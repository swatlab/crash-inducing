    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * vim: set ts=2 sw=2 et tw=78:
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Steve Clark <buster@netscape.com>
 5147:  *   Håkan Waara <hwaara@chello.se>
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Daniel Glazman <glazman@netscape.com>
38005:  *   Mats Palmgren <matspal@gmail.com>
56647:  *   Mihai Șucan <mihai.sucan@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  *
    1:  * This Original Code has been modified by IBM Corporation.
    1:  * Modifications made by IBM described herein are
    1:  * Copyright (c) International Business Machines
    1:  * Corporation, 2000
    1:  *
    1:  * Modifications to Mozilla code or documentation
    1:  * identified per MPL Section 3.3
    1:  *
    1:  * Date         Modified by     Description of modification
    1:  * 05/03/2000   IBM Corp.       Observer events for reflow states
    1:  */
    1: 
    1: /* a presentation of a document, part 2 */
    1: 
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIContent.h"
41930: #include "mozilla/dom/Element.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMXULDocument.h"
    1: #include "nsStubDocumentObserver.h"
    1: #include "nsStyleSet.h"
42163: #include "nsCSSStyleSheet.h" // XXX for UA sheet loading hack, can this go away please?
    1: #include "nsIDOMCSSStyleSheet.h"  // for Pref-related rule management (bugs 22963,20760,31816)
    1: #include "nsINameSpaceManager.h"  // for Pref-related rule management (bugs 22963,20760,31816)
    1: #include "nsIServiceManager.h"
    1: #include "nsFrame.h"
    1: #include "nsIViewManager.h"
    1: #include "nsCRT.h"
    1: #include "nsCRTGlue.h"
    1: #include "prlog.h"
    1: #include "prmem.h"
    1: #include "prprf.h"
    1: #include "prinrval.h"
24551: #include "nsTArray.h"
    1: #include "nsCOMArray.h"
    1: #include "nsHashtable.h"
    1: #include "nsIViewObserver.h"
    1: #include "nsContainerFrame.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsEventStateManager.h"
    1: #include "nsDOMEvent.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsContentUtils.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionController.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOM3Node.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsRange.h"
    1: #include "nsCSSPseudoElements.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsWeakReference.h"
    1: #include "nsIPageSequenceFrame.h"
15969: #include "nsCaret.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIXPointer.h"
    1: #include "nsIDOMXMLDocument.h"
    1: #include "nsIParser.h"
    1: #include "nsParserCIID.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsIDOMNSHTMLTextAreaElement.h"
    1: #include "nsViewsCID.h"
31619: #include "nsPresArena.h"
    1: #include "nsFrameManager.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsILineIterator.h" // for ScrollContentIntoView
    1: #include "nsWeakPtr.h"
    1: #include "pldhash.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIObserver.h"
    1: #include "nsIDocShell.h"        // for reflow observation
    1: #include "nsIBaseWindow.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsCSSRendering.h"
    1:   // for |#ifdef DEBUG| code
    1: #include "prenv.h"
    1: #include "nsIAttribute.h"
    1: #include "nsIGlobalHistory2.h"
    1: #include "nsDisplayList.h"
    1: #include "nsIRegion.h"
    1: #include "nsRegion.h"
    1: 
27962: #ifdef MOZ_REFLOW_PERF
    1: #include "nsIRenderingContext.h"
    1: #include "nsIFontMetrics.h"
    1: #endif
    1: 
    1: #include "nsIReflowCallback.h"
    1: 
    1: #include "nsPIDOMWindow.h"
29018: #include "nsFocusManager.h"
    1: #include "nsIPluginInstance.h"
    1: #include "nsIObjectFrame.h"
    1: #include "nsIObjectLoadingContent.h"
    1: #include "nsNetUtil.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsStyleSheetService.h"
    1: #include "gfxImageSurface.h"
    1: #include "gfxContext.h"
15753: #ifdef MOZ_MEDIA
21006: #include "nsHTMLMediaElement.h"
15753: #endif
38870: #ifdef MOZ_SMIL
38870: #include "nsSMILAnimationController.h"
38870: #endif
    1: 
50698: #include "nsRefreshDriver.h"
50698: 
    1: // Drag & Drop, Clipboard
    1: #include "nsWidgetsCID.h"
    1: #include "nsIClipboard.h"
    1: #include "nsIClipboardHelper.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIURI.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "prtime.h"
    1: #include "prlong.h"
    1: #include "nsIDragService.h"
    1: #include "nsCopySupport.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMHTMLAreaElement.h"
    1: #include "nsIDOMHTMLLinkElement.h"
    1: #include "nsITimer.h"
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
42313: #include "nsAccessible.h"
    1: #endif
    1: 
    1: // For style data reconstruction
    1: #include "nsStyleChangeList.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #ifdef MOZ_XUL
 3129: #include "nsMenuFrame.h"
20988: #include "nsTreeBodyFrame.h"
23881: #include "nsIBoxObject.h"
23881: #include "nsITreeBoxObject.h"
23881: #include "nsMenuPopupFrame.h"
23881: #include "nsITreeColumns.h"
23881: #include "nsIDOMXULMultSelectCntrlEl.h"
23881: #include "nsIDOMXULSelectCntrlItemEl.h"
23881: #include "nsIDOMXULMenuListElement.h"
23881: 
    1: #endif
    1: #include "nsPlaceholderFrame.h"
34149: #include "nsCanvasFrame.h"
    1: 
    1: // Content viewer interfaces
    1: #include "nsIContentViewer.h"
 1735: #include "imgIEncoder.h"
 1735: #include "gfxPlatform.h"
    1: 
42480: #include "mozilla/FunctionTimer.h"
42480: 
48947: #include "Layers.h"
48947: 
42480: #ifdef NS_FUNCTION_TIMER
42480: #define NS_TIME_FUNCTION_DECLARE_DOCURL                \
42480:   nsCAutoString docURL__("N/A");                       \
42480:   nsIURI *uri__ = mDocument->GetDocumentURI();         \
42480:   if (uri__) uri__->GetSpec(docURL__);
42480: #define NS_TIME_FUNCTION_WITH_DOCURL                   \
42480:   NS_TIME_FUNCTION_DECLARE_DOCURL                      \
42480:   NS_TIME_FUNCTION_MIN_FMT(1.0,                        \
42480:      "%s (line %d) (document: %s)", MOZ_FUNCTION_NAME, \
42480:      __LINE__, docURL__.get())
42480: #else
42480: #define NS_TIME_FUNCTION_WITH_DOCURL do{} while(0)
42480: #endif
42480: 
    1: #include "nsContentCID.h"
    1: static NS_DEFINE_IID(kRangeCID,     NS_RANGE_CID);
    1: 
46974: /* for NS_MEMORY_REPORTER_IMPLEMENT */
46974: #include "nsIMemoryReporter.h"
46974: 
47737: using namespace mozilla;
48947: using namespace mozilla::dom;
38805: using namespace mozilla::layers;
38805: 
 1071: PRBool nsIPresShell::gIsAccessibilityActive = PR_FALSE;
57052: CapturingContentInfo nsIPresShell::gCaptureInfo =
57052:   { PR_FALSE /* mAllowed */,     PR_FALSE /* mRetargetToElement */,
57052:     PR_FALSE /* mPreventDrag */, nsnull /* mContent */ };
50720: nsIContent* nsIPresShell::gKeyDownTarget;
 1071: 
54080: static PRUint32
54080: ChangeFlag(PRUint32 aFlags, PRBool aOnOff, PRUint32 aFlag)
54080: {
54080:   PRUint32 flags;
54080:   if (aOnOff) {
54080:     flags = (aFlags | aFlag);
54080:   } else {
54080:     flags = (aFlag & ~aFlag);
54080:   }
54080:   return flags;
54080: }
54080: 
    1: // convert a color value to a string, in the CSS format #RRGGBB
    1: // *  - initially created for bugs 31816, 20760, 22963
    1: static void ColorToString(nscolor aColor, nsAutoString &aString);
    1: 
    1: // Class ID's
    1: static NS_DEFINE_CID(kFrameSelectionCID, NS_FRAMESELECTION_CID);
    1: 
    1: // RangePaintInfo is used to paint ranges to offscreen buffers
    1: struct RangePaintInfo {
    1:   nsCOMPtr<nsIRange> mRange;
    1:   nsDisplayListBuilder mBuilder;
    1:   nsDisplayList mList;
    1: 
    1:   // offset of builder's reference frame to the root frame
    1:   nsPoint mRootOffset;
    1: 
    1:   RangePaintInfo(nsIRange* aRange, nsIFrame* aFrame)
57094:     : mRange(aRange), mBuilder(aFrame, nsDisplayListBuilder::PAINTING, PR_FALSE)
    1:   {
43900:     MOZ_COUNT_CTOR(RangePaintInfo);
    1:   }
    1: 
    1:   ~RangePaintInfo()
    1:   {
    1:     mList.DeleteAll();
43900:     MOZ_COUNT_DTOR(RangePaintInfo);
    1:   }
    1: };
    1: 
    1: #undef NOISY
    1: 
    1: // ----------------------------------------------------------------------
    1: 
    1: #ifdef NS_DEBUG
    1: // Set the environment variable GECKO_VERIFY_REFLOW_FLAGS to one or
    1: // more of the following flags (comma separated) for handy debug
    1: // output.
    1: static PRUint32 gVerifyReflowFlags;
    1: 
    1: struct VerifyReflowFlags {
    1:   const char*    name;
    1:   PRUint32 bit;
    1: };
    1: 
    1: static const VerifyReflowFlags gFlags[] = {
    1:   { "verify",                VERIFY_REFLOW_ON },
    1:   { "reflow",                VERIFY_REFLOW_NOISY },
    1:   { "all",                   VERIFY_REFLOW_ALL },
    1:   { "list-commands",         VERIFY_REFLOW_DUMP_COMMANDS },
    1:   { "noisy-commands",        VERIFY_REFLOW_NOISY_RC },
    1:   { "really-noisy-commands", VERIFY_REFLOW_REALLY_NOISY_RC },
    1:   { "resize",                VERIFY_REFLOW_DURING_RESIZE_REFLOW },
    1: };
    1: 
    1: #define NUM_VERIFY_REFLOW_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
    1: 
    1: static void
    1: ShowVerifyReflowFlags()
    1: {
    1:   printf("Here are the available GECKO_VERIFY_REFLOW_FLAGS:\n");
    1:   const VerifyReflowFlags* flag = gFlags;
    1:   const VerifyReflowFlags* limit = gFlags + NUM_VERIFY_REFLOW_FLAGS;
    1:   while (flag < limit) {
    1:     printf("  %s\n", flag->name);
    1:     ++flag;
    1:   }
    1:   printf("Note: GECKO_VERIFY_REFLOW_FLAGS is a comma separated list of flag\n");
    1:   printf("names (no whitespace)\n");
    1: }
    1: #endif
    1: 
    1: //========================================================================
    1: //========================================================================
    1: //========================================================================
    1: #ifdef MOZ_REFLOW_PERF
    1: class ReflowCountMgr;
    1: 
    1: static const char kGrandTotalsStr[] = "Grand Totals";
    1: 
    1: // Counting Class
    1: class ReflowCounter {
    1: public:
    1:   ReflowCounter(ReflowCountMgr * aMgr = nsnull);
    1:   ~ReflowCounter();
    1: 
    1:   void ClearTotals();
    1:   void DisplayTotals(const char * aStr);
    1:   void DisplayDiffTotals(const char * aStr);
    1:   void DisplayHTMLTotals(const char * aStr);
    1: 
    1:   void Add()                { mTotal++;         }
    1:   void Add(PRUint32 aTotal) { mTotal += aTotal; }
    1: 
    1:   void CalcDiffInTotals();
    1:   void SetTotalsCache();
    1: 
    1:   void SetMgr(ReflowCountMgr * aMgr) { mMgr = aMgr; }
    1: 
    1:   PRUint32 GetTotal() { return mTotal; }
    1:   
    1: protected:
    1:   void DisplayTotals(PRUint32 aTotal, const char * aTitle);
    1:   void DisplayHTMLTotals(PRUint32 aTotal, const char * aTitle);
    1: 
    1:   PRUint32 mTotal;
    1:   PRUint32 mCacheTotal;
    1: 
    1:   ReflowCountMgr * mMgr; // weak reference (don't delete)
    1: };
    1: 
    1: // Counting Class
    1: class IndiReflowCounter {
    1: public:
    1:   IndiReflowCounter(ReflowCountMgr * aMgr = nsnull)
    1:     : mFrame(nsnull),
    1:       mCount(0),
    1:       mMgr(aMgr),
    1:       mCounter(aMgr),
    1:       mHasBeenOutput(PR_FALSE)
    1:     {}
    1:   virtual ~IndiReflowCounter() {}
    1: 
    1:   nsAutoString mName;
    1:   nsIFrame *   mFrame;   // weak reference (don't delete)
    1:   PRInt32      mCount;
    1: 
    1:   ReflowCountMgr * mMgr; // weak reference (don't delete)
    1: 
    1:   ReflowCounter mCounter;
    1:   PRBool        mHasBeenOutput;
    1: 
    1: };
    1: 
    1: //--------------------
    1: // Manager Class
    1: //--------------------
    1: class ReflowCountMgr {
    1: public:
    1:   ReflowCountMgr();
    1:   virtual ~ReflowCountMgr();
    1: 
    1:   void ClearTotals();
    1:   void ClearGrandTotals();
    1:   void DisplayTotals(const char * aStr);
    1:   void DisplayHTMLTotals(const char * aStr);
    1:   void DisplayDiffsInTotals(const char * aStr);
    1: 
    1:   void Add(const char * aName, nsIFrame * aFrame);
    1:   ReflowCounter * LookUp(const char * aName);
    1: 
    1:   void PaintCount(const char * aName, nsIRenderingContext* aRenderingContext, nsPresContext* aPresContext, nsIFrame * aFrame, PRUint32 aColor);
    1: 
    1:   FILE * GetOutFile() { return mFD; }
    1: 
    1:   PLHashTable * GetIndiFrameHT() { return mIndiFrameCounts; }
    1: 
    1:   void SetPresContext(nsPresContext * aPresContext) { mPresContext = aPresContext; } // weak reference
    1:   void SetPresShell(nsIPresShell* aPresShell) { mPresShell= aPresShell; } // weak reference
    1: 
    1:   void SetDumpFrameCounts(PRBool aVal)         { mDumpFrameCounts = aVal; }
    1:   void SetDumpFrameByFrameCounts(PRBool aVal)  { mDumpFrameByFrameCounts = aVal; }
    1:   void SetPaintFrameCounts(PRBool aVal)        { mPaintFrameByFrameCounts = aVal; }
    1: 
30512:   PRBool IsPaintingFrameCounts() { return mPaintFrameByFrameCounts; }
30512: 
    1: protected:
    1:   void DisplayTotals(PRUint32 aTotal, PRUint32 * aDupArray, char * aTitle);
    1:   void DisplayHTMLTotals(PRUint32 aTotal, PRUint32 * aDupArray, char * aTitle);
    1: 
20261:   static PRIntn RemoveItems(PLHashEntry *he, PRIntn i, void *arg);
20261:   static PRIntn RemoveIndiItems(PLHashEntry *he, PRIntn i, void *arg);
    1:   void CleanUp();
    1: 
    1:   // stdout Output Methods
20261:   static PRIntn DoSingleTotal(PLHashEntry *he, PRIntn i, void *arg);
20261:   static PRIntn DoSingleIndi(PLHashEntry *he, PRIntn i, void *arg);
    1: 
    1:   void DoGrandTotals();
    1:   void DoIndiTotalsTree();
    1: 
    1:   // HTML Output Methods
20261:   static PRIntn DoSingleHTMLTotal(PLHashEntry *he, PRIntn i, void *arg);
    1:   void DoGrandHTMLTotals();
    1: 
    1:   // Zero Out the Totals
20261:   static PRIntn DoClearTotals(PLHashEntry *he, PRIntn i, void *arg);
    1: 
    1:   // Displays the Diff Totals
20261:   static PRIntn DoDisplayDiffTotals(PLHashEntry *he, PRIntn i, void *arg);
    1: 
    1:   PLHashTable * mCounts;
    1:   PLHashTable * mIndiFrameCounts;
    1:   FILE * mFD;
    1:   
    1:   PRBool mDumpFrameCounts;
    1:   PRBool mDumpFrameByFrameCounts;
    1:   PRBool mPaintFrameByFrameCounts;
    1: 
    1:   PRBool mCycledOnce;
    1: 
    1:   // Root Frame for Individual Tracking
    1:   nsPresContext * mPresContext;
    1:   nsIPresShell*    mPresShell;
    1: 
    1:   // ReflowCountMgr gReflowCountMgr;
    1: };
    1: #endif
    1: //========================================================================
    1: 
    1: // comment out to hide caret
    1: #define SHOW_CARET
    1: 
    1: // The upper bound on the amount of time to spend reflowing, in
    1: // microseconds.  When this bound is exceeded and reflow commands are
    1: // still queued up, a reflow event is posted.  The idea is for reflow
    1: // to not hog the processor beyond the time specifed in
    1: // gMaxRCProcessingTime.  This data member is initialized from the
    1: // layout.reflow.timeslice pref.
    1: #define NS_MAX_REFLOW_TIME    1000000
    1: static PRInt32 gMaxRCProcessingTime = -1;
    1: 
    1: #define MARK_INCREMENT 50
    1: #define BLOCK_INCREMENT 4044 /* a bit under 4096, for malloc overhead */
    1: 
    1: /**A block of memory that the stack will 
    1:  * chop up and hand out
    1:  */
    1: struct StackBlock {
    1:    
    1:    // a block of memory.  Note that this must be first so that it will
    1:    // be aligned.
    1:    char mBlock[BLOCK_INCREMENT];
    1: 
    1:    // another block of memory that would only be created
    1:    // if our stack overflowed. Yes we have the ability
    1:    // to grow on a stack overflow
    1:    StackBlock* mNext;
    1: 
    1:    StackBlock() : mNext(nsnull) { }
    1:    ~StackBlock() { }
    1: };
    1: 
    1: /* we hold an array of marks. A push pushes a mark on the stack
    1:  * a pop pops it off.
    1:  */
    1: struct StackMark {
    1:    // the block of memory we are currently handing out chunks of
    1:    StackBlock* mBlock;
    1:    
    1:    // our current position in the memory
    1:    size_t mPos;
    1: };
    1: 
    1: 
    1: /* A stack arena allows a stack based interface to a block of memory.
    1:  * It should be used when you need to allocate some temporary memory that
    1:  * you will immediately return.
    1:  */
    1: class StackArena {
    1: public:
    1:   StackArena();
    1:   ~StackArena();
    1: 
    1:   nsresult Init() { return mBlocks ? NS_OK : NS_ERROR_OUT_OF_MEMORY; }
    1: 
    1:   // Memory management functions
    1:   void* Allocate(size_t aSize);
    1:   void Push();
    1:   void Pop();
    1: 
42982:   PRUint32 Size() {
42982:     PRUint32 result = 0;
42982:     StackBlock *block = mBlocks;
42982:     while (block) {
42982:       result += sizeof(StackBlock);
42982:       block = block->mNext;
42982:     }
42982:     return result;
42982:   }
42982: 
    1: private:
    1:   // our current position in memory
    1:   size_t mPos;
    1: 
    1:   // a list of memory block. Usually there is only one
    1:   // but if we overrun our stack size we can get more memory.
    1:   StackBlock* mBlocks;
    1: 
    1:   // the current block of memory we are passing our chucks of
    1:   StackBlock* mCurBlock;
    1: 
    1:   // our stack of mark where push has been called
    1:   StackMark* mMarks;
    1: 
    1:   // the current top of the mark list
    1:   PRUint32 mStackTop;
    1: 
    1:   // the size of the mark array
    1:   PRUint32 mMarkLength;
    1: };
    1: 
    1: 
    1: 
    1: StackArena::StackArena()
    1: {
    1:   mMarkLength = 0;
    1:   mMarks = nsnull;
    1: 
    1:   // allocate our stack memory
    1:   mBlocks = new StackBlock();
    1:   mCurBlock = mBlocks;
    1: 
    1:   mStackTop = 0;
    1:   mPos = 0;
    1: }
    1: 
    1: StackArena::~StackArena()
    1: {
    1:   // free up our data
    1:   delete[] mMarks;
    1:   while(mBlocks)
    1:   {
    1:     StackBlock* toDelete = mBlocks;
    1:     mBlocks = mBlocks->mNext;
    1:     delete toDelete;
    1:   }
    1: } 
    1: 
    1: void
    1: StackArena::Push()
    1: {
    1:   // Resize the mark array if we overrun it.  Failure to allocate the
    1:   // mark array is not fatal; we just won't free to that mark.  This
    1:   // allows callers not to worry about error checking.
    1:   if (mStackTop >= mMarkLength)
    1:   {
    1:     PRUint32 newLength = mStackTop + MARK_INCREMENT;
    1:     StackMark* newMarks = new StackMark[newLength];
    1:     if (newMarks) {
    1:       if (mMarkLength)
    1:         memcpy(newMarks, mMarks, sizeof(StackMark)*mMarkLength);
    1:       // Fill in any marks that we couldn't allocate during a prior call
    1:       // to Push().
    1:       for (; mMarkLength < mStackTop; ++mMarkLength) {
    1:         NS_NOTREACHED("should only hit this on out-of-memory");
    1:         newMarks[mMarkLength].mBlock = mCurBlock;
    1:         newMarks[mMarkLength].mPos = mPos;
    1:       }
    1:       delete [] mMarks;
    1:       mMarks = newMarks;
    1:       mMarkLength = newLength;
    1:     }
    1:   }
    1: 
    1:   // set a mark at the top (if we can)
    1:   NS_ASSERTION(mStackTop < mMarkLength, "out of memory");
    1:   if (mStackTop < mMarkLength) {
    1:     mMarks[mStackTop].mBlock = mCurBlock;
    1:     mMarks[mStackTop].mPos = mPos;
    1:   }
    1: 
    1:   mStackTop++;
    1: }
    1: 
    1: void*
    1: StackArena::Allocate(size_t aSize)
    1: {
    1:   NS_ASSERTION(mStackTop > 0, "Allocate called without Push");
    1: 
    1:   // make sure we are aligned. Beard said 8 was safer then 4. 
    1:   // Round size to multiple of 8
    1:   aSize = PR_ROUNDUP(aSize, 8);
    1: 
    1:   // if the size makes the stack overflow. Grab another block for the stack
    1:   if (mPos + aSize >= BLOCK_INCREMENT)
    1:   {
    1:     NS_ASSERTION(aSize <= BLOCK_INCREMENT,"Requested memory is greater that our block size!!");
    1:     if (mCurBlock->mNext == nsnull)
    1:       mCurBlock->mNext = new StackBlock();
    1: 
    1:     mCurBlock =  mCurBlock->mNext;
    1:     mPos = 0;
    1:   }
    1: 
    1:   // return the chunk they need.
    1:   void *result = mCurBlock->mBlock + mPos;
    1:   mPos += aSize;
    1: 
    1:   return result;
    1: }
    1: 
    1: void
    1: StackArena::Pop()
    1: {
    1:   // pop off the mark
    1:   NS_ASSERTION(mStackTop > 0, "unmatched pop");
    1:   mStackTop--;
    1: 
    1:   if (mStackTop >= mMarkLength) {
    1:     // We couldn't allocate the marks array at the time of the push, so
    1:     // we don't know where we're freeing to.
    1:     NS_NOTREACHED("out of memory");
    1:     if (mStackTop == 0) {
    1:       // But we do know if we've completely pushed the stack.
    1:       mCurBlock = mBlocks;
    1:       mPos = 0;
    1:     }
    1:     return;
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   // Mark the "freed" memory with 0xdd to help with debugging of memory
    1:   // allocation problems.
    1:   {
    1:     StackBlock *block = mMarks[mStackTop].mBlock, *block_end = mCurBlock;
    1:     size_t pos = mMarks[mStackTop].mPos;
    1:     for (; block != block_end; block = block->mNext, pos = 0) {
    1:       memset(block->mBlock + pos, 0xdd, sizeof(block->mBlock) - pos);
    1:     }
    1:     memset(block->mBlock + pos, 0xdd, mPos - pos);
    1:   }
    1: #endif
    1: 
    1:   mCurBlock = mMarks[mStackTop].mBlock;
    1:   mPos      = mMarks[mStackTop].mPos;
    1: }
    1: 
    1: struct nsCallbackEventRequest
    1: {
    1:   nsIReflowCallback* callback;
    1:   nsCallbackEventRequest* next;
    1: };
    1: 
    1: // ----------------------------------------------------------------------------
38310: #define ASSERT_REFLOW_SCHEDULED_STATE()                                       \
38310:   NS_ASSERTION(mReflowScheduled ==                                            \
38310:                  GetPresContext()->RefreshDriver()->                          \
50365:                    IsLayoutFlushObserver(this), "Unexpected state")
38310: 
    1: class nsPresShellEventCB;
29804: class nsAutoCauseReflowNotifier;
    1: 
    1: class PresShell : public nsIPresShell, public nsIViewObserver,
    1:                   public nsStubDocumentObserver,
    1:                   public nsISelectionController, public nsIObserver,
59572:                   public nsSupportsWeakReference,
59572:                   public nsIPresShell_MOZILLA_2_0_BRANCH
    1: {
    1: public:
    1:   PresShell();
    1: 
    1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
    1: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIPresShell
39668:   virtual NS_HIDDEN_(nsresult) Init(nsIDocument* aDocument,
    1:                                    nsPresContext* aPresContext,
    1:                                    nsIViewManager* aViewManager,
    1:                                    nsStyleSet* aStyleSet,
    1:                                    nsCompatibility aCompatMode);
39668:   virtual NS_HIDDEN_(void) Destroy();
    1: 
32511:   virtual NS_HIDDEN_(void*) AllocateFrame(nsQueryFrame::FrameIID aCode,
32511:                                           size_t aSize);
32511:   virtual NS_HIDDEN_(void)  FreeFrame(nsQueryFrame::FrameIID aCode,
31620:                                       void* aChunk);
31620: 
31620:   virtual NS_HIDDEN_(void*) AllocateMisc(size_t aSize);
31620:   virtual NS_HIDDEN_(void)  FreeMisc(size_t aSize, void* aChunk);
    1: 
    1:   // Dynamic stack memory allocation
    1:   virtual NS_HIDDEN_(void) PushStackMemory();
    1:   virtual NS_HIDDEN_(void) PopStackMemory();
    1:   virtual NS_HIDDEN_(void*) AllocateStackMemory(size_t aSize);
    1: 
39668:   virtual NS_HIDDEN_(nsresult) SetPreferenceStyleRules(PRBool aForceReflow);
    1: 
    1:   NS_IMETHOD GetSelection(SelectionType aType, nsISelection** aSelection);
    1:   virtual nsISelection* GetCurrentSelection(SelectionType aType);
    1: 
    1:   NS_IMETHOD SetDisplaySelection(PRInt16 aToggle);
    1:   NS_IMETHOD GetDisplaySelection(PRInt16 *aToggle);
56442:   NS_IMETHOD ScrollSelectionIntoView(SelectionType aType, SelectionRegion aRegion,
56442:                                      PRInt16 aFlags);
    1:   NS_IMETHOD RepaintSelection(SelectionType aType);
    1: 
39668:   virtual NS_HIDDEN_(void) BeginObservingDocument();
39668:   virtual NS_HIDDEN_(void) EndObservingDocument();
39668:   virtual NS_HIDDEN_(nsresult) InitialReflow(nscoord aWidth, nscoord aHeight);
39668:   virtual NS_HIDDEN_(nsresult) ResizeReflow(nscoord aWidth, nscoord aHeight);
54649:   virtual NS_HIDDEN_(nsresult) ResizeReflowOverride(nscoord aWidth, nscoord aHeight);
39668:   virtual NS_HIDDEN_(void) StyleChangeReflow();
39668:   virtual NS_HIDDEN_(nsIPageSequenceFrame*) GetPageSequenceFrame() const;
10998:   virtual NS_HIDDEN_(nsIFrame*) GetRealPrimaryFrameFor(nsIContent* aContent) const;
    1: 
39668:   virtual NS_HIDDEN_(nsIFrame*) GetPlaceholderFrameFor(nsIFrame* aFrame) const;
39668:   virtual NS_HIDDEN_(void) FrameNeedsReflow(nsIFrame *aFrame, IntrinsicDirty aIntrinsicDirty,
 1161:                                             nsFrameState aBitToAdd);
39668:   virtual NS_HIDDEN_(void) FrameNeedsToContinueReflow(nsIFrame *aFrame);
39668:   virtual NS_HIDDEN_(void) CancelAllPendingReflows();
40044:   virtual NS_HIDDEN_(PRBool) IsSafeToFlush() const;
39668:   virtual NS_HIDDEN_(void) FlushPendingNotifications(mozFlushType aType);
    1: 
    1:   /**
    1:    * Recreates the frames for a node
    1:    */
40046:   virtual NS_HIDDEN_(nsresult) RecreateFramesFor(nsIContent* aContent);
    1: 
    1:   /**
    1:    * Post a callback that should be handled after reflow has finished.
    1:    */
40046:   virtual NS_HIDDEN_(nsresult) PostReflowCallback(nsIReflowCallback* aCallback);
40046:   virtual NS_HIDDEN_(void) CancelReflowCallback(nsIReflowCallback* aCallback);
40046: 
40046:   virtual NS_HIDDEN_(void) ClearFrameRefs(nsIFrame* aFrame);
51038:   virtual NS_HIDDEN_(already_AddRefed<nsIRenderingContext>) GetReferenceRenderingContext();
40046:   virtual NS_HIDDEN_(nsresult) GoToAnchor(const nsAString& aAnchorName, PRBool aScroll);
40046:   virtual NS_HIDDEN_(nsresult) ScrollToAnchor();
40046: 
40046:   virtual NS_HIDDEN_(nsresult) ScrollContentIntoView(nsIContent* aContent,
    1:                                                      PRIntn      aVPercent,
56647:                                                      PRIntn      aHPercent,
56647:                                                      PRUint32    aFlags);
37077:   virtual PRBool ScrollFrameRectIntoView(nsIFrame*     aFrame,
37077:                                          const nsRect& aRect,
37077:                                          PRIntn        aVPercent,
37077:                                          PRIntn        aHPercent,
37077:                                          PRUint32      aFlags);
37073:   virtual nsRectVisibility GetRectVisibility(nsIFrame *aFrame,
37073:                                              const nsRect &aRect,
40053:                                              nscoord aMinTwips) const;
    1: 
40046:   virtual NS_HIDDEN_(void) SetIgnoreFrameDestruction(PRBool aIgnore);
40046:   virtual NS_HIDDEN_(void) NotifyDestroyingFrame(nsIFrame* aFrame);
40046: 
40053:   virtual NS_HIDDEN_(nsresult) GetLinkLocation(nsIDOMNode* aNode, nsAString& aLocationString) const;
40046: 
40046:   virtual NS_HIDDEN_(nsresult) CaptureHistoryState(nsILayoutHistoryState** aLayoutHistoryState, PRBool aLeavingPage);
40020: 
40049:   virtual NS_HIDDEN_(void) UnsuppressPainting();
40020: 
    1:   virtual nsresult GetAgentStyleSheets(nsCOMArray<nsIStyleSheet>& aSheets);
    1:   virtual nsresult SetAgentStyleSheets(const nsCOMArray<nsIStyleSheet>& aSheets);
    1: 
    1:   virtual nsresult AddOverrideStyleSheet(nsIStyleSheet *aSheet);
    1:   virtual nsresult RemoveOverrideStyleSheet(nsIStyleSheet *aSheet);
    1: 
40055:   virtual NS_HIDDEN_(nsresult) HandleEventWithTarget(nsEvent* aEvent, nsIFrame* aFrame,
    1:                                                      nsIContent* aContent,
    1:                                                      nsEventStatus* aStatus);
40047:   virtual NS_HIDDEN_(nsIFrame*) GetEventTargetFrame();
40047:   virtual NS_HIDDEN_(already_AddRefed<nsIContent>) GetEventTargetContent(nsEvent* aEvent);
40020: 
    1: 
    1:   virtual nsresult ReconstructFrames(void);
    1:   virtual void Freeze();
    1:   virtual void Thaw();
25722:   virtual void FireOrClearDelayedEvents(PRBool aFireEvents);
    1: 
 5680:   virtual nsIFrame* GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt);
 5680: 
40052:   virtual NS_HIDDEN_(nsresult) RenderDocument(const nsRect& aRect, PRUint32 aFlags,
    1:                                               nscolor aBackgroundColor,
 1735:                                               gfxContext* aThebesContext);
    1: 
    1:   virtual already_AddRefed<gfxASurface> RenderNode(nsIDOMNode* aNode,
43137:                                                    nsIntRegion* aRegion,
23738:                                                    nsIntPoint& aPoint,
23738:                                                    nsIntRect* aScreenRect);
    1: 
    1:   virtual already_AddRefed<gfxASurface> RenderSelection(nsISelection* aSelection,
23738:                                                         nsIntPoint& aPoint,
23738:                                                         nsIntRect* aScreenRect);
    1: 
47198:   virtual already_AddRefed<nsPIDOMWindow> GetRootWindow();
47198: 
48947:   virtual LayerManager* GetLayerManager();
48947: 
54080:   virtual void SetIgnoreViewportScrolling(PRBool aIgnore);
54080: 
54080:   virtual void SetDisplayPort(const nsRect& aDisplayPort);
54080: 
54081:   virtual nsresult SetResolution(float aXResolution, float aYResolution);
54081: 
52492:  virtual void SynthesizeMouseMove(PRBool aFromScroll);
52492: 
    1:   //nsIViewObserver interface
    1: 
38805:   NS_IMETHOD Paint(nsIView* aDisplayRoot,
38805:                    nsIView* aViewToPaint,
38805:                    nsIWidget* aWidget,
38805:                    const nsRegion& aDirtyRegion,
47899:                    const nsIntRegion& aIntDirtyRegion,
47756:                    PRBool aPaintDefaultBackground,
47756:                    PRBool aWillSendDidPaint);
    1:   NS_IMETHOD HandleEvent(nsIView*        aView,
    1:                          nsGUIEvent*     aEvent,
58209:                          PRBool          aDontRetargetEvents,
    1:                          nsEventStatus*  aEventStatus);
40055:   virtual NS_HIDDEN_(nsresult) HandleDOMEventWithTarget(nsIContent* aTargetContent,
    1:                                                         nsEvent* aEvent,
    1:                                                         nsEventStatus* aStatus);
40055:   virtual NS_HIDDEN_(nsresult) HandleDOMEventWithTarget(nsIContent* aTargetContent,
29844:                                                         nsIDOMEvent* aEvent,
29844:                                                         nsEventStatus* aStatus);
    1:   NS_IMETHOD ResizeReflow(nsIView *aView, nscoord aWidth, nscoord aHeight);
50857:   NS_IMETHOD_(PRBool) ShouldIgnoreInvalidation();
47756:   NS_IMETHOD_(void) WillPaint(PRBool aWillSendDidPaint);
47756:   NS_IMETHOD_(void) DidPaint();
22471:   NS_IMETHOD_(void) DispatchSynthMouseMove(nsGUIEvent *aEvent,
22471:                                            PRBool aFlushOnHoverChange);
32435:   NS_IMETHOD_(void) ClearMouseCapture(nsIView* aView);
    1: 
    1:   // caret handling
40053:   virtual NS_HIDDEN_(already_AddRefed<nsCaret>) GetCaret() const;
40045:   virtual NS_HIDDEN_(void) MaybeInvalidateCaretPosition();
    1:   NS_IMETHOD SetCaretEnabled(PRBool aInEnable);
    1:   NS_IMETHOD SetCaretReadOnly(PRBool aReadOnly);
    1:   NS_IMETHOD GetCaretEnabled(PRBool *aOutEnabled);
    1:   NS_IMETHOD SetCaretVisibilityDuringSelection(PRBool aVisibility);
14068:   NS_IMETHOD GetCaretVisible(PRBool *_retval);
15969:   virtual void SetCaret(nsCaret *aNewCaret);
 6232:   virtual void RestoreCaret();
    1: 
    1:   NS_IMETHOD SetSelectionFlags(PRInt16 aInEnable);
    1:   NS_IMETHOD GetSelectionFlags(PRInt16 *aOutEnable);
    1: 
    1:   // nsISelectionController
    1: 
    1:   NS_IMETHOD CharacterMove(PRBool aForward, PRBool aExtend);
20532:   NS_IMETHOD CharacterExtendForDelete();
43298:   NS_IMETHOD CharacterExtendForBackspace();
    1:   NS_IMETHOD WordMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD WordExtendForDelete(PRBool aForward);
    1:   NS_IMETHOD LineMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD IntraLineMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD PageMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD ScrollPage(PRBool aForward);
    1:   NS_IMETHOD ScrollLine(PRBool aForward);
    1:   NS_IMETHOD ScrollHorizontal(PRBool aLeft);
    1:   NS_IMETHOD CompleteScroll(PRBool aForward);
    1:   NS_IMETHOD CompleteMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD SelectAll();
    1:   NS_IMETHOD CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, PRBool *_retval);
    1: 
    1:   // nsIDocumentObserver
56166:   NS_DECL_NSIDOCUMENTOBSERVER_BEGINUPDATE
56166:   NS_DECL_NSIDOCUMENTOBSERVER_ENDUPDATE
56166:   NS_DECL_NSIDOCUMENTOBSERVER_BEGINLOAD
56166:   NS_DECL_NSIDOCUMENTOBSERVER_ENDLOAD
56166:   NS_DECL_NSIDOCUMENTOBSERVER_CONTENTSTATESCHANGED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_DOCUMENTSTATESCHANGED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETADDED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETREMOVED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETAPPLICABLESTATECHANGED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLERULECHANGED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLERULEADDED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLERULEREMOVED
    1: 
 3410:   // nsIMutationObserver
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
35534:   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTEWILLCHANGE
 3410:   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
 3410: 
    1:   NS_DECL_NSIOBSERVER
    1: 
    1: #ifdef MOZ_REFLOW_PERF
40052:   virtual NS_HIDDEN_(void) DumpReflows();
40052:   virtual NS_HIDDEN_(void) CountReflows(const char * aName, nsIFrame * aFrame);
40052:   virtual NS_HIDDEN_(void) PaintCount(const char * aName,
40052:                                       nsIRenderingContext* aRenderingContext,
40052:                                       nsPresContext* aPresContext,
40052:                                       nsIFrame * aFrame,
40052:                                       PRUint32 aColor);
40052:   virtual NS_HIDDEN_(void) SetPaintFrameCount(PRBool aOn);
30512:   virtual PRBool IsPaintingFrameCounts();
    1: #endif
    1: 
    1: #ifdef DEBUG
    1:   virtual void ListStyleContexts(nsIFrame *aRootFrame, FILE *out,
    1:                                  PRInt32 aIndent = 0);
    1: 
    1:   virtual void ListStyleSheets(FILE *out, PRInt32 aIndent = 0);
    1:   virtual void VerifyStyleTree();
    1: #endif
    1: 
    1: #ifdef PR_LOGGING
    1:   static PRLogModuleInfo* gLog;
    1: #endif
    1: 
40052:   virtual NS_HIDDEN_(void) DisableNonTestMouseEvents(PRBool aDisable);
24947: 
27834:   virtual void UpdateCanvasBackground();
27834: 
29987:   virtual nsresult AddCanvasBackgroundColorItem(nsDisplayListBuilder& aBuilder,
29987:                                                 nsDisplayList& aList,
29987:                                                 nsIFrame* aFrame,
47739:                                                 const nsRect& aBounds,
35428:                                                 nscolor aBackstopColor,
35428:                                                 PRBool aForceDraw);
29987: 
49166:   virtual nsresult AddPrintPreviewBackgroundItem(nsDisplayListBuilder& aBuilder,
49166:                                                  nsDisplayList& aList,
49166:                                                  nsIFrame* aFrame,
49166:                                                  const nsRect& aBounds);
49166: 
49168:   virtual nscolor ComputeBackstopColor(nsIView* aDisplayRoot);
49168: 
50815:   virtual NS_HIDDEN_(nsresult) SetIsActive(PRBool aIsActive);
50815: 
59572:   virtual PRBool GetIsViewportOverridden() { return mViewportOverridden; }
59572: 
    1: protected:
    1:   virtual ~PresShell();
    1: 
27993:   void HandlePostedReflowCallbacks(PRBool aInterruptible);
 8509:   void CancelPostedReflowCallbacks();
    1: 
    1:   void UnsuppressAndInvalidate();
    1: 
29804:   void WillCauseReflow() {
29804:     nsContentUtils::AddScriptBlocker();
29804:     ++mChangeNestCount;
29804:   }
29804:   nsresult DidCauseReflow();
29804:   friend class nsAutoCauseReflowNotifier;
29804: 
    1:   void     WillDoReflow();
27993:   void     DidDoReflow(PRBool aInterruptible);
27993:   // ProcessReflowCommands returns whether we processed all our dirty roots
27993:   // without interruptions.
27993:   PRBool   ProcessReflowCommands(PRBool aInterruptible);
38310:   // MaybeScheduleReflow checks if posting a reflow is needed, then checks if
38310:   // the last reflow was interrupted. In the interrupted case ScheduleReflow is
29172:   // called off a timer, otherwise it is called directly.
38310:   void     MaybeScheduleReflow();
38310:   // Actually schedules a reflow.  This should only be called by
38310:   // MaybeScheduleReflow and the reflow timer ScheduleReflowOffTimer
38310:   // sets up.
38310:   void     ScheduleReflow();
    1: 
54649:   // Reflow regardless of whether the override bit has been set.
54649:   nsresult ResizeReflowIgnoreOverride(nscoord aWidth, nscoord aHeight);
54649: 
27993:   // DoReflow returns whether the reflow finished without interruption
27993:   PRBool DoReflow(nsIFrame* aFrame, PRBool aInterruptible);
  790: #ifdef DEBUG
  790:   void DoVerifyReflow();
  926:   void VerifyHasDirtyRootAncestor(nsIFrame* aFrame);
  790: #endif
  790: 
27993:   // Helper for ScrollContentIntoView
28165:   void DoScrollContentIntoView(nsIContent* aContent,
27993:                                PRIntn      aVPercent,
56647:                                PRIntn      aHPercent,
56647:                                PRUint32    aFlags);
27993: 
54080:   friend struct AutoRenderingStateSaveRestore;
54080:   friend struct RenderingState;
54080: 
54080:   struct RenderingState {
54080:     RenderingState(PresShell* aPresShell) 
54080:       : mRenderFlags(aPresShell->mRenderFlags)
54080:       , mDisplayPort(aPresShell->mDisplayPort)
54081:       , mXResolution(aPresShell->mXResolution)
54081:       , mYResolution(aPresShell->mYResolution)
54080:     { }
54080:     PRUint32 mRenderFlags;
54080:     nsRect mDisplayPort;
54081:     float mXResolution;
54081:     float mYResolution;
54080:   };
54080: 
54080:   struct AutoSaveRestoreRenderingState {
54080:     AutoSaveRestoreRenderingState(PresShell* aPresShell)
54080:       : mPresShell(aPresShell)
54080:       , mOldState(aPresShell)
54080:     {}
54080: 
54080:     ~AutoSaveRestoreRenderingState()
54080:     {
54080:       mPresShell->mRenderFlags = mOldState.mRenderFlags;
54080:       mPresShell->mDisplayPort = mOldState.mDisplayPort;
54081:       mPresShell->mXResolution = mOldState.mXResolution;
54081:       mPresShell->mYResolution = mOldState.mYResolution;
54080:     }
54080: 
54080:     PresShell* mPresShell;
54080:     RenderingState mOldState;
54080:   };
54080: 
54080:   void SetRenderingState(const RenderingState& aState);
54080: 
    1:   friend class nsPresShellEventCB;
    1: 
    1:   PRBool mCaretEnabled;
    1: #ifdef NS_DEBUG
    1:   nsresult CloneStyleSet(nsStyleSet* aSet, nsStyleSet** aResult);
    1:   PRBool VerifyIncrementalReflow();
    1:   PRBool mInVerifyReflow;
    1:   void ShowEventTargetDebug();
    1: #endif
    1: 
    1:     /**
    1:     * methods that manage rules that are used to implement the associated preferences
    1:     *  - initially created for bugs 31816, 20760, 22963
    1:     */
    1:   nsresult ClearPreferenceStyleRules(void);
    1:   nsresult CreatePreferenceStyleSheet(void);
    1:   nsresult SetPrefLinkRules(void);
    1:   nsresult SetPrefFocusRules(void);
    1:   nsresult SetPrefNoScriptRule();
    1:   nsresult SetPrefNoFramesRule(void);
    1: 
    1:   // methods for painting a range to an offscreen buffer
    1: 
    1:   // given a display list, clip the items within the list to
    1:   // the range
    1:   nsRect ClipListToRange(nsDisplayListBuilder *aBuilder,
    1:                          nsDisplayList* aList,
 4741:                          nsIRange* aRange);
    1: 
    1:   // create a RangePaintInfo for the range aRange containing the
    1:   // display list needed to paint the range to a surface
    1:   RangePaintInfo* CreateRangePaintInfo(nsIDOMRange* aRange,
47337:                                        nsRect& aSurfaceRect,
47337:                                        PRBool aForPrimarySelection);
    1: 
    1:   /*
    1:    * Paint the items to a new surface and return it.
    1:    *
    1:    * aSelection - selection being painted, if any
    1:    * aRegion - clip region, if any
    1:    * aArea - area that the surface occupies, relative to the root frame
    1:    * aPoint - reference point, typically the mouse position
    1:    * aScreenRect - [out] set to the area of the screen the painted area should
    1:    *               be displayed at
    1:    */
    1:   already_AddRefed<gfxASurface>
    1:   PaintRangePaintInfo(nsTArray<nsAutoPtr<RangePaintInfo> >* aItems,
    1:                       nsISelection* aSelection,
43137:                       nsIntRegion* aRegion,
    1:                       nsRect aArea,
23738:                       nsIntPoint& aPoint,
23738:                       nsIntRect* aScreenRect);
    1: 
    1:   /**
    1:    * Methods to handle changes to user and UA sheet lists that we get
    1:    * notified about.
    1:    */
    1:   void AddUserSheet(nsISupports* aSheet);
    1:   void AddAgentSheet(nsISupports* aSheet);
    1:   void RemoveSheet(nsStyleSet::sheetType aType, nsISupports* aSheet);
    1: 
  677:   // Hide a view if it is a popup
  677:   void HideViewIfPopup(nsIView* aView);
  677: 
  824:   // Utility method to restore the root scrollframe state
  824:   void RestoreRootScrollPosition();
  824: 
35522:   void MaybeReleaseCapturingContent()
35522:   {
35522:     nsCOMPtr<nsFrameSelection> frameSelection = FrameSelection();
35522:     if (frameSelection) {
35522:       frameSelection->SetMouseDownState(PR_FALSE);
35522:     }
35522:     if (gCaptureInfo.mContent &&
35522:         gCaptureInfo.mContent->GetOwnerDoc() == mDocument) {
35522:       SetCapturingContent(nsnull, 0);
35522:     }
35522:   }
35522: 
42163:   nsRefPtr<nsCSSStyleSheet> mPrefStyleSheet; // mStyleSet owns it but we
10382:                                              // maintain a ref, may be null
    1: #ifdef DEBUG
    1:   PRUint32                  mUpdateCount;
    1: #endif
    1:   // reflow roots that need to be reflowed, as both a queue and a hashtable
24551:   nsTArray<nsIFrame*> mDirtyRoots;
    1: 
    1:   PRPackedBool mDocumentLoading;
    1: 
    1:   PRPackedBool mIgnoreFrameDestruction;
    1:   PRPackedBool mHaveShutDown;
    1: 
54649:   PRPackedBool mViewportOverridden;
54649: 
55051:   PRPackedBool mLastRootReflowHadUnconstrainedHeight;
55051: 
29804:   // This is used to protect ourselves from triggering reflow while in the
29804:   // middle of frame construction and the like... it really shouldn't be
29804:   // needed, one hopes, but it is for now.
29804:   PRUint32  mChangeNestCount;
29804:   
    1:   nsIFrame*   mCurrentEventFrame;
    1:   nsCOMPtr<nsIContent> mCurrentEventContent;
24551:   nsTArray<nsIFrame*> mCurrentEventFrameStack;
    1:   nsCOMArray<nsIContent> mCurrentEventContentStack;
    1: 
12356:   nsCOMPtr<nsIContent>          mLastAnchorScrolledTo;
12356:   nscoord                       mLastAnchorScrollPositionY;
15969:   nsRefPtr<nsCaret>             mCaret;
15969:   nsRefPtr<nsCaret>             mOriginalCaret;
31619:   nsPresArena                   mFrameArena;
    1:   StackArena                    mStackArena;
    1:   nsCOMPtr<nsIDragService>      mDragService;
    1:   
27993: #ifdef DEBUG
27993:   // The reflow root under which we're currently reflowing.  Null when
27993:   // not in reflow.
27993:   nsIFrame* mCurrentReflowRoot;
27993: #endif
27993: 
27993:   // Set of frames that we should mark with NS_FRAME_HAS_DIRTY_CHILDREN after
27993:   // we finish reflowing mCurrentReflowRoot.
27993:   nsTHashtable< nsPtrHashKey<nsIFrame> > mFramesToDirty;
27993: 
27993:   // Information needed to properly handle scrolling content into view if the
27993:   // pre-scroll reflow flush can be interrupted.  mContentToScrollTo is
27993:   // non-null between the initial scroll attempt and the first time we finish
27993:   // processing all our dirty roots.  mContentScrollVPosition and
27993:   // mContentScrollHPosition are only used when it's non-null.
27993:   nsCOMPtr<nsIContent> mContentToScrollTo;
27993:   PRIntn mContentScrollVPosition;
27993:   PRIntn mContentScrollHPosition;
27993: 
28498:   class nsDelayedEvent
28498:   {
28498:   public:
28498:     virtual ~nsDelayedEvent() {};
28498:     virtual void Dispatch(PresShell* aShell) {}
28498:   };
28498: 
28498:   class nsDelayedInputEvent : public nsDelayedEvent
28498:   {
28498:   public:
28498:     virtual void Dispatch(PresShell* aShell)
28498:     {
28498:       if (mEvent && mEvent->widget) {
28498:         nsCOMPtr<nsIWidget> w = mEvent->widget;
28498:         nsEventStatus status;
28498:         w->DispatchEvent(mEvent, status);
28498:       }
28498:     }
28498: 
28498:   protected:
28498:     void Init(nsInputEvent* aEvent)
28498:     {
28498:       mEvent->time = aEvent->time;
28498:       mEvent->refPoint = aEvent->refPoint;
28498:       mEvent->isShift = aEvent->isShift;
28498:       mEvent->isControl = aEvent->isControl;
28498:       mEvent->isAlt = aEvent->isAlt;
28498:       mEvent->isMeta = aEvent->isMeta;
28498:     }
28498: 
28498:     nsDelayedInputEvent()
28498:     : nsDelayedEvent(), mEvent(nsnull) {}
28498: 
28498:     nsInputEvent* mEvent;
28498:   };
28498: 
28498:   class nsDelayedMouseEvent : public nsDelayedInputEvent
28498:   {
28498:   public:
28498:     nsDelayedMouseEvent(nsMouseEvent* aEvent) : nsDelayedInputEvent()
28498:     {
28498:       mEvent = new nsMouseEvent(NS_IS_TRUSTED_EVENT(aEvent),
28498:                                 aEvent->message,
28498:                                 aEvent->widget,
28498:                                 aEvent->reason,
28498:                                 aEvent->context);
28498:       if (mEvent) {
28498:         Init(aEvent);
28498:         static_cast<nsMouseEvent*>(mEvent)->clickCount = aEvent->clickCount;
28498:       }
28498:     }
28498: 
28498:     virtual ~nsDelayedMouseEvent()
28498:     {
28498:       delete static_cast<nsMouseEvent*>(mEvent);
28498:     }
28498:   };
28498: 
28498:   class nsDelayedKeyEvent : public nsDelayedInputEvent
28498:   {
28498:   public:
28498:     nsDelayedKeyEvent(nsKeyEvent* aEvent) : nsDelayedInputEvent()
28498:     {
28498:       mEvent = new nsKeyEvent(NS_IS_TRUSTED_EVENT(aEvent),
28498:                               aEvent->message,
28498:                               aEvent->widget);
28498:       if (mEvent) {
28498:         Init(aEvent);
28498:         static_cast<nsKeyEvent*>(mEvent)->keyCode = aEvent->keyCode;
28498:         static_cast<nsKeyEvent*>(mEvent)->charCode = aEvent->charCode;
28498:         static_cast<nsKeyEvent*>(mEvent)->alternativeCharCodes =
28498:           aEvent->alternativeCharCodes;
28498:         static_cast<nsKeyEvent*>(mEvent)->isChar = aEvent->isChar;
28498:       }
28498:     }
28498: 
28498:     virtual ~nsDelayedKeyEvent()
28498:     {
28498:       delete static_cast<nsKeyEvent*>(mEvent);
28498:     }
28498:   };
28498: 
28498:   PRPackedBool                         mNoDelayedMouseEvents;
28498:   PRPackedBool                         mNoDelayedKeyEvents;
28498:   nsTArray<nsAutoPtr<nsDelayedEvent> > mDelayedEvents;
25722: 
    1:   nsCallbackEventRequest* mFirstCallbackEventRequest;
    1:   nsCallbackEventRequest* mLastCallbackEventRequest;
    1: 
    1:   PRPackedBool      mIsDocumentGone;      // We've been disconnected from the document.
    1:                                           // We will refuse to paint the document until either
    1:                                           // (a) our timer fires or (b) all frames are constructed.
    1:   PRPackedBool      mShouldUnsuppressPainting;  // Indicates that it is safe to unlock painting once all pending
    1:                                                 // reflows have been processed.
    1:   nsCOMPtr<nsITimer> mPaintSuppressionTimer; // This timer controls painting suppression.  Until it fires
    1:                                              // or all frames are constructed, we won't paint anything but
    1:                                              // our <body> background and scrollbars.
    1: #define PAINTLOCK_EVENT_DELAY 250 // 250ms.  This is actually
    1:                                   // pref-controlled, but we use this
    1:                                   // value if we fail to get the pref
    1:                                   // for any reason.
    1: 
    1:   static void sPaintSuppressionCallback(nsITimer* aTimer, void* aPresShell); // A callback for the timer.
    1: 
38310:   // At least on Win32 and Mac after interupting a reflow we need to post
38310:   // the resume reflow event off a timer to avoid event starvation because
38310:   // posted messages are processed before other messages when the modal
38310:   // moving/sizing loop is running, see bug 491700 for details.
29172:   nsCOMPtr<nsITimer> mReflowContinueTimer;
29172:   static void sReflowContinueCallback(nsITimer* aTimer, void* aPresShell);
38310:   PRBool ScheduleReflowOffTimer();
29172:   
    1: #ifdef MOZ_REFLOW_PERF
    1:   ReflowCountMgr * mReflowCountMgr;
    1: #endif
    1: 
24947:   static PRBool sDisableNonTestMouseEvents;
24947: 
    1: private:
    1: 
    1:   PRBool InZombieDocument(nsIContent *aContent);
47198:   already_AddRefed<nsIPresShell> GetParentPresShell();
    1:   nsresult RetargetEventToParent(nsGUIEvent* aEvent,
    1:                                  nsEventStatus*  aEventStatus);
    1: 
    1:   //helper funcs for event handling
    1: protected:
    1:   //protected because nsPresShellEventCB needs this.
    1:   nsIFrame* GetCurrentEventFrame();
    1: private:
    1:   void PushCurrentEventInfo(nsIFrame* aFrame, nsIContent* aContent);
    1:   void PopCurrentEventInfo();
    1:   nsresult HandleEventInternal(nsEvent* aEvent, nsIView* aView,
    1:                                nsEventStatus *aStatus);
    1:   nsresult HandlePositionedEvent(nsIView*       aView,
    1:                                  nsIFrame*      aTargetFrame,
    1:                                  nsGUIEvent*    aEvent,
    1:                                  nsEventStatus* aEventStatus);
36337:   // This returns the focused DOM window under our top level window.
36337:   //  I.e., when we are deactive, this returns the *last* focused DOM window.
36337:   already_AddRefed<nsPIDOMWindow> GetFocusedDOMWindowInOurWindow();
    1: 
23881:   /*
23881:    * This and the next two helper methods are used to target and position the
23881:    * context menu when the keyboard shortcut is used to open it.
23881:    *
23881:    * If another menu is open, the context menu is opened relative to the
23881:    * active menuitem within the menu, or the menu itself if no item is active.
23881:    * Otherwise, if the caret is visible, the menu is opened near the caret.
23881:    * Otherwise, if a selectable list such as a listbox is focused, the
23881:    * current item within the menu is opened relative to this item.
23881:    * Otherwise, the context menu is opened at the topleft corner of the
23881:    * view.
23881:    *
23881:    * Returns true if the context menu event should fire and false if it should
23881:    * not.
23881:    */
23881:   PRBool AdjustContextMenuKeyEvent(nsMouseEvent* aEvent);
23881: 
23881:   // 
23884:   PRBool PrepareToUseCaretPosition(nsIWidget* aEventWidget, nsIntPoint& aTargetPt);
23881: 
23881:   // Get the selected item and coordinates in device pixels relative to root
30534:   // document's root view for element, first ensuring the element is onscreen
23881:   void GetCurrentItemAndPositionForElement(nsIDOMElement *aCurrentEl,
23881:                                            nsIContent **aTargetToUse,
47902:                                            nsIntPoint& aTargetPt,
47902:                                            nsIWidget *aRootWidget);
23881: 
    1:   void FireResizeEvent();
57661:   void FireBeforeResizeEvent();
31584:   static void AsyncResizeEventCallback(nsITimer* aTimer, void* aPresShell);
23685:   nsRevocableEventPtr<nsRunnableMethod<PresShell> > mResizeEvent;
31584:   nsCOMPtr<nsITimer> mAsyncResizeEventTimer;
31584:   PRPackedBool mAsyncResizeTimerIsActive;
31584:   PRPackedBool mInResize;
    1: 
29987: private:
32511: #ifdef DEBUG
32511:   // Ensure that every allocation from the PresArena is eventually freed.
32511:   PRUint32 mPresArenaAllocCount;
32511: #endif
42982: 
42982: public:
42982: 
42982:   PRUint32 EstimateMemoryUsed() {
42982:     PRUint32 result = 0;
42982: 
42982:     result += sizeof(PresShell);
42982:     result += mStackArena.Size();
42982:     result += mFrameArena.Size();
42982: 
42982:     return result;
42982:   }
42982: 
42982:   static PLDHashOperator LiveShellSizeEnumerator(PresShellPtrKey *aEntry,
42982:                                                  void *userArg)
42982:   {
42982:     PresShell *aShell = static_cast<PresShell*>(aEntry->GetKey());
42982:     PRUint32 *val = (PRUint32*)userArg;
42982:     *val += aShell->EstimateMemoryUsed();
42982:     *val += aShell->mPresContext->EstimateMemoryUsed();
42982:     return PL_DHASH_NEXT;
42982:   }
42982: 
42982:   static PLDHashOperator LiveShellBidiSizeEnumerator(PresShellPtrKey *aEntry,
42982:                                                      void *userArg)
42982:   {
42982:     PresShell *aShell = static_cast<PresShell*>(aEntry->GetKey());
42982:     PRUint32 *val = (PRUint32*)userArg;
42982:     *val += aShell->mPresContext->GetBidiMemoryUsed();
42982:     return PL_DHASH_NEXT;
42982:   }
42982: 
42982:   static PRUint32
42982:   EstimateShellsMemory(nsTHashtable<PresShellPtrKey>::Enumerator aEnumerator)
42982:   {
42982:     PRUint32 result = 0;
42982:     sLiveShells->EnumerateEntries(aEnumerator, &result);
42982:     return result;
42982:   }
42982:                   
42982:                                   
42982:   static PRInt64 SizeOfLayoutMemoryReporter(void *) {
42982:     return EstimateShellsMemory(LiveShellSizeEnumerator);
42982:   }
42982: 
42982:   static PRInt64 SizeOfBidiMemoryReporter(void *) {
42982:     return EstimateShellsMemory(LiveShellBidiSizeEnumerator);
42982:   }
48937: 
48937: protected:
48937:   void QueryIsActive();
50815:   nsresult UpdateImageLockingState();
    1: };
    1: 
29804: class nsAutoCauseReflowNotifier
29804: {
29804: public:
29804:   nsAutoCauseReflowNotifier(PresShell* aShell)
29804:     : mShell(aShell)
29804:   {
29804:     mShell->WillCauseReflow();
29804:   }
29804:   ~nsAutoCauseReflowNotifier()
29804:   {
29804:     // This check should not be needed. Currently the only place that seem
29804:     // to need it is the code that deals with bug 337586.
29804:     if (!mShell->mHaveShutDown) {
29804:       mShell->DidCauseReflow();
29804:     }
29804:     else {
29804:       nsContentUtils::RemoveScriptBlocker();
29804:     }
29804:   }
29804: 
29804:   PresShell* mShell;
29804: };
29804: 
15594: class NS_STACK_CLASS nsPresShellEventCB : public nsDispatchingCallback
    1: {
    1: public:
    1:   nsPresShellEventCB(PresShell* aPresShell) : mPresShell(aPresShell) {}
    1: 
    1:   virtual void HandleEvent(nsEventChainPostVisitor& aVisitor)
    1:   {
    1:     if (aVisitor.mPresContext && aVisitor.mEvent->eventStructType != NS_EVENT) {
    1:       nsIFrame* frame = mPresShell->GetCurrentEventFrame();
    1:       if (frame) {
    1:         frame->HandleEvent(aVisitor.mPresContext,
    1:                            (nsGUIEvent*) aVisitor.mEvent,
    1:                            &aVisitor.mEventStatus);
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsRefPtr<PresShell> mPresShell;
    1: };
    1: 
24947: PRBool PresShell::sDisableNonTestMouseEvents = PR_FALSE;
24947: 
    1: #ifdef PR_LOGGING
    1: PRLogModuleInfo* PresShell::gLog;
    1: #endif
    1: 
    1: #ifdef NS_DEBUG
    1: static void
    1: VerifyStyleTree(nsPresContext* aPresContext, nsFrameManager* aFrameManager)
    1: {
31709:   if (nsFrame::GetVerifyStyleTreeEnable()) {
    1:     nsIFrame* rootFrame = aFrameManager->GetRootFrame();
    1:     aFrameManager->DebugVerifyStyleTree(rootFrame);
    1:   }
    1: }
    1: #define VERIFY_STYLE_TREE ::VerifyStyleTree(mPresContext, FrameManager())
    1: #else
    1: #define VERIFY_STYLE_TREE
    1: #endif
    1: 
    1: static PRBool gVerifyReflowEnabled;
    1: 
    1: PRBool
    1: nsIPresShell::GetVerifyReflowEnable()
    1: {
    1: #ifdef NS_DEBUG
    1:   static PRBool firstTime = PR_TRUE;
    1:   if (firstTime) {
    1:     firstTime = PR_FALSE;
    1:     char* flags = PR_GetEnv("GECKO_VERIFY_REFLOW_FLAGS");
    1:     if (flags) {
    1:       PRBool error = PR_FALSE;
    1: 
    1:       for (;;) {
    1:         char* comma = PL_strchr(flags, ',');
    1:         if (comma)
    1:           *comma = '\0';
    1: 
    1:         PRBool found = PR_FALSE;
    1:         const VerifyReflowFlags* flag = gFlags;
    1:         const VerifyReflowFlags* limit = gFlags + NUM_VERIFY_REFLOW_FLAGS;
    1:         while (flag < limit) {
    1:           if (PL_strcasecmp(flag->name, flags) == 0) {
    1:             gVerifyReflowFlags |= flag->bit;
    1:             found = PR_TRUE;
    1:             break;
    1:           }
    1:           ++flag;
    1:         }
    1: 
    1:         if (! found)
    1:           error = PR_TRUE;
    1: 
    1:         if (! comma)
    1:           break;
    1: 
    1:         *comma = ',';
    1:         flags = comma + 1;
    1:       }
    1: 
    1:       if (error)
    1:         ShowVerifyReflowFlags();
    1:     }
    1: 
    1:     if (VERIFY_REFLOW_ON & gVerifyReflowFlags) {
    1:       gVerifyReflowEnabled = PR_TRUE;
 3232: 
 3232:       printf("Note: verifyreflow is enabled");
    1:       if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
    1:         printf(" (noisy)");
    1:       }
    1:       if (VERIFY_REFLOW_ALL & gVerifyReflowFlags) {
    1:         printf(" (all)");
    1:       }
    1:       if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {
    1:         printf(" (show reflow commands)");
    1:       }
    1:       if (VERIFY_REFLOW_NOISY_RC & gVerifyReflowFlags) {
    1:         printf(" (noisy reflow commands)");
    1:         if (VERIFY_REFLOW_REALLY_NOISY_RC & gVerifyReflowFlags) {
    1:           printf(" (REALLY noisy reflow commands)");
    1:         }
    1:       }
    1:       printf("\n");
    1:     }
 3232:   }
    1: #endif
    1:   return gVerifyReflowEnabled;
    1: }
    1: 
    1: void
    1: nsIPresShell::SetVerifyReflowEnable(PRBool aEnabled)
    1: {
    1:   gVerifyReflowEnabled = aEnabled;
    1: }
    1: 
34904: /* virtual */ void
34904: nsIPresShell::AddWeakFrameExternal(nsWeakFrame* aWeakFrame)
34904: {
34904:   AddWeakFrameInternal(aWeakFrame);
34904: }
34904: 
    1: void
34904: nsIPresShell::AddWeakFrameInternal(nsWeakFrame* aWeakFrame)
    1: {
    1:   if (aWeakFrame->GetFrame()) {
    1:     aWeakFrame->GetFrame()->AddStateBits(NS_FRAME_EXTERNAL_REFERENCE);
    1:   }
    1:   aWeakFrame->SetPreviousWeakFrame(mWeakFrames);
    1:   mWeakFrames = aWeakFrame;
    1: }
    1: 
34904: /* virtual */ void
34904: nsIPresShell::RemoveWeakFrameExternal(nsWeakFrame* aWeakFrame)
34904: {
34904:   RemoveWeakFrameInternal(aWeakFrame);
34904: }
34904: 
    1: void
34904: nsIPresShell::RemoveWeakFrameInternal(nsWeakFrame* aWeakFrame)
    1: {
    1:   if (mWeakFrames == aWeakFrame) {
    1:     mWeakFrames = aWeakFrame->GetPreviousWeakFrame();
    1:     return;
    1:   }
    1:   nsWeakFrame* nextWeak = mWeakFrames;
    1:   while (nextWeak && nextWeak->GetPreviousWeakFrame() != aWeakFrame) {
    1:     nextWeak = nextWeak->GetPreviousWeakFrame();
    1:   }
    1:   if (nextWeak) {
    1:     nextWeak->SetPreviousWeakFrame(aWeakFrame->GetPreviousWeakFrame());
    1:   }
    1: }
    1: 
 8295: already_AddRefed<nsFrameSelection>
 8295: nsIPresShell::FrameSelection()
 8295: {
 8295:   NS_IF_ADDREF(mSelection);
 8295:   return mSelection;
 8295: }
 8295: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsresult
    1: NS_NewPresShell(nsIPresShell** aInstancePtrResult)
    1: {
    1:   NS_PRECONDITION(nsnull != aInstancePtrResult, "null ptr");
40053: 
40053:   if (!aInstancePtrResult)
    1:     return NS_ERROR_NULL_POINTER;
40053: 
40053:   *aInstancePtrResult = new PresShell();
40053:   if (!*aInstancePtrResult)
    1:     return NS_ERROR_OUT_OF_MEMORY;
40053: 
40053:   NS_ADDREF(*aInstancePtrResult);
40053:   return NS_OK;
    1: }
    1: 
42982: nsTHashtable<PresShell::PresShellPtrKey> *nsIPresShell::sLiveShells = 0;
42982: 
42982: NS_MEMORY_REPORTER_IMPLEMENT(LayoutPresShell,
42982:                              "layout/all",
42982:                              "Memory in use by layout PresShell, PresContext, and other related areas.",
42982:                              PresShell::SizeOfLayoutMemoryReporter,
42983:                              nsnull)
42982: 
42982: NS_MEMORY_REPORTER_IMPLEMENT(LayoutBidi,
42982:                              "layout/bidi",
42982:                              "Memory in use by layout Bidi processor.",
42982:                              PresShell::SizeOfBidiMemoryReporter,
42983:                              nsnull)
42982: 
    1: PresShell::PresShell()
    1: {
    1:   mSelection = nsnull;
    1: #ifdef MOZ_REFLOW_PERF
    1:   mReflowCountMgr = new ReflowCountMgr();
    1:   mReflowCountMgr->SetPresContext(mPresContext);
    1:   mReflowCountMgr->SetPresShell(this);
    1: #endif
    1: #ifdef PR_LOGGING
    1:   if (! gLog)
    1:     gLog = PR_NewLogModule("PresShell");
    1: #endif
    1:   mSelectionFlags = nsISelectionDisplay::DISPLAY_TEXT | nsISelectionDisplay::DISPLAY_IMAGES;
    1:   mIsThemeSupportDisabled = PR_FALSE;
48937:   mIsActive = PR_TRUE;
50815:   mFrozen = PR_FALSE;
32511: #ifdef DEBUG
32511:   mPresArenaAllocCount = 0;
32511: #endif
54080:   mRenderFlags = 0;
54081:   mXResolution = 1.0;
54081:   mYResolution = 1.0;
54649:   mViewportOverridden = PR_FALSE;
    1: 
42982:   static bool registeredReporter = false;
42982:   if (!registeredReporter) {
42982:     NS_RegisterMemoryReporter(new NS_MEMORY_REPORTER_NAME(LayoutPresShell));
42982:     NS_RegisterMemoryReporter(new NS_MEMORY_REPORTER_NAME(LayoutBidi));
42982:     registeredReporter = true;
42982:   }
42982: 
    1:   new (this) nsFrameManager();
42982: 
42982:   sLiveShells->PutEntry(this);
    1: }
    1: 
59572: NS_IMPL_ISUPPORTS9(PresShell, nsIPresShell, nsIDocumentObserver,
    1:                    nsIViewObserver, nsISelectionController,
    1:                    nsISelectionDisplay, nsIObserver, nsISupportsWeakReference,
59572:                    nsIMutationObserver, nsIPresShell_MOZILLA_2_0_BRANCH)
    1: 
    1: PresShell::~PresShell()
    1: {
42982:   sLiveShells->RemoveEntry(this);
42982: 
    1:   if (!mHaveShutDown) {
    1:     NS_NOTREACHED("Someone did not call nsIPresShell::destroy");
    1:     Destroy();
    1:   }
    1: 
    1:   NS_ASSERTION(mCurrentEventContentStack.Count() == 0,
    1:                "Huh, event content left on the stack in pres shell dtor!");
    1:   NS_ASSERTION(mFirstCallbackEventRequest == nsnull &&
    1:                mLastCallbackEventRequest == nsnull,
    1:                "post-reflow queues not empty.  This means we're leaking");
    1: 
32511: #ifdef DEBUG
32511:   NS_ASSERTION(mPresArenaAllocCount == 0,
32511:                "Some pres arena objects were not freed");
32511: #endif
32511: 
    1:   delete mStyleSet;
50365:   delete mFrameConstructor;
    1: 
    1:   mCurrentEventContent = nsnull;
    1: 
    1:   NS_IF_RELEASE(mPresContext);
    1:   NS_IF_RELEASE(mDocument);
13846:   NS_IF_RELEASE(mSelection);
    1: }
    1: 
    1: /**
    1:  * Initialize the presentation shell. Create view manager and style
    1:  * manager.
    1:  */
39668: nsresult
    1: PresShell::Init(nsIDocument* aDocument,
    1:                 nsPresContext* aPresContext,
    1:                 nsIViewManager* aViewManager,
    1:                 nsStyleSet* aStyleSet,
    1:                 nsCompatibility aCompatMode)
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
    1:   NS_PRECONDITION(nsnull != aDocument, "null ptr");
    1:   NS_PRECONDITION(nsnull != aPresContext, "null ptr");
    1:   NS_PRECONDITION(nsnull != aViewManager, "null ptr");
    1:   nsresult result;
    1: 
    1:   if ((nsnull == aDocument) || (nsnull == aPresContext) ||
    1:       (nsnull == aViewManager)) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1:   if (mDocument) {
    1:     NS_WARNING("PresShell double init'ed");
    1:     return NS_ERROR_ALREADY_INITIALIZED;
    1:   }
    1:   result = mStackArena.Init();
    1:   NS_ENSURE_SUCCESS(result, result);
    1: 
27993:   if (!mFramesToDirty.Init()) {
27993:     return NS_ERROR_OUT_OF_MEMORY;
27993:   }
27993: 
    1:   mDocument = aDocument;
    1:   NS_ADDREF(mDocument);
    1:   mViewManager = aViewManager;
    1: 
    1:   // Create our frame constructor.
    1:   mFrameConstructor = new nsCSSFrameConstructor(mDocument, this);
    1:   NS_ENSURE_TRUE(mFrameConstructor, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // The document viewer owns both view manager and pres shell.
    1:   mViewManager->SetViewObserver(this);
    1: 
    1:   // Bind the context to the presentation shell.
    1:   mPresContext = aPresContext;
    1:   NS_ADDREF(mPresContext);
    1:   aPresContext->SetShell(this);
    1: 
    1:   // Now we can initialize the style set.
    1:   result = aStyleSet->Init(aPresContext);
    1:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   // From this point on, any time we return an error we need to make
    1:   // sure to null out mStyleSet first, since an error return from this
    1:   // method will cause the caller to delete the style set, so we don't
    1:   // want to delete it in our destructor.
    1:   mStyleSet = aStyleSet;
    1: 
    1:   // Notify our prescontext that it now has a compatibility mode.  Note that
    1:   // this MUST happen after we set up our style set but before we create any
    1:   // frames.
    1:   mPresContext->CompatibilityModeChanged();
    1: 
    1:   // setup the preference style rules (no forced reflow), and do it
    1:   // before creating any frames.
    1:   SetPreferenceStyleRules(PR_FALSE);
    1: 
    1:   result = CallCreateInstance(kFrameSelectionCID, &mSelection);
    1:   if (NS_FAILED(result)) {
    1:     mStyleSet = nsnull;
    1:     return result;
    1:   }
    1: 
    1:   // Create and initialize the frame manager
    1:   result = FrameManager()->Init(this, mStyleSet);
    1:   if (NS_FAILED(result)) {
    1:     NS_WARNING("Frame manager initialization failed");
    1:     mStyleSet = nsnull;
    1:     return result;
    1:   }
    1: 
    1:   mSelection->Init(this, nsnull);
    1: 
    1:   // Important: this has to happen after the selection has been set up
    1: #ifdef SHOW_CARET
    1:   // make the caret
    1:   nsresult  err = NS_NewCaret(getter_AddRefs(mCaret));
    1:   if (NS_SUCCEEDED(err))
    1:   {
    1:     mCaret->Init(this);
 6232:     mOriginalCaret = mCaret;
    1:   }
    1: 
    1:   //SetCaretEnabled(PR_TRUE);       // make it show in browser windows
    1: #endif  
    1:   //set up selection to be displayed in document
    1:   // Don't enable selection for print media
    1:   nsPresContext::nsPresContextType type = aPresContext->Type();
    1:   if (type != nsPresContext::eContext_PrintPreview &&
    1:       type != nsPresContext::eContext_Print)
    1:     SetDisplaySelection(nsISelectionController::SELECTION_DISABLED);
    1:   
    1:   if (gMaxRCProcessingTime == -1) {
    1:     gMaxRCProcessingTime =
    1:       nsContentUtils::GetIntPref("layout.reflow.timeslice",
    1:                                  NS_MAX_REFLOW_TIME);
    1:   }
    1: 
    1:   {
41540:     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
    1:     if (os) {
    1:       os->AddObserver(this, "agent-sheet-added", PR_FALSE);
    1:       os->AddObserver(this, "user-sheet-added", PR_FALSE);
    1:       os->AddObserver(this, "agent-sheet-removed", PR_FALSE);
    1:       os->AddObserver(this, "user-sheet-removed", PR_FALSE);
    1: #ifdef MOZ_XUL
    1:       os->AddObserver(this, "chrome-flush-skin-caches", PR_FALSE);
    1: #endif
 1071: #ifdef ACCESSIBILITY
 1071:       os->AddObserver(this, "a11y-init-or-shutdown", PR_FALSE);
 1071: #endif
    1:     }
    1:   }
    1: 
    1:   // cache the drag service so we can check it during reflows
    1:   mDragService = do_GetService("@mozilla.org/widget/dragservice;1");
    1: 
    1: #ifdef MOZ_REFLOW_PERF
    1:     if (mReflowCountMgr) {
    1:       PRBool paintFrameCounts =
    1:         nsContentUtils::GetBoolPref("layout.reflow.showframecounts");
    1: 
    1:       PRBool dumpFrameCounts =
    1:         nsContentUtils::GetBoolPref("layout.reflow.dumpframecounts");
    1: 
    1:       PRBool dumpFrameByFrameCounts =
    1:         nsContentUtils::GetBoolPref("layout.reflow.dumpframebyframecounts");
    1: 
    1:       mReflowCountMgr->SetDumpFrameCounts(dumpFrameCounts);
    1:       mReflowCountMgr->SetDumpFrameByFrameCounts(dumpFrameByFrameCounts);
    1:       mReflowCountMgr->SetPaintFrameCounts(paintFrameCounts);
    1:     }
    1: #endif
    1: 
39694: #ifdef MOZ_SMIL
39694:   if (mDocument->HasAnimationController()) {
39694:     nsSMILAnimationController* animCtrl = mDocument->GetAnimationController();
56137:     animCtrl->NotifyRefreshDriverCreated(GetPresContext()->RefreshDriver());
39694:   }
39694: #endif // MOZ_SMIL
39694: 
48937:   // Get our activeness from the docShell.
48937:   QueryIsActive();
48937: 
    1:   return NS_OK;
    1: }
    1: 
39668: void
    1: PresShell::Destroy()
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
28371:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
28371:     "destroy called on presshell while scripts not blocked");
28371: 
    1: #ifdef MOZ_REFLOW_PERF
    1:   DumpReflows();
    1:   if (mReflowCountMgr) {
    1:     delete mReflowCountMgr;
    1:     mReflowCountMgr = nsnull;
    1:   }
    1: #endif
    1: 
    1:   if (mHaveShutDown)
39668:     return;
    1: 
43765: #ifdef ACCESSIBILITY
43765:   if (gIsAccessibilityActive) {
43765:     nsCOMPtr<nsIAccessibilityService> accService =
43765:       do_GetService("@mozilla.org/accessibilityService;1");
43765:     if (accService) {
43765:       accService->PresShellDestroyed(this);
43765:     }
43765:   }
43765: #endif // ACCESSIBILITY
43765: 
35522:   MaybeReleaseCapturingContent();
35522: 
50720:   if (gKeyDownTarget && gKeyDownTarget->GetOwnerDoc() == mDocument) {
50720:     NS_RELEASE(gKeyDownTarget);
50720:   }
50720: 
27993:   mContentToScrollTo = nsnull;
27993: 
    1:   if (mPresContext) {
    1:     // We need to notify the destroying the nsPresContext to ESM for
    1:     // suppressing to use from ESM.
    1:     mPresContext->EventStateManager()->NotifyDestroyPresContext(mPresContext);
    1:   }
    1: 
    1:   {
41540:     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
    1:     if (os) {
    1:       os->RemoveObserver(this, "agent-sheet-added");
    1:       os->RemoveObserver(this, "user-sheet-added");
    1:       os->RemoveObserver(this, "agent-sheet-removed");
    1:       os->RemoveObserver(this, "user-sheet-removed");
    1: #ifdef MOZ_XUL
    1:       os->RemoveObserver(this, "chrome-flush-skin-caches");
    1: #endif
 1090: #ifdef ACCESSIBILITY
 1090:       os->RemoveObserver(this, "a11y-init-or-shutdown");
 1090: #endif
    1:     }
    1:   }
    1: 
    1:   // If our paint suppression timer is still active, kill it.
    1:   if (mPaintSuppressionTimer) {
    1:     mPaintSuppressionTimer->Cancel();
    1:     mPaintSuppressionTimer = nsnull;
    1:   }
    1: 
29172:   // Same for our reflow continuation timer
29172:   if (mReflowContinueTimer) {
29172:     mReflowContinueTimer->Cancel();
29172:     mReflowContinueTimer = nsnull;
29172:   }
29172: 
    1:   if (mCaret) {
    1:     mCaret->Terminate();
    1:     mCaret = nsnull;
    1:   }
    1: 
13846:   if (mSelection) {
13846:     mSelection->DisconnectFromPresShell();
13846:   }
13846: 
    1:   // release our pref style sheet, if we have one still
    1:   ClearPreferenceStyleRules();
    1: 
    1:   mIsDestroying = PR_TRUE;
    1: 
    1:   // We can't release all the event content in
    1:   // mCurrentEventContentStack here since there might be code on the
    1:   // stack that will release the event content too. Double release
    1:   // bad!
    1: 
    1:   // The frames will be torn down, so remove them from the current
    1:   // event frame stack (since they'd be dangling references if we'd
    1:   // leave them in) and null out the mCurrentEventFrame pointer as
    1:   // well.
    1: 
    1:   mCurrentEventFrame = nsnull;
    1: 
24551:   PRInt32 i, count = mCurrentEventFrameStack.Length();
    1:   for (i = 0; i < count; i++) {
24551:     mCurrentEventFrameStack[i] = nsnull;
    1:   }
    1: 
35246:   mFramesToDirty.Clear();
35246: 
    1:   if (mViewManager) {
    1:     // Clear the view manager's weak pointer back to |this| in case it
    1:     // was leaked.
    1:     mViewManager->SetViewObserver(nsnull);
    1:     mViewManager = nsnull;
    1:   }
    1: 
    1:   mStyleSet->BeginShutdown(mPresContext);
47259:   nsRefreshDriver* rd = GetPresContext()->RefreshDriver();
    1: 
    1:   // This shell must be removed from the document before the frame
    1:   // hierarchy is torn down to avoid finding deleted frames through
    1:   // this presshell while the frames are being torn down
    1:   if (mDocument) {
46225:     NS_ASSERTION(mDocument->GetShell() == this, "Wrong shell?");
36917:     mDocument->DeleteShell();
47259: 
43180: #ifdef MOZ_SMIL
39694:     if (mDocument->HasAnimationController()) {
56137:       mDocument->GetAnimationController()->NotifyRefreshDriverDestroying(rd);
39694:     }
43180: #endif // MOZ_SMIL
47259:   }
39694: 
38310:   // Revoke any pending events.  We need to do this and cancel pending reflows
38310:   // before we destroy the frame manager, since apparently frame destruction
38310:   // sometimes spins the event queue when plug-ins are involved(!).
50365:   rd->RemoveLayoutFlushObserver(this);
23685:   mResizeEvent.Revoke();
31584:   if (mAsyncResizeTimerIsActive) {
31584:     mAsyncResizeEventTimer->Cancel();
31584:     mAsyncResizeTimerIsActive = PR_FALSE;
31584:   }
    1: 
    1:   CancelAllPendingReflows();
 8509:   CancelPostedReflowCallbacks();
    1: 
    1:   // Destroy the frame manager. This will destroy the frame hierarchy
26803:   mFrameConstructor->WillDestroyFrameTree();
    1:   FrameManager()->Destroy();
    1: 
30599:   // Destroy all frame properties (whose destruction was suppressed
30599:   // while destroying the frame tree, but which might contain more
30599:   // frames within the properties.
    1:   if (mPresContext) {
    1:     // Clear out the prescontext's property table -- since our frame tree is
    1:     // now dead, we shouldn't be looking up any more properties in that table.
    1:     // We want to do this before we call SetShell() on the prescontext, so
    1:     // property destructors can usefully call GetPresShell() on the
    1:     // prescontext.
39965:     mPresContext->PropertyTable()->DeleteAll();
30599:   }
30599: 
30599: 
30599:   NS_WARN_IF_FALSE(!mWeakFrames, "Weak frames alive after destroying FrameManager");
30599:   while (mWeakFrames) {
30599:     mWeakFrames->Clear(this);
30599:   }
30599: 
30599:   // Let the style set do its cleanup.
30599:   mStyleSet->Shutdown(mPresContext);
30599: 
30599:   if (mPresContext) {
    1:     // We hold a reference to the pres context, and it holds a weak link back
    1:     // to us. To avoid the pres context having a dangling reference, set its 
    1:     // pres shell to NULL
    1:     mPresContext->SetShell(nsnull);
    1: 
    1:     // Clear the link handler (weak reference) as well
    1:     mPresContext->SetLinkHandler(nsnull);
    1:   }
    1: 
    1:   mHaveShutDown = PR_TRUE;
    1: }
    1: 
    1:                   // Dynamic stack memory allocation
    1: /* virtual */ void
    1: PresShell::PushStackMemory()
    1: {
    1:   mStackArena.Push();
    1: }
    1: 
    1: /* virtual */ void
    1: PresShell::PopStackMemory()
    1: {
    1:   mStackArena.Pop();
    1: }
    1: 
    1: /* virtual */ void*
    1: PresShell::AllocateStackMemory(size_t aSize)
    1: {
    1:   return mStackArena.Allocate(aSize);
    1: }
    1: 
    1: void
32511: PresShell::FreeFrame(nsQueryFrame::FrameIID aCode, void* aPtr)
32511: {
32511: #ifdef DEBUG
32511:   mPresArenaAllocCount--;
32511: #endif
32511:   if (PRESARENA_MUST_FREE_DURING_DESTROY || !mIsDestroying)
32511:     mFrameArena.FreeByCode(aCode, aPtr);
    1: }
    1: 
    1: void*
32511: PresShell::AllocateFrame(nsQueryFrame::FrameIID aCode, size_t aSize)
32511: {
32511: #ifdef DEBUG
32511:   mPresArenaAllocCount++;
32511: #endif
32511:   void* result = mFrameArena.AllocateByCode(aCode, aSize);
31620: 
31620:   if (result) {
31620:     memset(result, 0, aSize);
31620:   }
31620:   return result;
31620: }
31620: 
31620: void
31620: PresShell::FreeMisc(size_t aSize, void* aPtr)
31620: {
32511: #ifdef DEBUG
32511:   mPresArenaAllocCount--;
32511: #endif
32511:   if (PRESARENA_MUST_FREE_DURING_DESTROY || !mIsDestroying)
32511:     mFrameArena.FreeBySize(aSize, aPtr);
31620: }
31620: 
31620: void*
31620: PresShell::AllocateMisc(size_t aSize)
    1: {
32511: #ifdef DEBUG
32511:   mPresArenaAllocCount++;
32511: #endif
32511:   return mFrameArena.AllocateBySize(aSize);
    1: }
    1: 
    1: void
    1: nsIPresShell::SetAuthorStyleDisabled(PRBool aStyleDisabled)
    1: {
    1:   if (aStyleDisabled != mStyleSet->GetAuthorStyleDisabled()) {
    1:     mStyleSet->SetAuthorStyleDisabled(aStyleDisabled);
    1:     ReconstructStyleData();
    1:   }
    1: }
    1: 
    1: PRBool
40053: nsIPresShell::GetAuthorStyleDisabled() const
    1: {
    1:   return mStyleSet->GetAuthorStyleDisabled();
    1: }
    1: 
39668: nsresult
    1: PresShell::SetPreferenceStyleRules(PRBool aForceReflow)
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
    1:   if (!mDocument) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   nsPIDOMWindow *window = mDocument->GetWindow();
    1: 
    1:   // If the document doesn't have a window there's no need to notify
    1:   // its presshell about changes to preferences since the document is
    1:   // in a state where it doesn't matter any more (see
    1:   // DocumentViewerImpl::Close()).
    1: 
    1:   if (!window) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   } 
    1: 
    1:   NS_PRECONDITION(mPresContext, "presContext cannot be null");
    1:   if (mPresContext) {
    1:     // first, make sure this is not a chrome shell 
19869:     if (nsContentUtils::IsInChromeDocshell(mDocument)) {
    1:       return NS_OK;
    1:     }
    1: 
    1: #ifdef DEBUG_attinasi
    1:     printf("Setting Preference Style Rules:\n");
    1: #endif
    1:     // if here, we need to create rules for the prefs
    1:     // - this includes the background-color, the text-color,
    1:     //   the link color, the visited link color and the link-underlining
    1:     
    1:     // first clear any exising rules
19869:     nsresult result = ClearPreferenceStyleRules();
    1:       
    1:     // now the link rules (must come after the color rules, or links will not be correct color!)
    1:     // XXX - when there is both an override and agent pref stylesheet this won't matter,
    1:     //       as the color rules will be overrides and the links rules will be agent
    1:     if (NS_SUCCEEDED(result)) {
    1:       result = SetPrefLinkRules();
    1:     }
    1:     if (NS_SUCCEEDED(result)) {
    1:       result = SetPrefFocusRules();
    1:     }
    1:     if (NS_SUCCEEDED(result)) {
    1:       result = SetPrefNoScriptRule();
    1:     }
    1:     if (NS_SUCCEEDED(result)) {
    1:       result = SetPrefNoFramesRule();
    1:     }
    1: #ifdef DEBUG_attinasi
    1:     printf( "Preference Style Rules set: error=%ld\n", (long)result);
    1: #endif
    1: 
 3959:     // Note that this method never needs to force any calculation; the caller
 3959:     // will recalculate style if needed
    1: 
    1:     return result;
    1:   }
    1: 
    1:   return NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: nsresult PresShell::ClearPreferenceStyleRules(void)
    1: {
    1:   nsresult result = NS_OK;
    1:   if (mPrefStyleSheet) {
    1:     NS_ASSERTION(mStyleSet, "null styleset entirely unexpected!");
    1:     if (mStyleSet) {
    1:       // remove the sheet from the styleset: 
    1:       // - note that we have to check for success by comparing the count before and after...
    1: #ifdef NS_DEBUG
    1:       PRInt32 numBefore = mStyleSet->SheetCount(nsStyleSet::eUserSheet);
    1:       NS_ASSERTION(numBefore > 0, "no user stylesheets in styleset, but we have one!");
    1: #endif
    1:       mStyleSet->RemoveStyleSheet(nsStyleSet::eUserSheet, mPrefStyleSheet);
    1: 
    1: #ifdef DEBUG_attinasi
    1:       NS_ASSERTION((numBefore - 1) == mStyleSet->GetNumberOfUserStyleSheets(),
    1:                    "Pref stylesheet was not removed");
    1:       printf("PrefStyleSheet removed\n");
    1: #endif
    1:       // clear the sheet pointer: it is strictly historical now
10382:       mPrefStyleSheet = nsnull;
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult PresShell::CreatePreferenceStyleSheet(void)
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
    1:   NS_ASSERTION(!mPrefStyleSheet, "prefStyleSheet already exists");
36920:   nsresult result = NS_NewCSSStyleSheet(getter_AddRefs(mPrefStyleSheet));
    1:   if (NS_SUCCEEDED(result)) {
    1:     NS_ASSERTION(mPrefStyleSheet, "null but no error");
    1:     nsCOMPtr<nsIURI> uri;
    1:     result = NS_NewURI(getter_AddRefs(uri), "about:PreferenceStyleSheet", nsnull);
    1:     if (NS_SUCCEEDED(result)) {
    1:       NS_ASSERTION(uri, "null but no error");
42162:       mPrefStyleSheet->SetURIs(uri, uri, uri);
    1:       mPrefStyleSheet->SetComplete();
    1:       PRUint32 index;
10382:       result =
10382:         mPrefStyleSheet->InsertRuleInternal(NS_LITERAL_STRING("@namespace url(http://www.w3.org/1999/xhtml);"),
    1:                                             0, &index);
10382:       if (NS_SUCCEEDED(result)) {
    1:         mStyleSet->AppendStyleSheet(nsStyleSet::eUserSheet, mPrefStyleSheet);
    1:       }
    1:     }
10382:   }
    1: 
    1: #ifdef DEBUG_attinasi
    1:   printf("CreatePrefStyleSheet completed: error=%ld\n",(long)result);
    1: #endif
    1: 
10382:   if (NS_FAILED(result)) {
10382:     mPrefStyleSheet = nsnull;
10382:   }
10382: 
    1:   return result;
    1: }
    1: 
    1: // XXX We want these after the @namespace rule.  Does order matter
    1: // for these rules, or can we call nsICSSStyleRule::StyleRuleCount()
    1: // and just "append"?
    1: static PRUint32 sInsertPrefSheetRulesAt = 1;
    1: 
    1: nsresult
    1: PresShell::SetPrefNoScriptRule()
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   // also handle the case where print is done from print preview
    1:   // see bug #342439 for more details
36473:   nsIDocument* doc = mDocument;
36473:   if (mPresContext->Type() == nsPresContext::eContext_PrintPreview ||
36473:       mPresContext->Type() == nsPresContext::eContext_Print) {
36473:     while (doc->GetOriginalDocument()) {
36473:       doc = doc->GetOriginalDocument();
36473:     }
36473:   }
36473: 
36473:   PRBool scriptEnabled = doc->IsScriptEnabled();
    1:   if (scriptEnabled) {
    1:     if (!mPrefStyleSheet) {
    1:       rv = CreatePreferenceStyleSheet();
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
10382: 
    1:     PRUint32 index = 0;
10382:     mPrefStyleSheet->
10382:       InsertRuleInternal(NS_LITERAL_STRING("noscript{display:none!important}"),
    1:                          sInsertPrefSheetRulesAt, &index);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult PresShell::SetPrefNoFramesRule(void)
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
    1:   NS_ASSERTION(mPresContext,"null prescontext not allowed");
    1:   if (!mPresContext) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1:   
    1:   if (!mPrefStyleSheet) {
    1:     rv = CreatePreferenceStyleSheet();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   
    1:   NS_ASSERTION(mPrefStyleSheet, "prefstylesheet should not be null");
    1:   
    1:   PRBool allowSubframes = PR_TRUE;
    1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();     
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(container));
    1:   if (docShell) {
    1:     docShell->GetAllowSubframes(&allowSubframes);
    1:   }
    1:   if (!allowSubframes) {
    1:     PRUint32 index = 0;
10382:     rv = mPrefStyleSheet->
10382:       InsertRuleInternal(NS_LITERAL_STRING("noframes{display:block}"),
    1:                          sInsertPrefSheetRulesAt, &index);
    1:     NS_ENSURE_SUCCESS(rv, rv);
10382:     rv = mPrefStyleSheet->
10382:       InsertRuleInternal(NS_LITERAL_STRING("frame, frameset, iframe {display:none!important}"),
    1:                          sInsertPrefSheetRulesAt, &index);
    1:   }
    1:   return rv;
    1: }
    1:   
    1: nsresult PresShell::SetPrefLinkRules(void)
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
    1:   NS_ASSERTION(mPresContext,"null prescontext not allowed");
    1:   if (!mPresContext) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1:   
    1:   if (!mPrefStyleSheet) {
    1:     rv = CreatePreferenceStyleSheet();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   
    1:   NS_ASSERTION(mPrefStyleSheet, "prefstylesheet should not be null");
    1:   
    1:   // support default link colors: 
    1:   //   this means the link colors need to be overridable, 
    1:   //   which they are if we put them in the agent stylesheet,
    1:   //   though if using an override sheet this will cause authors grief still
    1:   //   In the agent stylesheet, they are !important when we are ignoring document colors
    1:   
    1:   nscolor linkColor(mPresContext->DefaultLinkColor());
    1:   nscolor activeColor(mPresContext->DefaultActiveLinkColor());
    1:   nscolor visitedColor(mPresContext->DefaultVisitedLinkColor());
    1:   
 1540:   NS_NAMED_LITERAL_STRING(ruleClose, "}");
    1:   PRUint32 index = 0;
    1:   nsAutoString strColor;
    1: 
    1:   // insert a rule to color links: '*|*:link {color: #RRGGBB [!important];}'
    1:   ColorToString(linkColor, strColor);
10382:   rv = mPrefStyleSheet->
10382:     InsertRuleInternal(NS_LITERAL_STRING("*|*:link{color:") +
    1:                        strColor + ruleClose,
    1:                        sInsertPrefSheetRulesAt, &index);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // - visited links: '*|*:visited {color: #RRGGBB [!important];}'
    1:   ColorToString(visitedColor, strColor);
10382:   rv = mPrefStyleSheet->
10382:     InsertRuleInternal(NS_LITERAL_STRING("*|*:visited{color:") +
    1:                        strColor + ruleClose,
    1:                        sInsertPrefSheetRulesAt, &index);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // - active links: '*|*:-moz-any-link:active {color: #RRGGBB [!important];}'
    1:   ColorToString(activeColor, strColor);
10382:   rv = mPrefStyleSheet->
10382:     InsertRuleInternal(NS_LITERAL_STRING("*|*:-moz-any-link:active{color:") +
    1:                        strColor + ruleClose,
    1:                        sInsertPrefSheetRulesAt, &index);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool underlineLinks =
    1:     mPresContext->GetCachedBoolPref(kPresContext_UnderlineLinks);
    1: 
    1:   if (underlineLinks) {
    1:     // create a rule to make underlining happen
    1:     //  '*|*:-moz-any-link {text-decoration:[underline|none];}'
    1:     // no need for important, we want these to be overridable
    1:     // NOTE: these must go in the agent stylesheet or they cannot be
    1:     //       overridden by authors
10382:     rv = mPrefStyleSheet->
10382:       InsertRuleInternal(NS_LITERAL_STRING("*|*:-moz-any-link{text-decoration:underline}"),
    1:                          sInsertPrefSheetRulesAt, &index);
    1:   } else {
10382:     rv = mPrefStyleSheet->
10382:       InsertRuleInternal(NS_LITERAL_STRING("*|*:-moz-any-link{text-decoration:none}"),
    1:                          sInsertPrefSheetRulesAt, &index);
    1:   }
    1: 
    1:   return rv;          
    1: }
    1: 
    1: nsresult PresShell::SetPrefFocusRules(void)
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
    1:   NS_ASSERTION(mPresContext,"null prescontext not allowed");
    1:   nsresult result = NS_OK;
    1: 
    1:   if (!mPresContext)
    1:     result = NS_ERROR_FAILURE;
    1: 
    1:   if (NS_SUCCEEDED(result) && !mPrefStyleSheet)
    1:     result = CreatePreferenceStyleSheet();
    1: 
    1:   if (NS_SUCCEEDED(result)) {
    1:     NS_ASSERTION(mPrefStyleSheet, "prefstylesheet should not be null");
    1: 
    1:     if (mPresContext->GetUseFocusColors()) {
    1:       nscolor focusBackground(mPresContext->FocusBackgroundColor());
    1:       nscolor focusText(mPresContext->FocusTextColor());
    1: 
    1:       // insert a rule to make focus the preferred color
    1:       PRUint32 index = 0;
    1:       nsAutoString strRule, strColor;
    1: 
    1:       ///////////////////////////////////////////////////////////////
    1:       // - focus: '*:focus
    1:       ColorToString(focusText,strColor);
    1:       strRule.AppendLiteral("*:focus,*:focus>font {color: ");
    1:       strRule.Append(strColor);
    1:       strRule.AppendLiteral(" !important; background-color: ");
    1:       ColorToString(focusBackground,strColor);
    1:       strRule.Append(strColor);
    1:       strRule.AppendLiteral(" !important; } ");
    1:       // insert the rules
10382:       result = mPrefStyleSheet->
10382:         InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
    1:     }
    1:     PRUint8 focusRingWidth = mPresContext->FocusRingWidth();
    1:     PRBool focusRingOnAnything = mPresContext->GetFocusRingOnAnything();
20177:     PRUint8 focusRingStyle = mPresContext->GetFocusRingStyle();
    1: 
    1:     if ((NS_SUCCEEDED(result) && focusRingWidth != 1 && focusRingWidth <= 4 ) || focusRingOnAnything) {
    1:       PRUint32 index = 0;
    1:       nsAutoString strRule;
    1:       if (!focusRingOnAnything)
    1:         strRule.AppendLiteral("*|*:link:focus, *|*:visited");    // If we only want focus rings on the normal things like links
    1:       strRule.AppendLiteral(":focus {outline: ");     // For example 3px dotted WindowText (maximum 4)
    1:       strRule.AppendInt(focusRingWidth);
20177:       if (focusRingStyle == 0) // solid
21040:         strRule.AppendLiteral("px solid -moz-mac-focusring !important; -moz-outline-radius: 3px; outline-offset: 1px; } ");
20177:       else // dotted
20177:         strRule.AppendLiteral("px dotted WindowText !important; } ");
    1:       // insert the rules
10382:       result = mPrefStyleSheet->
10382:         InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
    1:       NS_ENSURE_SUCCESS(result, result);
    1:       if (focusRingWidth != 1) {
    1:         // If the focus ring width is different from the default, fix buttons with rings
    1:         strRule.AssignLiteral("button::-moz-focus-inner, input[type=\"reset\"]::-moz-focus-inner,");
    1:         strRule.AppendLiteral("input[type=\"button\"]::-moz-focus-inner, ");
    1:         strRule.AppendLiteral("input[type=\"submit\"]::-moz-focus-inner { padding: 1px 2px 1px 2px; border: ");
    1:         strRule.AppendInt(focusRingWidth);
20177:         if (focusRingStyle == 0) // solid
20177:           strRule.AppendLiteral("px solid transparent !important; } ");
20177:         else
    1:           strRule.AppendLiteral("px dotted transparent !important; } ");
10382:         result = mPrefStyleSheet->
10382:           InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
    1:         NS_ENSURE_SUCCESS(result, result);
    1:           
    1:         strRule.AssignLiteral("button:focus::-moz-focus-inner, input[type=\"reset\"]:focus::-moz-focus-inner,");
    1:         strRule.AppendLiteral("input[type=\"button\"]:focus::-moz-focus-inner, input[type=\"submit\"]:focus::-moz-focus-inner {");
    1:         strRule.AppendLiteral("border-color: ButtonText !important; }");
10382:         result = mPrefStyleSheet->
10382:           InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: void
    1: PresShell::AddUserSheet(nsISupports* aSheet)
    1: {
    1:   // Make sure this does what DocumentViewerImpl::CreateStyleSet does wrt
    1:   // ordering. We want this new sheet to come after all the existing stylesheet
    1:   // service sheets, but before other user sheets; see nsIStyleSheetService.idl
    1:   // for the ordering.  Just remove and readd all the nsStyleSheetService
    1:   // sheets.
    1:   nsCOMPtr<nsIStyleSheetService> dummy =
    1:     do_GetService(NS_STYLESHEETSERVICE_CONTRACTID);
    1: 
    1:   mStyleSet->BeginUpdate();
    1:   
    1:   nsStyleSheetService *sheetService = nsStyleSheetService::gInstance;
    1:   nsCOMArray<nsIStyleSheet> & userSheets = *sheetService->UserStyleSheets();
    1:   PRInt32 i;
    1:   // Iterate forwards when removing so the searches for RemoveStyleSheet are as
    1:   // short as possible.
    1:   for (i = 0; i < userSheets.Count(); ++i) {
    1:     mStyleSet->RemoveStyleSheet(nsStyleSet::eUserSheet, userSheets[i]);
    1:   }
    1: 
    1:   // Now iterate backwards, so that the order of userSheets will be the same as
    1:   // the order of sheets from it in the style set.
    1:   for (i = userSheets.Count() - 1; i >= 0; --i) {
    1:     mStyleSet->PrependStyleSheet(nsStyleSet::eUserSheet, userSheets[i]);
    1:   }
    1: 
    1:   mStyleSet->EndUpdate();
    1: 
    1:   ReconstructStyleData();
    1: }
    1: 
    1: void
    1: PresShell::AddAgentSheet(nsISupports* aSheet)
    1: {
    1:   // Make sure this does what DocumentViewerImpl::CreateStyleSet does
    1:   // wrt ordering.
    1:   nsCOMPtr<nsIStyleSheet> sheet = do_QueryInterface(aSheet);
    1:   if (!sheet) {
    1:     return;
    1:   }
    1: 
    1:   mStyleSet->AppendStyleSheet(nsStyleSet::eAgentSheet, sheet);
    1:   ReconstructStyleData();
    1: }
    1: 
    1: void
    1: PresShell::RemoveSheet(nsStyleSet::sheetType aType, nsISupports* aSheet)
    1: {
    1:   nsCOMPtr<nsIStyleSheet> sheet = do_QueryInterface(aSheet);
    1:   if (!sheet) {
    1:     return;
    1:   }
    1: 
    1:   mStyleSet->RemoveStyleSheet(aType, sheet);
    1:   ReconstructStyleData();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::SetDisplaySelection(PRInt16 aToggle)
    1: {
    1:   mSelection->SetDisplaySelection(aToggle);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::GetDisplaySelection(PRInt16 *aToggle)
    1: {
    1:   *aToggle = mSelection->GetDisplaySelection();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::GetSelection(SelectionType aType, nsISelection **aSelection)
    1: {
    1:   if (!aSelection || !mSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aSelection = mSelection->GetSelection(aType);
    1: 
    1:   if (!(*aSelection))
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   NS_ADDREF(*aSelection);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsISelection*
    1: PresShell::GetCurrentSelection(SelectionType aType)
    1: {
    1:   if (!mSelection)
    1:     return nsnull;
    1: 
    1:   return mSelection->GetSelection(aType);
    1: }
    1: 
    1: NS_IMETHODIMP
56442: PresShell::ScrollSelectionIntoView(SelectionType aType, SelectionRegion aRegion,
56442:                                    PRInt16 aFlags)
    1: {
    1:   if (!mSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
56442:   return mSelection->ScrollSelectionIntoView(aType, aRegion, aFlags);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::RepaintSelection(SelectionType aType)
    1: {
    1:   if (!mSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   return mSelection->RepaintSelection(aType);
    1: }
    1: 
    1: // Make shell be a document observer
39668: void
    1: PresShell::BeginObservingDocument()
    1: {
 1416:   if (mDocument && !mIsDestroying) {
    1:     mDocument->AddObserver(this);
    1:     if (mIsDocumentGone) {
    1:       NS_WARNING("Adding a presshell that was disconnected from the document "
    1:                  "as a document observer?  Sounds wrong...");
    1:       mIsDocumentGone = PR_FALSE;
    1:     }
    1:   }
    1: }
    1: 
    1: // Make shell stop being a document observer
39668: void
    1: PresShell::EndObservingDocument()
    1: {
    1:   // XXXbz do we need to tell the frame constructor that the document
    1:   // is gone, perhaps?  Except for printing it's NOT gone, sometimes.
    1:   mIsDocumentGone = PR_TRUE;
    1:   if (mDocument) {
35581:     mDocument->RemoveObserver(this);
    1:   }
    1: }
    1: 
    1: #ifdef DEBUG_kipp
    1: char* nsPresShell_ReflowStackPointerTop;
    1: #endif
    1: 
39668: nsresult
    1: PresShell::InitialReflow(nscoord aWidth, nscoord aHeight)
    1: {
  967:   if (mIsDestroying) {
  967:     return NS_OK;
  967:   }
  967: 
28215:   if (!mDocument) {
28215:     // Nothing to do
28215:     return NS_OK;
28215:   }
28215: 
42480:   NS_TIME_FUNCTION_WITH_DOCURL;
42480: 
20272:   NS_ASSERTION(!mDidInitialReflow, "Why are we being called?");
20272: 
    1:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
    1:   mDidInitialReflow = PR_TRUE;
    1: 
    1: #ifdef NS_DEBUG
    1:   if (VERIFY_REFLOW_NOISY_RC & gVerifyReflowFlags) {
    1:     if (mDocument) {
    1:       nsIURI *uri = mDocument->GetDocumentURI();
    1:       if (uri) {
    1:         nsCAutoString url;
    1:         uri->GetSpec(url);
    1:         printf("*** PresShell::InitialReflow (this=%p, url='%s')\n", (void*)this, url.get());
    1:       }
    1:     }
    1:   }
    1: #endif
    1: 
    1:   if (mCaret)
    1:     mCaret->EraseCaret();
    1: 
    1:   // XXX Do a full invalidate at the beginning so that invalidates along
    1:   // the way don't have region accumulation issues?
    1: 
  967:   mPresContext->SetVisibleArea(nsRect(0, 0, aWidth, aHeight));
    1: 
    1:   // Get the root frame from the frame manager
28215:   // XXXbz it would be nice to move this somewhere else... like frame manager
28215:   // Init(), say.  But we need to make sure our views are all set up by the
28215:   // time we do this!
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
28215:   NS_ASSERTION(!rootFrame, "How did that happen, exactly?");
28215:   if (!rootFrame) {
28215:     nsAutoScriptBlocker scriptBlocker;
28215:     mFrameConstructor->BeginUpdate();
28215:     mFrameConstructor->ConstructRootFrame(&rootFrame);
28215:     FrameManager()->SetRootFrame(rootFrame);
28215:     mFrameConstructor->EndUpdate();
28215:   }
28215: 
28215:   NS_ENSURE_STATE(!mHaveShutDown);
28215: 
28215:   if (!rootFrame) {
28215:     return NS_ERROR_OUT_OF_MEMORY;
28215:   }
28215: 
41634:   Element *root = mDocument->GetRootElement();
    1: 
    1:   if (root) {
13098:     {
29804:       nsAutoCauseReflowNotifier reflowNotifier(this);
 6518:       mFrameConstructor->BeginUpdate();
 6518: 
    1:       // Have the style sheet processor construct frame for the root
    1:       // content object down
47667:       mFrameConstructor->ContentInserted(nsnull, root, nsnull, PR_FALSE);
    1:       VERIFY_STYLE_TREE;
    1: 
    1:       // Something in mFrameConstructor->ContentInserted may have caused
    1:       // Destroy() to get called, bug 337586.
    1:       NS_ENSURE_STATE(!mHaveShutDown);
 1416: 
 6518:       mFrameConstructor->EndUpdate();
13098:     }
13098: 
28215:     // nsAutoScriptBlocker going out of scope may have killed us too
13098:     NS_ENSURE_STATE(!mHaveShutDown);
 6518: 
 1416:     // Run the XBL binding constructors for any new frames we've constructed
 1416:     mDocument->BindingManager()->ProcessAttachedQueue();
 1416: 
42480:     NS_TIME_FUNCTION_MARK("XBL binding constructors fired");
42480: 
 1416:     // Constructors may have killed us too
 1416:     NS_ENSURE_STATE(!mHaveShutDown);
 1416: 
 1416:     // Now flush out pending restyles before we actually reflow, in
 1416:     // case XBL constructors changed styles somewhere.
23256:     {
23256:       nsAutoScriptBlocker scriptBlocker;
40938:       mFrameConstructor->CreateNeededFrames();
 1416:       mFrameConstructor->ProcessPendingRestyles();
23256:     }
 1416: 
 1416:     // And that might have run _more_ XBL constructors
 1416:     NS_ENSURE_STATE(!mHaveShutDown);
28215:   }
28215: 
28215:   NS_ASSERTION(rootFrame, "How did that happen?");
28215: 
 1158:   // Note: Because the frame just got created, it has the NS_FRAME_IS_DIRTY
 1158:   // bit set.  Unset it so that FrameNeedsReflow() will work right.
24551:   NS_ASSERTION(!mDirtyRoots.Contains(rootFrame),
 1158:                "Why is the root in mDirtyRoots already?");
 1158: 
 1158:   rootFrame->RemoveStateBits(NS_FRAME_IS_DIRTY |
 1158:                              NS_FRAME_HAS_DIRTY_CHILDREN);
 1158:   FrameNeedsReflow(rootFrame, eResize, NS_FRAME_IS_DIRTY);
 1158: 
24551:   NS_ASSERTION(mDirtyRoots.Contains(rootFrame),
 1158:                "Should be in mDirtyRoots now");
38310:   NS_ASSERTION(mReflowScheduled, "Why no reflow scheduled?");
  752: 
  824:   // Restore our root scroll position now if we're getting here after EndLoad
  967:   // got called, since this is our one chance to do it.  Note that we need not
  967:   // have reflowed for this to work; when the scrollframe is finally reflowed
  967:   // it'll puick up the position we store in it here.
  824:   if (!mDocumentLoading) {
  824:     RestoreRootScrollPosition();
  824:   }
  824: 
    1:   // For printing, we just immediately unsuppress.
    1:   if (!mPresContext->IsPaginated()) {
    1:     // Kick off a one-shot timer based off our pref value.  When this timer
    1:     // fires, if painting is still locked down, then we will go ahead and
    1:     // trigger a full invalidate and allow painting to proceed normally.
    1:     mPaintingSuppressed = PR_TRUE;
    1:     mPaintSuppressionTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:     if (!mPaintSuppressionTimer)
    1:       // Uh-oh.  We must be out of memory.  No point in keeping painting locked down.
    1:       mPaintingSuppressed = PR_FALSE;
    1:     else {
    1:       // Initialize the timer.
    1: 
    1:       // Default to PAINTLOCK_EVENT_DELAY if we can't get the pref value.
    1:       PRInt32 delay =
    1:         nsContentUtils::GetIntPref("nglayout.initialpaint.delay",
    1:                                    PAINTLOCK_EVENT_DELAY);
    1: 
    1:       mPaintSuppressionTimer->InitWithFuncCallback(sPaintSuppressionCallback,
    1:                                                    this, delay, 
    1:                                                    nsITimer::TYPE_ONE_SHOT);
    1:     }
    1:   }
    1: 
    1:   return NS_OK; //XXX this needs to be real. MMP
    1: }
    1: 
    1: void
    1: PresShell::sPaintSuppressionCallback(nsITimer *aTimer, void* aPresShell)
    1: {
28249:   nsRefPtr<PresShell> self = static_cast<PresShell*>(aPresShell);
    1:   if (self)
    1:     self->UnsuppressPainting();
    1: }
    1: 
31584: void
31584: PresShell::AsyncResizeEventCallback(nsITimer* aTimer, void* aPresShell)
31584: {
31584:   static_cast<PresShell*>(aPresShell)->FireResizeEvent();
31584: }
31584: 
39668: nsresult
54649: PresShell::ResizeReflowOverride(nscoord aWidth, nscoord aHeight)
54649: {
54649:   mViewportOverridden = PR_TRUE;
54649:   return ResizeReflowIgnoreOverride(aWidth, aHeight);
54649: }
54649: 
54649: nsresult
    1: PresShell::ResizeReflow(nscoord aWidth, nscoord aHeight)
    1: {
54649:   if (mViewportOverridden) {
54649:     // The viewport has been overridden, and this reflow request
54649:     // didn't ask to ignore the override.  Pretend it didn't happen.
54649:     return NS_OK;
54649:   }
54649:   return ResizeReflowIgnoreOverride(aWidth, aHeight);
54649: }
54649: 
54649: nsresult
54649: PresShell::ResizeReflowIgnoreOverride(nscoord aWidth, nscoord aHeight)
54649: {
 1503:   NS_PRECONDITION(!mIsReflowing, "Shouldn't be in reflow here!");
12971:   NS_PRECONDITION(aWidth != NS_UNCONSTRAINEDSIZE,
12971:                   "shouldn't use unconstrained widths anymore");
 1503:   
    1:   // If we don't have a root frame yet, that means we haven't had our initial
    1:   // reflow... If that's the case, and aWidth or aHeight is unconstrained,
    1:   // ignore them altogether.
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
    1: 
12971:   if (!rootFrame && aHeight == NS_UNCONSTRAINEDSIZE) {
12971:     // We can't do the work needed for SizeToContent without a root
12971:     // frame, and we want to return before setting the visible area.
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
57661:   if (!mIsDestroying && !mResizeEvent.IsPending() &&
57661:       !mAsyncResizeTimerIsActive) {
57661:     FireBeforeResizeEvent();
57661:   }
57661: 
  790:   mPresContext->SetVisibleArea(nsRect(0, 0, aWidth, aHeight));
  790: 
  790:   // There isn't anything useful we can do if the initial reflow hasn't happened
  790:   if (!rootFrame)
  790:     return NS_OK;
  790: 
  821:   NS_ASSERTION(mViewManager, "Must have view manager");
10730:   nsCOMPtr<nsIViewManager> viewManagerDeathGrip = mViewManager;
 6162:   // Take this ref after viewManager so it'll make sure to go away first
 6162:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
23332:   if (!GetPresContext()->SupressingResizeReflow())
23332:   {
23332:     nsIViewManager::UpdateViewBatch batch(mViewManager);
 6162: 
36817:     // Have to make sure that the content notifications are flushed before we
36817:     // start messing with the frame model; otherwise we can get content doubling.
36817:     mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
36817: 
 6162:     // Make sure style is up to date
23256:     {
23256:       nsAutoScriptBlocker scriptBlocker;
40938:       mFrameConstructor->CreateNeededFrames();
 6162:       mFrameConstructor->ProcessPendingRestyles();
23256:     }
10872: 
 6162:     if (!mIsDestroying) {
  821:       // XXX Do a full invalidate at the beginning so that invalidates along
  821:       // the way don't have region accumulation issues?
  821: 
13098:       {
29804:         nsAutoCauseReflowNotifier crNotifier(this);
  821:         WillDoReflow();
  821: 
    1:         // Kick off a top-down reflow
    1:         AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Reflow);
    1: 
  816:         mDirtyRoots.RemoveElement(rootFrame);
27993:         DoReflow(rootFrame, PR_TRUE);
27993:       }
27993: 
27993:       DidDoReflow(PR_TRUE);
 6162:     }
 6162: 
10730:     batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
10872:   }
 6162: 
12971:   if (aHeight == NS_UNCONSTRAINEDSIZE) {
12971:     mPresContext->SetVisibleArea(
12971:       nsRect(0, 0, aWidth, rootFrame->GetRect().height));
12971:   }
12971: 
31584:   if (!mIsDestroying && !mResizeEvent.IsPending() &&
31584:       !mAsyncResizeTimerIsActive) {
31584:     if (mInResize) {
31584:       if (!mAsyncResizeEventTimer) {
31584:         mAsyncResizeEventTimer = do_CreateInstance("@mozilla.org/timer;1");
31584:       }
31584:       if (mAsyncResizeEventTimer) {
31584:         mAsyncResizeTimerIsActive = PR_TRUE;
31584:         mAsyncResizeEventTimer->InitWithFuncCallback(AsyncResizeEventCallback,
31584:                                                      this, 15,
31584:                                                      nsITimer::TYPE_ONE_SHOT);
31584:       }
31584:     } else {
23685:       nsRefPtr<nsRunnableMethod<PresShell> > resizeEvent =
41361:         NS_NewRunnableMethod(this, &PresShell::FireResizeEvent);
23685:       if (NS_SUCCEEDED(NS_DispatchToCurrentThread(resizeEvent))) {
23685:         mResizeEvent = resizeEvent;
23685:       }
 6162:     }
31584:   }
    1: 
    1:   return NS_OK; //XXX this needs to be real. MMP
    1: }
    1: 
    1: void
57661: PresShell::FireBeforeResizeEvent()
57661: {
57661:   if (mIsDocumentGone)
57661:     return;
57661: 
57661:   // Send beforeresize event from here.
57661:   nsEvent event(PR_TRUE, NS_BEFORERESIZE_EVENT);
57661: 
57661:   nsPIDOMWindow *window = mDocument->GetWindow();
57661:   if (window) {
57661:     nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
57661:     nsEventDispatcher::Dispatch(window, mPresContext, &event);
57661:   }
57661: }
57661: 
57661: void
23332: PresShell::FireResizeEvent()
23332: {
31584:   if (mAsyncResizeTimerIsActive) {
31584:     mAsyncResizeTimerIsActive = PR_FALSE;
31584:     mAsyncResizeEventTimer->Cancel();
31584:   }
23685:   mResizeEvent.Revoke();
23685: 
    1:   if (mIsDocumentGone)
    1:     return;
    1: 
    1:   //Send resize event from here.
    1:   nsEvent event(PR_TRUE, NS_RESIZE_EVENT);
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1: 
    1:   nsPIDOMWindow *window = mDocument->GetWindow();
    1:   if (window) {
31584:     nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
31584:     mInResize = PR_TRUE;
    1:     nsEventDispatcher::Dispatch(window, mPresContext, &event, nsnull, &status);
31584:     mInResize = PR_FALSE;
    1:   }
    1: }
    1: 
40046: void
    1: PresShell::SetIgnoreFrameDestruction(PRBool aIgnore)
    1: {
    1:   mIgnoreFrameDestruction = aIgnore;
40046: }
40046: 
40046: void
    1: PresShell::NotifyDestroyingFrame(nsIFrame* aFrame)
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
47756:   mPresContext->ForgetUpdatePluginGeometryFrame(aFrame);
47756: 
    1:   if (!mIgnoreFrameDestruction) {
37172:     mPresContext->StopImagesFor(aFrame);
37172: 
    1:     mFrameConstructor->NotifyDestroyingFrame(aFrame);
    1: 
24551:     for (PRInt32 idx = mDirtyRoots.Length(); idx; ) {
 1503:       --idx;
 1503:       if (mDirtyRoots[idx] == aFrame) {
 1503:         mDirtyRoots.RemoveElementAt(idx);
 1503:       }
 1503:     }
    1: 
    1:     // Notify the frame manager
    1:     FrameManager()->NotifyDestroyingFrame(aFrame);
    1: 
    1:     // Remove frame properties
47756:     mPresContext->NotifyDestroyingFrame(aFrame);
35246: 
35246:     if (aFrame == mCurrentEventFrame) {
35246:       mCurrentEventContent = aFrame->GetContent();
35246:       mCurrentEventFrame = nsnull;
35246:     }
35246: 
35246:   #ifdef NS_DEBUG
35246:     if (aFrame == mDrawEventTargetFrame) {
35246:       mDrawEventTargetFrame = nsnull;
35246:     }
35246:   #endif
35246: 
35246:     for (unsigned int i=0; i < mCurrentEventFrameStack.Length(); i++) {
35246:       if (aFrame == mCurrentEventFrameStack.ElementAt(i)) {
35246:         //One of our stack frames was deleted.  Get its content so that when we
35246:         //pop it we can still get its new frame from its content
35246:         nsIContent *currentEventContent = aFrame->GetContent();
35246:         mCurrentEventContentStack.ReplaceObjectAt(currentEventContent, i);
35246:         mCurrentEventFrameStack[i] = nsnull;
35246:       }
35246:     }
35246:   
35246:     mFramesToDirty.RemoveEntry(aFrame);
    1:   }
    1: }
    1: 
40056: already_AddRefed<nsCaret> PresShell::GetCaret() const
40045: {
40045:   nsCaret* caret = mCaret;
40045:   NS_IF_ADDREF(caret);
40045:   return caret;
40045: }
40045: 
40045: void PresShell::MaybeInvalidateCaretPosition()
    1: {
    1:   if (mCaret) {
    1:     mCaret->InvalidateOutsideCaret();
    1:   }
    1: }
    1: 
15969: void PresShell::SetCaret(nsCaret *aNewCaret)
 6232: {
    1:   mCaret = aNewCaret;
 6232: }
 6232: 
 6232: void PresShell::RestoreCaret()
 6232: {
 6232:   mCaret = mOriginalCaret;
    1: }
    1: 
    1: NS_IMETHODIMP PresShell::SetCaretEnabled(PRBool aInEnable)
    1: {
    1:   PRBool oldEnabled = mCaretEnabled;
    1: 
    1:   mCaretEnabled = aInEnable;
    1: 
    1:   if (mCaret && (mCaretEnabled != oldEnabled))
    1:   {
    1: /*  Don't change the caret's selection here! This was an evil side-effect of SetCaretEnabled()
    1:     nsCOMPtr<nsIDOMSelection> domSel;
    1:     if (NS_SUCCEEDED(GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(domSel))) && domSel)
    1:       mCaret->SetCaretDOMSelection(domSel);
    1: */
15969:     mCaret->SetCaretVisible(mCaretEnabled);
15969:   }
15969: 
15969:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP PresShell::SetCaretReadOnly(PRBool aReadOnly)
    1: {
    1:   if (mCaret)
    1:     mCaret->SetCaretReadOnly(aReadOnly);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP PresShell::GetCaretEnabled(PRBool *aOutEnabled)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aOutEnabled);
    1:   *aOutEnabled = mCaretEnabled;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP PresShell::SetCaretVisibilityDuringSelection(PRBool aVisibility)
    1: {
    1:   if (mCaret)
    1:     mCaret->SetVisibilityDuringSelection(aVisibility);
    1:   return NS_OK;
    1: }
    1: 
14068: NS_IMETHODIMP PresShell::GetCaretVisible(PRBool *aOutIsVisible)
14068: {
14068:   *aOutIsVisible = PR_FALSE;
14068:   if (mCaret) {
14068:     nsresult rv = mCaret->GetCaretVisible(aOutIsVisible);
14068:     NS_ENSURE_SUCCESS(rv,rv);
14068:   }
14068:   return NS_OK;
14068: }
14068: 
    1: NS_IMETHODIMP PresShell::SetSelectionFlags(PRInt16 aInEnable)
    1: {
    1:   mSelectionFlags = aInEnable;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP PresShell::GetSelectionFlags(PRInt16 *aOutEnable)
    1: {
    1:   if (!aOutEnable)
    1:     return NS_ERROR_INVALID_ARG;
    1:   *aOutEnable = mSelectionFlags;
    1:   return NS_OK;
    1: }
    1: 
    1: //implementation of nsISelectionController
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::CharacterMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   return mSelection->CharacterMove(aForward, aExtend);  
    1: }
    1: 
    1: NS_IMETHODIMP
20532: PresShell::CharacterExtendForDelete()
20532: {
20532:   return mSelection->CharacterExtendForDelete();
20532: }
20532: 
20532: NS_IMETHODIMP
43298: PresShell::CharacterExtendForBackspace()
43298: {
43298:   return mSelection->CharacterExtendForBackspace();
43298: }
43298: 
43298: NS_IMETHODIMP 
    1: PresShell::WordMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   return mSelection->WordMove(aForward, aExtend);  
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::WordExtendForDelete(PRBool aForward)
    1: {
    1:   return mSelection->WordExtendForDelete(aForward);  
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::LineMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   nsresult result = mSelection->LineMove(aForward, aExtend);  
    1: // if we can't go down/up any more we must then move caret completely to 
    1: // end/beginning respectively.
    1:   if (NS_FAILED(result)) 
    1:     result = CompleteMove(aForward,aExtend);
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::IntraLineMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   return mSelection->IntraLineMove(aForward, aExtend);  
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::PageMove(PRBool aForward, PRBool aExtend)
    1: {
39248:   nsIScrollableFrame *scrollableFrame =
39248:     GetFrameToScrollAsScrollable(nsIPresShell::eVertical);
37057:   if (!scrollableFrame)
37057:     return NS_OK;
37057: 
37069:   mSelection->CommonPageMove(aForward, aExtend, scrollableFrame);
12392:   // After ScrollSelectionIntoView(), the pending notifications might be
12392:   // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
56442:   return ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
56442:                                  nsISelectionController::SELECTION_FOCUS_REGION,
56442:                                  nsISelectionController::SCROLL_SYNCHRONOUS);
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::ScrollPage(PRBool aForward)
    1: {
39248:   nsIScrollableFrame* scrollFrame =
39248:     GetFrameToScrollAsScrollable(nsIPresShell::eVertical);
37057:   if (scrollFrame) {
37057:     scrollFrame->ScrollBy(nsIntPoint(0, aForward ? 1 : -1),
37057:                           nsIScrollableFrame::PAGES,
37057:                           nsIScrollableFrame::SMOOTH);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::ScrollLine(PRBool aForward)
    1: {
39248:   nsIScrollableFrame* scrollFrame =
39248:     GetFrameToScrollAsScrollable(nsIPresShell::eVertical);
37057:   if (scrollFrame) {
37057:     PRInt32 lineCount = 1;
    1: #ifdef MOZ_WIDGET_COCOA
    1:     // Emulate the Mac IE behavior of scrolling a minimum of 2 lines
    1:     // rather than 1.  This vastly improves scrolling speed.
37057:     lineCount = 2;
    1: #endif
37057:     scrollFrame->ScrollBy(nsIntPoint(0, aForward ? lineCount : -lineCount),
37057:                           nsIScrollableFrame::LINES,
37057:                           nsIScrollableFrame::SMOOTH);
    1:       
    1: //NEW FOR LINES    
    1:     // force the update to happen now, otherwise multiple scrolls can
    1:     // occur before the update is processed. (bug #7354)
    1: 
    1:   // I'd use Composite here, but it doesn't always work.
    1:     // vm->Composite();
    1:     nsIViewManager* viewManager = GetViewManager();
    1:     if (viewManager) {
    1:       viewManager->ForceUpdate();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::ScrollHorizontal(PRBool aLeft)
    1: {
39248:   nsIScrollableFrame* scrollFrame =
39248:     GetFrameToScrollAsScrollable(nsIPresShell::eHorizontal);
37057:   if (scrollFrame) {
37057:     scrollFrame->ScrollBy(nsIntPoint(aLeft ? -1 : 1, 0),
37057:                           nsIScrollableFrame::LINES,
37057:                           nsIScrollableFrame::SMOOTH);
    1: //NEW FOR LINES    
    1:     // force the update to happen now, otherwise multiple scrolls can
    1:     // occur before the update is processed. (bug #7354)
    1: 
    1:   // I'd use Composite here, but it doesn't always work.
    1:     // vm->Composite();
    1:     nsIViewManager* viewManager = GetViewManager();
    1:     if (viewManager) {
    1:       viewManager->ForceUpdate();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::CompleteScroll(PRBool aForward)
    1: {
39248:   nsIScrollableFrame* scrollFrame =
39248:     GetFrameToScrollAsScrollable(nsIPresShell::eVertical);
37057:   if (scrollFrame) {
37057:     scrollFrame->ScrollBy(nsIntPoint(0, aForward ? 1 : -1),
37057:                           nsIScrollableFrame::WHOLE,
37057:                           nsIScrollableFrame::INSTANT);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::CompleteMove(PRBool aForward, PRBool aExtend)
    1: {
12392:   // Beware! This may flush notifications via synchronous
12392:   // ScrollSelectionIntoView.
38005:   nsIContent* limiter = mSelection->GetAncestorLimiter();
38005:   nsIFrame* frame = limiter ? limiter->GetPrimaryFrame()
38005:                             : FrameConstructor()->GetRootElementFrame();
    1:   if (!frame)
    1:     return NS_ERROR_FAILURE;
    1:   nsPeekOffsetStruct pos = frame->GetExtremeCaretPosition(!aForward);
38005:   mSelection->HandleClick(pos.mResultContent, pos.mContentOffset,
38005:                           pos.mContentOffset, aExtend, PR_FALSE, aForward);
38005:   if (limiter) {
38005:     // HandleClick resets ancestorLimiter, so set it again.
38005:     mSelection->SetAncestorLimiter(limiter);
38005:   }
  533:     
12392:   // After ScrollSelectionIntoView(), the pending notifications might be
12392:   // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
14558:   return ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL, 
14558:                                  nsISelectionController::SELECTION_FOCUS_REGION,
56442:                                  nsISelectionController::SCROLL_SYNCHRONOUS);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::SelectAll()
    1: {
    1:   return mSelection->SelectAll();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, PRBool *_retval)
    1: {
    1:   if (!node || startOffset>EndOffset || !_retval || startOffset<0 || EndOffset<0)
    1:     return NS_ERROR_INVALID_ARG;
    1:   *_retval = PR_FALSE; //initialize return parameter
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(node));
    1:   if (!content)
    1:     return NS_ERROR_FAILURE;
36656:   nsIFrame *frame = content->GetPrimaryFrame();
    1:   if (!frame) //no frame to look at so it must not be visible
    1:     return NS_OK;  
    1:   //start process now to go through all frames to find startOffset. then check chars after that to see 
    1:   //if anything until EndOffset is visible.
    1:   PRBool finished = PR_FALSE;
    1:   frame->CheckVisibility(mPresContext,startOffset,EndOffset,PR_TRUE,&finished, _retval);
    1:   return NS_OK;//dont worry about other return val
    1: }
    1: 
    1: //end implementations nsISelectionController
    1: 
    1: 
39668: void
    1: PresShell::StyleChangeReflow()
    1: {
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
  790:   // At the moment at least, we don't have a root frame before the initial
  790:   // reflow; it's safe to just ignore the request in that case
  790:   if (!rootFrame)
39668:     return;
39668: 
39668:   FrameNeedsReflow(rootFrame, eStyleChange, NS_FRAME_IS_DIRTY);
    1: }
    1: 
    1: nsIFrame*
40054: nsIPresShell::GetRootFrameExternal() const
    1: {
    1:   return FrameManager()->GetRootFrame();
    1: }
    1: 
    1: nsIFrame*
    1: nsIPresShell::GetRootScrollFrame() const
    1: {
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
    1:   // Ensure root frame is a viewport frame
    1:   if (!rootFrame || nsGkAtoms::viewportFrame != rootFrame->GetType())
    1:     return nsnull;
    1:   nsIFrame* theFrame = rootFrame->GetFirstChild(nsnull);
    1:   if (!theFrame || nsGkAtoms::scrollFrame != theFrame->GetType())
    1:     return nsnull;
    1:   return theFrame;
    1: }
    1: 
    1: nsIScrollableFrame*
    1: nsIPresShell::GetRootScrollFrameAsScrollable() const
    1: {
    1:   nsIFrame* frame = GetRootScrollFrame();
    1:   if (!frame)
    1:     return nsnull;
23554:   nsIScrollableFrame* scrollableFrame = do_QueryFrame(frame);
 1735:   NS_ASSERTION(scrollableFrame,
 1735:                "All scroll frames must implement nsIScrollableFrame");
    1:   return scrollableFrame;
    1: }
    1: 
34482: nsIScrollableFrame*
34482: nsIPresShell::GetRootScrollFrameAsScrollableExternal() const
34482: {
34482:   return GetRootScrollFrameAsScrollable();
34482: }
34482: 
39668: nsIPageSequenceFrame*
39668: PresShell::GetPageSequenceFrame() const
39668: {
    1:   nsIFrame* frame = mFrameConstructor->GetPageSequenceFrame();
39668:   return do_QueryFrame(frame);
    1: }
    1: 
 5680: nsIFrame*
 5680: PresShell::GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt)
 5680: {
 5680:   return nsLayoutUtils::GetFrameForPoint(aFrame, aPt);
 5680: }
 5680: 
    1: void
    1: PresShell::BeginUpdate(nsIDocument *aDocument, nsUpdateType aUpdateType)
    1: {
    1: #ifdef DEBUG
    1:   mUpdateCount++;
    1: #endif
    1:   mFrameConstructor->BeginUpdate();
    1: 
    1:   if (aUpdateType & UPDATE_STYLE)
    1:     mStyleSet->BeginUpdate();
    1: }
    1: 
    1: void
    1: PresShell::EndUpdate(nsIDocument *aDocument, nsUpdateType aUpdateType)
    1: {
    1: #ifdef DEBUG
    1:   NS_PRECONDITION(0 != mUpdateCount, "too many EndUpdate's");
    1:   --mUpdateCount;
    1: #endif
    1: 
    1:   if (aUpdateType & UPDATE_STYLE) {
    1:     mStyleSet->EndUpdate();
    1:     if (mStylesHaveChanged)
    1:       ReconstructStyleData();
    1:   }
    1: 
    1:   mFrameConstructor->EndUpdate();
    1: }
    1: 
    1: void
  824: PresShell::RestoreRootScrollPosition()
  824: {
    1:   // Restore frame state for the root scroll frame
    1:   nsCOMPtr<nsILayoutHistoryState> historyState =
  824:     mDocument->GetLayoutHistoryState();
    1:   // Make sure we don't reenter reflow via the sync paint that happens while
    1:   // we're scrolling to our restored position.  Entering reflow for the
    1:   // scrollable frame will cause it to reenter ScrollToRestoredPosition(), and
    1:   // it'll get all confused.
13098:   nsAutoScriptBlocker scriptBlocker;
29804:   ++mChangeNestCount;
    1: 
    1:   if (historyState) {
    1:     nsIFrame* scrollFrame = GetRootScrollFrame();
    1:     if (scrollFrame) {
23554:       nsIScrollableFrame* scrollableFrame = do_QueryFrame(scrollFrame);
    1:       if (scrollableFrame) {
    1:         FrameManager()->RestoreFrameStateFor(scrollFrame, historyState,
    1:                                              nsIStatefulFrame::eDocumentScrollState);
    1:         scrollableFrame->ScrollToRestoredPosition();
    1:       }
    1:     }
    1:   }
29804: 
29804:   --mChangeNestCount;
  824: }
  824: 
  824: void
  824: PresShell::BeginLoad(nsIDocument *aDocument)
  824: {  
  824:   mDocumentLoading = PR_TRUE;
  824: }
  824: 
  824: void
  824: PresShell::EndLoad(nsIDocument *aDocument)
  824: {
  824:   NS_PRECONDITION(aDocument == mDocument, "Wrong document");
  824:   
  824:   RestoreRootScrollPosition();
    1:   
    1:   mDocumentLoading = PR_FALSE;
    1: }
    1: 
  925: #ifdef DEBUG
  925: void
  925: PresShell::VerifyHasDirtyRootAncestor(nsIFrame* aFrame)
  925: {
  925:   // XXXbz due to bug 372769, can't actually assert anything here...
  925:   return;
  925:   
  925:   // XXXbz shouldn't need this part; remove it once FrameNeedsReflow
  925:   // handles the root frame correctly.
  925:   if (!aFrame->GetParent()) {
  925:     return;
  925:   }
  925:         
  925:   // Make sure that there is a reflow root ancestor of |aFrame| that's
  925:   // in mDirtyRoots already.
  925:   while (aFrame && (aFrame->GetStateBits() & NS_FRAME_HAS_DIRTY_CHILDREN)) {
  925:     if (((aFrame->GetStateBits() & NS_FRAME_REFLOW_ROOT) ||
  925:          !aFrame->GetParent()) &&
24551:         mDirtyRoots.Contains(aFrame)) {
  925:       return;
  925:     }
  925: 
  925:     aFrame = aFrame->GetParent();
  925:   }
  925:   NS_NOTREACHED("Frame has dirty bits set but isn't scheduled to be "
  925:                 "reflowed?");
  925: }
  925: #endif
  925: 
39668: void
 1158: PresShell::FrameNeedsReflow(nsIFrame *aFrame, IntrinsicDirty aIntrinsicDirty,
 1161:                             nsFrameState aBitToAdd)
 1161: {
42480: #ifdef NS_FUNCTION_TIMER
42480:   NS_TIME_FUNCTION_DECLARE_DOCURL;
42480:   nsCAutoString frameType__("N/A");
42480:   nsIAtom *atomType__ = aFrame ? aFrame->GetType() : nsnull;
42480:   if (atomType__) atomType__->ToUTF8String(frameType__);
42480:   NS_TIME_FUNCTION_MIN_FMT(1.0, "%s (line %d) (document: %s, frame type: %s)", MOZ_FUNCTION_NAME,
42480:                            __LINE__, docURL__.get(), frameType__.get());
42480: #endif
42480: 
 1161:   NS_PRECONDITION(aBitToAdd == NS_FRAME_IS_DIRTY ||
 1161:                   aBitToAdd == NS_FRAME_HAS_DIRTY_CHILDREN,
 1158:                   "Unexpected bits being added");
24631:   NS_PRECONDITION(aIntrinsicDirty != eStyleChange ||
24631:                   aBitToAdd == NS_FRAME_IS_DIRTY,
24631:                   "bits don't correspond to style change reason");
    1: 
 1503:   NS_ASSERTION(!mIsReflowing, "can't mark frame dirty during reflow");
    1: 
    1:   // If we've not yet done the initial reflow, then don't bother
    1:   // enqueuing a reflow command yet.
    1:   if (! mDidInitialReflow)
39668:     return;
    1: 
    1:   // If we're already destroying, don't bother with this either.
    1:   if (mIsDestroying)
39668:     return;
    1: 
    1: #ifdef DEBUG
    1:   //printf("gShellCounter: %d\n", gShellCounter++);
39668:   if (mInVerifyReflow)
39668:     return;
 1735: 
    1:   if (VERIFY_REFLOW_NOISY_RC & gVerifyReflowFlags) {
    1:     printf("\nPresShell@%p: frame %p needs reflow\n", (void*)this, (void*)aFrame);
    1:     if (VERIFY_REFLOW_REALLY_NOISY_RC & gVerifyReflowFlags) {
    1:       printf("Current content model:\n");
41634:       Element *rootElement = mDocument->GetRootElement();
41634:       if (rootElement) {
41634:         rootElement->List(stdout, 0);
    1:       }
    1:     }
    1:   }  
    1: #endif
    1: 
24631:   nsAutoTArray<nsIFrame*, 4> subtrees;
24631:   subtrees.AppendElement(aFrame);
24631: 
24631:   do {
24631:     nsIFrame *subtreeRoot = subtrees.ElementAt(subtrees.Length() - 1);
24631:     subtrees.RemoveElementAt(subtrees.Length() - 1);
24631: 
24631:     // Grab |wasDirty| now so we can go ahead and update the bits on
24631:     // subtreeRoot.
24631:     PRBool wasDirty = NS_SUBTREE_DIRTY(subtreeRoot);
24631:     subtreeRoot->AddStateBits(aBitToAdd);
24631: 
24631:     // Now if subtreeRoot is a reflow root we can cut off this reflow at it if
24631:     // the bit being added is NS_FRAME_HAS_DIRTY_CHILDREN.
 2472:     PRBool targetFrameDirty = (aBitToAdd == NS_FRAME_IS_DIRTY);
 2472: 
 1158: #define FRAME_IS_REFLOW_ROOT(_f)                   \
 1158:   ((_f->GetStateBits() & NS_FRAME_REFLOW_ROOT) &&  \
24631:    (_f != subtreeRoot || !targetFrameDirty))
 1158: 
 1158: 
    1:     // Mark the intrinsic widths as dirty on the frame, all of its ancestors,
    1:     // and all of its descendants, if needed:
    1: 
    1:     if (aIntrinsicDirty != eResize) {
24631:       // Mark argument and all ancestors dirty. (Unless we hit a reflow
24631:       // root that should contain the reflow.  That root could be
24631:       // subtreeRoot itself if it's not dirty, or it could be some
24631:       // ancestor of subtreeRoot.)
24631:       for (nsIFrame *a = subtreeRoot;
 1158:            a && !FRAME_IS_REFLOW_ROOT(a);
    1:            a = a->GetParent())
    1:         a->MarkIntrinsicWidthsDirty();
    1:     }
    1: 
    1:     if (aIntrinsicDirty == eStyleChange) {
24551:       // Mark all descendants dirty (using an nsTArray stack rather than
    1:       // recursion).
24631:       nsAutoTArray<nsIFrame*, 32> stack;
24631:       stack.AppendElement(subtreeRoot);
24631: 
24631:       do {
24631:         nsIFrame *f = stack.ElementAt(stack.Length() - 1);
24551:         stack.RemoveElementAt(stack.Length() - 1);
    1: 
24631:         if (f->GetType() == nsGkAtoms::placeholderFrame) {
24631:           nsIFrame *oof = nsPlaceholderFrame::GetRealFrameForPlaceholder(f);
24631:           if (!nsLayoutUtils::IsProperAncestorFrame(subtreeRoot, oof)) {
24631:             // We have another distinct subtree we need to mark.
24631:             subtrees.AppendElement(oof);
24631:           }
24631:         }
24631: 
    1:         PRInt32 childListIndex = 0;
    1:         nsIAtom *childListName;
    1:         do {
    1:           childListName = f->GetAdditionalChildListName(childListIndex++);
    1:           for (nsIFrame *kid = f->GetFirstChild(childListName); kid;
    1:                kid = kid->GetNextSibling()) {
    1:             kid->MarkIntrinsicWidthsDirty();
    1:             stack.AppendElement(kid);
    1:           }
    1:         } while (childListName);
24631:       } while (stack.Length() != 0);
24631:     }
24631: 
24631:     // Set NS_FRAME_HAS_DIRTY_CHILDREN bits (via nsIFrame::ChildIsDirty)
24631:     // up the tree until we reach either a frame that's already dirty or
24631:     // a reflow root.
24631:     nsIFrame *f = subtreeRoot;
    1:     for (;;) {
 1158:       if (FRAME_IS_REFLOW_ROOT(f) || !f->GetParent()) {
    1:         // we've hit a reflow root or the root frame
    1:         if (!wasDirty) {
    1:           mDirtyRoots.AppendElement(f);
    1:         }
  925: #ifdef DEBUG
  925:         else {
  925:           VerifyHasDirtyRootAncestor(f);
  925:         }
  925: #endif
  925:         
    1:         break;
    1:       }
    1: 
    1:       nsIFrame *child = f;
    1:       f = f->GetParent();
 1158:       wasDirty = NS_SUBTREE_DIRTY(f);
    1:       f->ChildIsDirty(child);
    1:       NS_ASSERTION(f->GetStateBits() & NS_FRAME_HAS_DIRTY_CHILDREN,
    1:                    "ChildIsDirty didn't do its job");
    1:       if (wasDirty) {
    1:         // This frame was already marked dirty.
  925: #ifdef DEBUG
  925:         VerifyHasDirtyRootAncestor(f);
  925: #endif
    1:         break;
    1:       }
    1:     }
24631:   } while (subtrees.Length() != 0);
    1: 
38310:   MaybeScheduleReflow();
39668: }
39668: 
39668: void
27993: PresShell::FrameNeedsToContinueReflow(nsIFrame *aFrame)
27993: {
27993:   NS_ASSERTION(mIsReflowing, "Must be in reflow when marking path dirty.");  
27993:   NS_PRECONDITION(mCurrentReflowRoot, "Must have a current reflow root here");
27993:   NS_ASSERTION(aFrame == mCurrentReflowRoot ||
27993:                nsLayoutUtils::IsProperAncestorFrame(mCurrentReflowRoot, aFrame),
27993:                "Frame passed in is not the descendant of mCurrentReflowRoot");
27993:   NS_ASSERTION(aFrame->GetStateBits() & NS_FRAME_IN_REFLOW,
27993:                "Frame passed in not in reflow?");
27993: 
27993:   mFramesToDirty.PutEntry(aFrame);
27993: }
27993: 
37057: nsIScrollableFrame*
39248: nsIPresShell::GetFrameToScrollAsScrollable(
39248:                 nsIPresShell::ScrollDirection aDirection)
37057: {
37057:   nsIScrollableFrame* scrollFrame = nsnull;
29018: 
    1:   nsCOMPtr<nsIContent> focusedContent;
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm && mDocument) {
29018:     nsCOMPtr<nsIDOMWindow> window = do_QueryInterface(mDocument->GetWindow());
29018: 
29018:     nsCOMPtr<nsIDOMElement> focusedElement;
29018:     fm->GetFocusedElementForWindow(window, PR_FALSE, nsnull, getter_AddRefs(focusedElement));
29018:     focusedContent = do_QueryInterface(focusedElement);
29018:   }
    1:   if (!focusedContent && mSelection) {
    1:     nsISelection* domSelection = mSelection->
    1:       GetSelection(nsISelectionController::SELECTION_NORMAL);
    1:     if (domSelection) {
    1:       nsCOMPtr<nsIDOMNode> focusedNode;
    1:       domSelection->GetFocusNode(getter_AddRefs(focusedNode));
    1:       focusedContent = do_QueryInterface(focusedNode);
    1:     }
    1:   }
    1:   if (focusedContent) {
36656:     nsIFrame* startFrame = focusedContent->GetPrimaryFrame();
    1:     if (startFrame) {
37057:       scrollFrame = startFrame->GetScrollTargetFrame();
37057:       if (scrollFrame) {
37057:         startFrame = scrollFrame->GetScrolledFrame();
37057:       }
39248:       if (aDirection == nsIPresShell::eEither) {
37057:         scrollFrame =
39248:           nsLayoutUtils::GetNearestScrollableFrame(startFrame);
39248:       } else {
39248:         scrollFrame =
39248:           nsLayoutUtils::GetNearestScrollableFrameForDirection(startFrame,
39248:             aDirection == eVertical ? nsLayoutUtils::eVertical :
39248:                                       nsLayoutUtils::eHorizontal);
39248:       }
37057:     }
37057:   }
37057:   if (!scrollFrame) {
37057:     scrollFrame = GetRootScrollFrameAsScrollable();
37057:   }
37057:   return scrollFrame;
    1: }
    1: 
39668: void
    1: PresShell::CancelAllPendingReflows()
    1: {
    1:   mDirtyRoots.Clear();
    1: 
38310:   if (mReflowScheduled) {
50365:     GetPresContext()->RefreshDriver()->RemoveLayoutFlushObserver(this);
38310:     mReflowScheduled = PR_FALSE;
38310:   }
38310: 
38310:   ASSERT_REFLOW_SCHEDULED_STATE();
    1: }
    1: 
40046: nsresult
    1: PresShell::RecreateFramesFor(nsIContent* aContent)
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
    1:   NS_ENSURE_TRUE(mPresContext, NS_ERROR_FAILURE);
 1271:   if (!mDidInitialReflow) {
 1271:     // Nothing to do here.  In fact, if we proceed and aContent is the
 1271:     // root we will crash.
 1271:     return NS_OK;
 1271:   }
    1: 
    1:   // Don't call RecreateFramesForContent since that is not exported and we want
    1:   // to keep the number of entrypoints down.
    1: 
    1:   NS_ASSERTION(mViewManager, "Should have view manager");
10730:   nsIViewManager::UpdateViewBatch batch(mViewManager);
    1: 
    1:   // Have to make sure that the content notifications are flushed before we
    1:   // start messing with the frame model; otherwise we can get content doubling.
    1:   mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
    1: 
13098:   nsAutoScriptBlocker scriptBlocker;
13098: 
    1:   nsStyleChangeList changeList;
    1:   changeList.AppendChange(nsnull, aContent, nsChangeHint_ReconstructFrame);
    1: 
29804:   // Mark ourselves as not safe to flush while we're doing frame construction.
29804:   ++mChangeNestCount;
    1:   nsresult rv = mFrameConstructor->ProcessRestyledFrames(changeList);
29804:   --mChangeNestCount;
 7017:   
10730:   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
    1:   return rv;
    1: }
    1: 
15538: void
42327: nsIPresShell::PostRecreateFramesFor(Element* aElement)
42327: {
43794:   FrameConstructor()->PostRestyleEvent(aElement, nsRestyleHint(0),
15538:                                        nsChangeHint_ReconstructFrame);
15538: }
15538: 
32401: void
46468: nsIPresShell::RestyleForAnimation(Element* aElement, nsRestyleHint aHint)
46468: {
46468:   FrameConstructor()->PostAnimationRestyleEvent(aElement, aHint,
32401:                                                 NS_STYLE_HINT_NONE);
32401: }
32401: 
40046: void
    1: PresShell::ClearFrameRefs(nsIFrame* aFrame)
    1: {
    1:   mPresContext->EventStateManager()->ClearFrameRefs(aFrame);
    1: 
    1:   nsWeakFrame* weakFrame = mWeakFrames;
    1:   while (weakFrame) {
    1:     nsWeakFrame* prev = weakFrame->GetPreviousWeakFrame();
    1:     if (weakFrame->GetFrame() == aFrame) {
    1:       // This removes weakFrame from mWeakFrames.
    1:       weakFrame->Clear(this);
    1:     }
    1:     weakFrame = prev;
    1:   }
40046: }
40046: 
51038: already_AddRefed<nsIRenderingContext>
51038: PresShell::GetReferenceRenderingContext()
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
51038:   nsIDeviceContext* devCtx = mPresContext->DeviceContext();
51038:   nsRefPtr<nsIRenderingContext> rc;
    1:   if (mPresContext->IsScreen()) {
51038:     devCtx->CreateRenderingContextInstance(*getter_AddRefs(rc));
51038:     if (rc) {
51038:       rc->Init(devCtx, gfxPlatform::GetPlatform()->ScreenReferenceSurface());
51038:     }
    1:   } else {
51038:     devCtx->CreateRenderingContext(*getter_AddRefs(rc));
51038:   }
51038:   return rc.forget();
    1: }
    1: 
40046: nsresult
    1: PresShell::GoToAnchor(const nsAString& aAnchorName, PRBool aScroll)
    1: {
    1:   if (!mDocument) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   
    1:   // Hold a reference to the ESM in case event dispatch tears us down.
    1:   nsCOMPtr<nsIEventStateManager> esm = mPresContext->EventStateManager();
    1: 
    1:   if (aAnchorName.IsEmpty()) {
    1:     NS_ASSERTION(!aScroll, "can't scroll to empty anchor name");
    1:     esm->SetContentState(nsnull, NS_EVENT_STATE_URLTARGET);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsIContent> content;
    1: 
    1:   // Search for an element with a matching "id" attribute
44209:   if (mDocument) {    
44209:     content = mDocument->GetElementById(aAnchorName);
    1:   }
    1: 
    1:   // Search for an anchor element with a matching "name" attribute
    1:   if (!content && htmlDoc) {
    1:     nsCOMPtr<nsIDOMNodeList> list;
    1:     // Find a matching list of named nodes
    1:     rv = htmlDoc->GetElementsByName(aAnchorName, getter_AddRefs(list));
    1:     if (NS_SUCCEEDED(rv) && list) {
    1:       PRUint32 i;
    1:       // Loop through the named nodes looking for the first anchor
    1:       for (i = 0; PR_TRUE; i++) {
    1:         nsCOMPtr<nsIDOMNode> node;
    1:         rv = list->Item(i, getter_AddRefs(node));
    1:         if (!node) {  // End of list
    1:           break;
    1:         }
    1:         // Ensure it's an anchor element
    1:         content = do_QueryInterface(node);
    1:         if (content) {
33329:           if (content->Tag() == nsGkAtoms::a && content->IsHTML()) {
    1:             break;
    1:           }
    1:           content = nsnull;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Search for anchor in the HTML namespace with a matching name
    1:   if (!content && !htmlDoc)
    1:   {
44209:     nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(mDocument);
    1:     nsCOMPtr<nsIDOMNodeList> list;
    1:     NS_NAMED_LITERAL_STRING(nameSpace, "http://www.w3.org/1999/xhtml");
    1:     // Get the list of anchor elements
    1:     rv = doc->GetElementsByTagNameNS(nameSpace, NS_LITERAL_STRING("a"), getter_AddRefs(list));
    1:     if (NS_SUCCEEDED(rv) && list) {
    1:       PRUint32 i;
    1:       // Loop through the named nodes looking for the first anchor
    1:       for (i = 0; PR_TRUE; i++) {
    1:         nsCOMPtr<nsIDOMNode> node;
    1:         rv = list->Item(i, getter_AddRefs(node));
    1:         if (!node) { // End of list
    1:           break;
    1:         }
    1:         // Compare the name attribute
    1:         nsCOMPtr<nsIDOMElement> element = do_QueryInterface(node);
    1:         nsAutoString value;
    1:         if (element && NS_SUCCEEDED(element->GetAttribute(NS_LITERAL_STRING("name"), value))) {
    1:           if (value.Equals(aAnchorName)) {
    1:             content = do_QueryInterface(element);
    1:             break;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMRange> jumpToRange;
    1:   nsCOMPtr<nsIXPointerResult> xpointerResult;
    1:   if (!content) {
    1:     nsCOMPtr<nsIDOMXMLDocument> xmldoc = do_QueryInterface(mDocument);
    1:     if (xmldoc) {
    1:       // Try XPointer
    1:       xmldoc->EvaluateXPointer(aAnchorName, getter_AddRefs(xpointerResult));
    1:       if (xpointerResult) {
    1:         xpointerResult->Item(0, getter_AddRefs(jumpToRange));
    1:         if (!jumpToRange) {
    1:           // We know it was an XPointer, so there is no point in
    1:           // trying any other pointer types, let's just return
    1:           // an error.
    1:           return NS_ERROR_FAILURE;
    1:         }
    1:       }
    1: 
    1:       // Finally try FIXptr
    1:       if (!jumpToRange) {
    1:         xmldoc->EvaluateFIXptr(aAnchorName,getter_AddRefs(jumpToRange));
    1:       }
    1: 
    1:       if (jumpToRange) {
    1:         nsCOMPtr<nsIDOMNode> node;
    1:         jumpToRange->GetStartContainer(getter_AddRefs(node));
    1:         if (node) {
    1:           PRUint16 nodeType;
    1:           node->GetNodeType(&nodeType);
    1:           PRInt32 offset = -1;
    1:           jumpToRange->GetStartOffset(&offset);
    1:           switch (nodeType) {
    1:             case nsIDOMNode::ATTRIBUTE_NODE:
    1:             {
    1:               // XXX Assuming jumping to the ownerElement is the sanest action.
    1:               nsCOMPtr<nsIAttribute> attr = do_QueryInterface(node);
    1:               content = attr->GetContent();
    1:               break;
    1:             }
    1:             case nsIDOMNode::DOCUMENT_NODE:
    1:             {
    1:               if (offset >= 0) {
    1:                 nsCOMPtr<nsIDocument> document = do_QueryInterface(node);
    1:                 content = document->GetChildAt(offset);
    1:               }
    1:               break;
    1:             }
    1:             case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
    1:             case nsIDOMNode::ELEMENT_NODE:
    1:             case nsIDOMNode::ENTITY_REFERENCE_NODE:
    1:             {
    1:               if (offset >= 0) {
    1:                 nsCOMPtr<nsIContent> parent = do_QueryInterface(node);
    1:                 content = parent->GetChildAt(offset);
    1:               }
    1:               break;
    1:             }
    1:             case nsIDOMNode::CDATA_SECTION_NODE:
    1:             case nsIDOMNode::COMMENT_NODE:
    1:             case nsIDOMNode::TEXT_NODE:
    1:             case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
    1:             {
    1:               // XXX This should scroll to a specific position in the text.
    1:               content = do_QueryInterface(node);
    1:               break;
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   esm->SetContentState(content, NS_EVENT_STATE_URLTARGET);
    1: 
34455: #ifdef ACCESSIBILITY
34455:   nsIContent *anchorTarget = content;
34455: #endif
34455: 
    1:   if (content) {
    1:     if (aScroll) {
    1:       rv = ScrollContentIntoView(content, NS_PRESSHELL_SCROLL_TOP,
56647:                                  NS_PRESSHELL_SCROLL_ANYWHERE,
56647:                                  SCROLL_OVERFLOW_HIDDEN);
    1:       NS_ENSURE_SUCCESS(rv, rv);
12356: 
12356:       nsIScrollableFrame* rootScroll = GetRootScrollFrameAsScrollable();
12356:       if (rootScroll) {
12356:         mLastAnchorScrolledTo = content;
12356:         mLastAnchorScrollPositionY = rootScroll->GetScrollPosition().y;
12356:       }
    1:     }
    1: 
    1:     // Should we select the target? This action is controlled by a
    1:     // preference: the default is to not select.
    1:     PRBool selectAnchor = nsContentUtils::GetBoolPref("layout.selectanchor");
    1: 
    1:     // Even if select anchor pref is false, we must still move the
    1:     // caret there. That way tabbing will start from the new
    1:     // location
    1:     if (!jumpToRange) {
    1:       jumpToRange = do_CreateInstance(kRangeCID);
    1:       if (jumpToRange) {
    1:         while (content && content->GetChildCount() > 0) {
    1:           content = content->GetChildAt(0);
    1:         }
    1:         nsCOMPtr<nsIDOMNode> node(do_QueryInterface(content));
    1:         NS_ASSERTION(node, "No nsIDOMNode for descendant of anchor");
    1:         jumpToRange->SelectNodeContents(node);
    1:       }
    1:     }
    1:     if (jumpToRange) {
    1:       // Select the anchor
    1:       nsISelection* sel = mSelection->
    1:         GetSelection(nsISelectionController::SELECTION_NORMAL);
    1:       if (sel) {
    1:         sel->RemoveAllRanges();
    1:         sel->AddRange(jumpToRange);
    1:         if (!selectAnchor) {
    1:           // Use a caret (collapsed selection) at the start of the anchor
    1:           sel->CollapseToStart();
    1:         }
    1: 
    1:         if (selectAnchor && xpointerResult) {
    1:           // Select the rest (if any) of the ranges in XPointerResult
    1:           PRUint32 count, i;
    1:           xpointerResult->GetLength(&count);
    1:           for (i = 1; i < count; i++) { // jumpToRange is i = 0
    1:             nsCOMPtr<nsIDOMRange> range;
    1:             xpointerResult->Item(i, getter_AddRefs(range));
    1:             sel->AddRange(range);
    1:           }
    1:         }
59581:       }
    1:       // Selection is at anchor.
    1:       // Now focus the document itself if focus is on an element within it.
    1:       nsPIDOMWindow *win = mDocument->GetWindow();
    1: 
29018:       nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:       if (fm && win) {
29018:         nsCOMPtr<nsIDOMWindow> focusedWindow;
29018:         fm->GetFocusedWindow(getter_AddRefs(focusedWindow));
29018:         if (SameCOMIdentity(win, focusedWindow))
29018:           fm->ClearFocus(focusedWindow);
    1:       }
    1:     }
    1:   } else {
    1:     rv = NS_ERROR_FAILURE; //changed to NS_OK in quirks mode if ScrollTo is called
    1: 
    1:     // Scroll to the top/left if the anchor can not be
    1:     // found and it is labelled top (quirks mode only). @see bug 80784
    1:     if ((NS_LossyConvertUTF16toASCII(aAnchorName).LowerCaseEqualsLiteral("top")) &&
    1:         (mPresContext->CompatibilityMode() == eCompatibility_NavQuirks)) {
    1:       rv = NS_OK;
37073:       nsIScrollableFrame* sf = GetRootScrollFrameAsScrollable();
    1:       // Check |aScroll| after setting |rv| so we set |rv| to the same
    1:       // thing whether or not |aScroll| is true.
37073:       if (aScroll && sf) {
    1:         // Scroll to the top of the page
37073:         sf->ScrollTo(nsPoint(0, 0), nsIScrollableFrame::INSTANT);
    1:       }
    1:     }
    1:   }
    1: 
34455: #ifdef ACCESSIBILITY
34455:   if (anchorTarget && gIsAccessibilityActive) {
34455:     nsCOMPtr<nsIAccessibilityService> accService = 
34455:       do_GetService("@mozilla.org/accessibilityService;1");
34455:     if (accService)
34455:       accService->NotifyOfAnchorJumpTo(anchorTarget);
34455:   }
34455: #endif
34455: 
    1:   return rv;
    1: }
    1: 
40046: nsresult
12356: PresShell::ScrollToAnchor()
12356: {
12356:   if (!mLastAnchorScrolledTo)
12356:     return NS_OK;
12356: 
42357:   NS_ASSERTION(mDidInitialReflow, "should have done initial reflow by now");
42357: 
12356:   nsIScrollableFrame* rootScroll = GetRootScrollFrameAsScrollable();
12356:   if (!rootScroll ||
12356:       mLastAnchorScrollPositionY != rootScroll->GetScrollPosition().y)
12356:     return NS_OK;
12356: 
12356:   nsresult rv = ScrollContentIntoView(mLastAnchorScrolledTo, NS_PRESSHELL_SCROLL_TOP,
56647:                                       NS_PRESSHELL_SCROLL_ANYWHERE,
56647:                                       SCROLL_OVERFLOW_HIDDEN);
12356:   mLastAnchorScrolledTo = nsnull;
12356:   return rv;
12356: }
12356: 
 3508: /*
 3508:  * Helper (per-continuation) for ScrollContentIntoView.
 3508:  *
37074:  * @param aContainerFrame [in] the frame which aRect is relative to
 3508:  * @param aFrame [in] Frame whose bounds should be unioned
37074:  * @param aUseWholeLineHeightForInlines [in] if true, then for inline frames
37074:  * we should include the top of the line in the added rectangle
 3508:  * @param aRect [inout] rect into which its bounds should be unioned
 3510:  * @param aHaveRect [inout] whether aRect contains data yet
 3508:  */
 3508: static void
37074: AccumulateFrameBounds(nsIFrame* aContainerFrame,
37074:                       nsIFrame* aFrame,
37074:                       PRBool aUseWholeLineHeightForInlines,
 3508:                       nsRect& aRect,
37074:                       PRBool& aHaveRect)
37074: {
37074:   nsRect frameBounds = aFrame->GetRect() +
37074:     aFrame->GetParent()->GetOffsetTo(aContainerFrame);
 3508: 
 3508:   // If this is an inline frame and either the bounds height is 0 (quirks
37074:   // layout model) or aUseWholeLineHeightForInlines is set, we need to
 3508:   // change the top of the bounds to include the whole line.
37074:   if (frameBounds.height == 0 || aUseWholeLineHeightForInlines) {
 3508:     nsIAtom* frameType = NULL;
 3508:     nsIFrame *prevFrame = aFrame;
 3508:     nsIFrame *f = aFrame;
 3508: 
 3508:     while (f &&
 3508:            (frameType = f->GetType()) == nsGkAtoms::inlineFrame) {
 3508:       prevFrame = f;
 3508:       f = prevFrame->GetParent();
 3508:     }
 3508: 
 3508:     if (f != aFrame &&
 3508:         f &&
 3508:         frameType == nsGkAtoms::blockFrame) {
 3508:       // find the line containing aFrame and increase the top of |offset|.
21112:       nsAutoLineIterator lines = f->GetLineIterator();
 3508:       if (lines) {
21112:         PRInt32 index = lines->FindLineContaining(prevFrame);
 3508:         if (index >= 0) {
 3508:           nsIFrame *trash1;
 3508:           PRInt32 trash2;
 3508:           nsRect lineBounds;
 3508:           PRUint32 trash3;
 3508: 
 3508:           if (NS_SUCCEEDED(lines->GetLine(index, &trash1, &trash2,
 3508:                                           lineBounds, &trash3))) {
37074:             lineBounds += f->GetOffsetTo(aContainerFrame);
37074:             if (lineBounds.y < frameBounds.y) {
37074:               frameBounds.height = frameBounds.YMost() - lineBounds.y;
37074:               frameBounds.y = lineBounds.y;
37074:             }
37074:           }
37074:         }
37074:       }
37074:     }
37074:   }
37074: 
 3510:   if (aHaveRect) {
 3510:     // We can't use nsRect::UnionRect since it drops empty rects on
 3510:     // the floor, and we need to include them.  (Thus we need
 3510:     // aHaveRect to know when to drop the initial value on the floor.)
12354:     aRect.UnionRectIncludeEmpty(aRect, frameBounds);
 3510:   } else {
 3510:     aHaveRect = PR_TRUE;
 3510:     aRect = frameBounds;
 3510:   }
 3508: }
 3508: 
    1: /**
37074:  * This function takes a scrollable frame, a rect in the coordinate system
37074:  * of the scrolled frame, and a desired percentage-based scroll
37074:  * position and attempts to scroll the rect to that position in the
37074:  * scrollport.
37077:  * 
37077:  * This needs to work even if aRect has a width or height of zero.
    1:  */
37074: static void ScrollToShowRect(nsIScrollableFrame* aScrollFrame,
37074:                              const nsRect&       aRect,
    1:                              PRIntn              aVPercent,
37077:                              PRIntn              aHPercent,
37077:                              PRUint32            aFlags)
    1: {
37074:   nsPoint scrollPt = aScrollFrame->GetScrollPosition();
37074:   nsRect visibleRect(scrollPt, aScrollFrame->GetScrollPortRect().Size());
37074:   nsSize lineSize = aScrollFrame->GetLineScrollAmount();
37077:   nsPresContext::ScrollbarStyles ss = aScrollFrame->GetScrollbarStyles();
37077: 
37077:   if ((aFlags & nsIPresShell::SCROLL_OVERFLOW_HIDDEN) ||
37077:       ss.mVertical != NS_STYLE_OVERFLOW_HIDDEN) {
    1:     // See how the rect should be positioned vertically
    1:     if (NS_PRESSHELL_SCROLL_ANYWHERE == aVPercent ||
    1:         (NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE == aVPercent &&
37074:          aRect.height < lineSize.height)) {
    1:       // The caller doesn't care where the frame is positioned vertically,
    1:       // so long as it's fully visible
    1:       if (aRect.y < visibleRect.y) {
    1:         // Scroll up so the frame's top edge is visible
37074:         scrollPt.y = aRect.y;
    1:       } else if (aRect.YMost() > visibleRect.YMost()) {
    1:         // Scroll down so the frame's bottom edge is visible. Make sure the
    1:         // frame's top edge is still visible
37074:         scrollPt.y += aRect.YMost() - visibleRect.YMost();
37074:         if (scrollPt.y > aRect.y) {
37074:           scrollPt.y = aRect.y;
    1:         }
    1:       }
    1:     } else if (NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE == aVPercent) {
    1:       // Scroll only if no part of the frame is visible in this view
37074:       if (aRect.YMost() - lineSize.height < visibleRect.y) {
    1:         // Scroll up so the frame's top edge is visible
37074:         scrollPt.y = aRect.y;
37074:       }  else if (aRect.y + lineSize.height > visibleRect.YMost()) {
    1:         // Scroll down so the frame's bottom edge is visible. Make sure the
    1:         // frame's top edge is still visible
37074:         scrollPt.y += aRect.YMost() - visibleRect.YMost();
37074:         if (scrollPt.y > aRect.y) {
37074:           scrollPt.y = aRect.y;
    1:         }
    1:       }
    1:     } else {
    1:       // Align the frame edge according to the specified percentage
    1:       nscoord frameAlignY =
    1:         NSToCoordRound(aRect.y + aRect.height * (aVPercent / 100.0f));
37074:       scrollPt.y =
    1:         NSToCoordRound(frameAlignY - visibleRect.height * (aVPercent / 100.0f));
    1:     }
37077:   }
37077: 
37077:   if ((aFlags & nsIPresShell::SCROLL_OVERFLOW_HIDDEN) ||
37077:       ss.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN) {
    1:     // See how the frame should be positioned horizontally
    1:     if (NS_PRESSHELL_SCROLL_ANYWHERE == aHPercent ||
    1:         (NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE == aHPercent &&
37074:          aRect.width < lineSize.width)) {
    1:       // The caller doesn't care where the frame is positioned horizontally,
    1:       // so long as it's fully visible
    1:       if (aRect.x < visibleRect.x) {
    1:         // Scroll left so the frame's left edge is visible
37074:         scrollPt.x = aRect.x;
    1:       } else if (aRect.XMost() > visibleRect.XMost()) {
    1:         // Scroll right so the frame's right edge is visible. Make sure the
    1:         // frame's left edge is still visible
37074:         scrollPt.x += aRect.XMost() - visibleRect.XMost();
37074:         if (scrollPt.x > aRect.x) {
37074:           scrollPt.x = aRect.x;
    1:         }
    1:       }
    1:     } else if (NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE == aHPercent) {
    1:       // Scroll only if no part of the frame is visible in this view
37074:       if (aRect.XMost() - lineSize.width < visibleRect.x) {
    1:         // Scroll left so the frame's left edge is visible
37074:         scrollPt.x = aRect.x;
37074:       }  else if (aRect.x + lineSize.width > visibleRect.XMost()) {
    1:         // Scroll right so the frame's right edge is visible. Make sure the
    1:         // frame's left edge is still visible
37074:         scrollPt.x += aRect.XMost() - visibleRect.XMost();
37074:         if (scrollPt.x > aRect.x) {
37074:           scrollPt.x = aRect.x;
    1:         }
    1:       }
    1:     } else {
    1:       // Align the frame edge according to the specified percentage
    1:       nscoord frameAlignX =
    1:         NSToCoordRound(aRect.x + (aRect.width) * (aHPercent / 100.0f));
37074:       scrollPt.x =
    1:         NSToCoordRound(frameAlignX - visibleRect.width * (aHPercent / 100.0f));
    1:     }
37077:   }
    1: 
37074:   aScrollFrame->ScrollTo(scrollPt, nsIScrollableFrame::INSTANT);
    1: }
    1: 
40046: nsresult
    1: PresShell::ScrollContentIntoView(nsIContent* aContent,
    1:                                  PRIntn      aVPercent,
56647:                                  PRIntn      aHPercent,
56647:                                  PRUint32    aFlags)
27993: {
    1:   nsCOMPtr<nsIContent> content = aContent; // Keep content alive while flushing.
    1:   NS_ENSURE_TRUE(content, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDocument> currentDoc = content->GetCurrentDoc();
    1:   NS_ENSURE_STATE(currentDoc);
    1: 
42357:   NS_ASSERTION(mDidInitialReflow, "should have done initial reflow by now");
42357: 
28165:   mContentToScrollTo = aContent;
28165:   mContentScrollVPosition = aVPercent;
28165:   mContentScrollHPosition = aHPercent;
28165: 
28165:   // Flush layout and attempt to scroll in the process.
28165:   currentDoc->FlushPendingNotifications(Flush_InterruptibleLayout);
28165: 
28165:   // If mContentToScrollTo is non-null, that means we interrupted the reflow
28165:   // (or suppressed it altogether because we're suppressing interruptible
28165:   // flushes right now) and won't necessarily get the position correct, but do
28165:   // a best-effort scroll here.  The other option would be to do this inside
28165:   // FlushPendingNotifications, but I'm not sure the repeated scrolling that
28165:   // could trigger if reflows keep getting interrupted would be more desirable
28165:   // than a single best-effort scroll followed by one final scroll on the first
28165:   // completed reflow.
28165:   if (mContentToScrollTo) {
56647:     DoScrollContentIntoView(content, aVPercent, aHPercent, aFlags);
28165:   }
28165:   return NS_OK;
28165: }
28165: 
28165: void
27993: PresShell::DoScrollContentIntoView(nsIContent* aContent,
27993:                                    PRIntn      aVPercent,
56647:                                    PRIntn      aHPercent,
56647:                                    PRUint32    aFlags)
27993: {
42357:   NS_ASSERTION(mDidInitialReflow, "should have done initial reflow by now");
42357: 
36656:   nsIFrame* frame = aContent->GetPrimaryFrame();
27993:   if (!frame) {
27993:     mContentToScrollTo = nsnull;
28165:     return;
27993:   }
27993: 
28358:   if (frame->GetStateBits() & NS_FRAME_FIRST_REFLOW) {
28358:     // The reflow flush before this scroll got interrupted, and this frame's
28358:     // coords and size are all zero, and it has no content showing anyway.
28358:     // Don't bother scrolling to it.  We'll try again when we finish up layout.
28358:     return;
28358:   }
28358: 
37074:   nsIFrame* container =
37074:     nsLayoutUtils::GetClosestFrameOfType(frame, nsGkAtoms::scrollFrame);
37074:   if (!container) {
37074:     // nothing can be scrolled
37074:     return;
37074:   }
37074: 
    1:   // This is a two-step process.
    1:   // Step 1: Find the bounds of the rect we want to scroll into view.  For
    1:   //         example, for an inline frame we may want to scroll in the whole
37074:   //         line, or we may want to scroll multiple lines into view.
37074:   // Step 2: Walk container frame and its ancestors and scroll them
    1:   //         appropriately.
37074:   // frameBounds is relative to container. We're assuming
37074:   // that scrollframes don't split so every continuation of frame will
37074:   // be a descendant of container. (Things would still mostly work
37074:   // even if that assumption was false.)
 3508:   nsRect frameBounds;
 3510:   PRBool haveRect = PR_FALSE;
37074:   PRBool useWholeLineHeightForInlines = aVPercent != NS_PRESSHELL_SCROLL_ANYWHERE;
 3508:   do {
37074:     AccumulateFrameBounds(container, frame, useWholeLineHeightForInlines,
37074:                           frameBounds, haveRect);
 3508:   } while ((frame = frame->GetNextContinuation()));
    1: 
37077:   ScrollFrameRectIntoView(container, frameBounds, aVPercent, aHPercent,
56647:                           aFlags);
37077: }
37077: 
37077: PRBool
37077: PresShell::ScrollFrameRectIntoView(nsIFrame*     aFrame,
37077:                                    const nsRect& aRect,
37077:                                    PRIntn        aVPercent,
37077:                                    PRIntn        aHPercent,
37077:                                    PRUint32      aFlags)
37077: {
37077:   PRBool didScroll = PR_FALSE;
37077:   // This function needs to work even if rect has a width or height of 0.
37077:   nsRect rect = aRect;
37077:   nsIFrame* container = aFrame;
37077:   // Walk up the frame hierarchy scrolling the rect into view and
37077:   // keeping rect relative to container
37077:   do {
37074:     nsIScrollableFrame* sf = do_QueryFrame(container);
37074:     if (sf) {
37074:       nsPoint oldPosition = sf->GetScrollPosition();
37077:       ScrollToShowRect(sf, rect - sf->GetScrolledFrame()->GetPosition(),
37077:                        aVPercent, aHPercent, aFlags);
37074:       nsPoint newPosition = sf->GetScrollPosition();
41181:       // If the scroll position increased, that means our content moved up,
41181:       // so our rect's offset should decrease
41181:       rect += oldPosition - newPosition;
37077: 
37077:       if (oldPosition != newPosition) {
37077:         didScroll = PR_TRUE;
37077:       }
37077: 
38842:       // only scroll one container when this flag is set
56442:       if (aFlags & nsIPresShell::SCROLL_FIRST_ANCESTOR_ONLY) {
38842:         break;
38842:       }
37077:     }
37077:     rect += container->GetPosition();
47902:     nsIFrame* parent = container->GetParent();
47902:     if (!parent) {
41180:       nsPoint extraOffset(0,0);
47902:       parent = nsLayoutUtils::GetCrossDocParentFrame(container, &extraOffset);
47902:       if (parent) {
47902:         PRInt32 APD = container->PresContext()->AppUnitsPerDevPixel();        
47902:         PRInt32 parentAPD = parent->PresContext()->AppUnitsPerDevPixel();
47902:         rect = rect.ConvertAppUnitsRoundOut(APD, parentAPD);
41180:         rect += extraOffset;
47902:       }
47902:     }
47902:     container = parent;
38842:   } while (container);
37077: 
37077:   return didScroll;
    1: }
    1: 
37073: nsRectVisibility
37073: PresShell::GetRectVisibility(nsIFrame* aFrame,
37073:                              const nsRect &aRect,
40053:                              nscoord aMinTwips) const
37073: {
47902:   NS_ASSERTION(aFrame->PresContext() == GetPresContext(),
47902:                "prescontext mismatch?");
37073:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
37073:   NS_ASSERTION(rootFrame,
37073:                "How can someone have a frame for this presshell when there's no root?");
37073:   nsIScrollableFrame* sf = GetRootScrollFrameAsScrollable();
37073:   nsRect scrollPortRect;
37073:   if (sf) {
37073:     scrollPortRect = sf->GetScrollPortRect();
37073:     nsIFrame* f = do_QueryFrame(sf);
37073:     scrollPortRect += f->GetOffsetTo(rootFrame);
37073:   } else {
37073:     scrollPortRect = nsRect(nsPoint(0,0), rootFrame->GetSize());
37073:   }
37073: 
37073:   nsRect r = aRect + aFrame->GetOffsetTo(rootFrame);
37073:   // If aRect is entirely visible then we don't need to ensure that
37073:   // at least aMinTwips of it is visible
37073:   if (scrollPortRect.Contains(r))
37073:     return nsRectVisibility_kVisible;
37073: 
37073:   nsRect insetRect = scrollPortRect;
37073:   insetRect.Deflate(aMinTwips, aMinTwips);
37073:   if (r.YMost() <= insetRect.y)
37073:     return nsRectVisibility_kAboveViewport;
37073:   if (r.y >= insetRect.YMost())
37073:     return nsRectVisibility_kBelowViewport;
37073:   if (r.XMost() <= insetRect.x)
37073:     return nsRectVisibility_kLeftOfViewport;
37073:   if (r.x >= insetRect.XMost())
37073:     return nsRectVisibility_kRightOfViewport;
37073: 
37073:   return nsRectVisibility_kVisible;
37073: }
37073: 
    1: // GetLinkLocation: copy link location to clipboard
40053: nsresult PresShell::GetLinkLocation(nsIDOMNode* aNode, nsAString& aLocationString) const
    1: {
    1: #ifdef DEBUG_dr
    1:   printf("dr :: PresShell::GetLinkLocation\n");
    1: #endif
    1: 
    1:   NS_ENSURE_ARG_POINTER(aNode);
    1:   nsresult rv;
    1:   nsAutoString anchorText;
    1:   static char strippedChars[] = {'\t','\r','\n'};
    1: 
    1:   // are we an anchor?
    1:   nsCOMPtr<nsIDOMHTMLAnchorElement> anchor(do_QueryInterface(aNode));
    1:   nsCOMPtr<nsIDOMHTMLAreaElement> area;
    1:   nsCOMPtr<nsIDOMHTMLLinkElement> link;
    1:   nsAutoString xlinkType;
    1:   if (anchor) {
    1:     rv = anchor->GetHref(anchorText);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   } else {
    1:     // area?
    1:     area = do_QueryInterface(aNode);
    1:     if (area) {
    1:       rv = area->GetHref(anchorText);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     } else {
    1:       // link?
    1:       link = do_QueryInterface(aNode);
    1:       if (link) {
    1:         rv = link->GetHref(anchorText);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       } else {
    1:         // Xlink?
    1:         nsCOMPtr<nsIDOMElement> element(do_QueryInterface(aNode));
    1:         if (element) {
    1:           NS_NAMED_LITERAL_STRING(xlinkNS,"http://www.w3.org/1999/xlink");
    1:           element->GetAttributeNS(xlinkNS,NS_LITERAL_STRING("type"),xlinkType);
    1:           if (xlinkType.EqualsLiteral("simple")) {
    1:             element->GetAttributeNS(xlinkNS,NS_LITERAL_STRING("href"),anchorText);
    1:             if (!anchorText.IsEmpty()) {
    1:               // Resolve the full URI using baseURI property
    1: 
    1:               nsAutoString base;
    1:               nsCOMPtr<nsIDOM3Node> node(do_QueryInterface(aNode,&rv));
    1:               NS_ENSURE_SUCCESS(rv, rv);
    1:               node->GetBaseURI(base);
    1: 
    1:               nsCOMPtr<nsIIOService>
    1:                 ios(do_GetService("@mozilla.org/network/io-service;1", &rv));
    1:               NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:               nsCOMPtr<nsIURI> baseURI;
    1:               rv = ios->NewURI(NS_ConvertUTF16toUTF8(base),nsnull,nsnull,getter_AddRefs(baseURI));
    1:               NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:               nsCAutoString spec;
    1:               rv = baseURI->Resolve(NS_ConvertUTF16toUTF8(anchorText),spec);
    1:               NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:               CopyUTF8toUTF16(spec, anchorText);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (anchor || area || link || xlinkType.EqualsLiteral("simple")) {
    1:     //Remove all the '\t', '\r' and '\n' from 'anchorText'
    1:     anchorText.StripChars(strippedChars);
    1: 
    1:     aLocationString = anchorText;
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // if no link, fail.
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
22471: NS_IMETHODIMP_(void)
22471: PresShell::DispatchSynthMouseMove(nsGUIEvent *aEvent,
22471:                                   PRBool aFlushOnHoverChange)
22471: {
22471:   PRUint32 hoverGenerationBefore = mFrameConstructor->GetHoverGeneration();
22471:   nsEventStatus status;
47898:   nsIView* targetView = nsIView::GetViewFor(aEvent->widget);
47898:   targetView->GetViewManager()->DispatchEvent(aEvent, targetView, &status);
22471:   if (aFlushOnHoverChange &&
22471:       hoverGenerationBefore != mFrameConstructor->GetHoverGeneration()) {
22471:     // Flush so that the resulting reflow happens now so that our caller
22471:     // can suppress any synthesized mouse moves caused by that reflow.
22471:     FlushPendingNotifications(Flush_Layout);
22471:   }
22471: }
22471: 
32435: NS_IMETHODIMP_(void)
32435: PresShell::ClearMouseCapture(nsIView* aView)
32435: {
32435:   if (gCaptureInfo.mContent) {
32435:     if (aView) {
32814:       // if a view was specified, ensure that the captured content is within
36790:       // this view.
36790:       nsIFrame* frame = gCaptureInfo.mContent->GetPrimaryFrame();
32435:       if (frame) {
32435:         nsIView* view = frame->GetClosestView();
33464:         // if there is no view, capturing won't be handled any more, so
33464:         // just release the capture.
33464:         if (view) {
33464:           do {
32435:             if (view == aView) {
32435:               NS_RELEASE(gCaptureInfo.mContent);
32435:               // the view containing the captured content likely disappeared so
32435:               // disable capture for now.
32435:               gCaptureInfo.mAllowed = PR_FALSE;
32435:               break;
32435:             }
32435: 
32435:             view = view->GetParent();
33464:           } while (view);
32435:           // return if the view wasn't found
32435:           return;
32435:         }
32435:       }
33464:     }
32435: 
32435:     NS_RELEASE(gCaptureInfo.mContent);
32435:   }
32435: 
32435:   // disable mouse capture until the next mousedown as a dialog has opened
32435:   // or a drag has started. Otherwise, someone could start capture during
32435:   // the modal dialog or drag.
32435:   gCaptureInfo.mAllowed = PR_FALSE;
32435: }
32435: 
40046: nsresult
    1: PresShell::CaptureHistoryState(nsILayoutHistoryState** aState, PRBool aLeavingPage)
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   NS_PRECONDITION(nsnull != aState, "null state pointer");
    1: 
    1:   // We actually have to mess with the docshell here, since we want to
    1:   // store the state back in it.
    1:   // XXXbz this isn't really right, since this is being called in the
    1:   // content viewer's Hide() method...  by that point the docshell's
    1:   // state could be wrong.  We should sort out a better ownership
    1:   // model for the layout history state.
    1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
    1:   if (!container)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(container));
    1:   if (!docShell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsILayoutHistoryState> historyState;
    1:   docShell->GetLayoutHistoryState(getter_AddRefs(historyState));
    1:   if (!historyState) {
    1:     // Create the document state object
    1:     rv = NS_NewLayoutHistoryState(getter_AddRefs(historyState));
    1:   
    1:     if (NS_FAILED(rv)) { 
    1:       *aState = nsnull;
    1:       return rv;
    1:     }    
    1: 
    1:     docShell->SetLayoutHistoryState(historyState);
    1:   }
    1: 
    1:   *aState = historyState;
    1:   NS_IF_ADDREF(*aState);
    1:   
    1:   // Capture frame state for the entire frame hierarchy
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
    1:   if (!rootFrame) return NS_OK;
    1:   // Capture frame state for the root scroll frame
    1:   // Don't capture state when first creating doc element hierarchy
30710:   // As the scroll position is 0 and this will cause us to lose
    1:   // our previously saved place!
    1:   if (aLeavingPage) {
    1:     nsIFrame* scrollFrame = GetRootScrollFrame();
    1:     if (scrollFrame) {
    1:       FrameManager()->CaptureFrameStateFor(scrollFrame, historyState,
    1:                                            nsIStatefulFrame::eDocumentScrollState);
    1:     }
    1:   }
    1: 
    1:   FrameManager()->CaptureFrameState(rootFrame, historyState);  
    1:  
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: PresShell::UnsuppressAndInvalidate()
    1: {
52218:   // Note: We ignore the EnsureVisible check for resource documents, because
52218:   // they won't have a docshell, so they'll always fail EnsureVisible.
52218:   if ((!mDocument->IsResourceDoc() && !mPresContext->EnsureVisible()) ||
52218:       mHaveShutDown) {
    1:     // No point; we're about to be torn down anyway.
    1:     return;
    1:   }
    1:   
    1:   mPaintingSuppressed = PR_FALSE;
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
    1:   if (rootFrame) {
    1:     // let's assume that outline on a root frame is not supported
    1:     nsRect rect(nsPoint(0, 0), rootFrame->GetSize());
19380:     rootFrame->Invalidate(rect);
    1: 
33905:     if (mCaretEnabled && mCaret) {
33905:       mCaret->CheckCaretDrawingState();
33905:     }
33905: 
37502:     nsRootPresContext* rootPC = mPresContext->GetRootPresContext();
37502:     if (rootPC) {
47756:       rootPC->RequestUpdatePluginGeometry(rootFrame);
37502:     }
32992:   }
30522: 
29018:   // now that painting is unsuppressed, focus may be set on the document
29018:   nsPIDOMWindow *win = mDocument->GetWindow();
29018:   if (win)
29018:     win->SetReadyForFocus();
    1: 
52492:   if (!mHaveShutDown)
52492:     SynthesizeMouseMove(PR_FALSE);
    1: }
    1: 
40049: void
    1: PresShell::UnsuppressPainting()
    1: {
    1:   if (mPaintSuppressionTimer) {
    1:     mPaintSuppressionTimer->Cancel();
    1:     mPaintSuppressionTimer = nsnull;
    1:   }
    1: 
    1:   if (mIsDocumentGone || !mPaintingSuppressed)
40049:     return;
    1: 
    1:   // If we have reflows pending, just wait until we process
    1:   // the reflows and get all the frames where we want them
    1:   // before actually unlocking the painting.  Otherwise
    1:   // go ahead and unlock now.
24551:   if (mDirtyRoots.Length() > 0)
    1:     mShouldUnsuppressPainting = PR_TRUE;
    1:   else
    1:     UnsuppressAndInvalidate();
40020: }
40020: 
    1: // Post a request to handle an arbitrary callback after reflow has finished.
40046: nsresult
    1: PresShell::PostReflowCallback(nsIReflowCallback* aCallback)
    1: {
31620:   void* result = AllocateMisc(sizeof(nsCallbackEventRequest));
    1:   if (NS_UNLIKELY(!result)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   nsCallbackEventRequest* request = (nsCallbackEventRequest*)result;
    1: 
    1:   request->callback = aCallback;
    1:   request->next = nsnull;
    1: 
    1:   if (mLastCallbackEventRequest) {
    1:     mLastCallbackEventRequest = mLastCallbackEventRequest->next = request;
    1:   } else {
    1:     mFirstCallbackEventRequest = request;
    1:     mLastCallbackEventRequest = request;
    1:   }
    1:  
    1:   return NS_OK;
    1: }
    1: 
40046: void
    1: PresShell::CancelReflowCallback(nsIReflowCallback* aCallback)
    1: {
    1:    nsCallbackEventRequest* before = nsnull;
    1:    nsCallbackEventRequest* node = mFirstCallbackEventRequest;
    1:    while(node)
    1:    {
    1:       nsIReflowCallback* callback = node->callback;
    1: 
    1:       if (callback == aCallback) 
    1:       {
    1:         nsCallbackEventRequest* toFree = node;
    1:         if (node == mFirstCallbackEventRequest) {
    1:           node = node->next;
    1:           mFirstCallbackEventRequest = node;
    1:           NS_ASSERTION(before == nsnull, "impossible");
    1:         } else {
    1:           node = node->next;
    1:           before->next = node;
    1:         }
    1: 
    1:         if (toFree == mLastCallbackEventRequest) {
    1:           mLastCallbackEventRequest = before;
    1:         }
    1: 
31620:         FreeMisc(sizeof(nsCallbackEventRequest), toFree);
    1:       } else {
    1:         before = node;
    1:         node = node->next;
    1:       }
    1:    }
    1: }
    1: 
    1: void
 8509: PresShell::CancelPostedReflowCallbacks()
 8509: {
 8509:   while (mFirstCallbackEventRequest) {
 8509:     nsCallbackEventRequest* node = mFirstCallbackEventRequest;
 8509:     mFirstCallbackEventRequest = node->next;
 8509:     if (!mFirstCallbackEventRequest) {
 8509:       mLastCallbackEventRequest = nsnull;
 8509:     }
 8509:     nsIReflowCallback* callback = node->callback;
31620:     FreeMisc(sizeof(nsCallbackEventRequest), node);
 8509:     if (callback) {
 8509:       callback->ReflowCallbackCanceled();
 8509:     }
 8509:   }
 8509: }
 8509: 
 8509: void
27993: PresShell::HandlePostedReflowCallbacks(PRBool aInterruptible)
    1: {
    1:    PRBool shouldFlush = PR_FALSE;
    1: 
    1:    while (mFirstCallbackEventRequest) {
    1:      nsCallbackEventRequest* node = mFirstCallbackEventRequest;
    1:      mFirstCallbackEventRequest = node->next;
    1:      if (!mFirstCallbackEventRequest) {
    1:        mLastCallbackEventRequest = nsnull;
    1:      }
    1:      nsIReflowCallback* callback = node->callback;
31620:      FreeMisc(sizeof(nsCallbackEventRequest), node);
    1:      if (callback) {
    1:        if (callback->ReflowFinished()) {
    1:          shouldFlush = PR_TRUE;
    1:        }
    1:      }
    1:    }
    1: 
27993:    mozFlushType flushType =
27993:      aInterruptible ? Flush_InterruptibleLayout : Flush_Layout;
    1:    if (shouldFlush)
27993:      FlushPendingNotifications(flushType);
    1: }
    1: 
39668: PRBool
40044: PresShell::IsSafeToFlush() const
    1: {
    1:   // Not safe if we are reflowing or in the middle of frame construction
39668:   PRBool isSafeToFlush = !mIsReflowing &&
29804:                          !mChangeNestCount;
29804: 
39668:   if (isSafeToFlush) {
    1:     // Not safe if we are painting
    1:     nsIViewManager* viewManager = GetViewManager();
    1:     if (viewManager) {
    1:       PRBool isPainting = PR_FALSE;
    1:       viewManager->IsPainting(isPainting);
    1:       if (isPainting) {
39668:         isSafeToFlush = PR_FALSE;
39668:       }
39668:     }
39668:   }
39668: 
39668:   return isSafeToFlush;
39668: }
39668: 
39668: 
39668: void
    1: PresShell::FlushPendingNotifications(mozFlushType aType)
    1: {
42480: #ifdef NS_FUNCTION_TIMER
42480:   NS_TIME_FUNCTION_DECLARE_DOCURL;
42480:   static const char *flushTypeNames[] = {
42480:     "Flush_Content",
42480:     "Flush_ContentAndNotify",
42480:     "Flush_Styles",
42480:     "Flush_InterruptibleLayout",
42480:     "Flush_Layout",
42480:     "Flush_Display"
42480:   };
42480:   NS_TIME_FUNCTION_MIN_FMT(1.0, "%s (line %d) (document: %s, type: %s)", MOZ_FUNCTION_NAME,
42480:                            __LINE__, docURL__.get(), flushTypeNames[aType - 1]);
42480: #endif
42480: 
 4886:   NS_ASSERTION(aType >= Flush_Frames, "Why did we get called?");
    1: 
39668:   PRBool isSafeToFlush = IsSafeToFlush();
52202: 
52202:   // If layout could possibly trigger scripts, then it's only safe to flush if
52202:   // it's safe to run script.
52202:   if (mDocument->GetScriptGlobalObject()) {
29804:     isSafeToFlush = isSafeToFlush && nsContentUtils::IsSafeToRunScript();
52202:   }
    1: 
    1:   NS_ASSERTION(!isSafeToFlush || mViewManager, "Must have view manager");
 4876:   // Make sure the view manager stays alive while batching view updates.
10730:   nsCOMPtr<nsIViewManager> viewManagerDeathGrip = mViewManager;
10730:   if (isSafeToFlush && mViewManager) {
  721:     // Processing pending notifications can kill us, and some callers only
  721:     // hold weak refs when calling FlushPendingNotifications().  :(
  721:     nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
  721: 
23685:     if (mResizeEvent.IsPending()) {
23685:       FireResizeEvent();
23685:       if (mIsDestroying) {
39668:         return;
23685:       }
23685:     }
23685: 
    1:     // Style reresolves not in conjunction with reflows can't cause
    1:     // painting or geometry changes, so don't bother with view update
    1:     // batching if we only have style reresolve
10730:     nsIViewManager::UpdateViewBatch batch(mViewManager);
    1: 
40701:     // We need to make sure external resource documents are flushed too (for
40701:     // example, svg filters that reference a filter in an external document
40701:     // need the frames in the external document to be constructed for the
40701:     // filter to work). We only need external resources to be flushed when the
40701:     // main document is flushing >= Flush_Frames, so we flush external
40701:     // resources here instead of nsDocument::FlushPendingNotifications.
40701:     mDocument->FlushExternalResources(aType);
40701: 
 5623:     // Force flushing of any pending content notifications that might have
 5623:     // queued up while our event was pending.  That will ensure that we don't
 5623:     // construct frames for content right now that's still waiting to be
 5623:     // notified on,
 5623:     mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
 6023: 
 6023:     // Process pending restyles, since any flush of the presshell wants
 6023:     // up-to-date style data.
 5623:     if (!mIsDestroying) {
49023:       mViewManager->FlushDelayedResize(PR_FALSE);
16226:       mPresContext->FlushPendingMediaFeatureValuesChanged();
16226: 
22507:       // Flush any pending update of the user font set, since that could
22507:       // cause style changes (for updating ex/ch units, and to cause a
22507:       // reflow).
22507:       mPresContext->FlushUserFontSet();
22507: 
38870: #ifdef MOZ_SMIL
38870:       // Flush any requested SMIL samples.
38870:       if (mDocument->HasAnimationController()) {
38870:         mDocument->GetAnimationController()->FlushResampleRequests();
38870:       }
38870: #endif // MOZ_SMIL
38870: 
23256:       nsAutoScriptBlocker scriptBlocker;
40938:       mFrameConstructor->CreateNeededFrames();
    1:       mFrameConstructor->ProcessPendingRestyles();
 5623:     }
 4886: 
 6023:     // Process whatever XBL constructors those restyles queued up.  This
 6023:     // ensures that onload doesn't fire too early and that we won't do extra
 6023:     // reflows after those constructors run.
 5872:     if (!mIsDestroying) {
 5872:       mDocument->BindingManager()->ProcessAttachedQueue();
 5872:     }
 5872: 
 6023:     // Now those constructors might have posted restyle events.  At the same
 6023:     // time, we still need up-to-date style data.  In particular, reflow
 6023:     // depends on style being completely up to date.  If it's not, then style
 6023:     // context reparenting, which can happen during reflow, might suddenly pick
 6023:     // up the new rules and we'll end up with frames whose style doesn't match
 6023:     // the frame type.
 6023:     if (!mIsDestroying) {
23256:       nsAutoScriptBlocker scriptBlocker;
40938:       mFrameConstructor->CreateNeededFrames();
 6023:       mFrameConstructor->ProcessPendingRestyles();
 6023:     }
 6023: 
21925: 
 6023:     // There might be more pending constructors now, but we're not going to
 6023:     // worry about them.  They can't be triggered during reflow, so we should
 6023:     // be good.
 6023: 
27993:     if (aType >= (mSuppressInterruptibleReflows ? Flush_Layout : Flush_InterruptibleLayout) &&
27993:         !mIsDestroying) {
  550:       mFrameConstructor->RecalcQuotesAndCounters();
49023:       mViewManager->FlushDelayedResize(PR_TRUE);
27993:       if (ProcessReflowCommands(aType < Flush_Layout) && mContentToScrollTo) {
27993:         // We didn't get interrupted.  Go ahead and scroll to our content
27993:         DoScrollContentIntoView(mContentToScrollTo, mContentScrollVPosition,
56647:                                 mContentScrollHPosition,
56647:                                 SCROLL_OVERFLOW_HIDDEN);
27993:         mContentToScrollTo = nsnull;
27993:       }
    1:     }
    1: 
47756:     if (aType >= Flush_Layout) {
47756:       // Flush plugin geometry. Don't flush plugin geometry for
47756:       // interruptible layouts, since WillPaint does an interruptible
47756:       // layout.
47756:       nsRootPresContext* rootPresContext = mPresContext->GetRootPresContext();
47756:       if (rootPresContext) {
47756:         rootPresContext->UpdatePluginGeometry();
47756:       }
47756:     }
47756: 
    1:     PRUint32 updateFlags = NS_VMREFRESH_NO_SYNC;
 4886:     if (aType >= Flush_Display) {
    1:       // Flushing paints, so perform the invalidates and drawing
    1:       // immediately
    1:       updateFlags = NS_VMREFRESH_IMMEDIATE;
    1:     }
10730:     batch.EndUpdateViewBatch(updateFlags);
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::CharacterDataChanged(nsIDocument *aDocument,
    1:                                 nsIContent*  aContent,
    1:                                 CharacterDataChangeInfo* aInfo)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected CharacterDataChanged");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
    1: 
29804:   nsAutoCauseReflowNotifier crNotifier(this);
13098: 
    1:   if (mCaret) {
    1:     // Invalidate the caret's current location before we call into the frame
    1:     // constructor. It is important to do this now, and not wait until the
    1:     // resulting reflow, because this call causes continuation frames of the
    1:     // text frame the caret is in to forget what part of the content they
    1:     // refer to, making it hard for them to return the correct continuation
    1:     // frame to the caret.
    1:     mCaret->InvalidateOutsideCaret();
    1:   }
11845: 
11845:   // Call this here so it only happens for real content mutations and
11845:   // not cases when the frame constructor calls its own methods to force
11845:   // frame reconstruction.
11845:   nsIContent *container = aContent->GetParent();
11845:   PRUint32 selectorFlags =
11845:     container ? (container->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
16128:   if (selectorFlags != 0 && !aContent->IsRootOfAnonymousSubtree()) {
42324:     Element* element = container->AsElement();
42324:     if (aInfo->mAppend && !aContent->GetNextSibling())
42324:       mFrameConstructor->RestyleForAppend(element, aContent);
11845:     else
42324:       mFrameConstructor->RestyleForInsertOrChange(element, aContent);
11845:   }
11845: 
31131:   mFrameConstructor->CharacterDataChanged(aContent, aInfo);
    1:   VERIFY_STYLE_TREE;
    1: }
    1: 
    1: void
    1: PresShell::ContentStatesChanged(nsIDocument* aDocument,
    1:                                 nsIContent* aContent1,
    1:                                 nsIContent* aContent2,
56168:                                 nsEventStates aStateMask)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentStatesChanged");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
    1: 
 3410:   if (mDidInitialReflow) {
29804:     nsAutoCauseReflowNotifier crNotifier(this);
    1:     mFrameConstructor->ContentStatesChanged(aContent1, aContent2, aStateMask);
    1:     VERIFY_STYLE_TREE;
    1:   }
 3410: }
    1: 
35534: void
39698: PresShell::DocumentStatesChanged(nsIDocument* aDocument,
56168:                                  nsEventStates aStateMask)
39698: {
39698:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected DocumentStatesChanged");
39698:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
39698: 
39698:   if (mDidInitialReflow &&
39698:       mStyleSet->HasDocumentStateDependentStyle(mPresContext,
41634:                                                 mDocument->GetRootElement(),
39698:                                                 aStateMask)) {
41634:     mFrameConstructor->PostRestyleEvent(mDocument->GetRootElement(),
43793:                                         eRestyle_Subtree, NS_STYLE_HINT_NONE);
39698:     VERIFY_STYLE_TREE;
39698:   }
47737: 
56168:   if (aStateMask.HasState(NS_DOCUMENT_STATE_WINDOW_INACTIVE)) {
47737:     nsIFrame* root = FrameManager()->GetRootFrame();
47737:     if (root) {
47737:       // It's a display root. So, invalidate the layer contents of
47737:       // everything we can find. We need to do this because the contents
47737:       // of controls etc can depend on whether the window is active,
47737:       // and when a window becomes (in)active it just gets repainted
47737:       // and we don't specifically invalidate each affected control.
47737:       nsIWidget* widget = root->GetNearestWidget();
47737:       if (widget) {
47737:         LayerManager* layerManager = widget->GetLayerManager();
47737:         if (layerManager) {
47737:           FrameLayerBuilder::InvalidateAllThebesLayerContents(layerManager);
47737:         }
47737:       }
47737:     }
47737:   }
39698: }
39698: 
39698: void
35534: PresShell::AttributeWillChange(nsIDocument* aDocument,
51352:                                Element*     aElement,
35534:                                PRInt32      aNameSpaceID,
35534:                                nsIAtom*     aAttribute,
35534:                                PRInt32      aModType)
35534: {
51352:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected AttributeWillChange");
35534:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
35534: 
35534:   // XXXwaterson it might be more elegant to wait until after the
35534:   // initial reflow to begin observing the document. That would
35534:   // squelch any other inappropriate notifications as well.
35534:   if (mDidInitialReflow) {
35534:     nsAutoCauseReflowNotifier crNotifier(this);
51352:     mFrameConstructor->AttributeWillChange(aElement, aNameSpaceID,
35534:                                            aAttribute, aModType);
35534:     VERIFY_STYLE_TREE;
35534:   }
35534: }
    1: 
    1: void
    1: PresShell::AttributeChanged(nsIDocument* aDocument,
51350:                             Element*     aElement,
    1:                             PRInt32      aNameSpaceID,
    1:                             nsIAtom*     aAttribute,
35535:                             PRInt32      aModType)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected AttributeChanged");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
    1: 
    1:   // XXXwaterson it might be more elegant to wait until after the
    1:   // initial reflow to begin observing the document. That would
    1:   // squelch any other inappropriate notifications as well.
    1:   if (mDidInitialReflow) {
29804:     nsAutoCauseReflowNotifier crNotifier(this);
51350:     mFrameConstructor->AttributeChanged(aElement, aNameSpaceID,
35535:                                         aAttribute, aModType);
    1:     VERIFY_STYLE_TREE;
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::ContentAppended(nsIDocument *aDocument,
    1:                            nsIContent* aContainer,
42107:                            nsIContent* aFirstNewContent,
    1:                            PRInt32     aNewIndexInContainer)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentAppended");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
11845:   NS_PRECONDITION(aContainer, "must have container");
    1:   
    1:   if (!mDidInitialReflow) {
    1:     return;
    1:   }
    1:   
29804:   nsAutoCauseReflowNotifier crNotifier(this);
    1: 
11845:   // Call this here so it only happens for real content mutations and
11845:   // not cases when the frame constructor calls its own methods to force
11845:   // frame reconstruction.
42324:   mFrameConstructor->RestyleForAppend(aContainer->AsElement(), aFirstNewContent);
11845: 
47668:   mFrameConstructor->ContentAppended(aContainer, aFirstNewContent, PR_TRUE);
    1:   VERIFY_STYLE_TREE;
    1: }
    1: 
    1: void
    1: PresShell::ContentInserted(nsIDocument* aDocument,
    1:                            nsIContent*  aContainer,
    1:                            nsIContent*  aChild,
    1:                            PRInt32      aIndexInContainer)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentInserted");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
    1: 
    1:   if (!mDidInitialReflow) {
    1:     return;
    1:   }
    1:   
29804:   nsAutoCauseReflowNotifier crNotifier(this);
11845: 
11845:   // Call this here so it only happens for real content mutations and
11845:   // not cases when the frame constructor calls its own methods to force
11845:   // frame reconstruction.
11845:   if (aContainer)
42324:     mFrameConstructor->RestyleForInsertOrChange(aContainer->AsElement(), aChild);
11845: 
47667:   mFrameConstructor->ContentInserted(aContainer, aChild, nsnull, PR_TRUE);
    1:   VERIFY_STYLE_TREE;
    1: }
    1: 
    1: void
    1: PresShell::ContentRemoved(nsIDocument *aDocument,
    1:                           nsIContent* aContainer,
    1:                           nsIContent* aChild,
48038:                           PRInt32     aIndexInContainer,
48038:                           nsIContent* aPreviousSibling)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentRemoved");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
    1: 
    1:   // Make sure that the caret doesn't leave a turd where the child used to be.
    1:   if (mCaret) {
    1:     mCaret->InvalidateOutsideCaret();
    1:   }
    1: 
    1:   // Notify the ESM that the content has been removed, so that
    1:   // it can clean up any state related to the content.
29018:   mPresContext->EventStateManager()->ContentRemoved(aDocument, aChild);
    1: 
29804:   nsAutoCauseReflowNotifier crNotifier(this);
11845: 
11845:   // Call this here so it only happens for real content mutations and
11845:   // not cases when the frame constructor calls its own methods to force
11845:   // frame reconstruction.
47669:   nsIContent* oldNextSibling;
47669:   if (aContainer) {
47669:     oldNextSibling = aContainer->GetChildAt(aIndexInContainer);
47669:   } else {
47669:     oldNextSibling = nsnull;
47669:   }
47669:   
11845:   if (aContainer)
42324:     mFrameConstructor->RestyleForRemove(aContainer->AsElement(), aChild,
47669:                                         oldNextSibling);
11845: 
 7681:   PRBool didReconstruct;
47669:   mFrameConstructor->ContentRemoved(aContainer, aChild, oldNextSibling,
29501:                                     nsCSSFrameConstructor::REMOVE_CONTENT,
29501:                                     &didReconstruct);
    1: 
    1:   VERIFY_STYLE_TREE;
    1: }
    1: 
    1: nsresult
    1: PresShell::ReconstructFrames(void)
    1: {
36817:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
36817: 
36817:   // Have to make sure that the content notifications are flushed before we
36817:   // start messing with the frame model; otherwise we can get content doubling.
36817:   mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
36817: 
29804:   nsAutoCauseReflowNotifier crNotifier(this);
15817:   mFrameConstructor->BeginUpdate();
13098:   nsresult rv = mFrameConstructor->ReconstructDocElementHierarchy();
    1:   VERIFY_STYLE_TREE;
15817:   mFrameConstructor->EndUpdate();
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsIPresShell::ReconstructStyleDataInternal()
    1: {
    1:   mStylesHaveChanged = PR_FALSE;
    1: 
21925:   if (mIsDestroying) {
21925:     // We don't want to mess with restyles at this point
21925:     return;
21925:   }
21925: 
21925:   if (mPresContext) {
21925:     mPresContext->RebuildUserFontSet();
21925:   }
21925: 
41634:   Element* root = mDocument->GetRootElement();
21920:   if (!mDidInitialReflow) {
21920:     // Nothing to do here, since we have no frames yet
21920:     return;
21920:   }
21920: 
    1:   if (!root) {
    1:     // No content to restyle
    1:     return;
    1:   }
    1:   
43793:   mFrameConstructor->PostRestyleEvent(root, eRestyle_Subtree, NS_STYLE_HINT_NONE);
    1: }
    1: 
    1: void
    1: nsIPresShell::ReconstructStyleDataExternal()
    1: {
    1:   ReconstructStyleDataInternal();
    1: }
    1: 
    1: void
    1: PresShell::StyleSheetAdded(nsIDocument *aDocument,
    1:                            nsIStyleSheet* aStyleSheet,
    1:                            PRBool aDocumentSheet)
    1: {
    1:   // We only care when enabled sheets are added
    1:   NS_PRECONDITION(aStyleSheet, "Must have a style sheet!");
42232: 
42332:   if (aStyleSheet->IsApplicable() && aStyleSheet->HasRules()) {
    1:     mStylesHaveChanged = PR_TRUE;
    1:   }
    1: }
    1: 
    1: void 
    1: PresShell::StyleSheetRemoved(nsIDocument *aDocument,
    1:                              nsIStyleSheet* aStyleSheet,
    1:                              PRBool aDocumentSheet)
    1: {
    1:   // We only care when enabled sheets are removed
    1:   NS_PRECONDITION(aStyleSheet, "Must have a style sheet!");
42232: 
42332:   if (aStyleSheet->IsApplicable() && aStyleSheet->HasRules()) {
    1:     mStylesHaveChanged = PR_TRUE;
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::StyleSheetApplicableStateChanged(nsIDocument *aDocument,
    1:                                             nsIStyleSheet* aStyleSheet,
    1:                                             PRBool aApplicable)
    1: {
    1:   if (aStyleSheet->HasRules()) {
    1:     mStylesHaveChanged = PR_TRUE;
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::StyleRuleChanged(nsIDocument *aDocument,
    1:                             nsIStyleSheet* aStyleSheet,
    1:                             nsIStyleRule* aOldStyleRule,
    1:                             nsIStyleRule* aNewStyleRule)
    1: {
    1:   mStylesHaveChanged = PR_TRUE;
    1: }
    1: 
    1: void
    1: PresShell::StyleRuleAdded(nsIDocument *aDocument,
    1:                           nsIStyleSheet* aStyleSheet,
    1:                           nsIStyleRule* aStyleRule) 
    1: {
    1:   mStylesHaveChanged = PR_TRUE;
    1: }
    1: 
    1: void
    1: PresShell::StyleRuleRemoved(nsIDocument *aDocument,
    1:                             nsIStyleSheet* aStyleSheet,
    1:                             nsIStyleRule* aStyleRule) 
    1: {
    1:   mStylesHaveChanged = PR_TRUE;
    1: }
    1: 
    1: nsIFrame*
10998: PresShell::GetRealPrimaryFrameFor(nsIContent* aContent) const
10998: {
36656:   if (aContent->GetDocument() != GetDocument()) {
36656:     return nsnull;
36656:   }
36656:   nsIFrame *primaryFrame = aContent->GetPrimaryFrame();
10998:   if (!primaryFrame)
10998:     return nsnull;
10998:   return nsPlaceholderFrame::GetRealFrameFor(primaryFrame);
10998: }
10998: 
39668: nsIFrame*
39668: PresShell::GetPlaceholderFrameFor(nsIFrame* aFrame) const
39668: {
39668:   return FrameManager()->GetPlaceholderFrameFor(aFrame);
    1: }
    1: 
47739: nsresult
47739: PresShell::RenderDocument(const nsRect& aRect, PRUint32 aFlags,
47739:                           nscolor aBackgroundColor,
47739:                           gfxContext* aThebesContext)
47739: {
47739:   NS_TIME_FUNCTION_WITH_DOCURL;
47739: 
47739:   NS_ENSURE_TRUE(!(aFlags & RENDER_IS_UNTRUSTED), NS_ERROR_NOT_IMPLEMENTED);
47739: 
59486:   nsAutoScriptBlocker blockScripts;
59486: 
47739:   // Set up the rectangle as the path in aThebesContext
 7683:   gfxRect r(0, 0,
 7683:             nsPresContext::AppUnitsToFloatCSSPixels(aRect.width),
 7683:             nsPresContext::AppUnitsToFloatCSSPixels(aRect.height));
20226:   aThebesContext->NewPath();
20282: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
20226:   aThebesContext->Rectangle(r, PR_TRUE);
20226: #else
20226:   aThebesContext->Rectangle(r);
20226: #endif
47739: 
47739:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
47739:   if (!rootFrame) {
47739:     // Nothing to paint, just fill the rect
47739:     aThebesContext->SetColor(gfxRGBA(aBackgroundColor));
47739:     aThebesContext->Fill();
47739:     return NS_OK;
47739:   }
47739: 
47739:   gfxContextAutoSaveRestore save(aThebesContext);
47739: 
47739:   gfxContext::GraphicsOperator oldOperator = aThebesContext->CurrentOperator();
47739:   if (oldOperator == gfxContext::OPERATOR_OVER) {
47739:     // Clip to the destination rectangle before we push the group,
47739:     // to limit the size of the temporary surface
20226:     aThebesContext->Clip();
47739:   }
47739: 
47739:   // we want the window to be composited as a single image using
47739:   // whatever operator was set; set OPERATOR_OVER here, which is
47739:   // either already the case, or overrides the operator in a group.
47739:   // the original operator will be present when we PopGroup.
20226:   // we can avoid using a temporary surface if we're using OPERATOR_OVER
20226:   // and our background color has no alpha (so we'll be compositing on top
20226:   // of a fully opaque solid color region)
47739:   PRBool needsGroup = NS_GET_A(aBackgroundColor) < 0xff ||
47739:     oldOperator != gfxContext::OPERATOR_OVER;
20226: 
20226:   if (needsGroup) {
 1735:     aThebesContext->PushGroup(NS_GET_A(aBackgroundColor) == 0xff ?
 1735:                               gfxASurface::CONTENT_COLOR :
 1735:                               gfxASurface::CONTENT_COLOR_ALPHA);
 1735:     aThebesContext->Save();
47739: 
47739:     if (oldOperator != gfxContext::OPERATOR_OVER) {
47739:       // Clip now while we paint to the temporary surface. For
47739:       // non-source-bounded operators (e.g., SOURCE), we need to do clip
47739:       // here after we've pushed the group, so that eventually popping
47739:       // the group and painting it will be able to clear the entire
47739:       // destination surface.
47739:       aThebesContext->Clip();
34441:       aThebesContext->SetOperator(gfxContext::OPERATOR_OVER);
47739:     }
47739:   }
47739: 
47739:   aThebesContext->Translate(gfxPoint(-nsPresContext::AppUnitsToFloatCSSPixels(aRect.x),
47739:                                      -nsPresContext::AppUnitsToFloatCSSPixels(aRect.y)));
 1735: 
 1735:   nsIDeviceContext* devCtx = mPresContext->DeviceContext();
 7683:   gfxFloat scale = gfxFloat(devCtx->AppUnitsPerDevPixel())/nsPresContext::AppUnitsPerCSSPixel();
 7683:   aThebesContext->Scale(scale, scale);
 7683: 
47758:   // Since canvas APIs use floats to set up their matrices, we may have
47758:   // some slight inaccuracy here. Adjust matrix components that are
47758:   // integers up to the accuracy of floats to be those integers.
47758:   aThebesContext->NudgeCurrentMatrixToIntegers();
47758: 
54080:   AutoSaveRestoreRenderingState _(this);
54080: 
 1735:   nsCOMPtr<nsIRenderingContext> rc;
 1735:   devCtx->CreateRenderingContextInstance(*getter_AddRefs(rc));
 1735:   rc->Init(devCtx, aThebesContext);
 1735: 
54080:   PRBool wouldFlushRetainedLayers = PR_FALSE;
48224:   PRUint32 flags = nsLayoutUtils::PAINT_IGNORE_SUPPRESSION;
60027:   if (aThebesContext->CurrentMatrix().HasNonIntegerTranslation()) {
60027:     flags |= nsLayoutUtils::PAINT_IN_TRANSFORM;
60027:   }
48224:   if (!(aFlags & RENDER_ASYNC_DECODE_IMAGES)) {
48224:     flags |= nsLayoutUtils::PAINT_SYNC_DECODE_IMAGES;
48224:   }
38805:   if (aFlags & RENDER_USE_WIDGET_LAYERS) {
49168:     // We only support using widget layers on display root's with widgets.
49168:     nsIView* view = rootFrame->GetView();
49168:     if (view && view->GetWidget() &&
49168:         nsLayoutUtils::GetDisplayRootFrame(rootFrame) == rootFrame) {
47739:       flags |= nsLayoutUtils::PAINT_WIDGET_LAYERS;
47739:     }
49168:   }
47739:   if (!(aFlags & RENDER_CARET)) {
54080:     wouldFlushRetainedLayers = PR_TRUE;
47739:     flags |= nsLayoutUtils::PAINT_HIDE_CARET;
47739:   }
47739:   if (aFlags & RENDER_IGNORE_VIEWPORT_SCROLLING) {
54080:     wouldFlushRetainedLayers = !IgnoringViewportScrolling();
54087:     mRenderFlags = ChangeFlag(mRenderFlags, PR_TRUE, STATE_IGNORING_VIEWPORT_SCROLLING);
51761:   }
54079:   if (aFlags & RENDER_DOCUMENT_RELATIVE) {
54080:     // XXX be smarter about this ... drawWindow might want a rect
54080:     // that's "pretty close" to what our retained layer tree covers.
54080:     // In that case, it wouldn't disturb normal rendering too much,
54080:     // and we should allow it.
54080:     wouldFlushRetainedLayers = PR_TRUE;
54079:     flags |= nsLayoutUtils::PAINT_DOCUMENT_RELATIVE;
54079:   }
54080: 
54080:   // Don't let drawWindow blow away our retained layer tree
54080:   if ((flags & nsLayoutUtils::PAINT_WIDGET_LAYERS) && wouldFlushRetainedLayers) {
54080:     flags &= ~nsLayoutUtils::PAINT_WIDGET_LAYERS;
54080:   }
54080: 
47739:   nsLayoutUtils::PaintFrame(rc, rootFrame, nsRegion(aRect),
47739:                             aBackgroundColor, flags);
34441: 
20226:   // if we had to use a group, paint it to the destination now
20226:   if (needsGroup) {
 1735:     aThebesContext->Restore();
 1735:     aThebesContext->PopGroupToSource();
 1735:     aThebesContext->Paint();
20226:   }
 1735: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Clip the display list aList to a range. Returns the clipped
    1:  * rectangle surrounding the range.
    1:  */
    1: nsRect
    1: PresShell::ClipListToRange(nsDisplayListBuilder *aBuilder,
    1:                            nsDisplayList* aList,
 4741:                            nsIRange* aRange)
    1: {
42480:   NS_TIME_FUNCTION_WITH_DOCURL;
42480: 
    1:   // iterate though the display items and add up the bounding boxes of each.
    1:   // This will allow the total area of the frames within the range to be
    1:   // determined. To do this, remove an item from the bottom of the list, check
    1:   // whether it should be part of the range, and if so, append it to the top
    1:   // of the temporary list tmpList. If the item is a text frame at the end of
    1:   // the selection range, wrap it in an nsDisplayClip to clip the display to
    1:   // the portion of the text frame that is part of the selection. Then, append
    1:   // the wrapper to the top of the list. Otherwise, just delete the item and
    1:   // don't append it.
    1:   nsRect surfaceRect;
    1:   nsDisplayList tmpList;
    1: 
    1:   nsDisplayItem* i;
    1:   while ((i = aList->RemoveBottom())) {
    1:     // itemToInsert indiciates the item that should be inserted into the
    1:     // temporary list. If null, no item should be inserted.
    1:     nsDisplayItem* itemToInsert = nsnull;
    1:     nsIFrame* frame = i->GetUnderlyingFrame();
    1:     if (frame) {
    1:       nsIContent* content = frame->GetContent();
    1:       if (content) {
    1:         PRBool atStart = (content == aRange->GetStartParent());
    1:         PRBool atEnd = (content == aRange->GetEndParent());
    1:         if ((atStart || atEnd) && frame->GetType() == nsGkAtoms::textFrame) {
    1:           PRInt32 frameStartOffset, frameEndOffset;
    1:           frame->GetOffsets(frameStartOffset, frameEndOffset);
    1: 
    1:           PRInt32 hilightStart =
32531:             atStart ? NS_MAX(aRange->StartOffset(), frameStartOffset) : frameStartOffset;
    1:           PRInt32 hilightEnd =
32531:             atEnd ? NS_MIN(aRange->EndOffset(), frameEndOffset) : frameEndOffset;
    1:           if (hilightStart < hilightEnd) {
    1:             // determine the location of the start and end edges of the range.
    1:             nsPoint startPoint, endPoint;
 4741:             frame->GetPointFromOffset(hilightStart, &startPoint);
 4741:             frame->GetPointFromOffset(hilightEnd, &endPoint);
    1: 
    1:             // the clip rectangle is determined by taking the the start and
    1:             // end points of the range, offset from the reference frame.
    1:             // Because of rtl, the end point may be to the left of the
    1:             // start point, so x is set to the lowest value
    1:             nsRect textRect(aBuilder->ToReferenceFrame(frame), frame->GetSize());
32531:             nscoord x = NS_MIN(startPoint.x, endPoint.x);
    1:             textRect.x += x;
32531:             textRect.width = NS_MAX(startPoint.x, endPoint.x) - x;
    1:             surfaceRect.UnionRect(surfaceRect, textRect);
    1: 
    1:             // wrap the item in an nsDisplayClip so that it can be clipped to
    1:             // the selection. If the allocation fails, fall through and delete
    1:             // the item below.
51260:             itemToInsert = new (aBuilder)
52289:                 nsDisplayClip(aBuilder, frame, i, textRect);
    1:           }
    1:         }
43138:         // Don't try to descend into subdocuments.
43138:         // If this ever changes we'd need to add handling for subdocuments with
43138:         // different zoom levels.
43138:         else if (content->GetCurrentDoc() ==
43138:                    aRange->GetStartParent()->GetCurrentDoc()) {
    1:           // if the node is within the range, append it to the temporary list
    1:           PRBool before, after;
43138:           nsresult rv =
    1:             nsRange::CompareNodeToRange(content, aRange, &before, &after);
43138:           if (NS_SUCCEEDED(rv) && !before && !after) {
    1:             itemToInsert = i;
    1:             surfaceRect.UnionRect(surfaceRect, i->GetBounds(aBuilder));
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
    1:     // insert the item into the list if necessary. If the item has a child
    1:     // list, insert that as well
    1:     nsDisplayList* sublist = i->GetList();
    1:     if (itemToInsert || sublist) {
    1:       tmpList.AppendToTop(itemToInsert ? itemToInsert : i);
    1:       // if the item is a list, iterate over it as well
    1:       if (sublist)
    1:         surfaceRect.UnionRect(surfaceRect,
 4741:           ClipListToRange(aBuilder, sublist, aRange));
    1:     }
    1:     else {
    1:       // otherwise, just delete the item and don't readd it to the list
    1:       i->~nsDisplayItem();
    1:     }
    1:   }
    1: 
    1:   // now add all the items back onto the original list again
    1:   aList->AppendToTop(&tmpList);
    1: 
    1:   return surfaceRect;
    1: }
    1: 
43138: #ifdef DEBUG
43138: #include <stdio.h>
43138: 
43138: static PRBool gDumpRangePaintList = PR_FALSE;
43138: #endif
43138: 
    1: RangePaintInfo*
    1: PresShell::CreateRangePaintInfo(nsIDOMRange* aRange,
47337:                                 nsRect& aSurfaceRect,
47337:                                 PRBool aForPrimarySelection)
    1: {
42480:   NS_TIME_FUNCTION_WITH_DOCURL;
42480: 
    1:   RangePaintInfo* info = nsnull;
    1: 
    1:   nsCOMPtr<nsIRange> range = do_QueryInterface(aRange);
    1:   if (!range)
    1:     return nsnull;
    1: 
  219:   nsIFrame* ancestorFrame;
  219:   nsIFrame* rootFrame = GetRootFrame();
  219: 
  219:   // If the start or end of the range is the document, just use the root
  219:   // frame, otherwise get the common ancestor of the two endpoints of the
  219:   // range.
  219:   nsINode* startParent = range->GetStartParent();
  219:   nsINode* endParent = range->GetEndParent();
  219:   nsIDocument* doc = startParent->GetCurrentDoc();
  219:   if (startParent == doc || endParent == doc) {
  219:     ancestorFrame = rootFrame;
  219:   }
  219:   else {
  219:     nsINode* ancestor = nsContentUtils::GetCommonAncestor(startParent, endParent);
    1:     NS_ASSERTION(!ancestor || ancestor->IsNodeOfType(nsINode::eCONTENT),
    1:                  "common ancestor is not content");
    1:     if (!ancestor || !ancestor->IsNodeOfType(nsINode::eCONTENT))
    1:       return nsnull;
    1: 
 3233:     nsIContent* ancestorContent = static_cast<nsIContent*>(ancestor);
36656:     ancestorFrame = ancestorContent->GetPrimaryFrame();
    1: 
    1:     // use the nearest ancestor frame that includes all continuations as the
    1:     // root for building the display list
   94:     while (ancestorFrame &&
   94:            nsLayoutUtils::GetNextContinuationOrSpecialSibling(ancestorFrame))
    1:       ancestorFrame = ancestorFrame->GetParent();
  219:   }
    1: 
    1:   if (!ancestorFrame)
    1:     return nsnull;
    1: 
    1:   info = new RangePaintInfo(range, ancestorFrame);
    1:   if (!info)
    1:     return nsnull;
    1: 
55040:   nsRect ancestorRect = ancestorFrame->GetVisualOverflowRect();
    1: 
    1:   // get a display list containing the range
58774:   info->mBuilder.SetIncludeAllOutOfFlows();
47337:   if (aForPrimarySelection) {
47337:     info->mBuilder.SetSelectedFramesOnly();
47337:   }
    1:   info->mBuilder.EnterPresShell(ancestorFrame, ancestorRect);
    1:   ancestorFrame->BuildDisplayListForStackingContext(&info->mBuilder,
    1:                                                     ancestorRect, &info->mList);
    1: 
43138: #ifdef DEBUG
43138:   if (gDumpRangePaintList) {
43138:     fprintf(stderr, "CreateRangePaintInfo --- before ClipListToRange:\n");
43138:     nsFrame::PrintDisplayList(&(info->mBuilder), info->mList);
43138:   }
43138: #endif
43138: 
 4741:   nsRect rangeRect = ClipListToRange(&info->mBuilder, &info->mList, range);
    1: 
60095:   info->mBuilder.LeavePresShell(ancestorFrame, ancestorRect);
60095: 
43138: #ifdef DEBUG
43138:   if (gDumpRangePaintList) {
43138:     fprintf(stderr, "CreateRangePaintInfo --- after ClipListToRange:\n");
43138:     nsFrame::PrintDisplayList(&(info->mBuilder), info->mList);
43138:   }
43138: #endif
43138: 
    1:   // determine the offset of the reference frame for the display list
    1:   // to the root frame. This will allow the coordinates used when painting
    1:   // to all be offset from the same point
  219:   info->mRootOffset = ancestorFrame->GetOffsetTo(rootFrame);
    1:   rangeRect.MoveBy(info->mRootOffset);
    1:   aSurfaceRect.UnionRect(aSurfaceRect, rangeRect);
    1: 
    1:   return info;
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
    1: PresShell::PaintRangePaintInfo(nsTArray<nsAutoPtr<RangePaintInfo> >* aItems,
    1:                                nsISelection* aSelection,
43137:                                nsIntRegion* aRegion,
    1:                                nsRect aArea,
23738:                                nsIntPoint& aPoint,
23738:                                nsIntRect* aScreenRect)
    1: {
42480:   NS_TIME_FUNCTION_WITH_DOCURL;
42480: 
    1:   nsPresContext* pc = GetPresContext();
 1562:   if (!pc || aArea.width == 0 || aArea.height == 0)
    1:     return nsnull;
    1: 
    1:   nsIDeviceContext* deviceContext = pc->DeviceContext();
    1: 
    1:   // use the rectangle to create the surface
28113:   nsIntRect pixelArea = aArea.ToOutsidePixels(pc->AppUnitsPerDevPixel());
    1: 
    1:   // if the area of the image is larger than the maximum area, scale it down
    1:   float scale = 0.0;
48930:   nsIntRect rootScreenRect =
48930:     GetRootFrame()->GetScreenRectInAppUnits().ToNearestPixels(
48930:       pc->AppUnitsPerDevPixel());
    1: 
    1:   // if the image is larger in one or both directions than half the size of
    1:   // the available screen area, scale the image down to that size.
    1:   nsRect maxSize;
    1:   deviceContext->GetClientRect(maxSize);
    1:   nscoord maxWidth = pc->AppUnitsToDevPixels(maxSize.width >> 1);
    1:   nscoord maxHeight = pc->AppUnitsToDevPixels(maxSize.height >> 1);
    1:   PRBool resize = (pixelArea.width > maxWidth || pixelArea.height > maxHeight);
    1:   if (resize) {
    1:     scale = 1.0;
    1:     // divide the maximum size by the image size in both directions. Whichever
    1:     // direction produces the smallest result determines how much should be
    1:     // scaled.
    1:     if (pixelArea.width > maxWidth)
32531:       scale = NS_MIN(scale, float(maxWidth) / pixelArea.width);
    1:     if (pixelArea.height > maxHeight)
32531:       scale = NS_MIN(scale, float(maxHeight) / pixelArea.height);
    1: 
    1:     pixelArea.width = NSToIntFloor(float(pixelArea.width) * scale);
    1:     pixelArea.height = NSToIntFloor(float(pixelArea.height) * scale);
    1: 
    1:     // adjust the screen position based on the rescaled size
    1:     nscoord left = rootScreenRect.x + pixelArea.x;
    1:     nscoord top = rootScreenRect.y + pixelArea.y;
    1:     aScreenRect->x = NSToIntFloor(aPoint.x - float(aPoint.x - left) * scale);
    1:     aScreenRect->y = NSToIntFloor(aPoint.y - float(aPoint.y - top) * scale);
    1:   }
    1:   else {
    1:     // move aScreenRect to the position of the surface in screen coordinates
    1:     aScreenRect->MoveTo(rootScreenRect.x + pixelArea.x, rootScreenRect.y + pixelArea.y);
    1:   }
    1:   aScreenRect->width = pixelArea.width;
    1:   aScreenRect->height = pixelArea.height;
    1: 
    1:   gfxImageSurface* surface =
    1:     new gfxImageSurface(gfxIntSize(pixelArea.width, pixelArea.height),
    1:                         gfxImageSurface::ImageFormatARGB32);
 1562:   if (!surface || surface->CairoStatus()) {
 1562:     delete surface;
    1:     return nsnull;
 1562:   }
    1: 
    1:   // clear the image
    1:   gfxContext context(surface);
    1:   context.SetOperator(gfxContext::OPERATOR_CLEAR);
    1:   context.Rectangle(gfxRect(0, 0, pixelArea.width, pixelArea.height));
    1:   context.Fill();
    1: 
    1:   nsCOMPtr<nsIRenderingContext> rc;
    1:   deviceContext->CreateRenderingContextInstance(*getter_AddRefs(rc));
    1:   rc->Init(deviceContext, surface);
    1: 
43137:   if (aRegion) {
43137:     // Convert aRegion from CSS pixels to dev pixels
43137:     nsIntRegion region =
43137:       aRegion->ToAppUnits(nsPresContext::AppUnitsPerCSSPixel())
43137:         .ToOutsidePixels(pc->AppUnitsPerDevPixel());
43137:     rc->SetClipRegion(region, nsClipCombine_kReplace);
43137:   }
    1: 
    1:   if (resize)
    1:     rc->Scale(scale, scale);
    1: 
    1:   // translate so that points are relative to the surface area
    1:   rc->Translate(-aArea.x, -aArea.y);
    1: 
    1:   // temporarily hide the selection so that text is drawn normally. If a
    1:   // selection is being rendered, use that, otherwise use the presshell's
    1:   // selection.
    1:   nsCOMPtr<nsFrameSelection> frameSelection;
    1:   if (aSelection) {
    1:     nsCOMPtr<nsISelectionPrivate> selpriv = do_QueryInterface(aSelection);
    1:     selpriv->GetFrameSelection(getter_AddRefs(frameSelection));
    1:   }
    1:   else {
    1:     frameSelection = FrameSelection();
    1:   }
    1:   PRInt16 oldDisplaySelection = frameSelection->GetDisplaySelection();
    1:   frameSelection->SetDisplaySelection(nsISelectionController::SELECTION_HIDDEN);
    1: 
    1:   // next, paint each range in the selection
    1:   PRInt32 count = aItems->Length();
    1:   for (PRInt32 i = 0; i < count; i++) {
    1:     RangePaintInfo* rangeInfo = (*aItems)[i];
    1:     // the display lists paint relative to the offset from the reference
    1:     // frame, so translate the rendering context
    1:     nsIRenderingContext::AutoPushTranslation
    1:       translate(rc, rangeInfo->mRootOffset.x, rangeInfo->mRootOffset.y);
    1: 
    1:     aArea.MoveBy(-rangeInfo->mRootOffset.x, -rangeInfo->mRootOffset.y);
33368:     nsRegion visible(aArea);
51633:     rangeInfo->mList.ComputeVisibilityForRoot(&rangeInfo->mBuilder, &visible);
42246:     rangeInfo->mList.PaintRoot(&rangeInfo->mBuilder, rc, nsDisplayList::PAINT_DEFAULT);
    1:     aArea.MoveBy(rangeInfo->mRootOffset.x, rangeInfo->mRootOffset.y);
    1:   }
    1: 
    1:   // restore the old selection display state
    1:   frameSelection->SetDisplaySelection(oldDisplaySelection);
    1: 
    1:   NS_ADDREF(surface);
    1:   return surface;
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
    1: PresShell::RenderNode(nsIDOMNode* aNode,
43137:                       nsIntRegion* aRegion,
23738:                       nsIntPoint& aPoint,
23738:                       nsIntRect* aScreenRect)
    1: {
    1:   // area will hold the size of the surface needed to draw the node, measured
    1:   // from the root frame.
    1:   nsRect area;
    1:   nsTArray<nsAutoPtr<RangePaintInfo> > rangeItems;
    1: 
18448:   // nothing to draw if the node isn't in a document
18448:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
18448:   if (!node->IsInDoc())
18448:     return nsnull;
18448:   
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   NS_NewRange(getter_AddRefs(range));
20084:   if (NS_FAILED(range->SelectNode(aNode)))
20084:     return nsnull;
    1: 
47337:   RangePaintInfo* info = CreateRangePaintInfo(range, area, PR_FALSE);
    1:   if (info && !rangeItems.AppendElement(info)) {
    1:     delete info;
    1:     return nsnull;
    1:   }
    1: 
    1:   if (aRegion) {
    1:     // combine the area with the supplied region
43137:     nsIntRect rrectPixels = aRegion->GetBounds();
    1: 
28113:     nsRect rrect = rrectPixels.ToAppUnits(nsPresContext::AppUnitsPerCSSPixel());
    1:     area.IntersectRect(area, rrect);
    1:     
    1:     nsPresContext* pc = GetPresContext();
    1:     if (!pc)
    1:       return nsnull;
    1: 
    1:     // move the region so that it is offset from the topleft corner of the surface
43138:     aRegion->MoveBy(-pc->AppUnitsToDevPixels(area.x),
43138:                     -pc->AppUnitsToDevPixels(area.y));
    1:   }
    1: 
    1:   return PaintRangePaintInfo(&rangeItems, nsnull, aRegion, area, aPoint,
    1:                              aScreenRect);
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
    1: PresShell::RenderSelection(nsISelection* aSelection,
23738:                            nsIntPoint& aPoint,
23738:                            nsIntRect* aScreenRect)
    1: {
    1:   // area will hold the size of the surface needed to draw the selection,
    1:   // measured from the root frame.
    1:   nsRect area;
    1:   nsTArray<nsAutoPtr<RangePaintInfo> > rangeItems;
    1: 
    1:   // iterate over each range and collect them into the rangeItems array.
    1:   // This is done so that the size of selection can be determined so as
    1:   // to allocate a surface area
    1:   PRInt32 numRanges;
    1:   aSelection->GetRangeCount(&numRanges);
 1562:   NS_ASSERTION(numRanges > 0, "RenderSelection called with no selection");
 1562: 
    1:   for (PRInt32 r = 0; r < numRanges; r++)
    1:   {
    1:     nsCOMPtr<nsIDOMRange> range;
    1:     aSelection->GetRangeAt(r, getter_AddRefs(range));
    1: 
47337:     RangePaintInfo* info = CreateRangePaintInfo(range, area, PR_TRUE);
    1:     if (info && !rangeItems.AppendElement(info)) {
    1:       delete info;
    1:       return nsnull;
    1:     }
    1:   }
    1: 
    1:   return PaintRangePaintInfo(&rangeItems, aSelection, nsnull, area, aPoint,
    1:                              aScreenRect);
    1: }
    1: 
49166: nsresult
49166: PresShell::AddPrintPreviewBackgroundItem(nsDisplayListBuilder& aBuilder,
49166:                                          nsDisplayList&        aList,
49166:                                          nsIFrame*             aFrame,
49166:                                          const nsRect&         aBounds)
49166: {
51260:   return aList.AppendNewToBottom(new (&aBuilder)
51260:     nsDisplaySolidColor(&aBuilder, aFrame, aBounds, NS_RGB(115, 115, 115)));
49166: }
49166: 
47741: static PRBool
47741: AddCanvasBackgroundColor(const nsDisplayList& aList, nsIFrame* aCanvasFrame,
47741:                          nscolor aColor)
47741: {
47741:   for (nsDisplayItem* i = aList.GetBottom(); i; i = i->GetAbove()) {
47741:     if (i->GetUnderlyingFrame() == aCanvasFrame &&
47741:         i->GetType() == nsDisplayItem::TYPE_CANVAS_BACKGROUND) {
47741:       nsDisplayCanvasBackground* bg = static_cast<nsDisplayCanvasBackground*>(i);
47741:       bg->SetExtraBackgroundColor(aColor);
47741:       return PR_TRUE;
47741:     }
47741:     nsDisplayList* sublist = i->GetList();
47741:     if (sublist && AddCanvasBackgroundColor(*sublist, aCanvasFrame, aColor))
47741:       return PR_TRUE;
47741:   }
47741:   return PR_FALSE;
47741: }
47741: 
29987: nsresult PresShell::AddCanvasBackgroundColorItem(nsDisplayListBuilder& aBuilder,
29987:                                                  nsDisplayList&        aList,
29987:                                                  nsIFrame*             aFrame,
47739:                                                  const nsRect&         aBounds,
35428:                                                  nscolor               aBackstopColor,
35428:                                                  PRBool                aForceDraw)
29987: {
30107:   // We don't want to add an item for the canvas background color if the frame
30107:   // (sub)tree we are painting doesn't include any canvas frames. There isn't
30107:   // an easy way to check this directly, but if we check if the root of the
30107:   // (sub)tree we are painting is a canvas frame that should cover us in all
30107:   // cases (it will usually be a viewport frame when we have a canvas frame in
30107:   // the (sub)tree).
35428:   if (!aForceDraw && !nsCSSRendering::IsCanvasFrame(aFrame))
30107:     return NS_OK;
30107: 
29987:   nscolor bgcolor = NS_ComposeColors(aBackstopColor, mCanvasBackgroundColor);
47741: 
47741:   // To make layers work better, we want to avoid having a big non-scrolled 
47741:   // color background behind a scrolled transparent background. Instead,
47741:   // we'll try to move the color background into the scrolled content
47741:   // by making nsDisplayCanvasBackground paint it.
47741:   if (!aFrame->GetParent()) {
47741:     nsIScrollableFrame* sf =
47741:       aFrame->PresContext()->PresShell()->GetRootScrollFrameAsScrollable();
47741:     if (sf) {
47741:       nsCanvasFrame* canvasFrame = do_QueryFrame(sf->GetScrolledFrame());
47741:       if (canvasFrame && canvasFrame->IsVisibleForPainting(&aBuilder)) {
47741:         if (AddCanvasBackgroundColor(aList, canvasFrame, bgcolor))
47741:           return NS_OK;
47741:       }
47741:     }
47741:   }
47741: 
47739:   return aList.AppendNewToBottom(
51260:       new (&aBuilder) nsDisplaySolidColor(&aBuilder, aFrame, aBounds, bgcolor));
29987: }
29987: 
51627: static PRBool IsTransparentContainerElement(nsPresContext* aPresContext)
51627: {
51627:   nsCOMPtr<nsISupports> container = aPresContext->GetContainerInternal();
51627:   nsCOMPtr<nsIDocShellTreeItem> docShellItem = do_QueryInterface(container);
51627:   nsCOMPtr<nsPIDOMWindow> pwin(do_GetInterface(docShellItem));
51627:   if (!pwin)
51627:     return PR_FALSE;
51627:   nsCOMPtr<nsIContent> containerElement =
51627:     do_QueryInterface(pwin->GetFrameElementInternal());
51627:   return containerElement &&
51627:          containerElement->HasAttr(kNameSpaceID_None, nsGkAtoms::transparent);
51627: }
51627: 
27834: void PresShell::UpdateCanvasBackground()
27834: {
25385:   // If we have a frame tree and it has style information that
25385:   // specifies the background color of the canvas, update our local
25385:   // cache of that color.
51627:   nsIFrame* rootStyleFrame = FrameConstructor()->GetRootElementStyleFrame();
51627:   if (rootStyleFrame) {
40177:     nsStyleContext* bgStyle =
51627:       nsCSSRendering::FindRootFrameBackground(rootStyleFrame);
29987:     // XXX We should really be passing the canvasframe, not the root element
29987:     // style frame but we don't have access to the canvasframe here. It isn't
29987:     // a problem because only a few frames can return something other than true
29987:     // and none of them would be a canvas frame or root element style frame.
29987:     mCanvasBackgroundColor =
51627:       nsCSSRendering::DetermineBackgroundColor(mPresContext, bgStyle,
51627:                                                rootStyleFrame);
52488:     if (GetPresContext()->IsRootContentDocument() &&
51627:         !IsTransparentContainerElement(mPresContext)) {
51627:       mCanvasBackgroundColor =
51627:         NS_ComposeColors(mPresContext->DefaultBackgroundColor(), mCanvasBackgroundColor);
51627:     }
29987:   }
29987: 
29987:   // If the root element of the document (ie html) has style 'display: none'
29987:   // then the document's background color does not get drawn; cache the
29987:   // color we actually draw.
29987:   if (!FrameConstructor()->GetRootElementFrame()) {
29987:     mCanvasBackgroundColor = mPresContext->DefaultBackgroundColor();
29987:   }
29987: }
29987: 
38805: nscolor PresShell::ComputeBackstopColor(nsIView* aDisplayRoot)
38805: {
38805:   nsIWidget* widget = aDisplayRoot->GetWidget();
29987:   if (widget && widget->GetTransparencyMode() != eTransparencyOpaque) {
29987:     // Within a transparent widget, so the backstop color must be
29987:     // totally transparent.
29987:     return NS_RGBA(0,0,0,0);
29987:   }
29987:   // Within an opaque widget (or no widget at all), so the backstop
29987:   // color must be totally opaque. The user's default background
29987:   // as reported by the prescontext is guaranteed to be opaque.
29987:   return GetPresContext()->DefaultBackgroundColor();
27834: }
27834: 
42593: struct PaintParams {
42593:   nsIFrame* mFrame;
42593:   nsPoint mOffsetToWidget;
42593:   const nsRegion* mDirtyRegion;
42593:   nscolor mBackgroundColor;
42593: };
42593: 
48947: LayerManager* PresShell::GetLayerManager()
48947: {
48947:   NS_ASSERTION(mViewManager, "Should have view manager");
48947: 
48947:   nsIView* rootView;
48947:   if (NS_SUCCEEDED(mViewManager->GetRootView(rootView)) && rootView) {
48947:     if (nsIWidget* widget = rootView->GetWidget()) {
48947:       return widget->GetLayerManager();
48947:     }
48947:   }
48947:   return nsnull;
48947: }
48947: 
54080: void PresShell::SetIgnoreViewportScrolling(PRBool aIgnore)
54080: {
54080:   if (IgnoringViewportScrolling() == aIgnore) {
54080:     return;
54080:   }
54080:   RenderingState state(this);
54080:   state.mRenderFlags = ChangeFlag(state.mRenderFlags, aIgnore,
54080:                                   STATE_IGNORING_VIEWPORT_SCROLLING);
54080:   SetRenderingState(state);
54080: }
54080: 
54080: void PresShell::SetDisplayPort(const nsRect& aDisplayPort)
54080: {
54080:   if (UsingDisplayPort() && mDisplayPort == aDisplayPort) {
54080:     return;
54080:   }
54080:   RenderingState state(this);
54080:   state.mRenderFlags = ChangeFlag(mRenderFlags, PR_TRUE,
54080:                                   STATE_USING_DISPLAYPORT);
54080:   state.mDisplayPort = aDisplayPort;
54080:   SetRenderingState(state);
54080: }
54080: 
54081: nsresult PresShell::SetResolution(float aXResolution, float aYResolution)
54081: {
54081:   if (!(aXResolution > 0.0 && aXResolution > 0.0)) {
54081:     return NS_ERROR_ILLEGAL_VALUE;
54081:   }
54081:   if (aXResolution == mXResolution && aYResolution == mYResolution) {
54081:     return NS_OK;
54081:   }
54081:   RenderingState state(this);
54081:   state.mXResolution = aXResolution;
54081:   state.mYResolution = aYResolution;
54081:   SetRenderingState(state);
54081:   return NS_OK;
54081:  }
54081: 
54080: void PresShell::SetRenderingState(const RenderingState& aState)
54080: {
54080:   if (mRenderFlags != aState.mRenderFlags) {
54080:     // Rendering state changed in a way that forces us to flush any
54080:     // retained layers we might already have.
54080:     LayerManager* manager = GetLayerManager();
54080:     if (manager) {
54080:       FrameLayerBuilder::InvalidateAllLayers(manager);
54080:     }
54080:   }
54080: 
54080:   mRenderFlags = aState.mRenderFlags;
54080:   if (UsingDisplayPort()) {
54080:     mDisplayPort = aState.mDisplayPort;
54080:   } else {
54080:     mDisplayPort = nsRect();
54080:   }
54081:   mXResolution = aState.mXResolution;
54081:   mYResolution = aState.mYResolution;
54080: 
54080:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
54080:   if (rootFrame) {
54080:     rootFrame->InvalidateFrameSubtree();
54080:   }
54080: }
54080: 
52492: void PresShell::SynthesizeMouseMove(PRBool aFromScroll)
52492: {
52492:   if (mViewManager && !mPaintingSuppressed && mIsActive) {
52492:     mViewManager->SynthesizeMouseMove(aFromScroll);
52492:   }
52492: }
52492: 
42593: static void DrawThebesLayer(ThebesLayer* aLayer,
42593:                             gfxContext* aContext,
42593:                             const nsIntRegion& aRegionToDraw,
47108:                             const nsIntRegion& aRegionToInvalidate,
42593:                             void* aCallbackData)
42593: {
42593:   PaintParams* params = static_cast<PaintParams*>(aCallbackData);
42593:   nsIFrame* frame = params->mFrame;
42593:   if (frame) {
46326:     // We're drawing into a child window.
42593:     nsIDeviceContext* devCtx = frame->PresContext()->DeviceContext();
42593:     nsCOMPtr<nsIRenderingContext> rc;
42593:     nsresult rv = devCtx->CreateRenderingContextInstance(*getter_AddRefs(rc));
42593:     if (NS_SUCCEEDED(rv)) {
42593:       rc->Init(devCtx, aContext);
42593:       nsIRenderingContext::AutoPushTranslation
47899:         push(rc, params->mOffsetToWidget.x, params->mOffsetToWidget.y);
47735:       nsLayoutUtils::PaintFrame(rc, frame, *params->mDirtyRegion,
46326:                                 params->mBackgroundColor,
46326:                                 nsLayoutUtils::PAINT_WIDGET_LAYERS);
42593:     }
42593:   } else {
42593:     aContext->NewPath();
42593:     aContext->SetColor(gfxRGBA(params->mBackgroundColor));
42593:     nsIntRect dirtyRect = aRegionToDraw.GetBounds();
42593:     aContext->Rectangle(
42593:       gfxRect(dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height));
42593:     aContext->Fill();
42593:   }
42593: }
42593: 
27834: NS_IMETHODIMP
38805: PresShell::Paint(nsIView*           aDisplayRoot,
38805:                  nsIView*           aViewToPaint,
38805:                  nsIWidget*         aWidgetToPaint,
38805:                  const nsRegion&    aDirtyRegion,
47899:                  const nsIntRegion& aIntDirtyRegion,
47756:                  PRBool             aPaintDefaultBackground,
47756:                  PRBool             aWillSendDidPaint)
38805: {
42480: #ifdef NS_FUNCTION_TIMER
42480:   NS_TIME_FUNCTION_DECLARE_DOCURL;
42480:   const nsRect& bounds__ = aDirtyRegion.GetBounds();
42480:   NS_TIME_FUNCTION_MIN_FMT(1.0, "%s (line %d) (document: %s, dirty rect: (<%f, %f>, <%f, %f>)",
42480:                            MOZ_FUNCTION_NAME, __LINE__, docURL__.get(),
42480:                            NSCoordToFloat(bounds__.x),
42480:                            NSCoordToFloat(bounds__.y),
42480:                            NSCoordToFloat(bounds__.XMost()),
42480:                            NSCoordToFloat(bounds__.YMost()));
42480: #endif
42480: 
59662:   AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Paint);
27834: 
27834:   NS_ASSERTION(!mIsDestroying, "painting a destroyed PresShell");
38805:   NS_ASSERTION(aDisplayRoot, "null view");
38805:   NS_ASSERTION(aViewToPaint, "null view");
38805:   NS_ASSERTION(aWidgetToPaint, "Can't paint without a widget");
38805: 
38805:   nsIFrame* frame = aPaintDefaultBackground
38805:       ? nsnull : static_cast<nsIFrame*>(aDisplayRoot->GetClientData());
38805: 
59684:   LayerManager* layerManager = aWidgetToPaint->GetLayerManager();
59684:   NS_ASSERTION(layerManager, "Must be in paint event");
59684: 
59684:   if (frame) {
59684:     if (!(frame->GetStateBits() & NS_FRAME_UPDATE_LAYER_TREE)) {
59684:       if (layerManager->DoEmptyTransaction())
59684:         return NS_OK;
59684:     }
59684:     frame->RemoveStateBits(NS_FRAME_UPDATE_LAYER_TREE);
59684:   }
59684: 
59684:   nscolor bgcolor = ComputeBackstopColor(aDisplayRoot);
59684: 
38805:   if (frame && aViewToPaint == aDisplayRoot) {
47735:     // Defer invalidates that are triggered during painting, and discard
47735:     // invalidates of areas that are already being repainted.
47735:     // The layer system can trigger invalidates during painting
47735:     // (see FrameLayerBuilder).
47735:     frame->BeginDeferringInvalidatesForDisplayRoot(aDirtyRegion);
47735: 
38805:     // We can paint directly into the widget using its layer manager.
38805:     // When we get rid of child widgets, this will be the only path we
38805:     // need. (aPaintDefaultBackground will never be needed since the
38805:     // chrome can always paint a default background.)
38805:     nsLayoutUtils::PaintFrame(nsnull, frame, aDirtyRegion, bgcolor,
38805:                               nsLayoutUtils::PAINT_WIDGET_LAYERS);
47735: 
47735:     frame->EndDeferringInvalidatesForDisplayRoot();
38805:     return NS_OK;
38805:   }
38805: 
47735:   if (frame) {
47735:     // Defer invalidates that are triggered during painting, and discard
47735:     // invalidates of areas that are already being repainted.
47899:     frame->BeginDeferringInvalidatesForDisplayRoot(aDirtyRegion);
47735:   }
47735: 
38805:   layerManager->BeginTransaction();
38805:   nsRefPtr<ThebesLayer> root = layerManager->CreateThebesLayer();
38805:   if (root) {
47899:     root->SetVisibleRegion(aIntDirtyRegion);
38805:     layerManager->SetRoot(root);
38805:   }
42593:   if (!frame) {
42593:     bgcolor = NS_ComposeColors(bgcolor, mCanvasBackgroundColor);
42593:   }
42593:   PaintParams params =
42593:     { frame,
47899:       aDisplayRoot->GetOffsetToWidget(aWidgetToPaint),
47899:       &aDirtyRegion,
42593:       bgcolor };
42593:   layerManager->EndTransaction(DrawThebesLayer, &params);
38805: 
47735:   if (frame) {
47735:     frame->EndDeferringInvalidatesForDisplayRoot();
47735:   }
    1:   return NS_OK;
    1: }
    1: 
32435: // static
32435: void
32435: nsIPresShell::SetCapturingContent(nsIContent* aContent, PRUint8 aFlags)
32435: {
32435:   NS_IF_RELEASE(gCaptureInfo.mContent);
32435: 
32435:   // only set capturing content if allowed or the CAPTURE_IGNOREALLOWED flag
32435:   // is used
32435:   if ((aFlags & CAPTURE_IGNOREALLOWED) || gCaptureInfo.mAllowed) {
32435:     if (aContent) {
32435:       NS_ADDREF(gCaptureInfo.mContent = aContent);
32435:     }
32435:     gCaptureInfo.mRetargetToElement = (aFlags & CAPTURE_RETARGETTOELEMENT) != 0;
37876:     gCaptureInfo.mPreventDrag = (aFlags & CAPTURE_PREVENTDRAG) != 0;
32435:   }
32435: }
32435: 
    1: nsIFrame*
    1: PresShell::GetCurrentEventFrame()
    1: {
22472:   if (NS_UNLIKELY(mIsDestroying)) {
22472:     return nsnull;
22472:   }
22472:     
    1:   if (!mCurrentEventFrame && mCurrentEventContent) {
    1:     // Make sure the content still has a document reference. If not,
    1:     // then we assume it is no longer in the content tree and the
    1:     // frame shouldn't get an event, nor should we even assume its
    1:     // safe to try and find the frame.
    1:     if (mCurrentEventContent->GetDocument()) {
36656:       mCurrentEventFrame = mCurrentEventContent->GetPrimaryFrame();
    1:     }
    1:   }
    1: 
    1:   return mCurrentEventFrame;
    1: }
    1: 
40047: nsIFrame*
40047: PresShell::GetEventTargetFrame()
40047: {
40047:   return GetCurrentEventFrame();
40047: }
40047: 
40047: already_AddRefed<nsIContent>
40047: PresShell::GetEventTargetContent(nsEvent* aEvent)
40047: {
40047:   nsIContent* content = nsnull;
40047: 
    1:   if (mCurrentEventContent) {
40047:     content = mCurrentEventContent;
40047:     NS_IF_ADDREF(content);
    1:   } else {
    1:     nsIFrame* currentEventFrame = GetCurrentEventFrame();
    1:     if (currentEventFrame) {
40047:       currentEventFrame->GetContentForEvent(mPresContext, aEvent, &content);
    1:     } else {
40047:       content = nsnull;
40047:     }
40047:   }
40047:   return content;
    1: }
    1: 
    1: void
    1: PresShell::PushCurrentEventInfo(nsIFrame* aFrame, nsIContent* aContent)
    1: {
    1:   if (mCurrentEventFrame || mCurrentEventContent) {
24551:     mCurrentEventFrameStack.InsertElementAt(0, mCurrentEventFrame);
    1:     mCurrentEventContentStack.InsertObjectAt(mCurrentEventContent, 0);
    1:   }
    1:   mCurrentEventFrame = aFrame;
    1:   mCurrentEventContent = aContent;
    1: }
    1: 
    1: void
    1: PresShell::PopCurrentEventInfo()
    1: {
    1:   mCurrentEventFrame = nsnull;
    1:   mCurrentEventContent = nsnull;
    1: 
24551:   if (0 != mCurrentEventFrameStack.Length()) {
24551:     mCurrentEventFrame = mCurrentEventFrameStack.ElementAt(0);
    1:     mCurrentEventFrameStack.RemoveElementAt(0);
    1:     mCurrentEventContent = mCurrentEventContentStack.ObjectAt(0);
    1:     mCurrentEventContentStack.RemoveObjectAt(0);
    1:   }
    1: }
    1: 
    1: PRBool PresShell::InZombieDocument(nsIContent *aContent)
    1: {
    1:   // If a content node points to a null document, or the document is not
    1:   // attached to a window, then it is possibly in a zombie document,
    1:   // about to be replaced by a newly loading document.
    1:   // Such documents cannot handle DOM events.
    1:   // It might actually be in a node not attached to any document,
    1:   // in which case there is not parent presshell to retarget it to.
    1:   nsIDocument *doc = aContent->GetDocument();
    1:   return !doc || !doc->GetWindow();
    1: }
    1: 
47198: already_AddRefed<nsPIDOMWindow>
47198: PresShell::GetRootWindow()
47198: {
47198:   nsCOMPtr<nsPIDOMWindow> window =
47198:     do_QueryInterface(mDocument->GetWindow());
47198:   if (window) {
47198:     nsCOMPtr<nsPIDOMWindow> rootWindow = window->GetPrivateRoot();
47198:     NS_ASSERTION(rootWindow, "nsPIDOMWindow::GetPrivateRoot() returns NULL");
47198:     return rootWindow.forget();
47198:   }
47198: 
47198:   // If we don't have DOM window, we're zombie, we should find the root window
47198:   // with our parent shell.
47198:   nsCOMPtr<nsIPresShell> parent = GetParentPresShell();
47198:   NS_ENSURE_TRUE(parent, nsnull);
47198:   return parent->GetRootWindow();
47198: }
47198: 
47198: already_AddRefed<nsIPresShell>
47198: PresShell::GetParentPresShell()
47198: {
47198:   NS_ENSURE_TRUE(mPresContext, nsnull);
47198:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
47198:   if (!container) {
47198:     container = do_QueryReferent(mForwardingContainer);
47198:   }
47198: 
47198:   // Now, find the parent pres shell and send the event there
47198:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(container);
47198:   // Might have gone away, or never been around to start with
47198:   NS_ENSURE_TRUE(treeItem, nsnull);
47198: 
47198:   nsCOMPtr<nsIDocShellTreeItem> parentTreeItem;
47198:   treeItem->GetParent(getter_AddRefs(parentTreeItem));
47198:   nsCOMPtr<nsIDocShell> parentDocShell = do_QueryInterface(parentTreeItem);
47198:   NS_ENSURE_TRUE(parentDocShell && treeItem != parentTreeItem, nsnull);
47198: 
47198:   nsIPresShell* parentPresShell = nsnull;
47198:   parentDocShell->GetPresShell(&parentPresShell);
47198:   return parentPresShell;
47198: }
47198: 
47198: nsresult
47198: PresShell::RetargetEventToParent(nsGUIEvent*     aEvent,
    1:                                  nsEventStatus*  aEventStatus)
    1: {
    1:   // Send this events straight up to the parent pres shell.
    1:   // We do this for keystroke events in zombie documents or if either a frame
    1:   // or a root content is not present.
    1:   // That way at least the UI key bindings can work.
    1: 
    1:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
47198:   nsCOMPtr<nsIPresShell> parentPresShell = GetParentPresShell();
47198:   NS_ENSURE_TRUE(parentPresShell, NS_ERROR_FAILURE);
    1:   nsCOMPtr<nsIViewObserver> parentViewObserver = 
    1:     do_QueryInterface(parentPresShell);
    1:   if (!parentViewObserver) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Fake the event as though it'ss from the parent pres shell's root view.
    1:   nsIView *parentRootView;
    1:   parentPresShell->GetViewManager()->GetRootView(parentRootView);
    1:   
58209:   return parentViewObserver->HandleEvent(parentRootView, aEvent, PR_TRUE, aEventStatus);
    1: }
    1: 
40052: void
24947: PresShell::DisableNonTestMouseEvents(PRBool aDisable)
24947: {
24947:   sDisableNonTestMouseEvents = aDisable;
24947: }
24947: 
36337: already_AddRefed<nsPIDOMWindow>
36337: PresShell::GetFocusedDOMWindowInOurWindow()
36337: {
47198:   nsCOMPtr<nsPIDOMWindow> rootWindow = GetRootWindow();
36337:   NS_ENSURE_TRUE(rootWindow, nsnull);
36337:   nsPIDOMWindow* focusedWindow;
36337:   nsFocusManager::GetFocusedDescendant(rootWindow, PR_TRUE, &focusedWindow);
36337:   return focusedWindow;
36337: }
36337: 
24947: NS_IMETHODIMP
    1: PresShell::HandleEvent(nsIView         *aView,
    1:                        nsGUIEvent*     aEvent,
58209:                        PRBool          aDontRetargetEvents,
    1:                        nsEventStatus*  aEventStatus)
    1: {
    1:   NS_ASSERTION(aView, "null view");
    1: 
54519:   if (mIsDestroying ||
24947:       (sDisableNonTestMouseEvents && NS_IS_MOUSE_EVENT(aEvent) &&
33400:        !(aEvent->flags & NS_EVENT_FLAG_SYNTHETIC_TEST_EVENT))) {
    1:     return NS_OK;
    1:   }
    1: 
    1: #ifdef ACCESSIBILITY
    1:   if (aEvent->eventStructType == NS_ACCESSIBLE_EVENT) {
54519:     NS_TIME_FUNCTION_MIN(1.0);
54519: 
13287:     // Accessibility events come through OS requests and not from scripts,
13287:     // so it is safe to handle here
    1:     return HandleEventInternal(aEvent, aView, aEventStatus);
    1:   }
    1: #endif
14479: 
54519:   if (!nsContentUtils::IsSafeToRunScript())
54519:     return NS_OK;
54519: 
54519:   NS_TIME_FUNCTION_MIN(1.0);
54519: 
33240:   nsIContent* capturingContent =
33240:     NS_IS_MOUSE_EVENT(aEvent) ? GetCapturingContent() : nsnull;
33240: 
32435:   nsCOMPtr<nsIDocument> retargetEventDoc;
58209:   if (!aDontRetargetEvents) {
43624:     // key and IME related events should not cross top level window boundary.
43624:     // Basically, such input events should be fired only on focused widget.
43624:     // However, some IMEs might need to clean up composition after focused
43624:     // window is deactivated.  And also some tests on MozMill want to test key
43624:     // handling on deactivated window because MozMill window can be activated
43624:     // during tests.  So, there is no merit the events should be redirected to
43624:     // active window.  So, the events should be handled on the last focused
43624:     // content in the last focused DOM window in same top level window.
43624:     // Note, if no DOM window has been focused yet, we can discard the events.
32435:     if (NS_IsEventTargetedAtFocusedWindow(aEvent)) {
43624:       nsCOMPtr<nsPIDOMWindow> window = GetFocusedDOMWindowInOurWindow();
43624:       // No DOM window in same top level window has not been focused yet,
43624:       // discard the events.
43624:       if (!window) {
29018:         return NS_OK;
43624:       }
43624: 
43624:       retargetEventDoc = do_QueryInterface(window->GetExtantDocument());
32435:       if (!retargetEventDoc)
29018:         return NS_OK;
33240:     } else if (capturingContent) {
32435:       // if the mouse is being captured then retarget the mouse event at the
32435:       // document that is being captured.
33240:       retargetEventDoc = capturingContent->GetCurrentDoc();
32435:     }
32435: 
32435:     if (retargetEventDoc) {
46225:       nsIPresShell* presShell = retargetEventDoc->GetShell();
29018:       if (!presShell)
29018:         return NS_OK;
29018: 
29018:       if (presShell != this) {
29018:         nsCOMPtr<nsIViewObserver> viewObserver = do_QueryInterface(presShell);
29018:         if (!viewObserver)
29018:           return NS_ERROR_FAILURE;
29018: 
29018:         nsIView *view;
29018:         presShell->GetViewManager()->GetRootView(view);
58209:         nsresult rv = viewObserver->HandleEvent(view, aEvent, PR_TRUE, aEventStatus);
29018:         return rv;
29018:       }
29018:     }
32435:   }
29018: 
    1:   // Check for a theme change up front, since the frame type is irrelevant
    1:   if (aEvent->message == NS_THEMECHANGED && mPresContext) {
    1:     mPresContext->ThemeChanged();
    1:     return NS_OK;
    1:   }
    1: 
41071:   if (aEvent->message == NS_UISTATECHANGED && mDocument) {
41071:     nsPIDOMWindow* win = mDocument->GetWindow();
41071:     if (win) {
41071:       nsUIStateChangeEvent* event = (nsUIStateChangeEvent*)aEvent;
41071:       win->SetKeyboardIndicators(event->showAccelerators, event->showFocusRings);
41071:     }
41071:     return NS_OK;
41071:   }
41071: 
    1:   // Check for a system color change up front, since the frame type is
    1:   // irrelevant
    1:   if ((aEvent->message == NS_SYSCOLORCHANGED) && mPresContext) {
    1:     nsIViewManager* vm = GetViewManager();
    1:     if (vm) {
    1:       // Only dispatch system color change when the message originates from
    1:       // from the root views widget. This is necessary to prevent us from 
    1:       // dispatching the SysColorChanged notification for each child window 
    1:       // which may be redundant.
    1:       nsIView *view;
    1:       vm->GetRootView(view);
    1:       if (view == aView) {
    1:         *aEventStatus = nsEventStatus_eConsumeDoDefault;
    1:         mPresContext->SysColorChanged();
    1:         return NS_OK;
    1:       }
    1:     }
    1:     return NS_OK;
    1:   }
    1: 
38961:   if (aEvent->eventStructType == NS_KEY_EVENT &&
38961:       mDocument && mDocument->EventHandlingSuppressed()) {
28498:     if (aEvent->message == NS_KEY_DOWN) {
28498:       mNoDelayedKeyEvents = PR_TRUE;
28498:     } else if (!mNoDelayedKeyEvents) {
38961:       nsDelayedEvent* event =
38961:         new nsDelayedKeyEvent(static_cast<nsKeyEvent*>(aEvent));
28498:       if (event && !mDelayedEvents.AppendElement(event)) {
28498:         delete event;
28498:       }
38961:     }
25722:     return NS_OK;
25722:   }
25722: 
 3233:   nsIFrame* frame = static_cast<nsIFrame*>(aView->GetClientData());
31218:   PRBool dispatchUsingCoordinates = NS_IsEventUsingCoordinates(aEvent);
    1: 
    1:   // if this event has no frame, we need to retarget it at a parent
    1:   // view that has a frame.
    1:   if (!frame &&
    1:       (dispatchUsingCoordinates || NS_IS_KEY_EVENT(aEvent) ||
41061:        NS_IS_IME_RELATED_EVENT(aEvent) || NS_IS_NON_RETARGETED_PLUGIN_EVENT(aEvent) ||
57526:        aEvent->message == NS_PLUGIN_ACTIVATE || aEvent->message == NS_PLUGIN_FOCUS)) {
    1:     nsIView* targetView = aView;
    1:     while (targetView && !targetView->GetClientData()) {
    1:       targetView = targetView->GetParent();
    1:     }
    1:     
    1:     if (targetView) {
    1:       aView = targetView;
 3233:       frame = static_cast<nsIFrame*>(aView->GetClientData());
    1:     }
    1:   }
    1: 
    1:   if (dispatchUsingCoordinates) {
27619:     NS_WARN_IF_FALSE(frame, "Nothing to handle this event!");
    1:     if (!frame)
    1:       return NS_OK;
    1: 
  238:     nsPresContext* framePresContext = frame->PresContext();
37502:     nsPresContext* rootPresContext = framePresContext->GetRootPresContext();
37502:     NS_ASSERTION(rootPresContext == mPresContext->GetRootPresContext(),
    1:                  "How did we end up outside the connected prescontext/viewmanager hierarchy?"); 
    1:     // If we aren't starting our event dispatch from the root frame of the root prescontext,
    1:     // then someone must be capturing the mouse. In that case we don't want to search the popup
    1:     // list.
    1:     if (framePresContext == rootPresContext &&
    1:         frame == FrameManager()->GetRootFrame()) {
39629:       nsIFrame* popupFrame =
48255:         nsLayoutUtils::GetPopupFrameForEventCoordinates(rootPresContext, aEvent);
39629:       // If the popupFrame is an ancestor of the 'frame', the frame should
39629:       // handle the event, otherwise, the popup should handle it.
39629:       if (popupFrame &&
37138:           !nsContentUtils::ContentIsCrossDocDescendantOf(
39629:              framePresContext->GetPresShell()->GetDocument(),
39629:              popupFrame->GetContent())) {
39629:         frame = popupFrame;
39629:       }
 3516:     }
    1: 
33240:     PRBool captureRetarget = PR_FALSE;
33240:     if (capturingContent) {
38335:       // If a capture is active, determine if the docshell is visible. If not,
38335:       // clear the capture and target the mouse event normally instead. This
38335:       // would occur if the mouse button is held down while a tab change occurs.
38335:       // If the docshell is visible, look for a scrolling container.
38335:       PRBool vis;
38335:       nsCOMPtr<nsISupports> supports = mPresContext->GetContainer();
38335:       nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(supports));
38335:       if (baseWin && NS_SUCCEEDED(baseWin->GetVisibility(&vis)) && vis) {
33240:         captureRetarget = gCaptureInfo.mRetargetToElement;
33710:         if (!captureRetarget) {
36656:           // A check was already done above to ensure that capturingContent is
38335:           // in this presshell.
36656:           NS_ASSERTION(capturingContent->GetCurrentDoc() == GetDocument(),
36656:                        "Unexpected document");
36656:           nsIFrame* captureFrame = capturingContent->GetPrimaryFrame();
33710:           if (captureFrame) {
33710:             if (capturingContent->Tag() == nsGkAtoms::select &&
33329:                 capturingContent->IsHTML()) {
33710:               // a dropdown <select> has a child in its selectPopupList and we should
33710:               // capture on that instead.
33710:               nsIFrame* childFrame = captureFrame->GetChildList(nsGkAtoms::selectPopupList).FirstChild();
33710:               if (childFrame) {
33710:                 captureFrame = childFrame;
33710:               }
33710:             }
33710: 
33710:             // scrollable frames should use the scrolling container as
33710:             // the root instead of the document
33710:             nsIScrollableFrame* scrollFrame = do_QueryFrame(captureFrame);
33710:             if (scrollFrame) {
33710:               frame = scrollFrame->GetScrolledFrame();
33240:             }
33240:           }
33240:         }
33240:       }
38335:       else {
38335:         ClearMouseCapture(nsnull);
38335:         capturingContent = nsnull;
38335:       }
38335:     }
33240: 
33240:     // Get the frame at the event point. However, don't do this if we're
33240:     // capturing and retargeting the event because the captured frame will
33240:     // be used instead below.
33240:     if (!captureRetarget) {
    1:       nsPoint eventPoint
    1:           = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, frame);
11016:       {
22095:         PRBool ignoreRootScrollFrame = PR_FALSE;
20863:         if (aEvent->eventStructType == NS_MOUSE_EVENT) {
22095:           ignoreRootScrollFrame = static_cast<nsMouseEvent*>(aEvent)->ignoreRootScrollFrame;
20863:         }
38961:         nsIFrame* target = nsLayoutUtils::GetFrameForPoint(frame, eventPoint,
22095:                                                            PR_FALSE, ignoreRootScrollFrame);
38961:         if (target) {
38961:           frame = target;
38961:         }
11016:       }
32435:     }
11016: 
33240:     // if a node is capturing the mouse, check if the event needs to be
33240:     // retargeted at the capturing content instead. This will be the case when
33240:     // capture retargeting is being used, no frame was found or the frame's
33240:     // content is not a descendant of the capturing content.
33240:     if (capturingContent &&
38961:         (gCaptureInfo.mRetargetToElement || !frame->GetContent() ||
38961:          !nsContentUtils::ContentIsCrossDocDescendantOf(frame->GetContent(),
33240:                                                         capturingContent))) {
33240:       // A check was already done above to ensure that capturingContent is
38335:       // in this presshell.
36656:       NS_ASSERTION(capturingContent->GetCurrentDoc() == GetDocument(),
36656:                    "Unexpected document");
36656:       nsIFrame* capturingFrame = capturingContent->GetPrimaryFrame();
33240:       if (capturingFrame) {
38961:         frame = capturingFrame;
38961:         aView = frame->GetClosestView();
38961:       }
38961:     }
38961: 
38961:     // Suppress mouse event if it's being targeted at an element inside
38961:     // a document which needs events suppressed
38961:     if (aEvent->eventStructType == NS_MOUSE_EVENT &&
38961:         frame->PresContext()->Document()->EventHandlingSuppressed()) {
38961:       if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
38961:         mNoDelayedMouseEvents = PR_TRUE;
38961:       } else if (!mNoDelayedMouseEvents && aEvent->message == NS_MOUSE_BUTTON_UP) {
38961:         nsDelayedEvent* event =
38961:           new nsDelayedMouseEvent(static_cast<nsMouseEvent*>(aEvent));
38961:         if (!mDelayedEvents.AppendElement(event)) {
38961:           delete event;
38961:         }
38961:       }
38961: 
38961:       return NS_OK;
38961:     }
38961: 
    1:     PresShell* shell =
38961:         static_cast<PresShell*>(frame->PresContext()->PresShell());
56077: 
56077:     // Check if we have an active EventStateManager which isn't the
56077:     // EventStateManager of the current PresContext.
56077:     // If that is the case, and mouse is over some ancestor document,
56077:     // forward event handling to the active document.
56077:     // This way content can get mouse events even when
56077:     // mouse is over the chrome or outside the window.
56077:     //
56077:     // Note, currently for backwards compatibility we don't forward mouse events
56077:     // to the active document when mouse is over some subdocument.
56077:     nsIEventStateManager* activeESM =
56077:       nsEventStateManager::GetActiveEventStateManager();
56077:     if (activeESM && NS_IS_MOUSE_EVENT(aEvent) &&
56077:         activeESM != shell->GetPresContext()->EventStateManager() &&
56077:         static_cast<nsEventStateManager*>(activeESM)->GetPresContext()) {
56077:       nsIPresShell* activeShell =
56077:         static_cast<nsEventStateManager*>(activeESM)->GetPresContext()->GetPresShell();
56077:       if (activeShell &&
56077:           nsContentUtils::ContentIsCrossDocDescendantOf(activeShell->GetDocument(),
56077:                                                         shell->GetDocument())) {
56077:         shell = static_cast<PresShell*>(activeShell);
56077:         nsIView* activeShellRootView;
56077:         shell->GetViewManager()->GetRootView(activeShellRootView);
56077:         frame = static_cast<nsIFrame*>(activeShellRootView->GetClientData());
56077:       }
56077:     }
56077: 
    1:     if (shell != this) {
    1:       // Handle the event in the correct shell.
    1:       // Prevent deletion until we're done with event handling (bug 336582).
 2706:       nsCOMPtr<nsIPresShell> kungFuDeathGrip(shell);
    1:       nsIView* subshellRootView;
    1:       shell->GetViewManager()->GetRootView(subshellRootView);
    1:       // We pass the subshell's root view as the view to start from. This is
    1:       // the only correct alternative; if the event was captured then it
    1:       // must have been captured by us or some ancestor shell and we
    1:       // now ask the subshell to dispatch it normally.
38961:       return shell->HandlePositionedEvent(subshellRootView, frame,
    1:                                           aEvent, aEventStatus);
    1:     }
38961: 
38961:     return HandlePositionedEvent(aView, frame, aEvent, aEventStatus);
    1:   }
    1:   
    1:   nsresult rv = NS_OK;
    1:   
    1:   if (frame) {
    1:     PushCurrentEventInfo(nsnull, nsnull);
    1: 
43624:     // key and IME related events go to the focused frame in this DOM window.
43624:     if (NS_IsEventTargetedAtFocusedContent(aEvent)) {
43624:       NS_ASSERTION(mDocument, "mDocument is null");
43624:       nsCOMPtr<nsPIDOMWindow> window =
43624:         do_QueryInterface(mDocument->GetWindow());
29018:       nsCOMPtr<nsPIDOMWindow> focusedWindow;
29018:       mCurrentEventContent =
43624:         nsFocusManager::GetFocusedDescendant(window, PR_FALSE,
43624:                                              getter_AddRefs(focusedWindow));
29018: 
29018:       // otherwise, if there is no focused content or the focused content has
29018:       // no frame, just use the root content. This ensures that key events
29018:       // still get sent to the window properly if nothing is focused or if a
29018:       // frame goes away while it is focused.
29018:       if (!mCurrentEventContent || !GetCurrentEventFrame())
41634:         mCurrentEventContent = mDocument->GetRootElement();
50720: 
50720:       if (aEvent->message == NS_KEY_DOWN) {
50720:         NS_IF_RELEASE(gKeyDownTarget);
50720:         NS_IF_ADDREF(gKeyDownTarget = mCurrentEventContent);
50720:       }
50720:       else if ((aEvent->message == NS_KEY_PRESS || aEvent->message == NS_KEY_UP) &&
50720:                gKeyDownTarget) {
50720:         // If a different element is now focused for the keypress/keyup event
50720:         // than what was focused during the keydown event, check if the new
50720:         // focused element is not in a chrome document any more, and if so,
50720:         // retarget the event back at the keydown target. This prevents a
50720:         // content area from grabbing the focus from chrome in-between key
50720:         // events.
50720:         if (mCurrentEventContent &&
50720:             nsContentUtils::IsChromeDoc(gKeyDownTarget->GetCurrentDoc()) &&
50720:             !nsContentUtils::IsChromeDoc(mCurrentEventContent->GetCurrentDoc())) {
50720:           mCurrentEventContent = gKeyDownTarget;
50720:         }
50720: 
50720:         if (aEvent->message == NS_KEY_UP) {
50720:           NS_RELEASE(gKeyDownTarget);
50720:         }
50720:       }
50720: 
29018:       mCurrentEventFrame = nsnull;
29018:         
37863:       if (!mCurrentEventContent || !GetCurrentEventFrame() ||
37863:           InZombieDocument(mCurrentEventContent)) {
    1:         rv = RetargetEventToParent(aEvent, aEventStatus);
    1:         PopCurrentEventInfo();
    1:         return rv;
    1:       }
    1:     } else {
    1:       mCurrentEventFrame = frame;
    1:     }
    1:     if (GetCurrentEventFrame()) {
    1:       rv = HandleEventInternal(aEvent, aView, aEventStatus);
    1:     }
    1:   
    1: #ifdef NS_DEBUG
    1:     ShowEventTargetDebug();
    1: #endif
    1:     PopCurrentEventInfo();
    1:   } else {
33344:     // Activation events need to be dispatched even if no frame was found, since
29018:     // we don't want the focus to be out of sync.
    1: 
    1:     if (!NS_EVENT_NEEDS_FRAME(aEvent)) {
    1:       mCurrentEventFrame = nsnull;
    1:       return HandleEventInternal(aEvent, aView, aEventStatus);
    1:     }
    1:     else if (NS_IS_KEY_EVENT(aEvent)) {
    1:       // Keypress events in new blank tabs should not be completely thrown away.
    1:       // Retarget them -- the parent chrome shell might make use of them.
    1:       return RetargetEventToParent(aEvent, aEventStatus);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: void
    1: PresShell::ShowEventTargetDebug()
    1: {
31709:   if (nsFrame::GetShowEventTargetFrameBorder() &&
    1:       GetCurrentEventFrame()) {
    1:     if (mDrawEventTargetFrame) {
    1:       mDrawEventTargetFrame->Invalidate(
    1:           nsRect(nsPoint(0, 0), mDrawEventTargetFrame->GetSize()));
    1:     }
    1: 
    1:     mDrawEventTargetFrame = mCurrentEventFrame;
    1:     mDrawEventTargetFrame->Invalidate(
    1:         nsRect(nsPoint(0, 0), mDrawEventTargetFrame->GetSize()));
    1:   }
    1: }
    1: #endif
    1: 
    1: nsresult
    1: PresShell::HandlePositionedEvent(nsIView*       aView,
    1:                                  nsIFrame*      aTargetFrame,
    1:                                  nsGUIEvent*    aEvent,
    1:                                  nsEventStatus* aEventStatus)
    1: {
    1:   nsresult rv = NS_OK;
    1:   
    1:   PushCurrentEventInfo(nsnull, nsnull);
    1:   
    1:   mCurrentEventFrame = aTargetFrame;
    1: 
    1:   if (mCurrentEventFrame) {
    1:     nsCOMPtr<nsIContent> targetElement;
    1:     mCurrentEventFrame->GetContentForEvent(mPresContext, aEvent,
    1:                                            getter_AddRefs(targetElement));
    1: 
    1:     // If there is no content for this frame, target it anyway.  Some
    1:     // frames can be targeted but do not have content, particularly
    1:     // windows with scrolling off.
    1:     if (targetElement) {
    1:       // Bug 103055, bug 185889: mouse events apply to *elements*, not all
    1:       // nodes.  Thus we get the nearest element parent here.
    1:       // XXX we leave the frame the same even if we find an element
    1:       // parent, so that the text frame will receive the event (selection
    1:       // and friends are the ones who care about that anyway)
    1:       //
    1:       // We use weak pointers because during this tight loop, the node
    1:       // will *not* go away.  And this happens on every mousemove.
41640:       while (targetElement && !targetElement->IsElement()) {
    1:         targetElement = targetElement->GetParent();
    1:       }
    1: 
    1:       // If we found an element, target it.  Otherwise, target *nothing*.
    1:       if (!targetElement) {
    1:         mCurrentEventContent = nsnull;
    1:         mCurrentEventFrame = nsnull;
    1:       } else if (targetElement != mCurrentEventContent) {
    1:         mCurrentEventContent = targetElement;
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (GetCurrentEventFrame()) {
    1:     rv = HandleEventInternal(aEvent, aView, aEventStatus);
    1:   }
    1: 
    1: #ifdef NS_DEBUG
    1:   ShowEventTargetDebug();
    1: #endif
    1:   PopCurrentEventInfo();
    1:   return rv;
    1: }
    1: 
40055: nsresult
    1: PresShell::HandleEventWithTarget(nsEvent* aEvent, nsIFrame* aFrame,
    1:                                  nsIContent* aContent, nsEventStatus* aStatus)
    1: {
    1:   PushCurrentEventInfo(aFrame, aContent);
40055:   nsresult rv = HandleEventInternal(aEvent, nsnull, aStatus);
    1:   PopCurrentEventInfo();
40055:   return rv;
    1: }
    1: 
39761: static inline PRBool
39761: IsSynthesizedMouseEvent(nsEvent* aEvent)
    1: {
    1:   return aEvent->eventStructType == NS_MOUSE_EVENT &&
 3233:          static_cast<nsMouseEvent*>(aEvent)->reason != nsMouseEvent::eReal;
    1: }
    1: 
31431: static PRBool CanHandleContextMenuEvent(nsMouseEvent* aMouseEvent,
31431:                                         nsIFrame* aFrame)
31431: {
31431: #if defined(XP_MACOSX) && defined(MOZ_XUL)
31431:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
31431:   if (pm) {
31431:     nsIFrame* popupFrame = pm->GetTopPopup(ePopupTypeMenu);
31431:     if (popupFrame) {
31431:       // context menus should not be opened while another menu is open on Mac,
31431:       // so return false so that the event is not fired.
31431:       if (aMouseEvent->context == nsMouseEvent::eContextMenuKey) {
31431:         return PR_FALSE;
31431:       } else if (aMouseEvent->widget) {
31431:          nsWindowType windowType;
31431:          aMouseEvent->widget->GetWindowType(windowType);
31431:          if (windowType == eWindowType_popup) {
31431:            for (nsIFrame* current = aFrame; current;
31431:                 current = nsLayoutUtils::GetCrossDocParentFrame(current)) {
31431:              if (current->GetType() == nsGkAtoms::menuPopupFrame) {
31431:                return PR_FALSE;
31431:              }
31431:            }
31431:          }
31431:       }
31431:     }
31431:   }
31431: #endif
31431:   return PR_TRUE;
31431: }
31431: 
    1: nsresult
    1: PresShell::HandleEventInternal(nsEvent* aEvent, nsIView *aView,
    1:                                nsEventStatus* aStatus)
    1: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
    1: #ifdef ACCESSIBILITY
    1:   if (aEvent->eventStructType == NS_ACCESSIBLE_EVENT)
    1:   {
42313:     nsAccessibleEvent *accEvent = static_cast<nsAccessibleEvent*>(aEvent);
42313:     accEvent->mAccessible = nsnull;
42313: 
    1:     nsCOMPtr<nsIAccessibilityService> accService =
    1:       do_GetService("@mozilla.org/accessibilityService;1");
    1:     if (accService) {
    1:       nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
    1:       if (!container) {
    1:         // This presshell is not active. This often happens when a
    1:         // preshell is being held onto for fastback.
    1:         return NS_OK;
    1:       }
42313: 
54519:       // Accessible creation might be not safe so we make sure it's not created
54519:       // at unsafe times.
54519:       accEvent->mAccessible =
54519:         accService->GetRootDocumentAccessible(this, nsContentUtils::IsSafeToRunScript());
42313: 
 1090:       // Ensure this is set in case a11y was activated before any
 1090:       // nsPresShells existed to observe "a11y-init-or-shutdown" topic
 1090:       gIsAccessibilityActive = PR_TRUE;
    1:       return NS_OK;
    1:     }
    1:   }
    1: #endif
    1: 
    1:   nsCOMPtr<nsIEventStateManager> manager = mPresContext->EventStateManager();
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (!NS_EVENT_NEEDS_FRAME(aEvent) || GetCurrentEventFrame()) {
    1:     PRBool isHandlingUserInput = PR_FALSE;
    1: 
    1:     if (NS_IS_TRUSTED_EVENT(aEvent)) {
    1:       switch (aEvent->message) {
    1:       case NS_MOUSE_BUTTON_DOWN:
    1:       case NS_MOUSE_BUTTON_UP:
    1:       case NS_KEY_PRESS:
    1:       case NS_KEY_DOWN:
    1:       case NS_KEY_UP:
    1:         isHandlingUserInput = PR_TRUE;
34272:         break;
34272:       case NS_DRAGDROP_DROP:
34272:         nsCOMPtr<nsIDragSession> session = nsContentUtils::GetDragSession();
34272:         if (session) {
34272:           PRBool onlyChromeDrop = PR_FALSE;
34272:           session->GetOnlyChromeDrop(&onlyChromeDrop);
34272:           if (onlyChromeDrop) {
34272:             aEvent->flags |= NS_EVENT_FLAG_ONLY_CHROME_DISPATCH;
34272:           }
34272:         }
34272:         break;
    1:       }
    1:     }
    1: 
31431:     if (aEvent->message == NS_CONTEXTMENU) {
31431:       nsMouseEvent* me = static_cast<nsMouseEvent*>(aEvent);
31431:       if (!CanHandleContextMenuEvent(me, GetCurrentEventFrame())) {
23881:         return NS_OK;
23881:       }
31431:       if (me->context == nsMouseEvent::eContextMenuKey &&
31431:           !AdjustContextMenuKeyEvent(me)) {
31431:         return NS_OK;
31431:       }
31431:     }                                
23881: 
32435:     nsAutoHandlingUserInputStatePusher userInpStatePusher(isHandlingUserInput,
56988:                                                           aEvent, mDocument);
    1: 
55892:     if (NS_IS_TRUSTED_EVENT(aEvent) && aEvent->message == NS_MOUSE_MOVE) {
55892:       nsIPresShell::AllowMouseCapture(
55892:         nsEventStateManager::GetActiveEventStateManager() == manager);
55892:     }
55892: 
    1:     nsAutoPopupStatePusher popupStatePusher(nsDOMEvent::GetEventPopupControlState(aEvent));
    1: 
    1:     // FIXME. If the event was reused, we need to clear the old target,
    1:     // bug 329430
    1:     aEvent->target = nsnull;
    1: 
 8292:     nsWeakView weakView(aView);
    1:     // 1. Give event to event manager for pre event state changes and
    1:     //    generation of synthetic events.
    1:     rv = manager->PreHandleEvent(mPresContext, aEvent, mCurrentEventFrame,
    1:                                  aStatus, aView);
    1: 
    1:     // 2. Give event to the DOM for third party and JS use.
22729:     if (GetCurrentEventFrame() && NS_SUCCEEDED(rv)) {
41239:       PRBool wasHandlingKeyBoardEvent =
41239:         nsContentUtils::IsHandlingKeyBoardEvent();
41239:       if (aEvent->eventStructType == NS_KEY_EVENT) {
41239:         nsContentUtils::SetIsHandlingKeyBoardEvent(PR_TRUE);
41239:       }
    1:       // We want synthesized mouse moves to cause mouseover and mouseout
    1:       // DOM events (PreHandleEvent above), but not mousemove DOM events.
39761:       // Synthesized button up events also do not cause DOM events
39761:       // because they do not have a reliable refPoint.
39761:       if (!IsSynthesizedMouseEvent(aEvent)) {
    1:         nsPresShellEventCB eventCB(this);
    1:         if (mCurrentEventContent) {
    1:           nsEventDispatcher::Dispatch(mCurrentEventContent, mPresContext,
    1:                                       aEvent, nsnull, aStatus, &eventCB);
    1:         }
    1:         else {
    1:           nsCOMPtr<nsIContent> targetContent;
    1:           rv = mCurrentEventFrame->GetContentForEvent(mPresContext, aEvent,
    1:                                                       getter_AddRefs(targetContent));
    1:           if (NS_SUCCEEDED(rv) && targetContent) {
    1:             nsEventDispatcher::Dispatch(targetContent, mPresContext, aEvent,
    1:                                         nsnull, aStatus, &eventCB);
    1:           } else if (mDocument) {
    1:             nsEventDispatcher::Dispatch(mDocument, mPresContext, aEvent,
    1:                                         nsnull, aStatus, nsnull);
    1:           }
    1:         }
    1:       }
    1: 
41239:       nsContentUtils::SetIsHandlingKeyBoardEvent(wasHandlingKeyBoardEvent);
41239: 
    1:       // 3. Give event to event manager for post event state changes and
    1:       //    generation of synthetic events.
22729:       if (!mIsDestroying && NS_SUCCEEDED(rv)) {
 8236:         rv = manager->PostHandleEvent(mPresContext, aEvent,
 8292:                                       GetCurrentEventFrame(), aStatus,
 8292:                                       weakView.GetView());
    1:       }
    1:     }
32435: 
32435:     if (aEvent->message == NS_MOUSE_BUTTON_UP) {
32435:       // reset the capturing content now that the mouse button is up
32435:       SetCapturingContent(nsnull, 0);
55892:     } else if (aEvent->message == NS_MOUSE_MOVE) {
55892:       nsIPresShell::AllowMouseCapture(PR_FALSE);
32435:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: // Dispatch event to content only (NOT full processing)
    1: // See also HandleEventWithTarget which does full event processing.
40055: nsresult
    1: PresShell::HandleDOMEventWithTarget(nsIContent* aTargetContent, nsEvent* aEvent,
    1:                                     nsEventStatus* aStatus)
    1: {
40055:   nsresult rv = NS_OK;
40055: 
    1:   PushCurrentEventInfo(nsnull, aTargetContent);
    1: 
    1:   // Bug 41013: Check if the event should be dispatched to content.
    1:   // It's possible that we are in the middle of destroying the window
    1:   // and the js context is out of date. This check detects the case
    1:   // that caused a crash in bug 41013, but there may be a better way
    1:   // to handle this situation!
    1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
    1:   if (container) {
    1: 
    1:     // Dispatch event to content
40055:     rv = nsEventDispatcher::Dispatch(aTargetContent, mPresContext, aEvent, nsnull,
    1:                                      aStatus);
    1:   }
    1: 
    1:   PopCurrentEventInfo();
40055:   return rv;
    1: }
    1: 
29844: // See the method above.
40055: nsresult
29844: PresShell::HandleDOMEventWithTarget(nsIContent* aTargetContent,
29844:                                     nsIDOMEvent* aEvent,
29844:                                     nsEventStatus* aStatus)
29844: {
40055:   nsresult rv = NS_OK;
40055: 
29844:   PushCurrentEventInfo(nsnull, aTargetContent);
29844:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
29844:   if (container) {
40055:     rv = nsEventDispatcher::DispatchDOMEvent(aTargetContent, nsnull, aEvent,
29844:                                              mPresContext, aStatus);
29844:   }
29844: 
29844:   PopCurrentEventInfo();
40055:   return rv;
29844: }
29844: 
23881: PRBool
23881: PresShell::AdjustContextMenuKeyEvent(nsMouseEvent* aEvent)
23881: {
23881: #ifdef MOZ_XUL
23881:   // if a menu is open, open the context menu relative to the active item on the menu. 
23881:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
23881:   if (pm) {
23881:     nsIFrame* popupFrame = pm->GetTopPopup(ePopupTypeMenu);
23881:     if (popupFrame) {
23881:       nsIFrame* itemFrame = 
23881:         (static_cast<nsMenuPopupFrame *>(popupFrame))->GetCurrentMenuItem();
23881:       if (!itemFrame)
23881:         itemFrame = popupFrame;
23881: 
47148:       nsCOMPtr<nsIWidget> widget = popupFrame->GetNearestWidget();
23881:       aEvent->widget = widget;
25183:       nsIntPoint widgetPoint = widget->WidgetToScreenOffset();
25183:       aEvent->refPoint = itemFrame->GetScreenRect().BottomLeft() - widgetPoint;
23881: 
23881:       mCurrentEventContent = itemFrame->GetContent();
23881:       mCurrentEventFrame = itemFrame;
23881: 
23881:       return PR_TRUE;
23881:     }
23881:   }
23881: #endif
23881: 
23881:   // If we're here because of the key-equiv for showing context menus, we
23881:   // have to twiddle with the NS event to make sure the context menu comes
23881:   // up in the upper left of the relevant content area before we create
23881:   // the DOM event. Since we never call InitMouseEvent() on the event, 
23881:   // the client X/Y will be 0,0. We can make use of that if the widget is null.
30534:   // Use the root view manager's widget since it's most likely to have one,
30534:   // and the coordinates returned by GetCurrentItemAndPositionForElement
47905:   // are relative to the widget of the root of the root view manager.
37502:   nsRootPresContext* rootPC = mPresContext->GetRootPresContext();
47905:   aEvent->refPoint.x = 0;
47905:   aEvent->refPoint.y = 0;
37502:   if (rootPC) {
37502:     rootPC->PresShell()->GetViewManager()->
30534:       GetRootWidget(getter_AddRefs(aEvent->widget));
47905: 
47905:     if (aEvent->widget) {
47905:       // default the refpoint to the topleft of our document
47905:       nsPoint offset(0, 0);
47905:       nsIFrame* rootFrame = FrameManager()->GetRootFrame();
47905:       if (rootFrame) {
47905:         nsIView* view = rootFrame->GetClosestView(&offset);
47905:         offset += view->GetOffsetToWidget(aEvent->widget);
47905:         aEvent->refPoint =
47905:           offset.ToNearestPixels(mPresContext->AppUnitsPerDevPixel());
47905:       }
47905:     }
37502:   } else {
37502:     aEvent->widget = nsnull;
37502:   }
23881: 
23881:   // see if we should use the caret position for the popup
23884:   nsIntPoint caretPoint;
23881:   // Beware! This may flush notifications via synchronous
23881:   // ScrollSelectionIntoView.
23881:   if (PrepareToUseCaretPosition(aEvent->widget, caretPoint)) {
23881:     // caret position is good
23881:     aEvent->refPoint = caretPoint;
23881:     return PR_TRUE;
23881:   }
23881: 
23881:   // If we're here because of the key-equiv for showing context menus, we
23881:   // have to reset the event target to the currently focused element. Get it
23881:   // from the focus controller.
23881:   nsCOMPtr<nsIDOMElement> currentFocus;
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm)
29018:     fm->GetFocusedElement(getter_AddRefs(currentFocus));
29018: 
23881:   // Reset event coordinates relative to focused frame in view
23881:   if (currentFocus) {
23881:     nsCOMPtr<nsIContent> currentPointElement;
23881:     GetCurrentItemAndPositionForElement(currentFocus,
23881:                                         getter_AddRefs(currentPointElement),
47902:                                         aEvent->refPoint,
47902:                                         aEvent->widget);
23881:     if (currentPointElement) {
23881:       mCurrentEventContent = currentPointElement;
23881:       mCurrentEventFrame = nsnull;
23881:       GetCurrentEventFrame();
23881:     }
23881:   }
23881: 
23881:   return PR_TRUE;
23881: }
23881: 
47902: // PresShell::PrepareToUseCaretPosition
23881: //
23881: //    This checks to see if we should use the caret position for popup context
23881: //    menus. Returns true if the caret position should be used, and the
23881: //    coordinates of that position is returned in aTargetPt. This function
23881: //    will also scroll the window as needed to make the caret visible.
23881: //
23881: //    The event widget should be the widget that generated the event, and
23881: //    whose coordinate system the resulting event's refPoint should be
23881: //    relative to.  The returned point is in device pixels realtive to the
23881: //    widget passed in.
23881: PRBool
23881: PresShell::PrepareToUseCaretPosition(nsIWidget* aEventWidget, nsIntPoint& aTargetPt)
23881: {
23881:   nsresult rv;
23881: 
23881:   // check caret visibility
40045:   nsRefPtr<nsCaret> caret = GetCaret();
23881:   NS_ENSURE_TRUE(caret, PR_FALSE);
23881: 
23881:   PRBool caretVisible = PR_FALSE;
23881:   rv = caret->GetCaretVisible(&caretVisible);
23881:   if (NS_FAILED(rv) || ! caretVisible)
23881:     return PR_FALSE;
23881: 
23881:   // caret selection, this is a temporary weak reference, so no refcounting is 
23881:   // needed
23881:   nsISelection* domSelection = caret->GetCaretDOMSelection();
23881:   NS_ENSURE_TRUE(domSelection, PR_FALSE);
23881: 
23881:   // since the match could be an anonymous textnode inside a
23881:   // <textarea> or text <input>, we need to get the outer frame
23881:   // note: frames are not refcounted
23881:   nsIFrame* frame = nsnull; // may be NULL
23881:   nsCOMPtr<nsIDOMNode> node;
23881:   rv = domSelection->GetFocusNode(getter_AddRefs(node));
23881:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
23881:   NS_ENSURE_TRUE(node, PR_FALSE);
23881:   nsCOMPtr<nsIContent> content(do_QueryInterface(node));
23881:   if (content) {
23881:     nsIContent* nonNative = content->FindFirstNonNativeAnonymous();
23881:     content = nonNative;
23881:   }
23881: 
23881:   if (content) {
23881:     // It seems like ScrollSelectionIntoView should be enough, but it's
23881:     // not. The problem is that scrolling the selection into view when it is
23881:     // below the current viewport will align the top line of the frame exactly
23881:     // with the bottom of the window. This is fine, BUT, the popup event causes
23881:     // the control to be re-focused which does this exact call to
23881:     // ScrollContentIntoView, which has a one-pixel disagreement of whether the
23881:     // frame is actually in view. The result is that the frame is aligned with
23881:     // the top of the window, but the menu is still at the bottom.
23881:     //
23881:     // Doing this call first forces the frame to be in view, eliminating the
23881:     // problem. The only difference in the result is that if your cursor is in
23881:     // an edit box below the current view, you'll get the edit box aligned with
23881:     // the top of the window. This is arguably better behavior anyway.
23881:     rv = ScrollContentIntoView(content, NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE,
56647:                                         NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE,
56647:                                         SCROLL_OVERFLOW_HIDDEN);
23881:     NS_ENSURE_SUCCESS(rv, PR_FALSE);
36656:     frame = content->GetPrimaryFrame();
23881:     NS_WARN_IF_FALSE(frame, "No frame for focused content?");
23881:   }
23881: 
23881:   // Actually scroll the selection (ie caret) into view. Note that this must
23881:   // be synchronous since we will be checking the caret position on the screen.
23881:   //
23881:   // Be easy about errors, and just don't scroll in those cases. Better to have
23881:   // the correct menu at a weird place than the wrong menu.
23881:   // After ScrollSelectionIntoView(), the pending notifications might be
23881:   // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
23881:   nsCOMPtr<nsISelectionController> selCon;
23881:   if (frame)
23881:     frame->GetSelectionController(GetPresContext(), getter_AddRefs(selCon));
23881:   else
23881:     selCon = static_cast<nsISelectionController *>(this);
23881:   if (selCon) {
23881:     rv = selCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
56442:                                          nsISelectionController::SELECTION_FOCUS_REGION,
56442:                                          nsISelectionController::SCROLL_SYNCHRONOUS);
23881:     NS_ENSURE_SUCCESS(rv, PR_FALSE);
23881:   }
23881: 
47902:   nsPresContext* presContext = GetPresContext();
47902: 
47902:   // get caret position relative to the closest view
23881:   nsRect caretCoords;
39425:   nsIFrame* caretFrame = caret->GetGeometry(domSelection, &caretCoords);
39425:   if (!caretFrame)
39425:     return PR_FALSE;
47902:   nsPoint viewOffset;
47902:   nsIView* view = caretFrame->GetClosestView(&viewOffset);
47902:   if (!view)
39425:     return PR_FALSE;
47902:   // and then get the caret coords relative to the event widget
47902:   if (aEventWidget) {
47902:     viewOffset += view->GetOffsetToWidget(aEventWidget);
47902:   }
47902:   caretCoords.MoveBy(viewOffset);
23881: 
23881:   // caret coordinates are in app units, convert to pixels
47902:   aTargetPt.x =
47902:     presContext->AppUnitsToDevPixels(caretCoords.x + caretCoords.width);
47902:   aTargetPt.y =
47902:     presContext->AppUnitsToDevPixels(caretCoords.y + caretCoords.height);
23881: 
36975:   // make sure rounding doesn't return a pixel which is outside the caret
36975:   // (e.g. one line lower)
36975:   aTargetPt.y -= 1;
36975: 
23881:   return PR_TRUE;
23881: }
23881: 
23881: void
23881: PresShell::GetCurrentItemAndPositionForElement(nsIDOMElement *aCurrentEl,
23881:                                                nsIContent** aTargetToUse,
47902:                                                nsIntPoint& aTargetPt,
47902:                                                nsIWidget *aRootWidget)
23881: {
23881:   nsCOMPtr<nsIContent> focusedContent(do_QueryInterface(aCurrentEl));
23881:   ScrollContentIntoView(focusedContent, NS_PRESSHELL_SCROLL_ANYWHERE,
56647:                                         NS_PRESSHELL_SCROLL_ANYWHERE,
56647:                                         SCROLL_OVERFLOW_HIDDEN);
23881: 
47902:   nsPresContext* presContext = GetPresContext();
47902: 
23881:   PRBool istree = PR_FALSE, checkLineHeight = PR_TRUE;
47902:   nscoord extraTreeY = 0;
23881: 
23881: #ifdef MOZ_XUL
23881:   // Set the position to just underneath the current item for multi-select
23881:   // lists or just underneath the selected item for single-select lists. If
23881:   // the element is not a list, or there is no selection, leave the position
23881:   // as is.
23881:   nsCOMPtr<nsIDOMXULSelectControlItemElement> item;
23881:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> multiSelect =
23881:     do_QueryInterface(aCurrentEl);
23881:   if (multiSelect) {
23881:     checkLineHeight = PR_FALSE;
23881:     
23881:     PRInt32 currentIndex;
23881:     multiSelect->GetCurrentIndex(&currentIndex);
23881:     if (currentIndex >= 0) {
23881:       nsCOMPtr<nsIDOMXULElement> xulElement(do_QueryInterface(aCurrentEl));
23881:       if (xulElement) {
23881:         nsCOMPtr<nsIBoxObject> box;
23881:         xulElement->GetBoxObject(getter_AddRefs(box));
23881:         nsCOMPtr<nsITreeBoxObject> treeBox(do_QueryInterface(box));
23881:         // Tree view special case (tree items have no frames)
23881:         // Get the focused row and add its coordinates, which are already in pixels
23881:         // XXX Boris, should we create a new interface so that this doesn't
23881:         // need to know about trees? Something like nsINodelessChildCreator which
23881:         // could provide the current focus coordinates?
23881:         if (treeBox) {
23881:           treeBox->EnsureRowIsVisible(currentIndex);
23881:           PRInt32 firstVisibleRow, rowHeight;
23881:           treeBox->GetFirstVisibleRow(&firstVisibleRow);
23881:           treeBox->GetRowHeight(&rowHeight);
23881: 
47902:           extraTreeY += presContext->CSSPixelsToAppUnits(
47902:                           (currentIndex - firstVisibleRow + 1) * rowHeight);
23881:           istree = PR_TRUE;
23881: 
23881:           nsCOMPtr<nsITreeColumns> cols;
23881:           treeBox->GetColumns(getter_AddRefs(cols));
23881:           if (cols) {
23881:             nsCOMPtr<nsITreeColumn> col;
23881:             cols->GetFirstColumn(getter_AddRefs(col));
23881:             if (col) {
23881:               nsCOMPtr<nsIDOMElement> colElement;
23881:               col->GetElement(getter_AddRefs(colElement));
23881:               nsCOMPtr<nsIContent> colContent(do_QueryInterface(colElement));
23881:               if (colContent) {
36656:                 nsIFrame* frame = colContent->GetPrimaryFrame();
23881:                 if (frame) {
47902:                   extraTreeY += frame->GetSize().height;
23881:                 }
23881:               }
23881:             }
23881:           }
23881:         }
23881:         else {
23881:           multiSelect->GetCurrentItem(getter_AddRefs(item));
23881:         }
23881:       }
23881:     }
23881:   }
23881:   else {
23881:     // don't check menulists as the selected item will be inside a popup.
23881:     nsCOMPtr<nsIDOMXULMenuListElement> menulist = do_QueryInterface(aCurrentEl);
23881:     if (!menulist) {
23881:       nsCOMPtr<nsIDOMXULSelectControlElement> select =
23881:         do_QueryInterface(aCurrentEl);
46317:       if (select) {
46317:         checkLineHeight = PR_FALSE;
23881:         select->GetSelectedItem(getter_AddRefs(item));
23881:       }
23881:     }
46317:   }
23881: 
23881:   if (item)
23881:     focusedContent = do_QueryInterface(item);
23881: #endif
23881: 
36656:   nsIFrame *frame = focusedContent->GetPrimaryFrame();
23881:   if (frame) {
47902:     NS_ASSERTION(frame->PresContext() == GetPresContext(),
47902:       "handling event for focused content that is not in our document?");
47902: 
23881:     nsPoint frameOrigin(0, 0);
23881: 
23881:     // Get the frame's origin within its view
23881:     nsIView *view = frame->GetClosestView(&frameOrigin);
23881:     NS_ASSERTION(view, "No view for frame");
23881: 
47902:     // View's origin relative the widget
47902:     if (aRootWidget) {
47902:       frameOrigin += view->GetOffsetToWidget(aRootWidget);
47902:     }
23881: 
23881:     // Start context menu down and to the right from top left of frame
23881:     // use the lineheight. This is a good distance to move the context
23881:     // menu away from the top left corner of the frame. If we always 
23881:     // used the frame height, the context menu could end up far away,
23881:     // for example when we're focused on linked images.
23881:     // On the other hand, we want to use the frame height if it's less
23881:     // than the current line height, so that the context menu appears
23881:     // associated with the correct frame.
23881:     nscoord extra = 0;
23881:     if (!istree) {
23881:       extra = frame->GetSize().height;
23881:       if (checkLineHeight) {
37057:         nsIScrollableFrame *scrollFrame =
37057:           nsLayoutUtils::GetNearestScrollableFrame(frame);
37057:         if (scrollFrame) {
47902:           nsSize scrollAmount = scrollFrame->GetLineScrollAmount();
47902:           nsIFrame* f = do_QueryFrame(scrollFrame);
47902:           PRInt32 APD = presContext->AppUnitsPerDevPixel();
47902:           PRInt32 scrollAPD = f->PresContext()->AppUnitsPerDevPixel();
47902:           scrollAmount = scrollAmount.ConvertAppUnits(scrollAPD, APD);
47902:           if (extra > scrollAmount.height) {
47902:             extra = scrollAmount.height;
47902:           }
47902:         }
47902:       }
47902:     }
47902: 
23881:     aTargetPt.x = presContext->AppUnitsToDevPixels(frameOrigin.x);
23881:     aTargetPt.y = presContext->AppUnitsToDevPixels(
47902:                     frameOrigin.y + extra + extraTreeY);
23881:   }
23881: 
23881:   NS_IF_ADDREF(*aTargetToUse = focusedContent);
23881: }
23881: 
    1: NS_IMETHODIMP
    1: PresShell::ResizeReflow(nsIView *aView, nscoord aWidth, nscoord aHeight)
    1: {
    1:   return ResizeReflow(aWidth, aHeight);
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
50857: PresShell::ShouldIgnoreInvalidation()
50857: {
51761:   return mPaintingSuppressed || !mIsActive;
50857: }
50857: 
    1: NS_IMETHODIMP_(void)
47756: PresShell::WillPaint(PRBool aWillSendDidPaint)
47756: {
52491:   // Don't bother doing anything if some viewmanager in our tree is painting
52491:   // while we still have painting suppressed or we are not active.
52491:   if (mPaintingSuppressed || !mIsActive) {
    1:     return;
    1:   }
    1: 
47756:   if (!aWillSendDidPaint) {
47756:     nsRootPresContext* rootPresContext = mPresContext->GetRootPresContext();
47756:     if (!rootPresContext) {
47756:       return;
47756:     }
47756:     if (rootPresContext == mPresContext) {
47756:       rootPresContext->UpdatePluginGeometry();
47756:     }
47756:   }
47756: 
    1:   // Process reflows, if we have them, to reduce flicker due to invalidates and
    1:   // reflow being interspersed.  Note that we _do_ allow this to be
    1:   // interruptible; if we can't do all the reflows it's better to flicker a bit
    1:   // than to freeze up.
27993:   FlushPendingNotifications(Flush_InterruptibleLayout);
    1: }
    1: 
47756: NS_IMETHODIMP_(void)
47756: PresShell::DidPaint()
47756: {
47756:   nsRootPresContext* rootPresContext = mPresContext->GetRootPresContext();
47756:   if (!rootPresContext) {
47756:     return;
47756:   }
47756:   if (rootPresContext == mPresContext) {
47756:     rootPresContext->UpdatePluginGeometry();
47756:   }
47756: }
47756: 
    1: nsresult
    1: PresShell::GetAgentStyleSheets(nsCOMArray<nsIStyleSheet>& aSheets)
    1: {
    1:   aSheets.Clear();
    1:   PRInt32 sheetCount = mStyleSet->SheetCount(nsStyleSet::eAgentSheet);
    1: 
    1:   for (PRInt32 i = 0; i < sheetCount; ++i) {
    1:     nsIStyleSheet *sheet = mStyleSet->StyleSheetAt(nsStyleSet::eAgentSheet, i);
    1:     if (!aSheets.AppendObject(sheet))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: PresShell::SetAgentStyleSheets(const nsCOMArray<nsIStyleSheet>& aSheets)
    1: {
    1:   return mStyleSet->ReplaceSheets(nsStyleSet::eAgentSheet, aSheets);
    1: }
    1: 
    1: nsresult
    1: PresShell::AddOverrideStyleSheet(nsIStyleSheet *aSheet)
    1: {
    1:   return mStyleSet->PrependStyleSheet(nsStyleSet::eOverrideSheet, aSheet);
    1: }
    1: 
    1: nsresult
    1: PresShell::RemoveOverrideStyleSheet(nsIStyleSheet *aSheet)
    1: {
    1:   return mStyleSet->RemoveStyleSheet(nsStyleSet::eOverrideSheet, aSheet);
    1: }
    1: 
    1: static void
36656: FreezeElement(nsIContent *aContent, void * /* unused */)
36656: {
36656:   nsIFrame *frame = aContent->GetPrimaryFrame();
28108:   nsIObjectFrame *objectFrame = do_QueryFrame(frame);
28108:   if (objectFrame) {
28108:     objectFrame->StopPlugin();
28108:   }
28108: }
28108: 
20261: static PRBool
    1: FreezeSubDocument(nsIDocument *aDocument, void *aData)
    1: {
46225:   nsIPresShell *shell = aDocument->GetShell();
    1:   if (shell)
    1:     shell->Freeze();
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: PresShell::Freeze()
    1: {
35522:   MaybeReleaseCapturingContent();
35522: 
36656:   mDocument->EnumerateFreezableElements(FreezeElement, nsnull);
    1: 
59014:   if (mCaret) {
    1:     mCaret->SetCaretVisible(PR_FALSE);
59014:   }
    1: 
    1:   mPaintingSuppressed = PR_TRUE;
    1: 
59014:   if (mDocument) {
    1:     mDocument->EnumerateSubDocuments(FreezeSubDocument, nsnull);
59014:   }
37880: 
37880:   nsPresContext* presContext = GetPresContext();
50366:   if (presContext &&
50366:       presContext->RefreshDriver()->PresContext() == presContext) {
37880:     presContext->RefreshDriver()->Freeze();
37880:   }
50815: 
50815:   mFrozen = PR_TRUE;
59014:   if (mDocument) {
50815:     UpdateImageLockingState();
    1:   }
59014: }
    1: 
25722: void
25722: PresShell::FireOrClearDelayedEvents(PRBool aFireEvents)
25722: {
28498:   mNoDelayedMouseEvents = PR_FALSE;
28498:   mNoDelayedKeyEvents = PR_FALSE;
25722:   if (!aFireEvents) {
28498:     mDelayedEvents.Clear();
25722:     return;
25722:   }
25722: 
29275:   if (mDocument) {
25722:     nsCOMPtr<nsIDocument> doc = mDocument;
29275:     while (!mIsDestroying && mDelayedEvents.Length() &&
29275:            !doc->EventHandlingSuppressed()) {
29275:       nsAutoPtr<nsDelayedEvent> ev(mDelayedEvents[0].forget());
28498:       mDelayedEvents.RemoveElementAt(0);
29275:       ev->Dispatch(this);
25724:     }
25724:     if (!doc->EventHandlingSuppressed()) {
28498:       mDelayedEvents.Clear();
25722:     }
25722:   }
25722: }
25722: 
    1: static void
28108: ThawElement(nsIContent *aContent, void *aShell)
28108: {
    1:   nsCOMPtr<nsIObjectLoadingContent> objlc(do_QueryInterface(aContent));
28108:   if (objlc) {
    1:     nsCOMPtr<nsIPluginInstance> inst;
    1:     objlc->EnsureInstantiation(getter_AddRefs(inst));
    1:   }
28108: }
15751: 
20261: static PRBool
    1: ThawSubDocument(nsIDocument *aDocument, void *aData)
    1: {
46225:   nsIPresShell *shell = aDocument->GetShell();
    1:   if (shell)
    1:     shell->Thaw();
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: PresShell::Thaw()
    1: {
37880:   nsPresContext* presContext = GetPresContext();
50366:   if (presContext &&
50366:       presContext->RefreshDriver()->PresContext() == presContext) {
37880:     presContext->RefreshDriver()->Thaw();
37880:   }
37880: 
28108:   mDocument->EnumerateFreezableElements(ThawElement, this);
    1: 
    1:   if (mDocument)
    1:     mDocument->EnumerateSubDocuments(ThawSubDocument, nsnull);
    1: 
48937:   // Get the activeness of our presshell, as this might have changed
48937:   // while we were in the bfcache
48937:   QueryIsActive();
50815: 
50815:   // We're now unfrozen
50815:   mFrozen = PR_FALSE;
50815:   UpdateImageLockingState();
52487: 
52487:   UnsuppressPainting();
    1: }
    1: 
    1: //--------------------------------------------------------
    1: // Start of protected and private methods on the PresShell
    1: //--------------------------------------------------------
    1: 
    1: void
38310: PresShell::MaybeScheduleReflow()
38310: {
38310:   ASSERT_REFLOW_SCHEDULED_STATE();
38310:   if (mReflowScheduled || mIsDestroying || mIsReflowing ||
24551:       mDirtyRoots.Length() == 0)
    1:     return;
    1: 
38310:   if (!mPresContext->HasPendingInterrupt() || !ScheduleReflowOffTimer()) {
38310:     ScheduleReflow();
38310:   }
38310: 
38310:   ASSERT_REFLOW_SCHEDULED_STATE();
29172: }
29172: 
29172: void
38310: PresShell::ScheduleReflow()
38310: {
38310:   NS_PRECONDITION(!mReflowScheduled, "Why are we trying to schedule a reflow?");
38310:   ASSERT_REFLOW_SCHEDULED_STATE();
38310: 
50365:   if (GetPresContext()->RefreshDriver()->AddLayoutFlushObserver(this)) {
38310:     mReflowScheduled = PR_TRUE;
38310:   }
38310: 
38310:   ASSERT_REFLOW_SCHEDULED_STATE();
    1: }
    1: 
29804: nsresult
29804: PresShell::DidCauseReflow()
29804: {
29804:   NS_ASSERTION(mChangeNestCount != 0, "Unexpected call to DidCauseReflow()");
29804:   --mChangeNestCount;
29804:   nsContentUtils::RemoveScriptBlocker();
29804: 
29804:   return NS_OK;
29804: }
29804: 
    1: void
    1: PresShell::WillDoReflow()
    1: {
    1:   // We just reflowed, tell the caret that its frame might have moved.
 6518:   // XXXbz that comment makes no sense
    1:   if (mCaret) {
    1:     mCaret->InvalidateOutsideCaret();
    1:   }
 6518: 
21925:   mPresContext->FlushUserFontSet();
21925: 
 6518:   mFrameConstructor->BeginUpdate();
    1: }
    1: 
    1: void
27993: PresShell::DidDoReflow(PRBool aInterruptible)
    1: {
 6518:   mFrameConstructor->EndUpdate();
 6518:   
27993:   HandlePostedReflowCallbacks(aInterruptible);
52492:   SynthesizeMouseMove(PR_FALSE);
    1:   if (mCaret) {
    1:     // Update the caret's position now to account for any changes created by
    1:     // the reflow.
    1:     mCaret->InvalidateOutsideCaret();
    1:     mCaret->UpdateCaretPosition();
    1:   }
    1: }
    1: 
27993: static PLDHashOperator
27993: MarkFramesDirtyToRoot(nsPtrHashKey<nsIFrame>* p, void* closure)
27993: {
27993:   nsIFrame* target = static_cast<nsIFrame*>(closure);
27993:   for (nsIFrame* f = p->GetKey(); f && !NS_SUBTREE_DIRTY(f);
27993:        f = f->GetParent()) {
27993:     f->AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
27993: 
27993:     if (f == target) {
27993:       break;
27993:     }
27993:   }
27993: 
27993:   return PL_DHASH_NEXT;
27993: }
27993: 
29172: void
29172: PresShell::sReflowContinueCallback(nsITimer* aTimer, void* aPresShell)
29172: {
29172:   nsRefPtr<PresShell> self = static_cast<PresShell*>(aPresShell);
29172: 
29172:   NS_PRECONDITION(aTimer == self->mReflowContinueTimer, "Unexpected timer");
29172:   self->mReflowContinueTimer = nsnull;
38310:   self->ScheduleReflow();
29172: }
29172: 
29172: PRBool
38310: PresShell::ScheduleReflowOffTimer()
38310: {
38310:   NS_PRECONDITION(!mReflowScheduled, "Shouldn't get here");
38310:   ASSERT_REFLOW_SCHEDULED_STATE();
38310: 
29172:   if (!mReflowContinueTimer) {
29172:     mReflowContinueTimer = do_CreateInstance("@mozilla.org/timer;1");
29172:     if (!mReflowContinueTimer ||
29172:         NS_FAILED(mReflowContinueTimer->
33392:                     InitWithFuncCallback(sReflowContinueCallback, this, 30,
29172:                                          nsITimer::TYPE_ONE_SHOT))) {
29172:       return PR_FALSE;
29172:     }
29172:   }
29172:   return PR_TRUE;
29172: }
29172: 
27993: PRBool
27993: PresShell::DoReflow(nsIFrame* target, PRBool aInterruptible)
  790: {
42480:   NS_TIME_FUNCTION_WITH_DOCURL;
42480: 
33393:   if (mReflowContinueTimer) {
33393:     mReflowContinueTimer->Cancel();
33393:     mReflowContinueTimer = nsnull;
33393:   }
33393: 
  790:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
  790: 
51038:   nsCOMPtr<nsIRenderingContext> rcx = GetReferenceRenderingContext();
51038:   if (!rcx) {
  790:     NS_NOTREACHED("CreateRenderingContext failure");
27993:     return PR_FALSE;
27993:   }
27993: 
27993: #ifdef DEBUG
27993:   mCurrentReflowRoot = target;
27993: #endif
    1: 
    1:   target->WillReflow(mPresContext);
    1: 
    1:   // If the target frame is the root of the frame hierarchy, then
    1:   // use all the available space. If it's simply a `reflow root',
    1:   // then use the target frame's size as the available space.
    1:   nsSize size;
47775:   if (target == rootFrame) {
  790:      size = mPresContext->GetVisibleArea().Size();
47775: 
47775:      // target->GetRect() has the old size of the frame,
47775:      // mPresContext->GetVisibleArea() has the new size.
47775:      target->InvalidateRectDifference(mPresContext->GetVisibleArea(),
47775:                                       target->GetRect());
47775:   } else {
    1:      size = target->GetSize();
47775:   }
    1: 
    1:   NS_ASSERTION(!target->GetNextInFlow() && !target->GetPrevInFlow(),
    1:                "reflow roots should never split");
    1: 
    1:   // Don't pass size directly to the reflow state, since a
    1:   // constrained height implies page/column breaking.
24416:   nsSize reflowSize(size.width, NS_UNCONSTRAINEDSIZE);
  790:   nsHTMLReflowState reflowState(mPresContext, target, rcx, reflowSize);
    1: 
55051:   if (rootFrame == target) {
55051:     // When the root frame is being reflowed with unconstrained height
55051:     // (which happens when we're called from
55051:     // DocumentViewerImpl::SizeToContent), we're effectively doing a
55051:     // vertical resize, since it changes the meaning of percentage
55051:     // heights even if no heights actually changed.  The same applies
55051:     // when we reflow again after that computation.  This is an unusual
55051:     // case, and isn't caught by nsHTMLReflowState::InitResizeFlags.
55051:     PRBool hasUnconstrainedHeight = size.height == NS_UNCONSTRAINEDSIZE;
55051: 
55051:     if (hasUnconstrainedHeight || mLastRootReflowHadUnconstrainedHeight) {
55051:       reflowState.mFlags.mVResize = PR_TRUE;
55051:     }
55051: 
55051:     mLastRootReflowHadUnconstrainedHeight = hasUnconstrainedHeight;
55051:   }
55051: 
    1:   // fix the computed height
    1:   NS_ASSERTION(reflowState.mComputedMargin == nsMargin(0, 0, 0, 0),
    1:                "reflow state should not set margin for reflow roots");
  967:   if (size.height != NS_UNCONSTRAINEDSIZE) {
 4166:     nscoord computedHeight =
    1:       size.height - reflowState.mComputedBorderPadding.TopBottom();
32531:     computedHeight = NS_MAX(computedHeight, 0);
 4166:     reflowState.SetComputedHeight(computedHeight);
  967:   }
    1:   NS_ASSERTION(reflowState.ComputedWidth() ==
    1:                  size.width -
    1:                    reflowState.mComputedBorderPadding.LeftRight(),
    1:                "reflow state computed incorrect width");
    1: 
27993:   mPresContext->ReflowStarted(aInterruptible);
27993:   mIsReflowing = PR_TRUE;
27993: 
    1:   nsReflowStatus status;
  790:   nsHTMLReflowMetrics desiredSize;
    1:   target->Reflow(mPresContext, desiredSize, reflowState, status);
    1: 
    1:   // If an incremental reflow is initiated at a frame other than the
  967:   // root frame, then its desired size had better not change!  If it's
  967:   // initiated at the root, then the size better not change unless its
  967:   // height was unconstrained to start with.
  967:   NS_ASSERTION((target == rootFrame && size.height == NS_UNCONSTRAINEDSIZE) ||
    1:                (desiredSize.width == size.width &&
    1:                 desiredSize.height == size.height),
    1:                "non-root frame's desired size changed during an "
    1:                "incremental reflow");
55039:   NS_ASSERTION(desiredSize.VisualOverflow() ==
    1:                  nsRect(nsPoint(0, 0),
    1:                         nsSize(desiredSize.width, desiredSize.height)),
    1:                "reflow roots must not have visible overflow");
55039:   NS_ASSERTION(desiredSize.ScrollableOverflow() ==
55039:                  nsRect(nsPoint(0, 0),
55039:                         nsSize(desiredSize.width, desiredSize.height)),
55039:                "reflow roots must not have scrollable overflow");
    1:   NS_ASSERTION(status == NS_FRAME_COMPLETE,
    1:                "reflow roots should never split");
    1: 
    1:   target->SetSize(nsSize(desiredSize.width, desiredSize.height));
    1: 
    1:   nsContainerFrame::SyncFrameViewAfterReflow(mPresContext, target,
    1:                                              target->GetView(),
55039:                                              desiredSize.VisualOverflow());
31401:   nsContainerFrame::SyncWindowProperties(mPresContext, target,
31401:                                          target->GetView());
    1: 
    1:   target->DidReflow(mPresContext, nsnull, NS_FRAME_REFLOW_FINISHED);
  967:   if (target == rootFrame && size.height == NS_UNCONSTRAINEDSIZE) {
  967:     mPresContext->SetVisibleArea(nsRect(0, 0, desiredSize.width,
  967:                                         desiredSize.height));
  967:   }
27993: 
27993: #ifdef DEBUG
27993:   mCurrentReflowRoot = nsnull;
27993: #endif
27993: 
27993:   NS_ASSERTION(mPresContext->HasPendingInterrupt() ||
27993:                mFramesToDirty.Count() == 0,
27993:                "Why do we need to dirty anything if not interrupted?");
27993: 
27993:   mIsReflowing = PR_FALSE;
27993:   PRBool interrupted = mPresContext->HasPendingInterrupt();
27993:   if (interrupted) {
27993:     // Make sure target gets reflowed again.
27993:     mFramesToDirty.EnumerateEntries(&MarkFramesDirtyToRoot, target);
27993:     NS_ASSERTION(NS_SUBTREE_DIRTY(target), "Why is the target not dirty?");
27993:     mDirtyRoots.AppendElement(target);
27993: 
27993:     // Clear mFramesToDirty after we've done the NS_SUBTREE_DIRTY(target)
27993:     // assertion so that if it fails it's easier to see what's going on.
27993: #ifdef NOISY_INTERRUPTIBLE_REFLOW
27993:     printf("mFramesToDirty.Count() == %u\n", mFramesToDirty.Count());
27993: #endif /* NOISY_INTERRUPTIBLE_REFLOW */
27993:     mFramesToDirty.Clear();
27993: 
27993:     // Any FlushPendingNotifications with interruptible reflows
27993:     // should be suppressed now. We don't want to do extra reflow work
27993:     // before our reflow event happens.
27993:     mSuppressInterruptibleReflows = PR_TRUE;
38310:     MaybeScheduleReflow();
27993:   }
27993: 
37502:   nsRootPresContext* rootPC = mPresContext->GetRootPresContext();
37502:   if (rootPC) {
47756:     rootPC->RequestUpdatePluginGeometry(target);
37502:   }
30522: 
27993:   return !interrupted;
  790: }
    1: 
    1: #ifdef DEBUG
  790: void
  790: PresShell::DoVerifyReflow()
  790: {
    1:   if (GetVerifyReflowEnable()) {
    1:     // First synchronously render what we have so far so that we can
    1:     // see it.
    1:     nsIView* rootView;
    1:     mViewManager->GetRootView(rootView);
    1:     mViewManager->UpdateView(rootView, NS_VMREFRESH_IMMEDIATE);
    1: 
  790:     FlushPendingNotifications(Flush_Layout);
    1:     mInVerifyReflow = PR_TRUE;
    1:     PRBool ok = VerifyIncrementalReflow();
    1:     mInVerifyReflow = PR_FALSE;
    1:     if (VERIFY_REFLOW_ALL & gVerifyReflowFlags) {
    1:       printf("ProcessReflowCommands: finished (%s)\n",
    1:              ok ? "ok" : "failed");
    1:     }
    1: 
24551:     if (0 != mDirtyRoots.Length()) {
    1:       printf("XXX yikes! reflow commands queued during verify-reflow\n");
    1:     }
    1:   }
  790: }
    1: #endif
    1: 
27993: PRBool
  790: PresShell::ProcessReflowCommands(PRBool aInterruptible)
  790: {
42480:   NS_TIME_FUNCTION_WITH_DOCURL;
42480: 
27993:   PRBool interrupted = PR_FALSE;
24551:   if (0 != mDirtyRoots.Length()) {
  790: 
  790: #ifdef DEBUG
  790:     if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {
  790:       printf("ProcessReflowCommands: begin incremental reflow\n");
  790:     }
  790: #endif
  790: 
  790:     // If reflow is interruptible, then make a note of our deadline.
  790:     const PRIntervalTime deadline = aInterruptible
  790:         ? PR_IntervalNow() + PR_MicrosecondsToInterval(gMaxRCProcessingTime)
  790:         : (PRIntervalTime)0;
  790: 
 6171:     // Scope for the reflow entry point
 6171:     {
13098:       nsAutoScriptBlocker scriptBlocker;
29072:       WillDoReflow();
  790:       AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Reflow);
  790: 
  790:       do {
  790:         // Send an incremental reflow notification to the target frame.
24551:         PRInt32 idx = mDirtyRoots.Length() - 1;
24551:         nsIFrame *target = mDirtyRoots[idx];
  790:         mDirtyRoots.RemoveElementAt(idx);
  790: 
 1158:         if (!NS_SUBTREE_DIRTY(target)) {
  790:           // It's not dirty anymore, which probably means the notification
  790:           // was posted in the middle of a reflow (perhaps with a reflow
  790:           // root in the middle).  Don't do anything.
  790:           continue;
  790:         }
  790: 
27993:         interrupted = !DoReflow(target, aInterruptible);
  790: 
  790:         // Keep going until we're out of reflow commands, or we've run
27993:         // past our deadline, or we're interrupted.
27993:       } while (!interrupted && mDirtyRoots.Length() &&
  790:                (!aInterruptible || PR_IntervalNow() < deadline));
  790: 
27993:       interrupted = mDirtyRoots.Length() != 0;
  790:     }
  790: 
13098:     // Exiting the scriptblocker might have killed us
13098:     if (!mIsDestroying) {
27993:       DidDoReflow(aInterruptible);
13098:     }
    1: 
 6162:     // DidDoReflow might have killed us
 6162:     if (!mIsDestroying) {
  790: #ifdef DEBUG
  790:       if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {
 6162:         printf("\nPresShell::ProcessReflowCommands() finished: this=%p\n",
 6162:                (void*)this);
  790:       }
  790:       DoVerifyReflow();
  790: #endif
  790: 
  921:       // If any new reflow commands were enqueued during the reflow, schedule
  921:       // another reflow event to process them.  Note that we want to do this
  921:       // after DidDoReflow(), since that method can change whether there are
 6162:       // dirty roots around by flushing, and there's no point in posting a
 6162:       // reflow event just to have the flush revoke it.
24551:       if (mDirtyRoots.Length())
38310:         MaybeScheduleReflow();
    1:     }
 6162:   }
    1: 
 6162:   if (!mIsDestroying && mShouldUnsuppressPainting &&
24551:       mDirtyRoots.Length() == 0) {
    1:     // We only unlock if we're out of reflows.  It's pointless
    1:     // to unlock if reflows are still pending, since reflows
    1:     // are just going to thrash the frames around some more.  By
    1:     // waiting we avoid an overeager "jitter" effect.
    1:     mShouldUnsuppressPainting = PR_FALSE;
    1:     UnsuppressAndInvalidate();
    1:   }
    1: 
27993:   return !interrupted;
    1: }
    1: 
    1: #ifdef MOZ_XUL
    1: /*
    1:  * It's better to add stuff to the |DidSetStyleContext| method of the
    1:  * relevant frames than adding it here.  These methods should (ideally,
    1:  * anyway) go away.
    1:  */
    1: 
    1: // Return value says whether to walk children.
20261: typedef PRBool (* frameWalkerFn)(nsIFrame *aFrame, void *aClosure);
20261:    
20261: static PRBool
    1: ReResolveMenusAndTrees(nsIFrame *aFrame, void *aClosure)
    1: {
    1:   // Trees have a special style cache that needs to be flushed when
    1:   // the theme changes.
23554:   nsTreeBodyFrame *treeBody = do_QueryFrame(aFrame);
20988:   if (treeBody)
20988:     treeBody->ClearStyleAndImageCaches();
    1: 
    1:   // We deliberately don't re-resolve style on a menu's popup
    1:   // sub-content, since doing so slows menus to a crawl.  That means we
    1:   // have to special-case them on a skin switch, and ensure that the
    1:   // popup frames just get destroyed completely.
 3129:   if (aFrame && aFrame->GetType() == nsGkAtoms::menuFrame)
 3233:     (static_cast<nsMenuFrame *>(aFrame))->CloseMenu(PR_TRUE);
    1:   return PR_TRUE;
    1: }
    1: 
20261: static PRBool
    1: ReframeImageBoxes(nsIFrame *aFrame, void *aClosure)
    1: {
 3233:   nsStyleChangeList *list = static_cast<nsStyleChangeList*>(aClosure);
    1:   if (aFrame->GetType() == nsGkAtoms::imageBoxFrame) {
    1:     list->AppendChange(aFrame, aFrame->GetContent(),
    1:                        NS_STYLE_HINT_FRAMECHANGE);
    1:     return PR_FALSE; // don't walk descendants
    1:   }
    1:   return PR_TRUE; // walk descendants
    1: }
    1: 
    1: static void
    1: WalkFramesThroughPlaceholders(nsPresContext *aPresContext, nsIFrame *aFrame,
    1:                               frameWalkerFn aFunc, void *aClosure)
    1: {
    1:   PRBool walkChildren = (*aFunc)(aFrame, aClosure);
    1:   if (!walkChildren)
    1:     return;
    1: 
    1:   PRInt32 listIndex = 0;
    1:   nsIAtom* childList = nsnull;
    1: 
    1:   do {
    1:     nsIFrame *child = aFrame->GetFirstChild(childList);
    1:     while (child) {
    1:       if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
    1:         // only do frames that are in flow, and recur through the
    1:         // out-of-flows of placeholders.
    1:         WalkFramesThroughPlaceholders(aPresContext,
    1:                                       nsPlaceholderFrame::GetRealFrameFor(child),
    1:                                       aFunc, aClosure);
    1:       }
    1:       child = child->GetNextSibling();
    1:     }
    1: 
    1:     childList = aFrame->GetAdditionalChildListName(listIndex++);
    1:   } while (childList);
    1: }
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: PresShell::Observe(nsISupports* aSubject, 
    1:                    const char* aTopic,
    1:                    const PRUnichar* aData)
    1: {
    1: #ifdef MOZ_XUL
    1:   if (!nsCRT::strcmp(aTopic, "chrome-flush-skin-caches")) {
    1:     nsIFrame *rootFrame = FrameManager()->GetRootFrame();
    1:     // Need to null-check because "chrome-flush-skin-caches" can happen
    1:     // at interesting times during startup.
    1:     if (rootFrame) {
    1:       NS_ASSERTION(mViewManager, "View manager must exist");
10730:       nsIViewManager::UpdateViewBatch batch(mViewManager);
    1: 
36817:       nsWeakFrame weakRoot(rootFrame);
36817:       // Have to make sure that the content notifications are flushed before we
36817:       // start messing with the frame model; otherwise we can get content doubling.
36817:       mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
36817: 
36817:       if (weakRoot.IsAlive()) {
    1:         WalkFramesThroughPlaceholders(mPresContext, rootFrame,
    1:                                       &ReResolveMenusAndTrees, nsnull);
    1: 
    1:         // Because "chrome:" URL equality is messy, reframe image box
    1:         // frames (hack!).
    1:         nsStyleChangeList changeList;
    1:         WalkFramesThroughPlaceholders(mPresContext, rootFrame,
    1:                                       ReframeImageBoxes, &changeList);
 7017:         // Mark ourselves as not safe to flush while we're doing frame
 7017:         // construction.
13098:         {
13098:           nsAutoScriptBlocker scriptBlocker;
29804:           ++mChangeNestCount;
    1:           mFrameConstructor->ProcessRestyledFrames(changeList);
29804:           --mChangeNestCount;
13098:         }
36817:       }
10730:       batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
    1:     }
    1:     return NS_OK;
    1:   }
    1: #endif
    1: 
    1:   if (!nsCRT::strcmp(aTopic, "agent-sheet-added") && mStyleSet) {
    1:     AddAgentSheet(aSubject);
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (!nsCRT::strcmp(aTopic, "user-sheet-added") && mStyleSet) {
    1:     AddUserSheet(aSubject);
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (!nsCRT::strcmp(aTopic, "agent-sheet-removed") && mStyleSet) {
    1:     RemoveSheet(nsStyleSet::eAgentSheet, aSubject);
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (!nsCRT::strcmp(aTopic, "user-sheet-removed") && mStyleSet) {
    1:     RemoveSheet(nsStyleSet::eUserSheet, aSubject);
    1:     return NS_OK;
    1:   }
    1: 
 1071: #ifdef ACCESSIBILITY
 1071:   if (!nsCRT::strcmp(aTopic, "a11y-init-or-shutdown")) {
 1071:     gIsAccessibilityActive = aData && *aData == '1';
 1071:   }
 1071: #endif
    1:   NS_WARNING("unrecognized topic in PresShell::Observe");
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
43799: PRBool
43799: nsIPresShell::AddRefreshObserverInternal(nsARefreshObserver* aObserver,
43799:                                          mozFlushType aFlushType)
43799: {
43799:   return GetPresContext()->RefreshDriver()->
43799:     AddRefreshObserver(aObserver, aFlushType);
43799: }
43799: 
43799: /* virtual */ PRBool
43799: nsIPresShell::AddRefreshObserverExternal(nsARefreshObserver* aObserver,
43799:                                          mozFlushType aFlushType)
43799: {
43799:   return AddRefreshObserverInternal(aObserver, aFlushType);
43799: }
43799: 
43799: PRBool
43799: nsIPresShell::RemoveRefreshObserverInternal(nsARefreshObserver* aObserver,
43799:                                             mozFlushType aFlushType)
43799: {
43799:   return GetPresContext()->RefreshDriver()->
43799:     RemoveRefreshObserver(aObserver, aFlushType);
43799: }
43799: 
43799: /* virtual */ PRBool
43799: nsIPresShell::RemoveRefreshObserverExternal(nsARefreshObserver* aObserver,
43799:                                             mozFlushType aFlushType)
43799: {
43799:   return RemoveRefreshObserverInternal(aObserver, aFlushType);
43799: }
43799: 
    1: //------------------------------------------------------
    1: // End of protected and private methods on the PresShell
    1: //------------------------------------------------------
    1: 
    1: // Start of DEBUG only code
    1: 
    1: #ifdef NS_DEBUG
    1: #include "nsViewsCID.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIURL.h"
    1: #include "nsILinkHandler.h"
    1: 
    1: static NS_DEFINE_CID(kViewManagerCID, NS_VIEW_MANAGER_CID);
    1: 
    1: static void
    1: LogVerifyMessage(nsIFrame* k1, nsIFrame* k2, const char* aMsg)
    1: {
31709:   nsAutoString n1, n2;
31709:   if (k1) {
31709:     k1->GetFrameName(n1);
31709:   } else {
31709:     n1.Assign(NS_LITERAL_STRING("(null)"));
31709:   }
31709: 
31709:   if (k2) {
31709:     k2->GetFrameName(n2);
31709:   } else {
31709:     n2.Assign(NS_LITERAL_STRING("(null)"));
31709:   }
31709: 
31709:   printf("verifyreflow: %s %p != %s %p  %s\n",
31709:          NS_LossyConvertUTF16toASCII(n1).get(), (void*)k1,
31709:          NS_LossyConvertUTF16toASCII(n2).get(), (void*)k2, aMsg);
    1: }
    1: 
    1: static void
    1: LogVerifyMessage(nsIFrame* k1, nsIFrame* k2, const char* aMsg,
    1:                  const nsRect& r1, const nsRect& r2)
    1: {
    1:   printf("VerifyReflow Error:\n");
    1:   nsAutoString name;
31709: 
31709:   if (k1) {
31709:     k1->GetFrameName(name);
31709:     printf("  %s %p ", NS_LossyConvertUTF16toASCII(name).get(), (void*)k1);
31709:   }
31709:   printf("{%d, %d, %d, %d} != \n", r1.x, r1.y, r1.width, r1.height);
31709: 
31709:   if (k2) {
31709:     k2->GetFrameName(name);
31709:     printf("  %s %p ", NS_LossyConvertUTF16toASCII(name).get(), (void*)k2);
31709:   }
31709:   printf("{%d, %d, %d, %d}\n  %s\n",
31709:          r2.x, r2.y, r2.width, r2.height, aMsg);
    1: }
    1: 
23738: static void
23738: LogVerifyMessage(nsIFrame* k1, nsIFrame* k2, const char* aMsg,
23738:                  const nsIntRect& r1, const nsIntRect& r2)
23738: {
23738:   printf("VerifyReflow Error:\n");
23738:   nsAutoString name;
31709: 
31709:   if (k1) {
31709:     k1->GetFrameName(name);
31709:     printf("  %s %p ", NS_LossyConvertUTF16toASCII(name).get(), (void*)k1);
31709:   }
31709:   printf("{%d, %d, %d, %d} != \n", r1.x, r1.y, r1.width, r1.height);
31709: 
31709:   if (k2) {
31709:     k2->GetFrameName(name);
31709:     printf("  %s %p ", NS_LossyConvertUTF16toASCII(name).get(), (void*)k2);
31709:   }
31709:   printf("{%d, %d, %d, %d}\n  %s\n",
31709:          r2.x, r2.y, r2.width, r2.height, aMsg);
23738: }
23738: 
    1: static PRBool
    1: CompareTrees(nsPresContext* aFirstPresContext, nsIFrame* aFirstFrame, 
    1:              nsPresContext* aSecondPresContext, nsIFrame* aSecondFrame)
    1: {
    1:   if (!aFirstPresContext || !aFirstFrame || !aSecondPresContext || !aSecondFrame)
    1:     return PR_TRUE;
 1735:   // XXX Evil hack to reduce false positives; I can't seem to figure
 1735:   // out how to flush scrollbar changes correctly
 1735:   //if (aFirstFrame->GetType() == nsGkAtoms::scrollbarFrame)
 1735:   //  return PR_TRUE;
    1:   PRBool ok = PR_TRUE;
    1:   nsIAtom* listName = nsnull;
    1:   PRInt32 listIndex = 0;
    1:   do {
30787:     const nsFrameList& kids1 = aFirstFrame->GetChildList(listName);
30787:     const nsFrameList& kids2 = aSecondFrame->GetChildList(listName);
30787:     PRInt32 l1 = kids1.GetLength();
30787:     PRInt32 l2 = kids2.GetLength();;
    1:     if (l1 != l2) {
    1:       ok = PR_FALSE;
30787:       LogVerifyMessage(kids1.FirstChild(), kids2.FirstChild(),
30787:                        "child counts don't match: ");
    1:       printf("%d != %d\n", l1, l2);
    1:       if (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags)) {
    1:         break;
    1:       }
    1:     }
    1: 
23738:     nsIntRect r1, r2;
    1:     nsIView* v1, *v2;
30787:     for (nsFrameList::Enumerator e1(kids1), e2(kids2);
30787:          ;
30787:          e1.Next(), e2.Next()) {
30787:       nsIFrame* k1 = e1.get();
30787:       nsIFrame* k2 = e2.get();
    1:       if (((nsnull == k1) && (nsnull != k2)) ||
    1:           ((nsnull != k1) && (nsnull == k2))) {
    1:         ok = PR_FALSE;
    1:         LogVerifyMessage(k1, k2, "child lists are different\n");
    1:         break;
    1:       }
    1:       else if (nsnull != k1) {
    1:         // Verify that the frames are the same size
    1:         if (k1->GetRect() != k2->GetRect()) {
    1:           ok = PR_FALSE;
    1:           LogVerifyMessage(k1, k2, "(frame rects)", k1->GetRect(), k2->GetRect());
    1:         }
    1: 
    1:         // Make sure either both have views or neither have views; if they
    1:         // do have views, make sure the views are the same size. If the
    1:         // views have widgets, make sure they both do or neither does. If
    1:         // they do, make sure the widgets are the same size.
    1:         v1 = k1->GetView();
    1:         v2 = k2->GetView();
    1:         if (((nsnull == v1) && (nsnull != v2)) ||
    1:             ((nsnull != v1) && (nsnull == v2))) {
    1:           ok = PR_FALSE;
    1:           LogVerifyMessage(k1, k2, "child views are not matched\n");
    1:         }
    1:         else if (nsnull != v1) {
    1:           if (v1->GetBounds() != v2->GetBounds()) {
    1:             LogVerifyMessage(k1, k2, "(view rects)", v1->GetBounds(), v2->GetBounds());
    1:           }
    1: 
    1:           nsIWidget* w1 = v1->GetWidget();
    1:           nsIWidget* w2 = v2->GetWidget();
    1:           if (((nsnull == w1) && (nsnull != w2)) ||
    1:               ((nsnull != w1) && (nsnull == w2))) {
    1:             ok = PR_FALSE;
    1:             LogVerifyMessage(k1, k2, "child widgets are not matched\n");
    1:           }
    1:           else if (nsnull != w1) {
    1:             w1->GetBounds(r1);
    1:             w2->GetBounds(r2);
    1:             if (r1 != r2) {
    1:               LogVerifyMessage(k1, k2, "(widget rects)", r1, r2);
    1:             }
    1:           }
    1:         }
    1:         if (!ok && (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags))) {
    1:           break;
    1:         }
    1: 
23300:         // XXX Should perhaps compare their float managers.
    1: 
    1:         // Compare the sub-trees too
    1:         if (!CompareTrees(aFirstPresContext, k1, aSecondPresContext, k2)) {
    1:           ok = PR_FALSE;
    1:           if (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags)) {
    1:             break;
    1:           }
    1:         }
    1:       }
    1:       else {
    1:         break;
    1:       }
    1:     }
    1:     if (!ok && (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags))) {
    1:       break;
    1:     }
    1: 
    1:     nsIAtom* listName1 = aFirstFrame->GetAdditionalChildListName(listIndex);
    1:     nsIAtom* listName2 = aSecondFrame->GetAdditionalChildListName(listIndex);
    1:     listIndex++;
    1:     if (listName1 != listName2) {
    1:       if (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags)) {
    1:         ok = PR_FALSE;
    1:       }
30787:       LogVerifyMessage(kids1.FirstChild(), kids2.FirstChild(),
30787:                        "child list names are not matched: ");
    1:       nsAutoString tmp;
    1:       if (nsnull != listName1) {
    1:         listName1->ToString(tmp);
    1:         fputs(NS_LossyConvertUTF16toASCII(tmp).get(), stdout);
    1:       }
    1:       else
    1:         fputs("(null)", stdout);
    1:       printf(" != ");
    1:       if (nsnull != listName2) {
    1:         listName2->ToString(tmp);
    1:         fputs(NS_LossyConvertUTF16toASCII(tmp).get(), stdout);
    1:       }
    1:       else
    1:         fputs("(null)", stdout);
    1:       printf("\n");
    1:       break;
    1:     }
    1:     listName = listName1;
    1:   } while (ok && (listName != nsnull));
    1: 
    1:   return ok;
    1: }
    1: #endif
    1: 
    1: #if 0
    1: static nsIFrame*
    1: FindTopFrame(nsIFrame* aRoot)
    1: {
    1:   if (aRoot) {
    1:     nsIContent* content = aRoot->GetContent();
    1:     if (content) {
    1:       nsIAtom* tag;
    1:       content->GetTag(tag);
    1:       if (nsnull != tag) {
    1:         NS_RELEASE(tag);
    1:         return aRoot;
    1:       }
    1:     }
    1: 
    1:     // Try one of the children
    1:     nsIFrame* kid = aRoot->GetFirstChild(nsnull);
    1:     while (nsnull != kid) {
    1:       nsIFrame* result = FindTopFrame(kid);
    1:       if (nsnull != result) {
    1:         return result;
    1:       }
    1:       kid = kid->GetNextSibling();
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: #endif
    1: 
    1: 
    1: #ifdef DEBUG
    1: 
    1: nsresult
    1: PresShell::CloneStyleSet(nsStyleSet* aSet, nsStyleSet** aResult)
    1: {
    1:   nsStyleSet *clone = new nsStyleSet();
    1:   if (!clone) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   PRInt32 i, n = aSet->SheetCount(nsStyleSet::eOverrideSheet);
    1:   for (i = 0; i < n; i++) {
    1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eOverrideSheet, i);
    1:     if (ss)
    1:       clone->AppendStyleSheet(nsStyleSet::eOverrideSheet, ss);
    1:   }
    1: 
 1735:   // The document expects to insert document stylesheets itself
 1735: #if 0
    1:   n = aSet->SheetCount(nsStyleSet::eDocSheet);
    1:   for (i = 0; i < n; i++) {
    1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eDocSheet, i);
    1:     if (ss)
    1:       clone->AddDocStyleSheet(ss, mDocument);
    1:   }
 1735: #endif
 1735: 
    1:   n = aSet->SheetCount(nsStyleSet::eUserSheet);
    1:   for (i = 0; i < n; i++) {
    1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eUserSheet, i);
    1:     if (ss)
    1:       clone->AppendStyleSheet(nsStyleSet::eUserSheet, ss);
    1:   }
    1: 
    1:   n = aSet->SheetCount(nsStyleSet::eAgentSheet);
    1:   for (i = 0; i < n; i++) {
    1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eAgentSheet, i);
    1:     if (ss)
    1:       clone->AppendStyleSheet(nsStyleSet::eAgentSheet, ss);
    1:   }
    1:   *aResult = clone;
    1:   return NS_OK;
    1: }
    1: 
 1735: #ifdef DEBUG_Eli
 1735: static nsresult
 1735: DumpToPNG(nsIPresShell* shell, nsAString& name) {
 1735:   PRInt32 width=1000, height=1000;
 1735:   nsRect r(0, 0, shell->GetPresContext()->DevPixelsToAppUnits(width),
 1735:                  shell->GetPresContext()->DevPixelsToAppUnits(height));
 1735: 
 1735:   nsRefPtr<gfxImageSurface> imgSurface =
 1735:      new gfxImageSurface(gfxIntSize(width, height),
 1735:                          gfxImageSurface::ImageFormatARGB32);
 1735:   NS_ENSURE_TRUE(imgSurface, NS_ERROR_OUT_OF_MEMORY);
 1735: 
 1735:   nsRefPtr<gfxContext> imgContext = new gfxContext(imgSurface);
 1735: 
 1735:   nsRefPtr<gfxASurface> surface = 
 1735:     gfxPlatform::GetPlatform()->
 1735:     CreateOffscreenSurface(gfxIntSize(width, height),
54254:       gfxASurface::ContentFromFormat(gfxASurface::ImageFormatARGB32));
 1735:   NS_ENSURE_TRUE(surface, NS_ERROR_OUT_OF_MEMORY);
 1735: 
 1735:   nsRefPtr<gfxContext> context = new gfxContext(surface);
 1735:   NS_ENSURE_TRUE(context, NS_ERROR_OUT_OF_MEMORY);
 1735: 
40052:   shell->RenderDocument(r, 0, NS_RGB(255, 255, 0), context);
 1735: 
 1735:   imgContext->DrawSurface(surface, gfxSize(width, height));
 1735: 
 1735:   nsCOMPtr<imgIEncoder> encoder = do_CreateInstance("@mozilla.org/image/encoder;2?type=image/png");
 1735:   NS_ENSURE_TRUE(encoder, NS_ERROR_FAILURE);
 1735:   encoder->InitFromData(imgSurface->Data(), imgSurface->Stride() * height,
 1735:                         width, height, imgSurface->Stride(),
 1735:                         imgIEncoder::INPUT_FORMAT_HOSTARGB, EmptyString());
 1735: 
 1735:   // XXX not sure if this is the right way to write to a file
 1735:   nsCOMPtr<nsILocalFile> file = do_CreateInstance("@mozilla.org/file/local;1");
 1735:   NS_ENSURE_TRUE(file, NS_ERROR_FAILURE);
 1735:   rv = file->InitWithPath(name);
 1735:   NS_ENSURE_SUCCESS(rv, rv);
 1735: 
 1735:   PRUint32 length;
 1735:   encoder->Available(&length);
 1735: 
 1735:   nsCOMPtr<nsIOutputStream> outputStream;
 1735:   rv = NS_NewLocalFileOutputStream(getter_AddRefs(outputStream), file);
 1735:   NS_ENSURE_SUCCESS(rv, rv);
 1735: 
 1735:   nsCOMPtr<nsIOutputStream> bufferedOutputStream;
 1735:   rv = NS_NewBufferedOutputStream(getter_AddRefs(bufferedOutputStream),
 1735:                                   outputStream, length);
 1735: 
 1735:   PRUint32 numWritten;
 1735:   rv = bufferedOutputStream->WriteFrom(encoder, length, &numWritten);
 1735:   NS_ENSURE_SUCCESS(rv, rv);
 1735: 
 1735:   return NS_OK;
 1735: }
 1735: #endif
 1735: 
    1: // After an incremental reflow, we verify the correctness by doing a
    1: // full reflow into a fresh frame tree.
    1: PRBool
    1: PresShell::VerifyIncrementalReflow()
    1: {
    1:    if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
    1:      printf("Building Verification Tree...\n");
    1:    }
    1: 
    1:   // Create a presentation context to view the new frame tree
39823:   nsRefPtr<nsPresContext> cx =
30514:        new nsRootPresContext(mDocument, mPresContext->IsPaginated() ?
    1:                                         nsPresContext::eContext_PrintPreview :
  790:                                         nsPresContext::eContext_Galley);
  790:   NS_ENSURE_TRUE(cx, PR_FALSE);
    1: 
    1:   nsIDeviceContext *dc = mPresContext->DeviceContext();
    1:   nsresult rv = cx->Init(dc);
  790:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:   // Get our scrolling preference
    1:   nsIView* rootView;
    1:   mViewManager->GetRootView(rootView);
30535:   NS_ENSURE_TRUE(rootView->HasWidget(), PR_FALSE);
51048:   nsIWidget* parentWidget = rootView->GetWidget();
    1: 
    1:   // Create a new view manager.
  790:   nsCOMPtr<nsIViewManager> vm = do_CreateInstance(kViewManagerCID);
  790:   NS_ENSURE_TRUE(vm, PR_FALSE);
    1:   rv = vm->Init(dc);
  790:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:   // Create a child window of the parent that is our "root view/window"
    1:   // Create a view
    1:   nsRect tbounds = mPresContext->GetVisibleArea();
    1:   nsIView* view = vm->CreateView(tbounds, nsnull);
  790:   NS_ENSURE_TRUE(view, PR_FALSE);
    1: 
    1:   //now create the widget for the view
51050:   rv = view->CreateWidgetForParent(parentWidget, nsnull, PR_TRUE);
  790:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:   // Setup hierarchical relationship in view manager
    1:   vm->SetRootView(view);
    1: 
    1:   // Make the new presentation context the same size as our
    1:   // presentation context.
    1:   nsRect r = mPresContext->GetVisibleArea();
    1:   cx->SetVisibleArea(r);
    1: 
    1:   // Create a new presentation shell to view the document. Use the
    1:   // exact same style information that this document has.
    1:   nsAutoPtr<nsStyleSet> newSet;
    1:   rv = CloneStyleSet(mStyleSet, getter_Transfers(newSet));
  790:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
  790:   nsCOMPtr<nsIPresShell> sh;
  790:   rv = mDocument->CreateShell(cx, vm, newSet, getter_AddRefs(sh));
  790:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
  790:   newSet.forget();
  790:   // Note that after we create the shell, we must make sure to destroy it
    1:   sh->SetVerifyReflowEnable(PR_FALSE); // turn off verify reflow while we're reflowing the test frame tree
  790:   vm->SetViewObserver((nsIViewObserver *)((PresShell*)sh.get()));
22979:   {
29804:     nsAutoCauseReflowNotifier crNotifier(this);
  790:     sh->InitialReflow(r.width, r.height);
22979:   }
  790:   mDocument->BindingManager()->ProcessAttachedQueue();
  790:   sh->FlushPendingNotifications(Flush_Layout);
    1:   sh->SetVerifyReflowEnable(PR_TRUE);  // turn on verify reflow again now that we're done reflowing the test frame tree
 1735:   // Force the non-primary presshell to unsuppress; it doesn't want to normally
 1735:   // because it thinks it's hidden
 1735:   ((PresShell*)sh.get())->mPaintingSuppressed = PR_FALSE;
    1:   if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
    1:      printf("Verification Tree built, comparing...\n");
    1:   }
    1: 
    1:   // Now that the document has been reflowed, use its frame tree to
    1:   // compare against our frame tree.
    1:   nsIFrame* root1 = FrameManager()->GetRootFrame();
    1:   nsIFrame* root2 = sh->FrameManager()->GetRootFrame();
    1:   PRBool ok = CompareTrees(mPresContext, root1, cx, root2);
    1:   if (!ok && (VERIFY_REFLOW_NOISY & gVerifyReflowFlags)) {
    1:     printf("Verify reflow failed, primary tree:\n");
31709:     root1->List(stdout, 0);
    1:     printf("Verification tree:\n");
31709:     root2->List(stdout, 0);
    1:   }
    1: 
 1735: #ifdef DEBUG_Eli
 1735:   // Sample code for dumping page to png
 1735:   // XXX Needs to be made more flexible
 1735:   if (!ok) {
 1735:     nsString stra;
 1735:     static int num = 0;
 1735:     stra.AppendLiteral("C:\\mozilla\\mozilla\\debug\\filea");
 1735:     stra.AppendInt(num);
 1735:     stra.AppendLiteral(".png");
 1735:     DumpToPNG(sh, stra);
 1735:     nsString strb;
 1735:     strb.AppendLiteral("C:\\mozilla\\mozilla\\debug\\fileb");
 1735:     strb.AppendInt(num);
 1735:     strb.AppendLiteral(".png");
 1735:     DumpToPNG(this, strb);
 1735:     ++num;
 1735:   }
 1735: #endif
 1735: 
    1:   sh->EndObservingDocument();
  790:   sh->Destroy();
    1:   if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
    1:     printf("Finished Verifying Reflow...\n");
    1:   }
    1: 
    1:   return ok;
    1: }
    1: 
    1: // Layout debugging hooks
    1: void
    1: PresShell::ListStyleContexts(nsIFrame *aRootFrame, FILE *out, PRInt32 aIndent)
    1: {
    1:   nsStyleContext *sc = aRootFrame->GetStyleContext();
    1:   if (sc)
    1:     sc->List(out, aIndent);
    1: }
    1: 
    1: void
    1: PresShell::ListStyleSheets(FILE *out, PRInt32 aIndent)
    1: {
    1:   PRInt32 sheetCount = mStyleSet->SheetCount(nsStyleSet::eDocSheet);
    1:   for (PRInt32 i = 0; i < sheetCount; ++i) {
    1:     mStyleSet->StyleSheetAt(nsStyleSet::eDocSheet, i)->List(out, aIndent);
    1:     fputs("\n", out);
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::VerifyStyleTree()
    1: {
    1:   VERIFY_STYLE_TREE;
    1: }
    1: #endif
    1: 
    1: //=============================================================
    1: //=============================================================
    1: //-- Debug Reflow Counts
    1: //=============================================================
    1: //=============================================================
    1: #ifdef MOZ_REFLOW_PERF
    1: //-------------------------------------------------------------
40052: void
    1: PresShell::DumpReflows()
    1: {
    1:   if (mReflowCountMgr) {
    1:     nsCAutoString uriStr;
    1:     if (mDocument) {
    1:       nsIURI *uri = mDocument->GetDocumentURI();
    1:       if (uri) {
    1:         uri->GetPath(uriStr);
    1:       }
    1:     }
    1:     mReflowCountMgr->DisplayTotals(uriStr.get());
    1:     mReflowCountMgr->DisplayHTMLTotals(uriStr.get());
    1:     mReflowCountMgr->DisplayDiffsInTotals("Differences");
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------
40052: void
    1: PresShell::CountReflows(const char * aName, nsIFrame * aFrame)
    1: {
    1:   if (mReflowCountMgr) {
    1:     mReflowCountMgr->Add(aName, aFrame);
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------
40052: void
40052: PresShell::PaintCount(const char * aName,
40052:                       nsIRenderingContext* aRenderingContext,
40052:                       nsPresContext* aPresContext,
40052:                       nsIFrame * aFrame,
40052:                       PRUint32 aColor)
    1: {
    1:   if (mReflowCountMgr) {
    1:     mReflowCountMgr->PaintCount(aName, aRenderingContext, aPresContext, aFrame, aColor);
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------
40052: void
    1: PresShell::SetPaintFrameCount(PRBool aPaintFrameCounts)
    1: {
    1:   if (mReflowCountMgr) {
    1:     mReflowCountMgr->SetPaintFrameCounts(aPaintFrameCounts);
    1:   }
    1: }
    1: 
30512: PRBool
30512: PresShell::IsPaintingFrameCounts()
30512: {
30512:   if (mReflowCountMgr)
30512:     return mReflowCountMgr->IsPaintingFrameCounts();
30512:   return PR_FALSE;
30512: }
30512: 
    1: //------------------------------------------------------------------
    1: //-- Reflow Counter Classes Impls
    1: //------------------------------------------------------------------
    1: 
    1: //------------------------------------------------------------------
    1: ReflowCounter::ReflowCounter(ReflowCountMgr * aMgr) :
    1:   mMgr(aMgr)
    1: {
    1:   ClearTotals();
    1:   SetTotalsCache();
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: ReflowCounter::~ReflowCounter()
    1: {
    1:   
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::ClearTotals()
    1: {
    1:   mTotal = 0;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::SetTotalsCache()
    1: {
    1:   mCacheTotal = mTotal;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::CalcDiffInTotals()
    1: {
    1:   mCacheTotal = mTotal - mCacheTotal;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::DisplayTotals(const char * aStr)
    1: {
    1:   DisplayTotals(mTotal, aStr?aStr:"Totals");
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::DisplayDiffTotals(const char * aStr)
    1: {
    1:   DisplayTotals(mCacheTotal, aStr?aStr:"Diff Totals");
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::DisplayHTMLTotals(const char * aStr)
    1: {
    1:   DisplayHTMLTotals(mTotal, aStr?aStr:"Totals");
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::DisplayTotals(PRUint32 aTotal, const char * aTitle)
    1: {
    1:   // figure total
    1:   if (aTotal == 0) {
    1:     return;
    1:   }
    1:   ReflowCounter * gTots = (ReflowCounter *)mMgr->LookUp(kGrandTotalsStr);
    1: 
    1:   printf("%25s\t", aTitle);
    1:   printf("%d\t", aTotal);
    1:   if (gTots != this && aTotal > 0) {
    1:     gTots->Add(aTotal);
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::DisplayHTMLTotals(PRUint32 aTotal, const char * aTitle)
    1: {
    1:   if (aTotal == 0) {
    1:     return;
    1:   }
    1: 
    1:   ReflowCounter * gTots = (ReflowCounter *)mMgr->LookUp(kGrandTotalsStr);
    1:   FILE * fd = mMgr->GetOutFile();
    1:   if (!fd) {
    1:     return;
    1:   }
    1: 
    1:   fprintf(fd, "<tr><td><center>%s</center></td>", aTitle);
    1:   fprintf(fd, "<td><center>%d</center></td></tr>\n", aTotal);
    1: 
    1:   if (gTots != this && aTotal > 0) {
    1:     gTots->Add(aTotal);
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: //-- ReflowCountMgr
    1: //------------------------------------------------------------------
    1: ReflowCountMgr::ReflowCountMgr()
    1: {
    1:   mCounts = PL_NewHashTable(10, PL_HashString, PL_CompareStrings, 
    1:                                 PL_CompareValues, nsnull, nsnull);
    1:   mIndiFrameCounts = PL_NewHashTable(10, PL_HashString, PL_CompareStrings, 
    1:                                      PL_CompareValues, nsnull, nsnull);
    1:   mCycledOnce              = PR_FALSE;
    1:   mDumpFrameCounts         = PR_FALSE;
    1:   mDumpFrameByFrameCounts  = PR_FALSE;
    1:   mPaintFrameByFrameCounts = PR_FALSE;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: ReflowCountMgr::~ReflowCountMgr()
    1: {
    1:   CleanUp();
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: ReflowCounter * ReflowCountMgr::LookUp(const char * aName)
    1: {
    1:   if (nsnull != mCounts) {
    1:     ReflowCounter * counter = (ReflowCounter *)PL_HashTableLookup(mCounts, aName);
    1:     return counter;
    1:   }
    1:   return nsnull;
    1: 
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::Add(const char * aName, nsIFrame * aFrame)
    1: {
    1:   NS_ASSERTION(aName != nsnull, "Name shouldn't be null!");
    1: 
    1:   if (mDumpFrameCounts && nsnull != mCounts) {
    1:     ReflowCounter * counter = (ReflowCounter *)PL_HashTableLookup(mCounts, aName);
    1:     if (counter == nsnull) {
    1:       counter = new ReflowCounter(this);
    1:       NS_ASSERTION(counter != nsnull, "null ptr");
    1:       char * name = NS_strdup(aName);
    1:       NS_ASSERTION(name != nsnull, "null ptr");
    1:       PL_HashTableAdd(mCounts, name, counter);
    1:     }
    1:     counter->Add();
    1:   }
    1: 
    1:   if ((mDumpFrameByFrameCounts || mPaintFrameByFrameCounts) && 
    1:       nsnull != mIndiFrameCounts && 
    1:       aFrame != nsnull) {
    1:     char * key = new char[16];
    1:     sprintf(key, "%p", (void*)aFrame);
    1:     IndiReflowCounter * counter = (IndiReflowCounter *)PL_HashTableLookup(mIndiFrameCounts, key);
    1:     if (counter == nsnull) {
    1:       counter = new IndiReflowCounter(this);
    1:       NS_ASSERTION(counter != nsnull, "null ptr");
    1:       counter->mFrame = aFrame;
    1:       counter->mName.AssignASCII(aName);
    1:       PL_HashTableAdd(mIndiFrameCounts, key, counter);
    1:     }
    1:     // this eliminates extra counts from super classes
    1:     if (counter != nsnull && counter->mName.EqualsASCII(aName)) {
    1:       counter->mCount++;
    1:       counter->mCounter.Add(1);
    1:     }
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::PaintCount(const char *    aName, 
    1:                                 nsIRenderingContext* aRenderingContext, 
    1:                                 nsPresContext* aPresContext, 
    1:                                 nsIFrame*       aFrame, 
    1:                                 PRUint32        aColor)
    1: {
    1:   if (mPaintFrameByFrameCounts && 
    1:       nsnull != mIndiFrameCounts && 
    1:       aFrame != nsnull) {
    1:     char * key = new char[16];
    1:     sprintf(key, "%p", (void*)aFrame);
    1:     IndiReflowCounter * counter = (IndiReflowCounter *)PL_HashTableLookup(mIndiFrameCounts, key);
    1:     if (counter != nsnull && counter->mName.EqualsASCII(aName)) {
    1:       aRenderingContext->PushState();
    1:       nsFont font("Times", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
24408:                   NS_FONT_WEIGHT_NORMAL, NS_FONT_STRETCH_NORMAL, 0,
    1:                   nsPresContext::CSSPixelsToAppUnits(11));
    1: 
    1:       nsCOMPtr<nsIFontMetrics> fm = aPresContext->GetMetricsFor(font);
    1:       aRenderingContext->SetFont(fm);
    1:       char buf[16];
    1:       sprintf(buf, "%d", counter->mCount);
    1:       nscoord x = 0, y;
    1:       nscoord width, height;
    1:       aRenderingContext->SetTextRunRTL(PR_FALSE);
    1:       aRenderingContext->GetWidth((char*)buf, width);
    1:       fm->GetHeight(height);
    1:       fm->GetMaxAscent(y);
    1: 
    1:       PRUint32 color;
    1:       PRUint32 color2;
    1:       if (aColor != 0) {
    1:         color  = aColor;
    1:         color2 = NS_RGB(0,0,0);
    1:       } else {
    1:         PRUint8 rc = 0, gc = 0, bc = 0;
    1:         if (counter->mCount < 5) {
    1:           rc = 255;
    1:           gc = 255;
    1:         } else if ( counter->mCount < 11) {
    1:           gc = 255;
    1:         } else {
    1:           rc = 255;
    1:         }
    1:         color  = NS_RGB(rc,gc,bc);
    1:         color2 = NS_RGB(rc/2,gc/2,bc/2);
    1:       }
    1: 
    1:       nsRect rect(0,0, width+15, height+15);
    1:       aRenderingContext->SetColor(NS_RGB(0,0,0));
    1:       aRenderingContext->FillRect(rect);
    1:       aRenderingContext->SetColor(color2);
    1:       aRenderingContext->DrawString(buf, strlen(buf), x+15,y+15);
    1:       aRenderingContext->SetColor(color);
    1:       aRenderingContext->DrawString(buf, strlen(buf), x,y);
    1: 
    1:       aRenderingContext->PopState();
    1:     }
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::RemoveItems(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   char *str = (char *)he->key;
    1:   ReflowCounter * counter = (ReflowCounter *)he->value;
    1:   delete counter;
    1:   NS_Free(str);
    1: 
    1:   return HT_ENUMERATE_REMOVE;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::RemoveIndiItems(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   char *str = (char *)he->key;
    1:   IndiReflowCounter * counter = (IndiReflowCounter *)he->value;
    1:   delete counter;
    1:   NS_Free(str);
    1: 
    1:   return HT_ENUMERATE_REMOVE;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::CleanUp()
    1: {
    1:   if (nsnull != mCounts) {
    1:     PL_HashTableEnumerateEntries(mCounts, RemoveItems, nsnull);
    1:     PL_HashTableDestroy(mCounts);
    1:     mCounts = nsnull;
    1:   }
    1: 
    1:   if (nsnull != mIndiFrameCounts) {
    1:     PL_HashTableEnumerateEntries(mIndiFrameCounts, RemoveIndiItems, nsnull);
    1:     PL_HashTableDestroy(mIndiFrameCounts);
    1:     mIndiFrameCounts = nsnull;
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::DoSingleTotal(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   char *str = (char *)he->key;
    1:   ReflowCounter * counter = (ReflowCounter *)he->value;
    1: 
    1:   counter->DisplayTotals(str);
    1: 
    1:   return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::DoGrandTotals()
    1: {
    1:   if (nsnull != mCounts) {
    1:     ReflowCounter * gTots = (ReflowCounter *)PL_HashTableLookup(mCounts, kGrandTotalsStr);
    1:     if (gTots == nsnull) {
    1:       gTots = new ReflowCounter(this);
    1:       PL_HashTableAdd(mCounts, NS_strdup(kGrandTotalsStr), gTots);
    1:     } else {
    1:       gTots->ClearTotals();
    1:     }
    1: 
    1:     printf("\t\t\t\tTotal\n");
    1:     for (PRUint32 i=0;i<78;i++) {
    1:       printf("-");
    1:     }
    1:     printf("\n");
    1:     PL_HashTableEnumerateEntries(mCounts, DoSingleTotal, this);
    1:   }
    1: }
    1: 
    1: static void RecurseIndiTotals(nsPresContext* aPresContext, 
    1:                               PLHashTable *   aHT, 
    1:                               nsIFrame *      aParentFrame,
    1:                               PRInt32         aLevel)
    1: {
    1:   if (aParentFrame == nsnull) {
    1:     return;
    1:   }
    1: 
    1:   char key[16];
    1:   sprintf(key, "%p", (void*)aParentFrame);
    1:   IndiReflowCounter * counter = (IndiReflowCounter *)PL_HashTableLookup(aHT, key);
    1:   if (counter) {
    1:     counter->mHasBeenOutput = PR_TRUE;
    1:     char * name = ToNewCString(counter->mName);
    1:     for (PRInt32 i=0;i<aLevel;i++) printf(" ");
    1:     printf("%s - %p   [%d][", name, (void*)aParentFrame, counter->mCount);
    1:     printf("%d", counter->mCounter.GetTotal());
    1:     printf("]\n");
    1:     nsMemory::Free(name);
    1:   }
    1: 
    1:   nsIFrame* child = aParentFrame->GetFirstChild(nsnull);
    1:   while (child) {
    1:     RecurseIndiTotals(aPresContext, aHT, child, aLevel+1);
    1:     child = child->GetNextSibling();
    1:   }
    1: 
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::DoSingleIndi(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   IndiReflowCounter * counter = (IndiReflowCounter *)he->value;
    1:   if (counter && !counter->mHasBeenOutput) {
    1:     char * name = ToNewCString(counter->mName);
    1:     printf("%s - %p   [%d][", name, (void*)counter->mFrame, counter->mCount);
    1:     printf("%d", counter->mCounter.GetTotal());
    1:     printf("]\n");
    1:     nsMemory::Free(name);
    1:   }
    1:   return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::DoIndiTotalsTree()
    1: {
    1:   if (nsnull != mCounts) {
    1:     printf("\n------------------------------------------------\n");
    1:     printf("-- Individual Frame Counts\n");
    1:     printf("------------------------------------------------\n");
    1: 
    1:     if (mPresShell) {
    1:       nsIFrame * rootFrame = mPresShell->FrameManager()->GetRootFrame();
    1:       RecurseIndiTotals(mPresContext, mIndiFrameCounts, rootFrame, 0);
    1:       printf("------------------------------------------------\n");
    1:       printf("-- Individual Counts of Frames not in Root Tree\n");
    1:       printf("------------------------------------------------\n");
    1:       PL_HashTableEnumerateEntries(mIndiFrameCounts, DoSingleIndi, this);
    1:     }
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::DoSingleHTMLTotal(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   char *str = (char *)he->key;
    1:   ReflowCounter * counter = (ReflowCounter *)he->value;
    1: 
    1:   counter->DisplayHTMLTotals(str);
    1: 
    1:   return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::DoGrandHTMLTotals()
    1: {
    1:   if (nsnull != mCounts) {
    1:     ReflowCounter * gTots = (ReflowCounter *)PL_HashTableLookup(mCounts, kGrandTotalsStr);
    1:     if (gTots == nsnull) {
    1:       gTots = new ReflowCounter(this);
    1:       PL_HashTableAdd(mCounts, NS_strdup(kGrandTotalsStr), gTots);
    1:     } else {
    1:       gTots->ClearTotals();
    1:     }
    1: 
    1:     static const char * title[] = {"Class", "Reflows"};
    1:     fprintf(mFD, "<tr>");
    1:     for (PRUint32 i=0; i < NS_ARRAY_LENGTH(title); i++) {
    1:       fprintf(mFD, "<td><center><b>%s<b></center></td>", title[i]);
    1:     }
    1:     fprintf(mFD, "</tr>\n");
    1:     PL_HashTableEnumerateEntries(mCounts, DoSingleHTMLTotal, this);
    1:   }
    1: }
    1: 
    1: //------------------------------------
    1: void ReflowCountMgr::DisplayTotals(const char * aStr)
    1: {
    1: #ifdef DEBUG_rods
    1:   printf("%s\n", aStr?aStr:"No name");
    1: #endif
    1:   if (mDumpFrameCounts) {
    1:     DoGrandTotals();
    1:   }
    1:   if (mDumpFrameByFrameCounts) {
    1:     DoIndiTotalsTree();
    1:   }
    1: 
    1: }
    1: //------------------------------------
    1: void ReflowCountMgr::DisplayHTMLTotals(const char * aStr)
    1: {
    1: #ifdef WIN32x // XXX NOT XP!
    1:   char name[1024];
    1:   
    1:   char * sptr = strrchr(aStr, '/');
    1:   if (sptr) {
    1:     sptr++;
    1:     strcpy(name, sptr);
    1:     char * eptr = strrchr(name, '.');
    1:     if (eptr) {
    1:       *eptr = 0;
    1:     }
    1:     strcat(name, "_stats.html");
    1:   }
    1:   mFD = fopen(name, "w");
    1:   if (mFD) {
    1:     fprintf(mFD, "<html><head><title>Reflow Stats</title></head><body>\n");
    1:     const char * title = aStr?aStr:"No name";
    1:     fprintf(mFD, "<center><b>%s</b><br><table border=1 style=\"background-color:#e0e0e0\">", title);
    1:     DoGrandHTMLTotals();
    1:     fprintf(mFD, "</center></table>\n");
    1:     fprintf(mFD, "</body></html>\n");
    1:     fclose(mFD);
    1:     mFD = nsnull;
    1:   }
    1: #endif // not XP!
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::DoClearTotals(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   ReflowCounter * counter = (ReflowCounter *)he->value;
    1:   counter->ClearTotals();
    1: 
    1:   return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::ClearTotals()
    1: {
    1:   PL_HashTableEnumerateEntries(mCounts, DoClearTotals, this);
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::ClearGrandTotals()
    1: {
    1:   if (nsnull != mCounts) {
    1:     ReflowCounter * gTots = (ReflowCounter *)PL_HashTableLookup(mCounts, kGrandTotalsStr);
    1:     if (gTots == nsnull) {
    1:       gTots = new ReflowCounter(this);
    1:       PL_HashTableAdd(mCounts, NS_strdup(kGrandTotalsStr), gTots);
    1:     } else {
    1:       gTots->ClearTotals();
    1:       gTots->SetTotalsCache();
    1:     }
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::DoDisplayDiffTotals(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   PRBool cycledOnce = (arg != 0);
    1: 
    1:   char *str = (char *)he->key;
    1:   ReflowCounter * counter = (ReflowCounter *)he->value;
    1: 
    1:   if (cycledOnce) {
    1:     counter->CalcDiffInTotals();
    1:     counter->DisplayDiffTotals(str);
    1:   }
    1:   counter->SetTotalsCache();
    1: 
    1:   return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::DisplayDiffsInTotals(const char * aStr)
    1: {
    1:   if (mCycledOnce) {
    1:     printf("Differences\n");
    1:     for (PRInt32 i=0;i<78;i++) {
    1:       printf("-");
    1:     }
    1:     printf("\n");
    1:     ClearGrandTotals();
    1:   }
    1:   PL_HashTableEnumerateEntries(mCounts, DoDisplayDiffTotals, (void *)mCycledOnce);
    1: 
    1:   mCycledOnce = PR_TRUE;
    1: }
    1: 
    1: #endif // MOZ_REFLOW_PERF
    1: 
    1: // make a color string like #RRGGBB
    1: void ColorToString(nscolor aColor, nsAutoString &aString)
    1: {
    1:   char buf[8];
    1: 
    1:   PR_snprintf(buf, sizeof(buf), "#%02x%02x%02x",
    1:               NS_GET_R(aColor), NS_GET_G(aColor), NS_GET_B(aColor));
    1:   CopyASCIItoUTF16(buf, aString);
    1: }
10522: 
10522: nsIFrame* nsIPresShell::GetAbsoluteContainingBlock(nsIFrame *aFrame)
10522: {
10522:   return FrameConstructor()->GetAbsoluteContainingBlock(aFrame);
10522: }
42982: 
42982: void nsIPresShell::InitializeStatics()
42982: {
42982:   NS_ASSERTION(sLiveShells == nsnull, "InitializeStatics called multiple times!");
42982:   sLiveShells = new nsTHashtable<PresShellPtrKey>();
42982:   sLiveShells->Init();
42982: }
42982: 
42982: void nsIPresShell::ReleaseStatics()
42982: {
42982:   NS_ASSERTION(sLiveShells, "ReleaseStatics called without Initialize!");
42982:   delete sLiveShells;
42982:   sLiveShells = nsnull;
42982: }
48937: 
48937: // Asks our docshell whether we're active.
48937: void PresShell::QueryIsActive()
48937: {
48937:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
57282:   if (mDocument) {
57282:     nsIDocument* displayDoc = mDocument->GetDisplayDocument();
57282:     if (displayDoc) {
57282:       // Ok, we're an external resource document -- we need to use our display
57282:       // document's docshell to determine "IsActive" status, since we lack
57282:       // a container.
57282:       NS_ABORT_IF_FALSE(!container,
57282:                         "external resource doc shouldn't have "
57282:                         "its own container");
57282: 
57282:       nsIPresShell* displayPresShell = displayDoc->GetShell();
57282:       if (displayPresShell) {
57282:         container = displayPresShell->GetPresContext()->GetContainer();
57282:       }
57282:     }
57282:   }
57282: 
48937:   nsCOMPtr<nsIDocShell> docshell(do_QueryInterface(container));
48937:   if (docshell) {
48937:     PRBool isActive;
48937:     nsresult rv = docshell->GetIsActive(&isActive);
48937:     if (NS_SUCCEEDED(rv))
48937:       SetIsActive(isActive);
48937:   }
48937: }
50815: 
57282: // Helper for propagating mIsActive changes to external resources
57282: static PRBool
57282: SetExternalResourceIsActive(nsIDocument* aDocument, void* aClosure)
57282: {
57282:   nsIPresShell* shell = aDocument->GetShell();
57282:   if (shell) {
57282:     shell->SetIsActive(*static_cast<PRBool*>(aClosure));
57282:   }
57282:   return PR_TRUE;
57282: }
57282: 
50815: nsresult
50815: PresShell::SetIsActive(PRBool aIsActive)
50815: {
58966:   NS_PRECONDITION(mDocument, "should only be called with a document");
58966: 
50815:   mIsActive = aIsActive;
51546:   nsPresContext* presContext = GetPresContext();
51546:   if (presContext &&
51546:       presContext->RefreshDriver()->PresContext() == presContext) {
51546:     presContext->RefreshDriver()->SetThrottled(!mIsActive);
51546:   }
57282: 
57282:   // Propagate state-change to my resource documents' PresShells
57282:   mDocument->EnumerateExternalResources(SetExternalResourceIsActive,
57282:                                         &aIsActive);
50815:   return UpdateImageLockingState();
50815: }
50815: 
50815: /*
50815:  * Determines the current image locking state. Called when one of the
50815:  * dependent factors changes.
50815:  */
50815: nsresult
50815: PresShell::UpdateImageLockingState()
50815: {
50815:   // We're locked if we're both thawed and active.
50815:   return mDocument->SetImageLockingState(!mFrozen && mIsActive);
50815: }
