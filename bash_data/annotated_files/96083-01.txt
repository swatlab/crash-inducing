    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #ifndef nsIContent_h___
    1: #define nsIContent_h___
    1: 
    1: #include "nsCOMPtr.h" // for already_AddRefed
    1: #include "nsStringGlue.h"
    1: #include "nsCaseTreatment.h"
    1: #include "nsChangeHint.h"
    1: #include "nsINode.h"
29004: #include "nsIDocument.h" // for IsInHTMLDocument
    1: 
    1: // Forward declarations
    1: class nsIAtom;
    1: class nsIDOMEvent;
    1: class nsIContent;
72328: class nsEventListenerManager;
    1: class nsIURI;
    1: class nsRuleWalker;
    1: class nsAttrValue;
    1: class nsAttrName;
    1: class nsTextFragment;
    1: class nsIDocShell;
36652: class nsIFrame;
23697: class nsISMILAttr;
32193: class nsIDOMCSSStyleDeclaration;
    1: 
63693: namespace mozilla {
63693: namespace css {
63693: class StyleRule;
82843: } // namespace css
82843: namespace widget {
82843: struct IMEState;
82843: } // namespace widget
82843: } // namespace mozilla
63693: 
30307: enum nsLinkState {
30307:   eLinkState_Unknown    = 0,
30307:   eLinkState_Unvisited  = 1,
30307:   eLinkState_Visited    = 2,
30307:   eLinkState_NotLink    = 3
30307: };
30307: 
    1: // IID for the nsIContent interface
    1: #define NS_ICONTENT_IID \
95454: { 0xa887c108, 0xc25e, 0x42ab, \
95454:   { 0x87, 0xef, 0xad, 0x4b, 0xee, 0x50, 0x28, 0x28 } }
    1: 
    1: /**
    1:  * A node of content in a document's content model. This interface
    1:  * is supported by all content objects.
    1:  */
 9807: class nsIContent : public nsINode {
    1: public:
82843:   typedef mozilla::widget::IMEState IMEState;
82843: 
    1: #ifdef MOZILLA_INTERNAL_API
    1:   // If you're using the external API, the only thing you can know about
    1:   // nsIContent is that it exists with an IID
    1: 
94340:   nsIContent(already_AddRefed<nsINodeInfo> aNodeInfo)
96083:     : nsINode(aNodeInfo),
96083:       mPrimaryFrame(nsnull)
    1:   {
48124:     NS_ASSERTION(mNodeInfo,
94340:                  "No nsINodeInfo passed to nsIContent, PREPARE TO CRASH!!!");
    1:   }
    1: #endif // MOZILLA_INTERNAL_API
    1: 
 9807:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICONTENT_IID)
 9807: 
    1:   /**
    1:    * Bind this content node to a tree.  If this method throws, the caller must
    1:    * call UnbindFromTree() on the node.  In the typical case of a node being
    1:    * appended to a parent, this will be called after the node has been added to
    1:    * the parent's child list and before nsIDocumentObserver notifications for
    1:    * the addition are dispatched.
    1:    * @param aDocument The new document for the content node.  Must match the
    1:    *                  current document of aParent, if aParent is not null.
    1:    *                  May not be null if aParent is null.
    1:    * @param aParent The new parent for the content node.  May be null if the
    1:    *                node is being bound as a direct child of the document.
    1:    * @param aBindingParent The new binding parent for the content node.
93758:    *                       This is must either be non-null if a particular
93758:    *                       binding parent is desired or match aParent's binding
93758:    *                       parent.
    1:    * @param aCompileEventHandlers whether to initialize the event handlers in
    1:    *        the document (used by nsXULElement)
    1:    * @note either aDocument or aParent must be non-null.  If both are null,
    1:    *       this method _will_ crash.
    1:    * @note This method must not be called by consumers of nsIContent on a node
    1:    *       that is already bound to a tree.  Call UnbindFromTree first.
    1:    * @note This method will handle rebinding descendants appropriately (eg
    1:    *       changing their binding parent as needed).
    1:    * @note This method does not add the content node to aParent's child list
    1:    * @throws NS_ERROR_OUT_OF_MEMORY if that happens
    1:    */
    1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
79445:                               bool aCompileEventHandlers) = 0;
    1: 
    1:   /**
    1:    * Unbind this content node from a tree.  This will set its current document
    1:    * and binding parent to null.  In the typical case of a node being removed
    1:    * from a parent, this will be called after it has been removed from the
    1:    * parent's child list and after the nsIDocumentObserver notifications for
    1:    * the removal have been dispatched.   
    1:    * @param aDeep Whether to recursively unbind the entire subtree rooted at
80486:    *        this node.  The only time false should be passed is when the
    1:    *        parent node of the content is being destroyed.
    1:    * @param aNullParent Whether to null out the parent pointer as well.  This
    1:    *        is usually desirable.  This argument should only be false while
    1:    *        recursively calling UnbindFromTree when a subtree is detached.
    1:    * @note This method is safe to call on nodes that are not bound to a tree.
    1:    */
79445:   virtual void UnbindFromTree(bool aDeep = true,
79445:                               bool aNullParent = true) = 0;
    1:   
    1:   /**
    1:    * DEPRECATED - Use GetCurrentDoc or GetOwnerDoc.
    1:    * Get the document for this content.
    1:    * @return the document
    1:    */
    1:   nsIDocument *GetDocument() const
    1:   {
    1:     return GetCurrentDoc();
    1:   }
    1: 
38069:   enum {
38069:     /**
38357:      * All XBL flattened tree children of the node, as well as :before and
38357:      * :after anonymous content and native anonymous children.
38069:      *
38069:      * @note the result children order is
38357:      *   1. :before generated node
38357:      *   2. XBL flattened tree children of this node
38357:      *   3. native anonymous nodes
38357:      *   4. :after generated node
38069:      */
38069:     eAllChildren = 0,
38069: 
38069:     /**
38357:      * All XBL explicit children of the node (see
38357:      * http://www.w3.org/TR/xbl/#explicit3 ), as well as :before and :after
38357:      * anonymous content and native anonymous children.
38357:      *
38357:      * @note the result children order is
38357:      *   1. :before generated node
38357:      *   2. XBL explicit children of the node
38357:      *   3. native anonymous nodes
38357:      *   4. :after generated node
38069:      */
55877:     eAllButXBL = 1,
55877: 
55877:     /**
55877:      * Skip native anonymous content created for placeholder of HTML input,
55877:      * used in conjunction with eAllChildren or eAllButXBL.
55877:      */
55877:     eSkipPlaceholderContent = 2
38069:   };
38069: 
38069:   /**
38357:    * Return either the XBL explicit children of the node or the XBL flattened
55877:    * tree children of the node, depending on the filter, as well as
38357:    * native anonymous children.
38357:    *
38357:    * @note calling this method with eAllButXBL will return children that are
38357:    *  also in the eAllButXBL and eAllChildren child lists of other descendants
38357:    *  of this node in the tree, but those other nodes cannot be reached from the
38357:    *  eAllButXBL child list.
38069:    */
55877:   virtual already_AddRefed<nsINodeList> GetChildren(PRUint32 aFilter) = 0;
38069: 
    1:   /**
    1:    * Get whether this content is C++-generated anonymous content
    1:    * @see nsIAnonymousContentCreator
    1:    * @return whether this content is anonymous
    1:    */
79445:   bool IsRootOfNativeAnonymousSubtree() const
    1:   {
25511:     NS_ASSERTION(!HasFlag(NODE_IS_NATIVE_ANONYMOUS_ROOT) ||
25511:                  (HasFlag(NODE_IS_ANONYMOUS) &&
25511:                   HasFlag(NODE_IS_IN_ANONYMOUS_SUBTREE)),
25511:                  "Some flags seem to be missing!");
25511:     return HasFlag(NODE_IS_NATIVE_ANONYMOUS_ROOT);
    1:   }
    1: 
    1:   /**
 9807:    * Makes this content anonymous
 9807:    * @see nsIAnonymousContentCreator
    1:    */
 9807:   void SetNativeAnonymous()
    1:   {
25511:     SetFlags(NODE_IS_ANONYMOUS | NODE_IS_IN_ANONYMOUS_SUBTREE |
25511:              NODE_IS_NATIVE_ANONYMOUS_ROOT);
    1:   }
    1: 
    1:   /**
12250:    * Returns |this| if it is not native anonymous, otherwise
12250:    * first non native anonymous ancestor.
12250:    */
12250:   virtual nsIContent* FindFirstNonNativeAnonymous() const;
12250: 
12250:   /**
16126:    * Returns true if and only if this node has a parent, but is not in
16126:    * its parent's child list.
16126:    */
79445:   bool IsRootOfAnonymousSubtree() const
16126:   {
16126:     NS_ASSERTION(!IsRootOfNativeAnonymousSubtree() ||
16126:                  (GetParent() && GetBindingParent() == GetParent()),
16126:                  "root of native anonymous subtree must have parent equal "
16126:                  "to binding parent");
25511:     NS_ASSERTION(!GetParent() ||
25511:                  ((GetBindingParent() == GetParent()) ==
47655:                   HasFlag(NODE_IS_ANONYMOUS)) ||
47655:                  // Unfortunately default content for XBL insertion points is
47655:                  // anonymous content that is bound with the parent of the
47655:                  // insertion point as the parent but the bound element for the
47655:                  // binding as the binding parent.  So we have to complicate
47655:                  // the assert a bit here.
47655:                  (GetBindingParent() &&
47655:                   (GetBindingParent() == GetParent()->GetBindingParent()) ==
25511:                   HasFlag(NODE_IS_ANONYMOUS)),
25511:                  "For nodes with parent, flag and GetBindingParent() check "
25511:                  "should match");
25511:     return HasFlag(NODE_IS_ANONYMOUS);
16126:   }
16126: 
16126:   /**
23995:    * Returns true if there is NOT a path through child lists
23995:    * from the top of this node's parent chain back to this node or
23995:    * if the node is in native anonymous subtree without a parent.
16126:    */
79445:   bool IsInAnonymousSubtree() const
16126:   {
23995:     NS_ASSERTION(!IsInNativeAnonymousSubtree() || GetBindingParent() || !GetParent(),
23995:                  "must have binding parent when in native anonymous subtree with a parent node");
23995:     return IsInNativeAnonymousSubtree() || GetBindingParent() != nsnull;
16126:   }
16126: 
16126:   /**
29004:    * Return true iff this node is in an HTML document (in the HTML5 sense of
29004:    * the term, i.e. not in an XHTML/XML document).
29004:    */
79445:   inline bool IsInHTMLDocument() const
29004:   {
80527:     return OwnerDoc()->IsHTML();
29004:   }
29004: 
29004:   /**
    1:    * Get the namespace that this element's tag is defined in
    1:    * @return the namespace
    1:    */
    1:   PRInt32 GetNameSpaceID() const
    1:   {
    1:     return mNodeInfo->NamespaceID();
    1:   }
    1: 
    1:   /**
    1:    * Get the tag for this element. This will always return a non-null
    1:    * atom pointer (as implied by the naming of the method).
    1:    */
    1:   nsIAtom *Tag() const
    1:   {
    1:     return mNodeInfo->NameAtom();
    1:   }
    1: 
    1:   /**
    1:    * Get the NodeInfo for this element
    1:    * @return the nodes node info
    1:    */
94340:   nsINodeInfo *NodeInfo() const
    1:   {
    1:     return mNodeInfo;
    1:   }
    1: 
79445:   inline bool IsInNamespace(PRInt32 aNamespace) const {
33329:     return mNodeInfo->NamespaceID() == aNamespace;
33329:   }
33329: 
79445:   inline bool IsHTML() const {
33329:     return IsInNamespace(kNameSpaceID_XHTML);
33329:   }
33329: 
79445:   inline bool IsHTML(nsIAtom* aTag) const {
53993:     return mNodeInfo->Equals(aTag, kNameSpaceID_XHTML);
53993:   }
53993: 
79445:   inline bool IsSVG() const {
84223:     return IsInNamespace(kNameSpaceID_SVG);
33329:   }
33329: 
84637:   inline bool IsSVG(nsIAtom* aTag) const {
84637:     return mNodeInfo->Equals(aTag, kNameSpaceID_SVG);
84637:   }
84637: 
79445:   inline bool IsXUL() const {
33329:     return IsInNamespace(kNameSpaceID_XUL);
33329:   }
33329: 
79445:   inline bool IsMathML() const {
33329:     return IsInNamespace(kNameSpaceID_MathML);
33329:   }
33329: 
84637:   inline bool IsMathML(nsIAtom* aTag) const {
84637:     return mNodeInfo->Equals(aTag, kNameSpaceID_MathML);
84637:   }
84637: 
    1:   /**
    1:    * Returns an atom holding the name of the attribute of type ID on
 4036:    * this content node (if applicable).  Returns null for non-element
 4036:    * content nodes.
    1:    */
 4036:   virtual nsIAtom *GetIDAttributeName() const = 0;
    1: 
    1:   /**
    1:    * Normalizes an attribute name and returns it as a nodeinfo if an attribute
    1:    * with that name exists. This method is intended for character case
    1:    * conversion if the content object is case insensitive (e.g. HTML). Returns
    1:    * the nodeinfo of the attribute with the specified name if one exists or
    1:    * null otherwise.
    1:    *
    1:    * @param aStr the unparsed attribute string
    1:    * @return the node info. May be nsnull.
    1:    */
94340:   virtual already_AddRefed<nsINodeInfo> GetExistingAttrNameFromQName(const nsAString& aStr) const = 0;
    1: 
    1:   /**
    1:    * Set attribute values. All attribute values are assumed to have a
    1:    * canonical string representation that can be used for these
    1:    * methods. The SetAttr method is assumed to perform a translation
    1:    * of the canonical form into the underlying content specific
    1:    * form.
    1:    *
    1:    * @param aNameSpaceID the namespace of the attribute
    1:    * @param aName the name of the attribute
    1:    * @param aValue the value to set
    1:    * @param aNotify specifies how whether or not the document should be
    1:    *        notified of the attribute change.
    1:    */
    1:   nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
79445:                    const nsAString& aValue, bool aNotify)
    1:   {
    1:     return SetAttr(aNameSpaceID, aName, nsnull, aValue, aNotify);
    1:   }
    1: 
    1:   /**
    1:    * Set attribute values. All attribute values are assumed to have a
    1:    * canonical String representation that can be used for these
    1:    * methods. The SetAttr method is assumed to perform a translation
    1:    * of the canonical form into the underlying content specific
    1:    * form.
    1:    *
    1:    * @param aNameSpaceID the namespace of the attribute
    1:    * @param aName the name of the attribute
    1:    * @param aPrefix the prefix of the attribute
    1:    * @param aValue the value to set
    1:    * @param aNotify specifies how whether or not the document should be
    1:    *        notified of the attribute change.
    1:    */
    1:   virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                            nsIAtom* aPrefix, const nsAString& aValue,
79445:                            bool aNotify) = 0;
    1: 
    1:   /**
    1:    * Get the current value of the attribute. This returns a form that is
    1:    * suitable for passing back into SetAttr.
    1:    *
    1:    * @param aNameSpaceID the namespace of the attr
    1:    * @param aName the name of the attr
    1:    * @param aResult the value (may legitimately be the empty string) [OUT]
80486:    * @returns true if the attribute was set (even when set to empty string)
80486:    *          false when not set.
    1:    */
79445:   virtual bool GetAttr(PRInt32 aNameSpaceID, nsIAtom* aName, 
    1:                          nsAString& aResult) const = 0;
    1: 
    1:   /**
    1:    * Determine if an attribute has been set (empty string or otherwise).
    1:    *
    1:    * @param aNameSpaceId the namespace id of the attribute
    1:    * @param aAttr the attribute name
    1:    * @return whether an attribute exists
    1:    */
79445:   virtual bool HasAttr(PRInt32 aNameSpaceID, nsIAtom* aName) const = 0;
    1: 
    1:   /**
    1:    * Test whether this content node's given attribute has the given value.  If
    1:    * the attribute is not set at all, this will return false.
    1:    *
    1:    * @param aNameSpaceID The namespace ID of the attribute.  Must not
    1:    *                     be kNameSpaceID_Unknown.
    1:    * @param aName The name atom of the attribute.  Must not be null.
    1:    * @param aValue The value to compare to.
    1:    * @param aCaseSensitive Whether to do a case-sensitive compare on the value.
    1:    */
79445:   virtual bool AttrValueIs(PRInt32 aNameSpaceID,
    1:                              nsIAtom* aName,
    1:                              const nsAString& aValue,
    1:                              nsCaseTreatment aCaseSensitive) const
    1:   {
80486:     return false;
    1:   }
    1:   
    1:   /**
    1:    * Test whether this content node's given attribute has the given value.  If
    1:    * the attribute is not set at all, this will return false.
    1:    *
    1:    * @param aNameSpaceID The namespace ID of the attribute.  Must not
    1:    *                     be kNameSpaceID_Unknown.
    1:    * @param aName The name atom of the attribute.  Must not be null.
    1:    * @param aValue The value to compare to.  Must not be null.
    1:    * @param aCaseSensitive Whether to do a case-sensitive compare on the value.
    1:    */
79445:   virtual bool AttrValueIs(PRInt32 aNameSpaceID,
    1:                              nsIAtom* aName,
    1:                              nsIAtom* aValue,
    1:                              nsCaseTreatment aCaseSensitive) const
    1:   {
80486:     return false;
    1:   }
    1:   
    1:   enum {
    1:     ATTR_MISSING = -1,
    1:     ATTR_VALUE_NO_MATCH = -2
    1:   };
    1:   /**
    1:    * Check whether this content node's given attribute has one of a given
    1:    * list of values. If there is a match, we return the index in the list
    1:    * of the first matching value. If there was no attribute at all, then
    1:    * we return ATTR_MISSING. If there was an attribute but it didn't
    1:    * match, we return ATTR_VALUE_NO_MATCH. A non-negative result always
    1:    * indicates a match.
    1:    * 
    1:    * @param aNameSpaceID The namespace ID of the attribute.  Must not
    1:    *                     be kNameSpaceID_Unknown.
    1:    * @param aName The name atom of the attribute.  Must not be null.
    1:    * @param aValues a NULL-terminated array of pointers to atom values to test
    1:    *                against.
    1:    * @param aCaseSensitive Whether to do a case-sensitive compare on the values.
    1:    * @return ATTR_MISSING, ATTR_VALUE_NO_MATCH or the non-negative index
    1:    * indicating the first value of aValues that matched
    1:    */
    1:   typedef nsIAtom* const* const AttrValuesArray;
    1:   virtual PRInt32 FindAttrValueIn(PRInt32 aNameSpaceID,
    1:                                   nsIAtom* aName,
    1:                                   AttrValuesArray* aValues,
    1:                                   nsCaseTreatment aCaseSensitive) const
    1:   {
    1:     return ATTR_MISSING;
    1:   }
    1: 
    1:   /**
    1:    * Remove an attribute so that it is no longer explicitly specified.
    1:    *
    1:    * @param aNameSpaceID the namespace id of the attribute
    1:    * @param aAttr the name of the attribute to unset
    1:    * @param aNotify specifies whether or not the document should be
    1:    * notified of the attribute change
    1:    */
    1:   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttr, 
79445:                              bool aNotify) = 0;
    1: 
    1: 
    1:   /**
    1:    * Get the namespace / name / prefix of a given attribute.
    1:    * 
    1:    * @param   aIndex the index of the attribute name
    1:    * @returns The name at the given index, or null if the index is
    1:    *          out-of-bounds.
    1:    * @note    The document returned by NodeInfo()->GetDocument() (if one is
23533:    *          present) is *not* necessarily the owner document of the element.
    1:    * @note    The pointer returned by this function is only valid until the
    1:    *          next call of either GetAttrNameAt or SetAttr on the element.
    1:    */
    1:   virtual const nsAttrName* GetAttrNameAt(PRUint32 aIndex) const = 0;
    1: 
    1:   /**
    1:    * Get the number of all specified attributes.
    1:    *
    1:    * @return the number of attributes
    1:    */
    1:   virtual PRUint32 GetAttrCount() const = 0;
    1: 
    1:   /**
    1:    * Get direct access (but read only) to the text in the text content.
    1:    * NOTE: For elements this is *not* the concatenation of all text children,
    1:    * it is simply null;
    1:    */
    1:   virtual const nsTextFragment *GetText() = 0;
    1: 
    1:   /**
    1:    * Get the length of the text content.
    1:    * NOTE: This should not be called on elements.
    1:    */
94357:   virtual PRUint32 TextLength() const = 0;
    1: 
    1:   /**
80486:    * Set the text to the given value. If aNotify is true then
    1:    * the document is notified of the content change.
    1:    * NOTE: For elements this always ASSERTS and returns NS_ERROR_FAILURE
    1:    */
    1:   virtual nsresult SetText(const PRUnichar* aBuffer, PRUint32 aLength,
79445:                            bool aNotify) = 0;
    1: 
    1:   /**
80486:    * Append the given value to the current text. If aNotify is true then
    1:    * the document is notified of the content change.
    1:    * NOTE: For elements this always ASSERTS and returns NS_ERROR_FAILURE
    1:    */
    1:   virtual nsresult AppendText(const PRUnichar* aBuffer, PRUint32 aLength,
79445:                               bool aNotify) = 0;
    1: 
    1:   /**
80486:    * Set the text to the given value. If aNotify is true then
    1:    * the document is notified of the content change.
    1:    * NOTE: For elements this always asserts and returns NS_ERROR_FAILURE
    1:    */
79445:   nsresult SetText(const nsAString& aStr, bool aNotify)
    1:   {
    1:     return SetText(aStr.BeginReading(), aStr.Length(), aNotify);
    1:   }
    1: 
    1:   /**
    1:    * Query method to see if the frame is nothing but whitespace
80486:    * NOTE: Always returns false for elements
    1:    */
82209:   virtual bool TextIsOnlyWhitespace() = 0;
    1: 
    1:   /**
    1:    * Append the text content to aResult.
    1:    * NOTE: This asserts and returns for elements
    1:    */
    1:   virtual void AppendTextTo(nsAString& aResult) = 0;
    1: 
    1:   /**
    1:    * Check if this content is focusable and in the current tab order.
    1:    * Note: most callers should use nsIFrame::IsFocusable() instead as it 
    1:    *       checks visibility and other layout factors as well.
    1:    * Tabbable is indicated by a nonnegative tabindex & is a subset of focusable.
    1:    * For example, only the selected radio button in a group is in the 
    1:    * tab order, unless the radio group has no selection in which case
    1:    * all of the visible, non-disabled radio buttons in the group are 
    1:    * in the tab order. On the other hand, all of the visible, non-disabled 
    1:    * radio buttons are always focusable via clicking or script.
    1:    * Also, depending on either the accessibility.tabfocus pref or
    1:    * a system setting (nowadays: Full keyboard access, mac only)
    1:    * some widgets may be focusable but removed from the tab order.
    1:    * @param  [inout, optional] aTabIndex the computed tab index
    1:    *         In: default tabindex for element (-1 nonfocusable, == 0 focusable)
    1:    *         Out: computed tabindex
    1:    * @param  [optional] aTabIndex the computed tab index
    1:    *         < 0 if not tabbable
    1:    *         == 0 if in normal tab order
    1:    *         > 0 can be tabbed to in the order specified by this value
    1:    * @return whether the content is focusable via mouse, kbd or script.
    1:    */
79445:   virtual bool IsFocusable(PRInt32 *aTabIndex = nsnull, bool aWithMouse = false)
    1:   {
    1:     if (aTabIndex) 
    1:       *aTabIndex = -1; // Default, not tabbable
80486:     return false;
    1:   }
    1: 
    1:   /**
    1:    * The method focuses (or activates) element that accesskey is bound to. It is
    1:    * called when accesskey is activated.
    1:    *
    1:    * @param aKeyCausesActivation - if true then element should be activated
    1:    * @param aIsTrustedEvent - if true then event that is cause of accesskey
    1:    *                          execution is trusted.
    1:    */
79445:   virtual void PerformAccesskey(bool aKeyCausesActivation,
79445:                                 bool aIsTrustedEvent)
    1:   {
    1:   }
    1: 
    1:   /*
    1:    * Get desired IME state for the content.
    1:    *
    1:    * @return The desired IME status for the content.
82843:    *         This is a combination of an IME enabled value and
82843:    *         an IME open value of widget::IMEState.
82843:    *         If you return DISABLED, you should not set the OPEN and CLOSE
82843:    *         value.
82843:    *         PASSWORD should be returned only from password editor, this value
82843:    *         has a special meaning. It is used as alternative of DISABLED.
82843:    *         PLUGIN should be returned only when plug-in has focus.  When a
82843:    *         plug-in is focused content, we should send native events directly.
82843:    *         Because we don't process some native events, but they may be needed
82843:    *         by the plug-in.
    1:    */
82843:   virtual IMEState GetDesiredIMEState();
    1: 
    1:   /**
16126:    * Gets content node with the binding (or native code, possibly on the
16126:    * frame) responsible for our construction (and existence).  Used by
16126:    * anonymous content (both XBL-generated and native-anonymous).
16126:    *
16126:    * null for all explicit content (i.e., content reachable from the top
16126:    * of its GetParent() chain via child lists).
    1:    *
    1:    * @return the binding parent
    1:    */
    1:   virtual nsIContent *GetBindingParent() const = 0;
    1: 
    1:   /**
40937:    * Returns the content node that is the parent of this node in the flattened
40937:    * tree.
40937:    *
40937:    * @return the flattened tree parent
40937:    */
40937:   nsIContent *GetFlattenedTreeParent() const;
40937: 
40937:   /**
    1:    * API to check if this is a link that's traversed in response to user input
    1:    * (e.g. a click event). Specializations for HTML/SVG/generic XML allow for
    1:    * different types of link in different types of content.
    1:    *
    1:    * @param aURI Required out param. If this content is a link, a new nsIURI
    1:    *             set to this link's URI will be passed out.
    1:    *
    1:    * @note The out param, aURI, is guaranteed to be set to a non-null pointer
80486:    *   when the return value is true.
    1:    *
    1:    * XXXjwatt: IMO IsInteractiveLink would be a better name.
    1:    */
79445:   virtual bool IsLink(nsIURI** aURI) const = 0;
    1: 
    1:   /**
30307:    * Get the cached state of the link.  If the state is unknown, 
30307:    * return eLinkState_Unknown.
30307:    *
30307:    * @return The cached link state of the link.
30307:    */
30307:   virtual nsLinkState GetLinkState() const
30307:   {
30307:     return eLinkState_NotLink;
30307:   }
30307: 
30307:   /**
30307:     * Get a pointer to the full href URI (fully resolved and canonicalized,
30307:     * since it's an nsIURI object) for link elements.
30307:     *
30307:     * @return A pointer to the URI or null if the element is not a link or it
30307:     *         has no HREF attribute.
30307:     */
30307:   virtual already_AddRefed<nsIURI> GetHrefURI() const
30307:   {
30307:     return nsnull;
30307:   }
30307: 
30307:   /**
    1:    * This method is called when the parser finishes creating the element.  This
    1:    * particularly means that it has done everything you would expect it to have
    1:    * done after it encounters the > at the end of the tag (for HTML or XML).
    1:    * This includes setting the attributes, setting the document / form, and
    1:    * placing the element into the tree at its proper place.
    1:    *
    1:    * For container elements, this is called *before* any of the children are
    1:    * created or added into the tree.
    1:    *
    1:    * NOTE: this is currently only called for input and button, in the HTML
    1:    * content sink.  If you want to call it on your element, modify the content
    1:    * sink of your choice to do so.  This is an efficiency measure.
    1:    *
    1:    * If you also need to determine whether the parser is the one creating your
    1:    * element (through createElement() or cloneNode() generally) then add a
43386:    * PRUint32 aFromParser to the NS_NewXXX() constructor for your element and
43386:    * have the parser pass the appropriate flags. See nsHTMLInputElement.cpp and
    1:    * nsHTMLContentSink::MakeContentObject().
    1:    *
    1:    * DO NOT USE THIS METHOD to get around the fact that it's hard to deal with
    1:    * attributes dynamically.  If you make attributes affect your element from
    1:    * this method, it will only happen on initialization and JavaScript will not
    1:    * be able to create elements (which requires them to first create the
    1:    * element and then call setAttribute() directly, at which point
    1:    * DoneCreatingElement() has already been called and is out of the picture).
    1:    */
    1:   virtual void DoneCreatingElement()
    1:   {
    1:   }
    1: 
    1:   /**
    1:    * This method is called when the parser begins creating the element's 
    1:    * children, if any are present.
    1:    *
    1:    * This is only called for XTF elements currently.
    1:    */
    1:   virtual void BeginAddingChildren()
    1:   {
    1:   }
    1: 
    1:   /**
    1:    * This method is called when the parser finishes creating the element's children,
    1:    * if any are present.
    1:    *
    1:    * NOTE: this is currently only called for textarea, select, applet, and
    1:    * object elements in the HTML content sink.  If you want
    1:    * to call it on your element, modify the content sink of your
    1:    * choice to do so.  This is an efficiency measure.
    1:    *
    1:    * If you also need to determine whether the parser is the one creating your
    1:    * element (through createElement() or cloneNode() generally) then add a
    1:    * boolean aFromParser to the NS_NewXXX() constructor for your element and
    1:    * have the parser pass true.  See nsHTMLInputElement.cpp and
    1:    * nsHTMLContentSink::MakeContentObject().
    1:    *
    1:    * @param aHaveNotified Whether there has been a
    1:    *        ContentInserted/ContentAppended notification for this content node
    1:    *        yet.
    1:    */
82285:   virtual void DoneAddingChildren(bool aHaveNotified)
    1:   {
    1:   }
    1: 
    1:   /**
    1:    * For HTML textarea, select, applet, and object elements, returns
80486:    * true if all children have been added OR if the element was not
80486:    * created by the parser. Returns true for all other elements.
80486:    * @returns false if the element was created by the parser and
    1:    *                   it is an HTML textarea, select, applet, or object
    1:    *                   element and not all children have been added.
80486:    * @returns true otherwise.
    1:    */
79445:   virtual bool IsDoneAddingChildren()
    1:   {
80486:     return true;
    1:   }
    1: 
    1:   /**
    1:    * Get the ID of this content node (the atom corresponding to the
 4036:    * value of the null-namespace attribute whose name is given by
 4036:    * GetIDAttributeName().  This may be null if there is no ID.
    1:    */
43079:   nsIAtom* GetID() const {
67607:     if (HasID()) {
43079:       return DoGetID();
43079:     }
43079:     return nsnull;
43079:   }
    1: 
    1:   /**
    1:    * Get the class list of this content node (this corresponds to the
    1:    * value of the null-namespace attribute whose name is given by
19132:    * GetClassAttributeName()).  This may be null if there are no
    1:    * classes, but that's not guaranteed.
    1:    */
19132:   const nsAttrValue* GetClasses() const {
19132:     if (HasFlag(NODE_MAY_HAVE_CLASS)) {
19132:       return DoGetClasses();
19132:     }
19132:     return nsnull;
19132:   }
    1: 
    1:   /**
    1:    * Walk aRuleWalker over the content style rules (presentational
    1:    * hint rules) for this content node.
    1:    */
    1:   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker) = 0;
    1: 
    1:   /**
    1:    * Is the attribute named stored in the mapped attributes?
    1:    *
    1:    * // XXXbz we use this method in HasAttributeDependentStyle, so svg
    1:    *    returns true here even though it stores nothing in the mapped
    1:    *    attributes.
    1:    */
79445:   NS_IMETHOD_(bool) IsAttributeMapped(const nsIAtom* aAttribute) const = 0;
    1: 
    1:   /**
    1:    * Get a hint that tells the style system what to do when 
    1:    * an attribute on this node changes, if something needs to happen
    1:    * in response to the change *other* than the result of what is
    1:    * mapped into style data via any type of style rule.
    1:    */
    1:   virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                               PRInt32 aModType) const = 0;
    1: 
    1:   /**
    1:    * Returns an atom holding the name of the "class" attribute on this
    1:    * content node (if applicable).  Returns null if there is no
    1:    * "class" attribute for this type of content node.
    1:    */
    1:   virtual nsIAtom *GetClassAttributeName() const = 0;
    1: 
 2896:   /**
 2896:    * Should be called when the node can become editable or when it can stop
 2896:    * being editable (for example when its contentEditable attribute changes,
71121:    * when it is moved into an editable parent, ...).  If aNotify is true and
71121:    * the node is an element, this will notify the state change.
 2896:    */
79445:   virtual void UpdateEditableState(bool aNotify);
    1: 
 8462:   /**
14188:    * Destroy this node and its children. Ideally this shouldn't be needed
 8462:    * but for now we need to do it to break cycles.
 8462:    */
 8462:   virtual void DestroyContent() = 0;
 8462: 
14188:   /**
14188:    * Saves the form state of this node and its children.
14188:    */
14188:   virtual void SaveSubtreeState() = 0;
14188: 
36652:   /**
36652:    * Getter and setter for our primary frame pointer.  This is the frame that
36652:    * is most closely associated with the content. A frame is more closely
36652:    * associated with the content than another frame if the one frame contains
36652:    * directly or indirectly the other frame (e.g., when a frame is scrolled
36652:    * there is a scroll frame that contains the frame being scrolled). This
36652:    * frame is always the first continuation.
36652:    *
36652:    * In the case of absolutely positioned elements and floated elements, this
36652:    * frame is the out of flow frame, not the placeholder.
36652:    */
96083:   nsIFrame* GetPrimaryFrame() const { return mPrimaryFrame; }
36653:   void SetPrimaryFrame(nsIFrame* aFrame) {
36793:     NS_PRECONDITION(!aFrame || !mPrimaryFrame || aFrame == mPrimaryFrame,
36653:                     "Losing track of existing primary frame");
36653:     mPrimaryFrame = aFrame;
36653:   }
36652: 
85097:   nsresult LookupNamespaceURIInternal(const nsAString& aNamespacePrefix,
41904:                                       nsAString& aNamespaceURI) const;
41904: 
48083:   /**
48083:    * If this content has independent selection, e.g., if this is input field
48083:    * or textarea, this return TRUE.  Otherwise, false.
48083:    */
79445:   bool HasIndependentSelection();
48083: 
48083:   /**
48083:    * If the content is a part of HTML editor, this returns editing
48083:    * host content.  When the content is in designMode, this returns its body
48083:    * element.  Also, when the content isn't editable, this returns null.
48083:    */
48083:   nsIContent* GetEditingHost();
48083: 
75374:   /**
75374:    * Determing language. Look at the nearest ancestor element that has a lang
90456:    * attribute in the XML namespace or is an HTML/SVG element and has a lang in
75374:    * no namespace attribute.
75374:    */
75374:   void GetLang(nsAString& aResult) const {
75374:     for (const nsIContent* content = this; content; content = content->GetParent()) {
75374:       if (content->GetAttrCount() > 0) {
75374:         // xml:lang has precedence over lang on HTML elements (see
75374:         // XHTML1 section C.7).
79445:         bool hasAttr = content->GetAttr(kNameSpaceID_XML, nsGkAtoms::lang,
75374:                                           aResult);
90456:         if (!hasAttr && (content->IsHTML() || content->IsSVG())) {
75374:           hasAttr = content->GetAttr(kNameSpaceID_None, nsGkAtoms::lang,
75374:                                      aResult);
75374:         }
75374:         NS_ASSERTION(hasAttr || aResult.IsEmpty(),
75374:                      "GetAttr that returns false should not make string non-empty");
75374:         if (hasAttr) {
75374:           return;
75374:         }
75374:       }
75374:     }
75374:   }
75374: 
62344:   // Overloaded from nsINode
62344:   virtual already_AddRefed<nsIURI> GetBaseURI() const;
62344: 
72324:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
72324: 
88521:   virtual bool IsPurple() = 0;
88521:   virtual void RemovePurple() = 0;
88521: 
43079: protected:
43079:   /**
43079:    * Hook for implementing GetID.  This is guaranteed to only be
67607:    * called if HasID() is true.
43079:    */
43079:   virtual nsIAtom* DoGetID() const = 0;
43079: 
19132: private:
19132:   /**
19132:    * Hook for implementing GetClasses.  This is guaranteed to only be
19132:    * called if the NODE_MAY_HAVE_CLASS flag is set.
19132:    */
19132:   virtual const nsAttrValue* DoGetClasses() const = 0;
19132: 
96083:   /**
96083:    * Pointer to our primary frame.  Might be null.
96083:    */
96083:   nsIFrame* mPrimaryFrame;
96083: 
19132: public:
    1: #ifdef DEBUG
    1:   /**
    1:    * List the content (and anything it contains) out to the given
    1:    * file stream. Use aIndent as the base indent during formatting.
    1:    */
    1:   virtual void List(FILE* out = stdout, PRInt32 aIndent = 0) const = 0;
    1: 
    1:   /**
    1:    * Dump the content (and anything it contains) out to the given
    1:    * file stream. Use aIndent as the base indent during formatting.
    1:    */
    1:   virtual void DumpContent(FILE* out = stdout, PRInt32 aIndent = 0,
79445:                            bool aDumpAll = true) const = 0;
    1: #endif
    1: 
    1:   enum ETabFocusType {
    1:   //eTabFocus_textControlsMask = (1<<0),  // unused - textboxes always tabbable
    1:     eTabFocus_formElementsMask = (1<<1),  // non-text form elements
    1:     eTabFocus_linksMask = (1<<2),         // links
    1:     eTabFocus_any = 1 + (1<<1) + (1<<2)   // everything that can be focused
    1:   };
    1: 
    1:   // Tab focus model bit field:
    1:   static PRInt32 sTabFocusModel;
    1: 
    1:   // accessibility.tabfocus_applies_to_xul pref - if it is set to true,
    1:   // the tabfocus bit field applies to xul elements.
79445:   static bool sTabFocusModelAppliesToXUL;
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsIContent, NS_ICONTENT_IID)
    1: 
    1: #endif /* nsIContent_h___ */
