29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
17755:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS bytecode generation.
    1:  */
    1: #ifdef HAVE_MEMORY_H
    1: #include <memory.h>
    1: #endif
27012: #include <new>
    1: #include <string.h>
80468: 
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsutil.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsatom.h"
 8817: #include "jsbool.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsfun.h"
    1: #include "jsnum.h"
    1: #include "jsopcode.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
42774: #include "jsautooplen.h"        // generated headers last
15453: 
80506: #include "ds/LifoAlloc.h"
80507: #include "frontend/BytecodeCompiler.h"
80966: #include "frontend/BytecodeEmitter.h"
80506: #include "frontend/Parser.h"
80506: #include "frontend/TokenStream.h"
80506: #include "vm/RegExpObject.h"
80506: 
59962: #include "jsatominlines.h"
47497: #include "jsobjinlines.h"
47497: #include "jsscopeinlines.h"
59968: #include "jsscriptinlines.h"
47497: 
72579: #include "frontend/ParseMaps-inl.h"
72579: 
    1: /* Allocation chunk counts, must be powers of two in general. */
77950: #define BYTECODE_CHUNK_LENGTH  1024    /* initial bytecode chunk length */
77950: #define SRCNOTE_CHUNK_LENGTH   1024    /* initial srcnote chunk length */
    1: 
    1: /* Macros to compute byte sizes from typed element counts. */
    1: #define BYTECODE_SIZE(n)        ((n) * sizeof(jsbytecode))
    1: #define SRCNOTE_SIZE(n)         ((n) * sizeof(jssrcnote))
    1: 
40320: using namespace js;
54707: using namespace js::gc;
80632: using namespace js::frontend;
80632: 
80632: #ifdef JS_TRACER
80632: extern uint8 js_opcode2extra[];
80632: #endif
80632: 
 3025: static JSBool
80966: NewTryNote(JSContext *cx, BytecodeEmitter *bce, JSTryNoteKind kind, uintN stackDepth,
80631:            size_t start, size_t end);
 3025: 
77456: static bool
80966: EmitIndexOp(JSContext *cx, JSOp op, uintN index, BytecodeEmitter *bce, JSOp *psuffix = NULL);
54855: 
54855: static JSBool
80966: EmitLeaveBlock(JSContext *cx, BytecodeEmitter *bce, JSOp op, ObjectBox *box);
54855: 
80786: static JSBool
80966: SetSrcNoteOffset(JSContext *cx, BytecodeEmitter *bce, uintN index, uintN which, ptrdiff_t offset);
80632: 
59968: void
80631: TreeContext::trace(JSTracer *trc)
59968: {
59968:     bindings.trace(trc);
59968: }
59968: 
80966: BytecodeEmitter::BytecodeEmitter(Parser *parser, uintN lineno)
80631:   : TreeContext(parser),
72579:     atomIndices(parser->context),
27012:     stackDepth(0), maxStackDepth(0),
27012:     ntrynotes(0), lastTryNode(NULL),
27012:     spanDeps(NULL), jumpTargets(NULL), jtFreeList(NULL),
27012:     numSpanDeps(0), numJumpTargets(0), spanDepTodo(0),
27012:     arrayCompDepth(0),
41867:     emitLevel(0),
48470:     constMap(parser->context),
52684:     constList(parser->context),
72579:     upvarIndices(parser->context),
73887:     upvarMap(parser->context),
80990:     globalScope(NULL),
72091:     globalUses(parser->context),
72579:     globalMap(parser->context),
72091:     closedArgs(parser->context),
72091:     closedVars(parser->context),
77343:     traceIndex(0),
77391:     typesetCount(0)
    1: {
27012:     flags = TCF_COMPILING;
27012:     memset(&prolog, 0, sizeof prolog);
27012:     memset(&main, 0, sizeof main);
27012:     current = &main;
27012:     firstLine = prolog.currentLine = main.currentLine = lineno;
27012: }
27012: 
72579: bool
80966: BytecodeEmitter::init(JSContext *cx, TreeContext::InitBehavior ib)
41867: {
72579:     roLexdeps.init();
80631:     return TreeContext::init(cx, ib) && constMap.init() && atomIndices.ensureMap(cx);
80631: }
80631: 
80966: BytecodeEmitter::~BytecodeEmitter()
    1: {
72579:     JSContext *cx = parser->context;
72579: 
77950:     cx->free_(prolog.base);
77950:     cx->free_(prolog.notes);
77950:     cx->free_(main.base);
77950:     cx->free_(main.notes);
77950: 
18308:     /* NB: non-null only after OOM. */
27012:     if (spanDeps)
72579:         cx->free_(spanDeps);
    1: }
    1: 
    1: static ptrdiff_t
80966: EmitCheck(JSContext *cx, BytecodeEmitter *bce, ptrdiff_t delta)
80966: {
80966:     jsbytecode *base = bce->base();
77950:     jsbytecode *newbase;
80966:     jsbytecode *next = bce->next();
80966:     jsbytecode *limit = bce->limit();
77950:     ptrdiff_t offset = next - base;
77950:     size_t minlength = offset + delta;
77950: 
    1:     if (next + delta > limit) {
77950:         size_t newlength;
    1:         if (!base) {
77950:             JS_ASSERT(!next && !limit);
77950:             newlength = BYTECODE_CHUNK_LENGTH;
77950:             if (newlength < minlength)     /* make it bigger if necessary */
77950:                 newlength = RoundUpPow2(minlength);
77950:             newbase = (jsbytecode *) cx->malloc_(BYTECODE_SIZE(newlength));
    1:         } else {
77950:             JS_ASSERT(base <= next && next <= limit);
77950:             newlength = (limit - base) * 2;
77950:             if (newlength < minlength)     /* make it bigger if necessary */
77950:                 newlength = RoundUpPow2(minlength);
77950:             newbase = (jsbytecode *) cx->realloc_(base, BYTECODE_SIZE(newlength));
77950:         }
77950:         if (!newbase) {
71371:             js_ReportOutOfMemory(cx);
    1:             return -1;
    1:         }
77950:         JS_ASSERT(newlength >= size_t(offset + delta));
80966:         bce->current->base = newbase;
80966:         bce->current->limit = newbase + newlength;
80966:         bce->current->next = newbase + offset;
    1:     }
    1:     return offset;
    1: }
    1: 
    1: static void
80966: UpdateDepth(JSContext *cx, BytecodeEmitter *bce, ptrdiff_t target)
    1: {
    1:     jsbytecode *pc;
 1227:     JSOp op;
    1:     const JSCodeSpec *cs;
77357:     uintN extra, nuses;
26729:     intN ndefs;
    1: 
80966:     pc = bce->code(target);
 1227:     op = (JSOp) *pc;
 1227:     cs = &js_CodeSpec[op];
23075: #ifdef JS_TRACER
23075:     extra = js_opcode2extra[op];
23075: #else
23075:     extra = 0;
23075: #endif
23075:     if ((cs->format & JOF_TMPSLOT_MASK) || extra) {
80966:         uintN depth = (uintN) bce->stackDepth +
23075:                       ((cs->format & JOF_TMPSLOT_MASK) >> JOF_TMPSLOT_SHIFT) +
23075:                       extra;
80966:         if (depth > bce->maxStackDepth)
80966:             bce->maxStackDepth = depth;
 2126:     }
23075: 
26729:     nuses = js_GetStackUses(cs, op, pc);
80966:     bce->stackDepth -= nuses;
80966:     JS_ASSERT(bce->stackDepth >= 0);
80966:     if (bce->stackDepth < 0) {
    1:         char numBuf[12];
40320:         TokenStream *ts;
 6561: 
    1:         JS_snprintf(numBuf, sizeof numBuf, "%d", target);
80966:         ts = &bce->parser->tokenStream;
    1:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING,
    1:                                      js_GetErrorMessage, NULL,
    1:                                      JSMSG_STACK_UNDERFLOW,
40270:                                      ts->getFilename() ? ts->getFilename() : "stdin",
    1:                                      numBuf);
    1:     }
18567:     ndefs = cs->ndefs;
18567:     if (ndefs < 0) {
18567:         JSObject *blockObj;
18567: 
18567:         /* We just executed IndexParsedObject */
18567:         JS_ASSERT(op == JSOP_ENTERBLOCK);
18567:         JS_ASSERT(nuses == 0);
80966:         blockObj = bce->objectList.lastbox->object;
53650:         JS_ASSERT(blockObj->isStaticBlock());
55746:         JS_ASSERT(blockObj->getSlot(JSSLOT_BLOCK_DEPTH).isUndefined());
18567: 
80966:         OBJ_SET_BLOCK_DEPTH(cx, blockObj, bce->stackDepth);
18567:         ndefs = OBJ_BLOCK_COUNT(cx, blockObj);
18567:     }
80966:     bce->stackDepth += ndefs;
80966:     if ((uintN)bce->stackDepth > bce->maxStackDepth)
80966:         bce->maxStackDepth = bce->stackDepth;
    1: }
    1: 
77357: static inline void
80966: UpdateDecomposeLength(BytecodeEmitter *bce, uintN start)
80966: {
80966:     uintN end = bce->offset();
77358:     JS_ASSERT(uintN(end - start) < 256);
80966:     bce->code(start)[-1] = end - start;
77357: }
77357: 
    1: ptrdiff_t
80966: frontend::Emit1(JSContext *cx, BytecodeEmitter *bce, JSOp op)
80966: {
80966:     ptrdiff_t offset = EmitCheck(cx, bce, 1);
    1: 
    1:     if (offset >= 0) {
80966:         *bce->current->next++ = (jsbytecode)op;
80966:         UpdateDepth(cx, bce, offset);
    1:     }
    1:     return offset;
    1: }
    1: 
    1: ptrdiff_t
80966: frontend::Emit2(JSContext *cx, BytecodeEmitter *bce, JSOp op, jsbytecode op1)
80966: {
80966:     ptrdiff_t offset = EmitCheck(cx, bce, 2);
    1: 
    1:     if (offset >= 0) {
80966:         jsbytecode *next = bce->next();
    1:         next[0] = (jsbytecode)op;
    1:         next[1] = op1;
80966:         bce->current->next = next + 2;
80966:         UpdateDepth(cx, bce, offset);
    1:     }
    1:     return offset;
    1: }
    1: 
    1: ptrdiff_t
80966: frontend::Emit3(JSContext *cx, BytecodeEmitter *bce, JSOp op, jsbytecode op1,
    1:                     jsbytecode op2)
    1: {
80966:     ptrdiff_t offset = EmitCheck(cx, bce, 3);
    1: 
    1:     if (offset >= 0) {
80966:         jsbytecode *next = bce->next();
    1:         next[0] = (jsbytecode)op;
    1:         next[1] = op1;
    1:         next[2] = op2;
80966:         bce->current->next = next + 3;
80966:         UpdateDepth(cx, bce, offset);
    1:     }
    1:     return offset;
    1: }
    1: 
    1: ptrdiff_t
80966: frontend::Emit5(JSContext *cx, BytecodeEmitter *bce, JSOp op, uint16 op1, uint16 op2)
80966: {
80966:     ptrdiff_t offset = EmitCheck(cx, bce, 5);
54855: 
54855:     if (offset >= 0) {
80966:         jsbytecode *next = bce->next();
54855:         next[0] = (jsbytecode)op;
54855:         next[1] = UINT16_HI(op1);
54855:         next[2] = UINT16_LO(op1);
54855:         next[3] = UINT16_HI(op2);
54855:         next[4] = UINT16_LO(op2);
80966:         bce->current->next = next + 5;
80966:         UpdateDepth(cx, bce, offset);
54855:     }
54855:     return offset;
54855: }
54855: 
54855: ptrdiff_t
80966: frontend::EmitN(JSContext *cx, BytecodeEmitter *bce, JSOp op, size_t extra)
    1: {
    1:     ptrdiff_t length = 1 + (ptrdiff_t)extra;
80966:     ptrdiff_t offset = EmitCheck(cx, bce, length);
    1: 
    1:     if (offset >= 0) {
80966:         jsbytecode *next = bce->next();
    1:         *next = (jsbytecode)op;
    1:         memset(next + 1, 0, BYTECODE_SIZE(extra));
80966:         bce->current->next = next + length;
15279: 
15279:         /*
15279:          * Don't UpdateDepth if op's use-count comes from the immediate
15279:          * operand yet to be stored in the extra bytes after op.
15279:          */
15279:         if (js_CodeSpec[op].nuses >= 0)
80966:             UpdateDepth(cx, bce, offset);
    1:     }
    1:     return offset;
    1: }
    1: 
    1: /* XXX too many "... statement" L10N gaffes below -- fix via js.msg! */
    1: const char js_with_statement_str[] = "with statement";
    1: const char js_finally_block_str[]  = "finally block";
    1: const char js_script_str[]         = "script";
    1: 
    1: static const char *statementName[] = {
    1:     "label statement",       /* LABEL */
    1:     "if statement",          /* IF */
    1:     "else statement",        /* ELSE */
11672:     "destructuring body",    /* BODY */
    1:     "switch statement",      /* SWITCH */
    1:     "block",                 /* BLOCK */
    1:     js_with_statement_str,   /* WITH */
    1:     "catch block",           /* CATCH */
    1:     "try block",             /* TRY */
    1:     js_finally_block_str,    /* FINALLY */
    1:     js_finally_block_str,    /* SUBROUTINE */
    1:     "do loop",               /* DO_LOOP */
    1:     "for loop",              /* FOR_LOOP */
    1:     "for/in loop",           /* FOR_IN_LOOP */
    1:     "while loop",            /* WHILE_LOOP */
    1: };
    1: 
11672: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(statementName) == STMT_LIMIT);
11672: 
    1: static const char *
80966: StatementName(BytecodeEmitter *bce)
80966: {
80966:     if (!bce->topStmt)
    1:         return js_script_str;
80966:     return statementName[bce->topStmt->type];
    1: }
    1: 
    1: static void
80966: ReportStatementTooLarge(JSContext *cx, BytecodeEmitter *bce)
    1: {
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NEED_DIET,
80966:                          StatementName(bce));
    1: }
    1: 
    1: /**
    1:   Span-dependent instructions in JS bytecode consist of the jump (JOF_JUMP)
    1:   and switch (JOF_LOOKUPSWITCH, JOF_TABLESWITCH) format opcodes, subdivided
    1:   into unconditional (gotos and gosubs), and conditional jumps or branches
    1:   (which pop a value, test it, and jump depending on its value).  Most jumps
    1:   have just one immediate operand, a signed offset from the jump opcode's pc
    1:   to the target bytecode.  The lookup and table switch opcodes may contain
    1:   many jump offsets.
    1: 
    1:   Mozilla bug #80981 (http://bugzilla.mozilla.org/show_bug.cgi?id=80981) was
    1:   fixed by adding extended "X" counterparts to the opcodes/formats (NB: X is
    1:   suffixed to prefer JSOP_ORX thereby avoiding a JSOP_XOR name collision for
    1:   the extended form of the JSOP_OR branch opcode).  The unextended or short
    1:   formats have 16-bit signed immediate offset operands, the extended or long
    1:   formats have 32-bit signed immediates.  The span-dependency problem consists
    1:   of selecting as few long instructions as possible, or about as few -- since
    1:   jumps can span other jumps, extending one jump may cause another to need to
    1:   be extended.
    1: 
    1:   Most JS scripts are short, so need no extended jumps.  We optimize for this
    1:   case by generating short jumps until we know a long jump is needed.  After
    1:   that point, we keep generating short jumps, but each jump's 16-bit immediate
80966:   offset operand is actually an unsigned index into bce->spanDeps, an array of
80631:   js::SpanDep structs.  Each struct tells the top offset in the script of the
    1:   opcode, the "before" offset of the jump (which will be the same as top for
    1:   simplex jumps, but which will index further into the bytecode array for a
    1:   non-initial jump offset in a lookup or table switch), the after "offset"
    1:   adjusted during span-dependent instruction selection (initially the same
    1:   value as the "before" offset), and the jump target (more below).
    1: 
80966:   Since we generate bce->spanDeps lazily, from within SetJumpOffset, we must
    1:   ensure that all bytecode generated so far can be inspected to discover where
80966:   the jump offset immediate operands lie within bce->main. But the bonus is
    1:   that we generate span-dependency records sorted by their offsets, so we can
80631:   binary-search when trying to find a SpanDep for a given bytecode offset, or
80631:   the nearest SpanDep at or above a given pc.
    1: 
80966:   To avoid limiting scripts to 64K jumps, if the bce->spanDeps index overflows
    1:   65534, we store SPANDEP_INDEX_HUGE in the jump's immediate operand.  This
80966:   tells us that we need to binary-search for the bce->spanDeps entry by the
    1:   jump opcode's bytecode offset (sd->before).
    1: 
    1:   Jump targets need to be maintained in a data structure that lets us look
    1:   up an already-known target by its address (jumps may have a common target),
    1:   and that also lets us update the addresses (script-relative, a.k.a. absolute
    1:   offsets) of targets that come after a jump target (for when a jump below
    1:   that target needs to be extended).  We use an AVL tree, implemented using
    1:   recursion, but with some tricky optimizations to its height-balancing code
    1:   (see http://www.cmcrossroads.com/bradapp/ftp/src/libs/C++/AvlTrees.html).
    1: 
    1:   A final wrinkle: backpatch chains are linked by jump-to-jump offsets with
    1:   positive sign, even though they link "backward" (i.e., toward lower bytecode
    1:   address).  We don't want to waste space and search time in the AVL tree for
    1:   such temporary backpatch deltas, so we use a single-bit wildcard scheme to
80631:   tag true JumpTarget pointers and encode untagged, signed (positive) deltas in
80631:   SpanDep::target pointers, depending on whether the SpanDep has a known
    1:   target, or is still awaiting backpatching.
    1: 
    1:   Note that backpatch chains would present a problem for BuildSpanDepTable,
80966:   which inspects bytecode to build bce->spanDeps on demand, when the first
    1:   short jump offset overflows.  To solve this temporary problem, we emit a
    1:   proxy bytecode (JSOP_BACKPATCH; JSOP_BACKPATCH_POP for branch ops) whose
    1:   nuses/ndefs counts help keep the stack balanced, but whose opcode format
    1:   distinguishes its backpatch delta immediate operand from a normal jump
    1:   offset.
    1:  */
    1: static int
80631: BalanceJumpTargets(JumpTarget **jtp)
80631: {
80631:     JumpTarget *jt = *jtp;
80631:     JS_ASSERT(jt->balance != 0);
80631: 
80631:     int dir;
    1:     JSBool doubleRotate;
    1:     if (jt->balance < -1) {
    1:         dir = JT_RIGHT;
    1:         doubleRotate = (jt->kids[JT_LEFT]->balance > 0);
    1:     } else if (jt->balance > 1) {
    1:         dir = JT_LEFT;
    1:         doubleRotate = (jt->kids[JT_RIGHT]->balance < 0);
    1:     } else {
    1:         return 0;
    1:     }
    1: 
80631:     int otherDir = JT_OTHER_DIR(dir);
80631:     JumpTarget *root;
80631:     int heightChanged;
    1:     if (doubleRotate) {
80631:         JumpTarget *jt2 = jt->kids[otherDir];
    1:         *jtp = root = jt2->kids[dir];
    1: 
    1:         jt->kids[otherDir] = root->kids[dir];
    1:         root->kids[dir] = jt;
    1: 
    1:         jt2->kids[dir] = root->kids[otherDir];
    1:         root->kids[otherDir] = jt2;
    1: 
    1:         heightChanged = 1;
    1:         root->kids[JT_LEFT]->balance = -JS_MAX(root->balance, 0);
    1:         root->kids[JT_RIGHT]->balance = -JS_MIN(root->balance, 0);
    1:         root->balance = 0;
    1:     } else {
    1:         *jtp = root = jt->kids[otherDir];
    1:         jt->kids[otherDir] = root->kids[dir];
    1:         root->kids[dir] = jt;
    1: 
    1:         heightChanged = (root->balance != 0);
    1:         jt->balance = -((dir == JT_LEFT) ? --root->balance : ++root->balance);
    1:     }
    1: 
    1:     return heightChanged;
    1: }
    1: 
80631: struct AddJumpTargetArgs {
    1:     JSContext           *cx;
80966:     BytecodeEmitter     *bce;
    1:     ptrdiff_t           offset;
80631:     JumpTarget          *node;
80631: };
    1: 
    1: static int
80631: AddJumpTarget(AddJumpTargetArgs *args, JumpTarget **jtp)
80631: {
80631:     JumpTarget *jt = *jtp;
    1:     if (!jt) {
80966:         BytecodeEmitter *bce = args->bce;
80966: 
80966:         jt = bce->jtFreeList;
    1:         if (jt) {
80966:             bce->jtFreeList = jt->kids[JT_LEFT];
    1:         } else {
80631:             jt = args->cx->tempLifoAlloc().new_<JumpTarget>();
    1:             if (!jt) {
71371:                 js_ReportOutOfMemory(args->cx);
    1:                 return 0;
    1:             }
    1:         }
    1:         jt->offset = args->offset;
    1:         jt->balance = 0;
    1:         jt->kids[JT_LEFT] = jt->kids[JT_RIGHT] = NULL;
80966:         bce->numJumpTargets++;
    1:         args->node = jt;
    1:         *jtp = jt;
    1:         return 1;
    1:     }
    1: 
    1:     if (jt->offset == args->offset) {
    1:         args->node = jt;
    1:         return 0;
    1:     }
    1: 
80631:     int balanceDelta;
    1:     if (args->offset < jt->offset)
    1:         balanceDelta = -AddJumpTarget(args, &jt->kids[JT_LEFT]);
    1:     else
    1:         balanceDelta = AddJumpTarget(args, &jt->kids[JT_RIGHT]);
    1:     if (!args->node)
    1:         return 0;
    1: 
    1:     jt->balance += balanceDelta;
    1:     return (balanceDelta && jt->balance)
    1:            ? 1 - BalanceJumpTargets(jtp)
    1:            : 0;
    1: }
    1: 
    1: #ifdef DEBUG_brendan
80786: static int
80786: AVLCheck(JumpTarget *jt)
    1: {
    1:     int lh, rh;
    1: 
    1:     if (!jt) return 0;
    1:     JS_ASSERT(-1 <= jt->balance && jt->balance <= 1);
    1:     lh = AVLCheck(jt->kids[JT_LEFT]);
    1:     rh = AVLCheck(jt->kids[JT_RIGHT]);
    1:     JS_ASSERT(jt->balance == rh - lh);
    1:     return 1 + JS_MAX(lh, rh);
    1: }
    1: #endif
    1: 
    1: static JSBool
80966: SetSpanDepTarget(JSContext *cx, BytecodeEmitter *bce, SpanDep *sd, ptrdiff_t off)
    1: {
    1:     AddJumpTargetArgs args;
    1: 
    1:     if (off < JUMPX_OFFSET_MIN || JUMPX_OFFSET_MAX < off) {
80966:         ReportStatementTooLarge(cx, bce);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     args.cx = cx;
80966:     args.bce = bce;
    1:     args.offset = sd->top + off;
    1:     args.node = NULL;
80966:     AddJumpTarget(&args, &bce->jumpTargets);
    1:     if (!args.node)
    1:         return JS_FALSE;
    1: 
    1: #ifdef DEBUG_brendan
80966:     AVLCheck(bce->jumpTargets);
    1: #endif
    1: 
    1:     SD_SET_TARGET(sd, args.node);
    1:     return JS_TRUE;
    1: }
    1: 
    1: #define SPANDEPS_MIN            256
80631: #define SPANDEPS_SIZE(n)        ((n) * sizeof(js::SpanDep))
    1: #define SPANDEPS_SIZE_MIN       SPANDEPS_SIZE(SPANDEPS_MIN)
    1: 
    1: static JSBool
80966: AddSpanDep(JSContext *cx, BytecodeEmitter *bce, jsbytecode *pc, jsbytecode *pc2, ptrdiff_t off)
80966: {
80966:     uintN index = bce->numSpanDeps;
    1:     if (index + 1 == 0) {
80966:         ReportStatementTooLarge(cx, bce);
    1:         return JS_FALSE;
    1:     }
    1: 
80631:     SpanDep *sdbase;
    1:     if ((index & (index - 1)) == 0 &&
80966:         (!(sdbase = bce->spanDeps) || index >= SPANDEPS_MIN))
80631:     {
80631:         size_t size = sdbase ? SPANDEPS_SIZE(index) : SPANDEPS_SIZE_MIN / 2;
80631:         sdbase = (SpanDep *) cx->realloc_(sdbase, size + size);
    1:         if (!sdbase)
    1:             return JS_FALSE;
80966:         bce->spanDeps = sdbase;
80966:     }
80966: 
80966:     bce->numSpanDeps = index + 1;
80966:     SpanDep *sd = bce->spanDeps + index;
80966:     sd->top = pc - bce->base();
80966:     sd->offset = sd->before = pc2 - bce->base();
    1: 
    1:     if (js_CodeSpec[*pc].format & JOF_BACKPATCH) {
    1:         /* Jump offset will be backpatched if off is a non-zero "bpdelta". */
    1:         if (off != 0) {
    1:             JS_ASSERT(off >= 1 + JUMP_OFFSET_LEN);
    1:             if (off > BPDELTA_MAX) {
80966:                 ReportStatementTooLarge(cx, bce);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         SD_SET_BPDELTA(sd, off);
    1:     } else if (off == 0) {
    1:         /* Jump offset will be patched directly, without backpatch chaining. */
16069:         SD_SET_TARGET(sd, 0);
    1:     } else {
    1:         /* The jump offset in off is non-zero, therefore it's already known. */
80966:         if (!SetSpanDepTarget(cx, bce, sd, off))
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     if (index > SPANDEP_INDEX_MAX)
    1:         index = SPANDEP_INDEX_HUGE;
    1:     SET_SPANDEP_INDEX(pc2, index);
    1:     return JS_TRUE;
    1: }
    1: 
 7365: static jsbytecode *
80966: AddSwitchSpanDeps(JSContext *cx, BytecodeEmitter *bce, jsbytecode *pc)
 7365: {
 7365:     JSOp op;
 7365:     jsbytecode *pc2;
 7365:     ptrdiff_t off;
 7365:     jsint low, high;
 7365:     uintN njumps, indexlen;
 7365: 
 7365:     op = (JSOp) *pc;
 7365:     JS_ASSERT(op == JSOP_TABLESWITCH || op == JSOP_LOOKUPSWITCH);
 7365:     pc2 = pc;
 7365:     off = GET_JUMP_OFFSET(pc2);
80966:     if (!AddSpanDep(cx, bce, pc, pc2, off))
 7365:         return NULL;
 7365:     pc2 += JUMP_OFFSET_LEN;
 7365:     if (op == JSOP_TABLESWITCH) {
 7365:         low = GET_JUMP_OFFSET(pc2);
 7365:         pc2 += JUMP_OFFSET_LEN;
 7365:         high = GET_JUMP_OFFSET(pc2);
 7365:         pc2 += JUMP_OFFSET_LEN;
 7365:         njumps = (uintN) (high - low + 1);
 7365:         indexlen = 0;
 7365:     } else {
 7365:         njumps = GET_UINT16(pc2);
 7365:         pc2 += UINT16_LEN;
 7365:         indexlen = INDEX_LEN;
 7365:     }
 7365:     while (njumps) {
 7365:         --njumps;
 7365:         pc2 += indexlen;
 7365:         off = GET_JUMP_OFFSET(pc2);
80966:         if (!AddSpanDep(cx, bce, pc, pc2, off))
 7365:             return NULL;
 7365:         pc2 += JUMP_OFFSET_LEN;
 7365:     }
 7365:     return 1 + pc2;
 7365: }
 7365: 
    1: static JSBool
80966: BuildSpanDepTable(JSContext *cx, BytecodeEmitter *bce)
    1: {
    1:     jsbytecode *pc, *end;
    1:     JSOp op;
    1:     const JSCodeSpec *cs;
 7365:     ptrdiff_t off;
    1: 
80966:     pc = bce->base() + bce->spanDepTodo;
80966:     end = bce->next();
 7365:     while (pc != end) {
 7365:         JS_ASSERT(pc < end);
    1:         op = (JSOp)*pc;
    1:         cs = &js_CodeSpec[op];
    1: 
11377:         switch (JOF_TYPE(cs->format)) {
 7365:           case JOF_TABLESWITCH:
 7365:           case JOF_LOOKUPSWITCH:
80966:             pc = AddSwitchSpanDeps(cx, bce, pc);
 7365:             if (!pc)
 7365:                 return JS_FALSE;
 7365:             break;
 7365: 
    1:           case JOF_JUMP:
    1:             off = GET_JUMP_OFFSET(pc);
80966:             if (!AddSpanDep(cx, bce, pc, pc, off))
    1:                 return JS_FALSE;
 7365:             /* FALL THROUGH */
 7365:           default:
 7365:             pc += cs->length;
 7365:             break;
 7365:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
80631: static SpanDep *
80966: GetSpanDep(BytecodeEmitter *bce, jsbytecode *pc)
    1: {
    1:     uintN index;
    1:     ptrdiff_t offset;
    1:     int lo, hi, mid;
80631:     SpanDep *sd;
    1: 
    1:     index = GET_SPANDEP_INDEX(pc);
    1:     if (index != SPANDEP_INDEX_HUGE)
80966:         return bce->spanDeps + index;
80966: 
80966:     offset = pc - bce->base();
    1:     lo = 0;
80966:     hi = bce->numSpanDeps - 1;
    1:     while (lo <= hi) {
    1:         mid = (lo + hi) / 2;
80966:         sd = bce->spanDeps + mid;
    1:         if (sd->before == offset)
    1:             return sd;
    1:         if (sd->before < offset)
    1:             lo = mid + 1;
    1:         else
    1:             hi = mid - 1;
    1:     }
    1: 
    1:     JS_ASSERT(0);
    1:     return NULL;
    1: }
    1: 
    1: static JSBool
80966: SetBackPatchDelta(JSContext *cx, BytecodeEmitter *bce, jsbytecode *pc, ptrdiff_t delta)
80631: {
80631:     SpanDep *sd;
    1: 
    1:     JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
80966:     if (!bce->spanDeps && delta < JUMP_OFFSET_MAX) {
    1:         SET_JUMP_OFFSET(pc, delta);
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     if (delta > BPDELTA_MAX) {
80966:         ReportStatementTooLarge(cx, bce);
80966:         return JS_FALSE;
80966:     }
80966: 
80966:     if (!bce->spanDeps && !BuildSpanDepTable(cx, bce))
80966:         return JS_FALSE;
80966: 
80966:     sd = GetSpanDep(bce, pc);
    1:     JS_ASSERT(SD_GET_BPDELTA(sd) == 0);
    1:     SD_SET_BPDELTA(sd, delta);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static void
80631: UpdateJumpTargets(JumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
    1: {
    1:     if (jt->offset > pivot) {
    1:         jt->offset += delta;
    1:         if (jt->kids[JT_LEFT])
    1:             UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
    1:     }
    1:     if (jt->kids[JT_RIGHT])
    1:         UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
    1: }
    1: 
80631: static SpanDep *
80966: FindNearestSpanDep(BytecodeEmitter *bce, ptrdiff_t offset, int lo, SpanDep *guard)
80966: {
80966:     int num = bce->numSpanDeps;
    1:     JS_ASSERT(num > 0);
80631:     int hi = num - 1;
80966:     SpanDep *sdbase = bce->spanDeps;
    1:     while (lo <= hi) {
80631:         int mid = (lo + hi) / 2;
80631:         SpanDep *sd = sdbase + mid;
    1:         if (sd->before == offset)
    1:             return sd;
    1:         if (sd->before < offset)
    1:             lo = mid + 1;
    1:         else
    1:             hi = mid - 1;
    1:     }
    1:     if (lo == num)
    1:         return guard;
80631:     SpanDep *sd = sdbase + lo;
    1:     JS_ASSERT(sd->before >= offset && (lo == 0 || sd[-1].before < offset));
    1:     return sd;
    1: }
    1: 
    1: static void
80966: FreeJumpTargets(BytecodeEmitter *bce, JumpTarget *jt)
    1: {
    1:     if (jt->kids[JT_LEFT])
80966:         FreeJumpTargets(bce, jt->kids[JT_LEFT]);
    1:     if (jt->kids[JT_RIGHT])
80966:         FreeJumpTargets(bce, jt->kids[JT_RIGHT]);
80966:     jt->kids[JT_LEFT] = bce->jtFreeList;
80966:     bce->jtFreeList = jt;
    1: }
    1: 
    1: static JSBool
80966: OptimizeSpanDeps(JSContext *cx, BytecodeEmitter *bce)
    1: {
    1:     jsbytecode *pc, *oldpc, *base, *limit, *next;
80631:     SpanDep *sd, *sd2, *sdbase, *sdlimit, *sdtop, guard;
    1:     ptrdiff_t offset, growth, delta, top, pivot, span, length, target;
    1:     JSBool done;
    1:     JSOp op;
    1:     uint32 type;
    1:     jssrcnote *sn, *snlimit;
    1:     JSSrcNoteSpec *spec;
    1:     uintN i, n, noteIndex;
80631:     TryNode *tryNode;
68941:     DebugOnly<int> passes = 0;
    1: 
80966:     base = bce->base();
80966:     sdbase = bce->spanDeps;
80966:     sdlimit = sdbase + bce->numSpanDeps;
80966:     offset = bce->offset();
    1:     growth = 0;
    1: 
    1:     do {
    1:         done = JS_TRUE;
    1:         delta = 0;
    1:         top = pivot = -1;
    1:         sdtop = NULL;
    1:         pc = NULL;
    1:         op = JSOP_NOP;
    1:         type = 0;
    1: #ifdef DEBUG_brendan
    1:         passes++;
    1: #endif
    1: 
    1:         for (sd = sdbase; sd < sdlimit; sd++) {
    1:             JS_ASSERT(JT_HAS_TAG(sd->target));
    1:             sd->offset += delta;
    1: 
    1:             if (sd->top != top) {
    1:                 sdtop = sd;
    1:                 top = sd->top;
    1:                 JS_ASSERT(top == sd->before);
    1:                 pivot = sd->offset;
    1:                 pc = base + top;
    1:                 op = (JSOp) *pc;
11377:                 type = JOF_OPTYPE(op);
    1:                 if (JOF_TYPE_IS_EXTENDED_JUMP(type)) {
    1:                     /*
    1:                      * We already extended all the jump offset operands for
    1:                      * the opcode at sd->top.  Jumps and branches have only
    1:                      * one jump offset operand, but switches have many, all
80966:                      * of which are adjacent in bce->spanDeps.
    1:                      */
    1:                     continue;
    1:                 }
    1: 
    1:                 JS_ASSERT(type == JOF_JUMP ||
    1:                           type == JOF_TABLESWITCH ||
    1:                           type == JOF_LOOKUPSWITCH);
    1:             }
    1: 
    1:             if (!JOF_TYPE_IS_EXTENDED_JUMP(type)) {
    1:                 span = SD_SPAN(sd, pivot);
    1:                 if (span < JUMP_OFFSET_MIN || JUMP_OFFSET_MAX < span) {
    1:                     ptrdiff_t deltaFromTop = 0;
    1: 
    1:                     done = JS_FALSE;
    1: 
    1:                     switch (op) {
    1:                       case JSOP_GOTO:         op = JSOP_GOTOX; break;
    1:                       case JSOP_IFEQ:         op = JSOP_IFEQX; break;
    1:                       case JSOP_IFNE:         op = JSOP_IFNEX; break;
    1:                       case JSOP_OR:           op = JSOP_ORX; break;
    1:                       case JSOP_AND:          op = JSOP_ANDX; break;
    1:                       case JSOP_GOSUB:        op = JSOP_GOSUBX; break;
    1:                       case JSOP_CASE:         op = JSOP_CASEX; break;
    1:                       case JSOP_DEFAULT:      op = JSOP_DEFAULTX; break;
    1:                       case JSOP_TABLESWITCH:  op = JSOP_TABLESWITCHX; break;
    1:                       case JSOP_LOOKUPSWITCH: op = JSOP_LOOKUPSWITCHX; break;
82079:                       case JSOP_LABEL:        op = JSOP_LABELX; break;
    1:                       default:
80966:                         ReportStatementTooLarge(cx, bce);
    1:                         return JS_FALSE;
    1:                     }
    1:                     *pc = (jsbytecode) op;
    1: 
    1:                     for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
    1:                         if (sd2 <= sd) {
    1:                             /*
    1:                              * sd2->offset already includes delta as it stood
    1:                              * before we entered this loop, but it must also
    1:                              * include the delta relative to top due to all the
    1:                              * extended jump offset immediates for the opcode
    1:                              * starting at top, which we extend in this loop.
    1:                              *
    1:                              * If there is only one extended jump offset, then
    1:                              * sd2->offset won't change and this for loop will
    1:                              * iterate once only.
    1:                              */
    1:                             sd2->offset += deltaFromTop;
    1:                             deltaFromTop += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
    1:                         } else {
    1:                             /*
    1:                              * sd2 comes after sd, and won't be revisited by
    1:                              * the outer for loop, so we have to increase its
    1:                              * offset by delta, not merely by deltaFromTop.
    1:                              */
    1:                             sd2->offset += delta;
    1:                         }
    1: 
    1:                         delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
80966:                         UpdateJumpTargets(bce->jumpTargets, sd2->offset,
    1:                                           JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
    1:                     }
    1:                     sd = sd2 - 1;
    1:                 }
    1:             }
    1:         }
    1: 
    1:         growth += delta;
    1:     } while (!done);
    1: 
    1:     if (growth) {
    1: #ifdef DEBUG_brendan
80966:         TokenStream *ts = &bce->parser->tokenStream;
10217: 
    1:         printf("%s:%u: %u/%u jumps extended in %d passes (%d=%d+%d)\n",
80966:                ts->filename ? ts->filename : "stdin", bce->firstLine,
80966:                growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), bce->numSpanDeps,
    1:                passes, offset + growth, offset, growth);
    1: #endif
    1: 
    1:         /*
    1:          * Ensure that we have room for the extended jumps, but don't round up
    1:          * to a power of two -- we're done generating code, so we cut to fit.
    1:          */
80966:         limit = bce->limit();
    1:         length = offset + growth;
    1:         next = base + length;
    1:         if (next > limit) {
77950:             base = (jsbytecode *) cx->realloc_(base, BYTECODE_SIZE(length));
    1:             if (!base) {
71371:                 js_ReportOutOfMemory(cx);
    1:                 return JS_FALSE;
    1:             }
80966:             bce->current->base = base;
80966:             bce->current->limit = next = base + length;
80966:         }
80966:         bce->current->next = next;
    1: 
    1:         /*
    1:          * Set up a fake span dependency record to guard the end of the code
    1:          * being generated.  This guard record is returned as a fencepost by
    1:          * FindNearestSpanDep if there is no real spandep at or above a given
    1:          * unextended code offset.
    1:          */
    1:         guard.top = -1;
    1:         guard.offset = offset + growth;
    1:         guard.before = offset;
    1:         guard.target = NULL;
    1:     }
    1: 
    1:     /*
    1:      * Now work backwards through the span dependencies, copying chunks of
    1:      * bytecode between each extended jump toward the end of the grown code
    1:      * space, and restoring immediate offset operands for all jump bytecodes.
    1:      * The first chunk of bytecodes, starting at base and ending at the first
    1:      * extended jump offset (NB: this chunk includes the operation bytecode
    1:      * just before that immediate jump offset), doesn't need to be copied.
    1:      */
    1:     JS_ASSERT(sd == sdlimit);
    1:     top = -1;
    1:     while (--sd >= sdbase) {
    1:         if (sd->top != top) {
    1:             top = sd->top;
    1:             op = (JSOp) base[top];
11377:             type = JOF_OPTYPE(op);
    1: 
    1:             for (sd2 = sd - 1; sd2 >= sdbase && sd2->top == top; sd2--)
    1:                 continue;
    1:             sd2++;
    1:             pivot = sd2->offset;
    1:             JS_ASSERT(top == sd2->before);
    1:         }
    1: 
    1:         oldpc = base + sd->before;
    1:         span = SD_SPAN(sd, pivot);
    1: 
    1:         /*
    1:          * If this jump didn't need to be extended, restore its span immediate
80966:          * offset operand now, overwriting the index of sd within bce->spanDeps
    1:          * that was stored temporarily after *pc when BuildSpanDepTable ran.
    1:          *
    1:          * Note that span might fit in 16 bits even for an extended jump op,
    1:          * if the op has multiple span operands, not all of which overflowed
    1:          * (e.g. JSOP_LOOKUPSWITCH or JSOP_TABLESWITCH where some cases are in
    1:          * range for a short jump, but others are not).
    1:          */
    1:         if (!JOF_TYPE_IS_EXTENDED_JUMP(type)) {
    1:             JS_ASSERT(JUMP_OFFSET_MIN <= span && span <= JUMP_OFFSET_MAX);
    1:             SET_JUMP_OFFSET(oldpc, span);
    1:             continue;
    1:         }
    1: 
    1:         /*
    1:          * Set up parameters needed to copy the next run of bytecode starting
    1:          * at offset (which is a cursor into the unextended, original bytecode
    1:          * vector), down to sd->before (a cursor of the same scale as offset,
    1:          * it's the index of the original jump pc).  Reuse delta to count the
    1:          * nominal number of bytes to copy.
    1:          */
    1:         pc = base + sd->offset;
    1:         delta = offset - sd->before;
    1:         JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
    1: 
    1:         /*
    1:          * Don't bother copying the jump offset we're about to reset, but do
    1:          * copy the bytecode at oldpc (which comes just before its immediate
    1:          * jump offset operand), on the next iteration through the loop, by
    1:          * including it in offset's new value.
    1:          */
    1:         offset = sd->before + 1;
77950:         size_t size = BYTECODE_SIZE(delta - (1 + JUMP_OFFSET_LEN));
    1:         if (size) {
    1:             memmove(pc + 1 + JUMPX_OFFSET_LEN,
    1:                     oldpc + 1 + JUMP_OFFSET_LEN,
    1:                     size);
    1:         }
    1: 
    1:         SET_JUMPX_OFFSET(pc, span);
    1:     }
    1: 
    1:     if (growth) {
    1:         /*
    1:          * Fix source note deltas.  Don't hardwire the delta fixup adjustment,
    1:          * even though currently it must be JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN
    1:          * at each sd that moved.  The future may bring different offset sizes
    1:          * for span-dependent instruction operands.  However, we fix only main
    1:          * notes here, not prolog notes -- we know that prolog opcodes are not
    1:          * span-dependent, and aren't likely ever to be.
    1:          */
    1:         offset = growth = 0;
    1:         sd = sdbase;
80966:         for (sn = bce->main.notes, snlimit = sn + bce->main.noteCount;
    1:              sn < snlimit;
    1:              sn = SN_NEXT(sn)) {
    1:             /*
    1:              * Recall that the offset of a given note includes its delta, and
    1:              * tells the offset of the annotated bytecode from the main entry
    1:              * point of the script.
    1:              */
    1:             offset += SN_DELTA(sn);
    1:             while (sd < sdlimit && sd->before < offset) {
    1:                 /*
    1:                  * To compute the delta to add to sn, we need to look at the
    1:                  * spandep after sd, whose offset - (before + growth) tells by
    1:                  * how many bytes sd's instruction grew.
    1:                  */
    1:                 sd2 = sd + 1;
    1:                 if (sd2 == sdlimit)
    1:                     sd2 = &guard;
    1:                 delta = sd2->offset - (sd2->before + growth);
    1:                 if (delta > 0) {
    1:                     JS_ASSERT(delta == JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
80966:                     sn = AddToSrcNoteDelta(cx, bce, sn, delta);
    1:                     if (!sn)
    1:                         return JS_FALSE;
80966:                     snlimit = bce->main.notes + bce->main.noteCount;
    1:                     growth += delta;
    1:                 }
    1:                 sd++;
    1:             }
    1: 
    1:             /*
    1:              * If sn has span-dependent offset operands, check whether each
    1:              * covers further span-dependencies, and increase those operands
    1:              * accordingly.  Some source notes measure offset not from the
    1:              * annotated pc, but from that pc plus some small bias.  NB: we
    1:              * assume that spec->offsetBias can't itself span span-dependent
    1:              * instructions!
    1:              */
    1:             spec = &js_SrcNoteSpec[SN_TYPE(sn)];
    1:             if (spec->isSpanDep) {
    1:                 pivot = offset + spec->offsetBias;
    1:                 n = spec->arity;
    1:                 for (i = 0; i < n; i++) {
    1:                     span = js_GetSrcNoteOffset(sn, i);
    1:                     if (span == 0)
    1:                         continue;
    1:                     target = pivot + span * spec->isSpanDep;
80966:                     sd2 = FindNearestSpanDep(bce, target,
    1:                                              (target >= pivot)
    1:                                              ? sd - sdbase
    1:                                              : 0,
    1:                                              &guard);
    1: 
    1:                     /*
    1:                      * Increase target by sd2's before-vs-after offset delta,
    1:                      * which is absolute (i.e., relative to start of script,
    1:                      * as is target).  Recompute the span by subtracting its
    1:                      * adjusted pivot from target.
    1:                      */
    1:                     target += sd2->offset - sd2->before;
    1:                     span = target - (pivot + growth);
    1:                     span *= spec->isSpanDep;
80966:                     noteIndex = sn - bce->main.notes;
80966:                     if (!SetSrcNoteOffset(cx, bce, noteIndex, i, span))
80966:                         return JS_FALSE;
80966:                     sn = bce->main.notes + noteIndex;
80966:                     snlimit = bce->main.notes + bce->main.noteCount;
80966:                 }
80966:             }
80966:         }
80966:         bce->main.lastNoteOffset += growth;
    1: 
    1:         /*
    1:          * Fix try/catch notes (O(numTryNotes * log2(numSpanDeps)), but it's
    1:          * not clear how we can beat that).
    1:          */
80966:         for (tryNode = bce->lastTryNode; tryNode; tryNode = tryNode->prev) {
    1:             /*
    1:              * First, look for the nearest span dependency at/above tn->start.
    1:              * There may not be any such spandep, in which case the guard will
    1:              * be returned.
    1:              */
 3025:             offset = tryNode->note.start;
80966:             sd = FindNearestSpanDep(bce, offset, 0, &guard);
    1:             delta = sd->offset - sd->before;
 3025:             tryNode->note.start = offset + delta;
    1: 
    1:             /*
    1:              * Next, find the nearest spandep at/above tn->start + tn->length.
    1:              * Use its delta minus tn->start's delta to increase tn->length.
    1:              */
 3025:             length = tryNode->note.length;
80966:             sd2 = FindNearestSpanDep(bce, offset + length, sd - sdbase, &guard);
 3025:             if (sd2 != sd) {
 3025:                 tryNode->note.length =
 3025:                     length + sd2->offset - sd2->before - delta;
 3025:             }
    1:         }
    1:     }
    1: 
    1: #ifdef DEBUG_brendan
    1:   {
    1:     uintN bigspans = 0;
    1:     top = -1;
    1:     for (sd = sdbase; sd < sdlimit; sd++) {
    1:         offset = sd->offset;
    1: 
    1:         /* NB: sd->top cursors into the original, unextended bytecode vector. */
    1:         if (sd->top != top) {
    1:             JS_ASSERT(top == -1 ||
    1:                       !JOF_TYPE_IS_EXTENDED_JUMP(type) ||
    1:                       bigspans != 0);
    1:             bigspans = 0;
    1:             top = sd->top;
    1:             JS_ASSERT(top == sd->before);
    1:             op = (JSOp) base[offset];
11377:             type = JOF_OPTYPE(op);
    1:             JS_ASSERT(type == JOF_JUMP ||
    1:                       type == JOF_JUMPX ||
    1:                       type == JOF_TABLESWITCH ||
    1:                       type == JOF_TABLESWITCHX ||
    1:                       type == JOF_LOOKUPSWITCH ||
    1:                       type == JOF_LOOKUPSWITCHX);
    1:             pivot = offset;
    1:         }
    1: 
    1:         pc = base + offset;
    1:         if (JOF_TYPE_IS_EXTENDED_JUMP(type)) {
    1:             span = GET_JUMPX_OFFSET(pc);
    1:             if (span < JUMP_OFFSET_MIN || JUMP_OFFSET_MAX < span) {
    1:                 bigspans++;
    1:             } else {
    1:                 JS_ASSERT(type == JOF_TABLESWITCHX ||
    1:                           type == JOF_LOOKUPSWITCHX);
    1:             }
    1:         } else {
    1:             span = GET_JUMP_OFFSET(pc);
    1:         }
    1:         JS_ASSERT(SD_SPAN(sd, pivot) == span);
    1:     }
    1:     JS_ASSERT(!JOF_TYPE_IS_EXTENDED_JUMP(type) || bigspans != 0);
    1:   }
    1: #endif
    1: 
    1:     /*
80966:      * Reset so we optimize at most once -- bce may be used for further code
    1:      * generation of successive, independent, top-level statements.  No jump
    1:      * can span top-level statements, because JS lacks goto.
    1:      */
80966:     cx->free_(bce->spanDeps);
80966:     bce->spanDeps = NULL;
80966:     FreeJumpTargets(bce, bce->jumpTargets);
80966:     bce->jumpTargets = NULL;
80966:     bce->numSpanDeps = bce->numJumpTargets = 0;
80966:     bce->spanDepTodo = bce->offset();
    1:     return JS_TRUE;
    1: }
    1: 
18998: static ptrdiff_t
80966: EmitJump(JSContext *cx, BytecodeEmitter *bce, JSOp op, ptrdiff_t off)
    1: {
    1:     JSBool extend;
    1:     ptrdiff_t jmp;
    1:     jsbytecode *pc;
    1: 
    1:     extend = off < JUMP_OFFSET_MIN || JUMP_OFFSET_MAX < off;
80966:     if (extend && !bce->spanDeps && !BuildSpanDepTable(cx, bce))
18998:         return -1;
    1: 
80966:     jmp = Emit3(cx, bce, op, JUMP_OFFSET_HI(off), JUMP_OFFSET_LO(off));
80966:     if (jmp >= 0 && (extend || bce->spanDeps)) {
80966:         pc = bce->code(jmp);
80966:         if (!AddSpanDep(cx, bce, pc, pc, off))
18998:             return -1;
    1:     }
    1:     return jmp;
    1: }
    1: 
    1: static ptrdiff_t
80966: GetJumpOffset(BytecodeEmitter *bce, jsbytecode *pc)
80966: {
80966:     if (!bce->spanDeps)
    1:         return GET_JUMP_OFFSET(pc);
    1: 
80966:     SpanDep *sd = GetSpanDep(bce, pc);
80631:     JumpTarget *jt = sd->target;
    1:     if (!JT_HAS_TAG(jt))
    1:         return JT_TO_BPDELTA(jt);
    1: 
80631:     ptrdiff_t top = sd->top;
80966:     while (--sd >= bce->spanDeps && sd->top == top)
    1:         continue;
    1:     sd++;
    1:     return JT_CLR_TAG(jt)->offset - sd->offset;
    1: }
    1: 
    1: JSBool
80966: frontend::SetJumpOffset(JSContext *cx, BytecodeEmitter *bce, jsbytecode *pc, ptrdiff_t off)
80966: {
80966:     if (!bce->spanDeps) {
    1:         if (JUMP_OFFSET_MIN <= off && off <= JUMP_OFFSET_MAX) {
    1:             SET_JUMP_OFFSET(pc, off);
    1:             return JS_TRUE;
    1:         }
    1: 
80966:         if (!BuildSpanDepTable(cx, bce))
80966:             return JS_FALSE;
80966:     }
80966: 
80966:     return SetSpanDepTarget(cx, bce, GetSpanDep(bce, pc), off);
    1: }
    1: 
27012: bool
80631: TreeContext::inStatement(StmtType type)
80631: {
80631:     for (StmtInfo *stmt = topStmt; stmt; stmt = stmt->down) {
    1:         if (stmt->type == type)
27012:             return true;
27012:     }
27012:     return false;
    1: }
    1: 
32729: bool
80631: TreeContext::ensureSharpSlots()
32729: {
32729: #if JS_HAS_SHARP_VARS
32772:     JS_STATIC_ASSERT(SHARP_NSLOTS == 2);
32772: 
32729:     if (sharpSlotBase >= 0) {
32729:         JS_ASSERT(flags & TCF_HAS_SHARPS);
32729:         return true;
32729:     }
32729: 
32729:     JS_ASSERT(!(flags & TCF_HAS_SHARPS));
41884:     if (inFunction()) {
40860:         JSContext *cx = parser->context;
70270:         JSAtom *sharpArrayAtom = js_Atomize(cx, "#array", 6);
70270:         JSAtom *sharpDepthAtom = js_Atomize(cx, "#depth", 6);
32729:         if (!sharpArrayAtom || !sharpDepthAtom)
32729:             return false;
32729: 
59968:         sharpSlotBase = bindings.countVars();
59968:         if (!bindings.addVariable(cx, sharpArrayAtom))
32729:             return false;
59968:         if (!bindings.addVariable(cx, sharpDepthAtom))
32729:             return false;
32729:     } else {
32729:         /*
80991:          * js::frontend::CompileScript will rebase immediate operands
80634:          * indexing the sharp slots to come at the end of the global script's
80634:          * |nfixed| slots storage, after gvars and regexps.
32729:          */
32729:         sharpSlotBase = 0;
32729:     }
32729:     flags |= TCF_HAS_SHARPS;
32729: #endif
32729:     return true;
32729: }
32729: 
37731: bool
80631: TreeContext::skipSpansGenerator(unsigned skip)
80631: {
80631:     TreeContext *tc = this;
37731:     for (unsigned i = 0; i < skip; ++i, tc = tc->parent) {
37738:         if (!tc)
37738:             return false;
37731:         if (tc->flags & TCF_FUN_IS_GENERATOR)
37731:             return true;
37731:     }
37731:     return false;
37731: }
37731: 
80507: bool
80786: frontend::SetStaticLevel(TreeContext *tc, uintN staticLevel)
80507: {
80507:     /*
80507:      * This is a lot simpler than error-checking every UpvarCookie::set, and
80507:      * practically speaking it leaves more than enough room for upvars.
80507:      */
80507:     if (UpvarCookie::isLevelReserved(staticLevel)) {
80507:         JS_ReportErrorNumber(tc->parser->context, js_GetErrorMessage, NULL,
80507:                              JSMSG_TOO_DEEP, js_function_str);
80507:         return false;
80507:     }
80507:     tc->staticLevel = staticLevel;
80507:     return true;
80507: }
80507: 
80507: bool
80786: frontend::GenerateBlockId(TreeContext *tc, uint32& blockid)
80507: {
80507:     if (tc->blockidGen == JS_BIT(20)) {
80507:         JS_ReportErrorNumber(tc->parser->context, js_GetErrorMessage, NULL,
80507:                              JSMSG_NEED_DIET, "program");
80507:         return false;
80507:     }
80507:     blockid = tc->blockidGen++;
80507:     return true;
80507: }
80507: 
    1: void
80786: frontend::PushStatement(TreeContext *tc, StmtInfo *stmt, StmtType type, ptrdiff_t top)
    1: {
    1:     stmt->type = type;
    1:     stmt->flags = 0;
27012:     stmt->blockid = tc->blockid();
    1:     SET_STATEMENT_TOP(stmt, top);
27012:     stmt->label = NULL;
54855:     JS_ASSERT(!stmt->blockBox);
    1:     stmt->down = tc->topStmt;
    1:     tc->topStmt = stmt;
    1:     if (STMT_LINKS_SCOPE(stmt)) {
    1:         stmt->downScope = tc->topScopeStmt;
    1:         tc->topScopeStmt = stmt;
    1:     } else {
    1:         stmt->downScope = NULL;
    1:     }
    1: }
    1: 
    1: void
80786: frontend::PushBlockScope(TreeContext *tc, StmtInfo *stmt, ObjectBox *blockBox, ptrdiff_t top)
80632: {
80632:     PushStatement(tc, stmt, STMT_BLOCK, top);
    1:     stmt->flags |= SIF_SCOPE;
56177:     blockBox->parent = tc->blockChainBox;
54855:     blockBox->object->setParent(tc->blockChain());
    1:     stmt->downScope = tc->topScopeStmt;
    1:     tc->topScopeStmt = stmt;
54855:     tc->blockChainBox = blockBox;
54855:     stmt->blockBox = blockBox;
    1: }
    1: 
    1: /*
    1:  * Emit a backpatch op with offset pointing to the previous jump of this type,
    1:  * so that we can walk back up the chain fixing up the op and jump offset.
    1:  */
    1: static ptrdiff_t
80966: EmitBackPatchOp(JSContext *cx, BytecodeEmitter *bce, JSOp op, ptrdiff_t *lastp)
    1: {
    1:     ptrdiff_t offset, delta;
    1: 
80966:     offset = bce->offset();
    1:     delta = offset - *lastp;
    1:     *lastp = offset;
    1:     JS_ASSERT(delta > 0);
80966:     return EmitJump(cx, bce, op, delta);
    1: }
    1: 
80632: /* A macro for inlining at the top of EmitTree (whence it came). */
80966: #define UPDATE_LINE_NUMBER_NOTES(cx, bce, line)                               \
    1:     JS_BEGIN_MACRO                                                            \
28739:         uintN line_ = (line);                                                 \
80966:         uintN delta_ = line_ - bce->currentLine();                            \
    1:         if (delta_ != 0) {                                                    \
    1:             /*                                                                \
    1:              * Encode any change in the current source line number by using   \
    1:              * either several SRC_NEWLINE notes or just one SRC_SETLINE note, \
    1:              * whichever consumes less space.                                 \
    1:              *                                                                \
    1:              * NB: We handle backward line number deltas (possible with for   \
    1:              * loops where the update part is emitted after the body, but its \
    1:              * line number is <= any line number in the body) here by letting \
    1:              * unsigned delta_ wrap to a very large number, which triggers a  \
    1:              * SRC_SETLINE.                                                   \
    1:              */                                                               \
80966:             bce->current->currentLine = line_;                                \
    1:             if (delta_ >= (uintN)(2 + ((line_ > SN_3BYTE_OFFSET_MASK)<<1))) { \
80966:                 if (NewSrcNote2(cx, bce, SRC_SETLINE, (ptrdiff_t)line_) < 0)  \
    1:                     return JS_FALSE;                                          \
    1:             } else {                                                          \
    1:                 do {                                                          \
80966:                     if (NewSrcNote(cx, bce, SRC_NEWLINE) < 0)                 \
    1:                         return JS_FALSE;                                      \
    1:                 } while (--delta_ != 0);                                      \
    1:             }                                                                 \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
    1: /* A function, so that we avoid macro-bloating all the other callsites. */
    1: static JSBool
80966: UpdateLineNumberNotes(JSContext *cx, BytecodeEmitter *bce, uintN line)
80966: {
80966:     UPDATE_LINE_NUMBER_NOTES(cx, bce, line);
    1:     return JS_TRUE;
    1: }
    1: 
75502: static ptrdiff_t
80966: EmitTraceOp(JSContext *cx, BytecodeEmitter *bce, ParseNode *nextpn)
75502: {
75502:     if (nextpn) {
75502:         /*
75502:          * Try to give the JSOP_TRACE the same line number as the next
75502:          * instruction. nextpn is often a block, in which case the next
75502:          * instruction typically comes from the first statement inside.
75502:          */
82024:         if (nextpn->isKind(PNK_LC) && nextpn->isArity(PN_LIST) && nextpn->pn_head)
75502:             nextpn = nextpn->pn_head;
80966:         if (!UpdateLineNumberNotes(cx, bce, nextpn->pn_pos.begin.lineno))
75502:             return -1;
75502:     }
75502: 
80966:     uint32 index = bce->traceIndex;
75502:     if (index < UINT16_MAX)
80966:         bce->traceIndex++;
80966:     return Emit3(cx, bce, JSOP_TRACE, UINT16_HI(index), UINT16_LO(index));
75502: }
75502: 
75502: /*
77434:  * If op is JOF_TYPESET (see the type barriers comment in jsinfer.h), reserve
77434:  * a type set to store its result.
77434:  */
77434: static inline void
80966: CheckTypeSet(JSContext *cx, BytecodeEmitter *bce, JSOp op)
77434: {
77434:     if (js_CodeSpec[op].format & JOF_TYPESET) {
80966:         if (bce->typesetCount < UINT16_MAX)
80966:             bce->typesetCount++;
77434:     }
77434: }
77434: 
77434: /*
75502:  * Macro to emit a bytecode followed by a uint16 immediate operand stored in
75502:  * big-endian order, used for arg and var numbers as well as for atomIndexes.
80966:  * NB: We use cx and bce from our caller's lexical environment, and return
75502:  * false on error.
75502:  */
75502: #define EMIT_UINT16_IMM_OP(op, i)                                             \
75502:     JS_BEGIN_MACRO                                                            \
80966:         if (Emit3(cx, bce, op, UINT16_HI(i), UINT16_LO(i)) < 0)               \
75502:             return JS_FALSE;                                                  \
80966:         CheckTypeSet(cx, bce, op);                                            \
75502:     JS_END_MACRO
75502: 
75502: #define EMIT_UINT16PAIR_IMM_OP(op, i, j)                                      \
75502:     JS_BEGIN_MACRO                                                            \
80966:         ptrdiff_t off_ = EmitN(cx, bce, op, 2 * UINT16_LEN);                  \
75502:         if (off_ < 0)                                                         \
75502:             return JS_FALSE;                                                  \
80966:         jsbytecode *pc_ = bce->code(off_);                                 \
75502:         SET_UINT16(pc_, i);                                                   \
75502:         pc_ += UINT16_LEN;                                                    \
75502:         SET_UINT16(pc_, j);                                                   \
75502:     JS_END_MACRO
75502: 
75502: #define EMIT_UINT16_IN_PLACE(offset, op, i)                                   \
75502:     JS_BEGIN_MACRO                                                            \
80966:         bce->code(offset)[0] = op;                                         \
80966:         bce->code(offset)[1] = UINT16_HI(i);                               \
80966:         bce->code(offset)[2] = UINT16_LO(i);                               \
75502:     JS_END_MACRO
75502: 
75502: static JSBool
80966: FlushPops(JSContext *cx, BytecodeEmitter *bce, intN *npops)
75502: {
75502:     JS_ASSERT(*npops != 0);
80966:     if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
75502:         return JS_FALSE;
75502:     EMIT_UINT16_IMM_OP(JSOP_POPN, *npops);
75502:     *npops = 0;
75502:     return JS_TRUE;
75502: }
75502: 
75502: /*
75502:  * Emit additional bytecode(s) for non-local jumps.
75502:  */
75502: static JSBool
80966: EmitNonLocalJumpFixup(JSContext *cx, BytecodeEmitter *bce, StmtInfo *toStmt)
80966: {
80966:     /*
80966:      * The non-local jump fixup we emit will unbalance bce->stackDepth, because
75502:      * the fixup replicates balanced code such as JSOP_LEAVEWITH emitted at the
80966:      * end of a with statement, so we save bce->stackDepth here and restore it
75502:      * just before a successful return.
75502:      */
80966:     intN depth = bce->stackDepth;
80631:     intN npops = 0;
75502: 
80966: #define FLUSH_POPS() if (npops && !FlushPops(cx, bce, &npops)) return JS_FALSE
80966: 
80966:     for (StmtInfo *stmt = bce->topStmt; stmt != toStmt; stmt = stmt->down) {
75502:         switch (stmt->type) {
75502:           case STMT_FINALLY:
75502:             FLUSH_POPS();
80966:             if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
80966:                 return JS_FALSE;
80966:             if (EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, &GOSUBS(*stmt)) < 0)
75502:                 return JS_FALSE;
75502:             break;
75502: 
75502:           case STMT_WITH:
75502:             /* There's a With object on the stack that we need to pop. */
75502:             FLUSH_POPS();
80966:             if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
80966:                 return JS_FALSE;
80966:             if (Emit1(cx, bce, JSOP_LEAVEWITH) < 0)
75502:                 return JS_FALSE;
75502:             break;
75502: 
75502:           case STMT_FOR_IN_LOOP:
75502:             /*
75502:              * The iterator and the object being iterated need to be popped.
75502:              */
75502:             FLUSH_POPS();
80966:             if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
80966:                 return JS_FALSE;
80966:             if (Emit1(cx, bce, JSOP_ENDITER) < 0)
75502:                 return JS_FALSE;
75502:             break;
75502: 
75502:           case STMT_SUBROUTINE:
75502:             /*
75502:              * There's a [exception or hole, retsub pc-index] pair on the
75502:              * stack that we need to pop.
75502:              */
75502:             npops += 2;
75502:             break;
75502: 
75502:           default:;
75502:         }
75502: 
75502:         if (stmt->flags & SIF_SCOPE) {
75502:             /* There is a Block object with locals on the stack to pop. */
75502:             FLUSH_POPS();
80966:             if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
80966:                 return JS_FALSE;
80966:             if (!EmitLeaveBlock(cx, bce, JSOP_LEAVEBLOCK, stmt->blockBox))
75502:                 return JS_FALSE;
75502:         }
75502:     }
75502: 
75502:     FLUSH_POPS();
80966:     bce->stackDepth = depth;
75502:     return JS_TRUE;
75502: 
75502: #undef FLUSH_POPS
75502: }
75502: 
75502: static JSBool
80966: EmitKnownBlockChain(JSContext *cx, BytecodeEmitter *bce, ObjectBox *box)
75502: {
75502:     if (box)
80966:         return EmitIndexOp(cx, JSOP_BLOCKCHAIN, box->index, bce);
80966:     return Emit1(cx, bce, JSOP_NULLBLOCKCHAIN) >= 0;
75502: }
75502: 
75502: static JSBool
80966: EmitBlockChain(JSContext *cx, BytecodeEmitter *bce)
80966: {
80966:     return EmitKnownBlockChain(cx, bce, bce->blockChainBox);
75502: }
75502: 
75510: static const jsatomid INVALID_ATOMID = -1;
75510: 
75502: static ptrdiff_t
80966: EmitGoto(JSContext *cx, BytecodeEmitter *bce, StmtInfo *toStmt, ptrdiff_t *lastp,
80631:          jsatomid labelIndex = INVALID_ATOMID, SrcNoteType noteType = SRC_NULL)
75502: {
75502:     intN index;
75502: 
80966:     if (!EmitNonLocalJumpFixup(cx, bce, toStmt))
75502:         return -1;
75502: 
75510:     if (labelIndex != INVALID_ATOMID)
80966:         index = NewSrcNote2(cx, bce, noteType, ptrdiff_t(labelIndex));
75502:     else if (noteType != SRC_NULL)
80966:         index = NewSrcNote(cx, bce, noteType);
75502:     else
75502:         index = 0;
75502:     if (index < 0)
75502:         return -1;
75502: 
80966:     ptrdiff_t result = EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, lastp);
75502:     if (result < 0)
75502:         return result;
75502: 
80966:     if (!EmitBlockChain(cx, bce))
75502:         return -1;
75502: 
75502:     return result;
75502: }
75502: 
75502: static JSBool
80966: BackPatch(JSContext *cx, BytecodeEmitter *bce, ptrdiff_t last, jsbytecode *target, jsbytecode op)
75502: {
75502:     jsbytecode *pc, *stop;
75502:     ptrdiff_t delta, span;
75502: 
80966:     pc = bce->code(last);
80966:     stop = bce->code(-1);
75502:     while (pc != stop) {
80966:         delta = GetJumpOffset(bce, pc);
75502:         span = target - pc;
80966:         CHECK_AND_SET_JUMP_OFFSET(cx, bce, pc, span);
75502: 
75502:         /*
75502:          * Set *pc after jump offset in case bpdelta didn't overflow, but span
75502:          * does (if so, CHECK_AND_SET_JUMP_OFFSET might call BuildSpanDepTable
75502:          * and need to see the JSOP_BACKPATCH* op at *pc).
75502:          */
75502:         *pc = op;
75502:         pc -= delta;
75502:     }
75502:     return JS_TRUE;
75502: }
75502: 
75502: void
80786: frontend::PopStatementTC(TreeContext *tc)
80631: {
80631:     StmtInfo *stmt = tc->topStmt;
75502:     tc->topStmt = stmt->down;
75502:     if (STMT_LINKS_SCOPE(stmt)) {
75502:         tc->topScopeStmt = stmt->downScope;
75502:         if (stmt->flags & SIF_SCOPE) {
75502:             tc->blockChainBox = stmt->blockBox->parent;
75502:         }
75502:     }
75502: }
75502: 
75502: JSBool
80966: frontend::PopStatementBCE(JSContext *cx, BytecodeEmitter *bce)
80966: {
80966:     StmtInfo *stmt = bce->topStmt;
75502:     if (!STMT_IS_TRYING(stmt) &&
80966:         (!BackPatch(cx, bce, stmt->breaks, bce->next(), JSOP_GOTO) ||
80966:          !BackPatch(cx, bce, stmt->continues, bce->code(stmt->update),
75502:                     JSOP_GOTO))) {
75502:         return JS_FALSE;
75502:     }
80966:     PopStatementTC(bce);
75502:     return JS_TRUE;
75502: }
75502: 
75502: JSBool
80966: frontend::DefineCompileTimeConstant(JSContext *cx, BytecodeEmitter *bce, JSAtom *atom, ParseNode *pn)
75502: {
75502:     /* XXX just do numbers for now */
82024:     if (pn->isKind(PNK_NUMBER)) {
80966:         if (!bce->constMap.put(atom, NumberValue(pn->pn_dval)))
75502:             return JS_FALSE;
75502:     }
75502:     return JS_TRUE;
75502: }
75502: 
80631: StmtInfo *
80786: frontend::LexicalLookup(TreeContext *tc, JSAtom *atom, jsint *slotp, StmtInfo *stmt)
75502: {
75502:     if (!stmt)
75502:         stmt = tc->topScopeStmt;
75502:     for (; stmt; stmt = stmt->downScope) {
75502:         if (stmt->type == STMT_WITH)
75502:             break;
75502: 
75502:         /* Skip "maybe scope" statements that don't contain let bindings. */
75502:         if (!(stmt->flags & SIF_SCOPE))
75502:             continue;
75502: 
75502:         JSObject *obj = stmt->blockBox->object;
75502:         JS_ASSERT(obj->isStaticBlock());
75502: 
78194:         const Shape *shape = obj->nativeLookup(tc->parser->context, ATOM_TO_JSID(atom));
75502:         if (shape) {
75502:             JS_ASSERT(shape->hasShortID());
75502: 
75502:             if (slotp) {
75502:                 JS_ASSERT(obj->getSlot(JSSLOT_BLOCK_DEPTH).isInt32());
75502:                 *slotp = obj->getSlot(JSSLOT_BLOCK_DEPTH).toInt32() + shape->shortid;
75502:             }
75502:             return stmt;
75502:         }
75502:     }
75502: 
75502:     if (slotp)
75502:         *slotp = -1;
75502:     return stmt;
75502: }
75502: 
75502: /*
75502:  * The function sets vp to NO_CONSTANT when the atom does not corresponds to a
75502:  * name defining a constant.
75502:  */
75502: static JSBool
80966: LookupCompileTimeConstant(JSContext *cx, BytecodeEmitter *bce, JSAtom *atom, Value *constp)
80966: {
80966:     /*
80966:      * Chase down the bce stack, but only until we reach the outermost bce.
75502:      * This enables propagating consts from top-level into switch cases in a
75502:      * function compiled along with the top-level script.
75502:      */
75502:     constp->setMagic(JS_NO_CONSTANT);
75502:     do {
80966:         if (bce->inFunction() || bce->compileAndGo()) {
75502:             /* XXX this will need revising if 'const' becomes block-scoped. */
80966:             StmtInfo *stmt = LexicalLookup(bce, atom, NULL);
75502:             if (stmt)
75502:                 return JS_TRUE;
75502: 
80966:             if (BytecodeEmitter::ConstMap::Ptr p = bce->constMap.lookup(atom)) {
75502:                 JS_ASSERT(!p->value.isMagic(JS_NO_CONSTANT));
75502:                 *constp = p->value;
75502:                 return JS_TRUE;
75502:             }
75502: 
75502:             /*
75502:              * Try looking in the variable object for a direct property that
75502:              * is readonly and permanent.  We know such a property can't be
75502:              * shadowed by another property on obj's prototype chain, or a
75502:              * with object or catch variable; nor can prop's value be changed,
75502:              * nor can prop be deleted.
75502:              */
80966:             if (bce->inFunction()) {
80966:                 if (bce->bindings.hasBinding(cx, atom))
75502:                     break;
75502:             } else {
80966:                 JS_ASSERT(bce->compileAndGo());
80966:                 JSObject *obj = bce->scopeChain();
75502: 
78194:                 const Shape *shape = obj->nativeLookup(cx, ATOM_TO_JSID(atom));
75502:                 if (shape) {
75502:                     /*
75502:                      * We're compiling code that will be executed immediately,
75502:                      * not re-executed against a different scope chain and/or
75502:                      * variable object.  Therefore we can get constant values
75502:                      * from our variable object here.
75502:                      */
75502:                     if (!shape->writable() && !shape->configurable() &&
75502:                         shape->hasDefaultGetter() && obj->containsSlot(shape->slot)) {
75502:                         *constp = obj->getSlot(shape->slot);
75502:                     }
75502:                 }
75502: 
75502:                 if (shape)
75502:                     break;
75502:             }
75502:         }
80966:     } while (bce->parent && (bce = bce->parent->asBytecodeEmitter()));
75502:     return JS_TRUE;
75502: }
75502: 
75502: static inline bool
75502: FitsWithoutBigIndex(uintN index)
75502: {
75502:     return index < JS_BIT(16);
75502: }
75502: 
75502: /*
75502:  * Return JSOP_NOP to indicate that index fits 2 bytes and no index segment
75502:  * reset instruction is necessary, JSOP_FALSE to indicate an error or either
75502:  * JSOP_RESETBASE0 or JSOP_RESETBASE1 to indicate the reset bytecode to issue
75502:  * after the main bytecode sequence.
75502:  */
75502: static JSOp
80966: EmitBigIndexPrefix(JSContext *cx, BytecodeEmitter *bce, uintN index)
75502: {
75502:     uintN indexBase;
75502: 
75502:     /*
75502:      * We have max 3 bytes for indexes and check for INDEX_LIMIT overflow only
75502:      * for big indexes.
75502:      */
75502:     JS_STATIC_ASSERT(INDEX_LIMIT <= JS_BIT(24));
75502:     JS_STATIC_ASSERT(INDEX_LIMIT >=
75502:                      (JSOP_INDEXBASE3 - JSOP_INDEXBASE1 + 2) << 16);
75502: 
75502:     if (FitsWithoutBigIndex(index))
75502:         return JSOP_NOP;
75502:     indexBase = index >> 16;
75502:     if (indexBase <= JSOP_INDEXBASE3 - JSOP_INDEXBASE1 + 1) {
80966:         if (Emit1(cx, bce, (JSOp)(JSOP_INDEXBASE1 + indexBase - 1)) < 0)
75502:             return JSOP_FALSE;
75502:         return JSOP_RESETBASE0;
75502:     }
75502: 
75502:     if (index >= INDEX_LIMIT) {
75502:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
75502:                              JSMSG_TOO_MANY_LITERALS);
75502:         return JSOP_FALSE;
75502:     }
75502: 
80966:     if (Emit2(cx, bce, JSOP_INDEXBASE, (JSOp)indexBase) < 0)
75502:         return JSOP_FALSE;
75502:     return JSOP_RESETBASE;
75502: }
75502: 
75502: /*
75502:  * Emit a bytecode and its 2-byte constant index immediate operand. If the
75502:  * index requires more than 2 bytes, emit a prefix op whose 8-bit immediate
75502:  * operand effectively extends the 16-bit immediate of the prefixed opcode,
75502:  * by changing index "segment" (see jsinterp.c). We optimize segments 1-3
75502:  * with single-byte JSOP_INDEXBASE[123] codes.
75502:  *
75502:  * Such prefixing currently requires a suffix to restore the "zero segment"
75502:  * register setting, but this could be optimized further.
75502:  */
77456: static bool
80966: EmitIndexOp(JSContext *cx, JSOp op, uintN index, BytecodeEmitter *bce, JSOp *psuffix)
75502: {
75502:     JSOp bigSuffix;
75502: 
80966:     bigSuffix = EmitBigIndexPrefix(cx, bce, index);
75502:     if (bigSuffix == JSOP_FALSE)
77456:         return false;
75502:     EMIT_UINT16_IMM_OP(op, index);
77456: 
77456:     /*
77456:      * For decomposed ops, the suffix needs to go after the decomposed version.
77456:      * This means the suffix will run in the interpreter in both the base
77456:      * and decomposed paths, which works as suffix ops are idempotent.
77456:      */
77456:     JS_ASSERT(!!(js_CodeSpec[op].format & JOF_DECOMPOSE) == (psuffix != NULL));
77456:     if (psuffix) {
77456:         *psuffix = bigSuffix;
77456:         return true;
77456:     }
77456: 
80966:     return bigSuffix == JSOP_NOP || Emit1(cx, bce, bigSuffix) >= 0;
80966: }
80966: 
80966: /*
80966:  * Slight sugar for EmitIndexOp, again accessing cx and bce from the macro
75502:  * caller's lexical environment, and embedding a false return on error.
75502:  */
75502: #define EMIT_INDEX_OP(op, index)                                              \
75502:     JS_BEGIN_MACRO                                                            \
80966:         if (!EmitIndexOp(cx, op, index, bce))                                 \
75502:             return JS_FALSE;                                                  \
75502:     JS_END_MACRO
75502: 
75510: static bool
80966: EmitAtomOp(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce, JSOp *psuffix = NULL)
75502: {
75502:     JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
77434: 
77434:     if (op == JSOP_GETPROP &&
77434:         pn->pn_atom == cx->runtime->atomState.lengthAtom) {
77434:         /* Specialize length accesses for the interpreter. */
77434:         op = JSOP_LENGTH;
77434:     }
75510: 
75510:     jsatomid index;
80966:     if (!bce->makeAtomIndex(pn->pn_atom, &index))
80966:         return false;
80966: 
80966:     return EmitIndexOp(cx, op, index, bce, psuffix);
75502: }
75502: 
75502: static JSBool
80966: EmitObjectOp(JSContext *cx, ObjectBox *objbox, JSOp op, BytecodeEmitter *bce)
75502: {
75502:     JS_ASSERT(JOF_OPTYPE(op) == JOF_OBJECT);
80966:     return EmitIndexOp(cx, op, bce->objectList.index(objbox), bce);
75502: }
75502: 
75502: /*
75502:  * What good are ARGNO_LEN and SLOTNO_LEN, you ask?  The answer is that, apart
75502:  * from EmitSlotIndexOp, they abstract out the detail that both are 2, and in
75502:  * other parts of the code there's no necessary relationship between the two.
75502:  * The abstraction cracks here in order to share EmitSlotIndexOp code among
75502:  * the JSOP_DEFLOCALFUN and JSOP_GET{ARG,VAR,LOCAL}PROP cases.
75502:  */
75502: JS_STATIC_ASSERT(ARGNO_LEN == 2);
75502: JS_STATIC_ASSERT(SLOTNO_LEN == 2);
75502: 
75502: static JSBool
80966: EmitSlotIndexOp(JSContext *cx, JSOp op, uintN slot, uintN index, BytecodeEmitter *bce)
75502: {
75502:     JSOp bigSuffix;
75502:     ptrdiff_t off;
75502:     jsbytecode *pc;
75502: 
75502:     JS_ASSERT(JOF_OPTYPE(op) == JOF_SLOTATOM ||
75502:               JOF_OPTYPE(op) == JOF_SLOTOBJECT);
80966:     bigSuffix = EmitBigIndexPrefix(cx, bce, index);
75502:     if (bigSuffix == JSOP_FALSE)
75502:         return JS_FALSE;
75502: 
75502:     /* Emit [op, slot, index]. */
80966:     off = EmitN(cx, bce, op, 2 + INDEX_LEN);
75502:     if (off < 0)
75502:         return JS_FALSE;
80966:     pc = bce->code(off);
75502:     SET_UINT16(pc, slot);
75502:     pc += 2;
75502:     SET_INDEX(pc, index);
80966:     return bigSuffix == JSOP_NOP || Emit1(cx, bce, bigSuffix) >= 0;
80632: }
80632: 
75502: bool
80966: BytecodeEmitter::shouldNoteClosedName(ParseNode *pn)
75502: {
78294:     return !callsEval() && pn->isDefn() && pn->isClosed();
75502: }
75502: 
75502: /*
75502:  * Adjust the slot for a block local to account for the number of variables
75502:  * that share the same index space with locals. Due to the incremental code
75502:  * generation for top-level script, we do the adjustment via code patching in
80991:  * js::frontend::CompileScript; see comments there.
75502:  *
75502:  * The function returns -1 on failures.
75502:  */
75502: static jsint
80966: AdjustBlockSlot(JSContext *cx, BytecodeEmitter *bce, jsint slot)
80966: {
80966:     JS_ASSERT((jsuint) slot < bce->maxStackDepth);
80966:     if (bce->inFunction()) {
80966:         slot += bce->bindings.countVars();
75502:         if ((uintN) slot >= SLOTNO_LIMIT) {
80966:             ReportCompileErrorNumber(cx, bce->tokenStream(), NULL, JSREPORT_ERROR,
80966:                                      JSMSG_TOO_MANY_LOCALS);
75502:             slot = -1;
75502:         }
75502:     }
75502:     return slot;
75502: }
75502: 
75502: static bool
80966: EmitEnterBlock(JSContext *cx, ParseNode *pn, BytecodeEmitter *bce)
75502: {
82024:     JS_ASSERT(pn->isKind(PNK_LEXICALSCOPE));
80966:     if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, bce))
75502:         return false;
75502: 
75502:     JSObject *blockObj = pn->pn_objbox->object;
80966:     jsint depth = AdjustBlockSlot(cx, bce, OBJ_BLOCK_DEPTH(cx, blockObj));
75502:     if (depth < 0)
75502:         return false;
75502: 
77817:     uintN base = JSSLOT_FREE(&BlockClass);
75502:     for (uintN slot = base, limit = base + OBJ_BLOCK_COUNT(cx, blockObj); slot < limit; slot++) {
75502:         const Value &v = blockObj->getSlot(slot);
75502: 
75502:         /* Beware the empty destructuring dummy. */
75502:         if (v.isUndefined()) {
75502:             JS_ASSERT(slot + 1 <= limit);
75502:             continue;
75502:         }
75502: 
80631:         Definition *dn = (Definition *) v.toPrivate();
78294:         JS_ASSERT(dn->isDefn());
75502:         JS_ASSERT(uintN(dn->frameSlot() + depth) < JS_BIT(16));
75502:         dn->pn_cookie.set(dn->pn_cookie.level(), uint16(dn->frameSlot() + depth));
75502: #ifdef DEBUG
80631:         for (ParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
75502:             JS_ASSERT(pnu->pn_lexdef == dn);
75502:             JS_ASSERT(!(pnu->pn_dflags & PND_BOUND));
75502:             JS_ASSERT(pnu->pn_cookie.isFree());
75502:         }
75502: #endif
75502: 
75502:         /*
75502:          * If this variable is closed over, and |eval| is not present, then
75502:          * then set a bit in dslots so the Method JIT can deoptimize this
75502:          * slot.
75502:          */
80966:         bool isClosed = bce->shouldNoteClosedName(dn);
75502:         blockObj->setSlot(slot, BooleanValue(isClosed));
75502:     }
75502: 
75502:     /*
80631:      * If clones of this block will have any extensible parents, then the
80631:      * clones must get unique shapes; see the comments for
80631:      * js::Bindings::extensibleParents.
75502:      */
80966:     if ((bce->flags & TCF_FUN_EXTENSIBLE_SCOPE) ||
80966:         bce->bindings.extensibleParents())
75502:         blockObj->setBlockOwnShape(cx);
75502: 
75502:     return true;
75502: }
75502: 
75502: static JSBool
80966: EmitLeaveBlock(JSContext *cx, BytecodeEmitter *bce, JSOp op, ObjectBox *box)
75502: {
75502:     JSOp bigSuffix;
75502:     uintN count = OBJ_BLOCK_COUNT(cx, box->object);
75502:     
80966:     bigSuffix = EmitBigIndexPrefix(cx, bce, box->index);
75502:     if (bigSuffix == JSOP_FALSE)
75502:         return JS_FALSE;
80966:     if (Emit5(cx, bce, op, count, box->index) < 0)
80966:         return JS_FALSE;
80966:     return bigSuffix == JSOP_NOP || Emit1(cx, bce, bigSuffix) >= 0;
75502: }
75502: 
75502: /*
75502:  * Try to convert a *NAME op to a *GNAME op, which optimizes access to
75502:  * undeclared globals. Return true if a conversion was made.
75502:  *
75502:  * This conversion is not made if we are in strict mode.  In eval code nested
75502:  * within (strict mode) eval code, access to an undeclared "global" might
75502:  * merely be to a binding local to that outer eval:
75502:  *
75502:  *   "use strict";
75502:  *   var x = "global";
75502:  *   eval('var x = "eval"; eval("x");'); // 'eval', not 'global'
75502:  *
75502:  * Outside eval code, access to an undeclared global is a strict mode error:
75502:  *
75502:  *   "use strict";
75502:  *   function foo()
75502:  *   {
75502:  *     undeclared = 17; // throws ReferenceError
75502:  *   }
75502:  *   foo();
75502:  */
75502: static bool
80966: TryConvertToGname(BytecodeEmitter *bce, ParseNode *pn, JSOp *op)
80966: {
80966:     if (bce->compileAndGo() && 
80990:         bce->globalScope->globalObj &&
80966:         !bce->mightAliasLocals() &&
75502:         !pn->isDeoptimized() &&
80966:         !(bce->flags & TCF_STRICT_MODE_CODE)) { 
75502:         switch (*op) {
75502:           case JSOP_NAME:     *op = JSOP_GETGNAME; break;
75502:           case JSOP_SETNAME:  *op = JSOP_SETGNAME; break;
75502:           case JSOP_INCNAME:  *op = JSOP_INCGNAME; break;
75502:           case JSOP_NAMEINC:  *op = JSOP_GNAMEINC; break;
75502:           case JSOP_DECNAME:  *op = JSOP_DECGNAME; break;
75502:           case JSOP_NAMEDEC:  *op = JSOP_GNAMEDEC; break;
75502:           case JSOP_SETCONST:
75502:           case JSOP_DELNAME:
75502:             /* Not supported. */
75502:             return false;
75502:           default: JS_NOT_REACHED("gname");
75502:         }
75502:         return true;
75502:     }
75502:     return false;
75502: }
75502: 
75502: // Binds a global, given a |dn| that is known to have the PND_GVAR bit, and a pn
75502: // that is |dn| or whose definition is |dn|. |pn->pn_cookie| is an outparam
75502: // that will be free (meaning no binding), or a slot number.
75502: static bool
80966: BindKnownGlobal(JSContext *cx, BytecodeEmitter *bce, ParseNode *dn, ParseNode *pn, JSAtom *atom)
75502: {
75502:     // Cookie is an outparam; make sure caller knew to clear it.
75502:     JS_ASSERT(pn->pn_cookie.isFree());
75502: 
80966:     if (bce->mightAliasLocals())
75502:         return true;
75502: 
80990:     GlobalScope *globalScope = bce->globalScope;
75502: 
75510:     jsatomid index;
75502:     if (dn->pn_cookie.isFree()) {
75502:         // The definition wasn't bound, so find its atom's index in the
75502:         // mapping of defined globals.
75510:         AtomIndexPtr p = globalScope->names.lookup(atom);
75510:         JS_ASSERT(!!p);
75510:         index = p.value();
75502:     } else {
80966:         BytecodeEmitter *globalbce = globalScope->bce;
80966: 
80966:         // If the definition is bound, and we're in the same bce, we can re-use
75502:         // its cookie.
80966:         if (globalbce == bce) {
75502:             pn->pn_cookie = dn->pn_cookie;
75502:             pn->pn_dflags |= PND_BOUND;
75502:             return true;
75502:         }
75502: 
80966:         // Otherwise, find the atom's index by using the originating bce's
75502:         // global use table.
80966:         index = globalbce->globalUses[dn->pn_cookie.asInteger()].slot;
80966:     }
80966: 
80966:     if (!bce->addGlobalUse(atom, index, &pn->pn_cookie))
75502:         return false;
75502: 
75502:     if (!pn->pn_cookie.isFree())
75502:         pn->pn_dflags |= PND_BOUND;
75502: 
75502:     return true;
75502: }
75502: 
75502: // See BindKnownGlobal()'s comment.
75502: static bool
80966: BindGlobal(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, JSAtom *atom)
75502: {
75502:     pn->pn_cookie.makeFree();
75502: 
80631:     Definition *dn;
78294:     if (pn->isUsed()) {
75502:         dn = pn->pn_lexdef;
75502:     } else {
78294:         if (!pn->isDefn())
75502:             return true;
80631:         dn = (Definition *)pn;
75502:     }
75502: 
75502:     // Only optimize for defined globals.
75502:     if (!dn->isGlobal())
75502:         return true;
75502: 
80966:     return BindKnownGlobal(cx, bce, dn, pn, atom);
75502: }
75502: 
75502: /*
75502:  * BindNameToSlot attempts to optimize name gets and sets to stack slot loads
82024:  * and stores, given the compile-time information in bce and a PNK_NAME node pn.
75502:  * It returns false on error, true on success.
75502:  *
75502:  * The caller can inspect pn->pn_cookie for FREE_UPVAR_COOKIE to tell whether
75502:  * optimization occurred, in which case BindNameToSlot also updated pn->pn_op.
75502:  * If pn->pn_cookie is still FREE_UPVAR_COOKIE on return, pn->pn_op still may
75502:  * have been optimized, e.g., from JSOP_NAME to JSOP_CALLEE.  Whether or not
75502:  * pn->pn_op was modified, if this function finds an argument or local variable
75502:  * name, PND_CONST will be set in pn_dflags for read-only properties after a
75502:  * successful return.
75502:  *
75502:  * NB: if you add more opcodes specialized from JSOP_NAME, etc., don't forget
82023:  * to update the special cases in EmitFor (for-in) and EmitAssignment (= and
82023:  * op=, e.g. +=).
75502:  */
75502: static JSBool
80966: BindNameToSlot(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
80631: {
80631:     Definition *dn;
75502:     JSOp op;
75502:     JSAtom *atom;
80631:     Definition::Kind dn_kind;
75502: 
82024:     JS_ASSERT(pn->isKind(PNK_NAME));
75502: 
75502:     /* Idempotency tests come first, since we may be called more than once. */
75502:     if (pn->pn_dflags & PND_BOUND)
75502:         return JS_TRUE;
75502: 
75502:     /* No cookie initialized for these two, they're pre-bound by definition. */
78294:     JS_ASSERT(!pn->isOp(JSOP_ARGUMENTS) && !pn->isOp(JSOP_CALLEE));
75502: 
75502:     /*
75502:      * The parser linked all uses (including forward references) to their
75502:      * definitions, unless a with statement or direct eval intervened.
75502:      */
78294:     if (pn->isUsed()) {
75502:         JS_ASSERT(pn->pn_cookie.isFree());
75502:         dn = pn->pn_lexdef;
78294:         JS_ASSERT(dn->isDefn());
75502:         if (pn->isDeoptimized())
75502:             return JS_TRUE;
75502:         pn->pn_dflags |= (dn->pn_dflags & PND_CONST);
75502:     } else {
78294:         if (!pn->isDefn())
75502:             return JS_TRUE;
80631:         dn = (Definition *) pn;
75502:     }
75502: 
78294:     op = pn->getOp();
75502:     if (op == JSOP_NOP)
75502:         return JS_TRUE;
75502: 
75502:     JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
75502:     atom = pn->pn_atom;
75502:     UpvarCookie cookie = dn->pn_cookie;
75502:     dn_kind = dn->kind();
75502: 
75502:     /*
75502:      * Turn attempts to mutate const-declared bindings into get ops (for
75502:      * pre-increment and pre-decrement ops, our caller will have to emit
75502:      * JSOP_POS, JSOP_ONE, and JSOP_ADD as well).
75502:      *
75502:      * Turn JSOP_DELNAME into JSOP_FALSE if dn is known, as all declared
75502:      * bindings visible to the compiler are permanent in JS unless the
75502:      * declaration originates at top level in eval code.
75502:      */
75502:     switch (op) {
75502:       case JSOP_NAME:
75502:       case JSOP_SETCONST:
75502:         break;
75502:       case JSOP_DELNAME:
80631:         if (dn_kind != Definition::UNKNOWN) {
80966:             if (bce->parser->callerFrame && dn->isTopLevel())
80966:                 JS_ASSERT(bce->compileAndGo());
75502:             else
78294:                 pn->setOp(JSOP_FALSE);
75502:             pn->pn_dflags |= PND_BOUND;
75502:             return JS_TRUE;
75502:         }
75502:         break;
75502:       default:
75502:         if (pn->isConst()) {
80966:             if (bce->needStrictChecks()) {
75502:                 JSAutoByteString name;
75502:                 if (!js_AtomToPrintableString(cx, atom, &name) ||
80966:                     !ReportStrictModeError(cx, bce->tokenStream(), bce, pn, JSMSG_READ_ONLY,
80966:                                            name.ptr())) {
75502:                     return JS_FALSE;
75502:                 }
75502:             }
78294:             pn->setOp(op = JSOP_NAME);
75502:         }
75502:     }
75502: 
75502:     if (dn->isGlobal()) {
75502:         if (op == JSOP_NAME) {
75502:             /*
75502:              * If the definition is a defined global, not potentially aliased
75502:              * by a local variable, and not mutating the variable, try and
75502:              * optimize to a fast, unguarded global access.
75502:              */
75502:             if (!pn->pn_cookie.isFree()) {
78646:                 pn->setOp(JSOP_GETGNAME);
78646:                 pn->pn_dflags |= PND_BOUND;
75502:                 return JS_TRUE;
75502:             }
75502:         }
75502: 
75502:         /*
75502:          * The locally stored cookie here should really come from |pn|, not
75502:          * |dn|. For example, we could have a SETGNAME op's lexdef be a
78646:          * GETGNAME op, and their cookies have very different meanings. As
75502:          * a workaround, just make the cookie free.
75502:          */
75502:         cookie.makeFree();
75502:     }
75502: 
75502:     if (cookie.isFree()) {
80966:         StackFrame *caller = bce->parser->callerFrame;
75502:         if (caller) {
80966:             JS_ASSERT(bce->compileAndGo());
75502: 
75502:             /*
75502:              * Don't generate upvars on the left side of a for loop. See
75502:              * bug 470758.
75502:              */
80966:             if (bce->flags & TCF_IN_FOR_INIT)
75502:                 return JS_TRUE;
75502: 
75502:             JS_ASSERT(caller->isScriptFrame());
75502: 
75502:             /*
75502:              * If this is an eval in the global scope, then unbound variables
75502:              * must be globals, so try to use GNAME ops.
75502:              */
80966:             if (caller->isGlobalFrame() && TryConvertToGname(bce, pn, &op)) {
75510:                 jsatomid _;
80966:                 if (!bce->makeAtomIndex(atom, &_))
75502:                     return JS_FALSE;
75502: 
78294:                 pn->setOp(op);
75502:                 pn->pn_dflags |= PND_BOUND;
75502:                 return JS_TRUE;
75502:             }
75502: 
75502:             /*
75502:              * Out of tricks, so we must rely on PICs to optimize named
75502:              * accesses from direct eval called from function code.
75502:              */
75502:             return JS_TRUE;
75502:         }
75502: 
75502:         /* Optimize accesses to undeclared globals. */
80966:         if (!bce->mightAliasLocals() && !TryConvertToGname(bce, pn, &op))
75502:             return JS_TRUE;
75502: 
75510:         jsatomid _;
80966:         if (!bce->makeAtomIndex(atom, &_))
75502:             return JS_FALSE;
75502: 
78294:         pn->setOp(op);
75502:         pn->pn_dflags |= PND_BOUND;
75502: 
75502:         return JS_TRUE;
75502:     }
75502: 
75502:     uint16 level = cookie.level();
80966:     JS_ASSERT(bce->staticLevel >= level);
80966: 
80966:     const uintN skip = bce->staticLevel - level;
75502:     if (skip != 0) {
80966:         JS_ASSERT(bce->inFunction());
80966:         JS_ASSERT_IF(cookie.slot() != UpvarCookie::CALLEE_SLOT, bce->roLexdeps->lookup(atom));
75502:         JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
80966:         JS_ASSERT(bce->fun()->u.i.skipmin <= skip);
75502: 
75502:         /*
75502:          * If op is a mutating opcode, this upvar's lookup skips too many levels,
75502:          * or the function is heavyweight, we fall back on JSOP_*NAME*.
75502:          */
75502:         if (op != JSOP_NAME)
75502:             return JS_TRUE;
77707:         if (skip >= UpvarCookie::UPVAR_LEVEL_LIMIT)
75502:             return JS_TRUE;
80966:         if (bce->flags & TCF_FUN_HEAVYWEIGHT)
75502:             return JS_TRUE;
75502: 
80966:         if (!bce->fun()->isFlatClosure())
75502:             return JS_TRUE;
75502: 
80966:         if (!bce->upvarIndices.ensureMap(cx))
80966:             return JS_FALSE;
80966: 
80966:         AtomIndexAddPtr p = bce->upvarIndices->lookupForAdd(atom);
75510:         jsatomid index;
75510:         if (p) {
75510:             index = p.value();
75502:         } else {
80966:             if (!bce->bindings.addUpvar(cx, atom))
80966:                 return JS_FALSE;
80966: 
80966:             index = bce->upvarIndices->count();
80966:             if (!bce->upvarIndices->add(p, atom, index))
80966:                 return JS_FALSE;
80966: 
80966:             UpvarCookies &upvarMap = bce->upvarMap;
76211:             /* upvarMap should have the same number of UpvarCookies as there are lexdeps. */
80966:             size_t lexdepCount = bce->roLexdeps->count();
76211: 
76211:             JS_ASSERT_IF(!upvarMap.empty(), lexdepCount == upvarMap.length());
76232:             if (upvarMap.empty()) {
76232:                 /* Lazily initialize the upvar map with exactly the necessary capacity. */
76232:                 if (lexdepCount <= upvarMap.sMaxInlineStorage) {
76232:                     JS_ALWAYS_TRUE(upvarMap.growByUninitialized(lexdepCount));
76232:                 } else {
76232:                     void *buf = upvarMap.allocPolicy().malloc_(lexdepCount * sizeof(UpvarCookie));
76232:                     if (!buf)
76232:                         return JS_FALSE;
76232:                     upvarMap.replaceRawBuffer(static_cast<UpvarCookie *>(buf), lexdepCount);
76232:                 }
76232:                 for (size_t i = 0; i < lexdepCount; ++i)
76232:                     upvarMap[i] = UpvarCookie();
76232:             }
75502: 
75502:             uintN slot = cookie.slot();
80631:             if (slot != UpvarCookie::CALLEE_SLOT && dn_kind != Definition::ARG) {
80966:                 TreeContext *tc = bce;
75502:                 do {
75502:                     tc = tc->parent;
75502:                 } while (tc->staticLevel != level);
75502:                 if (tc->inFunction())
75502:                     slot += tc->fun()->nargs;
75502:             }
75502: 
76211:             JS_ASSERT(index < upvarMap.length());
76211:             upvarMap[index].set(skip, slot);
75502:         }
75502: 
78294:         pn->setOp(JSOP_GETFCSLOT);
75502:         JS_ASSERT((index & JS_BITMASK(16)) == index);
75502:         pn->pn_cookie.set(0, index);
75502:         pn->pn_dflags |= PND_BOUND;
75502:         return JS_TRUE;
75502:     }
75502: 
75502:     /*
75502:      * We are compiling a function body and may be able to optimize name
75502:      * to stack slot. Look for an argument or variable in the function and
75502:      * rewrite pn_op and update pn accordingly.
75502:      */
75502:     switch (dn_kind) {
80631:       case Definition::UNKNOWN:
75502:         return JS_TRUE;
75502: 
80631:       case Definition::LET:
75502:         switch (op) {
75502:           case JSOP_NAME:     op = JSOP_GETLOCAL; break;
75502:           case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
75502:           case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
75502:           case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
75502:           case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
75502:           case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
75502:           default: JS_NOT_REACHED("let");
75502:         }
75502:         break;
75502: 
80631:       case Definition::ARG:
75502:         switch (op) {
75502:           case JSOP_NAME:     op = JSOP_GETARG; break;
75502:           case JSOP_SETNAME:  op = JSOP_SETARG; break;
75502:           case JSOP_INCNAME:  op = JSOP_INCARG; break;
75502:           case JSOP_NAMEINC:  op = JSOP_ARGINC; break;
75502:           case JSOP_DECNAME:  op = JSOP_DECARG; break;
75502:           case JSOP_NAMEDEC:  op = JSOP_ARGDEC; break;
75502:           default: JS_NOT_REACHED("arg");
75502:         }
75502:         JS_ASSERT(!pn->isConst());
75502:         break;
75502: 
80631:       case Definition::VAR:
78294:         if (dn->isOp(JSOP_CALLEE)) {
75502:             JS_ASSERT(op != JSOP_CALLEE);
80966:             JS_ASSERT((bce->fun()->flags & JSFUN_LAMBDA) && atom == bce->fun()->atom);
80966: 
80966:             /*
80966:              * Leave pn->isOp(JSOP_NAME) if bce->fun is heavyweight to
75502:              * address two cases: a new binding introduced by eval, and
75502:              * assignment to the name in strict mode.
75502:              *
75502:              *   var fun = (function f(s) { eval(s); return f; });
75502:              *   assertEq(fun("var f = 42"), 42);
75502:              *
75502:              * ECMAScript specifies that a function expression's name is bound
75502:              * in a lexical environment distinct from that used to bind its
75502:              * named parameters, the arguments object, and its variables.  The
75502:              * new binding for "var f = 42" shadows the binding for the
75502:              * function itself, so the name of the function will not refer to
75502:              * the function.
75502:              *
75502:              *    (function f() { "use strict"; f = 12; })();
75502:              *
75502:              * Outside strict mode, assignment to a function expression's name
75502:              * has no effect.  But in strict mode, this attempt to mutate an
75502:              * immutable binding must throw a TypeError.  We implement this by
75502:              * not optimizing such assignments and by marking such functions as
75502:              * heavyweight, ensuring that the function name is represented in
75502:              * the scope chain so that assignment will throw a TypeError.
75502:              */
75502:             JS_ASSERT(op != JSOP_DELNAME);
80966:             if (!(bce->flags & TCF_FUN_HEAVYWEIGHT)) {
75502:                 op = JSOP_CALLEE;
75502:                 pn->pn_dflags |= PND_CONST;
75502:             }
75502: 
78294:             pn->setOp(op);
75502:             pn->pn_dflags |= PND_BOUND;
75502:             return JS_TRUE;
75502:         }
75502:         /* FALL THROUGH */
75502: 
75502:       default:
80631:         JS_ASSERT_IF(dn_kind != Definition::FUNCTION,
80631:                      dn_kind == Definition::VAR ||
80631:                      dn_kind == Definition::CONST);
75502:         switch (op) {
75502:           case JSOP_NAME:     op = JSOP_GETLOCAL; break;
75502:           case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
75502:           case JSOP_SETCONST: op = JSOP_SETLOCAL; break;
75502:           case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
75502:           case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
75502:           case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
75502:           case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
75502:           default: JS_NOT_REACHED("local");
75502:         }
80631:         JS_ASSERT_IF(dn_kind == Definition::CONST, pn->pn_dflags & PND_CONST);
75502:         break;
75502:     }
75502: 
78294:     JS_ASSERT(!pn->isOp(op));
78294:     pn->setOp(op);
75502:     pn->pn_cookie.set(0, cookie.slot());
75502:     pn->pn_dflags |= PND_BOUND;
75502:     return JS_TRUE;
75502: }
75502: 
75502: bool
80966: BytecodeEmitter::addGlobalUse(JSAtom *atom, uint32 slot, UpvarCookie *cookie)
75502: {
75510:     if (!globalMap.ensureMap(context()))
75510:         return false;
75510: 
75510:     AtomIndexAddPtr p = globalMap->lookupForAdd(atom);
75510:     if (p) {
75510:         jsatomid index = p.value();
75510:         cookie->set(0, index);
75502:         return true;
75502:     }
75502: 
75502:     /* Don't bother encoding indexes >= uint16 */
75502:     if (globalUses.length() >= UINT16_LIMIT) {
75502:         cookie->makeFree();
75502:         return true;
75502:     }
75502: 
75502:     /* Find or add an existing atom table entry. */
75510:     jsatomid allAtomIndex;
75510:     if (!makeAtomIndex(atom, &allAtomIndex))
75502:         return false;
75502: 
75510:     jsatomid globalUseIndex = globalUses.length();
75510:     cookie->set(0, globalUseIndex);
75510: 
75510:     GlobalSlotArray::Entry entry = { allAtomIndex, slot };
75502:     if (!globalUses.append(entry))
75502:         return false;
75502: 
75510:     return globalMap->add(p, atom, globalUseIndex);
75502: }
75502: 
75502: /*
75502:  * If pn contains a useful expression, return true with *answer set to true.
75502:  * If pn contains a useless expression, return true with *answer set to false.
75502:  * Return false on error.
75502:  *
75502:  * The caller should initialize *answer to false and invoke this function on
75502:  * an expression statement or similar subtree to decide whether the tree could
75502:  * produce code that has any side effects.  For an expression statement, we
75502:  * define useless code as code with no side effects, because the main effect,
75502:  * the value left on the stack after the code executes, will be discarded by a
75502:  * pop bytecode.
75502:  */
75502: static JSBool
80966: CheckSideEffects(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, JSBool *answer)
75502: {
75502:     JSBool ok;
80631:     ParseNode *pn2;
75502: 
75502:     ok = JS_TRUE;
75502:     if (!pn || *answer)
75502:         return ok;
75502: 
78294:     switch (pn->getArity()) {
75502:       case PN_FUNC:
75502:         /*
75502:          * A named function, contrary to ES3, is no longer useful, because we
75502:          * bind its name lexically (using JSOP_CALLEE) instead of creating an
75502:          * Object instance and binding a readonly, permanent property in it
75502:          * (the object and binding can be detected and hijacked or captured).
75502:          * This is a bug fix to ES3; it is fixed in ES3.1 drafts.
75502:          */
75502:         *answer = JS_FALSE;
75502:         break;
75502: 
75502:       case PN_LIST:
78294:         if (pn->isOp(JSOP_NOP) || pn->isOp(JSOP_OR) || pn->isOp(JSOP_AND) ||
78294:             pn->isOp(JSOP_STRICTEQ) || pn->isOp(JSOP_STRICTNE)) {
75502:             /*
75502:              * Non-operators along with ||, &&, ===, and !== never invoke
75502:              * toString or valueOf.
75502:              */
75502:             for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next)
80966:                 ok &= CheckSideEffects(cx, bce, pn2, answer);
75502:         } else {
75502:             /*
82024:              * All invocation operations (construct: PNK_NEW, call: PNK_LP)
75502:              * are presumed to be useful, because they may have side effects
75502:              * even if their main effect (their return value) is discarded.
75502:              *
82024:              * PNK_LB binary trees of 3 or more nodes are flattened into lists
75502:              * to avoid too much recursion.  All such lists must be presumed
75502:              * to be useful because each index operation could invoke a getter
75502:              * (the JSOP_ARGUMENTS special case below, in the PN_BINARY case,
75502:              * does not apply here: arguments[i][j] might invoke a getter).
75502:              *
75502:              * Likewise, array and object initialisers may call prototype
75502:              * setters (the __defineSetter__ built-in, and writable __proto__
75502:              * on Array.prototype create this hazard). Initialiser list nodes
75502:              * have JSOP_NEWINIT in their pn_op.
75502:              */
75502:             *answer = JS_TRUE;
75502:         }
75502:         break;
75502: 
75502:       case PN_TERNARY:
80966:         ok = CheckSideEffects(cx, bce, pn->pn_kid1, answer) &&
80966:              CheckSideEffects(cx, bce, pn->pn_kid2, answer) &&
80966:              CheckSideEffects(cx, bce, pn->pn_kid3, answer);
75502:         break;
75502: 
75502:       case PN_BINARY:
82023:         if (pn->isAssignment()) {
75502:             /*
75502:              * Assignment is presumed to be useful, even if the next operation
75502:              * is another assignment overwriting this one's ostensible effect,
75502:              * because the left operand may be a property with a setter that
75502:              * has side effects.
75502:              *
75502:              * The only exception is assignment of a useless value to a const
75502:              * declared in the function currently being compiled.
75502:              */
75502:             pn2 = pn->pn_left;
82024:             if (!pn2->isKind(PNK_NAME)) {
75502:                 *answer = JS_TRUE;
75502:             } else {
80966:                 if (!BindNameToSlot(cx, bce, pn2))
80966:                     return JS_FALSE;
80966:                 if (!CheckSideEffects(cx, bce, pn->pn_right, answer))
75502:                     return JS_FALSE;
78294:                 if (!*answer && (!pn->isOp(JSOP_NOP) || !pn2->isConst()))
75502:                     *answer = JS_TRUE;
75502:             }
75502:         } else {
78294:             if (pn->isOp(JSOP_OR) || pn->isOp(JSOP_AND) || pn->isOp(JSOP_STRICTEQ) ||
78294:                 pn->isOp(JSOP_STRICTNE)) {
75502:                 /*
75502:                  * ||, &&, ===, and !== do not convert their operands via
75502:                  * toString or valueOf method calls.
75502:                  */
80966:                 ok = CheckSideEffects(cx, bce, pn->pn_left, answer) &&
80966:                      CheckSideEffects(cx, bce, pn->pn_right, answer);
75502:             } else {
75502:                 /*
75502:                  * We can't easily prove that neither operand ever denotes an
75502:                  * object with a toString or valueOf method.
75502:                  */
75502:                 *answer = JS_TRUE;
75502:             }
75502:         }
75502:         break;
75502: 
75502:       case PN_UNARY:
78294:         switch (pn->getKind()) {
82024:           case PNK_DELETE:
75502:             pn2 = pn->pn_kid;
78294:             switch (pn2->getKind()) {
82024:               case PNK_NAME:
80966:                 if (!BindNameToSlot(cx, bce, pn2))
75502:                     return JS_FALSE;
75502:                 if (pn2->isConst()) {
75502:                     *answer = JS_FALSE;
75502:                     break;
75502:                 }
75502:                 /* FALL THROUGH */
82024:               case PNK_DOT:
75502: #if JS_HAS_XML_SUPPORT
82024:               case PNK_DBLDOT:
82024:                 JS_ASSERT_IF(pn2->getKind() == PNK_DBLDOT, !bce->inStrictMode());
80780:                 /* FALL THROUGH */
80780: 
75502: #endif
82024:               case PNK_LP:
82024:               case PNK_LB:
75502:                 /* All these delete addressing modes have effects too. */
75502:                 *answer = JS_TRUE;
75502:                 break;
75502:               default:
80966:                 ok = CheckSideEffects(cx, bce, pn2, answer);
75502:                 break;
75502:             }
75502:             break;
75502: 
82024:           case PNK_TYPEOF:
82024:           case PNK_VOID:
82024:           case PNK_NOT:
82024:           case PNK_BITNOT:
78294:             if (pn->isOp(JSOP_NOT)) {
75502:                 /* ! does not convert its operand via toString or valueOf. */
80966:                 ok = CheckSideEffects(cx, bce, pn->pn_kid, answer);
75502:                 break;
75502:             }
75502:             /* FALL THROUGH */
75502: 
75502:           default:
75502:             /*
82024:              * All of PNK_INC, PNK_DEC, PNK_THROW, PNK_YIELD, and PNK_DEFSHARP
75502:              * have direct effects. Of the remaining unary-arity node types,
75502:              * we can't easily prove that the operand never denotes an object
75502:              * with a toString or valueOf method.
75502:              */
75502:             *answer = JS_TRUE;
75502:             break;
75502:         }
75502:         break;
75502: 
75502:       case PN_NAME:
75502:         /*
75502:          * Take care to avoid trying to bind a label name (labels, both for
75502:          * statements and property values in object initialisers, have pn_op
75502:          * defaulted to JSOP_NOP).
75502:          */
82024:         if (pn->isKind(PNK_NAME) && !pn->isOp(JSOP_NOP)) {
80966:             if (!BindNameToSlot(cx, bce, pn))
75502:                 return JS_FALSE;
78294:             if (!pn->isOp(JSOP_ARGUMENTS) && !pn->isOp(JSOP_CALLEE) &&
75502:                 pn->pn_cookie.isFree()) {
75502:                 /*
75502:                  * Not an argument or local variable use, and not a use of a
75502:                  * unshadowed named function expression's given name, so this
75502:                  * expression could invoke a getter that has side effects.
75502:                  */
75502:                 *answer = JS_TRUE;
75502:             }
75502:         }
75502:         pn2 = pn->maybeExpr();
82024:         if (pn->isKind(PNK_DOT)) {
82024:             if (pn2->isKind(PNK_NAME) && !BindNameToSlot(cx, bce, pn2))
78294:                 return JS_FALSE;
78294:             if (!(pn2->isOp(JSOP_ARGUMENTS) &&
75502:                   pn->pn_atom == cx->runtime->atomState.lengthAtom)) {
75502:                 /*
75502:                  * Any dotted property reference could call a getter, except
75502:                  * for arguments.length where arguments is unambiguous.
75502:                  */
75502:                 *answer = JS_TRUE;
75502:             }
75502:         }
80966:         ok = CheckSideEffects(cx, bce, pn2, answer);
75502:         break;
75502: 
75502:       case PN_NAMESET:
80966:         ok = CheckSideEffects(cx, bce, pn->pn_tree, answer);
75502:         break;
75502: 
75502:       case PN_NULLARY:
82024:         if (pn->isKind(PNK_DEBUGGER))
75502:             *answer = JS_TRUE;
75502:         break;
75502:     }
75502:     return ok;
75502: }
75502: 
75502: static JSBool
80966: EmitNameOp(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, JSBool callContext)
75502: {
75502:     JSOp op;
75502: 
80966:     if (!BindNameToSlot(cx, bce, pn))
75502:         return JS_FALSE;
78294:     op = pn->getOp();
75502: 
75502:     if (callContext) {
75502:         switch (op) {
75502:           case JSOP_NAME:
75502:             op = JSOP_CALLNAME;
75502:             break;
75502:           case JSOP_GETGNAME:
75502:             op = JSOP_CALLGNAME;
75502:             break;
75502:           case JSOP_GETARG:
75502:             op = JSOP_CALLARG;
75502:             break;
75502:           case JSOP_GETLOCAL:
75502:             op = JSOP_CALLLOCAL;
75502:             break;
75502:           case JSOP_GETFCSLOT:
75502:             op = JSOP_CALLFCSLOT;
75502:             break;
75502:           default:
75502:             JS_ASSERT(op == JSOP_ARGUMENTS || op == JSOP_CALLEE);
75502:             break;
75502:         }
75502:     }
75502: 
75502:     if (op == JSOP_ARGUMENTS || op == JSOP_CALLEE) {
80966:         if (Emit1(cx, bce, op) < 0)
80966:             return JS_FALSE;
80966:         if (callContext && Emit1(cx, bce, JSOP_PUSH) < 0)
75502:             return JS_FALSE;
75502:     } else {
75502:         if (!pn->pn_cookie.isFree()) {
75502:             EMIT_UINT16_IMM_OP(op, pn->pn_cookie.asInteger());
75502:         } else {
80966:             if (!EmitAtomOp(cx, pn, op, bce))
75502:                 return JS_FALSE;
75502:         }
75502:     }
75502: 
75502:     return JS_TRUE;
75502: }
75502: 
75502: #if JS_HAS_XML_SUPPORT
80632: static bool
80966: EmitXMLName(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
80966: {
80966:     JS_ASSERT(!bce->inStrictMode());
82114:     JS_ASSERT(pn->isKind(PNK_XMLUNARY));
78294:     JS_ASSERT(pn->isOp(JSOP_XMLNAME));
75502:     JS_ASSERT(op == JSOP_XMLNAME || op == JSOP_CALLXMLNAME);
75502: 
80632:     ParseNode *pn2 = pn->pn_kid;
80966:     uintN oldflags = bce->flags;
80966:     bce->flags &= ~TCF_IN_FOR_INIT;
80966:     if (!EmitTree(cx, bce, pn2))
80966:         return false;
80966:     bce->flags |= oldflags & TCF_IN_FOR_INIT;
80966:     if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - pn2->pn_offset) < 0)
80966:         return false;
80966: 
80966:     return Emit1(cx, bce, op) >= 0;
75502: }
75502: #endif
75502: 
77434: static inline bool
80966: EmitElemOpBase(JSContext *cx, BytecodeEmitter *bce, JSOp op)
80966: {
80966:     if (Emit1(cx, bce, op) < 0)
80966:         return false;
80966:     CheckTypeSet(cx, bce, op);
77434:     return true;
77434: }
77434: 
75510: static bool
80966: EmitSpecialPropOp(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
75502: {
75502:     /*
75502:      * Special case for obj.__proto__ to deoptimize away from fast paths in the
75502:      * interpreter and trace recorder, which skip dense array instances by
75502:      * going up to Array.prototype before looking up the property name.
75502:      */
75510:     jsatomid index;
80966:     if (!bce->makeAtomIndex(pn->pn_atom, &index))
80966:         return false;
80966:     if (!EmitIndexOp(cx, JSOP_QNAMEPART, index, bce))
80966:         return false;
80966:     return EmitElemOpBase(cx, bce, op);
75502: }
75502: 
80632: static bool
80966: EmitPropOp(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce,
77456:            JSBool callContext, JSOp *psuffix = NULL)
75502: {
80631:     ParseNode *pn2, *pndot, *pnup, *pndown;
75502:     ptrdiff_t top;
75502: 
78294:     JS_ASSERT(pn->isArity(PN_NAME));
75502:     pn2 = pn->maybeExpr();
75502: 
75502:     /* Special case deoptimization for __proto__. */
75502:     if ((op == JSOP_GETPROP || op == JSOP_CALLPROP) &&
75502:         pn->pn_atom == cx->runtime->atomState.protoAtom) {
80966:         if (pn2 && !EmitTree(cx, bce, pn2))
80966:             return false;
80966:         return EmitSpecialPropOp(cx, pn, callContext ? JSOP_CALLELEM : JSOP_GETELEM, bce);
75502:     }
75502: 
75502:     if (callContext) {
82024:         JS_ASSERT(pn->isKind(PNK_DOT));
75502:         JS_ASSERT(op == JSOP_GETPROP);
75502:         op = JSOP_CALLPROP;
82024:     } else if (op == JSOP_GETPROP && pn->isKind(PNK_DOT)) {
82024:         if (pn2->isKind(PNK_NAME)) {
80966:             if (!BindNameToSlot(cx, bce, pn2))
80632:                 return false;
75502:         }
75502:     }
75502: 
75502:     /*
75502:      * If the object operand is also a dotted property reference, reverse the
75502:      * list linked via pn_expr temporarily so we can iterate over it from the
75502:      * bottom up (reversing again as we go), to avoid excessive recursion.
75502:      */
82024:     if (pn2->isKind(PNK_DOT)) {
75502:         pndot = pn2;
75502:         pnup = NULL;
80966:         top = bce->offset();
75502:         for (;;) {
75502:             /* Reverse pndot->pn_expr to point up, not down. */
75502:             pndot->pn_offset = top;
78294:             JS_ASSERT(!pndot->isUsed());
75502:             pndown = pndot->pn_expr;
75502:             pndot->pn_expr = pnup;
82024:             if (!pndown->isKind(PNK_DOT))
75502:                 break;
75502:             pnup = pndot;
75502:             pndot = pndown;
75502:         }
75502: 
75502:         /* pndown is a primary expression, not a dotted property reference. */
80966:         if (!EmitTree(cx, bce, pndown))
80632:             return false;
75502: 
75502:         do {
75502:             /* Walk back up the list, emitting annotated name ops. */
80966:             if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - pndown->pn_offset) < 0)
80632:                 return false;
75502: 
75502:             /* Special case deoptimization on __proto__, as above. */
78294:             if (pndot->isArity(PN_NAME) && pndot->pn_atom == cx->runtime->atomState.protoAtom) {
80966:                 if (!EmitSpecialPropOp(cx, pndot, JSOP_GETELEM, bce))
80966:                     return false;
80966:             } else if (!EmitAtomOp(cx, pndot, pndot->getOp(), bce)) {
80632:                 return false;
75502:             }
75502: 
75502:             /* Reverse the pn_expr link again. */
75502:             pnup = pndot->pn_expr;
75502:             pndot->pn_expr = pndown;
75502:             pndown = pndot;
75502:         } while ((pndot = pnup) != NULL);
75502:     } else {
80966:         if (!EmitTree(cx, bce, pn2))
80966:             return false;
80966:     }
80966: 
80966:     if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - pn2->pn_offset) < 0)
80966:         return false;
80966: 
80966:     return EmitAtomOp(cx, pn, op, bce, psuffix);
75502: }
75502: 
77434: static bool
80966: EmitPropIncDec(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
77434: {
77456:     JSOp suffix = JSOP_NOP;
80966:     if (!EmitPropOp(cx, pn, op, bce, false, &suffix))
80966:         return false;
80966:     if (Emit1(cx, bce, JSOP_NOP) < 0)
77434:         return false;
77434: 
77434:     /*
77434:      * The stack is the same depth before/after INCPROP, so no balancing to do
77434:      * before the decomposed version.
77434:      */
80966:     int start = bce->offset();
80966: 
80966:     if (suffix != JSOP_NOP && Emit1(cx, bce, suffix) < 0)
77456:         return false;
77456: 
77434:     const JSCodeSpec *cs = &js_CodeSpec[op];
77434:     JS_ASSERT(cs->format & JOF_PROP);
77434:     JS_ASSERT(cs->format & (JOF_INC | JOF_DEC));
77434: 
77434:     bool post = (cs->format & JOF_POST);
77434:     JSOp binop = (cs->format & JOF_INC) ? JSOP_ADD : JSOP_SUB;
77434: 
77434:                                                     // OBJ
80966:     if (Emit1(cx, bce, JSOP_DUP) < 0)               // OBJ OBJ
80966:         return false;
80966:     if (!EmitAtomOp(cx, pn, JSOP_GETPROP, bce))     // OBJ V
80966:         return false;
80966:     if (Emit1(cx, bce, JSOP_POS) < 0)               // OBJ N
80966:         return false;
80966:     if (post && Emit1(cx, bce, JSOP_DUP) < 0)       // OBJ N? N
80966:         return false;
80966:     if (Emit1(cx, bce, JSOP_ONE) < 0)               // OBJ N? N 1
80966:         return false;
80966:     if (Emit1(cx, bce, binop) < 0)                  // OBJ N? N+1
77434:         return false;
77434: 
77434:     if (post) {
80966:         if (Emit2(cx, bce, JSOP_PICK, (jsbytecode)2) < 0)   // N? N+1 OBJ
80966:             return false;
80966:         if (Emit1(cx, bce, JSOP_SWAP) < 0)                  // N? OBJ N+1
80966:             return false;
80966:     }
80966: 
80966:     if (!EmitAtomOp(cx, pn, JSOP_SETPROP, bce))     // N? N+1
80966:         return false;
80966:     if (post && Emit1(cx, bce, JSOP_POP) < 0)       // RESULT
80966:         return false;
80966: 
80966:     UpdateDecomposeLength(bce, start);
80966: 
80966:     if (suffix != JSOP_NOP && Emit1(cx, bce, suffix) < 0)
77456:         return false;
77456: 
77434:     return true;
77434: }
77434: 
77434: static bool
80966: EmitNameIncDec(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
77434: {
77456:     JSOp suffix = JSOP_NOP;
80966:     if (!EmitAtomOp(cx, pn, op, bce, &suffix))
80966:         return false;
80966:     if (Emit1(cx, bce, JSOP_NOP) < 0)
77434:         return false;
77434: 
77434:     /* Remove the result to restore the stack depth before the INCNAME. */
80966:     bce->stackDepth--;
80966: 
80966:     int start = bce->offset();
80966: 
80966:     if (suffix != JSOP_NOP && Emit1(cx, bce, suffix) < 0)
77456:         return false;
77456: 
77434:     const JSCodeSpec *cs = &js_CodeSpec[op];
77434:     JS_ASSERT((cs->format & JOF_NAME) || (cs->format & JOF_GNAME));
77434:     JS_ASSERT(cs->format & (JOF_INC | JOF_DEC));
77434: 
77434:     bool global = (cs->format & JOF_GNAME);
77434:     bool post = (cs->format & JOF_POST);
77434:     JSOp binop = (cs->format & JOF_INC) ? JSOP_ADD : JSOP_SUB;
77434: 
80966:     if (!EmitAtomOp(cx, pn, global ? JSOP_BINDGNAME : JSOP_BINDNAME, bce))  // OBJ
80966:         return false;
80966:     if (!EmitAtomOp(cx, pn, global ? JSOP_GETGNAME : JSOP_NAME, bce))       // OBJ V
80966:         return false;
80966:     if (Emit1(cx, bce, JSOP_POS) < 0)               // OBJ N
80966:         return false;
80966:     if (post && Emit1(cx, bce, JSOP_DUP) < 0)       // OBJ N? N
80966:         return false;
80966:     if (Emit1(cx, bce, JSOP_ONE) < 0)               // OBJ N? N 1
80966:         return false;
80966:     if (Emit1(cx, bce, binop) < 0)                  // OBJ N? N+1
77434:         return false;
77434: 
77434:     if (post) {
80966:         if (Emit2(cx, bce, JSOP_PICK, (jsbytecode)2) < 0)   // N? N+1 OBJ
80966:             return false;
80966:         if (Emit1(cx, bce, JSOP_SWAP) < 0)                  // N? OBJ N+1
80966:             return false;
80966:     }
80966: 
80966:     if (!EmitAtomOp(cx, pn, global ? JSOP_SETGNAME : JSOP_SETNAME, bce))    // N? N+1
80966:         return false;
80966:     if (post && Emit1(cx, bce, JSOP_POP) < 0)       // RESULT
80966:         return false;
80966: 
80966:     UpdateDecomposeLength(bce, start);
80966: 
80966:     if (suffix != JSOP_NOP && Emit1(cx, bce, suffix) < 0)
77456:         return false;
77456: 
77434:     return true;
77434: }
77434: 
75502: static JSBool
80966: EmitElemOp(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
75502: {
81190:     ParseNode *left, *right;
81190: 
81190:     ptrdiff_t top = bce->offset();
81190: 
78294:     if (pn->isArity(PN_NAME)) {
75502:         /*
82024:          * Set left and right so pn appears to be a PNK_LB node, instead
82024:          * of a PNK_DOT node.  See the PNK_FOR/IN case in EmitTree, and
75502:          * EmitDestructuringOps nearer below.  In the destructuring case,
75502:          * the base expression (pn_expr) of the name may be null, which
75502:          * means we have to emit a JSOP_BINDNAME.
75502:          */
75502:         left = pn->maybeExpr();
75502:         if (!left) {
82024:             left = NullaryNode::create(PNK_STRING, bce);
80639:             if (!left)
80639:                 return false;
78294:             left->setOp(JSOP_BINDNAME);
75502:             left->pn_pos = pn->pn_pos;
75502:             left->pn_atom = pn->pn_atom;
75502:         }
82024:         right = NullaryNode::create(PNK_STRING, bce);
80639:         if (!right)
80639:             return false;
80633:         right->setOp(IsIdentifier(pn->pn_atom) ? JSOP_QNAMEPART : JSOP_STRING);
75502:         right->pn_pos = pn->pn_pos;
75502:         right->pn_atom = pn->pn_atom;
75502:     } else {
78294:         JS_ASSERT(pn->isArity(PN_BINARY));
75502:         left = pn->pn_left;
75502:         right = pn->pn_right;
75502:     }
75502: 
82024:     if (op == JSOP_GETELEM && left->isKind(PNK_NAME) && right->isKind(PNK_NUMBER)) {
80966:         if (!BindNameToSlot(cx, bce, left))
80639:             return false;
75502:     }
75502: 
80966:     if (!EmitTree(cx, bce, left))
80639:         return false;
75502: 
75502:     /* The right side of the descendant operator is implicitly quoted. */
82024:     JS_ASSERT(op != JSOP_DESCENDANTS || !right->isKind(PNK_STRING) ||
78294:               right->isOp(JSOP_QNAMEPART));
80966:     if (!EmitTree(cx, bce, right))
80966:         return false;
80966:     if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - top) < 0)
80966:         return false;
80966:     return EmitElemOpBase(cx, bce, op);
77434: }
77434: 
77434: static bool
80966: EmitElemIncDec(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
77434: {
77434:     if (pn) {
80966:         if (!EmitElemOp(cx, pn, op, bce))
77434:             return false;
77434:     } else {
80966:         if (!EmitElemOpBase(cx, bce, op))
80966:             return false;
80966:     }
80966:     if (Emit1(cx, bce, JSOP_NOP) < 0)
77434:         return false;
77434: 
77434:     /* INCELEM pops two values and pushes one, so restore the initial depth. */
80966:     bce->stackDepth++;
80966: 
80966:     int start = bce->offset();
77434: 
77434:     const JSCodeSpec *cs = &js_CodeSpec[op];
77434:     JS_ASSERT(cs->format & JOF_ELEM);
77434:     JS_ASSERT(cs->format & (JOF_INC | JOF_DEC));
77434: 
77434:     bool post = (cs->format & JOF_POST);
77434:     JSOp binop = (cs->format & JOF_INC) ? JSOP_ADD : JSOP_SUB;
77434: 
77434:     /*
77434:      * We need to convert the key to an object id first, so that we do not do
77434:      * it inside both the GETELEM and the SETELEM.
77434:      */
77434:                                                     // OBJ KEY*
80966:     if (Emit1(cx, bce, JSOP_TOID) < 0)              // OBJ KEY
80966:         return false;
80966:     if (Emit1(cx, bce, JSOP_DUP2) < 0)              // OBJ KEY OBJ KEY
80966:         return false;
80966:     if (!EmitElemOpBase(cx, bce, JSOP_GETELEM))     // OBJ KEY V
80966:         return false;
80966:     if (Emit1(cx, bce, JSOP_POS) < 0)               // OBJ KEY N
80966:         return false;
80966:     if (post && Emit1(cx, bce, JSOP_DUP) < 0)       // OBJ KEY N? N
80966:         return false;
80966:     if (Emit1(cx, bce, JSOP_ONE) < 0)               // OBJ KEY N? N 1
80966:         return false;
80966:     if (Emit1(cx, bce, binop) < 0)                  // OBJ KEY N? N+1
77434:         return false;
77434: 
77434:     if (post) {
80966:         if (Emit2(cx, bce, JSOP_PICK, (jsbytecode)3) < 0)   // KEY N N+1 OBJ
80966:             return false;
80966:         if (Emit2(cx, bce, JSOP_PICK, (jsbytecode)3) < 0)   // N N+1 OBJ KEY
80966:             return false;
80966:         if (Emit2(cx, bce, JSOP_PICK, (jsbytecode)2) < 0)   // N OBJ KEY N+1
80966:             return false;
80966:     }
80966: 
80966:     if (!EmitElemOpBase(cx, bce, JSOP_SETELEM))     // N? N+1
80966:         return false;
80966:     if (post && Emit1(cx, bce, JSOP_POP) < 0)       // RESULT
80966:         return false;
80966: 
80966:     UpdateDecomposeLength(bce, start);
77434: 
77434:     return true;
75502: }
75502: 
75502: static JSBool
80966: EmitNumberOp(JSContext *cx, jsdouble dval, BytecodeEmitter *bce)
75502: {
75502:     int32_t ival;
75502:     uint32 u;
75502:     ptrdiff_t off;
75502:     jsbytecode *pc;
75502: 
75502:     if (JSDOUBLE_IS_INT32(dval, &ival)) {
75502:         if (ival == 0)
80966:             return Emit1(cx, bce, JSOP_ZERO) >= 0;
75502:         if (ival == 1)
80966:             return Emit1(cx, bce, JSOP_ONE) >= 0;
75502:         if ((jsint)(int8)ival == ival)
80966:             return Emit2(cx, bce, JSOP_INT8, (jsbytecode)(int8)ival) >= 0;
75502: 
75502:         u = (uint32)ival;
75502:         if (u < JS_BIT(16)) {
75502:             EMIT_UINT16_IMM_OP(JSOP_UINT16, u);
75502:         } else if (u < JS_BIT(24)) {
80966:             off = EmitN(cx, bce, JSOP_UINT24, 3);
75502:             if (off < 0)
75502:                 return JS_FALSE;
80966:             pc = bce->code(off);
75502:             SET_UINT24(pc, u);
75502:         } else {
80966:             off = EmitN(cx, bce, JSOP_INT32, 4);
75502:             if (off < 0)
75502:                 return JS_FALSE;
80966:             pc = bce->code(off);
75502:             SET_INT32(pc, ival);
75502:         }
75502:         return JS_TRUE;
75502:     }
75502: 
80966:     if (!bce->constList.append(DoubleValue(dval)))
80966:         return JS_FALSE;
80966: 
80966:     return EmitIndexOp(cx, JSOP_DOUBLE, bce->constList.length() - 1, bce);
75502: }
75502: 
75502: /*
75502:  * To avoid bloating all parse nodes for the special case of switch, values are
75502:  * allocated in the temp pool and pointed to by the parse node. These values
75502:  * are not currently recycled (like parse nodes) and the temp pool is only
75502:  * flushed at the end of compiling a script, so these values are technically
75502:  * leaked. This would only be a problem for scripts containing a large number
75502:  * of large switches, which seems unlikely.
75502:  */
75502: static Value *
75502: AllocateSwitchConstant(JSContext *cx)
75502: {
79410:     return cx->tempLifoAlloc().new_<Value>();
75502: }
75502: 
76232: /*
76232:  * Sometimes, let-slots are pushed to the JS stack before we logically enter
76232:  * the let scope. For example,
76250:  *     let (x = EXPR) BODY
76232:  * compiles to roughly {enterblock; EXPR; setlocal x; BODY; leaveblock} even
76232:  * though EXPR is evaluated in the enclosing scope; it does not see x.
76232:  *
76232:  * In those cases we use TempPopScope around the code to emit EXPR. It
80966:  * temporarily removes the let-scope from the BytecodeEmitter's scope stack and
76232:  * emits extra bytecode to ensure that js::GetBlockChain also finds the correct
76232:  * scope at run time.
76232:  */
76232: class TempPopScope {
80631:     StmtInfo *savedStmt;
80631:     StmtInfo *savedScopeStmt;
80631:     ObjectBox *savedBlockBox;
76232: 
76232:   public:
76272:     TempPopScope() : savedStmt(NULL), savedScopeStmt(NULL), savedBlockBox(NULL) {}
76232: 
80966:     bool popBlock(JSContext *cx, BytecodeEmitter *bce) {
80966:         savedStmt = bce->topStmt;
80966:         savedScopeStmt = bce->topScopeStmt;
80966:         savedBlockBox = bce->blockChainBox;
80966: 
80966:         if (bce->topStmt->type == STMT_FOR_LOOP || bce->topStmt->type == STMT_FOR_IN_LOOP)
80966:             PopStatementTC(bce);
80966:         JS_ASSERT(STMT_LINKS_SCOPE(bce->topStmt));
80966:         JS_ASSERT(bce->topStmt->flags & SIF_SCOPE);
80966:         PopStatementTC(bce);
76232: 
76232:         /*
76232:          * Since we have changed the block chain, emit an instruction marking
76232:          * the change for the benefit of dynamic GetScopeChain callers such as
76232:          * the debugger.
76232:          *
76232:          * FIXME bug 671360 - The JSOP_NOP instruction should not be necessary.
76232:          */
80966:         return Emit1(cx, bce, JSOP_NOP) >= 0 && EmitBlockChain(cx, bce);
80966:     }
80966: 
80966:     bool repushBlock(JSContext *cx, BytecodeEmitter *bce) {
76232:         JS_ASSERT(savedStmt);
80966:         bce->topStmt = savedStmt;
80966:         bce->topScopeStmt = savedScopeStmt;
80966:         bce->blockChainBox = savedBlockBox;
80966:         return Emit1(cx, bce, JSOP_NOP) >= 0 && EmitBlockChain(cx, bce);
76232:     }
76232: };
76232: 
75502: static JSBool
80966: EmitSwitch(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
75502: {
75502:     JSOp switchOp;
75502:     JSBool ok, hasDefault, constPropagated;
75502:     ptrdiff_t top, off, defaultOffset;
80631:     ParseNode *pn2, *pn3, *pn4;
75502:     uint32 caseCount, tableLength;
80631:     ParseNode **table;
75502:     int32_t i, low, high;
75502:     intN noteIndex;
75502:     size_t switchSize, tableSize;
75502:     jsbytecode *pc, *savepc;
75502: #if JS_HAS_BLOCK_SCOPE
80631:     ObjectBox *box;
75502: #endif
80631:     StmtInfo stmtInfo;
75502: 
75502:     /* Try for most optimal, fall back if not dense ints, and per ECMAv2. */
75502:     switchOp = JSOP_TABLESWITCH;
75502:     ok = JS_TRUE;
75502:     hasDefault = constPropagated = JS_FALSE;
75502:     defaultOffset = -1;
75502: 
75502:     /*
75502:      * If the switch contains let variables scoped by its body, model the
75502:      * resulting block on the stack first, before emitting the discriminant's
75502:      * bytecode (in case the discriminant contains a stack-model dependency
75502:      * such as a let expression).
75502:      */
75502:     pn2 = pn->pn_right;
75502: #if JS_HAS_BLOCK_SCOPE
76232:     TempPopScope tps;
82024:     if (pn2->isKind(PNK_LEXICALSCOPE)) {
75502:         /*
76232:          * Push the body's block scope before discriminant code-gen to reflect
76232:          * the order of slots on the stack. The block's locals must lie under
76232:          * the discriminant on the stack so that case-dispatch bytecodes can
76232:          * find the discriminant on top of stack.
75502:          */
75502:         box = pn2->pn_objbox;
80966:         PushBlockScope(bce, &stmtInfo, box, -1);
79378:         stmtInfo.type = STMT_SWITCH;
75502: 
75502:         /* Emit JSOP_ENTERBLOCK before code to evaluate the discriminant. */
80966:         if (!EmitEnterBlock(cx, pn2, bce))
75502:             return JS_FALSE;
75502: 
75502:         /*
76232:          * Pop the switch's statement info around discriminant code-gen, which
76232:          * belongs in the enclosing scope.
76232:          */
80966:         if (!tps.popBlock(cx, bce))
76232:             return JS_FALSE;
75502:     }
75502: #ifdef __GNUC__
75502:     else {
75502:         box = NULL;
75502:     }
75502: #endif
75502: #endif
75502: 
75502:     /*
75502:      * Emit code for the discriminant first (or nearly first, in the case of a
75502:      * switch whose body is a block scope).
75502:      */
80966:     if (!EmitTree(cx, bce, pn->pn_left))
75502:         return JS_FALSE;
75502: 
75502:     /* Switch bytecodes run from here till end of final case. */
80966:     top = bce->offset();
75502: #if !JS_HAS_BLOCK_SCOPE
80966:     PushStatement(bce, &stmtInfo, STMT_SWITCH, top);
75502: #else
82024:     if (pn2->isKind(PNK_LC)) {
80966:         PushStatement(bce, &stmtInfo, STMT_SWITCH, top);
75502:     } else {
75502:         /* Re-push the switch's statement info record. */
80966:         if (!tps.repushBlock(cx, bce))
76232:             return JS_FALSE;
76232: 
76232:         /*
76232:          * Set the statement info record's idea of top. Reset top too, since
76232:          * repushBlock emits code.
76232:          */
80966:         stmtInfo.update = top = bce->offset();
75502: 
75502:         /* Advance pn2 to refer to the switch case list. */
75502:         pn2 = pn2->expr();
75502:     }
75502: #endif
75502: 
75502:     caseCount = pn2->pn_count;
75502:     tableLength = 0;
75502:     table = NULL;
75502: 
75502:     if (caseCount == 0 ||
75502:         (caseCount == 1 &&
82024:          (hasDefault = (pn2->pn_head->isKind(PNK_DEFAULT))))) {
75502:         caseCount = 0;
75502:         low = 0;
75502:         high = -1;
75502:     } else {
75502: #define INTMAP_LENGTH   256
75502:         jsbitmap intmap_space[INTMAP_LENGTH];
75502:         jsbitmap *intmap = NULL;
75502:         int32 intmap_bitlen = 0;
75502: 
75502:         low  = JSVAL_INT_MAX;
75502:         high = JSVAL_INT_MIN;
75502: 
75502:         for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
82024:             if (pn3->isKind(PNK_DEFAULT)) {
75502:                 hasDefault = JS_TRUE;
75502:                 caseCount--;    /* one of the "cases" was the default */
75502:                 continue;
75502:             }
75502: 
82024:             JS_ASSERT(pn3->isKind(PNK_CASE));
75502:             if (switchOp == JSOP_CONDSWITCH)
75502:                 continue;
75502: 
75502:             pn4 = pn3->pn_left;
82024:             while (pn4->isKind(PNK_RP))
75502:                 pn4 = pn4->pn_kid;
75502: 
75502:             Value constVal;
78294:             switch (pn4->getKind()) {
82024:               case PNK_NUMBER:
75502:                 constVal.setNumber(pn4->pn_dval);
75502:                 break;
82024:               case PNK_STRING:
75502:                 constVal.setString(pn4->pn_atom);
75502:                 break;
82024:               case PNK_TRUE:
82022:                 constVal.setBoolean(true);
82022:                 break;
82024:               case PNK_FALSE:
82022:                 constVal.setBoolean(false);
82022:                 break;
82024:               case PNK_NULL:
82022:                 constVal.setNull();
82022:                 break;
82024:               case PNK_NAME:
75502:                 if (!pn4->maybeExpr()) {
80966:                     ok = LookupCompileTimeConstant(cx, bce, pn4->pn_atom, &constVal);
75502:                     if (!ok)
75502:                         goto release;
75502:                     if (!constVal.isMagic(JS_NO_CONSTANT)) {
75502:                         if (constVal.isObject()) {
75502:                             /*
75502:                              * XXX JSOP_LOOKUPSWITCH does not support const-
75502:                              * propagated object values, see bug 407186.
75502:                              */
75502:                             switchOp = JSOP_CONDSWITCH;
75502:                             continue;
75502:                         }
75502:                         constPropagated = JS_TRUE;
75502:                         break;
75502:                     }
75502:                 }
75502:                 /* FALL THROUGH */
75502:               default:
75502:                 switchOp = JSOP_CONDSWITCH;
75502:                 continue;
75502:             }
75502:             JS_ASSERT(constVal.isPrimitive());
75502: 
75502:             pn3->pn_pval = AllocateSwitchConstant(cx);
75502:             if (!pn3->pn_pval) {
75502:                 ok = JS_FALSE;
75502:                 goto release;
75502:             }
75502: 
75502:             *pn3->pn_pval = constVal;
75502: 
75502:             if (switchOp != JSOP_TABLESWITCH)
75502:                 continue;
75502:             if (!pn3->pn_pval->isInt32()) {
75502:                 switchOp = JSOP_LOOKUPSWITCH;
75502:                 continue;
75502:             }
75502:             i = pn3->pn_pval->toInt32();
75502:             if ((jsuint)(i + (jsint)JS_BIT(15)) >= (jsuint)JS_BIT(16)) {
75502:                 switchOp = JSOP_LOOKUPSWITCH;
75502:                 continue;
75502:             }
75502:             if (i < low)
75502:                 low = i;
75502:             if (high < i)
75502:                 high = i;
75502: 
75502:             /*
75502:              * Check for duplicates, which require a JSOP_LOOKUPSWITCH.
75502:              * We bias i by 65536 if it's negative, and hope that's a rare
75502:              * case (because it requires a malloc'd bitmap).
75502:              */
75502:             if (i < 0)
75502:                 i += JS_BIT(16);
75502:             if (i >= intmap_bitlen) {
75502:                 if (!intmap &&
75502:                     i < (INTMAP_LENGTH << JS_BITS_PER_WORD_LOG2)) {
75502:                     intmap = intmap_space;
75502:                     intmap_bitlen = INTMAP_LENGTH << JS_BITS_PER_WORD_LOG2;
75502:                 } else {
75502:                     /* Just grab 8K for the worst-case bitmap. */
75502:                     intmap_bitlen = JS_BIT(16);
75502:                     intmap = (jsbitmap *)
75502:                         cx->malloc_((JS_BIT(16) >> JS_BITS_PER_WORD_LOG2)
75502:                                    * sizeof(jsbitmap));
75502:                     if (!intmap) {
75502:                         JS_ReportOutOfMemory(cx);
75502:                         return JS_FALSE;
75502:                     }
75502:                 }
75502:                 memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
75502:             }
75502:             if (JS_TEST_BIT(intmap, i)) {
75502:                 switchOp = JSOP_LOOKUPSWITCH;
75502:                 continue;
75502:             }
75502:             JS_SET_BIT(intmap, i);
75502:         }
75502: 
75502:       release:
75502:         if (intmap && intmap != intmap_space)
75502:             cx->free_(intmap);
75502:         if (!ok)
75502:             return JS_FALSE;
75502: 
75502:         /*
75502:          * Compute table length and select lookup instead if overlarge or
75502:          * more than half-sparse.
75502:          */
75502:         if (switchOp == JSOP_TABLESWITCH) {
75502:             tableLength = (uint32)(high - low + 1);
75502:             if (tableLength >= JS_BIT(16) || tableLength > 2 * caseCount)
75502:                 switchOp = JSOP_LOOKUPSWITCH;
75502:         } else if (switchOp == JSOP_LOOKUPSWITCH) {
75502:             /*
75502:              * Lookup switch supports only atom indexes below 64K limit.
75502:              * Conservatively estimate the maximum possible index during
75502:              * switch generation and use conditional switch if it exceeds
75502:              * the limit.
75502:              */
80966:             if (caseCount + bce->constList.length() > JS_BIT(16))
75502:                 switchOp = JSOP_CONDSWITCH;
75502:         }
75502:     }
75502: 
75502:     /*
75502:      * Emit a note with two offsets: first tells total switch code length,
75502:      * second tells offset to first JSOP_CASE if condswitch.
75502:      */
80966:     noteIndex = NewSrcNote3(cx, bce, SRC_SWITCH, 0, 0);
75502:     if (noteIndex < 0)
75502:         return JS_FALSE;
75502: 
75502:     if (switchOp == JSOP_CONDSWITCH) {
75502:         /*
75502:          * 0 bytes of immediate for unoptimized ECMAv2 switch.
75502:          */
75502:         switchSize = 0;
75502:     } else if (switchOp == JSOP_TABLESWITCH) {
75502:         /*
75502:          * 3 offsets (len, low, high) before the table, 1 per entry.
75502:          */
75502:         switchSize = (size_t)(JUMP_OFFSET_LEN * (3 + tableLength));
75502:     } else {
75502:         /*
75502:          * JSOP_LOOKUPSWITCH:
75502:          * 1 offset (len) and 1 atom index (npairs) before the table,
75502:          * 1 atom index and 1 jump offset per entry.
75502:          */
75502:         switchSize = (size_t)(JUMP_OFFSET_LEN + INDEX_LEN +
75502:                               (INDEX_LEN + JUMP_OFFSET_LEN) * caseCount);
75502:     }
75502: 
75502:     /*
75502:      * Emit switchOp followed by switchSize bytes of jump or lookup table.
75502:      *
75502:      * If switchOp is JSOP_LOOKUPSWITCH or JSOP_TABLESWITCH, it is crucial
75502:      * to emit the immediate operand(s) by which bytecode readers such as
75502:      * BuildSpanDepTable discover the length of the switch opcode *before*
80632:      * calling SetJumpOffset (which may call BuildSpanDepTable).  It's
75502:      * also important to zero all unknown jump offset immediate operands,
75502:      * so they can be converted to span dependencies with null targets to
80632:      * be computed later (EmitN zeros switchSize bytes after switchOp).
80632:      */
80966:     if (EmitN(cx, bce, switchOp, switchSize) < 0)
75502:         return JS_FALSE;
75502: 
75502:     off = -1;
75502:     if (switchOp == JSOP_CONDSWITCH) {
75502:         intN caseNoteIndex = -1;
75502:         JSBool beforeCases = JS_TRUE;
75502: 
75502:         /* Emit code for evaluating cases and jumping to case statements. */
75502:         for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
75502:             pn4 = pn3->pn_left;
80966:             if (pn4 && !EmitTree(cx, bce, pn4))
75502:                 return JS_FALSE;
75502:             if (caseNoteIndex >= 0) {
75502:                 /* off is the previous JSOP_CASE's bytecode offset. */
80966:                 if (!SetSrcNoteOffset(cx, bce, (uintN)caseNoteIndex, 0, bce->offset() - off))
80632:                     return JS_FALSE;
75502:             }
75502:             if (!pn4) {
82024:                 JS_ASSERT(pn3->isKind(PNK_DEFAULT));
75502:                 continue;
75502:             }
80966:             caseNoteIndex = NewSrcNote2(cx, bce, SRC_PCDELTA, 0);
75502:             if (caseNoteIndex < 0)
75502:                 return JS_FALSE;
80966:             off = EmitJump(cx, bce, JSOP_CASE, 0);
75502:             if (off < 0)
75502:                 return JS_FALSE;
75502:             pn3->pn_offset = off;
75502:             if (beforeCases) {
75502:                 uintN noteCount, noteCountDelta;
75502: 
75502:                 /* Switch note's second offset is to first JSOP_CASE. */
80966:                 noteCount = bce->noteCount();
80966:                 if (!SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 1, off - top))
80966:                     return JS_FALSE;
80966:                 noteCountDelta = bce->noteCount() - noteCount;
75502:                 if (noteCountDelta != 0)
75502:                     caseNoteIndex += noteCountDelta;
75502:                 beforeCases = JS_FALSE;
75502:             }
75502:         }
75502: 
75502:         /*
75502:          * If we didn't have an explicit default (which could fall in between
80632:          * cases, preventing us from fusing this SetSrcNoteOffset with the call
80632:          * in the loop above), link the last case to the implicit default for
80632:          * the decompiler.
75502:          */
75502:         if (!hasDefault &&
75502:             caseNoteIndex >= 0 &&
80966:             !SetSrcNoteOffset(cx, bce, (uintN)caseNoteIndex, 0, bce->offset() - off))
80632:         {
75502:             return JS_FALSE;
75502:         }
75502: 
75502:         /* Emit default even if no explicit default statement. */
80966:         defaultOffset = EmitJump(cx, bce, JSOP_DEFAULT, 0);
75502:         if (defaultOffset < 0)
75502:             return JS_FALSE;
75502:     } else {
80966:         pc = bce->code(top + JUMP_OFFSET_LEN);
75502: 
75502:         if (switchOp == JSOP_TABLESWITCH) {
75502:             /* Fill in switch bounds, which we know fit in 16-bit offsets. */
75502:             SET_JUMP_OFFSET(pc, low);
75502:             pc += JUMP_OFFSET_LEN;
75502:             SET_JUMP_OFFSET(pc, high);
75502:             pc += JUMP_OFFSET_LEN;
75502: 
75502:             /*
75502:              * Use malloc to avoid arena bloat for programs with many switches.
75502:              * We free table if non-null at label out, so all control flow must
75502:              * exit this function through goto out or goto bad.
75502:              */
75502:             if (tableLength != 0) {
75502:                 tableSize = (size_t)tableLength * sizeof *table;
80631:                 table = (ParseNode **) cx->malloc_(tableSize);
75502:                 if (!table)
75502:                     return JS_FALSE;
75502:                 memset(table, 0, tableSize);
75502:                 for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
82024:                     if (pn3->isKind(PNK_DEFAULT))
75502:                         continue;
75502:                     i = pn3->pn_pval->toInt32();
75502:                     i -= low;
75502:                     JS_ASSERT((uint32)i < tableLength);
75502:                     table[i] = pn3;
75502:                 }
75502:             }
75502:         } else {
75502:             JS_ASSERT(switchOp == JSOP_LOOKUPSWITCH);
75502: 
75502:             /* Fill in the number of cases. */
75502:             SET_INDEX(pc, caseCount);
75502:             pc += INDEX_LEN;
75502:         }
75502: 
75502:         /*
75502:          * After this point, all control flow involving JSOP_TABLESWITCH
75502:          * must set ok and goto out to exit this function.  To keep things
75502:          * simple, all switchOp cases exit that way.
75502:          */
75502:         MUST_FLOW_THROUGH("out");
80966:         if (bce->spanDeps) {
75502:             /*
75502:              * We have already generated at least one big jump so we must
75502:              * explicitly add span dependencies for the switch jumps. When
80632:              * called below, SetJumpOffset can only do it when patching the
80966:              * first big jump or when bce->spanDeps is null.
80966:              */
80966:             if (!AddSwitchSpanDeps(cx, bce, bce->code(top)))
75502:                 goto bad;
75502:         }
75502: 
75502:         if (constPropagated) {
75502:             /*
75502:              * Skip switchOp, as we are not setting jump offsets in the two
80966:              * for loops below.  We'll restore bce->next() from savepc after,
75502:              * unless there was an error.
75502:              */
80966:             savepc = bce->next();
80966:             bce->current->next = pc + 1;
75502:             if (switchOp == JSOP_TABLESWITCH) {
75502:                 for (i = 0; i < (jsint)tableLength; i++) {
75502:                     pn3 = table[i];
75502:                     if (pn3 &&
75502:                         (pn4 = pn3->pn_left) != NULL &&
82024:                         pn4->isKind(PNK_NAME))
82024:                     {
75502:                         /* Note a propagated constant with the const's name. */
75502:                         JS_ASSERT(!pn4->maybeExpr());
75510:                         jsatomid index;
80966:                         if (!bce->makeAtomIndex(pn4->pn_atom, &index))
75502:                             goto bad;
80966:                         bce->current->next = pc;
80966:                         if (NewSrcNote2(cx, bce, SRC_LABEL, ptrdiff_t(index)) < 0)
75502:                             goto bad;
75502:                     }
75502:                     pc += JUMP_OFFSET_LEN;
75502:                 }
75502:             } else {
75502:                 for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
75502:                     pn4 = pn3->pn_left;
82024:                     if (pn4 && pn4->isKind(PNK_NAME)) {
75502:                         /* Note a propagated constant with the const's name. */
75502:                         JS_ASSERT(!pn4->maybeExpr());
75510:                         jsatomid index;
80966:                         if (!bce->makeAtomIndex(pn4->pn_atom, &index))
75502:                             goto bad;
80966:                         bce->current->next = pc;
80966:                         if (NewSrcNote2(cx, bce, SRC_LABEL, ptrdiff_t(index)) < 0)
75502:                             goto bad;
75502:                     }
75502:                     pc += INDEX_LEN + JUMP_OFFSET_LEN;
75502:                 }
75502:             }
80966:             bce->current->next = savepc;
75502:         }
75502:     }
75502: 
75502:     /* Emit code for each case's statements, copying pn_offset up to pn3. */
75502:     for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
82024:         if (switchOp == JSOP_CONDSWITCH && !pn3->isKind(PNK_DEFAULT))
80966:             CHECK_AND_SET_JUMP_OFFSET_AT_CUSTOM(cx, bce, pn3->pn_offset, goto bad);
75502:         pn4 = pn3->pn_right;
80966:         ok = EmitTree(cx, bce, pn4);
75502:         if (!ok)
75502:             goto out;
75502:         pn3->pn_offset = pn4->pn_offset;
82024:         if (pn3->isKind(PNK_DEFAULT))
75502:             off = pn3->pn_offset - top;
75502:     }
75502: 
75502:     if (!hasDefault) {
75502:         /* If no default case, offset for default is to end of switch. */
80966:         off = bce->offset() - top;
75502:     }
75502: 
75502:     /* We better have set "off" by now. */
75502:     JS_ASSERT(off != -1);
75502: 
75502:     /* Set the default offset (to end of switch if no default). */
75502:     if (switchOp == JSOP_CONDSWITCH) {
75502:         pc = NULL;
75502:         JS_ASSERT(defaultOffset != -1);
80966:         ok = SetJumpOffset(cx, bce, bce->code(defaultOffset), off - (defaultOffset - top));
75502:         if (!ok)
75502:             goto out;
75502:     } else {
80966:         pc = bce->code(top);
80966:         ok = SetJumpOffset(cx, bce, pc, off);
75502:         if (!ok)
75502:             goto out;
75502:         pc += JUMP_OFFSET_LEN;
75502:     }
75502: 
75502:     /* Set the SRC_SWITCH note's offset operand to tell end of switch. */
80966:     off = bce->offset() - top;
80966:     ok = SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 0, off);
75502:     if (!ok)
75502:         goto out;
75502: 
75502:     if (switchOp == JSOP_TABLESWITCH) {
75502:         /* Skip over the already-initialized switch bounds. */
75502:         pc += 2 * JUMP_OFFSET_LEN;
75502: 
75502:         /* Fill in the jump table, if there is one. */
75502:         for (i = 0; i < (jsint)tableLength; i++) {
75502:             pn3 = table[i];
75502:             off = pn3 ? pn3->pn_offset - top : 0;
80966:             ok = SetJumpOffset(cx, bce, pc, off);
75502:             if (!ok)
75502:                 goto out;
75502:             pc += JUMP_OFFSET_LEN;
75502:         }
75502:     } else if (switchOp == JSOP_LOOKUPSWITCH) {
75502:         /* Skip over the already-initialized number of cases. */
75502:         pc += INDEX_LEN;
75502: 
75502:         for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
82024:             if (pn3->isKind(PNK_DEFAULT))
75502:                 continue;
80966:             if (!bce->constList.append(*pn3->pn_pval))
75502:                 goto bad;
80966:             SET_INDEX(pc, bce->constList.length() - 1);
75502:             pc += INDEX_LEN;
75502: 
75502:             off = pn3->pn_offset - top;
80966:             ok = SetJumpOffset(cx, bce, pc, off);
75502:             if (!ok)
75502:                 goto out;
75502:             pc += JUMP_OFFSET_LEN;
75502:         }
75502:     }
75502: 
75502: out:
75502:     if (table)
75502:         cx->free_(table);
75502:     if (ok) {
80966:         ok = PopStatementBCE(cx, bce);
75502: 
75502: #if JS_HAS_BLOCK_SCOPE
82024:         if (ok && pn->pn_right->isKind(PNK_LEXICALSCOPE))
80966:             ok = EmitLeaveBlock(cx, bce, JSOP_LEAVEBLOCK, box);
75502: #endif
75502:     }
75502:     return ok;
75502: 
75502: bad:
75502:     ok = JS_FALSE;
75502:     goto out;
75502: }
75502: 
75502: JSBool
80966: frontend::EmitFunctionScript(JSContext *cx, BytecodeEmitter *bce, ParseNode *body)
75502: {
75502:     /*
75502:      * The decompiler has assumptions about what may occur immediately after
75502:      * script->main (e.g., in the case of destructuring params). Thus, put the
75502:      * following ops into the range [script->code, script->main). Note:
75502:      * execution starts from script->code, so this has no semantic effect.
75502:      */
75502: 
80966:     if (bce->flags & TCF_FUN_IS_GENERATOR) {
75502:         /* JSOP_GENERATOR must be the first instruction. */
80966:         bce->switchToProlog();
80966:         JS_ASSERT(bce->next() == bce->base());
80966:         if (Emit1(cx, bce, JSOP_GENERATOR) < 0)
80966:             return false;
80966:         bce->switchToMain();
75502:     }
75502: 
75502:     /*
75502:      * Strict mode functions' arguments objects copy initial parameter values.
75502:      * We create arguments objects lazily -- but that doesn't work for strict
75502:      * mode functions where a parameter might be modified and arguments might
75502:      * be accessed. For such functions we synthesize an access to arguments to
75502:      * initialize it with the original parameter values.
75502:      */
80966:     if (bce->needsEagerArguments()) {
80966:         bce->switchToProlog();
80966:         if (Emit1(cx, bce, JSOP_ARGUMENTS) < 0 || Emit1(cx, bce, JSOP_POP) < 0)
80966:             return false;
80966:         bce->switchToMain();
80966:     }
80966: 
80966:     if (bce->flags & TCF_FUN_UNBRAND_THIS) {
80966:         bce->switchToProlog();
80966:         if (Emit1(cx, bce, JSOP_UNBRANDTHIS) < 0)
80966:             return false;
80966:         bce->switchToMain();
80966:     }
80966: 
80966:     return EmitTree(cx, bce, body) &&
80966:            Emit1(cx, bce, JSOP_STOP) >= 0 &&
80966:            JSScript::NewScriptFromEmitter(cx, bce);
75502: }
75502: 
72579: static bool
80966: MaybeEmitVarDecl(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp, ParseNode *pn,
80966:                  jsatomid *result)
    1: {
    1:     jsatomid atomIndex;
    1: 
47573:     if (!pn->pn_cookie.isFree()) {
72579:         atomIndex = pn->pn_cookie.slot();
    1:     } else {
80966:         if (!bce->makeAtomIndex(pn->pn_atom, &atomIndex))
72579:             return false;
    1:     }
    1: 
78294:     if (JOF_OPTYPE(pn->getOp()) == JOF_ATOM &&
80966:         (!bce->inFunction() || (bce->flags & TCF_FUN_HEAVYWEIGHT)) &&
60526:         !(pn->pn_dflags & PND_GVAR))
52555:     {
80966:         bce->switchToProlog();
80966:         if (!UpdateLineNumberNotes(cx, bce, pn->pn_pos.begin.lineno))
72579:             return false;
 3235:         EMIT_INDEX_OP(prologOp, atomIndex);
80966:         bce->switchToMain();
80966:     }
80966: 
80966:     if (bce->inFunction() &&
78294:         JOF_OPTYPE(pn->getOp()) == JOF_LOCAL &&
80966:         pn->pn_cookie.slot() < bce->bindings.countVars() &&
80966:         bce->shouldNoteClosedName(pn))
80966:     {
80966:         if (!bce->closedVars.append(pn->pn_cookie.slot()))
72579:             return false;
52878:     }
52878: 
    1:     if (result)
    1:         *result = atomIndex;
72579:     return true;
    1: }
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: 
    1: typedef JSBool
80966: (*DestructuringDeclEmitter)(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp, ParseNode *pn);
    1: 
    1: static JSBool
80966: EmitDestructuringDecl(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp, ParseNode *pn)
    1: {
82024:     JS_ASSERT(pn->isKind(PNK_NAME));
80966:     if (!BindNameToSlot(cx, bce, pn))
 9604:         return JS_FALSE;
    1: 
78294:     JS_ASSERT(!pn->isOp(JSOP_ARGUMENTS) && !pn->isOp(JSOP_CALLEE));
80966:     return MaybeEmitVarDecl(cx, bce, prologOp, pn, NULL);
    1: }
    1: 
    1: static JSBool
80966: EmitDestructuringDecls(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp, ParseNode *pn)
80631: {
80631:     ParseNode *pn2, *pn3;
    1:     DestructuringDeclEmitter emitter;
    1: 
82024:     if (pn->isKind(PNK_RB)) {
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
82024:             if (pn2->isKind(PNK_COMMA))
    1:                 continue;
82024:             emitter = (pn2->isKind(PNK_NAME))
    1:                       ? EmitDestructuringDecl
    1:                       : EmitDestructuringDecls;
80966:             if (!emitter(cx, bce, prologOp, pn2))
    1:                 return JS_FALSE;
    1:         }
    1:     } else {
82024:         JS_ASSERT(pn->isKind(PNK_RC));
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:             pn3 = pn2->pn_right;
82024:             emitter = pn3->isKind(PNK_NAME) ? EmitDestructuringDecl : EmitDestructuringDecls;
80966:             if (!emitter(cx, bce, prologOp, pn3))
    1:                 return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
80966: EmitDestructuringOpsHelper(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn);
    1: 
    1: static JSBool
80966: EmitDestructuringLHS(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
    1: {
    1:     /*
    1:      * Now emit the lvalue opcode sequence.  If the lvalue is a nested
    1:      * destructuring initialiser-form, call ourselves to handle it, then
    1:      * pop the matched value.  Otherwise emit an lvalue bytecode sequence
    1:      * ending with a JSOP_ENUMELEM or equivalent op.
    1:      */
82024:     if (pn->isKind(PNK_RB) || pn->isKind(PNK_RC)) {
80966:         if (!EmitDestructuringOpsHelper(cx, bce, pn))
80966:             return JS_FALSE;
80966:         if (Emit1(cx, bce, JSOP_POP) < 0)
    1:             return JS_FALSE;
    1:     } else {
82024:         if (pn->isKind(PNK_NAME)) {
80966:             if (!BindNameToSlot(cx, bce, pn))
27012:                 return JS_FALSE;
27012:             if (pn->isConst() && !pn->isInitialized())
80966:                 return Emit1(cx, bce, JSOP_POP) >= 0;
27012:         }
    1: 
78294:         switch (pn->getOp()) {
    1:           case JSOP_SETNAME:
52825:           case JSOP_SETGNAME:
    1:             /*
    1:              * NB: pn is a PN_NAME node, not a PN_BINARY.  Nevertheless,
    1:              * we want to emit JSOP_ENUMELEM, which has format JOF_ELEM.
    1:              * So here and for JSOP_ENUMCONSTELEM, we use EmitElemOp.
    1:              */
80966:             if (!EmitElemOp(cx, pn, JSOP_ENUMELEM, bce))
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case JSOP_SETCONST:
80966:             if (!EmitElemOp(cx, pn, JSOP_ENUMCONSTELEM, bce))
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case JSOP_SETLOCAL:
47573:           {
47573:             jsuint slot = pn->pn_cookie.asInteger();
    1:             EMIT_UINT16_IMM_OP(JSOP_SETLOCALPOP, slot);
    1:             break;
47573:           }
    1: 
    1:           case JSOP_SETARG:
47573:           {
47573:             jsuint slot = pn->pn_cookie.asInteger();
78294:             EMIT_UINT16_IMM_OP(pn->getOp(), slot);
80966:             if (Emit1(cx, bce, JSOP_POP) < 0)
    1:                 return JS_FALSE;
    1:             break;
47573:           }
    1: 
    1:           default:
    1:           {
    1:             ptrdiff_t top;
    1: 
80966:             top = bce->offset();
80966:             if (!EmitTree(cx, bce, pn))
80966:                 return JS_FALSE;
80966:             if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - top) < 0)
80966:                 return JS_FALSE;
80966:             if (!EmitElemOpBase(cx, bce, JSOP_ENUMELEM))
    1:                 return JS_FALSE;
    1:             break;
    1:           }
31815: 
    1:           case JSOP_ENUMELEM:
    1:             JS_ASSERT(0);
    1:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Recursive helper for EmitDestructuringOps.
    1:  *
    1:  * Given a value to destructure on the stack, walk over an object or array
    1:  * initialiser at pn, emitting bytecodes to match property values and store
    1:  * them in the lvalues identified by the matched property names.
    1:  */
    1: static JSBool
80966: EmitDestructuringOpsHelper(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
    1: {
    1:     jsuint index;
80631:     ParseNode *pn2, *pn3;
    1:     JSBool doElemOp;
    1: 
    1: #ifdef DEBUG
80966:     intN stackDepth = bce->stackDepth;
    1:     JS_ASSERT(stackDepth != 0);
78294:     JS_ASSERT(pn->isArity(PN_LIST));
82024:     JS_ASSERT(pn->isKind(PNK_RB) || pn->isKind(PNK_RC));
    1: #endif
    1: 
    1:     if (pn->pn_count == 0) {
    1:         /* Emit a DUP;POP sequence for the decompiler. */
80966:         return Emit1(cx, bce, JSOP_DUP) >= 0 &&
80966:                Emit1(cx, bce, JSOP_POP) >= 0;
    1:     }
    1: 
    1:     index = 0;
    1:     for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:         /*
    1:          * Duplicate the value being destructured to use as a reference base.
26956:          * If dup is not the first one, annotate it for the decompiler.
26956:          */
80966:         if (pn2 != pn->pn_head && NewSrcNote(cx, bce, SRC_CONTINUE) < 0)
80966:             return JS_FALSE;
80966:         if (Emit1(cx, bce, JSOP_DUP) < 0)
    1:             return JS_FALSE;
    1: 
    1:         /*
    1:          * Now push the property name currently being matched, which is either
    1:          * the array initialiser's current index, or the current property name
    1:          * "label" on the left of a colon in the object initialiser.  Set pn3
    1:          * to the lvalue node, which is in the value-initializing position.
    1:          */
    1:         doElemOp = JS_TRUE;
82024:         if (pn->isKind(PNK_RB)) {
80966:             if (!EmitNumberOp(cx, index, bce))
    1:                 return JS_FALSE;
    1:             pn3 = pn2;
    1:         } else {
82024:             JS_ASSERT(pn->isKind(PNK_RC));
82024:             JS_ASSERT(pn2->isKind(PNK_COLON));
    1:             pn3 = pn2->pn_left;
82024:             if (pn3->isKind(PNK_NUMBER)) {
    1:                 /*
    1:                  * If we are emitting an object destructuring initialiser,
    1:                  * annotate the index op with SRC_INITPROP so we know we are
    1:                  * not decompiling an array initialiser.
    1:                  */
80966:                 if (NewSrcNote(cx, bce, SRC_INITPROP) < 0)
80966:                     return JS_FALSE;
80966:                 if (!EmitNumberOp(cx, pn3->pn_dval, bce))
    1:                     return JS_FALSE;
    1:             } else {
82024:                 JS_ASSERT(pn3->isKind(PNK_STRING) || pn3->isKind(PNK_NAME));
80966:                 if (!EmitAtomOp(cx, pn3, JSOP_GETPROP, bce))
    1:                     return JS_FALSE;
    1:                 doElemOp = JS_FALSE;
    1:             }
    1:             pn3 = pn2->pn_right;
    1:         }
    1: 
    1:         if (doElemOp) {
    1:             /*
    1:              * Ok, get the value of the matching property name.  This leaves
    1:              * that value on top of the value being destructured, so the stack
    1:              * is one deeper than when we started.
    1:              */
80966:             if (!EmitElemOpBase(cx, bce, JSOP_GETELEM))
80966:                 return JS_FALSE;
80966:             JS_ASSERT(bce->stackDepth == stackDepth + 1);
    1:         }
    1: 
    1:         /* Nullary comma node makes a hole in the array destructurer. */
82024:         if (pn3->isKind(PNK_COMMA) && pn3->isArity(PN_NULLARY)) {
82024:             JS_ASSERT(pn->isKind(PNK_RB));
    1:             JS_ASSERT(pn2 == pn3);
80966:             if (Emit1(cx, bce, JSOP_POP) < 0)
    1:                 return JS_FALSE;
    1:         } else {
80966:             if (!EmitDestructuringLHS(cx, bce, pn3))
80966:                 return JS_FALSE;
80966:         }
80966: 
80966:         JS_ASSERT(bce->stackDepth == stackDepth);
    1:         ++index;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static ptrdiff_t
    1: OpToDeclType(JSOp op)
    1: {
    1:     switch (op) {
    1:       case JSOP_NOP:
    1:         return SRC_DECL_LET;
    1:       case JSOP_DEFCONST:
    1:         return SRC_DECL_CONST;
    1:       case JSOP_DEFVAR:
    1:         return SRC_DECL_VAR;
    1:       default:
    1:         return SRC_DECL_NONE;
    1:     }
    1: }
    1: 
    1: static JSBool
80966: EmitDestructuringOps(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp, ParseNode *pn)
    1: {
    1:     /*
    1:      * If we're called from a variable declaration, help the decompiler by
    1:      * annotating the first JSOP_DUP that EmitDestructuringOpsHelper emits.
    1:      * If the destructuring initialiser is empty, our helper will emit a
    1:      * JSOP_DUP followed by a JSOP_POP for the decompiler.
    1:      */
80966:     if (NewSrcNote2(cx, bce, SRC_DESTRUCT, OpToDeclType(prologOp)) < 0)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * Call our recursive helper to emit the destructuring assignments and
    1:      * related stack manipulations.
    1:      */
80966:     return EmitDestructuringOpsHelper(cx, bce, pn);
    1: }
    1: 
    1: static JSBool
80966: EmitGroupAssignment(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp,
80631:                     ParseNode *lhs, ParseNode *rhs)
    1: {
16072:     jsuint depth, limit, i, nslots;
80631:     ParseNode *pn;
    1: 
80966:     depth = limit = (uintN) bce->stackDepth;
    1:     for (pn = rhs->pn_head; pn; pn = pn->pn_next) {
    1:         if (limit == JS_BIT(16)) {
80966:             ReportCompileErrorNumber(cx, bce->tokenStream(), rhs, JSREPORT_ERROR,
80966:                                      JSMSG_ARRAY_INIT_TOO_BIG);
    1:             return JS_FALSE;
    1:         }
    1: 
28123:         /* MaybeEmitGroupAssignment won't call us if rhs is holey. */
82024:         JS_ASSERT(!(pn->isKind(PNK_COMMA) && pn->isArity(PN_NULLARY)));
80966:         if (!EmitTree(cx, bce, pn))
    1:             return JS_FALSE;
    1:         ++limit;
    1:     }
    1: 
80966:     if (NewSrcNote2(cx, bce, SRC_GROUPASSIGN, OpToDeclType(prologOp)) < 0)
    1:         return JS_FALSE;
    1: 
16072:     i = depth;
16072:     for (pn = lhs->pn_head; pn; pn = pn->pn_next, ++i) {
28123:         /* MaybeEmitGroupAssignment requires lhs->pn_count <= rhs->pn_count. */
28123:         JS_ASSERT(i < limit);
80966:         jsint slot = AdjustBlockSlot(cx, bce, i);
16072:         if (slot < 0)
16072:             return JS_FALSE;
    1:         EMIT_UINT16_IMM_OP(JSOP_GETLOCAL, slot);
28123: 
82024:         if (pn->isKind(PNK_COMMA) && pn->isArity(PN_NULLARY)) {
80966:             if (Emit1(cx, bce, JSOP_POP) < 0)
    1:                 return JS_FALSE;
    1:         } else {
80966:             if (!EmitDestructuringLHS(cx, bce, pn))
    1:                 return JS_FALSE;
    1:         }
    1:     }
    1: 
 1227:     nslots = limit - depth;
 1227:     EMIT_UINT16_IMM_OP(JSOP_POPN, nslots);
80966:     bce->stackDepth = (uintN) depth;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Helper called with pop out param initialized to a JSOP_POP* opcode.  If we
    1:  * can emit a group assignment sequence, which results in 0 stack depth delta,
    1:  * we set *pop to JSOP_NOP so callers can veto emitting pn followed by a pop.
    1:  */
    1: static JSBool
80966: MaybeEmitGroupAssignment(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp, ParseNode *pn,
80966:                          JSOp *pop)
80631: {
82024:     JS_ASSERT(pn->isKind(PNK_ASSIGN));
82023:     JS_ASSERT(pn->isOp(JSOP_NOP));
    1:     JS_ASSERT(*pop == JSOP_POP || *pop == JSOP_POPV);
82023: 
82023:     ParseNode *lhs = pn->pn_left;
82023:     ParseNode *rhs = pn->pn_right;
82024:     if (lhs->isKind(PNK_RB) && rhs->isKind(PNK_RB) &&
28123:         !(rhs->pn_xflags & PNX_HOLEY) &&
26959:         lhs->pn_count <= rhs->pn_count) {
80966:         if (!EmitGroupAssignment(cx, bce, prologOp, lhs, rhs))
    1:             return JS_FALSE;
    1:         *pop = JSOP_NOP;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
    1: static JSBool
80966: EmitVariables(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, JSBool inLetHead,
80631:               ptrdiff_t *headNoteIndex)
    1: {
78207:     bool forInVar, first;
    1:     ptrdiff_t off, noteIndex, tmp;
80631:     ParseNode *pn2, *pn3, *next;
    1:     JSOp op;
    1:     jsatomid atomIndex;
    1:     uintN oldflags;
    1: 
    1:     /* Default in case of JS_HAS_BLOCK_SCOPE early return, below. */
    1:     *headNoteIndex = -1;
    1: 
    1:     /*
    1:      * Let blocks and expressions have a parenthesized head in which the new
    1:      * scope is not yet open. Initializer evaluation uses the parent node's
    1:      * lexical scope. If popScope is true below, then we hide the top lexical
    1:      * block from any calls to BindNameToSlot hiding in pn2->pn_expr so that
    1:      * it won't find any names in the new let block.
    1:      *
    1:      * The same goes for let declarations in the head of any kind of for loop.
    1:      * Unlike a let declaration 'let x = i' within a block, where x is hoisted
    1:      * to the start of the block, a 'for (let x = i...) ...' loop evaluates i
    1:      * in the containing scope, and puts x in the loop body's scope.
    1:      */
78294:     DebugOnly<bool> let = (pn->isOp(JSOP_NOP));
27012:     forInVar = (pn->pn_xflags & PNX_FORINVAR) != 0;
    1: 
    1:     off = noteIndex = -1;
27012:     for (pn2 = pn->pn_head; ; pn2 = next) {
27012:         first = pn2 == pn->pn_head;
27012:         next = pn2->pn_next;
27012: 
82024:         if (!pn2->isKind(PNK_NAME)) {
26970: #if JS_HAS_DESTRUCTURING
82024:             if (pn2->isKind(PNK_RB) || pn2->isKind(PNK_RC)) {
    1:                 /*
80634:                  * Emit variable binding ops, but not destructuring ops.  The
80634:                  * parser (see Parser::variables) has ensured that our caller
82024:                  * will be the PNK_FOR/PNK_IN case in EmitTree, and that case
80634:                  * will emit the destructuring code only after emitting an
80634:                  * enumerating opcode and a branch that tests whether the
80634:                  * enumeration ended.
    1:                  */
    1:                 JS_ASSERT(forInVar);
    1:                 JS_ASSERT(pn->pn_count == 1);
80966:                 if (!EmitDestructuringDecls(cx, bce, pn->getOp(), pn2))
    1:                     return JS_FALSE;
    1:                 break;
    1:             }
27012: #endif
    1: 
    1:             /*
20413:              * A destructuring initialiser assignment preceded by var will
20413:              * never occur to the left of 'in' in a for-in loop.  As with 'for
20413:              * (var x = i in o)...', this will cause the entire 'var [a, b] =
20413:              * i' to be hoisted out of the loop.
    1:              */
82024:             JS_ASSERT(pn2->isKind(PNK_ASSIGN));
82023:             JS_ASSERT(pn2->isOp(JSOP_NOP));
20413:             JS_ASSERT(!forInVar);
27012: 
27012:             /*
27012:              * To allow the front end to rewrite var f = x; as f = x; when a
27012:              * function f(){} precedes the var, detect simple name assignment
27012:              * here and initialize the name.
27012:              */
27012: #if !JS_HAS_DESTRUCTURING
82024:             JS_ASSERT(pn2->pn_left->isKind(PNK_NAME));
27012: #else
82024:             if (pn2->pn_left->isKind(PNK_NAME))
27012: #endif
27012:             {
27012:                 pn3 = pn2->pn_right;
27012:                 pn2 = pn2->pn_left;
27012:                 goto do_name;
27012:             }
27012: 
27012: #if JS_HAS_DESTRUCTURING
20413:             if (pn->pn_count == 1) {
    1:                 /*
    1:                  * If this is the only destructuring assignment in the list,
    1:                  * try to optimize to a group assignment.  If we're in a let
    1:                  * head, pass JSOP_POP rather than the pseudo-prolog JSOP_NOP
    1:                  * in pn->pn_op, to suppress a second (and misplaced) 'let'.
    1:                  */
    1:                 JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
    1:                 op = JSOP_POP;
80966:                 if (!MaybeEmitGroupAssignment(cx, bce,
78294:                                               inLetHead ? JSOP_POP : pn->getOp(),
    1:                                               pn2, &op)) {
    1:                     return JS_FALSE;
    1:                 }
    1:                 if (op == JSOP_NOP) {
27012:                     pn->pn_xflags = (pn->pn_xflags & ~PNX_POPVAR) | PNX_GROUPINIT;
    1:                     break;
    1:                 }
    1:             }
    1: 
    1:             pn3 = pn2->pn_left;
80966:             if (!EmitDestructuringDecls(cx, bce, pn->getOp(), pn3))
80966:                 return JS_FALSE;
80966: 
80966:             if (!EmitTree(cx, bce, pn2->pn_right))
    1:                 return JS_FALSE;
    1: 
    1:             /*
    1:              * Veto pn->pn_op if inLetHead to avoid emitting a SRC_DESTRUCT
    1:              * that's redundant with respect to the SRC_DECL/SRC_DECL_LET that
    1:              * we will emit at the bottom of this function.
    1:              */
80966:             if (!EmitDestructuringOps(cx, bce,
78294:                                       inLetHead ? JSOP_POP : pn->getOp(),
    1:                                       pn3)) {
    1:                 return JS_FALSE;
    1:             }
    1:             goto emit_note_pop;
    1: #endif
27012:         }
27012: 
27012:         /*
27012:          * Load initializer early to share code above that jumps to do_name.
27012:          * NB: if this var redeclares an existing binding, then pn2 is linked
27012:          * on its definition's use-chain and pn_expr has been overlayed with
27012:          * pn_lexdef.
27012:          */
27012:         pn3 = pn2->maybeExpr();
27012: 
27012:      do_name:
80966:         if (!BindNameToSlot(cx, bce, pn2))
    1:             return JS_FALSE;
    1: 
78294:         op = pn2->getOp();
    1:         if (op == JSOP_ARGUMENTS) {
    1:             /* JSOP_ARGUMENTS => no initializer */
27012:             JS_ASSERT(!pn3 && !let);
    1:             pn3 = NULL;
    1: #ifdef __GNUC__
    1:             atomIndex = 0;            /* quell GCC overwarning */
    1: #endif
    1:         } else {
27012:             JS_ASSERT(op != JSOP_CALLEE);
47573:             JS_ASSERT(!pn2->pn_cookie.isFree() || !let);
80966:             if (!MaybeEmitVarDecl(cx, bce, pn->getOp(), pn2, &atomIndex))
    1:                 return JS_FALSE;
    1: 
    1:             if (pn3) {
20413:                 JS_ASSERT(!forInVar);
    1:                 if (op == JSOP_SETNAME) {
    1:                     JS_ASSERT(!let);
 3235:                     EMIT_INDEX_OP(JSOP_BINDNAME, atomIndex);
52825:                 } else if (op == JSOP_SETGNAME) {
52825:                     JS_ASSERT(!let);
52825:                     EMIT_INDEX_OP(JSOP_BINDGNAME, atomIndex);
    1:                 }
78294:                 if (pn->isOp(JSOP_DEFCONST) &&
80966:                     !DefineCompileTimeConstant(cx, bce, pn2->pn_atom, pn3))
80966:                 {
80966:                     return JS_FALSE;
80966:                 }
80966: 
80966:                 oldflags = bce->flags;
80966:                 bce->flags &= ~TCF_IN_FOR_INIT;
80966:                 if (!EmitTree(cx, bce, pn3))
80966:                     return JS_FALSE;
80966:                 bce->flags |= oldflags & TCF_IN_FOR_INIT;
    1:             }
    1:         }
    1: 
    1:         /*
20413:          * The parser rewrites 'for (var x = i in o)' to hoist 'var x = i' --
20413:          * likewise 'for (let x = i in o)' becomes 'i; for (let x in o)' using
82024:          * a PNK_SEQ node to make the two statements appear as one. Therefore
20413:          * if this declaration is part of a for-in loop head, we do not need to
82024:          * emit op or any source note. Our caller, the PNK_FOR/PNK_IN case in
80632:          * EmitTree, will annotate appropriately.
    1:          */
78294:         JS_ASSERT_IF(pn2->isDefn(), pn3 == pn2->pn_expr);
20413:         if (forInVar) {
    1:             JS_ASSERT(pn->pn_count == 1);
20413:             JS_ASSERT(!pn3);
    1:             break;
    1:         }
    1: 
27012:         if (first &&
    1:             !inLetHead &&
80966:             NewSrcNote2(cx, bce, SRC_DECL,
78294:                         (pn->isOp(JSOP_DEFCONST))
    1:                         ? SRC_DECL_CONST
78294:                         : (pn->isOp(JSOP_DEFVAR))
    1:                         ? SRC_DECL_VAR
80632:                         : SRC_DECL_LET) < 0)
80632:         {
    1:             return JS_FALSE;
    1:         }
    1:         if (op == JSOP_ARGUMENTS) {
80966:             if (Emit1(cx, bce, op) < 0)
    1:                 return JS_FALSE;
47573:         } else if (!pn2->pn_cookie.isFree()) {
    1:             EMIT_UINT16_IMM_OP(op, atomIndex);
    1:         } else {
 3235:             EMIT_INDEX_OP(op, atomIndex);
    1:         }
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:     emit_note_pop:
    1: #endif
80966:         tmp = bce->offset();
    1:         if (noteIndex >= 0) {
80966:             if (!SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 0, tmp-off))
    1:                 return JS_FALSE;
    1:         }
27012:         if (!next)
    1:             break;
    1:         off = tmp;
80966:         noteIndex = NewSrcNote2(cx, bce, SRC_PCDELTA, 0);
80966:         if (noteIndex < 0 || Emit1(cx, bce, JSOP_POP) < 0)
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     /* If this is a let head, emit and return a srcnote on the pop. */
    1:     if (inLetHead) {
80966:         *headNoteIndex = NewSrcNote(cx, bce, SRC_DECL);
    1:         if (*headNoteIndex < 0)
    1:             return JS_FALSE;
27012:         if (!(pn->pn_xflags & PNX_POPVAR))
80966:             return Emit1(cx, bce, JSOP_NOP) >= 0;
80966:     }
80966: 
80966:     return !(pn->pn_xflags & PNX_POPVAR) || Emit1(cx, bce, JSOP_POP) >= 0;
27012: }
27012: 
74052: static bool
80966: EmitAssignment(JSContext *cx, BytecodeEmitter *bce, ParseNode *lhs, JSOp op, ParseNode *rhs)
80966: {
80966:     ptrdiff_t top = bce->offset();
74052: 
74052:     /*
74052:      * Check left operand type and generate specialized code for it.
74052:      * Specialize to avoid ECMA "reference type" values on the operand
74052:      * stack, which impose pervasive runtime "GetValue" costs.
74052:      */
74052:     jsatomid atomIndex = (jsatomid) -1;              /* quell GCC overwarning */
74052:     jsbytecode offset = 1;
74052: 
78294:     switch (lhs->getKind()) {
82024:       case PNK_NAME:
80966:         if (!BindNameToSlot(cx, bce, lhs))
74052:             return false;
74052:         if (!lhs->pn_cookie.isFree()) {
74052:             atomIndex = lhs->pn_cookie.asInteger();
74052:         } else {
80966:             if (!bce->makeAtomIndex(lhs->pn_atom, &atomIndex))
74052:                 return false;
74052:             if (!lhs->isConst()) {
78294:                 JSOp op = lhs->isOp(JSOP_SETGNAME) ? JSOP_BINDGNAME : JSOP_BINDNAME;
74052:                 EMIT_INDEX_OP(op, atomIndex);
74052:                 offset++;
74052:             }
74052:         }
74052:         break;
82024:       case PNK_DOT:
80966:         if (!EmitTree(cx, bce, lhs->expr()))
74052:             return false;
74052:         offset++;
80966:         if (!bce->makeAtomIndex(lhs->pn_atom, &atomIndex))
74052:             return false;
74052:         break;
82024:       case PNK_LB:
78294:         JS_ASSERT(lhs->isArity(PN_BINARY));
80966:         if (!EmitTree(cx, bce, lhs->pn_left))
80966:             return false;
80966:         if (!EmitTree(cx, bce, lhs->pn_right))
74052:             return false;
74052:         offset += 2;
74052:         break;
74052: #if JS_HAS_DESTRUCTURING
82024:       case PNK_RB:
82024:       case PNK_RC:
74052:         break;
74052: #endif
82024:       case PNK_LP:
80966:         if (!EmitTree(cx, bce, lhs))
74052:             return false;
77824:         offset++;
74052:         break;
74052: #if JS_HAS_XML_SUPPORT
82114:       case PNK_XMLUNARY:
80966:         JS_ASSERT(!bce->inStrictMode());
78294:         JS_ASSERT(lhs->isOp(JSOP_SETXMLNAME));
80966:         if (!EmitTree(cx, bce, lhs->pn_kid))
80966:             return false;
80966:         if (Emit1(cx, bce, JSOP_BINDXMLNAME) < 0)
74052:             return false;
74052:         offset++;
74052:         break;
74052: #endif
74052:       default:
74052:         JS_ASSERT(0);
74052:     }
74052: 
74052:     if (op != JSOP_NOP) {
74052:         JS_ASSERT(rhs);
78294:         switch (lhs->getKind()) {
82024:           case PNK_NAME:
74052:             if (lhs->isConst()) {
78294:                 if (lhs->isOp(JSOP_CALLEE)) {
80966:                     if (Emit1(cx, bce, JSOP_CALLEE) < 0)
74052:                         return false;
74052:                 } else {
78294:                     EMIT_INDEX_OP(lhs->getOp(), atomIndex);
78294:                 }
78294:             } else if (lhs->isOp(JSOP_SETNAME)) {
80966:                 if (Emit1(cx, bce, JSOP_DUP) < 0)
74052:                     return false;
74052:                 EMIT_INDEX_OP(JSOP_GETXPROP, atomIndex);
78294:             } else if (lhs->isOp(JSOP_SETGNAME)) {
80966:                 if (!BindGlobal(cx, bce, lhs, lhs->pn_atom))
80966:                     return false;
80966:                 EmitAtomOp(cx, lhs, JSOP_GETGNAME, bce);
74052:             } else {
78294:                 EMIT_UINT16_IMM_OP(lhs->isOp(JSOP_SETARG) ? JSOP_GETARG : JSOP_GETLOCAL, atomIndex);
74052:             }
74052:             break;
82024:           case PNK_DOT:
80966:             if (Emit1(cx, bce, JSOP_DUP) < 0)
74052:                 return false;
77379:             if (lhs->pn_atom == cx->runtime->atomState.protoAtom) {
80966:                 if (!EmitIndexOp(cx, JSOP_QNAMEPART, atomIndex, bce))
80966:                     return false;
80966:                 if (!EmitElemOpBase(cx, bce, JSOP_GETELEM))
74052:                     return false;
74052:             } else {
77379:                 bool isLength = (lhs->pn_atom == cx->runtime->atomState.lengthAtom);
77379:                 EMIT_INDEX_OP(isLength ? JSOP_LENGTH : JSOP_GETPROP, atomIndex);
74052:             }
74052:             break;
82024:           case PNK_LB:
82024:           case PNK_LP:
74052: #if JS_HAS_XML_SUPPORT
82114:           case PNK_XMLUNARY:
74052: #endif
80966:             if (Emit1(cx, bce, JSOP_DUP2) < 0)
80966:                 return false;
80966:             if (!EmitElemOpBase(cx, bce, JSOP_GETELEM))
74052:                 return false;
74052:             break;
74052:           default:;
74052:         }
74052:     }
74052: 
74052:     /* Now emit the right operand (it may affect the namespace). */
74052:     if (rhs) {
80966:         if (!EmitTree(cx, bce, rhs))
74052:             return false;
74052:     } else {
77824:         /* The value to assign is the next enumeration value in a for-in loop. */
80966:         if (Emit2(cx, bce, JSOP_ITERNEXT, offset) < 0)
74052:             return false;
74052:     }
74052: 
74052:     /* If += etc., emit the binary operator with a decompiler note. */
74052:     if (op != JSOP_NOP) {
74052:         /*
74052:          * Take care to avoid SRC_ASSIGNOP if the left-hand side is a const
74052:          * declared in the current compilation unit, as in this case (just
74052:          * a bit further below) we will avoid emitting the assignment op.
74052:          */
82024:         if (!lhs->isKind(PNK_NAME) || !lhs->isConst()) {
80966:             if (NewSrcNote(cx, bce, SRC_ASSIGNOP) < 0)
80966:                 return false;
80966:         }
80966:         if (Emit1(cx, bce, op) < 0)
74052:             return false;
74052:     }
74052: 
74052:     /* Left parts such as a.b.c and a[b].c need a decompiler note. */
82024:     if (!lhs->isKind(PNK_NAME) &&
74052: #if JS_HAS_DESTRUCTURING
82024:         !lhs->isKind(PNK_RB) &&
82024:         !lhs->isKind(PNK_RC) &&
74052: #endif
80966:         NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - top) < 0)
80632:     {
74052:         return false;
74052:     }
74052: 
74052:     /* Finally, emit the specialized assignment bytecode. */
78294:     switch (lhs->getKind()) {
82024:       case PNK_NAME:
74052:         if (lhs->isConst()) {
74052:             if (!rhs) {
80966:                 ReportCompileErrorNumber(cx, bce->tokenStream(), lhs, JSREPORT_ERROR,
74052:                                          JSMSG_BAD_FOR_LEFTSIDE);
74052:                 return false;
74052:             }
74052:             break;
74052:         }
74052:         /* FALL THROUGH */
82024:       case PNK_DOT:
78294:         EMIT_INDEX_OP(lhs->getOp(), atomIndex);
74052:         break;
82024:       case PNK_LB:
82024:       case PNK_LP:
80966:         if (Emit1(cx, bce, JSOP_SETELEM) < 0)
74052:             return false;
74052:         break;
74052: #if JS_HAS_DESTRUCTURING
82024:       case PNK_RB:
82024:       case PNK_RC:
80966:         if (!EmitDestructuringOps(cx, bce, JSOP_SETNAME, lhs))
74052:             return false;
74052:         break;
74052: #endif
74052: #if JS_HAS_XML_SUPPORT
82114:       case PNK_XMLUNARY:
80966:         JS_ASSERT(!bce->inStrictMode());
80966:         if (Emit1(cx, bce, JSOP_SETXMLNAME) < 0)
74052:             return false;
74052:         break;
74052: #endif
74052:       default:
74052:         JS_ASSERT(0);
74052:     }
74052:     return true;
74052: }
74052: 
27012: #if defined DEBUG_brendan || defined DEBUG_mrbkap
    1: static JSBool
80966: GettableNoteForNextOp(BytecodeEmitter *bce)
    1: {
    1:     ptrdiff_t offset, target;
    1:     jssrcnote *sn, *end;
    1: 
    1:     offset = 0;
80966:     target = bce->offset();
80966:     for (sn = bce->notes(), end = sn + bce->noteCount(); sn < end;
    1:          sn = SN_NEXT(sn)) {
    1:         if (offset == target && SN_IS_GETTABLE(sn))
    1:             return JS_TRUE;
    1:         offset += SN_DELTA(sn);
    1:     }
    1:     return JS_FALSE;
    1: }
    1: #endif
    1: 
10466: /* Top-level named functions need a nop for decompilation. */
10466: static JSBool
80966: EmitFunctionDefNop(JSContext *cx, BytecodeEmitter *bce, uintN index)
80966: {
80966:     return NewSrcNote2(cx, bce, SRC_FUNCDEF, (ptrdiff_t)index) >= 0 &&
80966:            Emit1(cx, bce, JSOP_NOP) >= 0;
10466: }
10466: 
32729: static bool
80966: EmitNewInit(JSContext *cx, BytecodeEmitter *bce, JSProtoKey key, ParseNode *pn, int sharpnum)
80966: {
80966:     if (Emit3(cx, bce, JSOP_NEWINIT, (jsbytecode) key, 0) < 0)
58056:         return false;
32729: #if JS_HAS_SHARP_VARS
80966:     if (bce->hasSharps()) {
32729:         if (pn->pn_count != 0)
80966:             EMIT_UINT16_IMM_OP(JSOP_SHARPINIT, bce->sharpSlotBase);
32729:         if (sharpnum >= 0)
80966:             EMIT_UINT16PAIR_IMM_OP(JSOP_DEFSHARP, bce->sharpSlotBase, sharpnum);
32729:     } else {
32729:         JS_ASSERT(sharpnum < 0);
32729:     }
32729: #endif
32729:     return true;
32729: }
32729: 
32729: static bool
80966: EmitEndInit(JSContext *cx, BytecodeEmitter *bce, uint32 count)
32729: {
32729: #if JS_HAS_SHARP_VARS
32729:     /* Emit an op for sharp array cleanup and decompilation. */
80966:     if (bce->hasSharps() && count != 0)
80966:         EMIT_UINT16_IMM_OP(JSOP_SHARPINIT, bce->sharpSlotBase);
32729: #endif
80966:     return Emit1(cx, bce, JSOP_ENDINIT) >= 0;
80632: }
80632: 
59962: bool
80631: ParseNode::getConstantValue(JSContext *cx, bool strictChecks, Value *vp)
59962: {
78294:     switch (getKind()) {
82024:       case PNK_NUMBER:
59962:         vp->setNumber(pn_dval);
59962:         return true;
82024:       case PNK_STRING:
64345:         vp->setString(pn_atom);
59962:         return true;
82024:       case PNK_TRUE:
82022:         vp->setBoolean(true);
82022:         return true;
82024:       case PNK_FALSE:
82022:         vp->setBoolean(false);
82022:         return true;
82024:       case PNK_NULL:
59962:         vp->setNull();
59962:         return true;
82024:       case PNK_RB: {
78294:         JS_ASSERT(isOp(JSOP_NEWINIT) && !(pn_xflags & PNX_NONCONST));
59962: 
59962:         JSObject *obj = NewDenseAllocatedArray(cx, pn_count);
77343:         if (!obj)
59962:             return false;
59962: 
59962:         unsigned idx = 0;
80631:         for (ParseNode *pn = pn_head; pn; idx++, pn = pn->pn_next) {
59962:             Value value;
59962:             if (!pn->getConstantValue(cx, strictChecks, &value))
59962:                 return false;
80624:             if (!obj->defineGeneric(cx, INT_TO_JSID(idx), value, NULL, NULL, JSPROP_ENUMERATE))
77343:                 return false;
59962:         }
59962:         JS_ASSERT(idx == pn_count);
59962: 
77343:         types::FixArrayType(cx, obj);
59962:         vp->setObject(*obj);
59962:         return true;
59962:       }
82024:       case PNK_RC: {
78294:         JS_ASSERT(isOp(JSOP_NEWINIT) && !(pn_xflags & PNX_NONCONST));
59962: 
77775:         gc::AllocKind kind = GuessObjectGCKind(pn_count, false);
77817:         JSObject *obj = NewBuiltinClassInstance(cx, &ObjectClass, kind);
59962:         if (!obj)
59962:             return false;
59962: 
80631:         for (ParseNode *pn = pn_head; pn; pn = pn->pn_next) {
59962:             Value value;
59962:             if (!pn->pn_right->getConstantValue(cx, strictChecks, &value))
59962:                 return false;
59962: 
80631:             ParseNode *pnid = pn->pn_left;
82024:             if (pnid->isKind(PNK_NUMBER)) {
59962:                 Value idvalue = NumberValue(pnid->pn_dval);
59962:                 jsid id;
59962:                 if (idvalue.isInt32() && INT_FITS_IN_JSID(idvalue.toInt32()))
59962:                     id = INT_TO_JSID(idvalue.toInt32());
59962:                 else if (!js_InternNonIntElementId(cx, obj, idvalue, &id))
59962:                     return false;
80624:                 if (!obj->defineGeneric(cx, id, value, NULL, NULL, JSPROP_ENUMERATE))
59962:                     return false;
59962:             } else {
82024:                 JS_ASSERT(pnid->isKind(PNK_NAME) || pnid->isKind(PNK_STRING));
77448:                 JS_ASSERT(pnid->pn_atom != cx->runtime->atomState.protoAtom);
59962:                 jsid id = ATOM_TO_JSID(pnid->pn_atom);
77448:                 if (!DefineNativeProperty(cx, obj, id, value, NULL, NULL,
69855:                                           JSPROP_ENUMERATE, 0, 0)) {
59962:                     return false;
59962:                 }
59962:             }
59962:         }
59962: 
77343:         types::FixObjectType(cx, obj);
59962:         vp->setObject(*obj);
59962:         return true;
59962:       }
59962:       default:
59962:         JS_NOT_REACHED("Unexpected node");
59962:     }
59962:     return false;
59962: }
59962: 
59962: static bool
80966: EmitSingletonInitialiser(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
59962: {
59962:     Value value;
80966:     if (!pn->getConstantValue(cx, bce->needStrictChecks(), &value))
59962:         return false;
59962: 
59962:     JS_ASSERT(value.isObject());
80966:     ObjectBox *objbox = bce->parser->newObjectBox(&value.toObject());
59962:     if (!objbox)
59962:         return false;
59962: 
80966:     return EmitObjectOp(cx, objbox, JSOP_OBJECT, bce);
59962: }
59962: 
21520: /* See the SRC_FOR source note offsetBias comments later in this file. */
21520: JS_STATIC_ASSERT(JSOP_NOP_LENGTH == 1);
21520: JS_STATIC_ASSERT(JSOP_POP_LENGTH == 1);
21520: 
55512: class EmitLevelManager
55512: {
80966:     BytecodeEmitter *bce;
55512:   public:
80966:     EmitLevelManager(BytecodeEmitter *bce) : bce(bce) { bce->emitLevel++; }
80966:     ~EmitLevelManager() { bce->emitLevel--; }
55512: };
55512: 
79378: static bool
80966: EmitCatch(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
79378: {
79378:     ptrdiff_t catchStart, guardJump;
79378: 
79378:     /*
79378:      * Morph STMT_BLOCK to STMT_CATCH, note the block entry code offset,
79378:      * and save the block object atom.
79378:      */
80966:     StmtInfo *stmt = bce->topStmt;
79378:     JS_ASSERT(stmt->type == STMT_BLOCK && (stmt->flags & SIF_SCOPE));
79378:     stmt->type = STMT_CATCH;
79378:     catchStart = stmt->update;
79378: 
79378:     /* Go up one statement info record to the TRY or FINALLY record. */
79378:     stmt = stmt->down;
79378:     JS_ASSERT(stmt->type == STMT_TRY || stmt->type == STMT_FINALLY);
79378: 
79378:     /* Pick up the pending exception and bind it to the catch variable. */
80966:     if (Emit1(cx, bce, JSOP_EXCEPTION) < 0)
79378:         return false;
79378: 
79378:     /*
79378:      * Dup the exception object if there is a guard for rethrowing to use
79378:      * it later when rethrowing or in other catches.
79378:      */
80966:     if (pn->pn_kid2 && Emit1(cx, bce, JSOP_DUP) < 0)
79378:         return false;
79378: 
80631:     ParseNode *pn2 = pn->pn_kid1;
79378:     switch (pn2->getKind()) {
79378: #if JS_HAS_DESTRUCTURING
82024:       case PNK_RB:
82024:       case PNK_RC:
80966:         if (!EmitDestructuringOps(cx, bce, JSOP_NOP, pn2))
80966:             return false;
80966:         if (Emit1(cx, bce, JSOP_POP) < 0)
79378:             return false;
79378:         break;
26959: #endif
11139: 
82024:       case PNK_NAME:
79378:         /* Inline and specialize BindNameToSlot for pn2. */
79378:         JS_ASSERT(!pn2->pn_cookie.isFree());
79378:         EMIT_UINT16_IMM_OP(JSOP_SETLOCALPOP, pn2->pn_cookie.asInteger());
79378:         break;
79378: 
79378:       default:
79378:         JS_ASSERT(0);
79378:     }
79378: 
79378:     /* Emit the guard expression, if there is one. */
79378:     if (pn->pn_kid2) {
80966:         if (!EmitTree(cx, bce, pn->pn_kid2))
80966:             return false;
80966:         if (!SetSrcNoteOffset(cx, bce, CATCHNOTE(*stmt), 0, bce->offset() - catchStart))
80632:             return false;
79378:         /* ifeq <next block> */
80966:         guardJump = EmitJump(cx, bce, JSOP_IFEQ, 0);
79378:         if (guardJump < 0)
79378:             return false;
79378:         GUARDJUMP(*stmt) = guardJump;
79378: 
79378:         /* Pop duplicated exception object as we no longer need it. */
80966:         if (Emit1(cx, bce, JSOP_POP) < 0)
74052:             return false;
79378:     }
79378: 
79378:     /* Emit the catch body. */
80966:     if (!EmitTree(cx, bce, pn->pn_kid3))
79378:         return false;
79378: 
79378:     /*
79378:      * Annotate the JSOP_LEAVEBLOCK that will be emitted as we unwind via
82024:      * our PNK_LEXICALSCOPE parent, so the decompiler knows to pop.
79378:      */
80966:     ptrdiff_t off = bce->stackDepth;
80966:     if (NewSrcNote2(cx, bce, SRC_CATCH, off) < 0)
79378:         return false;
79378:     return true;
79378: }
79378: 
79378: static bool
80966: EmitTry(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
80631: {
80631:     StmtInfo stmtInfo;
79378:     ptrdiff_t catchJump = -1;
    1: 
    1:     /*
    1:      * Push stmtInfo to track jumps-over-catches and gosubs-to-finally
    1:      * for later fixup.
    1:      *
27012:      * When a finally block is active (STMT_FINALLY in our tree context),
    1:      * non-local jumps (including jumps-over-catches) result in a GOSUB
    1:      * being written into the bytecode stream and fixed-up later (c.f.
    1:      * EmitBackPatchOp and BackPatch).
    1:      */
80966:     PushStatement(bce, &stmtInfo, pn->pn_kid3 ? STMT_FINALLY : STMT_TRY, bce->offset());
    1: 
    1:     /*
 1825:      * Since an exception can be thrown at any place inside the try block,
 1825:      * we need to restore the stack and the scope chain before we transfer
 1825:      * the control to the exception handler.
    1:      *
 1825:      * For that we store in a try note associated with the catch or
 1825:      * finally block the stack depth upon the try entry. The interpreter
 1825:      * uses this depth to properly unwind the stack and the scope chain.
    1:      */
80966:     intN depth = bce->stackDepth;
    1: 
    1:     /* Mark try location for decompilation, then emit try block. */
80966:     if (Emit1(cx, bce, JSOP_TRY) < 0)
80966:         return false;
80966:     ptrdiff_t tryStart = bce->offset();
80966:     if (!EmitTree(cx, bce, pn->pn_kid1))
80966:         return false;
80966:     JS_ASSERT(depth == bce->stackDepth);
    1: 
    1:     /* GOSUB to finally, if present. */
    1:     if (pn->pn_kid3) {
80966:         if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
80966:             return false;
80966:         if (EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, &GOSUBS(stmtInfo)) < 0)
79378:             return false;
    1:     }
    1: 
    1:     /* Emit (hidden) jump over catch and/or finally. */
80966:     if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
80966:         return false;
80966:     if (EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, &catchJump) < 0)
80966:         return false;
80966: 
80966:     ptrdiff_t tryEnd = bce->offset();
    1: 
80631:     ObjectBox *prevBox = NULL;
    1:     /* If this try has a catch block, emit it. */
80631:     ParseNode *lastCatch = NULL;
80631:     if (ParseNode *pn2 = pn->pn_kid2) {
54855:         uintN count = 0;    /* previous catch block's population */
    1: 
    1:         /*
    1:          * The emitted code for a catch block looks like:
    1:          *
55526:          * blockchain
    1:          * [throwing]                          only if 2nd+ catch block
    1:          * [leaveblock]                        only if 2nd+ catch block
    1:          * enterblock                          with SRC_CATCH
    1:          * exception
    1:          * [dup]                               only if catchguard
    1:          * setlocalpop <slot>                  or destructuring code
    1:          * [< catchguard code >]               if there's a catchguard
    1:          * [ifeq <offset to next catch block>]         " "
    1:          * [pop]                               only if catchguard
    1:          * < catch block contents >
    1:          * leaveblock
    1:          * goto <end of catch blocks>          non-local; finally applies
    1:          *
    1:          * If there's no catch block without a catchguard, the last
    1:          * <offset to next catch block> points to rethrow code.  This
    1:          * code will [gosub] to the finally code if appropriate, and is
    1:          * also used for the catch-all trynote for capturing exceptions
    1:          * thrown from catch{} blocks.
    1:          */
80631:         for (ParseNode *pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
    1:             ptrdiff_t guardJump, catchNote;
    1: 
80966:             JS_ASSERT(bce->stackDepth == depth);
    1:             guardJump = GUARDJUMP(stmtInfo);
 1825:             if (guardJump != -1) {
80966:                 if (EmitKnownBlockChain(cx, bce, prevBox) < 0)
79378:                     return false;
55526:             
    1:                 /* Fix up and clean up previous catch block. */
80966:                 CHECK_AND_SET_JUMP_OFFSET_AT(cx, bce, guardJump);
    1: 
    1:                 /*
18567:                  * Account for JSOP_ENTERBLOCK (whose block object count
18567:                  * is saved below) and pushed exception object that we
18567:                  * still have after the jumping from the previous guard.
18567:                  */
80966:                 bce->stackDepth = depth + count + 1;
    1: 
    1:                 /*
    1:                  * Move exception back to cx->exception to prepare for
  190:                  * the next catch. We hide [throwing] from the decompiler
  190:                  * since it compensates for the hidden JSOP_DUP at the
  190:                  * start of the previous guarded catch.
  190:                  */
80966:                 if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0 ||
80966:                     Emit1(cx, bce, JSOP_THROWING) < 0) {
80966:                     return false;
80966:                 }
80966:                 if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
80966:                     return false;
80966:                 if (!EmitLeaveBlock(cx, bce, JSOP_LEAVEBLOCK, prevBox))
80966:                     return false;
80966:                 JS_ASSERT(bce->stackDepth == depth);
    1:             }
    1: 
    1:             /*
    1:              * Annotate the JSOP_ENTERBLOCK that's about to be generated
80632:              * by the call to EmitTree immediately below.  Save this
82024:              * source note's index in stmtInfo for use by the PNK_CATCH:
    1:              * case, where the length of the catch guard is set as the
    1:              * note's offset.
    1:              */
80966:             catchNote = NewSrcNote2(cx, bce, SRC_CATCH, 0);
    1:             if (catchNote < 0)
79378:                 return false;
    1:             CATCHNOTE(stmtInfo) = catchNote;
    1: 
    1:             /*
    1:              * Emit the lexical scope and catch body.  Save the catch's
    1:              * block object population via count, for use when targeting
    1:              * guardJump at the next catch (the guard mismatch case).
    1:              */
82024:             JS_ASSERT(pn3->isKind(PNK_LEXICALSCOPE));
27012:             count = OBJ_BLOCK_COUNT(cx, pn3->pn_objbox->object);
54855:             prevBox = pn3->pn_objbox;
80966:             if (!EmitTree(cx, bce, pn3))
79378:                 return false;
    1: 
    1:             /* gosub <finally>, if required */
    1:             if (pn->pn_kid3) {
80966:                 if (EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, &GOSUBS(stmtInfo)) < 0)
80966:                     return false;
80966:                 JS_ASSERT(bce->stackDepth == depth);
    1:             }
    1: 
    1:             /*
    1:              * Jump over the remaining catch blocks.  This will get fixed
    1:              * up to jump to after catch/finally.
    1:              */
80966:             if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
80966:                 return false;
80966:             if (EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, &catchJump) < 0)
79378:                 return false;
    1: 
    1:             /*
    1:              * Save a pointer to the last catch node to handle try-finally
    1:              * and try-catch(guard)-finally special cases.
    1:              */
27012:             lastCatch = pn3->expr();
    1:         }
    1:     }
    1: 
    1:     /*
    1:      * Last catch guard jumps to the rethrow code sequence if none of the
    1:      * guards match. Target guardJump at the beginning of the rethrow
    1:      * sequence, just in case a guard expression throws and leaves the
    1:      * stack unbalanced.
    1:      */
    1:     if (lastCatch && lastCatch->pn_kid2) {
80966:         if (EmitKnownBlockChain(cx, bce, prevBox) < 0)
80966:             return false;
80966:         
80966:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, bce, GUARDJUMP(stmtInfo));
    1: 
    1:         /* Sync the stack to take into account pushed exception. */
80966:         JS_ASSERT(bce->stackDepth == depth);
80966:         bce->stackDepth = depth + 1;
    1: 
    1:         /*
    1:          * Rethrow the exception, delegating executing of finally if any
    1:          * to the exception handler.
    1:          */
80966:         if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0 || Emit1(cx, bce, JSOP_THROW) < 0)
80966:             return false;
80966: 
80966:         if (EmitBlockChain(cx, bce) < 0)
80966:             return false;
80966:     }
80966: 
80966:     JS_ASSERT(bce->stackDepth == depth);
    1: 
    1:     /* Emit finally handler if any. */
79378:     ptrdiff_t finallyStart = 0;   /* to quell GCC uninitialized warnings */
    1:     if (pn->pn_kid3) {
    1:         /*
 1825:          * Fix up the gosubs that might have been emitted before non-local
 1825:          * jumps to the finally code.
 1825:          */
80966:         if (!BackPatch(cx, bce, GOSUBS(stmtInfo), bce->next(), JSOP_GOSUB))
80966:             return false;
80966: 
80966:         finallyStart = bce->offset();
 1825: 
18567:         /* Indicate that we're emitting a subroutine body. */
    1:         stmtInfo.type = STMT_SUBROUTINE;
80966:         if (!UpdateLineNumberNotes(cx, bce, pn->pn_kid3->pn_pos.begin.lineno))
80966:             return false;
80966:         if (Emit1(cx, bce, JSOP_FINALLY) < 0 ||
80966:             !EmitTree(cx, bce, pn->pn_kid3) ||
80966:             Emit1(cx, bce, JSOP_RETSUB) < 0)
80966:         {
80966:             return false;
80966:         }
80966:         JS_ASSERT(bce->stackDepth == depth);
80966:     }
80966:     if (!PopStatementBCE(cx, bce))
80966:         return false;
80966: 
80966:     if (NewSrcNote(cx, bce, SRC_ENDBRACE) < 0 || Emit1(cx, bce, JSOP_NOP) < 0)
79378:         return false;
    1: 
    1:     /* Fix up the end-of-try/catch jumps to come here. */
80966:     if (!BackPatch(cx, bce, catchJump, bce->next(), JSOP_GOTO))
79378:         return false;
    1: 
    1:     /*
    1:      * Add the try note last, to let post-order give us the right ordering
    1:      * (first to last for a given nesting level, inner to outer by level).
    1:      */
80966:     if (pn->pn_kid2 && !NewTryNote(cx, bce, JSTRY_CATCH, depth, tryStart, tryEnd))
79378:         return false;
    1: 
    1:     /*
    1:      * If we've got a finally, mark try+catch region with additional
    1:      * trynote to catch exceptions (re)thrown from a catch block or
    1:      * for the try{}finally{} case.
    1:      */
80966:     if (pn->pn_kid3 && !NewTryNote(cx, bce, JSTRY_FINALLY, depth, tryStart, finallyStart))
79378:         return false;
79378: 
79378:     return true;
79378: }
79378: 
79378: static bool
80966: EmitIf(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
80631: {
80631:     StmtInfo stmtInfo;
79378: 
79378:     /* Initialize so we can detect else-if chains and avoid recursion. */
79378:     stmtInfo.type = STMT_IF;
79378:     ptrdiff_t beq = -1;
79378:     ptrdiff_t jmp = -1;
79378:     ptrdiff_t noteIndex = -1;
79378: 
79378:   if_again:
79378:     /* Emit code for the condition before pushing stmtInfo. */
80966:     if (!EmitTree(cx, bce, pn->pn_kid1))
80966:         return JS_FALSE;
80966:     ptrdiff_t top = bce->offset();
79378:     if (stmtInfo.type == STMT_IF) {
80966:         PushStatement(bce, &stmtInfo, STMT_IF, top);
79378:     } else {
79378:         /*
79378:          * We came here from the goto further below that detects else-if
79378:          * chains, so we must mutate stmtInfo back into a STMT_IF record.
79378:          * Also (see below for why) we need a note offset for SRC_IF_ELSE
79378:          * to help the decompiler.  Actually, we need two offsets, one for
79378:          * decompiling any else clause and the second for decompiling an
79378:          * else-if chain without bracing, overindenting, or incorrectly
79378:          * scoping let declarations.
79378:          */
79378:         JS_ASSERT(stmtInfo.type == STMT_ELSE);
79378:         stmtInfo.type = STMT_IF;
79378:         stmtInfo.update = top;
80966:         if (!SetSrcNoteOffset(cx, bce, noteIndex, 0, jmp - beq))
80966:             return JS_FALSE;
80966:         if (!SetSrcNoteOffset(cx, bce, noteIndex, 1, top - beq))
79378:             return JS_FALSE;
79378:     }
79378: 
79378:     /* Emit an annotated branch-if-false around the then part. */
80631:     ParseNode *pn3 = pn->pn_kid3;
80966:     noteIndex = NewSrcNote(cx, bce, pn3 ? SRC_IF_ELSE : SRC_IF);
79378:     if (noteIndex < 0)
79378:         return JS_FALSE;
80966:     beq = EmitJump(cx, bce, JSOP_IFEQ, 0);
79378:     if (beq < 0)
79378:         return JS_FALSE;
79378: 
79378:     /* Emit code for the then and optional else parts. */
80966:     if (!EmitTree(cx, bce, pn->pn_kid2))
79378:         return JS_FALSE;
79378:     if (pn3) {
79378:         /* Modify stmtInfo so we know we're in the else part. */
79378:         stmtInfo.type = STMT_ELSE;
79378: 
79378:         /*
79378:          * Emit a JSOP_BACKPATCH op to jump from the end of our then part
80966:          * around the else part.  The PopStatementBCE call at the bottom of
80966:          * this function will fix up the backpatch chain linked from
79378:          * stmtInfo.breaks.
79378:          */
80966:         jmp = EmitGoto(cx, bce, &stmtInfo, &stmtInfo.breaks);
79378:         if (jmp < 0)
79378:             return JS_FALSE;
79378: 
79378:         /* Ensure the branch-if-false comes here, then emit the else. */
80966:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, bce, beq);
82024:         if (pn3->isKind(PNK_IF)) {
79378:             pn = pn3;
79378:             goto if_again;
79378:         }
79378: 
80966:         if (!EmitTree(cx, bce, pn3))
79378:             return JS_FALSE;
79378: 
79378:         /*
79378:          * Annotate SRC_IF_ELSE with the offset from branch to jump, for
79378:          * the decompiler's benefit.  We can't just "back up" from the pc
79378:          * of the else clause, because we don't know whether an extended
79378:          * jump was required to leap from the end of the then clause over
79378:          * the else clause.
79378:          */
80966:         if (!SetSrcNoteOffset(cx, bce, noteIndex, 0, jmp - beq))
79378:             return JS_FALSE;
79378:     } else {
79378:         /* No else part, fixup the branch-if-false to come here. */
80966:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, bce, beq);
80966:     }
80966:     return PopStatementBCE(cx, bce);
79378: }
79378: 
79378: #if JS_HAS_BLOCK_SCOPE
79378: static bool
81588: EmitLet(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
79378: {
79378:     /*
79378:      * pn represents one of these syntactic constructs:
79378:      *   let-expression:                        (let (x = y) EXPR)
79378:      *   let-statement:                         let (x = y) { ... }
79378:      *   let-declaration in statement context:  let x = y;
79378:      *   let-declaration in for-loop head:      for (let ...) ...
79378:      *
79378:      * Let-expressions and let-statements are represented as binary nodes
79378:      * with their variable declarations on the left and the body on the
79378:      * right.
79378:      */
80631:     ParseNode *pn2;
79378:     if (pn->isArity(PN_BINARY)) {
79378:         pn2 = pn->pn_right;
79378:         pn = pn->pn_left;
79378:     } else {
79378:         pn2 = NULL;
79378:     }
79378: 
79378:     /*
79378:      * Non-null pn2 means that pn is the variable list from a let head.
79378:      *
79378:      * Use TempPopScope to evaluate the expressions in the enclosing scope.
79378:      * This also causes the initializing assignments to be emitted in the
79378:      * enclosing scope, but the assignment opcodes emitted here
79378:      * (essentially just setlocal, though destructuring assignment uses
79378:      * other additional opcodes) do not care about the block chain.
79378:      */
79378:     JS_ASSERT(pn->isArity(PN_LIST));
79378:     TempPopScope tps;
80966:     bool popScope = pn2 || (bce->flags & TCF_IN_FOR_INIT);
80966:     if (popScope && !tps.popBlock(cx, bce))
79378:         return false;
79378:     ptrdiff_t noteIndex;
80966:     if (!EmitVariables(cx, bce, pn, pn2 != NULL, &noteIndex))
80966:         return false;
80966:     ptrdiff_t tmp = bce->offset();
80966:     if (popScope && !tps.repushBlock(cx, bce))
79378:         return false;
79378: 
79378:     /* Thus non-null pn2 is the body of the let block or expression. */
80966:     if (pn2 && !EmitTree(cx, bce, pn2))
80966:         return false;
80966: 
80966:     if (noteIndex >= 0 && !SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 0, bce->offset() - tmp))
79378:         return false;
79378: 
79378:     return true;
79378: }
79378: #endif
79378: 
79378: #if JS_HAS_XML_SUPPORT
79378: static bool
80966: EmitXMLTag(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
80966: {
80966:     JS_ASSERT(!bce->inStrictMode());
80966: 
80966:     if (Emit1(cx, bce, JSOP_STARTXML) < 0)
79378:         return false;
79378: 
79378:     {
79378:         jsatomid index;
82024:         JSAtom *tagAtom = (pn->isKind(PNK_XMLETAGO))
80780:                           ? cx->runtime->atomState.etagoAtom
79378:                           : cx->runtime->atomState.stagoAtom;
80966:         if (!bce->makeAtomIndex(tagAtom, &index))
79378:             return false;
79378:         EMIT_INDEX_OP(JSOP_STRING, index);
79378:     }
79378: 
79378:     JS_ASSERT(pn->pn_count != 0);
80631:     ParseNode *pn2 = pn->pn_head;
82024:     if (pn2->isKind(PNK_LC) && Emit1(cx, bce, JSOP_STARTXMLEXPR) < 0)
80966:         return false;
80966:     if (!EmitTree(cx, bce, pn2))
80966:         return false;
80966:     if (Emit1(cx, bce, JSOP_ADD) < 0)
79378:         return false;
79378: 
79378:     uint32 i;
79378:     for (pn2 = pn2->pn_next, i = 0; pn2; pn2 = pn2->pn_next, i++) {
82024:         if (pn2->isKind(PNK_LC) && Emit1(cx, bce, JSOP_STARTXMLEXPR) < 0)
80966:             return false;
80966:         if (!EmitTree(cx, bce, pn2))
79378:             return false;
82024:         if ((i & 1) && pn2->isKind(PNK_LC)) {
80966:             if (Emit1(cx, bce, JSOP_TOATTRVAL) < 0)
80966:                 return false;
80966:         }
80966:         if (Emit1(cx, bce, (i & 1) ? JSOP_ADDATTRVAL : JSOP_ADDATTRNAME) < 0)
80632:             return false;
79378:     }
79378: 
79378:     {
79378:         jsatomid index;
82024:         JSAtom *tmp = (pn->isKind(PNK_XMLPTAGC)) ? cx->runtime->atomState.ptagcAtom
79378:                                                  : cx->runtime->atomState.tagcAtom;
80966:         if (!bce->makeAtomIndex(tmp, &index))
79378:             return false;
79378:         EMIT_INDEX_OP(JSOP_STRING, index);
79378:     }
80966:     if (Emit1(cx, bce, JSOP_ADD) < 0)
80966:         return false;
80966: 
80966:     if ((pn->pn_xflags & PNX_XMLROOT) && Emit1(cx, bce, pn->getOp()) < 0)
79378:         return false;
79378: 
79378:     return true;
79378: }
79378: 
79378: static bool
80966: EmitXMLProcessingInstruction(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
80966: {
80966:     JS_ASSERT(!bce->inStrictMode());
80780: 
79378:     jsatomid index;
80966:     if (!bce->makeAtomIndex(pn->pn_pidata, &index))
80966:         return false;
80966:     if (!EmitIndexOp(cx, JSOP_QNAMEPART, index, bce))
80966:         return false;
80966:     if (!EmitAtomOp(cx, pn, JSOP_XMLPI, bce))
79378:         return false;
79378:     return true;
79378: }
79378: #endif
79378: 
79378: static bool
81588: EmitLexicalScope(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
80631: {
80631:     StmtInfo stmtInfo;
80631:     StmtInfo *stmt;
80631:     ObjectBox *objbox = pn->pn_objbox;
80966:     PushBlockScope(bce, &stmtInfo, objbox, bce->offset());
79378: 
79378:     /*
79378:      * If this lexical scope is not for a catch block, let block or let
79378:      * expression, or any kind of for loop (where the scope starts in the
79378:      * head after the first part if for (;;), else in the body if for-in);
79378:      * and if our container is top-level but not a function body, or else
79378:      * a block statement; then emit a SRC_BRACE note.  All other container
79378:      * statements get braces by default from the decompiler.
79378:      */
79378:     ptrdiff_t noteIndex = -1;
82024:     ParseNodeKind kind = pn->expr()->getKind();
82024:     if (kind != PNK_CATCH && kind != PNK_LET && kind != PNK_FOR &&
79378:         (!(stmt = stmtInfo.down)
80966:          ? !bce->inFunction()
82024:          : stmt->type == STMT_BLOCK))
82024:     {
79378: #if defined DEBUG_brendan || defined DEBUG_mrbkap
79378:         /* There must be no source note already output for the next op. */
80966:         JS_ASSERT(bce->noteCount() == 0 ||
80966:                   bce->lastNoteOffset() != bce->offset() ||
80966:                   !GettableNoteForNextOp(bce));
79378: #endif
80966:         noteIndex = NewSrcNote2(cx, bce, SRC_BRACE, 0);
79378:         if (noteIndex < 0)
79378:             return false;
79378:     }
79378: 
80966:     ptrdiff_t top = bce->offset();
80966:     if (!EmitEnterBlock(cx, pn, bce))
80966:         return false;
80966: 
80966:     if (!EmitTree(cx, bce, pn->pn_expr))
79378:         return false;
79378: 
79378:     JSOp op = pn->getOp();
79378:     if (op == JSOP_LEAVEBLOCKEXPR) {
80966:         if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - top) < 0)
79378:             return false;
79378:     } else {
80966:         if (noteIndex >= 0 && !SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 0, bce->offset() - top))
80632:             return false;
79378:     }
79378: 
79378:     /* Emit the JSOP_LEAVEBLOCK or JSOP_LEAVEBLOCKEXPR opcode. */
80966:     if (!EmitLeaveBlock(cx, bce, op, objbox))
80966:         return false;
80966: 
81588:     return PopStatementBCE(cx, bce);
79378: }
79378: 
79378: static bool
81588: EmitWith(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
80631: {
80631:     StmtInfo stmtInfo;
80966:     if (!EmitTree(cx, bce, pn->pn_left))
80966:         return false;
80966:     PushStatement(bce, &stmtInfo, STMT_WITH, bce->offset());
80966:     if (Emit1(cx, bce, JSOP_ENTERWITH) < 0)
79378:         return false;
79378: 
79378:     /* Make blockChain determination quicker. */
80966:     if (EmitBlockChain(cx, bce) < 0)
80966:         return false;
80966:     if (!EmitTree(cx, bce, pn->pn_right))
80966:         return false;
80966:     if (Emit1(cx, bce, JSOP_LEAVEWITH) < 0)
80966:         return false;
81588:     return PopStatementBCE(cx, bce);
79378: }
79378: 
80735: static bool
80966: EmitForIn(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, ptrdiff_t top)
80735: {
80735:     StmtInfo stmtInfo;
80966:     PushStatement(bce, &stmtInfo, STMT_FOR_IN_LOOP, top);
80735: 
80735:     ParseNode *forHead = pn->pn_left;
80735:     ParseNode *forBody = pn->pn_right;
80735: 
80735:     /*
80735:      * If the left part is 'var x', emit code to define x if necessary
80735:      * using a prolog opcode, but do not emit a pop. If the left part
80735:      * was originally 'var x = i', the parser will have rewritten it;
80735:      * see Parser::forStatement. 'for (let x = i in o)' is mercifully
80735:      * banned.
80735:      */
80735:     bool forLet = false;
80735:     if (ParseNode *decl = forHead->pn_kid1) {
82024:         JS_ASSERT(decl->isKind(PNK_VAR) || decl->isKind(PNK_LET));
82024:         forLet = decl->isKind(PNK_LET);
80966:         bce->flags |= TCF_IN_FOR_INIT;
80966:         if (!EmitTree(cx, bce, decl))
80966:             return false;
80966:         bce->flags &= ~TCF_IN_FOR_INIT;
80735:     }
80735: 
80735:     /* Compile the object expression to the right of 'in'. */
80735:     {
80735:         TempPopScope tps;
80966:         if (forLet && !tps.popBlock(cx, bce))
80966:             return false;
80966:         if (!EmitTree(cx, bce, forHead->pn_kid3))
80966:             return false;
80966:         if (forLet && !tps.repushBlock(cx, bce))
80735:             return false;
80735:     }
80735: 
80735:     /*
80735:      * Emit a bytecode to convert top of stack value to the iterator
80735:      * object depending on the loop variant (for-in, for-each-in, or
80735:      * destructuring for-in).
80735:      */
80735:     JS_ASSERT(pn->isOp(JSOP_ITER));
80966:     if (Emit2(cx, bce, JSOP_ITER, (uint8) pn->pn_iflags) < 0)
80735:         return false;
80735: 
80735:     /* Annotate so the decompiler can find the loop-closing jump. */
80966:     intN noteIndex = NewSrcNote(cx, bce, SRC_FOR_IN);
80735:     if (noteIndex < 0)
80735:         return false;
80735: 
80735:     /*
80735:      * Jump down to the loop condition to minimize overhead assuming at
80735:      * least one iteration, as the other loop forms do.
80735:      */
80966:     ptrdiff_t jmp = EmitJump(cx, bce, JSOP_GOTO, 0);
80735:     if (jmp < 0)
80735:         return false;
80735: 
80966:     intN noteIndex2 = NewSrcNote(cx, bce, SRC_TRACE);
80735:     if (noteIndex2 < 0)
80735:         return false;
80735: 
80966:     top = bce->offset();
80735:     SET_STATEMENT_TOP(&stmtInfo, top);
80966:     if (EmitTraceOp(cx, bce, NULL) < 0)
80735:         return false;
80735: 
80735: #ifdef DEBUG
80966:     intN loopDepth = bce->stackDepth;
80735: #endif
80735: 
80735:     /*
80735:      * Emit code to get the next enumeration value and assign it to the
80735:      * left hand side. The JSOP_POP after this assignment is annotated
80735:      * so that the decompiler can distinguish 'for (x in y)' from
80735:      * 'for (var x in y)'.
80735:      */
80966:     if (!EmitAssignment(cx, bce, forHead->pn_kid2, JSOP_NOP, NULL))
80966:         return false;
80966:     ptrdiff_t tmp2 = bce->offset();
80966:     if (forHead->pn_kid1 && NewSrcNote2(cx, bce, SRC_DECL,
80735:                                         (forHead->pn_kid1->isOp(JSOP_DEFVAR))
80735:                                         ? SRC_DECL_VAR
80735:                                         : SRC_DECL_LET) < 0) {
80735:         return false;
80735:     }
80966:     if (Emit1(cx, bce, JSOP_POP) < 0)
80735:         return false;
80735: 
80735:     /* The stack should be balanced around the assignment opcode sequence. */
80966:     JS_ASSERT(bce->stackDepth == loopDepth);
80735: 
80735:     /* Emit code for the loop body. */
80966:     if (!EmitTree(cx, bce, forBody))
80735:         return false;
80735: 
80735:     /* Set loop and enclosing "update" offsets, for continue. */
80735:     StmtInfo *stmt = &stmtInfo;
80735:     do {
80966:         stmt->update = bce->offset();
80735:     } while ((stmt = stmt->down) != NULL && stmt->type == STMT_LABEL);
80735: 
80735:     /*
80735:      * Fixup the goto that starts the loop to jump down to JSOP_MOREITER.
80735:      */
80966:     CHECK_AND_SET_JUMP_OFFSET_AT(cx, bce, jmp);
80966:     if (Emit1(cx, bce, JSOP_MOREITER) < 0)
80966:         return false;
80966:     ptrdiff_t beq = EmitJump(cx, bce, JSOP_IFNE, top - bce->offset());
80735:     if (beq < 0)
80735:         return false;
80735: 
80735:     /*
80735:      * Be careful: We must set noteIndex2 before noteIndex in case the noteIndex
80735:      * note gets bigger.
80735:      */
80966:     if (!SetSrcNoteOffset(cx, bce, (uintN)noteIndex2, 0, beq - top))
80735:         return false;
80735:     /* Set the first srcnote offset so we can find the start of the loop body. */
80966:     if (!SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 0, tmp2 - jmp))
80735:         return false;
80735:     /* Set the second srcnote offset so we can find the closing jump. */
80966:     if (!SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 1, beq - jmp))
80735:         return false;
80735: 
80735:     /* Now fixup all breaks and continues (before the JSOP_ENDITER). */
80966:     if (!PopStatementBCE(cx, bce))
80966:         return false;
80966: 
80966:     if (!NewTryNote(cx, bce, JSTRY_ITER, bce->stackDepth, top, bce->offset()))
80966:         return false;
80966: 
80966:     return Emit1(cx, bce, JSOP_ENDITER) >= 0;
80735: }
80735: 
80735: static bool
80966: EmitNormalFor(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, ptrdiff_t top)
80735: {
80735:     StmtInfo stmtInfo;
80966:     PushStatement(bce, &stmtInfo, STMT_FOR_LOOP, top);
80735: 
80735:     ParseNode *forHead = pn->pn_left;
80735:     ParseNode *forBody = pn->pn_right;
80735: 
80735:     /* C-style for (init; cond; update) ... loop. */
80735:     JSOp op = JSOP_POP;
80735:     ParseNode *pn3 = forHead->pn_kid1;
80735:     if (!pn3) {
80735:         /* No initializer: emit an annotated nop for the decompiler. */
80735:         op = JSOP_NOP;
80735:     } else {
80966:         bce->flags |= TCF_IN_FOR_INIT;
80735: #if JS_HAS_DESTRUCTURING
82024:         if (pn3->isKind(PNK_ASSIGN)) {
82023:             JS_ASSERT(pn3->isOp(JSOP_NOP));
82023:             if (!MaybeEmitGroupAssignment(cx, bce, op, pn3, &op))
80735:                 return false;
80735:         }
80735: #endif
80735:         if (op == JSOP_POP) {
80966:             if (!EmitTree(cx, bce, pn3))
80735:                 return false;
82024:             if (pn3->isKind(PNK_VAR) || pn3->isKind(PNK_LET)) {
80735:                 /*
80735:                  * Check whether a destructuring-initialized var decl
80735:                  * was optimized to a group assignment.  If so, we do
80735:                  * not need to emit a pop below, so switch to a nop,
80735:                  * just for the decompiler.
80735:                  */
80735:                 JS_ASSERT(pn3->isArity(PN_LIST));
80735:                 if (pn3->pn_xflags & PNX_GROUPINIT)
80735:                     op = JSOP_NOP;
80735:             }
80735:         }
80966:         bce->flags &= ~TCF_IN_FOR_INIT;
80735:     }
80735: 
80735:     /*
80735:      * NB: the SRC_FOR note has offsetBias 1 (JSOP_{NOP,POP}_LENGTH).
80735:      * Use tmp to hold the biased srcnote "top" offset, which differs
80735:      * from the top local variable by the length of the JSOP_GOTO{,X}
80735:      * emitted in between tmp and top if this loop has a condition.
80735:      */
80966:     intN noteIndex = NewSrcNote(cx, bce, SRC_FOR);
80966:     if (noteIndex < 0 || Emit1(cx, bce, op) < 0)
80966:         return false;
80966:     ptrdiff_t tmp = bce->offset();
80735: 
80735:     ptrdiff_t jmp = -1;
80735:     if (forHead->pn_kid2) {
80735:         /* Goto the loop condition, which branches back to iterate. */
80966:         jmp = EmitJump(cx, bce, JSOP_GOTO, 0);
80735:         if (jmp < 0)
80735:             return false;
80735:     }
80735: 
80966:     top = bce->offset();
80735:     SET_STATEMENT_TOP(&stmtInfo, top);
80735: 
80966:     intN noteIndex2 = NewSrcNote(cx, bce, SRC_TRACE);
80735:     if (noteIndex2 < 0)
80735:         return false;
80735: 
80735:     /* Emit code for the loop body. */
80966:     if (EmitTraceOp(cx, bce, forBody) < 0)
80966:         return false;
80966:     if (!EmitTree(cx, bce, forBody))
80735:         return false;
80735: 
80735:     /* Set the second note offset so we can find the update part. */
80735:     JS_ASSERT(noteIndex != -1);
80966:     ptrdiff_t tmp2 = bce->offset();
80735: 
80735:     /* Set loop and enclosing "update" offsets, for continue. */
80735:     StmtInfo *stmt = &stmtInfo;
80735:     do {
80966:         stmt->update = bce->offset();
80735:     } while ((stmt = stmt->down) != NULL && stmt->type == STMT_LABEL);
80735: 
80735:     /* Check for update code to do before the condition (if any). */
80735:     pn3 = forHead->pn_kid3;
80735:     if (pn3) {
80735:         op = JSOP_POP;
80735: #if JS_HAS_DESTRUCTURING
82024:         if (pn3->isKind(PNK_ASSIGN)) {
82023:             JS_ASSERT(pn3->isOp(JSOP_NOP));
82023:             if (!MaybeEmitGroupAssignment(cx, bce, op, pn3, &op))
80735:                 return false;
80735:         }
80735: #endif
80966:         if (op == JSOP_POP && !EmitTree(cx, bce, pn3))
80735:             return false;
80735: 
80735:         /* Always emit the POP or NOP, to help the decompiler. */
80966:         if (Emit1(cx, bce, op) < 0)
80735:             return false;
80735: 
80735:         /* Restore the absolute line number for source note readers. */
80735:         ptrdiff_t lineno = pn->pn_pos.end.lineno;
80966:         if (bce->currentLine() != (uintN) lineno) {
80966:             if (NewSrcNote2(cx, bce, SRC_SETLINE, lineno) < 0)
80966:                 return false;
80966:             bce->current->currentLine = (uintN) lineno;
80966:         }
80966:     }
80966: 
80966:     ptrdiff_t tmp3 = bce->offset();
80735: 
80735:     if (forHead->pn_kid2) {
80735:         /* Fix up the goto from top to target the loop condition. */
80735:         JS_ASSERT(jmp >= 0);
80966:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, bce, jmp);
80966: 
80966:         if (!EmitTree(cx, bce, forHead->pn_kid2))
80735:             return false;
80735:     }
80735: 
80735:     /*
80735:      * Be careful: We must set noteIndex2 before noteIndex in case the noteIndex
80735:      * note gets bigger.
80735:      */
80966:     if (!SetSrcNoteOffset(cx, bce, (uintN)noteIndex2, 0, bce->offset() - top))
80735:         return false;
80735:     /* Set the first note offset so we can find the loop condition. */
80966:     if (!SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 0, tmp3 - tmp))
80966:         return false;
80966:     if (!SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 1, tmp2 - tmp))
80735:         return false;
80735:     /* The third note offset helps us find the loop-closing jump. */
80966:     if (!SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 2, bce->offset() - tmp))
80735:         return false;
80735: 
80735:     /* If no loop condition, just emit a loop-closing jump. */
80735:     op = forHead->pn_kid2 ? JSOP_IFNE : JSOP_GOTO;
80966:     if (EmitJump(cx, bce, op, top - bce->offset()) < 0)
80735:         return false;
80735: 
80735:     /* Now fixup all breaks and continues. */
80966:     return PopStatementBCE(cx, bce);
80735: }
80735: 
80735: static inline bool
80966: EmitFor(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, ptrdiff_t top)
80735: {
82024:     return pn->pn_left->isKind(PNK_IN)
80966:            ? EmitForIn(cx, bce, pn, top)
80966:            : EmitNormalFor(cx, bce, pn, top);
80735: }
80735: 
79378: JSBool
80966: frontend::EmitTree(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
79378: {
79378:     JSBool useful, wantval;
80631:     StmtInfo stmtInfo;
80631:     StmtInfo *stmt;
80735:     ptrdiff_t top, off, tmp, beq, jmp;
80631:     ParseNode *pn2, *pn3;
79378:     JSAtom *atom;
79378:     jsatomid atomIndex;
79378:     uintN index;
79378:     ptrdiff_t noteIndex, noteIndex2;
80631:     SrcNoteType noteType;
79378:     jsbytecode *pc;
79378:     JSOp op;
79378:     uint32 argc;
80966:     EmitLevelManager elm(bce);
79378: #if JS_HAS_SHARP_VARS
79378:     jsint sharpnum;
79378: #endif
79378: 
79378:     JS_CHECK_RECURSION(cx, return JS_FALSE);
79378: 
79378:     JSBool ok = true;
80966:     pn->pn_offset = top = bce->offset();
79378: 
79378:     /* Emit notes to tell the current bytecode's source line number. */
80966:     UPDATE_LINE_NUMBER_NOTES(cx, bce, pn->pn_pos.begin.lineno);
79378: 
79378:     switch (pn->getKind()) {
82024:       case PNK_FUNCTION:
79378:       {
79378:         JSFunction *fun;
79378:         uintN slot;
79378: 
79378: #if JS_HAS_XML_SUPPORT
79378:         if (pn->isArity(PN_NULLARY)) {
80966:             if (Emit1(cx, bce, JSOP_GETFUNNS) < 0)
79378:                 return JS_FALSE;
79378:             break;
79378:         }
79378: #endif
79378: 
79378:         fun = pn->pn_funbox->function();
79378:         JS_ASSERT(fun->isInterpreted());
79378:         if (fun->script()) {
79378:             /*
79378:              * This second pass is needed to emit JSOP_NOP with a source note
79378:              * for the already-emitted function definition prolog opcode. See
82024:              * comments in the PNK_LC case.
79378:              */
79378:             JS_ASSERT(pn->isOp(JSOP_NOP));
80966:             JS_ASSERT(bce->inFunction());
80966:             if (!EmitFunctionDefNop(cx, bce, pn->pn_index))
79378:                 return JS_FALSE;
79378:             break;
79378:         }
79378: 
79378:         JS_ASSERT_IF(pn->pn_funbox->tcflags & TCF_FUN_HEAVYWEIGHT,
79378:                      fun->kind() == JSFUN_INTERPRETED);
79378: 
81299:         /*
81299:          * Generate code for the function's body.  bce2 is not allocated on the
81299:          * stack because doing so significantly reduces the maximum depth of
81299:          * nested functions we can handle.  See bug 696284.
81299:          */
80966:         BytecodeEmitter *bce2 = cx->new_<BytecodeEmitter>(bce->parser, pn->pn_pos.begin.lineno);
80966:         if (!bce2) {
79378:             js_ReportOutOfMemory(cx);
79378:             return JS_FALSE;
79378:         }
80966:         if (!bce2->init(cx))
80966:             return JS_FALSE;
80966: 
80966:         bce2->flags = pn->pn_funbox->tcflags | TCF_COMPILING | TCF_IN_FUNCTION |
80966:                      (bce->flags & TCF_FUN_MIGHT_ALIAS_LOCALS);
80966:         bce2->bindings.transfer(cx, &pn->pn_funbox->bindings);
79378: #if JS_HAS_SHARP_VARS
80966:         if (bce2->flags & TCF_HAS_SHARPS) {
80966:             bce2->sharpSlotBase = bce2->bindings.sharpSlotBase(cx);
80966:             if (bce2->sharpSlotBase < 0)
79378:                 return JS_FALSE;
79378:         }
79378: #endif
80966:         bce2->setFunction(fun);
80966:         bce2->funbox = pn->pn_funbox;
80966:         bce2->parent = bce;
80990:         bce2->globalScope = bce->globalScope;
79378: 
79378:         /*
80634:          * js::frontend::SetStaticLevel limited static nesting depth to fit in
80634:          * 16 bits and to reserve the all-ones value, thereby reserving the
80966:          * magic FREE_UPVAR_COOKIE value. Note the bce2->staticLevel assignment
80634:          * below.
79378:          */
80966:         JS_ASSERT(bce->staticLevel < JS_BITMASK(16) - 1);
80966:         bce2->staticLevel = bce->staticLevel + 1;
79378: 
79378:         /* We measured the max scope depth when we parsed the function. */
80966:         if (!EmitFunctionScript(cx, bce2, pn->pn_body))
79378:             pn = NULL;
79378: 
80966:         cx->delete_(bce2);
80966:         bce2 = NULL;
79378:         if (!pn)
79378:             return JS_FALSE;
79378: 
79378:         /* Make the function object a literal in the outer script's pool. */
80966:         index = bce->objectList.index(pn->pn_funbox);
79378: 
79378:         /* Emit a bytecode pointing to the closure object in its immediate. */
79378:         op = pn->getOp();
79378:         if (op != JSOP_NOP) {
79378:             if ((pn->pn_funbox->tcflags & TCF_GENEXP_LAMBDA) &&
80966:                 NewSrcNote(cx, bce, SRC_GENEXP) < 0)
80632:             {
79378:                 return JS_FALSE;
79378:             }
79378:             EMIT_INDEX_OP(op, index);
79378: 
79378:             /* Make blockChain determination quicker. */
80966:             if (EmitBlockChain(cx, bce) < 0)
79378:                 return JS_FALSE;
79378:             break;
79378:         }
79378: 
79378:         /*
79378:          * For a script we emit the code as we parse. Thus the bytecode for
79378:          * top-level functions should go in the prolog to predefine their
79378:          * names in the variable object before the already-generated main code
79378:          * is executed. This extra work for top-level scripts is not necessary
79378:          * when we emit the code for a function. It is fully parsed prior to
80632:          * invocation of the emitter and calls to EmitTree for function
79378:          * definitions can be scheduled before generating the rest of code.
79378:          */
80966:         if (!bce->inFunction()) {
80966:             JS_ASSERT(!bce->topStmt);
80966:             if (!BindGlobal(cx, bce, pn, fun->atom))
79378:                 return false;
79378:             if (pn->pn_cookie.isFree()) {
80966:                 bce->switchToProlog();
79378:                 op = fun->isFlatClosure() ? JSOP_DEFFUN_FC : JSOP_DEFFUN;
79378:                 EMIT_INDEX_OP(op, index);
79378: 
79378:                 /* Make blockChain determination quicker. */
80966:                 if (EmitBlockChain(cx, bce) < 0)
80966:                     return JS_FALSE;
80966:                 bce->switchToMain();
79378:             }
79378: 
79378:             /* Emit NOP for the decompiler. */
80966:             if (!EmitFunctionDefNop(cx, bce, index))
79378:                 return JS_FALSE;
79378:         } else {
80966:             DebugOnly<BindingKind> kind = bce->bindings.lookup(cx, fun->atom, &slot);
79378:             JS_ASSERT(kind == VARIABLE || kind == CONSTANT);
79378:             JS_ASSERT(index < JS_BIT(20));
79378:             pn->pn_index = index;
79378:             op = fun->isFlatClosure() ? JSOP_DEFLOCALFUN_FC : JSOP_DEFLOCALFUN;
79378:             if (pn->isClosed() &&
80966:                 !bce->callsEval() &&
80966:                 !bce->closedVars.append(pn->pn_cookie.slot())) {
80966:                 return JS_FALSE;
80966:             }
80966:             if (!EmitSlotIndexOp(cx, op, slot, index, bce))
79378:                 return JS_FALSE;
79378: 
79378:             /* Make blockChain determination quicker. */
80966:             if (EmitBlockChain(cx, bce) < 0)
79378:                 return JS_FALSE;
79378:         }
79378:         break;
79378:       }
79378: 
82024:       case PNK_ARGSBODY:
79378:       {
80631:         ParseNode *pnlast = pn->last();
80631:         for (ParseNode *pn2 = pn->pn_head; pn2 != pnlast; pn2 = pn2->pn_next) {
79378:             if (!pn2->isDefn())
79378:                 continue;
80966:             if (!BindNameToSlot(cx, bce, pn2))
80966:                 return JS_FALSE;
80966:             if (JOF_OPTYPE(pn2->getOp()) == JOF_QARG && bce->shouldNoteClosedName(pn2)) {
80966:                 if (!bce->closedArgs.append(pn2->pn_cookie.slot()))
80966:                     return JS_FALSE;
80966:             }
80966:         }
80966:         ok = EmitTree(cx, bce, pnlast);
79378:         break;
79378:       }
79378: 
82024:       case PNK_UPVARS:
79378:         JS_ASSERT(pn->pn_names->count() != 0);
80966:         bce->roLexdeps = pn->pn_names;
80966:         ok = EmitTree(cx, bce, pn->pn_tree);
80966:         bce->roLexdeps.clearMap();
79378:         pn->pn_names.releaseMap(cx);
79378:         break;
79378: 
82024:       case PNK_IF:
80966:         ok = EmitIf(cx, bce, pn);
79378:         break;
79378: 
82024:       case PNK_SWITCH:
80966:         ok = EmitSwitch(cx, bce, pn);
79378:         break;
79378: 
82024:       case PNK_WHILE:
79378:         /*
79378:          * Minimize bytecodes issued for one or more iterations by jumping to
79378:          * the condition below the body and closing the loop if the condition
79378:          * is true with a backward branch. For iteration count i:
79378:          *
79378:          *  i    test at the top                 test at the bottom
79378:          *  =    ===============                 ==================
79378:          *  0    ifeq-pass                       goto; ifne-fail
79378:          *  1    ifeq-fail; goto; ifne-pass      goto; ifne-pass; ifne-fail
79378:          *  2    2*(ifeq-fail; goto); ifeq-pass  goto; 2*ifne-pass; ifne-fail
79378:          *  . . .
79378:          *  N    N*(ifeq-fail; goto); ifeq-pass  goto; N*ifne-pass; ifne-fail
79378:          *
79378:          * SpiderMonkey, pre-mozilla.org, emitted while parsing and so used
80631:          * test at the top. When ParseNode trees were added during the ES3
79378:          * work (1998-9), the code generation scheme was not optimized, and
79378:          * the decompiler continued to take advantage of the branch and jump
79378:          * that bracketed the body. But given the SRC_WHILE note, it is easy
79378:          * to support the more efficient scheme.
79378:          */
80966:         PushStatement(bce, &stmtInfo, STMT_WHILE_LOOP, top);
80966:         noteIndex = NewSrcNote(cx, bce, SRC_WHILE);
79378:         if (noteIndex < 0)
79378:             return JS_FALSE;
80966:         jmp = EmitJump(cx, bce, JSOP_GOTO, 0);
79378:         if (jmp < 0)
79378:             return JS_FALSE;
80966:         noteIndex2 = NewSrcNote(cx, bce, SRC_TRACE);
79378:         if (noteIndex2 < 0)
79378:             return JS_FALSE;
80966:         top = EmitTraceOp(cx, bce, pn->pn_right);
79378:         if (top < 0)
79378:             return JS_FALSE;
80966:         if (!EmitTree(cx, bce, pn->pn_right))
80966:             return JS_FALSE;
80966:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, bce, jmp);
80966:         if (!EmitTree(cx, bce, pn->pn_left))
80966:             return JS_FALSE;
80966:         beq = EmitJump(cx, bce, JSOP_IFNE, top - bce->offset());
79378:         if (beq < 0)
79378:             return JS_FALSE;
79378:         /*
79378:          * Be careful: We must set noteIndex2 before noteIndex in case the noteIndex
79378:          * note gets bigger.
79378:          */
80966:         if (!SetSrcNoteOffset(cx, bce, noteIndex2, 0, beq - top))
80966:             return JS_FALSE;
80966:         if (!SetSrcNoteOffset(cx, bce, noteIndex, 0, beq - jmp))
80966:             return JS_FALSE;
80966:         ok = PopStatementBCE(cx, bce);
79378:         break;
79378: 
82024:       case PNK_DO:
79378:         /* Emit an annotated nop so we know to decompile a 'do' keyword. */
80966:         noteIndex = NewSrcNote(cx, bce, SRC_WHILE);
80966:         if (noteIndex < 0 || Emit1(cx, bce, JSOP_NOP) < 0)
80966:             return JS_FALSE;
80966: 
80966:         noteIndex2 = NewSrcNote(cx, bce, SRC_TRACE);
79378:         if (noteIndex2 < 0)
79378:             return JS_FALSE;
79378: 
79378:         /* Compile the loop body. */
80966:         top = EmitTraceOp(cx, bce, pn->pn_left);
79378:         if (top < 0)
79378:             return JS_FALSE;
80966:         PushStatement(bce, &stmtInfo, STMT_DO_LOOP, top);
80966:         if (!EmitTree(cx, bce, pn->pn_left))
79378:             return JS_FALSE;
79378: 
79378:         /* Set loop and enclosing label update offsets, for continue. */
80966:         off = bce->offset();
79378:         stmt = &stmtInfo;
79378:         do {
79378:             stmt->update = off;
79378:         } while ((stmt = stmt->down) != NULL && stmt->type == STMT_LABEL);
79378: 
79378:         /* Compile the loop condition, now that continues know where to go. */
80966:         if (!EmitTree(cx, bce, pn->pn_right))
79378:             return JS_FALSE;
79378: 
79378:         /*
79378:          * Since we use JSOP_IFNE for other purposes as well as for do-while
79378:          * loops, we must store 1 + (beq - top) in the SRC_WHILE note offset,
79378:          * and the decompiler must get that delta and decompile recursively.
79378:          */
80966:         beq = EmitJump(cx, bce, JSOP_IFNE, top - bce->offset());
79378:         if (beq < 0)
79378:             return JS_FALSE;
79378:         /*
79378:          * Be careful: We must set noteIndex2 before noteIndex in case the noteIndex
79378:          * note gets bigger.
79378:          */
80966:         if (!SetSrcNoteOffset(cx, bce, noteIndex2, 0, beq - top))
80966:             return JS_FALSE;
80966:         if (!SetSrcNoteOffset(cx, bce, noteIndex, 0, 1 + (off - top)))
80966:             return JS_FALSE;
80966:         ok = PopStatementBCE(cx, bce);
79378:         break;
79378: 
82024:       case PNK_FOR:
80966:         ok = EmitFor(cx, bce, pn, top);
79378:         break;
79378: 
82024:       case PNK_BREAK: {
80966:         stmt = bce->topStmt;
79378:         atom = pn->pn_atom;
79378: 
79378:         jsatomid labelIndex;
79378:         if (atom) {
80966:             if (!bce->makeAtomIndex(atom, &labelIndex))
79378:                 return JS_FALSE;
79378: 
79378:             while (stmt->type != STMT_LABEL || stmt->label != atom)
79378:                 stmt = stmt->down;
79378:             noteType = SRC_BREAK2LABEL;
79378:         } else {
79378:             labelIndex = INVALID_ATOMID;
79378:             while (!STMT_IS_LOOP(stmt) && stmt->type != STMT_SWITCH)
79378:                 stmt = stmt->down;
79378:             noteType = (stmt->type == STMT_SWITCH) ? SRC_SWITCHBREAK : SRC_BREAK;
79378:         }
79378: 
80966:         if (EmitGoto(cx, bce, stmt, &stmt->breaks, labelIndex, noteType) < 0)
79378:             return JS_FALSE;
79378:         break;
79378:       }
79378: 
82024:       case PNK_CONTINUE: {
80966:         stmt = bce->topStmt;
79378:         atom = pn->pn_atom;
79378: 
79378:         jsatomid labelIndex;
79378:         if (atom) {
79378:             /* Find the loop statement enclosed by the matching label. */
80631:             StmtInfo *loop = NULL;
80966:             if (!bce->makeAtomIndex(atom, &labelIndex))
79378:                 return JS_FALSE;
79378:             while (stmt->type != STMT_LABEL || stmt->label != atom) {
79378:                 if (STMT_IS_LOOP(stmt))
79378:                     loop = stmt;
79378:                 stmt = stmt->down;
79378:             }
79378:             stmt = loop;
79378:             noteType = SRC_CONT2LABEL;
79378:         } else {
79378:             labelIndex = INVALID_ATOMID;
79378:             while (!STMT_IS_LOOP(stmt))
79378:                 stmt = stmt->down;
79378:             noteType = SRC_CONTINUE;
79378:         }
79378: 
80966:         if (EmitGoto(cx, bce, stmt, &stmt->continues, labelIndex, noteType) < 0)
79378:             return JS_FALSE;
79378:         break;
79378:       }
79378: 
82024:       case PNK_WITH:
81588:         ok = EmitWith(cx, bce, pn);
79378:         break;
79378: 
82024:       case PNK_TRY:
80966:         if (!EmitTry(cx, bce, pn))
79378:             return false;
79378:         break;
    1: 
82024:       case PNK_CATCH:
80966:         if (!EmitCatch(cx, bce, pn))
79378:             return false;
79378:         break;
    1: 
82024:       case PNK_VAR:
80966:         if (!EmitVariables(cx, bce, pn, JS_FALSE, &noteIndex))
    1:             return JS_FALSE;
    1:         break;
    1: 
82024:       case PNK_RETURN:
    1:         /* Push a return value */
    1:         pn2 = pn->pn_kid;
    1:         if (pn2) {
80966:             if (!EmitTree(cx, bce, pn2))
    1:                 return JS_FALSE;
    1:         } else {
80966:             if (Emit1(cx, bce, JSOP_PUSH) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         /*
11758:          * EmitNonLocalJumpFixup may add fixup bytecode to close open try
11758:          * blocks having finally clauses and to exit intermingled let blocks.
    1:          * We can't simply transfer control flow to our caller in that case,
11758:          * because we must gosub to those finally clauses from inner to outer,
11758:          * with the correct stack pointer (i.e., after popping any with,
11758:          * for/in, etc., slots nested inside the finally's try).
11758:          *
11758:          * In this case we mutate JSOP_RETURN into JSOP_SETRVAL and add an
11758:          * extra JSOP_RETRVAL after the fixups.
11758:          */
80966:         top = bce->offset();
80966:         if (Emit1(cx, bce, JSOP_RETURN) < 0)
80966:             return JS_FALSE;
80966:         if (!EmitNonLocalJumpFixup(cx, bce, NULL))
80966:             return JS_FALSE;
80966:         if (top + JSOP_RETURN_LENGTH != bce->offset()) {
80966:             bce->base()[top] = JSOP_SETRVAL;
80966:             if (Emit1(cx, bce, JSOP_RETRVAL) < 0)
80966:                 return JS_FALSE;
80966:             if (EmitBlockChain(cx, bce) < 0)
55526:                 return JS_FALSE;
11758:         }
    1:         break;
    1: 
    1: #if JS_HAS_GENERATORS
82024:       case PNK_YIELD:
80966:         JS_ASSERT(bce->inFunction());
    1:         if (pn->pn_kid) {
80966:             if (!EmitTree(cx, bce, pn->pn_kid))
    1:                 return JS_FALSE;
    1:         } else {
80966:             if (Emit1(cx, bce, JSOP_PUSH) < 0)
80966:                 return JS_FALSE;
80966:         }
80966:         if (pn->pn_hidden && NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
80966:             return JS_FALSE;
80966:         if (Emit1(cx, bce, JSOP_YIELD) < 0)
    1:             return JS_FALSE;
    1:         break;
    1: #endif
    1: 
82024:       case PNK_LC:
26961:       {
    1: #if JS_HAS_XML_SUPPORT
78294:         if (pn->isArity(PN_UNARY)) {
80966:             if (!EmitTree(cx, bce, pn->pn_kid))
80966:                 return JS_FALSE;
80966:             if (Emit1(cx, bce, pn->getOp()) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1:         }
    1: #endif
    1: 
78294:         JS_ASSERT(pn->isArity(PN_LIST));
    1: 
    1:         noteIndex = -1;
80966:         tmp = bce->offset();
27012:         if (pn->pn_xflags & PNX_NEEDBRACES) {
80966:             noteIndex = NewSrcNote2(cx, bce, SRC_BRACE, 0);
80966:             if (noteIndex < 0 || Emit1(cx, bce, JSOP_NOP) < 0)
80966:                 return JS_FALSE;
80966:         }
80966: 
80966:         PushStatement(bce, &stmtInfo, STMT_BLOCK, top);
27012: 
80631:         ParseNode *pnchild = pn->pn_head;
27012:         if (pn->pn_xflags & PNX_FUNCDEFS) {
10466:             /*
10466:              * This block contains top-level function definitions. To ensure
27012:              * that we emit the bytecode defining them before the rest of code
10466:              * in the block we use a separate pass over functions. During the
10466:              * main pass later the emitter will add JSOP_NOP with source notes
10466:              * for the function to preserve the original functions position
10466:              * when decompiling.
10466:              *
10466:              * Currently this is used only for functions, as compile-as-we go
10466:              * mode for scripts does not allow separate emitter passes.
10466:              */
80966:             JS_ASSERT(bce->inFunction());
27012:             if (pn->pn_xflags & PNX_DESTRUCT) {
26961:                 /*
26961:                  * Assign the destructuring arguments before defining any
26961:                  * functions, see bug 419662.
26961:                  */
82024:                 JS_ASSERT(pnchild->isKind(PNK_SEMI));
82024:                 JS_ASSERT(pnchild->pn_kid->isKind(PNK_VAR));
80966:                 if (!EmitTree(cx, bce, pnchild))
27012:                     return JS_FALSE;
27012:                 pnchild = pnchild->pn_next;
27012:             }
27012: 
27012:             for (pn2 = pnchild; pn2; pn2 = pn2->pn_next) {
82024:                 if (pn2->isKind(PNK_FUNCTION)) {
78294:                     if (pn2->isOp(JSOP_NOP)) {
80966:                         if (!EmitTree(cx, bce, pn2))
10466:                             return JS_FALSE;
14332:                     } else {
14332:                         /*
18965:                          * JSOP_DEFFUN in a top-level block with function
14332:                          * definitions appears, for example, when "if (true)"
14332:                          * is optimized away from "if (true) function x() {}".
14332:                          * See bug 428424.
14332:                          */
78294:                         JS_ASSERT(pn2->isOp(JSOP_DEFFUN));
14332:                     }
10466:                 }
10466:             }
10466:         }
27012:         for (pn2 = pnchild; pn2; pn2 = pn2->pn_next) {
80966:             if (!EmitTree(cx, bce, pn2))
80966:                 return JS_FALSE;
80966:         }
80966: 
80966:         if (noteIndex >= 0 && !SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 0, bce->offset() - tmp))
80966:             return JS_FALSE;
80966: 
80966:         ok = PopStatementBCE(cx, bce);
    1:         break;
26961:       }
    1: 
82024:       case PNK_SEQ:
78294:         JS_ASSERT(pn->isArity(PN_LIST));
80966:         PushStatement(bce, &stmtInfo, STMT_SEQ, top);
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
80966:             if (!EmitTree(cx, bce, pn2))
80966:                 return JS_FALSE;
80966:         }
80966:         ok = PopStatementBCE(cx, bce);
    1:         break;
    1: 
82024:       case PNK_SEMI:
    1:         pn2 = pn->pn_kid;
    1:         if (pn2) {
    1:             /*
    1:              * Top-level or called-from-a-native JS_Execute/EvaluateScript,
    1:              * debugger, and eval frames may need the value of the ultimate
    1:              * expression statement as the script's result, despite the fact
    1:              * that it appears useless to the compiler.
17828:              *
17828:              * API users may also set the JSOPTION_NO_SCRIPT_RVAL option when
17838:              * calling JS_Compile* to suppress JSOP_POPV.
17828:              */
80966:             useful = wantval = !(bce->flags & (TCF_IN_FUNCTION | TCF_NO_SCRIPT_RVAL));
60792: 
60792:             /* Don't eliminate expressions with side effects. */
    1:             if (!useful) {
80966:                 if (!CheckSideEffects(cx, bce, pn2, &useful))
    1:                     return JS_FALSE;
    1:             }
    1: 
    1:             /*
    1:              * Don't eliminate apparently useless expressions if they are
    1:              * labeled expression statements.  The tc->topStmt->update test
80632:              * catches the case where we are nesting in EmitTree for a labeled
80632:              * compound statement.
    1:              */
    1:             if (!useful &&
80966:                 bce->topStmt &&
80966:                 bce->topStmt->type == STMT_LABEL &&
80966:                 bce->topStmt->update >= bce->offset()) {
60792:                 useful = true;
60792:             }
60792: 
60792:             if (!useful) {
60792:                 /* Don't complain about directive prologue members; just don't emit their code. */
60792:                 if (!pn->isDirectivePrologueMember()) {
80966:                     bce->current->currentLine = pn2->pn_pos.begin.lineno;
80966:                     if (!ReportCompileErrorNumber(cx, bce->tokenStream(), pn2,
40320:                                                   JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                                   JSMSG_USELESS_EXPR)) {
    1:                         return JS_FALSE;
    1:                     }
60792:                 }
    1:             } else {
    1:                 op = wantval ? JSOP_POPV : JSOP_POP;
82024:                 JS_ASSERT_IF(pn2->isKind(PNK_ASSIGN), pn2->isOp(JSOP_NOP));
    1: #if JS_HAS_DESTRUCTURING
    1:                 if (!wantval &&
82024:                     pn2->isKind(PNK_ASSIGN) &&
80966:                     !MaybeEmitGroupAssignment(cx, bce, op, pn2, &op)) {
    1:                     return JS_FALSE;
    1:                 }
    1: #endif
    1:                 if (op != JSOP_NOP) {
37685:                     /*
37685:                      * Specialize JSOP_SETPROP to JSOP_SETMETHOD to defer or
37685:                      * avoid null closure cloning. Do this only for assignment
37685:                      * statements that are not completion values wanted by a
37685:                      * script evaluator, to ensure that the joined function
37685:                      * can't escape directly.
37685:                      */
37685:                     if (!wantval &&
82024:                         pn2->isKind(PNK_ASSIGN) &&
78294:                         pn2->pn_left->isOp(JSOP_SETPROP) &&
78294:                         pn2->pn_right->isOp(JSOP_LAMBDA) &&
37685:                         pn2->pn_right->pn_funbox->joinable()) {
78294:                         pn2->pn_left->setOp(JSOP_SETMETHOD);
37685:                     }
80966:                     if (!EmitTree(cx, bce, pn2))
80966:                         return JS_FALSE;
80966:                     if (Emit1(cx, bce, op) < 0)
    1:                         return JS_FALSE;
    1:                 }
    1:             }
    1:         }
    1:         break;
    1: 
82024:       case PNK_COLON:
82079:         /*
82079:          * Emit a JSOP_LABEL instruction. The argument is the offset to the statement
82079:          * following the labeled statement. This op has either a SRC_LABEL or
82079:          * SRC_LABELBRACE source note for the decompiler.
82079:          */
    1:         atom = pn->pn_atom;
72579: 
72579:         jsatomid index;
80966:         if (!bce->makeAtomIndex(atom, &index))
72579:             return JS_FALSE;
72579: 
27012:         pn2 = pn->expr();
82024:         noteType = (pn2->isKind(PNK_LC) ||
82024:                     (pn2->isKind(PNK_LEXICALSCOPE) &&
82024:                      pn2->expr()->isKind(PNK_LC)))
    1:                    ? SRC_LABELBRACE
    1:                    : SRC_LABEL;
80966:         noteIndex = NewSrcNote2(cx, bce, noteType, ptrdiff_t(index));
82079:         if (noteIndex < 0)
82079:             return JS_FALSE;
82079: 
82079:         top = EmitJump(cx, bce, JSOP_LABEL, 0);
82079:         if (top < 0)
80632:             return JS_FALSE;
    1: 
    1:         /* Emit code for the labeled statement. */
80966:         PushStatement(bce, &stmtInfo, STMT_LABEL, bce->offset());
27012:         stmtInfo.label = atom;
80966:         if (!EmitTree(cx, bce, pn2))
80966:             return JS_FALSE;
80966:         if (!PopStatementBCE(cx, bce))
    1:             return JS_FALSE;
    1: 
82079:         /* Patch the JSOP_LABEL offset. */
82079:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, bce, top);
82079: 
    1:         /* If the statement was compound, emit a note for the end brace. */
    1:         if (noteType == SRC_LABELBRACE) {
80966:             if (NewSrcNote(cx, bce, SRC_ENDBRACE) < 0 ||
80966:                 Emit1(cx, bce, JSOP_NOP) < 0) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1: 
82024:       case PNK_COMMA:
    1:         /*
    1:          * Emit SRC_PCDELTA notes on each JSOP_POP between comma operands.
    1:          * These notes help the decompiler bracket the bytecodes generated
    1:          * from each sub-expression that follows a comma.
    1:          */
    1:         off = noteIndex = -1;
    1:         for (pn2 = pn->pn_head; ; pn2 = pn2->pn_next) {
80966:             if (!EmitTree(cx, bce, pn2))
80966:                 return JS_FALSE;
80966:             tmp = bce->offset();
    1:             if (noteIndex >= 0) {
80966:                 if (!SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 0, tmp-off))
    1:                     return JS_FALSE;
    1:             }
    1:             if (!pn2->pn_next)
    1:                 break;
    1:             off = tmp;
80966:             noteIndex = NewSrcNote2(cx, bce, SRC_PCDELTA, 0);
    1:             if (noteIndex < 0 ||
80966:                 Emit1(cx, bce, JSOP_POP) < 0) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1: 
82024:       case PNK_ASSIGN:
82024:       case PNK_ADDASSIGN:
82024:       case PNK_SUBASSIGN:
82024:       case PNK_BITORASSIGN:
82024:       case PNK_BITXORASSIGN:
82024:       case PNK_BITANDASSIGN:
82024:       case PNK_LSHASSIGN:
82024:       case PNK_RSHASSIGN:
82024:       case PNK_URSHASSIGN:
82024:       case PNK_MULASSIGN:
82024:       case PNK_DIVASSIGN:
82024:       case PNK_MODASSIGN:
80966:         if (!EmitAssignment(cx, bce, pn->pn_left, pn->getOp(), pn->pn_right))
74052:             return false;
    1:         break;
    1: 
82024:       case PNK_HOOK:
    1:         /* Emit the condition, then branch if false to the else part. */
80966:         if (!EmitTree(cx, bce, pn->pn_kid1))
80966:             return JS_FALSE;
80966:         noteIndex = NewSrcNote(cx, bce, SRC_COND);
    1:         if (noteIndex < 0)
    1:             return JS_FALSE;
80966:         beq = EmitJump(cx, bce, JSOP_IFEQ, 0);
80966:         if (beq < 0 || !EmitTree(cx, bce, pn->pn_kid2))
    1:             return JS_FALSE;
    1: 
    1:         /* Jump around else, fixup the branch, emit else, fixup jump. */
80966:         jmp = EmitJump(cx, bce, JSOP_GOTO, 0);
    1:         if (jmp < 0)
    1:             return JS_FALSE;
80966:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, bce, beq);
    1: 
    1:         /*
    1:          * Because each branch pushes a single value, but our stack budgeting
80966:          * analysis ignores branches, we now have to adjust bce->stackDepth to
    1:          * ignore the value pushed by the first branch.  Execution will follow
80966:          * only one path, so we must decrement bce->stackDepth.
    1:          *
    1:          * Failing to do this will foil code, such as the try/catch/finally
80966:          * exception handling code generator, that samples bce->stackDepth for
    1:          * use at runtime (JSOP_SETSP), or in let expression and block code
    1:          * generation, which must use the stack depth to compute local stack
    1:          * indexes correctly.
    1:          */
80966:         JS_ASSERT(bce->stackDepth > 0);
80966:         bce->stackDepth--;
80966:         if (!EmitTree(cx, bce, pn->pn_kid3))
80966:             return JS_FALSE;
80966:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, bce, jmp);
80966:         if (!SetSrcNoteOffset(cx, bce, noteIndex, 0, jmp - beq))
    1:             return JS_FALSE;
    1:         break;
    1: 
82024:       case PNK_OR:
82024:       case PNK_AND:
    1:         /*
82080:          * JSOP_OR converts the operand on the stack to boolean, leaves the original
82080:          * value on the stack and jumps if true; otherwise it falls into the next
82080:          * bytecode, which pops the left operand and then evaluates the right operand.
82080:          * The jump goes around the right operand evaluation.
    1:          *
82080:          * JSOP_AND converts the operand on the stack to boolean and jumps if false;
82080:          * otherwise it falls into the right operand's bytecode.
 6116:          */
78294:         if (pn->isArity(PN_BINARY)) {
80966:             if (!EmitTree(cx, bce, pn->pn_left))
80966:                 return JS_FALSE;
82080:             top = EmitJump(cx, bce, JSOP_BACKPATCH, 0);
    1:             if (top < 0)
    1:                 return JS_FALSE;
82080:             if (Emit1(cx, bce, JSOP_POP) < 0)
82080:                 return JS_FALSE;
80966:             if (!EmitTree(cx, bce, pn->pn_right))
80966:                 return JS_FALSE;
80966:             off = bce->offset();
80966:             pc = bce->code(top);
80966:             CHECK_AND_SET_JUMP_OFFSET(cx, bce, pc, off - top);
78294:             *pc = pn->getOp();
 6116:         } else {
78294:             JS_ASSERT(pn->isArity(PN_LIST));
 6116:             JS_ASSERT(pn->pn_head->pn_next->pn_next);
 6116: 
 6116:             /* Left-associative operator chain: avoid too much recursion. */
 6116:             pn2 = pn->pn_head;
80966:             if (!EmitTree(cx, bce, pn2))
80966:                 return JS_FALSE;
82080:             top = EmitJump(cx, bce, JSOP_BACKPATCH, 0);
 6116:             if (top < 0)
 6116:                 return JS_FALSE;
82080:             if (Emit1(cx, bce, JSOP_POP) < 0)
82080:                 return JS_FALSE;
 6116: 
 6116:             /* Emit nodes between the head and the tail. */
    1:             jmp = top;
 6116:             while ((pn2 = pn2->pn_next)->pn_next) {
80966:                 if (!EmitTree(cx, bce, pn2))
80966:                     return JS_FALSE;
82080:                 off = EmitJump(cx, bce, JSOP_BACKPATCH, 0);
    1:                 if (off < 0)
    1:                     return JS_FALSE;
82080:                 if (Emit1(cx, bce, JSOP_POP) < 0)
82080:                     return JS_FALSE;
80966:                 if (!SetBackPatchDelta(cx, bce, bce->code(jmp), off - jmp))
    1:                     return JS_FALSE;
    1:                 jmp = off;
 6116: 
    1:             }
80966:             if (!EmitTree(cx, bce, pn2))
    1:                 return JS_FALSE;
 6116: 
 6116:             pn2 = pn->pn_head;
80966:             off = bce->offset();
    1:             do {
80966:                 pc = bce->code(top);
80966:                 tmp = GetJumpOffset(bce, pc);
80966:                 CHECK_AND_SET_JUMP_OFFSET(cx, bce, pc, off - top);
78294:                 *pc = pn->getOp();
    1:                 top += tmp;
 6116:             } while ((pn2 = pn2->pn_next)->pn_next);
 6116:         }
    1:         break;
    1: 
82024:       case PNK_PLUS:
82024:       case PNK_MINUS:
82018:         if (pn->isArity(PN_UNARY))
82018:             goto unary_plusminus;
82024:       case PNK_BITOR:
82024:       case PNK_BITXOR:
82024:       case PNK_BITAND:
82024:       case PNK_STRICTEQ:
82024:       case PNK_EQ:
82024:       case PNK_STRICTNE:
82024:       case PNK_NE:
82024:       case PNK_LT:
82024:       case PNK_LE:
82024:       case PNK_GT:
82024:       case PNK_GE:
82024:       case PNK_IN:
82024:       case PNK_INSTANCEOF:
82024:       case PNK_LSH:
82024:       case PNK_RSH:
82024:       case PNK_URSH:
82024:       case PNK_STAR:
82024:       case PNK_DIV:
82024:       case PNK_MOD:
78294:         if (pn->isArity(PN_LIST)) {
    1:             /* Left-associative operator chain: avoid too much recursion. */
    1:             pn2 = pn->pn_head;
80966:             if (!EmitTree(cx, bce, pn2))
    1:                 return JS_FALSE;
78294:             op = pn->getOp();
    1:             while ((pn2 = pn2->pn_next) != NULL) {
80966:                 if (!EmitTree(cx, bce, pn2))
80966:                     return JS_FALSE;
80966:                 if (Emit1(cx, bce, op) < 0)
    1:                     return JS_FALSE;
    1:             }
    1:         } else {
    1: #if JS_HAS_XML_SUPPORT
    1:             uintN oldflags;
    1: 
82024:       case PNK_DBLCOLON:
82114:             JS_ASSERT(pn->getOp() != JSOP_XMLNAME);
78294:             if (pn->isArity(PN_NAME)) {
80966:                 if (!EmitTree(cx, bce, pn->expr()))
80966:                     return JS_FALSE;
80966:                 if (!EmitAtomOp(cx, pn, pn->getOp(), bce))
    1:                     return JS_FALSE;
    1:                 break;
    1:             }
    1: 
    1:             /*
    1:              * Binary :: has a right operand that brackets arbitrary code,
    1:              * possibly including a let (a = b) ... expression.  We must clear
    1:              * TCF_IN_FOR_INIT to avoid mis-compiling such beasts.
    1:              */
80966:             oldflags = bce->flags;
80966:             bce->flags &= ~TCF_IN_FOR_INIT;
    1: #endif
    1: 
    1:             /* Binary operators that evaluate both operands unconditionally. */
80966:             if (!EmitTree(cx, bce, pn->pn_left))
80966:                 return JS_FALSE;
80966:             if (!EmitTree(cx, bce, pn->pn_right))
    1:                 return JS_FALSE;
    1: #if JS_HAS_XML_SUPPORT
80966:             bce->flags |= oldflags & TCF_IN_FOR_INIT;
    1: #endif
80966:             if (Emit1(cx, bce, pn->getOp()) < 0)
    1:                 return JS_FALSE;
    1:         }
    1:         break;
    1: 
82114: #if JS_HAS_XML_SUPPORT
82114:       case PNK_XMLUNARY:
82114:         if (pn->getOp() == JSOP_XMLNAME) {
82114:             if (!EmitXMLName(cx, pn, JSOP_XMLNAME, bce))
82114:                 return false;
82114:         } else {
82114:             JSOp op = pn->getOp();
82114:             JS_ASSERT(op == JSOP_BINDXMLNAME || op == JSOP_SETXMLNAME);
82114:             uintN oldflags = bce->flags;
82114:             bce->flags &= ~TCF_IN_FOR_INIT;
82114:             if (!EmitTree(cx, bce, pn->pn_kid))
82114:                 return false;
82114:             bce->flags |= oldflags & TCF_IN_FOR_INIT;
82114:             if (Emit1(cx, bce, op) < 0)
82114:                 return false;
82114:         }
82114:         break;
82114: #endif
82114: 
82024:       case PNK_THROW:
    1: #if JS_HAS_XML_SUPPORT
82024:       case PNK_AT:
82024:       case PNK_DEFAULT:
78294:         JS_ASSERT(pn->isArity(PN_UNARY));
    1:         /* FALL THROUGH */
    1: #endif
82024:       case PNK_TYPEOF:
82024:       case PNK_VOID:
82024:       case PNK_NOT:
82024:       case PNK_BITNOT:
82018:       unary_plusminus:
    1:       {
    1:         /* Unary op, including unary +/-. */
78294:         op = pn->getOp();
    1:         pn2 = pn->pn_kid;
35096: 
82114:         JS_ASSERT(op != JSOP_XMLNAME);
82024:         if (op == JSOP_TYPEOF && !pn2->isKind(PNK_NAME))
37664:             op = JSOP_TYPEOFEXPR;
35096: 
82114:         uintN oldflags = bce->flags;
80966:         bce->flags &= ~TCF_IN_FOR_INIT;
80966:         if (!EmitTree(cx, bce, pn2))
80966:             return JS_FALSE;
80966:         bce->flags |= oldflags & TCF_IN_FOR_INIT;
80966:         if (Emit1(cx, bce, op) < 0)
    1:             return JS_FALSE;
    1:         break;
    1:       }
    1: 
82024:       case PNK_INC:
82024:       case PNK_DEC:
    1:         /* Emit lvalue-specialized code for ++/-- operators. */
    1:         pn2 = pn->pn_kid;
82024:         JS_ASSERT(!pn2->isKind(PNK_RP));
78294:         op = pn->getOp();
78294:         switch (pn2->getKind()) {
12611:           default:
82024:             JS_ASSERT(pn2->isKind(PNK_NAME));
78294:             pn2->setOp(op);
80966:             if (!BindNameToSlot(cx, bce, pn2))
    1:                 return JS_FALSE;
78294:             op = pn2->getOp();
27012:             if (op == JSOP_CALLEE) {
80966:                 if (Emit1(cx, bce, op) < 0)
27012:                     return JS_FALSE;
47573:             } else if (!pn2->pn_cookie.isFree()) {
72579:                 atomIndex = pn2->pn_cookie.asInteger();
    1:                 EMIT_UINT16_IMM_OP(op, atomIndex);
    1:             } else {
27012:                 JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
77376:                 if (js_CodeSpec[op].format & (JOF_INC | JOF_DEC)) {
80966:                     if (!EmitNameIncDec(cx, pn2, op, bce))
74052:                         return JS_FALSE;
77376:                 } else {
80966:                     if (!EmitAtomOp(cx, pn2, op, bce))
    1:                         return JS_FALSE;
77376:                 }
27012:                 break;
27012:             }
27012:             if (pn2->isConst()) {
80966:                 if (Emit1(cx, bce, JSOP_POS) < 0)
27012:                     return JS_FALSE;
78294:                 op = pn->getOp();
27012:                 if (!(js_CodeSpec[op].format & JOF_POST)) {
80966:                     if (Emit1(cx, bce, JSOP_ONE) < 0)
27012:                         return JS_FALSE;
27012:                     op = (js_CodeSpec[op].format & JOF_INC) ? JSOP_ADD : JSOP_SUB;
80966:                     if (Emit1(cx, bce, op) < 0)
27012:                         return JS_FALSE;
27012:                 }
    1:             }
    1:             break;
82024:           case PNK_DOT:
80966:             if (!EmitPropIncDec(cx, pn2, op, bce))
    1:                 return JS_FALSE;
    1:             break;
82024:           case PNK_LB:
80966:             if (!EmitElemIncDec(cx, pn2, op, bce))
    1:                 return JS_FALSE;
    1:             break;
82024:           case PNK_LP:
80966:             if (!EmitTree(cx, bce, pn2))
80966:                 return JS_FALSE;
80966:             if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - pn2->pn_offset) < 0)
80966:                 return JS_FALSE;
80966:             if (Emit1(cx, bce, op) < 0)
    1:                 return JS_FALSE;
77359:             /*
77359:              * This is dead code for the decompiler, don't generate
77365:              * a decomposed version of the opcode. We do need to balance
77365:              * the stacks in the decomposed version.
77365:              */
77366:             JS_ASSERT(js_CodeSpec[op].format & JOF_DECOMPOSE);
77365:             JS_ASSERT(js_CodeSpec[op].format & JOF_ELEM);
80966:             if (Emit1(cx, bce, (JSOp)1) < 0)
80966:                 return JS_FALSE;
80966:             if (Emit1(cx, bce, JSOP_POP) < 0)
77359:                 return JS_FALSE;
    1:             break;
    1: #if JS_HAS_XML_SUPPORT
82114:           case PNK_XMLUNARY:
80966:             JS_ASSERT(!bce->inStrictMode());
78294:             JS_ASSERT(pn2->isOp(JSOP_SETXMLNAME));
80966:             if (!EmitTree(cx, bce, pn2->pn_kid))
80966:                 return JS_FALSE;
80966:             if (Emit1(cx, bce, JSOP_BINDXMLNAME) < 0)
80966:                 return JS_FALSE;
80966:             if (!EmitElemIncDec(cx, NULL, op, bce))
    1:                 return JS_FALSE;
    1:             break;
    1: #endif
12611:         }
    1:         break;
    1: 
82024:       case PNK_DELETE:
    1:         /*
    1:          * Under ECMA 3, deleting a non-reference returns true -- but alas we
    1:          * must evaluate the operand if it appears it might have side effects.
    1:          */
    1:         pn2 = pn->pn_kid;
78294:         switch (pn2->getKind()) {
82024:           case PNK_NAME:
80966:             if (!BindNameToSlot(cx, bce, pn2))
    1:                 return JS_FALSE;
78294:             op = pn2->getOp();
    1:             if (op == JSOP_FALSE) {
80966:                 if (Emit1(cx, bce, op) < 0)
    1:                     return JS_FALSE;
    1:             } else {
80966:                 if (!EmitAtomOp(cx, pn2, op, bce))
    1:                     return JS_FALSE;
    1:             }
    1:             break;
82024:           case PNK_DOT:
80966:             if (!EmitPropOp(cx, pn2, JSOP_DELPROP, bce, JS_FALSE))
    1:                 return JS_FALSE;
    1:             break;
    1: #if JS_HAS_XML_SUPPORT
82024:           case PNK_DBLDOT:
80966:             JS_ASSERT(!bce->inStrictMode());
80966:             if (!EmitElemOp(cx, pn2, JSOP_DELDESC, bce))
    1:                 return JS_FALSE;
    1:             break;
    1: #endif
82024:           case PNK_LB:
80966:             if (!EmitElemOp(cx, pn2, JSOP_DELELEM, bce))
    1:                 return JS_FALSE;
    1:             break;
    1:           default:
    1:             /*
    1:              * If useless, just emit JSOP_TRUE; otherwise convert delete foo()
20928:              * to foo(), true (a comma expression, requiring SRC_PCDELTA).
    1:              */
    1:             useful = JS_FALSE;
80966:             if (!CheckSideEffects(cx, bce, pn2, &useful))
    1:                 return JS_FALSE;
    1:             if (!useful) {
    1:                 off = noteIndex = -1;
    1:             } else {
82024:                 JS_ASSERT_IF(pn2->isKind(PNK_LP), !(pn2->pn_xflags & PNX_SETCALL));
80966:                 if (!EmitTree(cx, bce, pn2))
80966:                     return JS_FALSE;
80966:                 off = bce->offset();
80966:                 noteIndex = NewSrcNote2(cx, bce, SRC_PCDELTA, 0);
80966:                 if (noteIndex < 0 || Emit1(cx, bce, JSOP_POP) < 0)
80966:                     return JS_FALSE;
80966:             }
80966:             if (Emit1(cx, bce, JSOP_TRUE) < 0)
    1:                 return JS_FALSE;
    1:             if (noteIndex >= 0) {
80966:                 tmp = bce->offset();
80966:                 if (!SetSrcNoteOffset(cx, bce, (uintN)noteIndex, 0, tmp-off))
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
82024:       case PNK_FILTER:
80966:         JS_ASSERT(!bce->inStrictMode());
80966: 
80966:         if (!EmitTree(cx, bce, pn->pn_left))
80966:             return JS_FALSE;
80966:         jmp = EmitJump(cx, bce, JSOP_FILTER, 0);
    1:         if (jmp < 0)
    1:             return JS_FALSE;
80966:         top = EmitTraceOp(cx, bce, pn->pn_right);
34286:         if (top < 0)
25627:             return JS_FALSE;
80966:         if (!EmitTree(cx, bce, pn->pn_right))
80966:             return JS_FALSE;
80966:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, bce, jmp);
80966:         if (EmitJump(cx, bce, JSOP_ENDFILTER, top - bce->offset()) < 0)
11672:             return JS_FALSE;
55527: 
55527:         /* Make blockChain determination quicker. */
80966:         if (EmitBlockChain(cx, bce) < 0)
55527:             return JS_FALSE;
    1:         break;
    1: #endif
    1: 
82024:       case PNK_DOT:
    1:         /*
    1:          * Pop a stack operand, convert it to object, get a property named by
    1:          * this bytecode's immediate-indexed atom operand, and push its value
    1:          * (not a reference to it).
    1:          */
80966:         ok = EmitPropOp(cx, pn, pn->getOp(), bce, JS_FALSE);
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
82024:       case PNK_DBLDOT:
80966:         JS_ASSERT(!bce->inStrictMode());
80780:         /* FALL THROUGH */
    1: #endif
82024:       case PNK_LB:
    1:         /*
    1:          * Pop two operands, convert the left one to object and the right one
    1:          * to property name (atom or tagged int), get the named property, and
    1:          * push its value.  Set the "obj" register to the result of ToObject
    1:          * on the left operand.
    1:          */
80966:         ok = EmitElemOp(cx, pn, pn->getOp(), bce);
    1:         break;
    1: 
82024:       case PNK_NEW:
82024:       case PNK_LP:
82024:       {
82024:         bool callop = pn->isKind(PNK_LP);
    1: 
    1:         /*
33604:          * Emit callable invocation or operator new (constructor call) code.
    1:          * First, emit code for the left operand to evaluate the callable or
    1:          * constructable object expression.
33604:          *
33604:          * For operator new applied to other expressions than E4X ones, we emit
33604:          * JSOP_GETPROP instead of JSOP_CALLPROP, etc. This is necessary to
33604:          * interpose the lambda-initialized method read barrier -- see the code
48470:          * in jsinterp.cpp for JSOP_LAMBDA followed by JSOP_{SET,INIT}PROP.
33604:          *
55712:          * Then (or in a call case that has no explicit reference-base
55712:          * object) we emit JSOP_PUSH to produce the |this| slot required
55712:          * for calls (which non-strict mode functions will box into the
55712:          * global object).
    1:          */
    1:         pn2 = pn->pn_head;
78294:         switch (pn2->getKind()) {
82024:           case PNK_NAME:
80966:             if (!EmitNameOp(cx, bce, pn2, callop))
    1:                 return JS_FALSE;
    1:             break;
82024:           case PNK_DOT:
80966:             if (!EmitPropOp(cx, pn2, pn2->getOp(), bce, callop))
    1:                 return JS_FALSE;
    1:             break;
82024:           case PNK_LB:
78294:             JS_ASSERT(pn2->isOp(JSOP_GETELEM));
80966:             if (!EmitElemOp(cx, pn2, callop ? JSOP_CALLELEM : JSOP_GETELEM, bce))
    1:                 return JS_FALSE;
    1:             break;
    1: #if JS_HAS_XML_SUPPORT
82114:           case PNK_XMLUNARY:
82018:             JS_ASSERT(pn2->isOp(JSOP_XMLNAME));
80966:             if (!EmitXMLName(cx, pn2, JSOP_CALLXMLNAME, bce))
    1:                 return JS_FALSE;
55712:             callop = true;          /* suppress JSOP_PUSH after */
    1:             break;
    1: #endif
    1:           default:
80966:             if (!EmitTree(cx, bce, pn2))
18031:                 return JS_FALSE;
55712:             callop = false;             /* trigger JSOP_PUSH after */
55712:             break;
55712:         }
80966:         if (!callop && Emit1(cx, bce, JSOP_PUSH) < 0)
33604:             return JS_FALSE;
    1: 
    1:         /* Remember start of callable-object bytecode for decompilation hint. */
    1:         off = top;
    1: 
    1:         /*
    1:          * Emit code for each argument in order, then emit the JSOP_*CALL or
    1:          * JSOP_NEW bytecode with a two-byte immediate telling how many args
    1:          * were pushed on the operand stack.
    1:          */
80966:         uintN oldflags = bce->flags;
80966:         bce->flags &= ~TCF_IN_FOR_INIT;
 4127:         for (pn3 = pn2->pn_next; pn3; pn3 = pn3->pn_next) {
80966:             if (!EmitTree(cx, bce, pn3))
80966:                 return JS_FALSE;
80966:         }
80966:         bce->flags |= oldflags & TCF_IN_FOR_INIT;
80966:         if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - off) < 0)
    1:             return JS_FALSE;
    1: 
    1:         argc = pn->pn_count - 1;
80966:         if (Emit3(cx, bce, pn->getOp(), ARGC_HI(argc), ARGC_LO(argc)) < 0)
80966:             return JS_FALSE;
80966:         CheckTypeSet(cx, bce, pn->getOp());
78294:         if (pn->isOp(JSOP_EVAL)) {
13504:             EMIT_UINT16_IMM_OP(JSOP_LINENO, pn->pn_pos.begin.lineno);
80966:             if (EmitBlockChain(cx, bce) < 0)
54855:                 return JS_FALSE;
54855:         }
57742:         if (pn->pn_xflags & PNX_SETCALL) {
80966:             if (Emit1(cx, bce, JSOP_SETCALL) < 0)
57742:                 return JS_FALSE;
57742:         }
    1:         break;
    1:       }
    1: 
82024:       case PNK_LEXICALSCOPE:
81588:         ok = EmitLexicalScope(cx, bce, pn);
79378:         break;
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
82024:       case PNK_LET:
80966:         if (!EmitLet(cx, bce, pn))
79378:             return false;
79378:         break;
    1: #endif /* JS_HAS_BLOCK_SCOPE */
    1: #if JS_HAS_GENERATORS
82024:       case PNK_ARRAYPUSH: {
16072:         jsint slot;
16072: 
16072:         /*
80966:          * The array object's stack index is in bce->arrayCompDepth. See below
    1:          * under the array initialiser code generator for array comprehension
    1:          * special casing.
    1:          */
80966:         if (!EmitTree(cx, bce, pn->pn_kid))
80966:             return JS_FALSE;
80966:         slot = AdjustBlockSlot(cx, bce, bce->arrayCompDepth);
16072:         if (slot < 0)
16072:             return JS_FALSE;
78294:         EMIT_UINT16_IMM_OP(pn->getOp(), slot);
16072:         break;
16072:       }
    1: #endif
    1: 
82024:       case PNK_RB:
    1: #if JS_HAS_GENERATORS
82024:       case PNK_ARRAYCOMP:
    1: #endif
    1:         /*
27234:          * Emit code for [a, b, c] that is equivalent to constructing a new
27234:          * array and in source order evaluating each element value and adding
27234:          * it to the array, without invoking latent setters.  We use the
27234:          * JSOP_NEWINIT and JSOP_INITELEM bytecodes to ignore setters and to
27234:          * avoid dup'ing and popping the array as each element is added, as
27234:          * JSOP_SETELEM/JSOP_SETPROP would do.
15279:          */
26959: #if JS_HAS_SHARP_VARS
26959:         sharpnum = -1;
26959:       do_emit_array:
26959: #endif
26959: 
    1: #if JS_HAS_GENERATORS
82024:         if (pn->isKind(PNK_ARRAYCOMP)) {
16072:             uintN saveDepth;
    1: 
80966:             if (!EmitNewInit(cx, bce, JSProto_Array, pn, sharpnum))
58056:                 return JS_FALSE;
58056: 
    1:             /*
82024:              * Pass the new array's stack index to the PNK_ARRAYPUSH case via
82024:              * bce->arrayCompDepth, then simply traverse the PNK_FOR node and
27012:              * its kids under pn2 to generate this comprehension.
    1:              */
80966:             JS_ASSERT(bce->stackDepth > 0);
80966:             saveDepth = bce->arrayCompDepth;
80966:             bce->arrayCompDepth = (uint32) (bce->stackDepth - 1);
80966:             if (!EmitTree(cx, bce, pn->pn_head))
80966:                 return JS_FALSE;
80966:             bce->arrayCompDepth = saveDepth;
    1: 
    1:             /* Emit the usual op needed for decompilation. */
80966:             if (!EmitEndInit(cx, bce, 1))
    1:                 return JS_FALSE;
    1:             break;
    1:         }
    1: #endif /* JS_HAS_GENERATORS */
    1: 
80966:         if (!bce->hasSharps() && !(pn->pn_xflags & PNX_NONCONST) && pn->pn_head &&
80966:             bce->checkSingletonContext()) {
80966:             if (!EmitSingletonInitialiser(cx, bce, pn))
59962:                 return JS_FALSE;
59962:             break;
59962:         }
59962: 
58702:         /* Use the slower NEWINIT for arrays in scripts containing sharps. */
80966:         if (bce->hasSharps()) {
80966:             if (!EmitNewInit(cx, bce, JSProto_Array, pn, sharpnum))
58056:                 return JS_FALSE;
58056:         } else {
80966:             ptrdiff_t off = EmitN(cx, bce, JSOP_NEWARRAY, 3);
58056:             if (off < 0)
58056:                 return JS_FALSE;
80966:             pc = bce->code(off);
58056:             SET_UINT24(pc, pn->pn_count);
58056:         }
58056: 
26959:         pn2 = pn->pn_head;
    1:         for (atomIndex = 0; pn2; atomIndex++, pn2 = pn2->pn_next) {
80966:             if (!EmitNumberOp(cx, atomIndex, bce))
15279:                 return JS_FALSE;
82024:             if (pn2->isKind(PNK_COMMA) && pn2->isArity(PN_NULLARY)) {
80966:                 if (Emit1(cx, bce, JSOP_HOLE) < 0)
    1:                     return JS_FALSE;
    1:             } else {
80966:                 if (!EmitTree(cx, bce, pn2))
80966:                     return JS_FALSE;
80966:             }
80966:             if (Emit1(cx, bce, JSOP_INITELEM) < 0)
    1:                 return JS_FALSE;
26959:         }
26959:         JS_ASSERT(atomIndex == pn->pn_count);
    1: 
27012:         if (pn->pn_xflags & PNX_ENDCOMMA) {
    1:             /* Emit a source note so we know to decompile an extra comma. */
80966:             if (NewSrcNote(cx, bce, SRC_CONTINUE) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
27234:         /*
27234:          * Emit an op to finish the array and, secondarily, to aid in sharp
27234:          * array cleanup (if JS_HAS_SHARP_VARS) and decompilation.
27234:          */
80966:         if (!EmitEndInit(cx, bce, atomIndex))
26959:             return JS_FALSE;
26959:         break;
    1: 
82024:       case PNK_RC: {
26959: #if JS_HAS_SHARP_VARS
26959:         sharpnum = -1;
26959:       do_emit_object:
26959: #endif
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
27012:         if (pn->pn_xflags & PNX_DESTRUCT) {
80966:             ReportCompileErrorNumber(cx, bce->tokenStream(), pn, JSREPORT_ERROR,
80966:                                      JSMSG_BAD_OBJECT_INIT);
11039:             return JS_FALSE;
11039:         }
11039: #endif
59962: 
80966:         if (!bce->hasSharps() && !(pn->pn_xflags & PNX_NONCONST) && pn->pn_head &&
80966:             bce->checkSingletonContext()) {
80966:             if (!EmitSingletonInitialiser(cx, bce, pn))
59962:                 return JS_FALSE;
59962:             break;
59962:         }
59962: 
    1:         /*
27234:          * Emit code for {p:a, '%q':b, 2:c} that is equivalent to constructing
27234:          * a new object and in source order evaluating each property value and
27234:          * adding the property to the object, without invoking latent setters.
27234:          * We use the JSOP_NEWINIT and JSOP_INITELEM/JSOP_INITPROP bytecodes to
27234:          * ignore setters and to avoid dup'ing and popping the object as each
27234:          * property is added, as JSOP_SETELEM/JSOP_SETPROP would do.
    1:          */
80966:         ptrdiff_t offset = bce->next() - bce->base();
80966:         if (!EmitNewInit(cx, bce, JSProto_Object, pn, sharpnum))
32729:             return JS_FALSE;
    1: 
58056:         /*
58056:          * Try to construct the shape of the object as we go, so we can emit a
58056:          * JSOP_NEWOBJECT with the final shape instead.
58056:          */
58056:         JSObject *obj = NULL;
80966:         if (!bce->hasSharps() && bce->compileAndGo()) {
77775:             gc::AllocKind kind = GuessObjectGCKind(pn->pn_count, false);
77817:             obj = NewBuiltinClassInstance(cx, &ObjectClass, kind);
58056:             if (!obj)
58056:                 return JS_FALSE;
58056:         }
58056: 
37685:         uintN methodInits = 0, slowMethodInits = 0;
26959:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
26959:             /* Emit an index for t[2] for later consumption by JSOP_INITELEM. */
    1:             pn3 = pn2->pn_left;
82024:             if (pn3->isKind(PNK_NUMBER)) {
80966:                 if (!EmitNumberOp(cx, pn3->pn_dval, bce))
26959:                     return JS_FALSE;
26959:             }
26959: 
26959:             /* Emit code for the property initializer. */
80966:             if (!EmitTree(cx, bce, pn2->pn_right))
26959:                 return JS_FALSE;
26959: 
78294:             op = pn2->getOp();
26959:             if (op == JSOP_GETTER || op == JSOP_SETTER) {
58056:                 obj = NULL;
80966:                 if (Emit1(cx, bce, op) < 0)
26959:                     return JS_FALSE;
26959:             }
40855: 
26959:             /* Annotate JSOP_INITELEM so we decompile 2:c and not just c. */
82024:             if (pn3->isKind(PNK_NUMBER)) {
58056:                 obj = NULL;
80966:                 if (NewSrcNote(cx, bce, SRC_INITPROP) < 0)
80966:                     return JS_FALSE;
80966:                 if (Emit1(cx, bce, JSOP_INITELEM) < 0)
    1:                     return JS_FALSE;
 8790:             } else {
82024:                 JS_ASSERT(pn3->isKind(PNK_NAME) || pn3->isKind(PNK_STRING));
72579:                 jsatomid index;
80966:                 if (!bce->makeAtomIndex(pn3->pn_atom, &index))
    1:                     return JS_FALSE;
32658: 
37685:                 /* Check whether we can optimize to JSOP_INITMETHOD. */
80631:                 ParseNode *init = pn2->pn_right;
78294:                 bool lambda = init->isOp(JSOP_LAMBDA);
37685:                 if (lambda)
37685:                     ++methodInits;
48676:                 if (op == JSOP_INITPROP && lambda && init->pn_funbox->joinable()) {
58056:                     obj = NULL;
37685:                     op = JSOP_INITMETHOD;
78294:                     pn2->setOp(op);
37685:                 } else {
58056:                     /*
58056:                      * Disable NEWOBJECT on initializers that set __proto__, which has
58056:                      * a non-standard setter on objects.
58056:                      */
58056:                     if (pn3->pn_atom == cx->runtime->atomState.protoAtom)
58056:                         obj = NULL;
37685:                     op = JSOP_INITPROP;
37685:                     if (lambda)
37685:                         ++slowMethodInits;
37685:                 }
37685: 
58056:                 if (obj) {
58056:                     JS_ASSERT(!obj->inDictionaryMode());
69855:                     if (!DefineNativeProperty(cx, obj, ATOM_TO_JSID(pn3->pn_atom),
62411:                                               UndefinedValue(), NULL, NULL,
69855:                                               JSPROP_ENUMERATE, 0, 0)) {
69855:                         return false;
58056:                     }
58056:                     if (obj->inDictionaryMode())
58056:                         obj = NULL;
58056:                 }
58056: 
72579:                 EMIT_INDEX_OP(op, index);
37685:             }
37685:         }
37685: 
80966:         if (bce->funbox && bce->funbox->shouldUnbrand(methodInits, slowMethodInits)) {
58056:             obj = NULL;
80966:             if (Emit1(cx, bce, JSOP_UNBRAND) < 0)
80966:                 return JS_FALSE;
80966:         }
80966:         if (!EmitEndInit(cx, bce, pn->pn_count))
    1:             return JS_FALSE;
58056: 
58056:         if (obj) {
58056:             /*
58056:              * The object survived and has a predictable shape.  Update the original bytecode,
58056:              * as long as we can do so without using a big index prefix/suffix.
58056:              */
80966:             ObjectBox *objbox = bce->parser->newObjectBox(obj);
58056:             if (!objbox)
58056:                 return JS_FALSE;
80966:             unsigned index = bce->objectList.index(objbox);
58056:             if (FitsWithoutBigIndex(index))
58056:                 EMIT_UINT16_IN_PLACE(offset, JSOP_NEWOBJECT, uint16(index));
58056:         }
58056: 
    1:         break;
37685:       }
    1: 
    1: #if JS_HAS_SHARP_VARS
82024:       case PNK_DEFSHARP:
80966:         JS_ASSERT(bce->hasSharps());
26959:         sharpnum = pn->pn_num;
26959:         pn = pn->pn_kid;
82024:         if (pn->isKind(PNK_RB))
26959:             goto do_emit_array;
26959: # if JS_HAS_GENERATORS
82024:         if (pn->isKind(PNK_ARRAYCOMP))
26959:             goto do_emit_array;
26959: # endif
82024:         if (pn->isKind(PNK_RC))
26959:             goto do_emit_object;
26959: 
80966:         if (!EmitTree(cx, bce, pn))
80966:             return JS_FALSE;
80966:         EMIT_UINT16PAIR_IMM_OP(JSOP_DEFSHARP, bce->sharpSlotBase, (jsatomid) sharpnum);
    1:         break;
    1: 
82024:       case PNK_USESHARP:
80966:         JS_ASSERT(bce->hasSharps());
80966:         EMIT_UINT16PAIR_IMM_OP(JSOP_USESHARP, bce->sharpSlotBase, (jsatomid) pn->pn_num);
    1:         break;
    1: #endif /* JS_HAS_SHARP_VARS */
    1: 
82024:       case PNK_NAME:
27012:         /*
27012:          * Cope with a left-over function definition that was replaced by a use
27012:          * of a later function definition of the same name. See FunctionDef and
80634:          * MakeDefIntoUse in Parser.cpp.
27012:          */
78294:         if (pn->isOp(JSOP_NOP))
55512:             break;
80966:         if (!EmitNameOp(cx, bce, pn, JS_FALSE))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
82024:       case PNK_XMLATTR:
82024:       case PNK_XMLSPACE:
82024:       case PNK_XMLTEXT:
82024:       case PNK_XMLCDATA:
82024:       case PNK_XMLCOMMENT:
80966:         JS_ASSERT(!bce->inStrictMode());
80780:         /* FALL THROUGH */
    1: #endif
82024:       case PNK_STRING:
80966:         ok = EmitAtomOp(cx, pn, pn->getOp(), bce);
    1:         break;
    1: 
82024:       case PNK_NUMBER:
80966:         ok = EmitNumberOp(cx, pn->pn_dval, bce);
    1:         break;
    1: 
82024:       case PNK_REGEXP:
78294:         JS_ASSERT(pn->isOp(JSOP_REGEXP));
80966:         ok = EmitIndexOp(cx, JSOP_REGEXP, bce->regexpList.index(pn->pn_objbox), bce);
79378:         break;
 3235: 
    1: #if JS_HAS_XML_SUPPORT
82024:       case PNK_ANYNAME:
    1: #endif
82024:       case PNK_TRUE:
82024:       case PNK_FALSE:
82024:       case PNK_THIS:
82024:       case PNK_NULL:
80966:         if (Emit1(cx, bce, pn->getOp()) < 0)
    1:             return JS_FALSE;
    1:         break;
    1: 
82024:       case PNK_DEBUGGER:
80966:         if (Emit1(cx, bce, JSOP_DEBUGGER) < 0)
    1:             return JS_FALSE;
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
82024:       case PNK_XMLELEM:
82024:       case PNK_XMLLIST:
80966:         JS_ASSERT(!bce->inStrictMode());
82024:         JS_ASSERT(pn->isKind(PNK_XMLLIST) || pn->pn_count != 0);
82024: 
82024:         switch (pn->pn_head ? pn->pn_head->getKind() : PNK_XMLLIST) {
82024:           case PNK_XMLETAGO:
    1:             JS_ASSERT(0);
    1:             /* FALL THROUGH */
82024:           case PNK_XMLPTAGC:
82024:           case PNK_XMLSTAGO:
    1:             break;
    1:           default:
80966:             if (Emit1(cx, bce, JSOP_STARTXML) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
82024:             if (pn2->isKind(PNK_LC) && Emit1(cx, bce, JSOP_STARTXMLEXPR) < 0)
82024:                 return JS_FALSE;
80966:             if (!EmitTree(cx, bce, pn2))
80966:                 return JS_FALSE;
80966:             if (pn2 != pn->pn_head && Emit1(cx, bce, JSOP_ADD) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
27012:         if (pn->pn_xflags & PNX_XMLROOT) {
    1:             if (pn->pn_count == 0) {
82024:                 JS_ASSERT(pn->isKind(PNK_XMLLIST));
    1:                 atom = cx->runtime->atomState.emptyAtom;
72579:                 jsatomid index;
80966:                 if (!bce->makeAtomIndex(atom, &index))
72579:                     return JS_FALSE;
72579:                 EMIT_INDEX_OP(JSOP_STRING, index);
    1:             }
80966:             if (Emit1(cx, bce, pn->getOp()) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: #ifdef DEBUG
    1:         else
    1:             JS_ASSERT(pn->pn_count != 0);
    1: #endif
    1:         break;
    1: 
82024:       case PNK_XMLPTAGC:
82024:       case PNK_XMLSTAGO:
82024:       case PNK_XMLETAGO:
80966:         if (!EmitXMLTag(cx, bce, pn))
79378:             return false;
79378:         break;
    1: 
82024:       case PNK_XMLNAME:
80966:         JS_ASSERT(!bce->inStrictMode());
80780: 
78294:         if (pn->isArity(PN_LIST)) {
    1:             JS_ASSERT(pn->pn_count != 0);
    1:             for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
82024:                 if (pn2->isKind(PNK_LC) && Emit1(cx, bce, JSOP_STARTXMLEXPR) < 0)
82024:                     return JS_FALSE;
80966:                 if (!EmitTree(cx, bce, pn2))
80966:                     return JS_FALSE;
80966:                 if (pn2 != pn->pn_head && Emit1(cx, bce, JSOP_ADD) < 0)
    1:                     return JS_FALSE;
    1:             }
    1:         } else {
78294:             JS_ASSERT(pn->isArity(PN_NULLARY));
78294:             ok = pn->isOp(JSOP_OBJECT)
80966:                  ? EmitObjectOp(cx, pn->pn_objbox, pn->getOp(), bce)
80966:                  : EmitAtomOp(cx, pn, pn->getOp(), bce);
    1:         }
    1:         break;
    1: 
82024:       case PNK_XMLPI:
80966:         if (!EmitXMLProcessingInstruction(cx, bce, pn))
79378:             return false;
79378:         break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:       default:
    1:         JS_ASSERT(0);
    1:     }
    1: 
80966:     /* bce->emitLevel == 1 means we're last on the stack, so finish up. */
80966:     if (ok && bce->emitLevel == 1) {
80966:         if (bce->spanDeps)
80966:             ok = OptimizeSpanDeps(cx, bce);
80966:         if (!UpdateLineNumberNotes(cx, bce, pn->pn_pos.end.lineno))
28739:             return JS_FALSE;
28739:     }
    1: 
    1:     return ok;
    1: }
    1: 
    1: static intN
80966: AllocSrcNote(JSContext *cx, BytecodeEmitter *bce)
80966: {
80966:     jssrcnote *notes = bce->notes();
77950:     jssrcnote *newnotes;
80966:     uintN index = bce->noteCount();
80966:     uintN max = bce->noteLimit();
77950: 
77950:     if (index == max) {
77950:         size_t newlength;
77950:         if (!notes) {
77950:             JS_ASSERT(!index && !max);
77950:             newlength = SRCNOTE_CHUNK_LENGTH;
77950:             newnotes = (jssrcnote *) cx->malloc_(SRCNOTE_SIZE(newlength));
    1:         } else {
77950:             JS_ASSERT(index <= max);
77950:             newlength = max * 2;
77950:             newnotes = (jssrcnote *) cx->realloc_(notes, SRCNOTE_SIZE(newlength));
77950:         }
77950:         if (!newnotes) {
71371:             js_ReportOutOfMemory(cx);
    1:             return -1;
    1:         }
80966:         bce->current->notes = newnotes;
80966:         bce->current->noteLimit = newlength;
80966:     }
80966: 
80966:     bce->current->noteCount = index + 1;
77950:     return (intN)index;
    1: }
    1: 
    1: intN
80966: frontend::NewSrcNote(JSContext *cx, BytecodeEmitter *bce, SrcNoteType type)
    1: {
    1:     intN index, n;
    1:     jssrcnote *sn;
    1:     ptrdiff_t offset, delta, xdelta;
    1: 
    1:     /*
80966:      * Claim a note slot in bce->notes() by growing it if necessary and then
80966:      * incrementing bce->noteCount().
80966:      */
80966:     index = AllocSrcNote(cx, bce);
    1:     if (index < 0)
    1:         return -1;
80966:     sn = &bce->notes()[index];
    1: 
    1:     /*
    1:      * Compute delta from the last annotated bytecode's offset.  If it's too
    1:      * big to fit in sn, allocate one or more xdelta notes and reset sn.
    1:      */
80966:     offset = bce->offset();
80966:     delta = offset - bce->lastNoteOffset();
80966:     bce->current->lastNoteOffset = offset;
    1:     if (delta >= SN_DELTA_LIMIT) {
    1:         do {
    1:             xdelta = JS_MIN(delta, SN_XDELTA_MASK);
    1:             SN_MAKE_XDELTA(sn, xdelta);
    1:             delta -= xdelta;
80966:             index = AllocSrcNote(cx, bce);
    1:             if (index < 0)
    1:                 return -1;
80966:             sn = &bce->notes()[index];
    1:         } while (delta >= SN_DELTA_LIMIT);
    1:     }
    1: 
    1:     /*
    1:      * Initialize type and delta, then allocate the minimum number of notes
    1:      * needed for type's arity.  Usually, we won't need more, but if an offset
80966:      * does take two bytes, SetSrcNoteOffset will grow bce->notes().
    1:      */
    1:     SN_MAKE_NOTE(sn, type, delta);
    1:     for (n = (intN)js_SrcNoteSpec[type].arity; n > 0; n--) {
80966:         if (NewSrcNote(cx, bce, SRC_NULL) < 0)
    1:             return -1;
    1:     }
    1:     return index;
    1: }
    1: 
    1: intN
80966: frontend::NewSrcNote2(JSContext *cx, BytecodeEmitter *bce, SrcNoteType type, ptrdiff_t offset)
    1: {
    1:     intN index;
    1: 
80966:     index = NewSrcNote(cx, bce, type);
    1:     if (index >= 0) {
80966:         if (!SetSrcNoteOffset(cx, bce, index, 0, offset))
    1:             return -1;
    1:     }
    1:     return index;
    1: }
    1: 
    1: intN
80966: frontend::NewSrcNote3(JSContext *cx, BytecodeEmitter *bce, SrcNoteType type, ptrdiff_t offset1,
80631:             ptrdiff_t offset2)
    1: {
    1:     intN index;
    1: 
80966:     index = NewSrcNote(cx, bce, type);
    1:     if (index >= 0) {
80966:         if (!SetSrcNoteOffset(cx, bce, index, 0, offset1))
    1:             return -1;
80966:         if (!SetSrcNoteOffset(cx, bce, index, 1, offset2))
    1:             return -1;
    1:     }
    1:     return index;
    1: }
    1: 
    1: static JSBool
80966: GrowSrcNotes(JSContext *cx, BytecodeEmitter *bce)
80966: {
80966:     size_t newlength = bce->noteLimit() * 2;
80966:     jssrcnote *newnotes = (jssrcnote *) cx->realloc_(bce->notes(), newlength);
77950:     if (!newnotes) {
71371:         js_ReportOutOfMemory(cx);
    1:         return JS_FALSE;
    1:     }
80966:     bce->current->notes = newnotes;
80966:     bce->current->noteLimit = newlength;
    1:     return JS_TRUE;
    1: }
    1: 
    1: jssrcnote *
80966: frontend::AddToSrcNoteDelta(JSContext *cx, BytecodeEmitter *bce, jssrcnote *sn, ptrdiff_t delta)
    1: {
    1:     ptrdiff_t base, limit, newdelta, diff;
    1:     intN index;
    1: 
    1:     /*
80632:      * Called only from OptimizeSpanDeps and FinishTakingSrcNotes to add to
    1:      * main script note deltas, and only by a small positive amount.
    1:      */
80966:     JS_ASSERT(bce->current == &bce->main);
    1:     JS_ASSERT((unsigned) delta < (unsigned) SN_XDELTA_LIMIT);
    1: 
    1:     base = SN_DELTA(sn);
    1:     limit = SN_IS_XDELTA(sn) ? SN_XDELTA_LIMIT : SN_DELTA_LIMIT;
    1:     newdelta = base + delta;
    1:     if (newdelta < limit) {
    1:         SN_SET_DELTA(sn, newdelta);
    1:     } else {
80966:         index = sn - bce->main.notes;
80966:         if (bce->main.noteCount == bce->main.noteLimit) {
80966:             if (!GrowSrcNotes(cx, bce))
    1:                 return NULL;
80966:             sn = bce->main.notes + index;
80966:         }
80966:         diff = bce->main.noteCount - index;
80966:         bce->main.noteCount++;
    1:         memmove(sn + 1, sn, SRCNOTE_SIZE(diff));
    1:         SN_MAKE_XDELTA(sn, delta);
    1:         sn++;
    1:     }
    1:     return sn;
    1: }
    1: 
80786: static JSBool
80966: SetSrcNoteOffset(JSContext *cx, BytecodeEmitter *bce, uintN index, uintN which, ptrdiff_t offset)
    1: {
    1:     jssrcnote *sn;
    1:     ptrdiff_t diff;
    1: 
    1:     if ((jsuword)offset >= (jsuword)((ptrdiff_t)SN_3BYTE_OFFSET_FLAG << 16)) {
80966:         ReportStatementTooLarge(cx, bce);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Find the offset numbered which (i.e., skip exactly which offsets). */
80966:     sn = &bce->notes()[index];
    1:     JS_ASSERT(SN_TYPE(sn) != SRC_XDELTA);
15428:     JS_ASSERT((intN) which < js_SrcNoteSpec[SN_TYPE(sn)].arity);
    1:     for (sn++; which; sn++, which--) {
    1:         if (*sn & SN_3BYTE_OFFSET_FLAG)
    1:             sn += 2;
    1:     }
    1: 
    1:     /* See if the new offset requires three bytes. */
    1:     if (offset > (ptrdiff_t)SN_3BYTE_OFFSET_MASK) {
    1:         /* Maybe this offset was already set to a three-byte value. */
    1:         if (!(*sn & SN_3BYTE_OFFSET_FLAG)) {
    1:             /* Losing, need to insert another two bytes for this offset. */
80966:             index = sn - bce->notes();
    1: 
    1:             /*
77949:              * Test to see if the source note array must grow to accommodate
77949:              * either the first or second byte of additional storage required
77949:              * by this 3-byte offset.
77949:              */
80966:             if (bce->noteCount() + 1 >= bce->noteLimit()) {
80966:                 if (!GrowSrcNotes(cx, bce))
80966:                     return JS_FALSE;
80966:                 sn = bce->notes() + index;
80966:             }
80966:             bce->current->noteCount += 2;
80966: 
80966:             diff = bce->noteCount() - (index + 3);
    1:             JS_ASSERT(diff >= 0);
    1:             if (diff > 0)
    1:                 memmove(sn + 3, sn + 1, SRCNOTE_SIZE(diff));
    1:         }
    1:         *sn++ = (jssrcnote)(SN_3BYTE_OFFSET_FLAG | (offset >> 16));
    1:         *sn++ = (jssrcnote)(offset >> 8);
    1:     }
    1:     *sn = (jssrcnote)offset;
    1:     return JS_TRUE;
    1: }
    1: 
    1: #ifdef DEBUG_notme
    1: #define DEBUG_srcnotesize
    1: #endif
    1: 
    1: #ifdef DEBUG_srcnotesize
    1: #define NBINS 10
    1: static uint32 hist[NBINS];
    1: 
80786: static void
80786: DumpSrcNoteSizeHist()
    1: {
    1:     static FILE *fp;
    1:     int i, n;
    1: 
    1:     if (!fp) {
    1:         fp = fopen("/tmp/srcnotes.hist", "w");
    1:         if (!fp)
    1:             return;
    1:         setvbuf(fp, NULL, _IONBF, 0);
    1:     }
    1:     fprintf(fp, "SrcNote size histogram:\n");
    1:     for (i = 0; i < NBINS; i++) {
    1:         fprintf(fp, "%4u %4u ", JS_BIT(i), hist[i]);
    1:         for (n = (int) JS_HOWMANY(hist[i], 10); n > 0; --n)
    1:             fputc('*', fp);
    1:         fputc('\n', fp);
    1:     }
    1:     fputc('\n', fp);
    1: }
    1: #endif
    1: 
    1: /*
    1:  * Fill in the storage at notes with prolog and main srcnotes; the space at
80966:  * notes was allocated using the BytecodeEmitter::countFinalSourceNotes()
80966:  * method from BytecodeEmitter.h. SO DON'T CHANGE THIS FUNCTION WITHOUT AT
80966:  * LEAST CHECKING WHETHER BytecodeEmitter::countFinalSourceNotes() NEEDS
80634:  * CORRESPONDING CHANGES!
    1:  */
    1: JSBool
80966: frontend::FinishTakingSrcNotes(JSContext *cx, BytecodeEmitter *bce, jssrcnote *notes)
    1: {
    1:     uintN prologCount, mainCount, totalCount;
    1:     ptrdiff_t offset, delta;
    1:     jssrcnote *sn;
    1: 
80966:     JS_ASSERT(bce->current == &bce->main);
80966: 
80966:     prologCount = bce->prolog.noteCount;
80966:     if (prologCount && bce->prolog.currentLine != bce->firstLine) {
80966:         bce->switchToProlog();
80966:         if (NewSrcNote2(cx, bce, SRC_SETLINE, (ptrdiff_t)bce->firstLine) < 0)
80966:             return false;
80966:         prologCount = bce->prolog.noteCount;
80966:         bce->switchToMain();
    1:     } else {
    1:         /*
    1:          * Either no prolog srcnotes, or no line number change over prolog.
    1:          * We don't need a SRC_SETLINE, but we may need to adjust the offset
    1:          * of the first main note, by adding to its delta and possibly even
    1:          * prepending SRC_XDELTA notes to it to account for prolog bytecodes
    1:          * that came at and after the last annotated bytecode.
    1:          */
80966:         offset = bce->prologOffset() - bce->prolog.lastNoteOffset;
    1:         JS_ASSERT(offset >= 0);
80966:         if (offset > 0 && bce->main.noteCount != 0) {
    1:             /* NB: Use as much of the first main note's delta as we can. */
80966:             sn = bce->main.notes;
    1:             delta = SN_IS_XDELTA(sn)
    1:                     ? SN_XDELTA_MASK - (*sn & SN_XDELTA_MASK)
    1:                     : SN_DELTA_MASK - (*sn & SN_DELTA_MASK);
    1:             if (offset < delta)
    1:                 delta = offset;
    1:             for (;;) {
80966:                 if (!AddToSrcNoteDelta(cx, bce, sn, delta))
80632:                     return false;
    1:                 offset -= delta;
    1:                 if (offset == 0)
    1:                     break;
    1:                 delta = JS_MIN(offset, SN_XDELTA_MASK);
80966:                 sn = bce->main.notes;
80966:             }
80966:         }
80966:     }
80966: 
80966:     mainCount = bce->main.noteCount;
    1:     totalCount = prologCount + mainCount;
    1:     if (prologCount)
80966:         memcpy(notes, bce->prolog.notes, SRCNOTE_SIZE(prologCount));
80966:     memcpy(notes + prologCount, bce->main.notes, SRCNOTE_SIZE(mainCount));
    1:     SN_MAKE_TERMINATOR(&notes[totalCount]);
    1: 
80632:     return true;
    1: }
    1: 
 3025: static JSBool
80966: NewTryNote(JSContext *cx, BytecodeEmitter *bce, JSTryNoteKind kind, uintN stackDepth, size_t start,
80631:            size_t end)
    1: {
 1825:     JS_ASSERT((uintN)(uint16)stackDepth == stackDepth);
 1825:     JS_ASSERT(start <= end);
 1825:     JS_ASSERT((size_t)(uint32)start == start);
 1825:     JS_ASSERT((size_t)(uint32)end == end);
 3025: 
80631:     TryNode *tryNode = cx->tempLifoAlloc().new_<TryNode>();
 8296:     if (!tryNode) {
71371:         js_ReportOutOfMemory(cx);
 8296:         return JS_FALSE;
 8296:     }
 3025: 
 3025:     tryNode->note.kind = kind;
 3025:     tryNode->note.stackDepth = (uint16)stackDepth;
 3025:     tryNode->note.start = (uint32)start;
 3025:     tryNode->note.length = (uint32)(end - start);
80966:     tryNode->prev = bce->lastTryNode;
80966:     bce->lastTryNode = tryNode;
80966:     bce->ntrynotes++;
 3025:     return JS_TRUE;
    1: }
    1: 
    1: void
80966: frontend::FinishTakingTryNotes(BytecodeEmitter *bce, JSTryNoteArray *array)
80631: {
80631:     TryNode *tryNode;
 3025:     JSTryNote *tn;
 3025: 
80966:     JS_ASSERT(array->length > 0 && array->length == bce->ntrynotes);
 3235:     tn = array->vector + array->length;
80966:     tryNode = bce->lastTryNode;
 3025:     do {
 3025:         *--tn = tryNode->note;
 3025:     } while ((tryNode = tryNode->prev) != NULL);
 3235:     JS_ASSERT(tn == array->vector);
 3235: }
 3235: 
 3235: /*
 3235:  * Find the index of the given object for code generator.
 3235:  *
 3235:  * Since the emitter refers to each parsed object only once, for the index we
 3235:  * use the number of already indexes objects. We also add the object to a list
 3235:  * to convert the list to a fixed-size array when we complete code generation,
80631:  * see js::CGObjectList::finish below.
 3235:  *
80966:  * Most of the objects go to BytecodeEmitter::objectList but for regexp we use
80966:  * a separated BytecodeEmitter::regexpList. In this way the emitted index can
80966:  * be directly used to store and fetch a reference to a cloned RegExp object
80966:  * that shares the same JSRegExp private data created for the object literal in
80631:  * objbox. We need a cloned object to hold lastIndex and other direct
80631:  * properties that should not be shared among threads sharing a precompiled
80631:  * function or script.
 3235:  *
 3235:  * If the code being compiled is function code, allocate a reserved slot in
 3235:  * the cloned function object that shares its precompiled script with other
 3235:  * cloned function objects and with the compiler-created clone-parent. There
32723:  * are nregexps = script->regexps()->length such reserved slots in each
18308:  * function object cloned from fun->object. NB: during compilation, a funobj
52503:  * slots element must never be allocated, because JSObject::allocSlot could
52503:  * hand out one of the slots that should be given to a regexp clone.
 3235:  *
 3235:  * If the code being compiled is global code, the cloned regexp are stored in
54477:  * fp->vars slot and to protect regexp slots from GC we set fp->nvars to
54477:  * nregexps.
 3235:  *
 3235:  * The slots initially contain undefined or null. We populate them lazily when
 3235:  * JSOP_REGEXP is executed for the first time.
 3235:  *
 3235:  * Why clone regexp objects?  ECMA specifies that when a regular expression
 3235:  * literal is scanned, a RegExp object is created.  In the spec, compilation
 3235:  * and execution happen indivisibly, but in this implementation and many of
 3235:  * its embeddings, code is precompiled early and re-executed in multiple
 3235:  * threads, or using multiple global objects, or both, for efficiency.
 3235:  *
 3235:  * In such cases, naively following ECMA leads to wrongful sharing of RegExp
 3235:  * objects, which makes for collisions on the lastIndex property (especially
41968:  * for global regexps) and on any ad-hoc properties.  Also, __proto__ refers to
41968:  * the pre-compilation prototype, a pigeon-hole problem for instanceof tests.
 3235:  */
27012: uintN
80631: CGObjectList::index(ObjectBox *objbox)
 3235: {
27012:     JS_ASSERT(!objbox->emitLink);
27012:     objbox->emitLink = lastbox;
27012:     lastbox = objbox;
54855:     objbox->index = length++;
54855:     return objbox->index;
 3235: }
 3235: 
 3235: void
80631: CGObjectList::finish(JSObjectArray *array)
80631: {
27012:     JS_ASSERT(length <= INDEX_LIMIT);
27012:     JS_ASSERT(length == array->length);
 3235: 
80631:     JSObject **cursor = array->vector + array->length;
80631:     ObjectBox *objbox = lastbox;
 3235:     do {
 3235:         --cursor;
 3235:         JS_ASSERT(!*cursor);
27012:         *cursor = objbox->object;
27012:     } while ((objbox = objbox->emitLink) != NULL);
 3235:     JS_ASSERT(cursor == array->vector);
 3235: }
48470: 
48470: void
80631: GCConstList::finish(JSConstArray *array)
48470: {
48470:     JS_ASSERT(array->length == list.length());
48470:     Value *src = list.begin(), *srcend = list.end();
48470:     Value *dst = array->vector;
48470:     for (; src != srcend; ++src, ++dst)
48470:         *dst = *src;
48470: }
80632: 
80632: /*
80632:  * We should try to get rid of offsetBias (always 0 or 1, where 1 is
80632:  * JSOP_{NOP,POP}_LENGTH), which is used only by SRC_FOR and SRC_DECL.
80632:  */
80632: JS_FRIEND_DATA(JSSrcNoteSpec) js_SrcNoteSpec[] = {
80632:     {"null",            0,      0,      0},
80632:     {"if",              0,      0,      0},
80632:     {"if-else",         2,      0,      1},
80632:     {"for",             3,      1,      1},
80632:     {"while",           1,      0,      1},
80632:     {"continue",        0,      0,      0},
80632:     {"decl",            1,      1,      1},
80632:     {"pcdelta",         1,      0,      1},
80632:     {"assignop",        0,      0,      0},
80632:     {"cond",            1,      0,      1},
80632:     {"brace",           1,      0,      1},
80632:     {"hidden",          0,      0,      0},
80632:     {"pcbase",          1,      0,     -1},
80632:     {"label",           1,      0,      0},
80632:     {"labelbrace",      1,      0,      0},
80632:     {"endbrace",        0,      0,      0},
80632:     {"break2label",     1,      0,      0},
80632:     {"cont2label",      1,      0,      0},
80632:     {"switch",          2,      0,      1},
80632:     {"funcdef",         1,      0,      0},
80632:     {"catch",           1,      0,      1},
80632:     {"extended",       -1,      0,      0},
80632:     {"newline",         0,      0,      0},
80632:     {"setline",         1,      0,      0},
80632:     {"xdelta",          0,      0,      0},
80632: };
80632: 
80632: JS_FRIEND_API(uintN)
80632: js_SrcNoteLength(jssrcnote *sn)
80632: {
80632:     uintN arity;
80632:     jssrcnote *base;
80632: 
80632:     arity = (intN)js_SrcNoteSpec[SN_TYPE(sn)].arity;
80632:     for (base = sn++; arity; sn++, arity--) {
80632:         if (*sn & SN_3BYTE_OFFSET_FLAG)
80632:             sn += 2;
80632:     }
80632:     return sn - base;
80632: }
80632: 
80632: JS_FRIEND_API(ptrdiff_t)
80632: js_GetSrcNoteOffset(jssrcnote *sn, uintN which)
80632: {
80632:     /* Find the offset numbered which (i.e., skip exactly which offsets). */
80632:     JS_ASSERT(SN_TYPE(sn) != SRC_XDELTA);
80632:     JS_ASSERT((intN) which < js_SrcNoteSpec[SN_TYPE(sn)].arity);
80632:     for (sn++; which; sn++, which--) {
80632:         if (*sn & SN_3BYTE_OFFSET_FLAG)
80632:             sn += 2;
80632:     }
80632:     if (*sn & SN_3BYTE_OFFSET_FLAG) {
80632:         return (ptrdiff_t)(((uint32)(sn[0] & SN_3BYTE_OFFSET_MASK) << 16)
80632:                            | (sn[1] << 8)
80632:                            | sn[2]);
80632:     }
80632:     return (ptrdiff_t)*sn;
80632: }
