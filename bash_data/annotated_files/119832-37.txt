     1: /* vim:set ts=2 sw=2 et cindent: */
 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "prlog.h"
     1: 
     1: #include <stdlib.h>
     1: #include "nsIPrefService.h"
     1: #include "nsIPrefBranch.h"
     1: #include "nsServiceManagerUtils.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsNSSShutDown.h"
     1: #include "nsNTLMAuthModule.h"
     1: #include "nsNativeCharsetUtils.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsString.h"
     1: #include "prsystem.h"
     1: #include "nss.h"
     1: #include "pk11func.h"
     1: #include "md4.h"
     1: 
     1: #ifdef PR_LOGGING
     1: PRLogModuleInfo *gNTLMLog = PR_NewLogModule("NTLM");
     1: 
     1: #define LOG(x) PR_LOG(gNTLMLog, PR_LOG_DEBUG, x)
     1: #define LOG_ENABLED() PR_LOG_TEST(gNTLMLog, PR_LOG_DEBUG)
     1: #else
     1: #define LOG(x)
     1: #endif
     1: 
108991: static void des_makekey(const uint8_t *raw, uint8_t *key);
108991: static void des_encrypt(const uint8_t *key, const uint8_t *src, uint8_t *hash);
108991: static void md5sum(const uint8_t *input, uint32_t inputLen, uint8_t *result);
     1: 
     1: //-----------------------------------------------------------------------------
     1: // this file contains a cross-platform NTLM authentication implementation. it
     1: // is based on documentation from: http://davenport.sourceforge.net/ntlm.html
     1: //-----------------------------------------------------------------------------
     1: 
     1: #define NTLM_NegotiateUnicode               0x00000001
     1: #define NTLM_NegotiateOEM                   0x00000002
     1: #define NTLM_RequestTarget                  0x00000004
     1: #define NTLM_Unknown1                       0x00000008
     1: #define NTLM_NegotiateSign                  0x00000010
     1: #define NTLM_NegotiateSeal                  0x00000020
     1: #define NTLM_NegotiateDatagramStyle         0x00000040
     1: #define NTLM_NegotiateLanManagerKey         0x00000080
     1: #define NTLM_NegotiateNetware               0x00000100
     1: #define NTLM_NegotiateNTLMKey               0x00000200
     1: #define NTLM_Unknown2                       0x00000400
     1: #define NTLM_Unknown3                       0x00000800
     1: #define NTLM_NegotiateDomainSupplied        0x00001000
     1: #define NTLM_NegotiateWorkstationSupplied   0x00002000
     1: #define NTLM_NegotiateLocalCall             0x00004000
     1: #define NTLM_NegotiateAlwaysSign            0x00008000
     1: #define NTLM_TargetTypeDomain               0x00010000
     1: #define NTLM_TargetTypeServer               0x00020000
     1: #define NTLM_TargetTypeShare                0x00040000
     1: #define NTLM_NegotiateNTLM2Key              0x00080000
     1: #define NTLM_RequestInitResponse            0x00100000
     1: #define NTLM_RequestAcceptResponse          0x00200000
     1: #define NTLM_RequestNonNTSessionKey         0x00400000
     1: #define NTLM_NegotiateTargetInfo            0x00800000
     1: #define NTLM_Unknown4                       0x01000000
     1: #define NTLM_Unknown5                       0x02000000
     1: #define NTLM_Unknown6                       0x04000000
     1: #define NTLM_Unknown7                       0x08000000
     1: #define NTLM_Unknown8                       0x10000000
     1: #define NTLM_Negotiate128                   0x20000000
     1: #define NTLM_NegotiateKeyExchange           0x40000000
     1: #define NTLM_Negotiate56                    0x80000000
     1: 
     1: // we send these flags with our type 1 message
     1: #define NTLM_TYPE1_FLAGS      \
     1:   (NTLM_NegotiateUnicode |    \
     1:    NTLM_NegotiateOEM |        \
     1:    NTLM_RequestTarget |       \
     1:    NTLM_NegotiateNTLMKey |    \
     1:    NTLM_NegotiateAlwaysSign | \
     1:    NTLM_NegotiateNTLM2Key)
     1: 
     1: static const char NTLM_SIGNATURE[] = "NTLMSSP";
     1: static const char NTLM_TYPE1_MARKER[] = { 0x01, 0x00, 0x00, 0x00 };
     1: static const char NTLM_TYPE2_MARKER[] = { 0x02, 0x00, 0x00, 0x00 };
     1: static const char NTLM_TYPE3_MARKER[] = { 0x03, 0x00, 0x00, 0x00 };
     1: 
     1: #define NTLM_TYPE1_HEADER_LEN 32
     1: #define NTLM_TYPE2_HEADER_LEN 32
     1: #define NTLM_TYPE3_HEADER_LEN 64
     1: 
     1: #define LM_HASH_LEN 16
     1: #define LM_RESP_LEN 24
     1: 
     1: #define NTLM_HASH_LEN 16
     1: #define NTLM_RESP_LEN 24
     1: 
     1: //-----------------------------------------------------------------------------
     1: 
 79445: static bool SendLM()
     1: {
     1:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
     1:   if (!prefs)
 80486:     return false;
     1: 
 79445:   bool val;
     1:   nsresult rv = prefs->GetBoolPref("network.ntlm.send-lm-response", &val);
     1:   return NS_SUCCEEDED(rv) && val;
     1: }
     1: 
     1: //-----------------------------------------------------------------------------
     1: 
     1: #ifdef PR_LOGGING
     1: 
     1: /**
     1:  * Prints a description of flags to the NSPR Log, if enabled.
     1:  */
108991: static void LogFlags(uint32_t flags)
     1: {
     1:   if (!LOG_ENABLED())
     1:     return;
     1: #define TEST(_flag) \
     1:   if (flags & NTLM_ ## _flag) \
     1:     PR_LogPrint("    0x%08x (" # _flag ")\n", NTLM_ ## _flag)
     1: 
     1:   TEST(NegotiateUnicode);
     1:   TEST(NegotiateOEM);
     1:   TEST(RequestTarget);
     1:   TEST(Unknown1);
     1:   TEST(NegotiateSign);
     1:   TEST(NegotiateSeal);
     1:   TEST(NegotiateDatagramStyle);
     1:   TEST(NegotiateLanManagerKey);
     1:   TEST(NegotiateNetware);
     1:   TEST(NegotiateNTLMKey);
     1:   TEST(Unknown2);
     1:   TEST(Unknown3);
     1:   TEST(NegotiateDomainSupplied);
     1:   TEST(NegotiateWorkstationSupplied);
     1:   TEST(NegotiateLocalCall);
     1:   TEST(NegotiateAlwaysSign);
     1:   TEST(TargetTypeDomain);
     1:   TEST(TargetTypeServer);
     1:   TEST(TargetTypeShare);
     1:   TEST(NegotiateNTLM2Key);
     1:   TEST(RequestInitResponse);
     1:   TEST(RequestAcceptResponse);
     1:   TEST(RequestNonNTSessionKey);
     1:   TEST(NegotiateTargetInfo);
     1:   TEST(Unknown4);
     1:   TEST(Unknown5);
     1:   TEST(Unknown6);
     1:   TEST(Unknown7);
     1:   TEST(Unknown8);
     1:   TEST(Negotiate128);
     1:   TEST(NegotiateKeyExchange);
     1:   TEST(Negotiate56);
     1: 
     1: #undef TEST
     1: }
     1: 
     1: /**
     1:  * Prints a hexdump of buf to the NSPR Log, if enabled.
     1:  * @param tag Description of the data, will be printed in front of the data
     1:  * @param buf the data to print
     1:  * @param bufLen length of the data
     1:  */
     1: static void
108991: LogBuf(const char *tag, const uint8_t *buf, uint32_t bufLen)
     1: {
     1:   int i;
     1: 
     1:   if (!LOG_ENABLED())
     1:     return;
     1: 
     1:   PR_LogPrint("%s =\n", tag);
     1:   char line[80];
     1:   while (bufLen > 0)
     1:   {
     1:     int count = bufLen;
     1:     if (count > 8)
     1:       count = 8;
     1: 
     1:     strcpy(line, "    ");
     1:     for (i=0; i<count; ++i)
     1:     {
     1:       int len = strlen(line);
     1:       PR_snprintf(line + len, sizeof(line) - len, "0x%02x ", int(buf[i]));
     1:     }
     1:     for (; i<8; ++i)
     1:     {
     1:       int len = strlen(line);
     1:       PR_snprintf(line + len, sizeof(line) - len, "     ");
     1:     }
     1: 
     1:     int len = strlen(line);
     1:     PR_snprintf(line + len, sizeof(line) - len, "   ");
     1:     for (i=0; i<count; ++i)
     1:     {
     1:       len = strlen(line);
     1:       if (isprint(buf[i]))
     1:         PR_snprintf(line + len, sizeof(line) - len, "%c", buf[i]);
     1:       else
     1:         PR_snprintf(line + len, sizeof(line) - len, ".");
     1:     }
     1:     PR_LogPrint("%s\n", line);
     1: 
     1:     bufLen -= count;
     1:     buf += count;
     1:   }
     1: }
     1: 
     1: #include "plbase64.h"
     1: #include "prmem.h"
     1: /**
     1:  * Print base64-encoded token to the NSPR Log.
     1:  * @param name Description of the token, will be printed in front
     1:  * @param token The token to print
     1:  * @param tokenLen length of the data in token
     1:  */
108991: static void LogToken(const char *name, const void *token, uint32_t tokenLen)
     1: {
     1:   if (!LOG_ENABLED())
     1:     return;
     1: 
119832:   char *b64data = PL_Base64Encode((const char *) token, tokenLen, NULL);
     1:   if (b64data)
     1:   {
     1:     PR_LogPrint("%s: %s\n", name, b64data);
     1:     PR_Free(b64data);
     1:   }
     1: }
     1: 
     1: #else
     1: #define LogFlags(x)
     1: #define LogBuf(a,b,c)
     1: #define LogToken(a,b,c)
     1: 
     1: #endif // PR_LOGGING
     1: 
     1: //-----------------------------------------------------------------------------
     1: 
     1: // byte order swapping
     1: #define SWAP16(x) ((((x) & 0xff) << 8) | (((x) >> 8) & 0xff))
     1: #define SWAP32(x) ((SWAP16((x) & 0xffff) << 16) | (SWAP16((x) >> 16)))
     1: 
     1: static void *
108991: WriteBytes(void *buf, const void *data, uint32_t dataLen)
     1: {
     1:   memcpy(buf, data, dataLen);
108991:   return (uint8_t *) buf + dataLen;
     1: }
     1: 
     1: static void *
108991: WriteDWORD(void *buf, uint32_t dword)
     1: {
     1: #ifdef IS_BIG_ENDIAN 
     1:   // NTLM uses little endian on the wire
     1:   dword = SWAP32(dword);
     1: #endif
     1:   return WriteBytes(buf, &dword, sizeof(dword));
     1: }
     1: 
     1: static void *
108991: WriteSecBuf(void *buf, uint16_t length, uint32_t offset)
     1: {
     1: #ifdef IS_BIG_ENDIAN
     1:   length = SWAP16(length);
     1:   offset = SWAP32(offset);
     1: #endif
     1:   buf = WriteBytes(buf, &length, sizeof(length));
     1:   buf = WriteBytes(buf, &length, sizeof(length));
     1:   buf = WriteBytes(buf, &offset, sizeof(offset));
     1:   return buf;
     1: }
     1: 
     1: #ifdef IS_BIG_ENDIAN
     1: /**
     1:  * WriteUnicodeLE copies a unicode string from one buffer to another.  The
     1:  * resulting unicode string is in little-endian format.  The input string is
     1:  * assumed to be in the native endianness of the local machine.  It is safe
     1:  * to pass the same buffer as both input and output, which is a handy way to
     1:  * convert the unicode buffer to little-endian on big-endian platforms.
     1:  */
     1: static void *
108991: WriteUnicodeLE(void *buf, const PRUnichar *str, uint32_t strLen)
     1: {
     1:   // convert input string from BE to LE
108991:   uint8_t *cursor = (uint8_t *) buf,
108991:           *input  = (uint8_t *) str;
108991:   for (uint32_t i=0; i<strLen; ++i, input+=2, cursor+=2)
     1:   {
     1:     // allow for the case where |buf == str|
108991:     uint8_t temp = input[0];
     1:     cursor[0] = input[1];
     1:     cursor[1] = temp;
     1:   }
     1:   return buf;
     1: }
     1: #endif
     1: 
108991: static uint16_t
108991: ReadUint16(const uint8_t *&buf)
     1: {
108991:   uint16_t x = ((uint16_t) buf[0]) | ((uint16_t) buf[1] << 8);
     1:   buf += sizeof(x);
     1:   return x;
     1: }
     1: 
108991: static uint32_t
108991: ReadUint32(const uint8_t *&buf)
     1: {
108991:   uint32_t x = ( (uint32_t) buf[0])        |
108991:                (((uint32_t) buf[1]) << 8)  |
108991:                (((uint32_t) buf[2]) << 16) |
108991:                (((uint32_t) buf[3]) << 24);
     1:   buf += sizeof(x);
     1:   return x;
     1: }
     1: 
     1: //-----------------------------------------------------------------------------
     1: 
     1: static void
     1: ZapBuf(void *buf, size_t bufLen)
     1: {
     1:   memset(buf, 0, bufLen);
     1: }
     1: 
     1: static void
     1: ZapString(nsCString &s)
     1: {
     1:   ZapBuf(s.BeginWriting(), s.Length());
     1: }
     1: 
     1: static void
     1: ZapString(nsString &s)
     1: {
     1:   ZapBuf(s.BeginWriting(), s.Length() * 2);
     1: }
     1: 
     1: static const unsigned char LM_MAGIC[] = "KGS!@#$%";
     1: 
     1: /**
     1:  * LM_Hash computes the LM hash of the given password.
     1:  *
     1:  * @param password
     1:  *        null-terminated unicode password.
     1:  * @param hash
     1:  *        16-byte result buffer
     1:  */
     1: static void
     1: LM_Hash(const nsString &password, unsigned char *hash)
     1: {
     1:   // convert password to OEM character set.  we'll just use the native
     1:   // filesystem charset.
110974:   nsAutoCString passbuf;
     1:   NS_CopyUnicodeToNative(password, passbuf);
     1:   ToUpperCase(passbuf);
108991:   uint32_t n = passbuf.Length();
     1:   passbuf.SetLength(14);
108991:   for (uint32_t i=n; i<14; ++i)
     1:     passbuf.SetCharAt('\0', i);
     1: 
     1:   unsigned char k1[8], k2[8];
     1:   des_makekey((const unsigned char *) passbuf.get()    , k1);
     1:   des_makekey((const unsigned char *) passbuf.get() + 7, k2);
     1:   ZapString(passbuf);
     1: 
     1:   // use password keys to hash LM magic string twice.
     1:   des_encrypt(k1, LM_MAGIC, hash);
     1:   des_encrypt(k2, LM_MAGIC, hash + 8);
     1: }
     1: 
     1: /**
     1:  * NTLM_Hash computes the NTLM hash of the given password.
     1:  *
     1:  * @param password
     1:  *        null-terminated unicode password.
     1:  * @param hash
     1:  *        16-byte result buffer
     1:  */
     1: static void
     1: NTLM_Hash(const nsString &password, unsigned char *hash)
     1: {
108991:   uint32_t len = password.Length();
108991:   uint8_t *passbuf;
     1:   
     1: #ifdef IS_BIG_ENDIAN
108991:   passbuf = (uint8_t *) malloc(len * 2);
     1:   WriteUnicodeLE(passbuf, password.get(), len);
     1: #else
108991:   passbuf = (uint8_t *) password.get();
     1: #endif
     1: 
     1:   md4sum(passbuf, len * 2, hash);
     1: 
     1: #ifdef IS_BIG_ENDIAN
     1:   ZapBuf(passbuf, len * 2);
     1:   free(passbuf);
     1: #endif
     1: }
     1: 
     1: //-----------------------------------------------------------------------------
     1: 
     1: /** 
     1:  * LM_Response generates the LM response given a 16-byte password hash and the
     1:  * challenge from the Type-2 message.
     1:  *
     1:  * @param hash
     1:  *        16-byte password hash
     1:  * @param challenge
     1:  *        8-byte challenge from Type-2 message
     1:  * @param response
     1:  *        24-byte buffer to contain the LM response upon return
     1:  */
     1: static void
108991: LM_Response(const uint8_t *hash, const uint8_t *challenge, uint8_t *response)
     1: {
108991:   uint8_t keybytes[21], k1[8], k2[8], k3[8];
     1: 
     1:   memcpy(keybytes, hash, 16);
     1:   ZapBuf(keybytes + 16, 5);
     1: 
     1:   des_makekey(keybytes     , k1);
     1:   des_makekey(keybytes +  7, k2);
     1:   des_makekey(keybytes + 14, k3);
     1: 
     1:   des_encrypt(k1, challenge, response);
     1:   des_encrypt(k2, challenge, response + 8);
     1:   des_encrypt(k3, challenge, response + 16);
     1: }
     1: 
     1: //-----------------------------------------------------------------------------
     1: 
     1: static nsresult
108991: GenerateType1Msg(void **outBuf, uint32_t *outLen)
     1: {
     1:   //
     1:   // verify that bufLen is sufficient
     1:   //
     1:   *outLen = NTLM_TYPE1_HEADER_LEN;
     1:   *outBuf = nsMemory::Alloc(*outLen);
     1:   if (!*outBuf)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   //
     1:   // write out type 1 msg
     1:   //
     1:   void *cursor = *outBuf;
     1: 
     1:   // 0 : signature
     1:   cursor = WriteBytes(cursor, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));
     1: 
     1:   // 8 : marker
     1:   cursor = WriteBytes(cursor, NTLM_TYPE1_MARKER, sizeof(NTLM_TYPE1_MARKER));
     1: 
     1:   // 12 : flags
     1:   cursor = WriteDWORD(cursor, NTLM_TYPE1_FLAGS);
     1: 
     1:   //
     1:   // NOTE: it is common for the domain and workstation fields to be empty.
     1:   //       this is true of Win2k clients, and my guess is that there is
     1:   //       little utility to sending these strings before the charset has
     1:   //       been negotiated.  we follow suite -- anyways, it doesn't hurt
     1:   //       to save some bytes on the wire ;-)
     1:   //
     1: 
     1:   // 16 : supplied domain security buffer (empty)
     1:   cursor = WriteSecBuf(cursor, 0, 0);
     1: 
     1:   // 24 : supplied workstation security buffer (empty)
     1:   cursor = WriteSecBuf(cursor, 0, 0);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: struct Type2Msg
     1: {
108991:   uint32_t    flags;         // NTLM_Xxx bitwise combination
108991:   uint8_t     challenge[8];  // 8 byte challenge
     1:   const void *target;        // target string (type depends on flags)
108991:   uint32_t    targetLen;     // target length in bytes
     1: };
     1: 
     1: static nsresult
108991: ParseType2Msg(const void *inBuf, uint32_t inLen, Type2Msg *msg)
     1: {
     1:   // make sure inBuf is long enough to contain a meaningful type2 msg.
     1:   //
     1:   // 0  NTLMSSP Signature
     1:   // 8  NTLM Message Type
     1:   // 12 Target Name
     1:   // 20 Flags
     1:   // 24 Challenge
     1:   // 32 end of header, start of optional data blocks
     1:   //
     1:   if (inLen < NTLM_TYPE2_HEADER_LEN)
     1:     return NS_ERROR_UNEXPECTED;
     1: 
108991:   const uint8_t *cursor = (const uint8_t *) inBuf;
     1: 
     1:   // verify NTLMSSP signature
     1:   if (memcmp(cursor, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE)) != 0)
     1:     return NS_ERROR_UNEXPECTED;
 30825: 
     1:   cursor += sizeof(NTLM_SIGNATURE);
     1: 
     1:   // verify Type-2 marker
     1:   if (memcmp(cursor, NTLM_TYPE2_MARKER, sizeof(NTLM_TYPE2_MARKER)) != 0)
     1:     return NS_ERROR_UNEXPECTED;
 30825: 
     1:   cursor += sizeof(NTLM_TYPE2_MARKER);
     1: 
 30825:   // Read target name security buffer: ...
 30825:   // ... read target length.
108991:   uint32_t targetLen = ReadUint16(cursor);
 30825:   // ... skip next 16-bit "allocated space" value.
 30825:   ReadUint16(cursor);
 30825:   // ... read offset from inBuf.
108991:   uint32_t offset = ReadUint32(cursor);
 30825:   // Check the offset / length combo is in range of the input buffer, including
 30825:   // integer overflow checking.
 30825:   if (NS_LIKELY(offset < offset + targetLen && offset + targetLen <= inLen)) {
 30825:     msg->targetLen = targetLen;
108991:     msg->target = ((const uint8_t *) inBuf) + offset;
 30825:   }
 30825:   else
 30825:   {
 30825:     // Do not error out, for (conservative) backward compatibility.
 30825:     msg->targetLen = 0;
119832:     msg->target = NULL;
 30825:   }
     1: 
     1:   // read flags
     1:   msg->flags = ReadUint32(cursor);
     1: 
     1:   // read challenge
     1:   memcpy(msg->challenge, cursor, sizeof(msg->challenge));
     1:   cursor += sizeof(msg->challenge);
     1: 
     1: 
     1:   LOG(("NTLM type 2 message:\n"));
108991:   LogBuf("target", (const uint8_t *) msg->target, msg->targetLen);
108991:   LogBuf("flags", (const uint8_t *) &msg->flags, 4);
     1:   LogFlags(msg->flags);
     1:   LogBuf("challenge", msg->challenge, sizeof(msg->challenge));
     1: 
     1:   // we currently do not implement LMv2/NTLMv2 or NTLM2 responses,
     1:   // so we can ignore target information.  we may want to enable
     1:   // support for these alternate mechanisms in the future.
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: GenerateType3Msg(const nsString &domain,
     1:                  const nsString &username,
     1:                  const nsString &password,
     1:                  const void     *inBuf,
108991:                  uint32_t        inLen,
     1:                  void          **outBuf,
108991:                  uint32_t       *outLen)
     1: {
     1:   // inBuf contains Type-2 msg (the challenge) from server
     1: 
     1:   nsresult rv;
     1:   Type2Msg msg;
     1: 
     1:   rv = ParseType2Msg(inBuf, inLen, &msg);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 79445:   bool unicode = (msg.flags & NTLM_NegotiateUnicode);
     1: 
     1:   // temporary buffers for unicode strings
     1: #ifdef IS_BIG_ENDIAN
     1:   nsAutoString ucsDomainBuf, ucsUserBuf;
     1: #endif
     1:   nsAutoString ucsHostBuf; 
     1:   // temporary buffers for oem strings
110974:   nsAutoCString oemDomainBuf, oemUserBuf, oemHostBuf;
     1:   // pointers and lengths for the string buffers; encoding is unicode if
     1:   // the "negotiate unicode" flag was set in the Type-2 message.
     1:   const void *domainPtr, *userPtr, *hostPtr;
108991:   uint32_t domainLen, userLen, hostLen;
     1: 
     1:   //
     1:   // get domain name
     1:   //
     1:   if (unicode)
     1:   {
     1: #ifdef IS_BIG_ENDIAN
     1:     ucsDomainBuf = domain;
     1:     domainPtr = ucsDomainBuf.get();
     1:     domainLen = ucsDomainBuf.Length() * 2;
     1:     WriteUnicodeLE((void *) domainPtr, (const PRUnichar *) domainPtr,
     1:                    ucsDomainBuf.Length());
     1: #else
     1:     domainPtr = domain.get();
     1:     domainLen = domain.Length() * 2;
     1: #endif
     1:   }
     1:   else
     1:   {
     1:     NS_CopyUnicodeToNative(domain, oemDomainBuf);
     1:     domainPtr = oemDomainBuf.get();
     1:     domainLen = oemDomainBuf.Length();
     1:   }
     1: 
     1:   //
     1:   // get user name
     1:   //
     1:   if (unicode)
     1:   {
     1: #ifdef IS_BIG_ENDIAN
     1:     ucsUserBuf = username;
     1:     userPtr = ucsUserBuf.get();
     1:     userLen = ucsUserBuf.Length() * 2;
     1:     WriteUnicodeLE((void *) userPtr, (const PRUnichar *) userPtr,
     1:                    ucsUserBuf.Length());
     1: #else
     1:     userPtr = username.get();
     1:     userLen = username.Length() * 2;
     1: #endif
     1:   }
     1:   else
     1:   {
     1:     NS_CopyUnicodeToNative(username, oemUserBuf);
     1:     userPtr = oemUserBuf.get();
     1:     userLen = oemUserBuf.Length();
     1:   }
     1: 
     1:   //
     1:   // get workstation name (use local machine's hostname)
     1:   //
     1:   char hostBuf[SYS_INFO_BUFFER_LENGTH];
     1:   if (PR_GetSystemInfo(PR_SI_HOSTNAME, hostBuf, sizeof(hostBuf)) == PR_FAILURE)
     1:     return NS_ERROR_UNEXPECTED;
     1:   hostLen = strlen(hostBuf);
     1:   if (unicode)
     1:   {
     1:     // hostname is ASCII, so we can do a simple zero-pad expansion:
     1:     CopyASCIItoUTF16(nsDependentCString(hostBuf, hostLen), ucsHostBuf);
     1:     hostPtr = ucsHostBuf.get();
     1:     hostLen = ucsHostBuf.Length() * 2;
     1: #ifdef IS_BIG_ENDIAN
     1:     WriteUnicodeLE((void *) hostPtr, (const PRUnichar *) hostPtr,
     1:                    ucsHostBuf.Length());
     1: #endif
     1:   }
     1:   else
     1:     hostPtr = hostBuf;
     1: 
     1:   //
     1:   // now that we have generated all of the strings, we can allocate outBuf.
     1:   //
     1:   *outLen = NTLM_TYPE3_HEADER_LEN + hostLen + domainLen + userLen +
     1:             LM_RESP_LEN + NTLM_RESP_LEN;
     1:   *outBuf = nsMemory::Alloc(*outLen);
     1:   if (!*outBuf)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   //
     1:   // next, we compute the LM and NTLM responses.
     1:   //
108991:   uint8_t lmResp[LM_RESP_LEN], ntlmResp[NTLM_RESP_LEN], ntlmHash[NTLM_HASH_LEN];
     1:   if (msg.flags & NTLM_NegotiateNTLM2Key)
     1:   {
     1:     // compute NTLM2 session response
108991:     uint8_t sessionHash[16], temp[16];
     1: 
     1:     PK11_GenerateRandom(lmResp, 8);
     1:     memset(lmResp + 8, 0, LM_RESP_LEN - 8);
     1: 
     1:     memcpy(temp, msg.challenge, 8);
     1:     memcpy(temp + 8, lmResp, 8);
     1:     md5sum(temp, 16, sessionHash);
     1: 
     1:     NTLM_Hash(password, ntlmHash);
     1:     LM_Response(ntlmHash, sessionHash, ntlmResp);
     1:   }
     1:   else
     1:   {
     1:     NTLM_Hash(password, ntlmHash);
     1:     LM_Response(ntlmHash, msg.challenge, ntlmResp);
     1: 
     1:     if (SendLM())
     1:     {
108991:       uint8_t lmHash[LM_HASH_LEN];
     1:       LM_Hash(password, lmHash);
     1:       LM_Response(lmHash, msg.challenge, lmResp);
     1:     }
     1:     else
     1:     {
     1:       // According to http://davenport.sourceforge.net/ntlm.html#ntlmVersion2,
     1:       // the correct way to not send the LM hash is to send the NTLM hash twice
     1:       // in both the LM and NTLM response fields.
     1:       LM_Response(ntlmHash, msg.challenge, lmResp);
     1:     }
     1:   }
     1: 
     1:   //
     1:   // finally, we assemble the Type-3 msg :-)
     1:   //
     1:   void *cursor = *outBuf;
108991:   uint32_t offset;
     1: 
     1:   // 0 : signature
     1:   cursor = WriteBytes(cursor, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));
     1: 
     1:   // 8 : marker
     1:   cursor = WriteBytes(cursor, NTLM_TYPE3_MARKER, sizeof(NTLM_TYPE3_MARKER));
     1: 
     1:   // 12 : LM response sec buf
     1:   offset = NTLM_TYPE3_HEADER_LEN + domainLen + userLen + hostLen;
     1:   cursor = WriteSecBuf(cursor, LM_RESP_LEN, offset);
108991:   memcpy((uint8_t *) *outBuf + offset, lmResp, LM_RESP_LEN);
     1: 
     1:   // 20 : NTLM response sec buf
     1:   offset += LM_RESP_LEN;
     1:   cursor = WriteSecBuf(cursor, NTLM_RESP_LEN, offset);
108991:   memcpy((uint8_t *) *outBuf + offset, ntlmResp, NTLM_RESP_LEN);
     1: 
     1:   // 28 : domain name sec buf
     1:   offset = NTLM_TYPE3_HEADER_LEN;
     1:   cursor = WriteSecBuf(cursor, domainLen, offset);
108991:   memcpy((uint8_t *) *outBuf + offset, domainPtr, domainLen);
     1: 
     1:   // 36 : user name sec buf
     1:   offset += domainLen;
     1:   cursor = WriteSecBuf(cursor, userLen, offset);
108991:   memcpy((uint8_t *) *outBuf + offset, userPtr, userLen);
     1: 
     1:   // 44 : workstation (host) name sec buf
     1:   offset += userLen;
     1:   cursor = WriteSecBuf(cursor, hostLen, offset);
108991:   memcpy((uint8_t *) *outBuf + offset, hostPtr, hostLen);
     1: 
     1:   // 52 : session key sec buf (not used)
     1:   cursor = WriteSecBuf(cursor, 0, 0);
     1: 
     1:   // 60 : negotiated flags
     1:   cursor = WriteDWORD(cursor, msg.flags & NTLM_TYPE1_FLAGS);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //-----------------------------------------------------------------------------
     1: 
     1: NS_IMPL_ISUPPORTS1(nsNTLMAuthModule, nsIAuthModule)
     1: 
     1: nsNTLMAuthModule::~nsNTLMAuthModule()
     1: {
     1:   ZapString(mPassword);
     1: }
     1: 
     1: nsresult
     1: nsNTLMAuthModule::InitTest()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   //
     1:   // disable NTLM authentication when FIPS mode is enabled.
     1:   //
     1:   return PK11_IsFIPS() ? NS_ERROR_NOT_AVAILABLE : NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNTLMAuthModule::Init(const char      *serviceName,
108991:                        uint32_t         serviceFlags,
     1:                        const PRUnichar *domain,
     1:                        const PRUnichar *username,
     1:                        const PRUnichar *password)
     1: {
     1:   NS_ASSERTION(serviceFlags == nsIAuthModule::REQ_DEFAULT, "unexpected service flags");
     1: 
     1:   mDomain = domain;
     1:   mUsername = username;
     1:   mPassword = password;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNTLMAuthModule::GetNextToken(const void *inToken,
108991:                                uint32_t    inTokenLen,
     1:                                void      **outToken,
108991:                                uint32_t   *outTokenLen)
     1: {
     1:   nsresult rv;
     1:   nsNSSShutDownPreventionLock locker;
     1:   //
     1:   // disable NTLM authentication when FIPS mode is enabled.
     1:   //
     1:   if (PK11_IsFIPS())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   // if inToken is non-null, then assume it contains a type 2 message...
     1:   if (inToken)
     1:   {
     1:     LogToken("in-token", inToken, inTokenLen);
     1:     rv = GenerateType3Msg(mDomain, mUsername, mPassword, inToken,
     1:                           inTokenLen, outToken, outTokenLen);
     1:   }
     1:   else
     1:   {
     1:     rv = GenerateType1Msg(outToken, outTokenLen);
     1:   }
     1: 
 17017: #ifdef PR_LOGGING
     1:   if (NS_SUCCEEDED(rv))
     1:     LogToken("out-token", *outToken, *outTokenLen);
 17017: #endif
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNTLMAuthModule::Unwrap(const void *inToken,
108991:                         uint32_t    inTokenLen,
     1:                         void      **outToken,
108991:                         uint32_t   *outTokenLen)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNTLMAuthModule::Wrap(const void *inToken,
108991:                        uint32_t    inTokenLen,
 79445:                        bool        confidential,
     1:                        void      **outToken,
108991:                        uint32_t   *outTokenLen)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
106571: NS_IMETHODIMP
108991: nsNTLMAuthModule::GetModuleProperties(uint32_t *flags)
106571: {
106571:     *flags = 0;
106571:     return NS_OK;
106571: }
106571: 
     1: //-----------------------------------------------------------------------------
     1: // DES support code
     1: 
     1: // set odd parity bit (in least significant bit position)
108991: static uint8_t
108991: des_setkeyparity(uint8_t x)
     1: {
     1:   if ((((x >> 7) ^ (x >> 6) ^ (x >> 5) ^
     1:         (x >> 4) ^ (x >> 3) ^ (x >> 2) ^
     1:         (x >> 1)) & 0x01) == 0)
     1:     x |= 0x01;
     1:   else
     1:     x &= 0xfe;
     1:   return x;
     1: }
     1: 
     1: // build 64-bit des key from 56-bit raw key
     1: static void
108991: des_makekey(const uint8_t *raw, uint8_t *key)
     1: {
     1:   key[0] = des_setkeyparity(raw[0]);
     1:   key[1] = des_setkeyparity((raw[0] << 7) | (raw[1] >> 1));
     1:   key[2] = des_setkeyparity((raw[1] << 6) | (raw[2] >> 2));
     1:   key[3] = des_setkeyparity((raw[2] << 5) | (raw[3] >> 3));
     1:   key[4] = des_setkeyparity((raw[3] << 4) | (raw[4] >> 4));
     1:   key[5] = des_setkeyparity((raw[4] << 3) | (raw[5] >> 5));
     1:   key[6] = des_setkeyparity((raw[5] << 2) | (raw[6] >> 6));
     1:   key[7] = des_setkeyparity((raw[6] << 1));
     1: }
     1: 
     1: // run des encryption algorithm (using NSS)
     1: static void
108991: des_encrypt(const uint8_t *key, const uint8_t *src, uint8_t *hash)
     1: {
     1:   CK_MECHANISM_TYPE cipherMech = CKM_DES_ECB;
106838:   PK11SlotInfo *slot = nullptr;
106838:   PK11SymKey *symkey = nullptr;
106838:   PK11Context *ctxt = nullptr;
106838:   SECItem keyItem, *param = nullptr;
     1:   SECStatus rv;
     1:   unsigned int n;
     1:   
106838:   slot = PK11_GetBestSlot(cipherMech, nullptr);
     1:   if (!slot)
     1:   {
     1:     NS_ERROR("no slot");
     1:     goto done;
     1:   }
     1: 
108991:   keyItem.data = (uint8_t *) key;
     1:   keyItem.len = 8;
     1:   symkey = PK11_ImportSymKey(slot, cipherMech,
     1:                              PK11_OriginUnwrap, CKA_ENCRYPT,
106838:                              &keyItem, nullptr);
     1:   if (!symkey)
     1:   {
     1:     NS_ERROR("no symkey");
     1:     goto done;
     1:   }
     1: 
     1:   // no initialization vector required
106838:   param = PK11_ParamFromIV(cipherMech, nullptr);
     1:   if (!param)
     1:   {
     1:     NS_ERROR("no param");
     1:     goto done;
     1:   }
     1: 
     1:   ctxt = PK11_CreateContextBySymKey(cipherMech, CKA_ENCRYPT,
     1:                                     symkey, param);
     1:   if (!ctxt)
     1:   {
     1:     NS_ERROR("no context");
     1:     goto done;
     1:   }
     1: 
108991:   rv = PK11_CipherOp(ctxt, hash, (int *) &n, 8, (uint8_t *) src, 8);
     1:   if (rv != SECSuccess)
     1:   {
     1:     NS_ERROR("des failure");
     1:     goto done;
     1:   }
     1: 
     1:   rv = PK11_DigestFinal(ctxt, hash+8, &n, 0);
     1:   if (rv != SECSuccess)
     1:   {
     1:     NS_ERROR("des failure");
     1:     goto done;
     1:   }
     1: 
     1: done:
     1:   if (ctxt)
 80486:     PK11_DestroyContext(ctxt, true);
     1:   if (symkey)
     1:     PK11_FreeSymKey(symkey);
     1:   if (param)
 80486:     SECITEM_FreeItem(param, true);
     1:   if (slot)
     1:     PK11_FreeSlot(slot);
     1: }
     1: 
     1: //-----------------------------------------------------------------------------
     1: // MD5 support code
     1: 
108991: static void md5sum(const uint8_t *input, uint32_t inputLen, uint8_t *result)
     1: {
     1:   PK11Context *ctxt = PK11_CreateDigestContext(SEC_OID_MD5);
     1:   if (ctxt)
     1:   {
     1:     if (PK11_DigestBegin(ctxt) == SECSuccess)
     1:     {
     1:       if (PK11_DigestOp(ctxt, input, inputLen) == SECSuccess)
     1:       {
108991:         uint32_t resultLen = 16;
     1:         PK11_DigestFinal(ctxt, result, &resultLen, resultLen);
     1:       }
     1:     }
 80486:     PK11_DestroyContext(ctxt, true);
     1:   }
     1: }
