74701: /* ***** BEGIN LICENSE BLOCK *****
74701:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
74701:  *
74701:  * The contents of this file are subject to the Mozilla Public License Version
74701:  * 1.1 (the "License"); you may not use this file except in compliance with
74701:  * the License. You may obtain a copy of the License at
74701:  * http://www.mozilla.org/MPL/
74701:  *
74701:  * Software distributed under the License is distributed on an "AS IS" basis,
74701:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
74701:  * for the specific language governing rights and limitations under the
74701:  * License.
74701:  *
74701:  * The Original Code is TPS.
74701:  *
74701:  * The Initial Developer of the Original Code is Mozilla.
74701:  * Portions created by the Initial Developer are Copyright (C) 2010
74701:  * the Initial Developer. All Rights Reserved.
74701:  *
74701:  * Contributor(s):
74701:  *   Jonathan Griffin <jgriffin@mozilla.com>
74701:  *   Philipp von Weitershausen <philipp@weitershausen.de>
74701:  *
74701:  * Alternatively, the contents of this file may be used under the terms of
74701:  * either the GNU General Public License Version 2 or later (the "GPL"), or
74701:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
74701:  * in which case the provisions of the GPL or the LGPL are applicable instead
74701:  * of those above. If you wish to allow use of your version of this file only
74701:  * under the terms of either the GPL or the LGPL, and not to allow others to
74701:  * use your version of this file under the terms of the MPL, indicate your
74701:  * decision by deleting the provisions above and replace them with the notice
74701:  * and other provisions required by the GPL or the LGPL. If you do not delete
74701:  * the provisions above, a recipient may use your version of this file under
74701:  * the terms of any one of the MPL, the GPL or the LGPL.
74701:  *
74701:  * ***** END LICENSE BLOCK ***** */
74701: 
74701:  /* This is a JavaScript module (JSM) to be imported via
74701:   * Components.utils.import() and acts as a singleton. Only the following
74701:   * listed symbols will exposed on import, and only when and where imported.
74701:   */
74701: 
84978: let EXPORTED_SYMBOLS = ["TPS"];
74701: 
84978: const {classes: CC, interfaces: CI, utils: CU} = Components;
74701: 
74701: CU.import("resource://services-sync/service.js");
74701: CU.import("resource://services-sync/constants.js");
84992: CU.import("resource://services-sync/engines.js");
82228: CU.import("resource://services-sync/async.js");
74701: CU.import("resource://services-sync/util.js");
74701: CU.import("resource://gre/modules/XPCOMUtils.jsm");
74701: CU.import("resource://gre/modules/Services.jsm");
82228: CU.import("resource://tps/addons.jsm");
74701: CU.import("resource://tps/bookmarks.jsm");
74701: CU.import("resource://tps/logger.jsm");
74701: CU.import("resource://tps/passwords.jsm");
74701: CU.import("resource://tps/history.jsm");
74701: CU.import("resource://tps/forms.jsm");
74701: CU.import("resource://tps/prefs.jsm");
74701: CU.import("resource://tps/tabs.jsm");
74701: 
77604: var hh = CC["@mozilla.org/network/protocol;1?name=http"]
77604:          .getService(CI.nsIHttpProtocolHandler);
82228: var prefs = CC["@mozilla.org/preferences-service;1"]
82228:             .getService(CI.nsIPrefBranch);
77604: 
77604: var mozmillInit = {};
77604: CU.import('resource://mozmill/modules/init.js', mozmillInit);
77604: 
74701: const ACTION_ADD              = "add";
74701: const ACTION_VERIFY           = "verify";
74701: const ACTION_VERIFY_NOT       = "verify-not";
74701: const ACTION_MODIFY           = "modify";
74701: const ACTION_SYNC             = "sync";
74701: const ACTION_DELETE           = "delete";
74701: const ACTION_PRIVATE_BROWSING = "private-browsing";
84978: const ACTION_WIPE_REMOTE      = "wipe-remote";
74701: const ACTION_WIPE_SERVER      = "wipe-server";
84978: const ACTION_SET_ENABLED      = "set-enabled";
84978: 
74701: const ACTIONS = [ACTION_ADD, ACTION_VERIFY, ACTION_VERIFY_NOT,
74701:                  ACTION_MODIFY, ACTION_SYNC, ACTION_DELETE,
84978:                  ACTION_PRIVATE_BROWSING, ACTION_WIPE_REMOTE,
84978:                  ACTION_WIPE_SERVER, ACTION_SET_ENABLED];
74701: 
84978: const SYNC_WIPE_CLIENT  = "wipe-client";
84978: const SYNC_WIPE_REMOTE  = "wipe-remote";
74701: const SYNC_WIPE_SERVER  = "wipe-server";
74701: const SYNC_RESET_CLIENT = "reset-client";
84978: const SYNC_START_OVER   = "start-over";
74701: 
84978: let TPS =
74701: {
74701:   _waitingForSync: false,
74701:   _test: null,
74701:   _currentAction: -1,
74701:   _currentPhase: -1,
74701:   _errors: 0,
74701:   _syncErrors: 0,
74701:   _usSinceEpoch: 0,
74701:   _tabsAdded: 0,
74701:   _tabsFinished: 0,
74701:   _phaselist: {},
74701:   _operations_pending: 0,
84978:   _loggedIn: false,
84992:   _enabledEngines: null,
74701: 
74701:   DumpError: function (msg) {
74701:     this._errors++;
74701:     Logger.logError("[phase" + this._currentPhase + "] " + msg);
74701:     this.quit();
74701:   },
74701: 
74701:   QueryInterface: XPCOMUtils.generateQI([CI.nsIObserver,
74701:                                          CI.nsISupportsWeakReference]),
74701: 
74701:   observe: function TPS__observe(subject, topic, data) {
74701:     try {
74701:       Logger.logInfo("----------event observed: " + topic);
74701:       switch(topic) {
74701:         case "private-browsing":
74701:           Logger.logInfo("private browsing " + data);
74701:           break;
74701:         case "weave:service:sync:error":
74701:           if (this._waitingForSync && this._syncErrors == 0) {
74701:             // if this is the first sync error, retry...
74701:             Logger.logInfo("sync error; retrying...");
74701:             this._syncErrors++;
74701:             this._waitingForSync = false;
74701:             Utils.nextTick(this.RunNextTestAction, this);
74701:           }
78052:           else if (this._waitingForSync) {
74701:             // ...otherwise abort the test
74701:             this.DumpError("sync error; aborting test");
74701:             return;
74701:           }
74701:           break;
84978: 
74701:         case "weave:service:sync:finish":
74701:           if (this._waitingForSync) {
74701:             this._syncErrors = 0;
74701:             this._waitingForSync = false;
74701:             // Wait a second before continuing, otherwise we can get
74701:             // 'sync not complete' errors.
74701:             Utils.namedTimer(function() {
74701:               this.FinishAsyncOperation();
74701:             }, 1000, this, "postsync");
74701:           }
74701:           break;
74701:         case "sessionstore-windows-restored":
74701:           Utils.nextTick(this.RunNextTestAction, this);
74701:           break;
74701:       }
74701:     }
74701:     catch(e) {
84968:       this.DumpError("Exception caught: " + Utils.exceptionStr(e));
74701:       return;
74701:     }
74701:   },
74701: 
74701:   StartAsyncOperation: function TPS__StartAsyncOperation() {
74701:     this._operations_pending++;
74701:   },
74701: 
74701:   FinishAsyncOperation: function TPS__FinishAsyncOperation() {
74701:     this._operations_pending--;
74701:     if (!this.operations_pending) {
74701:       this._currentAction++;
74701:       Utils.nextTick(function() {
74701:         this.RunNextTestAction();
74701:       }, this);
74701:     }
74701:   },
74701: 
74701:   quit: function () {
74701:     Logger.close();
74701:     this.goQuitApplication();
74701:   },
74701: 
74701:   HandleTabs: function (tabs, action) {
74701:     this._tabsAdded = tabs.length;
74701:     this._tabsFinished = 0;
74701:     for each (let tab in tabs) {
74701:       Logger.logInfo("executing action " + action.toUpperCase() +
74701:                      " on tab " + JSON.stringify(tab));
74701:       switch(action) {
74701:         case ACTION_ADD:
74701:           // When adding tabs, we keep track of how many tabs we're adding,
74701:           // and wait until we've received that many onload events from our
74701:           // new tabs before continuing
74701:           let that = this;
74701:           let taburi = tab.uri;
74701:           BrowserTabs.Add(tab.uri, function() {
74701:             that._tabsFinished++;
74701:             Logger.logInfo("tab for " + taburi + " finished loading");
74701:             if (that._tabsFinished == that._tabsAdded) {
74701:               Logger.logInfo("all tabs loaded, continuing...");
74701:               that.FinishAsyncOperation();
74701:             }
74701:           });
74701:           break;
74701:         case ACTION_VERIFY:
74701:           Logger.AssertTrue(typeof(tab.profile) != "undefined",
74701:             "profile must be defined when verifying tabs");
74701:           Logger.AssertTrue(
74701:             BrowserTabs.Find(tab.uri, tab.title, tab.profile), "error locating tab");
74701:           break;
74701:         case ACTION_VERIFY_NOT:
74701:           Logger.AssertTrue(typeof(tab.profile) != "undefined",
74701:             "profile must be defined when verifying tabs");
74701:           Logger.AssertTrue(
74701:             !BrowserTabs.Find(tab.uri, tab.title, tab.profile),
74701:             "tab found which was expected to be absent");
74701:           break;
74701:         default:
74701:           Logger.AssertTrue(false, "invalid action: " + action);
74701:       }
74701:     }
74701:     Logger.logPass("executing action " + action.toUpperCase() + " on tabs");
74701:   },
74701: 
74701:   HandlePrefs: function (prefs, action) {
74701:     for each (pref in prefs) {
74701:       Logger.logInfo("executing action " + action.toUpperCase() +
74701:                      " on pref " + JSON.stringify(pref));
74701:       let preference = new Preference(pref);
74701:       switch(action) {
74701:         case ACTION_MODIFY:
74701:           preference.Modify();
74701:           break;
74701:         case ACTION_VERIFY:
74701:           preference.Find();
74701:           break;
74701:         default:
74701:           Logger.AssertTrue(false, "invalid action: " + action);
74701:       }
74701:     }
74701:     Logger.logPass("executing action " + action.toUpperCase() + " on pref");
74701:   },
74701: 
74701:   HandleForms: function (data, action) {
74701:     for each (datum in data) {
74701:       Logger.logInfo("executing action " + action.toUpperCase() +
74701:                      " on form entry " + JSON.stringify(datum));
74701:       let formdata = new FormData(datum, this._usSinceEpoch);
74701:       switch(action) {
74701:         case ACTION_ADD:
74701:           formdata.Create();
74701:           break;
74701:         case ACTION_DELETE:
74701:           formdata.Remove();
74701:           break;
74701:         case ACTION_VERIFY:
74701:           Logger.AssertTrue(formdata.Find(), "form data not found");
74701:           break;
74701:         case ACTION_VERIFY_NOT:
74701:           Logger.AssertTrue(!formdata.Find(),
74701:             "form data found, but it shouldn't be present");
74701:           break;
74701:         default:
74701:           Logger.AssertTrue(false, "invalid action: " + action);
74701:       }
74701:     }
74701:     Logger.logPass("executing action " + action.toUpperCase() +
74701:                    " on formdata");
74701:   },
74701: 
74701:   HandleHistory: function (entries, action) {
78567:     try {
74701:       for each (entry in entries) {
74701:         Logger.logInfo("executing action " + action.toUpperCase() +
74701:                        " on history entry " + JSON.stringify(entry));
74701:         switch(action) {
74701:           case ACTION_ADD:
74701:             HistoryEntry.Add(entry, this._usSinceEpoch);
74701:             break;
74701:           case ACTION_DELETE:
74701:             HistoryEntry.Delete(entry, this._usSinceEpoch);
74701:             break;
74701:           case ACTION_VERIFY:
74701:             Logger.AssertTrue(HistoryEntry.Find(entry, this._usSinceEpoch),
74701:               "Uri visits not found in history database");
74701:             break;
74701:           case ACTION_VERIFY_NOT:
74701:             Logger.AssertTrue(!HistoryEntry.Find(entry, this._usSinceEpoch),
74701:               "Uri visits found in history database, but they shouldn't be");
74701:             break;
74701:           default:
74701:             Logger.AssertTrue(false, "invalid action: " + action);
74701:         }
74701:       }
74701:       Logger.logPass("executing action " + action.toUpperCase() +
74701:                      " on history");
78567:     }
78567:     catch(e) {
78567:       DumpHistory();
78567:       throw(e);
78567:     }
74701:   },
74701: 
74701:   HandlePasswords: function (passwords, action) {
78567:     try {
74701:       for each (password in passwords) {
74701:         let password_id = -1;
74701:         Logger.logInfo("executing action " + action.toUpperCase() +
74701:                       " on password " + JSON.stringify(password));
74701:         var password = new Password(password);
74701:         switch (action) {
74701:           case ACTION_ADD:
74701:             Logger.AssertTrue(password.Create() > -1, "error adding password");
74701:             break;
74701:           case ACTION_VERIFY:
74701:             Logger.AssertTrue(password.Find() != -1, "password not found");
74701:             break;
74701:           case ACTION_VERIFY_NOT:
74701:             Logger.AssertTrue(password.Find() == -1,
74701:               "password found, but it shouldn't exist");
74701:             break;
74701:           case ACTION_DELETE:
74701:             Logger.AssertTrue(password.Find() != -1, "password not found");
74701:             password.Remove();
74701:             break;
74701:           case ACTION_MODIFY:
74701:             if (password.updateProps != null) {
74701:               Logger.AssertTrue(password.Find() != -1, "password not found");
74701:               password.Update();
74701:             }
74701:             break;
74701:           default:
74701:             Logger.AssertTrue(false, "invalid action: " + action);
74701:         }
74701:       }
74701:       Logger.logPass("executing action " + action.toUpperCase() +
74701:                      " on passwords");
78567:     }
78567:     catch(e) {
78567:       DumpPasswords();
78567:       throw(e);
78567:     }
74701:   },
74701: 
82228:   HandleAddons: function (addons, action, state) {
84993:     for each (let entry in addons) {
82228:       Logger.logInfo("executing action " + action.toUpperCase() +
84993:                      " on addon " + JSON.stringify(entry));
84993:       let addon = new Addon(this, entry);
82228:       switch(action) {
82228:         case ACTION_ADD:
84993:           addon.install();
82228:           break;
82228:         case ACTION_DELETE:
84993:           addon.uninstall();
82228:           break;
82228:         case ACTION_VERIFY:
84993:           Logger.AssertTrue(addon.find(state), 'addon ' + addon.id + ' not found');
82228:           break;
82228:         case ACTION_VERIFY_NOT:
84993:           Logger.AssertFalse(addon.find(state), 'addon ' + addon.id + " is present, but it shouldn't be");
82228:           break;
84993:         case ACTION_SET_ENABLED:
84993:           Logger.AssertTrue(addon.setEnabled(state), 'addon ' + addon.id + ' not found');
82228:           break;
84993:         default:
84993:           throw new Error("Unknown action for add-on: " + action);
82228:       }
82228:     }
82228:     Logger.logPass("executing action " + action.toUpperCase() +
82228:                    " on addons");
82228:   },
82228: 
74701:   HandleBookmarks: function (bookmarks, action) {
78062:     try {
74701:       let items = [];
74701:       for (folder in bookmarks) {
74701:         let last_item_pos = -1;
74701:         for each (bookmark in bookmarks[folder]) {
74701:           Logger.clearPotentialError();
74701:           let placesItem;
74701:           bookmark['location'] = folder;
74701:           if (last_item_pos != -1)
74701:             bookmark['last_item_pos'] = last_item_pos;
74701:           let item_id = -1;
74701:           if (action != ACTION_MODIFY && action != ACTION_DELETE)
74701:             Logger.logInfo("executing action " + action.toUpperCase() +
74701:                            " on bookmark " + JSON.stringify(bookmark));
74701:           if ("uri" in bookmark)
74701:             placesItem = new Bookmark(bookmark);
74701:           else if ("folder" in bookmark)
74701:             placesItem = new BookmarkFolder(bookmark);
74701:           else if ("livemark" in bookmark)
74701:             placesItem = new Livemark(bookmark);
74701:           else if ("separator" in bookmark)
74701:             placesItem = new Separator(bookmark);
74701:           if (action == ACTION_ADD) {
74701:             item_id = placesItem.Create();
74701:           }
74701:           else {
74701:             item_id = placesItem.Find();
74701:             if (action == ACTION_VERIFY_NOT) {
74701:               Logger.AssertTrue(item_id == -1,
74701:                 "places item exists but it shouldn't: " +
74701:                 JSON.stringify(bookmark));
74701:             }
74701:             else
74701:               Logger.AssertTrue(item_id != -1, "places item not found", true);
74701:           }
74701: 
74701:           last_item_pos = placesItem.GetItemIndex();
74701:           items.push(placesItem);
74701:         }
74701:       }
74701: 
74701:       if (action == ACTION_DELETE || action == ACTION_MODIFY) {
74701:         for each (item in items) {
74701:           Logger.logInfo("executing action " + action.toUpperCase() +
74701:                          " on bookmark " + JSON.stringify(item));
74701:           switch(action) {
74701:             case ACTION_DELETE:
74701:               item.Remove();
74701:               break;
74701:             case ACTION_MODIFY:
74701:               if (item.updateProps != null)
74701:                 item.Update();
74701:               break;
74701:           }
74701:         }
74701:       }
74701: 
74701:       Logger.logPass("executing action " + action.toUpperCase() +
74701:         " on bookmarks");
78062:     }
78062:     catch(e) {
78062:       DumpBookmarks();
78062:       throw(e);
78062:     }
74701:   },
74701: 
77604:   MozmillEndTestListener: function TPS__MozmillEndTestListener(obj) {
77604:     Logger.logInfo("mozmill endTest: " + JSON.stringify(obj));
77604:     if (obj.failed > 0) {
77604:       this.DumpError('mozmill test failed, name: ' + obj.name + ', reason: ' + JSON.stringify(obj.fails));
77604:       return;
77604:     }
77604:     else if ('skipped' in obj && obj.skipped) {
77604:       this.DumpError('mozmill test failed, name: ' + obj.name + ', reason: ' + obj.skipped_reason);
77604:       return;
77604:     }
77604:     else {
77604:       Utils.namedTimer(function() {
77604:         this.FinishAsyncOperation();
77604:       }, 2000, this, "postmozmilltest");
77604:     }
77604:   },
77604: 
77604:   MozmillSetTestListener: function TPS__MozmillSetTestListener(obj) {
77604:     Logger.logInfo("mozmill setTest: " + obj.name);
77604:   },
77604: 
74701:   RunNextTestAction: function() {
74701:     try {
74701:       if (this._currentAction >=
74701:           this._phaselist["phase" + this._currentPhase].length) {
74701:         // we're all done
74701:         Logger.logInfo("test phase " + this._currentPhase + ": " +
74701:           (this._errors ? "FAIL" : "PASS"));
74701:         this.quit();
74701:         return;
74701:       }
74701: 
74701:       if (this.seconds_since_epoch)
74701:         this._usSinceEpoch = this.seconds_since_epoch * 1000 * 1000;
74701:       else {
74701:         this.DumpError("seconds-since-epoch not set");
74701:         return;
74701:       }
74701: 
74701:       let phase = this._phaselist["phase" + this._currentPhase];
74701:       let action = phase[this._currentAction];
74701:       Logger.logInfo("starting action: " + JSON.stringify(action));
82228:       action[0].apply(this, action.slice(1));
74701: 
74701:       // if we're in an async operation, don't continue on to the next action
74701:       if (this._operations_pending)
74701:         return;
74701: 
74701:       this._currentAction++;
74701:     }
74701:     catch(e) {
84968:       this.DumpError("Exception caught: " + Utils.exceptionStr(e));
74701:       return;
74701:     }
74701:     this.RunNextTestAction();
74701:   },
74701: 
84992:   /**
84992:    * Runs a single test phase.
84992:    *
84992:    * This is the main entry point for each phase of a test. The TPS command
84992:    * line driver loads this module and calls into the function with the
84992:    * arguments from the command line.
84992:    *
84992:    * When a phase is executed, the file is loaded as JavaScript into the
84992:    * current object.
84992:    *
84992:    * The following keys in the options argument have meaning:
84992:    *
84992:    *   - ignoreUnusedEngines  If true, unused engines will be unloaded from
84992:    *                          Sync. This makes output easier to parse and is
84992:    *                          useful for debugging test failures.
84992:    *
84992:    * @param  file
84992:    *         String URI of the file to open.
84992:    * @param  phase
84992:    *         String name of the phase to run.
84992:    * @param  logpath
84992:    *         String path of the log file to write to.
84992:    * @param  options
84992:    *         Object defining addition run-time options.
84992:    */
84992:   RunTestPhase: function (file, phase, logpath, options) {
74701:     try {
84992:       let settings = options || {};
84992: 
74701:       Logger.init(logpath);
77604:       Logger.logInfo("Sync version: " + WEAVE_VERSION);
74701:       Logger.logInfo("Firefox builddate: " + Services.appinfo.appBuildID);
74701:       Logger.logInfo("Firefox version: " + Services.appinfo.version);
74701: 
77604:       // do some sync housekeeping
74701:       if (Weave.Service.isLoggedIn) {
77604:         this.DumpError("Sync logged in on startup...profile may be dirty");
74701:         return;
74701:       }
74701: 
74701:       // setup observers
74701:       Services.obs.addObserver(this, "weave:service:sync:finish", true);
74701:       Services.obs.addObserver(this, "weave:service:sync:error", true);
74701:       Services.obs.addObserver(this, "sessionstore-windows-restored", true);
74701:       Services.obs.addObserver(this, "private-browsing", true);
74701: 
74701:       // parse the test file
74701:       Services.scriptloader.loadSubScript(file, this);
74701:       this._currentPhase = phase;
74701:       let this_phase = this._phaselist["phase" + this._currentPhase];
74701: 
74701:       if (this_phase == undefined) {
74701:         this.DumpError("invalid phase " + this._currentPhase);
74701:         return;
74701:       }
74701: 
74701:       if (this.phases["phase" + this._currentPhase] == undefined) {
74701:         this.DumpError("no profile defined for phase " + this._currentPhase);
74701:         return;
74701:       }
84992: 
84992:       // If we have restricted the active engines, unregister engines we don't
84992:       // care about.
84992:       if (settings.ignoreUnusedEngines && Array.isArray(this._enabledEngines)) {
84992:         let names = {};
84992:         for each (let name in this._enabledEngines) {
84992:           names[name] = true;
84992:         }
84992: 
84992:         for each (let engine in Engines.getEnabled()) {
84992:           if (!(engine.name in names)) {
84992:             Logger.logInfo("Unregistering unused engine: " + engine.name);
84992:             Engines.unregister(engine);
84992:           }
84992:         }
84992:       }
84992: 
84978:       Logger.logInfo("Starting phase " + parseInt(phase, 10) + "/" +
84978:                      Object.keys(this._phaselist).length);
84978: 
74701:       Logger.logInfo("setting client.name to " + this.phases["phase" + this._currentPhase]);
74701:       Weave.Svc.Prefs.set("client.name", this.phases["phase" + this._currentPhase]);
74701: 
84978:       // TODO Phases should be defined in a data type that has strong
84978:       // ordering, not by lexical sorting.
84978:       let currentPhase = parseInt(this._currentPhase, 10);
84978:       // Reset everything at the beginning of the test.
84978:       if (currentPhase <= 1) {
84978:         this_phase.unshift([this.ResetData]);
84978:       }
84978: 
84978:       // Wipe the server at the end of the final test phase.
84978:       if (currentPhase >= Object.keys(this.phases).length) {
74701:         this_phase.push([this.WipeServer]);
84978:       }
74701: 
78052:       // Store account details as prefs so they're accessible to the mozmill
78052:       // framework.
78052:       prefs.setCharPref('tps.account.username', this.config.account.username);
78052:       prefs.setCharPref('tps.account.password', this.config.account.password);
78052:       prefs.setCharPref('tps.account.passphrase', this.config.account.passphrase);
78564:       if (this.config.account['serverURL']) {
78564:         prefs.setCharPref('tps.account.serverURL', this.config.account.serverURL);
78564:       }
78052: 
74701:       // start processing the test actions
74701:       this._currentAction = 0;
74701:     }
74701:     catch(e) {
84968:       this.DumpError("Exception caught: " + Utils.exceptionStr(e));
74701:       return;
74701:     }
74701:   },
74701: 
84992:   /**
84992:    * Register a single phase with the test harness.
84992:    *
84992:    * This is called when loading individual test files.
84992:    *
84992:    * @param  phasename
84992:    *         String name of the phase being loaded.
84992:    * @param  fnlist
84992:    *         Array of functions/actions to perform.
84992:    */
74701:   Phase: function Test__Phase(phasename, fnlist) {
74701:     this._phaselist[phasename] = fnlist;
74701:   },
74701: 
84992:   /**
84992:    * Restrict enabled Sync engines to a specified set.
84992:    *
84992:    * This can be called by a test to limit what engines are enabled. It is
84992:    * recommended to call it to reduce the overhead and log clutter for the
84992:    * test.
84992:    *
84992:    * The "clients" engine is special and is always enabled, so there is no
84992:    * need to specify it.
84992:    *
84992:    * @param  names
84992:    *         Array of Strings for engines to make active during the test.
84992:    */
84992:   EnableEngines: function EnableEngines(names) {
84992:     if (!Array.isArray(names)) {
84992:       throw new Error("Argument to RestrictEngines() is not an array: "
84992:                       + typeof(names));
84992:     }
84992: 
84992:     this._enabledEngines = names;
84992:   },
84992: 
77604:   RunMozmillTest: function TPS__RunMozmillTest(testfile) {
77604:     var mozmillfile = CC["@mozilla.org/file/local;1"]
77604:                       .createInstance(CI.nsILocalFile);
77604:     if (hh.oscpu.toLowerCase().indexOf('windows') > -1) {
77604:       let re = /\/(\w)\/(.*)/;
87639:       this.config.testdir = this.config.testdir.replace(re, "$1://$2").replace(/\//g, "\\");
77604:     }
77604:     mozmillfile.initWithPath(this.config.testdir);
77604:     mozmillfile.appendRelativePath(testfile);
77604:     Logger.logInfo("Running mozmill test " + mozmillfile.path);
77604: 
77604:     var frame = {};
77604:     CU.import('resource://mozmill/modules/frame.js', frame);
77604:     frame.events.addListener('setTest', this.MozmillSetTestListener.bind(this));
77604:     frame.events.addListener('endTest', this.MozmillEndTestListener.bind(this));
77604:     this.StartAsyncOperation();
77604:     frame.runTestFile(mozmillfile.path, false);
77604:   },
77604: 
74701:   SetPrivateBrowsing: function TPS__SetPrivateBrowsing(options) {
74701:     let PBSvc = CC["@mozilla.org/privatebrowsing;1"].
74701:                 getService(CI.nsIPrivateBrowsingService);
74701:     PBSvc.privateBrowsingEnabled = options;
74701:     Logger.logInfo("set privateBrowsingEnabled: " + options);
74701:   },
74701: 
84978:   /**
84978:    * Reset the client and server to an empty/pure state.
84978:    *
84978:    * All data on the server is wiped and replaced with new keys and local
84978:    * client data. The local client is configured such that it is in sync
84978:    * with the server and ready to handle changes.
84978:    *
84978:    * This is typically called at the beginning of every test to set up a clean
84978:    * slate.
84978:    *
84978:    * This executes synchronously and doesn't return until things are in a good
84978:    * state.
84978:    */
84978:   ResetData: function ResetData() {
84978:     this.Login(true);
84978: 
84978:     Service.login();
84978:     Service.wipeServer();
84978:     Service.resetClient();
84978:     Service.login();
84978:   },
84978: 
84978:   Login: function Login(force) {
84978:     if (this._loggedIn && !force) {
84978:       return;
84978:     }
84978: 
84978:     let account = this.config.account;
84978:     if (!account) {
84978:       this.DumperError("No account information found! Did you use a valid " +
84978:                        "config file?");
84978:       return;
84978:     }
84978: 
84978:     if (account["serverURL"]) {
84978:       Service.serverURL = account["serverURL"];
84978:     }
84978: 
84978:     Logger.logInfo("Setting client credentials.");
84978:     if (account["admin-secret"]) {
84978:       // if admin-secret is specified, we'll dynamically create
84978:       // a new sync account
84978:       Weave.Svc.Prefs.set("admin-secret", account["admin-secret"]);
84978:       let suffix = account["account-suffix"];
84978:       Service.account = "tps" + suffix + "@mozilla.com";
84978:       Service.password = "tps" + suffix + "tps" + suffix;
84978:       Service.passphrase = Weave.Utils.generatePassphrase();
84978:       Service.createAccount(Service.account,
84978:                             Service.password,
84978:                             "dummy1", "dummy2");
84978:     } else if (account["username"] && account["password"] &&
84978:                account["passphrase"]) {
84978:       Service.account = account["username"];
84978:       Service.password = account["password"];
84978:       Service.passphrase = account["passphrase"];
84978:     } else {
84978:       this.DumpError("Must specify admin-secret, or " +
84978:                      "username/password/passphrase in the config file");
84978:       return;
84978:     }
84978: 
84978:     Service.login();
84978:     Logger.AssertEqual(Weave.Status.service, Weave.STATUS_OK, "Weave status not OK");
84978:     Weave.Svc.Obs.notify("weave:service:setup-complete");
84978:     this._loggedIn = true;
84978:   },
84978: 
74701:   Sync: function TPS__Sync(options) {
74701:     Logger.logInfo("executing Sync " + (options ? options : ""));
84978: 
84978:     if (options == SYNC_WIPE_REMOTE) {
74701:       Weave.Svc.Prefs.set("firstSync", "wipeRemote");
74701:     }
74701:     else if (options == SYNC_WIPE_CLIENT) {
74701:       Weave.Svc.Prefs.set("firstSync", "wipeClient");
74701:     }
74701:     else if (options == SYNC_RESET_CLIENT) {
74701:       Weave.Svc.Prefs.set("firstSync", "resetClient");
74701:     }
84978:     else if (options) {
84978:       throw new Error("Unhandled options to Sync(): " + options);
84978:     } else {
74701:       Weave.Svc.Prefs.reset("firstSync");
74701:     }
84978: 
84978:     this.Login(false);
84978: 
74701:     this._waitingForSync = true;
74701:     this.StartAsyncOperation();
84978: 
74701:     Weave.Service.sync();
74701:   },
74701: 
74701:   WipeServer: function TPS__WipeServer() {
74701:     Logger.logInfo("WipeServer()");
84978:     this.Login();
74701:     Weave.Service.wipeServer();
74701:   },
74701: };
74701: 
82228: var Addons = {
82228:   install: function Addons__install(addons) {
82228:     TPS.HandleAddons(addons, ACTION_ADD);
82228:   },
84978:   setEnabled: function Addons__setEnabled(addons, state) {
84978:     TPS.HandleAddons(addons, ACTION_SET_ENABLED, state);
82228:   },
82228:   uninstall: function Addons__uninstall(addons) {
82228:     TPS.HandleAddons(addons, ACTION_DELETE);
82228:   },
82228:   verify: function Addons__verify(addons, state) {
82228:     TPS.HandleAddons(addons, ACTION_VERIFY, state);
82228:   },
82228:   verifyNot: function Addons__verifyNot(addons) {
82228:     TPS.HandleAddons(addons, ACTION_VERIFY_NOT);
82228:   },
82228: };
82228: 
74701: var Bookmarks = {
74701:   add: function Bookmarks__add(bookmarks) {
74701:     TPS.HandleBookmarks(bookmarks, ACTION_ADD);
74701:   },
74701:   modify: function Bookmarks__modify(bookmarks) {
74701:     TPS.HandleBookmarks(bookmarks, ACTION_MODIFY);
74701:   },
74701:   delete: function Bookmarks__delete(bookmarks) {
74701:     TPS.HandleBookmarks(bookmarks, ACTION_DELETE);
74701:   },
74701:   verify: function Bookmarks__verify(bookmarks) {
74701:     TPS.HandleBookmarks(bookmarks, ACTION_VERIFY);
74701:   },
74701:   verifyNot: function Bookmarks__verifyNot(bookmarks) {
74701:     TPS.HandleBookmarks(bookmarks, ACTION_VERIFY_NOT);
74701:   }
74701: };
74701: 
74701: var Formdata = {
74701:   add: function Formdata__add(formdata) {
74701:     this.HandleForms(formdata, ACTION_ADD);
74701:   },
74701:   delete: function Formdata__delete(formdata) {
74701:     this.HandleForms(formdata, ACTION_DELETE);
74701:   },
74701:   verify: function Formdata__verify(formdata) {
74701:     this.HandleForms(formdata, ACTION_VERIFY);
74701:   },
74701:   verifyNot: function Formdata__verifyNot(formdata) {
74701:     this.HandleForms(formdata, ACTION_VERIFY_NOT);
74701:   }
74701: };
74701: 
74701: var History = {
74701:   add: function History__add(history) {
74701:     this.HandleHistory(history, ACTION_ADD);
74701:   },
74701:   delete: function History__delete(history) {
74701:     this.HandleHistory(history, ACTION_DELETE);
74701:   },
74701:   verify: function History__verify(history) {
74701:     this.HandleHistory(history, ACTION_VERIFY);
74701:   },
74701:   verifyNot: function History__verifyNot(history) {
74701:     this.HandleHistory(history, ACTION_VERIFY_NOT);
74701:   }
74701: };
74701: 
74701: var Passwords = {
74701:   add: function Passwords__add(passwords) {
74701:     this.HandlePasswords(passwords, ACTION_ADD);
74701:   },
74701:   modify: function Passwords__modify(passwords) {
74701:     this.HandlePasswords(passwords, ACTION_MODIFY);
74701:   },
74701:   delete: function Passwords__delete(passwords) {
74701:     this.HandlePasswords(passwords, ACTION_DELETE);
74701:   },
74701:   verify: function Passwords__verify(passwords) {
74701:     this.HandlePasswords(passwords, ACTION_VERIFY);
74701:   },
74701:   verifyNot: function Passwords__verifyNot(passwords) {
74701:     this.HandlePasswords(passwords, ACTION_VERIFY_NOT);
74701:   }
74701: };
74701: 
74701: var Prefs = {
74701:   modify: function Prefs__modify(prefs) {
74701:     TPS.HandlePrefs(prefs, ACTION_MODIFY);
74701:   },
74701:   verify: function Prefs__verify(prefs) {
74701:     TPS.HandlePrefs(prefs, ACTION_VERIFY);
74701:   }
74701: };
74701: 
74701: var Tabs = {
74701:   add: function Tabs__add(tabs) {
74701:     TPS.StartAsyncOperation();
74701:     TPS.HandleTabs(tabs, ACTION_ADD);
74701:   },
74701:   verify: function Tabs__verify(tabs) {
74701:     TPS.HandleTabs(tabs, ACTION_VERIFY);
74701:   },
74701:   verifyNot: function Tabs__verifyNot(tabs) {
74701:     TPS.HandleTabs(tabs, ACTION_VERIFY_NOT);
74701:   }
74701: };
74701: 
