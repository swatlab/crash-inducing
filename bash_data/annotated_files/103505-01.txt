     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* a presentation of a document, part 1 */
     1: 
     1: #include "nsCOMPtr.h"
     1: #include "nsPresContext.h"
     1: #include "nsIPresShell.h"
     1: #include "nsILinkHandler.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIContentViewer.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsStyleSet.h"
 94919: #include "nsImageLoader.h"
     1: #include "nsIContent.h"
     1: #include "nsIFrame.h"
     1: #include "nsIURL.h"
     1: #include "nsIDocument.h"
     1: #include "nsStyleContext.h"
 78130: #include "mozilla/LookAndFeel.h"
     1: #include "nsIComponentManager.h"
     1: #include "nsIURIContentListener.h"
     1: #include "nsIInterfaceRequestor.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsContentPolicyUtils.h"
     1: #include "nsIDOMWindow.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsIWeakReferenceUtils.h"
     1: #include "nsCSSRendering.h"
     1: #include "prprf.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsEventStateManager.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsFrameManager.h"
     1: #include "nsLayoutUtils.h"
     1: #include "nsIViewManager.h"
  3959: #include "nsCSSFrameConstructor.h"
 16396: #include "nsCSSRuleProcessor.h"
  3959: #include "nsStyleChangeList.h"
  6734: #include "nsRuleNode.h"
 19380: #include "nsEventDispatcher.h"
 19962: #include "gfxUserFontSet.h"
 21924: #include "gfxPlatform.h"
 21924: #include "nsCSSRules.h"
 21924: #include "nsFontFaceLoader.h"
 72328: #include "nsEventListenerManager.h"
 25231: #include "nsStyleStructInlines.h"
 27993: #include "nsIAppShell.h"
 27993: #include "prenv.h"
 29465: #include "nsIDOMEventTarget.h"
 30522: #include "nsObjectFrame.h"
 33649: #include "nsTransitionManager.h"
 67985: #include "nsAnimationManager.h"
 41930: #include "mozilla/dom/Element.h"
 42412: #include "nsIFrameMessageManager.h"
 67872: #include "FrameLayerBuilder.h"
 68769: #include "nsDOMMediaQueryList.h"
 23697: #include "nsSMILAnimationController.h"
 23697: 
     1: #ifdef IBMBIDI
     1: #include "nsBidiPresUtils.h"
     1: #endif // IBMBIDI
     1: 
     1: #include "nsContentUtils.h"
 46695: #include "nsPIWindowRoot.h"
 70840: #include "mozilla/Preferences.h"
     1: 
     1: // Needed for Start/Stop of Image Animation
     1: #include "imgIContainer.h"
     1: #include "nsIImageLoadingContent.h"
     1: 
     1: //needed for resetting of image service color
     1: #include "nsLayoutCID.h"
  5235: 
 80228: #include "nsCSSParser.h"
 80228: 
 67872: using namespace mozilla;
 41634: using namespace mozilla::dom;
 33393: 
103295: PRUint8 gNotifySubDocInvalidationData;
103295: 
 87091: namespace {
 87091: 
 87091: class CharSetChangingRunnable : public nsRunnable
 87091: {
 87091: public:
 87091:   CharSetChangingRunnable(nsPresContext* aPresContext,
 87091:                           const nsCString& aCharSet)
 87091:     : mPresContext(aPresContext),
 87091:       mCharSet(aCharSet)
 87091:   {
 87091:   }
 87091: 
 87091:   NS_IMETHOD Run()
 87091:   {
 87091:     mPresContext->DoChangeCharSet(mCharSet);
 87091:     return NS_OK;
 87091:   }
 87091: 
 87091: private:
 87091:   nsRefPtr<nsPresContext> mPresContext;
 87091:   nsCString mCharSet;
 87091: };
 87091: 
 87091: } // anonymous namespace
 87091: 
101129: nscolor
101129: nsPresContext::MakeColorPref(const nsString& aColor)
     1: {
101129:   nsCSSParser parser;
101129:   nsCSSValue value;
101129:   if (!parser.ParseColorString(aColor, nsnull, 0, value)) {
101129:     // Any better choices?
101129:     return NS_RGB(0, 0, 0);
101129:   }
101129: 
 80228:   nscolor color;
101129:   return nsRuleNode::ComputeColor(value, this, nsnull, color)
101129:     ? color
101129:     : NS_RGB(0, 0, 0);
     1: }
     1: 
 20261: int
     1: nsPresContext::PrefChangedCallback(const char* aPrefName, void* instance_data)
     1: {
     1:   nsPresContext*  presContext = (nsPresContext*)instance_data;
     1: 
     1:   NS_ASSERTION(nsnull != presContext, "bad instance data");
     1:   if (nsnull != presContext) {
     1:     presContext->PreferenceChanged(aPrefName);
     1:   }
     1:   return 0;  // PREF_OK
     1: }
     1: 
103295: bool
103295: nsPresContext::IsDOMPaintEventPending() 
103295: {
103295:   if (!mInvalidateRequests.mRequests.IsEmpty()) {
103295:     return true;    
103295:   }
103505:   if (GetRootPresContext()->mRefreshDriver->ViewManagerFlushIsPending()) {
103295:     // Since we're promising that there will be a MozAfterPaint event
103295:     // fired, we record an empty invalidation in case display list
103295:     // invalidation doesn't invalidate anything further.
103295:     NotifyInvalidation(nsRect(0, 0, 0, 0), 0);
103295:     return true;
103295:   }
103295:   return false;
103295: }
     1: 
     1: void
     1: nsPresContext::PrefChangedUpdateTimerCallback(nsITimer *aTimer, void *aClosure)
     1: {
     1:   nsPresContext*  presContext = (nsPresContext*)aClosure;
     1:   NS_ASSERTION(presContext != nsnull, "bad instance data");
     1:   if (presContext)
     1:     presContext->UpdateAfterPreferencesChanged();
     1: }
     1: 
     1: #ifdef IBMBIDI
 79445: static bool
     1: IsVisualCharset(const nsCString& aCharset)
     1: {
     1:   if (aCharset.LowerCaseEqualsLiteral("ibm864")             // Arabic//ahmed
     1:       || aCharset.LowerCaseEqualsLiteral("ibm862")          // Hebrew
     1:       || aCharset.LowerCaseEqualsLiteral("iso-8859-8") ) {  // Hebrew
 80486:     return true; // visual text type
     1:   }
     1:   else {
 80486:     return false; // logical text type
     1:   }
     1: }
     1: #endif // IBMBIDI
     1: 
 94919: 
 94919: static PLDHashOperator
 94919: destroy_loads(nsIFrame* aKey, nsRefPtr<nsImageLoader>& aData, void* closure)
 94919: {
 94919:   aData->Destroy();
 94919:   return PL_DHASH_NEXT;
 94919: }
 94919: 
     1: #include "nsContentCID.h"
     1: 
     1:   // NOTE! nsPresContext::operator new() zeroes out all members, so don't
     1:   // bother initializing members to 0.
     1: 
     1: nsPresContext::nsPresContext(nsIDocument* aDocument, nsPresContextType aType)
 70441:   : mType(aType), mDocument(aDocument), mMinFontSize(0),
 97799:     mTextZoom(1.0), mFullZoom(1.0), mLastFontInflationScreenWidth(-1.0),
 97799:     mPageSize(-1, -1), mPPScale(1.0f),
     1:     mViewportStyleOverflow(NS_STYLE_OVERFLOW_AUTO, NS_STYLE_OVERFLOW_AUTO),
103314:     mImageAnimationModePref(imgIContainer::kNormalAnimMode),
103314:     mAllInvalidated(false)
     1: {
     1:   // NOTE! nsPresContext::operator new() zeroes out all members, so don't
     1:   // bother initializing members to 0.
     1: 
 80486:   mDoScaledTwips = true;
     1: 
 80486:   SetBackgroundImageDraw(true);		// always draw the background
 80486:   SetBackgroundColorDraw(true);
     1: 
     1:   mBackgroundColor = NS_RGB(0xFF, 0xFF, 0xFF);
     1:   
 80486:   mUseDocumentColors = true;
 80486:   mUseDocumentFonts = true;
     1: 
     1:   // the minimum font-size is unconstrained by default
     1: 
     1:   mLinkColor = NS_RGB(0x00, 0x00, 0xEE);
     1:   mActiveLinkColor = NS_RGB(0xEE, 0x00, 0x00);
     1:   mVisitedLinkColor = NS_RGB(0x55, 0x1A, 0x8B);
 80486:   mUnderlineLinks = true;
 80486:   mSendAfterPaintToContent = false;
     1: 
     1:   mFocusTextColor = mDefaultColor;
     1:   mFocusBackgroundColor = mBackgroundColor;
     1:   mFocusRingWidth = 1;
     1: 
 71160:   mBodyTextColor = mDefaultColor;
 71160: 
     1:   if (aType == eContext_Galley) {
     1:     mMedium = nsGkAtoms::screen;
     1:   } else {
     1:     mMedium = nsGkAtoms::print;
 80486:     mPaginated = true;
     1:   }
     1: 
     1:   if (!IsDynamic()) {
     1:     mImageAnimationMode = imgIContainer::kDontAnimMode;
 80486:     mNeverAnimate = true;
     1:   } else {
     1:     mImageAnimationMode = imgIContainer::kNormalAnimMode;
 80486:     mNeverAnimate = false;
     1:   }
     1:   NS_ASSERTION(mDocument, "Null document");
 19962:   mUserFontSet = nsnull;
 80486:   mUserFontSetDirty = true;
 68769: 
 68769:   PR_INIT_CLIST(&mDOMMediaQueryLists);
     1: }
     1: 
     1: nsPresContext::~nsPresContext()
     1: {
     1:   NS_PRECONDITION(!mShell, "Presshell forgot to clear our mShell pointer");
     1:   SetShell(nsnull);
     1: 
 68769:   NS_ABORT_IF_FALSE(PR_CLIST_IS_EMPTY(&mDOMMediaQueryLists),
 68769:                     "must not have media query lists left");
 68769: 
 36615:   // Disconnect the refresh driver *after* the transition manager, which
 36615:   // needs it.
 50366:   if (mRefreshDriver && mRefreshDriver->PresContext() == this) {
 36615:     mRefreshDriver->Disconnect();
 36615:   }
 36615: 
     1:   if (mEventManager) {
     1:     // unclear if these are needed, but can't hurt
     1:     mEventManager->NotifyDestroyPresContext(this);
     1:     mEventManager->SetPresContext(nsnull);
     1: 
     1:     NS_RELEASE(mEventManager);
     1:   }
     1: 
     1:   if (mPrefChangedTimer)
     1:   {
     1:     mPrefChangedTimer->Cancel();
     1:     mPrefChangedTimer = nsnull;
     1:   }
     1: 
     1:   // Unregister preference callbacks
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "font.",
     1:                                   this);
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "browser.display.",
     1:                                   this);
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "browser.underline_anchors",
     1:                                   this);
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "browser.anchor_color",
     1:                                   this);
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "browser.active_color",
     1:                                   this);
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "browser.visited_color",
     1:                                   this);
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "image.animation_mode",
     1:                                   this);
     1: #ifdef IBMBIDI
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "bidi.",
 71001:                                   this);
     1: #endif // IBMBIDI
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "dom.send_after_paint_to_content",
 61194:                                   this);
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "gfx.font_rendering.",
 43347:                                   this);
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "layout.css.dpi",
     1:                                   this);
 71001:   Preferences::UnregisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                   "layout.css.devPixelsPerPx",
 28470:                                   this);
     1: 
     1:   NS_IF_RELEASE(mDeviceContext);
 38492:   NS_IF_RELEASE(mLanguage);
     1: }
     1: 
  4484: NS_IMPL_CYCLE_COLLECTION_CLASS(nsPresContext)
  4484: 
  4484: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsPresContext)
 39823:    NS_INTERFACE_MAP_ENTRY(nsISupports)
  4484:    NS_INTERFACE_MAP_ENTRY(nsIObserver)
  4484: NS_INTERFACE_MAP_END
  4484: 
  4484: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsPresContext)
  4484: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsPresContext)
  4484: 
 94919: static PLDHashOperator
 94919: TraverseImageLoader(nsIFrame* aKey, nsRefPtr<nsImageLoader>& aData,
 94919:                     void* aClosure)
 94919: {
 94919:   nsCycleCollectionTraversalCallback *cb =
 94919:     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
 94919: 
 94919:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mImageLoaders[i] item");
 94919:   cb->NoteXPCOMChild(aData);
 94919: 
 94919:   return PL_DHASH_NEXT;
 94919: }
 94919: 
  4484: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsPresContext)
  4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument);
 68667:   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mDeviceContext); // not xpcom
 68780:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mEventManager, nsIObserver);
 38492:   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mLanguage); // an atom
  4484: 
 94919:   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i)
 94919:     tmp->mImageLoaders[i].Enumerate(TraverseImageLoader, &cb);
 94919: 
 91314:   // We own only the items in mDOMMediaQueryLists that have listeners;
 91314:   // this reference is managed by their AddListener and RemoveListener
 91314:   // methods.
 91314:   for (PRCList *l = PR_LIST_HEAD(&tmp->mDOMMediaQueryLists);
 91314:        l != &tmp->mDOMMediaQueryLists; l = PR_NEXT_LINK(l)) {
 91314:     nsDOMMediaQueryList *mql = static_cast<nsDOMMediaQueryList*>(l);
 91314:     if (mql->HasListeners()) {
 91314:       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mDOMMediaQueryLists item");
 91314:       cb.NoteXPCOMChild(mql);
 91314:     }
 91314:   }
 91314: 
  4484:   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTheme); // a service
  4484:   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLangService); // a service
  4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrintSettings);
  4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrefChangedTimer);
  4484: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
  4484: 
  4484: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsPresContext)
  4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument);
  4484:   NS_RELEASE(tmp->mDeviceContext); // worth bothering?
  4484:   if (tmp->mEventManager) {
  4484:     // unclear if these are needed, but can't hurt
  4484:     tmp->mEventManager->NotifyDestroyPresContext(tmp);
  4484:     tmp->mEventManager->SetPresContext(nsnull);
  4484: 
  4484:     NS_RELEASE(tmp->mEventManager);
  4484:   }
  4484: 
 91314:   // We own only the items in mDOMMediaQueryLists that have listeners;
 91314:   // this reference is managed by their AddListener and RemoveListener
 91314:   // methods.
 91314:   for (PRCList *l = PR_LIST_HEAD(&tmp->mDOMMediaQueryLists);
 91314:        l != &tmp->mDOMMediaQueryLists; ) {
 91314:     PRCList *next = PR_NEXT_LINK(l);
 91314:     nsDOMMediaQueryList *mql = static_cast<nsDOMMediaQueryList*>(l);
 91314:     mql->RemoveAllListeners();
 91314:     l = next;
 91314:   }
 91314: 
 38492:   // NS_RELEASE(tmp->mLanguage); // an atom
  4484: 
  4484:   // NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTheme); // a service
  4484:   // NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLangService); // a service
  4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPrintSettings);
  4484:   if (tmp->mPrefChangedTimer)
  4484:   {
  4484:     tmp->mPrefChangedTimer->Cancel();
  4484:     tmp->mPrefChangedTimer = nsnull;
  4484:   }
  4484: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
  4484: 
     1: 
     1: #define MAKE_FONT_PREF_KEY(_pref, _s0, _s1) \
     1:  _pref.Assign(_s0); \
     1:  _pref.Append(_s1);
     1: 
     1: static const char* const kGenericFont[] = {
     1:   ".variable.",
     1:   ".fixed.",
     1:   ".serif.", 
     1:   ".sans-serif.", 
     1:   ".monospace.",
     1:   ".cursive.",
     1:   ".fantasy."
     1: };
     1: 
 25560: // whether no native theme service exists;
 25560: // if this gets set to true, we'll stop asking for it.
 79445: static bool sNoTheme = false;
 25560: 
     1: // Set to true when LookAndFeelChanged needs to be called.  This is used
     1: // because the look and feel is a service, so there's no need to notify it from
     1: // more than one prescontext.
 79445: static bool sLookAndFeelChanged;
     1: 
     1: // Set to true when ThemeChanged needs to be called on mTheme.  This is used
     1: // because mTheme is a service, so there's no need to notify it from more than
     1: // one prescontext.
 79445: static bool sThemeChanged;
     1: 
 90439: const nsPresContext::LangGroupFontPrefs*
 90439: nsPresContext::GetFontPrefsForLang(nsIAtom *aLanguage) const
     1: {
 90439:   // Get language group for aLanguage:
 90439: 
 90439:   nsresult rv;
 90439:   nsIAtom *langGroupAtom = nsnull;
 90439:   if (!aLanguage) {
 90439:     aLanguage = mLanguage;
 90439:   }
 90439:   if (aLanguage && mLangService) {
 90439:     langGroupAtom = mLangService->GetLanguageGroup(aLanguage, &rv);
 90439:   }
 90439:   if (NS_FAILED(rv) || !langGroupAtom) {
 90439:     langGroupAtom = nsGkAtoms::x_western; // Assume x-western is safe...
 90439:   }
 90439: 
 90439:   // Look for cached prefs for this lang group.
 90439:   // Most documents will only use one (or very few) language groups. Rather
 90439:   // than have the overhead of a hash lookup, we simply look along what will
 90439:   // typically be a very short (usually of length 1) linked list. There are 31
 90439:   // language groups, so in the worst case scenario we'll need to traverse 31
 90439:   // link items.
 90439: 
 90439:   LangGroupFontPrefs *prefs =
 90439:     const_cast<LangGroupFontPrefs*>(&mLangGroupFontPrefs);
 90439:   if (prefs->mLangGroup) { // if initialized
 90439:     DebugOnly<PRUint32> count = 0;
 90439:     for (;;) {
 90439:       NS_ASSERTION(++count < 35, "Lang group count exceeded!!!");
 90439:       if (prefs->mLangGroup == langGroupAtom) {
 90439:         return prefs;
 90439:       }
 90439:       if (!prefs->mNext) {
 90439:         break;
 90439:       }
 90439:       prefs = prefs->mNext;
 90439:     }
 90439: 
 90439:     // nothing cached, so go on and fetch the prefs for this lang group:
 90439:     prefs = prefs->mNext = new LangGroupFontPrefs;
 90439:   }
 90439: 
 90439:   prefs->mLangGroup = langGroupAtom;
 90439: 
     1:   /* Fetch the font prefs to be used -- see bug 61883 for details.
     1:      Not all prefs are needed upfront. Some are fallback prefs intended
     1:      for the GFX font sub-system...
     1: 
     1:   1) unit : assumed to be the same for all language groups -------------
     1:   font.size.unit = px | pt    XXX could be folded in the size... bug 90440
     1: 
     1:   2) attributes for generic fonts --------------------------------------
 90439:   font.default.[langGroup] = serif | sans-serif - fallback generic font
     1:   font.name.[generic].[langGroup] = current user' selected font on the pref dialog
     1:   font.name-list.[generic].[langGroup] = fontname1, fontname2, ... [factory pre-built list]
     1:   font.size.[generic].[langGroup] = integer - settable by the user
     1:   font.size-adjust.[generic].[langGroup] = "float" - settable by the user
     1:   font.minimum-size.[langGroup] = integer - settable by the user
     1:   */
     1: 
 90439:   nsCAutoString langGroup;
 90439:   langGroupAtom->ToUTF8String(langGroup);
     1: 
 90439:   prefs->mDefaultVariableFont.size = CSSPixelsToAppUnits(16);
 90439:   prefs->mDefaultFixedFont.size = CSSPixelsToAppUnits(13);
     1: 
     1:   nsCAutoString pref;
     1: 
     1:   // get the current applicable font-size unit
     1:   enum {eUnit_unknown = -1, eUnit_px, eUnit_pt};
     1:   PRInt32 unit = eUnit_px;
     1: 
     1:   nsAdoptingCString cvalue =
 70976:     Preferences::GetCString("font.size.unit");
     1: 
     1:   if (!cvalue.IsEmpty()) {
     1:     if (cvalue.Equals("px")) {
     1:       unit = eUnit_px;
     1:     }
     1:     else if (cvalue.Equals("pt")) {
     1:       unit = eUnit_pt;
     1:     }
     1:     else {
 90439:       // XXX should really send this warning to the user (Error Console?).
 90439:       // And just default to unit = eUnit_px?
     1:       NS_WARNING("unexpected font-size unit -- expected: 'px' or 'pt'");
     1:       unit = eUnit_unknown;
     1:     }
     1:   }
     1: 
     1:   // get font.minimum-size.[langGroup]
     1: 
 90439:   MAKE_FONT_PREF_KEY(pref, "font.minimum-size.", langGroup);
     1: 
 70842:   PRInt32 size = Preferences::GetInt(pref.get());
     1:   if (unit == eUnit_px) {
 90439:     prefs->mMinimumFontSize = CSSPixelsToAppUnits(size);
     1:   }
     1:   else if (unit == eUnit_pt) {
 90439:     prefs->mMinimumFontSize = CSSPointsToAppUnits(size);
     1:   }
     1: 
 85981:   nsFont* fontTypes[] = {
 90439:     &prefs->mDefaultVariableFont,
 90439:     &prefs->mDefaultFixedFont,
 90439:     &prefs->mDefaultSerifFont,
 90439:     &prefs->mDefaultSansSerifFont,
 90439:     &prefs->mDefaultMonospaceFont,
 90439:     &prefs->mDefaultCursiveFont,
 90439:     &prefs->mDefaultFantasyFont
 85981:   };
 94621:   MOZ_STATIC_ASSERT(NS_ARRAY_LENGTH(fontTypes) == eDefaultFont_COUNT,
 94621:                     "FontTypes array count is not correct");
 85981: 
 90439:   // Get attributes specific to each generic font. We do not get the user's
 90439:   // generic-font-name-to-specific-family-name preferences because its the
 90439:   // generic name that should be fed into the cascade. It is up to the GFX
 90439:   // code to look up the font prefs to convert generic names to specific
 90439:   // family names as necessary.
     1:   nsCAutoString generic_dot_langGroup;
 85981:   for (PRUint32 eType = 0; eType < ArrayLength(fontTypes); ++eType) {
     1:     generic_dot_langGroup.Assign(kGenericFont[eType]);
     1:     generic_dot_langGroup.Append(langGroup);
     1: 
 85981:     nsFont* font = fontTypes[eType];
     1: 
     1:     // set the default variable font (the other fonts are seen as 'generic' fonts
     1:     // in GFX and will be queried there when hunting for alternative fonts)
     1:     if (eType == eDefaultFont_Variable) {
 90439:       MAKE_FONT_PREF_KEY(pref, "font.name.variable.", langGroup);
     1: 
 70976:       nsAdoptingString value = Preferences::GetString(pref.get());
     1:       if (!value.IsEmpty()) {
 90439:         prefs->mDefaultVariableFont.name.Assign(value);
     1:       }
     1:       else {
     1:         MAKE_FONT_PREF_KEY(pref, "font.default.", langGroup);
 70976:         value = Preferences::GetString(pref.get());
     1:         if (!value.IsEmpty()) {
 90439:           prefs->mDefaultVariableFont.name.Assign(value);
     1:         }
     1:       } 
     1:     }
     1:     else {
     1:       if (eType == eDefaultFont_Monospace) {
     1:         // This takes care of the confusion whereby people often expect "monospace" 
     1:         // to have the same default font-size as "-moz-fixed" (this tentative
     1:         // size may be overwritten with the specific value for "monospace" when
     1:         // "font.size.monospace.[langGroup]" is read -- see below)
 90439:         prefs->mDefaultMonospaceFont.size = prefs->mDefaultFixedFont.size;
     1:       }
     1:       else if (eType != eDefaultFont_Fixed) {
     1:         // all the other generic fonts are initialized with the size of the
     1:         // variable font, but their specific size can supersede later -- see below
 90439:         font->size = prefs->mDefaultVariableFont.size;
     1:       }
     1:     }
     1: 
     1:     // Bug 84398: for spec purists, a different font-size only applies to the
     1:     // .variable. and .fixed. fonts and the other fonts should get |font-size-adjust|.
     1:     // The problem is that only GfxWin has the support for |font-size-adjust|. So for
     1:     // parity, we enable the ability to set a different font-size on all platforms.
     1: 
     1:     // get font.size.[generic].[langGroup]
     1:     // size=0 means 'Auto', i.e., generic fonts retain the size of the variable font
     1:     MAKE_FONT_PREF_KEY(pref, "font.size", generic_dot_langGroup);
 70842:     size = Preferences::GetInt(pref.get());
     1:     if (size > 0) {
     1:       if (unit == eUnit_px) {
 50791:         font->size = CSSPixelsToAppUnits(size);
     1:       }
     1:       else if (unit == eUnit_pt) {
 50791:         font->size = CSSPointsToAppUnits(size);
     1:       }
     1:     }
     1: 
     1:     // get font.size-adjust.[generic].[langGroup]
     1:     // XXX only applicable on GFX ports that handle |font-size-adjust|
     1:     MAKE_FONT_PREF_KEY(pref, "font.size-adjust", generic_dot_langGroup);
 70976:     cvalue = Preferences::GetCString(pref.get());
     1:     if (!cvalue.IsEmpty()) {
     1:       font->sizeAdjust = (float)atof(cvalue.get());
     1:     }
     1: 
     1: #ifdef DEBUG_rbs
     1:     printf("%s Family-list:%s size:%d sizeAdjust:%.2f\n",
     1:            generic_dot_langGroup.get(),
     1:            NS_ConvertUTF16toUTF8(font->name).get(), font->size,
     1:            font->sizeAdjust);
     1: #endif
     1:   }
 90439: 
 90439:   return prefs;
     1: }
     1: 
     1: void
     1: nsPresContext::GetDocumentColorPreferences()
     1: {
     1:   PRInt32 useAccessibilityTheme = 0;
 79445:   bool usePrefColors = true;
     1:   nsCOMPtr<nsIDocShellTreeItem> docShell(do_QueryReferent(mContainer));
     1:   if (docShell) {
     1:     PRInt32 docShellType;
     1:     docShell->GetItemType(&docShellType);
     1:     if (nsIDocShellTreeItem::typeChrome == docShellType) {
 80486:       usePrefColors = false;
     1:     }
     1:     else {
 78130:       useAccessibilityTheme =
 78130:         LookAndFeel::GetInt(LookAndFeel::eIntID_UseAccessibilityTheme, 0);
     1:       usePrefColors = !useAccessibilityTheme;
     1:     }
     1: 
     1:   }
     1:   if (usePrefColors) {
     1:     usePrefColors =
 79445:       !Preferences::GetBool("browser.display.use_system_colors", false);
     1:   }
     1: 
     1:   if (usePrefColors) {
 80228:     nsAdoptingString colorStr =
 80228:       Preferences::GetString("browser.display.foreground_color");
     1: 
     1:     if (!colorStr.IsEmpty()) {
     1:       mDefaultColor = MakeColorPref(colorStr);
     1:     }
     1: 
 80228:     colorStr = Preferences::GetString("browser.display.background_color");
     1: 
     1:     if (!colorStr.IsEmpty()) {
     1:       mBackgroundColor = MakeColorPref(colorStr);
     1:     }
     1:   }
     1:   else {
 78130:     mDefaultColor =
 78130:       LookAndFeel::GetColor(LookAndFeel::eColorID_WindowForeground,
 78130:                             NS_RGB(0x00, 0x00, 0x00));
 78130:     mBackgroundColor =
 78130:       LookAndFeel::GetColor(LookAndFeel::eColorID_WindowBackground,
 78130:                             NS_RGB(0xFF, 0xFF, 0xFF));
     1:   }
     1: 
 19436:   // Wherever we got the default background color from, ensure it is
 19436:   // opaque.
 19436:   mBackgroundColor = NS_ComposeColors(NS_RGB(0xFF, 0xFF, 0xFF),
 19436:                                       mBackgroundColor);
 19436: 
     1:   mUseDocumentColors = !useAccessibilityTheme &&
 70840:     Preferences::GetBool("browser.display.use_document_colors",
     1:                          mUseDocumentColors);
     1: }
     1: 
     1: void
     1: nsPresContext::GetUserPreferences()
     1: {
     1:   if (!GetPresShell()) {
     1:     // No presshell means nothing to do here.  We'll do this when we
     1:     // get a presshell.
     1:     return;
     1:   }
     1: 
 11409:   mAutoQualityMinFontSizePixelsPref =
 70842:     Preferences::GetInt("browser.display.auto_quality_min_font_size");
 11409: 
     1:   // * document colors
     1:   GetDocumentColorPreferences();
     1: 
 61194:   mSendAfterPaintToContent =
 70840:     Preferences::GetBool("dom.send_after_paint_to_content",
 61194:                          mSendAfterPaintToContent);
 61194: 
     1:   // * link colors
     1:   mUnderlineLinks =
 70840:     Preferences::GetBool("browser.underline_anchors", mUnderlineLinks);
     1: 
 80228:   nsAdoptingString colorStr = Preferences::GetString("browser.anchor_color");
     1: 
     1:   if (!colorStr.IsEmpty()) {
     1:     mLinkColor = MakeColorPref(colorStr);
     1:   }
     1: 
 80228:   colorStr = Preferences::GetString("browser.active_color");
     1: 
     1:   if (!colorStr.IsEmpty()) {
     1:     mActiveLinkColor = MakeColorPref(colorStr);
     1:   }
     1: 
 80228:   colorStr = Preferences::GetString("browser.visited_color");
     1: 
     1:   if (!colorStr.IsEmpty()) {
     1:     mVisitedLinkColor = MakeColorPref(colorStr);
     1:   }
     1: 
     1:   mUseFocusColors =
 70840:     Preferences::GetBool("browser.display.use_focus_colors", mUseFocusColors);
     1: 
     1:   mFocusTextColor = mDefaultColor;
     1:   mFocusBackgroundColor = mBackgroundColor;
     1: 
 80228:   colorStr = Preferences::GetString("browser.display.focus_text_color");
     1: 
     1:   if (!colorStr.IsEmpty()) {
     1:     mFocusTextColor = MakeColorPref(colorStr);
     1:   }
     1: 
 80228:   colorStr = Preferences::GetString("browser.display.focus_background_color");
     1: 
     1:   if (!colorStr.IsEmpty()) {
     1:     mFocusBackgroundColor = MakeColorPref(colorStr);
     1:   }
     1: 
     1:   mFocusRingWidth =
 70842:     Preferences::GetInt("browser.display.focus_ring_width", mFocusRingWidth);
     1: 
     1:   mFocusRingOnAnything =
 70840:     Preferences::GetBool("browser.display.focus_ring_on_anything",
     1:                          mFocusRingOnAnything);
     1: 
 20177:   mFocusRingStyle =
 70842:     Preferences::GetInt("browser.display.focus_ring_style", mFocusRingStyle);
 71160: 
 71160:   mBodyTextColor = mDefaultColor;
 71160:   
     1:   // * use fonts?
     1:   mUseDocumentFonts =
 70842:     Preferences::GetInt("browser.display.use_document_fonts") != 0;
     1: 
     1:   // * replace backslashes with Yen signs? (bug 245770)
     1:   mEnableJapaneseTransform =
 70840:     Preferences::GetBool("layout.enable_japanese_specific_transform");
     1: 
 70842:   mPrefScrollbarSide = Preferences::GetInt("layout.scrollbar.side");
     1: 
 90439:   ResetCachedFontPrefs();
     1: 
     1:   // * image animation
     1:   const nsAdoptingCString& animatePref =
 70976:     Preferences::GetCString("image.animation_mode");
     1:   if (animatePref.Equals("normal"))
     1:     mImageAnimationModePref = imgIContainer::kNormalAnimMode;
     1:   else if (animatePref.Equals("none"))
     1:     mImageAnimationModePref = imgIContainer::kDontAnimMode;
     1:   else if (animatePref.Equals("once"))
     1:     mImageAnimationModePref = imgIContainer::kLoopOnceAnimMode;
 11409:   else // dynamic change to invalid value should act like it does initially
 11409:     mImageAnimationModePref = imgIContainer::kNormalAnimMode;
     1: 
     1:   PRUint32 bidiOptions = GetBidi();
     1: 
     1:   PRInt32 prefInt =
 70842:     Preferences::GetInt(IBMBIDI_TEXTDIRECTION_STR,
     1:                         GET_BIDI_OPTION_DIRECTION(bidiOptions));
     1:   SET_BIDI_OPTION_DIRECTION(bidiOptions, prefInt);
     1:   mPrefBidiDirection = prefInt;
     1: 
     1:   prefInt =
 70842:     Preferences::GetInt(IBMBIDI_TEXTTYPE_STR,
     1:                         GET_BIDI_OPTION_TEXTTYPE(bidiOptions));
     1:   SET_BIDI_OPTION_TEXTTYPE(bidiOptions, prefInt);
     1: 
     1:   prefInt =
 70842:     Preferences::GetInt(IBMBIDI_NUMERAL_STR,
     1:                         GET_BIDI_OPTION_NUMERAL(bidiOptions));
     1:   SET_BIDI_OPTION_NUMERAL(bidiOptions, prefInt);
     1: 
     1:   prefInt =
 70842:     Preferences::GetInt(IBMBIDI_SUPPORTMODE_STR,
     1:                         GET_BIDI_OPTION_SUPPORT(bidiOptions));
     1:   SET_BIDI_OPTION_SUPPORT(bidiOptions, prefInt);
     1: 
     1:   // We don't need to force reflow: either we are initializing a new
     1:   // prescontext or we are being called from UpdateAfterPreferencesChanged()
     1:   // which triggers a reflow anyway.
 80486:   SetBidi(bidiOptions, false);
     1: }
     1: 
 50433: void
 71544: nsPresContext::InvalidateThebesLayers()
 67872: {
 71544:   if (!mShell)
 71544:     return;
 67872:   nsIFrame* rootFrame = mShell->FrameManager()->GetRootFrame();
 67872:   if (rootFrame) {
 67872:     // FrameLayerBuilder caches invalidation-related values that depend on the
 67872:     // appunits-per-dev-pixel ratio, so ensure that all ThebesLayer drawing
 67872:     // is completely flushed.
103295:     rootFrame->InvalidateFrameSubtree();
 67872:   }
 71544: }
 71544: 
 71544: void
 71544: nsPresContext::AppUnitsPerDevPixelChanged()
 71544: {
 71544:   InvalidateThebesLayers();
 67872: 
 67872:   mDeviceContext->FlushFontCache();
 67872: 
 67872:   // All cached style data must be recomputed.
 67872:   if (HasCachedStyleData()) {
 80486:     MediaFeatureValuesChanged(true);
 67872:     RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
 67872:   }
 67872: }
 67872: 
 67872: void
 50433: nsPresContext::PreferenceChanged(const char* aPrefName)
     1: {
 50433:   nsDependentCString prefName(aPrefName);
 50433:   if (prefName.EqualsLiteral("layout.css.dpi") ||
 50433:       prefName.EqualsLiteral("layout.css.devPixelsPerPx")) {
  9280:     PRInt32 oldAppUnitsPerDevPixel = AppUnitsPerDevPixel();
 50433:     if (mDeviceContext->CheckDPIChange() && mShell) {
  8940:       // Re-fetch the view manager's window dimensions in case there's a deferred
  8940:       // resize which hasn't affected our mVisibleArea yet
  8940:       nscoord oldWidthAppUnits, oldHeightAppUnits;
 26050:       nsIViewManager* vm = mShell->GetViewManager();
  8940:       vm->GetWindowDimensions(&oldWidthAppUnits, &oldHeightAppUnits);
  9280:       float oldWidthDevPixels = oldWidthAppUnits/oldAppUnitsPerDevPixel;
  9280:       float oldHeightDevPixels = oldHeightAppUnits/oldAppUnitsPerDevPixel;
     1: 
  8940:       nscoord width = NSToCoordRound(oldWidthDevPixels*AppUnitsPerDevPixel());
  8940:       nscoord height = NSToCoordRound(oldHeightDevPixels*AppUnitsPerDevPixel());
     1:       vm->SetWindowDimensions(width, height);
     1: 
 67872:       AppUnitsPerDevPixelChanged();
     1:     }
     1:     return;
     1:   }
 11409:   if (StringBeginsWith(prefName, NS_LITERAL_CSTRING("font."))) {
 11409:     // Changes to font family preferences don't change anything in the
 11409:     // computed style data, so the style system won't generate a reflow
 11409:     // hint for us.  We need to do that manually.
 11409: 
 11409:     // FIXME We could probably also handle changes to
 11409:     // browser.display.auto_quality_min_font_size here, but that
 11409:     // probably also requires clearing the text run cache, so don't
 11409:     // bother (yet, anyway).
 80486:     mPrefChangePendingNeedsReflow = true;
  4032:   }
 22917:   if (StringBeginsWith(prefName, NS_LITERAL_CSTRING("bidi."))) {
 22917:     // Changes to bidi prefs need to trigger a reflow (see bug 443629)
 80486:     mPrefChangePendingNeedsReflow = true;
 22917: 
 22917:     // Changes to bidi.numeral also needs to empty the text run cache.
 22917:     // This is handled in gfxTextRunWordCache.cpp.
 22917:   }
 43347:   if (StringBeginsWith(prefName, NS_LITERAL_CSTRING("gfx.font_rendering."))) {
 43347:     // Changes to font_rendering prefs need to trigger a reflow
 80486:     mPrefChangePendingNeedsReflow = true;
 43347:   }
     1:   // we use a zero-delay timer to coalesce multiple pref updates
     1:   if (!mPrefChangedTimer)
     1:   {
     1:     mPrefChangedTimer = do_CreateInstance("@mozilla.org/timer;1");
     1:     if (!mPrefChangedTimer)
     1:       return;
     1:     mPrefChangedTimer->InitWithFuncCallback(nsPresContext::PrefChangedUpdateTimerCallback, (void*)this, 0, nsITimer::TYPE_ONE_SHOT);
     1:   }
     1: }
     1: 
     1: void
     1: nsPresContext::UpdateAfterPreferencesChanged()
     1: {
     1:   mPrefChangedTimer = nsnull;
     1: 
     1:   nsCOMPtr<nsIDocShellTreeItem> docShell(do_QueryReferent(mContainer));
     1:   if (docShell) {
     1:     PRInt32 docShellType;
     1:     docShell->GetItemType(&docShellType);
     1:     if (nsIDocShellTreeItem::typeChrome == docShellType)
     1:       return;
     1:   }
     1: 
     1:   // Initialize our state from the user preferences
     1:   GetUserPreferences();
     1: 
     1:   // update the presShell: tell it to set the preference style rules up
     1:   if (mShell) {
 80486:     mShell->SetPreferenceStyleRules(true);
     1:   }
     1: 
 71544:   InvalidateThebesLayers();
     1:   mDeviceContext->FlushFontCache();
 11409: 
 11409:   nsChangeHint hint = nsChangeHint(0);
 11409: 
 11409:   if (mPrefChangePendingNeedsReflow) {
 11409:     NS_UpdateHint(hint, NS_STYLE_HINT_REFLOW);
 11409:   }
 11409: 
 11409:   RebuildAllStyleData(hint);
     1: }
     1: 
     1: nsresult
 68668: nsPresContext::Init(nsDeviceContext* aDeviceContext)
     1: {
 37970:   NS_ASSERTION(!mInitialized, "attempt to reinit pres context");
     1:   NS_ENSURE_ARG(aDeviceContext);
     1: 
     1:   mDeviceContext = aDeviceContext;
     1:   NS_ADDREF(mDeviceContext);
     1: 
  8362:   if (mDeviceContext->SetPixelScale(mFullZoom))
  8362:     mDeviceContext->FlushFontCache();
  5249:   mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
  5249: 
 98908:   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i) {
 98908:     mImageLoaders[i].Init();
 98908:   }
 94919: 
     1:   mEventManager = new nsEventStateManager();
     1:   NS_ADDREF(mEventManager);
     1: 
 33649:   mTransitionManager = new nsTransitionManager(this);
 36615: 
 67985:   mAnimationManager = new nsAnimationManager(this);
 67985: 
 50366:   if (mDocument->GetDisplayDocument()) {
 50366:     NS_ASSERTION(mDocument->GetDisplayDocument()->GetShell() &&
 50366:                  mDocument->GetDisplayDocument()->GetShell()->GetPresContext(),
 50366:                  "Why are we being initialized?");
 50366:     mRefreshDriver = mDocument->GetDisplayDocument()->GetShell()->
 50366:       GetPresContext()->RefreshDriver();
 50366:   } else {
 52103:     nsIDocument* parent = mDocument->GetParentDocument();
 52103:     // Unfortunately, sometimes |parent| here has no presshell because
 52103:     // printing screws up things.  Assert that in other cases it does,
 52103:     // but whenever the shell is null just fall back on using our own
 52103:     // refresh driver.
 52103:     NS_ASSERTION(!parent || mDocument->IsStaticDocument() || parent->GetShell(),
 52103:                  "How did we end up with a presshell if our parent doesn't "
 52103:                  "have one?");
 52103:     if (parent && parent->GetShell()) {
 52103:       NS_ASSERTION(parent->GetShell()->GetPresContext(),
 52103:                    "How did we get a presshell?");
 52103: 
 50366:       // We don't have our container set yet at this point
 50366:       nsCOMPtr<nsISupports> ourContainer = mDocument->GetContainer();
 52103: 
 50366:       nsCOMPtr<nsIDocShellTreeItem> ourItem = do_QueryInterface(ourContainer);
 50366:       if (ourItem) {
 50366:         nsCOMPtr<nsIDocShellTreeItem> parentItem;
 50366:         ourItem->GetSameTypeParent(getter_AddRefs(parentItem));
 52103:         if (parentItem) {
 52103:           mRefreshDriver = parent->GetShell()->GetPresContext()->RefreshDriver();
 50366:         }
 50366:       }
 50366:     }
 50366: 
 50366:     if (!mRefreshDriver) {
 36615:       mRefreshDriver = new nsRefreshDriver(this);
 50366:     }
 50366:   }
 33649: 
     1:   mLangService = do_GetService(NS_LANGUAGEATOMSERVICE_CONTRACTID);
     1: 
     1:   // Register callbacks so we're notified when the preferences change
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "font.",
     1:                                 this);
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "browser.display.",
     1:                                 this);
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "browser.underline_anchors",
     1:                                 this);
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "browser.anchor_color",
     1:                                 this);
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "browser.active_color",
     1:                                 this);
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "browser.visited_color",
     1:                                 this);
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "image.animation_mode",
     1:                                 this);
     1: #ifdef IBMBIDI
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "bidi.",
     1:                                 this);
     1: #endif
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "dom.send_after_paint_to_content",
 61194:                                 this);
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "gfx.font_rendering.",
 43347:                                 this);
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "layout.css.dpi",
     1:                                 this);
 71001:   Preferences::RegisterCallback(nsPresContext::PrefChangedCallback,
 71001:                                 "layout.css.devPixelsPerPx",
 28470:                                 this);
     1: 
 78130:   nsresult rv = mEventManager->Init();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   mEventManager->SetPresContext(this);
     1: 
     1: #ifdef DEBUG
 80486:   mInitialized = true;
     1: #endif
     1: 
     1:   mBorderWidthTable[NS_STYLE_BORDER_WIDTH_THIN] = CSSPixelsToAppUnits(1);
     1:   mBorderWidthTable[NS_STYLE_BORDER_WIDTH_MEDIUM] = CSSPixelsToAppUnits(3);
     1:   mBorderWidthTable[NS_STYLE_BORDER_WIDTH_THICK] = CSSPixelsToAppUnits(5);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // Note: We don't hold a reference on the shell; it has a reference to
     1: // us
     1: void
     1: nsPresContext::SetShell(nsIPresShell* aShell)
     1: {
 23932:   if (mUserFontSet) {
 23932:     // Clear out user font set if we have one
 23932:     mUserFontSet->Destroy();
 23932:     NS_RELEASE(mUserFontSet);
 23932:   }
 23932: 
     1:   if (mShell) {
     1:     // Remove ourselves as the charset observer from the shell's doc, because
     1:     // this shell may be going away for good.
     1:     nsIDocument *doc = mShell->GetDocument();
     1:     if (doc) {
     1:       doc->RemoveCharSetObserver(this);
     1:     }
     1:   }    
     1: 
     1:   mShell = aShell;
     1: 
     1:   if (mShell) {
     1:     nsIDocument *doc = mShell->GetDocument();
     1:     NS_ASSERTION(doc, "expect document here");
     1:     if (doc) {
     1:       // Have to update PresContext's mDocument before calling any other methods.
     1:       mDocument = doc;
     1:     }
     1:     // Initialize our state from the user preferences, now that we
     1:     // have a presshell, and hence a document.
     1:     GetUserPreferences();
     1: 
     1:     if (doc) {
     1:       nsIURI *docURI = doc->GetDocumentURI();
     1: 
     1:       if (IsDynamic() && docURI) {
 79445:         bool isChrome = false;
 79445:         bool isRes = false;
     1:         docURI->SchemeIs("chrome", &isChrome);
     1:         docURI->SchemeIs("resource", &isRes);
     1: 
     1:         if (!isChrome && !isRes)
     1:           mImageAnimationMode = mImageAnimationModePref;
     1:         else
     1:           mImageAnimationMode = imgIContainer::kNormalAnimMode;
     1:       }
     1: 
     1:       if (mLangService) {
     1:         doc->AddCharSetObserver(this);
     1:         UpdateCharSet(doc->GetDocumentCharacterSet());
     1:       }
     1:     }
 37172:   } else {
 61103:     if (mTransitionManager) {
 61103:       mTransitionManager->Disconnect();
 61103:       mTransitionManager = nsnull;
 61103:     }
 67985:     if (mAnimationManager) {
 67985:       mAnimationManager->Disconnect();
 67985:       mAnimationManager = nsnull;
 67985:     }
 87356: 
 87356:     if (IsRoot()) {
 87356:       // Have to cancel our plugin geometry timer, because the
 87356:       // callback for that depends on a non-null presshell.
 87356:       static_cast<nsRootPresContext*>(this)->CancelUpdatePluginGeometryTimer();
 87356:     }
     1:   }
     1: }
     1: 
     1: void
 94919: nsPresContext::DestroyImageLoaders()
 94919: {
 94919:   // Destroy image loaders. This is important to do when frames are being
 94919:   // destroyed because imageloaders can have pointers to frames and we don't
 94919:   // want those pointers to outlive the destruction of the frame arena.
 94919:   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i) {
 94919:     mImageLoaders[i].Enumerate(destroy_loads, nsnull);
 94919:     mImageLoaders[i].Clear();
 94919:   }
 94919: }
 94919: 
 94919: void
 87091: nsPresContext::DoChangeCharSet(const nsCString& aCharSet)
 87091: {
 87091:   UpdateCharSet(aCharSet);
 87091:   mDeviceContext->FlushFontCache();
 87091:   RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
 87091: }
 87091: 
 87091: void
 87091: nsPresContext::UpdateCharSet(const nsCString& aCharSet)
     1: {
     1:   if (mLangService) {
 38492:     NS_IF_RELEASE(mLanguage);
 38492:     mLanguage = mLangService->LookupCharSet(aCharSet.get()).get();  // addrefs
 38492:     // this will be a language group (or script) code rather than a true language code
     1: 
     1:     // bug 39570: moved from nsLanguageAtomService::LookupCharSet()
 38492:     if (mLanguage == nsGkAtoms::Unicode) {
 38492:       NS_RELEASE(mLanguage);
 38492:       NS_IF_ADDREF(mLanguage = mLangService->GetLocaleLanguage()); 
     1:     }
 90439:     ResetCachedFontPrefs();
     1:   }
     1: #ifdef IBMBIDI
     1:   //ahmed
     1: 
     1:   switch (GET_BIDI_OPTION_TEXTTYPE(GetBidi())) {
     1: 
     1:     case IBMBIDI_TEXTTYPE_LOGICAL:
 80486:       SetVisualMode(false);
     1:       break;
     1: 
     1:     case IBMBIDI_TEXTTYPE_VISUAL:
 80486:       SetVisualMode(true);
     1:       break;
     1: 
     1:     case IBMBIDI_TEXTTYPE_CHARSET:
     1:     default:
     1:       SetVisualMode(IsVisualCharset(aCharSet));
     1:   }
     1: #endif // IBMBIDI
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsPresContext::Observe(nsISupports* aSubject, 
     1:                         const char* aTopic,
     1:                         const PRUnichar* aData)
     1: {
     1:   if (!nsCRT::strcmp(aTopic, "charset")) {
 87091:     nsRefPtr<CharSetChangingRunnable> runnable =
 87091:       new CharSetChangingRunnable(this, NS_LossyConvertUTF16toASCII(aData));
 87091:     return NS_DispatchToCurrentThread(runnable);
     1:   }
     1: 
     1:   NS_WARNING("unrecognized topic in nsPresContext::Observe");
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
 99197: nsPresContext*
 99197: nsPresContext::GetParentPresContext()
 60645: {
 99197:   nsIPresShell* shell = GetPresShell();
 60645:   if (shell) {
 60645:     nsIFrame* rootFrame = shell->FrameManager()->GetRootFrame();
 60645:     if (rootFrame) {
 60645:       nsIFrame* f = nsLayoutUtils::GetCrossDocParentFrame(rootFrame);
 60645:       if (f)
 60645:         return f->PresContext();
 60645:     }
 60645:   }
103505:   // Not sure if this is always strictly the parent, but it works for GetRootPresContext
103505:   // where the current pres context has no frames.
103505:   nsIDocument *doc = Document();
103505:   if (doc) {
103505:     doc = doc->GetParentDocument();
103505:     if (doc) {
103505:       shell = doc->GetShell();
103505:       if (shell) {
103505:         return shell->GetPresContext();
103505:       }
103505:     }
103505:   }
 60645:   return nsnull;
 60645: }
 60645: 
 99197: nsPresContext*
 99197: nsPresContext::GetToplevelContentDocumentPresContext()
 99197: {
 99197:   if (IsChrome())
 99197:     return nsnull;
 99197:   nsPresContext* pc = this;
 99197:   for (;;) {
 99197:     nsPresContext* parent = pc->GetParentPresContext();
 99197:     if (!parent || parent->IsChrome())
 99197:       return pc;
 99197:     pc = parent;
 99197:   }
 99197: }
 99197: 
     1: // We may want to replace this with something faster, maybe caching the root prescontext
 30514: nsRootPresContext*
 37502: nsPresContext::GetRootPresContext()
     1: {
     1:   nsPresContext* pc = this;
     1:   for (;;) {
 99197:     nsPresContext* parent = pc->GetParentPresContext();
103287:     if (!parent || parent == pc)
 60645:       break;
 60645:     pc = parent;
     1:   }
 37502:   return pc->IsRoot() ? static_cast<nsRootPresContext*>(pc) : nsnull;
     1: }
     1: 
     1: void
     1: nsPresContext::CompatibilityModeChanged()
     1: {
     1:   if (!mShell)
     1:     return;
     1: 
     1:   // enable/disable the QuirkSheet
     1:   mShell->StyleSet()->
     1:     EnableQuirkStyleSheet(CompatibilityMode() == eCompatibility_NavQuirks);
     1: }
     1: 
     1: // Helper function for setting Anim Mode on image
     1: static void SetImgAnimModeOnImgReq(imgIRequest* aImgReq, PRUint16 aMode)
     1: {
     1:   if (aImgReq) {
     1:     nsCOMPtr<imgIContainer> imgCon;
     1:     aImgReq->GetImage(getter_AddRefs(imgCon));
     1:     if (imgCon) {
     1:       imgCon->SetAnimationMode(aMode);
     1:     }
     1:   }
     1: }
     1: 
 94919:  // Enumeration call back for HashTable
 94919: static PLDHashOperator
 94919: set_animation_mode(nsIFrame* aKey, nsRefPtr<nsImageLoader>& aData, void* closure)
 94919: {
 94919:   for (nsImageLoader *loader = aData; loader;
 94919:        loader = loader->GetNextLoader()) {
 94919:     imgIRequest* imgReq = loader->GetRequest();
 94919:     SetImgAnimModeOnImgReq(imgReq, (PRUint16)NS_PTR_TO_INT32(closure));
 94919:   }
 94919:   return PL_DHASH_NEXT;
 94919: }
 94919: 
     1: // IMPORTANT: Assumption is that all images for a Presentation 
     1: // have the same Animation Mode (pavlov said this was OK)
     1: //
     1: // Walks content and set the animation mode
     1: // this is a way to turn on/off image animations
     1: void nsPresContext::SetImgAnimations(nsIContent *aParent, PRUint16 aMode)
     1: {
     1:   nsCOMPtr<nsIImageLoadingContent> imgContent(do_QueryInterface(aParent));
     1:   if (imgContent) {
     1:     nsCOMPtr<imgIRequest> imgReq;
     1:     imgContent->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
     1:                            getter_AddRefs(imgReq));
     1:     SetImgAnimModeOnImgReq(imgReq, aMode);
     1:   }
     1:   
     1:   PRUint32 count = aParent->GetChildCount();
     1:   for (PRUint32 i = 0; i < count; ++i) {
     1:     SetImgAnimations(aParent->GetChildAt(i), aMode);
     1:   }
     1: }
     1: 
 23697: void
 23697: nsPresContext::SetSMILAnimations(nsIDocument *aDoc, PRUint16 aNewMode,
 23697:                                  PRUint16 aOldMode)
 23697: {
 38869:   if (aDoc->HasAnimationController()) {
 23697:     nsSMILAnimationController* controller = aDoc->GetAnimationController();
 23697:     switch (aNewMode)
 23697:     {
 23697:       case imgIContainer::kNormalAnimMode:
 23697:       case imgIContainer::kLoopOnceAnimMode:
 23697:         if (aOldMode == imgIContainer::kDontAnimMode)
 23697:           controller->Resume(nsSMILTimeContainer::PAUSE_USERPREF);
 23697:         break;
 23697: 
 23697:       case imgIContainer::kDontAnimMode:
 23697:         if (aOldMode != imgIContainer::kDontAnimMode)
 23697:           controller->Pause(nsSMILTimeContainer::PAUSE_USERPREF);
 23697:         break;
 23697:     }
 23697:   }
 23697: }
 23697: 
     1: void
     1: nsPresContext::SetImageAnimationModeInternal(PRUint16 aMode)
     1: {
     1:   NS_ASSERTION(aMode == imgIContainer::kNormalAnimMode ||
     1:                aMode == imgIContainer::kDontAnimMode ||
     1:                aMode == imgIContainer::kLoopOnceAnimMode, "Wrong Animation Mode is being set!");
     1: 
     1:   // Image animation mode cannot be changed when rendering to a printer.
     1:   if (!IsDynamic())
     1:     return;
     1: 
 94919:   // Set the mode on the image loaders.
 94919:   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i)
 94919:     mImageLoaders[i].Enumerate(set_animation_mode, NS_INT32_TO_PTR(aMode));
 94919: 
     1:   // Now walk the content tree and set the animation mode 
 21025:   // on all the images.
     1:   if (mShell != nsnull) {
     1:     nsIDocument *doc = mShell->GetDocument();
     1:     if (doc) {
 41634:       Element *rootElement = doc->GetRootElement();
 41634:       if (rootElement) {
 41634:         SetImgAnimations(rootElement, aMode);
     1:       }
 23697:       SetSMILAnimations(doc, aMode, mImageAnimationMode);
     1:     }
     1:   }
     1: 
     1:   mImageAnimationMode = aMode;
     1: }
     1: 
     1: void
     1: nsPresContext::SetImageAnimationModeExternal(PRUint16 aMode)
     1: {
     1:   SetImageAnimationModeInternal(aMode);
     1: }
     1: 
     1: const nsFont*
 90439: nsPresContext::GetDefaultFont(PRUint8 aFontID, nsIAtom *aLanguage) const
     1: {
 90439:   const LangGroupFontPrefs *prefs = GetFontPrefsForLang(aLanguage);
 90439: 
     1:   const nsFont *font;
     1:   switch (aFontID) {
     1:     // Special (our default variable width font and fixed width font)
     1:     case kPresContext_DefaultVariableFont_ID:
 90439:       font = &prefs->mDefaultVariableFont;
     1:       break;
     1:     case kPresContext_DefaultFixedFont_ID:
 90439:       font = &prefs->mDefaultFixedFont;
     1:       break;
     1:     // CSS
     1:     case kGenericFont_serif:
 90439:       font = &prefs->mDefaultSerifFont;
     1:       break;
     1:     case kGenericFont_sans_serif:
 90439:       font = &prefs->mDefaultSansSerifFont;
     1:       break;
     1:     case kGenericFont_monospace:
 90439:       font = &prefs->mDefaultMonospaceFont;
     1:       break;
     1:     case kGenericFont_cursive:
 90439:       font = &prefs->mDefaultCursiveFont;
     1:       break;
     1:     case kGenericFont_fantasy: 
 90439:       font = &prefs->mDefaultFantasyFont;
     1:       break;
     1:     default:
     1:       font = nsnull;
     1:       NS_ERROR("invalid arg");
     1:       break;
     1:   }
     1:   return font;
     1: }
     1: 
     1: void
  4003: nsPresContext::SetFullZoom(float aZoom)
     1: {
 35581:   if (!mShell || mFullZoom == aZoom) {
  8331:     return;
  8331:   }
 67872: 
  8940:   // Re-fetch the view manager's window dimensions in case there's a deferred
  8940:   // resize which hasn't affected our mVisibleArea yet
  8940:   nscoord oldWidthAppUnits, oldHeightAppUnits;
 26050:   mShell->GetViewManager()->GetWindowDimensions(&oldWidthAppUnits, &oldHeightAppUnits);
  8940:   float oldWidthDevPixels = oldWidthAppUnits / float(mCurAppUnitsPerDevPixel);
  8940:   float oldHeightDevPixels = oldHeightAppUnits / float(mCurAppUnitsPerDevPixel);
 67872:   mDeviceContext->SetPixelScale(aZoom);
 10872: 
 37970:   NS_ASSERTION(!mSupressResizeReflow, "two zooms happening at the same time? impossible!");
 80486:   mSupressResizeReflow = true;
 10872: 
  4359:   mFullZoom = aZoom;
 26050:   mShell->GetViewManager()->
 26050:     SetWindowDimensions(NSToCoordRound(oldWidthDevPixels * AppUnitsPerDevPixel()),
  8940:                         NSToCoordRound(oldHeightDevPixels * AppUnitsPerDevPixel()));
 67872: 
 67872:   AppUnitsPerDevPixelChanged();
 10872: 
 80486:   mSupressResizeReflow = false;
 10872: 
  5249:   mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
  4359: }
     1: 
 97799: float
 97799: nsPresContext::ScreenWidthInchesForFontInflation(bool* aChanged)
 97799: {
 97799:   if (aChanged) {
 97799:     *aChanged = false;
 97799:   }
 97799: 
 97799:   nsDeviceContext *dx = DeviceContext();
 97799:   nsRect clientRect;
 97799:   dx->GetClientRect(clientRect); // FIXME: GetClientRect looks expensive
 97799:   float deviceWidthInches =
 97799:     float(clientRect.width) / float(dx->AppUnitsPerPhysicalInch());
 97799: 
101632:   if (mLastFontInflationScreenWidth == -1.0) {
101632:     mLastFontInflationScreenWidth = deviceWidthInches;
101632:   }
101632: 
101632:   if (deviceWidthInches != mLastFontInflationScreenWidth && aChanged) {
 97799:     *aChanged = true;
 97799:     mLastFontInflationScreenWidth = deviceWidthInches;
 97799:   }
 97799: 
 97799:   return deviceWidthInches;
 97799: }
 97799: 
 25231: void
 94919: nsPresContext::SetImageLoaders(nsIFrame* aTargetFrame,
 94919:                                ImageLoadType aType,
 94919:                                nsImageLoader* aImageLoaders)
 94919: {
 94919:   NS_ASSERTION(mShell || !aImageLoaders,
 94919:                "Shouldn't add new image loader after the shell is gone");
 94919: 
 94919:   nsRefPtr<nsImageLoader> oldLoaders;
 94919:   mImageLoaders[aType].Get(aTargetFrame, getter_AddRefs(oldLoaders));
 94919: 
 94919:   if (aImageLoaders) {
 94919:     mImageLoaders[aType].Put(aTargetFrame, aImageLoaders);
 94919:   } else if (oldLoaders) {
 94919:     mImageLoaders[aType].Remove(aTargetFrame);
 94919:   }
 94919: 
 94919:   if (oldLoaders)
 94919:     oldLoaders->Destroy();
 94919: }
 94919: 
 94919: void
 94919: nsPresContext::SetupBackgroundImageLoaders(nsIFrame* aFrame,
 94919:                                      const nsStyleBackground* aStyleBackground)
 94919: {
 94919:   nsRefPtr<nsImageLoader> loaders;
 94919:   NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, aStyleBackground) {
 94919:     if (aStyleBackground->mLayers[i].mImage.GetType() == eStyleImageType_Image) {
 94919:       PRUint32 actions = nsImageLoader::ACTION_REDRAW_ON_DECODE;
 94919:       imgIRequest *image = aStyleBackground->mLayers[i].mImage.GetImageData();
 94919:       loaders = nsImageLoader::Create(aFrame, image, actions, loaders);
 94919:     }
 94919:   }
 94919:   SetImageLoaders(aFrame, BACKGROUND_IMAGE, loaders);
 94919: }
 94919: 
 94919: void
 94919: nsPresContext::SetupBorderImageLoaders(nsIFrame* aFrame,
 94919:                                        const nsStyleBorder* aStyleBorder)
 94919: {
 94919:   // We get called the first time we try to draw a border-image, and
 94919:   // also when the border image changes (including when it changes from
 94919:   // non-null to null).
 94919:   imgIRequest *borderImage = aStyleBorder->GetBorderImage();
 94919:   if (!borderImage) {
 94919:     SetImageLoaders(aFrame, BORDER_IMAGE, nsnull);
 94919:     return;
 94919:   }
 94919: 
 94919:   PRUint32 actions = nsImageLoader::ACTION_REDRAW_ON_LOAD;
 94919:   nsRefPtr<nsImageLoader> loader =
 94919:     nsImageLoader::Create(aFrame, borderImage, actions, nsnull);
 94919:   SetImageLoaders(aFrame, BORDER_IMAGE, loader);
 94919: }
 94919: 
 94919: void
 94919: nsPresContext::StopImagesFor(nsIFrame* aTargetFrame)
 94919: {
 94919:   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i)
 94919:     SetImageLoaders(aTargetFrame, ImageLoadType(i), nsnull);
 94919: }
 94919: 
 94919: void
     1: nsPresContext::SetContainer(nsISupports* aHandler)
     1: {
     1:   mContainer = do_GetWeakReference(aHandler);
 42557:   InvalidateIsChromeCache();
     1:   if (mContainer) {
     1:     GetDocumentColorPreferences();
     1:   }
     1: }
     1: 
     1: already_AddRefed<nsISupports>
  8088: nsPresContext::GetContainerInternal() const
     1: {
     1:   nsISupports *result = nsnull;
     1:   if (mContainer)
     1:     CallQueryReferent(mContainer.get(), &result);
     1: 
     1:   return result;
     1: }
     1: 
     1: already_AddRefed<nsISupports>
  8088: nsPresContext::GetContainerExternal() const
     1: {
     1:   return GetContainerInternal();
     1: }
     1: 
     1: #ifdef IBMBIDI
     1: void
 15376: nsPresContext::SetBidiEnabled() const
     1: {
     1:   if (mShell) {
     1:     nsIDocument *doc = mShell->GetDocument();
     1:     if (doc) {
 15376:       doc->SetBidiEnabled();
     1:     }
     1:   }
     1: }
     1: 
     1: void
 79445: nsPresContext::SetBidi(PRUint32 aSource, bool aForceRestyle)
     1: {
     1:   // Don't do all this stuff unless the options have changed.
     1:   if (aSource == GetBidi()) {
     1:     return;
     1:   }
     1: 
 10073:   NS_ASSERTION(!(aForceRestyle && (GetBidi() == 0)), 
     1:                "ForceReflow on new prescontext");
     1: 
     1:   Document()->SetBidiOptions(aSource);
     1:   if (IBMBIDI_TEXTDIRECTION_RTL == GET_BIDI_OPTION_DIRECTION(aSource)
     1:       || IBMBIDI_NUMERAL_HINDI == GET_BIDI_OPTION_NUMERAL(aSource)) {
 15376:     SetBidiEnabled();
     1:   }
     1:   if (IBMBIDI_TEXTTYPE_VISUAL == GET_BIDI_OPTION_TEXTTYPE(aSource)) {
 80486:     SetVisualMode(true);
     1:   }
     1:   else if (IBMBIDI_TEXTTYPE_LOGICAL == GET_BIDI_OPTION_TEXTTYPE(aSource)) {
 80486:     SetVisualMode(false);
     1:   }
     1:   else {
     1:     nsIDocument* doc = mShell->GetDocument();
     1:     if (doc) {
     1:       SetVisualMode(IsVisualCharset(doc->GetDocumentCharacterSet()));
     1:     }
     1:   }
 61102:   if (aForceRestyle && mShell) {
 61102:     // Reconstruct the root document element's frame and its children,
 61102:     // because we need to trigger frame reconstruction for direction change.
 61102:     RebuildUserFontSet();
 61102:     mShell->ReconstructFrames();
     1:   }
     1: }
     1: 
     1: PRUint32
     1: nsPresContext::GetBidi() const
     1: {
     1:   return Document()->GetBidiOptions();
     1: }
 42982: 
     1: #endif //IBMBIDI
     1: 
 79445: bool
 39698: nsPresContext::IsTopLevelWindowInactive()
 39698: {
 39698:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryReferent(mContainer));
 39698:   if (!treeItem)
 80486:     return false;
 39698: 
 39698:   nsCOMPtr<nsIDocShellTreeItem> rootItem;
 39698:   treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
 39698:   nsCOMPtr<nsPIDOMWindow> domWindow(do_GetInterface(rootItem));
 39698: 
 39698:   return domWindow && !domWindow->IsActive();
 39698: }
 39698: 
     1: nsITheme*
     1: nsPresContext::GetTheme()
     1: {
 25560:   if (!sNoTheme && !mTheme) {
     1:     mTheme = do_GetService("@mozilla.org/chrome/chrome-native-theme;1");
     1:     if (!mTheme)
 80486:       sNoTheme = true;
     1:   }
     1: 
     1:   return mTheme;
     1: }
     1: 
     1: void
     1: nsPresContext::ThemeChanged()
     1: {
     1:   if (!mPendingThemeChanged) {
 80486:     sLookAndFeelChanged = true;
 80486:     sThemeChanged = true;
     1: 
     1:     nsCOMPtr<nsIRunnable> ev =
 41361:       NS_NewRunnableMethod(this, &nsPresContext::ThemeChangedInternal);
     1:     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
 80486:       mPendingThemeChanged = true;
     1:     }
     1:   }    
     1: }
     1: 
     1: void
     1: nsPresContext::ThemeChangedInternal()
     1: {
 80486:   mPendingThemeChanged = false;
     1:   
     1:   // Tell the theme that it changed, so it can flush any handles to stale theme
     1:   // data.
     1:   if (mTheme && sThemeChanged) {
     1:     mTheme->ThemeChanged();
 80486:     sThemeChanged = false;
     1:   }
     1: 
 78130:   // Clear all cached LookAndFeel colors.
 78130:   if (sLookAndFeelChanged) {
 78130:     LookAndFeel::Refresh();
 80486:     sLookAndFeelChanged = false;
     1:   }
     1: 
 16396:   // This will force the system metrics to be generated the next time they're used
 16396:   nsCSSRuleProcessor::FreeSystemMetrics();
 16396: 
 33894:   // Changes to system metrics can change media queries on them.
 80486:   MediaFeatureValuesChanged(true);
 33894: 
 11409:   // Changes in theme can change system colors (whose changes are
 11409:   // properly reflected in computed style data), system fonts (whose
 11409:   // changes are not), and -moz-appearance (whose changes likewise are
 11409:   // not), so we need to reflow.
 11409:   RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
     1: }
     1: 
     1: void
     1: nsPresContext::SysColorChanged()
     1: {
     1:   if (!mPendingSysColorChanged) {
 80486:     sLookAndFeelChanged = true;
     1:     nsCOMPtr<nsIRunnable> ev =
 41361:       NS_NewRunnableMethod(this, &nsPresContext::SysColorChangedInternal);
     1:     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
 80486:       mPendingSysColorChanged = true;
     1:     }
     1:   }
     1: }
     1: 
     1: void
     1: nsPresContext::SysColorChangedInternal()
     1: {
 80486:   mPendingSysColorChanged = false;
     1:   
 78130:   if (sLookAndFeelChanged) {
     1:      // Don't use the cached values for the system colors
 78130:     LookAndFeel::Refresh();
 80486:     sLookAndFeelChanged = false;
     1:   }
     1:    
     1:   // Reset default background and foreground colors for the document since
     1:   // they may be using system colors
     1:   GetDocumentColorPreferences();
     1: 
 11409:   // The system color values are computed to colors in the style data,
 11409:   // so normal style data comparison is sufficient here.
 11409:   RebuildAllStyleData(nsChangeHint(0));
 10073: }
 10073: 
 10073: void
 11409: nsPresContext::RebuildAllStyleData(nsChangeHint aExtraHint)
 10073: {
 10073:   if (!mShell) {
 10073:     // We must have been torn down. Nothing to do here.
 10073:     return;
 10073:   }
 21925: 
 21925:   RebuildUserFontSet();
 67985:   AnimationManager()->KeyframesListIsDirty();
 21925: 
 11409:   mShell->FrameConstructor()->RebuildAllStyleData(aExtraHint);
 10073: }
 10073: 
 10073: void
 22339: nsPresContext::PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint)
 10073: {
 10073:   if (!mShell) {
 10073:     // We must have been torn down. Nothing to do here.
 10073:     return;
 10073:   }
 22339:   mShell->FrameConstructor()->PostRebuildAllStyleDataEvent(aExtraHint);
     1: }
     1: 
     1: void
 79445: nsPresContext::MediaFeatureValuesChanged(bool aCallerWillRebuildStyleData)
 16226: {
 80486:   mPendingMediaFeatureValuesChanged = false;
 34947:   if (mShell &&
 34947:       mShell->StyleSet()->MediumFeaturesChanged(this) &&
 16226:       !aCallerWillRebuildStyleData) {
 16226:     RebuildAllStyleData(nsChangeHint(0));
 16226:   }
 68769: 
 68769:   if (!nsContentUtils::IsSafeToRunScript()) {
 68769:     NS_ABORT_IF_FALSE(mDocument->IsBeingUsedAsImage(),
 68769:                       "How did we get here?  Are we failing to notify "
 68769:                       "listeners that we should notify?");
 68769:     return;
 68769:   }
 68769: 
 68769:   // Media query list listeners should be notified from a queued task
 68769:   // (in HTML5 terms), although we also want to notify them on certain
 68769:   // flushes.  (We're already running off an event.)
 68769:   //
 68769:   // Note that we do this after the new style from media queries in
 68769:   // style sheets has been computed.
 68769: 
 68769:   if (!PR_CLIST_IS_EMPTY(&mDOMMediaQueryLists)) {
 68769:     // We build a list of all the notifications we're going to send
 68769:     // before we send any of them.  (The spec says the notifications
 68769:     // should be a queued task, so any removals that happen during the
 68769:     // notifications shouldn't affect what gets notified.)  Furthermore,
 68769:     // we hold strong pointers to everything we're going to make
 68769:     // notification calls to, since each notification involves calling
 68769:     // arbitrary script that might otherwise destroy these objects, or,
 68769:     // for that matter, |this|.
 68769:     //
 68769:     // Note that we intentionally send the notifications to media query
 68769:     // list in the order they were created and, for each list, to the
 68769:     // listeners in the order added.
 68769:     nsDOMMediaQueryList::NotifyList notifyList;
 68769:     for (PRCList *l = PR_LIST_HEAD(&mDOMMediaQueryLists);
 68769:          l != &mDOMMediaQueryLists; l = PR_NEXT_LINK(l)) {
 68769:       nsDOMMediaQueryList *mql = static_cast<nsDOMMediaQueryList*>(l);
 68769:       mql->MediumFeaturesChanged(notifyList);
 68769:     }
 68769: 
 68833:     if (!notifyList.IsEmpty()) {
 68833:       nsPIDOMWindow *win = mDocument->GetInnerWindow();
 72326:       nsCOMPtr<nsIDOMEventTarget> et = do_QueryInterface(win);
 68833:       nsCxPusher pusher;
 68833: 
 68769:       for (PRUint32 i = 0, i_end = notifyList.Length(); i != i_end; ++i) {
 68833:         if (pusher.RePush(et)) {
 94651:           nsAutoMicroTask mt;
 68769:           nsDOMMediaQueryList::HandleChangeData &d = notifyList[i];
 68769:           d.listener->HandleChange(d.mql);
 68769:         }
 68833:       }
 68833:     }
 68769: 
 68769:     // NOTE:  When |notifyList| goes out of scope, our destructor could run.
 68769:   }
 16226: }
 16226: 
 16226: void
 16226: nsPresContext::PostMediaFeatureValuesChangedEvent()
 16226: {
 68769:   // FIXME: We should probably replace this event with use of
 68769:   // nsRefreshDriver::AddStyleFlushObserver (except the pres shell would
 68769:   // need to track whether it's been added).
 16226:   if (!mPendingMediaFeatureValuesChanged) {
 16226:     nsCOMPtr<nsIRunnable> ev =
 41361:       NS_NewRunnableMethod(this, &nsPresContext::HandleMediaFeatureValuesChangedEvent);
 16226:     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
 80486:       mPendingMediaFeatureValuesChanged = true;
 84597:       mDocument->SetNeedStyleFlush();
 16226:     }
 16226:   }
 16226: }
 16226: 
 16226: void
 16226: nsPresContext::HandleMediaFeatureValuesChangedEvent()
 16226: {
 16226:   // Null-check mShell in case the shell has been destroyed (and the
 16226:   // event is the only thing holding the pres context alive).
 16226:   if (mPendingMediaFeatureValuesChanged && mShell) {
 80486:     MediaFeatureValuesChanged(false);
 16226:   }
 16226: }
 16226: 
 16226: void
 68769: nsPresContext::MatchMedia(const nsAString& aMediaQueryList,
 68769:                           nsIDOMMediaQueryList** aResult)
 68769: {
 68769:   nsRefPtr<nsDOMMediaQueryList> result =
 68769:     new nsDOMMediaQueryList(this, aMediaQueryList);
 68769: 
 68769:   // Insert the new item at the end of the linked list.
 68769:   PR_INSERT_BEFORE(result, &mDOMMediaQueryLists);
 68769: 
 68769:   result.forget(aResult);
 68769: }
 68769: 
 68769: void
 79445: nsPresContext::SetPaginatedScrolling(bool aPaginated)
     1: {
     1:   if (mType == eContext_PrintPreview || mType == eContext_PageLayout)
     1:     mCanPaginatedScroll = aPaginated;
     1: }
     1: 
     1: void
     1: nsPresContext::SetPrintSettings(nsIPrintSettings *aPrintSettings)
     1: {
     1:   if (mMedium == nsGkAtoms::print)
     1:     mPrintSettings = aPrintSettings;
     1: }
     1: 
 79445: bool
 29018: nsPresContext::EnsureVisible()
     1: {
     1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
     1:   if (docShell) {
     1:     nsCOMPtr<nsIContentViewer> cv;
     1:     docShell->GetContentViewer(getter_AddRefs(cv));
     1:     // Make sure this is the content viewer we belong with
 80401:     if (cv) {
 40039:       nsRefPtr<nsPresContext> currentPresContext;
 80401:       cv->GetPresContext(getter_AddRefs(currentPresContext));
     1:       if (currentPresContext == this) {
 29018:         // OK, this is us.  We want to call Show() on the content viewer.
101068:         nsresult result = cv->Show();
101068:         if (NS_SUCCEEDED(result)) {
 80486:           return true;
     1:         }
     1:       }
     1:     }
101068:   }
 80486:   return false;
     1: }
     1: 
     1: #ifdef MOZ_REFLOW_PERF
     1: void
     1: nsPresContext::CountReflows(const char * aName, nsIFrame * aFrame)
     1: {
     1:   if (mShell) {
     1:     mShell->CountReflows(aName, aFrame);
     1:   }
     1: }
     1: #endif
  1540: 
 79445: bool
 42557: nsPresContext::IsChromeSlow() const
  1540: {
 79445:   bool isChrome = false;
  1540:   nsCOMPtr<nsISupports> container = GetContainer();
  1540:   if (container) {
  1540:     nsresult result;
  1540:     nsCOMPtr<nsIDocShellTreeItem> docShell(do_QueryInterface(container, &result));
  1540:     if (NS_SUCCEEDED(result) && docShell) {
  1540:       PRInt32 docShellType;
  1540:       result = docShell->GetItemType(&docShellType);
  1540:       if (NS_SUCCEEDED(result)) {
  1540:         isChrome = nsIDocShellTreeItem::typeChrome == docShellType;
  1540:       }
  1540:     }
  1540:   }
 40739:   mIsChrome = isChrome;
 80486:   mIsChromeIsCached = true;
 40739:   return mIsChrome;
 40739: }
 40739: 
 40739: void
 40739: nsPresContext::InvalidateIsChromeCacheExternal()
 40739: {
 40739:   InvalidateIsChromeCacheInternal();
  1540: }
  1540: 
 79445: /* virtual */ bool
 42557: nsPresContext::HasAuthorSpecifiedRules(nsIFrame *aFrame, PRUint32 ruleTypeMask) const
  6734: {
 23377:   return
 23377:     nsRuleNode::HasAuthorSpecifiedRules(aFrame->GetStyleContext(),
 29282:                                         ruleTypeMask,
 29282:                                         UseDocumentColors());
  6734: }
 19380: 
 21924: gfxUserFontSet*
 22335: nsPresContext::GetUserFontSetInternal()
 19962: {
 21925:   // We want to initialize the user font set lazily the first time the
 21925:   // user asks for it, rather than building it too early and forcing
 21925:   // rule cascade creation.  Thus we try to enforce the invariant that
 21925:   // we *never* build the user font set until the first call to
 21925:   // GetUserFontSet.  However, once it's been requested, we can't wait
 21925:   // for somebody to call GetUserFontSet in order to rebuild it (see
 21925:   // comments below in RebuildUserFontSet for why).
 24321: #ifdef DEBUG
 79445:   bool userFontSetGottenBefore = mGetUserFontSetCalled;
 24321: #endif
 24321:   // Set mGetUserFontSetCalled up front, so that FlushUserFontSet will actually
 24321:   // flush.
 80486:   mGetUserFontSetCalled = true;
 21924:   if (mUserFontSetDirty) {
 21925:     // If this assertion fails, and there have actually been changes to
 21925:     // @font-face rules, then we will call StyleChangeReflow in
 22033:     // FlushUserFontSet.  If we're in the middle of reflow,
 22033:     // that's a bad thing to do, and the caller was responsible for
 22033:     // flushing first.  If we're not (e.g., in frame construction), it's
 22033:     // ok.
 40048:     NS_ASSERTION(!userFontSetGottenBefore || !mShell->IsReflowLocked(),
 21925:                  "FlushUserFontSet should have been called first");
 21925:     FlushUserFontSet();
 21925:   }
 21924: 
 21925:   return mUserFontSet;
 21925: }
 21925: 
 22335: gfxUserFontSet*
 22335: nsPresContext::GetUserFontSetExternal()
 22335: {
 22335:   return GetUserFontSetInternal();
 22335: }
 22335: 
 21925: void
 21925: nsPresContext::FlushUserFontSet()
 21925: {
 68402:   if (!mShell) {
 21925:     return; // we've been torn down
 68402:   }
 21925: 
 24321:   if (!mGetUserFontSetCalled) {
 24321:     return; // No one cares about this font set yet, but we want to be careful
 24321:             // to not unset our mUserFontSetDirty bit, so when someone really
 24321:             // does we'll create it.
 24321:   }
 24321: 
 21925:   if (mUserFontSetDirty) {
 21924:     if (gfxPlatform::GetPlatform()->DownloadableFontsEnabled()) {
 21983:       nsTArray<nsFontFaceRuleContainer> rules;
 68402:       if (!mShell->StyleSet()->AppendFontFaceRules(this, rules)) {
 23932:         if (mUserFontSet) {
 23932:           mUserFontSet->Destroy();
 23932:           NS_RELEASE(mUserFontSet);
 23932:         }
 21925:         return;
 68006:       }
 68006: 
 79445:       bool changed = false;
 68010: 
 68402:       if (rules.Length() == 0) {
 68402:         if (mUserFontSet) {
 68402:           mUserFontSet->Destroy();
 68402:           NS_RELEASE(mUserFontSet);
 80486:           changed = true;
 68402:         }
 68402:       } else {
 68402:         if (!mUserFontSet) {
 68402:           mUserFontSet = new nsUserFontSet(this);
 68402:           NS_ADDREF(mUserFontSet);
 68402:         }
 68402:         changed = mUserFontSet->UpdateRules(rules);
 68402:       }
 68402: 
 21925:       // We need to enqueue a style change reflow (for later) to
 68402:       // reflect that we're modifying @font-face rules.  (However,
 22507:       // without a reflow, nothing will happen to start any downloads
 22507:       // that are needed.)
 68402:       if (changed) {
 22507:         UserFontSetUpdated();
 21925:       }
 21925:     }
 21925: 
 80486:     mUserFontSetDirty = false;
 21924:   }
 21925: }
 21925: 
 21925: void
 21925: nsPresContext::RebuildUserFontSet()
 21925: {
 21925:   if (!mGetUserFontSetCalled) {
 21925:     // We want to lazily build the user font set the first time it's
 21925:     // requested (so we don't force creation of rule cascades too
 21925:     // early), so don't do anything now.
 21925:     return;
 21925:   }
 21925: 
 80486:   mUserFontSetDirty = true;
 84597:   mDocument->SetNeedStyleFlush();
 21925: 
 21925:   // Somebody has already asked for the user font set, so we need to
 21925:   // post an event to rebuild it.  Setting the user font set to be dirty
 21925:   // and lazily rebuilding it isn't sufficient, since it is only the act
 21925:   // of rebuilding it that will trigger the style change reflow that
 21925:   // calls GetUserFontSet.  (This reflow causes rebuilding of text runs,
 21925:   // which starts font loads, whose completion causes another style
 21925:   // change reflow).
 21925:   if (!mPostedFlushUserFontSet) {
 21925:     nsCOMPtr<nsIRunnable> ev =
 41361:       NS_NewRunnableMethod(this, &nsPresContext::HandleRebuildUserFontSet);
 21925:     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
 80486:       mPostedFlushUserFontSet = true;
 21925:     }
 21925:   }    
 19962: }
 19962: 
 19380: void
 22507: nsPresContext::UserFontSetUpdated()
 22507: {
 22507:   if (!mShell)
 22507:     return;
 22507: 
 22507:   // Changes to the set of available fonts can cause updates to layout by:
 22507:   //
 22507:   //   1. Changing the font used for text, which changes anything that
 22507:   //      depends on text measurement, including line breaking and
 22507:   //      intrinsic widths, and any other parts of layout that depend on
 22507:   //      font metrics.  This requires a style change reflow to update.
 22507:   //
 22507:   //   2. Changing the value of the 'ex' and 'ch' units in style data,
 22507:   //      which also depend on font metrics.  Updating this information
 22507:   //      requires rebuilding the rule tree from the top, avoiding the
 22507:   //      reuse of cached data even when no style rules have changed.
 22507: 
 22507:   PostRebuildAllStyleDataEvent(NS_STYLE_HINT_REFLOW);
 22507: }
 22507: 
 79445: bool
 36786: nsPresContext::EnsureSafeToHandOutCSSRules()
 36786: {
 36786:   nsCSSStyleSheet::EnsureUniqueInnerResult res =
 36786:     mShell->StyleSet()->EnsureUniqueInnerOnCSSSheets();
 36786:   if (res == nsCSSStyleSheet::eUniqueInner_AlreadyUnique) {
 36786:     // Nothing to do.
 80486:     return true;
 36786:   }
 36786:   if (res == nsCSSStyleSheet::eUniqueInner_CloneFailed) {
 80486:     return false;
 36786:   }
 36786: 
 36786:   NS_ABORT_IF_FALSE(res == nsCSSStyleSheet::eUniqueInner_ClonedInner,
 36786:                     "unexpected result");
 36786:   RebuildAllStyleData(nsChangeHint(0));
 80486:   return true;
 36786: }
 36786: 
 22507: void
 19380: nsPresContext::FireDOMPaintEvent()
 19380: {
 29465:   nsPIDOMWindow* ourWindow = mDocument->GetWindow();
 20515:   if (!ourWindow)
 19380:     return;
 20515: 
 29465:   nsCOMPtr<nsIDOMEventTarget> dispatchTarget = do_QueryInterface(ourWindow);
 29465:   nsCOMPtr<nsIDOMEventTarget> eventTarget = dispatchTarget;
103295:   if (!IsChrome() && !mSendAfterPaintToContent) {
 19380:     // Don't tell the window about this event, it should not know that
 19380:     // something happened in a subdocument. Tell only the chrome event handler.
 19380:     // (Events sent to the window get propagated to the chrome event handler
 19380:     // automatically.)
 59493:     dispatchTarget = do_QueryInterface(ourWindow->GetParentTarget());
 29465:     if (!dispatchTarget) {
 20618:       return;
 20618:     }
 19380:   }
 19380:   // Events sent to the window get propagated to the chrome event handler
 19380:   // automatically.
 29465:   nsCOMPtr<nsIDOMEvent> event;
 32894:   // This will empty our list in case dispatching the event causes more damage
 32894:   // (hopefully it won't, or we're likely to get an infinite loop! At least
 32894:   // it won't be blocking app execution though).
 29465:   NS_NewDOMNotifyPaintEvent(getter_AddRefs(event), this, nsnull,
 29465:                             NS_AFTERPAINT,
 32894:                             &mInvalidateRequests);
103314:   mAllInvalidated = false;
101616:   if (!event) {
101616:     return;
101616:   }
 19380: 
 19380:   // Even if we're not telling the window about the event (so eventTarget is
 19380:   // the chrome event handler, not the window), the window is still
 19380:   // logically the event target.
101616:   event->SetTarget(eventTarget);
101616:   event->SetTrusted(true);
 29465:   nsEventDispatcher::DispatchDOMEvent(dispatchTarget, nsnull, event, this, nsnull);
 19380: }
 19380: 
 79445: static bool
103295: MayHavePaintEventListenerSubdocumentCallback(nsIDocument* aDocument, void* aData)
103295: {
103295:   bool *result = static_cast<bool*>(aData);
103295:   nsIPresShell* shell = aDocument->GetShell();
103295:   if (shell) {
103295:     nsPresContext* pc = shell->GetPresContext();
103295:     if (pc) {
103295:       *result = pc->MayHavePaintEventListenerInSubDocument();
103295: 
103295:       // If we found a paint event listener, then we can stop enumerating
103295:       // sub documents.
103295:       return !*result;
103295:     }
103295:   }
103295:   return true;
103295: }
103295: 
103295: static bool
 32894: MayHavePaintEventListener(nsPIDOMWindow* aInnerWindow)
 20515: {
 20515:   if (!aInnerWindow)
 80486:     return false;
 20515:   if (aInnerWindow->HasPaintEventListeners())
 80486:     return true;
 20515: 
 72326:   nsIDOMEventTarget* parentTarget = aInnerWindow->GetParentTarget();
 43680:   if (!parentTarget)
 80486:     return false;
 20515: 
 72328:   nsEventListenerManager* manager = nsnull;
 80486:   if ((manager = parentTarget->GetListenerManager(false)) &&
 42412:       manager->MayHavePaintEventListener()) {
 80486:     return true;
 42412:   }
 43680: 
 43680:   nsCOMPtr<nsINode> node;
 43680:   if (parentTarget != aInnerWindow->GetChromeEventHandler()) {
 43680:     nsCOMPtr<nsIInProcessContentFrameMessageManager> mm =
 43680:       do_QueryInterface(parentTarget);
 43680:     if (mm) {
 42412:       node = mm->GetOwnerContent();
 42412:     }
 43680:   }
 42412: 
 42412:   if (!node) {
 43680:     node = do_QueryInterface(parentTarget);
 42412:   }
 20515:   if (node)
 80526:     return MayHavePaintEventListener(node->OwnerDoc()->GetInnerWindow());
 20515: 
 43680:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(parentTarget);
 20515:   if (window)
 20515:     return MayHavePaintEventListener(window);
 20515: 
 46960:   nsCOMPtr<nsPIWindowRoot> root = do_QueryInterface(parentTarget);
 72326:   nsIDOMEventTarget* tabChildGlobal;
 46960:   return root &&
 46960:          (tabChildGlobal = root->GetParentTarget()) &&
 80486:          (manager = tabChildGlobal->GetListenerManager(false)) &&
 46960:          manager->MayHavePaintEventListener();
 20515: }
 20515: 
 79445: bool
 32894: nsPresContext::MayHavePaintEventListener()
 32894: {
 32894:   return ::MayHavePaintEventListener(mDocument->GetInnerWindow());
 32894: }
 32894: 
103295: bool
103295: nsPresContext::MayHavePaintEventListenerInSubDocument()
103295: {
103295:   if (MayHavePaintEventListener()) {
103295:     return true;
103295:   }
103295: 
103295:   bool result = false;
103295:   mDocument->EnumerateSubDocuments(MayHavePaintEventListenerSubdocumentCallback, &result);
103295:   return result;
103295: }
103295: 
103295: void
103314: nsPresContext::NotifyInvalidation(PRUint32 aFlags)
103314: {
103314:   nsIFrame* rootFrame = PresShell()->FrameManager()->GetRootFrame();
103314:   NotifyInvalidation(rootFrame->GetVisualOverflowRect(), aFlags);
103314:   mAllInvalidated = true;
103314: }
103314: 
103314: void
103295: nsPresContext::NotifyInvalidation(const nsIntRect& aRect, PRUint32 aFlags)
103295: {
103295:   nsRect rect(DevPixelsToAppUnits(aRect.x),
103295:               DevPixelsToAppUnits(aRect.y),
103295:               DevPixelsToAppUnits(aRect.width),
103295:               DevPixelsToAppUnits(aRect.height));
103295:   NotifyInvalidation(rect, aFlags);
103295: }
103295: 
 19380: void
 32894: nsPresContext::NotifyInvalidation(const nsRect& aRect, PRUint32 aFlags)
 19380: {
 20515:   // If there is no paint event listener, then we don't need to fire
 20515:   // the asynchronous event. We don't even need to record invalidation.
 20515:   // MayHavePaintEventListener is pretty cheap and we could make it
 20515:   // even cheaper by providing a more efficient
 20515:   // nsPIDOMWindow::GetListenerManager.
 19380:   
103314:   if (mAllInvalidated) {
103314:     return;
103314:   }
103314: 
 60645:   nsPresContext* pc;
 99197:   for (pc = this; pc; pc = pc->GetParentPresContext()) {
 60645:     if (pc->mFireAfterPaintEvents)
 60645:       break;
 80486:     pc->mFireAfterPaintEvents = true;
 60645:   }
 60645:   if (!pc) {
 60645:     nsRootPresContext* rpc = GetRootPresContext();
 60645:     if (rpc) {
 60645:       rpc->EnsureEventualDidPaintEvent();
 60645:     }
 19380:   }
 19380: 
 32894:   nsInvalidateRequestList::Request* request =
 32894:     mInvalidateRequests.mRequests.AppendElement();
 32894:   if (!request)
 32894:     return;
 32894: 
 32894:   request->mRect = aRect;
 32894:   request->mFlags = aFlags;
 19380: }
 23163: 
103295: /* static */ void 
103295: nsPresContext::NotifySubDocInvalidation(ContainerLayer* aContainer,
103295:                                         const nsIntRegion& aRegion)
103295: {
103295:   ContainerLayerPresContext *data = 
103295:     static_cast<ContainerLayerPresContext*>(
103295:       aContainer->GetUserData(&gNotifySubDocInvalidationData));
103295:   if (!data) {
103295:     return;
103295:   }
103295: 
103295:   nsIntPoint topLeft = aContainer->GetVisibleRegion().GetBounds().TopLeft();
103295: 
103295:   nsIntRegionRectIterator iter(aRegion);
103295:   while (const nsIntRect* r = iter.Next()) {
103295:     nsIntRect rect = *r;
103295:     //PresContext coordinate space is relative to the start of our visible
103295:     // region. Is this really true? This feels like the wrong way to get the right
103295:     // answer.
103295:     rect.MoveBy(-topLeft);
103295:     data->mPresContext->NotifyInvalidation(rect, 0);
103295:   }
103295: }
103295: 
 79445: static bool
 60645: NotifyDidPaintSubdocumentCallback(nsIDocument* aDocument, void* aData)
 60645: {
 60645:   nsIPresShell* shell = aDocument->GetShell();
 60645:   if (shell) {
 60645:     nsPresContext* pc = shell->GetPresContext();
 60645:     if (pc) {
 60645:       pc->NotifyDidPaintForSubtree();
 60645:     }
 60645:   }
 80486:   return true;
 60645: }
 60645: 
 60645: void
 60645: nsPresContext::NotifyDidPaintForSubtree()
 60645: {
103295:   if (IsRoot()) {
 60645:     if (!mFireAfterPaintEvents)
 60645:       return;
103295: 
101655:     static_cast<nsRootPresContext*>(this)->CancelDidPaintTimer();
101655:   }
101655: 
103295:   mFireAfterPaintEvents = false;
103295: 
 60645:   nsCOMPtr<nsIRunnable> ev =
 60645:     NS_NewRunnableMethod(this, &nsPresContext::FireDOMPaintEvent);
 60645:   nsContentUtils::AddScriptRunner(ev);
 60645: 
 60645:   mDocument->EnumerateSubDocuments(NotifyDidPaintSubdocumentCallback, nsnull);
 60645: }
 60645: 
 79445: bool
 23163: nsPresContext::HasCachedStyleData()
 23163: {
 23163:   return mShell && mShell->StyleSet()->HasCachedStyleData();
 23163: }
 27993: 
 79445: static bool sGotInterruptEnv = false;
 27993: enum InterruptMode {
 27993:   ModeRandom,
 27993:   ModeCounter,
 27993:   ModeEvent
 27993: };
 33393: // Controlled by the GECKO_REFLOW_INTERRUPT_MODE env var; allowed values are
 33393: // "random" (except on Windows) or "counter".  If neither is used, the mode is
 33393: // ModeEvent.
 27993: static InterruptMode sInterruptMode = ModeEvent;
 33393: // Used for the "random" mode.  Controlled by the GECKO_REFLOW_INTERRUPT_SEED
 33393: // env var.
 33393: static PRUint32 sInterruptSeed = 1;
 33393: // Used for the "counter" mode.  This is the number of unskipped interrupt
 33393: // checks that have to happen before we interrupt.  Controlled by the
 33393: // GECKO_REFLOW_INTERRUPT_FREQUENCY env var.
 33393: static PRUint32 sInterruptMaxCounter = 10;
 33393: // Used for the "counter" mode.  This counts up to sInterruptMaxCounter and is
 33393: // then reset to 0.
 27993: static PRUint32 sInterruptCounter;
 33393: // Number of interrupt checks to skip before really trying to interrupt.
 33393: // Controlled by the GECKO_REFLOW_INTERRUPT_CHECKS_TO_SKIP env var.
 33393: static PRUint32 sInterruptChecksToSkip = 200;
 33393: // Number of milliseconds that a reflow should be allowed to run for before we
 33393: // actually allow interruption.  Controlled by the
 80230: // GECKO_REFLOW_MIN_NOINTERRUPT_DURATION env var.  Can't be initialized here,
 80230: // because TimeDuration/TimeStamp is not safe to use in static constructors..
 80230: static TimeDuration sInterruptTimeout;
 27993: 
 27993: static void GetInterruptEnv()
 27993: {
 27993:   char *ev = PR_GetEnv("GECKO_REFLOW_INTERRUPT_MODE");
 27993:   if (ev) {
 27993: #ifndef XP_WIN
 27993:     if (PL_strcasecmp(ev, "random") == 0) {
 27993:       ev = PR_GetEnv("GECKO_REFLOW_INTERRUPT_SEED");
 27993:       if (ev) {
 27993:         sInterruptSeed = atoi(ev);
 27993:       }
 27993:       srandom(sInterruptSeed);
 27993:       sInterruptMode = ModeRandom;
 27993:     } else
 27993: #endif
 27993:       if (PL_strcasecmp(ev, "counter") == 0) {
 27993:       ev = PR_GetEnv("GECKO_REFLOW_INTERRUPT_FREQUENCY");
 27993:       if (ev) {
 27993:         sInterruptMaxCounter = atoi(ev);
 27993:       }
 27993:       sInterruptCounter = 0;
 27993:       sInterruptMode = ModeCounter;
 27993:     }
 27993:   }
 27993:   ev = PR_GetEnv("GECKO_REFLOW_INTERRUPT_CHECKS_TO_SKIP");
 27993:   if (ev) {
 27993:     sInterruptChecksToSkip = atoi(ev);
 27993:   }
 33393: 
 33393:   ev = PR_GetEnv("GECKO_REFLOW_MIN_NOINTERRUPT_DURATION");
 80230:   int duration_ms = ev ? atoi(ev) : 100;
 80230:   sInterruptTimeout = TimeDuration::FromMilliseconds(duration_ms);
 27993: }
 27993: 
 79445: bool
 27993: nsPresContext::HavePendingInputEvent()
 27993: {
 27993:   switch (sInterruptMode) {
 27993: #ifndef XP_WIN
 27993:     case ModeRandom:
 27993:       return (random() & 1);
 27993: #endif
 27993:     case ModeCounter:
 27993:       if (sInterruptCounter < sInterruptMaxCounter) {
 27993:         ++sInterruptCounter;
 80486:         return false;
 27993:       }
 27993:       sInterruptCounter = 0;
 80486:       return true;
 27993:     default:
 27993:     case ModeEvent: {
 27993:       nsIFrame* f = PresShell()->GetRootFrame();
 27993:       if (f) {
 47148:         nsIWidget* w = f->GetNearestWidget();
 27993:         if (w) {
 27993:           return w->HasPendingInputEvent();
 27993:         }
 27993:       }
 80486:       return false;
 27993:     }
 27993:   }
 27993: }
 27993: 
 27993: void
 79445: nsPresContext::ReflowStarted(bool aInterruptible)
 27993: {
 33393: #ifdef NOISY_INTERRUPTIBLE_REFLOW
 33393:   if (!aInterruptible) {
 33393:     printf("STARTING NONINTERRUPTIBLE REFLOW\n");
 33393:   }
 33393: #endif
 27993:   // We don't support interrupting in paginated contexts, since page
 27993:   // sequences only handle initial reflow
 27993:   mInterruptsEnabled = aInterruptible && !IsPaginated();
 27993: 
 27993:   // Don't set mHasPendingInterrupt based on HavePendingInputEvent() here.  If
 27993:   // we ever change that, then we need to update the code in
 27993:   // PresShell::DoReflow to only add the just-reflown root to dirty roots if
 27993:   // it's actually dirty.  Otherwise we can end up adding a root that has no
 27993:   // interruptible descendants, just because we detected an interrupt at reflow
 27993:   // start.
 80486:   mHasPendingInterrupt = false;
 27993: 
 27993:   mInterruptChecksToSkip = sInterruptChecksToSkip;
 33393: 
 33393:   if (mInterruptsEnabled) {
 33393:     mReflowStartTime = TimeStamp::Now();
 33393:   }
 27993: }
 27993: 
 79445: bool
 27993: nsPresContext::CheckForInterrupt(nsIFrame* aFrame)
 27993: {
 27993:   if (mHasPendingInterrupt) {
 27993:     mShell->FrameNeedsToContinueReflow(aFrame);
 80486:     return true;
 27993:   }
 27993: 
 27993:   if (!sGotInterruptEnv) {
 80486:     sGotInterruptEnv = true;
 27993:     GetInterruptEnv();
 27993:   }
 27993: 
 27993:   if (!mInterruptsEnabled) {
 80486:     return false;
 27993:   }
 27993: 
 27993:   if (mInterruptChecksToSkip > 0) {
 27993:     --mInterruptChecksToSkip;
 80486:     return false;
 27993:   }
 27993:   mInterruptChecksToSkip = sInterruptChecksToSkip;
 27993: 
 33393:   // Don't interrupt if it's been less than sInterruptTimeout since we started
 33393:   // the reflow.
 33393:   mHasPendingInterrupt =
 33393:     TimeStamp::Now() - mReflowStartTime > sInterruptTimeout &&
 33393:     HavePendingInputEvent() &&
 33393:     !IsChrome();
 27993:   if (mHasPendingInterrupt) {
 27993: #ifdef NOISY_INTERRUPTIBLE_REFLOW
 27993:     printf("*** DETECTED pending interrupt (time=%lld)\n", PR_Now());
 27993: #endif /* NOISY_INTERRUPTIBLE_REFLOW */
 27993:     mShell->FrameNeedsToContinueReflow(aFrame);
 27993:   }
 27993:   return mHasPendingInterrupt;
 27993: }
 30514: 
 91689: size_t
 91689: nsPresContext::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const
 91689: {
 91689:   return mPropertyTable.SizeOfExcludingThis(aMallocSizeOf);
 91689:          mLangGroupFontPrefs.SizeOfExcludingThis(aMallocSizeOf);
 91689: 
 91689:   // Measurement of other members may be added later if DMD finds it is
 91689:   // worthwhile.
 91689: }
 91689: 
 79445: bool
 52488: nsPresContext::IsRootContentDocument()
 52488: {
 55262:   // We are a root content document if: we are not a resource doc, we are
 55262:   // not chrome, and we either have no parent or our parent is chrome.
 55262:   if (mDocument->IsResourceDoc()) {
 80486:     return false;
 55262:   }
 52488:   if (IsChrome()) {
 80486:     return false;
 52488:   }
 52488:   // We may not have a root frame, so use views.
 64435:   nsIView* view = PresShell()->GetViewManager()->GetRootView();
 64435:   if (!view) {
 80486:     return false;
 52488:   }
 52488:   view = view->GetParent(); // anonymous inner view
 52488:   if (!view) {
 80486:     return true;
 52488:   }
 52488:   view = view->GetParent(); // subdocumentframe's view
 52488:   if (!view) {
 80486:     return true;
 52488:   }
 52488: 
 82566:   nsIFrame* f = view->GetFrame();
 52488:   return (f && f->PresContext()->IsChrome());
 52488: }
 52488: 
 30514: nsRootPresContext::nsRootPresContext(nsIDocument* aDocument,
 30514:                                      nsPresContextType aType)
 47756:   : nsPresContext(aDocument, aType),
 47756:     mUpdatePluginGeometryForFrame(nsnull),
 54261:     mDOMGeneration(0),
 80486:     mNeedsToUpdatePluginGeometry(false)
 30514: {
 30522:   mRegisteredPlugins.Init();
 30514: }
 30522: 
 30522: nsRootPresContext::~nsRootPresContext()
 30522: {
 30522:   NS_ASSERTION(mRegisteredPlugins.Count() == 0,
 30522:                "All plugins should have been unregistered");
 60645:   CancelDidPaintTimer();
 87356:   CancelUpdatePluginGeometryTimer();
 30522: }
 30522: 
 30522: void
 30522: nsRootPresContext::RegisterPluginForGeometryUpdates(nsObjectFrame* aPlugin)
 30522: {
 30522:   mRegisteredPlugins.PutEntry(aPlugin);
 30522: }
 30522: 
 30522: void
 30522: nsRootPresContext::UnregisterPluginForGeometryUpdates(nsObjectFrame* aPlugin)
 30522: {
 30522:   mRegisteredPlugins.RemoveEntry(aPlugin);
 30522: }
 30522: 
 30522: struct PluginGeometryClosure {
 30522:   nsIFrame* mRootFrame;
 47902:   PRInt32   mRootAPD;
 30522:   nsIFrame* mChangedSubtree;
 30522:   nsRect    mChangedRect;
 30522:   nsTHashtable<nsPtrHashKey<nsObjectFrame> > mAffectedPlugins;
 30522:   nsRect    mAffectedPluginBounds;
 30522:   nsTArray<nsIWidget::Configuration>* mOutputConfigurations;
 30522: };
 30522: static PLDHashOperator
 30522: PluginBoundsEnumerator(nsPtrHashKey<nsObjectFrame>* aEntry, void* userArg)
 30522: {
 30522:   PluginGeometryClosure* closure = static_cast<PluginGeometryClosure*>(userArg);
 30522:   nsObjectFrame* f = aEntry->GetKey();
 30522:   nsRect fBounds = f->GetContentRect() +
 47902:       f->GetParent()->GetOffsetToCrossDoc(closure->mRootFrame);
 47902:   PRInt32 APD = f->PresContext()->AppUnitsPerDevPixel();
 47902:   fBounds = fBounds.ConvertAppUnitsRoundOut(APD, closure->mRootAPD);
 30522:   // We're identifying the plugins that may have been affected by changes
 30522:   // to the frame subtree rooted at aChangedRoot. Any plugin that overlaps
 30522:   // the overflow area of aChangedRoot could have its clip region affected
 30522:   // because it might be covered (or uncovered) by changes to the subtree.
 30522:   // Plugins in the subtree might have changed position and/or size, and
 30522:   // they might not be in aChangedRoot's overflow area (because they're
 30522:   // being clipped by an ancestor in the subtree).
 30522:   if (fBounds.Intersects(closure->mChangedRect) ||
 30522:       nsLayoutUtils::IsAncestorFrameCrossDoc(closure->mChangedSubtree, f)) {
 30522:     closure->mAffectedPluginBounds.UnionRect(
 30522:         closure->mAffectedPluginBounds, fBounds);
 30522:     closure->mAffectedPlugins.PutEntry(f);
 30522:   }
 30522:   return PL_DHASH_NEXT;
 30522: }
 30522: 
 30522: static PLDHashOperator
 30522: PluginHideEnumerator(nsPtrHashKey<nsObjectFrame>* aEntry, void* userArg)
 30522: {
 30522:   PluginGeometryClosure* closure = static_cast<PluginGeometryClosure*>(userArg);
 30522:   nsObjectFrame* f = aEntry->GetKey();
 30522:   f->GetEmptyClipConfiguration(closure->mOutputConfigurations);
 30522:   return PL_DHASH_NEXT;
 30522: }
 30522: 
 30522: static void
 30522: RecoverPluginGeometry(nsDisplayListBuilder* aBuilder,
 79445:     nsDisplayList* aList, bool aInTransform, PluginGeometryClosure* aClosure)
 30522: {
 30522:   for (nsDisplayItem* i = aList->GetBottom(); i; i = i->GetAbove()) {
 30522:     switch (i->GetType()) {
 30522:     case nsDisplayItem::TYPE_PLUGIN: {
 30522:       nsDisplayPlugin* displayPlugin = static_cast<nsDisplayPlugin*>(i);
 30522:       nsObjectFrame* f = static_cast<nsObjectFrame*>(
 30522:           displayPlugin->GetUnderlyingFrame());
 30522:       // Ignore plugins which aren't supposed to be affected by this
 30522:       // operation --- their bounds will not have been included in the
 30522:       // display list computations so the visible region computed for them
 30522:       // would be incorrect
 30522:       nsPtrHashKey<nsObjectFrame>* entry =
 30522:         aClosure->mAffectedPlugins.GetEntry(f);
 64534:       // Windowed plugins in transforms are always ignored, we don't
 64534:       // create configurations for them
 93925:       if (entry && (!aInTransform || f->PaintedByGecko())) {
 30522:         displayPlugin->GetWidgetConfiguration(aBuilder,
 30522:                                               aClosure->mOutputConfigurations);
 30522:         // we've dealt with this plugin now
 30522:         aClosure->mAffectedPlugins.RawRemoveEntry(entry);
 30522:       }
 30522:       break;
 30522:     }
 64534:     case nsDisplayItem::TYPE_TRANSFORM: {
 64534:       nsDisplayList* sublist =
 64534:           static_cast<nsDisplayTransform*>(i)->GetStoredList()->GetList();
 80486:       RecoverPluginGeometry(aBuilder, sublist, true, aClosure);
 64534:       break;
 64534:     }
 30522:     default: {
 30522:       nsDisplayList* sublist = i->GetList();
 30522:       if (sublist) {
 64534:         RecoverPluginGeometry(aBuilder, sublist, aInTransform, aClosure);
 30522:       }
 30522:       break;
 30522:     }
 30522:     }
 30522:   }
 30522: }
 30522: 
 30522: #ifdef DEBUG
 30522: #include <stdio.h>
 30522: 
 79445: static bool gDumpPluginList = false;
 30522: #endif
 30522: 
 30522: void
 30522: nsRootPresContext::GetPluginGeometryUpdates(nsIFrame* aChangedSubtree,
 30522:                                             nsTArray<nsIWidget::Configuration>* aConfigurations)
 30522: {
 30522:   if (mRegisteredPlugins.Count() == 0)
 30522:     return;
 30522: 
 30522:   PluginGeometryClosure closure;
 30522:   closure.mRootFrame = mShell->FrameManager()->GetRootFrame();
 47902:   closure.mRootAPD = closure.mRootFrame->PresContext()->AppUnitsPerDevPixel();
 30522:   closure.mChangedSubtree = aChangedSubtree;
 55040:   closure.mChangedRect = aChangedSubtree->GetVisualOverflowRect() +
 47902:       aChangedSubtree->GetOffsetToCrossDoc(closure.mRootFrame);
 47902:   PRInt32 subtreeAPD = aChangedSubtree->PresContext()->AppUnitsPerDevPixel();
 47902:   closure.mChangedRect =
 47902:     closure.mChangedRect.ConvertAppUnitsRoundOut(subtreeAPD, closure.mRootAPD);
 30522:   closure.mAffectedPlugins.Init();
 30522:   closure.mOutputConfigurations = aConfigurations;
 30522:   // Fill in closure.mAffectedPlugins and closure.mAffectedPluginBounds
 30522:   mRegisteredPlugins.EnumerateEntries(PluginBoundsEnumerator, &closure);
 30522: 
 30522:   nsRect bounds;
 30522:   if (bounds.IntersectRect(closure.mAffectedPluginBounds,
 30522:                            closure.mRootFrame->GetRect())) {
 57094:     nsDisplayListBuilder builder(closure.mRootFrame,
 80486:     		nsDisplayListBuilder::PLUGIN_GEOMETRY, false);
 30522:     builder.SetAccurateVisibleRegions();
 30522:     nsDisplayList list;
 30522: 
 30522:     builder.EnterPresShell(closure.mRootFrame, bounds);
 30522:     closure.mRootFrame->BuildDisplayListForStackingContext(
 30522:         &builder, bounds, &list);
 30522:     builder.LeavePresShell(closure.mRootFrame, bounds);
 30522: 
 30522: #ifdef DEBUG
 30522:     if (gDumpPluginList) {
 30522:       fprintf(stderr, "Plugins --- before optimization (bounds %d,%d,%d,%d):\n",
 30522:           bounds.x, bounds.y, bounds.width, bounds.height);
 31709:       nsFrame::PrintDisplayList(&builder, list);
 30522:     }
 30522: #endif
 30522: 
 30522:     nsRegion visibleRegion(bounds);
 51633:     list.ComputeVisibilityForRoot(&builder, &visibleRegion);
 30522: 
 30522: #ifdef DEBUG
 30522:     if (gDumpPluginList) {
 30522:       fprintf(stderr, "Plugins --- after optimization:\n");
 31709:       nsFrame::PrintDisplayList(&builder, list);
 30522:     }
 30522: #endif
 30522: 
 80486:     RecoverPluginGeometry(&builder, &list, false, &closure);
 30522:     list.DeleteAll();
 30522:   }
 30522: 
 30522:   // Plugins that we didn't find in the display list are not visible
 30522:   closure.mAffectedPlugins.EnumerateEntries(PluginHideEnumerator, &closure);
 30522: }
 30522: 
 79445: static bool
 47757: HasOverlap(const nsIntPoint& aOffset1, const nsTArray<nsIntRect>& aClipRects1,
 47757:            const nsIntPoint& aOffset2, const nsTArray<nsIntRect>& aClipRects2)
 47757: {
 47757:   nsIntPoint offsetDelta = aOffset1 - aOffset2;
 47757:   for (PRUint32 i = 0; i < aClipRects1.Length(); ++i) {
 47757:     for (PRUint32 j = 0; j < aClipRects2.Length(); ++j) {
 47757:       if ((aClipRects1[i] + offsetDelta).Intersects(aClipRects2[j]))
 80486:         return true;
 47757:     }
 47757:   }
 80486:   return false;
 47757: }
 47757: 
 47757: /**
 47757:  * Given a list of plugin windows to move to new locations, sort the list
 47757:  * so that for each window move, the window moves to a location that
 47757:  * does not intersect other windows. This minimizes flicker and repainting.
 47757:  * It's not always possible to do this perfectly, since in general
 47757:  * we might have cycles. But we do our best.
 47757:  * We need to take into account that windows are clipped to particular
 47757:  * regions and the clip regions change as the windows are moved.
 47757:  */
 47757: static void
 47757: SortConfigurations(nsTArray<nsIWidget::Configuration>* aConfigurations)
 47757: {
 47757:   if (aConfigurations->Length() > 10) {
 47757:     // Give up, we don't want to get bogged down here
 47757:     return;
 47757:   }
 47757: 
 47757:   nsTArray<nsIWidget::Configuration> pluginsToMove;
 47757:   pluginsToMove.SwapElements(*aConfigurations);
 47757: 
 47757:   // Our algorithm is quite naive. At each step we try to identify
 47757:   // a window that can be moved to its new location that won't overlap
 47757:   // any other windows at the new location. If there is no such
 47757:   // window, we just move the last window in the list anyway.
 47757:   while (!pluginsToMove.IsEmpty()) {
 47757:     // Find a window whose destination does not overlap any other window
 47757:     PRUint32 i;
 47757:     for (i = 0; i + 1 < pluginsToMove.Length(); ++i) {
 47757:       nsIWidget::Configuration* config = &pluginsToMove[i];
 79445:       bool foundOverlap = false;
 47757:       for (PRUint32 j = 0; j < pluginsToMove.Length(); ++j) {
 47757:         if (i == j)
 47757:           continue;
 47757:         nsIntRect bounds;
 47757:         pluginsToMove[j].mChild->GetBounds(bounds);
 47757:         nsAutoTArray<nsIntRect,1> clipRects;
 47757:         pluginsToMove[j].mChild->GetWindowClipRegion(&clipRects);
 47757:         if (HasOverlap(bounds.TopLeft(), clipRects,
 47757:                        config->mBounds.TopLeft(),
 47757:                        config->mClipRegion)) {
 80486:           foundOverlap = true;
 47757:           break;
 47757:         }
 47757:       }
 47757:       if (!foundOverlap)
 47757:         break;
 47757:     }
 47757:     // Note that we always move the last plugin in pluginsToMove, if we
 47757:     // can't find any other plugin to move
 47757:     aConfigurations->AppendElement(pluginsToMove[i]);
 47757:     pluginsToMove.RemoveElementAt(i);
 47757:   }
 47757: }
 47757: 
 30522: void
 47756: nsRootPresContext::UpdatePluginGeometry()
 30522: {
 47756:   if (!mNeedsToUpdatePluginGeometry)
 47756:     return;
 80486:   mNeedsToUpdatePluginGeometry = false;
 87356:   // Cancel out mUpdatePluginGeometryTimer so it doesn't do a random
 87356:   // update when we don't actually want one.
 87356:   CancelUpdatePluginGeometryTimer();
 47756: 
 47756:   nsIFrame* f = mUpdatePluginGeometryForFrame;
 47756:   if (f) {
 47756:     mUpdatePluginGeometryForFrame->PresContext()->
 80486:       SetContainsUpdatePluginGeometryFrame(false);
 47756:     mUpdatePluginGeometryForFrame = nsnull;
 47756:   } else {
 47756:     f = FrameManager()->GetRootFrame();
 47756:   }
 47756: 
 30522:   nsTArray<nsIWidget::Configuration> configurations;
 47756:   GetPluginGeometryUpdates(f, &configurations);
 30522:   if (configurations.IsEmpty())
 30522:     return;
 47757:   SortConfigurations(&configurations);
 47148:   nsIWidget* widget = FrameManager()->GetRootFrame()->GetNearestWidget();
 33373:   NS_ASSERTION(widget, "Plugins must have a parent window");
 30522:   widget->ConfigureChildren(configurations);
 30524:   DidApplyPluginGeometryUpdates();
 30522: }
 30524: 
 87356: static void
 87356: UpdatePluginGeometryCallback(nsITimer *aTimer, void *aClosure)
 87356: {
 87356:   static_cast<nsRootPresContext*>(aClosure)->UpdatePluginGeometry();
 87356: }
 87356: 
 86158: void
 47756: nsRootPresContext::RequestUpdatePluginGeometry(nsIFrame* aFrame)
 47756: {
 47756:   if (mRegisteredPlugins.Count() == 0)
 47756:     return;
 47756: 
 47756:   if (!mNeedsToUpdatePluginGeometry) {
 87334:     // We'll update the plugin geometry during the next paint in this
 87334:     // presContext (either from nsPresShell::WillPaint or from
 87334:     // nsPresShell::DidPaint, depending on the platform) or on the next
 87356:     // layout flush, whichever comes first.  But we may not have anyone
 87356:     // flush layout, and paints might get optimized away if the old
 87356:     // plugin geometry covers the whole canvas, so set a backup timer to
 87356:     // do this too.  We want to make sure this won't fire before our
 87356:     // normal paint notifications, if those would update the geometry,
 87356:     // so set it for double the refresh driver interval.
 87356:     mUpdatePluginGeometryTimer = do_CreateInstance("@mozilla.org/timer;1");
 87356:     if (mUpdatePluginGeometryTimer) {
 87356:       mUpdatePluginGeometryTimer->
 87356:         InitWithFuncCallback(UpdatePluginGeometryCallback, this,
 87356:                              nsRefreshDriver::DefaultInterval() * 2,
 87356:                              nsITimer::TYPE_ONE_SHOT);
 87356:     }
 80486:     mNeedsToUpdatePluginGeometry = true;
 47756:     mUpdatePluginGeometryForFrame = aFrame;
 47756:     mUpdatePluginGeometryForFrame->PresContext()->
 80486:       SetContainsUpdatePluginGeometryFrame(true);
 47756:   } else {
 47960:     if (!mUpdatePluginGeometryForFrame ||
 47960:         aFrame == mUpdatePluginGeometryForFrame)
 47960:       return;
 47756:     mUpdatePluginGeometryForFrame->PresContext()->
 80486:       SetContainsUpdatePluginGeometryFrame(false);
 47756:     mUpdatePluginGeometryForFrame = nsnull;
 47756:   }
 47756: }
 47756: 
 30524: static PLDHashOperator
 30524: PluginDidSetGeometryEnumerator(nsPtrHashKey<nsObjectFrame>* aEntry, void* userArg)
 30524: {
 30524:   nsObjectFrame* f = aEntry->GetKey();
 30524:   f->DidSetWidgetGeometry();
 30524:   return PL_DHASH_NEXT;
 30524: }
 30524: 
 30524: void
 30524: nsRootPresContext::DidApplyPluginGeometryUpdates()
 30524: {
 30524:   mRegisteredPlugins.EnumerateEntries(PluginDidSetGeometryEnumerator, nsnull);
 30524: }
 47756: 
 47756: void
 47756: nsRootPresContext::RootForgetUpdatePluginGeometryFrame(nsIFrame* aFrame)
 47756: {
 47756:   if (aFrame == mUpdatePluginGeometryForFrame) {
 47756:     mUpdatePluginGeometryForFrame->PresContext()->
 80486:       SetContainsUpdatePluginGeometryFrame(false);
 47756:     mUpdatePluginGeometryForFrame = nsnull;
 47756:   }
 47756: }
 60645: 
 67576: void
 67576: nsRootPresContext::RootForgetUpdatePluginGeometryFrameForPresContext(
 67576:   nsPresContext* aPresContext)
 67576: {
 67576:   if (aPresContext->GetContainsUpdatePluginGeometryFrame()) {
 80486:     aPresContext->SetContainsUpdatePluginGeometryFrame(false);
 67576:     mUpdatePluginGeometryForFrame = nsnull;
 67576:   }
 67576: }
 67576: 
 60645: static void
 60645: NotifyDidPaintForSubtreeCallback(nsITimer *aTimer, void *aClosure)
 60645: {
 60645:   nsPresContext* presContext = (nsPresContext*)aClosure;
 60645:   nsAutoScriptBlocker blockScripts;
 60645:   presContext->NotifyDidPaintForSubtree();
 60645: }
 60645: 
 60645: void
 60645: nsRootPresContext::EnsureEventualDidPaintEvent()
 60645: {
 60645:   if (mNotifyDidPaintTimer)
 60645:     return;
 60645:   mNotifyDidPaintTimer = do_CreateInstance("@mozilla.org/timer;1");
 60645:   if (!mNotifyDidPaintTimer)
 60645:     return;
 60645:   mNotifyDidPaintTimer->InitWithFuncCallback(NotifyDidPaintForSubtreeCallback,
 60645:                                              (void*)this, 100, nsITimer::TYPE_ONE_SHOT);
 60645: }
 80879: 
 80879: void
 80879: nsRootPresContext::AddWillPaintObserver(nsIRunnable* aRunnable)
 80879: {
 80879:   if (!mWillPaintFallbackEvent.IsPending()) {
 80879:     mWillPaintFallbackEvent = new RunWillPaintObservers(this);
 80879:     NS_DispatchToMainThread(mWillPaintFallbackEvent.get());
 80879:   }
 80879:   mWillPaintObservers.AppendElement(aRunnable);
 80879: }
 80879: 
 80879: /**
 80879:  * Run all runnables that need to get called before the next paint.
 80879:  */
 80879: void
 80879: nsRootPresContext::FlushWillPaintObservers()
 80879: {
 80879:   mWillPaintFallbackEvent = nsnull;
 80879:   nsTArray<nsCOMPtr<nsIRunnable> > observers;
 80879:   observers.SwapElements(mWillPaintObservers);
 80879:   for (PRUint32 i = 0; i < observers.Length(); ++i) {
 80879:     observers[i]->Run();
 80879:   }
 80879: }
 91689: 
 91689: size_t
 91689: nsRootPresContext::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const
 91689: {
 91689:   return nsPresContext::SizeOfExcludingThis(aMallocSizeOf);
 91689: 
 91689:   // Measurement of the following members may be added later if DMD finds it is
 91689:   // worthwhile:
 91689:   // - mNotifyDidPaintTimer
 91689:   // - mRegisteredPlugins
 91689:   // - mWillPaintObservers
 91689:   // - mWillPaintFallbackEvent
 91689:   //
 91689:   // The following member are not measured:
 91689:   // - mUpdatePluginGeometryForFrame, because it is non-owning
 91689: }
 91689: 
