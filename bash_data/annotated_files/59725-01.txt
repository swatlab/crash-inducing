    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla SVG project.
    1:  *
    1:  * The Initial Developer of the Original Code is IBM Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
26875: // include nsSVGUtils.h first to ensure definition of M_SQRT1_2 is picked up
26875: #include "nsSVGUtils.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMSVGElement.h"
    1: #include "nsIDOMSVGSVGElement.h"
    1: #include "nsStyleCoord.h"
    1: #include "nsPresContext.h"
    1: #include "nsSVGSVGElement.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsIFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIURI.h"
    1: #include "nsStyleStruct.h"
    1: #include "nsIPresShell.h"
    1: #include "nsISVGGlyphFragmentLeaf.h"
    1: #include "nsNetUtil.h"
    1: #include "nsFrameList.h"
    1: #include "nsISVGChildFrame.h"
    1: #include "nsContentDLF.h"
    1: #include "nsContentUtils.h"
    1: #include "nsSVGFilterFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsDOMError.h"
    1: #include "nsSVGOuterSVGFrame.h"
27845: #include "nsSVGInnerSVGFrame.h"
59471: #include "SVGAnimatedPreserveAspectRatio.h"
    1: #include "nsSVGMatrix.h"
    1: #include "nsSVGClipPathFrame.h"
    1: #include "nsSVGMaskFrame.h"
    1: #include "nsSVGContainerFrame.h"
49139: #include "nsSVGTextContainerFrame.h"
    1: #include "nsSVGLength2.h"
    1: #include "nsGenericElement.h"
29610: #include "nsSVGGraphicElement.h"
    1: #include "nsAttrValue.h"
    1: #include "nsSVGGeometryFrame.h"
    1: #include "nsIScriptError.h"
    1: #include "gfxContext.h"
    1: #include "gfxMatrix.h"
    1: #include "gfxRect.h"
    1: #include "gfxImageSurface.h"
  630: #include "gfxPlatform.h"
 1519: #include "nsSVGForeignObjectFrame.h"
 2755: #include "nsIFontMetrics.h"
 8640: #include "nsIDOMSVGUnitTypes.h"
16501: #include "nsSVGEffects.h"
34208: #include "nsMathUtils.h"
19125: #include "nsSVGIntegrationUtils.h"
19125: #include "nsSVGFilterPaintCallback.h"
26759: #include "nsSVGGeometryFrame.h"
31707: #include "nsComputedDOMStyle.h"
34063: #include "nsSVGPathGeometryFrame.h"
37220: #include "prdtoa.h"
41930: #include "mozilla/dom/Element.h"
58579: #include "gfxUtils.h"
41643: 
59470: using namespace mozilla;
41643: using namespace mozilla::dom;
  831: 
    1: // c = n / 255
    1: // (c <= 0.0031308 ? c * 12.92 : 1.055 * pow(c, 1 / 2.4) - 0.055) * 255 + 0.5
    1: static const PRUint8 glinearRGBTosRGBMap[256] = {
    1:   0,  13,  22,  28,  34,  38,  42,  46,
    1:  50,  53,  56,  59,  61,  64,  66,  69,
    1:  71,  73,  75,  77,  79,  81,  83,  85,
    1:  86,  88,  90,  92,  93,  95,  96,  98,
    1:  99, 101, 102, 104, 105, 106, 108, 109,
    1: 110, 112, 113, 114, 115, 117, 118, 119,
    1: 120, 121, 122, 124, 125, 126, 127, 128,
    1: 129, 130, 131, 132, 133, 134, 135, 136,
    1: 137, 138, 139, 140, 141, 142, 143, 144,
    1: 145, 146, 147, 148, 148, 149, 150, 151,
    1: 152, 153, 154, 155, 155, 156, 157, 158,
    1: 159, 159, 160, 161, 162, 163, 163, 164,
    1: 165, 166, 167, 167, 168, 169, 170, 170,
    1: 171, 172, 173, 173, 174, 175, 175, 176,
    1: 177, 178, 178, 179, 180, 180, 181, 182,
    1: 182, 183, 184, 185, 185, 186, 187, 187,
    1: 188, 189, 189, 190, 190, 191, 192, 192,
    1: 193, 194, 194, 195, 196, 196, 197, 197,
    1: 198, 199, 199, 200, 200, 201, 202, 202,
    1: 203, 203, 204, 205, 205, 206, 206, 207,
    1: 208, 208, 209, 209, 210, 210, 211, 212,
    1: 212, 213, 213, 214, 214, 215, 215, 216,
    1: 216, 217, 218, 218, 219, 219, 220, 220,
    1: 221, 221, 222, 222, 223, 223, 224, 224,
    1: 225, 226, 226, 227, 227, 228, 228, 229,
    1: 229, 230, 230, 231, 231, 232, 232, 233,
    1: 233, 234, 234, 235, 235, 236, 236, 237,
    1: 237, 238, 238, 238, 239, 239, 240, 240,
    1: 241, 241, 242, 242, 243, 243, 244, 244,
    1: 245, 245, 246, 246, 246, 247, 247, 248,
    1: 248, 249, 249, 250, 250, 251, 251, 251,
    1: 252, 252, 253, 253, 254, 254, 255, 255
    1: };
    1: 
    1: // c = n / 255
    1: // c <= 0.04045 ? c / 12.92 : pow((c + 0.055) / 1.055, 2.4)) * 255 + 0.5
    1: static const PRUint8 gsRGBToLinearRGBMap[256] = {
    1:   0,   0,   0,   0,   0,   0,   0,   1,
    1:   1,   1,   1,   1,   1,   1,   1,   1,
    1:   1,   1,   2,   2,   2,   2,   2,   2,
    1:   2,   2,   3,   3,   3,   3,   3,   3,
    1:   4,   4,   4,   4,   4,   5,   5,   5,
    1:   5,   6,   6,   6,   6,   7,   7,   7,
    1:   8,   8,   8,   8,   9,   9,   9,  10,
    1:  10,  10,  11,  11,  12,  12,  12,  13,
    1:  13,  13,  14,  14,  15,  15,  16,  16,
    1:  17,  17,  17,  18,  18,  19,  19,  20,
    1:  20,  21,  22,  22,  23,  23,  24,  24,
    1:  25,  25,  26,  27,  27,  28,  29,  29,
    1:  30,  30,  31,  32,  32,  33,  34,  35,
    1:  35,  36,  37,  37,  38,  39,  40,  41,
    1:  41,  42,  43,  44,  45,  45,  46,  47,
    1:  48,  49,  50,  51,  51,  52,  53,  54,
    1:  55,  56,  57,  58,  59,  60,  61,  62,
    1:  63,  64,  65,  66,  67,  68,  69,  70,
    1:  71,  72,  73,  74,  76,  77,  78,  79,
    1:  80,  81,  82,  84,  85,  86,  87,  88,
    1:  90,  91,  92,  93,  95,  96,  97,  99,
    1: 100, 101, 103, 104, 105, 107, 108, 109,
    1: 111, 112, 114, 115, 116, 118, 119, 121,
    1: 122, 124, 125, 127, 128, 130, 131, 133,
    1: 134, 136, 138, 139, 141, 142, 144, 146,
    1: 147, 149, 151, 152, 154, 156, 157, 159,
    1: 161, 163, 164, 166, 168, 170, 171, 173,
    1: 175, 177, 179, 181, 183, 184, 186, 188,
    1: 190, 192, 194, 196, 198, 200, 202, 204,
    1: 206, 208, 210, 212, 214, 216, 218, 220,
    1: 222, 224, 226, 229, 231, 233, 235, 237,
    1: 239, 242, 244, 246, 248, 250, 253, 255
    1: };
    1: 
25961: #ifdef MOZ_SMIL
25961: static PRBool gSMILEnabled;
25961: static const char SMIL_PREF_STR[] = "svg.smil.enabled";
25961: #endif // MOZ_SMIL
25961: 
25961: #ifdef MOZ_SMIL
25961: static int
25961: SMILPrefChanged(const char *aPref, void *aClosure)
25961: {
25961:   PRBool prefVal = nsContentUtils::GetBoolPref(SMIL_PREF_STR);
25961:   gSMILEnabled = prefVal;
25961:   return 0;
25961: }
25961: 
25961: PRBool
25961: NS_SMILEnabled()
25961: {
25961:   static PRBool sInitialized = PR_FALSE;
25961:   
25961:   if (!sInitialized) {
25961:     /* check and register ourselves with the pref */
25961:     gSMILEnabled = nsContentUtils::GetBoolPref(SMIL_PREF_STR);
25961:     nsContentUtils::RegisterPrefCallback(SMIL_PREF_STR, SMILPrefChanged, nsnull);
25961: 
25961:     sInitialized = PR_TRUE;
25961:   }
25961: 
25961:   return gSMILEnabled;
25961: }
25961: #endif // MOZ_SMIL
25961: 
42326: Element*
25867: nsSVGUtils::GetParentElement(nsIContent *aContent)
25867: {
25867:   // XXXbz I _think_ this is right.  We want to be using the binding manager
25867:   // that would have attached the binding that gives us our anonymous parent.
25867:   // That's the binding manager for the document we actually belong to, which
25867:   // is our owner doc.
25867:   nsIDocument* ownerDoc = aContent->GetOwnerDoc();
25867:   nsBindingManager* bindingManager =
25867:     ownerDoc ? ownerDoc->BindingManager() : nsnull;
25867: 
25867:   if (bindingManager) {
25867:     // if we have a binding manager -- do we have an anonymous parent?
25867:     nsIContent *result = bindingManager->GetInsertionParent(aContent);
25867:     if (result) {
42326:       return result->AsElement();
25867:     }
25867:   }
25867: 
25867:   // otherewise use the explicit one, whether it's null or not...
42326:   nsIContent* parent = aContent->GetParent();
42385:   return parent && parent->IsElement() ? parent->AsElement() : nsnull;
25867: }
25867: 
 2755: float
41643: nsSVGUtils::GetFontSize(Element *aElement)
 2755: {
41643:   if (!aElement)
32463:     return 1.0f;
32463: 
31707:   nsRefPtr<nsStyleContext> styleContext = 
41643:     nsComputedDOMStyle::GetStyleContextForElementNoFlush(aElement,
41643:                                                          nsnull, nsnull);
31707:   if (!styleContext) {
47840:     // ReportToConsole
31707:     NS_WARNING("Couldn't get style context for content in GetFontStyle");
 2755:     return 1.0f;
 2755:   }
 2755: 
31707:   return GetFontSize(styleContext);
19125: }
19125: 
19125: float
19125: nsSVGUtils::GetFontSize(nsIFrame *aFrame)
19125: {
31707:   NS_ABORT_IF_FALSE(aFrame, "NULL frame in GetFontSize");
31707:   return GetFontSize(aFrame->GetStyleContext());
31707: }
31707: 
31707: float
31707: nsSVGUtils::GetFontSize(nsStyleContext *aStyleContext)
31707: {
31707:   NS_ABORT_IF_FALSE(aStyleContext, "NULL style context in GetFontSize");
31707: 
31707:   nsPresContext *presContext = aStyleContext->PresContext();
31707:   NS_ABORT_IF_FALSE(presContext, "NULL pres context in GetFontSize");
31707: 
31707:   nscoord fontSize = aStyleContext->GetStyleFont()->mSize;
31707:   return nsPresContext::AppUnitsToFloatCSSPixels(fontSize) / 
31707:          presContext->TextZoom();
 2755: }
 2755: 
 2755: float
41643: nsSVGUtils::GetFontXHeight(Element *aElement)
 2755: {
41643:   if (!aElement)
32463:     return 1.0f;
32463: 
31707:   nsRefPtr<nsStyleContext> styleContext = 
41643:     nsComputedDOMStyle::GetStyleContextForElementNoFlush(aElement,
41643:                                                          nsnull, nsnull);
31707:   if (!styleContext) {
47840:     // ReportToConsole
31707:     NS_WARNING("Couldn't get style context for content in GetFontStyle");
 2755:     return 1.0f;
 2755:   }
 2755: 
31707:   return GetFontXHeight(styleContext);
19125: }
19125:   
19125: float
19125: nsSVGUtils::GetFontXHeight(nsIFrame *aFrame)
19125: {
31707:   NS_ABORT_IF_FALSE(aFrame, "NULL frame in GetFontXHeight");
31707:   return GetFontXHeight(aFrame->GetStyleContext());
31707: }
31707: 
31707: float
31707: nsSVGUtils::GetFontXHeight(nsStyleContext *aStyleContext)
31707: {
31707:   NS_ABORT_IF_FALSE(aStyleContext, "NULL style context in GetFontXHeight");
31707: 
31707:   nsPresContext *presContext = aStyleContext->PresContext();
31707:   NS_ABORT_IF_FALSE(presContext, "NULL pres context in GetFontXHeight");
31707: 
 4767:   nsCOMPtr<nsIFontMetrics> fontMetrics;
31707:   nsLayoutUtils::GetFontMetricsForStyleContext(aStyleContext,
31707:                                                getter_AddRefs(fontMetrics));
 2755: 
 2755:   if (!fontMetrics) {
47840:     // ReportToConsole
 2755:     NS_WARNING("no FontMetrics in GetFontXHeight()");
 2755:     return 1.0f;
 2755:   }
 2755: 
 2755:   nscoord xHeight;
 2755:   fontMetrics->GetXHeight(xHeight);
 4767:   return nsPresContext::AppUnitsToFloatCSSPixels(xHeight) /
31707:          presContext->TextZoom();
 2755: }
 2755: 
    1: void
    1: nsSVGUtils::UnPremultiplyImageDataAlpha(PRUint8 *data, 
    1:                                         PRInt32 stride,
18367:                                         const nsIntRect &rect)
    1: {
    1:   for (PRInt32 y = rect.y; y < rect.YMost(); y++) {
    1:     for (PRInt32 x = rect.x; x < rect.XMost(); x++) {
    1:       PRUint8 *pixel = data + stride * y + 4 * x;
    1: 
    1:       PRUint8 a = pixel[GFX_ARGB32_OFFSET_A];
    1:       if (a == 255)
    1:         continue;
    1: 
    1:       if (a) {
    1:         pixel[GFX_ARGB32_OFFSET_B] = (255 * pixel[GFX_ARGB32_OFFSET_B]) / a;
    1:         pixel[GFX_ARGB32_OFFSET_G] = (255 * pixel[GFX_ARGB32_OFFSET_G]) / a;
    1:         pixel[GFX_ARGB32_OFFSET_R] = (255 * pixel[GFX_ARGB32_OFFSET_R]) / a;
    1:       } else {
    1:         pixel[GFX_ARGB32_OFFSET_B] = 0;
    1:         pixel[GFX_ARGB32_OFFSET_G] = 0;
    1:         pixel[GFX_ARGB32_OFFSET_R] = 0;
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsSVGUtils::PremultiplyImageDataAlpha(PRUint8 *data, 
    1:                                       PRInt32 stride,
18367:                                       const nsIntRect &rect)
    1: {
    1:   for (PRInt32 y = rect.y; y < rect.YMost(); y++) {
    1:     for (PRInt32 x = rect.x; x < rect.XMost(); x++) {
    1:       PRUint8 *pixel = data + stride * y + 4 * x;
    1: 
    1:       PRUint8 a = pixel[GFX_ARGB32_OFFSET_A];
    1:       if (a == 255)
    1:         continue;
    1: 
    1:       FAST_DIVIDE_BY_255(pixel[GFX_ARGB32_OFFSET_B],
    1:                          pixel[GFX_ARGB32_OFFSET_B] * a);
    1:       FAST_DIVIDE_BY_255(pixel[GFX_ARGB32_OFFSET_G],
    1:                          pixel[GFX_ARGB32_OFFSET_G] * a);
    1:       FAST_DIVIDE_BY_255(pixel[GFX_ARGB32_OFFSET_R],
    1:                          pixel[GFX_ARGB32_OFFSET_R] * a);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsSVGUtils::ConvertImageDataToLinearRGB(PRUint8 *data, 
    1:                                         PRInt32 stride,
18367:                                         const nsIntRect &rect)
    1: {
    1:   for (PRInt32 y = rect.y; y < rect.YMost(); y++) {
    1:     for (PRInt32 x = rect.x; x < rect.XMost(); x++) {
    1:       PRUint8 *pixel = data + stride * y + 4 * x;
    1: 
    1:       pixel[GFX_ARGB32_OFFSET_B] =
    1:         gsRGBToLinearRGBMap[pixel[GFX_ARGB32_OFFSET_B]];
    1:       pixel[GFX_ARGB32_OFFSET_G] =
    1:         gsRGBToLinearRGBMap[pixel[GFX_ARGB32_OFFSET_G]];
    1:       pixel[GFX_ARGB32_OFFSET_R] =
    1:         gsRGBToLinearRGBMap[pixel[GFX_ARGB32_OFFSET_R]];
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsSVGUtils::ConvertImageDataFromLinearRGB(PRUint8 *data, 
    1:                                           PRInt32 stride,
18367:                                           const nsIntRect &rect)
    1: {
    1:   for (PRInt32 y = rect.y; y < rect.YMost(); y++) {
    1:     for (PRInt32 x = rect.x; x < rect.XMost(); x++) {
    1:       PRUint8 *pixel = data + stride * y + 4 * x;
    1: 
    1:       pixel[GFX_ARGB32_OFFSET_B] =
    1:         glinearRGBTosRGBMap[pixel[GFX_ARGB32_OFFSET_B]];
    1:       pixel[GFX_ARGB32_OFFSET_G] =
    1:         glinearRGBTosRGBMap[pixel[GFX_ARGB32_OFFSET_G]];
    1:       pixel[GFX_ARGB32_OFFSET_R] =
    1:         glinearRGBTosRGBMap[pixel[GFX_ARGB32_OFFSET_R]];
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsSVGUtils::ReportToConsole(nsIDocument* doc,
    1:                             const char* aWarning,
    1:                             const PRUnichar **aParams,
    1:                             PRUint32 aParamsLength)
    1: {
    1:   return nsContentUtils::ReportToConsole(nsContentUtils::eSVG_PROPERTIES,
    1:                                          aWarning,
    1:                                          aParams, aParamsLength,
59513:                                          nsnull,
    1:                                          EmptyString(), 0, 0,
    1:                                          nsIScriptError::warningFlag,
59513:                                          "SVG", doc);
    1: }
    1: 
    1: float
    1: nsSVGUtils::CoordToFloat(nsPresContext *aPresContext,
    1:                          nsSVGElement *aContent,
    1:                          const nsStyleCoord &aCoord)
    1: {
    1:   switch (aCoord.GetUnit()) {
    1:   case eStyleUnit_Factor:
    1:     // user units
23852:     return aCoord.GetFactorValue();
    1: 
    1:   case eStyleUnit_Coord:
23852:     return nsPresContext::AppUnitsToFloatCSSPixels(aCoord.GetCoordValue());
    1: 
    1:   case eStyleUnit_Percent: {
23852:       nsSVGSVGElement* ctx = aContent->GetCtx();
23852:       return ctx ? aCoord.GetPercentValue() * ctx->GetLength(nsSVGUtils::XY) : 0.0f;
    1:     }
    1:   default:
23852:     return 0.0f;
    1:   }
    1: }
    1: 
30596: PRBool
30596: nsSVGUtils::EstablishesViewport(nsIContent *aContent)
10138: {
30596:   return aContent && aContent->GetNameSpaceID() == kNameSpaceID_SVG &&
30596:            (aContent->Tag() == nsGkAtoms::svg ||
30596:             aContent->Tag() == nsGkAtoms::image ||
30596:             aContent->Tag() == nsGkAtoms::foreignObject ||
30596:             aContent->Tag() == nsGkAtoms::symbol);
30596: }
10138: 
30596: already_AddRefed<nsIDOMSVGElement>
30596: nsSVGUtils::GetNearestViewportElement(nsIContent *aContent)
30596: {
30596:   nsIContent *element = GetParentElement(aContent);
30596: 
30596:   while (element && element->GetNameSpaceID() == kNameSpaceID_SVG) {
30596:     if (EstablishesViewport(element)) {
30596:       if (element->Tag() == nsGkAtoms::foreignObject) {
30596:         return nsnull;
30596:       }
30596:       return nsCOMPtr<nsIDOMSVGElement>(do_QueryInterface(element)).forget();
30596:     }
30596:     element = GetParentElement(element);
30596:   }
30596:   return nsnull;
30596: }
30596: 
30596: already_AddRefed<nsIDOMSVGElement>
30596: nsSVGUtils::GetFarthestViewportElement(nsIContent *aContent)
30596: {
30596:   nsIContent *element = nsnull;
26450:   nsIContent *ancestor = GetParentElement(aContent);
10138: 
26450:   while (ancestor && ancestor->GetNameSpaceID() == kNameSpaceID_SVG &&
26450:                      ancestor->Tag() != nsGkAtoms::foreignObject) {
30596:     element = ancestor;
30596:     ancestor = GetParentElement(element);
10138:   }
10138: 
30596:   if (element && element->Tag() == nsGkAtoms::svg) {
30596:     return nsCOMPtr<nsIDOMSVGElement>(do_QueryInterface(element)).forget();
10138:   }
30596:   return nsnull;
10138: }
10138: 
30596: gfxMatrix
30596: nsSVGUtils::GetCTM(nsSVGElement *aElement, PRBool aScreenCTM)
29610: {
30596:   nsIDocument* currentDoc = aElement->GetCurrentDoc();
29610:   if (currentDoc) {
29610:     // Flush all pending notifications so that our frames are up to date
29610:     currentDoc->FlushPendingNotifications(Flush_Layout);
29610:   }
29610: 
30596:   gfxMatrix matrix = aElement->PrependLocalTransformTo(gfxMatrix());
30596:   nsSVGElement *element = aElement;
30596:   nsIContent *ancestor = GetParentElement(aElement);
29610: 
30596:   while (ancestor && ancestor->GetNameSpaceID() == kNameSpaceID_SVG &&
30596:                      ancestor->Tag() != nsGkAtoms::foreignObject) {
32102:     // ignore unknown XML elements in the SVG namespace
32102:     if (ancestor->IsNodeOfType(nsINode::eSVG)) {
30596:       element = static_cast<nsSVGElement*>(ancestor);
30596:       matrix *= element->PrependLocalTransformTo(gfxMatrix()); // i.e. *A*ppend
30596:       if (!aScreenCTM && EstablishesViewport(element)) {
30596:         if (!element->NodeInfo()->Equals(nsGkAtoms::svg, kNameSpaceID_SVG) &&
30596:             !element->NodeInfo()->Equals(nsGkAtoms::symbol, kNameSpaceID_SVG)) {
30596:           NS_ERROR("New (SVG > 1.1) SVG viewport establishing element?");
30596:           return gfxMatrix(0.0, 0.0, 0.0, 0.0, 0.0, 0.0); // singular
29610:         }
30596:         // XXX spec seems to say x,y translation should be undone for IsInnerSVG
30596:         return matrix;
29610:       }
32102:     }
32102:     ancestor = GetParentElement(ancestor);      
30596:   }
30596:   if (!aScreenCTM) {
30596:     // didn't find a nearestViewportElement
30596:     return gfxMatrix(0.0, 0.0, 0.0, 0.0, 0.0, 0.0); // singular
30596:   }
41642:   if (!ancestor || !ancestor->IsElement()) {
30596:     return matrix;
30596:   }
30596:   if (ancestor->GetNameSpaceID() == kNameSpaceID_SVG) {
30596:     if (element->Tag() != nsGkAtoms::svg) {
30596:       return gfxMatrix(0.0, 0.0, 0.0, 0.0, 0.0, 0.0); // singular
30596:     }
30596:     return matrix * GetCTM(static_cast<nsSVGElement*>(ancestor), PR_TRUE);
30596:   }
30596:   // XXX this does not take into account CSS transform, or that the non-SVG
30596:   // content that we've hit may itself be inside an SVG foreignObject higher up
30596:   float x = 0.0f, y = 0.0f;
32373:   if (currentDoc && element->NodeInfo()->Equals(nsGkAtoms::svg, kNameSpaceID_SVG)) {
46225:     nsIPresShell *presShell = currentDoc->GetShell();
32373:     if (presShell) {
36656:       nsIFrame* frame = element->GetPrimaryFrame();
30596:       nsIFrame* ancestorFrame = presShell->GetRootFrame();
30596:       if (frame && ancestorFrame) {
30596:         nsPoint point = frame->GetOffsetTo(ancestorFrame);
30596:         x = nsPresContext::AppUnitsToFloatCSSPixels(point.x);
30596:         y = nsPresContext::AppUnitsToFloatCSSPixels(point.y);
30596:       }
30596:     }
30596:   }
30596:   return matrix * gfxMatrix().Translate(gfxPoint(x, y));
29610: }
29610: 
27845: nsSVGDisplayContainerFrame*
27845: nsSVGUtils::GetNearestSVGViewport(nsIFrame *aFrame)
27845: {
27845:   NS_ASSERTION(aFrame->IsFrameOfType(nsIFrame::eSVG), "SVG frame expected");
27845:   if (aFrame->GetType() == nsGkAtoms::svgOuterSVGFrame) {
27845:     return nsnull;
27845:   }
27845:   while ((aFrame = aFrame->GetParent())) {
27845:     NS_ASSERTION(aFrame->IsFrameOfType(nsIFrame::eSVG), "SVG frame expected");
27845:     if (aFrame->GetType() == nsGkAtoms::svgInnerSVGFrame ||
27845:         aFrame->GetType() == nsGkAtoms::svgOuterSVGFrame) {
27845:       return do_QueryFrame(aFrame);
27845:     }
27845:   }
27845:   NS_NOTREACHED("This is not reached. It's only needed to compile.");
27845:   return nsnull;
27845: }
27845: 
    1: nsRect
16124: nsSVGUtils::FindFilterInvalidation(nsIFrame *aFrame, const nsRect& aRect)
    1: {
19304:   PRInt32 appUnitsPerDevPixel = aFrame->PresContext()->AppUnitsPerDevPixel();
28113:   nsIntRect rect = aRect.ToOutsidePixels(appUnitsPerDevPixel);
    1: 
    1:   while (aFrame) {
    1:     if (aFrame->GetStateBits() & NS_STATE_IS_OUTER_SVG)
    1:       break;
    1: 
20305:     nsSVGFilterFrame *filter = nsSVGEffects::GetFilterFrame(aFrame);
16124:     if (filter) {
27845:       // When we are under AttributeChanged, we can no longer get the old bbox
27845:       // by calling GetBBox(), and we need that to set up the filter region
27845:       // with the correct position. :-(
27845:       //rect = filter->GetInvalidationBBox(aFrame, rect);
27845: 
27845:       // XXX [perf] As a horrible workaround, for now we just invalidate the
27845:       // entire area of the nearest viewport establishing frame that doesnt
27845:       // have overflow:visible. See bug 463939.
27845:       nsSVGDisplayContainerFrame* viewportFrame = GetNearestSVGViewport(aFrame);
27845:       while (viewportFrame && !viewportFrame->GetStyleDisplay()->IsScrollableOverflow()) {
27845:         viewportFrame = GetNearestSVGViewport(viewportFrame);
27845:       }
27845:       if (!viewportFrame) {
27845:         viewportFrame = GetOuterSVGFrame(aFrame);
27845:       }
27845:       if (viewportFrame->GetType() == nsGkAtoms::svgOuterSVGFrame) {
55040:         nsRect r = viewportFrame->GetVisualOverflowRect();
27845:         // GetOverflowRect is relative to our border box, but we need it
27845:         // relative to our content box.
42235:         r.MoveBy(viewportFrame->GetPosition() - viewportFrame->GetContentRect().TopLeft());
27845:         return r;
27845:       }
27845:       NS_ASSERTION(viewportFrame->GetType() == nsGkAtoms::svgInnerSVGFrame,
27845:                    "Wrong frame type");
27845:       nsSVGInnerSVGFrame* innerSvg = do_QueryFrame(static_cast<nsIFrame*>(viewportFrame));
27845:       nsSVGDisplayContainerFrame* innerSvgParent = do_QueryFrame(viewportFrame->GetParent());
27845:       float x, y, width, height;
27845:       static_cast<nsSVGSVGElement*>(innerSvg->GetContent())->
27845:         GetAnimatedLengthValues(&x, &y, &width, &height, nsnull);
27899:       gfxRect bounds = nsSVGUtils::GetCanvasTM(innerSvgParent).
27899:                          TransformBounds(gfxRect(x, y, width, height));
27845:       bounds.RoundOut();
27845:       nsIntRect r;
58579:       if (gfxUtils::GfxRectToIntRect(bounds, &r)) {
27845:         rect = r;
27845:       } else {
27845:         NS_NOTREACHED("Not going to invalidate the correct area");
27845:       }
27845:       aFrame = viewportFrame;
16124:     }
    1:     aFrame = aFrame->GetParent();
    1:   }
    1: 
42235:   nsRect r = rect.ToAppUnits(appUnitsPerDevPixel);
42235:   if (aFrame) {
42235:     NS_ASSERTION(aFrame->GetStateBits() & NS_STATE_IS_OUTER_SVG,
42235:                  "outer SVG frame expected");
42235:     r.MoveBy(aFrame->GetContentRect().TopLeft() - aFrame->GetPosition());
42235:   }
42235:   return r;
    1: }
    1: 
 1961: void
22349: nsSVGUtils::InvalidateCoveredRegion(nsIFrame *aFrame)
22349: {
22349:   if (aFrame->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
22349:     return;
22349: 
22349:   nsSVGOuterSVGFrame* outerSVGFrame = nsSVGUtils::GetOuterSVGFrame(aFrame);
22349:   NS_ASSERTION(outerSVGFrame, "no outer svg frame");
22349:   if (outerSVGFrame)
22349:     outerSVGFrame->InvalidateCoveredRegion(aFrame);
22349: }
22349: 
22349: void
14042: nsSVGUtils::UpdateGraphic(nsISVGChildFrame *aSVGFrame)
14042: {
23554:   nsIFrame *frame = do_QueryFrame(aSVGFrame);
14042: 
19948:   nsSVGEffects::InvalidateRenderingObservers(frame);
19948: 
14042:   if (frame->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
14042:     return;
14042: 
14042:   nsSVGOuterSVGFrame *outerSVGFrame = nsSVGUtils::GetOuterSVGFrame(frame);
14042:   if (!outerSVGFrame) {
14042:     NS_ERROR("null outerSVGFrame");
14042:     return;
14042:   }
14042: 
14042:   if (outerSVGFrame->IsRedrawSuspended()) {
14042:     frame->AddStateBits(NS_STATE_SVG_DIRTY);
14042:   } else {
14042:     frame->RemoveStateBits(NS_STATE_SVG_DIRTY);
14042: 
16124:     PRBool changed = outerSVGFrame->UpdateAndInvalidateCoveredRegion(frame);
16124:     if (changed) {
14042:       NotifyAncestorsOfFilterRegionChange(frame);
14042:     }
14042:   }
16124: }
14042: 
14042: void
13316: nsSVGUtils::NotifyAncestorsOfFilterRegionChange(nsIFrame *aFrame)
13316: {
14334:   if (aFrame->GetStateBits() & NS_STATE_IS_OUTER_SVG) {
14334:     // It would be better if we couldn't get here
14334:     return;
14334:   }
14334: 
13316:   aFrame = aFrame->GetParent();
13316: 
13316:   while (aFrame) {
13316:     if (aFrame->GetStateBits() & NS_STATE_IS_OUTER_SVG)
13316:       return;
13316: 
16501:     nsSVGFilterProperty *property = nsSVGEffects::GetFilterProperty(aFrame);
16406:     if (property) {
13316:       property->Invalidate();
13316:     }
13316:     aFrame = aFrame->GetParent();
13316:   }
13316: }
13316: 
15943: double
15943: nsSVGUtils::ComputeNormalizedHypotenuse(double aWidth, double aHeight)
15943: {
15943:   return sqrt((aWidth*aWidth + aHeight*aHeight)/2);
15943: }
15943: 
    1: float
29067: nsSVGUtils::ObjectSpace(const gfxRect &aRect, const nsSVGLength2 *aLength)
    1: {
    1:   float fraction, axis;
    1: 
    1:   switch (aLength->GetCtxType()) {
    1:   case X:
29067:     axis = aRect.Width();
    1:     break;
    1:   case Y:
29067:     axis = aRect.Height();
    1:     break;
    1:   case XY:
29067:     axis = float(ComputeNormalizedHypotenuse(aRect.Width(), aRect.Height()));
35655:     break;
35655:   default:
35655:     NS_NOTREACHED("unexpected ctx type");
35655:     axis = 0.0f;
35655:     break;
    1:   }
    1: 
10661:   if (aLength->IsPercentage()) {
    1:     fraction = aLength->GetAnimValInSpecifiedUnits() / 100;
35655:   } else {
 3233:     fraction = aLength->GetAnimValue(static_cast<nsSVGSVGElement*>
 3233:                                                 (nsnull));
35655:   }
    1: 
    1:   return fraction * axis;
    1: }
    1: 
    1: float
19125: nsSVGUtils::UserSpace(nsSVGElement *aSVGElement, const nsSVGLength2 *aLength)
    1: {
    1:   return aLength->GetAnimValue(aSVGElement);
    1: }
    1: 
19125: float
19125: nsSVGUtils::UserSpace(nsIFrame *aNonSVGContext, const nsSVGLength2 *aLength)
19125: {
19125:   return aLength->GetAnimValue(aNonSVGContext);
19125: }
19125: 
    1: float
    1: nsSVGUtils::AngleBisect(float a1, float a2)
    1: {
 3233:   float delta = fmod(a2 - a1, static_cast<float>(2*M_PI));
    1:   if (delta < 0) {
    1:     delta += 2*M_PI;
    1:   }
    1:   /* delta is now the angle from a1 around to a2, in the range [0, 2*M_PI) */
    1:   float r = a1 + delta/2;
    1:   if (delta >= M_PI) {
    1:     /* the arc from a2 to a1 is smaller, so use the ray on that side */
    1:     r += M_PI;
    1:   }
    1:   return r;
    1: }
    1: 
    1: nsSVGOuterSVGFrame *
    1: nsSVGUtils::GetOuterSVGFrame(nsIFrame *aFrame)
    1: {
    1:   while (aFrame) {
    1:     if (aFrame->GetStateBits() & NS_STATE_IS_OUTER_SVG) {
 3233:       return static_cast<nsSVGOuterSVGFrame*>(aFrame);
    1:     }
    1:     aFrame = aFrame->GetParent();
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
 2014: nsIFrame*
 2014: nsSVGUtils::GetOuterSVGFrameAndCoveredRegion(nsIFrame* aFrame, nsRect* aRect)
 2014: {
23554:   nsISVGChildFrame* svg = do_QueryFrame(aFrame);
 2014:   if (!svg)
 2014:     return nsnull;
59725:   *aRect = (aFrame->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD) ?
59725:              nsRect(0, 0, 0, 0) : svg->GetCoveredRegion();
 2014:   return GetOuterSVGFrame(aFrame);
 2014: }
 2014: 
30596: gfxMatrix
37974: nsSVGUtils::GetViewBoxTransform(nsSVGElement* aElement,
37974:                                 float aViewportWidth, float aViewportHeight,
    1:                                 float aViewboxX, float aViewboxY,
    1:                                 float aViewboxWidth, float aViewboxHeight,
59470:                                 const SVGAnimatedPreserveAspectRatio &aPreserveAspectRatio)
    1: {
59472:   return GetViewBoxTransform(aElement,
59472:                              aViewportWidth, aViewportHeight,
59472:                              aViewboxX, aViewboxY,
59472:                              aViewboxWidth, aViewboxHeight,
59472:                              aPreserveAspectRatio.GetAnimValue());
59472: }
59472: 
59472: gfxMatrix
59472: nsSVGUtils::GetViewBoxTransform(nsSVGElement* aElement,
59472:                                 float aViewportWidth, float aViewportHeight,
59472:                                 float aViewboxX, float aViewboxY,
59472:                                 float aViewboxWidth, float aViewboxHeight,
59472:                                 const SVGPreserveAspectRatio &aPreserveAspectRatio)
59472: {
59473:   NS_ASSERTION(aViewportWidth  >= 0, "viewport width must be nonnegative!");
59473:   NS_ASSERTION(aViewportHeight >= 0, "viewport height must be nonnegative!");
12023:   NS_ASSERTION(aViewboxWidth  > 0, "viewBox width must be greater than zero!");
12023:   NS_ASSERTION(aViewboxHeight > 0, "viewBox height must be greater than zero!");
12023: 
59472:   PRUint16 align = aPreserveAspectRatio.GetAlign();
59472:   PRUint16 meetOrSlice = aPreserveAspectRatio.GetMeetOrSlice();
    1: 
    1:   // default to the defaults
    1:   if (align == nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_UNKNOWN)
    1:     align = nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMID;
    1:   if (meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_UNKNOWN)
    1:     meetOrSlice = nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_MEET;
    1: 
    1:   float a, d, e, f;
    1:   a = aViewportWidth / aViewboxWidth;
    1:   d = aViewportHeight / aViewboxHeight;
    1:   e = 0.0f;
    1:   f = 0.0f;
    1: 
    1:   if (align != nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_NONE &&
    1:       a != d) {
19264:     if ((meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_MEET &&
19264:         a < d) ||
19264:         (meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_SLICE &&
19264:         d < a)) {
    1:       d = a;
    1:       switch (align) {
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMIN:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMIN:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMIN:
    1:         break;
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMID:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMID:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMID:
    1:         f = (aViewportHeight - a * aViewboxHeight) / 2.0f;
    1:         break;
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMAX:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
    1:         f = aViewportHeight - a * aViewboxHeight;
    1:         break;
    1:       default:
    1:         NS_NOTREACHED("Unknown value for align");
    1:       }
    1:     }
    1:     else if (
19264:       (meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_MEET &&
19264:       d < a) ||
19264:       (meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_SLICE &&
19264:       a < d)) {
    1:       a = d;
    1:       switch (align) {
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMIN:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMID:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMAX:
    1:         break;
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMIN:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMID:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
    1:         e = (aViewportWidth - a * aViewboxWidth) / 2.0f;
    1:         break;
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMIN:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMID:
    1:       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
    1:         e = aViewportWidth - a * aViewboxWidth;
    1:         break;
    1:       default:
    1:         NS_NOTREACHED("Unknown value for align");
    1:       }
    1:     }
    1:     else NS_NOTREACHED("Unknown value for meetOrSlice");
    1:   }
    1:   
    1:   if (aViewboxX) e += -a * aViewboxX;
    1:   if (aViewboxY) f += -d * aViewboxY;
    1:   
30596:   return gfxMatrix(a, 0.0f, 0.0f, d, e, f);
    1: }
    1: 
27899: gfxMatrix
    1: nsSVGUtils::GetCanvasTM(nsIFrame *aFrame)
    1: {
27899:   // XXX yuck, we really need a common interface for GetCanvasTM
27899: 
27899:   if (!aFrame->IsFrameOfType(nsIFrame::eSVG)) {
30596:     return nsSVGIntegrationUtils::GetInitialMatrix(aFrame);
27899:   }
19125: 
25737:   nsIAtom* type = aFrame->GetType();
25737:   if (type == nsGkAtoms::svgForeignObjectFrame) {
27899:     return static_cast<nsSVGForeignObjectFrame*>(aFrame)->GetCanvasTM();
 1519:   }
27899: 
27899:   nsSVGContainerFrame *containerFrame = do_QueryFrame(aFrame);
27899:   if (containerFrame) {
    1:     return containerFrame->GetCanvasTM();
    1:   }
    1: 
27899:   return static_cast<nsSVGGeometryFrame*>(aFrame)->GetCanvasTM();
    1: }
    1: 
    1: void 
10661: nsSVGUtils::NotifyChildrenOfSVGChange(nsIFrame *aFrame, PRUint32 aFlags)
 9548: {
37141:   nsIFrame *kid = aFrame->GetFirstChild(nsnull);
 9548: 
37141:   while (kid) {
37141:     nsISVGChildFrame* SVGFrame = do_QueryFrame(kid);
 9548:     if (SVGFrame) {
10661:       SVGFrame->NotifySVGChanged(aFlags); 
 9548:     } else {
37141:       NS_ASSERTION(kid->IsFrameOfType(nsIFrame::eSVG), "SVG frame expected");
 9548:       // recurse into the children of container frames e.g. <clipPath>, <mask>
 9548:       // in case they have child frames with transformation matrices
37141:       nsSVGUtils::NotifyChildrenOfSVGChange(kid, aFlags);
 9548:     }
37141:     kid = kid->GetNextSibling();
 9548:   }
 9548: }
 9548: 
    1: // ************************************************************
    1: 
19125: class SVGPaintCallback : public nsSVGFilterPaintCallback
19125: {
19125: public:
19125:   virtual void Paint(nsSVGRenderState *aContext, nsIFrame *aTarget,
20534:                      const nsIntRect* aDirtyRect)
19125:   {
23554:     nsISVGChildFrame *svgChildFrame = do_QueryFrame(aTarget);
19125:     NS_ASSERTION(svgChildFrame, "Expected SVG frame here");
19125: 
20534:     nsIntRect* dirtyRect = nsnull;
20534:     nsIntRect tmpDirtyRect;
20534: 
20534:     // aDirtyRect is in user-space pixels, we need to convert to
20534:     // outer-SVG-frame-relative device pixels.
20534:     if (aDirtyRect) {
27899:       gfxMatrix userToDeviceSpace = nsSVGUtils::GetCanvasTM(aTarget);
27899:       if (userToDeviceSpace.IsSingular()) {
27899:         return;
27899:       }
24804:       gfxRect dirtyBounds = userToDeviceSpace.TransformBounds(
20534:         gfxRect(aDirtyRect->x, aDirtyRect->y, aDirtyRect->width, aDirtyRect->height));
20534:       dirtyBounds.RoundOut();
58579:       if (gfxUtils::GfxRectToIntRect(dirtyBounds, &tmpDirtyRect)) {
20534:         dirtyRect = &tmpDirtyRect;
20534:       }
19125:     }
19125: 
20534:     svgChildFrame->PaintSVG(aContext, dirtyRect);
19125:   }
19125: };
19125: 
    1: void
20652: nsSVGUtils::PaintFrameWithEffects(nsSVGRenderState *aContext,
20652:                                   const nsIntRect *aDirtyRect,
    1:                                   nsIFrame *aFrame)
    1: {
23554:   nsISVGChildFrame *svgChildFrame = do_QueryFrame(aFrame);
    1:   if (!svgChildFrame)
    1:     return;
    1: 
    1:   float opacity = aFrame->GetStyleDisplay()->mOpacity;
    1:   if (opacity == 0.0f)
    1:     return;
    1: 
    1:   /* Properties are added lazily and may have been removed by a restyle,
    1:      so make sure all applicable ones are set again. */
    1: 
16501:   nsSVGEffects::EffectProperties effectProperties =
16501:     nsSVGEffects::GetEffectProperties(aFrame);
    1: 
19125:   PRBool isOK = PR_TRUE;
19948:   nsSVGFilterFrame *filterFrame = effectProperties.GetFilterFrame(&isOK);
19125: 
19125:   /* Check if we need to draw anything. HasValidCoveredRect only returns
19125:    * true for path geometry and glyphs, so basically we're traversing
19125:    * all containers and we can only skip leaves here.
19125:    */
16124:   if (aDirtyRect && svgChildFrame->HasValidCoveredRect()) {
19125:     if (filterFrame) {
19125:       if (!aDirtyRect->Intersects(filterFrame->GetFilterBBox(aFrame, nsnull)))
19125:         return;
19125:     } else {
28113:       nsRect rect = aDirtyRect->ToAppUnits(aFrame->PresContext()->AppUnitsPerDevPixel());
18367:       if (!rect.Intersects(aFrame->GetRect()))
    1:         return;
    1:     }
    1:   }
    1: 
    1:   /* SVG defines the following rendering model:
    1:    *
34189:    *  1. Render fill
34189:    *  2. Render stroke
34189:    *  3. Render markers
34189:    *  4. Apply filter
34189:    *  5. Apply clipping, masking, group opacity
    1:    *
  831:    * We follow this, but perform a couple of optimizations:
    1:    *
    1:    * + Use cairo's clipPath when representable natively (single object
    1:    *   clip region).
    1:    *
    1:    * + Merge opacity and masking if both used together.
    1:    */
    1: 
  831:   if (opacity != 1.0f && CanOptimizeOpacity(aFrame))
  831:     opacity = 1.0f;
    1: 
    1:   gfxContext *gfx = aContext->GetGfxContext();
 1707:   PRBool complexEffects = PR_FALSE;
    1: 
19948:   nsSVGClipPathFrame *clipPathFrame = effectProperties.GetClipPathFrame(&isOK);
19948:   nsSVGMaskFrame *maskFrame = effectProperties.GetMaskFrame(&isOK);
16406: 
  831:   PRBool isTrivialClip = clipPathFrame ? clipPathFrame->IsTrivial() : PR_TRUE;
  831: 
16406:   if (!isOK) {
59507:     // Some resource is invalid. We shouldn't paint anything.
16406:     return;
16406:   }
  831:   
30596:   gfxMatrix matrix;
30596:   if (clipPathFrame || maskFrame)
30596:     matrix = GetCanvasTM(aFrame);
  831: 
    1:   /* Check if we need to do additional operations on this child's
    1:    * rendering, which necessitates rendering into another surface. */
  831:   if (opacity != 1.0f || maskFrame || (clipPathFrame && !isTrivialClip)) {
 1707:     complexEffects = PR_TRUE;
 1707:     gfx->Save();
 1707:     gfx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
    1:   }
    1: 
    1:   /* If this frame has only a trivial clipPath, set up cairo's clipping now so
    1:    * we can just do normal painting and get it clipped appropriately.
    1:    */
  831:   if (clipPathFrame && isTrivialClip) {
    1:     gfx->Save();
19125:     clipPathFrame->ClipPaint(aContext, aFrame, matrix);
    1:   }
    1: 
    1:   /* Paint the child */
  831:   if (filterFrame) {
19125:     SVGPaintCallback paintCallback;
19125:     filterFrame->FilterPaint(aContext, aFrame, &paintCallback, aDirtyRect);
    1:   } else {
    1:     svgChildFrame->PaintSVG(aContext, aDirtyRect);
    1:   }
    1: 
  831:   if (clipPathFrame && isTrivialClip) {
    1:     gfx->Restore();
    1:   }
    1: 
    1:   /* No more effects, we're done. */
 1707:   if (!complexEffects)
    1:     return;
    1: 
 1707:   gfx->PopGroupToSource();
    1: 
 1707:   nsRefPtr<gfxPattern> maskSurface =
19125:     maskFrame ? maskFrame->ComputeMaskAlpha(aContext, aFrame,
  831:                                             matrix, opacity) : nsnull;
    1: 
 1707:   nsRefPtr<gfxPattern> clipMaskSurface;
  831:   if (clipPathFrame && !isTrivialClip) {
 1707:     gfx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
  831: 
19125:     nsresult rv = clipPathFrame->ClipPaint(aContext, aFrame, matrix);
 1707:     clipMaskSurface = gfx->PopGroup();
  831: 
  831:     if (NS_SUCCEEDED(rv) && clipMaskSurface) {
    1:       // Still more set after clipping, so clip to another surface
  831:       if (maskSurface || opacity != 1.0f) {
 1707:         gfx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
 1707:         gfx->Mask(clipMaskSurface);
 1707:         gfx->PopGroupToSource();
    1:       } else {
 1707:         gfx->Mask(clipMaskSurface);
    1:       }
    1:     }
  831:   }
    1: 
    1:   if (maskSurface) {
 1707:     gfx->Mask(maskSurface);
  831:   } else if (opacity != 1.0f) {
 1707:     gfx->Paint(opacity);
    1:   }
    1: 
 1707:   gfx->Restore();
    1: }
    1: 
    1: PRBool
18367: nsSVGUtils::HitTestClip(nsIFrame *aFrame, const nsPoint &aPoint)
    1: {
16501:   nsSVGEffects::EffectProperties props =
16501:     nsSVGEffects::GetEffectProperties(aFrame);
16406:   if (!props.mClipPath)
16406:     return PR_TRUE;
  831: 
38838:   PRBool isOK = PR_TRUE;
38838:   nsSVGClipPathFrame *clipPathFrame = props.GetClipPathFrame(&isOK);
38838:   if (!clipPathFrame || !isOK) {
16406:     // clipPath is not a valid resource, so nothing gets painted, so
16406:     // hit-testing must fail.
16406:     return PR_FALSE;
16406:   }
16406: 
30596:   return clipPathFrame->ClipHitTest(aFrame, GetCanvasTM(aFrame), aPoint);
    1: }
    1: 
18367: nsIFrame *
18367: nsSVGUtils::HitTestChildren(nsIFrame *aFrame, const nsPoint &aPoint)
    1: {
33390:   // Traverse the list in reverse order, so that if we get a hit we know that's
33390:   // the topmost frame that intersects the point; then we can just return it.
18367:   nsIFrame* result = nsnull;
33390:   for (nsIFrame* current = aFrame->GetChildList(nsnull).LastChild();
33390:        current;
33390:        current = current->GetPrevSibling()) {
23554:     nsISVGChildFrame* SVGFrame = do_QueryFrame(current);
    1:     if (SVGFrame) {
18367:        result = SVGFrame->GetFrameForPoint(aPoint);
18367:        if (result)
    1:          break;
    1:     }
    1:   }
    1: 
18367:   if (result && !HitTestClip(aFrame, aPoint))
18367:     result = nsnull;
18367: 
18367:   return result;
    1: }
    1: 
    1: nsRect
    1: nsSVGUtils::GetCoveredRegion(const nsFrameList &aFrames)
    1: {
    1:   nsRect rect;
    1: 
    1:   for (nsIFrame* kid = aFrames.FirstChild();
    1:        kid;
    1:        kid = kid->GetNextSibling()) {
23554:     nsISVGChildFrame* child = do_QueryFrame(kid);
    1:     if (child) {
    1:       nsRect childRect = child->GetCoveredRegion();
    1:       rect.UnionRect(rect, childRect);
    1:     }
    1:   }
    1: 
    1:   return rect;
    1: }
    1: 
    1: nsRect
18367: nsSVGUtils::ToAppPixelRect(nsPresContext *aPresContext,
18367:                            double xmin, double ymin,
    1:                            double xmax, double ymax)
    1: {
18367:   return ToAppPixelRect(aPresContext,
18367:                         gfxRect(xmin, ymin, xmax - xmin, ymax - ymin));
    1: }
    1: 
    1: nsRect
18367: nsSVGUtils::ToAppPixelRect(nsPresContext *aPresContext, const gfxRect& rect)
    1: {
18367:   return nsRect(aPresContext->DevPixelsToAppUnits(NSToIntFloor(rect.X())),
18367:                 aPresContext->DevPixelsToAppUnits(NSToIntFloor(rect.Y())),
18367:                 aPresContext->DevPixelsToAppUnits(NSToIntCeil(rect.XMost()) - NSToIntFloor(rect.X())),
18367:                 aPresContext->DevPixelsToAppUnits(NSToIntCeil(rect.YMost()) - NSToIntFloor(rect.Y())));
    1: }
    1: 
    1: gfxMatrix
    1: nsSVGUtils::ConvertSVGMatrixToThebes(nsIDOMSVGMatrix *aMatrix)
    1: {
27899:   if (!aMatrix) {
27899:     return gfxMatrix();
27899:   }
    1:   float A, B, C, D, E, F;
    1:   aMatrix->GetA(&A);
    1:   aMatrix->GetB(&B);
    1:   aMatrix->GetC(&C);
    1:   aMatrix->GetD(&D);
    1:   aMatrix->GetE(&E);
    1:   aMatrix->GetF(&F);
    1:   return gfxMatrix(A, B, C, D, E, F);
    1: }
    1: 
    1: PRBool
30596: nsSVGUtils::HitTestRect(const gfxMatrix &aMatrix,
    1:                         float aRX, float aRY, float aRWidth, float aRHeight,
    1:                         float aX, float aY)
    1: {
30596:   if (aMatrix.IsSingular()) {
30596:     return PR_FALSE;
30596:   }
51039:   gfxContext ctx(gfxPlatform::GetPlatform()->ScreenReferenceSurface());
30596:   ctx.SetMatrix(aMatrix);
 1776:   ctx.NewPath();
 1776:   ctx.Rectangle(gfxRect(aRX, aRY, aRWidth, aRHeight));
 1776:   ctx.IdentityMatrix();
30596:   return ctx.PointInFill(gfxPoint(aX, aY));
    1: }
    1: 
29308: gfxRect
29308: nsSVGUtils::GetClipRectForFrame(nsIFrame *aFrame,
29308:                                 float aX, float aY, float aWidth, float aHeight)
29308: {
29308:   const nsStyleDisplay* disp = aFrame->GetStyleDisplay();
29308: 
29308:   if (!(disp->mClipFlags & NS_STYLE_CLIP_RECT)) {
29308:     NS_ASSERTION(disp->mClipFlags == NS_STYLE_CLIP_AUTO,
29308:                  "We don't know about this type of clip.");
29308:     return gfxRect(aX, aY, aWidth, aHeight);
29308:   }
29308: 
29308:   if (disp->mOverflowX == NS_STYLE_OVERFLOW_HIDDEN ||
29308:       disp->mOverflowY == NS_STYLE_OVERFLOW_HIDDEN) {
29308: 
29308:     nsIntRect clipPxRect =
29308:       disp->mClip.ToOutsidePixels(aFrame->PresContext()->AppUnitsPerDevPixel());
29308:     gfxRect clipRect =
29308:       gfxRect(clipPxRect.x, clipPxRect.y, clipPxRect.width, clipPxRect.height);
29308: 
29308:     if (NS_STYLE_CLIP_RIGHT_AUTO & disp->mClipFlags) {
29308:       clipRect.size.width = aWidth - clipRect.X();
29308:     }
29308:     if (NS_STYLE_CLIP_BOTTOM_AUTO & disp->mClipFlags) {
29308:       clipRect.size.height = aHeight - clipRect.Y();
29308:     }
29308: 
29308:     if (disp->mOverflowX != NS_STYLE_OVERFLOW_HIDDEN) {
29308:       clipRect.pos.x = aX;
29308:       clipRect.size.width = aWidth;
29308:     }
29308:     if (disp->mOverflowY != NS_STYLE_OVERFLOW_HIDDEN) {
29308:       clipRect.pos.y = aY;
29308:       clipRect.size.height = aHeight;
29308:     }
29308:      
29308:     return clipRect;
29308:   }
29308:   return gfxRect(aX, aY, aWidth, aHeight);
29308: }
29308: 
    1: void
    1: nsSVGUtils::CompositeSurfaceMatrix(gfxContext *aContext,
    1:                                    gfxASurface *aSurface,
30596:                                    const gfxMatrix &aCTM, float aOpacity)
    1: {
30596:   if (aCTM.IsSingular())
    1:     return;
    1: 
    1:   aContext->Save();
30596:   aContext->Multiply(aCTM);
    1:   aContext->SetSource(aSurface);
    1:   aContext->Paint(aOpacity);
    1:   aContext->Restore();
    1: }
    1: 
    1: void
12652: nsSVGUtils::CompositePatternMatrix(gfxContext *aContext,
12652:                                    gfxPattern *aPattern,
30596:                                    const gfxMatrix &aCTM, float aWidth, float aHeight, float aOpacity)
12652: {
30596:   if (aCTM.IsSingular())
12652:     return;
12652: 
12652:   aContext->Save();
30596:   SetClipRect(aContext, aCTM, gfxRect(0, 0, aWidth, aHeight));
30596:   aContext->Multiply(aCTM);
12652:   aContext->SetPattern(aPattern);
12652:   aContext->Paint(aOpacity);
12652:   aContext->Restore();
12652: }
12652: 
12652: void
    1: nsSVGUtils::SetClipRect(gfxContext *aContext,
29327:                         const gfxMatrix &aCTM,
29308:                         const gfxRect &aRect)
    1: {
29327:   if (aCTM.IsSingular())
    1:     return;
    1: 
    1:   gfxMatrix oldMatrix = aContext->CurrentMatrix();
29327:   aContext->Multiply(aCTM);
29308:   aContext->Clip(aRect);
    1:   aContext->SetMatrix(oldMatrix);
    1: }
    1: 
15915: void
15915: nsSVGUtils::ClipToGfxRect(nsIntRect* aRect, const gfxRect& aGfxRect)
15915: {
15915:   gfxRect r = aGfxRect;
15915:   r.RoundOut();
15915:   gfxRect r2(aRect->x, aRect->y, aRect->width, aRect->height);
15915:   r = r.Intersect(r2);
15915:   *aRect = nsIntRect(PRInt32(r.X()), PRInt32(r.Y()),
15915:                      PRInt32(r.Width()), PRInt32(r.Height()));
15915: }
15915: 
29067: gfxRect
19125: nsSVGUtils::GetBBox(nsIFrame *aFrame)
19125: {
49139:   if (aFrame->GetContent()->IsNodeOfType(nsINode::eTEXT)) {
49139:     aFrame = aFrame->GetParent();
49139:   }
29067:   gfxRect bbox;
23554:   nsISVGChildFrame *svg = do_QueryFrame(aFrame);
29067:   if (svg) {
49139:     // It is possible to apply a gradient, pattern, clipping path, mask or
49139:     // filter to text. When one of these facilities is applied to text
49139:     // the bounding box is the entire text element in all
49139:     // cases.
55292:     nsSVGTextContainerFrame* metrics = do_QueryFrame(
55292:       GetFirstNonAAncestorFrame(aFrame));
49139:     if (metrics) {
49139:       while (aFrame->GetType() != nsGkAtoms::svgTextFrame) {
49139:         aFrame = aFrame->GetParent();
49139:       }
49139:       svg = do_QueryFrame(aFrame);
49139:     }
29067:     bbox = svg->GetBBoxContribution(gfxMatrix());
29067:   } else {
29067:     bbox = nsSVGIntegrationUtils::GetSVGBBoxForNonSVGFrame(aFrame);
19125:   }
29067:   NS_ASSERTION(bbox.Width() >= 0.0 && bbox.Height() >= 0.0, "Invalid bbox!");
29067:   return bbox;
19125: }
19125: 
19125: gfxRect
19125: nsSVGUtils::GetRelativeRect(PRUint16 aUnits, const nsSVGLength2 *aXYWH,
29067:                             const gfxRect &aBBox, nsIFrame *aFrame)
19125: {
19125:   float x, y, width, height;
19125:   if (aUnits == nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
29067:     x = aBBox.X() + ObjectSpace(aBBox, &aXYWH[0]);
29067:     y = aBBox.Y() + ObjectSpace(aBBox, &aXYWH[1]);
19125:     width = ObjectSpace(aBBox, &aXYWH[2]);
19125:     height = ObjectSpace(aBBox, &aXYWH[3]);
19125:   } else {
19125:     x = nsSVGUtils::UserSpace(aFrame, &aXYWH[0]);
19125:     y = nsSVGUtils::UserSpace(aFrame, &aXYWH[1]);
19125:     width = nsSVGUtils::UserSpace(aFrame, &aXYWH[2]);
19125:     height = nsSVGUtils::UserSpace(aFrame, &aXYWH[3]);
19125:   }
19125:   return gfxRect(x, y, width, height);
19125: }
19125: 
    1: PRBool
    1: nsSVGUtils::CanOptimizeOpacity(nsIFrame *aFrame)
    1: {
    1:   nsIAtom *type = aFrame->GetType();
34189:   if (type != nsGkAtoms::svgImageFrame &&
34189:       type != nsGkAtoms::svgPathGeometryFrame) {
34189:     return PR_FALSE;
34189:   }
34189:   if (aFrame->GetStyleSVGReset()->mFilter) {
34189:     return PR_FALSE;
34189:   }
34189:   // XXX The SVG WG is intending to allow fill, stroke and markers on <image>
34189:   if (type == nsGkAtoms::svgImageFrame) {
    1:     return PR_TRUE;
    1:   }
34189:   const nsStyleSVG *style = aFrame->GetStyleSVG();
34189:   if (style->mMarkerStart || style->mMarkerMid || style->mMarkerEnd) {
34189:     return PR_FALSE;
34189:   }
34189:   if (style->mFill.mType == eStyleSVGPaintType_None ||
34189:       style->mFillOpacity <= 0 ||
34189:       !static_cast<nsSVGPathGeometryFrame*>(aFrame)->HasStroke()) {
34189:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
 6539: float
30596: nsSVGUtils::MaxExpansion(const gfxMatrix &aMatrix)
 6539: {
 6539:   // maximum expansion derivation from
 6539:   // http://lists.cairographics.org/archives/cairo/2004-October/001980.html
30596:   // and also implemented in cairo_matrix_transformed_circle_major_axis
30596:   double a = aMatrix.xx;
30596:   double b = aMatrix.yx;
30596:   double c = aMatrix.xy;
30596:   double d = aMatrix.yy;
30596:   double f = (a * a + b * b + c * c + d * d) / 2;
30596:   double g = (a * a + b * b - c * c - d * d) / 2;
30596:   double h = a * c + b * d;
 6539:   return sqrt(f + sqrt(g * g + h * h));
 6539: }
 6539: 
30596: gfxMatrix
30596: nsSVGUtils::AdjustMatrixForUnits(const gfxMatrix &aMatrix,
 8640:                                  nsSVGEnum *aUnits,
19125:                                  nsIFrame *aFrame)
 8640: {
 8640:   if (aFrame &&
38700:       aUnits->GetAnimValue() ==
37441:       nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
29067:     gfxRect bbox = GetBBox(aFrame);
30596:     return gfxMatrix().Scale(bbox.Width(), bbox.Height()) *
30596:            gfxMatrix().Translate(gfxPoint(bbox.X(), bbox.Y())) *
30596:            aMatrix;
 8640:   }
30596:   return aMatrix;
 8640: }
 8640: 
23953: nsIFrame*
23953: nsSVGUtils::GetFirstNonAAncestorFrame(nsIFrame* aStartFrame)
23953: {
23953:   for (nsIFrame *ancestorFrame = aStartFrame; ancestorFrame;
23953:        ancestorFrame = ancestorFrame->GetParent()) {
23953:     if (ancestorFrame->GetType() != nsGkAtoms::svgAFrame) {
23953:       return ancestorFrame;
23953:     }
23953:   }
23953:   return nsnull;
23953: }
23953: 
 5947: #ifdef DEBUG
 5947: void
 5947: nsSVGUtils::WritePPM(const char *fname, gfxImageSurface *aSurface)
 5947: {
 5947:   FILE *f = fopen(fname, "wb");
 5947:   if (!f)
 5947:     return;
 5947: 
 5947:   gfxIntSize size = aSurface->GetSize();
 5947:   fprintf(f, "P6\n%d %d\n255\n", size.width, size.height);
 5947:   unsigned char *data = aSurface->Data();
 5947:   PRInt32 stride = aSurface->Stride();
 5947:   for (int y=0; y<size.height; y++) {
 5947:     for (int x=0; x<size.width; x++) {
 5947:       fwrite(data + y * stride + 4 * x + GFX_ARGB32_OFFSET_R, 1, 1, f);
 5947:       fwrite(data + y * stride + 4 * x + GFX_ARGB32_OFFSET_G, 1, 1, f);
 5947:       fwrite(data + y * stride + 4 * x + GFX_ARGB32_OFFSET_B, 1, 1, f);
 5947:     }
 5947:   }
 5947:   fclose(f);
 5947: }
 5947: #endif
 5947: 
26759: /*static*/ gfxRect
26759: nsSVGUtils::PathExtentsToMaxStrokeExtents(const gfxRect& aPathExtents,
26759:                                           nsSVGGeometryFrame* aFrame)
26759: {
26759:   // The logic here comes from _cairo_stroke_style_max_distance_from_path
26759: 
26759:   double style_expansion = 0.5;
26759: 
26759:   const nsStyleSVG* style = aFrame->GetStyleSVG();
26759: 
26759:   if (style->mStrokeLinecap == NS_STYLE_STROKE_LINECAP_SQUARE) {
26759:     style_expansion = M_SQRT1_2;
26759:   }
26759: 
26759:   if (style->mStrokeLinejoin == NS_STYLE_STROKE_LINEJOIN_MITER &&
26759:       style_expansion < style->mStrokeMiterlimit) {
26759:     style_expansion = style->mStrokeMiterlimit;
26759:   }
26759: 
26759:   style_expansion *= aFrame->GetStrokeWidth();
26759: 
27899:   gfxMatrix ctm = aFrame->GetCanvasTM();
26759: 
27899:   double dx = style_expansion * (fabs(ctm.xx) + fabs(ctm.xy));
27899:   double dy = style_expansion * (fabs(ctm.yy) + fabs(ctm.yx));
26759: 
26759:   gfxRect strokeExtents = aPathExtents;
26759:   strokeExtents.Outset(dy, dx, dy, dx);
26759:   return strokeExtents;
26759: }
26759: 
30596: /* static */ PRBool
30596: nsSVGUtils::IsInnerSVG(nsIContent* aContent)
30596: {
30596:   if (!aContent->NodeInfo()->Equals(nsGkAtoms::svg, kNameSpaceID_SVG)) {
30596:     return PR_FALSE;
30596:   }
30596:   nsIContent *ancestor = GetParentElement(aContent);
30596:   return ancestor && ancestor->GetNameSpaceID() == kNameSpaceID_SVG &&
30596:                      ancestor->Tag() != nsGkAtoms::foreignObject;
30596: }
30596: 
    1: // ----------------------------------------------------------------------
    1: 
    1: nsSVGRenderState::nsSVGRenderState(nsIRenderingContext *aContext) :
55826:   mRenderMode(NORMAL), mRenderingContext(aContext), mPaintingToWindow(PR_FALSE)
    1: {
 9438:   mGfxContext = aContext->ThebesContext();
    1: }
    1: 
50426: nsSVGRenderState::nsSVGRenderState(gfxContext *aContext) :
55826:   mRenderMode(NORMAL), mGfxContext(aContext), mPaintingToWindow(PR_FALSE)
50426: {
50426: }
50426: 
16577: nsSVGRenderState::nsSVGRenderState(gfxASurface *aSurface) :
55826:   mRenderMode(NORMAL), mPaintingToWindow(PR_FALSE)
    1: {
16577:   mGfxContext = new gfxContext(aSurface);
    1: }
16577: 
16577: nsIRenderingContext*
16577: nsSVGRenderState::GetRenderingContext(nsIFrame *aFrame)
16577: {
16577:   if (!mRenderingContext) {
16577:     nsIDeviceContext* devCtx = aFrame->PresContext()->DeviceContext();
16577:     devCtx->CreateRenderingContextInstance(*getter_AddRefs(mRenderingContext));
19125:     if (!mRenderingContext)
19125:       return nsnull;
16577:     mRenderingContext->Init(devCtx, mGfxContext);
16577:   }
16577:   return mRenderingContext;
16577: }
29067: 
54979: /* static */ PRBool
54979: nsSVGUtils::RootSVGElementHasViewbox(const nsIContent *aRootSVGElem)
54979: {
54979:   if (aRootSVGElem->GetNameSpaceID() != kNameSpaceID_SVG ||
54979:       aRootSVGElem->Tag() != nsGkAtoms::svg) {
54979:     NS_ABORT_IF_FALSE(PR_FALSE, "Expecting an SVG <svg> node");
54979:     return PR_FALSE;
54979:   }
54979: 
54979:   const nsSVGSVGElement *svgSvgElem =
54979:     static_cast<const nsSVGSVGElement*>(aRootSVGElem);
54979: 
54979:   return svgSvgElem->HasValidViewbox();
54979: }
