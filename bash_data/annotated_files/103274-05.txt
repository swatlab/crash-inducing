33581: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
98983:  * This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
    1: 
    1: #ifndef jsfun_h___
    1: #define jsfun_h___
    1: /*
    1:  * JS function definitions.
    1:  */
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
13824: #include "jsobj.h"
48676: #include "jsatom.h"
59968: #include "jsscript.h"
48676: #include "jsstr.h"
    1: 
82129: #include "gc/Barrier.h"
82129: 
27012: /*
28832:  * The high two bits of JSFunction.flags encode whether the function is native
28832:  * or interpreted, and if interpreted, what kind of optimized closure form (if
27012:  * any) it might be.
27012:  *
27012:  *   00   not interpreted
93245:  *   01   interpreted, not null closure
27012:  *   11   interpreted, null closure
27012:  *
27012:  * NB: JSFUN_EXPR_CLOSURE reuses JSFUN_STUB_GSOPS, which is an API request flag
27012:  * bit only, never stored in fun->flags.
27012:  *
76812:  * If we need more bits in the future, all flags for interpreted functions can
76812:  * move to u.i.script->flags. For now we use function flag bits to minimize
27012:  * pointer-chasing.
27012:  */
55498: #define JSFUN_PROTOTYPE     0x0800  /* function is Function.prototype for some
55498:                                        global object */
55498: 
27012: #define JSFUN_EXPR_CLOSURE  0x1000  /* expression closure: function(x) x*x */
83258: #define JSFUN_EXTENDED      0x2000  /* structure is FunctionExtended */
94094: #define JSFUN_INTERPRETED   0x4000  /* use u.i if kind >= this value else u.native */
93245: #define JSFUN_NULL_CLOSURE  0x8000  /* null closure entrains no scope chain */
27012: #define JSFUN_KINDMASK      0xc000  /* encode interp vs. native and closure
27012:                                        optimization level -- see above */
 4127: 
83258: namespace js { class FunctionExtended; }
83258: 
83258: struct JSFunction : public JSObject
38549: {
84755:     uint16_t        nargs;        /* maximum number of specified arguments,
28832:                                      reflected as f.length/f.arity */
84755:     uint16_t        flags;        /* flags, see JSFUN_* below and in jsapi.h */
52872:     union U {
48470:         js::Native  native;       /* native method pointer or null */
52872:         struct Scripted {
79820:             JSScript    *script_; /* interpreted bytecode descriptor or null;
84663:                                      use the accessor! */
84663:             JSObject    *env_;    /* environment for new activations;
84663:                                      use the accessor! */
28832:         } i;
57713:         void            *nativeOrScript;
28832:     } u;
93607:     js::HeapPtrAtom  atom;        /* name for diagnostics and decompiling */
28832: 
99552:     bool hasDefaults()       const { return flags & JSFUN_HAS_DEFAULTS; }
99225:     bool hasRest()           const { return flags & JSFUN_HAS_REST; }
76812:     bool isInterpreted()     const { return kind() >= JSFUN_INTERPRETED; }
76812:     bool isNative()          const { return !isInterpreted(); }
86533:     bool isNativeConstructor() const { return flags & JSFUN_CONSTRUCTOR; }
42714:     bool isHeavyweight()     const { return JSFUN_HEAVYWEIGHT_TEST(flags); }
76812:     bool isNullClosure()     const { return kind() == JSFUN_NULL_CLOSURE; }
55498:     bool isFunctionPrototype() const { return flags & JSFUN_PROTOTYPE; }
68964:     bool isInterpretedConstructor() const { return isInterpreted() && !isFunctionPrototype(); }
76812: 
84755:     uint16_t kind()          const { return flags & JSFUN_KINDMASK; }
84755:     void setKind(uint16_t k) {
76812:         JS_ASSERT(!(k & ~JSFUN_KINDMASK));
76812:         flags = (flags & ~JSFUN_KINDMASK) | k;
76812:     }
76812: 
59942:     /* Returns the strictness of this function, which must be interpreted. */
51095:     inline bool inStrictMode() const;
76812: 
84755:     void setArgCount(uint16_t nargs) {
59968:         JS_ASSERT(this->nargs == 0);
59968:         this->nargs = nargs;
37694:     }
37694: 
99225:     void setHasRest() {
99225:         JS_ASSERT(!hasRest());
99225:         this->flags |= JSFUN_HAS_REST;
99225:     }
99225: 
99552:     void setHasDefaults() {
99552:         JS_ASSERT(!hasDefaults());
99552:         this->flags |= JSFUN_HAS_DEFAULTS;
99552:     }
99552: 
84755:     /* uint16_t representation bounds number of call object dynamic slots. */
43223:     enum { MAX_ARGS_AND_VARS = 2 * ((1U << 16) - 1) };
43221: 
83244:     /*
83283:      * For an interpreted function, accessors for the initial scope object of
83283:      * activations (stack frames) of the function.
83244:      */
83283:     inline JSObject *environment() const;
83283:     inline void setEnvironment(JSObject *obj);
84663:     inline void initEnvironment(JSObject *obj);
53840: 
84663:     static inline size_t offsetOfEnvironment() { return offsetof(JSFunction, u.i.env_); }
48676: 
95099:     JSScript *script() const {
95099:         JS_ASSERT(isInterpreted());
95099:         return *(js::HeapPtrScript *)&u.i.script_;
95099:     }
95099: 
95099:     js::HeapPtrScript &mutableScript() {
72053:         JS_ASSERT(isInterpreted());
82129:         return *(js::HeapPtrScript *)&u.i.script_;
79820:     }
79820: 
82129:     inline void setScript(JSScript *script_);
82129:     inline void initScript(JSScript *script_);
53557: 
76812:     JSScript *maybeScript() const {
95099:         return isInterpreted() ? script() : NULL;
76812:     }
76812: 
78614:     JSNative native() const {
71697:         JS_ASSERT(isNative());
94094:         return u.native;
71697:     }
71697: 
78614:     JSNative maybeNative() const {
72053:         return isInterpreted() ? NULL : native();
53840:     }
53840: 
91237:     static unsigned offsetOfNativeOrScript() {
94094:         JS_STATIC_ASSERT(offsetof(U, native) == offsetof(U, i.script_));
94094:         JS_STATIC_ASSERT(offsetof(U, native) == offsetof(U, nativeOrScript));
57713:         return offsetof(JSFunction, u.nativeOrScript);
57713:     }
57713: 
83258: #if JS_BITS_PER_WORD == 32
93245:     static const js::gc::AllocKind FinalizeKind = js::gc::FINALIZE_OBJECT2_BACKGROUND;
93245:     static const js::gc::AllocKind ExtendedFinalizeKind = js::gc::FINALIZE_OBJECT4_BACKGROUND;
93245: #else
93245:     static const js::gc::AllocKind FinalizeKind = js::gc::FINALIZE_OBJECT4_BACKGROUND;
93245:     static const js::gc::AllocKind ExtendedFinalizeKind = js::gc::FINALIZE_OBJECT8_BACKGROUND;
93245: #endif
83258: 
83258:     inline void trace(JSTracer *trc);
83258: 
83301:     /* Bound function accessors. */
83301: 
97353:     inline bool initBoundFunction(JSContext *cx, js::HandleValue thisArg,
91237:                                   const js::Value *args, unsigned argslen);
83301: 
83301:     inline JSObject *getBoundFunctionTarget() const;
83301:     inline const js::Value &getBoundFunctionThis() const;
91237:     inline const js::Value &getBoundFunctionArgument(unsigned which) const;
83301:     inline size_t getBoundFunctionArgumentCount() const;
83301: 
83258:   private:
83258:     inline js::FunctionExtended *toExtended();
83258:     inline const js::FunctionExtended *toExtended() const;
83258: 
83258:     inline bool isExtended() const {
83258:         JS_STATIC_ASSERT(FinalizeKind != ExtendedFinalizeKind);
83258:         JS_ASSERT(!!(flags & JSFUN_EXTENDED) == (getAllocKind() == ExtendedFinalizeKind));
83258:         return !!(flags & JSFUN_EXTENDED);
82150:     }
83258: 
83258:   public:
83258:     /* Accessors for data stored in extended functions. */
83301:     inline void initializeExtended();
83301:     inline void setExtendedSlot(size_t which, const js::Value &val);
83301:     inline const js::Value &getExtendedSlot(size_t which) const;
83301: 
86875:   private:
86773:     /*
86773:      * These member functions are inherited from JSObject, but should never be applied to
86773:      * a value statically known to be a JSFunction.
86773:      */
86773:     inline JSFunction *toFunction() MOZ_DELETE;
86773:     inline const JSFunction *toFunction() const MOZ_DELETE;
28832: };
28832: 
53557: inline JSFunction *
83234: JSObject::toFunction()
53557: {
83234:     JS_ASSERT(JS_ObjectIsFunction(NULL, this));
83234:     return static_cast<JSFunction *>(this);
53557: }
53557: 
83234: inline const JSFunction *
83234: JSObject::toFunction() const
48470: {
83234:     JS_ASSERT(JS_ObjectIsFunction(NULL, const_cast<JSObject *>(this)));
83234:     return static_cast<const JSFunction *>(this);
48470: }
48470: 
51090: extern JSString *
91237: fun_toStringHelper(JSContext *cx, JSObject *obj, unsigned indent);
51090: 
53557: extern JSFunction *
91237: js_NewFunction(JSContext *cx, JSObject *funobj, JSNative native, unsigned nargs,
91237:                unsigned flags, js::HandleObject parent, JSAtom *atom,
83258:                js::gc::AllocKind kind = JSFunction::FinalizeKind);
40405: 
83234: extern JSFunction * JS_FASTCALL
95355: js_CloneFunctionObject(JSContext *cx, js::HandleFunction fun,
95355:                        js::HandleObject parent, js::HandleObject proto,
83258:                        js::gc::AllocKind kind = JSFunction::FinalizeKind);
38604: 
13702: extern JSFunction *
98960: js_DefineFunction(JSContext *cx, js::HandleObject obj, js::HandleId id, JSNative native,
91237:                   unsigned nargs, unsigned flags,
83258:                   js::gc::AllocKind kind = JSFunction::FinalizeKind);
    1: 
58293: namespace js {
    1: 
83258: /*
83301:  * Function extended with reserved slots for use by various kinds of functions.
83258:  * Most functions do not have these extensions, but enough are that efficient
83258:  * storage is required (no malloc'ed reserved slots).
83258:  */
83258: class FunctionExtended : public JSFunction
83258: {
83258:     friend struct JSFunction;
83258: 
83258:     /* Reserved slots available for storage by particular native functions. */
83301:     HeapValue extendedSlots[2];
83258: };
83258: 
58293: } // namespace js
29009: 
83258: inline js::FunctionExtended *
83258: JSFunction::toExtended()
83258: {
83258:     JS_ASSERT(isExtended());
83258:     return static_cast<js::FunctionExtended *>(this);
83258: }
83258: 
83258: inline const js::FunctionExtended *
83258: JSFunction::toExtended() const
83258: {
83258:     JS_ASSERT(isExtended());
83258:     return static_cast<const js::FunctionExtended *>(this);
83258: }
83258: 
37694: inline bool
37694: js_IsNamedLambda(JSFunction *fun) { return (fun->flags & JSFUN_LAMBDA) && fun->atom; }
37694: 
90546: namespace js {
90546: 
94006: template<XDRMode mode>
94006: bool
94006: XDRInterpretedFunction(XDRState<mode> *xdr, JSObject **objp, JSScript *parentScript);
90546: 
97298: extern JSObject *
97298: CloneInterpretedFunction(JSContext *cx, JSFunction *fun);
97298: 
90546: } /* namespace js */
    1: 
29887: extern JSBool
91237: js_fun_apply(JSContext *cx, unsigned argc, js::Value *vp);
21462: 
29887: extern JSBool
91237: js_fun_call(JSContext *cx, unsigned argc, js::Value *vp);
21462: 
94831: extern JSObject*
97353: js_fun_bind(JSContext *cx, js::HandleObject target, js::HandleValue thisArg,
94831:             js::Value *boundArgs, unsigned argslen);
94831: 
    1: #endif /* jsfun_h___ */
