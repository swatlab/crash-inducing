 47243: // Copyright (c) 2010, Google Inc.
 47243: // All rights reserved.
 47243: //
 47243: // Redistribution and use in source and binary forms, with or without
 47243: // modification, are permitted provided that the following conditions are
 47243: // met:
 47243: //
 47243: //     * Redistributions of source code must retain the above copyright
 47243: // notice, this list of conditions and the following disclaimer.
 47243: //     * Redistributions in binary form must reproduce the above
 47243: // copyright notice, this list of conditions and the following disclaimer
 47243: // in the documentation and/or other materials provided with the
 47243: // distribution.
 47243: //     * Neither the name of Google Inc. nor the names of its
 47243: // contributors may be used to endorse or promote products derived from
 47243: // this software without specific prior written permission.
 47243: //
 47243: // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 47243: // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 47243: // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 47243: // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 47243: // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 47243: // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 47243: // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 47243: // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 47243: // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 47243: // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 47243: // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 47243: 
 47243: // Original author: Jim Blandy <jimb@mozilla.com> <jimb@red-bean.com>
 47243: 
 47243: // macho_dump.cc: Dump the contents of a Mach-O file. This is mostly
 47243: // a test program for the Mach_O::FatReader and Mach_O::Reader classes.
 47243: 
 47243: #include <errno.h>
 47243: #include <fcntl.h>
 47243: #include <libgen.h>
 47243: #include <mach-o/arch.h>
 47243: #include <sys/mman.h>
 47243: #include <stdint.h>
 47243: #include <string.h>
 47243: #include <sys/stat.h>
 47243: #include <unistd.h>
 47243: 
 47243: #include <sstream>
 47243: #include <string>
 47243: #include <vector>
 47243: 
 47243: #include "common/byte_cursor.h"
118328: #include "common/mac/arch_utilities.h"
 47243: #include "common/mac/macho_reader.h"
 47243: 
 47243: using google_breakpad::ByteBuffer;
 47243: using std::ostringstream;
 47243: using std::string;
 47243: using std::vector;
 47243: 
 47243: namespace {
 47243: namespace mach_o = google_breakpad::mach_o;
 47243: 
 47243: string program_name;
 47243: 
 47243: int check_syscall(int result, const char *operation, const char *filename) {
 47243:   if (result < 0) {
 47243:     fprintf(stderr, "%s: %s '%s': %s\n",
 47243:             program_name.c_str(), operation,
 47243:             filename, strerror(errno));
 47243:     exit(1);
 47243:   }
 47243:   return result;
 47243: }
 47243: 
 47243: class DumpSection: public mach_o::Reader::SectionHandler {
 47243:  public:
 47243:   DumpSection() : index_(0) { }
 47243:   bool HandleSection(const mach_o::Section &section) {
 47243:     printf("        section %d '%s' in segment '%s'\n"
 47243:            "          address: 0x%llx\n"
 47243:            "          alignment: 1 << %d B\n"
 47243:            "          flags: %d\n"
 47243:            "          size: %ld\n",
 47243:            index_++, section.section_name.c_str(), section.segment_name.c_str(),
 47243:            section.address, section.align,
 47243:            mach_o::SectionFlags(section.flags),
 47243:            section.contents.Size());
 47243:     return true;
 47243:   }
 47243:          
 47243:  private:
 47243:   int index_;
 47243: };
 47243: 
 47243: class DumpCommand: public mach_o::Reader::LoadCommandHandler {
 47243:  public:
 47243:   DumpCommand(mach_o::Reader *reader) : reader_(reader), index_(0) { }
 47243:   bool UnknownCommand(mach_o::LoadCommandType type,
 47243:                       const ByteBuffer &contents) {
 47243:     printf("      load command %d: %d", index_++, type);
 47243:     return true;
 47243:   }
 47243:   bool SegmentCommand(const mach_o::Segment &segment) {
 47243:     printf("      load command %d: %s-bit segment '%s'\n"
 47243:            "        address: 0x%llx\n"
 47243:            "        memory size: 0x%llx\n"
 47243:            "        maximum protection: 0x%x\n"
 47243:            "        initial protection: 0x%x\n"
 47243:            "        flags: %d\n"
 47243:            "        section_list size: %ld B\n",
 47243:            index_++, (segment.bits_64 ? "64" : "32"), segment.name.c_str(),
 47243:            segment.vmaddr, segment.vmsize, segment.maxprot,
 47243:            segment.initprot, mach_o::SegmentFlags(segment.flags),
 47243:            segment.section_list.Size());
 47243:            
 47243:     DumpSection dump_section;
 47243:     return reader_->WalkSegmentSections(segment, &dump_section);
 47243:   }
 47243:  private:
 47243:   mach_o::Reader *reader_;
 47243:   int index_;
 47243: };
 47243: 
 47243: void DumpFile(const char *filename) {
 47243:   int fd = check_syscall(open(filename, O_RDONLY), "opening", filename);
 47243:   struct stat attributes;
 47243:   check_syscall(fstat(fd, &attributes),
 47243:                 "getting file attributes for", filename);
 47243:   void *mapping = mmap(NULL, attributes.st_size, PROT_READ,
 47243:                        MAP_PRIVATE, fd, 0);
 47243:   close(fd);
 47243:   check_syscall(mapping == (void *)-1 ? -1 : 0,
 47243:                 "mapping contents of", filename);
 47243: 
 47243:   mach_o::FatReader::Reporter fat_reporter(filename);
 47243:   mach_o::FatReader fat_reader(&fat_reporter);
 47243:   if (!fat_reader.Read(reinterpret_cast<uint8_t *>(mapping),
 47243:                        attributes.st_size)) {
 47243:     exit(1);
 47243:   }
 47243:   printf("filename: %s\n", filename);
 47243:   size_t object_files_size;
 50677:   const struct fat_arch *object_files 
 50677:     = fat_reader.object_files(&object_files_size);
 47243:   printf("  object file count: %ld\n", object_files_size);
 47243:   for (size_t i = 0; i < object_files_size; i++) {
 47243:     const struct fat_arch &file = object_files[i];
118328:     const NXArchInfo *fat_arch_info =
118328:         google_breakpad::BreakpadGetArchInfoFromCpuType(
118328:             file.cputype, file.cpusubtype);
 47243:     printf("\n  object file %ld:\n"
 47243:            "    fat header:\n:"
 47243:            "      CPU type: %s (%s)\n"
 47243:            "      size: %d B\n"
 47243:            "      alignment: 1<<%d B\n",
 47243:            i, fat_arch_info->name, fat_arch_info->description,
 47243:            file.size, file.align);
 47243: 
 47243:     ostringstream name;
 47243:     name << filename;
 47243:     if (object_files_size > 1)
 47243:       name << ", object file #" << i;
 47243:     ByteBuffer file_contents(reinterpret_cast<uint8_t *>(mapping)
 47243:                              + file.offset, file.size);
 47243:     mach_o::Reader::Reporter reporter(name.str());
 47243:     mach_o::Reader reader(&reporter);
 47243:     if (!reader.Read(file_contents, file.cputype, file.cpusubtype)) {
 47243:       exit(1);
 47243:     }
 47243: 
 47243:     const NXArchInfo *macho_arch_info =
 47243:       NXGetArchInfoFromCpuType(reader.cpu_type(),
 47243:                                reader.cpu_subtype());
 47243:     printf("    Mach-O header:\n"
 47243:            "      word size: %s\n" 
 47243:            "      CPU type: %s (%s)\n"
 47243:            "      File type: %d\n"
 47243:            "      flags: %x\n",
 47243:            (reader.bits_64() ? "64 bits" : "32 bits"),
 47243:            macho_arch_info->name, macho_arch_info->description,
 47243:            reader.file_type(), reader.flags());
 47243: 
 47243:     DumpCommand dump_command(&reader);
 47243:     reader.WalkLoadCommands(&dump_command);
 47243:   }
 47243:   munmap(mapping, attributes.st_size);
 47243: }
 47243: 
 47243: }  // namespace
 47243: 
 47243: int main(int argc, char **argv) {
 47243:   program_name = basename(argv[0]);
 47243:   if (argc == 1) {
 47243:     fprintf(stderr, "Usage: %s FILE ...\n"
 47243:             "Dump the contents of the Mach-O or fat binary files "
 47243:             "'FILE ...'.\n", program_name.c_str());
 47243:   }
 47243:   for (int i = 1; i < argc; i++) {
 47243:     DumpFile(argv[i]);
 47243:   }
 47243: }
