     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
     1: /* vim: set ts=4 sw=4 et tw=78: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: #include "nsCOMPtr.h"
     1: #include "nsAutoPtr.h"
     1: #include "jsapi.h"
118497: #include "jswrapper.h"
     1: #include "nsCRT.h"
108290: #include "nsError.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsJSProtocolHandler.h"
     1: #include "nsStringStream.h"
     1: #include "nsNetUtil.h"
     1: 
     1: #include "nsIComponentManager.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIURI.h"
     1: #include "nsIScriptContext.h"
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsIScriptGlobalObjectOwner.h"
     1: #include "nsIPrincipal.h"
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsIInterfaceRequestor.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsIWindowMediator.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIConsoleService.h"
     1: #include "nsXPIDLString.h"
     1: #include "prprf.h"
     1: #include "nsEscape.h"
     1: #include "nsIWebNavigation.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIContentViewer.h"
     1: #include "nsIXPConnect.h"
     1: #include "nsContentUtils.h"
     1: #include "nsJSUtils.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsIJSContextStack.h"
     1: #include "nsIScriptChannel.h"
  3052: #include "nsIDocument.h"
 21811: #include "nsIObjectInputStream.h"
 21811: #include "nsIObjectOutputStream.h"
 21811: #include "nsIWritablePropertyBag2.h"
 38438: #include "nsIContentSecurityPolicy.h"
108822: #include "nsSandboxFlags.h"
 21811: 
 21811: static NS_DEFINE_CID(kJSURICID, NS_JSURI_CID);
     1: 
     1: class nsJSThunk : public nsIInputStream
     1: {
     1: public:
     1:     nsJSThunk();
     1: 
     1:     NS_DECL_ISUPPORTS
     1:     NS_FORWARD_SAFE_NSIINPUTSTREAM(mInnerStream)
     1: 
     1:     nsresult Init(nsIURI* uri);
     1:     nsresult EvaluateScript(nsIChannel *aChannel,
     1:                             PopupControlState aPopupState,
108991:                             uint32_t aExecutionPolicy,
  2225:                             nsPIDOMWindow *aOriginalInnerWindow);
     1: 
     1: protected:
     1:     virtual ~nsJSThunk();
     1: 
     1:     nsCOMPtr<nsIInputStream>    mInnerStream;
 23304:     nsCString                   mScript;
 23304:     nsCString                   mURL;
     1: };
     1: 
     1: //
     1: // nsISupports implementation...
     1: //
     1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsJSThunk, nsIInputStream)
     1: 
     1: 
     1: nsJSThunk::nsJSThunk()
     1: {
     1: }
     1: 
     1: nsJSThunk::~nsJSThunk()
     1: {
     1: }
     1: 
     1: nsresult nsJSThunk::Init(nsIURI* uri)
     1: {
     1:     NS_ENSURE_ARG_POINTER(uri);
     1: 
 23304:     // Get the script string to evaluate...
 23304:     nsresult rv = uri->GetPath(mScript);
 23304:     if (NS_FAILED(rv)) return rv;
 23304: 
 23304:     // Get the url.
 23304:     rv = uri->GetSpec(mURL);
 23304:     if (NS_FAILED(rv)) return rv;
 23304: 
     1:     return NS_OK;
     1: }
     1: 
 79445: static bool
     1: IsISO88591(const nsString& aString)
     1: {
     1:     for (nsString::const_char_iterator c = aString.BeginReading(),
     1:                                    c_end = aString.EndReading();
     1:          c < c_end; ++c) {
     1:         if (*c > 255)
 80486:             return false;
     1:     }
 80486:     return true;
     1: }
     1: 
     1: static
     1: nsIScriptGlobalObject* GetGlobalObject(nsIChannel* aChannel)
     1: {
     1:     // Get the global object owner from the channel
     1:     nsCOMPtr<nsIScriptGlobalObjectOwner> globalOwner;
     1:     NS_QueryNotificationCallbacks(aChannel, globalOwner);
 20090:     if (!globalOwner) {
 20090:         NS_WARNING("Unable to get an nsIScriptGlobalObjectOwner from the "
     1:                    "channel!");
 20090:     }
     1:     if (!globalOwner) {
106838:         return nullptr;
     1:     }
     1: 
     1:     // So far so good: get the script context from its owner.
     1:     nsIScriptGlobalObject* global = globalOwner->GetScriptGlobalObject();
     1: 
     1:     NS_ASSERTION(global,
     1:                  "Unable to get an nsIScriptGlobalObject from the "
     1:                  "ScriptGlobalObjectOwner!");
     1:     return global;
     1: }
     1: 
     1: nsresult nsJSThunk::EvaluateScript(nsIChannel *aChannel,
     1:                                    PopupControlState aPopupState,
108991:                                    uint32_t aExecutionPolicy,
  2225:                                    nsPIDOMWindow *aOriginalInnerWindow)
     1: {
     1:     if (aExecutionPolicy == nsIScriptChannel::NO_EXECUTION) {
     1:         // Nothing to do here.
     1:         return NS_ERROR_DOM_RETVAL_UNDEFINED;
     1:     }
     1:     
     1:     NS_ENSURE_ARG_POINTER(aChannel);
     1: 
     1:     // Get principal of code for execution
     1:     nsCOMPtr<nsISupports> owner;
     1:     aChannel->GetOwner(getter_AddRefs(owner));
     1:     nsCOMPtr<nsIPrincipal> principal = do_QueryInterface(owner);
     1:     if (!principal) {
     1:         // No execution without a principal!
     1:         NS_ASSERTION(!owner, "Non-principal owner?");
     1:         NS_WARNING("No principal to execute JS with");
     1:         return NS_ERROR_DOM_RETVAL_UNDEFINED;
     1:     }
     1: 
 38438:     nsresult rv;
 38438: 
 38438:     // CSP check: javascript: URIs disabled unless "inline" scripts are
 38438:     // allowed.
 38438:     nsCOMPtr<nsIContentSecurityPolicy> csp;
 38438:     rv = principal->GetCsp(getter_AddRefs(csp));
 38438:     NS_ENSURE_SUCCESS(rv, rv);
 38438:     if (csp) {
 79445: 		bool allowsInline;
 38438: 		rv = csp->GetAllowsInlineScript(&allowsInline);
 38438: 		NS_ENSURE_SUCCESS(rv, rv);
 38438: 
 61654:       if (!allowsInline) {
 61654:           // gather information to log with violation report
 61654:           nsCOMPtr<nsIURI> uri;
 61654:           principal->GetURI(getter_AddRefs(uri));
110974:           nsAutoCString asciiSpec;
 61654:           uri->GetAsciiSpec(asciiSpec);
 61654: 		  csp->LogViolationDetails(nsIContentSecurityPolicy::VIOLATION_TYPE_INLINE_SCRIPT,
 61654: 								   NS_ConvertUTF8toUTF16(asciiSpec),
 61654: 								   NS_ConvertUTF8toUTF16(mURL),
106118:                                    0);
 38438:           return NS_ERROR_DOM_RETVAL_UNDEFINED;
 38438:       }
 61654:     }
     1: 
     1:     // Get the global object we should be running on.
     1:     nsIScriptGlobalObject* global = GetGlobalObject(aChannel);
     1:     if (!global) {
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(global));
     1: 
108822:     // Sandboxed document check: javascript: URI's are disabled
108822:     // in a sandboxed document unless 'allow-scripts' was specified.
108822:     nsIDocument* doc = aOriginalInnerWindow->GetExtantDoc();
108822:     if (doc && (doc->GetSandboxFlags() & SANDBOXED_SCRIPTS)) {
108822:         return NS_ERROR_DOM_RETVAL_UNDEFINED;
108822:     }
108822: 
     1:     // Push our popup control state
     1:     nsAutoPopupStatePusher popupStatePusher(win, aPopupState);
     1: 
  2225:     // Make sure we still have the same inner window as we used to.
  2225:     nsPIDOMWindow *innerWin = win->GetCurrentInnerWindow();
     1: 
  2225:     if (innerWin != aOriginalInnerWindow) {
     1:         return NS_ERROR_UNEXPECTED;
     1:     }
     1: 
     1:     nsCOMPtr<nsIScriptGlobalObject> innerGlobal = do_QueryInterface(innerWin);
     1: 
     1:     JSObject *globalJSObject = innerGlobal->GetGlobalJSObject();
     1: 
     1:     nsCOMPtr<nsIDOMWindow> domWindow(do_QueryInterface(global, &rv));
     1:     if (NS_FAILED(rv)) {
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     // So far so good: get the script context from its owner.
     1:     nsCOMPtr<nsIScriptContext> scriptContext = global->GetContext();
     1:     if (!scriptContext)
     1:         return NS_ERROR_FAILURE;
     1: 
110974:     nsAutoCString script(mScript);
     1:     // Unescape the script
     1:     NS_UnescapeURL(script);
     1: 
     1: 
     1:     nsCOMPtr<nsIScriptSecurityManager> securityManager;
     1:     securityManager = do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
 79445:     bool useSandbox =
     1:         (aExecutionPolicy == nsIScriptChannel::EXECUTE_IN_SANDBOX);
     1: 
     1:     if (!useSandbox) {
     1:         //-- Don't outside a sandbox unless the script principal subsumes the
     1:         //   principal of the context.
     1:         nsCOMPtr<nsIPrincipal> objectPrincipal;
     1:         rv = securityManager->
 78415:             GetObjectPrincipal(scriptContext->GetNativeContext(),
     1:                                globalJSObject,
     1:                                getter_AddRefs(objectPrincipal));
     1:         if (NS_FAILED(rv))
     1:             return rv;
     1: 
 79445:         bool subsumes;
     1:         rv = principal->Subsumes(objectPrincipal, &subsumes);
     1:         if (NS_FAILED(rv))
     1:             return rv;
     1: 
     1:         useSandbox = !subsumes;
     1:     }
     1: 
     1:     nsString result;
 79445:     bool isUndefined;
     1: 
     1:     // Finally, we have everything needed to evaluate the expression.
     1: 
     1:     if (useSandbox) {
     1:         // We were asked to use a sandbox, or the channel owner isn't allowed
     1:         // to execute in this context.  Evaluate the javascript URL in a
     1:         // sandbox to prevent it from accessing data it doesn't have
     1:         // permissions to access.
     1: 
     1:         // First check to make sure it's OK to evaluate this script to
     1:         // start with.  For example, script could be disabled.
 78415:         JSContext *cx = scriptContext->GetNativeContext();
  6082:         JSAutoRequest ar(cx);
     1: 
 79445:         bool ok;
     1:         rv = securityManager->CanExecuteScripts(cx, principal, &ok);
     1:         if (NS_FAILED(rv)) {
     1:             return rv;
     1:         }
     1: 
     1:         if (!ok) {
     1:             // Treat this as returning undefined from the script.  That's what
     1:             // nsJSContext does.
     1:             return NS_ERROR_DOM_RETVAL_UNDEFINED;
     1:         }
     1: 
     1:         nsIXPConnect *xpc = nsContentUtils::XPConnect();
     1: 
     1:         nsCOMPtr<nsIXPConnectJSObjectHolder> sandbox;
     1:         rv = xpc->CreateSandbox(cx, principal, getter_AddRefs(sandbox));
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1: 
118497:         // The nsXPConnect sandbox API gives us a wrapper to the sandbox for
118497:         // our current compartment. Because our current context doesn't necessarily
118497:         // subsume that of the sandbox, we want to unwrap and enter the sandbox's
118497:         // compartment. It's a shame that the APIs here are so clunkly. :-(
118497:         JSObject *sandboxObj;
118497:         rv = sandbox->GetJSObject(&sandboxObj);
118497:         NS_ENSURE_SUCCESS(rv, rv);
118497:         sandboxObj = js::UnwrapObject(sandboxObj);
118497:         JSAutoCompartment ac(cx, sandboxObj);
118497:         rv = xpc->HoldObject(cx, sandboxObj, getter_AddRefs(sandbox));
118497:         NS_ENSURE_SUCCESS(rv, rv);
118497: 
     1:         jsval rval = JSVAL_VOID;
     1: 
     1:         // Push our JSContext on the context stack so the JS_ValueToString call (and
     1:         // JS_ReportPendingException, if relevant) will use the principal of cx.
     1:         // Note that we do this as late as possible to make popping simpler.
     1:         nsCOMPtr<nsIJSContextStack> stack =
     1:             do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
     1:         if (NS_SUCCEEDED(rv)) {
     1:             rv = stack->Push(cx);
     1:         }
     1:         if (NS_FAILED(rv)) {
     1:             return rv;
     1:         }
     1: 
     1:         rv = xpc->EvalInSandboxObject(NS_ConvertUTF8toUTF16(script), cx,
 80486:                                       sandbox, true, &rval);
     1: 
     1:         // Propagate and report exceptions that happened in the
     1:         // sandbox.
     1:         if (JS_IsExceptionPending(cx)) {
     1:             JS_ReportPendingException(cx);
 80486:             isUndefined = true;
  3573:         } else {
  3573:             isUndefined = rval == JSVAL_VOID;
     1:         }
     1: 
     1:         if (!isUndefined && NS_SUCCEEDED(rv)) {
  3573:             NS_ASSERTION(JSVAL_IS_STRING(rval), "evalInSandbox is broken");
 59889: 
 59889:             nsDependentJSString depStr;
 59889:             if (!depStr.init(cx, JSVAL_TO_STRING(rval))) {
 59889:                 JS_ReportPendingException(cx);
 80486:                 isUndefined = true;
 59889:             } else {
 59889:                 result = depStr;
 59889:             }
     1:         }
     1: 
106838:         stack->Pop(nullptr);
     1:     } else {
     1:         // No need to use the sandbox, evaluate the script directly in
     1:         // the given scope.
     1:         rv = scriptContext->EvaluateString(NS_ConvertUTF8toUTF16(script),
     1:                                            globalJSObject, // obj
     1:                                            principal,
 85979:                                            principal,
 23304:                                            mURL.get(),     // url
     1:                                            1,              // line no
 94362:                                            JSVERSION_DEFAULT,
     1:                                            &result,
     1:                                            &isUndefined);
     1: 
     1:         // If there's an error on cx as a result of that call, report
     1:         // it now -- either we're just running under the event loop,
     1:         // so we shouldn't propagate JS exceptions out of here, or we
     1:         // can't be sure that our caller is JS (and if it's not we'll
     1:         // lose the error), or it might be JS that then proceeds to
     1:         // cause an error of its own (which will also make us lose
     1:         // this error).
 78415:         JSContext *cx = scriptContext->GetNativeContext();
  6082:         JSAutoRequest ar(cx);
  6082:         ::JS_ReportPendingException(cx);
     1:     }
     1:     
     1:     if (NS_FAILED(rv)) {
     1:         rv = NS_ERROR_MALFORMED_URI;
     1:     }
     1:     else if (isUndefined) {
     1:         rv = NS_ERROR_DOM_RETVAL_UNDEFINED;
     1:     }
     1:     else {
     1:         char *bytes;
108991:         uint32_t bytesLen;
     1:         NS_NAMED_LITERAL_CSTRING(isoCharset, "ISO-8859-1");
     1:         NS_NAMED_LITERAL_CSTRING(utf8Charset, "UTF-8");
     1:         const nsCString *charset;
     1:         if (IsISO88591(result)) {
     1:             // For compatibility, if the result is ISO-8859-1, we use
     1:             // ISO-8859-1, so that people can compatibly create images
     1:             // using javascript: URLs.
     1:             bytes = ToNewCString(result);
     1:             bytesLen = result.Length();
     1:             charset = &isoCharset;
     1:         }
     1:         else {
     1:             bytes = ToNewUTF8String(result, &bytesLen);
     1:             charset = &utf8Charset;
     1:         }
     1:         aChannel->SetContentCharset(*charset);
     1:         if (bytes)
     1:             rv = NS_NewByteInputStream(getter_AddRefs(mInnerStream),
     1:                                        bytes, bytesLen,
     1:                                        NS_ASSIGNMENT_ADOPT);
     1:         else
     1:             rv = NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: ////////////////////////////////////////////////////////////////////////////////
     1: 
     1: class nsJSChannel : public nsIChannel,
     1:                     public nsIStreamListener,
 21811:                     public nsIScriptChannel,
 21811:                     public nsIPropertyBag2
     1: {
     1: public:
     1:     nsJSChannel();
     1: 
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIREQUEST
     1:     NS_DECL_NSICHANNEL
     1:     NS_DECL_NSIREQUESTOBSERVER
     1:     NS_DECL_NSISTREAMLISTENER
     1:     NS_DECL_NSISCRIPTCHANNEL
 21811:     NS_FORWARD_SAFE_NSIPROPERTYBAG(mPropertyBag)
 21811:     NS_FORWARD_SAFE_NSIPROPERTYBAG2(mPropertyBag)
     1: 
     1:     nsresult Init(nsIURI *aURI);
     1: 
     1:     // Actually evaluate the script.
     1:     void EvaluateScript();
     1:     
     1: protected:
     1:     virtual ~nsJSChannel();
     1: 
     1:     nsresult StopAll();
     1: 
     1:     void NotifyListener();
     1: 
  3052:     void CleanupStrongRefs();
  3052:     
     1: protected:
     1:     nsCOMPtr<nsIChannel>    mStreamChannel;
 21811:     nsCOMPtr<nsIPropertyBag2> mPropertyBag;
     1:     nsCOMPtr<nsIStreamListener> mListener;  // Our final listener
     1:     nsCOMPtr<nsISupports> mContext; // The context passed to AsyncOpen
  2225:     nsCOMPtr<nsPIDOMWindow> mOriginalInnerWindow;  // The inner window our load
  2225:                                                    // started against.
  3052:     // If we blocked onload on a document in AsyncOpen, this is the document we
  3052:     // did it on.
  3052:     nsCOMPtr<nsIDocument>   mDocumentOnloadBlockedOn;
  3052: 
     1:     nsresult mStatus; // Our status
     1: 
     1:     nsLoadFlags             mLoadFlags;
     1:     nsLoadFlags             mActualLoadFlags; // See AsyncOpen
     1: 
     1:     nsRefPtr<nsJSThunk>     mIOThunk;
     1:     PopupControlState       mPopupState;
108991:     uint32_t                mExecutionPolicy;
 79445:     bool                    mIsAsync;
 79445:     bool                    mIsActive;
 79445:     bool                    mOpenedStreamChannel;
     1: };
     1: 
     1: nsJSChannel::nsJSChannel() :
     1:     mStatus(NS_OK),
     1:     mLoadFlags(LOAD_NORMAL),
     1:     mActualLoadFlags(LOAD_NORMAL),
     1:     mPopupState(openOverridden),
   376:     mExecutionPolicy(EXECUTE_IN_SANDBOX),
 80486:     mIsAsync(true),
 80486:     mIsActive(false),
 80486:     mOpenedStreamChannel(false)
     1: {
     1: }
     1: 
     1: nsJSChannel::~nsJSChannel()
     1: {
     1: }
     1: 
     1: nsresult nsJSChannel::StopAll()
     1: {
     1:     nsresult rv = NS_ERROR_UNEXPECTED;
     1:     nsCOMPtr<nsIWebNavigation> webNav;
     1:     NS_QueryNotificationCallbacks(mStreamChannel, webNav);
     1: 
     1:     NS_ASSERTION(webNav, "Can't get nsIWebNavigation from channel!");
     1:     if (webNav) {
     1:         rv = webNav->Stop(nsIWebNavigation::STOP_ALL);
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: nsresult nsJSChannel::Init(nsIURI *aURI)
     1: {
 21811:     nsRefPtr<nsJSURI> jsURI;
 21811:     nsresult rv = aURI->QueryInterface(kJSURICID,
 21811:                                        getter_AddRefs(jsURI));
 21811:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Create the nsIStreamIO layer used by the nsIStreamIOChannel.
     1:     mIOThunk = new nsJSThunk();
     1:     if (!mIOThunk)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     // Create a stock input stream channel...
     1:     // Remember, until AsyncOpen is called, the script will not be evaluated
     1:     // and the underlying Input Stream will not be created...
     1:     nsCOMPtr<nsIChannel> channel;
     1: 
     1:     // If the resultant script evaluation actually does return a value, we
     1:     // treat it as html.
     1:     rv = NS_NewInputStreamChannel(getter_AddRefs(channel), aURI, mIOThunk,
     1:                                   NS_LITERAL_CSTRING("text/html"));
     1:     if (NS_FAILED(rv)) return rv;
     1: 
     1:     rv = mIOThunk->Init(aURI);
     1:     if (NS_SUCCEEDED(rv)) {
     1:         mStreamChannel = channel;
 21811:         mPropertyBag = do_QueryInterface(channel);
 21811:         nsCOMPtr<nsIWritablePropertyBag2> writableBag =
 21811:             do_QueryInterface(channel);
 21811:         if (writableBag && jsURI->GetBaseURI()) {
 21811:             writableBag->SetPropertyAsInterface(NS_LITERAL_STRING("baseURI"),
 21811:                                                 jsURI->GetBaseURI());
 21811:         }
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: //
     1: // nsISupports implementation...
     1: //
     1: 
 21811: NS_IMPL_ISUPPORTS7(nsJSChannel, nsIChannel, nsIRequest, nsIRequestObserver,
 21811:                    nsIStreamListener, nsIScriptChannel, nsIPropertyBag,
 21811:                    nsIPropertyBag2)
     1: 
     1: //
     1: // nsIRequest implementation...
     1: //
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::GetName(nsACString &aResult)
     1: {
     1:     return mStreamChannel->GetName(aResult);
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsJSChannel::IsPending(bool *aResult)
     1: {
     1:     *aResult = mIsActive;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::GetStatus(nsresult *aResult)
     1: {
  3861:     if (NS_SUCCEEDED(mStatus) && mOpenedStreamChannel) {
  3861:         return mStreamChannel->GetStatus(aResult);
  3861:     }
  3861:     
     1:     *aResult = mStatus;
  3861:         
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::Cancel(nsresult aStatus)
     1: {
     1:     mStatus = aStatus;
     1: 
     1:     if (mOpenedStreamChannel) {
     1:         mStreamChannel->Cancel(aStatus);
     1:     }
     1:     
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::Suspend()
     1: {
     1:     return mStreamChannel->Suspend();
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::Resume()
     1: {
     1:     return mStreamChannel->Resume();
     1: }
     1: 
     1: //
     1: // nsIChannel implementation
     1: //
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::GetOriginalURI(nsIURI * *aURI)
     1: {
     1:     return mStreamChannel->GetOriginalURI(aURI);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::SetOriginalURI(nsIURI *aURI)
     1: {
     1:     return mStreamChannel->SetOriginalURI(aURI);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::GetURI(nsIURI * *aURI)
     1: {
     1:     return mStreamChannel->GetURI(aURI);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::Open(nsIInputStream **aResult)
     1: {
     1:     nsresult rv = mIOThunk->EvaluateScript(mStreamChannel, mPopupState,
  2225:                                            mExecutionPolicy,
  2225:                                            mOriginalInnerWindow);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     return mStreamChannel->Open(aResult);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::AsyncOpen(nsIStreamListener *aListener, nsISupports *aContext)
     1: {
     1:     NS_ENSURE_ARG(aListener);
 18432: 
  2225:     // First make sure that we have a usable inner window; we'll want to make
  2225:     // sure that we execute against that inner and no other.
  2225:     nsIScriptGlobalObject* global = GetGlobalObject(this);
  2225:     if (!global) {
  2225:         return NS_ERROR_NOT_AVAILABLE;
  2225:     }
 18432: 
  2225:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(global));
  2225:     NS_ASSERTION(win, "Our global is not a window??");
  2225: 
  2225:     // Make sure we create a new inner window if one doesn't already exist (see
  2225:     // bug 306630).
  2225:     mOriginalInnerWindow = win->EnsureInnerWindow();
  2225:     if (!mOriginalInnerWindow) {
  2225:         return NS_ERROR_NOT_AVAILABLE;
  2225:     }
  2225:     
     1:     mListener = aListener;
     1:     mContext = aContext;
     1: 
 80486:     mIsActive = true;
     1: 
     1:     // Temporarily set the LOAD_BACKGROUND flag to suppress load group observer
     1:     // notifications (and hence nsIWebProgressListener notifications) from
     1:     // being dispatched.  This is required since we suppress LOAD_DOCUMENT_URI,
     1:     // which means that the DocLoader would not generate document start and
     1:     // stop notifications (see bug 257875).
     1:     mActualLoadFlags = mLoadFlags;
     1:     mLoadFlags |= LOAD_BACKGROUND;
     1: 
     1:     // Add the javascript channel to its loadgroup so that we know if
     1:     // network loads were canceled or not...
     1:     nsCOMPtr<nsILoadGroup> loadGroup;
     1:     mStreamChannel->GetLoadGroup(getter_AddRefs(loadGroup));
     1:     if (loadGroup) {
106838:         nsresult rv = loadGroup->AddRequest(this, nullptr);
  3861:         if (NS_FAILED(rv)) {
 80486:             mIsActive = false;
  3861:             CleanupStrongRefs();
  3861:             return rv;
  3861:         }
     1:     }
     1: 
  3052:     mDocumentOnloadBlockedOn =
  3052:         do_QueryInterface(mOriginalInnerWindow->GetExtantDocument());
  3052:     if (mDocumentOnloadBlockedOn) {
  3052:         // If we're a document channel, we need to actually block onload on our
  3052:         // _parent_ document.  This is because we don't actually set our
  3092:         // LOAD_DOCUMENT_URI flag, so a docloader we're loading in as the
  3052:         // document channel will claim to not be busy, and our parent's onload
  3052:         // could fire too early.
  3052:         nsLoadFlags loadFlags;
  3052:         mStreamChannel->GetLoadFlags(&loadFlags);
  3052:         if (loadFlags & LOAD_DOCUMENT_URI) {
  3052:             mDocumentOnloadBlockedOn =
  3052:                 mDocumentOnloadBlockedOn->GetParentDocument();
  3052:         }
  3052:     }
  3052:     if (mDocumentOnloadBlockedOn) {
  3052:         mDocumentOnloadBlockedOn->BlockOnload();
  3052:     }
  3052: 
  3052: 
  2364:     mPopupState = win->GetPopupControlState();
  2364: 
 41361:     void (nsJSChannel::*method)();
  2364:     if (mIsAsync) {
     1:         // post an event to do the rest
  2364:         method = &nsJSChannel::EvaluateScript;
  2364:     } else {   
  2364:         EvaluateScript();
  2364:         if (mOpenedStreamChannel) {
  2364:             // That will handle notifying things
  2364:             return NS_OK;
  2364:         }
  2364: 
  2364:         NS_ASSERTION(NS_FAILED(mStatus), "We should have failed _somehow_");
  2364: 
  2364:         // mStatus is going to be NS_ERROR_DOM_RETVAL_UNDEFINED if we didn't
  2364:         // have any content resulting from the execution and NS_BINDING_ABORTED
  2364:         // if something we did causes our own load to be stopped.  Return
  2364:         // success in those cases, and error out in all others.
  2364:         if (mStatus != NS_ERROR_DOM_RETVAL_UNDEFINED &&
  2364:             mStatus != NS_BINDING_ABORTED) {
  2364:             // Note that calling EvaluateScript() handled removing us from the
  2364:             // loadgroup and marking us as not active anymore.
  3052:             CleanupStrongRefs();
  2364:             return mStatus;
  2364:         }
  2364: 
  2364:         // We're returning success from asyncOpen(), but we didn't open a
  2364:         // stream channel.  We'll have to notify ourselves, but make sure to do
  2364:         // it asynchronously.
  2364:         method = &nsJSChannel::NotifyListener;            
  2364:     }
  2364: 
 41361:     nsCOMPtr<nsIRunnable> ev = NS_NewRunnableMethod(this, method);
     1:     nsresult rv = NS_DispatchToCurrentThread(ev);
     1: 
     1:     if (NS_FAILED(rv)) {
106838:         loadGroup->RemoveRequest(this, nullptr, rv);
 80486:         mIsActive = false;
  3052:         CleanupStrongRefs();
     1:     }
     1:     return rv;
     1: }
     1: 
     1: void
     1: nsJSChannel::EvaluateScript()
     1: {
     1:     // Synchronously execute the script...
     1:     // mIsActive is used to indicate the the request is 'busy' during the
     1:     // the script evaluation phase.  This means that IsPending() will 
     1:     // indicate the the request is busy while the script is executing...
     1: 
     1:     // Note that we want to be in the loadgroup and pending while we evaluate
     1:     // the script, so that we find out if the loadgroup gets canceled by the
     1:     // script execution (in which case we shouldn't pump out data even if the
     1:     // script returns it).
     1:     
     1:     if (NS_SUCCEEDED(mStatus)) {
     1:         nsresult rv = mIOThunk->EvaluateScript(mStreamChannel, mPopupState,
  2225:                                                mExecutionPolicy,
  2225:                                                mOriginalInnerWindow);
     1: 
     1:         // Note that evaluation may have canceled us, so recheck mStatus again
     1:         if (NS_FAILED(rv) && NS_SUCCEEDED(mStatus)) {
     1:             mStatus = rv;
     1:         }
     1:     }
     1:     
     1:     // Remove the javascript channel from its loadgroup...
     1:     nsCOMPtr<nsILoadGroup> loadGroup;
     1:     mStreamChannel->GetLoadGroup(getter_AddRefs(loadGroup));
     1:     if (loadGroup) {
106838:         loadGroup->RemoveRequest(this, nullptr, mStatus);
     1:     }
     1: 
     1:     // Reset load flags to their original value...
     1:     mLoadFlags = mActualLoadFlags;
     1: 
     1:     // We're no longer active, it's now up to the stream channel to do
     1:     // the loading, if needed.
 80486:     mIsActive = false;
     1: 
     1:     if (NS_FAILED(mStatus)) {
  2364:         if (mIsAsync) {
     1:             NotifyListener();
  2364:         }
     1:         return;
     1:     }
     1:     
     1:     // EvaluateScript() succeeded, and we were not canceled, that
     1:     // means there's data to parse as a result of evaluating the
     1:     // script.
     1: 
     1:     // Get the stream channels load flags (!= mLoadFlags).
     1:     nsLoadFlags loadFlags;
     1:     mStreamChannel->GetLoadFlags(&loadFlags);
     1: 
125362:     if (loadFlags & LOAD_DOCUMENT_URI) {
125362:         // We're loaded as the document channel. If we go on,
125362:         // we'll blow away the current document. Make sure that's
125362:         // ok. If so, stop all pending network loads.
     1: 
     1:         nsCOMPtr<nsIDocShell> docShell;
     1:         NS_QueryNotificationCallbacks(mStreamChannel, docShell);
     1:         if (docShell) {
     1:             nsCOMPtr<nsIContentViewer> cv;
     1:             docShell->GetContentViewer(getter_AddRefs(cv));
     1: 
     1:             if (cv) {
 79445:                 bool okToUnload;
     1: 
 80486:                 if (NS_SUCCEEDED(cv->PermitUnload(false, &okToUnload)) &&
     1:                     !okToUnload) {
     1:                     // The user didn't want to unload the current
     1:                     // page, translate this into an undefined
     1:                     // return from the javascript: URL...
     1:                     mStatus = NS_ERROR_DOM_RETVAL_UNDEFINED;
     1:                 }
     1:             }
     1:         }
     1: 
     1:         if (NS_SUCCEEDED(mStatus)) {
     1:             mStatus = StopAll();
     1:         }
     1:     }
     1: 
     1:     if (NS_FAILED(mStatus)) {
  2364:         if (mIsAsync) {
     1:             NotifyListener();
  2364:         }
     1:         return;
     1:     }
     1:     
     1:     mStatus = mStreamChannel->AsyncOpen(this, mContext);
  2364:     if (NS_SUCCEEDED(mStatus)) {
     1:         // mStreamChannel will call OnStartRequest and OnStopRequest on
     1:         // us, so we'll be sure to call them on our listener.
 80486:         mOpenedStreamChannel = true;
  3861: 
  3861:         // Now readd ourselves to the loadgroup so we can receive
  3861:         // cancellation notifications.
 80486:         mIsActive = true;
  3861:         if (loadGroup) {
106838:             mStatus = loadGroup->AddRequest(this, nullptr);
  3861: 
  3861:             // If AddRequest failed, that's OK.  The key is to make sure we get
  3861:             // cancelled if needed, and that call just canceled us if it
  3861:             // failed.  We'll still get notified by the stream channel when it
  3861:             // finishes.
  3861:         }
  3861:         
  2364:     } else if (mIsAsync) {
  2364:         NotifyListener();
     1:     }
     1: 
     1:     return;
     1: }
     1: 
     1: void
     1: nsJSChannel::NotifyListener()
     1: {
  3052:     mListener->OnStartRequest(this, mContext);
  3052:     mListener->OnStopRequest(this, mContext, mStatus);
     1: 
  3052:     CleanupStrongRefs();
  3052: }
     1: 
  3052: void
  3052: nsJSChannel::CleanupStrongRefs()
  3052: {
106838:     mListener = nullptr;
106838:     mContext = nullptr;
106838:     mOriginalInnerWindow = nullptr;
  3052:     if (mDocumentOnloadBlockedOn) {
 80486:         mDocumentOnloadBlockedOn->UnblockOnload(false);
106838:         mDocumentOnloadBlockedOn = nullptr;
  3052:     }
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::GetLoadFlags(nsLoadFlags *aLoadFlags)
     1: {
     1:     *aLoadFlags = mLoadFlags;
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::SetLoadFlags(nsLoadFlags aLoadFlags)
     1: {
 19874:     // Figure out whether the LOAD_BACKGROUND bit in aLoadFlags is
 19874:     // actually right.
 79445:     bool bogusLoadBackground = false;
 19874:     if (mIsActive && !(mActualLoadFlags & LOAD_BACKGROUND) &&
 19874:         (aLoadFlags & LOAD_BACKGROUND)) {
 19874:         // We're getting a LOAD_BACKGROUND, but it's probably just our own fake
 19874:         // flag being mirrored to us.  The one exception is if our loadgroup is
 19874:         // LOAD_BACKGROUND.
 79445:         bool loadGroupIsBackground = false;
 19874:         nsCOMPtr<nsILoadGroup> loadGroup;
 19874:         mStreamChannel->GetLoadGroup(getter_AddRefs(loadGroup));
 19874:         if (loadGroup) {
 19874:             nsLoadFlags loadGroupFlags;
 19874:             loadGroup->GetLoadFlags(&loadGroupFlags);
 19874:             loadGroupIsBackground = ((loadGroupFlags & LOAD_BACKGROUND) != 0);
 19874:         }
 19874:         bogusLoadBackground = !loadGroupIsBackground;
 19874:     }
 19874: 
 59845:     // Classifying a javascript: URI doesn't help us, and requires
 59845:     // NSS to boot, which we don't have in content processes.  See
 59845:     // https://bugzilla.mozilla.org/show_bug.cgi?id=617838.
 59845:     aLoadFlags &= ~LOAD_CLASSIFY_URI;
 59845: 
     1:     // Since the javascript channel is never the actual channel that
     1:     // any data is loaded through, don't ever set the
     1:     // LOAD_DOCUMENT_URI flag on it, since that could lead to two
     1:     // 'document channels' in the loadgroup if a javascript: URL is
     1:     // loaded while a document is being loaded in the same window.
     1: 
     1:     // XXXbz this, and a whole lot of other hackery, could go away if we'd just
     1:     // cancel the current document load on javascript: load start like IE does.
     1:     
     1:     mLoadFlags = aLoadFlags & ~LOAD_DOCUMENT_URI;
     1: 
 19874:     if (bogusLoadBackground) {
 19874:         aLoadFlags = aLoadFlags & ~LOAD_BACKGROUND;
 19874:     }
 19874: 
 19874:     mActualLoadFlags = aLoadFlags;
 19874: 
     1:     // ... but the underlying stream channel should get this bit, if
     1:     // set, since that'll be the real document channel if the
     1:     // javascript: URL generated data.
     1: 
     1:     return mStreamChannel->SetLoadFlags(aLoadFlags);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::GetLoadGroup(nsILoadGroup* *aLoadGroup)
     1: {
     1:     return mStreamChannel->GetLoadGroup(aLoadGroup);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::SetLoadGroup(nsILoadGroup* aLoadGroup)
     1: {
  8608:     if (aLoadGroup) {
 79445:         bool streamPending;
  8608:         nsresult rv = mStreamChannel->IsPending(&streamPending);
  8608:         NS_ENSURE_SUCCESS(rv, rv);
  8608: 
  8608:         if (streamPending) {
  8608:             nsCOMPtr<nsILoadGroup> curLoadGroup;
  8608:             mStreamChannel->GetLoadGroup(getter_AddRefs(curLoadGroup));
  8608: 
  8608:             if (aLoadGroup != curLoadGroup) {
  8608:                 // Move the stream channel to our new loadgroup.  Make sure to
  8608:                 // add it before removing it, so that we don't trigger onload
  8608:                 // by accident.
106838:                 aLoadGroup->AddRequest(mStreamChannel, nullptr);
  8608:                 if (curLoadGroup) {
106838:                     curLoadGroup->RemoveRequest(mStreamChannel, nullptr,
  8608:                                                 NS_BINDING_RETARGETED);
  8608:                 }
  8608:             }
  8608:         }
  8608:     }
  8608:     
     1:     return mStreamChannel->SetLoadGroup(aLoadGroup);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::GetOwner(nsISupports* *aOwner)
     1: {
     1:     return mStreamChannel->GetOwner(aOwner);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::SetOwner(nsISupports* aOwner)
     1: {
     1:     return mStreamChannel->SetOwner(aOwner);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::GetNotificationCallbacks(nsIInterfaceRequestor* *aCallbacks)
     1: {
     1:     return mStreamChannel->GetNotificationCallbacks(aCallbacks);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::SetNotificationCallbacks(nsIInterfaceRequestor* aCallbacks)
     1: {
     1:     return mStreamChannel->SetNotificationCallbacks(aCallbacks);
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsJSChannel::GetSecurityInfo(nsISupports * *aSecurityInfo)
     1: {
     1:     return mStreamChannel->GetSecurityInfo(aSecurityInfo);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::GetContentType(nsACString &aContentType)
     1: {
     1:     return mStreamChannel->GetContentType(aContentType);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::SetContentType(const nsACString &aContentType)
     1: {
     1:     return mStreamChannel->SetContentType(aContentType);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::GetContentCharset(nsACString &aContentCharset)
     1: {
     1:     return mStreamChannel->GetContentCharset(aContentCharset);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::SetContentCharset(const nsACString &aContentCharset)
     1: {
     1:     return mStreamChannel->SetContentCharset(aContentCharset);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsJSChannel::GetContentDisposition(uint32_t *aContentDisposition)
 78165: {
 78165:     return mStreamChannel->GetContentDisposition(aContentDisposition);
 78165: }
 78165: 
 78165: NS_IMETHODIMP
115839: nsJSChannel::SetContentDisposition(uint32_t aContentDisposition)
115839: {
115839:     return mStreamChannel->SetContentDisposition(aContentDisposition);
115839: }
115839: 
115839: NS_IMETHODIMP
 78165: nsJSChannel::GetContentDispositionFilename(nsAString &aContentDispositionFilename)
 78165: {
 78165:     return mStreamChannel->GetContentDispositionFilename(aContentDispositionFilename);
 78165: }
 78165: 
 78165: NS_IMETHODIMP
115839: nsJSChannel::SetContentDispositionFilename(const nsAString &aContentDispositionFilename)
115839: {
115839:     return mStreamChannel->SetContentDispositionFilename(aContentDispositionFilename);
115839: }
115839: 
115839: NS_IMETHODIMP
 78165: nsJSChannel::GetContentDispositionHeader(nsACString &aContentDispositionHeader)
 78165: {
 78165:     return mStreamChannel->GetContentDispositionHeader(aContentDispositionHeader);
 78165: }
 78165: 
 78165: NS_IMETHODIMP
119703: nsJSChannel::GetContentLength(int64_t *aContentLength)
     1: {
     1:     return mStreamChannel->GetContentLength(aContentLength);
     1: }
     1: 
     1: NS_IMETHODIMP
119703: nsJSChannel::SetContentLength(int64_t aContentLength)
     1: {
     1:     return mStreamChannel->SetContentLength(aContentLength);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::OnStartRequest(nsIRequest* aRequest,
     1:                             nsISupports* aContext)
     1: {
     1:     NS_ENSURE_TRUE(aRequest == mStreamChannel, NS_ERROR_UNEXPECTED);
     1: 
     1:     return mListener->OnStartRequest(this, aContext);    
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::OnDataAvailable(nsIRequest* aRequest,
     1:                              nsISupports* aContext, 
     1:                              nsIInputStream* aInputStream,
111234:                              uint64_t aOffset,
108991:                              uint32_t aCount)
     1: {
     1:     NS_ENSURE_TRUE(aRequest == mStreamChannel, NS_ERROR_UNEXPECTED);
     1: 
     1:     return mListener->OnDataAvailable(this, aContext, aInputStream, aOffset,
     1:                                       aCount);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSChannel::OnStopRequest(nsIRequest* aRequest,
     1:                            nsISupports* aContext,
     1:                            nsresult aStatus)
     1: {
     1:     NS_ENSURE_TRUE(aRequest == mStreamChannel, NS_ERROR_UNEXPECTED);
     1: 
  3052:     nsCOMPtr<nsIStreamListener> listener = mListener;
     1: 
  3052:     CleanupStrongRefs();
     1: 
  3861:     // Make sure aStatus matches what GetStatus() returns
  3861:     if (NS_FAILED(mStatus)) {
  3861:         aStatus = mStatus;
  3861:     }
  3861:     
  3861:     nsresult rv = listener->OnStopRequest(this, aContext, aStatus);
  3861: 
  3861:     nsCOMPtr<nsILoadGroup> loadGroup;
  3861:     mStreamChannel->GetLoadGroup(getter_AddRefs(loadGroup));
  3861:     if (loadGroup) {
106838:         loadGroup->RemoveRequest(this, nullptr, mStatus);
  3861:     }
  3861: 
 80486:     mIsActive = false;
  3861: 
  3861:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsJSChannel::SetExecutionPolicy(uint32_t aPolicy)
     1: {
     1:     NS_ENSURE_ARG(aPolicy <= EXECUTE_NORMAL);
     1:     
     1:     mExecutionPolicy = aPolicy;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsJSChannel::GetExecutionPolicy(uint32_t* aPolicy)
     1: {
     1:     *aPolicy = mExecutionPolicy;
     1:     return NS_OK;
     1: }
     1: 
  2364: NS_IMETHODIMP
 79445: nsJSChannel::SetExecuteAsync(bool aIsAsync)
  2364: {
  2364:     if (!mIsActive) {
  2364:         mIsAsync = aIsAsync;
  2364:     }
  2364:     // else ignore this call
  2364:     NS_WARN_IF_FALSE(!mIsActive, "Calling SetExecuteAsync on active channel?");
  2364: 
  2364:     return NS_OK;
  2364: }
  2364: 
  2364: NS_IMETHODIMP
 79445: nsJSChannel::GetExecuteAsync(bool* aIsAsync)
  2364: {
  2364:     *aIsAsync = mIsAsync;
  2364:     return NS_OK;
  2364: }
  2364: 
     1: ////////////////////////////////////////////////////////////////////////////////
     1: 
     1: nsJSProtocolHandler::nsJSProtocolHandler()
     1: {
     1: }
     1: 
     1: nsresult
     1: nsJSProtocolHandler::Init()
     1: {
     1:     return NS_OK;
     1: }
     1: 
     1: nsJSProtocolHandler::~nsJSProtocolHandler()
     1: {
     1: }
     1: 
     1: NS_IMPL_ISUPPORTS1(nsJSProtocolHandler, nsIProtocolHandler)
     1: 
 46997: nsresult
     1: nsJSProtocolHandler::Create(nsISupports *aOuter, REFNSIID aIID, void **aResult)
     1: {
     1:     if (aOuter)
     1:         return NS_ERROR_NO_AGGREGATION;
     1: 
     1:     nsJSProtocolHandler* ph = new nsJSProtocolHandler();
     1:     if (!ph)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     NS_ADDREF(ph);
     1:     nsresult rv = ph->Init();
     1:     if (NS_SUCCEEDED(rv)) {
     1:         rv = ph->QueryInterface(aIID, aResult);
     1:     }
     1:     NS_RELEASE(ph);
     1:     return rv;
     1: }
     1: 
     1: nsresult 
     1: nsJSProtocolHandler::EnsureUTF8Spec(const nsAFlatCString &aSpec, const char *aCharset, 
     1:                                     nsACString &aUTF8Spec)
     1: {
     1:   aUTF8Spec.Truncate();
     1: 
     1:   nsresult rv;
     1:   
     1:   if (!mTextToSubURI) {
     1:     mTextToSubURI = do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1:   nsAutoString uStr;
     1:   rv = mTextToSubURI->UnEscapeNonAsciiURI(nsDependentCString(aCharset), aSpec, uStr);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (!IsASCII(uStr))
     1:     NS_EscapeURL(NS_ConvertUTF16toUTF8(uStr), esc_AlwaysCopy | esc_OnlyNonASCII, aUTF8Spec);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: ////////////////////////////////////////////////////////////////////////////////
     1: // nsIProtocolHandler methods:
     1: 
     1: NS_IMETHODIMP
     1: nsJSProtocolHandler::GetScheme(nsACString &result)
     1: {
     1:     result = "javascript";
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsJSProtocolHandler::GetDefaultPort(int32_t *result)
     1: {
     1:     *result = -1;        // no port for javascript: URLs
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsJSProtocolHandler::GetProtocolFlags(uint32_t *result)
     1: {
     1:     *result = URI_NORELATIVE | URI_NOAUTH | URI_INHERITS_SECURITY_CONTEXT |
 23759:         URI_LOADABLE_BY_ANYONE | URI_NON_PERSISTABLE | URI_OPENING_EXECUTES_SCRIPT;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSProtocolHandler::NewURI(const nsACString &aSpec,
 21811:                             const char *aCharset,
     1:                             nsIURI *aBaseURI,
     1:                             nsIURI **result)
     1: {
     1:     nsresult rv;
     1: 
     1:     // javascript: URLs (currently) have no additional structure beyond that
     1:     // provided by standard URLs, so there is no "outer" object given to
     1:     // CreateInstance.
     1: 
 70888:     nsCOMPtr<nsIURI> url = new nsJSURI(aBaseURI);
     1: 
     1:     if (!aCharset || !nsCRT::strcasecmp("UTF-8", aCharset))
     1:       rv = url->SetSpec(aSpec);
     1:     else {
110974:       nsAutoCString utf8Spec;
     1:       rv = EnsureUTF8Spec(PromiseFlatCString(aSpec), aCharset, utf8Spec);
     1:       if (NS_SUCCEEDED(rv)) {
     1:         if (utf8Spec.IsEmpty())
     1:           rv = url->SetSpec(aSpec);
     1:         else
     1:           rv = url->SetSpec(utf8Spec);
     1:       }
     1:     }
     1: 
     1:     if (NS_FAILED(rv)) {
     1:         return rv;
     1:     }
     1: 
 70888:     url.forget(result);
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsJSProtocolHandler::NewChannel(nsIURI* uri, nsIChannel* *result)
     1: {
     1:     nsresult rv;
     1:     nsJSChannel * channel;
     1: 
     1:     NS_ENSURE_ARG_POINTER(uri);
     1: 
     1:     channel = new nsJSChannel();
     1:     if (!channel) {
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:     NS_ADDREF(channel);
     1: 
     1:     rv = channel->Init(uri);
     1:     if (NS_SUCCEEDED(rv)) {
     1:         *result = channel;
     1:         NS_ADDREF(*result);
     1:     }
     1:     NS_RELEASE(channel);
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsJSProtocolHandler::AllowPort(int32_t port, const char *scheme, bool *_retval)
     1: {
     1:     // don't override anything.  
 80486:     *_retval = false;
     1:     return NS_OK;
     1: }
     1: 
 21811: ////////////////////////////////////////////////////////////
 21811: // nsJSURI implementation
 70888: static NS_DEFINE_CID(kThisSimpleURIImplementationCID,
 70888:                      NS_THIS_SIMPLEURI_IMPLEMENTATION_CID);
 21811: 
 70888: 
 70888: NS_IMPL_ADDREF_INHERITED(nsJSURI, nsSimpleURI)
 70888: NS_IMPL_RELEASE_INHERITED(nsJSURI, nsSimpleURI)
 21811: 
 21811: NS_INTERFACE_MAP_BEGIN(nsJSURI)
 21811:   if (aIID.Equals(kJSURICID))
 21811:       foundInterface = static_cast<nsIURI*>(this);
 70888:   else if (aIID.Equals(kThisSimpleURIImplementationCID)) {
 70888:       // Need to return explicitly here, because if we just set foundInterface
 70888:       // to null the NS_INTERFACE_MAP_END_INHERITING will end up calling into
 70888:       // nsSimplURI::QueryInterface and finding something for this CID.
106838:       *aInstancePtr = nullptr;
 70888:       return NS_NOINTERFACE;
 70888:   }
 21811:   else
 70888: NS_INTERFACE_MAP_END_INHERITING(nsSimpleURI)
 21811: 
 21811: // nsISerializable methods:
 21811: 
 21811: NS_IMETHODIMP
 21811: nsJSURI::Read(nsIObjectInputStream* aStream)
 21811: {
 70888:     nsresult rv = nsSimpleURI::Read(aStream);
 21811:     if (NS_FAILED(rv)) return rv;
 21811: 
 79445:     bool haveBase;
 21811:     rv = aStream->ReadBoolean(&haveBase);
 21811:     if (NS_FAILED(rv)) return rv;
 21811: 
 21811:     if (haveBase) {
 80486:         rv = aStream->ReadObject(true, getter_AddRefs(mBaseURI));
 21811:         if (NS_FAILED(rv)) return rv;
 21811:     }
 21811: 
 21811:     return NS_OK;
 21811: }
 21811: 
 21811: NS_IMETHODIMP
 21811: nsJSURI::Write(nsIObjectOutputStream* aStream)
 21811: {
 70888:     nsresult rv = nsSimpleURI::Write(aStream);
 21811:     if (NS_FAILED(rv)) return rv;
 21811: 
106838:     rv = aStream->WriteBoolean(mBaseURI != nullptr);
 21811:     if (NS_FAILED(rv)) return rv;
 21811: 
 21811:     if (mBaseURI) {
 80486:         rv = aStream->WriteObject(mBaseURI, true);
 21811:         if (NS_FAILED(rv)) return rv;
 21811:     }
 21811: 
 21811:     return NS_OK;
 21811: }
 21811: 
 70949: // nsSimpleURI methods:
 70888: /* virtual */ nsSimpleURI*
 70888: nsJSURI::StartClone(nsSimpleURI::RefHandlingEnum /* ignored */)
 70888: {
 70888:     nsCOMPtr<nsIURI> baseClone;
 70888:     if (mBaseURI) {
 70949:       // Note: We preserve ref on *base* URI, regardless of ref handling mode.
 70888:       nsresult rv = mBaseURI->Clone(getter_AddRefs(baseClone));
 70888:       if (NS_FAILED(rv)) {
106838:         return nullptr;
 70888:       }
 70888:     }
 70888: 
 70888:     return new nsJSURI(baseClone);
 70888: }
 69049: 
 70949: /* virtual */ nsresult
 70949: nsJSURI::EqualsInternal(nsIURI* aOther,
 70949:                         nsSimpleURI::RefHandlingEnum aRefHandlingMode,
 79445:                         bool* aResult)
 69042: {
 70949:     NS_ENSURE_ARG_POINTER(aOther);
 70949:     NS_PRECONDITION(aResult, "null pointer for outparam");
 69049: 
 70888:     nsRefPtr<nsJSURI> otherJSURI;
 70949:     nsresult rv = aOther->QueryInterface(kJSURICID,
 70888:                                          getter_AddRefs(otherJSURI));
 70949:     if (NS_FAILED(rv)) {
 80486:         *aResult = false; // aOther is not a nsJSURI --> not equal.
 69049:         return NS_OK;
 69042:     }
 21811: 
 70949:     // Compare the member data that our base class knows about.
 70949:     if (!nsSimpleURI::EqualsInternal(otherJSURI, aRefHandlingMode)) {
 80486:         *aResult = false;
 21811:         return NS_OK;
 70949:     }
 70888: 
 70949:     // Compare the piece of additional member data that we add to base class.
 70888:     nsIURI* otherBaseURI = otherJSURI->GetBaseURI();
 70888: 
 70949:     if (mBaseURI) {
 70949:         // (As noted in StartClone, we always honor refs on mBaseURI)
 70949:         return mBaseURI->Equals(otherBaseURI, aResult);
 21811:     }
 21811: 
 70949:     *aResult = !otherBaseURI;
 21811:     return NS_OK;
 21811: }
 21811: 
 21811: NS_IMETHODIMP 
 21811: nsJSURI::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
 21811: {
 21811:     *aClassIDNoAlloc = kJSURICID;
 21811:     return NS_OK;
 21811: }
 70888: 
