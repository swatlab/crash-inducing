47353: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
47353: /* ***** BEGIN LICENSE BLOCK *****
47353:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
47353:  *
47353:  * The contents of this file are subject to the Mozilla Public License Version
47353:  * 1.1 (the "License"); you may not use this file except in compliance with
47353:  * the License. You may obtain a copy of the License at
47353:  * http://www.mozilla.org/MPL/
47353:  *
47353:  * Software distributed under the License is distributed on an "AS IS" basis,
47353:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
47353:  * for the specific language governing rights and limitations under the
47353:  * License.
47353:  *
47353:  * The Original Code is mozilla.org code.
47353:  *
47353:  * The Initial Developer of the Original Code is
47353:  * Netscape Communications Corporation.
47353:  * Portions created by the Initial Developer are Copyright (C) 1998
47353:  * the Initial Developer. All Rights Reserved.
47353:  *
47353:  * Contributor(s):
47353:  *
47353:  * Alternatively, the contents of this file may be used under the terms of
47353:  * either the GNU General Public License Version 2 or later (the "GPL"), or
47353:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
47353:  * in which case the provisions of the GPL or the LGPL are applicable instead
47353:  * of those above. If you wish to allow use of your version of this file only
47353:  * under the terms of either the GPL or the LGPL, and not to allow others to
47353:  * use your version of this file under the terms of the MPL, indicate your
47353:  * decision by deleting the provisions above and replace them with the notice
47353:  * and other provisions required by the GPL or the LGPL. If you do not delete
47353:  * the provisions above, a recipient may use your version of this file under
47353:  * the terms of any one of the MPL, the GPL or the LGPL.
47353:  *
47353:  * ***** END LICENSE BLOCK ***** */
47353: 
47353: #include "nsNPAPIPluginStreamListener.h"
47353: #include "plstr.h"
47353: #include "prmem.h"
47353: #include "nsDirectoryServiceDefs.h"
47353: #include "nsDirectoryServiceUtils.h"
47353: #include "nsILocalFile.h"
47353: #include "nsNetUtil.h"
47353: #include "nsPluginHost.h"
47353: #include "nsNPAPIPlugin.h"
47353: #include "nsPluginSafety.h"
47353: #include "nsPluginLogging.h"
60021: #include "nsPluginStreamListenerPeer.h"
47353: 
47353: NS_IMPL_ISUPPORTS1(nsPluginStreamToFile, nsIOutputStream)
47353: 
47353: nsPluginStreamToFile::nsPluginStreamToFile(const char* target,
47353:                                            nsIPluginInstanceOwner* owner)
47353: : mTarget(PL_strdup(target)),
47353: mOwner(owner)
47353: {
47353:   nsresult rv;
47353:   nsCOMPtr<nsIFile> pluginTmp;
47353:   rv = NS_GetSpecialDirectory(NS_OS_TEMP_DIR, getter_AddRefs(pluginTmp));
47353:   if (NS_FAILED(rv)) return;
47353:   
47353:   mTempFile = do_QueryInterface(pluginTmp, &rv);
47353:   if (NS_FAILED(rv)) return;
47353:   
47353:   // need to create a file with a unique name - use target as the basis
47353:   rv = mTempFile->AppendNative(nsDependentCString(target));
47353:   if (NS_FAILED(rv)) return;
47353:   
47353:   // Yes, make it unique.
47353:   rv = mTempFile->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0700); 
47353:   if (NS_FAILED(rv)) return;
47353:   
47353:   // create the file
47353:   rv = NS_NewLocalFileOutputStream(getter_AddRefs(mOutputStream), mTempFile, -1, 00600);
47353:   if (NS_FAILED(rv))
47353:     return;
47353: 	
47353:   // construct the URL we'll use later in calls to GetURL()
47353:   NS_GetURLSpecFromFile(mTempFile, mFileURL);
47353:   
47353: #ifdef NS_DEBUG
47353:   printf("File URL = %s\n", mFileURL.get());
47353: #endif
47353: }
47353: 
47353: nsPluginStreamToFile::~nsPluginStreamToFile()
47353: {
47353:   // should we be deleting mTempFile here?
47353:   if (nsnull != mTarget)
47353:     PL_strfree(mTarget);
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsPluginStreamToFile::Flush()
47353: {
47353:   return NS_OK;
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsPluginStreamToFile::Write(const char* aBuf, PRUint32 aCount,
47353:                             PRUint32 *aWriteCount)
47353: {
47353:   mOutputStream->Write(aBuf, aCount, aWriteCount);
47353:   mOutputStream->Flush();
47353:   mOwner->GetURL(mFileURL.get(), mTarget, nsnull, nsnull, 0);
47353:   
47353:   return NS_OK;
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsPluginStreamToFile::WriteFrom(nsIInputStream *inStr, PRUint32 count,
47353:                                 PRUint32 *_retval)
47353: {
47353:   NS_NOTREACHED("WriteFrom");
47353:   return NS_ERROR_NOT_IMPLEMENTED;
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsPluginStreamToFile::WriteSegments(nsReadSegmentFun reader, void * closure,
47353:                                     PRUint32 count, PRUint32 *_retval)
47353: {
47353:   NS_NOTREACHED("WriteSegments");
47353:   return NS_ERROR_NOT_IMPLEMENTED;
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsPluginStreamToFile::IsNonBlocking(PRBool *aNonBlocking)
47353: {
47353:   *aNonBlocking = PR_FALSE;
47353:   return NS_OK;
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsPluginStreamToFile::Close(void)
47353: {
47353:   mOutputStream->Close();
47353:   mOwner->GetURL(mFileURL.get(), mTarget, nsnull, nsnull, 0);
47353:   return NS_OK;
47353: }
47353: 
47353: // nsNPAPIPluginStreamListener Methods
47353: 
47353: NS_IMPL_ISUPPORTS3(nsNPAPIPluginStreamListener, nsIPluginStreamListener,
47353:                    nsITimerCallback, nsIHTTPHeaderListener)
47353: 
47353: nsNPAPIPluginStreamListener::nsNPAPIPluginStreamListener(nsNPAPIPluginInstance* inst, 
47353:                                                          void* notifyData,
47353:                                                          const char* aURL)
60021: : mStreamBuffer(nsnull),
47353: mNotifyURL(aURL ? PL_strdup(aURL) : nsnull),
47353: mInst(inst),
60021: mStreamListenerPeer(nsnull),
47353: mStreamBufferSize(0),
47353: mStreamBufferByteCount(0),
47353: mStreamType(NP_NORMAL),
47353: mStreamStarted(PR_FALSE),
47353: mStreamCleanedUp(PR_FALSE),
60021: mCallNotify(notifyData ? PR_TRUE : PR_FALSE),
47353: mIsSuspended(PR_FALSE),
47353: mIsPluginInitJSStream(mInst->mInPluginInitCall &&
47353:                       aURL && strncmp(aURL, "javascript:",
47353:                                       sizeof("javascript:") - 1) == 0),
62512: mRedirectDenied(PR_FALSE),
47353: mResponseHeaderBuf(nsnull)
47353: {
47353:   memset(&mNPStream, 0, sizeof(mNPStream));
60021:   mNPStream.notifyData = notifyData;
47353: }
47353: 
47353: nsNPAPIPluginStreamListener::~nsNPAPIPluginStreamListener()
47353: {
47353:   // remove this from the plugin instance's stream list
60021:   nsTArray<nsNPAPIPluginStreamListener*> *streamListeners = mInst->StreamListeners();
60021:   streamListeners->RemoveElement(this);
47353: 
47353:   // For those cases when NewStream is never called, we still may need
47353:   // to fire a notification callback. Return network error as fallback
47353:   // reason because for other cases, notify should have already been
47353:   // called for other reasons elsewhere.
47353:   CallURLNotify(NPRES_NETWORK_ERR);
47353:   
47353:   // lets get rid of the buffer
47353:   if (mStreamBuffer) {
47353:     PR_Free(mStreamBuffer);
47353:     mStreamBuffer=nsnull;
47353:   }
47353:   
47353:   if (mNotifyURL)
47353:     PL_strfree(mNotifyURL);
47353:   
47353:   if (mResponseHeaderBuf)
47353:     PL_strfree(mResponseHeaderBuf);
47353: }
47353: 
47353: nsresult
47353: nsNPAPIPluginStreamListener::CleanUpStream(NPReason reason)
47353: {
47353:   nsresult rv = NS_ERROR_FAILURE;
47353:   
47353:   if (mStreamCleanedUp)
47353:     return NS_OK;
47353:   
47353:   mStreamCleanedUp = PR_TRUE;
47353:   
47353:   StopDataPump();
47353: 
60021:   // Release any outstanding redirect callback.
60021:   if (mHTTPRedirectCallback) {
60021:     mHTTPRedirectCallback->OnRedirectVerifyCallback(NS_ERROR_FAILURE);
60021:     mHTTPRedirectCallback = nsnull;
60021:   }
60021: 
47353:   // Seekable streams have an extra addref when they are created which must
47353:   // be matched here.
47353:   if (NP_SEEK == mStreamType)
47353:     NS_RELEASE_THIS();
47353:   
47353:   if (!mInst || !mInst->CanFireNotifications())
47353:     return rv;
47353:   
47353:   mStreamInfo = NULL;
47353:   
47353:   PluginDestructionGuard guard(mInst);
47353: 
47965:   nsNPAPIPlugin* plugin = mInst->GetPlugin();
55810:   if (!plugin || !plugin->GetLibrary())
47965:     return rv;
47965: 
47965:   NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
47965: 
47353:   NPP npp;
47353:   mInst->GetNPP(&npp);
47353: 
47965:   if (mStreamStarted && pluginFunctions->destroystream) {
47353:     NPPAutoPusher nppPusher(npp);
47353: 
47353:     NPError error;
55810:     NS_TRY_SAFE_CALL_RETURN(error, (*pluginFunctions->destroystream)(npp, &mNPStream, reason), mInst);
47353:     
47353:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
47353:                    ("NPP DestroyStream called: this=%p, npp=%p, reason=%d, return=%d, url=%s\n",
47353:                     this, npp, reason, error, mNPStream.url));
47353:     
47353:     if (error == NPERR_NO_ERROR)
47353:       rv = NS_OK;
47353:   }
47353:   
47353:   mStreamStarted = PR_FALSE;
47353:   
47353:   // fire notification back to plugin, just like before
47353:   CallURLNotify(reason);
47353:   
47353:   return rv;
47353: }
47353: 
47353: void
47353: nsNPAPIPluginStreamListener::CallURLNotify(NPReason reason)
47353: {
47353:   if (!mCallNotify || !mInst || !mInst->CanFireNotifications())
47353:     return;
47353:   
47353:   PluginDestructionGuard guard(mInst);
47353:   
47353:   mCallNotify = PR_FALSE; // only do this ONCE and prevent recursion
47353: 
47965:   nsNPAPIPlugin* plugin = mInst->GetPlugin();
55810:   if (!plugin || !plugin->GetLibrary())
47965:     return;
47965: 
47965:   NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
47965: 
47965:   if (pluginFunctions->urlnotify) {
47353:     NPP npp;
47353:     mInst->GetNPP(&npp);
47353:     
60021:     NS_TRY_SAFE_CALL_VOID((*pluginFunctions->urlnotify)(npp, mNotifyURL, reason, mNPStream.notifyData), mInst);
47353:     
47353:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
47353:                    ("NPP URLNotify called: this=%p, npp=%p, notify=%p, reason=%d, url=%s\n",
60021:                     this, npp, mNPStream.notifyData, reason, mNotifyURL));
47353:   }
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsNPAPIPluginStreamListener::OnStartBinding(nsIPluginStreamInfo* pluginInfo)
47353: {
47965:   if (!mInst || !mInst->CanFireNotifications())
47353:     return NS_ERROR_FAILURE;
47353: 
47353:   PluginDestructionGuard guard(mInst);
47353: 
47965:   nsNPAPIPlugin* plugin = mInst->GetPlugin();
55810:   if (!plugin || !plugin->GetLibrary())
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
47965: 
47965:   if (!pluginFunctions->newstream)
47965:     return NS_ERROR_FAILURE;
47965: 
47353:   NPP npp;
47353:   mInst->GetNPP(&npp);
47353: 
47353:   PRBool seekable;
47353:   char* contentType;
47353:   PRUint16 streamType = NP_NORMAL;
47353:   NPError error;
47353:   
47353:   mNPStream.ndata = (void*) this;
47353:   pluginInfo->GetURL(&mNPStream.url);
47353:   
47353:   pluginInfo->GetLength((PRUint32*)&(mNPStream.end));
47353:   pluginInfo->GetLastModified((PRUint32*)&(mNPStream.lastmodified));
47353:   pluginInfo->IsSeekable(&seekable);
47353:   pluginInfo->GetContentType(&contentType);
47353:   
47353:   if (!mResponseHeaders.IsEmpty()) {
47353:     mResponseHeaderBuf = PL_strdup(mResponseHeaders.get());
47353:     mNPStream.headers = mResponseHeaderBuf;
47353:   }
47353:   
47353:   mStreamInfo = pluginInfo;
47353:   
47353:   NPPAutoPusher nppPusher(npp);
47353:   
55810:   NS_TRY_SAFE_CALL_RETURN(error, (*pluginFunctions->newstream)(npp, (char*)contentType, &mNPStream, seekable, &streamType), mInst);
47353:   
47353:   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
47353:                  ("NPP NewStream called: this=%p, npp=%p, mime=%s, seek=%d, type=%d, return=%d, url=%s\n",
47353:                   this, npp, (char *)contentType, seekable, streamType, error, mNPStream.url));
47353:   
47353:   if (error != NPERR_NO_ERROR)
47353:     return NS_ERROR_FAILURE;
47353:   
47353:   switch(streamType)
47353:   {
47353:     case NP_NORMAL:
47353:       mStreamType = NP_NORMAL; 
47353:       break;
47353:     case NP_ASFILEONLY:
47353:       mStreamType = NP_ASFILEONLY; 
47353:       break;
47353:     case NP_ASFILE:
47353:       mStreamType = NP_ASFILE; 
47353:       break;
47353:     case NP_SEEK:
47353:       mStreamType = NP_SEEK; 
47353:       // Seekable streams should continue to exist even after OnStopRequest
47353:       // is fired, so we AddRef ourself an extra time and Release when the
47353:       // plugin calls NPN_DestroyStream (CleanUpStream). If the plugin never
47353:       // calls NPN_DestroyStream the stream will be destroyed before the plugin
47353:       // instance is destroyed.
47353:       NS_ADDREF_THIS();
47353:       break;
47353:     default:
47353:       return NS_ERROR_FAILURE;
47353:   }
47353:   
47353:   mStreamStarted = PR_TRUE;
47353:   return NS_OK;
47353: }
47353: 
63022: nsresult
47353: nsNPAPIPluginStreamListener::SuspendRequest()
47353: {
47353:   NS_ASSERTION(!mIsSuspended,
47353:                "Suspending a request that's already suspended!");
47353:   
47353:   nsCOMPtr<nsINPAPIPluginStreamInfo> pluginInfoNPAPI =
47353:   do_QueryInterface(mStreamInfo);
63022:   nsIRequest *request;
47353:   
63022:   if (!pluginInfoNPAPI || !(request = pluginInfoNPAPI->GetRequest())) {
63022:     NS_ERROR("Trying to suspend a non-suspendable stream!");
63022:     return NS_ERROR_FAILURE;
47353:   }
47353:   
47353:   nsresult rv = StartDataPump();
63022:   NS_ENSURE_SUCCESS(rv, rv);
47353:   
47353:   mIsSuspended = PR_TRUE;
47353:   
63022:   return request->Suspend();
47353: }
47353: 
47353: void
47353: nsNPAPIPluginStreamListener::ResumeRequest()
47353: {
47353:   nsCOMPtr<nsINPAPIPluginStreamInfo> pluginInfoNPAPI =
47353:   do_QueryInterface(mStreamInfo);
47353:   
63022:   nsIRequest *request = pluginInfoNPAPI->GetRequest();
63022:   
63022:   // request can be null if the network stream is done.
63022:   if (request)
63022:     request->Resume();
47353:   
47353:   mIsSuspended = PR_FALSE;
47353: }
47353: 
47353: nsresult
47353: nsNPAPIPluginStreamListener::StartDataPump()
47353: {
47353:   nsresult rv;
47353:   mDataPumpTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
47353:   NS_ENSURE_SUCCESS(rv, rv);
47353:   
47353:   // Start pumping data to the plugin every 100ms until it obeys and
47353:   // eats the data.
47353:   return mDataPumpTimer->InitWithCallback(this, 100,
47353:                                           nsITimer::TYPE_REPEATING_SLACK);
47353: }
47353: 
47353: void
47353: nsNPAPIPluginStreamListener::StopDataPump()
47353: {
47353:   if (mDataPumpTimer) {
47353:     mDataPumpTimer->Cancel();
47353:     mDataPumpTimer = nsnull;
47353:   }
47353: }
47353: 
47353: // Return true if a javascript: load that was started while the plugin
47353: // was being initialized is still in progress.
47353: PRBool
47353: nsNPAPIPluginStreamListener::PluginInitJSLoadInProgress()
47353: {
47353:   if (!mInst)
47353:     return PR_FALSE;
47353: 
60021:   nsTArray<nsNPAPIPluginStreamListener*> *streamListeners = mInst->StreamListeners();
60021:   for (unsigned int i = 0; i < streamListeners->Length(); i++) {
60021:     if (streamListeners->ElementAt(i)->mIsPluginInitJSStream) {
47353:       return PR_TRUE;
47353:     }
47353:   }
47353:   
47353:   return PR_FALSE;
47353: }
47353: 
47353: // This method is called when there's more data available off the
47353: // network, but it's also called from our data pump when we're feeding
47353: // the plugin data that we already got off the network, but the plugin
47353: // was unable to consume it at the point it arrived. In the case when
47353: // the plugin pump calls this method, the input argument will be null,
47353: // and the length will be the number of bytes available in our
47353: // internal buffer.
47353: NS_IMETHODIMP
47353: nsNPAPIPluginStreamListener::OnDataAvailable(nsIPluginStreamInfo* pluginInfo,
47353:                                              nsIInputStream* input,
47353:                                              PRUint32 length)
47353: {
47965:   if (!length || !mInst || !mInst->CanFireNotifications())
47353:     return NS_ERROR_FAILURE;
47353:   
47353:   PluginDestructionGuard guard(mInst);
47353:   
47353:   // Just in case the caller switches plugin info on us.
47353:   mStreamInfo = pluginInfo;
47353: 
47965:   nsNPAPIPlugin* plugin = mInst->GetPlugin();
55810:   if (!plugin || !plugin->GetLibrary())
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
47965: 
47353:   // check out if plugin implements NPP_Write call
47965:   if (!pluginFunctions->write)
47353:     return NS_ERROR_FAILURE; // it'll cancel necko transaction 
47353:   
47353:   if (!mStreamBuffer) {
47353:     // To optimize the mem usage & performance we have to allocate
47353:     // mStreamBuffer here in first ODA when length of data available
47353:     // in input stream is known.  mStreamBuffer will be freed in DTOR.
47353:     // we also have to remember the size of that buff to make safe
47353:     // consecutive Read() calls form input stream into our buff.
47353:     
47353:     PRUint32 contentLength;
47353:     pluginInfo->GetLength(&contentLength);
47353:     
47353:     mStreamBufferSize = NS_MAX(length, contentLength);
47353:     
47353:     // Limit the size of the initial buffer to MAX_PLUGIN_NECKO_BUFFER
47353:     // (16k). This buffer will grow if needed, as in the case where
47353:     // we're getting data faster than the plugin can process it.
47353:     mStreamBufferSize = NS_MIN(mStreamBufferSize,
47353:                                PRUint32(MAX_PLUGIN_NECKO_BUFFER));
47353:     
47353:     mStreamBuffer = (char*) PR_Malloc(mStreamBufferSize);
47353:     if (!mStreamBuffer)
47353:       return NS_ERROR_OUT_OF_MEMORY;
47353:   }
47353:   
47353:   // prepare NPP_ calls params
47353:   NPP npp;
47353:   mInst->GetNPP(&npp);
47353:   
47353:   PRInt32 streamPosition;
47353:   pluginInfo->GetStreamOffset(&streamPosition);
47353:   PRInt32 streamOffset = streamPosition;
47353:   
47353:   if (input) {
47353:     streamOffset += length;
47353:     
47353:     // Set new stream offset for the next ODA call regardless of how
47353:     // following NPP_Write call will behave we pretend to consume all
47353:     // data from the input stream.  It's possible that current steam
47353:     // position will be overwritten from NPP_RangeRequest call made
47353:     // from NPP_Write, so we cannot call SetStreamOffset after
47353:     // NPP_Write.
47353:     //
47353:     // Note: there is a special case when data flow should be
47353:     // temporarily stopped if NPP_WriteReady returns 0 (bug #89270)
47353:     pluginInfo->SetStreamOffset(streamOffset);
47353:     
47353:     // set new end in case the content is compressed
47353:     // initial end is less than end of decompressed stream
47353:     // and some plugins (e.g. acrobat) can fail. 
47353:     if ((PRInt32)mNPStream.end < streamOffset)
47353:       mNPStream.end = streamOffset;
47353:   }
47353:   
47353:   nsresult rv = NS_OK;
47353:   while (NS_SUCCEEDED(rv) && length > 0) {
47353:     if (input && length) {
47353:       if (mStreamBufferSize < mStreamBufferByteCount + length && mIsSuspended) {
47353:         // We're in the ::OnDataAvailable() call that we might get
47353:         // after suspending a request, or we suspended the request
47353:         // from within this ::OnDataAvailable() call while there's
47353:         // still data in the input, and we don't have enough space to
47353:         // store what we got off the network. Reallocate our internal
47353:         // buffer.
47353:         mStreamBufferSize = mStreamBufferByteCount + length;
47353:         char *buf = (char*)PR_Realloc(mStreamBuffer, mStreamBufferSize);
47353:         if (!buf)
47353:           return NS_ERROR_OUT_OF_MEMORY;
47353:         
47353:         mStreamBuffer = buf;
47353:       }
47353:       
47353:       PRUint32 bytesToRead =
47353:       NS_MIN(length, mStreamBufferSize - mStreamBufferByteCount);
47353:       
47353:       PRUint32 amountRead = 0;
47353:       rv = input->Read(mStreamBuffer + mStreamBufferByteCount, bytesToRead,
47353:                        &amountRead);
47353:       NS_ENSURE_SUCCESS(rv, rv);
47353:       
47353:       if (amountRead == 0) {
47353:         NS_NOTREACHED("input->Read() returns no data, it's almost impossible "
47353:                       "to get here");
47353:         
47353:         break;
47353:       }
47353:       
47353:       mStreamBufferByteCount += amountRead;
47353:       length -= amountRead;
47353:     } else {
47353:       // No input, nothing to read. Set length to 0 so that we don't
47353:       // keep iterating through this outer loop any more.
47353:       
47353:       length = 0;
47353:     }
47353:     
47353:     // Temporary pointer to the beginning of the data we're writing as
47353:     // we loop and feed the plugin data.
47353:     char *ptrStreamBuffer = mStreamBuffer;
47353:     
47353:     // it is possible plugin's NPP_Write() returns 0 byte consumed. We
47353:     // use zeroBytesWriteCount to count situation like this and break
47353:     // the loop
47353:     PRInt32 zeroBytesWriteCount = 0;
47353:     
47353:     // mStreamBufferByteCount tells us how many bytes there are in the
47353:     // buffer. WriteReady returns to us how many bytes the plugin is
47353:     // ready to handle.
47353:     while (mStreamBufferByteCount > 0) {
47353:       PRInt32 numtowrite;
47965:       if (pluginFunctions->writeready) {
47353:         NPPAutoPusher nppPusher(npp);
47353:         
55810:         NS_TRY_SAFE_CALL_RETURN(numtowrite, (*pluginFunctions->writeready)(npp, &mNPStream), mInst);
47353:         NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
47353:                        ("NPP WriteReady called: this=%p, npp=%p, "
47353:                         "return(towrite)=%d, url=%s\n",
47353:                         this, npp, numtowrite, mNPStream.url));
47353:         
47353:         if (!mStreamStarted) {
47353:           // The plugin called NPN_DestroyStream() from within
47353:           // NPP_WriteReady(), kill the stream.
47353:           
47353:           return NS_BINDING_ABORTED;
47353:         }
47353:         
47353:         // if WriteReady returned 0, the plugin is not ready to handle
47353:         // the data, suspend the stream (if it isn't already
47353:         // suspended).
47353:         //
47353:         // Also suspend the stream if the stream we're loading is not
47353:         // a javascript: URL load that was initiated during plugin
47353:         // initialization and there currently is such a stream
47353:         // loading. This is done to work around a Windows Media Player
47353:         // plugin bug where it can't deal with being fed data for
47353:         // other streams while it's waiting for data from the
47353:         // javascript: URL loads it requests during
47353:         // initialization. See bug 386493 for more details.
47353:         
47353:         if (numtowrite <= 0 ||
47353:             (!mIsPluginInitJSStream && PluginInitJSLoadInProgress())) {
47353:           if (!mIsSuspended) {
63022:             rv = SuspendRequest();
47353:           }
47353:           
47353:           // Break out of the inner loop, but keep going through the
47353:           // outer loop in case there's more data to read from the
47353:           // input stream.
47353:           
47353:           break;
47353:         }
47353:         
47353:         numtowrite = NS_MIN(numtowrite, mStreamBufferByteCount);
47353:       } else {
47353:         // if WriteReady is not supported by the plugin, just write
47353:         // the whole buffer
47353:         numtowrite = mStreamBufferByteCount;
47353:       }
47353:       
47353:       NPPAutoPusher nppPusher(npp);
47353:       
47353:       PRInt32 writeCount = 0; // bytes consumed by plugin instance
55810:       NS_TRY_SAFE_CALL_RETURN(writeCount, (*pluginFunctions->write)(npp, &mNPStream, streamPosition, numtowrite, ptrStreamBuffer), mInst);
47353:       
47353:       NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
47353:                      ("NPP Write called: this=%p, npp=%p, pos=%d, len=%d, "
47353:                       "buf=%s, return(written)=%d,  url=%s\n",
47353:                       this, npp, streamPosition, numtowrite,
47353:                       ptrStreamBuffer, writeCount, mNPStream.url));
47353:       
47353:       if (!mStreamStarted) {
47353:         // The plugin called NPN_DestroyStream() from within
47353:         // NPP_Write(), kill the stream.
47353:         return NS_BINDING_ABORTED;
47353:       }
47353:       
47353:       if (writeCount > 0) {
47353:         NS_ASSERTION(writeCount <= mStreamBufferByteCount,
47353:                      "Plugin read past the end of the available data!");
47353:         
47353:         writeCount = NS_MIN(writeCount, mStreamBufferByteCount);
47353:         mStreamBufferByteCount -= writeCount;
47353:         
47353:         streamPosition += writeCount;
47353:         
47353:         zeroBytesWriteCount = 0;
47353:         
47353:         if (mStreamBufferByteCount > 0) {
47353:           // This alignment code is most likely bogus, but we'll leave
47353:           // it in for now in case it matters for some plugins on some
47353:           // architectures. Who knows...
47353:           if (writeCount % sizeof(PRWord)) {
47353:             // memmove will take care  about alignment 
47353:             memmove(mStreamBuffer, ptrStreamBuffer + writeCount,
47353:                     mStreamBufferByteCount);
47353:             ptrStreamBuffer = mStreamBuffer;
47353:           } else {
47353:             // if aligned we can use ptrStreamBuffer += to eliminate
47353:             // memmove()
47353:             ptrStreamBuffer += writeCount;
47353:           }
47353:         }
47353:       } else if (writeCount == 0) {
47353:         // if NPP_Write() returns writeCount == 0 lets say 3 times in
47353:         // a row, suspend the request and continue feeding the plugin
47353:         // the data we got so far. Once that data is consumed, we'll
47353:         // resume the request.
47353:         if (mIsSuspended || ++zeroBytesWriteCount == 3) {
47353:           if (!mIsSuspended) {
63022:             rv = SuspendRequest();
47353:           }
47353:           
47353:           // Break out of the for loop, but keep going through the
47353:           // while loop in case there's more data to read from the
47353:           // input stream.
47353:           
47353:           break;
47353:         }
47353:       } else {
47353:         // Something's really wrong, kill the stream.
47353:         rv = NS_ERROR_FAILURE;
47353:         
47353:         break;
47353:       }  
47353:     } // end of inner while loop
47353:     
47353:     if (mStreamBufferByteCount && mStreamBuffer != ptrStreamBuffer) {
47353:       memmove(mStreamBuffer, ptrStreamBuffer, mStreamBufferByteCount);
47353:     }
47353:   }
47353:   
47353:   if (streamPosition != streamOffset) {
47353:     // The plugin didn't consume all available data, or consumed some
47353:     // of our cached data while we're pumping cached data. Adjust the
47353:     // plugin info's stream offset to match reality, except if the
47353:     // plugin info's stream offset was set by a re-entering
47353:     // NPN_RequestRead() call.
47353:     
47353:     PRInt32 postWriteStreamPosition;
47353:     pluginInfo->GetStreamOffset(&postWriteStreamPosition);
47353:     
47353:     if (postWriteStreamPosition == streamOffset) {
47353:       pluginInfo->SetStreamOffset(streamPosition);
47353:     }
47353:   }
47353:   
47353:   return rv;
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsNPAPIPluginStreamListener::OnFileAvailable(nsIPluginStreamInfo* pluginInfo, 
47353:                                              const char* fileName)
47353: {
47353:   if (!mInst || !mInst->CanFireNotifications())
47353:     return NS_ERROR_FAILURE;
47353:   
47353:   PluginDestructionGuard guard(mInst);
47353: 
47965:   nsNPAPIPlugin* plugin = mInst->GetPlugin();
55810:   if (!plugin || !plugin->GetLibrary())
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
47965: 
47965:   if (!pluginFunctions->asfile)
47353:     return NS_ERROR_FAILURE;
47353: 
47353:   NPP npp;
47353:   mInst->GetNPP(&npp);
47353:   
55810:   NS_TRY_SAFE_CALL_VOID((*pluginFunctions->asfile)(npp, &mNPStream, fileName), mInst);
47353:   
47353:   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
47353:                  ("NPP StreamAsFile called: this=%p, npp=%p, url=%s, file=%s\n",
47353:                   this, npp, mNPStream.url, fileName));
47353:   
47353:   return NS_OK;
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsNPAPIPluginStreamListener::OnStopBinding(nsIPluginStreamInfo* pluginInfo, 
47353:                                            nsresult status)
47353: {
47353:   StopDataPump();
47353:   
47353:   if (NS_FAILED(status)) {
47353:     // The stream was destroyed, or died for some reason. Make sure we
47353:     // cancel the underlying request.
47353:     nsCOMPtr<nsINPAPIPluginStreamInfo> pluginInfoNPAPI =
47353:     do_QueryInterface(mStreamInfo);
47353:     
63022:     nsIRequest *request;
63022:     if (pluginInfoNPAPI && (request = pluginInfoNPAPI->GetRequest())) {
63022:       request->Cancel(status);
47353:     }
47353:   }
47353:   
47353:   if (!mInst || !mInst->CanFireNotifications())
47353:     return NS_ERROR_FAILURE;
47353: 
47353:   // check if the stream is of seekable type and later its destruction
47353:   // see bug 91140
47353:   nsresult rv = NS_OK;
47353:   NPReason reason = NS_FAILED(status) ? NPRES_NETWORK_ERR : NPRES_DONE;
62512:   if (mRedirectDenied) {
62512:     reason = NPRES_USER_BREAK;
62512:   }
47353:   if (mStreamType != NP_SEEK ||
47353:       (NP_SEEK == mStreamType && NS_BINDING_ABORTED == status)) {
47353:     rv = CleanUpStream(reason);
47353:   }
47353: 
47353:   return rv;
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsNPAPIPluginStreamListener::GetStreamType(PRInt32 *result)
47353: {
47353:   *result = mStreamType;
47353:   return NS_OK;
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsNPAPIPluginStreamListener::Notify(nsITimer *aTimer)
47353: {
47353:   NS_ASSERTION(aTimer == mDataPumpTimer, "Uh, wrong timer?");
47353:   
47353:   PRInt32 oldStreamBufferByteCount = mStreamBufferByteCount;
47353:   
47353:   nsresult rv = OnDataAvailable(mStreamInfo, nsnull, mStreamBufferByteCount);
47353:   
47353:   if (NS_FAILED(rv)) {
47353:     // We ran into an error, no need to keep firing this timer then.
47353:     aTimer->Cancel();
47353:     return NS_OK;
47353:   }
47353:   
47353:   if (mStreamBufferByteCount != oldStreamBufferByteCount &&
47353:       ((mStreamStarted && mStreamBufferByteCount < 1024) ||
47353:        mStreamBufferByteCount == 0)) {
47353:         // The plugin read some data and we've got less than 1024 bytes in
47353:         // our buffer (or its empty and the stream is already
47353:         // done). Resume the request so that we get more data off the
47353:         // network.
47353:         ResumeRequest();
47353:         // Necko will pump data now that we've resumed the request.
47353:         StopDataPump();
47353:       }
47353:   
47353:   return NS_OK;
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsNPAPIPluginStreamListener::StatusLine(const char* line)
47353: {
47353:   mResponseHeaders.Append(line);
47353:   mResponseHeaders.Append('\n');
47353:   return NS_OK;
47353: }
47353: 
47353: NS_IMETHODIMP
47353: nsNPAPIPluginStreamListener::NewResponseHeader(const char* headerName,
47353:                                                const char* headerValue)
47353: {
47353:   mResponseHeaders.Append(headerName);
47353:   mResponseHeaders.Append(": ");
47353:   mResponseHeaders.Append(headerValue);
47353:   mResponseHeaders.Append('\n');
47353:   return NS_OK;
47353: }
60021: 
60021: bool
60021: nsNPAPIPluginStreamListener::HandleRedirectNotification(nsIChannel *oldChannel, nsIChannel *newChannel,
60021:                                                         nsIAsyncVerifyRedirectCallback* callback)
60021: {
60021:   nsCOMPtr<nsIHttpChannel> oldHttpChannel = do_QueryInterface(oldChannel);
60021:   nsCOMPtr<nsIHttpChannel> newHttpChannel = do_QueryInterface(newChannel);
60021:   if (!oldHttpChannel || !newHttpChannel) {
60021:     return false;
60021:   }
60021: 
61933:   if (!mInst || !mInst->CanFireNotifications()) {
60021:     return false;
60021:   }
60021: 
60021:   nsNPAPIPlugin* plugin = mInst->GetPlugin();
60021:   if (!plugin || !plugin->GetLibrary()) {
60021:     return false;
60021:   }
60021: 
60021:   NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
60021:   if (!pluginFunctions->urlredirectnotify) {
60021:     return false;
60021:   }
60021: 
60021:   // A non-null closure is required for redirect handling support.
60021:   if (mNPStream.notifyData) {
60021:     PRUint32 status;
60021:     if (NS_SUCCEEDED(oldHttpChannel->GetResponseStatus(&status))) {
60021:       nsCOMPtr<nsIURI> uri;
60021:       if (NS_SUCCEEDED(newHttpChannel->GetURI(getter_AddRefs(uri))) && uri) {
60021:         nsCAutoString spec;
60021:         if (NS_SUCCEEDED(uri->GetAsciiSpec(spec))) {
60021:           // At this point the plugin will be responsible for making the callback
60021:           // so save the callback object.
60021:           mHTTPRedirectCallback = callback;
60021: 
60021:           NPP npp;
60021:           mInst->GetNPP(&npp);
60021: #if defined(XP_WIN) || defined(XP_OS2)
60021:           NS_TRY_SAFE_CALL_VOID((*pluginFunctions->urlredirectnotify)(npp, spec.get(), static_cast<int32_t>(status), mNPStream.notifyData), mInst);
60021: #else
60021:           (*pluginFunctions->urlredirectnotify)(npp, spec.get(), static_cast<int32_t>(status), mNPStream.notifyData);
60021: #endif
60021:           return true;
60021:         }
60021:       }
60021:     }
60021:   }
60021: 
60021:   callback->OnRedirectVerifyCallback(NS_ERROR_FAILURE);
60021:   return true;
60021: }
60021: 
60021: void
60021: nsNPAPIPluginStreamListener::URLRedirectResponse(NPBool allow)
60021: {
60021:   if (mHTTPRedirectCallback) {
60021:     mHTTPRedirectCallback->OnRedirectVerifyCallback(allow ? NS_OK : NS_ERROR_FAILURE);
62512:     mRedirectDenied = allow ? PR_FALSE : PR_TRUE;
60021:     mHTTPRedirectCallback = nsnull;
60021:   }
60021: }
