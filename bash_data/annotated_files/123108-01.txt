115294: /* This Source Code Form is subject to the terms of the Mozilla Public
115294:  * License, v. 2.0. If a copy of the MPL was not distributed with this
115294:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
115294: 
115294: #include "mozilla/dom/TextEncoder.h"
115294: #include "mozilla/dom/EncodingUtils.h"
115294: #include "nsContentUtils.h"
115294: #include "nsICharsetConverterManager.h"
115294: #include "nsServiceManagerUtils.h"
115294: 
115294: namespace mozilla {
115294: namespace dom {
115294: 
115294: void
119967: TextEncoder::Init(const nsAString& aEncoding,
115294:                   ErrorResult& aRv)
115294: {
119967:   nsAutoString label(aEncoding);
115294:   EncodingUtils::TrimSpaceCharacters(label);
115294: 
121140:   // Let encoding be the result of getting an encoding from label.
121140:   // If encoding is failure, or is none of utf-8, utf-16, and utf-16be,
121140:   // throw a TypeError.
115294:   if (!EncodingUtils::FindEncodingForLabel(label, mEncoding)) {
121140:     aRv.ThrowTypeError(MSG_ENCODING_NOT_SUPPORTED, &label);
115294:     return;
115294:   }
115294: 
122804:   if (mEncoding.EqualsLiteral("UTF-16")) {
122804:     mEncoding.AssignLiteral("UTF-16LE");
122804:   }
122804: 
121273:   if (!mEncoding.EqualsLiteral("UTF-8") &&
121273:       !mEncoding.EqualsLiteral("UTF-16LE") &&
121273:       !mEncoding.EqualsLiteral("UTF-16BE")) {
121140:     aRv.ThrowTypeError(MSG_DOM_ENCODING_NOT_UTF);
115294:     return;
115294:   }
115294: 
115294:   // Create an encoder object for mEncoding.
115294:   nsCOMPtr<nsICharsetConverterManager> ccm =
115294:     do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID);
115294:   if (!ccm) {
115294:     aRv.Throw(NS_ERROR_UNEXPECTED);
115294:     return;
115294:   }
115294: 
121273:   ccm->GetUnicodeEncoderRaw(mEncoding.get(), getter_AddRefs(mEncoder));
115294:   if (!mEncoder) {
115294:     aRv.Throw(NS_ERROR_UNEXPECTED);
115294:     return;
115294:   }
115294: }
115294: 
115294: JSObject*
115294: TextEncoder::Encode(JSContext* aCx,
115294:                     const nsAString& aString,
115294:                     const TextEncodeOptions& aOptions,
115294:                     ErrorResult& aRv)
115294: {
115294:   // Run the steps of the encoding algorithm.
115294:   int32_t srcLen = aString.Length();
115294:   int32_t maxLen;
115294:   const PRUnichar* data = PromiseFlatString(aString).get();
115294:   nsresult rv = mEncoder->GetMaxLength(data, srcLen, &maxLen);
115294:   if (NS_FAILED(rv)) {
115294:     aRv.Throw(rv);
115294:     return nullptr;
115294:   }
115294:   // Need a fallible allocator because the caller may be a content
115294:   // and the content can specify the length of the string.
115294:   static const fallible_t fallible = fallible_t();
115294:   nsAutoArrayPtr<char> buf(new (fallible) char[maxLen + 1]);
115294:   if (!buf) {
115294:     aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
115294:     return nullptr;
115294:   }
115294: 
115294:   int32_t dstLen = maxLen;
115294:   rv = mEncoder->Convert(data, &srcLen, buf, &dstLen);
115294: 
115294:   // If the internal streaming flag is not set, then reset
115294:   // the encoding algorithm state to the default values for encoding.
115294:   if (!aOptions.stream) {
115294:     int32_t finishLen = maxLen - dstLen;
115294:     rv = mEncoder->Finish(buf + dstLen, &finishLen);
115294:     if (NS_SUCCEEDED(rv)) {
115294:       dstLen += finishLen;
115294:     }
115294:   }
115294: 
115294:   JSObject* outView = nullptr;
115294:   if (NS_SUCCEEDED(rv)) {
115294:     buf[dstLen] = '\0';
115294:     outView = Uint8Array::Create(aCx, this, dstLen,
115294:                                  reinterpret_cast<uint8_t*>(buf.get()));
123108:     if (!outView) {
123108:       aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
123108:       return nullptr;
123108:     }
115294:   }
115294: 
115294:   if (NS_FAILED(rv)) {
115294:     aRv.Throw(rv);
115294:   }
115294:   return outView;
115294: }
115294: 
115294: void
115294: TextEncoder::GetEncoding(nsAString& aEncoding)
115294: {
121273:   CopyASCIItoUTF16(mEncoding, aEncoding);
121273:   nsContentUtils::ASCIIToLower(aEncoding);
115294: }
115294: 
115294: NS_IMPL_CYCLE_COLLECTING_ADDREF(TextEncoder)
115294: NS_IMPL_CYCLE_COLLECTING_RELEASE(TextEncoder)
115294: 
115294: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(TextEncoder)
115294:   NS_INTERFACE_MAP_ENTRY(nsISupports)
115294: NS_INTERFACE_MAP_END
115294: 
115294: NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_1(TextEncoder, mGlobal)
115294: 
115294: } // dom
115294: } // mozilla
