     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98497: /* vim: set ts=2 sw=2 et tw=80: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 80467: #include "mozilla/Util.h"
 80467: 
     1: #include "nsXMLHttpRequest.h"
     1: #include "nsISimpleEnumerator.h"
     1: #include "nsIXPConnect.h"
     1: #include "nsICharsetConverterManager.h"
     1: #include "nsLayoutCID.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsIURI.h"
     1: #include "nsILoadGroup.h"
     1: #include "nsNetUtil.h"
 32329: #include "nsStreamUtils.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsIUploadChannel.h"
 32329: #include "nsIUploadChannel2.h"
     1: #include "nsIDOMSerializer.h"
     1: #include "nsXPCOM.h"
     1: #include "nsISupportsPrimitives.h"
     1: #include "nsGUIEvent.h"
     1: #include "prprf.h"
     1: #include "nsIDOMEventListener.h"
     1: #include "nsIJSContextStack.h"
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsWeakPtr.h"
 91519: #include "nsCharsetAlias.h"
     1: #include "nsIScriptGlobalObject.h"
 80058: #include "nsDOMClassInfoID.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMWindow.h"
 32329: #include "nsIMIMEService.h"
 32329: #include "nsCExternalHandlerService.h"
     1: #include "nsIVariant.h"
 86103: #include "nsVariant.h"
 86103: #include "nsIScriptError.h"
 86103: #include "xpcpublic.h"
     1: #include "nsStringStream.h"
     1: #include "nsIStreamConverterService.h"
     1: #include "nsICachingChannel.h"
     1: #include "nsContentUtils.h"
     1: #include "nsEventDispatcher.h"
     1: #include "nsDOMJSUtils.h"
     1: #include "nsCOMArray.h"
     1: #include "nsIScriptableUConv.h"
     1: #include "nsCycleCollectionParticipant.h"
    68: #include "nsIContentPolicy.h"
    68: #include "nsContentPolicyUtils.h"
108290: #include "nsError.h"
  1526: #include "nsLayoutStatics.h"
 19951: #include "nsCrossSiteListenerProxy.h"
  4064: #include "nsIHTMLDocument.h"
  4106: #include "nsIMultiPartChannel.h"
  8947: #include "nsIScriptObjectPrincipal.h"
 13258: #include "nsIStorageStream.h"
 14092: #include "nsIPromptFactory.h"
 14092: #include "nsIWindowWatcher.h"
 41763: #include "nsCharSeparatedTokenizer.h"
 35023: #include "nsIConsoleService.h"
 41212: #include "nsIChannelPolicy.h"
 41212: #include "nsChannelPolicy.h"
 41212: #include "nsIContentSecurityPolicy.h"
 48889: #include "nsAsyncRedirectVerifyHelper.h"
 58163: #include "nsStringBuffer.h"
 69662: #include "nsDOMFile.h"
 69662: #include "nsIFileChannel.h"
 82487: #include "mozilla/Telemetry.h"
 95834: #include "jsfriendapi.h"
 87692: #include "sampler.h"
 97422: #include "mozilla/dom/XMLHttpRequestBinding.h"
 94307: #include "nsIDOMFormData.h"
101616: #include "DictionaryHelpers.h"
102310: #include "mozilla/Attributes.h"
108686: #include "nsIPermissionManager.h"
110481: #include "nsMimeTypes.h"
 94307: 
 88267: #include "nsWrapperCacheInlines.h"
 98497: #include "nsStreamListenerWrapper.h"
     1: 
 80467: using namespace mozilla;
 94307: using namespace mozilla::dom;
 80467: 
     1: #define LOAD_STR "load"
     1: #define ERROR_STR "error"
 16665: #define ABORT_STR "abort"
 88284: #define TIMEOUT_STR "timeout"
 16665: #define LOADSTART_STR "loadstart"
     1: #define PROGRESS_STR "progress"
     1: #define READYSTATE_STR "readystatechange"
 63715: #define LOADEND_STR "loadend"
     1: 
     1: // CIDs
     1: 
     1: // State
 69662: #define XML_HTTP_REQUEST_UNSENT           (1 << 0) // 0 UNSENT
 69662: #define XML_HTTP_REQUEST_OPENED           (1 << 1) // 1 OPENED
 69662: #define XML_HTTP_REQUEST_HEADERS_RECEIVED (1 << 2) // 2 HEADERS_RECEIVED
 69662: #define XML_HTTP_REQUEST_LOADING          (1 << 3) // 3 LOADING
 69662: #define XML_HTTP_REQUEST_DONE             (1 << 4) // 4 DONE
 69662: #define XML_HTTP_REQUEST_SENT             (1 << 5) // Internal, OPENED in IE and external view
 69662: #define XML_HTTP_REQUEST_STOPPED          (1 << 6) // Internal, LOADING in IE and external view
     1: // The above states are mutually exclusive, change with ChangeState() only.
     1: // The states below can be combined.
     1: #define XML_HTTP_REQUEST_ABORTED        (1 << 7)  // Internal
     1: #define XML_HTTP_REQUEST_ASYNC          (1 << 8)  // Internal
     1: #define XML_HTTP_REQUEST_PARSEBODY      (1 << 9)  // Internal
 63932: #define XML_HTTP_REQUEST_SYNCLOOPING    (1 << 10) // Internal
 63932: #define XML_HTTP_REQUEST_MULTIPART      (1 << 11) // Internal
 63932: #define XML_HTTP_REQUEST_GOT_FINAL_STOP (1 << 12) // Internal
 63932: #define XML_HTTP_REQUEST_BACKGROUND     (1 << 13) // Internal
 19152: // This is set when we've got the headers for a multipart XMLHttpRequest,
 19152: // but haven't yet started to process the first part.
 63932: #define XML_HTTP_REQUEST_MPART_HEADERS  (1 << 14) // Internal
 63932: #define XML_HTTP_REQUEST_USE_XSITE_AC   (1 << 15) // Internal
 63932: #define XML_HTTP_REQUEST_NEED_AC_PREFLIGHT (1 << 16) // Internal
 63932: #define XML_HTTP_REQUEST_AC_WITH_CREDENTIALS (1 << 17) // Internal
 88284: #define XML_HTTP_REQUEST_TIMED_OUT (1 << 18) // Internal
 90101: #define XML_HTTP_REQUEST_DELETED (1 << 19) // Internal
     1: 
     1: #define XML_HTTP_REQUEST_LOADSTATES         \
 69662:   (XML_HTTP_REQUEST_UNSENT |                \
     1:    XML_HTTP_REQUEST_OPENED |                \
 69662:    XML_HTTP_REQUEST_HEADERS_RECEIVED |      \
 69662:    XML_HTTP_REQUEST_LOADING |               \
 69662:    XML_HTTP_REQUEST_DONE |                  \
     1:    XML_HTTP_REQUEST_SENT |                  \
     1:    XML_HTTP_REQUEST_STOPPED)
     1: 
 13282: #define NS_BADCERTHANDLER_CONTRACTID \
 13282:   "@mozilla.org/content/xmlhttprequest-bad-cert-handler;1"
 13282: 
 23607: #define NS_PROGRESS_EVENT_INTERVAL 50
 20640: 
 94307: #define IMPL_STRING_GETTER(_name)                                               \
 94307:   NS_IMETHODIMP                                                                 \
 94307:   nsXMLHttpRequest::_name(nsAString& aOut)                                      \
 94307:   {                                                                             \
 94307:     nsString tmp;                                                               \
 94307:     _name(tmp);                                                                 \
 94307:     aOut = tmp;                                                                 \
 94307:     return NS_OK;                                                               \
 94307:   }
 94307: 
 82543: NS_IMPL_ISUPPORTS1(nsXHRParseEndListener, nsIDOMEventListener)
 82543: 
 25722: class nsResumeTimeoutsEvent : public nsRunnable
 25722: {
 25722: public:
 25722:   nsResumeTimeoutsEvent(nsPIDOMWindow* aWindow) : mWindow(aWindow) {}
 25722: 
 25722:   NS_IMETHOD Run()
 25722:   {
 80486:     mWindow->ResumeTimeouts(false);
 25722:     return NS_OK;
 25722:   }
 25722: 
 25722: private:
 25722:   nsCOMPtr<nsPIDOMWindow> mWindow;
 25722: };
 25722: 
 16664: 
     1: // This helper function adds the given load flags to the request's existing
     1: // load flags.
     1: static void AddLoadFlags(nsIRequest *request, nsLoadFlags newFlags)
     1: {
     1:   nsLoadFlags flags;
     1:   request->GetLoadFlags(&flags);
     1:   flags |= newFlags;
     1:   request->SetLoadFlags(flags);
     1: }
     1: 
 79445: static nsresult IsCapabilityEnabled(const char *capability, bool *enabled)
 13282: {
 13282:   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
 13282:   if (!secMan)
 13282:     return NS_ERROR_FAILURE;
 13282: 
 13282:   return secMan->IsCapabilityEnabled(capability, enabled);
 13282: }
 13282: 
     1: // Helper proxy class to be used when expecting an
     1: // multipart/x-mixed-replace stream of XML documents.
     1: 
     1: class nsMultipartProxyListener : public nsIStreamListener
     1: {
     1: public:
     1:   nsMultipartProxyListener(nsIStreamListener *dest);
     1:   virtual ~nsMultipartProxyListener();
     1: 
     1:   /* additional members */
     1:   NS_DECL_ISUPPORTS
     1:   NS_DECL_NSISTREAMLISTENER
     1:   NS_DECL_NSIREQUESTOBSERVER
     1: 
     1: private:
     1:   nsCOMPtr<nsIStreamListener> mDestListener;
     1: };
     1: 
     1: 
     1: nsMultipartProxyListener::nsMultipartProxyListener(nsIStreamListener *dest)
     1:   : mDestListener(dest)
     1: {
     1: }
     1: 
     1: nsMultipartProxyListener::~nsMultipartProxyListener()
     1: {
     1: }
     1: 
     1: NS_IMPL_ISUPPORTS2(nsMultipartProxyListener, nsIStreamListener,
     1:                    nsIRequestObserver)
     1: 
     1: /** nsIRequestObserver methods **/
     1: 
     1: NS_IMETHODIMP
     1: nsMultipartProxyListener::OnStartRequest(nsIRequest *aRequest,
     1:                                          nsISupports *ctxt)
     1: {
     1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
     1:   NS_ENSURE_TRUE(channel, NS_ERROR_UNEXPECTED);
     1: 
110974:   nsAutoCString contentType;
     1:   nsresult rv = channel->GetContentType(contentType);
     1: 
     1:   if (!contentType.EqualsLiteral("multipart/x-mixed-replace")) {
     1:     return NS_ERROR_INVALID_ARG;
     1:   }
     1: 
     1:   // If multipart/x-mixed-replace content, we'll insert a MIME
     1:   // decoder in the pipeline to handle the content and pass it along
     1:   // to our original listener.
     1: 
 19152:   nsCOMPtr<nsIXMLHttpRequest> xhr = do_QueryInterface(mDestListener);
 19152: 
     1:   nsCOMPtr<nsIStreamConverterService> convServ =
     1:     do_GetService("@mozilla.org/streamConverters;1", &rv);
     1:   if (NS_SUCCEEDED(rv)) {
     1:     nsCOMPtr<nsIStreamListener> toListener(mDestListener);
     1:     nsCOMPtr<nsIStreamListener> fromListener;
     1: 
     1:     rv = convServ->AsyncConvertData("multipart/x-mixed-replace",
     1:                                     "*/*",
     1:                                     toListener,
106838:                                     nullptr,
     1:                                     getter_AddRefs(fromListener));
     1:     NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && fromListener, NS_ERROR_UNEXPECTED);
     1: 
     1:     mDestListener = fromListener;
     1:   }
     1: 
 19152:   if (xhr) {
 19152:     static_cast<nsXMLHttpRequest*>(xhr.get())->mState |=
 19152:       XML_HTTP_REQUEST_MPART_HEADERS;
 19152:    }
 19152: 
     1:   return mDestListener->OnStartRequest(aRequest, ctxt);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsMultipartProxyListener::OnStopRequest(nsIRequest *aRequest,
     1:                                         nsISupports *ctxt,
     1:                                         nsresult status)
     1: {
     1:   return mDestListener->OnStopRequest(aRequest, ctxt, status);
     1: }
     1: 
     1: /** nsIStreamListener methods **/
     1: 
     1: NS_IMETHODIMP
     1: nsMultipartProxyListener::OnDataAvailable(nsIRequest *aRequest,
     1:                                           nsISupports *ctxt,
     1:                                           nsIInputStream *inStr,
111234:                                           uint64_t sourceOffset,
108991:                                           uint32_t count)
     1: {
     1:   return mDestListener->OnDataAvailable(aRequest, ctxt, inStr, sourceOffset,
     1:                                         count);
     1: }
     1: 
     1: /////////////////////////////////////////////
 16665: 
 16665: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXHREventTarget)
 16665: 
 29226: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXHREventTarget,
 89667:                                                   nsDOMEventTargetHelper)
     1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
     1: 
 29226: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsXHREventTarget,
 89667:                                                 nsDOMEventTargetHelper)
     1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
     1: 
 29226: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsXHREventTarget)
 16665:   NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequestEventTarget)
 89667: NS_INTERFACE_MAP_END_INHERITING(nsDOMEventTargetHelper)
 89667: 
 89667: NS_IMPL_ADDREF_INHERITED(nsXHREventTarget, nsDOMEventTargetHelper)
 89667: NS_IMPL_RELEASE_INHERITED(nsXHREventTarget, nsDOMEventTargetHelper)
     1: 
110823: NS_IMPL_EVENT_HANDLER(nsXHREventTarget, loadstart)
110823: NS_IMPL_EVENT_HANDLER(nsXHREventTarget, progress)
110823: NS_IMPL_EVENT_HANDLER(nsXHREventTarget, abort)
110823: NS_IMPL_EVENT_HANDLER(nsXHREventTarget, error)
110823: NS_IMPL_EVENT_HANDLER(nsXHREventTarget, load)
110823: NS_IMPL_EVENT_HANDLER(nsXHREventTarget, timeout)
110823: NS_IMPL_EVENT_HANDLER(nsXHREventTarget, loadend)
110823: 
 92083: void
 92083: nsXHREventTarget::DisconnectFromOwner()
 92083: {
 92083:   nsDOMEventTargetHelper::DisconnectFromOwner();
 79469: }
 63715: 
 16665: /////////////////////////////////////////////
 19701: 
 40490: DOMCI_DATA(XMLHttpRequestUpload, nsXMLHttpRequestUpload)
 40490: 
 19701: NS_INTERFACE_MAP_BEGIN(nsXMLHttpRequestUpload)
 16665:   NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequestUpload)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(XMLHttpRequestUpload)
 16665: NS_INTERFACE_MAP_END_INHERITING(nsXHREventTarget)
 16665: 
 16665: NS_IMPL_ADDREF_INHERITED(nsXMLHttpRequestUpload, nsXHREventTarget)
 16665: NS_IMPL_RELEASE_INHERITED(nsXMLHttpRequestUpload, nsXHREventTarget)
 16665: 
 16665: /////////////////////////////////////////////
 16665: //
 16665: //
 16665: /////////////////////////////////////////////
 16665: 
 16665: nsXMLHttpRequest::nsXMLHttpRequest()
 78800:   : mResponseBodyDecodedPos(0),
 78800:     mResponseType(XML_HTTP_RESPONSE_TYPE_DEFAULT),
106838:     mRequestObserver(nullptr), mState(XML_HTTP_REQUEST_UNSENT),
 80486:     mUploadTransferred(0), mUploadTotal(0), mUploadComplete(true),
 80486:     mProgressSinceLastProgressEvent(false),
 20640:     mUploadProgress(0), mUploadProgressMax(0),
 88284:     mRequestSentTime(0), mTimeoutMilliseconds(0),
 90244:     mErrorLoad(false), mWaitingForOnStopRequest(false),
 90244:     mProgressTimerIsActive(false), mProgressEventWasDelayed(false),
 82543:     mIsHtml(false),
 82543:     mWarnAboutMultipartHtml(false),
 82543:     mWarnAboutSyncHtml(false),
 88284:     mLoadLengthComputable(false), mLoadTotal(0),
103957:     mIsSystem(false),
103957:     mIsAnon(false),
 80486:     mFirstStartRequestSeen(false),
 80486:     mInLoadProgressEvent(false),
 78799:     mResultJSON(JSVAL_VOID),
111437:     mResultArrayBuffer(nullptr),
111437:     mXPCOMifier(nullptr)
 16665: {
 16665:   nsLayoutStatics::AddRef();
 94512: 
 94512:   SetIsDOMBinding();
 94307: #ifdef DEBUG
 94307:   StaticAssertions();
 94307: #endif
 16665: }
 16665: 
 16665: nsXMLHttpRequest::~nsXMLHttpRequest()
 16665: {
 90101:   mState |= XML_HTTP_REQUEST_DELETED;
 90101: 
 16665:   if (mState & (XML_HTTP_REQUEST_STOPPED |
 16665:                 XML_HTTP_REQUEST_SENT |
 69662:                 XML_HTTP_REQUEST_LOADING)) {
 16665:     Abort();
 16665:   }
 16665: 
 16665:   NS_ABORT_IF_FALSE(!(mState & XML_HTTP_REQUEST_SYNCLOOPING), "we rather crash than hang");
 16665:   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
 16665: 
 16665:   nsLayoutStatics::Release();
 16665: }
 16665: 
 70838: void
107500: nsXMLHttpRequest::RootJSResultObjects()
 70838: {
 72322:   nsContentUtils::PreserveWrapper(
 72322:     static_cast<nsIDOMEventTarget*>(
 72322:       static_cast<nsDOMEventTargetHelper*>(this)), this);
 70838: }
 70838: 
 16665: /**
 16665:  * This Init method is called from the factory constructor.
 16665:  */
 16665: nsresult
 16665: nsXMLHttpRequest::Init()
 16665: {
 16665:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 16665:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
 16665:   if (secMan) {
101616:     secMan->GetSystemPrincipal(getter_AddRefs(subjectPrincipal));
 16665:   }
 16665:   NS_ENSURE_STATE(subjectPrincipal);
106838:   Construct(subjectPrincipal, nullptr);
 16665:   return NS_OK;
 16665: }
101616: 
 16665: /**
 16665:  * This Init method should only be called by C++ consumers.
 16665:  */
 16665: NS_IMETHODIMP
 16665: nsXMLHttpRequest::Init(nsIPrincipal* aPrincipal,
 16665:                        nsIScriptContext* aScriptContext,
 23201:                        nsPIDOMWindow* aOwnerWindow,
 23201:                        nsIURI* aBaseURI)
 16665: {
 16665:   NS_ENSURE_ARG_POINTER(aPrincipal);
 94512:   Construct(aPrincipal,
106838:             aOwnerWindow ? aOwnerWindow->GetCurrentInnerWindow() : nullptr,
 94512:             aBaseURI);
 16665:   return NS_OK;
 16665: }
 16665: 
 16665: /**
 16665:  * This Initialize method is called from XPConnect via nsIJSNativeInitializer.
 16665:  */
 16665: NS_IMETHODIMP
 16665: nsXMLHttpRequest::Initialize(nsISupports* aOwner, JSContext* cx, JSObject* obj,
108991:                              uint32_t argc, jsval *argv)
 16665: {
 92083:   nsCOMPtr<nsPIDOMWindow> owner = do_QueryInterface(aOwner);
 92083:   if (!owner) {
 16665:     NS_WARNING("Unexpected nsIJSNativeInitializer owner");
 16665:     return NS_OK;
 16665:   }
 16665: 
 16665:   // This XHR object is bound to a |window|,
 16665:   // so re-set principal and script context.
 16665:   nsCOMPtr<nsIScriptObjectPrincipal> scriptPrincipal = do_QueryInterface(aOwner);
 16665:   NS_ENSURE_STATE(scriptPrincipal);
 94512: 
 94512:   Construct(scriptPrincipal->GetPrincipal(), owner);
101616:   if (argc) {
101616:     nsresult rv = InitParameters(cx, argv);
101616:     NS_ENSURE_SUCCESS(rv, rv);
101616:   }
101616:   return NS_OK;
101616: }
101616: 
101616: nsresult
101616: nsXMLHttpRequest::InitParameters(JSContext* aCx, const jsval* aParams)
101616: {
102423:   XMLHttpRequestParameters params;
102423:   nsresult rv = params.Init(aCx, aParams);
101616:   NS_ENSURE_SUCCESS(rv, rv);
101616: 
102425:   InitParameters(params.mozAnon, params.mozSystem);
102425:   return NS_OK;
102425: }
102425: 
102425: void
102425: nsXMLHttpRequest::InitParameters(bool aAnon, bool aSystem)
102425: {
114064:   if (!aAnon && !aSystem) {
114064:     return;
114064:   }
114064: 
101616:   // Check for permissions.
101616:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(GetOwner());
102425:   if (!window || !window->GetDocShell()) {
102425:     return;
102425:   }
101616: 
101616:   // Chrome is always allowed access, so do the permission check only
101616:   // for non-chrome pages.
101616:   if (!nsContentUtils::IsCallerChrome()) {
101616:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(window->GetExtantDocument());
102425:     if (!doc) {
102425:       return;
102425:     }
101616: 
108686:     nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
108686:     nsCOMPtr<nsIPermissionManager> permMgr =
108686:       do_GetService(NS_PERMISSIONMANAGER_CONTRACTID);
108686:     if (!permMgr)
108686:       return;
108686: 
108991:     uint32_t permission;
108686:     nsresult rv =
108686:       permMgr->TestPermissionFromPrincipal(principal, "systemXHR", &permission);
108686:     if (NS_FAILED(rv) || permission != nsIPermissionManager::ALLOW_ACTION) {
102425:       return;
102425:     }
102425:   }
102425: 
114064:   SetParameters(aAnon, aSystem);
 16665: }
 16665: 
 19944: void
 78799: nsXMLHttpRequest::ResetResponse()
 78799: {
106838:   mResponseXML = nullptr;
 78799:   mResponseBody.Truncate();
 78800:   mResponseText.Truncate();
106838:   mResponseBlob = nullptr;
106838:   mDOMFile = nullptr;
106838:   mBuilder = nullptr;
106838:   mResultArrayBuffer = nullptr;
 78799:   mResultJSON = JSVAL_VOID;
 78799:   mLoadTransferred = 0;
 78800:   mResponseBodyDecodedPos = 0;
 78799: }
 78799: 
 78799: void
 19944: nsXMLHttpRequest::SetRequestObserver(nsIRequestObserver* aObserver)
 19944: {
 19944:   mRequestObserver = aObserver;
 19944: }
 19944: 
 16665: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXMLHttpRequest)
 16665: 
 88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsXMLHttpRequest)
 90244:   bool isBlack = tmp->IsBlack();
 90244:   if (isBlack || tmp->mWaitingForOnStopRequest) {
 88267:     if (tmp->mListenerManager) {
 88267:       tmp->mListenerManager->UnmarkGrayJSListeners();
 88267:     }
 93345:     if (!isBlack && tmp->PreservingWrapper()) {
 93345:       xpc_UnmarkGrayObject(tmp->GetWrapperPreserveColor());
 90244:     }
 88267:     return true;
 88267:   }
 88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
 88267: 
 88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsXMLHttpRequest)
 88267:   return tmp->IsBlack();
 88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
 88267: 
 88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsXMLHttpRequest)
 88267:   return tmp->IsBlack();
 88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
 88267: 
 16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXMLHttpRequest,
 16665:                                                   nsXHREventTarget)
 16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContext)
 16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannel)
 16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mReadRequest)
 21005:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mResponseXML)
 64070:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCORSPreflightChannel)
 16665: 
 16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mXMLParserStreamListener)
 16665: 
 16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannelEventSink)
 16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mProgressEventSink)
 16665: 
 16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mUpload,
 16665:                                                        nsIXMLHttpRequestUpload)
 16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 16665: 
 16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsXMLHttpRequest,
 16665:                                                 nsXHREventTarget)
106838:   tmp->mResultArrayBuffer = nullptr;
 78115:   tmp->mResultJSON = JSVAL_VOID;
 16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContext)
 16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChannel)
 16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mReadRequest)
 21005:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mResponseXML)
 64070:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCORSPreflightChannel)
 16665: 
 16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mXMLParserStreamListener)
 16665: 
 16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChannelEventSink)
 16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mProgressEventSink)
 16665: 
 16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mUpload)
 16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 16665: 
 70838: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED(nsXMLHttpRequest,
 70838:                                                nsXHREventTarget)
101616:   NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mResultArrayBuffer)
101616:   NS_IMPL_CYCLE_COLLECTION_TRACE_JSVAL_MEMBER_CALLBACK(mResultJSON)
 70838: NS_IMPL_CYCLE_COLLECTION_TRACE_END
 70838: 
 40490: DOMCI_DATA(XMLHttpRequest, nsXMLHttpRequest)
 16665: 
 16665: // QueryInterface implementation for nsXMLHttpRequest
 16665: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsXMLHttpRequest)
 16665:   NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequest)
 16665:   NS_INTERFACE_MAP_ENTRY(nsIJSXMLHttpRequest)
 16665:   NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
 16665:   NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
 16665:   NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
 16665:   NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)
 16665:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
 16665:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 16665:   NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
 20640:   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(XMLHttpRequest)
 16665: NS_INTERFACE_MAP_END_INHERITING(nsXHREventTarget)
 16665: 
 16665: NS_IMPL_ADDREF_INHERITED(nsXMLHttpRequest, nsXHREventTarget)
 16665: NS_IMPL_RELEASE_INHERITED(nsXMLHttpRequest, nsXHREventTarget)
 16665: 
110823: NS_IMPL_EVENT_HANDLER(nsXMLHttpRequest, readystatechange)
110823: 
 92083: void
 92083: nsXMLHttpRequest::DisconnectFromOwner()
 92083: {
 92083:   nsXHREventTarget::DisconnectFromOwner();
 92084:   Abort();
 92083: }
 92083: 
     1: /* readonly attribute nsIChannel channel; */
     1: NS_IMETHODIMP
     1: nsXMLHttpRequest::GetChannel(nsIChannel **aChannel)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aChannel);
     1:   NS_IF_ADDREF(*aChannel = mChannel);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 84264: static void LogMessage(const char* aWarning, nsPIDOMWindow* aWindow)
 84264: {
 84264:   nsCOMPtr<nsIDocument> doc;
 84264:   if (aWindow) {
 84264:     doc = do_QueryInterface(aWindow->GetExtantDocument());
 84264:   }
 84636:   nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
 84636:                                   "DOM", doc,
 84636:                                   nsContentUtils::eDOM_PROPERTIES,
 84636:                                   aWarning);
 84264: }
 84264: 
     1: /* readonly attribute nsIDOMDocument responseXML; */
     1: NS_IMETHODIMP
     1: nsXMLHttpRequest::GetResponseXML(nsIDOMDocument **aResponseXML)
     1: {
 97819:   ErrorResult rv;
 94307:   nsIDocument* responseXML = GetResponseXML(rv);
 97819:   if (rv.Failed()) {
 97819:     return rv.ErrorCode();
 97819:   }
 94307: 
 94307:   if (!responseXML) {
106838:     *aResponseXML = nullptr;
 94307:     return NS_OK;
 94307:   }
 94307: 
 94307:   return CallQueryInterface(responseXML, aResponseXML);
 94307: }
 94307: 
 94307: nsIDocument*
 97819: nsXMLHttpRequest::GetResponseXML(ErrorResult& aRv)
 94307: {
 69662:   if (mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT &&
 69662:       mResponseType != XML_HTTP_RESPONSE_TYPE_DOCUMENT) {
 97819:     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
106838:     return nullptr;
     1:   }
 82543:   if (mWarnAboutMultipartHtml) {
 82543:     mWarnAboutMultipartHtml = false;
 92083:     LogMessage("HTMLMultipartXHRWarning", GetOwner());
 82543:   }
 82543:   if (mWarnAboutSyncHtml) {
 82543:     mWarnAboutSyncHtml = false;
 92083:     LogMessage("HTMLSyncXHRWarning", GetOwner());
 82543:   }
106838:   return (XML_HTTP_REQUEST_DONE & mState) ? mResponseXML : nullptr;
     1: }
     1: 
     1: /*
     1:  * This piece copied from nsXMLDocument, we try to get the charset
     1:  * from HTTP headers.
     1:  */
     1: nsresult
 78800: nsXMLHttpRequest::DetectCharset()
     1: {
 78800:   mResponseCharset.Truncate();
106838:   mDecoder = nullptr;
 78800: 
 78800:   if (mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT &&
 78800:       mResponseType != XML_HTTP_RESPONSE_TYPE_TEXT &&
 78801:       mResponseType != XML_HTTP_RESPONSE_TYPE_JSON &&
 78801:       mResponseType != XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT) {
 78800:     return NS_OK;
 78800:   }
 78800: 
 78800:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(mReadRequest);
     1:   if (!channel) {
     1:     channel = mChannel;
 78800:   }
 78800: 
110974:   nsAutoCString charsetVal;
 78800:   nsresult rv = channel ? channel->GetContentCharset(charsetVal) :
 78800:                 NS_ERROR_FAILURE;
     1:   if (NS_SUCCEEDED(rv)) {
 91519:     rv = nsCharsetAlias::GetPreferred(charsetVal, mResponseCharset);
 78800:   }
 78800: 
 78800:   if (NS_FAILED(rv) || mResponseCharset.IsEmpty()) {
 78800:     // MS documentation states UTF-8 is default for responseText
 78800:     mResponseCharset.AssignLiteral("UTF-8");
 78800:   }
 78800: 
 84266:   if (mResponseType == XML_HTTP_RESPONSE_TYPE_JSON &&
 84266:       !mResponseCharset.EqualsLiteral("UTF-8")) {
 84266:     // The XHR spec says only UTF-8 is supported for responseType == "json"
 92083:     LogMessage("JSONCharsetWarning", GetOwner());
 84266:     mResponseCharset.AssignLiteral("UTF-8");
 84266:   }
 84266: 
 78800:   nsCOMPtr<nsICharsetConverterManager> ccm =
 78800:     do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
 78800:   NS_ENSURE_SUCCESS(rv, rv);
 78800: 
 78800:   return ccm->GetUnicodeDecoderRaw(mResponseCharset.get(),
 78800:                                    getter_AddRefs(mDecoder));
     1: }
     1: 
     1: nsresult
 78800: nsXMLHttpRequest::AppendToResponseText(const char * aSrcBuffer,
108991:                                        uint32_t aSrcBufferLen)
     1: {
 78800:   NS_ENSURE_STATE(mDecoder);
 78800: 
108991:   int32_t destBufferLen;
 78800:   nsresult rv = mDecoder->GetMaxLength(aSrcBuffer, aSrcBufferLen,
 78800:                                        &destBufferLen);
 78800:   NS_ENSURE_SUCCESS(rv, rv);
 78800: 
 98259:   if (!mResponseText.SetCapacity(mResponseText.Length() + destBufferLen, fallible_t())) {
 78800:     return NS_ERROR_OUT_OF_MEMORY;
 78800:   }
 78800: 
 78800:   PRUnichar* destBuffer = mResponseText.BeginWriting() + mResponseText.Length();
 78800: 
108991:   int32_t totalChars = mResponseText.Length();
 78800: 
     1:   // This code here is basically a copy of a similar thing in
108991:   // nsScanner::Append(const char* aBuffer, uint32_t aLen).
     1:   // If we get illegal characters in the input we replace
     1:   // them and don't just fail.
     1:   do {
108991:     int32_t srclen = (int32_t)aSrcBufferLen;
108991:     int32_t destlen = (int32_t)destBufferLen;
 78800:     rv = mDecoder->Convert(aSrcBuffer,
 78800:                            &srclen,
 78800:                            destBuffer,
 78800:                            &destlen);
     1:     if (NS_FAILED(rv)) {
     1:       // We consume one byte, replace it with U+FFFD
     1:       // and try the conversion again.
 78800: 
 78800:       destBuffer[destlen] = (PRUnichar)0xFFFD; // add replacement character
 78800:       destlen++; // skip written replacement character
 78800:       destBuffer += destlen;
 78800:       destBufferLen -= destlen;
 78800: 
108991:       if (srclen < (int32_t)aSrcBufferLen) {
 78800:         srclen++; // Consume the invalid character
 78800:       }
 78800:       aSrcBuffer += srclen;
 78800:       aSrcBufferLen -= srclen;
 78800: 
 78800:       mDecoder->Reset();
 78800:     }
 78800: 
 78800:     totalChars += destlen;
 78800: 
 78800:   } while (NS_FAILED(rv) && aSrcBufferLen > 0);
 78800: 
 78800:   mResponseText.SetLength(totalChars);
 78800: 
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute AString responseText; */
 94307: NS_IMETHODIMP
 94307: nsXMLHttpRequest::GetResponseText(nsAString& aResponseText)
 94307: {
 97819:   ErrorResult rv;
 94307:   nsString responseText;
 94307:   GetResponseText(responseText, rv);
 94307:   aResponseText = responseText;
 97819:   return rv.ErrorCode();
 94307: }
 94307: 
 94307: void
 97819: nsXMLHttpRequest::GetResponseText(nsString& aResponseText, ErrorResult& aRv)
     1: {
     1:   aResponseText.Truncate();
     1: 
 69662:   if (mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT &&
 78801:       mResponseType != XML_HTTP_RESPONSE_TYPE_TEXT &&
 78801:       mResponseType != XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT) {
 97819:     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
 94307:     return;
 69662:   }
 69662: 
 78801:   if (mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT &&
 78801:       !mInLoadProgressEvent) {
 80486:     aResponseText.SetIsVoid(true);
 94307:     return;
 78801:   }
 78801: 
 78800:   if (!(mState & (XML_HTTP_REQUEST_DONE | XML_HTTP_REQUEST_LOADING))) {
 94307:     return;
 78800:   }
 78800: 
 78800:   // We only decode text lazily if we're also parsing to a doc.
 78800:   // Also, if we've decoded all current data already, then no need to decode
 78800:   // more.
 82735:   if (!mResponseXML ||
 78800:       mResponseBodyDecodedPos == mResponseBody.Length()) {
 78800:     aResponseText = mResponseText;
 94307:     return;
 94307:   }
 94307: 
 94307:   if (mResponseCharset != mResponseXML->GetDocumentCharacterSet()) {
 94307:     mResponseCharset = mResponseXML->GetDocumentCharacterSet();
 78800:     mResponseText.Truncate();
 78800:     mResponseBodyDecodedPos = 0;
 78800: 
 97819:     nsresult rv;
 78800:     nsCOMPtr<nsICharsetConverterManager> ccm =
 97819:       do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
 97819:     if (NS_FAILED(rv)) {
 97819:       aRv.Throw(rv);
 94307:       return;
 94307:     }
 94307: 
 94307:     aRv = ccm->GetUnicodeDecoderRaw(mResponseCharset.get(),
 78800:                                     getter_AddRefs(mDecoder));
 97819:     if (aRv.Failed()) {
 94307:       return;
 94307:     }
 78800:   }
 78800: 
 78800:   NS_ASSERTION(mResponseBodyDecodedPos < mResponseBody.Length(),
 78800:                "Unexpected mResponseBodyDecodedPos");
 94307:   aRv = AppendToResponseText(mResponseBody.get() + mResponseBodyDecodedPos,
 78800:                              mResponseBody.Length() - mResponseBodyDecodedPos);
 97819:   if (aRv.Failed()) {
 94307:     return;
 94307:   }
 78800: 
 78800:   mResponseBodyDecodedPos = mResponseBody.Length();
 78800:   
 78800:   if (mState & XML_HTTP_REQUEST_DONE) {
 78800:     // Free memory buffer which we no longer need
 78800:     mResponseBody.Truncate();
 78800:     mResponseBodyDecodedPos = 0;
 78800:   }
 78800: 
 78800:   aResponseText = mResponseText;
     1: }
     1: 
 78115: nsresult
 78115: nsXMLHttpRequest::CreateResponseParsedJSON(JSContext* aCx)
 50604: {
 78115:   if (!aCx) {
 50604:     return NS_ERROR_FAILURE;
 78115:   }
107500:   RootJSResultObjects();
107365: 
 84266:   // The Unicode converter has already zapped the BOM if there was one
 78115:   if (!JS_ParseJSON(aCx,
 94307:                     static_cast<const jschar*>(mResponseText.get()),
 78800:                     mResponseText.Length(), &mResultJSON)) {
 78115:     return NS_ERROR_FAILURE;
 78115:   }
 78115: 
 78115:   return NS_OK;
 78115: }
 78115: 
 88536: nsresult
 88536: nsXMLHttpRequest::CreatePartialBlob()
 88536: {
 88536:   if (mDOMFile) {
 88536:     if (mLoadTotal == mLoadTransferred) {
 88536:       mResponseBlob = mDOMFile;
 88536:     } else {
 88536:       mResponseBlob =
 88536:         mDOMFile->CreateSlice(0, mLoadTransferred, EmptyString());
 88536:     }
 88536:     return NS_OK;
 88536:   }
 88536: 
 97346:   // mBuilder can be null if the request has been canceled
 97346:   if (!mBuilder) {
 97346:     return NS_OK;
 97346:   }
 97346: 
110974:   nsAutoCString contentType;
 88536:   if (mLoadTotal == mLoadTransferred) {
 88536:     mChannel->GetContentType(contentType);
 88536:   }
 88536: 
 88536:   return mBuilder->GetBlobInternal(NS_ConvertASCIItoUTF16(contentType),
 88536:                                    false, getter_AddRefs(mResponseBlob));
 88536: }
 88536: 
 69662: /* attribute AString responseType; */
 70067: NS_IMETHODIMP nsXMLHttpRequest::GetResponseType(nsAString& aResponseType)
 69662: {
 69662:   switch (mResponseType) {
 69662:   case XML_HTTP_RESPONSE_TYPE_DEFAULT:
 69662:     aResponseType.Truncate();
 69662:     break;
 69662:   case XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER:
 69662:     aResponseType.AssignLiteral("arraybuffer");
 69662:     break;
 69662:   case XML_HTTP_RESPONSE_TYPE_BLOB:
 69662:     aResponseType.AssignLiteral("blob");
 69662:     break;
 69662:   case XML_HTTP_RESPONSE_TYPE_DOCUMENT:
 69662:     aResponseType.AssignLiteral("document");
 69662:     break;
 69662:   case XML_HTTP_RESPONSE_TYPE_TEXT:
 69662:     aResponseType.AssignLiteral("text");
 69662:     break;
 78115:   case XML_HTTP_RESPONSE_TYPE_JSON:
 84266:     aResponseType.AssignLiteral("json");
 78115:     break;
 78801:   case XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT:
 78801:     aResponseType.AssignLiteral("moz-chunked-text");
 78801:     break;
 78801:   case XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER:
 78801:     aResponseType.AssignLiteral("moz-chunked-arraybuffer");
 78801:     break;
 88536:   case XML_HTTP_RESPONSE_TYPE_MOZ_BLOB:
 88536:     aResponseType.AssignLiteral("moz-blob");
 88536:     break;
 69662:   default:
 69662:     NS_ERROR("Should not happen");
 69662:   }
 69662: 
 69662:   return NS_OK;
 69662: }
 69662: 
 94307: #ifdef DEBUG
 94307: void
 94307: nsXMLHttpRequest::StaticAssertions()
 94307: {
 94307: #define ASSERT_ENUM_EQUAL(_lc, _uc) \
 94307:   MOZ_STATIC_ASSERT(\
 97422:     XMLHttpRequestResponseTypeValues::_lc                \
 97422:     == XMLHttpRequestResponseType(XML_HTTP_RESPONSE_TYPE_ ## _uc), \
 94307:     #_uc " should match")
 94307: 
 94512:   ASSERT_ENUM_EQUAL(_empty, DEFAULT);
102144:   ASSERT_ENUM_EQUAL(Arraybuffer, ARRAYBUFFER);
102144:   ASSERT_ENUM_EQUAL(Blob, BLOB);
102144:   ASSERT_ENUM_EQUAL(Document, DOCUMENT);
102144:   ASSERT_ENUM_EQUAL(Json, JSON);
102144:   ASSERT_ENUM_EQUAL(Text, TEXT);
102144:   ASSERT_ENUM_EQUAL(Moz_chunked_text, CHUNKED_TEXT);
102144:   ASSERT_ENUM_EQUAL(Moz_chunked_arraybuffer, CHUNKED_ARRAYBUFFER);
102144:   ASSERT_ENUM_EQUAL(Moz_blob, MOZ_BLOB);
 94307: #undef ASSERT_ENUM_EQUAL
 94307: }
 94307: #endif
 94307: 
 69662: /* attribute AString responseType; */
 70067: NS_IMETHODIMP nsXMLHttpRequest::SetResponseType(const nsAString& aResponseType)
 69662: {
113697:   nsXMLHttpRequest::ResponseTypeEnum responseType;
 94307:   if (aResponseType.IsEmpty()) {
 94307:     responseType = XML_HTTP_RESPONSE_TYPE_DEFAULT;
 94307:   } else if (aResponseType.EqualsLiteral("arraybuffer")) {
 94307:     responseType = XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER;
 94307:   } else if (aResponseType.EqualsLiteral("blob")) {
 94307:     responseType = XML_HTTP_RESPONSE_TYPE_BLOB;
 94307:   } else if (aResponseType.EqualsLiteral("document")) {
 94307:     responseType = XML_HTTP_RESPONSE_TYPE_DOCUMENT;
 94307:   } else if (aResponseType.EqualsLiteral("text")) {
 94307:     responseType = XML_HTTP_RESPONSE_TYPE_TEXT;
 94307:   } else if (aResponseType.EqualsLiteral("json")) {
 94307:     responseType = XML_HTTP_RESPONSE_TYPE_JSON;
 94307:   } else if (aResponseType.EqualsLiteral("moz-chunked-text")) {
 94307:     responseType = XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT;
 94307:   } else if (aResponseType.EqualsLiteral("moz-chunked-arraybuffer")) {
 94307:     responseType = XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER;
 94307:   } else if (aResponseType.EqualsLiteral("moz-blob")) {
 94307:     responseType = XML_HTTP_RESPONSE_TYPE_MOZ_BLOB;
 94307:   } else {
 94307:     return NS_OK;
 94307:   }
 94307: 
 97819:   ErrorResult rv;
 94307:   SetResponseType(responseType, rv);
 97819:   return rv.ErrorCode();
 94307: }
 94307: 
 94307: void
 94512: nsXMLHttpRequest::SetResponseType(XMLHttpRequestResponseType aType,
 97819:                                   ErrorResult& aRv)
 94512: {
113697:   SetResponseType(ResponseTypeEnum(aType), aRv);
 94512: }
 94512: 
 94512: void
113697: nsXMLHttpRequest::SetResponseType(nsXMLHttpRequest::ResponseTypeEnum aResponseType,
 97819:                                   ErrorResult& aRv)
 94307: {
 69662:   // If the state is not OPENED or HEADERS_RECEIVED raise an
 69662:   // INVALID_STATE_ERR exception and terminate these steps.
 69662:   if (!(mState & (XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT |
 94307:                   XML_HTTP_REQUEST_HEADERS_RECEIVED))) {
 97819:     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
 94307:     return;
 94307:   }
 69662: 
 84264:   // sync request is not allowed setting responseType in window context
 92083:   if (HasOrHasHadOwner() &&
 84264:       !(mState & (XML_HTTP_REQUEST_UNSENT | XML_HTTP_REQUEST_ASYNC))) {
 92083:     LogMessage("ResponseTypeSyncXHRWarning", GetOwner());
 97819:     aRv.Throw(NS_ERROR_DOM_INVALID_ACCESS_ERR);
 94307:     return;
 94307:   }
 94307: 
 94307:   if (!(mState & XML_HTTP_REQUEST_ASYNC) &&
 94307:       (aResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT ||
 94307:        aResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER)) {
 97819:     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
 94307:     return;
 84264:   }
 84264: 
 69662:   // Set the responseType attribute's value to the given value.
 94307:   mResponseType = aResponseType;
 69662: 
 69662:   // If the state is OPENED, SetCacheAsFile would have no effect here
 69662:   // because the channel hasn't initialized the cache entry yet.
 69662:   // SetCacheAsFile will be called from OnStartRequest.
 69662:   // If the state is HEADERS_RECEIVED, however, we need to call
 69662:   // it immediately because OnStartRequest is already dispatched.
 69662:   if (mState & XML_HTTP_REQUEST_HEADERS_RECEIVED) {
 69662:     nsCOMPtr<nsICachingChannel> cc(do_QueryInterface(mChannel));
 69662:     if (cc) {
 88536:       cc->SetCacheAsFile(mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
 88536:                          mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB);
 69662:     }
 69662:   }
 69662: }
 69662: 
 69662: /* readonly attribute jsval response; */
 94307: NS_IMETHODIMP
 94307: nsXMLHttpRequest::GetResponse(JSContext *aCx, jsval *aResult)
 69662: {
 97819:   ErrorResult rv;
 94307:   *aResult = GetResponse(aCx, rv);
 97819:   return rv.ErrorCode();
 94307: }
 94307: 
 94307: JS::Value
 97819: nsXMLHttpRequest::GetResponse(JSContext* aCx, ErrorResult& aRv)
 94307: {
 69662:   switch (mResponseType) {
 69662:   case XML_HTTP_RESPONSE_TYPE_DEFAULT:
 69662:   case XML_HTTP_RESPONSE_TYPE_TEXT:
 78801:   case XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT:
 69662:   {
 69662:     nsString str;
 94307:     aRv = GetResponseText(str);
 97819:     if (aRv.Failed()) {
 94307:       return JSVAL_NULL;
 94307:     }
 94307:     JS::Value result;
 94307:     if (!xpc::StringToJsval(aCx, str, &result)) {
 97819:       aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
 94307:       return JSVAL_NULL;
 94307:     }
 94307:     return result;
 94307:   }
 69662: 
 69662:   case XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER:
 78801:   case XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER:
 94307:   {
 94307:     if (!(mResponseType == XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER &&
 94307:           mState & XML_HTTP_REQUEST_DONE) &&
 94307:         !(mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER &&
 78801:           mInLoadProgressEvent)) {
 94307:       return JSVAL_NULL;
 94307:     }
 94307: 
 70838:     if (!mResultArrayBuffer) {
107500:       RootJSResultObjects();
 94307:       aRv = nsContentUtils::CreateArrayBuffer(aCx, mResponseBody,
 84707:                                               &mResultArrayBuffer);
 97819:       if (aRv.Failed()) {
 94307:         return JSVAL_NULL;
 94307:       }
 94307:     }
 94307:     return OBJECT_TO_JSVAL(mResultArrayBuffer);
 94307:   }
 69662:   case XML_HTTP_RESPONSE_TYPE_BLOB:
 88536:   case XML_HTTP_RESPONSE_TYPE_MOZ_BLOB:
 94307:   {
 94307:     if (!(mState & XML_HTTP_REQUEST_DONE)) {
 94307:       if (mResponseType != XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) {
 94307:         return JSVAL_NULL;
 94307:       }
 94307: 
 88536:       if (!mResponseBlob) {
 94307:         aRv = CreatePartialBlob();
 97819:         if (aRv.Failed()) {
 94307:           return JSVAL_NULL;
 94307:         }
 94307:       }
 94307:     }
 94307: 
 94307:     if (!mResponseBlob) {
 94307:       return JSVAL_NULL;
 94307:     }
 94307: 
 94307:     JS::Value result = JSVAL_NULL;
 80154:     JSObject* scope = JS_GetGlobalForScopeChain(aCx);
 94307:     aRv = nsContentUtils::WrapNative(aCx, scope, mResponseBlob, &result,
106838:                                      nullptr, true);
 94307:     return result;
 94307:   }
 69662:   case XML_HTTP_RESPONSE_TYPE_DOCUMENT:
 94307:   {
 94307:     if (!(mState & XML_HTTP_REQUEST_DONE) || !mResponseXML) {
 94307:       return JSVAL_NULL;
 94307:     }
 94307: 
 80154:     JSObject* scope = JS_GetGlobalForScopeChain(aCx);
 94307:     JS::Value result = JSVAL_NULL;
 94307:     aRv = nsContentUtils::WrapNative(aCx, scope, mResponseXML, &result,
106838:                                      nullptr, true);
 94307:     return result;
 94307:   }
 78115:   case XML_HTTP_RESPONSE_TYPE_JSON:
 94307:   {
 94307:     if (!(mState & XML_HTTP_REQUEST_DONE)) {
 94307:       return JSVAL_NULL;
 94307:     }
 94307: 
 78115:     if (mResultJSON == JSVAL_VOID) {
 94307:       aRv = CreateResponseParsedJSON(aCx);
 78800:       mResponseText.Truncate();
 97819:       if (aRv.Failed()) {
 84266:         // Per spec, errors aren't propagated. null is returned instead.
 94307:         aRv = NS_OK;
 84266:         // It would be nice to log the error to the console. That's hard to
 84266:         // do without calling window.onerror as a side effect, though.
 84266:         JS_ClearPendingException(aCx);
 84266:         mResultJSON = JSVAL_NULL;
 84266:       }
 78115:     }
 94307:     return mResultJSON;
 94307:   }
 69662:   default:
 69662:     NS_ERROR("Should not happen");
 69662:   }
 69662: 
 94307:   return JSVAL_NULL;
 69662: }
 69662: 
     1: /* readonly attribute unsigned long status; */
     1: NS_IMETHODIMP
108991: nsXMLHttpRequest::GetStatus(uint32_t *aStatus)
     1: {
113697:   *aStatus = Status();
 94307:   return NS_OK;
 94307: }
 94307: 
 94307: uint32_t
113697: nsXMLHttpRequest::Status()
 94307: {
 19952:   if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
 19952:     // Make sure we don't leak status information from denied cross-site
 19952:     // requests.
 19952:     if (mChannel) {
 19952:       nsresult status;
 19952:       mChannel->GetStatus(&status);
 19952:       if (NS_FAILED(status)) {
 94307:         return 0;
 19952:       }
 19952:     }
 19952:   }
 19952: 
108991:   uint16_t readyState;
 94034:   GetReadyState(&readyState);
 94034:   if (readyState == UNSENT || readyState == OPENED || mErrorLoad) {
 94307:     return 0;
 94034:   }
 94034: 
     1:   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
 94307:   if (!httpChannel) {
 94307:     return 0;
 94307:   }
 94307: 
108991:   uint32_t status;
 94307:   nsresult rv = httpChannel->GetResponseStatus(&status);
 94034:   if (NS_FAILED(rv)) {
 94307:     status = 0;
 94307:   }
 94307: 
 94307:   return status;
 94307: }
 94307: 
 94307: IMPL_STRING_GETTER(GetStatusText)
 94307: void
 94307: nsXMLHttpRequest::GetStatusText(nsString& aStatusText)
     1: {
     1:   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
     1: 
     1:   aStatusText.Truncate();
     1: 
 94307:   if (!httpChannel) {
 94307:     return;
 94307:   }
 94307: 
 39491:   if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
 39491:     // Make sure we don't leak status information from denied cross-site
 39491:     // requests.
 39491:     if (mChannel) {
 39491:       nsresult status;
 39491:       mChannel->GetStatus(&status);
 39491:       if (NS_FAILED(status)) {
 94307:         return;
 94307:       }
 94307:     }
 94307:   }
 94307: 
 94307:   nsCString statusText;
 94307:   httpChannel->GetResponseStatusText(statusText);
 94307:   if (statusText.IsVoid()) {
 94307:     aStatusText.SetIsVoid(true);
 94307:   } else {
 94307:     // We use UTF8ToNewUnicode here because it truncates after invalid UTF-8
 94307:     // characters, CopyUTF8toUTF16 just doesn't copy in that case.
108991:     uint32_t length;
 94307:     PRUnichar* chars = UTF8ToNewUnicode(statusText, &length);
 94307:     aStatusText.Adopt(chars, length);
 94307:   }
     1: }
     1: 
 88284: void
 88284: nsXMLHttpRequest::CloseRequestWithError(const nsAString& aType,
108991:                                         const uint32_t aFlag)
     1: {
     1:   if (mReadRequest) {
     1:     mReadRequest->Cancel(NS_BINDING_ABORTED);
     1:   }
     1:   if (mChannel) {
     1:     mChannel->Cancel(NS_BINDING_ABORTED);
     1:   }
 64070:   if (mCORSPreflightChannel) {
 64070:     mCORSPreflightChannel->Cancel(NS_BINDING_ABORTED);
 19951:   }
 88284:   if (mTimeoutTimer) {
 88284:     mTimeoutTimer->Cancel();
 88284:   }
108991:   uint32_t responseLength = mResponseBody.Length();
 78799:   ResetResponse();
 88284:   mState |= aFlag;
     1: 
 90101:   // If we're in the destructor, don't risk dispatching an event.
 90516:   if (mState & XML_HTTP_REQUEST_DELETED) {
 90516:     mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
 90101:     return;
 90516:   }
 90101: 
 69662:   if (!(mState & (XML_HTTP_REQUEST_UNSENT |
 11304:                   XML_HTTP_REQUEST_OPENED |
 69662:                   XML_HTTP_REQUEST_DONE))) {
 80486:     ChangeState(XML_HTTP_REQUEST_DONE, true);
     1: 
 16665:     if (!(mState & XML_HTTP_REQUEST_SYNCLOOPING)) {
 88284:       DispatchProgressEvent(this, aType, mLoadLengthComputable, responseLength,
 20640:                             mLoadTotal);
 16665:       if (mUpload && !mUploadComplete) {
 80486:         mUploadComplete = true;
 88284:         DispatchProgressEvent(mUpload, aType, true, mUploadTransferred,
 16665:                               mUploadTotal);
 16665:       }
 16665:     }
 82572:   }
 16665: 
     1:   // The ChangeState call above calls onreadystatechange handlers which
 64068:   // if they load a new url will cause nsXMLHttpRequest::Open to clear
     1:   // the abort state bit. If this occurs we're not uninitialized (bug 361773).
     1:   if (mState & XML_HTTP_REQUEST_ABORTED) {
 80486:     ChangeState(XML_HTTP_REQUEST_UNSENT, false);  // IE seems to do it
     1:   }
     1: 
 18378:   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
 88284: }
 88284: 
 88284: /* void abort (); */
 94307: void
 88284: nsXMLHttpRequest::Abort()
 88284: {
 88284:   CloseRequestWithError(NS_LITERAL_STRING(ABORT_STR), XML_HTTP_REQUEST_ABORTED);
 94307: }
 94307: 
 94307: NS_IMETHODIMP
 94307: nsXMLHttpRequest::SlowAbort()
 94307: {
 94307:   Abort();
     1:   return NS_OK;
     1: }
     1: 
 90481: /* DOMString getAllResponseHeaders(); */
 94307: IMPL_STRING_GETTER(GetAllResponseHeaders)
 94307: void
 94307: nsXMLHttpRequest::GetAllResponseHeaders(nsString& aResponseHeaders)
     1: {
 90481:   aResponseHeaders.Truncate();
     1: 
 90450:   // If the state is UNSENT or OPENED,
 90450:   // return the empty string and terminate these steps.
 90450:   if (mState & (XML_HTTP_REQUEST_UNSENT |
 90450:                 XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT)) {
 94307:     return;
 90450:   }
 90450: 
 19951:   if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
 94307:     return;
 19951:   }
 19951: 
 90481:   if (nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel()) {
 57364:     nsRefPtr<nsHeaderVisitor> visitor = new nsHeaderVisitor();
 90481:     if (NS_SUCCEEDED(httpChannel->VisitResponseHeaders(visitor))) {
 94307:       CopyASCIItoUTF16(visitor->Headers(), aResponseHeaders);
 94307:     }
 94307:     return;
 90481:   }
 90481: 
 90481:   if (!mChannel) {
 94307:     return;
 90481:   }
 90481: 
 90450:   // Even non-http channels supply content type.
110974:   nsAutoCString value;
 90450:   if (NS_SUCCEEDED(mChannel->GetContentType(value))) {
 90481:     aResponseHeaders.AppendLiteral("Content-Type: ");
 94307:     AppendASCIItoUTF16(value, aResponseHeaders);
 94307:     if (NS_SUCCEEDED(mChannel->GetContentCharset(value)) && !value.IsEmpty()) {
 90481:       aResponseHeaders.AppendLiteral(";charset=");
 94307:       AppendASCIItoUTF16(value, aResponseHeaders);
 90481:     }
106577:     aResponseHeaders.AppendLiteral("\r\n");
 90481:   }
110480: 
110653:   int32_t length;
110480:   if (NS_SUCCEEDED(mChannel->GetContentLength(&length))) {
110480:     aResponseHeaders.AppendLiteral("Content-Length: ");
110480:     aResponseHeaders.AppendInt(length);
110480:     aResponseHeaders.AppendLiteral("\r\n");
110480:   }
 94307: }
 94307: 
     1: NS_IMETHODIMP
 94307: nsXMLHttpRequest::GetResponseHeader(const nsACString& aHeader,
 94307:                                     nsACString& aResult)
     1: {
 97819:   ErrorResult rv;
 94307:   GetResponseHeader(aHeader, aResult, rv);
 97819:   return rv.ErrorCode();
 94307: }
 94307: 
 94307: void
 94307: nsXMLHttpRequest::GetResponseHeader(const nsACString& header,
 97819:                                     nsACString& _retval, ErrorResult& aRv)
 94307: {
 80486:   _retval.SetIsVoid(true);
 54923: 
 54923:   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
 54923: 
 54923:   if (!httpChannel) {
 90450:     // If the state is UNSENT or OPENED,
 90450:     // return null and terminate these steps.
 90450:     if (mState & (XML_HTTP_REQUEST_UNSENT |
 90450:                   XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT)) {
 94307:       return;
 90450:     }
 90450: 
110480:     // Even non-http channels supply content type and content length.
 90450:     // Remember we don't leak header information from denied cross-site
 90450:     // requests.
 90450:     nsresult status;
 90450:     if (!mChannel ||
 90450:         NS_FAILED(mChannel->GetStatus(&status)) ||
110480:         NS_FAILED(status)) {
 94307:       return;
 90450:     }
 90450: 
110480:     // Content Type:
110480:     if (header.LowerCaseEqualsASCII("content-type")) {
 90450:       if (NS_FAILED(mChannel->GetContentType(_retval))) {
 90450:         // Means no content type
 90450:         _retval.SetIsVoid(true);
 94307:         return;
 90450:       }
 90450: 
 90450:       nsCString value;
 90450:       if (NS_SUCCEEDED(mChannel->GetContentCharset(value)) &&
 90450:           !value.IsEmpty()) {
 90450:         _retval.Append(";charset=");
 90450:         _retval.Append(value);
 90450:       }
110480:     }
110480: 
110480:     // Content Length:
110480:     else if (header.LowerCaseEqualsASCII("content-length")) {
110653:       int32_t length;
110480:       if (NS_SUCCEEDED(mChannel->GetContentLength(&length))) {
110480:         _retval.AppendInt(length);
110480:       }
110480:     }
 90450: 
 94307:     return;
 54923:   }
     1: 
 21639:   // See bug #380418. Hide "Set-Cookie" headers from non-chrome scripts.
 79445:   bool chrome = false; // default to false in case IsCapabilityEnabled fails
 21639:   IsCapabilityEnabled("UniversalXPConnect", &chrome);
 21639:   if (!chrome &&
 21639:        (header.LowerCaseEqualsASCII("set-cookie") ||
 21639:         header.LowerCaseEqualsASCII("set-cookie2"))) {
 21639:     NS_WARNING("blocked access to response header");
 94307:     return;
 21639:   }
 21639: 
 19951:   // Check for dangerous headers
 19951:   if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
 19951:     // Make sure we don't leak header information from denied cross-site
 19951:     // requests.
 19951:     if (mChannel) {
 19951:       nsresult status;
 19951:       mChannel->GetStatus(&status);
 19951:       if (NS_FAILED(status)) {
 94307:         return;
 19951:       }
 19951:     }
 19951: 
 19951:     const char *kCrossOriginSafeHeaders[] = {
 19951:       "cache-control", "content-language", "content-type", "expires",
 19951:       "last-modified", "pragma"
 19951:     };
 79445:     bool safeHeader = false;
108991:     uint32_t i;
 80467:     for (i = 0; i < ArrayLength(kCrossOriginSafeHeaders); ++i) {
 19951:       if (header.LowerCaseEqualsASCII(kCrossOriginSafeHeaders[i])) {
 80486:         safeHeader = true;
 19951:         break;
 19951:       }
 19951:     }
 19951: 
 19951:     if (!safeHeader) {
110974:       nsAutoCString headerVal;
 54923:       // The "Access-Control-Expose-Headers" header contains a comma separated
 54923:       // list of method names.
 54923:       httpChannel->
 54923:         GetResponseHeader(NS_LITERAL_CSTRING("Access-Control-Expose-Headers"),
 54923:                           headerVal);
 54923:       nsCCharSeparatedTokenizer exposeTokens(headerVal, ',');
 54923:       while(exposeTokens.hasMoreTokens()) {
 54923:         const nsDependentCSubstring& token = exposeTokens.nextToken();
 54923:         if (token.IsEmpty()) {
 54923:           continue;
 54923:         }
 54923:         if (!IsValidHTTPToken(token)) {
 94307:           return;
 19951:         }
 54923:         if (header.Equals(token, nsCaseInsensitiveCStringComparator())) {
 80486:           safeHeader = true;
 54923:         }
 54923:       }
 54923:     }
 54923: 
 54923:     if (!safeHeader) {
 94307:       return;
 94307:     }
 94307:   }
 94307: 
 94307:   aRv = httpChannel->GetResponseHeader(header, _retval);
 97819:   if (aRv.ErrorCode() == NS_ERROR_NOT_AVAILABLE) {
     1:     // Means no header
 80486:     _retval.SetIsVoid(true);
 94307:     aRv = NS_OK;
 94307:   }
     1: }
     1: 
 77186: already_AddRefed<nsILoadGroup>
 77186: nsXMLHttpRequest::GetLoadGroup() const
 20560: {
 20560:   if (mState & XML_HTTP_REQUEST_BACKGROUND) {                 
106838:     return nullptr;
 20560:   }
 20560: 
 92083:   nsresult rv = NS_ERROR_FAILURE;
 92083:   nsIScriptContext* sc =
 92083:     const_cast<nsXMLHttpRequest*>(this)->GetContextForEventHandlers(&rv);
 29226:   nsCOMPtr<nsIDocument> doc =
 92083:     nsContentUtils::GetDocumentFromScriptContext(sc);
 20560:   if (doc) {
 77186:     return doc->GetDocumentLoadGroup();
 77186:   }
 77186: 
106838:   return nullptr;
 20560: }
 20560: 
 20560: nsresult
 16665: nsXMLHttpRequest::CreateReadystatechangeEvent(nsIDOMEvent** aDOMEvent)
     1: {
106838:   nsresult rv = nsEventDispatcher::CreateEvent(nullptr, nullptr,
     1:                                                NS_LITERAL_STRING("Events"),
     1:                                                aDOMEvent);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
 16665:   (*aDOMEvent)->InitEvent(NS_LITERAL_STRING(READYSTATE_STR),
 80486:                           false, false);
 16665: 
 16665:   // We assume anyone who managed to call CreateReadystatechangeEvent is trusted
101616:   (*aDOMEvent)->SetTrusted(true);
 16665: 
 16665:   return NS_OK;
     1: }
     1: 
 16665: void
 72322: nsXMLHttpRequest::DispatchProgressEvent(nsDOMEventTargetHelper* aTarget,
 16665:                                         const nsAString& aType,
 79445:                                         bool aUseLSEventWrapper,
 79445:                                         bool aLengthComputable,
108991:                                         uint64_t aLoaded, uint64_t aTotal,
108991:                                         uint64_t aPosition, uint64_t aTotalSize)
 16665: {
 19953:   NS_ASSERTION(aTarget, "null target");
 78799:   NS_ASSERTION(!aType.IsEmpty(), "missing event type");
 78799: 
 78799:   if (NS_FAILED(CheckInnerWindowCorrectness()) ||
106062:       (!AllowUploadProgress() && aTarget == mUpload)) {
 16665:     return;
 16665:   }
 16665: 
 79445:   bool dispatchLoadend = aType.EqualsLiteral(LOAD_STR) ||
 63715:                            aType.EqualsLiteral(ERROR_STR) ||
 88284:                            aType.EqualsLiteral(TIMEOUT_STR) ||
 63715:                            aType.EqualsLiteral(ABORT_STR);
 63715:   
 16665:   nsCOMPtr<nsIDOMEvent> event;
106838:   nsresult rv = nsEventDispatcher::CreateEvent(nullptr, nullptr,
 16665:                                                NS_LITERAL_STRING("ProgressEvent"),
 16665:                                                getter_AddRefs(event));
 16665:   if (NS_FAILED(rv)) {
 16665:     return;
 16665:   }
 16665: 
101616:   event->SetTrusted(true);
     1: 
 16665:   nsCOMPtr<nsIDOMProgressEvent> progress = do_QueryInterface(event);
 16665:   if (!progress) {
 16665:     return;
 16665:   }
 16665: 
 80486:   progress->InitProgressEvent(aType, false, false, aLengthComputable,
 16665:                               aLoaded, (aTotal == LL_MAXUINT) ? 0 : aTotal);
 16665: 
 16665:   if (aUseLSEventWrapper) {
 16665:     nsCOMPtr<nsIDOMProgressEvent> xhrprogressEvent =
 92083:       new nsXMLHttpProgressEvent(progress, aPosition, aTotalSize, GetOwner());
 16665:     event = xhrprogressEvent;
 16665:   }
106838:   aTarget->DispatchDOMEvent(nullptr, event, nullptr, nullptr);
 63715:   
 63715:   if (dispatchLoadend) {
 63715:     DispatchProgressEvent(aTarget, NS_LITERAL_STRING(LOADEND_STR),
 63715:                           aUseLSEventWrapper, aLengthComputable,
 63715:                           aLoaded, aTotal, aPosition, aTotalSize);
 63715:   }
     1: }
     1:                                           
     1: already_AddRefed<nsIHttpChannel>
     1: nsXMLHttpRequest::GetCurrentHttpChannel()
     1: {
106838:   nsIHttpChannel *httpChannel = nullptr;
     1: 
     1:   if (mReadRequest) {
     1:     CallQueryInterface(mReadRequest, &httpChannel);
     1:   }
     1: 
     1:   if (!httpChannel && mChannel) {
     1:     CallQueryInterface(mChannel, &httpChannel);
     1:   }
     1: 
     1:   return httpChannel;
     1: }
     1: 
 75263: bool
 75263: nsXMLHttpRequest::IsSystemXHR()
 75263: {
101616:   return mIsSystem || nsContentUtils::IsSystemPrincipal(mPrincipal);
 75263: }
 75263: 
 19951: nsresult
 19951: nsXMLHttpRequest::CheckChannelForCrossSiteRequest(nsIChannel* aChannel)
 19951: {
 63932:   // First check if cross-site requests are enabled...
 63932:   if (IsSystemXHR()) {
 43831:     return NS_OK;
 43831:   }
 43831: 
108824:   // If this is a same-origin request or the channel's URI inherits
108824:   // its principal, it's allowed.
108824:   if (nsContentUtils::CheckMayLoad(mPrincipal, aChannel, true)) {
 87071:     return NS_OK;
 87071:   }
 87071: 
 19951:   // This is a cross-site request
 19951:   mState |= XML_HTTP_REQUEST_USE_XSITE_AC;
 19951: 
 25455:   // Check if we need to do a preflight request.
 25455:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aChannel);
 25455:   NS_ENSURE_TRUE(httpChannel, NS_ERROR_DOM_BAD_URI);
 25455: 
110974:   nsAutoCString method;
 25455:   httpChannel->GetRequestMethod(method);
 64070:   if (!mCORSUnsafeHeaders.IsEmpty() ||
 54922:       (mUpload && mUpload->HasListeners()) ||
 54922:       (!method.LowerCaseEqualsLiteral("get") &&
 54922:        !method.LowerCaseEqualsLiteral("post") &&
 54922:        !method.LowerCaseEqualsLiteral("head"))) {
 25455:     mState |= XML_HTTP_REQUEST_NEED_AC_PREFLIGHT;
 25455:   }
 25455: 
 19951:   return NS_OK;
 19951: }
 19951: 
     1: NS_IMETHODIMP
 64068: nsXMLHttpRequest::Open(const nsACString& method, const nsACString& url,
 79445:                        bool async, const nsAString& user,
108991:                        const nsAString& password, uint8_t optional_argc)
     1: {
 64068:   if (!optional_argc) {
 64068:     // No optional arguments were passed in. Default async to true.
 80486:     async = true;
 64068:   }
 99738:   Optional<nsAString> realUser;
 99738:   if (optional_argc > 1) {
 99738:     realUser = &user;
 99738:   }
 99738:   Optional<nsAString> realPassword;
 99738:   if (optional_argc > 2) {
 99738:     realPassword = &password;
 99738:   }
 99738:   return Open(method, url, async, realUser, realPassword);
 94307: }
 94307: 
 94307: nsresult
 94307: nsXMLHttpRequest::Open(const nsACString& method, const nsACString& url,
 99738:                        bool async, const Optional<nsAString>& user,
 99738:                        const Optional<nsAString>& password)
 94307: {
 94307:   NS_ENSURE_ARG(!method.IsEmpty());
 94307: 
 82487:   Telemetry::Accumulate(Telemetry::XMLHTTPREQUEST_ASYNC_OR_SYNC,
 82487:                         async ? 0 : 1);
 64068: 
 11887:   NS_ENSURE_TRUE(mPrincipal, NS_ERROR_NOT_INITIALIZED);
 11887: 
  2795:   // Disallow HTTP/1.1 TRACE method (see bug 302489)
  2795:   // and MS IIS equivalent TRACK (see bug 381264)
  4064:   if (method.LowerCaseEqualsLiteral("trace") ||
  4064:       method.LowerCaseEqualsLiteral("track")) {
     1:     return NS_ERROR_INVALID_ARG;
     1:   }
     1: 
 84264:   // sync request is not allowed using withCredential or responseType
 84264:   // in window context
 92083:   if (!async && HasOrHasHadOwner() &&
 84264:       (mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS ||
 88284:        mTimeoutMilliseconds ||
 84264:        mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT)) {
 84264:     if (mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS) {
 92083:       LogMessage("WithCredentialsSyncXHRWarning", GetOwner());
 84264:     }
 88284:     if (mTimeoutMilliseconds) {
 92083:       LogMessage("TimeoutSyncXHRWarning", GetOwner());
 88284:     }
 84264:     if (mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT) {
 92083:       LogMessage("ResponseTypeSyncXHRWarning", GetOwner());
 84264:     }
 84264:     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
 84264:   }
 84264: 
     1:   nsresult rv;
     1:   nsCOMPtr<nsIURI> uri;
     1: 
  8067:   if (mState & (XML_HTTP_REQUEST_OPENED |
 69662:                 XML_HTTP_REQUEST_HEADERS_RECEIVED |
 69662:                 XML_HTTP_REQUEST_LOADING |
     1:                 XML_HTTP_REQUEST_SENT |
     1:                 XML_HTTP_REQUEST_STOPPED)) {
     1:     // IE aborts as well
     1:     Abort();
     1: 
     1:     // XXX We should probably send a warning to the JS console
     1:     //     that load was aborted and event listeners were cleared
     1:     //     since this looks like a situation that could happen
     1:     //     by accident and you could spend a lot of time wondering
     1:     //     why things didn't work.
  8067:   }
  8067: 
 88284:   // Unset any pre-existing aborted and timed-out states.
 88284:   mState &= ~XML_HTTP_REQUEST_ABORTED & ~XML_HTTP_REQUEST_TIMED_OUT;
     1: 
     1:   if (async) {
     1:     mState |= XML_HTTP_REQUEST_ASYNC;
     1:   } else {
     1:     mState &= ~XML_HTTP_REQUEST_ASYNC;
     1:   }
     1: 
 19152:   mState &= ~XML_HTTP_REQUEST_MPART_HEADERS;
 19152: 
 92083:   nsIScriptContext* sc = GetContextForEventHandlers(&rv);
 92083:   NS_ENSURE_SUCCESS(rv, rv);
 29226:   nsCOMPtr<nsIDocument> doc =
 92083:     nsContentUtils::GetDocumentFromScriptContext(sc);
 20331:   
 20331:   nsCOMPtr<nsIURI> baseURI;
 23201:   if (mBaseURI) {
 23201:     baseURI = mBaseURI;
 23201:   }
 23201:   else if (doc) {
 20331:     baseURI = doc->GetBaseURI();
 20331:   }
 20331: 
106838:   rv = NS_NewURI(getter_AddRefs(uri), url, nullptr, baseURI);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
  8947:   rv = CheckInnerWindowCorrectness();
  8947:   NS_ENSURE_SUCCESS(rv, rv);
108991:   int16_t shouldLoad = nsIContentPolicy::ACCEPT;
  2501:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_XMLHTTPREQUEST,
    68:                                  uri,
  8947:                                  mPrincipal,
    68:                                  doc,
    68:                                  EmptyCString(), //mime guess
106838:                                  nullptr,         //extra
  4367:                                  &shouldLoad,
  4367:                                  nsContentUtils::GetContentPolicy(),
  4367:                                  nsContentUtils::GetSecurityManager());
    68:   if (NS_FAILED(rv)) return rv;
    68:   if (NS_CP_REJECTED(shouldLoad)) {
    68:     // Disallowed by content policy
    68:     return NS_ERROR_CONTENT_BLOCKED;
    68:   }
    68: 
 99738:   // XXXbz this is wrong: we should only be looking at whether
 99738:   // user/password were passed, not at the values!  See bug 759624.
 99738:   if (user.WasPassed() && !user.Value().IsEmpty()) {
110974:     nsAutoCString userpass;
 99738:     CopyUTF16toUTF8(user.Value(), userpass);
 99738:     if (password.WasPassed() && !password.Value().IsEmpty()) {
     1:       userpass.Append(':');
 99738:       AppendUTF16toUTF8(password.Value(), userpass);
     1:     }
     1:     uri->SetUserPass(userpass);
     1:   }
     1: 
 20560:   // When we are called from JS we can find the load group for the page,
 20560:   // and add ourselves to it. This way any pending requests
 20560:   // will be automatically aborted if the user leaves the page.
 77186:   nsCOMPtr<nsILoadGroup> loadGroup = GetLoadGroup();
     1: 
 41212:   // get Content Security Policy from principal to pass into channel
 41212:   nsCOMPtr<nsIChannelPolicy> channelPolicy;
 41212:   nsCOMPtr<nsIContentSecurityPolicy> csp;
 41350:   rv = mPrincipal->GetCsp(getter_AddRefs(csp));
 41350:   NS_ENSURE_SUCCESS(rv, rv);
 41212:   if (csp) {
 41212:     channelPolicy = do_CreateInstance("@mozilla.org/nschannelpolicy;1");
 41212:     channelPolicy->SetContentSecurityPolicy(csp);
 41212:     channelPolicy->SetLoadType(nsIContentPolicy::TYPE_XMLHTTPREQUEST);
 41212:   }
 41212:   rv = NS_NewChannel(getter_AddRefs(mChannel),
 41212:                      uri,
106838:                      nullptr,                    // ioService
 41212:                      loadGroup,
106838:                      nullptr,                    // callbacks
 52200:                      nsIRequest::LOAD_BACKGROUND,
 41212:                      channelPolicy);
 20560:   if (NS_FAILED(rv)) return rv;
     1: 
 25455:   mState &= ~(XML_HTTP_REQUEST_USE_XSITE_AC |
 25455:               XML_HTTP_REQUEST_NEED_AC_PREFLIGHT);
 25455: 
     1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
     1:   if (httpChannel) {
     1:     rv = httpChannel->SetRequestMethod(method);
  4064:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   ChangeState(XML_HTTP_REQUEST_OPENED);
     1: 
     1:   return rv;
     1: }
     1: 
     1: /*
     1:  * "Copy" from a stream.
     1:  */
     1: NS_METHOD
     1: nsXMLHttpRequest::StreamReaderFunc(nsIInputStream* in,
     1:                                    void* closure,
     1:                                    const char* fromRawSegment,
108991:                                    uint32_t toOffset,
108991:                                    uint32_t count,
108991:                                    uint32_t *writeCount)
     1: {
  3233:   nsXMLHttpRequest* xmlHttpRequest = static_cast<nsXMLHttpRequest*>(closure);
     1:   if (!xmlHttpRequest || !writeCount) {
     1:     NS_WARNING("XMLHttpRequest cannot read from stream: no closure or writeCount");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 88536:   nsresult rv = NS_OK;
 88536: 
 88536:   if (xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
 88536:       xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) {
 88536:     if (!xmlHttpRequest->mDOMFile) {
 88536:       if (!xmlHttpRequest->mBuilder) {
 88536:         xmlHttpRequest->mBuilder = new nsDOMBlobBuilder();
 88536:       }
 88536:       rv = xmlHttpRequest->mBuilder->AppendVoidPtr(fromRawSegment, count);
 88536:     }
 88536:     // Clear the cache so that the blob size is updated.
 88536:     if (xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) {
106838:       xmlHttpRequest->mResponseBlob = nullptr;
 88536:     }
 88536:     if (NS_SUCCEEDED(rv)) {
 69662:       *writeCount = count;
 88536:     }
 88536:     return rv;
 69662:   }
 69662: 
 78800:   if ((xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_DEFAULT &&
 78800:        xmlHttpRequest->mResponseXML) ||
 78800:       xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER ||
 78801:       xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER) {
     1:     // Copy for our own use
108991:     uint32_t previousLength = xmlHttpRequest->mResponseBody.Length();
     1:     xmlHttpRequest->mResponseBody.Append(fromRawSegment,count);
 69662:     if (count > 0 && xmlHttpRequest->mResponseBody.Length() == previousLength) {
 69662:       return NS_ERROR_OUT_OF_MEMORY;
 69662:     }
 78801:   } else if (xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_DEFAULT ||
 78800:              xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_TEXT ||
 78801:              xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_JSON ||
 78801:              xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT) {
 78800:     NS_ASSERTION(!xmlHttpRequest->mResponseXML,
 78800:                  "We shouldn't be parsing a doc here");
 78800:     xmlHttpRequest->AppendToResponseText(fromRawSegment, count);
 69662:   }
     1: 
     1:   if (xmlHttpRequest->mState & XML_HTTP_REQUEST_PARSEBODY) {
     1:     // Give the same data to the parser.
     1: 
     1:     // We need to wrap the data in a new lightweight stream and pass that
     1:     // to the parser, because calling ReadSegments() recursively on the same
     1:     // stream is not supported.
     1:     nsCOMPtr<nsIInputStream> copyStream;
     1:     rv = NS_NewByteInputStream(getter_AddRefs(copyStream), fromRawSegment, count);
     1: 
 29232:     if (NS_SUCCEEDED(rv) && xmlHttpRequest->mXMLParserStreamListener) {
     1:       NS_ASSERTION(copyStream, "NS_NewByteInputStream lied");
     1:       nsresult parsingResult = xmlHttpRequest->mXMLParserStreamListener
     1:                                   ->OnDataAvailable(xmlHttpRequest->mReadRequest,
     1:                                                     xmlHttpRequest->mContext,
     1:                                                     copyStream, toOffset, count);
     1: 
     1:       // No use to continue parsing if we failed here, but we
     1:       // should still finish reading the stream
     1:       if (NS_FAILED(parsingResult)) {
     1:         xmlHttpRequest->mState &= ~XML_HTTP_REQUEST_PARSEBODY;
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (NS_SUCCEEDED(rv)) {
     1:     *writeCount = count;
     1:   } else {
     1:     *writeCount = 0;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
 88536: bool nsXMLHttpRequest::CreateDOMFile(nsIRequest *request)
 69662: {
 69662:   nsCOMPtr<nsIFile> file;
 69662:   nsCOMPtr<nsICachingChannel> cc(do_QueryInterface(request));
 69662:   if (cc) {
 69662:     cc->GetCacheFile(getter_AddRefs(file));
 69662:   } else {
 69662:     nsCOMPtr<nsIFileChannel> fc = do_QueryInterface(request);
 69662:     if (fc) {
 69662:       fc->GetFile(getter_AddRefs(file));
 69662:     }
 69662:   }
 80889:   bool fromFile = false;
 69662:   if (file) {
110974:     nsAutoCString contentType;
 69662:     mChannel->GetContentType(contentType);
 72855:     nsCOMPtr<nsISupports> cacheToken;
 72855:     if (cc) {
 72855:       cc->GetCacheToken(getter_AddRefs(cacheToken));
 80889:       // We need to call IsFromCache to determine whether the response is
 80889:       // fully cached (i.e. whether we can skip reading the response).
 80889:       cc->IsFromCache(&fromFile);
 80889:     } else {
 80889:       // If the response is coming from the local resource, we can skip
 80889:       // reading the response unconditionally.
 80889:       fromFile = true;
 72855:     }
 72856: 
 88536:     mDOMFile =
 73691:       new nsDOMFileFile(file, NS_ConvertASCIItoUTF16(contentType), cacheToken);
106838:     mBuilder = nullptr;
 88536:     NS_ASSERTION(mResponseBody.IsEmpty(), "mResponseBody should be empty");
 69662:   }
 80889:   return fromFile;
 69662: }
 69662: 
     1: NS_IMETHODIMP
 78799: nsXMLHttpRequest::OnDataAvailable(nsIRequest *request,
 78799:                                   nsISupports *ctxt,
 78799:                                   nsIInputStream *inStr,
111234:                                   uint64_t sourceOffset,
108991:                                   uint32_t count)
     1: {
     1:   NS_ENSURE_ARG_POINTER(inStr);
     1: 
     1:   NS_ABORT_IF_FALSE(mContext.get() == ctxt,"start context different from OnDataAvailable context");
     1: 
 80889:   mProgressSinceLastProgressEvent = true;
 80889: 
 81017:   bool cancelable = false;
 88536:   if ((mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
 88536:        mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) && !mDOMFile) {
 88536:     cancelable = CreateDOMFile(request);
 81017:     // The nsIStreamListener contract mandates us
 81017:     // to read from the stream before returning.
 81017:   }
 81017: 
108991:   uint32_t totalRead;
 81017:   nsresult rv = inStr->ReadSegments(nsXMLHttpRequest::StreamReaderFunc,
 81017:                                     (void*)this, count, &totalRead);
 81017:   NS_ENSURE_SUCCESS(rv, rv);
 81017: 
 81017:   if (cancelable) {
 80889:     // We don't have to read from the local file for the blob response
 88536:     mDOMFile->GetSize(&mLoadTransferred);
 80889:     ChangeState(XML_HTTP_REQUEST_LOADING);
 80889:     return request->Cancel(NS_OK);
 80889:   }
 78799: 
 78799:   mLoadTransferred += totalRead;
 78799: 
 78799:   ChangeState(XML_HTTP_REQUEST_LOADING);
 78799:   
 80486:   MaybeDispatchProgressEvents(false);
 78799: 
 78799:   return NS_OK;
     1: }
     1: 
 79445: bool
  5746: IsSameOrBaseChannel(nsIRequest* aPossibleBase, nsIChannel* aChannel)
  5746: {
  5746:   nsCOMPtr<nsIMultiPartChannel> mpChannel = do_QueryInterface(aPossibleBase);
  5746:   if (mpChannel) {
  5746:     nsCOMPtr<nsIChannel> baseChannel;
  5746:     nsresult rv = mpChannel->GetBaseChannel(getter_AddRefs(baseChannel));
 80486:     NS_ENSURE_SUCCESS(rv, false);
  5746:     
  5746:     return baseChannel == aChannel;
  5746:   }
  5746: 
  5746:   return aPossibleBase == aChannel;
  5746: }
  5746: 
     1: /* void onStartRequest (in nsIRequest request, in nsISupports ctxt); */
     1: NS_IMETHODIMP
     1: nsXMLHttpRequest::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
     1: {
 88104:   SAMPLE_LABEL("nsXMLHttpRequest", "OnStartRequest");
 20640:   nsresult rv = NS_OK;
 19944:   if (!mFirstStartRequestSeen && mRequestObserver) {
 80486:     mFirstStartRequestSeen = true;
 19944:     mRequestObserver->OnStartRequest(request, ctxt);
 19944:   }
 19944: 
  5746:   if (!IsSameOrBaseChannel(request, mChannel)) {
  5746:     return NS_OK;
  5746:   }
  5746: 
     1:   // Don't do anything if we have been aborted
 69662:   if (mState & XML_HTTP_REQUEST_UNSENT)
     1:     return NS_OK;
     1: 
 88284:   /* Apparently, Abort() should set XML_HTTP_REQUEST_UNSENT.  See bug 361773.
 88284:      XHR2 spec says this is correct. */
     1:   if (mState & XML_HTTP_REQUEST_ABORTED) {
     1:     NS_ERROR("Ugh, still getting data on an aborted XMLHttpRequest!");
     1: 
     1:     return NS_ERROR_UNEXPECTED;
     1:   }
     1: 
 88284:   // Don't do anything if we have timed out.
 88284:   if (mState & XML_HTTP_REQUEST_TIMED_OUT) {
 88284:     return NS_OK;
 88284:   }
 88284: 
     1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
     1:   NS_ENSURE_TRUE(channel, NS_ERROR_UNEXPECTED);
     1: 
 63932:   nsCOMPtr<nsIPrincipal> documentPrincipal;
 63932:   if (IsSystemXHR()) {
 13653:     // Don't give this document the system principal.  We need to keep track of
 13653:     // mPrincipal being system because we use it for various security checks
 13653:     // that should be passing, but the document data shouldn't get a system
 13653:     // principal.
 13653:     nsresult rv;
 13653:     documentPrincipal = do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
 13653:     NS_ENSURE_SUCCESS(rv, rv);
 63932:   } else {
 63932:     documentPrincipal = mPrincipal;
 13653:   }
 13653: 
 13653:   channel->SetOwner(documentPrincipal);
  3028: 
 78799:   nsresult status;
 78799:   request->GetStatus(&status);
 78799:   mErrorLoad = mErrorLoad || NS_FAILED(status);
 78799: 
 78799:   if (mUpload && !mUploadComplete && !mErrorLoad &&
 78799:       (mState & XML_HTTP_REQUEST_ASYNC)) {
 88284:     if (mProgressTimerIsActive) {
 88284:       mProgressTimerIsActive = false;
 78799:       mProgressNotifier->Cancel();
 78799:     }
 80486:     MaybeDispatchProgressEvents(true);
 80486:     mUploadComplete = true;
 78799:     DispatchProgressEvent(mUpload, NS_LITERAL_STRING(LOAD_STR),
 80486:                           true, mUploadTotal, mUploadTotal);
 78799:   }
 78799: 
     1:   mReadRequest = request;
     1:   mContext = ctxt;
     1:   mState |= XML_HTTP_REQUEST_PARSEBODY;
 19152:   mState &= ~XML_HTTP_REQUEST_MPART_HEADERS;
 69662:   ChangeState(XML_HTTP_REQUEST_HEADERS_RECEIVED);
 69662: 
 88536:   if (mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
 88536:       mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) {
 69662:     nsCOMPtr<nsICachingChannel> cc(do_QueryInterface(mChannel));
 69662:     if (cc) {
 80486:       cc->SetCacheAsFile(true);
 69662:     }
 69662:   }
     1: 
 78799:   ResetResponse();
 20331: 
 78800:   if (!mOverrideMimeType.IsEmpty()) {
 94307:     channel->SetContentType(NS_ConvertUTF16toUTF8(mOverrideMimeType));
 78800:   }
 78800: 
 78800:   DetectCharset();
 78800: 
 20331:   // Set up responseXML
 79445:   bool parseBody = mResponseType == XML_HTTP_RESPONSE_TYPE_DEFAULT ||
 69662:                      mResponseType == XML_HTTP_RESPONSE_TYPE_DOCUMENT;
     1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
 69662:   if (parseBody && httpChannel) {
110974:     nsAutoCString method;
     1:     httpChannel->GetRequestMethod(method);
     1:     parseBody = !method.EqualsLiteral("HEAD");
     1:   }
     1: 
 82543:   mIsHtml = false;
 82543:   mWarnAboutMultipartHtml = false;
 82543:   mWarnAboutSyncHtml = false;
     1:   if (parseBody && NS_SUCCEEDED(status)) {
     1:     // We can gain a huge performance win by not even trying to
     1:     // parse non-XML data. This also protects us from the situation
     1:     // where we have an XML document and sink, but HTML (or other)
     1:     // parser, which can produce unreliable results.
110974:     nsAutoCString type;
     1:     channel->GetContentType(type);
     1: 
 82735:     if ((mResponseType == XML_HTTP_RESPONSE_TYPE_DOCUMENT) &&
 82735:         type.EqualsLiteral("text/html")) {
 82735:       // HTML parsing is only supported for responseType == "document" to
 82735:       // avoid running the parser and, worse, populating responseXML for
 82735:       // legacy users of XHR who use responseType == "" for retrieving the
 82735:       // responseText of text/html resources. This legacy case is so common
 82735:       // that it's not useful to emit a warning about it.
 82543:       if (!(mState & XML_HTTP_REQUEST_ASYNC)) {
 82543:         // We don't make cool new features available in the bad synchronous
 82543:         // mode. The synchronous mode is for legacy only.
 82543:         mWarnAboutSyncHtml = true;
 82543:         mState &= ~XML_HTTP_REQUEST_PARSEBODY;
 82543:       } else if (mState & XML_HTTP_REQUEST_MULTIPART) {
 82543:         // HTML parsing is supported only for non-multipart responses. The
 82543:         // multipart implementation assumes that it's OK to start the next part
 82543:         // immediately after the last part. That doesn't work with the HTML
 82543:         // parser, because when OnStopRequest for one part has fired, the
 82543:         // parser thread still hasn't posted back the runnables that make the
 82543:         // parsing appear finished.
 82543:         //
 82543:         // On the other hand, multipart support seems to be a legacy feature,
 82543:         // so it isn't clear that use cases justify adding support for deferring
 82543:         // the multipart stream events between parts to accommodate the
 82543:         // asynchronous nature of the HTML parser.
 82543:         mWarnAboutMultipartHtml = true;
 82543:         mState &= ~XML_HTTP_REQUEST_PARSEBODY;
 82543:       } else {
 82543:         mIsHtml = true;
 82543:       }
 82543:     } else if (type.Find("xml") == kNotFound) {
     1:       mState &= ~XML_HTTP_REQUEST_PARSEBODY;
     1:     }
     1:   } else {
     1:     // The request failed, so we shouldn't be parsing anyway
     1:     mState &= ~XML_HTTP_REQUEST_PARSEBODY;
     1:   }
     1: 
     1:   if (mState & XML_HTTP_REQUEST_PARSEBODY) {
 20331:     nsCOMPtr<nsIURI> baseURI, docURI;
 92083:     nsIScriptContext* sc = GetContextForEventHandlers(&rv);
 92083:     NS_ENSURE_SUCCESS(rv, rv);
 29226:     nsCOMPtr<nsIDocument> doc =
 92083:       nsContentUtils::GetDocumentFromScriptContext(sc);
 20331: 
 20331:     if (doc) {
 20331:       docURI = doc->GetDocumentURI();
 20331:       baseURI = doc->GetBaseURI();
 20331:     }
 20331: 
 20331:     // Create an empty document from it.  Here we have to cheat a little bit...
 20331:     // Setting the base URI to |baseURI| won't work if the document has a null
 20331:     // principal, so use mPrincipal when creating the document, then reset the
 20331:     // principal.
 20331:     const nsAString& emptyStr = EmptyString();
 92083:     nsCOMPtr<nsIScriptGlobalObject> global = do_QueryInterface(GetOwner());
 94307:     nsCOMPtr<nsIDOMDocument> responseDoc;
106838:     rv = nsContentUtils::CreateDocument(emptyStr, emptyStr, nullptr, docURI,
 82543:                                         baseURI, mPrincipal, global,
 82543:                                         mIsHtml ? DocumentFlavorHTML :
 82543:                                                   DocumentFlavorLegacyGuess,
 94307:                                         getter_AddRefs(responseDoc));
 20331:     NS_ENSURE_SUCCESS(rv, rv);
 94307:     mResponseXML = do_QueryInterface(responseDoc);
 94307:     mResponseXML->SetPrincipal(documentPrincipal);
 20331: 
101616:     if (nsContentUtils::IsSystemPrincipal(mPrincipal)) {
 94307:       mResponseXML->ForceEnableXULXBL();
 51490:     }
 51490: 
 20331:     if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
 20331:       nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mResponseXML);
 20331:       if (htmlDoc) {
 20331:         htmlDoc->DisableCookieAccess();
 20331:       }
 20331:     }
 20331: 
     1:     nsCOMPtr<nsIStreamListener> listener;
     1:     nsCOMPtr<nsILoadGroup> loadGroup;
     1:     channel->GetLoadGroup(getter_AddRefs(loadGroup));
     1: 
 94307:     rv = mResponseXML->StartDocumentLoad(kLoadAsData, channel, loadGroup,
106838:                                          nullptr, getter_AddRefs(listener),
 20331:                                          !(mState & XML_HTTP_REQUEST_USE_XSITE_AC));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     mXMLParserStreamListener = listener;
 20331:     rv = mXMLParserStreamListener->OnStartRequest(request, ctxt);
 20331:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
 20640:   // We won't get any progress events anyway if we didn't have progress
 20640:   // events when starting the request - so maybe no need to start timer here.
 20640:   if (NS_SUCCEEDED(rv) &&
 20640:       (mState & XML_HTTP_REQUEST_ASYNC) &&
 20640:       HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR))) {
 20640:     StartProgressEventTimer();
 20640:   }
 20640: 
     1:   return NS_OK;
     1: }
     1: 
     1: /* void onStopRequest (in nsIRequest request, in nsISupports ctxt, in nsresult status, in wstring statusArg); */
     1: NS_IMETHODIMP
     1: nsXMLHttpRequest::OnStopRequest(nsIRequest *request, nsISupports *ctxt, nsresult status)
     1: {
 87692:   SAMPLE_LABEL("content", "nsXMLHttpRequest::OnStopRequest");
  5746:   if (!IsSameOrBaseChannel(request, mChannel)) {
  5746:     return NS_OK;
  5746:   }
  5746: 
 90244:   mWaitingForOnStopRequest = false;
 90244: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   // If we're loading a multipart stream of XML documents, we'll get
     1:   // an OnStopRequest() for the last part in the stream, and then
     1:   // another one for the end of the initiating
     1:   // "multipart/x-mixed-replace" stream too. So we must check that we
     1:   // still have an xml parser stream listener before accessing it
     1:   // here.
  4106:   nsCOMPtr<nsIMultiPartChannel> mpChannel = do_QueryInterface(request);
  4106:   if (mpChannel) {
 79445:     bool last;
  4106:     rv = mpChannel->GetIsLastPart(&last);
  4106:     NS_ENSURE_SUCCESS(rv, rv);
  4106:     if (last) {
  4106:       mState |= XML_HTTP_REQUEST_GOT_FINAL_STOP;
  4106:     }
  4106:   }
  4106:   else {
  4106:     mState |= XML_HTTP_REQUEST_GOT_FINAL_STOP;
  4106:   }
  4106: 
 22035:   if (mRequestObserver && mState & XML_HTTP_REQUEST_GOT_FINAL_STOP) {
 22035:     NS_ASSERTION(mFirstStartRequestSeen, "Inconsistent state!");
 80486:     mFirstStartRequestSeen = false;
 22035:     mRequestObserver->OnStopRequest(request, ctxt, status);
 22035:   }
 22035: 
 41710:   // make sure to notify the listener if we were aborted
 41710:   // XXX in fact, why don't we do the cleanup below in this case??
 88284:   // XML_HTTP_REQUEST_UNSENT is for abort calls.  See OnStartRequest above.
 88284:   if ((mState & XML_HTTP_REQUEST_UNSENT) ||
 88284:       (mState & XML_HTTP_REQUEST_TIMED_OUT)) {
 41710:     if (mXMLParserStreamListener)
 41710:       (void) mXMLParserStreamListener->OnStopRequest(request, ctxt, status);
 22035:     return NS_OK;
 41710:   }
 22035: 
 22035:   // Is this good enough here?
 22035:   if (mState & XML_HTTP_REQUEST_PARSEBODY && mXMLParserStreamListener) {
 71743:     mXMLParserStreamListener->OnStopRequest(request, ctxt, status);
 22035:   }
 22035: 
106838:   mXMLParserStreamListener = nullptr;
106838:   mReadRequest = nullptr;
106838:   mContext = nullptr;
     1: 
 78799:   // If we're received data since the last progress event, make sure to fire
 82543:   // an event for it, except in the HTML case, defer the last progress event
 82543:   // until the parser is done.
 82543:   if (!mIsHtml) {
 80486:     MaybeDispatchProgressEvents(true);
 82543:   }
 78799: 
 88536:   if (NS_SUCCEEDED(status) &&
 88536:       (mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
 88536:        mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB)) {
 88536:     if (!mDOMFile) {
 88536:       CreateDOMFile(request);
 88536:     }
 88536:     if (mDOMFile) {
 88536:       mResponseBlob = mDOMFile;
106838:       mDOMFile = nullptr;
 88536:     } else {
114175:       // mBuilder can be null if the channel is non-file non-cacheable
114175:       // and if the response length is zero.
114175:       if (!mBuilder) {
114175:         mBuilder = new nsDOMBlobBuilder();
114175:       }
 69662:       // Smaller files may be written in cache map instead of separate files.
 69662:       // Also, no-store response cannot be written in persistent cache.
110974:       nsAutoCString contentType;
 69662:       mChannel->GetContentType(contentType);
 88536:       mBuilder->GetBlobInternal(NS_ConvertASCIItoUTF16(contentType),
 88536:                                 false, getter_AddRefs(mResponseBlob));
106838:       mBuilder = nullptr;
 88536:     }
 88536:     NS_ASSERTION(mResponseBody.IsEmpty(), "mResponseBody should be empty");
 78800:     NS_ASSERTION(mResponseText.IsEmpty(), "mResponseText should be empty");
 69662:   }
 88536: 
 88536:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
 88536:   NS_ENSURE_TRUE(channel, NS_ERROR_UNEXPECTED);
 69662: 
106838:   channel->SetNotificationCallbacks(nullptr);
106838:   mNotificationCallbacks = nullptr;
106838:   mChannelEventSink = nullptr;
106838:   mProgressEventSink = nullptr;
     1: 
 82345:   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
 82345: 
     1:   if (NS_FAILED(status)) {
     1:     // This can happen if the server is unreachable. Other possible
     1:     // reasons are that the user leaves the page or hits the ESC key.
 71743: 
 80486:     mErrorLoad = true;
106838:     mResponseXML = nullptr;
 71743:   }
 71743: 
     1:   // If we're uninitialized at this point, we encountered an error
     1:   // earlier and listeners have already been notified. Also we do
     1:   // not want to do this if we already completed.
 69662:   if (mState & (XML_HTTP_REQUEST_UNSENT |
 69662:                 XML_HTTP_REQUEST_DONE)) {
     1:     return NS_OK;
     1:   }
     1: 
 82543:   if (!mResponseXML) {
 82543:     ChangeStateToDone();
 82543:     return NS_OK;
 82543:   }
 82543:   if (mIsHtml) {
 82543:     NS_ASSERTION(!(mState & XML_HTTP_REQUEST_SYNCLOOPING),
 82543:       "We weren't supposed to support HTML parsing with XHR!");
 82543:     nsCOMPtr<nsIDOMEventTarget> eventTarget = do_QueryInterface(mResponseXML);
 82543:     nsEventListenerManager* manager = eventTarget->GetListenerManager(true);
 82543:     manager->AddEventListenerByType(new nsXHRParseEndListener(this),
 82543:                                     NS_LITERAL_STRING("DOMContentLoaded"),
 82543:                                     NS_EVENT_FLAG_BUBBLE |
 82543:                                     NS_EVENT_FLAG_SYSTEM_EVENT);
 82543:     return NS_OK;
 82543:   }
     1:   // We might have been sent non-XML data. If that was the case,
     1:   // we should null out the document member. The idea in this
     1:   // check here is that if there is no document element it is not
     1:   // an XML document. We might need a fancier check...
 94307:   if (!mResponseXML->GetRootElement()) {
106838:     mResponseXML = nullptr;
     1:   }
 82543:   ChangeStateToDone();
 82543:   return NS_OK;
 82543: }
 82543: 
 82543: void
 82543: nsXMLHttpRequest::ChangeStateToDone()
 82543: {
 82543:   if (mIsHtml) {
 82543:     // In the HTML case, this has to be deferred, because the parser doesn't
 82543:     // do it's job synchronously.
 82543:     MaybeDispatchProgressEvents(true);
 82543:   }
 88284: 
 80486:   ChangeState(XML_HTTP_REQUEST_DONE, true);
 88284:   if (mTimeoutTimer) {
 88284:     mTimeoutTimer->Cancel();
 88284:   }
     1: 
 16665:   NS_NAMED_LITERAL_STRING(errorStr, ERROR_STR);
 16665:   NS_NAMED_LITERAL_STRING(loadStr, LOAD_STR);
 16665:   DispatchProgressEvent(this,
 16665:                         mErrorLoad ? errorStr : loadStr,
 16665:                         !mErrorLoad,
 78799:                         mLoadTransferred,
 78799:                         mErrorLoad ? 0 : mLoadTransferred);
 16665:   if (mErrorLoad && mUpload && !mUploadComplete) {
 80486:     DispatchProgressEvent(mUpload, errorStr, true,
 16665:                           mUploadTransferred, mUploadTotal);
     1:   }
     1: 
 71743:   if (mErrorLoad) {
 71743:     // By nulling out channel here we make it so that Send() can test
 71743:     // for that and throw. Also calling the various status
 71743:     // methods/members will not throw.
 71743:     // This matches what IE does.
106838:     mChannel = nullptr;
106838:     mCORSPreflightChannel = nullptr;
 71743:   }
 71743:   else if (!(mState & XML_HTTP_REQUEST_GOT_FINAL_STOP)) {
     1:     // We're a multipart request, so we're not done. Reset to opened.
     1:     ChangeState(XML_HTTP_REQUEST_OPENED);
     1:   }
     1: }
     1: 
  3941: NS_IMETHODIMP
102430: nsXMLHttpRequest::SendAsBinary(const nsAString &aBody)
  3941: {
 97819:   ErrorResult rv;
102430:   SendAsBinary(aBody, rv);
 97819:   return rv.ErrorCode();
 94307: }
 94307: 
 94307: void
102430: nsXMLHttpRequest::SendAsBinary(const nsAString &aBody,
 97819:                                ErrorResult& aRv)
 94307: {
  3941:   char *data = static_cast<char*>(NS_Alloc(aBody.Length() + 1));
 94307:   if (!data) {
 97819:     aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
 94307:     return;
 94307:   }
  3941: 
  3941:   nsAString::const_iterator iter, end;
  3941:   aBody.BeginReading(iter);
  3941:   aBody.EndReading(end);
  3941:   char *p = data;
  3941:   while (iter != end) {
  3941:     if (*iter & 0xFF00) {
  3941:       NS_Free(data);
 97819:       aRv.Throw(NS_ERROR_DOM_INVALID_CHARACTER_ERR);
 94307:       return;
  3941:     }
  3941:     *p++ = static_cast<char>(*iter++);
  3941:   }
  3941:   *p = '\0';
  3941: 
  3941:   nsCOMPtr<nsIInputStream> stream;
 94307:   aRv = NS_NewByteInputStream(getter_AddRefs(stream), data, aBody.Length(),
 94307:                               NS_ASSIGNMENT_ADOPT);
 97819:   if (aRv.Failed()) {
  3941:     NS_Free(data);
 94307:     return;
 94307:   }
 94307: 
 94307:   nsCOMPtr<nsIWritableVariant> variant = new nsVariant();
 94307: 
 94307:   aRv = variant->SetAsISupports(stream);
 97819:   if (aRv.Failed()) {
 94307:     return;
 94307:   }
 94307: 
102430:   aRv = Send(variant);
 94307: }
 94307: 
 94307: static nsresult
 94307: GetRequestBody(nsIDOMDocument* aDoc, nsIInputStream** aResult,
 94307:                nsACString& aContentType, nsACString& aCharset)
 94307: {
 94307:   aContentType.AssignLiteral("application/xml");
 94307:   nsAutoString inputEncoding;
 94307:   aDoc->GetInputEncoding(inputEncoding);
 94307:   if (!DOMStringIsNull(inputEncoding)) {
 94307:     CopyUTF16toUTF8(inputEncoding, aCharset);
 94307:   }
 94307:   else {
 94307:     aCharset.AssignLiteral("UTF-8");
 94307:   }
 94307: 
 94307:   // Serialize to a stream so that the encoding used will
 94307:   // match the document's.
 94307:   nsresult rv;
 94307:   nsCOMPtr<nsIDOMSerializer> serializer =
 94307:     do_CreateInstance(NS_XMLSERIALIZER_CONTRACTID, &rv);
  3941:   NS_ENSURE_SUCCESS(rv, rv);
  3941: 
 94307:   nsCOMPtr<nsIStorageStream> storStream;
 94307:   rv = NS_NewStorageStream(4096, PR_UINT32_MAX, getter_AddRefs(storStream));
  3941:   NS_ENSURE_SUCCESS(rv, rv);
  3941: 
 94307:   nsCOMPtr<nsIOutputStream> output;
 94307:   rv = storStream->GetOutputStream(0, getter_AddRefs(output));
 94307:   NS_ENSURE_SUCCESS(rv, rv);
 94307: 
 94307:   // Make sure to use the encoding we'll send
 94307:   rv = serializer->SerializeToStream(aDoc, output, aCharset);
 94307:   NS_ENSURE_SUCCESS(rv, rv);
 94307: 
 94307:   output->Close();
 94307: 
 94307:   return storStream->NewInputStream(0, aResult);
 94307: }
 94307: 
 94307: static nsresult
 94307: GetRequestBody(const nsAString& aString, nsIInputStream** aResult,
 94307:                nsACString& aContentType, nsACString& aCharset)
 94307: {
 94307:   aContentType.AssignLiteral("text/plain");
 94307:   aCharset.AssignLiteral("UTF-8");
 94307: 
 94307:   return NS_NewCStringInputStream(aResult, NS_ConvertUTF16toUTF8(aString));
 94307: }
 94307: 
 94307: static nsresult
 94307: GetRequestBody(nsIInputStream* aStream, nsIInputStream** aResult,
 94307:                nsACString& aContentType, nsACString& aCharset)
 94307: {
 94307:   aContentType.AssignLiteral("text/plain");
 94307:   aCharset.Truncate();
 94307: 
 94307:   NS_ADDREF(*aResult = aStream);
 94307: 
 94307:   return NS_OK;
 94307: }
 94307: 
 94307: static nsresult
 94307: GetRequestBody(nsIXHRSendable* aSendable, nsIInputStream** aResult,
 94307:                nsACString& aContentType, nsACString& aCharset)
 94307: {
 94307:   return aSendable->GetSendInfo(aResult, aContentType, aCharset);
 94307: }
 94307: 
 94307: static nsresult
100046: GetRequestBody(ArrayBuffer* aArrayBuffer, nsIInputStream** aResult,
 94307:                nsACString& aContentType, nsACString& aCharset)
 94307: {
 94307:   aContentType.SetIsVoid(true);
 94307:   aCharset.Truncate();
 94307: 
108991:   int32_t length = aArrayBuffer->Length();
107061:   char* data = reinterpret_cast<char*>(aArrayBuffer->Data());
 94307: 
 94307:   nsCOMPtr<nsIInputStream> stream;
 94307:   nsresult rv = NS_NewByteInputStream(getter_AddRefs(stream), data, length,
 94307:                                       NS_ASSIGNMENT_COPY);
 94307:   NS_ENSURE_SUCCESS(rv, rv);
 94307: 
 94307:   stream.forget(aResult);
 94307: 
 94307:   return NS_OK;
  3941: }
  3941: 
 38677: static nsresult
102430: GetRequestBody(nsIVariant* aBody, nsIInputStream** aResult,
 38677:                nsACString& aContentType, nsACString& aCharset)
 38677: {
106838:   *aResult = nullptr;
 38677: 
108991:   uint16_t dataType;
 38677:   nsresult rv = aBody->GetDataType(&dataType);
 38677:   NS_ENSURE_SUCCESS(rv, rv);
 38677: 
 38677:   if (dataType == nsIDataType::VTYPE_INTERFACE ||
 38677:       dataType == nsIDataType::VTYPE_INTERFACE_IS) {
 38677:     nsCOMPtr<nsISupports> supports;
 38677:     nsID *iid;
 38677:     rv = aBody->GetAsInterface(&iid, getter_AddRefs(supports));
 38677:     NS_ENSURE_SUCCESS(rv, rv);
 38677: 
 38677:     nsMemory::Free(iid);
 38677: 
 38677:     // document?
 38677:     nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(supports);
 38677:     if (doc) {
 94307:       return GetRequestBody(doc, aResult, aContentType, aCharset);
 38677:     }
 38677: 
 38677:     // nsISupportsString?
 38677:     nsCOMPtr<nsISupportsString> wstr = do_QueryInterface(supports);
 38677:     if (wstr) {
 38677:       nsAutoString string;
 38677:       wstr->GetData(string);
 38677: 
 94307:       return GetRequestBody(string, aResult, aContentType, aCharset);
 38677:     }
 38677: 
 38677:     // nsIInputStream?
 38677:     nsCOMPtr<nsIInputStream> stream = do_QueryInterface(supports);
 38677:     if (stream) {
 94307:       return GetRequestBody(stream, aResult, aContentType, aCharset);
 38677:     }
 38677: 
 38679:     // nsIXHRSendable?
 38679:     nsCOMPtr<nsIXHRSendable> sendable = do_QueryInterface(supports);
 38679:     if (sendable) {
 94307:       return GetRequestBody(sendable, aResult, aContentType, aCharset);
 38679:     }
 78114: 
 78114:     // ArrayBuffer?
 78114:     jsval realVal;
102429:     nsCxPusher pusher;
109257:     Maybe<JSAutoCompartment> ac;
102429: 
102429:     // If there's a context on the stack, we can just use it. Otherwise, we need
102429:     // to use the safe js context (and push it into the stack, so that it's
102429:     // visible to cx-less functions that we might call here).
102429:     JSContext* cx = nsContentUtils::GetCurrentJSContext();
102429:     if (!cx) {
102429:       cx = nsContentUtils::GetSafeJSContext();
102429:       if (!pusher.Push(cx)) {
102429:         return NS_ERROR_FAILURE;
102429:       }
102429:     }
102429: 
 78114:     nsresult rv = aBody->GetAsJSVal(&realVal);
109257:     if (NS_SUCCEEDED(rv) && !JSVAL_IS_PRIMITIVE(realVal)) {
109257:       JSObject *obj = JSVAL_TO_OBJECT(realVal);
109257:       ac.construct(cx, obj);
109257:       if (JS_IsArrayBufferObject(obj, cx)) {
102429:           ArrayBuffer buf(cx, obj);
100046:           return GetRequestBody(&buf, aResult, aContentType, aCharset);
 78114:       }
 38677:     }
109257:   }
 38677:   else if (dataType == nsIDataType::VTYPE_VOID ||
 38677:            dataType == nsIDataType::VTYPE_EMPTY) {
 38677:     // Makes us act as if !aBody, don't upload anything
 94307:     aContentType.AssignLiteral("text/plain");
 94307:     aCharset.AssignLiteral("UTF-8");
 94307: 
 38677:     return NS_OK;
 38677:   }
 38677: 
106838:   PRUnichar* data = nullptr;
108991:   uint32_t len = 0;
 38677:   rv = aBody->GetAsWStringWithSize(&len, &data);
 38677:   NS_ENSURE_SUCCESS(rv, rv);
 38677: 
 38677:   nsString string;
 38677:   string.Adopt(data, len);
 38677: 
 94307:   return GetRequestBody(string, aResult, aContentType, aCharset);
 94307: }
 94307: 
 94307: /* static */
 94307: nsresult
102430: nsXMLHttpRequest::GetRequestBody(nsIVariant* aVariant,
 94512:                                  const Nullable<RequestBody>& aBody,
 94307:                                  nsIInputStream** aResult,
 94307:                                  nsACString& aContentType, nsACString& aCharset)
 94307: {
 94307:   if (aVariant) {
102430:     return ::GetRequestBody(aVariant, aResult, aContentType, aCharset);
 94307:   }
 94307: 
 94512:   const RequestBody& body = aBody.Value();
 94307:   RequestBody::Value value = body.GetValue();
 94307:   switch (body.GetType()) {
 94307:     case nsXMLHttpRequest::RequestBody::ArrayBuffer:
 94307:     {
100046:       return ::GetRequestBody(value.mArrayBuffer, aResult, aContentType, aCharset);
 94307:     }
 94307:     case nsXMLHttpRequest::RequestBody::Blob:
 94307:     {
 94307:       nsresult rv;
 94307:       nsCOMPtr<nsIXHRSendable> sendable = do_QueryInterface(value.mBlob, &rv);
 94307:       NS_ENSURE_SUCCESS(rv, rv);
 94307: 
 94307:       return ::GetRequestBody(sendable, aResult, aContentType, aCharset);
 94307:     }
 94307:     case nsXMLHttpRequest::RequestBody::Document:
 94307:     {
 94307:       nsCOMPtr<nsIDOMDocument> document = do_QueryInterface(value.mDocument);
 94307:       return ::GetRequestBody(document, aResult, aContentType, aCharset);
 94307:     }
 94307:     case nsXMLHttpRequest::RequestBody::DOMString:
 94307:     {
 94307:       return ::GetRequestBody(*value.mString, aResult, aContentType, aCharset);
 94307:     }
 94307:     case nsXMLHttpRequest::RequestBody::FormData:
 94307:     {
 94307:       nsresult rv;
 94307:       nsCOMPtr<nsIXHRSendable> sendable = do_QueryInterface(value.mFormData, &rv);
 94307:       NS_ENSURE_SUCCESS(rv, rv);
 94307: 
 94307:       return ::GetRequestBody(sendable, aResult, aContentType, aCharset);
 94307:     }
 94307:     case nsXMLHttpRequest::RequestBody::InputStream:
 94307:     {
 94307:       return ::GetRequestBody(value.mStream, aResult, aContentType, aCharset);
 94307:     }
 94307:     default:
 94307:     {
 94307:       return NS_ERROR_FAILURE;
 94307:     }
 94307:   }
 94307: 
 94307:   NS_NOTREACHED("Default cases exist for a reason");
 94307:   return NS_OK;
 38677: }
 38677: 
 20556: /* void send (in nsIVariant aBody); */
 20556: NS_IMETHODIMP
102430: nsXMLHttpRequest::Send(nsIVariant *aBody)
     1: {
102430:   return Send(aBody, Nullable<RequestBody>());
 94307: }
 94307: 
 94307: nsresult
102430: nsXMLHttpRequest::Send(nsIVariant* aVariant, const Nullable<RequestBody>& aBody)
 94307: {
 20556:   NS_ENSURE_TRUE(mPrincipal, NS_ERROR_NOT_INITIALIZED);
 20556: 
 20556:   nsresult rv = CheckInnerWindowCorrectness();
 20556:   NS_ENSURE_SUCCESS(rv, rv);
 20556: 
 20556:   // Return error if we're already processing a request
 20556:   if (XML_HTTP_REQUEST_SENT & mState) {
 20556:     return NS_ERROR_FAILURE;
 20556:   }
 20556: 
 20556:   // Make sure we've been opened
 20556:   if (!mChannel || !(XML_HTTP_REQUEST_OPENED & mState)) {
 20556:     return NS_ERROR_NOT_INITIALIZED;
 20556:   }
 20556: 
 52200: 
 52200:   // nsIRequest::LOAD_BACKGROUND prevents throbber from becoming active, which
 52200:   // in turn keeps STOP button from becoming active.  If the consumer passed in
 52200:   // a progress event handler we must load with nsIRequest::LOAD_NORMAL or
 52200:   // necko won't generate any progress notifications.
 52200:   if (HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR)) ||
 52200:       (mUpload && mUpload->HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR)))) {
 52200:     nsLoadFlags loadFlags;
 52200:     mChannel->GetLoadFlags(&loadFlags);
 52200:     loadFlags &= ~nsIRequest::LOAD_BACKGROUND;
 52200:     loadFlags |= nsIRequest::LOAD_NORMAL;
 52200:     mChannel->SetLoadFlags(loadFlags);
 52200:   }
 52200: 
 20556:   // XXX We should probably send a warning to the JS console
 20556:   //     if there are no event listeners set and we are doing
 20556:   //     an asynchronous call.
 20556: 
 20556:   // Ignore argument if method is GET, there is no point in trying to
 20556:   // upload anything
110974:   nsAutoCString method;
     1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
 20556: 
 20556:   if (httpChannel) {
 20556:     httpChannel->GetRequestMethod(method); // If GET, method name will be uppercase
 20556: 
 63932:     if (!IsSystemXHR()) {
 62277:       // Get the referrer for the request.
 62277:       //
 62277:       // If it weren't for history.push/replaceState, we could just use the
 62277:       // principal's URI here.  But since we want changes to the URI effected
 62277:       // by push/replaceState to be reflected in the XHR referrer, we have to
 62277:       // be more clever.
 62277:       //
 62277:       // If the document's original URI (before any push/replaceStates) matches
 62277:       // our principal, then we use the document's current URI (after
 62277:       // push/replaceStates).  Otherwise (if the document is, say, a data:
 62277:       // URI), we just use the principal's URI.
 62277: 
 62277:       nsCOMPtr<nsIURI> principalURI;
 62277:       mPrincipal->GetURI(getter_AddRefs(principalURI));
 62277: 
 92083:       nsIScriptContext* sc = GetContextForEventHandlers(&rv);
 92083:       NS_ENSURE_SUCCESS(rv, rv);
 62277:       nsCOMPtr<nsIDocument> doc =
 92083:         nsContentUtils::GetDocumentFromScriptContext(sc);
 62277: 
 62277:       nsCOMPtr<nsIURI> docCurURI;
 62277:       nsCOMPtr<nsIURI> docOrigURI;
 62277:       if (doc) {
 62277:         docCurURI = doc->GetDocumentURI();
 62277:         docOrigURI = doc->GetOriginalURI();
 62277:       }
 62277: 
 62277:       nsCOMPtr<nsIURI> referrerURI;
 62277: 
 62277:       if (principalURI && docCurURI && docOrigURI) {
 79445:         bool equal = false;
 62277:         principalURI->Equals(docOrigURI, &equal);
 62277:         if (equal) {
 62277:           referrerURI = docCurURI;
 62277:         }
 62277:       }
 62277: 
 62277:       if (!referrerURI)
 62277:         referrerURI = principalURI;
 62277: 
 62277:       httpChannel->SetReferrer(referrerURI);
 20556:     }
 35023: 
 35023:     // Some extensions override the http protocol handler and provide their own
 35023:     // implementation. The channels returned from that implementation doesn't
 35023:     // seem to always implement the nsIUploadChannel2 interface, presumably
 35023:     // because it's a new interface.
 35023:     // Eventually we should remove this and simply require that http channels
 35023:     // implement the new interface.
 35023:     // See bug 529041
 35023:     nsCOMPtr<nsIUploadChannel2> uploadChannel2 =
 35023:       do_QueryInterface(httpChannel);
 35023:     if (!uploadChannel2) {
 35023:       nsCOMPtr<nsIConsoleService> consoleService =
 35023:         do_GetService(NS_CONSOLESERVICE_CONTRACTID);
 35023:       if (consoleService) {
 35023:         consoleService->LogStringMessage(NS_LITERAL_STRING(
 35027:           "Http channel implementation doesn't support nsIUploadChannel2. An extension has supplied a non-functional http protocol handler. This will break behavior and in future releases not work at all."
 35027:                                                            ).get());
 35023:       }
 35023:     }
 20556:   }
 20556: 
 20556:   mUploadTransferred = 0;
 20556:   mUploadTotal = 0;
 20556:   // By default we don't have any upload, so mark upload complete.
 80486:   mUploadComplete = true;
 80486:   mErrorLoad = false;
 80486:   mLoadLengthComputable = false;
 20640:   mLoadTotal = 0;
 20640:   mUploadProgress = 0;
 20640:   mUploadProgressMax = 0;
 94512:   if ((aVariant || !aBody.IsNull()) && httpChannel &&
 94307:       !method.EqualsLiteral("GET")) {
 38677: 
110974:     nsAutoCString charset;
110974:     nsAutoCString defaultContentType;
     1:     nsCOMPtr<nsIInputStream> postDataStream;
 38677: 
102430:     rv = GetRequestBody(aVariant, aBody, getter_AddRefs(postDataStream),
 38677:                         defaultContentType, charset);
 13258:     NS_ENSURE_SUCCESS(rv, rv);
 13258: 
     1:     if (postDataStream) {
     1:       // If no content type header was set by the client, we set it to
     1:       // application/xml.
110974:       nsAutoCString contentType;
     1:       if (NS_FAILED(httpChannel->
     1:                       GetRequestHeader(NS_LITERAL_CSTRING("Content-Type"),
     1:                                        contentType)) ||
     1:           contentType.IsEmpty()) {
 23635:         contentType = defaultContentType;
     1:       }
     1: 
  3251:       // We don't want to set a charset for streams.
  3251:       if (!charset.IsEmpty()) {
110974:         nsAutoCString specifiedCharset;
 79445:         bool haveCharset;
108991:         int32_t charsetStart, charsetEnd;
  8603:         rv = NS_ExtractCharsetFromContentType(contentType, specifiedCharset,
  8603:                                               &haveCharset, &charsetStart,
  8603:                                               &charsetEnd);
 23635:         if (NS_SUCCEEDED(rv)) {
 82961:           // special case: the extracted charset is quoted with single quotes
 82961:           // -- for the purpose of preserving what was set we want to handle
 82961:           // them as delimiters (although they aren't really)
 82961:           if (specifiedCharset.Length() >= 2 &&
 82961:               specifiedCharset.First() == '\'' &&
 82961:               specifiedCharset.Last() == '\'') {
 82961:             specifiedCharset = Substring(specifiedCharset, 1,
 82961:                                          specifiedCharset.Length() - 2);
 82961:           }
 82961: 
  8603:           // If the content-type the page set already has a charset parameter,
  8603:           // and it's the same charset, up to case, as |charset|, just send the
  8603:           // page-set content-type header.  Apparently at least
  8603:           // google-web-toolkit is broken and relies on the exact case of its
  8603:           // charset parameter, which makes things break if we use |charset|
  8603:           // (which is always a fully resolved charset per our charset alias
  8603:           // table, hence might be differently cased).
  8603:           if (!specifiedCharset.Equals(charset,
  8603:                                        nsCaseInsensitiveCStringComparator())) {
110974:             nsAutoCString newCharset("; charset=");
  8603:             newCharset.Append(charset);
  8603:             contentType.Replace(charsetStart, charsetEnd - charsetStart,
  8603:                                 newCharset);
  8603:           }
  3251:         }
 23635:       }
  1407: 
 32329:       // If necessary, wrap the stream in a buffered stream so as to guarantee
 32329:       // support for our upload when calling ExplicitSetUploadStream.
 32329:       if (!NS_InputStreamIsBuffered(postDataStream)) {
 32329:         nsCOMPtr<nsIInputStream> bufferedStream;
 32329:         rv = NS_NewBufferedInputStream(getter_AddRefs(bufferedStream),
 32329:                                        postDataStream, 
 32329:                                        4096);
 32329:         NS_ENSURE_SUCCESS(rv, rv);
 32329: 
 32329:         postDataStream = bufferedStream;
 32329:       }
 32329: 
 80486:       mUploadComplete = false;
108991:       uint64_t uploadTotal = 0;
 20714:       postDataStream->Available(&uploadTotal);
 20714:       mUploadTotal = uploadTotal;
 32329: 
 32329:       // We want to use a newer version of the upload channel that won't
 32329:       // ignore the necessary headers for an empty Content-Type.
 35023:       nsCOMPtr<nsIUploadChannel2> uploadChannel2(do_QueryInterface(httpChannel));
 35023:       // This assertion will fire if buggy extensions are installed
 54922:       NS_ASSERTION(uploadChannel2, "http must support nsIUploadChannel2");
 35023:       if (uploadChannel2) {
 35023:           uploadChannel2->ExplicitSetUploadStream(postDataStream, contentType,
 80486:                                                  -1, method, false);
 35023:       }
 35023:       else {
 35023:         // http channel doesn't support the new nsIUploadChannel2. Emulate
 35023:         // as best we can using nsIUploadChannel
 35023:         if (contentType.IsEmpty()) {
 35023:           contentType.AssignLiteral("application/octet-stream");
 35023:         }
 35023:         nsCOMPtr<nsIUploadChannel> uploadChannel =
 35023:           do_QueryInterface(httpChannel);
 35023:         uploadChannel->SetUploadStream(postDataStream, contentType, -1);
 35023:         // Reset the method to its original value
 35023:         httpChannel->SetRequestMethod(method);
 35023:       }
 20556:     }
 20556:   }
 20556: 
 54922:   if (httpChannel) {
110974:     nsAutoCString contentTypeHeader;
 54922:     rv = httpChannel->GetRequestHeader(NS_LITERAL_CSTRING("Content-Type"),
 54922:                                        contentTypeHeader);
 54922:     if (NS_SUCCEEDED(rv)) {
110974:       nsAutoCString contentType, charset;
 54922:       rv = NS_ParseContentType(contentTypeHeader, contentType, charset);
 54922:       NS_ENSURE_SUCCESS(rv, rv);
 54922:   
 54922:       if (!contentType.LowerCaseEqualsLiteral("text/plain") &&
 54922:           !contentType.LowerCaseEqualsLiteral("application/x-www-form-urlencoded") &&
 54922:           !contentType.LowerCaseEqualsLiteral("multipart/form-data")) {
 64070:         mCORSUnsafeHeaders.AppendElement(NS_LITERAL_CSTRING("Content-Type"));
 54922:       }
 54922:     }
 54922:   }
 54922: 
 78799:   ResetResponse();
 20560: 
 20560:   rv = CheckChannelForCrossSiteRequest(mChannel);
 20560:   NS_ENSURE_SUCCESS(rv, rv);
 20560: 
 79445:   bool withCredentials = !!(mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS);
 20560: 
 20560:   // Hook us up to listen to redirects and the like
 20560:   mChannel->GetNotificationCallbacks(getter_AddRefs(mNotificationCallbacks));
 20560:   mChannel->SetNotificationCallbacks(this);
 20560: 
 20560:   // Create our listener
 20560:   nsCOMPtr<nsIStreamListener> listener = this;
 20560:   if (mState & XML_HTTP_REQUEST_MULTIPART) {
 94239:     Telemetry::Accumulate(Telemetry::MULTIPART_XHR_RESPONSE, 1);
 20560:     listener = new nsMultipartProxyListener(listener);
 94239:   } else {
 94239:     Telemetry::Accumulate(Telemetry::MULTIPART_XHR_RESPONSE, 0);
 20560:   }
 20560: 
 93840:   // Blocking gets are common enough out of XHR that we should mark
 93840:   // the channel slow by default for pipeline purposes
 93840:   AddLoadFlags(mChannel, nsIRequest::INHIBIT_PIPELINE);
 93840: 
 63932:   if (!IsSystemXHR()) {
 64070:     // Always create a nsCORSListenerProxy here even if it's
 20560:     // a same-origin request right now, since it could be redirected.
 64070:     listener = new nsCORSListenerProxy(listener, mPrincipal, mChannel,
 87071:                                        withCredentials, true, &rv);
 20560:     NS_ENSURE_SUCCESS(rv, rv);
 20560:   }
 98497:   else {
 98497:     // Because of bug 682305, we can't let listener be the XHR object itself
 98497:     // because JS wouldn't be able to use it. So if we haven't otherwise
 98497:     // created a listener around 'this', do so now.
 98497: 
 98497:     listener = new nsStreamListenerWrapper(listener);
 98497:   }
 98497: 
101616:   if (mIsAnon) {
101616:     AddLoadFlags(mChannel, nsIRequest::LOAD_ANONYMOUS);
101616:   }
101616: 
 98497:   NS_ASSERTION(listener != this,
 98497:                "Using an object as a listener that can't be exposed to JS");
 20560: 
     1:   // Bypass the network cache in cases where it makes no sense:
     1:   // 1) Multipart responses are very large and would likely be doomed by the
     1:   //    cache once they grow too large, so they are not worth caching.
     1:   // 2) POST responses are always unique, and we provide no API that would
     1:   //    allow our consumers to specify a "cache key" to access old POST
     1:   //    responses, so they are not worth caching.
     1:   if ((mState & XML_HTTP_REQUEST_MULTIPART) || method.EqualsLiteral("POST")) {
     1:     AddLoadFlags(mChannel,
     1:         nsIRequest::LOAD_BYPASS_CACHE | nsIRequest::INHIBIT_CACHING);
     1:   }
     1:   // When we are sync loading, we need to bypass the local cache when it would
     1:   // otherwise block us waiting for exclusive access to the cache.  If we don't
     1:   // do this, then we could dead lock in some cases (see bug 309424).
 20133:   else if (!(mState & XML_HTTP_REQUEST_ASYNC)) {
     1:     AddLoadFlags(mChannel,
     1:         nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE_IF_BUSY);
     1:   }
     1: 
     1:   // Since we expect XML data, set the type hint accordingly
110481:   // if the channel doesn't know any content type.
     1:   // This means that we always try to parse local files as XML
     1:   // ignoring return value, as this is not critical
110974:   nsAutoCString contentType;
110481:   if (NS_FAILED(mChannel->GetContentType(contentType)) ||
110481:       contentType.IsEmpty() ||
110481:       contentType.Equals(UNKNOWN_CONTENT_TYPE)) {
     1:     mChannel->SetContentType(NS_LITERAL_CSTRING("application/xml"));
110481:   }
     1: 
 88284:   // We're about to send the request.  Start our timeout.
 88284:   mRequestSentTime = PR_Now();
 88284:   StartTimeoutTimer();
 88284: 
 64069:   // Set up the preflight if needed
 64069:   if (mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT) {
 64069:     // Check to see if this initial OPTIONS request has already been cached
 64069:     // in our special Access Control Cache.
 64069: 
 64069:     rv = NS_StartCORSPreflight(mChannel, listener,
 64069:                                mPrincipal, withCredentials,
 64070:                                mCORSUnsafeHeaders,
 64070:                                getter_AddRefs(mCORSPreflightChannel));
 19951:     NS_ENSURE_SUCCESS(rv, rv);
 19951:   }
 19951:   else {
     1:     // Start reading from the channel
106838:     rv = mChannel->AsyncOpen(listener, nullptr);
 19951:   }
     1: 
     1:   if (NS_FAILED(rv)) {
     1:     // Drop our ref to the channel to avoid cycles
106838:     mChannel = nullptr;
106838:     mCORSPreflightChannel = nullptr;
     1:     return rv;
     1:   }
     1: 
 90244:   // Either AsyncOpen was called, or CORS will open the channel later.
 90244:   mWaitingForOnStopRequest = true;
 90244: 
     1:   // If we're synchronous, spin an event loop here and wait
     1:   if (!(mState & XML_HTTP_REQUEST_ASYNC)) {
 20133:     mState |= XML_HTTP_REQUEST_SYNCLOOPING;
 25074: 
 25722:     nsCOMPtr<nsIDocument> suspendedDoc;
 25074:     nsCOMPtr<nsIRunnable> resumeTimeoutRunnable;
 92083:     if (GetOwner()) {
 25074:       nsCOMPtr<nsIDOMWindow> topWindow;
 92083:       if (NS_SUCCEEDED(GetOwner()->GetTop(getter_AddRefs(topWindow)))) {
 25074:         nsCOMPtr<nsPIDOMWindow> suspendedWindow(do_QueryInterface(topWindow));
 25722:         if (suspendedWindow &&
 25722:             (suspendedWindow = suspendedWindow->GetCurrentInnerWindow())) {
 25722:           suspendedDoc = do_QueryInterface(suspendedWindow->GetExtantDocument());
 25722:           if (suspendedDoc) {
 25722:             suspendedDoc->SuppressEventHandling();
 25722:           }
 80486:           suspendedWindow->SuspendTimeouts(1, false);
 25722:           resumeTimeoutRunnable = new nsResumeTimeoutsEvent(suspendedWindow);
 25074:         }
 25074:       }
 25074:     }
 25074: 
 54235:     ChangeState(XML_HTTP_REQUEST_SENT);
 94465: 
 94465:     {
 94465:       nsAutoSyncOperation sync(suspendedDoc);
 54235:       // Note, calling ChangeState may have cleared
 54235:       // XML_HTTP_REQUEST_SYNCLOOPING flag.
     1:       nsIThread *thread = NS_GetCurrentThread();
     1:       while (mState & XML_HTTP_REQUEST_SYNCLOOPING) {
     1:         if (!NS_ProcessNextEvent(thread)) {
     1:           rv = NS_ERROR_UNEXPECTED;
     1:           break;
     1:         }
     1:       }
 94465:     }
 25074: 
 25722:     if (suspendedDoc) {
 80486:       suspendedDoc->UnsuppressEventHandlingAndFireEvents(true);
 25722:     }
 25722: 
 25074:     if (resumeTimeoutRunnable) {
 25074:       NS_DispatchToCurrentThread(resumeTimeoutRunnable);
 25074:     }
 16665:   } else {
 54235:     // Now that we've successfully opened the channel, we can change state.  Note
 54235:     // that this needs to come after the AsyncOpen() and rv check, because this
 54235:     // can run script that would try to restart this request, and that could end
 54235:     // up doing our AsyncOpen on a null channel if the reentered AsyncOpen fails.
 54235:     ChangeState(XML_HTTP_REQUEST_SENT);
106062:     if (mUpload && mUpload->HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR))) {
 20640:       StartProgressEventTimer();
 20640:     }
 80486:     DispatchProgressEvent(this, NS_LITERAL_STRING(LOADSTART_STR), false,
 16665:                           0, 0);
 16665:     if (mUpload && !mUploadComplete) {
 80486:       DispatchProgressEvent(mUpload, NS_LITERAL_STRING(LOADSTART_STR), true,
 16665:                             0, mUploadTotal);
 16665:     }
     1:   }
     1: 
     1:   if (!mChannel) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: /* void setRequestHeader (in AUTF8String header, in AUTF8String value); */
107465: // http://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-setrequestheader
     1: NS_IMETHODIMP
     1: nsXMLHttpRequest::SetRequestHeader(const nsACString& header,
     1:                                    const nsACString& value)
     1: {
107465:   // Step 1 and 2
107465:   if (!(mState & XML_HTTP_REQUEST_OPENED)) {
107465:     return NS_ERROR_DOM_INVALID_STATE_ERR;
107465:   }
107465:   NS_ASSERTION(mChannel, "mChannel must be valid if we're OPENED.");
107465: 
107465:   // Step 3
 64070:   // Make sure we don't store an invalid header name in mCORSUnsafeHeaders
107465:   if (!IsValidHTTPToken(header)) { // XXX nsHttp::IsValidToken?
107465:     return NS_ERROR_DOM_SYNTAX_ERR;
 19952:   }
 19952: 
 19951:   // Check that we haven't already opened the channel. We can't rely on
 19951:   // the channel throwing from mChannel->SetRequestHeader since we might
 64070:   // still be waiting for mCORSPreflightChannel to actually open mChannel
 64070:   if (mCORSPreflightChannel) {
 79445:     bool pending;
107465:     nsresult rv = mCORSPreflightChannel->IsPending(&pending);
 19951:     NS_ENSURE_SUCCESS(rv, rv);
 19951:     
 19951:     if (pending) {
 19951:       return NS_ERROR_IN_PROGRESS;
 19951:     }
 19951:   }
 19951: 
  4106:   if (!mChannel)             // open() initializes mChannel, and open()
  4106:     return NS_ERROR_FAILURE; // must be called before first setRequestHeader()
  4106: 
107465:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(mChannel);
  4106:   if (!httpChannel) {
  4106:     return NS_OK;
  4106:   }
     1: 
     1:   // Prevent modification to certain HTTP headers (see bug 302263), unless
 86399:   // the executing script has UniversalXPConnect.
     1: 
 79445:   bool privileged;
107465:   if (NS_FAILED(IsCapabilityEnabled("UniversalXPConnect", &privileged)))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   if (!privileged) {
107465:     // Step 5: Check for dangerous headers.
     1:     const char *kInvalidHeaders[] = {
 57507:       "accept-charset", "accept-encoding", "access-control-request-headers",
 57507:       "access-control-request-method", "connection", "content-length",
108338:       "cookie", "cookie2", "content-transfer-encoding", "date", "dnt",
108338:       "expect", "host", "keep-alive", "origin", "referer", "te", "trailer",
 57507:       "transfer-encoding", "upgrade", "user-agent", "via"
     1:     };
108991:     uint32_t i;
 80467:     for (i = 0; i < ArrayLength(kInvalidHeaders); ++i) {
     1:       if (header.LowerCaseEqualsASCII(kInvalidHeaders[i])) {
     1:         NS_WARNING("refusing to set request header");
     1:         return NS_OK;
     1:       }
     1:     }
 15889:     if (StringBeginsWith(header, NS_LITERAL_CSTRING("proxy-"),
 15889:                          nsCaseInsensitiveCStringComparator()) ||
 15889:         StringBeginsWith(header, NS_LITERAL_CSTRING("sec-"),
 15889:                          nsCaseInsensitiveCStringComparator())) {
 15889:       NS_WARNING("refusing to set request header");
 15889:       return NS_OK;
 15889:     }
 19951: 
 19951:     // Check for dangerous cross-site headers
 63932:     bool safeHeader = IsSystemXHR();
 19951:     if (!safeHeader) {
 54922:       // Content-Type isn't always safe, but we'll deal with it in Send()
 19951:       const char *kCrossOriginSafeHeaders[] = {
 54922:         "accept", "accept-language", "content-language", "content-type",
 54922:         "last-event-id"
 19951:       };
 80467:       for (i = 0; i < ArrayLength(kCrossOriginSafeHeaders); ++i) {
 19951:         if (header.LowerCaseEqualsASCII(kCrossOriginSafeHeaders[i])) {
 63932:           safeHeader = true;
 19951:           break;
 19951:         }
 19951:       }
 19951:     }
 19951: 
 19951:     if (!safeHeader) {
114062:       if (!mCORSUnsafeHeaders.Contains(header)) {
 64070:         mCORSUnsafeHeaders.AppendElement(header);
 19951:       }
  4064:     }
114062:   }
  4064: 
  4054:   // We need to set, not add to, the header.
107465:   nsresult rv = httpChannel->SetRequestHeader(header, value, false);
107465:   if (rv == NS_ERROR_INVALID_ARG) {
107465:     return NS_ERROR_DOM_SYNTAX_ERR;
107465:   }
 72497:   if (NS_SUCCEEDED(rv)) {
 72497:     // We'll want to duplicate this header for any replacement channels (eg. on redirect)
 72497:     RequestHeader reqHeader = {
 72497:       nsCString(header), nsCString(value)
 72497:     };
 72497:     mModifiedRequestHeaders.AppendElement(reqHeader);
 72497:   }
 72497:   return rv;
  4051: }
  4051: 
 88284: /* attribute unsigned long timeout; */
 88284: NS_IMETHODIMP
108991: nsXMLHttpRequest::GetTimeout(uint32_t *aTimeout)
 88284: {
113697:   *aTimeout = Timeout();
 88284:   return NS_OK;
 88284: }
 94307: 
 88284: NS_IMETHODIMP
108991: nsXMLHttpRequest::SetTimeout(uint32_t aTimeout)
 88284: {
 97819:   ErrorResult rv;
 94307:   SetTimeout(aTimeout, rv);
 97819:   return rv.ErrorCode();
 94307: }
 94307: 
 94307: void
 97819: nsXMLHttpRequest::SetTimeout(uint32_t aTimeout, ErrorResult& aRv)
 94307: {
 94307:   if (!(mState & (XML_HTTP_REQUEST_ASYNC | XML_HTTP_REQUEST_UNSENT)) &&
 94307:       HasOrHasHadOwner()) {
 94307:     /* Timeout is not supported for synchronous requests with an owning window,
 94307:        per XHR2 spec. */
 94307:     LogMessage("TimeoutSyncXHRWarning", GetOwner());
 97819:     aRv.Throw(NS_ERROR_DOM_INVALID_ACCESS_ERR);
 94307:     return;
 94307:   }
 94307: 
 88284:   mTimeoutMilliseconds = aTimeout;
 88284:   if (mRequestSentTime) {
 88284:     StartTimeoutTimer();
 88284:   }
 88284: }
 88284: 
 88284: void
 88284: nsXMLHttpRequest::StartTimeoutTimer()
 88284: {
 88284:   NS_ABORT_IF_FALSE(mRequestSentTime,
 88284:                     "StartTimeoutTimer mustn't be called before the request was sent!");
 88284:   if (mState & XML_HTTP_REQUEST_DONE) {
 88284:     // do nothing!
 88284:     return;
 88284:   }
 88284: 
 88284:   if (mTimeoutTimer) {
 88284:     mTimeoutTimer->Cancel();
 88284:   }
 88284: 
 88284:   if (!mTimeoutMilliseconds) {
 88284:     return;
 88284:   }
 88284: 
 88284:   if (!mTimeoutTimer) {
 88284:     mTimeoutTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
 88284:   }
108991:   uint32_t elapsed =
108991:     (uint32_t)((PR_Now() - mRequestSentTime) / PR_USEC_PER_MSEC);
 88284:   mTimeoutTimer->InitWithCallback(
 88284:     this,
 88284:     mTimeoutMilliseconds > elapsed ? mTimeoutMilliseconds - elapsed : 0,
 88284:     nsITimer::TYPE_ONE_SHOT
 88284:   );
 88284: }
 88284: 
 94307: /* readonly attribute unsigned short readyState; */
     1: NS_IMETHODIMP
108991: nsXMLHttpRequest::GetReadyState(uint16_t *aState)
     1: {
113697:   *aState = ReadyState();
 94307:   return NS_OK;
 94307: }
 94307: 
 94307: uint16_t
113697: nsXMLHttpRequest::ReadyState()
 94307: {
     1:   // Translate some of our internal states for external consumers
 69662:   if (mState & XML_HTTP_REQUEST_UNSENT) {
 94307:     return UNSENT;
 94307:   }
 94307:   if (mState & (XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT)) {
 94307:     return OPENED;
 94307:   }
 94307:   if (mState & XML_HTTP_REQUEST_HEADERS_RECEIVED) {
 94307:     return HEADERS_RECEIVED;
 94307:   }
 94307:   if (mState & (XML_HTTP_REQUEST_LOADING | XML_HTTP_REQUEST_STOPPED)) {
 94307:     return LOADING;
 94307:   }
 94307:   MOZ_ASSERT(mState & XML_HTTP_REQUEST_DONE);
 94307:   return DONE;
 94307: }
 94307: 
 94307: /* void overrideMimeType(in DOMString mimetype); */
 94307: NS_IMETHODIMP
 94307: nsXMLHttpRequest::SlowOverrideMimeType(const nsAString& aMimeType)
 94307: {
 94307:   OverrideMimeType(aMimeType);
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute boolean multipart; */
     1: NS_IMETHODIMP
 79445: nsXMLHttpRequest::GetMultipart(bool *_retval)
     1: {
113697:   *_retval = Multipart();
     1:   return NS_OK;
     1: }
     1: 
 94307: bool
113697: nsXMLHttpRequest::Multipart()
 94307: {
 94307:   return !!(mState & XML_HTTP_REQUEST_MULTIPART);
 94307: }
 94307: 
     1: NS_IMETHODIMP
 79445: nsXMLHttpRequest::SetMultipart(bool aMultipart)
     1: {
 94307:   nsresult rv = NS_OK;
 94307:   SetMultipart(aMultipart, rv);
 94307:   return rv;
 94307: }
 94307: 
 94307: void
 94307: nsXMLHttpRequest::SetMultipart(bool aMultipart, nsresult& aRv)
 94307: {
 69662:   if (!(mState & XML_HTTP_REQUEST_UNSENT)) {
     1:     // Can't change this while we're in the middle of something.
 94307:     aRv = NS_ERROR_IN_PROGRESS;
 94307:     return;
     1:   }
     1: 
     1:   if (aMultipart) {
     1:     mState |= XML_HTTP_REQUEST_MULTIPART;
     1:   } else {
     1:     mState &= ~XML_HTTP_REQUEST_MULTIPART;
     1:   }
     1: }
     1: 
 13282: /* attribute boolean mozBackgroundRequest; */
 13282: NS_IMETHODIMP
 79445: nsXMLHttpRequest::GetMozBackgroundRequest(bool *_retval)
 13282: {
113697:   *_retval = MozBackgroundRequest();
 13282:   return NS_OK;
 13282: }
 13282: 
 94307: bool
113697: nsXMLHttpRequest::MozBackgroundRequest()
 94307: {
 94307:   return !!(mState & XML_HTTP_REQUEST_BACKGROUND);
 94307: }
 94307: 
 13282: NS_IMETHODIMP
 79445: nsXMLHttpRequest::SetMozBackgroundRequest(bool aMozBackgroundRequest)
 13282: {
 94307:   nsresult rv = NS_OK;
 94307:   SetMozBackgroundRequest(aMozBackgroundRequest, rv);
 94307:   return rv;
 94307: }
 94307: 
 94307: void
 94307: nsXMLHttpRequest::SetMozBackgroundRequest(bool aMozBackgroundRequest, nsresult& aRv)
 94307: {
 79445:   bool privileged;
 94307:   aRv = IsCapabilityEnabled("UniversalXPConnect", &privileged);
 94307:   if (NS_FAILED(aRv)) {
 94307:     return;
 94307:   }
 94307: 
 94307:   if (!privileged) {
 94307:     aRv = NS_ERROR_DOM_SECURITY_ERR;
 94307:     return;
 94307:   }
 13282: 
 69662:   if (!(mState & XML_HTTP_REQUEST_UNSENT)) {
 13282:     // Can't change this while we're in the middle of something.
 94307:     aRv = NS_ERROR_IN_PROGRESS;
 94307:     return;
 13282:   }
 13282: 
 13282:   if (aMozBackgroundRequest) {
 13282:     mState |= XML_HTTP_REQUEST_BACKGROUND;
 13282:   } else {
 13282:     mState &= ~XML_HTTP_REQUEST_BACKGROUND;
 13282:   }
 13282: }
 13282: 
 19954: /* attribute boolean withCredentials; */
 19954: NS_IMETHODIMP
 79445: nsXMLHttpRequest::GetWithCredentials(bool *_retval)
 19954: {
113697:   *_retval = WithCredentials();
 19954:   return NS_OK;
 19954: }
 19954: 
 94307: bool
113697: nsXMLHttpRequest::WithCredentials()
 94307: {
 94307:   return !!(mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS);
 94307: }
 94307: 
 19954: NS_IMETHODIMP
 79445: nsXMLHttpRequest::SetWithCredentials(bool aWithCredentials)
 19954: {
 94307:   nsresult rv = NS_OK;
 94307:   SetWithCredentials(aWithCredentials, rv);
 94307:   return rv;
 94307: }
 94307: 
 94307: void
 94307: nsXMLHttpRequest::SetWithCredentials(bool aWithCredentials, nsresult& aRv)
 94307: {
 19954:   // Return error if we're already processing a request
 19954:   if (XML_HTTP_REQUEST_SENT & mState) {
 94307:     aRv = NS_ERROR_FAILURE;
 94307:     return;
 19954:   }
 19954: 
 84264:   // sync request is not allowed setting withCredentials in window context
 92083:   if (HasOrHasHadOwner() &&
 84264:       !(mState & (XML_HTTP_REQUEST_UNSENT | XML_HTTP_REQUEST_ASYNC))) {
 92083:     LogMessage("WithCredentialsSyncXHRWarning", GetOwner());
 94307:     aRv = NS_ERROR_DOM_INVALID_ACCESS_ERR;
 94307:     return;
 84264:   }
 84264: 
 19954:   if (aWithCredentials) {
 19954:     mState |= XML_HTTP_REQUEST_AC_WITH_CREDENTIALS;
 94307:   } else {
 19954:     mState &= ~XML_HTTP_REQUEST_AC_WITH_CREDENTIALS;
 19954:   }
 19954: }
 19954: 
     1: nsresult
108991: nsXMLHttpRequest::ChangeState(uint32_t aState, bool aBroadcast)
     1: {
     1:   // If we are setting one of the mutually exclusive states,
     1:   // unset those state bits first.
     1:   if (aState & XML_HTTP_REQUEST_LOADSTATES) {
     1:     mState &= ~XML_HTTP_REQUEST_LOADSTATES;
     1:   }
     1:   mState |= aState;
     1:   nsresult rv = NS_OK;
     1: 
 20640:   if (mProgressNotifier &&
 69662:       !(aState & (XML_HTTP_REQUEST_HEADERS_RECEIVED | XML_HTTP_REQUEST_LOADING))) {
 88284:     mProgressTimerIsActive = false;
 20640:     mProgressNotifier->Cancel();
 20640:   }
 20640: 
 54235:   if ((aState & XML_HTTP_REQUEST_LOADSTATES) && // Broadcast load states only
 54235:       aBroadcast &&
 54235:       (mState & XML_HTTP_REQUEST_ASYNC ||
 54235:        aState & XML_HTTP_REQUEST_OPENED ||
 69662:        aState & XML_HTTP_REQUEST_DONE)) {
     1:     nsCOMPtr<nsIDOMEvent> event;
 16665:     rv = CreateReadystatechangeEvent(getter_AddRefs(event));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
106838:     DispatchDOMEvent(nullptr, event, nullptr, nullptr);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
 48889: /*
 48889:  * Simple helper class that just forwards the redirect callback back
 48889:  * to the nsXMLHttpRequest.
 48889:  */
102310: class AsyncVerifyRedirectCallbackForwarder MOZ_FINAL : public nsIAsyncVerifyRedirectCallback
 48889: {
 48889: public:
 48889:   AsyncVerifyRedirectCallbackForwarder(nsXMLHttpRequest *xhr)
 48889:     : mXHR(xhr)
 48889:   {
 48889:   }
 48889: 
 48889:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 48889:   NS_DECL_CYCLE_COLLECTION_CLASS(AsyncVerifyRedirectCallbackForwarder)
 48889: 
 48889:   // nsIAsyncVerifyRedirectCallback implementation
 48889:   NS_IMETHOD OnRedirectVerifyCallback(nsresult result)
 48889:   {
 48889:     mXHR->OnRedirectVerifyCallback(result);
 48889: 
 48889:     return NS_OK;
 48889:   }
 48889: 
 48889: private:
 48889:   nsRefPtr<nsXMLHttpRequest> mXHR;
 48889: };
 48889: 
 48889: NS_IMPL_CYCLE_COLLECTION_CLASS(AsyncVerifyRedirectCallbackForwarder)
 48889: 
 48889: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(AsyncVerifyRedirectCallbackForwarder)
 71743: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mXHR, nsIXMLHttpRequest)
 48889: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 48889: 
 48889: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(AsyncVerifyRedirectCallbackForwarder)
 48889:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mXHR)
 48889: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 48889: 
 48889: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(AsyncVerifyRedirectCallbackForwarder)
 48889:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 48889:   NS_INTERFACE_MAP_ENTRY(nsIAsyncVerifyRedirectCallback)
 48889: NS_INTERFACE_MAP_END
 48889: 
 48889: NS_IMPL_CYCLE_COLLECTING_ADDREF(AsyncVerifyRedirectCallbackForwarder)
 48889: NS_IMPL_CYCLE_COLLECTING_RELEASE(AsyncVerifyRedirectCallbackForwarder)
 48889: 
 48889: 
     1: /////////////////////////////////////////////////////
     1: // nsIChannelEventSink methods:
     1: //
     1: NS_IMETHODIMP
 48889: nsXMLHttpRequest::AsyncOnChannelRedirect(nsIChannel *aOldChannel,
     1:                                          nsIChannel *aNewChannel,
108991:                                          uint32_t    aFlags,
 48889:                                          nsIAsyncVerifyRedirectCallback *callback)
     1: {
     1:   NS_PRECONDITION(aNewChannel, "Redirect without a channel?");
     1: 
  4064:   nsresult rv;
  4054: 
 24084:   if (!NS_IsInternalSameURIRedirect(aOldChannel, aNewChannel, aFlags)) {
 19951:     rv = CheckChannelForCrossSiteRequest(aNewChannel);
 48889:     if (NS_FAILED(rv)) {
 48889:       NS_WARNING("nsXMLHttpRequest::OnChannelRedirect: "
 48889:                  "CheckChannelForCrossSiteRequest returned failure");
 48889:       return rv;
 48889:     }
  4064: 
 19952:     // Disable redirects for preflighted cross-site requests entirely for now
 19951:     // Note, do this after the call to CheckChannelForCrossSiteRequest
 19951:     // to make sure that XML_HTTP_REQUEST_USE_XSITE_AC is up-to-date
 19952:     if ((mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT)) {
 19951:        return NS_ERROR_DOM_BAD_URI;
 13898:     }
 24084:   }
 13898: 
 48889:   // Prepare to receive callback
 48889:   mRedirectCallback = callback;
 48889:   mNewRedirectChannel = aNewChannel;
 48889: 
 13898:   if (mChannelEventSink) {
 48889:     nsRefPtr<AsyncVerifyRedirectCallbackForwarder> fwd =
 48889:       new AsyncVerifyRedirectCallbackForwarder(this);
 48889: 
 48889:     rv = mChannelEventSink->AsyncOnChannelRedirect(aOldChannel,
 48889:                                                    aNewChannel,
 48889:                                                    aFlags, fwd);
 16665:     if (NS_FAILED(rv)) {
106838:         mRedirectCallback = nullptr;
106838:         mNewRedirectChannel = nullptr;
 48889:     }
 48889:     return rv;
 48889:   }
 48889:   OnRedirectVerifyCallback(NS_OK);
 48889:   return NS_OK;
 48889: }
 48889: 
 48889: void
 48889: nsXMLHttpRequest::OnRedirectVerifyCallback(nsresult result)
 48889: {
 48889:   NS_ASSERTION(mRedirectCallback, "mRedirectCallback not set in callback");
 48889:   NS_ASSERTION(mNewRedirectChannel, "mNewRedirectChannel not set in callback");
 48889: 
 72497:   if (NS_SUCCEEDED(result)) {
 48889:     mChannel = mNewRedirectChannel;
 72497: 
 72497:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
 72497:     if (httpChannel) {
 72497:       // Ensure all original headers are duplicated for the new channel (bug #553888)
108991:       for (uint32_t i = mModifiedRequestHeaders.Length(); i > 0; ) {
 72497:         --i;
 72497:         httpChannel->SetRequestHeader(mModifiedRequestHeaders[i].header,
 72497:                                       mModifiedRequestHeaders[i].value,
 80486:                                       false);
 72497:       }
 72497:     }
 72497:   } else {
 80486:     mErrorLoad = true;
 72497:   }
 48889: 
106838:   mNewRedirectChannel = nullptr;
 48889: 
 48889:   mRedirectCallback->OnRedirectVerifyCallback(result);
106838:   mRedirectCallback = nullptr;
     1: }
     1: 
     1: /////////////////////////////////////////////////////
     1: // nsIProgressEventSink methods:
     1: //
     1: 
 78799: void
 79445: nsXMLHttpRequest::MaybeDispatchProgressEvents(bool aFinalProgress)
 78799: {
 88284:   if (aFinalProgress && mProgressTimerIsActive) {
 88284:     mProgressTimerIsActive = false;
 78799:     mProgressNotifier->Cancel();
 78799:   }
 78799: 
 88284:   if (mProgressTimerIsActive ||
 78799:       !mProgressSinceLastProgressEvent ||
 78799:       mErrorLoad ||
 78799:       !(mState & XML_HTTP_REQUEST_ASYNC)) {
 78799:     return;
 78799:   }
 78799: 
 78799:   if (!aFinalProgress) {
 78799:     StartProgressEventTimer();
 78799:   }
 78799: 
 78799:   // We're uploading if our state is XML_HTTP_REQUEST_OPENED or
 78799:   // XML_HTTP_REQUEST_SENT
 78799:   if ((XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT) & mState) {
 78799:     if (aFinalProgress) {
 78799:       mUploadTotal = mUploadTransferred;
 78799:       mUploadProgressMax = mUploadProgress;
 78799:     }
 78799:     if (mUpload && !mUploadComplete) {
 78799:       DispatchProgressEvent(mUpload, NS_LITERAL_STRING(PROGRESS_STR),
 80486:                             true, mUploadLengthComputable, mUploadTransferred,
 78799:                             mUploadTotal, mUploadProgress,
 78799:                             mUploadProgressMax);
 78799:     }
 78799:   } else {
 78799:     if (aFinalProgress) {
 78799:       mLoadTotal = mLoadTransferred;
 80486:     }
 80486:     mInLoadProgressEvent = true;
 78799:     DispatchProgressEvent(this, NS_LITERAL_STRING(PROGRESS_STR),
 80486:                           true, mLoadLengthComputable, mLoadTransferred,
 78799:                           mLoadTotal, mLoadTransferred, mLoadTotal);
 80486:     mInLoadProgressEvent = false;
 78801:     if (mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT ||
 78801:         mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER) {
 78801:       mResponseBody.Truncate();
 78801:       mResponseText.Truncate();
106838:       mResultArrayBuffer = nullptr;
 78801:     }
 78799:   }
 78799: 
 80486:   mProgressSinceLastProgressEvent = false;
 78799: }
 78799: 
     1: NS_IMETHODIMP
108991: nsXMLHttpRequest::OnProgress(nsIRequest *aRequest, nsISupports *aContext, uint64_t aProgress, uint64_t aProgressMax)
     1: {
 19152:   // We're in middle of processing multipart headers and we don't want to report
 19152:   // any progress because upload's 'load' is dispatched when we start to load
 19152:   // the first response.
 19152:   if (XML_HTTP_REQUEST_MPART_HEADERS & mState) {
 19152:     return NS_OK;
 19152:   }
 19152: 
     1:   // We're uploading if our state is XML_HTTP_REQUEST_OPENED or
     1:   // XML_HTTP_REQUEST_SENT
 79445:   bool upload = !!((XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT) & mState);
 16665:   // When uploading, OnProgress reports also headers in aProgress and aProgressMax.
 16665:   // So, try to remove the headers, if possible.
 79445:   bool lengthComputable = (aProgressMax != LL_MAXUINT);
 16665:   if (upload) {
108991:     uint64_t loaded = aProgress;
108991:     uint64_t total = aProgressMax;
 16665:     if (lengthComputable) {
108991:       uint64_t headerSize = aProgressMax - mUploadTotal;
 16665:       loaded -= headerSize;
 16665:       total -= headerSize;
 16665:     }
 78799:     mUploadLengthComputable = lengthComputable;
 16665:     mUploadTransferred = loaded;
 20640:     mUploadProgress = aProgress;
 20640:     mUploadProgressMax = aProgressMax;
 80486:     mProgressSinceLastProgressEvent = true;
 80486: 
 80486:     MaybeDispatchProgressEvents(false);
 20640:   } else {
 20640:     mLoadLengthComputable = lengthComputable;
 78799:     mLoadTotal = lengthComputable ? aProgressMax : 0;
 78799:     
 78799:     // Don't dispatch progress events here. OnDataAvailable will take care
 78799:     // of that.
 16665:   }
     1: 
     1:   if (mProgressEventSink) {
     1:     mProgressEventSink->OnProgress(aRequest, aContext, aProgress,
     1:                                    aProgressMax);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXMLHttpRequest::OnStatus(nsIRequest *aRequest, nsISupports *aContext, nsresult aStatus, const PRUnichar *aStatusArg)
     1: {
     1:   if (mProgressEventSink) {
     1:     mProgressEventSink->OnStatus(aRequest, aContext, aStatus, aStatusArg);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
 19953: nsXMLHttpRequest::AllowUploadProgress()
 19953: {
 19953:   return !(mState & XML_HTTP_REQUEST_USE_XSITE_AC) ||
 19953:     (mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT);
 19953: }
 19953: 
     1: /////////////////////////////////////////////////////
     1: // nsIInterfaceRequestor methods:
     1: //
     1: NS_IMETHODIMP
     1: nsXMLHttpRequest::GetInterface(const nsIID & aIID, void **aResult)
     1: {
 14092:   nsresult rv;
 14092: 
     1:   // Make sure to return ourselves for the channel event sink interface and
     1:   // progress event sink interface, no matter what.  We can forward these to
     1:   // mNotificationCallbacks if it wants to get notifications for them.  But we
     1:   // need to see these notifications for proper functioning.
     1:   if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
     1:     mChannelEventSink = do_GetInterface(mNotificationCallbacks);
111437:     *aResult = static_cast<nsIChannelEventSink*>(EnsureXPCOMifier().get());
     1:     return NS_OK;
     1:   } else if (aIID.Equals(NS_GET_IID(nsIProgressEventSink))) {
     1:     mProgressEventSink = do_GetInterface(mNotificationCallbacks);
111437:     *aResult = static_cast<nsIProgressEventSink*>(EnsureXPCOMifier().get());
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Now give mNotificationCallbacks (if non-null) a chance to return the
 13239:   // desired interface.
     1:   if (mNotificationCallbacks) {
 14092:     rv = mNotificationCallbacks->GetInterface(aIID, aResult);
     1:     if (NS_SUCCEEDED(rv)) {
     1:       NS_ASSERTION(*aResult, "Lying nsIInterfaceRequestor implementation!");
     1:       return rv;
     1:     }
     1:   }
     1: 
 13282:   if (mState & XML_HTTP_REQUEST_BACKGROUND) {
 13282:     nsCOMPtr<nsIInterfaceRequestor> badCertHandler(do_CreateInstance(NS_BADCERTHANDLER_CONTRACTID, &rv));
 13282: 
 13282:     // Ignore failure to get component, we may not have all its dependencies
 13282:     // available
 13282:     if (NS_SUCCEEDED(rv)) {
 13282:       rv = badCertHandler->GetInterface(aIID, aResult);
 13282:       if (NS_SUCCEEDED(rv))
 13282:         return rv;
 13282:     }
 13282:   }
 14092:   else if (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) ||
 14092:            aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
 14092:     nsCOMPtr<nsIPromptFactory> wwatch =
 14092:       do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
 14092:     NS_ENSURE_SUCCESS(rv, rv);
 14092: 
 14092:     // Get the an auth prompter for our window so that the parenting
 14092:     // of the dialogs works as it should when using tabs.
 14092: 
 14092:     nsCOMPtr<nsIDOMWindow> window;
 92083:     if (GetOwner()) {
 92083:       window = GetOwner()->GetOuterWindow();
 14092:     }
 14092: 
 14092:     return wwatch->GetPrompt(window, aIID,
 14092:                              reinterpret_cast<void**>(aResult));
111437:   }
111437:   // Now check for the various XHR non-DOM interfaces, except
111437:   // nsIProgressEventSink and nsIChannelEventSink which we already
111437:   // handled above.
111437:   else if (aIID.Equals(NS_GET_IID(nsIStreamListener))) {
111437:     *aResult = static_cast<nsIStreamListener*>(EnsureXPCOMifier().get());
111437:     return NS_OK;
111437:   }
111437:   else if (aIID.Equals(NS_GET_IID(nsIRequestObserver))) {
111437:     *aResult = static_cast<nsIRequestObserver*>(EnsureXPCOMifier().get());
111437:     return NS_OK;
111437:   }
111437:   else if (aIID.Equals(NS_GET_IID(nsITimerCallback))) {
111437:     *aResult = static_cast<nsITimerCallback*>(EnsureXPCOMifier().get());
111437:     return NS_OK;
 14092:   }
 13282: 
     1:   return QueryInterface(aIID, aResult);
     1: }
     1: 
 94512: JS::Value
 97819: nsXMLHttpRequest::GetInterface(JSContext* aCx, nsIJSIID* aIID, ErrorResult& aRv)
 94512: {
 94512:   const nsID* iid = aIID->GetID();
 94512:   nsCOMPtr<nsISupports> result;
 94512:   JS::Value v = JSVAL_NULL;
 94512:   aRv = GetInterface(*iid, getter_AddRefs(result));
 97819:   NS_ENSURE_FALSE(aRv.Failed(), JSVAL_NULL);
 94512: 
 94512:   JSObject* global = JS_GetGlobalForObject(aCx, GetWrapper());
 94512:   aRv = nsContentUtils::WrapNative(aCx, global, result, iid, &v);
 97819:   return aRv.Failed() ? JSVAL_NULL : v;
 94512: }
 94512: 
 94307: nsXMLHttpRequestUpload*
113697: nsXMLHttpRequest::Upload()
 94307: {
 94307:   if (!mUpload) {
 94307:     mUpload = new nsXMLHttpRequestUpload(this);
 94307:   }
 94307:   return mUpload;
 94307: }
 94307: 
 16665: NS_IMETHODIMP
 16665: nsXMLHttpRequest::GetUpload(nsIXMLHttpRequestUpload** aUpload)
 16665: {
113697:   nsRefPtr<nsXMLHttpRequestUpload> upload = Upload();
 94307:   upload.forget(aUpload);
 16665:   return NS_OK;
 16665: }
 16665: 
101616: bool
113697: nsXMLHttpRequest::MozAnon()
101616: {
101616:   return mIsAnon;
101616: }
101616: 
101616: NS_IMETHODIMP
101616: nsXMLHttpRequest::GetMozAnon(bool* aAnon)
101616: {
113697:   *aAnon = MozAnon();
101616:   return NS_OK;
101616: }
101616: 
101616: bool
113697: nsXMLHttpRequest::MozSystem()
101616: {
101616:   return IsSystemXHR();
101616: }
101616: 
101616: NS_IMETHODIMP
101616: nsXMLHttpRequest::GetMozSystem(bool* aSystem)
101616: {
113697:   *aSystem = MozSystem();
101616:   return NS_OK;
101616: }
101616: 
 88284: void
 88284: nsXMLHttpRequest::HandleTimeoutCallback()
 88284: {
 88284:   if (mState & XML_HTTP_REQUEST_DONE) {
 88284:     NS_NOTREACHED("nsXMLHttpRequest::HandleTimeoutCallback with completed request");
 88284:     // do nothing!
 88284:     return;
 88284:   }
 88284: 
 88284:   CloseRequestWithError(NS_LITERAL_STRING(TIMEOUT_STR),
 88284:                         XML_HTTP_REQUEST_TIMED_OUT);
 88284: }
 88284: 
 20640: NS_IMETHODIMP
 20640: nsXMLHttpRequest::Notify(nsITimer* aTimer)
 20640: {
 88284:   if (mProgressNotifier == aTimer) {
 88284:     HandleProgressTimerCallback();
 88284:     return NS_OK;
 88284:   }
 88284: 
 88284:   if (mTimeoutTimer == aTimer) {
 88284:     HandleTimeoutCallback();
 88284:     return NS_OK;
 88284:   }
 88284: 
 88284:   // Just in case some JS user wants to QI to nsITimerCallback and play with us...
 88284:   NS_WARNING("Unexpected timer!");
 88284:   return NS_ERROR_INVALID_POINTER;
 88284: }
 88284: 
 88284: void
 88284: nsXMLHttpRequest::HandleProgressTimerCallback()
 88284: {
 88284:   mProgressTimerIsActive = false;
 20640:   if (!(XML_HTTP_REQUEST_MPART_HEADERS & mState)) {
 80486:     MaybeDispatchProgressEvents(false);
 78799:   }
 20640: }
 20640: 
 20640: void
 20640: nsXMLHttpRequest::StartProgressEventTimer()
 20640: {
 20640:   if (!mProgressNotifier) {
 20640:     mProgressNotifier = do_CreateInstance(NS_TIMER_CONTRACTID);
 20640:   }
 20640:   if (mProgressNotifier) {
 80486:     mProgressEventWasDelayed = false;
 88284:     mProgressTimerIsActive = true;
 20640:     mProgressNotifier->Cancel();
 20640:     mProgressNotifier->InitWithCallback(this, NS_PROGRESS_EVENT_INTERVAL,
 20640:                                         nsITimer::TYPE_ONE_SHOT);
 20640:   }
 20640: }
 20640: 
111437: already_AddRefed<nsXMLHttpRequestXPCOMifier>
111437: nsXMLHttpRequest::EnsureXPCOMifier()
111437: {
111437:   if (!mXPCOMifier) {
111437:     mXPCOMifier = new nsXMLHttpRequestXPCOMifier(this);
111437:   }
111437:   nsRefPtr<nsXMLHttpRequestXPCOMifier> newRef(mXPCOMifier);
111437:   return newRef.forget();
111437: }
111437: 
     1: NS_IMPL_ISUPPORTS1(nsXMLHttpRequest::nsHeaderVisitor, nsIHttpHeaderVisitor)
     1: 
     1: NS_IMETHODIMP nsXMLHttpRequest::
     1: nsHeaderVisitor::VisitHeader(const nsACString &header, const nsACString &value)
     1: {
 21639:     // See bug #380418. Hide "Set-Cookie" headers from non-chrome scripts.
 79445:     bool chrome = false; // default to false in case IsCapabilityEnabled fails
 21639:     IsCapabilityEnabled("UniversalXPConnect", &chrome);
 21639:     if (!chrome &&
 21639:          (header.LowerCaseEqualsASCII("set-cookie") ||
 21639:           header.LowerCaseEqualsASCII("set-cookie2"))) {
 21639:         NS_WARNING("blocked access to response header");
 21639:     } else {
     1:         mHeaders.Append(header);
     1:         mHeaders.Append(": ");
     1:         mHeaders.Append(value);
106577:         mHeaders.Append("\r\n");
 21639:     }
     1:     return NS_OK;
     1: }
     1: 
     1: // DOM event class to handle progress notifications
 16665: nsXMLHttpProgressEvent::nsXMLHttpProgressEvent(nsIDOMProgressEvent* aInner,
108991:                                                uint64_t aCurrentProgress,
108991:                                                uint64_t aMaxProgress,
 79614:                                                nsPIDOMWindow* aWindow)
 79614:   : mWindow(aWindow)
     1: {
111242:   mInner = aInner;
     1:   mCurProgress = aCurrentProgress;
     1:   mMaxProgress = aMaxProgress;
     1: }
     1: 
     1: nsXMLHttpProgressEvent::~nsXMLHttpProgressEvent()
     1: {}
     1: 
 16665: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXMLHttpProgressEvent)
 16665: 
 40490: DOMCI_DATA(XMLHttpProgressEvent, nsXMLHttpProgressEvent)
 40490: 
 16665: // QueryInterface implementation for nsXMLHttpProgressEvent
 16665: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsXMLHttpProgressEvent)
 16665:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMProgressEvent)
 16665:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEvent, nsIDOMProgressEvent)
 16665:   NS_INTERFACE_MAP_ENTRY(nsIDOMProgressEvent)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMLSProgressEvent)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(XMLHttpProgressEvent)
     1: NS_INTERFACE_MAP_END
     1: 
 16665: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsXMLHttpProgressEvent)
 16665: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsXMLHttpProgressEvent)
 16665: 
 16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsXMLHttpProgressEvent)
 16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mInner);
 79614:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mWindow);
 16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 16665: 
 16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsXMLHttpProgressEvent)
111242:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mInner)
 79614:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mWindow);
 16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
     1: 
     1: NS_IMETHODIMP nsXMLHttpProgressEvent::GetInput(nsIDOMLSInput * *aInput)
     1: {
106838:   *aInput = nullptr;
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
 79614: void
 79614: nsXMLHttpProgressEvent::WarnAboutLSProgressEvent(nsIDocument::DeprecatedOperations aOperation)
 79614: {
 79614:   if (!mWindow) {
 79614:     return;
 79614:   }
 79614:   nsCOMPtr<nsIDocument> document =
 79614:     do_QueryInterface(mWindow->GetExtantDocument());
 79614:   if (!document) {
 79614:     return;
 79614:   }
 79614:   document->WarnOnceAbout(aOperation);
 79614: }
 79614: 
108991: NS_IMETHODIMP nsXMLHttpProgressEvent::GetPosition(uint32_t *aPosition)
     1: {
 79614:   WarnAboutLSProgressEvent(nsIDocument::ePosition);
     1:   // XXX can we change the iface?
     1:   LL_L2UI(*aPosition, mCurProgress);
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsXMLHttpProgressEvent::GetTotalSize(uint32_t *aTotalSize)
     1: {
 79614:   WarnAboutLSProgressEvent(nsIDocument::eTotalSize);
     1:   // XXX can we change the iface?
     1:   LL_L2UI(*aTotalSize, mMaxProgress);
     1:   return NS_OK;
     1: }
111437: 
111437: // nsXMLHttpRequestXPCOMifier implementation
111437: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsXMLHttpRequestXPCOMifier)
111437:   NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
111437:   NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
111437:   NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
111437:   NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)
111437:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
111437:   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
111437:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStreamListener)
111437: NS_INTERFACE_MAP_END
111437: 
111437: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsXMLHttpRequestXPCOMifier)
111437: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsXMLHttpRequestXPCOMifier)
111437: 
111437: // Can't NS_IMPL_CYCLE_COLLECTION_1 because mXHR has ambiguous
111437: // inheritance from nsISupports.
111437: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXMLHttpRequestXPCOMifier)
111437: 
111437: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsXMLHttpRequestXPCOMifier)
111437: if (tmp->mXHR) {
111437:   tmp->mXHR->mXPCOMifier = nullptr;
111437: }
111437: NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mXHR)
111437: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
111437: 
111437: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsXMLHttpRequestXPCOMifier)
111437: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mXHR, nsIXMLHttpRequest)
111437: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
111437: 
111437: NS_IMETHODIMP
111437: nsXMLHttpRequestXPCOMifier::GetInterface(const nsIID & aIID, void **aResult)
111437: {
111437:   // Return ourselves for the things we implement (except
111437:   // nsIInterfaceRequestor) and the XHR for the rest.
111437:   if (!aIID.Equals(NS_GET_IID(nsIInterfaceRequestor))) {
111437:     nsresult rv = QueryInterface(aIID, aResult);
111437:     if (NS_SUCCEEDED(rv)) {
111437:       return rv;
111437:     }
111437:   }
111437: 
111437:   return mXHR->GetInterface(aIID, aResult);
111437: }
