36949: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
36949:  * ***** BEGIN LICENSE BLOCK *****
36949:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
36949:  *
36949:  * The contents of this file are subject to the Mozilla Public License Version
36949:  * 1.1 (the "License"); you may not use this file except in compliance with
36949:  * the License. You may obtain a copy of the License at
36949:  * http://www.mozilla.org/MPL/
36949:  *
36949:  * Software distributed under the License is distributed on an "AS IS" basis,
36949:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
36949:  * for the specific language governing rights and limitations under the
36949:  * License.
36949:  *
36949:  * The Original Code is Mozilla Corporation code.
36949:  *
36949:  * The Initial Developer of the Original Code is Mozilla Corporation.
36949:  * Portions created by the Initial Developer are Copyright (C) 2009
36949:  * the Initial Developer. All Rights Reserved.
36949:  *
36949:  * Contributor(s):
36949:  *   Stuart Parmenter <stuart@mozilla.com>
36949:  *   Masayuki Nakano <masayuki@d-toybox.com>
36949:  *   Mats Palmgren <mats.palmgren@bredband.net>
36949:  *   John Daggett <jdaggett@mozilla.com>
36949:  *   Jonathan Kew <jfkthame@gmail.com>
36949:  *
36949:  * Alternatively, the contents of this file may be used under the terms of
36949:  * either the GNU General Public License Version 2 or later (the "GPL"), or
36949:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
36949:  * in which case the provisions of the GPL or the LGPL are applicable instead
36949:  * of those above. If you wish to allow use of your version of this file only
36949:  * under the terms of either the GPL or the LGPL, and not to allow others to
36949:  * use your version of this file under the terms of the MPL, indicate your
36949:  * decision by deleting the provisions above and replace them with the notice
36949:  * and other provisions required by the GPL or the LGPL. If you do not delete
36949:  * the provisions above, a recipient may use your version of this file under
36949:  * the terms of any one of the MPL, the GPL or the LGPL.
36949:  *
36949:  * ***** END LICENSE BLOCK ***** */
36949: 
36949: #include "gfxFT2FontList.h"
36949: #include "gfxUserFontSet.h"
36949: #include "gfxFontUtils.h"
36949: 
36949: #include "ft2build.h"
36949: #include FT_FREETYPE_H
36949: #include "gfxFT2Fonts.h"
36949: 
36949: #include "nsServiceManagerUtils.h"
36949: #include "nsTArray.h"
36949: #include "nsUnicharUtils.h"
36949: 
36949: #include "nsDirectoryServiceUtils.h"
36949: #include "nsDirectoryServiceDefs.h"
36949: #include "nsAppDirectoryServiceDefs.h"
36949: #include "nsISimpleEnumerator.h"
36949: 
36949: #ifdef XP_WIN
48022: #include "nsIWindowsRegKey.h"
36949: #include <windows.h>
36949: #endif
36949: 
36949: #define ROUND(x) floor((x) + 0.5)
36949: 
36949: #ifdef PR_LOGGING
36949: static PRLogModuleInfo *gFontInfoLog = PR_NewLogModule("fontInfoLog");
36949: #endif /* PR_LOGGING */
36949: 
48022: #ifdef ANDROID
48022: #include "gfxAndroidPlatform.h"
48022: #include <dirent.h>
48022: #include <android/log.h>
48022: #define ALOG(args...)  __android_log_print(ANDROID_LOG_INFO, "Gecko" , ## args)
48022: 
48022: #endif
36949: #define LOG(args) PR_LOG(gFontInfoLog, PR_LOG_DEBUG, args)
36949: #define LOG_ENABLED() PR_LOG_TEST(gFontInfoLog, PR_LOG_DEBUG)
36949: 
36949: static __inline void
36949: BuildKeyNameFromFontName(nsAString &aName)
36949: {
48022: #ifdef XP_WIN
36949:     if (aName.Length() >= LF_FACESIZE)
36949:         aName.Truncate(LF_FACESIZE - 1);
48022: #endif
36949:     ToLowerCase(aName);
36949: }
36949: 
36949: /***************************************************************
36949:  *
36949:  * gfxFT2FontList
36949:  *
36949:  */
36949: 
36949: // For Mobile, we use gfxFT2Fonts, and we build the font list by directly scanning
36949: // the system's Fonts directory for OpenType and TrueType files.
36949: //
36949: // FontEntry is currently defined in gfxFT2Fonts.h, but will probably be moved here
36949: // as part of the Freetype/Linux font restructuring for Harfbuzz integration.
36949: //
36949: // TODO: investigate startup performance - we might be able to improve by avoiding
36949: // the creation of FT_Faces here, and just reading names directly from the file;
36949: // or even consider caching a mapping from font family name to (list of) filenames,
36949: // so that we don't have to scan all the files before we can do any font lookups.
36949: 
36949: gfxFT2FontList::gfxFT2FontList()
36949: {
36949: }
36949: 
36949: void
36949: gfxFT2FontList::AppendFacesFromFontFile(const PRUnichar *aFileName)
36949: {
48022:     AppendFacesFromFontFile(NS_ConvertUTF16toUTF8(aFileName).get());
48022: }
48022: 
48022: void
48022: gfxFT2FontList::AppendFacesFromFontFile(const char *aFileName)
48022: {
48022: #ifdef XP_WIN
36949:     FT_Library ftLibrary = gfxWindowsPlatform::GetPlatform()->GetFTLibrary();
48022: #elif defined(ANDROID)
48022:     FT_Library ftLibrary = gfxAndroidPlatform::GetPlatform()->GetFTLibrary();
48022: #endif
36949:     FT_Face dummy;
48022:     if (FT_Err_Ok == FT_New_Face(ftLibrary, aFileName, -1, &dummy)) {
36949:         for (FT_Long i = 0; i < dummy->num_faces; i++) {
36949:             FT_Face face;
48022:             if (FT_Err_Ok != FT_New_Face(ftLibrary, aFileName, i, &face))
36949:                 continue;
36949: 
36949:             FontEntry* fe = FontEntry::CreateFontEntryFromFace(face);
36949:             if (fe) {
36949:                 NS_ConvertUTF8toUTF16 name(face->family_name);
36949:                 BuildKeyNameFromFontName(name);       
36949:                 gfxFontFamily *family = mFontFamilies.GetWeak(name);
36949:                 if (!family) {
36949:                     family = new gfxFontFamily(name);
36949:                     mFontFamilies.Put(name, family);
38060:                     if (mBadUnderlineFamilyNames.Contains(name))
37599:                         family->SetBadUnderlineFamily();
36949:                 }
36949:                 family->AddFontEntry(fe);
36967:                 fe->SetFamily(family);
36949:                 family->SetHasStyles(PR_TRUE);
37599:                 if (family->IsBadUnderlineFamily())
37599:                     fe->mIsBadUnderlineFont = PR_TRUE;
36949: #ifdef PR_LOGGING
36949:                 if (LOG_ENABLED()) {
36949:                     LOG(("(fontinit) added (%s) to family (%s)"
36949:                          " with style: %s weight: %d stretch: %d",
36949:                          NS_ConvertUTF16toUTF8(fe->Name()).get(), 
36949:                          NS_ConvertUTF16toUTF8(family->Name()).get(), 
36949:                          fe->IsItalic() ? "italic" : "normal",
36949:                          fe->Weight(), fe->Stretch()));
36949:                 }
36949: #endif
36949:             }
36949:         }
36949:         FT_Done_Face(dummy);
36949:     }
36949: }
36949: 
36949: void
36949: gfxFT2FontList::FindFonts()
36949: {
48022: #ifdef XP_WIN
36949:     nsTArray<nsString> searchPaths(3);
36949:     nsTArray<nsString> fontPatterns(3);
36949:     fontPatterns.AppendElement(NS_LITERAL_STRING("\\*.ttf"));
36949:     fontPatterns.AppendElement(NS_LITERAL_STRING("\\*.ttc"));
36949:     fontPatterns.AppendElement(NS_LITERAL_STRING("\\*.otf"));
36949:     wchar_t pathBuf[256];
36949:     SHGetSpecialFolderPathW(0, pathBuf, CSIDL_WINDOWS, 0);
36949:     searchPaths.AppendElement(pathBuf);
36949:     SHGetSpecialFolderPathW(0, pathBuf, CSIDL_FONTS, 0);
36949:     searchPaths.AppendElement(pathBuf);
36949:     nsCOMPtr<nsIFile> resDir;
36949:     NS_GetSpecialDirectory(NS_APP_RES_DIR, getter_AddRefs(resDir));
36949:     if (resDir) {
36949:         resDir->Append(NS_LITERAL_STRING("fonts"));
36949:         nsAutoString resPath;
36949:         resDir->GetPath(resPath);
36949:         searchPaths.AppendElement(resPath);
36949:     }
36949:     WIN32_FIND_DATAW results;
36949:     for (PRUint32 i = 0;  i < searchPaths.Length(); i++) {
36949:         const nsString& path(searchPaths[i]);
36949:         for (PRUint32 j = 0; j < fontPatterns.Length(); j++) { 
36949:             nsAutoString pattern(path);
36949:             pattern.Append(fontPatterns[j]);
36949:             HANDLE handle = FindFirstFileExW(pattern.get(),
36949:                                              FindExInfoStandard,
36949:                                              &results,
36949:                                              FindExSearchNameMatch,
36949:                                              NULL,
36949:                                              0);
36949:             PRBool moreFiles = handle != INVALID_HANDLE_VALUE;
36949:             while (moreFiles) {
36949:                 nsAutoString filePath(path);
36949:                 filePath.AppendLiteral("\\");
36949:                 filePath.Append(results.cFileName);
36949:                 AppendFacesFromFontFile(static_cast<const PRUnichar*>(filePath.get()));
36949:                 moreFiles = FindNextFile(handle, &results);
36949:             }
36949:             if (handle != INVALID_HANDLE_VALUE)
36949:                 FindClose(handle);
36949:         }
36949:     }
48022: #elif defined(ANDROID)
48022:     gfxFontCache *fc = gfxFontCache::GetCache();
48022:     if (fc)
48022:         fc->AgeAllGenerations();
48022:     mPrefFonts.Clear();
48022:     mCodepointsWithNoFonts.reset();
48022: 
48022:     DIR *d = opendir("/system/fonts");
48022:     struct dirent *ent = NULL;
48022:     while(d && (ent = readdir(d)) != NULL) {
48022:         int namelen = strlen(ent->d_name);
48022:         if (namelen > 4 &&
48022:             strcasecmp(ent->d_name + namelen - 4, ".ttf") == 0)
48022:         {
48022:             nsCString s("/system/fonts");
48022:             s.Append("/");
48022:             s.Append(nsDependentCString(ent->d_name));
48022: 
48022:             AppendFacesFromFontFile(nsPromiseFlatCString(s).get());
48022:         }
48022:     }
48022: 
48022:     mCodepointsWithNoFonts.SetRange(0,0x1f);     // C0 controls
48022:     mCodepointsWithNoFonts.SetRange(0x7f,0x9f);  // C1 controls
48022: 
48022: #endif // XP_WIN && ANDROID
36949: }
36949: 
57104: nsresult
36949: gfxFT2FontList::InitFontList()
36949: {
37618:     // reset font lists
37618:     gfxPlatformFontList::InitFontList();
36949:     
36949:     FindFonts();
57104: 
57104:     return NS_OK;
36949: }
36949: 
36949: struct FullFontNameSearch {
36949:     FullFontNameSearch(const nsAString& aFullName)
36949:         : mFullName(aFullName), mFontEntry(nsnull)
36949:     { }
36949: 
36949:     nsString     mFullName;
36949:     gfxFontEntry *mFontEntry;
36949: };
36949: 
36949: // callback called for each family name, based on the assumption that the 
36949: // first part of the full name is the family name
36949: static PLDHashOperator
36949: FindFullName(nsStringHashKey::KeyType aKey,
36949:              nsRefPtr<gfxFontFamily>& aFontFamily,
36949:              void* userArg)
36949: {
36949:     FullFontNameSearch *data = reinterpret_cast<FullFontNameSearch*>(userArg);
36949: 
36949:     // does the family name match up to the length of the family name?
36949:     const nsString& family = aFontFamily->Name();
36949:     
36949:     nsString fullNameFamily;
36949:     data->mFullName.Left(fullNameFamily, family.Length());
36949: 
36949:     // if so, iterate over faces in this family to see if there is a match
36949:     if (family.Equals(fullNameFamily)) {
36949:         nsTArray<nsRefPtr<gfxFontEntry> >& fontList = aFontFamily->GetFontList();
36949:         int index, len = fontList.Length();
36949:         for (index = 0; index < len; index++) {
36949:             if (fontList[index]->Name().Equals(data->mFullName)) {
36949:                 data->mFontEntry = fontList[index];
36949:                 return PL_DHASH_STOP;
36949:             }
36949:         }
36949:     }
36949: 
36949:     return PL_DHASH_NEXT;
36949: }
36949: 
36949: gfxFontEntry* 
36949: gfxFT2FontList::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
36949:                                        const nsAString& aFontName)
36949: {
36949:     // walk over list of names
36949:     FullFontNameSearch data(aFontName);
36949: 
36949:     mFontFamilies.Enumerate(FindFullName, &data);
36949: 
36949:     return data.mFontEntry;
36949: }
36949: 
36949: gfxFontEntry*
36949: gfxFT2FontList::GetDefaultFont(const gfxFontStyle* aStyle, PRBool& aNeedsBold)
36949: {
36949: #ifdef XP_WIN
36949:     HGDIOBJ hGDI = ::GetStockObject(SYSTEM_FONT);
36949:     LOGFONTW logFont;
36949:     if (hGDI && ::GetObjectW(hGDI, sizeof(logFont), &logFont)) {
36949:         nsAutoString resolvedName;
36949:         if (ResolveFontName(nsDependentString(logFont.lfFaceName), resolvedName)) {
36949:             return FindFontForFamily(resolvedName, aStyle, aNeedsBold);
36949:         }
36949:     }
48022: #elif defined(ANDROID)
48022:     nsAutoString resolvedName;
48022:     if (ResolveFontName(nsDependentString(NS_LITERAL_STRING("Droid Sans")), 
48022:                         resolvedName))
48022:         return FindFontForFamily(resolvedName, aStyle, aNeedsBold);
36949: #endif
36949:     /* TODO: what about Qt or other platforms that may use this? */
36949:     return nsnull;
36949: }
36949: 
36949: gfxFontEntry*
36949: gfxFT2FontList::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
36949:                                  const PRUint8 *aFontData,
36949:                                  PRUint32 aLength)
36949: {
36949:     // The FT2 font needs the font data to persist, so we do NOT free it here
36949:     // but instead pass ownership to the font entry.
36949:     // Deallocation will happen later, when the font face is destroyed.
36949:     return FontEntry::CreateFontEntry(*aProxyEntry, aFontData, aLength);
36949: }
