 42611: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 42611: 
 72995: 
104368: #include "ipc/AutoOpenSurface.h"
 72995: #include "mozilla/layers/PLayers.h"
 72995: #include "mozilla/layers/ShadowLayers.h"
 72995: #include "ShadowBufferD3D9.h"
 42611: 
 42611: #include "gfxImageSurface.h"
 42611: #include "gfxWindowsSurface.h"
 52175: #include "gfxWindowsPlatform.h"
 42611: 
 72995: #include "CanvasLayerD3D9.h"
 72995: 
 42611: namespace mozilla {
 42611: namespace layers {
 42611: 
 42611: CanvasLayerD3D9::~CanvasLayerD3D9()
 42611: {
 53980:   if (mD3DManager) {
 53784:     mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
 53784:   }
 42611: }
 42611: 
 42611: void
 42611: CanvasLayerD3D9::Initialize(const Data& aData)
 42611: {
 42611:   NS_ASSERTION(mSurface == nsnull, "BasicCanvasLayer::Initialize called twice!");
 42611: 
 82414:   if (aData.mDrawTarget) {
 82414:     mDrawTarget = aData.mDrawTarget;
106547:     mSurface = gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(mDrawTarget);
 82414:     mNeedsYFlip = false;
 82414:     mDataIsPremultiplied = true;
 82414:   } else if (aData.mSurface) {
 42611:     mSurface = aData.mSurface;
 42611:     NS_ASSERTION(aData.mGLContext == nsnull,
 42611:                  "CanvasLayer can't have both surface and GLContext");
 80486:     mNeedsYFlip = false;
 80486:     mDataIsPremultiplied = true;
 42611:   } else if (aData.mGLContext) {
 47909:     NS_ASSERTION(aData.mGLContext->IsOffscreen(), "canvas gl context isn't offscreen");
 42611:     mGLContext = aData.mGLContext;
 47909:     mCanvasFramebuffer = mGLContext->GetOffscreenFBO();
 51316:     mDataIsPremultiplied = aData.mGLBufferIsPremultiplied;
 80486:     mNeedsYFlip = true;
 42611:   } else {
 82414:     NS_ERROR("CanvasLayer created without mSurface, mGLContext or mDrawTarget?");
 42611:   }
 42611: 
 42611:   mBounds.SetRect(0, 0, aData.mSize.width, aData.mSize.height);
 42611: 
 53785:   CreateTexture();
 49317: }
 42611: 
 42611: void
 64540: CanvasLayerD3D9::UpdateSurface()
 42611: {
 87505:   if (!mDirty && mTexture)
 64540:     return;
 80486:   mDirty = false;
 64540: 
 42611:   if (!mTexture) {
 53785:     CreateTexture();
 87505: 
 87505:     if (!mTexture) {
 87505:       NS_WARNING("CanvasLayerD3D9::Updated called but no texture present and creation failed!");
 42611:       return;
 42611:     }
 87505:   }
 42611: 
 42611:   if (mGLContext) {
 42611:     // WebGL reads entire surface.
 72995:     LockTextureRectD3D9 textureLock(mTexture);
 72995:     if (!textureLock.HasLock()) {
 53786:       NS_WARNING("Failed to lock CanvasLayer texture.");
 53786:       return;
 53786:     }
 42611: 
 72995:     D3DLOCKED_RECT r = textureLock.GetLockRect();
 72995: 
 94020:     const bool stridesMatch = r.Pitch == mBounds.width * 4;
 94020: 
 42611:     PRUint8 *destination;
 94020:     if (!stridesMatch) {
 94020:       destination = GetTempBlob(mBounds.width * mBounds.height * 4);
 42611:     } else {
 94020:       DiscardTempBlob();
 42611:       destination = (PRUint8*)r.pBits;
 42611:     }
 42611: 
 80020:     mGLContext->MakeCurrent();
 80020: 
 47909:     PRUint32 currentFramebuffer = 0;
 47909: 
 47909:     mGLContext->fGetIntegerv(LOCAL_GL_FRAMEBUFFER_BINDING, (GLint*)&currentFramebuffer);
 47909: 
 47909:     // Make sure that we read pixels from the correct framebuffer, regardless
 47909:     // of what's currently bound.
 47909:     if (currentFramebuffer != mCanvasFramebuffer)
 47909:       mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, mCanvasFramebuffer);
 47909: 
 49076:     nsRefPtr<gfxImageSurface> tmpSurface =
 49076:       new gfxImageSurface(destination,
 49076:                           gfxIntSize(mBounds.width, mBounds.height),
 49076:                           mBounds.width * 4,
 49076:                           gfxASurface::ImageFormatARGB32);
 49076:     mGLContext->ReadPixelsIntoImageSurface(0, 0,
 49076:                                            mBounds.width, mBounds.height,
 49076:                                            tmpSurface);
 49076:     tmpSurface = nsnull;
 42611: 
 47909:     // Put back the previous framebuffer binding.
 47909:     if (currentFramebuffer != mCanvasFramebuffer)
 47909:       mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, currentFramebuffer);
 47909: 
 94020:     if (!stridesMatch) {
 42611:       for (int y = 0; y < mBounds.height; y++) {
 42611:         memcpy((PRUint8*)r.pBits + r.Pitch * y,
 42611:                destination + mBounds.width * 4 * y,
 42611:                mBounds.width * 4);
 42611:       }
 42611:     }
 82414:   } else {
 42611:     RECT r;
 64540:     r.left = mBounds.x;
 64540:     r.top = mBounds.y;
 64540:     r.right = mBounds.XMost();
 64540:     r.bottom = mBounds.YMost();
 42611: 
 72995:     LockTextureRectD3D9 textureLock(mTexture);
 72995:     if (!textureLock.HasLock()) {
 53786:       NS_WARNING("Failed to lock CanvasLayer texture.");
 53786:       return;
 53786:     }
 42611: 
 72995:     D3DLOCKED_RECT lockedRect = textureLock.GetLockRect();
 72995: 
 42611:     nsRefPtr<gfxImageSurface> sourceSurface;
 42611: 
106547:     if (mSurface->GetType() == gfxASurface::SurfaceTypeWin32) {
106547:       sourceSurface = mSurface->GetAsImageSurface();
106547:     } else if (mSurface->GetType() == gfxASurface::SurfaceTypeImage) {
106547:       sourceSurface = static_cast<gfxImageSurface*>(mSurface.get());
 42611:       if (sourceSurface->Format() != gfxASurface::ImageFormatARGB32 &&
 42611:           sourceSurface->Format() != gfxASurface::ImageFormatRGB24)
 42611:       {
 42611:         return;
 42611:       }
 42611:     } else {
 64540:       sourceSurface = new gfxImageSurface(gfxIntSize(mBounds.width, mBounds.height),
 42611:                                           gfxASurface::ImageFormatARGB32);
 42611:       nsRefPtr<gfxContext> ctx = new gfxContext(sourceSurface);
 42611:       ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
106547:       ctx->SetSource(mSurface);
 42611:       ctx->Paint();
 42611:     }
 42611: 
 64540:     PRUint8 *startBits = sourceSurface->Data();
 64540:     PRUint32 sourceStride = sourceSurface->Stride();
 64540: 
 62301:     if (sourceSurface->Format() != gfxASurface::ImageFormatARGB32) {
 62301:       mHasAlpha = false;
 62301:     } else {
 62301:       mHasAlpha = true;
 62301:     }
 62301: 
 64540:     for (int y = 0; y < mBounds.height; y++) {
 42611:       memcpy((PRUint8*)lockedRect.pBits + lockedRect.Pitch * y,
 42611:              startBits + sourceStride * y,
 64540:              mBounds.width * 4);
 42611:     }
 42611: 
 42611:   }
 42611: }
 42611: 
 42611: Layer*
 42611: CanvasLayerD3D9::GetLayer()
 42611: {
 42611:   return this;
 42611: }
 42611: 
 42611: void
 57097: CanvasLayerD3D9::RenderLayer()
 42611: {
 64540:   UpdateSurface();
 64541:   FireDidTransactionCallback();
 64541: 
 64540:   if (!mTexture)
 64540:     return;
 53785: 
 42611:   /*
 54880:    * We flip the Y axis here, note we can only do this because we are in 
 54880:    * CULL_NONE mode!
 42611:    */
 54880: 
 54880:   ShaderConstantRect quad(0, 0, mBounds.width, mBounds.height);
 42611:   if (mNeedsYFlip) {
 54880:     quad.mHeight = (float)-mBounds.height;
 54880:     quad.mY = (float)mBounds.height;
 42611:   }
 42611: 
 54880:   device()->SetVertexShaderConstantF(CBvLayerQuad, quad, 1);
 42611: 
 57097:   SetShaderTransformAndOpacity();
 42611: 
 62301:   if (mHasAlpha) {
 97439:     mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBALAYER, GetMaskLayer());
 62301:   } else {
 97439:     mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBLAYER, GetMaskLayer());
 62301:   }
 42611: 
 59728:   if (mFilter == gfxPattern::FILTER_NEAREST) {
 59728:     device()->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);
 59728:     device()->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);
 59728:   }
 51316:   if (!mDataIsPremultiplied) {
 42611:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
 51314:     device()->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, TRUE);
 42611:   }
 42611:   device()->SetTexture(0, mTexture);
 42611:   device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
 51316:   if (!mDataIsPremultiplied) {
 42611:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
 51314:     device()->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, FALSE);
 42611:   }
 59728:   if (mFilter == gfxPattern::FILTER_NEAREST) {
 59728:     device()->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
 59728:     device()->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
 59728:   }
 42611: }
 42611: 
 53784: void
 53784: CanvasLayerD3D9::CleanResources()
 53784: {
 53784:   if (mD3DManager->deviceManager()->HasDynamicTextures()) {
 53784:     // In this case we have a texture in POOL_DEFAULT
 53784:     mTexture = nsnull;
 53784:   }
 53784: }
 53784: 
 53785: void
 53979: CanvasLayerD3D9::LayerManagerDestroyed()
 53979: {
 53979:   mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
 53979:   mD3DManager = nsnull;
 53979: }
 53979: 
 53979: void
 53785: CanvasLayerD3D9::CreateTexture()
 53785: {
 81355:   HRESULT hr;
 53785:   if (mD3DManager->deviceManager()->HasDynamicTextures()) {
 81355:     hr = device()->CreateTexture(mBounds.width, mBounds.height, 1, D3DUSAGE_DYNAMIC,
 53785:                                  D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT,
 53785:                                  getter_AddRefs(mTexture), NULL);
 53785:   } else {
 53785:     // D3DPOOL_MANAGED is fine here since we require Dynamic Textures for D3D9Ex
 53785:     // devices.
 81355:     hr = device()->CreateTexture(mBounds.width, mBounds.height, 1, 0,
 53785:                                  D3DFMT_A8R8G8B8, D3DPOOL_MANAGED,
 53785:                                  getter_AddRefs(mTexture), NULL);
 53785:   }
 81355:   if (FAILED(hr)) {
 81355:     mD3DManager->ReportFailure(NS_LITERAL_CSTRING("CanvasLayerD3D9::CreateTexture() failed"),
 81355:                                  hr);
 81355:     return;
 81355:   }
 53785: }
 53785: 
 72995: ShadowCanvasLayerD3D9::ShadowCanvasLayerD3D9(LayerManagerD3D9* aManager)
 72995:   : ShadowCanvasLayer(aManager, nsnull)
 72995:   , LayerD3D9(aManager)
 80486:   , mNeedsYFlip(false)
 72995: {
 72995:   mImplData = static_cast<LayerD3D9*>(this);
 72995: }
 72995:  
 72995: ShadowCanvasLayerD3D9::~ShadowCanvasLayerD3D9()
 72995: {}
 72995: 
 72995: void
 72995: ShadowCanvasLayerD3D9::Initialize(const Data& aData)
 72995: {
 72995:   NS_RUNTIMEABORT("Non-shadow layer API unexpectedly used for shadow layer");
 72995: }
 72995: 
 72995: void
 79426: ShadowCanvasLayerD3D9::Init(bool needYFlip)
 72995: {
 72995:   if (!mBuffer) {
 72995:     mBuffer = new ShadowBufferD3D9(this);
 72995:   }
 72995: 
 72995:   mNeedsYFlip = needYFlip;
 72995: }
 72995: 
 72995: void
 79426: ShadowCanvasLayerD3D9::Swap(const CanvasSurface& aNewFront,
 79426:                             bool needYFlip,
 79426:                             CanvasSurface* aNewBack)
 72995: {
 79426:   NS_ASSERTION(aNewFront.type() == CanvasSurface::TSurfaceDescriptor, 
 79426:     "ShadowCanvasLayerD3D9::Swap expected CanvasSurface surface");
 72995: 
104368:   AutoOpenSurface surf(OPEN_READ_ONLY, aNewFront);
 79426:   if (!mBuffer) {
 79426:     Init(needYFlip);
 79426:   }
104368:   mBuffer->Upload(surf.Get(), GetVisibleRegion().GetBounds());
 72995: 
 72995:   *aNewBack = aNewFront;
 72995: }
 72995: 
 72995: void
 72995: ShadowCanvasLayerD3D9::DestroyFrontBuffer()
 72995: {
 72995:   Destroy();
 72995: }
 72995: 
 72995: void
 72995: ShadowCanvasLayerD3D9::Disconnect()
 72995: {
 72995:   Destroy();
 72995: }
 72995: 
 72995: void
 72995: ShadowCanvasLayerD3D9::Destroy()
 72995: {
 72995:   mBuffer = nsnull;
 72995: }
 72995: 
 72995: void
 72995: ShadowCanvasLayerD3D9::CleanResources()
 72995: {
 72995:   Destroy();
 72995: }
 72995: 
 72995: void
 72995: ShadowCanvasLayerD3D9::LayerManagerDestroyed()
 72995: {
 72995:   mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
 72995:   mD3DManager = nsnull;
 72995: }
 72995: 
 72995: Layer*
 72995: ShadowCanvasLayerD3D9::GetLayer()
 72995: {
 72995:   return this;
 72995: }
 72995: 
 72995: void
 72995: ShadowCanvasLayerD3D9::RenderLayer()
 72995: {
103533:   if (!mBuffer) {
 72995:     return;
 72995:   }
 72995: 
 72995:   mBuffer->RenderTo(mD3DManager, GetEffectiveVisibleRegion());
 72995: }
 72995: 
 72995: 
 42611: } /* namespace layers */
 47909: } /* namespace mozilla */
