     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
     1: /* vim:expandtab:shiftwidth=4:tabstop=4:
     1:  */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 80467: #include "mozilla/Util.h"
 80467: 
 38014: #ifdef MOZ_PLATFORM_MAEMO
 40081: // needed to include hildon parts in gtk.h
 19111: #define MAEMO_CHANGES
 19111: #endif
 19111: 
     1: #include "prlink.h"
     1: #include "nsWindow.h"
     1: #include "nsGTKToolkit.h"
     1: #include "nsIRollupListener.h"
     1: #include "nsIDOMNode.h"
     1: 
     1: #include "nsWidgetsCID.h"
 27557: #include "nsDragService.h"
108457: #include "nsIWidgetListener.h"
     1: 
     1: #include "nsGtkKeyUtils.h"
     1: #include "nsGtkCursors.h"
     1: 
 23281: #include <gtk/gtk.h>
113945: #if (MOZ_WIDGET_GTK == 3)
 78664: #include <gtk/gtkx.h>
 78664: #endif
 16529: #ifdef MOZ_X11
     1: #include <gdk/gdkx.h>
 40081: #include <X11/Xatom.h>
 54594: #include <X11/extensions/XShm.h>
 69673: #include <X11/extensions/shape.h>
113945: #if (MOZ_WIDGET_GTK == 3)
 78664: #include <gdk/gdkkeysyms-compat.h>
 78664: #endif
 39957: 
 39957: #ifdef AIX
 39957: #include <X11/keysym.h>
 39957: #else
 16529: #include <X11/XF86keysym.h>
 39957: #endif
 39957: 
113945: #if (MOZ_WIDGET_GTK == 2)
 16529: #include "gtk2xtbin.h"
113945: #endif
 16529: #endif /* MOZ_X11 */
 16458: #include <gdk/gdkkeysyms.h>
 78664: #if defined(MOZ_WIDGET_GTK2)
 30515: #include <gtk/gtkprivate.h>
 78664: #endif
 78664: 
 80435: #include "nsGkAtoms.h"
     1: 
     1: #ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
     1: #define SN_API_NOT_YET_FROZEN
     1: #include <startup-notification-1.0/libsn/sn.h>
     1: #endif
     1: 
120353: #include "mozilla/Likely.h"
 70976: #include "mozilla/Preferences.h"
     1: #include "nsIPrefService.h"
 82831: #include "nsIGConfService.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIStringBundle.h"
     1: #include "nsGfxCIID.h"
 33057: #include "nsIObserverService.h"
106914: #include "LayersTypes.h"
103224: #include "nsIIdleServiceInternal.h"
 40087: #include "nsIPropertyBag2.h"
 33517: 
     1: #ifdef ACCESSIBILITY
 86928: #include "nsAccessibilityService.h"
 42313: #include "nsIAccessibleDocument.h"
 70976: 
 70976: using namespace mozilla;
 82840: using namespace mozilla::widget;
     1: #endif
     1: 
     1: /* For SetIcon */
     1: #include "nsAppDirectoryServiceDefs.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsIFile.h"
     1: 
     1: /* SetCursor(imgIContainer*) */
     1: #include <gdk/gdk.h>
 33057: #include <wchar.h>
     1: #include "imgIContainer.h"
     1: #include "nsGfxCIID.h"
     1: #include "nsImageToPixbuf.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsAutoPtr.h"
106914: #include "BasicLayers.h"
     1: 
 35698: extern "C" {
 84270: #define PIXMAN_DONT_DEFINE_STDINT
 35698: #include "pixman.h"
 35698: }
     1: #include "gfxPlatformGtk.h"
     1: #include "gfxContext.h"
     1: #include "gfxImageSurface.h"
 61316: #include "gfxUtils.h"
 44138: #include "Layers.h"
 44138: #include "LayerManagerOGL.h"
 44138: #include "GLContextProvider.h"
     1: 
 16529: #ifdef MOZ_X11
 16529: #include "gfxXlibSurface.h"
 78664: #include "cairo-xlib.h"
 16529: #endif
 16529: 
 56628: #include "nsShmImage.h"
 56628: 
108071: #include "nsIDOMWheelEvent.h"
108071: 
 54594: using namespace mozilla;
 82883: using namespace mozilla::widget;
 46205: using mozilla::gl::GLContext;
 46205: using mozilla::layers::LayerManagerOGL;
 46205: 
 25021: // Don't put more than this many rects in the dirty region, just fluff
 25021: // out to the bounding-box if there are more
 25021: #define MAX_RECTS_IN_REGION 100
 25021: 
119750: const gint kEvents = GDK_EXPOSURE_MASK | GDK_STRUCTURE_MASK |
119750:                      GDK_VISIBILITY_NOTIFY_MASK |
119750:                      GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
119750:                      GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
119750: #ifdef MOZ_PLATFORM_MAEMO
119750:                      GDK_POINTER_MOTION_HINT_MASK |
119750: #endif
119750:                      GDK_POINTER_MOTION_MASK;
119750: 
     1: /* utility functions */
 79445: static bool       is_mouse_in_window(GdkWindow* aWindow,
     1:                                      gdouble aMouseX, gdouble aMouseY);
     1: static nsWindow  *get_window_for_gtk_widget(GtkWidget *widget);
     1: static nsWindow  *get_window_for_gdk_window(GdkWindow *window);
     1: static GtkWidget *get_gtk_widget_for_gdk_window(GdkWindow *window);
     1: static GdkCursor *get_gtk_cursor(nsCursor aCursor);
     1: 
     1: static GdkWindow *get_inner_gdk_window (GdkWindow *aWindow,
     1:                                         gint x, gint y,
     1:                                         gint *retx, gint *rety);
     1: 
 79445: static inline bool is_context_menu_key(const nsKeyEvent& inKeyEvent);
     1: 
     1: static int    is_parent_ungrab_enter(GdkEventCrossing *aEvent);
     1: static int    is_parent_grab_leave(GdkEventCrossing *aEvent);
     1: 
 84531: static void GetBrandName(nsXPIDLString& brandName);
 84531: 
     1: /* callbacks from widgets */
 78664: #if defined(MOZ_WIDGET_GTK2)
     1: static gboolean expose_event_cb           (GtkWidget *widget,
     1:                                            GdkEventExpose *event);
 78664: #else
 78664: static gboolean expose_event_cb           (GtkWidget *widget,
 78664:                                            cairo_t *rect);
 78664: #endif
     1: static gboolean configure_event_cb        (GtkWidget *widget,
     1:                                            GdkEventConfigure *event);
 28365: static void     container_unrealize_cb    (GtkWidget *widget);
     1: static void     size_allocate_cb          (GtkWidget *widget,
     1:                                            GtkAllocation *allocation);
     1: static gboolean delete_event_cb           (GtkWidget *widget,
     1:                                            GdkEventAny *event);
     1: static gboolean enter_notify_event_cb     (GtkWidget *widget,
     1:                                            GdkEventCrossing *event);
     1: static gboolean leave_notify_event_cb     (GtkWidget *widget,
     1:                                            GdkEventCrossing *event);
     1: static gboolean motion_notify_event_cb    (GtkWidget *widget,
     1:                                            GdkEventMotion *event);
     1: static gboolean button_press_event_cb     (GtkWidget *widget,
     1:                                            GdkEventButton *event);
     1: static gboolean button_release_event_cb   (GtkWidget *widget,
     1:                                            GdkEventButton *event);
     1: static gboolean focus_in_event_cb         (GtkWidget *widget,
     1:                                            GdkEventFocus *event);
     1: static gboolean focus_out_event_cb        (GtkWidget *widget,
     1:                                            GdkEventFocus *event);
     1: static gboolean key_press_event_cb        (GtkWidget *widget,
     1:                                            GdkEventKey *event);
     1: static gboolean key_release_event_cb      (GtkWidget *widget,
     1:                                            GdkEventKey *event);
     1: static gboolean scroll_event_cb           (GtkWidget *widget,
     1:                                            GdkEventScroll *event);
     1: static gboolean visibility_notify_event_cb(GtkWidget *widget,
     1:                                            GdkEventVisibility *event);
 34456: static void     hierarchy_changed_cb      (GtkWidget *widget,
 34456:                                            GtkWidget *previous_toplevel);
     1: static gboolean window_state_event_cb     (GtkWidget *widget,
     1:                                            GdkEventWindowState *event);
     1: static void     theme_changed_cb          (GtkSettings *settings,
     1:                                            GParamSpec *pspec,
     1:                                            nsWindow *data);
  9049: static nsWindow* GetFirstNSWindowForGDKWindow (GdkWindow *aGdkWindow);
  9049: 
     1: #ifdef __cplusplus
     1: extern "C" {
     1: #endif /* __cplusplus */
 16529: #ifdef MOZ_X11
 43761: static GdkFilterReturn popup_take_focus_filter (GdkXEvent *gdk_xevent,
 43761:                                                 GdkEvent *event,
 43761:                                                 gpointer data);
     1: static GdkFilterReturn plugin_window_filter_func (GdkXEvent *gdk_xevent,
     1:                                                   GdkEvent *event,
     1:                                                   gpointer data);
     1: static GdkFilterReturn plugin_client_message_filter (GdkXEvent *xevent,
     1:                                                      GdkEvent *event,
     1:                                                      gpointer data);
 16529: #endif /* MOZ_X11 */
     1: #ifdef __cplusplus
     1: }
     1: #endif /* __cplusplus */
     1: 
     1: static gboolean drag_motion_event_cb      (GtkWidget *aWidget,
     1:                                            GdkDragContext *aDragContext,
     1:                                            gint aX,
     1:                                            gint aY,
     1:                                            guint aTime,
     1:                                            gpointer aData);
     1: static void     drag_leave_event_cb       (GtkWidget *aWidget,
     1:                                            GdkDragContext *aDragContext,
     1:                                            guint aTime,
     1:                                            gpointer aData);
     1: static gboolean drag_drop_event_cb        (GtkWidget *aWidget,
     1:                                            GdkDragContext *aDragContext,
     1:                                            gint aX,
     1:                                            gint aY,
     1:                                            guint aTime,
 70072:                                            gpointer aData);
     1: static void    drag_data_received_event_cb(GtkWidget *aWidget,
     1:                                            GdkDragContext *aDragContext,
     1:                                            gint aX,
     1:                                            gint aY,
     1:                                            GtkSelectionData  *aSelectionData,
     1:                                            guint aInfo,
     1:                                            guint32 aTime,
     1:                                            gpointer aData);
     1: 
     1: /* initialization static functions */
     1: static nsresult    initialize_prefs        (void);
     1: 
 90019: static guint32 sLastUserInputTime = GDK_CURRENT_TIME;
 89550: static guint32 sRetryGrabTime;
     1: 
     1: static NS_DEFINE_IID(kCDragServiceCID,  NS_DRAGSERVICE_CID);
     1: 
 43760: // The window from which the focus manager asks us to dispatch key events.
     1: static nsWindow         *gFocusWindow          = NULL;
 79445: static bool              gBlockActivateEvent   = false;
 79445: static bool              gGlobalsInitialized   = false;
 79445: static bool              gRaiseWindows         = true;
     1: static nsWindow         *gPluginFocusWindow    = NULL;
     1: 
     1: 
     1: #define NS_WINDOW_TITLE_MAX_LENGTH 4095
     1: 
     1: // If after selecting profile window, the startup fail, please refer to
     1: // http://bugzilla.gnome.org/show_bug.cgi?id=88940
     1: 
     1: // needed for imgIContainer cursors
     1: // GdkDisplay* was added in 2.2
     1: typedef struct _GdkDisplay GdkDisplay;
     1: 
     1: #define kWindowPositionSlop 20
     1: 
     1: // cursor cache
     1: static GdkCursor *gCursorCache[eCursorCount];
     1: 
 28365: static GtkWidget *gInvisibleContainer = NULL;
 28365: 
 39762: // Sometimes this actually also includes the state of the modifier keys, but
 39762: // only the button state bits are used.
 39762: static guint gButtonState;
 39762: 
 34456: // Some gobject functions expect functions for gpointer arguments.
 34456: // gpointer is void* but C++ doesn't like casting functions to void*.
 39762: template<class T> static inline gpointer
 34456: FuncToGpointer(T aFunction)
 34456: {
 34456:     return reinterpret_cast<gpointer>
 34456:         (reinterpret_cast<uintptr_t>
 34456:          // This cast just provides a warning if T is not a function.
 34456:          (reinterpret_cast<void (*)()>(aFunction)));
 34456: }
 34456: 
 35698: // nsAutoRef<pixman_region32> uses nsSimpleRef<> to know how to automatically
 35698: // destroy regions.
 35698: template <>
 35698: class nsSimpleRef<pixman_region32> : public pixman_region32 {
 35698: protected:
 35698:     typedef pixman_region32 RawRef;
 35698: 
106838:     nsSimpleRef() { data = nullptr; }
 35698:     nsSimpleRef(const RawRef &aRawRef) : pixman_region32(aRawRef) { }
 35698: 
 35698:     static void Release(pixman_region32& region) {
 35698:         pixman_region32_fini(&region);
 35698:     }
 35698:     // Whether this needs to be released:
106838:     bool HaveResource() const { return data != nullptr; }
 35698: 
 35698:     pixman_region32& get() { return *this; }
 35698: };
 35698: 
108991: static inline int32_t
108991: GetBitmapStride(int32_t width)
 78664: {
 78664: #if defined(MOZ_X11) || defined(MOZ_WIDGET_GTK2)
 78664:   return (width+7)/8;
 78664: #else
 78664:   return cairo_format_stride_for_width(CAIRO_FORMAT_A1, width);
 78664: #endif
 78664: }
 78664: 
 90019: static inline bool TimestampIsNewerThan(guint32 a, guint32 b)
 90019: {
 90019:     // Timestamps are just the least significant bits of a monotonically
 90019:     // increasing function, and so the use of unsigned overflow arithmetic.
 90019:     return a - b <= G_MAXUINT32/2;
 90019: }
 90019: 
 90019: static void
 90019: UpdateLastInputEventTime(void *aGdkEvent)
 90019: {
103224:     nsCOMPtr<nsIIdleServiceInternal> idleService =
 90019:         do_GetService("@mozilla.org/widget/idleservice;1");
 90019:     if (idleService) {
103224:         idleService->ResetIdleTimeOut(0);
 90019:     }
 90019: 
 90019:     guint timestamp = gdk_event_get_time(static_cast<GdkEvent*>(aGdkEvent));
 90019:     if (timestamp == GDK_CURRENT_TIME)
 90019:         return;
 90019: 
 90019:     sLastUserInputTime = timestamp;
 90019: }
 90019: 
     1: nsWindow::nsWindow()
     1: {
 79636:     mIsTopLevel       = false;
 79636:     mIsDestroyed      = false;
 79636:     mNeedsResize      = false;
 79636:     mNeedsMove        = false;
 79636:     mListenForResizes = false;
 79636:     mIsShown          = false;
 79636:     mNeedsShow        = false;
 79636:     mEnabled          = true;
 79636:     mCreated          = false;
 20621: 
106838:     mContainer           = nullptr;
106838:     mGdkWindow           = nullptr;
106838:     mShell               = nullptr;
106838:     mWindowGroup         = nullptr;
 79636:     mHasMappedToplevel   = false;
 79636:     mIsFullyObscured     = false;
 79636:     mRetryPointerGrab    = false;
106838:     mTransientParent     = nullptr;
     1:     mWindowType          = eWindowType_child;
     1:     mSizeState           = nsSizeMode_Normal;
 32018:     mLastSizeMode        = nsSizeMode_Normal;
122623:     mSizeConstraints.mMaxSize = GetSafeWindowSize(mSizeConstraints.mMaxSize);
 32018: 
 16529: #ifdef MOZ_X11
     1:     mOldFocusWindow      = 0;
 16529: #endif /* MOZ_X11 */
     1:     mPluginType          = PluginType_NONE;
     1: 
     1:     if (!gGlobalsInitialized) {
 79636:         gGlobalsInitialized = true;
     1: 
     1:         // It's OK if either of these fail, but it may not be one day.
     1:         initialize_prefs();
     1:     }
     1: 
 22684:     mLastMotionPressure = 0;
     1: 
     1: #ifdef ACCESSIBILITY
106838:     mRootAccessible  = nullptr;
     1: #endif
     1: 
 79636:     mIsTransparent = false;
106838:     mTransparencyBitmap = nullptr;
     1: 
     1:     mTransparencyBitmapWidth  = 0;
     1:     mTransparencyBitmapHeight = 0;
     1: }
     1: 
     1: nsWindow::~nsWindow()
     1: {
     1:     LOG(("nsWindow::~nsWindow() [%p]\n", (void *)this));
     1: 
     1:     delete[] mTransparencyBitmap;
106838:     mTransparencyBitmap = nullptr;
     1: 
     1:     Destroy();
     1: }
     1: 
     1: /* static */ void
     1: nsWindow::ReleaseGlobals()
     1: {
108991:   for (uint32_t i = 0; i < ArrayLength(gCursorCache); ++i) {
     1:     if (gCursorCache[i]) {
     1:       gdk_cursor_unref(gCursorCache[i]);
106838:       gCursorCache[i] = nullptr;
     1:     }
     1:   }
     1: }
     1: 
 20621: NS_IMPL_ISUPPORTS_INHERITED1(nsWindow, nsBaseWidget,
     1:                              nsISupportsWeakReference)
     1: 
 20621: void
 79445: nsWindow::CommonCreate(nsIWidget *aParent, bool aListenForResizes)
 20621: {
 20621:     mParent = aParent;
 20621:     mListenForResizes = aListenForResizes;
 79636:     mCreated = true;
 20621: }
 20621: 
 20621: void
 20621: nsWindow::DispatchActivateEvent(void)
 20621: {
 32520:     NS_ASSERTION(mContainer || mIsDestroyed,
 32520:                  "DispatchActivateEvent only intended for container windows");
 32520: 
 20621: #ifdef ACCESSIBILITY
 20621:     DispatchActivateEventAccessible();
 20621: #endif //ACCESSIBILITY
108457: 
108457:     if (mWidgetListener)
108457:       mWidgetListener->WindowActivated();
 20621: }
 20621: 
 20621: void
 20621: nsWindow::DispatchDeactivateEvent(void)
 20621: {
108457:     if (mWidgetListener)
108457:       mWidgetListener->WindowDeactivated();
 20621: 
 20621: #ifdef ACCESSIBILITY
 20621:     DispatchDeactivateEventAccessible();
 20621: #endif //ACCESSIBILITY
 20621: }
 20621: 
119753: void
119753: nsWindow::DispatchResized(int32_t aWidth, int32_t aHeight)
119753: {
119753:     nsIWidgetListener *listeners[] =
119753:         { mWidgetListener, mAttachedWidgetListener };
119753:     for (size_t i = 0; i < ArrayLength(listeners); ++i) {
119753:         if (listeners[i]) {
119753:             listeners[i]->WindowResized(this, aWidth, aHeight);
119753:         }
119753:     }
119753: }
 20621: 
 20621: nsresult
 25825: nsWindow::DispatchEvent(nsGUIEvent *aEvent, nsEventStatus &aStatus)
 20621: {
 20621: #ifdef DEBUG
 20621:     debug_DumpEvent(stdout, aEvent->widget, aEvent,
110974:                     nsAutoCString("something"), 0);
 20621: #endif
 20621: 
 20621:     aStatus = nsEventStatus_eIgnore;
119753:     nsIWidgetListener* listener =
119753:         mAttachedWidgetListener ? mAttachedWidgetListener : mWidgetListener;
119753:     if (listener) {
119753:       aStatus = listener->HandleEvent(aEvent, mUseAttachedEvents);
119753:     }
 20621: 
 20621:     return NS_OK;
 20621: }
 20621: 
 20621: void
 20621: nsWindow::OnDestroy(void)
 20621: {
 20621:     if (mOnDestroyCalled)
 20621:         return;
 20621: 
 79636:     mOnDestroyCalled = true;
 20621:     
 39858:     // Prevent deletion.
 39858:     nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
 39858: 
 20621:     // release references to children, device context, toolkit + app shell
 20621:     nsBaseWidget::OnDestroy(); 
 20621:     
 39858:     // Remove association between this object and its parent and siblings.
 39858:     nsBaseWidget::Destroy();
106838:     mParent = nullptr;
 20621: 
108456:     NotifyWindowDestroyed();
 20621: }
 20621: 
 79445: bool
 20621: nsWindow::AreBoundsSane(void)
 20621: {
 20621:     if (mBounds.width > 0 && mBounds.height > 0)
 79636:         return true;
 79636: 
 79636:     return false;
 20621: }
 20621: 
 28365: static GtkWidget*
 28365: EnsureInvisibleContainer()
 28365: {
 28365:     if (!gInvisibleContainer) {
 28365:         // GtkWidgets need to be anchored to a GtkWindow to be realized (to
 28365:         // have a window).  Using GTK_WINDOW_POPUP rather than
 28365:         // GTK_WINDOW_TOPLEVEL in the hope that POPUP results in less
 28365:         // initialization and window manager interaction.
 28365:         GtkWidget* window = gtk_window_new(GTK_WINDOW_POPUP);
 28365:         gInvisibleContainer = moz_container_new();
 28365:         gtk_container_add(GTK_CONTAINER(window), gInvisibleContainer);
 28365:         gtk_widget_realize(gInvisibleContainer);
 28365: 
 28365:     }
 28365:     return gInvisibleContainer;
 28365: }
 28365: 
 28365: static void
 28365: CheckDestroyInvisibleContainer()
 28365: {
 28365:     NS_PRECONDITION(gInvisibleContainer, "oh, no");
 28365: 
 78664:     if (!gdk_window_peek_children(gtk_widget_get_window(gInvisibleContainer))) {
 28365:         // No children, so not in use.
 28365:         // Make sure to destroy the GtkWindow also.
 78664:         gtk_widget_destroy(gtk_widget_get_parent(gInvisibleContainer));
 28365:         gInvisibleContainer = NULL;
 28365:     }
 28365: }
 28365: 
 28365: // Change the containing GtkWidget on a sub-hierarchy of GdkWindows belonging
 28365: // to aOldWidget and rooted at aWindow, and reparent any child GtkWidgets of
 34746: // the GdkWindow hierarchy to aNewWidget.
 28365: static void
 28365: SetWidgetForHierarchy(GdkWindow *aWindow,
 28365:                       GtkWidget *aOldWidget,
 28365:                       GtkWidget *aNewWidget)
 28365: {
 28365:     gpointer data;
 28365:     gdk_window_get_user_data(aWindow, &data);
 28365: 
 28365:     if (data != aOldWidget) {
 28365:         if (!GTK_IS_WIDGET(data))
 28365:             return;
 28365: 
 28365:         GtkWidget* widget = static_cast<GtkWidget*>(data);
 78664:         if (gtk_widget_get_parent(widget) != aOldWidget)
 28365:             return;
 28365: 
 28365:         // This window belongs to a child widget, which will no longer be a
 28365:         // child of aOldWidget.
 28365:         gtk_widget_reparent(widget, aNewWidget);
 28365: 
 28365:         return;
 28365:     }
 28365: 
 28433:     GList *children = gdk_window_get_children(aWindow);
 28433:     for(GList *list = children; list; list = list->next) {
 28365:         SetWidgetForHierarchy(GDK_WINDOW(list->data), aOldWidget, aNewWidget);
 28365:     }
 28433:     g_list_free(children);
 28365: 
 28365:     gdk_window_set_user_data(aWindow, aNewWidget);
 28365: }
 28365: 
 34746: // Walk the list of child windows and call destroy on them.
 34746: void
 34746: nsWindow::DestroyChildWindows()
 34746: {
 34746:     if (!mGdkWindow)
 34746:         return;
 34746: 
 34813:     while (GList *children = gdk_window_peek_children(mGdkWindow)) {
 34746:         GdkWindow *child = GDK_WINDOW(children->data);
 34746:         nsWindow *kid = get_window_for_gdk_window(child);
 34746:         if (kid) {
 34746:             kid->Destroy();
 34746:         } else {
 34746:             // This child is not an nsWindow.
 34746:             // Destroy the child GtkWidget.
 34746:             gpointer data;
 34746:             gdk_window_get_user_data(child, &data);
 34746:             if (GTK_IS_WIDGET(data)) {
 34746:                 gtk_widget_destroy(static_cast<GtkWidget*>(data));
 34746:             }
 34746:         }
 34746:     }
 34746: }
 34746: 
     1: NS_IMETHODIMP
     1: nsWindow::Destroy(void)
     1: {
     1:     if (mIsDestroyed || !mCreated)
     1:         return NS_OK;
     1: 
     1:     LOG(("nsWindow::Destroy [%p]\n", (void *)this));
 79636:     mIsDestroyed = true;
 79636:     mCreated = false;
     1: 
 46205:     /** Need to clean our LayerManager up while still alive */
 49074:     if (mLayerManager) {
106838:         nsRefPtr<GLContext> gl = nullptr;
105710:         if (mLayerManager->GetBackendType() == mozilla::layers::LAYERS_OPENGL) {
 49074:             LayerManagerOGL *ogllm = static_cast<LayerManagerOGL*>(mLayerManager.get());
 49074:             gl = ogllm->gl();
 49074:         }
 49074: 
 49074:         mLayerManager->Destroy();
 49074: 
 49074:         if (gl) {
 49074:             gl->MarkDestroyed();
 49074:         }
 49074:     }
106838:     mLayerManager = nullptr;
 46205: 
 99223:     // It is safe to call DestroyeCompositor several times (here and 
 99223:     // in the parent class) since it will take effect only once.
 99223:     // The reason we call it here is because on gtk platforms we need 
 99223:     // to destroy the compositor before we destroy the gdk window (which
 99223:     // destroys the the gl context attached to it).
 99223:     DestroyCompositor();
 99223: 
 61184:     ClearCachedResources();
 61184: 
     1:     g_signal_handlers_disconnect_by_func(gtk_settings_get_default(),
 34456:                                          FuncToGpointer(theme_changed_cb),
     1:                                          this);
     1: 
120177:     nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
120177:     nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
120177:     if (static_cast<nsIWidget *>(this) == rollupWidget) {
120177:         rollupListener->Rollup(0, nullptr);
     1:     }
     1: 
 97615:     // dragService will be null after shutdown of the service manager.
 97331:     nsDragService *dragService = nsDragService::GetInstance();
 97615:     if (dragService && this == dragService->GetMostRecentDestWindow()) {
 97331:         dragService->ScheduleLeaveEvent();
 97331:     }
 97331: 
 79636:     NativeShow(false);
     1: 
 39627:     if (mIMModule) {
 39627:         mIMModule->OnDestroyWindow(this);
 39627:     }
     1: 
     1:     // make sure that we remove ourself as the focus window
     1:     if (gFocusWindow == this) {
     1:         LOGFOCUS(("automatically losing focus...\n"));
106838:         gFocusWindow = nullptr;
     1:     }
     1: 
 78664: #if defined(MOZ_WIDGET_GTK2) && defined(MOZ_X11)
     1:     // make sure that we remove ourself as the plugin focus window
     1:     if (gPluginFocusWindow == this) {
     1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
     1:     }
 78664: #endif /* MOZ_X11 && MOZ_WIDGET_GTK2 */
     1:   
  6721:     if (mWindowGroup) {
 69740:         g_object_unref(mWindowGroup);
106838:         mWindowGroup = nullptr;
  6721:     }
     1: 
     1:     // Destroy thebes surface now. Badness can happen if we destroy
     1:     // the surface after its X Window.
106838:     mThebesSurface = nullptr;
     1: 
 28365:     GtkWidget *owningWidget = GetMozContainerWidget();
 28365:     if (mShell) {
 28365:         gtk_widget_destroy(mShell);
106838:         mShell = nullptr;
106838:         mContainer = nullptr;
 30705:         NS_ABORT_IF_FALSE(!mGdkWindow,
 30705:                           "mGdkWindow should be NULL when mContainer is destroyed");
 28365:     }
 28365:     else if (mContainer) {
 28365:         gtk_widget_destroy(GTK_WIDGET(mContainer));
106838:         mContainer = nullptr;
 30705:         NS_ABORT_IF_FALSE(!mGdkWindow,
 30705:                           "mGdkWindow should be NULL when mContainer is destroyed");
 30705:     }
 30705:     else if (mGdkWindow) {
 34746:         // Destroy child windows to ensure that their mThebesSurfaces are
 34746:         // released and to remove references from GdkWindows back to their
 34746:         // container widget.  (OnContainerUnrealize() does this when the
 34746:         // MozContainer widget is destroyed.)
 34746:         DestroyChildWindows();
 34746: 
 34746:         gdk_window_set_user_data(mGdkWindow, NULL);
 30705:         g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", NULL);
 30704:         gdk_window_destroy(mGdkWindow);
106838:         mGdkWindow = nullptr;
 18490:     }
 18490: 
 28365:     if (gInvisibleContainer && owningWidget == gInvisibleContainer) {
 28365:         CheckDestroyInvisibleContainer();
     1:     }
     1: 
     1: #ifdef ACCESSIBILITY
     1:      if (mRootAccessible) {
106838:          mRootAccessible = nullptr;
     1:      }
     1: #endif
     1: 
 39858:     // Save until last because OnDestroy() may cause us to be deleted.
 39858:     OnDestroy();
 39858: 
     1:     return NS_OK;
     1: }
     1: 
 20621: nsIWidget *
 20621: nsWindow::GetParent(void)
 20621: {
 20621:     return mParent;
 20621: }
 20621: 
 50783: float
 50783: nsWindow::GetDPI()
 50783: {
 57858: 
 57858: #ifdef MOZ_PLATFORM_MAEMO
 57858:     static float sDPI = 0;
 57858: 
 57858:     if (!sDPI) {
 57858:         // X on Maemo does not report true DPI: https://bugs.maemo.org/show_bug.cgi?id=4825
 57858:         nsCOMPtr<nsIPropertyBag2> infoService = do_GetService("@mozilla.org/system-info;1");
 57858:         NS_ASSERTION(infoService, "Could not find a system info service");
 57858: 
 57858:         nsCString deviceType;
 57858:         infoService->GetPropertyAsACString(NS_LITERAL_STRING("device"), deviceType);
 57858:         if (deviceType.EqualsLiteral("Nokia N900")) {
 57858:             sDPI = 265.0f;
 57858:         } else if (deviceType.EqualsLiteral("Nokia N8xx")) {
 57858:             sDPI = 225.0f;
 57858:         } else {
 57858:             // Fall back to something sane.
 57858:             NS_WARNING("Unknown device - using default DPI");
 57858:             sDPI = 96.0f;
 57858:         }
 57858:     }
 57858:     return sDPI;
 57858: #else
 78664:     Display *dpy = GDK_DISPLAY_XDISPLAY(gdk_display_get_default());
 50783:     int defaultScreen = DefaultScreen(dpy);
 50784:     double heightInches = DisplayHeightMM(dpy, defaultScreen)/MM_PER_INCH_FLOAT;
 50783:     if (heightInches < 0.25) {
 50783:         // Something's broken, but we'd better not crash.
 50783:         return 96.0f;
 50783:     }
 50783:     return float(DisplayHeight(dpy, defaultScreen)/heightInches);
 57858: #endif
 50783: }
 50783: 
     1: NS_IMETHODIMP
     1: nsWindow::SetParent(nsIWidget *aNewParent)
     1: {
 82580:     if (mContainer || !mGdkWindow) {
 82580:         NS_NOTREACHED("nsWindow::SetParent called illegally");
 28365:         return NS_ERROR_NOT_IMPLEMENTED;
 28365:     }
 28365: 
 54312:     NS_ASSERTION(!mTransientParent, "child widget with transient parent");
 54312: 
 28365:     nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
 82580:     if (mParent) {
 28365:         mParent->RemoveChild(this);
 82580:     }
 28365: 
 28365:     mParent = aNewParent;
 28365: 
 28365:     GtkWidget* oldContainer = GetMozContainerWidget();
 28365:     if (!oldContainer) {
 28365:         // The GdkWindows have been destroyed so there is nothing else to
 28365:         // reparent.
 78664:         NS_ABORT_IF_FALSE(gdk_window_is_destroyed(mGdkWindow),
 28365:                           "live GdkWindow with no widget");
 28365:         return NS_OK;
 28365:     }
 28365: 
 28365:     if (aNewParent) {
 54310:         aNewParent->AddChild(this);
 54312:         ReparentNativeWidget(aNewParent);
 28365:     } else {
 28365:         // aNewParent is NULL, but reparent to a hidden window to avoid
 28365:         // destroying the GdkWindow and its descendants.
 28365:         // An invisible container widget is needed to hold descendant
 28365:         // GtkWidgets.
 54312:         GtkWidget* newContainer = EnsureInvisibleContainer();
 78664:         GdkWindow* newParentWindow = gtk_widget_get_window(newContainer);
 54312:         ReparentNativeWidgetInternal(aNewParent, newContainer, newParentWindow,
 54312:                                      oldContainer);
 54312:     }
 54312:     return NS_OK;
 54312: }
 54312: 
 54312: NS_IMETHODIMP
 54312: nsWindow::ReparentNativeWidget(nsIWidget* aNewParent)
 54312: {
 54312:     NS_PRECONDITION(aNewParent, "");
 54312:     NS_ASSERTION(!mIsDestroyed, "");
 54312:     NS_ASSERTION(!static_cast<nsWindow*>(aNewParent)->mIsDestroyed, "");
 54312: 
 54312:     GtkWidget* oldContainer = GetMozContainerWidget();
 54312:     if (!oldContainer) {
 54312:         // The GdkWindows have been destroyed so there is nothing else to
 54312:         // reparent.
 78664:         NS_ABORT_IF_FALSE(gdk_window_is_destroyed(mGdkWindow),
 54312:                           "live GdkWindow with no widget");
 54312:         return NS_OK;
 54312:     }
 78664:     NS_ABORT_IF_FALSE(!gdk_window_is_destroyed(mGdkWindow),
 54312:                       "destroyed GdkWindow with widget");
 54312:     
 54312:     nsWindow* newParent = static_cast<nsWindow*>(aNewParent);
 54312:     GdkWindow* newParentWindow = newParent->mGdkWindow;
119750:     GtkWidget* newContainer = newParent->GetMozContainerWidget();
 54312: 
 54312:     if (mTransientParent) {
 54312:       GtkWindow* topLevelParent =
 54312:           GTK_WINDOW(gtk_widget_get_toplevel(newContainer));
 54312:       gtk_window_set_transient_for(GTK_WINDOW(mShell), topLevelParent);
 54312:       mTransientParent = topLevelParent;
 54312:       if (mWindowGroup) {
 69740:           g_object_unref(mWindowGroup);
 54312:           mWindowGroup = NULL;
 54312:       }
 78664:       if (gtk_window_get_group(mTransientParent)) {
 78664:           gtk_window_group_add_window(gtk_window_get_group(mTransientParent),
 54312:                                       GTK_WINDOW(mShell));
 78664:           mWindowGroup = gtk_window_get_group(mTransientParent);
 69740:           g_object_ref(mWindowGroup);
 54312:       }
 78664:       else if (gtk_window_get_group(GTK_WINDOW(mShell))) {
 78664:           gtk_window_group_remove_window(gtk_window_get_group(GTK_WINDOW(mShell)),
 54312:                                          GTK_WINDOW(mShell));
 54312:       }
 54312:     }
 54312: 
 54312:     ReparentNativeWidgetInternal(aNewParent, newContainer, newParentWindow,
 54312:                                  oldContainer);
 54312:     return NS_OK;
 54312: }
 54312: 
 54312: void
 54312: nsWindow::ReparentNativeWidgetInternal(nsIWidget* aNewParent,
 54312:                                        GtkWidget* aNewContainer,
 54312:                                        GdkWindow* aNewParentWindow,
 54312:                                        GtkWidget* aOldContainer)
 54312: {
 54312:     if (!aNewContainer) {
 28365:         // The new parent GdkWindow has been destroyed.
 54312:         NS_ABORT_IF_FALSE(!aNewParentWindow ||
 78664:                           gdk_window_is_destroyed(aNewParentWindow),
 28365:                           "live GdkWindow with no widget");
 28365:         Destroy();
 28365:     } else {
 54312:         if (aNewContainer != aOldContainer) {
 78664:             NS_ABORT_IF_FALSE(!gdk_window_is_destroyed(aNewParentWindow),
 28365:                               "destroyed GdkWindow with widget");
 54312:             SetWidgetForHierarchy(mGdkWindow, aOldContainer, aNewContainer);
 82580: 
 82580:             if (aOldContainer == gInvisibleContainer) {
 82580:                 CheckDestroyInvisibleContainer();
 82580:             }
 54312:         }
 54312: 
 54312:         if (!mIsTopLevel) {
 54312:             gdk_window_reparent(mGdkWindow, aNewParentWindow, mBounds.x,
 54312:                                 mBounds.y);
 54312:         }
 54312:     }
 54312: 
 54312:     nsWindow* newParent = static_cast<nsWindow*>(aNewParent);
 79445:     bool parentHasMappedToplevel =
 34456:         newParent && newParent->mHasMappedToplevel;
 34456:     if (mHasMappedToplevel != parentHasMappedToplevel) {
 34456:         SetHasMappedToplevel(parentHasMappedToplevel);
 34456:     }
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsWindow::SetModal(bool aModal)
     1: {
     1:     LOG(("nsWindow::SetModal [%p] %d\n", (void *)this, aModal));
 43004:     if (mIsDestroyed)
 43004:         return aModal ? NS_ERROR_NOT_AVAILABLE : NS_OK;
 43004:     if (!mIsTopLevel || !mShell)
     1:         return NS_ERROR_FAILURE;
 43004:     gtk_window_set_modal(GTK_WINDOW(mShell), aModal ? TRUE : FALSE);
     1:     return NS_OK;
     1: }
     1: 
 30702: // nsIWidget method, which means IsShown.
105772: bool
105772: nsWindow::IsVisible() const
105772: {
105772:     return mIsShown;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsWindow::ConstrainPosition(bool aAllowSlop, int32_t *aX, int32_t *aY)
     1: {
     1:     if (mIsTopLevel && mShell) {
108991:         int32_t screenWidth = gdk_screen_width();
108991:         int32_t screenHeight = gdk_screen_height();
     1:         if (aAllowSlop) {
     1:             if (*aX < (kWindowPositionSlop - mBounds.width))
     1:                 *aX = kWindowPositionSlop - mBounds.width;
     1:             if (*aX > (screenWidth - kWindowPositionSlop))
     1:                 *aX = screenWidth - kWindowPositionSlop;
     1:             if (*aY < (kWindowPositionSlop - mBounds.height))
     1:                 *aY = kWindowPositionSlop - mBounds.height;
     1:             if (*aY > (screenHeight - kWindowPositionSlop))
     1:                 *aY = screenHeight - kWindowPositionSlop;
     1:         } else {
     1:             if (*aX < 0)
     1:                 *aX = 0;
     1:             if (*aX > (screenWidth - mBounds.width))
     1:                 *aX = screenWidth - mBounds.width;
     1:             if (*aY < 0)
     1:                 *aY = 0;
     1:             if (*aY > (screenHeight - mBounds.height))
     1:                 *aY = screenHeight - mBounds.height;
     1:         }
     1:     }
     1:     return NS_OK;
     1: }
     1: 
106923: void nsWindow::SetSizeConstraints(const SizeConstraints& aConstraints)
106923: {
122623:     mSizeConstraints.mMinSize = GetSafeWindowSize(aConstraints.mMinSize);
122623:     mSizeConstraints.mMaxSize = GetSafeWindowSize(aConstraints.mMaxSize);
122623: 
106923:     if (mShell) {
106923:         GdkGeometry geometry;
122623:         geometry.min_width = mSizeConstraints.mMinSize.width;
122623:         geometry.min_height = mSizeConstraints.mMinSize.height;
122623:         geometry.max_width = mSizeConstraints.mMaxSize.width;
122623:         geometry.max_height = mSizeConstraints.mMaxSize.height;
106923: 
108991:         uint32_t hints = GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE;
106923:         gtk_window_set_geometry_hints(GTK_WINDOW(mShell), nullptr,
106923:                                       &geometry, GdkWindowHints(hints));
106923:     }
106923: }
106923: 
     1: NS_IMETHODIMP
 79445: nsWindow::Show(bool aState)
 20621: {
 34456:     if (aState == mIsShown)
 34456:         return NS_OK;
 34456: 
 61184:     // Clear our cached resources when the window is hidden.
 61184:     if (mIsShown && !aState) {
 61184:         ClearCachedResources();
 61184:     }
 61184: 
 20621:     mIsShown = aState;
 20621: 
 20621:     LOG(("nsWindow::Show [%p] state %d\n", (void *)this, aState));
 20621: 
 34456:     if (aState) {
 34456:         // Now that this window is shown, mHasMappedToplevel needs to be
 34456:         // tracked on viewable descendants.
 34456:         SetHasMappedToplevel(mHasMappedToplevel);
 34456:     }
 34456: 
 20621:     // Ok, someone called show on a window that isn't sized to a sane
 20621:     // value.  Mark this window as needing to have Show() called on it
 20621:     // and return.
 20621:     if ((aState && !AreBoundsSane()) || !mCreated) {
 20621:         LOG(("\tbounds are insane or window hasn't been created yet\n"));
 79636:         mNeedsShow = true;
 20621:         return NS_OK;
 20621:     }
 20621: 
 20621:     // If someone is hiding this widget, clear any needing show flag.
 20621:     if (!aState)
 79636:         mNeedsShow = false;
 20621: 
 20621:     // If someone is showing this window and it needs a resize then
 20621:     // resize the widget.
 20621:     if (aState) {
 20621:         if (mNeedsMove) {
 20621:             NativeResize(mBounds.x, mBounds.y, mBounds.width, mBounds.height,
 79636:                          false);
 20621:         } else if (mNeedsResize) {
 79636:             NativeResize(mBounds.width, mBounds.height, false);
 20621:         }
 20621:     }
 20621: 
 70987: #ifdef ACCESSIBILITY
 86928:     if (aState && a11y::ShouldA11yBeEnabled())
 70987:         CreateRootAccessible();
 70987: #endif
 70987: 
 20621:     NativeShow(aState);
 20621: 
 20621:     return NS_OK;
 20621: }
 20621: 
 20621: NS_IMETHODIMP
108991: nsWindow::Resize(int32_t aWidth, int32_t aHeight, bool aRepaint)
 20621: {
106923:     ConstrainSize(&aWidth, &aHeight);
106923: 
 73647:     // For top-level windows, aWidth and aHeight should possibly be
 73647:     // interpreted as frame bounds, but NativeResize treats these as window
 73647:     // bounds (Bug 581866).
 73647: 
122623:     mBounds.SizeTo(aWidth, aHeight);
 20621: 
 20621:     if (!mCreated)
 20621:         return NS_OK;
 20621: 
 20621:     // There are several cases here that we need to handle, based on a
 20621:     // matrix of the visibility of the widget, the sanity of this resize
 20621:     // and whether or not the widget was previously sane.
 20621: 
 20621:     // Has this widget been set to visible?
 20621:     if (mIsShown) {
 20621:         // Are the bounds sane?
 20621:         if (AreBoundsSane()) {
 20621:             // Yep?  Resize the window
 20621:             //Maybe, the toplevel has moved
 20621: 
 59546:             // Note that if the widget needs to be positioned because its
 59546:             // size was previously insane in Resize(x,y,w,h), then we need
 20621:             // to set the x and y here too, because the widget wasn't
 20621:             // moved back then
 59546:             if (mNeedsMove)
 20621:                 NativeResize(mBounds.x, mBounds.y,
 20621:                              mBounds.width, mBounds.height, aRepaint);
 20621:             else
 20621:                 NativeResize(mBounds.width, mBounds.height, aRepaint);
 20621: 
 20621:             // Does it need to be shown because it was previously insane?
 20621:             if (mNeedsShow)
 79636:                 NativeShow(true);
 20621:         }
 20621:         else {
 20621:             // If someone has set this so that the needs show flag is false
 20621:             // and it needs to be hidden, update the flag and hide the
 20621:             // window.  This flag will be cleared the next time someone
 20621:             // hides the window or shows it.  It also prevents us from
 79636:             // calling NativeShow(false) excessively on the window which
 20621:             // causes unneeded X traffic.
 20621:             if (!mNeedsShow) {
 79636:                 mNeedsShow = true;
 79636:                 NativeShow(false);
 20621:             }
 20621:         }
 20621:     }
 20621:     // If the widget hasn't been shown, mark the widget as needing to be
 20621:     // resized before it is shown.
 20621:     else {
 20621:         if (AreBoundsSane() && mListenForResizes) {
 20621:             // For widgets that we listen for resizes for (widgets created
 20621:             // with native parents) we apparently _always_ have to resize.  I
 20621:             // dunno why, but apparently we're lame like that.
 20621:             NativeResize(aWidth, aHeight, aRepaint);
 20621:         }
 20621:         else {
 79636:             mNeedsResize = true;
 20621:         }
 20621:     }
 20621: 
120177:     NotifyRollupGeometryChange();
102762: 
108457:     // send a resize notification if this is a toplevel
 20621:     if (mIsTopLevel || mListenForResizes) {
119753:         DispatchResized(aWidth, aHeight);
 20621:     }
 20621: 
 20621:     return NS_OK;
 20621: }
 20621: 
 20621: NS_IMETHODIMP
108991: nsWindow::Resize(int32_t aX, int32_t aY, int32_t aWidth, int32_t aHeight,
 79445:                        bool aRepaint)
 20621: {
106923:     ConstrainSize(&aWidth, &aHeight);
106923: 
 20621:     mBounds.x = aX;
 20621:     mBounds.y = aY;
122623:     mBounds.SizeTo(aWidth, aHeight);
 20621: 
 79636:     mNeedsMove = true;
 20621: 
 20621:     if (!mCreated)
 20621:         return NS_OK;
 20621: 
 20621:     // There are several cases here that we need to handle, based on a
 20621:     // matrix of the visibility of the widget, the sanity of this resize
 20621:     // and whether or not the widget was previously sane.
 20621: 
 20621:     // Has this widget been set to visible?
 20621:     if (mIsShown) {
 20621:         // Are the bounds sane?
 20621:         if (AreBoundsSane()) {
 20621:             // Yep?  Resize the window
 20621:             NativeResize(aX, aY, aWidth, aHeight, aRepaint);
 20621:             // Does it need to be shown because it was previously insane?
 20621:             if (mNeedsShow)
 79636:                 NativeShow(true);
 20621:         }
 20621:         else {
 20621:             // If someone has set this so that the needs show flag is false
 20621:             // and it needs to be hidden, update the flag and hide the
 20621:             // window.  This flag will be cleared the next time someone
 20621:             // hides the window or shows it.  It also prevents us from
 79636:             // calling NativeShow(false) excessively on the window which
 20621:             // causes unneeded X traffic.
 20621:             if (!mNeedsShow) {
 79636:                 mNeedsShow = true;
 79636:                 NativeShow(false);
 20621:             }
 20621:         }
 20621:     }
 20621:     // If the widget hasn't been shown, mark the widget as needing to be
 20621:     // resized before it is shown
 20621:     else {
 20621:         if (AreBoundsSane() && mListenForResizes){
 20621:             // For widgets that we listen for resizes for (widgets created
 20621:             // with native parents) we apparently _always_ have to resize.  I
 20621:             // dunno why, but apparently we're lame like that.
 20621:             NativeResize(aX, aY, aWidth, aHeight, aRepaint);
 20621:         }
 20621:         else {
 79636:             mNeedsResize = true;
 20621:         }
 20621:     }
 20621: 
120177:     NotifyRollupGeometryChange();
102762: 
 20621:     if (mIsTopLevel || mListenForResizes) {
119753:         DispatchResized(aWidth, aHeight);
 20621:     }
 20621: 
 20621:     return NS_OK;
 20621: }
 20621: 
 20621: NS_IMETHODIMP
 79445: nsWindow::Enable(bool aState)
 20621: {
 20621:     mEnabled = aState;
 20621: 
 20621:     return NS_OK;
 20621: }
 20621: 
106103: bool
106103: nsWindow::IsEnabled() const
106103: {
106103:     return mEnabled;
 20621: }
 20621: 
 20621: 
 20621: 
 20621: NS_IMETHODIMP
108991: nsWindow::Move(int32_t aX, int32_t aY)
     1: {
     1:     LOG(("nsWindow::Move [%p] %d %d\n", (void *)this,
     1:          aX, aY));
     1: 
 34488:     if (mWindowType == eWindowType_toplevel ||
 34488:         mWindowType == eWindowType_dialog) {
 34488:         SetSizeMode(nsSizeMode_Normal);
 34488:     }
 34488: 
     1:     // Since a popup window's x/y coordinates are in relation to to
     1:     // the parent, the parent might have moved so we always move a
     1:     // popup window.
     1:     if (aX == mBounds.x && aY == mBounds.y &&
     1:         mWindowType != eWindowType_popup)
     1:         return NS_OK;
     1: 
     1:     // XXX Should we do some AreBoundsSane check here?
     1: 
     1:     mBounds.x = aX;
     1:     mBounds.y = aY;
     1: 
     1:     if (!mCreated)
     1:         return NS_OK;
     1: 
 79636:     mNeedsMove = false;
 59547: 
     1:     if (mIsTopLevel) {
     1:         gtk_window_move(GTK_WINDOW(mShell), aX, aY);
     1:     }
 30704:     else if (mGdkWindow) {
 30704:         gdk_window_move(mGdkWindow, aX, aY);
     1:     }
     1: 
120177:     NotifyRollupGeometryChange();
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 14964: nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement  aPlacement,
 14964:                       nsIWidget                  *aWidget,
 79445:                       bool                        aActivate)
     1: {
     1:     return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsWindow::SetZIndex(int32_t aZIndex)
     1: {
     1:     nsIWidget* oldPrev = GetPrevSibling();
     1: 
     1:     nsBaseWidget::SetZIndex(aZIndex);
     1: 
     1:     if (GetPrevSibling() == oldPrev) {
     1:         return NS_OK;
     1:     }
     1: 
     1:     NS_ASSERTION(!mContainer, "Expected Mozilla child widget");
     1: 
 30704:     // We skip the nsWindows that don't have mGdkWindows.
     1:     // These are probably in the process of being destroyed.
     1: 
     1:     if (!GetNextSibling()) {
     1:         // We're to be on top.
 30704:         if (mGdkWindow)
 30704:             gdk_window_raise(mGdkWindow);
     1:     } else {
     1:         // All the siblings before us need to be below our widget.
     1:         for (nsWindow* w = this; w;
  3233:              w = static_cast<nsWindow*>(w->GetPrevSibling())) {
 30704:             if (w->mGdkWindow)
 30704:                 gdk_window_lower(w->mGdkWindow);
     1:         }
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsWindow::SetSizeMode(int32_t aMode)
     1: {
     1:     nsresult rv;
     1: 
     1:     LOG(("nsWindow::SetSizeMode [%p] %d\n", (void *)this, aMode));
     1: 
     1:     // Save the requested state.
     1:     rv = nsBaseWidget::SetSizeMode(aMode);
     1: 
     1:     // return if there's no shell or our current state is the same as
     1:     // the mode we were just set to.
     1:     if (!mShell || mSizeState == mSizeMode) {
     1:         return rv;
     1:     }
     1: 
     1:     switch (aMode) {
     1:     case nsSizeMode_Maximized:
     1:         gtk_window_maximize(GTK_WINDOW(mShell));
     1:         break;
     1:     case nsSizeMode_Minimized:
     1:         gtk_window_iconify(GTK_WINDOW(mShell));
     1:         break;
 31567:     case nsSizeMode_Fullscreen:
 79636:         MakeFullScreen(true);
 31567:         break;
 31567: 
     1:     default:
     1:         // nsSizeMode_Normal, really.
     1:         if (mSizeState == nsSizeMode_Minimized)
     1:             gtk_window_deiconify(GTK_WINDOW(mShell));
     1:         else if (mSizeState == nsSizeMode_Maximized)
     1:             gtk_window_unmaximize(GTK_WINDOW(mShell));
     1:         break;
     1:     }
     1: 
     1:     mSizeState = mSizeMode;
     1: 
     1:     return rv;
     1: }
     1: 
     1: typedef void (* SetUserTimeFunc)(GdkWindow* aWindow, guint32 aTimestamp);
     1: 
     1: // This will become obsolete when new GTK APIs are widely supported,
     1: // as described here: http://bugzilla.gnome.org/show_bug.cgi?id=347375
     1: static void
     1: SetUserTimeAndStartupIDForActivatedWindow(GtkWidget* aWindow)
     1: {
 80842:     nsGTKToolkit* GTKToolkit = nsGTKToolkit::GetToolkit();
 80842:     if (!GTKToolkit)
     1:         return;
     1: 
110974:     nsAutoCString desktopStartupID;
     1:     GTKToolkit->GetDesktopStartupID(&desktopStartupID);
     1:     if (desktopStartupID.IsEmpty()) {
     1:         // We don't have the data we need. Fall back to an
     1:         // approximation ... using the timestamp of the remote command
     1:         // being received as a guess for the timestamp of the user event
     1:         // that triggered it.
108991:         uint32_t timestamp = GTKToolkit->GetFocusTimestamp();
     1:         if (timestamp) {
 78664:             gdk_window_focus(gtk_widget_get_window(aWindow), timestamp);
     1:             GTKToolkit->SetFocusTimestamp(0);
     1:         }
     1:         return;
     1:     }
     1: 
 78664: #if defined(MOZ_ENABLE_STARTUP_NOTIFICATION)
 78664:     GdkWindow* gdkWindow = gtk_widget_get_window(aWindow);
 78664:   
 78664:     GdkScreen* screen = gdk_window_get_screen(gdkWindow);
     1:     SnDisplay* snd =
 78664:         sn_display_new(gdk_x11_display_get_xdisplay(gdk_window_get_display(gdkWindow)), 
106838:                        nullptr, nullptr);
     1:     if (!snd)
     1:         return;
     1:     SnLauncheeContext* ctx =
     1:         sn_launchee_context_new(snd, gdk_screen_get_number(screen),
     1:                                 desktopStartupID.get());
     1:     if (!ctx) {
     1:         sn_display_unref(snd);
     1:         return;
     1:     }
     1: 
     1:     if (sn_launchee_context_get_id_has_timestamp(ctx)) {
     1:         PRLibrary* gtkLibrary;
     1:         SetUserTimeFunc setUserTimeFunc = (SetUserTimeFunc)
     1:             PR_FindFunctionSymbolAndLibrary("gdk_x11_window_set_user_time", &gtkLibrary);
     1:         if (setUserTimeFunc) {
 78664:             setUserTimeFunc(gdkWindow, sn_launchee_context_get_timestamp(ctx));
     1:             PR_UnloadLibrary(gtkLibrary);
     1:         }
     1:     }
     1: 
 78664:     sn_launchee_context_setup_window(ctx, gdk_x11_window_get_xid(gdkWindow));
     1:     sn_launchee_context_complete(ctx);
     1: 
     1:     sn_launchee_context_unref(ctx);
     1:     sn_display_unref(snd);
     1: #endif
     1: 
 90270:     // If we used the startup ID, that already contains the focus timestamp;
 90270:     // we don't want to reuse the timestamp next time we raise the window
 90270:     GTKToolkit->SetFocusTimestamp(0);
     1:     GTKToolkit->SetDesktopStartupID(EmptyCString());
     1: }
     1: 
 89550: /* static */ guint32
 90019: nsWindow::GetLastUserInputTime()
 90019: {
 90019:     // gdk_x11_display_get_user_time tracks button and key presses,
 90019:     // DESKTOP_STARTUP_ID used to start the app, drop events from external
 90019:     // drags, WM_DELETE_WINDOW delete events, but not usually mouse motion nor
 90019:     // button and key releases.  Therefore use the most recent of
 90019:     // gdk_x11_display_get_user_time and the last time that we have seen.
 90019:     guint32 timestamp =
 90019:             gdk_x11_display_get_user_time(gdk_display_get_default());
 90019:     if (sLastUserInputTime != GDK_CURRENT_TIME &&
 90019:         TimestampIsNewerThan(sLastUserInputTime, timestamp)) {
 90019:         return sLastUserInputTime;
 90019:     }       
 90019: 
 89550:     return timestamp;
 89550: }
 89550: 
     1: NS_IMETHODIMP
 79445: nsWindow::SetFocus(bool aRaise)
     1: {
     1:     // Make sure that our owning widget has focus.  If it doesn't try to
     1:     // grab it.  Note that we don't set our focus flag in this case.
     1: 
 43760:     LOGFOCUS(("  SetFocus %d [%p]\n", aRaise, (void *)this));
     1: 
 18490:     GtkWidget *owningWidget = GetMozContainerWidget();
     1:     if (!owningWidget)
     1:         return NS_ERROR_FAILURE;
     1: 
 79636:     // Raise the window if someone passed in true and the prefs are
     1:     // set properly.
     1:     GtkWidget *toplevelWidget = gtk_widget_get_toplevel(owningWidget);
     1: 
     1:     if (gRaiseWindows && aRaise && toplevelWidget &&
 78664:         !gtk_widget_has_focus(owningWidget) &&
 78664:         !gtk_widget_has_focus(toplevelWidget)) {
121096:         GtkWidget* top_window = GetToplevelWidget();
 78664:         if (top_window && (gtk_widget_get_visible(top_window)))
 78664:         {
 78664:             gdk_window_show_unraised(gtk_widget_get_window(top_window));
     1:             // Unset the urgency hint if possible.
 79636:             SetUrgencyHint(top_window, false);
     1:         }
     1:     }
     1: 
   920:     nsRefPtr<nsWindow> owningWindow = get_window_for_gtk_widget(owningWidget);
     1:     if (!owningWindow)
     1:         return NS_ERROR_FAILURE;
     1: 
 43760:     if (aRaise) {
 79636:         // aRaise == true means request toplevel activation.
 43760: 
 43760:         // This is asynchronous.
 43760:         // If and when the window manager accepts the request, then the focus
 43760:         // widget will get a focus-in-event signal.
 43760:         if (gRaiseWindows && owningWindow->mIsShown && owningWindow->mShell &&
 43760:             !gtk_window_is_active(GTK_WINDOW(owningWindow->mShell))) {
 43760: 
108991:             uint32_t timestamp = GDK_CURRENT_TIME;
 90270: 
 90270:             nsGTKToolkit* GTKToolkit = nsGTKToolkit::GetToolkit();
 90270:             if (GTKToolkit)
 90270:                 timestamp = GTKToolkit->GetFocusTimestamp();
 90270: 
 43760:             LOGFOCUS(("  requesting toplevel activation [%p]\n", (void *)this));
 43760:             NS_ASSERTION(owningWindow->mWindowType != eWindowType_popup
 43760:                          || mParent,
 43760:                          "Presenting an override-redirect window");
 90270:             gtk_window_present_with_time(GTK_WINDOW(owningWindow->mShell), timestamp);
 90270: 
 90270:             if (GTKToolkit)
 90270:                 GTKToolkit->SetFocusTimestamp(0);
 43760:         }
 43760: 
 43760:         return NS_OK;
 43760:     }
 43760: 
 79636:     // aRaise == false means that keyboard events should be dispatched
 43760:     // from this widget.
 43760: 
 43760:     // Ensure owningWidget is the focused GtkWidget within its toplevel window.
 43760:     //
 43760:     // For eWindowType_popup, this GtkWidget may not actually be the one that
 43760:     // receives the key events as it may be the parent window that is active.
 43760:     if (!gtk_widget_is_focus(owningWidget)) {
 43760:         // This is synchronous.  It takes focus from a plugin or from a widget
 43760:         // in an embedder.  The focus manager already knows that this window
 43760:         // is active so gBlockActivateEvent avoids another (unnecessary)
108457:         // activate notification.
 79636:         gBlockActivateEvent = true;
     1:         gtk_widget_grab_focus(owningWidget);
 79636:         gBlockActivateEvent = false;
     1:     }
     1: 
     1:     // If this is the widget that already has focus, return.
     1:     if (gFocusWindow == this) {
     1:         LOGFOCUS(("  already have focus [%p]\n", (void *)this));
     1:         return NS_OK;
     1:     }
     1: 
 29018:     // Set this window to be the focused child window
     1:     gFocusWindow = this;
     1: 
 39627:     if (mIMModule) {
 39627:         mIMModule->OnFocusWindow(this);
 39627:     }
     1: 
 30583:     LOGFOCUS(("  widget now has focus in SetFocus() [%p]\n",
     1:               (void *)this));
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 23738: nsWindow::GetScreenBounds(nsIntRect &aRect)
 23738: {
 48259:     if (mIsTopLevel && mContainer) {
 48259:         // use the point including window decorations
 48259:         gint x, y;
 78664:         gdk_window_get_root_origin(gtk_widget_get_window(GTK_WIDGET(mContainer)), &x, &y);
 48259:         aRect.MoveTo(x, y);
 48259:     }
 48259:     else {
 48259:         aRect.MoveTo(WidgetToScreenOffset());
 48259:     }
 73647:     // mBounds.Size() is the window bounds, not the window-manager frame
 73647:     // bounds (bug 581863).  gdk_window_get_frame_extents would give the
 73647:     // frame bounds, but mBounds.Size() is returned here for consistency
 73647:     // with Resize.
 48259:     aRect.SizeTo(mBounds.Size());
 73647:     LOG(("GetScreenBounds %d,%d | %dx%d\n",
 73647:          aRect.x, aRect.y, aRect.width, aRect.height));
     1:     return NS_OK;
     1: }
     1: 
 83100: NS_IMETHODIMP
 83107: nsWindow::GetClientBounds(nsIntRect &aRect)
 83107: {
 83107:     // GetBounds returns a rect whose top left represents the top left of the
 83107:     // outer bounds, but whose width/height represent the size of the inner
 83107:     // bounds (which is messed up).
 83107:     GetBounds(aRect);
 83107:     aRect.MoveBy(GetClientOffset());
 83107: 
 83107:     return NS_OK;
 83107: }
 83107: 
 83107: nsIntPoint
 83107: nsWindow::GetClientOffset()
 83107: {
 83107:     if (!mIsTopLevel) {
 83107:         return nsIntPoint(0, 0);
 83107:     }
 83107: 
 83107:     GdkAtom cardinal_atom = gdk_x11_xatom_to_atom(XA_CARDINAL);
 83107: 
 83107:     GdkAtom type_returned;
 83107:     int format_returned;
 83107:     int length_returned;
 83107:     long *frame_extents;
 99595:     GdkWindow* window;
 99595: 
 99595:     if (!mShell || !(window = gtk_widget_get_window(mShell)) ||
 99595:         !gdk_property_get(window,
 83107:                           gdk_atom_intern ("_NET_FRAME_EXTENTS", FALSE),
 83107:                           cardinal_atom,
 83107:                           0, // offset
 83107:                           4*4, // length
 83107:                           FALSE, // delete
 83107:                           &type_returned,
 83107:                           &format_returned,
 83107:                           &length_returned,
 83107:                           (guchar **) &frame_extents) ||
 83107:         length_returned/sizeof(glong) != 4) {
 83107: 
 83107:         return nsIntPoint(0, 0);
 83107:     }
 83107: 
 83107:     // data returned is in the order left, right, top, bottom
108991:     int32_t left = int32_t(frame_extents[0]);
108991:     int32_t top = int32_t(frame_extents[2]);
 83107: 
 83107:     g_free(frame_extents);
 83107: 
 83107:     return nsIntPoint(left, top);
 83107: }
 83107: 
 83107: NS_IMETHODIMP
     1: nsWindow::SetForegroundColor(const nscolor &aColor)
     1: {
     1:     return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWindow::SetBackgroundColor(const nscolor &aColor)
     1: {
     1:     return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWindow::SetCursor(nsCursor aCursor)
     1: {
     1:     // if we're not the toplevel window pass up the cursor request to
     1:     // the toplevel window to handle it.
 30704:     if (!mContainer && mGdkWindow) {
 25258:         nsWindow *window = GetContainerWindow();
 25258:         if (!window)
 25258:             return NS_ERROR_FAILURE;
 25258: 
     1:         return window->SetCursor(aCursor);
     1:     }
     1: 
     1:     // Only change cursor if it's actually been changed
     1:     if (aCursor != mCursor) {
     1:         GdkCursor *newCursor = NULL;
     1: 
     1:         newCursor = get_gtk_cursor(aCursor);
     1: 
106838:         if (nullptr != newCursor) {
     1:             mCursor = aCursor;
     1: 
     1:             if (!mContainer)
     1:                 return NS_OK;
     1: 
 78664:             gdk_window_set_cursor(gtk_widget_get_window(GTK_WIDGET(mContainer)), newCursor);
     1:         }
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWindow::SetCursor(imgIContainer* aCursor,
108991:                     uint32_t aHotspotX, uint32_t aHotspotY)
     1: {
     1:     // if we're not the toplevel window pass up the cursor request to
     1:     // the toplevel window to handle it.
 30704:     if (!mContainer && mGdkWindow) {
 25258:         nsWindow *window = GetContainerWindow();
 25258:         if (!window)
 25258:             return NS_ERROR_FAILURE;
 25258: 
     1:         return window->SetCursor(aCursor, aHotspotX, aHotspotY);
     1:     }
     1: 
     1:     mCursor = nsCursor(-1);
     1: 
 30479:     // Get the image's current frame
 30479:     GdkPixbuf* pixbuf = nsImageToPixbuf::ImageToPixbuf(aCursor);
     1:     if (!pixbuf)
     1:         return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:     int width = gdk_pixbuf_get_width(pixbuf);
     1:     int height = gdk_pixbuf_get_height(pixbuf);
     1:     // Reject cursors greater than 128 pixels in some direction, to prevent
     1:     // spoofing.
     1:     // XXX ideally we should rescale. Also, we could modify the API to
     1:     // allow trusted content to set larger cursors.
  6790:     if (width > 128 || height > 128) {
 24530:         g_object_unref(pixbuf);
     1:         return NS_ERROR_NOT_AVAILABLE;
  6790:     }
     1: 
     1:     // Looks like all cursors need an alpha channel (tested on Gtk 2.4.4). This
     1:     // is of course not documented anywhere...
     1:     // So add one if there isn't one yet
     1:     if (!gdk_pixbuf_get_has_alpha(pixbuf)) {
     1:         GdkPixbuf* alphaBuf = gdk_pixbuf_add_alpha(pixbuf, FALSE, 0, 0, 0);
 24530:         g_object_unref(pixbuf);
     1:         if (!alphaBuf) {
     1:             return NS_ERROR_OUT_OF_MEMORY;
     1:         }
     1:         pixbuf = alphaBuf;
     1:     }
     1: 
 78664:     GdkCursor* cursor = gdk_cursor_new_from_pixbuf(gdk_display_get_default(),
     1:                                                    pixbuf,
     1:                                                    aHotspotX, aHotspotY);
 24530:     g_object_unref(pixbuf);
     1:     nsresult rv = NS_ERROR_OUT_OF_MEMORY;
     1:     if (cursor) {
     1:         if (mContainer) {
 78664:             gdk_window_set_cursor(gtk_widget_get_window(GTK_WIDGET(mContainer)), cursor);
     1:             rv = NS_OK;
     1:         }
     1:         gdk_cursor_unref(cursor);
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
 87336: nsWindow::Invalidate(const nsIntRect &aRect)
     1: {
 34456:     if (!mGdkWindow)
 30702:         return NS_OK;
 30702: 
     1:     GdkRectangle rect;
     1:     rect.x = aRect.x;
     1:     rect.y = aRect.y;
     1:     rect.width = aRect.width;
     1:     rect.height = aRect.height;
     1: 
 87336:     LOGDRAW(("Invalidate (rect) [%p]: %d %d %d %d\n", (void *)this,
 87336:              rect.x, rect.y, rect.width, rect.height));
     1: 
 30704:     gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
 87336: 
     1:     return NS_OK;
     1: }
     1: 
     1: void*
108991: nsWindow::GetNativeData(uint32_t aDataType)
     1: {
     1:     switch (aDataType) {
     1:     case NS_NATIVE_WINDOW:
     1:     case NS_NATIVE_WIDGET: {
 30704:         if (!mGdkWindow)
106838:             return nullptr;
     1: 
 30704:         return mGdkWindow;
     1:         break;
     1:     }
     1: 
     1:     case NS_NATIVE_PLUGIN_PORT:
     1:         return SetupPluginPort();
     1:         break;
     1: 
     1:     case NS_NATIVE_DISPLAY:
 16529: #ifdef MOZ_X11
 78664:         return GDK_DISPLAY_XDISPLAY(gdk_display_get_default());
 16529: #else
106838:         return nullptr;
 16529: #endif /* MOZ_X11 */
     1:         break;
     1: 
     1:     case NS_NATIVE_SHELLWIDGET:
121096:         return GetToplevelWidget();
     1: 
 77658:     case NS_NATIVE_SHAREABLE_WINDOW:
 77658:         return (void *) GDK_WINDOW_XID(gdk_window_get_toplevel(mGdkWindow));
 77658: 
     1:     default:
     1:         NS_WARNING("nsWindow::GetNativeData called with bad value");
106838:         return nullptr;
     1:     }
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWindow::SetTitle(const nsAString& aTitle)
     1: {
     1:     if (!mShell)
     1:         return NS_OK;
     1: 
     1:     // convert the string into utf8 and set the title.
     1: #define UTF8_FOLLOWBYTE(ch) (((ch) & 0xC0) == 0x80)
     1:     NS_ConvertUTF16toUTF8 titleUTF8(aTitle);
     1:     if (titleUTF8.Length() > NS_WINDOW_TITLE_MAX_LENGTH) {
     1:         // Truncate overlong titles (bug 167315). Make sure we chop after a
     1:         // complete sequence by making sure the next char isn't a follow-byte.
108991:         uint32_t len = NS_WINDOW_TITLE_MAX_LENGTH;
     1:         while(UTF8_FOLLOWBYTE(titleUTF8[len]))
     1:             --len;
     1:         titleUTF8.Truncate(len);
     1:     }
     1:     gtk_window_set_title(GTK_WINDOW(mShell), (const char *)titleUTF8.get());
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWindow::SetIcon(const nsAString& aIconSpec)
     1: {
     1:     if (!mShell)
     1:         return NS_OK;
     1: 
110974:     nsAutoCString iconName;
 84531:     
 84531:     if (aIconSpec.EqualsLiteral("default")) {
 84531:         nsXPIDLString brandName;
 84531:         GetBrandName(brandName);
 84531:         AppendUTF16toUTF8(brandName, iconName);
 84531:         ToLowerCase(iconName);
 84531:     } else {
 84531:         AppendUTF16toUTF8(aIconSpec, iconName);
 84531:     }
 84531:     
101111:     nsCOMPtr<nsIFile> iconFile;
110974:     nsAutoCString path;
 84531: 
 87052:     gint *iconSizes =
 87052:         gtk_icon_theme_get_icon_sizes(gtk_icon_theme_get_default(),
 84531:                                       iconName.get());
 87052:     bool foundIcon = (iconSizes[0] != 0);
 87052:     g_free(iconSizes);
 84531: 
 84531:     if (!foundIcon) {
 84531:         // Look for icons with the following suffixes appended to the base name
 10124:         // The last two entries (for the old XPM format) will be ignored unless
 84531:         // no icons are found using other suffixes. XPM icons are deprecated.
 10124: 
 10124:         const char extensions[6][7] = { ".png", "16.png", "32.png", "48.png",
 10124:                                     ".xpm", "16.xpm" };
 10124: 
108991:         for (uint32_t i = 0; i < ArrayLength(extensions); i++) {
 10124:             // Don't bother looking for XPM versions if we found a PNG.
 84531:             if (i == ArrayLength(extensions) - 2 && foundIcon)
 10124:                 break;
 10124: 
 10124:             nsAutoString extension;
 10124:             extension.AppendASCII(extensions[i]);
 10124: 
 10124:             ResolveIconName(aIconSpec, extension, getter_AddRefs(iconFile));
     1:             if (iconFile) {
     1:                 iconFile->GetNativePath(path);
 84531:                 GdkPixbuf *icon = gdk_pixbuf_new_from_file(path.get(), NULL);
 84531:                 if (icon){
 84531:                     gtk_icon_theme_add_builtin_icon(iconName.get(),
 84531:                                                     gdk_pixbuf_get_height(icon),
 84531:                                                     icon);
 84531:                     g_object_unref(icon);
 84531:                     foundIcon = true;
 84531:                 }
 84531:             }
     1:         }
     1:     }
     1: 
     1:     // leave the default icon intact if no matching icons were found
 84531:     if (foundIcon) {
 84531:         gtk_window_set_icon_name(GTK_WINDOW(mShell), iconName.get());
 84531:     }
 84531: 
     1:     return NS_OK;
 84531: }
 84531: 
     1: 
 25183: nsIntPoint
 25183: nsWindow::WidgetToScreenOffset()
     1: {
     1:     gint x = 0, y = 0;
     1: 
 48259:     if (mGdkWindow) {
 30704:         gdk_window_get_origin(mGdkWindow, &x, &y);
 25183:     }
 25183: 
 25183:     return nsIntPoint(x, y);
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsWindow::EnableDragDrop(bool aEnable)
     1: {
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsWindow::CaptureMouse(bool aCapture)
     1: {
     1:     LOG(("CaptureMouse %p\n", (void *)this));
     1: 
 30704:     if (!mGdkWindow)
     1:         return NS_OK;
     1: 
120426:     if (!mShell)
 25258:         return NS_ERROR_FAILURE;
     1: 
     1:     if (aCapture) {
120426:         gtk_grab_add(mShell);
 90019:         GrabPointer(GetLastUserInputTime());
     1:     }
     1:     else {
     1:         ReleaseGrabs();
120426:         gtk_grab_remove(mShell);
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWindow::CaptureRollupEvents(nsIRollupListener *aListener,
120177:                               bool               aDoCapture)
     1: {
 30704:     if (!mGdkWindow)
     1:         return NS_OK;
     1: 
120426:     if (!mShell)
 25258:         return NS_ERROR_FAILURE;
     1: 
120506:     LOG(("CaptureRollupEvents %p %i\n", this, int(aDoCapture)));
     1: 
     1:     if (aDoCapture) {
     1:         gRollupListener = aListener;
     1:         // real grab is only done when there is no dragging
     1:         if (!nsWindow::DragInProgress()) {
120426:             // This widget grab ensures that a Gecko GtkWidget receives mouse
120426:             // events even when embedded in non-Gecko-owned GtkWidgets.
120426:             // The grab is placed on the toplevel GtkWindow instead of the
120426:             // MozContainer to avoid double dispatch of keyboard events
120426:             // (bug 707623).
120426:             gtk_grab_add(mShell);
 90019:             GrabPointer(GetLastUserInputTime());
     1:         }
     1:     }
     1:     else {
     1:         if (!nsWindow::DragInProgress()) {
     1:             ReleaseGrabs();
 62720:         }
 62720:         // There may not have been a drag in process when aDoCapture was set,
 62720:         // so make sure to remove any added grab.  This is a no-op if the grab
 62720:         // was not added to this widget.
120426:         gtk_grab_remove(mShell);
106838:         gRollupListener = nullptr;
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsWindow::GetAttention(int32_t aCycleCount)
     1: {
     1:     LOG(("nsWindow::GetAttention [%p]\n", (void *)this));
     1: 
121096:     GtkWidget* top_window = GetToplevelWidget();
121096:     GtkWidget* top_focused_window =
121161:         gFocusWindow ? gFocusWindow->GetToplevelWidget() : nullptr;
     1: 
     1:     // Don't get attention if the window is focused anyway.
 78664:     if (top_window && (gtk_widget_get_visible(top_window)) &&
     1:         top_window != top_focused_window) {
 79636:         SetUrgencyHint(top_window, true);
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
 79445: bool
 27993: nsWindow::HasPendingInputEvent()
 27993: {
 27993:     // This sucks, but gtk/gdk has no way to answer the question we want while
 27993:     // excluding paint events, and there's no X API that will let us peek
 27993:     // without blocking or removing.  To prevent event reordering, peek
 27993:     // anything except expose events.  Reordering expose and others should be
 27993:     // ok, hopefully.
 79445:     bool haveEvent;
 27993: #ifdef MOZ_X11
 27993:     XEvent ev;
 78664:     Display *display = GDK_DISPLAY_XDISPLAY(gdk_display_get_default());
 27993:     haveEvent =
 78664:         XCheckMaskEvent(display,
 27993:                         KeyPressMask | KeyReleaseMask | ButtonPressMask |
 27993:                         ButtonReleaseMask | EnterWindowMask | LeaveWindowMask |
 27993:                         PointerMotionMask | PointerMotionHintMask |
 27993:                         Button1MotionMask | Button2MotionMask |
 27993:                         Button3MotionMask | Button4MotionMask |
 27993:                         Button5MotionMask | ButtonMotionMask | KeymapStateMask |
 27993:                         VisibilityChangeMask | StructureNotifyMask |
 27993:                         ResizeRedirectMask | SubstructureNotifyMask |
 27993:                         SubstructureRedirectMask | FocusChangeMask |
 27993:                         PropertyChangeMask | ColormapChangeMask |
 27993:                         OwnerGrabButtonMask, &ev);
 27993:     if (haveEvent) {
 78664:         XPutBackEvent(display, &ev);
 27993:     }
 27993: #else
 79636:     haveEvent = false;
 27993: #endif
 27993:     return haveEvent;
 27993: }
 27993: 
 18490: #if 0
     1: #ifdef DEBUG
 18490: // Paint flashing code (disabled for cairo - see below)
     1: 
     1: #define CAPS_LOCK_IS_ON \
 90660: (KeymapWrapper::AreModifiersCurrentlyActive(KeymapWrapper::CAPS_LOCK))
     1: 
     1: #define WANT_PAINT_FLASHING \
     1: (debug_WantPaintFlashing() && CAPS_LOCK_IS_ON)
     1: 
 16529: #ifdef MOZ_X11
     1: static void
     1: gdk_window_flash(GdkWindow *    aGdkWindow,
     1:                  unsigned int   aTimes,
     1:                  unsigned int   aInterval,  // Milliseconds
     1:                  GdkRegion *    aRegion)
     1: {
     1:   gint         x;
     1:   gint         y;
     1:   gint         width;
     1:   gint         height;
     1:   guint        i;
     1:   GdkGC *      gc = 0;
     1:   GdkColor     white;
     1: 
 78664: #if defined(MOZ_WIDGET_GTK2)
 78664:   gdk_window_get_geometry(aGdkWindow,NULL,NULL,&width,&height,NULL);
 78664: #else
 78664:   gdk_window_get_geometry(aGdkWindow,NULL,NULL,&width,&height);
 78664: #endif
     1: 
     1:   gdk_window_get_origin (aGdkWindow,
     1:                          &x,
     1:                          &y);
     1: 
     1:   gc = gdk_gc_new(GDK_ROOT_PARENT());
     1: 
     1:   white.pixel = WhitePixel(gdk_display,DefaultScreen(gdk_display));
     1: 
     1:   gdk_gc_set_foreground(gc,&white);
     1:   gdk_gc_set_function(gc,GDK_XOR);
     1:   gdk_gc_set_subwindow(gc,GDK_INCLUDE_INFERIORS);
     1: 
     1:   gdk_region_offset(aRegion, x, y);
     1:   gdk_gc_set_clip_region(gc, aRegion);
     1: 
     1:   /*
     1:    * Need to do this twice so that the XOR effect can replace
     1:    * the original window contents.
     1:    */
     1:   for (i = 0; i < aTimes * 2; i++)
     1:   {
     1:     gdk_draw_rectangle(GDK_ROOT_PARENT(),
     1:                        gc,
     1:                        TRUE,
     1:                        x,
     1:                        y,
     1:                        width,
     1:                        height);
     1: 
     1:     gdk_flush();
     1: 
     1:     PR_Sleep(PR_MillisecondsToInterval(aInterval));
     1:   }
     1: 
     1:   gdk_gc_destroy(gc);
     1: 
     1:   gdk_region_offset(aRegion, -x, -y);
     1: }
 16529: #endif /* MOZ_X11 */
     1: #endif // DEBUG
 18490: #endif
     1: 
 78664: #if defined(MOZ_WIDGET_GTK2)
     1: gboolean
 78664: nsWindow::OnExposeEvent(GdkEventExpose *aEvent)
 78664: #else
 78664: gboolean
 78664: nsWindow::OnExposeEvent(cairo_t *cr)
 78664: #endif
     1: {
     1:     if (mIsDestroyed) {
     1:         return FALSE;
     1:     }
     1: 
 34456:     // Windows that are not visible will be painted after they become visible.
 34456:     if (!mGdkWindow || mIsFullyObscured || !mHasMappedToplevel)
     1:         return FALSE;
     1: 
119753:     nsIWidgetListener *listener =
119753:         mAttachedWidgetListener ? mAttachedWidgetListener : mWidgetListener;
119753:     if (!listener)
119753:         return FALSE;
119753: 
108457:     // Dispatch WillPaintWindow notification to allow scripts etc. to run
108457:     // before we paint
108457:     {
119753:         listener->WillPaintWindow(this, true);
108457: 
108457:         // If the window has been destroyed during the will paint notification,
108457:         // there is nothing left to do.
 69478:         if (!mGdkWindow)
 69478:             return TRUE;
122971: 
122971:         // Re-get the listener since the will paint notification might have
122971:         // killed it.
122971:         listener =
122971:             mAttachedWidgetListener ? mAttachedWidgetListener : mWidgetListener;
122971:         if (!listener)
122971:             return FALSE;
 61316:     }
 61316: 
 78664: #if defined(MOZ_WIDGET_GTK2)
     1:     GdkRectangle *rects;
     1:     gint nrects;
     1:     gdk_region_get_rectangles(aEvent->region, &rects, &nrects);
120353:     if (MOZ_UNLIKELY(!rects)) // OOM
  3368:         return FALSE;
 78664: #else
 78664: #ifdef cairo_copy_clip_rectangle_list
 78664: #error "Looks like we're including Mozilla's cairo instead of system cairo"
 78664: #else
 78664:     cairo_rectangle_list_t *rects;
 78664:     rects = cairo_copy_clip_rectangle_list(cr);  
120353:     if (MOZ_UNLIKELY(rects->status != CAIRO_STATUS_SUCCESS)) {
 78664:        NS_WARNING("Failed to obtain cairo rectangle list.");
 78664:        return FALSE;
 78664:     }
 78664: #endif
 78664: #endif
 78664: 
 78664: // GTK3 TODO?
 78664: #if defined(MOZ_WIDGET_GTK2)
 25021:     if (nrects > MAX_RECTS_IN_REGION) {
 25021:         // Just use the bounding box
 25021:         rects[0] = aEvent->area;
 25021:         nrects = 1;
 25021:     }
 78664: #endif
 25021: 
     1:     LOGDRAW(("sending expose event [%p] %p 0x%lx (rects follow):\n",
 78664:              (void *)this, (void *)mGdkWindow,
 78664:              gdk_x11_window_get_xid(mGdkWindow)));
 78664: 
108457:     nsIntRegion region;
108457:   
 78664: #if defined(MOZ_WIDGET_GTK2)
 78664:     GdkRectangle *r = rects;
     1:     GdkRectangle *r_end = rects + nrects;
 78664: #else
 78664:     cairo_rectangle_t *r = rects->rectangles;
 78664:     cairo_rectangle_t *r_end = r + rects->num_rectangles;
 78664: #endif
 78664:     for (; r < r_end; ++r) {
108457:         region.Or(region, nsIntRect(r->x, r->y, r->width, r->height));
     1:         LOGDRAW(("\t%d %d %d %d\n", r->x, r->y, r->width, r->height));
     1:     }
     1: 
108457:     // Our bounds may have changed after calling WillPaintWindow.  Clip
108457:     // to the new bounds here.  The region is relative to this
 61316:     // window.
108457:     region.And(region, nsIntRect(0, 0, mBounds.width, mBounds.height));
 61316: 
115975:     bool shaped = false;
115975:     if (eTransparencyTransparent == GetTransparencyMode()) {
115975:         GdkScreen *screen = gdk_window_get_screen(mGdkWindow);
115975:         if (gdk_screen_is_composited(screen) &&
115975:             gdk_window_get_visual(mGdkWindow) ==
115975:             gdk_screen_get_rgba_visual(screen)) {
115975:             // Remove possible shape mask from when window manger was not
115975:             // previously compositing.
115975:             static_cast<nsWindow*>(GetTopLevelWidget())->
115975:                 ClearTransparencyBitmap();
115975:         } else {
115975:             shaped = true;
115975:         }
115975:     }
115975: 
115975:     if (!shaped) {
 30516:         GList *children =
 30704:             gdk_window_peek_children(mGdkWindow);
 30516:         while (children) {
 30516:             GdkWindow *gdkWin = GDK_WINDOW(children->data);
 30516:             nsWindow *kid = get_window_for_gdk_window(gdkWin);
 30631:             if (kid && gdk_window_is_visible(gdkWin)) {
 30516:                 nsAutoTArray<nsIntRect,1> clipRects;
 30516:                 kid->GetWindowClipRegion(&clipRects);
 30516:                 nsIntRect bounds;
 30516:                 kid->GetBounds(bounds);
108991:                 for (uint32_t i = 0; i < clipRects.Length(); ++i) {
 30516:                     nsIntRect r = clipRects[i] + bounds.TopLeft();
108457:                     region.Sub(region, r);
 30516:                 }
 30516:             }
 30516:             children = children->next;
 30516:         }
 30516:     }
 30516: 
108457:     if (region.IsEmpty()) {
 78664: #if defined(MOZ_WIDGET_GTK2)
 30516:         g_free(rects);
 78664: #else
 78664:         cairo_rectangle_list_destroy(rects);
 78664: #endif
 30516:         return TRUE;
 30516:     }
 99629:     // If this widget uses OMTC...
 99629:     if (GetLayerManager()->AsShadowForwarder() && GetLayerManager()->AsShadowForwarder()->HasShadowManager()) {
 99629: #if defined(MOZ_WIDGET_GTK2)
 99629:         nsRefPtr<gfxContext> ctx = new gfxContext(GetThebesSurface());
 99629: #else
 99629:         nsRefPtr<gfxContext> ctx = new gfxContext(GetThebesSurface(cr));
 99629: #endif
 99629:         nsBaseWidget::AutoLayerManagerSetup
106914:           setupLayerManager(this, ctx, mozilla::layers::BUFFER_NONE);
108457: 
119753:         listener->PaintWindow(this, region, nsIWidgetListener::SENT_WILL_PAINT | nsIWidgetListener::WILL_SEND_DID_PAINT);
119753:         listener->DidPaintWindow();
 99629: 
 99629:         g_free(rects);
 99629:         return TRUE;
 99629: 
105710:     } else if (GetLayerManager()->GetBackendType() == mozilla::layers::LAYERS_OPENGL) {
 63893:         LayerManagerOGL *manager = static_cast<LayerManagerOGL*>(GetLayerManager());
108457:         manager->SetClippingRegion(region);
108457: 
119753:         listener->PaintWindow(this, region, nsIWidgetListener::SENT_WILL_PAINT | nsIWidgetListener::WILL_SEND_DID_PAINT);
119753:         listener->DidPaintWindow();
 61316: 
 44138:         g_free(rects);
 44138:         return TRUE;
 44138:     }
 44138: 
 78664: #if defined(MOZ_WIDGET_GTK2)
 38805:     nsRefPtr<gfxContext> ctx = new gfxContext(GetThebesSurface());
 78664: #else
 78664:     nsRefPtr<gfxContext> ctx = new gfxContext(GetThebesSurface(cr));
 78664: #endif
 16529: 
 16529: #ifdef MOZ_X11
115975:     nsIntRect boundsRect; // for shaped only
     1: 
     1:     ctx->NewPath();
115975:     if (shaped) {
     1:         // Collapse update area to the bounding box. This is so we only have to
     1:         // call UpdateTranslucentWindowAlpha once. After we have dropped
     1:         // support for non-Thebes graphics, UpdateTranslucentWindowAlpha will be
     1:         // our private interface so we can rework things to avoid this.
108457:         boundsRect = region.GetBounds();
     1:         ctx->Rectangle(gfxRect(boundsRect.x, boundsRect.y,
     1:                                boundsRect.width, boundsRect.height));
     1:     } else {
108457:         gfxUtils::PathFromRegion(ctx, region);
     1:     }
     1:     ctx->Clip();
     1: 
106914:     BufferMode layerBuffering;
115975:     if (shaped) {
 47761:         // The double buffering is done here to extract the shape mask.
 47761:         // (The shape mask won't be necessary when a visual with an alpha
 47761:         // channel is used on compositing window managers.)
106914:         layerBuffering = mozilla::layers::BUFFER_NONE;
     1:         ctx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
 54594: #ifdef MOZ_HAVE_SHMIMAGE
 56628:     } else if (nsShmImage::UseShm()) {
 54594:         // We're using an xshm mapping as a back buffer.
106914:         layerBuffering = mozilla::layers::BUFFER_NONE;
 54594: #endif // MOZ_HAVE_SHMIMAGE
     1:     } else {
 47761:         // Get the layer manager to do double buffering (if necessary).
106914:         layerBuffering = mozilla::layers::BUFFER_BUFFERED;
     1:     }
  2467: 
  2467: #if 0
     1:     // NOTE: Paint flashing region would be wrong for cairo, since
     1:     // cairo inflates the update region, etc.  So don't paint flash
     1:     // for cairo.
  2467: #ifdef DEBUG
 61316:     // XXX aEvent->region may refer to a newly-invalid area.  FIXME
 78664:     if (0 && WANT_PAINT_FLASHING && gtk_widget_get_window(aEvent))
 78664:         gdk_window_flash(mGdkWindow, 1, 100, aEvent->region);
  2467: #endif
  2467: #endif
     1: 
 16529: #endif // MOZ_X11
 16529: 
108457:     bool painted = false;
 38805:     {
 47761:       AutoLayerManagerSetup setupLayerManager(this, ctx, layerBuffering);
119753:       painted = listener->PaintWindow(this, region, nsIWidgetListener::SENT_WILL_PAINT | nsIWidgetListener::WILL_SEND_DID_PAINT);
 38805:     }
     1: 
 16529: #ifdef MOZ_X11
108457:     // PaintWindow can Destroy us (bug 378273), avoid doing any paint
   920:     // operations below if that happened - it will lead to XError and exit().
115975:     if (shaped) {
120353:         if (MOZ_LIKELY(!mIsDestroyed)) {
108457:             if (painted) {
     1:                 nsRefPtr<gfxPattern> pattern = ctx->PopGroup();
     1: 
     1:                 nsRefPtr<gfxImageSurface> img =
     1:                     new gfxImageSurface(gfxIntSize(boundsRect.width, boundsRect.height),
     1:                                         gfxImageSurface::ImageFormatA8);
  3368:                 if (img && !img->CairoStatus()) {
     1:                     img->SetDeviceOffset(gfxPoint(-boundsRect.x, -boundsRect.y));
     1: 
     1:                     nsRefPtr<gfxContext> imgCtx = new gfxContext(img);
  3368:                     if (imgCtx) {
     1:                         imgCtx->SetPattern(pattern);
     1:                         imgCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
     1:                         imgCtx->Paint();
  3368:                     }
     1: 
 23738:                     UpdateTranslucentWindowAlphaInternal(nsIntRect(boundsRect.x, boundsRect.y,
     1:                                                                    boundsRect.width, boundsRect.height),
     1:                                                          img->Data(), img->Stride());
  3368:                 }
 69781: 
 69781:                 ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
 69781:                 ctx->SetPattern(pattern);
 69781:                 ctx->Paint();
 47761:             }
 47761:         }
   920:     }
 54594: #  ifdef MOZ_HAVE_SHMIMAGE
120353:     if (nsShmImage::UseShm() && MOZ_LIKELY(!mIsDestroyed)) {
 78664: #if defined(MOZ_WIDGET_GTK2)
 54594:         mShmImage->Put(mGdkWindow, rects, r_end);
 78664: #else
 78664:         mShmImage->Put(mGdkWindow, rects);
 78664: #endif
 54594:     }
 54594: #  endif  // MOZ_HAVE_SHMIMAGE
 16529: #endif // MOZ_X11
 16529: 
 78664: #if defined(MOZ_WIDGET_GTK2)
     1:     g_free(rects);
 78664: #else
 78664:     cairo_rectangle_list_destroy(rects);
 78664: #endif
     1: 
119753:     listener->DidPaintWindow();
 47756: 
 47756:     // Synchronously flush any new dirty areas
 78664: #if defined(MOZ_WIDGET_GTK2)
 47756:     GdkRegion* dirtyArea = gdk_window_get_update_area(mGdkWindow);
 78664: #else
 78664:     cairo_region_t* dirtyArea = gdk_window_get_update_area(mGdkWindow);
 78664: #endif
 78664: 
 47756:     if (dirtyArea) {
 79636:         gdk_window_invalidate_region(mGdkWindow, dirtyArea, false);
 78664: #if defined(MOZ_WIDGET_GTK2)
 47756:         gdk_region_destroy(dirtyArea);
 78664: #else
 78664:         cairo_region_destroy(dirtyArea);
 78664: #endif
 79636:         gdk_window_process_updates(mGdkWindow, false);
 47756:     }
 47756: 
     1:     // check the return value!
     1:     return TRUE;
     1: }
     1: 
     1: gboolean
     1: nsWindow::OnConfigureEvent(GtkWidget *aWidget, GdkEventConfigure *aEvent)
     1: {
 73647:     // These events are only received on toplevel windows.
 73647:     //
 73647:     // GDK ensures that the coordinates are the client window top-left wrt the
 73647:     // root window.
 73647:     //
 73647:     //   GDK calculates the cordinates for real ConfigureNotify events on
 73647:     //   managed windows (that would normally be relative to the parent
 73647:     //   window).
 73647:     //
 73647:     //   Synthetic ConfigureNotify events are from the window manager and
 73647:     //   already relative to the root window.  GDK creates all X windows with
 73647:     //   border_width = 0, so synthetic events also indicate the top-left of
 73647:     //   the client window.
 73647:     //
 73647:     //   Override-redirect windows are children of the root window so parent
 73647:     //   coordinates are root coordinates.
 73647: 
     1:     LOG(("configure event [%p] %d %d %d %d\n", (void *)this,
     1:          aEvent->x, aEvent->y, aEvent->width, aEvent->height));
     1: 
 83107:     nsIntRect screenBounds;
 83107:     GetScreenBounds(screenBounds);
 75007: 
 54150:     if (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog) {
 83107:         // This check avoids unwanted rollup on spurious configure events from
 83107:         // Cygwin/X (bug 672103).
 83107:         if (mBounds.x != screenBounds.x ||
 83107:             mBounds.y != screenBounds.y) {
120177:             CheckForRollup(0, 0, false, true);
 54150:         }
 83107:     }
 54150: 
 73647:     // This event indicates that the window position may have changed.
 73647:     // mBounds.Size() is updated in OnSizeAllocate().
 73647: 
 73647:     // (The gtk_window_get_window_type() function is only available from
 73647:     // version 2.20.)
 73647:     NS_ASSERTION(GTK_IS_WINDOW(aWidget),
 73647:                  "Configure event on widget that is not a GtkWindow");
 73647:     gint type;
 73647:     g_object_get(aWidget, "type", &type, NULL);
 73647:     if (type == GTK_WINDOW_POPUP) {
 73647:         // Override-redirect window
 73647:         //
 73647:         // These windows should not be moved by the window manager, and so any
 73647:         // change in position is a result of our direction.  mBounds has
 73647:         // already been set in Move() or Resize(), and that is more
 73647:         // up-to-date than the position in the ConfigureNotify event if the
 73647:         // event is from an earlier window move.
 73647:         //
108457:         // Skipping the WindowMoved call saves context menus from an infinite
 73647:         // loop when nsXULPopupManager::PopupMoved moves the window to the new
 73647:         // position and nsMenuPopupFrame::SetPopupPosition adds
 73647:         // offsetForContextMenu on each iteration.
 73647:         return FALSE;
 73647:     }
 73647: 
 83107:     mBounds.MoveTo(screenBounds.TopLeft());
     1: 
     1:     // XXX mozilla will invalidate the entire window after this move
     1:     // complete.  wtf?
108457:     if (mWidgetListener)
108457:       mWidgetListener->WindowMoved(this, mBounds.x, mBounds.y);
     1: 
     1:     return FALSE;
     1: }
     1: 
     1: void
119749: nsWindow::OnContainerUnrealize()
 28365: {
 28365:     // The GdkWindows are about to be destroyed (but not deleted), so remove
 28365:     // their references back to their container widget while the GdkWindow
 28365:     // hierarchy is still available.
 28365: 
 30704:     if (mGdkWindow) {
 34746:         DestroyChildWindows();
 30705: 
 30705:         g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", NULL);
 30705:         mGdkWindow = NULL;
 28365:     }
 28365: }
 28365: 
 28365: void
119749: nsWindow::OnSizeAllocate(GtkAllocation *aAllocation)
     1: {
     1:     LOG(("size_allocate [%p] %d %d %d %d\n",
     1:          (void *)this, aAllocation->x, aAllocation->y,
     1:          aAllocation->width, aAllocation->height));
     1: 
119752:     nsIntSize size(aAllocation->width, aAllocation->height);
119752:     if (mBounds.Size() == size)
119752:         return;
119752: 
119752:     // Invalidate the new part of the window now for the pending paint to
119752:     // minimize background flashes (GDK does not do this for external resizes
119752:     // of toplevels.)
119752:     if (mBounds.width < size.width) {
119752:         GdkRectangle rect =
119752:             { mBounds.width, 0, size.width - mBounds.width, size.height };
119752:         gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
119752:     }
119752:     if (mBounds.height < size.height) {
119752:         GdkRectangle rect =
119752:             { 0, mBounds.height, size.width, size.height - mBounds.height };
119752:         gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
119752:     }
119752: 
119752:     mBounds.SizeTo(size);
     1: 
 30704:     if (!mGdkWindow)
     1:         return;
     1: 
119753:     DispatchResized(size.width, size.height);
     1: }
     1: 
     1: void
119749: nsWindow::OnDeleteEvent()
     1: {
108457:     if (mWidgetListener)
108457:         mWidgetListener->RequestWindowClose(this);
     1: }
     1: 
     1: void
119749: nsWindow::OnEnterNotifyEvent(GdkEventCrossing *aEvent)
     1: {
 39762:     // This skips NotifyVirtual and NotifyNonlinearVirtual enter notify events
 39762:     // when the pointer enters a child window.  If the destination window is a
 39762:     // Gecko window then we'll catch the corresponding event on that window,
 39762:     // but we won't notice when the pointer directly enters a foreign (plugin)
 39762:     // child window without passing over a visible portion of a Gecko window.
     1:     if (aEvent->subwindow != NULL)
     1:         return;
     1: 
 39762:     // Check before is_parent_ungrab_enter() as the button state may have
 39762:     // changed while a non-Gecko ancestor window had a pointer grab.
 39762:     DispatchMissedButtonReleases(aEvent);
 39762: 
 39762:     if (is_parent_ungrab_enter(aEvent))
 39762:         return;
 39762: 
 79636:     nsMouseEvent event(true, NS_MOUSE_ENTER, this, nsMouseEvent::eReal);
     1: 
     1:     event.refPoint.x = nscoord(aEvent->x);
     1:     event.refPoint.y = nscoord(aEvent->y);
     1: 
     1:     event.time = aEvent->time;
     1: 
     1:     LOG(("OnEnterNotify: %p\n", (void *)this));
     1: 
     1:     nsEventStatus status;
     1:     DispatchEvent(&event, status);
     1: }
     1: 
 39762: // XXX Is this the right test for embedding cases?
 79445: static bool
 12976: is_top_level_mouse_exit(GdkWindow* aWindow, GdkEventCrossing *aEvent)
 12976: {
 12976:     gint x = gint(aEvent->x_root);
 12976:     gint y = gint(aEvent->y_root);
 78664:     GdkDisplay* display = gdk_window_get_display(aWindow);
 12976:     GdkWindow* winAtPt = gdk_display_get_window_at_pointer(display, &x, &y);
 12976:     if (!winAtPt)
 79636:         return true;
 12976:     GdkWindow* topLevelAtPt = gdk_window_get_toplevel(winAtPt);
 12976:     GdkWindow* topLevelWidget = gdk_window_get_toplevel(aWindow);
 12976:     return topLevelAtPt != topLevelWidget;
 12976: }
 12976: 
     1: void
119749: nsWindow::OnLeaveNotifyEvent(GdkEventCrossing *aEvent)
     1: {
 39762:     // This ignores NotifyVirtual and NotifyNonlinearVirtual leave notify
 39762:     // events when the pointer leaves a child window.  If the destination
 39762:     // window is a Gecko window then we'll catch the corresponding event on
 39762:     // that window.
 39762:     //
 39762:     // XXXkt However, we will miss toplevel exits when the pointer directly
 39762:     // leaves a foreign (plugin) child window without passing over a visible
 39762:     // portion of a Gecko window.
     1:     if (aEvent->subwindow != NULL)
     1:         return;
     1: 
 79636:     nsMouseEvent event(true, NS_MOUSE_EXIT, this, nsMouseEvent::eReal);
     1: 
     1:     event.refPoint.x = nscoord(aEvent->x);
     1:     event.refPoint.y = nscoord(aEvent->y);
     1: 
     1:     event.time = aEvent->time;
     1: 
 30704:     event.exit = is_top_level_mouse_exit(mGdkWindow, aEvent)
 12976:         ? nsMouseEvent::eTopLevel : nsMouseEvent::eChild;
 12976: 
     1:     LOG(("OnLeaveNotify: %p\n", (void *)this));
     1: 
     1:     nsEventStatus status;
     1:     DispatchEvent(&event, status);
     1: }
     1: 
 16529: void
119749: nsWindow::OnMotionNotifyEvent(GdkEventMotion *aEvent)
 16529: {
     1:     // see if we can compress this event
 20644:     // XXXldb Why skip every other motion event when we have multiple,
 20644:     // but not more than that?
 79445:     bool synthEvent = false;
 20644: #ifdef MOZ_X11
 20644:     XEvent xevent;
 20644: 
 20644:     while (XPending (GDK_WINDOW_XDISPLAY(aEvent->window))) {
 20644:         XEvent peeked;
 20644:         XPeekEvent (GDK_WINDOW_XDISPLAY(aEvent->window), &peeked);
 78664:         if (peeked.xany.window != gdk_x11_window_get_xid(aEvent->window)
 20644:             || peeked.type != MotionNotify)
 20359:             break;
 20359: 
 79636:         synthEvent = true;
 20644:         XNextEvent (GDK_WINDOW_XDISPLAY(aEvent->window), &xevent);
 20644:     }
 78664: #if defined(MOZ_WIDGET_GTK2)
     1:     // if plugins still keeps the focus, get it back
     1:     if (gPluginFocusWindow && gPluginFocusWindow != this) {
   920:         nsRefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
     1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
     1:     }
 78664: #endif /* MOZ_WIDGET_GTK2 */
 16529: #endif /* MOZ_X11 */
     1: 
 79636:     nsMouseEvent event(true, NS_MOUSE_MOVE, this, nsMouseEvent::eReal);
     1: 
 22684:     gdouble pressure = 0;
 22684:     gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
 22684:     // Sometime gdk generate 0 pressure value between normal values
 22684:     // We have to ignore that and use last valid value
 22684:     if (pressure)
 22684:       mLastMotionPressure = pressure;
 22684:     event.pressure = mLastMotionPressure;
 22684: 
 90661:     guint modifierState;
 20644:     if (synthEvent) {
 20644: #ifdef MOZ_X11
 20644:         event.refPoint.x = nscoord(xevent.xmotion.x);
 20644:         event.refPoint.y = nscoord(xevent.xmotion.y);
 20644: 
 90661:         modifierState = xevent.xmotion.state;
 20644: 
 20644:         event.time = xevent.xmotion.time;
 20644: #else
 16529:         event.refPoint.x = nscoord(aEvent->x);
 16529:         event.refPoint.y = nscoord(aEvent->y);
 16529: 
 90661:         modifierState = aEvent->state;
 16529: 
 16529:         event.time = aEvent->time;
 20644: #endif /* MOZ_X11 */
 20644:     }
 20644:     else {
 20644:         // XXX see OnScrollEvent()
 30704:         if (aEvent->window == mGdkWindow) {
 20644:             event.refPoint.x = nscoord(aEvent->x);
 20644:             event.refPoint.y = nscoord(aEvent->y);
 20644:         } else {
 25183:             nsIntPoint point(NSToIntFloor(aEvent->x_root), NSToIntFloor(aEvent->y_root));
 25183:             event.refPoint = point - WidgetToScreenOffset();
 20644:         }
 20644: 
 90661:         modifierState = aEvent->state;
 20644: 
 20644:         event.time = aEvent->time;
 20644:     }
     1: 
 90661:     KeymapWrapper::InitInputEvent(event, modifierState);
 90661: 
     1:     nsEventStatus status;
     1:     DispatchEvent(&event, status);
     1: }
     1: 
 39762: // If the automatic pointer grab on ButtonPress has deactivated before
 39762: // ButtonRelease, and the mouse button is released while the pointer is not
 39762: // over any a Gecko window, then the ButtonRelease event will not be received.
 39762: // (A similar situation exists when the pointer is grabbed with owner_events
 39762: // True as the ButtonRelease may be received on a foreign [plugin] window).
 39762: // Use this method to check for released buttons when the pointer returns to a
 39762: // Gecko window.
 39762: void
 39762: nsWindow::DispatchMissedButtonReleases(GdkEventCrossing *aGdkEvent)
 39762: {
 39762:     guint changed = aGdkEvent->state ^ gButtonState;
 39762:     // Only consider button releases.
 39762:     // (Ignore button presses that occurred outside Gecko.)
 39762:     guint released = changed & gButtonState;
 39762:     gButtonState = aGdkEvent->state;
 39762: 
 39762:     // Loop over each button, excluding mouse wheel buttons 4 and 5 for which
 39762:     // GDK ignores releases.
 39762:     for (guint buttonMask = GDK_BUTTON1_MASK;
 39762:          buttonMask <= GDK_BUTTON3_MASK;
 39762:          buttonMask <<= 1) {
 39762: 
 39762:         if (released & buttonMask) {
108991:             int16_t buttonType;
 39762:             switch (buttonMask) {
 39762:             case GDK_BUTTON1_MASK:
 39762:                 buttonType = nsMouseEvent::eLeftButton;
 39762:                 break;
 39762:             case GDK_BUTTON2_MASK:
 39762:                 buttonType = nsMouseEvent::eMiddleButton;
 39762:                 break;
 39762:             default:
 39762:                 NS_ASSERTION(buttonMask == GDK_BUTTON3_MASK,
 39762:                              "Unexpected button mask");
 39762:                 buttonType = nsMouseEvent::eRightButton;
 39762:             }
 39762: 
 39762:             LOG(("Synthesized button %u release on %p\n",
 39762:                  guint(buttonType + 1), (void *)this));
 39762: 
 39762:             // Dispatch a synthesized button up event to tell Gecko about the
 39762:             // change in state.  This event is marked as synthesized so that
 39762:             // it is not dispatched as a DOM event, because we don't know the
 39762:             // position, widget, modifiers, or time/order.
 79636:             nsMouseEvent synthEvent(true, NS_MOUSE_BUTTON_UP, this,
 39762:                                     nsMouseEvent::eSynthesized);
 39762:             synthEvent.button = buttonType;
 39762:             nsEventStatus status;
 39762:             DispatchEvent(&synthEvent, status);
 39762:         }
 39762:     }
 39762: }
 39762: 
     1: void
  9049: nsWindow::InitButtonEvent(nsMouseEvent &aEvent,
  9049:                           GdkEventButton *aGdkEvent)
  9049: {
  9049:     // XXX see OnScrollEvent()
 30704:     if (aGdkEvent->window == mGdkWindow) {
  9049:         aEvent.refPoint.x = nscoord(aGdkEvent->x);
  9049:         aEvent.refPoint.y = nscoord(aGdkEvent->y);
  9049:     } else {
 25183:         nsIntPoint point(NSToIntFloor(aGdkEvent->x_root), NSToIntFloor(aGdkEvent->y_root));
 25183:         aEvent.refPoint = point - WidgetToScreenOffset();
  9049:     }
  9049: 
 96890:     guint modifierState = aGdkEvent->state;
 96890:     // aEvent's state doesn't include this event's information.  Therefore,
 96890:     // if aEvent is mouse button down event, we need to set it manually.
 96890:     // Note that we cannot do same thing for NS_MOUSE_BUTTON_UP because
 96890:     // system may have two or more mice and same button of another mouse
 96890:     // may be still pressed.
 96890:     if (aGdkEvent->type != GDK_BUTTON_RELEASE) {
 96890:         switch (aGdkEvent->button) {
 96890:             case 1:
 96890:                 modifierState |= GDK_BUTTON1_MASK;
 96890:                 break;
 96890:             case 2:
 96890:                 modifierState |= GDK_BUTTON2_MASK;
 96890:                 break;
 96890:             case 3:
 96890:                 modifierState |= GDK_BUTTON3_MASK;
 96890:                 break;
 96890:         }
 96890:     }
 96890: 
 96890:     KeymapWrapper::InitInputEvent(aEvent, modifierState);
  9049: 
  9049:     aEvent.time = aGdkEvent->time;
  9049: 
  9049:     switch (aGdkEvent->type) {
  9049:     case GDK_2BUTTON_PRESS:
  9049:         aEvent.clickCount = 2;
  9049:         break;
  9049:     case GDK_3BUTTON_PRESS:
  9049:         aEvent.clickCount = 3;
  9049:         break;
  9049:         // default is one click
  9049:     default:
  9049:         aEvent.clickCount = 1;
  9049:     }
  9049: }
  9049: 
 39762: static guint ButtonMaskFromGDKButton(guint button)
 39762: {
 39762:     return GDK_BUTTON1_MASK << (button - 1);
 39762: }
 39762: 
  9049: void
119749: nsWindow::OnButtonPressEvent(GdkEventButton *aEvent)
     1: {
 39762:     LOG(("Button %u press on %p\n", aEvent->button, (void *)this));
 39762: 
     1:     nsEventStatus status;
     1: 
 39762:     // If you double click in GDK, it will actually generate a second
 39762:     // GDK_BUTTON_PRESS before sending the GDK_2BUTTON_PRESS, and this is
     1:     // different than the DOM spec.  GDK puts this in the queue
     1:     // programatically, so it's safe to assume that if there's a
     1:     // double click in the queue, it was generated so we can just drop
     1:     // this click.
     1:     GdkEvent *peekedEvent = gdk_event_peek();
     1:     if (peekedEvent) {
     1:         GdkEventType type = peekedEvent->any.type;
     1:         gdk_event_free(peekedEvent);
     1:         if (type == GDK_2BUTTON_PRESS || type == GDK_3BUTTON_PRESS)
     1:             return;
     1:     }
     1: 
 25258:     nsWindow *containerWindow = GetContainerWindow();
 25258:     if (!gFocusWindow && containerWindow) {
 30583:         containerWindow->DispatchActivateEvent();
 30583:     }
 30583: 
 30583:     // check to see if we should rollup
120177:     if (CheckForRollup(aEvent->x_root, aEvent->y_root, false, false))
     1:         return;
     1: 
 22684:     gdouble pressure = 0;
 22684:     gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
 22684:     mLastMotionPressure = pressure;
 22684: 
108991:     uint16_t domButton;
     1:     switch (aEvent->button) {
  3974:     case 1:
  3974:         domButton = nsMouseEvent::eLeftButton;
  3974:         break;
     1:     case 2:
     1:         domButton = nsMouseEvent::eMiddleButton;
     1:         break;
     1:     case 3:
     1:         domButton = nsMouseEvent::eRightButton;
     1:         break;
 13248:     // These are mapped to horizontal scroll
 13248:     case 6:
 13248:     case 7:
108071:         NS_WARNING("We're not supporting legacy horizontal scroll event");
 13248:         return;
 11933:     // Map buttons 8-9 to back/forward
 11933:     case 8:
 80435:         DispatchCommandEvent(nsGkAtoms::Back);
 11933:         return;
 11933:     case 9:
 80435:         DispatchCommandEvent(nsGkAtoms::Forward);
 11933:         return;
     1:     default:
  3974:         return;
     1:     }
     1: 
 39762:     gButtonState |= ButtonMaskFromGDKButton(aEvent->button);
 39762: 
 79636:     nsMouseEvent event(true, NS_MOUSE_BUTTON_DOWN, this, nsMouseEvent::eReal);
     1:     event.button = domButton;
     1:     InitButtonEvent(event, aEvent);
 22684:     event.pressure = mLastMotionPressure;
     1: 
     1:     DispatchEvent(&event, status);
     1: 
     1:     // right menu click on linux should also pop up a context menu
   920:     if (domButton == nsMouseEvent::eRightButton &&
120353:         MOZ_LIKELY(!mIsDestroyed)) {
 79636:         nsMouseEvent contextMenuEvent(true, NS_CONTEXTMENU, this,
     1:                                       nsMouseEvent::eReal);
     1:         InitButtonEvent(contextMenuEvent, aEvent);
 22684:         contextMenuEvent.pressure = mLastMotionPressure;
     1:         DispatchEvent(&contextMenuEvent, status);
     1:     }
     1: }
     1: 
     1: void
119749: nsWindow::OnButtonReleaseEvent(GdkEventButton *aEvent)
     1: {
 39762:     LOG(("Button %u release on %p\n", aEvent->button, (void *)this));
 39762: 
108991:     uint16_t domButton;
     1:     switch (aEvent->button) {
  3974:     case 1:
  3974:         domButton = nsMouseEvent::eLeftButton;
  3974:         break;
     1:     case 2:
     1:         domButton = nsMouseEvent::eMiddleButton;
     1:         break;
     1:     case 3:
     1:         domButton = nsMouseEvent::eRightButton;
     1:         break;
  3974:     default:
     1:         return;
     1:     }
     1: 
 39762:     gButtonState &= ~ButtonMaskFromGDKButton(aEvent->button);
 39762: 
 79636:     nsMouseEvent event(true, NS_MOUSE_BUTTON_UP, this, nsMouseEvent::eReal);
     1:     event.button = domButton;
     1:     InitButtonEvent(event, aEvent);
 22684:     gdouble pressure = 0;
 22684:     gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
 22684:     event.pressure = pressure ? pressure : mLastMotionPressure;
     1: 
     1:     nsEventStatus status;
     1:     DispatchEvent(&event, status);
 22684:     mLastMotionPressure = pressure;
     1: }
     1: 
     1: void
119749: nsWindow::OnContainerFocusInEvent(GdkEventFocus *aEvent)
     1: {
 43761:     NS_ASSERTION(mWindowType != eWindowType_popup,
 43761:                  "Unexpected focus on a popup window");
 43761: 
     1:     LOGFOCUS(("OnContainerFocusInEvent [%p]\n", (void *)this));
     1: 
     1:     // Unset the urgency hint, if possible
121096:     GtkWidget* top_window = GetToplevelWidget();
 78664:     if (top_window && (gtk_widget_get_visible(top_window)))
 79636:         SetUrgencyHint(top_window, false);
     1: 
 43760:     // Return if being called within SetFocus because the focus manager
 43760:     // already knows that the window is active.
 43760:     if (gBlockActivateEvent) {
108457:         LOGFOCUS(("activated notification is blocked [%p]\n", (void *)this));
 43760:         return;
 43760:     }
 43760: 
119747:     // If keyboard input will be accepted, the focus manager will call
119747:     // SetFocus to set the correct window.
119747:     gFocusWindow = nullptr;
119747: 
119747:     DispatchActivateEvent();
119747: 
119747:     if (!gFocusWindow) {
119747:         // We don't really have a window for dispatching key events, but
119747:         // setting a non-NULL value here prevents OnButtonPressEvent() from
119747:         // dispatching an activation notification if the widget is already
119747:         // active.
 29018:         gFocusWindow = this;
119747:     }
     1: 
     1:     LOGFOCUS(("Events sent from focus in event [%p]\n", (void *)this));
     1: }
     1: 
     1: void
119749: nsWindow::OnContainerFocusOutEvent(GdkEventFocus *aEvent)
     1: {
     1:     LOGFOCUS(("OnContainerFocusOutEvent [%p]\n", (void *)this));
     1: 
 54150:     if (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog) {
 59748:         nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
 59748:         nsCOMPtr<nsIDragSession> dragSession;
 59748:         dragService->GetCurrentSession(getter_AddRefs(dragSession));
 59748: 
 59748:         // Rollup popups when a window is focused out unless a drag is occurring.
 59748:         // This check is because drags grab the keyboard and cause a focus out on
 59748:         // versions of GTK before 2.18.
 79445:         bool shouldRollup = !dragSession;
 59748:         if (!shouldRollup) {
 59748:             // we also roll up when a drag is from a different application
 59748:             nsCOMPtr<nsIDOMNode> sourceNode;
 59748:             dragSession->GetSourceNode(getter_AddRefs(sourceNode));
106838:             shouldRollup = (sourceNode == nullptr);
 59748:         }
 59748: 
 59748:         if (shouldRollup) {
120177:             CheckForRollup(0, 0, false, true);
 54150:         }
 59748:     }
 54150: 
 78664: #if defined(MOZ_WIDGET_GTK2) && defined(MOZ_X11)
     1:     // plugin lose focus
     1:     if (gPluginFocusWindow) {
   920:         nsRefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
     1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
     1:     }
 78664: #endif /* MOZ_X11 && MOZ_WIDGET_GTK2 */
     1: 
 43759:     if (gFocusWindow) {
   920:         nsRefPtr<nsWindow> kungFuDeathGrip = gFocusWindow;
 39627:         if (gFocusWindow->mIMModule) {
 39627:             gFocusWindow->mIMModule->OnBlurWindow(gFocusWindow);
 39627:         }
106838:         gFocusWindow = nullptr;
 43759:     }
 43759: 
 29018:     DispatchDeactivateEvent();
     1: 
     1:     LOGFOCUS(("Done with container focus out [%p]\n", (void *)this));
     1: }
     1: 
 79445: bool
 11933: nsWindow::DispatchCommandEvent(nsIAtom* aCommand)
 11283: {
 11283:     nsEventStatus status;
 80435:     nsCommandEvent event(true, nsGkAtoms::onAppCommand, aCommand, this);
 11283:     DispatchEvent(&event, status);
 11283:     return TRUE;
 11283: }
 11283: 
 79445: bool
108991: nsWindow::DispatchContentCommandEvent(int32_t aMsg)
 73807: {
 73807:   nsEventStatus status;
 79636:   nsContentCommandEvent event(true, aMsg, this);
 73807:   DispatchEvent(&event, status);
 73807:   return TRUE;
 73807: }
 73807: 
 79445: static bool
 39627: IsCtrlAltTab(GdkEventKey *aEvent)
 39627: {
 39627:     return aEvent->keyval == GDK_Tab &&
 90665:         KeymapWrapper::AreModifiersActive(
 90665:             KeymapWrapper::CTRL | KeymapWrapper::ALT, aEvent->state);
 39627: }
 39627: 
 79445: bool
 79445: nsWindow::DispatchKeyDownEvent(GdkEventKey *aEvent, bool *aCancelled)
 39627: {
 39627:     NS_PRECONDITION(aCancelled, "aCancelled must not be null");
 39627: 
 79636:     *aCancelled = false;
 39627: 
 39627:     if (IsCtrlAltTab(aEvent)) {
 79636:         return false;
 39627:     }
 39627: 
 39627:     // send the key down event
 39627:     nsEventStatus status;
 79636:     nsKeyEvent downEvent(true, NS_KEY_DOWN, this);
 90663:     KeymapWrapper::InitKeyEvent(downEvent, aEvent);
 39627:     DispatchEvent(&downEvent, status);
 39627:     *aCancelled = (status == nsEventStatus_eConsumeNoDefault);
 79636:     return true;
 39627: }
 39627: 
     1: gboolean
119749: nsWindow::OnKeyPressEvent(GdkEventKey *aEvent)
     1: {
     1:     LOGFOCUS(("OnKeyPressEvent [%p]\n", (void *)this));
     1: 
     1:     // if we are in the middle of composing text, XIM gets to see it
     1:     // before mozilla does.
 79445:     bool IMEWasEnabled = false;
 60496:     if (mIMModule) {
 60496:         IMEWasEnabled = mIMModule->IsEnabled();
 60496:         if (mIMModule->OnKeyEvent(this, aEvent)) {
     1:             return TRUE;
 39627:         }
 60496:     }
     1: 
     1:     nsEventStatus status;
     1: 
     1:     // work around for annoying things.
 39627:     if (IsCtrlAltTab(aEvent)) {
     1:         return TRUE;
     1:     }
     1: 
     1:     nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
     1: 
 55062:     // Dispatch keydown event always.  At auto repeating, we should send
 55062:     // KEYDOWN -> KEYPRESS -> KEYDOWN -> KEYPRESS ... -> KEYUP
 55062:     // However, old distributions (e.g., Ubuntu 9.10) sent native key
 55062:     // release event, so, on such platform, the DOM events will be:
 55062:     // KEYDOWN -> KEYPRESS -> KEYUP -> KEYDOWN -> KEYPRESS -> KEYUP...
     1: 
 79445:     bool isKeyDownCancelled = false;
 39627:     if (DispatchKeyDownEvent(aEvent, &isKeyDownCancelled) &&
120353:         MOZ_UNLIKELY(mIsDestroyed)) {
 39627:         return TRUE;
     1:     }
     1: 
 60496:     // If a keydown event handler causes to enable IME, i.e., it moves
 60496:     // focus from IME unusable content to IME usable editor, we should
 60496:     // send the native key event to IME for the first input on the editor.
 60496:     if (!IMEWasEnabled && mIMModule && mIMModule->IsEnabled()) {
 60496:         // Notice our keydown event was already dispatched.  This prevents
 60496:         // unnecessary DOM keydown event in the editor.
 79636:         if (mIMModule->OnKeyEvent(this, aEvent, true)) {
 60496:             return TRUE;
 60496:         }
 60496:     }
 60496: 
     1:     // Don't pass modifiers as NS_KEY_PRESS events.
     1:     // TODO: Instead of selectively excluding some keys from NS_KEY_PRESS events,
     1:     //       we should instead selectively include (as per MSDN spec; no official
     1:     //       spec covers KeyPress events).
 90664:     if (!KeymapWrapper::IsKeyPressEventNecessary(aEvent)) {
     1:         return TRUE;
     1:     }
 11283: 
 16529: #ifdef MOZ_X11
 39957: #if ! defined AIX // no XFree86 on AIX 5L
 11283:     // Look for specialized app-command keys
 11283:     switch (aEvent->keyval) {
 11283:         case XF86XK_Back:
 80435:             return DispatchCommandEvent(nsGkAtoms::Back);
 11283:         case XF86XK_Forward:
 80435:             return DispatchCommandEvent(nsGkAtoms::Forward);
 11283:         case XF86XK_Refresh:
 80435:             return DispatchCommandEvent(nsGkAtoms::Reload);
 11283:         case XF86XK_Stop:
 80435:             return DispatchCommandEvent(nsGkAtoms::Stop);
 11283:         case XF86XK_Search:
 80435:             return DispatchCommandEvent(nsGkAtoms::Search);
 11283:         case XF86XK_Favorites:
 80435:             return DispatchCommandEvent(nsGkAtoms::Bookmarks);
 11283:         case XF86XK_HomePage:
 80435:             return DispatchCommandEvent(nsGkAtoms::Home);
 73807:         case XF86XK_Copy:
 73807:         case GDK_F16:  // F16, F20, F18, F14 are old keysyms for Copy Cut Paste Undo
 73807:             return DispatchContentCommandEvent(NS_CONTENT_COMMAND_COPY);
 73807:         case XF86XK_Cut:
 73807:         case GDK_F20:
 73807:             return DispatchContentCommandEvent(NS_CONTENT_COMMAND_CUT);
 73807:         case XF86XK_Paste:
 73807:         case GDK_F18:
 73807:             return DispatchContentCommandEvent(NS_CONTENT_COMMAND_PASTE);
 73807:         case GDK_Redo:
 73807:             return DispatchContentCommandEvent(NS_CONTENT_COMMAND_REDO);
 73807:         case GDK_Undo:
 73807:         case GDK_F14:
 73807:             return DispatchContentCommandEvent(NS_CONTENT_COMMAND_UNDO);
 11283:     }
 39957: #endif /* ! AIX */
 16529: #endif /* MOZ_X11 */
 11283: 
 79636:     nsKeyEvent event(true, NS_KEY_PRESS, this);
 90663:     KeymapWrapper::InitKeyEvent(event, aEvent);
     1:     if (isKeyDownCancelled) {
     1:       // If prevent default set for onkeydown, do the same for onkeypress
     1:       event.flags |= NS_EVENT_FLAG_NO_DEFAULT;
     1:     }
     1: 
     1:     // before we dispatch a key, check if it's the context menu key.
     1:     // If so, send a context menu key event instead.
     1:     if (is_context_menu_key(event)) {
 79636:         nsMouseEvent contextMenuEvent(true, NS_CONTEXTMENU, this,
 11930:                                       nsMouseEvent::eReal,
 11930:                                       nsMouseEvent::eContextMenuKey);
 90661: 
 90661:         contextMenuEvent.refPoint = nsIntPoint(0, 0);
 90661:         contextMenuEvent.time = aEvent->time;
 90661:         contextMenuEvent.clickCount = 1;
 90661:         KeymapWrapper::InitInputEvent(contextMenuEvent, aEvent->state);
     1:         DispatchEvent(&contextMenuEvent, status);
     1:     }
     1:     else {
 47210:         // If the character code is in the BMP, send the key press event.
 47210:         // Otherwise, send a text event with the equivalent UTF-16 string.
 47210:         if (IS_IN_BMP(event.charCode)) {
     1:             DispatchEvent(&event, status);
     1:         }
 47210:         else {
 79636:             nsTextEvent textEvent(true, NS_TEXT_TEXT, this);
 47210:             PRUnichar textString[3];
 47210:             textString[0] = H_SURROGATE(event.charCode);
 47210:             textString[1] = L_SURROGATE(event.charCode);
 47210:             textString[2] = 0;
 47210:             textEvent.theText = textString;
 47210:             textEvent.time = event.time;
 47210:             DispatchEvent(&textEvent, status);
 47210:         }
 47210:     }
     1: 
     1:     // If the event was consumed, return.
     1:     if (status == nsEventStatus_eConsumeNoDefault) {
     1:         return TRUE;
     1:     }
     1: 
     1:     return FALSE;
     1: }
     1: 
     1: gboolean
119749: nsWindow::OnKeyReleaseEvent(GdkEventKey *aEvent)
     1: {
     1:     LOGFOCUS(("OnKeyReleaseEvent [%p]\n", (void *)this));
     1: 
 39627:     if (mIMModule && mIMModule->OnKeyEvent(this, aEvent)) {
     1:         return TRUE;
 39627:     }
     1: 
     1:     // send the key event as a key up event
 79636:     nsKeyEvent event(true, NS_KEY_UP, this);
 90663:     KeymapWrapper::InitKeyEvent(event, aEvent);
     1: 
   920:     nsEventStatus status;
     1:     DispatchEvent(&event, status);
     1: 
     1:     // If the event was consumed, return.
     1:     if (status == nsEventStatus_eConsumeNoDefault) {
     1:         return TRUE;
     1:     }
     1: 
     1:     return FALSE;
     1: }
     1: 
     1: void
119749: nsWindow::OnScrollEvent(GdkEventScroll *aEvent)
     1: {
     1:     // check to see if we should rollup
120177:     if (CheckForRollup(aEvent->x_root, aEvent->y_root, true, false))
     1:         return;
     1: 
108071:     WheelEvent wheelEvent(true, NS_WHEEL_WHEEL, this);
108071:     wheelEvent.deltaMode = nsIDOMWheelEvent::DOM_DELTA_LINE;
  8875:     switch (aEvent->direction) {
  8875:     case GDK_SCROLL_UP:
108071:         wheelEvent.deltaY = wheelEvent.lineOrPageDeltaY = -3;
  8875:         break;
  8875:     case GDK_SCROLL_DOWN:
108071:         wheelEvent.deltaY = wheelEvent.lineOrPageDeltaY = 3;
  8875:         break;
  8875:     case GDK_SCROLL_LEFT:
108071:         wheelEvent.deltaX = wheelEvent.lineOrPageDeltaX = -1;
  8875:         break;
  8875:     case GDK_SCROLL_RIGHT:
108071:         wheelEvent.deltaX = wheelEvent.lineOrPageDeltaX = 1;
  8875:         break;
  8875:     }
  8875: 
108071:     NS_ASSERTION(wheelEvent.deltaX || wheelEvent.deltaY,
108071:                  "deltaX or deltaY must be non-zero");
108071: 
 30704:     if (aEvent->window == mGdkWindow) {
 25183:         // we are the window that the event happened on so no need for expensive WidgetToScreenOffset
108071:         wheelEvent.refPoint.x = nscoord(aEvent->x);
108071:         wheelEvent.refPoint.y = nscoord(aEvent->y);
  8875:     } else {
  8875:         // XXX we're never quite sure which GdkWindow the event came from due to our custom bubbling
  8875:         // in scroll_event_cb(), so use ScreenToWidget to translate the screen root coordinates into
  8875:         // coordinates relative to this widget.
 25183:         nsIntPoint point(NSToIntFloor(aEvent->x_root), NSToIntFloor(aEvent->y_root));
108071:         wheelEvent.refPoint = point - WidgetToScreenOffset();
108071:     }
108071: 
108071:     KeymapWrapper::InitInputEvent(wheelEvent, aEvent->state);
108071: 
108071:     wheelEvent.time = aEvent->time;
  8875: 
     1:     nsEventStatus status;
108071:     DispatchEvent(&wheelEvent, status);
     1: }
     1: 
     1: void
119749: nsWindow::OnVisibilityNotifyEvent(GdkEventVisibility *aEvent)
     1: {
 34456:     LOGDRAW(("Visibility event %i on [%p] %p\n",
 34456:              aEvent->state, this, aEvent->window));
 34456: 
 34456:     if (!mGdkWindow)
 34456:         return;
 34456: 
     1:     switch (aEvent->state) {
     1:     case GDK_VISIBILITY_UNOBSCURED:
     1:     case GDK_VISIBILITY_PARTIAL:
 34456:         if (mIsFullyObscured && mHasMappedToplevel) {
 34456:             // GDK_EXPOSE events have been ignored, so make sure GDK
 34456:             // doesn't think that the window has already been painted.
 34456:             gdk_window_invalidate_rect(mGdkWindow, NULL, FALSE);
 34456:         }
 34456: 
 79636:         mIsFullyObscured = false;
 34456: 
 19265:         // In Hildon/Maemo, a browser window will get into 'patially visible' state wheneven an
 19265:         // autocomplete feature is dropped down (from urlbar or from an entry form completion),
 19265:         // and there are no much further ways for that to happen in the plaftorm. In such cases, if hildon
 19265:         // virtual keyboard is up, we can not grab focus to any dropdown list. Reason: nsWindow::EnsureGrabs()
 19265:         // calls gdk_pointer_grab() which grabs the pointer (usually a mouse) so that all events are passed
 19265:         // to this it until the pointer is ungrabbed.
 39627:         if (!nsGtkIMModule::IsVirtualKeyboardOpened()) {
     1:             // if we have to retry the grab, retry it.
     1:             EnsureGrabs();
 39627:         }
     1:         break;
     1:     default: // includes GDK_VISIBILITY_FULLY_OBSCURED
 79636:         mIsFullyObscured = true;
     1:         break;
     1:     }
     1: }
     1: 
     1: void
     1: nsWindow::OnWindowStateEvent(GtkWidget *aWidget, GdkEventWindowState *aEvent)
     1: {
     1:     LOG(("nsWindow::OnWindowStateEvent [%p] changed %d new_window_state %d\n",
     1:          (void *)this, aEvent->changed_mask, aEvent->new_window_state));
     1: 
 34456:     if (IS_MOZ_CONTAINER(aWidget)) {
 34456:         // This event is notifying the container widget of changes to the
 34456:         // toplevel window.  Just detect changes affecting whether windows are
 34456:         // viewable.
 34456:         //
 34456:         // (A visibility notify event is sent to each window that becomes
 34456:         // viewable when the toplevel is mapped, but we can't rely on that for
 34456:         // setting mHasMappedToplevel because these toplevel window state
 34456:         // events are asynchronous.  The windows in the hierarchy now may not
 34456:         // be the same windows as when the toplevel was mapped, so they may
 34456:         // not get VisibilityNotify events.)
 79445:         bool mapped =
 34456:             !(aEvent->new_window_state &
 34456:               (GDK_WINDOW_STATE_ICONIFIED|GDK_WINDOW_STATE_WITHDRAWN));
 34456:         if (mHasMappedToplevel != mapped) {
 34456:             SetHasMappedToplevel(mapped);
 34456:         }
 34456:         return;
 34456:     }
 34456:     // else the widget is a shell widget.
 34456: 
 89521:     // We don't care about anything but changes in the maximized/icon/fullscreen
     1:     // states
  9467:     if ((aEvent->changed_mask
 89521:          & (GDK_WINDOW_STATE_ICONIFIED |
 89521:             GDK_WINDOW_STATE_MAXIMIZED |
 89521:             GDK_WINDOW_STATE_FULLSCREEN)) == 0) {
     1:         return;
     1:     }
     1: 
     1:     if (aEvent->new_window_state & GDK_WINDOW_STATE_ICONIFIED) {
     1:         LOG(("\tIconified\n"));
     1:         mSizeState = nsSizeMode_Minimized;
 64019: #ifdef ACCESSIBILITY
 64019:         DispatchMinimizeEventAccessible();
 64019: #endif //ACCESSIBILITY
     1:     }
 89520:     else if (aEvent->new_window_state & GDK_WINDOW_STATE_FULLSCREEN) {
 89520:         LOG(("\tFullscreen\n"));
 89520:         mSizeState = nsSizeMode_Fullscreen;
 89520:     }
     1:     else if (aEvent->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) {
     1:         LOG(("\tMaximized\n"));
     1:         mSizeState = nsSizeMode_Maximized;
 64019: #ifdef ACCESSIBILITY
 64019:         DispatchMaximizeEventAccessible();
 64019: #endif //ACCESSIBILITY
     1:     }
     1:     else {
     1:         LOG(("\tNormal\n"));
     1:         mSizeState = nsSizeMode_Normal;
 64019: #ifdef ACCESSIBILITY
 64019:         DispatchRestoreEventAccessible();
 64019: #endif //ACCESSIBILITY
     1:     }
     1: 
108457:     if (mWidgetListener)
108457:       mWidgetListener->SizeModeChanged(mSizeState);
     1: }
     1: 
     1: void
     1: nsWindow::ThemeChanged()
     1: {
108452:     NotifyThemeChanged();
     1: 
120353:     if (!mGdkWindow || MOZ_UNLIKELY(mIsDestroyed))
     1:         return;
     1: 
108452:     // Dispatch theme change notification to all child windows
     1:     GList *children =
 30704:         gdk_window_peek_children(mGdkWindow);
     1:     while (children) {
     1:         GdkWindow *gdkWin = GDK_WINDOW(children->data);
     1: 
     1:         nsWindow *win = (nsWindow*) g_object_get_data(G_OBJECT(gdkWin),
     1:                                                       "nsWindow");
     1: 
   920:         if (win && win != this) { // guard against infinite recursion
   920:             nsRefPtr<nsWindow> kungFuDeathGrip = win;
     1:             win->ThemeChanged();
   920:         }
     1: 
     1:         children = children->next;
     1:     }
     1: }
     1: 
 37793: void
108991: nsWindow::DispatchDragEvent(uint32_t aMsg, const nsIntPoint& aRefPoint,
 95559:                             guint aTime)
 95559: {
 95559:     nsDragEvent event(true, aMsg, this);
 95559: 
 95559:     if (aMsg == NS_DRAGDROP_OVER) {
 95559:         InitDragEvent(event);
 95559:     }
 95559: 
 95559:     event.refPoint = aRefPoint;
 95559:     event.time = aTime;
 95559: 
 95559:     nsEventStatus status;
 95559:     DispatchEvent(&event, status);
 95559: }
 95559: 
     1: void
     1: nsWindow::OnDragDataReceivedEvent(GtkWidget *aWidget,
     1:                                   GdkDragContext *aDragContext,
     1:                                   gint aX,
     1:                                   gint aY,
     1:                                   GtkSelectionData  *aSelectionData,
     1:                                   guint aInfo,
     1:                                   guint aTime,
     1:                                   gpointer aData)
     1: {
 29217:     LOGDRAG(("nsWindow::OnDragDataReceived(%p)\n", (void*)this));
     1: 
 97334:     nsDragService::GetInstance()->
 97334:         TargetDataReceived(aWidget, aDragContext, aX, aY,
     1:                            aSelectionData, aInfo, aTime);
     1: }
     1: 
     1: static void
     1: GetBrandName(nsXPIDLString& brandName)
     1: {
     1:     nsCOMPtr<nsIStringBundleService> bundleService =
     1:         do_GetService(NS_STRINGBUNDLE_CONTRACTID);
     1: 
     1:     nsCOMPtr<nsIStringBundle> bundle;
     1:     if (bundleService)
     1:         bundleService->CreateBundle(
     1:             "chrome://branding/locale/brand.properties",
     1:             getter_AddRefs(bundle));
     1: 
     1:     if (bundle)
     1:         bundle->GetStringFromName(
     1:             NS_LITERAL_STRING("brandShortName").get(),
     1:             getter_Copies(brandName));
     1: 
     1:     if (brandName.IsEmpty())
     1:         brandName.Assign(NS_LITERAL_STRING("Mozilla"));
     1: }
     1: 
 30704: static GdkWindow *
 30704: CreateGdkWindow(GdkWindow *parent, GtkWidget *widget)
 30704: {
 30704:     GdkWindowAttr attributes;
 78664:     gint          attributes_mask = GDK_WA_VISUAL;
 30704: 
119750:     attributes.event_mask = kEvents;
 30704: 
 30704:     attributes.width = 1;
 30704:     attributes.height = 1;
 30704:     attributes.wclass = GDK_INPUT_OUTPUT;
 30704:     attributes.visual = gtk_widget_get_visual(widget);
 78664:     attributes.window_type = GDK_WINDOW_CHILD;
 78664: 
 78664: #if defined(MOZ_WIDGET_GTK2)
 78664:     attributes_mask |= GDK_WA_COLORMAP;
 30704:     attributes.colormap = gtk_widget_get_colormap(widget);
 78664: #endif
 30704: 
 30704:     GdkWindow *window = gdk_window_new(parent, &attributes, attributes_mask);
 30704:     gdk_window_set_user_data(window, widget);
 30704: 
 78664: // GTK3 TODO?
 78664: #if defined(MOZ_WIDGET_GTK2)
 30704:     /* set the default pixmap to None so that you don't end up with the
 30704:        gtk default which is BlackPixel. */
 30704:     gdk_window_set_back_pixmap(window, NULL, FALSE);
 78664: #endif
 30704: 
 30704:     return window;
 30704: }
 30704: 
     1: nsresult
 33013: nsWindow::Create(nsIWidget        *aParent,
     1:                  nsNativeWidget    aNativeParent,
 23738:                  const nsIntRect  &aRect,
 68668:                  nsDeviceContext *aContext,
     1:                  nsWidgetInitData *aInitData)
     1: {
     1:     // only set the base parent if we're going to be a dialog or a
     1:     // toplevel
     1:     nsIWidget *baseParent = aInitData &&
     1:         (aInitData->mWindowType == eWindowType_dialog ||
     1:          aInitData->mWindowType == eWindowType_toplevel ||
     1:          aInitData->mWindowType == eWindowType_invisible) ?
106838:         nullptr : aParent;
     1: 
  6721:     NS_ASSERTION(!mWindowGroup, "already have window group (leaking it)");
     1: 
 86928: #ifdef ACCESSIBILITY
 86928:     // Send a DBus message to check whether a11y is enabled
 86928:     a11y::PreInit();
 86928: #endif
 86928: 
 80842:     // Ensure that the toolkit is created.
 80842:     nsGTKToolkit::GetToolkit();
 80842: 
     1:     // initialize all the common bits of this class
108460:     BaseCreate(baseParent, aRect, aContext, aInitData);
     1: 
     1:     // Do we need to listen for resizes?
 79445:     bool listenForResizes = false;;
     1:     if (aNativeParent || (aInitData && aInitData->mListenForResizes))
 79636:         listenForResizes = true;
     1: 
     1:     // and do our common creation
     1:     CommonCreate(aParent, listenForResizes);
     1: 
     1:     // save our bounds
     1:     mBounds = aRect;
122623:     ConstrainSize(&mBounds.width, &mBounds.height);
     1: 
     1:     // figure out our parent window
106838:     GtkWidget      *parentMozContainer = nullptr;
106838:     GtkContainer   *parentGtkContainer = nullptr;
106838:     GdkWindow      *parentGdkWindow = nullptr;
106838:     GtkWindow      *topLevelParent = nullptr;
119750:     nsWindow       *parentnsWindow = nullptr;
119750:     GtkWidget      *eventWidget = nullptr;
119750: 
119750:     if (aParent) {
119750:         parentnsWindow = static_cast<nsWindow*>(aParent);
119750:         parentGdkWindow = parentnsWindow->mGdkWindow;
119750:     } else if (aNativeParent && GDK_IS_WINDOW(aNativeParent)) {
     1:         parentGdkWindow = GDK_WINDOW(aNativeParent);
119750:         parentnsWindow = get_window_for_gdk_window(parentGdkWindow);
119750:         if (!parentnsWindow)
119750:             return NS_ERROR_FAILURE;
119750: 
119750:     } else if (aNativeParent && GTK_IS_CONTAINER(aNativeParent)) {
     1:         parentGtkContainer = GTK_CONTAINER(aNativeParent);
119750:     }
     1: 
     1:     if (parentGdkWindow) {
 30704:         // get the widget for the window - it should be a moz container
119750:         parentMozContainer = parentnsWindow->GetMozContainerWidget();
119750:         if (!parentMozContainer)
     1:             return NS_ERROR_FAILURE;
     1: 
     1:         // get the toplevel window just in case someone needs to use it
     1:         // for setting transients or whatever.
     1:         topLevelParent =
119750:             GTK_WINDOW(gtk_widget_get_toplevel(parentMozContainer));
     1:     }
     1: 
     1:     // ok, create our windows
     1:     switch (mWindowType) {
     1:     case eWindowType_dialog:
     1:     case eWindowType_popup:
     1:     case eWindowType_toplevel:
     1:     case eWindowType_invisible: {
 79636:         mIsTopLevel = true;
     1: 
 73645:         // We only move a general managed toplevel window if someone has
 73645:         // actually placed the window somewhere.  If no placement has taken
 73645:         // place, we just let the window manager Do The Right Thing.
 73645:         //
 73645:         // Indicate that if we're shown, we at least need to have our size set.
 73645:         // If we get explicitly moved, the position will also be set.
 79636:         mNeedsResize = true;
 73645: 
     1:         if (mWindowType == eWindowType_dialog) {
     1:             mShell = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     1:             SetDefaultIcon();
 94220:             gtk_window_set_wmclass(GTK_WINDOW(mShell), "Dialog", 
 94220:                                    gdk_get_program_class());
     1:             gtk_window_set_type_hint(GTK_WINDOW(mShell),
     1:                                      GDK_WINDOW_TYPE_HINT_DIALOG);
     1:             gtk_window_set_transient_for(GTK_WINDOW(mShell),
     1:                                          topLevelParent);
     1:             mTransientParent = topLevelParent;
     1:             // add ourselves to the parent window's window group
     1:             if (!topLevelParent) {
     1:                 gtk_widget_realize(mShell);
 78664:                 GdkWindow* dialoglead = gtk_widget_get_window(mShell);
     1:                 gdk_window_set_group(dialoglead, dialoglead);
     1:             }
 30704:             if (parentGdkWindow) {
119750:                 if (parentnsWindow->mWindowGroup) {
     1:                     gtk_window_group_add_window(parentnsWindow->mWindowGroup,
     1:                                                 GTK_WINDOW(mShell));
     1:                     // store this in case any children are created
     1:                     mWindowGroup = parentnsWindow->mWindowGroup;
 69740:                     g_object_ref(mWindowGroup);
     1:                     LOG(("adding window %p to group %p\n",
     1:                          (void *)mShell, (void *)mWindowGroup));
     1:                 }
     1:             }
     1:         }
     1:         else if (mWindowType == eWindowType_popup) {
 73645:             // With popup windows, we want to control their position, so don't
 73645:             // wait for the window manager to place them (which wouldn't
 73645:             // happen with override-redirect windows anyway).
 79636:             mNeedsMove = true;
 73645: 
 48254:             // Popups that are not noautohide are only temporary. The are used
 48254:             // for menus and the like and disappear when another window is used.
115974:             // For most popups, use the standard GtkWindowType GTK_WINDOW_POPUP,
115974:             // which will use a Window with the override-redirect attribute
115974:             // (for temporary windows).
115974:             // For long-lived windows, their stacking order is managed by the
115974:             // window manager, as indicated by GTK_WINDOW_TOPLEVEL ...
115974:             GtkWindowType type = aInitData->mNoAutoHide ?
115974:                                      GTK_WINDOW_TOPLEVEL : GTK_WINDOW_POPUP;
115974:             mShell = gtk_window_new(type);
 94220:             gtk_window_set_wmclass(GTK_WINDOW(mShell), "Popup",
 94220:                                    gdk_get_program_class());
115974: 
121831:             if (aInitData->mSupportTranslucency) {
121831:                 // We need to select an ARGB visual here instead of in
121831:                 // SetTransparencyMode() because it has to be done before the
121831:                 // widget is realized.  An ARGB visual is only useful if we
121831:                 // are on a compositing window manager.
115974:                 GdkScreen *screen = gtk_widget_get_screen(mShell);
115974:                 if (gdk_screen_is_composited(screen)) {
115974: #if defined(MOZ_WIDGET_GTK2)
115974:                     GdkColormap *colormap =
115974:                         gdk_screen_get_rgba_colormap(screen);
115974:                     gtk_widget_set_colormap(mShell, colormap);
115974: #else
115974:                     GdkVisual *visual = gdk_screen_get_rgba_visual(screen);
115974:                     gtk_widget_set_visual(mShell, visual);
115974: #endif
115974:                 }
121831:             }
121831:             if (aInitData->mNoAutoHide) {
 43761:                 // ... but the window manager does not decorate this window,
 43761:                 // nor provide a separate taskbar icon.
 48261:                 if (mBorderStyle == eBorderStyle_default) {
 48261:                   gtk_window_set_decorated(GTK_WINDOW(mShell), FALSE);
 48261:                 }
 48261:                 else {
 79445:                   bool decorate = mBorderStyle & eBorderStyle_title;
 48261:                   gtk_window_set_decorated(GTK_WINDOW(mShell), decorate);
 48261:                   if (decorate) {
 48261:                     gtk_window_set_deletable(GTK_WINDOW(mShell), mBorderStyle & eBorderStyle_close);
 48261:                   }
 48261:                 }
 51873:                 gtk_window_set_skip_taskbar_hint(GTK_WINDOW(mShell), TRUE);
 43761:                 // Element focus is managed by the parent window so the
 43761:                 // WM_HINTS input field is set to False to tell the window
 43761:                 // manager not to set input focus to this window ...
 51873:                 gtk_window_set_accept_focus(GTK_WINDOW(mShell), FALSE);
 43761: #ifdef MOZ_X11
 43761:                 // ... but when the window manager offers focus through
 43761:                 // WM_TAKE_FOCUS, focus is requested on the parent window.
 43761:                 gtk_widget_realize(mShell);
 78664:                 gdk_window_add_filter(gtk_widget_get_window(mShell),
 43761:                                       popup_take_focus_filter, NULL); 
 43761: #endif
 43761:             }
 43761: 
 12796:             GdkWindowTypeHint gtkTypeHint;
 77050:             if (aInitData->mIsDragPopup) {
 77050:                 gtkTypeHint = GDK_WINDOW_TYPE_HINT_DND;
 77050:             }
 77050:             else {
 12796:                 switch (aInitData->mPopupHint) {
 12796:                     case ePopupTypeMenu:
 12796:                         gtkTypeHint = GDK_WINDOW_TYPE_HINT_POPUP_MENU;
 12796:                         break;
 12796:                     case ePopupTypeTooltip:
 12796:                         gtkTypeHint = GDK_WINDOW_TYPE_HINT_TOOLTIP;
 12796:                         break;
 12796:                     default:
 12796:                         gtkTypeHint = GDK_WINDOW_TYPE_HINT_UTILITY;
 12796:                         break;
 12796:                 }
 77050:             }
 12796:             gtk_window_set_type_hint(GTK_WINDOW(mShell), gtkTypeHint);
     1: 
     1:             if (topLevelParent) {
     1:                 gtk_window_set_transient_for(GTK_WINDOW(mShell),
     1:                                             topLevelParent);
     1:                 mTransientParent = topLevelParent;
     1: 
 78664:                 GtkWindowGroup *groupParent = gtk_window_get_group(topLevelParent);
 78664:                 if (groupParent) {
 78664:                     gtk_window_group_add_window(groupParent, GTK_WINDOW(mShell));
 78664:                     mWindowGroup = groupParent;
 69740:                     g_object_ref(mWindowGroup);
     1:                 }
     1:             }
     1:         }
     1:         else { // must be eWindowType_toplevel
     1:             mShell = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     1:             SetDefaultIcon();
 94220:             gtk_window_set_wmclass(GTK_WINDOW(mShell), "Toplevel", 
 94220:                                    gdk_get_program_class());
     1: 
     1:             // each toplevel window gets its own window group
     1:             mWindowGroup = gtk_window_group_new();
     1: 
     1:             // and add ourselves to the window group
     1:             LOG(("adding window %p to new group %p\n",
     1:                  (void *)mShell, (void *)mWindowGroup));
     1:             gtk_window_group_add_window(mWindowGroup, GTK_WINDOW(mShell));
     1:         }
     1: 
119750:         // Prevent GtkWindow from painting a background to flicker.
119750:         gtk_widget_set_app_paintable(mShell, TRUE);
119750: 
119750:         // Create a container to hold child windows and child GtkWidgets.
 30704:         GtkWidget *container = moz_container_new();
 30704:         mContainer = MOZ_CONTAINER(container);
119750:         // Use mShell's window for drawing and events.
119750:         gtk_widget_set_has_window(container, FALSE);
119750:         eventWidget = mShell;
119750:         gtk_widget_add_events(eventWidget, kEvents);
 30704:         gtk_container_add(GTK_CONTAINER(mShell), container);
 30704:         gtk_widget_realize(container);
     1: 
     1:         // make sure this is the focus widget in the container
122013:         gtk_widget_show(container);
122013:         gtk_widget_grab_focus(container);
 30704: 
 30705:         // the drawing window
119750:         mGdkWindow = gtk_widget_get_window(mShell);
     1: 
     1:         if (mWindowType == eWindowType_popup) {
     1:             // gdk does not automatically set the cursor for "temporary"
     1:             // windows, which are what gtk uses for popups.
     1: 
     1:             mCursor = eCursor_wait; // force SetCursor to actually set the
     1:                                     // cursor, even though our internal state
     1:                                     // indicates that we already have the
     1:                                     // standard cursor.
     1:             SetCursor(eCursor_standard);
 48256: 
 48256:             if (aInitData->mNoAutoHide) {
 48256:                 gint wmd = ConvertBorderStyles(mBorderStyle);
 48256:                 if (wmd != -1)
 78664:                   gdk_window_set_decorations(gtk_widget_get_window(mShell), (GdkWMDecoration) wmd);
 48256:             }
     1:         }
     1:     }
     1:         break;
 33357:     case eWindowType_plugin:
     1:     case eWindowType_child: {
     1:         if (parentMozContainer) {
 30704:             mGdkWindow = CreateGdkWindow(parentGdkWindow, parentMozContainer);
 34456:             mHasMappedToplevel = parentnsWindow->mHasMappedToplevel;
     1:         }
     1:         else if (parentGtkContainer) {
119750:             // This MozContainer has its own window for drawing and receives
119750:             // events because there is no mShell widget (corresponding to this
119750:             // nsWindow).
 30704:             GtkWidget *container = moz_container_new();
 30704:             mContainer = MOZ_CONTAINER(container);
119750:             eventWidget = container;
119750:             gtk_widget_add_events(eventWidget, kEvents);
 30704:             gtk_container_add(parentGtkContainer, container);
 30704:             gtk_widget_realize(container);
     1: 
 78664:             mGdkWindow = gtk_widget_get_window(container);
     1:         }
     1:         else {
     1:             NS_WARNING("Warning: tried to create a new child widget with no parent!");
     1:             return NS_ERROR_FAILURE;
     1:         }
     1:     }
     1:         break;
     1:     default:
     1:         break;
     1:     }
     1: 
 30704:     // label the drawing window with this object so we can find our way home
 30704:     g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", this);
     1: 
     1:     if (mContainer)
     1:         g_object_set_data(G_OBJECT(mContainer), "nsWindow", this);
     1: 
     1:     if (mShell)
     1:         g_object_set_data(G_OBJECT(mShell), "nsWindow", this);
     1: 
     1:     // attach listeners for events
     1:     if (mShell) {
 69740:         g_signal_connect(mShell, "configure_event",
     1:                          G_CALLBACK(configure_event_cb), NULL);
 69740:         g_signal_connect(mShell, "delete_event",
     1:                          G_CALLBACK(delete_event_cb), NULL);
 69740:         g_signal_connect(mShell, "window_state_event",
     1:                          G_CALLBACK(window_state_event_cb), NULL);
     1: 
     1:         GtkSettings* default_settings = gtk_settings_get_default();
     1:         g_signal_connect_after(default_settings,
     1:                                "notify::gtk-theme-name",
     1:                                G_CALLBACK(theme_changed_cb), this);
     1:         g_signal_connect_after(default_settings,
     1:                                "notify::gtk-font-name",
     1:                                G_CALLBACK(theme_changed_cb), this);
 40081: 
 40081: #ifdef MOZ_PLATFORM_MAEMO
 40081:         if (mWindowType == eWindowType_toplevel) {
 78664:             GdkWindow *gdkwin = gtk_widget_get_window(mShell);
 40081: 
 40087:             // Tell the Hildon desktop that we support being rotated
 40087:             gulong portrait_set = 1;
 40087:             GdkAtom support = gdk_atom_intern("_HILDON_PORTRAIT_MODE_SUPPORT", FALSE);
 40087:             gdk_property_change(gdkwin, support, gdk_x11_xatom_to_atom(XA_CARDINAL),
 40087:                                 32, GDK_PROP_MODE_REPLACE,
 40087:                                 (const guchar *) &portrait_set, 1);
 40087: 
 40081:             // Tell maemo-status-volume daemon to ungrab keys
 40081:             gulong volume_set = 1;
 40081:             GdkAtom keys = gdk_atom_intern("_HILDON_ZOOM_KEY_ATOM", FALSE);
 40081:             gdk_property_change(gdkwin, keys, gdk_x11_xatom_to_atom(XA_INTEGER),
 40081:                                 32, GDK_PROP_MODE_REPLACE, (const guchar *) &volume_set, 1);
 40081:         }
 40081: #endif
     1:     }
     1: 
     1:     if (mContainer) {
119750:         // Widget signals
 69740:         g_signal_connect(mContainer, "unrealize",
 28365:                          G_CALLBACK(container_unrealize_cb), NULL);
 69740:         g_signal_connect_after(mContainer, "size_allocate",
     1:                                G_CALLBACK(size_allocate_cb), NULL);
119750:         g_signal_connect(mContainer, "hierarchy-changed",
119750:                          G_CALLBACK(hierarchy_changed_cb), NULL);
119750:         // Initialize mHasMappedToplevel.
119750:         hierarchy_changed_cb(GTK_WIDGET(mContainer), NULL);
119750:         // Expose, focus, key, and drag events are sent even to GTK_NO_WINDOW
119750:         // widgets.
 78664: #if defined(MOZ_WIDGET_GTK2)
 69740:         g_signal_connect(mContainer, "expose_event",
     1:                          G_CALLBACK(expose_event_cb), NULL);
 78664: #else
 78664:         g_signal_connect(G_OBJECT(mContainer), "draw",
 78664:                          G_CALLBACK(expose_event_cb), NULL);
 78664: #endif
 69740:         g_signal_connect(mContainer, "focus_in_event",
     1:                          G_CALLBACK(focus_in_event_cb), NULL);
 69740:         g_signal_connect(mContainer, "focus_out_event",
     1:                          G_CALLBACK(focus_out_event_cb), NULL);
 69740:         g_signal_connect(mContainer, "key_press_event",
     1:                          G_CALLBACK(key_press_event_cb), NULL);
 69740:         g_signal_connect(mContainer, "key_release_event",
     1:                          G_CALLBACK(key_release_event_cb), NULL);
     1: 
     1:         gtk_drag_dest_set((GtkWidget *)mContainer,
     1:                           (GtkDestDefaults)0,
     1:                           NULL,
     1:                           0,
     1:                           (GdkDragAction)0);
     1: 
 69740:         g_signal_connect(mContainer, "drag_motion",
     1:                          G_CALLBACK(drag_motion_event_cb), NULL);
 69740:         g_signal_connect(mContainer, "drag_leave",
     1:                          G_CALLBACK(drag_leave_event_cb), NULL);
 69740:         g_signal_connect(mContainer, "drag_drop",
     1:                          G_CALLBACK(drag_drop_event_cb), NULL);
 69740:         g_signal_connect(mContainer, "drag_data_received",
     1:                          G_CALLBACK(drag_data_received_event_cb), NULL);
     1: 
119750:         GtkWidget *widgets[] = { GTK_WIDGET(mContainer), mShell };
119750:         for (size_t i = 0; i < ArrayLength(widgets) && widgets[i]; ++i) {
119750:             // Visibility events are sent to the owning widget of the relevant
119750:             // window but do not propagate to parent widgets so connect on
119750:             // mShell (if it exists) as well as mContainer.
119750:             g_signal_connect(widgets[i], "visibility-notify-event",
119750:                              G_CALLBACK(visibility_notify_event_cb), NULL);
119750:             // Similarly double buffering is controlled by the window's owning
119750:             // widget.  Disable double buffering for painting directly to the
119750:             // X Window.
119750:             gtk_widget_set_double_buffered(widgets[i], FALSE);
119750:         }
119750: 
     1:         // We create input contexts for all containers, except for
     1:         // toplevel popup windows
 39627:         if (mWindowType != eWindowType_popup) {
 39627:             mIMModule = new nsGtkIMModule(this);
 39627:         }
 39627:     } else if (!mIMModule) {
 39627:         nsWindow *container = GetContainerWindow();
 39627:         if (container) {
 39627:             mIMModule = container->mIMModule;
 39627:         }
     1:     }
     1: 
119750:     if (eventWidget) {
119750:         // Don't let GTK mess with the shapes of our GdkWindows
119750:         GTK_PRIVATE_SET_FLAG(eventWidget, GTK_HAS_SHAPE_MASK);
119750: 
119750:         // These events are sent to the owning widget of the relevant window
119750:         // and propagate up to the first widget that handles the events, so we
119750:         // need only connect on mShell, if it exists, to catch events on its
119750:         // window and windows of mContainer.
119750:         g_signal_connect(eventWidget, "enter-notify-event",
119750:                          G_CALLBACK(enter_notify_event_cb), NULL);
119750:         g_signal_connect(eventWidget, "leave-notify-event",
119750:                          G_CALLBACK(leave_notify_event_cb), NULL);
119750:         g_signal_connect(eventWidget, "motion-notify-event",
119750:                          G_CALLBACK(motion_notify_event_cb), NULL);
119750:         g_signal_connect(eventWidget, "button-press-event",
119750:                          G_CALLBACK(button_press_event_cb), NULL);
119750:         g_signal_connect(eventWidget, "button-release-event",
119750:                          G_CALLBACK(button_release_event_cb), NULL);
119750:         g_signal_connect(eventWidget, "scroll-event",
119750:                          G_CALLBACK(scroll_event_cb), NULL);
119750:     }
119750: 
     1:     LOG(("nsWindow [%p]\n", (void *)this));
     1:     if (mShell) {
119751:         LOG(("\tmShell %p mContainer %p mGdkWindow %p 0x%lx\n",
119751:              mShell, mContainer, mGdkWindow,
119751:              gdk_x11_window_get_xid(mGdkWindow)));
119751:     } else if (mContainer) {
119751:         LOG(("\tmContainer %p mGdkWindow %p\n", mContainer, mGdkWindow));
     1:     }
 30705:     else if (mGdkWindow) {
119751:         LOG(("\tmGdkWindow %p parent %p\n",
119751:              mGdkWindow, gdk_window_get_parent(mGdkWindow)));
     1:     }
     1: 
     1:     // resize so that everything is set to the right dimensions
  2144:     if (!mIsTopLevel)
 79636:         Resize(mBounds.x, mBounds.y, mBounds.width, mBounds.height, false);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWindow::SetWindowClass(const nsAString &xulWinType)
     1: {
     1:   if (!mShell)
     1:     return NS_ERROR_FAILURE;
     1: 
 94220:   const char *res_class = gdk_get_program_class();
 94220:   if (!res_class)
 94220:     return NS_ERROR_FAILURE;
 94220:   
 94220:   char *res_name = ToNewCString(xulWinType);
 16529:   if (!res_name)
 16529:     return NS_ERROR_OUT_OF_MEMORY;
 16529: 
 16529:   const char *role = NULL;
 16529: 
 16529:   // Parse res_name into a name and role. Characters other than
 16529:   // [A-Za-z0-9_-] are converted to '_'. Anything after the first
 16529:   // colon is assigned to role; if there's no colon, assign the
 16529:   // whole thing to both role and res_name.
 16529:   for (char *c = res_name; *c; c++) {
 16529:     if (':' == *c) {
 16529:       *c = 0;
 16529:       role = c + 1;
 16529:     }
 16529:     else if (!isascii(*c) || (!isalnum(*c) && ('_' != *c) && ('-' != *c)))
 16529:       *c = '_';
 16529:   }
 16529:   res_name[0] = toupper(res_name[0]);
 16529:   if (!role) role = res_name;
 16529: 
 94220:   GdkWindow *shellWindow = gtk_widget_get_window(GTK_WIDGET(mShell));
 94220:   gdk_window_set_role(shellWindow, role);
 94220: 
 94220: #ifdef MOZ_X11
 94220:   XClassHint *class_hint = XAllocClassHint();
 94220:   if (!class_hint) {
 16529:     nsMemory::Free(res_name);
 94220:     return NS_ERROR_OUT_OF_MEMORY;
 94220:   }
 94220:   class_hint->res_name = res_name;
 94220:   class_hint->res_class = const_cast<char*>(res_class);
 94220: 
 94220:   // Can't use gtk_window_set_wmclass() for this; it prints
 94220:   // a warning & refuses to make the change.
 94220:   XSetClassHint(GDK_DISPLAY_XDISPLAY(gdk_display_get_default()),
 94220:                 gdk_x11_window_get_xid(shellWindow),
 94220:                 class_hint);
 94220:   XFree(class_hint);
 16529: #endif /* MOZ_X11 */
 94220: 
 94220:   nsMemory::Free(res_name);
 94220: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
108991: nsWindow::NativeResize(int32_t aWidth, int32_t aHeight, bool    aRepaint)
     1: {
     1:     LOG(("nsWindow::NativeResize [%p] %d %d\n", (void *)this,
     1:          aWidth, aHeight));
     1: 
     1:     // clear our resize flag
 79636:     mNeedsResize = false;
     1: 
     1:     if (mIsTopLevel) {
     1:         gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
     1:     }
     1:     else if (mContainer) {
 30705:         GtkWidget *widget = GTK_WIDGET(mContainer);
 78664:         GtkAllocation allocation, prev_allocation;
 78664:         gtk_widget_get_allocation(widget, &prev_allocation);
 78664:         allocation.x = prev_allocation.x;
 78664:         allocation.y = prev_allocation.y;
     1:         allocation.width = aWidth;
     1:         allocation.height = aHeight;
 30705:         gtk_widget_size_allocate(widget, &allocation);
 30705:     }
 30705:     else if (mGdkWindow) {
 30704:         gdk_window_resize(mGdkWindow, aWidth, aHeight);
     1:     }
 26758: }
     1: 
     1: void
108991: nsWindow::NativeResize(int32_t aX, int32_t aY,
108991:                        int32_t aWidth, int32_t aHeight,
 79445:                        bool    aRepaint)
     1: {
 79636:     mNeedsResize = false;
 79636:     mNeedsMove = false;
     1: 
     1:     LOG(("nsWindow::NativeResize [%p] %d %d %d %d\n", (void *)this,
     1:          aX, aY, aWidth, aHeight));
     1: 
     1:     if (mIsTopLevel) {
 73647:         // aX and aY give the position of the window manager frame top-left.
     1:         gtk_window_move(GTK_WINDOW(mShell), aX, aY);
 73647:         // This sets the client window size.
     1:         gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
     1:     }
     1:     else if (mContainer) {
     1:         GtkAllocation allocation;
 30705:         allocation.x = aX;
 30705:         allocation.y = aY;
     1:         allocation.width = aWidth;
     1:         allocation.height = aHeight;
     1:         gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
 30704:     }
 30704:     else if (mGdkWindow) {
 30704:         gdk_window_move_resize(mGdkWindow, aX, aY, aWidth, aHeight);
     1:     }
     1: }
     1: 
     1: void
 79445: nsWindow::NativeShow(bool aAction)
     1: {
     1:     if (aAction) {
     1:         // unset our flag now that our window has been shown
 79636:         mNeedsShow = false;
     1: 
     1:         if (mIsTopLevel) {
     1:             // Set up usertime/startupID metadata for the created window.
     1:             if (mWindowType != eWindowType_invisible) {
     1:                 SetUserTimeAndStartupIDForActivatedWindow(mShell);
     1:             }
     1: 
     1:             gtk_widget_show(mShell);
     1:         }
     1:         else if (mContainer) {
     1:             gtk_widget_show(GTK_WIDGET(mContainer));
     1:         }
 30704:         else if (mGdkWindow) {
 30704:             gdk_window_show_unraised(mGdkWindow);
     1:         }
     1:     }
     1:     else {
     1:         if (mIsTopLevel) {
     1:             gtk_widget_hide(GTK_WIDGET(mShell));
115972: 
115972:             ClearTransparencyBitmap(); // Release some resources
     1:         }
     1:         else if (mContainer) {
     1:             gtk_widget_hide(GTK_WIDGET(mContainer));
 30705:         }
 30705:         else if (mGdkWindow) {
 30704:             gdk_window_hide(mGdkWindow);
     1:         }
     1:     }
     1: }
     1: 
 34456: void
 79445: nsWindow::SetHasMappedToplevel(bool aState)
 34456: {
 34456:     // Even when aState == mHasMappedToplevel (as when this method is called
 34456:     // from Show()), child windows need to have their state checked, so don't
 34456:     // return early.
 79445:     bool oldState = mHasMappedToplevel;
 34456:     mHasMappedToplevel = aState;
 34456: 
 34456:     // mHasMappedToplevel is not updated for children of windows that are
 34456:     // hidden; GDK knows not to send expose events for these windows.  The
 34456:     // state is recorded on the hidden window itself, but, for child trees of
 34456:     // hidden windows, their state essentially becomes disconnected from their
 34456:     // hidden parent.  When the hidden parent gets shown, the child trees are
 34456:     // reconnected, and the state of the window being shown can be easily
 34456:     // propagated.
 34456:     if (!mIsShown || !mGdkWindow)
 34456:         return;
 34456: 
 34456:     if (aState && !oldState && !mIsFullyObscured) {
 34456:         // GDK_EXPOSE events have been ignored but the window is now visible,
 34456:         // so make sure GDK doesn't think that the window has already been
 34456:         // painted.
 34456:         gdk_window_invalidate_rect(mGdkWindow, NULL, FALSE);
 34456: 
 34456:         // Check that a grab didn't fail due to the window not being
 34456:         // viewable.
 34456:         EnsureGrabs();
 34456:     }
 34456: 
 34456:     for (GList *children = gdk_window_peek_children(mGdkWindow);
 34456:          children;
 34456:          children = children->next) {
 34456:         GdkWindow *gdkWin = GDK_WINDOW(children->data);
 34456:         nsWindow *child = get_window_for_gdk_window(gdkWin);
 34456: 
 34456:         if (child && child->mHasMappedToplevel != aState) {
 34456:             child->SetHasMappedToplevel(aState);
 34456:         }
 34456:     }
 34456: }
 34456: 
 23738: nsIntSize
 23738: nsWindow::GetSafeWindowSize(nsIntSize aSize)
 23738: {
122623:     // The X protocol uses CARD32 for window sizes, but the server (1.11.3)
122623:     // reads it as CARD16.  Sizes of pixmaps, used for drawing, are (unsigned)
122623:     // CARD16 in the protocol, but the server's ProcCreatePixmap returns
122623:     // BadAlloc if dimensions cannot be represented by signed shorts.
 23738:     nsIntSize result = aSize;
108991:     const int32_t kInt16Max = 32767;
 18736:     if (result.width > kInt16Max) {
 18736:         result.width = kInt16Max;
 18736:     }
 18736:     if (result.height > kInt16Max) {
 18736:         result.height = kInt16Max;
 15623:     }
 15623:     return result;
 15623: }
 15623: 
     1: void
     1: nsWindow::EnsureGrabs(void)
     1: {
     1:     if (mRetryPointerGrab)
 89550:         GrabPointer(sRetryGrabTime);
     1: }
     1: 
 16601: void
114750: nsWindow::CleanLayerManagerRecursive(void) {
114750:     if (mLayerManager) {
114750:         mLayerManager->Destroy();
114750:         mLayerManager = nullptr;
114750:     }
114750: 
114750:     DestroyCompositor();
114750: 
114750:     GList* children = gdk_window_peek_children(mGdkWindow);
114750:     for (GList* list = children; list; list = list->next) {
114750:         nsWindow* window = get_window_for_gdk_window(GDK_WINDOW(list->data));
114750:         if (window) {
114750:             window->CleanLayerManagerRecursive();
114750:         }
114750:     }
114750: }
114750: 
114750: void
 16601: nsWindow::SetTransparencyMode(nsTransparencyMode aMode)
     1: {
     1:     if (!mShell) {
     1:         // Pass the request to the toplevel window
121096:         GtkWidget *topWidget = GetToplevelWidget();
     1:         if (!topWidget)
 16601:             return;
     1: 
     1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
     1:         if (!topWindow)
 16601:             return;
 16601: 
 16601:         topWindow->SetTransparencyMode(aMode);
 16601:         return;
 16601:     }
 79445:     bool isTransparent = aMode == eTransparencyTransparent;
 16601: 
 16601:     if (mIsTransparent == isTransparent)
 16601:         return;
 16601: 
 16601:     if (!isTransparent) {
115972:         ClearTransparencyBitmap();
     1:     } // else the new default alpha values are "all 1", so we don't
     1:     // need to change anything yet
     1: 
 16601:     mIsTransparent = isTransparent;
114750: 
114750:     // Need to clean our LayerManager up while still alive because
114750:     // we don't want to use layers acceleration on shaped windows
114750:     CleanLayerManagerRecursive();
 16601: }
 16601: 
 16601: nsTransparencyMode
 16601: nsWindow::GetTransparencyMode()
     1: {
     1:     if (!mShell) {
     1:         // Pass the request to the toplevel window
121096:         GtkWidget *topWidget = GetToplevelWidget();
     1:         if (!topWidget) {
 16601:             return eTransparencyOpaque;
     1:         }
     1: 
     1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
     1:         if (!topWindow) {
 16601:             return eTransparencyOpaque;
 16601:         }
 16601: 
 16601:         return topWindow->GetTransparencyMode();
 16601:     }
 16601: 
 16601:     return mIsTransparent ? eTransparencyTransparent : eTransparencyOpaque;
     1: }
     1: 
 30515: nsresult
 30515: nsWindow::ConfigureChildren(const nsTArray<Configuration>& aConfigurations)
 30515: {
108991:     for (uint32_t i = 0; i < aConfigurations.Length(); ++i) {
 30515:         const Configuration& configuration = aConfigurations[i];
 30515:         nsWindow* w = static_cast<nsWindow*>(configuration.mChild);
 30515:         NS_ASSERTION(w->GetParent() == this,
 30515:                      "Configured widget is not a child");
 79636:         w->SetWindowClipRegion(configuration.mClipRegion, true);
 30515:         if (w->mBounds.Size() != configuration.mBounds.Size()) {
 30515:             w->Resize(configuration.mBounds.x, configuration.mBounds.y,
 30515:                       configuration.mBounds.width, configuration.mBounds.height,
 79636:                       true);
 30515:         } else if (w->mBounds.TopLeft() != configuration.mBounds.TopLeft()) {
 30515:             w->Move(configuration.mBounds.x, configuration.mBounds.y);
 30515:         } 
 79636:         w->SetWindowClipRegion(configuration.mClipRegion, false);
 30515:     }
 30515:     return NS_OK;
 30515: }
 30515: 
 50394: static pixman_box32
 50394: ToPixmanBox(const nsIntRect& aRect)
 50394: {
 50394:     pixman_box32_t result;
 50394:     result.x1 = aRect.x;
 50394:     result.y1 = aRect.y;
 50394:     result.x2 = aRect.XMost();
 50394:     result.y2 = aRect.YMost();
 50394:     return result;
 50394: }
 50394: 
 50394: static nsIntRect
 50394: ToIntRect(const pixman_box32& aBox)
 50394: {
 50394:     nsIntRect result;
 50394:     result.x = aBox.x1;
 50394:     result.y = aBox.y1;
 50394:     result.width = aBox.x2 - aBox.x1;
 50394:     result.height = aBox.y2 - aBox.y1;
 50394:     return result;
 50394: }
 50394: 
 50394: static void
 50394: InitRegion(pixman_region32* aRegion,
 50394:            const nsTArray<nsIntRect>& aRects)
 50394: {
 50394:     nsAutoTArray<pixman_box32,10> rects;
 50394:     rects.SetCapacity(aRects.Length());
108991:     for (uint32_t i = 0; i < aRects.Length (); ++i) {
 50394:         if (!aRects[i].IsEmpty()) {
 50394:             rects.AppendElement(ToPixmanBox(aRects[i]));
 50394:         }
 50394:     }
 50394: 
 50394:     pixman_region32_init_rects(aRegion,
 50394:                                rects.Elements(), rects.Length());
 50394: }
 50394: 
 50394: static void
 50394: GetIntRects(pixman_region32& aRegion, nsTArray<nsIntRect>* aRects)
 50394: {
 50394:     int nRects;
 50394:     pixman_box32* boxes = pixman_region32_rectangles(&aRegion, &nRects);
 50394:     aRects->SetCapacity(aRects->Length() + nRects);
 50394:     for (int i = 0; i < nRects; ++i) {
 50394:         aRects->AppendElement(ToIntRect(boxes[i]));
 50394:     }
 50394: }
 50394: 
 35698: void
 35698: nsWindow::SetWindowClipRegion(const nsTArray<nsIntRect>& aRects,
 79445:                               bool aIntersectWithExisting)
 35698: {
 35698:     const nsTArray<nsIntRect>* newRects = &aRects;
 35698: 
 35698:     nsAutoTArray<nsIntRect,1> intersectRects;
 35698:     if (aIntersectWithExisting) {
 35698:         nsAutoTArray<nsIntRect,1> existingRects;
 35698:         GetWindowClipRegion(&existingRects);
 35698: 
 35698:         nsAutoRef<pixman_region32> existingRegion;
 35698:         InitRegion(&existingRegion, existingRects);
 35698:         nsAutoRef<pixman_region32> newRegion;
 35698:         InitRegion(&newRegion, aRects);
 35698:         nsAutoRef<pixman_region32> intersectRegion;
 39053:         pixman_region32_init(&intersectRegion);
 35698:         pixman_region32_intersect(&intersectRegion,
 35698:                                   &newRegion, &existingRegion);
 35698: 
 59054:         // If mClipRects is null we haven't set a clip rect yet, so we
 59054:         // need to set the clip even if it is equal.
 59054:         if (mClipRects &&
 59054:             pixman_region32_equal(&intersectRegion, &existingRegion)) {
 35698:             return;
 59054:         }
 35698: 
 35698:         if (!pixman_region32_equal(&intersectRegion, &newRegion)) {
 35698:             GetIntRects(intersectRegion, &intersectRects);
 35698:             newRects = &intersectRects;
 35698:         }
 35698:     }
 35698: 
 35698:     if (!StoreWindowClipRegion(*newRects))
 35698:         return;
 30515: 
 30704:     if (!mGdkWindow)
 35698:         return;
 35698: 
 78664: #if defined(MOZ_WIDGET_GTK2)
 35698:     GdkRegion *region = gdk_region_new(); // aborts on OOM
108991:     for (uint32_t i = 0; i < newRects->Length(); ++i) {
 35698:         const nsIntRect& r = newRects->ElementAt(i);
 30515:         GdkRectangle rect = { r.x, r.y, r.width, r.height };
 30515:         gdk_region_union_with_rect(region, &rect);
 30515:     }
 30515: 
 30704:     gdk_window_shape_combine_region(mGdkWindow, region, 0, 0);
 30515:     gdk_region_destroy(region);
 78664: #else
 78664:     cairo_region_t *region = cairo_region_create();
108991:     for (uint32_t i = 0; i < newRects->Length(); ++i) {
 78664:         const nsIntRect& r = newRects->ElementAt(i);
 78664:         cairo_rectangle_int_t rect = { r.x, r.y, r.width, r.height };
 78664:         cairo_region_union_rectangle(region, &rect);
 78664:     }
 78664: 
 78664:     gdk_window_shape_combine_region(mGdkWindow, region, 0, 0);
 78664:     cairo_region_destroy(region);
 78664: #endif
 30515:   
 35698:     return;
 30515: }
 30515: 
     1: void
114752: nsWindow::ResizeTransparencyBitmap()
     1: {
     1:     if (!mTransparencyBitmap)
     1:         return;
     1: 
114752:     if (mBounds.width == mTransparencyBitmapWidth &&
114752:         mBounds.height == mTransparencyBitmapHeight)
     1:         return;
     1: 
114752:     int32_t newRowBytes = GetBitmapStride(mBounds.width);
114752:     int32_t newSize = newRowBytes * mBounds.height;
     1:     gchar* newBits = new gchar[newSize];
114752:     // fill new mask with "transparent", first
114752:     memset(newBits, 0, newSize);
     1: 
     1:     // Now copy the intersection of the old and new areas into the new mask
114752:     int32_t copyWidth = NS_MIN(mBounds.width, mTransparencyBitmapWidth);
114752:     int32_t copyHeight = NS_MIN(mBounds.height, mTransparencyBitmapHeight);
108991:     int32_t oldRowBytes = GetBitmapStride(mTransparencyBitmapWidth);
108991:     int32_t copyBytes = GetBitmapStride(copyWidth);
108991: 
108991:     int32_t i;
     1:     gchar* fromPtr = mTransparencyBitmap;
     1:     gchar* toPtr = newBits;
     1:     for (i = 0; i < copyHeight; i++) {
     1:         memcpy(toPtr, fromPtr, copyBytes);
     1:         fromPtr += oldRowBytes;
     1:         toPtr += newRowBytes;
     1:     }
     1: 
     1:     delete[] mTransparencyBitmap;
     1:     mTransparencyBitmap = newBits;
114752:     mTransparencyBitmapWidth = mBounds.width;
114752:     mTransparencyBitmapHeight = mBounds.height;
     1: }
     1: 
 79445: static bool
108991: ChangedMaskBits(gchar* aMaskBits, int32_t aMaskWidth, int32_t aMaskHeight,
108991:         const nsIntRect& aRect, uint8_t* aAlphas, int32_t aStride)
108991: {
108991:     int32_t x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
108991:     int32_t maskBytesPerRow = GetBitmapStride(aMaskWidth);
     1:     for (y = aRect.y; y < yMax; y++) {
     1:         gchar* maskBytes = aMaskBits + y*maskBytesPerRow;
108991:         uint8_t* alphas = aAlphas;
     1:         for (x = aRect.x; x < xMax; x++) {
115970:             bool newBit = *alphas > 0x7f;
     1:             alphas++;
     1: 
     1:             gchar maskByte = maskBytes[x >> 3];
 79445:             bool maskBit = (maskByte & (1 << (x & 7))) != 0;
     1: 
     1:             if (maskBit != newBit) {
 79636:                 return true;
     1:             }
     1:         }
     1:         aAlphas += aStride;
     1:     }
     1: 
 79636:     return false;
     1: }
     1: 
     1: static
108991: void UpdateMaskBits(gchar* aMaskBits, int32_t aMaskWidth, int32_t aMaskHeight,
108991:         const nsIntRect& aRect, uint8_t* aAlphas, int32_t aStride)
108991: {
108991:     int32_t x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
108991:     int32_t maskBytesPerRow = GetBitmapStride(aMaskWidth);
     1:     for (y = aRect.y; y < yMax; y++) {
     1:         gchar* maskBytes = aMaskBits + y*maskBytesPerRow;
108991:         uint8_t* alphas = aAlphas;
     1:         for (x = aRect.x; x < xMax; x++) {
115970:             bool newBit = *alphas > 0x7f;
     1:             alphas++;
     1: 
     1:             gchar mask = 1 << (x & 7);
     1:             gchar maskByte = maskBytes[x >> 3];
     1:             // Note: '-newBit' turns 0 into 00...00 and 1 into 11...11
     1:             maskBytes[x >> 3] = (maskByte & ~mask) | (-newBit & mask);
     1:         }
     1:         aAlphas += aStride;
     1:     }
     1: }
     1: 
     1: void
     1: nsWindow::ApplyTransparencyBitmap()
     1: {
 69673: #ifdef MOZ_X11
 69673:     // We use X11 calls where possible, because GDK handles expose events
 69673:     // for shaped windows in a way that's incompatible with us (Bug 635903).
 69673:     // It doesn't occur when the shapes are set through X.
 78664:     GdkWindow *shellWindow = gtk_widget_get_window(mShell);
 78664:     Display* xDisplay = GDK_WINDOW_XDISPLAY(shellWindow);
 78664:     Window xDrawable = GDK_WINDOW_XID(shellWindow);
 69673:     Pixmap maskPixmap = XCreateBitmapFromData(xDisplay,
 69673:                                               xDrawable,
 69673:                                               mTransparencyBitmap,
 69673:                                               mTransparencyBitmapWidth,
 69673:                                               mTransparencyBitmapHeight);
 69673:     XShapeCombineMask(xDisplay, xDrawable,
 69673:                       ShapeBounding, 0, 0,
 69673:                       maskPixmap, ShapeSet);
 69673:     XFreePixmap(xDisplay, maskPixmap);
 69673: #else
 78664: #if defined(MOZ_WIDGET_GTK2)
     1:     gtk_widget_reset_shapes(mShell);
 78664:     GdkBitmap* maskBitmap = gdk_bitmap_create_from_data(gtk_widget_get_window(mShell),
     1:             mTransparencyBitmap,
     1:             mTransparencyBitmapWidth, mTransparencyBitmapHeight);
     1:     if (!maskBitmap)
     1:         return;
     1: 
     1:     gtk_widget_shape_combine_mask(mShell, maskBitmap, 0, 0);
 24530:     g_object_unref(maskBitmap);
 78664: #else
 78664:     cairo_surface_t *maskBitmap;
 78664:     maskBitmap = cairo_image_surface_create_for_data((unsigned char*)mTransparencyBitmap, 
 78664:                                                      CAIRO_FORMAT_A1, 
 78664:                                                      mTransparencyBitmapWidth, 
 78664:                                                      mTransparencyBitmapHeight,
 78664:                                                      GetBitmapStride(mTransparencyBitmapWidth));
 78664:     if (!maskBitmap)
 78664:         return;
 78664: 
 78664:     cairo_region_t * maskRegion = gdk_cairo_region_create_from_surface(maskBitmap);
 78664:     gtk_widget_shape_combine_region(mShell, maskRegion);
 78664:     cairo_region_destroy(maskRegion);
 78664:     cairo_surface_destroy(maskBitmap);
 78664: #endif // MOZ_WIDGET_GTK2
 78664: #endif // MOZ_X11
     1: }
     1: 
115972: void
115972: nsWindow::ClearTransparencyBitmap()
115972: {
115972:     if (!mTransparencyBitmap)
115972:         return;
115972: 
115972:     delete[] mTransparencyBitmap;
115972:     mTransparencyBitmap = nullptr;
115972:     mTransparencyBitmapWidth = 0;
115972:     mTransparencyBitmapHeight = 0;
115972: 
115972:     if (!mShell)
115972:         return;
115972: 
115972: #ifdef MOZ_X11
115972:     GdkWindow *window = gtk_widget_get_window(mShell);
115972:     if (!window)
115972:         return;
115972: 
115972:     Display* xDisplay = GDK_WINDOW_XDISPLAY(window);
115972:     Window xWindow = gdk_x11_window_get_xid(window);
115972: 
115972:     XShapeCombineMask(xDisplay, xWindow, ShapeBounding, 0, 0, None, ShapeSet);
115972: #endif
115972: }
115972: 
     1: nsresult
 23738: nsWindow::UpdateTranslucentWindowAlphaInternal(const nsIntRect& aRect,
108991:                                                uint8_t* aAlphas, int32_t aStride)
     1: {
     1:     if (!mShell) {
     1:         // Pass the request to the toplevel window
121096:         GtkWidget *topWidget = GetToplevelWidget();
     1:         if (!topWidget)
     1:             return NS_ERROR_FAILURE;
     1: 
     1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
     1:         if (!topWindow)
     1:             return NS_ERROR_FAILURE;
     1: 
     1:         return topWindow->UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aStride);
     1:     }
     1: 
  9499:     NS_ASSERTION(mIsTransparent, "Window is not transparent");
     1: 
106838:     if (mTransparencyBitmap == nullptr) {
108991:         int32_t size = GetBitmapStride(mBounds.width)*mBounds.height;
     1:         mTransparencyBitmap = new gchar[size];
     1:         memset(mTransparencyBitmap, 255, size);
     1:         mTransparencyBitmapWidth = mBounds.width;
     1:         mTransparencyBitmapHeight = mBounds.height;
114752:     } else {
114752:         ResizeTransparencyBitmap();
     1:     }
     1: 
114753:     nsIntRect rect;
114753:     rect.IntersectRect(aRect, nsIntRect(0, 0, mBounds.width, mBounds.height));
     1: 
     1:     if (!ChangedMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height,
114753:                          rect, aAlphas, aStride))
     1:         // skip the expensive stuff if the mask bits haven't changed; hopefully
     1:         // this is the common case
     1:         return NS_OK;
     1: 
     1:     UpdateMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height,
114753:                    rect, aAlphas, aStride);
     1: 
     1:     if (!mNeedsShow) {
     1:         ApplyTransparencyBitmap();
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: void
 89550: nsWindow::GrabPointer(guint32 aTime)
     1: {
 89613:     LOG(("GrabPointer time=0x%08x retry=%d\n",
 89613:          (unsigned int)aTime, mRetryPointerGrab));
     1: 
 79636:     mRetryPointerGrab = false;
 89613:     sRetryGrabTime = aTime;
     1: 
     1:     // If the window isn't visible, just set the flag to retry the
     1:     // grab.  When this window becomes visible, the grab will be
     1:     // retried.
 34456:     if (!mHasMappedToplevel || mIsFullyObscured) {
     1:         LOG(("GrabPointer: window not visible\n"));
 79636:         mRetryPointerGrab = true;
     1:         return;
     1:     }
     1: 
 30704:     if (!mGdkWindow)
     1:         return;
     1: 
     1:     gint retval;
 30704:     retval = gdk_pointer_grab(mGdkWindow, TRUE,
     1:                               (GdkEventMask)(GDK_BUTTON_PRESS_MASK |
     1:                                              GDK_BUTTON_RELEASE_MASK |
     1:                                              GDK_ENTER_NOTIFY_MASK |
     1:                                              GDK_LEAVE_NOTIFY_MASK |
 97566: #ifdef MOZ_PLATFORM_MAEMO
 21947:                                              GDK_POINTER_MOTION_HINT_MASK |
 21947: #endif
 21586:                                              GDK_POINTER_MOTION_MASK),
 89550:                               (GdkWindow *)NULL, NULL, aTime);
     1: 
 89548:     if (retval == GDK_GRAB_NOT_VIEWABLE) {
 89548:         LOG(("GrabPointer: window not viewable; will retry\n"));
 79636:         mRetryPointerGrab = true;
 89548:     } else if (retval != GDK_GRAB_SUCCESS) {
 89548:         LOG(("GrabPointer: pointer grab failed: %i\n", retval));
 89548:         // A failed grab indicates that another app has grabbed the pointer.
 89548:         // Check for rollup now, because, without the grab, we likely won't
 89548:         // get subsequent button press events.
120177:         CheckForRollup(0, 0, false, true);
     1:     }
     1: }
     1: 
     1: void
 62719: nsWindow::ReleaseGrabs(void)
 62719: {
 62719:     LOG(("ReleaseGrabs\n"));
 62719: 
 79636:     mRetryPointerGrab = false;
     1:     gdk_pointer_ungrab(GDK_CURRENT_TIME);
     1: }
     1: 
121096: GtkWidget *
121096: nsWindow::GetToplevelWidget()
121096: {
     1:     if (mShell) {
121096:         return mShell;
     1:     }
     1: 
 18490:     GtkWidget *widget = GetMozContainerWidget();
     1:     if (!widget)
121096:         return nullptr;
121096: 
121096:     return gtk_widget_get_toplevel(widget);
     1: }
     1: 
 18490: GtkWidget *
 18490: nsWindow::GetMozContainerWidget()
 18490: {
 30704:     if (!mGdkWindow)
 25258:         return NULL;
 25258: 
119750:     if (mContainer)
119750:         return GTK_WIDGET(mContainer);
119750: 
 18490:     GtkWidget *owningWidget =
 30704:         get_gtk_widget_for_gdk_window(mGdkWindow);
 18490:     return owningWidget;
 18490: }
 18490: 
 25258: nsWindow *
 25258: nsWindow::GetContainerWindow()
 25258: {
 18490:     GtkWidget *owningWidget = GetMozContainerWidget();
 25258:     if (!owningWidget)
106838:         return nullptr;
 25258: 
 25258:     nsWindow *window = get_window_for_gtk_widget(owningWidget);
 25258:     NS_ASSERTION(window, "No nsWindow for container widget");
 25258:     return window;
     1: }
     1: 
     1: void
 79445: nsWindow::SetUrgencyHint(GtkWidget *top_window, bool state)
     1: {
     1:     if (!top_window)
     1:         return;
     1:         
 78664:     gdk_window_set_urgency_hint(gtk_widget_get_window(top_window), state);
     1: }
     1: 
     1: void *
     1: nsWindow::SetupPluginPort(void)
     1: {
 30704:     if (!mGdkWindow)
106838:         return nullptr;
     1: 
 78664:     if (gdk_window_is_destroyed(mGdkWindow) == TRUE)
106838:         return nullptr;
     1: 
 78664:     Window window = gdk_x11_window_get_xid(mGdkWindow);
 78664:     
     1:     // we have to flush the X queue here so that any plugins that
     1:     // might be running on separate X connections will be able to use
     1:     // this window in case it was just created
 16529: #ifdef MOZ_X11
     1:     XWindowAttributes xattrs;    
 78664:     Display *display = GDK_DISPLAY_XDISPLAY(gdk_display_get_default());
 78664:     XGetWindowAttributes(display, window, &xattrs);
 78664:     XSelectInput (display, window,
     1:                   xattrs.your_event_mask |
     1:                   SubstructureNotifyMask);
     1: 
 30704:     gdk_window_add_filter(mGdkWindow, plugin_window_filter_func, this);
     1: 
 78664:     XSync(display, False);
 16529: #endif /* MOZ_X11 */
     1:     
 78664:     return (void *)window;
     1: }
     1: 
     1: void
     1: nsWindow::SetDefaultIcon(void)
     1: {
 10124:     SetIcon(NS_LITERAL_STRING("default"));
     1: }
     1: 
     1: void
     1: nsWindow::SetPluginType(PluginType aPluginType)
     1: {
     1:     mPluginType = aPluginType;
     1: }
     1: 
 16529: #ifdef MOZ_X11
     1: void
     1: nsWindow::SetNonXEmbedPluginFocus()
     1: {
     1:     if (gPluginFocusWindow == this || mPluginType!=PluginType_NONXEMBED) {
     1:         return;
     1:     }
     1: 
     1:     if (gPluginFocusWindow) {
   920:         nsRefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
     1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
     1:     }
     1: 
     1:     LOGFOCUS(("nsWindow::SetNonXEmbedPluginFocus\n"));
     1: 
     1:     Window curFocusWindow;
     1:     int focusState;
     1:     
 78664:     GdkDisplay *gdkDisplay = gdk_window_get_display(mGdkWindow);
 78664:     XGetInputFocus(gdk_x11_display_get_xdisplay(gdkDisplay),
     1:                    &curFocusWindow,
     1:                    &focusState);
     1: 
     1:     LOGFOCUS(("\t curFocusWindow=%p\n", curFocusWindow));
     1: 
 30704:     GdkWindow* toplevel = gdk_window_get_toplevel(mGdkWindow);
 78664: #if defined(MOZ_WIDGET_GTK2)
     1:     GdkWindow *gdkfocuswin = gdk_window_lookup(curFocusWindow);
 78664: #else
 78664:     GdkWindow *gdkfocuswin = gdk_x11_window_lookup_for_display(gdkDisplay,
 78664:                                                                curFocusWindow);
 78664: #endif
     1: 
     1:     // lookup with the focus proxy window is supposed to get the
     1:     // same GdkWindow as toplevel. If the current focused window
     1:     // is not the focus proxy, we return without any change.
     1:     if (gdkfocuswin != toplevel) {
     1:         return;
     1:     }
     1: 
     1:     // switch the focus from the focus proxy to the plugin window
     1:     mOldFocusWindow = curFocusWindow;
 30704:     XRaiseWindow(GDK_WINDOW_XDISPLAY(mGdkWindow),
 78664:                  gdk_x11_window_get_xid(mGdkWindow));
     1:     gdk_error_trap_push();
 30704:     XSetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
 78664:                    gdk_x11_window_get_xid(mGdkWindow),
     1:                    RevertToNone,
     1:                    CurrentTime);
     1:     gdk_flush();
     1:     gdk_error_trap_pop();
     1:     gPluginFocusWindow = this;
     1:     gdk_window_add_filter(NULL, plugin_client_message_filter, this);
     1: 
     1:     LOGFOCUS(("nsWindow::SetNonXEmbedPluginFocus oldfocus=%p new=%p\n",
 78664:               mOldFocusWindow, gdk_x11_window_get_xid(mGdkWindow)));
     1: }
     1: 
     1: void
     1: nsWindow::LoseNonXEmbedPluginFocus()
     1: {
     1:     LOGFOCUS(("nsWindow::LoseNonXEmbedPluginFocus\n"));
     1: 
     1:     // This method is only for the nsWindow which contains a
     1:     // Non-XEmbed plugin, for example, JAVA plugin.
     1:     if (gPluginFocusWindow != this || mPluginType!=PluginType_NONXEMBED) {
     1:         return;
     1:     }
     1: 
     1:     Window curFocusWindow;
     1:     int focusState;
     1: 
 30704:     XGetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
     1:                    &curFocusWindow,
     1:                    &focusState);
     1: 
     1:     // we only switch focus between plugin window and focus proxy. If the
     1:     // current focused window is not the plugin window, just removing the
     1:     // event filter that blocks the WM_TAKE_FOCUS is enough. WM and gtk2
     1:     // will take care of the focus later.
     1:     if (!curFocusWindow ||
 78664:         curFocusWindow == gdk_x11_window_get_xid(mGdkWindow)) {
     1: 
     1:         gdk_error_trap_push();
 30704:         XRaiseWindow(GDK_WINDOW_XDISPLAY(mGdkWindow),
     1:                      mOldFocusWindow);
 30704:         XSetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
     1:                        mOldFocusWindow,
     1:                        RevertToParent,
     1:                        CurrentTime);
     1:         gdk_flush();
     1:         gdk_error_trap_pop();
     1:     }
     1:     gPluginFocusWindow = NULL;
     1:     mOldFocusWindow = 0;
     1:     gdk_window_remove_filter(NULL, plugin_client_message_filter, this);
     1: 
     1:     LOGFOCUS(("nsWindow::LoseNonXEmbedPluginFocus end\n"));
     1: }
 16529: #endif /* MOZ_X11 */
     1: 
     1: gint
     1: nsWindow::ConvertBorderStyles(nsBorderStyle aStyle)
     1: {
     1:     gint w = 0;
     1: 
     1:     if (aStyle == eBorderStyle_default)
     1:         return -1;
     1: 
 48256:     // note that we don't handle eBorderStyle_close yet
     1:     if (aStyle & eBorderStyle_all)
     1:         w |= GDK_DECOR_ALL;
     1:     if (aStyle & eBorderStyle_border)
     1:         w |= GDK_DECOR_BORDER;
     1:     if (aStyle & eBorderStyle_resizeh)
     1:         w |= GDK_DECOR_RESIZEH;
     1:     if (aStyle & eBorderStyle_title)
     1:         w |= GDK_DECOR_TITLE;
     1:     if (aStyle & eBorderStyle_menu)
     1:         w |= GDK_DECOR_MENU;
     1:     if (aStyle & eBorderStyle_minimize)
     1:         w |= GDK_DECOR_MINIMIZE;
     1:     if (aStyle & eBorderStyle_maximize)
     1:         w |= GDK_DECOR_MAXIMIZE;
     1: 
     1:     return w;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsWindow::MakeFullScreen(bool aFullScreen)
     1: {
 31567:     LOG(("nsWindow::MakeFullScreen [%p] aFullScreen %d\n",
 31567:          (void *)this, aFullScreen));
 31567: 
 31567:     if (aFullScreen) {
 32018:         if (mSizeMode != nsSizeMode_Fullscreen)
 32018:             mLastSizeMode = mSizeMode;
 32018: 
 31567:         mSizeMode = nsSizeMode_Fullscreen;
 34744:         gtk_window_fullscreen(GTK_WINDOW(mShell));
 31567:     }
 32018:     else {
 32018:         mSizeMode = mLastSizeMode;
 34744:         gtk_window_unfullscreen(GTK_WINDOW(mShell));
 32018:     }
 32018: 
 32018:     NS_ASSERTION(mLastSizeMode != nsSizeMode_Fullscreen,
 32018:                  "mLastSizeMode should never be fullscreen");
  9857:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsWindow::HideWindowChrome(bool aShouldHide)
     1: {
     1:     if (!mShell) {
     1:         // Pass the request to the toplevel window
121096:         GtkWidget *topWidget = GetToplevelWidget();
 25258:         if (!topWidget)
 25258:             return NS_ERROR_FAILURE;
 25258: 
     1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
 25258:         if (!topWindow)
 25258:             return NS_ERROR_FAILURE;
 25258: 
     1:         return topWindow->HideWindowChrome(aShouldHide);
     1:     }
     1: 
     1:     // Sawfish, metacity, and presumably other window managers get
     1:     // confused if we change the window decorations while the window
     1:     // is visible.
 79445:     bool wasVisible = false;
 78664:     GdkWindow *shellWindow = gtk_widget_get_window(mShell);
 78664:     if (gdk_window_is_visible(shellWindow)) {
 78664:         gdk_window_hide(shellWindow);
 79636:         wasVisible = true;
 10249:     }
     1: 
     1:     gint wmd;
     1:     if (aShouldHide)
     1:         wmd = 0;
     1:     else
     1:         wmd = ConvertBorderStyles(mBorderStyle);
     1: 
 48256:     if (wmd != -1)
 78664:       gdk_window_set_decorations(shellWindow, (GdkWMDecoration) wmd);
     1: 
 10249:     if (wasVisible)
 78664:         gdk_window_show(shellWindow);
     1: 
     1:     // For some window managers, adding or removing window decorations
     1:     // requires unmapping and remapping our toplevel window.  Go ahead
     1:     // and flush the queue here so that we don't end up with a BadWindow
     1:     // error later when this happens (when the persistence timer fires
     1:     // and GetWindowPos is called)
 16529: #ifdef MOZ_X11
 78664:     XSync(GDK_DISPLAY_XDISPLAY(gdk_display_get_default()) , False);
 16529: #else
 16529:     gdk_flush ();
 16529: #endif /* MOZ_X11 */
     1: 
     1:     return NS_OK;
     1: }
     1: 
120177: bool
120177: nsWindow::CheckForRollup(gdouble aMouseX, gdouble aMouseY,
 79445:                          bool aIsWheel, bool aAlwaysRollup)
 79445: {
 79445:     bool retVal = false;
120177:     nsIRollupListener* rollupListener = GetActiveRollupListener();
120177:     nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
120177:     if (rollupWidget) {
     1:         GdkWindow *currentPopup =
     1:             (GdkWindow *)rollupWidget->GetNativeData(NS_NATIVE_WINDOW);
 54150:         if (aAlwaysRollup || !is_mouse_in_window(currentPopup, aMouseX, aMouseY)) {
 79445:             bool rollup = true;
     1:             if (aIsWheel) {
120177:                 rollup = rollupListener->ShouldRollupOnMouseWheelEvent();
 79636:                 retVal = true;
     1:             }
     1:             // if we're dealing with menus, we probably have submenus and
     1:             // we don't want to rollup if the click is in a parent menu of
     1:             // the current submenu
115367:             uint32_t popupsToRollup = UINT32_MAX;
 82030:             if (!aAlwaysRollup) {
 10352:                 nsAutoTArray<nsIWidget*, 5> widgetChain;
120177:                 uint32_t sameTypeCount = rollupListener->GetSubmenuWidgetChain(&widgetChain);
108991:                 for (uint32_t i=0; i<widgetChain.Length(); ++i) {
 10352:                     nsIWidget* widget = widgetChain[i];
     1:                     GdkWindow* currWindow =
     1:                         (GdkWindow*) widget->GetNativeData(NS_NATIVE_WINDOW);
     1:                     if (is_mouse_in_window(currWindow, aMouseX, aMouseY)) {
 42263:                       // don't roll up if the mouse event occurred within a
 42263:                       // menu of the same type. If the mouse event occurred
 29148:                       // in a menu higher than that, roll up, but pass the
 29148:                       // number of popups to Rollup so that only those of the
 29148:                       // same type close up.
 29148:                       if (i < sameTypeCount) {
 79636:                         rollup = false;
 29148:                       }
 29148:                       else {
 29148:                         popupsToRollup = sameTypeCount;
 29148:                       }
     1:                       break;
     1:                     }
     1:                 } // foreach parent menu widget
     1:             } // if rollup listener knows about menus
     1: 
     1:             // if we've determined that we should still rollup, do it.
120177:             if (rollup && rollupListener->Rollup(popupsToRollup, nullptr)) {
 79636:                 retVal = true;
     1:             }
     1:         }
     1:     } else {
120177:         nsBaseWidget::gRollupListener = nullptr;
     1:     }
     1: 
     1:     return retVal;
     1: }
     1: 
     1: /* static */
 79445: bool
     1: nsWindow::DragInProgress(void)
     1: {
 95561:     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
 95561: 
 95561:     if (!dragService)
 95561:         return false;
 95561: 
 95561:     nsCOMPtr<nsIDragSession> currentDragSession;
 95561:     dragService->GetCurrentSession(getter_AddRefs(currentDragSession));
 95561: 
106838:     return currentDragSession != nullptr;
     1: }
     1: 
 79445: static bool
     1: is_mouse_in_window (GdkWindow* aWindow, gdouble aMouseX, gdouble aMouseY)
     1: {
     1:     gint x = 0;
     1:     gint y = 0;
     1:     gint w, h;
     1: 
     1:     gint offsetX = 0;
     1:     gint offsetY = 0;
     1: 
 25258:     GdkWindow *window = aWindow;
     1: 
     1:     while (window) {
     1:         gint tmpX = 0;
     1:         gint tmpY = 0;
     1: 
     1:         gdk_window_get_position(window, &tmpX, &tmpY);
 25258:         GtkWidget *widget = get_gtk_widget_for_gdk_window(window);
     1: 
     1:         // if this is a window, compute x and y given its origin and our
     1:         // offset
     1:         if (GTK_IS_WINDOW(widget)) {
     1:             x = tmpX + offsetX;
     1:             y = tmpY + offsetY;
     1:             break;
     1:         }
     1: 
     1:         offsetX += tmpX;
     1:         offsetY += tmpY;
     1:         window = gdk_window_get_parent(window);
     1:     }
     1: 
 78664: #if defined(MOZ_WIDGET_GTK2)
 24530:     gdk_drawable_get_size(aWindow, &w, &h);
 78664: #else
 78664:     w = gdk_window_get_width(aWindow);
 78664:     h = gdk_window_get_height(aWindow);
 78664: #endif
     1: 
     1:     if (aMouseX > x && aMouseX < x + w &&
     1:         aMouseY > y && aMouseY < y + h)
 79636:         return true;
 79636: 
 79636:     return false;
     1: }
     1: 
 70016: static nsWindow *
     1: get_window_for_gtk_widget(GtkWidget *widget)
     1: {
 25258:     gpointer user_data = g_object_get_data(G_OBJECT(widget), "nsWindow");
     1: 
  3233:     return static_cast<nsWindow *>(user_data);
     1: }
     1: 
 70016: static nsWindow *
     1: get_window_for_gdk_window(GdkWindow *window)
     1: {
 25258:     gpointer user_data = g_object_get_data(G_OBJECT(window), "nsWindow");
     1: 
  3233:     return static_cast<nsWindow *>(user_data);
     1: }
     1: 
 70016: static GtkWidget *
     1: get_gtk_widget_for_gdk_window(GdkWindow *window)
     1: {
     1:     gpointer user_data = NULL;
     1:     gdk_window_get_user_data(window, &user_data);
     1: 
     1:     return GTK_WIDGET(user_data);
     1: }
     1: 
 70016: static GdkCursor *
     1: get_gtk_cursor(nsCursor aCursor)
     1: {
106838:     GdkCursor *gdkcursor = nullptr;
108991:     uint8_t newType = 0xff;
     1: 
     1:     if ((gdkcursor = gCursorCache[aCursor])) {
     1:         return gdkcursor;
     1:     }
     1: 
     1:     switch (aCursor) {
     1:     case eCursor_standard:
     1:         gdkcursor = gdk_cursor_new(GDK_LEFT_PTR);
     1:         break;
     1:     case eCursor_wait:
     1:         gdkcursor = gdk_cursor_new(GDK_WATCH);
     1:         break;
     1:     case eCursor_select:
     1:         gdkcursor = gdk_cursor_new(GDK_XTERM);
     1:         break;
     1:     case eCursor_hyperlink:
     1:         gdkcursor = gdk_cursor_new(GDK_HAND2);
     1:         break;
     1:     case eCursor_n_resize:
     1:         gdkcursor = gdk_cursor_new(GDK_TOP_SIDE);
     1:         break;
     1:     case eCursor_s_resize:
     1:         gdkcursor = gdk_cursor_new(GDK_BOTTOM_SIDE);
     1:         break;
     1:     case eCursor_w_resize:
     1:         gdkcursor = gdk_cursor_new(GDK_LEFT_SIDE);
     1:         break;
     1:     case eCursor_e_resize:
     1:         gdkcursor = gdk_cursor_new(GDK_RIGHT_SIDE);
     1:         break;
     1:     case eCursor_nw_resize:
     1:         gdkcursor = gdk_cursor_new(GDK_TOP_LEFT_CORNER);
     1:         break;
     1:     case eCursor_se_resize:
     1:         gdkcursor = gdk_cursor_new(GDK_BOTTOM_RIGHT_CORNER);
     1:         break;
     1:     case eCursor_ne_resize:
     1:         gdkcursor = gdk_cursor_new(GDK_TOP_RIGHT_CORNER);
     1:         break;
     1:     case eCursor_sw_resize:
     1:         gdkcursor = gdk_cursor_new(GDK_BOTTOM_LEFT_CORNER);
     1:         break;
     1:     case eCursor_crosshair:
     1:         gdkcursor = gdk_cursor_new(GDK_CROSSHAIR);
     1:         break;
     1:     case eCursor_move:
     1:         gdkcursor = gdk_cursor_new(GDK_FLEUR);
     1:         break;
     1:     case eCursor_help:
  5988:         gdkcursor = gdk_cursor_new(GDK_QUESTION_ARROW);
     1:         break;
     1:     case eCursor_copy: // CSS3
     1:         newType = MOZ_CURSOR_COPY;
     1:         break;
     1:     case eCursor_alias:
     1:         newType = MOZ_CURSOR_ALIAS;
     1:         break;
     1:     case eCursor_context_menu:
     1:         newType = MOZ_CURSOR_CONTEXT_MENU;
     1:         break;
     1:     case eCursor_cell:
     1:         gdkcursor = gdk_cursor_new(GDK_PLUS);
     1:         break;
     1:     case eCursor_grab:
     1:         newType = MOZ_CURSOR_HAND_GRAB;
     1:         break;
     1:     case eCursor_grabbing:
     1:         newType = MOZ_CURSOR_HAND_GRABBING;
     1:         break;
     1:     case eCursor_spinning:
     1:         newType = MOZ_CURSOR_SPINNING;
     1:         break;
     1:     case eCursor_zoom_in:
     1:         newType = MOZ_CURSOR_ZOOM_IN;
     1:         break;
     1:     case eCursor_zoom_out:
     1:         newType = MOZ_CURSOR_ZOOM_OUT;
     1:         break;
     1:     case eCursor_not_allowed:
     1:     case eCursor_no_drop:
     1:         newType = MOZ_CURSOR_NOT_ALLOWED;
     1:         break;
     1:     case eCursor_vertical_text:
     1:         newType = MOZ_CURSOR_VERTICAL_TEXT;
     1:         break;
     1:     case eCursor_all_scroll:
     1:         gdkcursor = gdk_cursor_new(GDK_FLEUR);
     1:         break;
     1:     case eCursor_nesw_resize:
     1:         newType = MOZ_CURSOR_NESW_RESIZE;
     1:         break;
     1:     case eCursor_nwse_resize:
     1:         newType = MOZ_CURSOR_NWSE_RESIZE;
     1:         break;
     1:     case eCursor_ns_resize:
 29997:     case eCursor_row_resize:
     1:         gdkcursor = gdk_cursor_new(GDK_SB_V_DOUBLE_ARROW);
     1:         break;
     1:     case eCursor_ew_resize:
 29997:     case eCursor_col_resize:
     1:         gdkcursor = gdk_cursor_new(GDK_SB_H_DOUBLE_ARROW);
     1:         break;
 10405:     case eCursor_none:
 10405:         newType = MOZ_CURSOR_NONE;
 10405:         break;
     1:     default:
     1:         NS_ASSERTION(aCursor, "Invalid cursor type");
     1:         gdkcursor = gdk_cursor_new(GDK_LEFT_PTR);
     1:         break;
     1:     }
     1: 
 84527:     // If by now we don't have a xcursor, this means we have to make a custom
 84527:     // one. First, we try creating a named cursor based on the hash of our
 84527:     // custom bitmap, as libXcursor has some magic to convert bitmapped cursors
 84527:     // to themed cursors
 84527:     if (newType != 0xFF && GtkCursors[newType].hash) {
 84527:         gdkcursor = gdk_cursor_new_from_name(gdk_display_get_default(),
 84527:                                              GtkCursors[newType].hash);
 84527:     }
 84527: 
 84527:     // If we still don't have a xcursor, we now really create a bitmap cursor
 84527:     if (newType != 0xff && !gdkcursor) {
 78664:         GdkPixbuf * cursor_pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8, 32, 32);
 78664:         if (!cursor_pixbuf)
  6790:             return NULL;
  6790:       
 78664:         guchar *data = gdk_pixbuf_get_pixels(cursor_pixbuf);
 78664:         
 78664:         // Read data from GtkCursors and compose RGBA surface from 1bit bitmap and mask
 78664:         // GtkCursors bits and mask are 32x32 monochrome bitmaps (1 bit for each pixel)
 78664:         // so it's 128 byte array (4 bytes for are one bitmap row and there are 32 rows here).
 78664:         const unsigned char *bits = GtkCursors[newType].bits;
 78664:         const unsigned char *mask_bits = GtkCursors[newType].mask_bits;
 78664:         
 78664:         for (int i = 0; i < 128; i++) {
 78664:             char bit = *bits++;
 78664:             char mask = *mask_bits++;
 78664:             for (int j = 0; j < 8; j++) {
 78664:                 unsigned char pix = ~(((bit >> j) & 0x01) * 0xff);
 78664:                 *data++ = pix;
 78664:                 *data++ = pix;
 78664:                 *data++ = pix;
 78664:                 *data++ = (((mask >> j) & 0x01) * 0xff);
 78664:             }
 78664:         }
 78664:       
 78664:         gdkcursor = gdk_cursor_new_from_pixbuf(gdk_display_get_default(), cursor_pixbuf,
     1:                                                GtkCursors[newType].hot_x,
     1:                                                GtkCursors[newType].hot_y);
     1:         
 78664:         g_object_unref(cursor_pixbuf);
     1:     }
     1: 
     1:     gCursorCache[aCursor] = gdkcursor;
     1: 
     1:     return gdkcursor;
     1: }
     1: 
     1: // gtk callbacks
     1: 
 78664: #if defined(MOZ_WIDGET_GTK2)
 70016: static gboolean
     1: expose_event_cb(GtkWidget *widget, GdkEventExpose *event)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
     1:     if (!window)
     1:         return FALSE;
     1: 
 78664:     window->OnExposeEvent(event);
     1:     return FALSE;
     1: }
 78664: #else
 78664: void
 78664: draw_window_of_widget(GtkWidget *widget, GdkWindow *aWindow, cairo_t *cr)
 78664: {
 78664:     if (gtk_cairo_should_draw_window(cr, aWindow)) {
 78664:         nsRefPtr<nsWindow> window = get_window_for_gdk_window(aWindow);
 78664:         if (!window) {
 78664:             NS_WARNING("Cannot get nsWindow from GtkWidget");
 78664:         }
 78664:         else {      
 78664:             cairo_save(cr);      
 78664:             gtk_cairo_transform_to_window(cr, widget, aWindow);  
 78664:             // TODO - window->OnExposeEvent() can destroy this or other windows,
 78664:             // do we need to handle it somehow?
 78664:             window->OnExposeEvent(cr);
 78664:             cairo_restore(cr);
 78664:         }
 78664:     }
 78664:     
 78664:     GList *children = gdk_window_get_children(aWindow);
 78664:     GList *child = children;
 78664:     while (child) {
119750:         GdkWindow *window = GDK_WINDOW(child->data);
119750:         gpointer windowWidget;
119750:         gdk_window_get_user_data(window, &windowWidget);
119750:         if (windowWidget == widget) {
119750:             draw_window_of_widget(widget, window, cr);
119750:         }
 78664:         child = g_list_next(child);
 78664:     }  
 78664:     g_list_free(children);
 78664: }
 78664: 
 78664: /* static */
 78664: gboolean
 78664: expose_event_cb(GtkWidget *widget, cairo_t *cr)
 78664: {
 78664:     draw_window_of_widget(widget, gtk_widget_get_window(widget), cr);
 78664:     return FALSE;
 78664: }
 78664: #endif //MOZ_WIDGET_GTK2
     1: 
 70016: static gboolean
     1: configure_event_cb(GtkWidget *widget,
     1:                    GdkEventConfigure *event)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
     1:     if (!window)
     1:         return FALSE;
     1: 
     1:     return window->OnConfigureEvent(widget, event);
     1: }
     1: 
 70016: static void
 28365: container_unrealize_cb (GtkWidget *widget)
 28365: {
 28365:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
 28365:     if (!window)
 28365:         return;
 28365: 
119749:     window->OnContainerUnrealize();
 28365: }
 28365: 
 70016: static void
     1: size_allocate_cb (GtkWidget *widget, GtkAllocation *allocation)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
     1:     if (!window)
     1:         return;
     1: 
119749:     window->OnSizeAllocate(allocation);
     1: }
     1: 
 70016: static gboolean
     1: delete_event_cb(GtkWidget *widget, GdkEventAny *event)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
     1:     if (!window)
     1:         return FALSE;
     1: 
119749:     window->OnDeleteEvent();
     1: 
     1:     return TRUE;
     1: }
     1: 
 70016: static gboolean
     1: enter_notify_event_cb(GtkWidget *widget,
     1:                       GdkEventCrossing *event)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
     1:     if (!window)
     1:         return TRUE;
     1: 
119749:     window->OnEnterNotifyEvent(event);
     1: 
     1:     return TRUE;
     1: }
     1: 
 70016: static gboolean
     1: leave_notify_event_cb(GtkWidget *widget,
     1:                       GdkEventCrossing *event)
     1: {
     1:     if (is_parent_grab_leave(event)) {
     1:         return TRUE;
     1:     }
     1: 
  9467:     // bug 369599: Suppress LeaveNotify events caused by pointer grabs to
  9467:     // avoid generating spurious mouse exit events.
  9467:     gint x = gint(event->x_root);
  9467:     gint y = gint(event->y_root);
  9467:     GdkDisplay* display = gtk_widget_get_display(widget);
  9467:     GdkWindow* winAtPt = gdk_display_get_window_at_pointer(display, &x, &y);
  9467:     if (winAtPt == event->window) {
  9467:         return TRUE;
  9467:     }
  9467: 
   920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
     1:     if (!window)
     1:         return TRUE;
     1: 
119749:     window->OnLeaveNotifyEvent(event);
     1: 
     1:     return TRUE;
     1: }
     1: 
 70016: static nsWindow*
  9049: GetFirstNSWindowForGDKWindow(GdkWindow *aGdkWindow)
  9049: {
  9049:     nsWindow* window;
  9049:     while (!(window = get_window_for_gdk_window(aGdkWindow))) {
  9049:         // The event has bubbled to the moz_container widget as passed into each caller's *widget parameter,
  9049:         // but its corresponding nsWindow is an ancestor of the window that we need.  Instead, look at
  9049:         // event->window and find the first ancestor nsWindow of it because event->window may be in a plugin.
  9049:         aGdkWindow = gdk_window_get_parent(aGdkWindow);
  9049:         if (!aGdkWindow) {
106838:             window = nullptr;
  9049:             break;
  9049:         }
  9049:     }
  9049:     return window;
  9049: }
  9049: 
 70016: static gboolean
     1: motion_notify_event_cb(GtkWidget *widget, GdkEventMotion *event)
     1: {
 90019:     UpdateLastInputEventTime(event);
 32815: 
  9049:     nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
     1:     if (!window)
  9049:         return FALSE;
     1: 
119749:     window->OnMotionNotifyEvent(event);
     1: 
 97566: #ifdef MOZ_PLATFORM_MAEMO
 21947:     gdk_event_request_motions(event);
 21947: #endif
     1:     return TRUE;
     1: }
     1: 
 70016: static gboolean
     1: button_press_event_cb(GtkWidget *widget, GdkEventButton *event)
     1: {
 90019:     UpdateLastInputEventTime(event);
 32815: 
  9049:     nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
     1:     if (!window)
  9049:         return FALSE;
     1: 
119749:     window->OnButtonPressEvent(event);
     1: 
     1:     return TRUE;
     1: }
     1: 
 70016: static gboolean
     1: button_release_event_cb(GtkWidget *widget, GdkEventButton *event)
     1: {
 90019:     UpdateLastInputEventTime(event);
 32815: 
  9049:     nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
     1:     if (!window)
  9049:         return FALSE;
     1: 
119749:     window->OnButtonReleaseEvent(event);
     1: 
     1:     return TRUE;
     1: }
     1: 
 70016: static gboolean
     1: focus_in_event_cb(GtkWidget *widget, GdkEventFocus *event)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
     1:     if (!window)
     1:         return FALSE;
     1: 
119749:     window->OnContainerFocusInEvent(event);
     1: 
     1:     return FALSE;
     1: }
     1: 
 70016: static gboolean
     1: focus_out_event_cb(GtkWidget *widget, GdkEventFocus *event)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
     1:     if (!window)
     1:         return FALSE;
     1: 
119749:     window->OnContainerFocusOutEvent(event);
     1: 
     1:     return FALSE;
     1: }
     1: 
 16529: #ifdef MOZ_X11
 43761: // For long-lived popup windows that don't really take focus themselves but
 43761: // may have elements that accept keyboard input when the parent window is
 43761: // active, focus is handled specially.  These windows include noautohide
 43761: // panels.  (This special handling is not necessary for temporary popups where
 43761: // the keyboard is grabbed.)
 43761: //
 43761: // Mousing over or clicking on these windows should not cause them to steal
 43761: // focus from their parent windows, so, the input field of WM_HINTS is set to
 43761: // False to request that the window manager not set the input focus to this
 43761: // window.  http://tronche.com/gui/x/icccm/sec-4.html#s-4.1.7
 43761: //
 43761: // However, these windows can still receive WM_TAKE_FOCUS messages from the
 43761: // window manager, so they can still detect when the user has indicated that
 43761: // they wish to direct keyboard input at these windows.  When the window
 43761: // manager offers focus to these windows (after a mouse over or click, for
 43761: // example), a request to make the parent window active is issued.  When the
 43761: // parent window becomes active, keyboard events will be received.
 43761: 
 70016: static GdkFilterReturn
 43761: popup_take_focus_filter(GdkXEvent *gdk_xevent,
 43761:                         GdkEvent *event,
 43761:                         gpointer data)
 43761: {
 43761:     XEvent* xevent = static_cast<XEvent*>(gdk_xevent);
 43761:     if (xevent->type != ClientMessage)
 43761:         return GDK_FILTER_CONTINUE;
 43761: 
 43761:     XClientMessageEvent& xclient = xevent->xclient;
 43761:     if (xclient.message_type != gdk_x11_get_xatom_by_name("WM_PROTOCOLS"))
 43761:         return GDK_FILTER_CONTINUE;
 43761: 
 43761:     Atom atom = xclient.data.l[0];
 43761:     if (atom != gdk_x11_get_xatom_by_name("WM_TAKE_FOCUS"))
 43761:         return GDK_FILTER_CONTINUE;
 43761: 
 43761:     guint32 timestamp = xclient.data.l[1];
 43761: 
 43761:     GtkWidget* widget = get_gtk_widget_for_gdk_window(event->any.window);
 43761:     if (!widget)
 43761:         return GDK_FILTER_CONTINUE;
 43761: 
 43761:     GtkWindow* parent = gtk_window_get_transient_for(GTK_WINDOW(widget));
 43761:     if (!parent)
 43761:         return GDK_FILTER_CONTINUE;
 43761: 
 43761:     if (gtk_window_is_active(parent))
 43761:         return GDK_FILTER_REMOVE; // leave input focus on the parent
 43761: 
 78664:     GdkWindow* parent_window = gtk_widget_get_window(GTK_WIDGET(parent));
 43761:     if (!parent_window)
 43761:         return GDK_FILTER_CONTINUE;
 43761: 
 43761:     // In case the parent has not been deconified.
 43761:     gdk_window_show_unraised(parent_window);
 43761: 
 43761:     // Request focus on the parent window.
 43761:     // Use gdk_window_focus rather than gtk_window_present to avoid
 43761:     // raising the parent window.
 43761:     gdk_window_focus(parent_window, timestamp);
 43761:     return GDK_FILTER_REMOVE;
 43761: }
 43761: 
 70016: static GdkFilterReturn
     1: plugin_window_filter_func(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
     1: {
     1:     GdkWindow  *plugin_window;
     1:     XEvent     *xevent;
 78664:     Window      xeventWindow;
     1: 
   920:     nsRefPtr<nsWindow> nswindow = (nsWindow*)data;
     1:     GdkFilterReturn return_val;
     1: 
     1:     xevent = (XEvent *)gdk_xevent;
     1:     return_val = GDK_FILTER_CONTINUE;
     1: 
     1:     switch (xevent->type)
     1:     {
     1:         case CreateNotify:
     1:         case ReparentNotify:
     1:             if (xevent->type==CreateNotify) {
 78664:                 xeventWindow = xevent->xcreatewindow.window;
     1:             }
     1:             else {
     1:                 if (xevent->xreparent.event != xevent->xreparent.parent)
     1:                     break;
 78664:                 xeventWindow = xevent->xreparent.window;
 78664:             }
 78664: #if defined(MOZ_WIDGET_GTK2)
 78664:             plugin_window = gdk_window_lookup(xeventWindow);
 78664: #else
 78664:             plugin_window = gdk_x11_window_lookup_for_display(
 78664:                                   gdk_x11_lookup_xdisplay(xevent->xcreatewindow.display), xeventWindow);
 78664: #endif        
     1:             if (plugin_window) {
 25258:                 GtkWidget *widget =
 25258:                     get_gtk_widget_for_gdk_window(plugin_window);
     1: 
 78664: // TODO GTK3
 78664: #if defined(MOZ_WIDGET_GTK2)
     1:                 if (GTK_IS_XTBIN(widget)) {
     1:                     nswindow->SetPluginType(nsWindow::PluginType_NONXEMBED);
     1:                     break;
     1:                 }
 78664:                 else 
 78664: #endif
 78664:                 if(GTK_IS_SOCKET(widget)) {
107139:                     if (!g_object_get_data(G_OBJECT(widget), "enable-xt-focus")) {
     1:                         nswindow->SetPluginType(nsWindow::PluginType_XEMBED);
     1:                         break;
     1:                     }
     1:                 }
107139:             }
     1:             nswindow->SetPluginType(nsWindow::PluginType_NONXEMBED);
     1:             return_val = GDK_FILTER_REMOVE;
     1:             break;
     1:         case EnterNotify:
     1:             nswindow->SetNonXEmbedPluginFocus();
     1:             break;
     1:         case DestroyNotify:
     1:             gdk_window_remove_filter
     1:                 ((GdkWindow*)(nswindow->GetNativeData(NS_NATIVE_WINDOW)),
     1:                  plugin_window_filter_func,
     1:                  nswindow);
     1:             // Currently we consider all plugins are non-xembed and calls
     1:             // LoseNonXEmbedPluginFocus without any checking.
     1:             nswindow->LoseNonXEmbedPluginFocus();
     1:             break;
     1:         default:
     1:             break;
     1:     }
     1:     return return_val;
     1: }
     1: 
 70016: static GdkFilterReturn
     1: plugin_client_message_filter(GdkXEvent *gdk_xevent,
     1:                              GdkEvent *event,
     1:                              gpointer data)
     1: {
     1:     XEvent    *xevent;
     1:     xevent = (XEvent *)gdk_xevent;
     1: 
     1:     GdkFilterReturn return_val;
     1:     return_val = GDK_FILTER_CONTINUE;
     1: 
     1:     if (!gPluginFocusWindow || xevent->type!=ClientMessage) {
     1:         return return_val;
     1:     }
     1: 
     1:     // When WM sends out WM_TAKE_FOCUS, gtk2 will use XSetInputFocus
     1:     // to set the focus to the focus proxy. To prevent this happen
     1:     // while the focus is on the plugin, we filter the WM_TAKE_FOCUS
     1:     // out.
     1:     if (gdk_x11_get_xatom_by_name("WM_PROTOCOLS")
     1:             != xevent->xclient.message_type) {
     1:         return return_val;
     1:     }
     1: 
     1:     if ((Atom) xevent->xclient.data.l[0] ==
     1:             gdk_x11_get_xatom_by_name("WM_TAKE_FOCUS")) {
     1:         // block it from gtk2.0 focus proxy
     1:         return_val = GDK_FILTER_REMOVE;
     1:     }
     1: 
     1:     return return_val;
     1: }
 16529: #endif /* MOZ_X11 */
     1: 
 70016: static gboolean
     1: key_press_event_cb(GtkWidget *widget, GdkEventKey *event)
     1: {
     1:     LOG(("key_press_event_cb\n"));
 32815: 
 90019:     UpdateLastInputEventTime(event);
 32815: 
     1:     // find the window with focus and dispatch this event to that widget
     1:     nsWindow *window = get_window_for_gtk_widget(widget);
     1:     if (!window)
     1:         return FALSE;
     1: 
   920:     nsRefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
     1: 
 22802: #ifdef MOZ_X11
 22802:     // Keyboard repeat can cause key press events to queue up when there are
 22802:     // slow event handlers (bug 301029).  Throttle these events by removing
 22802:     // consecutive pending duplicate KeyPress events to the same window.
 22802:     // We use the event time of the last one.
 22802:     // Note: GDK calls XkbSetDetectableAutorepeat so that KeyRelease events
 22802:     // are generated only when the key is physically released.
 22802: #define NS_GDKEVENT_MATCH_MASK 0x1FFF /* GDK_SHIFT_MASK .. GDK_BUTTON5_MASK */
 22802:     GdkDisplay* gdkDisplay = gtk_widget_get_display(widget);
 22802:     Display* dpy = GDK_DISPLAY_XDISPLAY(gdkDisplay);
 22802:     while (XPending(dpy)) {
 22802:         XEvent next_event;
 22802:         XPeekEvent(dpy, &next_event);
 22802:         GdkWindow* nextGdkWindow =
 78664:             gdk_x11_window_lookup_for_display(gdkDisplay, next_event.xany.window);
 22802:         if (nextGdkWindow != event->window ||
 22802:             next_event.type != KeyPress ||
 22802:             next_event.xkey.keycode != event->hardware_keycode ||
 22802:             next_event.xkey.state != (event->state & NS_GDKEVENT_MATCH_MASK)) {
 22802:             break;
 22802:         }
 22802:         XNextEvent(dpy, &next_event);
 22802:         event->time = next_event.xkey.time;
 22802:     }
 22802: #endif
 22802: 
119749:     return focusWindow->OnKeyPressEvent(event);
     1: }
     1: 
 70016: static gboolean
     1: key_release_event_cb(GtkWidget *widget, GdkEventKey *event)
     1: {
     1:     LOG(("key_release_event_cb\n"));
 32815: 
 90019:     UpdateLastInputEventTime(event);
 32815: 
     1:     // find the window with focus and dispatch this event to that widget
     1:     nsWindow *window = get_window_for_gtk_widget(widget);
     1:     if (!window)
     1:         return FALSE;
     1: 
   920:     nsRefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
     1: 
119749:     return focusWindow->OnKeyReleaseEvent(event);
     1: }
     1: 
 70016: static gboolean
     1: scroll_event_cb(GtkWidget *widget, GdkEventScroll *event)
     1: {
  9049:     nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
  9049:     if (!window)
     1:         return FALSE;
     1: 
119749:     window->OnScrollEvent(event);
     1: 
     1:     return TRUE;
     1: }
     1: 
 70016: static gboolean
     1: visibility_notify_event_cb (GtkWidget *widget, GdkEventVisibility *event)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
     1:     if (!window)
     1:         return FALSE;
     1: 
119749:     window->OnVisibilityNotifyEvent(event);
     1: 
     1:     return TRUE;
     1: }
     1: 
 34456: static void
 34456: hierarchy_changed_cb (GtkWidget *widget,
 34456:                       GtkWidget *previous_toplevel)
 34456: {
 34456:     GtkWidget *toplevel = gtk_widget_get_toplevel(widget);
 34456:     GdkWindowState old_window_state = GDK_WINDOW_STATE_WITHDRAWN;
 34456:     GdkEventWindowState event;
 34456: 
 34456:     event.new_window_state = GDK_WINDOW_STATE_WITHDRAWN;
 34456: 
 34456:     if (GTK_IS_WINDOW(previous_toplevel)) {
 34456:         g_signal_handlers_disconnect_by_func(previous_toplevel,
 34456:                                              FuncToGpointer(window_state_event_cb),
 34456:                                              widget);
 78664:         GdkWindow *win = gtk_widget_get_window(previous_toplevel);
 78664:         if (win) {
 78664:             old_window_state = gdk_window_get_state(win);
 34456:         }
 34456:     }
 34456: 
 34456:     if (GTK_IS_WINDOW(toplevel)) {
 34456:         g_signal_connect_swapped(toplevel, "window-state-event",
 34456:                                  G_CALLBACK(window_state_event_cb), widget);
 78664:         GdkWindow *win = gtk_widget_get_window(toplevel);
 78664:         if (win) {
 78664:             event.new_window_state = gdk_window_get_state(win);
 34456:         }
 34456:     }
 34456: 
 34456:     event.changed_mask = static_cast<GdkWindowState>
 34456:         (old_window_state ^ event.new_window_state);
 34456: 
 34456:     if (event.changed_mask) {
 34456:         event.type = GDK_WINDOW_STATE;
 34456:         event.window = NULL;
 34456:         event.send_event = TRUE;
 34456:         window_state_event_cb(widget, &event);
 34456:     }
 34456: }
 34456: 
 70016: static gboolean
     1: window_state_event_cb (GtkWidget *widget, GdkEventWindowState *event)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
     1:     if (!window)
     1:         return FALSE;
     1: 
     1:     window->OnWindowStateEvent(widget, event);
     1: 
     1:     return FALSE;
     1: }
     1: 
 70016: static void
     1: theme_changed_cb (GtkSettings *settings, GParamSpec *pspec, nsWindow *data)
     1: {
   920:     nsRefPtr<nsWindow> window = data;
   920:     window->ThemeChanged();
     1: }
     1: 
     1: //////////////////////////////////////////////////////////////////////
     1: // These are all of our drag and drop operations
     1: 
     1: void
 18445: nsWindow::InitDragEvent(nsDragEvent &aEvent)
     1: {
     1:     // set the keyboard modifiers
 90661:     guint modifierState = KeymapWrapper::GetCurrentModifierState();
 90661:     KeymapWrapper::InitInputEvent(aEvent, modifierState);
     1: }
     1: 
 70016: static gboolean
     1: drag_motion_event_cb(GtkWidget *aWidget,
     1:                      GdkDragContext *aDragContext,
     1:                      gint aX,
     1:                      gint aY,
     1:                      guint aTime,
     1:                      gpointer aData)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
     1:     if (!window)
     1:         return FALSE;
     1: 
 97331:     // figure out which internal widget this drag motion actually happened on
 97331:     nscoord retx = 0;
 97331:     nscoord rety = 0;
 97331: 
 97331:     GdkWindow *innerWindow =
 97331:         get_inner_gdk_window(gtk_widget_get_window(aWidget), aX, aY,
 97331:                              &retx, &rety);
 97331:     nsRefPtr<nsWindow> innerMostWindow = get_window_for_gdk_window(innerWindow);
 97331: 
 97331:     if (!innerMostWindow) {
 97331:         innerMostWindow = window;
 97331:     }
 97331: 
 97331:     LOGDRAG(("nsWindow drag-motion signal for %p\n", (void*)innerMostWindow));
 97331: 
 97331:     return nsDragService::GetInstance()->
 97331:         ScheduleMotionEvent(innerMostWindow, aDragContext,
121830:                             nsIntPoint(retx, rety), aTime);
     1: }
 70016: 
 70016: static void
     1: drag_leave_event_cb(GtkWidget *aWidget,
     1:                     GdkDragContext *aDragContext,
     1:                     guint aTime,
     1:                     gpointer aData)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
     1:     if (!window)
     1:         return;
     1: 
 97331:     nsDragService *dragService = nsDragService::GetInstance();
 97331: 
 97331:     nsWindow *mostRecentDragWindow = dragService->GetMostRecentDestWindow();
 97331:     if (!mostRecentDragWindow) {
 97336:         // This can happen when the target will not accept a drop.  A GTK drag
 97336:         // source sends the leave message to the destination before the
 97336:         // drag-failed signal on the source widget, but the leave message goes
 97336:         // via the X server, and so doesn't get processed at least until the
 97336:         // event loop runs again.
 97331:         return;
 97331:     }
 97331: 
 97331:     GtkWidget *mozContainer = mostRecentDragWindow->GetMozContainerWidget();
 97331:     if (aWidget != mozContainer)
 97331:     {
 97331:         // When the drag moves between widgets, GTK can send leave signal for
 97331:         // the old widget after the motion or drop signal for the new widget.
 97331:         // We'll send the leave event when the motion or drop event is run.
 97331:         return;
 97331:     }
 97331: 
 97331:     LOGDRAG(("nsWindow drag-leave signal for %p\n",
 97331:              (void*)mostRecentDragWindow));
 97331: 
 97331:     dragService->ScheduleLeaveEvent();
     1: }
     1: 
     1: 
 70016: static gboolean
     1: drag_drop_event_cb(GtkWidget *aWidget,
     1:                    GdkDragContext *aDragContext,
     1:                    gint aX,
     1:                    gint aY,
     1:                    guint aTime,
 70072:                    gpointer aData)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
     1:     if (!window)
     1:         return FALSE;
     1: 
 97331:     // figure out which internal widget this drag motion actually happened on
 97331:     nscoord retx = 0;
 97331:     nscoord rety = 0;
 97331: 
 97331:     GdkWindow *innerWindow =
 97331:         get_inner_gdk_window(gtk_widget_get_window(aWidget), aX, aY,
 97331:                              &retx, &rety);
 97331:     nsRefPtr<nsWindow> innerMostWindow = get_window_for_gdk_window(innerWindow);
 97331: 
 97331:     if (!innerMostWindow) {
 97331:         innerMostWindow = window;
 97331:     }
 97331: 
 97331:     LOGDRAG(("nsWindow drag-drop signal for %p\n", (void*)innerMostWindow));
 97331: 
 97331:     return nsDragService::GetInstance()->
 97331:         ScheduleDropEvent(innerMostWindow, aDragContext,
121830:                           nsIntPoint(retx, rety), aTime);
     1: }
     1: 
 70016: static void
     1: drag_data_received_event_cb(GtkWidget *aWidget,
     1:                             GdkDragContext *aDragContext,
     1:                             gint aX,
     1:                             gint aY,
     1:                             GtkSelectionData  *aSelectionData,
     1:                             guint aInfo,
     1:                             guint aTime,
     1:                             gpointer aData)
     1: {
   920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
     1:     if (!window)
     1:         return;
     1: 
     1:     window->OnDragDataReceivedEvent(aWidget,
     1:                                     aDragContext,
     1:                                     aX, aY,
     1:                                     aSelectionData,
     1:                                     aInfo, aTime, aData);
     1: }
     1: 
 70016: static nsresult
     1: initialize_prefs(void)
     1: {
 70976:     gRaiseWindows =
 79445:         Preferences::GetBool("mozilla.widget.raise-on-setfocus", true);
 19352: 
     1:     return NS_OK;
     1: }
     1: 
 70016: static GdkWindow *
     1: get_inner_gdk_window (GdkWindow *aWindow,
     1:                       gint x, gint y,
     1:                       gint *retx, gint *rety)
     1: {
 78664:     gint cx, cy, cw, ch;
     1:     GList *children = gdk_window_peek_children(aWindow);
 69741:     for (GList *child = g_list_last(children);
 69741:          child;
 69741:          child = g_list_previous(child)) {
     1:         GdkWindow *childWindow = (GdkWindow *) child->data;
 61174:         if (get_window_for_gdk_window(childWindow)) {
 78664: #if defined(MOZ_WIDGET_GTK2)
 78664:             gdk_window_get_geometry(childWindow, &cx, &cy, &cw, &ch, NULL);
 78664: #else
 78664:             gdk_window_get_geometry(childWindow, &cx, &cy, &cw, &ch);
 78664: #endif
     1:             if ((cx < x) && (x < (cx + cw)) &&
     1:                 (cy < y) && (y < (cy + ch)) &&
     1:                 gdk_window_is_visible(childWindow)) {
     1:                 return get_inner_gdk_window(childWindow,
     1:                                             x - cx, y - cy,
     1:                                             retx, rety);
     1:             }
     1:         }
     1:     }
     1:     *retx = x;
     1:     *rety = y;
     1:     return aWindow;
     1: }
     1: 
 79445: static inline bool
     1: is_context_menu_key(const nsKeyEvent& aKeyEvent)
     1: {
 96893:     return ((aKeyEvent.keyCode == NS_VK_F10 && aKeyEvent.IsShift() &&
 96893:              !aKeyEvent.IsControl() && !aKeyEvent.IsMeta() &&
 96893:              !aKeyEvent.IsAlt()) ||
 96893:             (aKeyEvent.keyCode == NS_VK_CONTEXT_MENU && !aKeyEvent.IsShift() &&
 96893:              !aKeyEvent.IsControl() && !aKeyEvent.IsMeta() &&
 96893:              !aKeyEvent.IsAlt()));
     1: }
     1: 
 70016: static int
     1: is_parent_ungrab_enter(GdkEventCrossing *aEvent)
     1: {
     1:     return (GDK_CROSSING_UNGRAB == aEvent->mode) &&
     1:         ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
     1:          (GDK_NOTIFY_VIRTUAL == aEvent->detail));
     1: 
     1: }
     1: 
 70016: static int
     1: is_parent_grab_leave(GdkEventCrossing *aEvent)
     1: {
     1:     return (GDK_CROSSING_GRAB == aEvent->mode) &&
     1:         ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
     1:             (GDK_NOTIFY_VIRTUAL == aEvent->detail));
     1: }
     1: 
     1: #ifdef ACCESSIBILITY
     1: void
     1: nsWindow::CreateRootAccessible()
     1: {
     1:     if (mIsTopLevel && !mRootAccessible) {
 70987:         LOG(("nsWindow:: Create Toplevel Accessibility\n"));
108454:         mRootAccessible = GetAccessible();
108454:     }
 42313: }
 42313: 
 42313: void
108991: nsWindow::DispatchEventToRootAccessible(uint32_t aEventType)
 42313: {
 86928:     if (!a11y::ShouldA11yBeEnabled()) {
 42313:         return;
 85096:     }
 42313: 
 42313:     nsCOMPtr<nsIAccessibilityService> accService =
 42313:         do_GetService("@mozilla.org/accessibilityService;1");
 42313:     if (!accService) {
 42313:         return;
 42313:     }
 42313: 
 54519:     // Get the root document accessible and fire event to it.
122283:     a11y::Accessible* acc = GetAccessible();
 54519:     if (acc) {
 54519:         accService->FireAccessibleEvent(aEventType, acc);
 54519:     }
     1: }
     1: 
     1: void
 20621: nsWindow::DispatchActivateEventAccessible(void)
     1: {
 42313:     DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_ACTIVATE);
     1: }
     1: 
     1: void
 20621: nsWindow::DispatchDeactivateEventAccessible(void)
 20621: {
 42313:     DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_DEACTIVATE);
     1: }
 20621: 
 64019: void
 64019: nsWindow::DispatchMaximizeEventAccessible(void)
 64019: {
 64019:     DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_MAXIMIZE);
 64019: }
 64019: 
 64019: void
 64019: nsWindow::DispatchMinimizeEventAccessible(void)
 64019: {
 64019:     DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_MINIMIZE);
 64019: }
 64019: 
 64019: void
 64019: nsWindow::DispatchRestoreEventAccessible(void)
 64019: {
 64019:     DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_RESTORE);
 64019: }
 64019: 
     1: #endif /* #ifdef ACCESSIBILITY */
     1: 
     1: // nsChildWindow class
     1: 
     1: nsChildWindow::nsChildWindow()
     1: {
     1: }
     1: 
     1: nsChildWindow::~nsChildWindow()
     1: {
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWindow::ResetInputState()
     1: {
 39627:     return mIMModule ? mIMModule->ResetInputState(this) : NS_OK;
     1: }
     1: 
 82841: NS_IMETHODIMP_(void)
 82841: nsWindow::SetInputContext(const InputContext& aContext,
 82841:                           const InputContextAction& aAction)
 58019: {
 39627:     if (!mIMModule) {
 82841:         return;
 82841:     }
 82841:     mIMModule->SetInputContext(this, &aContext, &aAction);
 82841: }
 82841: 
 82841: NS_IMETHODIMP_(InputContext)
 82841: nsWindow::GetInputContext()
 82841: {
 82841:   InputContext context;
 82841:   if (!mIMModule) {
 82842:       context.mIMEState.mEnabled = IMEState::DISABLED;
 82842:       context.mIMEState.mOpen = IMEState::OPEN_STATE_NOT_SUPPORTED;
120231:       // If IME context isn't available on this widget, we should set |this|
120231:       // instead of nullptr since nullptr means that the platform has only one
120231:       // context per process.
120231:       context.mNativeIMEContext = this;
 82841:   } else {
 82841:       context = mIMModule->GetInputContext();
120231:       context.mNativeIMEContext = mIMModule;
 82841:   }
 82841:   return context;
 39627: }
     1: 
     1: NS_IMETHODIMP
     1: nsWindow::CancelIMEComposition()
     1: {
 39627:     return mIMModule ? mIMModule->CancelIMEComposition(this) : NS_OK;
 39627: }
 39627: 
 39627: NS_IMETHODIMP
 79445: nsWindow::OnIMEFocusChange(bool aFocus)
 39627: {
 39627:     if (mIMModule) {
 39627:       mIMModule->OnFocusChangeInGecko(aFocus);
 39627:     }
121727:     return NS_OK;
     1: }
     1: 
  2475: NS_IMETHODIMP
108991: nsWindow::GetToggledKeyState(uint32_t aKeyCode, bool* aLEDState)
  2475: {
  2475:     NS_ENSURE_ARG_POINTER(aLEDState);
  2475: 
 90660:     KeymapWrapper::Modifiers modifier;
  2475:     switch (aKeyCode) {
 90660:         case NS_VK_CAPS_LOCK:   modifier = KeymapWrapper::CAPS_LOCK;   break;
 90660:         case NS_VK_NUM_LOCK:    modifier = KeymapWrapper::NUM_LOCK;    break;
 90660:         case NS_VK_SCROLL_LOCK: modifier = KeymapWrapper::SCROLL_LOCK; break;
 90660:         default: return NS_ERROR_INVALID_ARG;
 90660:     }
 90660: 
 90660:     *aLEDState =
 90660:         KeymapWrapper::AreModifiersCurrentlyActive(modifier);
  2475:     return NS_OK;
  2475: }
  2475: 
 78664: #if defined(MOZ_X11) && defined(MOZ_WIDGET_GTK2)
 15409: /* static */ already_AddRefed<gfxASurface>
 15409: nsWindow::GetSurfaceForGdkDrawable(GdkDrawable* aDrawable,
 23738:                                    const nsIntSize& aSize)
 15409: {
 15409:     GdkVisual* visual = gdk_drawable_get_visual(aDrawable);
 47113:     Screen* xScreen =
 47113:         gdk_x11_screen_get_xscreen(gdk_drawable_get_screen(aDrawable));
 47113:     Display* xDisplay = DisplayOfScreen(xScreen);
 15409:     Drawable xDrawable = gdk_x11_drawable_get_xid(aDrawable);
 15409: 
106838:     gfxASurface* result = nullptr;
 19352: 
 19352:     if (visual) {
 19352:         Visual* xVisual = gdk_x11_visual_get_xvisual(visual);
 19352: 
 19352:         result = new gfxXlibSurface(xDisplay, xDrawable, xVisual,
 15409:                                     gfxIntSize(aSize.width, aSize.height));
 19352:     } else {
 19352:         // no visual? we must be using an xrender format.  Find a format
 19352:         // for this depth.
 19352:         XRenderPictFormat *pf = NULL;
 19352:         switch (gdk_drawable_get_depth(aDrawable)) {
 19352:             case 32:
 19352:                 pf = XRenderFindStandardFormat(xDisplay, PictStandardARGB32);
 19352:                 break;
 19352:             case 24:
 19352:                 pf = XRenderFindStandardFormat(xDisplay, PictStandardRGB24);
 19352:                 break;
 19352:             default:
 19352:                 NS_ERROR("Don't know how to handle the given depth!");
 19352:                 break;
 19352:         }
 19352: 
 47113:         result = new gfxXlibSurface(xScreen, xDrawable, pf,
 19352:                                     gfxIntSize(aSize.width, aSize.height));
 19352:     }
 19352: 
 15409:     NS_IF_ADDREF(result);
 15409:     return result;
 15409: }
 16529: #endif
 15409: 
     1: // return the gfxASurface for rendering to this widget
     1: gfxASurface*
 78664: #if defined(MOZ_WIDGET_GTK2)
     1: nsWindow::GetThebesSurface()
 78664: #else
 78664: nsWindow::GetThebesSurface(cairo_t *cr)
 78664: #endif
     1: {
 34746:     if (!mGdkWindow)
106838:         return nullptr;
 34746: 
 78664: #if !defined(MOZ_WIDGET_GTK2)
 78664:     cairo_surface_t *surf = cairo_get_target(cr);
 78664:     if (cairo_surface_status(surf) != CAIRO_STATUS_SUCCESS) {
 78664:       NS_NOTREACHED("Missing cairo target?");
 78664:       return NULL;
 78664:     }
 78664: #endif // MOZ_WIDGET_GTK2
 13055: 
 16529: #ifdef MOZ_X11
     1:     gint width, height;
 78664: 
 78664: #if defined(MOZ_WIDGET_GTK2)
 78664:     gdk_drawable_get_size(GDK_DRAWABLE(mGdkWindow), &width, &height);
 78664: #else
 78664:     width = gdk_window_get_width(mGdkWindow);
 78664:     height = gdk_window_get_height(mGdkWindow);
 78664: #endif
 78664: 
 13055:     // Owen Taylor says this is the right thing to do!
 71173:     width = NS_MIN(32767, width);
 71173:     height = NS_MIN(32767, height);
 54594:     gfxIntSize size(width, height);
 78664: 
 78664:     GdkVisual *gdkVisual = gdk_window_get_visual(mGdkWindow);
 78664:     Visual* visual = gdk_x11_visual_get_xvisual(gdkVisual);
 54594: 
 54594: #  ifdef MOZ_HAVE_SHMIMAGE
 79445:     bool usingShm = false;
 56628:     if (nsShmImage::UseShm()) {
 54594:         // EnsureShmImage() is a dangerous interface, but we guarantee
 54594:         // that the thebes surface and the shmimage have the same
 54594:         // lifetime
 56628:         mThebesSurface =
 56628:             nsShmImage::EnsureShmImage(size,
 78664:                                        visual, gdk_visual_get_depth(gdkVisual),
 54594:                                        mShmImage);
106838:         usingShm = mThebesSurface != nullptr;
 54594:     }
 54594:     if (!usingShm)
 54594: #  endif  // MOZ_HAVE_SHMIMAGE
 13055: 
 78664: #if defined(MOZ_WIDGET_GTK2)
     1:     mThebesSurface = new gfxXlibSurface
 78664:         (GDK_WINDOW_XDISPLAY(mGdkWindow),
 78664:          gdk_x11_window_get_xid(mGdkWindow),
 54594:          visual,
 54594:          size);
 78664: #else
 78664: #if MOZ_TREE_CAIRO
 78664: #error "cairo-gtk3 target must be built with --enable-system-cairo"
 78664: #else
 78664:     mThebesSurface = gfxASurface::Wrap(surf);
 78664: #endif
 78664: #endif
 78664: 
 16529: #endif
  7639: 
  7639:     // if the surface creation is reporting an error, then
  7639:     // we don't have a surface to give back
 16529:     if (mThebesSurface && mThebesSurface->CairoStatus() != 0) {
106838:         mThebesSurface = nullptr;
 13055:     }
     1: 
     1:     return mThebesSurface;
     1: }
  8892: 
 47857: // Code shared begin BeginMoveDrag and BeginResizeDrag
 79445: bool
 47857: nsWindow::GetDragInfo(nsMouseEvent* aMouseEvent,
 47857:                       GdkWindow** aWindow, gint* aButton,
 47857:                       gint* aRootX, gint* aRootY)
 47857: {
 47857:     if (aMouseEvent->button != nsMouseEvent::eLeftButton) {
 47857:         // we can only begin a move drag with the left mouse button
 79636:         return false;
 47857:     }
 47857:     *aButton = 1;
 47857: 
 47857:     // get the gdk window for this widget
 47857:     GdkWindow* gdk_window = mGdkWindow;
 47857:     if (!gdk_window) {
 79636:         return false;
 47857:     }
 47857:     NS_ABORT_IF_FALSE(GDK_IS_WINDOW(gdk_window), "must really be window");
 47857: 
 47857:     // find the top-level window
 47857:     gdk_window = gdk_window_get_toplevel(gdk_window);
 47857:     NS_ABORT_IF_FALSE(gdk_window,
 47857:                       "gdk_window_get_toplevel should not return null");
 47857:     *aWindow = gdk_window;
 47857: 
 47857:     if (!aMouseEvent->widget) {
 79636:         return false;
 47857:     }
 47857: 
 47857:     // FIXME: It would be nice to have the widget position at the time
 47857:     // of the event, but it's relatively unlikely that the widget has
 47857:     // moved since the mousedown.  (On the other hand, it's quite likely
 47857:     // that the mouse has moved, which is why we use the mouse position
 47857:     // from the event.)
 47857:     nsIntPoint offset = aMouseEvent->widget->WidgetToScreenOffset();
 47857:     *aRootX = aMouseEvent->refPoint.x + offset.x;
 47857:     *aRootY = aMouseEvent->refPoint.y + offset.y;
 47857: 
 79636:     return true;
 47857: }
 47857: 
 47857: NS_IMETHODIMP
 47857: nsWindow::BeginMoveDrag(nsMouseEvent* aEvent)
 47857: {
 47857:     NS_ABORT_IF_FALSE(aEvent, "must have event");
 47857:     NS_ABORT_IF_FALSE(aEvent->eventStructType == NS_MOUSE_EVENT,
 47857:                       "event must have correct struct type");
 47857: 
 47857:     GdkWindow *gdk_window;
 47857:     gint button, screenX, screenY;
 47857:     if (!GetDragInfo(aEvent, &gdk_window, &button, &screenX, &screenY)) {
 47857:         return NS_ERROR_FAILURE;
 47857:     }
 47857: 
 47857:     // tell the window manager to start the move
 47857:     gdk_window_begin_move_drag(gdk_window, button, screenX, screenY,
 47857:                                aEvent->time);
 47857: 
 47857:     return NS_OK;
 47857: }
 47857: 
  8892: NS_IMETHODIMP
108991: nsWindow::BeginResizeDrag(nsGUIEvent* aEvent, int32_t aHorizontal, int32_t aVertical)
  8892: {
  8892:     NS_ENSURE_ARG_POINTER(aEvent);
  8892: 
  8892:     if (aEvent->eventStructType != NS_MOUSE_EVENT) {
  8892:         // you can only begin a resize drag with a mouse event
  8892:         return NS_ERROR_INVALID_ARG;
  8892:     }
  8892: 
  8892:     nsMouseEvent* mouse_event = static_cast<nsMouseEvent*>(aEvent);
  8892: 
 47857:     GdkWindow *gdk_window;
 47857:     gint button, screenX, screenY;
 47857:     if (!GetDragInfo(mouse_event, &gdk_window, &button, &screenX, &screenY)) {
 47857:         return NS_ERROR_FAILURE;
  8892:     }
  8892: 
  8892:     // work out what GdkWindowEdge we're talking about
  8892:     GdkWindowEdge window_edge;
  8892:     if (aVertical < 0) {
  8892:         if (aHorizontal < 0) {
  8892:             window_edge = GDK_WINDOW_EDGE_NORTH_WEST;
  8892:         } else if (aHorizontal == 0) {
  8892:             window_edge = GDK_WINDOW_EDGE_NORTH;
  8892:         } else {
  8892:             window_edge = GDK_WINDOW_EDGE_NORTH_EAST;
  8892:         }
  8892:     } else if (aVertical == 0) {
  8892:         if (aHorizontal < 0) {
  8892:             window_edge = GDK_WINDOW_EDGE_WEST;
  8892:         } else if (aHorizontal == 0) {
  8892:             return NS_ERROR_INVALID_ARG;
  8892:         } else {
  8892:             window_edge = GDK_WINDOW_EDGE_EAST;
  8892:         }
  8892:     } else {
  8892:         if (aHorizontal < 0) {
  8892:             window_edge = GDK_WINDOW_EDGE_SOUTH_WEST;
  8892:         } else if (aHorizontal == 0) {
  8892:             window_edge = GDK_WINDOW_EDGE_SOUTH;
  8892:         } else {
  8892:             window_edge = GDK_WINDOW_EDGE_SOUTH_EAST;
  8892:         }
  8892:     }
  8892: 
  8892:     // tell the window manager to start the resize
 47857:     gdk_window_begin_resize_drag(gdk_window, window_edge, button,
  8892:                                  screenX, screenY, aEvent->time);
  8892: 
  8892:     return NS_OK;
  8892: }
 61184: 
114750: nsIWidget::LayerManager*
114750: nsWindow::GetLayerManager(PLayersChild* aShadowManager,
114750:                           LayersBackend aBackendHint,
114750:                           LayerManagerPersistence aPersistence,
114750:                           bool* aAllowRetaining)
114750: {
114750:     if (!mLayerManager && eTransparencyTransparent == GetTransparencyMode()) {
114750:         mLayerManager = CreateBasicLayerManager();
114750:     }
114750: 
114750:     return nsBaseWidget::GetLayerManager(aShadowManager, aBackendHint,
114750:                                          aPersistence, aAllowRetaining);
114750: }
114750: 
 61184: void
 61184: nsWindow::ClearCachedResources()
 61184: {
 61184:     if (mLayerManager &&
105710:         mLayerManager->GetBackendType() == mozilla::layers::LAYERS_BASIC) {
106914:         static_cast<mozilla::layers::BasicLayerManager*> (mLayerManager.get())->
 61184:             ClearCachedResources();
 61184:     }
 61184: 
 61184:     GList* children = gdk_window_peek_children(mGdkWindow);
 61184:     for (GList* list = children; list; list = list->next) {
 61184:         nsWindow* window = get_window_for_gdk_window(GDK_WINDOW(list->data));
 61184:         if (window) {
 61184:             window->ClearCachedResources();
 61184:         }
 61184:     }
 61184: }
 95203: 
 95203: nsresult
 95203: nsWindow::SynthesizeNativeMouseEvent(nsIntPoint aPoint,
108991:                                      uint32_t aNativeMessage,
108991:                                      uint32_t aModifierFlags)
 95203: {
 95203:   if (!mGdkWindow) {
 95203:     return NS_OK;
 95203:   }
 95203: 
 95203:   GdkDisplay* display = gdk_window_get_display(mGdkWindow);
 95203:   GdkScreen* screen = gdk_window_get_screen(mGdkWindow);
 95203:   gdk_display_warp_pointer(display, screen, aPoint.x, aPoint.y);
 95203: 
 95203:   return NS_OK;
 95203: }
