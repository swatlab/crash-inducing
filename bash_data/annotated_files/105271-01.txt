 98753: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 87729: /* vim: set sw=2 ts=2 et tw=80 : */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 87729: 
 87729: #include "CompositorParent.h"
 91562: #include "RenderTrace.h"
 87729: #include "ShadowLayersParent.h"
 98068: #include "BasicLayers.h"
 87729: #include "LayerManagerOGL.h"
 87729: #include "nsIWidget.h"
 92853: #include "nsGkAtoms.h"
 92950: #include "RenderTrace.h"
 87729: 
 92781: #if defined(MOZ_WIDGET_ANDROID)
 92781: #include "AndroidBridge.h"
 92814: #include <android/log.h>
 92781: #endif
 87729: 
104622: #include <map>
104622: 
 93083: using base::Thread;
 93083: 
 87729: namespace mozilla {
 87729: namespace layers {
 87729: 
104549: static Thread* sCompositorThread = nsnull;
105271: // manual reference count of the compositor thread.
105271: static int sCompositorThreadRefCount = 0;
105271: static MessageLoop* sMainLoop = nsnull;
105271: 
105271: static void DeferredDeleteCompositorParent(CompositorParent* aNowReadyToDie)
105271: {
105271:   aNowReadyToDie->Release();
105271: }
105271: 
105271: static void DeleteCompositorThread()
105271: {
105271:   if (NS_IsMainThread()) {
105271:     delete sCompositorThread;  
105271:     sCompositorThread = nsnull;
105271:   } else {
105271:     sMainLoop->PostTask(FROM_HERE, NewRunnableFunction(&DeleteCompositorThread));
105271:   }
105271: }
105271: 
105271: static void ReleaseCompositorThread()
105271: {
105271:   if(--sCompositorThreadRefCount == 0) {
105271:     DeleteCompositorThread();
105271:   }
105271: }
105271: 
104549: 
104549: void CompositorParent::StartUp()
104549: {
104622:   CreateCompositorMap();
104549:   CreateThread();
105271:   sMainLoop = MessageLoop::current();
104549: }
104549: 
104549: void CompositorParent::ShutDown()
104549: {
104549:   DestroyThread();
104622:   DestroyCompositorMap();
104549: }
104549: 
104549: bool CompositorParent::CreateThread()
104549: {
104549:   NS_ASSERTION(NS_IsMainThread(), "Should be on the main Thread!");
104549:   if (sCompositorThread) {
104549:     return true;
104549:   }
105271:   sCompositorThreadRefCount = 1;
104549:   sCompositorThread = new Thread("Compositor");
104549:   if (!sCompositorThread->Start()) {
104549:     delete sCompositorThread;
104549:     sCompositorThread = nsnull;
104549:     return false;
104549:   }
104549:   return true;
104549: }
104549: 
104549: void CompositorParent::DestroyThread()
104549: {
104549:   NS_ASSERTION(NS_IsMainThread(), "Should be on the main Thread!");
105271:   ReleaseCompositorThread();
104549: }
104549: 
104549: MessageLoop* CompositorParent::CompositorLoop()
104549: {
104549:   return sCompositorThread ? sCompositorThread->message_loop() : nsnull;
104549: }
104549: 
104549: CompositorParent::CompositorParent(nsIWidget* aWidget,
104549:                                    bool aRenderToEGLSurface,
 98069:                                    int aSurfaceWidth, int aSurfaceHeight)
 96883:   : mWidget(aWidget)
 92818:   , mCurrentCompositeTask(NULL)
 92837:   , mPaused(false)
 97355:   , mXScale(1.0)
 97355:   , mYScale(1.0)
 93058:   , mIsFirstPaint(false)
 93545:   , mLayersUpdated(false)
 98069:   , mRenderToEGLSurface(aRenderToEGLSurface)
 98069:   , mEGLSurfaceSize(aSurfaceWidth, aSurfaceHeight)
 98753:   , mPauseCompositionMonitor("PauseCompositionMonitor")
 99700:   , mResumeCompositionMonitor("ResumeCompositionMonitor")
 87729: {
104549:   NS_ABORT_IF_FALSE(sCompositorThread != nsnull, 
104549:                     "The compositor thread must be Initialized before instanciating a COmpositorParent.");
 87729:   MOZ_COUNT_CTOR(CompositorParent);
104622:   mCompositorID = 0;
104622:   // FIXME: This holds on the the fact that right now the only thing that 
104622:   // can destroy this instance is initialized on the compositor thread after 
104622:   // this task has been processed.
104622:   CompositorLoop()->PostTask(FROM_HERE, NewRunnableFunction(&AddCompositor, 
104622:                                                           this, &mCompositorID));
105271:   ++sCompositorThreadRefCount;
 87729: }
 87729: 
 96883: PlatformThreadId
 96883: CompositorParent::CompositorThreadID()
 96883: {
104549:   return sCompositorThread->thread_id();
 96883: }
 96883: 
 87729: CompositorParent::~CompositorParent()
 87729: {
 87729:   MOZ_COUNT_DTOR(CompositorParent);
105271:   ReleaseCompositorThread();
 87729: }
 87729: 
 87729: void
 87729: CompositorParent::Destroy()
 87729: {
 87729:   NS_ABORT_IF_FALSE(ManagedPLayersParent().Length() == 0,
 87729:                     "CompositorParent destroyed before managed PLayersParent");
 87729: 
 94488:   // Ensure that the layer manager is destructed on the compositor thread.
 87729:   mLayerManager = NULL;
 87729: }
 87729: 
 87729: bool
 94488: CompositorParent::RecvWillStop()
 94488: {
 94488:   mPaused = true;
104622:   RemoveCompositor(mCompositorID);
 94488: 
 94488:   // Ensure that the layer manager is destroyed before CompositorChild.
 94488:   mLayerManager->Destroy();
 94488: 
 94488:   return true;
 94488: }
 94488: 
 94488: bool
 87729: CompositorParent::RecvStop()
 87729: {
 87729:   Destroy();
105271:   // There are chances that the ref count reaches zero on the main thread shortly
105271:   // after this function returns while some ipdl code still needs to run on 
105271:   // this thread.
105271:   // We must keep the compositor parent alive untill the code handling message 
105271:   // reception is finished on this thread.
105271:   this->AddRef(); // Corresponds to DeferredDeleteCompositorParent's Release
105271:   CompositorLoop()->PostTask(FROM_HERE, 
105271:                            NewRunnableFunction(&DeferredDeleteCompositorParent,
105271:                                                this));
 87729:   return true;
 87729: }
 87729: 
 94309: bool
 94309: CompositorParent::RecvPause()
 94309: {
 94309:   PauseComposition();
 94309:   return true;
 94309: }
 94309: 
 94309: bool
 94309: CompositorParent::RecvResume()
 94309: {
 94309:   ResumeComposition();
 94309:   return true;
 94309: }
 94309: 
 87729: void
 93083: CompositorParent::ScheduleRenderOnCompositorThread()
 92813: {
 93083:   CancelableTask *renderTask = NewRunnableMethod(this, &CompositorParent::ScheduleComposition);
 96883:   CompositorLoop()->PostTask(FROM_HERE, renderTask);
 92813: }
 92813: 
 92813: void
 92816: CompositorParent::PauseComposition()
 92816: {
 96883:   NS_ABORT_IF_FALSE(CompositorThreadID() == PlatformThread::CurrentId(),
 93083:                     "PauseComposition() can only be called on the compositor thread");
 98753: 
 98753:   mozilla::MonitorAutoLock lock(mPauseCompositionMonitor);
 98753: 
 92820:   if (!mPaused) {
 92816:     mPaused = true;
 92816: 
 92816: #ifdef MOZ_WIDGET_ANDROID
 92820:     static_cast<LayerManagerOGL*>(mLayerManager.get())->gl()->ReleaseSurface();
 92816: #endif
 92816:   }
 98753: 
 98753:   // if anyone's waiting to make sure that composition really got paused, tell them
 98753:   lock.NotifyAll();
 92820: }
 92816: 
 92816: void
 92816: CompositorParent::ResumeComposition()
 92816: {
 96883:   NS_ABORT_IF_FALSE(CompositorThreadID() == PlatformThread::CurrentId(),
 93083:                     "ResumeComposition() can only be called on the compositor thread");
 99700: 
 99700:   mozilla::MonitorAutoLock lock(mResumeCompositionMonitor);
 99700: 
 92816:   mPaused = false;
 92816: 
 92816: #ifdef MOZ_WIDGET_ANDROID
 92823:   static_cast<LayerManagerOGL*>(mLayerManager.get())->gl()->RenewSurface();
 92816: #endif
 99700: 
101768:   Composite();
101768: 
 99700:   // if anyone's waiting to make sure that composition really got resumed, tell them
 99700:   lock.NotifyAll();
 92816: }
 92816: 
 92816: void
 98069: CompositorParent::SetEGLSurfaceSize(int width, int height)
 98069: {
 98069:   NS_ASSERTION(mRenderToEGLSurface, "Compositor created without RenderToEGLSurface ar provided");
 98069:   mEGLSurfaceSize.SizeTo(width, height);
 98069:   if (mLayerManager) {
 98069:     static_cast<LayerManagerOGL*>(mLayerManager.get())->SetSurfaceSize(mEGLSurfaceSize.width, mEGLSurfaceSize.height);
 98069:   }
 98069: }
 98069: 
 98069: void
 95782: CompositorParent::ResumeCompositionAndResize(int width, int height)
 95782: {
 99199:   mWidgetSize.width = width;
 99199:   mWidgetSize.height = height;
 98069:   SetEGLSurfaceSize(width, height);
 95782:   ResumeComposition();
 95782: }
 95782: 
 98753: /*
 98753:  * This will execute a pause synchronously, waiting to make sure that the compositor
 98753:  * really is paused.
 98753:  */
 95782: void
 93083: CompositorParent::SchedulePauseOnCompositorThread()
 92816: {
 98753:   mozilla::MonitorAutoLock lock(mPauseCompositionMonitor);
 98753: 
 92816:   CancelableTask *pauseTask = NewRunnableMethod(this,
 92816:                                                 &CompositorParent::PauseComposition);
 96883:   CompositorLoop()->PostTask(FROM_HERE, pauseTask);
 98753: 
 98753:   // Wait until the pause has actually been processed by the compositor thread
 98753:   lock.Wait();
 92816: }
 92816: 
 92816: void
 95782: CompositorParent::ScheduleResumeOnCompositorThread(int width, int height)
 92816: {
 99700:   mozilla::MonitorAutoLock lock(mResumeCompositionMonitor);
 99700: 
 95782:   CancelableTask *resumeTask =
 95782:     NewRunnableMethod(this, &CompositorParent::ResumeCompositionAndResize, width, height);
 96883:   CompositorLoop()->PostTask(FROM_HERE, resumeTask);
 99700: 
 99700:   // Wait until the resume has actually been processed by the compositor thread
 99700:   lock.Wait();
 92816: }
 92816: 
 92816: void
 96884: CompositorParent::ScheduleTask(CancelableTask* task, int time)
 96884: {
 99381:   if (time == 0) {
 96884:     MessageLoop::current()->PostTask(FROM_HERE, task);
 96884:   } else {
 96884:     MessageLoop::current()->PostDelayedTask(FROM_HERE, task, time);
 96884:   }
 96884: }
 96884: 
 96884: void
 87729: CompositorParent::ScheduleComposition()
 87729: {
 92818:   if (mCurrentCompositeTask) {
 92818:     return;
 92818:   }
 91562: 
 92848:   bool initialComposition = mLastCompose.IsNull();
 92848:   TimeDuration delta;
 92848:   if (!initialComposition)
 92848:     delta = mozilla::TimeStamp::Now() - mLastCompose;
 92819: 
 92862: #ifdef COMPOSITOR_PERFORMANCE_WARNING
 92862:   mExpectedComposeTime = mozilla::TimeStamp::Now() + TimeDuration::FromMilliseconds(15);
 91562: #endif
 91562: 
 92818:   mCurrentCompositeTask = NewRunnableMethod(this, &CompositorParent::Composite);
 93083: 
 93083:   // Since 60 fps is the maximum frame rate we can acheive, scheduling composition
 93083:   // events less than 15 ms apart wastes computation..
 92848:   if (!initialComposition && delta.ToMilliseconds() < 15) {
 92862: #ifdef COMPOSITOR_PERFORMANCE_WARNING
 92862:     mExpectedComposeTime = mozilla::TimeStamp::Now() + TimeDuration::FromMilliseconds(15 - delta.ToMilliseconds());
 92862: #endif
 96884:     ScheduleTask(mCurrentCompositeTask, 15 - delta.ToMilliseconds());
 92819:   } else {
 96884:     ScheduleTask(mCurrentCompositeTask, 0);
 92819:   }
 92793: }
 92793: 
 92793: void
 92793: CompositorParent::SetTransformation(float aScale, nsIntPoint aScrollOffset)
 92793: {
 92793:   mXScale = aScale;
 92793:   mYScale = aScale;
 92793:   mScrollOffset = aScrollOffset;
 87729: }
 87729: 
 87729: void
 87729: CompositorParent::Composite()
 87729: {
 96883:   NS_ABORT_IF_FALSE(CompositorThreadID() == PlatformThread::CurrentId(),
 93083:                     "Composite can only be called on the compositor thread");
 92818:   mCurrentCompositeTask = NULL;
 92818: 
 92862:   mLastCompose = mozilla::TimeStamp::Now();
 92862: 
 93097:   if (mPaused || !mLayerManager || !mLayerManager->GetRoot()) {
 87729:     return;
 87729:   }
 87729: 
 92904:   TransformShadowTree();
 92818: 
 92950:   Layer* aLayer = mLayerManager->GetRoot();
 92950:   mozilla::layers::RenderTraceLayers(aLayer, "0000");
 92950: 
 87729:   mLayerManager->EndEmptyTransaction();
 92862: 
 92862: #ifdef COMPOSITOR_PERFORMANCE_WARNING
 92862:   if (mExpectedComposeTime + TimeDuration::FromMilliseconds(15) < mozilla::TimeStamp::Now()) {
 93042:     printf_stderr("Compositor: Composite took %i ms.\n",
 93042:                   15 + (int)(mozilla::TimeStamp::Now() - mExpectedComposeTime).ToMilliseconds());
 87729:   }
 92862: #endif
 87729: }
 87729: 
 92924: // Do a breadth-first search to find the first layer in the tree that is
 92924: // scrollable.
 92828: Layer*
 92828: CompositorParent::GetPrimaryScrollableLayer()
 92828: {
 92828:   Layer* root = mLayerManager->GetRoot();
 92828: 
 92828:   nsTArray<Layer*> queue;
 92828:   queue.AppendElement(root);
 93083:   while (queue.Length()) {
 93083:     ContainerLayer* containerLayer = queue[0]->AsContainerLayer();
 93083:     queue.RemoveElementAt(0);
 92828:     if (!containerLayer) {
 92828:       continue;
 92828:     }
 92828: 
 92828:     const FrameMetrics& frameMetrics = containerLayer->GetFrameMetrics();
 92924:     if (frameMetrics.IsScrollable()) {
 92828:       return containerLayer;
 92828:     }
 92828: 
 92828:     Layer* child = containerLayer->GetFirstChild();
 92828:     while (child) {
 92828:       queue.AppendElement(child);
 92828:       child = child->GetNextSibling();
 92828:     }
 92828:   }
 92828: 
 92828:   return root;
 92828: }
 87729: 
 99199: static void
 99199: Translate2D(gfx3DMatrix& aTransform, const gfxPoint& aOffset)
 99199: {
 99199:   aTransform._41 += aOffset.x;
 99199:   aTransform._42 += aOffset.y;
 99199: }
 99199: 
 99199: void
103086: CompositorParent::TransformFixedLayers(Layer* aLayer,
103086:                                        const gfxPoint& aTranslation,
103086:                                        const gfxPoint& aScaleDiff)
 99199: {
 99199:   if (aLayer->GetIsFixedPosition() &&
 99199:       !aLayer->GetParent()->GetIsFixedPosition()) {
103086:     // When a scale has been applied to a layer, it focuses around (0,0).
103086:     // The anchor position is used here as a scale focus point (assuming that
103086:     // aScaleDiff has already been applied) to re-focus the scale.
103086:     const gfxPoint& anchor = aLayer->GetFixedPositionAnchor();
103086:     gfxPoint translation(aTranslation.x - (anchor.x - anchor.x / aScaleDiff.x),
103086:                          aTranslation.y - (anchor.y - anchor.y / aScaleDiff.y));
103086: 
 99199:     gfx3DMatrix layerTransform = aLayer->GetTransform();
103086:     Translate2D(layerTransform, translation);
 99199:     ShadowLayer* shadow = aLayer->AsShadowLayer();
 99199:     shadow->SetShadowTransform(layerTransform);
 99199: 
 99199:     const nsIntRect* clipRect = aLayer->GetClipRect();
 99199:     if (clipRect) {
 99199:       nsIntRect transformedClipRect(*clipRect);
103086:       transformedClipRect.MoveBy(translation.x, translation.y);
 99199:       shadow->SetShadowClipRect(&transformedClipRect);
 99199:     }
 99199:   }
 99199: 
 99199:   for (Layer* child = aLayer->GetFirstChild();
 99199:        child; child = child->GetNextSibling()) {
103086:     TransformFixedLayers(child, aTranslation, aScaleDiff);
 99199:   }
 99199: }
 99199: 
 95625: // Go down shadow layer tree, setting properties to match their non-shadow
 95625: // counterparts.
 95625: static void
 95625: SetShadowProperties(Layer* aLayer)
 95625: {
 95625:   // FIXME: Bug 717688 -- Do these updates in ShadowLayersParent::RecvUpdate.
 95625:   ShadowLayer* shadow = aLayer->AsShadowLayer();
 95625:   shadow->SetShadowTransform(aLayer->GetTransform());
 95625:   shadow->SetShadowVisibleRegion(aLayer->GetVisibleRegion());
 95625:   shadow->SetShadowClipRect(aLayer->GetClipRect());
 95625: 
 95625:   for (Layer* child = aLayer->GetFirstChild();
 95625:       child; child = child->GetNextSibling()) {
 95625:     SetShadowProperties(child);
 95625:   }
 95625: }
 95625: 
 92904: void
 92904: CompositorParent::TransformShadowTree()
 92793: {
 92904:   Layer* layer = GetPrimaryScrollableLayer();
 92904:   ShadowLayer* shadow = layer->AsShadowLayer();
 92904:   ContainerLayer* container = layer->AsContainerLayer();
 92793: 
 99282:   const FrameMetrics& metrics = container->GetFrameMetrics();
 93060:   const gfx3DMatrix& rootTransform = mLayerManager->GetRoot()->GetTransform();
 92904:   const gfx3DMatrix& currentTransform = layer->GetTransform();
 92793: 
 93083:   float rootScaleX = rootTransform.GetXScale();
 93083:   float rootScaleY = rootTransform.GetYScale();
 93060: 
 99282:   if (mIsFirstPaint) {
 99282:     mContentRect = metrics.mContentRect;
 99282:     SetFirstPaintViewport(metrics.mViewportScrollOffset,
 95790:                           1/rootScaleX,
 99281:                           mContentRect,
 99282:                           metrics.mCSSContentRect);
 93060:     mIsFirstPaint = false;
 99282:   } else if (!metrics.mContentRect.IsEqualEdges(mContentRect)) {
 99282:     mContentRect = metrics.mContentRect;
101900:     SetPageRect(metrics.mCSSContentRect);
 93060:   }
 93060: 
 93398:   // We synchronise the viewport information with Java after sending the above
 93398:   // notifications, so that Java can take these into account in its response.
 93544:   // Calculate the absolute display port to send to Java
 99282:   nsIntRect displayPort = metrics.mDisplayPort;
 99282:   nsIntPoint scrollOffset = metrics.mViewportScrollOffset;
 93544:   displayPort.x += scrollOffset.x;
 93544:   displayPort.y += scrollOffset.y;
 93544: 
 97355:   SyncViewportInfo(displayPort, 1/rootScaleX, mLayersUpdated,
 93545:                    mScrollOffset, mXScale, mYScale);
 93545:   mLayersUpdated = false;
 93060: 
 93060:   // Handle transformations for asynchronous panning and zooming. We determine the
 93060:   // zoom used by Gecko from the transformation set on the root layer, and we
 93060:   // determine the scroll offset used by Gecko from the frame metrics of the
 93060:   // primary scrollable layer. We compare this to the desired zoom and scroll
 93060:   // offset in the view transform we obtained from Java in order to compute the
 93060:   // transformation we need to apply.
 93060:   float tempScaleDiffX = rootScaleX * mXScale;
 93060:   float tempScaleDiffY = rootScaleY * mYScale;
 92793: 
 97058:   nsIntPoint metricsScrollOffset(0, 0);
 99282:   if (metrics.IsScrollable())
 99282:     metricsScrollOffset = metrics.mViewportScrollOffset;
 92793: 
 92793:   nsIntPoint scrollCompensation(
 92904:     (mScrollOffset.x / tempScaleDiffX - metricsScrollOffset.x) * mXScale,
 92904:     (mScrollOffset.y / tempScaleDiffY - metricsScrollOffset.y) * mYScale);
 93060:   ViewTransform treeTransform(-scrollCompensation, mXScale, mYScale);
 93060:   shadow->SetShadowTransform(gfx3DMatrix(treeTransform) * currentTransform);
 99542: 
103086:   // Translate fixed position layers so that they stay in the correct position
103086:   // when mScrollOffset and metricsScrollOffset differ.
103602:   gfxPoint offset;
103602:   gfxPoint scaleDiff;
 99542: 
103086:   // If the contents can fit entirely within the widget area on a particular
103086:   // dimenson, we need to translate and scale so that the fixed layers remain
103086:   // within the page boundaries.
103086:   if (mContentRect.width * tempScaleDiffX < mWidgetSize.width) {
103086:     offset.x = -metricsScrollOffset.x;
103086:     scaleDiff.x = NS_MIN(1.0f, mWidgetSize.width / (float)mContentRect.width);
103602:   } else {
103602:     offset.x = clamped(mScrollOffset.x / tempScaleDiffX, (float)mContentRect.x,
103602:                        mContentRect.XMost() - mWidgetSize.width / tempScaleDiffX) -
103602:                metricsScrollOffset.x;
103602:     scaleDiff.x = tempScaleDiffX;
103086:   }
103086: 
103086:   if (mContentRect.height * tempScaleDiffY < mWidgetSize.height) {
103086:     offset.y = -metricsScrollOffset.y;
103086:     scaleDiff.y = NS_MIN(1.0f, mWidgetSize.height / (float)mContentRect.height);
103602:   } else {
103602:     offset.y = clamped(mScrollOffset.y / tempScaleDiffY, (float)mContentRect.y,
103602:                        mContentRect.YMost() - mWidgetSize.height / tempScaleDiffY) -
103602:                metricsScrollOffset.y;
103602:     scaleDiff.y = tempScaleDiffY;
103086:   }
103086: 
103086:   TransformFixedLayers(layer, offset, scaleDiff);
 97355: }
 97355: 
 97355: void
 99281: CompositorParent::SetFirstPaintViewport(const nsIntPoint& aOffset, float aZoom,
 99281:                                         const nsIntRect& aPageRect, const gfx::Rect& aCssPageRect)
 97355: {
 97355: #ifdef MOZ_WIDGET_ANDROID
 99281:   mozilla::AndroidBridge::Bridge()->SetFirstPaintViewport(aOffset, aZoom, aPageRect, aCssPageRect);
 97355: #endif
 97355: }
 97355: 
 97355: void
101900: CompositorParent::SetPageRect(const gfx::Rect& aCssPageRect)
 97355: {
 97355: #ifdef MOZ_WIDGET_ANDROID
101900:   mozilla::AndroidBridge::Bridge()->SetPageRect(aCssPageRect);
 97355: #endif
 97355: }
 97355: 
 97355: void
 97355: CompositorParent::SyncViewportInfo(const nsIntRect& aDisplayPort,
 97355:                                    float aDisplayResolution, bool aLayersUpdated,
 97355:                                    nsIntPoint& aScrollOffset, float& aScaleX, float& aScaleY)
 97355: {
 97355: #ifdef MOZ_WIDGET_ANDROID
 97355:   mozilla::AndroidBridge::Bridge()->SyncViewportInfo(aDisplayPort, aDisplayResolution, aLayersUpdated,
 97355:                                                      aScrollOffset, aScaleX, aScaleY);
 92908: #endif
 92793: }
 92793: 
 87729: void
 93058: CompositorParent::ShadowLayersUpdated(bool isFirstPaint)
 87729: {
 93058:   mIsFirstPaint = mIsFirstPaint || isFirstPaint;
 93545:   mLayersUpdated = true;
 87729:   const nsTArray<PLayersParent*>& shadowParents = ManagedPLayersParent();
 87729:   NS_ABORT_IF_FALSE(shadowParents.Length() <= 1,
 87729:                     "can only support at most 1 ShadowLayersParent");
 87729:   if (shadowParents.Length()) {
 87729:     Layer* root = static_cast<ShadowLayersParent*>(shadowParents[0])->GetRoot();
 87729:     mLayerManager->SetRoot(root);
 87729:     SetShadowProperties(root);
 87729:   }
 87729:   ScheduleComposition();
 87729: }
 87729: 
 87729: PLayersParent*
 99140: CompositorParent::AllocPLayers(const LayersBackend& aBackendType, int* aMaxTextureSize)
 87729: {
 99199:   // mWidget doesn't belong to the compositor thread, so it should be set to
 99199:   // NULL before returning from this method, to avoid accessing it elsewhere.
 99199:   nsIntRect rect;
 99199:   mWidget->GetBounds(rect);
 99199:   mWidgetSize.width = rect.width;
 99199:   mWidgetSize.height = rect.height;
 99199: 
 99140:   if (aBackendType == LayerManager::LAYERS_OPENGL) {
 98069:     nsRefPtr<LayerManagerOGL> layerManager;
 98069:     layerManager =
 98069:       new LayerManagerOGL(mWidget, mEGLSurfaceSize.width, mEGLSurfaceSize.height, mRenderToEGLSurface);
 87729:     mWidget = NULL;
 87729:     mLayerManager = layerManager;
104622:     ShadowLayerManager* shadowManager = layerManager->AsShadowManager();
104622:     if (shadowManager) {
104622:       shadowManager->SetCompositorID(mCompositorID);  
104622:     }
 87729:     
 87729:     if (!layerManager->Initialize()) {
 87729:       NS_ERROR("Failed to init OGL Layers");
 87729:       return NULL;
 87729:     }
 87729: 
 87729:     ShadowLayerManager* slm = layerManager->AsShadowManager();
 87729:     if (!slm) {
 87729:       return NULL;
 87729:     }
 99140:     *aMaxTextureSize = layerManager->GetMaxTextureSize();
 87729:     return new ShadowLayersParent(slm, this);
 99140:   } else if (aBackendType == LayerManager::LAYERS_BASIC) {
 98068:     nsRefPtr<LayerManager> layerManager = new BasicShadowLayerManager(mWidget);
 98068:     mWidget = NULL;
 98068:     mLayerManager = layerManager;
 98068:     ShadowLayerManager* slm = layerManager->AsShadowManager();
 98068:     if (!slm) {
 98068:       return NULL;
 98068:     }
 99140:     *aMaxTextureSize = layerManager->GetMaxTextureSize();
 98068:     return new ShadowLayersParent(slm, this);
 87729:   } else {
 87729:     NS_ERROR("Unsupported backend selected for Async Compositor");
 87729:     return NULL;
 87729:   }
 87729: }
 87729: 
 87729: bool
 87729: CompositorParent::DeallocPLayers(PLayersParent* actor)
 87729: {
 87729:   delete actor;
 87729:   return true;
 87729: }
 87729: 
104622: 
104622: typedef std::map<PRUint64,CompositorParent*> CompositorMap;
104622: static CompositorMap* sCompositorMap;
104622: 
104622: void CompositorParent::CreateCompositorMap()
104622: {
104622:   if (sCompositorMap == nsnull) {
104622:     sCompositorMap = new CompositorMap;
104622:   }
104622: }
104622: 
104622: void CompositorParent::DestroyCompositorMap()
104622: {
104622:   if (sCompositorMap != nsnull) {
104622:     NS_ASSERTION(sCompositorMap->empty(), 
104622:                  "The Compositor map should be empty when destroyed>");
104622:     delete sCompositorMap;
104622:     sCompositorMap = nsnull;
104622:   }
104622: }
104622: 
104622: CompositorParent* CompositorParent::GetCompositor(PRUint64 id)
104622: {
104622:   CompositorMap::iterator it = sCompositorMap->find(id);
104622:   return it != sCompositorMap->end() ? it->second : nsnull;
104622: }
104622: 
104622: void CompositorParent::AddCompositor(CompositorParent* compositor, PRUint64* outID)
104622: {
104622:   static PRUint64 sNextID = 1;
104622:   
104622:   ++sNextID;
104622:   (*sCompositorMap)[sNextID] = compositor;
104622:   *outID = sNextID;
104622: }
104622: 
104622: CompositorParent* CompositorParent::RemoveCompositor(PRUint64 id)
104622: {
104622:   CompositorMap::iterator it = sCompositorMap->find(id);
104622:   if (it == sCompositorMap->end()) {
104622:     return nsnull;
104622:   }
104622:   sCompositorMap->erase(it);
104622:   return it->second;
104622: }
104622: 
104622: 
 87729: } // namespace layers
 87729: } // namespace mozilla
 87729: 
