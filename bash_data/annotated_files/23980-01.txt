    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:ts=2:et:sw=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * construction of a frame tree that is nearly isomorphic to the content
    1:  * tree and updating of that tree in response to dynamic changes
    1:  */
    1: 
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsCRT.h"
    1: #include "nsIAtom.h"
    1: #include "nsIURL.h"
 6939: #include "nsISupportsArray.h"
    1: #include "nsHashtable.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIStyleRule.h"
    1: #include "nsIFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsPresContext.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIDocument.h"
    1: #include "nsTableFrame.h"
    1: #include "nsTableColGroupFrame.h"
    1: #include "nsTableColFrame.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMHTMLTableColElement.h"
    1: #include "nsIDOMHTMLTableCaptionElem.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsIPresShell.h"
    1: #include "nsStyleSet.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsTableOuterFrame.h"
    1: #include "nsIDOMXULElement.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDOMHTMLSelectElement.h"
    1: #include "nsIDOMHTMLLegendElement.h"
    1: #include "nsIComboboxControlFrame.h"
    1: #include "nsIListControlFrame.h"
    1: #include "nsISelectControlFrame.h"
    1: #include "nsIRadioControlFrame.h"
    1: #include "nsICheckboxControlFrame.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsPlaceholderFrame.h"
    1: #include "nsTableRowGroupFrame.h"
    1: #include "nsStyleChangeList.h"
    1: #include "nsIFormControl.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsCSSPseudoElements.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsTextFragment.h"
 6939: #include "nsISupportsArray.h"
    1: #include "nsIAnonymousContentCreator.h"
    1: #include "nsFrameManager.h"
    1: #include "nsLegendFrame.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsBindingManager.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsITheme.h"
    1: #include "nsContentCID.h"
    1: #include "nsContentUtils.h"
 7189: #include "nsIScriptError.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsObjectFrame.h"
    1: #include "nsRuleNode.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsChildIterator.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsISelectElement.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsBoxFrame.h"
    1: #include "nsIBoxLayout.h"
    1: #include "nsImageFrame.h"
    1: #include "nsIObjectLoadingContent.h"
    1: #include "nsContentErrors.h"
 3645: #include "nsIPrincipal.h"
    1: #include "nsIDOMWindowInternal.h"
11845: #include "nsStyleUtil.h"
13389: #include "nsIFocusEventSuppressor.h"
    1: #include "nsBox.h"
    1: 
    1: #ifdef MOZ_XUL
    1: #include "nsIRootBox.h"
    1: #include "nsIDOMXULCommandDispatcher.h"
    1: #include "nsIDOMXULDocument.h"
    1: #include "nsIXULDocument.h"
    1: #endif
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #include "nsIAccessibleEvent.h"
    1: #endif
    1: 
    1: #include "nsInlineFrame.h"
    1: #include "nsBlockFrame.h"
    1: 
    1: #include "nsIScrollableFrame.h"
    1: 
    1: #include "nsIXBLService.h"
    1: 
    1: #undef NOISY_FIRST_LETTER
    1: 
    1: #ifdef MOZ_MATHML
    1: #include "nsMathMLParts.h"
    1: #endif
16411: #ifdef MOZ_SVG
19948: #include "nsSVGEffects.h"
16411: #endif
    1: 
    1: nsIFrame*
    1: NS_NewHTMLCanvasFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
15751: #if defined(MOZ_MEDIA)
15751: nsIFrame*
15751: NS_NewHTMLVideoFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
15751: #endif
15751: 
    1: #ifdef MOZ_SVG
    1: #include "nsISVGTextContentMetrics.h"
    1: 
    1: PRBool
    1: NS_SVGEnabled();
    1: nsIFrame*
23953: NS_NewSVGOuterSVGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGInnerSVGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGPathGeometryFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGGenericContainerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGForeignObjectFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGAFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGGlyphFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGSwitchFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
15895: nsIFrame*
23953: NS_NewSVGTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGTSpanFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGContainerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGUseFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: PRBool 
15895: NS_SVG_PassesConditionalProcessingTests(nsIContent *aContent);
    1: extern nsIFrame*
23953: NS_NewSVGLinearGradientFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: extern nsIFrame*
23953: NS_NewSVGRadialGradientFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: extern nsIFrame*
23953: NS_NewSVGStopFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGMarkerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: extern nsIFrame*
23953: NS_NewSVGImageFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGClipPathFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGTextPathFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGFilterFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGPatternFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGMaskFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
    1: NS_NewSVGLeafFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: #endif
    1: 
    1: #include "nsIDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentXBL.h"
    1: #include "nsIScrollable.h"
    1: #include "nsINodeInfo.h"
    1: #include "prenv.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsIServiceManager.h"
    1: 
    1: // Global object maintenance
    1: nsIXBLService * nsCSSFrameConstructor::gXBLService = nsnull;
    1: 
    1: #ifdef DEBUG
    1: // Set the environment variable GECKO_FRAMECTOR_DEBUG_FLAGS to one or
    1: // more of the following flags (comma separated) for handy debug
    1: // output.
    1: static PRBool gNoisyContentUpdates = PR_FALSE;
    1: static PRBool gReallyNoisyContentUpdates = PR_FALSE;
    1: static PRBool gNoisyInlineConstruction = PR_FALSE;
    1: static PRBool gVerifyFastFindFrame = PR_FALSE;
    1: static PRBool gTablePseudoFrame = PR_FALSE;
    1: 
    1: struct FrameCtorDebugFlags {
    1:   const char* name;
    1:   PRBool* on;
    1: };
    1: 
    1: static FrameCtorDebugFlags gFlags[] = {
    1:   { "content-updates",              &gNoisyContentUpdates },
    1:   { "really-noisy-content-updates", &gReallyNoisyContentUpdates },
    1:   { "noisy-inline",                 &gNoisyInlineConstruction },
    1:   { "fast-find-frame",              &gVerifyFastFindFrame },
    1:   { "table-pseudo",                 &gTablePseudoFrame },
    1: };
    1: 
    1: #define NUM_DEBUG_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
    1: #endif
    1: 
    1: 
    1: #ifdef MOZ_XUL
    1: #include "nsMenuFrame.h"
    1: #include "nsPopupSetFrame.h"
    1: #include "nsTreeColFrame.h"
    1: #include "nsIBoxObject.h"
    1: #include "nsPIListBoxObject.h"
    1: #include "nsListBoxBodyFrame.h"
    1: #include "nsListItemFrame.h"
23176: #include "nsXULLabelFrame.h"
    1: 
    1: //------------------------------------------------------------------
    1: 
    1: nsIFrame*
    1: NS_NewAutoRepeatBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewRootBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewDocElementBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewThumbFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
23947: NS_NewDeckFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewLeafBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
23947: NS_NewStackFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewProgressMeterFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewImageBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewTextBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewGroupBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewButtonBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewSplitterFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewMenuPopupFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewPopupSetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewMenuFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
    1: 
    1: nsIFrame*
    1: NS_NewMenuBarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewTreeBodyFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: // grid
    1: nsresult
    1: NS_NewGridLayout2 ( nsIPresShell* aPresShell, nsIBoxLayout** aNewLayout );
    1: nsIFrame*
23947: NS_NewGridRowLeafFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23947: NS_NewGridRowGroupFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: // end grid
    1: 
    1: nsIFrame*
    1: NS_NewTitleBarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewResizerFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: 
    1: #endif
    1: 
    1: nsIFrame*
    1: NS_NewHTMLScrollFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot);
    1: 
    1: nsIFrame*
    1: NS_NewXULScrollFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot);
    1: 
    1: nsIFrame*
    1: NS_NewSliderFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewScrollbarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewScrollbarButtonFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: 
    1: #ifdef NOISY_FINDFRAME
    1: static PRInt32 FFWC_totalCount=0;
    1: static PRInt32 FFWC_doLoop=0;
    1: static PRInt32 FFWC_doSibling=0;
    1: static PRInt32 FFWC_recursions=0;
    1: static PRInt32 FFWC_nextInFlows=0;
    1: static PRInt32 FFWC_slowSearchForText=0;
    1: #endif
    1: 
    1: static nsresult
    1: DeletingFrameSubtree(nsFrameManager* aFrameManager,
    1:                      nsIFrame*       aFrame);
    1: 
    1: static inline nsIFrame*
23176: GetFieldSetBlockFrame(nsIFrame* aFieldsetFrame)
    1: {
    1:   // Depends on the fieldset child frame order - see ConstructFieldSetFrame() below.
    1:   nsIFrame* firstChild = aFieldsetFrame->GetFirstChild(nsnull);
    1:   return firstChild && firstChild->GetNextSibling() ? firstChild->GetNextSibling() : firstChild;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: static PRBool
 2829: IsInlineOutside(nsIFrame* aFrame)
 2829: {
 2829:   return aFrame->GetStyleDisplay()->IsInlineOutside();
 2829: }
 2829: 
 4696: /**
 4696:  * True if aFrame is an actual inline frame in the sense of non-replaced
 4696:  * display:inline CSS boxes.  In other words, it can be affected by {ib}
 4696:  * splitting and can contain first-letter frames.  Basically, this is either an
 4696:  * inline frame (positioned or otherwise) or an line frame (this last because
 4696:  * it can contain first-letter and because inserting blocks in the middle of it
 4696:  * needs to terminate it).
 4696:  */
    1: static PRBool
 4696: IsInlineFrame(const nsIFrame* aFrame)
 4696: {
 4696:   return aFrame->IsFrameOfType(nsIFrame::eLineParticipant);
    1: }
    1: 
 7189: /**
 7189:  * If any children require a block parent, return the first such child.
 7189:  * Otherwise return null.
 7189:  */
 7189: static nsIContent*
 7189: AnyKidsNeedBlockParent(nsIFrame *aFrameList)
 7189: {
 7189:   for (nsIFrame *k = aFrameList; k; k = k->GetNextSibling()) {
 7189:     // Line participants, such as text and inline frames, can't be
 7189:     // directly inside a XUL box; they must be wrapped in an
 7189:     // intermediate block.
 7189:     if (k->IsFrameOfType(nsIFrame::eLineParticipant)) {
 7189:       return k->GetContent();
 7189:     }
 7189:   }
 7189:   return nsnull;
 7189: }
 7189: 
 7189: // Reparent a frame into a wrapper frame that is a child of its old parent.
 7189: static void
 7189: ReparentFrame(nsFrameManager* aFrameManager,
 7189:               nsIFrame* aNewParentFrame,
 7189:               nsIFrame* aFrame)
 7189: {
 7189:   aFrame->SetParent(aNewParentFrame);
 7189:   aFrameManager->ReParentStyleContext(aFrame);
 7189:   if (aFrame->GetStateBits() &
 7189:       (NS_FRAME_HAS_VIEW | NS_FRAME_HAS_CHILD_WITH_VIEW)) {
 7189:     // No need to walk up the tree, since the bits are already set
 7189:     // right on the parent of aNewParentFrame.
 7189:     NS_ASSERTION(aNewParentFrame->GetParent()->GetStateBits() &
 7189:                    NS_FRAME_HAS_CHILD_WITH_VIEW,
 7189:                  "aNewParentFrame's parent should have this bit set!");
 7189:     aNewParentFrame->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
 7189:   }
 7189: }
 7189: 
    1: //----------------------------------------------------------------------
 5324: //
 5324: // When inline frames get weird and have block frames in them, we
 5324: // annotate them to help us respond to incremental content changes
 5324: // more easily.
 5324: 
 5324: static inline PRBool
 5324: IsFrameSpecial(nsIFrame* aFrame)
 5324: {
 5324:   return (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) != 0;
 5324: }
 5324: 
 5324: static nsIFrame* GetSpecialSibling(nsIFrame* aFrame)
 5324: {
 5324:   // We only store the "special sibling" annotation with the first
 5324:   // frame in the continuation chain. Walk back to find that frame now.
 5324:   aFrame = aFrame->GetFirstContinuation();
 5324: 
 5324:   void* value = aFrame->GetProperty(nsGkAtoms::IBSplitSpecialSibling);
 5324: 
 5324:   return static_cast<nsIFrame*>(value);
 5324: }
 5324: 
 5324: static nsIFrame*
19125: GetIBSplitSpecialPrevSiblingForAnonymousBlock(nsIFrame* aFrame)
 5324: {
 5324:   NS_PRECONDITION(IsFrameSpecial(aFrame) && !IsInlineFrame(aFrame),
 5324:                   "Shouldn't call this");
 5324:   
 5324:   // We only store the "special sibling" annotation with the first
 5324:   // frame in the continuation chain. Walk back to find that frame now.  
 5324:   return
 5324:     static_cast<nsIFrame*>
 5324:     (aFrame->GetFirstContinuation()->
 5324:        GetProperty(nsGkAtoms::IBSplitSpecialPrevSibling));
 5324: }
 5324: 
 5324: static nsIFrame*
 5324: GetLastSpecialSibling(nsIFrame* aFrame)
 5324: {
 5324:   for (nsIFrame *frame = aFrame, *next; ; frame = next) {
 5324:     next = GetSpecialSibling(frame);
 5324:     if (!next)
 5324:       return frame;
 5324:   }
 5324:   NS_NOTREACHED("unreachable code");
 5324:   return nsnull;
 5324: }
 5324: 
 5324: static void
 5324: SetFrameIsSpecial(nsIFrame* aFrame, nsIFrame* aSpecialSibling)
 5324: {
 5324:   NS_PRECONDITION(aFrame, "bad args!");
 5324: 
 5324:   // Mark the frame and all of its siblings as "special".
 5324:   for (nsIFrame* frame = aFrame; frame != nsnull; frame = frame->GetNextContinuation()) {
 5324:     frame->AddStateBits(NS_FRAME_IS_SPECIAL);
 5324:   }
 5324: 
 5324:   if (aSpecialSibling) {
 5324:     // We should be the first-in-flow
 5324:     NS_ASSERTION(!aFrame->GetPrevInFlow(),
 5324:                  "assigning special sibling to other than first-in-flow!");
 5324: 
 5324:     // Store the "special sibling" (if we were given one) with the
 5324:     // first frame in the flow.
 5324:     aFrame->SetProperty(nsGkAtoms::IBSplitSpecialSibling, aSpecialSibling);
 5324:   }
 5324: }
 5324: 
 5324: static nsIFrame*
 5324: GetIBContainingBlockFor(nsIFrame* aFrame)
 5324: {
 5324:   NS_PRECONDITION(IsFrameSpecial(aFrame),
 5324:                   "GetIBContainingBlockFor() should only be called on known IB frames");
 5324: 
 5324:   // Get the first "normal" ancestor of the target frame.
 5324:   nsIFrame* parentFrame;
 5324:   do {
 5324:     parentFrame = aFrame->GetParent();
 5324: 
 5324:     if (! parentFrame) {
 5324:       NS_ERROR("no unsplit block frame in IB hierarchy");
 5324:       return aFrame;
 5324:     }
 5324: 
 5324:     // Note that we ignore non-special frames which have a pseudo on their
 5324:     // style context -- they're not the frames we're looking for!  In
 5324:     // particular, they may be hiding a real parent that _is_ special.
 5324:     if (!IsFrameSpecial(parentFrame) &&
 5324:         !parentFrame->GetStyleContext()->GetPseudoType())
 5324:       break;
 5324: 
 5324:     aFrame = parentFrame;
 5324:   } while (1);
 5324:  
 5324:   // post-conditions
 5324:   NS_ASSERTION(parentFrame, "no normal ancestor found for special frame in GetIBContainingBlockFor");
 5324:   NS_ASSERTION(parentFrame != aFrame, "parentFrame is actually the child frame - bogus reslt");
 5324: 
 5324:   return parentFrame;
 5324: }
 5324: 
 5324: //----------------------------------------------------------------------
    1: 
    1: // Block/inline frame construction logic. We maintain a few invariants here:
    1: //
    1: // 1. Block frames contain block and inline frames.
    1: //
    1: // 2. Inline frames only contain inline frames. If an inline parent has a block
    1: // child then the block child is migrated upward until it lands in a block
    1: // parent (the inline frames containing block is where it will end up).
    1: 
    1: static nsIFrame*
    1: FindFirstBlock(nsIFrame* aKid, nsIFrame** aPrevKid)
    1: {
    1:   nsIFrame* prevKid = nsnull;
    1:   while (aKid) {
 2829:     if (!IsInlineOutside(aKid)) {
    1:       *aPrevKid = prevKid;
    1:       return aKid;
    1:     }
    1:     prevKid = aKid;
    1:     aKid = aKid->GetNextSibling();
    1:   }
    1:   *aPrevKid = nsnull;
    1:   return nsnull;
    1: }
    1: 
    1: static nsIFrame*
    1: FindLastBlock(nsIFrame* aKid)
    1: {
    1:   nsIFrame* lastBlock = nsnull;
    1:   while (aKid) {
 2829:     if (!IsInlineOutside(aKid)) {
    1:       lastBlock = aKid;
    1:     }
    1:     aKid = aKid->GetNextSibling();
    1:   }
    1:   return lastBlock;
    1: }
    1: 
    1: /*
19125:  * The special-prev-sibling is useful for
    1:  * finding the "special parent" of a frame (i.e., a frame from which a
    1:  * good parent style context can be obtained), one looks at the
    1:  * special previous sibling annotation of the real parent of the frame
    1:  * (if the real parent has NS_FRAME_IS_SPECIAL).
    1:  */
    1: inline void
 5324: MarkIBSpecialPrevSibling(nsIFrame *aAnonymousFrame,
    1:                          nsIFrame *aSpecialParent)
    1: {
 5324:   aAnonymousFrame->SetProperty(nsGkAtoms::IBSplitSpecialPrevSibling,
    1:                                aSpecialParent, nsnull, nsnull);
    1: }
    1: 
    1: // -----------------------------------------------------------
    1: 
 8406: static PRBool
 8406: IsOutOfFlowList(nsIAtom* aListName)
 8406: {
 8406:   return
 8406:     aListName == nsGkAtoms::floatList ||
 8406:     aListName == nsGkAtoms::absoluteList ||
 8406:     aListName == nsGkAtoms::overflowOutOfFlowList ||
 8406:     aListName == nsGkAtoms::fixedList;
 8406: }
 8406: 
    1: // Helper function that recursively removes content to frame mappings and
    1: // undisplayed content mappings.
    1: // This differs from DeletingFrameSubtree() because the frames have not yet been
    1: // added to the frame hierarchy.
    1: // XXXbz it would really help if we merged the two methods somehow... :(
    1: static void
    1: DoCleanupFrameReferences(nsFrameManager*  aFrameManager,
    1:                          nsIFrame*        aFrameIn)
    1: {
    1:   nsIContent* content = aFrameIn->GetContent();
    1: 
    1:   if (aFrameIn->GetType() == nsGkAtoms::placeholderFrame) {
 3233:     nsPlaceholderFrame* placeholder = static_cast<nsPlaceholderFrame*>
 3233:                                                  (aFrameIn);
    1:     // if the frame is a placeholder use the out of flow frame
    1:     aFrameIn = nsPlaceholderFrame::GetRealFrameForPlaceholder(placeholder);
    1: 
    1:     // And don't forget to unregister the placeholder mapping.  Note that this
    1:     // means it's the caller's responsibility to actually destroy the
    1:     // out-of-flow pointed to by the placeholder, since after this point the
    1:     // out-of-flow is not reachable via the placeholder.
    1:     aFrameManager->UnregisterPlaceholderFrame(placeholder);
    1:   }
    1: 
    1:   // Remove the mapping from the content object to its frame
    1:   aFrameManager->RemoveAsPrimaryFrame(content, aFrameIn);
    1:   aFrameManager->ClearAllUndisplayedContentIn(content);
    1: 
    1:   // Recursively walk the child frames.
    1:   nsIAtom* childListName = nsnull;
    1:   PRInt32 childListIndex = 0;
    1:   do {
    1:     nsIFrame* childFrame = aFrameIn->GetFirstChild(childListName);
    1:     while (childFrame) {
    1:       DoCleanupFrameReferences(aFrameManager, childFrame);
    1:     
    1:       // Get the next sibling child frame
    1:       childFrame = childFrame->GetNextSibling();
    1:     }
    1: 
    1:     childListName = aFrameIn->GetAdditionalChildListName(childListIndex++);
    1:   } while (childListName);
    1: }
    1: 
    1: // Helper function that walks a frame list and calls DoCleanupFrameReference()
    1: static void
    1: CleanupFrameReferences(nsFrameManager*  aFrameManager,
    1:                        nsIFrame*        aFrameList)
    1: {
    1:   while (aFrameList) {
    1:     DoCleanupFrameReferences(aFrameManager, aFrameList);
    1: 
    1:     // Get the sibling frame
    1:     aFrameList = aFrameList->GetNextSibling();
    1:   }
    1: }
    1: 
    1: // -----------------------------------------------------------
    1: 
    1: // Structure used when constructing formatting object trees.
    1: struct nsFrameItems {
    1:   nsIFrame* childList;
    1:   nsIFrame* lastChild;
    1:   
    1:   nsFrameItems(nsIFrame* aFrame = nsnull);
    1: 
    1:   // Appends the frame to the end of the list
    1:   void AddChild(nsIFrame* aChild);
    1: 
    1:   // Inserts the frame somewhere in the list
    1:   void InsertChildAfter(nsIFrame* aChild, nsIFrame* aAfter);
    1: 
 4368:   // Remove the frame from the list, return PR_FALSE if not found.  If
 4368:   // aPrevSibling is given, it must have aChild as its GetNextSibling().
 4368:   // aPrevSibling may be null to indicate that the list should be searched.
 4368:   PRBool RemoveChild(nsIFrame* aChild, nsIFrame* aPrevSibling);
    1: };
    1: 
    1: nsFrameItems::nsFrameItems(nsIFrame* aFrame)
    1:   : childList(aFrame), lastChild(aFrame)
    1: {
    1: }
    1: 
    1: void 
    1: nsFrameItems::AddChild(nsIFrame* aChild)
    1: {
    1: #ifdef DEBUG
    1:   nsIFrame* oldLastChild = lastChild;
    1: #endif
    1:   
    1:   if (childList == nsnull) {
    1:     childList = lastChild = aChild;
    1:   }
    1:   else
    1:   {
    1:     NS_ASSERTION(aChild != lastChild,
    1:                  "Same frame being added to frame list twice?");
    1:     lastChild->SetNextSibling(aChild);
    1:     lastChild = aChild;
    1:   }
    1:   // if aChild has siblings, lastChild needs to be the last one
    1:   for (nsIFrame* sib = lastChild->GetNextSibling(); sib;
    1:        sib = sib->GetNextSibling()) {
    1:     NS_ASSERTION(oldLastChild != sib, "Loop in frame list");
    1:     lastChild = sib;
    1:   }
    1: }
    1: 
    1: void
    1: nsFrameItems::InsertChildAfter(nsIFrame* aChild, nsIFrame* aAfter)
    1: {
    1:   if (!childList || (aAfter && !aAfter->GetNextSibling())) {
    1:     // Appending to the end of the list
    1:     AddChild(aChild);
    1:     return;
    1:   }
    1:   if (!aAfter) {
    1:     // Inserting at beginning of list
    1:     aChild->SetNextSibling(childList);
    1:     childList = aChild;
    1:     return;
    1:   }
    1:   aChild->SetNextSibling(aAfter->GetNextSibling());
    1:   aAfter->SetNextSibling(aChild);
    1: }
    1: 
    1: PRBool
 4368: nsFrameItems::RemoveChild(nsIFrame* aFrame, nsIFrame* aPrevSibling)
    1: {
    1:   NS_PRECONDITION(aFrame, "null ptr");
 4368: 
 4368:   nsIFrame* prev;
 4368:   if (aPrevSibling) {
 4368:     prev = aPrevSibling;
 4368:   } else {
 4368:     prev = nsnull;
 4368:     nsIFrame* sib;
 4368:     for (sib = childList; sib && sib != aFrame; sib = sib->GetNextSibling()) {
    1:       prev = sib;
    1:     }
    1:     if (!sib) {
    1:       return PR_FALSE;
    1:     }
 4368:   }
 4368: 
 4368:   NS_ASSERTION(!prev || prev->GetNextSibling() == aFrame,
 4368:                "Unexpected prevsibling");
 4368: 
 4368:   if (aFrame == childList) {
 4368:     childList = aFrame->GetNextSibling();
    1:   } else {
 4368:     prev->SetNextSibling(aFrame->GetNextSibling());
 4368:   }
 4368:   if (aFrame == lastChild) {
    1:     lastChild = prev;
    1:   }
 4368:   aFrame->SetNextSibling(nsnull);
    1:   return PR_TRUE;
    1: }
    1: 
    1: // -----------------------------------------------------------
    1: 
    1: // Structure used when constructing formatting object trees. Contains
    1: // state information needed for absolutely positioned elements
    1: struct nsAbsoluteItems : nsFrameItems {
    1:   // containing block for absolutely positioned elements
    1:   nsIFrame* containingBlock;
    1:   
    1:   nsAbsoluteItems(nsIFrame* aContainingBlock);
    1: #ifdef DEBUG
    1:   // XXXbz Does this need a debug-only assignment operator that nulls out the
    1:   // childList in the nsAbsoluteItems we're copying?  Introducing a difference
    1:   // between debug and non-debug behavior seems bad, so I guess not...
    1:   ~nsAbsoluteItems() {
    1:     NS_ASSERTION(!childList,
    1:                  "Dangling child list.  Someone forgot to insert it?");
    1:   }
    1: #endif
    1:   
    1:   // Appends the frame to the end of the list
    1:   void AddChild(nsIFrame* aChild);
    1: };
    1: 
    1: nsAbsoluteItems::nsAbsoluteItems(nsIFrame* aContainingBlock)
    1:   : containingBlock(aContainingBlock)
    1: {
    1: }
    1: 
    1: // Additional behavior is that it sets the frame's NS_FRAME_OUT_OF_FLOW flag
    1: void
    1: nsAbsoluteItems::AddChild(nsIFrame* aChild)
    1: {
  238:   NS_ASSERTION(aChild->PresContext()->FrameManager()->
    1:                GetPlaceholderFrameFor(aChild),
    1:                "Child without placeholder being added to nsAbsoluteItems?");
    1:   aChild->AddStateBits(NS_FRAME_OUT_OF_FLOW);
    1:   nsFrameItems::AddChild(aChild);
    1: }
    1: 
    1: // Structures used to record the creation of pseudo table frames where 
    1: // the content belongs to some ancestor. 
    1: // PseudoFrames are necessary when the childframe cannot be the direct
    1: // ancestor of the content based parent frame. The amount of necessary pseudo
    1: // frames is limited as the worst case would be table frame nested directly
    1: // into another table frame. So the member structures of nsPseudoFrames can be
    1: // viewed as a ring buffer where you start with the necessary frame type and
    1: // add higher frames as long as necessary to fit into the initial parent frame.
    1: // mLowestType is some sort of stack pointer which shows the start of the
    1: // ringbuffer. The insertion of pseudo frames can happen between every
    1: // two frames so we need to push and pop the pseudo frame data when children
    1: // of a frame are created.
    1: // The colgroup frame is special as it can harbour only col children.
    1: // Once all children of given frame are known, the pseudo frames can be
    1: // processed that means attached to the corresponding parent frames.
    1: // The behaviour is in general described at
    1: // http://www.w3.org/TR/CSS21/tables.html#anonymous-boxes
    1: // however there are implementation details that extend the CSS 2.1
    1: // specification:
    1: // 1. every table frame is wrapped in an outer table frame, which is always a
    1: //    pseudo frame.
    1: // 2. the outer table frame will be also created to hold a caption.
    1: // 3. each table cell will have a pseudo inner table cell frame.
    1: // 4. a colgroup frame is created between a column and a table
    1: // 5. a rowgroup frame is created between a row and a table
    1: // A table frame can only have rowgroups or column groups as children.
    1: // A outer table frame can only have one caption and one table frame
    1: // as children.
    1: // Every table even if all table frames are specified will require the
    1: // creation of two types of pseudo frames: the outer table frame and the inner
    1: // table cell frames.
    1: 
    1: struct nsPseudoFrameData {
    1:   nsIFrame*    mFrame; // created pseudo frame
    1:   nsFrameItems mChildList;  // child frames pending to be added to the pseudo
    1:   nsFrameItems mChildList2; // child frames pending to be added to the pseudo
    1: 
    1:   nsPseudoFrameData();
    1:   nsPseudoFrameData(nsPseudoFrameData& aOther);
    1:   void Reset();
    1: #ifdef DEBUG
    1:   void Dump();
    1: #endif
    1: };
    1: 
    1: struct nsPseudoFrames {
    1:   nsPseudoFrameData mTableOuter; 
    1:   nsPseudoFrameData mTableInner;  
    1:   nsPseudoFrameData mRowGroup;   
    1:   nsPseudoFrameData mColGroup;
    1:   nsPseudoFrameData mRow;   
    1:   nsPseudoFrameData mCellOuter;
    1:   nsPseudoFrameData mCellInner;
    1: 
    1:   // the frame type of the most descendant pseudo frame, no AddRef
    1:   nsIAtom*          mLowestType;
    1: 
    1:   nsPseudoFrames();
    1:   nsPseudoFrames& operator=(const nsPseudoFrames& aOther);
    1:   void Reset(nsPseudoFrames* aSave = nsnull);
    1:   PRBool IsEmpty() { return (!mLowestType && !mColGroup.mFrame); }
    1: #ifdef DEBUG
    1:   void Dump();
    1: #endif
    1: };
    1: 
    1: nsPseudoFrameData::nsPseudoFrameData()
    1: : mFrame(nsnull), mChildList(), mChildList2()
    1: {}
    1: 
    1: nsPseudoFrameData::nsPseudoFrameData(nsPseudoFrameData& aOther)
    1: : mFrame(aOther.mFrame), mChildList(aOther.mChildList), 
    1:   mChildList2(aOther.mChildList2)
    1: {}
    1: 
    1: void
    1: nsPseudoFrameData::Reset()
    1: {
    1:   mFrame = nsnull;
    1:   mChildList.childList  = mChildList.lastChild  = nsnull;
    1:   mChildList2.childList = mChildList2.lastChild = nsnull;
    1: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsPseudoFrameData::Dump()
    1: {
    1:   nsIFrame* main = nsnull;
    1:   nsIFrame* second = nsnull;
 3233:   printf("        %p\n", static_cast<void*>(mFrame));
    1:   main = mChildList.childList;
    1: 
    1:  
    1:   second = mChildList2.childList;
    1:   while (main || second) {
 3233:     printf("          %p   %p\n", static_cast<void*>(main),
 3233:            static_cast<void*>(second));
    1:     if (main)
    1:       main = main->GetNextSibling();
    1:     if (second)
    1:       second = second->GetNextSibling();
    1:   }
    1: }
    1: #endif
    1: nsPseudoFrames::nsPseudoFrames() 
    1: : mTableOuter(), mTableInner(), mRowGroup(), mColGroup(), 
    1:   mRow(), mCellOuter(), mCellInner(), mLowestType(nsnull)
    1: {}
    1: 
    1: nsPseudoFrames& nsPseudoFrames::operator=(const nsPseudoFrames& aOther)
    1: {
    1:   mTableOuter = aOther.mTableOuter;
    1:   mTableInner = aOther.mTableInner;
    1:   mColGroup   = aOther.mColGroup;
    1:   mRowGroup   = aOther.mRowGroup;
    1:   mRow        = aOther.mRow;
    1:   mCellOuter  = aOther.mCellOuter;
    1:   mCellInner  = aOther.mCellInner;
    1:   mLowestType = aOther.mLowestType;
    1: 
    1:   return *this;
    1: }
    1: void
    1: nsPseudoFrames::Reset(nsPseudoFrames* aSave) 
    1: {
    1:   if (aSave) {
    1:     *aSave = *this;
    1:   }
    1: 
    1:   mTableOuter.Reset();
    1:   mTableInner.Reset();
    1:   mColGroup.Reset();
    1:   mRowGroup.Reset();
    1:   mRow.Reset();
    1:   mCellOuter.Reset();
    1:   mCellInner.Reset();
    1:   mLowestType = nsnull;
    1: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsPseudoFrames::Dump()
    1: {
    1:   if (IsEmpty()) {
    1:     // check that it is really empty, warn otherwise
    1:     NS_ASSERTION(!mTableOuter.mFrame,    "Pseudo Outer Table Frame not empty");
    1:     NS_ASSERTION(!mTableOuter.mChildList.childList, "Pseudo Outer Table Frame has primary children");
    1:     NS_ASSERTION(!mTableOuter.mChildList2.childList,"Pseudo Outer Table Frame has secondary children");
    1:     NS_ASSERTION(!mTableInner.mFrame,    "Pseudo Inner Table Frame not empty");
    1:     NS_ASSERTION(!mTableInner.mChildList.childList, "Pseudo Inner Table Frame has primary children");
    1:     NS_ASSERTION(!mTableInner.mChildList2.childList,"Pseudo Inner Table Frame has secondary children");
    1:     NS_ASSERTION(!mColGroup.mFrame,      "Pseudo Colgroup Frame not empty");
    1:     NS_ASSERTION(!mColGroup.mChildList.childList,   "Pseudo Colgroup Table Frame has primary children");
    1:     NS_ASSERTION(!mColGroup.mChildList2.childList,  "Pseudo Colgroup Table Frame has secondary children");
    1:     NS_ASSERTION(!mRowGroup.mFrame,      "Pseudo Rowgroup Frame not empty");
    1:     NS_ASSERTION(!mRowGroup.mChildList.childList,   "Pseudo Rowgroup Frame has primary children");
    1:     NS_ASSERTION(!mRowGroup.mChildList2.childList,  "Pseudo Rowgroup Frame has secondary children");
    1:     NS_ASSERTION(!mRow.mFrame,           "Pseudo Row Frame not empty");
    1:     NS_ASSERTION(!mRow.mChildList.childList,        "Pseudo Row Frame has primary children");
    1:     NS_ASSERTION(!mRow.mChildList2.childList,       "Pseudo Row Frame has secondary children");
    1:     NS_ASSERTION(!mCellOuter.mFrame,     "Pseudo Outer Cell Frame not empty");
    1:     NS_ASSERTION(!mCellOuter.mChildList.childList,  "Pseudo Outer Cell Frame has primary children");
    1:     NS_ASSERTION(!mCellOuter.mChildList2.childList, "Pseudo Outer Cell Frame has secondary children");
    1:     NS_ASSERTION(!mCellInner.mFrame,     "Pseudo Inner Cell Frame not empty");
    1:     NS_ASSERTION(!mCellInner.mChildList.childList,  "Pseudo Inner Cell Frame has primary children");
    1:     NS_ASSERTION(!mCellInner.mChildList2.childList, "Pseudo inner Cell Frame has secondary children");
    1:   }
    1:   else {
    1:     if (mTableOuter.mFrame || mTableOuter.mChildList.childList || mTableOuter.mChildList2.childList) {
    1:       if (nsGkAtoms::tableOuterFrame == mLowestType) {
    1:         printf("LOW OuterTable\n");
    1:       }
    1:       else {
    1:         printf("    OuterTable\n");
    1:       }
    1:       mTableOuter.Dump();
    1:     }
    1:     if (mTableInner.mFrame || mTableInner.mChildList.childList || mTableInner.mChildList2.childList) {
    1:       if (nsGkAtoms::tableFrame == mLowestType) {
    1:         printf("LOW InnerTable\n");
    1:       }
    1:       else {
    1:         printf("    InnerTable\n");
    1:       }
    1:       mTableInner.Dump();
    1:     }
    1:     if (mColGroup.mFrame || mColGroup.mChildList.childList || mColGroup.mChildList2.childList) {
    1:       if (nsGkAtoms::tableColGroupFrame == mLowestType) {
    1:         printf("LOW ColGroup\n");
    1:       }
    1:       else {
    1:         printf("    ColGroup\n");
    1:       }
    1:       mColGroup.Dump();
    1:     }
    1:     if (mRowGroup.mFrame || mRowGroup.mChildList.childList || mRowGroup.mChildList2.childList) {
    1:       if (nsGkAtoms::tableRowGroupFrame == mLowestType) {
    1:         printf("LOW RowGroup\n");
    1:       }
    1:       else {
    1:         printf("    RowGroup\n");
    1:       }
    1:       mRowGroup.Dump();
    1:     }
    1:     if (mRow.mFrame || mRow.mChildList.childList || mRow.mChildList2.childList) {
    1:       if (nsGkAtoms::tableRowFrame == mLowestType) {
    1:         printf("LOW Row\n");
    1:       }
    1:       else {
    1:         printf("    Row\n");
    1:       }
    1:       mRow.Dump();
    1:     }
    1:     
    1:     if (mCellOuter.mFrame || mCellOuter.mChildList.childList || mCellOuter.mChildList2.childList) {
    1:       if (IS_TABLE_CELL(mLowestType)) {
    1:         printf("LOW OuterCell\n");
    1:       }
    1:       else {
    1:         printf("    OuterCell\n");
    1:       }
    1:       mCellOuter.Dump();
    1:     }
    1:     if (mCellInner.mFrame || mCellInner.mChildList.childList || mCellInner.mChildList2.childList) {
    1:       printf("    InnerCell\n");
    1:       mCellInner.Dump();
    1:     }
    1:   }
    1: }
    1: #endif
    1: // -----------------------------------------------------------
    1: 
    1: // Structure for saving the existing state when pushing/poping containing
    1: // blocks. The destructor restores the state to its previous state
    1: class nsFrameConstructorSaveState {
    1: public:
    1:   nsFrameConstructorSaveState();
    1:   ~nsFrameConstructorSaveState();
    1: 
    1: private:
    1:   nsAbsoluteItems* mItems;                // pointer to struct whose data we save/restore
19214:   PRBool*          mFixedPosIsAbsPos;
    1: 
    1:   nsAbsoluteItems  mSavedItems;           // copy of original data
19214:   PRBool           mSavedFixedPosIsAbsPos;
    1: 
    1:   // The name of the child list in which our frames would belong
    1:   nsIAtom* mChildListName;
    1:   nsFrameConstructorState* mState;
    1: 
    1:   friend class nsFrameConstructorState;
    1: };
    1: 
    1: // Structure used for maintaining state information during the
    1: // frame construction process
15599: class NS_STACK_CLASS nsFrameConstructorState {
    1: public:
    1:   nsPresContext            *mPresContext;
    1:   nsIPresShell             *mPresShell;
    1:   nsFrameManager           *mFrameManager;
    1: 
    1: #ifdef MOZ_XUL
    1:   // Frames destined for the nsGkAtoms::popupList.
    1:   nsAbsoluteItems           mPopupItems;
    1: #endif
    1: 
    1:   // Containing block information for out-of-flow frames.
    1:   nsAbsoluteItems           mFixedItems;
    1:   nsAbsoluteItems           mAbsoluteItems;
    1:   nsAbsoluteItems           mFloatedItems;
19214: 
19214:   // When working with the -moz-transform property, we want to hook
19214:   // the abs-pos and fixed-pos lists together, since transformed
19214:   // elements are fixed-pos containing blocks.  This flag determines
19214:   // whether or not we want to wire the fixed-pos and abs-pos lists
19214:   // together.
19214:   PRBool                    mFixedPosIsAbsPos;
19214: 
    1:   nsCOMPtr<nsILayoutHistoryState> mFrameState;
    1:   nsPseudoFrames            mPseudoFrames;
16976:   // These bits will be added to the state bits of any frame we construct
16976:   // using this state.
16976:   nsFrameState              mAdditionalStateBits; 
    1: 
    1:   // Constructor
    1:   // Use the passed-in history state.
    1:   nsFrameConstructorState(nsIPresShell*          aPresShell,
    1:                           nsIFrame*              aFixedContainingBlock,
    1:                           nsIFrame*              aAbsoluteContainingBlock,
    1:                           nsIFrame*              aFloatContainingBlock,
    1:                           nsILayoutHistoryState* aHistoryState);
    1:   // Get the history state from the pres context's pres shell.
    1:   nsFrameConstructorState(nsIPresShell*          aPresShell,
    1:                           nsIFrame*              aFixedContainingBlock,
    1:                           nsIFrame*              aAbsoluteContainingBlock,
    1:                           nsIFrame*              aFloatContainingBlock);
    1: 
    1:   ~nsFrameConstructorState();
    1:   
    1:   // Function to push the existing absolute containing block state and
    1:   // create a new scope. Code that uses this function should get matching
    1:   // logic in GetAbsoluteContainingBlock.
    1:   void PushAbsoluteContainingBlock(nsIFrame* aNewAbsoluteContainingBlock,
    1:                                    nsFrameConstructorSaveState& aSaveState);
    1: 
    1:   // Function to push the existing float containing block state and
    1:   // create a new scope. Code that uses this function should get matching
    1:   // logic in GetFloatContainingBlock.
    1:   // Pushing a null float containing block forbids any frames from being
    1:   // floated until a new float containing block is pushed.
    1:   // XXX we should get rid of null float containing blocks and teach the
    1:   // various frame classes to deal with floats instead.
    1:   void PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
23352:                                 nsFrameConstructorSaveState& aSaveState);
    1: 
    1:   // Function to return the proper geometric parent for a frame with display
    1:   // struct given by aStyleDisplay and parent's frame given by
23944:   // aContentParentFrame.
    1:   nsIFrame* GetGeometricParent(const nsStyleDisplay* aStyleDisplay,
    1:                                nsIFrame* aContentParentFrame);
    1: 
    1:   /**
    1:    * Function to add a new frame to the right frame list.  This MUST be called
    1:    * on frames before their children have been processed if the frames might
    1:    * conceivably be out-of-flow; otherwise cleanup in error cases won't work
    1:    * right.  Also, this MUST be called on frames after they have been
    1:    * initialized.
    1:    * @param aNewFrame the frame to add
    1:    * @param aFrameItems the list to add in-flow frames to
    1:    * @param aContent the content pointer for aNewFrame
 7807:    * @param aStyleContext the style context resolved for aContent
    1:    * @param aParentFrame the parent frame for the content if it were in-flow
    1:    * @param aCanBePositioned pass false if the frame isn't allowed to be
    1:    *        positioned
    1:    * @param aCanBeFloated pass false if the frame isn't allowed to be
    1:    *        floated
    1:    * @param aIsOutOfFlowPopup pass true if the frame is an out-of-flow popup
    1:    *        (XUL-only)
    1:    * @throws NS_ERROR_OUT_OF_MEMORY if it happens.
    1:    * @note If this method throws, that means that aNewFrame was not inserted
    1:    *       into any frame lists.  Furthermore, this method will handle cleanup
    1:    *       of aNewFrame (via calling CleanupFrameReferences() and Destroy() on
    1:    *       it).
    1:    */
    1:   nsresult AddChild(nsIFrame* aNewFrame,
    1:                     nsFrameItems& aFrameItems,
    1:                     nsIContent* aContent,
    1:                     nsStyleContext* aStyleContext,
    1:                     nsIFrame* aParentFrame,
    1:                     PRBool aCanBePositioned = PR_TRUE,
    1:                     PRBool aCanBeFloated = PR_TRUE,
    1:                     PRBool aIsOutOfFlowPopup = PR_FALSE,
    1:                     PRBool aInsertAfter = PR_FALSE,
    1:                     nsIFrame* aInsertAfterFrame = nsnull);
    1: 
19214:   /**
19214:    * Function to return the fixed-pos element list.  Normally this will just hand back the
19214:    * fixed-pos element list, but in case we're dealing with a transformed element that's
19214:    * acting as an abs-pos and fixed-pos container, we'll hand back the abs-pos list.  Callers should
19214:    * use this function if they want to get the list acting as the fixed-pos item parent.
19214:    */
19214:   nsAbsoluteItems& GetFixedItems()
19214:   {
19214:     return mFixedPosIsAbsPos ? mAbsoluteItems : mFixedItems;
19214:   }
19214:   const nsAbsoluteItems& GetFixedItems() const
19214:   {
19214:     return mFixedPosIsAbsPos ? mAbsoluteItems : mFixedItems;
19214:   }
19214: 
    1: protected:
    1:   friend class nsFrameConstructorSaveState;
    1: 
    1:   /**
    1:    * ProcessFrameInsertions takes the frames in aFrameItems and adds them as
    1:    * kids to the aChildListName child list of |aFrameItems.containingBlock|.
    1:    */
    1:   void ProcessFrameInsertions(nsAbsoluteItems& aFrameItems,
    1:                               nsIAtom* aChildListName);
    1: };
    1: 
    1: nsFrameConstructorState::nsFrameConstructorState(nsIPresShell*          aPresShell,
    1:                                                  nsIFrame*              aFixedContainingBlock,
    1:                                                  nsIFrame*              aAbsoluteContainingBlock,
    1:                                                  nsIFrame*              aFloatContainingBlock,
    1:                                                  nsILayoutHistoryState* aHistoryState)
    1:   : mPresContext(aPresShell->GetPresContext()),
    1:     mPresShell(aPresShell),
    1:     mFrameManager(aPresShell->FrameManager()),
    1: #ifdef MOZ_XUL    
23951:     mPopupItems(nsnull),
    1: #endif
    1:     mFixedItems(aFixedContainingBlock),
    1:     mAbsoluteItems(aAbsoluteContainingBlock),
    1:     mFloatedItems(aFloatContainingBlock),
22341:     // See PushAbsoluteContaningBlock below
22341:     mFixedPosIsAbsPos(aAbsoluteContainingBlock &&
22341:                       aAbsoluteContainingBlock->GetStyleDisplay()->
22341:                         HasTransform()),
    1:     mFrameState(aHistoryState),
16976:     mPseudoFrames(),
16976:     mAdditionalStateBits(0)
    1: {
23951: #ifdef MOZ_XUL
23951:   nsIRootBox* rootBox = nsIRootBox::GetRootBox(aPresShell);
23951:   if (rootBox) {
23951:     mPopupItems.containingBlock = rootBox->GetPopupSetFrame();
23951:   }
23951: #endif
 5327:   MOZ_COUNT_CTOR(nsFrameConstructorState);
    1: }
    1: 
    1: nsFrameConstructorState::nsFrameConstructorState(nsIPresShell* aPresShell,
    1:                                                  nsIFrame*     aFixedContainingBlock,
    1:                                                  nsIFrame*     aAbsoluteContainingBlock,
    1:                                                  nsIFrame*     aFloatContainingBlock)
    1:   : mPresContext(aPresShell->GetPresContext()),
    1:     mPresShell(aPresShell),
    1:     mFrameManager(aPresShell->FrameManager()),
    1: #ifdef MOZ_XUL    
23951:     mPopupItems(nsnull),
    1: #endif
    1:     mFixedItems(aFixedContainingBlock),
    1:     mAbsoluteItems(aAbsoluteContainingBlock),
    1:     mFloatedItems(aFloatContainingBlock),
22341:     // See PushAbsoluteContaningBlock below
22341:     mFixedPosIsAbsPos(aAbsoluteContainingBlock &&
22341:                       aAbsoluteContainingBlock->GetStyleDisplay()->
22341:                         HasTransform()),
16976:     mPseudoFrames(),
16976:     mAdditionalStateBits(0)
    1: {
23951: #ifdef MOZ_XUL
23951:   nsIRootBox* rootBox = nsIRootBox::GetRootBox(aPresShell);
23951:   if (rootBox) {
23951:     mPopupItems.containingBlock = rootBox->GetPopupSetFrame();
23951:   }
23951: #endif
 5327:   MOZ_COUNT_CTOR(nsFrameConstructorState);
    1:   mFrameState = aPresShell->GetDocument()->GetLayoutHistoryState();
    1: }
    1: 
    1: nsFrameConstructorState::~nsFrameConstructorState()
    1: {
    1:   // Frame order comparison functions only work properly when the placeholders
    1:   // have been inserted into the frame tree. So for example if we have a new float
    1:   // containing the placeholder for a new abs-pos frame, and we process the abs-pos
    1:   // insertion first, then we won't be able to find the right place to insert in
    1:   // in the abs-pos list. So put floats in first, because they can contain placeholders
    1:   // for abs-pos and fixed-pos items whose containing blocks are outside the floats.
    1:   // Then put abs-pos frames in, because they can contain placeholders for fixed-pos
    1:   // items whose containing block is outside the abs-pos frames. 
 5327:   MOZ_COUNT_DTOR(nsFrameConstructorState);
    1:   ProcessFrameInsertions(mFloatedItems, nsGkAtoms::floatList);
    1:   ProcessFrameInsertions(mAbsoluteItems, nsGkAtoms::absoluteList);
    1:   ProcessFrameInsertions(mFixedItems, nsGkAtoms::fixedList);
    1: #ifdef MOZ_XUL
    1:   ProcessFrameInsertions(mPopupItems, nsGkAtoms::popupList);
    1: #endif
    1: }
    1: 
    1: static nsIFrame*
 7680: AdjustAbsoluteContainingBlock(nsIFrame* aContainingBlockIn)
    1: {
    1:   if (!aContainingBlockIn) {
    1:     return nsnull;
    1:   }
    1:   
 7680:   // Always use the container's first continuation. (Inline frames can have
 7680:   // non-fluid bidi continuations...)
 7680:   return aContainingBlockIn->GetFirstContinuation();
    1: }
    1: 
    1: void
    1: nsFrameConstructorState::PushAbsoluteContainingBlock(nsIFrame* aNewAbsoluteContainingBlock,
    1:                                                      nsFrameConstructorSaveState& aSaveState)
    1: {
    1:   aSaveState.mItems = &mAbsoluteItems;
    1:   aSaveState.mSavedItems = mAbsoluteItems;
    1:   aSaveState.mChildListName = nsGkAtoms::absoluteList;
    1:   aSaveState.mState = this;
19214: 
19214:   /* Store whether we're wiring the abs-pos and fixed-pos lists together. */
19214:   aSaveState.mFixedPosIsAbsPos = &mFixedPosIsAbsPos;
19214:   aSaveState.mSavedFixedPosIsAbsPos = mFixedPosIsAbsPos;
19214: 
    1:   mAbsoluteItems = 
 7680:     nsAbsoluteItems(AdjustAbsoluteContainingBlock(aNewAbsoluteContainingBlock));
19214: 
19214:   /* See if we're wiring the fixed-pos and abs-pos lists together.  This happens iff
19214:    * we're a transformed element.
19214:    */
19214:   mFixedPosIsAbsPos = (aNewAbsoluteContainingBlock &&
19214:                        aNewAbsoluteContainingBlock->GetStyleDisplay()->HasTransform());
    1: }
    1: 
    1: void
    1: nsFrameConstructorState::PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
23352:                                                   nsFrameConstructorSaveState& aSaveState)
23352: {
    1:   NS_PRECONDITION(!aNewFloatContainingBlock ||
23352:                   aNewFloatContainingBlock->IsFloatContainingBlock(),
    1:                   "Please push a real float containing block!");
    1:   aSaveState.mItems = &mFloatedItems;
    1:   aSaveState.mSavedItems = mFloatedItems;
    1:   aSaveState.mChildListName = nsGkAtoms::floatList;
    1:   aSaveState.mState = this;
    1:   mFloatedItems = nsAbsoluteItems(aNewFloatContainingBlock);
    1: }
    1: 
    1: nsIFrame*
    1: nsFrameConstructorState::GetGeometricParent(const nsStyleDisplay* aStyleDisplay,
    1:                                             nsIFrame* aContentParentFrame)
    1: {
    1:   NS_PRECONDITION(aStyleDisplay, "Must have display struct!");
    1: 
    1:   // If there is no container for a fixed, absolute, or floating root
    1:   // frame, we will ignore the positioning.  This hack is originally
    1:   // brought to you by the letter T: tables, since other roots don't
    1:   // even call into this code.  See bug 178855.
    1:   //
    1:   // XXX Disabling positioning in this case is a hack.  If one was so inclined,
    1:   // one could support this either by (1) inserting a dummy block between the
    1:   // table and the canvas or (2) teaching the canvas how to reflow positioned
    1:   // elements. (1) has the usual problems when multiple frames share the same
    1:   // content (notice all the special cases in this file dealing with inner
    1:   // tables and outer tables which share the same content). (2) requires some
    1:   // work and possible factoring.
    1:   //
    1:   // XXXbz couldn't we just force position to "static" on roots and
    1:   // float to "none"?  That's OK per CSS 2.1, as far as I can tell.
    1:   
    1:   if (aStyleDisplay->IsFloating() && mFloatedItems.containingBlock) {
    1:     NS_ASSERTION(!aStyleDisplay->IsAbsolutelyPositioned(),
    1:                  "Absolutely positioned _and_ floating?");
    1:     return mFloatedItems.containingBlock;
    1:   }
    1: 
    1:   if (aStyleDisplay->mPosition == NS_STYLE_POSITION_ABSOLUTE &&
    1:       mAbsoluteItems.containingBlock) {
    1:     return mAbsoluteItems.containingBlock;
    1:   }
    1: 
    1:   if (aStyleDisplay->mPosition == NS_STYLE_POSITION_FIXED &&
19214:       GetFixedItems().containingBlock) {
19214:     return GetFixedItems().containingBlock;
    1:   }
    1: 
    1:   return aContentParentFrame;
    1: }
    1: 
    1: nsresult
    1: nsFrameConstructorState::AddChild(nsIFrame* aNewFrame,
    1:                                   nsFrameItems& aFrameItems,
    1:                                   nsIContent* aContent,
    1:                                   nsStyleContext* aStyleContext,
    1:                                   nsIFrame* aParentFrame,
    1:                                   PRBool aCanBePositioned,
    1:                                   PRBool aCanBeFloated,
    1:                                   PRBool aIsOutOfFlowPopup,
    1:                                   PRBool aInsertAfter,
    1:                                   nsIFrame* aInsertAfterFrame)
    1: {
 8199:   const nsStyleDisplay* disp = aNewFrame->GetStyleDisplay();
 7807:   
    1:   // The comments in GetGeometricParent regarding root table frames
    1:   // all apply here, unfortunately.
    1: 
    1:   PRBool needPlaceholder = PR_FALSE;
    1:   nsFrameItems* frameItems = &aFrameItems;
    1: #ifdef MOZ_XUL
    1:   if (NS_UNLIKELY(aIsOutOfFlowPopup)) {
    1:       NS_ASSERTION(aNewFrame->GetParent() == mPopupItems.containingBlock,
    1:                    "Popup whose parent is not the popup containing block?");
    1:       NS_ASSERTION(mPopupItems.containingBlock, "Must have a popup set frame!");
    1:       needPlaceholder = PR_TRUE;
    1:       frameItems = &mPopupItems;
    1:   }
    1:   else
    1: #endif // MOZ_XUL
 8199:   if (aCanBeFloated && disp->IsFloating() &&
    1:       mFloatedItems.containingBlock) {
    1:     NS_ASSERTION(aNewFrame->GetParent() == mFloatedItems.containingBlock,
    1:                  "Float whose parent is not the float containing block?");
    1:     needPlaceholder = PR_TRUE;
    1:     frameItems = &mFloatedItems;
    1:   }
    1:   else if (aCanBePositioned) {
 8199:     if (disp->mPosition == NS_STYLE_POSITION_ABSOLUTE &&
    1:         mAbsoluteItems.containingBlock) {
    1:       NS_ASSERTION(aNewFrame->GetParent() == mAbsoluteItems.containingBlock,
    1:                    "Abs pos whose parent is not the abs pos containing block?");
    1:       needPlaceholder = PR_TRUE;
    1:       frameItems = &mAbsoluteItems;
    1:     }
 8199:     if (disp->mPosition == NS_STYLE_POSITION_FIXED &&
19214:         GetFixedItems().containingBlock) {
19214:       NS_ASSERTION(aNewFrame->GetParent() == GetFixedItems().containingBlock,
    1:                    "Fixed pos whose parent is not the fixed pos containing block?");
    1:       needPlaceholder = PR_TRUE;
19214:       frameItems = &GetFixedItems();
    1:     }
    1:   }
    1: 
    1:   if (needPlaceholder) {
    1:     NS_ASSERTION(frameItems != &aFrameItems,
    1:                  "Putting frame in-flow _and_ want a placeholder?");
    1:     nsIFrame* placeholderFrame;
    1:     nsresult rv =
    1:       nsCSSFrameConstructor::CreatePlaceholderFrameFor(mPresShell,
    1:                                                        aContent,
    1:                                                        aNewFrame,
    1:                                                        aStyleContext,
    1:                                                        aParentFrame,
 6219:                                                        nsnull,
    1:                                                        &placeholderFrame);
    1:     if (NS_FAILED(rv)) {
    1:       // Note that aNewFrame could be the top frame for a scrollframe setup,
    1:       // hence already set as the primary frame.  So we have to clean up here.
    1:       // But it shouldn't have any out-of-flow kids.
    1:       // XXXbz Maybe add a utility function to assert that?
    1:       CleanupFrameReferences(mFrameManager, aNewFrame);
    1:       aNewFrame->Destroy();
    1:       return rv;
    1:     }
    1: 
16976:     placeholderFrame->AddStateBits(mAdditionalStateBits);
    1:     // Add the placeholder frame to the flow
    1:     aFrameItems.AddChild(placeholderFrame);
    1:   }
    1: #ifdef DEBUG
    1:   else {
    1:     NS_ASSERTION(aNewFrame->GetParent() == aParentFrame,
    1:                  "In-flow frame has wrong parent");
    1:   }
    1: #endif
    1: 
    1:   if (aInsertAfter) {
    1:     frameItems->InsertChildAfter(aNewFrame, aInsertAfterFrame);
    1:   } else {
    1:     frameItems->AddChild(aNewFrame);
    1:   }
    1: 
    1:   // Now add the special siblings too.
    1:   nsIFrame* specialSibling = aNewFrame;
    1:   while (specialSibling && IsFrameSpecial(specialSibling)) {
 4696:     specialSibling = GetSpecialSibling(specialSibling);
    1:     if (specialSibling) {
    1:       NS_ASSERTION(frameItems == &aFrameItems,
    1:                    "IB split ending up in an out-of-flow childlist?");
    1:       frameItems->AddChild(specialSibling);
    1:     }
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameConstructorState::ProcessFrameInsertions(nsAbsoluteItems& aFrameItems,
    1:                                                 nsIAtom* aChildListName)
    1: {
    1: #define NS_NONXUL_LIST_TEST (&aFrameItems == &mFloatedItems &&             \
    1:                              aChildListName == nsGkAtoms::floatList)    || \
    1:                             (&aFrameItems == &mAbsoluteItems &&            \
    1:                              aChildListName == nsGkAtoms::absoluteList) || \
    1:                             (&aFrameItems == &mFixedItems &&               \
    1:                              aChildListName == nsGkAtoms::fixedList)
    1: #ifdef MOZ_XUL
    1:   NS_PRECONDITION(NS_NONXUL_LIST_TEST ||
    1:                   (&aFrameItems == &mPopupItems &&
    1:                    aChildListName == nsGkAtoms::popupList), 
    1:                   "Unexpected aFrameItems/aChildListName combination");
    1: #else
    1:   NS_PRECONDITION(NS_NONXUL_LIST_TEST,
    1:                   "Unexpected aFrameItems/aChildListName combination");
    1: #endif
    1: 
    1:   nsIFrame* firstNewFrame = aFrameItems.childList;
    1:   
    1:   if (!firstNewFrame) {
    1:     return;
    1:   }
    1:   
    1:   nsIFrame* containingBlock = aFrameItems.containingBlock;
    1: 
    1:   NS_ASSERTION(containingBlock,
    1:                "Child list without containing block?");
    1:   
    1:   // Insert the frames hanging out in aItems.  We can use SetInitialChildList()
    1:   // if the containing block hasn't been reflown yet (so NS_FRAME_FIRST_REFLOW
    1:   // is set) and doesn't have any frames in the aChildListName child list yet.
    1:   nsIFrame* firstChild = containingBlock->GetFirstChild(aChildListName);
    1:   nsresult rv = NS_OK;
    1:   if (!firstChild && (containingBlock->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
    1:     rv = containingBlock->SetInitialChildList(aChildListName, firstNewFrame);
    1:   } else {
    1:     // Note that whether the frame construction context is doing an append or
    1:     // not is not helpful here, since it could be appending to some frame in
    1:     // the middle of the document, which means we're not necessarily
    1:     // appending to the children of the containing block.
    1:     //
    1:     // We need to make sure the 'append to the end of document' case is fast.
    1:     // So first test the last child of the containing block
    1:     nsIFrame* lastChild = nsLayoutUtils::GetLastSibling(firstChild);
    1: 
    1:     // CompareTreePosition uses placeholder hierarchy for out of flow frames,
    1:     // so this will make out-of-flows respect the ordering of placeholders,
    1:     // which is great because it takes care of anonymous content.
    1:     if (!lastChild ||
    1:         nsLayoutUtils::CompareTreePosition(lastChild, firstNewFrame, containingBlock) < 0) {
    1:       // no lastChild, or lastChild comes before the new children, so just append
    1:       rv = containingBlock->AppendFrames(aChildListName, firstNewFrame);
    1:     } else {
    1:       nsIFrame* insertionPoint = nsnull;
    1:       // try the other children
    1:       for (nsIFrame* f = firstChild; f != lastChild; f = f->GetNextSibling()) {
    1:         PRInt32 compare =
    1:           nsLayoutUtils::CompareTreePosition(f, firstNewFrame, containingBlock);
    1:         if (compare > 0) {
    1:           // f comes after the new children, so stop here and insert after
    1:           // the previous frame
    1:           break;
    1:         }
    1:         insertionPoint = f;
    1:       }
    1: 
    1:       rv = containingBlock->InsertFrames(aChildListName, insertionPoint,
    1:                                          firstNewFrame);
    1:     }
    1:   }
    1:   aFrameItems.childList = nsnull;
    1:   // XXXbz And if NS_FAILED(rv), what?  I guess we need to clean up the list
    1:   // and deal with all the placeholders... but what if the placeholders aren't
    1:   // in the document yet?  Could that happen?
    1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Frames getting lost!");
    1: }
    1: 
    1: 
    1: nsFrameConstructorSaveState::nsFrameConstructorSaveState()
    1:   : mItems(nsnull),
19214:     mFixedPosIsAbsPos(nsnull),
    1:     mSavedItems(nsnull),
19214:     mSavedFixedPosIsAbsPos(PR_FALSE),
    1:     mChildListName(nsnull),
    1:     mState(nsnull)
    1: {
    1: }
    1: 
    1: nsFrameConstructorSaveState::~nsFrameConstructorSaveState()
    1: {
    1:   // Restore the state
    1:   if (mItems) {
    1:     NS_ASSERTION(mState, "Can't have mItems set without having a state!");
    1:     mState->ProcessFrameInsertions(*mItems, mChildListName);
    1:     *mItems = mSavedItems;
    1: #ifdef DEBUG
    1:     // We've transferred the child list, so drop the pointer we held to it.
    1:     // Note that this only matters for the assert in ~nsAbsoluteItems.
    1:     mSavedItems.childList = nsnull;
    1: #endif
    1:   }
19214:   if (mFixedPosIsAbsPos) {
19214:     *mFixedPosIsAbsPos = mSavedFixedPosIsAbsPos;
19214:   }
    1: }
    1: 
    1: static 
    1: PRBool IsBorderCollapse(nsIFrame* aFrame)
    1: {
    1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent()) {
    1:     if (nsGkAtoms::tableFrame == frame->GetType()) {
    1:       return ((nsTableFrame*)frame)->IsBorderCollapse();
    1:     }
    1:   }
    1:   NS_ASSERTION(PR_FALSE, "program error");
    1:   return PR_FALSE;
    1: }
    1: 
    1: /**
    1:  * Utility method, called from MoveChildrenTo(), that recursively
    1:  * descends down the frame hierarchy looking for floating frames that
    1:  * need parent pointer adjustments to account for the containment block
    1:  * changes that could occur as the result of the reparenting done in
    1:  * MoveChildrenTo().
    1:  */
    1: static void
    1: AdjustFloatParentPtrs(nsIFrame*                aFrame,
    1:                       nsFrameConstructorState& aState,
    1:                       nsFrameConstructorState& aOuterState)
    1: {
    1:   NS_PRECONDITION(aFrame, "must have frame to work with");
    1: 
    1:   nsIFrame *outOfFlowFrame = nsPlaceholderFrame::GetRealFrameFor(aFrame);
    1:   if (outOfFlowFrame != aFrame) {
    1:     if (outOfFlowFrame->GetStyleDisplay()->IsFloating()) {
    1:       // Update the parent pointer for outOfFlowFrame since its
    1:       // containing block has changed as the result of reparenting
    1:       // and move it from the outer state to the inner, bug 307277.
    1:       
    1:       nsIFrame *parent = aState.mFloatedItems.containingBlock;
    1:       NS_ASSERTION(parent, "Should have float containing block here!");
    1:       NS_ASSERTION(outOfFlowFrame->GetParent() == aOuterState.mFloatedItems.containingBlock,
    1:                    "expected the float to be a child of the outer CB");
    1: 
 4368:       if (aOuterState.mFloatedItems.RemoveChild(outOfFlowFrame, nsnull)) {
    1:         aState.mFloatedItems.AddChild(outOfFlowFrame);
    1:       } else {
    1:         NS_NOTREACHED("float wasn't in the outer state float list");
    1:       }
    1: 
    1:       outOfFlowFrame->SetParent(parent);
    1:       if (outOfFlowFrame->GetStateBits() &
    1:           (NS_FRAME_HAS_VIEW | NS_FRAME_HAS_CHILD_WITH_VIEW)) {
    1:         // We don't need to walk up the tree, since we're doing this
    1:         // recursively.
    1:         parent->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
    1:       }
    1:     }
    1: 
    1:     // All out-of-flows are automatically float containing blocks, so we're
    1:     // done here.
    1:     return;
    1:   }
    1: 
    1:   if (aFrame->IsFloatContainingBlock()) {
    1:     // No need to recurse further; floats whose placeholders are
    1:     // inside a block already have the right parent.
    1:     return;
    1:   }
    1: 
    1:   // Dive down into children to see if any of their
    1:   // placeholders need adjusting.
    1:   nsIFrame *childFrame = aFrame->GetFirstChild(nsnull);
    1:   while (childFrame) {
    1:     // XXX_kin: Do we need to prevent descent into anonymous content here?
    1: 
    1:     AdjustFloatParentPtrs(childFrame, aState, aOuterState);
    1:     childFrame = childFrame->GetNextSibling();
    1:   }
    1: }
    1: 
    1: /**
 4696:  * Moves frames to a new parent, updating the style context and propagating
 4696:  * relevant frame state bits. |aState| may be null, in which case the parent
    1:  * pointers of out-of-flow frames will remain untouched.
    1:  */
    1: static void
    1: MoveChildrenTo(nsFrameManager*          aFrameManager,
    1:                nsIFrame*                aNewParent,
    1:                nsIFrame*                aFrameList,
 5585:                nsIFrame*                aFrameListEnd,
    1:                nsFrameConstructorState* aState,
    1:                nsFrameConstructorState* aOuterState)
    1: {
    1:   PRBool setHasChildWithView = PR_FALSE;
    1: 
 5585:   while (aFrameList && aFrameList != aFrameListEnd) {
    1:     if (!setHasChildWithView
    1:         && (aFrameList->GetStateBits() & (NS_FRAME_HAS_VIEW | NS_FRAME_HAS_CHILD_WITH_VIEW))) {
    1:       setHasChildWithView = PR_TRUE;
    1:     }
    1: 
    1:     aFrameList->SetParent(aNewParent);
    1: 
    1:     // If aState is not null, the caller expects us to make adjustments so that
    1:     // floats whose placeholders are descendants of frames in aFrameList point
    1:     // to the correct parent.
    1:     if (aState) {
    1:       NS_ASSERTION(aOuterState, "need an outer state too");
    1:       AdjustFloatParentPtrs(aFrameList, *aState, *aOuterState);
    1:     }
    1: 
    1:     aFrameList = aFrameList->GetNextSibling();
    1:   }
    1: 
    1:   if (setHasChildWithView) {
 4696:     do {
    1:       aNewParent->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
 4696:       aNewParent = aNewParent->GetParent();
 4696:     } while (aNewParent &&
 4696:              !(aNewParent->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW));
    1:   }
    1: }
    1: 
    1: // -----------------------------------------------------------
    1: 
    1: 
    1: // Structure used to ensure that bindings are properly enqueued in the
    1: // binding manager's attached queue.
15599: struct NS_STACK_CLASS nsAutoEnqueueBinding
    1: {
    1:   nsAutoEnqueueBinding(nsIDocument* aDocument) :
    1:     mDocument(aDocument)
    1:   {}
    1: 
    1:   ~nsAutoEnqueueBinding();
    1: 
    1:   nsRefPtr<nsXBLBinding> mBinding;
    1: private:
    1:   nsIDocument* mDocument;
    1: };
    1: 
    1: nsAutoEnqueueBinding::~nsAutoEnqueueBinding()
    1: {
    1:   if (mBinding) {
    1:     mDocument->BindingManager()->AddToAttachedQueue(mBinding);
    1:   }
    1: }
    1: 
    1: 
    1: // Helper function that determines the child list name that aChildFrame
    1: // is contained in
    1: static nsIAtom*
    1: GetChildListNameFor(nsIFrame*       aChildFrame)
    1: {
    1:   nsIAtom*      listName;
    1: 
 6521:   if (aChildFrame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
 6521:     listName = nsGkAtoms::overflowContainersList;
 6521:   }
    1:   // See if the frame is moved out of the flow
 6521:   else if (aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
    1:     // Look at the style information to tell
    1:     const nsStyleDisplay* disp = aChildFrame->GetStyleDisplay();
    1:     
    1:     if (NS_STYLE_POSITION_ABSOLUTE == disp->mPosition) {
    1:       listName = nsGkAtoms::absoluteList;
    1:     } else if (NS_STYLE_POSITION_FIXED == disp->mPosition) {
21903:       if (nsLayoutUtils::IsReallyFixedPos(aChildFrame)) {
    1:         listName = nsGkAtoms::fixedList;
21903:       } else {
21903:         listName = nsGkAtoms::absoluteList;
21903:       }
    1: #ifdef MOZ_XUL
    1:     } else if (NS_STYLE_DISPLAY_POPUP == disp->mDisplay) {
    1:       // Out-of-flows that are DISPLAY_POPUP must be kids of the root popup set
    1: #ifdef DEBUG
    1:       nsIFrame* parent = aChildFrame->GetParent();
 3129:       NS_ASSERTION(parent && parent->GetType() == nsGkAtoms::popupSetFrame,
 3129:                    "Unexpected parent");
    1: #endif // DEBUG
    1: 
    1:       // XXX FIXME: Bug 350740
    1:       // Return here, because the postcondition for this function actually
    1:       // fails for this case, since the popups are not in a "real" frame list
    1:       // in the popup set.
    1:       return nsGkAtoms::popupList;      
    1: #endif // MOZ_XUL
    1:     } else {
    1:       NS_ASSERTION(aChildFrame->GetStyleDisplay()->IsFloating(),
    1:                    "not a floated frame");
    1:       listName = nsGkAtoms::floatList;
    1:     }
    1: 
    1:   } else {
    1:     listName = nsnull;
    1:   }
    1: 
    1: #ifdef NS_DEBUG
    1:   // Verify that the frame is actually in that child list or in the
    1:   // corresponding overflow list.
    1:   nsIFrame* parent = aChildFrame->GetParent();
    1:   PRBool found = nsFrameList(parent->GetFirstChild(listName))
    1:                    .ContainsFrame(aChildFrame);
    1:   if (!found) {
    1:     if (!(aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
    1:       found = nsFrameList(parent->GetFirstChild(nsGkAtoms::overflowList))
    1:                 .ContainsFrame(aChildFrame);
    1:     }
    1:     else if (aChildFrame->GetStyleDisplay()->IsFloating()) {
    1:       found = nsFrameList(parent->GetFirstChild(nsGkAtoms::overflowOutOfFlowList))
    1:                 .ContainsFrame(aChildFrame);
    1:     }
    1:     // else it's positioned and should have been on the 'listName' child list.
    1:     NS_POSTCONDITION(found, "not in child list");
    1:   }
    1: #endif
    1: 
    1:   return listName;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsCSSFrameConstructor::nsCSSFrameConstructor(nsIDocument *aDocument,
    1:                                              nsIPresShell *aPresShell)
    1:   : mDocument(aDocument)
    1:   , mPresShell(aPresShell)
    1:   , mInitialContainingBlock(nsnull)
16509:   , mRootElementStyleFrame(nsnull)
    1:   , mFixedContainingBlock(nsnull)
    1:   , mDocElementContainingBlock(nsnull)
    1:   , mGfxScrollFrame(nsnull)
    1:   , mPageSequenceFrame(nsnull)
    1:   , mUpdateCount(0)
22769:   , mFocusSuppressCount(0)
    1:   , mQuotesDirty(PR_FALSE)
    1:   , mCountersDirty(PR_FALSE)
    1:   , mIsDestroyingFrameTree(PR_FALSE)
10073:   , mRebuildAllStyleData(PR_FALSE)
18953:   , mHasRootAbsPosContainingBlock(PR_FALSE)
22471:   , mHoverGeneration(0)
22339:   , mRebuildAllExtraHint(nsChangeHint(0))
    1: {
    1:   // XXXbz this should be in Init() or something!
    1:   if (!mPendingRestyles.Init()) {
    1:     // now what?
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   static PRBool gFirstTime = PR_TRUE;
    1:   if (gFirstTime) {
    1:     gFirstTime = PR_FALSE;
    1:     char* flags = PR_GetEnv("GECKO_FRAMECTOR_DEBUG_FLAGS");
    1:     if (flags) {
    1:       PRBool error = PR_FALSE;
    1:       for (;;) {
    1:         char* comma = PL_strchr(flags, ',');
    1:         if (comma)
    1:           *comma = '\0';
    1: 
    1:         PRBool found = PR_FALSE;
    1:         FrameCtorDebugFlags* flag = gFlags;
    1:         FrameCtorDebugFlags* limit = gFlags + NUM_DEBUG_FLAGS;
    1:         while (flag < limit) {
    1:           if (PL_strcasecmp(flag->name, flags) == 0) {
    1:             *(flag->on) = PR_TRUE;
    1:             printf("nsCSSFrameConstructor: setting %s debug flag on\n", flag->name);
    1:             found = PR_TRUE;
    1:             break;
    1:           }
    1:           ++flag;
    1:         }
    1: 
    1:         if (! found)
    1:           error = PR_TRUE;
    1: 
    1:         if (! comma)
    1:           break;
    1: 
    1:         *comma = ',';
    1:         flags = comma + 1;
    1:       }
    1: 
    1:       if (error) {
    1:         printf("Here are the available GECKO_FRAMECTOR_DEBUG_FLAGS:\n");
    1:         FrameCtorDebugFlags* flag = gFlags;
    1:         FrameCtorDebugFlags* limit = gFlags + NUM_DEBUG_FLAGS;
    1:         while (flag < limit) {
    1:           printf("  %s\n", flag->name);
    1:           ++flag;
    1:         }
    1:         printf("Note: GECKO_FRAMECTOR_DEBUG_FLAGS is a comma separated list of flag\n");
    1:         printf("names (no whitespace)\n");
    1:       }
    1:     }
    1:   }
    1: #endif
    1: }
    1: 
    1: nsIXBLService * nsCSSFrameConstructor::GetXBLService()
    1: {
    1:   if (!gXBLService) {
    1:     nsresult rv = CallGetService("@mozilla.org/xbl;1", &gXBLService);
    1:     if (NS_FAILED(rv))
    1:       gXBLService = nsnull;
    1:   }
    1:   
    1:   return gXBLService;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::NotifyDestroyingFrame(nsIFrame* aFrame)
    1: {
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while destroying frames");
 6518: 
16477:   if (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) {
16477:     if (mQuoteList.DestroyNodesFor(aFrame))
    1:       QuotesDirty();
    1:   }
16477: 
16477:   if (mCounterManager.DestroyNodesFor(aFrame)) {
    1:     // Technically we don't need to update anything if we destroyed only
    1:     // USE nodes.  However, this is unlikely to happen in the real world
    1:     // since USE nodes generally go along with INCREMENT nodes.
    1:     CountersDirty();
    1:   }
    1: }
16477: 
16976: struct nsGenConInitializer {
16976:   nsAutoPtr<nsGenConNode> mNode;
16976:   nsGenConList*           mList;
16976:   void (nsCSSFrameConstructor::*mDirtyAll)();
16976:   
16976:   nsGenConInitializer(nsGenConNode* aNode, nsGenConList* aList,
16976:                       void (nsCSSFrameConstructor::*aDirtyAll)())
16976:     : mNode(aNode), mList(aList), mDirtyAll(aDirtyAll) {}
16976: };
16976: 
16976: static void
16976: DestroyGenConInitializer(void*    aFrame,
16976:                          nsIAtom* aPropertyName,
16976:                          void*    aPropertyValue,
16976:                          void*    aDtorData)
16976: {
16976:   delete static_cast<nsGenConInitializer*>(aPropertyValue);
16976: }
16976: 
16976: already_AddRefed<nsIContent>
16976: nsCSSFrameConstructor::CreateGenConTextNode(const nsString& aString,
16976:                                             nsCOMPtr<nsIDOMCharacterData>* aText,
16976:                                             nsGenConInitializer* aInitializer)
16976: {
16976:   nsCOMPtr<nsIContent> content;
16976:   NS_NewTextNode(getter_AddRefs(content), mDocument->NodeInfoManager());
16976:   if (!content) {
16976:     // XXX The quotes/counters code doesn't like the text pointer
16976:     // being null in case of dynamic changes!
16976:     NS_ASSERTION(!aText, "this OOM case isn't handled very well");
16976:     return nsnull;
16976:   }
16976:   content->SetText(aString, PR_FALSE);
16976:   if (aText) {
16976:     *aText = do_QueryInterface(content);
16976:   }
16976:   if (aInitializer) {
16976:     content->SetProperty(nsGkAtoms::genConInitializerProperty, aInitializer,
16976:                          DestroyGenConInitializer);
16976:   }
16976:   return content.forget();
16976: }
16976: 
16976: already_AddRefed<nsIContent>
16976: nsCSSFrameConstructor::CreateGeneratedContent(nsIContent*     aParentContent,
16477:                                               nsStyleContext* aStyleContext,
16976:                                               PRUint32        aContentIndex)
16976: {
    1:   // Get the content value
16976:   const nsStyleContentData &data =
16976:     aStyleContext->GetStyleContent()->ContentAt(aContentIndex);
    1:   nsStyleContentType type = data.mType;
    1: 
    1:   if (eStyleContentType_Image == type) {
    1:     if (!data.mContent.mImage) {
    1:       // CSS had something specified that couldn't be converted to an
    1:       // image object
16976:       return nsnull;
    1:     }
    1:     
    1:     // Create an image content object and pass it the image request.
    1:     // XXX Check if it's an image type we can handle...
    1: 
    1:     nsCOMPtr<nsINodeInfo> nodeInfo;
19197:     nodeInfo = mDocument->NodeInfoManager()->GetNodeInfo(nsGkAtoms::mozgeneratedcontentimage, nsnull,
19197:                                                          kNameSpaceID_XHTML);
    1: 
16976:     nsCOMPtr<nsIContent> content;
16976:     NS_NewGenConImageContent(getter_AddRefs(content), nodeInfo,
    1:                              data.mContent.mImage);
16976:     return content.forget();
16976:   }
    1: 
    1:   switch (type) {
    1:   case eStyleContentType_String:
16976:     return CreateGenConTextNode(nsDependentString(data.mContent.mString), nsnull,
16976:                                 nsnull);
    1: 
    1:   case eStyleContentType_Attr:
    1:     {
    1:       nsCOMPtr<nsIAtom> attrName;
    1:       PRInt32 attrNameSpace = kNameSpaceID_None;
16976:       nsAutoString contentString(data.mContent.mString);
    1:       PRInt32 barIndex = contentString.FindChar('|'); // CSS namespace delimiter
    1:       if (-1 != barIndex) {
    1:         nsAutoString  nameSpaceVal;
    1:         contentString.Left(nameSpaceVal, barIndex);
    1:         PRInt32 error;
    1:         attrNameSpace = nameSpaceVal.ToInteger(&error, 10);
    1:         contentString.Cut(0, barIndex + 1);
    1:         if (contentString.Length()) {
    1:           attrName = do_GetAtom(contentString);
    1:         }
    1:       }
    1:       else {
    1:         attrName = do_GetAtom(contentString);
    1:       }
    1: 
    1:       if (!attrName) {
16976:         return nsnull;
16976:       }
16976: 
16976:       nsCOMPtr<nsIContent> content;
16976:       NS_NewAttributeContent(mDocument->NodeInfoManager(),
16976:                              attrNameSpace, attrName, getter_AddRefs(content));
16976:       return content.forget();
16976:     }
    1:   
    1:   case eStyleContentType_Counter:
    1:   case eStyleContentType_Counters:
    1:     {
    1:       nsCSSValue::Array* counters = data.mContent.mCounters;
    1:       nsCounterList* counterList = mCounterManager.CounterListFor(
    1:           nsDependentString(counters->Item(0).GetStringBufferValue()));
    1:       if (!counterList)
16976:         return nsnull;
    1: 
    1:       nsCounterUseNode* node =
16976:         new nsCounterUseNode(counters, aContentIndex,
16477:                              type == eStyleContentType_Counters);
    1:       if (!node)
16976:         return nsnull;
16976: 
16976:       nsGenConInitializer* initializer =
16976:         new nsGenConInitializer(node, counterList,
16976:                                 &nsCSSFrameConstructor::CountersDirty);
16976:       return CreateGenConTextNode(EmptyString(), &node->mText, initializer);
16976:     }
    1: 
    1:   case eStyleContentType_Image:
    1:     NS_NOTREACHED("handled by if above");
16976:     return nsnull;
    1: 
    1:   case eStyleContentType_OpenQuote:
    1:   case eStyleContentType_CloseQuote:
    1:   case eStyleContentType_NoOpenQuote:
    1:   case eStyleContentType_NoCloseQuote:
    1:     {
16976:       nsQuoteNode* node =
16976:         new nsQuoteNode(type, aContentIndex);
    1:       if (!node)
16976:         return nsnull;
16976: 
16976:       nsGenConInitializer* initializer =
16976:         new nsGenConInitializer(node, &mQuoteList,
16976:                                 &nsCSSFrameConstructor::QuotesDirty);
16976:       return CreateGenConTextNode(EmptyString(), &node->mText, initializer);
16976:     }
    1:   
    1:   case eStyleContentType_AltContent:
    1:     {
    1:       // Use the "alt" attribute; if that fails and the node is an HTML
    1:       // <input>, try the value attribute and then fall back to some default
    1:       // localized text we have.
16976:       // XXX what if the 'alt' attribute is added later, how will we
16976:       // detect that and do the right thing here?
16976:       if (aParentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::alt)) {
16976:         nsCOMPtr<nsIContent> content;
16976:         NS_NewAttributeContent(mDocument->NodeInfoManager(),
16976:                                kNameSpaceID_None, nsGkAtoms::alt, getter_AddRefs(content));
16976:         return content.forget();
16976:       }
16976: 
16976:       if (aParentContent->IsNodeOfType(nsINode::eHTML) &&
16976:           aParentContent->NodeInfo()->Equals(nsGkAtoms::input)) {
16976:         if (aParentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
16976:           nsCOMPtr<nsIContent> content;
16976:           NS_NewAttributeContent(mDocument->NodeInfoManager(),
16976:                                  kNameSpaceID_None, nsGkAtoms::value, getter_AddRefs(content));
16976:           return content.forget();
16976:         }
16976: 
    1:         nsXPIDLString temp;
16976:         nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
    1:                                            "Submit", temp);
16976:         return CreateGenConTextNode(temp, nsnull, nsnull);
16976:       }
16976: 
    1:       break;
16976:     }
    1:   } // switch
    1: 
16976:   return nsnull;
16976: }
16976: 
16976: static void DestroyContent(void *aObject,
16976:                            nsIAtom *aPropertyName,
16976:                            void *aPropertyValue,
16976:                            void *aData)
16976: {
16976:   nsIContent* content = static_cast<nsIContent*>(aPropertyValue);
16976:   content->UnbindFromTree();
16976:   NS_RELEASE(content);
    1: }
    1: 
    1: /*
16976:  * aParentFrame - the frame that should be the parent of the generated
    1:  *   content.  This is the frame for the corresponding content node,
    1:  *   which must not be a leaf frame.
16976:  * 
16976:  * Any frames created are added to aFrameItems (or possibly left
16976:  * in the table pseudoframe state in aState).
16976:  * 
16976:  * We create an XML element (tag _moz_generated_content_before or
16976:  * _moz_generated_content_after) representing the pseudoelement. We
16976:  * create a DOM node for each 'content' item and make those nodes the
16976:  * children of the XML element. Then we create a frame subtree for
16976:  * the XML element as if it were a regular child of
16976:  * aParentFrame/aParentContent, giving the XML element the ::before or
16976:  * ::after style.
    1:  */
16976: void
    1: nsCSSFrameConstructor::CreateGeneratedContentFrame(nsFrameConstructorState& aState,
16976:                                                    nsIFrame*        aParentFrame,
16976:                                                    nsIContent*      aParentContent,
    1:                                                    nsStyleContext*  aStyleContext,
    1:                                                    nsIAtom*         aPseudoElement,
16976:                                                    nsFrameItems&    aFrameItems)
16976: {
16976:   if (!aParentContent->IsNodeOfType(nsINode::eELEMENT))
16976:     return;
    1: 
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1: 
    1:   // Probe for the existence of the pseudo-element
    1:   nsRefPtr<nsStyleContext> pseudoStyleContext;
16976:   pseudoStyleContext = styleSet->ProbePseudoStyleFor(aParentContent,
    1:                                                      aPseudoElement,
    1:                                                      aStyleContext);
16976:   if (!pseudoStyleContext)
16976:     return;
16976:   // |ProbePseudoStyleFor| checked the 'display' property and the
    1:   // |ContentCount()| of the 'content' property for us.
16976:   nsCOMPtr<nsINodeInfo> nodeInfo;
16976:   nsIAtom* elemName = aPseudoElement == nsCSSPseudoElements::before ?
16976:     nsGkAtoms::mozgeneratedcontentbefore : nsGkAtoms::mozgeneratedcontentafter;
19197:   nodeInfo = mDocument->NodeInfoManager()->GetNodeInfo(elemName, nsnull,
19197:                                                        kNameSpaceID_None);
16976:   nsIContent* container;
16976:   nsresult rv = NS_NewXMLElement(&container, nodeInfo);
16976:   if (NS_FAILED(rv))
16976:     return;
16976:   container->SetNativeAnonymous();
16976:   // Transfer ownership to the frame
16976:   aParentFrame->SetProperty(aPseudoElement, container, DestroyContent);
16976: 
16976:   rv = container->BindToTree(mDocument, aParentContent, aParentContent, PR_TRUE);
16976:   if (NS_FAILED(rv)) {
16976:     container->UnbindFromTree();
16976:     return;
16976:   }
16976: 
16976:   PRUint32 contentCount = pseudoStyleContext->GetStyleContent()->ContentCount();
    1:   for (PRUint32 contentIndex = 0; contentIndex < contentCount; contentIndex++) {
16976:     nsCOMPtr<nsIContent> content =
16976:       CreateGeneratedContent(aParentContent, pseudoStyleContext, contentIndex);
16976:     if (content) {
16976:       container->AppendChildTo(content, PR_FALSE);
16976:     }
16976:   }
16976: 
16976:   nsFrameState savedStateBits = aState.mAdditionalStateBits;
16976:   // Ensure that frames created here are all tagged with
16976:   // NS_FRAME_GENERATED_CONTENT.
16976:   aState.mAdditionalStateBits |= NS_FRAME_GENERATED_CONTENT;
16976: 
16976:   ConstructFrameInternal(aState, container, aParentFrame,
16976:     elemName, kNameSpaceID_None, pseudoStyleContext, aFrameItems, PR_TRUE);
16976:   aState.mAdditionalStateBits = savedStateBits;
    1: }
    1: 
    1: static PRBool
    1: TextIsOnlyWhitespace(nsIContent* aContent)
    1: {
    1:   return aContent->IsNodeOfType(nsINode::eTEXT) &&
    1:          aContent->TextIsOnlyWhitespace();
    1: }
    1:     
    1: /****************************************************
    1:  **  BEGIN TABLE SECTION
    1:  ****************************************************/
    1: 
    1: // The term pseudo frame is being used instead of anonymous frame, since anonymous
    1: // frame has been used elsewhere to refer to frames that have generated content
    1: 
    1: // aIncludeSpecial applies to captions, col groups, cols and cells.
    1: // These do not generate pseudo frame wrappers for foreign children. 
    1: 
    1: static PRBool
    1: IsTableRelated(PRUint8 aDisplay,
    1:                PRBool  aIncludeSpecial) 
    1: {
    1:   if ((aDisplay == NS_STYLE_DISPLAY_TABLE)              ||
    1:       (aDisplay == NS_STYLE_DISPLAY_INLINE_TABLE)       ||
    1:       (aDisplay == NS_STYLE_DISPLAY_TABLE_HEADER_GROUP) ||
    1:       (aDisplay == NS_STYLE_DISPLAY_TABLE_ROW_GROUP)    ||
    1:       (aDisplay == NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP) ||
    1:       (aDisplay == NS_STYLE_DISPLAY_TABLE_ROW)) {
    1:     return PR_TRUE;
    1:   }
    1:   else if (aIncludeSpecial && 
    1:            ((aDisplay == NS_STYLE_DISPLAY_TABLE_CAPTION)      ||
    1:             (aDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP) ||
    1:             (aDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN)       ||
    1:             (aDisplay == NS_STYLE_DISPLAY_TABLE_CELL))) {
    1:     return PR_TRUE;
    1:   }
    1:   else return PR_FALSE;
    1: }
    1: 
    1: static PRBool
    1: IsTableRelated(nsIAtom* aParentType,
    1:                PRBool   aIncludeSpecial)
    1: {
    1:   if ((nsGkAtoms::tableFrame         == aParentType)  ||
    1:       (nsGkAtoms::tableRowGroupFrame == aParentType)  ||
    1:       (nsGkAtoms::tableRowFrame      == aParentType)) {
    1:     return PR_TRUE;
    1:   }
    1:   else if (aIncludeSpecial && 
    1:            ((nsGkAtoms::tableCaptionFrame  == aParentType)  ||
    1:             (nsGkAtoms::tableColGroupFrame == aParentType)  ||
    1:             (nsGkAtoms::tableColFrame      == aParentType)  ||
    1:             IS_TABLE_CELL(aParentType))) {
    1:     return PR_TRUE;
    1:   }
    1:   else return PR_FALSE;
    1: }
    1:            
    1: static nsIFrame*
    1: AdjustCaptionParentFrame(nsIFrame* aParentFrame) 
    1: {
    1:   if (nsGkAtoms::tableFrame == aParentFrame->GetType()) {
    1:     return aParentFrame->GetParent();;
    1:   }
    1:   return aParentFrame;
    1: }
    1:  
    1: /**
    1:  * If the parent frame is a |tableFrame| and the child is a
    1:  * |captionFrame|, then we want to insert the frames beneath the
    1:  * |tableFrame|'s parent frame. Returns |PR_TRUE| if the parent frame
    1:  * needed to be fixed up.
    1:  */
    1: static PRBool
    1: GetCaptionAdjustedParent(nsIFrame*        aParentFrame,
    1:                          const nsIFrame*  aChildFrame,
    1:                          nsIFrame**       aAdjParentFrame)
    1: {
    1:   *aAdjParentFrame = aParentFrame;
    1:   PRBool haveCaption = PR_FALSE;
    1: 
    1:   if (nsGkAtoms::tableCaptionFrame == aChildFrame->GetType()) {
    1:     haveCaption = PR_TRUE;
    1:     *aAdjParentFrame = AdjustCaptionParentFrame(aParentFrame);
    1:   }
    1:   return haveCaption;
    1: }
    1:    
    1: static nsresult 
    1: ProcessPseudoFrame(nsPseudoFrameData& aPseudoData,
    1:                    nsIFrame*&         aParent)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   aParent = aPseudoData.mFrame;
    1:   nsFrameItems* items = &aPseudoData.mChildList;
    1:   if (items && items->childList) {
    1:     rv = aParent->SetInitialChildList(nsnull, items->childList);
    1:     if (NS_FAILED(rv)) return rv;
    1:   }
    1:   aPseudoData.Reset();
    1:   return rv;
    1: }
    1: 
    1: static nsresult 
    1: ProcessPseudoRowGroupFrame(nsPseudoFrameData& aPseudoData,
    1:                            nsIFrame*&         aParent)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   aParent = aPseudoData.mFrame;
    1:   nsFrameItems* items = &aPseudoData.mChildList;
    1:   if (items && items->childList) {
    1:     nsTableRowGroupFrame* rgFrame = nsTableFrame::GetRowGroupFrame(aParent);
    1:     rv = rgFrame->SetInitialChildList(nsnull, items->childList);
    1:     if (NS_FAILED(rv)) return rv;
    1:   }
    1:   aPseudoData.Reset();
    1:   return rv;
    1: }
    1: 
    1: static nsresult 
    1: ProcessPseudoTableFrame(nsPseudoFrames& aPseudoFrames,
    1:                         nsIFrame*&      aParent)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   // process the col group frame, if it exists
    1:   if (aPseudoFrames.mColGroup.mFrame) {
    1:     rv = ProcessPseudoFrame(aPseudoFrames.mColGroup, aParent);
    1:   }
    1: 
    1:   // process the inner table frame
    1:   rv = ProcessPseudoFrame(aPseudoFrames.mTableInner, aParent);
    1: 
    1:   // process the outer table frame
    1:   aParent = aPseudoFrames.mTableOuter.mFrame;
    1:   nsFrameItems* items = &aPseudoFrames.mTableOuter.mChildList;
    1:   if (items && items->childList) {
    1:     rv = aParent->SetInitialChildList(nsnull, items->childList);
    1:     if (NS_FAILED(rv)) return rv;
    1:   }
    1:   nsFrameItems* captions = &aPseudoFrames.mTableOuter.mChildList2;
    1:   if (captions && captions->childList) {
    1:     rv = aParent->SetInitialChildList(nsGkAtoms::captionList, captions->childList);
    1:   }
    1:   aPseudoFrames.mTableOuter.Reset();
    1:   return rv;
    1: }
    1: 
    1: static nsresult 
    1: ProcessPseudoCellFrame(nsPseudoFrames& aPseudoFrames,
    1:                        nsIFrame*&      aParent)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   rv = ProcessPseudoFrame(aPseudoFrames.mCellInner, aParent);
    1:   if (NS_FAILED(rv)) return rv;
    1:   rv = ProcessPseudoFrame(aPseudoFrames.mCellOuter, aParent);
    1:   return rv;
    1: }
    1: 
    1: // limit the processing up to the frame type indicated by aHighestType.
    1: // make a complete processing when aHighestType is null
    1: static nsresult 
    1: ProcessPseudoFrames(nsFrameConstructorState& aState,
    1:                     nsIAtom*        aHighestType,
    1:                     nsIFrame*&      aHighestFrame)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   aHighestFrame = nsnull;
    1: 
    1: #ifdef DEBUG
    1:   if (gTablePseudoFrame) {
    1:     printf("*** ProcessPseudoFrames enter***\n");
    1:     aState.mPseudoFrames.Dump();
    1:   }
    1: #endif
    1: 
    1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
    1: 
    1:   if (nsGkAtoms::tableFrame == pseudoFrames.mLowestType) {
    1:     if (pseudoFrames.mColGroup.mFrame) {
    1:       rv = ProcessPseudoFrame(pseudoFrames.mColGroup, aHighestFrame);
    1:       if (nsGkAtoms::tableColGroupFrame == aHighestType) return rv;
    1:     }
    1:     rv = ProcessPseudoTableFrame(pseudoFrames, aHighestFrame);
    1:     if (nsGkAtoms::tableOuterFrame == aHighestType) return rv;
    1:     
    1:     if (pseudoFrames.mCellOuter.mFrame) {
    1:       rv = ProcessPseudoCellFrame(pseudoFrames, aHighestFrame);
    1:       if (IS_TABLE_CELL(aHighestType)) return rv;
    1:     }
    1:     if (pseudoFrames.mRow.mFrame) {
    1:       rv = ProcessPseudoFrame(pseudoFrames.mRow, aHighestFrame);
    1:       if (nsGkAtoms::tableRowFrame == aHighestType) return rv;
    1:     }
    1:     if (pseudoFrames.mRowGroup.mFrame) {
    1:       rv = ProcessPseudoRowGroupFrame(pseudoFrames.mRowGroup, aHighestFrame);
    1:       if (nsGkAtoms::tableRowGroupFrame == aHighestType) return rv;
    1:     }
    1:   }
    1:   else if (nsGkAtoms::tableRowGroupFrame == pseudoFrames.mLowestType) {
    1:     rv = ProcessPseudoRowGroupFrame(pseudoFrames.mRowGroup, aHighestFrame);
    1:     if (nsGkAtoms::tableRowGroupFrame == aHighestType) return rv;
    1:     if (pseudoFrames.mColGroup.mFrame) {
    1:       nsIFrame* colGroupHigh;
    1:       rv = ProcessPseudoFrame(pseudoFrames.mColGroup, colGroupHigh);
    1:       if (aHighestFrame &&
    1:           nsGkAtoms::tableRowGroupFrame == aHighestFrame->GetType() &&
    1:           !pseudoFrames.mTableInner.mFrame) {
    1:         // table frames are special they can have two types of pseudo frames as
    1:         // children that need to be processed in one pass, we only need to link
    1:         // them if the parent is not a pseudo where the link is already done
    1:         // We sort this later out inside nsTableFrame.
    1:         colGroupHigh->SetNextSibling(aHighestFrame); 
    1:       }
    1:       aHighestFrame = colGroupHigh;
    1:       if (nsGkAtoms::tableColGroupFrame == aHighestType) return rv;
    1:     }
    1:     if (pseudoFrames.mTableOuter.mFrame) {
    1:       rv = ProcessPseudoTableFrame(pseudoFrames, aHighestFrame);
    1:       if (nsGkAtoms::tableOuterFrame == aHighestType) return rv;
    1:     }
    1:     if (pseudoFrames.mCellOuter.mFrame) {
    1:       rv = ProcessPseudoCellFrame(pseudoFrames, aHighestFrame);
    1:       if (IS_TABLE_CELL(aHighestType)) return rv;
    1:     }
    1:     if (pseudoFrames.mRow.mFrame) {
    1:       rv = ProcessPseudoFrame(pseudoFrames.mRow, aHighestFrame);
    1:       if (nsGkAtoms::tableRowFrame == aHighestType) return rv;
    1:     }
    1:   }
    1:   else if (nsGkAtoms::tableRowFrame == pseudoFrames.mLowestType) {
    1:     rv = ProcessPseudoFrame(pseudoFrames.mRow, aHighestFrame);
    1:     if (nsGkAtoms::tableRowFrame == aHighestType) return rv;
    1: 
    1:     if (pseudoFrames.mRowGroup.mFrame) {
    1:       rv = ProcessPseudoRowGroupFrame(pseudoFrames.mRowGroup, aHighestFrame);
    1:       if (nsGkAtoms::tableRowGroupFrame == aHighestType) return rv;
    1:     }
    1:     if (pseudoFrames.mColGroup.mFrame) {
    1:       nsIFrame* colGroupHigh;
    1:       rv = ProcessPseudoFrame(pseudoFrames.mColGroup, colGroupHigh);
    1:       if (aHighestFrame &&
    1:           nsGkAtoms::tableRowGroupFrame == aHighestFrame->GetType() &&
    1:           !pseudoFrames.mTableInner.mFrame) {
    1:         // table frames are special they can have two types of pseudo frames as
    1:         // children that need to be processed in one pass, we only need to link
    1:         // them if the parent is not a pseudo where the link is already done
    1:         // We sort this later out inside nsTableFrame.
    1:         colGroupHigh->SetNextSibling(aHighestFrame); 
    1:       }
    1:       aHighestFrame = colGroupHigh;
    1:       if (nsGkAtoms::tableColGroupFrame == aHighestType) return rv;
    1:     }
    1:     if (pseudoFrames.mTableOuter.mFrame) {
    1:       rv = ProcessPseudoTableFrame(pseudoFrames, aHighestFrame);
    1:       if (nsGkAtoms::tableOuterFrame == aHighestType) return rv;
    1:     }
    1:     if (pseudoFrames.mCellOuter.mFrame) {
    1:       rv = ProcessPseudoCellFrame(pseudoFrames, aHighestFrame);
    1:       if (IS_TABLE_CELL(aHighestType)) return rv;
    1:     }
    1:   }
    1:   else if (IS_TABLE_CELL(pseudoFrames.mLowestType)) {
    1:     rv = ProcessPseudoCellFrame(pseudoFrames, aHighestFrame);
    1:     if (IS_TABLE_CELL(aHighestType)) return rv;
    1: 
    1:     if (pseudoFrames.mRow.mFrame) {
    1:       rv = ProcessPseudoFrame(pseudoFrames.mRow, aHighestFrame);
    1:       if (nsGkAtoms::tableRowFrame == aHighestType) return rv;
    1:     }
    1:     if (pseudoFrames.mRowGroup.mFrame) {
    1:       rv = ProcessPseudoRowGroupFrame(pseudoFrames.mRowGroup, aHighestFrame);
    1:       if (nsGkAtoms::tableRowGroupFrame == aHighestType) return rv;
    1:     }
    1:     if (pseudoFrames.mColGroup.mFrame) {
    1:       nsIFrame* colGroupHigh;
    1:       rv = ProcessPseudoFrame(pseudoFrames.mColGroup, colGroupHigh);
    1:       if (aHighestFrame &&
    1:           nsGkAtoms::tableRowGroupFrame == aHighestFrame->GetType() &&
    1:           !pseudoFrames.mTableInner.mFrame) {
    1:         // table frames are special they can have two types of pseudo frames as
    1:         // children that need to be processed in one pass, we only need to link
    1:         // them if the parent is not a pseudo where the link is already done
    1:         // We sort this later out inside nsTableFrame.
    1:         colGroupHigh->SetNextSibling(aHighestFrame); 
    1:       }
    1:       aHighestFrame = colGroupHigh;
    1:       if (nsGkAtoms::tableColGroupFrame == aHighestType) return rv;
    1:     }
    1:     if (pseudoFrames.mTableOuter.mFrame) {
    1:       rv = ProcessPseudoTableFrame(pseudoFrames, aHighestFrame);
    1:     }
    1:   }
    1:   else if (pseudoFrames.mColGroup.mFrame) { 
    1:     // process the col group frame
    1:     rv = ProcessPseudoFrame(pseudoFrames.mColGroup, aHighestFrame);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: static nsresult 
    1: ProcessPseudoFrames(nsFrameConstructorState& aState,
    1:                     nsFrameItems&   aItems)
    1: {
    1: 
    1: #ifdef DEBUG
    1:   if (gTablePseudoFrame) {
    1:     printf("*** ProcessPseudoFrames complete enter***\n");
    1:     aState.mPseudoFrames.Dump();
    1:   }
    1: #endif
    1:  
    1:   nsIFrame* highestFrame;
    1:   nsresult rv = ProcessPseudoFrames(aState, nsnull, highestFrame);
    1:   if (highestFrame) {
    1:     aItems.AddChild(highestFrame);
    1:   }
    1:  
    1: #ifdef DEBUG
    1:   if (gTablePseudoFrame) {
    1:     printf("*** ProcessPseudoFrames complete leave, highestframe:%p***\n",
 3233:            static_cast<void*>(highestFrame));
    1:     aState.mPseudoFrames.Dump();
    1:   }
    1: #endif
    1:   aState.mPseudoFrames.Reset();
    1:   return rv;
    1: }
    1: 
    1: static nsresult 
    1: ProcessPseudoFrames(nsFrameConstructorState& aState,
    1:                     nsIAtom*        aHighestType)
    1: {
    1: #ifdef DEBUG
    1:   if (gTablePseudoFrame) {
    1:     printf("*** ProcessPseudoFrames limited enter highest:");
    1:     if (nsGkAtoms::tableOuterFrame == aHighestType) 
    1:       printf("OuterTable");
    1:     else if (nsGkAtoms::tableFrame == aHighestType) 
    1:       printf("InnerTable");
    1:     else if (nsGkAtoms::tableColGroupFrame == aHighestType) 
    1:       printf("ColGroup");
    1:     else if (nsGkAtoms::tableRowGroupFrame == aHighestType) 
    1:       printf("RowGroup");
    1:     else if (nsGkAtoms::tableRowFrame == aHighestType) 
    1:       printf("Row");
    1:     else if (IS_TABLE_CELL(aHighestType)) 
    1:       printf("Cell");
    1:     else 
    1:       NS_ASSERTION(PR_FALSE, "invalid call to ProcessPseudoFrames ");
    1:     printf("***\n");
    1:     aState.mPseudoFrames.Dump();
    1:   }
    1: #endif
    1:  
    1:   nsIFrame* highestFrame;
    1:   nsresult rv = ProcessPseudoFrames(aState, aHighestType, highestFrame);
    1: 
    1: #ifdef DEBUG
    1:   if (gTablePseudoFrame) {
    1:     printf("*** ProcessPseudoFrames limited leave:%p***\n",
 3233:            static_cast<void*>(highestFrame));
    1:     aState.mPseudoFrames.Dump();
    1:   }
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreatePseudoTableFrame(PRInt32                  aNameSpaceID,
    1:                                               nsFrameConstructorState& aState, 
    1:                                               nsIFrame*                aParentFrameIn)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsIFrame* parentFrame = (aState.mPseudoFrames.mCellInner.mFrame) 
    1:                           ? aState.mPseudoFrames.mCellInner.mFrame : aParentFrameIn;
    1:   if (!parentFrame) return rv;
    1: 
    1:   nsStyleContext *parentStyle;
    1:   nsRefPtr<nsStyleContext> childStyle;
    1: 
    1:   parentStyle = parentFrame->GetStyleContext(); 
    1:   nsIContent* parentContent = parentFrame->GetContent();   
    1: 
    1:   // Thankfully, the parent can't change display type without causing
    1:   // frame reconstruction, so this won't need to change.
    1:   nsIAtom *pseudoType;
    1:   if (parentStyle->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE)
    1:     pseudoType = nsCSSAnonBoxes::inlineTable;
    1:   else
    1:     pseudoType = nsCSSAnonBoxes::table;
    1: 
    1:   // create the SC for the inner table which will be the parent of the outer table's SC
    1:   childStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(parentContent,
    1:                                                              pseudoType,
    1:                                                              parentStyle);
    1: 
    1:   nsPseudoFrameData& pseudoOuter = aState.mPseudoFrames.mTableOuter;
    1:   nsPseudoFrameData& pseudoInner = aState.mPseudoFrames.mTableInner;
    1: 
    1:   // construct the pseudo outer and inner as part of the pseudo frames
    1:   nsFrameItems items;
    1:   rv = ConstructTableFrame(aState, parentContent,
    1:                            parentFrame, childStyle, aNameSpaceID,
10035:                            PR_TRUE, items, pseudoOuter.mFrame, 
    1:                            pseudoInner.mFrame);
    1: 
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   // set pseudo data for the newly created frames
    1:   pseudoOuter.mChildList.AddChild(pseudoInner.mFrame);
    1:   aState.mPseudoFrames.mLowestType = nsGkAtoms::tableFrame;
    1: 
    1:   // set pseudo data for the parent
    1:   if (aState.mPseudoFrames.mCellInner.mFrame) {
    1:     aState.mPseudoFrames.mCellInner.mChildList.AddChild(pseudoOuter.mFrame);
    1:   }
    1: #ifdef DEBUG
    1:   if (gTablePseudoFrame) {
    1:      printf("*** CreatePseudoTableFrame ***\n");
    1:     aState.mPseudoFrames.Dump();
    1:   }
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreatePseudoRowGroupFrame(PRInt32                  aNameSpaceID,
    1:                                                  nsFrameConstructorState& aState, 
    1:                                                  nsIFrame*                aParentFrameIn)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsIFrame* parentFrame = (aState.mPseudoFrames.mTableInner.mFrame) 
    1:                           ? aState.mPseudoFrames.mTableInner.mFrame : aParentFrameIn;
    1:   if (!parentFrame) return rv;
    1: 
    1:   nsStyleContext *parentStyle;
    1:   nsRefPtr<nsStyleContext> childStyle;
    1: 
    1:   parentStyle = parentFrame->GetStyleContext();
    1:   nsIContent* parentContent = parentFrame->GetContent();
    1: 
    1:   childStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(parentContent,
    1:                                                              nsCSSAnonBoxes::tableRowGroup, 
    1:                                                              parentStyle);
    1: 
    1:   nsPseudoFrameData& pseudo = aState.mPseudoFrames.mRowGroup;
    1: 
    1:   // construct the pseudo row group as part of the pseudo frames
    1:   PRBool pseudoParent;
    1:   nsFrameItems items;
    1:   rv = ConstructTableRowGroupFrame(aState, parentContent,
    1:                                    parentFrame, childStyle, aNameSpaceID,
    1:                                    PR_TRUE, items, pseudo.mFrame, pseudoParent);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   // set pseudo data for the newly created frames
    1:   aState.mPseudoFrames.mLowestType = nsGkAtoms::tableRowGroupFrame;
    1: 
    1:   // set pseudo data for the parent
    1:   if (aState.mPseudoFrames.mTableInner.mFrame) {
    1:     aState.mPseudoFrames.mTableInner.mChildList.AddChild(pseudo.mFrame);
    1:   }
    1: #ifdef DEBUG
    1:   if (gTablePseudoFrame) {
    1:      printf("*** CreatePseudoRowGroupFrame ***\n");
    1:     aState.mPseudoFrames.Dump();
    1:   }
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: nsresult 
    1: nsCSSFrameConstructor::CreatePseudoColGroupFrame(PRInt32                  aNameSpaceID,
    1:                                                  nsFrameConstructorState& aState, 
    1:                                                  nsIFrame*                aParentFrameIn)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsIFrame* parentFrame = (aState.mPseudoFrames.mTableInner.mFrame) 
    1:                           ? aState.mPseudoFrames.mTableInner.mFrame : aParentFrameIn;
    1:   if (!parentFrame) return rv;
    1: 
    1:   nsStyleContext *parentStyle;
    1:   nsRefPtr<nsStyleContext> childStyle;
    1: 
    1:   parentStyle = parentFrame->GetStyleContext();
    1:   nsIContent* parentContent = parentFrame->GetContent();
    1: 
    1:   childStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(parentContent,
    1:                                                              nsCSSAnonBoxes::tableColGroup, 
    1:                                                              parentStyle);
    1: 
    1:   nsPseudoFrameData& pseudo = aState.mPseudoFrames.mColGroup;
    1: 
    1:   // construct the pseudo col group as part of the pseudo frames
    1:   PRBool pseudoParent;
    1:   nsFrameItems items;
    1:   rv = ConstructTableColGroupFrame(aState, parentContent,
    1:                                    parentFrame, childStyle, aNameSpaceID,
    1:                                    PR_TRUE, items, pseudo.mFrame, pseudoParent);
    1:   if (NS_FAILED(rv)) return rv;
    1:   ((nsTableColGroupFrame*)pseudo.mFrame)->SetColType(eColGroupAnonymousCol);
    1: 
    1:   // Do not set  aState.mPseudoFrames.mLowestType here as colgroup frame will
    1:   // be always below a table frame but we can not descent any further as col
    1:   // frames can not have children and will not wrap table foreign frames.
    1: 
    1:   // set pseudo data for the parent
    1:   if (aState.mPseudoFrames.mTableInner.mFrame) {
    1:     aState.mPseudoFrames.mTableInner.mChildList.AddChild(pseudo.mFrame);
    1:   }
    1: #ifdef DEBUG
    1:   if (gTablePseudoFrame) {
    1:      printf("*** CreatePseudoColGroupFrame ***\n");
    1:     aState.mPseudoFrames.Dump();
    1:   }
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreatePseudoRowFrame(PRInt32                  aNameSpaceID,
    1:                                             nsFrameConstructorState& aState, 
    1:                                             nsIFrame*                aParentFrameIn)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsIFrame* parentFrame = aParentFrameIn;
    1:   if (aState.mPseudoFrames.mRowGroup.mFrame) {
    1:     parentFrame = (nsIFrame*) nsTableFrame::GetRowGroupFrame(aState.mPseudoFrames.mRowGroup.mFrame);
    1:   }
    1:   if (!parentFrame) return rv;
    1: 
    1:   nsStyleContext *parentStyle;
    1:   nsRefPtr<nsStyleContext> childStyle;
    1: 
    1:   parentStyle = parentFrame->GetStyleContext();
    1:   nsIContent* parentContent = parentFrame->GetContent();
    1: 
    1:   childStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(parentContent,
    1:                                                              nsCSSAnonBoxes::tableRow, 
    1:                                                              parentStyle);
    1: 
    1:   nsPseudoFrameData& pseudo = aState.mPseudoFrames.mRow;
    1: 
    1:   // construct the pseudo row as part of the pseudo frames
    1:   PRBool pseudoParent;
    1:   nsFrameItems items;
    1:   rv = ConstructTableRowFrame(aState, parentContent,
    1:                               parentFrame, childStyle, aNameSpaceID,
    1:                               PR_TRUE, items, pseudo.mFrame, pseudoParent);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   aState.mPseudoFrames.mLowestType = nsGkAtoms::tableRowFrame;
    1: 
    1:   // set pseudo data for the parent
    1:   if (aState.mPseudoFrames.mRowGroup.mFrame) {
    1:     aState.mPseudoFrames.mRowGroup.mChildList.AddChild(pseudo.mFrame);
    1:   }
    1: #ifdef DEBUG
    1:   if (gTablePseudoFrame) {
    1:      printf("*** CreatePseudoRowFrame ***\n");
    1:     aState.mPseudoFrames.Dump();
    1:   }
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreatePseudoCellFrame(PRInt32                  aNameSpaceID,
    1:                                              nsFrameConstructorState& aState, 
    1:                                              nsIFrame*                aParentFrameIn)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsIFrame* parentFrame = (aState.mPseudoFrames.mRow.mFrame) 
    1:                           ? aState.mPseudoFrames.mRow.mFrame : aParentFrameIn;
    1:   if (!parentFrame) return rv;
    1: 
    1:   nsStyleContext *parentStyle;
    1:   nsRefPtr<nsStyleContext> childStyle;
    1: 
    1:   parentStyle = parentFrame->GetStyleContext();
    1:   nsIContent* parentContent = parentFrame->GetContent();
    1: 
    1:   childStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(parentContent,
    1:                                                              nsCSSAnonBoxes::tableCell, 
    1:                                                              parentStyle);
    1: 
    1:   nsPseudoFrameData& pseudoOuter = aState.mPseudoFrames.mCellOuter;
    1:   nsPseudoFrameData& pseudoInner = aState.mPseudoFrames.mCellInner;
    1: 
    1:   // construct the pseudo outer and inner as part of the pseudo frames
    1:   PRBool pseudoParent;
    1:   nsFrameItems items;
    1:   rv = ConstructTableCellFrame(aState, parentContent, parentFrame, childStyle,
    1:                                aNameSpaceID, PR_TRUE, items,
    1:                                pseudoOuter.mFrame, pseudoInner.mFrame,
    1:                                pseudoParent);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   // set pseudo data for the newly created frames
    1:   pseudoOuter.mChildList.AddChild(pseudoInner.mFrame);
    1:   // give it nsGkAtoms::tableCellFrame, if it is really nsGkAtoms::bcTableCellFrame, it will match later
    1:   aState.mPseudoFrames.mLowestType = nsGkAtoms::tableCellFrame;
    1: 
    1:   // set pseudo data for the parent
    1:   if (aState.mPseudoFrames.mRow.mFrame) {
    1:     aState.mPseudoFrames.mRow.mChildList.AddChild(pseudoOuter.mFrame);
    1:   }
    1: #ifdef DEBUG
    1:   if (gTablePseudoFrame) {
    1:      printf("*** CreatePseudoCellFrame ***\n");
    1:     aState.mPseudoFrames.Dump();
    1:   }
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: // called if the parent is not a table
    1: nsresult 
    1: nsCSSFrameConstructor::GetPseudoTableFrame(PRInt32                  aNameSpaceID,
    1:                                            nsFrameConstructorState& aState, 
    1:                                            nsIFrame&                aParentFrameIn)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
    1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
    1: 
    1:   if (pseudoFrames.IsEmpty()) {
    1:     PRBool created = PR_FALSE;
    1:     if (nsGkAtoms::tableRowGroupFrame == parentFrameType) { // row group parent
    1:       rv = CreatePseudoRowFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:       if (NS_FAILED(rv)) return rv;
    1:       created = PR_TRUE;
    1:     }
    1:     if (created || (nsGkAtoms::tableRowFrame == parentFrameType)) { // row parent
    1:       rv = CreatePseudoCellFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:       if (NS_FAILED(rv)) return rv;
    1:     }
    1:     rv = CreatePseudoTableFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:   }
    1:   else {
    1:     if (!pseudoFrames.mTableInner.mFrame) { 
    1:       if (pseudoFrames.mRowGroup.mFrame && !(pseudoFrames.mRow.mFrame)) {
    1:         rv = CreatePseudoRowFrame(aNameSpaceID, aState);
    1:         if (NS_FAILED(rv)) return rv;
    1:       }
    1:       if (pseudoFrames.mRow.mFrame && !(pseudoFrames.mCellOuter.mFrame)) {
    1:         rv = CreatePseudoCellFrame(aNameSpaceID, aState);
    1:         if (NS_FAILED(rv)) return rv;
    1:       }
    1:       CreatePseudoTableFrame(aNameSpaceID, aState);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: // called if the parent is not a col group
    1: nsresult 
    1: nsCSSFrameConstructor::GetPseudoColGroupFrame(PRInt32                  aNameSpaceID,
    1:                                               nsFrameConstructorState& aState, 
    1:                                               nsIFrame&                aParentFrameIn)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
    1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
    1: 
    1:   if (pseudoFrames.IsEmpty()) {
    1:     PRBool created = PR_FALSE;
    1:     if (nsGkAtoms::tableRowGroupFrame == parentFrameType) {  // row group parent
    1:       rv = CreatePseudoRowFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:       created = PR_TRUE;
    1:     }
    1:     if (created || (nsGkAtoms::tableRowFrame == parentFrameType)) { // row parent
    1:       rv = CreatePseudoCellFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:       created = PR_TRUE;
    1:     }
    1:     if (created || IS_TABLE_CELL(parentFrameType) || // cell parent
    1:         (nsGkAtoms::tableCaptionFrame == parentFrameType)  || // caption parent
    1:         !IsTableRelated(parentFrameType, PR_TRUE)) { // block parent
    1:       rv = CreatePseudoTableFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:     }
    1:     rv = CreatePseudoColGroupFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:   }
    1:   else {
    1:     if (!pseudoFrames.mColGroup.mFrame) {
    1:       if (!pseudoFrames.mTableInner.mFrame) {
    1:         if (pseudoFrames.mRowGroup.mFrame && !(pseudoFrames.mRow.mFrame)) {
    1:           rv = CreatePseudoRowFrame(aNameSpaceID, aState);
    1:         }
    1:         if (pseudoFrames.mRow.mFrame && !(pseudoFrames.mCellOuter.mFrame)) {
    1:           rv = CreatePseudoCellFrame(aNameSpaceID, aState);
    1:         }
    1:         if (pseudoFrames.mCellOuter.mFrame && !(pseudoFrames.mTableOuter.mFrame)) {
    1:           rv = CreatePseudoTableFrame(aNameSpaceID, aState);
    1:         }
    1:       }
    1:       rv = CreatePseudoColGroupFrame(aNameSpaceID, aState);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: // called if the parent is not a row group
    1: nsresult 
    1: nsCSSFrameConstructor::GetPseudoRowGroupFrame(PRInt32                  aNameSpaceID,
    1:                                               nsFrameConstructorState& aState, 
    1:                                               nsIFrame&                aParentFrameIn)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
    1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
    1: 
    1:   if (!pseudoFrames.mLowestType) {
    1:     PRBool created = PR_FALSE;
    1:     if (nsGkAtoms::tableRowFrame == parentFrameType) {  // row parent
    1:       rv = CreatePseudoCellFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:       created = PR_TRUE;
    1:     }
    1:     if (created || IS_TABLE_CELL(parentFrameType) || // cell parent
    1:         (nsGkAtoms::tableCaptionFrame == parentFrameType)  || // caption parent
    1:         !IsTableRelated(parentFrameType, PR_TRUE)) { // block parent
    1:       rv = CreatePseudoTableFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:     }
    1:     rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:   }
    1:   else {
    1:     if (!pseudoFrames.mRowGroup.mFrame) { 
    1:       if (pseudoFrames.mRow.mFrame && !(pseudoFrames.mCellOuter.mFrame)) {
    1:         rv = CreatePseudoCellFrame(aNameSpaceID, aState);
    1:       }
    1:       if (pseudoFrames.mCellOuter.mFrame && !(pseudoFrames.mTableOuter.mFrame)) {
    1:         rv = CreatePseudoTableFrame(aNameSpaceID, aState);
    1:       }
    1:       rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: // called if the parent is not a row
    1: nsresult
    1: nsCSSFrameConstructor::GetPseudoRowFrame(PRInt32                  aNameSpaceID,
    1:                                          nsFrameConstructorState& aState, 
    1:                                          nsIFrame&                aParentFrameIn)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
    1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
    1: 
    1:   if (!pseudoFrames.mLowestType) {
    1:     PRBool created = PR_FALSE;
    1:     if (IS_TABLE_CELL(parentFrameType) || // cell parent
    1:        (nsGkAtoms::tableCaptionFrame == parentFrameType)  || // caption parent
    1:         !IsTableRelated(parentFrameType, PR_TRUE)) { // block parent
    1:       rv = CreatePseudoTableFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:       created = PR_TRUE;
    1:     }
    1:     if (created || (nsGkAtoms::tableFrame == parentFrameType)) { // table parent
    1:       rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:     }
    1:     rv = CreatePseudoRowFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:   }
    1:   else {
    1:     if (!pseudoFrames.mRow.mFrame) { 
    1:       if (pseudoFrames.mCellOuter.mFrame && !pseudoFrames.mTableOuter.mFrame) {
    1:         rv = CreatePseudoTableFrame(aNameSpaceID, aState);
    1:       }
    1:       if (pseudoFrames.mTableInner.mFrame && !(pseudoFrames.mRowGroup.mFrame)) {
    1:         rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState);
    1:       }
    1:       rv = CreatePseudoRowFrame(aNameSpaceID, aState);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: // called if the parent is not a cell or block
    1: nsresult 
    1: nsCSSFrameConstructor::GetPseudoCellFrame(PRInt32                  aNameSpaceID,
    1:                                           nsFrameConstructorState& aState, 
    1:                                           nsIFrame&                aParentFrameIn)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
    1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
    1: 
    1:   if (!pseudoFrames.mLowestType) {
    1:     PRBool created = PR_FALSE;
    1:     if (nsGkAtoms::tableFrame == parentFrameType) { // table parent
    1:       rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:       created = PR_TRUE;
    1:     }
    1:     if (created || (nsGkAtoms::tableRowGroupFrame == parentFrameType)) { // row group parent
    1:       rv = CreatePseudoRowFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:       created = PR_TRUE;
    1:     }
    1:     rv = CreatePseudoCellFrame(aNameSpaceID, aState, &aParentFrameIn);
    1:   }
    1:   else if (!pseudoFrames.mCellOuter.mFrame) { 
    1:     if (pseudoFrames.mTableInner.mFrame && !(pseudoFrames.mRowGroup.mFrame)) {
    1:       rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState);
    1:     }
    1:     if (pseudoFrames.mRowGroup.mFrame && !(pseudoFrames.mRow.mFrame)) {
    1:       rv = CreatePseudoRowFrame(aNameSpaceID, aState);
    1:     }
    1:     rv = CreatePseudoCellFrame(aNameSpaceID, aState);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: nsresult 
    1: nsCSSFrameConstructor::GetParentFrame(PRInt32                  aNameSpaceID,
    1:                                       nsIFrame&                aParentFrameIn, 
    1:                                       nsIAtom*                 aChildFrameType, 
    1:                                       nsFrameConstructorState& aState, 
    1:                                       nsIFrame*&               aParentFrame,
    1:                                       PRBool&                  aIsPseudoParent)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
    1:   nsIFrame* pseudoParentFrame = nsnull;
    1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
    1:   aParentFrame = &aParentFrameIn;
    1:   aIsPseudoParent = PR_FALSE;
    1: 
20108:   nsFrameState savedStateBits  = aState.mAdditionalStateBits;
20108:   aState.mAdditionalStateBits &= ~NS_FRAME_GENERATED_CONTENT;
20108: 
    1:   if (nsGkAtoms::tableOuterFrame == aChildFrameType) { // table child
    1:     if (IsTableRelated(parentFrameType, PR_TRUE) &&
    1:         (nsGkAtoms::tableCaptionFrame != parentFrameType) ) { // need pseudo cell parent
    1:       rv = GetPseudoCellFrame(aNameSpaceID, aState, aParentFrameIn);
    1:       if (NS_FAILED(rv)) return rv;
    1:       pseudoParentFrame = pseudoFrames.mCellInner.mFrame;
    1:     }
    1:   } 
    1:   else if (nsGkAtoms::tableCaptionFrame == aChildFrameType) { // caption child
    1:     if (nsGkAtoms::tableOuterFrame != parentFrameType) { // need pseudo table parent
    1:       rv = GetPseudoTableFrame(aNameSpaceID, aState, aParentFrameIn);
    1:       if (NS_FAILED(rv)) return rv;
    1:       pseudoParentFrame = pseudoFrames.mTableOuter.mFrame;
    1:     }
    1:   }
    1:   else if (nsGkAtoms::tableColGroupFrame == aChildFrameType) { // col group child
    1:     if (nsGkAtoms::tableFrame != parentFrameType) { // need pseudo table parent
    1:       rv = GetPseudoTableFrame(aNameSpaceID, aState, aParentFrameIn);
    1:       if (NS_FAILED(rv)) return rv;
    1:       pseudoParentFrame = pseudoFrames.mTableInner.mFrame;
    1:     }
    1:   }
    1:   else if (nsGkAtoms::tableColFrame == aChildFrameType) { // col child
    1:     if (nsGkAtoms::tableColGroupFrame != parentFrameType) { // need pseudo col group parent
    1:       rv = GetPseudoColGroupFrame(aNameSpaceID, aState, aParentFrameIn);
    1:       if (NS_FAILED(rv)) return rv;
    1:       pseudoParentFrame = pseudoFrames.mColGroup.mFrame;
    1:     }
    1:   }
    1:   else if (nsGkAtoms::tableRowGroupFrame == aChildFrameType) { // row group child
    1:     // XXX can this go away?
    1:     if (nsGkAtoms::tableFrame != parentFrameType) {
    1:       // trees allow row groups to contain row groups, so don't create pseudo frames
    1:         rv = GetPseudoTableFrame(aNameSpaceID, aState, aParentFrameIn);
    1:         if (NS_FAILED(rv)) return rv;
    1:         pseudoParentFrame = pseudoFrames.mTableInner.mFrame;
    1:      }
    1:   }
    1:   else if (nsGkAtoms::tableRowFrame == aChildFrameType) { // row child
    1:     if (nsGkAtoms::tableRowGroupFrame != parentFrameType) { // need pseudo row group parent
    1:       rv = GetPseudoRowGroupFrame(aNameSpaceID, aState, aParentFrameIn);
    1:       if (NS_FAILED(rv)) return rv;
    1:       pseudoParentFrame = pseudoFrames.mRowGroup.mFrame;
    1:     }
    1:   }
    1:   else if (IS_TABLE_CELL(aChildFrameType)) { // cell child
    1:     if (nsGkAtoms::tableRowFrame != parentFrameType) { // need pseudo row parent
    1:       rv = GetPseudoRowFrame(aNameSpaceID, aState, aParentFrameIn);
    1:       if (NS_FAILED(rv)) return rv;
    1:       pseudoParentFrame = pseudoFrames.mRow.mFrame;
    1:     }
    1:   }
    1:   else if (nsGkAtoms::tableFrame == aChildFrameType) { // invalid
    1:     NS_ASSERTION(PR_FALSE, "GetParentFrame called on nsGkAtoms::tableFrame child");
    1:   }
    1:   else { // foreign frame
    1:     if (IsTableRelated(parentFrameType, PR_FALSE)) { // need pseudo cell parent
    1:       rv = GetPseudoCellFrame(aNameSpaceID, aState, aParentFrameIn);
    1:       if (NS_FAILED(rv)) return rv;
    1:       pseudoParentFrame = pseudoFrames.mCellInner.mFrame;
    1:     }
    1:   }
    1:   
    1:   if (pseudoParentFrame) {
    1:     aParentFrame = pseudoParentFrame;
    1:     aIsPseudoParent = PR_TRUE;
    1:   }
    1: 
20108:   aState.mAdditionalStateBits = savedStateBits;
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::AdjustParentFrame(nsFrameConstructorState&     aState,
    1:                                          nsIContent*                  aChildContent,
    1:                                          nsIFrame* &                  aParentFrame,
23955:                                          const FrameConstructionData* aFCData,
    1:                                          PRInt32                      aNameSpaceID,
23955:                                          const nsStyleDisplay*        aDisplay,
    1:                                          nsFrameItems* &              aFrameItems,
    1:                                          nsFrameConstructorSaveState& aSaveState,
    1:                                          PRBool&                      aSuppressFrame,
    1:                                          PRBool&                      aCreatedPseudo)
    1: {
23955:   NS_PRECONDITION(aDisplay, "Must have child's style context");
    1:   NS_PRECONDITION(aFrameItems, "Must have frame items to work with");
    1: 
    1:   aSuppressFrame = PR_FALSE;
    1:   aCreatedPseudo = PR_FALSE;
    1:   if (!aParentFrame) {
    1:     // Nothing to do here
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Only use the outer table frame as parent if the child is going to use a
    1:   // tableCaptionFrame, otherwise the inner table frame is the parent
    1:   // (bug 341858).
    1:   nsIAtom* parentType = aParentFrame->GetType();
 4194:   NS_ASSERTION(parentType != nsGkAtoms::tableOuterFrame,
 4194:                "Shouldn't be happening");
 4194:   if (parentType == nsGkAtoms::tableColGroupFrame) {
23955:     if (aFCData || aDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_COLUMN) {
    1:       aSuppressFrame = PR_TRUE;
    1:       return NS_OK;
    1:     }
    1:   }
    1:  
    1:   // If our parent is a table, table-row-group, or table-row, and
    1:   // we're not table-related in any way, we have to create table
    1:   // pseudo-frames so that we have a table cell to live in.
    1:   if (IsTableRelated(aParentFrame->GetType(), PR_FALSE) &&
23955:       (!IsTableRelated(aDisplay->mDisplay, PR_TRUE) ||
    1:        // Also need to create a pseudo-parent if the child is going to end up
    1:        // with a frame based on something other than display.
23955:        aFCData)) {
20108:     nsFrameState savedStateBits  = aState.mAdditionalStateBits;
20108:     aState.mAdditionalStateBits &= ~NS_FRAME_GENERATED_CONTENT;
    1:     nsresult rv = GetPseudoCellFrame(aNameSpaceID, aState, *aParentFrame);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
20108:     aState.mAdditionalStateBits = savedStateBits;
    1: 
    1:     NS_ASSERTION(aState.mPseudoFrames.mCellInner.mFrame,
    1:                  "Must have inner cell frame now!");
    1: 
    1:     aParentFrame = aState.mPseudoFrames.mCellInner.mFrame;
    1:     aFrameItems = &aState.mPseudoFrames.mCellInner.mChildList;
    1:     // We pushed an anonymous table cell.  The inner block of this
    1:     // needs to become the float containing block.
23352:     aState.PushFloatContainingBlock(aParentFrame, aSaveState);
    1:     aCreatedPseudo = PR_TRUE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
 4368: // Pull all the captions present in aItems out  into aCaptions
 4368: static void
 4368: PullOutCaptionFrames(nsFrameItems& aItems, nsFrameItems& aCaptions)
 4368: {
 4368:   nsIFrame *child = aItems.childList;
 4368:   nsIFrame* prev = nsnull;
 4368:   while (child) {
 4368:     nsIFrame *nextSibling = child->GetNextSibling();
 4368:     if (nsGkAtoms::tableCaptionFrame == child->GetType()) {
 4368:       aItems.RemoveChild(child, prev);
 4368:       aCaptions.AddChild(child);
 4368:     } else {
 4368:       prev = child;
 4368:     }
 4368:     child = nextSibling;
 4368:   }
 4368: }
 4368: 
 4368: 
    1: // Construct the outer, inner table frames and the children frames for the table. 
    1: // XXX Page break frames for pseudo table frames are not constructed to avoid the risk
    1: // associated with revising the pseudo frame mechanism. The long term solution
    1: // of having frames handle page-break-before/after will solve the problem. 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructTableFrame(nsFrameConstructorState& aState,
    1:                                            nsIContent*              aContent,
    1:                                            nsIFrame*                aContentParent,
    1:                                            nsStyleContext*          aStyleContext,
    1:                                            PRInt32                  aNameSpaceID,
    1:                                            PRBool                   aIsPseudo,
    1:                                            nsFrameItems&            aChildItems,
    1:                                            nsIFrame*&               aNewOuterFrame,
    1:                                            nsIFrame*&               aNewInnerFrame)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1: 
    1:   // create the pseudo SC for the outer table as a child of the inner SC
    1:   nsRefPtr<nsStyleContext> outerStyleContext;
    1:   outerStyleContext = mPresShell->StyleSet()->
    1:     ResolvePseudoStyleFor(aContent, nsCSSAnonBoxes::tableOuter, aStyleContext);
    1: 
    1:   // Create the outer table frame which holds the caption and inner table frame
    1: #ifdef MOZ_MATHML
    1:   if (kNameSpaceID_MathML == aNameSpaceID)
    1:     aNewOuterFrame = NS_NewMathMLmtableOuterFrame(mPresShell,
    1:                                                   outerStyleContext);
    1:   else
    1: #endif
    1:     aNewOuterFrame = NS_NewTableOuterFrame(mPresShell, outerStyleContext);
    1: 
    1:   nsIFrame* parentFrame = aContentParent;
    1:   nsFrameItems* frameItems = &aChildItems;
    1:   // We may need to push a float containing block
    1:   nsFrameConstructorSaveState floatSaveState;
    1:   if (!aIsPseudo) {
    1:     // this frame may have a pseudo parent
    1:     PRBool hasPseudoParent = PR_FALSE;
    1:     GetParentFrame(aNameSpaceID,*parentFrame, nsGkAtoms::tableOuterFrame,
    1:                    aState, parentFrame, hasPseudoParent);
    1:     if (!hasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aChildItems);
    1:     }
    1:     if (hasPseudoParent) {
23352:       aState.PushFloatContainingBlock(parentFrame, floatSaveState);
    1:       frameItems = &aState.mPseudoFrames.mCellInner.mChildList;
    1:       if (aState.mPseudoFrames.mTableOuter.mFrame) {
    1:         ProcessPseudoFrames(aState, nsGkAtoms::tableOuterFrame);
    1:       }
    1:     }
    1:   }
    1: 
10035:   nsIFrame* geometricParent = aState.GetGeometricParent
10035:                                 (outerStyleContext->GetStyleDisplay(),
10035:                                  parentFrame);
    1: 
    1:   // Init the table outer frame and see if we need to create a view, e.g.
    1:   // the frame is absolutely positioned  
    1:   InitAndRestoreFrame(aState, aContent, geometricParent, nsnull, aNewOuterFrame);  
23395:   nsHTMLContainerFrame::CreateViewForFrame(aNewOuterFrame, PR_FALSE);
    1: 
    1:   // Create the inner table frame
    1: #ifdef MOZ_MATHML
    1:   if (kNameSpaceID_MathML == aNameSpaceID)
    1:     aNewInnerFrame = NS_NewMathMLmtableFrame(mPresShell, aStyleContext);
    1:   else
    1: #endif
    1:     aNewInnerFrame = NS_NewTableFrame(mPresShell, aStyleContext);
    1:  
    1:   InitAndRestoreFrame(aState, aContent, aNewOuterFrame, nsnull,
    1:                       aNewInnerFrame);
    1: 
    1:   if (!aIsPseudo) {
    1:     // Put the newly created frames into the right child list
    1:     aNewOuterFrame->SetInitialChildList(nsnull, aNewInnerFrame);
    1: 
 8199:     rv = aState.AddChild(aNewOuterFrame, *frameItems, aContent,
10035:                          aStyleContext, parentFrame);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
20147:     if (!mInitialContainingBlock) {
20147:       // The frame we're constructing will be the initial containing block.
20147:       // Set mInitialContainingBlock before processing children.
20147:       mInitialContainingBlock = aNewOuterFrame;
20147:     }
20147: 
    1:     nsFrameItems childItems;
23352:     rv = ProcessChildren(aState, aContent, aStyleContext, aNewInnerFrame,
23352:                          PR_TRUE, childItems, PR_FALSE);
    1:     // XXXbz what about cleaning up?
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsFrameItems captionItems;
 4368:     PullOutCaptionFrames(childItems, captionItems);
 4368: 
    1:     // Set the inner table frame's initial primary list 
    1:     aNewInnerFrame->SetInitialChildList(nsnull, childItems.childList);
    1: 
    1:     // Set the outer table frame's secondary childlist lists
    1:     if (captionItems.childList) {
    1:         aNewOuterFrame->SetInitialChildList(nsGkAtoms::captionList,
    1:                                             captionItems.childList);
    1:     }
    1:  }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructTableCaptionFrame(nsFrameConstructorState& aState,
    1:                                                   nsIContent*              aContent,
    1:                                                   nsIFrame*                aParentFrameIn,
    1:                                                   nsStyleContext*          aStyleContext,
    1:                                                   PRInt32                  aNameSpaceID,
    1:                                                   nsFrameItems&            aChildItems,
    1:                                                   nsIFrame*&               aNewFrame,
    1:                                                   PRBool&                  aIsPseudoParent)
    1: 
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (!aParentFrameIn) return rv;
    1: 
    1:   nsIFrame* parentFrame = aParentFrameIn;
    1:   aIsPseudoParent = PR_FALSE;
    1:   // this frame may have a pseudo parent
    1:   GetParentFrame(aNameSpaceID, *aParentFrameIn, 
    1:                  nsGkAtoms::tableCaptionFrame, aState, parentFrame,
    1:                  aIsPseudoParent);
    1:   if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:     ProcessPseudoFrames(aState, aChildItems);
    1:   }
    1: 
    1:   aNewFrame = NS_NewTableCaptionFrame(mPresShell, aStyleContext);
    1:   if (NS_UNLIKELY(!aNewFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewFrame);
23395:   nsHTMLContainerFrame::CreateViewForFrame(aNewFrame, PR_FALSE);
23167: 
    1:   nsFrameItems childItems;
23352:   rv = ProcessChildren(aState, aContent, aStyleContext, aNewFrame,
    1:                        PR_TRUE, childItems, PR_TRUE);
    1:   if (NS_FAILED(rv)) return rv;
    1:   aNewFrame->SetInitialChildList(nsnull, childItems.childList);
    1:   if (aIsPseudoParent) {
    1:     aState.mPseudoFrames.mTableOuter.mChildList2.AddChild(aNewFrame);
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructTableRowGroupFrame(nsFrameConstructorState& aState,
    1:                                                    nsIContent*              aContent,
    1:                                                    nsIFrame*                aParentFrameIn,
    1:                                                    nsStyleContext*          aStyleContext,
    1:                                                    PRInt32                  aNameSpaceID,
    1:                                                    PRBool                   aIsPseudo,
    1:                                                    nsFrameItems&            aChildItems,
    1:                                                    nsIFrame*&               aNewFrame, 
    1:                                                    PRBool&                  aIsPseudoParent)
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (!aParentFrameIn) return rv;
    1: 
    1:   nsIFrame* parentFrame = aParentFrameIn;
    1:   aIsPseudoParent = PR_FALSE;
    1:   if (!aIsPseudo) {
    1:     // this frame may have a pseudo parent
    1:     GetParentFrame(aNameSpaceID, *aParentFrameIn, 
    1:                    nsGkAtoms::tableRowGroupFrame, aState, parentFrame,
    1:                    aIsPseudoParent);
    1:     if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aChildItems);
    1:     }
    1:     if (!aIsPseudo && aIsPseudoParent && aState.mPseudoFrames.mRowGroup.mFrame) {
    1:       ProcessPseudoFrames(aState, nsGkAtoms::tableRowGroupFrame);
    1:     }
    1:   }
    1: 
    1:   const nsStyleDisplay* styleDisplay = aStyleContext->GetStyleDisplay();
    1: 
    1:   aNewFrame = NS_NewTableRowGroupFrame(mPresShell, aStyleContext);
    1: 
    1:   nsIFrame* scrollFrame = nsnull;
    1:   if (styleDisplay->IsScrollableOverflow()) {
    1:     // Create an area container for the frame
    1:     BuildScrollFrame(aState, aContent, aStyleContext, aNewFrame, parentFrame,
23950:                      scrollFrame);
    1: 
    1:   } 
    1:   else {
    1:     if (NS_UNLIKELY(!aNewFrame)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewFrame);
23395:     nsHTMLContainerFrame::CreateViewForFrame(aNewFrame, PR_FALSE);
    1:   }
    1: 
    1:   if (!aIsPseudo) {
    1:     nsFrameItems childItems;
23352:     rv = ProcessChildren(aState, aContent, aStyleContext, aNewFrame, PR_TRUE,
23352:                          childItems, PR_FALSE);
    1:     
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     aNewFrame->SetInitialChildList(nsnull, childItems.childList);
    1:     if (aIsPseudoParent) {
    1:       nsIFrame* child = (scrollFrame) ? scrollFrame : aNewFrame;
    1:       aState.mPseudoFrames.mTableInner.mChildList.AddChild(child);
    1:     }
    1:   } 
    1: 
    1:   // if there is a scroll frame, use it as the one constructed
    1:   if (scrollFrame) {
    1:     aNewFrame = scrollFrame;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructTableColGroupFrame(nsFrameConstructorState& aState,
    1:                                                    nsIContent*              aContent,
    1:                                                    nsIFrame*                aParentFrameIn,
    1:                                                    nsStyleContext*          aStyleContext,
    1:                                                    PRInt32                  aNameSpaceID,
    1:                                                    PRBool                   aIsPseudo,
    1:                                                    nsFrameItems&            aChildItems,
    1:                                                    nsIFrame*&               aNewFrame, 
    1:                                                    PRBool&                  aIsPseudoParent)
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (!aParentFrameIn) return rv;
    1: 
    1:   nsIFrame* parentFrame = aParentFrameIn;
    1:   aIsPseudoParent = PR_FALSE;
    1:   if (!aIsPseudo) {
    1:     // this frame may have a pseudo parent
    1:     GetParentFrame(aNameSpaceID, *aParentFrameIn,
    1:                    nsGkAtoms::tableColGroupFrame, aState, parentFrame,
    1:                    aIsPseudoParent);
    1:     if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aChildItems);
    1:     }
    1:     if (!aIsPseudo && aIsPseudoParent && aState.mPseudoFrames.mColGroup.mFrame) {
    1:       ProcessPseudoFrames(aState, nsGkAtoms::tableColGroupFrame);
    1:     }
    1:   }
    1: 
    1:   aNewFrame = NS_NewTableColGroupFrame(mPresShell, aStyleContext);
    1:   if (NS_UNLIKELY(!aNewFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewFrame);
    1: 
    1:   if (!aIsPseudo) {
    1:     nsFrameItems childItems;
23352:     rv = ProcessChildren(aState, aContent, aStyleContext, aNewFrame, PR_TRUE,
23352:                          childItems, PR_FALSE);
    1:     if (NS_FAILED(rv)) return rv;
    1:     aNewFrame->SetInitialChildList(nsnull, childItems.childList);
    1:     if (aIsPseudoParent) {
    1:       aState.mPseudoFrames.mTableInner.mChildList.AddChild(aNewFrame);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructTableRowFrame(nsFrameConstructorState& aState,
    1:                                               nsIContent*              aContent,
    1:                                               nsIFrame*                aParentFrameIn,
    1:                                               nsStyleContext*          aStyleContext,
    1:                                               PRInt32                  aNameSpaceID,
    1:                                               PRBool                   aIsPseudo,
    1:                                               nsFrameItems&            aChildItems,
    1:                                               nsIFrame*&               aNewFrame,
    1:                                               PRBool&                  aIsPseudoParent)
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (!aParentFrameIn) return rv;
    1: 
    1:   nsIFrame* parentFrame = aParentFrameIn;
    1:   aIsPseudoParent = PR_FALSE;
    1:   if (!aIsPseudo) {
    1:     // this frame may have a pseudo parent
    1:     GetParentFrame(aNameSpaceID, *aParentFrameIn,
    1:                    nsGkAtoms::tableRowFrame, aState, parentFrame,
    1:                    aIsPseudoParent);
    1:     if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aChildItems);
    1:     }
    1:     if (!aIsPseudo && aIsPseudoParent && aState.mPseudoFrames.mRow.mFrame) {
    1:       ProcessPseudoFrames(aState, nsGkAtoms::tableRowFrame);
    1:     }
    1:   }
    1: 
    1: #ifdef MOZ_MATHML
    1:   if (kNameSpaceID_MathML == aNameSpaceID)
    1:     aNewFrame = NS_NewMathMLmtrFrame(mPresShell, aStyleContext);
    1:   else
    1: #endif
    1:     aNewFrame = NS_NewTableRowFrame(mPresShell, aStyleContext);
    1: 
    1:   if (NS_UNLIKELY(!aNewFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewFrame);
23395:   nsHTMLContainerFrame::CreateViewForFrame(aNewFrame, PR_FALSE);
    1:   if (!aIsPseudo) {
    1:     nsFrameItems childItems;
23352:     rv = ProcessChildren(aState, aContent, aStyleContext, aNewFrame, PR_TRUE,
23352:                          childItems, PR_FALSE);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     aNewFrame->SetInitialChildList(nsnull, childItems.childList);
    1:     if (aIsPseudoParent) {
    1:       aState.mPseudoFrames.mRowGroup.mChildList.AddChild(aNewFrame);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1:       
    1: nsresult
    1: nsCSSFrameConstructor::ConstructTableColFrame(nsFrameConstructorState& aState,
    1:                                               nsIContent*              aContent,
    1:                                               nsIFrame*                aParentFrameIn,
    1:                                               nsStyleContext*          aStyleContext,
    1:                                               PRInt32                  aNameSpaceID,
    1:                                               PRBool                   aIsPseudo,
    1:                                               nsFrameItems&            aChildItems,
    1:                                               nsIFrame*&               aNewFrame,
    1:                                               PRBool&                  aIsPseudoParent)
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (!aParentFrameIn || !aStyleContext) return rv;
    1: 
    1:   nsIFrame* parentFrame = aParentFrameIn;
    1:   aIsPseudoParent = PR_FALSE;
    1:   if (!aIsPseudo) {
    1:     // this frame may have a pseudo parent
    1:     GetParentFrame(aNameSpaceID, *aParentFrameIn,
    1:                    nsGkAtoms::tableColFrame, aState, parentFrame,
    1:                    aIsPseudoParent);
    1:     if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aChildItems);
    1:     }
    1:   }
    1: 
 8151:   nsTableColFrame* colFrame = NS_NewTableColFrame(mPresShell, aStyleContext);
 8151:   aNewFrame = colFrame;
    1:   if (NS_UNLIKELY(!aNewFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewFrame);
    1: 
    1:   // construct additional col frames if the col frame has a span > 1
 8151:   PRInt32 span = colFrame->GetSpan();
    1:   nsIFrame* lastCol = aNewFrame;
    1:   nsStyleContext* styleContext = nsnull;
    1:   for (PRInt32 spanX = 1; spanX < span; spanX++) {
    1:     // The same content node should always resolve to the same style context.
    1:     if (1 == spanX)
    1:       styleContext = aNewFrame->GetStyleContext();
 8151:     nsTableColFrame* newCol = NS_NewTableColFrame(mPresShell, styleContext);
    1:     if (NS_UNLIKELY(!newCol)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
 4192:     InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, newCol, PR_FALSE);
 8570:     lastCol->SetNextSibling(newCol);
 8570:     lastCol->SetNextContinuation(newCol);
 8570:     newCol->SetPrevContinuation(lastCol);
 8151:     newCol->SetColType(eColAnonymousCol);
    1:     lastCol = newCol;
    1:   }
    1: 
    1:   if (!aIsPseudo && aIsPseudoParent) {
    1:       aState.mPseudoFrames.mColGroup.mChildList.AddChild(aNewFrame);
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructTableCellFrame(nsFrameConstructorState& aState,
    1:                                                nsIContent*              aContent,
    1:                                                nsIFrame*                aParentFrameIn,
    1:                                                nsStyleContext*          aStyleContext,
    1:                                                PRInt32                  aNameSpaceID,
    1:                                                PRBool                   aIsPseudo,
    1:                                                nsFrameItems&            aChildItems,
    1:                                                nsIFrame*&               aNewCellOuterFrame,
    1:                                                nsIFrame*&               aNewCellInnerFrame,
    1:                                                PRBool&                  aIsPseudoParent)
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (!aParentFrameIn) return rv;
    1: 
    1:   nsIFrame* parentFrame = aParentFrameIn;
    1:   aIsPseudoParent = PR_FALSE;
    1:   if (!aIsPseudo) {
    1:     // this frame may have a pseudo parent
    1:     // use nsGkAtoms::tableCellFrame which will match if it is really nsGkAtoms::bcTableCellFrame
    1:     GetParentFrame(aNameSpaceID, *aParentFrameIn,
    1:                    nsGkAtoms::tableCellFrame, aState, parentFrame,
    1:                    aIsPseudoParent);
    1:     if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aChildItems);
    1:     }
    1:     if (!aIsPseudo && aIsPseudoParent && aState.mPseudoFrames.mCellOuter.mFrame) {
    1:       ProcessPseudoFrames(aState, nsGkAtoms::tableCellFrame);
    1:     }
    1:   }
    1: #ifdef MOZ_MATHML
    1:   // <mtable> is border separate in mathml.css and the MathML code doesn't implement
    1:   // border collapse. For those users who style <mtable> with border collapse,
    1:   // give them the default non-MathML table frames that understand border collpase.
    1:   // This won't break us because MathML table frames are all subclasses of the default
    1:   // table code, and so we can freely mix <mtable> with <mtr> or <tr>, <mtd> or <td>.
    1:   // What will happen is just that non-MathML frames won't understand MathML attributes
    1:   // and will therefore miss the special handling that the MathML code does.
    1:   if (kNameSpaceID_MathML == aNameSpaceID && !IsBorderCollapse(parentFrame))
    1:     aNewCellOuterFrame = NS_NewMathMLmtdFrame(mPresShell, aStyleContext);
    1:   else
    1: #endif
 8578:     // Warning: If you change this and add a wrapper frame around table cell
 8578:     // frames, make sure Bug 368554 doesn't regress!
 8578:     // See IsInAutoWidthTableCellForQuirk() in nsImageFrame.cpp.    
    1:     aNewCellOuterFrame = NS_NewTableCellFrame(mPresShell, aStyleContext,
    1:                                               IsBorderCollapse(parentFrame));
    1: 
    1:   if (NS_UNLIKELY(!aNewCellOuterFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // Initialize the table cell frame
    1:   InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewCellOuterFrame);
23395:   nsHTMLContainerFrame::CreateViewForFrame(aNewCellOuterFrame, PR_FALSE);
    1:   
    1:   // Resolve pseudo style and initialize the body cell frame
    1:   nsRefPtr<nsStyleContext> innerPseudoStyle;
    1:   innerPseudoStyle = mPresShell->StyleSet()->
    1:     ResolvePseudoStyleFor(aContent,
    1:                           nsCSSAnonBoxes::cellContent, aStyleContext);
    1: 
    1:   // Create a block frame that will format the cell's content
 6818:   PRBool isBlock;
    1: #ifdef MOZ_MATHML
 6818:   if (kNameSpaceID_MathML == aNameSpaceID) {
    1:     aNewCellInnerFrame = NS_NewMathMLmtdInnerFrame(mPresShell, innerPseudoStyle);
 6818:     isBlock = PR_FALSE;
 6818:   }
    1:   else
    1: #endif
 6818:   {
    1:     aNewCellInnerFrame = NS_NewTableCellInnerFrame(mPresShell, innerPseudoStyle);
 6818:     isBlock = PR_TRUE;
 6818:   }
    1: 
    1: 
    1:   if (NS_UNLIKELY(!aNewCellInnerFrame)) {
    1:     aNewCellOuterFrame->Destroy();
    1:     aNewCellOuterFrame = nsnull;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   InitAndRestoreFrame(aState, aContent, aNewCellOuterFrame, nsnull, aNewCellInnerFrame);
    1: 
    1:   if (!aIsPseudo) {
    1:     // Process the child content
    1:     nsFrameItems childItems;
23352:     rv = ProcessChildren(aState, aContent, aStyleContext, aNewCellInnerFrame, 
 6820:                          PR_TRUE, childItems, isBlock);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:       // Clean up
    1:       // XXXbz kids of this stuff need to be cleaned up too!
    1:       aNewCellInnerFrame->Destroy();
    1:       aNewCellInnerFrame = nsnull;
    1:       aNewCellOuterFrame->Destroy();
    1:       aNewCellOuterFrame = nsnull;
    1:       return rv;
    1:     }
    1: 
    1:     aNewCellInnerFrame->SetInitialChildList(nsnull, childItems.childList);
    1:     aNewCellOuterFrame->SetInitialChildList(nsnull, aNewCellInnerFrame);
    1:     if (aIsPseudoParent) {
    1:       aState.mPseudoFrames.mRow.mChildList.AddChild(aNewCellOuterFrame);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: static PRBool 
    1: NeedFrameFor(nsIFrame*   aParentFrame,
    1:              nsIContent* aChildContent) 
    1: {
16976:   // don't create a whitespace frame if aParentFrame doesn't want it.
16976:   // always create frames for children in generated content. counter(),
16976:   // quotes, and attr() content can easily change dynamically and we don't
16976:   // want to be reconstructing frames. It's not even clear that these
16976:   // should be considered ignorable just because they evaluate to
16976:   // whitespace.
16976:   return !aParentFrame->IsFrameOfType(nsIFrame::eExcludesIgnorableWhitespace)
16976:     || !TextIsOnlyWhitespace(aChildContent)
16976:     || aParentFrame->IsGeneratedContentFrame();
    1: }
    1: 
    1: /***********************************************
    1:  * END TABLE SECTION
    1:  ***********************************************/
    1: 
    1: static PRBool CheckOverflow(nsPresContext* aPresContext,
    1:                             const nsStyleDisplay* aDisplay)
    1: {
    1:   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
    1:     return PR_FALSE;
    1: 
    1:   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_CLIP)
    1:     aPresContext->SetViewportOverflowOverride(NS_STYLE_OVERFLOW_HIDDEN,
    1:                                               NS_STYLE_OVERFLOW_HIDDEN);
    1:   else
    1:     aPresContext->SetViewportOverflowOverride(aDisplay->mOverflowX,
    1:                                               aDisplay->mOverflowY);
    1:   return PR_TRUE;
    1: }
    1: 
    1: /**
    1:  * This checks the root element and the HTML BODY, if any, for an "overflow" property
    1:  * that should be applied to the viewport. If one is found then we return the
    1:  * element that we took the overflow from (which should then be treated as
    1:  * "overflow:visible"), and we store the overflow style in the prescontext.
    1:  * @return if scroll was propagated from some content node, the content node it
    1:  *         was propagated from.
    1:  */
    1: nsIContent*
    1: nsCSSFrameConstructor::PropagateScrollToViewport()
    1: {
    1:   // Set default
    1:   nsPresContext* presContext = mPresShell->GetPresContext();
    1:   presContext->SetViewportOverflowOverride(NS_STYLE_OVERFLOW_AUTO,
    1:                                            NS_STYLE_OVERFLOW_AUTO);
    1: 
    1:   // We never mess with the viewport scroll state
    1:   // when printing or in print preview
    1:   if (presContext->IsPaginated()) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsIContent* docElement = mDocument->GetRootContent();
    1: 
    1:   // Check the style on the document root element
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1:   nsRefPtr<nsStyleContext> rootStyle;
    1:   rootStyle = styleSet->ResolveStyleFor(docElement, nsnull);
    1:   if (!rootStyle) {
    1:     return nsnull;
    1:   }
    1:   if (CheckOverflow(presContext, rootStyle->GetStyleDisplay())) {
    1:     // tell caller we stole the overflow style from the root element
    1:     return docElement;
    1:   }
    1:   
    1:   // Don't look in the BODY for non-HTML documents or HTML documents
    1:   // with non-HTML roots
    1:   // XXX this should be earlier; we shouldn't even look at the document root
    1:   // for non-HTML documents. Fix this once we support explicit CSS styling
    1:   // of the viewport
    1:   // XXX what about XHTML?
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(mDocument));
    1:   if (!htmlDoc || !docElement->IsNodeOfType(nsINode::eHTML)) {
    1:     return nsnull;
    1:   }
    1:   
    1:   nsCOMPtr<nsIDOMHTMLElement> body;
    1:   htmlDoc->GetBody(getter_AddRefs(body));
    1:   nsCOMPtr<nsIContent> bodyElement = do_QueryInterface(body);
    1:   
    1:   if (!bodyElement ||
    1:       !bodyElement->NodeInfo()->Equals(nsGkAtoms::body)) {
    1:     // The body is not a <body> tag, it's a <frameset>.
    1:     return nsnull;
    1:   }
    1: 
    1:   nsRefPtr<nsStyleContext> bodyStyle;
    1:   bodyStyle = styleSet->ResolveStyleFor(bodyElement, rootStyle);
    1:   if (!bodyStyle) {
    1:     return nsnull;
    1:   }
    1: 
    1:   if (CheckOverflow(presContext, bodyStyle->GetStyleDisplay())) {
    1:     // tell caller we stole the overflow style from the body element
    1:     return bodyElement;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: /**
    1:  * New one
    1:  */
    1: nsresult
    1: nsCSSFrameConstructor::ConstructDocElementFrame(nsFrameConstructorState& aState,
    1:                                                 nsIContent*              aDocElement,
    1:                                                 nsIFrame*                aParentFrame,
    1:                                                 nsIFrame**               aNewFrame)
    1: {
    1:   *aNewFrame = nsnull;
    1: 
    1:   if (!mTempFrameTreeState)
    1:     aState.mPresShell->CaptureHistoryState(getter_AddRefs(mTempFrameTreeState));
    1: 
    1:   // ----- reattach gfx scrollbars ------
    1:   // Gfx scrollframes were created in the root frame but the primary frame map may have been destroyed if a 
    1:   // new style sheet was loaded so lets reattach the frames to their content.
    1:   // XXX this seems truly bogus, we wipe out mGfxScrollFrame below
    1:   if (mGfxScrollFrame) {
    1:     nsIFrame* gfxScrollbarFrame1 = mGfxScrollFrame->GetFirstChild(nsnull);
23830:     // Check the frame type because when there aren't scrollbars, we'll
23830:     // get the canvas.
23830:     if (gfxScrollbarFrame1 &&
23830:         gfxScrollbarFrame1->GetType() == nsGkAtoms::scrollbarFrame) {
    1:       // XXX This works, but why?
    1:       aState.mFrameManager->
    1:         SetPrimaryFrameFor(gfxScrollbarFrame1->GetContent(), gfxScrollbarFrame1);
    1: 
    1:       nsIFrame* gfxScrollbarFrame2 = gfxScrollbarFrame1->GetNextSibling();
23830:       if (gfxScrollbarFrame2 &&
23830:           gfxScrollbarFrame2->GetType() == nsGkAtoms::scrollbarFrame) {
    1:         // XXX This works, but why?
    1:         aState.mFrameManager->
    1:           SetPrimaryFrameFor(gfxScrollbarFrame2->GetContent(), gfxScrollbarFrame2);
    1:       }
    1:     }
    1:   }
    1: 
    1:   // --------- CREATE AREA OR BOX FRAME -------
    1:   nsRefPtr<nsStyleContext> styleContext;
    1:   styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
    1:                                                          nsnull);
    1: 
    1:   const nsStyleDisplay* display = styleContext->GetStyleDisplay();
    1: 
    1:   // Ensure that our XBL bindings are installed.
    1:   if (display->mBinding) {
    1:     // Get the XBL loader.
    1:     nsresult rv;
    1:     PRBool resolveStyle;
    1:     
    1:     nsIXBLService * xblService = GetXBLService();
    1:     if (!xblService)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     nsRefPtr<nsXBLBinding> binding;
 3645:     rv = xblService->LoadBindings(aDocElement, display->mBinding->mURI,
 3645:                                   display->mBinding->mOriginPrincipal,
 3645:                                   PR_FALSE, getter_AddRefs(binding),
 3645:                                   &resolveStyle);
    1:     if (NS_FAILED(rv))
    1:       return NS_OK; // Binding will load asynchronously.
    1: 
    1:     if (binding) {
    1:       mDocument->BindingManager()->AddToAttachedQueue(binding);
    1:     }
    1: 
    1:     if (resolveStyle) {
    1:       styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
    1:                                                              nsnull);
    1:       display = styleContext->GetStyleDisplay();
    1:     }
    1:   }
    1: 
    1:   // --------- IF SCROLLABLE WRAP IN SCROLLFRAME --------
    1: 
    1: #ifdef DEBUG
    1:   PRBool propagatedScrollToViewport =
    1:     PropagateScrollToViewport() == aDocElement;
    1: 
    1:   NS_ASSERTION(!display->IsScrollableOverflow() || 
    1:                aState.mPresContext->IsPaginated() ||
    1:                propagatedScrollToViewport,
    1:                "Scrollbars should have been propagated to the viewport");
    1: #endif
    1: 
19172:   if (NS_UNLIKELY(display->mDisplay == NS_STYLE_DISPLAY_NONE)) {
23523:     aState.mFrameManager->SetUndisplayedContent(aDocElement, styleContext);
19172:     mInitialContainingBlock = nsnull;
19172:     mRootElementStyleFrame = nsnull;
19172:     return NS_OK;
19172:   }
19172: 
18953:   nsFrameConstructorSaveState absoluteSaveState;
18953:   if (mHasRootAbsPosContainingBlock) {
18953:     // Push the absolute containing block now so we can absolutely position
18953:     // the root element
18953:     aState.PushAbsoluteContainingBlock(mDocElementContainingBlock, absoluteSaveState);
18953:   }
18953: 
    1:   nsresult rv;
    1: 
    1:   // The rules from CSS 2.1, section 9.2.4, have already been applied
    1:   // by the style system, so we can assume that display->mDisplay is
    1:   // either NONE, BLOCK, or TABLE.
    1: 
18953:   // contentFrame is the primary frame for the root element. *aNewFrame
18953:   // is the frame that will be the child of the initial containing block.
18953:   // These are usually the same frame but they can be different, in
18953:   // particular if the root frame is positioned, in which case
18953:   // contentFrame is the out-of-flow frame and *aNewFrame is the
18953:   // placeholder.
18953:   nsIFrame* contentFrame;
18953:   PRBool processChildren = PR_FALSE;
23938: 
23938:   // Check whether we need to build a XUL box or SVG root frame
23938: #ifdef MOZ_XUL
23938:   if (aDocElement->IsNodeOfType(nsINode::eXUL)) {
23938:     contentFrame = NS_NewDocElementBoxFrame(mPresShell, styleContext);
23938:     if (NS_UNLIKELY(!contentFrame)) {
23938:       return NS_ERROR_OUT_OF_MEMORY;
23938:     }
23938:     InitAndRestoreFrame(aState, aDocElement, aParentFrame, nsnull, contentFrame);
23938:     *aNewFrame = contentFrame;
23938:     processChildren = PR_TRUE;
23938:   }
23938:   else
23938: #endif
23938: #ifdef MOZ_SVG
23938:   if (aDocElement->GetNameSpaceID() == kNameSpaceID_SVG) {
23938:     if (aDocElement->Tag() == nsGkAtoms::svg && NS_SVGEnabled()) {
23953:       contentFrame = NS_NewSVGOuterSVGFrame(mPresShell, styleContext);
23938:       if (NS_UNLIKELY(!contentFrame)) {
23938:         return NS_ERROR_OUT_OF_MEMORY;
23938:       }
23938:       InitAndRestoreFrame(aState, aDocElement,
23938:                           aState.GetGeometricParent(display, aParentFrame),
23938:                           nsnull, contentFrame);
23938: 
23938:       // AddChild takes care of transforming the frame tree for fixed-pos
23938:       // or abs-pos situations
23938:       nsFrameItems frameItems;
23938:       rv = aState.AddChild(contentFrame, frameItems, aDocElement,
23938:                            styleContext, aParentFrame);
23938:       if (NS_FAILED(rv) || !frameItems.childList) {
23938:         return rv;
23938:       }
23938:       *aNewFrame = frameItems.childList;
23938:       processChildren = PR_TRUE;
23938: 
23938:       // See if we need to create a view
23938:       nsHTMLContainerFrame::CreateViewForFrame(contentFrame, PR_FALSE);
23938:     } else {
23938:       return NS_ERROR_FAILURE;
23938:     }
23938:   }
23938:   else
23938: #endif
23938:   {
23938:     PRBool docElemIsTable = (display->mDisplay == NS_STYLE_DISPLAY_TABLE);
    1:     if (docElemIsTable) {
18953:       nsIFrame* innerTableFrame;
18953:       nsFrameItems frameItems;
    1:       // if the document is a table then just populate it.
18953:       rv = ConstructTableFrame(aState, aDocElement,
18953:                                aParentFrame, styleContext,
23938:                                kNameSpaceID_None, PR_FALSE, frameItems,
23938:                                contentFrame, innerTableFrame);
18953:       if (NS_FAILED(rv))
18953:         return rv;
18953:       if (!contentFrame || !frameItems.childList)
18953:         return NS_ERROR_FAILURE;
18953:       *aNewFrame = frameItems.childList;
18953:       NS_ASSERTION(!frameItems.childList->GetNextSibling(),
18953:                    "multiple root element frames");
    1:     } else {
18953:       contentFrame = NS_NewBlockFrame(mPresShell, styleContext,
23305:         NS_BLOCK_FLOAT_MGR|NS_BLOCK_MARGIN_ROOT);
18953:       if (!contentFrame)
18885:         return NS_ERROR_OUT_OF_MEMORY;
18953:       nsFrameItems frameItems;
18953:       rv = ConstructBlock(aState, display, aDocElement,
18953:                           aState.GetGeometricParent(display, aParentFrame),
18953:                           aParentFrame, styleContext, &contentFrame,
18953:                           frameItems, display->IsPositioned());
18953:       if (NS_FAILED(rv) || !frameItems.childList)
18953:         return rv;
18953:       *aNewFrame = frameItems.childList;
18953:       NS_ASSERTION(!frameItems.childList->GetNextSibling(),
18953:                    "multiple root element frames");
18953:     }
    1:   }
    1: 
    1:   // set the primary frame
    1:   aState.mFrameManager->SetPrimaryFrameFor(aDocElement, contentFrame);
    1: 
20147:   NS_ASSERTION(processChildren ? !mInitialContainingBlock :
20147:                  mInitialContainingBlock == contentFrame,
20147:                "unexpected mInitialContainingBlock");
    1:   mInitialContainingBlock = contentFrame;
    1: 
16509:   // Figure out which frame has the main style for the document element,
16509:   // assigning it to mRootElementStyleFrame.
16509:   // Backgrounds should be propagated from that frame to the viewport.
16509:   PRBool isChild;
16509:   contentFrame->GetParentStyleContextFrame(aState.mPresContext,
16509:           &mRootElementStyleFrame, &isChild);
16509:   if (!isChild) {
16509:     mRootElementStyleFrame = mInitialContainingBlock;
16509:   }
16509: 
18953:   if (processChildren) {
18953:     // Still need to process the child content
    1:     nsFrameItems childItems;
    1: 
18953:     NS_ASSERTION(!nsLayoutUtils::GetAsBlock(contentFrame),
18953:                  "Only XUL and SVG frames should reach here");
23352:     ProcessChildren(aState, aDocElement, styleContext, contentFrame, PR_TRUE,
23352:                     childItems, PR_FALSE);
    1: 
    1:     // Set the initial child lists
    1:     contentFrame->SetInitialChildList(nsnull, childItems.childList);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructRootFrame(nsIContent*     aDocElement,
    1:                                           nsIFrame**      aNewFrame)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
    1:   NS_PRECONDITION(aNewFrame, "null out param");
    1:   
    1:     /*
18953:        how the root frame hierarchy should look
18953: 
18953:   Galley presentation, non-XUL, with scrolling (i.e. not a frameset):
18953:   
18953:       ViewportFrame [fixed-cb]
18953:         nsHTMLScrollFrame
18953:           CanvasFrame [abs-cb]
18953:             root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
18953:                                 nsTableOuterFrame, nsPlaceholderFrame)
18953: 
18953:   Galley presentation, non-XUL, without scrolling (i.e. a frameset):
18953:   
18953:       ViewportFrame [fixed-cb]
18953:         CanvasFrame [abs-cb]
18953:           root element frame (nsBlockFrame)
18953: 
18953:   Galley presentation, XUL
18953:   
18953:       ViewportFrame [fixed-cb]
18953:         nsRootBoxFrame
18953:           root element frame (nsDocElementBoxFrame)
18953: 
18953:   Print presentation, non-XUL
18953: 
18953:       ViewportFrame
18953:         nsSimplePageSequenceFrame
18953:           nsPageFrame [fixed-cb]
18953:             nsPageContentFrame
18953:               CanvasFrame [abs-cb]
18953:                 root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
18953:                                     nsTableOuterFrame, nsPlaceholderFrame)
18953: 
18953:   Print-preview presentation, non-XUL
18953: 
18953:       ViewportFrame
18953:         nsHTMLScrollFrame
18953:           nsSimplePageSequenceFrame
18953:             nsPageFrame [fixed-cb]
18953:               nsPageContentFrame
18953:                 CanvasFrame [abs-cb]
18953:                   root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
18953:                                       nsTableOuterFrame, nsPlaceholderFrame)
18953: 
18953:   Print/print preview of XUL is not supported.
18953:   [fixed-cb]: the default containing block for fixed-pos content
18953:   [abs-cb]: the default containing block for abs-pos content
18953:  
18953:   Meaning of nsCSSFrameConstructor fields:
18953:     mInitialContainingBlock is "root element frame".
18953:     mDocElementContainingBlock is the parent of mInitialContainingBlock
18953:       (i.e. CanvasFrame or nsRootBoxFrame)
18953:     mFixedContainingBlock is the [fixed-cb]
18953:     mGfxScrollFrame is the nsHTMLScrollFrame mentioned above, or null if there isn't one
18953:     mPageSequenceFrame is the nsSimplePageSequenceFrame, or null if there isn't one
    1: */
    1: 
    1:   // Set up our style rule observer.
    1:   {
    1:     mPresShell->StyleSet()->SetBindingManager(mDocument->BindingManager());
    1:   }
    1: 
    1:   // --------- BUILD VIEWPORT -----------
    1:   nsIFrame*                 viewportFrame = nsnull;
    1:   nsRefPtr<nsStyleContext> viewportPseudoStyle;
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1: 
    1:   viewportPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
    1:                                                         nsCSSAnonBoxes::viewport,
    1:                                                         nsnull);
    1: 
    1:   viewportFrame = NS_NewViewportFrame(mPresShell, viewportPseudoStyle);
    1: 
    1:   nsPresContext* presContext = mPresShell->GetPresContext();
    1: 
    1:   // XXXbz do we _have_ to pass a null content pointer to that frame?
    1:   // Would it really kill us to pass in the root element or something?
    1:   // What would that break?
    1:   viewportFrame->Init(nsnull, nsnull, nsnull);
    1: 
    1:   // Bind the viewport frame to the root view
    1:   nsIViewManager* viewManager = mPresShell->GetViewManager();
    1:   nsIView*        rootView;
    1: 
    1:   viewManager->GetRootView(rootView);
    1:   viewportFrame->SetView(rootView);
    1: 
    1:   nsContainerFrame::SyncFrameViewProperties(presContext, viewportFrame,
    1:                                             viewportPseudoStyle, rootView);
    1: 
    1:   // The viewport is the containing block for 'fixed' elements
    1:   mFixedContainingBlock = viewportFrame;
    1: 
    1:   // --------- CREATE ROOT FRAME -------
    1: 
    1: 
    1:   // Create the root frame. The document element's frame is a child of the
    1:   // root frame.
    1:   //
    1:   // The root frame serves two purposes:
    1:   // - reserves space for any margins needed for the document element's frame
    1:   // - renders the document element's background. This ensures the background covers
    1:   //   the entire canvas as specified by the CSS2 spec
    1: 
    1:   PRBool isPaginated = presContext->IsRootPaginatedDocument();
    1: 
    1:   nsIFrame* rootFrame = nsnull;
    1:   nsIAtom* rootPseudo;
    1:         
    1:   if (!isPaginated) {
    1: #ifdef MOZ_XUL
    1:     if (aDocElement->IsNodeOfType(nsINode::eXUL))
    1:     {
    1:       // pass a temporary stylecontext, the correct one will be set later
    1:       rootFrame = NS_NewRootBoxFrame(mPresShell, viewportPseudoStyle);
    1:     } else
    1: #endif
    1:     {
    1:       // pass a temporary stylecontext, the correct one will be set later
    1:       rootFrame = NS_NewCanvasFrame(mPresShell, viewportPseudoStyle);
18953:       mHasRootAbsPosContainingBlock = PR_TRUE;
    1:     }
    1: 
    1:     rootPseudo = nsCSSAnonBoxes::canvas;
    1:     mDocElementContainingBlock = rootFrame;
    1:   } else {
    1:     // Create a page sequence frame
    1:     rootFrame = NS_NewSimplePageSequenceFrame(mPresShell, viewportPseudoStyle);
    1:     mPageSequenceFrame = rootFrame;
    1:     rootPseudo = nsCSSAnonBoxes::pageSequence;
    1:   }
    1: 
    1: 
    1:   // --------- IF SCROLLABLE WRAP IN SCROLLFRAME --------
    1: 
    1:   // If the device supports scrolling (e.g., in galley mode on the screen and
    1:   // for print-preview, but not when printing), then create a scroll frame that
    1:   // will act as the scrolling mechanism for the viewport. 
    1:   // XXX Do we even need a viewport when printing to a printer?
    1: 
    1:   // As long as the webshell doesn't prohibit it, and the device supports
    1:   // it, create a scroll frame that will act as the scolling mechanism for
    1:   // the viewport.
    1:   //
    1:   // Threre are three possible values stored in the docshell:
    1:   //  1) nsIScrollable::Scrollbar_Never = no scrollbars
    1:   //  2) nsIScrollable::Scrollbar_Auto = scrollbars appear if needed
    1:   //  3) nsIScrollable::Scrollbar_Always = scrollbars always
    1:   // Only need to create a scroll frame/view for cases 2 and 3.
    1: 
    1:   PRBool isHTML = aDocElement->IsNodeOfType(nsINode::eHTML);
    1:   PRBool isXUL = PR_FALSE;
    1: 
    1:   if (!isHTML) {
    1:     isXUL = aDocElement->IsNodeOfType(nsINode::eXUL);
    1:   }
    1: 
    1:   // Never create scrollbars for XUL documents
    1:   PRBool isScrollable = !isXUL;
    1: 
    1:   // Never create scrollbars for frameset documents.
    1:   if (isHTML) {
    1:     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
    1:     if (htmlDoc && htmlDoc->GetIsFrameset())
    1:       isScrollable = PR_FALSE;
    1:   }
    1: 
    1:   if (isPaginated) {
    1:     isScrollable = presContext->HasPaginatedScrolling();
    1:   }
    1: 
    1:   // We no longer need to do overflow propagation here. It's taken care of
    1:   // when we construct frames for the element whose overflow might be
    1:   // propagated
    1:   NS_ASSERTION(!isScrollable || !isXUL,
    1:                "XUL documents should never be scrollable - see above");
    1: 
    1:   nsIFrame* newFrame = rootFrame;
    1:   nsRefPtr<nsStyleContext> rootPseudoStyle;
    1:   // we must create a state because if the scrollbars are GFX it needs the 
    1:   // state to build the scrollbar frames.
    1:   nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull);
    1: 
    1:   nsIFrame* parentFrame = viewportFrame;
    1: 
    1:   // If paginated, make sure we don't put scrollbars in
    1:   if (!isScrollable) {
    1:     rootPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
    1:                                                       rootPseudo,
    1:                                                       viewportPseudoStyle);
    1:   } else {
    1:       if (rootPseudo == nsCSSAnonBoxes::canvas) {
    1:         rootPseudo = nsCSSAnonBoxes::scrolledCanvas;
    1:       } else {
    1:         NS_ASSERTION(rootPseudo == nsCSSAnonBoxes::pageSequence,
    1:                      "Unknown root pseudo");
    1:         rootPseudo = nsCSSAnonBoxes::scrolledPageSequence;
    1:       }
    1: 
    1:       // Build the frame. We give it the content we are wrapping which is the document,
    1:       // the root frame, the parent view port frame, and we should get back the new
    1:       // frame and the scrollable view if one was created.
    1: 
    1:       // resolve a context for the scrollframe
    1:       nsRefPtr<nsStyleContext>  styleContext;
    1:       styleContext = styleSet->ResolvePseudoStyleFor(nsnull,
    1:                                                      nsCSSAnonBoxes::viewportScroll,
    1:                                                      viewportPseudoStyle);
    1: 
    1:       // Note that the viewport scrollframe is always built with
    1:       // overflow:auto style. This forces the scroll frame to create
    1:       // anonymous content for both scrollbars. This is necessary even
    1:       // if the HTML or BODY elements are overriding the viewport
    1:       // scroll style to 'hidden' --- dynamic style changes might put
    1:       // scrollbars back on the viewport and we don't want to have to
    1:       // reframe the viewport to create the scrollbar content.
    1:       newFrame = nsnull;
    1:       rootPseudoStyle = BeginBuildingScrollFrame( state,
    1:                                                   aDocElement,
    1:                                                   styleContext,
    1:                                                   viewportFrame,
    1:                                                   rootPseudo,
    1:                                                   PR_TRUE,
    1:                                                   newFrame);
    1: 
23554:       nsIScrollableFrame* scrollable = do_QueryFrame(newFrame);
    1:       NS_ENSURE_TRUE(scrollable, NS_ERROR_FAILURE);
    1: 
    1:       nsIScrollableView* scrollableView = scrollable->GetScrollableView();
    1:       NS_ENSURE_TRUE(scrollableView, NS_ERROR_FAILURE);
    1: 
    1:       viewManager->SetRootScrollableView(scrollableView);
    1:       parentFrame = newFrame;
    1: 
    1:       mGfxScrollFrame = newFrame;
    1:   }
    1:   
    1:   rootFrame->SetStyleContextWithoutNotification(rootPseudoStyle);
    1:   rootFrame->Init(aDocElement, parentFrame, nsnull);
    1:   
    1:   if (isScrollable) {
    1:     FinishBuildingScrollFrame(parentFrame, rootFrame);
    1:   }
    1:   
    1:   if (isPaginated) { // paginated
    1:     // Create the first page
    1:     // Set the initial child lists
18953:     nsIFrame *pageFrame, *canvasFrame;
    1:     ConstructPageFrame(mPresShell, presContext, rootFrame, nsnull,
18953:                        pageFrame, canvasFrame);
    1:     rootFrame->SetInitialChildList(nsnull, pageFrame);
    1: 
    1:     // The eventual parent of the document element frame.
    1:     // XXX should this be set for every new page (in ConstructPageFrame)?
18953:     mDocElementContainingBlock = canvasFrame;
18953:     mHasRootAbsPosContainingBlock = PR_TRUE;
    1:   }
    1: 
    1:   viewportFrame->SetInitialChildList(nsnull, newFrame);
    1:   
    1:   *aNewFrame = viewportFrame;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructPageFrame(nsIPresShell*  aPresShell,
    1:                                           nsPresContext* aPresContext,
    1:                                           nsIFrame*      aParentFrame,
    1:                                           nsIFrame*      aPrevPageFrame,
    1:                                           nsIFrame*&     aPageFrame,
18953:                                           nsIFrame*&     aCanvasFrame)
    1: {
    1:   nsStyleContext* parentStyleContext = aParentFrame->GetStyleContext();
    1:   nsStyleSet *styleSet = aPresShell->StyleSet();
    1: 
    1:   nsRefPtr<nsStyleContext> pagePseudoStyle;
    1:   pagePseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
    1:                                                     nsCSSAnonBoxes::page,
    1:                                                     parentStyleContext);
    1: 
    1:   aPageFrame = NS_NewPageFrame(aPresShell, pagePseudoStyle);
    1:   if (NS_UNLIKELY(!aPageFrame))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // Initialize the page frame and force it to have a view. This makes printing of
    1:   // the pages easier and faster.
    1:   aPageFrame->Init(nsnull, aParentFrame, aPrevPageFrame);
    1: 
    1:   nsRefPtr<nsStyleContext> pageContentPseudoStyle;
    1:   pageContentPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
    1:                                                            nsCSSAnonBoxes::pageContent,
    1:                                                            pagePseudoStyle);
    1: 
18953:   nsIFrame* pageContentFrame = NS_NewPageContentFrame(aPresShell, pageContentPseudoStyle);
18953:   if (NS_UNLIKELY(!pageContentFrame))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // Initialize the page content frame and force it to have a view. Also make it the
    1:   // containing block for fixed elements which are repeated on every page.
 4006:   nsIFrame* prevPageContentFrame = nsnull;
 4006:   if (aPrevPageFrame) {
 4006:     prevPageContentFrame = aPrevPageFrame->GetFirstChild(nsnull);
 4006:     NS_ASSERTION(prevPageContentFrame, "missing page content frame");
 4006:   }
18953:   pageContentFrame->Init(nsnull, aPageFrame, prevPageContentFrame);
18953:   aPageFrame->SetInitialChildList(nsnull, pageContentFrame);
18953:   mFixedContainingBlock = pageContentFrame;
18953: 
18953:   nsRefPtr<nsStyleContext> canvasPseudoStyle;
18953:   canvasPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
18953:                                                       nsCSSAnonBoxes::canvas,
18953:                                                       pageContentPseudoStyle);
18953: 
18953:   aCanvasFrame = NS_NewCanvasFrame(aPresShell, canvasPseudoStyle);
18953:   if (NS_UNLIKELY(!aCanvasFrame))
18953:     return NS_ERROR_OUT_OF_MEMORY;
18953: 
18953:   nsIFrame* prevCanvasFrame = nsnull;
18953:   if (prevPageContentFrame) {
18953:     prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
18953:     NS_ASSERTION(prevCanvasFrame, "missing canvas frame");
18953:   }
18953:   aCanvasFrame->Init(nsnull, pageContentFrame, prevCanvasFrame);
18953:   pageContentFrame->SetInitialChildList(nsnull, aCanvasFrame);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsCSSFrameConstructor::CreatePlaceholderFrameFor(nsIPresShell*    aPresShell, 
    1:                                                  nsIContent*      aContent,
    1:                                                  nsIFrame*        aFrame,
    1:                                                  nsStyleContext*  aStyleContext,
    1:                                                  nsIFrame*        aParentFrame,
 6219:                                                  nsIFrame*        aPrevInFlow,
    1:                                                  nsIFrame**       aPlaceholderFrame)
    1: {
    1:   nsRefPtr<nsStyleContext> placeholderStyle = aPresShell->StyleSet()->
    1:     ResolveStyleForNonElement(aStyleContext->GetParent());
    1:   
    1:   // The placeholder frame gets a pseudo style context
    1:   nsPlaceholderFrame* placeholderFrame =
    1:     (nsPlaceholderFrame*)NS_NewPlaceholderFrame(aPresShell, placeholderStyle);
    1: 
    1:   if (placeholderFrame) {
 6219:     placeholderFrame->Init(aContent, aParentFrame, aPrevInFlow);
    1:   
    1:     // The placeholder frame has a pointer back to the out-of-flow frame
    1:     placeholderFrame->SetOutOfFlowFrame(aFrame);
    1:   
    1:     aFrame->AddStateBits(NS_FRAME_OUT_OF_FLOW);
    1: 
    1:     // Add mapping from absolutely positioned frame to its placeholder frame
 6219:     aPresShell->FrameManager()->RegisterPlaceholderFrame(placeholderFrame);
    1: 
 3233:     *aPlaceholderFrame = static_cast<nsIFrame*>(placeholderFrame);
    1:     
    1:     return NS_OK;
    1:   }
    1:   else {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructButtonFrame(nsFrameConstructorState& aState,
    1:                                             nsIContent*              aContent,
    1:                                             nsIFrame*                aParentFrame,
    1:                                             nsIAtom*                 aTag,
    1:                                             nsStyleContext*          aStyleContext,
    1:                                             const nsStyleDisplay*    aStyleDisplay,
 4461:                                             nsFrameItems&            aFrameItems,
23944:                                             nsIFrame**               aNewFrame)
23944: {
    1:   *aNewFrame = nsnull;
    1:   nsIFrame* buttonFrame = nsnull;
    1:   
    1:   if (nsGkAtoms::button == aTag) {
    1:     buttonFrame = NS_NewHTMLButtonControlFrame(mPresShell, aStyleContext);
    1:   }
    1:   else {
    1:     buttonFrame = NS_NewGfxButtonControlFrame(mPresShell, aStyleContext);
    1:   }
    1:   if (NS_UNLIKELY(!buttonFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   // Initialize the button frame
    1:   nsresult rv = InitAndRestoreFrame(aState, aContent,
    1:                                     aState.GetGeometricParent(aStyleDisplay, aParentFrame),
    1:                                     nsnull, buttonFrame);
    1:   if (NS_FAILED(rv)) {
    1:     buttonFrame->Destroy();
    1:     return rv;
    1:   }
23395:   // See if we need to create a view
23395:   nsHTMLContainerFrame::CreateViewForFrame(buttonFrame, PR_FALSE);
    1: 
    1:   
    1:   
    1:   nsRefPtr<nsStyleContext> styleContext;
    1:   styleContext = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
    1:                                                                nsCSSAnonBoxes::buttonContent,
    1:                                                                aStyleContext);
    1:                                                                
23176:   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, styleContext,
23305:                                           NS_BLOCK_FLOAT_MGR);
23167: 
23176:   if (NS_UNLIKELY(!blockFrame)) {
    1:     buttonFrame->Destroy();
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
23176:   rv = InitAndRestoreFrame(aState, aContent, buttonFrame, nsnull, blockFrame);
    1:   if (NS_FAILED(rv)) {
23176:     blockFrame->Destroy();
    1:     buttonFrame->Destroy();
    1:     return rv;
    1:   }
    1: 
 8199:   rv = aState.AddChild(buttonFrame, aFrameItems, aContent, aStyleContext,
 8199:                        aParentFrame);
    1:   if (NS_FAILED(rv)) {
23176:     blockFrame->Destroy();
    1:     buttonFrame->Destroy();
    1:     return rv;
    1:   }
    1: 
23343:   PRBool isLeaf = buttonFrame->IsLeaf();
23343: #ifdef DEBUG
23343:   // Make sure that we're an anonymous content creator exactly when we're a
23343:   // leaf
23554:   nsIAnonymousContentCreator* creator = do_QueryFrame(buttonFrame);
23343:   NS_ASSERTION(!creator == !isLeaf,
23343:                "Should be creator exactly when we're a leaf");
23343: #endif
23343:   
23343:   if (!isLeaf) { 
    1:     // Process children
    1:     nsFrameConstructorSaveState absoluteSaveState;
    1:     nsFrameItems                childItems;
    1: 
    1:     if (aStyleDisplay->IsPositioned()) {
    1:       // The area frame becomes a container for child frames that are
    1:       // absolutely positioned
23176:       aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
23176:     }
23176: 
23343: #ifdef DEBUG
23343:     // Make sure that anonymous child creation will have no effect in this case
23554:     nsIAnonymousContentCreator* creator = do_QueryFrame(blockFrame);
23343:     NS_ASSERTION(!creator, "Shouldn't be an anonymous content creator!");
23343: #endif
23343: 
23352:     rv = ProcessChildren(aState, aContent, aStyleContext, blockFrame, PR_TRUE,
23352:                          childItems,
 2829:                          buttonFrame->GetStyleDisplay()->IsBlockOutside());
    1:     if (NS_FAILED(rv)) return rv;
    1:   
    1:     // Set the areas frame's initial child lists
23176:     blockFrame->SetInitialChildList(nsnull, childItems.childList);
23176:   }
23176: 
23176:   buttonFrame->SetInitialChildList(nsnull, blockFrame);
23167: 
23343:   if (isLeaf) {
    1:     nsFrameItems  anonymousChildItems;
23343:     // if there are any anonymous children create frames for them.  Note that
23343:     // we're doing this using a different parent frame from the one we pass to
23343:     // ProcessChildren!
    1:     CreateAnonymousFrames(aTag, aState, aContent, buttonFrame,
23342:                           anonymousChildItems);
    1:     if (anonymousChildItems.childList) {
    1:       // the anonymous content is already parented to the area frame
23176:       aState.mFrameManager->AppendFrames(blockFrame, nsnull,
23176:                                          anonymousChildItems.childList);
23167:     }
    1:   }
    1: 
    1:   // our new button frame returned is the top frame. 
    1:   *aNewFrame = buttonFrame; 
    1: 
    1:   return NS_OK;  
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructSelectFrame(nsFrameConstructorState& aState,
    1:                                             nsIContent*              aContent,
    1:                                             nsIFrame*                aParentFrame,
    1:                                             nsIAtom*                 aTag,
    1:                                             nsStyleContext*          aStyleContext,
    1:                                             const nsStyleDisplay*    aStyleDisplay,
23944:                                             nsFrameItems&            aFrameItems,
23944:                                             nsIFrame**               aNewFrame)
    1: {
    1:   nsresult rv = NS_OK;
    1:   const PRInt32 kNoSizeSpecified = -1;
    1: 
    1:   // Construct a frame-based listbox or combobox
    1:   nsCOMPtr<nsIDOMHTMLSelectElement> sel(do_QueryInterface(aContent));
    1:   PRInt32 size = 1;
    1:   if (sel) {
    1:     sel->GetSize(&size); 
    1:     PRBool multipleSelect = PR_FALSE;
    1:     sel->GetMultiple(&multipleSelect);
    1:      // Construct a combobox if size=1 or no size is specified and its multiple select
    1:     if (((1 == size || 0 == size) || (kNoSizeSpecified  == size)) && (PR_FALSE == multipleSelect)) {
    1:         // Construct a frame-based combo box.
    1:         // The frame-based combo box is built out of three parts. A display area, a button and
    1:         // a dropdown list. The display area and button are created through anonymous content.
    1:         // The drop-down list's frame is created explicitly. The combobox frame shares its content
    1:         // with the drop-down list.
23305:       PRUint32 flags = NS_BLOCK_FLOAT_MGR;
    1:       nsIFrame* comboboxFrame = NS_NewComboboxControlFrame(mPresShell, aStyleContext, flags);
    1: 
    1:       // Save the history state so we don't restore during construction
    1:       // since the complete tree is required before we restore.
    1:       nsILayoutHistoryState *historyState = aState.mFrameState;
    1:       aState.mFrameState = nsnull;
    1:       // Initialize the combobox frame
    1:       InitAndRestoreFrame(aState, aContent,
    1:                           aState.GetGeometricParent(aStyleDisplay, aParentFrame),
    1:                           nsnull, comboboxFrame);
    1: 
23395:       nsHTMLContainerFrame::CreateViewForFrame(comboboxFrame, PR_FALSE);
    1: 
 8199:       rv = aState.AddChild(comboboxFrame, aFrameItems, aContent, aStyleContext,
 8199:                            aParentFrame);
    1:       if (NS_FAILED(rv)) {
    1:         return rv;
    1:       }
    1:       
    1:       ///////////////////////////////////////////////////////////////////
    1:       // Combobox - Old Native Implementation
    1:       ///////////////////////////////////////////////////////////////////
23554:       nsIComboboxControlFrame* comboBox = do_QueryFrame(comboboxFrame);
    1:       NS_ASSERTION(comboBox, "NS_NewComboboxControlFrame returned frame that "
    1:                              "doesn't implement nsIComboboxControlFrame");
    1: 
    1:         // Resolve pseudo element style for the dropdown list
    1:       nsRefPtr<nsStyleContext> listStyle;
    1:       listStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
    1:                                                                 nsCSSAnonBoxes::dropDownList, 
    1:                                                                 aStyleContext);
    1: 
    1:         // Create a listbox
    1:       nsIFrame* listFrame = NS_NewListControlFrame(mPresShell, listStyle);
    1: 
    1:         // Notify the listbox that it is being used as a dropdown list.
23554:       nsIListControlFrame * listControlFrame = do_QueryFrame(listFrame);
23554:       if (listControlFrame) {
    1:         listControlFrame->SetComboboxFrame(comboboxFrame);
    1:       }
    1:          // Notify combobox that it should use the listbox as it's popup
    1:       comboBox->SetDropDown(listFrame);
    1: 
    1:       NS_ASSERTION(!listStyle->GetStyleDisplay()->IsPositioned(),
    1:                    "Ended up with positioned dropdown list somehow.");
    1:       NS_ASSERTION(!listStyle->GetStyleDisplay()->IsFloating(),
    1:                    "Ended up with floating dropdown list somehow.");
    1:       
    1:       // Initialize the scroll frame positioned. Note that it is NOT
    1:       // initialized as absolutely positioned.
    1:       nsIFrame* scrolledFrame = NS_NewSelectsAreaFrame(mPresShell, aStyleContext, flags);
    1: 
    1:       InitializeSelectFrame(aState, listFrame, scrolledFrame, aContent,
    1:                             comboboxFrame, listStyle, PR_TRUE, aFrameItems);
    1: 
    1:         // Set flag so the events go to the listFrame not child frames.
    1:         // XXX: We should replace this with a real widget manager similar
    1:         // to how the nsFormControlFrame works. Re-directing events is a temporary Kludge.
    1:       NS_ASSERTION(listFrame->GetView(), "ListFrame's view is nsnull");
    1:       //listFrame->GetView()->SetViewFlags(NS_VIEW_PUBLIC_FLAG_DONT_CHECK_CHILDREN);
    1: 
    1:       // Create display and button frames from the combobox's anonymous content.
    1:       // The anonymous content is appended to existing anonymous content for this
    1:       // element (the scrollbars).
    1: 
    1:       nsFrameItems childItems;
    1:       CreateAnonymousFrames(nsGkAtoms::combobox, aState, aContent,
23342:                             comboboxFrame, childItems);
    1:   
    1:       comboboxFrame->SetInitialChildList(nsnull, childItems.childList);
    1: 
    1:       // Initialize the additional popup child list which contains the
    1:       // dropdown list frame.
    1:       nsFrameItems popupItems;
    1:       popupItems.AddChild(listFrame);
 4448:       comboboxFrame->SetInitialChildList(nsGkAtoms::selectPopupList,
    1:                                          popupItems.childList);
    1: 
23944:       *aNewFrame = comboboxFrame;
    1:       aState.mFrameState = historyState;
    1:       if (aState.mFrameState && aState.mFrameManager) {
    1:         // Restore frame state for the entire subtree of |comboboxFrame|.
    1:         aState.mFrameManager->RestoreFrameState(comboboxFrame,
    1:                                                 aState.mFrameState);
    1:       }
    1:     } else {
    1:       ///////////////////////////////////////////////////////////////////
    1:       // ListBox - Old Native Implementation
    1:       ///////////////////////////////////////////////////////////////////
    1:       nsIFrame* listFrame = NS_NewListControlFrame(mPresShell, aStyleContext);
    1:       if (listFrame) {
    1:         rv = NS_OK;
    1:       }
    1:       else {
    1:         rv = NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1: 
    1:       nsIFrame* scrolledFrame = NS_NewSelectsAreaFrame(
23305:         mPresShell, aStyleContext, NS_BLOCK_FLOAT_MGR);
    1: 
    1:       // ******* this code stolen from Initialze ScrollFrame ********
    1:       // please adjust this code to use BuildScrollFrame.
    1: 
    1:       InitializeSelectFrame(aState, listFrame, scrolledFrame, aContent,
    1:                             aParentFrame, aStyleContext, PR_FALSE, aFrameItems);
    1: 
23944:       *aNewFrame = listFrame;
    1:     }
    1:   }
    1:   return rv;
    1: 
    1: }
    1: 
    1: /**
    1:  * Used to be InitializeScrollFrame but now it's only used for the select tag
    1:  * But the select tag should really be fixed to use GFX scrollbars that can
    1:  * be create with BuildScrollFrame.
    1:  */
    1: nsresult
    1: nsCSSFrameConstructor::InitializeSelectFrame(nsFrameConstructorState& aState,
    1:                                              nsIFrame*                scrollFrame,
    1:                                              nsIFrame*                scrolledFrame,
    1:                                              nsIContent*              aContent,
    1:                                              nsIFrame*                aParentFrame,
    1:                                              nsStyleContext*          aStyleContext,
    1:                                              PRBool                   aBuildCombobox,
    1:                                              nsFrameItems&            aFrameItems)
    1: {
    1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
    1: 
    1:   // Initialize it
    1:   nsIFrame* geometricParent = aState.GetGeometricParent(display, aParentFrame);
    1:     
    1:   // We don't call InitAndRestoreFrame for scrollFrame because we can only
    1:   // restore the frame state after its parts have been created (in particular,
    1:   // the scrollable view). So we have to split Init and Restore.
    1: 
    1:   // Initialize the frame
    1:   scrollFrame->Init(aContent, geometricParent, nsnull);
    1: 
    1:   if (!aBuildCombobox) {
 8199:     nsresult rv = aState.AddChild(scrollFrame, aFrameItems, aContent,
 8199:                                   aStyleContext, aParentFrame);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1:   }
    1:       
23395:   nsHTMLContainerFrame::CreateViewForFrame(scrollFrame, aBuildCombobox);
    1:   if (aBuildCombobox) {
    1:     // Give the drop-down list a popup widget
    1:     nsIView* view = scrollFrame->GetView();
    1:     NS_ASSERTION(view, "We asked for a view but didn't get one");
    1:     if (view) {
    1:       view->GetViewManager()->SetViewFloating(view, PR_TRUE);
    1: 
    1:       nsWidgetInitData widgetData;
    1:       widgetData.mWindowType  = eWindowType_popup;
    1:       widgetData.mBorderStyle = eBorderStyle_default;
    1: 
    1: #if defined(XP_MACOSX) || defined(XP_BEOS) 
    1:       static NS_DEFINE_IID(kCPopUpCID,  NS_POPUP_CID);
    1:       view->CreateWidget(kCPopUpCID, &widgetData, nsnull);
    1: #else
    1:       static NS_DEFINE_IID(kCChildCID, NS_CHILD_CID);
    1:       view->CreateWidget(kCChildCID, &widgetData, nsnull);
    1: #endif
    1:     }
    1:   }
    1: 
    1:   BuildScrollFrame(aState, aContent, aStyleContext, scrolledFrame,
23950:                    geometricParent, scrollFrame);
    1: 
    1:   if (aState.mFrameState && aState.mFrameManager) {
    1:     // Restore frame state for the scroll frame
    1:     aState.mFrameManager->RestoreFrameStateFor(scrollFrame, aState.mFrameState);
    1:   }
    1: 
    1:   // Process children
    1:   nsFrameConstructorSaveState absoluteSaveState;
    1:   nsFrameItems                childItems;
    1: 
    1:   if (display->IsPositioned()) {
    1:     // The area frame becomes a container for child frames that are
    1:     // absolutely positioned
    1:     aState.PushAbsoluteContainingBlock(scrolledFrame, absoluteSaveState);
    1:   }
    1: 
23352:   ProcessChildren(aState, aContent, aStyleContext, scrolledFrame, PR_FALSE,
    1:                   childItems, PR_TRUE);
    1: 
    1:   // Set the scrolled frame's initial child lists
    1:   scrolledFrame->SetInitialChildList(nsnull, childItems.childList);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructFieldSetFrame(nsFrameConstructorState& aState,
    1:                                               nsIContent*              aContent,
    1:                                               nsIFrame*                aParentFrame,
    1:                                               nsIAtom*                 aTag,
    1:                                               nsStyleContext*          aStyleContext,
23944:                                               const nsStyleDisplay*    aStyleDisplay,
    1:                                               nsFrameItems&            aFrameItems,
23944:                                               nsIFrame**               aNewFrame)
    1: {
    1:   nsIFrame* newFrame = NS_NewFieldSetFrame(mPresShell, aStyleContext);
    1:   if (NS_UNLIKELY(!newFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // Initialize it
    1:   InitAndRestoreFrame(aState, aContent, 
    1:                       aState.GetGeometricParent(aStyleDisplay, aParentFrame),
    1:                       nsnull, newFrame);
    1: 
    1:   // See if we need to create a view, e.g. the frame is absolutely
    1:   // positioned
23395:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:   // Resolve style and initialize the frame
    1:   nsRefPtr<nsStyleContext> styleContext;
    1:   styleContext = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
    1:                                                                nsCSSAnonBoxes::fieldsetContent,
    1:                                                                aStyleContext);
    1:   
23176:   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, styleContext,
23305:                                           NS_BLOCK_FLOAT_MGR |
23176:                                           NS_BLOCK_MARGIN_ROOT);
23176:   InitAndRestoreFrame(aState, aContent, newFrame, nsnull, blockFrame);
    1: 
 8199:   nsresult rv = aState.AddChild(newFrame, aFrameItems, aContent, aStyleContext,
 8199:                                 aParentFrame);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   
    1:   // Process children
    1:   nsFrameConstructorSaveState absoluteSaveState;
    1:   nsFrameItems                childItems;
    1: 
    1:   if (aStyleDisplay->IsPositioned()) {
    1:     // The area frame becomes a container for child frames that are
    1:     // absolutely positioned
23352:     // XXXbz this is probably wrong, and once arbitrary frames can be absolute
23352:     // containing blocks we should fix this..
23176:     aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
23176:   }
23176: 
23352:   ProcessChildren(aState, aContent, aStyleContext, blockFrame, PR_TRUE,
    1:                   childItems, PR_TRUE);
    1: 
    1:   nsIFrame * child      = childItems.childList;
    1:   nsIFrame * previous   = nsnull;
23554:   nsLegendFrame* legendFrame = nsnull;
    1:   while (nsnull != child) {
23554:     legendFrame = do_QueryFrame(child);
23554:     if (legendFrame) {
    1:       // We want the legend to be the first frame in the fieldset child list.
    1:       // That way the EventStateManager will do the right thing when tabbing
    1:       // from a selection point within the legend (bug 236071), which is
    1:       // used for implementing legend access keys (bug 81481).
    1:       // GetAdjustedParentFrame() below depends on this frame order.
    1:       if (nsnull != previous) {
    1:         previous->SetNextSibling(legendFrame->GetNextSibling());
    1:       } else {
    1:         childItems.childList = legendFrame->GetNextSibling();
    1:       }
23176:       legendFrame->SetNextSibling(blockFrame);
    1:       legendFrame->SetParent(newFrame);
    1:       break;
    1:     }
    1:     previous = child;
    1:     child = child->GetNextSibling();
    1:   }
    1: 
    1:   // Set the scrolled frame's initial child lists
23176:   blockFrame->SetInitialChildList(nsnull, childItems.childList);
    1: 
    1:   // Set the scroll frame's initial child list
23176:   newFrame->SetInitialChildList(nsnull, legendFrame ? legendFrame : blockFrame);
    1: 
    1:   // our new frame returned is the top frame which is the list frame. 
23944:   *aNewFrame = newFrame; 
    1: 
    1:   return NS_OK;
    1: }
    1: 
16976: static nsIFrame*
16976: FindAncestorWithGeneratedContentPseudo(nsIFrame* aFrame)
16976: {
16976:   for (nsIFrame* f = aFrame->GetParent(); f; f = f->GetParent()) {
16976:     NS_ASSERTION(f->IsGeneratedContentFrame(),
16976:                  "should not have exited generated content");
16976:     nsIAtom* pseudo = f->GetStyleContext()->GetPseudoType();
16976:     if (pseudo == nsCSSPseudoElements::before ||
16976:         pseudo == nsCSSPseudoElements::after)
16976:       return f;
16976:   }
16976:   return nsnull;
16976: }
16976: 
23955: #define FCDATA_DECL(_flags, _func) \
23955:   { _flags, { (FrameCreationFunc)_func } }
23955: #define SIMPLE_FCDATA(_func) FCDATA_DECL(0, _func)
23955: 
23955: /* static */
23955: const nsCSSFrameConstructor::FrameConstructionData*
23955: nsCSSFrameConstructor::FindTextData(nsIFrame* aParentFrame)
23955: {
23167: #ifdef MOZ_SVG
23167:   if (aParentFrame->IsFrameOfType(nsIFrame::eSVG)) {
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
23167:     if (ancestorFrame) {
23554:       nsISVGTextContentMetrics* metrics = do_QueryFrame(ancestorFrame);
23955:       if (metrics) {
23955:         static const FrameConstructionData sSVGGlyphData =
23955:           SIMPLE_FCDATA(NS_NewSVGGlyphFrame);
23955:         return &sSVGGlyphData;
23955:       }
23955:     }
23955:     return nsnull;
23955:   }
23955: #endif
23955: 
23955:   static const FrameConstructionData sTextData = SIMPLE_FCDATA(NS_NewTextFrame);
23955:   return &sTextData;
23955: }
23955: 
23955: nsresult
23955: nsCSSFrameConstructor::ConstructTextFrame(const FrameConstructionData* aData,
23955:                                           nsFrameConstructorState& aState,
    1:                                           nsIContent*              aContent,
    1:                                           nsIFrame*                aParentFrame,
    1:                                           nsStyleContext*          aStyleContext,
    1:                                           nsFrameItems&            aFrameItems,
    1:                                           PRBool                   aPseudoParent)
    1: {
23955:   if (!aData) {
23955:     // Nothing to do here: suppressed text inside SVG, say
23955:     return NS_OK;
23955:   }
23955: 
    1:   // process pending pseudo frames. whitespace doesn't have an effect.
    1:   if (!aPseudoParent && !aState.mPseudoFrames.IsEmpty() &&
    1:       !TextIsOnlyWhitespace(aContent))
    1:     ProcessPseudoFrames(aState, aFrameItems);
    1: 
23955:   nsIFrame* newFrame = (*aData->mFunc.mCreationFunc)(mPresShell, aStyleContext);
    1: 
    1:   if (NS_UNLIKELY(!newFrame))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsresult rv = InitAndRestoreFrame(aState, aContent, aParentFrame,
    1:                                     nsnull, newFrame);
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     newFrame->Destroy();
    1:     return rv;
    1:   }
    1: 
    1:   // We never need to create a view for a text frame.
    1: 
16976:   if (newFrame->IsGeneratedContentFrame()) {
16976:     nsAutoPtr<nsGenConInitializer> initializer;
16976:     initializer =
16976:       static_cast<nsGenConInitializer*>(
16976:         aContent->UnsetProperty(nsGkAtoms::genConInitializerProperty));
16976:     if (initializer) {
16976:       if (initializer->mNode->InitTextFrame(initializer->mList,
16976:               FindAncestorWithGeneratedContentPseudo(newFrame), newFrame)) {
16976:         (this->*(initializer->mDirtyAll))();
16976:       }
16976:       initializer->mNode.forget();
16976:     }
16976:   }
    1:   
    1:   // Add the newly constructed frame to the flow
    1:   aFrameItems.AddChild(newFrame);
    1: 
    1:   // Text frames don't go in the content->frame hash table, because
    1:   // they're anonymous. This keeps the hash table smaller
    1: 
    1:   return rv;
    1: }
    1: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindDataByInt(PRInt32 aInt,
23167:                                      nsIContent* aContent,
23944:                                      nsStyleContext* aStyleContext,
23944:                                      const FrameConstructionDataByInt* aDataPtr,
23944:                                      PRUint32 aDataLength)
23944: {
23944:   for (const FrameConstructionDataByInt *curData = aDataPtr,
23944:          *endData = aDataPtr + aDataLength;
23944:        curData != endData;
23944:        ++curData) {
23944:     if (curData->mInt == aInt) {
23944:       const FrameConstructionData* data = &curData->mData;
23944:       if (data->mBits & FCDATA_FUNC_IS_DATA_GETTER) {
23944:         return data->mFunc.mDataGetter(aContent, aStyleContext);
23944:       }
23944: 
23944:       return data;
23944:     }
23944:   }
23944: 
23944:   return nsnull;
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindDataByTag(nsIAtom* aTag,
23944:                                      nsIContent* aContent,
23944:                                      nsStyleContext* aStyleContext,
23944:                                      const FrameConstructionDataByTag* aDataPtr,
23944:                                      PRUint32 aDataLength)
23944: {
23944:   for (const FrameConstructionDataByTag *curData = aDataPtr,
23944:          *endData = aDataPtr + aDataLength;
23944:        curData != endData;
23944:        ++curData) {
23944:     if (*curData->mTag == aTag) {
23944:       const FrameConstructionData* data = &curData->mData;
23944:       if (data->mBits & FCDATA_FUNC_IS_DATA_GETTER) {
23944:         return data->mFunc.mDataGetter(aContent, aStyleContext);
23944:       }
23944: 
23944:       return data;
23944:     }
23944:   }
23944: 
23944:   return nsnull;
23944: }
23944: 
23952: #define SUPPRESS_FCDATA() FCDATA_DECL(FCDATA_SUPPRESS_FRAME, nsnull)
23944: #define SIMPLE_INT_CREATE(_int, _func) { _int, SIMPLE_FCDATA(_func) }
23944: #define SIMPLE_INT_CHAIN(_int, _func)                       \
23944:   { _int, FCDATA_DECL(FCDATA_FUNC_IS_DATA_GETTER, _func) }
23944: #define COMPLEX_INT_CREATE(_int, _func)                     \
23944:   { _int, { FCDATA_FUNC_IS_FULL_CTOR, { nsnull }, _func } }
23944: 
23944: #define SIMPLE_TAG_CREATE(_tag, _func)          \
23944:   { &nsGkAtoms::_tag, SIMPLE_FCDATA(_func) }
23944: #define SIMPLE_TAG_CHAIN(_tag, _func)                                   \
23944:   { &nsGkAtoms::_tag, FCDATA_DECL(FCDATA_FUNC_IS_DATA_GETTER,  _func) }
23944: #define COMPLEX_TAG_CREATE(_tag, _func)                                 \
23944:   { &nsGkAtoms::_tag, { FCDATA_FUNC_IS_FULL_CTOR, { nsnull }, _func } }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindHTMLData(nsIContent* aContent,
23167:                                     nsIAtom* aTag,
23167:                                     PRInt32 aNameSpaceID,
23944:                                     nsStyleContext* aStyleContext)
23167: {
23167:   // Ignore the tag if it's not HTML content and if it doesn't extend (via XBL)
23167:   // a valid HTML namespace.  This check must match the one in
23167:   // ShouldHaveFirstLineStyle.
23167:   if (!aContent->IsNodeOfType(nsINode::eHTML) &&
23167:       aNameSpaceID != kNameSpaceID_XHTML) {
23944:     return nsnull;
23944:   }
23944: 
23944:   static const FrameConstructionDataByTag sHTMLData[] = {
23944:     SIMPLE_TAG_CHAIN(img, nsCSSFrameConstructor::FindImgData),
23944:     SIMPLE_TAG_CHAIN(mozgeneratedcontentimage,
23944:                      nsCSSFrameConstructor::FindImgData),
23944:     { &nsGkAtoms::br, FCDATA_DECL(FCDATA_SKIP_FRAMEMAP, NS_NewBRFrame) },
23977:     SIMPLE_TAG_CREATE(wbr, NS_NewWBRFrame),
23944:     SIMPLE_TAG_CHAIN(input, nsCSSFrameConstructor::FindInputData),
23944:     SIMPLE_TAG_CREATE(textarea, NS_NewTextControlFrame),
23944:     COMPLEX_TAG_CREATE(select, &nsCSSFrameConstructor::ConstructSelectFrame),
23944:     SIMPLE_TAG_CHAIN(object, nsCSSFrameConstructor::FindObjectData),
23944:     SIMPLE_TAG_CHAIN(applet, nsCSSFrameConstructor::FindObjectData),
23944:     SIMPLE_TAG_CHAIN(embed, nsCSSFrameConstructor::FindObjectData),
23944:     COMPLEX_TAG_CREATE(fieldset,
23944:                        &nsCSSFrameConstructor::ConstructFieldSetFrame),
23944:     SIMPLE_TAG_CREATE(legend, NS_NewLegendFrame),
23944:     SIMPLE_TAG_CREATE(frameset, NS_NewHTMLFramesetFrame),
23944:     SIMPLE_TAG_CREATE(iframe, NS_NewSubDocumentFrame),
23944:     SIMPLE_TAG_CREATE(spacer, NS_NewSpacerFrame),
23944:     COMPLEX_TAG_CREATE(button, &nsCSSFrameConstructor::ConstructButtonFrame),
23944:     SIMPLE_TAG_CREATE(canvas, NS_NewHTMLCanvasFrame),
23944: #if defined(MOZ_MEDIA)
23944:     SIMPLE_TAG_CREATE(video, NS_NewHTMLVideoFrame),
23944:     SIMPLE_TAG_CREATE(audio, NS_NewHTMLVideoFrame),
23944: #endif
23944:     SIMPLE_TAG_CREATE(isindex, NS_NewIsIndexFrame)
23944:   };
23944: 
23944:   return FindDataByTag(aTag, aContent, aStyleContext, sHTMLData,
23944:                        NS_ARRAY_LENGTH(sHTMLData));
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindImgData(nsIContent* aContent,
23944:                                    nsStyleContext* aStyleContext)
23944: {
23944:   if (!nsImageFrame::ShouldCreateImageFrameFor(aContent, aStyleContext)) {
23944:     return nsnull;
23944:   }
23944: 
23944:   static const FrameConstructionData sImgData = SIMPLE_FCDATA(NS_NewImageFrame);
23944:   return &sImgData;
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindImgControlData(nsIContent* aContent,
23944:                                           nsStyleContext* aStyleContext)
23944: {
23944:   if (!nsImageFrame::ShouldCreateImageFrameFor(aContent, aStyleContext)) {
23944:     return nsnull;
23944:   }
23944: 
23944:   static const FrameConstructionData sImgControlData =
23944:     SIMPLE_FCDATA(NS_NewImageControlFrame);
23944:   return &sImgControlData;
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindInputData(nsIContent* aContent,
23944:                                      nsStyleContext* aStyleContext)
23944: {
23944:   static const FrameConstructionDataByInt sInputData[] = {
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_CHECKBOX, NS_NewGfxCheckboxControlFrame),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_RADIO, NS_NewGfxRadioControlFrame),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_FILE, NS_NewFileControlFrame),
23944:     SIMPLE_INT_CHAIN(NS_FORM_INPUT_IMAGE,
23944:                      nsCSSFrameConstructor::FindImgControlData),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_TEXT, NS_NewTextControlFrame),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_PASSWORD, NS_NewTextControlFrame),
23944:     COMPLEX_INT_CREATE(NS_FORM_INPUT_SUBMIT,
23944:                        &nsCSSFrameConstructor::ConstructButtonFrame),
23944:     COMPLEX_INT_CREATE(NS_FORM_INPUT_RESET,
23944:                        &nsCSSFrameConstructor::ConstructButtonFrame),
23944:     COMPLEX_INT_CREATE(NS_FORM_INPUT_BUTTON,
23944:                        &nsCSSFrameConstructor::ConstructButtonFrame)
23944:     // Keeping hidden inputs out of here on purpose for so they get frames by
23944:     // display (in practice, none).
23944:   };
23944: 
23944:   nsCOMPtr<nsIFormControl> control = do_QueryInterface(aContent);
23944:   NS_ASSERTION(control, "input doesn't implement nsIFormControl?");
23944: 
23944:   return FindDataByInt(control->GetType(), aContent, aStyleContext,
23944:                        sInputData, NS_ARRAY_LENGTH(sInputData));
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindObjectData(nsIContent* aContent,
23944:                                       nsStyleContext* aStyleContext)
23944: {
23944:   // GetDisplayedType isn't necessarily nsIObjectLoadingContent::TYPE_NULL for
23944:   // cases when the object is broken/suppressed/etc (e.g. a broken image), but
23944:   // we want to treat those cases as TYPE_NULL
23944:   PRUint32 type;
23944:   if (aContent->IntrinsicState() &
23944:       (NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED |
23944:        NS_EVENT_STATE_SUPPRESSED)) {
23944:     type = nsIObjectLoadingContent::TYPE_NULL;
23944:   } else {
23944:     nsCOMPtr<nsIObjectLoadingContent> objContent(do_QueryInterface(aContent));
23944:     NS_ASSERTION(objContent,
23944:                  "applet, embed and object must implement "
23944:                  "nsIObjectLoadingContent!");
23944: 
23944:     objContent->GetDisplayedType(&type);
23944:   }
23944: 
23944:   static const FrameConstructionDataByInt sObjectData[] = {
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_LOADING,
23944:                       NS_NewEmptyFrame),
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_PLUGIN,
23944:                       NS_NewObjectFrame),
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_IMAGE,
23944:                       NS_NewImageFrame),
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_DOCUMENT,
23944:                       NS_NewSubDocumentFrame)
23944:     // Nothing for TYPE_NULL so we'll construct frames by display there
23944:   };
23944: 
23944:   return FindDataByInt((PRInt32)type, aContent, aStyleContext,
23944:                        sObjectData, NS_ARRAY_LENGTH(sObjectData));
23944: }
23944: 
23944: nsresult
23944: nsCSSFrameConstructor::ConstructFrameFromData(const FrameConstructionData* aData,
23944:                                               nsFrameConstructorState& aState,
    1:                                               nsIContent* aContent,
    1:                                               nsIFrame* aParentFrame,
    1:                                               nsIAtom* aTag,
    1:                                               PRInt32 aNameSpaceID,
    1:                                               nsStyleContext* aStyleContext,
    1:                                               nsFrameItems& aFrameItems,
    1:                                               PRBool aHasPseudoParent)
    1: {
23944:   PRUint32 bits = aData->mBits;
23944: 
23944:   NS_ASSERTION(!(bits & FCDATA_FUNC_IS_DATA_GETTER),
23944:                "Should have dealt with this inside the data finder");
23944: 
23952:   // Some sets of bits are not compatible with each other
23952: #define CHECK_ONLY_ONE_BIT(_bit1, _bit2)               \
23952:   NS_ASSERTION(!(bits & _bit1) || !(bits & _bit2),     \
23952:                "Only one of these bits should be set")
23952:   CHECK_ONLY_ONE_BIT(FCDATA_SKIP_FRAMEMAP, FCDATA_MAY_NEED_SCROLLFRAME);
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_DISALLOW_OUT_OF_FLOW);
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_FORCE_NULL_ABSPOS_CONTAINER);
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_WRAP_KIDS_IN_BLOCKS);
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_MAY_NEED_SCROLLFRAME);
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_IS_POPUP);
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_SKIP_ABSPOS_PUSH);
23954:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_FORCE_VIEW);
23954:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR,
23954:                      FCDATA_DISALLOW_GENERATED_CONTENT);
23954:   CHECK_ONLY_ONE_BIT(FCDATA_MAY_NEED_SCROLLFRAME, FCDATA_FORCE_VIEW);
23952: #undef CHECK_ONLY_ONE_BIT
23952: 
23944:   // We found something, so not creating by display type.  Process
23944:   // pseudo-frames now.
    1:   if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:     ProcessPseudoFrames(aState, aFrameItems); 
    1:   }
23944: 
23944:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
23944: 
23944:   nsIFrame* newFrame;
23944:   if (bits & FCDATA_FUNC_IS_FULL_CTOR) {
23944:     nsresult rv =
23944:       (this->*(aData->mFullConstructor))(aState, aContent, aParentFrame,
23944:                                          aTag, aStyleContext, display,
23944:                                          aFrameItems, &newFrame);
23944:     if (NS_FAILED(rv)) {
23944:       return rv;
23944:     }
23944:   } else {
23944:     newFrame =
23944:       (*aData->mFunc.mCreationFunc)(mPresShell, aStyleContext);
23944:     if (!newFrame) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
23944: 
23944:     PRBool allowOutOfFlow = !(bits & FCDATA_DISALLOW_OUT_OF_FLOW);
23952: #ifdef MOZ_XUL
23952:     PRBool isPopup = (bits & FCDATA_IS_POPUP) &&
23952:                      aParentFrame->GetType() != nsGkAtoms::menuFrame;
23952: #else
23952:     PRBool isPopup = PR_FALSE;
23952: #endif
23952:     NS_ASSERTION(!isPopup ||
23952:                  (aState.mPopupItems.containingBlock &&
23952:                   aState.mPopupItems.containingBlock->GetType() ==
23952:                     nsGkAtoms::popupSetFrame),
23952:                  "Should have a containing block here!");
23952: 
23952:     PRBool isXUL = (aNameSpaceID == kNameSpaceID_XUL);
23944: 
23944:     nsIFrame* geometricParent =
23952:       isPopup ? aState.mPopupItems.containingBlock :
23952:       (allowOutOfFlow ? aState.GetGeometricParent(display, aParentFrame)
23952:                       : aParentFrame);
23952: 
23952:     nsresult rv = NS_OK;
23952: 
23952:     // Must init frameToAddToList to null, since it's inout
23952:     nsIFrame* frameToAddToList = nsnull;
23952:     if ((bits & FCDATA_MAY_NEED_SCROLLFRAME) &&
23952:         display->IsScrollableOverflow()) {
23952:       BuildScrollFrame(aState, aContent, aStyleContext, newFrame,
23952:                        geometricParent, frameToAddToList);
23952:       // No need to add to frame map later, since BuildScrollFrame did it
23952:       // already
23952:       bits |= FCDATA_SKIP_FRAMEMAP;
23952:     } else {
23952:       rv = InitAndRestoreFrame(aState, aContent, geometricParent, nsnull,
23944:                                newFrame);
    1:       NS_ASSERTION(NS_SUCCEEDED(rv), "InitAndRestoreFrame failed");
23944:       // See whether we need to create a view
23954:       nsHTMLContainerFrame::CreateViewForFrame(newFrame,
23954:                                                (bits & FCDATA_FORCE_VIEW) != 0);
23952:       frameToAddToList = newFrame;
23952:     }
23952: 
23952:     rv = aState.AddChild(frameToAddToList, aFrameItems, aContent, aStyleContext,
23952:                          aParentFrame, allowOutOfFlow, allowOutOfFlow, isPopup);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
23167: 
23952: #ifdef MOZ_XUL
23952:     // Icky XUL stuff, sadly
23952:     if (isXUL && aTag == nsGkAtoms::popupgroup &&
23952:         aContent->IsRootOfNativeAnonymousSubtree()) {
23952:       nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
23952:       if (rootBox) {
23952:         NS_ASSERTION(rootBox->GetPopupSetFrame() == newFrame,
23952:                      "Unexpected PopupSetFrame");
23952:         aState.mPopupItems.containingBlock = rootBox->GetPopupSetFrame();
23952:       }
23952:     }
23952: #endif /* MOZ_XUL */
    1: 
    1:     // Process the child content if requested
    1:     nsFrameItems childItems;
    1:     nsFrameConstructorSaveState absoluteSaveState;
23343: 
23944:     if (bits & FCDATA_FORCE_NULL_ABSPOS_CONTAINER) {
23944:       aState.PushAbsoluteContainingBlock(nsnull, absoluteSaveState);
23952:     } else if (!(bits & FCDATA_SKIP_ABSPOS_PUSH) && display->IsPositioned()) {
    1:       aState.PushAbsoluteContainingBlock(newFrame, absoluteSaveState);
    1:     }
23352: 
23352:     // Process the child frames.  Don't allow block styles; anything that's a
23952:     // special HTML or MathML or XUL frame but wants those should do its own
23946:     // ProcessChildren.
23954:     rv = ProcessChildren(aState, aContent, aStyleContext, newFrame,
23954:                          !(bits & FCDATA_DISALLOW_GENERATED_CONTENT),
23352:                          childItems, PR_FALSE);
23167: 
23952: #ifdef MOZ_XUL
23952:     // More icky XUL stuff
23952:     if (isXUL &&
23952:         (aTag == nsGkAtoms::treechildren || // trees always need titletips
23952:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltiptext) ||
23952:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltip))) {
23952:       nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
23952:       if (rootBox) {
23952:         rootBox->AddTooltipSupport(aContent);
23952:       }
23952:     }
23952: #endif
23952: 
23946: #ifdef MOZ_MATHML
23946:     if (NS_SUCCEEDED(rv) && (bits & FCDATA_WRAP_KIDS_IN_BLOCKS)) {
23946:       nsFrameItems newItems;
23946:       nsFrameItems currentBlock;
23946:       nsIFrame* f;
23946:       while ((f = childItems.childList) != nsnull) {
23946:         PRBool wrapFrame = IsInlineFrame(f) || IsFrameSpecial(f);
23946:         if (!wrapFrame) {
23946:           rv = FlushAccumulatedBlock(aState, aContent, newFrame, &currentBlock, &newItems);
23946:           if (NS_FAILED(rv))
23946:             break;
23946:         }
23946: 
23946:         childItems.RemoveChild(f, nsnull);
23946:         if (wrapFrame) {
23946:           currentBlock.AddChild(f);
23946:         } else {
23946:           newItems.AddChild(f);
23946:         }
23946:       }
23946:       rv = FlushAccumulatedBlock(aState, aContent, newFrame, &currentBlock, &newItems);
23946: 
23946:       if (childItems.childList) {
23946:         // an error must have occurred, delete unprocessed frames
23946:         CleanupFrameReferences(aState.mFrameManager, childItems.childList);
23946:         nsFrameList(childItems.childList).DestroyFrames();
23946:       }
23946: 
23946:       childItems = newItems;
23946:     }
23946: #endif
    1: 
    1:     // Set the frame's initial child list
23946:     // Note that MathML depends on this being called even if
23946:     // childItems.childList is null!
    1:     newFrame->SetInitialChildList(nsnull, childItems.childList);
    1:   }
23167: 
23944:   if (!(bits & FCDATA_SKIP_FRAMEMAP)) {
    1:     aState.mFrameManager->SetPrimaryFrameFor(aContent, newFrame);
    1:   }
    1: 
23944:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateAnonymousFrames(nsIAtom*                 aTag,
    1:                                              nsFrameConstructorState& aState,
    1:                                              nsIContent*              aParent,
    1:                                              nsIFrame*                aNewFrame,
    1:                                              nsFrameItems&            aChildItems,
    1:                                              PRBool                   aIsRoot)
    1: {
    1:   // See if we might have anonymous content
    1:   // by looking at the tag rather than doing a QueryInterface on
    1:   // the frame.  Only these tags' frames can have anonymous content
    1:   // through nsIAnonymousContentCreator.  We do this check for
    1:   // performance reasons. If we did a QueryInterface on every tag it
    1:   // would be inefficient.
23342:   // XXXbz what about just having a virtual method to check this instead?
    1:   if (!aIsRoot &&
    1:       aTag != nsGkAtoms::input &&
    1:       aTag != nsGkAtoms::textarea &&
    1:       aTag != nsGkAtoms::combobox &&
    1:       aTag != nsGkAtoms::isindex &&
    1:       aTag != nsGkAtoms::scrollbar
    1: #ifdef MOZ_SVG
    1:       && aTag != nsGkAtoms::use
    1: #endif
15751: #ifdef MOZ_MEDIA
15751:       && aTag != nsGkAtoms::video
22873:       && aTag != nsGkAtoms::audio
15751: #endif
    1:       )
    1:     return NS_OK;
    1: 
23342:   return CreateAnonymousFrames(aState, aParent, aNewFrame, aChildItems);
    1: }
    1: 
    1: // after the node has been constructed and initialized create any
    1: // anonymous content a node needs.
    1: nsresult
    1: nsCSSFrameConstructor::CreateAnonymousFrames(nsFrameConstructorState& aState,
    1:                                              nsIContent*              aParent,
    1:                                              nsIFrame*                aParentFrame,
    1:                                              nsFrameItems&            aChildItems)
    1: {
23554:   nsIAnonymousContentCreator* creator = do_QueryFrame(aParentFrame);
    1:   if (!creator)
    1:     return NS_OK;
    1: 
    1:   nsresult rv;
    1: 
    1:   nsAutoTArray<nsIContent*, 4> newAnonymousItems;
    1:   rv = creator->CreateAnonymousContent(newAnonymousItems);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint32 count = newAnonymousItems.Length();
    1:   if (count == 0) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // save the incoming pseudo frame state, so that we don't end up
    1:   // with those pseudoframes in aChildItems
    1:   nsPseudoFrames priorPseudoFrames; 
    1:   aState.mPseudoFrames.Reset(&priorPseudoFrames);
    1: 
    1:   for (PRUint32 i=0; i < count; i++) {
    1:     // get our child's content and set its parent to our content
    1:     nsIContent* content = newAnonymousItems[i];
    1:     NS_ASSERTION(content, "null anonymous content?");
    1: 
    1: #ifdef MOZ_SVG
    1:     // least-surprise CSS binding until we do the SVG specified
    1:     // cascading rules for <svg:use> - bug 265894
16126:     if (!aParent ||
16126:         !aParent->NodeInfo()->Equals(nsGkAtoms::use, kNameSpaceID_SVG))
12250: #endif
12250:     {
12250:       content->SetNativeAnonymous();
12250:     }
    1: 
23342:     rv = content->BindToTree(mDocument, aParent, aParent, PR_TRUE);
    1:     if (NS_FAILED(rv)) {
    1:       content->UnbindFromTree();
    1:       return rv;
    1:     }
    1: 
    1:     nsIFrame* newFrame = creator->CreateFrameFor(content);
    1:     if (newFrame) {
    1:       aChildItems.AddChild(newFrame);
    1:     }
    1:     else {
    1:       // create the frame and attach it to our frame
    1:       ConstructFrame(aState, content, aParentFrame, aChildItems);
    1:     }
 1346:   }
    1: 
    1:   creator->PostCreateFrames();
    1: 
    1:   // process the current pseudo frame state
    1:   if (!aState.mPseudoFrames.IsEmpty()) {
    1:     ProcessPseudoFrames(aState, aChildItems);
    1:   }
    1: 
    1:   // restore the incoming pseudo frame state 
    1:   aState.mPseudoFrames = priorPseudoFrames;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static
    1: PRBool IsXULDisplayType(const nsStyleDisplay* aDisplay)
    1: {
    1:   return (aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX || 
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_GRID || 
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_STACK ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_BOX ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_STACK ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID_GROUP ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID_LINE ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_DECK ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_POPUP ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GROUPBOX
    1:           );
    1: }
    1: 
23952: 
23952: // XUL frames are not allowed to be out of flow.
23952: #define SIMPLE_XUL_FCDATA(_func)                                        \
23952:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_SKIP_ABSPOS_PUSH,    \
23952:               _func)
23952: #define SCROLLABLE_XUL_FCDATA(_func)                                    \
23952:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_SKIP_ABSPOS_PUSH |   \
23952:               FCDATA_MAY_NEED_SCROLLFRAME, _func)
23952: #define SIMPLE_XUL_CREATE(_tag, _func)            \
23952:   { &nsGkAtoms::_tag, SIMPLE_XUL_FCDATA(_func) }
23952: #define SCROLLABLE_XUL_CREATE(_tag, _func)            \
23952:   { &nsGkAtoms::_tag, SCROLLABLE_XUL_FCDATA(_func) }
23952: #define SIMPLE_XUL_INT_CREATE(_int, _func)      \
23952:   { _int, SIMPLE_XUL_FCDATA(_func) }
23952: #define SCROLLABLE_XUL_INT_CREATE(_int, _func)                          \
23952:   { _int, SCROLLABLE_XUL_FCDATA(_func) }
23952: 
23952: static
23952: nsIFrame* NS_NewGridBoxFrame(nsIPresShell* aPresShell,
23952:                              nsStyleContext* aStyleContext)
23952: {
23952:   nsCOMPtr<nsIBoxLayout> layout;
23952:   NS_NewGridLayout2(aPresShell, getter_AddRefs(layout));
23952:   if (!layout) {
23952:     return nsnull;
23952:   }
23952: 
23952:   return NS_NewBoxFrame(aPresShell, aStyleContext, PR_FALSE, layout);
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULTagData(nsIContent* aContent,
    1:                                       nsIAtom* aTag,
    1:                                       PRInt32 aNameSpaceID,
23952:                                       nsStyleContext* aStyleContext)
23952: {
23952:   if (aNameSpaceID != kNameSpaceID_XUL) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionDataByTag sXULTagData[] = {
    1: #ifdef MOZ_XUL
23952:     SCROLLABLE_XUL_CREATE(button, NS_NewButtonBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(checkbox, NS_NewButtonBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(radio, NS_NewButtonBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(autorepeatbutton, NS_NewAutoRepeatBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(titlebar, NS_NewTitleBarFrame),
23952:     SCROLLABLE_XUL_CREATE(resizer, NS_NewResizerFrame),
23952:     SIMPLE_XUL_CREATE(image, NS_NewImageBoxFrame),
23952:     SIMPLE_XUL_CREATE(spring, NS_NewLeafBoxFrame),
23952:     SIMPLE_XUL_CREATE(spacer, NS_NewLeafBoxFrame),
23952:     SIMPLE_XUL_CREATE(treechildren, NS_NewTreeBodyFrame),
23952:     SIMPLE_XUL_CREATE(treecol, NS_NewTreeColFrame),
23952:     SIMPLE_XUL_CREATE(text, NS_NewTextBoxFrame),
23952:     SIMPLE_TAG_CHAIN(label, nsCSSFrameConstructor::FindXULLabelData),
23952:     SIMPLE_TAG_CHAIN(description, nsCSSFrameConstructor::FindXULDescriptionData),
23952:     SIMPLE_XUL_CREATE(menu, NS_NewMenuFrame),
23952:     SIMPLE_XUL_CREATE(menubutton, NS_NewMenuFrame),
23952:     SIMPLE_XUL_CREATE(menuitem, NS_NewMenuItemFrame),
    1: #ifdef XP_MACOSX
23952:     SIMPLE_TAG_CHAIN(menubar, nsCSSFrameConstructor::FindXULMenubarData),
23952: #else
23952:     SIMPLE_XUL_CREATE(menubar, NS_NewMenuBarFrame),
23952: #endif /* XP_MACOSX */
23952:     SIMPLE_TAG_CHAIN(popupgroup, nsCSSFrameConstructor::FindPopupGroupData),
23952:     SIMPLE_XUL_CREATE(iframe, NS_NewSubDocumentFrame),
23952:     SIMPLE_XUL_CREATE(editor, NS_NewSubDocumentFrame),
23952:     SIMPLE_XUL_CREATE(browser, NS_NewSubDocumentFrame),
23952:     SIMPLE_XUL_CREATE(progressmeter, NS_NewProgressMeterFrame),
23952:     SIMPLE_XUL_CREATE(splitter, NS_NewSplitterFrame),
23952:     SIMPLE_TAG_CHAIN(listboxbody,
23952:                      nsCSSFrameConstructor::FindXULListBoxBodyData),
23952:     SIMPLE_TAG_CHAIN(listitem, nsCSSFrameConstructor::FindXULListItemData),
23952: #endif /* MOZ_XUL */
23952:     SIMPLE_XUL_CREATE(slider, NS_NewSliderFrame),
23952:     SIMPLE_XUL_CREATE(scrollbar, NS_NewScrollbarFrame),
23952:     SIMPLE_XUL_CREATE(scrollbarbutton, NS_NewScrollbarButtonFrame)
23952: };
23952: 
23952:   return FindDataByTag(aTag, aContent, aStyleContext, sXULTagData,
23952:                        NS_ARRAY_LENGTH(sXULTagData));
23952: }
23952: 
23952: #ifdef MOZ_XUL
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindPopupGroupData(nsIContent* aContent,
23952:                                           nsStyleContext* /* unused */)
23952: {
23952:   if (!aContent->IsRootOfNativeAnonymousSubtree()) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionData sPopupSetData =
23952:     SIMPLE_XUL_FCDATA(NS_NewPopupSetFrame);
23952:   return &sPopupSetData;
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData
23952: nsCSSFrameConstructor::sXULTextBoxData = SIMPLE_XUL_FCDATA(NS_NewTextBoxFrame);
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULLabelData(nsIContent* aContent,
23952:                                         nsStyleContext* /* unused */)
23952: {
23952:   if (aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
23952:     return &sXULTextBoxData;
23952:   }
23952: 
23952:   static const FrameConstructionData sLabelData =
23952:     SIMPLE_XUL_FCDATA(NS_NewXULLabelFrame);
23952:   return &sLabelData;
23952: }
23952: 
23952: static nsIFrame*
23952: NS_NewXULDescriptionFrame(nsIPresShell* aPresShell, nsStyleContext *aContext)
23952: {
23952:   // XXXbz do we really need to set those flags?  If the parent is not
23952:   // a block we'll get them anyway, and if it is, do we want them?
23952:   return NS_NewBlockFrame(aPresShell, aContext,
23952:                           NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULDescriptionData(nsIContent* aContent,
23952:                                               nsStyleContext* /* unused */)
23952: {
23952:   if (aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
23952:     return &sXULTextBoxData;
23952:   }
23952: 
23952:   static const FrameConstructionData sDescriptionData =
23952:     SIMPLE_XUL_FCDATA(NS_NewXULDescriptionFrame);
23952:   return &sDescriptionData;
23952: }
23952: 
23952: #ifdef XP_MACOSX
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULMenubarData(nsIContent* aContent,
23952:                                           nsStyleContext* aStyleContext)
23952: {
23952:   nsCOMPtr<nsISupports> container =
23952:     aStyleContext->PresContext()->GetContainer();
    1:   if (container) {
    1:     nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
    1:     if (treeItem) {
    1:       PRInt32 type;
    1:       treeItem->GetItemType(&type);
    1:       if (nsIDocShellTreeItem::typeChrome == type) {
    1:         nsCOMPtr<nsIDocShellTreeItem> parent;
    1:         treeItem->GetParent(getter_AddRefs(parent));
23952:         if (!parent) {
23952:           // This is the root.  Suppress the menubar, since on Mac
23952:           // window menus are not attached to the window.
23952:           static const FrameConstructionData sSuppressData = SUPPRESS_FCDATA();
23952:           return &sSuppressData;
23952:         }
23952:       }
23952:     }
23952:   }
23952: 
23952:   static const FrameConstructionData sMenubarData =
23952:     SIMPLE_XUL_FCDATA(NS_NewMenuBarFrame);
23952:   return &sMenubarData;
23952: }
23952: #endif /* XP_MACOSX */
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULListBoxBodyData(nsIContent* aContent,
23952:                                               nsStyleContext* aStyleContext)
23952: {
23952:   if (aStyleContext->GetStyleDisplay()->mDisplay !=
23952:         NS_STYLE_DISPLAY_GRID_GROUP) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionData sListBoxBodyData =
23952:     SCROLLABLE_XUL_FCDATA(NS_NewListBoxBodyFrame);
23952:   return &sListBoxBodyData;
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULListItemData(nsIContent* aContent,
23952:                                            nsStyleContext* aStyleContext)
23952: {
23952:   if (aStyleContext->GetStyleDisplay()->mDisplay !=
23952:         NS_STYLE_DISPLAY_GRID_LINE) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionData sListItemData =
23952:     SCROLLABLE_XUL_FCDATA(NS_NewListItemFrame);
23952:   return &sListItemData;
23952: }
23952: 
23952: #endif /* MOZ_XUL */
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23955: nsCSSFrameConstructor::FindXULDisplayData(const nsStyleDisplay* aDisplay,
23955:                                           nsIContent* aContent,
23952:                                           nsStyleContext* aStyleContext)
23952: {
23955:   if (!IsXULDisplayType(aDisplay)) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionDataByInt sXULDisplayData[] = {
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_BOX, NS_NewBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_BOX, NS_NewBoxFrame),
    1: #ifdef MOZ_XUL
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_GRID, NS_NewGridBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID, NS_NewGridBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID_GROUP,
23952:                               NS_NewGridRowGroupFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID_LINE,
23952:                               NS_NewGridRowLeafFrame),
23952:     SIMPLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_DECK, NS_NewDeckFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GROUPBOX, NS_NewGroupBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_STACK, NS_NewStackFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_STACK, NS_NewStackFrame),
23952:     { NS_STYLE_DISPLAY_POPUP,
23952:       FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_IS_POPUP |
23952:                   FCDATA_SKIP_ABSPOS_PUSH, NS_NewMenuPopupFrame) }
23952: #endif /* MOZ_XUL */
23952:   };
23952: 
23952:   // Processing by display here:
23955:   return FindDataByInt(aDisplay->mDisplay, aContent, aStyleContext,
23952:                        sXULDisplayData, NS_ARRAY_LENGTH(sXULDisplayData));
    1: }
    1: 
 3129: nsresult
 3129: nsCSSFrameConstructor::AddLazyChildren(nsIContent* aContent,
 3129:                                        nsLazyFrameConstructionCallback* aCallback,
 8282:                                        void* aArg, PRBool aIsSynch)
 3129: {
 3129:   nsCOMPtr<nsIRunnable> event =
 3129:     new LazyGenerateChildrenEvent(aContent, mPresShell, aCallback, aArg);
 8282:   return aIsSynch ? event->Run() :
 8282:                     NS_DispatchToCurrentThread(event);
 3129: }
 3129: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::BeginBuildingScrollFrame(nsFrameConstructorState& aState,
    1:                                                 nsIContent*              aContent,
    1:                                                 nsStyleContext*          aContentStyle,
    1:                                                 nsIFrame*                aParentFrame,
    1:                                                 nsIAtom*                 aScrolledPseudo,
    1:                                                 PRBool                   aIsRoot,
    1:                                                 nsIFrame*&               aNewFrame)
    1: {
    1:   nsIFrame* parentFrame = nsnull;
    1:   nsIFrame* gfxScrollFrame = aNewFrame;
    1: 
    1:   nsFrameItems anonymousItems;
    1: 
    1:   nsRefPtr<nsStyleContext> contentStyle = aContentStyle;
    1: 
    1:   if (!gfxScrollFrame) {
    1:     // Build a XULScrollFrame when the child is a box, otherwise an
    1:     // HTMLScrollFrame
    1:     if (IsXULDisplayType(aContentStyle->GetStyleDisplay())) {
    1:       gfxScrollFrame = NS_NewXULScrollFrame(mPresShell, contentStyle, aIsRoot);
    1:     } else {
    1:       gfxScrollFrame = NS_NewHTMLScrollFrame(mPresShell, contentStyle, aIsRoot);
    1:     }
    1: 
    1:     InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, gfxScrollFrame);
    1: 
    1:     // Create a view
23395:     nsHTMLContainerFrame::CreateViewForFrame(gfxScrollFrame, PR_FALSE);
    1:   }
    1: 
    1:   // if there are any anonymous children for the scroll frame, create
    1:   // frames for them.
23342:   CreateAnonymousFrames(aState, aContent, gfxScrollFrame, anonymousItems);
    1: 
    1:   parentFrame = gfxScrollFrame;
    1:   aNewFrame = gfxScrollFrame;
    1: 
    1:   // we used the style that was passed in. So resolve another one.
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1:   nsStyleContext* aScrolledChildStyle = styleSet->ResolvePseudoStyleFor(aContent,
    1:                                                                         aScrolledPseudo,
    1:                                                                         contentStyle).get();
    1: 
    1:   if (gfxScrollFrame) {
    1:      gfxScrollFrame->SetInitialChildList(nsnull, anonymousItems.childList);
    1:   }
    1: 
    1:   return aScrolledChildStyle;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::FinishBuildingScrollFrame(nsIFrame* aScrollFrame,
    1:                                                  nsIFrame* aScrolledFrame)
    1: {
    1:   aScrollFrame->AppendFrames(nsnull, aScrolledFrame);
    1: 
    1:   // force the scrolled frame to have a view. The view will be parented to
    1:   // the correct anonymous inner view because the scrollframes override
    1:   // nsIFrame::GetParentViewForChildFrame.
23395:   nsHTMLContainerFrame::CreateViewForFrame(aScrolledFrame, PR_TRUE);
23395: 
23395:   // XXXbz what's the point of the code after this in this method?
    1:   nsIView* view = aScrolledFrame->GetView();
    1:   if (!view)
    1:     return;
    1: }
    1: 
    1: 
    1: /**
    1:  * Called to wrap a gfx scrollframe around a frame. The hierarchy will look like this
    1:  *
    1:  * ------- for gfx scrollbars ------
    1:  *
    1:  *
    1:  *            ScrollFrame
    1:  *                 ^
    1:  *                 |
    1:  *               Frame (scrolled frame you passed in)
    1:  *
    1:  *
    1:  *-----------------------------------
    1:  * LEGEND:
    1:  * 
    1:  * ScrollFrame: This is a frame that manages gfx cross platform frame based scrollbars.
    1:  *
    1:  * @param aContent the content node of the child to wrap.
    1:  * @param aScrolledFrame The frame of the content to wrap. This should not be
    1:  *                    Initialized. This method will initialize it with a scrolled pseudo
    1:  *                    and no nsIContent. The content will be attached to the scrollframe 
    1:  *                    returned.
    1:  * @param aContentStyle the style context that has already been resolved for the content being passed in.
    1:  *
    1:  * @param aParentFrame The parent to attach the scroll frame to
    1:  *
    1:  * @param aNewFrame The new scrollframe or gfx scrollframe that we create. It will contain the
    1:  *                  scrolled frame you passed in. (returned)
    1:  *                  If this is not null, we'll just use it
    1:  * @param aScrolledContentStyle the style that was resolved for the scrolled frame. (returned)
    1:  */
    1: nsresult
    1: nsCSSFrameConstructor::BuildScrollFrame(nsFrameConstructorState& aState,
    1:                                         nsIContent*              aContent,
    1:                                         nsStyleContext*          aContentStyle,
    1:                                         nsIFrame*                aScrolledFrame,
    1:                                         nsIFrame*                aParentFrame,
23950:                                         nsIFrame*&               aNewFrame)
    1: {
    1:     nsRefPtr<nsStyleContext> scrolledContentStyle =
    1:       BeginBuildingScrollFrame(aState, aContent, aContentStyle, aParentFrame,
23395:                                nsCSSAnonBoxes::scrolledContent,
    1:                                PR_FALSE, aNewFrame);
    1:     
    1:     aScrolledFrame->SetStyleContextWithoutNotification(scrolledContentStyle);
    1:     InitAndRestoreFrame(aState, aContent, aNewFrame, nsnull, aScrolledFrame);
    1: 
    1:     FinishBuildingScrollFrame(aNewFrame, aScrolledFrame);
    1: 
    1:     // now set the primary frame to the ScrollFrame
    1:     aState.mFrameManager->SetPrimaryFrameFor( aContent, aNewFrame );
    1:     return NS_OK;
    1: 
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructFrameByDisplayType(nsFrameConstructorState& aState,
    1:                                                    const nsStyleDisplay*    aDisplay,
    1:                                                    nsIContent*              aContent,
    1:                                                    PRInt32                  aNameSpaceID,
    1:                                                    nsIAtom*                 aTag,
    1:                                                    nsIFrame*                aParentFrame,
    1:                                                    nsStyleContext*          aStyleContext,
    1:                                                    nsFrameItems&            aFrameItems,
    1:                                                    PRBool                   aHasPseudoParent)
    1: {
    1:   PRBool    primaryFrameSet = PR_FALSE;
    1:   nsIFrame* newFrame = nsnull;  // the frame we construct
    1:   PRBool    addToHashTable = PR_TRUE;
    1:   PRBool    addedToFrameList = PR_FALSE;
    1:   nsresult  rv = NS_OK;
    1: 
    1:   // The style system ensures that floated and positioned frames are
    1:   // block-level.
    1:   NS_ASSERTION(!(aDisplay->IsFloating() ||
    1:                  aDisplay->IsAbsolutelyPositioned()) ||
 2829:                aDisplay->IsBlockOutside(),
    1:                "Style system did not apply CSS2.1 section 9.7 fixups");
    1: 
    1:   // If this is "body", try propagating its scroll style to the viewport
    1:   // Note that we need to do this even if the body is NOT scrollable;
    1:   // it might have dynamically changed from scrollable to not scrollable,
    1:   // and that might need to be propagated.
    1:   PRBool propagatedScrollToViewport = PR_FALSE;
    1:   if (aContent->NodeInfo()->Equals(nsGkAtoms::body) &&
    1:       aContent->IsNodeOfType(nsINode::eHTML)) {
    1:     propagatedScrollToViewport =
    1:       PropagateScrollToViewport() == aContent;
    1:   }
    1: 
    1:   // If the frame is a block-level frame and is scrollable, then wrap it
    1:   // in a scroll frame.
    1:   // XXX Ignore tables for the time being
    1:   if (aDisplay->IsBlockInside() &&
    1:       aDisplay->IsScrollableOverflow() &&
    1:       !propagatedScrollToViewport) {
    1: 
    1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aFrameItems); 
    1:     }
    1: 
    1:     nsRefPtr<nsStyleContext> scrolledContentStyle
    1:       = BeginBuildingScrollFrame(aState, aContent, aStyleContext,
    1:                                  aState.GetGeometricParent(aDisplay, aParentFrame),
    1:                                  nsCSSAnonBoxes::scrolledContent,
    1:                                  PR_FALSE, newFrame);
    1:     
    1:     // Initialize it
    1:     // pass a temporary stylecontext, the correct one will be set later
    1:     nsIFrame* scrolledFrame =
23176:         NS_NewBlockFrame(mPresShell, aStyleContext,
23305:                          NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
    1: 
    1:     nsFrameItems blockItem;
    1:     rv = ConstructBlock(aState,
    1:                         scrolledContentStyle->GetStyleDisplay(), aContent,
    1:                         newFrame, newFrame, scrolledContentStyle,
    1:                         &scrolledFrame, blockItem, aDisplay->IsPositioned());
    1:     NS_ASSERTION(blockItem.childList == scrolledFrame,
    1:                  "Scrollframe's frameItems should be exactly the scrolled frame");
    1:     FinishBuildingScrollFrame(newFrame, scrolledFrame);
    1: 
 8199:     rv = aState.AddChild(newFrame, aFrameItems, aContent, aStyleContext,
 8199:                          aParentFrame);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
    1:     addedToFrameList = PR_TRUE;
    1:   }
    1:   // See if the frame is absolute or fixed positioned
    1:   else if (aDisplay->IsAbsolutelyPositioned() &&
    1:            (NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay ||
    1:             NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay)) {
    1: 
    1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aFrameItems); 
    1:     }
    1: 
    1:     // Create a frame to wrap up the absolute positioned item
    1:     // pass a temporary stylecontext, the correct one will be set later
    1:     newFrame = NS_NewAbsoluteItemWrapperFrame(mPresShell, aStyleContext);
    1: 
    1:     rv = ConstructBlock(aState, aDisplay, aContent,
    1:                         aState.GetGeometricParent(aDisplay, aParentFrame), aParentFrame,
    1:                         aStyleContext, &newFrame, aFrameItems, PR_TRUE);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
    1:     addedToFrameList = PR_TRUE;
    1:   }
    1:   // See if the frame is floated and it's a block frame
    1:   else if (aDisplay->IsFloating() &&
    1:            (NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay ||
    1:             NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay)) {
    1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aFrameItems); 
    1:     }
    1:     // Create an area frame
    1:     // pass a temporary stylecontext, the correct one will be set later
    1:     newFrame = NS_NewFloatingItemWrapperFrame(mPresShell, aStyleContext);
    1: 
    1:     rv = ConstructBlock(aState, aDisplay, aContent, 
    1:                         aState.GetGeometricParent(aDisplay, aParentFrame),
    1:                         aParentFrame, aStyleContext, &newFrame, aFrameItems,
19214:                         aDisplay->mPosition == NS_STYLE_POSITION_RELATIVE ||
19214:                         aDisplay->HasTransform());
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
    1:     addedToFrameList = PR_TRUE;
    1:   }
19214:   // See if it's relatively positioned or transformed
19214:   else if ((NS_STYLE_POSITION_RELATIVE == aDisplay->mPosition ||
19214:             aDisplay->HasTransform()) &&
 7667:            (aDisplay->IsBlockInside() ||
 7667:             (NS_STYLE_DISPLAY_INLINE == aDisplay->mDisplay))) {
    1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aFrameItems); 
    1:     }
    1:     // Is it block-level or inline-level?
 7667:     if (aDisplay->IsBlockInside()) {
23305:       // Create a wrapper frame. Only need float manager if it's inline-block
 7667:       PRUint32 flags = (aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_BLOCK ?
23305:                         NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT : 0);
 7667:       newFrame = NS_NewRelativeItemWrapperFrame(mPresShell, aStyleContext, 
 7667:                                                 flags);
    1:       // XXXbz should we be passing in a non-null aContentParentFrame?
    1:       ConstructBlock(aState, aDisplay, aContent,
    1:                      aParentFrame, nsnull, aStyleContext, &newFrame,
    1:                      aFrameItems, PR_TRUE);
    1:       addedToFrameList = PR_TRUE;
    1:     } else {
    1:       // Create a positioned inline frame
    1:       newFrame = NS_NewPositionedInlineFrame(mPresShell, aStyleContext);
    1:       // Note that we want to insert the inline after processing kids, since
    1:       // processing of kids may split the inline.
    1:       ConstructInline(aState, aDisplay, aContent,
    1:                       aParentFrame, aStyleContext, PR_TRUE, newFrame);
    1:     }
    1:   }
    1:   // See if it's a block frame of some sort
    1:   else if ((NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay) ||
    1:            (NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay) ||
    1:            (NS_STYLE_DISPLAY_RUN_IN == aDisplay->mDisplay) ||
    1:            (NS_STYLE_DISPLAY_COMPACT == aDisplay->mDisplay) ||
    1:            (NS_STYLE_DISPLAY_INLINE_BLOCK == aDisplay->mDisplay)) {
    1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aFrameItems); 
    1:     }
    1:     PRUint32 flags = 0;
    1:     if (NS_STYLE_DISPLAY_INLINE_BLOCK == aDisplay->mDisplay) {
23305:       flags = NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT;
    1:     }
    1:     // Create the block frame
    1:     newFrame = NS_NewBlockFrame(mPresShell, aStyleContext, flags);
    1:     if (newFrame) { // That worked so construct the block and its children
    1:       // XXXbz should we be passing in a non-null aContentParentFrame?
    1:       rv = ConstructBlock(aState, aDisplay, aContent,
    1:                           aParentFrame, nsnull, aStyleContext, &newFrame,
    1:                           aFrameItems, PR_FALSE);
    1:       addedToFrameList = PR_TRUE;
    1:     }
    1:     else {
    1:       rv = NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1:   // See if it's an inline frame of some sort
    1:   else if ((NS_STYLE_DISPLAY_INLINE == aDisplay->mDisplay) ||
    1:            (NS_STYLE_DISPLAY_MARKER == aDisplay->mDisplay)) {
    1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
    1:       ProcessPseudoFrames(aState, aFrameItems); 
    1:     }
    1:     // Create the inline frame
    1:     newFrame = NS_NewInlineFrame(mPresShell, aStyleContext);
    1:     if (newFrame) { // That worked so construct the inline and its children
    1:       // Note that we want to insert the inline after processing kids, since
    1:       // processing of kids may split the inline.
    1:       rv = ConstructInline(aState, aDisplay, aContent,
    1:                            aParentFrame, aStyleContext, PR_FALSE, newFrame);
    1:     }
    1:     else {
    1:       rv = NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     // To keep the hash table small don't add inline frames (they're
    1:     // typically things like FONT and B), because we can quickly
    1:     // find them if we need to
    1:     addToHashTable = PR_FALSE;
    1:   }
    1:   // otherwise let the display property influence the frame type to create
    1:   else {
    1:     // XXX This section now only handles table frames; should be
    1:     // factored out probably
    1: 
    1:     // Use the 'display' property to choose a frame type
    1:     switch (aDisplay->mDisplay) {
    1:     case NS_STYLE_DISPLAY_TABLE:
    1:     case NS_STYLE_DISPLAY_INLINE_TABLE:
    1:     {
    1:       nsIFrame* innerTable;
    1:       rv = ConstructTableFrame(aState, aContent, 
    1:                                aParentFrame, aStyleContext,
10035:                                aNameSpaceID, PR_FALSE, aFrameItems, newFrame,
10035:                                innerTable);
    1:       addedToFrameList = PR_TRUE;
    1:       // Note: table construction function takes care of initializing
    1:       // the frame, processing children, and setting the initial child
    1:       // list
    1:       break;
    1:     }
    1:   
    1:     // the next 5 cases are only relevant if the parent is not a table, ConstructTableFrame handles children
    1:     case NS_STYLE_DISPLAY_TABLE_CAPTION:
    1:     {
    1:       // aParentFrame may be an inner table frame rather than an outer frame 
    1:       // In this case we need to get the outer frame.
 4194:       nsIFrame* parentFrame = AdjustCaptionParentFrame(aParentFrame);
    1:       rv = ConstructTableCaptionFrame(aState, aContent, parentFrame,
    1:                                       aStyleContext, aNameSpaceID, aFrameItems,
    1:                                       newFrame, aHasPseudoParent);
    1:       if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
    1:         aFrameItems.AddChild(newFrame);
    1:       }
    1:       return rv;
    1:     }
    1: 
    1:     case NS_STYLE_DISPLAY_TABLE_ROW_GROUP:
    1:     case NS_STYLE_DISPLAY_TABLE_HEADER_GROUP:
    1:     case NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP:
    1:       rv = ConstructTableRowGroupFrame(aState, aContent, aParentFrame,
    1:                                        aStyleContext, aNameSpaceID, PR_FALSE,
    1:                                        aFrameItems, newFrame,
    1:                                        aHasPseudoParent);
    1:       if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
    1:         aFrameItems.AddChild(newFrame);
    1:       }
    1:       return rv;
    1: 
    1:     case NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP:
    1:       rv = ConstructTableColGroupFrame(aState, aContent, aParentFrame,
    1:                                        aStyleContext, aNameSpaceID,
    1:                                        PR_FALSE, aFrameItems, newFrame,
    1:                                        aHasPseudoParent);
    1:       if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
    1:         aFrameItems.AddChild(newFrame);
    1:       }
    1:       return rv;
    1:    
    1:     case NS_STYLE_DISPLAY_TABLE_COLUMN:
    1:       rv = ConstructTableColFrame(aState, aContent, aParentFrame,
    1:                                   aStyleContext, aNameSpaceID, PR_FALSE,
    1:                                   aFrameItems, newFrame, aHasPseudoParent);
    1:       if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
    1:         aFrameItems.AddChild(newFrame);
    1:       }
    1:       return rv;
    1:   
    1:     case NS_STYLE_DISPLAY_TABLE_ROW:
    1:       rv = ConstructTableRowFrame(aState, aContent, aParentFrame,
    1:                                   aStyleContext, aNameSpaceID, PR_FALSE,
    1:                                   aFrameItems, newFrame, aHasPseudoParent);
    1:       if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
    1:         aFrameItems.AddChild(newFrame);
    1:       }
    1:       return rv;
    1:   
    1:     case NS_STYLE_DISPLAY_TABLE_CELL:
    1:       {
    1:         nsIFrame* innerTable;
    1:         rv = ConstructTableCellFrame(aState, aContent, aParentFrame,
    1:                                      aStyleContext, aNameSpaceID,
    1:                                      PR_FALSE, aFrameItems, newFrame,
    1:                                      innerTable, aHasPseudoParent);
    1:         if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
    1:           aFrameItems.AddChild(newFrame);
    1:         }
    1:         return rv;
    1:       }
    1:   
    1:     default:
    1:       NS_NOTREACHED("How did we get here?");
    1:       break;
    1:     }
    1:   }
    1: 
    1:   if (!addedToFrameList) {
    1:     // Gotta do it here
    1:     NS_ASSERTION(!aDisplay->IsAbsolutelyPositioned() &&
    1:                  !aDisplay->IsFloating(),
    1:                  "Things that could be out-of-flow need to handle adding "
    1:                  "to the frame list themselves");
    1:     
 8199:     rv = aState.AddChild(newFrame, aFrameItems, aContent, aStyleContext,
 8199:                          aParentFrame);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv),
    1:                  "Cases where AddChild() can fail must handle it themselves");
    1:   }
    1: 
    1:   if (newFrame && addToHashTable) {
    1:     // Add a mapping from content object to primary frame. Note that for
    1:     // floated and positioned frames this is the out-of-flow frame and not
    1:     // the placeholder frame
    1:     if (!primaryFrameSet) {
    1:       aState.mFrameManager->SetPrimaryFrameFor(aContent, newFrame);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult 
    1: nsCSSFrameConstructor::InitAndRestoreFrame(const nsFrameConstructorState& aState,
    1:                                            nsIContent*              aContent,
    1:                                            nsIFrame*                aParentFrame,
    1:                                            nsIFrame*                aPrevInFlow,
    1:                                            nsIFrame*                aNewFrame,
    1:                                            PRBool                   aAllowCounters)
    1: {
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while creating frames");
 6518:   
    1:   nsresult rv = NS_OK;
    1:   
    1:   NS_ASSERTION(aNewFrame, "Null frame cannot be initialized");
    1:   if (!aNewFrame)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Initialize the frame
    1:   rv = aNewFrame->Init(aContent, aParentFrame, aPrevInFlow);
16976:   aNewFrame->AddStateBits(aState.mAdditionalStateBits);
    1: 
    1:   if (aState.mFrameState && aState.mFrameManager) {
    1:     // Restore frame state for just the newly created frame.
    1:     aState.mFrameManager->RestoreFrameStateFor(aNewFrame, aState.mFrameState);
    1:   }
    1: 
    1:   if (aAllowCounters && !aPrevInFlow &&
    1:       mCounterManager.AddCounterResetsAndIncrements(aNewFrame)) {
    1:     CountersDirty();
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::ResolveStyleContext(nsIFrame*         aParentFrame,
    1:                                            nsIContent*       aContent)
    1: {
18953:   nsStyleContext* parentStyleContext = nsnull;
  822:   if (aContent->GetParent()) {
  549:     aParentFrame = nsFrame::CorrectStyleParentFrame(aParentFrame, nsnull);
  549:   
18953:     if (aParentFrame) {
    1:       // Resolve the style context based on the content object and the parent
    1:       // style context
  822:       parentStyleContext = aParentFrame->GetStyleContext();
  822:     } else {
18953:       // Perhaps aParentFrame is a canvasFrame and we're replicating
18953:       // fixed-pos frames.
18953:       // XXX should we create a way to tell ConstructFrame which style
18953:       // context to use, and pass it the style context for the
18953:       // previous page's fixed-pos frame?
18953:     }
18953:   } else {
  822:     // This has got to be a call from ConstructDocElementTableFrame.
18953:     // Not sure how best to assert that here.
  822:   }
    1: 
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1: 
    1:   if (aContent->IsNodeOfType(nsINode::eELEMENT)) {
    1:     return styleSet->ResolveStyleFor(aContent, parentStyleContext);
    1:   } else {
    1: 
    1:     NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
    1:                  "shouldn't waste time creating style contexts for "
    1:                  "comments and processing instructions");
    1: 
    1:     return styleSet->ResolveStyleForNonElement(parentStyleContext);
    1:   }
    1: }
    1: 
    1: // MathML Mod - RBS
    1: #ifdef MOZ_MATHML
    1: nsresult
 6862: nsCSSFrameConstructor::FlushAccumulatedBlock(nsFrameConstructorState& aState,
 6862:                                              nsIContent* aContent,
 6862:                                              nsIFrame* aParentFrame,
 6862:                                              nsFrameItems* aBlockItems,
 6862:                                              nsFrameItems* aNewItems)
 6862: {
 6862:   if (!aBlockItems->childList) {
 6862:     // Nothing to do
 6862:     return NS_OK;
 6862:   }
 6862: 
 6862:   nsStyleContext* parentContext =
 6862:     nsFrame::CorrectStyleParentFrame(aParentFrame,
 6862:                                      nsCSSAnonBoxes::mozMathMLAnonymousBlock)->GetStyleContext(); 
 6862:   nsStyleSet *styleSet = mPresShell->StyleSet();
 6862:   nsRefPtr<nsStyleContext> blockContext;
 6862:   blockContext = styleSet->ResolvePseudoStyleFor(aContent,
 6862:                                                  nsCSSAnonBoxes::mozMathMLAnonymousBlock,
 6862:                                                  parentContext);
 6862: 
 6862:   // then, create a block frame that will wrap the child frames. Make it a
 6862:   // MathML frame so that Get(Absolute/Float)ContainingBlockFor know that this
 6862:   // is not a suitable block.
 6862:   nsIFrame* blockFrame = NS_NewMathMLmathBlockFrame(mPresShell, blockContext,
23305:                           NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
 6862:   if (NS_UNLIKELY(!blockFrame))
 6862:     return NS_ERROR_OUT_OF_MEMORY;
 6862: 
 6862:   InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, blockFrame);
 6862:   for (nsIFrame* f = aBlockItems->childList; f; f = f->GetNextSibling()) {
 6862:     ReparentFrame(aState.mFrameManager, blockFrame, f);
 6862:   }
 6862:   // abs-pos and floats are disabled in MathML children so we don't have to
 6862:   // worry about messing up those.
 6862:   blockFrame->SetInitialChildList(nsnull, aBlockItems->childList);
 6862:   *aBlockItems = nsFrameItems();
 6862:   aNewItems->AddChild(blockFrame);
 6862:   return NS_OK;
 6862: }
 6862: 
23946: // Only <math> elements can be floated or positioned.  All other MathML
23946: // should be in-flow.
23946: #define SIMPLE_MATHML_CREATE(_tag, _func)                               \
23946:   { &nsGkAtoms::_tag,                                                   \
23946:       FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW |                         \
23946:                   FCDATA_FORCE_NULL_ABSPOS_CONTAINER |                  \
23946:                   FCDATA_WRAP_KIDS_IN_BLOCKS |                          \
23946:                   FCDATA_SKIP_FRAMEMAP, _func) }
23946: 
23946: /* static */
23946: const nsCSSFrameConstructor::FrameConstructionData*
23946: nsCSSFrameConstructor::FindMathMLData(nsIContent* aContent,
    1:                                       nsIAtom* aTag,
    1:                                       PRInt32 aNameSpaceID,
23946:                                       nsStyleContext* aStyleContext)
    1: {
    1:   // Make sure that we remain confined in the MathML world
    1:   if (aNameSpaceID != kNameSpaceID_MathML) 
23946:     return nsnull;
23946: 
23946:   static const FrameConstructionDataByTag sMathMLData[] = {
23946:     SIMPLE_MATHML_CREATE(mi_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(mn_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(ms_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(mtext_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(mo_, NS_NewMathMLmoFrame),
23946:     SIMPLE_MATHML_CREATE(mfrac_, NS_NewMathMLmfracFrame),
23946:     SIMPLE_MATHML_CREATE(msup_, NS_NewMathMLmsupFrame),
23946:     SIMPLE_MATHML_CREATE(msub_, NS_NewMathMLmsubFrame),
23946:     SIMPLE_MATHML_CREATE(msubsup_, NS_NewMathMLmsubsupFrame),
23946:     SIMPLE_MATHML_CREATE(munder_, NS_NewMathMLmunderFrame),
23946:     SIMPLE_MATHML_CREATE(mover_, NS_NewMathMLmoverFrame),
23946:     SIMPLE_MATHML_CREATE(munderover_, NS_NewMathMLmunderoverFrame),
23946:     SIMPLE_MATHML_CREATE(mphantom_, NS_NewMathMLmphantomFrame),
23946:     SIMPLE_MATHML_CREATE(mpadded_, NS_NewMathMLmpaddedFrame),
23946:     SIMPLE_MATHML_CREATE(mspace_, NS_NewMathMLmspaceFrame),
23946:     SIMPLE_MATHML_CREATE(none, NS_NewMathMLmspaceFrame),
23946:     SIMPLE_MATHML_CREATE(mprescripts_, NS_NewMathMLmspaceFrame),
23946:     SIMPLE_MATHML_CREATE(mfenced_, NS_NewMathMLmfencedFrame),
23946:     SIMPLE_MATHML_CREATE(mmultiscripts_, NS_NewMathMLmmultiscriptsFrame),
23946:     SIMPLE_MATHML_CREATE(mstyle_, NS_NewMathMLmstyleFrame),
23946:     SIMPLE_MATHML_CREATE(msqrt_, NS_NewMathMLmsqrtFrame),
23946:     SIMPLE_MATHML_CREATE(mroot_, NS_NewMathMLmrootFrame),
23946:     SIMPLE_MATHML_CREATE(maction_, NS_NewMathMLmactionFrame),
23946:     SIMPLE_MATHML_CREATE(mrow_, NS_NewMathMLmrowFrame),
23946:     SIMPLE_MATHML_CREATE(merror_, NS_NewMathMLmrowFrame),
23946:     { &nsGkAtoms::math,
23946:       FCDATA_DECL(FCDATA_FORCE_NULL_ABSPOS_CONTAINER |
23946:                   FCDATA_WRAP_KIDS_IN_BLOCKS |
23946:                   FCDATA_SKIP_FRAMEMAP,
23946:                   NS_NewMathMLmathFrame) }
23946:   };
23946: 
23946:   return FindDataByTag(aTag, aContent, aStyleContext, sMathMLData,
23946:                        NS_ARRAY_LENGTH(sMathMLData));
23167: }
23167: #endif // MOZ_MATHML
23167: 
23167: #ifdef MOZ_SVG
23954: // Only outer <svg> elements can be floated or positioned.  All other SVG
    1: // should be in-flow.
23954: #define SIMPLE_SVG_FCDATA(_func)                                        \
23954:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW |                             \
23954:               FCDATA_SKIP_ABSPOS_PUSH | FCDATA_SKIP_FRAMEMAP |          \
23954:               FCDATA_DISALLOW_GENERATED_CONTENT,  _func)
23954: #define SIMPLE_SVG_CREATE(_tag, _func)            \
23954:   { &nsGkAtoms::_tag, SIMPLE_SVG_FCDATA(_func) }
23954: 
23954: /* static */
23954: const nsCSSFrameConstructor::FrameConstructionData*
23954: nsCSSFrameConstructor::FindSVGData(nsIContent* aContent,
    1:                                    nsIAtom* aTag,
    1:                                    PRInt32 aNameSpaceID,
23954:                                    nsIFrame* aParentFrame,
23954:                                    nsStyleContext* aStyleContext)
23954: {
23954:   if (aNameSpaceID != kNameSpaceID_SVG || !NS_SVGEnabled()) {
23954:     return nsnull;
23954:   }
23954: 
23954:   static const FrameConstructionData sSuppressData = SUPPRESS_FCDATA();
23954:   static const FrameConstructionData sGenericContainerData =
23954:     SIMPLE_SVG_FCDATA(NS_NewSVGGenericContainerFrame);
    1: 
    1:   PRBool parentIsSVG = PR_FALSE;
23954:   nsIContent* parentContent =
23954:     aParentFrame ? aParentFrame->GetContent() : nsnull;
23954:   // XXXbz should this really be based on the XBL-resolved tag of the parent
23954:   // frame's content?  Should it not be based on the type of the parent frame
23954:   // (e.g. whether it's an SVG frame)?
23954:   if (parentContent) {
    1:     PRInt32 parentNSID;
    1:     nsIAtom* parentTag =
23954:       parentContent->GetOwnerDoc()->BindingManager()->
23954:         ResolveTag(aParentFrame->GetContent(), &parentNSID);
    1: 
    1:     // It's not clear whether the SVG spec intends to allow any SVG
    1:     // content within svg:foreignObject at all (SVG 1.1, section
    1:     // 23.2), but if it does, it better be svg:svg.  So given that
    1:     // we're allowing it, treat it as a non-SVG parent.
16967:     parentIsSVG = parentNSID == kNameSpaceID_SVG &&
16967:                   parentTag != nsGkAtoms::foreignObject;
    1:   }
    1: 
    1:   if ((aTag != nsGkAtoms::svg && !parentIsSVG) ||
    1:       (aTag == nsGkAtoms::desc || aTag == nsGkAtoms::title)) {
    1:     // Sections 5.1 and G.4 of SVG 1.1 say that SVG elements other than
    1:     // svg:svg not contained within svg:svg are incorrect, although they
    1:     // don't seem to specify error handling.  Ignore them, since many of
    1:     // our frame classes can't deal.  It *may* be that the document
    1:     // should at that point be considered in error according to F.2, but
    1:     // it's hard to tell.
    1:     //
    1:     // Style mutation can't change this situation, so don't bother
    1:     // adding to the undisplayed content map.
23954:     // XXXbz except of course that this makes GetPrimaryFrameFor for this stuff
23954:     // that much slower.
    1:     //
    1:     // We don't currently handle any UI for desc/title
23954:     return &sSuppressData;
    1:   }
    1: 
15895:   // Reduce the number of frames we create unnecessarily. Note that this is not
15895:   // where we select which frame in a <switch> to render! That happens in
15895:   // nsSVGSwitchFrame::PaintSVG.
15895:   if (!NS_SVG_PassesConditionalProcessingTests(aContent)) {
    1:     // Note that just returning is probably not right.  According
    1:     // to the spec, <use> is allowed to use an element that fails its
    1:     // conditional, but because we never actually create the frame when
    1:     // a conditional fails and when we use GetReferencedFrame to find the
    1:     // references, things don't work right.
    1:     // XXX FIXME XXX
23954:     return &sSuppressData;
23954:   }
23954: 
23954:   // Special case for aTag == nsGkAtoms::svg because we don't want to
23954:   // have to recompute parentIsSVG for it.
    1:   if (aTag == nsGkAtoms::svg) {
23954:     if (parentIsSVG) {
23954:       static const FrameConstructionData sInnerSVGData =
23954:         SIMPLE_SVG_FCDATA(NS_NewSVGInnerSVGFrame);
23954:       return &sInnerSVGData;
23954:     }
23954: 
23954:     static const FrameConstructionData sOuterSVGData =
23954:       FCDATA_DECL(FCDATA_FORCE_VIEW | FCDATA_SKIP_ABSPOS_PUSH |
23954:                   FCDATA_SKIP_FRAMEMAP | FCDATA_DISALLOW_GENERATED_CONTENT,
23954:                   NS_NewSVGOuterSVGFrame);
23954:     return &sOuterSVGData;
23954:   }
23954: 
23954:   // Special cases for text/tspan/textpath, because the kind of frame
23954:   // they get depends on the parent frame.
23954:   if (aTag == nsGkAtoms::text) {
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
16390:     if (ancestorFrame) {
23554:       nsISVGTextContentMetrics* metrics = do_QueryFrame(ancestorFrame);
16390:       // Text cannot be nested
23954:       if (metrics) {
23954:         return &sGenericContainerData;
23954:       }
    1:     }
16390:   }
    1:   else if (aTag == nsGkAtoms::tspan) {
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
    1:     if (ancestorFrame) {
23554:       nsISVGTextContentMetrics* metrics = do_QueryFrame(ancestorFrame);
23954:       if (!metrics) {
23954:         return &sGenericContainerData;
23954:       }
23954:     }
    1:   }
    1:   else if (aTag == nsGkAtoms::textPath) {
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
23954:     if (!ancestorFrame ||
23954:         ancestorFrame->GetType() != nsGkAtoms::svgTextFrame) {
23954:       return &sGenericContainerData;
23954:     }
23954:   }
23954: 
23954:   static const FrameConstructionDataByTag sSVGData[] = {
23954:     SIMPLE_SVG_CREATE(g, NS_NewSVGGFrame),
23954:     SIMPLE_SVG_CREATE(svgSwitch, NS_NewSVGSwitchFrame),
23954:     SIMPLE_SVG_CREATE(polygon, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(polyline, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(circle, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(ellipse, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(line, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(rect, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(path, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(defs, NS_NewSVGContainerFrame),
23954:     COMPLEX_TAG_CREATE(foreignObject,
23954:                        &nsCSSFrameConstructor::ConstructSVGForeignObjectFrame),
23954:     SIMPLE_SVG_CREATE(a, NS_NewSVGAFrame),
23954:     SIMPLE_SVG_CREATE(text, NS_NewSVGTextFrame),
23954:     SIMPLE_SVG_CREATE(tspan, NS_NewSVGTSpanFrame),
23954:     SIMPLE_SVG_CREATE(linearGradient, NS_NewSVGLinearGradientFrame),
23954:     SIMPLE_SVG_CREATE(radialGradient, NS_NewSVGRadialGradientFrame),
23954:     SIMPLE_SVG_CREATE(stop, NS_NewSVGStopFrame),
23954:     SIMPLE_SVG_CREATE(use, NS_NewSVGUseFrame),
23954:     SIMPLE_SVG_CREATE(marker, NS_NewSVGMarkerFrame),
23954:     SIMPLE_SVG_CREATE(image, NS_NewSVGImageFrame),
23954:     SIMPLE_SVG_CREATE(clipPath, NS_NewSVGClipPathFrame),
23954:     SIMPLE_SVG_CREATE(textPath, NS_NewSVGTextPathFrame),
23954:     SIMPLE_SVG_CREATE(filter, NS_NewSVGFilterFrame),
23954:     SIMPLE_SVG_CREATE(pattern, NS_NewSVGPatternFrame),
23954:     SIMPLE_SVG_CREATE(mask, NS_NewSVGMaskFrame),
23954:     SIMPLE_SVG_CREATE(feDistantLight, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(fePointLight, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feSpotLight, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feBlend, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feColorMatrix, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncR, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncG, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncB, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncA, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feComposite, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feConvolveMatrix, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feDisplacementMap, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFlood, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feGaussianBlur, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feImage, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feMergeNode, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feMorphology, NS_NewSVGLeafFrame), 
23954:     SIMPLE_SVG_CREATE(feOffset, NS_NewSVGLeafFrame), 
23954:     SIMPLE_SVG_CREATE(feTile, NS_NewSVGLeafFrame), 
23954:     SIMPLE_SVG_CREATE(feTurbulence, NS_NewSVGLeafFrame) 
23954:   };
23954: 
23954:   const FrameConstructionData* data =
23954:     FindDataByTag(aTag, aContent, aStyleContext, sSVGData,
23954:                   NS_ARRAY_LENGTH(sSVGData));
23954: 
23954:   if (!data) {
23954:     data = &sGenericContainerData;
23954:   }
23954: 
23954:   return data;
23954: }
23954: 
23954: nsresult
23954: nsCSSFrameConstructor::ConstructSVGForeignObjectFrame(nsFrameConstructorState& aState,
23954:                                                       nsIContent* aContent,
23954:                                                       nsIFrame* aParentFrame,
23954:                                                       nsIAtom* aTag,
23954:                                                       nsStyleContext* aStyleContext,
23954:                                                       const nsStyleDisplay* aStyleDisplay,
23954:                                                       nsFrameItems& aFrameItems,
23954:                                                       nsIFrame** aNewFrame)
23954: {
23954:   nsIFrame* newFrame = NS_NewSVGForeignObjectFrame(mPresShell, aStyleContext);
23954:   if (NS_UNLIKELY(!newFrame)) {
23954:     return NS_ERROR_OUT_OF_MEMORY;
23954:   }
23954: 
23954:   // We don't allow this frame to be out of flow
23954:   InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, newFrame);
23954:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
23954: 
23954:   nsresult rv = aState.AddChild(newFrame, aFrameItems, aContent, aStyleContext,
23954:                                 aParentFrame, PR_FALSE, PR_FALSE);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsRefPtr<nsStyleContext> innerPseudoStyle;
    1:   innerPseudoStyle = mPresShell->StyleSet()->
    1:     ResolvePseudoStyleFor(aContent,
    1:                           nsCSSAnonBoxes::mozSVGForeignContent, aStyleContext);
    1: 
    1:   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerPseudoStyle,
23305:                                           NS_BLOCK_FLOAT_MGR |
    1:                                           NS_BLOCK_MARGIN_ROOT);
23954:   if (NS_UNLIKELY(!blockFrame)) {
23954:     newFrame->Destroy();
    1:     return NS_ERROR_OUT_OF_MEMORY;
23954:   }
23954: 
23954:   nsFrameItems childItems;
    1:   // Claim to be relatively positioned so that we end up being the
    1:   // absolute containing block.
 7189:   rv = ConstructBlock(aState, innerPseudoStyle->GetStyleDisplay(), aContent,
    1:                       newFrame, newFrame, innerPseudoStyle,
    1:                       &blockFrame, childItems, PR_TRUE);
23954: 
    1:   // Give the blockFrame a view so that GetOffsetTo works for descendants
    1:   // of blockFrame with views...
23395:   nsHTMLContainerFrame::CreateViewForFrame(blockFrame, PR_TRUE);
23954: 
    1:   newFrame->SetInitialChildList(nsnull, childItems.childList);
23954: 
23954:   *aNewFrame = newFrame;
23954: 
23954:   return rv;
23954: }
23954: 
    1: #endif // MOZ_SVG
    1: 
14246: // If page-break-before is set, this function constructs a page break frame,
14246: // EXCEPT for on these types of elements:
14246: //  * row groups, rows, cells (these are handled internally by tables)
14246: //  * fixed- and absolutely-positioned elements (currently, our positioning
14246: //    code doesn't expect positioned frames to have nsPageBreakFrame siblings)
14246: //
14246: // Returns true iff we should construct a page break frame after this element.
23162: // aStyleContext is the style context of the frame for which we're
23162: // constructing the page break
    1: PRBool
    1: nsCSSFrameConstructor::PageBreakBefore(nsFrameConstructorState& aState,
    1:                                        nsIContent*              aContent,
    1:                                        nsIFrame*                aParentFrame,
    1:                                        nsStyleContext*          aStyleContext,
    1:                                        nsFrameItems&            aFrameItems)
    1: {
    1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
    1: 
    1:   if (NS_STYLE_DISPLAY_NONE != display->mDisplay &&
14246:       NS_STYLE_POSITION_FIXED    != display->mPosition &&
14246:       NS_STYLE_POSITION_ABSOLUTE != display->mPosition &&
    1:       (NS_STYLE_DISPLAY_TABLE == display->mDisplay ||
    1:        !IsTableRelated(display->mDisplay, PR_TRUE))) { 
    1:     if (display->mBreakBefore) {
    1:       ConstructPageBreakFrame(aState, aContent, aParentFrame, aStyleContext,
    1:                               aFrameItems);
    1:     }
    1:     return display->mBreakAfter;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
23162: // aStyleContext is the style context of the frame for which we're
23162: // constructing the page break
    1: nsresult
    1: nsCSSFrameConstructor::ConstructPageBreakFrame(nsFrameConstructorState& aState,
    1:                                                nsIContent*              aContent,
    1:                                                nsIFrame*                aParentFrame,
    1:                                                nsStyleContext*          aStyleContext,
    1:                                                nsFrameItems&            aFrameItems)
    1: {
    1:   nsRefPtr<nsStyleContext> pseudoStyle;
23162:   // Use the same parent style context that |aStyleContext| has, since
23162:   // that's easier to re-resolve and it doesn't matter in practice.
23162:   // (Getting different parents can result in framechange hints, e.g.,
23162:   // for user-modify.)
    1:   pseudoStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(nsnull,
23162:                    nsCSSAnonBoxes::pageBreak, aStyleContext->GetParent());
    1:   nsIFrame* pageBreakFrame = NS_NewPageBreakFrame(mPresShell, pseudoStyle);
    1:   if (pageBreakFrame) {
    1:     InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, pageBreakFrame);
    1:     aFrameItems.AddChild(pageBreakFrame);
    1: 
    1:     return NS_OK;
    1:   }
    1:   else {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructFrame(nsFrameConstructorState& aState,
    1:                                       nsIContent*              aContent,
    1:                                       nsIFrame*                aParentFrame,
    1:                                       nsFrameItems&            aFrameItems)
    1: 
    1: {
    1:   NS_PRECONDITION(nsnull != aParentFrame, "no parent frame");
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   // don't create a whitespace frame if aParent doesn't want it
    1:   if (!NeedFrameFor(aParentFrame, aContent)) {
    1:     return rv;
    1:   }
    1: 
    1:   // never create frames for comments or PIs
    1:   if (aContent->IsNodeOfType(nsINode::eCOMMENT) ||
    1:       aContent->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION))
    1:     return rv;
    1: 
    1:   nsRefPtr<nsStyleContext> styleContext;
    1:   styleContext = ResolveStyleContext(aParentFrame, aContent);
    1: 
    1:   PRBool pageBreakAfter = PR_FALSE;
    1: 
    1:   if (aState.mPresContext->IsPaginated()) {
23162:     // Construct a page break frame for page-break-before, and remember if
23162:     // we need one for page-break-after.
    1:     pageBreakAfter = PageBreakBefore(aState, aContent, aParentFrame,
    1:                                      styleContext, aFrameItems);
    1:   }
    1: 
    1:   // construct the frame
    1:   rv = ConstructFrameInternal(aState, aContent, aParentFrame,
    1:                               aContent->Tag(), aContent->GetNameSpaceID(),
    1:                               styleContext, aFrameItems, PR_FALSE);
    1: 
    1:   if (NS_SUCCEEDED(rv) && pageBreakAfter) {
    1:     // Construct the page break after
    1:     ConstructPageBreakFrame(aState, aContent, aParentFrame, styleContext,
    1:                             aFrameItems);
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructFrameInternal( nsFrameConstructorState& aState,
    1:                                                nsIContent*              aContent,
    1:                                                nsIFrame*                aParentFrame,
    1:                                                nsIAtom*                 aTag,
    1:                                                PRInt32                  aNameSpaceID,
    1:                                                nsStyleContext*          aStyleContext,
    1:                                                nsFrameItems&            aFrameItems,
    1:                                                PRBool                   aXBLBaseTag)
    1: {
    1:   // The following code allows the user to specify the base tag
    1:   // of an element using XBL.  XUL and HTML objects (like boxes, menus, etc.)
    1:   // can then be extended arbitrarily.
    1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
    1:   nsRefPtr<nsStyleContext> styleContext(aStyleContext);
    1:   nsAutoEnqueueBinding binding(mDocument);
    1:   if (!aXBLBaseTag)
    1:   {
    1:     
    1:     // Ensure that our XBL bindings are installed.
    1:     if (display->mBinding) {
    1:       // Get the XBL loader.
    1:       nsresult rv;
    1:       // Load the bindings.
    1:       PRBool resolveStyle;
    1:       
    1:       nsIXBLService * xblService = GetXBLService();
    1:       if (!xblService)
    1:         return NS_ERROR_FAILURE;
    1: 
 3645:       rv = xblService->LoadBindings(aContent, display->mBinding->mURI,
 3645:                                     display->mBinding->mOriginPrincipal,
 3645:                                     PR_FALSE, getter_AddRefs(binding.mBinding),
    1:                                     &resolveStyle);
    1:       if (NS_FAILED(rv))
    1:         return NS_OK;
    1: 
    1:       if (resolveStyle) {
    1:         styleContext = ResolveStyleContext(aParentFrame, aContent);
    1:         display = styleContext->GetStyleDisplay();
    1:       }
    1: 
    1:       PRInt32 nameSpaceID;
    1:       nsCOMPtr<nsIAtom> baseTag =
    1:         mDocument->BindingManager()->ResolveTag(aContent, &nameSpaceID);
    1: 
    1:       if (baseTag != aTag || aNameSpaceID != nameSpaceID) {
    1:         // Construct the frame using the XBL base tag.
    1:         rv = ConstructFrameInternal(aState,
    1:                                     aContent,
    1:                                     aParentFrame,
    1:                                     baseTag,
    1:                                     nameSpaceID,
    1:                                     styleContext,
    1:                                     aFrameItems,
    1:                                     PR_TRUE);
    1:         return rv;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Pre-check for display "none" - if we find that, don't create
    1:   // any frame at all
    1:   if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
    1:     aState.mFrameManager->SetUndisplayedContent(aContent, styleContext);
    1:     return NS_OK;
    1:   }
    1: 
23955:   PRBool isText = aContent->IsNodeOfType(nsINode::eTEXT);
23955:   // Try to find frame construction data for this content
23955:   const FrameConstructionData* data;
23955:   if (isText) {
23955:     data = FindTextData(aParentFrame);
23955:   } else {
23955:     data = FindHTMLData(aContent, aTag, aNameSpaceID, styleContext);
23955:     if (!data) {
23955:       data = FindXULTagData(aContent, aTag, aNameSpaceID, styleContext);
23955:     }
23955: #ifdef MOZ_MATHML
23955:     if (!data) {
23955:       data = FindMathMLData(aContent, aTag, aNameSpaceID, styleContext);
23955:     }
23955: #endif
23955: #ifdef MOZ_SVG
23955:     if (!data) {
23955:       data = FindSVGData(aContent, aTag, aNameSpaceID, aParentFrame,
23955:                          styleContext);
23955:     }
23955: #endif /* MOZ_SVG */
23955: 
23955:     if (data && (data->mBits & FCDATA_SUPPRESS_FRAME)) {
23955:       return NS_OK;
23955:     }
23955:   }
23955:   
    1:   nsIFrame* adjParentFrame = aParentFrame;
    1:   nsFrameItems* frameItems = &aFrameItems;
    1:   PRBool pseudoParent = PR_FALSE;
    1:   PRBool suppressFrame = PR_FALSE;
    1:   nsFrameConstructorSaveState pseudoSaveState;
    1:   nsresult rv = AdjustParentFrame(aState, aContent, adjParentFrame,
23955:                                   data, aNameSpaceID, display, frameItems,
23955:                                   pseudoSaveState, suppressFrame, pseudoParent);
    1:   if (NS_FAILED(rv) || suppressFrame) {
    1:     return rv;
    1:   }
    1: 
23955:   if (isText) {
23955:     return ConstructTextFrame(data, aState, aContent, adjParentFrame,
23955:                               styleContext, *frameItems, pseudoParent);
23955:   }
    1: 
    1: #ifdef MOZ_SVG
23955:   // Don't create frames for non-SVG element children of SVG elements
    1:   if (aNameSpaceID != kNameSpaceID_SVG &&
    1:       aParentFrame &&
16967:       aParentFrame->IsFrameOfType(nsIFrame::eSVG) &&
16967:       !aParentFrame->IsFrameOfType(nsIFrame::eSVGForeignObject)
    1:       ) {
    1:     return NS_OK;
    1:   }
    1: #endif
    1: 
18889:   // If the page contains markup that overrides text direction, and
18889:   // does not contain any characters that would activate the Unicode
18889:   // bidi algorithm, we need to call |SetBidiEnabled| on the pres
18889:   // context before reflow starts.  This requires us to resolve some
18889:   // style information now.  See bug 115921.
18889:   {
18889:     if (styleContext->GetStyleVisibility()->mDirection ==
18889:         NS_STYLE_DIRECTION_RTL)
18889:       aState.mPresContext->SetBidiEnabled();
    1:   }
    1:   // Start background loads during frame construction. This is just
    1:   // a hint; the paint code will do the right thing in any case.
    1:   {
    1:     styleContext->GetStyleBackground();
    1:   }
    1: 
23955:   // Now check for XUL display types
23952:   if (!data) {
23955:     data = FindXULDisplayData(display, aContent, aStyleContext);
23955:   }
23954: 
23954:   if (data) {
23952: #ifdef MOZ_XUL
23955:     if ((data->mBits & FCDATA_IS_POPUP) &&
23952:         adjParentFrame->GetType() != nsGkAtoms::menuFrame &&
23955:         !aState.mPopupItems.containingBlock) {
23955:       return NS_OK;
23955:     }
23952: #endif /* MOZ_XUL */
23954: 
23954:     return ConstructFrameFromData(data, aState, aContent, adjParentFrame, aTag,
    1:                                   aNameSpaceID, styleContext, *frameItems,
    1:                                   pseudoParent);
23167: 
23954:   }
23954:   
23954:   return ConstructFrameByDisplayType(aState, display, aContent, aNameSpaceID,
    1:                                      aTag, adjParentFrame, styleContext,
    1:                                      *frameItems, pseudoParent);
    1: }
    1: 
    1: 
    1: inline PRBool
    1: IsRootBoxFrame(nsIFrame *aFrame)
    1: {
    1:   return (aFrame->GetType() == nsGkAtoms::rootFrame);
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ReconstructDocElementHierarchy()
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
    1:   return ReconstructDocElementHierarchyInternal();
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ReconstructDocElementHierarchyInternal()
    1: {
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ReconstructDocElementHierarchy\n");
    1:   }
    1: #endif
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   // XXXbz is that null-check needed?  Why?
    1:   if (mDocument && mPresShell) {
    1:     nsIContent *rootContent = mDocument->GetRootContent();
    1:     
    1:     if (rootContent) {
18953:       nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
18953:                                     nsnull, nsnull, mTempFrameTreeState);
18953: 
18888:       // Before removing the frames associated with the content object, ask them to save their
18888:       // state onto a temporary state object.
18953:       CaptureStateFor(state.mFrameManager->GetRootFrame(), mTempFrameTreeState);
18885: 
    1:       // Get the frame that corresponds to the document element
    1:       nsIFrame* docElementFrame =
    1:         state.mFrameManager->GetPrimaryFrameFor(rootContent, -1);
    1: 
18953:       if (docElementFrame) {
18953:         // Destroy out-of-flow frames that might not be in the frame subtree
18953:         // rooted at docElementFrame
18953:         ::DeletingFrameSubtree(state.mFrameManager, docElementFrame);
23830:       } else {
23830:         state.mFrameManager->ClearUndisplayedContentIn(rootContent, nsnull);
18953:       }
18953: 
    1:       // Remove any existing fixed items: they are always on the
    1:       // FixedContainingBlock.  Note that this has to be done before we call
    1:       // ClearPlaceholderFrameMap(), since RemoveFixedItems uses the
    1:       // placeholder frame map.
18953:       rv = RemoveFixedItems(state, docElementFrame);
18953: 
    1:       if (NS_SUCCEEDED(rv)) {
18953:         nsPlaceholderFrame* placeholderFrame = nsnull;
18953:         if (docElementFrame &&
18953:             (docElementFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
18953:           // Get the placeholder frame now, before we tear down the
18953:           // placeholder frame map
18953:           placeholderFrame =
18953:             state.mFrameManager->GetPlaceholderFrameFor(docElementFrame);
18953:           NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
18953:         }
18953: 
    1:         // Clear the hash tables that map from content to frame and out-of-flow
    1:         // frame to placeholder frame
    1:         state.mFrameManager->ClearPrimaryFrameMap();
    1:         state.mFrameManager->ClearPlaceholderFrameMap();
    1:         state.mFrameManager->ClearUndisplayedContentMap();
    1: 
 1228:         if (docElementFrame) {
    1:           // Take the docElementFrame, and remove it from its parent.
    1:           // XXXbz So why can't we reuse ContentRemoved?
    1: 
 7113:           // Notify self that we will destroy the entire frame tree, this blocks
 7113:           // RemoveMappingsForFrameSubtree() which would otherwise lead to a
 7113:           // crash since we cleared the placeholder map above (bug 398982).
 7113:           PRBool wasDestroyingFrameTree = mIsDestroyingFrameTree;
22769:           WillDestroyFrameTree(PR_FALSE);
18953: 
18953:           rv = state.mFrameManager->RemoveFrame(docElementFrame->GetParent(),
18953:                     GetChildListNameFor(docElementFrame), docElementFrame);
18953:           
18953:           if (placeholderFrame) {
18953:             // Remove the placeholder frame first (XXX second for now) (so
18953:             // that it doesn't retain a dangling pointer to memory)
18953:             rv |= state.mFrameManager->RemoveFrame(placeholderFrame->GetParent(),
18953:                                             nsnull, placeholderFrame);
18953:           }
18953: 
 7113:           mIsDestroyingFrameTree = wasDestroyingFrameTree;
    1:           if (NS_FAILED(rv)) {
    1:             return rv;
    1:           }
 1228:         }
21942:       }
21942:     }
21942:     
21942:     if (rootContent && NS_SUCCEEDED(rv)) {
16509:       mInitialContainingBlock = nsnull;
16509:       mRootElementStyleFrame = nsnull;
16509: 
21942:       // We don't reuse the old frame constructor state because,
21942:       // for example, its mPopupItems may be stale
21942:       nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
21942:                                     nsnull, nsnull, mTempFrameTreeState);
21942: 
    1:       // Create the new document element hierarchy
    1:       nsIFrame* newChild;
    1:       rv = ConstructDocElementFrame(state, rootContent,
    1:                                     mDocElementContainingBlock, &newChild);
    1: 
    1:       // newChild could be null even if |rv| is success, thanks to XBL.
    1:       if (NS_SUCCEEDED(rv) && newChild) {
    1:         rv = state.mFrameManager->InsertFrames(mDocElementContainingBlock,
    1:                                                nsnull, nsnull, newChild);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: nsIFrame*
    1: nsCSSFrameConstructor::GetFrameFor(nsIContent* aContent)
    1: {
    1:   // Get the primary frame associated with the content
    1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
    1: 
    1:   if (!frame)
    1:     return nsnull;
    1: 
    1:   nsIFrame* insertionFrame = frame->GetContentInsertionFrame();
    1: 
    1:   NS_ASSERTION(insertionFrame == frame || !frame->IsLeaf(),
    1:     "The insertion frame is the primary frame or the primary frame isn't a leaf");
    1: 
    1:   return insertionFrame;
    1: }
    1: 
    1: nsIFrame*
    1: nsCSSFrameConstructor::GetAbsoluteContainingBlock(nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(nsnull != mInitialContainingBlock, "no initial containing block");
    1:   
    1:   // Starting with aFrame, look for a frame that is absolutely positioned or
    1:   // relatively positioned
    1:   nsIFrame* containingBlock = nsnull;
    1:   for (nsIFrame* frame = aFrame; frame && !containingBlock;
    1:        frame = frame->GetParent()) {
    1:     if (frame->IsFrameOfType(nsIFrame::eMathML)) {
    1:       // If it's mathml, bail out -- no absolute positioning out from inside
    1:       // mathml frames.  Note that we don't make this part of the loop
20147:       // condition because of the stuff at the end of this method...
    1:       return nsnull;
    1:     }
    1:     
    1:     // Is it positioned?
    1:     // If it's table-related then ignore it, because for the time
    1:     // being table-related frames are not containers for absolutely
    1:     // positioned child frames.
    1:     const nsStyleDisplay* disp = frame->GetStyleDisplay();
    1: 
    1:     if (disp->IsPositioned() && !IsTableRelated(disp->mDisplay, PR_TRUE)) {
    1:       // Find the outermost wrapped block under this frame
    1:       for (nsIFrame* wrappedFrame = aFrame; wrappedFrame != frame->GetParent();
    1:            wrappedFrame = wrappedFrame->GetParent()) {
    1:         nsIAtom* frameType = wrappedFrame->GetType();
23176:         if (nsGkAtoms::blockFrame == frameType ||
23176: #ifdef MOZ_XUL
23176:             nsGkAtoms::XULLabelFrame == frameType ||
23176: #endif
    1:             nsGkAtoms::positionedInlineFrame == frameType) {
    1:           containingBlock = wrappedFrame;
    1:         } else if (nsGkAtoms::fieldSetFrame == frameType) {
    1:           // If the positioned frame is a fieldset, use the area frame inside it.
    1:           // We don't use GetContentInsertionFrame for fieldsets yet.
23176:           containingBlock = GetFieldSetBlockFrame(wrappedFrame);
    1:         }
    1:       }
    1: 
    1: #ifdef DEBUG
    1:       if (!containingBlock)
    1:         NS_WARNING("Positioned frame that does not handle positioned kids; looking further up the parent chain");
    1: #endif
    1:     }
    1:   }
    1: 
 7680:   // If we found an absolutely positioned containing block, then use the
 7680:   // first-continuation.
    1:   if (containingBlock)
 7680:     return AdjustAbsoluteContainingBlock(containingBlock);
    1: 
18953:   // If we didn't find it, then use the document element containing block
18953:   return mHasRootAbsPosContainingBlock ? mDocElementContainingBlock : nsnull;
    1: }
    1: 
    1: nsIFrame*
    1: nsCSSFrameConstructor::GetFloatContainingBlock(nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(mInitialContainingBlock, "no initial containing block");
    1:   
    1:   // Starting with aFrame, look for a frame that is a float containing block.
    1:   // IF we hit a mathml frame, bail out; we don't allow floating out of mathml
    1:   // frames, because they don't seem to be able to deal.
23352:   // The logic here needs to match the logic in ProcessChildren()
    1:   for (nsIFrame* containingBlock = aFrame;
 2192:        containingBlock && !containingBlock->IsFrameOfType(nsIFrame::eMathML) &&
 2192:        !containingBlock->IsBoxFrame();
    1:        containingBlock = containingBlock->GetParent()) {
    1:     if (containingBlock->IsFloatContainingBlock()) {
    1:       return containingBlock;
    1:     }
    1:   }
    1: 
    1:   // If we didn't find a containing block, then there just isn't
    1:   // one.... return null
    1:   return nsnull;
    1: }
    1: 
    1: /**
    1:  * This function will check whether aContainer has :after generated content.
    1:  * If so, appending to it should actually insert.  The return value is the
    1:  * parent to use for newly-appended content.  *aAfterFrame points to the :after
    1:  * frame before which appended content should go, if there is one.
    1:  */
    1: static nsIFrame*
    1: AdjustAppendParentForAfterContent(nsPresContext* aPresContext,
    1:                                   nsIContent* aContainer,
    1:                                   nsIFrame* aParentFrame,
    1:                                   nsIFrame** aAfterFrame)
    1: {
    1:   // See if the parent has an :after pseudo-element.  Check for the presence
    1:   // of style first, since nsLayoutUtils::GetAfterFrame is sorta expensive.
    1:   nsStyleContext* parentStyle = aParentFrame->GetStyleContext();
    1:   if (nsLayoutUtils::HasPseudoStyle(aContainer, parentStyle,
    1:                                     nsCSSPseudoElements::after,
    1:                                     aPresContext)) {
    1:     nsIFrame* afterFrame = nsLayoutUtils::GetAfterFrame(aParentFrame);
    1:     if (afterFrame) {
    1:       *aAfterFrame = afterFrame;
    1:       return afterFrame->GetParent();
    1:     }
    1:   }
    1: 
    1:   *aAfterFrame = nsnull;
    1:   return aParentFrame;
    1: }
    1: 
    1: /**
    1:  * This function is called by ContentAppended() and ContentInserted()
    1:  * when appending flowed frames to a parent's principal child list. It
    1:  * handles the case where the parent frame has :after pseudo-element
    1:  * generated content.
    1:  */
    1: nsresult
 4696: nsCSSFrameConstructor::AppendFrames(nsFrameConstructorState&       aState,
    1:                                     nsIContent*                    aContainer,
    1:                                     nsIFrame*                      aParentFrame,
 4696:                                     nsFrameItems&                  aFrameList,
    1:                                     nsIFrame*                      aAfterFrame)
    1: {
    1: #ifdef DEBUG
    1:   nsIFrame* debugAfterFrame;
    1:   nsIFrame* debugNewParent =
    1:     ::AdjustAppendParentForAfterContent(aState.mPresContext, aContainer,
    1:                                         aParentFrame, &debugAfterFrame);
    1:   NS_ASSERTION(debugNewParent == aParentFrame, "Incorrect parent");
    1:   NS_ASSERTION(debugAfterFrame == aAfterFrame, "Incorrect after frame");
    1: #endif
    1: 
    1:   nsFrameManager* frameManager = aState.mFrameManager;
    1:   if (aAfterFrame) {
 4696:     NS_ASSERTION(!IsFrameSpecial(aParentFrame) ||
 4696:                  IsInlineFrame(aParentFrame) ||
 4696:                  !IsInlineOutside(aAfterFrame),
 4696:                  "Shouldn't have inline :after content on the block in an "
 4696:                  "{ib} split");
    1:     nsFrameList frames(aParentFrame->GetFirstChild(nsnull));
    1: 
    1:     // Insert the frames before the :after pseudo-element.
    1:     return frameManager->InsertFrames(aParentFrame, nsnull,
    1:                                       frames.GetPrevSiblingFor(aAfterFrame),
 4696:                                       aFrameList.childList);
 4696:   }
 4696: 
 4696:   if (IsFrameSpecial(aParentFrame) &&
 4696:       !IsInlineFrame(aParentFrame) &&
 4696:       IsInlineOutside(aFrameList.lastChild)) {
10780:     NS_ASSERTION(!aParentFrame->GetNextContinuation() ||
10780:                  !aParentFrame->GetNextContinuation()->GetFirstChild(nsnull),
10780:                  "Shouldn't happen");
 4696:     
 4696:     // We want to put some of the frames into the following inline frame.
 4696:     nsIFrame* lastBlock = FindLastBlock(aFrameList.childList);
 4696:     nsIFrame* firstTrailingInline;
 4696:     if (lastBlock) {
 4696:       firstTrailingInline = lastBlock->GetNextSibling();
 4696:       lastBlock->SetNextSibling(nsnull);
 4696:       aFrameList.lastChild = lastBlock;
 4696:     } else {
 4696:       firstTrailingInline = aFrameList.childList;
 4696:       aFrameList = nsFrameItems();
 4696:     }
 4696: 
 4696:     NS_ASSERTION(firstTrailingInline, "How did that happen?");
 4696:     nsIFrame* parentFrame = aParentFrame;
 4696: 
 5327:     // As we go up the tree creating trailing inlines, we have to move floats
 5327:     // up to ancestor blocks.  This means that at any given time we'll be
 5327:     // working with two frame constructor states, and aState is one of the two
 5327:     // only at the first step.  Create some space to do this so we don't have
 5327:     // to allocate as we go.
 5327:     char stateBuf[2 * sizeof(nsFrameConstructorState)];
 5327:     nsFrameConstructorState* sourceState = &aState;
 5327:     nsFrameConstructorState* targetState =
 5327:       reinterpret_cast<nsFrameConstructorState*>(stateBuf);
 5327: 
 4696:     // Now we loop, because it might be the case that the parent of our special
 4696:     // block is another special block, and that we're at the very end of it,
 4696:     // and in that case if we create a new special inline we'll have to create
 4696:     // a parent for it too.
 4696:     do {
 4696:       NS_ASSERTION(IsFrameSpecial(parentFrame) && !IsInlineFrame(parentFrame),
 4696:                    "Shouldn't be in this code");
 4696:       nsIFrame* inlineSibling = GetSpecialSibling(parentFrame);
 4696:       PRBool isPositioned = PR_FALSE;
 4696:       nsIContent* content = nsnull;
 4696:       nsStyleContext* styleContext = nsnull;
 4696:       if (!inlineSibling) {
19125:         nsIFrame* firstInline =
19125:           GetIBSplitSpecialPrevSiblingForAnonymousBlock(parentFrame);
 4696:         NS_ASSERTION(firstInline, "How did that happen?");
 4696: 
 4696:         content = firstInline->GetContent();
 4696:         styleContext = firstInline->GetStyleContext();
 4696:         isPositioned = (styleContext->GetStyleDisplay()->mPosition ==
 4696:                         NS_STYLE_POSITION_RELATIVE);
 4696:       }
 4696: 
 4696:       nsIFrame* stateParent =
 4696:         inlineSibling ? inlineSibling->GetParent() : parentFrame->GetParent();
 4696: 
 5327:       new (targetState)
 5327:         nsFrameConstructorState(mPresShell, mFixedContainingBlock,
 4696:                                 GetAbsoluteContainingBlock(stateParent),
 4696:                                 GetFloatContainingBlock(stateParent));
 4696:       nsIFrame* newInlineSibling =
 5327:         MoveFramesToEndOfIBSplit(*sourceState, inlineSibling,
 4696:                                  isPositioned, content,
 4696:                                  styleContext, firstTrailingInline,
 5327:                                  parentFrame, targetState);
 5327: 
 5327:       if (sourceState == &aState) {
 5327:         NS_ASSERTION(targetState ==
 5327:                        reinterpret_cast<nsFrameConstructorState*>(stateBuf),
 5327:                      "Bogus target state?");
 5327:         // Set sourceState to the value targetState should have next.
 5327:         sourceState = targetState + 1;
 5327:       } else {
 5327:         // Go ahead and process whatever insertions we didn't move out
 5327:         sourceState->~nsFrameConstructorState();
 5327:       }
 5327: 
 5327:       // We're done with the source state.  The target becomes the new source,
 5327:       // and we point the target pointer to the available memory.
 5327:       nsFrameConstructorState* temp = sourceState;
 5327:       sourceState = targetState;
 5327:       targetState = temp;;
 4696: 
 4696:       if (inlineSibling) {
 4696:         // we're all set -- we just moved things to a frame that was already
 4696:         // there.
 4696:         NS_ASSERTION(newInlineSibling == inlineSibling, "What happened?");
 4696:         break;
 4696:       }
 4696: 
 5322:       SetFrameIsSpecial(parentFrame->GetFirstContinuation(), newInlineSibling);
 4696:       
 4696:       // We had to create a frame for this new inline sibling.  Figure out
 4696:       // the right parentage for it.
 4696:       // XXXbz add a test for this?
 4696:       nsIFrame* newParentFrame = parentFrame->GetParent();
 4696:       NS_ASSERTION(!IsInlineFrame(newParentFrame),
 4696:                    "The block in an {ib} split shouldn't be living inside "
 4696:                    "an inline");
 4696:       if (!IsFrameSpecial(newParentFrame) ||
 4696:           newParentFrame->GetNextContinuation() ||
 4696:           parentFrame->GetNextSibling()) {
 4696:         // Just insert after parentFrame
 4696:         frameManager->InsertFrames(newParentFrame, nsnull, parentFrame,
 4696:                                    newInlineSibling);
 4696:         firstTrailingInline = nsnull;
 4696:       } else {
 4696:         // recurse up the tree
 4696:         parentFrame = newParentFrame;
 4696:         firstTrailingInline = newInlineSibling;
 4696:       }      
 4696:     } while (firstTrailingInline);
 5327: 
 5327:     // Process the float insertions on the last target state we had.
 5327:     sourceState->~nsFrameConstructorState();
 4696:   }
 4696:     
 4696:   if (!aFrameList.childList) {
 4696:     // It all got eaten by the special inline
 4696:     return NS_OK;
 4696:   }
 4696:   
 4696:   return frameManager->AppendFrames(aParentFrame, nsnull,
 4696:                                     aFrameList.childList);
    1: }
    1: 
 7655: #define UNSET_DISPLAY 255
 7655: 
 7655: nsIFrame*
 7655: nsCSSFrameConstructor::FindPreviousAnonymousSibling(nsIContent*   aContainer,
    1:                                                     nsIContent*   aChild)
    1: {
 7655:   nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(mDocument));
    1:   NS_ASSERTION(xblDoc, "null xblDoc for content element in FindNextAnonymousSibling");
    1:   if (! xblDoc)
    1:     return nsnull;
    1: 
    1:   // Grovel through the anonymous elements looking for aChild. We'll
    1:   // start our search for a previous frame there.
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1:   nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(aContainer));
    1:   xblDoc->GetAnonymousNodes(elt, getter_AddRefs(nodeList));
    1: 
    1:   if (! nodeList)
    1:     return nsnull;
    1: 
    1:   PRUint32 length;
    1:   nodeList->GetLength(&length);
    1: 
    1:   PRInt32 index;
    1:   for (index = PRInt32(length) - 1; index >= 0; --index) {
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     nodeList->Item(PRUint32(index), getter_AddRefs(node));
    1: 
    1:     nsCOMPtr<nsIContent> child = do_QueryInterface(node);
    1:     if (child == aChild)
    1:       break;
    1:   }
    1: 
    1:   // We want the node immediately before aChild. Keep going until we
    1:   // run off the beginning of the nodeList, or we find a frame.
 7655:   PRUint8 childDisplay = UNSET_DISPLAY;
    1:   while (--index >= 0) {
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     nodeList->Item(PRUint32(index), getter_AddRefs(node));
    1: 
    1:     nsCOMPtr<nsIContent> child = do_QueryInterface(node);
    1: 
    1:     // Get its frame. If it doesn't have one, continue on to the
    1:     // anonymous element that preceded it.
 7655:     nsIFrame* prevSibling = FindFrameForContentSibling(child, aChild,
 7655:                                                        childDisplay, PR_TRUE);
    1:     if (prevSibling) {
    1:       // Found a previous sibling, we're done!
    1:       return prevSibling;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: /**
    1:  * Find the frame for the anonymous content immediately following
    1:  * aChild.
    1:  */
 7655: nsIFrame*
 7655: nsCSSFrameConstructor::FindNextAnonymousSibling(nsIContent*   aContainer,
    1:                                                 nsIContent*   aChild)
    1: {
 7655:   nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(mDocument));
    1:   NS_ASSERTION(xblDoc, "null xblDoc for content element in FindNextAnonymousSibling");
    1:   if (! xblDoc)
    1:     return nsnull;
    1: 
    1:   // Grovel through the anonymous elements looking for aChild
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1:   nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(aContainer));
    1:   xblDoc->GetAnonymousNodes(elt, getter_AddRefs(nodeList));
    1: 
    1:   if (! nodeList)
    1:     return nsnull;
    1: 
    1:   PRUint32 length;
    1:   nodeList->GetLength(&length);
    1: 
    1:   PRInt32 index;
    1:   for (index = 0; index < PRInt32(length); ++index) {
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     nodeList->Item(PRUint32(index), getter_AddRefs(node));
    1: 
    1:     nsCOMPtr<nsIContent> child = do_QueryInterface(node);
    1:     if (child == aChild)
    1:       break;
    1:   }
    1: 
    1:   // We want the node immediately after aChild. Keep going until we
    1:   // run off the end of the nodeList, or we find a next sibling.
 7655:   PRUint8 childDisplay = UNSET_DISPLAY;
    1:   while (++index < PRInt32(length)) {
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     nodeList->Item(PRUint32(index), getter_AddRefs(node));
    1: 
    1:     nsCOMPtr<nsIContent> child = do_QueryInterface(node);
    1: 
    1:     // Get its frame
 7655:     nsIFrame* nextSibling = FindFrameForContentSibling(child, aChild,
 7655:                                                        childDisplay, PR_FALSE);
    1:     if (nextSibling) {
    1:       // Found a next sibling, we're done!
    1:       return nextSibling;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // This gets called to see if the frames corresponding to aSiblingDisplay and aDisplay
    1: // should be siblings in the frame tree. Although (1) rows and cols, (2) row groups 
 7655: // and col groups, (3) row groups and captions, (4) legends and content inside fieldsets, (5) popups and other kids of the menu
    1: // are siblings from a content perspective, they are not considered siblings in the 
    1: // frame tree.
    1: PRBool
 7655: nsCSSFrameConstructor::IsValidSibling(nsIFrame*              aSibling,
 7655:                                       nsIContent*            aContent,
    1:                                       PRUint8&               aDisplay)
    1: {
 8009:   nsIFrame* parentFrame = aSibling->GetParent();
 8009:   nsIAtom* parentType = nsnull;
 8009:   nsIAtom* grandparentType = nsnull;
 8009:   if (parentFrame) {
 8009:     parentType = parentFrame->GetType();
 8009:     nsIFrame* grandparentFrame = parentFrame->GetParent();
 8009:     if (grandparentFrame) {
 8009:       grandparentType = grandparentFrame->GetType();
 8009:     }
 8009:   }
 8009:     
 7655:   PRUint8 siblingDisplay = aSibling->GetStyleDisplay()->mDisplay;
 7655:   if ((NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_COLUMN       == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_CAPTION      == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_ROW_GROUP    == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == siblingDisplay) ||
 7655:       nsGkAtoms::menuFrame == parentType) {
    1:     // if we haven't already, construct a style context to find the display type of aContent
    1:     if (UNSET_DISPLAY == aDisplay) {
    1:       nsRefPtr<nsStyleContext> styleContext;
 1502:       nsIFrame* styleParent;
 1502:       PRBool providerIsChild;
 1502:       if (NS_FAILED(aSibling->
 1502:                       GetParentStyleContextFrame(aSibling->PresContext(),
 1502:                                                  &styleParent,
 1502:                                                  &providerIsChild)) ||
 1502:           !styleParent) {
 1502:         NS_NOTREACHED("Shouldn't happen");
 1502:         return PR_FALSE;
 1502:       }
 7655:       styleContext = ResolveStyleContext(styleParent, aContent);
    1:       if (!styleContext) return PR_FALSE;
    1:       const nsStyleDisplay* display = styleContext->GetStyleDisplay();
    1:       aDisplay = display->mDisplay;
    1:     }
 7655:     if (nsGkAtoms::menuFrame == parentType) {
 7655:       return
 7655:         (NS_STYLE_DISPLAY_POPUP == aDisplay) ==
 7655:         (NS_STYLE_DISPLAY_POPUP == siblingDisplay);
 7655:     }
 7655:     switch (siblingDisplay) {
    1:     case NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP:
    1:       return (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == aDisplay);
    1:     case NS_STYLE_DISPLAY_TABLE_COLUMN:
    1:       return (NS_STYLE_DISPLAY_TABLE_COLUMN == aDisplay);
    1:     case NS_STYLE_DISPLAY_TABLE_CAPTION:
    1:       return (NS_STYLE_DISPLAY_TABLE_CAPTION == aDisplay);
    1:     default: // all of the row group types
    1:       return (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == aDisplay) ||
    1:              (NS_STYLE_DISPLAY_TABLE_ROW_GROUP    == aDisplay) ||
    1:              (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == aDisplay) ||
    1:              (NS_STYLE_DISPLAY_TABLE_CAPTION      == aDisplay);
    1:     }
    1:   }
 8009:   else if (nsGkAtoms::fieldSetFrame == parentType ||
 8009:            (nsGkAtoms::fieldSetFrame == grandparentType &&
23176:             nsGkAtoms::blockFrame == parentType)) {
    1:     // Legends can be sibling of legends but not of other content in the fieldset
 1502:     nsIAtom* sibType = aSibling->GetType();
 7655:     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(aContent));
    1: 
    1:     if ((legendContent  && (nsGkAtoms::legendFrame != sibType)) ||
    1:         (!legendContent && (nsGkAtoms::legendFrame == sibType)))
    1:       return PR_FALSE;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
 7655: nsIFrame*
 7655: nsCSSFrameConstructor::FindFrameForContentSibling(nsIContent* aContent,
 7655:                                                   nsIContent* aTargetContent,
 7655:                                                   PRUint8& aTargetContentDisplay,
 7655:                                                   PRBool aPrevSibling)
 7655: {
 7655:   nsIFrame* sibling = mPresShell->GetPrimaryFrameFor(aContent);
 7655:   if (!sibling) {
 7655:     return nsnull;
 7655:   }
 7655: 
 7655:   // If the frame is out-of-flow, GPFF() will have returned the
 7655:   // out-of-flow frame; we want the placeholder.
 7655:   if (sibling->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
 7655:     nsIFrame* placeholderFrame;
 7655:     mPresShell->GetPlaceholderFrameFor(sibling, &placeholderFrame);
 7655:     NS_ASSERTION(placeholderFrame, "no placeholder for out-of-flow frame");
 7655:     sibling = placeholderFrame;
 7655:   }
 7655: 
 8406:   // The frame we have now should never be a continuation
 8406:   NS_ASSERTION(!sibling->GetPrevContinuation(), "How did that happen?");
 7655: 
 7655:   if (aPrevSibling) {
 7655:     // The frame may be a special frame (a split inline frame that
 7655:     // contains a block).  Get the last part of that split.
 7655:     if (IsFrameSpecial(sibling)) {
 7655:       sibling = GetLastSpecialSibling(sibling);
 7655:     }
 7655: 
 7655:     // The frame may have a continuation. If so, we want the last
 7655:     // non-overflow-container continuation as our previous sibling.
10780:     sibling = sibling->GetTailContinuation();
 7655:   }
 7655: 
 7655:   if (aTargetContent &&
 7655:       !IsValidSibling(sibling, aTargetContent, aTargetContentDisplay)) {
 7655:     sibling = nsnull;
 7655:   }
 7655: 
 7655:   return sibling;
 7655: }
 7655: 
    1: /**
    1:  * Find the ``rightmost'' frame for the content immediately preceding
    1:  * aIndexInContainer, following continuations if necessary.
    1:  */
    1: nsIFrame*
    1: nsCSSFrameConstructor::FindPreviousSibling(nsIContent* aContainer,
    1:                                            PRInt32     aIndexInContainer,
 7655:                                            nsIContent* aChild)
    1: {
    1:   NS_ASSERTION(aContainer, "null argument");
    1: 
    1:   ChildIterator first, iter;
    1:   nsresult rv = ChildIterator::Init(aContainer, &first, &iter);
    1:   NS_ENSURE_SUCCESS(rv, nsnull);
    1:   iter.seek(aIndexInContainer);
    1: 
    1:   PRUint8 childDisplay = UNSET_DISPLAY;
    1:   // Note: not all content objects are associated with a frame (e.g., if it's
 7655:   // `display: none') so keep looking until we find a previous frame
    1:   while (iter-- != first) {
 7655:     nsIFrame* prevSibling =
 7655:       FindFrameForContentSibling(nsCOMPtr<nsIContent>(*iter), aChild,
 7655:                                  childDisplay, PR_TRUE);
    1: 
    1:     if (prevSibling) {
    1: #ifdef DEBUG
    1:       nsIFrame* containerFrame = nsnull;
    1:       containerFrame = mPresShell->GetPrimaryFrameFor(aContainer);
    1:       NS_ASSERTION(prevSibling != containerFrame, "Previous Sibling is the Container's frame");
    1: #endif
    1:       // Found a previous sibling, we're done!
    1:       return prevSibling;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: /**
    1:  * Find the frame for the content node immediately following
    1:  * aIndexInContainer.
    1:  */
    1: nsIFrame*
    1: nsCSSFrameConstructor::FindNextSibling(nsIContent* aContainer,
    1:                                        PRInt32     aIndexInContainer,
 7655:                                        nsIContent* aChild)
    1: {
    1:   ChildIterator iter, last;
    1:   nsresult rv = ChildIterator::Init(aContainer, &iter, &last);
    1:   NS_ENSURE_SUCCESS(rv, nsnull);
    1:   iter.seek(aIndexInContainer);
    1: 
    1:   // Catch the case where someone tries to append
    1:   if (iter == last)
    1:     return nsnull;
    1: 
    1:   PRUint8 childDisplay = UNSET_DISPLAY;
    1: 
    1:   while (++iter != last) {
    1:     nsIFrame* nextSibling =
 7655:       FindFrameForContentSibling(nsCOMPtr<nsIContent>(*iter), aChild,
 7655:                                  childDisplay, PR_FALSE);
    1: 
    1:     if (nextSibling) {
    1:       // We found a next sibling, we're done!
    1:       return nextSibling;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // For fieldsets, returns the area frame, if the child is not a legend. 
    1: static nsIFrame*
    1: GetAdjustedParentFrame(nsIFrame*       aParentFrame,
    1:                        nsIAtom*        aParentFrameType,
    1:                        nsIContent*     aParentContent,
    1:                        PRInt32         aChildIndex)
    1: {
 4194:   NS_PRECONDITION(nsGkAtoms::tableOuterFrame != aParentFrameType,
 4194:                   "Shouldn't be happening!");
 4194:   
    1:   nsIContent *childContent = aParentContent->GetChildAt(aChildIndex);
    1:   nsIFrame* newParent = nsnull;
    1: 
 4194:   if (nsGkAtoms::fieldSetFrame == aParentFrameType) {
    1:     // If the parent is a fieldSet, use the fieldSet's area frame as the
    1:     // parent unless the new content is a legend. 
    1:     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(childContent));
    1:     if (!legendContent) {
23176:       newParent = GetFieldSetBlockFrame(aParentFrame);
    1:     }
    1:   }
    1:   return (newParent) ? newParent : aParentFrame;
    1: }
    1: 
    1: static void
    1: InvalidateCanvasIfNeeded(nsIFrame* aFrame);
    1: 
    1: static PRBool
    1: IsSpecialFramesetChild(nsIContent* aContent)
    1: {
    1:   // IMPORTANT: This must match the conditions in nsHTMLFramesetFrame::Init.
    1:   return aContent->IsNodeOfType(nsINode::eHTML) &&
    1:     (aContent->Tag() == nsGkAtoms::frameset ||
    1:      aContent->Tag() == nsGkAtoms::frame);
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ContentAppended(nsIContent*     aContainer,
    1:                                        PRInt32         aNewIndexInContainer)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while creating frames");
 6518: 
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ContentAppended container=%p index=%d\n",
 3233:            static_cast<void*>(aContainer), aNewIndexInContainer);
    1:     if (gReallyNoisyContentUpdates && aContainer) {
    1:       aContainer->List(stdout, 0);
    1:     }
    1:   }
    1: #endif
    1: 
    1: #ifdef MOZ_XUL
    1:   if (aContainer) {
    1:     PRInt32 namespaceID;
    1:     nsIAtom* tag =
    1:       mDocument->BindingManager()->ResolveTag(aContainer, &namespaceID);
    1: 
    1:     // Just ignore tree tags, anyway we don't create any frames for them.
    1:     if (tag == nsGkAtoms::treechildren ||
    1:         tag == nsGkAtoms::treeitem ||
23941:         tag == nsGkAtoms::treerow)
    1:       return NS_OK;
    1: 
    1:   }
    1: #endif // MOZ_XUL
    1: 
    1:   // Get the frame associated with the content
    1:   nsIFrame* parentFrame = GetFrameFor(aContainer);
    1:   if (! parentFrame)
    1:     return NS_OK;
    1: 
    1:   // See if we have an XBL insertion point. If so, then that's our
    1:   // real parent frame; if not, then the frame hasn't been built yet
    1:   // and we just bail.
    1:   //
    1:   nsIFrame* insertionPoint;
    1:   PRBool multiple = PR_FALSE;
    1:   GetInsertionPoint(parentFrame, nsnull, &insertionPoint, &multiple);
    1:   if (! insertionPoint)
    1:     return NS_OK; // Don't build the frames.
    1: 
    1:   PRBool hasInsertion = PR_FALSE;
    1:   if (!multiple) {
    1:     nsIDocument* document = nsnull; 
    1:     nsIContent *firstAppendedChild =
    1:       aContainer->GetChildAt(aNewIndexInContainer);
    1:     if (firstAppendedChild) {
    1:       document = firstAppendedChild->GetDocument();
    1:     }
    1:     if (document &&
    1:         document->BindingManager()->GetInsertionParent(firstAppendedChild)) {
    1:       hasInsertion = PR_TRUE;
    1:     }
    1:   }
    1:   
    1:   if (multiple || hasInsertion) {
    1:     // We have an insertion point.  There are some additional tests we need to do
    1:     // in order to ensure that an append is a safe operation.
    1:     PRUint32 childCount = 0;
    1:       
    1:     if (!multiple) {
    1:       // We may need to make multiple ContentInserted calls instead.  A
    1:       // reasonable heuristic to employ (in order to maintain good performance)
    1:       // is to find out if the insertion point's content node contains any
    1:       // explicit children.  If it does not, then it is highly likely that 
    1:       // an append is occurring.  (Note it is not definite, and there are insane
    1:       // cases we will not deal with by employing this heuristic, but it beats
    1:       // always falling back to multiple ContentInserted calls).
    1:       //
    1:       // In the multiple insertion point case, we know we're going to need to do
    1:       // multiple ContentInserted calls anyway.
    1:       childCount = insertionPoint->GetContent()->GetChildCount();
    1:     }
    1: 
    1:     if (multiple || childCount > 0) {
    1:       // Now comes the fun part.  For each appended child, we must obtain its
    1:       // insertion point and find its exact position within that insertion point.
    1:       // We then make a ContentInserted call with the correct computed index.
    1:       nsIContent* insertionContent = insertionPoint->GetContent();
    1:       
    1:       PRUint32 containerCount = aContainer->GetChildCount();
    1:       for (PRUint32 i = aNewIndexInContainer; i < containerCount; i++) {
    1:         nsIContent *child = aContainer->GetChildAt(i);
    1:         if (multiple) {
    1:           // Filters are in effect, so the insertion point needs to be refetched for
    1:           // each child.
    1:           GetInsertionPoint(parentFrame, child, &insertionPoint);
    1:           if (!insertionPoint) {
    1:             // This content node doesn't have an insertion point, so we just
    1:             // skip over it
    1:             continue;
    1:           }
    1:           insertionContent = insertionPoint->GetContent();
    1:         }
    1: 
    1:         // Construct an iterator to locate this child at its correct index.
    1:         ChildIterator iter, last;
    1:         for (ChildIterator::Init(insertionContent, &iter, &last);
    1:          iter != last;
    1:          ++iter) {
    1:           LAYOUT_PHASE_TEMP_EXIT();
    1:           nsIContent* item = nsCOMPtr<nsIContent>(*iter);
    1:           if (item == child)
    1:             // Call ContentInserted with this index.
    1:             ContentInserted(aContainer, child,
17132:                             iter.position(), mTempFrameTreeState);
    1:           LAYOUT_PHASE_TEMP_REENTER();
    1:         }
    1:       }
    1: 
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   parentFrame = insertionPoint;
    1: 
    1:   if (parentFrame->GetType() == nsGkAtoms::frameSetFrame) {
    1:     // Check whether we have any kids we care about.
    1:     PRUint32 count = aContainer->GetChildCount();
    1:     for (PRUint32 i = aNewIndexInContainer; i < count; ++i) {
    1:       if (IsSpecialFramesetChild(aContainer->GetChildAt(i))) {
    1:         // Just reframe the parent, since framesets are weird like that.
    1:         return RecreateFramesForContent(parentFrame->GetContent());
    1:       }
    1:     }
    1:   }
    1:   
    1:   if (parentFrame->IsLeaf()) {
    1:     // Nothing to do here; we shouldn't be constructing kids of leaves
    1:     return NS_OK;
    1:   }
    1:   
 6862: #ifdef MOZ_MATHML
 6862:   if (parentFrame->IsFrameOfType(nsIFrame::eMathML))
 6862:     return RecreateFramesForContent(parentFrame->GetContent());
 6862: #endif
 6862: 
 4696:   // If the frame we are manipulating is a ``special'' frame (that is, one
 4696:   // that's been created as a result of a block-in-inline situation) then we
 4696:   // need to append to the last special sibling, not to the frame itself.
    1:   if (IsFrameSpecial(parentFrame)) {
    1: #ifdef DEBUG
    1:     if (gNoisyContentUpdates) {
    1:       printf("nsCSSFrameConstructor::ContentAppended: parentFrame=");
    1:       nsFrame::ListTag(stdout, parentFrame);
    1:       printf(" is special\n");
    1:     }
    1: #endif
    1: 
    1:     // Since we're appending, we'll walk to the last anonymous frame
    1:     // that was created for the broken inline frame.
 4696:     parentFrame = GetLastSpecialSibling(parentFrame);
    1:   }
    1: 
10780:   // Get continuation that parents the last child
10780:   parentFrame = nsLayoutUtils::GetLastContinuationWithChild(parentFrame);
    1: 
    1:   nsIAtom* frameType = parentFrame->GetType();
 4194:   // Deal with fieldsets
    1:   parentFrame = ::GetAdjustedParentFrame(parentFrame, frameType,
    1:                                          aContainer, aNewIndexInContainer);
    1: 
    1:   // Deal with possible :after generated content on the parent
    1:   nsIFrame* parentAfterFrame;
    1:   parentFrame =
    1:     ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
    1:                                         aContainer, parentFrame,
    1:                                         &parentAfterFrame);
    1:   
    1:   // Create some new frames
    1:   PRUint32                count;
    1:   nsFrameItems            frameItems;
    1:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                 GetAbsoluteContainingBlock(parentFrame),
    1:                                 GetFloatContainingBlock(parentFrame));
    1: 
    1:   // See if the containing block has :first-letter style applied.
    1:   PRBool haveFirstLetterStyle = PR_FALSE, haveFirstLineStyle = PR_FALSE;
    1:   nsIFrame* containingBlock = state.mFloatedItems.containingBlock;
    1:   if (containingBlock) {
 1254:     haveFirstLetterStyle = HasFirstLetterStyle(containingBlock);
 1243:     haveFirstLineStyle =
 1254:       ShouldHaveFirstLineStyle(containingBlock->GetContent(),
 1243:                                containingBlock->GetStyleContext());
    1:   }
    1: 
    1:   if (haveFirstLetterStyle) {
    1:     // Before we get going, remove the current letter frames
    1:     RemoveLetterFrames(state.mPresContext, state.mPresShell,
    1:                        state.mFrameManager, containingBlock);
    1:   }
    1: 
    1:   // if the container is a table and a caption was appended, it needs to be put in
    1:   // the outer table frame's additional child list. 
    1:   nsFrameItems captionItems;
    1: 
    1:   // The last frame that we added to the list.
    1:   nsIFrame* oldNewFrame = nsnull;
    1: 
    1:   PRUint32 i;
    1:   count = aContainer->GetChildCount();
    1:   for (i = aNewIndexInContainer; i < count; i++) {
    1:     nsIFrame* newFrame = nsnull;
    1:     nsIContent *childContent = aContainer->GetChildAt(i);
 4368: 
    1:     ConstructFrame(state, childContent, parentFrame, frameItems);
    1:     newFrame = frameItems.lastChild;
    1: 
    1:     if (newFrame && newFrame != oldNewFrame) {
    1:       InvalidateCanvasIfNeeded(newFrame);
    1:       oldNewFrame = newFrame;
    1:     }
    1:   }
    1: 
 4368:   if (nsGkAtoms::tableFrame == frameType) {
 4368:     // Pull out the captions.  Note that we don't want to do that as we go,
 4368:     // because processing a single caption can add a whole bunch of things to
 4368:     // the frame items due to pseudoframe processing.  So we'd have to pull
 4368:     // captions from a list anyway; might as well do that here.
 4368:     PullOutCaptionFrames(frameItems, captionItems);
 4368:   }
 4368:   
 4368: 
    1:   // process the current pseudo frame state
    1:   if (!state.mPseudoFrames.IsEmpty()) {
    1:     ProcessPseudoFrames(state, frameItems);
    1:   }
    1: 
    1:   if (haveFirstLineStyle && parentFrame == containingBlock) {
    1:     // It's possible that some of the new frames go into a
    1:     // first-line frame. Look at them and see...
    1:     AppendFirstLineFrames(state, containingBlock->GetContent(),
    1:                           containingBlock, frameItems); 
    1:   }
    1: 
    1:   nsresult result = NS_OK;
    1: 
    1:   // Notify the parent frame passing it the list of new frames
 4696:   if (NS_SUCCEEDED(result) &&
 4696:       (frameItems.childList || captionItems.childList)) {
    1:     // Perform special check for diddling around with the frames in
    1:     // a special inline frame.
    1: 
16976:     // If we're appending before :after content, then we're not really
16976:     // appending, so let WipeContainingBlock know that.
 4696:     if (WipeContainingBlock(state, containingBlock, parentFrame, frameItems,
16976:                             !parentAfterFrame, nsnull)) {
    1:       return NS_OK;
    1:     }
    1: 
    1:     // Append the flowed frames to the principal child list, tables need special treatment
    1:     if (nsGkAtoms::tableFrame == frameType) {
    1:       if (captionItems.childList) { // append the caption to the outer table
    1:         nsIFrame* outerTable = parentFrame->GetParent();
    1:         if (outerTable) { 
    1:           state.mFrameManager->AppendFrames(outerTable,
    1:                                             nsGkAtoms::captionList,
    1:                                             captionItems.childList);
    1:         }
    1:       }
    1:       if (frameItems.childList) { // append children of the inner table
 4696:         AppendFrames(state, aContainer, parentFrame, frameItems,
    1:                      parentAfterFrame);
    1:       }
    1:     }
    1:     else {
 4696:       AppendFrames(state, aContainer, parentFrame, frameItems,
    1:                    parentAfterFrame);
    1:     }
    1:   }
    1: 
    1:   // Recover first-letter frames
    1:   if (haveFirstLetterStyle) {
23461:     RecoverLetterFrames(containingBlock);
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   if (gReallyNoisyContentUpdates) {
23554:     nsIFrameDebug* fdbg = do_QueryFrame(parentFrame);
    1:     if (fdbg) {
    1:       printf("nsCSSFrameConstructor::ContentAppended: resulting frame model:\n");
    1:       fdbg->List(stdout, 0);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef MOZ_XUL
    1: 
    1: enum content_operation
    1: {
    1:     CONTENT_INSERTED,
    1:     CONTENT_REMOVED
    1: };
    1: 
    1: // Helper function to lookup the listbox body frame and send a notification
    1: // for insertion or removal of content
    1: static
    1: PRBool NotifyListBoxBody(nsPresContext*    aPresContext,
    1:                          nsIContent*        aContainer,
    1:                          nsIContent*        aChild,
    1:                          PRInt32            aIndexInContainer,
    1:                          nsIDocument*       aDocument,                         
    1:                          nsIFrame*          aChildFrame,
    1:                          content_operation  aOperation)
    1: {
    1:   if (!aContainer)
    1:     return PR_FALSE;
    1: 
    1:   if (aContainer->IsNodeOfType(nsINode::eXUL) &&
    1:       aChild->IsNodeOfType(nsINode::eXUL) &&
    1:       aContainer->Tag() == nsGkAtoms::listbox &&
    1:       aChild->Tag() == nsGkAtoms::listitem) {
    1:     nsCOMPtr<nsIDOMXULElement> xulElement = do_QueryInterface(aContainer);
    1:     nsCOMPtr<nsIBoxObject> boxObject;
    1:     xulElement->GetBoxObject(getter_AddRefs(boxObject));
    1:     nsCOMPtr<nsPIListBoxObject> listBoxObject = do_QueryInterface(boxObject);
    1:     if (listBoxObject) {
20990:       nsListBoxBodyFrame* listBoxBodyFrame = listBoxObject->GetListBoxBody(PR_FALSE);
20990:       if (listBoxBodyFrame) {
    1:         if (aOperation == CONTENT_REMOVED) {
    1:           // Except if we have an aChildFrame and its parent is not the right
    1:           // thing, then we don't do this.  Pseudo frames are so much fun....
    1:           if (!aChildFrame || aChildFrame->GetParent() == listBoxBodyFrame) {
    1:             listBoxBodyFrame->OnContentRemoved(aPresContext, aChildFrame,
    1:                                                aIndexInContainer);
    1:             return PR_TRUE;
    1:           }
    1:         } else {
    1:           listBoxBodyFrame->OnContentInserted(aPresContext, aChild);
    1:           return PR_TRUE;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: #endif // MOZ_XUL
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ContentInserted(nsIContent*            aContainer,
    1:                                        nsIContent*            aChild,
    1:                                        PRInt32                aIndexInContainer,
 4696:                                        nsILayoutHistoryState* aFrameState)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while creating frames");
 6518: 
    1:   // XXXldb Do we need to re-resolve style to handle the CSS2 + combinator and
    1:   // the :empty pseudo-class?
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ContentInserted container=%p child=%p index=%d\n",
 3233:            static_cast<void*>(aContainer),
 3233:            static_cast<void*>(aChild),
    1:            aIndexInContainer);
    1:     if (gReallyNoisyContentUpdates) {
    1:       (aContainer ? aContainer : aChild)->List(stdout, 0);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1: #ifdef MOZ_XUL
    1:   if (NotifyListBoxBody(mPresShell->GetPresContext(), aContainer, aChild,
    1:                         aIndexInContainer, 
23941:                         mDocument, nsnull, CONTENT_INSERTED))
    1:     return NS_OK;
    1: #endif // MOZ_XUL
    1:   
    1:   // If we have a null parent, then this must be the document element
    1:   // being inserted
    1:   if (! aContainer) {
    1:     nsIContent *docElement = mDocument->GetRootContent();
    1: 
    1:     if (aChild == docElement) {
    1:       NS_PRECONDITION(nsnull == mInitialContainingBlock, "initial containing block already created");
    1:       
    1:       if (!mDocElementContainingBlock)
    1:         return NS_OK; // We get into this situation when an XBL binding is asynchronously
    1:                       // applied to the root tag (e.g., <window> in XUL).  It's ok.  We can
    1:                       // just bail here because the root will really be built later during
    1:                       // InitialReflow.
    1: 
    1:       // Create frames for the document element and its child elements
    1:       nsIFrame*               docElementFrame;
    1:       nsFrameConstructorState state(mPresShell, mFixedContainingBlock, nsnull,
    1:                                     nsnull, aFrameState);
 3026:       rv = ConstructDocElementFrame(state,
    1:                                     docElement, 
    1:                                     mDocElementContainingBlock,
    1:                                     &docElementFrame);
    1:     
 3026:       if (NS_SUCCEEDED(rv) && docElementFrame) {
    1:         if (mDocElementContainingBlock->GetStateBits() & NS_FRAME_FIRST_REFLOW) {
    1:           // Set the initial child list for the parent and wait on the initial
    1:           // reflow.
    1:           mDocElementContainingBlock->SetInitialChildList(nsnull, 
    1:                                                           docElementFrame);
    1:         } else {
    1:           // Whoops, we've already received our initial reflow! Insert the doc.
    1:           // element as a child so it reflows (note that containing block is
    1:           // empty, so we can simply append).
    1:           NS_ASSERTION(mDocElementContainingBlock->GetFirstChild(nsnull) == nsnull,
    1:                        "Unexpected child of document element containing block");
    1:           mDocElementContainingBlock->AppendFrames(nsnull, docElementFrame);
    1:         }
    1:         InvalidateCanvasIfNeeded(docElementFrame);
    1: #ifdef DEBUG
 3026:         if (gReallyNoisyContentUpdates) {
23554:           nsIFrameDebug* fdbg = do_QueryFrame(docElementFrame);
    1:           if (fdbg) {
    1:             printf("nsCSSFrameConstructor::ContentInserted: resulting frame model:\n");
    1:             fdbg->List(stdout, 0);
    1:           }
    1:         }
    1: #endif
    1:       }
 3026:     }
    1: 
    1:     // otherwise this is not a child of the root element, and we
    1:     // won't let it have a frame.
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Otherwise, we've got parent content. Find its frame.
    1:   nsIFrame* parentFrame = GetFrameFor(aContainer);
    1:   if (! parentFrame)
    1:     return NS_OK; // XXXwaterson will this break selects? (See ``Here
    1:     // we have been notified...'' below.)
    1: 
    1:   // See if we have an XBL insertion point. If so, then that's our
    1:   // real parent frame; if not, then the frame hasn't been built yet
    1:   // and we just bail.
    1:   nsIFrame* insertionPoint;
    1:   GetInsertionPoint(parentFrame, aChild, &insertionPoint);
    1:   if (! insertionPoint)
    1:     return NS_OK; // Don't build the frames.
    1: 
    1:   parentFrame = insertionPoint;
    1: 
    1:   // Find the frame that precedes the insertion point. Walk backwards
    1:   // from the parent frame to get the parent content, because if an
    1:   // XBL insertion point is involved, we'll need to use _that_ to find
    1:   // the preceding frame.
    1:   nsIContent* container = parentFrame->GetContent();
    1: 
    1:   // XXX if the insertionPoint was different from the original
    1:   // parentFrame, then aIndexInContainer is most likely completely
    1:   // wrong. What we need to do here is remember the original index,
    1:   // then as we insert, search the child list where we're about to put
    1:   // the new frame to make sure that it appears after any siblings
    1:   // with a lower index, and before any siblings with a higher
    1:   // index. Same with FindNextSibling(), below.
    1:   nsIFrame* prevSibling = (aIndexInContainer >= 0)
 7655:     ? FindPreviousSibling(container, aIndexInContainer, aChild)
 7655:     : FindPreviousAnonymousSibling(aContainer, aChild);
    1: 
    1:   PRBool    isAppend = PR_FALSE;
    1:   nsIFrame* appendAfterFrame;  // This is only looked at when isAppend is true
    1:   nsIFrame* nextSibling = nsnull;
    1:     
    1:   // If there is no previous sibling, then find the frame that follows
    1:   if (! prevSibling) {
    1:     nextSibling = (aIndexInContainer >= 0)
 7655:       ? FindNextSibling(container, aIndexInContainer, aChild)
 7655:       : FindNextAnonymousSibling(aContainer, aChild);
    1:   }
    1: 
    1:   // Now, find the geometric parent so that we can handle
    1:   // continuations properly. Use the prev sibling if we have it;
    1:   // otherwise use the next sibling.
    1:   if (prevSibling) {
 4194:     parentFrame = prevSibling->GetParent()->GetContentInsertionFrame();
    1:   }
    1:   else if (nextSibling) {
 4194:     parentFrame = nextSibling->GetParent()->GetContentInsertionFrame();
    1:   }
    1:   else {
    1:     // No previous or next sibling, so treat this like an appended frame.
    1:     isAppend = PR_TRUE;
23861:     // Get continuation that parents the last child
23861:     parentFrame = nsLayoutUtils::GetLastContinuationWithChild(parentFrame);
 4194:     // Deal with fieldsets
    1:     parentFrame = ::GetAdjustedParentFrame(parentFrame, parentFrame->GetType(),
    1:                                            aContainer, aIndexInContainer);
    1:     parentFrame =
    1:       ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
    1:                                           aContainer, parentFrame,
    1:                                           &appendAfterFrame);
    1:   }
    1: 
    1:   if (parentFrame->GetType() == nsGkAtoms::frameSetFrame &&
    1:       IsSpecialFramesetChild(aChild)) {
    1:     // Just reframe the parent, since framesets are weird like that.
    1:     return RecreateFramesForContent(parentFrame->GetContent());
    1:   }
    1:   
    1:   // Don't construct kids of leaves
    1:   if (parentFrame->IsLeaf()) {
    1:     return NS_OK;
    1:   }
    1: 
 6862: #ifdef MOZ_MATHML
 6862:   if (parentFrame->IsFrameOfType(nsIFrame::eMathML))
 6862:     return RecreateFramesForContent(parentFrame->GetContent());
 6862: #endif
 6862: 
    1:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                 GetAbsoluteContainingBlock(parentFrame),
    1:                                 GetFloatContainingBlock(parentFrame),
    1:                                 aFrameState);
    1: 
    1: 
    1:   // Recover state for the containing block - we need to know if
    1:   // it has :first-letter or :first-line style applied to it. The
    1:   // reason we care is that the internal structure in these cases
    1:   // is not the normal structure and requires custom updating
    1:   // logic.
    1:   nsIFrame* containingBlock = state.mFloatedItems.containingBlock;
    1:   PRBool haveFirstLetterStyle = PR_FALSE;
    1:   PRBool haveFirstLineStyle = PR_FALSE;
    1: 
    1:   // In order to shave off some cycles, we only dig up the
    1:   // containing block haveFirst* flags if the parent frame where
    1:   // the insertion/append is occurring is an inline or block
    1:   // container. For other types of containers this isn't relevant.
    1:   const nsStyleDisplay* parentDisplay = parentFrame->GetStyleDisplay();
    1: 
    1:   // Examine the parentFrame where the insertion is taking
    1:   // place. If it's a certain kind of container then some special
    1:   // processing is done.
    1:   if ((NS_STYLE_DISPLAY_BLOCK == parentDisplay->mDisplay) ||
    1:       (NS_STYLE_DISPLAY_LIST_ITEM == parentDisplay->mDisplay) ||
    1:       (NS_STYLE_DISPLAY_INLINE == parentDisplay->mDisplay) ||
    1:       (NS_STYLE_DISPLAY_INLINE_BLOCK == parentDisplay->mDisplay)) {
    1:     // Recover the special style flags for the containing block
    1:     if (containingBlock) {
 1254:       haveFirstLetterStyle = HasFirstLetterStyle(containingBlock);
 1243:       haveFirstLineStyle =
 1254:         ShouldHaveFirstLineStyle(containingBlock->GetContent(),
 1243:                                  containingBlock->GetStyleContext());
    1:     }
    1: 
    1:     if (haveFirstLetterStyle) {
    1:       // Get the correct parentFrame and prevSibling - if a
    1:       // letter-frame is present, use its parent.
    1:       if (parentFrame->GetType() == nsGkAtoms::letterFrame) {
    1:         parentFrame = parentFrame->GetParent();
    1:         container = parentFrame->GetContent();
    1:       }
    1: 
    1:       // Remove the old letter frames before doing the insertion
    1:       RemoveLetterFrames(state.mPresContext, mPresShell,
    1:                          state.mFrameManager,
    1:                          state.mFloatedItems.containingBlock);
    1: 
    1:       // Removing the letterframes messes around with the frame tree, removing
    1:       // and creating frames.  We need to reget our prevsibling.
    1:       // See XXX comment the first time we do this in this method....
    1:       prevSibling = (aIndexInContainer >= 0)
 7655:         ? FindPreviousSibling(container, aIndexInContainer, aChild)
 7655:         : FindPreviousAnonymousSibling(aContainer, aChild);
    1: 
    1:       // If there is no previous sibling, then find the frame that follows
    1:       if (! prevSibling) {
    1:         nextSibling = (aIndexInContainer >= 0)
 7655:           ? FindNextSibling(container, aIndexInContainer, aChild)
 7655:           : FindNextAnonymousSibling(aContainer, aChild);
    1:       }
    1:     }
    1:   }
    1: 
 8154:   if (!prevSibling) {
 8154:     // We're inserting the new frame as the first child. See if the
 8154:     // parent has a :before pseudo-element
 8154:     nsIFrame* firstChild = parentFrame->GetFirstChild(nsnull);
 8154: 
 8154:     if (firstChild &&
 8154:         nsLayoutUtils::IsGeneratedContentFor(aContainer, firstChild,
 8154:                                              nsCSSPseudoElements::before)) {
 8154:       // Insert the new frames after the last continuation of the :before
10780:       prevSibling = firstChild->GetTailContinuation();
 8154:       parentFrame = prevSibling->GetParent();
 8154:       // We perhaps could leave this true and take the AppendFrames path
 8154:       // below, but we'd have to update appendAfterFrame and it seems safer
 8154:       // to force all insert-after-:before cases to take these to take the
 8154:       // InsertFrames path
 8154:       isAppend = PR_FALSE;
 8154:     }
 8154:   }
 8154: 
    1:   // if the container is a table and a caption will be appended, it needs to be
    1:   // put in the outer table frame's additional child list.
    1:   
    1:   nsFrameItems frameItems, captionItems;
    1: 
    1:   ConstructFrame(state, aChild, parentFrame, frameItems);
    1:   if (frameItems.childList) {
    1:     InvalidateCanvasIfNeeded(frameItems.childList);
    1:     
    1:     if (nsGkAtoms::tableCaptionFrame == frameItems.childList->GetType()) {
    1:       NS_ASSERTION(frameItems.childList == frameItems.lastChild ,
    1:                    "adding a non caption frame to the caption childlist?");
    1:       captionItems.AddChild(frameItems.childList);
    1:       frameItems = nsFrameItems();
    1:     }
    1:   }
    1: 
    1:   // process the current pseudo frame state
    1:   if (!state.mPseudoFrames.IsEmpty())
    1:     ProcessPseudoFrames(state, frameItems);
    1: 
 4194:   // If the parent of our current prevSibling is different from the frame we'll
 4194:   // actually use as the parent, then the calculated insertion point is now
 4194:   // invalid and as it is unknown where to insert correctly we append instead
 4194:   // (bug 341858).
 4194:   if (prevSibling && frameItems.childList &&
 4194:       frameItems.childList->GetParent() != prevSibling->GetParent()) {
    1:     prevSibling = nsnull;
    1:     isAppend = PR_TRUE;
    1:     parentFrame =
    1:       ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
    1:                                           aContainer,
    1:                                           frameItems.childList->GetParent(),
    1:                                           &appendAfterFrame);
    1:   }
    1: 
    1:   // Perform special check for diddling around with the frames in
    1:   // a special inline frame.
16976: 
16976:   // If we're appending before :after content, then we're not really
16976:   // appending, so let WipeContainingBlock know that.
 4696:   if (WipeContainingBlock(state, containingBlock, parentFrame, frameItems,
16976:                           isAppend && !appendAfterFrame, prevSibling))
    1:     return NS_OK;
    1: 
    1:   if (haveFirstLineStyle && parentFrame == containingBlock) {
    1:     // It's possible that the new frame goes into a first-line
    1:     // frame. Look at it and see...
    1:     if (isAppend) {
    1:       // Use append logic when appending
    1:       AppendFirstLineFrames(state, containingBlock->GetContent(),
    1:                             containingBlock, frameItems); 
    1:     }
    1:     else {
    1:       // Use more complicated insert logic when inserting
    1:       InsertFirstLineFrames(state, aContainer, containingBlock, &parentFrame,
    1:                             prevSibling, frameItems);
    1:     }
    1:   }
    1:       
 4696:   nsIFrame* const newFrame = frameItems.childList;
    1:   if (NS_SUCCEEDED(rv) && newFrame) {
    1:     NS_ASSERTION(!captionItems.childList, "leaking caption frames");
 3663:     // Notify the parent frame
 3663:     if (isAppend) {
 4696:       AppendFrames(state, aContainer, parentFrame, frameItems,
 4696:                    appendAfterFrame);
 3663:     } else {
    1:       state.mFrameManager->InsertFrames(parentFrame,
    1:                                         nsnull, prevSibling, newFrame);
    1:     }
    1:   }
    1:   else {
    1:     // we might have a caption treat it here
    1:     nsIFrame* newCaptionFrame = captionItems.childList;
    1:     if (NS_SUCCEEDED(rv) && newCaptionFrame) {
    1:       nsIFrame* outerTableFrame;
    1:       if (GetCaptionAdjustedParent(parentFrame, newCaptionFrame, &outerTableFrame)) {
 4194:         // If the parent of our current prevSibling is different from the frame
 4194:         // we'll actually use as the parent, then the calculated insertion
 4194:         // point is now invalid (bug 341382).
 4194:         if (prevSibling && prevSibling->GetParent() != outerTableFrame) {
    1:           prevSibling = nsnull;
    1:         }
    1:         // If the parent is not a outer table frame we will try to add frames
    1:         // to a named child list that the parent does not honour and the frames
    1:         // will get lost
    1:         NS_ASSERTION(nsGkAtoms::tableOuterFrame == outerTableFrame->GetType(),
    1:                      "Pseudo frame construction failure, "
    1:                      "a caption can be only a child of a outer table frame");
    1:         if (isAppend) {
    1:           state.mFrameManager->AppendFrames(outerTableFrame,
    1:                                             nsGkAtoms::captionList,
    1:                                             newCaptionFrame);
    1:         }
    1:         else {
    1:           state.mFrameManager->InsertFrames(outerTableFrame,
    1:                                             nsGkAtoms::captionList,
    1:                                             prevSibling, newCaptionFrame);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (haveFirstLetterStyle) {
    1:     // Recover the letter frames for the containing block when
    1:     // it has first-letter style.
23461:     RecoverLetterFrames(state.mFloatedItems.containingBlock);
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   if (gReallyNoisyContentUpdates && parentFrame) {
23554:     nsIFrameDebug* fdbg = do_QueryFrame(parentFrame);
    1:     if (fdbg) {
    1:       printf("nsCSSFrameConstructor::ContentInserted: resulting frame model:\n");
    1:       fdbg->List(stdout, 0);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ReinsertContent(nsIContent* aContainer,
    1:                                        nsIContent* aChild)
    1: {
    1:   PRInt32 ix = aContainer->IndexOf(aChild);
    1:   // XXX For now, do a brute force remove and insert.
    1:   // XXXbz this probably doesn't work so well with anonymous content
    1:   // XXXbz doesn't this need to do the state-saving stuff that
    1:   // RecreateFramesForContent does?
 7681:   PRBool didReconstruct;
 7681:   nsresult res = ContentRemoved(aContainer, aChild, ix, &didReconstruct);
 7681: 
 7681:   if (NS_SUCCEEDED(res) && !didReconstruct) {
 7681:     // If ContentRemoved just reconstructed everything, there is no need to
 7681:     // reinsert the content here
 4696:     res = ContentInserted(aContainer, aChild, ix, nsnull);
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
22483: static void
22483: DoDeletingFrameSubtree(nsFrameManager* aFrameManager,
22483:                        nsVoidArray&    aDestroyQueue,
22483:                        nsIFrame*       aRemovedFrame,
22483:                        nsIFrame*       aFrame);
22483: 
22483: static void
22483: DoDeletingOverflowContainers(nsFrameManager* aFrameManager,
22483:                              nsVoidArray&    aDestroyQueue,
22483:                              nsIFrame*       aRemovedFrame,
22483:                              nsIFrame*       aFrame)
22483: {
22483:   // The invariant that "continuing frames should be found as part of the
22483:   // walk over the top-most frame's continuing frames" does not hold for
22483:   // out-of-flow overflow containers, so we need to walk them too.
22483:   // Note that DoDeletingFrameSubtree() skips the child lists where
22483:   // overflow containers live so we won't process them twice.
22483:   const PRBool orphanSubtree = aRemovedFrame == aFrame;
22483:   for (nsIFrame* next = aFrame->GetNextContinuation();
22483:        next && (next->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER);
22483:        next = next->GetNextContinuation()) {
22483:     DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
22483:                            orphanSubtree ? next : aRemovedFrame,
22483:                            next);
22483:   }
22483: }
22483: 
    1: /**
    1:  * Called when a frame subtree is about to be deleted. Two important
    1:  * things happen:
    1:  *
    1:  * 1. For each frame in the subtree, we remove the mapping from the
    1:  *    content object to its frame
    1:  *
 2454:  * 2. For child frames that have been moved out of the flow, we enqueue
 2454:  *    the out-of-flow frame for deletion *if* the out-of-flow frame's
    1:  *    geometric parent is not in |aRemovedFrame|'s hierarchy (e.g., an
    1:  *    absolutely positioned element that has been promoted to be a direct
    1:  *    descendant of an area frame).
    1:  *
    1:  * Note: this function should only be called by DeletingFrameSubtree()
    1:  *
    1:  * @param   aRemovedFrame this is the frame that was removed from the
    1:  *            content model. As we recurse we need to remember this so we
    1:  *            can check if out-of-flow frames are a descendant of the frame
    1:  *            being removed
    1:  * @param   aFrame the local subtree that is being deleted. This is initially
    1:  *            the same as aRemovedFrame, but as we recurse down the tree
    1:  *            this changes
    1:  */
22483: static void
    1: DoDeletingFrameSubtree(nsFrameManager* aFrameManager,
    1:                        nsVoidArray&    aDestroyQueue,
    1:                        nsIFrame*       aRemovedFrame,
    1:                        nsIFrame*       aFrame)
    1: {
22483: #undef RECURSE
22483: #define RECURSE(top, child)                                                  \
22483:   DoDeletingFrameSubtree(aFrameManager, aDestroyQueue, (top), (child));      \
22483:   DoDeletingOverflowContainers(aFrameManager, aDestroyQueue, (top), (child));
22483: 
    1:   // Remove the mapping from the content object to its frame.
    1:   nsIContent* content = aFrame->GetContent();
    1:   if (content) {
    1:     aFrameManager->RemoveAsPrimaryFrame(content, aFrame);
    1:     aFrameManager->ClearAllUndisplayedContentIn(content);
    1:   }
    1: 
    1:   nsIAtom* childListName = nsnull;
    1:   PRInt32 childListIndex = 0;
    1: 
    1:   do {
    1:     // Walk aFrame's normal flow child frames looking for placeholder frames.
    1:     nsIFrame* childFrame = aFrame->GetFirstChild(childListName);
    1:     for (; childFrame; childFrame = childFrame->GetNextSibling()) {
22483:       NS_ASSERTION(!(childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW),
22483:                    "out-of-flow on wrong child list");
    1:       if (NS_LIKELY(nsGkAtoms::placeholderFrame != childFrame->GetType())) {
22483:         RECURSE(aRemovedFrame, childFrame);
    1:       } else {
    1:         nsIFrame* outOfFlowFrame =
    1:           nsPlaceholderFrame::GetRealFrameForPlaceholder(childFrame);
    1:   
    1:         // Remove the mapping from the out-of-flow frame to its placeholder.
    1:         aFrameManager->UnregisterPlaceholderFrame((nsPlaceholderFrame*)childFrame);
    1:         // Don't SetOutOfFlowFrame(nsnull) here because the float cache depends
    1:         // on it when the float is removed later on, see bug 348688 comment 6.
    1:         
    1:         // Queue the out-of-flow frame to be destroyed only if aRemovedFrame is _not_
    1:         // one of its ancestor frames or if it is a popup frame. 
    1:         // If aRemovedFrame is an ancestor of the out-of-flow frame, then 
    1:         // the out-of-flow frame will be destroyed by aRemovedFrame.
    1:         if (outOfFlowFrame->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_POPUP ||
    1:             !nsLayoutUtils::IsProperAncestorFrame(aRemovedFrame, outOfFlowFrame)) {
    1:           NS_ASSERTION(aDestroyQueue.IndexOf(outOfFlowFrame) == kNotFound,
    1:                        "out-of-flow is already in the destroy queue");
    1:           aDestroyQueue.AppendElement(outOfFlowFrame);
    1:           // Recurse into the out-of-flow, it is now the aRemovedFrame.
22483:           RECURSE(outOfFlowFrame, outOfFlowFrame);
    1:         }
    1:         else {
    1:           // Also recurse into the out-of-flow when it's a descendant of aRemovedFrame
    1:           // since we don't walk those lists, see |childListName| increment below.
22483:           RECURSE(aRemovedFrame, outOfFlowFrame);
    1:         }
    1:       }
    1:     }
    1: 
    1:     // Move to next child list but skip lists with frames we should have
22483:     // a placeholder for or that contains only next-in-flow overflow containers
22483:     // (which we walk explicitly above).
    1:     do {
    1:       childListName = aFrame->GetAdditionalChildListName(childListIndex++);
22483:     } while (IsOutOfFlowList(childListName) ||
22483:              childListName == nsGkAtoms::overflowContainersList ||
22483:              childListName == nsGkAtoms::excessOverflowContainersList);
    1:   } while (childListName);
    1: }
    1: 
    1: /**
    1:  * Called when a frame is about to be deleted. Calls DoDeletingFrameSubtree()
    1:  * for aFrame and each of its continuing frames
    1:  */
    1: static nsresult
    1: DeletingFrameSubtree(nsFrameManager* aFrameManager,
    1:                      nsIFrame*       aFrame)
    1: {
    1:   NS_ENSURE_TRUE(aFrame, NS_OK); // XXXldb Remove this sometime in the future.
    1: 
    1:   // If there's no frame manager it's probably because the pres shell is
    1:   // being destroyed.
    1:   if (NS_UNLIKELY(!aFrameManager)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsAutoVoidArray destroyQueue;
    1: 
    1:   // If it's a "special" block-in-inline frame, then we can't really deal.
    1:   // That really shouldn't be happening.
    1:   NS_ASSERTION(!IsFrameSpecial(aFrame),
    1:                "DeletingFrameSubtree on a special frame.  Prepare to crash.");
    1: 
    1:   do {
    1:     DoDeletingFrameSubtree(aFrameManager, destroyQueue, aFrame, aFrame);
    1: 
    1:     // If it's split, then get the continuing frame. Note that we only do
    1:     // this for the top-most frame being deleted. Don't do it if we're
    1:     // recursing over a subtree, because those continuing frames should be
    1:     // found as part of the walk over the top-most frame's continuing frames.
    1:     // Walking them again will make this an N^2/2 algorithm.
22483:     // The above is true for normal child next-in-flows but not overflow
22483:     // containers which we do walk because they *can* escape the subtree
22483:     // we're deleting.  We skip [excess]overflowContainersList where
22483:     // they live to avoid processing them more than once.
    1:     aFrame = aFrame->GetNextContinuation();
    1:   } while (aFrame);
    1: 
    1:   // Now destroy any out-of-flow frames that have been enqueued for
    1:   // destruction.
    1:   for (PRInt32 i = destroyQueue.Count() - 1; i >= 0; --i) {
 3233:     nsIFrame* outOfFlowFrame = static_cast<nsIFrame*>(destroyQueue[i]);
    1: 
    1:     // Ask the out-of-flow's parent to delete the out-of-flow
    1:     // frame from the right list.
    1:     aFrameManager->RemoveFrame(outOfFlowFrame->GetParent(),
    1:                                GetChildListNameFor(outOfFlowFrame),
    1:                                outOfFlowFrame);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::RemoveMappingsForFrameSubtree(nsIFrame* aRemovedFrame)
    1: {
    1:   if (NS_UNLIKELY(mIsDestroyingFrameTree)) {
    1:     // The frame tree might not be in a consistent state after
    1:     // WillDestroyFrameTree() has been called. Most likely we're destroying
    1:     // the pres shell which means the frame manager takes care of clearing all
    1:     // mappings so there is no need to walk the frame tree here, bug 372576.
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Save the frame tree's state before deleting it
    1:   CaptureStateFor(aRemovedFrame, mTempFrameTreeState);
    1: 
    1:   return ::DeletingFrameSubtree(mPresShell->FrameManager(), aRemovedFrame);
    1: }
    1: 
 4162: static void UnregisterPlaceholderChain(nsFrameManager* frameManager,
 4162:                                        nsPlaceholderFrame* placeholderFrame)
 4162: {
 4162:   // Remove the mapping from the frame to its placeholder
 4162:   nsPlaceholderFrame* curFrame = placeholderFrame;
 4162:   do {
 4162:     frameManager->UnregisterPlaceholderFrame(curFrame);
 6589:     curFrame->SetOutOfFlowFrame(nsnull);
 4162:     curFrame = static_cast<nsPlaceholderFrame*>(curFrame->GetNextContinuation());
 4162:   } while (curFrame);
 4162: }
 4162: 
    1: nsresult
    1: nsCSSFrameConstructor::ContentRemoved(nsIContent* aContainer,
    1:                                       nsIContent* aChild,
    1:                                       PRInt32     aIndexInContainer,
 7681:                                       PRBool*     aDidReconstruct)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while destroying frames");
 6518: 
 7681:   *aDidReconstruct = PR_FALSE;
 7681:   
    1:   // XXXldb Do we need to re-resolve style to handle the CSS2 + combinator and
    1:   // the :empty pseudo-class?
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ContentRemoved container=%p child=%p index=%d\n",
 3233:            static_cast<void*>(aContainer),
 3233:            static_cast<void*>(aChild),
    1:            aIndexInContainer);
    1:     if (gReallyNoisyContentUpdates) {
    1:       aContainer->List(stdout, 0);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   nsFrameManager *frameManager = mPresShell->FrameManager();
    1:   nsPresContext *presContext = mPresShell->GetPresContext();
    1:   nsresult                  rv = NS_OK;
    1: 
    1:   // Find the child frame that maps the content
    1:   nsIFrame* childFrame =
    1:     mPresShell->FrameManager()->GetPrimaryFrameFor(aChild, aIndexInContainer);
    1: 
21936:   if (!childFrame || childFrame->GetContent() != aChild) {
21936:     // XXXbz the GetContent() != aChild check is needed due to bug 135040.
21936:     // Remove it once that's fixed.
    1:     frameManager->ClearUndisplayedContentIn(aChild, aContainer);
    1:   }
    1: 
    1: #ifdef MOZ_XUL
    1:   if (NotifyListBoxBody(presContext, aContainer, aChild, aIndexInContainer, 
23941:                         mDocument, childFrame, CONTENT_REMOVED))
    1:     return NS_OK;
    1: 
    1: #endif // MOZ_XUL
    1: 
    1:   if (childFrame) {
    1:     InvalidateCanvasIfNeeded(childFrame);
    1:     
    1:     // If the frame we are manipulating is a special frame then do
    1:     // something different instead of just inserting newly created
    1:     // frames.
    1:     // NOTE: if we are in ReinsertContent, 
    1:     //       then do not reframe as we are already doing just that!
 7681:     if (MaybeRecreateContainerForIBSplitterFrame(childFrame, &rv)) {
 7681:       *aDidReconstruct = PR_TRUE;
 4696:       return rv;
    1:     }
    1: 
    1:     // Get the childFrame's parent frame
    1:     nsIFrame* parentFrame = childFrame->GetParent();
 6862:     nsIAtom* parentType = parentFrame->GetType();
 6862: 
 6862:     if (parentType == nsGkAtoms::frameSetFrame &&
    1:         IsSpecialFramesetChild(aChild)) {
    1:       // Just reframe the parent, since framesets are weird like that.
 7681:       *aDidReconstruct = PR_TRUE;
    1:       return RecreateFramesForContent(parentFrame->GetContent());
    1:     }
    1: 
 6862: #ifdef MOZ_MATHML
 6862:     // If we're a child of MathML, then we should reframe the MathML content.
 6862:     // If we're non-MathML, then we would be wrapped in a block so we need to
 6862:     // check our grandparent in that case.
 6862:     nsIFrame* possibleMathMLAncestor = parentType == nsGkAtoms::blockFrame ? 
 6862:          parentFrame->GetParent() : parentFrame;
 7681:     if (possibleMathMLAncestor->IsFrameOfType(nsIFrame::eMathML)) {
 7681:       *aDidReconstruct = PR_TRUE;
 6862:       return RecreateFramesForContent(possibleMathMLAncestor->GetContent());
 7681:     }
 6862: #endif
 6862: 
 7189:     // Undo XUL wrapping if it's no longer needed.
 7189:     // (If we're in the XUL block-wrapping situation, parentFrame is the
 7189:     // wrapper frame.)
 7189:     nsIFrame* grandparentFrame = parentFrame->GetParent();
 7189:     if (grandparentFrame && grandparentFrame->IsBoxFrame() &&
 7189:         (grandparentFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
 7189:         // check if this frame is the only one needing wrapping
 7189:         aChild == AnyKidsNeedBlockParent(parentFrame->GetFirstChild(nsnull)) &&
 7189:         !AnyKidsNeedBlockParent(childFrame->GetNextSibling())) {
 7681:       *aDidReconstruct = PR_TRUE;
 7189:       return RecreateFramesForContent(grandparentFrame->GetContent());
 7189:     }
 7189:     
    1:     // Examine the containing-block for the removed content and see if
    1:     // :first-letter style applies.
    1:     nsIFrame* containingBlock = GetFloatContainingBlock(parentFrame);
 1254:     PRBool haveFLS = containingBlock && HasFirstLetterStyle(containingBlock);
    1:     if (haveFLS) {
    1:       // Trap out to special routine that handles adjusting a blocks
    1:       // frame tree when first-letter style is present.
    1: #ifdef NOISY_FIRST_LETTER
    1:       printf("ContentRemoved: containingBlock=");
    1:       nsFrame::ListTag(stdout, containingBlock);
    1:       printf(" parentFrame=");
    1:       nsFrame::ListTag(stdout, parentFrame);
    1:       printf(" childFrame=");
    1:       nsFrame::ListTag(stdout, childFrame);
    1:       printf("\n");
    1: #endif
    1: 
    1:       // First update the containing blocks structure by removing the
    1:       // existing letter frames. This makes the subsequent logic
    1:       // simpler.
    1:       RemoveLetterFrames(presContext, mPresShell, frameManager,
    1:                          containingBlock);
    1: 
    1:       // Recover childFrame and parentFrame
    1:       childFrame = mPresShell->GetPrimaryFrameFor(aChild);
21936:       if (!childFrame || childFrame->GetContent() != aChild) {
21936:         // XXXbz the GetContent() != aChild check is needed due to bug 135040.
21936:         // Remove it once that's fixed.
    1:         frameManager->ClearUndisplayedContentIn(aChild, aContainer);
    1:         return NS_OK;
    1:       }
    1:       parentFrame = childFrame->GetParent();
    1: 
    1: #ifdef NOISY_FIRST_LETTER
    1:       printf("  ==> revised parentFrame=");
    1:       nsFrame::ListTag(stdout, parentFrame);
    1:       printf(" childFrame=");
    1:       nsFrame::ListTag(stdout, childFrame);
    1:       printf("\n");
    1: #endif
    1:     }
    1: 
    1: #ifdef DEBUG
    1:     if (gReallyNoisyContentUpdates) {
    1:       printf("nsCSSFrameConstructor::ContentRemoved: childFrame=");
    1:       nsFrame::ListTag(stdout, childFrame);
    1:       printf("\n");
    1: 
23554:       nsIFrameDebug* fdbg = do_QueryFrame(parentFrame);
    1:       if (fdbg)
    1:         fdbg->List(stdout, 0);
    1:     }
    1: #endif
    1: 
    1:     // Walk the frame subtree deleting any out-of-flow frames, and
    1:     // remove the mapping from content objects to frames
    1:     ::DeletingFrameSubtree(frameManager, childFrame);
    1: 
    1:     // See if the child frame is an out-of-flow
    1:     if (childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
    1:       nsPlaceholderFrame* placeholderFrame =
    1:         frameManager->GetPlaceholderFrameFor(childFrame);
    1:       NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
    1: 
 4162:       UnregisterPlaceholderChain(frameManager, placeholderFrame);
    1: 
    1:       // Now we remove the out-of-flow frame
    1:       // XXX has to be done first for now: for floats, the block's line list
    1:       // contains an array of pointers to the placeholder - we have to
    1:       // remove the float first (which gets rid of the lines
    1:       // reference to the placeholder and float) and then remove the
    1:       // placeholder
    1:       rv = frameManager->RemoveFrame(parentFrame,
    1:                                      GetChildListNameFor(childFrame),
    1:                                      childFrame);
    1: 
    1:       // Remove the placeholder frame first (XXX second for now) (so
    1:       // that it doesn't retain a dangling pointer to memory)
    1:       nsIFrame* placeholderParent = placeholderFrame->GetParent();
    1:       ::DeletingFrameSubtree(frameManager, placeholderFrame);
    1:       rv |= frameManager->RemoveFrame(placeholderParent,
    1:                                       nsnull, placeholderFrame);
    1:     } else {
    1:       // Notify the parent frame that it should delete the frame
    1:       // check for a table caption which goes on an additional child list with a different parent
    1:       nsIFrame* outerTableFrame; 
    1:       if (GetCaptionAdjustedParent(parentFrame, childFrame, &outerTableFrame)) {
    1:         rv = frameManager->RemoveFrame(outerTableFrame,
    1:                                        nsGkAtoms::captionList,
    1:                                        childFrame);
    1:       }
    1:       else {
    1:         rv = frameManager->RemoveFrame(parentFrame, nsnull, childFrame);
    1:       }
    1:     }
    1: 
    1:     if (mInitialContainingBlock == childFrame) {
    1:       mInitialContainingBlock = nsnull;
16509:       mRootElementStyleFrame = nsnull;
    1:     }
    1: 
    1:     if (haveFLS && mInitialContainingBlock) {
    1:       NS_ASSERTION(containingBlock == GetFloatContainingBlock(parentFrame),
    1:                    "What happened here?");
    1:       nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                     GetAbsoluteContainingBlock(parentFrame),
    1:                                     containingBlock);
23461:       RecoverLetterFrames(containingBlock);
    1:     }
    1: 
    1: #ifdef DEBUG
    1:     if (gReallyNoisyContentUpdates && parentFrame) {
23554:       nsIFrameDebug* fdbg = do_QueryFrame(parentFrame);
    1:       if (fdbg) {
    1:         printf("nsCSSFrameConstructor::ContentRemoved: resulting frame model:\n");
    1:         fdbg->List(stdout, 0);
    1:       }
    1:     }
    1: #endif
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef DEBUG
    1:   // To ensure that the functions below are only called within
    1:   // |ApplyRenderingChangeToTree|.
    1: static PRBool gInApplyRenderingChangeToTree = PR_FALSE;
    1: #endif
    1: 
    1: static void
    1: DoApplyRenderingChangeToTree(nsIFrame* aFrame,
    1:                              nsIViewManager* aViewManager,
    1:                              nsFrameManager* aFrameManager,
    1:                              nsChangeHint aChange);
    1: 
    1: /**
    1:  * @param aBoundsRect returns the bounds enclosing the areas covered by aFrame and its childre
    1:  * This rect is relative to aFrame's parent
    1:  */
    1: static void
    1: UpdateViewsForTree(nsIFrame* aFrame, nsIViewManager* aViewManager,
    1:                    nsFrameManager* aFrameManager,
  134:                    nsChangeHint aChange)
    1: {
    1:   NS_PRECONDITION(gInApplyRenderingChangeToTree,
    1:                   "should only be called within ApplyRenderingChangeToTree");
    1: 
    1:   nsIView* view = aFrame->GetView();
    1:   if (view) {
    1:     if (aChange & nsChangeHint_SyncFrameView) {
  238:       nsContainerFrame::SyncFrameViewProperties(aFrame->PresContext(),
    1:                                                 aFrame, nsnull, view);
    1:     }
    1:   }
    1: 
    1:   // now do children of frame
    1:   PRInt32 listIndex = 0;
    1:   nsIAtom* childList = nsnull;
    1: 
    1:   do {
    1:     nsIFrame* child = aFrame->GetFirstChild(childList);
    1:     while (child) {
 6521:       if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
 6521:           || (child->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
 7655:         // only do frames that don't have placeholders
    1:         if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
    1:           // get out of flow frame and start over there
    1:           nsIFrame* outOfFlowFrame =
    1:             nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
    1: 
    1:           DoApplyRenderingChangeToTree(outOfFlowFrame, aViewManager,
    1:                                        aFrameManager, aChange);
    1:         }
    1:         else {  // regular frame
  134:           UpdateViewsForTree(child, aViewManager, aFrameManager, aChange);
    1:         }
    1:       }
    1:       child = child->GetNextSibling();
    1:     }
    1:     childList = aFrame->GetAdditionalChildListName(listIndex++);
    1:   } while (childList);
    1: }
    1: 
    1: static void
    1: DoApplyRenderingChangeToTree(nsIFrame* aFrame,
    1:                              nsIViewManager* aViewManager,
    1:                              nsFrameManager* aFrameManager,
    1:                              nsChangeHint aChange)
    1: {
    1:   NS_PRECONDITION(gInApplyRenderingChangeToTree,
    1:                   "should only be called within ApplyRenderingChangeToTree");
    1: 
   94:   for ( ; aFrame; aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame)) {
    1:     // Get view if this frame has one and trigger an update. If the
    1:     // frame doesn't have a view, find the nearest containing view
    1:     // (adjusting r's coordinate system to reflect the nesting) and
    1:     // update there.
  134:     UpdateViewsForTree(aFrame, aViewManager, aFrameManager, aChange);
    1: 
    1:     // if frame has view, will already be invalidated
15351:     if ((aChange & nsChangeHint_RepaintFrame) &&
15351:         !aFrame->IsFrameOfType(nsIFrame::eSVG)) {
  134:       aFrame->Invalidate(aFrame->GetOverflowRect());
    1:     }
    1:   }
    1: }
    1: 
    1: static void
    1: ApplyRenderingChangeToTree(nsPresContext* aPresContext,
    1:                            nsIFrame* aFrame,
    1:                            nsChangeHint aChange)
    1: {
    1:   nsIPresShell *shell = aPresContext->PresShell();
    1:   PRBool isPaintingSuppressed = PR_FALSE;
    1:   shell->IsPaintingSuppressed(&isPaintingSuppressed);
    1:   if (isPaintingSuppressed) {
    1:     // Don't allow synchronous rendering changes when painting is turned off.
    1:     aChange = NS_SubtractHint(aChange, nsChangeHint_RepaintFrame);
    1:     if (!aChange) {
    1:       return;
    1:     }
    1:   }
    1: 
    1:   // If the frame's background is propagated to an ancestor, walk up to
    1:   // that ancestor.
    1:   const nsStyleBackground *bg;
    1:   PRBool isCanvas;
    1:   while (!nsCSSRendering::FindBackground(aPresContext, aFrame,
    1:                                          &bg, &isCanvas)) {
    1:     aFrame = aFrame->GetParent();
    1:     NS_ASSERTION(aFrame, "root frame must paint");
    1:   }
    1: 
    1:   nsIViewManager* viewManager = aPresContext->GetViewManager();
    1: 
    1:   // Trigger rendering updates by damaging this frame and any
    1:   // continuations of this frame.
    1: 
    1:   // XXX this needs to detect the need for a view due to an opacity change and deal with it...
    1: 
10730:   nsIViewManager::UpdateViewBatch batch(viewManager);
    1: 
    1: #ifdef DEBUG
    1:   gInApplyRenderingChangeToTree = PR_TRUE;
    1: #endif
    1:   DoApplyRenderingChangeToTree(aFrame, viewManager, shell->FrameManager(),
    1:                                aChange);
    1: #ifdef DEBUG
    1:   gInApplyRenderingChangeToTree = PR_FALSE;
    1: #endif
    1:   
10730:   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
    1: }
    1: 
    1: /**
    1:  * This method invalidates the canvas when frames are removed or added for a
    1:  * node that might have its background propagated to the canvas, i.e., a
    1:  * document root node or an HTML BODY which is a child of the root node.
    1:  *
    1:  * @param aFrame a frame for a content node about to be removed or a frme that
    1:  *               was just created for a content node that was inserted.
    1:  */ 
    1: static void
    1: InvalidateCanvasIfNeeded(nsIFrame* aFrame)
    1: {
    1:   NS_ASSERTION(aFrame, "Must have frame!");
    1: 
    1:   //  Note that for both in ContentRemoved and ContentInserted the content node
    1:   //  will still have the right parent pointer, so looking at that is ok.
    1:   
    1:   nsIContent* node = aFrame->GetContent();
    1:   nsIContent* parent = node->GetParent();
    1:   if (parent) {
    1:     // Has a parent; might not be what we want
    1:     nsIContent* grandParent = parent->GetParent();
    1:     if (grandParent) {
    1:       // Has a grandparent, so not what we want
    1:       return;
    1:     }
    1: 
    1:     // Check whether it's an HTML body
    1:     if (node->Tag() != nsGkAtoms::body ||
    1:         !node->IsNodeOfType(nsINode::eHTML)) {
    1:       return;
    1:     }
    1:   }
    1: 
    1:   // At this point the node has no parent or it's an HTML <body> child of the
    1:   // root.  We might not need to invalidate in this case (eg we might be in
    1:   // XHTML or something), but chances are we want to.  Play it safe.  Find the
    1:   // frame to invalidate and do it.
    1:   nsIFrame *ancestor = aFrame;
    1:   const nsStyleBackground *bg;
    1:   PRBool isCanvas;
  238:   nsPresContext* presContext = aFrame->PresContext();
    1:   while (!nsCSSRendering::FindBackground(presContext, ancestor,
    1:                                          &bg, &isCanvas)) {
    1:     ancestor = ancestor->GetParent();
    1:     NS_ASSERTION(ancestor, "canvas must paint");
    1:   }
    1: 
    1:   if (ancestor->GetType() == nsGkAtoms::canvasFrame) {
    1:     // The canvas frame's dimensions are not meaningful; invalidate the
    1:     // viewport instead.
    1:     ancestor = ancestor->GetParent();
    1:   }
    1: 
    1:   if (ancestor != aFrame) {
 7808:     // Wrap this in a DEFERRED view update batch so we don't try to
 7808:     // flush out layout here
 7808: 
10730:     nsIViewManager::UpdateViewBatch batch(presContext->GetViewManager());  
    1:     ApplyRenderingChangeToTree(presContext, ancestor,
    1:                                nsChangeHint_RepaintFrame);
10730:     batch.EndUpdateViewBatch(NS_VMREFRESH_DEFERRED);
    1:   }
    1: }
    1: 
    1: nsresult
 2724: nsCSSFrameConstructor::StyleChangeReflow(nsIFrame* aFrame)
    1: {
    1:   // If the frame hasn't even received an initial reflow, then don't
    1:   // send it a style-change reflow!
    1:   if (aFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)
    1:     return NS_OK;
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::StyleChangeReflow: aFrame=");
    1:     nsFrame::ListTag(stdout, aFrame);
    1:     printf("\n");
    1:   }
    1: #endif
    1: 
    1:   // If the frame is part of a split block-in-inline hierarchy, then
    1:   // target the style-change reflow at the first ``normal'' ancestor
    1:   // so we're sure that the style change will propagate to any
    1:   // anonymously created siblings.
    1:   if (IsFrameSpecial(aFrame))
    1:     aFrame = GetIBContainingBlockFor(aFrame);
    1: 
 6521:   do {
 1158:     mPresShell->FrameNeedsReflow(aFrame, nsIPresShell::eStyleChange,
 1158:                                  NS_FRAME_IS_DIRTY);
 6521:     aFrame = aFrame->GetNextContinuation();
 6521:   } while (aFrame);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CharacterDataChanged(nsIContent* aContent,
    1:                                             PRBool aAppend)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
    1:   nsresult      rv = NS_OK;
    1: 
    1:   // Find the child frame
    1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
    1: 
    1:   // Notify the first frame that maps the content. It will generate a reflow
    1:   // command
    1: 
    1:   // It's possible the frame whose content changed isn't inserted into the
    1:   // frame hierarchy yet, or that there is no frame that maps the content
    1:   if (nsnull != frame) {
    1: #if 0
    1:     NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
    1:        ("nsCSSFrameConstructor::CharacterDataChanged: content=%p[%s] subcontent=%p frame=%p",
    1:         aContent, ContentTag(aContent, 0),
    1:         aSubContent, frame));
    1: #endif
    1: 
    1:     // Special check for text content that is a child of a letter frame.  If
    1:     // this happens, we should remove the letter frame, do whatever we're
    1:     // planning to do with this notification, then put the letter frame back.
    1:     // Note that this is basically what ReinsertContent ends up doing; the
    1:     // reason we dont' want to call that here is that our text content could be
    1:     // native anonymous, in which case ReinsertContent would completely barf on
    1:     // it.  And reinserting the non-anonymous ancestor would just lead us to
    1:     // come back into this notification (e.g. if quotes or counters are
    1:     // involved), leading to a loop.
    1:     nsIFrame* block = GetFloatContainingBlock(frame);
    1:     PRBool haveFirstLetterStyle = PR_FALSE;
    1:     if (block) {
    1:       // See if the block has first-letter style applied to it.
 1254:       haveFirstLetterStyle = HasFirstLetterStyle(block);
    1:       if (haveFirstLetterStyle) {
    1:         RemoveLetterFrames(mPresShell->GetPresContext(), mPresShell,
    1:                            mPresShell->FrameManager(), block);
    1:         // Reget |frame|, since we might have killed it.
    1:         // Do we really need to call CharacterDataChanged in this case, though?
    1:         frame = mPresShell->GetPrimaryFrameFor(aContent);
    1:         NS_ASSERTION(frame, "Should have frame here!");
    1:       }
    1:     }
    1: 
    1:     frame->CharacterDataChanged(mPresShell->GetPresContext(), aContent,
    1:                                 aAppend);
    1: 
    1:     if (haveFirstLetterStyle) {
    1:       nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                     GetAbsoluteContainingBlock(frame),
    1:                                     block, nsnull);
23461:       RecoverLetterFrames(block);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ProcessRestyledFrames(nsStyleChangeList& aChangeList)
    1: {
23652:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
23652:                "Someone forgot a script blocker");
    1:   PRInt32 count = aChangeList.Count();
    1:   if (!count)
    1:     return NS_OK;
    1: 
 6467:   // Make sure to not rebuild quote or counter lists while we're
 6467:   // processing restyles
 6467:   BeginUpdate();
 6467: 
    1:   nsPropertyTable *propTable = mPresShell->GetPresContext()->PropertyTable();
    1: 
    1:   // Mark frames so that we skip frames that die along the way, bug 123049.
    1:   // A frame can be in the list multiple times with different hints. Further
    1:   // optmization is possible if nsStyleChangeList::AppendChange could coalesce
    1:   PRInt32 index = count;
    1: 
    1:   while (0 <= --index) {
    1:     const nsStyleChangeData* changeData;
    1:     aChangeList.ChangeAt(index, &changeData);
    1:     if (changeData->mFrame) {
    1:       propTable->SetProperty(changeData->mFrame,
    1:                              nsGkAtoms::changeListProperty,
    1:                              nsnull, nsnull, nsnull);
    1:     }
    1:   }
    1: 
    1:   index = count;
    1:   while (0 <= --index) {
    1:     nsIFrame* frame;
    1:     nsIContent* content;
    1:     nsChangeHint hint;
    1:     aChangeList.ChangeAt(index, frame, content, hint);
21936:     if (frame && frame->GetContent() != content) {
21936:       // XXXbz this is due to image maps messing with the primary frame map.
21936:       // See bug 135040.  Remove this block once that's fixed.
21936:       frame = nsnull;
21936:       if (!(hint & nsChangeHint_ReconstructFrame)) {
21936:         continue;
21936:       }
21936:     }
    1: 
    1:     // skip any frame that has been destroyed due to a ripple effect
    1:     if (frame) {
    1:       nsresult res;
    1: 
    1:       propTable->GetProperty(frame, nsGkAtoms::changeListProperty, &res);
    1: 
    1:       if (NS_PROPTABLE_PROP_NOT_THERE == res)
    1:         continue;
    1:     }
    1: 
    1:     if (hint & nsChangeHint_ReconstructFrame) {
    1:       RecreateFramesForContent(content);
    1:     } else {
    1:       NS_ASSERTION(frame, "This shouldn't happen");
16411: #ifdef MOZ_SVG
16411:       if (hint & nsChangeHint_UpdateEffects) {
19948:         nsSVGEffects::UpdateEffects(frame);
16411:       }
16411: #endif
    1:       if (hint & nsChangeHint_ReflowFrame) {
 2724:         StyleChangeReflow(frame);
    1:       }
    1:       if (hint & (nsChangeHint_RepaintFrame | nsChangeHint_SyncFrameView)) {
    1:         ApplyRenderingChangeToTree(mPresShell->GetPresContext(), frame, hint);
    1:       }
    1:       if (hint & nsChangeHint_UpdateCursor) {
    1:         nsIViewManager* viewMgr = mPresShell->GetViewManager();
    1:         if (viewMgr)
    1:           viewMgr->SynthesizeMouseMove(PR_FALSE);
    1:       }
    1:     }
    1:   }
    1: 
 6467:   EndUpdate();
 6467:   
 6739:   // cleanup references and verify the style tree.  Note that the latter needs
 6739:   // to happen once we've processed the whole list, since until then the tree
 6739:   // is not in fact in a consistent state.
    1:   index = count;
    1:   while (0 <= --index) {
    1:     const nsStyleChangeData* changeData;
    1:     aChangeList.ChangeAt(index, &changeData);
    1:     if (changeData->mFrame) {
    1:       propTable->DeleteProperty(changeData->mFrame,
    1:                                 nsGkAtoms::changeListProperty);
    1:     }
 6739: 
 6739: #ifdef DEBUG
 6739:     // reget frame from content since it may have been regenerated...
 6739:     if (changeData->mContent) {
 6739:       nsIFrame* frame = mPresShell->GetPrimaryFrameFor(changeData->mContent);
 6739:       if (frame) {
 6739:         mPresShell->FrameManager()->DebugVerifyStyleTree(frame);
 6739:       }
 6739:     } else {
 6739:       NS_WARNING("Unable to test style tree integrity -- no content node");
 6739:     }
 6739: #endif
    1:   }
    1: 
    1:   aChangeList.Clear();
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::RestyleElement(nsIContent     *aContent,
    1:                                       nsIFrame       *aPrimaryFrame,
    1:                                       nsChangeHint   aMinHint)
    1: {
11409:   NS_ASSERTION(aPrimaryFrame == mPresShell->GetPrimaryFrameFor(aContent),
11409:                "frame/content mismatch");
21936:   if (aPrimaryFrame && aPrimaryFrame->GetContent() != aContent) {
21936:     // XXXbz this is due to image maps messing with the primary frame mapping.
21936:     // See bug 135040.  We can remove this block once that's fixed.
21936:     aPrimaryFrame = nsnull;
21936:   }
11409:   NS_ASSERTION(!aPrimaryFrame || aPrimaryFrame->GetContent() == aContent,
11409:                "frame/content mismatch");
11409: 
    1:   if (aMinHint & nsChangeHint_ReconstructFrame) {
    1:     RecreateFramesForContent(aContent);
    1:   } else if (aPrimaryFrame) {
    1:     nsStyleChangeList changeList;
11409:     mPresShell->FrameManager()->
    1:       ComputeStyleChangeFor(aPrimaryFrame, &changeList, aMinHint);
    1:     ProcessRestyledFrames(changeList);
    1:   } else {
    1:     // no frames, reconstruct for content
    1:     MaybeRecreateFramesForContent(aContent);
    1:   }
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::RestyleLaterSiblings(nsIContent *aContent)
    1: {
    1:   nsIContent *parent = aContent->GetParent();
    1:   if (!parent)
    1:     return; // root element has no later siblings
    1: 
    1:   for (PRInt32 index = parent->IndexOf(aContent) + 1,
    1:                index_end = parent->GetChildCount();
    1:        index != index_end; ++index) {
    1:     nsIContent *child = parent->GetChildAt(index);
    1:     if (!child->IsNodeOfType(nsINode::eELEMENT))
    1:       continue;
    1: 
    1:     nsIFrame* primaryFrame = mPresShell->GetPrimaryFrameFor(child);
    1:     RestyleElement(child, primaryFrame, NS_STYLE_HINT_NONE);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ContentStatesChanged(nsIContent* aContent1,
    1:                                             nsIContent* aContent2,
    1:                                             PRInt32 aStateMask) 
    1: {
    1:   DoContentStateChanged(aContent1, aStateMask);
    1:   DoContentStateChanged(aContent2, aStateMask);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::DoContentStateChanged(nsIContent* aContent,
    1:                                              PRInt32 aStateMask) 
    1: {
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1:   nsPresContext *presContext = mPresShell->GetPresContext();
    1:   NS_ASSERTION(styleSet, "couldn't get style set");
    1: 
    1:   if (aContent) {
    1:     nsChangeHint hint = NS_STYLE_HINT_NONE;
    1:     // Any change to a content state that affects which frames we construct
    1:     // must lead to a frame reconstruct here if we already have a frame.
    1:     // Note that we never decide through non-CSS means to not create frames
    1:     // based on content states, so if we already don't have a frame we don't
    1:     // need to force a reframe -- if it's needed, the HasStateDependentStyle
    1:     // call will handle things.
    1:     nsIFrame* primaryFrame = mPresShell->GetPrimaryFrameFor(aContent);
    1:     if (primaryFrame) {
    1:       // If it's generated content, ignore LOADING/etc state changes on it.
    1:       if (!primaryFrame->IsGeneratedContentFrame() &&
    1:           (aStateMask & (NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED |
    1:                          NS_EVENT_STATE_SUPPRESSED | NS_EVENT_STATE_LOADING))) {
    1:         hint = nsChangeHint_ReconstructFrame;
    1:       } else {          
    1:         PRUint8 app = primaryFrame->GetStyleDisplay()->mAppearance;
    1:         if (app) {
    1:           nsITheme *theme = presContext->GetTheme();
    1:           if (theme && theme->ThemeSupportsWidget(presContext,
    1:                                                   primaryFrame, app)) {
    1:             PRBool repaint = PR_FALSE;
    1:             theme->WidgetStateChanged(primaryFrame, app, nsnull, &repaint);
    1:             if (repaint) {
    1:               NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
    1:     nsReStyleHint rshint = 
    1:       styleSet->HasStateDependentStyle(presContext, aContent, aStateMask);
    1:       
22471:     if ((aStateMask & NS_EVENT_STATE_HOVER) && rshint != 0) {
22471:       ++mHoverGeneration;
22471:     }
22471: 
    1:     PostRestyleEvent(aContent, rshint, hint);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::AttributeChanged(nsIContent* aContent,
    1:                                         PRInt32 aNameSpaceID,
    1:                                         nsIAtom* aAttribute,
 3410:                                         PRInt32 aModType,
 3410:                                         PRUint32 aStateMask)
    1: {
    1:   nsresult  result = NS_OK;
    1: 
    1:   // Hold onto the PresShell to prevent ourselves from being destroyed.
    1:   // XXXbz how, exactly, would this attribute change cause us to be
    1:   // destroyed from inside this function?
    1:   nsCOMPtr<nsIPresShell> shell = mPresShell;
    1: 
    1:   // Get the frame associated with the content which is the highest in the frame tree
    1:   nsIFrame* primaryFrame = shell->GetPrimaryFrameFor(aContent); 
    1: 
    1: #if 0
    1:   NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
    1:      ("HTMLStyleSheet::AttributeChanged: content=%p[%s] frame=%p",
    1:       aContent, ContentTag(aContent, 0), frame));
    1: #endif
    1: 
    1:   // the style tag has its own interpretation based on aHint 
 4036:   nsChangeHint hint = aContent->GetAttributeChangeHint(aAttribute, aModType);
    1: 
    1:   PRBool reframe = (hint & nsChangeHint_ReconstructFrame) != 0;
    1: 
    1: #ifdef MOZ_XUL
    1:   // The following listbox widget trap prevents offscreen listbox widget
    1:   // content from being removed and re-inserted (which is what would
    1:   // happen otherwise).
    1:   if (!primaryFrame && !reframe) {
    1:     PRInt32 namespaceID;
    1:     nsIAtom* tag =
    1:       mDocument->BindingManager()->ResolveTag(aContent, &namespaceID);
    1: 
    1:     if (namespaceID == kNameSpaceID_XUL &&
    1:         (tag == nsGkAtoms::listitem ||
    1:          tag == nsGkAtoms::listcell))
    1:       return NS_OK;
    1:   }
    1: 
    1:   if (aAttribute == nsGkAtoms::tooltiptext ||
    1:       aAttribute == nsGkAtoms::tooltip) 
    1:   {
    1:     nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
    1:     if (rootBox) {
    1:       if (aModType == nsIDOMMutationEvent::REMOVAL)
    1:         rootBox->RemoveTooltipSupport(aContent);
    1:       if (aModType == nsIDOMMutationEvent::ADDITION)
    1:         rootBox->AddTooltipSupport(aContent);
    1:     }
    1:   }
    1: 
    1: #endif // MOZ_XUL
    1: 
    1:   if (primaryFrame) {
    1:     // See if we have appearance information for a theme.
    1:     const nsStyleDisplay* disp = primaryFrame->GetStyleDisplay();
    1:     if (disp->mAppearance) {
    1:       nsPresContext* presContext = mPresShell->GetPresContext();
    1:       nsITheme *theme = presContext->GetTheme();
 4036:       if (theme && theme->ThemeSupportsWidget(presContext, primaryFrame, disp->mAppearance)) {
    1:         PRBool repaint = PR_FALSE;
 4036:         theme->WidgetStateChanged(primaryFrame, disp->mAppearance, aAttribute, &repaint);
    1:         if (repaint)
    1:           NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
    1:       }
    1:     }
    1:    
    1:     // let the frame deal with it now, so we don't have to deal later
    1:     result = primaryFrame->AttributeChanged(aNameSpaceID, aAttribute,
    1:                                             aModType);
    1:     // XXXwaterson should probably check for special IB siblings
    1:     // here, and propagate the AttributeChanged notification to
    1:     // them, as well. Currently, inline frames don't do anything on
    1:     // this notification, so it's not that big a deal.
    1:   }
    1: 
    1:   // See if we can optimize away the style re-resolution -- must be called after
    1:   // the frame's AttributeChanged() in case it does something that affects the style
    1:   nsFrameManager *frameManager = shell->FrameManager();
    1:   nsReStyleHint rshint = frameManager->HasAttributeDependentStyle(aContent,
    1:                                                                   aAttribute,
 3410:                                                                   aModType,
 3410:                                                                   aStateMask);
    1: 
    1:   PostRestyleEvent(aContent, rshint, hint);
    1: 
    1:   return result;
    1: }
    1: 
    1: void
11855: nsCSSFrameConstructor::BeginUpdate() {
13389:   NS_SuppressFocusEvent();
22769:   ++mFocusSuppressCount;
11855:   ++mUpdateCount;
11855: }
11855: 
11855: void
    1: nsCSSFrameConstructor::EndUpdate()
    1: {
    1:   if (mUpdateCount == 1) {
    1:     // This is the end of our last update.  Before we decrement
    1:     // mUpdateCount, recalc quotes and counters as needed.
    1: 
  550:     RecalcQuotesAndCounters();
  550:     NS_ASSERTION(mUpdateCount == 1, "Odd update count");
  550:   }
22957:   --mUpdateCount;
22769:   if (mFocusSuppressCount) {
13389:     NS_UnsuppressFocusEvent();
22769:     --mFocusSuppressCount;
22769:   }
  550: }
  550: 
  550: void
  550: nsCSSFrameConstructor::RecalcQuotesAndCounters()
  550: {
    1:   if (mQuotesDirty) {
    1:     mQuotesDirty = PR_FALSE;
    1:     mQuoteList.RecalcAll();
    1:   }
    1: 
    1:   if (mCountersDirty) {
    1:     mCountersDirty = PR_FALSE;
    1:     mCounterManager.RecalcAll();
    1:   }
    1: 
    1:   NS_ASSERTION(!mQuotesDirty, "Quotes updates will be lost");
    1:   NS_ASSERTION(!mCountersDirty, "Counter updates will be lost");  
    1: }
    1: 
22769: class nsFocusUnsuppressEvent : public nsRunnable {
22769:   public:
22769:     NS_DECL_NSIRUNNABLE
22769:     nsFocusUnsuppressEvent(PRUint32 aCount) : mCount(aCount) {}
22769:   private:
22769:     PRUint32 mCount;
22769:   };
22769: 
22769: NS_IMETHODIMP nsFocusUnsuppressEvent::Run()
22769: {
22769:   while (mCount) {
22769:     --mCount;
22769:     NS_UnsuppressFocusEvent();
22769:   }
22769:   return NS_OK;
22769: }
22769: 
    1: void
22769: nsCSSFrameConstructor::WillDestroyFrameTree(PRBool aDestroyingPresShell)
    1: {
    1: #if defined(DEBUG_dbaron_off)
    1:   mCounterManager.Dump();
    1: #endif
    1: 
    1:   mIsDestroyingFrameTree = PR_TRUE;
    1: 
    1:   // Prevent frame tree destruction from being O(N^2)
    1:   mQuoteList.Clear();
    1:   mCounterManager.Clear();
    1: 
    1:   // Cancel all pending re-resolves
    1:   mRestyleEvent.Revoke();
22769: 
22769:   if (mFocusSuppressCount && aDestroyingPresShell) {
22769:     nsRefPtr<nsFocusUnsuppressEvent> ev =
22769:       new nsFocusUnsuppressEvent(mFocusSuppressCount);
22769:     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
22769:       mFocusSuppressCount = 0;
22769:     }
22769:   }
    1: }
    1: 
    1: //STATIC
    1: 
    1: // XXXbz I'd really like this method to go away. Once we have inline-block and
    1: // I can just use that for sized broken images, that can happen, maybe.
    1: void nsCSSFrameConstructor::GetAlternateTextFor(nsIContent*    aContent,
    1:                                                 nsIAtom*       aTag,  // content object's tag
    1:                                                 nsXPIDLString& aAltText)
    1: {
    1:   // The "alt" attribute specifies alternate text that is rendered
    1:   // when the image can not be displayed
    1: 
    1:   // If there's no "alt" attribute, and aContent is an input    
    1:   // element, then use the value of the "value" attribute
    1:   if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::alt, aAltText) &&
    1:       nsGkAtoms::input == aTag) {
    1:     // If there's no "value" attribute either, then use the localized string 
    1:     // for "Submit" as the alternate text.
    1:     if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::value, aAltText)) {
    1:       nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
    1:                                          "Submit", aAltText);      
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateContinuingOuterTableFrame(nsIPresShell*    aPresShell,
    1:                                                        nsPresContext*  aPresContext,
    1:                                                        nsIFrame*        aFrame,
    1:                                                        nsIFrame*        aParentFrame,
    1:                                                        nsIContent*      aContent,
    1:                                                        nsStyleContext*  aStyleContext,
    1:                                                        nsIFrame**       aContinuingFrame)
    1: {
    1:   nsIFrame* newFrame = NS_NewTableOuterFrame(aPresShell, aStyleContext);
    1: 
    1:   if (newFrame) {
    1:     newFrame->Init(aContent, aParentFrame, aFrame);
23395:     nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:     // Create a continuing inner table frame, and if there's a caption then
    1:     // replicate the caption
    1:     nsFrameItems  newChildFrames;
    1: 
    1:     nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
    1:     if (childFrame) {
    1:       nsIFrame* continuingTableFrame;
    1:       nsresult rv = CreateContinuingFrame(aPresContext, childFrame, newFrame,
    1:                                           &continuingTableFrame);
    1:       if (NS_FAILED(rv)) {
    1:         newFrame->Destroy();
    1:         *aContinuingFrame = nsnull;
    1:         return rv;
    1:       }
    1:       newChildFrames.AddChild(continuingTableFrame);
    1:       
    1:       NS_ASSERTION(!childFrame->GetNextSibling(),"there can be only one inner table frame");
    1:     }
    1: 
    1:     // Set the outer table's initial child list
    1:     newFrame->SetInitialChildList(nsnull, newChildFrames.childList);
    1:     
    1:     *aContinuingFrame = newFrame;
    1:     return NS_OK;
    1:   }
    1:   else {
    1:     *aContinuingFrame = nsnull;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateContinuingTableFrame(nsIPresShell* aPresShell, 
    1:                                                   nsPresContext*  aPresContext,
    1:                                                   nsIFrame*        aFrame,
    1:                                                   nsIFrame*        aParentFrame,
    1:                                                   nsIContent*      aContent,
    1:                                                   nsStyleContext*  aStyleContext,
    1:                                                   nsIFrame**       aContinuingFrame)
    1: {
    1:   nsIFrame* newFrame = NS_NewTableFrame(aPresShell, aStyleContext);
    1: 
    1:   if (newFrame) {
    1:     newFrame->Init(aContent, aParentFrame, aFrame);
23395:     nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:     // Replicate any header/footer frames
    1:     nsFrameItems  childFrames;
    1:     nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
    1:     for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
    1:       // See if it's a header/footer, possibly wrapped in a scroll frame.
    1:       nsTableRowGroupFrame* rowGroupFrame =
    1:         nsTableFrame::GetRowGroupFrame(childFrame);
    1:       if (rowGroupFrame) {
    1:         // If the row group was continued, then don't replicate it.
    1:         nsIFrame* rgNextInFlow = rowGroupFrame->GetNextInFlow();
    1:         if (rgNextInFlow) {
    1:           rowGroupFrame->SetRepeatable(PR_FALSE);
    1:         }
    1:         else if (rowGroupFrame->IsRepeatable()) {        
    1:           // Replicate the header/footer frame.
    1:           nsTableRowGroupFrame*   headerFooterFrame;
    1:           nsFrameItems            childItems;
    1:           nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                         GetAbsoluteContainingBlock(newFrame),
    1:                                         nsnull);
    1: 
 3233:           headerFooterFrame = static_cast<nsTableRowGroupFrame*>
 3233:                                          (NS_NewTableRowGroupFrame(aPresShell, rowGroupFrame->GetStyleContext()));
    1:           nsIContent* headerFooter = rowGroupFrame->GetContent();
    1:           headerFooterFrame->Init(headerFooter, newFrame, nsnull);
23352:           ProcessChildren(state, headerFooter, rowGroupFrame->GetStyleContext(),
23352:                           headerFooterFrame, PR_TRUE, childItems, PR_FALSE);
    1:           NS_ASSERTION(!state.mFloatedItems.childList, "unexpected floated element");
    1:           headerFooterFrame->SetInitialChildList(nsnull, childItems.childList);
    1:           headerFooterFrame->SetRepeatable(PR_TRUE);
    1: 
    1:           // Table specific initialization
    1:           headerFooterFrame->InitRepeatedFrame(aPresContext, rowGroupFrame);
    1: 
    1:           // XXX Deal with absolute and fixed frames...
    1:           childFrames.AddChild(headerFooterFrame);
    1:         }
    1:       }
    1:     }
    1:     
    1:     // Set the table frame's initial child list
    1:     newFrame->SetInitialChildList(nsnull, childFrames.childList);
    1:     
    1:     *aContinuingFrame = newFrame;
    1:     return NS_OK;
    1:   }
    1:   else {
    1:     *aContinuingFrame = nsnull;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateContinuingFrame(nsPresContext* aPresContext,
    1:                                              nsIFrame*       aFrame,
    1:                                              nsIFrame*       aParentFrame,
    1:                                              nsIFrame**      aContinuingFrame,
    1:                                              PRBool          aIsFluid)
    1: {
    1:   nsIPresShell*              shell = aPresContext->PresShell();
    1:   nsStyleContext*            styleContext = aFrame->GetStyleContext();
    1:   nsIFrame*                  newFrame = nsnull;
    1:   nsresult                   rv = NS_OK;
    1:   nsIFrame*                  nextContinuation = aFrame->GetNextContinuation();
    1:   nsIFrame*                  nextInFlow = aFrame->GetNextInFlow();
    1: 
    1:   // Use the frame type to determine what type of frame to create
    1:   nsIAtom* frameType = aFrame->GetType();
    1:   nsIContent* content = aFrame->GetContent();
    1: 
    1:   NS_ASSERTION(aFrame->GetSplittableType() != NS_FRAME_NOT_SPLITTABLE,
    1:                "why CreateContinuingFrame for a non-splittable frame?");
    1:   
    1:   if (nsGkAtoms::textFrame == frameType) {
    1:     newFrame = NS_NewContinuingTextFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:     
    1:   } else if (nsGkAtoms::inlineFrame == frameType) {
    1:     newFrame = NS_NewInlineFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::blockFrame == frameType) {
    1:     newFrame = NS_NewBlockFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
23167:     }
23167:   
23176: #ifdef MOZ_XUL
23176:   } else if (nsGkAtoms::XULLabelFrame == frameType) {
23947:     newFrame = NS_NewXULLabelFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
23167:     }
23176: #endif  
    1:   } else if (nsGkAtoms::columnSetFrame == frameType) {
    1:     newFrame = NS_NewColumnSetFrame(shell, styleContext, 0);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::positionedInlineFrame == frameType) {
    1:     newFrame = NS_NewPositionedInlineFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1: 
    1:   } else if (nsGkAtoms::pageFrame == frameType) {
18953:     nsIFrame* canvasFrame;
    1:     rv = ConstructPageFrame(shell, aPresContext, aParentFrame, aFrame,
18953:                             newFrame, canvasFrame);
    1:   } else if (nsGkAtoms::tableOuterFrame == frameType) {
    1:     rv = CreateContinuingOuterTableFrame(shell, aPresContext, aFrame, aParentFrame,
    1:                                          content, styleContext, &newFrame);
    1: 
    1:   } else if (nsGkAtoms::tableFrame == frameType) {
    1:     rv = CreateContinuingTableFrame(shell, aPresContext, aFrame, aParentFrame,
    1:                                     content, styleContext, &newFrame);
    1: 
    1:   } else if (nsGkAtoms::tableRowGroupFrame == frameType) {
    1:     newFrame = NS_NewTableRowGroupFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1: 
    1:   } else if (nsGkAtoms::tableRowFrame == frameType) {
    1:     newFrame = NS_NewTableRowFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:       // Create a continuing frame for each table cell frame
    1:       nsFrameItems  newChildList;
    1:       nsIFrame* cellFrame = aFrame->GetFirstChild(nsnull);
    1:       while (cellFrame) {
    1:         // See if it's a table cell frame
    1:         if (IS_TABLE_CELL(cellFrame->GetType())) {
    1:           nsIFrame* continuingCellFrame;
    1:           rv = CreateContinuingFrame(aPresContext, cellFrame, newFrame,
    1:                                      &continuingCellFrame);
    1:           if (NS_FAILED(rv)) {
    1:             nsFrameList tmp(newChildList.childList);
    1:             tmp.DestroyFrames();
    1:             newFrame->Destroy();
    1:             *aContinuingFrame = nsnull;
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:           }
    1:           newChildList.AddChild(continuingCellFrame);
    1:         }
    1:         cellFrame = cellFrame->GetNextSibling();
    1:       }
    1:       
    1:       // Set the table cell's initial child list
    1:       newFrame->SetInitialChildList(nsnull, newChildList.childList);
    1:     }
    1: 
    1:   } else if (IS_TABLE_CELL(frameType)) {
 8578:     // Warning: If you change this and add a wrapper frame around table cell
 8578:     // frames, make sure Bug 368554 doesn't regress!
 8578:     // See IsInAutoWidthTableCellForQuirk() in nsImageFrame.cpp.
    1:     newFrame = NS_NewTableCellFrame(shell, styleContext, IsBorderCollapse(aParentFrame));
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:       // Create a continuing area frame
23296:       nsIFrame* continuingBlockFrame;
23176:       nsIFrame* blockFrame = aFrame->GetFirstChild(nsnull);
23176:       rv = CreateContinuingFrame(aPresContext, blockFrame, newFrame,
23296:                                  &continuingBlockFrame);
    1:       if (NS_FAILED(rv)) {
    1:         newFrame->Destroy();
    1:         *aContinuingFrame = nsnull;
    1:         return rv;
    1:       }
    1: 
    1:       // Set the table cell's initial child list
23296:       newFrame->SetInitialChildList(nsnull, continuingBlockFrame);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::lineFrame == frameType) {
    1:     newFrame = NS_NewFirstLineFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::letterFrame == frameType) {
    1:     newFrame = NS_NewFirstLetterFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1: 
    1:   } else if (nsGkAtoms::imageFrame == frameType) {
    1:     newFrame = NS_NewImageFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
    1:     }
 9869:   } else if (nsGkAtoms::imageControlFrame == frameType) {
 9869:     newFrame = NS_NewImageControlFrame(shell, styleContext);
 9869: 
 9869:     if (newFrame) {
 9869:       newFrame->Init(content, aParentFrame, aFrame);
 9869:     }    
    1:   } else if (nsGkAtoms::placeholderFrame == frameType) {
    1:     // create a continuing out of flow frame
    1:     nsIFrame* oofFrame = nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
    1:     nsIFrame* oofContFrame;
    1:     rv = CreateContinuingFrame(aPresContext, oofFrame, aParentFrame, &oofContFrame);
    1:     if (NS_FAILED(rv)) {
    1:       *aContinuingFrame = nsnull;
    1:       return rv;
    1:     }
    1:     // create a continuing placeholder frame
 6219:     rv = CreatePlaceholderFrameFor(shell, content, oofContFrame, styleContext,
 6219:                                    aParentFrame, aFrame, &newFrame);
    1:     if (NS_FAILED(rv)) {
    1:       oofContFrame->Destroy();
    1:       *aContinuingFrame = nsnull;
    1:       return rv;
    1:     }
    1:   } else if (nsGkAtoms::fieldSetFrame == frameType) {
    1:     newFrame = NS_NewFieldSetFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
    1: 
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:       // Create a continuing area frame
    1:       // XXXbz we really shouldn't have to do this by hand!
23296:       nsIFrame* continuingBlockFrame;
23176:       nsIFrame* blockFrame = GetFieldSetBlockFrame(aFrame);
23176:       rv = CreateContinuingFrame(aPresContext, blockFrame, newFrame,
23296:                                  &continuingBlockFrame);
    1:       if (NS_FAILED(rv)) {
    1:         newFrame->Destroy();
    1:         *aContinuingFrame = nsnull;
    1:         return rv;
    1:       }
    1:       // Set the fieldset's initial child list
23296:       newFrame->SetInitialChildList(nsnull, continuingBlockFrame);
    1:     }
    1:   } else {
    1:     NS_NOTREACHED("unexpected frame type");
    1:     *aContinuingFrame = nsnull;
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   *aContinuingFrame = newFrame;
    1: 
    1:   if (!newFrame) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // Init() set newFrame to be a fluid continuation of aFrame.
    1:   // If we want a non-fluid continuation, we need to call SetPrevContinuation()
    1:   // to reset NS_FRAME_IS_FLUID_CONTINUATION.
    1:   if (!aIsFluid) {
    1:     newFrame->SetPrevContinuation(aFrame);
    1:   }
    1: 
    1:   // A continuation of generated content is also generated content
    1:   if (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) {
    1:     newFrame->AddStateBits(NS_FRAME_GENERATED_CONTENT);
    1:   }
    1: 
 6521:   // A continuation of an out-of-flow is also an out-of-flow
 6521:   if (aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
 6521:     newFrame->AddStateBits(NS_FRAME_OUT_OF_FLOW);
 6521:   }
 6521: 
    1:   if (nextInFlow) {
    1:     nextInFlow->SetPrevInFlow(newFrame);
    1:     newFrame->SetNextInFlow(nextInFlow);
    1:   } else if (nextContinuation) {
    1:     nextContinuation->SetPrevContinuation(newFrame);
    1:     newFrame->SetNextContinuation(nextContinuation);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
 4347: nsresult
 4347: nsCSSFrameConstructor::ReplicateFixedFrames(nsPageContentFrame* aParentFrame)
 4347: {
18953:   // Now deal with fixed-pos things....  They should appear on all pages,
18953:   // so we want to move over the placeholders when processing the child
18953:   // of the pageContentFrame.
 4347: 
 4347:   nsIFrame* prevPageContentFrame = aParentFrame->GetPrevInFlow();
    1:   if (!prevPageContentFrame) {
 4347:     return NS_OK;
 4347:   }
18953:   nsIFrame* canvasFrame = aParentFrame->GetFirstChild(nsnull);
18953:   nsIFrame* prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
18953:   if (!canvasFrame || !prevCanvasFrame) {
 4366:     // document's root element frame missing
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   nsFrameItems fixedPlaceholders;
    1:   nsIFrame* firstFixed = prevPageContentFrame->GetFirstChild(nsGkAtoms::fixedList);
    1:   if (!firstFixed) {
    1:     return NS_OK;
    1:   }
    1: 
 4347:   //XXXbz Should mInitialContainingBlock be docRootFrame? It probably doesn't matter.
 8933:   // Don't allow abs-pos descendants of the fixed content to escape the content.
 8933:   // This should not normally be possible (because fixed-pos elements should
 8933:   // be absolute containers) but fixed-pos tables currently aren't abs-pos
 8933:   // containers.
    1:   nsFrameConstructorState state(mPresShell, aParentFrame,
 8933:                                 nsnull,
    1:                                 mInitialContainingBlock);
    1: 
 4366:   // Iterate across fixed frames and replicate each whose placeholder is a
 4366:   // descendant of aFrame. (We don't want to explicitly copy placeholders that
 4366:   // are within fixed frames, because that would cause duplicates on the new
 4366:   // page - bug 389619)
    1:   for (nsIFrame* fixed = firstFixed; fixed; fixed = fixed->GetNextSibling()) {
 4366:     nsIFrame* prevPlaceholder = nsnull;
 4366:     mPresShell->GetPlaceholderFrameFor(fixed, &prevPlaceholder);
 4366:     if (prevPlaceholder &&
18953:         nsLayoutUtils::IsProperAncestorFrame(prevCanvasFrame, prevPlaceholder)) {
 4347:       nsresult rv = ConstructFrame(state, fixed->GetContent(),
18953:                                    canvasFrame, fixedPlaceholders);
 4347:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
 4366:   }
    1: 
    1:   // Add the placeholders to our primary child list.
18953:   // XXXbz this is a little screwed up, since the fixed frames will have 
18953:   // broken auto-positioning. Oh, well.
18953:   NS_ASSERTION(!canvasFrame->GetFirstChild(nsnull),
 4347:                "leaking frames; doc root continuation must be empty");
18953:   canvasFrame->SetInitialChildList(nsnull, fixedPlaceholders.childList);
    1:   return NS_OK;
    1: }
    1: 
 6719: static PRBool
 6719: IsBindingAncestor(nsIContent* aContent, nsIContent* aBindingRoot)
 6719: {
 6719:   while (PR_TRUE) {
16126:     // Native-anonymous content doesn't contain insertion points, so
16126:     // we don't need to search through it.
16126:     if (aContent->IsRootOfNativeAnonymousSubtree())
16126:       return PR_FALSE;
 6719:     nsIContent* bindingParent = aContent->GetBindingParent();
 6719:     if (!bindingParent)
 6719:       return PR_FALSE;
 6719:     if (bindingParent == aBindingRoot)
 6719:       return PR_TRUE;
 6719:     aContent = bindingParent;
 6719:   }
 6719: }
 6719: 
    1: // Helper function that searches the immediate child frames 
    1: // (and their children if the frames are "special")
    1: // for a frame that maps the specified content object
    1: nsIFrame*
    1: nsCSSFrameConstructor::FindFrameWithContent(nsFrameManager*  aFrameManager,
    1:                                             nsIFrame*        aParentFrame,
    1:                                             nsIContent*      aParentContent,
    1:                                             nsIContent*      aContent,
    1:                                             nsFindFrameHint* aHint)
    1: {
    1:   
    1: #ifdef NOISY_FINDFRAME
    1:   FFWC_totalCount++;
    1:   printf("looking for content=%p, given aParentFrame %p parentContent %p, hint is %s\n", 
    1:          aContent, aParentFrame, aParentContent, aHint ? "set" : "NULL");
    1: #endif
    1: 
    1:   NS_ENSURE_TRUE(aParentFrame != nsnull, nsnull);
    1: 
    1:   do {
    1:     // Search for the frame in each child list that aParentFrame supports
    1:     nsIAtom* listName = nsnull;
    1:     PRInt32 listIndex = 0;
    1:     PRBool searchAgain;
    1: 
    1:     do {
    1: #ifdef NOISY_FINDFRAME
    1:       FFWC_doLoop++;
    1: #endif
    1:       nsIFrame* kidFrame = nsnull;
    1: 
    1:       searchAgain = PR_FALSE;
    1: 
    1:       // if we were given an hint, try to use it here to find a good
    1:       // previous frame to start our search (|kidFrame|).
    1:       if (aHint) {
    1: #ifdef NOISY_FINDFRAME
    1:         printf("  hint frame is %p\n", aHint->mPrimaryFrameForPrevSibling);
    1: #endif
    1:         // start with the primary frame for aContent's previous sibling
    1:         kidFrame = aHint->mPrimaryFrameForPrevSibling;
    1:         // But if it's out of flow, start from its placeholder.
    1:         if (kidFrame && (kidFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
    1:           kidFrame = aFrameManager->GetPlaceholderFrameFor(kidFrame);
    1:         }
    1: 
    1:         if (kidFrame) {
    1:           // then use the next sibling frame as our starting point
    1:           if (kidFrame->GetNextSibling()) {
    1:             kidFrame = kidFrame->GetNextSibling();
    1:           }
    1:           else {
    1:             // The hint frame had no next sibling. Try the next-in-flow or
    1:             // special sibling of the parent of the hint frame (or its
    1:             // associated placeholder).
    1:             nsIFrame *parentFrame = kidFrame->GetParent();
    1:             kidFrame = nsnull;
    1:             if (parentFrame) {
   94:               parentFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(parentFrame);
    1:             }
    1:             if (parentFrame) {
    1:               // Found it, continue the search with its first child.
    1:               kidFrame = parentFrame->GetFirstChild(listName);
    1:               // Leave |aParentFrame| as-is, since the only time we'll
    1:               // reuse it is if the hint fails.
    1:             }
    1:           }
    1: #ifdef NOISY_FINDFRAME
    1:           printf("  hint gives us kidFrame=%p with parent frame %p content %p\n", 
    1:                   kidFrame, aParentFrame, aParentContent);
    1: #endif
    1:         }
    1:       }
    1:       if (!kidFrame) {  // we didn't have enough info to prune, start searching from the beginning
    1:         kidFrame = aParentFrame->GetFirstChild(listName);
    1:       }
    1:       while (kidFrame) {
    1:         // See if the child frame points to the content object we're
    1:         // looking for
    1:         nsIContent* kidContent = kidFrame->GetContent();
    1:         if (kidContent == aContent) {
    1: 
    1:           // We found a match.  Return the out-of-flow if it's a placeholder
    1:           return nsPlaceholderFrame::GetRealFrameFor(kidFrame);
    1:         }
    1: 
    1:         // only do this if there is content
    1:         if (kidContent) {
    1:           // We search the immediate children only, but if the child frame has
    1:           // the same content pointer as its parent then we need to search its
    1:           // child frames, too.
    1:           // We also need to search if the child content is anonymous and scoped
    1:           // to the parent content.
16126:           // XXXldb What makes us continue the search once we're inside
16126:           // the anonymous subtree?
    1:           if (aParentContent == kidContent ||
 6719:               (aParentContent && IsBindingAncestor(kidContent, aParentContent))) 
    1:           {
    1: #ifdef NOISY_FINDFRAME
    1:             FFWC_recursions++;
    1:             printf("  recursing with new parent set to kidframe=%p, parentContent=%p\n", 
    1:                    kidFrame, aParentContent);
    1: #endif
    1:             nsIFrame* matchingFrame =
 8406:                 FindFrameWithContent(aFrameManager,
 8406:                                      nsPlaceholderFrame::GetRealFrameFor(kidFrame),
    1:                                      aParentContent, aContent, nsnull);
    1: 
    1:             if (matchingFrame) {
    1:               return matchingFrame;
    1:             }
    1:           }
    1:         }
    1: 
    1:         // Get the next sibling frame
    1:         kidFrame = kidFrame->GetNextSibling();
    1: #ifdef NOISY_FINDFRAME
    1:         FFWC_doSibling++;
    1:         if (kidFrame) {
    1:           printf("  searching sibling frame %p\n", kidFrame);
    1:         }
    1: #endif
    1:       }
    1: 
    1:       if (aHint) {
    1:         // If we get here, and we had a hint, then we didn't find a frame.
    1:         // The hint may have been a frame whose location in the frame tree
    1:         // doesn't match the location of its corresponding element in the
    1:         // DOM tree, e.g. a floated or absolutely positioned frame, or e.g.
    1:         // a <col> frame, in which case we'd be off in the weeds looking
    1:         // through something other than the primary frame list.
    1:         // Reboot the search from scratch, without the hint, but using the
    1:         // null child list again.
    1:         aHint = nsnull;
    1:         searchAgain = PR_TRUE;
    1:       } else {
 8406:         do {
    1:           listName = aParentFrame->GetAdditionalChildListName(listIndex++);
 8406:         } while (IsOutOfFlowList(listName));
    1:       }
    1:     } while(listName || searchAgain);
    1: 
    1:     // We didn't find a matching frame. If aFrame has a next-in-flow,
    1:     // then continue looking there
   94:     aParentFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aParentFrame);
    1: #ifdef NOISY_FINDFRAME
    1:     if (aParentFrame) {
    1:       FFWC_nextInFlows++;
    1:       printf("  searching NIF frame %p\n", aParentFrame);
    1:     }
    1: #endif
    1:   } while (aParentFrame);
    1: 
    1:   // No matching frame
    1:   return nsnull;
    1: }
    1: 
    1: // Request to find the primary frame associated with a given content object.
    1: // This is typically called by the pres shell when there is no mapping in
    1: // the pres shell hash table
    1: nsresult
    1: nsCSSFrameConstructor::FindPrimaryFrameFor(nsFrameManager*  aFrameManager,
    1:                                            nsIContent*      aContent,
    1:                                            nsIFrame**       aFrame,
    1:                                            nsFindFrameHint* aHint)
    1: {
    1:   NS_ASSERTION(aFrameManager && aContent && aFrame, "bad arg");
    1: 
    1:   *aFrame = nsnull;  // initialize OUT parameter 
    1: 
    1:   // We want to be able to quickly map from a content object to its frame,
    1:   // but we also want to keep the hash table small. Therefore, many frames
    1:   // are not added to the hash table when they're first created:
    1:   // - text frames
    1:   // - inline frames (often things like FONT and B)
    1:   // - BR frames
    1:   // - internal table frames (row-group, row, cell, col-group, col)
    1:   //
    1:   // That means we need to need to search for the frame
    1:   nsIFrame*              parentFrame;   // this pointer is used to iterate across all frames that map to parentContent
    1: 
    1:   // Get the frame that corresponds to the parent content object.
    1:   // Note that this may recurse indirectly, because the pres shell will
    1:   // call us back if there is no mapping in the hash table
    1:   nsCOMPtr<nsIContent> parentContent = aContent->GetParent(); // Get this once
    1:   if (parentContent) {
    1:     parentFrame = aFrameManager->GetPrimaryFrameFor(parentContent, -1);
    1:     while (parentFrame) {
    1:       // Search the child frames for a match
    1:       *aFrame = FindFrameWithContent(aFrameManager, parentFrame,
    1:                                      parentContent, aContent, aHint);
    1: #ifdef NOISY_FINDFRAME
    1:       printf("FindFrameWithContent returned %p\n", *aFrame);
    1: #endif
    1: 
    1: #ifdef DEBUG
    1:       // if we're given a hint and we were told to verify, then compare the resulting frame with
    1:       // the frame we get by calling FindFrameWithContent *without* the hint.  
    1:       // Assert if they do not match
    1:       // Note that this makes finding frames *slower* than it was before the fix.
    1:       if (gVerifyFastFindFrame && aHint) 
    1:       {
    1: #ifdef NOISY_FINDFRAME
    1:         printf("VERIFYING...\n");
    1: #endif
    1:         nsIFrame *verifyTestFrame =
    1:             FindFrameWithContent(aFrameManager, parentFrame,
    1:                                  parentContent, aContent, nsnull);
    1: #ifdef NOISY_FINDFRAME
    1:         printf("VERIFY returned %p\n", verifyTestFrame);
    1: #endif
    1:         NS_ASSERTION(verifyTestFrame == *aFrame, "hint shortcut found wrong frame");
    1:       }
    1: #endif
    1:       // If we found a match, then add a mapping to the hash table so
    1:       // next time this will be quick
    1:       if (*aFrame) {
    1:         aFrameManager->SetPrimaryFrameFor(aContent, *aFrame);
    1:         break;
    1:       }
    1:       else if (IsFrameSpecial(parentFrame)) {
    1:         // If it's a "special" frame (that is, part of an inline
    1:         // that's been split because it contained a block), we need to
    1:         // follow the out-of-flow "special sibling" link, and search
    1:         // *that* subtree as well.
 4696:         parentFrame = GetSpecialSibling(parentFrame);
    1:       }
    1:       else {
    1:         break;
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (aHint && !*aFrame)
    1:   { // if we had a hint, and we didn't get a frame, see if we should try the slow way
    1:     if (aContent->IsNodeOfType(nsINode::eTEXT)) 
    1:     {
    1: #ifdef NOISY_FINDFRAME
    1:       FFWC_slowSearchForText++;
    1: #endif
    1:       // since we're passing in a null hint, we're guaranteed to only recurse once
    1:       return FindPrimaryFrameFor(aFrameManager, aContent, aFrame, nsnull);
    1:     }
    1:   }
    1: 
    1: #ifdef NOISY_FINDFRAME
    1:   printf("%10s %10s %10s %10s %10s \n", 
    1:          "total", "doLoop", "doSibling", "recur", "nextIF", "slowSearch");
    1:   printf("%10d %10d %10d %10d %10d \n", 
    1:          FFWC_totalCount, FFWC_doLoop, FFWC_doSibling, FFWC_recursions, 
    1:          FFWC_nextInFlows, FFWC_slowSearchForText);
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::GetInsertionPoint(nsIFrame*     aParentFrame,
    1:                                          nsIContent*   aChildContent,
    1:                                          nsIFrame**    aInsertionPoint,
    1:                                          PRBool*       aMultiple)
    1: {
    1:   // Make the insertion point be the parent frame by default, in case
    1:   // we have to bail early.
    1:   *aInsertionPoint = aParentFrame;
    1: 
    1:   nsIContent* container = aParentFrame->GetContent();
    1:   if (!container)
    1:     return NS_OK;
    1: 
    1:   nsBindingManager *bindingManager = mDocument->BindingManager();
    1: 
    1:   nsIContent* insertionElement;
    1:   if (aChildContent) {
    1:     // We've got an explicit insertion child. Check to see if it's
    1:     // anonymous.
    1:     if (aChildContent->GetBindingParent() == container) {
    1:       // This child content is anonymous. Don't use the insertion
    1:       // point, since that's only for the explicit kids.
    1:       return NS_OK;
    1:     }
    1: 
    1:     PRUint32 index;
    1:     insertionElement = bindingManager->GetInsertionPoint(container,
    1:                                                          aChildContent,
    1:                                                          &index);
    1:   }
    1:   else {
    1:     PRBool multiple;
    1:     PRUint32 index;
    1:     insertionElement = bindingManager->GetSingleInsertionPoint(container,
    1:                                                                &index,
    1:                                                                &multiple);
    1:     if (multiple && aMultiple)
    1:       *aMultiple = multiple; // Record the fact that filters are in use.
    1:   }
    1: 
    1:   if (insertionElement) {
    1:     nsIFrame* insertionPoint = mPresShell->GetPrimaryFrameFor(insertionElement);
    1:     if (insertionPoint) {
    1:       // Use the content insertion frame of the insertion point.
    1:       insertionPoint = insertionPoint->GetContentInsertionFrame();
    1:       if (insertionPoint && insertionPoint != aParentFrame) 
    1:         GetInsertionPoint(insertionPoint, aChildContent, aInsertionPoint, aMultiple);
    1:     }
    1:     else {
    1:       // There was no frame created yet for the insertion point.
    1:       *aInsertionPoint = nsnull;
    1:     }
    1:   }
    1: 
    1:   // fieldsets have multiple insertion points.  Note that we might
    1:   // have to look at insertionElement here...
    1:   if (aMultiple && !*aMultiple) {
    1:     nsIContent* content = insertionElement ? insertionElement : container;
    1:     if (content->IsNodeOfType(nsINode::eHTML) &&
    1:         content->Tag() == nsGkAtoms::fieldset) {
    1:       *aMultiple = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Capture state for the frame tree rooted at the frame associated with the
    1: // content object, aContent
    1: nsresult
    1: nsCSSFrameConstructor::CaptureStateForFramesOf(nsIContent* aContent,
    1:                                                nsILayoutHistoryState* aHistoryState)
    1: {
    1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
    1:   if (frame) {
    1:     CaptureStateFor(frame, aHistoryState);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Capture state for the frame tree rooted at aFrame.
    1: nsresult
    1: nsCSSFrameConstructor::CaptureStateFor(nsIFrame* aFrame,
    1:                                        nsILayoutHistoryState* aHistoryState)
    1: {
    1:   if (aFrame && aHistoryState) {
    1:     mPresShell->FrameManager()->CaptureFrameState(aFrame, aHistoryState);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::MaybeRecreateFramesForContent(nsIContent* aContent)
    1: {
    1:   nsresult result = NS_OK;
    1:   nsFrameManager *frameManager = mPresShell->FrameManager();
    1: 
    1:   nsStyleContext *oldContext = frameManager->GetUndisplayedContent(aContent);
    1:   if (oldContext) {
    1:     // The parent has a frame, so try resolving a new context.
    1:     nsRefPtr<nsStyleContext> newContext = mPresShell->StyleSet()->
    1:       ResolveStyleFor(aContent, oldContext->GetParent());
    1: 
    1:     frameManager->ChangeUndisplayedContent(aContent, newContext);
    1:     if (newContext->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_NONE) {
    1:       result = RecreateFramesForContent(aContent);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: PRBool
 4696: nsCSSFrameConstructor::MaybeRecreateContainerForIBSplitterFrame(nsIFrame* aFrame,
 4696:                                                                 nsresult* aResult)
 4696: {
 4696:   NS_PRECONDITION(aFrame, "Must have a frame");
 4696:   NS_PRECONDITION(aFrame->GetParent(), "Frame shouldn't be root");
 4696:   NS_PRECONDITION(aResult, "Null out param?");
 4696:   NS_PRECONDITION(aFrame == aFrame->GetFirstContinuation(),
 4696:                   "aFrame not the result of GetPrimaryFrameFor()?");
 4696: 
 4696:   if (IsFrameSpecial(aFrame)) {
 4696:     // The removal functions can't handle removal of an {ib} split directly; we
 4696:     // need to rebuild the containing block.
    1: #ifdef DEBUG
    1:     if (gNoisyContentUpdates) {
 4696:       printf("nsCSSFrameConstructor::MaybeRecreateContainerForIBSplitterFrame: "
 4696:              "frame=");
    1:       nsFrame::ListTag(stdout, aFrame);
    1:       printf(" is special\n");
    1:     }
    1: #endif
 4696: 
    1:     *aResult = ReframeContainingBlock(aFrame);
    1:     return PR_TRUE;
    1:   }
    1: 
 4696:   // We might still need to reconstruct things if the parent of aFrame is
 4696:   // special, since in that case the removal of aFrame might affect the
 4696:   // splitting of its parent.
 4696:   nsIFrame* parent = aFrame->GetParent();
 4696:   if (!IsFrameSpecial(parent)) {
 4696:     return PR_FALSE;
 4696:   }
 4696: 
 4717:   // If aFrame is an inline, then it cannot possibly have caused the splitting.
 4717:   // If the frame is being reconstructed and being changed to a block, the
 4717:   // ContentInserted call will handle the containing block reframe.  So in this
 4717:   // case, try to be conservative about whether we need to reframe.  The only
 4717:   // case when it's needed is if the inline is the only child of the tail end
 4717:   // of an {ib} split, because the splitting code doesn't produce this tail end
 4717:   // if it would have no kids.  If that ever changes, this code should change.
 4717:   if (IsInlineOutside(aFrame) &&
 4717:       (
 4717:        // Not a kid of the third part of the IB split
 4717:        GetSpecialSibling(parent) || !IsInlineOutside(parent) ||
 4717:        // Or not the only child
10780:        aFrame->GetTailContinuation()->GetNextSibling() ||
 4717:        aFrame != parent->GetFirstContinuation()->GetFirstChild(nsnull)
 4717:       )) {
 4717:     return PR_FALSE;
 4717:   }
 4717: 
 4696: #ifdef DEBUG
 5310:   if (gNoisyContentUpdates) {
 4696:     printf("nsCSSFrameConstructor::MaybeRecreateContainerForIBSplitterFrame: "
 4696:            "frame=");
 4696:     nsFrame::ListTag(stdout, parent);
 4696:     printf(" is special\n");
 4696:   }
 4696: #endif
 4696: 
 4696:   *aResult = ReframeContainingBlock(parent);
 4696:   return PR_TRUE;
 4696: }
 4696:  
    1: nsresult
    1: nsCSSFrameConstructor::RecreateFramesForContent(nsIContent* aContent)
    1: {
    1:   // If there is no document, we don't want to recreate frames for it.  (You
    1:   // shouldn't generally be giving this method content without a document
    1:   // anyway).
    1:   // Rebuilding the frame tree can have bad effects, especially if it's the
    1:   // frame tree for chrome (see bug 157322).
    1:   NS_ENSURE_TRUE(aContent->GetDocument(), NS_ERROR_FAILURE);
    1: 
    1:   // Is the frame `special'? If so, we need to reframe the containing
    1:   // block *here*, rather than trying to remove and re-insert the
    1:   // content (which would otherwise result in *two* nested reframe
    1:   // containing block from ContentRemoved() and ContentInserted(),
 4696:   // below!).  We'd really like to optimize away one of those
 4696:   // containing block reframes, hence the code here.
    1: 
    1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
 6862:   if (frame && frame->IsFrameOfType(nsIFrame::eMathML)) {
 6862:     // Reframe the topmost MathML element to prevent exponential blowup
 6862:     // (see bug 397518)
 6862:     while (PR_TRUE) {
 6862:       nsIContent* parentContent = aContent->GetParent();
 6862:       nsIFrame* parentContentFrame = mPresShell->GetPrimaryFrameFor(parentContent);
 6862:       if (!parentContentFrame || !parentContentFrame->IsFrameOfType(nsIFrame::eMathML))
 6862:         break;
 6862:       aContent = parentContent;
 6862:       frame = parentContentFrame;
 6862:     }
 6862:   }
    1: 
21943:   if (frame) {
21943:     nsIFrame* nonGeneratedAncestor = nsLayoutUtils::GetNonGeneratedAncestor(frame);
21943:     if (nonGeneratedAncestor->GetContent() != aContent) {
21943:       return RecreateFramesForContent(nonGeneratedAncestor->GetContent());
21943:     }
21943:   }
21943: 
    1:   nsresult rv = NS_OK;
    1: 
 4696:   if (frame && MaybeRecreateContainerForIBSplitterFrame(frame, &rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> container = aContent->GetParent();
    1:   if (container) {
    1:     // XXXbz what if this is anonymous content?
    1:     PRInt32 indexInContainer = container->IndexOf(aContent);
    1:     // Before removing the frames associated with the content object,
    1:     // ask them to save their state onto a temporary state object.
    1:     CaptureStateForFramesOf(aContent, mTempFrameTreeState);
    1: 
    1:     // Remove the frames associated with the content object on which
    1:     // the attribute change occurred.
 7681:     PRBool didReconstruct;
 7681:     rv = ContentRemoved(container, aContent, indexInContainer, &didReconstruct);
 7681: 
 7681:     if (NS_SUCCEEDED(rv) && !didReconstruct) {
 7681:       // Now, recreate the frames associated with this content object. If
 7681:       // ContentRemoved triggered reconstruction, then we don't need to do this
 7681:       // because the frames will already have been built.
    1:       rv = ContentInserted(container, aContent,
 4696:                            indexInContainer, mTempFrameTreeState);
    1:     }
    1:   } else {
    1:     // The content is the root node, so just rebuild the world.
    1:     ReconstructDocElementHierarchy();
    1:   }
    1: 
    1: #ifdef ACCESSIBILITY
    1:   if (mPresShell->IsAccessibilityActive()) {
    1:     PRUint32 event;
    1:     if (frame) {
    1:       nsIFrame *newFrame = mPresShell->GetPrimaryFrameFor(aContent);
 7113:       event = newFrame ? PRUint32(nsIAccessibleEvent::EVENT_ASYNCH_SIGNIFICANT_CHANGE) :
 7113:                          PRUint32(nsIAccessibleEvent::EVENT_ASYNCH_HIDE);
    1:     }
    1:     else {
 4516:       event = nsIAccessibleEvent::EVENT_ASYNCH_SHOW;
    1:     }
    1: 
    1:     // A significant enough change occured that this part
    1:     // of the accessible tree is no longer valid.
    1:     nsCOMPtr<nsIAccessibilityService> accService = 
    1:       do_GetService("@mozilla.org/accessibilityService;1");
    1:     if (accService) {
    1:       accService->InvalidateSubtreeFor(mPresShell, aContent, event);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
    1: //////////////////////////////////////////////////////////////////////
    1: 
    1: // Block frame construction code
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::GetFirstLetterStyle(nsIContent* aContent,
    1:                                            nsStyleContext* aStyleContext)
    1: {
    1:   if (aContent) {
    1:     return mPresShell->StyleSet()->
    1:       ResolvePseudoStyleFor(aContent,
    1:                             nsCSSPseudoElements::firstLetter, aStyleContext);
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::GetFirstLineStyle(nsIContent* aContent,
    1:                                          nsStyleContext* aStyleContext)
    1: {
    1:   if (aContent) {
    1:     return mPresShell->StyleSet()->
    1:       ResolvePseudoStyleFor(aContent,
    1:                             nsCSSPseudoElements::firstLine, aStyleContext);
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: // Predicate to see if a given content (block element) has
    1: // first-letter style applied to it.
    1: PRBool
 1254: nsCSSFrameConstructor::ShouldHaveFirstLetterStyle(nsIContent* aContent,
    1:                                                   nsStyleContext* aStyleContext)
    1: {
    1:   return nsLayoutUtils::HasPseudoStyle(aContent, aStyleContext,
    1:                                        nsCSSPseudoElements::firstLetter,
    1:                                        mPresShell->GetPresContext());
    1: }
    1: 
    1: PRBool
 1254: nsCSSFrameConstructor::HasFirstLetterStyle(nsIFrame* aBlockFrame)
  551: {
  551:   NS_PRECONDITION(aBlockFrame, "Need a frame");
15909:   NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlockFrame),
  551:                "Not a block frame?");
  551: 
  551:   return (aBlockFrame->GetStateBits() & NS_BLOCK_HAS_FIRST_LETTER_STYLE) != 0;
  551: }
  551: 
  551: PRBool
 1254: nsCSSFrameConstructor::ShouldHaveFirstLineStyle(nsIContent* aContent,
    1:                                                 nsStyleContext* aStyleContext)
    1: {
16270:   PRBool hasFirstLine =
16270:     nsLayoutUtils::HasPseudoStyle(aContent, aStyleContext,
    1:                                   nsCSSPseudoElements::firstLine,
    1:                                   mPresShell->GetPresContext());
16270:   if (hasFirstLine) {
16270:     // But disable for fieldsets
16270:     PRInt32 namespaceID;
16270:     nsIAtom* tag = mDocument->BindingManager()->ResolveTag(aContent,
16270:                                                            &namespaceID);
23944:     // This check must match the one in FindHTMLData.
16270:     hasFirstLine = tag != nsGkAtoms::fieldset ||
16270:       (namespaceID != kNameSpaceID_XHTML &&
16270:        !aContent->IsNodeOfType(nsINode::eHTML));
16270:   }
16274: 
16274:   return hasFirstLine;
    1: }
    1: 
    1: void
 1254: nsCSSFrameConstructor::ShouldHaveSpecialBlockStyle(nsIContent* aContent,
    1:                                                    nsStyleContext* aStyleContext,
    1:                                                    PRBool* aHaveFirstLetterStyle,
    1:                                                    PRBool* aHaveFirstLineStyle)
    1: {
    1:   *aHaveFirstLetterStyle =
 1254:     ShouldHaveFirstLetterStyle(aContent, aStyleContext);
    1:   *aHaveFirstLineStyle =
 1254:     ShouldHaveFirstLineStyle(aContent, aStyleContext);
    1: }
    1: 
    1: /**
    1:  * Request to process the child content elements and create frames.
    1:  *
    1:  * @param   aContent the content object whose child elements to process
    1:  * @param   aFrame the frame associated with aContent. This will be the
    1:  *            parent frame (both content and geometric) for the flowed
    1:  *            child frames
    1:  */
    1: nsresult
    1: nsCSSFrameConstructor::ProcessChildren(nsFrameConstructorState& aState,
    1:                                        nsIContent*              aContent,
23352:                                        nsStyleContext*          aStyleContext,
    1:                                        nsIFrame*                aFrame,
    1:                                        PRBool                   aCanHaveGeneratedContent,
    1:                                        nsFrameItems&            aFrameItems,
23352:                                        PRBool                   aAllowBlockStyles)
23352: {
23352:   NS_PRECONDITION(aFrame, "Must have parent frame here");
23352:   NS_PRECONDITION(aFrame->GetContentInsertionFrame() == aFrame,
23352:                   "Parent frame in ProcessChildren should be its own "
23352:                   "content insertion frame");
23352: 
    1:   // XXXbz ideally, this would do all the pushing of various
    1:   // containing blocks as needed, so callers don't have to do it...
23343: 
23352:   PRBool haveFirstLetterStyle = PR_FALSE, haveFirstLineStyle = PR_FALSE;
23352:   if (aAllowBlockStyles) {
23352:     ShouldHaveSpecialBlockStyle(aContent, aStyleContext, &haveFirstLetterStyle,
23352:                                 &haveFirstLineStyle);
23352:   }
23352: 
23352:   // The logic here needs to match the logic in GetFloatContainingBlock()
23352:   nsFrameConstructorSaveState floatSaveState;
23352:   if (aFrame->IsFrameOfType(nsIFrame::eMathML) ||
23352:       aFrame->IsBoxFrame()) {
23352:     aState.PushFloatContainingBlock(nsnull, floatSaveState);
23352:   } else if (aFrame->IsFloatContainingBlock()) {
23352:     aState.PushFloatContainingBlock(aFrame, floatSaveState);
23352:   }
    1: 
    1:   // save the incoming pseudo frame state
    1:   nsPseudoFrames priorPseudoFrames;
    1:   aState.mPseudoFrames.Reset(&priorPseudoFrames);
    1: 
23343:   if (aFrame == mInitialContainingBlock) {
23343:     // Create any anonymous frames the initial containing block frame requires.
23343:     // This must happen before the rest of ProcessChildren to ensure that
23343:     // popups are never constructed before the popupset.
23343:     CreateAnonymousFrames(nsnull, aState, aContent, aFrame, aFrameItems,
23343:                           PR_TRUE);
23343:   }
23343: 
23167:   nsresult rv = NS_OK;
23420:   if (!aFrame->IsLeaf() &&
23420:       mDocument->BindingManager()->ShouldBuildChildFrames(aContent)) {
23167:     // :before/:after content should have the same style context parent
23167:     // as normal kids.
23352:     // Note that we don't use this style context for looking up things like
23352:     // special block styles because in some cases involving table pseudo-frames
23352:     // it has nothing to do with the parent frame's desired behavior.
23167:     nsStyleContext* styleContext =
23167:       nsFrame::CorrectStyleParentFrame(aFrame, nsnull)->GetStyleContext();
23167: 
16976:     if (aCanHaveGeneratedContent) {
16976:       // Probe for generated content before
16976:       CreateGeneratedContentFrame(aState, aFrame, aContent,
16976:                                   styleContext, nsCSSPseudoElements::before,
16976:                                   aFrameItems);
16976:     }
16976: 
    1:     ChildIterator iter, last;
    1:     for (ChildIterator::Init(aContent, &iter, &last);
    1:          iter != last;
    1:          ++iter) {
    1:       rv = ConstructFrame(aState, nsCOMPtr<nsIContent>(*iter),
    1:                           aFrame, aFrameItems);
    1:       if (NS_FAILED(rv))
    1:         return rv;
    1:     }
    1: 
16976:     if (aCanHaveGeneratedContent) {
16976:       // Probe for generated content after
16976:       CreateGeneratedContentFrame(aState, aFrame, aContent,
16976:                                   styleContext, nsCSSPseudoElements::after,
16976:                                   aFrameItems);
16976:     }
23343:   }
23343: 
23343:   if (aFrame != mInitialContainingBlock) {
23343:     CreateAnonymousFrames(aContent->Tag(), aState, aContent, aFrame,
23343:                           aFrameItems);
23343:   }
16976: 
    1:   // process the current pseudo frame state
    1:   if (!aState.mPseudoFrames.IsEmpty()) {
    1:     ProcessPseudoFrames(aState, aFrameItems);
    1:   }
    1: 
    1:   // restore the incoming pseudo frame state
    1:   aState.mPseudoFrames = priorPseudoFrames;
    1: 
23352:   NS_ASSERTION(!aAllowBlockStyles || !aFrame->IsBoxFrame(),
22859:                "can't be both block and box");
22859: 
23352:   if (haveFirstLetterStyle) {
23461:     rv = WrapFramesInFirstLetterFrame(aContent, aFrame, aFrameItems);
23167:   }
23352:   if (haveFirstLineStyle) {
    1:     rv = WrapFramesInFirstLineFrame(aState, aContent, aFrame, aFrameItems);
    1:   }
    1: 
22859:   nsIContent *badKid;
22859:   if (aFrame->IsBoxFrame() &&
22859:       (badKid = AnyKidsNeedBlockParent(aFrameItems.childList))) {
22859:     nsAutoString parentTag, kidTag;
22859:     aContent->Tag()->ToString(parentTag);
22859:     badKid->Tag()->ToString(kidTag);
22859:     const PRUnichar* params[] = { parentTag.get(), kidTag.get() };
22859:     nsStyleContext *frameStyleContext = aFrame->GetStyleContext();
22859:     const nsStyleDisplay *display = frameStyleContext->GetStyleDisplay();
22859:     const char *message =
22859:       (display->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX)
22859:         ? "NeededToWrapXULInlineBox" : "NeededToWrapXUL";
22859:     nsContentUtils::ReportToConsole(nsContentUtils::eXUL_PROPERTIES,
22859:                                     message,
22859:                                     params, NS_ARRAY_LENGTH(params),
22859:                                     mDocument->GetDocumentURI(),
22859:                                     EmptyString(), 0, 0, // not useful
22859:                                     nsIScriptError::warningFlag,
22859:                                     "FrameConstructor");
22859: 
22859:     nsRefPtr<nsStyleContext> blockSC = mPresShell->StyleSet()->
22859:       ResolvePseudoStyleFor(aContent,
22859:                             nsCSSAnonBoxes::mozXULAnonymousBlock,
22859:                             frameStyleContext);
22859:     nsIFrame *blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
23305:     // We might, in theory, want to set NS_BLOCK_FLOAT_MGR and
22859:     // NS_BLOCK_MARGIN_ROOT, but I think it's a bad idea given that
22859:     // a real block placed here wouldn't get those set on it.
22859: 
22859:     InitAndRestoreFrame(aState, aContent, aFrame, nsnull,
22859:                         blockFrame, PR_FALSE);
22859: 
22859:     NS_ASSERTION(!blockFrame->HasView(), "need to do view reparenting");
22859:     for (nsIFrame *f = aFrameItems.childList; f; f = f->GetNextSibling()) {
22859:       ReparentFrame(aState.mFrameManager, blockFrame, f);
22859:     }
22859: 
22859:     blockFrame->AppendFrames(nsnull, aFrameItems.childList);
22859:     aFrameItems = nsFrameItems();
22859:     aFrameItems.AddChild(blockFrame);
22859: 
22859:     aFrame->AddStateBits(NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK);
22859:   }
22859: 
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Support for :first-line style
    1: 
    1: // Special routine to handle placing a list of frames into a block
    1: // frame that has first-line style. The routine ensures that the first
    1: // collection of inline frames end up in a first-line frame.
23461: // NOTE: aState may have containing block information related to a
23461: // different part of the frame tree than where the first line occurs.
23461: // In particular aState may be set up for where ContentInserted or
23461: // ContentAppended is inserting content, which may be some
23461: // non-first-in-flow continuation of the block to which the first-line
23461: // belongs. So this function needs to be careful about how it uses
23461: // aState.
    1: nsresult
    1: nsCSSFrameConstructor::WrapFramesInFirstLineFrame(
    1:   nsFrameConstructorState& aState,
    1:   nsIContent*              aBlockContent,
    1:   nsIFrame*                aBlockFrame,
    1:   nsFrameItems&            aFrameItems)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   // Find the first and last inline frame in aFrameItems
    1:   nsIFrame* kid = aFrameItems.childList;
    1:   nsIFrame* firstInlineFrame = nsnull;
    1:   nsIFrame* lastInlineFrame = nsnull;
    1:   while (kid) {
 2829:     if (IsInlineOutside(kid)) {
    1:       if (!firstInlineFrame) firstInlineFrame = kid;
    1:       lastInlineFrame = kid;
    1:     }
    1:     else {
    1:       break;
    1:     }
    1:     kid = kid->GetNextSibling();
    1:   }
    1: 
    1:   // If we don't find any inline frames, then there is nothing to do
    1:   if (!firstInlineFrame) {
    1:     return rv;
    1:   }
    1: 
    1:   // Create line frame
 7706:   nsStyleContext* parentStyle =
 7706:     nsFrame::CorrectStyleParentFrame(aBlockFrame,
 7706:                                      nsCSSPseudoElements::firstLine)->
 7706:       GetStyleContext();
    1:   nsRefPtr<nsStyleContext> firstLineStyle = GetFirstLineStyle(aBlockContent,
    1:                                                               parentStyle);
    1: 
    1:   nsIFrame* lineFrame = NS_NewFirstLineFrame(mPresShell, firstLineStyle);
    1: 
    1:   if (lineFrame) {
    1:     // Initialize the line frame
    1:     rv = InitAndRestoreFrame(aState, aBlockContent, aBlockFrame, nsnull,
    1:                              lineFrame);
    1: 
    1:     // Mangle the list of frames we are giving to the block: first
    1:     // chop the list in two after lastInlineFrame
    1:     nsIFrame* secondBlockFrame = lastInlineFrame->GetNextSibling();
    1:     lastInlineFrame->SetNextSibling(nsnull);
    1: 
    1:     // The lineFrame will be the block's first child; the rest of the
    1:     // frame list (after lastInlineFrame) will be the second and
    1:     // subsequent children; join the list together and reset
    1:     // aFrameItems appropriately.
    1:     if (secondBlockFrame) {
    1:       lineFrame->SetNextSibling(secondBlockFrame);
    1:     }
    1:     if (aFrameItems.childList == lastInlineFrame) {
    1:       // Just in case the block had exactly one inline child
    1:       aFrameItems.lastChild = lineFrame;
    1:     }
    1:     aFrameItems.childList = lineFrame;
    1: 
    1:     // Give the inline frames to the lineFrame <b>after</b> reparenting them
    1:     kid = firstInlineFrame;
    1:     NS_ASSERTION(lineFrame->GetStyleContext() == firstLineStyle,
    1:                  "Bogus style context on line frame");
    1:     while (kid) {
    1:       ReparentFrame(aState.mFrameManager, lineFrame, kid);
    1:       kid = kid->GetNextSibling();
    1:     }
    1:     lineFrame->SetInitialChildList(nsnull, firstInlineFrame);
    1:   }
    1:   else {
    1:     rv = NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: // Special routine to handle appending a new frame to a block frame's
    1: // child list. Takes care of placing the new frame into the right
    1: // place when first-line style is present.
    1: nsresult
    1: nsCSSFrameConstructor::AppendFirstLineFrames(
    1:   nsFrameConstructorState& aState,
    1:   nsIContent*              aBlockContent,
    1:   nsIFrame*                aBlockFrame,
    1:   nsFrameItems&            aFrameItems)
    1: {
    1:   // It's possible that aBlockFrame needs to have a first-line frame
    1:   // created because it doesn't currently have any children.
    1:   nsIFrame* blockKid = aBlockFrame->GetFirstChild(nsnull);
    1:   if (!blockKid) {
    1:     return WrapFramesInFirstLineFrame(aState, aBlockContent,
    1:                                       aBlockFrame, aFrameItems);
    1:   }
    1: 
    1:   // Examine the last block child - if it's a first-line frame then
    1:   // appended frames need special treatment.
    1:   nsresult rv = NS_OK;
    1:   nsFrameList blockFrames(blockKid);
    1:   nsIFrame* lastBlockKid = blockFrames.LastChild();
    1:   if (lastBlockKid->GetType() != nsGkAtoms::lineFrame) {
    1:     // No first-line frame at the end of the list, therefore there is
    1:     // an interveening block between any first-line frame the frames
    1:     // we are appending. Therefore, we don't need any special
    1:     // treatment of the appended frames.
    1:     return rv;
    1:   }
    1:   nsIFrame* lineFrame = lastBlockKid;
    1: 
    1:   // Find the first and last inline frame in aFrameItems
    1:   nsIFrame* kid = aFrameItems.childList;
    1:   nsIFrame* firstInlineFrame = nsnull;
    1:   nsIFrame* lastInlineFrame = nsnull;
    1:   while (kid) {
 2829:     if (IsInlineOutside(kid)) {
    1:       if (!firstInlineFrame) firstInlineFrame = kid;
    1:       lastInlineFrame = kid;
    1:     }
    1:     else {
    1:       break;
    1:     }
    1:     kid = kid->GetNextSibling();
    1:   }
    1: 
    1:   // If we don't find any inline frames, then there is nothing to do
    1:   if (!firstInlineFrame) {
    1:     return rv;
    1:   }
    1: 
    1:   // The inline frames get appended to the lineFrame. Make sure they
    1:   // are reparented properly.
    1:   nsIFrame* remainingFrames = lastInlineFrame->GetNextSibling();
    1:   lastInlineFrame->SetNextSibling(nsnull);
    1:   kid = firstInlineFrame;
    1:   while (kid) {
    1:     ReparentFrame(aState.mFrameManager, lineFrame, kid);
    1:     kid = kid->GetNextSibling();
    1:   }
    1:   aState.mFrameManager->AppendFrames(lineFrame, nsnull, firstInlineFrame);
    1: 
    1:   // The remaining frames get appended to the block frame
    1:   if (remainingFrames) {
    1:     aFrameItems.childList = remainingFrames;
    1:   }
    1:   else {
    1:     aFrameItems.childList = nsnull;
    1:     aFrameItems.lastChild = nsnull;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: // Special routine to handle inserting a new frame into a block
    1: // frame's child list. Takes care of placing the new frame into the
    1: // right place when first-line style is present.
    1: nsresult
    1: nsCSSFrameConstructor::InsertFirstLineFrames(
    1:   nsFrameConstructorState& aState,
    1:   nsIContent*              aContent,
    1:   nsIFrame*                aBlockFrame,
    1:   nsIFrame**               aParentFrame,
    1:   nsIFrame*                aPrevSibling,
    1:   nsFrameItems&            aFrameItems)
    1: {
    1:   nsresult rv = NS_OK;
    1:   // XXXbz If you make this method actually do something, check to make sure
    1:   // that the caller is passing what you expect.  In particular, which content
    1:   // is aContent?
    1: #if 0
    1:   nsIFrame* parentFrame = *aParentFrame;
    1:   nsIFrame* newFrame = aFrameItems.childList;
 2829:   PRBool isInline = IsInlineOutside(newFrame);
    1: 
    1:   if (!aPrevSibling) {
    1:     // Insertion will become the first frame. Two cases: we either
    1:     // already have a first-line frame or we don't.
    1:     nsIFrame* firstBlockKid = aBlockFrame->GetFirstChild(nsnull);
    1:     if (firstBlockKid->GetType() == nsGkAtoms::lineFrame) {
    1:       // We already have a first-line frame
    1:       nsIFrame* lineFrame = firstBlockKid;
    1: 
    1:       if (isInline) {
    1:         // Easy case: the new inline frame will go into the lineFrame.
    1:         ReparentFrame(aState.mFrameManager, lineFrame, newFrame);
    1:         aState.mFrameManager->InsertFrames(lineFrame, nsnull, nsnull,
    1:                                            newFrame);
    1: 
    1:         // Since the frame is going into the lineFrame, don't let it
    1:         // go into the block too.
    1:         aFrameItems.childList = nsnull;
    1:         aFrameItems.lastChild = nsnull;
    1:       }
    1:       else {
    1:         // Harder case: We are about to insert a block level element
    1:         // before the first-line frame.
    1:         // XXX need a method to steal away frames from the line-frame
    1:       }
    1:     }
    1:     else {
    1:       // We do not have a first-line frame
    1:       if (isInline) {
    1:         // We now need a first-line frame to contain the inline frame.
    1:         nsIFrame* lineFrame = NS_NewFirstLineFrame(firstLineStyle);
    1:         if (!lineFrame) {
    1:           rv = NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1: 
    1:         if (NS_SUCCEEDED(rv)) {
    1:           // Lookup first-line style context
 7706:           nsStyleContext* parentStyle =
 7706:             nsFrame::CorrectStyleParentFrame(aBlockFrame,
 7706:                                              nsCSSPseudoElements::firstLine)->
 7706:               GetStyleContext();
    1:           nsRefPtr<nsStyleContext> firstLineStyle =
    1:             GetFirstLineStyle(aContent, parentStyle);
    1: 
    1:           // Initialize the line frame
    1:           rv = InitAndRestoreFrame(aState, aContent, aBlockFrame,
    1:                                    nsnull, lineFrame);
    1: 
    1:           // Make sure the caller inserts the lineFrame into the
    1:           // blocks list of children.
    1:           aFrameItems.childList = lineFrame;
    1:           aFrameItems.lastChild = lineFrame;
    1: 
    1:           // Give the inline frames to the lineFrame <b>after</b>
    1:           // reparenting them
    1:           NS_ASSERTION(lineFrame->GetStyleContext() == firstLineStyle,
    1:                        "Bogus style context on line frame");
    1:           ReparentFrame(aPresContext, lineFrame, newFrame);
    1:           lineFrame->SetInitialChildList(nsnull, newFrame);
    1:         }
    1:       }
    1:       else {
    1:         // Easy case: the regular insertion logic can insert the new
    1:         // frame because it's a block frame.
    1:       }
    1:     }
    1:   }
    1:   else {
    1:     // Insertion will not be the first frame.
    1:     nsIFrame* prevSiblingParent = aPrevSibling->GetParent();
    1:     if (prevSiblingParent == aBlockFrame) {
    1:       // Easy case: The prev-siblings parent is the block
    1:       // frame. Therefore the prev-sibling is not currently in a
    1:       // line-frame. Therefore the new frame which is going after it,
    1:       // regardless of type, is not going into a line-frame.
    1:     }
    1:     else {
    1:       // If the prevSiblingParent is not the block-frame then it must
    1:       // be a line-frame (if it were a letter-frame, that logic would
    1:       // already have adjusted the prev-sibling to be the
    1:       // letter-frame).
    1:       if (isInline) {
    1:         // Easy case: the insertion can go where the caller thinks it
    1:         // should go (which is into prevSiblingParent).
    1:       }
    1:       else {
    1:         // Block elements don't end up in line-frames, therefore
    1:         // change the insertion point to aBlockFrame. However, there
    1:         // might be more inline elements following aPrevSibling that
    1:         // need to be pulled out of the line-frame and become children
    1:         // of the block.
    1:         nsIFrame* nextSibling = aPrevSibling->GetNextSibling();
    1:         nsIFrame* nextLineFrame = prevSiblingParent->GetNextInFlow();
    1:         if (nextSibling || nextLineFrame) {
    1:           // Oy. We have work to do. Create a list of the new frames
    1:           // that are going into the block by stripping them away from
    1:           // the line-frame(s).
    1:           nsFrameList list(nextSibling);
    1:           if (nextSibling) {
    1:             nsLineFrame* lineFrame = (nsLineFrame*) prevSiblingParent;
    1:             lineFrame->StealFramesFrom(nextSibling);
    1:           }
    1: 
    1:           nsLineFrame* nextLineFrame = (nsLineFrame*) lineFrame;
    1:           for (;;) {
    1:             nextLineFrame = nextLineFrame->GetNextInFlow();
    1:             if (!nextLineFrame) {
    1:               break;
    1:             }
    1:             nsIFrame* kids = nextLineFrame->GetFirstChild(nsnull);
    1:           }
    1:         }
    1:         else {
    1:           // We got lucky: aPrevSibling was the last inline frame in
    1:           // the line-frame.
    1:           ReparentFrame(aState.mFrameManager, aBlockFrame, newFrame);
    1:           aState.mFrameManager->InsertFrames(aBlockFrame, nsnull,
    1:                                              prevSiblingParent, newFrame);
    1:           aFrameItems.childList = nsnull;
    1:           aFrameItems.lastChild = nsnull;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // First-letter support
    1: 
    1: // Determine how many characters in the text fragment apply to the
    1: // first letter
    1: static PRInt32
    1: FirstLetterCount(const nsTextFragment* aFragment)
    1: {
    1:   PRInt32 count = 0;
    1:   PRInt32 firstLetterLength = 0;
    1:   PRBool done = PR_FALSE;
    1: 
    1:   PRInt32 i, n = aFragment->GetLength();
    1:   for (i = 0; i < n; i++) {
    1:     PRUnichar ch = aFragment->CharAt(i);
    1:     if (XP_IS_SPACE(ch)) {
    1:       if (firstLetterLength) {
    1:         done = PR_TRUE;
    1:         break;
    1:       }
    1:       count++;
    1:       continue;
    1:     }
    1:     // XXX I18n
    1:     if ((ch == '\'') || (ch == '\"')) {
    1:       if (firstLetterLength) {
    1:         done = PR_TRUE;
    1:         break;
    1:       }
    1:       // keep looping
    1:       firstLetterLength = 1;
    1:     }
    1:     else {
    1:       count++;
    1:       done = PR_TRUE;
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return count;
    1: }
    1: 
    1: static PRBool
    1: NeedFirstLetterContinuation(nsIContent* aContent)
    1: {
    1:   NS_PRECONDITION(aContent, "null ptr");
    1: 
    1:   PRBool result = PR_FALSE;
    1:   if (aContent) {
    1:     const nsTextFragment* frag = aContent->GetText();
    1:     if (frag) {
    1:       PRInt32 flc = FirstLetterCount(frag);
    1:       PRInt32 tl = frag->GetLength();
    1:       if (flc < tl) {
    1:         result = PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: static PRBool IsFirstLetterContent(nsIContent* aContent)
    1: {
    1:   return aContent->TextLength() &&
    1:          !aContent->TextIsOnlyWhitespace();
    1: }
    1: 
    1: /**
    1:  * Create a letter frame, only make it a floating frame.
    1:  */
    1: void
    1: nsCSSFrameConstructor::CreateFloatingLetterFrame(
    1:   nsFrameConstructorState& aState,
    1:   nsIFrame* aBlockFrame,
    1:   nsIContent* aTextContent,
    1:   nsIFrame* aTextFrame,
    1:   nsIContent* aBlockContent,
    1:   nsIFrame* aParentFrame,
    1:   nsStyleContext* aStyleContext,
    1:   nsFrameItems& aResult)
    1: {
    1:   // Create the first-letter-frame
    1:   nsresult rv;
    1:   nsIFrame* letterFrame;
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1: 
    1:   letterFrame = NS_NewFirstLetterFrame(mPresShell, aStyleContext);
    1:   // We don't want to use a text content for a non-text frame (because we want
    1:   // its primary frame to be a text frame).  So use its parent for the
    1:   // first-letter.
    1:   nsIContent* letterContent = aTextContent->GetParent();
    1:   InitAndRestoreFrame(aState, letterContent,
    1:                       aState.GetGeometricParent(aStyleContext->GetStyleDisplay(),
    1:                                                 aParentFrame),
    1:                       nsnull, letterFrame);
    1: 
    1:   // Init the text frame to refer to the letter frame. Make sure we
    1:   // get a proper style context for it (the one passed in is for the
    1:   // letter frame and will have the float property set on it; the text
    1:   // frame shouldn't have that set).
    1:   nsRefPtr<nsStyleContext> textSC;
    1:   textSC = styleSet->ResolveStyleForNonElement(aStyleContext);
    1:   aTextFrame->SetStyleContextWithoutNotification(textSC);
    1:   InitAndRestoreFrame(aState, aTextContent, letterFrame, nsnull, aTextFrame);
    1: 
    1:   // And then give the text frame to the letter frame
    1:   letterFrame->SetInitialChildList(nsnull, aTextFrame);
    1: 
    1:   // See if we will need to continue the text frame (does it contain
    1:   // more than just the first-letter text or not?) If it does, then we
    1:   // create (in advance) a continuation frame for it.
    1:   nsIFrame* nextTextFrame = nsnull;
    1:   if (NeedFirstLetterContinuation(aTextContent)) {
    1:     // Create continuation
    1:     rv = CreateContinuingFrame(aState.mPresContext, aTextFrame, aParentFrame,
    1:                                &nextTextFrame);
    1:     if (NS_FAILED(rv)) {
    1:       letterFrame->Destroy();
    1:       return;
    1:     }
    1:     // Repair the continuations style context
    1:     nsStyleContext* parentStyleContext = aStyleContext->GetParent();
    1:     if (parentStyleContext) {
    1:       nsRefPtr<nsStyleContext> newSC;
    1:       newSC = styleSet->ResolveStyleForNonElement(parentStyleContext);
    1:       if (newSC) {
    1:         nextTextFrame->SetStyleContext(newSC);
    1:       }
    1:     }
    1:   }
    1: 
    1:   NS_ASSERTION(aResult.childList == nsnull,
    1:                "aResult should be an empty nsFrameItems!");
    1:   nsIFrame* insertAfter = nsnull;
    1:   nsIFrame* f;
    1:   // Put the new float before any of the floats in the block we're
    1:   // doing first-letter for, that is, before any floats whose parent is aBlockFrame
    1:   for (f = aState.mFloatedItems.childList; f; f = f->GetNextSibling()) {
    1:     if (f->GetParent() == aBlockFrame)
    1:       break;
    1:     insertAfter = f;
    1:   }
    1: 
 8199:   rv = aState.AddChild(letterFrame, aResult, letterContent, aStyleContext,
 8199:                        aParentFrame, PR_FALSE, PR_TRUE, PR_FALSE, PR_TRUE,
 8199:                        insertAfter);
    1: 
    1:   if (nextTextFrame) {
    1:     if (NS_FAILED(rv)) {
    1:       nextTextFrame->Destroy();
    1:     } else {
    1:       aResult.AddChild(nextTextFrame);
    1:     }
    1:   }
    1: }
    1: 
    1: /**
    1:  * Create a new letter frame for aTextFrame. The letter frame will be
    1:  * a child of aParentFrame.
    1:  */
    1: nsresult
23461: nsCSSFrameConstructor::CreateLetterFrame(nsIFrame* aBlockFrame,
    1:                                          nsIContent* aTextContent,
    1:                                          nsIFrame* aParentFrame,
    1:                                          nsFrameItems& aResult)
    1: {
    1:   NS_PRECONDITION(aTextContent->IsNodeOfType(nsINode::eTEXT),
    1:                   "aTextContent isn't text");
15909:   NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlockFrame),
  551:                  "Not a block frame?");
  551: 
    1:   // Get style context for the first-letter-frame
 7706:   nsStyleContext* parentStyleContext =
 7706:     nsFrame::CorrectStyleParentFrame(aParentFrame,
 7706:                                      nsCSSPseudoElements::firstLetter)->
 7706:       GetStyleContext();
23461: 
    1:   // Use content from containing block so that we can actually
    1:   // find a matching style rule.
23461:   nsIContent* blockContent = aBlockFrame->GetContent();
    1: 
    1:   // Create first-letter style rule
    1:   nsRefPtr<nsStyleContext> sc = GetFirstLetterStyle(blockContent,
    1:                                                     parentStyleContext);
    1:   if (sc) {
    1:     nsRefPtr<nsStyleContext> textSC;
    1:     textSC = mPresShell->StyleSet()->ResolveStyleForNonElement(sc);
    1:     
    1:     // Create a new text frame (the original one will be discarded)
    1:     // pass a temporary stylecontext, the correct one will be set later
    1:     nsIFrame* textFrame = NS_NewTextFrame(mPresShell, textSC);
    1: 
23461:     NS_ASSERTION(aBlockFrame == GetFloatContainingBlock(aParentFrame),
23461:                  "Containing block is confused");
23461:     nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
23461:                                   GetAbsoluteContainingBlock(aParentFrame),
23461:                                   aBlockFrame);
23461: 
    1:     // Create the right type of first-letter frame
    1:     const nsStyleDisplay* display = sc->GetStyleDisplay();
    1:     if (display->IsFloating()) {
    1:       // Make a floating first-letter frame
23461:       CreateFloatingLetterFrame(state, aBlockFrame, aTextContent, textFrame,
    1:                                 blockContent, aParentFrame,
    1:                                 sc, aResult);
    1:     }
    1:     else {
    1:       // Make an inflow first-letter frame
    1:       nsIFrame* letterFrame = NS_NewFirstLetterFrame(mPresShell, sc);
    1: 
    1:       if (letterFrame) {
    1:         // Initialize the first-letter-frame.  We don't want to use a text
    1:         // content for a non-text frame (because we want its primary frame to
    1:         // be a text frame).  So use its parent for the first-letter.
    1:         nsIContent* letterContent = aTextContent->GetParent();
    1:         letterFrame->Init(letterContent, aParentFrame, nsnull);
    1: 
23461:         InitAndRestoreFrame(state, aTextContent, letterFrame, nsnull,
    1:                             textFrame);
    1: 
    1:         letterFrame->SetInitialChildList(nsnull, textFrame);
    1:         aResult.childList = aResult.lastChild = letterFrame;
 8759:         aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_CHILD);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::WrapFramesInFirstLetterFrame(
    1:   nsIContent*              aBlockContent,
    1:   nsIFrame*                aBlockFrame,
    1:   nsFrameItems&            aBlockFrames)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
  551:   aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_STYLE);
  551: 
    1:   nsIFrame* parentFrame = nsnull;
    1:   nsIFrame* textFrame = nsnull;
    1:   nsIFrame* prevFrame = nsnull;
    1:   nsFrameItems letterFrames;
    1:   PRBool stopLooking = PR_FALSE;
23461:   rv = WrapFramesInFirstLetterFrame(aBlockFrame, aBlockFrame,
    1:                                     aBlockFrames.childList,
    1:                                     &parentFrame, &textFrame, &prevFrame,
    1:                                     letterFrames, &stopLooking);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   if (parentFrame) {
    1:     if (parentFrame == aBlockFrame) {
    1:       // Text textFrame out of the blocks frame list and substitute the
    1:       // letter frame(s) instead.
    1:       nsIFrame* nextSibling = textFrame->GetNextSibling();
    1:       textFrame->SetNextSibling(nsnull);
    1:       if (prevFrame) {
    1:         prevFrame->SetNextSibling(letterFrames.childList);
    1:       }
    1:       else {
    1:         aBlockFrames.childList = letterFrames.childList;
    1:       }
    1:       letterFrames.lastChild->SetNextSibling(nextSibling);
    1: 
    1:       // Destroy the old textFrame
    1:       textFrame->Destroy();
    1: 
    1:       // Repair lastChild; the only time this needs to happen is when
    1:       // the block had one child (the text frame).
    1:       if (!nextSibling) {
    1:         aBlockFrames.lastChild = letterFrames.lastChild;
    1:       }
    1:     }
    1:     else {
    1:       // Take the old textFrame out of the inline parents child list
23461:       ::DeletingFrameSubtree(mPresShell->FrameManager(), textFrame);
    1:       parentFrame->RemoveFrame(nsnull, textFrame);
    1: 
    1:       // Insert in the letter frame(s)
    1:       parentFrame->InsertFrames(nsnull, prevFrame, letterFrames.childList);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::WrapFramesInFirstLetterFrame(
    1:   nsIFrame*                aBlockFrame,
    1:   nsIFrame*                aParentFrame,
    1:   nsIFrame*                aParentFrameList,
    1:   nsIFrame**               aModifiedParent,
    1:   nsIFrame**               aTextFrame,
    1:   nsIFrame**               aPrevFrame,
    1:   nsFrameItems&            aLetterFrames,
    1:   PRBool*                  aStopLooking)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsIFrame* prevFrame = nsnull;
    1:   nsIFrame* frame = aParentFrameList;
    1: 
    1:   while (frame) {
    1:     nsIFrame* nextFrame = frame->GetNextSibling();
    1: 
16291:     nsIAtom* frameType = frame->GetType();
16291:     if (nsGkAtoms::textFrame == frameType) {
    1:       // Wrap up first-letter content in a letter frame
    1:       nsIContent* textContent = frame->GetContent();
    1:       if (IsFirstLetterContent(textContent)) {
    1:         // Create letter frame to wrap up the text
23461:         rv = CreateLetterFrame(aBlockFrame, textContent,
    1:                                aParentFrame, aLetterFrames);
    1:         if (NS_FAILED(rv)) {
    1:           return rv;
    1:         }
    1: 
    1:         // Provide adjustment information for parent
    1:         *aModifiedParent = aParentFrame;
    1:         *aTextFrame = frame;
    1:         *aPrevFrame = prevFrame;
    1:         *aStopLooking = PR_TRUE;
    1:         return NS_OK;
    1:       }
    1:     }
16291:     else if (IsInlineFrame(frame) && frameType != nsGkAtoms::brFrame) {
    1:       nsIFrame* kids = frame->GetFirstChild(nsnull);
23461:       WrapFramesInFirstLetterFrame(aBlockFrame, frame, kids,
    1:                                    aModifiedParent, aTextFrame,
    1:                                    aPrevFrame, aLetterFrames, aStopLooking);
    1:       if (*aStopLooking) {
    1:         return NS_OK;
    1:       }
    1:     }
    1:     else {
    1:       // This will stop us looking to create more letter frames. For
    1:       // example, maybe the frame-type is "letterFrame" or
    1:       // "placeholderFrame". This keeps us from creating extra letter
    1:       // frames, and also prevents us from creating letter frames when
    1:       // the first real content child of a block is not text (e.g. an
    1:       // image, hr, etc.)
    1:       *aStopLooking = PR_TRUE;
    1:       break;
    1:     }
    1: 
    1:     prevFrame = frame;
    1:     frame = nextFrame;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::RemoveFloatingFirstLetterFrames(
    1:   nsPresContext* aPresContext,
    1:   nsIPresShell* aPresShell,
    1:   nsFrameManager* aFrameManager,
    1:   nsIFrame* aBlockFrame,
    1:   PRBool* aStopLooking)
    1: {
    1:   // First look for the float frame that is a letter frame
    1:   nsIFrame* floatFrame = aBlockFrame->GetFirstChild(nsGkAtoms::floatList);
    1:   while (floatFrame) {
    1:     // See if we found a floating letter frame
    1:     if (nsGkAtoms::letterFrame == floatFrame->GetType()) {
    1:       break;
    1:     }
    1:     floatFrame = floatFrame->GetNextSibling();
    1:   }
    1:   if (!floatFrame) {
    1:     // No such frame
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Take the text frame away from the letter frame (so it isn't
    1:   // destroyed when we destroy the letter frame).
    1:   nsIFrame* textFrame = floatFrame->GetFirstChild(nsnull);
    1:   if (!textFrame) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Discover the placeholder frame for the letter frame
    1:   nsIFrame* parentFrame;
    1:   nsPlaceholderFrame* placeholderFrame = 
    1:     aFrameManager->GetPlaceholderFrameFor(floatFrame);
    1: 
    1:   if (!placeholderFrame) {
    1:     // Somethings really wrong
    1:     return NS_OK;
    1:   }
    1:   parentFrame = placeholderFrame->GetParent();
    1:   if (!parentFrame) {
    1:     // Somethings really wrong
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Create a new text frame with the right style context that maps
    1:   // all of the content that was previously part of the letter frame
    1:   // (and probably continued elsewhere).
    1:   nsStyleContext* parentSC = parentFrame->GetStyleContext();
    1:   if (!parentSC) {
    1:     return NS_OK;
    1:   }
    1:   nsIContent* textContent = textFrame->GetContent();
    1:   if (!textContent) {
    1:     return NS_OK;
    1:   }
    1:   nsRefPtr<nsStyleContext> newSC;
    1:   newSC = aPresShell->StyleSet()->ResolveStyleForNonElement(parentSC);
    1:   if (!newSC) {
    1:     return NS_OK;
    1:   }
    1:   nsIFrame* newTextFrame = NS_NewTextFrame(aPresShell, newSC);
    1:   if (NS_UNLIKELY(!newTextFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;;
    1:   }
    1:   newTextFrame->Init(textContent, parentFrame, nsnull);
    1: 
    1:   // Destroy the old text frame's continuations (the old text frame
    1:   // will be destroyed when its letter frame is destroyed).
22202:   nsIFrame* nextTextFrame = textFrame->GetNextContinuation();
22202:   while (nextTextFrame) {
    1:     nsIFrame* nextTextParent = nextTextFrame->GetParent();
    1:     if (nextTextParent) {
22202:       nsSplittableFrame::RemoveFromFlow(nextTextFrame);
    1:       ::DeletingFrameSubtree(aFrameManager, nextTextFrame);
    1:       aFrameManager->RemoveFrame(nextTextParent, nsnull, nextTextFrame);
    1:     }
22202:     nextTextFrame = textFrame->GetNextContinuation();
    1:   }
    1: 
    1:   // First find out where (in the content) the placeholder frames
    1:   // text is and its previous sibling frame, if any.  Note that:
    1:   // 1)  The placeholder had better be in the principal child list of
    1:   //     parentFrame.
    1:   // 2)  It's probably near the beginning (since we're a first-letter frame),
    1:   //     so just doing a linear search for the prevSibling is ok.
    1:   // 3)  Trying to use FindPreviousSibling will fail if the first-letter is in
    1:   //     anonymous content (eg generated content).
    1:   nsFrameList siblingList(parentFrame->GetFirstChild(nsnull));
    1:   NS_ASSERTION(siblingList.ContainsFrame(placeholderFrame),
    1:                "Placeholder not in parent's principal child list?");
    1:   nsIFrame* prevSibling = siblingList.GetPrevSiblingFor(placeholderFrame);
    1: 
    1:   // Now that everything is set...
    1: #ifdef NOISY_FIRST_LETTER
    1:   printf("RemoveFloatingFirstLetterFrames: textContent=%p oldTextFrame=%p newTextFrame=%p\n",
    1:          textContent.get(), textFrame, newTextFrame);
    1: #endif
 4162: 
 4162:   UnregisterPlaceholderChain(aFrameManager, placeholderFrame);
    1: 
    1:   // Remove the float frame
    1:   ::DeletingFrameSubtree(aFrameManager, floatFrame);
    1:   aFrameManager->RemoveFrame(aBlockFrame, nsGkAtoms::floatList,
    1:                              floatFrame);
    1: 
    1:   // Remove placeholder frame
 4162:   ::DeletingFrameSubtree(aFrameManager, placeholderFrame);
    1:   aFrameManager->RemoveFrame(parentFrame, nsnull, placeholderFrame);
    1: 
    1:   // Insert text frame in its place
    1:   aFrameManager->InsertFrames(parentFrame, nsnull,
    1:                               prevSibling, newTextFrame);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::RemoveFirstLetterFrames(nsPresContext* aPresContext,
    1:                                                nsIPresShell* aPresShell,
    1:                                                nsFrameManager* aFrameManager,
    1:                                                nsIFrame* aFrame,
    1:                                                PRBool* aStopLooking)
    1: {
    1:   nsIFrame* prevSibling = nsnull;
    1:   nsIFrame* kid = aFrame->GetFirstChild(nsnull);
    1: 
    1:   while (kid) {
 4696:     if (nsGkAtoms::letterFrame == kid->GetType()) {
    1:       // Bingo. Found it. First steal away the text frame.
    1:       nsIFrame* textFrame = kid->GetFirstChild(nsnull);
    1:       if (!textFrame) {
    1:         break;
    1:       }
    1: 
    1:       // Create a new textframe
    1:       nsStyleContext* parentSC = aFrame->GetStyleContext();
    1:       if (!parentSC) {
    1:         break;
    1:       }
    1:       nsIContent* textContent = textFrame->GetContent();
    1:       if (!textContent) {
    1:         break;
    1:       }
    1:       nsRefPtr<nsStyleContext> newSC;
    1:       newSC = aPresShell->StyleSet()->ResolveStyleForNonElement(parentSC);
    1:       if (!newSC) {
    1:         break;
    1:       }
    1:       textFrame = NS_NewTextFrame(aPresShell, newSC);
    1:       textFrame->Init(textContent, aFrame, nsnull);
    1: 
    1:       // Next rip out the kid and replace it with the text frame
    1:       ::DeletingFrameSubtree(aFrameManager, kid);
    1:       aFrameManager->RemoveFrame(aFrame, nsnull, kid);
    1: 
    1:       // Insert text frame in its place
    1:       aFrameManager->InsertFrames(aFrame, nsnull, prevSibling, textFrame);
    1: 
    1:       *aStopLooking = PR_TRUE;
 8759:       aFrame->RemoveStateBits(NS_BLOCK_HAS_FIRST_LETTER_CHILD);
    1:       break;
    1:     }
 4696:     else if (IsInlineFrame(kid)) {
    1:       // Look inside child inline frame for the letter frame
    1:       RemoveFirstLetterFrames(aPresContext, aPresShell, aFrameManager, kid,
    1:                               aStopLooking);
    1:       if (*aStopLooking) {
    1:         break;
    1:       }
    1:     }
    1:     prevSibling = kid;
    1:     kid = kid->GetNextSibling();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::RemoveLetterFrames(nsPresContext* aPresContext,
    1:                                           nsIPresShell* aPresShell,
    1:                                           nsFrameManager* aFrameManager,
    1:                                           nsIFrame* aBlockFrame)
    1: {
 8324:   aBlockFrame = aBlockFrame->GetFirstContinuation();
 8324:   
    1:   PRBool stopLooking = PR_FALSE;
10280:   nsresult rv;
10280:   do {
10280:     rv = RemoveFloatingFirstLetterFrames(aPresContext, aPresShell,
    1:                                          aFrameManager,
    1:                                          aBlockFrame, &stopLooking);
    1:     if (NS_SUCCEEDED(rv) && !stopLooking) {
    1:       rv = RemoveFirstLetterFrames(aPresContext, aPresShell, aFrameManager,
    1:                                    aBlockFrame, &stopLooking);
    1:     }
10280:     if (stopLooking) {
10280:       break;
10280:     }
10280:     aBlockFrame = aBlockFrame->GetNextContinuation();
10280:   }  while (aBlockFrame);
    1:   return rv;
    1: }
    1: 
    1: // Fixup the letter frame situation for the given block
    1: nsresult
23461: nsCSSFrameConstructor::RecoverLetterFrames(nsIFrame* aBlockFrame)
    1: {
 8324:   aBlockFrame = aBlockFrame->GetFirstContinuation();
 8324:   
    1:   nsIFrame* parentFrame = nsnull;
    1:   nsIFrame* textFrame = nsnull;
    1:   nsIFrame* prevFrame = nsnull;
    1:   nsFrameItems letterFrames;
    1:   PRBool stopLooking = PR_FALSE;
10280:   nsresult rv;
10280:   do {
10280:     // XXX shouldn't this bit be set already (bug 408493), assert instead?
10280:     aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_STYLE);
23461:     rv = WrapFramesInFirstLetterFrame(aBlockFrame, aBlockFrame,
10280:                                       aBlockFrame->GetFirstChild(nsnull),
    1:                                       &parentFrame, &textFrame, &prevFrame,
    1:                                       letterFrames, &stopLooking);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
10280:     if (stopLooking) {
10280:       break;
10280:     }
10280:     aBlockFrame = aBlockFrame->GetNextContinuation();
10280:   } while (aBlockFrame);
10280: 
    1:   if (parentFrame) {
    1:     // Take the old textFrame out of the parents child list
23461:     ::DeletingFrameSubtree(mPresShell->FrameManager(), textFrame);
    1:     parentFrame->RemoveFrame(nsnull, textFrame);
    1: 
    1:     // Insert in the letter frame(s)
    1:     parentFrame->InsertFrames(nsnull, prevFrame, letterFrames.childList);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // listbox Widget Routines
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateListBoxContent(nsPresContext* aPresContext,
    1:                                             nsIFrame*       aParentFrame,
    1:                                             nsIFrame*       aPrevFrame,
    1:                                             nsIContent*     aChild,
    1:                                             nsIFrame**      aNewFrame,
    1:                                             PRBool          aIsAppend,
    1:                                             PRBool          aIsScrollbar,
    1:                                             nsILayoutHistoryState* aFrameState)
    1: {
    1: #ifdef MOZ_XUL
    1:   nsresult rv = NS_OK;
    1: 
    1:   // Construct a new frame
    1:   if (nsnull != aParentFrame) {
    1:     nsFrameItems            frameItems;
    1:     nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                   GetAbsoluteContainingBlock(aParentFrame),
    1:                                   GetFloatContainingBlock(aParentFrame), 
    1:                                   mTempFrameTreeState);
    1: 
    1:     nsRefPtr<nsStyleContext> styleContext;
    1:     styleContext = ResolveStyleContext(aParentFrame, aChild);
    1: 
    1:     // Pre-check for display "none" - only if we find that, do we create
    1:     // any frame at all
    1:     const nsStyleDisplay* display = styleContext->GetStyleDisplay();
    1: 
    1:     if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
    1:       *aNewFrame = nsnull;
    1:       return NS_OK;
    1:     }
    1: 
 6737:     BeginUpdate();
 6737: 
    1:     rv = ConstructFrameInternal(state, aChild,
    1:                                 aParentFrame, aChild->Tag(),
    1:                                 aChild->GetNameSpaceID(),
    1:                                 styleContext, frameItems, PR_FALSE);
  516:     if (!state.mPseudoFrames.IsEmpty()) {
  516:       ProcessPseudoFrames(state, frameItems); 
  516:     }
    1: 
    1:     nsIFrame* newFrame = frameItems.childList;
    1:     *aNewFrame = newFrame;
    1: 
    1:     if (NS_SUCCEEDED(rv) && (nsnull != newFrame)) {
    1:       // Notify the parent frame
    1:       if (aIsAppend)
    1:         rv = ((nsListBoxBodyFrame*)aParentFrame)->ListBoxAppendFrames(newFrame);
    1:       else
    1:         rv = ((nsListBoxBodyFrame*)aParentFrame)->ListBoxInsertFrames(aPrevFrame, newFrame);
    1:     }
 6737: 
 6737:     EndUpdate();
    1:   }
    1: 
    1:   return rv;
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
    1: //----------------------------------------
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructBlock(nsFrameConstructorState& aState,
    1:                                       const nsStyleDisplay*    aDisplay,
    1:                                       nsIContent*              aContent,
    1:                                       nsIFrame*                aParentFrame,
    1:                                       nsIFrame*                aContentParentFrame,
    1:                                       nsStyleContext*          aStyleContext,
    1:                                       nsIFrame**               aNewFrame,
    1:                                       nsFrameItems&            aFrameItems,
    1:                                       PRBool                   aAbsPosContainer)
    1: {
    1:   // Create column wrapper if necessary
    1:   nsIFrame* blockFrame = *aNewFrame;
    1:   nsIFrame* parent = aParentFrame;
    1:   nsRefPtr<nsStyleContext> blockStyle = aStyleContext;
    1:   const nsStyleColumn* columns = aStyleContext->GetStyleColumn();
    1: 
    1:   if (columns->mColumnCount != NS_STYLE_COLUMN_COUNT_AUTO
    1:       || columns->mColumnWidth.GetUnit() != eStyleUnit_Auto) {
    1:     nsIFrame* columnSetFrame = nsnull;
    1:     columnSetFrame = NS_NewColumnSetFrame(mPresShell, aStyleContext, 0);
    1:     if (!columnSetFrame) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, columnSetFrame);
23395:     // See if we need to create a view
23395:     nsHTMLContainerFrame::CreateViewForFrame(columnSetFrame, PR_FALSE);
    1:     blockStyle = mPresShell->StyleSet()->
    1:       ResolvePseudoStyleFor(aContent, nsCSSAnonBoxes::columnContent,
    1:                             aStyleContext);
    1:     parent = columnSetFrame;
    1:     *aNewFrame = columnSetFrame;
    1: 
    1:     columnSetFrame->SetInitialChildList(nsnull, blockFrame);
    1:   }
    1: 
    1:   blockFrame->SetStyleContextWithoutNotification(blockStyle);
    1:   InitAndRestoreFrame(aState, aContent, parent, nsnull, blockFrame);
    1: 
 8199:   nsresult rv = aState.AddChild(*aNewFrame, aFrameItems, aContent,
 8199:                                 aStyleContext,
    1:                                 aContentParentFrame ? aContentParentFrame :
    1:                                                       aParentFrame);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // See if we need to create a view, e.g. the frame is absolutely positioned
23395:   nsHTMLContainerFrame::CreateViewForFrame(blockFrame, PR_FALSE);
    1: 
20147:   if (!mInitialContainingBlock) {
20147:     // The frame we're constructing will be the initial containing block.
20147:     // Set mInitialContainingBlock before processing children.
20147:     mInitialContainingBlock = *aNewFrame;
20147:   }
20147: 
    1:   // We should make the outer frame be the absolute containing block,
    1:   // if one is required. We have to do this because absolute
    1:   // positioning must be computed with respect to the CSS dimensions
    1:   // of the element, which are the dimensions of the outer block. But
    1:   // we can't really do that because only blocks can have absolute
    1:   // children. So use the block and try to compensate with hacks
    1:   // in nsBlockFrame::CalculateContainingBlockSizeForAbsolutes.
    1:   nsFrameConstructorSaveState absoluteSaveState;
    1:   if (aAbsPosContainer) {
    1:     //    NS_ASSERTION(aRelPos, "should have made area frame for this");
    1:     aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
    1:   }
    1: 
    1:   // Process the child content
    1:   nsFrameItems childItems;
23352:   rv = ProcessChildren(aState, aContent, aStyleContext, blockFrame, PR_TRUE,
23352:                        childItems, PR_TRUE);
    1: 
    1:   // Set the frame's initial child list
    1:   blockFrame->SetInitialChildList(nsnull, childItems.childList);
    1: 
    1:   return rv;
    1: }
    1: 
 7189: static PRBool
 7189: AreAllKidsInline(nsIFrame* aFrameList)
    1: {
    1:   nsIFrame* kid = aFrameList;
    1:   while (kid) {
 2829:     if (!IsInlineOutside(kid)) {
    1:       return PR_FALSE;
    1:     }
    1:     kid = kid->GetNextSibling();
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructInline(nsFrameConstructorState& aState,
    1:                                        const nsStyleDisplay*    aDisplay,
    1:                                        nsIContent*              aContent,
    1:                                        nsIFrame*                aParentFrame,
    1:                                        nsStyleContext*          aStyleContext,
    1:                                        PRBool                   aIsPositioned,
    1:                                        nsIFrame*                aNewFrame)
    1: {
    1:   // Initialize the frame
    1:   InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, aNewFrame);
    1: 
    1:   nsFrameConstructorSaveState absoluteSaveState;  // definition cannot be inside next block
    1:                                                   // because the object's destructor is significant
    1:                                                   // this is part of the fix for bug 42372
    1: 
    1:   // Any inline frame might need a view (because of opacity, or fixed background)
23395:   nsHTMLContainerFrame::CreateViewForFrame(aNewFrame, PR_FALSE);
    1: 
    1:   if (aIsPositioned) {                            
    1:     // Relatively positioned frames becomes a container for child
    1:     // frames that are positioned
    1:     aState.PushAbsoluteContainingBlock(aNewFrame, absoluteSaveState);
    1:   }
    1: 
    1:   // Process the child content
    1:   nsFrameItems childItems;
    1:   PRBool kidsAllInline;
    1:   nsresult rv = ProcessInlineChildren(aState, aContent, aNewFrame, PR_TRUE,
    1:                                       childItems, &kidsAllInline);
    1:   if (kidsAllInline) {
    1:     // Set the inline frame's initial child list
    1:     CreateAnonymousFrames(aContent->Tag(), aState, aContent, aNewFrame,
23342:                           childItems);
    1: 
    1:     aNewFrame->SetInitialChildList(nsnull, childItems.childList);
    1:     return rv;
    1:   }
    1: 
    1:   // This inline frame contains several types of children. Therefore
    1:   // this frame has to be chopped into several pieces. We will produce
    1:   // as a result of this 3 lists of children. The first list contains
    1:   // all of the inline children that precede the first block child
    1:   // (and may be empty). The second list contains all of the block
    1:   // children and any inlines that are between them (and must not be
    1:   // empty, otherwise - why are we here?). The final list contains all
    1:   // of the inline children that follow the final block child.
    1: 
    1:   // Find the first block child which defines list1 and list2
    1:   nsIFrame* list1 = childItems.childList;
    1:   nsIFrame* prevToFirstBlock;
    1:   nsIFrame* list2 = FindFirstBlock(list1, &prevToFirstBlock);
    1:   if (prevToFirstBlock) {
    1:     prevToFirstBlock->SetNextSibling(nsnull);
    1:   }
    1:   else {
    1:     list1 = nsnull;
    1:   }
    1: 
    1:   // Find the last block child which defines the end of list2 and the
    1:   // start of list3
    1:   nsIFrame* afterFirstBlock = list2->GetNextSibling();
    1:   nsIFrame* list3 = nsnull;
    1:   nsIFrame* lastBlock = FindLastBlock(afterFirstBlock);
    1:   if (!lastBlock) {
    1:     lastBlock = list2;
    1:   }
    1:   list3 = lastBlock->GetNextSibling();
    1:   lastBlock->SetNextSibling(nsnull);
    1: 
    1:   // list1's frames belong to this inline frame so go ahead and take them
    1:   aNewFrame->SetInitialChildList(nsnull, list1);
    1:                                              
    1:   // list2's frames belong to an anonymous block that we create right
    1:   // now. The anonymous block will be the parent of the block children
    1:   // of the inline.
    1:   nsIAtom* blockStyle;
    1:   nsRefPtr<nsStyleContext> blockSC;
    1:   nsIFrame* blockFrame;
    1:   if (aIsPositioned) {
    1:     blockStyle = nsCSSAnonBoxes::mozAnonymousPositionedBlock;
    1:     
    1:     blockSC = mPresShell->StyleSet()->
    1:       ResolvePseudoStyleFor(aContent, blockStyle, aStyleContext);
    1:       
 7667:     blockFrame = NS_NewRelativeItemWrapperFrame(mPresShell, blockSC, 0);
    1:   }
    1:   else {
    1:     blockStyle = nsCSSAnonBoxes::mozAnonymousBlock;
    1: 
    1:     blockSC = mPresShell->StyleSet()->
    1:       ResolvePseudoStyleFor(aContent, blockStyle, aStyleContext);
    1: 
    1:     blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
    1:   }
    1: 
    1:   InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, blockFrame, PR_FALSE);  
    1: 
    1:   // Any inline frame could have a view (e.g., opacity)
23395:   nsHTMLContainerFrame::CreateViewForFrame(blockFrame, PR_FALSE);
    1: 
    1:   if (blockFrame->HasView() || aNewFrame->HasView()) {
    1:     // Move list2's frames into the new view
    1:     nsHTMLContainerFrame::ReparentFrameViewList(aState.mPresContext, list2,
    1:                                                 list2->GetParent(), blockFrame);
    1:   }
    1: 
    1:   blockFrame->SetInitialChildList(nsnull, list2);
    1: 
    1:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                 GetAbsoluteContainingBlock(blockFrame),
    1:                                 GetFloatContainingBlock(blockFrame));
    1: 
    1:   // If we have an inline between two blocks all inside an inline and the inner
    1:   // inline contains a float, the float will end up in the float list of the
    1:   // parent block of the inline, but its parent pointer will be the anonymous
    1:   // block we create...  AdjustFloatParentPtrs() deals with this by moving the
    1:   // float from the outer state |aState| to the inner |state|.
 5585:   MoveChildrenTo(state.mFrameManager, blockFrame, list2, nsnull, &state,
 5585:                  &aState);
    1: 
    1:   // list3's frames belong to another inline frame
    1:   nsIFrame* inlineFrame = nsnull;
    1: 
 4696:   // If we ever start constructing a second inline in the split even when
 4696:   // list3 is null, the logic in MaybeRecreateContainerForIBSplitterFrame
 4696:   // needs to be adjusted.  Also, if you're changing this code also change
 4696:   // AppendFrames().
    1:   if (list3) {
 4696:     inlineFrame = MoveFramesToEndOfIBSplit(aState, nsnull,
 4696:                                            aIsPositioned, aContent,
 4696:                                            aStyleContext, list3,
 4696:                                            blockFrame, nsnull);
 4696:     
 4696:   }
 4696: 
 4696:   // Mark the frames as special (note: marking for inlineFrame is handled by
 4696:   // MoveFramesToEndOfIBSplit). That way if any of the append/insert/remove
 4696:   // methods try to fiddle with the children, the containing block will be
 4696:   // reframed instead.
    1:   SetFrameIsSpecial(aNewFrame, blockFrame);
    1:   SetFrameIsSpecial(blockFrame, inlineFrame);
 5324:   MarkIBSpecialPrevSibling(blockFrame, aNewFrame);
19125:   if (inlineFrame) {
19125:     MarkIBSpecialPrevSibling(inlineFrame, blockFrame);
19125:   }
    1: 
    1:   #ifdef DEBUG
    1:   if (gNoisyInlineConstruction) {
    1:     nsIFrameDebug*  frameDebug;
    1: 
    1:     printf("nsCSSFrameConstructor::ConstructInline:\n");
23554:     if ( (frameDebug = do_QueryFrame(aNewFrame)) ) {
    1:       printf("  ==> leading inline frame:\n");
    1:       frameDebug->List(stdout, 2);
    1:     }
23554:     if ( (frameDebug = do_QueryFrame(blockFrame)) ) {
    1:       printf("  ==> block frame:\n");
    1:       frameDebug->List(stdout, 2);
    1:     }
23554:     if ( (frameDebug = do_QueryFrame(inlineFrame)) ) {
    1:       printf("  ==> trailing inline frame:\n");
    1:       frameDebug->List(stdout, 2);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
 4696: nsIFrame*
 4696: nsCSSFrameConstructor::MoveFramesToEndOfIBSplit(nsFrameConstructorState& aState,
 4696:                                                 nsIFrame* aExistingEndFrame,
 4696:                                                 PRBool aIsPositioned,
 4696:                                                 nsIContent* aContent,
 4696:                                                 nsStyleContext* aStyleContext,
 4696:                                                 nsIFrame* aFramesToMove,
 4696:                                                 nsIFrame* aBlockPart,
 4696:                                                 nsFrameConstructorState* aTargetState)
 4696: {
 4696:   NS_PRECONDITION(aFramesToMove, "Must have frames to move");
 4696:   NS_PRECONDITION(aBlockPart, "Must have a block part");
 4696: 
 4696:   nsIFrame* inlineFrame = aExistingEndFrame;
 4696:   if (!inlineFrame) {
 4696:     if (aIsPositioned) {
 4696:       inlineFrame = NS_NewPositionedInlineFrame(mPresShell, aStyleContext);
 4696:     }
 4696:     else {
 4696:       inlineFrame = NS_NewInlineFrame(mPresShell, aStyleContext);
 4696:     }
 4696: 
 4696:     InitAndRestoreFrame(aState, aContent, aBlockPart->GetParent(), nsnull,
 4696:                         inlineFrame, PR_FALSE);
 4696: 
 4696:     // Any frame might need a view
23395:     nsHTMLContainerFrame::CreateViewForFrame(inlineFrame, PR_FALSE);
 4696:   }
 4696:   
 4696:   if (inlineFrame->HasView() || aFramesToMove->GetParent()->HasView()) {
 4696:     // Move list3's frames into the new view
 4696:     nsHTMLContainerFrame::ReparentFrameViewList(aState.mPresContext,
 4696:                                                 aFramesToMove,
 4696:                                                 aFramesToMove->GetParent(),
 4696:                                                 inlineFrame);
 4696:   }
 4696: 
 4696:   // Reparent (cheaply) the frames in list3
 5585:   nsIFrame* existingFirstChild = inlineFrame->GetFirstChild(nsnull);
 5585:   if (!existingFirstChild &&
 4696:       (inlineFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
 4696:     inlineFrame->SetInitialChildList(nsnull, aFramesToMove);
 4696:   } else {
 4696:     inlineFrame->InsertFrames(nsnull, nsnull, aFramesToMove);
 4696:   }
 4696:   nsFrameConstructorState* startState = aTargetState ? &aState : nsnull;
 4696:   MoveChildrenTo(aState.mFrameManager, inlineFrame, aFramesToMove,
 5585:                  existingFirstChild, aTargetState, startState);
 4696:   SetFrameIsSpecial(inlineFrame, nsnull);
 4696:   return inlineFrame;
 4696: }
 4696:  
    1: nsresult
    1: nsCSSFrameConstructor::ProcessInlineChildren(nsFrameConstructorState& aState,
    1:                                              nsIContent*              aContent,
    1:                                              nsIFrame*                aFrame,
    1:                                              PRBool                   aCanHaveGeneratedContent,
    1:                                              nsFrameItems&            aFrameItems,
    1:                                              PRBool*                  aKidsAllInline)
    1: {
    1:   nsresult rv = NS_OK;
    1:   nsStyleContext* styleContext = nsnull;
    1: 
    1:   // save the pseudo frame state 
    1:   nsPseudoFrames prevPseudoFrames; 
    1:   aState.mPseudoFrames.Reset(&prevPseudoFrames);
    1: 
    1:   if (aCanHaveGeneratedContent) {
    1:     // Probe for generated content before
    1:     styleContext = aFrame->GetStyleContext();
16976:     CreateGeneratedContentFrame(aState, aFrame, aContent,
    1:                                 styleContext, nsCSSPseudoElements::before,
16976:                                 aFrameItems);
    1:   }
    1: 
    1:   // Iterate the child content objects and construct frames
    1:   PRBool allKidsInline = PR_TRUE;
    1:   ChildIterator iter, last;
    1:   for (ChildIterator::Init(aContent, &iter, &last);
    1:        iter != last;
    1:        ++iter) {
    1:     // Construct a child frame
    1:     nsIFrame* oldLastChild = aFrameItems.lastChild;
    1:     rv = ConstructFrame(aState, nsCOMPtr<nsIContent>(*iter),
    1:                         aFrame, aFrameItems);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
    1:     // Examine newly added children (we may have added more than one
    1:     // child if the child was another inline frame that ends up
    1:     // being carved in 3 pieces) to maintain the allKidsInline flag.
    1:     if (allKidsInline) {
    1:       nsIFrame* kid;
    1:       if (oldLastChild) {
    1:         kid = oldLastChild->GetNextSibling();
    1:       }
    1:       else {
    1:         kid = aFrameItems.childList;
    1:       }
    1:       while (kid) {
 2829:         if (!IsInlineOutside(kid)) {
    1:           allKidsInline = PR_FALSE;
    1:           break;
    1:         }
    1:         kid = kid->GetNextSibling();
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (aCanHaveGeneratedContent) {
    1:     // Probe for generated content after
16976:     CreateGeneratedContentFrame(aState, aFrame, aContent,
    1:                                 styleContext, nsCSSPseudoElements::after,
16976:                                 aFrameItems);
    1:   }
    1: 
    1:   // process the current pseudo frame state
    1:   if (!aState.mPseudoFrames.IsEmpty()) {
    1:     ProcessPseudoFrames(aState, aFrameItems);
    1:     // recompute allKidsInline to take into account new child frames
    1:     // XXX we DON'T do this yet because anonymous table children should
    1:     // be accepted as inline children, until we turn on inline-table.
    1:     // See bug 297537.
    1:     // allKidsInline = AreAllKidsInline(aFrameItems.childList);
    1:   }
    1:   // restore the pseudo frame state
    1:   aState.mPseudoFrames = prevPseudoFrames;
    1: 
    1:   *aKidsAllInline = allKidsInline;
    1: 
    1:   return rv;
    1: }
    1: 
 7189: static void
 7189: DestroyNewlyCreatedFrames(nsFrameConstructorState& aState,
 7189:                           nsIFrame* aParentFrame,
 7189:                           const nsFrameItems& aFrameList)
 7189: {
 7189:   // Ok, reverse tracks: wipe out the frames we just created
 7189:   nsFrameManager *frameManager = aState.mFrameManager;
 7189: 
 7189:   // Destroy the frames. As we do make sure any content to frame mappings
 7189:   // or entries in the undisplayed content map are removed
 7189:   frameManager->ClearAllUndisplayedContentIn(aParentFrame->GetContent());
 7189: 
 7189:   CleanupFrameReferences(frameManager, aFrameList.childList);
 7189:   if (aState.mAbsoluteItems.childList) {
 7189:     CleanupFrameReferences(frameManager, aState.mAbsoluteItems.childList);
 7189:   }
 7189:   if (aState.mFixedItems.childList) {
 7189:     CleanupFrameReferences(frameManager, aState.mFixedItems.childList);
 7189:   }
 7189:   if (aState.mFloatedItems.childList) {
 7189:     CleanupFrameReferences(frameManager, aState.mFloatedItems.childList);
 7189:   }
 7189: #ifdef MOZ_XUL
 7189:   if (aState.mPopupItems.childList) {
 7189:     CleanupFrameReferences(frameManager, aState.mPopupItems.childList);
 7189:   }
 7189: #endif
 7189:   nsFrameList tmp(aFrameList.childList);
 7189:   tmp.DestroyFrames();
 7189: 
 7189:   tmp.SetFrames(aState.mAbsoluteItems.childList);
 7189:   tmp.DestroyFrames();
 7189:   aState.mAbsoluteItems.childList = nsnull;
 7189: 
 7189:   tmp.SetFrames(aState.mFixedItems.childList);
 7189:   tmp.DestroyFrames();
 7189:   aState.mFixedItems.childList = nsnull;
 7189: 
 7189:   tmp.SetFrames(aState.mFloatedItems.childList);
 7189:   tmp.DestroyFrames();
 7189:   aState.mFloatedItems.childList = nsnull;
 7189: 
 7189: #ifdef MOZ_XUL
 7189:   tmp.SetFrames(aState.mPopupItems.childList);
 7189:   tmp.DestroyFrames();
 7189:   aState.mPopupItems.childList = nsnull;
 7189: #endif
 7189: }
 7189: 
    1: PRBool
    1: nsCSSFrameConstructor::WipeContainingBlock(nsFrameConstructorState& aState,
    1:                                            nsIFrame* aContainingBlock,
    1:                                            nsIFrame* aFrame,
 4696:                                            const nsFrameItems& aFrameList,
 4696:                                            PRBool aIsAppend,
 4696:                                            nsIFrame* aPrevSibling)
 4696: {
 4696:   if (!aFrameList.childList) {
 4696:     return PR_FALSE;
 4696:   }
 4696:   
 7189:   // Before we go and append the frames, we must check for two
 7189:   // special situations.
 7189: 
 7189:   // Situation #1 is a XUL frame that contains frames that are required
 7189:   // to be wrapped in blocks.
 7189:   if (aFrame->IsBoxFrame() &&
 7189:       !(aFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
 7189:       AnyKidsNeedBlockParent(aFrameList.childList)) {
 7189:     DestroyNewlyCreatedFrames(aState, aFrame, aFrameList);
 7189:     RecreateFramesForContent(aFrame->GetContent());
 7189:     return PR_TRUE;
 7189:   }
 7189: 
 7189:   // Situation #2 is an inline frame that will now contain block
    1:   // frames. This is a no-no and the frame construction logic knows
 4696:   // how to fix this.  See defition of IsInlineFrame() for what "an
 4696:   // inline" is.  Whether we have "a block" is tested for by
 4696:   // AreAllKidsInline.
 4696: 
 4696:   // We also need to check for an append of content ending in an
 4696:   // inline to the block in an {ib} split or an insert of content
 4696:   // starting with an inline to the start of that block.  If that
 4696:   // happens, we also need to reframe, since that content needs to go
 4696:   // into the following or preceding inline in the split.
 4696: 
 4696:   if (IsInlineFrame(aFrame)) {
 4696:     // Nothing to do if all kids are inline
 4696:     if (AreAllKidsInline(aFrameList.childList)) {
    1:       return PR_FALSE;
 4696:     }
 4696:   } else if (!IsFrameSpecial(aFrame)) {
 4696:     return PR_FALSE;
 4696:   } else {
 4696:     // aFrame is the block in an {ib} split.  Check that we're not
 4696:     // messing up either end of it.
 4696:     if (aIsAppend) {
 5324:       // Will be handled in AppendFrames(), unless we have floats that we can't
 5324:       // move out because there might be no float containing block to move them
 5324:       // into.
 5324:       if (!aState.mFloatedItems.childList) {
 4696:         return PR_FALSE;
 4696:       }
 4696: 
 5324:       // Walk up until we get a float containing block that's not part of an
 5324:       // {ib} split, since otherwise we might have to ship floats out of it
 5324:       // too.
 5324:       nsIFrame* floatContainer = aFrame;
 5324:       do {
19125:         floatContainer = GetFloatContainingBlock(
19125:           GetIBSplitSpecialPrevSiblingForAnonymousBlock(floatContainer));
 5324:         if (!floatContainer) {
 5324:           break;
 5324:         }
 5324:         if (!IsFrameSpecial(floatContainer)) {
 5324:           return PR_FALSE;
 5324:         }
 5324:       } while (1);
 5324:     }
 5324:     
 4696:     if (aPrevSibling && !aPrevSibling->GetNextSibling()) {
 4696:       // This is an append that won't go through AppendFrames.  We can bail out
 4696:       // if the last frame we're appending is not inline
 4696:       if (!aFrameList.lastChild->GetStyleDisplay()->IsInlineOutside()) {
 4696:         return PR_FALSE;
 4696:       }
 4696:     } else {
 4696:       // We can bail out if we're not inserting at the beginning or if
 4696:       // the first frame we're inserting is not inline.
 4696:       if (aPrevSibling ||
 4696:           !aFrameList.childList->GetStyleDisplay()->IsInlineOutside()) {
 4696:         return PR_FALSE;
 4696:       }
 4696:     }
 4696:   }
    1: 
 7189:   DestroyNewlyCreatedFrames(aState, aFrame, aFrameList);
    1: 
    1:   // If we don't have a containing block, start with aFrame and look for one.
    1:   if (!aContainingBlock) {
    1:     aContainingBlock = aFrame;
    1:   }
    1:   
    1:   // To find the right block to reframe, just walk up the tree until we find a
    1:   // frame that is:
    1:   // 1)  Not part of an IB split (not special)
    1:   // 2)  Not a pseudo-frame
    1:   // 3)  Not an inline frame
    1:   // We're guaranteed to find one, since nsStyleContext::ApplyStyleFixups
    1:   // enforces that the root is display:none, display:table, or display:block.
    1:   // Note that walking up "too far" is OK in terms of correctness, even if it
    1:   // might be a little inefficient.  This is why we walk out of all
    1:   // pseudo-frames -- telling which ones are or are not OK to walk out of is
    1:   // too hard (and I suspect that we do in fact need to walk out of all of
    1:   // them).
 2829:   while (IsFrameSpecial(aContainingBlock) || IsInlineOutside(aContainingBlock) ||
    1:          aContainingBlock->GetStyleContext()->GetPseudoType()) {
    1:     aContainingBlock = aContainingBlock->GetParent();
    1:     NS_ASSERTION(aContainingBlock,
    1:                  "Must have non-inline, non-special, non-pseudo frame as root "
    1:                  "(or child of root, for a table root)!");
    1:   }
    1: 
    1:   // Tell parent of the containing block to reformulate the
    1:   // entire block. This is painful and definitely not optimal
    1:   // but it will *always* get the right answer.
    1: 
    1:   nsIContent *blockContent = aContainingBlock->GetContent();
    1:   nsCOMPtr<nsIContent> parentContainer = blockContent->GetParent();
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::WipeContainingBlock: blockContent=%p parentContainer=%p\n",
 3233:            static_cast<void*>(blockContent),
 3233:            static_cast<void*>(parentContainer));
    1:   }
    1: #endif
    1:   if (parentContainer) {
    1:     ReinsertContent(parentContainer, blockContent);
    1:   }
    1:   else if (blockContent->GetCurrentDoc() == mDocument) {
    1:     ReconstructDocElementHierarchyInternal();
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ReframeContainingBlock(nsIFrame* aFrame)
    1: {
    1: 
    1: #ifdef DEBUG
    1:   // ReframeContainingBlock is a NASTY routine, it causes terrible performance problems
    1:   // so I want to see when it is happening!  Unfortunately, it is happening way to often because
    1:   // so much content on the web causes 'special' block-in-inline frame situations and we handle them
    1:   // very poorly
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ReframeContainingBlock frame=%p\n",
 3233:            static_cast<void*>(aFrame));
    1:   }
    1: #endif
    1: 
    1:   PRBool isReflowing;
    1:   mPresShell->IsReflowLocked(&isReflowing);
    1:   if(isReflowing) {
    1:     // don't ReframeContainingBlock, this will result in a crash
    1:     // if we remove a tree that's in reflow - see bug 121368 for testcase
    1:     NS_ASSERTION(0, "Atemptted to nsCSSFrameConstructor::ReframeContainingBlock during a Reflow!!!");
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Get the first "normal" ancestor of the target frame.
    1:   nsIFrame* containingBlock = GetIBContainingBlockFor(aFrame);
    1:   if (containingBlock) {
    1:     // From here we look for the containing block in case the target
    1:     // frame is already a block (which can happen when an inline frame
    1:     // wraps some of its content in an anonymous block; see
    1:     // ConstructInline)
    1:    
    1:     // NOTE: We used to get the FloatContainingBlock here, but it was often wrong.
    1:     // GetIBContainingBlock works much better and provides the correct container in all cases
    1:     // so GetFloatContainingBlock(aFrame) has been removed
    1: 
    1:     // And get the containingBlock's content
    1:     nsCOMPtr<nsIContent> blockContent = containingBlock->GetContent();
    1:     if (blockContent) {
    1:       // Now find the containingBlock's content's parent
    1:       nsCOMPtr<nsIContent> parentContainer = blockContent->GetParent();
    1:       if (parentContainer) {
    1: #ifdef DEBUG
    1:         if (gNoisyContentUpdates) {
    1:           printf("  ==> blockContent=%p, parentContainer=%p\n",
 3233:                  static_cast<void*>(blockContent),
 3233:                  static_cast<void*>(parentContainer));
    1:         }
    1: #endif
    1:         return ReinsertContent(parentContainer, blockContent);
    1:       }
    1:     }
    1:   }
    1: 
    1:   // If we get here, we're screwed!
    1:   return ReconstructDocElementHierarchyInternal();
    1: }
    1: 
18953: nsresult
18953: nsCSSFrameConstructor::RemoveFixedItems(const nsFrameConstructorState& aState,
18953:                                         nsIFrame *aRootElementFrame)
    1: {
    1:   nsresult rv=NS_OK;
    1: 
    1:   if (mFixedContainingBlock) {
    1:     nsIFrame *fixedChild = nsnull;
    1:     do {
    1:       fixedChild = mFixedContainingBlock->GetFirstChild(nsGkAtoms::fixedList);
18953:       if (fixedChild && fixedChild == aRootElementFrame) {
18953:         // Skip the root element frame, if it happens to be fixed-positioned
18953:         // It will be explicitly removed later in
18953:         // ReconstructDocElementHierarchyInternal
18953:         fixedChild = fixedChild->GetNextSibling();
18953:       }
    1:       if (fixedChild) {
    1:         // Remove the placeholder so it doesn't end up sitting about pointing
    1:         // to the removed fixed frame.
 4162:         nsPlaceholderFrame *placeholderFrame =
 4162:           aState.mFrameManager->GetPlaceholderFrameFor(fixedChild);
    1:         NS_ASSERTION(placeholderFrame, "no placeholder for fixed-pos frame");
    1:         NS_ASSERTION(placeholderFrame->GetType() ==
    1:                      nsGkAtoms::placeholderFrame,
    1:                      "Wrong type");
 4162:         UnregisterPlaceholderChain(aState.mFrameManager, placeholderFrame);
    1:         nsIFrame* placeholderParent = placeholderFrame->GetParent();
    1:         ::DeletingFrameSubtree(aState.mFrameManager, placeholderFrame);
    1:         rv = aState.mFrameManager->RemoveFrame(placeholderParent, nsnull,
    1:                                                placeholderFrame);
    1:         if (NS_FAILED(rv)) {
    1:           NS_WARNING("Error removing placeholder for fixed frame in RemoveFixedItems");
    1:           break;
    1:         }
    1: 
    1:         ::DeletingFrameSubtree(aState.mFrameManager, fixedChild);
    1:         rv = aState.mFrameManager->RemoveFrame(mFixedContainingBlock,
    1:                                                nsGkAtoms::fixedList,
    1:                                                fixedChild);
    1:         if (NS_FAILED(rv)) {
    1:           NS_WARNING("Error removing frame from fixed containing block in RemoveFixedItems");
    1:           break;
    1:         }
    1:       }
    1:     } while(fixedChild);
    1:   } else {
    1:     NS_WARNING( "RemoveFixedItems called with no FixedContainingBlock data member set");
    1:   }
    1:   return rv;
    1: }
    1: 
11845: void
11845: nsCSSFrameConstructor::RestyleForAppend(nsIContent* aContainer,
11845:                                         PRInt32 aNewIndexInContainer)
11845: {
11845:   NS_ASSERTION(aContainer, "must have container for append");
15302: #ifdef DEBUG
15302:   {
15302:     for (PRInt32 index = aNewIndexInContainer;; ++index) {
15302:       nsIContent *content = aContainer->GetChildAt(index);
15302:       if (!content) {
15302:         NS_ASSERTION(index != aNewIndexInContainer, "yikes, nothing appended");
15302:         break;
15302:       }
16128:       NS_ASSERTION(!content->IsRootOfAnonymousSubtree(),
16128:                    "anonymous nodes should not be in child lists");
15302:     }
15302:   }
15302: #endif
11845:   PRUint32 selectorFlags =
11845:     aContainer->GetFlags() & (NODE_ALL_SELECTOR_FLAGS &
11845:                               ~NODE_HAS_SLOW_SELECTOR_NOAPPEND);
11845:   if (selectorFlags == 0)
11845:     return;
11845: 
11845:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
11845:     PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:     // Restyling the container is the most we can do here, so we're done.
11845:     return;
11845:   }
11845: 
11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
11845:     // see whether we need to restyle the container
11845:     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
11845:     for (PRInt32 index = 0; index < aNewIndexInContainer; ++index) {
11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
11845:       // IsSignificantChild less likely to be true, and thus make us more
11845:       // likely to restyle).
11845:       if (nsStyleUtil::IsSignificantChild(aContainer->GetChildAt(index),
11845:                                           PR_TRUE, PR_FALSE)) {
11845:         wasEmpty = PR_FALSE;
11845:         break;
11845:       }
11845:     }
11845:     if (wasEmpty) {
11845:       PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:       // Restyling the container is the most we can do here, so we're done.
11845:       return;
11845:     }
11845:   }
11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
11845:     // restyle the last element child before this node
11845:     for (PRInt32 index = aNewIndexInContainer - 1; index >= 0; --index) {
11845:       nsIContent *content = aContainer->GetChildAt(index);
11845:       if (content->IsNodeOfType(nsINode::eELEMENT)) {
11845:         PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:         break;
11845:       }
11845:     }
11845:   }
11845: }
11845: 
11845: // Restyling for a ContentInserted or CharacterDataChanged notification.
11845: // This could be used for ContentRemoved as well if we got the
11845: // notification before the removal happened (and sometimes
11845: // CharacterDataChanged is more like a removal than an addition).
11845: // The comments are written and variables are named in terms of it being
11845: // a ContentInserted notification.
11845: void
11845: nsCSSFrameConstructor::RestyleForInsertOrChange(nsIContent* aContainer,
11845:                                                 nsIContent* aChild)
11845: {
16128:   NS_ASSERTION(!aChild->IsRootOfAnonymousSubtree(),
16128:                "anonymous nodes should not be in child lists");
11845:   PRUint32 selectorFlags =
11845:     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
11845:   if (selectorFlags == 0)
11845:     return;
11845: 
11845:   if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
11845:                        NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
11845:     PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:     // Restyling the container is the most we can do here, so we're done.
11845:     return;
11845:   }
11845: 
11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
11845:     // see whether we need to restyle the container
11845:     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
11845:     for (PRInt32 index = 0; ; ++index) {
11845:       nsIContent *child = aContainer->GetChildAt(index);
11845:       if (!child) // last child
11845:         break;
11845:       if (child == aChild)
11845:         continue;
11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
11845:       // IsSignificantChild less likely to be true, and thus make us more
11845:       // likely to restyle).
11845:       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
11845:         wasEmpty = PR_FALSE;
11845:         break;
11845:       }
11845:     }
11845:     if (wasEmpty) {
11845:       PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:       // Restyling the container is the most we can do here, so we're done.
11845:       return;
11845:     }
11845:   }
11845: 
11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
11845:     // restyle the previously-first element child if it is after this node
11845:     PRBool passedChild = PR_FALSE;
11845:     for (PRInt32 index = 0; ; ++index) {
11845:       nsIContent *content = aContainer->GetChildAt(index);
11845:       if (!content)
11845:         break; // went through all children
11845:       if (content == aChild) {
11845:         passedChild = PR_TRUE;
11845:         continue;
11845:       }
11845:       if (content->IsNodeOfType(nsINode::eELEMENT)) {
11845:         if (passedChild) {
11845:           PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
11845:     }
11845:     // restyle the previously-last element child if it is before this node
11845:     passedChild = PR_FALSE;
11845:     for (PRInt32 index = aContainer->GetChildCount() - 1;
11845:          index >= 0; --index) {
11845:       nsIContent *content = aContainer->GetChildAt(index);
11845:       if (content == aChild) {
11845:         passedChild = PR_TRUE;
11845:         continue;
11845:       }
11845:       if (content->IsNodeOfType(nsINode::eELEMENT)) {
11845:         if (passedChild) {
11845:           PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
11845:     }
11845:   }
11845: }
11845: 
11845: void
11845: nsCSSFrameConstructor::RestyleForRemove(nsIContent* aContainer,
11845:                                         nsIContent* aOldChild,
11845:                                         PRInt32 aIndexInContainer)
11845: {
16128:   NS_ASSERTION(!aOldChild->IsRootOfAnonymousSubtree(),
16128:                "anonymous nodes should not be in child lists");
11845:   PRUint32 selectorFlags =
11845:     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
11845:   if (selectorFlags == 0)
11845:     return;
11845: 
11845:   if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
11845:                        NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
11845:     PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:     // Restyling the container is the most we can do here, so we're done.
11845:     return;
11845:   }
11845: 
11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
11845:     // see whether we need to restyle the container
11845:     PRBool isEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
11845:     for (PRInt32 index = 0; ; ++index) {
11845:       nsIContent *child = aContainer->GetChildAt(index);
11845:       if (!child) // last child
11845:         break;
11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
11845:       // IsSignificantChild less likely to be true, and thus make us more
11845:       // likely to restyle).
11845:       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
11845:         isEmpty = PR_FALSE;
11845:         break;
11845:       }
11845:     }
11845:     if (isEmpty) {
11845:       PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:       // Restyling the container is the most we can do here, so we're done.
11845:       return;
11845:     }
11845:   }
11845: 
11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
11845:     // restyle the previously-first element child if it is after aOldChild
11845:     for (PRInt32 index = 0; ; ++index) {
11845:       nsIContent *content = aContainer->GetChildAt(index);
11845:       if (!content)
11845:         break; // went through all children
11845:       if (content->IsNodeOfType(nsINode::eELEMENT)) {
11845:         if (index >= aIndexInContainer) {
11845:           PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
11845:     }
11845:     // restyle the previously-last element child if it is before aOldChild
11845:     for (PRInt32 index = aContainer->GetChildCount() - 1;
11845:          index >= 0; --index) {
11845:       nsIContent *content = aContainer->GetChildAt(index);
11845:       if (content->IsNodeOfType(nsINode::eELEMENT)) {
11845:         if (index < aIndexInContainer) {
11845:           PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
11845:     }
11845:   }
11845: }
11845: 
11845: 
20261: static PLDHashOperator
    1: CollectRestyles(nsISupports* aContent,
    1:                 nsCSSFrameConstructor::RestyleData& aData,
    1:                 void* aRestyleArrayPtr)
    1: {
    1:   nsCSSFrameConstructor::RestyleEnumerateData** restyleArrayPtr =
 3233:     static_cast<nsCSSFrameConstructor::RestyleEnumerateData**>
 3233:                (aRestyleArrayPtr);
    1:   nsCSSFrameConstructor::RestyleEnumerateData* currentRestyle =
    1:     *restyleArrayPtr;
 3233:   currentRestyle->mContent = static_cast<nsIContent*>(aContent);
    1:   currentRestyle->mRestyleHint = aData.mRestyleHint;
    1:   currentRestyle->mChangeHint = aData.mChangeHint;
    1: 
    1:   // Increment to the next slot in the array
    1:   *restyleArrayPtr = currentRestyle + 1; 
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::ProcessOneRestyle(nsIContent* aContent,
    1:                                          nsReStyleHint aRestyleHint,
    1:                                          nsChangeHint aChangeHint)
    1: {
    1:   NS_PRECONDITION(aContent, "Must have content node");
    1:   
    1:   if (!aContent->IsInDoc() ||
    1:       aContent->GetCurrentDoc() != mDocument) {
    1:     // Content node has been removed from our document; nothing else
    1:     // to do here
    1:     return;
    1:   }
    1:   
    1:   nsIFrame* primaryFrame = mPresShell->GetPrimaryFrameFor(aContent);
    1:   if (aRestyleHint & eReStyle_Self) {
    1:     RestyleElement(aContent, primaryFrame, aChangeHint);
    1:   } else if (aChangeHint &&
    1:                (primaryFrame ||
    1:                 (aChangeHint & nsChangeHint_ReconstructFrame))) {
    1:     // Don't need to recompute style; just apply the hint
    1:     nsStyleChangeList changeList;
    1:     changeList.AppendChange(primaryFrame, aContent, aChangeHint);
    1:     ProcessRestyledFrames(changeList);
    1:   }
    1: 
    1:   if (aRestyleHint & eReStyle_LaterSiblings) {
    1:     RestyleLaterSiblings(aContent);
    1:   }
    1: }
    1: 
 7713: #define RESTYLE_ARRAY_STACKSIZE 128
 7713: 
    1: void
11409: nsCSSFrameConstructor::RebuildAllStyleData(nsChangeHint aExtraHint)
11409: {
11409:   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
11409:                "Should not reconstruct the root of the frame tree.  "
11409:                "Use ReconstructDocElementHierarchy instead.");
11409: 
10073:   mRebuildAllStyleData = PR_FALSE;
22339:   NS_UpdateHint(aExtraHint, mRebuildAllExtraHint);
22339:   mRebuildAllExtraHint = nsChangeHint(0);
10073: 
10073:   if (!mPresShell || !mPresShell->GetRootFrame())
10073:     return;
10073: 
23652:   nsAutoScriptBlocker scriptBlocker;
23652: 
23652:   // Make sure that the viewmanager will outlive the presshell
23652:   nsIViewManager::UpdateViewBatch batch(mPresShell->GetViewManager());
23652: 
21202:   // Processing the style changes could cause a flush that propagates to
21202:   // the parent frame and thus destroys the pres shell.
21202:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(mPresShell);
21202: 
10073:   // Tell the style set to get the old rule tree out of the way
10073:   // so we can recalculate while maintaining rule tree immutability
10073:   nsresult rv = mPresShell->StyleSet()->BeginReconstruct();
23652:   if (NS_FAILED(rv)) {
23652:     batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
10073:     return;
23652:   }
10073: 
10073:   // Recalculate all of the style contexts for the document
10073:   // Note that we can ignore the return value of ComputeStyleChangeFor
10073:   // because we never need to reframe the root frame
10073:   // XXX This could be made faster by not rerunning rule matching
10073:   // (but note that nsPresShell::SetPreferenceStyleRules currently depends
10073:   // on us re-running rule matching here
10073:   nsStyleChangeList changeList;
11409:   // XXX Does it matter that we're passing aExtraHint to the real root
11409:   // frame and not the root node's primary frame?
10073:   mPresShell->FrameManager()->ComputeStyleChangeFor(mPresShell->GetRootFrame(),
11409:                                                     &changeList, aExtraHint);
10073:   // Process the required changes
10073:   ProcessRestyledFrames(changeList);
10073:   // Tell the style set it's safe to destroy the old rule tree.  We
10073:   // must do this after the ProcessRestyledFrames call in case the
10073:   // change list has frame reconstructs in it (since frames to be
10073:   // reconstructed will still have their old style context pointers
10073:   // until they are destroyed).
10073:   mPresShell->StyleSet()->EndReconstruct();
23652:   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
10073: }
10073: 
10073: void
    1: nsCSSFrameConstructor::ProcessPendingRestyles()
    1: {
22339:   NS_PRECONDITION(mDocument, "No document?  Pshaw!\n");
23256:   NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
23256:                   "Missing a script blocker!");
22339: 
    1:   PRUint32 count = mPendingRestyles.Count();
22339: 
22339:   if (count) {
 7713:     // Use the stack if we can, otherwise fall back on heap-allocation.
 7713:     nsAutoTArray<RestyleEnumerateData, RESTYLE_ARRAY_STACKSIZE> restyleArr;
 7713:     RestyleEnumerateData* restylesToProcess = restyleArr.AppendElements(count);
 7713:   
    1:     if (!restylesToProcess) {
    1:       return;
    1:     }
    1: 
 7713:     RestyleEnumerateData* lastRestyle = restylesToProcess;
    1:     mPendingRestyles.Enumerate(CollectRestyles, &lastRestyle);
    1: 
 7713:     NS_ASSERTION(lastRestyle - restylesToProcess == PRInt32(count),
    1:                  "Enumeration screwed up somehow");
    1: 
    1:     // Clear the hashtable so we don't end up trying to process a restyle we're
    1:     // already processing, sending us into an infinite loop.
    1:     mPendingRestyles.Clear();
    1: 
    1:     // Make sure to not rebuild quote or counter lists while we're
    1:     // processing restyles
    1:     BeginUpdate();
    1: 
 7713:     for (RestyleEnumerateData* currentRestyle = restylesToProcess;
    1:          currentRestyle != lastRestyle;
    1:          ++currentRestyle) {
    1:       ProcessOneRestyle(currentRestyle->mContent,
    1:                         currentRestyle->mRestyleHint,
    1:                         currentRestyle->mChangeHint);
    1:     }
    1: 
    1:     EndUpdate();
    1: 
    1: #ifdef DEBUG
    1:     mPresShell->VerifyStyleTree();
    1: #endif
22339:   }
10073: 
10073:   if (mRebuildAllStyleData) {
10073:     // We probably wasted a lot of work up above, but this seems safest
10073:     // and it should be rarely used.
11409:     RebuildAllStyleData(nsChangeHint(0));
10073:   }
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::PostRestyleEvent(nsIContent* aContent,
    1:                                         nsReStyleHint aRestyleHint,
    1:                                         nsChangeHint aMinChangeHint)
    1: {
10402:   if (NS_UNLIKELY(mIsDestroyingFrameTree)) {
10402:     NS_NOTREACHED("PostRestyleEvent after the shell is destroyed (bug 279505)");
10402:     return;
10402:   }
10402: 
    1:   if (aRestyleHint == 0 && !aMinChangeHint) {
    1:     // Nothing to do here
    1:     return;
    1:   }
    1: 
    1:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eELEMENT),
    1:                "Shouldn't be trying to restyle non-elements directly");
    1: 
    1:   RestyleData existingData;
    1:   existingData.mRestyleHint = nsReStyleHint(0);
    1:   existingData.mChangeHint = NS_STYLE_HINT_NONE;
    1: 
    1:   mPendingRestyles.Get(aContent, &existingData);
    1:   existingData.mRestyleHint =
    1:     nsReStyleHint(existingData.mRestyleHint | aRestyleHint);
    1:   NS_UpdateHint(existingData.mChangeHint, aMinChangeHint);
    1: 
    1:   mPendingRestyles.Put(aContent, existingData);
    1: 
22339:   PostRestyleEventInternal();
22339: }
22339:     
22339: void
22339: nsCSSFrameConstructor::PostRestyleEventInternal()
22339: {
    1:   if (!mRestyleEvent.IsPending()) {
    1:     nsRefPtr<RestyleEvent> ev = new RestyleEvent(this);
    1:     if (NS_FAILED(NS_DispatchToCurrentThread(ev))) {
    1:       NS_WARNING("failed to dispatch restyle event");
    1:       // XXXbz and what?
    1:     } else {
    1:       mRestyleEvent = ev;
    1:     }
    1:   }
    1: }
    1: 
10073: void
22339: nsCSSFrameConstructor::PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint)
22339: {
22339:   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
22339:                "Should not reconstruct the root of the frame tree.  "
22339:                "Use ReconstructDocElementHierarchy instead.");
22339: 
10073:   mRebuildAllStyleData = PR_TRUE;
22339:   NS_UpdateHint(mRebuildAllExtraHint, aExtraHint);
10073:   // Get a restyle event posted if necessary
22339:   PostRestyleEventInternal();
10073: }
10073: 
 6171: NS_IMETHODIMP nsCSSFrameConstructor::RestyleEvent::Run()
 6171: {
    1:   if (!mConstructor)
    1:     return NS_OK;  // event was revoked
    1: 
    1:   // Make sure that any restyles that happen from now on will go into
    1:   // a new event.
    1:   mConstructor->mRestyleEvent.Forget();  
    1:   
 6171:   return mConstructor->mPresShell->FlushPendingNotifications(Flush_Style);
    1: }
    1: 
 3129: NS_IMETHODIMP
 3129: nsCSSFrameConstructor::LazyGenerateChildrenEvent::Run()
 3129: {
 3129:   mPresShell->GetDocument()->FlushPendingNotifications(Flush_Layout);
 3129: 
 3129:   // this is hard-coded to handle only menu popup frames
 3129:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(mContent);
 3129:   if (frame && frame->GetType() == nsGkAtoms::menuPopupFrame) {
 3799: #ifdef MOZ_XUL
 3129:     // it is possible that the frame is different than the one that requested
 3129:     // the lazy generation, but as long as it's a popup frame that hasn't
 3129:     // generated its children yet, that's OK.
 3233:     nsMenuPopupFrame* menuPopupFrame = static_cast<nsMenuPopupFrame *>(frame);
 9758:     if (menuPopupFrame->HasGeneratedChildren()) {
 9758:       if (mCallback)
 9758:         mCallback(mContent, frame, mArg);
 9758:       
 9758:       return NS_OK;
 9758:     }     
 3129: 
 3129:     // indicate that the children have been generated
 3129:     menuPopupFrame->SetGeneratedChildren();
 3799: #endif
 3129: 
23256:    {
23256:       nsAutoScriptBlocker scriptBlocker;
 6518:       nsCSSFrameConstructor* fc = mPresShell->FrameConstructor();
 6518:       fc->BeginUpdate();
 6518: 
 3129:       nsFrameItems childItems;
 3129:       nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull);
23352:       nsresult rv = fc->ProcessChildren(state, mContent, frame->GetStyleContext(),
23352:                                         frame, PR_FALSE, childItems, PR_FALSE);
23652:       if (NS_FAILED(rv)) {
23652:         fc->EndUpdate();
23652:         return rv;
23652:       }
23167: 
 3129:       frame->SetInitialChildList(nsnull, childItems.childList);
 3129: 
 6518:       fc->EndUpdate();
23256:     }
 6518: 
 3129:     if (mCallback)
 3129:       mCallback(mContent, frame, mArg);
 3129: 
 3129:     // call XBL constructors after the frames are created
 3129:     mPresShell->GetDocument()->BindingManager()->ProcessAttachedQueue();
 3129:   }
 3129: 
 3129:   return NS_OK;
 3129: }
