    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
18084:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS parser.
    1:  *
    1:  * This is a recursive-descent parser for the JavaScript language specified by
    1:  * "The JavaScript 1.5 Language Specification".  It uses lexical and semantic
    1:  * feedback to disambiguate non-LL(1) structures.  It generates trees of nodes
    1:  * induced by the recursive parsing (not precise syntax trees, see jsparse.h).
    1:  * After tree construction, it rewrites trees to fold constants and evaluate
    1:  * compile-time expressions.  Finally, it calls js_EmitTree (see jsemit.h) to
    1:  * generate bytecode.
    1:  *
    1:  * This parser attempts no error recovery.
    1:  */
    1: #include "jsstddef.h"
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include <math.h>
    1: #include "jstypes.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsinterp.h"
15613: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
18989: #include "jsstaticcheck.h"
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: #include "jsdhash.h"
    1: #endif
    1: 
    1: /*
10466:  * Asserts to verify assumptions behind pn_ macros.
10466:  */
10466: JS_STATIC_ASSERT(offsetof(JSParseNode, pn_u.name.atom) ==
10466:                  offsetof(JSParseNode, pn_u.apair.atom));
10466: JS_STATIC_ASSERT(offsetof(JSParseNode, pn_u.name.slot) ==
10466:                  offsetof(JSParseNode, pn_u.lexical.slot));
10466: 
10466: /*
    1:  * JS parsers, from lowest to highest precedence.
    1:  *
    1:  * Each parser takes a context, a token stream, and a tree context struct.
    1:  * Each returns a parse node tree or null on error.
    1:  */
    1: 
    1: typedef JSParseNode *
    1: JSParser(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc);
    1: 
    1: typedef JSParseNode *
    1: JSMemberParser(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:                JSBool allowCallSyntax);
    1: 
    1: typedef JSParseNode *
    1: JSPrimaryParser(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:                 JSTokenType tt, JSBool afterDot);
    1: 
 1577: typedef JSParseNode *
 1577: JSParenParser(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
 1577:               JSParseNode *pn1, JSBool *genexp);
 1577: 
    1: static JSParser FunctionStmt;
    1: static JSParser FunctionExpr;
    1: static JSParser Statements;
    1: static JSParser Statement;
    1: static JSParser Variables;
    1: static JSParser Expr;
    1: static JSParser AssignExpr;
    1: static JSParser CondExpr;
    1: static JSParser OrExpr;
    1: static JSParser AndExpr;
    1: static JSParser BitOrExpr;
    1: static JSParser BitXorExpr;
    1: static JSParser BitAndExpr;
    1: static JSParser EqExpr;
    1: static JSParser RelExpr;
    1: static JSParser ShiftExpr;
    1: static JSParser AddExpr;
    1: static JSParser MulExpr;
    1: static JSParser UnaryExpr;
    1: static JSMemberParser  MemberExpr;
    1: static JSPrimaryParser PrimaryExpr;
 1577: static JSParenParser   ParenExpr;
    1: 
    1: /*
    1:  * Insist that the next token be of type tt, or report errno and return null.
    1:  * NB: this macro uses cx and ts from its lexical environment.
    1:  */
    1: #define MUST_MATCH_TOKEN(tt, errno)                                           \
    1:     JS_BEGIN_MACRO                                                            \
    1:         if (js_GetToken(cx, ts) != tt) {                                      \
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR, errno); \
    1:             return NULL;                                                      \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
    1: #ifdef METER_PARSENODES
    1: static uint32 parsenodes = 0;
    1: static uint32 maxparsenodes = 0;
    1: static uint32 recyclednodes = 0;
    1: #endif
    1: 
 8444: JSBool
 8444: js_InitParseContext(JSContext *cx, JSParseContext *pc, JSPrincipals *principals,
18955:                     JSStackFrame *callerFrame,
 6561:                     const jschar *base, size_t length,
 6561:                     FILE *fp, const char *filename, uintN lineno)
 3235: {
18955:     JS_ASSERT_IF(callerFrame, callerFrame->script);
18955: 
 6561:     pc->tempPoolMark = JS_ARENA_MARK(&cx->tempPool);
 6561:     if (!js_InitTokenStream(cx, TS(pc), base, length, fp, filename, lineno)) {
 6561:         JS_ARENA_RELEASE(&cx->tempPool, pc->tempPoolMark);
 6561:         return JS_FALSE;
 6561:     }
 8444:     if (principals)
 8444:         JSPRINCIPALS_HOLD(cx, principals);
 8444:     pc->principals = principals;
18955:     pc->callerFrame = callerFrame;
 3235:     pc->nodeList = NULL;
 3235:     pc->traceListHead = NULL;
 3235: 
 3235:     /* Root atoms and objects allocated for the parsed tree. */
 3235:     JS_KEEP_ATOMS(cx->runtime);
 3235:     JS_PUSH_TEMP_ROOT_PARSE_CONTEXT(cx, pc, &pc->tempRoot);
 6561:     return JS_TRUE;
 3235: }
 3235: 
 3235: void
 3235: js_FinishParseContext(JSContext *cx, JSParseContext *pc)
 3235: {
 6561:     if (pc->principals)
 6561:         JSPRINCIPALS_DROP(cx, pc->principals);
 3235:     JS_ASSERT(pc->tempRoot.u.parseContext == pc);
 3235:     JS_POP_TEMP_ROOT(cx, &pc->tempRoot);
 3235:     JS_UNKEEP_ATOMS(cx->runtime);
 6561:     js_CloseTokenStream(cx, TS(pc));
 6561:     JS_ARENA_RELEASE(&cx->tempPool, pc->tempPoolMark);
 6561: }
 6561: 
 6561: void
 6561: js_InitCompilePrincipals(JSContext *cx, JSParseContext *pc,
 6561:                          JSPrincipals *principals)
 6561: {
 6561:     JS_ASSERT(!pc->principals);
 6561:     if (principals)
 6561:         JSPRINCIPALS_HOLD(cx, principals);
 6561:     pc->principals = principals;
 3235: }
 3235: 
 3235: JSParsedObjectBox *
 3235: js_NewParsedObjectBox(JSContext *cx, JSParseContext *pc, JSObject *obj)
 3235: {
 3235:     JSParsedObjectBox *pob;
 3235: 
 3235:     /*
 3235:      * We use JSContext.tempPool to allocate parsed objects and place them on
11534:      * a list in JSTokenStream to ensure GC safety. Thus the tempPool arenas
11534:      * containing the entries must be alive until we are done with scanning,
 3235:      * parsing and code generation for the whole script or top-level function.
 3235:      */
 3235:     JS_ASSERT(obj);
 3235:     JS_ARENA_ALLOCATE_TYPE(pob, JSParsedObjectBox, &cx->tempPool);
 3235:     if (!pob) {
 8296:         js_ReportOutOfScriptQuota(cx);
 3235:         return NULL;
 3235:     }
 3235:     pob->traceLink = pc->traceListHead;
 3235:     pob->emitLink = NULL;
 3235:     pob->object = obj;
 3235:     pc->traceListHead = pob;
 3235:     return pob;
 3235: }
 3235: 
 3235: 
 3235: void
 3235: js_TraceParseContext(JSTracer *trc, JSParseContext *pc)
 3235: {
 3235:     JSParsedObjectBox *pob;
 3235: 
 3235:     JS_ASSERT(pc->tempRoot.u.parseContext == pc);
 3235:     pob = pc->traceListHead;
 3235:     while (pob) {
 3235:         JS_CALL_OBJECT_TRACER(trc, pob->object, "parser.object");
 3235:         pob = pob->traceLink;
 3235:     }
 3235: }
 3235: 
    1: static JSParseNode *
    1: RecycleTree(JSParseNode *pn, JSTreeContext *tc)
    1: {
    1:     JSParseNode *next;
    1: 
    1:     if (!pn)
    1:         return NULL;
 3235: 
 3235:     /* Catch back-to-back dup recycles. */
 3235:     JS_ASSERT(pn != tc->parseContext->nodeList);
    1:     next = pn->pn_next;
 3235:     pn->pn_next = tc->parseContext->nodeList;
 3235:     tc->parseContext->nodeList = pn;
    1: #ifdef METER_PARSENODES
    1:     recyclednodes++;
    1: #endif
    1:     return next;
    1: }
    1: 
    1: static JSParseNode *
    1: NewOrRecycledNode(JSContext *cx, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
 3235:     pn = tc->parseContext->nodeList;
    1:     if (!pn) {
    1:         JS_ARENA_ALLOCATE_TYPE(pn, JSParseNode, &cx->tempPool);
    1:         if (!pn)
 8296:             js_ReportOutOfScriptQuota(cx);
    1:     } else {
 3235:         tc->parseContext->nodeList = pn->pn_next;
    1: 
    1:         /* Recycle immediate descendents only, to save work and working set. */
    1:         switch (pn->pn_arity) {
    1:           case PN_FUNC:
    1:             RecycleTree(pn->pn_body, tc);
    1:             break;
    1:           case PN_LIST:
    1:             if (pn->pn_head) {
    1:                 /* XXX check for dup recycles in the list */
 3235:                 *pn->pn_tail = tc->parseContext->nodeList;
 3235:                 tc->parseContext->nodeList = pn->pn_head;
    1: #ifdef METER_PARSENODES
    1:                 recyclednodes += pn->pn_count;
    1: #endif
    1:             }
    1:             break;
    1:           case PN_TERNARY:
    1:             RecycleTree(pn->pn_kid1, tc);
    1:             RecycleTree(pn->pn_kid2, tc);
    1:             RecycleTree(pn->pn_kid3, tc);
    1:             break;
    1:           case PN_BINARY:
15154:             if (pn->pn_left != pn->pn_right)
    1:                 RecycleTree(pn->pn_left, tc);
    1:             RecycleTree(pn->pn_right, tc);
    1:             break;
    1:           case PN_UNARY:
    1:             RecycleTree(pn->pn_kid, tc);
    1:             break;
    1:           case PN_NAME:
    1:             RecycleTree(pn->pn_expr, tc);
    1:             break;
    1:           case PN_NULLARY:
    1:             break;
    1:         }
    1:     }
 2567:     if (pn) {
    1: #ifdef METER_PARSENODES
    1:         parsenodes++;
    1:         if (parsenodes - recyclednodes > maxparsenodes)
    1:             maxparsenodes = parsenodes - recyclednodes;
    1: #endif
 1577:         memset(&pn->pn_u, 0, sizeof pn->pn_u);
 1577:         pn->pn_next = NULL;
 2567:     }
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Allocate a JSParseNode from cx's temporary arena.
    1:  */
    1: static JSParseNode *
    1: NewParseNode(JSContext *cx, JSTokenStream *ts, JSParseNodeArity arity,
    1:              JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSToken *tp;
    1: 
    1:     pn = NewOrRecycledNode(cx, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     tp = &CURRENT_TOKEN(ts);
    1:     pn->pn_type = tp->type;
    1:     pn->pn_pos = tp->pos;
    1:     pn->pn_op = JSOP_NOP;
    1:     pn->pn_arity = arity;
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: NewBinary(JSContext *cx, JSTokenType tt,
    1:           JSOp op, JSParseNode *left, JSParseNode *right,
    1:           JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn1, *pn2;
    1: 
    1:     if (!left || !right)
    1:         return NULL;
    1: 
    1:     /*
    1:      * Flatten a left-associative (left-heavy) tree of a given operator into
    1:      * a list, to reduce js_FoldConstants and js_EmitTree recursion.
    1:      */
    1:     if (left->pn_type == tt &&
    1:         left->pn_op == op &&
    1:         (js_CodeSpec[op].format & JOF_LEFTASSOC)) {
    1:         if (left->pn_arity != PN_LIST) {
    1:             pn1 = left->pn_left, pn2 = left->pn_right;
    1:             left->pn_arity = PN_LIST;
    1:             PN_INIT_LIST_1(left, pn1);
    1:             PN_APPEND(left, pn2);
    1:             if (tt == TOK_PLUS) {
    1:                 if (pn1->pn_type == TOK_STRING)
    1:                     left->pn_extra |= PNX_STRCAT;
    1:                 else if (pn1->pn_type != TOK_NUMBER)
    1:                     left->pn_extra |= PNX_CANTFOLD;
    1:                 if (pn2->pn_type == TOK_STRING)
    1:                     left->pn_extra |= PNX_STRCAT;
    1:                 else if (pn2->pn_type != TOK_NUMBER)
    1:                     left->pn_extra |= PNX_CANTFOLD;
    1:             }
    1:         }
    1:         PN_APPEND(left, right);
    1:         left->pn_pos.end = right->pn_pos.end;
    1:         if (tt == TOK_PLUS) {
    1:             if (right->pn_type == TOK_STRING)
    1:                 left->pn_extra |= PNX_STRCAT;
    1:             else if (right->pn_type != TOK_NUMBER)
    1:                 left->pn_extra |= PNX_CANTFOLD;
    1:         }
    1:         return left;
    1:     }
    1: 
    1:     /*
    1:      * Fold constant addition immediately, to conserve node space and, what's
    1:      * more, so js_FoldConstants never sees mixed addition and concatenation
    1:      * operations with more than one leading non-string operand in a PN_LIST
    1:      * generated for expressions such as 1 + 2 + "pt" (which should evaluate
    1:      * to "3pt", not "12pt").
    1:      */
    1:     if (tt == TOK_PLUS &&
    1:         left->pn_type == TOK_NUMBER &&
    1:         right->pn_type == TOK_NUMBER) {
    1:         left->pn_dval += right->pn_dval;
    1:         left->pn_pos.end = right->pn_pos.end;
    1:         RecycleTree(right, tc);
    1:         return left;
    1:     }
    1: 
    1:     pn = NewOrRecycledNode(cx, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_type = tt;
    1:     pn->pn_pos.begin = left->pn_pos.begin;
    1:     pn->pn_pos.end = right->pn_pos.end;
    1:     pn->pn_op = op;
    1:     pn->pn_arity = PN_BINARY;
    1:     pn->pn_left = left;
    1:     pn->pn_right = right;
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_GETTER_SETTER
    1: static JSTokenType
    1: CheckGetterOrSetter(JSContext *cx, JSTokenStream *ts, JSTokenType tt)
    1: {
    1:     JSAtom *atom;
    1:     JSRuntime *rt;
    1:     JSOp op;
    1:     const char *name;
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_NAME);
    1:     atom = CURRENT_TOKEN(ts).t_atom;
    1:     rt = cx->runtime;
    1:     if (atom == rt->atomState.getterAtom)
    1:         op = JSOP_GETTER;
    1:     else if (atom == rt->atomState.setterAtom)
    1:         op = JSOP_SETTER;
    1:     else
    1:         return TOK_NAME;
    1:     if (js_PeekTokenSameLine(cx, ts) != tt)
    1:         return TOK_NAME;
    1:     (void) js_GetToken(cx, ts);
    1:     if (CURRENT_TOKEN(ts).t_op != JSOP_NOP) {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_GETTER_OR_SETTER,
    1:                                     (op == JSOP_GETTER)
    1:                                     ? js_getter_str
    1:                                     : js_setter_str);
    1:         return TOK_ERROR;
    1:     }
    1:     CURRENT_TOKEN(ts).t_op = op;
    1:     if (JS_HAS_STRICT_OPTION(cx)) {
    1:         name = js_AtomToPrintableString(cx, atom);
    1:         if (!name ||
 7984:             !js_ReportCompileErrorNumber(cx, ts, NULL,
 7984:                                          JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                          JSMSG_DEPRECATED_USAGE,
    1:                                          name)) {
    1:             return TOK_ERROR;
    1:         }
    1:     }
    1:     return tt;
    1: }
    1: #endif
    1: 
    1: /*
    1:  * Parse a top-level JS script.
    1:  */
 8444: JSParseNode *
 6561: js_ParseScript(JSContext *cx, JSObject *chain, JSParseContext *pc)
    1: {
    1:     JSTreeContext tc;
    1:     JSParseNode *pn;
    1: 
    1:     /*
    1:      * Protect atoms from being collected by a GC activation, which might
    1:      * - nest on this thread due to out of memory (the so-called "last ditch"
    1:      *   GC attempted within js_NewGCThing), or
    1:      * - run for any reason on another thread if this thread is suspended on
    1:      *   an object lock before it finishes generating bytecode into a script
    1:      *   protected from the GC by a root or a stack frame reference.
    1:      */
 6561:     TREE_CONTEXT_INIT(&tc, pc);
18955:     tc.u.scopeChain = chain;
 6561:     pn = Statements(cx, TS(pc), &tc);
    1:     if (pn) {
 6561:         if (!js_MatchToken(cx, TS(pc), TOK_EOF)) {
 7984:             js_ReportCompileErrorNumber(cx, TS(pc), NULL, JSREPORT_ERROR,
    1:                                         JSMSG_SYNTAX_ERROR);
    1:             pn = NULL;
    1:         } else {
    1:             pn->pn_type = TOK_LC;
    1:             if (!js_FoldConstants(cx, pn, &tc))
    1:                 pn = NULL;
    1:         }
    1:     }
    1: 
16072:     TREE_CONTEXT_FINISH(cx, &tc);
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Compile a top-level script.
    1:  */
18955: extern JSScript *
18955: js_CompileScript(JSContext *cx, JSObject *scopeChain, JSStackFrame *callerFrame,
18955:                  JSPrincipals *principals, uint32 tcflags,
18955:                  const jschar *chars, size_t length,
 8444:                  FILE *file, const char *filename, uintN lineno)
    1: {
 8444:     JSParseContext pc;
 6561:     JSArenaPool codePool, notePool;
 6561:     JSCodeGenerator cg;
 9604:     JSTokenType tt;
    1:     JSParseNode *pn;
16072:     uint32 scriptGlobals;
 6561:     JSScript *script;
    1: #ifdef METER_PARSENODES
    1:     void *sbrk(ptrdiff_t), *before = sbrk(0);
    1: #endif
    1: 
18955:     JS_ASSERT(!(tcflags & ~(TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL |
18955:                             TCF_STATIC_DEPTH_MASK)));
 8444: 
    1:     /*
18955:      * The scripted callerFrame can only be given for compile-and-go scripts
18955:      * and non-zero static depth requires callerFrame.
    1:      */
18955:     JS_ASSERT_IF(callerFrame, tcflags & TCF_COMPILE_N_GO);
18955:     JS_ASSERT_IF(TCF_GET_STATIC_DEPTH(tcflags) != 0, callerFrame);
18955: 
18955:     if (!js_InitParseContext(cx, &pc, principals, callerFrame, chars, length,
18955:                              file, filename, lineno)) {
18955:         return NULL;
18955:     }
    1: 
 6561:     JS_INIT_ARENA_POOL(&codePool, "code", 1024, sizeof(jsbytecode),
 6561:                        &cx->scriptStackQuota);
 6561:     JS_INIT_ARENA_POOL(&notePool, "note", 1024, sizeof(jssrcnote),
 6561:                        &cx->scriptStackQuota);
 8444:     js_InitCodeGenerator(cx, &cg, &pc, &codePool, &notePool,
 8444:                          pc.tokenStream.lineno);
 6561: 
18989:     MUST_FLOW_THROUGH("out");
18517:     cg.treeContext.flags |= (uint16) tcflags;
18955:     cg.treeContext.u.scopeChain = scopeChain;
18517:     cg.staticDepth = TCF_GET_STATIC_DEPTH(tcflags);
 9604: 
21451:     if ((tcflags & TCF_COMPILE_N_GO) && callerFrame && callerFrame->fun) {
21449:         /*
21449:          * An eval script in a caller frame needs to have its enclosing function
21449:          * captured in case it uses an upvar reference, and someone wishes to
21449:          * decompile it while running.
21449:          */
24153:         JSParsedObjectBox *pob = js_NewParsedObjectBox(cx, &pc, FUN_OBJECT(callerFrame->fun));
21449:         pob->emitLink = cg.objectList.lastPob;
21449:         cg.objectList.lastPob = pob;
21449:         cg.objectList.length++;
21449:     }
21449: 
18955:     /* Inline Statements() to emit as we go to save space. */
 9604:     for (;;) {
 9604:         pc.tokenStream.flags |= TSF_OPERAND;
 9604:         tt = js_PeekToken(cx, &pc.tokenStream);
 9604:         pc.tokenStream.flags &= ~TSF_OPERAND;
 9604:         if (tt <= TOK_EOF) {
 9604:             if (tt == TOK_EOF)
 9604:                 break;
 9604:             JS_ASSERT(tt == TOK_ERROR);
 9604:             script = NULL;
 9604:             goto out;
 9604:         }
 9604: 
 9604:         pn = Statement(cx, &pc.tokenStream, &cg.treeContext);
    1:         if (!pn) {
 6561:             script = NULL;
 6561:             goto out;
 6561:         }
 9604:         JS_ASSERT(!cg.treeContext.blockNode);
 9604: 
 9604:         if (!js_FoldConstants(cx, pn, &cg.treeContext) ||
 9604:             !js_EmitTree(cx, &cg, pn)) {
 6561:             script = NULL;
 6561:             goto out;
 6561:         }
 9604:         RecycleTree(pn, &cg.treeContext);
 9604:     }
 9604: 
16072:     /*
17947:      * Global variables and regexps shares the index space with locals. Due to
17947:      * incremental code generation we need to patch the bytecode to adjust the
17947:      * local references to skip the globals.
16072:      */
16072:     scriptGlobals = cg.treeContext.ngvars + cg.regexpList.length;
16072:     if (scriptGlobals != 0) {
16072:         jsbytecode *code, *end;
16072:         JSOp op;
16072:         const JSCodeSpec *cs;
16072:         uintN len, slot;
16072: 
16072:         if (scriptGlobals >= SLOTNO_LIMIT)
16072:             goto too_many_slots;
16072:         code = CG_BASE(&cg);
16072:         for (end = code + CG_OFFSET(&cg); code != end; code += len) {
16072:             JS_ASSERT(code < end);
16072:             op = (JSOp) *code;
16072:             cs = &js_CodeSpec[op];
17947:             len = (cs->length > 0)
16072:                   ? (uintN) cs->length
16072:                   : js_GetVariableBytecodeLength(code);
16072:             if (JOF_TYPE(cs->format) == JOF_LOCAL ||
16072:                 (JOF_TYPE(cs->format) == JOF_SLOTATOM)) {
16072:                 /*
16429:                  * JSOP_GETARGPROP also has JOF_SLOTATOM type, but it may be
16429:                  * emitted only for a function.
16072:                  */
16072:                 JS_ASSERT((JOF_TYPE(cs->format) == JOF_SLOTATOM) ==
16072:                           (op == JSOP_GETLOCALPROP));
16072:                 slot = GET_SLOTNO(code);
16072:                 slot += scriptGlobals;
16072:                 if (slot >= SLOTNO_LIMIT)
16072:                     goto too_many_slots;
16072:                 SET_SLOTNO(code, slot);
16072:             }
16072:         }
16072:     }
16072: 
    1: #ifdef METER_PARSENODES
    1:     printf("Parser growth: %d (%u nodes, %u max, %u unrecycled)\n",
    1:            (char *)sbrk(0) - (char *)before,
    1:            parsenodes,
    1:            maxparsenodes,
    1:            parsenodes - recyclednodes);
    1:     before = sbrk(0);
    1: #endif
    1: 
    1:     /*
    1:      * Nowadays the threaded interpreter needs a stop instruction, so we
    1:      * do have to emit that here.
    1:      */
 6561:     if (js_Emit1(cx, &cg, JSOP_STOP) < 0) {
 6561:         script = NULL;
 6561:         goto out;
 6561:     }
    1: #ifdef METER_PARSENODES
    1:     printf("Code-gen growth: %d (%u bytecodes, %u srcnotes)\n",
    1:            (char *)sbrk(0) - (char *)before, CG_OFFSET(cg), cg->noteCount);
    1: #endif
    1: #ifdef JS_ARENAMETER
    1:     JS_DumpArenaStats(stdout);
    1: #endif
 8444:     script = js_NewScriptFromCG(cx, &cg);
 6561: 
10217: #ifdef JS_SCOPE_DEPTH_METER
10217:     if (script) {
18955:         JSObject *obj = scopeChain;
10217:         uintN depth = 1;
18955:         while ((obj = OBJ_GET_PARENT(cx, obj)) != NULL)
10217:             ++depth;
10217:         JS_BASIC_STATS_ACCUM(&cx->runtime->hostenvScopeDepthStats, depth);
10217:     }
10217: #endif
10217: 
 6561:   out:
 6561:     js_FinishCodeGenerator(cx, &cg);
 6561:     JS_FinishArenaPool(&codePool);
 6561:     JS_FinishArenaPool(&notePool);
 8444:     js_FinishParseContext(cx, &pc);
 6561:     return script;
16072: 
16072:   too_many_slots:
16072:     js_ReportCompileErrorNumber(cx, &pc.tokenStream, NULL,
16072:                                 JSREPORT_ERROR, JSMSG_TOO_MANY_LOCALS);
16072:     script = NULL;
16072:     goto out;
    1: }
    1: 
    1: /*
    1:  * Insist on a final return before control flows out of pn.  Try to be a bit
    1:  * smart about loops: do {...; return e2;} while(0) at the end of a function
    1:  * that contains an early return e1 will get a strict warning.  Similarly for
    1:  * iloops: while (true){...} is treated as though ... returns.
    1:  */
    1: #define ENDS_IN_OTHER   0
    1: #define ENDS_IN_RETURN  1
    1: #define ENDS_IN_BREAK   2
    1: 
    1: static int
    1: HasFinalReturn(JSParseNode *pn)
    1: {
    1:     JSParseNode *pn2, *pn3;
    1:     uintN rv, rv2, hasDefault;
    1: 
    1:     switch (pn->pn_type) {
    1:       case TOK_LC:
    1:         if (!pn->pn_head)
    1:             return ENDS_IN_OTHER;
    1:         return HasFinalReturn(PN_LAST(pn));
    1: 
    1:       case TOK_IF:
    1:         if (!pn->pn_kid3)
    1:             return ENDS_IN_OTHER;
    1:         return HasFinalReturn(pn->pn_kid2) & HasFinalReturn(pn->pn_kid3);
    1: 
    1:       case TOK_WHILE:
    1:         pn2 = pn->pn_left;
    1:         if (pn2->pn_type == TOK_PRIMARY && pn2->pn_op == JSOP_TRUE)
    1:             return ENDS_IN_RETURN;
    1:         if (pn2->pn_type == TOK_NUMBER && pn2->pn_dval)
    1:             return ENDS_IN_RETURN;
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_DO:
    1:         pn2 = pn->pn_right;
    1:         if (pn2->pn_type == TOK_PRIMARY) {
    1:             if (pn2->pn_op == JSOP_FALSE)
    1:                 return HasFinalReturn(pn->pn_left);
    1:             if (pn2->pn_op == JSOP_TRUE)
    1:                 return ENDS_IN_RETURN;
    1:         }
    1:         if (pn2->pn_type == TOK_NUMBER) {
    1:             if (pn2->pn_dval == 0)
    1:                 return HasFinalReturn(pn->pn_left);
    1:             return ENDS_IN_RETURN;
    1:         }
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_FOR:
    1:         pn2 = pn->pn_left;
    1:         if (pn2->pn_arity == PN_TERNARY && !pn2->pn_kid2)
    1:             return ENDS_IN_RETURN;
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_SWITCH:
    1:         rv = ENDS_IN_RETURN;
    1:         hasDefault = ENDS_IN_OTHER;
    1:         pn2 = pn->pn_right;
    1:         if (pn2->pn_type == TOK_LEXICALSCOPE)
    1:             pn2 = pn2->pn_expr;
    1:         for (pn2 = pn2->pn_head; rv && pn2; pn2 = pn2->pn_next) {
    1:             if (pn2->pn_type == TOK_DEFAULT)
    1:                 hasDefault = ENDS_IN_RETURN;
    1:             pn3 = pn2->pn_right;
    1:             JS_ASSERT(pn3->pn_type == TOK_LC);
    1:             if (pn3->pn_head) {
    1:                 rv2 = HasFinalReturn(PN_LAST(pn3));
    1:                 if (rv2 == ENDS_IN_OTHER && pn2->pn_next)
    1:                     /* Falling through to next case or default. */;
    1:                 else
    1:                     rv &= rv2;
    1:             }
    1:         }
    1:         /* If a final switch has no default case, we judge it harshly. */
    1:         rv &= hasDefault;
    1:         return rv;
    1: 
    1:       case TOK_BREAK:
    1:         return ENDS_IN_BREAK;
    1: 
    1:       case TOK_WITH:
    1:         return HasFinalReturn(pn->pn_right);
    1: 
    1:       case TOK_RETURN:
    1:         return ENDS_IN_RETURN;
    1: 
    1:       case TOK_COLON:
    1:       case TOK_LEXICALSCOPE:
    1:         return HasFinalReturn(pn->pn_expr);
    1: 
    1:       case TOK_THROW:
    1:         return ENDS_IN_RETURN;
    1: 
    1:       case TOK_TRY:
    1:         /* If we have a finally block that returns, we are done. */
    1:         if (pn->pn_kid3) {
    1:             rv = HasFinalReturn(pn->pn_kid3);
    1:             if (rv == ENDS_IN_RETURN)
    1:                 return rv;
    1:         }
    1: 
    1:         /* Else check the try block and any and all catch statements. */
    1:         rv = HasFinalReturn(pn->pn_kid1);
    1:         if (pn->pn_kid2) {
    1:             JS_ASSERT(pn->pn_kid2->pn_arity == PN_LIST);
    1:             for (pn2 = pn->pn_kid2->pn_head; pn2; pn2 = pn2->pn_next)
    1:                 rv &= HasFinalReturn(pn2);
    1:         }
    1:         return rv;
    1: 
    1:       case TOK_CATCH:
    1:         /* Check this catch block's body. */
    1:         return HasFinalReturn(pn->pn_kid3);
    1: 
    1:       case TOK_LET:
    1:         /* Non-binary let statements are let declarations. */
    1:         if (pn->pn_arity != PN_BINARY)
    1:             return ENDS_IN_OTHER;
    1:         return HasFinalReturn(pn->pn_right);
    1: 
    1:       default:
    1:         return ENDS_IN_OTHER;
    1:     }
    1: }
    1: 
    1: static JSBool
 8444: ReportBadReturn(JSContext *cx, JSTreeContext *tc, uintN flags, uintN errnum,
    1:                 uintN anonerrnum)
    1: {
    1:     const char *name;
    1: 
 8444:     JS_ASSERT(tc->flags & TCF_IN_FUNCTION);
18955:     if (tc->u.fun->atom) {
18955:         name = js_AtomToPrintableString(cx, tc->u.fun->atom);
    1:     } else {
    1:         errnum = anonerrnum;
    1:         name = NULL;
    1:     }
 8444:     return js_ReportCompileErrorNumber(cx, TS(tc->parseContext), NULL, flags,
 8444:                                        errnum, name);
    1: }
    1: 
    1: static JSBool
 8444: CheckFinalReturn(JSContext *cx, JSTreeContext *tc, JSParseNode *pn)
    1: {
 8444:     JS_ASSERT(tc->flags & TCF_IN_FUNCTION);
    1:     return HasFinalReturn(pn) == ENDS_IN_RETURN ||
 8444:            ReportBadReturn(cx, tc, JSREPORT_WARNING | JSREPORT_STRICT,
    1:                            JSMSG_NO_RETURN_VALUE, JSMSG_ANON_NO_RETURN_VALUE);
    1: }
    1: 
    1: static JSParseNode *
 8444: FunctionBody(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSStmtInfo stmtInfo;
    1:     uintN oldflags, firstLine;
    1:     JSParseNode *pn;
    1: 
 8444:     JS_ASSERT(tc->flags & TCF_IN_FUNCTION);
    1:     js_PushStatement(tc, &stmtInfo, STMT_BLOCK, -1);
    1:     stmtInfo.flags = SIF_BODY_BLOCK;
    1: 
    1:     oldflags = tc->flags;
    1:     tc->flags &= ~(TCF_RETURN_EXPR | TCF_RETURN_VOID);
    1: 
    1:     /*
    1:      * Save the body's first line, and store it in pn->pn_pos.begin.lineno
    1:      * later, because we may have not peeked in ts yet, so Statements won't
    1:      * acquire a valid pn->pn_pos.begin from the current token.
    1:      */
    1:     firstLine = ts->lineno;
 1967: #if JS_HAS_EXPR_CLOSURES
 1967:     if (CURRENT_TOKEN(ts).type == TOK_LC) {
    1:         pn = Statements(cx, ts, tc);
 1967:     } else {
 1967:         pn = NewParseNode(cx, ts, PN_UNARY, tc);
 1967:         if (pn) {
 1967:             pn->pn_kid = AssignExpr(cx, ts, tc);
 1967:             if (!pn->pn_kid) {
 1967:                 pn = NULL;
 1967:             } else {
 1967:                 if (tc->flags & TCF_FUN_IS_GENERATOR) {
 8444:                     ReportBadReturn(cx, tc, JSREPORT_ERROR,
 1967:                                     JSMSG_BAD_GENERATOR_RETURN,
 1967:                                     JSMSG_BAD_ANON_GENERATOR_RETURN);
 1967:                     pn = NULL;
 1967:                 } else {
 1967:                     pn->pn_type = TOK_RETURN;
 1967:                     pn->pn_op = JSOP_RETURN;
 1967:                     pn->pn_pos.end = pn->pn_kid->pn_pos.end;
 1967:                 }
 1967:             }
 1967:         }
 1967:     }
 1967: #else
 1967:     pn = Statements(cx, ts, tc);
 1967: #endif
    1: 
10299:     if (pn) {
    1:         js_PopStatement(tc);
10299:         pn->pn_pos.begin.lineno = firstLine;
    1: 
    1:         /* Check for falling off the end of a function that returns a value. */
10299:         if (JS_HAS_STRICT_OPTION(cx) && (tc->flags & TCF_RETURN_EXPR) &&
10299:             !CheckFinalReturn(cx, tc, pn)) {
    1:             pn = NULL;
    1:         }
10299:     }
 8444: 
    1:     tc->flags = oldflags | (tc->flags & (TCF_FUN_FLAGS | TCF_HAS_DEFXMLNS));
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Compile a JS function body, which might appear as the value of an event
    1:  * handler attribute in an HTML <INPUT> tag.
    1:  */
    1: JSBool
13702: js_CompileFunctionBody(JSContext *cx, JSFunction *fun, JSPrincipals *principals,
 8444:                        const jschar *chars, size_t length,
 8444:                        const char *filename, uintN lineno)
    1: {
 8444:     JSParseContext pc;
    1:     JSArenaPool codePool, notePool;
    1:     JSCodeGenerator funcg;
    1:     JSParseNode *pn;
    1: 
18955:     if (!js_InitParseContext(cx, &pc, principals, NULL, chars, length, NULL,
 8444:                              filename, lineno)) {
    1:         return JS_FALSE;
    1:     }
    1: 
 8444:     /* No early return from this point until js_FinishParseContext call. */
 5344:     JS_INIT_ARENA_POOL(&codePool, "code", 1024, sizeof(jsbytecode),
 5344:                        &cx->scriptStackQuota);
 5344:     JS_INIT_ARENA_POOL(&notePool, "note", 1024, sizeof(jssrcnote),
 5344:                        &cx->scriptStackQuota);
 8444:     js_InitCodeGenerator(cx, &funcg, &pc, &codePool, &notePool,
 8444:                          pc.tokenStream.lineno);
 8444:     funcg.treeContext.flags |= TCF_IN_FUNCTION;
18955:     funcg.treeContext.u.fun = fun;
    1: 
    1:     /*
    1:      * Farble the body so that it looks like a block statement to js_EmitTree,
    1:      * which is called beneath FunctionBody; see Statements, further below in
    1:      * this file.  FunctionBody pushes a STMT_BLOCK record around its call to
    1:      * Statements, so Statements will not compile each statement as it loops
    1:      * to save JSParseNode space -- it will not compile at all, only build a
    1:      * JSParseNode tree.
    1:      *
    1:      * Therefore we must fold constants, allocate try notes, and generate code
    1:      * for this function, including a stop opcode at the end.
    1:      */
 8444:     CURRENT_TOKEN(&pc.tokenStream).type = TOK_LC;
 8444:     pn = FunctionBody(cx, &pc.tokenStream, &funcg.treeContext);
    1:     if (pn) {
 8444:         if (!js_MatchToken(cx, &pc.tokenStream, TOK_EOF)) {
 8444:             js_ReportCompileErrorNumber(cx, &pc.tokenStream, NULL,
 8444:                                         JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:             pn = NULL;
    1:         } else {
 8444:             if (!js_FoldConstants(cx, pn, &funcg.treeContext) ||
 9786:                 !js_EmitFunctionScript(cx, &funcg, pn)) {
    1:                 pn = NULL;
    1:             }
    1:         }
 8444:     }
    1: 
    1:     /* Restore saved state and release code generation arenas. */
    1:     js_FinishCodeGenerator(cx, &funcg);
    1:     JS_FinishArenaPool(&codePool);
    1:     JS_FinishArenaPool(&notePool);
 8444:     js_FinishParseContext(cx, &pc);
    1:     return pn != NULL;
    1: }
    1: 
    1: /*
    1:  * Parameter block types for the several Binder functions.  We use a common
    1:  * helper function signature in order to share code among destructuring and
    1:  * simple variable declaration parsers.  In the destructuring case, the binder
    1:  * function is called indirectly from the variable declaration parser by way
    1:  * of CheckDestructuring and its friends.
    1:  */
    1: typedef struct BindData BindData;
    1: 
    1: typedef JSBool
    1: (*Binder)(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc);
    1: 
    1: struct BindData {
    1:     JSParseNode             *pn;                /* error source coordinate */
    1:     JSOp                    op;                 /* prolog bytecode or nop */
    1:     Binder                  binder;             /* binder, discriminates u */
    1:     union {
    1:         struct {
    1:             uintN           overflow;
    1:         } let;
    1:     } u;
    1: };
    1: 
    1: static JSBool
 8444: BindArg(JSContext *cx, JSAtom *atom, JSTreeContext *tc)
    1: {
    1:     const char *name;
    1: 
    1:     /*
 8179:      * Check for a duplicate parameter name, a "feature" required by ECMA-262.
    1:      */
 8444:     JS_ASSERT(tc->flags & TCF_IN_FUNCTION);
18955:     if (js_LookupLocal(cx, tc->u.fun, atom, NULL) != JSLOCAL_NONE) {
    1:         name = js_AtomToPrintableString(cx, atom);
 8179:         if (!name ||
 8444:             !js_ReportCompileErrorNumber(cx, TS(tc->parseContext), NULL,
 7984:                                          JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                          JSMSG_DUPLICATE_FORMAL,
 8179:                                          name)) {
    1:             return JS_FALSE;
 8179:         }
 8179:     }
 8179: 
18955:     return js_AddLocal(cx, tc->u.fun, atom, JSLOCAL_ARG);
    1: }
    1: 
    1: static JSBool
13702: BindLocalVariable(JSContext *cx, JSFunction *fun, JSAtom *atom,
 8444:                   JSLocalKind localKind)
    1: {
 8444:     JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
    1: 
    1:     /*
    1:      * Don't bind a variable with the hidden name 'arguments', per ECMA-262.
    1:      * Instead 'var arguments' always restates the predefined property of the
    1:      * activation objects with unhidden name 'arguments'.  Assignment to such
    1:      * a variable must be handled specially.
    1:      */
    1:     if (atom == cx->runtime->atomState.argumentsAtom)
    1:         return JS_TRUE;
    1: 
 8444:     return js_AddLocal(cx, fun, atom, localKind);
    1: }
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: /*
    1:  * Forward declaration to maintain top-down presentation.
    1:  */
    1: static JSParseNode *
    1: DestructuringExpr(JSContext *cx, BindData *data, JSTreeContext *tc,
    1:                   JSTokenType tt);
    1: 
    1: static JSBool
    1: BindDestructuringArg(JSContext *cx, BindData *data, JSAtom *atom,
    1:                      JSTreeContext *tc)
    1: {
    1:     JSAtomListElement *ale;
    1:     const char *name;
    1: 
 8444:     JS_ASSERT(tc->flags & TCF_IN_FUNCTION);
    1:     ATOM_LIST_SEARCH(ale, &tc->decls, atom);
    1:     if (!ale) {
    1:         ale = js_IndexAtom(cx, atom, &tc->decls);
    1:         if (!ale)
    1:             return JS_FALSE;
    1:         ALE_SET_JSOP(ale, data->op);
    1:     }
    1: 
18955:     if (js_LookupLocal(cx, tc->u.fun, atom, NULL) != JSLOCAL_NONE) {
    1:         name = js_AtomToPrintableString(cx, atom);
    1:         if (!name ||
 7984:             !js_ReportCompileErrorNumber(cx, TS(tc->parseContext), data->pn,
 7984:                                          JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                          JSMSG_DUPLICATE_FORMAL,
    1:                                          name)) {
    1:             return JS_FALSE;
    1:         }
    1:     } else {
18955:         if (!BindLocalVariable(cx, tc->u.fun, atom, JSLOCAL_VAR))
    1:             return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
 8444: static JSFunction *
 8444: NewCompilerFunction(JSContext *cx, JSTreeContext *tc, JSAtom *atom,
 9481:                     uintN lambda)
 8444: {
 8444:     JSObject *parent;
13702:     JSFunction *fun;
 9481: 
 9481:     JS_ASSERT((lambda & ~JSFUN_LAMBDA) == 0);
18955:     parent = (tc->flags & TCF_IN_FUNCTION)
18955:              ? FUN_OBJECT(tc->u.fun)
18955:              : tc->u.scopeChain;
13702:     fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED | lambda,
13702:                          parent, atom);
13691:     if (fun && !(tc->flags & TCF_COMPILE_N_GO)) {
16069:         STOBJ_CLEAR_PARENT(FUN_OBJECT(fun));
16069:         STOBJ_CLEAR_PROTO(FUN_OBJECT(fun));
13691:     }
13691:     return fun;
 8444: }
 8444: 
    1: static JSParseNode *
    1: FunctionDef(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
 9481:             uintN lambda)
    1: {
    1:     JSOp op, prevop;
    1:     JSParseNode *pn, *body, *result;
    1:     JSTokenType tt;
 3235:     JSAtom *funAtom;
 3235:     JSParsedObjectBox *funpob;
    1:     JSAtomListElement *ale;
    1:     JSFunction *fun;
    1:     JSTreeContext funtc;
    1: #if JS_HAS_DESTRUCTURING
    1:     JSParseNode *item, *list = NULL;
    1: #endif
    1: 
    1:     /* Make a TOK_FUNCTION node. */
    1: #if JS_HAS_GETTER_SETTER
    1:     op = CURRENT_TOKEN(ts).t_op;
    1: #endif
    1:     pn = NewParseNode(cx, ts, PN_FUNC, tc);
    1:     if (!pn)
    1:         return NULL;
10466: #ifdef DEBUG
10466:     pn->pn_index = (uint32) -1;
10466: #endif
    1: 
    1:     /* Scan the optional function name into funAtom. */
    1:     ts->flags |= TSF_KEYWORD_IS_NAME;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:     if (tt == TOK_NAME) {
    1:         funAtom = CURRENT_TOKEN(ts).t_atom;
    1:     } else {
 9481:         if (lambda == 0 && (cx->options & JSOPTION_ANONFUNFIX)) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
  399:                                         JSMSG_SYNTAX_ERROR);
  399:             return NULL;
  399:         }
    1:         funAtom = NULL;
    1:         js_UngetToken(ts);
    1:     }
    1: 
    1:     /*
    1:      * Record names for function statements in tc->decls so we know when to
    1:      * avoid optimizing variable references that might name a function.
    1:      */
 9481:     if (lambda == 0 && funAtom) {
    1:         ATOM_LIST_SEARCH(ale, &tc->decls, funAtom);
    1:         if (ale) {
    1:             prevop = ALE_JSOP(ale);
    1:             if (JS_HAS_STRICT_OPTION(cx) || prevop == JSOP_DEFCONST) {
    1:                 const char *name = js_AtomToPrintableString(cx, funAtom);
    1:                 if (!name ||
 7984:                     !js_ReportCompileErrorNumber(cx, ts, NULL,
    1:                                                  (prevop != JSOP_DEFCONST)
 7984:                                                  ? JSREPORT_WARNING |
    1:                                                    JSREPORT_STRICT
 7984:                                                  : JSREPORT_ERROR,
    1:                                                  JSMSG_REDECLARED_VAR,
18965:                                                  (prevop == JSOP_DEFFUN)
    1:                                                  ? js_function_str
    1:                                                  : (prevop == JSOP_DEFCONST)
    1:                                                  ? js_const_str
    1:                                                  : js_var_str,
    1:                                                  name)) {
    1:                     return NULL;
    1:                 }
    1:             }
    1:             if (!AT_TOP_LEVEL(tc) && prevop == JSOP_DEFVAR)
    1:                 tc->flags |= TCF_FUN_CLOSURE_VS_VAR;
    1:         } else {
    1:             ale = js_IndexAtom(cx, funAtom, &tc->decls);
    1:             if (!ale)
    1:                 return NULL;
    1:         }
18965:         ALE_SET_JSOP(ale, JSOP_DEFFUN);
    1: 
    1:         /*
    1:          * A function nested at top level inside another's body needs only a
    1:          * local variable to bind its name to its value, and not an activation
    1:          * object property (it might also need the activation property, if the
    1:          * outer function contains with statements, e.g., but the stack slot
    1:          * wins when jsemit.c's BindNameToSlot can optimize a JSOP_NAME into a
16429:          * JSOP_GETLOCAL bytecode).
    1:          */
    1:         if (AT_TOP_LEVEL(tc) && (tc->flags & TCF_IN_FUNCTION)) {
 8179:             JSLocalKind localKind;
    1: 
    1:             /*
    1:              * Define a property on the outer function so that BindNameToSlot
 8179:              * can properly optimize accesses. Note that we need a variable,
 8179:              * not an argument, for the function statement. Thus we add a
 8179:              * variable even if the parameter with the given name already
 8179:              * exists.
    1:              */
18955:             localKind = js_LookupLocal(cx, tc->u.fun, funAtom, NULL);
 8179:             if (localKind == JSLOCAL_NONE || localKind == JSLOCAL_ARG) {
18955:                 if (!js_AddLocal(cx, tc->u.fun, funAtom, JSLOCAL_VAR))
13691:                     return NULL;
13691:             }
13691:         }
13691:     }
13691: 
13691:     fun = NewCompilerFunction(cx, tc, funAtom, lambda);
    1:     if (!fun)
    1:         return NULL;
 8179: 
    1: #if JS_HAS_GETTER_SETTER
    1:     if (op != JSOP_NOP)
    1:         fun->flags |= (op == JSOP_GETTER) ? JSPROP_GETTER : JSPROP_SETTER;
    1: #endif
    1: 
    1:     /*
 3235:      * Create wrapping box for fun->object early to protect against a
 8179:      * last-ditch GC.
    1:      */
13824:     funpob = js_NewParsedObjectBox(cx, tc->parseContext, FUN_OBJECT(fun));
 3235:     if (!funpob)
    1:         return NULL;
    1: 
    1:     /* Initialize early for possible flags mutation via DestructuringExpr. */
 3235:     TREE_CONTEXT_INIT(&funtc, tc->parseContext);
17755:     funtc.flags |= TCF_IN_FUNCTION | (tc->flags & TCF_COMPILE_N_GO);
18955:     funtc.u.fun = fun;
    1: 
    1:     /* Now parse formal argument list and compute fun->nargs. */
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_FORMAL);
    1:     if (!js_MatchToken(cx, ts, TOK_RP)) {
    1:         do {
    1:             tt = js_GetToken(cx, ts);
    1:             switch (tt) {
    1: #if JS_HAS_DESTRUCTURING
    1:               case TOK_LB:
    1:               case TOK_LC:
    1:               {
 8444:                 BindData data;
    1:                 JSParseNode *lhs, *rhs;
    1:                 jsint slot;
    1: 
    1:                 /*
    1:                  * A destructuring formal parameter turns into one or more
    1:                  * local variables initialized from properties of a single
    1:                  * anonymous positional parameter, so here we must tweak our
    1:                  * binder and its data.
    1:                  */
 8444:                 data.pn = NULL;
    1:                 data.op = JSOP_DEFVAR;
    1:                 data.binder = BindDestructuringArg;
    1:                 lhs = DestructuringExpr(cx, &data, &funtc, tt);
    1:                 if (!lhs)
    1:                     return NULL;
    1: 
    1:                 /*
    1:                  * Adjust fun->nargs to count the single anonymous positional
    1:                  * parameter that is to be destructured.
    1:                  */
    1:                 slot = fun->nargs;
13691:                 if (!js_AddLocal(cx, fun, NULL, JSLOCAL_ARG))
    1:                     return NULL;
    1: 
    1:                 /*
    1:                  * Synthesize a destructuring assignment from the single
    1:                  * anonymous positional parameter into the destructuring
    1:                  * left-hand-side expression and accumulate it in list.
    1:                  */
    1:                 rhs = NewParseNode(cx, ts, PN_NAME, tc);
    1:                 if (!rhs)
    1:                     return NULL;
    1:                 rhs->pn_type = TOK_NAME;
    1:                 rhs->pn_op = JSOP_GETARG;
    1:                 rhs->pn_atom = cx->runtime->atomState.emptyAtom;
    1:                 rhs->pn_slot = slot;
    1: 
    1:                 item = NewBinary(cx, TOK_ASSIGN, JSOP_NOP, lhs, rhs, tc);
    1:                 if (!item)
    1:                     return NULL;
    1:                 if (!list) {
    1:                     list = NewParseNode(cx, ts, PN_LIST, tc);
    1:                     if (!list)
    1:                         return NULL;
    1:                     list->pn_type = TOK_COMMA;
    1:                     PN_INIT_LIST(list);
    1:                 }
    1:                 PN_APPEND(list, item);
    1:                 break;
    1:               }
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
    1:               case TOK_NAME:
 8444:                 if (!BindArg(cx, CURRENT_TOKEN(ts).t_atom, &funtc))
    1:                     return NULL;
    1:                 break;
    1: 
    1:               default:
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_MISSING_FORMAL);
    1:                 return NULL;
    1:             }
    1:         } while (js_MatchToken(cx, ts, TOK_COMMA));
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FORMAL);
    1:     }
    1: 
 1967: #if JS_HAS_EXPR_CLOSURES
 1967:     ts->flags |= TSF_OPERAND;
 1967:     tt = js_GetToken(cx, ts);
 1967:     ts->flags &= ~TSF_OPERAND;
 1967:     if (tt != TOK_LC) {
 1967:         js_UngetToken(ts);
 1967:         fun->flags |= JSFUN_EXPR_CLOSURE;
 1967:     }
 1967: #else
    1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_BODY);
 1967: #endif
    1:     pn->pn_pos.begin = CURRENT_TOKEN(ts).pos.begin;
    1: 
 8444:     body = FunctionBody(cx, ts, &funtc);
    1:     if (!body)
    1:         return NULL;
    1: 
 1967: #if JS_HAS_EXPR_CLOSURES
 1967:     if (tt == TOK_LC)
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
 9481:     else if (lambda == 0)
 1967:         js_MatchToken(cx, ts, TOK_SEMI);
 1967: #else
 1967:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
 1967: #endif
    1:     pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:     /*
    1:      * If there were destructuring formal parameters, prepend the initializing
    1:      * comma expression that we synthesized to body.  If the body is a lexical
20413:      * scope node, we must make a special TOK_SEQ node, to prepend the formal
    1:      * parameter destructuring code without bracing the decompilation of the
    1:      * function body's lexical scope.
    1:      */
    1:     if (list) {
    1:         if (body->pn_arity != PN_LIST) {
    1:             JSParseNode *block;
    1: 
    1:             block = NewParseNode(cx, ts, PN_LIST, tc);
    1:             if (!block)
    1:                 return NULL;
20413:             block->pn_type = TOK_SEQ;
    1:             block->pn_pos = body->pn_pos;
    1:             PN_INIT_LIST_1(block, body);
    1: 
    1:             body = block;
    1:         }
    1: 
    1:         item = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!item)
    1:             return NULL;
    1: 
    1:         item->pn_type = TOK_SEMI;
    1:         item->pn_pos.begin = item->pn_pos.end = body->pn_pos.begin;
    1:         item->pn_kid = list;
    1:         item->pn_next = body->pn_head;
    1:         body->pn_head = item;
    1:         if (body->pn_tail == &body->pn_head)
    1:             body->pn_tail = &item->pn_next;
    1:         ++body->pn_count;
    1:     }
    1: #endif
    1: 
    1:     /*
    1:      * If we collected flags that indicate nested heavyweight functions, or
    1:      * this function contains heavyweight-making statements (references to
16489:      * __parent__ or __proto__; use of with, or eval; and assignment to 
16489:      * arguments), flag the function as heavyweight (requiring a call object 
16489:      * per invocation).
    1:      */
    1:     if (funtc.flags & TCF_FUN_HEAVYWEIGHT) {
    1:         fun->flags |= JSFUN_HEAVYWEIGHT;
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:     } else {
    1:         /*
    1:          * If this function is a named statement function not at top-level
18965:          * (i.e. not a top-level function definiton or expression), then
    1:          * our enclosing function, if any, must be heavyweight.
    1:          *
    1:          * The TCF_FUN_USES_NONLOCALS flag is set only by the code generator,
    1:          * so it won't be set here.  Assert that it's not.  We have to check
 9786:          * it later, in js_EmitTree, after js_EmitFunctionScript has traversed
 9786:          * the function's body.
    1:          */
    1:         JS_ASSERT(!(funtc.flags & TCF_FUN_USES_NONLOCALS));
 9481:         if (lambda == 0 && funAtom && !AT_TOP_LEVEL(tc))
    1:             tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:     }
    1: 
    1:     result = pn;
 9481:     if (lambda != 0) {
    1:         /*
    1:          * ECMA ed. 3 standard: function expression, possibly anonymous.
    1:          */
    1:         op = funAtom ? JSOP_NAMEDFUNOBJ : JSOP_ANONFUNOBJ;
    1:     } else if (!funAtom) {
    1:         /*
    1:          * If this anonymous function definition is *not* embedded within a
    1:          * larger expression, we treat it as an expression statement, not as
    1:          * a function declaration -- and not as a syntax error (as ECMA-262
 1967:          * Edition 3 would have it).  Backward compatibility must trump all,
 1967:          * unless JSOPTION_ANONFUNFIX is set.
    1:          */
    1:         result = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!result)
    1:             return NULL;
    1:         result->pn_type = TOK_SEMI;
    1:         result->pn_pos = pn->pn_pos;
    1:         result->pn_kid = pn;
    1:         op = JSOP_ANONFUNOBJ;
    1:     } else if (!AT_TOP_LEVEL(tc)) {
    1:         /*
    1:          * ECMA ed. 3 extension: a function expression statement not at the
    1:          * top level, e.g., in a compound statement such as the "then" part
    1:          * of an "if" statement, binds a closure only if control reaches that
    1:          * sub-statement.
    1:          */
18965:         op = JSOP_DEFFUN;
    1:     } else {
    1:         op = JSOP_NOP;
    1:     }
    1: 
 3235:     pn->pn_funpob = funpob;
    1:     pn->pn_op = op;
    1:     pn->pn_body = body;
17755:     pn->pn_flags = funtc.flags & (TCF_FUN_FLAGS | TCF_HAS_DEFXMLNS | TCF_COMPILE_N_GO);
16072:     TREE_CONTEXT_FINISH(cx, &funtc);
    1:     return result;
    1: }
    1: 
    1: static JSParseNode *
    1: FunctionStmt(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
 9481:     return FunctionDef(cx, ts, tc, 0);
    1: }
    1: 
    1: static JSParseNode *
    1: FunctionExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
 9481:     return FunctionDef(cx, ts, tc, JSFUN_LAMBDA);
    1: }
    1: 
    1: /*
    1:  * Parse the statements in a block, creating a TOK_LC node that lists the
    1:  * statements' trees.  If called from block-parsing code, the caller must
    1:  * match { before and } after.
    1:  */
    1: static JSParseNode *
    1: Statements(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2, *saveBlock;
    1:     JSTokenType tt;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     pn = NewParseNode(cx, ts, PN_LIST, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     saveBlock = tc->blockNode;
    1:     tc->blockNode = pn;
    1:     PN_INIT_LIST(pn);
    1: 
 9604:     for (;;) {
    1:         ts->flags |= TSF_OPERAND;
 9604:         tt = js_PeekToken(cx, ts);
    1:         ts->flags &= ~TSF_OPERAND;
10466:         if (tt <= TOK_EOF || tt == TOK_RC) {
10466:             if (tt == TOK_ERROR)
10466:                 return NULL;
 9604:             break;
10466:         }
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2) {
    1:             if (ts->flags & TSF_EOF)
    1:                 ts->flags |= TSF_UNEXPECTED_EOF;
    1:             return NULL;
    1:         }
    1: 
10466:         if (pn2->pn_type == TOK_FUNCTION) {
10466:             /*
10466:              * PNX_FUNCDEFS notifies the emitter that the block contains top-
10466:              * level function definitions that should be processed before the
10466:              * rest of nodes.
10466:              *
10466:              * TCF_HAS_FUNCTION_STMT is for the TOK_LC case in Statement. It
10466:              * is relevant only for function definitions not at top-level,
10466:              * which we call function statements.
10466:              */
10466:             if (AT_TOP_LEVEL(tc))
10466:                 pn->pn_extra |= PNX_FUNCDEFS;
10466:             else
    1:                 tc->flags |= TCF_HAS_FUNCTION_STMT;
10466:         }
    1:         PN_APPEND(pn, pn2);
    1:     }
    1: 
    1:     /*
    1:      * Handle the case where there was a let declaration under this block.  If
    1:      * it replaced tc->blockNode with a new block node then we must refresh pn
    1:      * and then restore tc->blockNode.
    1:      */
    1:     if (tc->blockNode != pn)
    1:         pn = tc->blockNode;
    1:     tc->blockNode = saveBlock;
    1: 
    1:     pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: Condition(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_COND);
 1577:     pn = ParenExpr(cx, ts, tc, NULL, NULL);
    1:     if (!pn)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_COND);
    1: 
    1:     /*
    1:      * Check for (a = b) and warn about possible (a == b) mistype iff b's
    1:      * operator has greater precedence than ==.
    1:      */
    1:     if (pn->pn_type == TOK_ASSIGN &&
    1:         pn->pn_op == JSOP_NOP &&
    1:         pn->pn_right->pn_type > TOK_EQOP)
    1:     {
 7984:         if (!js_ReportCompileErrorNumber(cx, ts, NULL,
 7984:                                          JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                          JSMSG_EQUAL_AS_ASSIGN,
    1:                                          "")) {
    1:             return NULL;
    1:         }
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSBool
    1: MatchLabel(JSContext *cx, JSTokenStream *ts, JSParseNode *pn)
    1: {
    1:     JSAtom *label;
    1:     JSTokenType tt;
    1: 
    1:     tt = js_PeekTokenSameLine(cx, ts);
    1:     if (tt == TOK_ERROR)
    1:         return JS_FALSE;
    1:     if (tt == TOK_NAME) {
    1:         (void) js_GetToken(cx, ts);
    1:         label = CURRENT_TOKEN(ts).t_atom;
    1:     } else {
    1:         label = NULL;
    1:     }
    1:     pn->pn_atom = label;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: BindLet(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc)
    1: {
    1:     JSObject *blockObj;
    1:     JSScopeProperty *sprop;
    1:     JSAtomListElement *ale;
14688:     uintN n;
    1: 
 8444:     blockObj = tc->blockChain;
    1:     sprop = SCOPE_GET_PROPERTY(OBJ_SCOPE(blockObj), ATOM_TO_JSID(atom));
    1:     ATOM_LIST_SEARCH(ale, &tc->decls, atom);
    1:     if (sprop || (ale && ALE_JSOP(ale) == JSOP_DEFCONST)) {
    1:         const char *name;
    1: 
    1:         if (sprop) {
    1:             JS_ASSERT(sprop->flags & SPROP_HAS_SHORTID);
14688:             JS_ASSERT((uint16)sprop->shortid < OBJ_BLOCK_COUNT(cx, blockObj));
    1:         }
    1: 
    1:         name = js_AtomToPrintableString(cx, atom);
    1:         if (name) {
 7984:             js_ReportCompileErrorNumber(cx, TS(tc->parseContext), data->pn,
 7984:                                         JSREPORT_ERROR, JSMSG_REDECLARED_VAR,
    1:                                         (ale && ALE_JSOP(ale) == JSOP_DEFCONST)
    1:                                         ? js_const_str
    1:                                         : "variable",
    1:                                         name);
    1:         }
    1:         return JS_FALSE;
    1:     }
    1: 
14688:     n = OBJ_BLOCK_COUNT(cx, blockObj);
14688:     if (n == JS_BIT(16)) {
 7984:         js_ReportCompileErrorNumber(cx, TS(tc->parseContext), data->pn,
 7984:                                     JSREPORT_ERROR, data->u.let.overflow);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Use JSPROP_ENUMERATE to aid the disassembler. */
    1:     return js_DefineNativeProperty(cx, blockObj, ATOM_TO_JSID(atom),
    1:                                    JSVAL_VOID, NULL, NULL,
14860:                                    JSPROP_ENUMERATE |
14860:                                    JSPROP_PERMANENT |
14860:                                    JSPROP_SHARED,
14688:                                    SPROP_HAS_SHORTID, (int16) n, NULL);
    1: }
    1: 
    1: static JSBool
    1: BindVarOrConst(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc)
    1: {
    1:     JSStmtInfo *stmt;
    1:     JSAtomListElement *ale;
    1:     JSOp op, prevop;
    1:     const char *name;
 8179:     JSLocalKind localKind;
    1: 
16378:     stmt = js_LexicalLookup(tc, atom, NULL);
    1:     ATOM_LIST_SEARCH(ale, &tc->decls, atom);
    1:     op = data->op;
    1:     if ((stmt && stmt->type != STMT_WITH) || ale) {
    1:         prevop = ale ? ALE_JSOP(ale) : JSOP_DEFVAR;
    1:         if (JS_HAS_STRICT_OPTION(cx)
    1:             ? op != JSOP_DEFVAR || prevop != JSOP_DEFVAR
    1:             : op == JSOP_DEFCONST || prevop == JSOP_DEFCONST) {
    1:             name = js_AtomToPrintableString(cx, atom);
    1:             if (!name ||
 7984:                 !js_ReportCompileErrorNumber(cx, TS(tc->parseContext), data->pn,
    1:                                              (op != JSOP_DEFCONST &&
    1:                                               prevop != JSOP_DEFCONST)
    1:                                              ? JSREPORT_WARNING |
    1:                                                JSREPORT_STRICT
 7984:                                              : JSREPORT_ERROR,
    1:                                              JSMSG_REDECLARED_VAR,
18965:                                              (prevop == JSOP_DEFFUN)
    1:                                              ? js_function_str
    1:                                              : (prevop == JSOP_DEFCONST)
    1:                                              ? js_const_str
    1:                                              : js_var_str,
    1:                                              name)) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
18965:         if (op == JSOP_DEFVAR && prevop == JSOP_DEFFUN)
    1:             tc->flags |= TCF_FUN_CLOSURE_VS_VAR;
    1:     }
    1:     if (!ale) {
    1:         ale = js_IndexAtom(cx, atom, &tc->decls);
    1:         if (!ale)
    1:             return JS_FALSE;
    1:     }
    1:     ALE_SET_JSOP(ale, op);
    1: 
 8444:     if (!(tc->flags & TCF_IN_FUNCTION)) {
    1:         /*
 8179:          * Don't lookup global variables or variables in an active frame at
 8179:          * compile time.
    1:          */
 8179:         return JS_TRUE;
 8179:     }
 8179: 
18955:     localKind = js_LookupLocal(cx, tc->u.fun, atom, NULL);
 8179:     if (localKind == JSLOCAL_NONE) {
    1:         /*
    1:          * Property not found in current variable scope: we have not seen this
    1:          * variable before.  Define a new local variable by adding a property
    1:          * to the function's scope, allocating one slot in the function's vars
 8444:          * frame. Any locals declared in with statement bodies are handled at
 8444:          * runtime, by script prolog JSOP_DEFVAR opcodes generated for
 8444:          * slot-less vars.
    1:          */
 8444:         localKind = (data->op == JSOP_DEFCONST) ? JSLOCAL_CONST : JSLOCAL_VAR;
 8444:         if (!js_InWithStatement(tc) &&
18955:             !BindLocalVariable(cx, tc->u.fun, atom, localKind)) {
    1:             return JS_FALSE;
    1:         }
 8179:     } else if (localKind == JSLOCAL_ARG) {
 8179:         name = js_AtomToPrintableString(cx, atom);
 8179:         if (!name)
 8179:             return JS_FALSE;
 8179: 
 8179:         if (op == JSOP_DEFCONST) {
 8179:             js_ReportCompileErrorNumber(cx, TS(tc->parseContext), data->pn,
 8179:                                         JSREPORT_ERROR, JSMSG_REDECLARED_PARAM,
 8179:                                         name);
 8179:             return JS_FALSE;
 8179:         }
 8179:         if (!js_ReportCompileErrorNumber(cx, TS(tc->parseContext), data->pn,
 8179:                                          JSREPORT_WARNING | JSREPORT_STRICT,
 8179:                                          JSMSG_VAR_HIDES_ARG, name)) {
 8179:             return JS_FALSE;
 8179:         }
 8179:     } else {
 8179:         /* Not an argument, must be a redeclared local var. */
 8179:         JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
 8179:     }
 8179:     return JS_TRUE;
    1: }
    1: 
20908: static JSBool
20908: MakeSetCall(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, uintN msg)
20908: {
20908:     JSParseNode *pn2;
20908: 
20908:     JS_ASSERT(pn->pn_arity == PN_LIST);
21460:     JS_ASSERT(pn->pn_op == JSOP_CALL || pn->pn_op == JSOP_EVAL || pn->pn_op == JSOP_APPLY);
20908:     pn2 = pn->pn_head;
20908:     if (pn2->pn_type == TOK_FUNCTION && (pn2->pn_flags & TCF_GENEXP_LAMBDA)) {
20908:         js_ReportCompileErrorNumber(cx, TS(tc->parseContext), pn,
20908:                                     JSREPORT_ERROR, msg);
20908:         return JS_FALSE;
20908:     }
20908:     pn->pn_op = JSOP_SETCALL;
20908:     return JS_TRUE;
20908: }
20908: 
    1: #if JS_HAS_DESTRUCTURING
    1: 
    1: static JSBool
    1: BindDestructuringVar(JSContext *cx, BindData *data, JSParseNode *pn,
    1:                      JSTreeContext *tc)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     /*
    1:      * Destructuring is a form of assignment, so just as for an initialized
    1:      * simple variable, we must check for assignment to 'arguments' and flag
    1:      * the enclosing function (if any) as heavyweight.
    1:      */
    1:     JS_ASSERT(pn->pn_type == TOK_NAME);
    1:     atom = pn->pn_atom;
    1:     if (atom == cx->runtime->atomState.argumentsAtom)
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1: 
    1:     data->pn = pn;
    1:     if (!data->binder(cx, data, atom, tc))
    1:         return JS_FALSE;
    1:     data->pn = NULL;
    1: 
    1:     /*
    1:      * Select the appropriate name-setting opcode, which may be specialized
    1:      * further for local variable and argument slot optimizations.  At this
    1:      * point, we can't select the optimal final opcode, yet we must preserve
    1:      * the CONST bit and convey "set", not "get".
    1:      */
 8444:     if (data->op == JSOP_DEFCONST) {
 8444:         pn->pn_op = JSOP_SETCONST;
 8444:         pn->pn_const = JS_TRUE;
 8444:     } else {
 8444:         pn->pn_op = JSOP_SETNAME;
 8444:         pn->pn_const = JS_FALSE;
 8444:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Here, we are destructuring {... P: Q, ...} = R, where P is any id, Q is any
    1:  * LHS expression except a destructuring initialiser, and R is on the stack.
    1:  * Because R is already evaluated, the usual LHS-specialized bytecodes won't
    1:  * work.  After pushing R[P] we need to evaluate Q's "reference base" QB and
    1:  * then push its property name QN.  At this point the stack looks like
    1:  *
    1:  *   [... R, R[P], QB, QN]
    1:  *
    1:  * We need to set QB[QN] = R[P].  This is a job for JSOP_ENUMELEM, which takes
    1:  * its operands with left-hand side above right-hand side:
    1:  *
    1:  *   [rval, lval, xval]
    1:  *
    1:  * and pops all three values, setting lval[xval] = rval.  But we cannot select
    1:  * JSOP_ENUMELEM yet, because the LHS may turn out to be an arg or local var,
    1:  * which can be optimized further.  So we select JSOP_SETNAME.
    1:  */
    1: static JSBool
    1: BindDestructuringLHS(JSContext *cx, JSParseNode *pn, JSTreeContext *tc)
    1: {
    1:     while (pn->pn_type == TOK_RP)
    1:         pn = pn->pn_kid;
    1: 
    1:     switch (pn->pn_type) {
    1:       case TOK_NAME:
    1:         if (pn->pn_atom == cx->runtime->atomState.argumentsAtom)
    1:             tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:         /* FALL THROUGH */
    1:       case TOK_DOT:
    1:       case TOK_LB:
    1:         pn->pn_op = JSOP_SETNAME;
    1:         break;
    1: 
    1: #if JS_HAS_LVALUE_RETURN
    1:       case TOK_LP:
 7984:         if (!MakeSetCall(cx, pn, tc, JSMSG_BAD_LEFTSIDE_OF_ASS))
 1577:             return JS_FALSE;
    1:         break;
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_UNARYOP:
    1:         if (pn->pn_op == JSOP_XMLNAME) {
    1:             pn->pn_op = JSOP_BINDXMLNAME;
    1:             break;
    1:         }
    1:         /* FALL THROUGH */
    1: #endif
    1: 
    1:       default:
 7984:         js_ReportCompileErrorNumber(cx, TS(tc->parseContext), pn,
 7984:                                     JSREPORT_ERROR, JSMSG_BAD_LEFTSIDE_OF_ASS);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: typedef struct FindPropValData {
    1:     uint32          numvars;    /* # of destructuring vars in left side */
    1:     uint32          maxstep;    /* max # of steps searching right side */
    1:     JSDHashTable    table;      /* hash table for O(1) right side search */
    1: } FindPropValData;
    1: 
    1: typedef struct FindPropValEntry {
    1:     JSDHashEntryHdr hdr;
    1:     JSParseNode     *pnkey;
    1:     JSParseNode     *pnval;
    1: } FindPropValEntry;
    1: 
    1: #define ASSERT_VALID_PROPERTY_KEY(pnkey)                                      \
    1:     JS_ASSERT((pnkey)->pn_arity == PN_NULLARY &&                              \
    1:               ((pnkey)->pn_type == TOK_NUMBER ||                              \
    1:                (pnkey)->pn_type == TOK_STRING ||                              \
    1:                (pnkey)->pn_type == TOK_NAME))
    1: 
18907: static JSDHashNumber
    1: HashFindPropValKey(JSDHashTable *table, const void *key)
    1: {
    1:     const JSParseNode *pnkey = (const JSParseNode *)key;
    1: 
    1:     ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:     return (pnkey->pn_type == TOK_NUMBER)
    1:            ? (JSDHashNumber) (JSDOUBLE_HI32(pnkey->pn_dval) ^
    1:                               JSDOUBLE_LO32(pnkey->pn_dval))
 3328:            : ATOM_HASH(pnkey->pn_atom);
    1: }
    1: 
18907: static JSBool
    1: MatchFindPropValEntry(JSDHashTable *table,
    1:                       const JSDHashEntryHdr *entry,
    1:                       const void *key)
    1: {
    1:     const FindPropValEntry *fpve = (const FindPropValEntry *)entry;
    1:     const JSParseNode *pnkey = (const JSParseNode *)key;
    1: 
    1:     ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:     return pnkey->pn_type == fpve->pnkey->pn_type &&
    1:            ((pnkey->pn_type == TOK_NUMBER)
    1:             ? pnkey->pn_dval == fpve->pnkey->pn_dval
    1:             : pnkey->pn_atom == fpve->pnkey->pn_atom);
    1: }
    1: 
    1: static const JSDHashTableOps FindPropValOps = {
    1:     JS_DHashAllocTable,
    1:     JS_DHashFreeTable,
    1:     HashFindPropValKey,
    1:     MatchFindPropValEntry,
    1:     JS_DHashMoveEntryStub,
    1:     JS_DHashClearEntryStub,
    1:     JS_DHashFinalizeStub,
    1:     NULL
    1: };
    1: 
    1: #define STEP_HASH_THRESHOLD     10
    1: #define BIG_DESTRUCTURING        5
    1: #define BIG_OBJECT_INIT         20
    1: 
    1: static JSParseNode *
    1: FindPropertyValue(JSParseNode *pn, JSParseNode *pnid, FindPropValData *data)
    1: {
    1:     FindPropValEntry *entry;
  991:     JSParseNode *pnhit, *pnhead, *pnprop, *pnkey;
    1:     uint32 step;
    1: 
    1:     /* If we have a hash table, use it as the sole source of truth. */
    1:     if (data->table.ops) {
    1:         entry = (FindPropValEntry *)
    1:                 JS_DHashTableOperate(&data->table, pnid, JS_DHASH_LOOKUP);
    1:         return JS_DHASH_ENTRY_IS_BUSY(&entry->hdr) ? entry->pnval : NULL;
    1:     }
    1: 
    1:     /* If pn is not an object initialiser node, we can't do anything here. */
    1:     if (pn->pn_type != TOK_RC)
    1:         return NULL;
    1: 
    1:     /*
    1:      * We must search all the way through pn's list, to handle the case of an
    1:      * id duplicated for two or more property initialisers.
    1:      */
    1:     pnhit = NULL;
    1:     step = 0;
    1:     ASSERT_VALID_PROPERTY_KEY(pnid);
  991:     pnhead = pn->pn_head;
  994:     if (pnhead && pnhead->pn_type == TOK_DEFSHARP)
  991:         pnhead = pnhead->pn_next;
    1:     if (pnid->pn_type == TOK_NUMBER) {
  991:         for (pnprop = pnhead; pnprop; pnprop = pnprop->pn_next) {
    1:             JS_ASSERT(pnprop->pn_type == TOK_COLON);
    1:             if (pnprop->pn_op == JSOP_NOP) {
    1:                 pnkey = pnprop->pn_left;
    1:                 ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:                 if (pnkey->pn_type == TOK_NUMBER &&
    1:                     pnkey->pn_dval == pnid->pn_dval) {
    1:                     pnhit = pnprop;
    1:                 }
    1:                 ++step;
    1:             }
    1:         }
    1:     } else {
  991:         for (pnprop = pnhead; pnprop; pnprop = pnprop->pn_next) {
    1:             JS_ASSERT(pnprop->pn_type == TOK_COLON);
    1:             if (pnprop->pn_op == JSOP_NOP) {
    1:                 pnkey = pnprop->pn_left;
    1:                 ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:                 if (pnkey->pn_type == pnid->pn_type &&
    1:                     pnkey->pn_atom == pnid->pn_atom) {
    1:                     pnhit = pnprop;
    1:                 }
    1:                 ++step;
    1:             }
    1:         }
    1:     }
    1:     if (!pnhit)
    1:         return NULL;
    1: 
    1:     /* Hit via full search -- see whether it's time to create the hash table. */
    1:     JS_ASSERT(!data->table.ops);
    1:     if (step > data->maxstep) {
    1:         data->maxstep = step;
    1:         if (step >= STEP_HASH_THRESHOLD &&
    1:             data->numvars >= BIG_DESTRUCTURING &&
    1:             pn->pn_count >= BIG_OBJECT_INIT &&
    1:             JS_DHashTableInit(&data->table, &FindPropValOps, pn,
    1:                               sizeof(FindPropValEntry),
    1:                               JS_DHASH_DEFAULT_CAPACITY(pn->pn_count)))
    1:         {
  991:             for (pn = pnhead; pn; pn = pn->pn_next) {
  991:                 JS_ASSERT(pnprop->pn_type == TOK_COLON);
    1:                 ASSERT_VALID_PROPERTY_KEY(pn->pn_left);
    1:                 entry = (FindPropValEntry *)
    1:                         JS_DHashTableOperate(&data->table, pn->pn_left,
    1:                                              JS_DHASH_ADD);
    1:                 entry->pnval = pn->pn_right;
    1:             }
    1:         }
    1:     }
    1:     return pnhit->pn_right;
    1: }
    1: 
    1: /*
    1:  * If data is null, the caller is AssignExpr and instead of binding variables,
    1:  * we specialize lvalues in the propery value positions of the left-hand side.
    1:  * If right is null, just check for well-formed lvalues.
    1:  */
    1: static JSBool
    1: CheckDestructuring(JSContext *cx, BindData *data,
    1:                    JSParseNode *left, JSParseNode *right,
    1:                    JSTreeContext *tc)
    1: {
    1:     JSBool ok;
    1:     FindPropValData fpvd;
    1:     JSParseNode *lhs, *rhs, *pn, *pn2;
    1: 
    1:     if (left->pn_type == TOK_ARRAYCOMP) {
 7984:         js_ReportCompileErrorNumber(cx, TS(tc->parseContext), left,
 7984:                                     JSREPORT_ERROR, JSMSG_ARRAY_COMP_LEFTSIDE);
    1:         return JS_FALSE;
    1:     }
    1: 
18473: #if JS_HAS_DESTRUCTURING_SHORTHAND
18996:     if (right && right->pn_arity == PN_LIST && (right->pn_extra & PNX_SHORTHAND)) {
18473:         js_ReportCompileErrorNumber(cx, TS(tc->parseContext), right,
18473:                                     JSREPORT_ERROR, JSMSG_BAD_OBJECT_INIT);
18473:         return JS_FALSE;
18473:     }
18473: #endif
18473: 
    1:     fpvd.table.ops = NULL;
    1:     lhs = left->pn_head;
    1:     if (lhs && lhs->pn_type == TOK_DEFSHARP) {
    1:         pn = lhs;
    1:         goto no_var_name;
    1:     }
    1: 
    1:     if (left->pn_type == TOK_RB) {
    1:         rhs = (right && right->pn_type == left->pn_type)
    1:               ? right->pn_head
    1:               : NULL;
    1: 
    1:         while (lhs) {
    1:             pn = lhs, pn2 = rhs;
    1:             if (!data) {
    1:                 /* Skip parenthesization if not in a variable declaration. */
    1:                 while (pn->pn_type == TOK_RP)
    1:                     pn = pn->pn_kid;
    1:                 if (pn2) {
    1:                     while (pn2->pn_type == TOK_RP)
    1:                         pn2 = pn2->pn_kid;
    1:                 }
    1:             }
    1: 
    1:             /* Nullary comma is an elision; binary comma is an expression.*/
    1:             if (pn->pn_type != TOK_COMMA || pn->pn_arity != PN_NULLARY) {
    1:                 if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC) {
    1:                     ok = CheckDestructuring(cx, data, pn, pn2, tc);
    1:                 } else {
    1:                     if (data) {
    1:                         if (pn->pn_type != TOK_NAME)
    1:                             goto no_var_name;
    1: 
    1:                         ok = BindDestructuringVar(cx, data, pn, tc);
    1:                     } else {
    1:                         ok = BindDestructuringLHS(cx, pn, tc);
    1:                     }
    1:                 }
    1:                 if (!ok)
    1:                     goto out;
    1:             }
    1: 
    1:             lhs = lhs->pn_next;
    1:             if (rhs)
    1:                 rhs = rhs->pn_next;
    1:         }
    1:     } else {
    1:         JS_ASSERT(left->pn_type == TOK_RC);
    1:         fpvd.numvars = left->pn_count;
    1:         fpvd.maxstep = 0;
    1:         rhs = NULL;
    1: 
    1:         while (lhs) {
    1:             JS_ASSERT(lhs->pn_type == TOK_COLON);
    1:             pn = lhs->pn_right;
    1:             if (!data) {
    1:                 /* Skip parenthesization if not in a variable declaration. */
    1:                 while (pn->pn_type == TOK_RP)
    1:                     pn = pn->pn_kid;
    1:             }
    1: 
    1:             if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC) {
    1:                 if (right) {
    1:                     rhs = FindPropertyValue(right, lhs->pn_left, &fpvd);
    1:                     if (rhs && !data) {
    1:                         while (rhs->pn_type == TOK_RP)
    1:                             rhs = rhs->pn_kid;
    1:                     }
    1:                 }
    1: 
    1:                 ok = CheckDestructuring(cx, data, pn, rhs, tc);
    1:             } else if (data) {
    1:                 if (pn->pn_type != TOK_NAME)
    1:                     goto no_var_name;
    1: 
    1:                 ok = BindDestructuringVar(cx, data, pn, tc);
    1:             } else {
    1:                 ok = BindDestructuringLHS(cx, pn, tc);
    1:             }
    1:             if (!ok)
    1:                 goto out;
    1: 
    1:             lhs = lhs->pn_next;
    1:         }
    1:     }
    1: 
14688:     /*
14688:      * The catch/finally handler implementation in the interpreter assumes
14688:      * that any operation that introduces a new scope (like a "let" or "with"
14688:      * block) increases the stack depth. This way, it is possible to restore
14688:      * the scope chain based on stack depth of the handler alone. "let" with
14688:      * an empty destructuring pattern like in
14688:      *
14688:      *   let [] = 1;
14688:      *
14688:      * would violate this assumption as the there would be no let locals to
14688:      * store on the stack. To satisfy it we add an empty property to such
14688:      * blocks so that OBJ_BLOCK_COUNT(cx, blockObj), which gives the number of
14688:      * slots, would be always positive.
14688:      *
14688:      * Note that we add such a property even if the block has locals due to
14688:      * later let declarations in it. We optimize for code simplicity here,
14688:      * not the fastest runtime performance with empty [] or {}.
14688:      */
14688:     if (data &&
14688:         data->binder == BindLet &&
14688:         OBJ_BLOCK_COUNT(cx, tc->blockChain) == 0) {
14688:         ok = js_DefineNativeProperty(cx, tc->blockChain,
14688:                                      ATOM_TO_JSID(cx->runtime->
14688:                                                   atomState.emptyAtom),
14688:                                      JSVAL_VOID, NULL, NULL,
14860:                                      JSPROP_ENUMERATE |
14860:                                      JSPROP_PERMANENT |
14860:                                      JSPROP_SHARED,
14688:                                      SPROP_HAS_SHORTID, 0, NULL);
14688:         if (!ok)
14688:             goto out;
14688:     }
14688: 
14688:     ok = JS_TRUE;
14688: 
    1:   out:
    1:     if (fpvd.table.ops)
    1:         JS_DHashTableFinish(&fpvd.table);
    1:     return ok;
    1: 
    1:   no_var_name:
 7984:     js_ReportCompileErrorNumber(cx, TS(tc->parseContext), pn, JSREPORT_ERROR,
    1:                                 JSMSG_NO_VARIABLE_NAME);
    1:     ok = JS_FALSE;
    1:     goto out;
    1: }
    1: 
    1: static JSParseNode *
    1: DestructuringExpr(JSContext *cx, BindData *data, JSTreeContext *tc,
    1:                   JSTokenType tt)
    1: {
    1:     JSParseNode *pn;
    1: 
 7984:     pn = PrimaryExpr(cx, TS(tc->parseContext), tc, tt, JS_FALSE);
    1:     if (!pn)
    1:         return NULL;
    1:     if (!CheckDestructuring(cx, data, pn, NULL, tc))
    1:         return NULL;
    1:     return pn;
    1: }
    1: 
20413: // Currently used only #if JS_HAS_DESTRUCTURING, in Statement's TOK_FOR case.
20413: static JSParseNode *
20413: CloneParseTree(JSContext *cx, JSParseNode *opn, JSTreeContext *tc)
20413: {
20413:     JSParseNode *pn, *pn2, *opn2;
20413: 
20413:     pn = NewOrRecycledNode(cx, tc);
20413:     if (!pn)
20413:         return NULL;
20413:     pn->pn_type = opn->pn_type;
20413:     pn->pn_pos = opn->pn_pos;
20413:     pn->pn_op = opn->pn_op;
20413:     pn->pn_arity = opn->pn_arity;
20413: 
20413:     switch (pn->pn_arity) {
20419: #define NULLCHECK(e)    JS_BEGIN_MACRO if (!(e)) return NULL; JS_END_MACRO
20413: 
20413:       case PN_FUNC:
20413:         NULLCHECK(pn->pn_funpob =
20413:                   js_NewParsedObjectBox(cx, tc->parseContext, opn->pn_funpob->object));
20413:         NULLCHECK(pn->pn_body = CloneParseTree(cx, opn->pn_body, tc));
20413:         pn->pn_flags = opn->pn_flags;
20413:         pn->pn_index = opn->pn_index;
20413:         break;
20413: 
20413:       case PN_LIST:
20413:         PN_INIT_LIST(pn);
20413:         for (opn2 = opn->pn_head; opn2; opn2 = opn2->pn_next) {
20413:             NULLCHECK(pn2 = CloneParseTree(cx, opn2, tc));
20413:             PN_APPEND(pn, pn2);
20413:         }
20413:         pn->pn_extra = opn->pn_extra;
20413:         break;
20413: 
20413:       case PN_TERNARY:
20413:         NULLCHECK(pn->pn_kid1 = CloneParseTree(cx, opn->pn_kid1, tc));
20413:         NULLCHECK(pn->pn_kid2 = CloneParseTree(cx, opn->pn_kid2, tc));
20413:         NULLCHECK(pn->pn_kid3 = CloneParseTree(cx, opn->pn_kid3, tc));
20413:         break;
20413: 
20413:       case PN_BINARY:
20413:         NULLCHECK(pn->pn_left = CloneParseTree(cx, opn->pn_left, tc));
20413:         if (opn->pn_right != opn->pn_left)
20413:             NULLCHECK(pn->pn_right = CloneParseTree(cx, opn->pn_right, tc));
20413:         else
20413:             pn->pn_right = pn->pn_left;
20413:         pn->pn_val = opn->pn_val;
20413:         pn->pn_iflags = opn->pn_iflags;
20413:         break;
20413: 
20413:       case PN_UNARY:
20413:         NULLCHECK(pn->pn_kid = CloneParseTree(cx, opn->pn_kid, tc));
20413:         pn->pn_num = opn->pn_num;
20413:         pn->pn_hidden = opn->pn_hidden;
20413:         break;
20413: 
20413:       case PN_NAME:
20413:         // PN_NAME could mean several arms in pn_u, so copy the whole thing.
20413:         pn->pn_u = opn->pn_u;
20413:         if (opn->pn_expr)
20413:             NULLCHECK(pn->pn_expr = CloneParseTree(cx, opn->pn_expr, tc));
20413:         break;
20413: 
20413:       case PN_NULLARY:
20413:         // Even PN_NULLARY may have data (apair for E4X -- what a botch).
20413:         pn->pn_u = opn->pn_u;
20413:         break;
20413: 
20413: #undef NULLCHECK
20413:     }
20413:     return pn;
20413: }
20413: 
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
    1: extern const char js_with_statement_str[];
    1: 
    1: static JSParseNode *
    1: ContainsStmt(JSParseNode *pn, JSTokenType tt)
    1: {
    1:     JSParseNode *pn2, *pnt;
    1: 
    1:     if (!pn)
    1:         return NULL;
    1:     if (pn->pn_type == tt)
    1:         return pn;
    1:     switch (pn->pn_arity) {
    1:       case PN_LIST:
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:             pnt = ContainsStmt(pn2, tt);
    1:             if (pnt)
    1:                 return pnt;
    1:         }
    1:         break;
    1:       case PN_TERNARY:
    1:         pnt = ContainsStmt(pn->pn_kid1, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         pnt = ContainsStmt(pn->pn_kid2, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         return ContainsStmt(pn->pn_kid3, tt);
    1:       case PN_BINARY:
    1:         /*
    1:          * Limit recursion if pn is a binary expression, which can't contain a
    1:          * var statement.
    1:          */
    1:         if (pn->pn_op != JSOP_NOP)
    1:             return NULL;
    1:         pnt = ContainsStmt(pn->pn_left, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         return ContainsStmt(pn->pn_right, tt);
    1:       case PN_UNARY:
    1:         if (pn->pn_op != JSOP_NOP)
    1:             return NULL;
    1:         return ContainsStmt(pn->pn_kid, tt);
    1:       case PN_NAME:
    1:         return ContainsStmt(pn->pn_expr, tt);
    1:       default:;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: static JSParseNode *
    1: ReturnOrYield(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:               JSParser operandParser)
    1: {
    1:     JSTokenType tt, tt2;
    1:     JSParseNode *pn, *pn2;
    1: 
    1:     tt = CURRENT_TOKEN(ts).type;
 1577:     if (tt == TOK_RETURN && !(tc->flags & TCF_IN_FUNCTION)) {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
 1577:                                     JSMSG_BAD_RETURN_OR_YIELD, js_return_str);
    1:         return NULL;
    1:     }
    1: 
    1:     pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1: #if JS_HAS_GENERATORS
    1:     if (tt == TOK_YIELD)
    1:         tc->flags |= TCF_FUN_IS_GENERATOR;
    1: #endif
    1: 
    1:     /* This is ugly, but we don't want to require a semicolon. */
    1:     ts->flags |= TSF_OPERAND;
    1:     tt2 = js_PeekTokenSameLine(cx, ts);
    1:     ts->flags &= ~TSF_OPERAND;
    1:     if (tt2 == TOK_ERROR)
    1:         return NULL;
    1: 
    1:     if (tt2 != TOK_EOF && tt2 != TOK_EOL && tt2 != TOK_SEMI && tt2 != TOK_RC
    1: #if JS_HAS_GENERATORS
  339:         && (tt != TOK_YIELD ||
11844:             (tt2 != tt && tt2 != TOK_RB && tt2 != TOK_RP &&
11844:              tt2 != TOK_COLON && tt2 != TOK_COMMA))
    1: #endif
    1:         ) {
    1:         pn2 = operandParser(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1: #if JS_HAS_GENERATORS
    1:         if (tt == TOK_RETURN)
    1: #endif
    1:             tc->flags |= TCF_RETURN_EXPR;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:     } else {
    1: #if JS_HAS_GENERATORS
    1:         if (tt == TOK_RETURN)
    1: #endif
    1:             tc->flags |= TCF_RETURN_VOID;
    1:     }
    1: 
    1:     if ((~tc->flags & (TCF_RETURN_EXPR | TCF_FUN_IS_GENERATOR)) == 0) {
    1:         /* As in Python (see PEP-255), disallow return v; in generators. */
 8444:         ReportBadReturn(cx, tc, JSREPORT_ERROR,
    1:                         JSMSG_BAD_GENERATOR_RETURN,
    1:                         JSMSG_BAD_ANON_GENERATOR_RETURN);
    1:         return NULL;
    1:     }
    1: 
    1:     if (JS_HAS_STRICT_OPTION(cx) &&
    1:         (~tc->flags & (TCF_RETURN_EXPR | TCF_RETURN_VOID)) == 0 &&
 8444:         !ReportBadReturn(cx, tc, JSREPORT_WARNING | JSREPORT_STRICT,
    1:                          JSMSG_NO_RETURN_VALUE,
    1:                          JSMSG_ANON_NO_RETURN_VALUE)) {
    1:         return NULL;
    1:     }
    1: 
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: PushLexicalScope(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:                  JSStmtInfo *stmtInfo)
    1: {
    1:     JSParseNode *pn;
    1:     JSObject *obj;
 9832:     JSParsedObjectBox *blockpob;
    1: 
    1:     pn = NewParseNode(cx, ts, PN_NAME, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     obj = js_NewBlockObject(cx);
    1:     if (!obj)
    1:         return NULL;
    1: 
 9832:     blockpob = js_NewParsedObjectBox(cx, tc->parseContext, obj);
 9832:     if (!blockpob)
 3235:         return NULL;
 3235: 
 3235:     js_PushBlockScope(tc, stmtInfo, obj, -1);
    1:     pn->pn_type = TOK_LEXICALSCOPE;
    1:     pn->pn_op = JSOP_LEAVEBLOCK;
 9832:     pn->pn_pob = blockpob;
    1:     pn->pn_slot = -1;
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1: 
    1: static JSParseNode *
    1: LetBlock(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc, JSBool statement)
    1: {
    1:     JSParseNode *pn, *pnblock, *pnlet;
    1:     JSStmtInfo stmtInfo;
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_LET);
    1: 
    1:     /* Create the let binary node. */
    1:     pnlet = NewParseNode(cx, ts, PN_BINARY, tc);
    1:     if (!pnlet)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_LET);
    1: 
    1:     /* This is a let block or expression of the form: let (a, b, c) .... */
    1:     pnblock = PushLexicalScope(cx, ts, tc, &stmtInfo);
    1:     if (!pnblock)
    1:         return NULL;
    1:     pn = pnblock;
    1:     pn->pn_expr = pnlet;
    1: 
    1:     pnlet->pn_left = Variables(cx, ts, tc);
    1:     if (!pnlet->pn_left)
    1:         return NULL;
    1:     pnlet->pn_left->pn_extra = PNX_POPVAR;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_LET);
    1: 
    1:     ts->flags |= TSF_OPERAND;
    1:     if (statement && !js_MatchToken(cx, ts, TOK_LC)) {
    1:         /*
    1:          * If this is really an expression in let statement guise, then we
    1:          * need to wrap the TOK_LET node in a TOK_SEMI node so that we pop
    1:          * the return value of the expression.
    1:          */
    1:         pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_SEMI;
    1:         pn->pn_num = -1;
    1:         pn->pn_kid = pnblock;
    1: 
    1:         statement = JS_FALSE;
    1:     }
    1:     ts->flags &= ~TSF_OPERAND;
    1: 
    1:     if (statement) {
    1:         pnlet->pn_right = Statements(cx, ts, tc);
    1:         if (!pnlet->pn_right)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_LET);
    1:     } else {
    1:         /*
    1:          * Change pnblock's opcode to the variant that propagates the last
    1:          * result down after popping the block, and clear statement.
    1:          */
    1:         pnblock->pn_op = JSOP_LEAVEBLOCKEXPR;
 1967:         pnlet->pn_right = AssignExpr(cx, ts, tc);
    1:         if (!pnlet->pn_right)
    1:             return NULL;
    1:     }
    1: 
    1:     js_PopStatement(tc);
    1:     return pn;
    1: }
    1: 
    1: #endif /* JS_HAS_BLOCK_SCOPE */
    1: 
    1: static JSParseNode *
    1: Statement(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSTokenType tt;
    1:     JSParseNode *pn, *pn1, *pn2, *pn3, *pn4;
    1:     JSStmtInfo stmtInfo, *stmt, *stmt2;
    1:     JSAtom *label;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     ts->flags |= TSF_OPERAND;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_OPERAND;
    1: 
    1: #if JS_HAS_GETTER_SETTER
    1:     if (tt == TOK_NAME) {
    1:         tt = CheckGetterOrSetter(cx, ts, TOK_FUNCTION);
    1:         if (tt == TOK_ERROR)
    1:             return NULL;
    1:     }
    1: #endif
    1: 
    1:     switch (tt) {
    1:       case TOK_FUNCTION:
    1: #if JS_HAS_XML_SUPPORT
    1:         ts->flags |= TSF_KEYWORD_IS_NAME;
    1:         tt = js_PeekToken(cx, ts);
    1:         ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:         if (tt == TOK_DBLCOLON)
    1:             goto expression;
    1: #endif
    1:         return FunctionStmt(cx, ts, tc);
    1: 
    1:       case TOK_IF:
    1:         /* An IF node has three kids: condition, then, and optional else. */
    1:         pn = NewParseNode(cx, ts, PN_TERNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn1 = Condition(cx, ts, tc);
    1:         if (!pn1)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_IF, -1);
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         ts->flags |= TSF_OPERAND;
    1:         if (js_MatchToken(cx, ts, TOK_ELSE)) {
    1:             ts->flags &= ~TSF_OPERAND;
    1:             stmtInfo.type = STMT_ELSE;
    1:             pn3 = Statement(cx, ts, tc);
    1:             if (!pn3)
    1:                 return NULL;
    1:             pn->pn_pos.end = pn3->pn_pos.end;
    1:         } else {
    1:             ts->flags &= ~TSF_OPERAND;
    1:             pn3 = NULL;
    1:             pn->pn_pos.end = pn2->pn_pos.end;
    1:         }
    1:         js_PopStatement(tc);
    1:         pn->pn_kid1 = pn1;
    1:         pn->pn_kid2 = pn2;
    1:         pn->pn_kid3 = pn3;
    1:         return pn;
    1: 
    1:       case TOK_SWITCH:
    1:       {
    1:         JSParseNode *pn5, *saveBlock;
    1:         JSBool seenDefault = JS_FALSE;
    1: 
    1:         pn = NewParseNode(cx, ts, PN_BINARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_SWITCH);
    1: 
    1:         /* pn1 points to the switch's discriminant. */
 1577:         pn1 = ParenExpr(cx, ts, tc, NULL, NULL);
    1:         if (!pn1)
    1:             return NULL;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_SWITCH);
    1:         MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_SWITCH);
    1: 
    1:         /* pn2 is a list of case nodes. The default case has pn_left == NULL */
    1:         pn2 = NewParseNode(cx, ts, PN_LIST, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         saveBlock = tc->blockNode;
    1:         tc->blockNode = pn2;
    1:         PN_INIT_LIST(pn2);
    1: 
    1:         js_PushStatement(tc, &stmtInfo, STMT_SWITCH, -1);
    1: 
    1:         while ((tt = js_GetToken(cx, ts)) != TOK_RC) {
    1:             switch (tt) {
    1:               case TOK_DEFAULT:
    1:                 if (seenDefault) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_TOO_MANY_DEFAULTS);
    1:                     return NULL;
    1:                 }
    1:                 seenDefault = JS_TRUE;
 1577:                 /* FALL THROUGH */
    1: 
    1:               case TOK_CASE:
    1:                 pn3 = NewParseNode(cx, ts, PN_BINARY, tc);
    1:                 if (!pn3)
    1:                     return NULL;
 1577:                 if (tt == TOK_CASE) {
    1:                     pn3->pn_left = Expr(cx, ts, tc);
    1:                     if (!pn3->pn_left)
    1:                         return NULL;
    1:                 }
    1:                 PN_APPEND(pn2, pn3);
    1:                 if (pn2->pn_count == JS_BIT(16)) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_TOO_MANY_CASES);
    1:                     return NULL;
    1:                 }
    1:                 break;
    1: 
    1:               case TOK_ERROR:
    1:                 return NULL;
    1: 
    1:               default:
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_SWITCH);
    1:                 return NULL;
    1:             }
    1:             MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_AFTER_CASE);
    1: 
    1:             pn4 = NewParseNode(cx, ts, PN_LIST, tc);
    1:             if (!pn4)
    1:                 return NULL;
    1:             pn4->pn_type = TOK_LC;
    1:             PN_INIT_LIST(pn4);
    1:             ts->flags |= TSF_OPERAND;
    1:             while ((tt = js_PeekToken(cx, ts)) != TOK_RC &&
    1:                    tt != TOK_CASE && tt != TOK_DEFAULT) {
    1:                 ts->flags &= ~TSF_OPERAND;
    1:                 if (tt == TOK_ERROR)
    1:                     return NULL;
    1:                 pn5 = Statement(cx, ts, tc);
    1:                 if (!pn5)
    1:                     return NULL;
    1:                 pn4->pn_pos.end = pn5->pn_pos.end;
    1:                 PN_APPEND(pn4, pn5);
    1:                 ts->flags |= TSF_OPERAND;
    1:             }
    1:             ts->flags &= ~TSF_OPERAND;
    1: 
    1:             /* Fix the PN_LIST so it doesn't begin at the TOK_COLON. */
    1:             if (pn4->pn_head)
    1:                 pn4->pn_pos.begin = pn4->pn_head->pn_pos.begin;
    1:             pn3->pn_pos.end = pn4->pn_pos.end;
    1:             pn3->pn_right = pn4;
    1:         }
    1: 
    1:         /*
    1:          * Handle the case where there was a let declaration in any case in
    1:          * the switch body, but not within an inner block.  If it replaced
    1:          * tc->blockNode with a new block node then we must refresh pn2 and
    1:          * then restore tc->blockNode.
    1:          */
    1:         if (tc->blockNode != pn2)
    1:             pn2 = tc->blockNode;
    1:         tc->blockNode = saveBlock;
    1:         js_PopStatement(tc);
    1: 
    1:         pn->pn_pos.end = pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         pn->pn_left = pn1;
    1:         pn->pn_right = pn2;
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_WHILE:
    1:         pn = NewParseNode(cx, ts, PN_BINARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_WHILE_LOOP, -1);
    1:         pn2 = Condition(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_left = pn2;
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         js_PopStatement(tc);
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_right = pn2;
    1:         return pn;
    1: 
    1:       case TOK_DO:
    1:         pn = NewParseNode(cx, ts, PN_BINARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_DO_LOOP, -1);
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_left = pn2;
    1:         MUST_MATCH_TOKEN(TOK_WHILE, JSMSG_WHILE_AFTER_DO);
    1:         pn2 = Condition(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         js_PopStatement(tc);
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_right = pn2;
 1599:         if (JSVERSION_NUMBER(cx) != JSVERSION_ECMA_3) {
    1:             /*
    1:              * All legacy and extended versions must do automatic semicolon
    1:              * insertion after do-while.  See the testcase and discussion in
    1:              * http://bugzilla.mozilla.org/show_bug.cgi?id=238945.
    1:              */
    1:             (void) js_MatchToken(cx, ts, TOK_SEMI);
    1:             return pn;
    1:         }
    1:         break;
    1: 
    1:       case TOK_FOR:
    1:       {
20413:         JSParseNode *pnseq = NULL;
    1: #if JS_HAS_BLOCK_SCOPE
20413:         JSParseNode *pnlet = NULL;
    1:         JSStmtInfo blockInfo;
    1: #endif
    1: 
    1:         /* A FOR node is binary, left is loop control and right is the body. */
    1:         pn = NewParseNode(cx, ts, PN_BINARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_FOR_LOOP, -1);
    1: 
15613:         pn->pn_op = JSOP_ITER;
15613:         pn->pn_iflags = 0;
    1:         if (js_MatchToken(cx, ts, TOK_NAME)) {
    1:             if (CURRENT_TOKEN(ts).t_atom == cx->runtime->atomState.eachAtom)
15613:                 pn->pn_iflags = JSITER_FOREACH;
    1:             else
    1:                 js_UngetToken(ts);
    1:         }
    1: 
    1:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
    1:         ts->flags |= TSF_OPERAND;
    1:         tt = js_PeekToken(cx, ts);
    1:         ts->flags &= ~TSF_OPERAND;
    1:         if (tt == TOK_SEMI) {
15613:             if (pn->pn_iflags & JSITER_FOREACH)
    1:                 goto bad_for_each;
    1: 
    1:             /* No initializer -- set first kid of left sub-node to null. */
    1:             pn1 = NULL;
    1:         } else {
    1:             /*
    1:              * Set pn1 to a var list or an initializing expression.
    1:              *
    1:              * Set the TCF_IN_FOR_INIT flag during parsing of the first clause
    1:              * of the for statement.  This flag will be used by the RelExpr
    1:              * production; if it is set, then the 'in' keyword will not be
    1:              * recognized as an operator, leaving it available to be parsed as
    1:              * part of a for/in loop.
    1:              *
    1:              * A side effect of this restriction is that (unparenthesized)
    1:              * expressions involving an 'in' operator are illegal in the init
    1:              * clause of an ordinary for loop.
    1:              */
    1:             tc->flags |= TCF_IN_FOR_INIT;
    1:             if (tt == TOK_VAR) {
    1:                 (void) js_GetToken(cx, ts);
    1:                 pn1 = Variables(cx, ts, tc);
    1: #if JS_HAS_BLOCK_SCOPE
    1:             } else if (tt == TOK_LET) {
    1:                 (void) js_GetToken(cx, ts);
    1:                 if (js_PeekToken(cx, ts) == TOK_LP) {
    1:                     pn1 = LetBlock(cx, ts, tc, JS_FALSE);
    1:                     tt = TOK_LEXICALSCOPE;
    1:                 } else {
    1:                     pnlet = PushLexicalScope(cx, ts, tc, &blockInfo);
    1:                     if (!pnlet)
    1:                         return NULL;
 9976:                     blockInfo.flags |= SIF_FOR_BLOCK;
    1:                     pn1 = Variables(cx, ts, tc);
    1:                 }
    1: #endif
    1:             } else {
    1:                 pn1 = Expr(cx, ts, tc);
    1:                 if (pn1) {
    1:                     while (pn1->pn_type == TOK_RP)
    1:                         pn1 = pn1->pn_kid;
    1:                 }
    1:             }
    1:             tc->flags &= ~TCF_IN_FOR_INIT;
    1:             if (!pn1)
    1:                 return NULL;
    1:         }
    1: 
    1:         /*
    1:          * We can be sure that it's a for/in loop if there's still an 'in'
    1:          * keyword here, even if JavaScript recognizes 'in' as an operator,
    1:          * as we've excluded 'in' from being parsed in RelExpr by setting
    1:          * the TCF_IN_FOR_INIT flag in our JSTreeContext.
    1:          */
    1:         if (pn1 && js_MatchToken(cx, ts, TOK_IN)) {
15613:             pn->pn_iflags |= JSITER_ENUMERATE;
    1:             stmtInfo.type = STMT_FOR_IN_LOOP;
    1: 
    1:             /* Check that the left side of the 'in' is valid. */
    1:             JS_ASSERT(!TOKEN_TYPE_IS_DECL(tt) || pn1->pn_type == tt);
    1:             if (TOKEN_TYPE_IS_DECL(tt)
    1:                 ? (pn1->pn_count > 1 || pn1->pn_op == JSOP_DEFCONST
    1: #if JS_HAS_DESTRUCTURING
 1599:                    || (JSVERSION_NUMBER(cx) == JSVERSION_1_7 &&
15613:                        pn->pn_op == JSOP_ITER &&
15613:                        !(pn->pn_iflags & JSITER_FOREACH) &&
    1:                        (pn1->pn_head->pn_type == TOK_RC ||
    1:                         (pn1->pn_head->pn_type == TOK_RB &&
    1:                          pn1->pn_head->pn_count != 2) ||
    1:                         (pn1->pn_head->pn_type == TOK_ASSIGN &&
    1:                          (pn1->pn_head->pn_left->pn_type != TOK_RB ||
    1:                           pn1->pn_head->pn_left->pn_count != 2))))
    1: #endif
    1:                   )
    1:                 : (pn1->pn_type != TOK_NAME &&
    1:                    pn1->pn_type != TOK_DOT &&
    1: #if JS_HAS_DESTRUCTURING
 1599:                    ((JSVERSION_NUMBER(cx) == JSVERSION_1_7 &&
15613:                      pn->pn_op == JSOP_ITER &&
15613:                      !(pn->pn_iflags & JSITER_FOREACH))
    1:                     ? (pn1->pn_type != TOK_RB || pn1->pn_count != 2)
    1:                     : (pn1->pn_type != TOK_RB && pn1->pn_type != TOK_RC)) &&
    1: #endif
    1: #if JS_HAS_LVALUE_RETURN
    1:                    pn1->pn_type != TOK_LP &&
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:                    (pn1->pn_type != TOK_UNARYOP ||
    1:                     pn1->pn_op != JSOP_XMLNAME) &&
    1: #endif
    1:                    pn1->pn_type != TOK_LB)) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, pn1, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_FOR_LEFTSIDE);
    1:                 return NULL;
    1:             }
    1: 
20413:             /* pn2 points to the name or destructuring pattern on in's left. */
20413:             pn2 = NULL;
20413: 
    1:             if (TOKEN_TYPE_IS_DECL(tt)) {
    1:                 /* Tell js_EmitTree(TOK_VAR) that pn1 is part of a for/in. */
    1:                 pn1->pn_extra |= PNX_FORINVAR;
    1: 
    1:                 /*
20413:                  * Rewrite 'for (<decl> x = i in o)' where <decl> is 'let',
20413:                  * 'var', or 'const' to hoist the initializer or the entire
20413:                  * decl out of the loop head. TOK_VAR is the type for both
20413:                  * 'var' and 'const'.
    1:                  */
    1:                 pn2 = pn1->pn_head;
20413:                 if (pn2->pn_type == TOK_NAME && pn2->pn_expr
20413: #if JS_HAS_DESTRUCTURING
20413:                     || pn2->pn_type == TOK_ASSIGN
20413: #endif
20413:                     ) {
20413:                     pnseq = NewParseNode(cx, ts, PN_LIST, tc);
20413:                     if (!pnseq)
20413:                         return NULL;
20413:                     pnseq->pn_type = TOK_SEQ;
20413:                     pnseq->pn_pos.begin = pn->pn_pos.begin;
20413:                     if (tt == TOK_LET) {
20413:                         /*
20413:                          * Hoist just the 'i' from 'for (let x = i in o)' to
20413:                          * before the loop, glued together via pnseq.
20413:                          */
20413:                         pn3 = NewParseNode(cx, ts, PN_UNARY, tc);
20413:                         if (!pn3)
20413:                             return NULL;
20413:                         pn3->pn_type = TOK_SEMI;
20413:                         pn3->pn_op = JSOP_NOP;
20413: #if JS_HAS_DESTRUCTURING
20413:                         if (pn2->pn_type == TOK_ASSIGN) {
20413:                             pn4 = pn2->pn_right;
20413:                             pn2 = pn1->pn_head = pn2->pn_left;
20413:                         } else
20413: #endif
20413:                         {
20413:                             pn4 = pn2->pn_expr;
20413:                             pn2->pn_expr = NULL;
20413:                         }
20413:                         pn3->pn_pos = pn4->pn_pos;
20413:                         pn3->pn_kid = pn4;
20413:                         PN_INIT_LIST_1(pnseq, pn3);
20413:                     } else {
20413:                         /*
20413:                          * All of 'var x = i' is hoisted above 'for (x in o)',
20413:                          * so clear PNX_FORINVAR.
20413:                          *
20413:                          * Request JSOP_POP here since the var is for a simple
20413:                          * name (it is not a destructuring binding's left-hand
20413:                          * side) and it has an initializer.
20413:                          */
20413:                         pn1->pn_extra &= ~PNX_FORINVAR;
    1:                         pn1->pn_extra |= PNX_POPVAR;
20413:                         PN_INIT_LIST_1(pnseq, pn1);
20413: 
20413: #if JS_HAS_DESTRUCTURING
20413:                         if (pn2->pn_type == TOK_ASSIGN) {
20413:                             pn1 = CloneParseTree(cx, pn2->pn_left, tc);
20413:                             if (!pn1)
20413:                                 return NULL;
20413:                         } else
20413: #endif
20413:                         {
20413:                             pn1 = NewParseNode(cx, ts, PN_NAME, tc);
20413:                             if (!pn1)
20413:                                 return NULL;
20413:                             pn1->pn_type = TOK_NAME;
20413:                             pn1->pn_op = JSOP_NAME;
20413:                             pn1->pn_pos = pn2->pn_pos;
20413:                             pn1->pn_atom = pn2->pn_atom;
20413:                             pn1->pn_expr = NULL;
20413:                             pn1->pn_slot = -1;
20413:                             pn1->pn_const = pn2->pn_const;
20413:                         }
20413:                         pn2 = pn1;
20413:                     }
20413:                 }
20413:             }
20413: 
20413:             if (!pn2) {
    1:                 pn2 = pn1;
    1: #if JS_HAS_LVALUE_RETURN
 1577:                 if (pn2->pn_type == TOK_LP &&
 7984:                     !MakeSetCall(cx, pn2, tc, JSMSG_BAD_LEFTSIDE_OF_ASS)) {
 1577:                     return NULL;
 1577:                 }
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:                 if (pn2->pn_type == TOK_UNARYOP)
    1:                     pn2->pn_op = JSOP_BINDXMLNAME;
    1: #endif
    1:             }
    1: 
    1:             switch (pn2->pn_type) {
    1:               case TOK_NAME:
    1:                 /* Beware 'for (arguments in ...)' with or without a 'var'. */
    1:                 if (pn2->pn_atom == cx->runtime->atomState.argumentsAtom)
    1:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:                 break;
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:               case TOK_ASSIGN:
    1:                 pn2 = pn2->pn_left;
    1:                 JS_ASSERT(pn2->pn_type == TOK_RB || pn2->pn_type == TOK_RC);
    1:                 /* FALL THROUGH */
    1:               case TOK_RB:
    1:               case TOK_RC:
    1:                 /* Check for valid lvalues in var-less destructuring for-in. */
    1:                 if (pn1 == pn2 && !CheckDestructuring(cx, NULL, pn2, NULL, tc))
    1:                     return NULL;
    1: 
 1599:                 if (JSVERSION_NUMBER(cx) == JSVERSION_1_7) {
 1599:                     /*
 1599:                      * Destructuring for-in requires [key, value] enumeration
 1599:                      * in JS1.7.
 1599:                      */
15613:                     JS_ASSERT(pn->pn_op == JSOP_ITER);
15613:                     if (!(pn->pn_iflags & JSITER_FOREACH))
15613:                         pn->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
 1599:                 }
    1:                 break;
    1: #endif
    1: 
    1:               default:;
    1:             }
    1: 
    1:             /* Parse the object expression as the right operand of 'in'. */
    1:             pn2 = NewBinary(cx, TOK_IN, JSOP_NOP, pn1, Expr(cx, ts, tc), tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn->pn_left = pn2;
    1:         } else {
15613:             if (pn->pn_iflags & JSITER_FOREACH)
    1:                 goto bad_for_each;
    1:             pn->pn_op = JSOP_NOP;
    1: 
    1:             /* Parse the loop condition or null into pn2. */
    1:             MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_INIT);
    1:             ts->flags |= TSF_OPERAND;
    1:             tt = js_PeekToken(cx, ts);
    1:             ts->flags &= ~TSF_OPERAND;
    1:             if (tt == TOK_SEMI) {
    1:                 pn2 = NULL;
    1:             } else {
    1:                 pn2 = Expr(cx, ts, tc);
    1:                 if (!pn2)
    1:                     return NULL;
    1:             }
    1: 
    1:             /* Parse the update expression or null into pn3. */
    1:             MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_COND);
    1:             ts->flags |= TSF_OPERAND;
    1:             tt = js_PeekToken(cx, ts);
    1:             ts->flags &= ~TSF_OPERAND;
    1:             if (tt == TOK_RP) {
    1:                 pn3 = NULL;
    1:             } else {
    1:                 pn3 = Expr(cx, ts, tc);
    1:                 if (!pn3)
    1:                     return NULL;
    1:             }
    1: 
20902:             /* Build the FORHEAD node to use as the left kid of pn. */
    1:             pn4 = NewParseNode(cx, ts, PN_TERNARY, tc);
    1:             if (!pn4)
    1:                 return NULL;
20902:             pn4->pn_type = TOK_FORHEAD;
    1:             pn4->pn_op = JSOP_NOP;
    1:             pn4->pn_kid1 = pn1;
    1:             pn4->pn_kid2 = pn2;
    1:             pn4->pn_kid3 = pn3;
    1:             pn->pn_left = pn4;
    1:         }
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
    1: 
    1:         /* Parse the loop body into pn->pn_right. */
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_right = pn2;
    1: 
    1:         /* Record the absolute line number for source note emission. */
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1:         if (pnlet) {
    1:             js_PopStatement(tc);
    1:             pnlet->pn_expr = pn;
    1:             pn = pnlet;
    1:         }
    1: #endif
20413:         if (pnseq) {
20413:             pnseq->pn_pos.end = pn->pn_pos.end;
20413:             PN_APPEND(pnseq, pn);
20413:             pn = pnseq;
20413:         }
    1:         js_PopStatement(tc);
    1:         return pn;
    1: 
    1:       bad_for_each:
 7984:         js_ReportCompileErrorNumber(cx, ts, pn, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_FOR_EACH_LOOP);
    1:         return NULL;
    1:       }
    1: 
    1:       case TOK_TRY: {
    1:         JSParseNode *catchList, *lastCatch;
    1: 
    1:         /*
    1:          * try nodes are ternary.
    1:          * kid1 is the try Statement
    1:          * kid2 is the catch node list or null
    1:          * kid3 is the finally Statement
    1:          *
    1:          * catch nodes are ternary.
    1:          * kid1 is the lvalue (TOK_NAME, TOK_LB, or TOK_LC)
    1:          * kid2 is the catch guard or null if no guard
    1:          * kid3 is the catch block
    1:          *
    1:          * catch lvalue nodes are either:
    1:          *   TOK_NAME for a single identifier
    1:          *   TOK_RB or TOK_RC for a destructuring left-hand side
    1:          *
    1:          * finally nodes are TOK_LC Statement lists.
    1:          */
    1:         pn = NewParseNode(cx, ts, PN_TERNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_op = JSOP_NOP;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_TRY);
    1:         js_PushStatement(tc, &stmtInfo, STMT_TRY, -1);
    1:         pn->pn_kid1 = Statements(cx, ts, tc);
    1:         if (!pn->pn_kid1)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_TRY);
    1:         js_PopStatement(tc);
    1: 
    1:         catchList = NULL;
    1:         tt = js_GetToken(cx, ts);
    1:         if (tt == TOK_CATCH) {
    1:             catchList = NewParseNode(cx, ts, PN_LIST, tc);
    1:             if (!catchList)
    1:                 return NULL;
    1:             catchList->pn_type = TOK_RESERVED;
    1:             PN_INIT_LIST(catchList);
    1:             lastCatch = NULL;
    1: 
    1:             do {
    1:                 JSParseNode *pnblock;
    1:                 BindData data;
    1: 
    1:                 /* Check for another catch after unconditional catch. */
    1:                 if (lastCatch && !lastCatch->pn_kid2) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_CATCH_AFTER_GENERAL);
    1:                     return NULL;
    1:                 }
    1: 
    1:                 /*
    1:                  * Create a lexical scope node around the whole catch clause,
    1:                  * including the head.
    1:                  */
    1:                 pnblock = PushLexicalScope(cx, ts, tc, &stmtInfo);
    1:                 if (!pnblock)
    1:                     return NULL;
    1:                 stmtInfo.type = STMT_CATCH;
    1: 
    1:                 /*
    1:                  * Legal catch forms are:
    1:                  *   catch (lhs)
    1:                  *   catch (lhs if <boolean_expression>)
    1:                  * where lhs is a name or a destructuring left-hand side.
    1:                  * (the latter is legal only #ifdef JS_HAS_CATCH_GUARD)
    1:                  */
    1:                 pn2 = NewParseNode(cx, ts, PN_TERNARY, tc);
    1:                 if (!pn2)
    1:                     return NULL;
    1:                 pnblock->pn_expr = pn2;
    1:                 MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_CATCH);
    1: 
    1:                 /*
    1:                  * Contrary to ECMA Ed. 3, the catch variable is lexically
    1:                  * scoped, not a property of a new Object instance.  This is
    1:                  * an intentional change that anticipates ECMA Ed. 4.
    1:                  */
    1:                 data.pn = NULL;
    1:                 data.op = JSOP_NOP;
    1:                 data.binder = BindLet;
    1:                 data.u.let.overflow = JSMSG_TOO_MANY_CATCH_VARS;
    1: 
    1:                 tt = js_GetToken(cx, ts);
    1:                 switch (tt) {
    1: #if JS_HAS_DESTRUCTURING
    1:                   case TOK_LB:
    1:                   case TOK_LC:
    1:                     pn3 = DestructuringExpr(cx, &data, tc, tt);
    1:                     if (!pn3)
    1:                         return NULL;
    1:                     break;
    1: #endif
    1: 
    1:                   case TOK_NAME:
    1:                     label = CURRENT_TOKEN(ts).t_atom;
    1:                     if (!data.binder(cx, &data, label, tc))
    1:                         return NULL;
    1: 
    1:                     pn3 = NewParseNode(cx, ts, PN_NAME, tc);
    1:                     if (!pn3)
    1:                         return NULL;
    1:                     pn3->pn_atom = label;
16072:                     pn3->pn_slot = -1;
    1:                     break;
    1: 
    1:                   default:
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_CATCH_IDENTIFIER);
    1:                     return NULL;
    1:                 }
    1: 
    1:                 pn2->pn_kid1 = pn3;
    1: #if JS_HAS_CATCH_GUARD
    1:                 /*
    1:                  * We use 'catch (x if x === 5)' (not 'catch (x : x === 5)')
    1:                  * to avoid conflicting with the JS2/ECMAv4 type annotation
    1:                  * catchguard syntax.
    1:                  */
    1:                 if (js_MatchToken(cx, ts, TOK_IF)) {
    1:                     pn2->pn_kid2 = Expr(cx, ts, tc);
    1:                     if (!pn2->pn_kid2)
    1:                         return NULL;
    1:                 }
    1: #endif
    1:                 MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_CATCH);
    1: 
    1:                 MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_CATCH);
    1:                 pn2->pn_kid3 = Statements(cx, ts, tc);
    1:                 if (!pn2->pn_kid3)
    1:                     return NULL;
    1:                 MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_CATCH);
    1:                 js_PopStatement(tc);
    1: 
    1:                 PN_APPEND(catchList, pnblock);
    1:                 lastCatch = pn2;
    1:                 ts->flags |= TSF_OPERAND;
    1:                 tt = js_GetToken(cx, ts);
    1:                 ts->flags &= ~TSF_OPERAND;
    1:             } while (tt == TOK_CATCH);
    1:         }
    1:         pn->pn_kid2 = catchList;
    1: 
    1:         if (tt == TOK_FINALLY) {
    1:             MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_FINALLY);
    1:             js_PushStatement(tc, &stmtInfo, STMT_FINALLY, -1);
    1:             pn->pn_kid3 = Statements(cx, ts, tc);
    1:             if (!pn->pn_kid3)
    1:                 return NULL;
    1:             MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_FINALLY);
    1:             js_PopStatement(tc);
    1:         } else {
    1:             js_UngetToken(ts);
    1:         }
    1:         if (!catchList && !pn->pn_kid3) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_CATCH_OR_FINALLY);
    1:             return NULL;
    1:         }
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_THROW:
    1:         pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* ECMA-262 Edition 3 says 'throw [no LineTerminator here] Expr'. */
    1:         ts->flags |= TSF_OPERAND;
    1:         tt = js_PeekTokenSameLine(cx, ts);
    1:         ts->flags &= ~TSF_OPERAND;
    1:         if (tt == TOK_ERROR)
    1:             return NULL;
    1:         if (tt == TOK_EOF || tt == TOK_EOL || tt == TOK_SEMI || tt == TOK_RC) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_SYNTAX_ERROR);
    1:             return NULL;
    1:         }
    1: 
    1:         pn2 = Expr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_op = JSOP_THROW;
    1:         pn->pn_kid = pn2;
    1:         break;
    1: 
    1:       /* TOK_CATCH and TOK_FINALLY are both handled in the TOK_TRY case */
    1:       case TOK_CATCH:
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_CATCH_WITHOUT_TRY);
    1:         return NULL;
    1: 
    1:       case TOK_FINALLY:
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_FINALLY_WITHOUT_TRY);
    1:         return NULL;
    1: 
    1:       case TOK_BREAK:
    1:         pn = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         if (!MatchLabel(cx, ts, pn))
    1:             return NULL;
    1:         stmt = tc->topStmt;
    1:         label = pn->pn_atom;
    1:         if (label) {
    1:             for (; ; stmt = stmt->down) {
    1:                 if (!stmt) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_LABEL_NOT_FOUND);
    1:                     return NULL;
    1:                 }
 3235:                 if (stmt->type == STMT_LABEL && stmt->u.label == label)
    1:                     break;
    1:             }
    1:         } else {
    1:             for (; ; stmt = stmt->down) {
    1:                 if (!stmt) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_TOUGH_BREAK);
    1:                     return NULL;
    1:                 }
    1:                 if (STMT_IS_LOOP(stmt) || stmt->type == STMT_SWITCH)
    1:                     break;
    1:             }
    1:         }
    1:         if (label)
    1:             pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         break;
    1: 
    1:       case TOK_CONTINUE:
    1:         pn = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         if (!MatchLabel(cx, ts, pn))
    1:             return NULL;
    1:         stmt = tc->topStmt;
    1:         label = pn->pn_atom;
    1:         if (label) {
    1:             for (stmt2 = NULL; ; stmt = stmt->down) {
    1:                 if (!stmt) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_LABEL_NOT_FOUND);
    1:                     return NULL;
    1:                 }
    1:                 if (stmt->type == STMT_LABEL) {
 3235:                     if (stmt->u.label == label) {
    1:                         if (!stmt2 || !STMT_IS_LOOP(stmt2)) {
 7984:                             js_ReportCompileErrorNumber(cx, ts, NULL,
    1:                                                         JSREPORT_ERROR,
    1:                                                         JSMSG_BAD_CONTINUE);
    1:                             return NULL;
    1:                         }
    1:                         break;
    1:                     }
    1:                 } else {
    1:                     stmt2 = stmt;
    1:                 }
    1:             }
    1:         } else {
    1:             for (; ; stmt = stmt->down) {
    1:                 if (!stmt) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_BAD_CONTINUE);
    1:                     return NULL;
    1:                 }
    1:                 if (STMT_IS_LOOP(stmt))
    1:                     break;
    1:             }
    1:         }
    1:         if (label)
    1:             pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         break;
    1: 
    1:       case TOK_WITH:
    1:         pn = NewParseNode(cx, ts, PN_BINARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_WITH);
 1577:         pn2 = ParenExpr(cx, ts, tc, NULL, NULL);
    1:         if (!pn2)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_WITH);
    1:         pn->pn_left = pn2;
    1: 
    1:         js_PushStatement(tc, &stmtInfo, STMT_WITH, -1);
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         js_PopStatement(tc);
    1: 
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_right = pn2;
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:         return pn;
    1: 
    1:       case TOK_VAR:
    1:         pn = Variables(cx, ts, tc);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* Tell js_EmitTree to generate a final POP. */
    1:         pn->pn_extra |= PNX_POPVAR;
    1:         break;
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1:       case TOK_LET:
    1:       {
    1:         JSObject *obj;
 9832:         JSParsedObjectBox *blockpob;
    1: 
    1:         /* Check for a let statement or let expression. */
    1:         if (js_PeekToken(cx, ts) == TOK_LP) {
    1:             pn = LetBlock(cx, ts, tc, JS_TRUE);
    1:             if (!pn || pn->pn_op == JSOP_LEAVEBLOCK)
    1:                 return pn;
    1: 
    1:             /* Let expressions require automatic semicolon insertion. */
    1:             JS_ASSERT(pn->pn_type == TOK_SEMI ||
    1:                       pn->pn_op == JSOP_LEAVEBLOCKEXPR);
    1:             break;
    1:         }
    1: 
    1:         /*
 9976:          * This is a let declaration. We must be directly under a block per
 9976:          * the proposed ES4 specs, but not an implicit block created due to
 9976:          * 'for (let ...)'. If we pass this error test, make the enclosing
 9976:          * JSStmtInfo be our scope. Further let declarations in this block
 9976:          * will find this scope statement and use the same block object.
 9976:          *
 9976:          * If we are the first let declaration in this block (i.e., when the
 9976:          * enclosing maybe-scope JSStmtInfo isn't yet a scope statement) then
 9976:          * we also need to set tc->blockNode to be our TOK_LEXICALSCOPE.
    1:          */
 9832:         stmt = tc->topStmt;
 9976:         if (stmt &&
 9976:             (!STMT_MAYBE_SCOPE(stmt) || (stmt->flags & SIF_FOR_BLOCK))) {
 9832:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
 9832:                                         JSMSG_LET_DECL_NOT_IN_BLOCK);
 9832:             return NULL;
    1:         }
    1: 
    1:         if (stmt && (stmt->flags & SIF_SCOPE)) {
 3235:             JS_ASSERT(tc->blockChain == stmt->u.blockObj);
    1:             obj = tc->blockChain;
    1:         } else {
16379:             if (!stmt || (stmt->flags & SIF_BODY_BLOCK)) {
    1:                 /*
16379:                  * ES4 specifies that let at top level and at body-block scope
16379:                  * does not shadow var, so convert back to var.
    1:                  */
    1:                 CURRENT_TOKEN(ts).type = TOK_VAR;
    1:                 CURRENT_TOKEN(ts).t_op = JSOP_DEFVAR;
    1: 
    1:                 pn = Variables(cx, ts, tc);
    1:                 if (!pn)
    1:                     return NULL;
    1:                 pn->pn_extra |= PNX_POPVAR;
    1:                 break;
    1:             }
    1: 
18084:             /*
18084:              * Some obvious assertions here, but they may help clarify the
18084:              * situation. This stmt is not yet a scope, so it must not be a
18084:              * catch block (which is a lexical scope by definition).
18084:              */
18084:             JS_ASSERT(!(stmt->flags & SIF_SCOPE));
18084:             JS_ASSERT(stmt != tc->topScopeStmt);
18084:             JS_ASSERT(stmt->type == STMT_BLOCK ||
18084:                       stmt->type == STMT_SWITCH ||
18084:                       stmt->type == STMT_TRY ||
18084:                       stmt->type == STMT_FINALLY);
18084:             JS_ASSERT(!stmt->downScope);
18084: 
    1:             /* Convert the block statement into a scope statement. */
    1:             obj = js_NewBlockObject(cx);
    1:             if (!obj)
    1:                 return NULL;
 9832:             blockpob = js_NewParsedObjectBox(cx, tc->parseContext, obj);
 9832:             if (!blockpob)
    1:                 return NULL;
    1: 
    1:             /*
    1:              * Insert stmt on the tc->topScopeStmt/stmtInfo.downScope linked
    1:              * list stack, if it isn't already there.  If it is there, but it
    1:              * lacks the SIF_SCOPE flag, it must be a try, catch, or finally
    1:              * block.
    1:              */
    1:             stmt->flags |= SIF_SCOPE;
 9832:             stmt->downScope = tc->topScopeStmt;
 9832:             tc->topScopeStmt = stmt;
18084:             JS_SCOPE_DEPTH_METERING(++tc->scopeDepth > tc->maxScopeDepth &&
18084:                                     (tc->maxScopeDepth = tc->scopeDepth));
    1: 
    1:             STOBJ_SET_PARENT(obj, tc->blockChain);
    1:             tc->blockChain = obj;
 3235:             stmt->u.blockObj = obj;
    1: 
    1: #ifdef DEBUG
    1:             pn1 = tc->blockNode;
    1:             JS_ASSERT(!pn1 || pn1->pn_type != TOK_LEXICALSCOPE);
    1: #endif
    1: 
    1:             /* Create a new lexical scope node for these statements. */
    1:             pn1 = NewParseNode(cx, ts, PN_NAME, tc);
    1:             if (!pn1)
    1:                 return NULL;
    1: 
    1:             pn1->pn_type = TOK_LEXICALSCOPE;
    1:             pn1->pn_op = JSOP_LEAVEBLOCK;
    1:             pn1->pn_pos = tc->blockNode->pn_pos;
 9832:             pn1->pn_pob = blockpob;
    1:             pn1->pn_expr = tc->blockNode;
    1:             pn1->pn_slot = -1;
    1:             tc->blockNode = pn1;
    1:         }
    1: 
    1:         pn = Variables(cx, ts, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_extra = PNX_POPVAR;
    1:         break;
    1:       }
    1: #endif /* JS_HAS_BLOCK_SCOPE */
    1: 
    1:       case TOK_RETURN:
    1:         pn = ReturnOrYield(cx, ts, tc, Expr);
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_LC:
    1:       {
    1:         uintN oldflags;
    1: 
    1:         oldflags = tc->flags;
    1:         tc->flags = oldflags & ~TCF_HAS_FUNCTION_STMT;
    1:         js_PushStatement(tc, &stmtInfo, STMT_BLOCK, -1);
    1:         pn = Statements(cx, ts, tc);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_COMPOUND);
    1:         js_PopStatement(tc);
    1: 
    1:         /*
    1:          * If we contain a function statement and our container is top-level
    1:          * or another block, flag pn to preserve braces when decompiling.
    1:          */
    1:         if ((tc->flags & TCF_HAS_FUNCTION_STMT) &&
    1:             (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)) {
    1:             pn->pn_extra |= PNX_NEEDBRACES;
    1:         }
    1:         tc->flags = oldflags | (tc->flags & (TCF_FUN_FLAGS | TCF_RETURN_FLAGS));
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_EOL:
    1:       case TOK_SEMI:
    1:         pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_SEMI;
    1:         return pn;
    1: 
    1: #if JS_HAS_DEBUGGER_KEYWORD
    1:       case TOK_DEBUGGER:
    1:         pn = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_DEBUGGER;
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:         break;
    1: #endif /* JS_HAS_DEBUGGER_KEYWORD */
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_DEFAULT:
    1:         pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         if (!js_MatchToken(cx, ts, TOK_NAME) ||
    1:             CURRENT_TOKEN(ts).t_atom != cx->runtime->atomState.xmlAtom ||
    1:             !js_MatchToken(cx, ts, TOK_NAME) ||
    1:             CURRENT_TOKEN(ts).t_atom != cx->runtime->atomState.namespaceAtom ||
    1:             !js_MatchToken(cx, ts, TOK_ASSIGN) ||
    1:             CURRENT_TOKEN(ts).t_op != JSOP_NOP) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_BAD_DEFAULT_XML_NAMESPACE);
    1:             return NULL;
    1:         }
    1:         pn2 = Expr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_op = JSOP_DEFXMLNS;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:         tc->flags |= TCF_HAS_DEFXMLNS;
    1:         break;
    1: #endif
    1: 
    1:       case TOK_ERROR:
    1:         return NULL;
    1: 
    1:       default:
    1: #if JS_HAS_XML_SUPPORT
    1:       expression:
    1: #endif
    1:         js_UngetToken(ts);
    1:         pn2 = Expr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1: 
    1:         if (js_PeekToken(cx, ts) == TOK_COLON) {
    1:             if (pn2->pn_type != TOK_NAME) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_LABEL);
    1:                 return NULL;
    1:             }
    1:             label = pn2->pn_atom;
    1:             for (stmt = tc->topStmt; stmt; stmt = stmt->down) {
 3235:                 if (stmt->type == STMT_LABEL && stmt->u.label == label) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_DUPLICATE_LABEL);
    1:                     return NULL;
    1:                 }
    1:             }
    1:             (void) js_GetToken(cx, ts);
    1: 
    1:             /* Push a label struct and parse the statement. */
    1:             js_PushStatement(tc, &stmtInfo, STMT_LABEL, -1);
 3235:             stmtInfo.u.label = label;
    1:             pn = Statement(cx, ts, tc);
    1:             if (!pn)
    1:                 return NULL;
    1: 
    1:             /* Normalize empty statement to empty block for the decompiler. */
    1:             if (pn->pn_type == TOK_SEMI && !pn->pn_kid) {
    1:                 pn->pn_type = TOK_LC;
    1:                 pn->pn_arity = PN_LIST;
    1:                 PN_INIT_LIST(pn);
    1:             }
    1: 
    1:             /* Pop the label, set pn_expr, and return early. */
    1:             js_PopStatement(tc);
    1:             pn2->pn_type = TOK_COLON;
    1:             pn2->pn_pos.end = pn->pn_pos.end;
    1:             pn2->pn_expr = pn;
    1:             return pn2;
    1:         }
    1: 
    1:         pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_SEMI;
    1:         pn->pn_pos = pn2->pn_pos;
    1:         pn->pn_kid = pn2;
    1:         break;
    1:     }
    1: 
    1:     /* Check termination of this primitive statement. */
    1:     if (ON_CURRENT_LINE(ts, pn->pn_pos)) {
    1:         ts->flags |= TSF_OPERAND;
    1:         tt = js_PeekTokenSameLine(cx, ts);
    1:         ts->flags &= ~TSF_OPERAND;
    1:         if (tt == TOK_ERROR)
    1:             return NULL;
    1:         if (tt != TOK_EOF && tt != TOK_EOL && tt != TOK_SEMI && tt != TOK_RC) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_SEMI_BEFORE_STMNT);
    1:             return NULL;
    1:         }
    1:     }
    1: 
    1:     (void) js_MatchToken(cx, ts, TOK_SEMI);
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: Variables(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSTokenType tt;
    1:     JSBool let;
    1:     JSStmtInfo *scopeStmt;
    1:     BindData data;
    1:     JSParseNode *pn, *pn2;
    1:     JSAtom *atom;
    1: 
    1:     /*
    1:      * The three options here are:
    1:      * - TOK_LET: We are parsing a let declaration.
    1:      * - TOK_LP: We are parsing the head of a let block.
    1:      * - Otherwise, we're parsing var declarations.
    1:      */
    1:     tt = CURRENT_TOKEN(ts).type;
    1:     let = (tt == TOK_LET || tt == TOK_LP);
    1:     JS_ASSERT(let || tt == TOK_VAR);
    1: 
    1:     /* Make sure that Statement set the tree context up correctly. */
    1:     scopeStmt = tc->topScopeStmt;
    1:     if (let) {
    1:         while (scopeStmt && !(scopeStmt->flags & SIF_SCOPE)) {
    1:             JS_ASSERT(!STMT_MAYBE_SCOPE(scopeStmt));
    1:             scopeStmt = scopeStmt->downScope;
    1:         }
    1:         JS_ASSERT(scopeStmt);
    1:     }
    1: 
    1:     data.pn = NULL;
    1:     data.op = let ? JSOP_NOP : CURRENT_TOKEN(ts).t_op;
    1:     pn = NewParseNode(cx, ts, PN_LIST, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_op = data.op;
    1:     PN_INIT_LIST(pn);
    1: 
    1:     /*
    1:      * The tricky part of this code is to create special parsenode opcodes for
    1:      * getting and setting variables (which will be stored as special slots in
    1:      * the frame).  The most complicated case is an eval() inside a function.
    1:      * If the evaluated string references variables in the enclosing function,
    1:      * then we need to generate the special variable opcodes.  We determine
    1:      * this by looking up the variable's id in the current variable object.
    1:      * Fortunately, we can avoid doing this for let declared variables.
    1:      */
    1:     if (let) {
 3235:         JS_ASSERT(tc->blockChain == scopeStmt->u.blockObj);
 8444:         data.binder = BindLet;
16072:         data.u.let.overflow = JSMSG_TOO_MANY_LOCALS;
    1:     } else {
 8444:         data.binder = BindVarOrConst;
    1:     }
    1: 
    1:     do {
    1:         tt = js_GetToken(cx, ts);
    1: #if JS_HAS_DESTRUCTURING
    1:         if (tt == TOK_LB || tt == TOK_LC) {
    1:             pn2 = PrimaryExpr(cx, ts, tc, tt, JS_FALSE);
    1:             if (!pn2)
    1:                 return NULL;
    1: 
    1:             if ((tc->flags & TCF_IN_FOR_INIT) &&
    1:                 js_PeekToken(cx, ts) == TOK_IN) {
    1:                 if (!CheckDestructuring(cx, &data, pn2, NULL, tc))
    1:                     return NULL;
    1:                 PN_APPEND(pn, pn2);
    1:                 continue;
    1:             }
    1: 
    1:             MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_BAD_DESTRUCT_DECL);
    1:             if (CURRENT_TOKEN(ts).t_op != JSOP_NOP)
    1:                 goto bad_var_init;
    1: 
    1:             pn2 = NewBinary(cx, TOK_ASSIGN, JSOP_NOP,
    1:                             pn2, AssignExpr(cx, ts, tc),
    1:                             tc);
    1:             if (!pn2 ||
    1:                 !CheckDestructuring(cx, &data,
    1:                                     pn2->pn_left, pn2->pn_right,
    1:                                     tc)) {
    1:                 return NULL;
    1:             }
    1:             PN_APPEND(pn, pn2);
    1:             continue;
    1:         }
    1: #endif
    1: 
    1:         if (tt != TOK_NAME) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_NO_VARIABLE_NAME);
    1:             return NULL;
    1:         }
    1:         atom = CURRENT_TOKEN(ts).t_atom;
    1:         if (!data.binder(cx, &data, atom, tc))
    1:             return NULL;
    1: 
    1:         pn2 = NewParseNode(cx, ts, PN_NAME, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn2->pn_op = JSOP_NAME;
    1:         pn2->pn_atom = atom;
    1:         pn2->pn_slot = -1;
 1577:         if (!let)
 8444:             pn2->pn_const = (data.op == JSOP_DEFCONST);
    1:         PN_APPEND(pn, pn2);
    1: 
    1:         if (js_MatchToken(cx, ts, TOK_ASSIGN)) {
    1:             if (CURRENT_TOKEN(ts).t_op != JSOP_NOP)
    1:                 goto bad_var_init;
    1: 
    1:             pn2->pn_expr = AssignExpr(cx, ts, tc);
    1:             if (!pn2->pn_expr)
    1:                 return NULL;
    1:             pn2->pn_op = (!let && data.op == JSOP_DEFCONST)
    1:                          ? JSOP_SETCONST
    1:                          : JSOP_SETNAME;
22906:             pn2->pn_pos.end = pn2->pn_expr->pn_pos.end;
    1:             if (!let && atom == cx->runtime->atomState.argumentsAtom)
    1:                 tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:         }
    1:     } while (js_MatchToken(cx, ts, TOK_COMMA));
    1: 
    1:     pn->pn_pos.end = PN_LAST(pn)->pn_pos.end;
    1:     return pn;
    1: 
    1: bad_var_init:
 7984:     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                 JSMSG_BAD_VAR_INIT);
    1:     return NULL;
    1: }
    1: 
    1: static JSParseNode *
    1: Expr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2;
    1: 
    1:     pn = AssignExpr(cx, ts, tc);
    1:     if (pn && js_MatchToken(cx, ts, TOK_COMMA)) {
    1:         pn2 = NewParseNode(cx, ts, PN_LIST, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn2->pn_pos.begin = pn->pn_pos.begin;
    1:         PN_INIT_LIST_1(pn2, pn);
    1:         pn = pn2;
    1:         do {
    1: #if JS_HAS_GENERATORS
    1:             pn2 = PN_LAST(pn);
    1:             if (pn2->pn_type == TOK_YIELD) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, pn2, JSREPORT_ERROR,
 1577:                                             JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                             js_yield_str);
    1:                 return NULL;
    1:             }
    1: #endif
    1:             pn2 = AssignExpr(cx, ts, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             PN_APPEND(pn, pn2);
    1:         } while (js_MatchToken(cx, ts, TOK_COMMA));
    1:         pn->pn_pos.end = PN_LAST(pn)->pn_pos.end;
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: AssignExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2;
    1:     JSTokenType tt;
    1:     JSOp op;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1: #if JS_HAS_GENERATORS
    1:     ts->flags |= TSF_OPERAND;
    1:     if (js_MatchToken(cx, ts, TOK_YIELD)) {
    1:         ts->flags &= ~TSF_OPERAND;
    1:         return ReturnOrYield(cx, ts, tc, AssignExpr);
    1:     }
    1:     ts->flags &= ~TSF_OPERAND;
    1: #endif
    1: 
    1:     pn = CondExpr(cx, ts, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     tt = js_GetToken(cx, ts);
    1: #if JS_HAS_GETTER_SETTER
    1:     if (tt == TOK_NAME) {
    1:         tt = CheckGetterOrSetter(cx, ts, TOK_ASSIGN);
    1:         if (tt == TOK_ERROR)
    1:             return NULL;
    1:     }
    1: #endif
    1:     if (tt != TOK_ASSIGN) {
    1:         js_UngetToken(ts);
    1:         return pn;
    1:     }
    1: 
    1:     op = CURRENT_TOKEN(ts).t_op;
    1:     for (pn2 = pn; pn2->pn_type == TOK_RP; pn2 = pn2->pn_kid)
    1:         continue;
    1:     switch (pn2->pn_type) {
    1:       case TOK_NAME:
    1:         pn2->pn_op = JSOP_SETNAME;
    1:         if (pn2->pn_atom == cx->runtime->atomState.argumentsAtom)
    1:             tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:         break;
    1:       case TOK_DOT:
    1:         pn2->pn_op = JSOP_SETPROP;
    1:         break;
    1:       case TOK_LB:
    1:         pn2->pn_op = JSOP_SETELEM;
    1:         break;
    1: #if JS_HAS_DESTRUCTURING
    1:       case TOK_RB:
    1:       case TOK_RC:
    1:         if (op != JSOP_NOP) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_BAD_DESTRUCT_ASS);
    1:             return NULL;
    1:         }
    1:         pn = AssignExpr(cx, ts, tc);
    1:         if (!pn || !CheckDestructuring(cx, NULL, pn2, pn, tc))
    1:             return NULL;
    1:         return NewBinary(cx, TOK_ASSIGN, op, pn2, pn, tc);
    1: #endif
    1: #if JS_HAS_LVALUE_RETURN
    1:       case TOK_LP:
 7984:         if (!MakeSetCall(cx, pn2, tc, JSMSG_BAD_LEFTSIDE_OF_ASS))
 1577:             return NULL;
    1:         break;
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_UNARYOP:
    1:         if (pn2->pn_op == JSOP_XMLNAME) {
    1:             pn2->pn_op = JSOP_SETXMLNAME;
    1:             break;
    1:         }
    1:         /* FALL THROUGH */
    1: #endif
    1:       default:
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_LEFTSIDE_OF_ASS);
    1:         return NULL;
    1:     }
    1: 
    1:     return NewBinary(cx, TOK_ASSIGN, op, pn2, AssignExpr(cx, ts, tc), tc);
    1: }
    1: 
    1: static JSParseNode *
    1: CondExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn1, *pn2, *pn3;
    1:     uintN oldflags;
    1: 
    1:     pn = OrExpr(cx, ts, tc);
    1:     if (pn && js_MatchToken(cx, ts, TOK_HOOK)) {
    1:         pn1 = pn;
    1:         pn = NewParseNode(cx, ts, PN_TERNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         /*
    1:          * Always accept the 'in' operator in the middle clause of a ternary,
    1:          * where it's unambiguous, even if we might be parsing the init of a
    1:          * for statement.
    1:          */
    1:         oldflags = tc->flags;
    1:         tc->flags &= ~TCF_IN_FOR_INIT;
    1:         pn2 = AssignExpr(cx, ts, tc);
    1:         tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1: 
    1:         if (!pn2)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_IN_COND);
    1:         pn3 = AssignExpr(cx, ts, tc);
    1:         if (!pn3)
    1:             return NULL;
    1:         pn->pn_pos.begin = pn1->pn_pos.begin;
    1:         pn->pn_pos.end = pn3->pn_pos.end;
    1:         pn->pn_kid1 = pn1;
    1:         pn->pn_kid2 = pn2;
    1:         pn->pn_kid3 = pn3;
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: OrExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = AndExpr(cx, ts, tc);
 6116:     while (pn && js_MatchToken(cx, ts, TOK_OR))
 6116:         pn = NewBinary(cx, TOK_OR, JSOP_OR, pn, AndExpr(cx, ts, tc), tc);
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: AndExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = BitOrExpr(cx, ts, tc);
 6116:     while (pn && js_MatchToken(cx, ts, TOK_AND))
 6116:         pn = NewBinary(cx, TOK_AND, JSOP_AND, pn, BitOrExpr(cx, ts, tc), tc);
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: BitOrExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = BitXorExpr(cx, ts, tc);
    1:     while (pn && js_MatchToken(cx, ts, TOK_BITOR)) {
    1:         pn = NewBinary(cx, TOK_BITOR, JSOP_BITOR, pn, BitXorExpr(cx, ts, tc),
    1:                        tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: BitXorExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = BitAndExpr(cx, ts, tc);
    1:     while (pn && js_MatchToken(cx, ts, TOK_BITXOR)) {
    1:         pn = NewBinary(cx, TOK_BITXOR, JSOP_BITXOR, pn, BitAndExpr(cx, ts, tc),
    1:                        tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: BitAndExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = EqExpr(cx, ts, tc);
    1:     while (pn && js_MatchToken(cx, ts, TOK_BITAND))
    1:         pn = NewBinary(cx, TOK_BITAND, JSOP_BITAND, pn, EqExpr(cx, ts, tc), tc);
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: EqExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSOp op;
    1: 
    1:     pn = RelExpr(cx, ts, tc);
    1:     while (pn && js_MatchToken(cx, ts, TOK_EQOP)) {
    1:         op = CURRENT_TOKEN(ts).t_op;
    1:         pn = NewBinary(cx, TOK_EQOP, op, pn, RelExpr(cx, ts, tc), tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: RelExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSTokenType tt;
    1:     JSOp op;
    1:     uintN inForInitFlag = tc->flags & TCF_IN_FOR_INIT;
    1: 
    1:     /*
    1:      * Uses of the in operator in ShiftExprs are always unambiguous,
    1:      * so unset the flag that prohibits recognizing it.
    1:      */
    1:     tc->flags &= ~TCF_IN_FOR_INIT;
    1: 
    1:     pn = ShiftExpr(cx, ts, tc);
    1:     while (pn &&
    1:            (js_MatchToken(cx, ts, TOK_RELOP) ||
    1:             /*
    1:              * Recognize the 'in' token as an operator only if we're not
    1:              * currently in the init expr of a for loop.
    1:              */
    1:             (inForInitFlag == 0 && js_MatchToken(cx, ts, TOK_IN)) ||
    1:             js_MatchToken(cx, ts, TOK_INSTANCEOF))) {
    1:         tt = CURRENT_TOKEN(ts).type;
    1:         op = CURRENT_TOKEN(ts).t_op;
    1:         pn = NewBinary(cx, tt, op, pn, ShiftExpr(cx, ts, tc), tc);
    1:     }
    1:     /* Restore previous state of inForInit flag. */
    1:     tc->flags |= inForInitFlag;
    1: 
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: ShiftExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSOp op;
    1: 
    1:     pn = AddExpr(cx, ts, tc);
    1:     while (pn && js_MatchToken(cx, ts, TOK_SHOP)) {
    1:         op = CURRENT_TOKEN(ts).t_op;
    1:         pn = NewBinary(cx, TOK_SHOP, op, pn, AddExpr(cx, ts, tc), tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: AddExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSTokenType tt;
    1:     JSOp op;
    1: 
    1:     pn = MulExpr(cx, ts, tc);
    1:     while (pn &&
    1:            (js_MatchToken(cx, ts, TOK_PLUS) ||
    1:             js_MatchToken(cx, ts, TOK_MINUS))) {
    1:         tt = CURRENT_TOKEN(ts).type;
    1:         op = (tt == TOK_PLUS) ? JSOP_ADD : JSOP_SUB;
    1:         pn = NewBinary(cx, tt, op, pn, MulExpr(cx, ts, tc), tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: MulExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSTokenType tt;
    1:     JSOp op;
    1: 
    1:     pn = UnaryExpr(cx, ts, tc);
    1:     while (pn &&
    1:            (js_MatchToken(cx, ts, TOK_STAR) ||
    1:             js_MatchToken(cx, ts, TOK_DIVOP))) {
    1:         tt = CURRENT_TOKEN(ts).type;
    1:         op = CURRENT_TOKEN(ts).t_op;
    1:         pn = NewBinary(cx, tt, op, pn, UnaryExpr(cx, ts, tc), tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: SetLvalKid(JSContext *cx, JSTokenStream *ts, JSParseNode *pn, JSParseNode *kid,
    1:            const char *name)
    1: {
    1:     while (kid->pn_type == TOK_RP)
    1:         kid = kid->pn_kid;
    1:     if (kid->pn_type != TOK_NAME &&
    1:         kid->pn_type != TOK_DOT &&
    1: #if JS_HAS_LVALUE_RETURN
  279:         (kid->pn_type != TOK_LP ||
21460:          (kid->pn_op != JSOP_CALL && kid->pn_op != JSOP_EVAL && kid->pn_op != JSOP_APPLY)) &&
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:         (kid->pn_type != TOK_UNARYOP || kid->pn_op != JSOP_XMLNAME) &&
    1: #endif
    1:         kid->pn_type != TOK_LB) {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_OPERAND, name);
    1:         return NULL;
    1:     }
    1:     pn->pn_kid = kid;
    1:     return kid;
    1: }
    1: 
    1: static const char incop_name_str[][10] = {"increment", "decrement"};
    1: 
    1: static JSBool
    1: SetIncOpKid(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:             JSParseNode *pn, JSParseNode *kid,
    1:             JSTokenType tt, JSBool preorder)
    1: {
    1:     JSOp op;
    1: 
    1:     kid = SetLvalKid(cx, ts, pn, kid, incop_name_str[tt == TOK_DEC]);
    1:     if (!kid)
    1:         return JS_FALSE;
    1:     switch (kid->pn_type) {
    1:       case TOK_NAME:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCNAME : JSOP_NAMEINC)
    1:              : (preorder ? JSOP_DECNAME : JSOP_NAMEDEC);
    1:         if (kid->pn_atom == cx->runtime->atomState.argumentsAtom)
    1:             tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:         break;
    1: 
    1:       case TOK_DOT:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCPROP : JSOP_PROPINC)
    1:              : (preorder ? JSOP_DECPROP : JSOP_PROPDEC);
    1:         break;
    1: 
    1: #if JS_HAS_LVALUE_RETURN
    1:       case TOK_LP:
 7984:         if (!MakeSetCall(cx, kid, tc, JSMSG_BAD_INCOP_OPERAND))
 1577:             return JS_FALSE;
    1:         /* FALL THROUGH */
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_UNARYOP:
    1:         if (kid->pn_op == JSOP_XMLNAME)
    1:             kid->pn_op = JSOP_SETXMLNAME;
    1:         /* FALL THROUGH */
    1: #endif
    1:       case TOK_LB:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCELEM : JSOP_ELEMINC)
    1:              : (preorder ? JSOP_DECELEM : JSOP_ELEMDEC);
    1:         break;
    1: 
    1:       default:
    1:         JS_ASSERT(0);
    1:         op = JSOP_NOP;
    1:     }
    1:     pn->pn_op = op;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSParseNode *
    1: UnaryExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSTokenType tt;
    1:     JSParseNode *pn, *pn2;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     ts->flags |= TSF_OPERAND;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_OPERAND;
    1: 
    1:     switch (tt) {
    1:       case TOK_UNARYOP:
    1:       case TOK_PLUS:
    1:       case TOK_MINUS:
    1:         pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_UNARYOP;      /* PLUS and MINUS are binary */
    1:         pn->pn_op = CURRENT_TOKEN(ts).t_op;
    1:         pn2 = UnaryExpr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:         break;
    1: 
    1:       case TOK_INC:
    1:       case TOK_DEC:
    1:         pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn2 = MemberExpr(cx, ts, tc, JS_TRUE);
    1:         if (!pn2)
    1:             return NULL;
    1:         if (!SetIncOpKid(cx, ts, tc, pn, pn2, tt, JS_TRUE))
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         break;
    1: 
    1:       case TOK_DELETE:
    1:         pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn2 = UnaryExpr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1: 
    1:         /*
    1:          * Under ECMA3, deleting any unary expression is valid -- it simply
 1962:          * returns true. Here we strip off any parentheses and fold constants
 1962:          * before checking for a call expression, in order to rule out delete
 1962:          * of a generator expression.
    1:          */
    1:         while (pn2->pn_type == TOK_RP)
    1:             pn2 = pn2->pn_kid;
 1962:         if (!js_FoldConstants(cx, pn2, tc))
 1962:             return NULL;
 1577:         if (pn2->pn_type == TOK_LP &&
 1577:             pn2->pn_op != JSOP_SETCALL &&
 7984:             !MakeSetCall(cx, pn2, tc, JSMSG_BAD_DELETE_OPERAND)) {
 1577:             return NULL;
 1577:         }
    1:         pn->pn_kid = pn2;
    1:         break;
    1: 
    1:       case TOK_ERROR:
    1:         return NULL;
    1: 
    1:       default:
    1:         js_UngetToken(ts);
    1:         pn = MemberExpr(cx, ts, tc, JS_TRUE);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* Don't look across a newline boundary for a postfix incop. */
    1:         if (ON_CURRENT_LINE(ts, pn->pn_pos)) {
    1:             ts->flags |= TSF_OPERAND;
    1:             tt = js_PeekTokenSameLine(cx, ts);
    1:             ts->flags &= ~TSF_OPERAND;
    1:             if (tt == TOK_INC || tt == TOK_DEC) {
    1:                 (void) js_GetToken(cx, ts);
    1:                 pn2 = NewParseNode(cx, ts, PN_UNARY, tc);
    1:                 if (!pn2)
    1:                     return NULL;
    1:                 if (!SetIncOpKid(cx, ts, tc, pn2, pn, tt, JS_FALSE))
    1:                     return NULL;
    1:                 pn2->pn_pos.begin = pn->pn_pos.begin;
    1:                 pn = pn2;
    1:             }
    1:         }
    1:         break;
    1:     }
    1:     return pn;
    1: }
    1: 
 1577: #if JS_HAS_GENERATORS
 1577: 
 1577: /*
 1577:  * Starting from a |for| keyword after the first array initialiser element or
 1577:  * an expression in an open parenthesis, parse the tail of the comprehension
 1577:  * or generator expression signified by this |for| keyword in context.
 1577:  *
 1577:  * Return null on failure, else return the top-most parse node for the array
 1577:  * comprehension or generator expression, with a unary node as the body of the
 1577:  * (possibly nested) for-loop, initialized by |type, op, kid|.
 1577:  */
 1577: static JSParseNode *
 1577: ComprehensionTail(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
 1577:                   JSTokenType type, JSOp op, JSParseNode *kid)
 1577: {
 1577:     JSParseNode *pn, *pn2, *pn3, **pnp;
 1577:     JSStmtInfo stmtInfo;
 1577:     BindData data;
 1577:     JSRuntime *rt;
 1577:     JSTokenType tt;
 1577:     JSAtom *atom;
 1577: 
 3025:     JS_ASSERT(type == TOK_SEMI || type == TOK_ARRAYPUSH);
 1577:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_FOR);
 1577: 
 1577:     /*
 1577:      * Make a parse-node and literal object representing the block scope of
 1577:      * this array comprehension or generator expression.
 1577:      */
 1577:     pn = PushLexicalScope(cx, ts, tc, &stmtInfo);
 1577:     if (!pn)
 1577:         return NULL;
 1577:     pnp = &pn->pn_expr;
 1577: 
 1577:     data.pn = NULL;
 1577:     data.op = JSOP_NOP;
 1577:     data.binder = BindLet;
 1577:     data.u.let.overflow = JSMSG_ARRAY_INIT_TOO_BIG;
 1577: 
 1577:     rt = cx->runtime;
 1577:     do {
 1577:         /*
 1577:          * FOR node is binary, left is loop control and right is body.  Use
 1577:          * index to count each block-local let-variable on the left-hand side
 1577:          * of the IN.
 1577:          */
 1577:         pn2 = NewParseNode(cx, ts, PN_BINARY, tc);
 1577:         if (!pn2)
 1577:             return NULL;
 1577: 
15613:         pn2->pn_op = JSOP_ITER;
15613:         pn2->pn_iflags = JSITER_ENUMERATE;
 1577:         if (js_MatchToken(cx, ts, TOK_NAME)) {
 1577:             if (CURRENT_TOKEN(ts).t_atom == rt->atomState.eachAtom)
15613:                 pn2->pn_iflags |= JSITER_FOREACH;
 1577:             else
 1577:                 js_UngetToken(ts);
 1577:         }
 1577:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
 1577: 
 1577:         tt = js_GetToken(cx, ts);
 1577:         switch (tt) {
 1577: #if JS_HAS_DESTRUCTURING
 1577:           case TOK_LB:
 1577:           case TOK_LC:
 1577:             pn3 = DestructuringExpr(cx, &data, tc, tt);
 1577:             if (!pn3)
 1577:                 return NULL;
 1577: 
 1577:             if (pn3->pn_type != TOK_RB || pn3->pn_count != 2) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
 1577:                                             JSMSG_BAD_FOR_LEFTSIDE);
 1577:                 return NULL;
 1577:             }
 1577: 
 1599:             if (JSVERSION_NUMBER(cx) == JSVERSION_1_7) {
 1599:                 /* Destructuring requires [key, value] enumeration in JS1.7. */
15613:                 JS_ASSERT(pn2->pn_op == JSOP_ITER);
15613:                 JS_ASSERT(pn2->pn_iflags & JSITER_ENUMERATE);
15613:                 if (!(pn2->pn_iflags & JSITER_FOREACH))
15613:                     pn2->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
 1599:             }
 1577:             break;
 1577: #endif
 1577: 
 1577:           case TOK_NAME:
 1577:             atom = CURRENT_TOKEN(ts).t_atom;
 1577:             if (!data.binder(cx, &data, atom, tc))
 1577:                 return NULL;
 1577: 
 1577:             /*
 1577:              * Create a name node with pn_op JSOP_NAME.  We can't set pn_op to
 1577:              * JSOP_GETLOCAL here, because we don't yet know the block's depth
 1577:              * in the operand stack frame.  The code generator computes that,
 1577:              * and it tries to bind all names to slots, so we must let it do
 1577:              * the deed.
 1577:              */
 1577:             pn3 = NewParseNode(cx, ts, PN_NAME, tc);
 1577:             if (!pn3)
 1577:                 return NULL;
 1577:             pn3->pn_op = JSOP_NAME;
 1577:             pn3->pn_atom = atom;
 1577:             pn3->pn_slot = -1;
 1577:             break;
 1577: 
 1577:           default:
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
 1577:                                         JSMSG_NO_VARIABLE_NAME);
 1607: 
 1607:           case TOK_ERROR:
 1577:             return NULL;
 1577:         }
 1577: 
 1577:         MUST_MATCH_TOKEN(TOK_IN, JSMSG_IN_AFTER_FOR_NAME);
 1577:         pn3 = NewBinary(cx, TOK_IN, JSOP_NOP, pn3,
 1577:                         Expr(cx, ts, tc), tc);
 1577:         if (!pn3)
 1577:             return NULL;
 1577: 
 1577:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
 1577:         pn2->pn_left = pn3;
 1577:         *pnp = pn2;
 1577:         pnp = &pn2->pn_right;
 1577:     } while (js_MatchToken(cx, ts, TOK_FOR));
 1577: 
 1577:     if (js_MatchToken(cx, ts, TOK_IF)) {
 1577:         pn2 = NewParseNode(cx, ts, PN_TERNARY, tc);
 1577:         if (!pn2)
 1577:             return NULL;
 1577:         pn2->pn_kid1 = Condition(cx, ts, tc);
 1577:         if (!pn2->pn_kid1)
 1577:             return NULL;
 1577:         *pnp = pn2;
 1577:         pnp = &pn2->pn_kid2;
 1577:     }
 1577: 
 1577:     pn2 = NewParseNode(cx, ts, PN_UNARY, tc);
 1577:     if (!pn2)
 1577:         return NULL;
 1577:     pn2->pn_type = type;
 1577:     pn2->pn_op = op;
 1577:     pn2->pn_kid = kid;
 1577:     *pnp = pn2;
 1577: 
 1577:     js_PopStatement(tc);
 1577:     return pn;
 1577: }
 1577: 
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577: 
 1577: /*
 1577:  * Starting from a |for| keyword after an expression, parse the comprehension
 1577:  * tail completing this generator expression. Wrap the expression at kid in a
 1577:  * generator function that is immediately called to evaluate to the generator
 1577:  * iterator that is the value of this generator expression.
 1577:  *
 1577:  * Callers pass a blank unary node via pn, which GeneratorExpr fills in as the
 1577:  * yield expression, which ComprehensionTail in turn wraps in a TOK_SEMI-type
 1577:  * expression-statement node that constitutes the body of the |for| loop(s) in
 1577:  * the generator function.
 1577:  *
 1577:  * Note how unlike Python, we do not evaluate the expression to the right of
 1577:  * the first |in| in the chain of |for| heads. Instead, a generator expression
 1577:  * is merely sugar for a generator function expression and its application.
 1577:  */
 1577: static JSParseNode *
 1577: GeneratorExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
 1577:               uintN oldflags, JSParseNode *pn, JSParseNode *kid)
 1577: {
 1577:     JSParseNode *body, *lambda;
 1577:     JSFunction *fun;
 1577: 
 1577:     /* Initialize pn, connecting it to kid. */
 1577:     JS_ASSERT(pn->pn_arity == PN_UNARY);
 1577:     pn->pn_type = TOK_YIELD;
 1577:     pn->pn_op = JSOP_YIELD;
 1577:     pn->pn_pos = kid->pn_pos;
 1577:     pn->pn_kid = kid;
 1577:     pn->pn_hidden = JS_TRUE;
 1577: 
 1577:     /*
 1577:      * Parse the comprehension tail at hand, making pn the kid of the loop
 1577:      * body's expression statement.
 1577:      */
 1577:     body = ComprehensionTail(cx, ts, tc, TOK_SEMI, JSOP_NOP, pn);
 1577:     if (!body)
 1577:         return NULL;
 1577:     body->pn_pos.begin = kid->pn_pos.begin;
 1577: 
 1577:     /*
 1577:      * Make the generator function and flag it as interpreted ASAP (see the
 1577:      * comment in FunctionBody).
 1577:      */
13691:     fun = NewCompilerFunction(cx, tc, NULL, JSFUN_LAMBDA);
 1577:     if (!fun)
 1577:         return NULL;
 1577: 
 1577:     /*
 1577:      * This generator function is referenced by an anonymous function object
 1577:      * node. Here is where we must take care to propagate certain tc->flags
 1577:      * that may have changed from oldflags to reflect crucial facts about the
 1577:      * expression on the left of |for| and in the comprehension tail after it.
 1577:      */
 1577:     lambda = NewParseNode(cx, ts, PN_FUNC, tc);
 1577:     if (!lambda)
 1577:         return NULL;
 1577:     lambda->pn_type = TOK_FUNCTION;
 1577:     lambda->pn_op = JSOP_ANONFUNOBJ;
 1577:     lambda->pn_pos.begin = body->pn_pos.begin;
 3235:     lambda->pn_funpob = js_NewParsedObjectBox(cx, tc->parseContext,
13824:                                               FUN_OBJECT(fun));
 3235:     if (!lambda->pn_funpob)
 1577:         return NULL;
 1577:     lambda->pn_body = body;
 1577:     lambda->pn_flags = TCF_FUN_IS_GENERATOR | TCF_GENEXP_LAMBDA |
 1577:                        ((oldflags ^ tc->flags) & TCF_FUN_FLAGS);
 1577: 
 1577:     /*
 1577:      * Re-use pn to name the result node, a call expression invoking the
 1577:      * anonymous generator function object.
 1577:      */
 1577:     pn = NewParseNode(cx, ts, PN_LIST, tc);
 1577:     if (!pn)
 1577:         return NULL;
 1577:     pn->pn_type = TOK_LP;
 1577:     pn->pn_op = JSOP_CALL;
 1577:     pn->pn_pos.begin = lambda->pn_pos.begin;
 1577:     PN_INIT_LIST_1(pn, lambda);
 1577: 
 1577:     body->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
 1577:     tc->flags = oldflags;
 1577:     return pn;
 1577: }
 1577: 
 1577: static const char js_generator_str[] = "generator";
 1577: 
 1577: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577: #endif /* JS_HAS_GENERATORS */
 1577: 
    1: static JSBool
    1: ArgumentList(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:              JSParseNode *listNode)
    1: {
    1:     JSBool matched;
    1: 
    1:     ts->flags |= TSF_OPERAND;
    1:     matched = js_MatchToken(cx, ts, TOK_RP);
    1:     ts->flags &= ~TSF_OPERAND;
    1:     if (!matched) {
    1:         do {
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577:             uintN oldflags = tc->flags;
 1577: #endif
    1:             JSParseNode *argNode = AssignExpr(cx, ts, tc);
    1:             if (!argNode)
    1:                 return JS_FALSE;
    1: #if JS_HAS_GENERATORS
11844:             if (argNode->pn_type == TOK_YIELD &&
11844:                 js_PeekToken(cx, ts) == TOK_COMMA) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, argNode, JSREPORT_ERROR,
 1577:                                             JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                             js_yield_str);
    1:                 return JS_FALSE;
    1:             }
    1: #endif
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577:             if (js_MatchToken(cx, ts, TOK_FOR)) {
 1577:                 JSParseNode *pn = NewParseNode(cx, ts, PN_UNARY, tc);
 1577:                 if (!pn)
 1577:                     return JS_FALSE;
 1577:                 argNode = GeneratorExpr(cx, ts, tc, oldflags, pn, argNode);
 1577:                 if (!argNode)
 1577:                     return JS_FALSE;
 1577:                 if (listNode->pn_count > 1 ||
 1577:                     js_PeekToken(cx, ts) == TOK_COMMA) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, argNode, JSREPORT_ERROR,
 1577:                                                 JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                                 js_generator_str);
 1577:                     return JS_FALSE;
 1577:                 }
 1577:             }
 1577: #endif
    1:             PN_APPEND(listNode, argNode);
    1:         } while (js_MatchToken(cx, ts, TOK_COMMA));
    1: 
    1:         if (js_GetToken(cx, ts) != TOK_RP) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_PAREN_AFTER_ARGS);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSParseNode *
    1: MemberExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:            JSBool allowCallSyntax)
    1: {
    1:     JSParseNode *pn, *pn2, *pn3;
    1:     JSTokenType tt;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     /* Check for new expression first. */
    1:     ts->flags |= TSF_OPERAND;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_OPERAND;
    1:     if (tt == TOK_NEW) {
    1:         pn = NewParseNode(cx, ts, PN_LIST, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn2 = MemberExpr(cx, ts, tc, JS_FALSE);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_op = JSOP_NEW;
    1:         PN_INIT_LIST_1(pn, pn2);
    1:         pn->pn_pos.begin = pn2->pn_pos.begin;
    1: 
    1:         if (js_MatchToken(cx, ts, TOK_LP) && !ArgumentList(cx, ts, tc, pn))
    1:             return NULL;
    1:         if (pn->pn_count > ARGC_LIMIT) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_TOO_MANY_CON_ARGS);
    1:             return NULL;
    1:         }
    1:         pn->pn_pos.end = PN_LAST(pn)->pn_pos.end;
    1:     } else {
    1:         pn = PrimaryExpr(cx, ts, tc, tt, JS_FALSE);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         if (pn->pn_type == TOK_ANYNAME ||
    1:             pn->pn_type == TOK_AT ||
    1:             pn->pn_type == TOK_DBLCOLON) {
    1:             pn2 = NewOrRecycledNode(cx, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_type = TOK_UNARYOP;
    1:             pn2->pn_pos = pn->pn_pos;
    1:             pn2->pn_op = JSOP_XMLNAME;
    1:             pn2->pn_arity = PN_UNARY;
    1:             pn2->pn_kid = pn;
    1:             pn = pn2;
    1:         }
    1:     }
    1: 
    1:     while ((tt = js_GetToken(cx, ts)) > TOK_EOF) {
    1:         if (tt == TOK_DOT) {
    1:             pn2 = NewParseNode(cx, ts, PN_NAME, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_slot = -1;
    1: #if JS_HAS_XML_SUPPORT
    1:             ts->flags |= TSF_OPERAND | TSF_KEYWORD_IS_NAME;
    1:             tt = js_GetToken(cx, ts);
    1:             ts->flags &= ~(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
    1:             pn3 = PrimaryExpr(cx, ts, tc, tt, JS_TRUE);
    1:             if (!pn3)
    1:                 return NULL;
 3164:             tt = PN_TYPE(pn3);
    1:             if (tt == TOK_NAME) {
    1:                 pn2->pn_op = JSOP_GETPROP;
    1:                 pn2->pn_expr = pn;
    1:                 pn2->pn_atom = pn3->pn_atom;
    1:                 RecycleTree(pn3, tc);
    1:             } else {
    1:                 if (TOKEN_TYPE_IS_XML(tt)) {
    1:                     pn2->pn_type = TOK_LB;
    1:                     pn2->pn_op = JSOP_GETELEM;
    1:                 } else if (tt == TOK_RP) {
    1:                     JSParseNode *group = pn3;
    1: 
20928:                     /* Recycle the useless TOK_RP node. */
    1:                     pn3 = group->pn_kid;
    1:                     group->pn_kid = NULL;
    1:                     RecycleTree(group, tc);
    1:                     pn2->pn_type = TOK_FILTER;
    1:                     pn2->pn_op = JSOP_FILTER;
    1: 
    1:                     /* A filtering predicate is like a with statement. */
    1:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:                 } else {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_NAME_AFTER_DOT);
    1:                     return NULL;
    1:                 }
    1:                 pn2->pn_arity = PN_BINARY;
    1:                 pn2->pn_left = pn;
    1:                 pn2->pn_right = pn3;
    1:             }
    1: #else
    1:             ts->flags |= TSF_KEYWORD_IS_NAME;
    1:             MUST_MATCH_TOKEN(TOK_NAME, JSMSG_NAME_AFTER_DOT);
    1:             ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:             pn2->pn_op = JSOP_GETPROP;
    1:             pn2->pn_expr = pn;
    1:             pn2->pn_atom = CURRENT_TOKEN(ts).t_atom;
    1: #endif
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
    1:             pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1: #if JS_HAS_XML_SUPPORT
    1:         } else if (tt == TOK_DBLDOT) {
    1:             pn2 = NewParseNode(cx, ts, PN_BINARY, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             ts->flags |= TSF_OPERAND | TSF_KEYWORD_IS_NAME;
    1:             tt = js_GetToken(cx, ts);
    1:             ts->flags &= ~(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
    1:             pn3 = PrimaryExpr(cx, ts, tc, tt, JS_TRUE);
    1:             if (!pn3)
    1:                 return NULL;
 3164:             tt = PN_TYPE(pn3);
    1:             if (tt == TOK_NAME) {
    1:                 pn3->pn_type = TOK_STRING;
    1:                 pn3->pn_arity = PN_NULLARY;
    1:                 pn3->pn_op = JSOP_QNAMEPART;
    1:             } else if (!TOKEN_TYPE_IS_XML(tt)) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_NAME_AFTER_DOT);
    1:                 return NULL;
    1:             }
    1:             pn2->pn_op = JSOP_DESCENDANTS;
    1:             pn2->pn_left = pn;
    1:             pn2->pn_right = pn3;
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
    1:             pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1: #endif
    1:         } else if (tt == TOK_LB) {
    1:             pn2 = NewParseNode(cx, ts, PN_BINARY, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn3 = Expr(cx, ts, tc);
    1:             if (!pn3)
    1:                 return NULL;
    1: 
    1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_IN_INDEX);
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
    1:             pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1: 
18392:             /*
18392:              * Optimize o['p'] to o.p by rewriting pn2, but avoid rewriting
18392:              * o['0'] to use JSOP_GETPROP, to keep fast indexing disjoint in
18392:              * the interpreter from fast property access. However, if the
18392:              * bracketed string is a uint32, we rewrite pn3 to be a number
18392:              * instead of a string.
18392:              */
18392:             do {
    1:                 if (pn3->pn_type == TOK_STRING) {
18392:                     jsuint index;
18392: 
18392:                     if (!js_IdIsIndex(ATOM_TO_JSID(pn3->pn_atom), &index)) {
    1:                         pn2->pn_type = TOK_DOT;
    1:                         pn2->pn_op = JSOP_GETPROP;
    1:                         pn2->pn_arity = PN_NAME;
    1:                         pn2->pn_expr = pn;
    1:                         pn2->pn_atom = pn3->pn_atom;
18392:                         break;
18392:                     }
18392:                     pn3->pn_type = TOK_NUMBER;
20902:                     pn3->pn_op = JSOP_DOUBLE;
18392:                     pn3->pn_dval = index;
18392:                 }
    1:                 pn2->pn_op = JSOP_GETELEM;
    1:                 pn2->pn_left = pn;
    1:                 pn2->pn_right = pn3;
18392:             } while (0);
    1:         } else if (allowCallSyntax && tt == TOK_LP) {
    1:             pn2 = NewParseNode(cx, ts, PN_LIST, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1: 
    1:             pn2->pn_op = JSOP_CALL;
 6766:             if (pn->pn_op == JSOP_NAME &&
    1:                 pn->pn_atom == cx->runtime->atomState.evalAtom) {
21452:                 /* Pick JSOP_EVAL and flag tc as heavyweight if eval(...). */
    1:                 pn2->pn_op = JSOP_EVAL;
    1:                 tc->flags |= TCF_FUN_HEAVYWEIGHT;
21452:             } else if (pn->pn_op == JSOP_GETPROP &&
21473:                        (pn->pn_atom == cx->runtime->atomState.applyAtom ||
21473:                         pn->pn_atom == cx->runtime->atomState.callAtom)) {
21452:                 /* Pick JSOP_APPLY if apply(...). */
21452:                 pn2->pn_op = JSOP_APPLY;
    1:             } 
    1: 
    1:             PN_INIT_LIST_1(pn2, pn);
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
    1: 
    1:             if (!ArgumentList(cx, ts, tc, pn2))
    1:                 return NULL;
    1:             if (pn2->pn_count > ARGC_LIMIT) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_TOO_MANY_FUN_ARGS);
    1:                 return NULL;
    1:             }
    1:             pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         } else {
    1:             js_UngetToken(ts);
    1:             return pn;
    1:         }
    1: 
    1:         pn = pn2;
    1:     }
    1:     if (tt == TOK_ERROR)
    1:         return NULL;
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: BracketedExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     uintN oldflags;
    1:     JSParseNode *pn;
    1: 
    1:     /*
    1:      * Always accept the 'in' operator in a parenthesized expression,
    1:      * where it's unambiguous, even if we might be parsing the init of a
    1:      * for statement.
    1:      */
    1:     oldflags = tc->flags;
    1:     tc->flags &= ~TCF_IN_FOR_INIT;
    1:     pn = Expr(cx, ts, tc);
    1:     tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: 
    1: static JSParseNode *
    1: EndBracketedExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = BracketedExpr(cx, ts, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_ATTR_EXPR);
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * From the ECMA-357 grammar in 11.1.1 and 11.1.2:
    1:  *
    1:  *      AttributeIdentifier:
    1:  *              @ PropertySelector
    1:  *              @ QualifiedIdentifier
    1:  *              @ [ Expression ]
    1:  *
    1:  *      PropertySelector:
    1:  *              Identifier
    1:  *              *
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector :: PropertySelector
    1:  *              PropertySelector :: [ Expression ]
    1:  *
    1:  * We adapt AttributeIdentifier and QualifiedIdentier to be LL(1), like so:
    1:  *
    1:  *      AttributeIdentifier:
    1:  *              @ QualifiedIdentifier
    1:  *              @ [ Expression ]
    1:  *
    1:  *      PropertySelector:
    1:  *              Identifier
    1:  *              *
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector :: PropertySelector
    1:  *              PropertySelector :: [ Expression ]
    1:  *              PropertySelector
    1:  *
    1:  * As PrimaryExpression: Identifier is in ECMA-262 and we want the semantics
    1:  * for that rule to result in a name node, but ECMA-357 extends the grammar
    1:  * to include PrimaryExpression: QualifiedIdentifier, we must factor further:
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector QualifiedSuffix
    1:  *
    1:  *      QualifiedSuffix:
    1:  *              :: PropertySelector
    1:  *              :: [ Expression ]
    1:  *              /nothing/
    1:  *
    1:  * And use this production instead of PrimaryExpression: QualifiedIdentifier:
    1:  *
    1:  *      PrimaryExpression:
    1:  *              Identifier QualifiedSuffix
    1:  *
    1:  * We hoist the :: match into callers of QualifiedSuffix, in order to tweak
    1:  * PropertySelector vs. Identifier pn_arity, pn_op, and other members.
    1:  */
    1: static JSParseNode *
    1: PropertySelector(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     if (pn->pn_type == TOK_STAR) {
    1:         pn->pn_type = TOK_ANYNAME;
    1:         pn->pn_op = JSOP_ANYNAME;
    1:         pn->pn_atom = cx->runtime->atomState.starAtom;
    1:     } else {
    1:         JS_ASSERT(pn->pn_type == TOK_NAME);
    1:         pn->pn_op = JSOP_QNAMEPART;
    1:         pn->pn_arity = PN_NAME;
    1:         pn->pn_atom = CURRENT_TOKEN(ts).t_atom;
    1:         pn->pn_slot = -1;
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: QualifiedSuffix(JSContext *cx, JSTokenStream *ts, JSParseNode *pn,
    1:                 JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn2, *pn3;
    1:     JSTokenType tt;
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_DBLCOLON);
    1:     pn2 = NewParseNode(cx, ts, PN_NAME, tc);
    1:     if (!pn2)
    1:         return NULL;
    1: 
    1:     /* Left operand of :: must be evaluated if it is an identifier. */
    1:     if (pn->pn_op == JSOP_QNAMEPART)
    1:         pn->pn_op = JSOP_NAME;
    1: 
    1:     ts->flags |= TSF_KEYWORD_IS_NAME;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:     if (tt == TOK_STAR || tt == TOK_NAME) {
    1:         /* Inline and specialize PropertySelector for JSOP_QNAMECONST. */
    1:         pn2->pn_op = JSOP_QNAMECONST;
    1:         pn2->pn_atom = (tt == TOK_STAR)
    1:                        ? cx->runtime->atomState.starAtom
    1:                        : CURRENT_TOKEN(ts).t_atom;
    1:         pn2->pn_expr = pn;
    1:         pn2->pn_slot = -1;
    1:         return pn2;
    1:     }
    1: 
    1:     if (tt != TOK_LB) {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     pn3 = EndBracketedExpr(cx, ts, tc);
    1:     if (!pn3)
    1:         return NULL;
    1: 
    1:     pn2->pn_op = JSOP_QNAME;
    1:     pn2->pn_arity = PN_BINARY;
    1:     pn2->pn_left = pn;
    1:     pn2->pn_right = pn3;
    1:     return pn2;
    1: }
    1: 
    1: static JSParseNode *
    1: QualifiedIdentifier(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = PropertySelector(cx, ts, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     if (js_MatchToken(cx, ts, TOK_DBLCOLON))
    1:         pn = QualifiedSuffix(cx, ts, pn, tc);
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: AttributeIdentifier(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2;
    1:     JSTokenType tt;
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_AT);
    1:     pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_op = JSOP_TOATTRNAME;
    1:     ts->flags |= TSF_KEYWORD_IS_NAME;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:     if (tt == TOK_STAR || tt == TOK_NAME) {
    1:         pn2 = QualifiedIdentifier(cx, ts, tc);
    1:     } else if (tt == TOK_LB) {
    1:         pn2 = EndBracketedExpr(cx, ts, tc);
    1:     } else {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     if (!pn2)
    1:         return NULL;
    1:     pn->pn_kid = pn2;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Make a TOK_LC unary node whose pn_kid is an expression.
    1:  */
    1: static JSParseNode *
    1: XMLExpr(JSContext *cx, JSTokenStream *ts, JSBool inTag, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2;
    1:     uintN oldflags;
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_LC);
    1:     pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     /*
    1:      * Turn off XML tag mode, but don't restore it after parsing this braced
    1:      * expression.  Instead, simply restore ts's old flags.  This is required
    1:      * because XMLExpr is called both from within a tag, and from within text
    1:      * contained in an element, but outside of any start, end, or point tag.
    1:      */
    1:     oldflags = ts->flags;
    1:     ts->flags = oldflags & ~TSF_XMLTAGMODE;
    1:     pn2 = Expr(cx, ts, tc);
    1:     if (!pn2)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_XML_EXPR);
    1:     ts->flags = oldflags;
    1:     pn->pn_kid = pn2;
    1:     pn->pn_op = inTag ? JSOP_XMLTAGEXPR : JSOP_XMLELTEXPR;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Make a terminal node for one of TOK_XMLNAME, TOK_XMLATTR, TOK_XMLSPACE,
    1:  * TOK_XMLTEXT, TOK_XMLCDATA, TOK_XMLCOMMENT, or TOK_XMLPI.  When converting
    1:  * parse tree to XML, we preserve a TOK_XMLSPACE node only if it's the sole
    1:  * child of a container tag.
    1:  */
    1: static JSParseNode *
    1: XMLAtomNode(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSToken *tp;
    1: 
    1:     pn = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     tp = &CURRENT_TOKEN(ts);
    1:     pn->pn_op = tp->t_op;
    1:     pn->pn_atom = tp->t_atom;
    1:     if (tp->type == TOK_XMLPI)
    1:         pn->pn_atom2 = tp->t_atom2;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Parse the productions:
    1:  *
    1:  *      XMLNameExpr:
    1:  *              XMLName XMLNameExpr?
    1:  *              { Expr } XMLNameExpr?
    1:  *
    1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according as XMLNameExpr produces
    1:  * a list of names and/or expressions, a single expression, or a single name.
    1:  * If PN_LIST or PN_NULLARY, pn_type will be TOK_XMLNAME; if PN_UNARY, pn_type
    1:  * will be TOK_LC.
    1:  */
    1: static JSParseNode *
    1: XMLNameExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2, *list;
    1:     JSTokenType tt;
    1: 
    1:     pn = list = NULL;
    1:     do {
    1:         tt = CURRENT_TOKEN(ts).type;
    1:         if (tt == TOK_LC) {
    1:             pn2 = XMLExpr(cx, ts, JS_TRUE, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:         } else {
    1:             JS_ASSERT(tt == TOK_XMLNAME);
    1:             pn2 = XMLAtomNode(cx, ts, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:         }
    1: 
    1:         if (!pn) {
    1:             pn = pn2;
    1:         } else {
    1:             if (!list) {
    1:                 list = NewParseNode(cx, ts, PN_LIST, tc);
    1:                 if (!list)
    1:                     return NULL;
    1:                 list->pn_type = TOK_XMLNAME;
    1:                 list->pn_pos.begin = pn->pn_pos.begin;
    1:                 PN_INIT_LIST_1(list, pn);
    1:                 list->pn_extra = PNX_CANTFOLD;
    1:                 pn = list;
    1:             }
    1:             pn->pn_pos.end = pn2->pn_pos.end;
    1:             PN_APPEND(pn, pn2);
    1:         }
    1:     } while ((tt = js_GetToken(cx, ts)) == TOK_XMLNAME || tt == TOK_LC);
    1: 
    1:     js_UngetToken(ts);
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Macro to test whether an XMLNameExpr or XMLTagContent node can be folded
    1:  * at compile time into a JSXML tree.
    1:  */
    1: #define XML_FOLDABLE(pn)        ((pn)->pn_arity == PN_LIST                    \
    1:                                  ? ((pn)->pn_extra & PNX_CANTFOLD) == 0       \
    1:                                  : (pn)->pn_type != TOK_LC)
    1: 
    1: /*
    1:  * Parse the productions:
    1:  *
    1:  *      XMLTagContent:
    1:  *              XMLNameExpr
    1:  *              XMLTagContent S XMLNameExpr S? = S? XMLAttr
    1:  *              XMLTagContent S XMLNameExpr S? = S? { Expr }
    1:  *
    1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according to how XMLTagContent
    1:  * produces a list of name and attribute values and/or braced expressions, a
    1:  * single expression, or a single name.
    1:  *
    1:  * If PN_LIST or PN_NULLARY, pn_type will be TOK_XMLNAME for the case where
    1:  * XMLTagContent: XMLNameExpr.  If pn_type is not TOK_XMLNAME but pn_arity is
    1:  * PN_LIST, pn_type will be tagtype.  If PN_UNARY, pn_type will be TOK_LC and
    1:  * we parsed exactly one expression.
    1:  */
    1: static JSParseNode *
    1: XMLTagContent(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:               JSTokenType tagtype, JSAtom **namep)
    1: {
    1:     JSParseNode *pn, *pn2, *list;
    1:     JSTokenType tt;
    1: 
    1:     pn = XMLNameExpr(cx, ts, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     *namep = (pn->pn_arity == PN_NULLARY) ? pn->pn_atom : NULL;
    1:     list = NULL;
    1: 
    1:     while (js_MatchToken(cx, ts, TOK_XMLSPACE)) {
    1:         tt = js_GetToken(cx, ts);
    1:         if (tt != TOK_XMLNAME && tt != TOK_LC) {
    1:             js_UngetToken(ts);
    1:             break;
    1:         }
    1: 
    1:         pn2 = XMLNameExpr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         if (!list) {
    1:             list = NewParseNode(cx, ts, PN_LIST, tc);
    1:             if (!list)
    1:                 return NULL;
    1:             list->pn_type = tagtype;
    1:             list->pn_pos.begin = pn->pn_pos.begin;
    1:             PN_INIT_LIST_1(list, pn);
    1:             pn = list;
    1:         }
    1:         PN_APPEND(pn, pn2);
    1:         if (!XML_FOLDABLE(pn2))
    1:             pn->pn_extra |= PNX_CANTFOLD;
    1: 
    1:         js_MatchToken(cx, ts, TOK_XMLSPACE);
    1:         MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_NO_ASSIGN_IN_XML_ATTR);
    1:         js_MatchToken(cx, ts, TOK_XMLSPACE);
    1: 
    1:         tt = js_GetToken(cx, ts);
    1:         if (tt == TOK_XMLATTR) {
    1:             pn2 = XMLAtomNode(cx, ts, tc);
    1:         } else if (tt == TOK_LC) {
    1:             pn2 = XMLExpr(cx, ts, JS_TRUE, tc);
    1:             pn->pn_extra |= PNX_CANTFOLD;
    1:         } else {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_BAD_XML_ATTR_VALUE);
    1:             return NULL;
    1:         }
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         PN_APPEND(pn, pn2);
    1:     }
    1: 
    1:     return pn;
    1: }
    1: 
    1: #define XML_CHECK_FOR_ERROR_AND_EOF(tt,result)                                \
    1:     JS_BEGIN_MACRO                                                            \
    1:         if ((tt) <= TOK_EOF) {                                                \
    1:             if ((tt) == TOK_EOF) {                                            \
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,     \
    1:                                             JSMSG_END_OF_XML_SOURCE);         \
    1:             }                                                                 \
    1:             return result;                                                    \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
    1: static JSParseNode *
    1: XMLElementOrList(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:                  JSBool allowList);
    1: 
    1: /*
    1:  * Consume XML element tag content, including the TOK_XMLETAGO (</) sequence
    1:  * that opens the end tag for the container.
    1:  */
    1: static JSBool
    1: XMLElementContent(JSContext *cx, JSTokenStream *ts, JSParseNode *pn,
    1:                   JSTreeContext *tc)
    1: {
    1:     JSTokenType tt;
    1:     JSParseNode *pn2;
    1:     JSAtom *textAtom;
    1: 
    1:     ts->flags &= ~TSF_XMLTAGMODE;
    1:     for (;;) {
    1:         ts->flags |= TSF_XMLTEXTMODE;
    1:         tt = js_GetToken(cx, ts);
    1:         ts->flags &= ~TSF_XMLTEXTMODE;
    1:         XML_CHECK_FOR_ERROR_AND_EOF(tt, JS_FALSE);
    1: 
    1:         JS_ASSERT(tt == TOK_XMLSPACE || tt == TOK_XMLTEXT);
    1:         textAtom = CURRENT_TOKEN(ts).t_atom;
    1:         if (textAtom) {
    1:             /* Non-zero-length XML text scanned. */
    1:             pn2 = XMLAtomNode(cx, ts, tc);
    1:             if (!pn2)
    1:                 return JS_FALSE;
    1:             pn->pn_pos.end = pn2->pn_pos.end;
    1:             PN_APPEND(pn, pn2);
    1:         }
    1: 
    1:         ts->flags |= TSF_OPERAND;
    1:         tt = js_GetToken(cx, ts);
    1:         ts->flags &= ~TSF_OPERAND;
    1:         XML_CHECK_FOR_ERROR_AND_EOF(tt, JS_FALSE);
    1:         if (tt == TOK_XMLETAGO)
    1:             break;
    1: 
    1:         if (tt == TOK_LC) {
    1:             pn2 = XMLExpr(cx, ts, JS_FALSE, tc);
    1:             pn->pn_extra |= PNX_CANTFOLD;
    1:         } else if (tt == TOK_XMLSTAGO) {
    1:             pn2 = XMLElementOrList(cx, ts, tc, JS_FALSE);
    1:             if (pn2) {
    1:                 pn2->pn_extra &= ~PNX_XMLROOT;
    1:                 pn->pn_extra |= pn2->pn_extra;
    1:             }
    1:         } else {
    1:             JS_ASSERT(tt == TOK_XMLCDATA || tt == TOK_XMLCOMMENT ||
    1:                       tt == TOK_XMLPI);
    1:             pn2 = XMLAtomNode(cx, ts, tc);
    1:         }
    1:         if (!pn2)
    1:             return JS_FALSE;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         PN_APPEND(pn, pn2);
    1:     }
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_XMLETAGO);
    1:     ts->flags |= TSF_XMLTAGMODE;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Return a PN_LIST node containing an XML or XMLList Initialiser.
    1:  */
    1: static JSParseNode *
    1: XMLElementOrList(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:                  JSBool allowList)
    1: {
    1:     JSParseNode *pn, *pn2, *list;
    1:     JSTokenType tt;
    1:     JSAtom *startAtom, *endAtom;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_XMLSTAGO);
    1:     pn = NewParseNode(cx, ts, PN_LIST, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     ts->flags |= TSF_XMLTAGMODE;
    1:     tt = js_GetToken(cx, ts);
    1:     if (tt == TOK_ERROR)
    1:         return NULL;
    1: 
    1:     if (tt == TOK_XMLNAME || tt == TOK_LC) {
    1:         /*
    1:          * XMLElement.  Append the tag and its contents, if any, to pn.
    1:          */
    1:         pn2 = XMLTagContent(cx, ts, tc, TOK_XMLSTAGO, &startAtom);
    1:         if (!pn2)
    1:             return NULL;
    1:         js_MatchToken(cx, ts, TOK_XMLSPACE);
    1: 
    1:         tt = js_GetToken(cx, ts);
    1:         if (tt == TOK_XMLPTAGC) {
    1:             /* Point tag (/>): recycle pn if pn2 is a list of tag contents. */
    1:             if (pn2->pn_type == TOK_XMLSTAGO) {
    1:                 PN_INIT_LIST(pn);
    1:                 RecycleTree(pn, tc);
    1:                 pn = pn2;
    1:             } else {
    1:                 JS_ASSERT(pn2->pn_type == TOK_XMLNAME ||
    1:                           pn2->pn_type == TOK_LC);
    1:                 PN_INIT_LIST_1(pn, pn2);
    1:                 if (!XML_FOLDABLE(pn2))
    1:                     pn->pn_extra |= PNX_CANTFOLD;
    1:             }
    1:             pn->pn_type = TOK_XMLPTAGC;
    1:             pn->pn_extra |= PNX_XMLROOT;
    1:         } else {
    1:             /* We had better have a tag-close (>) at this point. */
    1:             if (tt != TOK_XMLTAGC) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1:             pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1: 
    1:             /* Make sure pn2 is a TOK_XMLSTAGO list containing tag contents. */
    1:             if (pn2->pn_type != TOK_XMLSTAGO) {
    1:                 PN_INIT_LIST_1(pn, pn2);
    1:                 if (!XML_FOLDABLE(pn2))
    1:                     pn->pn_extra |= PNX_CANTFOLD;
    1:                 pn2 = pn;
    1:                 pn = NewParseNode(cx, ts, PN_LIST, tc);
    1:                 if (!pn)
    1:                     return NULL;
    1:             }
    1: 
    1:             /* Now make pn a nominal-root TOK_XMLELEM list containing pn2. */
    1:             pn->pn_type = TOK_XMLELEM;
    1:             PN_INIT_LIST_1(pn, pn2);
    1:             if (!XML_FOLDABLE(pn2))
    1:                 pn->pn_extra |= PNX_CANTFOLD;
    1:             pn->pn_extra |= PNX_XMLROOT;
    1: 
    1:             /* Get element contents and delimiting end-tag-open sequence. */
    1:             if (!XMLElementContent(cx, ts, pn, tc))
    1:                 return NULL;
    1: 
    1:             tt = js_GetToken(cx, ts);
    1:             XML_CHECK_FOR_ERROR_AND_EOF(tt, NULL);
    1:             if (tt != TOK_XMLNAME && tt != TOK_LC) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1: 
    1:             /* Parse end tag; check mismatch at compile-time if we can. */
    1:             pn2 = XMLTagContent(cx, ts, tc, TOK_XMLETAGO, &endAtom);
    1:             if (!pn2)
    1:                 return NULL;
    1:             if (pn2->pn_type == TOK_XMLETAGO) {
    1:                 /* Oops, end tag has attributes! */
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1:             if (endAtom && startAtom && endAtom != startAtom) {
    1:                 JSString *str = ATOM_TO_STRING(startAtom);
    1: 
    1:                 /* End vs. start tag name mismatch: point to the tag name. */
 7984:                 js_ReportCompileErrorNumber(cx, ts, pn2,
 7984:                                             JSREPORT_UC | JSREPORT_ERROR,
    1:                                             JSMSG_XML_TAG_NAME_MISMATCH,
    1:                                             JSSTRING_CHARS(str));
    1:                 return NULL;
    1:             }
    1: 
    1:             /* Make a TOK_XMLETAGO list with pn2 as its single child. */
    1:             JS_ASSERT(pn2->pn_type == TOK_XMLNAME || pn2->pn_type == TOK_LC);
    1:             list = NewParseNode(cx, ts, PN_LIST, tc);
    1:             if (!list)
    1:                 return NULL;
    1:             list->pn_type = TOK_XMLETAGO;
    1:             PN_INIT_LIST_1(list, pn2);
    1:             PN_APPEND(pn, list);
    1:             if (!XML_FOLDABLE(pn2)) {
    1:                 list->pn_extra |= PNX_CANTFOLD;
    1:                 pn->pn_extra |= PNX_CANTFOLD;
    1:             }
    1: 
    1:             js_MatchToken(cx, ts, TOK_XMLSPACE);
    1:             MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_TAG_SYNTAX);
    1:         }
    1: 
    1:         /* Set pn_op now that pn has been updated to its final value. */
    1:         pn->pn_op = JSOP_TOXML;
    1:     } else if (allowList && tt == TOK_XMLTAGC) {
    1:         /* XMLList Initialiser. */
    1:         pn->pn_type = TOK_XMLLIST;
    1:         pn->pn_op = JSOP_TOXMLLIST;
    1:         PN_INIT_LIST(pn);
    1:         pn->pn_extra |= PNX_XMLROOT;
    1:         if (!XMLElementContent(cx, ts, pn, tc))
    1:             return NULL;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_LIST_SYNTAX);
    1:     } else {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_XML_NAME_SYNTAX);
    1:         return NULL;
    1:     }
    1: 
    1:     pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:     ts->flags &= ~TSF_XMLTAGMODE;
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: XMLElementOrListRoot(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:                      JSBool allowList)
    1: {
    1:     uint32 oldopts;
    1:     JSParseNode *pn;
    1: 
    1:     /*
    1:      * Force XML support to be enabled so that comments and CDATA literals
    1:      * are recognized, instead of <! followed by -- starting an HTML comment
    1:      * to end of line (used in script tags to hide content from old browsers
    1:      * that don't recognize <script>).
    1:      */
    1:     oldopts = JS_SetOptions(cx, cx->options | JSOPTION_XML);
    1:     pn = XMLElementOrList(cx, ts, tc, allowList);
    1:     JS_SetOptions(cx, oldopts);
    1:     return pn;
    1: }
    1: 
    1: JS_FRIEND_API(JSParseNode *)
 6561: js_ParseXMLText(JSContext *cx, JSObject *chain, JSParseContext *pc,
    1:                 JSBool allowList)
    1: {
    1:     JSParseNode *pn;
    1:     JSTreeContext tc;
    1:     JSTokenType tt;
    1: 
    1:     /*
    1:      * Push a compiler frame if we have no frames, or if the top frame is a
    1:      * lightweight function activation, or if its scope chain doesn't match
    1:      * the one passed to us.
    1:      */
 6561:     TREE_CONTEXT_INIT(&tc, pc);
18955:     tc.u.scopeChain = chain;
    1: 
    1:     /* Set XML-only mode to turn off special treatment of {expr} in XML. */
 6561:     TS(pc)->flags |= TSF_OPERAND | TSF_XMLONLYMODE;
 6561:     tt = js_GetToken(cx, TS(pc));
 6561:     TS(pc)->flags &= ~TSF_OPERAND;
    1: 
    1:     if (tt != TOK_XMLSTAGO) {
 7984:         js_ReportCompileErrorNumber(cx, TS(pc), NULL, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_XML_MARKUP);
    1:         pn = NULL;
    1:     } else {
 6561:         pn = XMLElementOrListRoot(cx, TS(pc), &tc, allowList);
 6561:     }
 6561: 
 6561:     TS(pc)->flags &= ~TSF_XMLONLYMODE;
16072:     TREE_CONTEXT_FINISH(cx, &tc);
    1:     return pn;
    1: }
    1: 
    1: #endif /* JS_HAS_XMLSUPPORT */
    1: 
    1: static JSParseNode *
    1: PrimaryExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:             JSTokenType tt, JSBool afterDot)
    1: {
    1:     JSParseNode *pn, *pn2, *pn3;
    1:     JSOp op;
    1: #if JS_HAS_SHARP_VARS
    1:     JSParseNode *defsharp;
    1:     JSBool notsharp;
11139: #endif
11139: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
11139: 
11139: #if JS_HAS_SHARP_VARS
    1:     defsharp = NULL;
    1:     notsharp = JS_FALSE;
    1:   again:
    1:     /*
    1:      * Control flows here after #n= is scanned.  If the following primary is
    1:      * not valid after such a "sharp variable" definition, the tt switch case
    1:      * should set notsharp.
    1:      */
    1: #endif
    1: 
    1: #if JS_HAS_GETTER_SETTER
    1:     if (tt == TOK_NAME) {
    1:         tt = CheckGetterOrSetter(cx, ts, TOK_FUNCTION);
    1:         if (tt == TOK_ERROR)
    1:             return NULL;
    1:     }
    1: #endif
    1: 
    1:     switch (tt) {
    1:       case TOK_FUNCTION:
    1: #if JS_HAS_XML_SUPPORT
    1:         ts->flags |= TSF_KEYWORD_IS_NAME;
    1:         if (js_MatchToken(cx, ts, TOK_DBLCOLON)) {
    1:             ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:             pn2 = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_type = TOK_FUNCTION;
    1:             pn = QualifiedSuffix(cx, ts, pn2, tc);
    1:             if (!pn)
    1:                 return NULL;
    1:             break;
    1:         }
    1:         ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1: #endif
    1:         pn = FunctionExpr(cx, ts, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_LB:
    1:       {
    1:         JSBool matched;
    1:         jsuint index;
    1: 
    1:         pn = NewParseNode(cx, ts, PN_LIST, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_RB;
20902:         pn->pn_op = JSOP_NEWINIT;
    1: 
    1: #if JS_HAS_SHARP_VARS
    1:         if (defsharp) {
    1:             PN_INIT_LIST_1(pn, defsharp);
    1:             defsharp = NULL;
    1:         } else
    1: #endif
    1:             PN_INIT_LIST(pn);
    1: 
    1:         ts->flags |= TSF_OPERAND;
    1:         matched = js_MatchToken(cx, ts, TOK_RB);
    1:         ts->flags &= ~TSF_OPERAND;
    1:         if (!matched) {
    1:             for (index = 0; ; index++) {
    1:                 if (index == ARRAY_INIT_LIMIT) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_ARRAY_INIT_TOO_BIG);
    1:                     return NULL;
    1:                 }
    1: 
    1:                 ts->flags |= TSF_OPERAND;
    1:                 tt = js_PeekToken(cx, ts);
    1:                 ts->flags &= ~TSF_OPERAND;
    1:                 if (tt == TOK_RB) {
    1:                     pn->pn_extra |= PNX_ENDCOMMA;
    1:                     break;
    1:                 }
    1: 
    1:                 if (tt == TOK_COMMA) {
    1:                     /* So CURRENT_TOKEN gets TOK_COMMA and not TOK_LB. */
    1:                     js_MatchToken(cx, ts, TOK_COMMA);
    1:                     pn2 = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:                 } else {
    1:                     pn2 = AssignExpr(cx, ts, tc);
    1:                 }
    1:                 if (!pn2)
    1:                     return NULL;
    1:                 PN_APPEND(pn, pn2);
    1: 
    1:                 if (tt != TOK_COMMA) {
    1:                     /* If we didn't already match TOK_COMMA in above case. */
    1:                     if (!js_MatchToken(cx, ts, TOK_COMMA))
    1:                         break;
    1:                 }
    1:             }
    1: 
    1: #if JS_HAS_GENERATORS
    1:             /*
    1:              * At this point, (index == 0 && pn->pn_count != 0) implies one
    1:              * element initialiser was parsed (possibly with a defsharp before
    1:              * the left bracket).
    1:              *
    1:              * An array comprehension of the form:
    1:              *
    1:              *   [i * j for (i in o) for (j in p) if (i != j)]
    1:              *
    1:              * translates to roughly the following let expression:
    1:              *
    1:              *   let (array = new Array, i, j) {
    1:              *     for (i in o) let {
    1:              *       for (j in p)
    1:              *         if (i != j)
    1:              *           array.push(i * j)
    1:              *     }
    1:              *     array
    1:              *   }
    1:              *
    1:              * where array is a nameless block-local variable.  The "roughly"
    1:              * means that an implementation may optimize away the array.push.
    1:              * An array comprehension opens exactly one block scope, no matter
    1:              * how many for heads it contains.
    1:              *
    1:              * Each let () {...} or for (let ...) ... compiles to:
    1:              *
    1:              *   JSOP_ENTERBLOCK <o> ... JSOP_LEAVEBLOCK <n>
    1:              *
    1:              * where <o> is a literal object representing the block scope,
    1:              * with <n> properties, naming each var declared in the block.
    1:              *
    1:              * Each var declaration in a let-block binds a name in <o> at
    1:              * compile time, and allocates a slot on the operand stack at
    1:              * runtime via JSOP_ENTERBLOCK.  A block-local var is accessed
    1:              * by the JSOP_GETLOCAL and JSOP_SETLOCAL ops, and iterated with
    1:              * JSOP_FORLOCAL.  These ops all have an immediate operand, the
    1:              * local slot's stack index from fp->spbase.
    1:              *
    1:              * The array comprehension iteration step, array.push(i * j) in
    1:              * the example above, is done by <i * j>; JSOP_ARRAYCOMP <array>,
    1:              * where <array> is the index of array's stack slot.
    1:              */
    1:             if (index == 0 &&
    1:                 pn->pn_count != 0 &&
    1:                 js_MatchToken(cx, ts, TOK_FOR)) {
 1577:                 JSParseNode *pnexp, *pntop;
    1: 
    1:                 /* Relabel pn as an array comprehension node. */
    1:                 pn->pn_type = TOK_ARRAYCOMP;
    1: 
    1:                 /*
    1:                  * Remove the comprehension expression from pn's linked list
    1:                  * and save it via pnexp.  We'll re-install it underneath the
    1:                  * ARRAYPUSH node after we parse the rest of the comprehension.
    1:                  */
    1:                 pnexp = PN_LAST(pn);
    1:                 JS_ASSERT(pn->pn_count == 1 || pn->pn_count == 2);
    1:                 pn->pn_tail = (--pn->pn_count == 1)
    1:                               ? &pn->pn_head->pn_next
    1:                               : &pn->pn_head;
    1:                 *pn->pn_tail = NULL;
    1: 
 1577:                 pntop = ComprehensionTail(cx, ts, tc, TOK_ARRAYPUSH,
 1577:                                           JSOP_ARRAYPUSH, pnexp);
    1:                 if (!pntop)
    1:                     return NULL;
    1:                 PN_APPEND(pn, pntop);
    1:             }
    1: #endif /* JS_HAS_GENERATORS */
    1: 
    1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_LIST);
    1:         }
    1:         pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_LC:
    1:       {
    1:         JSBool afterComma;
11039:         JSParseNode *pnval;
    1: 
    1:         pn = NewParseNode(cx, ts, PN_LIST, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_RC;
20902:         pn->pn_op = JSOP_NEWINIT;
    1: 
    1: #if JS_HAS_SHARP_VARS
    1:         if (defsharp) {
    1:             PN_INIT_LIST_1(pn, defsharp);
    1:             defsharp = NULL;
    1:         } else
    1: #endif
    1:             PN_INIT_LIST(pn);
    1: 
    1:         afterComma = JS_FALSE;
    1:         for (;;) {
    1:             ts->flags |= TSF_KEYWORD_IS_NAME;
    1:             tt = js_GetToken(cx, ts);
    1:             ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:             switch (tt) {
    1:               case TOK_NUMBER:
    1:                 pn3 = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:                 if (pn3)
    1:                     pn3->pn_dval = CURRENT_TOKEN(ts).t_dval;
    1:                 break;
    1:               case TOK_NAME:
    1: #if JS_HAS_GETTER_SETTER
    1:                 {
    1:                     JSAtom *atom;
    1: 
    1:                     atom = CURRENT_TOKEN(ts).t_atom;
 1478:                     if (atom == cx->runtime->atomState.getAtom)
 1478:                         op = JSOP_GETTER;
 1478:                     else if (atom == cx->runtime->atomState.setAtom)
 1478:                         op = JSOP_SETTER;
 1478:                     else
 1478:                         goto property_name;
 1478: 
 1478:                     ts->flags |= TSF_KEYWORD_IS_NAME;
 1478:                     tt = js_GetToken(cx, ts);
 1478:                     ts->flags &= ~TSF_KEYWORD_IS_NAME;
 1478:                     if (tt != TOK_NAME) {
 1478:                         js_UngetToken(ts);
 1478:                         goto property_name;
 1478:                     }
    1:                     pn3 = NewParseNode(cx, ts, PN_NAME, tc);
    1:                     if (!pn3)
    1:                         return NULL;
    1:                     pn3->pn_atom = CURRENT_TOKEN(ts).t_atom;
    1:                     pn3->pn_slot = -1;
    1: 
    1:                     /* We have to fake a 'function' token here. */
    1:                     CURRENT_TOKEN(ts).t_op = JSOP_NOP;
    1:                     CURRENT_TOKEN(ts).type = TOK_FUNCTION;
    1:                     pn2 = FunctionExpr(cx, ts, tc);
    1:                     pn2 = NewBinary(cx, TOK_COLON, op, pn3, pn2, tc);
    1:                     goto skip;
    1:                 }
 1478:               property_name:
    1: #endif
    1:               case TOK_STRING:
    1:                 pn3 = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:                 if (pn3)
    1:                     pn3->pn_atom = CURRENT_TOKEN(ts).t_atom;
    1:                 break;
    1:               case TOK_RC:
    1:                 if (afterComma &&
 7984:                     !js_ReportCompileErrorNumber(cx, ts, NULL,
    1:                                                  JSREPORT_WARNING |
    1:                                                  JSREPORT_STRICT,
    1:                                                  JSMSG_TRAILING_COMMA)) {
    1:                         return NULL;
    1:                 }
    1:                 goto end_obj_init;
    1:               default:
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_PROP_ID);
    1:                 return NULL;
    1:             }
    1: 
    1:             tt = js_GetToken(cx, ts);
    1: #if JS_HAS_GETTER_SETTER
    1:             if (tt == TOK_NAME) {
    1:                 tt = CheckGetterOrSetter(cx, ts, TOK_COLON);
    1:                 if (tt == TOK_ERROR)
    1:                     return NULL;
    1:             }
    1: #endif
11039: 
    1:             if (tt != TOK_COLON) {
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:                 if (tt != TOK_COMMA && tt != TOK_RC) {
11039: #endif
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_COLON_AFTER_ID);
    1:                     return NULL;
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:                 }
11039: 
11039:                 /*
11039:                  * Support, e.g., |var {x, y} = o| as destructuring shorthand
11039:                  * for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.
11039:                  */
11039:                 js_UngetToken(ts);
11039:                 pn->pn_extra |= PNX_SHORTHAND;
11039:                 pnval = pn3;
11039:                 if (pnval->pn_type == TOK_NAME) {
11039:                     pnval->pn_arity = PN_NAME;
11039:                     pnval->pn_expr = NULL;
11039:                     pnval->pn_slot = -1;
11039:                     pnval->pn_const = JS_FALSE;
11039:                 }
11039:                 op = JSOP_NOP;
11039: #endif
11039:             } else {
    1:                 op = CURRENT_TOKEN(ts).t_op;
11039:                 pnval = AssignExpr(cx, ts, tc);
11039:             }
11039: 
11039:             pn2 = NewBinary(cx, TOK_COLON, op, pn3, pnval, tc);
    1: #if JS_HAS_GETTER_SETTER
    1:           skip:
    1: #endif
    1:             if (!pn2)
    1:                 return NULL;
    1:             PN_APPEND(pn, pn2);
    1: 
    1:             tt = js_GetToken(cx, ts);
    1:             if (tt == TOK_RC)
    1:                 goto end_obj_init;
    1:             if (tt != TOK_COMMA) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_CURLY_AFTER_LIST);
    1:                 return NULL;
    1:             }
    1:             afterComma = JS_TRUE;
    1:         }
 1967: 
    1:       end_obj_init:
    1:         pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         return pn;
    1:       }
    1: 
 1967: #if JS_HAS_BLOCK_SCOPE
 1967:       case TOK_LET:
 1967:         pn = LetBlock(cx, ts, tc, JS_FALSE);
 1967:         if (!pn)
 1967:             return NULL;
 1967:         break;
 1967: #endif
 1967: 
    1: #if JS_HAS_SHARP_VARS
    1:       case TOK_DEFSHARP:
    1:         if (defsharp)
    1:             goto badsharp;
    1:         defsharp = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!defsharp)
    1:             return NULL;
    1:         defsharp->pn_num = (jsint) CURRENT_TOKEN(ts).t_dval;
    1:         ts->flags |= TSF_OPERAND;
    1:         tt = js_GetToken(cx, ts);
    1:         ts->flags &= ~TSF_OPERAND;
    1:         goto again;
    1: 
    1:       case TOK_USESHARP:
    1:         /* Check for forward/dangling references at runtime, to allow eval. */
    1:         pn = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_num = (jsint) CURRENT_TOKEN(ts).t_dval;
    1:         notsharp = JS_TRUE;
    1:         break;
    1: #endif /* JS_HAS_SHARP_VARS */
    1: 
    1:       case TOK_LP:
 1577:       {
 1577:         JSBool genexp;
 1577: 
    1:         pn = NewParseNode(cx, ts, PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
 1577:         pn2 = ParenExpr(cx, ts, tc, pn, &genexp);
    1:         if (!pn2)
    1:             return NULL;
 1577:         if (genexp)
 1577:             return pn2;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_IN_PAREN);
    1:         if (pn2->pn_type == TOK_RP ||
    1:             (js_CodeSpec[pn2->pn_op].prec >= js_CodeSpec[JSOP_GETPROP].prec &&
    1:              !afterDot)) {
    1:             /*
    1:              * Avoid redundant JSOP_GROUP opcodes, for efficiency and mainly
    1:              * to help the decompiler look ahead from a JSOP_ENDINIT to see a
    1:              * JSOP_GROUP followed by a POP or POPV.  That sequence means the
    1:              * parentheses are mandatory, to disambiguate object initialisers
    1:              * as expression statements from block statements.
    1:              *
    1:              * Also drop pn if pn2 is a member or a primary expression of any
    1:              * kind.  This is required to avoid generating a JSOP_GROUP that
    1:              * will null the |obj| interpreter register, causing |this| in any
    1:              * call of that member expression to bind to the global object.
    1:              */
    1:             RecycleTree(pn, tc);
    1:             pn = pn2;
    1:         } else {
    1:             pn->pn_type = TOK_RP;
 7991:             pn->pn_kid = pn2;
 7991:         }
    1:         pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         break;
 1577:       }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_STAR:
    1:         pn = QualifiedIdentifier(cx, ts, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         notsharp = JS_TRUE;
    1:         break;
    1: 
    1:       case TOK_AT:
    1:         pn = AttributeIdentifier(cx, ts, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         notsharp = JS_TRUE;
    1:         break;
    1: 
    1:       case TOK_XMLSTAGO:
    1:         pn = XMLElementOrListRoot(cx, ts, tc, JS_TRUE);
    1:         if (!pn)
    1:             return NULL;
    1:         notsharp = JS_TRUE;     /* XXXbe could be sharp? */
    1:         break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:       case TOK_STRING:
    1: #if JS_HAS_SHARP_VARS
    1:         notsharp = JS_TRUE;
    1:         /* FALL THROUGH */
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_XMLCDATA:
    1:       case TOK_XMLCOMMENT:
    1:       case TOK_XMLPI:
    1: #endif
    1:       case TOK_NAME:
    1:         pn = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_atom = CURRENT_TOKEN(ts).t_atom;
    1: #if JS_HAS_XML_SUPPORT
    1:         if (tt == TOK_XMLPI)
    1:             pn->pn_atom2 = CURRENT_TOKEN(ts).t_atom2;
    1:         else
    1: #endif
    1:             pn->pn_op = CURRENT_TOKEN(ts).t_op;
    1:         if (tt == TOK_NAME) {
    1:             pn->pn_arity = PN_NAME;
    1:             pn->pn_slot = -1;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:             if (js_MatchToken(cx, ts, TOK_DBLCOLON)) {
    1:                 if (afterDot) {
    1:                     JSString *str;
    1: 
    1:                     /*
    1:                      * Here PrimaryExpr is called after '.' or '..' and we
    1:                      * just scanned .name:: or ..name:: . This is the only
    1:                      * case where a keyword after '.' or '..' is not
    1:                      * treated as a property name.
    1:                      */
    1:                     str = ATOM_TO_STRING(pn->pn_atom);
    1:                     tt = js_CheckKeyword(JSSTRING_CHARS(str),
    1:                                          JSSTRING_LENGTH(str));
    1:                     if (tt == TOK_FUNCTION) {
    1:                         pn->pn_arity = PN_NULLARY;
    1:                         pn->pn_type = TOK_FUNCTION;
    1:                     } else if (tt != TOK_EOF) {
    1:                         js_ReportCompileErrorNumber(
 7984:                             cx, ts, NULL, JSREPORT_ERROR,
    1:                             JSMSG_KEYWORD_NOT_NS);
    1:                         return NULL;
    1:                     }
    1:                 }
    1:                 pn = QualifiedSuffix(cx, ts, pn, tc);
    1:                 if (!pn)
    1:                     return NULL;
    1:                 break;
    1:             }
    1: #endif
    1: 
    1:             /* Unqualified __parent__ and __proto__ uses require activations. */
    1:             if (pn->pn_atom == cx->runtime->atomState.parentAtom ||
    1:                 pn->pn_atom == cx->runtime->atomState.protoAtom) {
    1:                 tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:             }
    1:         }
    1:         break;
    1: 
 6561:       case TOK_REGEXP:
 6561:       {
 6561:         JSObject *obj;
 6561: 
 6561:         pn = NewParseNode(cx, ts, PN_NULLARY, tc);
 6561:         if (!pn)
 6561:             return NULL;
 6561: 
 6561:         /* Token stream ensures that tokenbuf is NUL-terminated. */
 6561:         JS_ASSERT(*ts->tokenbuf.ptr == (jschar) 0);
 6561:         obj = js_NewRegExpObject(cx, ts,
 6561:                                  ts->tokenbuf.base,
 6561:                                  ts->tokenbuf.ptr - ts->tokenbuf.base,
 6561:                                  CURRENT_TOKEN(ts).t_reflags);
 6561:         if (!obj)
 6561:             return NULL;
 9481:         if (!(tc->flags & TCF_COMPILE_N_GO)) {
16069:             STOBJ_CLEAR_PARENT(obj);
16069:             STOBJ_CLEAR_PROTO(obj);
 9481:         }
 6561: 
 6561:         pn->pn_pob = js_NewParsedObjectBox(cx, tc->parseContext, obj);
 6561:         if (!pn->pn_pob)
 6561:             return NULL;
 6561: 
 6561:         pn->pn_op = JSOP_REGEXP;
 6561:         break;
 6561:       }
 6561: 
    1:       case TOK_NUMBER:
    1:         pn = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
20902:         pn->pn_op = JSOP_DOUBLE;
    1:         pn->pn_dval = CURRENT_TOKEN(ts).t_dval;
    1: #if JS_HAS_SHARP_VARS
    1:         notsharp = JS_TRUE;
    1: #endif
    1:         break;
    1: 
    1:       case TOK_PRIMARY:
    1:         pn = NewParseNode(cx, ts, PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_op = CURRENT_TOKEN(ts).t_op;
    1: #if JS_HAS_SHARP_VARS
    1:         notsharp = JS_TRUE;
    1: #endif
    1:         break;
    1: 
    1:       case TOK_ERROR:
    1:         /* The scanner or one of its subroutines reported the error. */
    1:         return NULL;
    1: 
    1:       default:
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1: 
    1: #if JS_HAS_SHARP_VARS
    1:     if (defsharp) {
    1:         if (notsharp) {
    1:   badsharp:
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_BAD_SHARP_VAR_DEF);
    1:             return NULL;
    1:         }
    1:         defsharp->pn_kid = pn;
    1:         return defsharp;
    1:     }
    1: #endif
    1:     return pn;
    1: }
    1: 
 1577: static JSParseNode *
 1577: ParenExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
 1577:           JSParseNode *pn1, JSBool *genexp)
 1577: {
 1577:     JSTokenPtr begin;
 1577:     JSParseNode *pn;
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577:     uintN oldflags = tc->flags;
 1577: #endif
 1577: 
 1577:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_LP);
 1577:     begin = CURRENT_TOKEN(ts).pos.begin;
 1577: 
 1577:     if (genexp)
 1577:         *genexp = JS_FALSE;
 1577:     pn = BracketedExpr(cx, ts, tc);
 1577:     if (!pn)
 1577:         return NULL;
 1577: 
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577:     if (js_MatchToken(cx, ts, TOK_FOR)) {
 1577:         if (pn->pn_type == TOK_YIELD) {
 7984:             js_ReportCompileErrorNumber(cx, ts, pn, JSREPORT_ERROR,
 1577:                                         JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                         js_yield_str);
 1577:             return NULL;
 1577:         }
 1577:         if (pn->pn_type == TOK_COMMA) {
 7984:             js_ReportCompileErrorNumber(cx, ts, PN_LAST(pn), JSREPORT_ERROR,
 1577:                                         JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                         js_generator_str);
 1577:             return NULL;
 1577:         }
 1577:         if (!pn1) {
 1577:             pn1 = NewParseNode(cx, ts, PN_UNARY, tc);
 1577:             if (!pn1)
 1577:                 return NULL;
 1577:         }
 1577:         pn->pn_pos.begin = begin;
 1577:         pn = GeneratorExpr(cx, ts, tc, oldflags, pn1, pn);
 1577:         if (!pn)
 1577:             return NULL;
 1577:         if (genexp) {
 1577:             if (js_GetToken(cx, ts) != TOK_RP) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
 1577:                                             JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                             js_generator_str);
 1577:                 return NULL;
 1577:             }
 1577:             pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
 1577:             *genexp = JS_TRUE;
 1577:         }
 1577:     }
 1577: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577: 
 1577:     return pn;
 1577: }
 1577: 
    1: /*
    1:  * Fold from one constant type to another.
    1:  * XXX handles only strings and numbers for now
    1:  */
    1: static JSBool
    1: FoldType(JSContext *cx, JSParseNode *pn, JSTokenType type)
    1: {
    1:     if (pn->pn_type != type) {
    1:         switch (type) {
    1:           case TOK_NUMBER:
    1:             if (pn->pn_type == TOK_STRING) {
    1:                 jsdouble d;
12694:                 if (!JS_ValueToNumber(cx, ATOM_KEY(pn->pn_atom), &d))
    1:                     return JS_FALSE;
    1:                 pn->pn_dval = d;
    1:                 pn->pn_type = TOK_NUMBER;
 3328:                 pn->pn_op = JSOP_DOUBLE;
    1:             }
    1:             break;
    1: 
    1:           case TOK_STRING:
    1:             if (pn->pn_type == TOK_NUMBER) {
    1:                 JSString *str = js_NumberToString(cx, pn->pn_dval);
    1:                 if (!str)
    1:                     return JS_FALSE;
    1:                 pn->pn_atom = js_AtomizeString(cx, str, 0);
    1:                 if (!pn->pn_atom)
    1:                     return JS_FALSE;
    1:                 pn->pn_type = TOK_STRING;
    1:                 pn->pn_op = JSOP_STRING;
    1:             }
    1:             break;
    1: 
    1:           default:;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Fold two numeric constants.  Beware that pn1 and pn2 are recycled, unless
    1:  * one of them aliases pn, so you can't safely fetch pn2->pn_next, e.g., after
    1:  * a successful call to this function.
    1:  */
    1: static JSBool
    1: FoldBinaryNumeric(JSContext *cx, JSOp op, JSParseNode *pn1, JSParseNode *pn2,
    1:                   JSParseNode *pn, JSTreeContext *tc)
    1: {
    1:     jsdouble d, d2;
    1:     int32 i, j;
    1: 
    1:     JS_ASSERT(pn1->pn_type == TOK_NUMBER && pn2->pn_type == TOK_NUMBER);
    1:     d = pn1->pn_dval;
    1:     d2 = pn2->pn_dval;
    1:     switch (op) {
    1:       case JSOP_LSH:
    1:       case JSOP_RSH:
 9613:         i = js_DoubleToECMAInt32(d);
 9613:         j = js_DoubleToECMAInt32(d2);
    1:         j &= 31;
    1:         d = (op == JSOP_LSH) ? i << j : i >> j;
    1:         break;
    1: 
    1:       case JSOP_URSH:
 9613:         j = js_DoubleToECMAInt32(d2);
    1:         j &= 31;
 9613:         d = js_DoubleToECMAUint32(d) >> j;
    1:         break;
    1: 
    1:       case JSOP_ADD:
    1:         d += d2;
    1:         break;
    1: 
    1:       case JSOP_SUB:
    1:         d -= d2;
    1:         break;
    1: 
    1:       case JSOP_MUL:
    1:         d *= d2;
    1:         break;
    1: 
    1:       case JSOP_DIV:
    1:         if (d2 == 0) {
    1: #if defined(XP_WIN)
    1:             /* XXX MSVC miscompiles such that (NaN == 0) */
    1:             if (JSDOUBLE_IS_NaN(d2))
    1:                 d = *cx->runtime->jsNaN;
    1:             else
    1: #endif
    1:             if (d == 0 || JSDOUBLE_IS_NaN(d))
    1:                 d = *cx->runtime->jsNaN;
    1:             else if ((JSDOUBLE_HI32(d) ^ JSDOUBLE_HI32(d2)) >> 31)
    1:                 d = *cx->runtime->jsNegativeInfinity;
    1:             else
    1:                 d = *cx->runtime->jsPositiveInfinity;
    1:         } else {
    1:             d /= d2;
    1:         }
    1:         break;
    1: 
    1:       case JSOP_MOD:
    1:         if (d2 == 0) {
    1:             d = *cx->runtime->jsNaN;
    1:         } else {
    1: #if defined(XP_WIN)
    1:           /* Workaround MS fmod bug where 42 % (1/0) => NaN, not 42. */
    1:           if (!(JSDOUBLE_IS_FINITE(d) && JSDOUBLE_IS_INFINITE(d2)))
    1: #endif
    1:             d = fmod(d, d2);
    1:         }
    1:         break;
    1: 
    1:       default:;
    1:     }
    1: 
    1:     /* Take care to allow pn1 or pn2 to alias pn. */
    1:     if (pn1 != pn)
    1:         RecycleTree(pn1, tc);
    1:     if (pn2 != pn)
    1:         RecycleTree(pn2, tc);
    1:     pn->pn_type = TOK_NUMBER;
 3328:     pn->pn_op = JSOP_DOUBLE;
    1:     pn->pn_arity = PN_NULLARY;
    1:     pn->pn_dval = d;
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: 
    1: static JSBool
    1: FoldXMLConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc)
    1: {
    1:     JSTokenType tt;
    1:     JSParseNode **pnp, *pn1, *pn2;
    1:     JSString *accum, *str;
    1:     uint32 i, j;
12677:     JSTempValueRooter tvr;
    1: 
    1:     JS_ASSERT(pn->pn_arity == PN_LIST);
 3164:     tt = PN_TYPE(pn);
    1:     pnp = &pn->pn_head;
    1:     pn1 = *pnp;
    1:     accum = NULL;
    1:     if ((pn->pn_extra & PNX_CANTFOLD) == 0) {
    1:         if (tt == TOK_XMLETAGO)
    1:             accum = ATOM_TO_STRING(cx->runtime->atomState.etagoAtom);
    1:         else if (tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC)
    1:             accum = ATOM_TO_STRING(cx->runtime->atomState.stagoAtom);
    1:     }
    1: 
12677:     /*
12677:      * GC Rooting here is tricky: for most of the loop, |accum| is safe via
12677:      * the newborn string root. However, when |pn2->pn_type| is TOK_XMLCDATA,
12677:      * TOK_XMLCOMMENT, or TOK_XMLPI it is knocked out of the newborn root.
12677:      * Therefore, we have to add additonal protection from GC nesting under
12677:      * js_ConcatStrings.
12677:      */
    1:     for (pn2 = pn1, i = j = 0; pn2; pn2 = pn2->pn_next, i++) {
    1:         /* The parser already rejected end-tags with attributes. */
    1:         JS_ASSERT(tt != TOK_XMLETAGO || i == 0);
    1:         switch (pn2->pn_type) {
    1:           case TOK_XMLATTR:
    1:             if (!accum)
    1:                 goto cantfold;
    1:             /* FALL THROUGH */
    1:           case TOK_XMLNAME:
    1:           case TOK_XMLSPACE:
    1:           case TOK_XMLTEXT:
    1:           case TOK_STRING:
    1:             if (pn2->pn_arity == PN_LIST)
    1:                 goto cantfold;
    1:             str = ATOM_TO_STRING(pn2->pn_atom);
    1:             break;
    1: 
    1:           case TOK_XMLCDATA:
    1:             str = js_MakeXMLCDATAString(cx, ATOM_TO_STRING(pn2->pn_atom));
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case TOK_XMLCOMMENT:
    1:             str = js_MakeXMLCommentString(cx, ATOM_TO_STRING(pn2->pn_atom));
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case TOK_XMLPI:
    1:             str = js_MakeXMLPIString(cx, ATOM_TO_STRING(pn2->pn_atom),
    1:                                          ATOM_TO_STRING(pn2->pn_atom2));
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           cantfold:
    1:           default:
    1:             JS_ASSERT(*pnp == pn1);
    1:             if ((tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC) &&
    1:                 (i & 1) ^ (j & 1)) {
    1: #ifdef DEBUG_brendanXXX
    1:                 printf("1: %d, %d => ", i, j);
    1:                 if (accum)
    1:                     js_FileEscapedString(stdout, accum, 0);
    1:                 else
    1:                     fputs("NULL", stdout);
    1:                 fputc('\n', stdout);
    1: #endif
    1:             } else if (accum && pn1 != pn2) {
    1:                 while (pn1->pn_next != pn2) {
    1:                     pn1 = RecycleTree(pn1, tc);
    1:                     --pn->pn_count;
    1:                 }
    1:                 pn1->pn_type = TOK_XMLTEXT;
    1:                 pn1->pn_op = JSOP_STRING;
    1:                 pn1->pn_arity = PN_NULLARY;
    1:                 pn1->pn_atom = js_AtomizeString(cx, accum, 0);
    1:                 if (!pn1->pn_atom)
    1:                     return JS_FALSE;
    1:                 JS_ASSERT(pnp != &pn1->pn_next);
    1:                 *pnp = pn1;
    1:             }
    1:             pnp = &pn2->pn_next;
    1:             pn1 = *pnp;
    1:             accum = NULL;
    1:             continue;
    1:         }
    1: 
    1:         if (accum) {
12677:             JS_PUSH_TEMP_ROOT_STRING(cx, accum, &tvr);
    1:             str = ((tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC) && i != 0)
    1:                   ? js_AddAttributePart(cx, i & 1, accum, str)
    1:                   : js_ConcatStrings(cx, accum, str);
12677:             JS_POP_TEMP_ROOT(cx, &tvr);
    1:             if (!str)
    1:                 return JS_FALSE;
    1: #ifdef DEBUG_brendanXXX
    1:             printf("2: %d, %d => ", i, j);
    1:             js_FileEscapedString(stdout, str, 0);
    1:             printf(" (%u)\n", JSSTRING_LENGTH(str));
    1: #endif
    1:             ++j;
    1:         }
    1:         accum = str;
    1:     }
    1: 
    1:     if (accum) {
    1:         str = NULL;
    1:         if ((pn->pn_extra & PNX_CANTFOLD) == 0) {
    1:             if (tt == TOK_XMLPTAGC)
    1:                 str = ATOM_TO_STRING(cx->runtime->atomState.ptagcAtom);
    1:             else if (tt == TOK_XMLSTAGO || tt == TOK_XMLETAGO)
    1:                 str = ATOM_TO_STRING(cx->runtime->atomState.tagcAtom);
    1:         }
    1:         if (str) {
    1:             accum = js_ConcatStrings(cx, accum, str);
    1:             if (!accum)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         JS_ASSERT(*pnp == pn1);
    1:         while (pn1->pn_next) {
    1:             pn1 = RecycleTree(pn1, tc);
    1:             --pn->pn_count;
    1:         }
    1:         pn1->pn_type = TOK_XMLTEXT;
    1:         pn1->pn_op = JSOP_STRING;
    1:         pn1->pn_arity = PN_NULLARY;
    1:         pn1->pn_atom = js_AtomizeString(cx, accum, 0);
    1:         if (!pn1->pn_atom)
    1:             return JS_FALSE;
    1:         JS_ASSERT(pnp != &pn1->pn_next);
    1:         *pnp = pn1;
    1:     }
    1: 
    1:     if (pn1 && pn->pn_count == 1) {
    1:         /*
    1:          * Only one node under pn, and it has been folded: move pn1 onto pn
    1:          * unless pn is an XML root (in which case we need it to tell the code
    1:          * generator to emit a JSOP_TOXML or JSOP_TOXMLLIST op).  If pn is an
    1:          * XML root *and* it's a point-tag, rewrite it to TOK_XMLELEM to avoid
    1:          * extra "<" and "/>" bracketing at runtime.
    1:          */
    1:         if (!(pn->pn_extra & PNX_XMLROOT)) {
    1:             PN_MOVE_NODE(pn, pn1);
    1:         } else if (tt == TOK_XMLPTAGC) {
    1:             pn->pn_type = TOK_XMLELEM;
    1:             pn->pn_op = JSOP_TOXML;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1: static JSBool
    1: StartsWith(JSParseNode *pn, JSTokenType tt)
    1: {
    1: #define TAIL_RECURSE(pn2) JS_BEGIN_MACRO pn = (pn2); goto recur; JS_END_MACRO
    1: 
    1: recur:
    1:     if (pn->pn_type == tt)
    1:         return JS_TRUE;
    1:     switch (pn->pn_arity) {
    1:       case PN_FUNC:
    1:         return  tt == TOK_FUNCTION;
    1:       case PN_LIST:
    1:         if (pn->pn_head)
    1:             TAIL_RECURSE(pn->pn_head);
    1:         break;
    1:       case PN_TERNARY:
    1:         if (pn->pn_kid1)
    1:             TAIL_RECURSE(pn->pn_kid1);
    1:         break;
    1:       case PN_BINARY:
    1:         if (pn->pn_left)
    1:             TAIL_RECURSE(pn->pn_left);
    1:         break;
    1:       case PN_UNARY:
    1:         /* A parenthesized expression starts with a left parenthesis. */
    1:         if (pn->pn_type == TOK_RP)
    1:             return tt == TOK_LP;
    1:         if (pn->pn_kid)
    1:             TAIL_RECURSE(pn->pn_kid);
    1:         break;
    1:       case PN_NAME:
    1:         if (pn->pn_type == TOK_DOT || pn->pn_type == TOK_DBLDOT)
    1:             TAIL_RECURSE(pn->pn_expr);
    1:         /* FALL THROUGH */
    1:     }
    1:     return JS_FALSE;
    1: #undef TAIL_RECURSE
    1: }
    1: 
20902: static int
20902: Boolish(JSParseNode *pn)
20902: {
20902:     switch (pn->pn_op) {
20902:       case JSOP_DOUBLE:
20918:         return pn->pn_dval != 0 && !JSDOUBLE_IS_NaN(pn->pn_dval);
20902: 
20902:       case JSOP_STRING:
20902:         return JSSTRING_LENGTH(ATOM_TO_STRING(pn->pn_atom)) != 0;
20902: 
20906: #if JS_HAS_GENERATOR_EXPRS
20902:       case JSOP_CALL:
20904:       {
20902:         /*
20902:          * A generator expression as an if or loop condition has no effects, it
20902:          * simply results in a truthy object reference. This condition folding
20903:          * is needed for the decompiler. See bug 442342 and bug 443074.
20902:          */
20902:         if (pn->pn_count != 1)
20902:             break;
20902:         JSParseNode *pn2 = pn->pn_head;
20902:         if (pn2->pn_type != TOK_FUNCTION)
20902:             break;
20902:         if (!(pn2->pn_flags & TCF_GENEXP_LAMBDA))
20902:             break;
20902:         /* FALL THROUGH */
20904:       }
20906: #endif
20902: 
20902:       case JSOP_DEFFUN:
20902:       case JSOP_NAMEDFUNOBJ:
20902:       case JSOP_ANONFUNOBJ:
20902:       case JSOP_THIS:
20902:       case JSOP_TRUE:
20902:         return 1;
20902: 
20902:       case JSOP_NULL:
20902:       case JSOP_FALSE:
20902:         return 0;
20902: 
20902:       default:;
20902:     }
20902:     return -1;
20902: }
20902: 
    1: JSBool
20902: js_FoldConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, bool inCond)
    1: {
    1:     JSParseNode *pn1 = NULL, *pn2 = NULL, *pn3 = NULL;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
    1:     switch (pn->pn_arity) {
    1:       case PN_FUNC:
    1:       {
    1:         uint16 oldflags = tc->flags;
    1: 
    1:         tc->flags = (uint16) pn->pn_flags;
    1:         if (!js_FoldConstants(cx, pn->pn_body, tc))
    1:             return JS_FALSE;
    1:         tc->flags = oldflags;
    1:         break;
    1:       }
    1: 
    1:       case PN_LIST:
21457:       {
21457:         /* Propagate inCond through logical connectives. */
21457:         bool cond = inCond && (pn->pn_type == TOK_OR || pn->pn_type == TOK_AND);
21457: 
    1:         /* Save the list head in pn1 for later use. */
    1:         for (pn1 = pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
21457:             if (!js_FoldConstants(cx, pn2, tc, cond))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
21457:       }
    1: 
    1:       case PN_TERNARY:
    1:         /* Any kid may be null (e.g. for (;;)). */
    1:         pn1 = pn->pn_kid1;
    1:         pn2 = pn->pn_kid2;
    1:         pn3 = pn->pn_kid3;
20902:         if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_type == TOK_IF))
    1:             return JS_FALSE;
20902:         if (pn2) {
20902:             if (!js_FoldConstants(cx, pn2, tc, pn->pn_type == TOK_FORHEAD))
    1:                 return JS_FALSE;
20902:             if (pn->pn_type == TOK_FORHEAD && pn2->pn_op == JSOP_TRUE) {
20902:                 RecycleTree(pn2, tc);
20902:                 pn->pn_kid2 = NULL;
20902:             }
20902:         }
    1:         if (pn3 && !js_FoldConstants(cx, pn3, tc))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_BINARY:
    1:         pn1 = pn->pn_left;
    1:         pn2 = pn->pn_right;
20902: 
20902:         /* Propagate inCond through logical connectives. */
20909:         if (pn->pn_type == TOK_OR || pn->pn_type == TOK_AND) {
20902:             if (!js_FoldConstants(cx, pn1, tc, inCond))
    1:                 return JS_FALSE;
20902:             if (!js_FoldConstants(cx, pn2, tc, inCond))
20902:                 return JS_FALSE;
20902:             break;
20902:         }
20902: 
20902:         /* First kid may be null (for default case in switch). */
20902:         if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_type == TOK_WHILE))
20902:             return JS_FALSE;
20902:         if (!js_FoldConstants(cx, pn2, tc, pn->pn_type == TOK_DO))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_UNARY:
    1:         /* Our kid may be null (e.g. return; vs. return e;). */
    1:         pn1 = pn->pn_kid;
20910:         if (pn1 &&
20910:             !js_FoldConstants(cx, pn1, tc,
20910:                               (inCond && pn->pn_type == TOK_RP) ||
20910:                               pn->pn_op == JSOP_NOT)) {
    1:             return JS_FALSE;
20910:         }
    1:         break;
    1: 
    1:       case PN_NAME:
    1:         /*
    1:          * Skip pn1 down along a chain of dotted member expressions to avoid
    1:          * excessive recursion.  Our only goal here is to fold constants (if
    1:          * any) in the primary expression operand to the left of the first
    1:          * dot in the chain.
    1:          */
    1:         pn1 = pn->pn_expr;
    1:         while (pn1 && pn1->pn_arity == PN_NAME)
    1:             pn1 = pn1->pn_expr;
    1:         if (pn1 && !js_FoldConstants(cx, pn1, tc))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_NULLARY:
    1:         break;
    1:     }
    1: 
    1:     switch (pn->pn_type) {
    1:       case TOK_IF:
    1:         if (ContainsStmt(pn2, TOK_VAR) || ContainsStmt(pn3, TOK_VAR))
    1:             break;
    1:         /* FALL THROUGH */
    1: 
    1:       case TOK_HOOK:
    1:         /* Reduce 'if (C) T; else E' into T for true C, E for false. */
    1:         while (pn1->pn_type == TOK_RP)
    1:             pn1 = pn1->pn_kid;
    1:         switch (pn1->pn_type) {
    1:           case TOK_NUMBER:
  207:             if (pn1->pn_dval == 0 || JSDOUBLE_IS_NaN(pn1->pn_dval))
    1:                 pn2 = pn3;
    1:             break;
    1:           case TOK_STRING:
    1:             if (JSSTRING_LENGTH(ATOM_TO_STRING(pn1->pn_atom)) == 0)
    1:                 pn2 = pn3;
    1:             break;
    1:           case TOK_PRIMARY:
    1:             if (pn1->pn_op == JSOP_TRUE)
    1:                 break;
    1:             if (pn1->pn_op == JSOP_FALSE || pn1->pn_op == JSOP_NULL) {
    1:                 pn2 = pn3;
    1:                 break;
    1:             }
    1:             /* FALL THROUGH */
    1:           default:
    1:             /* Early return to dodge common code that copies pn2 to pn. */
    1:             return JS_TRUE;
    1:         }
    1: 
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577:         /* Don't fold a trailing |if (0)| in a generator expression. */
 1577:         if (!pn2 && (tc->flags & TCF_GENEXP_LAMBDA))
 1577:             break;
 1577: #endif
 1577: 
    1:         if (pn2) {
    1:             /*
    1:              * pn2 is the then- or else-statement subtree to compile.  Take
    1:              * care not to expose an object initialiser, which would be parsed
    1:              * as a block, to the Statement parser via eval(uneval(e)) where e
    1:              * is '1 ? {p:2, q:3}[i] : r;' or the like.
    1:              */
    1:             if (pn->pn_type == TOK_HOOK && StartsWith(pn2, TOK_RC)) {
    1:                 pn->pn_type = TOK_RP;
    1:                 pn->pn_arity = PN_UNARY;
    1:                 pn->pn_kid = pn2;
14190:                 if (pn3 && pn3 != pn2)
14190:                     RecycleTree(pn3, tc);
14190:                 break;
14190:             }
    1:             PN_MOVE_NODE(pn, pn2);
    1:         }
    1:         if (!pn2 || (pn->pn_type == TOK_SEMI && !pn->pn_kid)) {
    1:             /*
    1:              * False condition and no else, or an empty then-statement was
    1:              * moved up over pn.  Either way, make pn an empty block (not an
    1:              * empty statement, which does not decompile, even when labeled).
    1:              * NB: pn must be a TOK_IF as TOK_HOOK can never have a null kid
    1:              * or an empty statement for a child.
    1:              */
    1:             pn->pn_type = TOK_LC;
    1:             pn->pn_arity = PN_LIST;
    1:             PN_INIT_LIST(pn);
    1:         }
    1:         RecycleTree(pn2, tc);
    1:         if (pn3 && pn3 != pn2)
    1:             RecycleTree(pn3, tc);
    1:         break;
    1: 
20902:       case TOK_OR:
20905:       case TOK_AND:
20902:         if (inCond) {
20905:             if (pn->pn_arity == PN_LIST) {
20905:                 JSParseNode **pnp = &pn->pn_head;
20905:                 JS_ASSERT(*pnp == pn1);
20905:                 do {
20905:                     int cond = Boolish(pn1);
20905:                     if (cond == (pn->pn_type == TOK_OR)) {
20905:                         for (pn2 = pn1->pn_next; pn2; pn2 = pn3) {
20905:                             pn3 = pn2->pn_next;
20905:                             RecycleTree(pn2, tc);
20905:                             --pn->pn_count;
20905:                         }
20905:                         pn1->pn_next = NULL;
20905:                         break;
20905:                     }
20905:                     if (cond != -1) {
20905:                         JS_ASSERT(cond == (pn->pn_type == TOK_AND));
20905:                         if (pn->pn_count == 1)
20905:                             break;
20905:                         *pnp = pn1->pn_next;
20905:                         RecycleTree(pn1, tc);
20905:                         --pn->pn_count;
20905:                     } else {
20905:                         pnp = &pn1->pn_next;
20905:                     }
20905:                 } while ((pn1 = *pnp) != NULL);
20905: 
20905:                 // We may have to change arity from LIST to BINARY.
20911:                 pn1 = pn->pn_head;
20905:                 if (pn->pn_count == 2) {
20905:                     pn2 = pn1->pn_next;
20905:                     pn1->pn_next = NULL;
20905:                     JS_ASSERT(!pn2->pn_next);
20905:                     pn->pn_arity = PN_BINARY;
20905:                     pn->pn_left = pn1;
20905:                     pn->pn_right = pn2;
20905:                 } else if (pn->pn_count == 1) {
20905:                     PN_MOVE_NODE(pn, pn1);
20905:                     RecycleTree(pn1, tc);
20905:                 }
20905:             } else {
20905:                 int cond = Boolish(pn1);
20905:                 if (cond == (pn->pn_type == TOK_OR)) {
20902:                     RecycleTree(pn2, tc);
20902:                     PN_MOVE_NODE(pn, pn1);
20905:                 } else if (cond != -1) {
20905:                     JS_ASSERT(cond == (pn->pn_type == TOK_AND));
20902:                     RecycleTree(pn1, tc);
20902:                     PN_MOVE_NODE(pn, pn2);
20902:                 }
20902:             }
20902:         }
20902:         break;
20902: 
    1:       case TOK_ASSIGN:
    1:         /*
    1:          * Compound operators such as *= should be subject to folding, in case
    1:          * the left-hand side is constant, and so that the decompiler produces
    1:          * the same string that you get from decompiling a script or function
    1:          * compiled from that same string.  As with +, += is special.
    1:          */
    1:         if (pn->pn_op == JSOP_NOP)
    1:             break;
    1:         if (pn->pn_op != JSOP_ADD)
    1:             goto do_binary_op;
    1:         /* FALL THROUGH */
    1: 
    1:       case TOK_PLUS:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             size_t length, length2;
    1:             jschar *chars;
    1:             JSString *str, *str2;
    1: 
    1:             /*
    1:              * Any string literal term with all others number or string means
    1:              * this is a concatenation.  If any term is not a string or number
    1:              * literal, we can't fold.
    1:              */
    1:             JS_ASSERT(pn->pn_count > 2);
    1:             if (pn->pn_extra & PNX_CANTFOLD)
    1:                 return JS_TRUE;
    1:             if (pn->pn_extra != PNX_STRCAT)
    1:                 goto do_binary_op;
    1: 
    1:             /* Ok, we're concatenating: convert non-string constant operands. */
    1:             length = 0;
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 if (!FoldType(cx, pn2, TOK_STRING))
    1:                     return JS_FALSE;
    1:                 /* XXX fold only if all operands convert to string */
    1:                 if (pn2->pn_type != TOK_STRING)
    1:                     return JS_TRUE;
10444:                 length += JSFLATSTR_LENGTH(ATOM_TO_STRING(pn2->pn_atom));
    1:             }
    1: 
    1:             /* Allocate a new buffer and string descriptor for the result. */
    1:             chars = (jschar *) JS_malloc(cx, (length + 1) * sizeof(jschar));
    1:             if (!chars)
    1:                 return JS_FALSE;
 4718:             str = js_NewString(cx, chars, length);
    1:             if (!str) {
    1:                 JS_free(cx, chars);
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             /* Fill the buffer, advancing chars and recycling kids as we go. */
    1:             for (pn2 = pn1; pn2; pn2 = RecycleTree(pn2, tc)) {
    1:                 str2 = ATOM_TO_STRING(pn2->pn_atom);
10444:                 length2 = JSFLATSTR_LENGTH(str2);
10444:                 js_strncpy(chars, JSFLATSTR_CHARS(str2), length2);
    1:                 chars += length2;
    1:             }
    1:             *chars = 0;
    1: 
    1:             /* Atomize the result string and mutate pn to refer to it. */
    1:             pn->pn_atom = js_AtomizeString(cx, str, 0);
    1:             if (!pn->pn_atom)
    1:                 return JS_FALSE;
    1:             pn->pn_type = TOK_STRING;
    1:             pn->pn_op = JSOP_STRING;
    1:             pn->pn_arity = PN_NULLARY;
    1:             break;
    1:         }
    1: 
    1:         /* Handle a binary string concatenation. */
    1:         JS_ASSERT(pn->pn_arity == PN_BINARY);
    1:         if (pn1->pn_type == TOK_STRING || pn2->pn_type == TOK_STRING) {
    1:             JSString *left, *right, *str;
    1: 
    1:             if (!FoldType(cx, (pn1->pn_type != TOK_STRING) ? pn1 : pn2,
    1:                           TOK_STRING)) {
    1:                 return JS_FALSE;
    1:             }
    1:             if (pn1->pn_type != TOK_STRING || pn2->pn_type != TOK_STRING)
    1:                 return JS_TRUE;
    1:             left = ATOM_TO_STRING(pn1->pn_atom);
    1:             right = ATOM_TO_STRING(pn2->pn_atom);
    1:             str = js_ConcatStrings(cx, left, right);
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             pn->pn_atom = js_AtomizeString(cx, str, 0);
    1:             if (!pn->pn_atom)
    1:                 return JS_FALSE;
    1:             pn->pn_type = TOK_STRING;
    1:             pn->pn_op = JSOP_STRING;
    1:             pn->pn_arity = PN_NULLARY;
    1:             RecycleTree(pn1, tc);
    1:             RecycleTree(pn2, tc);
    1:             break;
    1:         }
    1: 
    1:         /* Can't concatenate string literals, let's try numbers. */
    1:         goto do_binary_op;
    1: 
    1:       case TOK_STAR:
    1:       case TOK_SHOP:
    1:       case TOK_MINUS:
    1:       case TOK_DIVOP:
    1:       do_binary_op:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             JS_ASSERT(pn->pn_count > 2);
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 if (!FoldType(cx, pn2, TOK_NUMBER))
    1:                     return JS_FALSE;
    1:             }
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 /* XXX fold only if all operands convert to number */
    1:                 if (pn2->pn_type != TOK_NUMBER)
    1:                     break;
    1:             }
    1:             if (!pn2) {
 3164:                 JSOp op = PN_OP(pn);
    1: 
    1:                 pn2 = pn1->pn_next;
    1:                 pn3 = pn2->pn_next;
    1:                 if (!FoldBinaryNumeric(cx, op, pn1, pn2, pn, tc))
    1:                     return JS_FALSE;
    1:                 while ((pn2 = pn3) != NULL) {
    1:                     pn3 = pn2->pn_next;
    1:                     if (!FoldBinaryNumeric(cx, op, pn, pn2, pn, tc))
    1:                         return JS_FALSE;
    1:                 }
    1:             }
    1:         } else {
    1:             JS_ASSERT(pn->pn_arity == PN_BINARY);
    1:             if (!FoldType(cx, pn1, TOK_NUMBER) ||
    1:                 !FoldType(cx, pn2, TOK_NUMBER)) {
    1:                 return JS_FALSE;
    1:             }
    1:             if (pn1->pn_type == TOK_NUMBER && pn2->pn_type == TOK_NUMBER) {
 3164:                 if (!FoldBinaryNumeric(cx, PN_OP(pn), pn1, pn2, pn, tc))
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1: 
    1:       case TOK_UNARYOP:
    1:         while (pn1->pn_type == TOK_RP)
    1:             pn1 = pn1->pn_kid;
    1:         if (pn1->pn_type == TOK_NUMBER) {
    1:             jsdouble d;
    1: 
    1:             /* Operate on one numeric constant. */
    1:             d = pn1->pn_dval;
    1:             switch (pn->pn_op) {
    1:               case JSOP_BITNOT:
 9613:                 d = ~js_DoubleToECMAInt32(d);
    1:                 break;
    1: 
    1:               case JSOP_NEG:
    1: #ifdef HPUX
    1:                 /*
    1:                  * Negation of a zero doesn't produce a negative
    1:                  * zero on HPUX. Perform the operation by bit
    1:                  * twiddling.
    1:                  */
    1:                 JSDOUBLE_HI32(d) ^= JSDOUBLE_HI32_SIGNBIT;
    1: #else
    1:                 d = -d;
    1: #endif
    1:                 break;
    1: 
    1:               case JSOP_POS:
    1:                 break;
    1: 
    1:               case JSOP_NOT:
    1:                 pn->pn_type = TOK_PRIMARY;
  207:                 pn->pn_op = (d == 0 || JSDOUBLE_IS_NaN(d)) ? JSOP_TRUE : JSOP_FALSE;
    1:                 pn->pn_arity = PN_NULLARY;
    1:                 /* FALL THROUGH */
    1: 
    1:               default:
    1:                 /* Return early to dodge the common TOK_NUMBER code. */
    1:                 return JS_TRUE;
    1:             }
    1:             pn->pn_type = TOK_NUMBER;
 3328:             pn->pn_op = JSOP_DOUBLE;
    1:             pn->pn_arity = PN_NULLARY;
    1:             pn->pn_dval = d;
    1:             RecycleTree(pn1, tc);
20918:         } else if (pn1->pn_type == TOK_PRIMARY) {
20918:             if (pn->pn_op == JSOP_NOT &&
20918:                 (pn1->pn_op == JSOP_TRUE ||
20918:                  pn1->pn_op == JSOP_FALSE)) {
20918:                 PN_MOVE_NODE(pn, pn1);
20918:                 pn->pn_op = (pn->pn_op == JSOP_TRUE) ? JSOP_FALSE : JSOP_TRUE;
20918:                 RecycleTree(pn1, tc);
20918:             }
    1:         }
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_XMLELEM:
    1:       case TOK_XMLLIST:
    1:       case TOK_XMLPTAGC:
    1:       case TOK_XMLSTAGO:
    1:       case TOK_XMLETAGO:
    1:       case TOK_XMLNAME:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             JS_ASSERT(pn->pn_type == TOK_XMLLIST || pn->pn_count != 0);
    1:             if (!FoldXMLConstants(cx, pn, tc))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
    1: 
    1:       case TOK_AT:
    1:         if (pn1->pn_type == TOK_XMLNAME) {
    1:             jsval v;
 3235:             JSParsedObjectBox *xmlpob;
    1: 
    1:             v = ATOM_KEY(pn1->pn_atom);
    1:             if (!js_ToAttributeName(cx, &v))
    1:                 return JS_FALSE;
    1:             JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));
 3235: 
 3235:             xmlpob = js_NewParsedObjectBox(cx, tc->parseContext,
 3235:                                            JSVAL_TO_OBJECT(v));
 3235:             if (!xmlpob)
    1:                 return JS_FALSE;
    1: 
    1:             pn->pn_type = TOK_XMLNAME;
    1:             pn->pn_op = JSOP_OBJECT;
    1:             pn->pn_arity = PN_NULLARY;
 3235:             pn->pn_pob = xmlpob;
    1:             RecycleTree(pn1, tc);
    1:         }
    1:         break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:       default:;
    1:     }
    1: 
20902:     if (inCond) {
20902:         int cond = Boolish(pn);
20902:         if (cond >= 0) {
20902:             if (pn->pn_arity == PN_LIST) {
20902:                 pn2 = pn->pn_head;
20902:                 do {
20902:                     pn3 = pn2->pn_next;
20902:                     RecycleTree(pn2, tc);
20902:                 } while ((pn2 = pn3) != NULL);
20902:             }
20902:             pn->pn_type = TOK_PRIMARY;
20902:             pn->pn_op = cond ? JSOP_TRUE : JSOP_FALSE;
20902:             pn->pn_arity = PN_NULLARY;
20902:         }
20902:     }
20902: 
    1:     return JS_TRUE;
    1: }
