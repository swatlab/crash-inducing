   1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Mozilla Communicator client code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: //
   1: // Eric Vaughan
   1: // Netscape Communications
   1: //
   1: // See documentation in associated header file
   1: //
   1: 
   1: #include "nsLeafBoxFrame.h"
   1: #include "nsBoxFrame.h"
   1: #include "nsCOMPtr.h"
   1: #include "nsIDeviceContext.h"
   1: #include "nsIFontMetrics.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsPresContext.h"
   1: #include "nsIRenderingContext.h"
   1: #include "nsStyleContext.h"
   1: #include "nsIContent.h"
   1: #include "nsINameSpaceManager.h"
   1: #include "nsBoxLayoutState.h"
   1: #include "nsWidgetsCID.h"
   1: #include "nsIViewManager.h"
   1: #include "nsHTMLContainerFrame.h"
   1: #include "nsDisplayList.h"
   1: 
   1: static NS_DEFINE_IID(kWidgetCID, NS_CHILD_CID);
   1: 
   1: //
   1: // NS_NewLeafBoxFrame
   1: //
   1: // Creates a new Toolbar frame and returns it
   1: //
   1: nsIFrame*
   1: NS_NewLeafBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: {
   1:   return new (aPresShell) nsLeafBoxFrame(aPresShell, aContext);
   1: } // NS_NewLeafBoxFrame
   1: 
   1: nsLeafBoxFrame::nsLeafBoxFrame(nsIPresShell* aShell, nsStyleContext* aContext)
1406:     : nsLeafFrame(aContext)
   1: {
   1:     mState |= NS_FRAME_IS_BOX;
   1: }
   1: 
   1: #ifdef DEBUG_LAYOUT
   1: void
   1: nsLeafBoxFrame::GetBoxName(nsAutoString& aName)
   1: {
   1:    GetFrameName(aName);
   1: }
   1: #endif
   1: 
   1: 
   1: /**
   1:  * Initialize us. This is a good time to get the alignment of the box
   1:  */
   1: NS_IMETHODIMP
   1: nsLeafBoxFrame::Init(
   1:               nsIContent*      aContent,
   1:               nsIFrame*        aParent,
   1:               nsIFrame*        aPrevInFlow)
   1: {
   1:   nsresult  rv = nsLeafFrame::Init(aContent, aParent, aPrevInFlow);
1412:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:    // see if we need a widget
   1:   if (aParent && aParent->IsBoxFrame()) {
   1:     if (aParent->ChildrenMustHaveWidgets()) {
1412:         rv = nsHTMLContainerFrame::CreateViewForFrame(this, nsnull, PR_TRUE); 
1412:         NS_ENSURE_SUCCESS(rv, rv);
1412: 
   1:         nsIView* view = GetView();
   1:         if (!view->HasWidget())
   1:            view->CreateWidget(kWidgetCID);   
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsLeafBoxFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
   1:                                  const nsRect&           aDirtyRect,
   1:                                  const nsDisplayListSet& aLists)
   1: {
   1:   // REVIEW: GetFrameForPoint used to not report events for the background
   1:   // layer, whereas this code will put an event receiver for this frame in the
   1:   // BlockBorderBackground() list. But I don't see any need to preserve
   1:   // that anomalous behaviour. The important thing I'm preserving is that
   1:   // leaf boxes continue to receive events in the foreground layer.
   1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (!aBuilder->IsForEventDelivery() || !IsVisibleForPainting(aBuilder))
   1:     return NS_OK;
   1: 
   1:   return aLists.Content()->AppendNewToTop(new (aBuilder)
   1:       nsDisplayEventReceiver(this));
   1: }
   1: 
   1: /* virtual */ nscoord
   1: nsLeafBoxFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
   1: {
   1:   nscoord result;
   1:   DISPLAY_MIN_WIDTH(this, result);
 238:   nsBoxLayoutState state(PresContext(), aRenderingContext);
   1:   nsSize minSize = GetMinSize(state);
   1: 
   1:   // GetMinSize returns border-box width, and we want to return content
   1:   // width.  Since Reflow uses the reflow state's border and padding, we
   1:   // actually just want to subtract what GetMinSize added, which is the
   1:   // result of GetBorderAndPadding.
   1:   nsMargin bp;
   1:   GetBorderAndPadding(bp);
   1: 
   1:   result = minSize.width - bp.LeftRight();
   1: 
   1:   return result;
   1: }
   1: 
   1: /* virtual */ nscoord
   1: nsLeafBoxFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
   1: {
   1:   nscoord result;
   1:   DISPLAY_PREF_WIDTH(this, result);
 238:   nsBoxLayoutState state(PresContext(), aRenderingContext);
   1:   nsSize prefSize = GetPrefSize(state);
   1: 
   1:   // GetPrefSize returns border-box width, and we want to return content
   1:   // width.  Since Reflow uses the reflow state's border and padding, we
   1:   // actually just want to subtract what GetPrefSize added, which is the
   1:   // result of GetBorderAndPadding.
   1:   nsMargin bp;
   1:   GetBorderAndPadding(bp);
   1: 
   1:   result = prefSize.width - bp.LeftRight();
   1: 
   1:   return result;
   1: }
   1: 
   1: nscoord
   1: nsLeafBoxFrame::GetIntrinsicWidth()
   1: {
   1:   // No intrinsic width
   1:   return 0;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsLeafBoxFrame::Reflow(nsPresContext*   aPresContext,
   1:                      nsHTMLReflowMetrics&     aDesiredSize,
   1:                      const nsHTMLReflowState& aReflowState,
   1:                      nsReflowStatus&          aStatus)
   1: {
   1:   // This is mostly a copy of nsBoxFrame::Reflow().
   1:   // We aren't able to share an implementation because of the frame
   1:   // class hierarchy.  If you make changes here, please keep
   1:   // nsBoxFrame::Reflow in sync.
   1: 
   1:   DO_GLOBAL_REFLOW_COUNT("nsLeafBoxFrame");
   1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
   1: 
   1:   NS_ASSERTION(aReflowState.ComputedWidth() >=0 && aReflowState.mComputedHeight >= 0, "Computed Size < 0");
   1: 
   1: #ifdef DO_NOISY_REFLOW
   1:   printf("\n-------------Starting LeafBoxFrame Reflow ----------------------------\n");
   1:   printf("%p ** nsLBF::Reflow %d R: ", this, myCounter++);
   1:   switch (aReflowState.reason) {
   1:     case eReflowReason_Initial:
   1:       printf("Ini");break;
   1:     case eReflowReason_Incremental:
   1:       printf("Inc");break;
   1:     case eReflowReason_Resize:
   1:       printf("Rsz");break;
   1:     case eReflowReason_StyleChange:
   1:       printf("Sty");break;
   1:     case eReflowReason_Dirty:
   1:       printf("Drt ");
   1:       break;
   1:     default:printf("<unknown>%d", aReflowState.reason);break;
   1:   }
   1:   
   1:   printSize("AW", aReflowState.availableWidth);
   1:   printSize("AH", aReflowState.availableHeight);
   1:   printSize("CW", aReflowState.ComputedWidth());
   1:   printSize("CH", aReflowState.mComputedHeight);
   1: 
   1:   printf(" *\n");
   1: 
   1: #endif
   1: 
   1:   aStatus = NS_FRAME_COMPLETE;
   1: 
   1:   // create the layout state
   1:   nsBoxLayoutState state(aPresContext, aReflowState.rendContext);
   1: 
   1:   nsSize computedSize(aReflowState.ComputedWidth(),aReflowState.mComputedHeight);
   1: 
   1:   nsMargin m;
   1:   m = aReflowState.mComputedBorderPadding;
   1: 
   1:   //GetBorderAndPadding(m);
   1: 
   1:   // this happens sometimes. So lets handle it gracefully.
   1:   if (aReflowState.mComputedHeight == 0) {
   1:     nsSize minSize = GetMinSize(state);
   1:     computedSize.height = minSize.height - m.top - m.bottom;
   1:   }
   1: 
   1:   nsSize prefSize(0,0);
   1: 
   1:   // if we are told to layout intrinic then get our preferred size.
   1:   if (computedSize.width == NS_INTRINSICSIZE || computedSize.height == NS_INTRINSICSIZE) {
   1:      prefSize = GetPrefSize(state);
   1:      nsSize minSize = GetMinSize(state);
   1:      nsSize maxSize = GetMaxSize(state);
   1:      BoundsCheck(minSize, prefSize, maxSize);
   1:   }
   1: 
   1:   // get our desiredSize
   1:   if (aReflowState.ComputedWidth() == NS_INTRINSICSIZE) {
   1:     computedSize.width = prefSize.width;
   1:   } else {
   1:     computedSize.width += m.left + m.right;
   1:   }
   1: 
   1:   if (aReflowState.mComputedHeight == NS_INTRINSICSIZE) {
   1:     computedSize.height = prefSize.height;
   1:   } else {
   1:     computedSize.height += m.top + m.bottom;
   1:   }
   1: 
   1:   // handle reflow state min and max sizes
   1: 
   1:   if (computedSize.width > aReflowState.mComputedMaxWidth)
   1:     computedSize.width = aReflowState.mComputedMaxWidth;
   1: 
   1:   if (computedSize.height > aReflowState.mComputedMaxHeight)
   1:     computedSize.height = aReflowState.mComputedMaxHeight;
   1: 
   1:   if (computedSize.width < aReflowState.mComputedMinWidth)
   1:     computedSize.width = aReflowState.mComputedMinWidth;
   1: 
   1:   if (computedSize.height < aReflowState.mComputedMinHeight)
   1:     computedSize.height = aReflowState.mComputedMinHeight;
   1: 
   1:   nsRect r(mRect.x, mRect.y, computedSize.width, computedSize.height);
   1: 
   1:   SetBounds(state, r);
   1:  
   1:   // layout our children
   1:   Layout(state);
   1:   
   1:   // ok our child could have gotten bigger. So lets get its bounds
   1:   aDesiredSize.width  = mRect.width;
   1:   aDesiredSize.height = mRect.height;
   1:   aDesiredSize.ascent = GetBoxAscent(state);
   1: 
   1:   // NS_FRAME_OUTSIDE_CHILDREN is set in SetBounds() above
   1:   if (mState & NS_FRAME_OUTSIDE_CHILDREN) {
   1:     nsRect* overflowArea = GetOverflowAreaProperty();
   1:     NS_ASSERTION(overflowArea, "Failed to set overflow area property");
   1:     aDesiredSize.mOverflowArea = *overflowArea;
   1:   } else {
   1:     aDesiredSize.mOverflowArea = nsRect(nsPoint(0, 0), GetSize());
   1:   }
   1: 
   1: #ifdef DO_NOISY_REFLOW
   1:   {
   1:     printf("%p ** nsLBF(done) W:%d H:%d  ", this, aDesiredSize.width, aDesiredSize.height);
   1: 
   1:     if (maxElementWidth) {
   1:       printf("MW:%d\n", *maxElementWidth); 
   1:     } else {
   1:       printf("MW:?\n"); 
   1:     }
   1: 
   1:   }
   1: #endif
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: #ifdef DEBUG
   1: NS_IMETHODIMP
   1: nsLeafBoxFrame::GetFrameName(nsAString& aResult) const
   1: {
   1:   return MakeFrameName(NS_LITERAL_STRING("LeafBox"), aResult);
   1: }
   1: #endif
   1: 
   1: NS_IMETHODIMP_(nsrefcnt) 
   1: nsLeafBoxFrame::AddRef(void)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP_(nsrefcnt)
   1: nsLeafBoxFrame::Release(void)
   1: {
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsLeafBoxFrame::CharacterDataChanged(nsPresContext* aPresContext,
   1:                                      nsIContent*     aChild,
   1:                                      PRBool          aAppend)
   1: {
   1:   MarkIntrinsicWidthsDirty();
   1:   return nsLeafFrame::CharacterDataChanged(aPresContext, aChild, aAppend);
   1: }
   1: 
   1: /* virtual */ nsSize
   1: nsLeafBoxFrame::GetPrefSize(nsBoxLayoutState& aState)
   1: {
   1:     return nsBox::GetPrefSize(aState);
   1: }
   1: 
   1: /* virtual */ nsSize
   1: nsLeafBoxFrame::GetMinSize(nsBoxLayoutState& aState)
   1: {
   1:     return nsBox::GetMinSize(aState);
   1: }
   1: 
   1: /* virtual */ nsSize
   1: nsLeafBoxFrame::GetMaxSize(nsBoxLayoutState& aState)
   1: {
   1:     return nsBox::GetMaxSize(aState);
   1: }
   1: 
   1: /* virtual */ nscoord
   1: nsLeafBoxFrame::GetFlex(nsBoxLayoutState& aState)
   1: {
   1:     return nsBox::GetFlex(aState);
   1: }
   1: 
   1: /* virtual */ nscoord
   1: nsLeafBoxFrame::GetBoxAscent(nsBoxLayoutState& aState)
   1: {
   1:     return nsBox::GetBoxAscent(aState);
   1: }
   1: 
   1: /* virtual */ void
   1: nsLeafBoxFrame::MarkIntrinsicWidthsDirty()
   1: {
   1:   // Don't call base class method, since everything it does is within an
   1:   // IsBoxWrapped check.
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsLeafBoxFrame::DoLayout(nsBoxLayoutState& aState)
   1: {
   1:     return nsBox::DoLayout(aState);
   1: }
   1: 
   1: PRBool
   1: nsLeafBoxFrame::GetWasCollapsed(nsBoxLayoutState& aState)
   1: {
   1:     return nsBox::GetWasCollapsed(aState);
   1: }
   1: 
   1: void
   1: nsLeafBoxFrame::SetWasCollapsed(nsBoxLayoutState& aState, PRBool aWas)
   1: {
   1:     nsBox::SetWasCollapsed(aState, aWas);
   1: }
