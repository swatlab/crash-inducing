 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 18830:  * vim: set ts=8 sw=4 et tw=99:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 93270: /*
 93270:  * JS function support.
 93270:  */
 93270: #include <string.h>
 93270: 
 93270: #include "mozilla/Util.h"
 93270: 
 93270: #include "jstypes.h"
 93270: #include "jsutil.h"
 93270: #include "jsapi.h"
 93270: #include "jsarray.h"
 93270: #include "jsatom.h"
 93270: #include "jsbool.h"
 93270: #include "jscntxt.h"
 94006: #include "jsexn.h"
 93270: #include "jsfun.h"
 93250: #include "jsgc.h"
 93250: #include "jsinterp.h"
 93270: #include "jslock.h"
 93270: #include "jsnum.h"
 93270: #include "jsobj.h"
 93270: #include "jsopcode.h"
 93270: #include "jspropertytree.h"
 93270: #include "jsproxy.h"
 93270: #include "jsscope.h"
 93270: #include "jsscript.h"
 93270: #include "jsstr.h"
 80468: 
 93270: #include "frontend/BytecodeCompiler.h"
 93270: #include "frontend/TokenStream.h"
 97569: #include "gc/Marking.h"
 93270: #include "vm/Debugger.h"
 93250: #include "vm/MethodGuard.h"
 93270: #include "vm/ScopeObject.h"
 94006: #include "vm/Xdr.h"
 80468: 
 93270: #if JS_HAS_GENERATORS
 93270: # include "jsiter.h"
 93270: #endif
 93270: 
 93270: #ifdef JS_METHODJIT
 93270: #include "methodjit/MethodJIT.h"
 93270: #endif
 93270: 
 93270: #include "jsatominlines.h"
 93270: #include "jsfuninlines.h"
 93270: #include "jsinferinlines.h"
 93250: #include "jsobjinlines.h"
 93270: #include "jsscriptinlines.h"
 93270: #include "vm/ArgumentsObject-inl.h"
 93270: #include "vm/ScopeObject-inl.h"
 93270: #include "vm/Stack-inl.h"
 80506: 
 93270: using namespace mozilla;
 37741: using namespace js;
 54707: using namespace js::gc;
 93270: using namespace js::types;
 37741: 
 93249: static JSBool
 98960: fun_getProperty(JSContext *cx, HandleObject obj_, HandleId id, Value *vp)
 93249: {
 98960:     JSObject *obj = obj_;
 93270:     while (!obj->isFunction()) {
 93270:         obj = obj->getProto();
 93270:         if (!obj)
 93270:             return true;
 93270:     }
 93270:     JSFunction *fun = obj->toFunction();
 93270: 
 93270:     /*
 93270:      * Mark the function's script as uninlineable, to expand any of its
 93270:      * frames on the stack before we go looking for them. This allows the
 93270:      * below walk to only check each explicit frame rather than needing to
 93270:      * check any calls that were inlined.
 93270:      */
 93270:     if (fun->isInterpreted()) {
 93270:         fun->script()->uninlineable = true;
 93270:         MarkTypeObjectFlags(cx, fun, OBJECT_FLAG_UNINLINEABLE);
 93270:     }
 93270: 
 93270:     /* Set to early to null in case of error */
 93270:     vp->setNull();
 93270: 
 93270:     /* Find fun's top-most activation record. */
 95385:     StackIter iter(cx);
 95385:     for (; !iter.done(); ++iter) {
 95385:         if (!iter.isFunctionFrame() || iter.isEvalFrame())
 93270:             continue;
 97160:         if (iter.callee() == fun)
 93270:             break;
 93270:     }
 95385:     if (iter.done())
 93249:         return true;
 93249: 
 95394:     StackFrame *fp = iter.fp();
 95385: 
 95385:     if (JSID_IS_ATOM(id, cx->runtime->atomState.argumentsAtom)) {
 99225:         if (fun->hasRest()) {
 99225:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_FUNCTION_ARGUMENTS_AND_REST);
 99225:             return false;
 99225:         }
 95385:         /* Warn if strict about f.arguments or equivalent unqualified uses. */
 95385:         if (!JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING | JSREPORT_STRICT, js_GetErrorMessage,
 95385:                                           NULL, JSMSG_DEPRECATED_USAGE, js_arguments_str)) {
 95385:             return false;
 95385:         }
 95385: 
 95385:         ArgumentsObject *argsobj = ArgumentsObject::createUnexpected(cx, fp);
 95385:         if (!argsobj)
 95385:             return false;
 95385: 
 95385:         *vp = ObjectValue(*argsobj);
 95385:         return true;
 95385:     }
 95385: 
 93270: #ifdef JS_METHODJIT
 93270:     if (JSID_IS_ATOM(id, cx->runtime->atomState.callerAtom) && fp && fp->prev()) {
 93249:         /*
 93270:          * If the frame was called from within an inlined frame, mark the
 93270:          * innermost function as uninlineable to expand its frame and allow us
 93270:          * to recover its callee object.
 93249:          */
101075:         InlinedSite *inlined;
102812:         jsbytecode *prevpc = fp->prevpc(&inlined);
 93270:         if (inlined) {
 93270:             mjit::JITChunk *chunk = fp->prev()->jit()->chunk(prevpc);
 93270:             JSFunction *fun = chunk->inlineFrames()[inlined->inlineIndex].fun;
 93270:             fun->script()->uninlineable = true;
 93270:             MarkTypeObjectFlags(cx, fun, OBJECT_FLAG_UNINLINEABLE);
 93249:         }
 93249:     }
 93270: #endif
 93270: 
 95385:     if (JSID_IS_ATOM(id, cx->runtime->atomState.callerAtom)) {
103273:         ++iter;
103273:         if (iter.done() || !iter.isFunctionFrame()) {
 93270:             JS_ASSERT(vp->isNull());
 93249:             return true;
 93249:         }
103273: 
103273:         *vp = iter.calleev();
 94227: 
 93270:         /* Censor the caller if it is from another compartment. */
 93270:         JSObject &caller = vp->toObject();
 93270:         if (caller.compartment() != cx->compartment) {
 93270:             vp->setNull();
 93270:         } else if (caller.isFunction()) {
 93270:             JSFunction *callerFun = caller.toFunction();
 93270:             if (callerFun->isInterpreted() && callerFun->inStrictMode()) {
 93270:                 JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL,
 93270:                                              JSMSG_CALLER_IS_STRICT);
 93270:                 return false;
 93270:             }
 93270:         }
 93249: 
 93249:         return true;
 93249:     }
 93249: 
 93270:     JS_NOT_REACHED("fun_getProperty");
 93270:     return false;
 93250: }
 93250: 
 93270: 
 93270: 
 93270: /* NB: no sentinels at ends -- use ArrayLength to bound loops.
 93270:  * Properties censored into [[ThrowTypeError]] in strict mode. */
 93270: static const uint16_t poisonPillProps[] = {
 97828:     NAME_OFFSET(arguments),
 97828:     NAME_OFFSET(caller),
 93270: };
 93270: 
 93270: static JSBool
 98960: fun_enumerate(JSContext *cx, HandleObject obj)
 93270: {
 93270:     JS_ASSERT(obj->isFunction());
 93270: 
 99421:     RootedId id(cx);
 93270:     bool found;
 93270: 
 93270:     if (!obj->isBoundFunction()) {
 97828:         id = NameToId(cx->runtime->atomState.classPrototypeAtom);
 93270:         if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
 93270:             return false;
 93270:     }
 93270: 
 97828:     id = NameToId(cx->runtime->atomState.lengthAtom);
 93270:     if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
 93250:         return false;
 93250: 
 97828:     id = NameToId(cx->runtime->atomState.nameAtom);
 93270:     if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
 93250:         return false;
 93250: 
 93270:     for (unsigned i = 0; i < ArrayLength(poisonPillProps); i++) {
 93270:         const uint16_t offset = poisonPillProps[i];
 97828:         id = NameToId(OFFSET_TO_NAME(cx->runtime, offset));
 93270:         if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
 93249:             return false;
 93249:     }
 93249: 
 93249:     return true;
 93249: }
 93249: 
 93270: static JSObject *
 95355: ResolveInterpretedFunctionPrototype(JSContext *cx, HandleObject obj)
 93249: {
 93270: #ifdef DEBUG
 93270:     JSFunction *fun = obj->toFunction();
 93270:     JS_ASSERT(fun->isInterpreted());
 93270:     JS_ASSERT(!fun->isFunctionPrototype());
 93270: #endif
 93270: 
 93270:     /*
 93270:      * Assert that fun is not a compiler-created function object, which
 93270:      * must never leak to script or embedding code and then be mutated.
 93270:      * Also assert that obj is not bound, per the ES5 15.3.4.5 ref above.
 93270:      */
 93270:     JS_ASSERT(!IsInternalFunctionObject(obj));
 93270:     JS_ASSERT(!obj->isBoundFunction());
 93270: 
 93270:     /*
 93270:      * Make the prototype object an instance of Object with the same parent
 93270:      * as the function object itself.
 93270:      */
 93270:     JSObject *objProto = obj->global().getOrCreateObjectPrototype(cx);
 93270:     if (!objProto)
 93270:         return NULL;
 99421:     RootedObject proto(cx, NewObjectWithGivenProto(cx, &ObjectClass, objProto, NULL));
 93270:     if (!proto || !proto->setSingletonType(cx))
 93270:         return NULL;
 93270: 
 93270:     /*
 93270:      * Per ES5 15.3.5.2 a user-defined function's .prototype property is
 93270:      * initially non-configurable, non-enumerable, and writable.  Per ES5 13.2
 93270:      * the prototype's .constructor property is configurable, non-enumerable,
 93270:      * and writable.
 93270:      */
 93270:     if (!obj->defineProperty(cx, cx->runtime->atomState.classPrototypeAtom,
 93270:                              ObjectValue(*proto), JS_PropertyStub, JS_StrictPropertyStub,
 93270:                              JSPROP_PERMANENT) ||
 93270:         !proto->defineProperty(cx, cx->runtime->atomState.constructorAtom,
 93270:                                ObjectValue(*obj), JS_PropertyStub, JS_StrictPropertyStub, 0))
 93270:     {
 93270:        return NULL;
 93270:     }
 93270: 
 93270:     return proto;
 93270: }
 93270: 
 93270: static JSBool
 98960: fun_resolve(JSContext *cx, HandleObject obj, HandleId id, unsigned flags,
 93270:             JSObject **objp)
 93270: {
 93270:     if (!JSID_IS_ATOM(id))
 93270:         return true;
 93270: 
 99421:     RootedFunction fun(cx);
 93270:     fun = obj->toFunction();
 93270: 
 93270:     if (JSID_IS_ATOM(id, cx->runtime->atomState.classPrototypeAtom)) {
 93270:         /*
 93270:          * Native or "built-in" functions do not have a .prototype property per
 93270:          * ECMA-262, or (Object.prototype, Function.prototype, etc.) have that
 93270:          * property created eagerly.
 93270:          *
 93270:          * ES5 15.3.4: the non-native function object named Function.prototype
 93270:          * does not have a .prototype property.
 93270:          *
 93270:          * ES5 15.3.4.5: bound functions don't have a prototype property. The
 93270:          * isNative() test covers this case because bound functions are native
 93270:          * functions by definition/construction.
 93270:          */
 93270:         if (fun->isNative() || fun->isFunctionPrototype())
 93270:             return true;
 93270: 
 93270:         if (!ResolveInterpretedFunctionPrototype(cx, fun))
 93270:             return false;
 93270:         *objp = fun;
 93270:         return true;
 93270:     }
 93270: 
 93270:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom) ||
 93270:         JSID_IS_ATOM(id, cx->runtime->atomState.nameAtom)) {
 93270:         JS_ASSERT(!IsInternalFunctionObject(obj));
 93270: 
 93270:         Value v;
 93270:         if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom))
 99225:             v.setInt32(fun->nargs - fun->hasRest());
 93270:         else
 93270:             v.setString(fun->atom ? fun->atom : cx->runtime->emptyString);
 93270: 
 93270:         if (!DefineNativeProperty(cx, fun, id, v, JS_PropertyStub, JS_StrictPropertyStub,
 93270:                                   JSPROP_PERMANENT | JSPROP_READONLY, 0, 0)) {
 93270:             return false;
 93270:         }
 93270:         *objp = fun;
 93270:         return true;
 93270:     }
 93270: 
 93270:     for (unsigned i = 0; i < ArrayLength(poisonPillProps); i++) {
 93270:         const uint16_t offset = poisonPillProps[i];
 93270: 
 97828:         if (JSID_IS_ATOM(id, OFFSET_TO_NAME(cx->runtime, offset))) {
 93270:             JS_ASSERT(!IsInternalFunctionObject(fun));
 93270: 
 93270:             PropertyOp getter;
 93270:             StrictPropertyOp setter;
 93270:             unsigned attrs = JSPROP_PERMANENT;
 93270:             if (fun->isInterpreted() ? fun->inStrictMode() : fun->isBoundFunction()) {
 93270:                 JSObject *throwTypeError = fun->global().getThrowTypeError();
 93270: 
 93270:                 getter = CastAsPropertyOp(throwTypeError);
 93270:                 setter = CastAsStrictPropertyOp(throwTypeError);
 93270:                 attrs |= JSPROP_GETTER | JSPROP_SETTER;
 93270:             } else {
 93270:                 getter = fun_getProperty;
 93270:                 setter = JS_StrictPropertyStub;
 93270:             }
 93270: 
 93270:             if (!DefineNativeProperty(cx, fun, id, UndefinedValue(), getter, setter,
 93270:                                       attrs, 0, 0)) {
 93270:                 return false;
 93270:             }
 93270:             *objp = fun;
 93270:             return true;
 93270:         }
 93270:     }
 93270: 
 93270:     return true;
 93270: }
 93270: 
 94006: template<XDRMode mode>
 94006: bool
 94006: js::XDRInterpretedFunction(XDRState<mode> *xdr, JSObject **objp, JSScript *parentScript)
 93270: {
 97298:     /* NB: Keep this in sync with CloneInterpretedFunction. */
 93270:     JSFunction *fun;
 93607:     JSAtom *atom;
 93270:     uint32_t firstword;           /* flag telling whether fun->atom is non-null,
 93270:                                    plus for fun->u.i.skipmin, fun->u.i.wrapper,
 93270:                                    and 14 bits reserved for future use */
 93270:     uint32_t flagsword;           /* word for argument count and fun->flags */
 93270: 
 94006:     JSContext *cx = xdr->cx();
 93270:     JSScript *script;
 94006:     if (mode == XDR_ENCODE) {
 93270:         fun = (*objp)->toFunction();
 93270:         if (!fun->isInterpreted()) {
 93270:             JSAutoByteString funNameBytes;
 93270:             if (const char *name = GetFunctionNameBytes(cx, fun, &funNameBytes)) {
 93270:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_SCRIPTED_FUNCTION,
 93270:                                      name);
 93270:             }
 93270:             return false;
 93270:         }
 93270:         firstword = !!fun->atom;
 93270:         flagsword = (fun->nargs << 16) | fun->flags;
 93607:         atom = fun->atom;
 93270:         script = fun->script();
 93270:     } else {
 99421:         RootedObject parent(cx, NULL);
 93270:         fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED, parent, NULL);
 93270:         if (!fun)
 93270:             return false;
 93270:         if (!fun->clearParent(cx))
 93270:             return false;
 93270:         if (!fun->clearType(cx))
 93270:             return false;
 93607:         atom = NULL;
 93270:         script = NULL;
 93270:     }
 93270: 
 94006:     if (!xdr->codeUint32(&firstword))
 93270:         return false;
 94006:     if ((firstword & 1U) && !XDRAtom(xdr, &atom))
 93270:         return false;
 94006:     if (!xdr->codeUint32(&flagsword))
 93270:         return false;
 93270: 
 94006:     if (!XDRScript(xdr, &script, parentScript))
 93270:         return false;
 93270: 
 94006:     if (mode == XDR_DECODE) {
 93270:         fun->nargs = flagsword >> 16;
 93270:         JS_ASSERT((flagsword & JSFUN_KINDMASK) >= JSFUN_INTERPRETED);
 93270:         fun->flags = uint16_t(flagsword);
 93607:         fun->atom.init(atom);
 93607:         fun->initScript(script);
 93270:         if (!script->typeSetFunction(cx, fun))
 93270:             return false;
 95100:         JS_ASSERT(fun->nargs == fun->script()->bindings.numArgs());
 93270:         js_CallNewScriptHook(cx, fun->script(), fun);
 93270:         *objp = fun;
 93270:     }
 93270: 
 93270:     return true;
 93270: }
 93270: 
 94006: template bool
 94006: js::XDRInterpretedFunction(XDRState<XDR_ENCODE> *xdr, JSObject **objp, JSScript *parentScript);
 94006: 
 94006: template bool
 94006: js::XDRInterpretedFunction(XDRState<XDR_DECODE> *xdr, JSObject **objp, JSScript *parentScript);
 93270: 
 97298: JSObject *
 97298: js::CloneInterpretedFunction(JSContext *cx, JSFunction *srcFun)
 97298: {
 97298:     /* NB: Keep this in sync with XDRInterpretedFunction. */
 97298: 
 99421:     RootedObject parent(cx, NULL);
 97298:     JSFunction *clone = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED, parent, NULL);
 97298:     if (!clone)
 97298:         return NULL;
 97298:     if (!clone->clearParent(cx))
 97298:         return NULL;
 97298:     if (!clone->clearType(cx))
 97298:         return NULL;
 97298: 
102586:     Rooted<JSScript*> srcScript(cx, srcFun->script());
102586:     JSScript *clonedScript = CloneScript(cx, srcScript);
 97298:     if (!clonedScript)
 97298:         return NULL;
 97298: 
 97298:     clone->nargs = srcFun->nargs;
 97298:     clone->flags = srcFun->flags;
 97298:     clone->atom.init(srcFun->atom);
 97298:     clone->initScript(clonedScript);
 97298:     if (!clonedScript->typeSetFunction(cx, clone))
 97298:         return NULL;
 97298: 
 97298:     js_CallNewScriptHook(cx, clone->script(), clone);
 97298:     return clone;
 97298: }
 97298: 
 93270: /*
 93270:  * [[HasInstance]] internal method for Function objects: fetch the .prototype
 93270:  * property of its 'this' parameter, and walks the prototype chain of v (only
 93270:  * if v is an object) returning true if .prototype is found.
 93270:  */
 93270: static JSBool
 98960: fun_hasInstance(JSContext *cx, HandleObject obj_, const Value *v, JSBool *bp)
 93270: {
 99421:     RootedObject obj(cx, obj_);
 98960: 
 93270:     while (obj->isFunction()) {
 93270:         if (!obj->isBoundFunction())
 93270:             break;
 93270:         obj = obj->toFunction()->getBoundFunctionTarget();
 93270:     }
 93270: 
 93270:     Value pval;
 93270:     if (!obj->getProperty(cx, cx->runtime->atomState.classPrototypeAtom, &pval))
 93270:         return JS_FALSE;
 93270: 
 93270:     if (pval.isPrimitive()) {
 93270:         /*
 93270:          * Throw a runtime error if instanceof is called on a function that
 93270:          * has a non-object as its .prototype value.
 93270:          */
 93270:         js_ReportValueError(cx, JSMSG_BAD_PROTOTYPE, -1, ObjectValue(*obj), NULL);
 93270:         return JS_FALSE;
 93270:     }
 93270: 
 93270:     *bp = js_IsDelegate(cx, &pval.toObject(), *v);
 93270:     return JS_TRUE;
 93270: }
 93270: 
 93270: inline void
 93270: JSFunction::trace(JSTracer *trc)
 93270: {
 93270:     if (isExtended()) {
 93270:         MarkValueRange(trc, ArrayLength(toExtended()->extendedSlots),
 93270:                        toExtended()->extendedSlots, "nativeReserved");
 93270:     }
 93270: 
 93270:     if (atom)
 93607:         MarkString(trc, &atom, "atom");
 93270: 
 93270:     if (isInterpreted()) {
 93270:         if (u.i.script_)
 93270:             MarkScriptUnbarriered(trc, &u.i.script_, "script");
 93270:         if (u.i.env_)
 93270:             MarkObjectUnbarriered(trc, &u.i.env_, "fun_callscope");
 93270:     }
 93249: }
 93249: 
 93249: static void
 93270: fun_trace(JSTracer *trc, JSObject *obj)
 93249: {
 93270:     obj->toFunction()->trace(trc);
 93249: }
 93249: 
 93249: /*
 93270:  * Reserve two slots in all function objects for XPConnect.  Note that this
 93270:  * does not bloat every instance, only those on which reserved slots are set,
 93270:  * and those on which ad-hoc properties are defined.
 93249:  */
 93270: JS_FRIEND_DATA(Class) js::FunctionClass = {
 93270:     js_Function_str,
 93249:     JSCLASS_NEW_RESOLVE | JSCLASS_IMPLEMENTS_BARRIERS |
 93270:     JSCLASS_HAS_CACHED_PROTO(JSProto_Function),
 93249:     JS_PropertyStub,         /* addProperty */
 93270:     JS_PropertyStub,         /* delProperty */
 93249:     JS_PropertyStub,         /* getProperty */
 93249:     JS_StrictPropertyStub,   /* setProperty */
 93270:     fun_enumerate,
 93270:     (JSResolveOp)fun_resolve,
 93249:     JS_ConvertStub,
 93270:     NULL,                    /* finalize    */
 93249:     NULL,                    /* checkAccess */
 93249:     NULL,                    /* call        */
 98058:     fun_hasInstance,
 93249:     NULL,                    /* construct   */
 93270:     fun_trace
 93249: };
 93249: 
 93270: JSString *
 97467: ToSourceCache::lookup(JSFunction *fun)
 97467: {
 97467:     if (!map_)
 97467:         return NULL;
 97467:     if (Map::Ptr p = map_->lookup(fun))
 97467:         return p->value;
 97467:     return NULL;
 97467: }
 97467: 
 97467: void
 97467: ToSourceCache::put(JSFunction *fun, JSString *str)
 97467: {
 97467:     if (!map_) {
 97467:         map_ = OffTheBooks::new_<Map>();
 97467:         if (!map_)
 97467:             return;
 97467:         map_->init();
 97467:     }
 97467: 
 97467:     (void) map_->put(fun, str);
 97467: }
 97467: 
 97467: void
 97467: ToSourceCache::purge()
 97467: {
 97467:     Foreground::delete_(map_);
 97467:     map_ = NULL;
 97467: }
 97467: 
 97467: JSString *
 93270: fun_toStringHelper(JSContext *cx, JSObject *obj, unsigned indent)
 93270: {
 93270:     if (!obj->isFunction()) {
 93270:         if (IsFunctionProxy(obj))
 93270:             return Proxy::fun_toString(cx, obj, indent);
 93270:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 93270:                              JSMSG_INCOMPATIBLE_PROTO,
 93270:                              js_Function_str, js_toString_str,
 93270:                              "object");
 93270:         return NULL;
 93270:     }
 93270: 
 93270:     JSFunction *fun = obj->toFunction();
 93270:     if (!fun)
 93270:         return NULL;
 93270: 
 97467:     if (!indent) {
 97467:         if (JSString *str = cx->runtime->toSourceCache.lookup(fun))
 97467:             return str;
 93270:     }
 93270: 
 93270:     JSString *str = JS_DecompileFunction(cx, fun, indent);
 93270:     if (!str)
 93270:         return NULL;
 93270: 
 97467:     if (!indent)
 97467:         cx->runtime->toSourceCache.put(fun, str);
 93270: 
 93270:     return str;
 93270: }
 93270: 
 93270: static JSBool
 93270: fun_toString(JSContext *cx, unsigned argc, Value *vp)
 93270: {
 93270:     JS_ASSERT(IsFunctionObject(vp[0]));
 93270:     uint32_t indent = 0;
 93270: 
 93270:     if (argc != 0 && !ToUint32(cx, vp[2], &indent))
 93270:         return false;
 93270: 
 93270:     JSObject *obj = ToObject(cx, &vp[1]);
 93270:     if (!obj)
 93270:         return false;
 93270: 
 93270:     JSString *str = fun_toStringHelper(cx, obj, indent);
 93270:     if (!str)
 93270:         return false;
 93270: 
 93270:     vp->setString(str);
 93270:     return true;
 93270: }
 93270: 
 93270: #if JS_HAS_TOSOURCE
 93270: static JSBool
 93270: fun_toSource(JSContext *cx, unsigned argc, Value *vp)
 93270: {
 93270:     JS_ASSERT(IsFunctionObject(vp[0]));
 93270: 
 93270:     JSObject *obj = ToObject(cx, &vp[1]);
 93270:     if (!obj)
 93270:         return false;
 93270: 
 93270:     JSString *str = fun_toStringHelper(cx, obj, JS_DONT_PRETTY_PRINT);
 93270:     if (!str)
 93270:         return false;
 93270: 
 93270:     vp->setString(str);
 93270:     return true;
 93270: }
 93270: #endif
 93270: 
 93270: JSBool
 93270: js_fun_call(JSContext *cx, unsigned argc, Value *vp)
 93270: {
 93270:     Value fval = vp[1];
 93270: 
 93270:     if (!js_IsCallable(fval)) {
 93270:         ReportIncompatibleMethod(cx, CallReceiverFromVp(vp), &FunctionClass);
 93270:         return false;
 93270:     }
 93270: 
 93270:     Value *argv = vp + 2;
 93270:     Value thisv;
 93270:     if (argc == 0) {
 93270:         thisv.setUndefined();
 93270:     } else {
 93270:         thisv = argv[0];
 93270: 
 93270:         argc--;
 93270:         argv++;
 93270:     }
 93270: 
 93270:     /* Allocate stack space for fval, obj, and the args. */
 93270:     InvokeArgsGuard args;
 93270:     if (!cx->stack.pushInvokeArgs(cx, argc, &args))
 93270:         return JS_FALSE;
 93270: 
 93270:     /* Push fval, thisv, and the args. */
 93270:     args.calleev() = fval;
 93270:     args.thisv() = thisv;
 93270:     PodCopy(args.array(), argv, argc);
 93270: 
 93270:     bool ok = Invoke(cx, args);
 93270:     *vp = args.rval();
 93270:     return ok;
 93270: }
 93270: 
 93270: /* ES5 15.3.4.3 */
 93270: JSBool
 93270: js_fun_apply(JSContext *cx, unsigned argc, Value *vp)
 93270: {
 93270:     /* Step 1. */
 99421:     RootedValue fval(cx, vp[1]);
 93270:     if (!js_IsCallable(fval)) {
 93270:         ReportIncompatibleMethod(cx, CallReceiverFromVp(vp), &FunctionClass);
 93270:         return false;
 93270:     }
 93270: 
 93270:     /* Step 2. */
 93270:     if (argc < 2 || vp[3].isNullOrUndefined())
 93270:         return js_fun_call(cx, (argc > 0) ? 1 : 0, vp);
 93270: 
 93270:     InvokeArgsGuard args;
103261: 
103261:     /*
103261:      * GuardFunApplyArgumentsOptimization already called IsOptimizedArguments,
103261:      * so we don't need to here. This is not an optimization: we can't rely on
103261:      * cx->fp (since natives can be called directly from JSAPI).
103261:      */
 93270:     if (vp[3].isMagic(JS_OPTIMIZED_ARGUMENTS)) {
 93249:         /*
 93270:          * Pretend we have been passed the 'arguments' object for the current
 93270:          * function and read actuals out of the frame.
 93270:          *
 93270:          * N.B. Changes here need to be propagated to stubs::SplatApplyArgs.
 93249:          */
 93270:         /* Steps 4-6. */
 93270:         unsigned length = cx->fp()->numActualArgs();
 93270:         JS_ASSERT(length <= StackSpace::ARGS_LENGTH_MAX);
 93270: 
 93270:         if (!cx->stack.pushInvokeArgs(cx, length, &args))
 93270:             return false;
 93270: 
 93270:         /* Push fval, obj, and aobj's elements as args. */
 93270:         args.calleev() = fval;
 93270:         args.thisv() = vp[2];
 93270: 
 93270:         /* Steps 7-8. */
101075:         cx->fp()->forEachUnaliasedActual(CopyTo(args.array()));
 93270:     } else {
 93270:         /* Step 3. */
 93270:         if (!vp[3].isObject()) {
 93270:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_APPLY_ARGS, js_apply_str);
 93270:             return false;
 93270:         }
 93270: 
 93270:         /*
 93270:          * Steps 4-5 (note erratum removing steps originally numbered 5 and 7 in
 93270:          * original version of ES5).
 93270:          */
 99421:         RootedObject aobj(cx, &vp[3].toObject());
 93270:         uint32_t length;
 93270:         if (!js_GetLengthProperty(cx, aobj, &length))
 93270:             return false;
 93270: 
 93270:         /* Step 6. */
 93270:         if (length > StackSpace::ARGS_LENGTH_MAX) {
 93270:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_TOO_MANY_FUN_APPLY_ARGS);
 93270:             return false;
 93270:         }
 93270: 
 93270:         if (!cx->stack.pushInvokeArgs(cx, length, &args))
 93270:             return false;
 93270: 
 93270:         /* Push fval, obj, and aobj's elements as args. */
 93270:         args.calleev() = fval;
 93270:         args.thisv() = vp[2];
 93270: 
 93270:         /* Steps 7-8. */
 93270:         if (!GetElements(cx, aobj, length, args.array()))
 93270:             return false;
 93270:     }
 93270: 
 93270:     /* Step 9. */
 93270:     if (!Invoke(cx, args))
 93270:         return false;
 93270: 
 93270:     *vp = args.rval();
 93270:     return true;
 93270: }
 93270: 
 93270: namespace js {
 93270: 
 93270: JSBool
 93270: CallOrConstructBoundFunction(JSContext *cx, unsigned argc, Value *vp);
 93270: 
 93270: }
 93270: 
 93270: static const uint32_t JSSLOT_BOUND_FUNCTION_THIS       = 0;
 93270: static const uint32_t JSSLOT_BOUND_FUNCTION_ARGS_COUNT = 1;
 93270: 
 93270: static const uint32_t BOUND_FUNCTION_RESERVED_SLOTS = 2;
 93270: 
 93270: inline bool
 97353: JSFunction::initBoundFunction(JSContext *cx, HandleValue thisArg,
 93270:                               const Value *args, unsigned argslen)
 93249: {
 93270:     JS_ASSERT(isFunction());
 93270: 
 99421:     RootedFunction self(cx, this);
 97353: 
 93270:     /*
 93270:      * Convert to a dictionary to set the BOUND_FUNCTION flag and increase
 93270:      * the slot span to cover the arguments and additional slots for the 'this'
 93270:      * value and arguments count.
 93270:      */
 97353:     if (!self->toDictionaryMode(cx))
 93270:         return false;
 93270: 
 97353:     if (!self->setFlag(cx, BaseShape::BOUND_FUNCTION))
 93270:         return false;
 93270: 
 97353:     if (!self->setSlotSpan(cx, BOUND_FUNCTION_RESERVED_SLOTS + argslen))
 93270:         return false;
 93270: 
 97353:     self->setSlot(JSSLOT_BOUND_FUNCTION_THIS, thisArg);
 97353:     self->setSlot(JSSLOT_BOUND_FUNCTION_ARGS_COUNT, PrivateUint32Value(argslen));
 93270: 
 97353:     self->initSlotRange(BOUND_FUNCTION_RESERVED_SLOTS, args, argslen);
 93270: 
 93270:     return true;
 93249: }
 93270: 
 93270: inline JSObject *
 93270: JSFunction::getBoundFunctionTarget() const
 93270: {
 93270:     JS_ASSERT(isFunction());
 93270:     JS_ASSERT(isBoundFunction());
 93270: 
 93270:     /* Bound functions abuse |parent| to store their target function. */
 93270:     return getParent();
 93270: }
 93270: 
 93270: inline const js::Value &
 93270: JSFunction::getBoundFunctionThis() const
 93270: {
 93270:     JS_ASSERT(isFunction());
 93270:     JS_ASSERT(isBoundFunction());
 93270: 
 93270:     return getSlot(JSSLOT_BOUND_FUNCTION_THIS);
 93270: }
 93270: 
 93270: inline const js::Value &
 93270: JSFunction::getBoundFunctionArgument(unsigned which) const
 93270: {
 93270:     JS_ASSERT(isFunction());
 93270:     JS_ASSERT(isBoundFunction());
 93270:     JS_ASSERT(which < getBoundFunctionArgumentCount());
 93270: 
 93270:     return getSlot(BOUND_FUNCTION_RESERVED_SLOTS + which);
 93270: }
 93270: 
 93270: inline size_t
 93270: JSFunction::getBoundFunctionArgumentCount() const
 93270: {
 93270:     JS_ASSERT(isFunction());
 93270:     JS_ASSERT(isBoundFunction());
 93270: 
 93270:     return getSlot(JSSLOT_BOUND_FUNCTION_ARGS_COUNT).toPrivateUint32();
 93270: }
 93270: 
 93270: namespace js {
 93270: 
 93270: /* ES5 15.3.4.5.1 and 15.3.4.5.2. */
 93270: JSBool
 93270: CallOrConstructBoundFunction(JSContext *cx, unsigned argc, Value *vp)
 93270: {
 93270:     JSFunction *fun = vp[0].toObject().toFunction();
 93270:     JS_ASSERT(fun->isBoundFunction());
 93270: 
 93270:     bool constructing = IsConstructing(vp);
 93270: 
 93270:     /* 15.3.4.5.1 step 1, 15.3.4.5.2 step 3. */
 93270:     unsigned argslen = fun->getBoundFunctionArgumentCount();
 93270: 
 93270:     if (argc + argslen > StackSpace::ARGS_LENGTH_MAX) {
 93270:         js_ReportAllocationOverflow(cx);
 93270:         return false;
 93270:     }
 93270: 
 93270:     /* 15.3.4.5.1 step 3, 15.3.4.5.2 step 1. */
 93270:     JSObject *target = fun->getBoundFunctionTarget();
 93270: 
 93270:     /* 15.3.4.5.1 step 2. */
 93270:     const Value &boundThis = fun->getBoundFunctionThis();
 93270: 
 93270:     InvokeArgsGuard args;
 93270:     if (!cx->stack.pushInvokeArgs(cx, argc + argslen, &args))
 93270:         return false;
 93270: 
 93270:     /* 15.3.4.5.1, 15.3.4.5.2 step 4. */
 93270:     for (unsigned i = 0; i < argslen; i++)
 93270:         args[i] = fun->getBoundFunctionArgument(i);
 93270:     PodCopy(args.array() + argslen, vp + 2, argc);
 93270: 
 93270:     /* 15.3.4.5.1, 15.3.4.5.2 step 5. */
 93270:     args.calleev().setObject(*target);
 93270: 
 93270:     if (!constructing)
 93270:         args.thisv() = boundThis;
 93270: 
 93270:     if (constructing ? !InvokeConstructor(cx, args) : !Invoke(cx, args))
 93270:         return false;
 93270: 
 93270:     *vp = args.rval();
 93270:     return true;
 93270: }
 93270: 
 93270: }
 93270: 
 93270: #if JS_HAS_GENERATORS
 93270: static JSBool
 93270: fun_isGenerator(JSContext *cx, unsigned argc, Value *vp)
 93270: {
 93270:     JSFunction *fun;
 93270:     if (!IsFunctionObject(vp[1], &fun)) {
 93270:         JS_SET_RVAL(cx, vp, BooleanValue(false));
 93270:         return true;
 93270:     }
 93270: 
 93270:     bool result = false;
 93270:     if (fun->isInterpreted()) {
 93270:         JSScript *script = fun->script();
 93270:         JS_ASSERT(script->length != 0);
 95100:         result = script->isGenerator;
 93270:     }
 93270: 
 93270:     JS_SET_RVAL(cx, vp, BooleanValue(result));
 93270:     return true;
 93270: }
 93270: #endif
 93270: 
 93270: /* ES5 15.3.4.5. */
 93270: static JSBool
 93270: fun_bind(JSContext *cx, unsigned argc, Value *vp)
 93270: {
 93270:     CallArgs args = CallArgsFromVp(argc, vp);
 93270: 
 93270:     /* Step 1. */
 93270:     Value &thisv = args.thisv();
 93270: 
 93270:     /* Step 2. */
 93270:     if (!js_IsCallable(thisv)) {
 93270:         ReportIncompatibleMethod(cx, args, &FunctionClass);
 93270:         return false;
 93270:     }
 93270: 
 99421:     RootedObject target(cx);
 93270:     target = &thisv.toObject();
 93270: 
 93270:     /* Step 3. */
 93270:     Value *boundArgs = NULL;
 93270:     unsigned argslen = 0;
 93270:     if (args.length() > 1) {
 93270:         boundArgs = args.array() + 1;
 93270:         argslen = args.length() - 1;
 93270:     }
 93270: 
 94831:     /* Steps 7-9. */
 99421:     RootedValue thisArg(cx, args.length() >= 1 ? args[0] : UndefinedValue());
 94831: 
 94831:     JSObject *boundFunction = js_fun_bind(cx, target, thisArg, boundArgs, argslen);
 94831:     if (!boundFunction)
 94831:         return false;
 94831: 
 94831:     /* Step 22. */
 94831:     args.rval().setObject(*boundFunction);
 94831:     return true;
 94831: }
 94831: 
 94831: JSObject*
 97353: js_fun_bind(JSContext *cx, HandleObject target, HandleValue thisArg,
 94831:             Value *boundArgs, unsigned argslen)
 94831: {
 93270:     /* Steps 15-16. */
 93270:     unsigned length = 0;
 93270:     if (target->isFunction()) {
 93270:         unsigned nargs = target->toFunction()->nargs;
 93270:         if (nargs > argslen)
 93270:             length = nargs - argslen;
 93270:     }
 93270: 
 93270:     /* Step 4-6, 10-11. */
 93607:     JSAtom *name = target->isFunction() ? target->toFunction()->atom.get() : NULL;
 93270: 
 99421:     RootedObject funobj(cx);
 97353:     funobj = js_NewFunction(cx, NULL, CallOrConstructBoundFunction, length,
 93270:                             JSFUN_CONSTRUCTOR, target, name);
 93270:     if (!funobj)
 94831:         return NULL;
 93270: 
 93270:     /* NB: Bound functions abuse |parent| to store their target. */
 97353:     if (!JSObject::setParent(cx, funobj, target))
 94831:         return NULL;
 93270: 
 93270:     if (!funobj->toFunction()->initBoundFunction(cx, thisArg, boundArgs, argslen))
 94831:         return NULL;
 93270: 
 93270:     /* Steps 17, 19-21 are handled by fun_resolve. */
 93270:     /* Step 18 is the default for new functions. */
 94831:     return funobj;
 93270: }
 93270: 
 93270: /*
 93270:  * Report "malformed formal parameter" iff no illegal char or similar scanner
 93270:  * error was already reported.
 93270:  */
 93270: static bool
 93270: OnBadFormal(JSContext *cx, TokenKind tt)
 93270: {
 93270:     if (tt != TOK_ERROR)
 93270:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_FORMAL);
 93270:     else
 93270:         JS_ASSERT(cx->isExceptionPending());
 93270:     return false;
 93270: }
 93270: 
 93270: namespace js {
 93270: 
 93270: JSFunctionSpec function_methods[] = {
 93270: #if JS_HAS_TOSOURCE
 93270:     JS_FN(js_toSource_str,   fun_toSource,   0,0),
 93270: #endif
 93270:     JS_FN(js_toString_str,   fun_toString,   0,0),
 93270:     JS_FN(js_apply_str,      js_fun_apply,   2,0),
 93270:     JS_FN(js_call_str,       js_fun_call,    1,0),
 93270:     JS_FN("bind",            fun_bind,       1,0),
 93270: #if JS_HAS_GENERATORS
 93270:     JS_FN("isGenerator",     fun_isGenerator,0,0),
 93270: #endif
 93270:     JS_FS_END
 93249: };
 93270: 
 93270: JSBool
 93270: Function(JSContext *cx, unsigned argc, Value *vp)
 93270: {
 93270:     CallArgs args = CallArgsFromVp(argc, vp);
 93270: 
 93270:     /* Block this call if security callbacks forbid it. */
 99421:     Rooted<GlobalObject*> global(cx);
 93270:     global = &args.callee().global();
 93270:     if (!global->isRuntimeCodeGenEnabled(cx)) {
 93270:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CSP_BLOCKED_FUNCTION);
 93270:         return false;
 93270:     }
 93270: 
102615:     Bindings bindings;
 99364:     Bindings::AutoRooter bindingsRoot(cx, &bindings);
 93270: 
 99225:     bool hasRest = false;
 99225: 
 93270:     const char *filename;
 93270:     unsigned lineno;
 93270:     JSPrincipals *originPrincipals;
 93270:     CurrentScriptFileLineOrigin(cx, &filename, &lineno, &originPrincipals);
 93270:     JSPrincipals *principals = PrincipalsForCompiledCode(args, cx);
 93270: 
 93270:     unsigned n = args.length() ? args.length() - 1 : 0;
 93270:     if (n > 0) {
 93270:         /*
 93270:          * Collect the function-argument arguments into one string, separated
 93270:          * by commas, then make a tokenstream from that string, and scan it to
 93270:          * get the arguments.  We need to throw the full scanner at the
 93270:          * problem, because the argument string can legitimately contain
 93270:          * comments and linefeeds.  XXX It might be better to concatenate
 93270:          * everything up into a function definition and pass it to the
 93270:          * compiler, but doing it this way is less of a delta from the old
 93270:          * code.  See ECMA 15.3.2.1.
 93270:          */
 93270:         size_t args_length = 0;
 93270:         for (unsigned i = 0; i < n; i++) {
 93270:             /* Collect the lengths for all the function-argument arguments. */
 93270:             JSString *arg = ToString(cx, args[i]);
 93270:             if (!arg)
 93270:                 return false;
 93270:             args[i].setString(arg);
 93270: 
 93270:             /*
 93270:              * Check for overflow.  The < test works because the maximum
 93270:              * JSString length fits in 2 fewer bits than size_t has.
 93270:              */
 93270:             size_t old_args_length = args_length;
 93270:             args_length = old_args_length + arg->length();
 93270:             if (args_length < old_args_length) {
 93270:                 js_ReportAllocationOverflow(cx);
 93270:                 return false;
 93270:             }
 93270:         }
 93270: 
 93270:         /* Add 1 for each joining comma and check for overflow (two ways). */
 93270:         size_t old_args_length = args_length;
 93270:         args_length = old_args_length + n - 1;
 93270:         if (args_length < old_args_length ||
 93270:             args_length >= ~(size_t)0 / sizeof(jschar)) {
 93270:             js_ReportAllocationOverflow(cx);
 93270:             return false;
 93270:         }
 93270: 
 93270:         /*
 93270:          * Allocate a string to hold the concatenated arguments, including room
 93270:          * for a terminating 0. Mark cx->tempLifeAlloc for later release, to
 93270:          * free collected_args and its tokenstream in one swoop.
 93270:          */
 93270:         LifoAllocScope las(&cx->tempLifoAlloc());
 93270:         jschar *cp = cx->tempLifoAlloc().newArray<jschar>(args_length + 1);
 93270:         if (!cp) {
 93270:             js_ReportOutOfMemory(cx);
 93270:             return false;
 93270:         }
 93270:         jschar *collected_args = cp;
 93270: 
 93270:         /*
 93270:          * Concatenate the arguments into the new string, separated by commas.
 93270:          */
 93270:         for (unsigned i = 0; i < n; i++) {
 93270:             JSString *arg = args[i].toString();
 93270:             size_t arg_length = arg->length();
 93270:             const jschar *arg_chars = arg->getChars(cx);
 93270:             if (!arg_chars)
 93270:                 return false;
 93270:             (void) js_strncpy(cp, arg_chars, arg_length);
 93270:             cp += arg_length;
 93270: 
 93270:             /* Add separating comma or terminating 0. */
 93270:             *cp++ = (i + 1 < n) ? ',' : 0;
 93270:         }
 93270: 
 99779:         /*
 99779:          * Initialize a tokenstream that reads from the given string.  No
 99779:          * StrictModeGetter is needed because this TokenStream won't report any
 99779:          * strict mode errors.  Any strict mode errors which might be reported
 99779:          * here (duplicate argument names, etc.) will be detected when we
 99779:          * compile the function body.
 99779:          */
 99261:         TokenStream ts(cx, principals, originPrincipals,
 99779:                        collected_args, args_length, filename, lineno, cx->findVersion(),
 99779:                        /* strictModeGetter = */ NULL);
 93270: 
 93270:         /* The argument string may be empty or contain no tokens. */
 93270:         TokenKind tt = ts.getToken();
 93270:         if (tt != TOK_EOF) {
 93270:             for (;;) {
 93270:                 /*
 93270:                  * Check that it's a name.  This also implicitly guards against
 93270:                  * TOK_ERROR, which was already reported.
 93270:                  */
 99225:                 if (hasRest) {
102849:                     ts.reportError(JSMSG_PARAMETER_AFTER_REST);
 99225:                     return false;
 99225:                 }
 99225: 
 99225:                 if (tt != TOK_NAME) {
 99225:                     if (tt == TOK_TRIPLEDOT) {
 99225:                         hasRest = true;
 99225:                         tt = ts.getToken();
 99225:                         if (tt != TOK_NAME) {
 99225:                             if (tt != TOK_ERROR)
102849:                                 ts.reportError(JSMSG_NO_REST_NAME);
 99225:                             return false;
 99225:                         }
102849:                     } else {
 93270:                         return OnBadFormal(cx, tt);
 99225:                     }
 99225:                 }
 93270: 
 93270:                 /* Check for a duplicate parameter name. */
 99421:                 Rooted<PropertyName*> name(cx, ts.currentToken().name());
 93270:                 if (bindings.hasBinding(cx, name)) {
 93270:                     JSAutoByteString bytes;
 93270:                     if (!js_AtomToPrintableString(cx, name, &bytes))
 93270:                         return false;
102849:                     if (!ts.reportStrictWarning(JSMSG_DUPLICATE_FORMAL, bytes.ptr()))
 93270:                         return false;
 93270:                 }
 93270: 
 93270:                 uint16_t dummy;
 93270:                 if (!bindings.addArgument(cx, name, &dummy))
 93270:                     return false;
 93270: 
 93270:                 /*
 93270:                  * Get the next token.  Stop on end of stream.  Otherwise
 93270:                  * insist on a comma, get another name, and iterate.
 93270:                  */
 93270:                 tt = ts.getToken();
 93270:                 if (tt == TOK_EOF)
 93270:                     break;
 93270:                 if (tt != TOK_COMMA)
 93270:                     return OnBadFormal(cx, tt);
 93270:                 tt = ts.getToken();
 93270:             }
 93270:         }
 93270:     }
 93270: 
 93270:     JS::Anchor<JSString *> strAnchor(NULL);
 93270:     const jschar *chars;
 93270:     size_t length;
 93270: 
 97353:     SkipRoot skip(cx, &chars);
 97353: 
 93270:     if (args.length()) {
 93270:         JSString *str = ToString(cx, args[args.length() - 1]);
 93270:         if (!str)
 93270:             return false;
 93270:         strAnchor.set(str);
 93270:         chars = str->getChars(cx);
 93270:         length = str->length();
 93270:     } else {
 93270:         chars = cx->runtime->emptyString->chars();
 93270:         length = 0;
 93270:     }
 93270: 
 93270:     /*
 93270:      * NB: (new Function) is not lexically closed by its caller, it's just an
 93270:      * anonymous function in the top-level scope that its constructor inhabits.
 93270:      * Thus 'var x = 42; f = new Function("return x"); print(f())' prints 42,
 93270:      * and so would a call to f from another top-level's script or function.
 93270:      */
 99421:     RootedFunction fun(cx, js_NewFunction(cx, NULL, NULL, 0, JSFUN_LAMBDA | JSFUN_INTERPRETED,
 97353:                                              global, cx->runtime->atomState.anonymousAtom));
 93270:     if (!fun)
 93270:         return false;
 93270: 
 99225:     if (hasRest)
 99225:         fun->setHasRest();
 99225: 
 93270:     bool ok = frontend::CompileFunctionBody(cx, fun, principals, originPrincipals,
 93270:                                             &bindings, chars, length, filename, lineno,
 93270:                                             cx->findVersion());
 93270:     args.rval().setObject(*fun);
 93270:     return ok;
 93270: }
 93270: 
 93270: bool
 93270: IsBuiltinFunctionConstructor(JSFunction *fun)
 93270: {
 93270:     return fun->maybeNative() == Function;
 93270: }
 93270: 
 93270: } /* namespace js */
 93270: 
 93270: JSFunction *
 93270: js_NewFunction(JSContext *cx, JSObject *funobj, Native native, unsigned nargs,
 95355:                unsigned flags, HandleObject parent, JSAtom *atom_, js::gc::AllocKind kind)
 93270: {
 93270:     JS_ASSERT(kind == JSFunction::FinalizeKind || kind == JSFunction::ExtendedFinalizeKind);
 93270:     JS_ASSERT(sizeof(JSFunction) <= gc::Arena::thingSize(JSFunction::FinalizeKind));
 93270:     JS_ASSERT(sizeof(FunctionExtended) <= gc::Arena::thingSize(JSFunction::ExtendedFinalizeKind));
 93270: 
 99421:     RootedAtom atom(cx, atom_);
 95355: 
 93270:     JSFunction *fun;
 93270: 
 93270:     if (funobj) {
 93270:         JS_ASSERT(funobj->isFunction());
 93270:         JS_ASSERT(funobj->getParent() == parent);
 93270:     } else {
 93270:         funobj = NewObjectWithClassProto(cx, &FunctionClass, NULL, SkipScopeParent(parent), kind);
 93270:         if (!funobj)
 93270:             return NULL;
 93270:     }
 93270:     fun = static_cast<JSFunction *>(funobj);
 93270: 
 93270:     /* Initialize all function members. */
 93270:     fun->nargs = uint16_t(nargs);
 93270:     fun->flags = flags & (JSFUN_FLAGS_MASK | JSFUN_KINDMASK);
 93270:     if ((flags & JSFUN_KINDMASK) >= JSFUN_INTERPRETED) {
 93270:         JS_ASSERT(!native);
 95099:         fun->mutableScript().init(NULL);
 93270:         fun->initEnvironment(parent);
 93270:     } else {
 94094:         fun->u.native = native;
 94094:         JS_ASSERT(fun->u.native);
 93270:     }
 93270:     if (kind == JSFunction::ExtendedFinalizeKind) {
 93270:         fun->flags |= JSFUN_EXTENDED;
 93270:         fun->initializeExtended();
 93270:     }
 93607:     fun->atom.init(atom);
 93270: 
 93270:     if (native && !fun->setSingletonType(cx))
 93270:         return NULL;
 93270: 
 93270:     return fun;
 93270: }
 93270: 
 93270: JSFunction * JS_FASTCALL
 95355: js_CloneFunctionObject(JSContext *cx, HandleFunction fun, HandleObject parent,
 95355:                        HandleObject proto, gc::AllocKind kind)
 93270: {
 93270:     JS_ASSERT(parent);
 93270:     JS_ASSERT(proto);
 98316:     JS_ASSERT(!fun->isBoundFunction());
 93270: 
 93270:     JSObject *cloneobj = NewObjectWithClassProto(cx, &FunctionClass, NULL, SkipScopeParent(parent), kind);
 93270:     if (!cloneobj)
 93270:         return NULL;
 99421:     RootedFunction clone(cx, static_cast<JSFunction *>(cloneobj));
 93270: 
 93270:     clone->nargs = fun->nargs;
 93270:     clone->flags = fun->flags & ~JSFUN_EXTENDED;
 93270:     if (fun->isInterpreted()) {
 93270:         clone->initScript(fun->script());
 93270:         clone->initEnvironment(parent);
 93270:     } else {
 94094:         clone->u.native = fun->native();
 93270:     }
 93607:     clone->atom.init(fun->atom);
 93270: 
 93270:     if (kind == JSFunction::ExtendedFinalizeKind) {
 93270:         clone->flags |= JSFUN_EXTENDED;
 93270:         clone->initializeExtended();
 93270:     }
 93270: 
 93270:     if (cx->compartment == fun->compartment()) {
 93270:         /*
 93270:          * We can use the same type as the original function provided that (a)
 93270:          * its prototype is correct, and (b) its type is not a singleton. The
 93270:          * first case will hold in all compileAndGo code, and the second case
 93270:          * will have been caught by CloneFunctionObject coming from function
 93270:          * definitions or read barriers, so will not get here.
 93270:          */
 93270:         if (fun->getProto() == proto && !fun->hasSingletonType())
 93270:             clone->setType(fun->type());
 93270:     } else {
 93270:         /*
 93270:          * Across compartments we have to clone the script for interpreted
 93270:          * functions.
 93270:          */
 93270:         if (clone->isInterpreted()) {
101203:             RootedScript script(cx, clone->script());
 93270:             JS_ASSERT(script);
 93270:             JS_ASSERT(script->compartment() == fun->compartment());
 93270:             JS_ASSERT(script->compartment() != cx->compartment);
 93270: 
 95099:             clone->mutableScript().init(NULL);
 93270:             JSScript *cscript = CloneScript(cx, script);
 93270:             if (!cscript)
 93270:                 return NULL;
 93270: 
 93270:             cscript->globalObject = &clone->global();
 93270:             clone->setScript(cscript);
 93270:             if (!cscript->typeSetFunction(cx, clone))
 93270:                 return NULL;
 93270: 
 93270:             js_CallNewScriptHook(cx, clone->script(), clone);
 93270:             Debugger::onNewScript(cx, clone->script(), NULL);
 93270:         }
 93270:     }
 93270:     return clone;
 93270: }
 93270: 
 93270: JSFunction *
 98960: js_DefineFunction(JSContext *cx, HandleObject obj, HandleId id, Native native,
 93270:                   unsigned nargs, unsigned attrs, AllocKind kind)
 93270: {
 93270:     PropertyOp gop;
 93270:     StrictPropertyOp sop;
 93270: 
 99421:     RootedFunction fun(cx);
 93270: 
 93270:     if (attrs & JSFUN_STUB_GSOPS) {
 93270:         /*
 93270:          * JSFUN_STUB_GSOPS is a request flag only, not stored in fun->flags or
 93270:          * the defined property's attributes. This allows us to encode another,
 93270:          * internal flag using the same bit, JSFUN_EXPR_CLOSURE -- see jsfun.h
 93270:          * for more on this.
 93270:          */
 93270:         attrs &= ~JSFUN_STUB_GSOPS;
 93270:         gop = JS_PropertyStub;
 93270:         sop = JS_StrictPropertyStub;
 93270:     } else {
 93270:         gop = NULL;
 93270:         sop = NULL;
 93270:     }
 93270: 
 93270:     fun = js_NewFunction(cx, NULL, native, nargs,
 93270:                          attrs & (JSFUN_FLAGS_MASK),
 93270:                          obj,
 93270:                          JSID_IS_ATOM(id) ? JSID_TO_ATOM(id) : NULL,
 93270:                          kind);
 93270:     if (!fun)
 93270:         return NULL;
 93270: 
 93270:     if (!obj->defineGeneric(cx, id, ObjectValue(*fun), gop, sop, attrs & ~JSFUN_FLAGS_MASK))
 93270:         return NULL;
 93270: 
 93270:     return fun;
 93270: }
 93270: 
 93270: JS_STATIC_ASSERT((JSV2F_CONSTRUCT & JSV2F_SEARCH_STACK) == 0);
 93270: 
 93270: JSFunction *
 93270: js_ValueToFunction(JSContext *cx, const Value *vp, unsigned flags)
 93270: {
 93270:     JSFunction *fun;
 93270:     if (!IsFunctionObject(*vp, &fun)) {
 93270:         js_ReportIsNotFunction(cx, vp, flags);
 93270:         return NULL;
 93270:     }
 93270:     return fun;
 93270: }
 93270: 
 93270: JSObject *
 93270: js_ValueToCallableObject(JSContext *cx, Value *vp, unsigned flags)
 93270: {
 93270:     if (vp->isObject()) {
 93270:         JSObject *callable = &vp->toObject();
 93270:         if (callable->isCallable())
 93270:             return callable;
 93270:     }
 93270: 
 93270:     js_ReportIsNotFunction(cx, vp, flags);
 93270:     return NULL;
 93270: }
 93270: 
 93270: void
 93270: js_ReportIsNotFunction(JSContext *cx, const Value *vp, unsigned flags)
 93270: {
 93270:     const char *name = NULL, *source = NULL;
 93270:     unsigned error = (flags & JSV2F_CONSTRUCT) ? JSMSG_NOT_CONSTRUCTOR : JSMSG_NOT_FUNCTION;
 93270: 
 93270:     /*
 93270:      * We try to the print the code that produced vp if vp is a value in the
 93270:      * most recent interpreted stack frame. Note that additional values, not
 93270:      * directly produced by the script, may have been pushed onto the frame's
 93270:      * expression stack (e.g. by pushInvokeArgs) thereby incrementing sp past
 93270:      * the depth simulated by ReconstructPCStack.
 93270:      *
 93270:      * Conversely, values may have been popped from the stack in preparation
 93270:      * for a call (e.g., by SplatApplyArgs). Since we must pass an offset from
 93270:      * the top of the simulated stack to js_ReportValueError3, we do bounds
 93270:      * checking using the minimum of both the simulated and actual stack depth.
 93270:      */
 93270:     ptrdiff_t spindex = 0;
 93270: 
 97161:     ScriptFrameIter i(cx);
 93270:     if (!i.done()) {
 97161:         unsigned depth = js_ReconstructStackDepth(cx, i.script(), i.pc());
 93270:         Value *simsp = i.fp()->base() + depth;
103273:         if (i.fp()->base() <= vp && vp < Min(simsp, i.spFuzzy()))
 93270:             spindex = vp - simsp;
 93270:     }
 93270: 
 93270:     if (!spindex)
 93270:         spindex = ((flags & JSV2F_SEARCH_STACK) ? JSDVG_SEARCH_STACK : JSDVG_IGNORE_STACK);
 93270: 
 93270:     js_ReportValueError3(cx, error, spindex, *vp, NULL, name, source);
 93270: }
