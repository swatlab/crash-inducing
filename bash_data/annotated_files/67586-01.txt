    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org Code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Scott MacGregor <mscott@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsIconURI.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIIOService.h"
    1: #include "nsIURL.h"
    1: #include "prprf.h"
    1: #include "plstr.h"
    1: #include <stdlib.h>
    1: 
    1: #define DEFAULT_IMAGE_SIZE 16
    1: 
42290: #if defined(MAX_PATH)
42290: #define SANE_FILE_NAME_LEN MAX_PATH
42290: #elif defined(PATH_MAX)
42290: #define SANE_FILE_NAME_LEN PATH_MAX
42290: #else
42290: #define SANE_FILE_NAME_LEN 1024
42290: #endif
42290: 
    1: // helper function for parsing out attributes like size, and contentType
    1: // from the icon url.
    1: static void extractAttributeValue(const char * searchString, const char * attributeName, nsCString& aResult);
    1:  
 7731: static const char *kSizeStrings[] =
 7731: {
 7731:   "button",
 7731:   "toolbar",
 7731:   "toolbarsmall",
 7731:   "menu",
 8719:   "dnd",
 7731:   "dialog"
    1: };
    1: 
 7731: static const char *kStateStrings[] =
    1: {
 7731:   "normal",
 7731:   "disabled"
    1: };
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1:  
    1: nsMozIconURI::nsMozIconURI()
 7731:   : mSize(DEFAULT_IMAGE_SIZE),
 7731:     mIconSize(-1),
 7731:     mIconState(-1)
    1: {
    1: }
    1:  
    1: nsMozIconURI::~nsMozIconURI()
    1: {
    1: }
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS2(nsMozIconURI, nsIMozIconURI, nsIURI)
    1: 
42290: #define MOZICON_SCHEME "moz-icon:"
42290: #define MOZICON_SCHEME_LEN (sizeof(MOZICON_SCHEME) - 1)
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: // nsURI methods:
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetSpec(nsACString &aSpec)
    1: {
42290:   aSpec = MOZICON_SCHEME;
 7731: 
42290:   if (mIconURL)
 7731:   {
 7731:     nsCAutoString fileIconSpec;
42290:     nsresult rv = mIconURL->GetSpec(fileIconSpec);
 7731:     NS_ENSURE_SUCCESS(rv, rv);
 7731:     aSpec += fileIconSpec;
 7731:   }
 7731:   else if (!mStockIcon.IsEmpty())
 7731:   {
 7731:     aSpec += "//stock/";
 7731:     aSpec += mStockIcon;
 7731:   }
 7731:   else
 7731:   {
 7731:     aSpec += "//";
42290:     aSpec += mFileName;
 7731:   }
 7731: 
 7731:   aSpec += "?size=";
 7731:   if (mIconSize >= 0)
 7731:   {
 7731:     aSpec += kSizeStrings[mIconSize];
 7731:   }
 7731:   else
 7731:   {
 7731:     char buf[20];
 7731:     PR_snprintf(buf, sizeof(buf), "%d", mSize);
 7731:     aSpec.Append(buf);
 7731:   }
 7731: 
 7731:   if (mIconState >= 0) {
 7731:     aSpec += "&state=";
 7731:     aSpec += kStateStrings[mIconState];
 7731:   }
 7731: 
 7731:   if (!mContentType.IsEmpty())
 7731:   {
 7731:     aSpec += "&contentType=";
 7731:     aSpec += mContentType.get();
 7731:   }
 7731:   
 7731:   return NS_OK;
    1: }
    1: 
    1: // takes a string like ?size=32&contentType=text/html and returns a new string 
    1: // containing just the attribute value. i.e you could pass in this string with
    1: // an attribute name of 'size=', this will return 32
    1: // Assumption: attribute pairs in the string are separated by '&'.
    1: void extractAttributeValue(const char * searchString, const char * attributeName, nsCString& result)
    1: {
    1:   //NS_ENSURE_ARG_POINTER(extractAttributeValue);
    1: 
    1:   result.Truncate();
    1: 
    1:   if (searchString && attributeName)
    1:   {
    1:     // search the string for attributeName
    1:     PRUint32 attributeNameSize = strlen(attributeName);
    1:     const char * startOfAttribute = PL_strcasestr(searchString, attributeName);
  943:     if (startOfAttribute &&
  943:        ( *(startOfAttribute-1) == '?' || *(startOfAttribute-1) == '&') )
    1:     {
    1:       startOfAttribute += attributeNameSize; // skip over the attributeName
    1:       if (*startOfAttribute) // is there something after the attribute name
    1:       {
    1:         const char * endofAttribute = strchr(startOfAttribute, '&');
    1:         if (endofAttribute)
    1:           result.Assign(Substring(startOfAttribute, endofAttribute));
    1:         else
    1:           result.Assign(startOfAttribute);
    1:       } // if we have a attribute value
    1:     } // if we have a attribute name
    1:   } // if we got non-null search string and attribute name values
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::SetSpec(const nsACString &aSpec)
    1: {
42290:   // Reset everything to default values.
42290:   mIconURL = nsnull;
42290:   mSize = DEFAULT_IMAGE_SIZE;
42290:   mContentType.Truncate();
42290:   mFileName.Truncate();
42290:   mStockIcon.Truncate();
42290:   mIconSize = -1;
42290:   mIconState = -1;
    1: 
42290:   nsCAutoString iconSpec(aSpec);
42290:   if (!Substring(iconSpec, 0, MOZICON_SCHEME_LEN).EqualsLiteral(MOZICON_SCHEME))
    1:     return NS_ERROR_MALFORMED_URI;
    1: 
42290:   PRInt32 questionMarkPos = iconSpec.Find("?");
42290:   if (questionMarkPos != -1 && static_cast<PRInt32>(iconSpec.Length()) > (questionMarkPos + 1))
42290:   {
42290:     extractAttributeValue(iconSpec.get(), "contentType=", mContentType);
42290: 
    1:     nsCAutoString sizeString;
42290:     extractAttributeValue(iconSpec.get(), "size=", sizeString);
    1:     if (!sizeString.IsEmpty())
    1:     {      
 7731:       const char *sizeStr = sizeString.get();
29632:       for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(kSizeStrings); i++)
    1:       {
 7731:         if (PL_strcasecmp(sizeStr, kSizeStrings[i]) == 0)
    1:         {
 7731:           mIconSize = i;
    1:           break;
    1:         }
    1:       }
42290: 
42290:       PRInt32 sizeValue = atoi(sizeString.get());
42290:       if (sizeValue)
42290:         mSize = sizeValue;
    1:     }
    1: 
42290:     nsCAutoString stateString;
42290:     extractAttributeValue(iconSpec.get(), "state=", stateString);
    1:     if (!stateString.IsEmpty())
    1:     {
 7731:       const char *stateStr = stateString.get();
29632:       for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(kStateStrings); i++)
    1:       {
 7731:         if (PL_strcasecmp(stateStr, kStateStrings[i]) == 0)
    1:         {
 7731:           mIconState = i;
    1:           break;
    1:         }
    1:       }
    1:     }
42290:   }
    1: 
42290:   PRInt32 pathLength = iconSpec.Length() - MOZICON_SCHEME_LEN;
42290:   if (questionMarkPos != -1)
42290:     pathLength = questionMarkPos - MOZICON_SCHEME_LEN;
42290:   if (pathLength < 3)
42290:     return NS_ERROR_MALFORMED_URI;
42290: 
42290:   nsCAutoString iconPath(Substring(iconSpec, MOZICON_SCHEME_LEN, pathLength));
42290: 
42290:   // Icon URI path can have three forms:
42290:   // (1) //stock/<icon-identifier>
    1:   // (2) //<some dummy file with an extension>
42290:   // (3) a valid URL
42290: 
42290:   if (!strncmp("//stock/", iconPath.get(), 8))
    1:   {
42290:     mStockIcon.Assign(Substring(iconPath, 8));
67586:     // An icon identifier must always be specified.
67586:     if (mStockIcon.IsEmpty())
67586:       return NS_ERROR_MALFORMED_URI;
42290:     return NS_OK;
42290:   }
42290: 
43725:   if (StringBeginsWith(iconPath, NS_LITERAL_CSTRING("//")))
    1:   {
42290:     // Sanity check this supposed dummy file name.
42290:     if (iconPath.Length() > SANE_FILE_NAME_LEN)
42290:       return NS_ERROR_MALFORMED_URI;
43725:     iconPath.Cut(0, 2);
43725:     mFileName.Assign(iconPath);
    1:   }
42290: 
42290:   nsresult rv;
42290:   nsCOMPtr<nsIIOService> ioService(do_GetService(NS_IOSERVICE_CONTRACTID, &rv));
42290:   NS_ENSURE_SUCCESS(rv, rv);
42290: 
42290:   nsCOMPtr<nsIURI> uri;
43725:   ioService->NewURI(iconPath, nsnull, nsnull, getter_AddRefs(uri));
43725:   mIconURL = do_QueryInterface(uri);
43725:   if (mIconURL)
43725:     mFileName.Truncate();
43725:   else if (mFileName.IsEmpty())
43725:     return NS_ERROR_MALFORMED_URI;
42290: 
43725:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetPrePath(nsACString &prePath)
    1: {
42290:   prePath = MOZICON_SCHEME;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetScheme(nsACString &aScheme)
    1: {
    1:   aScheme = "moz-icon";
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::SetScheme(const nsACString &aScheme)
    1: {
    1:   // doesn't make sense to set the scheme of a moz-icon URL
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetUsername(nsACString &aUsername)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::SetUsername(const nsACString &aUsername)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetPassword(nsACString &aPassword)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::SetPassword(const nsACString &aPassword)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetUserPass(nsACString &aUserPass)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::SetUserPass(const nsACString &aUserPass)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetHostPort(nsACString &aHostPort)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::SetHostPort(const nsACString &aHostPort)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetHost(nsACString &aHost)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::SetHost(const nsACString &aHost)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetPort(PRInt32 *aPort)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1:  
    1: NS_IMETHODIMP
    1: nsMozIconURI::SetPort(PRInt32 aPort)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetPath(nsACString &aPath)
    1: {
    1:   aPath.Truncate();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::SetPath(const nsACString &aPath)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::Equals(nsIURI *other, PRBool *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(other);
    1:   NS_PRECONDITION(result, "null pointer");
    1: 
    1:   nsCAutoString spec1;
    1:   nsCAutoString spec2;
    1: 
    1:   other->GetSpec(spec2);
    1:   GetSpec(spec1);
    1:   if (!PL_strcasecmp(spec1.get(), spec2.get()))
    1:     *result = PR_TRUE;
    1:   else
    1:     *result = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::SchemeIs(const char *i_Scheme, PRBool *o_Equals)
    1: {
    1:   NS_ENSURE_ARG_POINTER(o_Equals);
    1:   if (!i_Scheme) return NS_ERROR_INVALID_ARG;
    1:   
    1:   *o_Equals = PL_strcasecmp("moz-icon", i_Scheme) ? PR_FALSE : PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::Clone(nsIURI **result)
    1: {
42290:   nsCOMPtr<nsIURL> newIconURL;
42290:   if (mIconURL)
    1:   {
42290:     nsCOMPtr<nsIURI> newURI;
42290:     nsresult rv = mIconURL->Clone(getter_AddRefs(newURI));
42290:     if (NS_FAILED(rv))
42290:       return rv;
42290:     newIconURL = do_QueryInterface(newURI, &rv);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:   }
    1: 
    1:   nsMozIconURI *uri = new nsMozIconURI();
    1:   if (!uri)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:  
42290:   newIconURL.swap(uri->mIconURL);
    1:   uri->mSize = mSize;
    1:   uri->mContentType = mContentType;
42290:   uri->mFileName = mFileName;
    1:   uri->mStockIcon = mStockIcon;
    1:   uri->mIconSize = mIconSize;
    1:   uri->mIconState = mIconState;
    1:   NS_ADDREF(*result = uri);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::Resolve(const nsACString &relativePath, nsACString &result)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetAsciiSpec(nsACString &aSpecA)
    1: {
    1:   return GetSpec(aSpecA);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetAsciiHost(nsACString &aHostA)
    1: {
    1:   return GetHost(aHostA);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetOriginCharset(nsACString &result)
    1: {
    1:   result.Truncate();
    1:   return NS_OK;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: // nsIIconUri methods:
    1: 
    1: NS_IMETHODIMP
42290: nsMozIconURI::GetIconURL(nsIURL* * aFileUrl)
    1: {
42290:   *aFileUrl = mIconURL;
    1:   NS_IF_ADDREF(*aFileUrl);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
42290: nsMozIconURI::SetIconURL(nsIURL* aFileUrl)
    1: {
  943:   // this isn't called anywhere, needs to go through SetSpec parsing
  943:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetImageSize(PRUint32 * aImageSize)  // measured by # of pixels in a row. defaults to 16.
    1: {
    1:   *aImageSize = mSize;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::SetImageSize(PRUint32 aImageSize)  // measured by # of pixels in a row. defaults to 16.
    1: {
    1:   mSize = aImageSize;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetContentType(nsACString &aContentType)
    1: {
    1:   aContentType = mContentType;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::SetContentType(const nsACString &aContentType) 
    1: {
    1:   mContentType = aContentType;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetFileExtension(nsACString &aFileExtension)  
    1: {
42290:   // First, try to get the extension from mIconURL if we have one
42290:   if (mIconURL)
    1:   {
    1:     nsCAutoString fileExt;
42290:     if (NS_SUCCEEDED(mIconURL->GetFileExtension(fileExt)))
    1:     {
42290:       if (!fileExt.IsEmpty())
    1:       {
    1:         // unfortunately, this code doesn't give us the required '.' in front of the extension
    1:         // so we have to do it ourselves..
    1:         aFileExtension.Assign('.');
    1:         aFileExtension.Append(fileExt);
42290:       }
42290:     }
    1:     return NS_OK;
    1:   }
42290: 
42290:   if (!mFileName.IsEmpty())
42290:   {
42290:     // truncate the extension out of the file path...
42290:     const char * chFileName = mFileName.get(); // get the underlying buffer
42290:     const char * fileExt = strrchr(chFileName, '.');
42290:     if (!fileExt)
42290:       return NS_OK;
42290:     aFileExtension = fileExt;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetStockIcon(nsACString &aStockIcon)
    1: {
 7731:   aStockIcon = mStockIcon;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetIconSize(nsACString &aSize)
    1: {
 7731:   if (mIconSize >= 0)
 7731:     aSize = kSizeStrings[mIconSize];
 7731:   else
    1:     aSize.Truncate();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMozIconURI::GetIconState(nsACString &aState)
    1: {
10219:   if (mIconState >= 0)
 7731:     aState = kStateStrings[mIconState];
 7731:   else
    1:     aState.Truncate();
    1:   return NS_OK;
    1: }
    1: ////////////////////////////////////////////////////////////////////////////////
