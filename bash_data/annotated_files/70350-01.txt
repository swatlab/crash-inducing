52216: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
52216: /* ***** BEGIN LICENSE BLOCK *****
52216:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52216:  *
52216:  * The contents of this file are subject to the Mozilla Public License Version
52216:  * 1.1 (the "License"); you may not use this file except in compliance with
52216:  * the License. You may obtain a copy of the License at
52216:  * http://www.mozilla.org/MPL/
52216:  *
52216:  * Software distributed under the License is distributed on an "AS IS" basis,
52216:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52216:  * for the specific language governing rights and limitations under the
52216:  * License.
52216:  *
52216:  * The Original Code is mozilla.org code.
52216:  *
52216:  * The Initial Developer of the Original Code is
52216:  * the Mozilla Foundation.
52216:  * Portions created by the Initial Developer are Copyright (C) 2010
52216:  * the Initial Developer. All Rights Reserved.
52216:  *
52216:  * Contributor(s):
52216:  *   Daniel Holbert <dholbert@mozilla.com>
52216:  *
52216:  * Alternatively, the contents of this file may be used under the terms of
52216:  * either the GNU General Public License Version 2 or later (the "GPL"), or
52216:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52216:  * in which case the provisions of the GPL or the LGPL are applicable instead
52216:  * of those above. If you wish to allow use of your version of this file only
52216:  * under the terms of either the GPL or the LGPL, and not to allow others to
52216:  * use your version of this file under the terms of the MPL, indicate your
52216:  * decision by deleting the provisions above and replace them with the notice
52216:  * and other provisions required by the GPL or the LGPL. If you do not delete
52216:  * the provisions above, a recipient may use your version of this file under
52216:  * the terms of any one of the MPL, the GPL or the LGPL.
52216:  *
52216:  * ***** END LICENSE BLOCK ***** */
52216: 
52216: #include "VectorImage.h"
52221: #include "imgIDecoderObserver.h"
52221: #include "SVGDocumentWrapper.h"
52221: #include "gfxContext.h"
52221: #include "gfxPlatform.h"
52221: #include "nsPresContext.h"
52221: #include "nsRect.h"
52221: #include "nsIDocumentViewer.h"
52221: #include "nsIObserverService.h"
52221: #include "nsIPresShell.h"
52221: #include "nsIStreamListener.h"
52221: #include "nsComponentManagerUtils.h"
52221: #include "nsServiceManagerUtils.h"
52221: #include "nsSVGUtils.h"  // for nsSVGUtils::ConvertToSurfaceSize
52221: #include "nsSVGEffects.h" // for nsSVGRenderingObserver
52221: #include "gfxDrawable.h"
52221: #include "gfxUtils.h"
52222: #include "nsSVGSVGElement.h"
52222: 
52222: using namespace mozilla::dom;
52216: 
52216: namespace mozilla {
52216: namespace imagelib {
52216: 
52222: // Helper-class: SVGRootRenderingObserver
52222: class SVGRootRenderingObserver : public nsSVGRenderingObserver {
52222: public:
52222:   SVGRootRenderingObserver(SVGDocumentWrapper* aDocWrapper,
52222:                            VectorImage*        aVectorImage)
52222:     : nsSVGRenderingObserver(),
52222:       mDocWrapper(aDocWrapper),
52222:       mVectorImage(aVectorImage)
52222:   {
52222:     StartListening();
52222:     Element* elem = GetTarget();
52222:     if (elem) {
52222:       nsSVGEffects::AddRenderingObserver(elem, this);
53744:       mInObserverList = PR_TRUE;
52222:     }
53744: #ifdef DEBUG
53744:     else {
53744:       NS_ABORT_IF_FALSE(!mInObserverList,
53744:                         "Have no target, so we can't be in "
53744:                         "target's observer list...");
53744:     }
53744: #endif
52222:   }
52222: 
52222:   virtual ~SVGRootRenderingObserver()
52222:   {
52222:     StopListening();
52222:   }
52222: 
52222: protected:
52222:   virtual Element* GetTarget()
52222:   {
52222:     return mDocWrapper->GetRootSVGElem();
52222:   }
52222: 
52222:   virtual void DoUpdate()
52222:   {
52222:     Element* elem = GetTarget();
52222:     if (!elem)
52222:       return;
52222: 
52222:     if (!mDocWrapper->ShouldIgnoreInvalidation()) {
52222:       nsIFrame* frame = elem->GetPrimaryFrame();
52222:       if (!frame || frame->PresContext()->PresShell()->IsDestroying()) {
52222:         // We're being destroyed. Bail out.
52222:         return;
52222:       }
52222: 
52222:       mVectorImage->InvalidateObserver();
52222:     }
52222: 
52222:     // Our caller might've removed us from rendering-observer list.
52222:     // Add ourselves back!
52222:     if (!mInObserverList) {
52222:       nsSVGEffects::AddRenderingObserver(elem, this);
52222:       mInObserverList = PR_TRUE;
52222:     }
52222:   }
52222: 
52222:   // Private data
52222:   nsRefPtr<SVGDocumentWrapper> mDocWrapper;
52222:   VectorImage* mVectorImage;   // Raw pointer because it owns me.
52222: };
52222: 
52221: // Helper-class: SVGDrawingCallback
52221: class SVGDrawingCallback : public gfxDrawingCallback {
52221: public:
52221:   SVGDrawingCallback(SVGDocumentWrapper* aSVGDocumentWrapper,
52221:                      const nsIntRect& aViewport,
52221:                      PRUint32 aImageFlags) :
52221:     mSVGDocumentWrapper(aSVGDocumentWrapper),
52221:     mViewport(aViewport),
52221:     mImageFlags(aImageFlags)
52221:   {}
52221:   virtual PRBool operator()(gfxContext* aContext,
52221:                             const gfxRect& aFillRect,
52221:                             const gfxPattern::GraphicsFilter& aFilter,
52221:                             const gfxMatrix& aTransform);
52221: private:
52221:   nsRefPtr<SVGDocumentWrapper> mSVGDocumentWrapper;
52221:   const nsIntRect mViewport;
52221:   PRUint32        mImageFlags;
52221: };
52221: 
52221: // Based loosely on nsSVGIntegrationUtils' PaintFrameCallback::operator()
52221: PRBool
52221: SVGDrawingCallback::operator()(gfxContext* aContext,
52221:                                const gfxRect& aFillRect,
52221:                                const gfxPattern::GraphicsFilter& aFilter,
52221:                                const gfxMatrix& aTransform)
52221: {
52221:   NS_ABORT_IF_FALSE(mSVGDocumentWrapper, "need an SVGDocumentWrapper");
52221: 
52221:   // Get (& sanity-check) the helper-doc's presShell
52221:   nsCOMPtr<nsIPresShell> presShell;
52221:   if (NS_FAILED(mSVGDocumentWrapper->GetPresShell(getter_AddRefs(presShell)))) {
52221:     NS_WARNING("Unable to draw -- presShell lookup failed");
52221:     return NS_ERROR_FAILURE;
52221:   }
52221:   NS_ABORT_IF_FALSE(presShell, "GetPresShell succeeded but returned null");
52221: 
61178:   gfxContextAutoSaveRestore contextRestorer(aContext);
52221: 
52221:   // Clip to aFillRect so that we don't paint outside.
52221:   aContext->NewPath();
52221:   aContext->Rectangle(aFillRect);
52221:   aContext->Clip();
52221: 
61178:   gfxContextMatrixAutoSaveRestore contextMatrixRestorer(aContext);
52221:   aContext->Multiply(gfxMatrix(aTransform).Invert());
52221: 
52221: 
52221:   nsPresContext* presContext = presShell->GetPresContext();
52221:   NS_ABORT_IF_FALSE(presContext, "pres shell w/out pres context");
52221: 
52221:   nsRect svgRect(presContext->DevPixelsToAppUnits(mViewport.x),
52221:                  presContext->DevPixelsToAppUnits(mViewport.y),
52221:                  presContext->DevPixelsToAppUnits(mViewport.width),
52221:                  presContext->DevPixelsToAppUnits(mViewport.height));
52221: 
52221:   PRUint32 renderDocFlags = nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING;
52221:   if (!(mImageFlags & imgIContainer::FLAG_SYNC_DECODE)) {
52221:     renderDocFlags |= nsIPresShell::RENDER_ASYNC_DECODE_IMAGES;
52221:   }
52221: 
52221:   presShell->RenderDocument(svgRect, renderDocFlags,
52221:                             NS_RGBA(0, 0, 0, 0), // transparent
52221:                             aContext);
52221: 
52221:   return PR_TRUE;
52221: }
52221: 
52221: // Implement VectorImage's nsISupports-inherited methods
52216: NS_IMPL_ISUPPORTS3(VectorImage,
52216:                    imgIContainer,
52216:                    nsIStreamListener,
52216:                    nsIRequestObserver)
52216: 
52216: //------------------------------------------------------------------------------
52216: // Constructor / Destructor
52216: 
52216: VectorImage::VectorImage(imgStatusTracker* aStatusTracker) :
52221:   Image(aStatusTracker), // invoke superclass's constructor
52221:   mRestrictedRegion(0, 0, 0, 0),
52221:   mLastRenderedSize(0, 0),
52221:   mIsInitialized(PR_FALSE),
52221:   mIsFullyLoaded(PR_FALSE),
57902:   mIsDrawing(PR_FALSE),
52221:   mHaveAnimations(PR_FALSE),
54949:   mHaveRestrictedRegion(PR_FALSE)
52216: {
52216: }
52216: 
52216: VectorImage::~VectorImage()
52216: {
52216: }
52216: 
52216: //------------------------------------------------------------------------------
52216: // Methods inherited from Image.h
52216: 
52216: nsresult
52216: VectorImage::Init(imgIDecoderObserver* aObserver,
52216:                   const char* aMimeType,
53660:                   const char* aURIString,
52216:                   PRUint32 aFlags)
52216: {
52221:   // We don't support re-initialization
52221:   if (mIsInitialized)
52221:     return NS_ERROR_ILLEGAL_VALUE;
52221: 
52221:   NS_ABORT_IF_FALSE(!mIsFullyLoaded && !mHaveAnimations &&
52221:                     !mHaveRestrictedRegion && !mError,
52221:                     "Flags unexpectedly set before initialization");
52221: 
52221:   mObserver = do_GetWeakReference(aObserver);
52221:   NS_ABORT_IF_FALSE(!strcmp(aMimeType, SVG_MIMETYPE), "Unexpected mimetype");
52221: 
52221:   mIsInitialized = PR_TRUE;
52221: 
52221:   return NS_OK;
52216: }
52216: 
52216: void
52216: VectorImage::GetCurrentFrameRect(nsIntRect& aRect)
52216: {
52306:   aRect = nsIntRect::GetMaxSizedIntRect();
52216: }
52216: 
52216: PRUint32
54949: VectorImage::GetDecodedDataSize()
52216: {
54949:   // XXXdholbert TODO: return num bytes used by helper SVG doc. (bug 590790)
52221:   return sizeof(*this);
52216: }
52216: 
54949: PRUint32
54949: VectorImage::GetSourceDataSize()
54949: {
54949:   // We're not storing the source data -- we just feed that directly to
54949:   // our helper SVG document as we receive it, for it to parse.
54949:   // So 0 is an appropriate return value here.
54949:   return 0;
54949: }
54949: 
52216: nsresult
52216: VectorImage::StartAnimation()
52216: {
52221:   if (mError)
52221:     return NS_ERROR_FAILURE;
52221: 
57656:   NS_ABORT_IF_FALSE(ShouldAnimate(), "Should not animate!");
52221: 
52221:   mSVGDocumentWrapper->StartAnimation();
52221:   return NS_OK;
52216: }
52216: 
52216: nsresult
52216: VectorImage::StopAnimation()
52216: {
52221:   if (mError)
52221:     return NS_ERROR_FAILURE;
52221: 
57656:   NS_ABORT_IF_FALSE(mIsFullyLoaded && mHaveAnimations,
57656:                     "Should not have been animating!");
57656: 
57656:   mSVGDocumentWrapper->StopAnimation();
52221:   return NS_OK;
52221: }
52221: 
57656: PRBool
57656: VectorImage::ShouldAnimate()
57656: {
57656:   return Image::ShouldAnimate() && mIsFullyLoaded && mHaveAnimations;
52216: }
52216: 
52216: //------------------------------------------------------------------------------
52216: // imgIContainer methods
52216: 
52216: //******************************************************************************
52216: /* readonly attribute PRInt32 width; */
52216: NS_IMETHODIMP
52216: VectorImage::GetWidth(PRInt32* aWidth)
52216: {
52221:   if (mError || !mIsFullyLoaded) {
54976:     *aWidth = 0;
52221:     return NS_ERROR_FAILURE;
52221:   }
52221: 
52221:   if (!mSVGDocumentWrapper->GetWidthOrHeight(SVGDocumentWrapper::eWidth,
52221:                                              *aWidth)) {
54976:     *aWidth = 0;
52221:     return NS_ERROR_FAILURE;
52221:   }
52221: 
52221:   return NS_OK;
52216: }
52216: 
52216: //******************************************************************************
52216: /* readonly attribute PRInt32 height; */
52216: NS_IMETHODIMP
52216: VectorImage::GetHeight(PRInt32* aHeight)
52216: {
52221:   if (mError || !mIsFullyLoaded) {
54976:     *aHeight = 0;
52221:     return NS_ERROR_FAILURE;
52221:   }
52221: 
52232:   if (!mSVGDocumentWrapper->GetWidthOrHeight(SVGDocumentWrapper::eHeight,
52221:                                              *aHeight)) {
54976:     *aHeight = 0;
52221:     return NS_ERROR_FAILURE;
52221:   }
52221: 
52221:   return NS_OK;
52216: }
52216: 
52216: //******************************************************************************
52216: /* readonly attribute unsigned short type; */
52216: NS_IMETHODIMP
52216: VectorImage::GetType(PRUint16* aType)
52216: {
58783:   NS_ENSURE_ARG_POINTER(aType);
58783: 
58783:   *aType = GetType();
52216:   return NS_OK;
52216: }
52216: 
52216: //******************************************************************************
58783: /* [noscript, notxpcom] PRUint16 GetType(); */
58783: NS_IMETHODIMP_(PRUint16)
58783: VectorImage::GetType()
58783: {
58783:   return imgIContainer::TYPE_VECTOR;
58783: }
58783: 
58783: //******************************************************************************
52216: /* readonly attribute boolean animated; */
52216: NS_IMETHODIMP
52216: VectorImage::GetAnimated(PRBool* aAnimated)
52216: {
52221:   if (mError || !mIsFullyLoaded)
52221:     return NS_ERROR_FAILURE;
52221: 
52221:   *aAnimated = mSVGDocumentWrapper->IsAnimated();
52221:   return NS_OK;
52216: }
52216: 
52216: //******************************************************************************
52216: /* readonly attribute boolean currentFrameIsOpaque; */
52216: NS_IMETHODIMP
52216: VectorImage::GetCurrentFrameIsOpaque(PRBool* aIsOpaque)
52216: {
52221:   NS_ENSURE_ARG_POINTER(aIsOpaque);
52221:   *aIsOpaque = PR_FALSE;   // In general, SVG content is not opaque.
52221:   return NS_OK;
52216: }
52216: 
52216: //******************************************************************************
52216: /* [noscript] gfxASurface getFrame(in PRUint32 aWhichFrame,
52216:  *                                 in PRUint32 aFlags; */
52216: NS_IMETHODIMP
52216: VectorImage::GetFrame(PRUint32 aWhichFrame,
52216:                       PRUint32 aFlags,
52216:                       gfxASurface** _retval)
52216: {
55363:   NS_ENSURE_ARG_POINTER(_retval);
55363:   nsRefPtr<gfxImageSurface> surface;
55363:   nsresult rv = CopyFrame(aWhichFrame, aFlags, getter_AddRefs(surface));
55363:   if (NS_SUCCEEDED(rv)) {
55363:     *_retval = surface.forget().get();
55363:   }
55363:   return rv;
52216: }
52216: 
52216: //******************************************************************************
52216: /* [noscript] gfxImageSurface copyFrame(in PRUint32 aWhichFrame,
52216:  *                                      in PRUint32 aFlags); */
52216: NS_IMETHODIMP
52216: VectorImage::CopyFrame(PRUint32 aWhichFrame,
52216:                        PRUint32 aFlags,
52216:                        gfxImageSurface** _retval)
52216: {
55363:   NS_ENSURE_ARG_POINTER(_retval);
55363:   // XXXdholbert NOTE: Currently assuming FRAME_CURRENT for simplicity.
55363:   // Could handle FRAME_FIRST by saving helper-doc current time, seeking
55363:   // to time 0, rendering, and then seeking to saved time.
52221:   if (aWhichFrame > FRAME_MAX_VALUE)
52221:     return NS_ERROR_INVALID_ARG;
52221: 
52221:   if (mError)
52221:     return NS_ERROR_FAILURE;
52221: 
55363:   // Look up height & width
55363:   // ----------------------
55363:   nsIntSize imageIntSize;
55363:   if (!mSVGDocumentWrapper->GetWidthOrHeight(SVGDocumentWrapper::eWidth,
55363:                                              imageIntSize.width) ||
55363:       !mSVGDocumentWrapper->GetWidthOrHeight(SVGDocumentWrapper::eHeight,
55363:                                              imageIntSize.height)) {
55363:     // We'll get here if our SVG doc has a percent-valued width or height.
55363:     return NS_ERROR_FAILURE;
55363:   }
55363: 
55363:   // Create a surface that we'll ultimately return
55363:   // ---------------------------------------------
55363:   // Make our surface the size of what will ultimately be drawn to it.
55363:   // (either the full image size, or the restricted region)
55363:   gfxIntSize surfaceSize;
55363:   if (mHaveRestrictedRegion) {
55363:     surfaceSize.width = mRestrictedRegion.width;
55363:     surfaceSize.height = mRestrictedRegion.height;
55363:   } else {
55363:     surfaceSize.width = imageIntSize.width;
55363:     surfaceSize.height = imageIntSize.height;
55363:   }
55363: 
55363:   nsRefPtr<gfxImageSurface> surface =
55363:     new gfxImageSurface(surfaceSize, gfxASurface::ImageFormatARGB32);
55363:   nsRefPtr<gfxContext> context = new gfxContext(surface);
55363: 
55363:   // Draw to our surface!
55363:   // --------------------
55363:   nsresult rv = Draw(context, gfxPattern::FILTER_NEAREST, gfxMatrix(),
55363:                      gfxRect(gfxPoint(0,0), gfxIntSize(imageIntSize.width,
55363:                                                        imageIntSize.height)),
55363:                      nsIntRect(nsIntPoint(0,0), imageIntSize),
55363:                      imageIntSize, aFlags);
55363:   if (NS_SUCCEEDED(rv)) {
55363:     *_retval = surface.forget().get();
55363:   }
55363: 
55363:   return rv;
52216: }
52216: 
52216: //******************************************************************************
52216: /* [noscript] imgIContainer extractFrame(PRUint32 aWhichFrame,
52216:  *                                       [const] in nsIntRect aRegion,
52216:  *                                       in PRUint32 aFlags); */
52216: NS_IMETHODIMP
52216: VectorImage::ExtractFrame(PRUint32 aWhichFrame,
52216:                           const nsIntRect& aRegion,
52216:                           PRUint32 aFlags,
52216:                           imgIContainer** _retval)
52216: {
52221:   NS_ENSURE_ARG_POINTER(_retval);
52221:   if (mError || !mIsFullyLoaded)
52221:     return NS_ERROR_FAILURE;
52221: 
52221:   // XXXdholbert NOTE: This method assumes FRAME_CURRENT (not FRAME_FIRST)
52221:   // right now, because mozilla doesn't actually contain any clients of this
52221:   // method that use FRAME_FIRST.  If it's needed, we *could* handle
52221:   // FRAME_FIRST by saving the helper-doc's current SMIL time, seeking it to
52221:   // time 0, rendering to a RasterImage, and then restoring our saved time.
52221:   if (aWhichFrame != FRAME_CURRENT) {
52221:     NS_WARNING("VectorImage::ExtractFrame with something other than "
52221:                "FRAME_CURRENT isn't supported yet. Assuming FRAME_CURRENT.");
52221:   }
52221: 
52221:   // XXXdholbert This method also doesn't actually freeze animation in the
52221:   // returned imgIContainer, because it shares our helper-document. To
52221:   // get a true snapshot, we need to clone the document - see bug 590792.
52221: 
52221:   // Make a new container with same SVG document.
52221:   nsRefPtr<VectorImage> extractedImg = new VectorImage();
52221:   extractedImg->mSVGDocumentWrapper = mSVGDocumentWrapper;
52221:   extractedImg->mAnimationMode = kDontAnimMode;
52221: 
52221:   extractedImg->mRestrictedRegion.x = aRegion.x;
52221:   extractedImg->mRestrictedRegion.y = aRegion.y;
52221: 
52221:   // (disallow negative width/height on our restricted region)
52221:   extractedImg->mRestrictedRegion.width  = NS_MAX(aRegion.width,  0);
52221:   extractedImg->mRestrictedRegion.height = NS_MAX(aRegion.height, 0);
52221: 
52221:   extractedImg->mIsInitialized = PR_TRUE;
52221:   extractedImg->mIsFullyLoaded = PR_TRUE;
52221:   extractedImg->mHaveRestrictedRegion = PR_TRUE;
52221: 
52221:   *_retval = extractedImg.forget().get();
52221:   return NS_OK;
52216: }
52216: 
52216: 
52216: //******************************************************************************
52216: /* [noscript] void draw(in gfxContext aContext,
52216:  *                      in gfxGraphicsFilter aFilter,
52216:  *                      [const] in gfxMatrix aUserSpaceToImageSpace,
52216:  *                      [const] in gfxRect aFill,
52216:  *                      [const] in nsIntRect aSubimage,
52216:  *                      [const] in nsIntSize aViewportSize,
52216:  *                      in PRUint32 aFlags); */
52216: NS_IMETHODIMP
52216: VectorImage::Draw(gfxContext* aContext,
52216:                   gfxPattern::GraphicsFilter aFilter,
52216:                   const gfxMatrix& aUserSpaceToImageSpace,
52216:                   const gfxRect& aFill,
52216:                   const nsIntRect& aSubimage,
52216:                   const nsIntSize& aViewportSize,
52216:                   PRUint32 aFlags)
52216: {
57902:   NS_ENSURE_ARG_POINTER(aContext);
52221:   if (mError || !mIsFullyLoaded)
52221:     return NS_ERROR_FAILURE;
52221: 
57902:   if (mIsDrawing) {
57902:     NS_WARNING("Refusing to make re-entrant call to VectorImage::Draw");
57902:     return NS_ERROR_FAILURE;
57902:   }
57902:   mIsDrawing = PR_TRUE;
52221: 
52221:   if (aViewportSize != mLastRenderedSize) {
52221:     mSVGDocumentWrapper->UpdateViewportBounds(aViewportSize);
52221:     mLastRenderedSize = aViewportSize;
52221:   }
62243:   mSVGDocumentWrapper->FlushImageTransformInvalidation();
52221: 
52221:   nsIntSize imageSize = mHaveRestrictedRegion ?
52221:     mRestrictedRegion.Size() : aViewportSize;
52221: 
52221:   // XXXdholbert Do we need to convert image size from
52221:   // CSS pixels to dev pixels here? (is gfxCallbackDrawable's 2nd arg in dev
52221:   // pixels?)
52221:   gfxIntSize imageSizeGfx(imageSize.width, imageSize.height);
52221: 
52221:   // Based on imgFrame::Draw
52221:   gfxRect sourceRect = aUserSpaceToImageSpace.Transform(aFill);
52221:   gfxRect imageRect(0, 0, imageSize.width, imageSize.height);
52221:   gfxRect subimage(aSubimage.x, aSubimage.y, aSubimage.width, aSubimage.height);
52221: 
52221: 
52221:   nsRefPtr<gfxDrawingCallback> cb =
52221:     new SVGDrawingCallback(mSVGDocumentWrapper,
52221:                            mHaveRestrictedRegion ?
52221:                            mRestrictedRegion :
52221:                            nsIntRect(nsIntPoint(0, 0), aViewportSize),
52221:                            aFlags);
52221: 
52221:   nsRefPtr<gfxDrawable> drawable = new gfxCallbackDrawable(cb, imageSizeGfx);
52221: 
52221:   gfxUtils::DrawPixelSnapped(aContext, drawable,
52221:                              aUserSpaceToImageSpace,
52221:                              subimage, sourceRect, imageRect, aFill,
52221:                              gfxASurface::ImageFormatARGB32, aFilter);
52221: 
57902:   mIsDrawing = PR_FALSE;
52221:   return NS_OK;
52216: }
52216: 
52216: //******************************************************************************
52216: /* [notxpcom] nsIFrame GetRootLayoutFrame() */
52216: nsIFrame*
52216: VectorImage::GetRootLayoutFrame()
52216: {
70350:   if (mError)
70350:     return nsnull;
70350: 
52221:   return mSVGDocumentWrapper->GetRootLayoutFrame();
52216: }
52216: 
52216: //******************************************************************************
52216: /* void requestDecode() */
52216: NS_IMETHODIMP
52216: VectorImage::RequestDecode()
52216: {
52216:   // Nothing to do for SVG images
52216:   return NS_OK;
52216: }
52216: 
52216: //******************************************************************************
52216: /* void lockImage() */
52216: NS_IMETHODIMP
52216: VectorImage::LockImage()
52216: {
52221:   // This method is for image-discarding, which only applies to RasterImages.
52221:   return NS_OK;
52216: }
52216: 
52216: //******************************************************************************
52216: /* void unlockImage() */
52216: NS_IMETHODIMP
52216: VectorImage::UnlockImage()
52216: {
52221:   // This method is for image-discarding, which only applies to RasterImages.
52221:   return NS_OK;
52216: }
52216: 
52216: //******************************************************************************
52216: /* void resetAnimation (); */
52216: NS_IMETHODIMP
52216: VectorImage::ResetAnimation()
52216: {
52221:   if (mError)
52221:     return NS_ERROR_FAILURE;
52221: 
52221:   if (!mIsFullyLoaded || !mHaveAnimations) {
52221:     return NS_OK; // There are no animations to be reset.
52221:   }
52221: 
52221:   mSVGDocumentWrapper->ResetAnimation();
52221: 
52221:   return NS_OK;
52216: }
52216: 
52216: //------------------------------------------------------------------------------
52216: // nsIRequestObserver methods
52216: 
52216: //******************************************************************************
52216: /* void onStartRequest(in nsIRequest request, in nsISupports ctxt); */
52216: NS_IMETHODIMP
52216: VectorImage::OnStartRequest(nsIRequest* aRequest, nsISupports* aCtxt)
52216: {
52221:   NS_ABORT_IF_FALSE(!mSVGDocumentWrapper,
52221:                     "Repeated call to OnStartRequest -- can this happen?");
52221: 
52221:   mSVGDocumentWrapper = new SVGDocumentWrapper();
52221:   nsresult rv = mSVGDocumentWrapper->OnStartRequest(aRequest, aCtxt);
52221:   if (NS_FAILED(rv)) {
52221:     mSVGDocumentWrapper = nsnull;
52221:     mError = PR_TRUE;
52221:   }
52221: 
52221:   return rv;
52216: }
52216: 
52216: //******************************************************************************
52216: /* void onStopRequest(in nsIRequest request, in nsISupports ctxt,
52216:                       in nsresult status); */
52216: NS_IMETHODIMP
52216: VectorImage::OnStopRequest(nsIRequest* aRequest, nsISupports* aCtxt,
52216:                            nsresult aStatus)
52216: {
52221:   if (mError)
52221:     return NS_ERROR_FAILURE;
52221: 
52221:   NS_ABORT_IF_FALSE(!mIsFullyLoaded && !mHaveAnimations,
52221:                     "these flags shouldn't get set until OnStopRequest. "
52221:                     "Duplicate calls to OnStopRequest?");
52221: 
52221:   nsresult rv = mSVGDocumentWrapper->OnStopRequest(aRequest, aCtxt, aStatus);
52221:   if (!mSVGDocumentWrapper->ParsedSuccessfully()) {
52221:     // XXXdholbert Need to do something more here -- right now, this just
52221:     // makes us draw the "object" icon, rather than the (jagged) "broken image"
52221:     // icon.  See bug 594505.
52221:     mError = PR_TRUE;
52221:     return rv;
52221:   }
52221: 
52221:   mIsFullyLoaded = PR_TRUE;
52221:   mHaveAnimations = mSVGDocumentWrapper->IsAnimated();
52221: 
52222:   // Start listening to our image for rendering updates
52222:   mRenderingObserver = new SVGRootRenderingObserver(mSVGDocumentWrapper, this);
52222: 
52222:   // Tell *our* observers that we're done loading
52221:   nsCOMPtr<imgIDecoderObserver> observer = do_QueryReferent(mObserver);
52221:   if (observer) {
52221:     // NOTE: This signals that width/height are available.
52221:     observer->OnStartContainer(nsnull, this);
52221: 
52306:     observer->FrameChanged(this, &nsIntRect::GetMaxSizedIntRect());
52221:     observer->OnStopFrame(nsnull, 0);
52221:     observer->OnStopDecode(nsnull, NS_OK, nsnull);
52221:   }
59475:   EvaluateAnimation();
52221: 
52221:   return rv;
52216: }
52216: 
52216: //------------------------------------------------------------------------------
52216: // nsIStreamListener method
52216: 
52216: //******************************************************************************
52216: /* void onDataAvailable(in nsIRequest request, in nsISupports ctxt,
52216:                         in nsIInputStream inStr, in unsigned long sourceOffset,
52216:                         in unsigned long count); */
52216: NS_IMETHODIMP
52216: VectorImage::OnDataAvailable(nsIRequest* aRequest, nsISupports* aCtxt,
52216:                              nsIInputStream* aInStr, PRUint32 aSourceOffset,
52216:                              PRUint32 aCount)
52216: {
70350:   if (mError)
70350:     return NS_ERROR_FAILURE;
70350: 
52221:   return mSVGDocumentWrapper->OnDataAvailable(aRequest, aCtxt, aInStr,
52221:                                               aSourceOffset, aCount);
52216: }
52216: 
52222: // --------------------------
52222: // Invalidation helper method
52222: 
52222: void
52222: VectorImage::InvalidateObserver()
52222: {
69097:   if (!mObserver)
69097:     return;
69097: 
69097:   nsCOMPtr<imgIContainerObserver> containerObs(do_QueryReferent(mObserver));
69097:   if (containerObs) {
69097:     containerObs->FrameChanged(this, &nsIntRect::GetMaxSizedIntRect());
69097:   }
69097: 
69097:   nsCOMPtr<imgIDecoderObserver> decoderObs(do_QueryReferent(mObserver));
69097:   if (decoderObs) {
69097:     decoderObs->OnStopFrame(nsnull, imgIContainer::FRAME_CURRENT);
52222:   }
52222: }
52222: 
52216: } // namespace imagelib
52216: } // namespace mozilla
