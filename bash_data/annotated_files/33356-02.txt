    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Blake Ross <blakeross@telocity.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsTextControlFrame.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMNSHTMLTextAreaElement.h"
    1: #include "nsIDOMNSHTMLInputElement.h"
    1: #include "nsIFormControl.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsIPlaintextEditor.h"
    1: #include "nsEditorCID.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsIDocumentEncoder.h"
15969: #include "nsCaret.h"
    1: #include "nsISelectionListener.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsIController.h"
    1: #include "nsIControllers.h"
    1: #include "nsIControllerContext.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsIEditorIMESupport.h"
    1: #include "nsIPhonetic.h"
    1: #include "nsIEditorObserver.h"
    1: #include "nsIDOMHTMLTextAreaElement.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsIScrollableFrame.h" //to turn off scroll bars
    1: #include "nsFormControlFrame.h" //for registering accesskeys
    1: #include "nsIDeviceContext.h" // to measure fonts
    1: 
    1: #include "nsIContent.h"
    1: #include "nsIAtom.h"
    1: #include "nsPresContext.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIDOMHTMLInputElement.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIComponentManager.h"
    1: 
    1: #include "nsBoxLayoutState.h"
    1: //for keylistener for "return" check
    1: #include "nsIPrivateDOMEvent.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDocument.h" //observe documents to send onchangenotifications
    1: #include "nsIStyleSheet.h"//observe documents to send onchangenotifications
    1: #include "nsIStyleRule.h"//observe documents to send onchangenotifications
    1: #include "nsIDOMEventListener.h"//observe documents to send onchangenotifications
    1: #include "nsGUIEvent.h"
    1: #include "nsIDOMEventGroup.h"
    1: #include "nsIDOM3EventTarget.h"
    1: #include "nsIDOMNSEvent.h"
    1: #include "nsIDOMNSUIEvent.h"
    1: #include "nsIEventStateManager.h"
    1: 
    1: #include "nsIDOMFocusListener.h" //onchange events
    1: #include "nsIDOMCharacterData.h" //for selection setting helper func
    1: #include "nsIDOMNodeList.h" //for selection setting helper func
    1: #include "nsIDOMRange.h" //for selection setting helper func
    1: #include "nsPIDOMWindow.h" //needed for notify selection changed to update the menus ect.
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #endif
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsITextControlElement.h"
    1: 
    1: #include "nsIEditorObserver.h"
    1: #include "nsITransactionManager.h"
    1: #include "nsIDOMText.h" //for multiline getselection
    1: #include "nsNodeInfoManager.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsIDOMKeyListener.h"
    1: #include "nsIDOMEventGroup.h"
    1: #include "nsIDOM3EventTarget.h"
    1: #include "nsINativeKeyBindings.h"
    1: #include "nsIJSContextStack.h"
29018: #include "nsFocusManager.h"
    1: 
    1: #define DEFAULT_COLUMN_WIDTH 20
    1: 
    1: #include "nsContentCID.h"
    1: static NS_DEFINE_IID(kRangeCID,     NS_RANGE_CID);
    1: 
    1: static NS_DEFINE_CID(kTextEditorCID, NS_TEXTEDITOR_CID);
    1: static NS_DEFINE_CID(kFrameSelectionCID, NS_FRAMESELECTION_CID);
    1: 
    1: static const PRInt32 DEFAULT_COLS = 20;
    1: static const PRInt32 DEFAULT_ROWS = 1;
    1: static const PRInt32 DEFAULT_ROWS_TEXTAREA = 2;
    1: static const PRInt32 DEFAULT_UNDO_CAP = 1000;
    1: 
    1: static nsINativeKeyBindings *sNativeInputBindings = nsnull;
    1: static nsINativeKeyBindings *sNativeTextAreaBindings = nsnull;
    1: 
    1: static void
    1: PlatformToDOMLineBreaks(nsString &aString)
    1: {
    1:   // Windows linebreaks: Map CRLF to LF:
    1:   aString.ReplaceSubstring(NS_LITERAL_STRING("\r\n").get(),
    1:                            NS_LITERAL_STRING("\n").get());
    1: 
    1:   // Mac linebreaks: Map any remaining CR to LF:
    1:   aString.ReplaceSubstring(NS_LITERAL_STRING("\r").get(),
    1:                            NS_LITERAL_STRING("\n").get());
    1: }
    1: 
    1: // wrap can be one of these three values.  
    1: typedef enum {
    1:   eHTMLTextWrap_Off     = 1,    // "off"
    1:   eHTMLTextWrap_Hard    = 2,    // "hard"
    1:   eHTMLTextWrap_Soft    = 3     // the default
    1: } nsHTMLTextWrap;
    1: 
    1: static PRBool 
    1: GetWrapPropertyEnum(nsIContent* aContent, nsHTMLTextWrap& aWrapProp)
    1: {
    1:   // soft is the default; "physical" defaults to soft as well because all other
    1:   // browsers treat it that way and there is no real reason to maintain physical
    1:   // and virtual as separate entities if no one else does.  Only hard and off
    1:   // do anything different.
    1:   aWrapProp = eHTMLTextWrap_Soft; // the default
    1:   
    1:   nsAutoString wrap;
33329:   if (aContent->IsHTML()) {
    1:     static nsIContent::AttrValuesArray strings[] =
    1:       {&nsGkAtoms::HARD, &nsGkAtoms::OFF, nsnull};
    1: 
    1:     switch (aContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::wrap,
    1:                                       strings, eIgnoreCase)) {
    1:       case 0: aWrapProp = eHTMLTextWrap_Hard; break;
    1:       case 1: aWrapProp = eHTMLTextWrap_Off; break;
    1:     }
    1: 
    1:     return PR_TRUE;
    1:   }
    1:  
    1:   return PR_FALSE;
    1: }
    1: 
    1: class nsTextInputListener : public nsISelectionListener,
    1:                             public nsIDOMKeyListener,
    1:                             public nsIEditorObserver,
    1:                             public nsSupportsWeakReference
    1: {
    1: public:
    1:   /** the default constructor
    1:    */ 
    1:   nsTextInputListener();
    1:   /** the default destructor. virtual due to the possibility of derivation.
    1:    */
    1:   virtual ~nsTextInputListener();
    1: 
    1:   /** SetEditor gives an address to the editor that will be accessed
    1:    *  @param aEditor the editor this listener calls for editing operations
    1:    */
    1:   void SetFrame(nsTextControlFrame *aFrame){mFrame = aFrame;}
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_DECL_NSISELECTIONLISTENER
    1: 
    1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent);
    1: 
    1:   // nsIDOMKeyListener
    1:   NS_IMETHOD KeyDown(nsIDOMEvent *aKeyEvent);
    1:   NS_IMETHOD KeyPress(nsIDOMEvent *aKeyEvent);
    1:   NS_IMETHOD KeyUp(nsIDOMEvent *aKeyEvent);
    1: 
    1:   NS_DECL_NSIEDITOROBSERVER
    1: 
    1: protected:
    1: 
    1:   nsresult  UpdateTextInputCommands(const nsAString& commandsToUpdate);
    1: 
    1:   NS_HIDDEN_(nsINativeKeyBindings*) GetKeyBindings();
    1: 
    1: protected:
    1: 
    1:   nsTextControlFrame* mFrame;  // weak reference
    1:   
    1:   PRPackedBool    mSelectionWasCollapsed;
    1:   /**
    1:    * Whether we had undo items or not the last time we got EditAction()
    1:    * notification (when this state changes we update undo and redo menus)
    1:    */
    1:   PRPackedBool    mHadUndoItems;
    1:   /**
    1:    * Whether we had redo items or not the last time we got EditAction()
    1:    * notification (when this state changes we update undo and redo menus)
    1:    */
    1:   PRPackedBool    mHadRedoItems;
    1: };
    1: 
    1: 
    1: /*
    1:  * nsTextEditorListener implementation
    1:  */
    1: 
    1: nsTextInputListener::nsTextInputListener()
    1: : mFrame(nsnull)
    1: , mSelectionWasCollapsed(PR_TRUE)
    1: , mHadUndoItems(PR_FALSE)
    1: , mHadRedoItems(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsTextInputListener::~nsTextInputListener() 
    1: {
    1: }
    1: 
    1: NS_IMPL_ADDREF(nsTextInputListener)
    1: NS_IMPL_RELEASE(nsTextInputListener)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsTextInputListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsISelectionListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsIEditorObserver)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMKeyListener)
29018:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMKeyListener)
29018:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMKeyListener)
    1: NS_INTERFACE_MAP_END
    1: 
    1: // BEGIN nsIDOMSelectionListener
    1: 
29018: static PRBool
29018: IsFocusedContent(nsIContent* aContent)
29018: {
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (!fm)
29018:     return PR_FALSE;
29018: 
29018:   nsCOMPtr<nsIDOMElement> focusedElement;
29018:   fm->GetFocusedElement(getter_AddRefs(focusedElement));
29018:   nsCOMPtr<nsIContent> focusedContent = do_QueryInterface(focusedElement);
29018:   return (focusedContent == aContent);
29018: }
29018: 
    1: NS_IMETHODIMP
    1: nsTextInputListener::NotifySelectionChanged(nsIDOMDocument* aDoc, nsISelection* aSel, PRInt16 aReason)
    1: {
    1:   PRBool collapsed;
    1:   if (!mFrame || !aDoc || !aSel || NS_FAILED(aSel->GetIsCollapsed(&collapsed)))
    1:     return NS_OK;
    1: 
    1:   // Fire the select event
    1:   // The specs don't exactly say when we should fire the select event.
    1:   // IE: Whenever you add/remove a character to/from the selection. Also
    1:   //     each time for select all. Also if you get to the end of the text 
    1:   //     field you will get new event for each keypress or a continuous 
    1:   //     stream of events if you use the mouse. IE will fire select event 
    1:   //     when the selection collapses to nothing if you are holding down
    1:   //     the shift or mouse button.
    1:   // Mozilla: If we have non-empty selection we will fire a new event for each
    1:   //          keypress (or mouseup) if the selection changed. Mozilla will also
    1:   //          create the event each time select all is called, even if everything
    1:   //          was previously selected, becase technically select all will first collapse
    1:   //          and then extend. Mozilla will never create an event if the selection 
    1:   //          collapses to nothing.
    1:   if (!collapsed && (aReason & (nsISelectionListener::MOUSEUP_REASON | 
    1:                                 nsISelectionListener::KEYPRESS_REASON |
    1:                                 nsISelectionListener::SELECTALL_REASON)))
    1:   {
    1:     nsIContent* content = mFrame->GetContent();
    1:     if (content) 
    1:     {
    1:       nsCOMPtr<nsIDocument> doc = content->GetDocument();
    1:       if (doc) 
    1:       {
  981:         nsCOMPtr<nsIPresShell> presShell = doc->GetPrimaryShell();
    1:         if (presShell) 
    1:         {
    1:           nsEventStatus status = nsEventStatus_eIgnore;
    1:           nsEvent event(PR_TRUE, NS_FORM_SELECTED);
    1: 
    1:           presShell->HandleEventWithTarget(&event, mFrame, content, &status);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // if the collapsed state did not change, don't fire notifications
    1:   if (collapsed == mSelectionWasCollapsed)
    1:     return NS_OK;
    1:   
    1:   mSelectionWasCollapsed = collapsed;
    1: 
29018:   if (!mFrame || !IsFocusedContent(mFrame->GetContent()))
 5881:     return NS_OK;
 5881: 
    1:   return UpdateTextInputCommands(NS_LITERAL_STRING("select"));
    1: }
    1: 
    1: // END nsIDOMSelectionListener
    1: 
29018: // BEGIN nsIDOMKeyListener
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputListener::HandleEvent(nsIDOMEvent* aEvent)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: DoCommandCallback(const char *aCommand, void *aData)
    1: {
 3233:   nsTextControlFrame *frame = static_cast<nsTextControlFrame*>(aData);
    1:   nsIContent *content = frame->GetContent();
    1: 
    1:   nsCOMPtr<nsIControllers> controllers;
    1:   nsCOMPtr<nsIDOMNSHTMLInputElement> input = do_QueryInterface(content);
    1:   if (input) {
    1:     input->GetControllers(getter_AddRefs(controllers));
    1:   } else {
    1:     nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea =
    1:       do_QueryInterface(content);
    1: 
    1:     if (textArea) {
    1:       textArea->GetControllers(getter_AddRefs(controllers));
    1:     }
    1:   }
    1: 
    1:   if (!controllers) {
    1:     NS_WARNING("Could not get controllers");
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIController> controller;
    1:   controllers->GetControllerForCommand(aCommand, getter_AddRefs(controller));
    1:   if (controller) {
    1:     controller->DoCommand(aCommand);
    1:   }
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
20505: nsTextInputListener::KeyDown(nsIDOMEvent *aDOMEvent)
    1: {
20505:   nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aDOMEvent));
20505:   NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
20505: 
    1:   nsNativeKeyEvent nativeEvent;
    1:   nsINativeKeyBindings *bindings = GetKeyBindings();
    1:   if (bindings &&
20505:       nsContentUtils::DOMEventToNativeKeyEvent(keyEvent, &nativeEvent, PR_FALSE)) {
    1:     if (bindings->KeyDown(nativeEvent, DoCommandCallback, mFrame)) {
20505:       aDOMEvent->PreventDefault();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
20505: nsTextInputListener::KeyPress(nsIDOMEvent *aDOMEvent)
    1: {
20505:   nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aDOMEvent));
20505:   NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
20505: 
    1:   nsNativeKeyEvent nativeEvent;
    1:   nsINativeKeyBindings *bindings = GetKeyBindings();
    1:   if (bindings &&
20505:       nsContentUtils::DOMEventToNativeKeyEvent(keyEvent, &nativeEvent, PR_TRUE)) {
    1:     if (bindings->KeyPress(nativeEvent, DoCommandCallback, mFrame)) {
20505:       aDOMEvent->PreventDefault();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
20505: nsTextInputListener::KeyUp(nsIDOMEvent *aDOMEvent)
    1: {
20505:   nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aDOMEvent));
20505:   NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
20505: 
    1:   nsNativeKeyEvent nativeEvent;
    1:   nsINativeKeyBindings *bindings = GetKeyBindings();
    1:   if (bindings &&
20505:       nsContentUtils::DOMEventToNativeKeyEvent(keyEvent, &nativeEvent, PR_FALSE)) {
    1:     if (bindings->KeyUp(nativeEvent, DoCommandCallback, mFrame)) {
20505:       aDOMEvent->PreventDefault();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: // END nsIDOMKeyListener
    1: 
    1: // BEGIN nsIEditorObserver
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputListener::EditAction()
    1: {
    1:   //
    1:   // Update the undo / redo menus
    1:   //
    1:   nsCOMPtr<nsIEditor> editor;
    1:   mFrame->GetEditor(getter_AddRefs(editor));
    1: 
    1:   nsCOMPtr<nsITransactionManager> manager;
    1:   editor->GetTransactionManager(getter_AddRefs(manager));
    1:   NS_ENSURE_TRUE(manager, NS_ERROR_FAILURE);
    1: 
    1:   // Get the number of undo / redo items
    1:   PRInt32 numUndoItems = 0;
    1:   PRInt32 numRedoItems = 0;
    1:   manager->GetNumberOfUndoItems(&numUndoItems);
    1:   manager->GetNumberOfRedoItems(&numRedoItems);
19264:   if ((numUndoItems && !mHadUndoItems) || (!numUndoItems && mHadUndoItems) ||
19264:       (numRedoItems && !mHadRedoItems) || (!numRedoItems && mHadRedoItems)) {
    1:     // Modify the menu if undo or redo items are different
    1:     UpdateTextInputCommands(NS_LITERAL_STRING("undo"));
    1: 
    1:     mHadUndoItems = numUndoItems != 0;
    1:     mHadRedoItems = numRedoItems != 0;
    1:   }
    1: 
    1:   // Make sure we know we were changed (do NOT set this to false if there are
    1:   // no undo items; JS could change the value and we'd still need to save it)
    1:   mFrame->SetValueChanged(PR_TRUE);
    1: 
    1:   // Fire input event
    1:   mFrame->FireOnInput();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // END nsIEditorObserver
    1: 
    1: 
    1: nsresult
    1: nsTextInputListener::UpdateTextInputCommands(const nsAString& commandsToUpdate)
    1: {
    1:   NS_ENSURE_STATE(mFrame);
    1: 
    1:   nsIContent* content = mFrame->GetContent();
    1:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
    1:   
    1:   nsCOMPtr<nsIDocument> doc = content->GetDocument();
    1:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
    1: 
    1:   nsPIDOMWindow *domWindow = doc->GetWindow();
    1:   NS_ENSURE_TRUE(domWindow, NS_ERROR_FAILURE);
    1: 
    1:   return domWindow->UpdateCommands(commandsToUpdate);
    1: }
    1: 
    1: nsINativeKeyBindings*
    1: nsTextInputListener::GetKeyBindings()
    1: {
    1:   if (mFrame->IsTextArea()) {
    1:     static PRBool sNoTextAreaBindings = PR_FALSE;
    1: 
    1:     if (!sNativeTextAreaBindings && !sNoTextAreaBindings) {
    1:       CallGetService(NS_NATIVEKEYBINDINGS_CONTRACTID_PREFIX "textarea",
    1:                      &sNativeTextAreaBindings);
    1: 
    1:       if (!sNativeTextAreaBindings) {
    1:         sNoTextAreaBindings = PR_TRUE;
    1:       }
    1:     }
    1: 
    1:     return sNativeTextAreaBindings;
    1:   }
    1: 
    1:   static PRBool sNoInputBindings = PR_FALSE;
    1:   if (!sNativeInputBindings && !sNoInputBindings) {
    1:     CallGetService(NS_NATIVEKEYBINDINGS_CONTRACTID_PREFIX "input",
    1:                    &sNativeInputBindings);
    1: 
    1:     if (!sNativeInputBindings) {
    1:       sNoInputBindings = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return sNativeInputBindings;
    1: }
    1: 
    1: // END nsTextInputListener
    1: 
    1: class nsTextInputSelectionImpl : public nsSupportsWeakReference
    1:                                , public nsISelectionController
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   nsTextInputSelectionImpl(nsFrameSelection *aSel, nsIPresShell *aShell, nsIContent *aLimiter);
    1:   ~nsTextInputSelectionImpl(){}
    1: 
    1:   //NSISELECTIONCONTROLLER INTERFACES
    1:   NS_IMETHOD SetDisplaySelection(PRInt16 toggle);
    1:   NS_IMETHOD GetDisplaySelection(PRInt16 *_retval);
    1:   NS_IMETHOD SetSelectionFlags(PRInt16 aInEnable);
    1:   NS_IMETHOD GetSelectionFlags(PRInt16 *aOutEnable);
    1:   NS_IMETHOD GetSelection(PRInt16 type, nsISelection **_retval);
    1:   NS_IMETHOD ScrollSelectionIntoView(PRInt16 aType, PRInt16 aRegion, PRBool aIsSynchronous);
    1:   NS_IMETHOD RepaintSelection(PRInt16 type);
    1:   NS_IMETHOD RepaintSelection(nsPresContext* aPresContext, SelectionType aSelectionType);
    1:   NS_IMETHOD SetCaretEnabled(PRBool enabled);
    1:   NS_IMETHOD SetCaretReadOnly(PRBool aReadOnly);
    1:   NS_IMETHOD GetCaretEnabled(PRBool *_retval);
14068:   NS_IMETHOD GetCaretVisible(PRBool *_retval);
    1:   NS_IMETHOD SetCaretVisibilityDuringSelection(PRBool aVisibility);
    1:   NS_IMETHOD CharacterMove(PRBool aForward, PRBool aExtend);
20532:   NS_IMETHOD CharacterExtendForDelete();
    1:   NS_IMETHOD WordMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD WordExtendForDelete(PRBool aForward);
    1:   NS_IMETHOD LineMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD IntraLineMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD PageMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD CompleteScroll(PRBool aForward);
    1:   NS_IMETHOD CompleteMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD ScrollPage(PRBool aForward);
    1:   NS_IMETHOD ScrollLine(PRBool aForward);
    1:   NS_IMETHOD ScrollHorizontal(PRBool aLeft);
    1:   NS_IMETHOD SelectAll(void);
    1:   NS_IMETHOD CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, PRBool *_retval);
    1: 
    1: private:
    1:   nsCOMPtr<nsFrameSelection> mFrameSelection;
    1:   nsCOMPtr<nsIContent>        mLimiter;
    1:   nsWeakPtr mPresShellWeak;
    1: };
    1: 
    1: // Implement our nsISupports methods
13964: NS_IMPL_ISUPPORTS3(nsTextInputSelectionImpl,
13964:                    nsISelectionController,
13964:                    nsISelectionDisplay,
13964:                    nsISupportsWeakReference)
    1: 
    1: 
    1: // BEGIN nsTextInputSelectionImpl
    1: 
    1: nsTextInputSelectionImpl::nsTextInputSelectionImpl(nsFrameSelection *aSel, nsIPresShell *aShell, nsIContent *aLimiter)
    1: {
    1:   if (aSel && aShell)
    1:   {
    1:     mFrameSelection = aSel;//we are the owner now!
    1:     mLimiter = aLimiter;
    1:     mFrameSelection->Init(aShell, mLimiter);
    1:     mPresShellWeak = do_GetWeakReference(aShell);
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::SetDisplaySelection(PRInt16 aToggle)
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   mFrameSelection->SetDisplaySelection(aToggle);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::GetDisplaySelection(PRInt16 *aToggle)
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aToggle = mFrameSelection->GetDisplaySelection();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::SetSelectionFlags(PRInt16 aToggle)
    1: {
    1:   return NS_OK;//stub this out. not used in input
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::GetSelectionFlags(PRInt16 *aOutEnable)
    1: {
    1:   *aOutEnable = nsISelectionDisplay::DISPLAY_TEXT;
    1:   return NS_OK; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::GetSelection(PRInt16 type, nsISelection **_retval)
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1:     
    1:   *_retval = mFrameSelection->GetSelection(type);
    1:   
    1:   if (!(*_retval))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::ScrollSelectionIntoView(PRInt16 aType, PRInt16 aRegion, PRBool aIsSynchronous)
    1: {
    1:   if (mFrameSelection) {
12392:     // After ScrollSelectionIntoView(), the pending notifications might be
12392:     // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
    1:     nsresult rv = mFrameSelection->ScrollSelectionIntoView(aType, aRegion, aIsSynchronous);
    1: 
    1:     nsIScrollableView* scrollableView = mFrameSelection->GetScrollableView();
    1:     if (!scrollableView) {
    1:       return rv;
    1:     }
    1:     nsIView* view = nsnull;
    1:     scrollableView->GetScrolledView(view);
    1:     if (!view) {
    1:       return rv;
    1:     }
    1:     const nsRect portRect = scrollableView->View()->GetBounds();
    1:     const nsRect viewRect = view->GetBounds();
    1:     if (viewRect.XMost() < portRect.width) {
32531:       return scrollableView->ScrollTo(NS_MAX(viewRect.width - portRect.width, 0), -viewRect.y, 0);
    1:     }
    1: 
    1:     return rv;
    1:   }
    1:   return NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::RepaintSelection(PRInt16 type)
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mFrameSelection->RepaintSelection(type);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::RepaintSelection(nsPresContext* aPresContext, SelectionType aSelectionType)
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mFrameSelection->RepaintSelection(aSelectionType);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::SetCaretEnabled(PRBool enabled)
    1: {
    1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak);
    1:   if (!shell) return NS_ERROR_FAILURE;
    1: 
    1:   // tell the pres shell to enable the caret, rather than settings its visibility directly.
    1:   // this way the presShell's idea of caret visibility is maintained.
    1:   nsCOMPtr<nsISelectionController> selCon = do_QueryInterface(shell);
    1:   if (!selCon) return NS_ERROR_NO_INTERFACE;
    1:   selCon->SetCaretEnabled(enabled);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::SetCaretReadOnly(PRBool aReadOnly)
    1: {
    1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
    1:   nsresult result;
    1:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
    1:   if (shell)
    1:   {
15969:     nsRefPtr<nsCaret> caret;
    1:     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))))
    1:     {
    1:       nsISelection* domSel = mFrameSelection->
    1:         GetSelection(nsISelectionController::SELECTION_NORMAL);
    1:       if (domSel)
15969:         caret->SetCaretReadOnly(aReadOnly);
15969:       return NS_OK;
    1:     }
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::GetCaretEnabled(PRBool *_retval)
    1: {
14068:   return GetCaretVisible(_retval);
14068: }
14068: 
14068: NS_IMETHODIMP
14068: nsTextInputSelectionImpl::GetCaretVisible(PRBool *_retval)
14068: {
    1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
    1:   nsresult result;
    1:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
    1:   if (shell)
    1:   {
15969:     nsRefPtr<nsCaret> caret;
    1:     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))))
    1:     {
    1:       nsISelection* domSel = mFrameSelection->
    1:         GetSelection(nsISelectionController::SELECTION_NORMAL);
    1:       if (domSel)
    1:         return caret->GetCaretVisible(_retval);
    1:     }
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::SetCaretVisibilityDuringSelection(PRBool aVisibility)
    1: {
    1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
    1:   nsresult result;
    1:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
    1:   if (shell)
    1:   {
15969:     nsRefPtr<nsCaret> caret;
    1:     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))))
    1:     {
    1:       nsISelection* domSel = mFrameSelection->
    1:         GetSelection(nsISelectionController::SELECTION_NORMAL);
    1:       if (domSel)
15969:         caret->SetVisibilityDuringSelection(aVisibility);
15969:       return NS_OK;
    1:     }
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::CharacterMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   if (mFrameSelection)
    1:     return mFrameSelection->CharacterMove(aForward, aExtend);
    1:   return NS_ERROR_NULL_POINTER;
    1: }
    1: 
20532: NS_IMETHODIMP
20532: nsTextInputSelectionImpl::CharacterExtendForDelete()
20532: {
20532:   if (mFrameSelection)
20532:     return mFrameSelection->CharacterExtendForDelete();
20532:   return NS_ERROR_NULL_POINTER;
20532: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::WordMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   if (mFrameSelection)
    1:     return mFrameSelection->WordMove(aForward, aExtend);
    1:   return NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::WordExtendForDelete(PRBool aForward)
    1: {
    1:   if (mFrameSelection)
    1:     return mFrameSelection->WordExtendForDelete(aForward);
    1:   return NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::LineMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   if (mFrameSelection)
    1:   {
    1:     nsresult result = mFrameSelection->LineMove(aForward, aExtend);
    1:     if (NS_FAILED(result))
    1:       result = CompleteMove(aForward,aExtend);
    1:     return result;
    1:   }
    1:   return NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::IntraLineMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   if (mFrameSelection)
    1:     return mFrameSelection->IntraLineMove(aForward, aExtend);
    1:   return NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::PageMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   // expected behavior for PageMove is to scroll AND move the caret
    1:   // and to remain relative position of the caret in view. see Bug 4302.
    1: 
    1:   if (mPresShellWeak)
    1:   {
    1:     nsCOMPtr<nsIPresShell> presShell = do_QueryReferent(mPresShellWeak);
    1:     if (!presShell)
    1:       return NS_ERROR_NULL_POINTER;
    1: 
    1:     //get the scroll view
    1:     nsIScrollableView *scrollableView = mFrameSelection->GetScrollableView();
    1:     if (scrollableView)
    1:       mFrameSelection->CommonPageMove(aForward, aExtend, scrollableView);
    1:   }
12392:   // After ScrollSelectionIntoView(), the pending notifications might be
12392:   // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
    1:   return ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL, nsISelectionController::SELECTION_FOCUS_REGION, PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::CompleteScroll(PRBool aForward)
    1: {
    1:   nsIScrollableView *scrollableView = mFrameSelection->GetScrollableView();
    1: 
    1:   if (!scrollableView)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   return scrollableView->ScrollByWhole(!aForward); //TRUE = top, aForward TRUE=bottom
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::CompleteMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   // grab the parent / root DIV for this text widget
    1:   nsIContent* parentDIV = mFrameSelection->GetLimiter();
    1:   if (!parentDIV)
    1:     return NS_ERROR_UNEXPECTED;
    1: 
    1:   // make the caret be either at the very beginning (0) or the very end
    1:   PRInt32 offset = 0;
    1:   nsFrameSelection::HINT hint = nsFrameSelection::HINTLEFT;
    1:   if (aForward)
    1:   {
    1:     offset = parentDIV->GetChildCount();
    1: 
    1:     // Prevent the caret from being placed after the last
    1:     // BR node in the content tree!
    1: 
    1:     if (offset > 0)
    1:     {
    1:       nsIContent *child = parentDIV->GetChildAt(offset - 1);
    1: 
    1:       if (child->Tag() == nsGkAtoms::br)
    1:       {
    1:         --offset;
    1:         hint = nsFrameSelection::HINTRIGHT; // for Bug 106855
    1:       }
    1:     }
    1:   }
    1: 
    1:   mFrameSelection->HandleClick(parentDIV, offset, offset, aExtend,
    1:                                PR_FALSE, hint);
    1: 
    1:   // if we got this far, attempt to scroll no matter what the above result is
    1:   return CompleteScroll(aForward);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::ScrollPage(PRBool aForward)
    1: {
    1:   nsIScrollableView *scrollableView = mFrameSelection->GetScrollableView();
    1:   if (!scrollableView)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   return scrollableView->ScrollByPages(0, aForward ? 1 : -1);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::ScrollLine(PRBool aForward)
    1: {
    1:   nsIScrollableView *scrollableView = mFrameSelection->GetScrollableView();
    1:   if (!scrollableView)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   // will we have bug #7354 because we aren't forcing an update here?
    1:   return scrollableView->ScrollByLines(0, aForward ? 1 : -1);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::ScrollHorizontal(PRBool aLeft)
    1: {
    1:   nsIScrollableView *scrollableView = mFrameSelection->GetScrollableView();
    1:   if (!scrollableView)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   // will we have bug #7354 because we aren't forcing an update here?
    1:   return scrollableView->ScrollByLines(aLeft ? -1 : 1, 0);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::SelectAll()
    1: {
    1:   if (mFrameSelection)
    1:     return mFrameSelection->SelectAll();
    1:   return NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextInputSelectionImpl::CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, PRBool *_retval)
    1: {
    1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
    1:   nsresult result;
    1:   nsCOMPtr<nsISelectionController> shell = do_QueryReferent(mPresShellWeak, &result);
    1:   if (shell)
    1:   {
    1:     return shell->CheckVisibility(node,startOffset,EndOffset, _retval);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: 
    1: }
    1: 
    1: nsIFrame*
    1: NS_NewTextControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsTextControlFrame(aPresShell, aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsTextControlFrame)
32423: 
23554: NS_QUERYFRAME_HEAD(nsTextControlFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIFormControlFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)
23554:   NS_QUERYFRAME_ENTRY(nsITextControlFrame)
32423:   NS_QUERYFRAME_ENTRY_CONDITIONAL(nsIScrollableViewProvider, IsScrollable())
23554: NS_QUERYFRAME_TAIL_INHERITING(nsBoxFrame)
    1: 
    1: #ifdef ACCESSIBILITY
    1: NS_IMETHODIMP nsTextControlFrame::GetAccessible(nsIAccessible** aAccessible)
    1: {
    1:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
    1: 
    1:   if (accService) {
 3233:     return accService->CreateHTMLTextFieldAccessible(static_cast<nsIFrame*>(this), aAccessible);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: #endif
    1: 
    1: nsTextControlFrame::nsTextControlFrame(nsIPresShell* aShell, nsStyleContext* aContext)
    1:   : nsStackFrame(aShell, aContext)
    1:   , mUseEditor(PR_FALSE)
    1:   , mIsProcessing(PR_FALSE)
    1:   , mNotifyOnInput(PR_TRUE)
    1:   , mDidPreDestroy(PR_FALSE)
    1:   , mFireChangeEventState(PR_FALSE)
 6348:   , mInSecureKeyboardInputMode(PR_FALSE)
    1:   , mTextListener(nsnull)
    1: {
    1: }
    1: 
    1: nsTextControlFrame::~nsTextControlFrame()
    1: {
    1:   NS_IF_RELEASE(mTextListener);
    1: }
    1: 
    1: static PRBool
    1: SuppressEventHandlers(nsPresContext* aPresContext)
    1: {
    1:   PRBool suppressHandlers = PR_FALSE;
    1: 
    1:   if (aPresContext)
    1:   {
    1:     // Right now we only suppress event handlers and controller manipulation
    1:     // when in a print preview or print context!
    1: 
    1:     // In the current implementation, we only paginate when
    1:     // printing or in print preview.
    1: 
    1:     suppressHandlers = aPresContext->IsPaginated();
    1:   }
    1: 
    1:   return suppressHandlers;
    1: }
    1: 
    1: void
    1: nsTextControlFrame::PreDestroy()
    1: {
    1:   // notify the editor that we are going away
    1:   if (mEditor)
    1:   {
    1:     // If we were in charge of state before, relinquish it back
    1:     // to the control.
    1:     if (mUseEditor)
    1:     {
    1:       // First get the frame state from the editor
    1:       nsAutoString value;
    1:       GetValue(value, PR_TRUE);
    1: 
    1:       mUseEditor = PR_FALSE;
    1: 
    1:       // Next store the frame state in the control
    1:       // (now that mUseEditor is false values get stored
    1:       // in content).
    1:       SetValue(value);
    1:     }
22729:     mEditor->PreDestroy(PR_TRUE);
    1:   }
    1:   
    1:   // Clean up the controller
    1: 
  238:   if (!SuppressEventHandlers(PresContext()))
    1:   {
    1:     nsCOMPtr<nsIControllers> controllers;
    1:     nsCOMPtr<nsIDOMNSHTMLInputElement> inputElement = do_QueryInterface(mContent);
    1:     if (inputElement)
    1:       inputElement->GetControllers(getter_AddRefs(controllers));
    1:     else
    1:     {
    1:       nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textAreaElement = do_QueryInterface(mContent);
    1:       if (textAreaElement) {
    1:         textAreaElement->GetControllers(getter_AddRefs(controllers));
    1:       }
    1:     }
    1: 
    1:     if (controllers)
    1:     {
    1:       PRUint32 numControllers;
    1:       nsresult rv = controllers->GetControllerCount(&numControllers);
    1:       NS_ASSERTION((NS_SUCCEEDED(rv)), "bad result in gfx text control destructor");
    1:       for (PRUint32 i = 0; i < numControllers; i ++)
    1:       {
    1:         nsCOMPtr<nsIController> controller;
    1:         rv = controllers->GetControllerAt(i, getter_AddRefs(controller));
    1:         if (NS_SUCCEEDED(rv) && controller)
    1:         {
    1:           nsCOMPtr<nsIControllerContext> editController = do_QueryInterface(controller);
    1:           if (editController)
    1:           {
    1:             editController->SetCommandContext(nsnull);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   mEditor = nsnull;
    1:   mSelCon = nsnull;
    1:   if (mFrameSel) {
    1:     mFrameSel->SetScrollableViewProvider(nsnull);
13846:     mFrameSel->DisconnectFromPresShell();
    1:     mFrameSel = nsnull;
    1:   }
    1: 
 3233:   nsFormControlFrame::RegUnRegAccessKey(static_cast<nsIFrame*>(this), PR_FALSE);
    1:   if (mTextListener)
    1:   {
15848:     mTextListener->SetFrame(nsnull);
    1: 
    1:     nsCOMPtr<nsIDOMEventGroup> systemGroup;
 1418:     mContent->GetSystemEventGroup(getter_AddRefs(systemGroup));
    1:     nsCOMPtr<nsIDOM3EventTarget> dom3Targ = do_QueryInterface(mContent);
    1:     if (dom3Targ) {
    1:       // cast because of ambiguous base
 3233:       nsIDOMEventListener *listener = static_cast<nsIDOMKeyListener*>
 3233:                                                  (mTextListener);
    1: 
    1:       dom3Targ->RemoveGroupedEventListener(NS_LITERAL_STRING("keydown"),
    1:                                            listener, PR_FALSE, systemGroup);
    1:       dom3Targ->RemoveGroupedEventListener(NS_LITERAL_STRING("keypress"),
    1:                                            listener, PR_FALSE, systemGroup);
    1:       dom3Targ->RemoveGroupedEventListener(NS_LITERAL_STRING("keyup"),
    1:                                            listener, PR_FALSE, systemGroup);
    1:     }
    1:   }
    1: 
    1:   mDidPreDestroy = PR_TRUE; 
    1: }
    1: 
    1: void
    1: nsTextControlFrame::Destroy()
    1: {
 6348:   if (mInSecureKeyboardInputMode) {
 6348:     MaybeEndSecureKeyboardInput();
 6348:   }
    1:   if (!mDidPreDestroy) {
    1:     PreDestroy();
    1:   }
    1:   if (mFrameSel) {
    1:     mFrameSel->SetScrollableViewProvider(nsnull);
    1:   }
    1:   nsContentUtils::DestroyAnonymousContent(&mAnonymousDiv);
    1:   nsBoxFrame::Destroy();
    1: }
    1: 
    1: void 
    1: nsTextControlFrame::RemovedAsPrimaryFrame()
    1: {
    1:   if (!mDidPreDestroy) {
    1:     PreDestroy();
    1:   }
    1:   else NS_ASSERTION(PR_FALSE, "RemovedAsPrimaryFrame called after PreDestroy");
    1: }
    1: 
    1: nsIAtom*
    1: nsTextControlFrame::GetType() const 
    1: { 
    1:   return nsGkAtoms::textInputFrame;
    1: } 
    1: 
    1: // XXX: wouldn't it be nice to get this from the style context!
    1: PRBool nsTextControlFrame::IsSingleLineTextControl() const
    1: {
    1:   nsCOMPtr<nsIFormControl> formControl = do_QueryInterface(mContent);
    1:   if (formControl) {
    1:     PRInt32 type = formControl->GetType();
    1:     return (type == NS_FORM_INPUT_TEXT) || (type == NS_FORM_INPUT_PASSWORD);
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool nsTextControlFrame::IsTextArea() const
    1: {
    1:   return mContent && mContent->Tag() == nsGkAtoms::textarea;
    1: }
    1: 
    1: // XXX: wouldn't it be nice to get this from the style context!
    1: PRBool nsTextControlFrame::IsPlainTextControl() const
    1: {
    1:   // need to check HTML attribute of mContent and/or CSS.
    1:   return PR_TRUE;
    1: }
    1: 
 6348: nsresult nsTextControlFrame::MaybeBeginSecureKeyboardInput()
 6348: {
 6348:   nsresult rv = NS_OK;
 6348:   if (IsPasswordTextControl() && !mInSecureKeyboardInputMode) {
 6348:     nsIWidget* window = GetWindow();
 6348:     NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 6348:     rv = window->BeginSecureKeyboardInput();
 6348:     mInSecureKeyboardInputMode = NS_SUCCEEDED(rv);
 6348:   }
 6348:   return rv;
 6348: }
 6348: 
 6348: void nsTextControlFrame::MaybeEndSecureKeyboardInput()
 6348: {
 6348:   if (mInSecureKeyboardInputMode) {
 6348:     nsIWidget* window = GetWindow();
 6348:     if (!window)
 6348:       return;
 6348:     window->EndSecureKeyboardInput();
 6348:     mInSecureKeyboardInputMode = PR_FALSE;
 6348:   }
 6348: }
 6348: 
    1: PRBool nsTextControlFrame::IsPasswordTextControl() const
    1: {
    1:   nsCOMPtr<nsIFormControl> formControl = do_QueryInterface(mContent);
    1:   return formControl && formControl->GetType() == NS_FORM_INPUT_PASSWORD;
    1: }
    1: 
    1: 
    1: PRInt32
    1: nsTextControlFrame::GetCols()
    1: {
    1:   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(mContent);
    1:   NS_ASSERTION(content, "Content is not HTML content!");
    1: 
    1:   if (IsTextArea()) {
    1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::cols);
    1:     if (attr) {
    1:       PRInt32 cols = attr->Type() == nsAttrValue::eInteger ?
    1:                      attr->GetIntegerValue() : 0;
    1:       // XXX why a default of 1 char, why hide it
    1:       return (cols <= 0) ? 1 : cols;
    1:     }
    1:   } else {
    1:     // Else we know (assume) it is an input with size attr
    1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::size);
    1:     if (attr && attr->Type() == nsAttrValue::eInteger) {
    1:       PRInt32 cols = attr->GetIntegerValue();
    1:       if (cols > 0) {
    1:         return cols;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return DEFAULT_COLS;
    1: }
    1: 
    1: 
    1: PRInt32
    1: nsTextControlFrame::GetRows()
    1: {
    1:   if (IsTextArea()) {
    1:     nsGenericHTMLElement *content =
    1:       nsGenericHTMLElement::FromContent(mContent);
    1:     NS_ASSERTION(content, "Content is not HTML content!");
    1: 
    1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::rows);
    1:     if (attr && attr->Type() == nsAttrValue::eInteger) {
    1:       PRInt32 rows = attr->GetIntegerValue();
    1:       return (rows <= 0) ? DEFAULT_ROWS_TEXTAREA : rows;
    1:     }
    1:     return DEFAULT_ROWS_TEXTAREA;
    1:   }
    1: 
    1:   return DEFAULT_ROWS;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsTextControlFrame::CalcIntrinsicSize(nsIRenderingContext* aRenderingContext,
    1:                                       nsSize&              aIntrinsicSize)
    1: {
    1:   // Get leading and the Average/MaxAdvance char width 
    1:   nscoord lineHeight  = 0;
    1:   nscoord charWidth   = 0;
    1:   nscoord charMaxAdvance  = 0;
    1: 
    1:   nsCOMPtr<nsIFontMetrics> fontMet;
    1:   nsresult rv =
    1:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   aRenderingContext->SetFont(fontMet);
    1: 
28519:   lineHeight =
28519:     nsHTMLReflowState::CalcLineHeight(GetStyleContext(), NS_AUTOHEIGHT);
    1:   fontMet->GetAveCharWidth(charWidth);
    1:   fontMet->GetMaxAdvance(charMaxAdvance);
    1: 
    1:   // Set the width equal to the width in characters
    1:   PRInt32 cols = GetCols();
    1:   aIntrinsicSize.width = cols * charWidth;
    1: 
    1:   // To better match IE, take the maximum character width(in twips) and remove
    1:   // 4 pixels add this on as additional padding(internalPadding). But only do
    1:   // this if charMaxAdvance != charWidth; if they are equal, this is almost
    1:   // certainly a fixed-width font.
    1:   if (charWidth != charMaxAdvance) {
32531:     nscoord internalPadding = NS_MAX(0, charMaxAdvance -
    1:                                         nsPresContext::CSSPixelsToAppUnits(4));
    1:     nscoord t = nsPresContext::CSSPixelsToAppUnits(1); 
    1:    // Round to a multiple of t
    1:     nscoord rest = internalPadding % t; 
    1:     if (rest < t - rest) {
    1:       internalPadding -= rest;
    1:     } else {
    1:       internalPadding += t - rest;
    1:     }
    1:     // Now add the extra padding on (so that small input sizes work well)
    1:     aIntrinsicSize.width += internalPadding;
    1:   } else {
15383:     // This is to account for the anonymous <br> having a 1 twip width
15383:     // in Full Standards mode, see BRFrame::Reflow and bug 228752.
15383:     if (PresContext()->CompatibilityMode() == eCompatibility_FullStandards) {
15383:       aIntrinsicSize.width += 1;
15383:     }
15383: 
15383:     // Also add in the padding of our anonymous div child.  Note that it hasn't
 4199:     // been reflowed yet, so we can't get its used padding, but it shouldn't be
 4199:     // using percentage padding anyway.
 4199:     nsMargin childPadding;
 4199:     if (GetFirstChild(nsnull)->GetStylePadding()->GetPadding(childPadding)) {
 4199:       aIntrinsicSize.width += childPadding.LeftRight();
 4199:     } else {
 4199:       NS_ERROR("Percentage padding on anonymous div?");
 4199:     }
    1:   }
    1: 
    1:   // Increment width with cols * letter-spacing.
    1:   {
    1:     const nsStyleCoord& lsCoord = GetStyleText()->mLetterSpacing;
    1:     if (eStyleUnit_Coord == lsCoord.GetUnit()) {
    1:       nscoord letterSpacing = lsCoord.GetCoordValue();
    1:       if (letterSpacing != 0) {
    1:         aIntrinsicSize.width += cols * letterSpacing;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Set the height equal to total number of rows (times the height of each
    1:   // line, of course)
    1:   aIntrinsicSize.height = lineHeight * GetRows();
    1: 
    1:   // Add in the size of the scrollbars for textarea
    1:   if (IsTextArea()) {
    1:     nsIFrame* first = GetFirstChild(nsnull);
    1: 
23554:     nsIScrollableFrame *scrollableFrame = do_QueryFrame(first);
    1:     NS_ASSERTION(scrollableFrame, "Child must be scrollable");
    1: 
14159:     nsMargin scrollbarSizes =
14159:       scrollableFrame->GetDesiredScrollbarSizes(PresContext(), aRenderingContext);
    1: 
    1:     aIntrinsicSize.width  += scrollbarSizes.LeftRight();
    1:     
    1:     aIntrinsicSize.height += scrollbarSizes.TopBottom();;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
16318: void
24402: nsTextControlFrame::DelayedEditorInit()
16318: {
28581:   nsIDocument* doc = mContent->GetCurrentDoc();
28581:   if (!doc) {
28581:     return;
28581:   }
28581:   
28581:   nsWeakFrame weakFrame(this);
28581: 
28581:   // Flush out content on our document.  Have to do this, because script
28581:   // blockers don't prevent the sink flushing out content and notifying in the
28581:   // process, which can destroy frames.
28581:   doc->FlushPendingNotifications(Flush_ContentAndNotify);
28581:   if (!weakFrame.IsAlive()) {
28581:     return;
28581:   }
28581:   
26231:   // Make sure that editor init doesn't do things that would kill us off
26231:   // (especially off the script blockers it'll create for its DOM mutations).
26231:   nsAutoScriptBlocker scriptBlocker;
26231: 
25038:   // Time to mess with our security context... See comments in GetValue()
25038:   // for why this is needed.
25038:   nsCxPusher pusher;
25038:   pusher.PushNull();
25038: 
    1:   InitEditor();
29018:   if (IsFocusedContent(GetContent()))
16318:     SetFocus(PR_TRUE, PR_FALSE);
16318: }
    1: 
29186: PRInt32
29186: nsTextControlFrame::GetWrapCols()
29186: {
29186:   if (IsTextArea()) {
29186:     // wrap=off means -1 for wrap width no matter what cols is
29186:     nsHTMLTextWrap wrapProp;
29186:     ::GetWrapPropertyEnum(mContent, wrapProp);
29186:     if (wrapProp == eHTMLTextWrap_Off) {
29186:       // do not wrap when wrap=off
29186:       return -1;
29186:     }
29186:    
29186:     // Otherwise we just wrap at the given number of columns
29186:     return GetCols();
29186:   }
29186: 
29186:   // Never wrap non-textareas
29186:   return -1;
29186: }
29186: 
24402: nsresult
24402: nsTextControlFrame::InitEditor()
    1: {
24402:   // This method initializes our editor, if needed.
24402:   
24402:   // This code used to be called from CreateAnonymousContent(), but
24402:   // when the editor set the initial string, it would trigger a
24402:   // PresShell listener which called FlushPendingNotifications()
24402:   // during frame construction. This was causing other form controls
24402:   // to display wrong values.  So we call this from a script runner
24402:   // now.
24402: 
24402:   // Check if this method has been called already.
24402:   // If so, just return early.
24402: 
24402:   if (mUseEditor)
24402:     return NS_OK;
24402: 
24402:   // Create an editor
24402: 
24402:   nsresult rv;
    1:   mEditor = do_CreateInstance(kTextEditorCID, &rv);
24402:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   // Setup the editor flags
    1: 
    1:   PRUint32 editorFlags = 0;
    1:   if (IsPlainTextControl())
    1:     editorFlags |= nsIPlaintextEditor::eEditorPlaintextMask;
    1:   if (IsSingleLineTextControl())
    1:     editorFlags |= nsIPlaintextEditor::eEditorSingleLineMask;
    1:   if (IsPasswordTextControl())
    1:     editorFlags |= nsIPlaintextEditor::eEditorPasswordMask;
    1: 
24402:   // All nsTextControlFrames are widgets
    1:   editorFlags |= nsIPlaintextEditor::eEditorWidgetMask;
    1: 
    1:   // Use async reflow and painting for text widgets to improve
    1:   // performance.
    1: 
 3277:   // XXX: Using editor async updates exposes bugs 158782, 151882,
 3277:   //      and 165130, so we're disabling it for now, until they
 3277:   //      can be addressed.
 3277:   // editorFlags |= nsIPlaintextEditor::eEditorUseAsyncUpdatesMask;
    1: 
    1:   // Now initialize the editor.
    1:   //
    1:   // NOTE: Conversion of '\n' to <BR> happens inside the
    1:   //       editor's Init() call.
    1: 
24402:   nsPresContext *presContext = PresContext();
24402:   nsIPresShell *shell = presContext->GetPresShell();
24402: 
24402:   // Get the DOM document
24402:   nsCOMPtr<nsIDOMDocument> domdoc = do_QueryInterface(shell->GetDocument());
24402:   if (!domdoc)
24402:     return NS_ERROR_FAILURE;
24402: 
24402:   rv = mEditor->Init(domdoc, shell, mAnonymousDiv, mSelCon, editorFlags);
24402:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Initialize the controller for the editor
    1: 
    1:   if (!SuppressEventHandlers(presContext)) {
    1:     nsCOMPtr<nsIControllers> controllers;
    1:     nsCOMPtr<nsIDOMNSHTMLInputElement> inputElement =
    1:       do_QueryInterface(mContent);
    1:     if (inputElement) {
    1:       rv = inputElement->GetControllers(getter_AddRefs(controllers));
    1:     } else {
    1:       nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textAreaElement =
    1:         do_QueryInterface(mContent);
    1: 
    1:       if (!textAreaElement)
24402:         return NS_ERROR_FAILURE;
    1: 
    1:       rv = textAreaElement->GetControllers(getter_AddRefs(controllers));
    1:     }
    1: 
    1:     if (NS_FAILED(rv))
24402:       return rv;
    1: 
    1:     if (controllers) {
    1:       PRUint32 numControllers;
    1:       PRBool found = PR_FALSE;
    1:       rv = controllers->GetControllerCount(&numControllers);
    1:       for (PRUint32 i = 0; i < numControllers; i ++) {
    1:         nsCOMPtr<nsIController> controller;
    1:         rv = controllers->GetControllerAt(i, getter_AddRefs(controller));
    1:         if (NS_SUCCEEDED(rv) && controller) {
    1:           nsCOMPtr<nsIControllerContext> editController =
    1:             do_QueryInterface(controller);
    1:           if (editController) {
    1:             editController->SetCommandContext(mEditor);
    1:             found = PR_TRUE;
    1:           }
    1:         }
    1:       }
    1:       if (!found)
    1:         rv = NS_ERROR_FAILURE;
    1:     }
    1:   }
    1: 
    1:   // Initialize the plaintext editor
    1:   nsCOMPtr<nsIPlaintextEditor> textEditor(do_QueryInterface(mEditor));
    1:   if (textEditor) {
    1:     // Set up wrapping
29186:     textEditor->SetWrapColumn(GetWrapCols());
    1: 
    1:     // Set max text field length
    1:     PRInt32 maxLength;
    1:     if (GetMaxLength(&maxLength)) { 
    1:       textEditor->SetMaxTextLength(maxLength);
    1:     }
    1:   }
    1:   
    1:   if (mContent) {
    1:     rv = mEditor->GetFlags(&editorFlags);
    1: 
    1:     if (NS_FAILED(rv))
    1:       return nsnull;
    1: 
    1:     // Check if the readonly attribute is set.
    1: 
    1:     if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::readonly))
    1:       editorFlags |= nsIPlaintextEditor::eEditorReadonlyMask;
    1: 
    1:     // Check if the disabled attribute is set.
    1: 
    1:     if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) 
    1:       editorFlags |= nsIPlaintextEditor::eEditorDisabledMask;
    1: 
    1:     // Disable the selection if necessary.
    1: 
    1:     if (editorFlags & nsIPlaintextEditor::eEditorDisabledMask)
    1:       mSelCon->SetDisplaySelection(nsISelectionController::SELECTION_OFF);
    1: 
    1:     mEditor->SetFlags(editorFlags);
    1:   }
    1: 
    1:   // Get the current value of the textfield from the content.
    1:   nsAutoString defaultValue;
    1:   GetValue(defaultValue, PR_TRUE);
    1: 
    1:   // Turn on mUseEditor so that subsequent calls will use the
    1:   // editor.
    1:   mUseEditor = PR_TRUE;
    1: 
    1:   // If we have a default value, insert it under the div we created
    1:   // above, but be sure to use the editor so that '*' characters get
    1:   // displayed for password fields, etc. SetValue() will call the
    1:   // editor for us.
    1: 
    1:   if (!defaultValue.IsEmpty()) {
    1:     // Avoid causing reentrant painting and reflowing by telling the editor
    1:     // that we don't want it to force immediate view refreshes or force
    1:     // immediate reflows during any editor calls.
    1: 
    1:     rv = mEditor->SetFlags(editorFlags |
    1:                            nsIPlaintextEditor::eEditorUseAsyncUpdatesMask);
    1: 
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     // Now call SetValue() which will make the necessary editor calls to set
    1:     // the default value.  Make sure to turn off undo before setting the default
    1:     // value, and turn it back on afterwards. This will make sure we can't undo
    1:     // past the default value.
    1: 
    1:     rv = mEditor->EnableUndo(PR_FALSE);
    1: 
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     SetValue(defaultValue);
    1: 
    1:     rv = mEditor->EnableUndo(PR_TRUE);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv),"Transaction Manager must have failed");
24402: 
    1:     // Now restore the original editor flags.
    1:     rv = mEditor->SetFlags(editorFlags);
    1: 
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsITransactionManager> transMgr;
    1:   mEditor->GetTransactionManager(getter_AddRefs(transMgr));
    1:   NS_ENSURE_TRUE(transMgr, NS_ERROR_FAILURE);
    1: 
    1:   transMgr->SetMaxTransactionCount(DEFAULT_UNDO_CAP);
    1: 
    1:   if (IsPasswordTextControl()) {
    1:     // Disable undo for password textfields.  Note that we want to do this at
    1:     // the very end of InitEditor, so the calls to EnableUndo when setting the
    1:     // default value don't screw us up.
    1:     // Since changing the control type does a reframe, we don't have to worry
    1:     // about dynamic type changes here.
    1:     mEditor->EnableUndo(PR_FALSE);
    1:   }
    1: 
24402:   mEditor->PostCreate();
24402: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::CreateAnonymousContent(nsTArray<nsIContent*>& aElements)
    1: {
    1:   mState |= NS_FRAME_INDEPENDENT_SELECTION;
    1: 
  238:   nsIPresShell* shell = PresContext()->GetPresShell();
    1:   if (!shell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDocument *doc = shell->GetDocument();
    1:   if (!doc)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Now create a DIV and add it to the anonymous content child list.
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
19197:   nodeInfo = doc->NodeInfoManager()->GetNodeInfo(nsGkAtoms::div, nsnull,
19197:                                                  kNameSpaceID_XHTML);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
19197: 
19197:   nsresult rv = NS_NewHTMLElement(getter_AddRefs(mAnonymousDiv), nodeInfo, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
33356:   // Set the necessary classes on the text control. We use class values
33356:   // instead of a 'style' attribute so that the style comes from a user-agent
33356:   // style sheet and is still applied even if author styles are disabled.
33356:   nsAutoString classValue;
33356:   classValue.AppendLiteral("anonymous-div");
29186:   PRInt32 wrapCols = GetWrapCols();
29186:   if (wrapCols >= 0) {
33356:     classValue.AppendLiteral(" wrap");
29186:   }
    1:   if (!IsSingleLineTextControl()) {
    1:     // We can't just inherit the overflow because setting visible overflow will
    1:     // crash when the number of lines exceeds the height of the textarea and
    1:     // setting -moz-hidden-unscrollable overflow (NS_STYLE_OVERFLOW_CLIP)
    1:     // doesn't paint the caret for some reason.
    1:     const nsStyleDisplay* disp = GetStyleDisplay();
    1:     if (disp->mOverflowX != NS_STYLE_OVERFLOW_VISIBLE &&
    1:         disp->mOverflowX != NS_STYLE_OVERFLOW_CLIP) {
33356:       classValue.AppendLiteral(" inherit-overflow");
29186:     }
29186:   }
33356:   rv = mAnonymousDiv->SetAttr(kNameSpaceID_None, nsGkAtoms::_class,
33356:                               classValue, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!aElements.AppendElement(mAnonymousDiv))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
24402:   // Create selection
24402: 
24402:   mFrameSel = do_CreateInstance(kFrameSelectionCID, &rv);
24402:   if (NS_FAILED(rv))
24402:     return rv;
24402:   mFrameSel->SetScrollableViewProvider(this);
24402: 
24402:   // Create a SelectionController
24402: 
24402:   mSelCon = static_cast<nsISelectionController*>
24402:                        (new nsTextInputSelectionImpl(mFrameSel, shell,
24402:                                                      mAnonymousDiv));
24402:   if (!mSelCon)
24402:     return NS_ERROR_OUT_OF_MEMORY;
24402:   mTextListener = new nsTextInputListener();
24402:   if (!mTextListener)
24402:     return NS_ERROR_OUT_OF_MEMORY;
24402:   NS_ADDREF(mTextListener);
24402: 
24402:   mTextListener->SetFrame(this);
24402:   mSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
24402: 
24402:   // Get the caret and make it a selection listener.
24402: 
24402:   nsRefPtr<nsISelection> domSelection;
24402:   if (NS_SUCCEEDED(mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
24402:                                          getter_AddRefs(domSelection))) &&
24402:       domSelection) {
24402:     nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(domSelection));
24402:     nsRefPtr<nsCaret> caret;
24402:     nsCOMPtr<nsISelectionListener> listener;
24402:     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))) && caret) {
24402:       listener = do_QueryInterface(caret);
24402:       if (listener) {
24402:         selPriv->AddSelectionListener(listener);
24402:       }
24402:     }
24402: 
24402:     selPriv->AddSelectionListener(static_cast<nsISelectionListener*>
24402:                                              (mTextListener));
24402:   }
24402: 
24402:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
24402:                "Someone forgot a script blocker?");
24402: 
24402:   if (!nsContentUtils::AddScriptRunner(new EditorInitializer(this))) {
24402:     return NS_ERROR_OUT_OF_MEMORY;
24402:   }
24402: 
    1:   return NS_OK;
    1: }
    1: 
    1: nscoord
    1: nsTextControlFrame::GetMinWidth(nsIRenderingContext* aRenderingContext)
    1: {
    1:   // Our min width is just our preferred width if we have auto width.
    1:   nscoord result;
    1:   DISPLAY_MIN_WIDTH(this, result);
    1: 
    1:   result = GetPrefWidth(aRenderingContext);
    1: 
    1:   return result;
    1: }
    1: 
 4887: nsSize
 4887: nsTextControlFrame::ComputeAutoSize(nsIRenderingContext *aRenderingContext,
 4887:                                     nsSize aCBSize, nscoord aAvailableWidth,
 4887:                                     nsSize aMargin, nsSize aBorder,
 4887:                                     nsSize aPadding, PRBool aShrinkWrap)
 4887: {
 4887:   nsSize autoSize;
 4887:   nsresult rv = CalcIntrinsicSize(aRenderingContext, autoSize);
 4887:   if (NS_FAILED(rv)) {
 4887:     // What now?
 4887:     autoSize.SizeTo(0, 0);
 4887:   }
 4887: #ifdef DEBUG
 4887:   // Note: Ancestor ComputeAutoSize only computes a width if we're auto-width
 4887:   else if (GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
 4887:     nsSize ancestorAutoSize =
 4887:       nsStackFrame::ComputeAutoSize(aRenderingContext,
 4887:                                     aCBSize, aAvailableWidth,
 4887:                                     aMargin, aBorder,
 4887:                                     aPadding, aShrinkWrap);
 4887:     NS_ASSERTION(ancestorAutoSize.width == autoSize.width,
 4887:                  "Incorrect size computed by ComputeAutoSize?");
 4887:   }
 4887: #endif
 4887:   
 4887:   return autoSize;
 4887: }
 4887: 
 4887: 
    1: // We inherit our GetPrefWidth from nsBoxFrame
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::Reflow(nsPresContext*   aPresContext,
    1:                            nsHTMLReflowMetrics&     aDesiredSize,
    1:                            const nsHTMLReflowState& aReflowState,
    1:                            nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsTextControlFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1: 
    1:   // make sure the the form registers itself on the initial/first reflow
    1:   if (mState & NS_FRAME_FIRST_REFLOW) {
    1:     nsFormControlFrame::RegUnRegAccessKey(this, PR_TRUE);
    1:   }
    1: 
    1:   return nsStackFrame::Reflow(aPresContext, aDesiredSize, aReflowState,
    1:                               aStatus);
    1: }
    1: 
    1: nsSize
    1: nsTextControlFrame::GetPrefSize(nsBoxLayoutState& aState)
    1: {
    1:   if (!DoesNeedRecalc(mPrefSize))
    1:      return mPrefSize;
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aState);
    1: #endif
    1: 
    1:   nsSize pref(0,0);
    1: 
    1:   nsresult rv = CalcIntrinsicSize(aState.GetRenderingContext(), pref);
    1:   NS_ENSURE_SUCCESS(rv, pref);
    1:   AddBorderAndPadding(pref);
    1: 
    1:   mPrefSize = pref;
    1: 
    1: #ifdef DEBUG_rods
    1:   {
    1:     nsMargin borderPadding(0,0,0,0);
    1:     GetBorderAndPadding(borderPadding);
    1:     nsSize size(169, 24);
    1:     nsSize actual(pref.width/15, 
    1:                   pref.height/15);
    1:     printf("nsGfxText(field) %d,%d  %d,%d  %d,%d\n", 
    1:            size.width, size.height, actual.width, actual.height, actual.width-size.width, actual.height-size.height);  // text field
    1:   }
    1: #endif
    1: 
    1:   return pref;
    1: }
    1: 
    1: nsSize
    1: nsTextControlFrame::GetMinSize(nsBoxLayoutState& aState)
    1: {
    1:   // XXXbz why?  Why not the nsBoxFrame sizes?
    1:   return nsBox::GetMinSize(aState);
    1: }
    1: 
    1: nsSize
    1: nsTextControlFrame::GetMaxSize(nsBoxLayoutState& aState)
    1: {
    1:   // XXXbz why?  Why not the nsBoxFrame sizes?
    1:   return nsBox::GetMaxSize(aState);
    1: }
    1: 
    1: nscoord
    1: nsTextControlFrame::GetBoxAscent(nsBoxLayoutState& aState)
    1: {
28519:   // Return the baseline of the first (nominal) row, with centering for
28519:   // single-line controls.
28519: 
28519:   // First calculate the ascent wrt the client rect
28519:   nsRect clientRect;
28519:   GetClientRect(clientRect);
28519:   nscoord lineHeight =
28519:     IsSingleLineTextControl() ? clientRect.height :
28519:     nsHTMLReflowState::CalcLineHeight(GetStyleContext(), NS_AUTOHEIGHT);
28519: 
28519:   nsCOMPtr<nsIFontMetrics> fontMet;
28519:   nsresult rv =
28519:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
28519:   NS_ENSURE_SUCCESS(rv, 0);
28519: 
28519:   nscoord ascent = nsLayoutUtils::GetCenteredFontBaseline(fontMet, lineHeight);
28519: 
28519:   // Now adjust for our borders and padding
28519:   ascent += clientRect.y;
    1: 
    1:   return ascent;
    1: }
    1: 
    1: PRBool
    1: nsTextControlFrame::IsCollapsed(nsBoxLayoutState& aBoxLayoutState)
    1: {
    1:   // We're never collapsed in the box sense.
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsTextControlFrame::IsLeaf() const
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
    1: //IMPLEMENTING NS_IFORMCONTROLFRAME
    1: void nsTextControlFrame::SetFocus(PRBool aOn, PRBool aRepaint)
    1: {
29018:   nsCOMPtr<nsIEditor> editor;
29018:   GetEditor(getter_AddRefs(editor));
29018: 
29018:   if (!aOn) {
29018:     if (editor)
29018:       editor->RemoveEditorObserver(mTextListener);
29018: 
29018:     MaybeEndSecureKeyboardInput();
    1:     return;
29018:   }
29018: 
29018:   if (!mSelCon)
    1:     return;
    1: 
29018:   if (editor)
29018:     editor->AddEditorObserver(mTextListener);
29018: 
29018:   if (NS_SUCCEEDED(InitFocusedValue()))
29018:     MaybeBeginSecureKeyboardInput();
29018: 
    1:   // tell the caret to use our selection
    1: 
    1:   nsCOMPtr<nsISelection> ourSel;
    1:   mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, 
    1:     getter_AddRefs(ourSel));
    1:   if (!ourSel) return;
    1: 
  238:   nsIPresShell* presShell = PresContext()->GetPresShell();
15969:   nsRefPtr<nsCaret> caret;
    1:   presShell->GetCaret(getter_AddRefs(caret));
    1:   if (!caret) return;
    1:   caret->SetCaretDOMSelection(ourSel);
    1: 
    1:   // mutual-exclusion: the selection is either controlled by the
    1:   // document or by the text input/area. Clear any selection in the
    1:   // document since the focus is now on our independent selection.
    1: 
    1:   nsCOMPtr<nsISelectionController> selCon(do_QueryInterface(presShell));
    1:   nsCOMPtr<nsISelection> docSel;
    1:   selCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
    1:     getter_AddRefs(docSel));
    1:   if (!docSel) return;
    1: 
    1:   PRBool isCollapsed = PR_FALSE;
    1:   docSel->GetIsCollapsed(&isCollapsed);
    1:   if (!isCollapsed)
    1:     docSel->RemoveAllRanges();
    1: }
    1: 
    1: nsresult nsTextControlFrame::SetFormProperty(nsIAtom* aName, const nsAString& aValue)
    1: {
    1:   if (!mIsProcessing)//some kind of lock.
    1:   {
    1:     mIsProcessing = PR_TRUE;
 6544:     PRBool isUserInput = (nsGkAtoms::userInput == aName);
 6544:     if (nsGkAtoms::value == aName || isUserInput) 
    1:     {
 6544:       PRBool fireChangeEvent = GetFireChangeEventState();
 6544:       if (isUserInput) {
 6544:         SetFireChangeEventState(PR_TRUE);
 6544:       }
    1:       SetValueChanged(PR_TRUE);
    1:       nsresult rv = SetValue(aValue); // set new text value
 6544:       if (isUserInput) {
 6544:         SetFireChangeEventState(fireChangeEvent);
 6544:       }
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     else if (nsGkAtoms::select == aName)
    1:     {
    1:       // Select all the text.
    1:       //
    1:       // XXX: This is lame, we can't call mEditor->SelectAll()
    1:       //      because that triggers AutoCopies in unix builds.
    1:       //      Instead, we have to call our own homegrown version
    1:       //      of select all which merely builds a range that selects
    1:       //      all of the content and adds that to the selection.
    1: 
    1:       SelectAllContents();
    1:     }
    1:     mIsProcessing = PR_FALSE;
    1:   }
    1:   return NS_OK;
    1: }      
    1: 
    1: nsresult
    1: nsTextControlFrame::GetFormProperty(nsIAtom* aName, nsAString& aValue) const
    1: {
    1:   // Return the value of the property from the widget it is not null.
    1:   // If widget is null, assume the widget is GFX-rendered and return a member variable instead.
    1: 
    1:   if (nsGkAtoms::value == aName) {
    1:     GetValue(aValue, PR_FALSE);
    1:   }
    1:   return NS_OK;
    1: }  
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::GetEditor(nsIEditor **aEditor)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEditor);
    1:   *aEditor = mEditor;
    1:   NS_IF_ADDREF(*aEditor);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::OwnsValue(PRBool* aOwnsValue)
    1: {
    1:   NS_PRECONDITION(aOwnsValue, "aOwnsValue must be non-null");
    1:   *aOwnsValue = mUseEditor;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::GetTextLength(PRInt32* aTextLength)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aTextLength);
    1: 
    1:   nsAutoString   textContents;
    1:   GetValue(textContents, PR_FALSE);   // this is expensive!
    1:   *aTextLength = textContents.Length();
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::SetSelectionInternal(nsIDOMNode *aStartNode,
    1:                                          PRInt32 aStartOffset,
    1:                                          nsIDOMNode *aEndNode,
    1:                                          PRInt32 aEndOffset)
    1: {
    1:   // Create a new range to represent the new selection.
    1:   // Note that we use a new range to avoid having to do
    1:   // isIncreasing checks to avoid possible errors.
    1: 
    1:   nsCOMPtr<nsIDOMRange> range = do_CreateInstance(kRangeCID);
    1:   NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
    1: 
    1:   nsresult rv = range->SetStart(aStartNode, aStartOffset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = range->SetEnd(aEndNode, aEndOffset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Get the selection, clear it and add the new range to it!
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));  
    1:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
    1: 
    1:   rv = selection->RemoveAllRanges();  
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return selection->AddRange(range);
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::SelectAllContents()
    1: {
    1:   if (!mEditor)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIDOMElement> rootElement;
    1:   nsresult rv = mEditor->GetRootElement(getter_AddRefs(rootElement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIContent> rootContent = do_QueryInterface(rootElement);
    1:   PRInt32 numChildren = rootContent->GetChildCount();
    1: 
    1:   if (numChildren > 0) {
    1:     // We never want to place the selection after the last
    1:     // br under the root node!
    1:     nsIContent *child = rootContent->GetChildAt(numChildren - 1);
    1:     if (child) {
    1:       if (child->Tag() == nsGkAtoms::br)
    1:         --numChildren;
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
    1: 
    1:   return SetSelectionInternal(rootNode, 0, rootNode, numChildren);
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::SetSelectionEndPoints(PRInt32 aSelStart, PRInt32 aSelEnd)
    1: {
    1:   NS_ASSERTION(aSelStart <= aSelEnd, "Invalid selection offsets!");
    1: 
    1:   if (aSelStart > aSelEnd)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:   PRInt32 startOffset, endOffset;
    1: 
    1:   // Calculate the selection start point.
    1: 
    1:   nsresult rv = OffsetToDOMPoint(aSelStart, getter_AddRefs(startNode), &startOffset);
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aSelStart == aSelEnd) {
    1:     // Collapsed selection, so start and end are the same!
    1:     endNode   = startNode;
    1:     endOffset = startOffset;
    1:   }
    1:   else {
    1:     // Selection isn't collapsed so we have to calculate
    1:     // the end point too.
    1: 
    1:     rv = OffsetToDOMPoint(aSelEnd, getter_AddRefs(endNode), &endOffset);
    1: 
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return SetSelectionInternal(startNode, startOffset, endNode, endOffset);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::SetSelectionRange(PRInt32 aSelStart, PRInt32 aSelEnd)
    1: {
    1:   NS_ENSURE_TRUE(mEditor, NS_ERROR_NOT_INITIALIZED);
    1:   
    1:   if (aSelStart > aSelEnd) {
    1:     // Simulate what we'd see SetSelectionStart() was called, followed
    1:     // by a SetSelectionEnd().
    1: 
    1:     aSelStart   = aSelEnd;
    1:   }
    1: 
    1:   return SetSelectionEndPoints(aSelStart, aSelEnd);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::SetSelectionStart(PRInt32 aSelectionStart)
    1: {
    1:   NS_ENSURE_TRUE(mEditor, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   PRInt32 selStart = 0, selEnd = 0; 
    1: 
    1:   nsresult rv = GetSelectionRange(&selStart, &selEnd);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aSelectionStart > selEnd) {
    1:     // Collapse to the new start point.
    1:     selEnd = aSelectionStart; 
    1:   }
    1: 
    1:   selStart = aSelectionStart;
    1:   
    1:   return SetSelectionEndPoints(selStart, selEnd);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::SetSelectionEnd(PRInt32 aSelectionEnd)
    1: {
    1:   NS_ENSURE_TRUE(mEditor, NS_ERROR_NOT_INITIALIZED);
    1:   
    1:   PRInt32 selStart = 0, selEnd = 0; 
    1: 
    1:   nsresult rv = GetSelectionRange(&selStart, &selEnd);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aSelectionEnd < selStart) {
    1:     // Collapse to the new end point.
    1:     selStart = aSelectionEnd; 
    1:   }
    1: 
    1:   selEnd = aSelectionEnd;
    1:   
    1:   return SetSelectionEndPoints(selStart, selEnd);
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::DOMPointToOffset(nsIDOMNode* aNode,
    1:                                      PRInt32 aNodeOffset,
    1:                                      PRInt32* aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aNode && aResult);
    1: 
    1:   *aResult = 0;
    1: 
    1:   nsCOMPtr<nsIDOMElement> rootElement;
    1:   mEditor->GetRootElement(getter_AddRefs(rootElement));
    1:   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
    1: 
    1:   NS_ENSURE_TRUE(rootNode, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1: 
    1:   nsresult rv = rootNode->GetChildNodes(getter_AddRefs(nodeList));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
    1: 
    1:   PRUint32 length = 0;
    1:   rv = nodeList->GetLength(&length);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!length || aNodeOffset < 0)
    1:     return NS_OK;
    1: 
    1:   PRInt32 i, textOffset = 0;
    1:   PRInt32 lastIndex = (PRInt32)length - 1;
    1: 
    1:   for (i = 0; i < (PRInt32)length; i++) {
    1:     if (rootNode == aNode && i == aNodeOffset) {
    1:       *aResult = textOffset;
    1:       return NS_OK;
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMNode> item;
    1:     rv = nodeList->Item(i, getter_AddRefs(item));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     NS_ENSURE_TRUE(item, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsIDOMText> domText(do_QueryInterface(item));
    1: 
    1:     if (domText) {
    1:       PRUint32 textLength = 0;
    1: 
    1:       rv = domText->GetLength(&textLength);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       if (item == aNode) {
    1:         NS_ASSERTION((aNodeOffset >= 0 && aNodeOffset <= (PRInt32)textLength),
    1:                      "Invalid aNodeOffset!");
    1:         *aResult = textOffset + aNodeOffset;
    1:         return NS_OK;
    1:       }
    1: 
    1:       textOffset += textLength;
    1:     }
    1:     else {
    1:       // Must be a BR node. If it's not the last BR node
    1:       // under the root, count it as a newline.
    1: 
    1:       if (i != lastIndex)
    1:         ++textOffset;
    1:     }
    1:   }
    1: 
    1:   NS_ASSERTION((aNode == rootNode && aNodeOffset == (PRInt32)length),
    1:                "Invalid node offset!");
    1: 
    1:   *aResult = textOffset;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::OffsetToDOMPoint(PRInt32 aOffset,
    1:                                      nsIDOMNode** aResult,
    1:                                      PRInt32* aPosition)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult && aPosition);
    1: 
    1:   *aResult = nsnull;
    1:   *aPosition = 0;
    1: 
    1:   nsCOMPtr<nsIDOMElement> rootElement;
    1:   mEditor->GetRootElement(getter_AddRefs(rootElement));
    1:   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
    1: 
    1:   NS_ENSURE_TRUE(rootNode, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1: 
    1:   nsresult rv = rootNode->GetChildNodes(getter_AddRefs(nodeList));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
    1: 
    1:   PRUint32 length = 0;
    1: 
    1:   rv = nodeList->GetLength(&length);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!length || aOffset < 0) {
    1:     *aPosition = 0;
    1:     *aResult = rootNode;
    1:     NS_ADDREF(*aResult);
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRInt32 textOffset = 0;
    1:   PRUint32 lastIndex = length - 1;
    1: 
    1:   for (PRUint32 i=0; i<length; i++) {
    1:     nsCOMPtr<nsIDOMNode> item;
    1:     rv = nodeList->Item(i, getter_AddRefs(item));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     NS_ENSURE_TRUE(item, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsIDOMText> domText(do_QueryInterface(item));
    1: 
    1:     if (domText) {
    1:       PRUint32 textLength = 0;
    1: 
    1:       rv = domText->GetLength(&textLength);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       // Check if aOffset falls within this range.
    1:       if (aOffset >= textOffset && aOffset <= textOffset+(PRInt32)textLength) {
    1:         *aPosition = aOffset - textOffset;
    1:         *aResult = item;
    1:         NS_ADDREF(*aResult);
    1:         return NS_OK;
    1:       }
    1: 
    1:       textOffset += textLength;
    1: 
    1:       // If there aren't any more siblings after this text node,
    1:       // return the point at the end of this text node!
    1: 
    1:       if (i == lastIndex) {
    1:         *aPosition = textLength;
    1:         *aResult = item;
    1:         NS_ADDREF(*aResult);
    1:         return NS_OK;
    1:       }
    1:     }
    1:     else {
    1:       // Must be a BR node, count it as a newline.
    1: 
    1:       if (aOffset == textOffset || i == lastIndex) {
    1:         // We've found the correct position, or aOffset takes us
    1:         // beyond the last child under rootNode, just return the point
    1:         // under rootNode that is in front of this br.
    1: 
    1:         *aPosition = i;
    1:         *aResult = rootNode;
    1:         NS_ADDREF(*aResult);
    1:         return NS_OK;
    1:       }
    1: 
    1:       ++textOffset;
    1:     }
    1:   }
    1: 
31561:   NS_ERROR("We should never get here!");
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::GetSelectionRange(PRInt32* aSelectionStart, PRInt32* aSelectionEnd)
    1: {
    1:   // make sure we have an editor
    1:   NS_ENSURE_TRUE(mEditor, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aSelectionStart = 0;
    1:   *aSelectionEnd = 0;
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult rv = mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));  
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 numRanges = 0;
    1:   selection->GetRangeCount(&numRanges);
    1: 
    1:   if (numRanges < 1)
    1:     return NS_OK;
    1: 
    1:   // We only operate on the first range in the selection!
    1: 
    1:   nsCOMPtr<nsIDOMRange> firstRange;
    1:   rv = selection->GetRangeAt(0, getter_AddRefs(firstRange));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(firstRange, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:   PRInt32 startOffset = 0, endOffset = 0;
    1: 
    1:   // Get the start point of the range.
    1: 
    1:   rv = firstRange->GetStartContainer(getter_AddRefs(startNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
    1: 
    1:   rv = firstRange->GetStartOffset(&startOffset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Get the end point of the range.
    1: 
    1:   rv = firstRange->GetEndContainer(getter_AddRefs(endNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(endNode, NS_ERROR_FAILURE);
    1: 
    1:   rv = firstRange->GetEndOffset(&endOffset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Convert the start point to a selection offset.
    1: 
    1:   rv = DOMPointToOffset(startNode, startOffset, aSelectionStart);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Convert the end point to a selection offset.
    1: 
    1:   return DOMPointToOffset(endNode, endOffset, aSelectionEnd);
    1: }
    1: 
    1: /////END INTERFACE IMPLEMENTATIONS
    1: 
    1: ////NSIFRAME
    1: NS_IMETHODIMP
    1: nsTextControlFrame::AttributeChanged(PRInt32         aNameSpaceID,
    1:                                      nsIAtom*        aAttribute,
    1:                                      PRInt32         aModType)
    1: {
    1:   if (!mEditor || !mSelCon) 
24402:     return nsBoxFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);;
24402: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (nsGkAtoms::maxlength == aAttribute) 
    1:   {
    1:     PRInt32 maxLength;
    1:     PRBool maxDefined = GetMaxLength(&maxLength);
    1:     
    1:     nsCOMPtr<nsIPlaintextEditor> textEditor = do_QueryInterface(mEditor);
    1:     if (textEditor)
    1:     {
    1:       if (maxDefined) 
    1:       {  // set the maxLength attribute
    1:           textEditor->SetMaxTextLength(maxLength);
    1:         // if maxLength>docLength, we need to truncate the doc content
    1:       }
    1:       else { // unset the maxLength attribute
    1:           textEditor->SetMaxTextLength(-1);
    1:       }
    1:     }
    1:     rv = NS_OK; // don't propagate the error
    1:   } 
    1:   else if (nsGkAtoms::readonly == aAttribute) 
    1:   {
    1:     PRUint32 flags;
    1:     mEditor->GetFlags(&flags);
    1:     if (AttributeExists(nsGkAtoms::readonly))
    1:     { // set readonly
    1:       flags |= nsIPlaintextEditor::eEditorReadonlyMask;
29018:       if (IsFocusedContent(mContent))
    1:         mSelCon->SetCaretEnabled(PR_FALSE);
    1:     }
    1:     else 
    1:     { // unset readonly
    1:       flags &= ~(nsIPlaintextEditor::eEditorReadonlyMask);
    1:       if (!(flags & nsIPlaintextEditor::eEditorDisabledMask) &&
29018:           IsFocusedContent(mContent))
    1:         mSelCon->SetCaretEnabled(PR_TRUE);
    1:     }    
    1:     mEditor->SetFlags(flags);
    1:   }
24402:   else if (nsGkAtoms::disabled == aAttribute) 
    1:   {
    1:     PRUint32 flags;
    1:     mEditor->GetFlags(&flags);
    1:     if (AttributeExists(nsGkAtoms::disabled))
    1:     { // set disabled
    1:       flags |= nsIPlaintextEditor::eEditorDisabledMask;
    1:       mSelCon->SetDisplaySelection(nsISelectionController::SELECTION_OFF);
29018:       if (IsFocusedContent(mContent))
    1:         mSelCon->SetCaretEnabled(PR_FALSE);
    1:     }
    1:     else 
    1:     { // unset disabled
    1:       flags &= ~(nsIPlaintextEditor::eEditorDisabledMask);
    1:       mSelCon->SetDisplaySelection(nsISelectionController::SELECTION_HIDDEN);
    1:     }    
    1:     mEditor->SetFlags(flags);
    1:   }
    1:   // Allow the base class to handle common attributes supported
    1:   // by all form elements... 
    1:   else {
    1:     rv = nsBoxFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::GetText(nsString* aText)
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (IsSingleLineTextControl()) {
    1:     // If we're going to remove newlines anyway, ignore the wrap property
    1:     GetValue(*aText, PR_TRUE);
    1:     RemoveNewlines(*aText);
    1:   } else {
    1:     nsCOMPtr<nsIDOMHTMLTextAreaElement> textArea = do_QueryInterface(mContent);
    1:     if (textArea) {
    1:       rv = textArea->GetValue(*aText);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: 
20884: nsresult
    1: nsTextControlFrame::GetPhonetic(nsAString& aPhonetic)
    1: {
    1:   aPhonetic.Truncate(0); 
    1:   if (!mEditor)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1:   nsCOMPtr<nsIEditorIMESupport> imeSupport = do_QueryInterface(mEditor);
    1:   if (imeSupport) {
    1:     nsCOMPtr<nsIPhonetic> phonetic = do_QueryInterface(imeSupport);
    1:     if (phonetic)
    1:       phonetic->GetPhonetic(aPhonetic);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: ///END NSIFRAME OVERLOADS
    1: /////BEGIN PROTECTED METHODS
    1: 
    1: void nsTextControlFrame::RemoveNewlines(nsString &aString)
    1: {
    1:   // strip CR/LF and null
    1:   static const char badChars[] = {10, 13, 0};
    1:   aString.StripChars(badChars);
    1: }
    1: 
    1: 
    1: PRBool
    1: nsTextControlFrame::GetMaxLength(PRInt32* aSize)
    1: {
    1:   *aSize = -1;
    1: 
    1:   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(mContent);
    1:   if (content) {
    1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::maxlength);
    1:     if (attr && attr->Type() == nsAttrValue::eInteger) {
    1:       *aSize = attr->GetIntegerValue();
    1: 
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: // this is where we propagate a content changed event
    1: void
    1: nsTextControlFrame::FireOnInput()
    1: {
    1:   if (!mNotifyOnInput)
    1:     return; // if notification is turned off, do nothing
    1:   
    1:   // Dispatch the "input" event
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   nsUIEvent event(PR_TRUE, NS_FORM_INPUT, 0);
    1: 
    1:   // Have the content handle the event, propagating it according to normal
    1:   // DOM rules.
  238:   nsCOMPtr<nsIPresShell> shell = PresContext()->PresShell();
   95:   shell->HandleEventWithTarget(&event, nsnull, mContent, &status);
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::InitFocusedValue()
    1: {
    1:   return GetText(&mFocusedValue);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::CheckFireOnChange()
    1: {
    1:   nsString value;
    1:   GetText(&value);
    1:   if (!mFocusedValue.Equals(value))
    1:   {
    1:     mFocusedValue = value;
    1:     // Dispatch the change event
    1:     nsEventStatus status = nsEventStatus_eIgnore;
    1:     nsInputEvent event(PR_TRUE, NS_FORM_CHANGE, nsnull);
  238:     nsCOMPtr<nsIPresShell> shell = PresContext()->PresShell();
   95:     shell->HandleEventWithTarget(&event, nsnull, mContent, &status);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //======
    1: //privates
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::GetValue(nsAString& aValue, PRBool aIgnoreWrap) const
    1: {
    1:   aValue.Truncate();  // initialize out param
    1:   nsresult rv = NS_OK;
    1:   
    1:   if (mEditor && mUseEditor) 
    1:   {
    1:     PRUint32 flags = (nsIDocumentEncoder::OutputLFLineBreak |
    1:                       nsIDocumentEncoder::OutputPreformatted |
    1:                       nsIDocumentEncoder::OutputPersistNBSP);
    1: 
    1:     if (PR_TRUE==IsPlainTextControl())
    1:     {
    1:       flags |= nsIDocumentEncoder::OutputBodyOnly;
    1:     }
    1: 
    1:     if (!aIgnoreWrap) {
    1:       nsHTMLTextWrap wrapProp;
    1:       if (::GetWrapPropertyEnum(mContent, wrapProp) &&
    1:           wrapProp == eHTMLTextWrap_Hard) {
    1:         flags |= nsIDocumentEncoder::OutputWrap;
    1:       }
    1:     }
    1: 
    1:     // What follows is a bit of a hack.  The problem is that we could be in
    1:     // this method because we're being destroyed for whatever reason while
    1:     // script is executing.  If that happens, editor will run with the
    1:     // privileges of the executing script, which means it may not be able to
    1:     // access its own DOM nodes!  Let's try to deal with that by pushing a null
    1:     // JSContext on the JSContext stack to make it clear that we're native
    1:     // code.  Note that any script that's directly trying to access our value
    1:     // has to be going through some scriptable object to do that and that
    1:     // already does the relevant security checks.
    1:     // XXXbz if we could just get the textContent of our anonymous content (eg
    1:     // if plaintext editor didn't create <br> nodes all over), we wouldn't need
    1:     // this.
25038:     { /* Scope for context pusher */
25038:       nsCxPusher pusher;
25038:       pusher.PushNull();
    1:       
    1:       rv = mEditor->OutputToString(NS_LITERAL_STRING("text/plain"), flags,
    1:                                    aValue);
    1:     }
    1:   }
    1:   else
    1:   {
    1:     // Otherwise get the value from content.
    1:     nsCOMPtr<nsIDOMHTMLInputElement> inputControl = do_QueryInterface(mContent);
    1:     if (inputControl)
    1:     {
    1:       rv = inputControl->GetValue(aValue);
    1:     }
    1:     else
    1:     {
    1:       nsCOMPtr<nsIDOMHTMLTextAreaElement> textareaControl
    1:           = do_QueryInterface(mContent);
    1:       if (textareaControl)
    1:       {
    1:         rv = textareaControl->GetValue(aValue);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: // END IMPLEMENTING NS_IFORMCONTROLFRAME
    1: 
    1: nsresult
    1: nsTextControlFrame::SetValue(const nsAString& aValue)
    1: {
    1:   // XXX this method should actually propagate errors!  It'd make debugging it
    1:   // so much easier...
    1:   if (mEditor && mUseEditor) 
    1:   {
 3721:     // This method isn't used for user-generated changes, except for calls
 3721:     // from nsFileControlFrame which sets mFireChangeEventState==true and
 3721:     // restores it afterwards (ie. we want 'change' events for those changes).
 3721:     // Focused value must be updated to prevent incorrect 'change' events,
 3721:     // but only if user hasn't changed the value.
 3721:     nsString val;
 3721:     GetText(&val);
 3721:     PRBool focusValueInit = !mFireChangeEventState &&
 3721:       mFocusedValue.Equals(val);
 3721: 
    1:     nsCOMPtr<nsIEditor> editor = mEditor;
    1:     nsWeakFrame weakFrame(this);
    1:     nsAutoString currentValue;
    1:     GetValue(currentValue, PR_FALSE);
    1:     if (IsSingleLineTextControl())
    1:     {
    1:       RemoveNewlines(currentValue); 
    1:     }
    1:     // this is necessary to avoid infinite recursion
    1:     if (!currentValue.Equals(aValue))
    1:     {
    1:       // \r is an illegal character in the dom, but people use them,
    1:       // so convert windows and mac platform linebreaks to \n:
    1:       // Unfortunately aValue is declared const, so we have to copy
    1:       // in order to do this substitution.
    1:       currentValue.Assign(aValue);
    1:       ::PlatformToDOMLineBreaks(currentValue);
    1: 
    1:       nsCOMPtr<nsIDOMDocument>domDoc;
    1:       nsresult rv = editor->GetDocument(getter_AddRefs(domDoc));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:       NS_ENSURE_STATE(domDoc);
    1: 
25038:       PRBool outerTransaction;
    1:       // Time to mess with our security context... See comments in GetValue()
    1:       // for why this is needed.  Note that we have to do this up here, because
    1:       // otherwise SelectAll() will fail.
25038:       { /* Scope for context pusher */
25038:         nsCxPusher pusher;
25038:         pusher.PushNull();
    1: 
    1:         nsCOMPtr<nsISelection> domSel;
    1:         nsCOMPtr<nsISelectionPrivate> selPriv;
25038:         mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
25038:                               getter_AddRefs(domSel));
    1:         if (domSel)
    1:         {
    1:           selPriv = do_QueryInterface(domSel);
    1:           if (selPriv)
    1:             selPriv->StartBatchChanges();
    1:         }
    1: 
 8295:         nsCOMPtr<nsISelectionController> kungFuDeathGrip = mSelCon;
    1:         mSelCon->SelectAll();
    1:         nsCOMPtr<nsIPlaintextEditor> plaintextEditor = do_QueryInterface(editor);
 8295:         if (!plaintextEditor || !weakFrame.IsAlive()) {
    1:           NS_WARNING("Somehow not a plaintext editor?");
    1:           return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         // Since this code does not handle user-generated changes to the text,
    1:         // make sure we don't fire oninput when the editor notifies us.
    1:         // (mNotifyOnInput must be reset before we return).
    1: 
    1:         // To protect against a reentrant call to SetValue, we check whether
    1:         // another SetValue is already happening for this frame.  If it is,
    1:         // we must wait until we unwind to re-enable oninput events.
25038:         outerTransaction = mNotifyOnInput;
    1:         if (outerTransaction)
    1:           mNotifyOnInput = PR_FALSE;
    1: 
    1:         // get the flags, remove readonly and disabled, set the value,
    1:         // restore flags
    1:         PRUint32 flags, savedFlags;
    1:         editor->GetFlags(&savedFlags);
    1:         flags = savedFlags;
    1:         flags &= ~(nsIPlaintextEditor::eEditorDisabledMask);
    1:         flags &= ~(nsIPlaintextEditor::eEditorReadonlyMask);
    1:         editor->SetFlags(flags);
    1: 
 4889:         // Also don't enforce max-length here
 4889:         PRInt32 savedMaxLength;
 4889:         plaintextEditor->GetMaxTextLength(&savedMaxLength);
 4889:         plaintextEditor->SetMaxTextLength(-1);
 4889: 
    1:         if (currentValue.Length() < 1)
    1:           editor->DeleteSelection(nsIEditor::eNone);
    1:         else {
 4889:           if (plaintextEditor)
 4889:             plaintextEditor->InsertText(currentValue);
    1:         }
    1: 
 4889:         plaintextEditor->SetMaxTextLength(savedMaxLength);
    1:         editor->SetFlags(savedFlags);
    1:         if (selPriv)
    1:           selPriv->EndBatchChanges();
    1:       }
    1: 
    1:       NS_ENSURE_STATE(weakFrame.IsAlive());
    1:       if (outerTransaction)
    1:         mNotifyOnInput = PR_TRUE;
    1: 
 3721:       if (focusValueInit) {
    1:         // Reset mFocusedValue so the onchange event doesn't fire incorrectly.
    1:         InitFocusedValue();
    1:       }
    1:     }
    1: 
    1:     NS_ENSURE_STATE(weakFrame.IsAlive());
    1:     nsIScrollableView* scrollableView = GetScrollableView();
    1:     if (scrollableView)
    1:     {
    1:       // Scroll the upper left corner of the text control's
    1:       // content area back into view.
    1: 
21290:       scrollableView->ScrollTo(0, 0, 0);
    1:     }
    1:   }
    1:   else
    1:   {
    1:     // Otherwise set the value in content.
    1:     nsCOMPtr<nsITextControlElement> textControl = do_QueryInterface(mContent);
    1:     if (textControl)
    1:     {
    1:       textControl->TakeTextFrameValue(aValue);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::SetInitialChildList(nsIAtom*        aListName,
30790:                                         nsFrameList&    aChildList)
    1: {
    1:   nsresult rv = nsBoxFrame::SetInitialChildList(aListName, aChildList);
24402: 
    1:   //look for scroll view below this frame go along first child list
    1:   nsIFrame* first = GetFirstChild(nsnull);
    1: 
    1:   // Mark the scroll frame as being a reflow root. This will allow
    1:   // incremental reflows to be initiated at the scroll frame, rather
    1:   // than descending from the root frame of the frame hierarchy.
    1:   first->AddStateBits(NS_FRAME_REFLOW_ROOT);
    1: 
23554:   nsIScrollableFrame *scrollableFrame = do_QueryFrame(first);
    1:   NS_ASSERTION(scrollableFrame, "Child must be scrollable");
    1: 
    1:   // we must turn off scrollbars for singleline text controls
    1:   // XXX FIXME this should be removed,
    1:   // nsGfxScrollFrameInner::CreateAnonymousContent handles this
    1:   if (IsSingleLineTextControl()) 
    1:   {
    1:     if (scrollableFrame)
    1:       scrollableFrame->SetScrollbarVisibility(PR_FALSE, PR_FALSE);
    1:   }
    1: 
29018:   //register key listeners
    1:   nsCOMPtr<nsIDOMEventGroup> systemGroup;
 1418:   mContent->GetSystemEventGroup(getter_AddRefs(systemGroup));
    1:   nsCOMPtr<nsIDOM3EventTarget> dom3Targ = do_QueryInterface(mContent);
    1:   if (dom3Targ) {
    1:     // cast because of ambiguous base
 3233:     nsIDOMEventListener *listener = static_cast<nsIDOMKeyListener*>
 3233:                                                (mTextListener);
    1: 
    1:     dom3Targ->AddGroupedEventListener(NS_LITERAL_STRING("keydown"),
    1:                                       listener, PR_FALSE, systemGroup);
    1:     dom3Targ->AddGroupedEventListener(NS_LITERAL_STRING("keypress"),
    1:                                       listener, PR_FALSE, systemGroup);
    1:     dom3Targ->AddGroupedEventListener(NS_LITERAL_STRING("keyup"),
    1:                                       listener, PR_FALSE, systemGroup);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsIScrollableView* nsTextControlFrame::GetScrollableView()
    1: {
    1:   nsIFrame* first = GetFirstChild(nsnull);
23554:   nsIScrollableFrame* scrollableFrame = do_QueryFrame(first);
    1:   return scrollableFrame ? scrollableFrame->GetScrollableView() : nsnull;
    1: }
    1: 
    1: PRBool
    1: nsTextControlFrame::IsScrollable() const
    1: {
    1:   return !IsSingleLineTextControl();
    1: }
    1: 
    1: void
    1: nsTextControlFrame::SetValueChanged(PRBool aValueChanged)
    1: {
    1:   nsCOMPtr<nsITextControlElement> elem = do_QueryInterface(mContent);
    1:   if (elem) {
    1:     elem->SetValueChanged(aValueChanged);
    1:   }
    1: }
    1: 
    1: /* static */ void
    1: nsTextControlFrame::ShutDown()
    1: {
    1:   NS_IF_RELEASE(sNativeTextAreaBindings);
    1:   NS_IF_RELEASE(sNativeInputBindings);
    1: }
