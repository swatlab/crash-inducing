 3037: /******* BEGIN LICENSE BLOCK *******
 3037:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 3037:  * 
 3037:  * The contents of this file are subject to the Mozilla Public License Version
 3037:  * 1.1 (the "License"); you may not use this file except in compliance with
 3037:  * the License. You may obtain a copy of the License at
 3037:  * http://www.mozilla.org/MPL/
 3037:  * 
 3037:  * Software distributed under the License is distributed on an "AS IS" basis,
 3037:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 3037:  * for the specific language governing rights and limitations under the
 3037:  * License.
 3037:  * 
 3037:  * The Initial Developers of the Original Code are Kevin Hendricks (MySpell)
 3042:  * and László Németh (Hunspell). Portions created by the Initial Developers
 3037:  * are Copyright (C) 2002-2005 the Initial Developers. All Rights Reserved.
 3037:  * 
 3037:  * Contributor(s): Kevin Hendricks (kevin.hendricks@sympatico.ca)
 3042:  *                 David Einstein (deinst@world.std.com)
 3037:  *                 László Németh (nemethl@gyorsposta.hu)
43385:  *                 Caolan McNamara (caolanm@redhat.com)
 3037:  *                 Davide Prina
 3037:  *                 Giuseppe Modugno
 3037:  *                 Gianluca Turconi
 3037:  *                 Simon Brouwer
 3037:  *                 Noll Janos
 3037:  *                 Biro Arpad
 3037:  *                 Goldman Eleonora
 3037:  *                 Sarlos Tamas
 3037:  *                 Bencsath Boldizsar
 3037:  *                 Halacsy Peter
 3037:  *                 Dvornik Laszlo
 3037:  *                 Gefferth Andras
 3037:  *                 Nagy Viktor
 3037:  *                 Varga Daniel
 3037:  *                 Chris Halls
 3037:  *                 Rene Engelhard
 3037:  *                 Bram Moolenaar
 3037:  *                 Dafydd Jones
 3037:  *                 Harri Pitkanen
 3037:  *                 Andras Timar
 3037:  *                 Tor Lillqvist
 3037:  * 
 3037:  * Alternatively, the contents of this file may be used under the terms of
 3037:  * either the GNU General Public License Version 2 or later (the "GPL"), or
 3037:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 3037:  * in which case the provisions of the GPL or the LGPL are applicable instead
 3037:  * of those above. If you wish to allow use of your version of this file only
 3037:  * under the terms of either the GPL or the LGPL, and not to allow others to
 3037:  * use your version of this file under the terms of the MPL, indicate your
 3037:  * decision by deleting the provisions above and replace them with the notice
 3037:  * and other provisions required by the GPL or the LGPL. If you do not delete
 3037:  * the provisions above, a recipient may use your version of this file under
 3037:  * the terms of any one of the MPL, the GPL or the LGPL.
 3037:  *
 3037:  ******* END LICENSE BLOCK *******/
 3037: 
 3037: #include <stdlib.h>
 3037: #include <string.h>
 3037: #include <stdio.h>
 3037: #include <ctype.h>
 3037: 
 3037: #include "affentry.hxx"
 3037: #include "csutil.hxx"
 3037: 
 3037: PfxEntry::PfxEntry(AffixMgr* pmgr, affentry* dp)
 3037: {
 3037:   // register affix manager
 3037:   pmyMgr = pmgr;
 3037: 
43385:   // set up its initial values
 3037: 
 3037:   aflag = dp->aflag;         // flag
 3037:   strip = dp->strip;         // string to strip
 3037:   appnd = dp->appnd;         // string to append
 3037:   stripl = dp->stripl;       // length of strip string
 3037:   appndl = dp->appndl;       // length of append string
21326:   numconds = dp->numconds;   // length of the condition
 3037:   opts = dp->opts;           // cross product flag
 3037:   // then copy over all of the conditions
21326:   if (opts & aeLONGCOND) {
21326:     memcpy(c.conds, dp->c.l.conds1, MAXCONDLEN_1);
21326:     c.l.conds2 = dp->c.l.conds2;
21326:   } else memcpy(c.conds, dp->c.conds, MAXCONDLEN);
 3037:   next = NULL;
 3037:   nextne = NULL;
 3037:   nexteq = NULL;
 3037:   morphcode = dp->morphcode;
 3037:   contclass = dp->contclass;
 3037:   contclasslen = dp->contclasslen;
 3037: }
 3037: 
 3037: 
 3037: PfxEntry::~PfxEntry()
 3037: {
 3037:     aflag = 0;
 3037:     if (appnd) free(appnd);
 3037:     if (strip) free(strip);
 3037:     pmyMgr = NULL;
 3037:     appnd = NULL;
 3037:     strip = NULL;
21326:     if (opts & aeLONGCOND) free(c.l.conds2);
 3037:     if (morphcode && !(opts & aeALIASM)) free(morphcode);
 3037:     if (contclass && !(opts & aeALIASF)) free(contclass);
 3037: }
 3037: 
 3037: // add prefix to this word assuming conditions hold
 3037: char * PfxEntry::add(const char * word, int len)
 3037: {
 3037:     char tword[MAXWORDUTF8LEN + 4];
 3037: 
21326:     if ((len > stripl || (len == 0 && pmyMgr->get_fullstrip())) && 
21326:        (len >= numconds) && test_condition(word) &&
 3037:        (!stripl || (strncmp(word, strip, stripl) == 0)) &&
 3037:        ((MAXWORDUTF8LEN + 4) > (len + appndl - stripl))) {
 3037:     /* we have a match so add prefix */
 3037:               char * pp = tword;
 3037:               if (appndl) {
 3037:                   strcpy(tword,appnd);
 3037:                   pp += appndl;
 3037:                }
 3037:                strcpy(pp, (word + stripl));
 3037:                return mystrdup(tword);
 3037:      }
 3037:      return NULL;
 3037: }
 3037: 
21326: inline char * PfxEntry::nextchar(char * p) {
21326:     if (p) {
21326:         p++;
21326:         if (opts & aeLONGCOND) {
21326:             // jump to the 2nd part of the condition
21326:             if (p == c.conds + MAXCONDLEN_1) return c.l.conds2;
21326:         // end of the MAXCONDLEN length condition
21326:         } else if (p == c.conds + MAXCONDLEN) return NULL;
21326: 	return *p ? p : NULL;
21326:     }
21326:     return NULL;
21326: }
 3037: 
 3037: inline int PfxEntry::test_condition(const char * st)
 3037: {
21326:     const char * pos = NULL; // group with pos input position
21326:     bool neg = false;        // complementer
21326:     bool ingroup = false;    // character in the group
21326:     if (numconds == 0) return 1;
21326:     char * p = c.conds;
21326:     while (1) {
21326:       switch (*p) {
21326:         case '\0': return 1;
21326:         case '[': { 
21326:                 neg = false;
21326:                 ingroup = false;
21326:                 p = nextchar(p);
21326:                 pos = st; break;
 3037:             }
21326:         case '^': { p = nextchar(p); neg = true; break; }
21326:         case ']': { 
21326:                 if ((neg && ingroup) || (!neg && !ingroup)) return 0;
21326:                 pos = NULL;
21326:                 p = nextchar(p);
21326:                 // skip the next character
63910:                 if (!ingroup && *st) for (st++; (opts & aeUTF8) && (*st & 0xc0) == 0x80; st++);
21326:                 if (*st == '\0' && p) return 0; // word <= condition
21326:                 break;
 3037:             }
21326:          case '.': if (!pos) { // dots are not metacharacters in groups: [.]
21326:                 p = nextchar(p);
21326:                 // skip the next character
21326:                 for (st++; (opts & aeUTF8) && (*st & 0xc0) == 0x80; st++);
21326:                 if (*st == '\0' && p) return 0; // word <= condition
21326:                 break;
 3037:             }
21326:     default: {
21326:                 if (*st == *p) {
21326:                     st++;
21326:                     p = nextchar(p);
21326:                     if ((opts & aeUTF8) && (*(st - 1) & 0x80)) { // multibyte
21326:                         while (p && (*p & 0xc0) == 0x80) {       // character
21326:                             if (*p != *st) {
21326:                                 if (!pos) return 0;
21326:                                 st = pos;
21326:                                 break;
 3037:                             }
21326:                             p = nextchar(p);
21326:                             st++;
 3037:                         }
21326:                         if (pos && st != pos) {
21326:                             ingroup = true;
21326:                             while (p && *p != ']' && (p = nextchar(p)));
 3037:                         }
21326:                     } else if (pos) {
21326:                         ingroup = true;
21326:                         while (p && *p != ']' && (p = nextchar(p)));
 3037:                     }
21326:                 } else if (pos) { // group
21326:                     p = nextchar(p);
21326:                 } else return 0;
21326:             }
21326:       }
21326:       if (!p) return 1;
21326:     }
21326: }
 3037: 
 3037: // check if this prefix entry matches
 3037: struct hentry * PfxEntry::checkword(const char * word, int len, char in_compound, const FLAG needflag)
 3037: {
 3037:     int                 tmpl;   // length of tmpword
 3037:     struct hentry *     he;     // hash entry of root word or NULL
 3037:     char                tmpword[MAXWORDUTF8LEN + 4];
 3037: 
 3037:     // on entry prefix is 0 length or already matches the beginning of the word.
 3037:     // So if the remaining root word has positive length
 3037:     // and if there are enough chars in root word and added back strip chars
 3037:     // to meet the number of characters conditions, then test it
 3037: 
 3037:      tmpl = len - appndl;
 3037: 
21326:      if (tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) {
 3037: 
 3037:             // generate new root word by removing prefix and adding
 3037:             // back any characters that would have been stripped
 3037: 
 3037:             if (stripl) strcpy (tmpword, strip);
 3037:             strcpy ((tmpword + stripl), (word + appndl));
 3037: 
 3037:             // now make sure all of the conditions on characters
 3037:             // are met.  Please see the appendix at the end of
 3037:             // this file for more info on exactly what is being
 3037:             // tested
 3037: 
 3037:             // if all conditions are met then check if resulting
 3037:             // root word in the dictionary
 3037: 
 3037:             if (test_condition(tmpword)) {
 3037:                 tmpl += stripl;
 3037:                 if ((he = pmyMgr->lookup(tmpword)) != NULL) {
 3037:                    do {
 3037:                       if (TESTAFF(he->astr, aflag, he->alen) &&
21326:                         // forbid single prefixes with needaffix flag
21326:                         ! TESTAFF(contclass, pmyMgr->get_needaffix(), contclasslen) &&
 3037:                         // needflag
 3037:                         ((!needflag) || TESTAFF(he->astr, needflag, he->alen) ||
 3037:                          (contclass && TESTAFF(contclass, needflag, contclasslen))))
 3037:                             return he;
 3037:                       he = he->next_homonym; // check homonyms
 3037:                    } while (he);
 3037:                 }
 3037: 
 3037:                 // prefix matched but no root word was found
 3037:                 // if aeXPRODUCT is allowed, try again but now
 3037:                 // ross checked combined with a suffix
 3037: 
 3037:                 //if ((opts & aeXPRODUCT) && in_compound) {
 3037:                 if ((opts & aeXPRODUCT)) {
43385:                    he = pmyMgr->suffix_check(tmpword, tmpl, aeXPRODUCT, this, NULL,
 3037:                         0, NULL, FLAG_NULL, needflag, in_compound);
 3037:                    if (he) return he;
 3037:                 }
 3037:             }
 3037:      }
 3037:     return NULL;
 3037: }
 3037: 
 3037: // check if this prefix entry matches
 3037: struct hentry * PfxEntry::check_twosfx(const char * word, int len,
 3037:     char in_compound, const FLAG needflag)
 3037: {
 3037:     int                 tmpl;   // length of tmpword
 3037:     struct hentry *     he;     // hash entry of root word or NULL
 3037:     char                tmpword[MAXWORDUTF8LEN + 4];
 3037: 
 3037:     // on entry prefix is 0 length or already matches the beginning of the word.
 3037:     // So if the remaining root word has positive length
 3037:     // and if there are enough chars in root word and added back strip chars
 3037:     // to meet the number of characters conditions, then test it
 3037: 
 3037:      tmpl = len - appndl;
 3037: 
21326:      if ((tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) &&
21326:         (tmpl + stripl >= numconds)) {
 3037: 
 3037:             // generate new root word by removing prefix and adding
 3037:             // back any characters that would have been stripped
 3037: 
 3037:             if (stripl) strcpy (tmpword, strip);
 3037:             strcpy ((tmpword + stripl), (word + appndl));
 3037: 
 3037:             // now make sure all of the conditions on characters
 3037:             // are met.  Please see the appendix at the end of
 3037:             // this file for more info on exactly what is being
 3037:             // tested
 3037: 
 3037:             // if all conditions are met then check if resulting
 3037:             // root word in the dictionary
 3037: 
 3037:             if (test_condition(tmpword)) {
 3037:                 tmpl += stripl;
 3037: 
 3037:                 // prefix matched but no root word was found
 3037:                 // if aeXPRODUCT is allowed, try again but now
 3037:                 // cross checked combined with a suffix
 3037: 
 3037:                 if ((opts & aeXPRODUCT) && (in_compound != IN_CPD_BEGIN)) {
43385:                    he = pmyMgr->suffix_check_twosfx(tmpword, tmpl, aeXPRODUCT, this, needflag);
 3037:                    if (he) return he;
 3037:                 }
 3037:             }
 3037:      }
 3037:     return NULL;
 3037: }
 3037: 
 3037: // check if this prefix entry matches
 3037: char * PfxEntry::check_twosfx_morph(const char * word, int len,
 3037:          char in_compound, const FLAG needflag)
 3037: {
 3037:     int                 tmpl;   // length of tmpword
 3037:     char                tmpword[MAXWORDUTF8LEN + 4];
 3037: 
 3037:     // on entry prefix is 0 length or already matches the beginning of the word.
 3037:     // So if the remaining root word has positive length
 3037:     // and if there are enough chars in root word and added back strip chars
 3037:     // to meet the number of characters conditions, then test it
 3037: 
 3037:      tmpl = len - appndl;
 3037: 
21326:      if ((tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) &&
21326:         (tmpl + stripl >= numconds)) {
 3037: 
 3037:             // generate new root word by removing prefix and adding
 3037:             // back any characters that would have been stripped
 3037: 
 3037:             if (stripl) strcpy (tmpword, strip);
 3037:             strcpy ((tmpword + stripl), (word + appndl));
 3037: 
 3037:             // now make sure all of the conditions on characters
 3037:             // are met.  Please see the appendix at the end of
 3037:             // this file for more info on exactly what is being
 3037:             // tested
 3037: 
 3037:             // if all conditions are met then check if resulting
 3037:             // root word in the dictionary
 3037: 
 3037:             if (test_condition(tmpword)) {
 3037:                 tmpl += stripl;
 3037: 
 3037:                 // prefix matched but no root word was found
 3037:                 // if aeXPRODUCT is allowed, try again but now
 3037:                 // ross checked combined with a suffix
 3037: 
 3037:                 if ((opts & aeXPRODUCT) && (in_compound != IN_CPD_BEGIN)) {
 3037:                     return pmyMgr->suffix_check_twosfx_morph(tmpword, tmpl,
43385:                              aeXPRODUCT, this, needflag);
 3037:                 }
 3037:             }
 3037:      }
 3037:     return NULL;
 3037: }
 3037: 
 3037: // check if this prefix entry matches
 3037: char * PfxEntry::check_morph(const char * word, int len, char in_compound, const FLAG needflag)
 3037: {
 3037:     int                 tmpl;   // length of tmpword
 3037:     struct hentry *     he;     // hash entry of root word or NULL
 3037:     char                tmpword[MAXWORDUTF8LEN + 4];
 3037:     char                result[MAXLNLEN];
 3037:     char * st;
 3037: 
 3037:     *result = '\0';
 3037: 
 3037:     // on entry prefix is 0 length or already matches the beginning of the word.
 3037:     // So if the remaining root word has positive length
 3037:     // and if there are enough chars in root word and added back strip chars
 3037:     // to meet the number of characters conditions, then test it
 3037: 
 3037:      tmpl = len - appndl;
 3037: 
21326:      if ((tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) &&
21326:         (tmpl + stripl >= numconds)) {
 3037: 
 3037:             // generate new root word by removing prefix and adding
 3037:             // back any characters that would have been stripped
 3037: 
 3037:             if (stripl) strcpy (tmpword, strip);
 3037:             strcpy ((tmpword + stripl), (word + appndl));
 3037: 
 3037:             // now make sure all of the conditions on characters
 3037:             // are met.  Please see the appendix at the end of
 3037:             // this file for more info on exactly what is being
 3037:             // tested
 3037: 
 3037:             // if all conditions are met then check if resulting
 3037:             // root word in the dictionary
 3037: 
 3037:             if (test_condition(tmpword)) {
 3037:                 tmpl += stripl;
 3037:                 if ((he = pmyMgr->lookup(tmpword)) != NULL) {
 3037:                     do {
 3037:                       if (TESTAFF(he->astr, aflag, he->alen) &&
21326:                         // forbid single prefixes with needaffix flag
21326:                         ! TESTAFF(contclass, pmyMgr->get_needaffix(), contclasslen) &&
 3037:                         // needflag
 3037:                         ((!needflag) || TESTAFF(he->astr, needflag, he->alen) ||
 3037:                          (contclass && TESTAFF(contclass, needflag, contclasslen)))) {
21326:                             if (morphcode) {
21326:                                 mystrcat(result, " ", MAXLNLEN);
21326:                                 mystrcat(result, morphcode, MAXLNLEN);
21326:                             } else mystrcat(result,getKey(), MAXLNLEN);
21326:                             if (!HENTRY_FIND(he, MORPH_STEM)) {
21326:                                 mystrcat(result, " ", MAXLNLEN);
21326:                                 mystrcat(result, MORPH_STEM, MAXLNLEN);
21326:                                 mystrcat(result, HENTRY_WORD(he), MAXLNLEN);
 3037:                             }
21326:                             // store the pointer of the hash entry
21326:                             if (HENTRY_DATA(he)) {
21326:                                 mystrcat(result, " ", MAXLNLEN);
21326:                                 mystrcat(result, HENTRY_DATA2(he), MAXLNLEN);
21326:                             } else {
21326:                                 // return with debug information
21326:                                 char * flag = pmyMgr->encode_flag(getFlag());
21326:                                 mystrcat(result, " ", MAXLNLEN);
21326:                                 mystrcat(result, MORPH_FLAG, MAXLNLEN);
21326:                                 mystrcat(result, flag, MAXLNLEN);
21326:                                 free(flag);
21326:                             }
21326:                             mystrcat(result, "\n", MAXLNLEN);
 3037:                       }
 3037:                       he = he->next_homonym;
 3037:                     } while (he);
 3037:                 }
 3037: 
 3037:                 // prefix matched but no root word was found
 3037:                 // if aeXPRODUCT is allowed, try again but now
 3037:                 // ross checked combined with a suffix
 3037: 
 3037:                 if ((opts & aeXPRODUCT) && (in_compound != IN_CPD_BEGIN)) {
43385:                    st = pmyMgr->suffix_check_morph(tmpword, tmpl, aeXPRODUCT, this,
 3037:                      FLAG_NULL, needflag);
 3037:                    if (st) {
21326:                         mystrcat(result, st, MAXLNLEN);
 3037:                         free(st);
 3037:                    }
 3037:                 }
 3037:             }
 3037:      }
 3037:     
 3037:     if (*result) return mystrdup(result);
 3037:     return NULL;
 3037: }
 3037: 
 3037: SfxEntry::SfxEntry(AffixMgr * pmgr, affentry* dp)
 3037: {
 3037:   // register affix manager
 3037:   pmyMgr = pmgr;
 3037: 
43385:   // set up its initial values
 3037:   aflag = dp->aflag;         // char flag
 3037:   strip = dp->strip;         // string to strip
 3037:   appnd = dp->appnd;         // string to append
 3037:   stripl = dp->stripl;       // length of strip string
 3037:   appndl = dp->appndl;       // length of append string
21326:   numconds = dp->numconds;   // length of the condition
 3037:   opts = dp->opts;           // cross product flag
 3037: 
 3037:   // then copy over all of the conditions
21326:   if (opts & aeLONGCOND) {
21326:     memcpy(c.l.conds1, dp->c.l.conds1, MAXCONDLEN_1);
21326:     c.l.conds2 = dp->c.l.conds2;
21326:   } else memcpy(c.conds, dp->c.conds, MAXCONDLEN);
86232:   next = NULL;
86232:   nextne = NULL;
86232:   nexteq = NULL;
 3037:   rappnd = myrevstrdup(appnd);
 3037:   morphcode = dp->morphcode;
 3037:   contclass = dp->contclass;
 3037:   contclasslen = dp->contclasslen;
 3037: }
 3037: 
 3037: 
 3037: SfxEntry::~SfxEntry()
 3037: {
 3037:     aflag = 0;
 3037:     if (appnd) free(appnd);
 3037:     if (rappnd) free(rappnd);
 3037:     if (strip) free(strip);
 3037:     pmyMgr = NULL;
 3037:     appnd = NULL;
 3037:     strip = NULL;
21326:     if (opts & aeLONGCOND) free(c.l.conds2);
 3037:     if (morphcode && !(opts & aeALIASM)) free(morphcode);
 3037:     if (contclass && !(opts & aeALIASF)) free(contclass);
 3037: }
 3037: 
 3037: // add suffix to this word assuming conditions hold
 3037: char * SfxEntry::add(const char * word, int len)
 3037: {
 3037:     char                tword[MAXWORDUTF8LEN + 4];
 3037: 
 3037:      /* make sure all conditions match */
21326:      if ((len > stripl || (len == 0 && pmyMgr->get_fullstrip())) &&
21326:         (len >= numconds) && test_condition(word + len, word) &&
 3037:         (!stripl || (strcmp(word + len - stripl, strip) == 0)) &&
 3037:         ((MAXWORDUTF8LEN + 4) > (len + appndl - stripl))) {
 3037:               /* we have a match so add suffix */
 3037:               strcpy(tword,word);
 3037:               if (appndl) {
 3037:                   strcpy(tword + len - stripl, appnd);
 3037:               } else {
 3037:                   *(tword + len - stripl) = '\0';
 3037:               }
 3037:               return mystrdup(tword);
 3037:      }
 3037:      return NULL;
 3037: }
 3037: 
21326: inline char * SfxEntry::nextchar(char * p) {
21326:     if (p) {
21326: 	p++;
21326: 	if (opts & aeLONGCOND) {
21326:     	    // jump to the 2nd part of the condition
21326:     	    if (p == c.l.conds1 + MAXCONDLEN_1) return c.l.conds2;
21326: 	// end of the MAXCONDLEN length condition
21326: 	} else if (p == c.conds + MAXCONDLEN) return NULL;
21326: 	return *p ? p : NULL;
21326:     }
21326:     return NULL;
21326: }
 3037: 
 3037: inline int SfxEntry::test_condition(const char * st, const char * beg)
 3037: {
21326:     const char * pos = NULL;    // group with pos input position
21326:     bool neg = false;           // complementer
21326:     bool ingroup = false;       // character in the group
21326:     if (numconds == 0) return 1;
21326:     char * p = c.conds;
21326:     st--;
21326:     int i = 1;
21326:     while (1) {
21326:       switch (*p) {
21326:         case '\0': return 1;
21326:         case '[': { p = nextchar(p); pos = st; break; }
21326:         case '^': { p = nextchar(p); neg = true; break; }
21326:         case ']': { if (!neg && !ingroup) return 0;
21326:                 i++;
21326:                 // skip the next character
21326:                 if (!ingroup) {
21326:                     for (; (opts & aeUTF8) && (st >= beg) && (*st & 0xc0) == 0x80; st--);
21326:                     st--;
 3037:                 }                    
21326:                 pos = NULL;
21326:                 neg = false;
21326:                 ingroup = false;
21326:                 p = nextchar(p);
21326:                 if (st < beg && p) return 0; // word <= condition
21326:                 break;
 3037:             }
21326:         case '.': if (!pos) { // dots are not metacharacters in groups: [.]
21326:                 p = nextchar(p);
21326:                 // skip the next character
21326:                 for (st--; (opts & aeUTF8) && (st >= beg) && (*st & 0xc0) == 0x80; st--);
21326:                 if (st < beg) { // word <= condition
21326: 		    if (p) return 0; else return 1;
 3037: 		}
21326:                 if ((opts & aeUTF8) && (*st & 0x80)) { // head of the UTF-8 character
21326:                     st--;
21326:                     if (st < beg) { // word <= condition
21326: 			if (p) return 0; else return 1;
 3037: 		    }
 3037:                 }
21326:                 break;
 3037:             }
21326:     default: {
21326:                 if (*st == *p) {
21326:                     p = nextchar(p);
21326:                     if ((opts & aeUTF8) && (*st & 0x80)) {
21326:                         st--;
21326:                         while (p && (st >= beg)) {
21326:                             if (*p != *st) {
21326:                                 if (!pos) return 0;
21326:                                 st = pos;
21326:                                 break;
 3037:                             }
21326:                             // first byte of the UTF-8 multibyte character
21326:                             if ((*p & 0xc0) != 0x80) break;
21326:                             p = nextchar(p);
21326:                             st--;
21326:                         }
21326:                         if (pos && st != pos) {
21326:                             if (neg) return 0;
21326:                             else if (i == numconds) return 1;
21326:                             ingroup = true;
21326:                             while (p && *p != ']' && (p = nextchar(p)));
21326: 			    st--;
21326:                         }
21326:                         if (p && *p != ']') p = nextchar(p);
21326:                     } else if (pos) {
21326:                         if (neg) return 0;
21326:                         else if (i == numconds) return 1;
21326:                         ingroup = true;
21326: 			while (p && *p != ']' && (p = nextchar(p)));
21326: //			if (p && *p != ']') p = nextchar(p);
21326:                         st--;
21326:                     }
21326:                     if (!pos) {
21326:                         i++;
21326:                         st--;
21326:                     }
21326:                     if (st < beg && p && *p != ']') return 0; // word <= condition
21326:                 } else if (pos) { // group
21326:                     p = nextchar(p);
21326:                 } else return 0;
21326:             }
21326:       }
21326:       if (!p) return 1;
21326:     }
21326: }
 3037: 
 3037: // see if this suffix is present in the word
 3037: struct hentry * SfxEntry::checkword(const char * word, int len, int optflags,
43385:     PfxEntry* ppfx, char ** wlst, int maxSug, int * ns, const FLAG cclass, const FLAG needflag,
 3037:     const FLAG badflag)
 3037: {
 3037:     int                 tmpl;            // length of tmpword
 3037:     struct hentry *     he;              // hash entry pointer
 3037:     unsigned char *     cp;
 3037:     char                tmpword[MAXWORDUTF8LEN + 4];
43385:     PfxEntry* ep = ppfx;
 3037: 
 3037:     // if this suffix is being cross checked with a prefix
 3037:     // but it does not support cross products skip it
 3037: 
 3037:     if (((optflags & aeXPRODUCT) != 0) && ((opts & aeXPRODUCT) == 0))
 3037:         return NULL;
 3037: 
 3037:     // upon entry suffix is 0 length or already matches the end of the word.
 3037:     // So if the remaining root word has positive length
 3037:     // and if there are enough chars in root word and added back strip chars
 3037:     // to meet the number of characters conditions, then test it
 3037: 
 3037:     tmpl = len - appndl;
 3037:     // the second condition is not enough for UTF-8 strings
 3037:     // it checked in test_condition()
 3037: 
21326:     if ((tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) &&
21326:         (tmpl + stripl >= numconds)) {
 3037: 
 3037:             // generate new root word by removing suffix and adding
 3037:             // back any characters that would have been stripped or
 3037:             // or null terminating the shorter string
 3037: 
 3037:             strcpy (tmpword, word);
 3037:             cp = (unsigned char *)(tmpword + tmpl);
 3037:             if (stripl) {
 3037:                 strcpy ((char *)cp, strip);
 3037:                 tmpl += stripl;
 3037:                 cp = (unsigned char *)(tmpword + tmpl);
 3037:             } else *cp = '\0';
 3037: 
 3037:             // now make sure all of the conditions on characters
 3037:             // are met.  Please see the appendix at the end of
21326:             // this file for more info on exactly what is being
21326:             // tested
 3037: 
 3037:             // if all conditions are met then check if resulting
 3037:             // root word in the dictionary
 3037: 
 3037:             if (test_condition((char *) cp, (char *) tmpword)) {
 3037: 
 3037: #ifdef SZOSZABLYA_POSSIBLE_ROOTS
 3037:                 fprintf(stdout,"%s %s %c\n", word, tmpword, aflag);
 3037: #endif
 3037:                 if ((he = pmyMgr->lookup(tmpword)) != NULL) {
 3037:                     do {
 3037:                         // check conditional suffix (enabled by prefix)
 3037:                         if ((TESTAFF(he->astr, aflag, he->alen) || (ep && ep->getCont() &&
 3037:                                     TESTAFF(ep->getCont(), aflag, ep->getContLen()))) &&
 3037:                             (((optflags & aeXPRODUCT) == 0) ||
43385:                             (ep && TESTAFF(he->astr, ep->getFlag(), he->alen)) ||
 3037:                              // enabled by prefix
43385:                             ((contclass) && (ep && TESTAFF(contclass, ep->getFlag(), contclasslen)))
 3037:                             ) &&
 3037:                             // handle cont. class
 3037:                             ((!cclass) ||
 3037:                                 ((contclass) && TESTAFF(contclass, cclass, contclasslen))
 3037:                             ) &&
 3037:                             // check only in compound homonyms (bad flags)
 3037:                             (!badflag || !TESTAFF(he->astr, badflag, he->alen)
 3037:                             ) &&
 3037:                             // handle required flag
 3037:                             ((!needflag) ||
 3037:                               (TESTAFF(he->astr, needflag, he->alen) ||
 3037:                               ((contclass) && TESTAFF(contclass, needflag, contclasslen)))
 3037:                             )
 3037:                         ) return he;
 3037:                         he = he->next_homonym; // check homonyms
 3037:                     } while (he);
 3037: 
 3037:                 // obsolote stemming code (used only by the
 3037:                 // experimental SuffixMgr:suggest_pos_stems)
 3037:                 // store resulting root in wlst
 3037:                 } else if (wlst && (*ns < maxSug)) {
 3037:                     int cwrd = 1;
 3037:                     for (int k=0; k < *ns; k++)
 3037:                         if (strcmp(tmpword, wlst[k]) == 0) cwrd = 0;
 3037:                     if (cwrd) {
 3037:                         wlst[*ns] = mystrdup(tmpword);
 3037:                         if (wlst[*ns] == NULL) {
 3037:                             for (int j=0; j<*ns; j++) free(wlst[j]);
 3037:                             *ns = -1;
 3037:                             return NULL;
 3037:                         }
 3037:                         (*ns)++;
 3037:                     }
 3037:                 }
 3037:             }
 3037:     }
 3037:     return NULL;
 3037: }
 3037: 
 3037: // see if two-level suffix is present in the word
 3037: struct hentry * SfxEntry::check_twosfx(const char * word, int len, int optflags,
43385:     PfxEntry* ppfx, const FLAG needflag)
 3037: {
 3037:     int                 tmpl;            // length of tmpword
 3037:     struct hentry *     he;              // hash entry pointer
 3037:     unsigned char *     cp;
 3037:     char                tmpword[MAXWORDUTF8LEN + 4];
43385:     PfxEntry* ep = ppfx;
 3037: 
 3037: 
 3037:     // if this suffix is being cross checked with a prefix
 3037:     // but it does not support cross products skip it
 3037: 
 3037:     if ((optflags & aeXPRODUCT) != 0 &&  (opts & aeXPRODUCT) == 0)
 3037:         return NULL;
 3037: 
 3037:     // upon entry suffix is 0 length or already matches the end of the word.
 3037:     // So if the remaining root word has positive length
 3037:     // and if there are enough chars in root word and added back strip chars
 3037:     // to meet the number of characters conditions, then test it
 3037: 
 3037:     tmpl = len - appndl;
 3037: 
21326:     if ((tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) &&
21326:        (tmpl + stripl >= numconds)) {
 3037: 
 3037:             // generate new root word by removing suffix and adding
 3037:             // back any characters that would have been stripped or
 3037:             // or null terminating the shorter string
 3037: 
 3037:             strcpy (tmpword, word);
 3037:             cp = (unsigned char *)(tmpword + tmpl);
 3037:             if (stripl) {
 3037:                 strcpy ((char *)cp, strip);
 3037:                 tmpl += stripl;
 3037:                 cp = (unsigned char *)(tmpword + tmpl);
 3037:             } else *cp = '\0';
 3037: 
 3037:             // now make sure all of the conditions on characters
 3037:             // are met.  Please see the appendix at the end of
 3037:             // this file for more info on exactly what is being
 3037:             // tested
 3037: 
 3037:             // if all conditions are met then recall suffix_check
 3037: 
 3037:             if (test_condition((char *) cp, (char *) tmpword)) {
 3037:                 if (ppfx) {
 3037:                     // handle conditional suffix
 3037:                     if ((contclass) && TESTAFF(contclass, ep->getFlag(), contclasslen))
 3037:                         he = pmyMgr->suffix_check(tmpword, tmpl, 0, NULL, NULL, 0, NULL, (FLAG) aflag, needflag);
 3037:                     else
 3037:                         he = pmyMgr->suffix_check(tmpword, tmpl, optflags, ppfx, NULL, 0, NULL, (FLAG) aflag, needflag);
 3037:                 } else {
 3037:                     he = pmyMgr->suffix_check(tmpword, tmpl, 0, NULL, NULL, 0, NULL, (FLAG) aflag, needflag);
 3037:                 }
 3037:                 if (he) return he;
 3037:             }
 3037:     }
 3037:     return NULL;
 3037: }
 3037: 
 3037: // see if two-level suffix is present in the word
 3037: char * SfxEntry::check_twosfx_morph(const char * word, int len, int optflags,
43385:     PfxEntry* ppfx, const FLAG needflag)
 3037: {
 3037:     int                 tmpl;            // length of tmpword
 3037:     unsigned char *     cp;
 3037:     char                tmpword[MAXWORDUTF8LEN + 4];
43385:     PfxEntry* ep = ppfx;
 3037:     char * st;
 3037: 
 3037:     char result[MAXLNLEN];
 3037: 
 3037:     *result = '\0';
 3037: 
 3037:     // if this suffix is being cross checked with a prefix
 3037:     // but it does not support cross products skip it
 3037: 
 3037:     if ((optflags & aeXPRODUCT) != 0 &&  (opts & aeXPRODUCT) == 0)
 3037:         return NULL;
 3037: 
 3037:     // upon entry suffix is 0 length or already matches the end of the word.
 3037:     // So if the remaining root word has positive length
 3037:     // and if there are enough chars in root word and added back strip chars
 3037:     // to meet the number of characters conditions, then test it
 3037: 
 3037:     tmpl = len - appndl;
 3037: 
21326:     if ((tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) &&
21326:        (tmpl + stripl >= numconds)) {
 3037: 
 3037:             // generate new root word by removing suffix and adding
 3037:             // back any characters that would have been stripped or
 3037:             // or null terminating the shorter string
 3037: 
 3037:             strcpy (tmpword, word);
 3037:             cp = (unsigned char *)(tmpword + tmpl);
 3037:             if (stripl) {
 3037:                 strcpy ((char *)cp, strip);
 3037:                 tmpl += stripl;
 3037:                 cp = (unsigned char *)(tmpword + tmpl);
 3037:             } else *cp = '\0';
 3037: 
 3037:             // now make sure all of the conditions on characters
 3037:             // are met.  Please see the appendix at the end of
 3037:             // this file for more info on exactly what is being
 3037:             // tested
 3037: 
 3037:             // if all conditions are met then recall suffix_check
 3037: 
 3037:             if (test_condition((char *) cp, (char *) tmpword)) {
 3037:                 if (ppfx) {
 3037:                     // handle conditional suffix
 3037:                     if ((contclass) && TESTAFF(contclass, ep->getFlag(), contclasslen)) {
 3037:                         st = pmyMgr->suffix_check_morph(tmpword, tmpl, 0, NULL, aflag, needflag);
 3037:                         if (st) {
43385:                             if (ppfx->getMorph()) {
43385:                                 mystrcat(result, ppfx->getMorph(), MAXLNLEN);
21326:                                 mystrcat(result, " ", MAXLNLEN);
 3037:                             }
21326:                             mystrcat(result,st, MAXLNLEN);
 3037:                             free(st);
 3037:                             mychomp(result);
 3037:                         }
 3037:                     } else {
 3037:                         st = pmyMgr->suffix_check_morph(tmpword, tmpl, optflags, ppfx, aflag, needflag);
 3037:                         if (st) {
21326:                             mystrcat(result, st, MAXLNLEN);
 3037:                             free(st);
 3037:                             mychomp(result);
 3037:                         }
 3037:                     }
 3037:                 } else {
 3037:                         st = pmyMgr->suffix_check_morph(tmpword, tmpl, 0, NULL, aflag, needflag);
 3037:                         if (st) {
21326:                             mystrcat(result, st, MAXLNLEN);
 3037:                             free(st);
 3037:                             mychomp(result);
 3037:                         }
 3037:                 }
 3037:                 if (*result) return mystrdup(result);
 3037:             }
 3037:     }
 3037:     return NULL;
 3037: }
 3037: 
 3037: // get next homonym with same affix
43385: struct hentry * SfxEntry::get_next_homonym(struct hentry * he, int optflags, PfxEntry* ppfx,
 3037:     const FLAG cclass, const FLAG needflag)
 3037: {
43385:     PfxEntry* ep = ppfx;
 3648:     FLAG eFlag = ep ? ep->getFlag() : FLAG_NULL;
 3037: 
 3037:     while (he->next_homonym) {
 3037:         he = he->next_homonym;
 3037:         if ((TESTAFF(he->astr, aflag, he->alen) || (ep && ep->getCont() && TESTAFF(ep->getCont(), aflag, ep->getContLen()))) &&
 3037:                             ((optflags & aeXPRODUCT) == 0 ||
 3648:                             TESTAFF(he->astr, eFlag, he->alen) ||
 3037:                              // handle conditional suffix
 3648:                             ((contclass) && TESTAFF(contclass, eFlag, contclasslen))
 3037:                             ) &&
 3037:                             // handle cont. class
 3037:                             ((!cclass) ||
 3037:                                 ((contclass) && TESTAFF(contclass, cclass, contclasslen))
 3037:                             ) &&
 3037:                             // handle required flag
 3037:                             ((!needflag) ||
 3037:                               (TESTAFF(he->astr, needflag, he->alen) ||
 3037:                               ((contclass) && TESTAFF(contclass, needflag, contclasslen)))
 3037:                             )
 3037:                         ) return he;
 3037:     }
 3037:     return NULL;
 3037: }
 3037: 
 3037: 
 3037: #if 0
 3037: 
 3037: Appendix:  Understanding Affix Code
 3037: 
 3037: 
 3037: An affix is either a  prefix or a suffix attached to root words to make 
 3037: other words.
 3037: 
 3037: Basically a Prefix or a Suffix is set of AffEntry objects
 3037: which store information about the prefix or suffix along 
 3037: with supporting routines to check if a word has a particular 
 3037: prefix or suffix or a combination.
 3037: 
 3037: The structure affentry is defined as follows:
 3037: 
 3037: struct affentry
 3037: {
 3037:    unsigned short aflag;    // ID used to represent the affix
 3037:    char * strip;            // string to strip before adding affix
 3037:    char * appnd;            // the affix string to add
 3037:    unsigned char stripl;    // length of the strip string
 3037:    unsigned char appndl;    // length of the affix string
 3037:    char numconds;           // the number of conditions that must be met
 3037:    char opts;               // flag: aeXPRODUCT- combine both prefix and suffix 
 3037:    char   conds[SETSIZE];   // array which encodes the conditions to be met
 3037: };
 3037: 
 3037: 
 3037: Here is a suffix borrowed from the en_US.aff file.  This file 
 3037: is whitespace delimited.
 3037: 
 3037: SFX D Y 4 
 3037: SFX D   0     e          d
 3037: SFX D   y     ied        [^aeiou]y
 3037: SFX D   0     ed         [^ey]
 3037: SFX D   0     ed         [aeiou]y
 3037: 
 3037: This information can be interpreted as follows:
 3037: 
 3037: In the first line has 4 fields
 3037: 
 3037: Field
 3037: -----
 3037: 1     SFX - indicates this is a suffix
 3037: 2     D   - is the name of the character flag which represents this suffix
 3037: 3     Y   - indicates it can be combined with prefixes (cross product)
 3037: 4     4   - indicates that sequence of 4 affentry structures are needed to
 3037:                properly store the affix information
 3037: 
 3037: The remaining lines describe the unique information for the 4 SfxEntry 
 3037: objects that make up this affix.  Each line can be interpreted
 3037: as follows: (note fields 1 and 2 are as a check against line 1 info)
 3037: 
 3037: Field
 3037: -----
 3037: 1     SFX         - indicates this is a suffix
 3037: 2     D           - is the name of the character flag for this affix
 3037: 3     y           - the string of chars to strip off before adding affix
 3037:                          (a 0 here indicates the NULL string)
 3037: 4     ied         - the string of affix characters to add
 3037: 5     [^aeiou]y   - the conditions which must be met before the affix
 3037:                     can be applied
 3037: 
 3037: Field 5 is interesting.  Since this is a suffix, field 5 tells us that
 3037: there are 2 conditions that must be met.  The first condition is that 
 3037: the next to the last character in the word must *NOT* be any of the 
 3037: following "a", "e", "i", "o" or "u".  The second condition is that
 3037: the last character of the word must end in "y".
 3037: 
 3037: So how can we encode this information concisely and be able to 
 3037: test for both conditions in a fast manner?  The answer is found
 3037: but studying the wonderful ispell code of Geoff Kuenning, et.al. 
 3037: (now available under a normal BSD license).
 3037: 
 3037: If we set up a conds array of 256 bytes indexed (0 to 255) and access it
 3037: using a character (cast to an unsigned char) of a string, we have 8 bits
 3037: of information we can store about that character.  Specifically we
 3037: could use each bit to say if that character is allowed in any of the 
 3037: last (or first for prefixes) 8 characters of the word.
 3037: 
 3037: Basically, each character at one end of the word (up to the number 
 3037: of conditions) is used to index into the conds array and the resulting 
 3037: value found there says whether the that character is valid for a 
 3037: specific character position in the word.  
 3037: 
 3037: For prefixes, it does this by setting bit 0 if that char is valid 
 3037: in the first position, bit 1 if valid in the second position, and so on. 
 3037: 
 3037: If a bit is not set, then that char is not valid for that postion in the
 3037: word.
 3037: 
 3037: If working with suffixes bit 0 is used for the character closest 
 3037: to the front, bit 1 for the next character towards the end, ..., 
 3037: with bit numconds-1 representing the last char at the end of the string. 
 3037: 
 3037: Note: since entries in the conds[] are 8 bits, only 8 conditions 
 3037: (read that only 8 character positions) can be examined at one
 3037: end of a word (the beginning for prefixes and the end for suffixes.
 3037: 
 3037: So to make this clearer, lets encode the conds array values for the 
 3037: first two affentries for the suffix D described earlier.
 3037: 
 3037: 
 3037:   For the first affentry:    
 3037:      numconds = 1             (only examine the last character)
 3037: 
 3037:      conds['e'] =  (1 << 0)   (the word must end in an E)
 3037:      all others are all 0
 3037: 
 3037:   For the second affentry:
 3037:      numconds = 2             (only examine the last two characters)     
 3037: 
 3037:      conds[X] = conds[X] | (1 << 0)     (aeiou are not allowed)
 3037:          where X is all characters *but* a, e, i, o, or u
 3037:          
 3037: 
 3037:      conds['y'] = (1 << 1)     (the last char must be a y)
 3037:      all other bits for all other entries in the conds array are zero
 3037: 
 3037: 
 3037: #endif
43385: 
