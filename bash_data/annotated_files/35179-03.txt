    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: 
    1: #include "nsIAppShellService.h"
    1: #include "nsISupportsArray.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIURL.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIObserver.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: 
    1: #include "nsIWindowMediator.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsPIWindowWatcher.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsWebShellWindow.h"
    1: 
    1: #include "nsIEnumerator.h"
    1: #include "nsCRT.h"
    1: #include "nsITimelineService.h"
    1: #include "prprf.h"    
    1: 
    1: #include "nsWidgetsCID.h"
    1: #include "nsIRequestObserver.h"
    1: 
    1: /* For implementing GetHiddenWindowAndJSContext */
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptContext.h"
    1: #include "jsapi.h"
    1: 
    1: #include "nsAppShellService.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsIPlatformCharset.h"
    1: #include "nsICharsetConverterManager.h"
    1: #include "nsIUnicodeDecoder.h"
    1: 
  679: // Default URL for the hidden window, can be overridden by a pref on Mac
33777: #define DEFAULT_HIDDENWINDOW_URL "resource://gre-resources/hiddenWindow.html"
  679: 
    1: class nsIAppShell;
    1: 
    1: nsAppShellService::nsAppShellService() : 
35179:   mXPCOMWillShutDown(PR_FALSE),
    1:   mXPCOMShuttingDown(PR_FALSE),
 5221:   mModalWindowCount(0),
 5221:   mApplicationProvidedHiddenWindow(PR_FALSE)
    1: {
    1:   nsCOMPtr<nsIObserverService> obs
    1:     (do_GetService("@mozilla.org/observer-service;1"));
    1: 
35179:   if (obs) {
35179:     obs->AddObserver(this, "xpcom-will-shutdown", PR_FALSE);
    1:     obs->AddObserver(this, "xpcom-shutdown", PR_FALSE);
    1:   }
35179: }
    1: 
    1: nsAppShellService::~nsAppShellService()
    1: {
    1: }
    1: 
    1: 
    1: /*
    1:  * Implement the nsISupports methods...
    1:  */
    1: NS_IMPL_ISUPPORTS2(nsAppShellService,
    1:                    nsIAppShellService,
    1:                    nsIObserver)
    1: 
    1: nsresult 
    1: nsAppShellService::SetXPConnectSafeContext()
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIThreadJSContextStack> cxstack =
    1:     do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMWindowInternal> junk;
    1:   JSContext *cx;
    1:   rv = GetHiddenWindowAndJSContext(getter_AddRefs(junk), &cx);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return cxstack->SetSafeJSContext(cx);
    1: }  
    1: 
    1: nsresult nsAppShellService::ClearXPConnectSafeContext()
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIThreadJSContextStack> cxstack =
    1:     do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
    1:   if (NS_FAILED(rv)) {
    1:     NS_ERROR("XPConnect ContextStack gone before XPCOM shutdown?");
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMWindowInternal> junk;
    1:   JSContext *cx;
    1:   rv = GetHiddenWindowAndJSContext(getter_AddRefs(junk), &cx);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   JSContext *safe_cx;
    1:   rv = cxstack->GetSafeJSContext(&safe_cx);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (cx == safe_cx)
    1:     rv = cxstack->SetSafeJSContext(nsnull);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAppShellService::CreateHiddenWindow(nsIAppShell* aAppShell)
    1: {
    1:   nsresult rv;
    1:   PRInt32 initialHeight = 100, initialWidth = 100;
    1:     
    1: #ifdef XP_MACOSX
    1:   PRUint32    chromeMask = 0;
    1:   nsCOMPtr<nsIPrefBranch> prefBranch;
    1:   nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:   prefs->GetBranch(nsnull, getter_AddRefs(prefBranch));
    1:   nsXPIDLCString prefVal;
    1:   rv = prefBranch->GetCharPref("browser.hiddenWindowChromeURL", getter_Copies(prefVal));
  679:   const char* hiddenWindowURL = prefVal.get() ? prefVal.get() : DEFAULT_HIDDENWINDOW_URL;
 5221:   mApplicationProvidedHiddenWindow = prefVal.get() ? PR_TRUE : PR_FALSE;
    1: #else
  679:   static const char hiddenWindowURL[] = DEFAULT_HIDDENWINDOW_URL;
    1:   PRUint32    chromeMask =  nsIWebBrowserChrome::CHROME_ALL;
    1: #endif
    1: 
    1:   nsCOMPtr<nsIURI> url;
    1:   rv = NS_NewURI(getter_AddRefs(url), hiddenWindowURL);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsRefPtr<nsWebShellWindow> newWindow;
    1:   rv = JustCreateTopWindow(nsnull, url,
    1:                            chromeMask, initialWidth, initialHeight,
    1:                            PR_TRUE, aAppShell, getter_AddRefs(newWindow));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mHiddenWindow.swap(newWindow);
    1: 
    1: #ifdef XP_MACOSX
    1:   // hide the hidden window by launching it into outer space. This
    1:   // way, we can keep it visible and let the OS send it activates
    1:   // to keep menus happy. This will cause it to show up in window
    1:   // lists under osx, but I think that's ok.
    1:   mHiddenWindow->SetPosition ( -32000, -32000 );
    1:   mHiddenWindow->SetVisibility ( PR_TRUE );
    1: #endif
    1: 
    1:   // Set XPConnect's fallback JSContext (used for JS Components)
    1:   // to the DOM JSContext for this thread, so that DOM-to-XPConnect
    1:   // conversions get the JSContext private magic they need to
    1:   // succeed.
    1:   SetXPConnectSafeContext();
    1: 
    1:   // RegisterTopLevelWindow(newWindow); -- Mac only
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAppShellService::DestroyHiddenWindow()
    1: {
    1:   if (mHiddenWindow) {
    1:     ClearXPConnectSafeContext();
    1:     mHiddenWindow->Destroy();
    1: 
    1:     mHiddenWindow = nsnull;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Create a new top level window and display the given URL within it...
    1:  */
    1: NS_IMETHODIMP
    1: nsAppShellService::CreateTopLevelWindow(nsIXULWindow *aParent,
    1:                                         nsIURI *aUrl, 
    1:                                         PRUint32 aChromeMask,
    1:                                         PRInt32 aInitialWidth,
    1:                                         PRInt32 aInitialHeight,
    1:                                         nsIAppShell* aAppShell,
    1:                                         nsIXULWindow **aResult)
    1: 
    1: {
    1:   nsresult rv;
    1: 
    1:   nsWebShellWindow *newWindow = nsnull;
    1:   rv = JustCreateTopWindow(aParent, aUrl,
    1:                            aChromeMask, aInitialWidth, aInitialHeight,
    1:                            PR_FALSE, aAppShell, &newWindow);  // addrefs
    1: 
    1:   *aResult = newWindow; // transfer ref
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // the addref resulting from this is the owning addref for this window
    1:     RegisterTopLevelWindow(*aResult);
33261:     nsCOMPtr<nsIXULWindow> parent;
33261:     if (aChromeMask & nsIWebBrowserChrome::CHROME_DEPENDENT)
33261:       parent = aParent;
33261:     (*aResult)->SetZLevel(CalculateWindowZLevel(parent, aChromeMask));
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: PRUint32
    1: nsAppShellService::CalculateWindowZLevel(nsIXULWindow *aParent,
    1:                                          PRUint32      aChromeMask)
    1: {
    1:   PRUint32 zLevel;
    1: 
    1:   zLevel = nsIXULWindow::normalZ;
    1:   if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_RAISED)
    1:     zLevel = nsIXULWindow::raisedZ;
    1:   else if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_LOWERED)
    1:     zLevel = nsIXULWindow::loweredZ;
    1: 
    1: #ifdef XP_MACOSX
    1:   /* Platforms on which modal windows are always application-modal, not
    1:      window-modal (that's just the Mac, right?) want modal windows to
    1:      be stacked on top of everyone else.
    1: 
    1:      On Mac OS X, bind modality to parent window instead of app (ala Mac OS 9)
    1:   */
    1:   PRUint32 modalDepMask = nsIWebBrowserChrome::CHROME_MODAL |
    1:                           nsIWebBrowserChrome::CHROME_DEPENDENT;
    1:   if (aParent && (aChromeMask & modalDepMask)) {
    1:     aParent->GetZLevel(&zLevel);
    1:   }
    1: #else
    1:   /* Platforms with native support for dependent windows (that's everyone
    1:       but pre-Mac OS X, right?) know how to stack dependent windows. On these
    1:       platforms, give the dependent window the same level as its parent,
    1:       so we won't try to override the normal platform behaviour. */
    1:   if ((aChromeMask & nsIWebBrowserChrome::CHROME_DEPENDENT) && aParent)
    1:     aParent->GetZLevel(&zLevel);
    1: #endif
    1: 
    1:   return zLevel;
    1: }
    1: 
    1: /*
    1:  * Just do the window-making part of CreateTopLevelWindow
    1:  */
    1: nsresult
    1: nsAppShellService::JustCreateTopWindow(nsIXULWindow *aParent,
    1:                                        nsIURI *aUrl, 
    1:                                        PRUint32 aChromeMask,
    1:                                        PRInt32 aInitialWidth,
    1:                                        PRInt32 aInitialHeight,
    1:                                        PRBool aIsHiddenWindow,
    1:                                        nsIAppShell* aAppShell,
    1:                                        nsWebShellWindow **aResult)
    1: {
    1:   *aResult = nsnull;
35179:   NS_ENSURE_STATE(!mXPCOMWillShutDown);
    1: 
33261:   nsCOMPtr<nsIXULWindow> parent;
33261:   if (aChromeMask & nsIWebBrowserChrome::CHROME_DEPENDENT)
33261:     parent = aParent;
33261: 
31556:   nsRefPtr<nsWebShellWindow> window = new nsWebShellWindow(aChromeMask);
    1:   NS_ENSURE_TRUE(window, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsWidgetInitData widgetInitData;
    1: 
    1:   if (aIsHiddenWindow)
    1:     widgetInitData.mWindowType = eWindowType_invisible;
    1:   else
    1:     widgetInitData.mWindowType = aChromeMask & nsIWebBrowserChrome::CHROME_OPENAS_DIALOG ?
    1:       eWindowType_dialog : eWindowType_toplevel;
    1: 
    1:   if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_POPUP)
    1:     widgetInitData.mWindowType = eWindowType_popup;
    1: 
    1: #ifdef XP_MACOSX
    1:   // Mac OS X sheet support
13491:   // Adding CHROME_OPENAS_CHROME to sheetMask makes modal windows opened from
13491:   // nsGlobalWindow::ShowModalDialog() be dialogs (not sheets), while modal
13491:   // windows opened from nsPromptService::DoDialog() still are sheets.  This
13491:   // fixes bmo bug 395465 (see nsCocoaWindow::StandardCreate() and
13491:   // nsCocoaWindow::SetModal()).
    1:   PRUint32 sheetMask = nsIWebBrowserChrome::CHROME_OPENAS_DIALOG |
13491:                        nsIWebBrowserChrome::CHROME_MODAL |
13491:                        nsIWebBrowserChrome::CHROME_OPENAS_CHROME;
33261:   if (parent && ((aChromeMask & sheetMask) == sheetMask))
    1:     widgetInitData.mWindowType = eWindowType_sheet;
    1: #endif
    1: 
    1:   widgetInitData.mContentType = eContentTypeUI;                
    1: 
    1:   // note default chrome overrides other OS chrome settings, but
    1:   // not internal chrome
    1:   if (aChromeMask & nsIWebBrowserChrome::CHROME_DEFAULT)
    1:     widgetInitData.mBorderStyle = eBorderStyle_default;
    1:   else if ((aChromeMask & nsIWebBrowserChrome::CHROME_ALL) == nsIWebBrowserChrome::CHROME_ALL)
    1:     widgetInitData.mBorderStyle = eBorderStyle_all;
    1:   else {
    1:     widgetInitData.mBorderStyle = eBorderStyle_none; // assumes none == 0x00
    1:     if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_BORDERS)
 3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_border);
    1:     if (aChromeMask & nsIWebBrowserChrome::CHROME_TITLEBAR)
 3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_title);
    1:     if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_CLOSE)
 3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_close);
    1:     if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_RESIZE) {
 3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_resizeh);
    1:       // only resizable windows get the maximize button (but not dialogs)
    1:       if (!(aChromeMask & nsIWebBrowserChrome::CHROME_OPENAS_DIALOG))
 3233:         widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_maximize);
    1:     }
    1:     // all windows (except dialogs) get minimize buttons and the system menu
    1:     if (!(aChromeMask & nsIWebBrowserChrome::CHROME_OPENAS_DIALOG))
 3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_minimize | eBorderStyle_menu);
    1:     // but anyone can explicitly ask for a minimize button
    1:     if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_MIN) {
 3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_minimize);
    1:     }  
    1:   }
    1: 
    1:   if (aInitialWidth == nsIAppShellService::SIZE_TO_CONTENT ||
    1:       aInitialHeight == nsIAppShellService::SIZE_TO_CONTENT) {
    1:     aInitialWidth = 1;
    1:     aInitialHeight = 1;
    1:     window->SetIntrinsicallySized(PR_TRUE);
    1:   }
    1: 
33261:   PRBool center = aChromeMask & nsIWebBrowserChrome::CHROME_CENTER_SCREEN;
33261: 
33261:   nsresult rv = window->Initialize(parent, center ? aParent : nsnull,
33261:                                    aAppShell, aUrl,
    1:                                    aInitialWidth, aInitialHeight,
    1:                                    aIsHiddenWindow, widgetInitData);
    1:       
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   window.swap(*aResult); // transfer reference
33261:   if (parent)
33261:     parent->AddChildWindow(*aResult);
    1: 
33261:   if (center)
33261:     rv = (*aResult)->Center(parent, parent ? PR_FALSE : PR_TRUE, PR_FALSE);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAppShellService::GetHiddenWindow(nsIXULWindow **aWindow)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aWindow);
    1: 
    1:   *aWindow = mHiddenWindow;
    1:   NS_IF_ADDREF(*aWindow);
    1:   return *aWindow ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAppShellService::GetHiddenDOMWindow(nsIDOMWindowInternal **aWindow)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIDocShell> docShell;
    1:   NS_ENSURE_TRUE(mHiddenWindow, NS_ERROR_FAILURE);
    1: 
    1:   rv = mHiddenWindow->GetDocShell(getter_AddRefs(docShell));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   nsCOMPtr<nsIDOMWindowInternal> hiddenDOMWindow(do_GetInterface(docShell, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *aWindow = hiddenDOMWindow;
    1:   NS_IF_ADDREF(*aWindow);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAppShellService::GetHiddenWindowAndJSContext(nsIDOMWindowInternal **aWindow,
    1:                                                JSContext    **aJSContext)
    1: {
    1:     nsresult rv = NS_OK;
    1:     if ( aWindow && aJSContext ) {
    1:         *aWindow    = nsnull;
    1:         *aJSContext = nsnull;
    1: 
    1:         if ( mHiddenWindow ) {
    1:             // Convert hidden window to nsIDOMWindowInternal and extract its JSContext.
    1:             do {
    1:                 // 1. Get doc for hidden window.
    1:                 nsCOMPtr<nsIDocShell> docShell;
    1:                 rv = mHiddenWindow->GetDocShell(getter_AddRefs(docShell));
    1:                 if (NS_FAILED(rv)) break;
    1: 
    1:                 // 2. Convert that to an nsIDOMWindowInternal.
    1:                 nsCOMPtr<nsIDOMWindowInternal> hiddenDOMWindow(do_GetInterface(docShell));
    1:                 if(!hiddenDOMWindow) break;
    1: 
    1:                 // 3. Get script global object for the window.
    1:                 nsCOMPtr<nsIScriptGlobalObject> sgo;
    1:                 sgo = do_QueryInterface( hiddenDOMWindow );
    1:                 if (!sgo) { rv = NS_ERROR_FAILURE; break; }
    1: 
    1:                 // 4. Get script context from that.
    1:                 nsIScriptContext *scriptContext = sgo->GetContext();
    1:                 if (!scriptContext) { rv = NS_ERROR_FAILURE; break; }
    1: 
    1:                 // 5. Get JSContext from the script context.
    1:                 JSContext *jsContext = (JSContext*)scriptContext->GetNativeContext();
    1:                 if (!jsContext) { rv = NS_ERROR_FAILURE; break; }
    1: 
    1:                 // Now, give results to caller.
    1:                 *aWindow    = hiddenDOMWindow.get();
    1:                 NS_IF_ADDREF( *aWindow );
    1:                 *aJSContext = jsContext;
    1:             } while (0);
    1:         } else {
    1:             rv = NS_ERROR_FAILURE;
    1:         }
    1:     } else {
    1:         rv = NS_ERROR_NULL_POINTER;
    1:     }
    1:     return rv;
    1: }
    1: 
 5221: NS_IMETHODIMP
 5221: nsAppShellService::GetApplicationProvidedHiddenWindow(PRBool* aAPHW)
 5221: {
 5221:     *aAPHW = mApplicationProvidedHiddenWindow;
 5221:     return NS_OK;
 5221: }
 5221: 
    1: /*
    1:  * Register a new top level window (created elsewhere)
    1:  */
    1: NS_IMETHODIMP
    1: nsAppShellService::RegisterTopLevelWindow(nsIXULWindow* aWindow)
    1: {
    1:   // tell the window mediator about the new window
    1:   nsCOMPtr<nsIWindowMediator> mediator
    1:     ( do_GetService(NS_WINDOWMEDIATOR_CONTRACTID) );
    1:   NS_ASSERTION(mediator, "Couldn't get window mediator.");
    1: 
    1:   if (mediator)
    1:     mediator->RegisterWindow(aWindow);
    1: 
    1:   // tell the window watcher about the new window
    1:   nsCOMPtr<nsPIWindowWatcher> wwatcher ( do_GetService(NS_WINDOWWATCHER_CONTRACTID) );
    1:   NS_ASSERTION(wwatcher, "No windowwatcher?");
    1:   if (wwatcher) {
    1:     nsCOMPtr<nsIDocShell> docShell;
    1:     aWindow->GetDocShell(getter_AddRefs(docShell));
    1:     NS_ASSERTION(docShell, "Window has no docshell");
    1:     if (docShell) {
    1:       nsCOMPtr<nsIDOMWindow> domWindow(do_GetInterface(docShell));
    1:       NS_ASSERTION(domWindow, "Couldn't get DOM window.");
    1:       if (domWindow)
    1:         wwatcher->AddWindow(domWindow, 0);
    1:     }
    1:   }
    1: 
    1:   // an ongoing attempt to quit is stopped by a newly opened window
    1:   nsCOMPtr<nsIObserverService> obssvc =
    1:     do_GetService("@mozilla.org/observer-service;1");
    1:   NS_ASSERTION(obssvc, "Couldn't get observer service.");
    1: 
    1:   if (obssvc)
    1:     obssvc->NotifyObservers(aWindow, "xul-window-registered", nsnull);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsAppShellService::UnregisterTopLevelWindow(nsIXULWindow* aWindow)
    1: {
    1:   if (mXPCOMShuttingDown) {
    1:     /* return an error code in order to:
    1:        - avoid doing anything with other member variables while we are in
    1:          the destructor
    1:        - notify the caller not to release the AppShellService after
    1:          unregistering the window
    1:          (we don't want to be deleted twice consecutively to
    1:          mHiddenWindow->Destroy() in our destructor)
    1:     */
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   
    1:   NS_ENSURE_ARG_POINTER(aWindow);
    1: 
    1:   if (aWindow == mHiddenWindow) {
    1:     // CreateHiddenWindow() does not register the window, so we're done.
    1:     return NS_OK;
    1:   }
    1: 
    1:   // tell the window mediator
    1:   nsCOMPtr<nsIWindowMediator> mediator
    1:     ( do_GetService(NS_WINDOWMEDIATOR_CONTRACTID) );
    1:   NS_ASSERTION(mediator, "Couldn't get window mediator. Doing xpcom shutdown?");
    1: 
    1:   if (mediator)
    1:     mediator->UnregisterWindow(aWindow);
    1: 	
    1:   // tell the window watcher
    1:   nsCOMPtr<nsPIWindowWatcher> wwatcher ( do_GetService(NS_WINDOWWATCHER_CONTRACTID) );
    1:   NS_ASSERTION(wwatcher, "Couldn't get windowwatcher, doing xpcom shutdown?");
    1:   if (wwatcher) {
    1:     nsCOMPtr<nsIDocShell> docShell;
    1:     aWindow->GetDocShell(getter_AddRefs(docShell));
    1:     if (docShell) {
    1:       nsCOMPtr<nsIDOMWindow> domWindow(do_GetInterface(docShell));
    1:       if (domWindow)
    1:         wwatcher->RemoveWindow(domWindow);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsAppShellService::Observe(nsISupports* aSubject, const char *aTopic,
    1:                            const PRUnichar *aData)
    1: {
35179:   if (!strcmp(aTopic, "xpcom-will-shutdown")) {
35179:     mXPCOMWillShutDown = PR_TRUE;
35179:   } else if (!strcmp(aTopic, "xpcom-shutdown")) {
    1:     mXPCOMShuttingDown = PR_TRUE;
    1:     if (mHiddenWindow) {
    1:       ClearXPConnectSafeContext();
    1:       mHiddenWindow->Destroy();
    1:     }
35179:   } else {
35179:     NS_ERROR("Unexpected observer topic!");
35179:   }
    1: 
    1:   return NS_OK;
    1: }
