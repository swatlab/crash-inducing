74337: /* -*- Mode: c++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 40 -*- */
76372: /* vim: set ts=2 et sw=2 tw=80: */
74337: /* ***** BEGIN LICENSE BLOCK *****
74337:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
74337:  *
74337:  * The contents of this file are subject to the Mozilla Public License Version
74337:  * 1.1 (the "License"); you may not use this file except in compliance with
74337:  * the License. You may obtain a copy of the License at
74337:  * http://www.mozilla.org/MPL/
74337:  *
74337:  * Software distributed under the License is distributed on an "AS IS" basis,
74337:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
74337:  * for the specific language governing rights and limitations under the
74337:  * License.
74337:  *
74337:  * The Original Code is Web Workers.
74337:  *
74337:  * The Initial Developer of the Original Code is
74337:  *   The Mozilla Foundation.
74337:  * Portions created by the Initial Developer are Copyright (C) 2011
74337:  * the Initial Developer. All Rights Reserved.
74337:  *
74337:  * Contributor(s):
74337:  *   Ben Turner <bent.mozilla@gmail.com> (Original Author)
74337:  *
74337:  * Alternatively, the contents of this file may be used under the terms of
74337:  * either the GNU General Public License Version 2 or later (the "GPL"), or
74337:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
74337:  * in which case the provisions of the GPL or the LGPL are applicable instead
74337:  * of those above. If you wish to allow use of your version of this file only
74337:  * under the terms of either the GPL or the LGPL, and not to allow others to
74337:  * use your version of this file under the terms of the MPL, indicate your
74337:  * decision by deleting the provisions above and replace them with the notice
74337:  * and other provisions required by the GPL or the LGPL. If you do not delete
74337:  * the provisions above, a recipient may use your version of this file under
74337:  * the terms of any one of the MPL, the GPL or the LGPL.
74337:  *
74337:  * ***** END LICENSE BLOCK ***** */
74337: 
74337: #include "WorkerPrivate.h"
74337: 
80360: #include "mozIThirdPartyUtil.h"
74337: #include "nsIClassInfo.h"
74337: #include "nsIConsoleService.h"
76372: #include "nsIDOMFile.h"
74337: #include "nsIDocument.h"
74337: #include "nsIJSContextStack.h"
78275: #include "nsIMemoryReporter.h"
74337: #include "nsIScriptError.h"
74337: #include "nsIScriptGlobalObject.h"
74337: #include "nsIScriptSecurityManager.h"
74337: #include "nsPIDOMWindow.h"
74337: #include "nsITextToSubURI.h"
74337: #include "nsITimer.h"
74337: #include "nsIURI.h"
74337: #include "nsIURL.h"
74337: #include "nsIXPConnect.h"
74337: 
87275: #include "jsfriendapi.h"
74337: #include "jsdbgapi.h"
87588: #include "jsfriendapi.h"
78275: #include "jsprf.h"
86987: #include "js/MemoryMetrics.h"
86987: 
74337: #include "nsAlgorithm.h"
74337: #include "nsContentUtils.h"
74337: #include "nsDOMClassInfo.h"
74337: #include "nsDOMJSUtils.h"
74337: #include "nsGUIEvent.h"
74337: #include "nsJSEnvironment.h"
74337: #include "nsJSUtils.h"
74337: #include "nsNetUtil.h"
74337: #include "nsThreadUtils.h"
75066: #include "xpcpublic.h"
74337: 
74337: #include "Events.h"
74337: #include "Exceptions.h"
76372: #include "File.h"
74337: #include "Principal.h"
74337: #include "RuntimeService.h"
74337: #include "ScriptLoader.h"
80028: #include "Worker.h"
74337: #include "WorkerFeature.h"
74337: #include "WorkerScope.h"
86209: #ifdef ANDROID
86209: #include <android/log.h>
86209: #endif
74337: 
74337: #include "WorkerInlines.h"
74337: 
74337: #if 0 // Define to run GC more often.
74337: #define EXTRA_GC
74337: #endif
74337: 
87588: // GC will run once every thirty seconds during normal execution.
87588: #define NORMAL_GC_TIMER_DELAY_MS 30000
87588: 
87588: // GC will run five seconds after the last event is processed.
87588: #define IDLE_GC_TIMER_DELAY_MS 5000
87588: 
74337: using mozilla::MutexAutoLock;
74337: using mozilla::TimeDuration;
74337: using mozilla::TimeStamp;
74337: using mozilla::dom::workers::exceptions::ThrowDOMExceptionForCode;
86987: using mozilla::xpconnect::memory::ReportJSRuntimeStats;
74337: 
74337: USING_WORKERS_NAMESPACE
74337: 
74337: namespace {
74337: 
74337: const char gErrorChars[] = "error";
74337: const char gMessageChars[] = "message";
74337: 
74337: template <class T>
74337: class AutoPtrComparator
74337: {
74337:   typedef nsAutoPtr<T> A;
74337:   typedef T* B;
74337: 
74337: public:
79445:   bool Equals(const A& a, const B& b) const {
74337:     return a && b ? *a == *b : !a && !b ? true : false;
74337:   }
79445:   bool LessThan(const A& a, const B& b) const {
74337:     return a && b ? *a < *b : b ? true : false;
74337:   }
74337: };
74337: 
74337: template <class T>
74337: inline AutoPtrComparator<T>
74337: GetAutoPtrComparator(const nsTArray<nsAutoPtr<T> >&)
74337: {
74337:   return AutoPtrComparator<T>();
74337: }
74337: 
74337: // Specialize this if there's some class that has multiple nsISupports bases.
74337: template <class T>
74337: struct ISupportsBaseInfo
74337: {
74337:   typedef T ISupportsBase;
74337: };
74337: 
74337: template <template <class> class SmartPtr, class T>
74337: inline void
74337: SwapToISupportsArray(SmartPtr<T>& aSrc,
74337:                      nsTArray<nsCOMPtr<nsISupports> >& aDest)
74337: {
74337:   nsCOMPtr<nsISupports>* dest = aDest.AppendElement();
74337: 
74337:   T* raw = nsnull;
74337:   aSrc.swap(raw);
74337: 
74337:   nsISupports* rawSupports =
74337:     static_cast<typename ISupportsBaseInfo<T>::ISupportsBase*>(raw);
74337:   dest->swap(rawSupports);
74337: }
74337: 
78275: class WorkerMemoryReporter : public nsIMemoryMultiReporter
78275: {
78275:   WorkerPrivate* mWorkerPrivate;
78275:   nsCString mAddressString;
78275:   nsCString mPathPrefix;
78275: 
78275: public:
78275:   NS_DECL_ISUPPORTS
78275: 
78275:   WorkerMemoryReporter(WorkerPrivate* aWorkerPrivate)
78275:   : mWorkerPrivate(aWorkerPrivate)
78275:   {
78275:     aWorkerPrivate->AssertIsOnWorkerThread();
78275: 
78275:     nsCString escapedDomain(aWorkerPrivate->Domain());
78275:     escapedDomain.ReplaceChar('/', '\\');
78275: 
78275:     NS_ConvertUTF16toUTF8 escapedURL(aWorkerPrivate->ScriptURL());
78275:     escapedURL.ReplaceChar('/', '\\');
78275: 
78275:     {
78275:       // 64bit address plus '0x' plus null terminator.
78275:       char address[21];
84755:       uint32_t addressSize =
78275:         JS_snprintf(address, sizeof(address), "0x%llx", aWorkerPrivate);
84755:       if (addressSize != uint32_t(-1)) {
78275:         mAddressString.Assign(address, addressSize);
78275:       }
78275:       else {
78275:         NS_WARNING("JS_snprintf failed!");
78275:         mAddressString.AssignLiteral("<unknown address>");
78275:       }
78275:     }
78275: 
78275:     mPathPrefix = NS_LITERAL_CSTRING("explicit/dom/workers(") +
78275:                   escapedDomain + NS_LITERAL_CSTRING(")/worker(") +
78275:                   escapedURL + NS_LITERAL_CSTRING(", ") + mAddressString +
78275:                   NS_LITERAL_CSTRING(")/");
78275:   }
78275: 
86388:   nsresult
86388:   CollectForRuntime(bool aIsQuick, void* aData)
78275:   {
78275:     AssertIsOnMainThread();
78275: 
78275:     if (mWorkerPrivate) {
78275:       bool disabled;
86388:       if (!mWorkerPrivate->BlockAndCollectRuntimeStats(aIsQuick, aData, &disabled)) {
78275:         return NS_ERROR_FAILURE;
78275:       }
78275: 
78275:       // Don't ever try to talk to the worker again.
78275:       if (disabled) {
78275: #ifdef DEBUG
78275:         {
78275:           nsCAutoString message("Unable to report memory for ");
78275:           if (mWorkerPrivate->IsChromeWorker()) {
78275:             message.AppendLiteral("Chrome");
78275:           }
78275:           message += NS_LITERAL_CSTRING("Worker (") + mAddressString +
78275:                      NS_LITERAL_CSTRING(")! It is either using ctypes or is in "
78275:                                         "the process of being destroyed");
78275:           NS_WARNING(message.get());
78275:         }
78275: #endif
78275:         mWorkerPrivate = nsnull;
78275:       }
78275:     }
86388:     return NS_OK;
86388:   }
86388: 
86388:   NS_IMETHOD
86388:   CollectReports(nsIMemoryMultiReporterCallback* aCallback,
86388:                  nsISupports* aClosure)
86388:   {
86388:     AssertIsOnMainThread();
86388: 
88580:     JS::RuntimeStats rtStats(xpc::JsMallocSizeOf, xpc::GetCompartmentName,
86987:                              xpc::DestroyCompartmentName);
88580:     nsresult rv = CollectForRuntime(/* isQuick = */false, &rtStats);
86388:     if (NS_FAILED(rv)) {
86388:       return rv;
86388:     }
78275: 
78275:     // Always report, even if we're disabled, so that we at least get an entry
78275:     // in about::memory.
88580:     ReportJSRuntimeStats(rtStats, mPathPrefix, aCallback, aClosure);
86388: 
78275:     return NS_OK;
78275:   }
86388: 
86388:   NS_IMETHOD
86388:   GetExplicitNonHeap(PRInt64 *aAmount)
86388:   {
86388:     AssertIsOnMainThread();
86388: 
86388:     return CollectForRuntime(/* isQuick = */true, aAmount);
86388:   }
78275: };
78275: 
78275: NS_IMPL_THREADSAFE_ISUPPORTS1(WorkerMemoryReporter, nsIMemoryMultiReporter)
78275: 
74337: struct WorkerStructuredCloneCallbacks
74337: {
74337:   static JSObject*
84755:   Read(JSContext* aCx, JSStructuredCloneReader* aReader, uint32_t aTag,
84755:        uint32_t aData, void* aClosure)
74337:   {
76372:     // See if object is a nsIDOMFile pointer.
76372:     if (aTag == DOMWORKER_SCTAG_FILE) {
76372:       JS_ASSERT(!aData);
76372: 
76372:       nsIDOMFile* file;
76372:       if (JS_ReadBytes(aReader, &file, sizeof(file))) {
76372:         JS_ASSERT(file);
76372: 
76372: #ifdef DEBUG
76372:         {
76372:           // File should not be mutable.
76372:           nsCOMPtr<nsIMutable> mutableFile = do_QueryInterface(file);
79445:           bool isMutable;
76372:           NS_ASSERTION(NS_SUCCEEDED(mutableFile->GetMutable(&isMutable)) &&
76372:                        !isMutable,
76372:                        "Only immutable file should be passed to worker");
76372:         }
76372: #endif
76372: 
76372:         // nsIDOMFiles should be threadsafe, thus we will use the same instance
76372:         // in the worker.
76372:         JSObject* jsFile = file::CreateFile(aCx, file);
76372:         return jsFile;
76372:       }
76372:     }
76372:     // See if object is a nsIDOMBlob pointer.
76372:     else if (aTag == DOMWORKER_SCTAG_BLOB) {
76372:       JS_ASSERT(!aData);
76372: 
76372:       nsIDOMBlob* blob;
76372:       if (JS_ReadBytes(aReader, &blob, sizeof(blob))) {
76372:         JS_ASSERT(blob);
76372: 
76372: #ifdef DEBUG
76372:         {
76372:           // Blob should not be mutable.
76372:           nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(blob);
79445:           bool isMutable;
76372:           NS_ASSERTION(NS_SUCCEEDED(mutableBlob->GetMutable(&isMutable)) &&
76372:                        !isMutable,
76372:                        "Only immutable blob should be passed to worker");
76372:         }
76372: #endif
76372: 
76372:         // nsIDOMBlob should be threadsafe, thus we will use the same instance
76372:         // in the worker.
76372:         JSObject* jsBlob = file::CreateBlob(aCx, blob);
76372:         return jsBlob;
76372:       }
76372:     }
76372: 
74337:     Error(aCx, 0);
74337:     return nsnull;
74337:   }
74337: 
74337:   static JSBool
74337:   Write(JSContext* aCx, JSStructuredCloneWriter* aWriter, JSObject* aObj,
74337:         void* aClosure)
74337:   {
76372:     NS_ASSERTION(aClosure, "Null pointer!");
76372: 
76372:     // We'll stash any nsISupports pointers that need to be AddRef'd here.
76372:     nsTArray<nsCOMPtr<nsISupports> >* clonedObjects =
76372:       static_cast<nsTArray<nsCOMPtr<nsISupports> >*>(aClosure);
76372: 
76372:     // See if this is a File object.
76372:     {
76372:       nsIDOMFile* file = file::GetDOMFileFromJSObject(aCx, aObj);
76372:       if (file) {
76372:         if (JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_FILE, 0) &&
76372:             JS_WriteBytes(aWriter, &file, sizeof(file))) {
76372:           clonedObjects->AppendElement(file);
76372:           return true;
76372:         }
76372:       }
76372:     }
76372: 
76372:     // See if this is a Blob object.
76372:     {
76372:       nsIDOMBlob* blob = file::GetDOMBlobFromJSObject(aCx, aObj);
76372:       if (blob) {
76372:         nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(blob);
80486:         if (mutableBlob && NS_SUCCEEDED(mutableBlob->SetMutable(false)) &&
76372:             JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_BLOB, 0) &&
76372:             JS_WriteBytes(aWriter, &blob, sizeof(blob))) {
76372:           clonedObjects->AppendElement(blob);
76372:           return true;
76372:         }
76372:       }
76372:     }
76372: 
74337:     Error(aCx, 0);
74337:     return false;
74337:   }
74337: 
74337:   static void
84755:   Error(JSContext* aCx, uint32_t /* aErrorId */)
74337:   {
74337:     ThrowDOMExceptionForCode(aCx, DATA_CLONE_ERR);
74337:   }
74337: };
74337: 
74337: JSStructuredCloneCallbacks gWorkerStructuredCloneCallbacks = {
74337:   WorkerStructuredCloneCallbacks::Read,
74337:   WorkerStructuredCloneCallbacks::Write,
74337:   WorkerStructuredCloneCallbacks::Error
74337: };
74337: 
74337: struct MainThreadWorkerStructuredCloneCallbacks
74337: {
74337:   static JSObject*
84755:   Read(JSContext* aCx, JSStructuredCloneReader* aReader, uint32_t aTag,
84755:        uint32_t aData, void* aClosure)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
76372:     // See if object is a nsIDOMFile pointer.
76372:     if (aTag == DOMWORKER_SCTAG_FILE) {
76372:       JS_ASSERT(!aData);
76372: 
76372:       nsIDOMFile* file;
76372:       if (JS_ReadBytes(aReader, &file, sizeof(file))) {
76372:         JS_ASSERT(file);
76372: 
76372: #ifdef DEBUG
76372:         {
76372:           // File should not be mutable.
76372:           nsCOMPtr<nsIMutable> mutableFile = do_QueryInterface(file);
79445:           bool isMutable;
76372:           NS_ASSERTION(NS_SUCCEEDED(mutableFile->GetMutable(&isMutable)) &&
76372:                        !isMutable,
76372:                        "Only immutable file should be passed to worker");
76372:         }
76372: #endif
76372: 
76372:         // nsIDOMFiles should be threadsafe, thus we will use the same instance
76372:         // on the main thread.
76372:         jsval wrappedFile;
76372:         nsresult rv =
76372:           nsContentUtils::WrapNative(aCx, JS_GetGlobalForScopeChain(aCx), file,
76372:                                      &NS_GET_IID(nsIDOMFile), &wrappedFile);
76372:         if (NS_FAILED(rv)) {
76372:           Error(aCx, DATA_CLONE_ERR);
76372:           return nsnull;
76372:         }
76372: 
76372:         return JSVAL_TO_OBJECT(wrappedFile);
76372:       }
76372:     }
76372:     // See if object is a nsIDOMBlob pointer.
76372:     else if (aTag == DOMWORKER_SCTAG_BLOB) {
76372:       JS_ASSERT(!aData);
76372: 
76372:       nsIDOMBlob* blob;
76372:       if (JS_ReadBytes(aReader, &blob, sizeof(blob))) {
76372:         JS_ASSERT(blob);
76372: 
76372: #ifdef DEBUG
76372:         {
76372:           // Blob should not be mutable.
76372:           nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(blob);
79445:           bool isMutable;
76372:           NS_ASSERTION(NS_SUCCEEDED(mutableBlob->GetMutable(&isMutable)) &&
76372:                        !isMutable,
76372:                        "Only immutable blob should be passed to worker");
76372:         }
76372: #endif
76372: 
76372:         // nsIDOMBlobs should be threadsafe, thus we will use the same instance
76372:         // on the main thread.
76372:         jsval wrappedBlob;
76372:         nsresult rv =
76372:           nsContentUtils::WrapNative(aCx, JS_GetGlobalForScopeChain(aCx), blob,
76372:                                      &NS_GET_IID(nsIDOMBlob), &wrappedBlob);
76372:         if (NS_FAILED(rv)) {
76372:           Error(aCx, DATA_CLONE_ERR);
76372:           return nsnull;
76372:         }
76372: 
76372:         return JSVAL_TO_OBJECT(wrappedBlob);
76372:       }
76372:     }
76372: 
74337:     JSObject* clone =
74337:       WorkerStructuredCloneCallbacks::Read(aCx, aReader, aTag, aData, aClosure);
74337:     if (clone) {
74337:       return clone;
74337:     }
74337: 
74337:     JS_ClearPendingException(aCx);
74337:     return NS_DOMReadStructuredClone(aCx, aReader, aTag, aData, nsnull);
74337:   }
74337: 
74337:   static JSBool
74337:   Write(JSContext* aCx, JSStructuredCloneWriter* aWriter, JSObject* aObj,
74337:         void* aClosure)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
76372:     NS_ASSERTION(aClosure, "Null pointer!");
76372: 
76372:     // We'll stash any nsISupports pointers that need to be AddRef'd here.
76372:     nsTArray<nsCOMPtr<nsISupports> >* clonedObjects =
76372:       static_cast<nsTArray<nsCOMPtr<nsISupports> >*>(aClosure);
76372: 
76372:     // See if this is a wrapped native.
76372:     nsCOMPtr<nsIXPConnectWrappedNative> wrappedNative;
76372:     nsContentUtils::XPConnect()->
76372:       GetWrappedNativeOfJSObject(aCx, aObj, getter_AddRefs(wrappedNative));
76372: 
76372:     if (wrappedNative) {
76372:       // Get the raw nsISupports out of it.
76372:       nsISupports* wrappedObject = wrappedNative->Native();
76372:       NS_ASSERTION(wrappedObject, "Null pointer?!");
76372: 
76372:       // See if the wrapped native is a nsIDOMFile.
76372:       nsCOMPtr<nsIDOMFile> file = do_QueryInterface(wrappedObject);
76372:       if (file) {
76372:         nsCOMPtr<nsIMutable> mutableFile = do_QueryInterface(file);
80486:         if (mutableFile && NS_SUCCEEDED(mutableFile->SetMutable(false))) {
76372:           nsIDOMFile* filePtr = file;
76372:           if (JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_FILE, 0) &&
76372:               JS_WriteBytes(aWriter, &filePtr, sizeof(filePtr))) {
76372:             clonedObjects->AppendElement(file);
76372:             return true;
76372:           }
76372:         }
76372:       }
76372: 
76372:       // See if the wrapped native is a nsIDOMBlob.
76372:       nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(wrappedObject);
76372:       if (blob) {
76372:         nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(blob);
80486:         if (mutableBlob && NS_SUCCEEDED(mutableBlob->SetMutable(false))) {
76372:           nsIDOMBlob* blobPtr = blob;
76372:           if (JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_BLOB, 0) &&
76372:               JS_WriteBytes(aWriter, &blobPtr, sizeof(blobPtr))) {
76372:             clonedObjects->AppendElement(blob);
76372:             return true;
76372:           }
76372:         }
76372:       }
76372:     }
76372: 
74337:     JSBool ok =
74337:       WorkerStructuredCloneCallbacks::Write(aCx, aWriter, aObj, aClosure);
74337:     if (ok) {
74337:       return ok;
74337:     }
74337: 
74337:     JS_ClearPendingException(aCx);
74337:     return NS_DOMWriteStructuredClone(aCx, aWriter, aObj, nsnull);
74337:   }
74337: 
74337:   static void
84755:   Error(JSContext* aCx, uint32_t aErrorId)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
74337:     NS_DOMStructuredCloneError(aCx, aErrorId);
74337:   }
74337: };
74337: 
74337: JSStructuredCloneCallbacks gMainThreadWorkerStructuredCloneCallbacks = {
74337:   MainThreadWorkerStructuredCloneCallbacks::Read,
74337:   MainThreadWorkerStructuredCloneCallbacks::Write,
74337:   MainThreadWorkerStructuredCloneCallbacks::Error
74337: };
74337: 
74337: struct ChromeWorkerStructuredCloneCallbacks
74337: {
74337:   static JSObject*
84755:   Read(JSContext* aCx, JSStructuredCloneReader* aReader, uint32_t aTag,
84755:        uint32_t aData, void* aClosure)
74337:   {
74337:     return WorkerStructuredCloneCallbacks::Read(aCx, aReader, aTag, aData,
74337:                                                 aClosure);
74337:   }
74337: 
74337:   static JSBool
74337:   Write(JSContext* aCx, JSStructuredCloneWriter* aWriter, JSObject* aObj,
74337:         void* aClosure)
74337:   {
74337:     return WorkerStructuredCloneCallbacks::Write(aCx, aWriter, aObj, aClosure);
74337:   }
74337: 
74337:   static void
84755:   Error(JSContext* aCx, uint32_t aErrorId)
74337:   {
74337:     return WorkerStructuredCloneCallbacks::Error(aCx, aErrorId);
74337:   }
74337: };
74337: 
74337: JSStructuredCloneCallbacks gChromeWorkerStructuredCloneCallbacks = {
74337:   ChromeWorkerStructuredCloneCallbacks::Read,
74337:   ChromeWorkerStructuredCloneCallbacks::Write,
74337:   ChromeWorkerStructuredCloneCallbacks::Error
74337: };
74337: 
74337: struct MainThreadChromeWorkerStructuredCloneCallbacks
74337: {
74337:   static JSObject*
84755:   Read(JSContext* aCx, JSStructuredCloneReader* aReader, uint32_t aTag,
84755:        uint32_t aData, void* aClosure)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
74337:     JSObject* clone =
81573:       MainThreadWorkerStructuredCloneCallbacks::Read(aCx, aReader, aTag, aData,
81573:                                                      aClosure);
81573:     if (clone) {
81573:       return clone;
81573:     }
81573: 
81573:     clone =
74337:       ChromeWorkerStructuredCloneCallbacks::Read(aCx, aReader, aTag, aData,
74337:                                                  aClosure);
74337:     if (clone) {
74337:       return clone;
74337:     }
74337: 
74337:     JS_ClearPendingException(aCx);
74337:     return NS_DOMReadStructuredClone(aCx, aReader, aTag, aData, nsnull);
74337:   }
74337: 
74337:   static JSBool
74337:   Write(JSContext* aCx, JSStructuredCloneWriter* aWriter, JSObject* aObj,
74337:         void* aClosure)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
81573:     if (MainThreadWorkerStructuredCloneCallbacks::Write(aCx, aWriter, aObj,
81573:                                                         aClosure) ||
81573:         ChromeWorkerStructuredCloneCallbacks::Write(aCx, aWriter, aObj,
81573:                                                     aClosure) ||
81573:         NS_DOMWriteStructuredClone(aCx, aWriter, aObj, nsnull)) {
81573:       return true;
81573:     }
81573: 
81573:     return false;
74337:   }
74337: 
74337:   static void
84755:   Error(JSContext* aCx, uint32_t aErrorId)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
74337:     NS_DOMStructuredCloneError(aCx, aErrorId);
74337:   }
74337: };
74337: 
74337: JSStructuredCloneCallbacks gMainThreadChromeWorkerStructuredCloneCallbacks = {
74337:   MainThreadChromeWorkerStructuredCloneCallbacks::Read,
74337:   MainThreadChromeWorkerStructuredCloneCallbacks::Write,
74337:   MainThreadChromeWorkerStructuredCloneCallbacks::Error
74337: };
74337: 
74337: class WorkerFinishedRunnable : public WorkerControlRunnable
74337: {
74337:   WorkerPrivate* mFinishedWorker;
74337:   nsCOMPtr<nsIThread> mThread;
74337: 
74337:   class MainThreadReleaseRunnable : public nsRunnable
74337:   {
74337:     nsCOMPtr<nsIThread> mThread;
74337:     nsTArray<nsCOMPtr<nsISupports> > mDoomed;
74337: 
74337:   public:
74337:     MainThreadReleaseRunnable(nsCOMPtr<nsIThread>& aThread,
74337:                               nsTArray<nsCOMPtr<nsISupports> >& aDoomed)
74337:     {
74337:       mThread.swap(aThread);
74337:       mDoomed.SwapElements(aDoomed);
74337:     }
74337: 
74337:     NS_IMETHOD
74337:     Run()
74337:     {
74337:       mDoomed.Clear();
74338: 
74338:       if (mThread) {
74338:         RuntimeService* runtime = RuntimeService::GetService();
74338:         NS_ASSERTION(runtime, "This should never be null!");
74338: 
74338:         runtime->NoteIdleThread(mThread);
74338:       }
74338: 
74338:       return NS_OK;
74337:     }
74337:   };
74337: 
74337: public:
74337:   WorkerFinishedRunnable(WorkerPrivate* aWorkerPrivate,
74337:                          WorkerPrivate* aFinishedWorker,
74337:                          nsIThread* aFinishedThread)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
74337:     mFinishedWorker(aFinishedWorker), mThread(aFinishedThread)
74337:   { }
74337: 
74337:   bool
74337:   PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     // Silence bad assertions.
74337:     return true;
74337:   }
74337: 
74337:   void
74337:   PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                bool aDispatchResult)
74337:   {
74337:     // Silence bad assertions.
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     nsTArray<nsCOMPtr<nsISupports> > doomed;
74337:     mFinishedWorker->ForgetMainThreadObjects(doomed);
74337: 
74337:     nsRefPtr<MainThreadReleaseRunnable> runnable =
74337:       new MainThreadReleaseRunnable(mThread, doomed);
74337:     if (NS_FAILED(NS_DispatchToMainThread(runnable, NS_DISPATCH_NORMAL))) {
74337:       NS_WARNING("Failed to dispatch, going to leak!");
74337:     }
74337: 
80028:     mFinishedWorker->FinalizeInstance(aCx, false);
74337: 
74337:     RuntimeService* runtime = RuntimeService::GetService();
74337:     NS_ASSERTION(runtime, "This should never be null!");
74337: 
74337:     runtime->UnregisterWorker(aCx, mFinishedWorker);
74337: 
74337:     delete mFinishedWorker;
74337:     return true;
74337:   }
74337: };
74337: 
74337: class TopLevelWorkerFinishedRunnable : public nsRunnable
74337: {
74337:   WorkerPrivate* mFinishedWorker;
74337:   nsCOMPtr<nsIThread> mThread;
74337: 
74337: public:
74337:   TopLevelWorkerFinishedRunnable(WorkerPrivate* aFinishedWorker,
74337:                                  nsIThread* aFinishedThread)
74337:   : mFinishedWorker(aFinishedWorker), mThread(aFinishedThread)
74337:   {
74337:     aFinishedWorker->AssertIsOnWorkerThread();
74337:   }
74337: 
74337:   NS_IMETHOD
74337:   Run()
74337:   {
74337:     AssertIsOnMainThread();
74337: 
74337:     RuntimeService::AutoSafeJSContext cx;
74337: 
80028:     mFinishedWorker->FinalizeInstance(cx, false);
74337: 
74337:     RuntimeService* runtime = RuntimeService::GetService();
74337:     NS_ASSERTION(runtime, "This should never be null!");
74337: 
74337:     runtime->UnregisterWorker(cx, mFinishedWorker);
74337: 
74338:     if (mThread) {
74338:       runtime->NoteIdleThread(mThread);
74338:     }
74337: 
74337:     delete mFinishedWorker;
74337: 
74338:     return NS_OK;
74337:   }
74337: };
74337: 
74337: class ModifyBusyCountRunnable : public WorkerControlRunnable
74337: {
74337:   bool mIncrease;
74337: 
74337: public:
74337:   ModifyBusyCountRunnable(WorkerPrivate* aWorkerPrivate, bool aIncrease)
74337:   : WorkerControlRunnable(aWorkerPrivate, ParentThread, UnchangedBusyCount),
74337:     mIncrease(aIncrease)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     return aWorkerPrivate->ModifyBusyCount(aCx, mIncrease);
74337:   }
74337: 
74337:   void
74337:   PostRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate, bool aRunResult)
74337:   {
74337:     if (mIncrease) {
74337:       WorkerControlRunnable::PostRun(aCx, aWorkerPrivate, aRunResult);
74337:       return;
74337:     }
74337:     // Don't do anything here as it's possible that aWorkerPrivate has been
74337:     // deleted.
74337:   }
74337: };
74337: 
74337: class CompileScriptRunnable : public WorkerRunnable
74337: {
74337: public:
74337:   CompileScriptRunnable(WorkerPrivate* aWorkerPrivate)
88791:   : WorkerRunnable(aWorkerPrivate, WorkerThread, ModifyBusyCount,
88791:                    SkipWhenClearing)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     JSObject* global = CreateDedicatedWorkerGlobalScope(aCx);
74337:     if (!global) {
74337:       NS_WARNING("Failed to make global!");
74337:       return false;
74337:     }
74337: 
74337:     JSAutoEnterCompartment ac;
74337:     if (!ac.enter(aCx, global)) {
74337:       NS_WARNING("Failed to enter compartment!");
74337:       return false;
74337:     }
74337: 
74337:     JS_SetGlobalObject(aCx, global);
74337: 
74337:     return scriptloader::LoadWorkerScript(aCx);
74337:   }
74337: };
74337: 
74337: class CloseEventRunnable : public WorkerRunnable
74337: {
74337: public:
74337:   CloseEventRunnable(WorkerPrivate* aWorkerPrivate)
88791:   : WorkerRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount,
88791:                    SkipWhenClearing)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     JSObject* target = JS_GetGlobalObject(aCx);
74337:     NS_ASSERTION(target, "This must never be null!");
74337: 
74337:     aWorkerPrivate->CloseHandlerStarted();
74337: 
74337:     JSString* type = JS_InternString(aCx, "close");
74337:     if (!type) {
74337:       return false;
74337:     }
74337: 
74337:     JSObject* event = events::CreateGenericEvent(aCx, type, false, false,
74337:                                                  false);
74337:     if (!event) {
74337:       return false;
74337:     }
74337: 
74337:     bool ignored;
74337:     return events::DispatchEventToTarget(aCx, target, event, &ignored);
74337:   }
74337: 
74337:   void
74337:   PostRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate, bool aRunResult)
74337:   {
74337:     // Report errors.
74337:     WorkerRunnable::PostRun(aCx, aWorkerPrivate, aRunResult);
74337: 
74337:     // Match the busy count increase from NotifyRunnable.
74337:     if (!aWorkerPrivate->ModifyBusyCountFromWorker(aCx, false)) {
74337:       JS_ReportPendingException(aCx);
74337:     }
74337: 
74337:     aWorkerPrivate->CloseHandlerFinished();
74337:   }
74337: };
74337: 
74337: class MessageEventRunnable : public WorkerRunnable
74337: {
86471:   uint64_t* mData;
74337:   size_t mDataByteCount;
76372:   nsTArray<nsCOMPtr<nsISupports> > mClonedObjects;
74337: 
74337: public:
74337:   MessageEventRunnable(WorkerPrivate* aWorkerPrivate, Target aTarget,
76372:                        JSAutoStructuredCloneBuffer& aData,
76372:                        nsTArray<nsCOMPtr<nsISupports> >& aClonedObjects)
74337:   : WorkerRunnable(aWorkerPrivate, aTarget, aTarget == WorkerThread ?
74337:                                                        ModifyBusyCount :
88791:                                                        UnchangedBusyCount,
88791:                    SkipWhenClearing)
74337:   {
74337:     aData.steal(&mData, &mDataByteCount);
76372: 
76372:     if (!mClonedObjects.SwapElements(aClonedObjects)) {
76372:       NS_ERROR("This should never fail!");
76372:     }
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     JSAutoStructuredCloneBuffer buffer;
74542:     buffer.adopt(mData, mDataByteCount);
74337: 
74337:     mData = nsnull;
74337:     mDataByteCount = 0;
74337: 
74337:     bool mainRuntime;
74337:     JSObject* target;
74337:     if (mTarget == ParentThread) {
74337:       mainRuntime = !aWorkerPrivate->GetParent();
74337: 
74337:       target = aWorkerPrivate->GetJSObject();
74337: 
74337:       // Don't fire this event if the JS object has ben disconnected from the
74337:       // private object.
74337:       if (!target) {
74337:         return true;
74337:       }
74337: 
74337:       if (aWorkerPrivate->IsSuspended()) {
74337:         aWorkerPrivate->QueueRunnable(this);
74337:         buffer.steal(&mData, &mDataByteCount);
74337:         return true;
74337:       }
74337: 
74337:       aWorkerPrivate->AssertInnerWindowIsCorrect();
74337:     }
74337:     else {
74337:       NS_ASSERTION(aWorkerPrivate == GetWorkerPrivateFromContext(aCx),
74337:                    "Badness!");
74337:       mainRuntime = false;
74337:       target = JS_GetGlobalObject(aCx);
74337:     }
74337: 
74337:     NS_ASSERTION(target, "This should never be null!");
74337: 
76372:     JSObject* event = events::CreateMessageEvent(aCx, buffer, mClonedObjects,
76372:                                                  mainRuntime);
74337:     if (!event) {
74337:       return false;
74337:     }
74337: 
74337:     bool dummy;
74337:     return events::DispatchEventToTarget(aCx, target, event, &dummy);
74337:   }
74337: };
74337: 
74337: class NotifyRunnable : public WorkerControlRunnable
74337: {
86428:   bool mFromJSObjectFinalizer;
74337:   Status mStatus;
74337: 
74337: public:
86428:   NotifyRunnable(WorkerPrivate* aWorkerPrivate, bool aFromJSObjectFinalizer,
86428:                  Status aStatus)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
86428:     mFromJSObjectFinalizer(aFromJSObjectFinalizer), mStatus(aStatus)
74337:   {
74337:     NS_ASSERTION(aStatus == Terminating || aStatus == Canceling ||
74337:                  aStatus == Killing, "Bad status!");
74337:   }
74337: 
74337:   bool
74337:   PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     // Modify here, but not in PostRun! This busy count addition will be matched
86428:     // by the CloseEventRunnable. If we're running from a finalizer there is no
86428:     // need to modify the count because future changes to the busy count will
86428:     // have no effect.
86428:     return mFromJSObjectFinalizer ?
86428:            true :
86428:            aWorkerPrivate->ModifyBusyCount(aCx, true);
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     return aWorkerPrivate->NotifyInternal(aCx, mStatus);
74337:   }
74337: };
74337: 
74337: class CloseRunnable : public WorkerControlRunnable
74337: {
74337: public:
74337:   CloseRunnable(WorkerPrivate* aWorkerPrivate)
74337:   : WorkerControlRunnable(aWorkerPrivate, ParentThread, UnchangedBusyCount)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     // This busy count will be matched by the CloseEventRunnable.
74337:     return aWorkerPrivate->ModifyBusyCount(aCx, true) &&
74337:            aWorkerPrivate->Close(aCx);
74337:   }
74337: };
74337: 
74337: class SuspendRunnable : public WorkerControlRunnable
74337: {
74337: public:
74337:   SuspendRunnable(WorkerPrivate* aWorkerPrivate)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     return aWorkerPrivate->SuspendInternal(aCx);
74337:   }
74337: };
74337: 
74337: class ResumeRunnable : public WorkerControlRunnable
74337: {
74337: public:
74337:   ResumeRunnable(WorkerPrivate* aWorkerPrivate)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     return aWorkerPrivate->ResumeInternal(aCx);
74337:   }
74337: };
74337: 
74337: class ReportErrorRunnable : public WorkerRunnable
74337: {
74337:   nsString mMessage;
74337:   nsString mFilename;
74337:   nsString mLine;
74337:   PRUint32 mLineNumber;
74337:   PRUint32 mColumnNumber;
74337:   PRUint32 mFlags;
74337:   PRUint32 mErrorNumber;
74337: 
74337: public:
74337:   ReportErrorRunnable(WorkerPrivate* aWorkerPrivate, const nsString& aMessage,
74337:                       const nsString& aFilename, const nsString& aLine,
74337:                       PRUint32 aLineNumber, PRUint32 aColumnNumber,
74337:                       PRUint32 aFlags, PRUint32 aErrorNumber)
88791:   : WorkerRunnable(aWorkerPrivate, ParentThread, UnchangedBusyCount,
88791:                    SkipWhenClearing),
74337:     mMessage(aMessage), mFilename(aFilename), mLine(aLine),
74337:     mLineNumber(aLineNumber), mColumnNumber(aColumnNumber), mFlags(aFlags),
74337:     mErrorNumber(aErrorNumber)
74337:   { }
74337: 
74337:   void
74337:   PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                bool aDispatchResult)
74337:   {
74337:     aWorkerPrivate->AssertIsOnWorkerThread();
74337: 
74337:     // Dispatch may fail if the worker was canceled, no need to report that as
74337:     // an error, so don't call base class PostDispatch.
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     JSObject* target = aWorkerPrivate->GetJSObject();
74337:     if (target) {
74337:       aWorkerPrivate->AssertInnerWindowIsCorrect();
74337:     }
74337: 
77330:     PRUint64 innerWindowId;
74337: 
74337:     WorkerPrivate* parent = aWorkerPrivate->GetParent();
74337:     if (parent) {
77330:       innerWindowId = 0;
74337:     }
74337:     else {
74337:       AssertIsOnMainThread();
74337: 
74337:       if (aWorkerPrivate->IsSuspended()) {
74337:         aWorkerPrivate->QueueRunnable(this);
74337:         return true;
74337:       }
74337: 
77330:       innerWindowId = aWorkerPrivate->GetInnerWindowId();
74337:     }
74337: 
74337:     return ReportErrorRunnable::ReportError(aCx, parent, true, target, mMessage,
74337:                                             mFilename, mLine, mLineNumber,
74337:                                             mColumnNumber, mFlags,
77330:                                             mErrorNumber, innerWindowId);
74337:   }
74337: 
74337:   static bool
74337:   ReportError(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:               bool aFireAtScope, JSObject* aTarget, const nsString& aMessage,
74337:               const nsString& aFilename, const nsString& aLine,
74337:               PRUint32 aLineNumber, PRUint32 aColumnNumber, PRUint32 aFlags,
77330:               PRUint32 aErrorNumber, PRUint64 aInnerWindowId)
74337:   {
74337:     if (aWorkerPrivate) {
74337:       aWorkerPrivate->AssertIsOnWorkerThread();
74337:     }
74337:     else {
74337:       AssertIsOnMainThread();
74337:     }
74337: 
74337:     JSString* message = JS_NewUCStringCopyN(aCx, aMessage.get(),
74337:                                             aMessage.Length());
74337:     if (!message) {
74337:       return false;
74337:     }
74337: 
74337:     JSString* filename = JS_NewUCStringCopyN(aCx, aFilename.get(),
74337:                                              aFilename.Length());
74337:     if (!filename) {
74337:       return false;
74337:     }
74337: 
74337:     // First fire an ErrorEvent at the worker.
74337:     if (aTarget) {
74337:       JSObject* event = events::CreateErrorEvent(aCx, message, filename,
74337:                                                  aLineNumber, !aWorkerPrivate);
74337:       if (!event) {
74337:         return false;
74337:       }
74337: 
74337:       bool preventDefaultCalled;
74337:       if (!events::DispatchEventToTarget(aCx, aTarget, event,
74337:                                          &preventDefaultCalled)) {
74337:         return false;
74337:       }
74337: 
74337:       if (preventDefaultCalled) {
74337:         return true;
74337:       }
74337:     }
74337: 
74337:     // Now fire an event at the global object, but don't do that if the error
74337:     // code is too much recursion and this is the same script threw the error.
74337:     if (aFireAtScope && (aTarget || aErrorNumber != JSMSG_OVER_RECURSED)) {
74337:       aTarget = JS_GetGlobalForScopeChain(aCx);
74337:       NS_ASSERTION(aTarget, "This should never be null!");
74337: 
74337:       bool preventDefaultCalled;
80426:       nsIScriptGlobalObject* sgo;
80426: 
80426:       if (aWorkerPrivate ||
80426:           !(sgo = nsJSUtils::GetStaticScriptGlobal(aCx, aTarget))) {
74337:         // Fire a normal ErrorEvent if we're running on a worker thread.
74337:         JSObject* event = events::CreateErrorEvent(aCx, message, filename,
74337:                                                    aLineNumber, false);
74337:         if (!event) {
74337:           return false;
74337:         }
74337: 
74337:         if (!events::DispatchEventToTarget(aCx, aTarget, event,
74337:                                            &preventDefaultCalled)) {
74337:           return false;
74337:         }
74337:       }
74337:       else {
74337:         // Icky, we have to fire an nsScriptErrorEvent...
74337:         nsScriptErrorEvent event(true, NS_LOAD_ERROR);
74337:         event.lineNr = aLineNumber;
74337:         event.errorMsg = aMessage.get();
74337:         event.fileName = aFilename.get();
74337: 
74337:         nsEventStatus status;
74337:         if (NS_FAILED(sgo->HandleScriptError(&event, &status))) {
74337:           NS_WARNING("Failed to dispatch main thread error event!");
74337:           status = nsEventStatus_eIgnore;
74337:         }
74337: 
74337:         preventDefaultCalled = status == nsEventStatus_eConsumeNoDefault;
74337:       }
74337: 
74337:       if (preventDefaultCalled) {
74337:         return true;
74337:       }
74337:     }
74337: 
74337:     // Now fire a runnable to do the same on the parent's thread if we can.
74337:     if (aWorkerPrivate) {
74337:       nsRefPtr<ReportErrorRunnable> runnable =
74337:         new ReportErrorRunnable(aWorkerPrivate, aMessage, aFilename, aLine,
74337:                                 aLineNumber, aColumnNumber, aFlags,
74337:                                 aErrorNumber);
74337:       return runnable->Dispatch(aCx);
74337:     }
74337: 
74337:     // Otherwise log an error to the error console.
86030:     nsCOMPtr<nsIScriptError> scriptError =
74337:       do_CreateInstance(NS_SCRIPTERROR_CONTRACTID);
86030:     NS_WARN_IF_FALSE(scriptError, "Failed to create script error!");
74337: 
74337:     if (scriptError) {
86030:       if (NS_FAILED(scriptError->InitWithWindowID(aMessage.get(),
74337:                                                   aFilename.get(),
74337:                                                   aLine.get(), aLineNumber,
74337:                                                   aColumnNumber, aFlags,
74337:                                                   "Web Worker",
77330:                                                   aInnerWindowId))) {
74337:         NS_WARNING("Failed to init script error!");
86030:         scriptError = nsnull;
74337:       }
74337:     }
74337: 
74337:     nsCOMPtr<nsIConsoleService> consoleService =
74337:       do_GetService(NS_CONSOLESERVICE_CONTRACTID);
86030:     NS_WARN_IF_FALSE(consoleService, "Failed to get console service!");
74337: 
74337:     bool logged = false;
74337: 
74337:     if (consoleService) {
86030:       if (scriptError) {
86030:         if (NS_SUCCEEDED(consoleService->LogMessage(scriptError))) {
74337:           logged = true;
74337:         }
74337:         else {
74337:           NS_WARNING("Failed to log script error!");
74337:         }
74337:       }
74337:       else if (NS_SUCCEEDED(consoleService->LogStringMessage(aMessage.get()))) {
74337:         logged = true;
74337:       }
74337:       else {
74337:         NS_WARNING("Failed to log script error!");
74337:       }
74337:     }
74337: 
74337:     if (!logged) {
86209:       NS_ConvertUTF16toUTF8 msg(aMessage);
86209: #ifdef ANDROID
86209:       __android_log_print(ANDROID_LOG_INFO, "Gecko", msg.get());
86209: #endif
86209:       fputs(msg.get(), stderr);
74337:       fflush(stderr);
74337:     }
74337: 
74337:     return true;
74337:   }
74337: };
74337: 
74337: class TimerRunnable : public WorkerRunnable
74337: {
74337: public:
74337:   TimerRunnable(WorkerPrivate* aWorkerPrivate)
88791:   : WorkerRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount,
88791:                    SkipWhenClearing)
74337:   { }
74337: 
74337:   bool
74337:   PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     // Silence bad assertions.
74337:     return true;
74337:   }
74337: 
74337:   void
74337:   PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                bool aDispatchResult)
74337:   {
74337:     // Silence bad assertions.
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     return aWorkerPrivate->RunExpiredTimeouts(aCx);
74337:   }
74337: };
74337: 
74337: void
74337: DummyCallback(nsITimer* aTimer, void* aClosure)
74337: {
74337:   // Nothing!
74337: }
74337: 
74337: class WorkerRunnableEventTarget : public nsIEventTarget
74337: {
74337: protected:
74337:   nsRefPtr<WorkerRunnable> mWorkerRunnable;
74337: 
74337: public:
74337:   WorkerRunnableEventTarget(WorkerRunnable* aWorkerRunnable)
74337:   : mWorkerRunnable(aWorkerRunnable)
74337:   { }
74337: 
74337:   NS_DECL_ISUPPORTS
74337: 
74337:   NS_IMETHOD
74337:   Dispatch(nsIRunnable* aRunnable, PRUint32 aFlags)
74337:   {
74337:     NS_ASSERTION(aFlags == nsIEventTarget::DISPATCH_NORMAL, "Don't call me!");
74337: 
74337:     nsRefPtr<WorkerRunnableEventTarget> kungFuDeathGrip = this;
74337: 
74337:     // This can fail if we're racing to terminate or cancel, should be handled
74337:     // by the terminate or cancel code.
74337:     mWorkerRunnable->Dispatch(nsnull);
74337: 
74337:     // Run the runnable we're given now (should just call DummyCallback()),
74337:     // otherwise the timer thread will leak it...
74337:     return aRunnable->Run();
74337:   }
74337: 
74337:   NS_IMETHOD
79445:   IsOnCurrentThread(bool* aIsOnCurrentThread)
74337:   {
74337:     *aIsOnCurrentThread = false;
74337:     return NS_OK;
74337:   }
74337: };
74337: 
74337: NS_IMPL_THREADSAFE_ISUPPORTS1(WorkerRunnableEventTarget, nsIEventTarget)
74337: 
74337: class KillCloseEventRunnable : public WorkerRunnable
74337: {
74337:   nsCOMPtr<nsITimer> mTimer;
74337: 
74337:   class KillScriptRunnable : public WorkerControlRunnable
74337:   {
74337:   public:
74337:     KillScriptRunnable(WorkerPrivate* aWorkerPrivate)
74337:     : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount)
74337:     { }
74337: 
74337:     bool
74337:     PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:     {
74337:       // Silence bad assertions.
74337:       return true;
74337:     }
74337: 
74337:     void
74337:     PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                  bool aDispatchResult)
74337:     {
74337:       // Silence bad assertions.
74337:     }
74337: 
74337:     bool
74337:     WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:     {
74337:       // Kill running script.
74337:       return false;
74337:     }
74337:   };
74337: 
74337: public:
74337:   KillCloseEventRunnable(WorkerPrivate* aWorkerPrivate)
88791:   : WorkerRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount,
88791:                    SkipWhenClearing)
74337:   { }
74337: 
74337:   ~KillCloseEventRunnable()
74337:   {
74337:     if (mTimer) {
74337:       mTimer->Cancel();
74337:     }
74337:   }
74337: 
74337:   bool
74337:   PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     NS_NOTREACHED("Not meant to be dispatched!");
74337:     return false;
74337:   }
74337: 
74337:   bool
74337:   SetTimeout(JSContext* aCx, PRUint32 aDelayMS)
74337:   {
74337:     nsCOMPtr<nsITimer> timer = do_CreateInstance(NS_TIMER_CONTRACTID);
74337:     if (!timer) {
74337:       JS_ReportError(aCx, "Failed to create timer!");
74337:       return false;
74337:     }
74337: 
74337:     nsRefPtr<KillScriptRunnable> runnable =
74337:       new KillScriptRunnable(mWorkerPrivate);
74337: 
74337:     nsRefPtr<WorkerRunnableEventTarget> target =
74337:       new WorkerRunnableEventTarget(runnable);
74337: 
74337:     if (NS_FAILED(timer->SetTarget(target))) {
74337:       JS_ReportError(aCx, "Failed to set timer's target!");
74337:       return false;
74337:     }
74337: 
74337:     if (NS_FAILED(timer->InitWithFuncCallback(DummyCallback, nsnull, aDelayMS,
74337:                                               nsITimer::TYPE_ONE_SHOT))) {
74337:       JS_ReportError(aCx, "Failed to start timer!");
74337:       return false;
74337:     }
74337: 
74337:     mTimer.swap(timer);
74337:     return true;
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     if (mTimer) {
74337:       mTimer->Cancel();
74337:       mTimer = nsnull;
74337:     }
74337: 
74337:     return true;
74337:   }
74337: };
74337: 
74337: class UpdateJSContextOptionsRunnable : public WorkerControlRunnable
74337: {
74337:   PRUint32 mOptions;
74337: 
74337: public:
74337:   UpdateJSContextOptionsRunnable(WorkerPrivate* aWorkerPrivate,
74337:                                  PRUint32 aOptions)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
74337:     mOptions(aOptions)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     aWorkerPrivate->UpdateJSContextOptionsInternal(aCx, mOptions);
74337:     return true;
74337:   }
74337: };
74337: 
86576: class UpdateJSRuntimeHeapSizeRunnable : public WorkerControlRunnable
86576: {
86576:   PRUint32 mJSRuntimeHeapSize;
86576: 
86576: public:
86576:   UpdateJSRuntimeHeapSizeRunnable(WorkerPrivate* aWorkerPrivate,
86576:                                   PRUint32 aJSRuntimeHeapSize)
86576:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
86576:     mJSRuntimeHeapSize(aJSRuntimeHeapSize)
86576:   { }
86576: 
86576:   bool
86576:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
86576:   {
86576:     aWorkerPrivate->UpdateJSRuntimeHeapSizeInternal(aCx, mJSRuntimeHeapSize);
86576:     return true;
86576:   }
86576: };
86576: 
74337: #ifdef JS_GC_ZEAL
74337: class UpdateGCZealRunnable : public WorkerControlRunnable
74337: {
74337:   PRUint8 mGCZeal;
74337: 
74337: public:
74337:   UpdateGCZealRunnable(WorkerPrivate* aWorkerPrivate,
74337:                        PRUint8 aGCZeal)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
74337:     mGCZeal(aGCZeal)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     aWorkerPrivate->UpdateGCZealInternal(aCx, mGCZeal);
74337:     return true;
74337:   }
74337: };
74337: #endif
74337: 
87588: class GarbageCollectRunnable : public WorkerControlRunnable
87588: {
87588: protected:
87588:   bool mShrinking;
87588:   bool mCollectChildren;
87588: 
87588: public:
87588:   GarbageCollectRunnable(WorkerPrivate* aWorkerPrivate, bool aShrinking,
87588:                          bool aCollectChildren)
87588:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
87588:     mShrinking(aShrinking), mCollectChildren(aCollectChildren)
87588:   { }
87588: 
87588:   bool
87588:   PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
87588:   {
87588:     // Silence bad assertions, this can be dispatched from either the main
87588:     // thread or the timer thread..
87588:     return true;
87588:   }
87588: 
87588:   void
87588:   PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
87588:                 bool aDispatchResult)
87588:   {
87588:     // Silence bad assertions, this can be dispatched from either the main
87588:     // thread or the timer thread..
87588:   }
87588: 
87588:   bool
87588:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
87588:   {
87588:     aWorkerPrivate->GarbageCollectInternal(aCx, mShrinking, mCollectChildren);
87588:     return true;
87588:   }
87588: };
87588: 
75066: class CollectRuntimeStatsRunnable : public WorkerControlRunnable
75066: {
75066:   typedef mozilla::Mutex Mutex;
75066:   typedef mozilla::CondVar CondVar;
75066: 
78275:   Mutex mMutex;
78275:   CondVar mCondVar;
78275:   volatile bool mDone;
86388:   bool mIsQuick;
86388:   void* mData;
78275:   bool* mSucceeded;
75066: 
75066: public:
86388:   CollectRuntimeStatsRunnable(WorkerPrivate* aWorkerPrivate, bool aIsQuick,
86388:                               void* aData, bool* aSucceeded)
75066:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
78275:     mMutex("CollectRuntimeStatsRunnable::mMutex"),
78275:     mCondVar(mMutex, "CollectRuntimeStatsRunnable::mCondVar"), mDone(false),
86388:     mIsQuick(aIsQuick), mData(aData), mSucceeded(aSucceeded)
75066:   { }
75066: 
75066:   bool
75066:   PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
75066:   {
75066:     AssertIsOnMainThread();
75066:     return true;
75066:   }
75066: 
75066:   void
75066:   PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
75066:                bool aDispatchResult)
75066:   {
75066:     AssertIsOnMainThread();
75066:   }
75066: 
75066:   bool
78275:   DispatchInternal()
78275:   {
78275:     AssertIsOnMainThread();
78275: 
78275:     if (!WorkerControlRunnable::DispatchInternal()) {
78275:       NS_WARNING("Failed to dispatch runnable!");
78275:       return false;
78275:     }
78275: 
78275:     {
78275:       MutexAutoLock lock(mMutex);
78275:       while (!mDone) {
78275:         mCondVar.Wait();
78275:       }
78275:     }
78275: 
78275:     return true;
78275:   }
78275: 
78275:   bool
75066:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
75066:   {
75066:     JSAutoSuspendRequest asr(aCx);
75066: 
86987:     *mSucceeded = mIsQuick
86987:       ? JS::GetExplicitNonHeapForRuntime(JS_GetRuntime(aCx), static_cast<int64_t*>(mData), xpc::JsMallocSizeOf)
88580:       : JS::CollectRuntimeStats(JS_GetRuntime(aCx), static_cast<JS::RuntimeStats*>(mData));
75066: 
75066:     {
78275:       MutexAutoLock lock(mMutex);
78275:       mDone = true;
78275:       mCondVar.Notify();
75066:     }
75066: 
75066:     return true;
75066:   }
75066: };
75066: 
74337: } /* anonymous namespace */
74337: 
74337: #ifdef DEBUG
74337: void
74337: mozilla::dom::workers::AssertIsOnMainThread()
74337: {
74337:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
74337: }
74337: 
74337: WorkerRunnable::WorkerRunnable(WorkerPrivate* aWorkerPrivate, Target aTarget,
88791:                                BusyBehavior aBusyBehavior,
88791:                                ClearingBehavior aClearingBehavior)
74337: : mWorkerPrivate(aWorkerPrivate), mTarget(aTarget),
88791:   mBusyBehavior(aBusyBehavior), mClearingBehavior(aClearingBehavior)
74337: {
74337:   NS_ASSERTION(aWorkerPrivate, "Null worker private!");
74337: }
74337: #endif
74337: 
74337: NS_IMPL_THREADSAFE_ISUPPORTS1(WorkerRunnable, nsIRunnable)
74337: 
74337: bool
74337: WorkerRunnable::PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337: {
74337: #ifdef DEBUG
74337:   if (mBusyBehavior == ModifyBusyCount) {
74337:     NS_ASSERTION(mTarget == WorkerThread,
74337:                  "Don't set this option unless targeting the worker thread!");
74337:   }
74337:   if (mTarget == ParentThread) {
74337:     aWorkerPrivate->AssertIsOnWorkerThread();
74337:   }
74337:   else {
74337:     aWorkerPrivate->AssertIsOnParentThread();
74337:   }
74337: #endif
74337: 
87172:   if (mBusyBehavior == ModifyBusyCount && aCx) {
74337:     return aWorkerPrivate->ModifyBusyCount(aCx, true);
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: bool
74337: WorkerRunnable::Dispatch(JSContext* aCx)
74337: {
74337:   bool ok;
74337: 
74337:   if (!aCx) {
74337:     ok = PreDispatch(nsnull, mWorkerPrivate);
74337:     if (ok) {
74337:       ok = DispatchInternal();
74337:     }
74337:     PostDispatch(nsnull, mWorkerPrivate, ok);
74337:     return ok;
74337:   }
74337: 
74337:   JSAutoRequest ar(aCx);
74337: 
74337:   JSObject* global = JS_GetGlobalObject(aCx);
74337: 
74337:   JSAutoEnterCompartment ac;
74337:   if (global && !ac.enter(aCx, global)) {
74337:     return false;
74337:   }
74337: 
74337:   ok = PreDispatch(aCx, mWorkerPrivate);
74337: 
74337:   if (ok && !DispatchInternal()) {
74337:     ok = false;
74337:   }
74337: 
74337:   PostDispatch(aCx, mWorkerPrivate, ok);
74337: 
74337:   return ok;
74337: }
74337: 
74337: // static
74337: bool
74337: WorkerRunnable::DispatchToMainThread(nsIRunnable* aRunnable)
74337: {
74337:   nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
74337:   NS_ASSERTION(mainThread, "This should never fail!");
74337: 
74337:   return NS_SUCCEEDED(mainThread->Dispatch(aRunnable, NS_DISPATCH_NORMAL));
74337: }
74337: 
74337: // These DispatchInternal functions look identical but carry important type
74337: // informaton so they can't be consolidated...
74337: 
74337: #define IMPL_DISPATCH_INTERNAL(_class)                                         \
74337:   bool                                                                         \
74337:   _class ::DispatchInternal()                                                  \
74337:   {                                                                            \
74337:     if (mTarget == WorkerThread) {                                             \
74337:       return mWorkerPrivate->Dispatch(this);                                   \
74337:     }                                                                          \
74337:                                                                                \
74337:     if (mWorkerPrivate->GetParent()) {                                         \
74337:       return mWorkerPrivate->GetParent()->Dispatch(this);                      \
74337:     }                                                                          \
74337:                                                                                \
74337:     return DispatchToMainThread(this);                                         \
74337:   }
74337: 
74337: IMPL_DISPATCH_INTERNAL(WorkerRunnable)
74337: IMPL_DISPATCH_INTERNAL(WorkerSyncRunnable)
74337: IMPL_DISPATCH_INTERNAL(WorkerControlRunnable)
74337: 
74337: #undef IMPL_DISPATCH_INTERNAL
74337: 
74337: void
74337: WorkerRunnable::PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                              bool aDispatchResult)
74337: {
74337: #ifdef DEBUG
74337:   if (mTarget == ParentThread) {
74337:     aWorkerPrivate->AssertIsOnWorkerThread();
74337:   }
74337:   else {
74337:     aWorkerPrivate->AssertIsOnParentThread();
74337:   }
74337: #endif
74337: 
87172:   if (!aDispatchResult && aCx) {
74337:     if (mBusyBehavior == ModifyBusyCount) {
74337:       aWorkerPrivate->ModifyBusyCount(aCx, false);
74337:     }
74337:     JS_ReportPendingException(aCx);
74337:   }
74337: }
74337: 
74337: NS_IMETHODIMP
74337: WorkerRunnable::Run()
74337: {
74337:   JSContext* cx;
74584:   JSObject* targetCompartmentObject;
74337:   nsIThreadJSContextStack* contextStack = nsnull;
74337: 
74337:   if (mTarget == WorkerThread) {
74337:     mWorkerPrivate->AssertIsOnWorkerThread();
74337:     cx = mWorkerPrivate->GetJSContext();
74584:     targetCompartmentObject = JS_GetGlobalObject(cx);
74337:   } else {
74337:     mWorkerPrivate->AssertIsOnParentThread();
74337:     cx = mWorkerPrivate->ParentJSContext();
74584:     targetCompartmentObject = mWorkerPrivate->GetJSObject();
74337: 
74337:     if (!mWorkerPrivate->GetParent()) {
74337:       AssertIsOnMainThread();
74337: 
74337:       contextStack = nsContentUtils::ThreadJSContextStack();
74337:       NS_ASSERTION(contextStack, "This should never be null!");
74337: 
74337:       if (NS_FAILED(contextStack->Push(cx))) {
74337:         NS_WARNING("Failed to push context!");
74337:         contextStack = nsnull;
74337:       }
74337:     }
74337:   }
74337: 
74337:   NS_ASSERTION(cx, "Must have a context!");
74337: 
74337:   JSAutoRequest ar(cx);
74337: 
74337:   JSAutoEnterCompartment ac;
74584:   if (targetCompartmentObject && !ac.enter(cx, targetCompartmentObject)) {
74337:     return false;
74337:   }
74337: 
74337:   bool result = WorkerRun(cx, mWorkerPrivate);
74337: 
74337:   PostRun(cx, mWorkerPrivate, result);
74337: 
74337:   if (contextStack) {
74337:     JSContext* otherCx;
74337:     if (NS_FAILED(contextStack->Pop(&otherCx))) {
74337:       NS_WARNING("Failed to pop context!");
74337:     }
74337:     else if (otherCx != cx) {
74337:       NS_WARNING("Popped a different context!");
74337:     }
74337:   }
74337: 
74337:   return result ? NS_OK : NS_ERROR_FAILURE;
74337: }
74337: 
74337: void
74337: WorkerRunnable::PostRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                         bool aRunResult)
74337: {
74337: #ifdef DEBUG
74337:   if (mTarget == ParentThread) {
74337:     mWorkerPrivate->AssertIsOnParentThread();
74337:   }
74337:   else {
74337:     mWorkerPrivate->AssertIsOnWorkerThread();
74337:   }
74337: #endif
74337: 
74337:   if (mBusyBehavior == ModifyBusyCount) {
74337:     if (!aWorkerPrivate->ModifyBusyCountFromWorker(aCx, false)) {
74337:       aRunResult = false;
74337:     }
74337:   }
74337: 
74337:   if (!aRunResult) {
74337:     JS_ReportPendingException(aCx);
74337:   }
74337: }
74337: 
74337: struct WorkerPrivate::TimeoutInfo
74337: {
74337:   TimeoutInfo()
74337:   : mTimeoutVal(JSVAL_VOID), mLineNumber(0), mId(0), mIsInterval(false),
74337:     mCanceled(false)
74337:   {
74337:     MOZ_COUNT_CTOR(mozilla::dom::workers::WorkerPrivate::TimeoutInfo);
74337:   }
74337: 
74337:   ~TimeoutInfo()
74337:   {
74337:     MOZ_COUNT_DTOR(mozilla::dom::workers::WorkerPrivate::TimeoutInfo);
74337:   }
74337: 
74337:   bool operator==(const TimeoutInfo& aOther)
74337:   {
74337:     return mTargetTime == aOther.mTargetTime;
74337:   }
74337: 
74337:   bool operator<(const TimeoutInfo& aOther)
74337:   {
74337:     return mTargetTime < aOther.mTargetTime;
74337:   }
74337: 
74337:   jsval mTimeoutVal;
74337:   nsTArray<jsval> mExtraArgVals;
74337:   mozilla::TimeStamp mTargetTime;
74337:   mozilla::TimeDuration mInterval;
74337:   nsCString mFilename;
74337:   PRUint32 mLineNumber;
74337:   PRUint32 mId;
74337:   bool mIsInterval;
74337:   bool mCanceled;
74337: };
74337: 
74337: template <class Derived>
74337: WorkerPrivateParent<Derived>::WorkerPrivateParent(
74337:                                      JSContext* aCx, JSObject* aObject,
74337:                                      WorkerPrivate* aParent,
74337:                                      JSContext* aParentJSContext,
74337:                                      const nsAString& aScriptURL,
74337:                                      bool aIsChromeWorker,
74337:                                      const nsACString& aDomain,
74337:                                      nsCOMPtr<nsPIDOMWindow>& aWindow,
74337:                                      nsCOMPtr<nsIScriptContext>& aScriptContext,
74337:                                      nsCOMPtr<nsIURI>& aBaseURI,
74337:                                      nsCOMPtr<nsIPrincipal>& aPrincipal,
74337:                                      nsCOMPtr<nsIDocument>& aDocument)
74337: : mMutex("WorkerPrivateParent Mutex"),
74337:   mCondVar(mMutex, "WorkerPrivateParent CondVar"),
74337:   mJSObject(aObject), mParent(aParent), mParentJSContext(aParentJSContext),
74337:   mScriptURL(aScriptURL), mDomain(aDomain), mBusyCount(0),
86576:   mParentStatus(Pending), mJSContextOptions(0), mJSRuntimeHeapSize(0),
86576:   mGCZeal(0), mJSObjectRooted(false), mParentSuspended(false),
76372:   mIsChromeWorker(aIsChromeWorker), mPrincipalIsSystem(false)
74337: {
74337:   MOZ_COUNT_CTOR(mozilla::dom::workers::WorkerPrivateParent);
74337: 
74337:   if (aWindow) {
74337:     NS_ASSERTION(aWindow->IsInnerWindow(), "Should have inner window here!");
74337:   }
74337: 
74337:   mWindow.swap(aWindow);
74337:   mScriptContext.swap(aScriptContext);
74337:   mBaseURI.swap(aBaseURI);
74337:   mPrincipal.swap(aPrincipal);
74337:   mDocument.swap(aDocument);
74337: 
74337:   if (aParent) {
74337:     aParent->AssertIsOnWorkerThread();
74337: 
74337:     NS_ASSERTION(JS_GetOptions(aCx) == aParent->GetJSContextOptions(),
74337:                  "Options mismatch!");
74337:     mJSContextOptions = aParent->GetJSContextOptions();
86576: 
86576:     NS_ASSERTION(JS_GetGCParameter(JS_GetRuntime(aCx), JSGC_MAX_BYTES) ==
86576:                  aParent->GetJSRuntimeHeapSize(),
86576:                  "Runtime heap size mismatch!");
86576:     mJSRuntimeHeapSize = aParent->GetJSRuntimeHeapSize();
86576: 
74337: #ifdef JS_GC_ZEAL
74337:     mGCZeal = aParent->GetGCZeal();
74337: #endif
74337:   }
74337:   else {
74337:     AssertIsOnMainThread();
74337: 
74337:     mJSContextOptions = RuntimeService::GetDefaultJSContextOptions();
86576:     mJSRuntimeHeapSize = RuntimeService::GetDefaultJSRuntimeHeapSize();
74337: #ifdef JS_GC_ZEAL
74337:     mGCZeal = RuntimeService::GetDefaultGCZeal();
74337: #endif
74337:   }
74337: }
74337: 
74337: template <class Derived>
74337: WorkerPrivateParent<Derived>::~WorkerPrivateParent()
74337: {
74337:   MOZ_COUNT_DTOR(mozilla::dom::workers::WorkerPrivateParent);
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::Start()
74337: {
74337:   // May be called on any thread!
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     NS_ASSERTION(mParentStatus != Running, "How can this be?!");
74337: 
74337:     if (mParentStatus == Pending) {
74337:       mParentStatus = Running;
74337:       return true;
74337:     }
74337:   }
74337: 
74337:   return false;
74337: }
74337: 
74337: template <class Derived>
74337: bool
86428: WorkerPrivateParent<Derived>::NotifyPrivate(JSContext* aCx, Status aStatus,
86428:                                             bool aFromJSObjectFinalizer)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   bool pending;
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mParentStatus >= aStatus) {
74337:       return true;
74337:     }
74337: 
74337:     pending = mParentStatus == Pending;
74337:     mParentStatus = aStatus;
74337:   }
74337: 
80028:   FinalizeInstance(aCx, false);
74337: 
74337:   if (pending) {
74337:     WorkerPrivate* self = ParentAsWorkerPrivate();
74337: #ifdef DEBUG
74337:     {
74337:       // Silence useless assertions in debug builds.
74337:       nsIThread* currentThread = NS_GetCurrentThread();
74337:       NS_ASSERTION(currentThread, "This should never be null!");
74337: 
74337:       self->SetThread(currentThread);
74337:     }
74337: #endif
74337:     // Worker never got a chance to run, go ahead and delete it.
74337:     self->ScheduleDeletion(true);
74337:     return true;
74337:   }
74337: 
74337:   NS_ASSERTION(aStatus != Terminating || mQueuedRunnables.IsEmpty(),
74337:                "Shouldn't have anything queued!");
74337: 
74337:   // Anything queued will be discarded.
74337:   mQueuedRunnables.Clear();
74337: 
74337:   nsRefPtr<NotifyRunnable> runnable =
86428:     new NotifyRunnable(ParentAsWorkerPrivate(), aFromJSObjectFinalizer,
86428:                        aStatus);
86428:   return runnable->Dispatch(aFromJSObjectFinalizer ? nsnull : aCx);
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::Suspend(JSContext* aCx)
74337: {
74337:   AssertIsOnParentThread();
74337:   NS_ASSERTION(!mParentSuspended, "Suspended more than once!");
74337: 
74337:   mParentSuspended = true;
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mParentStatus >= Terminating) {
74337:       return true;
74337:     }
74337:   }
74337: 
74337:   nsRefPtr<SuspendRunnable> runnable =
74337:     new SuspendRunnable(ParentAsWorkerPrivate());
74337:   return runnable->Dispatch(aCx);
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::Resume(JSContext* aCx)
74337: {
74337:   AssertIsOnParentThread();
74337:   NS_ASSERTION(mParentSuspended, "Not yet suspended!");
74337: 
74337:   mParentSuspended = false;
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mParentStatus >= Terminating) {
74337:       return true;
74337:     }
74337:   }
74337: 
74337:   // Dispatch queued runnables before waking up the worker, otherwise the worker
74337:   // could post new messages before we run those that have been queued.
74337:   if (!mQueuedRunnables.IsEmpty()) {
74337:     AssertIsOnMainThread();
74337: 
74337:     nsTArray<nsRefPtr<WorkerRunnable> > runnables;
74337:     mQueuedRunnables.SwapElements(runnables);
74337: 
74337:     for (PRUint32 index = 0; index < runnables.Length(); index++) {
74337:       nsRefPtr<WorkerRunnable>& runnable = runnables[index];
74337:       if (NS_FAILED(NS_DispatchToCurrentThread(runnable))) {
74337:         NS_WARNING("Failed to dispatch queued runnable!");
74337:       }
74337:     }
74337:   }
74337: 
74337:   nsRefPtr<ResumeRunnable> runnable =
74337:     new ResumeRunnable(ParentAsWorkerPrivate());
74337:   if (!runnable->Dispatch(aCx)) {
74337:     return false;
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: template <class Derived>
74337: void
80028: WorkerPrivateParent<Derived>::FinalizeInstance(JSContext* aCx,
80028:                                                bool aFromJSFinalizer)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   if (mJSObject) {
86428:     // Make sure we're in the right compartment, but only enter one if this is
86428:     // not running from a finalizer.
80028:     JSAutoEnterCompartment ac;
86428:     if (!aFromJSFinalizer && !ac.enter(aCx, mJSObject)) {
80028:       NS_ERROR("How can this fail?!");
80028:       return;
80028:     }
80028: 
74337:     // Decouple the object from the private now.
80028:     worker::ClearPrivateSlot(aCx, mJSObject, !aFromJSFinalizer);
74337: 
74337:     // Clear the JS object.
74337:     mJSObject = nsnull;
74337: 
74337:     // Unroot.
74337:     RootJSObject(aCx, false);
74337: 
86428:     if (!TerminatePrivate(aCx, aFromJSFinalizer)) {
74337:       NS_WARNING("Failed to terminate!");
74337:     }
74337: 
74337:     events::EventTarget::FinalizeInstance(aCx);
74337:   }
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::Close(JSContext* aCx)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mParentStatus < Closing) {
74337:       mParentStatus = Closing;
74337:     }
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::ModifyBusyCount(JSContext* aCx, bool aIncrease)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   NS_ASSERTION(aIncrease || mBusyCount, "Mismatched busy count mods!");
74337: 
74337:   if (aIncrease) {
74337:     if (mBusyCount++ == 0) {
74337:       if (!RootJSObject(aCx, true)) {
74337:         return false;
74337:       }
74337:     }
74337:     return true;
74337:   }
74337: 
74337:   if (--mBusyCount == 0) {
74337:     if (!RootJSObject(aCx, false)) {
74337:       return false;
74337:     }
74337: 
74337:     bool shouldCancel;
74337:     {
74337:       MutexAutoLock lock(mMutex);
74337:       shouldCancel = mParentStatus == Terminating;
74337:     }
74337: 
74337:     if (shouldCancel && !Cancel(aCx)) {
74337:       return false;
74337:     }
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::RootJSObject(JSContext* aCx, bool aRoot)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   if (aRoot) {
74337:     if (mJSObjectRooted || !mJSObject) {
74337:       return true;
74337:     }
74337: 
74337:     if (!JS_AddNamedObjectRoot(aCx, &mJSObject, "Worker root")) {
74337:       NS_WARNING("JS_AddNamedObjectRoot failed!");
74337:       return false;
74337:     }
74337:   }
74337:   else {
74337:     if (!mJSObjectRooted) {
74337:       return true;
74337:     }
74337: 
74337:     if (!JS_RemoveObjectRoot(aCx, &mJSObject)) {
74337:       NS_WARNING("JS_RemoveObjectRoot failed!");
74337:       return false;
74337:     }
74337:   }
74337: 
74337:   mJSObjectRooted = aRoot;
74337:   return true;
74337: }
74337: 
74337: template <class Derived>
74337: void
74337: WorkerPrivateParent<Derived>::ForgetMainThreadObjects(
74337:                                       nsTArray<nsCOMPtr<nsISupports> >& aDoomed)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   aDoomed.SetCapacity(6);
74337: 
74337:   SwapToISupportsArray(mWindow, aDoomed);
74337:   SwapToISupportsArray(mScriptContext, aDoomed);
74337:   SwapToISupportsArray(mBaseURI, aDoomed);
74337:   SwapToISupportsArray(mScriptURI, aDoomed);
74337:   SwapToISupportsArray(mPrincipal, aDoomed);
74337:   SwapToISupportsArray(mDocument, aDoomed);
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::PostMessage(JSContext* aCx, jsval aMessage)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   JSStructuredCloneCallbacks* callbacks;
74337:   if (GetParent()) {
76372:     if (IsChromeWorker()) {
76372:       callbacks = &gChromeWorkerStructuredCloneCallbacks;
76372:     }
76372:     else {
76372:       callbacks = &gWorkerStructuredCloneCallbacks;
76372:     }
74337:   }
74337:   else {
74337:     AssertIsOnMainThread();
74337: 
74337:     if (IsChromeWorker()) {
74337:       callbacks = &gMainThreadChromeWorkerStructuredCloneCallbacks;
74337:     }
74337:     else {
74337:       callbacks = &gMainThreadWorkerStructuredCloneCallbacks;
74337:     }
74337:   }
74337: 
76372:   nsTArray<nsCOMPtr<nsISupports> > clonedObjects;
76372: 
74337:   JSAutoStructuredCloneBuffer buffer;
76372:   if (!buffer.write(aCx, aMessage, callbacks, &clonedObjects)) {
74337:     return false;
74337:   }
74337: 
74337:   nsRefPtr<MessageEventRunnable> runnable =
74337:     new MessageEventRunnable(ParentAsWorkerPrivate(),
76372:                              WorkerRunnable::WorkerThread, buffer,
76372:                              clonedObjects);
74337:   return runnable->Dispatch(aCx);
74337: }
74337: 
74337: template <class Derived>
74337: PRUint64
77330: WorkerPrivateParent<Derived>::GetInnerWindowId()
74337: {
74337:   AssertIsOnMainThread();
80426:   return mDocument ? mDocument->InnerWindowID() : 0;
74337: }
74337: 
74337: template <class Derived>
74337: void
74337: WorkerPrivateParent<Derived>::UpdateJSContextOptions(JSContext* aCx,
74337:                                                      PRUint32 aOptions)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   mJSContextOptions = aOptions;
74337: 
74337:   nsRefPtr<UpdateJSContextOptionsRunnable> runnable =
74337:     new UpdateJSContextOptionsRunnable(ParentAsWorkerPrivate(), aOptions);
74337:   if (!runnable->Dispatch(aCx)) {
74337:     NS_WARNING("Failed to update worker context options!");
74337:     JS_ClearPendingException(aCx);
74337:   }
74337: }
74337: 
86576: template <class Derived>
86576: void
86576: WorkerPrivateParent<Derived>::UpdateJSRuntimeHeapSize(JSContext* aCx,
86576:                                                       PRUint32 aMaxBytes)
86576: {
86576:   AssertIsOnParentThread();
86576: 
86576:   mJSRuntimeHeapSize = aMaxBytes;
86576: 
86576:   nsRefPtr<UpdateJSRuntimeHeapSizeRunnable> runnable =
86576:     new UpdateJSRuntimeHeapSizeRunnable(ParentAsWorkerPrivate(), aMaxBytes);
86576:   if (!runnable->Dispatch(aCx)) {
86576:     NS_WARNING("Failed to update worker heap size!");
86576:     JS_ClearPendingException(aCx);
86576:   }
86576: }
86576: 
74337: #ifdef JS_GC_ZEAL
74337: template <class Derived>
74337: void
74337: WorkerPrivateParent<Derived>::UpdateGCZeal(JSContext* aCx, PRUint8 aGCZeal)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   mGCZeal = aGCZeal;
74337: 
74337:   nsRefPtr<UpdateGCZealRunnable> runnable =
74337:     new UpdateGCZealRunnable(ParentAsWorkerPrivate(), aGCZeal);
74337:   if (!runnable->Dispatch(aCx)) {
74337:     NS_WARNING("Failed to update worker gczeal!");
74337:     JS_ClearPendingException(aCx);
74337:   }
74337: }
74337: #endif
74337: 
74337: template <class Derived>
81424: void
87588: WorkerPrivateParent<Derived>::GarbageCollect(JSContext* aCx, bool aShrinking)
87588: {
87588:   nsRefPtr<GarbageCollectRunnable> runnable =
87588:     new GarbageCollectRunnable(ParentAsWorkerPrivate(), aShrinking, true);
87588:   if (!runnable->Dispatch(aCx)) {
87588:     NS_WARNING("Failed to update worker heap size!");
87588:     JS_ClearPendingException(aCx);
87588:   }
87588: }
87588: 
87588: template <class Derived>
87588: void
74337: WorkerPrivateParent<Derived>::SetBaseURI(nsIURI* aBaseURI)
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   mBaseURI = aBaseURI;
74337: 
81424:   if (NS_FAILED(aBaseURI->GetSpec(mLocationInfo.mHref))) {
81424:     mLocationInfo.mHref.Truncate();
81424:   }
81424: 
81424:   if (NS_FAILED(aBaseURI->GetHost(mLocationInfo.mHostname))) {
81424:     mLocationInfo.mHostname.Truncate();
81424:   }
81424: 
81424:   if (NS_FAILED(aBaseURI->GetPath(mLocationInfo.mPathname))) {
81424:     mLocationInfo.mPathname.Truncate();
81424:   }
81424: 
81424:   nsCString temp;
81424: 
74337:   nsCOMPtr<nsIURL> url(do_QueryInterface(aBaseURI));
81424:   if (url && NS_SUCCEEDED(url->GetQuery(temp)) && !temp.IsEmpty()) {
74337:     mLocationInfo.mSearch.AssignLiteral("?");
74337:     mLocationInfo.mSearch.Append(temp);
74337:   }
74337: 
81424:   if (NS_SUCCEEDED(aBaseURI->GetRef(temp)) && !temp.IsEmpty()) {
81424:     nsCOMPtr<nsITextToSubURI> converter =
81424:       do_GetService(NS_ITEXTTOSUBURI_CONTRACTID);
81424:     if (converter) {
81424:       nsCString charset;
74337:       nsAutoString unicodeRef;
81424:       if (NS_SUCCEEDED(aBaseURI->GetOriginCharset(charset)) &&
81424:           NS_SUCCEEDED(converter->UnEscapeURIForUI(charset, temp,
81424:                                                    unicodeRef))) {
74337:         mLocationInfo.mHash.AssignLiteral("#");
74337:         mLocationInfo.mHash.Append(NS_ConvertUTF16toUTF8(unicodeRef));
74337:       }
74337:     }
81424: 
81424:     if (mLocationInfo.mHash.IsEmpty()) {
74337:       mLocationInfo.mHash.AssignLiteral("#");
74337:       mLocationInfo.mHash.Append(temp);
74337:     }
74337:   }
74337: 
81424:   if (NS_SUCCEEDED(aBaseURI->GetScheme(mLocationInfo.mProtocol))) {
74337:     mLocationInfo.mProtocol.AppendLiteral(":");
81424:   }
81424:   else {
81424:     mLocationInfo.mProtocol.Truncate();
81424:   }
74337: 
74337:   PRInt32 port;
81424:   if (NS_SUCCEEDED(aBaseURI->GetPort(&port)) && port != -1) {
74337:     mLocationInfo.mPort.AppendInt(port);
74337: 
74337:     nsCAutoString host(mLocationInfo.mHostname);
74337:     host.AppendLiteral(":");
74337:     host.Append(mLocationInfo.mPort);
74337: 
74337:     mLocationInfo.mHost.Assign(host);
74337:   }
74337:   else {
74337:     mLocationInfo.mHost.Assign(mLocationInfo.mHostname);
74337:   }
74337: }
74337: 
74337: template <class Derived>
76372: void
76372: WorkerPrivateParent<Derived>::SetPrincipal(nsIPrincipal* aPrincipal)
76372: {
76372:   AssertIsOnMainThread();
76372: 
76372:   mPrincipal = aPrincipal;
76372:   mPrincipalIsSystem = nsContentUtils::IsSystemPrincipal(aPrincipal);
76372: }
76372: 
76372: template <class Derived>
74337: JSContext*
74337: WorkerPrivateParent<Derived>::ParentJSContext() const
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   if (!mParent) {
74337:     AssertIsOnMainThread();
74337: 
74337:     if (!mScriptContext) {
74337:       NS_ASSERTION(!mParentJSContext, "Shouldn't have a parent context!");
74337:       return RuntimeService::AutoSafeJSContext::GetSafeContext();
74337:     }
74337: 
78415:     NS_ASSERTION(mParentJSContext == mScriptContext->GetNativeContext(),
74337:                  "Native context has changed!");
74337:   }
74337: 
74337:   return mParentJSContext;
74337: }
74337: 
74337: WorkerPrivate::WorkerPrivate(JSContext* aCx, JSObject* aObject,
74337:                              WorkerPrivate* aParent,
74337:                              JSContext* aParentJSContext,
74337:                              const nsAString& aScriptURL, bool aIsChromeWorker,
74337:                              const nsACString& aDomain,
74337:                              nsCOMPtr<nsPIDOMWindow>& aWindow,
74337:                              nsCOMPtr<nsIScriptContext>& aParentScriptContext,
74337:                              nsCOMPtr<nsIURI>& aBaseURI,
74337:                              nsCOMPtr<nsIPrincipal>& aPrincipal,
74337:                              nsCOMPtr<nsIDocument>& aDocument)
74337: : WorkerPrivateParent<WorkerPrivate>(aCx, aObject, aParent, aParentJSContext,
74337:                                      aScriptURL, aIsChromeWorker, aDomain,
74337:                                      aWindow, aParentScriptContext, aBaseURI,
74337:                                      aPrincipal, aDocument),
74337:   mJSContext(nsnull), mErrorHandlerRecursionCount(0), mNextTimeoutId(1),
74337:   mStatus(Pending), mSuspended(false), mTimerRunning(false),
74337:   mRunningExpiredTimeouts(false), mCloseHandlerStarted(false),
78275:   mCloseHandlerFinished(false), mMemoryReporterRunning(false),
78275:   mMemoryReporterDisabled(false)
74337: {
74337:   MOZ_COUNT_CTOR(mozilla::dom::workers::WorkerPrivate);
74337: }
74337: 
74337: WorkerPrivate::~WorkerPrivate()
74337: {
74337:   MOZ_COUNT_DTOR(mozilla::dom::workers::WorkerPrivate);
74337: }
74337: 
74337: // static
74337: WorkerPrivate*
74337: WorkerPrivate::Create(JSContext* aCx, JSObject* aObj, WorkerPrivate* aParent,
74337:                       JSString* aScriptURL, bool aIsChromeWorker)
74337: {
74337:   nsCString domain;
74337:   nsCOMPtr<nsIURI> baseURI;
74337:   nsCOMPtr<nsIPrincipal> principal;
74337:   nsCOMPtr<nsIScriptContext> scriptContext;
74337:   nsCOMPtr<nsIDocument> document;
74337:   nsCOMPtr<nsPIDOMWindow> window;
74337: 
74337:   JSContext* parentContext;
74337: 
74337:   if (aParent) {
74337:     aParent->AssertIsOnWorkerThread();
74337: 
74337:     parentContext = aCx;
74337: 
74337:     // Domain is the only thing we can touch here. The rest will be handled by
74337:     // the ScriptLoader.
74337:     domain = aParent->Domain();
74337:   }
74337:   else {
74337:     AssertIsOnMainThread();
74337: 
74337:     nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
74337:     NS_ASSERTION(ssm, "This should never be null!");
74337: 
79445:     bool isChrome;
74337:     if (NS_FAILED(ssm->IsCapabilityEnabled("UniversalXPConnect", &isChrome))) {
74337:       NS_WARNING("IsCapabilityEnabled failed!");
80486:       isChrome = false;
74337:     }
74337: 
74337:     // First check to make sure the caller has permission to make a
74337:     // ChromeWorker if they called the ChromeWorker constructor.
74337:     if (aIsChromeWorker && !isChrome) {
74337:       nsDOMClassInfo::ThrowJSException(aCx, NS_ERROR_DOM_SECURITY_ERR);
74337:       return nsnull;
74337:     }
74337: 
74337:     // Chrome callers (whether ChromeWorker of Worker) always get the system
74337:     // principal here as they're allowed to load anything. The script loader may
74337:     // change the principal later depending on the script uri.
74337:     if (isChrome &&
74337:         NS_FAILED(ssm->GetSystemPrincipal(getter_AddRefs(principal)))) {
74337:       JS_ReportError(aCx, "Could not get system principal!");
74337:       return nsnull;
74337:     }
74337: 
74337:     // See if we're being called from a window or from somewhere else.
74337:     nsCOMPtr<nsIScriptGlobalObject> scriptGlobal =
74337:       nsJSUtils::GetStaticScriptGlobal(aCx, JS_GetGlobalForScopeChain(aCx));
74337:     if (scriptGlobal) {
74337:       // Window!
74337:       nsCOMPtr<nsPIDOMWindow> globalWindow = do_QueryInterface(scriptGlobal);
74337: 
74337:       // Only use the current inner window, and only use it if the caller can
74337:       // access it.
74337:       nsPIDOMWindow* outerWindow = globalWindow ?
74337:                                    globalWindow->GetOuterWindow() :
74337:                                    nsnull;
74337:       window = outerWindow ? outerWindow->GetCurrentInnerWindow() : nsnull;
74337:       if (!window ||
74337:           (globalWindow != window &&
74337:            !nsContentUtils::CanCallerAccess(window))) {
74337:         nsDOMClassInfo::ThrowJSException(aCx, NS_ERROR_DOM_SECURITY_ERR);
74337:         return nsnull;
74337:       }
74337: 
74337:       scriptContext = scriptGlobal->GetContext();
74337:       if (!scriptContext) {
74337:         JS_ReportError(aCx, "Couldn't get script context for this worker!");
74337:         return nsnull;
74337:       }
74337: 
78415:       parentContext = scriptContext->GetNativeContext();
74337: 
74337:       // If we're called from a window then we can dig out the principal and URI
74337:       // from the document.
74337:       document = do_QueryInterface(window->GetExtantDocument());
74337:       if (!document) {
74337:         JS_ReportError(aCx, "No document in this window!");
74337:         return nsnull;
74337:       }
74337: 
74337:       baseURI = document->GetDocBaseURI();
74337: 
74337:       // Use the document's NodePrincipal as our principal if we're not being
74337:       // called from chrome.
74337:       if (!principal) {
74337:         if (!(principal = document->NodePrincipal())) {
74337:           JS_ReportError(aCx, "Could not get document principal!");
74337:           return nsnull;
74337:         }
74337: 
74337:         nsCOMPtr<nsIURI> codebase;
74337:         if (NS_FAILED(principal->GetURI(getter_AddRefs(codebase)))) {
74337:           JS_ReportError(aCx, "Could not determine codebase!");
74337:           return nsnull;
74337:         }
74337: 
74337:         NS_NAMED_LITERAL_CSTRING(file, "file");
74337: 
79445:         bool isFile;
74337:         if (NS_FAILED(codebase->SchemeIs(file.get(), &isFile))) {
74337:           JS_ReportError(aCx, "Could not determine if codebase is file!");
74337:           return nsnull;
74337:         }
74337: 
74337:         if (isFile) {
74337:           // XXX Fix this, need a real domain here.
74337:           domain = file;
74337:         }
74337:         else {
80360:           nsCOMPtr<mozIThirdPartyUtil> thirdPartyUtil =
80360:             do_GetService(THIRDPARTYUTIL_CONTRACTID);
80360:           if (!thirdPartyUtil) {
80360:             JS_ReportError(aCx, "Could not get third party helper service!");
74337:             return nsnull;
74337:           }
74337: 
80360:           if (NS_FAILED(thirdPartyUtil->GetBaseDomain(codebase, domain))) {
74337:             JS_ReportError(aCx, "Could not get domain!");
74337:             return nsnull;
74337:           }
74337:         }
74337:       }
74337:     }
74337:     else {
74337:       // Not a window
74337:       NS_ASSERTION(isChrome, "Should be chrome only!");
74337: 
74337:       parentContext = nsnull;
74337: 
74337:       // We're being created outside of a window. Need to figure out the script
74337:       // that is creating us in order for us to use relative URIs later on.
74337:       JSStackFrame* frame = JS_GetScriptedCaller(aCx, nsnull);
74337:       if (frame) {
74337:         JSScript* script = JS_GetFrameScript(aCx, frame);
74337:         if (!script) {
74337:           JS_ReportError(aCx, "Could not get frame script!");
74337:           return nsnull;
74337:         }
74337:         if (NS_FAILED(NS_NewURI(getter_AddRefs(baseURI),
74337:                                 JS_GetScriptFilename(aCx, script)))) {
74337:           JS_ReportError(aCx, "Failed to construct base URI!");
74337:           return nsnull;
74337:         }
74337:       }
74337:     }
74337: 
74337:     NS_ASSERTION(principal, "Must have a principal now!");
74337: 
74337:     if (!isChrome && domain.IsEmpty()) {
74337:       NS_ERROR("Must be chrome or have an domain!");
74337:       return nsnull;
74337:     }
74337:   }
74337: 
74337:   size_t urlLength;
74337:   const jschar* urlChars = JS_GetStringCharsZAndLength(aCx, aScriptURL,
74337:                                                        &urlLength);
74337:   if (!urlChars) {
74337:     return nsnull;
74337:   }
74337: 
74337:   nsDependentString scriptURL(urlChars, urlLength);
74337: 
74337:   nsAutoPtr<WorkerPrivate> worker(
74337:     new WorkerPrivate(aCx, aObj, aParent, parentContext, scriptURL,
74337:                       aIsChromeWorker, domain, window, scriptContext, baseURI,
74337:                       principal, document));
74337: 
74337:   nsRefPtr<CompileScriptRunnable> compiler = new CompileScriptRunnable(worker);
74337:   if (!compiler->Dispatch(aCx)) {
74337:     return nsnull;
74337:   }
74337: 
74337:   return worker.forget();
74337: }
74337: 
74337: void
74337: WorkerPrivate::DoRunLoop(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337:     mJSContext = aCx;
74337: 
74337:     NS_ASSERTION(mStatus == Pending, "Huh?!");
74337:     mStatus = Running;
74337:   }
74337: 
87588:   // We need a timer for GC. The basic plan is to run a normal (non-shrinking)
87588:   // GC periodically (NORMAL_GC_TIMER_DELAY_MS) while the worker is running.
87588:   // Once the worker goes idle we set a short (IDLE_GC_TIMER_DELAY_MS) timer to
87588:   // run a shrinking GC. If the worker receives more messages then the short
87588:   // timer is canceled and the periodic timer resumes.
87588:   nsCOMPtr<nsITimer> gcTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
87588:   if (!gcTimer) {
87588:     JS_ReportError(aCx, "Failed to create GC timer!");
87588:     return;
87588:   }
87588: 
87588:   bool normalGCTimerRunning = false;
87588: 
87588:   // We need to swap event targets below to get different types of GC behavior.
87588:   nsCOMPtr<nsIEventTarget> normalGCEventTarget;
87588:   nsCOMPtr<nsIEventTarget> idleGCEventTarget;
87588: 
87588:   // We also need to track the idle GC event so that we don't confuse it with a
87588:   // generic event that should re-trigger the idle GC timer.
87588:   nsCOMPtr<nsIRunnable> idleGCEvent;
87588:   {
87588:     nsRefPtr<GarbageCollectRunnable> runnable =
87588:       new GarbageCollectRunnable(this, false, false);
87588:     normalGCEventTarget = new WorkerRunnableEventTarget(runnable);
87588: 
87588:     runnable = new GarbageCollectRunnable(this, true, false);
87588:     idleGCEventTarget = new WorkerRunnableEventTarget(runnable);
87588: 
87588:     idleGCEvent = runnable;
87588:   }
87588: 
78275:   mMemoryReporter = new WorkerMemoryReporter(this);
78275: 
78275:   if (NS_FAILED(NS_RegisterMemoryMultiReporter(mMemoryReporter))) {
78275:     NS_WARNING("Failed to register memory reporter!");
78275:     mMemoryReporter = nsnull;
78275:   }
78275: 
74337:   for (;;) {
74337:     Status currentStatus;
87588:     bool scheduleIdleGC;
87588: 
88791:     WorkerRunnable* event;
74337:     {
74337:       MutexAutoLock lock(mMutex);
74337: 
74337:       while (!mControlQueue.Pop(event) && !mQueue.Pop(event)) {
74337:         mCondVar.Wait();
74337:       }
74337: 
87588:       bool eventIsNotIdleGCEvent;
87588:       currentStatus = mStatus;
87588: 
74337:       {
74337:         MutexAutoUnlock unlock(mMutex);
74337: 
87588:         if (!normalGCTimerRunning &&
87588:             event != idleGCEvent &&
87588:             currentStatus <= Terminating) {
87588:           // Must always cancel before changing the timer's target.
87588:           if (NS_FAILED(gcTimer->Cancel())) {
87588:             NS_WARNING("Failed to cancel GC timer!");
87588:           }
87588: 
87588:           if (NS_SUCCEEDED(gcTimer->SetTarget(normalGCEventTarget)) &&
87588:               NS_SUCCEEDED(gcTimer->InitWithFuncCallback(
87588:                                              DummyCallback, nsnull,
87588:                                              NORMAL_GC_TIMER_DELAY_MS,
87588:                                              nsITimer::TYPE_REPEATING_SLACK))) {
87588:             normalGCTimerRunning = true;
87588:           }
87588:           else {
87588:             JS_ReportError(aCx, "Failed to start normal GC timer!");
87588:           }
87588:         }
87588: 
74337: #ifdef EXTRA_GC
74337:         // Find GC bugs...
74337:         JS_GC(aCx);
74337: #endif
74337: 
87588:         // Keep track of whether or not this is the idle GC event.
87588:         eventIsNotIdleGCEvent = event != idleGCEvent;
87588: 
88791:         static_cast<nsIRunnable*>(event)->Run();
74337:         NS_RELEASE(event);
74337:       }
74337: 
74337:       currentStatus = mStatus;
87588:       scheduleIdleGC = mControlQueue.IsEmpty() &&
87588:                        mQueue.IsEmpty() &&
87588:                        eventIsNotIdleGCEvent;
87588:     }
87588: 
87588:     // Take care of the GC timer. If we're starting the close sequence then we
87588:     // kill the timer once and for all. Otherwise we schedule the idle timeout
87588:     // if there are no more events.
87588:     if (currentStatus > Terminating || scheduleIdleGC) {
87588:       if (NS_SUCCEEDED(gcTimer->Cancel())) {
87588:         normalGCTimerRunning = false;
87588:       }
87588:       else {
87588:         NS_WARNING("Failed to cancel GC timer!");
87588:       }
87588:     }
87588: 
87588:     if (scheduleIdleGC) {
87588:       if (NS_SUCCEEDED(gcTimer->SetTarget(idleGCEventTarget)) &&
87588:           NS_SUCCEEDED(gcTimer->InitWithFuncCallback(
87588:                                                     DummyCallback, nsnull,
87588:                                                     IDLE_GC_TIMER_DELAY_MS,
87588:                                                     nsITimer::TYPE_ONE_SHOT))) {
87588:       }
87588:       else {
87588:         JS_ReportError(aCx, "Failed to start idle GC timer!");
87588:       }
74337:     }
74337: 
74337: #ifdef EXTRA_GC
74337:     // Find GC bugs...
74337:     JS_GC(aCx);
74337: #endif
74337: 
74337:     if (currentStatus != Running && !HasActiveFeatures()) {
74337:       // If the close handler has finished and all features are done then we can
74337:       // kill this thread.
74337:       if (mCloseHandlerFinished && currentStatus != Killing) {
74337:         if (!NotifyInternal(aCx, Killing)) {
74337:           JS_ReportPendingException(aCx);
74337:         }
74337: #ifdef DEBUG
74337:         {
74337:           MutexAutoLock lock(mMutex);
74337:           currentStatus = mStatus;
74337:         }
74337:         NS_ASSERTION(currentStatus == Killing, "Should have changed status!");
74337: #else
74337:         currentStatus = Killing;
74337: #endif
74337:       }
74337: 
74337:       // If we're supposed to die then we should exit the loop.
74337:       if (currentStatus == Killing) {
87588:         // Always make sure the timer is canceled.
87588:         if (NS_FAILED(gcTimer->Cancel())) {
87588:           NS_WARNING("Failed to cancel the GC timer!");
87588:         }
87588: 
78275:         // Call this before unregistering the reporter as we may be racing with
78275:         // the main thread.
78275:         DisableMemoryReporter();
78275: 
78275:         if (mMemoryReporter) {
78275:           if (NS_FAILED(NS_UnregisterMemoryMultiReporter(mMemoryReporter))) {
78275:             NS_WARNING("Failed to unregister memory reporter!");
78275:           }
78275:           mMemoryReporter = nsnull;
78275:         }
78275: 
74337:         StopAcceptingEvents();
74337:         return;
74337:       }
74337:     }
74337:   }
74337: 
74337:   NS_NOTREACHED("Shouldn't get here!");
74337: }
74337: 
74337: bool
74337: WorkerPrivate::OperationCallback(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   bool mayContinue = true;
74337: 
74337:   for (;;) {
74337:     // Run all control events now.
78275:     mayContinue = ProcessAllControlRunnables();
78275: 
78275:     if (!mayContinue || !mSuspended) {
78275:       break;
78275:     }
78275: 
78275:     // Clean up before suspending.
78275:     JS_FlushCaches(aCx);
78275:     JS_GC(aCx);
78275: 
78275:     while ((mayContinue = MayContinueRunning())) {
78275:       MutexAutoLock lock(mMutex);
78275:       if (!mControlQueue.IsEmpty()) {
78275:         break;
78275:       }
78275: 
78275:       mCondVar.Wait(PR_MillisecondsToInterval(RemainingRunTimeMS()));
78275:     }
78275:   }
78275: 
78275:   if (!mayContinue) {
78275:     // We want only uncatchable exceptions here.
78275:     NS_ASSERTION(!JS_IsExceptionPending(aCx),
78275:                  "Should not have an exception set here!");
78275:     return false;
78275:   }
78275: 
78275:   return true;
78275: }
78275: 
78275: void
78275: WorkerPrivate::ScheduleDeletion(bool aWasPending)
78275: {
78275:   AssertIsOnWorkerThread();
78275:   NS_ASSERTION(mChildWorkers.IsEmpty(), "Live child workers!");
78275:   NS_ASSERTION(mSyncQueues.IsEmpty(), "Should have no sync queues here!");
78275: 
78275:   StopAcceptingEvents();
78275: 
78275:   nsIThread* currentThread;
78275:   if (aWasPending) {
78275:     // Don't want to close down this thread since we never got to run!
78275:     currentThread = nsnull;
78275:   }
78275:   else {
78275:     currentThread = NS_GetCurrentThread();
78275:     NS_ASSERTION(currentThread, "This should never be null!");
78275:   }
78275: 
78275:   WorkerPrivate* parent = GetParent();
78275:   if (parent) {
78275:     nsRefPtr<WorkerFinishedRunnable> runnable =
78275:       new WorkerFinishedRunnable(parent, this, currentThread);
78275:     if (!runnable->Dispatch(nsnull)) {
78275:       NS_WARNING("Failed to dispatch runnable!");
78275:     }
78275:   }
78275:   else {
78275:     nsRefPtr<TopLevelWorkerFinishedRunnable> runnable =
78275:       new TopLevelWorkerFinishedRunnable(this, currentThread);
78275:     if (NS_FAILED(NS_DispatchToMainThread(runnable, NS_DISPATCH_NORMAL))) {
78275:       NS_WARNING("Failed to dispatch runnable!");
78275:     }
78275:   }
78275: }
78275: 
78275: bool
86388: WorkerPrivate::BlockAndCollectRuntimeStats(bool aIsQuick, void* aData, bool* aDisabled)
78275: {
78275:   AssertIsOnMainThread();
78275:   NS_ASSERTION(aData, "Null data!");
78275: 
78275:   {
78275:     MutexAutoLock lock(mMutex);
78275: 
78275:     if (mMemoryReporterDisabled) {
78275:       *aDisabled = true;
78275:       return true;
78275:     }
78275: 
78275:     *aDisabled = false;
78275:     mMemoryReporterRunning = true;
78275:   }
78275: 
78275:   bool succeeded;
78275: 
78275:   nsRefPtr<CollectRuntimeStatsRunnable> runnable =
86388:     new CollectRuntimeStatsRunnable(this, aIsQuick, aData, &succeeded);
78275:   if (!runnable->Dispatch(nsnull)) {
78275:     NS_WARNING("Failed to dispatch runnable!");
78275:     succeeded = false;
78275:   }
78275: 
78275:   {
78275:     MutexAutoLock lock(mMutex);
78275:     mMemoryReporterRunning = false;
78275:   }
78275: 
78275:   return succeeded;
78275: }
78275: 
78275: bool
78275: WorkerPrivate::DisableMemoryReporter()
78275: {
78275:   AssertIsOnWorkerThread();
78275: 
78275:   bool result = true;
78275: 
78275:   {
78275:     MutexAutoLock lock(mMutex);
78275: 
78275:     mMemoryReporterDisabled = true;
78275: 
78275:     while (mMemoryReporterRunning) {
78275:       MutexAutoUnlock unlock(mMutex);
78275:       result = ProcessAllControlRunnables() && result;
78275:     }
78275:   }
78275: 
78275:   return result;
78275: }
78275: 
78275: bool
78275: WorkerPrivate::ProcessAllControlRunnables()
78275: {
78275:   AssertIsOnWorkerThread();
78275: 
78275:   bool result = true;
78275: 
78117:   for (;;) {
88791:     WorkerRunnable* event;
78117:     {
78117:       MutexAutoLock lock(mMutex);
78117:       if (!mControlQueue.Pop(event)) {
78117:         break;
78117:       }
78117:     }
78117: 
88791:     if (NS_FAILED(static_cast<nsIRunnable*>(event)->Run())) {
78275:       result = false;
78117:     }
78117: 
78117:     NS_RELEASE(event);
78117:   }
78275:   return result;
78107: }
78107: 
78107: bool
74337: WorkerPrivate::Dispatch(WorkerRunnable* aEvent, EventQueue* aQueue)
74337: {
74337:   nsRefPtr<WorkerRunnable> event(aEvent);
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mStatus == Dead) {
74337:       // Nothing may be added after we've set Dead.
74337:       return false;
74337:     }
74337: 
74337:     if (aQueue == &mQueue) {
74337:       // Check parent status.
74337:       Status parentStatus = ParentStatus();
74337:       if (parentStatus >= Terminating) {
74337:         // Throw.
74337:         return false;
74337:       }
74337: 
74337:       // Check inner status too.
74337:       if (parentStatus >= Closing || mStatus >= Closing) {
74337:         // Silently eat this one.
74337:         return true;
74337:       }
74337:     }
74337: 
74337:     if (!aQueue->Push(event)) {
74337:       return false;
74337:     }
74337: 
74337:     if (aQueue == &mControlQueue && mJSContext) {
74337:       JS_TriggerOperationCallback(mJSContext);
74337:     }
74337: 
74337:     mCondVar.Notify();
74337:   }
74337: 
74337:   event.forget();
74337:   return true;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::DispatchToSyncQueue(WorkerSyncRunnable* aEvent)
74337: {
74337:   nsRefPtr<WorkerRunnable> event(aEvent);
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     NS_ASSERTION(mSyncQueues.Length() > aEvent->mSyncQueueKey, "Bad event!");
74337: 
74337:     if (!mSyncQueues[aEvent->mSyncQueueKey]->mQueue.Push(event)) {
74337:       return false;
74337:     }
74337: 
74337:     mCondVar.Notify();
74337:   }
74337: 
74337:   event.forget();
74337:   return true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::ClearQueue(EventQueue* aQueue)
74337: {
74337:   AssertIsOnWorkerThread();
74337:   mMutex.AssertCurrentThreadOwns();
74337: 
88791:   WorkerRunnable* event;
74337:   while (aQueue->Pop(event)) {
88791:     if (event->WantsToRunDuringClear()) {
88791:       MutexAutoUnlock unlock(mMutex);
88791: 
88791:       static_cast<nsIRunnable*>(event)->Run();
88791:     }
74337:     event->Release();
74337:   }
74337: }
74337: 
74337: PRUint32
74337: WorkerPrivate::RemainingRunTimeMS() const
74337: {
74337:   if (mKillTime.IsNull()) {
74337:     return PR_UINT32_MAX;
74337:   }
74337:   TimeDuration runtime = mKillTime - TimeStamp::Now();
74337:   double ms = runtime > TimeDuration(0) ? runtime.ToMilliseconds() : 0;
74337:   return ms > double(PR_UINT32_MAX) ? PR_UINT32_MAX : PRUint32(ms);
74337: }
74337: 
74337: bool
74337: WorkerPrivate::SuspendInternal(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(!mSuspended, "Already suspended!");
74337: 
74337:   mSuspended = true;
74337:   return true;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::ResumeInternal(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(mSuspended, "Not yet suspended!");
74337: 
74337:   mSuspended = false;
74337:   return true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::TraceInternal(JSTracer* aTrc)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   for (PRUint32 index = 0; index < mTimeouts.Length(); index++) {
74337:     TimeoutInfo* info = mTimeouts[index];
74337:     JS_CALL_VALUE_TRACER(aTrc, info->mTimeoutVal,
74337:                          "WorkerPrivate timeout value");
74337:     for (PRUint32 index2 = 0; index2 < info->mExtraArgVals.Length(); index2++) {
74337:       JS_CALL_VALUE_TRACER(aTrc, info->mExtraArgVals[index2],
74337:                            "WorkerPrivate timeout extra argument value");
74337:     }
74337:   }
74337: }
74337: 
74337: bool
74337: WorkerPrivate::ModifyBusyCountFromWorker(JSContext* aCx, bool aIncrease)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     // If we're in shutdown then the busy count is no longer being considered so
74337:     // just return now.
74337:     if (mStatus >= Killing) {
74337:       return true;
74337:     }
74337:   }
74337: 
74337:   nsRefPtr<ModifyBusyCountRunnable> runnable =
74337:     new ModifyBusyCountRunnable(this, aIncrease);
74337:   return runnable->Dispatch(aCx);
74337: }
74337: 
74337: bool
74337: WorkerPrivate::AddChildWorker(JSContext* aCx, ParentType* aChildWorker)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   Status currentStatus;
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337:     currentStatus = mStatus;
74337:   }
74337: 
74337:   if (currentStatus > Running) {
74337:     JS_ReportError(aCx, "Cannot create child workers from the close handler!");
74337:     return false;
74337:   }
74337: 
74337:   NS_ASSERTION(!mChildWorkers.Contains(aChildWorker),
74337:                "Already know about this one!");
74337:   mChildWorkers.AppendElement(aChildWorker);
74337: 
74337:   return mChildWorkers.Length() == 1 ?
74337:          ModifyBusyCountFromWorker(aCx, true) :
74337:          true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::RemoveChildWorker(JSContext* aCx, ParentType* aChildWorker)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(mChildWorkers.Contains(aChildWorker),
74337:                "Didn't know about this one!");
74337:   mChildWorkers.RemoveElement(aChildWorker);
74337: 
74337:   if (mChildWorkers.IsEmpty() && !ModifyBusyCountFromWorker(aCx, false)) {
74337:     NS_WARNING("Failed to modify busy count!");
74337:   }
74337: }
74337: 
74337: bool
74337: WorkerPrivate::AddFeature(JSContext* aCx, WorkerFeature* aFeature)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mStatus >= Canceling) {
74337:       return false;
74337:     }
74337:   }
74337: 
74337:   NS_ASSERTION(!mFeatures.Contains(aFeature), "Already know about this one!");
74337:   mFeatures.AppendElement(aFeature);
74337: 
74337:   return mFeatures.Length() == 1 ?
74337:          ModifyBusyCountFromWorker(aCx, true) :
74337:          true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::RemoveFeature(JSContext* aCx, WorkerFeature* aFeature)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(mFeatures.Contains(aFeature), "Didn't know about this one!");
74337:   mFeatures.RemoveElement(aFeature);
74337: 
74337:   if (mFeatures.IsEmpty() && !ModifyBusyCountFromWorker(aCx, false)) {
74337:     NS_WARNING("Failed to modify busy count!");
74337:   }
74337: }
74337: 
74337: void
74337: WorkerPrivate::NotifyFeatures(JSContext* aCx, Status aStatus)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(aStatus > Running, "Bad status!");
74337: 
74337:   if (aStatus >= Closing) {
74337:     CancelAllTimeouts(aCx);
74337:   }
74337: 
74337:   nsAutoTArray<WorkerFeature*, 30> features;
74337:   features.AppendElements(mFeatures);
74337: 
74337:   for (PRUint32 index = 0; index < features.Length(); index++) {
74337:     if (!features[index]->Notify(aCx, aStatus)) {
74337:       NS_WARNING("Failed to notify feature!");
74337:     }
74337:   }
74337: 
74337:   nsAutoTArray<ParentType*, 10> children;
74337:   children.AppendElements(mChildWorkers);
74337: 
74337:   for (PRUint32 index = 0; index < children.Length(); index++) {
74337:     if (!children[index]->Notify(aCx, aStatus)) {
74337:       NS_WARNING("Failed to notify child worker!");
74337:     }
74337:   }
74337: }
74337: 
74337: void
74337: WorkerPrivate::CancelAllTimeouts(JSContext* aCx)
74337: {
89017:   AssertIsOnWorkerThread();
89017: 
74337:   if (mTimerRunning) {
74337:     NS_ASSERTION(mTimer, "Huh?!");
74337:     NS_ASSERTION(!mTimeouts.IsEmpty(), "Huh?!");
74337: 
74337:     if (NS_FAILED(mTimer->Cancel())) {
74337:       NS_WARNING("Failed to cancel timer!");
74337:     }
74337: 
74337:     for (PRUint32 index = 0; index < mTimeouts.Length(); index++) {
74337:       mTimeouts[index]->mCanceled = true;
74337:     }
74337: 
89017:     if (!RunExpiredTimeouts(aCx)) {
89017:       JS_ReportPendingException(aCx);
89017:     }
89017: 
89017:     mTimerRunning = false;
89017:   }
89017: #ifdef DEBUG
89017:   else if (!mRunningExpiredTimeouts) {
89017:     NS_ASSERTION(mTimeouts.IsEmpty(), "Huh?!");
89017:   }
89017: #endif
74337: 
74337:   mTimer = nsnull;
74337: }
74337: 
74337: PRUint32
74337: WorkerPrivate::CreateNewSyncLoop()
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(mSyncQueues.Length() < PR_UINT32_MAX,
74337:                "Should have bailed by now!");
74337: 
74337:   mSyncQueues.AppendElement(new SyncQueue());
74337:   return mSyncQueues.Length() - 1;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::RunSyncLoop(JSContext* aCx, PRUint32 aSyncLoopKey)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(!mSyncQueues.IsEmpty() ||
74337:                (aSyncLoopKey != mSyncQueues.Length() - 1),
74337:                "Forgot to call CreateNewSyncLoop!");
74337:   if (aSyncLoopKey != mSyncQueues.Length() - 1) {
74337:     return false;
74337:   }
74337: 
74337:   SyncQueue* syncQueue = mSyncQueues[aSyncLoopKey].get();
74337: 
74337:   for (;;) {
88791:     WorkerRunnable* event;
74337:     {
74337:       MutexAutoLock lock(mMutex);
74337: 
74337:       while (!mControlQueue.Pop(event) && !syncQueue->mQueue.Pop(event)) {
74337:         mCondVar.Wait();
74337:       }
74337:     }
74337: 
74337: #ifdef EXTRA_GC
74337:     // Find GC bugs...
74337:     JS_GC(mJSContext);
74337: #endif
74337: 
88791:     static_cast<nsIRunnable*>(event)->Run();
74337:     NS_RELEASE(event);
74337: 
74337: #ifdef EXTRA_GC
74337:     // Find GC bugs...
74337:     JS_GC(mJSContext);
74337: #endif
74337: 
74337:     if (syncQueue->mComplete) {
74337:       NS_ASSERTION(mSyncQueues.Length() - 1 == aSyncLoopKey,
74337:                    "Mismatched calls!");
74337:       NS_ASSERTION(syncQueue->mQueue.IsEmpty(), "Unprocessed sync events!");
74337: 
74337:       bool result = syncQueue->mResult;
74337:       mSyncQueues.RemoveElementAt(aSyncLoopKey);
74337: 
74337: #ifdef DEBUG
74337:       syncQueue = nsnull;
74337: #endif
74337: 
74337:       return result;
74337:     }
74337:   }
74337: 
74337:   NS_NOTREACHED("Shouldn't get here!");
74337:   return false;
74337: }
74337: 
74337: void
74337: WorkerPrivate::StopSyncLoop(PRUint32 aSyncLoopKey, bool aSyncResult)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(mSyncQueues.IsEmpty() ||
74337:                (aSyncLoopKey == mSyncQueues.Length() - 1),
74337:                "Forgot to call CreateNewSyncLoop!");
74337:   if (aSyncLoopKey != mSyncQueues.Length() - 1) {
74337:     return;
74337:   }
74337: 
74337:   SyncQueue* syncQueue = mSyncQueues[aSyncLoopKey].get();
74337: 
74337:   NS_ASSERTION(!syncQueue->mComplete, "Already called StopSyncLoop?!");
74337: 
74337:   syncQueue->mResult = aSyncResult;
74337:   syncQueue->mComplete = true;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::PostMessageToParent(JSContext* aCx, jsval aMessage)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
76372:   JSStructuredCloneCallbacks* callbacks =
76372:     IsChromeWorker() ?
76372:     &gChromeWorkerStructuredCloneCallbacks :
76372:     &gWorkerStructuredCloneCallbacks;
76372: 
76372:   nsTArray<nsCOMPtr<nsISupports> > clonedObjects;
76372: 
74337:   JSAutoStructuredCloneBuffer buffer;
76372:   if (!buffer.write(aCx, aMessage, callbacks, &clonedObjects)) {
74337:     return false;
74337:   }
74337: 
74337:   nsRefPtr<MessageEventRunnable> runnable =
76372:     new MessageEventRunnable(this, WorkerRunnable::ParentThread, buffer,
76372:                              clonedObjects);
74337:   return runnable->Dispatch(aCx);
74337: }
74337: 
74337: bool
74337: WorkerPrivate::NotifyInternal(JSContext* aCx, Status aStatus)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(aStatus > Running && aStatus < Dead, "Bad status!");
74337: 
74337:   // Save the old status and set the new status.
74337:   Status previousStatus;
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mStatus >= aStatus) {
74337:       return true;
74337:     }
74337: 
74337:     previousStatus = mStatus;
74337:     mStatus = aStatus;
74337:   }
74337: 
83422:   // Now that status > Running, no-one can create a new mCrossThreadDispatcher
83422:   // if we don't already have one.
83422:   if (mCrossThreadDispatcher) {
83422:     // Since we'll no longer process events, make sure we no longer allow
83422:     // anyone to post them.
83422:     // We have to do this without mMutex held, since our mutex must be
83422:     // acquired *after* mCrossThreadDispatcher's mutex when they're both held.
83422:     mCrossThreadDispatcher->Forget();
83422:   }
83422: 
74337:   NS_ASSERTION(previousStatus != Pending, "How is this possible?!");
74337: 
74337:   NS_ASSERTION(previousStatus >= Canceling || mKillTime.IsNull(),
74337:                "Bad kill time set!");
74337: 
74337:   // Let all our features know the new status.
74337:   NotifyFeatures(aCx, aStatus);
74337: 
74337:   // There's nothing to do here if we never succeeded in running the worker
74337:   // script or if the close handler has already run.
74337:   if (!JS_GetGlobalObject(aCx) || mCloseHandlerFinished) {
74337:     return true;
74337:   }
74337: 
74337:   // If this is the first time our status has changed then we need to clear the
74337:   // main event queue. We also need to schedule the close handler unless we're
74337:   // being shut down.
74337:   if (previousStatus == Running) {
74337:     NS_ASSERTION(!mCloseHandlerStarted && !mCloseHandlerFinished,
74337:                  "This is impossible!");
74337: 
74337:     {
74337:       MutexAutoLock lock(mMutex);
74337:       ClearQueue(&mQueue);
74337:     }
74337: 
74337:     if (aStatus != Killing) {
74337:       nsRefPtr<CloseEventRunnable> closeRunnable = new CloseEventRunnable(this);
74337: 
74337:       MutexAutoLock lock(mMutex);
74337: 
74337:       if (!mQueue.Push(closeRunnable)) {
74337:         NS_WARNING("Failed to push closeRunnable!");
74337:         return false;
74337:       }
74337: 
74337:       closeRunnable.forget();
74337:     }
74337:   }
74337: 
74337:   if (aStatus == Closing) {
74337:     // Notify parent to stop sending us messages and balance our busy count.
74337:     nsRefPtr<CloseRunnable> runnable = new CloseRunnable(this);
74337:     if (!runnable->Dispatch(aCx)) {
74337:       return false;
74337:     }
74337: 
74337:     // Don't abort the script.
74337:     return true;
74337:   }
74337: 
74337:   if (aStatus == Terminating) {
74337:     // Only abort the script if we're not yet running the close handler.
74337:     return mCloseHandlerStarted;
74337:   }
74337: 
74337:   if (aStatus == Canceling) {
74337:     // We need to enforce a timeout on the close handler.
74337:     NS_ASSERTION(previousStatus == Running || previousStatus == Closing ||
74337:                  previousStatus == Terminating,
74337:                  "Bad previous status!");
74337: 
74337:     PRUint32 killSeconds = RuntimeService::GetCloseHandlerTimeoutSeconds();
74337:     if (killSeconds) {
74337:       mKillTime = TimeStamp::Now() + TimeDuration::FromSeconds(killSeconds);
74337: 
74337:       if (!mCloseHandlerFinished && !ScheduleKillCloseEventRunnable(aCx)) {
74337:         return false;
74337:       }
74337:     }
74337: 
74337:     // Only abort the script if we're not yet running the close handler.
74337:     return mCloseHandlerStarted;
74337:   }
74337: 
74337:   if (aStatus == Killing) {
74337:     mKillTime = TimeStamp::Now();
74337: 
74337:     if (!mCloseHandlerFinished && !ScheduleKillCloseEventRunnable(aCx)) {
74337:       return false;
74337:     }
74337: 
74337:     // Always abort the script.
74337:     return false;
74337:   }
74337: 
74337:   NS_NOTREACHED("Should never get here!");
74337:   return false;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::ScheduleKillCloseEventRunnable(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337:   NS_ASSERTION(!mKillTime.IsNull(), "Must have a kill time!");
74337: 
74337:   nsRefPtr<KillCloseEventRunnable> killCloseEventRunnable =
74337:     new KillCloseEventRunnable(this);
74337:   if (!killCloseEventRunnable->SetTimeout(aCx, RemainingRunTimeMS())) {
74337:     return false;
74337:   }
74337: 
74337:   MutexAutoLock lock(mMutex);
74337: 
74337:   if (!mQueue.Push(killCloseEventRunnable)) {
74337:     NS_WARNING("Failed to push killCloseEventRunnable!");
74337:     return false;
74337:   }
74337: 
74337:   killCloseEventRunnable.forget();
74337:   return true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::ReportError(JSContext* aCx, const char* aMessage,
74337:                            JSErrorReport* aReport)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   if (!MayContinueRunning() || mErrorHandlerRecursionCount == 2) {
74337:     return;
74337:   }
74337: 
74337:   NS_ASSERTION(mErrorHandlerRecursionCount == 0 ||
74337:                mErrorHandlerRecursionCount == 1,
74337:                "Bad recursion logic!");
74337: 
74337:   JS_ClearPendingException(aCx);
74337: 
74337:   nsString message, filename, line;
74337:   PRUint32 lineNumber, columnNumber, flags, errorNumber;
74337: 
74337:   if (aReport) {
74337:     if (aReport->ucmessage) {
74337:       message = aReport->ucmessage;
74337:     }
74337:     filename = NS_ConvertUTF8toUTF16(aReport->filename);
74337:     line = aReport->uclinebuf;
74337:     lineNumber = aReport->lineno;
74337:     columnNumber = aReport->uctokenptr - aReport->uclinebuf;
74337:     flags = aReport->flags;
74337:     errorNumber = aReport->errorNumber;
74337:   }
74337:   else {
74337:     lineNumber = columnNumber = errorNumber = 0;
74337:     flags = nsIScriptError::errorFlag | nsIScriptError::exceptionFlag;
74337:   }
74337: 
74337:   if (message.IsEmpty()) {
74337:     message = NS_ConvertUTF8toUTF16(aMessage);
74337:   }
74337: 
74337:   mErrorHandlerRecursionCount++;
74337: 
74337:   // Don't want to run the scope's error handler if this is a recursive error or
86576:   // if there was an error in the close handler or if we ran out of memory.
74337:   bool fireAtScope = mErrorHandlerRecursionCount == 1 &&
86576:                      !mCloseHandlerStarted &&
86576:                      errorNumber != JSMSG_OUT_OF_MEMORY;
74337: 
74337:   if (!ReportErrorRunnable::ReportError(aCx, this, fireAtScope, nsnull, message,
74337:                                         filename, line, lineNumber,
74337:                                         columnNumber, flags, errorNumber, 0)) {
74337:     JS_ReportPendingException(aCx);
74337:   }
74337: 
74337:   mErrorHandlerRecursionCount--;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::SetTimeout(JSContext* aCx, uintN aArgc, jsval* aVp,
74337:                           bool aIsInterval)
74337: {
74337:   AssertIsOnWorkerThread();
74337:   NS_ASSERTION(aArgc, "Huh?!");
74337: 
74337:   const PRUint32 timerId = mNextTimeoutId++;
74337: 
74337:   Status currentStatus;
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337:     currentStatus = mStatus;
74337:   }
74337: 
89017:   // It's a script bug if setTimeout/setInterval are called from a close handler
89017:   // so throw an exception.
89017:   if (currentStatus == Closing) {
74337:     JS_ReportError(aCx, "Cannot schedule timeouts from the close handler!");
89017:   }
89017: 
89017:   // If the worker is trying to call setTimeout/setInterval and the parent
89017:   // thread has initiated the close process then just silently fail.
89017:   if (currentStatus >= Closing) {
74337:     return false;
74337:   }
74337: 
74337:   nsAutoPtr<TimeoutInfo> newInfo(new TimeoutInfo());
74337:   newInfo->mIsInterval = aIsInterval;
74337:   newInfo->mId = timerId;
74337: 
74337:   if (NS_UNLIKELY(timerId == PR_UINT32_MAX)) {
74337:     NS_WARNING("Timeout ids overflowed!");
74337:     mNextTimeoutId = 1;
74337:   }
74337: 
74337:   jsval* argv = JS_ARGV(aCx, aVp);
74337: 
74337:   // Take care of the main argument.
74337:   if (JSVAL_IS_OBJECT(argv[0])) {
74337:     if (JS_ObjectIsCallable(aCx, JSVAL_TO_OBJECT(argv[0]))) {
74337:       newInfo->mTimeoutVal = argv[0];
74337:     }
74337:     else {
74337:       JSString* timeoutStr = JS_ValueToString(aCx, argv[0]);
74337:       if (!timeoutStr) {
74337:         return false;
74337:       }
74337:       newInfo->mTimeoutVal = STRING_TO_JSVAL(timeoutStr);
74337:     }
74337:   }
74337:   else if (JSVAL_IS_STRING(argv[0])) {
74337:     newInfo->mTimeoutVal = argv[0];
74337:   }
74337:   else {
74337:     JS_ReportError(aCx, "Useless %s call (missing quotes around argument?)",
74337:                    aIsInterval ? "setInterval" : "setTimeout");
74337:     return false;
74337:   }
74337: 
74337:   // See if any of the optional arguments were passed.
74337:   if (aArgc > 1) {
74337:     jsdouble intervalMS = 0;
74337:     if (!JS_ValueToNumber(aCx, argv[1], &intervalMS)) {
74337:       return false;
74337:     }
74337:     newInfo->mInterval = TimeDuration::FromMilliseconds(intervalMS);
74337: 
74337:     if (aArgc > 2 && JSVAL_IS_OBJECT(newInfo->mTimeoutVal)) {
74337:       nsTArray<jsval> extraArgVals(aArgc - 2);
74337:       for (uintN index = 2; index < aArgc; index++) {
74337:         extraArgVals.AppendElement(argv[index]);
74337:       }
74337:       newInfo->mExtraArgVals.SwapElements(extraArgVals);
74337:     }
74337:   }
74337: 
74337:   newInfo->mTargetTime = TimeStamp::Now() + newInfo->mInterval;
74337: 
74337:   if (JSVAL_IS_STRING(newInfo->mTimeoutVal)) {
74337:     const char* filenameChars;
74337:     PRUint32 lineNumber;
74337:     if (nsJSUtils::GetCallingLocation(aCx, &filenameChars, &lineNumber)) {
74337:       newInfo->mFilename = filenameChars;
74337:       newInfo->mLineNumber = lineNumber;
74337:     }
74337:     else {
74337:       NS_WARNING("Failed to get calling location!");
74337:     }
74337:   }
74337: 
74337:   mTimeouts.InsertElementSorted(newInfo.get(), GetAutoPtrComparator(mTimeouts));
74337: 
74337:   // If the timeout we just made is set to fire next then we need to update the
74337:   // timer.
74337:   if (mTimeouts[0] == newInfo) {
74337:     nsresult rv;
74337: 
74337:     if (!mTimer) {
74337:       mTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &rv);
74337:       if (NS_FAILED(rv)) {
74337:         JS_ReportError(aCx, "Failed to create timer!");
74337:         return false;
74337:       }
74337: 
74337:       nsRefPtr<TimerRunnable> timerRunnable = new TimerRunnable(this);
74337: 
74337:       nsCOMPtr<nsIEventTarget> target =
74337:         new WorkerRunnableEventTarget(timerRunnable);
74337:       rv = mTimer->SetTarget(target);
74337:       if (NS_FAILED(rv)) {
74337:         JS_ReportError(aCx, "Failed to set timer's target!");
74337:         return false;
74337:       }
74337:     }
74337: 
74337:     if (!mTimerRunning) {
74337:       if (!ModifyBusyCountFromWorker(aCx, true)) {
74337:         return false;
74337:       }
74337:       mTimerRunning = true;
74337:     }
74337: 
74337:     if (!RescheduleTimeoutTimer(aCx)) {
74337:       return false;
74337:     }
74337:   }
74337: 
74337:   JS_SET_RVAL(aCx, aVp, INT_TO_JSVAL(timerId));
74337: 
74337:   newInfo.forget();
74337:   return true;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::ClearTimeout(JSContext* aCx, uint32 aId)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   if (!mTimeouts.IsEmpty()) {
74337:     NS_ASSERTION(mTimerRunning, "Huh?!");
74337: 
74337:     for (PRUint32 index = 0; index < mTimeouts.Length(); index++) {
74337:       nsAutoPtr<TimeoutInfo>& info = mTimeouts[index];
74337:       if (info->mId == aId) {
74337:         info->mCanceled = true;
74337:         break;
74337:       }
74337:     }
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::RunExpiredTimeouts(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   // We may be called recursively (e.g. close() inside a timeout) or we could
74337:   // have been canceled while this event was pending, bail out if there is
74337:   // nothing to do.
74337:   if (mRunningExpiredTimeouts || !mTimerRunning) {
74337:     return true;
74337:   }
74337: 
89017:   NS_ASSERTION(mTimer, "Must have a timer!");
74337:   NS_ASSERTION(!mTimeouts.IsEmpty(), "Should have some work to do!");
74337: 
74337:   bool retval = true;
74337: 
77181:   AutoPtrComparator<TimeoutInfo> comparator = GetAutoPtrComparator(mTimeouts);
77181:   JSObject* global = JS_GetGlobalObject(aCx);
77181:   JSPrincipals* principal = GetWorkerPrincipal();
74337: 
74337:   // We want to make sure to run *something*, even if the timer fired a little
74337:   // early. Fudge the value of now to at least include the first timeout.
77181:   const TimeStamp now = NS_MAX(TimeStamp::Now(), mTimeouts[0]->mTargetTime);
74337: 
74337:   nsAutoTArray<TimeoutInfo*, 10> expiredTimeouts;
74337:   for (PRUint32 index = 0; index < mTimeouts.Length(); index++) {
74337:     nsAutoPtr<TimeoutInfo>& info = mTimeouts[index];
77181:     if (info->mTargetTime > now) {
77181:       break;
77181:     }
74337:     expiredTimeouts.AppendElement(info);
74337:   }
74337: 
74337:   // Guard against recursion.
74337:   mRunningExpiredTimeouts = true;
74337: 
74337:   // Run expired timeouts.
74337:   for (PRUint32 index = 0; index < expiredTimeouts.Length(); index++) {
74337:     TimeoutInfo*& info = expiredTimeouts[index];
74337: 
74337:     if (info->mCanceled) {
74337:       continue;
74337:     }
74337: 
77181:     // Always call JS_ReportPendingException if something fails, and if
77181:     // JS_ReportPendingException returns false (i.e. uncatchable exception) then
77181:     // break out of the loop.
74337: 
74337:     if (JSVAL_IS_STRING(info->mTimeoutVal)) {
74337:       JSString* expression = JSVAL_TO_STRING(info->mTimeoutVal);
74337: 
74337:       size_t stringLength;
74337:       const jschar* string = JS_GetStringCharsAndLength(aCx, expression,
74337:                                                         &stringLength);
77181: 
77181:       if ((!string ||
77181:            !JS_EvaluateUCScriptForPrincipals(aCx, global, principal, string,
77181:                                              stringLength,
77181:                                              info->mFilename.get(),
77181:                                              info->mLineNumber, nsnull)) &&
77181:           !JS_ReportPendingException(aCx)) {
74337:         retval = false;
74337:         break;
74337:       }
74337:     }
74337:     else {
74337:       jsval rval;
74337:       if (!JS_CallFunctionValue(aCx, global, info->mTimeoutVal,
74337:                                 info->mExtraArgVals.Length(),
77181:                                 info->mExtraArgVals.Elements(), &rval) &&
77181:           !JS_ReportPendingException(aCx)) {
74337:         retval = false;
74337:         break;
74337:       }
74337:     }
77181: 
89017:     NS_ASSERTION(mRunningExpiredTimeouts, "Someone changed this!");
89017: 
77181:     // Reschedule intervals.
89017:     if (info->mIsInterval && !info->mCanceled) {
77181:       PRUint32 timeoutIndex = mTimeouts.IndexOf(info);
77181:       NS_ASSERTION(timeoutIndex != PRUint32(-1),
77181:                    "Should still be in the main list!");
77181: 
89017:       // This is nasty but we have to keep the old nsAutoPtr from deleting the
89017:       // info we're about to re-add.
77181:       mTimeouts[timeoutIndex].forget();
77181:       mTimeouts.RemoveElementAt(timeoutIndex);
77181: 
77181:       NS_ASSERTION(!mTimeouts.Contains(info), "Shouldn't have duplicates!");
77181: 
88790:       // NB: We must ensure that info->mTargetTime > now (where now is the
88790:       // now above, not literally TimeStamp::Now()) or we will remove the
88790:       // interval in the next loop below.
88790:       info->mTargetTime = NS_MAX(info->mTargetTime + info->mInterval,
88790:                                  now + TimeDuration::FromMilliseconds(1));
77181:       mTimeouts.InsertElementSorted(info, comparator);
74337:     }
74337:   }
74337: 
74337:   // No longer possible to be called recursively.
74337:   mRunningExpiredTimeouts = false;
74337: 
77181:   // Now remove canceled and expired timeouts from the main list.
77181:   for (PRUint32 index = 0; index < mTimeouts.Length(); ) {
77181:     nsAutoPtr<TimeoutInfo>& info = mTimeouts[index];
77181:     if (info->mTargetTime <= now || info->mCanceled) {
88790:       NS_ASSERTION(!info->mIsInterval || info->mCanceled,
88790:                    "Interval timers can only be removed when canceled!");
74337:       mTimeouts.RemoveElement(info);
77181:     }
77181:     else {
77181:       index++;
77181:     }
74337:   }
74337: 
89017:   // Either signal the parent that we're no longer using timeouts or reschedule
89017:   // the timer.
74337:   if (mTimeouts.IsEmpty()) {
74337:     if (!ModifyBusyCountFromWorker(aCx, false)) {
74337:       retval = false;
74337:     }
74337:     mTimerRunning = false;
74337:   }
74337:   else if (retval && !RescheduleTimeoutTimer(aCx)) {
74337:     retval = false;
74337:   }
74337: 
74337:   return retval;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::RescheduleTimeoutTimer(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337:   NS_ASSERTION(!mTimeouts.IsEmpty(), "Should have some timeouts!");
74337:   NS_ASSERTION(mTimer, "Should have a timer!");
74337: 
74337:   double delta =
74337:     (mTimeouts[0]->mTargetTime - TimeStamp::Now()).ToMilliseconds();
74337:   PRUint32 delay = delta > 0 ? NS_MIN(delta, double(PR_UINT32_MAX)) : 0;
74337: 
74337:   nsresult rv = mTimer->InitWithFuncCallback(DummyCallback, nsnull, delay,
74337:                                              nsITimer::TYPE_ONE_SHOT);
74337:   if (NS_FAILED(rv)) {
74337:     JS_ReportError(aCx, "Failed to start timer!");
74337:     return false;
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::UpdateJSContextOptionsInternal(JSContext* aCx, PRUint32 aOptions)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   JS_SetOptions(aCx, aOptions);
74337: 
74337:   for (PRUint32 index = 0; index < mChildWorkers.Length(); index++) {
74337:     mChildWorkers[index]->UpdateJSContextOptions(aCx, aOptions);
74337:   }
74337: }
74337: 
86576: void
86576: WorkerPrivate::UpdateJSRuntimeHeapSizeInternal(JSContext* aCx,
86576:                                                PRUint32 aMaxBytes)
86576: {
86576:   AssertIsOnWorkerThread();
86576: 
86576:   JS_SetGCParameter(JS_GetRuntime(aCx), JSGC_MAX_BYTES, aMaxBytes);
86576: 
86576:   for (PRUint32 index = 0; index < mChildWorkers.Length(); index++) {
86576:     mChildWorkers[index]->UpdateJSRuntimeHeapSize(aCx, aMaxBytes);
86576:   }
86576: }
86576: 
74337: #ifdef JS_GC_ZEAL
74337: void
74337: WorkerPrivate::UpdateGCZealInternal(JSContext* aCx, PRUint8 aGCZeal)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   PRUint32 frequency = aGCZeal <= 2 ? JS_DEFAULT_ZEAL_FREQ : 1;
74337:   JS_SetGCZeal(aCx, aGCZeal, frequency, false);
74337: 
74337:   for (PRUint32 index = 0; index < mChildWorkers.Length(); index++) {
74337:     mChildWorkers[index]->UpdateGCZeal(aCx, aGCZeal);
74337:   }
74337: }
74337: #endif
74337: 
87588: void
87588: WorkerPrivate::GarbageCollectInternal(JSContext* aCx, bool aShrinking,
87588:                                       bool aCollectChildren)
87588: {
87588:   AssertIsOnWorkerThread();
87588: 
87588:   if (aShrinking) {
88182:     js::ShrinkingGC(aCx, js::gcreason::DOM_WORKER);
87588:   }
87588:   else {
88182:     js::GCForReason(aCx, js::gcreason::DOM_WORKER);
87588:   }
87588: 
87588:   if (aCollectChildren) {
87588:     for (PRUint32 index = 0; index < mChildWorkers.Length(); index++) {
87588:       mChildWorkers[index]->GarbageCollect(aCx, aShrinking);
87588:     }
87588:   }
87588: }
87588: 
74337: #ifdef DEBUG
74337: template <class Derived>
74337: void
74337: WorkerPrivateParent<Derived>::AssertIsOnParentThread() const
74337: {
74337:   if (GetParent()) {
74337:     GetParent()->AssertIsOnWorkerThread();
74337:   }
74337:   else {
74337:     AssertIsOnMainThread();
74337:   }
74337: }
74337: 
74337: template <class Derived>
74337: void
74337: WorkerPrivateParent<Derived>::AssertInnerWindowIsCorrect() const
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   // Only care about top level workers from windows.
74337:   if (mParent || !mWindow) {
74337:     return;
74337:   }
74337: 
74337:   AssertIsOnMainThread();
74337: 
74337:   nsPIDOMWindow* outer = mWindow->GetOuterWindow();
74337:   NS_ASSERTION(outer && outer->GetCurrentInnerWindow() == mWindow,
74337:                "Inner window no longer correct!");
74337: }
74337: 
74337: void
74337: WorkerPrivate::AssertIsOnWorkerThread() const
74337: {
74337:   if (mThread) {
79445:     bool current;
74337:     if (NS_FAILED(mThread->IsOnCurrentThread(&current)) || !current) {
74337:       NS_ERROR("Wrong thread!");
74337:     }
74337:   }
74337:   else {
74337:     NS_ERROR("Trying to assert thread identity after thread has been "
74337:              "shutdown!");
74337:   }
74337: }
74337: #endif
74337: 
83422: WorkerCrossThreadDispatcher*
83422: WorkerPrivate::GetCrossThreadDispatcher()
83422: {
83422:   mozilla::MutexAutoLock lock(mMutex);
83422:   if (!mCrossThreadDispatcher && mStatus <= Running) {
83422:     mCrossThreadDispatcher = new WorkerCrossThreadDispatcher(this);
83422:   }
83422:   return mCrossThreadDispatcher;
83422: }
83422: 
74890: BEGIN_WORKERS_NAMESPACE
74890: 
74337: // Force instantiation.
74337: template class WorkerPrivateParent<WorkerPrivate>;
74337: 
74337: WorkerPrivate*
74337: GetWorkerPrivateFromContext(JSContext* aCx)
74337: {
74337:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
74337:   return static_cast<WorkerPrivate*>(JS_GetContextPrivate(aCx));
74337: }
74337: 
74337: JSStructuredCloneCallbacks*
76372: WorkerStructuredCloneCallbacks(bool aMainRuntime)
74337: {
76372:   return aMainRuntime ?
76372:          &gMainThreadWorkerStructuredCloneCallbacks :
76372:          &gWorkerStructuredCloneCallbacks;
74337: }
74337: 
74337: JSStructuredCloneCallbacks*
76372: ChromeWorkerStructuredCloneCallbacks(bool aMainRuntime)
74337: {
76372:   return aMainRuntime ?
76372:          &gMainThreadChromeWorkerStructuredCloneCallbacks :
76372:          &gChromeWorkerStructuredCloneCallbacks;
74337: }
74337: 
74337: END_WORKERS_NAMESPACE
