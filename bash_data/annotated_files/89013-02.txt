    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Gaunt (jgaunt@netscape.com)
13223:  *   Alexander Surkov <surkov.alexander@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsBaseWidgetAccessible.h"
41384: 
41384: #include "nsAccessibilityService.h"
41384: #include "nsAccUtils.h"
20521: #include "nsCoreUtils.h"
41384: #include "nsHyperTextAccessibleWrap.h"
87094: #include "Role.h"
87094: #include "States.h"
41384: 
    1: #include "nsGUIEvent.h"
    1: #include "nsILink.h"
    1: #include "nsIFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIURI.h"
    1: 
74618: using namespace mozilla::a11y;
74618: 
34240: ////////////////////////////////////////////////////////////////////////////////
    1: // nsLeafAccessible
34240: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsLeafAccessible::
43504:   nsLeafAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS_INHERITED0(nsLeafAccessible, nsAccessible)
    1: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsLeafAccessible: nsAccessible public
35523: 
64131: nsAccessible*
72477: nsLeafAccessible::ChildAtPoint(PRInt32 aX, PRInt32 aY,
64131:                                EWhichChildAtPoint aWhichChild)
28197: {
28197:   // Don't walk into leaf accessibles.
64131:   return this;
28197: }
28197: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsLeafAccessible: nsAccessible private
35523: 
34240: void
34240: nsLeafAccessible::CacheChildren()
34240: {
34240:   // No children for leaf accessible.
34240: }
34240: 
34240: 
13223: ////////////////////////////////////////////////////////////////////////////////
    1: // nsLinkableAccessible
34240: ////////////////////////////////////////////////////////////////////////////////
    1: 
13223: nsLinkableAccessible::
43504:   nsLinkableAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsAccessibleWrap(aContent, aShell),
70183:   mActionAcc(nsnull),
80486:   mIsLink(false),
80486:   mIsOnclick(false)
    1: {
    1: }
    1: 
34199: NS_IMPL_ISUPPORTS_INHERITED0(nsLinkableAccessible, nsAccessibleWrap)
    1: 
13223: ////////////////////////////////////////////////////////////////////////////////
13223: // nsLinkableAccessible. nsIAccessible
13223: 
13223: NS_IMETHODIMP
13223: nsLinkableAccessible::TakeFocus()
    1: {
70183:   return mActionAcc ? mActionAcc->TakeFocus() : nsAccessibleWrap::TakeFocus();
 8743: }
13223: 
67790: PRUint64
67790: nsLinkableAccessible::NativeState()
13223: {
67790:   PRUint64 states = nsAccessibleWrap::NativeState();
13223:   if (mIsLink) {
67790:     states |= states::LINKED;
70183:     if (mActionAcc->State() & states::TRAVERSED)
67790:       states |= states::TRAVERSED;
    1:   }
    1: 
67790:   return states;
    1: }
    1: 
  262: NS_IMETHODIMP
13223: nsLinkableAccessible::GetValue(nsAString& aValue)
    1: {
10555:   aValue.Truncate();
13223: 
34199:   nsAccessible::GetValue(aValue);
10555:   if (!aValue.IsEmpty())
10555:     return NS_OK;
10555: 
70183:   return mIsLink ? mActionAcc->GetValue(aValue) : NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
74781: PRUint8
74781: nsLinkableAccessible::ActionCount()
    1: {
74781:   return (mIsOnclick || mIsLink) ? 1 : 0;
    1: }
    1: 
13223: NS_IMETHODIMP
13223: nsLinkableAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
13223:   aName.Truncate();
13223: 
    1:   // Action 0 (default action): Jump to link
    1:   if (aIndex == eAction_Jump) {   
    1:     if (mIsLink) {
    1:       aName.AssignLiteral("jump");
    1:       return NS_OK;
    1:     }
    1:     else if (mIsOnclick) {
    1:       aName.AssignLiteral("click");
    1:       return NS_OK;
    1:     }
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
13223: NS_IMETHODIMP
13223: nsLinkableAccessible::DoAction(PRUint8 aIndex)
    1: {
16516:   if (aIndex != eAction_Jump)
16516:     return NS_ERROR_INVALID_ARG;
16516: 
70183:   return mActionAcc ? mActionAcc->DoAction(aIndex) :
70183:     nsAccessibleWrap::DoAction(aIndex);
    1: }
    1: 
74014: KeyBinding
74014: nsLinkableAccessible::AccessKey() const
    1: {
74014:   return mActionAcc ?
74014:     mActionAcc->AccessKey() : nsAccessible::AccessKey();
    1: }
    1: 
13223: ////////////////////////////////////////////////////////////////////////////////
21169: // nsLinkableAccessible. nsAccessNode
    1: 
43538: void
13223: nsLinkableAccessible::Shutdown()
    1: {
80486:   mIsLink = false;
80486:   mIsOnclick = false;
70183:   mActionAcc = nsnull;
43538:   nsAccessibleWrap::Shutdown();
    1: }
    1: 
13223: ////////////////////////////////////////////////////////////////////////////////
51810: // nsLinkableAccessible: HyperLinkAccessible
51810: 
51810: already_AddRefed<nsIURI>
72483: nsLinkableAccessible::AnchorURIAt(PRUint32 aAnchorIndex)
51810: {
51810:   if (mIsLink) {
72484:     NS_ASSERTION(mActionAcc->IsLink(),
51810:                  "nsIAccessibleHyperLink isn't implemented.");
51810: 
72484:     if (mActionAcc->IsLink())
72483:       return mActionAcc->AnchorURIAt(aAnchorIndex);
51810:   }
51810: 
51810:   return nsnull;
51810: }
51810: 
51810: ////////////////////////////////////////////////////////////////////////////////
57414: // nsLinkableAccessible: nsAccessible protected
13223: 
13223: void
57414: nsLinkableAccessible::BindToParent(nsAccessible* aParent,
57414:                                    PRUint32 aIndexInParent)
13223: {
57414:   nsAccessibleWrap::BindToParent(aParent, aIndexInParent);
57414: 
57414:   // Cache action content.
70183:   mActionAcc = nsnull;
80486:   mIsLink = false;
80486:   mIsOnclick = false;
57414: 
70183:   if (nsCoreUtils::HasClickListener(mContent)) {
80486:     mIsOnclick = true;
13223:     return;
13223:   }
13223: 
70183:   // XXX: The logic looks broken since the click listener may be registered
70183:   // on non accessible node in parent chain but this node is skipped when tree
70183:   // is traversed.
70183:   nsAccessible* walkUpAcc = this;
74545:   while ((walkUpAcc = walkUpAcc->Parent()) && !walkUpAcc->IsDoc()) {
87094:     if (walkUpAcc->Role() == roles::LINK &&
67790:         walkUpAcc->State() & states::LINKED) {
80486:         mIsLink = true;
70183:         mActionAcc = walkUpAcc;
13223:         return;
13223:     }
13223: 
70183:     if (nsCoreUtils::HasClickListener(walkUpAcc->GetContent())) {
70183:       mActionAcc = walkUpAcc;
80486:       mIsOnclick = true;
13223:       return;
13223:     }
13223:   }
13223: }
13223: 
89013: void
89013: nsLinkableAccessible::UnbindFromParent()
89013: {
89013:   mActionAcc = nsnull;
89013:   mIsLink = false;
89013:   mIsOnclick = nsnull;
89013: 
89013:   nsAccessibleWrap::UnbindFromParent();
89013: }
89013: 
57414: ////////////////////////////////////////////////////////////////////////////////
    1: // nsEnumRoleAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsEnumRoleAccessible::
43504:   nsEnumRoleAccessible(nsIContent *aNode, nsIWeakReference *aShell,
87094:                        roles::Role aRole) :
43504:   nsAccessibleWrap(aNode, aShell), mRole(aRole)
    1: {
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS_INHERITED0(nsEnumRoleAccessible, nsAccessible)
25822: 
87094: role
52027: nsEnumRoleAccessible::NativeRole()
25822: {
52027:   return mRole;
25822: }
