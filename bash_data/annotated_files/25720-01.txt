 1662: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
11789:  *   Mats Palmgren <mats.palmgren@bredband.net>
16418:  *   John Daggett <jdaggett@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: //#define FORCE_UNISCRIBE 1
    1: #define FORCE_PR_LOG
    1: 
    1: #include "prtypes.h"
    1: #include "gfxTypes.h"
    1: 
    1: #include "gfxContext.h"
    1: #include "gfxWindowsFonts.h"
    1: #include "gfxWindowsSurface.h"
    1: #include "gfxWindowsPlatform.h"
    1: 
    1: #include "gfxFontTest.h"
    1: 
    1: #include "cairo.h"
    1: #include "cairo-win32.h"
    1: 
    1: #include <windows.h>
    1: 
 6076: #include "nsTArray.h"
    1: #include "nsUnicodeRange.h"
    1: #include "nsUnicharUtils.h"
    1: 
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
11466: #include "nsIPrefLocalizedString.h"
    1: #include "nsServiceManagerUtils.h"
    1: 
    1: #include "nsCRT.h"
    1: 
    1: #include <math.h>
    1: 
    1: #include "prlog.h"
14918: #include "prinit.h"
    1: static PRLogModuleInfo *gFontLog = PR_NewLogModule("winfonts");
    1: 
    1: #define ROUND(x) floor((x) + 0.5)
    1: 
15022: BYTE 
15022: FontTypeToOutPrecision(PRUint8 fontType)
15022: {
15022: #ifdef WINCE
15022:     return OUT_DEFAULT_PRECIS;
15022: #else
15022:     BYTE ret;
15022:     switch (fontType) {
15022:     case GFX_FONT_TYPE_TT_OPENTYPE:
15022:     case GFX_FONT_TYPE_TRUETYPE:
15022:         ret = OUT_TT_ONLY_PRECIS;
15022:         break;
15022:     case GFX_FONT_TYPE_PS_OPENTYPE:
15022:         ret = OUT_PS_ONLY_PRECIS;
15022:         break;
15022:     case GFX_FONT_TYPE_TYPE1:
15022:         ret = OUT_OUTLINE_PRECIS;
15022:         break;
15022:     case GFX_FONT_TYPE_RASTER:
15022:         ret = OUT_RASTER_PRECIS;
15022:         break;
15022:     case GFX_FONT_TYPE_DEVICE:
15022:         ret = OUT_DEVICE_PRECIS;
15022:         break;
15022:     default:
15022:         ret = OUT_DEFAULT_PRECIS;
15022:     }
15022:     return ret;
15022: #endif
15022: }
 4363: 
 4363: struct DCFromContext {
 4363:     DCFromContext(gfxContext *aContext) {
 4621:         dc = NULL;
 4363:         nsRefPtr<gfxASurface> aSurface = aContext->CurrentSurface();
 4619:         NS_ASSERTION(aSurface, "DCFromContext: null surface");
 6274:         if (aSurface &&
 6274:             (aSurface->GetType() == gfxASurface::SurfaceTypeWin32 ||
 6274:              aSurface->GetType() == gfxASurface::SurfaceTypeWin32Printing))
 6274:         {
 4363:             dc = static_cast<gfxWindowsSurface*>(aSurface.get())->GetDC();
 4363:             needsRelease = PR_FALSE;
 4619:         }
 4619:         if (!dc) {
 4363:             dc = GetDC(NULL);
15061:             SetGraphicsMode(dc, GM_ADVANCED);
 4363:             needsRelease = PR_TRUE;
    1:         }
    1:     }
    1: 
 4363:     ~DCFromContext() {
 4363:         if (needsRelease)
 4363:             ReleaseDC(NULL, dc);
 4363:     }
 4363: 
 4363:     operator HDC () {
 4363:         return dc;
 4363:     }
 4363: 
 4363:     HDC dc;
 4363:     PRBool needsRelease;
 4363: };
 4363: 
13578: 
13578: /**********************************************************************
13578:  *
13578:  * class FontFamily
13578:  *
13578:  **********************************************************************/
13578: static nsresult
13578: ReadCMAP(HDC hdc, FontEntry *aFontEntry)
13578: {
13578:     const PRUint32 kCMAP = (('c') | ('m' << 8) | ('a' << 16) | ('p' << 24));
13578: 
13578:     DWORD len = GetFontData(hdc, kCMAP, 0, nsnull, 0);
13578:     if (len == GDI_ERROR || len == 0) // not a truetype font --
13578:         return NS_ERROR_FAILURE;      // we'll treat it as a symbol font
13578: 
13578:     nsAutoTArray<PRUint8,16384> buffer;
13578:     if (!buffer.AppendElements(len))
13578:         return NS_ERROR_OUT_OF_MEMORY;
13578:     PRUint8 *buf = buffer.Elements();
13578: 
13578:     DWORD newLen = GetFontData(hdc, kCMAP, 0, buf, len);
13578:     NS_ENSURE_TRUE(newLen == len, NS_ERROR_FAILURE);
13578: 
13879:     // can't pass bits as references...
13879:     PRPackedBool unicodeFont = aFontEntry->mUnicodeFont;
13879:     PRPackedBool symbolFont = aFontEntry->mSymbolFont;
13879:     nsresult rv = gfxFontUtils::ReadCMAP(buf, len, aFontEntry->mCharacterMap,
13879:                                          unicodeFont, symbolFont);
13879:     aFontEntry->mUnicodeFont = unicodeFont;
13879:     aFontEntry->mSymbolFont = symbolFont;
13879: 
13879:     return rv;
13578: }
13578: 
13578: struct FamilyAddStyleProcData {
13578:     HDC dc;
13578:     FontFamily *ff;
13578: };
13578: 
13578: int CALLBACK 
13578: FontFamily::FamilyAddStylesProc(const ENUMLOGFONTEXW *lpelfe,
13578:                                 const NEWTEXTMETRICEXW *nmetrics,
13578:                                 DWORD fontType, LPARAM data)
13578: {
13578:     const NEWTEXTMETRICW& metrics = nmetrics->ntmTm;
13578:     LOGFONTW logFont = lpelfe->elfLogFont;
13578: 
13578:     FamilyAddStyleProcData *faspd = reinterpret_cast<FamilyAddStyleProcData*>(data);
13578:     FontFamily *ff = faspd->ff;
13578:     HDC hdc = faspd->dc;
13578: 
13578:     // Some fonts claim to support things > 900, but we don't so clamp the sizes
13578:     logFont.lfWeight = PR_MAX(PR_MIN(logFont.lfWeight, 900), 100);
13578: 
19962: 
19962:     gfxWindowsFontType feType = FontEntry::DetermineFontType(metrics, fontType);
15022: 
13578:     FontEntry *fe = nsnull;
13578:     for (PRUint32 i = 0; i < ff->mVariations.Length(); ++i) {
13578:         fe = ff->mVariations[i];
15022:         if (feType > fe->mFontType) {
15022:             // if the new type is better than the old one, remove the old entries
15022:             ff->mVariations.RemoveElementAt(i);
15022:             --i;
15022:         } else if (feType < fe->mFontType) {
15022:             // otherwise if the new type is worse, skip it
15022:             return 1;
15022:         }
15022:     }
13578: 
15022:     for (PRUint32 i = 0; i < ff->mVariations.Length(); ++i) {
15022:         fe = ff->mVariations[i];
13578:         // check if we already know about this face
13578:         if (fe->mWeight == logFont.lfWeight &&
13578:             fe->mItalic == (logFont.lfItalic == 0xFF)) {
13578:             // update the charset bit here since this could be different
13578:             fe->mCharset[metrics.tmCharSet] = 1;
13578:             return 1; 
13578:         }
13578:     }
13578: 
19962:     logFont.lfCharSet = DEFAULT_CHARSET;
19962:     logFont.lfOutPrecision = FontTypeToOutPrecision(feType);
19962:     fe = FontEntry::CreateFontEntry(ff->mName, feType, (logFont.lfItalic == 0xFF), (PRUint16) (logFont.lfWeight), nsnull, hdc, &logFont);
19962: 
19962:     if (!fe)
19962:         return 1;
19962: 
13578:     ff->mVariations.AppendElement(fe);
13578: 
13578:     // mark the charset bit
13578:     fe->mCharset[metrics.tmCharSet] = 1;
13578: 
13578:     fe->mWindowsFamily = logFont.lfPitchAndFamily & 0xF0;
13578:     fe->mWindowsPitch = logFont.lfPitchAndFamily & 0x0F;
13578: 
13578:     if (nmetrics->ntmFontSig.fsUsb[0] != 0x00000000 &&
13578:         nmetrics->ntmFontSig.fsUsb[1] != 0x00000000 &&
13578:         nmetrics->ntmFontSig.fsUsb[2] != 0x00000000 &&
13578:         nmetrics->ntmFontSig.fsUsb[3] != 0x00000000) {
13578: 
13578:         // set the unicode ranges
13578:         PRUint32 x = 0;
13578:         for (PRUint32 i = 0; i < 4; ++i) {
13578:             DWORD range = nmetrics->ntmFontSig.fsUsb[i];
13578:             for (PRUint32 k = 0; k < 32; ++k) {
13578:                 fe->mUnicodeRanges[x++] = (range & (1 << k)) != 0;
13578:             }
13578:         }
13578:     }
13578: 
19962:     fe->mIsBadUnderlineFont = ff->mIsBadUnderlineFontFamily;
13578: 
13578:     return 1;
13578: }
13578: 
13578: // general cmap reading routines moved to gfxFontUtils.cpp
13578: void
13578: FontFamily::FindStyleVariations()
13578: {
13877:     if (mHasStyles)
13877:         return;
13578:     mHasStyles = PR_TRUE;
13578: 
13578:     HDC hdc = GetDC(nsnull);
15061:     SetGraphicsMode(hdc, GM_ADVANCED);
13578: 
13578:     LOGFONTW logFont;
13578:     memset(&logFont, 0, sizeof(LOGFONTW));
13578:     logFont.lfCharSet = DEFAULT_CHARSET;
13578:     logFont.lfPitchAndFamily = 0;
13578:     PRUint32 l = PR_MIN(mName.Length(), LF_FACESIZE - 1);
13578:     memcpy(logFont.lfFaceName,
13578:            nsPromiseFlatString(mName).get(),
13578:            l * sizeof(PRUnichar));
13578:     logFont.lfFaceName[l] = 0;
13578: 
13578:     FamilyAddStyleProcData faspd;
13578:     faspd.dc = hdc;
13578:     faspd.ff = this;
13578: 
13578:     EnumFontFamiliesExW(hdc, &logFont, (FONTENUMPROCW)FontFamily::FamilyAddStylesProc, (LPARAM)&faspd, 0);
25720: #ifdef DEBUG
25720:     if (mVariations.Length() == 0) {
25720:         char msgBuf[256];
25720:         (void)sprintf(msgBuf, "no styles available in family \"%s\"",
25720:                       NS_ConvertUTF16toUTF8(mName).get());
25720:         NS_ASSERTION(mVariations.Length() != 0, msgBuf);
25720:     }
25720: #endif
13578: 
13578:     ReleaseDC(nsnull, hdc);
13578: 
13578:     // Look for font families without bold variations and add a FontEntry
13578:     // with synthetic bold (weight 600) for them.
13578:     FontEntry *darkestItalic = nsnull;
13578:     FontEntry *darkestNonItalic = nsnull;
13578:     PRUint8 highestItalic = 0, highestNonItalic = 0;
13578:     for (PRUint32 i = 0; i < mVariations.Length(); i++) {
13578:         FontEntry *fe = mVariations[i];
13578:         if (fe->mItalic) {
13578:             if (!darkestItalic || fe->mWeight > darkestItalic->mWeight)
13578:                 darkestItalic = fe;
13578:         } else {
13578:             if (!darkestNonItalic || fe->mWeight > darkestNonItalic->mWeight)
13578:                 darkestNonItalic = fe;
13578:         }
13578:     }
13578: 
13578:     if (darkestItalic && darkestItalic->mWeight < 600) {
13578:         FontEntry *newEntry = new FontEntry(*darkestItalic);
13578:         newEntry->mWeight = 600;
13578:         mVariations.AppendElement(newEntry);
13578:     }
13578:     if (darkestNonItalic && darkestNonItalic->mWeight < 600) {
13578:         FontEntry *newEntry = new FontEntry(*darkestNonItalic);
13578:         newEntry->mWeight = 600;
13578:         mVariations.AppendElement(newEntry);
13578:     }
13578: }
13578: 
13578: 
13578: FontEntry *
13578: FontFamily::FindFontEntry(const gfxFontStyle& aFontStyle)
13578: {
16418:     PRBool needsBold;
16418:     return static_cast<FontEntry*> (FindFontForStyle(aFontStyle, needsBold));
16418: }
16418: 
16418: PRBool
16418: FontFamily::FindWeightsForStyle(gfxFontEntry* aFontsForWeights[], const gfxFontStyle& aFontStyle)
16418: {
13578:     if (!mHasStyles)
13578:         FindStyleVariations();
13578: 
13578:     PRBool italic = (aFontStyle.style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) != 0;
16418:     PRBool matchesSomething;
13578: 
13578:     for (PRUint32 j = 0; j < 2; j++) {
16418:         matchesSomething = PR_FALSE;
13578:         // build up an array of weights that match the italicness we're looking for
13578:         for (PRUint32 i = 0; i < mVariations.Length(); i++) {
13578:             FontEntry *fe = mVariations[i];
13578:             const PRUint8 weight = (fe->mWeight / 100);
13578:             if (fe->mItalic == italic) {
16418:                 aFontsForWeights[weight] = fe;
13578:                 matchesSomething = PR_TRUE;
13578:             }
13578:         }
13578:         if (matchesSomething)
13578:             break;
13578:         italic = !italic;
13578:     }
13578: 
16418:     return matchesSomething;
13578: }
13578: 
24104: // from t2embapi.h, included in Platform SDK 6.1 but not 6.0
24104: 
24104: #ifndef __t2embapi__
24104: 
24104: #define TTLOAD_PRIVATE                  0x00000001
24104: #define LICENSE_PREVIEWPRINT            0x0004
24104: #define E_NONE                          0x0000L
24104: 
24104: typedef unsigned long( WINAPIV *READEMBEDPROC ) ( void*, void*, const unsigned long );
24104: 
24104: typedef struct
24104: {
24104:     unsigned short usStructSize;    // size in bytes of structure client should set to sizeof(TTLOADINFO)
24104:     unsigned short usRefStrSize;    // size in wide characters of pusRefStr including NULL terminator
24104:     unsigned short *pusRefStr;      // reference or actual string.
24104: }TTLOADINFO;
24104: 
24104: LONG WINAPI TTLoadEmbeddedFont
24104: (
24104:     HANDLE*  phFontReference,           // on completion, contains handle to identify embedded font installed
24104:                                         // on system
24104:     ULONG    ulFlags,                   // flags specifying the request 
24104:     ULONG*   pulPrivStatus,             // on completion, contains the embedding status
24104:     ULONG    ulPrivs,                   // allows for the reduction of licensing privileges
24104:     ULONG*   pulStatus,                 // on completion, may contain status flags for request 
24104:     READEMBEDPROC lpfnReadFromStream,   // callback function for doc/disk reads
24104:     LPVOID   lpvReadStream,             // the input stream tokin
24104:     LPWSTR   szWinFamilyName,           // the new 16 bit windows family name can be NULL
24104:     LPSTR    szMacFamilyName,           // the new 8 bit mac family name can be NULL
24104:     TTLOADINFO* pTTLoadInfo             // optional security
24104: );
24104: 
24104: #endif // __t2embapi__
24104: 
24104: typedef LONG( WINAPI *TTLoadEmbeddedFontProc ) (HANDLE* phFontReference, ULONG ulFlags, ULONG* pulPrivStatus, ULONG ulPrivs, ULONG* pulStatus, 
24104:                                              READEMBEDPROC lpfnReadFromStream, LPVOID lpvReadStream, LPWSTR szWinFamilyName, 
24104:                                              LPSTR szMacFamilyName, TTLOADINFO* pTTLoadInfo);
24104: 
24104: typedef LONG( WINAPI *TTDeleteEmbeddedFontProc ) (HANDLE hFontReference, ULONG ulFlags, ULONG* pulStatus);
24104: 
24104: 
24104: static TTLoadEmbeddedFontProc TTLoadEmbeddedFontPtr = nsnull;
24104: static TTDeleteEmbeddedFontProc TTDeleteEmbeddedFontPtr = nsnull;
24104: 
24104: void FontEntry::InitializeFontEmbeddingProcs()
24104: {
24104:     HMODULE fontlib = LoadLibraryW(L"t2embed.dll");
24104:     if (!fontlib)
24104:         return;
24104:     TTLoadEmbeddedFontPtr = (TTLoadEmbeddedFontProc) GetProcAddress(fontlib, "TTLoadEmbeddedFont");
24104:     TTDeleteEmbeddedFontPtr = (TTDeleteEmbeddedFontProc) GetProcAddress(fontlib, "TTDeleteEmbeddedFont");
24104: }
24104: 
24104: class WinUserFontData : public gfxUserFontData {
24104: public:
24104:     WinUserFontData(HANDLE aFontRef, PRBool aIsCFF)
24104:         : mFontRef(aFontRef), mIsCFF(aIsCFF)
24104:     { }
24104: 
24104:     virtual ~WinUserFontData()
24104:     {
24104:         if (mIsCFF) {
24104:             RemoveFontMemResourceEx(mFontRef);
24104:         } else {
24104:             ULONG pulStatus;
24104:             TTDeleteEmbeddedFontPtr(mFontRef, 0, &pulStatus);
24104:         }
24104:     }
24104:     
24104:     HANDLE mFontRef;
24104:     PRPackedBool mIsCFF;
24104: };
24104: 
24104: // used to control stream read by Windows TTLoadEmbeddedFont API
24104: 
24104: class EOTFontStreamReader {
24104: public:
24104:     EOTFontStreamReader(const PRUint8 *aFontData, PRUint32 aLength, PRUint8 *aEOTHeader, 
24104:                         PRUint32 aEOTHeaderLen)
24104:         : mInHeader(PR_TRUE), mHeaderOffset(0), mEOTHeader(aEOTHeader), 
24104:           mEOTHeaderLen(aEOTHeaderLen), mFontData(aFontData), mFontDataLen(aLength),
24104:           mFontDataOffset(0)
24104:     {
24104:     
24104:     }
24104: 
24104:     ~EOTFontStreamReader() 
24104:     { 
24104: 
24104:     }
24104: 
24104:     PRPackedBool            mInHeader;
24104:     PRUint32                mHeaderOffset;
24104:     PRUint8                 *mEOTHeader;
24104:     PRUint32                mEOTHeaderLen;
24104:     const PRUint8           *mFontData;
24104:     PRUint32                mFontDataLen;
24104:     PRUint32                mFontDataOffset;
24104: 
24104:     unsigned long Read(void *outBuffer, const unsigned long aBytesToRead)
24104:     {
24104:         PRUint32 bytesLeft = aBytesToRead;
24104:         PRUint8 *out = static_cast<PRUint8*> (outBuffer);
24104: 
24104:         // read from EOT header
24104:         if (mInHeader) {
24104:             PRUint32 toCopy = PR_MIN(aBytesToRead, mEOTHeaderLen - mHeaderOffset);
24104:             memcpy(out, mEOTHeader + mHeaderOffset, toCopy);
24104:             bytesLeft -= toCopy;
24104:             mHeaderOffset += toCopy;
24104:             out += toCopy;
24104:             if (mHeaderOffset == mEOTHeaderLen)
24104:                 mInHeader = PR_FALSE;
24104:         }
24104: 
24104:         if (bytesLeft) {
24104:             PRInt32 bytesRead = PR_MIN(bytesLeft, mFontDataLen - mFontDataOffset);
24104:             memcpy(out, mFontData, bytesRead);
24104:             mFontData += bytesRead;
24104:             mFontDataOffset += bytesRead;
24104:             if (bytesRead > 0)
24104:                 bytesLeft -= bytesRead;
24104:         }
24104: 
24104:         return aBytesToRead - bytesLeft;
24104:     }
24104: 
24104:     static unsigned long ReadEOTStream(void *aReadStream, void *outBuffer, 
24104:                                        const unsigned long aBytesToRead) 
24104:     {
24104:         EOTFontStreamReader *eotReader = 
24104:                                static_cast<EOTFontStreamReader*> (aReadStream);
24104:         return eotReader->Read(outBuffer, aBytesToRead);
24104:     }        
24104:         
24104: };
24104: 
24104: static void MakeUniqueFontName(nsAString& aName)
24104: {
24104:     char buf[50];
24104: 
24104:     static PRUint32 fontCount = 0;
24104:     ++fontCount;
24104: 
24104:     sprintf(buf, "mozfont%8.8x%8.8x", ::GetTickCount(), fontCount);  // slightly retarded, figure something better later...
24104:     aName.AssignASCII(buf);
24104: }
24104: 
24104: /* static */
24104: FontEntry* 
24106: FontEntry::CreateFontEntry(const gfxProxyFontEntry &aProxyEntry, 
24106:                            nsISupports *aLoader,const PRUint8 *aFontData, 
24106:                            PRUint32 aLength) {
24104:     // if calls aren't available, bail
24104:     if (!TTLoadEmbeddedFontPtr || !TTDeleteEmbeddedFontPtr)
24104:         return nsnull;
24104: 
24104:     PRBool isCFF;
24104:     if (!gfxFontUtils::ValidateSFNTHeaders(aFontData, aLength, &isCFF))
24104:         return nsnull;
24104:         
24104:     nsresult rv;
24104:     HANDLE fontRef;
24104: 
24104:     nsAutoString uniqueName;
24104:     MakeUniqueFontName(uniqueName);
24104: 
24104:     if (isCFF) {
24104:         // Postscript-style glyphs, swizzle name table, load directly
24104:         nsTArray<PRUint8> newFontData;
24104: 
24104:         rv = gfxFontUtils::RenameFont(uniqueName, aFontData, aLength, &newFontData);
24104: 
24104:         if (NS_FAILED(rv))
24104:             return nsnull;
24104:         
24104:         DWORD numFonts = 0;
24104: 
24104:         PRUint8 *fontData = reinterpret_cast<PRUint8*> (newFontData.Elements());
24104:         PRUint32 fontLength = newFontData.Length();
24104:         NS_ASSERTION(fontData, "null font data after renaming");
24104: 
24104:         // http://msdn.microsoft.com/en-us/library/ms533942(VS.85).aspx
24104:         // "A font that is added by AddFontMemResourceEx is always private 
24104:         //  to the process that made the call and is not enumerable."
24104:         fontRef = AddFontMemResourceEx(fontData, fontLength, 
24104:                                        0 /* reserved */, &numFonts);
24104:         if (!fontRef)
24104:             return nsnull;
24104: 
24104:         // only load fonts with a single face contained in the data
24104:         if (fontRef && numFonts != 1) {
24104:             RemoveFontMemResourceEx(fontRef);
24104:             return nsnull;
24104:         }
24104:     } else {
24104:         // TrueType-style glyphs, use EOT library
24104:         nsAutoTArray<PRUint8,2048> eotHeader;
24104:         PRUint8 *buffer;
24104:         PRUint32 eotlen;
24104: 
24104:         PRUint32 nameLen = PR_MIN(uniqueName.Length(), LF_FACESIZE - 1);
24104:         nsPromiseFlatString fontName(Substring(uniqueName, 0, nameLen));
24104: 
24104:         rv = gfxFontUtils::MakeEOTHeader(aFontData, aLength, &eotHeader);
24104:         if (NS_FAILED(rv))
24104:             return nsnull;
24104: 
24104:         // load in embedded font data
24104:         eotlen = eotHeader.Length();
24104:         buffer = reinterpret_cast<PRUint8*> (eotHeader.Elements());
24104:         
24104:         PRInt32 ret;
24104:         ULONG privStatus, pulStatus;
24104:         EOTFontStreamReader eotReader(aFontData, aLength, buffer, eotlen);
24104: 
24104:         ret = TTLoadEmbeddedFontPtr(&fontRef, TTLOAD_PRIVATE, &privStatus, 
24104:                                    LICENSE_PREVIEWPRINT, &pulStatus, 
24104:                                    EOTFontStreamReader::ReadEOTStream, 
24104:                                    &eotReader, (PRUnichar*)(fontName.get()), 0, 0);
24104:         if (ret != E_NONE)
24104:             return nsnull;
24104:     }
24104: 
24104:     // make a new font entry using the unique name
24104:     WinUserFontData *winUserFontData = new WinUserFontData(fontRef, isCFF);
24104:     PRUint16 w = (aProxyEntry.mWeight == 0 ? 400 : aProxyEntry.mWeight);
24104: 
24104:     FontEntry *fe = FontEntry::CreateFontEntry(uniqueName, 
24104:         gfxWindowsFontType(isCFF ? GFX_FONT_TYPE_PS_OPENTYPE : GFX_FONT_TYPE_TRUETYPE) /*type*/, 
24104:         PRUint32(aProxyEntry.mItalic ? FONT_STYLE_ITALIC : FONT_STYLE_NORMAL), 
24104:         w, winUserFontData);
24104: 
24104:     if (fe && isCFF)
24104:         fe->mForceGDI = PR_TRUE;
24104:     return fe;
24104: }
24104: 
19962: FontEntry* 
19962: FontEntry::CreateFontEntry(const nsAString& aName, gfxWindowsFontType aFontType, PRBool aItalic, PRUint16 aWeight, gfxUserFontData* aUserFontData, HDC hdc, LOGFONTW *aLogFont)
19962: {
19962:     LOGFONTW logFont;
19962:     PRBool needRelease = PR_FALSE;
19962: 
19962:     // jtdfix - need to set charset, unicode ranges, pitch/family
19962: 
19962:     FontEntry *fe;
19962: 
19962:     fe = new FontEntry(aName);
19962:     fe->mFontType = aFontType;
19962:     fe->mUserFontData = aUserFontData;
19962: 
19962:     fe->mItalic = aItalic;
19962:     fe->mWeight = aWeight;
19962: 
19962:     if (fe->IsType1())
19962:         fe->mForceGDI = PR_TRUE;
19962: 
19962:     if (!aLogFont) {
19962:         aLogFont = &logFont;
19962:         FontEntry::FillLogFont(aLogFont, fe, 0, aItalic);
19962:     }
19962: 
19962:     if (!hdc) {
19962:         hdc = GetDC(nsnull);
19962:         SetGraphicsMode(hdc, GM_ADVANCED);
19962:         needRelease = PR_TRUE;
19962:     }
19962: 
19962:     HFONT font = CreateFontIndirectW(aLogFont);
19962: 
19962:     if (font) {
19962:         HFONT oldFont = (HFONT)SelectObject(hdc, font);
19962: 
19962:         // ReadCMAP may change the values of mUnicodeFont and mSymbolFont
19962:         if (NS_FAILED(::ReadCMAP(hdc, fe))) {
19962:             // Type1 fonts aren't necessarily Unicode but
19962:             // this is the best guess we can make here
19962:             if (fe->IsType1())
19962:                 fe->mUnicodeFont = PR_TRUE;
19962:             else
19962:                 fe->mUnicodeFont = PR_FALSE;
19962: 
19962:             // For fonts where we failed to read the character map,
19962:             // we can take a slow path to look up glyphs character by character
19962:             fe->mUnknownCMAP = PR_TRUE;
19962: 
19962:         } 
19962: 
19962:         SelectObject(hdc, oldFont);
19962:         DeleteObject(font);
19962:     }
19962: 
19962:     if (needRelease)
19962:         ReleaseDC(nsnull, hdc);
19962: 
19962:     return fe;
19962: }
19962: 
19962: 
19962: void
19962: FontEntry::FillLogFont(LOGFONTW *aLogFont, FontEntry *aFontEntry, gfxFloat aSize, PRBool aItalic)
19962: {
19962: #define CLIP_TURNOFF_FONTASSOCIATION 0x40
19962:     
19962:     aLogFont->lfHeight = (LONG)-ROUND(aSize);
19962: 
19962:     if (aLogFont->lfHeight == 0)
19962:         aLogFont->lfHeight = -1;
19962: 
19962:     // Fill in logFont structure
19962:     aLogFont->lfWidth          = 0;
19962:     aLogFont->lfEscapement     = 0;
19962:     aLogFont->lfOrientation    = 0;
19962:     aLogFont->lfUnderline      = FALSE;
19962:     aLogFont->lfStrikeOut      = FALSE;
19962:     aLogFont->lfCharSet        = DEFAULT_CHARSET;
19962:     aLogFont->lfOutPrecision   = FontTypeToOutPrecision(aFontEntry->mFontType);
19962:     aLogFont->lfClipPrecision  = CLIP_TURNOFF_FONTASSOCIATION;
19962:     aLogFont->lfQuality        = DEFAULT_QUALITY;
19962:     aLogFont->lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
19962:     // always force lfItalic if we want it.  Font selection code will
19962:     // do its best to give us an italic font entry, but if no face exists
19962:     // it may give us a regular one based on weight.  Windows should
19962:     // do fake italic for us in that case.
19962:     aLogFont->lfItalic         = aItalic;
19962:     aLogFont->lfWeight         = aFontEntry->mWeight;
19962: 
19962:     int len = PR_MIN(aFontEntry->Name().Length(), LF_FACESIZE - 1);
19962:     memcpy(aLogFont->lfFaceName, nsPromiseFlatString(aFontEntry->Name()).get(), len * 2);
19962:     aLogFont->lfFaceName[len] = '\0';
19962: }
19962: 
19962: 
16418: PRBool 
16418: FontEntry::TestCharacterMap(PRUint32 aCh)
16418: {
16418:     if (mUnknownCMAP) {
16418:         if (aCh > 0xFFFF)
16418:             return PR_FALSE;
16418: 
16418:         // previous code was using the group style
16418:         gfxFontStyle fakeStyle;  
16418:         if (mItalic)
16418:             fakeStyle.style = FONT_STYLE_ITALIC;
16418:         fakeStyle.weight = mWeight * 100;
16418: 
16418:         nsRefPtr<gfxWindowsFont> font =
16418:             gfxWindowsFont::GetOrMakeFont(this, &fakeStyle);
16418:         if (!font->IsValid())
16418:             return PR_FALSE;
16418: 
16418:         HDC dc = GetDC((HWND)nsnull);
16418:         SetGraphicsMode(dc, GM_ADVANCED);
16418:         HFONT hfont = font->GetHFONT();
16418:         HFONT oldFont = (HFONT)SelectObject(dc, hfont);
16418: 
16418:         PRUnichar str[1] = { (PRUnichar)aCh };
16418:         WORD glyph[1];
16418: 
16418:         PRBool hasGlyph = PR_FALSE;
16418:         if (IsType1()) {
16418:             // Type1 fonts and uniscribe APIs don't get along.  ScriptGetCMap will return E_HANDLE
16418:             DWORD ret = GetGlyphIndicesW(dc, str, 1, glyph, GGI_MARK_NONEXISTING_GLYPHS);
16418:             if (ret != GDI_ERROR && glyph[0] != 0xFFFF)
16418:                 hasGlyph = PR_TRUE;
16418:         } else {
16418:             // ScriptGetCMap works better than GetGlyphIndicesW for things like bitmap/vector fonts
16418:             HRESULT rv = ScriptGetCMap(dc, font->ScriptCache(), str, 1, 0, glyph);
16418:             if (rv == S_OK)
16418:                 hasGlyph = PR_TRUE;
13578:         }
13578: 
16418:         if (hasGlyph) {
16418:             mCharacterMap.set(aCh);
16418:             return PR_TRUE;         // jtdcheck -- don't we need to do a ReleaseDC??
13578:         }
13578: 
16418:         SelectObject(dc, oldFont);
16418:         ReleaseDC(NULL, dc);
13578:     }
13578: 
16418:     return PR_FALSE;
13578: }
13578: 
    1: /**********************************************************************
    1:  *
    1:  * class gfxWindowsFont
    1:  *
    1:  **********************************************************************/
    1: 
25417: gfxWindowsFont::gfxWindowsFont(FontEntry *aFontEntry, const gfxFontStyle *aFontStyle,
25417:                                cairo_antialias_t anAntialiasOption)
16418:     : gfxFont(aFontEntry, aFontStyle),
 9503:       mFont(nsnull), mAdjustedSize(0.0), mScriptCache(nsnull),
    1:       mFontFace(nsnull), mScaledFont(nsnull),
25417:       mMetrics(nsnull), mAntialiasOption(anAntialiasOption)
    1: {
16418:     mFontEntry = aFontEntry;
 1959:     NS_ASSERTION(mFontEntry, "Unable to find font entry for font.  Something is whack.");
 2369: 
 2369:     mFont = MakeHFONT(); // create the HFONT, compute metrics, etc
 2369:     NS_ASSERTION(mFont, "Failed to make HFONT");
    1: }
    1: 
    1: gfxWindowsFont::~gfxWindowsFont()
    1: {
    1:     if (mFontFace)
    1:         cairo_font_face_destroy(mFontFace);
    1: 
    1:     if (mScaledFont)
    1:         cairo_scaled_font_destroy(mScaledFont);
    1: 
    1:     if (mFont)
    1:         DeleteObject(mFont);
    1: 
    1:     ScriptFreeCache(&mScriptCache);
    1: 
    1:     delete mMetrics;
    1: }
    1: 
    1: const gfxFont::Metrics&
    1: gfxWindowsFont::GetMetrics()
    1: {
    1:     if (!mMetrics)
    1:         ComputeMetrics();
    1: 
    1:     return *mMetrics;
    1: }
    1: 
    1: cairo_font_face_t *
    1: gfxWindowsFont::CairoFontFace()
    1: {
    1:     if (!mFontFace)
 2369:         mFontFace = cairo_win32_font_face_create_for_logfontw_hfont(&mLogFont, mFont);
    1: 
    1:     NS_ASSERTION(mFontFace, "Failed to make font face");
    1: 
    1:     return mFontFace;
    1: }
    1: 
    1: cairo_scaled_font_t *
    1: gfxWindowsFont::CairoScaledFont()
    1: {
 2369:     if (!mScaledFont) {
 2369:         cairo_matrix_t sizeMatrix;
 2369:         cairo_matrix_t identityMatrix;
 2369: 
 2369:         cairo_matrix_init_scale(&sizeMatrix, mAdjustedSize, mAdjustedSize);
 2369:         cairo_matrix_init_identity(&identityMatrix);
 2369: 
 2369:         cairo_font_options_t *fontOptions = cairo_font_options_create();
25417:         if (mAntialiasOption != CAIRO_ANTIALIAS_DEFAULT) {
25417:             cairo_font_options_set_antialias(fontOptions, mAntialiasOption);
25417:         }
 2369:         mScaledFont = cairo_scaled_font_create(CairoFontFace(), &sizeMatrix,
 2369:                                                &identityMatrix, fontOptions);
 2369:         cairo_font_options_destroy(fontOptions);
 2369:     }
    1: 
 5274:     NS_ASSERTION(mAdjustedSize == 0.0 ||
 5274:                  cairo_scaled_font_status(mScaledFont) == CAIRO_STATUS_SUCCESS,
 4304:                  "Failed to make scaled font");
    1: 
    1:     return mScaledFont;
    1: }
    1: 
    1: HFONT
    1: gfxWindowsFont::MakeHFONT()
    1: {
    1:     if (mFont)
    1:         return mFont;
    1: 
  323:     mAdjustedSize = GetStyle()->size;
 9504:     if (GetStyle()->sizeAdjust > 0.0) {
    1:         if (!mFont) {
13280:             FillLogFont(mAdjustedSize);
    1:             mFont = CreateFontIndirectW(&mLogFont);
    1:         }
    1: 
    1:         Metrics *oldMetrics = mMetrics;
    1:         ComputeMetrics();
    1:         gfxFloat aspect = mMetrics->xHeight / mMetrics->emHeight;
 2210:         mAdjustedSize = GetStyle()->GetAdjustedSize(aspect);
    1: 
    1:         if (mMetrics != oldMetrics) {
    1:             delete mMetrics;
    1:             mMetrics = oldMetrics;
    1:         }
    1:         DeleteObject(mFont);
    1:         mFont = nsnull;
    1:     }
    1: 
    1:     if (!mFont) {
13280:         FillLogFont(mAdjustedSize);
    1:         mFont = CreateFontIndirectW(&mLogFont);
    1:     }
    1: 
    1:     return mFont;
    1: }
    1: 
    1: void
    1: gfxWindowsFont::ComputeMetrics()
    1: {
    1:     if (!mMetrics)
    1:         mMetrics = new gfxFont::Metrics;
 2369:     else
 2369:         NS_WARNING("Calling ComputeMetrics multiple times");
    1: 
    1:     HDC dc = GetDC((HWND)nsnull);
15061:     SetGraphicsMode(dc, GM_ADVANCED);
    1: 
 2369:     HGDIOBJ oldFont = SelectObject(dc, mFont);
    1: 
    1:     // Get font metrics
    1:     OUTLINETEXTMETRIC oMetrics;
    1:     TEXTMETRIC& metrics = oMetrics.otmTextMetrics;
    1: 
    1:     if (0 < GetOutlineTextMetrics(dc, sizeof(oMetrics), &oMetrics)) {
    1:         mMetrics->superscriptOffset = (double)oMetrics.otmptSuperscriptOffset.y;
11789:         // Some fonts have wrong sign on their subscript offset, bug 410917.
11789:         mMetrics->subscriptOffset = fabs((double)oMetrics.otmptSubscriptOffset.y);
11765:         mMetrics->strikeoutSize = (double)oMetrics.otmsStrikeoutSize;
    1:         mMetrics->strikeoutOffset = (double)oMetrics.otmsStrikeoutPosition;
11765:         mMetrics->underlineSize = (double)oMetrics.otmsUnderscoreSize;
    1:         mMetrics->underlineOffset = (double)oMetrics.otmsUnderscorePosition;
    1: 
    1:         const MAT2 kIdentityMatrix = { {0, 1}, {0, 0}, {0, 0}, {0, 1} };
    1:         GLYPHMETRICS gm;
    1:         DWORD len = GetGlyphOutlineW(dc, PRUnichar('x'), GGO_METRICS, &gm, 0, nsnull, &kIdentityMatrix);
    1:         if (len == GDI_ERROR || gm.gmptGlyphOrigin.y <= 0) {
    1:             // 56% of ascent, best guess for true type
    1:             mMetrics->xHeight = ROUND((double)metrics.tmAscent * 0.56);
    1:         } else {
    1:             mMetrics->xHeight = gm.gmptGlyphOrigin.y;
    1:         }
11765:         mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
11765:         gfxFloat typEmHeight = (double)oMetrics.otmAscent - (double)oMetrics.otmDescent;
11765:         mMetrics->emAscent = ROUND(mMetrics->emHeight * (double)oMetrics.otmAscent / typEmHeight);
11765:         mMetrics->emDescent = mMetrics->emHeight - mMetrics->emAscent;
    1:     } else {
    1:         // Make a best-effort guess at extended metrics
    1:         // this is based on general typographic guidelines
14798:         
14798:         // GetTextMetrics can fail if the font file has been removed
14798:         // or corrupted recently.
14798:         BOOL result = GetTextMetrics(dc, &metrics);
14798:         if (!result) {
14798:             NS_WARNING("Missing or corrupt font data, fasten your seatbelt");
14798:             mIsValid = PR_FALSE;
14798:             memset(mMetrics, 0, sizeof(*mMetrics));
14798:             SelectObject(dc, oldFont);
14798:             ReleaseDC((HWND)nsnull, dc);
14798:             return;
14798:         }
    1: 
    1:         mMetrics->xHeight = ROUND((float)metrics.tmAscent * 0.56f); // 56% of ascent, best guess for non-true type
    1:         mMetrics->superscriptOffset = mMetrics->xHeight;
    1:         mMetrics->subscriptOffset = mMetrics->xHeight;
    1:         mMetrics->strikeoutSize = 1;
    1:         mMetrics->strikeoutOffset = ROUND(mMetrics->xHeight / 2.0f); // 50% of xHeight
    1:         mMetrics->underlineSize = 1;
    1:         mMetrics->underlineOffset = -ROUND((float)metrics.tmDescent * 0.30f); // 30% of descent
11765:         mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
11765:         mMetrics->emAscent = metrics.tmAscent - metrics.tmInternalLeading;
11765:         mMetrics->emDescent = metrics.tmDescent;
    1:     }
    1: 
    1:     mMetrics->internalLeading = metrics.tmInternalLeading;
    1:     mMetrics->externalLeading = metrics.tmExternalLeading;
    1:     mMetrics->maxHeight = metrics.tmHeight;
    1:     mMetrics->maxAscent = metrics.tmAscent;
    1:     mMetrics->maxDescent = metrics.tmDescent;
    1:     mMetrics->maxAdvance = metrics.tmMaxCharWidth;
    1:     mMetrics->aveCharWidth = PR_MAX(1, metrics.tmAveCharWidth);
14465:     // The font is monospace when TMPF_FIXED_PITCH is *not* set!
14465:     // See http://msdn2.microsoft.com/en-us/library/ms534202(VS.85).aspx
14465:     if (!(metrics.tmPitchAndFamily & TMPF_FIXED_PITCH)) {
14465:       mMetrics->maxAdvance = mMetrics->aveCharWidth;
14465:     }
    1: 
    1:     // Cache the width of a single space.
    1:     SIZE size;
18480:     GetTextExtentPoint32W(dc, L" ", 1, &size);
    1:     mMetrics->spaceWidth = ROUND(size.cx);
    1: 
15955:     // Cache the width of digit zero.
15955:     // XXX MSDN (http://msdn.microsoft.com/en-us/library/ms534223.aspx)
15955:     // does not say what the failure modes for GetTextExtentPoint32 are -
15955:     // is it safe to assume it will fail iff the font has no '0'?
19626:     if (GetTextExtentPoint32W(dc, L"0", 1, &size))
15955:         mMetrics->zeroOrAveCharWidth = ROUND(size.cx);
15955:     else
15955:         mMetrics->zeroOrAveCharWidth = mMetrics->aveCharWidth;
15955: 
 1295:     mSpaceGlyph = 0;
 1295:     if (metrics.tmPitchAndFamily & TMPF_TRUETYPE) {
 1295:         WORD glyph;
18480:         DWORD ret = GetGlyphIndicesW(dc, L" ", 1, &glyph,
 1295:                                      GGI_MARK_NONEXISTING_GLYPHS);
 1295:         if (ret != GDI_ERROR && glyph != 0xFFFF) {
 1295:             mSpaceGlyph = glyph;
 1295:         }
 1295:     }
 1295: 
    1:     SelectObject(dc, oldFont);
    1: 
    1:     ReleaseDC((HWND)nsnull, dc);
11765: 
19962:     SanitizeMetrics(mMetrics, GetFontEntry()->mIsBadUnderlineFont);
    1: }
    1: 
    1: void
13280: gfxWindowsFont::FillLogFont(gfxFloat aSize)
    1: {
19962:     FontEntry::FillLogFont(&mLogFont, GetFontEntry(), aSize, (GetStyle()->style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)));
    1: }
    1: 
    1: 
    1: nsString
    1: gfxWindowsFont::GetUniqueName()
    1: {
    1:     nsString uniqueName;
    1: 
    1:     // start with the family name
16418:     uniqueName.Assign(GetName());
    1: 
    1:     // append the weight code
    1:     if (mLogFont.lfWeight != 400) {
    1:         uniqueName.AppendLiteral(":");
    1:         uniqueName.AppendInt((PRInt32)mLogFont.lfWeight);
    1:     }
    1: 
    1:     // append italic?
    1:     if (mLogFont.lfItalic)
    1:         uniqueName.AppendLiteral(":Italic");
    1: 
    1:     if (mLogFont.lfUnderline)
    1:         uniqueName.AppendLiteral(":Underline");
    1: 
    1:     if (mLogFont.lfStrikeOut)
    1:         uniqueName.AppendLiteral(":StrikeOut");
    1: 
    1:     return uniqueName;
    1: }
    1: 
    1: void
    1: gfxWindowsFont::Draw(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,
    1:                      gfxContext *aContext, PRBool aDrawToPath, gfxPoint *aBaselineOrigin,
    1:                      Spacing *aSpacing)
    1: {
    1:     // XXX stuart may want us to do something faster here
    1:     gfxFont::Draw(aTextRun, aStart, aEnd, aContext, aDrawToPath, aBaselineOrigin,
    1:                   aSpacing);
    1: }
    1: 
25417: gfxFont::RunMetrics
25417: gfxWindowsFont::Measure(gfxTextRun *aTextRun,
25417:                         PRUint32 aStart, PRUint32 aEnd,
25417:                         BoundingBoxType aBoundingBoxType,
25417:                         gfxContext *aRefContext,
25417:                         Spacing *aSpacing)
25417: {
25417:     // if aBoundingBoxType is TIGHT_HINTED_OUTLINE_EXTENTS
25417:     // and the underlying cairo font may be antialiased,
25417:     // we need to create a copy in order to avoid getting cached extents
25417:     if (aBoundingBoxType == TIGHT_HINTED_OUTLINE_EXTENTS &&
25417:         mAntialiasOption != CAIRO_ANTIALIAS_NONE) {
25417:         nsRefPtr<gfxWindowsFont> tempFont =
25417:             new gfxWindowsFont(GetFontEntry(), GetStyle(), CAIRO_ANTIALIAS_NONE);
25417:         if (tempFont) {
25417:             return tempFont->Measure(aTextRun, aStart, aEnd,
25417:                                      TIGHT_HINTED_OUTLINE_EXTENTS,
25417:                                      aRefContext, aSpacing);
25417:         }
25417:     }
25417: 
25417:     return gfxFont::Measure(aTextRun, aStart, aEnd,
25417:                             aBoundingBoxType, aRefContext, aSpacing);
25417: }
25417: 
16418: FontEntry*
16418: gfxWindowsFont::GetFontEntry()
16418: {
16418:     return static_cast<FontEntry*> (mFontEntry.get()); 
16418: }
16418: 
 4304: PRBool
 6247: gfxWindowsFont::SetupCairoFont(gfxContext *aContext)
    1: {
 4304:     cairo_scaled_font_t *scaledFont = CairoScaledFont();
 5274:     if (cairo_scaled_font_status(scaledFont) != CAIRO_STATUS_SUCCESS) {
 5274:         // Don't cairo_set_scaled_font as that would propagate the error to
 5274:         // the cairo_t, precluding any further drawing.
 5274:         return PR_FALSE;
 5274:     }
 6247:     cairo_set_scaled_font(aContext->GetCairo(), scaledFont);
 4304:     return PR_TRUE;
 4304: }
    1: 
    1: /**********************************************************************
    1:  *
    1:  * class gfxWindowsFontGroup
    1:  *
    1:  **********************************************************************/
    1: 
  323: /**
  323:  * Look up the font in the gfxFont cache. If we don't find it, create one.
  323:  * In either case, add a ref, append it to the aFonts array, and return it ---
  323:  * except for OOM in which case we do nothing and return null.
  323:  */
14798: already_AddRefed<gfxWindowsFont>
14798: gfxWindowsFont::GetOrMakeFont(FontEntry *aFontEntry, const gfxFontStyle *aStyle)
  323: {
13649:     // because we know the FontEntry has the weight we really want, use it for matching
13649:     // things in the cache so we don't end up with things like 402 in there.
13649:     gfxFontStyle style(*aStyle);
13649:     style.weight = aFontEntry->mWeight;
13649:     // also pre-round the size if there is no size adjust
13649:     if (style.sizeAdjust == 0.0)
13649:         style.size = ROUND(style.size);
13649: 
16418:     nsRefPtr<gfxFont> font = gfxFontCache::GetCache()->Lookup(aFontEntry->Name(), &style);
  323:     if (!font) {
16418:         font = new gfxWindowsFont(aFontEntry, &style);
  323:         if (!font)
  323:             return nsnull;
  323:         gfxFontCache::GetCache()->AddNew(font);
  323:     }
  323:     gfxFont *f = nsnull;
  323:     font.swap(f);
  323:     return static_cast<gfxWindowsFont *>(f);
  323: }
  323: 
 2252: static PRBool
13280: AddFontNameToArray(const nsAString& aName,
    1:                    const nsACString& aGenericName,
    1:                    void *closure)
    1: {
    1:     if (!aName.IsEmpty()) {
14457:         nsTArray<nsString> *list = static_cast<nsTArray<nsString> *>(closure);
    1: 
13280:         if (list->IndexOf(aName) == list->NoIndex)
13280:             list->AppendElement(aName);
    1:     }
    1: 
    1:     return PR_TRUE;
    1: }
    1: 
19962: 
13280: void
13280: gfxWindowsFontGroup::GroupFamilyListToArrayList(nsTArray<nsRefPtr<FontEntry> > *list)
13280: {
14457:     nsAutoTArray<nsString, 15> fonts;
13280:     ForEachFont(AddFontNameToArray, &fonts);
13280: 
13280:     PRUint32 len = fonts.Length();
13280:     for (PRUint32 i = 0; i < len; ++i) {
19962:         nsRefPtr<FontEntry> fe;
19962:         
19962:         // first, look up in the user font set
19962:         gfxFontEntry *gfe;
19962:         PRBool needsBold;
19962:         if (mUserFontSet && (gfe = mUserFontSet->FindFontEntry(fonts[i], mStyle, needsBold))) {
19962:             // assume for now platform font if not SVG
19962:             fe = static_cast<FontEntry*> (gfe);
19962:         }
19962:     
19962:         // nothing in the user font set ==> check system fonts
19962:         if (!fe) {
19962:             fe = gfxWindowsPlatform::GetPlatform()->FindFontEntry(fonts[i], mStyle);
19962:         }
19962: 
19962:         // if found, add to the list
19962:         if (fe) {
13280:             list->AppendElement(fe);
13280:         }
13280:     }
19962: }
13280: 
13280: void
13280: gfxWindowsFontGroup::FamilyListToArrayList(const nsString& aFamilies,
13280:                                            const nsCString& aLangGroup,
13280:                                            nsTArray<nsRefPtr<FontEntry> > *list)
13280: {
14457:     nsAutoTArray<nsString, 15> fonts;
13280:     ForEachFont(aFamilies, aLangGroup, AddFontNameToArray, &fonts);
13280: 
13280:     PRUint32 len = fonts.Length();
13280:     for (PRUint32 i = 0; i < len; ++i) {
14457:         const nsString& str = fonts[i];
13578:         nsRefPtr<FontEntry> fe = gfxWindowsPlatform::GetPlatform()->FindFontEntry(str, mStyle);
13280:         list->AppendElement(fe);
13280:     }
13280: }
13280: 
19962: gfxWindowsFontGroup::gfxWindowsFontGroup(const nsAString& aFamilies, const gfxFontStyle *aStyle, gfxUserFontSet *aUserFontSet)
19962:     : gfxFontGroup(aFamilies, aStyle, aUserFontSet)
19962: {
19962:     InitFontList();
19962: }
19962: 
19962: gfxWindowsFontGroup::~gfxWindowsFontGroup()
19962: {
19962: }
19962: 
19962: gfxWindowsFont *
19962: gfxWindowsFontGroup::GetFontAt(PRInt32 i)
19962: {
21927:     // If it turns out to be hard for all clients that cache font
21927:     // groups to call UpdateFontList at appropriate times, we could
21927:     // instead consider just calling UpdateFontList from someplace
21927:     // more central (such as here).
21927:     NS_ASSERTION(!mUserFontSet || mCurrGeneration == GetGeneration(),
21927:                  "Whoever was caching this font group should have "
21927:                  "called UpdateFontList on it");
21927: 
19962:     if (!mFonts[i]) {
19962:         nsRefPtr<gfxWindowsFont> font =
19962:             gfxWindowsFont::GetOrMakeFont(mFontEntries[i], &mStyle);
19962:         mFonts[i] = font;
19962:     }
19962: 
19962:     return static_cast<gfxWindowsFont*>(mFonts[i].get());
19962: }
19962: 
19962: gfxFontGroup *
19962: gfxWindowsFontGroup::Copy(const gfxFontStyle *aStyle)
19962: {
19962:     return new gfxWindowsFontGroup(mFamilies, aStyle, mUserFontSet);
19962: }
19962: 
19962: void 
19962: gfxWindowsFontGroup::UpdateFontList()
19962: {
19962:     // if user font set is set, check to see if font list needs updating
19962:     if (mUserFontSet && mCurrGeneration != GetGeneration()) {
19962:         // xxx - can probably improve this to detect when all fonts were found, so no need to update list
19962:         mFonts.Clear();
19962:         mFontEntries.Clear();
19962:         InitFontList();
19962:         mCurrGeneration = GetGeneration();
19962:     }
19962: 
19962: }
19962: 
19962: void 
19962: gfxWindowsFontGroup::InitFontList()
    1: {
13280:     GroupFamilyListToArrayList(&mFontEntries);
    1: 
14798:     mFonts.AppendElements(mFontEntries.Length());
14798: 
14798:     // Ensure that the first font is usable. Precompute its metrics since
14798:     // we'll surely need them anyway.
14798:     while (mFontEntries.Length() > 0) {
14798:         nsRefPtr<gfxWindowsFont> font =
14798:             gfxWindowsFont::GetOrMakeFont(mFontEntries[0], &mStyle);
14798:         if (!font->IsValid()) {
14798:             mFontEntries.RemoveElementAt(0);
14798:             mFonts.RemoveElementAt(0);
14798:             continue;
14798:         }
14798:         mFonts[0] = font;
14798:         break;
14798:     }
14798: 
 5257:     if (mFontEntries.Length() == 0) {
15194:         // It is pretty important that we have at least one font, so
15194:         // try a few system fonts that should be there.
15194:         nsAutoString str;
    1:         HGDIOBJ hGDI = ::GetStockObject(DEFAULT_GUI_FONT);
    1:         LOGFONTW logFont;
15194:         if (hGDI && ::GetObjectW(hGDI, sizeof(logFont), &logFont)) {
15194:             str.AppendLiteral("\"");
15194:             str.Append(nsDependentString(logFont.lfFaceName));
15194:             str.AppendLiteral("\"");
    1:         }
15194: 
15194:         NONCLIENTMETRICSW ncm;
15194:         ncm.cbSize = sizeof(ncm);
15194:         BOOL status = ::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, 
15194:                                               sizeof(ncm), &ncm, 0);
15194:         if (status) {
15194:             str.AppendLiteral(",\"");
15194:             str.Append(nsDependentString(ncm.lfMessageFont.lfFaceName));
15194:             str.AppendLiteral("\"");
15194:         }
15194: 
15194:         FamilyListToArrayList(str, mStyle.langGroup, &mFontEntries);
15194: 
14798:         // Keep length of mFonts in sync with length of mFontEntries.
14798:         // Maybe we should eagerly set up mFonts[0] like we do above,
14798:         // but if the resulting gfxWindowsFont is invalid then we can't
14798:         // do much anyway. In that case the font will return zero metrics,
14798:         // its mUnknownCMAP will be set to true, and HasCharacter will
14798:         // just report false for all characters, so the fact that the font
14798:         // is bogus should not cause problems.
15194:         mFonts.AppendElements(mFontEntries.Length());
    1:     }
 2252: 
22991:     // force the underline offset to get recalculated
22991:     mUnderlineOffset = UNDERLINE_OFFSET_NOT_SET;
22991: }
22991: 
22991: gfxFloat 
22991: gfxWindowsFontGroup::GetUnderlineOffset()
22991: {
22991:     if (mUnderlineOffset != UNDERLINE_OFFSET_NOT_SET)
22991:         return mUnderlineOffset;
22991: 
22991:     // not yet initialized, need to calculate
13714:     if (!mStyle.systemFont) {
12989:         for (PRUint32 i = 0; i < mFontEntries.Length(); ++i) {
19962:             if (mFontEntries[i]->mIsBadUnderlineFont) {
12989:                 gfxFloat first = GetFontAt(0)->GetMetrics().underlineOffset;
12989:                 gfxFloat bad = GetFontAt(i)->GetMetrics().underlineOffset;
12989:                 mUnderlineOffset = PR_MIN(first, bad);
12989:                 break;
12989:             }
12989:         }
    1:     }
    1: 
22991:     if (mUnderlineOffset == UNDERLINE_OFFSET_NOT_SET)
22991:         mUnderlineOffset = GetFontAt(0)->GetMetrics().underlineOffset;
22991: 
22991:     return mUnderlineOffset;
    6: }
    6: 
 4032: static PRBool
 4032: CanTakeFastPath(PRUint32 aFlags)
 4032: {
 4032:     // Can take fast path only if OPTIMIZE_SPEED is set and IS_RTL isn't
 4032:     // We need to always use Uniscribe for RTL text, in case glyph mirroring is required
 4032:     return (aFlags &
 4032:             (gfxTextRunFactory::TEXT_OPTIMIZE_SPEED | gfxTextRunFactory::TEXT_IS_RTL)) ==
 4032:         gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
 4032: }
 4032: 
    1: gfxTextRun *
    1: gfxWindowsFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,
 1295:                                  const Parameters *aParams, PRUint32 aFlags)
    1: {
  642:     // XXX comment out the assertion for now since it fires too much
 1295:     //    NS_ASSERTION(!(mFlags & TEXT_NEED_BOUNDING_BOX),
  642:     //                 "Glyph extents not yet supported");
    1: 
 8084:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
    1:     if (!textRun)
    1:         return nsnull;
 1153:     NS_ASSERTION(aParams->mContext, "MakeTextRun called without a gfxContext");
    1: 
    1:     textRun->RecordSurrogates(aString);
    1:     
    1: #ifdef FORCE_UNISCRIBE
    1:     const PRBool isComplex = PR_TRUE;
    1: #else
 4032:     const PRBool isComplex = !CanTakeFastPath(aFlags) ||
 4032:                              ScriptIsComplex(aString, aLength, SIC_COMPLEX) == S_OK;
    1: #endif
    1:     if (isComplex)
    1:         InitTextRunUniscribe(aParams->mContext, textRun, aString, aLength);
    1:     else
    1:         InitTextRunGDI(aParams->mContext, textRun, aString, aLength);
    1: 
 6247:     textRun->FetchGlyphExtents(aParams->mContext);
 6247: 
    1:     return textRun;
    1: }
    1: 
    1: gfxTextRun *
    1: gfxWindowsFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,
 1295:                                  const Parameters *aParams, PRUint32 aFlags)
    1: {
 1295:     NS_ASSERTION(aFlags & TEXT_IS_8BIT, "should be marked 8bit");
 1295:  
 8084:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
    1:     if (!textRun)
    1:         return nsnull;
 1153:     NS_ASSERTION(aParams->mContext, "MakeTextRun called without a gfxContext");
    1: 
    1: #ifdef FORCE_UNISCRIBE
    1:     const PRBool isComplex = PR_TRUE;
    1: #else
 4032:     const PRBool isComplex = !CanTakeFastPath(aFlags);
    1: #endif
    1: 
  837:     /* We can only call GDI "A" functions if this is a true 7bit ASCII string,
  837:        because they interpret code points from 0x80-0xFF as if they were
  837:        in the system code page. */
 1295:     if (!isComplex && (aFlags & TEXT_IS_ASCII)) {
  837:         InitTextRunGDI(aParams->mContext, textRun,
  837:                        reinterpret_cast<const char*>(aString), aLength);
  837:     }
  837:     else {
    1:         nsDependentCSubstring cString(reinterpret_cast<const char*>(aString),
    1:                                   reinterpret_cast<const char*>(aString + aLength));
    1:         nsAutoString utf16;
    1:         AppendASCIItoUTF16(cString, utf16);
  837:         if (isComplex) {
    1:             InitTextRunUniscribe(aParams->mContext, textRun, utf16.get(), aLength);
    1:         } else {
  837:             InitTextRunGDI(aParams->mContext, textRun, utf16.get(), aLength);
  837:         }
    1:     }
    1: 
 6247:     textRun->FetchGlyphExtents(aParams->mContext);
 6247: 
    1:     return textRun;
    1: }
    1: 
  127: /**
 4363:  * Set the font in the given DC.  If something goes wrong or if the
 4363:  * font is not a Truetype font (hence GetGlyphIndices may be buggy)
 4363:  * then we're not successful and return PR_FALSE, otherwise PR_TRUE.
  127:  */
 4363: static PRBool
 4363: SetupDCFont(HDC dc, gfxWindowsFont *aFont)
    1: {
  127:     HFONT hfont = aFont->GetHFONT();
  127:     if (!hfont)
 4363:         return PR_FALSE;
  127:     SelectObject(dc, hfont);
    1: 
13449:     // GetGlyphIndices is buggy for bitmap and vector fonts, so send them to uniscribe
13449:     // Also sent Symbol fonts through Uniscribe as it has special code to deal with them
15022:     if (!aFont->GetFontEntry()->IsTrueType() || aFont->GetFontEntry()->mSymbolFont)
 4363:         return PR_FALSE;
  127: 
 4363:     return PR_TRUE;
    1: }
    1: 
  127: static PRBool
  127: IsAnyGlyphMissing(WCHAR *aGlyphs, PRUint32 aLength)
    1: {
  127:     PRUint32 i;
  127:     for (i = 0; i < aLength; ++i) {
  127:         if (aGlyphs[i] == 0xFFFF)
  127:             return PR_TRUE;
  127:     }
  127:     return PR_FALSE;
  127: }
  127: 
  127: static PRBool
  127: SetupTextRunFromGlyphs(gfxTextRun *aRun, WCHAR *aGlyphs, HDC aDC,
  127:                        gfxWindowsFont *aFont)
  127: {
  127:     PRUint32 length = aRun->GetLength();
  127:     if (IsAnyGlyphMissing(aGlyphs, length))
  127:         return PR_FALSE;
  127: 
  127:     SIZE size;
 6076:     nsAutoTArray<int,500> partialWidthArray;
 6076:     if (!partialWidthArray.SetLength(length))
  127:         return PR_FALSE;
  127:     BOOL success = GetTextExtentExPointI(aDC,
  341:                                          (WORD*) aGlyphs,
  127:                                          length,
  127:                                          INT_MAX,
  127:                                          NULL,
 6076:                                          partialWidthArray.Elements(),
  127:                                          &size);
  127:     if (!success)
  127:         return PR_FALSE;
  127: 
  127:     aRun->AddGlyphRun(aFont, 0);
  127: 
    1:     gfxTextRun::CompressedGlyph g;
    1:     PRUint32 i;
  127:     PRInt32 lastWidth = 0;
  127:     PRUint32 appUnitsPerDevPixel = aRun->GetAppUnitsPerDevUnit();
    1:     for (i = 0; i < length; ++i) {
  127:         PRInt32 advancePixels = partialWidthArray[i] - lastWidth;
  127:         lastWidth = partialWidthArray[i];
  127:         PRInt32 advanceAppUnits = advancePixels*appUnitsPerDevPixel;
    1:         WCHAR glyph = aGlyphs[i];
 3118:         NS_ASSERTION(!gfxFontGroup::IsInvalidChar(aRun->GetChar(i)),
 3118:                      "Invalid character detected!");
 3118:         if (advanceAppUnits >= 0 &&
    1:             gfxTextRun::CompressedGlyph::IsSimpleAdvance(advanceAppUnits) &&
    1:             gfxTextRun::CompressedGlyph::IsSimpleGlyphID(glyph)) {
 7715:             aRun->SetSimpleGlyph(i, g.SetSimpleGlyph(advanceAppUnits, glyph));
    1:         } else {
    1:             gfxTextRun::DetailedGlyph details;
    1:             details.mGlyphID = glyph;
    1:             details.mAdvance = advanceAppUnits;
    1:             details.mXOffset = 0;
    1:             details.mYOffset = 0;
 7715:             aRun->SetGlyphs(i, g.SetComplex(PR_TRUE, PR_TRUE, 1), &details);
    1:         }
    1:     }
    1:     return PR_TRUE;
    1: }
    1: 
    1: void
    1: gfxWindowsFontGroup::InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun,
    1:                                     const char *aString, PRUint32 aLength)
    1: {
 2252:     nsRefPtr<gfxWindowsFont> font = GetFontAt(0);
 4363:     DCFromContext dc(aContext);
 4363:     if (SetupDCFont(dc, font)) {
 6076:         nsAutoTArray<WCHAR,500> glyphArray;
 6076:         if (!glyphArray.SetLength(aLength))
    1:             return;
    1: 
 6076:         DWORD ret = GetGlyphIndicesA(dc, aString, aLength, (WORD*) glyphArray.Elements(),
  127:                                      GGI_MARK_NONEXISTING_GLYPHS);
  127:         if (ret != GDI_ERROR &&
 6076:             SetupTextRunFromGlyphs(aRun, glyphArray.Elements(), dc, font))
  127:             return;
  127:     }
  127: 
    1:     nsDependentCSubstring cString(aString, aString + aLength);
    1:     nsAutoString utf16;
    1:     AppendASCIItoUTF16(cString, utf16);
    1:     InitTextRunUniscribe(aContext, aRun, utf16.get(), aLength);
    1: }
    1: 
    1: void
    1: gfxWindowsFontGroup::InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun,
    1:                                     const PRUnichar *aString, PRUint32 aLength)
    1: {
 2252:     nsRefPtr<gfxWindowsFont> font = GetFontAt(0);
 4363:     DCFromContext dc(aContext);
 4363:     if (SetupDCFont(dc, font)) {
 6076:         nsAutoTArray<WCHAR,500> glyphArray;
 6076:         if (!glyphArray.SetLength(aLength))
    1:             return;
    1: 
 6076:         DWORD ret = GetGlyphIndicesW(dc, aString, aLength, (WORD*) glyphArray.Elements(),
  127:                                      GGI_MARK_NONEXISTING_GLYPHS);
  127:         if (ret != GDI_ERROR &&
 6076:             SetupTextRunFromGlyphs(aRun, glyphArray.Elements(), dc, font))
    1:             return;
    1:     }
    1: 
  127:     InitTextRunUniscribe(aContext, aRun, aString, aLength);
    1: }
    1: 
    1: /*******************
    1:  * Uniscribe
    1:  *******************/
    1: 
    1: /* we map primary language id's to this to look up language codes */
    1: struct ScriptPropertyEntry {
    1:     const char *value;
    1:     const char *langCode;
    1: };
    1: 
    1: static const struct ScriptPropertyEntry gScriptToText[] =
    1: {
    1:     { nsnull, nsnull },
13578:     { "LANG_ARABIC",     "ar" }, // ara
    1:     { "LANG_BULGARIAN",  "bul" },
    1:     { "LANG_CATALAN",    "cat" },
    1:     { "LANG_CHINESE",    "zh-CN" }, //XXX right lang code?
    1:     { "LANG_CZECH",      "cze" }, // cze/ces
    1:     { "LANG_DANISH",     "dan" },
    1:     { "LANG_GERMAN",     "ger" }, // ger/deu
    1:     { "LANG_GREEK",      "el" }, // gre/ell
    1:     { "LANG_ENGLISH",    "x-western" },
    1:     { "LANG_SPANISH",    "spa" },
    1:     { "LANG_FINNISH",    "fin" },
    1:     { "LANG_FRENCH",     "fre" }, // fre/fra
    1:     { "LANG_HEBREW",     "he" }, // heb
    1:     { "LANG_HUNGARIAN",  "hun" },
    1:     { "LANG_ICELANDIC",  "ice" }, // ice/isl
    1:     { "LANG_ITALIAN",    "ita" },
    1:     { "LANG_JAPANESE",   "ja" }, // jpn
    1:     { "LANG_KOREAN",     "ko" }, // kor
    1:     { "LANG_DUTCH",      "dut" }, // dut/nld
    1:     { "LANG_NORWEGIAN",  "nor" },
    1:     { "LANG_POLISH",     "pol" },
    1:     { "LANG_PORTUGUESE", "por" },
    1:     { nsnull, nsnull },
    1:     { "LANG_ROMANIAN",   "rum" }, // rum/ron
    1:     { "LANG_RUSSIAN",    "rus" },
    1:     { "LANG_SERBIAN",    "scc" }, // scc/srp
    1:     { "LANG_SLOVAK",     "slo" }, // slo/slk
    1:     { "LANG_ALBANIAN",   "alb" }, // alb/sqi
    1:     { "LANG_SWEDISH",    "swe" },
    1:     { "LANG_THAI",       "th" }, // tha
    1:     { "LANG_TURKISH",    "tr" }, // tur
    1:     { "LANG_URDU",       "urd" },
    1:     { "LANG_INDONESIAN", "ind" },
    1:     { "LANG_UKRAINIAN",  "ukr" },
    1:     { "LANG_BELARUSIAN", "bel" },
    1:     { "LANG_SLOVENIAN",  "slv" },
    1:     { "LANG_ESTONIAN",   "est" },
    1:     { "LANG_LATVIAN",    "lav" },
    1:     { "LANG_LITHUANIAN", "lit" },
    1:     { nsnull, nsnull },
    1:     { "LANG_FARSI",      "per" }, // per/fas
    1:     { "LANG_VIETNAMESE", "vie" },
    1:     { "LANG_ARMENIAN",   "x-armn" }, // arm/hye
    1:     { "LANG_AZERI",      "aze" },
    1:     { "LANG_BASQUE",     "baq" }, // baq/eus
    1:     { nsnull, nsnull },
    1:     { "LANG_MACEDONIAN", "mac" }, // mac/mkd
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { "LANG_AFRIKAANS",  "afr" },
    1:     { "LANG_GEORGIAN",   "x-geor" }, // geo
    1:     { "LANG_FAEROESE",   "fao" },
    1:     { "LANG_HINDI",      "x-devanagari" }, // hin
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { "LANG_MALAY",      "may" }, // may/msa
    1:     { "LANG_KAZAK",      "kaz" }, // listed as kazakh?
    1:     { "LANG_KYRGYZ",     "kis" },
    1:     { "LANG_SWAHILI",    "swa" },
    1:     { nsnull, nsnull },
    1:     { "LANG_UZBEK",      "uzb" },
    1:     { "LANG_TATAR",      "tat" },
    1:     { "LANG_BENGALI",    "x-beng" }, // ben
    1:     { "LANG_PUNJABI",    "x-guru" }, // pan -- XXX x-guru is for Gurmukhi which isn't just Punjabi
    1:     { "LANG_GUJARATI",   "x-gujr" }, // guj
13885:     { "LANG_ORIYA",      "x-orya" }, // ori
    1:     { "LANG_TAMIL",      "x-tamil" }, // tam
13885:     { "LANG_TELUGU",     "x-telu" },  //tel
13885:     { "LANG_KANNADA",    "x-knda" },  // kan
    1:     { "LANG_MALAYALAM",  "x-mlym" }, // mal
13885:     { "LANG_ASSAMESE",   "x-beng" },    // asm
13885:     { "LANG_MARATHI",    "x-devanagari" }, // mar
13885:     { "LANG_SANSKRIT",   "x-devanagari" }, // san
    1:     { "LANG_MONGOLIAN",  "mon" },
    1:     { "TIBETAN",         "tib" }, // tib/bod
    1:     { nsnull, nsnull },
    1:     { "KHMER",           "x-khmr" }, // khm
    1:     { "LAO",             "lao" },
    1:     { "MYANMAR",         "bur" }, // bur/mya
    1:     { "LANG_GALICIAN",   "glg" },
    1:     { "LANG_KONKANI",    "kok" },
    1:     { "LANG_MANIPURI",   "mni" },
13885:     { "LANG_SINDHI",     "snd" },
    1:     { "LANG_SYRIAC",     "syr" },
13885:     { "SINHALESE",       "x-sinh" }, // sin
    1:     { "CHEROKEE",        "chr" },
    1:     { "INUKTITUT",       "x-cans" }, // iku
    1:     { "ETHIOPIC",        "x-ethi" }, // amh -- this is both Amharic and Tigrinya
    1:     { nsnull, nsnull },
13885:     { "LANG_KASHMIRI",   "kas" },
    1:     { "LANG_NEPALI",     "x-devanagari" }, // nep
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { "LANG_DIVEHI",     "div" }
    1: };
    1: 
    1: static const char *sCJKLangGroup[] = {
    1:     "ja",
    1:     "ko",
    1:     "zh-CN",
    1:     "zh-HK",
    1:     "zh-TW"
    1: };
    1: 
    1: #define COUNT_OF_CJK_LANG_GROUP 5
    1: #define CJK_LANG_JA    sCJKLangGroup[0]
    1: #define CJK_LANG_KO    sCJKLangGroup[1]
    1: #define CJK_LANG_ZH_CN sCJKLangGroup[2]
    1: #define CJK_LANG_ZH_HK sCJKLangGroup[3]
    1: #define CJK_LANG_ZH_TW sCJKLangGroup[4]
    1: 
    1: #define STATIC_STRING_LENGTH 100
    1: 
 7625: #define ESTIMATE_MAX_GLYPHS(L) (((3 * (L)) >> 1) + 16)
 7625: 
    1: class UniscribeItem
    1: {
    1: public:
    1:     UniscribeItem(gfxContext *aContext, HDC aDC,
    1:                   const PRUnichar *aString, PRUint32 aLength,
    1:                   SCRIPT_ITEM *aItem,
    1:                   gfxWindowsFontGroup *aGroup) :
 2252:         mContext(aContext), mDC(aDC), mRangeString(nsnull), mRangeLength(0),
 2252:         mItemString(aString), mItemLength(aLength), 
 2252:         mAlternativeString(nsnull), mScriptItem(aItem),
    1:         mScript(aItem->a.eScript), mGroup(aGroup),
 7625:         mNumGlyphs(0), mMaxGlyphs(ESTIMATE_MAX_GLYPHS(aLength)),
22991:         mFontSelected(PR_FALSE), mForceGDIPlace(PR_FALSE)
    1:     {
 7625:         NS_ASSERTION(mMaxGlyphs < 65535, "UniscribeItem is too big, ScriptShape() will fail!");
 6076:         mGlyphs.SetLength(mMaxGlyphs);
 6076:         mClusters.SetLength(mItemLength + 1);
 6076:         mAttr.SetLength(mMaxGlyphs);
    1:     }
    1: 
    1:     ~UniscribeItem() {
    1:         free(mAlternativeString);
    1:     }
    1: 
    1:     /* possible return values:
 1959:      * S_OK - things succeeded
 1959:      * GDI_ERROR - things failed to shape.  Might want to try again after calling DisableShaping()
    1:      */
12992: 
12992:     HRESULT ShapeUniscribe() {
    1:         HRESULT rv;
    1:         HDC shapeDC = nsnull;
    1: 
 2252:         const PRUnichar *str = mAlternativeString ? mAlternativeString : mRangeString;
 1959: 
 6299:         mScriptItem->a.fLogicalOrder = PR_TRUE; 
 5308:         SCRIPT_ANALYSIS sa = mScriptItem->a;
 5308:         /*
 5308:           fLinkBefore and fLinkAfter in the SCRIPT_ANALYSIS structure refer to
 5308:           the whole item, so if the current range begins after the beginning
 5308:           of the item or ends before the end of the item, we need to override
 5308:           them here.
 5308:           This assumes that we won't split an item into ranges between two
 5308:           characters that need to be shaped together.
 5308:         */
 5308:         if (mRangeString > mItemString)
 5308:             sa.fLinkBefore = PR_FALSE;
 5308:         if (mRangeString + mRangeLength < mItemString + mItemLength)
 5308:             sa.fLinkAfter = PR_FALSE;
 5308: 
    1:         while (PR_TRUE) {
  282: 
    1:             rv = ScriptShape(shapeDC, mCurrentFont->ScriptCache(),
 2252:                              str, mRangeLength,
 5308:                              mMaxGlyphs, &sa,
 6076:                              mGlyphs.Elements(), mClusters.Elements(),
 6076:                              mAttr.Elements(), &mNumGlyphs);
    1: 
    1:             if (rv == E_OUTOFMEMORY) {
16654:                 mMaxGlyphs *= 2;
 6076:                 mGlyphs.SetLength(mMaxGlyphs);
 6076:                 mAttr.SetLength(mMaxGlyphs);
    1:                 continue;
    1:             }
    1: 
22991:             // Uniscribe can't do shaping with some fonts, so it sets the 
22991:             // fNoGlyphIndex flag in the SCRIPT_ANALYSIS structure to indicate
22991:             // this.  This occurs with CFF fonts loaded with 
22991:             // AddFontMemResourceEx but it's not clear what the other cases
22991:             // are, so just log a warning for now.
22991:             // see http://msdn.microsoft.com/en-us/library/ms776520(VS.85).aspx
22991: 
22991:             if (sa.fNoGlyphIndex) {
22991:                 mForceGDIPlace = PR_TRUE;
22991:                 NS_WARNING("Uniscribe refuses to shape with given font");
22991:                 return ShapeGDI();
22991:             }
22991: 
    1:             if (rv == E_PENDING) {
 4363:                 if (shapeDC == mDC) {
 4363:                     // we already tried this once, something failed, give up
14918:                     return E_PENDING;
 4363:                 }
 4363: 
    1:                 SelectFont();
    1: 
    1:                 shapeDC = mDC;
    1:                 continue;
    1:             }
12992: 
    1:             return rv;
    1:         }
    1:     }
    1: 
12992:     HRESULT ShapeGDI() {
12992:         SelectFont();
12992: 
12992:         mNumGlyphs = mRangeLength;
12992:         GetGlyphIndicesW(mDC, mRangeString, mRangeLength,
12992:                          (WORD*) mGlyphs.Elements(),
12992:                          GGI_MARK_NONEXISTING_GLYPHS);
12992: 
13439:         for (PRUint32 i = 0; i < mRangeLength; ++i)
12992:             mClusters[i] = i;
12992: 
12992:         return S_OK;
12992:     }
12992: 
12992:     HRESULT Shape() {
13439:         // Skip Uniscribe for fonts that need GDI
13439:         if (mCurrentFont->GetFontEntry()->mForceGDI)
12992:             return ShapeGDI();
12992: 
12992:         return ShapeUniscribe();
12992:     }
12992: 
    1:     PRBool ShapingEnabled() {
    1:         return (mScriptItem->a.eScript != SCRIPT_UNDEFINED);
    1:     }
    1:     void DisableShaping() {
    1:         mScriptItem->a.eScript = SCRIPT_UNDEFINED;
    1:         // Note: If we disable the shaping by using SCRIPT_UNDEFINED and
    1:         // the string has the surrogate pair, ScriptShape API is
    1:         // *sometimes* crashed. Therefore, we should replace the surrogate
    1:         // pair to U+FFFD. See bug 341500.
    1:         GenerateAlternativeString();
    1:     }
 2252:     void EnableShaping() {
 2252:         mScriptItem->a.eScript = mScript;
 2252:         if (mAlternativeString) {
 2252:             free(mAlternativeString);
 2252:             mAlternativeString = nsnull;
 1959:         }
  282:     }
  282: 
  282:     PRBool IsGlyphMissing(SCRIPT_FONTPROPERTIES *aSFP, PRUint32 aGlyphIndex) {
13097:         PRBool missing = PR_FALSE;
13439:         if (GetCurrentFont()->GetFontEntry()->mForceGDI) {
13439:             // Our GDI path marks missing glyphs as 0xFFFF. So just look for that.
13097:             if (mGlyphs[aGlyphIndex] == 0xFFFF)
13097:                 missing = PR_TRUE;
13097:         } else if (mGlyphs[aGlyphIndex] == aSFP->wgDefault) {
13097:             missing = PR_TRUE;
13097:         }
13097:         return missing;
    1:     }
    1: 
11748: 
11748:     HRESULT PlaceUniscribe() {
    1:         HRESULT rv;
    1:         HDC placeDC = nsnull;
    1: 
    1:         while (PR_TRUE) {
    1:             rv = ScriptPlace(placeDC, mCurrentFont->ScriptCache(),
 6076:                              mGlyphs.Elements(), mNumGlyphs,
 6076:                              mAttr.Elements(), &mScriptItem->a,
 6076:                              mAdvances.Elements(), mOffsets.Elements(), NULL);
    1: 
    1:             if (rv == E_PENDING) {
    1:                 SelectFont();
    1:                 placeDC = mDC;
    1:                 continue;
    1:             }
    1: 
    1:             break;
    1:         }
    1: 
    1:         return rv;
    1:     }
    1: 
11748:     HRESULT PlaceGDI() {
11748:         SelectFont();
11748: 
11748:         nsAutoTArray<int,500> partialWidthArray;
14918:         // Callers incorrectly assume this code is infallible,
14918:         // so we must abort on this OOM condition.
11748:         if (!partialWidthArray.SetLength(mNumGlyphs))
14918:             PR_Abort();
11748:         SIZE size;
11748: 
11748:         GetTextExtentExPointI(mDC,
11748:                               (WORD*) mGlyphs.Elements(),
11748:                               mNumGlyphs,
11748:                               INT_MAX,
11748:                               NULL,
11748:                               partialWidthArray.Elements(),
11748:                               &size);
11748: 
11748:         PRInt32 lastWidth = 0;
11748: 
11748:         for (PRUint32 i = 0; i < mNumGlyphs; i++) {
11748:             mAdvances[i] = partialWidthArray[i] - lastWidth;
11748:             lastWidth = partialWidthArray[i];
11748:             mOffsets[i].du = mOffsets[i].dv = 0;
11748:         }
11748:         return 0;
11748:     }
11748: 
11748:     HRESULT Place() {
11748:         mOffsets.SetLength(mNumGlyphs);
11748:         mAdvances.SetLength(mNumGlyphs);
11748: 
22991:         if (mForceGDIPlace)
22991:             return PlaceGDI();
22991: 
11748:         PRBool allCJK = PR_TRUE;
12992: 
13439:         // Some fonts don't get along with Uniscribe so we'll use GDI to
13439:         // render them.
13439:         if (!mCurrentFont->GetFontEntry()->mForceGDI) {
11748:             for (PRUint32 i = 0; i < mRangeLength; i++) {
11748:                 const PRUnichar ch = mRangeString[i];
11748:                 if (ch == ' ' || FindCharUnicodeRange(ch) == kRangeSetCJK)
11748:                     continue;
11748: 
11748:                 allCJK = PR_FALSE;
11748:                 break;
11748:             }
12992:         }
11748: 
13879:         if (allCJK)
11748:             return PlaceGDI();
11748: 
11748:         return PlaceUniscribe();
11748:     }
11748: 
    1:     const SCRIPT_PROPERTIES *ScriptProperties() {
    1:         /* we can use this to figure out in some cases the language of the item */
    1:         static const SCRIPT_PROPERTIES **gScriptProperties;
    1:         static int gMaxScript = -1;
    1: 
    1:         if (gMaxScript == -1) {
    1:             ScriptGetProperties(&gScriptProperties, &gMaxScript);
    1:         }
    1:         return gScriptProperties[mScript];
    1:     }
    1: 
    1:     void ScriptFontProperties(SCRIPT_FONTPROPERTIES *sfp) {
    1:         HRESULT rv;
    1: 
    1:         memset(sfp, 0, sizeof(SCRIPT_FONTPROPERTIES));
    1:         sfp->cBytes = sizeof(SCRIPT_FONTPROPERTIES);
    1:         rv = ScriptGetFontProperties(NULL, mCurrentFont->ScriptCache(),
    1:                                      sfp);
    1:         if (rv == E_PENDING) {
    1:             SelectFont();
    1:             rv = ScriptGetFontProperties(mDC, mCurrentFont->ScriptCache(),
    1:                                          sfp);
    1:         }
    1:     }
    1: 
    1:     void SetupClusterBoundaries(gfxTextRun *aRun, PRUint32 aOffsetInRun) {
    1:         if (aRun->GetFlags() & gfxTextRunFactory::TEXT_IS_8BIT)
    1:             return;
    1: 
    1:         nsAutoTArray<SCRIPT_LOGATTR,STATIC_STRING_LENGTH> logAttr;
 2252:         if (!logAttr.AppendElements(mRangeLength))
    1:             return;
 2252:         HRESULT rv = ScriptBreak(mRangeString, mRangeLength,
 2252:                                  &mScriptItem->a, logAttr.Elements());
    1:         if (FAILED(rv))
    1:             return;
    1:         gfxTextRun::CompressedGlyph g;
  277:         // The first character is never inside a cluster. Windows might tell us
  277:         // that it should be, but we have no before-character to cluster
  277:         // it with so we just can't cluster it. So skip it here.
 2252:         for (PRUint32 i = 1; i < mRangeLength; ++i) {
    1:             if (!logAttr[i].fCharStop) {
 7715:                 aRun->SetGlyphs(i + aOffsetInRun, g.SetComplex(PR_FALSE, PR_TRUE, 0), nsnull);
    1:             }
    1:         }
    1:     }
    1: 
    1:     void SaveGlyphs(gfxTextRun *aRun) {
 2252:         PRUint32 offsetInRun = mScriptItem->iCharPos + (mRangeString - mItemString);
    1:         SetupClusterBoundaries(aRun, offsetInRun);
    1: 
  132:         aRun->AddGlyphRun(GetCurrentFont(), offsetInRun);
  132: 
    1:         // XXX We should store this in the item and only fetch it once
    1:         SCRIPT_FONTPROPERTIES sfp;
    1:         ScriptFontProperties(&sfp);
    1: 
    1:         PRUint32 offset = 0;
    1:         nsAutoTArray<gfxTextRun::DetailedGlyph,1> detailedGlyphs;
    1:         gfxTextRun::CompressedGlyph g;
    1:         const PRUint32 appUnitsPerDevUnit = aRun->GetAppUnitsPerDevUnit();
 2252:         while (offset < mRangeLength) {
    1:             PRUint32 runOffset = offsetInRun + offset;
    1:             if (offset > 0 && mClusters[offset] == mClusters[offset - 1]) {
 7715:                 g.SetComplex(aRun->IsClusterStart(runOffset), PR_FALSE, 0);
 7715:                 aRun->SetGlyphs(runOffset, g, nsnull);
    1:             } else {
    1:                 // Count glyphs for this character
    1:                 PRUint32 k = mClusters[offset];
    1:                 PRUint32 glyphCount = mNumGlyphs - k;
    1:                 PRUint32 nextClusterOffset;
  282:                 PRBool missing = IsGlyphMissing(&sfp, k);
 2252:                 for (nextClusterOffset = offset + 1; nextClusterOffset < mRangeLength; ++nextClusterOffset) {
    1:                     if (mClusters[nextClusterOffset] > k) {
    1:                         glyphCount = mClusters[nextClusterOffset] - k;
    1:                         break;
    1:                     }
    1:                 }
    1:                 PRUint32 j;
    1:                 for (j = 1; j < glyphCount; ++j) {
  282:                     if (IsGlyphMissing(&sfp, k + j)) {
    1:                         missing = PR_TRUE;
    1:                     }
    1:                 }
    1:                 PRInt32 advance = mAdvances[k]*appUnitsPerDevUnit;
    1:                 WORD glyph = mGlyphs[k];
 3119:                 NS_ASSERTION(!gfxFontGroup::IsInvalidChar(mRangeString[offset]),
 3119:                              "invalid character detected");
 3119:                 if (missing) {
 6135:                     if (NS_IS_HIGH_SURROGATE(mRangeString[offset]) &&
 6135:                         offset + 1 < mRangeLength &&
 6135:                         NS_IS_LOW_SURROGATE(mRangeString[offset + 1])) {
 6135:                         aRun->SetMissingGlyph(runOffset,
 6135:                                               SURROGATE_TO_UCS4(mRangeString[offset],
 6135:                                                                 mRangeString[offset + 1]));
 6135:                     } else {
 2252:                         aRun->SetMissingGlyph(runOffset, mRangeString[offset]);
 6135:                     }
    1:                 } else if (glyphCount == 1 && advance >= 0 &&
    1:                     mOffsets[k].dv == 0 && mOffsets[k].du == 0 &&
    1:                     gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&
    1:                     gfxTextRun::CompressedGlyph::IsSimpleGlyphID(glyph)) {
 7715:                     aRun->SetSimpleGlyph(runOffset, g.SetSimpleGlyph(advance, glyph));
    1:                 } else {
    1:                     if (detailedGlyphs.Length() < glyphCount) {
    1:                         if (!detailedGlyphs.AppendElements(glyphCount - detailedGlyphs.Length()))
    1:                             return;
    1:                     }
    1:                     PRUint32 i;
    1:                     for (i = 0; i < glyphCount; ++i) {
    1:                         gfxTextRun::DetailedGlyph *details = &detailedGlyphs[i];
    1:                         details->mGlyphID = mGlyphs[k + i];
    1:                         details->mAdvance = mAdvances[k + i]*appUnitsPerDevUnit;
  780:                         details->mXOffset = float(mOffsets[k + i].du)*appUnitsPerDevUnit*aRun->GetDirection();
24333:                         details->mYOffset = - float(mOffsets[k + i].dv)*appUnitsPerDevUnit;
    1:                     }
 7715:                     aRun->SetGlyphs(runOffset,
 7715:                         g.SetComplex(PR_TRUE, PR_TRUE, glyphCount), detailedGlyphs.Elements());
    1:                 }
    1:             }
    1:             ++offset;
    1:         }
    1:     }
    1: 
    1:     void SetCurrentFont(gfxWindowsFont *aFont) {
    1:         if (mCurrentFont != aFont) {
    1:             mCurrentFont = aFont;
 4304:             cairo_scaled_font_t *scaledFont = mCurrentFont->CairoScaledFont();
 4304:             cairo_win32_scaled_font_done_font(scaledFont);
    1:             mFontSelected = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     gfxWindowsFont *GetCurrentFont() {
    1:         return mCurrentFont;
    1:     }
    1: 
    1:     void SelectFont() {
    1:         if (mFontSelected)
    1:             return;
    1: 
    1:         cairo_t *cr = mContext->GetCairo();
    1: 
    1:         cairo_set_font_face(cr, mCurrentFont->CairoFontFace());
    1:         cairo_set_font_size(cr, mCurrentFont->GetAdjustedSize());
 4304:         cairo_scaled_font_t *scaledFont = mCurrentFont->CairoScaledFont();
 4304:         cairo_win32_scaled_font_select_font(scaledFont, mDC);
    1: 
    1:         mFontSelected = PR_TRUE;
    1:     }
    1: 
16418:     nsTArray<gfxTextRange>& Ranges() { return mRanges; }
 2252: 
 2252:     void SetRange(PRUint32 i) {
14798:         nsRefPtr<gfxWindowsFont> font;
 2252:         if (mRanges[i].font)
16418:             font = static_cast<gfxWindowsFont*> (mRanges[i].font.get());
 2252:         else
14798:             font = mGroup->GetFontAt(0);
 2252: 
 2252:         SetCurrentFont(font);
 2252: 
 2252:         mRangeString = mItemString + mRanges[i].start;
 2252:         mRangeLength = mRanges[i].Length();
 2252:     }
 2252: 
 2252: 
    1: private:
    1: 
    1:     void GenerateAlternativeString() {
    1:         if (mAlternativeString)
    1:             free(mAlternativeString);
 2252:         mAlternativeString = (PRUnichar *)malloc(mRangeLength * sizeof(PRUnichar));
 7030:         if (!mAlternativeString)
 7030:             return;
 2252:         memcpy((void *)mAlternativeString, (const void *)mRangeString,
 2252:                mRangeLength * sizeof(PRUnichar));
 2308:         for (PRUint32 i = 0; i < mRangeLength; i++) {
 2252:             if (NS_IS_HIGH_SURROGATE(mRangeString[i]) || NS_IS_LOW_SURROGATE(mRangeString[i]))
    1:                 mAlternativeString[i] = PRUnichar(0xFFFD);
    1:         }
    1:     }
 1959: 
    1: private:
    1:     nsRefPtr<gfxContext> mContext;
    1:     HDC mDC;
    1: 
    1:     SCRIPT_ITEM *mScriptItem;
    1:     WORD mScript;
    1: 
 2252:     // these point to the current range
 2252:     const PRUnichar *mRangeString;
 2252:     PRUint32 mRangeLength;
 2252: 
16418: public:
 2252:     // these point to the full string/length of the item
 2252:     const PRUnichar *mItemString;
 2252:     const PRUint32 mItemLength;
    1: 
16418: private:
    1:     PRUnichar *mAlternativeString;
    1: 
    1:     gfxWindowsFontGroup *mGroup;
    1: 
 5393: #define AVERAGE_ITEM_LENGTH 40
 5393: 
 7625:     nsAutoTArray<WORD, PRUint32(ESTIMATE_MAX_GLYPHS(AVERAGE_ITEM_LENGTH))> mGlyphs;
 6076:     nsAutoTArray<WORD, AVERAGE_ITEM_LENGTH + 1> mClusters;
 7625:     nsAutoTArray<SCRIPT_VISATTR, PRUint32(ESTIMATE_MAX_GLYPHS(AVERAGE_ITEM_LENGTH))> mAttr;
 5393:  
 6076:     nsAutoTArray<GOFFSET, 2 * AVERAGE_ITEM_LENGTH> mOffsets;
 6076:     nsAutoTArray<int, 2 * AVERAGE_ITEM_LENGTH> mAdvances;
 5393: 
 5393: #undef AVERAGE_ITEM_LENGTH
    1: 
    1:     int mMaxGlyphs;
    1:     int mNumGlyphs;
    1: 
    1:     nsRefPtr<gfxWindowsFont> mCurrentFont;
    1: 
    1:     PRPackedBool mFontSelected;
 2252: 
22991:     // when shaping, Uniscribe refuses to shape with some fonts
22991:     // (e.g. CFF fonts loaded with AddFontMemResourceEx), so need
22991:     // to force GDI placement
22991:     PRPackedBool mForceGDIPlace;
22991: 
16418:     nsTArray<gfxTextRange> mRanges;
    1: };
    1: 
 7625: 
 7625: #define MAX_ITEM_LENGTH 32768
 7625: 
 7625: 
 7625: 
 7625: static PRUint32 FindNextItemStart(int aOffset, int aLimit,
 7625:                                   nsTArray<SCRIPT_LOGATTR> &aLogAttr,
 7625:                                   const PRUnichar *aString)
 7625: {
 7625:     if (aOffset + MAX_ITEM_LENGTH >= aLimit) {
 7625:         // The item starting at aOffset can't be longer than the max length,
 7625:         // so starting the next item at aLimit won't cause ScriptShape() to fail.
 7625:         return aLimit;
 7625:     }
 7625: 
 7625:     // Try to start the next item before or after a space, since spaces
 7625:     // don't kern or ligate.
 7625:     PRUint32 off;
 7625:     int boundary = -1;
 7625:     for (off = MAX_ITEM_LENGTH; off > 1; --off) {
 7625:       if (aLogAttr[off].fCharStop) {
 7625:           if (off > boundary) {
 7625:               boundary = off;
 7625:           }
 7625:           if (aString[aOffset+off] == ' ' || aString[aOffset+off - 1] == ' ')
 7625:             return aOffset+off;
 7625:       }
 7625:     }
 7625: 
 7625:     // Try to start the next item at the last cluster boundary in the range.
 7625:     if (boundary > 0) {
 7625:       return aOffset+boundary;
 7625:     }
 7625: 
 7625:     // No nice cluster boundaries inside MAX_ITEM_LENGTH characters, break
 7625:     // on the size limit. It won't be visually plesaing, but at least it
 7625:     // won't cause ScriptShape() to fail.
 7625:     return aOffset + MAX_ITEM_LENGTH;
 7625: }
 7625: 
    1: class Uniscribe
    1: {
    1: public:
    1:     Uniscribe(gfxContext *aContext, HDC aDC, const PRUnichar *aString, PRUint32 aLength, PRBool aIsRTL) :
    1:         mContext(aContext), mDC(aDC), mString(aString), mLength(aLength), mIsRTL(aIsRTL),
    1:         mItems(nsnull) {
    1:     }
  282:     ~Uniscribe() {
  282:     }
    1: 
    1:     void Init() {
    1:         memset(&mControl, 0, sizeof(SCRIPT_CONTROL));
    1:         memset(&mState, 0, sizeof(SCRIPT_STATE));
    1:         // Lock the direction. Don't allow the itemizer to change directions
    1:         // based on character type.
    1:         mState.uBidiLevel = mIsRTL;
    1:         mState.fOverrideDirection = PR_TRUE;
    1:     }
    1: 
 7625: private:
 7625: 
 7625:     // Append mItems[aIndex] to aDest, adding extra items to aDest to ensure
 7625:     // that no item is too long for ScriptShape() to handle. See bug 366643.
 7625:     nsresult CopyItemSplitOversize(int aIndex, nsTArray<SCRIPT_ITEM> &aDest) {
 7625:         aDest.AppendElement(mItems[aIndex]);
 7625:         const int itemLength = mItems[aIndex+1].iCharPos - mItems[aIndex].iCharPos;
 7625:         if (ESTIMATE_MAX_GLYPHS(itemLength) > 65535) {
 7625:             // This items length would cause ScriptShape() to fail. We need to
 7625:             // add extra items here so that no item's length could cause the fail.
 7625: 
 7625:             // Get cluster boundaries, so we can break cleanly if possible.
 7625:             nsTArray<SCRIPT_LOGATTR> logAttr;
 7625:             if (!logAttr.SetLength(itemLength))
 7625:                 return NS_ERROR_FAILURE;
 7625:             HRESULT rv= ScriptBreak(mString+mItems[aIndex].iCharPos, itemLength,
 7625:                                     &mItems[aIndex].a, logAttr.Elements());
 7625:             if (FAILED(rv))
 7625:                 return NS_ERROR_FAILURE;
 7625: 
 7625:             const int nextItemStart = mItems[aIndex+1].iCharPos;
 7625:             int start = FindNextItemStart(mItems[aIndex].iCharPos,
 7625:                                           nextItemStart, logAttr, mString);
 7625: 
 7625:             while (start < nextItemStart) {
 7625:                 SCRIPT_ITEM item = mItems[aIndex];
 7625:                 item.iCharPos = start;
 7625:                 aDest.AppendElement(item);
 7625:                 start = FindNextItemStart(start, nextItemStart, logAttr, mString);
 7625:             }
 7625:         } 
 7625:         return NS_OK;
 7625:     }
 7625: 
 7625: public:
 7625: 
    1:     int Itemize() {
    1:         HRESULT rv;
    1: 
    1:         int maxItems = 5;
    1: 
    1:         Init();
 7625: 
  808:         // Allocate space for one more item than expected, to handle a rare
  808:         // overflow in ScriptItemize (pre XP SP2). See bug 366643.
 7625:         if (!mItems.SetLength(maxItems + 1)) {
 7625:             return 0;
 7625:         }
    1:         while ((rv = ScriptItemize(mString, mLength, maxItems, &mControl, &mState,
 7625:                                    mItems.Elements(), &mNumItems)) == E_OUTOFMEMORY) {
    1:             maxItems *= 2;
 7625:             if (!mItems.SetLength(maxItems + 1)) {
 7625:                 return 0;
 7625:             }
    1:             Init();
    1:         }
    1: 
 7625:         if (ESTIMATE_MAX_GLYPHS(mLength) > 65535) {
 7625:             // Any item of length > 43680 will cause ScriptShape() to fail, as its
 7625:             // mMaxGlyphs value will be greater than 65535 (43680*1.5+16>65535). So we
 7625:             // need to break up items which are longer than that upon cluster boundaries.
 7625:             // See bug 394751 for details.
 7625:             nsTArray<SCRIPT_ITEM> items;
 7625:             for (int i=0; i<mNumItems; i++) {
 7625:                 nsresult nrs = CopyItemSplitOversize(i, items);
 7625:                 NS_ASSERTION(NS_SUCCEEDED(nrs), "CopyItemSplitOversize() failed");
 7625:             }
 7625:             items.AppendElement(mItems[mNumItems]); // copy terminator.
 7625: 
 7625:             mItems = items;
 7625:             mNumItems = items.Length() - 1; // Don't count the terminator.
 7625:         }
    1:         return mNumItems;
    1:     }
    1: 
    1:     PRUint32 ItemsLength() {
    1:         return mNumItems;
    1:     }
    1: 
    1:     // XXX Why do we dynamically allocate this? We could just fill in an object
    1:     // on the stack.
    1:     UniscribeItem *GetItem(PRUint32 i, gfxWindowsFontGroup *aGroup) {
    1:         NS_ASSERTION(i < (PRUint32)mNumItems, "Trying to get out of bounds item");
    1: 
    1:         UniscribeItem *item = new UniscribeItem(mContext, mDC,
    1:                                                 mString + mItems[i].iCharPos,
    1:                                                 mItems[i+1].iCharPos - mItems[i].iCharPos,
    1:                                                 &mItems[i],
    1:                                                 aGroup);
    1: 
    1:         return item;
    1:     }
    1: 
    1: private:
    1:     nsRefPtr<gfxContext> mContext;
    1:     HDC mDC;
    1:     const PRUnichar *mString;
    1:     const PRUint32 mLength;
    1:     const PRBool mIsRTL;
    1: 
    1:     SCRIPT_CONTROL mControl;
    1:     SCRIPT_STATE   mState;
 7625:     nsTArray<SCRIPT_ITEM> mItems;
    1:     int mNumItems;
    1: };
    1: 
16418: already_AddRefed<gfxWindowsFont>
16418: gfxWindowsFontGroup::WhichFontSupportsChar(const nsTArray<nsRefPtr<FontEntry> >& fonts, PRUint32 ch) {
16418:     for (PRUint32 i = 0; i < fonts.Length(); i++) {
16418:         nsRefPtr<FontEntry> fe = fonts[i];
16418:         if (fe->mSymbolFont && !mStyle.familyNameQuirks)
16418:             continue;
16418:         if (fe->HasCharacter(ch)) {
16418:             nsRefPtr<gfxWindowsFont> font =
16418:                 gfxWindowsFont::GetOrMakeFont(fe, &mStyle);
16418:             // Check that the font is still usable.
16418:             if (!font->IsValid())
16418:                 continue;
16418:             return font.forget();
16418:         }
16418:     }
16418:     return nsnull;
16418: }
16418: 
16418: // this function appends to the array passed in.
16418: void gfxWindowsFontGroup::GetPrefFonts(const char *aLangGroup, nsTArray<nsRefPtr<FontEntry> >& array) {
16418:     NS_ASSERTION(aLangGroup, "aLangGroup is null");
16418:     gfxWindowsPlatform *platform = gfxWindowsPlatform::GetPlatform();
16418:     nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
16418:     /* this lookup has to depend on weight and style */
16418:     nsCAutoString key(aLangGroup);
16418:     key.Append("-");
16418:     key.AppendInt(GetStyle()->style);
16418:     key.Append("-");
16418:     key.AppendInt(GetStyle()->weight);
16418:     if (!platform->GetPrefFontEntries(key, &fonts)) {
16418:         nsString fontString;
16418:         platform->GetPrefFonts(aLangGroup, fontString);
16418:         if (fontString.IsEmpty())
16418:             return;
16418: 
16418:         FamilyListToArrayList(fontString, nsDependentCString(aLangGroup),
16418:                                       &fonts);
16418: 
16418:         platform->SetPrefFontEntries(key, fonts);
16418:     }
16418:     array.AppendElements(fonts);
16418: }
16418: 
16418: static PRInt32 GetCJKLangGroupIndex(const char *aLangGroup) {
16418:     PRInt32 i;
16418:     for (i = 0; i < COUNT_OF_CJK_LANG_GROUP; i++) {
16418:         if (!PL_strcasecmp(aLangGroup, sCJKLangGroup[i]))
16418:             return i;
16418:     }
16418:     return -1;
16418: }
16418: 
16418: // this function assigns to the array passed in.
16418: void gfxWindowsFontGroup::GetCJKPrefFonts(nsTArray<nsRefPtr<FontEntry> >& array) {
16418:     gfxWindowsPlatform *platform = gfxWindowsPlatform::GetPlatform();
16418: 
16418:     nsCAutoString key("x-internal-cjk-");
16418:     key.AppendInt(mStyle.style);
16418:     key.Append("-");
16418:     key.AppendInt(mStyle.weight);
16418: 
16418:     if (!platform->GetPrefFontEntries(key, &array)) {
16418:         nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
16418:         if (!prefs)
16418:             return;
16418: 
16418:         nsCOMPtr<nsIPrefBranch> prefBranch;
16418:         prefs->GetBranch(0, getter_AddRefs(prefBranch));
16418:         if (!prefBranch)
16418:             return;
16418: 
16418:         // Add the CJK pref fonts from accept languages, the order should be same order
16418:         nsCAutoString list;
16418:         nsCOMPtr<nsIPrefLocalizedString> val;
16418:         nsresult rv = prefBranch->GetComplexValue("intl.accept_languages", NS_GET_IID(nsIPrefLocalizedString),
16418:                                                   getter_AddRefs(val));
16418:         if (NS_SUCCEEDED(rv) && val) {
16418:             nsAutoString temp;
16418:             val->ToString(getter_Copies(temp));
16418:             LossyCopyUTF16toASCII(temp, list);
16418:         }
16418:         if (!list.IsEmpty()) {
16418:             const char kComma = ',';
16418:             const char *p, *p_end;
16418:             list.BeginReading(p);
16418:             list.EndReading(p_end);
16418:             while (p < p_end) {
16418:                 while (nsCRT::IsAsciiSpace(*p)) {
16418:                     if (++p == p_end)
16418:                         break;
16418:                 }
16418:                 if (p == p_end)
16418:                     break;
16418:                 const char *start = p;
16418:                 while (++p != p_end && *p != kComma)
16418:                     /* nothing */ ;
16418:                 nsCAutoString lang(Substring(start, p));
16418:                 lang.CompressWhitespace(PR_FALSE, PR_TRUE);
16418:                 PRInt32 index = GetCJKLangGroupIndex(lang.get());
16418:                 if (index >= 0)
16418:                     GetPrefFonts(sCJKLangGroup[index], array);
16418:                 p++;
16418:             }
16418:         }
16418: 
16418:         // Add the system locale
16418:         switch (::GetACP()) {
16418:             case 932: GetPrefFonts(CJK_LANG_JA, array); break;
16418:             case 936: GetPrefFonts(CJK_LANG_ZH_CN, array); break;
16418:             case 949: GetPrefFonts(CJK_LANG_KO, array); break;
16418:             // XXX Don't we need to append CJK_LANG_ZH_HK if the codepage is 950?
16418:             case 950: GetPrefFonts(CJK_LANG_ZH_TW, array); break;
16418:         }
16418: 
16418:         // last resort...
16418:         GetPrefFonts(CJK_LANG_JA, array);
16418:         GetPrefFonts(CJK_LANG_KO, array);
16418:         GetPrefFonts(CJK_LANG_ZH_CN, array);
16418:         GetPrefFonts(CJK_LANG_ZH_HK, array);
16418:         GetPrefFonts(CJK_LANG_ZH_TW, array);
16418: 
16418:         platform->SetPrefFontEntries(key, array);
16418:     }
16418: }
16418: 
16418: already_AddRefed<gfxFont> 
16418: gfxWindowsFontGroup::WhichPrefFontSupportsChar(PRUint32 aCh)
16418: {
16418:     nsRefPtr<gfxWindowsFont> selectedFont;
16418: 
16418:     // check out the style's language group
16418:     if (!selectedFont) {
16418:         nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
16418:         this->GetPrefFonts(mStyle.langGroup.get(), fonts);
16418:         selectedFont = WhichFontSupportsChar(fonts, aCh);
16418:     }
16418: 
16418:     // otherwise search prefs
16418:     if (!selectedFont) {
16418:         /* first check with the script properties to see what they think */
16418:         if (mItemLangGroup) {
16418:             PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Trying to find fonts for: %s ", mItemLangGroup));
16418: 
16418:             nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
16418:             this->GetPrefFonts(mItemLangGroup, fonts);
16418:             selectedFont = WhichFontSupportsChar(fonts, aCh);
16418:         } else if (aCh <= 0xFFFF) {
16418:             PRUint32 unicodeRange = FindCharUnicodeRange(aCh);
16418: 
16418:             /* special case CJK */
16418:             if (unicodeRange == kRangeSetCJK) {
16418:                 if (PR_LOG_TEST(gFontLog, PR_LOG_DEBUG))
16418:                     PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Trying to find fonts for: CJK"));
16418: 
16418:                 nsAutoTArray<nsRefPtr<FontEntry>, 15> fonts;
16418:                 this->GetCJKPrefFonts(fonts);
16418:                 selectedFont = WhichFontSupportsChar(fonts, aCh);
16418:             } else {
16418:                 const char *langGroup = LangGroupFromUnicodeRange(unicodeRange);
16418:                 if (langGroup) {
16418:                     PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Trying to find fonts for: %s", langGroup));
16418: 
16418:                     nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
16418:                     this->GetPrefFonts(langGroup, fonts);
16418:                     selectedFont = WhichFontSupportsChar(fonts, aCh);
16418:                 }
16418:             }
16418:         }
16418:     }
16418: 
16418:     if (selectedFont) {
16418:         nsRefPtr<gfxFont> f = static_cast<gfxFont*>(selectedFont.get());
16418:         return f.forget();
16418:     }
16418: 
16418:     return nsnull;
16418: }
16418: 
16418: 
16418: already_AddRefed<gfxFont> 
16418: gfxWindowsFontGroup::WhichSystemFontSupportsChar(PRUint32 aCh)
16418: {
24104:     nsRefPtr<gfxFont> selectedFont;
16418: 
16418:     // system font lookup
16418:     PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Looking for best match"));
16418: 
16418:     nsRefPtr<gfxWindowsFont> refFont = GetFontAt(0);
16418:     gfxWindowsPlatform *platform = gfxWindowsPlatform::GetPlatform();
16418:     selectedFont = platform->FindFontForChar(aCh, refFont);
16418: 
16418:     if (selectedFont) {
24104:         return selectedFont.forget();
16418:     }
16418: 
16418:     return nsnull;
16418: }
16418: 
16418: 
    1: void
    1: gfxWindowsFontGroup::InitTextRunUniscribe(gfxContext *aContext, gfxTextRun *aRun, const PRUnichar *aString,
    1:                                           PRUint32 aLength)
    1: {
 4363:     DCFromContext aDC(aContext);
    1:  
    1:     const PRBool isRTL = aRun->IsRightToLeft();
    1: 
    1:     HRESULT rv;
    1: 
    1:     Uniscribe us(aContext, aDC, aString, aLength, isRTL);
    1: 
    1:     /* itemize the string */
    1:     int numItems = us.Itemize();
    1: 
    1:     for (int i = 0; i < numItems; ++i) {
    1:         SaveDC(aDC);
    1: 
13517:         nsAutoPtr<UniscribeItem> item(us.GetItem(i, this));
    1: 
16418:         // jtdfix - push this into the pref handling code??
16418:         mItemLangGroup = nsnull;
16418: 
16418:         const SCRIPT_PROPERTIES *sp = item->ScriptProperties();
16418:         if (!sp->fAmbiguousCharSet) {
16418:             WORD primaryId = PRIMARYLANGID(sp->langid);
16418:             mItemLangGroup = gScriptToText[primaryId].langCode;
16418:         }
16418: 
16418:         ComputeRanges(item->Ranges(), item->mItemString, 0, item->mItemLength);
16418: 
16418:         PRUint32 nranges = item->Ranges().Length();
    1: 
 2252:         for (PRUint32 j = 0; j < nranges; ++j) {
    1: 
 2252:             item->SetRange(j);
    1: 
 2252:             if (!item->ShapingEnabled())
 2252:                 item->EnableShaping();
    1: 
 7625:             rv = item->Shape();
 7625:             if (FAILED(rv)) {
 2252:                 PR_LOG(gFontLog, PR_LOG_DEBUG, ("shaping failed"));
 1959:                 // we know we have the glyphs to display this font already
 1959:                 // so Uniscribe just doesn't know how to shape the script.
 1959:                 // Render the glyphs without shaping.
 1959:                 item->DisableShaping();
 7625:                 rv = item->Shape();
 1959:             }
  282: 
14918:             NS_ASSERTION(SUCCEEDED(rv), "Failed to shape, twice -- we should never hit this");
    1: 
14918:             if (SUCCEEDED(rv)) {
    1:                 rv = item->Place();
 2252:                 NS_ASSERTION(SUCCEEDED(rv), "Failed to place -- this is pretty bad.");
14918:             }
    1: 
13439:             if (FAILED(rv)) {
13439:                 aRun->ResetGlyphRuns();
13439: 
13439:                 /* Uniscribe doesn't like this font, use GDI instead */
13439:                 item->GetCurrentFont()->GetFontEntry()->mForceGDI = PR_TRUE;
13439:                 break;
13439:             }
13439: 
    1:             item->SaveGlyphs(aRun);
 2252:         }
 1959: 
13439:         RestoreDC(aDC, -1);
    1: 
13439:         if (FAILED(rv)) {
13439:             i = -1;
    1:         }
    1:     }
13439: }
16418: 
