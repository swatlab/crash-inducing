29628: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
29628: /* ***** BEGIN LICENSE BLOCK *****
29628:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
29628:  *
29628:  * The contents of this file are subject to the Mozilla Public License Version
29628:  * 1.1 (the "License"); you may not use this file except in compliance with
29628:  * the License. You may obtain a copy of the License at
29628:  * http://www.mozilla.org/MPL/
29628:  *
29628:  * Software distributed under the License is distributed on an "AS IS" basis,
29628:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
29628:  * for the specific language governing rights and limitations under the
29628:  * License.
29628:  *
29628:  * The Original Code is mozilla.org code.
29628:  *
29628:  * The Initial Developer of the Original Code is
29628:  *   Mozilla Corporation.
29628:  * Portions created by the Initial Developer are Copyright (C) 2007
29628:  * the Initial Developer. All Rights Reserved.
29628:  *
29628:  * Contributor(s):
29628:  *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
29628:  *
29628:  * Alternatively, the contents of this file may be used under the terms of
29628:  * either the GNU General Public License Version 2 or later (the "GPL"), or
29628:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
29628:  * in which case the provisions of the GPL or the LGPL are applicable instead
29628:  * of those above. If you wish to allow use of your version of this file only
29628:  * under the terms of either the GPL or the LGPL, and not to allow others to
29628:  * use your version of this file under the terms of the MPL, indicate your
29628:  * decision by deleting the provisions above and replace them with the notice
29628:  * and other provisions required by the GPL or the LGPL. If you do not delete
29628:  * the provisions above, a recipient may use your version of this file under
29628:  * the terms of any one of the MPL, the GPL or the LGPL.
29628:  *
29628:  * ***** END LICENSE BLOCK ***** */
29628: 
29628: // this must be first, else windows.h breaks us
32195: #include "nsICanvasRenderingContextWebGL.h"
29628: 
29628: #include "nsIPrefService.h"
32195: #include "nsServiceManagerUtils.h"
32195: 
32195: #include "glwrap.h"
29628: 
29628: #include "nsGLPbuffer.h"
32195: #include "WebGLContext.h"
29628: 
29628: #include "gfxContext.h"
29628: 
32195: using namespace mozilla;
32195: 
29628: #if defined(MOZ_WIDGET_GTK2) && defined(MOZ_X11)
29628: #include <gdk/gdkx.h>
29628: #endif
29628: 
29628: static PRUint32 gActiveBuffers = 0;
29628: 
29628: class GLXWrap
29628:     : public LibrarySymbolLoader
29628: {
29628: public:
29628:     GLXWrap() : fCreateNewContext(0) { }
29628: 
29628:     bool Init();
29628: 
29628: protected:
29628: 
29628:     //
29628:     // the wrapped functions
29628:     //
29628: public:
29628:     typedef PRFuncPtr (* PFNGLXGETPROCADDRESS) (const GLubyte *procName);
29628:     PFNGLXGETPROCADDRESS fGetProcAddress;
29628:     typedef GLXContext (* PFNGLXCREATENEWCONTEXTPROC) (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
29628:     PFNGLXCREATENEWCONTEXTPROC fCreateNewContext;
29628:     typedef XVisualInfo* (* PFNGLXCHOOSEVISUALPROC) (Display *dpy, int scrnum, int *attrib);
29628:     PFNGLXCHOOSEVISUALPROC fChooseVisual;
29628:     typedef GLXContext (* PFNGLXCREATECONTEXTPROC) (Display *dpy, XVisualInfo *visinfo, GLXContext share_list, Bool direct);
29628:     PFNGLXCREATECONTEXTPROC fCreateContext;
29628:     typedef GLXPbuffer (* PFNGLXCREATEPBUFFERPROC) (Display *dpy, GLXFBConfig config, const int *attrib_list);
29628:     PFNGLXCREATEPBUFFERPROC fCreatePbuffer;
29628:     typedef void (* PFNGLXDESTROYCONTEXTPROC) (Display *dpy, GLXContext ctx);
29628:     PFNGLXDESTROYCONTEXTPROC fDestroyContext;
29628:     typedef void (* PFNGLXDESTROYPBUFFERPROC) (Display *dpy, GLXPbuffer pbuf);
29628:     PFNGLXDESTROYPBUFFERPROC fDestroyPbuffer;
29628:     typedef GLXFBConfig* (* PFNGLXCHOOSEFBCONFIGPROC) (Display *dpy, int screen, const int *attrib_list, int *nelements);
29628:     PFNGLXCHOOSEFBCONFIGPROC fChooseFBConfig;
29628:     typedef Bool (* PFNGLXMAKECONTEXTCURRENTPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
29628:     PFNGLXMAKECONTEXTCURRENTPROC fMakeContextCurrent;
29628:     typedef GLXContext (* PFNGLXGETCURRENTCONTEXTPROC) ( void );
29628:     PFNGLXGETCURRENTCONTEXTPROC fGetCurrentContext;
29628:     typedef const char* (* PFNGLXQUERYEXTENSIONSSTRING) (Display *dpy, int screen);
29628:     PFNGLXQUERYEXTENSIONSSTRING fQueryExtensionsString;
29628:     typedef const char* (* PFNGLXQUERYSERVERSTRING) (Display *dpy, int screen, int name);
29628:     PFNGLXQUERYSERVERSTRING fQueryServerString;
29628: };
29628: 
29628: bool
29628: GLXWrap::Init()
29628: {
29628:     if (fCreateNewContext)
29628:         return true;
29628: 
29628:     SymLoadStruct symbols[] = {
29628:         { (PRFuncPtr*) &fGetProcAddress, { "glXGetProcAddress", "glXGetProcAddressARB", NULL } },
29628:         { (PRFuncPtr*) &fCreateNewContext, { "glXCreateNewContext", NULL } },
29628:         { (PRFuncPtr*) &fCreateContext, { "glXCreateContext", NULL } },
29628:         { (PRFuncPtr*) &fChooseVisual, { "glXChooseVisual", NULL } },
29628:         { (PRFuncPtr*) &fCreatePbuffer, { "glXCreatePbuffer", NULL } },
29628:         { (PRFuncPtr*) &fDestroyContext, { "glXDestroyContext", NULL } },
29628:         { (PRFuncPtr*) &fDestroyPbuffer, { "glXDestroyPbuffer", NULL } },
29628:         { (PRFuncPtr*) &fChooseFBConfig, { "glXChooseFBConfig", NULL } },
29628:         { (PRFuncPtr*) &fMakeContextCurrent, { "glXMakeContextCurrent", NULL } },
29628:         { (PRFuncPtr*) &fGetCurrentContext, { "glXGetCurrentContext", NULL } },
29628:         { (PRFuncPtr*) &fQueryExtensionsString, { "glXQueryExtensionsString", NULL } },
29628:         { (PRFuncPtr*) &fQueryServerString, { "glXQueryServerString", NULL } },
29628:         { NULL, { NULL } }
29628:     };
29628: 
29628:     return LoadSymbols(&symbols[0]);
29628: }
29628: 
29628: static GLXWrap gGLXWrap;
29628: 
29628: nsGLPbufferGLX::nsGLPbufferGLX()
29628:     : mDisplay(nsnull), mFBConfig(0), mPbuffer(0), mPbufferContext(0)
29628: {
29628:     gActiveBuffers++;
29628:     fprintf (stderr, "nsGLPbufferGLX: gActiveBuffers: %d\n", gActiveBuffers);
29628: }
29628: 
29628: PRBool
32195: nsGLPbufferGLX::Init(WebGLContext *priv)
29628: {
29628:     nsresult rv;
29628:     const char *s;
29628: 
29628:     if (!gGLXWrap.OpenLibrary("libGL.so.1")) {
32195:         LogMessage("Canvas 3D: Couldn't find libGL.so.1");
29628:         return PR_FALSE;
29628:     }
29628: 
29628:     if (!gGLXWrap.Init()) {
32195:         LogMessage("Canvas 3D: gGLXWrap.Init() failed");
29628:         return PR_FALSE;
29628:     }
29628: 
29628: #if defined(MOZ_WIDGET_GTK2) && defined(MOZ_X11)
29628:     mDisplay = gdk_x11_get_default_xdisplay();
29628: #else
29628:     mDisplay = XOpenDisplay(NULL);
29628: #endif
29628:     if (!mDisplay) {
32195:         LogMessage("Canvas 3D: XOpenDisplay failed");
29628:         return PR_FALSE;
29628:     }
29628: 
29628:     // Make sure that everyone agrees that pbuffers are supported
29628:     s = gGLXWrap.fQueryExtensionsString(mDisplay, DefaultScreen(mDisplay));
38833:     if (!s || strstr(s, "GLX_SGIX_pbuffer") == NULL) {
32195:         LogMessage("Canvas 3D: GLX_SGIX_pbuffer not supported");
29628:         return PR_FALSE;
29628:     }
29628: 
29628:     s = gGLXWrap.fQueryServerString(mDisplay, DefaultScreen(mDisplay), GLX_EXTENSIONS);
38833:     if (!s || strstr(s, "GLX_SGIX_pbuffer") == NULL) {
32195:         LogMessage("Canvas 3D: GLX_SGIX_pbuffer not supported by server");
29628:         return PR_FALSE;
29628:     }
29628: 
29628:     mPriv = priv;
29628: 
29628:     nsCOMPtr<nsIPrefService> prefService = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
29628:     NS_ENSURE_SUCCESS(rv, PR_FALSE);
29628: 
29628:     nsCOMPtr<nsIPrefBranch> prefBranch;
29628:     rv = prefService->GetBranch("extensions.canvas3d.", getter_AddRefs(prefBranch));
29628:     NS_ENSURE_SUCCESS(rv, PR_FALSE);
29628: 
29628:     PRInt32 prefAntialiasing;
29628:     rv = prefBranch->GetIntPref("antialiasing", &prefAntialiasing);
29628:     if (NS_FAILED(rv))
29628:         prefAntialiasing = 0;
29628:     
29628:     int attrib[] = { GLX_DRAWABLE_TYPE, GLX_PBUFFER_BIT,
29628:                      GLX_RENDER_TYPE,   GLX_RGBA_BIT,
29628:                      GLX_RED_SIZE, 1,
29628:                      GLX_GREEN_SIZE, 1,
29628:                      GLX_BLUE_SIZE, 1,
29628:                      GLX_ALPHA_SIZE, 1,
29628:                      GLX_DEPTH_SIZE, 1,
29628:                      GLX_SAMPLE_BUFFERS, 1,
29628:                      GLX_SAMPLES, 1 << prefAntialiasing,
29628:                      None };
29628:     if (prefAntialiasing <= 0)
29628:       attrib[16] = 0;
29628:     int num;
29628:     GLXFBConfig *configs = gGLXWrap.fChooseFBConfig(mDisplay, DefaultScreen(mDisplay),
29628:                                                     attrib, &num);
29628: 
29628:     fprintf(stderr, "CANVAS3D FBCONFIG: %d %p\n", num, (void*) configs);
29628:     if (!configs) {
32195:         LogMessage("Canvas 3D: No GLXFBConfig found");
29628:         return PR_FALSE;
29628:     }
29628: 
29628:     // choose first matching config;
29628:     mFBConfig = *configs;
29628: 
29628:     XFree(configs);
29628: 
29628:     mPbufferContext = gGLXWrap.fCreateNewContext(mDisplay, mFBConfig, GLX_RGBA_TYPE,
29628:                                                  nsnull, True);
29628: 
29628:     PRInt64 t1 = PR_Now();
29628: 
29628:     Resize(2, 2);
29628:     MakeContextCurrent();
29628: 
29628:     PRInt64 t2 = PR_Now();
29628: 
29628:     fprintf (stderr, "nsGLPbufferGLX::Init!\n");
29628: 
29628:     if (!mGLWrap.OpenLibrary("libGL.so.1")) {
32195:         LogMessage("Canvas 3D: GLWrap init failed, couldn't find libGL.so.1");
29628:         return PR_FALSE;
29628:     }
29628: 
29628:     mGLWrap.SetLookupFunc((LibrarySymbolLoader::PlatformLookupFunction) gGLXWrap.fGetProcAddress);
29628: 
29628:     if (!mGLWrap.Init(GLES20Wrap::TRY_NATIVE_GL)) {
32195:         LogMessage("Canvas 3D: GLWrap init failed");
29628:         return PR_FALSE;
29628:     }
29628: 
29628:     PRInt64 t3 = PR_Now();
29628: 
29628:     fprintf (stderr, "nsGLPbufferGLX:: Initialization took t2-t1: %f t3-t2: %f\n",
29628:              ((double)(t2-t1))/1000.0, ((double)(t3-t2))/1000.0);
29628:     fflush (stderr);
29628: 
29628:     return PR_TRUE;
29628: }
29628: 
29628: PRBool
29628: nsGLPbufferGLX::Resize(PRInt32 width, PRInt32 height)
29628: {
29628:     if (mWidth == width &&
29628:         mHeight == height)
29628:     {
29628:         return PR_TRUE;
29628:     }
29628: 
29628:     Destroy();
29628: 
32195:     mThebesSurface = new gfxImageSurface(gfxIntSize(width, height), gfxASurface::ImageFormatARGB32);
29628:     if (mThebesSurface->CairoStatus() != 0) {
29628:         fprintf (stderr, "image surface failed\n");
29628:         return PR_FALSE;
29628:     }
29628: 
29628:     // clear the surface
29628:     memset (mThebesSurface->Data(),
29628:             0,
29628:             height * mThebesSurface->Stride());
29628: 
29628:     int attrib[] = { GLX_PBUFFER_WIDTH, width,
29628:                      GLX_PBUFFER_HEIGHT, height,
29628:                      None };
29628: 
29628:     mPbuffer = gGLXWrap.fCreatePbuffer(mDisplay, mFBConfig, attrib);
29628:     gGLXWrap.fMakeContextCurrent(mDisplay, mPbuffer, mPbuffer, mPbufferContext);
29628: 
29628:     mWidth = width;
29628:     mHeight = height;
29628: 
29628:     fprintf (stderr, "Resize: %d %d\n", width, height);
29628:     return PR_TRUE;
29628: }
29628: 
29628: void
29628: nsGLPbufferGLX::Destroy()
29628: {
29628:     sCurrentContextToken = nsnull;
29628:     mThebesSurface = nsnull;
29628: 
29628:     if (mPbuffer) {
29628:         gGLXWrap.fDestroyPbuffer(mDisplay, mPbuffer);
29628:         mPbuffer = nsnull;
29628:     }
29628: }
29628: 
29628: nsGLPbufferGLX::~nsGLPbufferGLX()
29628: {
29628:     MakeContextCurrent();
29628: #ifndef GL_FRAMEBUFFER
29628: #define GL_FRAMEBUFFER 0x8D40
29628: #endif
29628:     // workaround for segfault on glXDestroyContext
29628:     mGLWrap.fBindFramebuffer(GL_FRAMEBUFFER, 0);
29628: 
29628:     Destroy();
29628: 
29628:     if (mPbuffer)
29628:         gGLXWrap.fDestroyPbuffer(mDisplay, mPbuffer);
29628:     if (mPbufferContext)
29628:         gGLXWrap.fDestroyContext(mDisplay, mPbufferContext);
29628: #if !(defined(MOZ_WIDGET_GTK2) && defined(MOZ_X11))
29628:     if (mDisplay)
29628:         XCloseDisplay(mDisplay);
29628: #endif
29628: 
29628:     gActiveBuffers--;
29628:     fprintf (stderr, "nsGLPbufferGLX: gActiveBuffers: %d\n", gActiveBuffers);
29628:     fflush (stderr);
29628: }
29628: 
29628: void
29628: nsGLPbufferGLX::MakeContextCurrent()
29628: {
29628:     if (gGLXWrap.fGetCurrentContext() != mPbufferContext)
29628:         gGLXWrap.fMakeContextCurrent(mDisplay, mPbuffer, mPbuffer, mPbufferContext);
29628: }
29628: 
29628: void
29628: nsGLPbufferGLX::SwapBuffers()
29628: {
29628:     MakeContextCurrent();
32195:     mGLWrap.fReadPixels (0, 0, mWidth, mHeight, LOCAL_GL_BGRA, LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV, mThebesSurface->Data());
29628:     unsigned int len = mWidth*mHeight*4;
29628:     unsigned char *src = mThebesSurface->Data();
29628:     // Premultiply the image
29628:     // XXX don't do this if we're known opaque
29628:     Premultiply(src, len);
29628: }
29628: 
29628: gfxASurface*
29628: nsGLPbufferGLX::ThebesSurface()
29628: {
29628:     return mThebesSurface;
29628: }
