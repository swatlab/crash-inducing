    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52557:  * vim: set ts=4 sw=4 et tw=79 ft=cpp:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsscript_h___
    1: #define jsscript_h___
    1: /*
    1:  * JS script descriptor.
    1:  */
    1: #include "jsatom.h"
    1: #include "jsprvtd.h"
25215: #include "jsdbgapi.h"
53391: #include "jsclist.h"
    1: 
    1: /*
17215:  * Type of try note associated with each catch or finally block, and also with
17215:  * for-in loops.
 1825:  */
 1825: typedef enum JSTryNoteKind {
20420:     JSTRY_CATCH,
20420:     JSTRY_FINALLY,
20420:     JSTRY_ITER
 1825: } JSTryNoteKind;
 1825: 
47573: namespace js {
47573: 
47573: /*
47573:  * Indicates a location in the stack that an upvar value can be retrieved from
47573:  * as a two tuple of (level, slot).
47573:  *
47573:  * Some existing client code uses the level value as a delta, or level "skip"
47573:  * quantity. We could probably document that through use of more types at some
47573:  * point in the future.
47573:  *
47573:  * Existing XDR code wants this to be backed by a 32b integer for serialization,
47573:  * so we oblige.
47573:  *
47573:  * TODO: consider giving more bits to the slot value and takings ome from the level.
47573:  */
47573: class UpvarCookie
47573: {
47573:     uint32 value;
47573: 
47573:     static const uint32 FREE_VALUE = 0xfffffffful;
47573: 
48582:     void checkInvariants() {
48582:         JS_STATIC_ASSERT(sizeof(UpvarCookie) == sizeof(uint32));
48582:         JS_STATIC_ASSERT(UPVAR_LEVEL_LIMIT < FREE_LEVEL);
48582:     }
48582: 
47573:   public:
47573:     /*
47573:      * All levels above-and-including FREE_LEVEL are reserved so that
47573:      * FREE_VALUE can be used as a special value.
47573:      */
47573:     static const uint16 FREE_LEVEL = 0x3fff;
48582: 
48582:     /*
48582:      * If a function has a higher static level than this limit, we will not
48582:      * optimize it using UPVAR opcodes.
48582:      */
48582:     static const uint16 UPVAR_LEVEL_LIMIT = 16;
47573:     static const uint16 CALLEE_SLOT = 0xffff;
47573:     static bool isLevelReserved(uint16 level) { return level >= FREE_LEVEL; }
47573: 
47573:     bool isFree() const { return value == FREE_VALUE; }
47573:     uint32 asInteger() const { return value; }
47573:     /* isFree check should be performed before using these accessors. */
53650:     uint16 level() const { JS_ASSERT(!isFree()); return uint16(value >> 16); }
48585:     uint16 slot() const { JS_ASSERT(!isFree()); return uint16(value); }
47573: 
47573:     void set(const UpvarCookie &other) { set(other.level(), other.slot()); }
47573:     void set(uint16 newLevel, uint16 newSlot) { value = (uint32(newLevel) << 16) | newSlot; }
47573:     void makeFree() { set(0xffff, 0xffff); JS_ASSERT(isFree()); }
53081:     void fromInteger(uint32 u32) { value = u32; }
47573: };
47573: 
47573: }
47573: 
 1825: /*
 1825:  * Exception handling record.
    1:  */
    1: struct JSTryNote {
 1825:     uint8           kind;       /* one of JSTryNoteKind */
 1825:     uint8           padding;    /* explicit padding on uint16 boundary */
 1825:     uint16          stackDepth; /* stack depth upon exception handler entry */
 3025:     uint32          start;      /* start of the try statement or for-in loop
 3025:                                    relative to script->main */
 3025:     uint32          length;     /* length of the try statement or for-in loop */
    1: };
    1: 
 1825: typedef struct JSTryNoteArray {
 3235:     JSTryNote       *vector;    /* array of indexed try notes */
17182:     uint32          length;     /* count of indexed try notes */
 1825: } JSTryNoteArray;
    1: 
 3235: typedef struct JSObjectArray {
 3235:     JSObject        **vector;   /* array of indexed objects */
17182:     uint32          length;     /* count of indexed objects */
 3235: } JSObjectArray;
 3235: 
18308: typedef struct JSUpvarArray {
47573:     js::UpvarCookie *vector;    /* array of indexed upvar cookies */
18308:     uint32          length;     /* count of indexed upvar cookies */
18308: } JSUpvarArray;
18308: 
48470: typedef struct JSConstArray {
48470:     js::Value       *vector;    /* array of indexed constant values */
48470:     uint32          length;
48470: } JSConstArray;
48470: 
59968: struct JSArenaPool;
59968: 
52555: namespace js {
52555: 
52555: struct GlobalSlotArray {
52555:     struct Entry {
52555:         uint32      atomIndex;  /* index into atom table */
52555:         uint32      slot;       /* global obj slot number */
52555:     };
52555:     Entry           *vector;
52555:     uint32          length;
52555: };
52555: 
59987: struct Shape;
59968: 
59968: enum BindingKind { NONE, ARGUMENT, VARIABLE, CONSTANT, UPVAR };
59968: 
59968: /*
59968:  * Formal parameters, local variables, and upvars are stored in a shape tree
59968:  * path encapsulated within this class.  This class represents bindings for
59968:  * both function and top-level scripts (the latter is needed to track names in
59968:  * strict mode eval code, to give such code its own lexical environment).
59968:  */
59968: class Bindings {
59968:     js::Shape *lastBinding;
59968:     uint16 nargs;
59968:     uint16 nvars;
59968:     uint16 nupvars;
64296:     bool hasExtensibleParents;
59968: 
59968:   public:
64242:     inline Bindings(JSContext *cx, EmptyShape *emptyCallShape);
59968: 
59968:     /*
59968:      * Transfers ownership of bindings data from bindings into this fresh
59968:      * Bindings instance. Once such a transfer occurs, the old bindings must
59968:      * not be used again.
59968:      */
59968:     inline void transfer(JSContext *cx, Bindings *bindings);
59968: 
59968:     /*
59968:      * Clones bindings data from bindings, which must be immutable, into this
59968:      * fresh Bindings instance. A Bindings instance may be cloned multiple
59968:      * times.
59968:      */
59968:     inline void clone(JSContext *cx, Bindings *bindings);
59968: 
59968:     uint16 countArgs() const { return nargs; }
59968:     uint16 countVars() const { return nvars; }
59968:     uint16 countUpvars() const { return nupvars; }
59968: 
59968:     uintN countArgsAndVars() const { return nargs + nvars; }
59968: 
59968:     uintN countLocalNames() const { return nargs + nvars + nupvars; }
59968: 
59968:     bool hasUpvars() const { return nupvars > 0; }
59968:     bool hasLocalNames() const { return countLocalNames() > 0; }
59968: 
59968:     /* Returns the shape lineage generated for these bindings. */
64295:     inline js::Shape *lastShape() const;
59968: 
59974:     enum {
59974:         /*
59974:          * A script may have no more than this many arguments, variables, or
59974:          * upvars.
59974:          */
59974:         BINDING_COUNT_LIMIT = 0xFFFF
59974:     };
59974: 
59968:     /*
59968:      * Add a local binding for the given name, of the given type, for the code
59968:      * being compiled.  If fun is non-null, this binding set is being created
59968:      * for that function, so adjust corresponding metadata in that function
59968:      * while adding.  Otherwise this set must correspond to a top-level script.
59968:      *
59968:      * A binding may be added twice with different kinds; the last one for a
59968:      * given name prevails.  (We preserve both bindings for the decompiler,
59968:      * which must deal with such cases.)  Pass null for name when indicating a
59968:      * destructuring argument.  Return true on success.
59968:      *
59968:      * The parser builds shape paths for functions, usable by Call objects at
60254:      * runtime, by calling an "add" method. All ARGUMENT bindings must be added
60254:      * before before any VARIABLE or CONSTANT bindings, which themselves must
60254:      * be added before all UPVAR bindings.
59968:      */
59968:     bool add(JSContext *cx, JSAtom *name, BindingKind kind);
59968: 
59968:     /* Convenience specializations. */
59968:     bool addVariable(JSContext *cx, JSAtom *name) {
59968:         return add(cx, name, VARIABLE);
59968:     }
59968:     bool addConstant(JSContext *cx, JSAtom *name) {
59968:         return add(cx, name, CONSTANT);
59968:     }
59968:     bool addUpvar(JSContext *cx, JSAtom *name) {
59968:         return add(cx, name, UPVAR);
59968:     }
59968:     bool addArgument(JSContext *cx, JSAtom *name, uint16 *slotp) {
59968:         JS_ASSERT(name != NULL); /* not destructuring */
59968:         *slotp = nargs;
59968:         return add(cx, name, ARGUMENT);
59968:     }
59968:     bool addDestructuring(JSContext *cx, uint16 *slotp) {
59968:         *slotp = nargs;
59968:         return add(cx, NULL, ARGUMENT);
59968:     }
59968: 
59968:     /*
59968:      * Look up an argument or variable name, returning its kind when found or
59968:      * NONE when no such name exists. When indexp is not null and the name
59968:      * exists, *indexp will receive the index of the corresponding argument or
59968:      * variable.
59968:      */
59992:     BindingKind lookup(JSContext *cx, JSAtom *name, uintN *indexp) const;
59968: 
59968:     /* Convenience method to check for any binding for a name. */
59992:     bool hasBinding(JSContext *cx, JSAtom *name) const {
59992:         return lookup(cx, name, NULL) != NONE;
59968:     }
59968: 
59968:     /*
59968:      * Function and macros to work with local names as an array of words.
59968:      * getLocalNameArray returns the array, or null if we are out of memory.
59968:      * This function must be called only when hasLocalNames().
59968:      *
59968:      * The supplied pool is used to allocate the returned array, so the caller
59968:      * is obligated to mark and release to free it.
59968:      *
59968:      * The elements of the array with index less than nargs correspond to the
59968:      * the names of arguments. An index >= nargs addresses a var binding. Use
59968:      * JS_LOCAL_NAME_TO_ATOM to convert array's element to an atom pointer.
59968:      * This pointer can be null when the element is for an argument
59968:      * corresponding to a destructuring pattern.
59968:      *
59968:      * If nameWord does not name an argument, use JS_LOCAL_NAME_IS_CONST to
59968:      * check if nameWord corresponds to the const declaration.
59968:      */
59968:     jsuword *
59968:     getLocalNameArray(JSContext *cx, JSArenaPool *pool);
59968: 
59968:     /*
59968:      * Returns the slot where the sharp array is stored, or a value < 0 if no
59968:      * sharps are present or in case of failure.
59968:      */
59968:     int sharpSlotBase(JSContext *cx);
59968: 
59968:     /*
59968:      * Protect stored bindings from mutation.  Subsequent attempts to add
59968:      * bindings will copy the existing bindings before adding to them, allowing
59968:      * the original bindings to be safely shared.
59968:      */
59968:     void makeImmutable();
59968: 
59968:     /*
64296:      * Sometimes call objects and run-time block objects need unique shapes, but
64296:      * sometimes they don't.
64296:      *
64296:      * Property cache entries only record the shapes of the first and last
64296:      * objects along the search path, so if the search traverses more than those
64296:      * two objects, then those first and last shapes must determine the shapes
64296:      * of everything else along the path. The js_PurgeScopeChain stuff takes
64296:      * care of making this work, but that suffices only because we require that
64296:      * start points with the same shape have the same successor object in the
64296:      * search path --- a cache hit means the starting shapes were equal, which
64296:      * means the seach path tail (everything but the first object in the path)
64296:      * was shared, which in turn means the effects of a purge will be seen by
64296:      * all affected starting search points.
64296:      *
64296:      * For call and run-time block objects, the "successor object" is the scope
64296:      * chain parent. Unlike prototype objects (of which there are usually few),
64296:      * scope chain parents are created frequently (possibly on every call), so
64296:      * following the shape-implies-parent rule blindly would lead one to give
64296:      * every call and block its own shape.
64296:      *
64296:      * In many cases, however, it's not actually necessary to give call and
64296:      * block objects their own shapes, and we can do better. If the code will
64296:      * always be used with the same global object, and none of the enclosing
64296:      * call objects could have bindings added to them at runtime (by direct eval
64296:      * calls or function statements), then we can use a fixed set of shapes for
64296:      * those objects. You could think of the shapes in the functions' bindings
64296:      * and compile-time blocks as uniquely identifying the global object(s) at
64296:      * the end of the scope chain.
64296:      *
64296:      * (In fact, some JSScripts we do use against multiple global objects (see
64296:      * bug 618497), and using the fixed shapes isn't sound there.)
64296:      * 
64296:      * In deciding whether a call or block has any extensible parents, we
64296:      * actually only need to consider enclosing calls; blocks are never
64296:      * extensible, and the other sorts of objects that appear in the scope
64296:      * chains ('with' blocks, say) are not CacheableNonGlobalScopes.
64296:      *
64296:      * If the hasExtensibleParents flag is set, then Call objects created for
64296:      * the function this Bindings describes need unique shapes. If the flag is
64296:      * clear, then we can use lastBinding's shape.
64296:      *
64296:      * For blocks, we set the the OWN_SHAPE flag on the compiler-generated
64296:      * blocksto indicate that their clones need unique shapes.
64296:      */
64296:     void setExtensibleParents() { hasExtensibleParents = true; }
64296:     bool extensibleParents() const { return hasExtensibleParents; }
64296: 
64296:     /*
59968:      * These methods provide direct access to the shape path normally
59968:      * encapsulated by js::Bindings. These methods may be used to make a
59968:      * Shape::Range for iterating over the relevant shapes from youngest to
59968:      * oldest (i.e., last or right-most to first or left-most in source order).
59968:      *
59968:      * Sometimes iteration order must be from oldest to youngest, however. For
59968:      * such cases, use js::Bindings::getLocalNameArray. The RAII class
59968:      * js::AutoLocalNameArray, defined in jscntxt.h, should be used where
59968:      * possible instead of direct calls to getLocalNameArray.
59968:      */
59968:     const js::Shape *lastArgument() const;
59968:     const js::Shape *lastVariable() const;
59968:     const js::Shape *lastUpvar() const;
59968: 
59968:     void trace(JSTracer *trc);
59968: };
59968: 
52555: } /* namespace js */
52555: 
 3235: #define JS_OBJECT_ARRAY_SIZE(length)                                          \
 3235:     (offsetof(JSObjectArray, vector) + sizeof(JSObject *) * (length))
 3235: 
11377: #if defined DEBUG && defined JS_THREADSAFE
11377: # define CHECK_SCRIPT_OWNER 1
11377: #endif
11377: 
52557: #ifdef JS_METHODJIT
52557: namespace JSC {
52557:     class ExecutablePool;
52557: }
55503: 
55503: #define JS_UNJITTABLE_SCRIPT (reinterpret_cast<void*>(1))
55503: 
55503: enum JITScriptStatus {
55503:     JITScript_None,
55503:     JITScript_Invalid,
55503:     JITScript_Valid
55503: };
55503: 
52557: namespace js {
52557: namespace mjit {
53498: 
53498: struct JITScript;
53498: 
52557: }
52557: }
52557: #endif
52557: 
    1: struct JSScript {
54840:     /*
54840:      * Two successively less primitive ways to make a new JSScript.  The first
54840:      * does *not* call a non-null cx->runtime->newScriptHook -- only the second,
54840:      * NewScriptFromCG, calls this optional debugger hook.
54840:      *
54840:      * The NewScript function can't know whether the script it creates belongs
54840:      * to a function, or is top-level or eval code, but the debugger wants access
54840:      * to the newly made script's function, if any -- so callers of NewScript
54840:      * are responsible for notifying the debugger after successfully creating any
54840:      * kind (function or other) of new JSScript.
54840:      */
54840:     static JSScript *NewScript(JSContext *cx, uint32 length, uint32 nsrcnotes, uint32 natoms,
54840:                                uint32 nobjects, uint32 nupvars, uint32 nregexps,
54840:                                uint32 ntrynotes, uint32 nconsts, uint32 nglobals,
61450:                                uint16 nClosedArgs, uint16 nClosedVars, JSVersion version);
54840: 
54840:     static JSScript *NewScriptFromCG(JSContext *cx, JSCodeGenerator *cg);
54840: 
53391:     /* FIXME: bug 586181 */
53391:     JSCList         links;      /* Links for compartment script list */
    1:     jsbytecode      *code;      /* bytecodes and their immediate operands */
    1:     uint32          length;     /* length of code vector */
61450: 
61450:   private:
 3235:     uint16          version;    /* JS version under which script was compiled */
61450: 
62574:     size_t          callCount_; /* Number of times the script has been called. */
62574: 
61450:   public:
16072:     uint16          nfixed;     /* number of slots besides stack operands in
16072:                                    slot array */
59221: 
59221:     /*
59221:      * Offsets to various array structures from the end of this script, or
59221:      * JSScript::INVALID_OFFSET if the array has length 0.
59221:      */
 3235:     uint8           objectsOffset;  /* offset to the array of nested function,
 3235:                                        block, scope, xml and one-time regexps
59221:                                        objects */
18308:     uint8           upvarsOffset;   /* offset of the array of display ("up")
59221:                                        closure vars */
 3235:     uint8           regexpsOffset;  /* offset to the array of to-be-cloned
59221:                                        regexps  */
59221:     uint8           trynotesOffset; /* offset to the array of try notes */
59221:     uint8           globalsOffset;  /* offset to the array of global slots */
59221:     uint8           constOffset;    /* offset to the array of constants */
59221: 
33750:     bool            noScriptRval:1; /* no need for result value of last
33750:                                        expression statement */
33750:     bool            savedCallerFun:1; /* object 0 is caller function */
33750:     bool            hasSharps:1;      /* script uses sharp variables */
35113:     bool            strictModeCode:1; /* code is in strict mode */
52825:     bool            compileAndGo:1;   /* script was compiled with TCF_COMPILE_N_GO */
52878:     bool            usesEval:1;       /* script uses eval() */
54840:     bool            usesArguments:1;  /* script uses arguments */
48589:     bool            warnedAboutTwoArgumentEval:1; /* have warned about use of
48589:                                                      obsolete eval(s, o) in
48589:                                                      this script */
59962:     bool            hasSingletons:1;  /* script has singleton objects */
53391: #ifdef JS_METHODJIT
53391:     bool            debugMode:1;      /* script was compiled in debug mode */
59882:     bool            singleStepMode:1; /* compile script in single-step mode */
53391: #endif
33750: 
    1:     jsbytecode      *main;      /* main entry point, after predef'ing prolog */
    1:     JSAtomMap       atomMap;    /* maps immediate index to literal struct */
55633:     JSCompartment   *compartment; /* compartment the script was compiled for */
    1:     const char      *filename;  /* source filename or null */
18308:     uint32          lineno;     /* base line number of script */
18308:     uint16          nslots;     /* vars plus maximum stack depth */
27012:     uint16          staticLevel;/* static level for display maintenance */
54840:     uint16          nClosedArgs; /* number of args which are closed over. */
54840:     uint16          nClosedVars; /* number of vars which are closed over. */
59968:     js::Bindings    bindings;   /* names of top-level variables in this script
59968:                                    (and arguments if this is a function script) */
    1:     JSPrincipals    *principals;/* principals for this script */
18285:     union {
51440:         /*
51440:          * A script object of class js_ScriptClass, to ensure the script is GC'd.
51440:          * - All scripts returned by JSAPI functions (JS_CompileScript,
51440:          *   JS_CompileFile, etc.) have these objects.
51440:          * - Function scripts never have script objects; such scripts are owned
51440:          *   by their function objects.
51440:          * - Temporary scripts created by obj_eval, JS_EvaluateScript, and
51440:          *   similar functions never have these objects; such scripts are
51440:          *   explicitly destroyed by the code that created them.
51440:          * Debugging API functions (JSDebugHooks::newScriptHook;
51440:          * JS_GetFunctionScript) may reveal sans-script-object Function and
51440:          * temporary scripts to clients, but clients must never call
51440:          * JS_NewScriptObject on such scripts: doing so would double-free them,
51440:          * once from the explicit call to js_DestroyScript, and once when the
51440:          * script object is garbage collected.
51440:          */
51440:         JSObject    *object;
18285:         JSScript    *nextToGC;  /* next to GC in rt->scriptsToGC list */
18285:     } u;
55633: 
11377: #ifdef CHECK_SCRIPT_OWNER
11377:     JSThread        *owner;     /* for thread-safe life-cycle assertions */
11377: #endif
54840: 
54840:     uint32          *closedSlots; /* vector of closed slots; args first, then vars. */
54840: 
54840:   public:
52557: #ifdef JS_METHODJIT
55503:     // Fast-cached pointers to make calls faster. These are also used to
55503:     // quickly test whether there is JIT code; a NULL value means no
55503:     // compilation has been attempted. A JS_UNJITTABLE_SCRIPT value means
55503:     // compilation failed. Any value is the arity-check entry point.
55503:     void *jitArityCheckNormal;
55503:     void *jitArityCheckCtor;
52557: 
55503:     js::mjit::JITScript *jitNormal;   /* Extra JIT info for normal scripts */
55503:     js::mjit::JITScript *jitCtor;     /* Extra JIT info for constructors */
55503: 
55503:     bool hasJITCode() {
55503:         return jitNormal || jitCtor;
55503:     }
55503: 
55687:     // These methods are implemented in MethodJIT.h.
55687:     inline void **nativeMap(bool constructing);
55687:     inline void *maybeNativeCodeForPC(bool constructing, jsbytecode *pc);
55687:     inline void *nativeCodeForPC(bool constructing, jsbytecode *pc);
55503: 
55503:     js::mjit::JITScript *getJIT(bool constructing) {
55503:         return constructing ? jitCtor : jitNormal;
55503:     }
55503: 
62574:     size_t callCount() const  { return callCount_; }
62574:     size_t incCallCount() { return ++callCount_; }
62574: 
55503:     JITScriptStatus getJITStatus(bool constructing) {
55503:         void *addr = constructing ? jitArityCheckCtor : jitArityCheckNormal;
55503:         if (addr == NULL)
55503:             return JITScript_None;
55503:         if (addr == JS_UNJITTABLE_SCRIPT)
55503:             return JITScript_Invalid;
55503:         return JITScript_Valid;
55503:     }
53119: #endif
32723: 
32723:     /* Script notes are allocated right after the code. */
32723:     jssrcnote *notes() { return (jssrcnote *)(code + length); }
32723: 
59221:     static const uint8 INVALID_OFFSET = 0xFF;
59221:     static bool isValidOffset(uint8 offset) { return offset != INVALID_OFFSET; }
59221: 
32723:     JSObjectArray *objects() {
59221:         JS_ASSERT(isValidOffset(objectsOffset));
59221:         return (JSObjectArray *)((uint8 *) (this + 1) + objectsOffset);
32723:     }
32723: 
32723:     JSUpvarArray *upvars() {
59221:         JS_ASSERT(isValidOffset(upvarsOffset));
59221:         return (JSUpvarArray *) ((uint8 *) (this + 1) + upvarsOffset);
32723:     }
32723: 
32723:     JSObjectArray *regexps() {
59221:         JS_ASSERT(isValidOffset(regexpsOffset));
59221:         return (JSObjectArray *) ((uint8 *) (this + 1) + regexpsOffset);
32723:     }
32723: 
32723:     JSTryNoteArray *trynotes() {
59221:         JS_ASSERT(isValidOffset(trynotesOffset));
59221:         return (JSTryNoteArray *) ((uint8 *) (this + 1) + trynotesOffset);
32723:     }
32723: 
52555:     js::GlobalSlotArray *globals() {
59221:         JS_ASSERT(isValidOffset(globalsOffset));
59221:         return (js::GlobalSlotArray *) ((uint8 *) (this + 1) + globalsOffset);
52555:     }
52555: 
48470:     JSConstArray *consts() {
59221:         JS_ASSERT(isValidOffset(constOffset));
59221:         return (JSConstArray *) ((uint8 *) (this + 1) + constOffset);
48470:     }
48470: 
32723:     JSAtom *getAtom(size_t index) {
32723:         JS_ASSERT(index < atomMap.length);
32723:         return atomMap.vector[index];
32723:     }
32723: 
32723:     JSObject *getObject(size_t index) {
32723:         JSObjectArray *arr = objects();
32723:         JS_ASSERT(index < arr->length);
32723:         return arr->vector[index];
32723:     }
32723: 
52555:     uint32 getGlobalSlot(size_t index) {
52555:         js::GlobalSlotArray *arr = globals();
52555:         JS_ASSERT(index < arr->length);
52555:         return arr->vector[index].slot;
52555:     }
52555: 
52555:     JSAtom *getGlobalAtom(size_t index) {
52555:         js::GlobalSlotArray *arr = globals();
52555:         JS_ASSERT(index < arr->length);
52555:         return getAtom(arr->vector[index].atomIndex);
52555:     }
52555: 
53848:     JSVersion getVersion() const {
53848:         return JSVersion(version);
53848:     }
53848: 
32736:     inline JSFunction *getFunction(size_t index);
32723: 
32723:     inline JSObject *getRegExp(size_t index);
34290: 
48470:     const js::Value &getConst(size_t index) {
48470:         JSConstArray *arr = consts();
48470:         JS_ASSERT(index < arr->length);
48470:         return arr->vector[index];
48470:     }
48470: 
34290:     /*
34290:      * The isEmpty method tells whether this script has code that computes any
34290:      * result (not return value, result AKA normal completion value) other than
59220:      * JSVAL_VOID, or any other effects.
34290:      */
34290:     inline bool isEmpty() const;
34290: 
54840:     uint32 getClosedArg(uint32 index) {
54840:         JS_ASSERT(index < nClosedArgs);
54840:         return closedSlots[index];
54840:     }
54840: 
54840:     uint32 getClosedVar(uint32 index) {
54840:         JS_ASSERT(index < nClosedVars);
54840:         return closedSlots[nClosedArgs + index];
54840:     }
54840: 
54840:     void copyClosedSlotsTo(JSScript *other);
    1: };
    1: 
32772: #define SHARP_NSLOTS            2       /* [#array, #depth] slots if the script
32772:                                            uses sharp variables */
32772: 
16284: static JS_INLINE uintN
16072: StackDepth(JSScript *script)
16072: {
16072:     return script->nslots - script->nfixed;
16072: }
16072: 
32673: /*
32673:  * If pc_ does not point within script_'s bytecode, then it must point into an
32673:  * imacro body, so we use cx->runtime common atoms instead of script_'s atoms.
32673:  * This macro uses cx from its callers' environments in the pc-in-imacro case.
32673:  */
32673: #define JS_GET_SCRIPT_ATOM(script_, pc_, index, atom)                         \
 3235:     JS_BEGIN_MACRO                                                            \
32673:         if ((pc_) < (script_)->code ||                                        \
32673:             (script_)->code + (script_)->length <= (pc_)) {                   \
21685:             JS_ASSERT((size_t)(index) < js_common_atom_count);                \
21685:             (atom) = COMMON_ATOMS_START(&cx->runtime->atomState)[index];      \
21685:         } else {                                                              \
32723:             (atom) = script_->getAtom(index);                                 \
21685:         }                                                                     \
 3235:     JS_END_MACRO
 3235: 
48470: extern JS_FRIEND_DATA(js::Class) js_ScriptClass;
    1: 
    1: extern JSObject *
    1: js_InitScriptClass(JSContext *cx, JSObject *obj);
    1: 
    1: /*
    1:  * On first new context in rt, initialize script runtime state, specifically
    1:  * the script filename table and its lock.
    1:  */
    1: extern JSBool
    1: js_InitRuntimeScriptState(JSRuntime *rt);
    1: 
    1: /*
    1:  * On JS_DestroyRuntime(rt), forcibly free script filename prefixes and any
33534:  * script filename table entries that have not been GC'd.
    1:  *
    1:  * This allows script filename prefixes to outlive any context in rt.
    1:  */
    1: extern void
    1: js_FreeRuntimeScriptState(JSRuntime *rt);
    1: 
    1: extern void
    1: js_MarkScriptFilename(const char *filename);
    1: 
    1: extern void
41294: js_MarkScriptFilenames(JSRuntime *rt);
    1: 
    1: extern void
    1: js_SweepScriptFilenames(JSRuntime *rt);
    1: 
    1: /*
    1:  * New-script-hook calling is factored from js_NewScriptFromCG so that it
    1:  * and callers of js_XDRScript can share this code.  In the case of callers
    1:  * of js_XDRScript, the hook should be invoked only after successful decode
    1:  * of any owning function (the fun parameter) or script object (null fun).
    1:  */
13702: extern JS_FRIEND_API(void)
13702: js_CallNewScriptHook(JSContext *cx, JSScript *script, JSFunction *fun);
    1: 
62571: extern void
    1: js_CallDestroyScriptHook(JSContext *cx, JSScript *script);
    1: 
58041: /*
58041:  * The function must be used only outside the GC for a script that was run
58041:  * only on the current thread.
58041:  */
    1: extern void
    1: js_DestroyScript(JSContext *cx, JSScript *script);
    1: 
62571: extern void
62571: js_DestroyScriptFromGC(JSContext *cx, JSScript *script);
62571: 
58041: /*
62571:  * Script objects may be cached and reused, in which case their JSD-visible
62571:  * lifetimes may be shorter than their actual lifetimes. Destroy one such
62571:  * script for real as part of a GC pass. From JSD's point of view, the script
62571:  * is already dead.
58041:  */
58041: extern void
62571: js_DestroyCachedScript(JSContext *cx, JSScript *script);
58041: 
    1: extern void
  583: js_TraceScript(JSTracer *trc, JSScript *script);
    1: 
64190: extern JSObject *
51440: js_NewScriptObject(JSContext *cx, JSScript *script);
51440: 
    1: /*
    1:  * To perturb as little code as possible, we introduce a js_GetSrcNote lookup
    1:  * cache without adding an explicit cx parameter.  Thus js_GetSrcNote becomes
    1:  * a macro that uses cx from its calls' lexical environments.
    1:  */
    1: #define js_GetSrcNote(script,pc) js_GetSrcNoteCached(cx, script, pc)
    1: 
    1: extern jssrcnote *
    1: js_GetSrcNoteCached(JSContext *cx, JSScript *script, jsbytecode *pc);
    1: 
21685: /*
21685:  * NOTE: use js_FramePCToLineNumber(cx, fp) when you have an active fp, in
21685:  * preference to js_PCToLineNumber (cx, fp->script  fp->regs->pc), because
21685:  * fp->imacpc may be non-null, indicating an active imacro.
21685:  */
21685: extern uintN
21685: js_FramePCToLineNumber(JSContext *cx, JSStackFrame *fp);
21685: 
    1: extern uintN
    1: js_PCToLineNumber(JSContext *cx, JSScript *script, jsbytecode *pc);
    1: 
    1: extern jsbytecode *
    1: js_LineNumberToPC(JSScript *script, uintN lineno);
    1: 
    1: extern JS_FRIEND_API(uintN)
    1: js_GetScriptLineExtent(JSScript *script);
    1: 
25215: static JS_INLINE JSOp
25215: js_GetOpcode(JSContext *cx, JSScript *script, jsbytecode *pc)
25215: {
25215:     JSOp op = (JSOp) *pc;
25215:     if (op == JSOP_TRAP)
25215:         op = JS_GetTrapOpcode(cx, script, pc);
25215:     return op;
25215: }
25215: 
55633: extern JSScript *
55633: js_CloneScript(JSContext *cx, JSScript *script);
55633: 
    1: /*
59220:  * NB: after a successful JSXDR_DECODE, js_XDRScript callers must do any
59220:  * required subsequent set-up of owning function or script object and then call
59220:  * js_CallNewScriptHook.
    1:  */
    1: extern JSBool
64300: js_XDRScript(JSXDRState *xdr, JSScript **scriptp);
    1: 
68100: extern JSBool
68100: js_XDRScriptAndSubscripts(JSXDRState *xdr, JSScript **scriptp);
68100: 
64190: inline bool
64190: JSObject::isScript() const
64190: {
64190:     return getClass() == &js_ScriptClass;
64190: }
64190: 
64190: inline JSScript *
64190: JSObject::getScript() const
64190: {
64190:     JS_ASSERT(isScript());
64190:     return static_cast<JSScript *>(getPrivate());
64190: }
64190: 
    1: #endif /* jsscript_h___ */
