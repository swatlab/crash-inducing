  9499: /* -*- Mode: Objective-C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsCocoaWindow.h"
     1: 
 11978: #include "nsObjCExceptions.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsWidgetsCID.h"
     1: #include "nsGUIEvent.h"
     1: #include "nsIRollupListener.h"
     1: #include "nsChildView.h"
 14885: #include "nsWindowMap.h"
 26321: #include "nsAppShell.h"
     1: #include "nsIAppShellService.h"
     1: #include "nsIBaseWindow.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsIXULWindow.h"
  7634: #include "nsToolkit.h"
 29018: #include "nsIDOMWindow.h"
 29018: #include "nsPIDOMWindow.h"
 29018: #include "nsIDOMElement.h"
 11675: #include "nsThreadUtils.h"
 13608: #include "nsMenuBarX.h"
 15578: #include "nsMenuUtilsX.h"
 20467: #include "nsStyleConsts.h"
 20506: #include "nsNativeThemeColors.h"
 27993: #include "nsChildView.h"
 98723: #include "nsCocoaFeatures.h"
 98927: #include "nsIScreenManager.h"
108457: #include "nsIWidgetListener.h"
119103: #include "nsIPresShell.h"
     1: 
 14002: #include "gfxPlatform.h"
 27035: #include "qcms.h"
 14002: 
 70976: #include "mozilla/Preferences.h"
 70976: 
 38805: namespace mozilla {
 38805: namespace layers {
 38805: class LayerManager;
 38805: }
 38805: }
 38805: using namespace mozilla::layers;
 70976: using namespace mozilla;
 38805: 
 26321: // defined in nsAppShell.mm
 26321: extern nsCocoaAppModalWindowList *gCocoaAppModalWindowList;
 26321: 
108991: int32_t gXULModalLevel = 0;
 26321: 
 13491: // In principle there should be only one app-modal window at any given time.
 13491: // But sometimes, despite our best efforts, another window appears above the
 13491: // current app-modal window.  So we need to keep a linked list of app-modal
 13491: // windows.  (A non-sheet window that appears above an app-modal window is
 13491: // also made app-modal.)  See nsCocoaWindow::SetModal().
 26321: nsCocoaWindowList *gGeckoAppModalWindowList = NULL;
  6111: 
     1: // defined in nsMenuBarX.mm
     1: extern NSMenu* sApplicationMenu; // Application menu shared by all menubars
     1: 
     1: // defined in nsChildView.mm
     1: extern BOOL                gSomeMenuBarPainted;
     1: 
 36750: extern "C" {
 36750:   // CGSPrivate.h
 36750:   typedef NSInteger CGSConnection;
 36750:   typedef NSInteger CGSWindow;
 37144:   typedef NSUInteger CGSWindowFilterRef;
 36750:   extern CGSConnection _CGSDefaultConnection(void);
 36750:   extern CGError CGSSetWindowShadowAndRimParameters(const CGSConnection cid, CGSWindow wid, float standardDeviation, float density, int offsetX, int offsetY, unsigned int flags);
 37144:   extern CGError CGSNewCIFilterByName(CGSConnection cid, CFStringRef filterName, CGSWindowFilterRef *outFilter);
 37144:   extern CGError CGSSetCIFilterValuesFromDictionary(CGSConnection cid, CGSWindowFilterRef filter, CFDictionaryRef filterValues);
 37144:   extern CGError CGSAddWindowFilter(CGSConnection cid, CGSWindow wid, CGSWindowFilterRef filter, NSInteger flags);
 37144:   extern CGError CGSRemoveWindowFilter(CGSConnection cid, CGSWindow wid, CGSWindowFilterRef filter);
 37144:   extern CGError CGSReleaseCIFilter(CGSConnection cid, CGSWindowFilterRef filter);
 36750: }
 36750: 
     1: #define NS_APPSHELLSERVICE_CONTRACTID "@mozilla.org/appshell/appShellService;1"
     1: 
     1: NS_IMPL_ISUPPORTS_INHERITED1(nsCocoaWindow, Inherited, nsPIWidgetCocoa)
     1: 
  5900: // A note on testing to see if your object is a sheet...
  5900: // |mWindowType == eWindowType_sheet| is true if your gecko nsIWidget is a sheet
  5900: // widget - whether or not the sheet is showing. |[mWindow isSheet]| will return
  5900: // true *only when the sheet is actually showing*. Choose your test wisely.
  5900: 
  2314: static void RollUpPopups()
  2314: {
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
123327:   NS_ENSURE_TRUE_VOID(rollupListener);
120177:   nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
123327:   NS_ENSURE_TRUE_VOID(rollupWidget);
120177:     rollupListener->Rollup(0, nullptr);
  2314: }
  2314: 
     1: nsCocoaWindow::nsCocoaWindow()
106838: : mParent(nullptr)
     1: , mWindow(nil)
     1: , mDelegate(nil)
     1: , mSheetWindowParent(nil)
     1: , mPopupContentView(nil)
 36750: , mShadowStyle(NS_STYLE_WINDOW_SHADOW_DEFAULT)
 37144: , mWindowFilter(0)
115495: , mBackingScaleFactor(0.0)
 90340: , mAnimationType(nsIWidget::eGenericWindowAnimation)
 79564: , mWindowMadeHere(false)
 79564: , mSheetNeedsShow(false)
 79564: , mFullScreen(false)
 94397: , mInFullScreenTransition(false)
 79564: , mModal(false)
 93634: , mUsesNativeFullScreen(false)
 90340: , mIsAnimationSuppressed(false)
 84492: , mInReportMoveEvent(false)
 13491: , mNumModalDescendents(0)
     1: {
     1: 
     1: }
     1: 
 29540: void nsCocoaWindow::DestroyNativeWindow()
 29540: {
 29540:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 29540: 
102222:   if (!mWindow)
102222:     return;
102222: 
 37144:   CleanUpWindowFilter();
 29540:   // We want to unhook the delegate here because we don't want events
 29540:   // sent to it after this object has been destroyed.
 29540:   [mWindow setDelegate:nil];
 29540:   [mWindow close];
102222:   mWindow = nil;
 29540:   [mDelegate autorelease];
 29540: 
 29540:   NS_OBJC_END_TRY_ABORT_BLOCK;
 29540: }
 29540: 
     1: nsCocoaWindow::~nsCocoaWindow()
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 27679:   // Notify the children that we're gone.  Popup windows (e.g. tooltips) can
 27679:   // have nsChildView children.  'kid' is an nsChildView object if and only if
 33357:   // its 'type' is 'eWindowType_child' or 'eWindowType_plugin'.
 33357:   // childView->ResetParent() can change our list of children while it's
 33357:   // being iterated, so the way we iterate the list must allow for this.
 30427:   for (nsIWidget* kid = mLastChild; kid;) {
 27679:     nsWindowType kidType;
 27679:     kid->GetWindowType(kidType);
 33357:     if (kidType == eWindowType_child || kidType == eWindowType_plugin) {
 27679:       nsChildView* childView = static_cast<nsChildView*>(kid);
 30427:       kid = kid->GetPrevSibling();
 27679:       childView->ResetParent();
 27679:     } else {
  3233:       nsCocoaWindow* childWindow = static_cast<nsCocoaWindow*>(kid);
106838:       childWindow->mParent = nullptr;
 30427:       kid = kid->GetPrevSibling();
     1:     }
 27679:   }
     1: 
 32510:   if (mWindow && mWindowMadeHere) {
 29540:     DestroyNativeWindow();
     1:   }
     1: 
     1:   NS_IF_RELEASE(mPopupContentView);
  6111: 
  6111:   // Deal with the possiblity that we're being destroyed while running modal.
  6111:   NS_ASSERTION(!mModal, "Widget destroyed while running modal!");
  6111:   if (mModal) {
  6111:     --gXULModalLevel;
  6111:     NS_ASSERTION(gXULModalLevel >= 0, "Wierdness setting modality!");
  6111:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
 76916: // Find the screen that overlaps aRect the most,
 76916: // if none are found default to the mainScreen.
119101: static NSScreen *FindTargetScreenForRect(const nsIntRect& aRect)
119101: {
 76916:   NSScreen *targetScreen = [NSScreen mainScreen];
115495:   NSEnumerator *screenEnum = [[NSScreen screens] objectEnumerator];
 76916:   int largestIntersectArea = 0;
115495:   while (NSScreen *screen = [screenEnum nextObject]) {
115495:     nsIntRect screenRect(nsCocoaUtils::CocoaRectToGeckoRect([screen visibleFrame]));
115495:     screenRect = screenRect.Intersect(aRect);
115495:     int area = screenRect.width * screenRect.height;
 76916:     if (area > largestIntersectArea) {
 76916:       largestIntersectArea = area;
 76916:       targetScreen = screen;
 76916:     }
 76916:   }
119101:   return targetScreen;
119101: }
119101: 
119101: // fits the rect to the screen that contains the largest area of it,
119101: // or to aScreen if a screen is passed in
120795: // NB: this operates with aRect in global display pixels
119101: static void FitRectToVisibleAreaForScreen(nsIntRect &aRect, NSScreen *aScreen)
119101: {
119101:   if (!aScreen) {
119101:     aScreen = FindTargetScreenForRect(aRect);
119101:   }
119101: 
119101:   nsIntRect screenBounds(nsCocoaUtils::CocoaRectToGeckoRect([aScreen visibleFrame]));
119101: 
119101:   if (aRect.width > screenBounds.width) {
119101:     aRect.width = screenBounds.width;
119101:   }
119101:   if (aRect.height > screenBounds.height) {
119101:     aRect.height = screenBounds.height;
119101:   }
119101:   
119101:   if (aRect.x - screenBounds.x + aRect.width > screenBounds.width) {
119101:     aRect.x += screenBounds.width - (aRect.x - screenBounds.x + aRect.width);
119101:   }
119101:   if (aRect.y - screenBounds.y + aRect.height > screenBounds.height) {
119101:     aRect.y += screenBounds.height - (aRect.y - screenBounds.y + aRect.height);
119101:   }
119101: 
119101:   // If the left/top edge of the window is off the screen in either direction,
119101:   // then set the window to start at the left/top edge of the screen.
119101:   if (aRect.x < screenBounds.x || aRect.x > (screenBounds.x + screenBounds.width)) {
119101:     aRect.x = screenBounds.x;
119101:   }
119101:   if (aRect.y < screenBounds.y || aRect.y > (screenBounds.y + screenBounds.height)) {
119101:     aRect.y = screenBounds.y;
119101:   }
119101: }
119101: 
119101: // Some applications like Camino use native popup windows
119101: // (native context menus, native tooltips)
119101: static bool UseNativePopupWindows()
119101: {
119101: #ifdef MOZ_USE_NATIVE_POPUP_WINDOWS
119101:   return true;
119101: #else
119101:   return false;
119101: #endif /* MOZ_USE_NATIVE_POPUP_WINDOWS */
119101: }
119101: 
120795: // aRect here is specified in global display pixels
119101: nsresult nsCocoaWindow::Create(nsIWidget *aParent,
119101:                                nsNativeWidget aNativeParent,
119101:                                const nsIntRect &aRect,
119101:                                nsDeviceContext *aContext,
119101:                                nsWidgetInitData *aInitData)
119101: {
119101:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
119101: 
119101:   // Because the hidden window is created outside of an event loop,
119101:   // we have to provide an autorelease pool (see bug 559075).
119101:   nsAutoreleasePool localPool;
115495: 
 56422:   nsIntRect newBounds = aRect;
119101:   FitRectToVisibleAreaForScreen(newBounds, nullptr);
  8590: 
 33357:   // Set defaults which can be overriden from aInitData in BaseCreate
 33357:   mWindowType = eWindowType_toplevel;
 33357:   mBorderStyle = eBorderStyle_default;
 33357: 
 80842:   // Ensure that the toolkit is created.
 80842:   nsToolkit::GetToolkit();
 80842: 
120795:   // newBounds is still display (global screen) pixels at this point;
120795:   // fortunately, BaseCreate doesn't actually use it so we don't
120795:   // need to worry about trying to convert it to device pixels
120795:   // when we don't have a window (or dev context, perhaps) yet
108460:   Inherited::BaseCreate(aParent, newBounds, aContext, aInitData);
     1: 
     1:   mParent = aParent;
 29540: 
 33013:   // Applications that use native popups don't want us to create popup windows.
 33013:   if ((mWindowType == eWindowType_popup) && UseNativePopupWindows())
 33013:     return NS_OK;
 33013: 
120795:   nsresult rv =
120795:     CreateNativeWindow(nsCocoaUtils::GeckoRectToCocoaRect(newBounds),
 79564:                        mBorderStyle, false);
 29540:   NS_ENSURE_SUCCESS(rv, rv);
 29540: 
 77050:   if (mWindowType == eWindowType_popup) {
 77050:     if (aInitData->mIsDragPopup) {
 77050:       [mWindow setIgnoresMouseEvents:YES];
 77050:     }
120795:     // now we can convert newBounds to device pixels for the window we created,
120795:     // as the child view expects a rect expressed in the dev pix of its parent
120795:     double scale = BackingScaleFactor();
120795:     newBounds.x *= scale;
120795:     newBounds.y *= scale;
120795:     newBounds.width *= scale;
120795:     newBounds.height *= scale;
108460:     return CreatePopupContentView(newBounds, aContext);
 77050:   }
 29540: 
 90340:   mIsAnimationSuppressed = aInitData->mIsAnimationSuppressed;
 90340: 
 29540:   return NS_OK;
 29540: 
 29540:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 29540: }
 29540: 
 29618: static unsigned int WindowMaskForBorderStyle(nsBorderStyle aBorderStyle)
 29618: {
 79445:   bool allOrDefault = (aBorderStyle == eBorderStyle_all ||
 29618:                          aBorderStyle == eBorderStyle_default);
 29618: 
 29618:   /* Apple's docs on NSWindow styles say that "a window's style mask should
 29618:    * include NSTitledWindowMask if it includes any of the others [besides
 29618:    * NSBorderlessWindowMask]".  This implies that a borderless window
 29618:    * shouldn't have any other styles than NSBorderlessWindowMask.
 29618:    */
 29618:   if (!allOrDefault && !(aBorderStyle & eBorderStyle_title))
 29618:     return NSBorderlessWindowMask;
 29618: 
 34004:   unsigned int mask = NSTitledWindowMask;
 29618:   if (allOrDefault || aBorderStyle & eBorderStyle_close)
 29618:     mask |= NSClosableWindowMask;
 34004:   if (allOrDefault || aBorderStyle & eBorderStyle_minimize)
 34004:     mask |= NSMiniaturizableWindowMask;
 29618:   if (allOrDefault || aBorderStyle & eBorderStyle_resizeh)
 29618:     mask |= NSResizableWindowMask;
 29618: 
 29618:   return mask;
 29618: }
 29618: 
 54312: NS_IMETHODIMP nsCocoaWindow::ReparentNativeWidget(nsIWidget* aNewParent)
 54312: {
 54312:   return NS_ERROR_NOT_IMPLEMENTED;
 54312: }
 54312: 
 30549: // If aRectIsFrameRect, aRect specifies the frame rect of the new window.
 30549: // Otherwise, aRect.x/y specify the position of the window's frame relative to
 30549: // the bottom of the menubar and aRect.width/height specify the size of the
 30549: // content rect.
 30549: nsresult nsCocoaWindow::CreateNativeWindow(const NSRect &aRect,
 30549:                                            nsBorderStyle aBorderStyle,
 79445:                                            bool aRectIsFrameRect)
 29540: {
 29540:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 29540: 
 29618:   // We default to NSBorderlessWindowMask, add features if needed.
     1:   unsigned int features = NSBorderlessWindowMask;
     1: 
 29618:   // Configure the window we will create based on the window type.
     1:   switch (mWindowType)
     1:   {
     1:     case eWindowType_invisible:
     1:     case eWindowType_child:
 33357:     case eWindowType_plugin:
 48256:       break;
 29618:     case eWindowType_popup:
 48256:       if (aBorderStyle != eBorderStyle_default && mBorderStyle & eBorderStyle_title) {
 48256:         features |= NSTitledWindowMask;
 48261:         if (aBorderStyle & eBorderStyle_close) {
 48261:           features |= NSClosableWindowMask;
 48261:         }
 48256:       }
     1:       break;
 29618:     case eWindowType_toplevel:
     1:     case eWindowType_dialog:
 29618:       features = WindowMaskForBorderStyle(aBorderStyle);
     1:       break;
     1:     case eWindowType_sheet:
     1:       nsWindowType parentType;
 29540:       mParent->GetWindowType(parentType);
     1:       if (parentType != eWindowType_invisible &&
 29540:           aBorderStyle & eBorderStyle_resizeh) {
     1:         features = NSResizableWindowMask;
     1:       }
     1:       else {
     1:         features = NSMiniaturizableWindowMask;
     1:       }
     1:       features |= NSTitledWindowMask;
     1:       break;
     1:     default:
     1:       NS_ERROR("Unhandled window type!");
     1:       return NS_ERROR_FAILURE;
     1:   }
     1: 
 30549:   NSRect contentRect;
 30549: 
 30549:   if (aRectIsFrameRect) {
 30549:     contentRect = [NSWindow contentRectForFrameRect:aRect styleMask:features];
 30549:   } else {
     1:     /* 
     1:      * We pass a content area rect to initialize the native Cocoa window. The
     1:      * content rect we give is the same size as the size we're given by gecko.
     1:      * The origin we're given for non-popup windows is moved down by the height
     1:      * of the menu bar so that an origin of (0,100) from gecko puts the window
     1:      * 100 pixels below the top of the available desktop area. We also move the
     1:      * origin down by the height of a title bar if it exists. This is so the
     1:      * origin that gecko gives us for the top-left of  the window turns out to
     1:      * be the top-left of the window we create. This is how it was done in
     1:      * Carbon. If it ought to be different we'll probably need to look at all
     1:      * the callers.
     1:      *
     1:      * Note: This means that if you put a secondary screen on top of your main
     1:      * screen and open a window in the top screen, it'll be incorrectly shifted
     1:      * down by the height of the menu bar. Same thing would happen in Carbon.
     1:      *
     1:      * Note: If you pass a rect with 0,0 for an origin, the window ends up in a
     1:      * weird place for some reason. This stops that without breaking popups.
     1:      */
 30549:     // Compensate for difference between frame and content area height (e.g. title bar).
 30549:     NSRect newWindowFrame = [NSWindow frameRectForContentRect:aRect styleMask:features];
     1: 
 30549:     contentRect = aRect;
 30549:     contentRect.origin.y -= (newWindowFrame.size.height - aRect.size.height);
     1: 
     1:     if (mWindowType != eWindowType_popup)
 31406:       contentRect.origin.y -= [[NSApp mainMenu] menuBarHeight];
 30549:   }
     1: 
     1:   // NSLog(@"Top-level window being created at Cocoa rect: %f, %f, %f, %f\n",
     1:   //       rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
     1: 
 34487:   Class windowClass = [BaseWindow class];
  8121:   // If we have a titlebar on a top-level window, we want to be able to control the 
  8121:   // titlebar color (for unified windows), so use the special ToolbarWindow class. 
 29540:   // Note that we need to check the window type because we mark sheets as 
  8121:   // having titlebars.
 31095:   if ((mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog) &&
  7242:       (features & NSTitledWindowMask))
  3574:     windowClass = [ToolbarWindow class];
  3574:   // If we're a popup window we need to use the PopupWindow class.
  3574:   else if (mWindowType == eWindowType_popup)
  3574:     windowClass = [PopupWindow class];
  7042:   // If we're a non-popup borderless window we need to use the
  7042:   // BorderlessWindow class.
  7042:   else if (features == NSBorderlessWindowMask)
  7042:     windowClass = [BorderlessWindow class];
  7242: 
  7242:   // Create the window
 30549:   mWindow = [[windowClass alloc] initWithContentRect:contentRect styleMask:features 
  9499:                                  backing:NSBackingStoreBuffered defer:YES];
     1: 
119103:   // setup our notification delegate. Note that setDelegate: does NOT retain.
119103:   mDelegate = [[WindowDelegate alloc] initWithGeckoWindow:this];
119103:   [mWindow setDelegate:mDelegate];
119103: 
 30549:   // Make sure that the content rect we gave has been honored.
 30549:   NSRect wantedFrame = [mWindow frameRectForContentRect:contentRect];
 30549:   if (!NSEqualRects([mWindow frame], wantedFrame)) {
 30549:     // This can happen when the window is not on the primary screen.
 30549:     [mWindow setFrame:wantedFrame display:NO];
 30549:   }
 59551:   UpdateBounds();
 30549: 
 29540:   if (mWindowType == eWindowType_invisible) {
 29540:     [mWindow setLevel:kCGDesktopWindowLevelKey];
 29853:   } else if (mWindowType == eWindowType_popup) {
 48254:     SetPopupWindowLevel();
 29853:     [mWindow setHasShadow:YES];
 29540:   }
 29540: 
 67728:   [mWindow setBackgroundColor:[NSColor clearColor]];
 67728:   [mWindow setOpaque:NO];
 29540:   [mWindow setContentMinSize:NSMakeSize(60, 60)];
 30495:   [mWindow disableCursorRects];
 29540: 
 30549:   [[WindowDataMap sharedWindowDataMap] ensureDataForWindow:mWindow];
 79564:   mWindowMadeHere = true;
 29540: 
 29540:   return NS_OK;
 29540: 
 29540:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 29540: }
 29540: 
 29540: NS_IMETHODIMP nsCocoaWindow::CreatePopupContentView(const nsIntRect &aRect,
 80842:                              nsDeviceContext *aContext)
 29540: {
 29540:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 29540: 
 29540:   // We need to make our content view a ChildView.
     1:   mPopupContentView = new nsChildView();
 29540:   if (!mPopupContentView)
 29540:     return NS_ERROR_FAILURE;
 29540: 
     1:   NS_ADDREF(mPopupContentView);
     1: 
  3233:   nsIWidget* thisAsWidget = static_cast<nsIWidget*>(this);
108460:   mPopupContentView->Create(thisAsWidget, nullptr, aRect, aContext, nullptr);
     1: 
     1:   ChildView* newContentView = (ChildView*)mPopupContentView->GetNativeData(NS_NATIVE_WIDGET);
     1:   [mWindow setContentView:newContentView];
 29297: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
     1: NS_IMETHODIMP nsCocoaWindow::Destroy()
     1: {
     1:   if (mPopupContentView)
     1:     mPopupContentView->Destroy();
     1: 
 25875:   nsBaseWidget::Destroy();
     1:   nsBaseWidget::OnDestroy();
     1: 
102222:   if (mFullScreen) {
102222:     // On Lion we don't have to mess with the OS chrome when in Full Screen
102222:     // mode.  But we do have to destroy the native window here (and not wait
102222:     // for that to happen in our destructor).  We don't switch away from the
102222:     // native window's space until the window is destroyed, and otherwise this
102222:     // might not happen for several seconds (because at least one object
102222:     // holding a reference to ourselves is usually waiting to be garbage-
102222:     // collected).  See bug 757618.
102222:     if (mUsesNativeFullScreen) {
102222:       DestroyNativeWindow();
102222:     } else if (mWindow) {
 79564:       nsCocoaUtils::HideOSChromeOnScreen(false, [mWindow screen]);
 62309:     }
102222:   }
 62309: 
     1:   return NS_OK;
     1: }
     1: 
 14886: nsIWidget* nsCocoaWindow::GetSheetWindowParent(void)
 14886: {
 14886:   if (mWindowType != eWindowType_sheet)
106838:     return nullptr;
 14886:   nsCocoaWindow *parent = static_cast<nsCocoaWindow*>(mParent);
 14886:   while (parent && (parent->mWindowType == eWindowType_sheet))
 14886:     parent = static_cast<nsCocoaWindow*>(parent->mParent);
 14886:   return parent;
 14886: }
 14886: 
108991: void* nsCocoaWindow::GetNativeData(uint32_t aDataType)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSNULL;
 11978: 
106838:   void* retVal = nullptr;
     1:   
     1:   switch (aDataType) {
     1:     // to emulate how windows works, we always have to return a NSView
     1:     // for NS_NATIVE_WIDGET
     1:     case NS_NATIVE_WIDGET:
     1:     case NS_NATIVE_DISPLAY:
     1:       retVal = [mWindow contentView];
     1:       break;
     1:       
     1:     case NS_NATIVE_WINDOW:
     1:       retVal = mWindow;
     1:       break;
     1:       
     1:     case NS_NATIVE_GRAPHIC:
     1:       // There isn't anything that makes sense to return here,
106838:       // and it doesn't matter so just return nullptr.
 31561:       NS_ERROR("Requesting NS_NATIVE_GRAPHIC on a top-level window!");
     1:       break;
     1:   }
     1: 
     1:   return retVal;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL;
     1: }
     1: 
105772: bool nsCocoaWindow::IsVisible() const
     1: {
105772:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
105772: 
105772:   return (mWindow && ([mWindow isVisible] || mSheetNeedsShow));
105772: 
105772:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(false);
     1: }
     1: 
 79445: NS_IMETHODIMP nsCocoaWindow::SetModal(bool aState)
  6111: {
102222:   if (!mWindow)
102222:     return NS_OK;
102222: 
 40766:   // This is used during startup (outside the event loop) when creating
 40766:   // the add-ons compatibility checking dialog and the profile manager UI;
 40766:   // therefore, it needs to provide an autorelease pool to avoid cocoa
 40766:   // objects leaking.
 40766:   nsAutoreleasePool localPool;
 40766: 
  6111:   mModal = aState;
 13491:   nsCocoaWindow *aParent = static_cast<nsCocoaWindow*>(mParent);
  6111:   if (aState) {
  6111:     ++gXULModalLevel;
 26321:     if (gCocoaAppModalWindowList)
 26321:       gCocoaAppModalWindowList->PushGecko(mWindow, this);
 14843:     // When a non-sheet window gets "set modal", make the window(s) that it
 14843:     // appears over behave as they should.  We can't rely on native methods to
 14843:     // do this, for the following reason:  The OS runs modal non-sheet windows
 14843:     // in an event loop (using [NSApplication runModalForWindow:] or similar
 14843:     // methods) that's incompatible with the modal event loop in nsXULWindow::
 14843:     // ShowModal() (each of these event loops is "exclusive", and can't run at
 14843:     // the same time as other (similar) event loops).
 14843:     if (mWindowType != eWindowType_sheet) {
 13491:       while (aParent) {
 13491:         if (aParent->mNumModalDescendents++ == 0) {
 13491:           NSWindow *aWindow = aParent->GetCocoaWindow();
 13491:           if (aParent->mWindowType != eWindowType_invisible) {
 13491:             [[aWindow standardWindowButton:NSWindowCloseButton] setEnabled:NO];
 13491:             [[aWindow standardWindowButton:NSWindowMiniaturizeButton] setEnabled:NO];
 13491:             [[aWindow standardWindowButton:NSWindowZoomButton] setEnabled:NO];
 13491:           }
 13491:         }
 13491:         aParent = static_cast<nsCocoaWindow*>(aParent->mParent);
 13491:       }
 13491:       [mWindow setLevel:NSModalPanelWindowLevel];
 13491:       nsCocoaWindowList *windowList = new nsCocoaWindowList;
 13491:       if (windowList) {
 13491:         windowList->window = this; // Don't ADDREF
 26321:         windowList->prev = gGeckoAppModalWindowList;
 26321:         gGeckoAppModalWindowList = windowList;
 13491:       }
 13491:     }
 13491:   }
 13491:   else {
  6111:     --gXULModalLevel;
 79564:     NS_ASSERTION(gXULModalLevel >= 0, "Mismatched call to nsCocoaWindow::SetModal(false)!");
 26321:     if (gCocoaAppModalWindowList)
 26321:       gCocoaAppModalWindowList->PopGecko(mWindow, this);
 14843:     if (mWindowType != eWindowType_sheet) {
 13491:       while (aParent) {
 13491:         if (--aParent->mNumModalDescendents == 0) {
 13491:           NSWindow *aWindow = aParent->GetCocoaWindow();
 13491:           if (aParent->mWindowType != eWindowType_invisible) {
 13491:             [[aWindow standardWindowButton:NSWindowCloseButton] setEnabled:YES];
 13491:             [[aWindow standardWindowButton:NSWindowMiniaturizeButton] setEnabled:YES];
 13491:             [[aWindow standardWindowButton:NSWindowZoomButton] setEnabled:YES];
 13491:           }
 13491:         }
 13491:         NS_ASSERTION(aParent->mNumModalDescendents >= 0, "Widget hierarchy changed while modal!");
 13491:         aParent = static_cast<nsCocoaWindow*>(aParent->mParent);
 13491:       }
 26321:       if (gGeckoAppModalWindowList) {
 26321:         NS_ASSERTION(gGeckoAppModalWindowList->window == this, "Widget hierarchy changed while modal!");
 26321:         nsCocoaWindowList *saved = gGeckoAppModalWindowList;
 26321:         gGeckoAppModalWindowList = gGeckoAppModalWindowList->prev;
 13491:         delete saved; // "window" not ADDREFed
 13491:       }
 13491:       if (mWindowType == eWindowType_popup)
 48254:         SetPopupWindowLevel();
 13491:       else
 13491:         [mWindow setLevel:NSNormalWindowLevel];
 13491:     }
  6111:   }
  6111:   return NS_OK;
  6111: }
  6111: 
     1: // Hide or show this window
 79445: NS_IMETHODIMP nsCocoaWindow::Show(bool bState)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
102222:   if (!mWindow)
102222:     return NS_OK;
102222: 
 12278:   // We need to re-execute sometimes in order to bring already-visible
 12278:   // windows forward.
 61363:   if (!mSheetNeedsShow && !bState && ![mWindow isVisible])
 11899:     return NS_OK;
 11899: 
     1:   nsIWidget* parentWidget = mParent;
     1:   nsCOMPtr<nsPIWidgetCocoa> piParentWidget(do_QueryInterface(parentWidget));
     1:   NSWindow* nativeParentWindow = (parentWidget) ?
     1:     (NSWindow*)parentWidget->GetNativeData(NS_NATIVE_WINDOW) : nil;
     1: 
     1:   if (bState && !mBounds.IsEmpty()) {
     1:     if (mWindowType == eWindowType_sheet) {
     1:       // bail if no parent window (its basically what we do in Carbon)
 61363:       if (!nativeParentWindow || !piParentWidget)
     1:         return NS_ERROR_FAILURE;
     1: 
     1:       NSWindow* topNonSheetWindow = nativeParentWindow;
     1:       
     1:       // If this sheet is the child of another sheet, hide the parent so that
     1:       // this sheet can be displayed. Leave the parent mSheetNeedsShow alone,
     1:       // that is only used to handle sibling sheet contention. The parent will
     1:       // return once there are no more child sheets.
 79445:       bool parentIsSheet = false;
     1:       if (NS_SUCCEEDED(piParentWidget->GetIsSheet(&parentIsSheet)) &&
     1:           parentIsSheet) {
     1:         piParentWidget->GetSheetWindowParent(&topNonSheetWindow);
     1:         [NSApp endSheet:nativeParentWindow];
     1:       }
     1: 
106838:       nsCocoaWindow* sheetShown = nullptr;
 79564:       if (NS_SUCCEEDED(piParentWidget->GetChildSheet(true, &sheetShown)) &&
     1:           (!sheetShown || sheetShown == this)) {
     1:         // If this sheet is already the sheet actually being shown, don't
     1:         // tell it to show again. Otherwise the number of calls to
     1:         // [NSApp beginSheet...] won't match up with [NSApp endSheet...].
 12066:         if (![mWindow isVisible]) {
 79564:           mSheetNeedsShow = false;
     1:           mSheetWindowParent = topNonSheetWindow;
 15026:           // Only set contextInfo if our parent isn't a sheet.
 15026:           NSWindow* contextInfo = parentIsSheet ? nil : mSheetWindowParent;
 14885:           [TopLevelWindowData deactivateInWindow:mSheetWindowParent];
     1:           [NSApp beginSheet:mWindow
     1:              modalForWindow:mSheetWindowParent
     1:               modalDelegate:mDelegate
     1:              didEndSelector:@selector(didEndSheet:returnCode:contextInfo:)
 15026:                 contextInfo:contextInfo];
 14885:           [TopLevelWindowData activateInWindow:mWindow];
     1:           SendSetZLevelEvent();
     1:         }
     1:       }
     1:       else {
     1:         // A sibling of this sheet is active, don't show this sheet yet.
     1:         // When the active sheet hides, its brothers and sisters that have
     1:         // mSheetNeedsShow set will have their opportunities to display.
 79564:         mSheetNeedsShow = true;
     1:       }
     1:     }
     1:     else if (mWindowType == eWindowType_popup) {
  3574:       // If a popup window is shown after being hidden, it needs to be "reset"
  3574:       // for it to receive any mouse events aside from mouse-moved events
  3574:       // (because it was removed from the "window cache" when it was hidden
  3574:       // -- see below).  Setting the window number to -1 and then back to its
  3574:       // original value seems to accomplish this.  The idea was "borrowed"
  3574:       // from the Java Embedding Plugin.
 33037:       NSInteger windowNumber = [mWindow windowNumber];
  3574:       [mWindow _setWindowNumber:-1];
  3574:       [mWindow _setWindowNumber:windowNumber];
 24417:       // For reasons that aren't yet clear, calls to [NSWindow orderFront:] or
 24417:       // [NSWindow makeKeyAndOrderFront:] can sometimes trigger "Error (1000)
 24417:       // creating CGSWindow", which in turn triggers an internal inconsistency
 24417:       // NSException.  These errors shouldn't be fatal.  So we need to wrap
 24417:       // calls to ...orderFront: in LOGONLY blocks.  See bmo bug 470864.
 24417:       NS_OBJC_BEGIN_TRY_LOGONLY_BLOCK;
     1:       [mWindow orderFront:nil];
 24417:       NS_OBJC_END_TRY_LOGONLY_BLOCK;
     1:       SendSetZLevelEvent();
 36750:       AdjustWindowShadow();
 37144:       SetUpWindowFilter();
  3574:       // If our popup window is a non-native context menu, tell the OS (and
  3574:       // other programs) that a menu has opened.  This is how the OS knows to
  3574:       // close other programs' context menus when ours open.
  3574:       if ([mWindow isKindOfClass:[PopupWindow class]] &&
  3574:           [(PopupWindow*) mWindow isContextMenu]) {
  3574:         [[NSDistributedNotificationCenter defaultCenter]
  3574:           postNotificationName:@"com.apple.HIToolbox.beginMenuTrackingNotification"
  3574:                         object:@"org.mozilla.gecko.PopupWindow"];
  3574:       }
  8408: 
 48254:       // If a parent window was supplied and this is a popup at the parent
 48254:       // level, set its child window. This will cause the child window to
 48254:       // appear above the parent and move when the parent does. Setting this
 48254:       // needs to happen after the _setWindowNumber calls above, otherwise the
 48254:       // window doesn't focus properly.
 48254:       if (nativeParentWindow && mPopupLevel == ePopupLevelParent)
  8408:         [nativeParentWindow addChildWindow:mWindow
  8408:                             ordered:NSWindowAbove];
     1:     }
     1:     else {
 24417:       NS_OBJC_BEGIN_TRY_LOGONLY_BLOCK;
 90340:       if (mWindowType == eWindowType_toplevel &&
 90340:           [mWindow respondsToSelector:@selector(setAnimationBehavior:)]) {
 90340:         NSWindowAnimationBehavior behavior;
 90340:         if (mIsAnimationSuppressed) {
 90340:           behavior = NSWindowAnimationBehaviorNone;
 90340:         } else {
 90340:           switch (mAnimationType) {
 90340:             case nsIWidget::eDocumentWindowAnimation:
 90340:               behavior = NSWindowAnimationBehaviorDocumentWindow;
 90340:               break;
 90340:             default:
 90340:               NS_NOTREACHED("unexpected mAnimationType value");
 90340:               // fall through
 90340:             case nsIWidget::eGenericWindowAnimation:
 90340:               behavior = NSWindowAnimationBehaviorDefault;
 90340:               break;
 90340:           }
 90340:         }
 90340:         [mWindow setAnimationBehavior:behavior];
 90340:       }
     1:       [mWindow makeKeyAndOrderFront:nil];
 24417:       NS_OBJC_END_TRY_LOGONLY_BLOCK;
     1:       SendSetZLevelEvent();
     1:     }
     1:   }
     1:   else {
     1:     // roll up any popups if a top-level window is going away
 31095:     if (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog)
  2314:       RollUpPopups();
     1: 
     1:     // now get rid of the window/sheet
     1:     if (mWindowType == eWindowType_sheet) {
 11899:       if (mSheetNeedsShow) {
 11899:         // This is an attempt to hide a sheet that never had a chance to
 11899:         // be shown. There's nothing to do other than make sure that it
 11899:         // won't show.
 79564:         mSheetNeedsShow = false;
 11899:       }
 11899:       else {
     1:         // get sheet's parent *before* hiding the sheet (which breaks the linkage)
     1:         NSWindow* sheetParent = mSheetWindowParent;
     1:         
     1:         // hide the sheet
     1:         [NSApp endSheet:mWindow];
     1:         
 14885:         [TopLevelWindowData deactivateInWindow:mWindow];
     1: 
106838:         nsCocoaWindow* siblingSheetToShow = nullptr;
 79445:         bool parentIsSheet = false;
     1: 
     1:         if (nativeParentWindow && piParentWidget &&
 79564:             NS_SUCCEEDED(piParentWidget->GetChildSheet(false, &siblingSheetToShow)) &&
     1:             siblingSheetToShow) {
     1:           // First, give sibling sheets an opportunity to show.
 79564:           siblingSheetToShow->Show(true);
     1:         }
     1:         else if (nativeParentWindow && piParentWidget &&
     1:                  NS_SUCCEEDED(piParentWidget->GetIsSheet(&parentIsSheet)) &&
     1:                  parentIsSheet) {
 15026:           // Only set contextInfo if the parent of the parent sheet we're about
 15026:           // to restore isn't itself a sheet.
 15026:           NSWindow* contextInfo = sheetParent;
 15026:           nsIWidget* grandparentWidget = nil;
 15026:           if (NS_SUCCEEDED(piParentWidget->GetRealParent(&grandparentWidget)) && grandparentWidget) {
 15026:             nsCOMPtr<nsPIWidgetCocoa> piGrandparentWidget(do_QueryInterface(grandparentWidget));
 79445:             bool grandparentIsSheet = false;
 15026:             if (piGrandparentWidget && NS_SUCCEEDED(piGrandparentWidget->GetIsSheet(&grandparentIsSheet)) &&
 15026:                 grandparentIsSheet) {
 15026:                 contextInfo = nil;
 15026:             }
 15026:           }
     1:           // If there are no sibling sheets, but the parent is a sheet, restore
     1:           // it.  It wasn't sent any deactivate events when it was hidden, so
     1:           // don't call through Show, just let the OS put it back up.
     1:           [NSApp beginSheet:nativeParentWindow
     1:              modalForWindow:sheetParent
     1:               modalDelegate:[nativeParentWindow delegate]
     1:              didEndSelector:@selector(didEndSheet:returnCode:contextInfo:)
 15026:                 contextInfo:contextInfo];
     1:         }
     1:         else {
     1:           // Sheet, that was hard.  No more siblings or parents, going back
     1:           // to a real window.
 24417:           NS_OBJC_BEGIN_TRY_LOGONLY_BLOCK;
     1:           [sheetParent makeKeyAndOrderFront:nil];
 24417:           NS_OBJC_END_TRY_LOGONLY_BLOCK;
     1:         }
     1:         SendSetZLevelEvent();
     1:       }
     1:     }
     1:     else {
  8769:       // If the window is a popup window with a parent window we need to
  8769:       // unhook it here before ordering it out. When you order out the child
  8769:       // of a window it hides the parent window.
  8769:       if (mWindowType == eWindowType_popup && nativeParentWindow)
  8769:         [nativeParentWindow removeChildWindow:mWindow];
  8769: 
 37144:       CleanUpWindowFilter();
     1:       [mWindow orderOut:nil];
  3574:       // Unless it's explicitly removed from NSApp's "window cache", a popup
  3574:       // window will keep receiving mouse-moved events even after it's been
  3574:       // "ordered out" (instead of the browser window that was underneath it,
  3574:       // until you click on that window).  This is bmo bug 378645, but it's
  3574:       // surely an Apple bug.  The "window cache" is an undocumented subsystem,
  3574:       // all of whose methods are included in the NSWindowCache category of
  3574:       // the NSApplication class (in header files generated using class-dump).
  3574:       // This workaround was "borrowed" from the Java Embedding Plugin (which
  3574:       // uses it for a different purpose).
 30470:       if (mWindowType == eWindowType_popup)
  3574:         [NSApp _removeWindowFromCache:mWindow];
  8408: 
  3574:       // If our popup window is a non-native context menu, tell the OS (and
  3574:       // other programs) that a menu has closed.
  3574:       if ([mWindow isKindOfClass:[PopupWindow class]] &&
  3574:           [(PopupWindow*) mWindow isContextMenu]) {
  3574:         [[NSDistributedNotificationCenter defaultCenter]
  3574:           postNotificationName:@"com.apple.HIToolbox.endMenuTrackingNotification"
  3574:                         object:@"org.mozilla.gecko.PopupWindow"];
  3574:       }
     1:     }
     1:   }
     1:   
 61363:   if (mPopupContentView)
 61363:       mPopupContentView->Show(bState);
 61363: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
 36750: struct ShadowParams {
 36750:   float standardDeviation;
 36750:   float density;
 36750:   int offsetX;
 36750:   int offsetY;
 36750:   unsigned int flags;
 36750: };
 36750: 
 36750: // These numbers have been determined by looking at the results of
 36750: // CGSGetWindowShadowAndRimParameters for native window types.
 36750: static const ShadowParams kWindowShadowParameters[] = {
 36750:   { 0.0f, 0.0f, 0, 0, 0 },        // none
 36750:   { 8.0f, 0.5f, 0, 6, 1 },        // default
 36750:   { 10.0f, 0.44f, 0, 10, 512 },   // menu
 36750:   { 8.0f, 0.5f, 0, 6, 1 },        // tooltip
 36750:   { 4.0f, 0.6f, 0, 4, 512 }       // sheet
 36750: };
 36750: 
 36750: // This method will adjust the window shadow style for popup windows after
 36750: // they have been made visible. Before they're visible, their window number
 36750: // might be -1, which is not useful.
 36750: // We won't attempt to change the shadow for windows that can acquire key state
 36750: // since OS X will reset the shadow whenever that happens.
 36750: void
 36750: nsCocoaWindow::AdjustWindowShadow()
 36750: {
 36750:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 36750: 
102222:   if (!mWindow || ![mWindow isVisible] || ![mWindow hasShadow] ||
 36750:       [mWindow canBecomeKeyWindow] || [mWindow windowNumber] == -1)
 36750:     return;
 36750: 
 36750:   const ShadowParams& params = kWindowShadowParameters[mShadowStyle];
 36750:   CGSConnection cid = _CGSDefaultConnection();
 36750:   CGSSetWindowShadowAndRimParameters(cid, [mWindow windowNumber],
 36750:                                      params.standardDeviation, params.density,
 36750:                                      params.offsetX, params.offsetY,
 36750:                                      params.flags);
 36750: 
 36750:   NS_OBJC_END_TRY_ABORT_BLOCK;
 36750: }
 36750: 
 37144: void
 37144: nsCocoaWindow::SetUpWindowFilter()
 37144: {
 37144:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 37144: 
102222:   if (!mWindow || ![mWindow isVisible] || [mWindow windowNumber] == -1)
 37144:     return;
 37144: 
 37144:   CleanUpWindowFilter();
 37144: 
 39095:   // Only blur the background of menus and fake sheets, but not on PPC
 39095:   // because it results in blank windows (bug 547723).
 39095: #ifndef __ppc__
 37144:   if (mShadowStyle != NS_STYLE_WINDOW_SHADOW_MENU &&
 37144:       mShadowStyle != NS_STYLE_WINDOW_SHADOW_SHEET)
 39095: #endif
 37144:     return;
 37144: 
 37144:   // Create a CoreImage filter and set it up
 37144:   CGSConnection cid = _CGSDefaultConnection();
 37144:   CGSNewCIFilterByName(cid, (CFStringRef)@"CIGaussianBlur", &mWindowFilter);
 37144:   NSDictionary *options = [NSDictionary dictionaryWithObject:[NSNumber numberWithFloat:2.0] forKey:@"inputRadius"];
 37144:   CGSSetCIFilterValuesFromDictionary(cid, mWindowFilter, (CFDictionaryRef)options);
 37144: 
 37144:   // Now apply the filter to the window
 37144:   NSInteger compositingType = 1 << 0; // Under the window
 37144:   CGSAddWindowFilter(cid, [mWindow windowNumber], mWindowFilter, compositingType);
 37144: 
 37144:   NS_OBJC_END_TRY_ABORT_BLOCK;
 37144: }
 37144: 
 37144: void
 37144: nsCocoaWindow::CleanUpWindowFilter()
 37144: {
102222:   if (!mWindow || !mWindowFilter || [mWindow windowNumber] == -1)
 37144:     return;
 37144: 
 37144:   CGSConnection cid = _CGSDefaultConnection();
 37144:   CGSRemoveWindowFilter(cid, [mWindow windowNumber], mWindowFilter);
 37144:   CGSReleaseCIFilter(cid, mWindowFilter);
 37144:   mWindowFilter = 0;
 37144: }
 37144: 
 30515: nsresult
 30515: nsCocoaWindow::ConfigureChildren(const nsTArray<Configuration>& aConfigurations)
 30515: {
 30540:   if (mPopupContentView) {
 30540:     mPopupContentView->ConfigureChildren(aConfigurations);
 30515:   }
 30515:   return NS_OK;
 30515: }
 30515: 
 38805: LayerManager*
 75149: nsCocoaWindow::GetLayerManager(PLayersChild* aShadowManager,
 75149:                                LayersBackend aBackendHint,
 75149:                                LayerManagerPersistence aPersistence,
 75149:                                bool* aAllowRetaining)
 63556: {
 63556:   if (mPopupContentView) {
 75149:     return mPopupContentView->GetLayerManager(aShadowManager,
 75149:                                               aBackendHint,
 75149:                                               aPersistence,
 75149:                                               aAllowRetaining);
 38805:   }
106838:   return nullptr;
 38805: }
 38805: 
 16601: nsTransparencyMode nsCocoaWindow::GetTransparencyMode()
  9499: {
 18401:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 16601: 
102222:   return (!mWindow || [mWindow isOpaque]) ? eTransparencyOpaque : eTransparencyTransparent;
 16601: 
 18401:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(eTransparencyOpaque);
  9499: }
  9499: 
  9499: // This is called from nsMenuPopupFrame when making a popup transparent.
 16601: // For other window types, nsChildView::SetTransparencyMode is used.
 16601: void nsCocoaWindow::SetTransparencyMode(nsTransparencyMode aMode)
  9499: {
 16601:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 16601: 
102222:   if (!mWindow)
102222:     return;
102222: 
 16601:   BOOL isTransparent = aMode == eTransparencyTransparent;
  9499:   BOOL currentTransparency = ![mWindow isOpaque];
 16601:   if (isTransparent != currentTransparency) {
 34853:     [mWindow setOpaque:!isTransparent];
 34853:     [mWindow setBackgroundColor:(isTransparent ? [NSColor clearColor] : [NSColor whiteColor])];
  9499:   }
 16601: 
 16601:   NS_OBJC_END_TRY_ABORT_BLOCK;
  9499: }
  9499: 
 79445: NS_IMETHODIMP nsCocoaWindow::Enable(bool aState)
     1: {
     1:   return NS_OK;
     1: }
     1: 
106103: bool nsCocoaWindow::IsEnabled() const
     1: {
106103:   return true;
     1: }
     1: 
 86034: #define kWindowPositionSlop 20
 86034: 
 79445: NS_IMETHODIMP nsCocoaWindow::ConstrainPosition(bool aAllowSlop,
108991:                                                int32_t *aX, int32_t *aY)
     1: {
 86034:   if (!mWindow || ![mWindow screen]) {
 86034:     return NS_OK;
 86034:   }
 86034: 
 98927:   nsIntRect screenBounds;
 98927: 
119098:   int32_t width, height;
119098: 
119098:   NSRect frame = [mWindow frame];
119098: 
119098:   // zero size rects confuse the screen manager
119098:   width = NS_MAX<int32_t>(frame.size.width, 1);
119098:   height = NS_MAX<int32_t>(frame.size.height, 1);
119098: 
 98927:   nsCOMPtr<nsIScreenManager> screenMgr = do_GetService("@mozilla.org/gfx/screenmanager;1");
 98927:   if (screenMgr) {
 98927:     nsCOMPtr<nsIScreen> screen;
 98927:     screenMgr->ScreenForRect(*aX, *aY, width, height, getter_AddRefs(screen));
 98927: 
 98927:     if (screen) {
119098:       screen->GetRectDisplayPix(&(screenBounds.x), &(screenBounds.y),
 98927:                                 &(screenBounds.width), &(screenBounds.height));
 98927:     }
 98927:   }
 86034: 
 86034:   if (aAllowSlop) {
119098:     if (*aX < screenBounds.x - width + kWindowPositionSlop) {
119098:       *aX = screenBounds.x - width + kWindowPositionSlop;
 86034:     } else if (*aX >= screenBounds.x + screenBounds.width - kWindowPositionSlop) {
 86034:       *aX = screenBounds.x + screenBounds.width - kWindowPositionSlop;
 86034:     }
 86034: 
119098:     if (*aY < screenBounds.y - height + kWindowPositionSlop) {
119098:       *aY = screenBounds.y - height + kWindowPositionSlop;
 86034:     } else if (*aY >= screenBounds.y + screenBounds.height - kWindowPositionSlop) {
 86034:       *aY = screenBounds.y + screenBounds.height - kWindowPositionSlop;
 86034:     }
 86034:   } else {
 86034:     if (*aX < screenBounds.x) {
 86034:       *aX = screenBounds.x;
119098:     } else if (*aX >= screenBounds.x + screenBounds.width - width) {
119098:       *aX = screenBounds.x + screenBounds.width - width;
 86034:     }
 86034: 
 86034:     if (*aY < screenBounds.y) {
 86034:       *aY = screenBounds.y;
119098:     } else if (*aY >= screenBounds.y + screenBounds.height - height) {
119098:       *aY = screenBounds.y + screenBounds.height - height;
 86034:     }
 86034:   }
 86034: 
     1:   return NS_OK;
     1: }
     1: 
106923: void nsCocoaWindow::SetSizeConstraints(const SizeConstraints& aConstraints)
106923: {
106923:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
106923: 
106923:   // Popups can be smaller than (60, 60)
106923:   NSRect rect =
106923:     (mWindowType == eWindowType_popup) ? NSZeroRect : NSMakeRect(0.0, 0.0, 60, 60);
106923:   rect = [mWindow frameRectForContentRect:rect];
106923: 
115495:   CGFloat scaleFactor = BackingScaleFactor();
115495: 
106923:   SizeConstraints c = aConstraints;
115495:   c.mMinSize.width =
115495:     NS_MAX(nsCocoaUtils::CocoaPointsToDevPixels(rect.size.width, scaleFactor),
115495:            c.mMinSize.width);
115495:   c.mMinSize.height =
115495:     NS_MAX(nsCocoaUtils::CocoaPointsToDevPixels(rect.size.height, scaleFactor),
115495:            c.mMinSize.height);
115495: 
115495:   NSSize minSize = {
115495:     nsCocoaUtils::DevPixelsToCocoaPoints(c.mMinSize.width, scaleFactor),
115495:     nsCocoaUtils::DevPixelsToCocoaPoints(c.mMinSize.height, scaleFactor)
115495:   };
106923:   [mWindow setMinSize:minSize];
106923: 
115495:   NSSize maxSize = {
115495:     c.mMaxSize.width == NS_MAXSIZE ?
115495:       FLT_MAX : nsCocoaUtils::DevPixelsToCocoaPoints(c.mMaxSize.width, scaleFactor),
115495:     c.mMaxSize.height == NS_MAXSIZE ?
115495:       FLT_MAX : nsCocoaUtils::DevPixelsToCocoaPoints(c.mMaxSize.height, scaleFactor)
115495:   };
106923:   [mWindow setMaxSize:maxSize];
106923: 
106923:   nsBaseWidget::SetSizeConstraints(c);
106923: 
106923:   NS_OBJC_END_TRY_ABORT_BLOCK;
106923: }
106923: 
108991: NS_IMETHODIMP nsCocoaWindow::Move(int32_t aX, int32_t aY)
     1: {
  7635:   if (!mWindow || (mBounds.x == aX && mBounds.y == aY))
  7635:     return NS_OK;
  7635: 
  7635:   // The point we have is in Gecko coordinates (origin top-left). Convert
     1:   // it to Cocoa ones (origin bottom-left).
115495:   CGFloat scaleFactor = BackingScaleFactor();
115495:   NSPoint coord = {
115495:     nsCocoaUtils::DevPixelsToCocoaPoints(aX, scaleFactor),
115495:     nsCocoaUtils::FlippedScreenY(nsCocoaUtils::DevPixelsToCocoaPoints(aY, scaleFactor))
115495:   };
     1:   [mWindow setFrameTopLeftPoint:coord];
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // Position the window behind the given window
     1: NS_METHOD nsCocoaWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
 79445:                                      nsIWidget *aWidget, bool aActivate)
     1: {
     1:   return NS_OK;
     1: }
     1: 
108991: NS_METHOD nsCocoaWindow::SetSizeMode(int32_t aMode)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
102222:   if (!mWindow)
102222:     return NS_OK;
102222: 
 88648:   // mSizeMode will be updated in DispatchSizeModeEvent, which will be called
 88648:   // from a delegate method that handles the state change during one of the
 88648:   // calls below.
 88648:   nsSizeMode previousMode = mSizeMode;
     1: 
     1:   if (aMode == nsSizeMode_Normal) {
 19112:     if ([mWindow isMiniaturized])
 19112:       [mWindow deminiaturize:nil];
 19112:     else if (previousMode == nsSizeMode_Maximized && [mWindow isZoomed])
     1:       [mWindow zoom:nil];
     1:   }
     1:   else if (aMode == nsSizeMode_Minimized) {
     1:     if (![mWindow isMiniaturized])
     1:       [mWindow miniaturize:nil];
     1:   }
     1:   else if (aMode == nsSizeMode_Maximized) {
     1:     if ([mWindow isMiniaturized])
     1:       [mWindow deminiaturize:nil];
     1:     if (![mWindow isZoomed])
     1:       [mWindow zoom:nil];
     1:   }
 89724:   else if (aMode == nsSizeMode_Fullscreen) {
 89724:     if (!mFullScreen)
 89724:       MakeFullScreen(true);
 89724:   }
     1: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
 30549: // This has to preserve the window's frame bounds.
 30549: // This method requires (as does the Windows impl.) that you call Resize shortly
 30549: // after calling HideWindowChrome. See bug 498835 for fixing this.
 79445: NS_IMETHODIMP nsCocoaWindow::HideWindowChrome(bool aShouldHide)
 30549: {
 30549:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 30549: 
102222:   if (!mWindow || !mWindowMadeHere ||
 30549:       (mWindowType != eWindowType_toplevel && mWindowType != eWindowType_dialog))
 30549:     return NS_ERROR_FAILURE;
 30549: 
 30549:   BOOL isVisible = [mWindow isVisible];
 30549: 
 30549:   // Remove child windows.
 30549:   NSArray* childWindows = [mWindow childWindows];
 30549:   NSEnumerator* enumerator = [childWindows objectEnumerator];
 30549:   NSWindow* child = nil;
 30549:   while ((child = [enumerator nextObject])) {
 30549:     [mWindow removeChildWindow:child];
 30549:   }
 30549: 
 30549:   // Remove the content view.
 30549:   NSView* contentView = [mWindow contentView];
 30549:   [contentView retain];
 30549:   [contentView removeFromSuperviewWithoutNeedingDisplay];
 30549: 
 34487:   // Save state (like window title).
 34487:   NSMutableDictionary* state = [mWindow exportState];
 34487: 
 30549:   // Recreate the window with the right border style.
 30549:   NSRect frameRect = [mWindow frame];
 30549:   DestroyNativeWindow();
 79564:   nsresult rv = CreateNativeWindow(frameRect, aShouldHide ? eBorderStyle_none : mBorderStyle, true);
 30549:   NS_ENSURE_SUCCESS(rv, rv);
 30549: 
 34487:   // Re-import state.
 34487:   [mWindow importState:state];
 34487: 
 30549:   // Reparent the content view.
 30549:   [mWindow setContentView:contentView];
 30549:   [contentView release];
 30549: 
 30549:   // Reparent child windows.
 30549:   enumerator = [childWindows objectEnumerator];
 30549:   while ((child = [enumerator nextObject])) {
 30549:     [mWindow addChildWindow:child ordered:NSWindowAbove];
 30549:   }
 30549: 
 30549:   // Show the new window.
 30549:   if (isVisible) {
 79564:     rv = Show(true);
 30549:     NS_ENSURE_SUCCESS(rv, rv);
 30549:   }
 30549: 
 30549:   return NS_OK;
 30549: 
 30549:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 30549: }
 30549: 
 93634: void nsCocoaWindow::EnteredFullScreen(bool aFullScreen)
 93634: {
 94397:   mInFullScreenTransition = false;
 93634:   mFullScreen = aFullScreen;
 93634:   DispatchSizeModeEvent();
 93634: }
 30549: 
 79445: NS_METHOD nsCocoaWindow::MakeFullScreen(bool aFullScreen)
 30550: {
 30550:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 30550: 
102222:   if (!mWindow) {
102222:     return NS_OK;
102222:   }
102222: 
 93634:   // We will call into MakeFullScreen redundantly when entering/exiting
 93634:   // fullscreen mode via OS X controls. When that happens we should just handle
 93634:   // it gracefully - no need to ASSERT.
 93634:   if (mFullScreen == aFullScreen) {
 93634:     return NS_OK;
 93634:   }
102444: 
102444:   // If we're using native fullscreen mode and our native window is invisible,
102444:   // our attempt to go into fullscreen mode will fail with an assertion in
102444:   // system code, without [WindowDelegate windowDidFailToEnterFullScreen:]
102444:   // ever getting called.  To pre-empt this we bail here.  See bug 752294.
102444:   if (mUsesNativeFullScreen && aFullScreen && ![mWindow isVisible]) {
102444:     EnteredFullScreen(false);
102444:     return NS_OK;
102444:   }
102444: 
 94397:   mInFullScreenTransition = true;
 93634: 
 93634:   if (mUsesNativeFullScreen) {
 94397:     // Calling toggleFullScreen will result in windowDid(FailTo)?(Enter|Exit)FullScreen
 93634:     // to be called from the OS. We will call EnteredFullScreen from those methods,
 93634:     // where mFullScreen will be set and a sizemode event will be dispatched.
 93634:     [mWindow toggleFullScreen:nil];
 93634:   } else {
 30550:     NSDisableScreenUpdates();
 37145:     // The order here matters. When we exit full screen mode, we need to show the
 37145:     // Dock first, otherwise the newly-created window won't have its minimize
 37145:     // button enabled. See bug 526282.
 37145:     nsCocoaUtils::HideOSChromeOnScreen(aFullScreen, [mWindow screen]);
 30550:     nsresult rv = nsBaseWidget::MakeFullScreen(aFullScreen);
 30550:     NSEnableScreenUpdates();
 30550:     NS_ENSURE_SUCCESS(rv, rv);
 30550: 
 93634:     EnteredFullScreen(aFullScreen);
 93634:   }
 30550: 
 30550:   return NS_OK;
 30550: 
 30550:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 30550: }
 30550: 
119101: nsresult nsCocoaWindow::DoResize(int32_t aX, int32_t aY,
119101:                                  int32_t aWidth, int32_t aHeight,
119101:                                  bool aRepaint, bool aConstrainToCurrentScreen)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
106923:   ConstrainSize(&aWidth, &aHeight);
106923: 
115495:   nsIntRect newBounds(aX, aY, aWidth, aHeight);
115495: 
115495:   // convert requested size into Cocoa points
115495:   CGFloat scaleFactor = BackingScaleFactor();
115495:   NSRect cocoaBounds = nsCocoaUtils::DevPixelsToCocoaPoints(newBounds, scaleFactor);
115495: 
119101:   // constrain to the visible area of the window's current screen if requested,
119101:   // or to the screen that contains the largest area of the new rect
115495:   nsCocoaUtils::NSRectToGeckoRect(cocoaBounds, newBounds);
119101:   FitRectToVisibleAreaForScreen(newBounds,
119101:                                 aConstrainToCurrentScreen ?
119101:                                     [mWindow screen] : nullptr);
  8590: 
115495:   // then convert back to device pixels
115495:   nsCocoaUtils::GeckoRectToNSRect(newBounds, cocoaBounds);
115495:   newBounds = nsCocoaUtils::CocoaPointsToDevPixels(cocoaBounds, scaleFactor);
115495: 
 59551:   BOOL isMoving = (mBounds.x != newBounds.x || mBounds.y != newBounds.y);
 59551:   BOOL isResizing = (mBounds.width != newBounds.width || mBounds.height != newBounds.height);
  7635: 
 58552:   if (!mWindow || (!isMoving && !isResizing))
  7635:     return NS_OK;
  7635: 
115495:   NSRect newFrame = nsCocoaUtils::GeckoRectToCocoaRectDevPix(newBounds, scaleFactor);
  7635: 
  8351:   // We ignore aRepaint -- we have to call display:YES, otherwise the
  8351:   // title bar doesn't immediately get repainted and is displayed in
  8351:   // the wrong place, leading to a visual jump.
  8351:   [mWindow setFrame:newFrame display:YES];
  7635: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
119101: NS_IMETHODIMP nsCocoaWindow::Resize(int32_t aX, int32_t aY,
119101:                                     int32_t aWidth, int32_t aHeight,
119101:                                     bool aRepaint)
119101: {
119101:   return DoResize(aX, aY, aWidth, aHeight, aRepaint, false);
119101: }
119101: 
108991: NS_IMETHODIMP nsCocoaWindow::Resize(int32_t aWidth, int32_t aHeight, bool aRepaint)
     1: {
119101:   return DoResize(mBounds.x, mBounds.y, aWidth, aHeight, aRepaint, true);
     1: }
     1: 
 59551: NS_IMETHODIMP nsCocoaWindow::GetClientBounds(nsIntRect &aRect)
 59551: {
 59551:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 59551: 
115495:   CGFloat scaleFactor = BackingScaleFactor();
102222:   if (!mWindow) {
115495:     aRect = nsCocoaUtils::CocoaRectToGeckoRectDevPix(NSZeroRect, scaleFactor);
102222:     return NS_OK;
102222:   }
102222: 
115495:   NSRect r;
 59551:   if ([mWindow isKindOfClass:[ToolbarWindow class]] &&
 59551:       [(ToolbarWindow*)mWindow drawsContentsIntoWindowFrame]) {
115495:     r = [mWindow frame];
 59551:   } else {
115495:     r = [mWindow contentRectForFrameRect:[mWindow frame]];
 59551:   }
 59551: 
115495:   aRect = nsCocoaUtils::CocoaRectToGeckoRectDevPix(r, scaleFactor);
115495: 
 59551:   return NS_OK;
 59551: 
 59551:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 59551: }
 59551: 
 59551: void
 59551: nsCocoaWindow::UpdateBounds()
 59551: {
102222:   NSRect frame = NSZeroRect;
115495:   if (mWindow) {
102222:     frame = [mWindow frame];
115495:   }
115495:   mBounds = nsCocoaUtils::CocoaRectToGeckoRectDevPix(frame, BackingScaleFactor());
 59551: }
 59551: 
 23738: NS_IMETHODIMP nsCocoaWindow::GetScreenBounds(nsIntRect &aRect)
     1: {
 39807:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 39807: 
115495: #ifdef DEBUG
115495:   nsIntRect r = nsCocoaUtils::CocoaRectToGeckoRectDevPix([mWindow frame], BackingScaleFactor());
115495:   NS_ASSERTION(mWindow && mBounds == r, "mBounds out of sync!");
115495: #endif
 59551: 
 59551:   aRect = mBounds;
     1:   return NS_OK;
 39807: 
 39807:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
115495: double
120488: nsCocoaWindow::GetDefaultScaleInternal()
115495: {
115495:   return BackingScaleFactor();
115495: }
115495: 
115495: CGFloat
115495: nsCocoaWindow::BackingScaleFactor()
115495: {
115495:   if (mBackingScaleFactor > 0.0) {
115495:     return mBackingScaleFactor;
115495:   }
115495:   if (!mWindow) {
115495:     return 1.0;
115495:   }
115495:   mBackingScaleFactor = nsCocoaUtils::GetBackingScaleFactor(mWindow);
115495:   return mBackingScaleFactor;
115495: }
115495: 
119103: void
119103: nsCocoaWindow::BackingScaleFactorChanged()
119103: {
119103:   CGFloat newScale = nsCocoaUtils::GetBackingScaleFactor(mWindow);
119103: 
119103:   // ignore notification if it hasn't really changed (or maybe we have
119103:   // disabled HiDPI mode via prefs)
119103:   if (mBackingScaleFactor == newScale) {
119103:     return;
119103:   }
119103: 
119104:   if (mBackingScaleFactor > 0.0) {
119104:     // convert size constraints to the new device pixel coordinate space
119104:     double scaleFactor = newScale / mBackingScaleFactor;
119104:     mSizeConstraints.mMinSize.width =
119104:       NSToIntRound(mSizeConstraints.mMinSize.width * scaleFactor);
119104:     mSizeConstraints.mMinSize.height =
119104:       NSToIntRound(mSizeConstraints.mMinSize.height * scaleFactor);
119104:     if (mSizeConstraints.mMaxSize.width < NS_MAXSIZE) {
119104:       mSizeConstraints.mMaxSize.width =
119104:         NS_MIN(NS_MAXSIZE,
119104:                NSToIntRound(mSizeConstraints.mMaxSize.width * scaleFactor));
119104:     }
119104:     if (mSizeConstraints.mMaxSize.height < NS_MAXSIZE) {
119104:       mSizeConstraints.mMaxSize.height =
119104:         NS_MIN(NS_MAXSIZE,
119104:                NSToIntRound(mSizeConstraints.mMaxSize.height * scaleFactor));
119104:     }
119104:   }
119104: 
119103:   mBackingScaleFactor = newScale;
119103: 
119103:   if (!mWidgetListener || mWidgetListener->GetXULWindow()) {
119103:     return;
119103:   }
119103: 
119103:   nsIPresShell* presShell = mWidgetListener->GetPresShell();
119103:   if (presShell) {
119103:     presShell->BackingScaleFactorChanged();
119103:   }
119103: }
119103: 
 33232: NS_IMETHODIMP nsCocoaWindow::SetCursor(nsCursor aCursor)
 33232: {
 33232:   if (mPopupContentView)
 33232:     return mPopupContentView->SetCursor(aCursor);
 33232: 
 33232:   return NS_OK;
 33232: }
 33232: 
 33232: NS_IMETHODIMP nsCocoaWindow::SetCursor(imgIContainer* aCursor,
108991:                                        uint32_t aHotspotX, uint32_t aHotspotY)
 33232: {
 33232:   if (mPopupContentView)
 33232:     return mPopupContentView->SetCursor(aCursor, aHotspotX, aHotspotY);
 33232: 
 33232:   return NS_OK;
 33232: }
 33232: 
     1: NS_IMETHODIMP nsCocoaWindow::SetTitle(const nsAString& aTitle)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
102222:   if (!mWindow)
102222:     return NS_OK;
102222: 
     1:   const nsString& strTitle = PromiseFlatString(aTitle);
     1:   NSString* title = [NSString stringWithCharacters:strTitle.get() length:strTitle.Length()];
     1:   [mWindow setTitle:title];
     1: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
 87336: NS_IMETHODIMP nsCocoaWindow::Invalidate(const nsIntRect & aRect)
     1: {
115495:   if (mPopupContentView) {
 87336:     return mPopupContentView->Invalidate(aRect);
115495:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // Pass notification of some drag event to Gecko
     1: //
     1: // The drag manager has let us know that something related to a drag has
     1: // occurred in this window. It could be any number of things, ranging from 
     1: // a drop, to a drag enter/leave, or a drag over event. The actual event
     1: // is passed in |aMessage| and is passed along to our event hanlder so Gecko
     1: // knows about it.
 79445: bool nsCocoaWindow::DragEvent(unsigned int aMessage, Point aMouseGlobal, UInt16 aKeyModifiers)
     1: {
 79564:   return false;
     1: }
     1: 
     1: NS_IMETHODIMP nsCocoaWindow::SendSetZLevelEvent()
     1: {
108457:   nsWindowZ placement = nsWindowZTop;
108457:   nsIWidget* actualBelow;
108457:   if (mWidgetListener)
108457:     mWidgetListener->ZLevelChanged(true, &placement, nullptr, &actualBelow);
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP nsCocoaWindow::GetChildSheet(bool aShown, nsCocoaWindow** _retval)
     1: {
     1:   nsIWidget* child = GetFirstChild();
     1: 
     1:   while (child) {
     1:     nsWindowType type;
 11899:     if (NS_SUCCEEDED(child->GetWindowType(type)) && type == eWindowType_sheet) {
     1:       // if it's a sheet, it must be an nsCocoaWindow
 11899:       nsCocoaWindow* cocoaWindow = static_cast<nsCocoaWindow*>(child);
102222:       if (cocoaWindow->mWindow &&
102222:           ((aShown && [cocoaWindow->mWindow isVisible]) ||
102222:           (!aShown && cocoaWindow->mSheetNeedsShow))) {
     1:         *_retval = cocoaWindow;
     1:         return NS_OK;
     1:       }
     1:     }
     1:     child = child->GetNextSibling();
     1:   }
     1: 
106838:   *_retval = nullptr;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 15026: NS_IMETHODIMP nsCocoaWindow::GetRealParent(nsIWidget** parent)
 15026: {
 15026:   *parent = mParent;
 15026:   return NS_OK;
 15026: }
 15026: 
 79445: NS_IMETHODIMP nsCocoaWindow::GetIsSheet(bool* isSheet)
     1: {
 79564:   mWindowType == eWindowType_sheet ? *isSheet = true : *isSheet = false;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsCocoaWindow::GetSheetWindowParent(NSWindow** sheetWindowParent)
     1: {
     1:   *sheetWindowParent = mSheetWindowParent;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsCocoaWindow::ResetInputState()
     1: {
     1:   return NS_OK;
     1: }
     1: 
  6118: // Invokes callback and ProcessEvent methods on Event Listener object
     1: NS_IMETHODIMP 
     1: nsCocoaWindow::DispatchEvent(nsGUIEvent* event, nsEventStatus& aStatus)
     1: {
     1:   aStatus = nsEventStatus_eIgnore;
     1: 
     1:   nsIWidget* aWidget = event->widget;
     1:   NS_IF_ADDREF(aWidget);
     1: 
108460:   if (mWidgetListener)
108460:     aStatus = mWidgetListener->HandleEvent(event, mUseAttachedEvents);
     1: 
     1:   NS_IF_RELEASE(aWidget);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 89724: // aFullScreen should be the window's mFullScreen. We don't have access to that
 89724: // from here, so we need to pass it in. mFullScreen should be the canonical
 89724: // indicator that a window is currently full screen and it makes sense to keep
 89724: // all sizemode logic here.
 31533: static nsSizeMode
 89724: GetWindowSizeMode(NSWindow* aWindow, bool aFullScreen) {
 89724:   if (aFullScreen)
 89724:     return nsSizeMode_Fullscreen;
 31533:   if ([aWindow isMiniaturized])
 31533:     return nsSizeMode_Minimized;
 31533:   if (([aWindow styleMask] & NSResizableWindowMask) && [aWindow isZoomed])
 31533:     return nsSizeMode_Maximized;
 31533:   return nsSizeMode_Normal;
 31533: }
 31533: 
     1: void
 48258: nsCocoaWindow::ReportMoveEvent()
 48258: {
 59551:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 59551: 
 84492:   // Prevent recursion, which can become infinite (see bug 708278).  This
 84492:   // can happen when the call to [NSWindow setFrameTopLeftPoint:] in
 84492:   // nsCocoaWindow::Move() triggers an immediate NSWindowDidMove notification
 84492:   // (and a call to [WindowDelegate windowDidMove:]).
 84492:   if (mInReportMoveEvent) {
 84492:     return;
 84492:   }
 84492:   mInReportMoveEvent = true;
 84492: 
 59551:   UpdateBounds();
 59551: 
 48258:   // Dispatch the move event to Gecko
108457:   if (mWidgetListener)
108457:     mWidgetListener->WindowMoved(this, mBounds.x, mBounds.y);
 59551: 
 84492:   mInReportMoveEvent = false;
 84492: 
 59551:   NS_OBJC_END_TRY_ABORT_BLOCK;
 48258: }
 48258: 
 48258: void
 31533: nsCocoaWindow::DispatchSizeModeEvent()
 19112: {
102222:   if (!mWindow) {
102222:     return;
102222:   }
102222: 
 89724:   nsSizeMode newMode = GetWindowSizeMode(mWindow, mFullScreen);
 94397: 
 94397:   // Don't dispatch a sizemode event if:
 94397:   // 1. the window is transitioning to fullscreen
 94397:   // 2. the new sizemode is the same as the current sizemode
 94397:   if (mInFullScreenTransition || mSizeMode == newMode) {
 88648:     return;
 94397:   }
 88648: 
 88648:   mSizeMode = newMode;
108457:   if (mWidgetListener) {
108457:     mWidgetListener->SizeModeChanged(newMode);
108457:   }
 19112: }
 19112: 
 19112: void
 59551: nsCocoaWindow::ReportSizeEvent()
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 59551:   UpdateBounds();
 34054: 
108457:   if (mWidgetListener) {
 59551:     nsIntRect innerBounds;
 59551:     GetClientBounds(innerBounds);
108457:     mWidgetListener->WindowResized(this, innerBounds.width, innerBounds.height);
108457:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
 27089: void nsCocoaWindow::SetMenuBar(nsMenuBarX *aMenuBar)
     1: {
     1:   if (mMenuBar)
106838:     mMenuBar->SetParent(nullptr);
102222:   if (!mWindow) {
106838:     mMenuBar = nullptr;
102222:     return;
102222:   }
 27089:   mMenuBar = aMenuBar;
     1: 
 29018:   // Only paint for active windows, or paint the hidden window menu bar if no
 29018:   // other menu bar has been painted yet so that some reasonable menu bar is
 29018:   // displayed when the app starts up.
 29018:   id windowDelegate = [mWindow delegate];
 29018:   if (mMenuBar &&
 29018:       ((!gSomeMenuBarPainted && nsMenuUtilsX::GetHiddenWindowMenuBar() == mMenuBar) ||
 29018:        (windowDelegate && [windowDelegate toplevelActiveState])))
     1:     mMenuBar->Paint();
     1: }
     1: 
 79445: NS_IMETHODIMP nsCocoaWindow::SetFocus(bool aState)
     1: {
102222:   if (!mWindow)
102222:     return NS_OK;
102222: 
 29018:   if (mPopupContentView) {
     1:     mPopupContentView->SetFocus(aState);
 29018:   }
 37853:   else if (aState && ([mWindow isVisible] || [mWindow isMiniaturized])) {
 29018:     [mWindow makeKeyAndOrderFront:nil];
 29018:     SendSetZLevelEvent();
 29018:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 25183: nsIntPoint nsCocoaWindow::WidgetToScreenOffset()
     1: {
 25183:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
102222:   NSRect rect = NSZeroRect;
115495:   nsIntRect r;
115495:   if (mWindow) {
102222:     rect = [mWindow contentRectForFrameRect:[mWindow frame]];
115495:   }
115495:   r = nsCocoaUtils::CocoaRectToGeckoRectDevPix(rect, BackingScaleFactor());
     1: 
 25183:   return r.TopLeft();
 25183: 
 25183:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(nsIntPoint(0,0));
     1: }
     1: 
 48256: nsIntPoint nsCocoaWindow::GetClientOffset()
 48256: {
 48256:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 48256: 
 59551:   nsIntRect clientRect;
 59551:   GetClientBounds(clientRect);
 59551: 
 59551:   return clientRect.TopLeft() - mBounds.TopLeft();
 48256: 
 48256:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(nsIntPoint(0, 0));
 48256: }
 48256: 
 48256: nsIntSize nsCocoaWindow::ClientToWindowSize(const nsIntSize& aClientSize)
 48256: {
 48256:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 48256: 
102222:   if (!mWindow)
102222:     return nsIntSize(0, 0);
102222: 
115495:   CGFloat backingScale = BackingScaleFactor();
115495:   nsIntRect r(0, 0, aClientSize.width, aClientSize.height);
115495:   NSRect rect = nsCocoaUtils::DevPixelsToCocoaPoints(r, backingScale);
 48256: 
 48256:   NSRect inflatedRect = [mWindow frameRectForContentRect:rect];
115495:   return nsCocoaUtils::CocoaRectToGeckoRectDevPix(inflatedRect, backingScale).Size();
 48256: 
 48256:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(nsIntSize(0,0));
 48256: }
 48256: 
 15578: nsMenuBarX* nsCocoaWindow::GetMenuBar()
     1: {
     1:   return mMenuBar;
     1: }
     1: 
120177: NS_IMETHODIMP nsCocoaWindow::CaptureRollupEvents(nsIRollupListener* aListener, bool aDoCapture)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
106838:   gRollupListener = nullptr;
     1:   
     1:   if (aDoCapture) {
     1:     gRollupListener = aListener;
 28346: 
  6494:     // Sometimes more than one popup window can be visible at the same time
  6494:     // (e.g. nested non-native context menus, or the test case (attachment
120177:     // 276885) for bmo bug 392389, which displays a non-native combo-box in a
120177:     // non-native popup window).  In these cases the "active" popup window should
120177:     // be the topmost -- the (nested) context menu the mouse is currently over,
120177:     // or the combo-box's drop-down list (when it's displayed).  But (among
  6494:     // windows that have the same "level") OS X makes topmost the window that
  6494:     // last received a mouse-down event, which may be incorrect (in the combo-
  6494:     // box case, it makes topmost the window containing the combo-box).  So
  6494:     // here we fiddle with a non-native popup window's level to make sure the
  6494:     // "active" one is always above any other non-native popup windows that
  6494:     // may be visible.
  6494:     if (mWindow && (mWindowType == eWindowType_popup))
 48254:       SetPopupWindowLevel();
  6494:   } else {
 48254:     // XXXndeakin this doesn't make sense.
 48254:     // Why is the new window assumed to be a modal panel?
  6494:     if (mWindow && (mWindowType == eWindowType_popup))
  6494:       [mWindow setLevel:NSModalPanelWindowLevel];
     1:   }
     1:   
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
108991: NS_IMETHODIMP nsCocoaWindow::GetAttention(int32_t aCycleCount)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
     1:   [NSApp requestUserAttention:NSInformationalRequest];
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
 79445: bool
 27993: nsCocoaWindow::HasPendingInputEvent()
 27993: {
 27993:   return nsChildView::DoHasPendingInputEvent();
 27993: }
     1: 
108991: NS_IMETHODIMP nsCocoaWindow::SetWindowShadowStyle(int32_t aStyle)
 20467: {
 20467:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 20467: 
102222:   if (!mWindow)
102222:     return NS_OK;
102222: 
 36750:   mShadowStyle = aStyle;
 20467:   [mWindow setHasShadow:(aStyle != NS_STYLE_WINDOW_SHADOW_NONE)];
 36750:   AdjustWindowShadow();
 37144:   SetUpWindowFilter();
 36750: 
 20467:   return NS_OK;
 20467: 
 20467:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 20467: }
 20467: 
 79445: void nsCocoaWindow::SetShowsToolbarButton(bool aShow)
 31160: {
 31160:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 31160: 
102222:   if (mWindow)
 31160:     [mWindow setShowsToolbarButton:aShow];
 31160: 
 31160:   NS_OBJC_END_TRY_ABORT_BLOCK;
 31160: }
 31160: 
 93634: void nsCocoaWindow::SetShowsFullScreenButton(bool aShow)
 93634: {
 93634:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 93634: 
102222:   if (!mWindow || ![mWindow respondsToSelector:@selector(toggleFullScreen:)] ||
 93634:       mUsesNativeFullScreen == aShow) {
 93634:     return;
 93634:   }
 93634: 
 93634:   // If the window is currently in fullscreen mode, then we're going to
 93634:   // transition out first, then set the collection behavior & toggle
 93634:   // mUsesNativeFullScreen, then transtion back into fullscreen mode. This
 93634:   // prevents us from getting into a conflicting state with MakeFullScreen
 93634:   // where mUsesNativeFullScreen would lead us down the wrong path.
 93634:   bool wasFullScreen = mFullScreen;
 93634: 
 93634:   if (wasFullScreen) {
 93634:     MakeFullScreen(false);
 93634:   }
 93634: 
 93634:   NSWindowCollectionBehavior newBehavior = [mWindow collectionBehavior];
 93634:   if (aShow) {
 93634:     newBehavior |= NSWindowCollectionBehaviorFullScreenPrimary;
 93634:   } else {
 93634:     newBehavior &= ~NSWindowCollectionBehaviorFullScreenPrimary;
 93634:   }
 93634:   [mWindow setCollectionBehavior:newBehavior];
 93634:   mUsesNativeFullScreen = aShow;
 93634: 
 93634:   if (wasFullScreen) {
 93634:     MakeFullScreen(true);
 93634:   }
 93634: 
 93634:   NS_OBJC_END_TRY_ABORT_BLOCK;
 93634: }
 93634: 
 90340: void nsCocoaWindow::SetWindowAnimationType(nsIWidget::WindowAnimationType aType)
 90340: {
 90340:   mAnimationType = aType;
 90340: }
 90340: 
 79445: NS_IMETHODIMP nsCocoaWindow::SetWindowTitlebarColor(nscolor aColor, bool aActive)
  7242: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
102222:   if (!mWindow)
102222:     return NS_OK;
102222: 
  7242:   // If they pass a color with a complete transparent alpha component, use the
  7242:   // native titlebar appearance.
  7242:   if (NS_GET_A(aColor) == 0) {
 34487:     [mWindow setTitlebarColor:nil forActiveWindow:(BOOL)aActive]; 
  7242:   } else {
 14002:     // Transform from sRGBA to monitor RGBA. This seems like it would make trying
 14002:     // to match the system appearance lame, so probably we just shouldn't color 
 14002:     // correct chrome.
 19127:     if (gfxPlatform::GetCMSMode() == eCMSMode_All) {
 27035:       qcms_transform *transform = gfxPlatform::GetCMSRGBATransform();
 19127:       if (transform) {
108991:         uint8_t color[3];
 19127:         color[0] = NS_GET_R(aColor);
 19127:         color[1] = NS_GET_G(aColor);
 19127:         color[2] = NS_GET_B(aColor);
 27035:         qcms_transform_data(transform, color, color, 1);
 19127:         aColor = NS_RGB(color[0], color[1], color[2]);
 19127:       }
 19127:     }
 14002: 
 34487:     [mWindow setTitlebarColor:[NSColor colorWithDeviceRed:NS_GET_R(aColor)/255.0
  7242:                                                     green:NS_GET_G(aColor)/255.0
  7242:                                                      blue:NS_GET_B(aColor)/255.0
 14886:                                                     alpha:NS_GET_A(aColor)/255.0]
 14886:               forActiveWindow:(BOOL)aActive];
  7242:   }
  7242:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
  7242: }
  7242: 
 79445: void nsCocoaWindow::SetDrawsInTitlebar(bool aState)
 34054: {
 34054:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 34054: 
102222:   if (mWindow)
 34487:     [mWindow setDrawsContentsIntoWindowFrame:aState];
 34054: 
 34054:   NS_OBJC_END_TRY_ABORT_BLOCK;
 34054: }
 34054: 
 32976: NS_IMETHODIMP nsCocoaWindow::SynthesizeNativeMouseEvent(nsIntPoint aPoint,
108991:                                                         uint32_t aNativeMessage,
108991:                                                         uint32_t aModifierFlags)
 32976: {
 32976:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 32976: 
 32976:   if (mPopupContentView)
 32976:     return mPopupContentView->SynthesizeNativeMouseEvent(aPoint, aNativeMessage,
 32976:                                                          aModifierFlags);
 32976: 
 32976:   return NS_OK;
 32976: 
 32976:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 32976: }
 32976: 
  4174: gfxASurface* nsCocoaWindow::GetThebesSurface()
  4174: {
  4174:   if (mPopupContentView)
  4174:     return mPopupContentView->GetThebesSurface();
106838:   return nullptr;
  4174: }
  4174: 
  6348: NS_IMETHODIMP nsCocoaWindow::BeginSecureKeyboardInput()
  6348: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
  6348:   nsresult rv = nsBaseWidget::BeginSecureKeyboardInput();
 62281:   if (NS_SUCCEEDED(rv)) {
  6348:     ::EnableSecureEventInput();
 62281:   }
  6348:   return rv;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
  6348: }
  6348: 
  6348: NS_IMETHODIMP nsCocoaWindow::EndSecureKeyboardInput()
  6348: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
  6348:   nsresult rv = nsBaseWidget::EndSecureKeyboardInput();
 62281:   if (NS_SUCCEEDED(rv)) {
  6348:     ::DisableSecureEventInput();
 62281:   }
  6348:   return rv;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
  6348: }
  6348: 
 48254: void nsCocoaWindow::SetPopupWindowLevel()
 48254: {
102222:   if (!mWindow)
102222:     return;
102222: 
 48254:   // Floating popups are at the floating level and hide when the window is
 48254:   // deactivated.
 48254:   if (mPopupLevel == ePopupLevelFloating) {
 48254:     [mWindow setLevel:NSFloatingWindowLevel];
 48254:     [mWindow setHidesOnDeactivate:YES];
 48254:   }
 48254:   else {
 48254:     // Otherwise, this is a top-level or parent popup. Parent popups always
 48254:     // appear just above their parent and essentially ignore the level.
 48254:     [mWindow setLevel:NSPopUpMenuWindowLevel];
 48254:     [mWindow setHidesOnDeactivate:NO];
 48254:   }
 48254: }
 48254: 
 79445: bool nsCocoaWindow::IsChildInFailingLeftClickThrough(NSView *aChild)
 57526: {
 57526:   if ([aChild isKindOfClass:[ChildView class]]) {
 57526:     ChildView* childView = (ChildView*) aChild;
 57526:     if ([childView isInFailingLeftClickThrough])
 79564:       return true;
 57526:   }
 57526:   NSArray* subviews = [aChild subviews];
 57526:   if (subviews) {
 57526:     NSUInteger count = [subviews count];
 57526:     for (NSUInteger i = 0; i < count; ++i) {
 57526:       NSView* aView = (NSView*) [subviews objectAtIndex:i];
 57526:       if (IsChildInFailingLeftClickThrough(aView))
 79564:         return true;
 57526:     }
 57526:   }
 79564:   return false;
 57526: }
 57526: 
 57526: // Don't focus a plugin if we're in a left click-through that will
 57526: // fail (see [ChildView isInFailingLeftClickThrough]).  Called from
 57526: // [ChildView shouldFocusPlugin].
 79445: bool nsCocoaWindow::ShouldFocusPlugin()
 57526: {
102222:   if (!mWindow || IsChildInFailingLeftClickThrough([mWindow contentView]))
 79564:     return false;
 79564: 
 79564:   return true;
 57526: }
 57526: 
     1: @implementation WindowDelegate
     1: 
     1: // We try to find a gecko menu bar to paint. If one does not exist, just paint
     1: // the application menu by itself so that a window doesn't have some other
     1: // window's menu bar.
     1: + (void)paintMenubarForWindow:(NSWindow*)aWindow
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
     1:   // make sure we only act on windows that have this kind of
     1:   // object as a delegate
     1:   id windowDelegate = [aWindow delegate];
     1:   if ([windowDelegate class] != [self class])
     1:     return;
     1: 
     1:   nsCocoaWindow* geckoWidget = [windowDelegate geckoWidget];
     1:   NS_ASSERTION(geckoWidget, "Window delegate not returning a gecko widget!");
     1:   
 15578:   nsMenuBarX* geckoMenuBar = geckoWidget->GetMenuBar();
     1:   if (geckoMenuBar) {
     1:     geckoMenuBar->Paint();
     1:   }
     1:   else {
     1:     // sometimes we don't have a native application menu early in launching
     1:     if (!sApplicationMenu)
     1:       return;
     1: 
  8087:     NSMenu* mainMenu = [NSApp mainMenu];
  8087:     NS_ASSERTION([mainMenu numberOfItems] > 0, "Main menu does not have any items, something is terribly wrong!");
     1: 
 14024:     // Create a new menu bar.
 14024:     // We create a GeckoNSMenu because all menu bar NSMenu objects should use that subclass for
 14024:     // key handling reasons.
 14024:     GeckoNSMenu* newMenuBar = [[GeckoNSMenu alloc] initWithTitle:@"MainMenuBar"];
  8087: 
  8087:     // move the application menu from the existing menu bar to the new one
  8087:     NSMenuItem* firstMenuItem = [[mainMenu itemAtIndex:0] retain];
  8087:     [mainMenu removeItemAtIndex:0];
  8087:     [newMenuBar insertItem:firstMenuItem atIndex:0];
  8087:     [firstMenuItem release];
     1: 
     1:     // set our new menu bar as the main menu
     1:     [NSApp setMainMenu:newMenuBar];
     1:     [newMenuBar release];
     1:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: - (id)initWithGeckoWindow:(nsCocoaWindow*)geckoWind
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
     1:   [super init];
     1:   mGeckoWindow = geckoWind;
 79564:   mToplevelActiveState = false;
 79564:   mHasEverBeenZoomed = false;
     1:   return self;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
     1: }
     1: 
     1: - (NSSize)windowWillResize:(NSWindow *)sender toSize:(NSSize)proposedFrameSize
     1: {
  2314:   RollUpPopups();
     1:   
     1:   return proposedFrameSize;
     1: }
     1: 
     1: - (void)windowDidResize:(NSNotification *)aNotification
     1: {
 75223:   BaseWindow* window = [aNotification object];
 75223:   [window updateTrackingArea];
 75223: 
 58552:   if (!mGeckoWindow)
     1:     return;
     1: 
 31533:   // Resizing might have changed our zoom state.
 31533:   mGeckoWindow->DispatchSizeModeEvent();
  5945:   mGeckoWindow->ReportSizeEvent();
     1: }
     1: 
 86118: - (void)windowDidChangeScreen:(NSNotification *)aNotification
 86118: {
 86118:   if (!mGeckoWindow)
 86118:     return;
 86118: 
 86118:   mGeckoWindow->ReportMoveEvent();
 86118: }
 86118: 
 93634: // Lion's full screen mode will bypass our internal fullscreen tracking, so
 93634: // we need to catch it when we transition and call our own methods, which in
 93634: // turn will fire "fullscreen" events.
 93634: - (void)windowDidEnterFullScreen:(NSNotification *)notification
 93634: {
 93634:   if (!mGeckoWindow) {
 93634:     return;
 93634:   }
 93634: 
 93634:   mGeckoWindow->EnteredFullScreen(true);
 93634: }
 93634: 
 93634: - (void)windowDidExitFullScreen:(NSNotification *)notification
 93634: {
 93634:   if (!mGeckoWindow) {
 93634:     return;
 93634:   }
 93634: 
 93634:   mGeckoWindow->EnteredFullScreen(false);
 93634: }
 93634: 
 94397: - (void)windowDidFailToEnterFullScreen:(NSWindow *)window
 94397: {
 94397:   if (!mGeckoWindow) {
 94397:     return;
 94397:   }
 94397: 
 94397:   mGeckoWindow->EnteredFullScreen(false);
 94397: }
 94397: 
 94397: - (void)windowDidFailToExitFullScreen:(NSWindow *)window
 94397: {
 94397:   if (!mGeckoWindow) {
 94397:     return;
 94397:   }
 94397: 
 94397:   mGeckoWindow->EnteredFullScreen(true);
 94397: }
 94397: 
     1: - (void)windowDidBecomeMain:(NSNotification *)aNotification
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
  2314:   RollUpPopups();
 35621:   ChildViewMouseTracker::ReEvaluateMouseEnterState();
  1579: 
 13608:   // [NSApp _isRunningAppModal] will return true if we're running an OS dialog
 13608:   // app modally. If one of those is up then we want it to retain its menu bar.
 13608:   if ([NSApp _isRunningAppModal])
 13608:     return;
     1:   NSWindow* window = [aNotification object];
     1:   if (window)
     1:     [WindowDelegate paintMenubarForWindow:window];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: - (void)windowDidResignMain:(NSNotification *)aNotification
     1: {
  2314:   RollUpPopups();
 35621:   ChildViewMouseTracker::ReEvaluateMouseEnterState();
     1: 
 13608:   // [NSApp _isRunningAppModal] will return true if we're running an OS dialog
 13608:   // app modally. If one of those is up then we want it to retain its menu bar.
 13608:   if ([NSApp _isRunningAppModal])
 13608:     return;
 15578:   nsRefPtr<nsMenuBarX> hiddenWindowMenuBar = nsMenuUtilsX::GetHiddenWindowMenuBar();
     1:   if (hiddenWindowMenuBar) {
     1:     // printf("painting hidden window menu bar due to window losing main status\n");
     1:     hiddenWindowMenuBar->Paint();
     1:   }
     1: }
     1: 
     1: - (void)windowDidBecomeKey:(NSNotification *)aNotification
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 33515:   RollUpPopups();
 35621:   ChildViewMouseTracker::ReEvaluateMouseEnterState();
 33515: 
     1:   NSWindow* window = [aNotification object];
     1:   if ([window isSheet])
     1:     [WindowDelegate paintMenubarForWindow:window];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: - (void)windowDidResignKey:(NSNotification *)aNotification
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 33515:   RollUpPopups();
 35621:   ChildViewMouseTracker::ReEvaluateMouseEnterState();
 33515: 
     1:   // If a sheet just resigned key then we should paint the menu bar
     1:   // for whatever window is now main.
     1:   NSWindow* window = [aNotification object];
     1:   if ([window isSheet])
     1:     [WindowDelegate paintMenubarForWindow:[NSApp mainWindow]];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: - (void)windowWillMove:(NSNotification *)aNotification
     1: {
  2314:   RollUpPopups();
     1: }
     1: 
  1357: - (void)windowDidMove:(NSNotification *)aNotification
  1357: {
 48258:   if (mGeckoWindow)
 48258:     mGeckoWindow->ReportMoveEvent();
  1357: }
     1: 
     1: - (BOOL)windowShouldClose:(id)sender
     1: {
108457:   nsIWidgetListener* listener = mGeckoWindow ? mGeckoWindow->GetWidgetListener() : nullptr;
108457:   if (listener)
108457:     listener->RequestWindowClose(mGeckoWindow);
     1:   return NO; // gecko will do it
     1: }
     1: 
     1: - (void)windowWillClose:(NSNotification *)aNotification
     1: {
  2314:   RollUpPopups();
     1: }
     1: 
     1: - (void)windowWillMiniaturize:(NSNotification *)aNotification
     1: {
  2314:   RollUpPopups();
     1: }
     1: 
 19112: - (void)windowDidMiniaturize:(NSNotification *)aNotification
 19112: {
 19112:   if (mGeckoWindow)
 31533:     mGeckoWindow->DispatchSizeModeEvent();
 19112: }
 19112: 
 19112: - (void)windowDidDeminiaturize:(NSNotification *)aNotification
 19112: {
 19112:   if (mGeckoWindow)
 31533:     mGeckoWindow->DispatchSizeModeEvent();
 31533: }
 31533: 
 31533: - (BOOL)windowShouldZoom:(NSWindow *)window toFrame:(NSRect)proposedFrame
 31533: {
 31533:   if (!mHasEverBeenZoomed && [window isZoomed])
 31533:     return NO; // See bug 429954.
 31533: 
 31533:   mHasEverBeenZoomed = YES;
 31533:   return YES;
 19112: }
 19112: 
     1: - (void)didEndSheet:(NSWindow*)sheet returnCode:(int)returnCode contextInfo:(void*)contextInfo
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 15026:   // Note: 'contextInfo' (if it is set) is the window that is the parent of
 15026:   // the sheet.  The value of contextInfo is determined in
 15026:   // nsCocoaWindow::Show().  If it's set, 'contextInfo' is always the top-
 15026:   // level window, not another sheet itself.  But 'contextInfo' is nil if
 15026:   // our parent window is also a sheet -- in that case we shouldn't send
 15026:   // the top-level window any activate events (because it's our parent
 15026:   // window that needs to get these events, not the top-level window).
 14885:   [TopLevelWindowData deactivateInWindow:sheet];
     1:   [sheet orderOut:self];
 15026:   if (contextInfo)
 14885:     [TopLevelWindowData activateInWindow:(NSWindow*)contextInfo];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
119103: - (void)windowDidChangeBackingProperties:(NSNotification *)aNotification
119103: {
119103:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
119103: 
119103:   NSWindow *window = (NSWindow *)[aNotification object];
119103: 
119103:   if ([window respondsToSelector:@selector(backingScaleFactor)]) {
119103:     CGFloat oldFactor =
119103:       [[[aNotification userInfo]
119103:          objectForKey:@"NSBackingPropertyOldScaleFactorKey"] doubleValue];
119103:     if ([window backingScaleFactor] != oldFactor) {
119103:       mGeckoWindow->BackingScaleFactorChanged();
119103:     }
119103:   }
119103: 
119103:   NS_OBJC_END_TRY_ABORT_BLOCK;
119103: }
119103: 
   604: - (nsCocoaWindow*)geckoWidget
     1: {
     1:   return mGeckoWindow;
     1: }
     1: 
 79445: - (bool)toplevelActiveState
 14885: {
 14885:   return mToplevelActiveState;
 14885: }
 14885: 
 14885: - (void)sendToplevelActivateEvents
 14885: {
108457:   if (!mToplevelActiveState && mGeckoWindow) {
108457:     nsIWidgetListener* listener = mGeckoWindow->GetWidgetListener();
108457:     if (listener)
108457:       listener->WindowActivated();
 79564:     mToplevelActiveState = true;
 14885:   }
 14885: }
 14885: 
 14885: - (void)sendToplevelDeactivateEvents
 14885: {
108457:   if (mToplevelActiveState && mGeckoWindow) {
108457:     nsIWidgetListener* listener = mGeckoWindow->GetWidgetListener();
108457:     if (listener)
108457:       listener->WindowDeactivated();
 79564:     mToplevelActiveState = false;
 14885:   }
 14885: }
 14885: 
     1: @end
  2029: 
 50873: static float
 50873: GetDPI(NSWindow* aWindow)
 50873: {
 50873:   NSScreen* screen = [aWindow screen];
 50873:   if (!screen)
 50873:     return 96.0f;
 50873: 
 50873:   CGDirectDisplayID displayID =
 50873:     [[[screen deviceDescription] objectForKey:@"NSScreenNumber"] intValue];
 50873:   CGFloat heightMM = ::CGDisplayScreenSize(displayID).height;
 50873:   size_t heightPx = ::CGDisplayPixelsHigh(displayID);
 50873:   CGFloat scaleFactor = [aWindow userSpaceScaleFactor];
 50873:   if (scaleFactor < 0.01 || heightMM < 1 || heightPx < 1) {
 50873:     // Something extremely bogus is going on
 50873:     return 96.0f;
 50873:   }
 50873: 
 50873:   // Currently we don't do our own scaling to take account
 50873:   // of userSpaceScaleFactor, so every "pixel" we draw is actually
 50873:   // userSpaceScaleFactor screen pixels. So divide the screen height
 50873:   // by userSpaceScaleFactor to get the number of "device pixels"
 50873:   // available.
115495:   float dpi = (heightPx / scaleFactor) / (heightMM / MM_PER_INCH_FLOAT);
115495: 
115495:   // Account for HiDPI mode where Cocoa's "points" do not correspond to real
115495:   // device pixels
115495:   CGFloat backingScale = nsCocoaUtils::GetBackingScaleFactor(aWindow);
115495: 
115495:   return dpi * backingScale;
 50873: }
 50873: 
 75223: @interface BaseWindow(Private)
 75223: - (void)removeTrackingArea;
 75223: - (void)cursorUpdated:(NSEvent*)aEvent;
 75223: @end
 75223: 
 34487: @implementation BaseWindow
  7242: 
 34487: - (id)initWithContentRect:(NSRect)aContentRect styleMask:(NSUInteger)aStyle backing:(NSBackingStoreType)aBufferingType defer:(BOOL)aFlag
  7242: {
 34487:   [super initWithContentRect:aContentRect styleMask:aStyle backing:aBufferingType defer:aFlag];
 34487:   mState = nil;
 34487:   mDrawsIntoWindowFrame = NO;
 34487:   mActiveTitlebarColor = nil;
 34487:   mInactiveTitlebarColor = nil;
 35620:   mScheduledShadowInvalidation = NO;
 50873:   mDPI = GetDPI(self);
 75223:   mTrackingArea = nil;
 75223:   [self updateTrackingArea];
 50873: 
 34487:   return self;
 34487: }
 11978: 
 34487: - (void)dealloc
 34487: {
 34487:   [mActiveTitlebarColor release];
 34487:   [mInactiveTitlebarColor release];
 75223:   [self removeTrackingArea];
 75223:   ChildViewMouseTracker::OnDestroyWindow(self);
 34487:   [super dealloc];
 34487: }
 11978: 
 34487: static const NSString* kStateTitleKey = @"title";
 34487: static const NSString* kStateDrawsContentsIntoWindowFrameKey = @"drawsContentsIntoWindowFrame";
 34487: static const NSString* kStateActiveTitlebarColorKey = @"activeTitlebarColor";
 34487: static const NSString* kStateInactiveTitlebarColorKey = @"inactiveTitlebarColor";
 36749: static const NSString* kStateShowsToolbarButton = @"showsToolbarButton";
 34487: 
 34487: - (void)importState:(NSDictionary*)aState
 34487: {
 34487:   [self setTitle:[aState objectForKey:kStateTitleKey]];
 34487:   [self setDrawsContentsIntoWindowFrame:[[aState objectForKey:kStateDrawsContentsIntoWindowFrameKey] boolValue]];
 34487:   [self setTitlebarColor:[aState objectForKey:kStateActiveTitlebarColorKey] forActiveWindow:YES];
 34487:   [self setTitlebarColor:[aState objectForKey:kStateInactiveTitlebarColorKey] forActiveWindow:NO];
 36749:   [self setShowsToolbarButton:[[aState objectForKey:kStateShowsToolbarButton] boolValue]];
 34487: }
 34487: 
 34487: - (NSMutableDictionary*)exportState
 34487: {
 34487:   NSMutableDictionary* state = [NSMutableDictionary dictionaryWithCapacity:10];
 34487:   [state setObject:[self title] forKey:kStateTitleKey];
 34487:   [state setObject:[NSNumber numberWithBool:[self drawsContentsIntoWindowFrame]]
 34487:             forKey:kStateDrawsContentsIntoWindowFrameKey];
 34487:   NSColor* activeTitlebarColor = [self titlebarColorForActiveWindow:YES];
 34487:   if (activeTitlebarColor) {
 34487:     [state setObject:activeTitlebarColor forKey:kStateActiveTitlebarColorKey];
 34487:   }
 34487:   NSColor* inactiveTitlebarColor = [self titlebarColorForActiveWindow:NO];
 34487:   if (inactiveTitlebarColor) {
 34487:     [state setObject:inactiveTitlebarColor forKey:kStateInactiveTitlebarColorKey];
 34487:   }
 36749:   [state setObject:[NSNumber numberWithBool:[self showsToolbarButton]]
 36749:             forKey:kStateShowsToolbarButton];
 34487:   return state;
 34487: }
 34487: 
 34487: - (void)setDrawsContentsIntoWindowFrame:(BOOL)aState
 34487: {
 34487:   mDrawsIntoWindowFrame = aState;
 34487: }
 34487: 
 34487: - (BOOL)drawsContentsIntoWindowFrame
 34487: {
 34487:   return mDrawsIntoWindowFrame;
 34487: }
 34487: 
 34487: // Pass nil here to get the default appearance.
 34487: - (void)setTitlebarColor:(NSColor*)aColor forActiveWindow:(BOOL)aActive
 34487: {
 34487:   [aColor retain];
 34487:   if (aActive) {
 34487:     [mActiveTitlebarColor release];
 34487:     mActiveTitlebarColor = aColor;
 34487:   } else {
 34487:     [mInactiveTitlebarColor release];
 34487:     mInactiveTitlebarColor = aColor;
 34487:   }
 34487: }
 34487: 
 34487: - (NSColor*)titlebarColorForActiveWindow:(BOOL)aActive
 34487: {
 34487:   return aActive ? mActiveTitlebarColor : mInactiveTitlebarColor;
  7242: }
  7242: 
 35620: - (void)deferredInvalidateShadow
 35620: {
 35620:   if (mScheduledShadowInvalidation || [self isOpaque] || ![self hasShadow])
 35620:     return;
 35620: 
 35620:   [self performSelector:@selector(invalidateShadow) withObject:nil afterDelay:0];
 35620:   mScheduledShadowInvalidation = YES;
 35620: }
 35620: 
 35620: - (void)invalidateShadow
 35620: {
 35620:   [super invalidateShadow];
 35620:   mScheduledShadowInvalidation = NO;
 35620: }
 35620: 
 50873: - (float)getDPI
 50873: {
 50873:   return mDPI;
 50873: }
 50873: 
 75223: - (NSView*)trackingAreaView
 75223: {
 75223:   NSView* contentView = [self contentView];
 75223:   return [contentView superview] ? [contentView superview] : contentView;
 75223: }
 75223: 
 75223: - (void)removeTrackingArea
 75223: {
 75223:   if (mTrackingArea) {
 75223:     [[self trackingAreaView] removeTrackingArea:mTrackingArea];
 75223:     [mTrackingArea release];
 75223:     mTrackingArea = nil;
 75223:   }
 75223: }
 75223: 
 75223: - (void)updateTrackingArea
 75223: {
 75223:   [self removeTrackingArea];
 75223: 
 75223:   NSView* view = [self trackingAreaView];
 75223:   const NSTrackingAreaOptions options =
 75223:     NSTrackingMouseEnteredAndExited | NSTrackingMouseMoved | NSTrackingActiveAlways;
 75223:   mTrackingArea = [[NSTrackingArea alloc] initWithRect:[view bounds]
 75223:                                                options:options
 75223:                                                  owner:self
 75223:                                               userInfo:nil];
 75223:   [view addTrackingArea:mTrackingArea];
 75223: }
 75223: 
 75223: - (void)mouseEntered:(NSEvent*)aEvent
 75223: {
 75223:   ChildViewMouseTracker::MouseEnteredWindow(aEvent);
 75223: }
 75223: 
 75223: - (void)mouseExited:(NSEvent*)aEvent
 75223: {
 75223:   ChildViewMouseTracker::MouseExitedWindow(aEvent);
 75223: }
 75223: 
 75223: - (void)mouseMoved:(NSEvent*)aEvent
 75223: {
 75223:   ChildViewMouseTracker::MouseMoved(aEvent);
 75223: }
 75223: 
 75223: - (void)cursorUpdated:(NSEvent*)aEvent
 75223: {
 75223:   // Nothing to do here, but NSTrackingArea wants us to implement this method.
 75223: }
 75223: 
 61539: - (BOOL)respondsToSelector:(SEL)aSelector
 61539: {
 61539:   // Claim the window doesn't respond to this so that the system
 61539:   // doesn't steal keyboard equivalents for it. Bug 613710.
 61539:   if (aSelector == @selector(cancelOperation:)) {
 61539:     return NO;
 61539:   }
 61539: 
 61539:   return [super respondsToSelector:aSelector];
 61539: }
 61539: 
 50708: - (void) doCommandBySelector:(SEL)aSelector
 50708: {
 50708:   // We override this so that it won't beep if it can't act.
 50708:   // We want to control the beeping for missing or disabled
 50708:   // commands ourselves.
 50708:   [self tryToPerform:aSelector with:nil];
 50708: }
 50708: 
 79363: - (id)accessibilityAttributeValue:(NSString *)attribute
 79363: {
 79363:   id retval = [super accessibilityAttributeValue:attribute];
 79363: 
 79363:   // The following works around a problem with Text-to-Speech on OS X 10.7.
 79363:   // See bug 674612 for more info.
 79363:   //
 79363:   // When accessibility is off, AXUIElementCopyAttributeValue(), when called
 79363:   // on an AXApplication object to get its AXFocusedUIElement attribute,
 79363:   // always returns an AXWindow object (the actual browser window -- never a
 79363:   // mozAccessible object).  This also happens with accessibility turned on,
 79363:   // if no other object in the browser window has yet been focused.  But if
 79363:   // the browser window has a title bar (as it currently always does), the
 79363:   // AXWindow object will always have four "accessible" children, one of which
 79363:   // is an AXStaticText object (the title bar's "title"; the other three are
 79363:   // the close, minimize and zoom buttons).  This means that (for complicated
 79363:   // reasons, for which see bug 674612) Text-to-Speech on OS X 10.7 will often
 79363:   // "speak" the window title, no matter what text is selected, or even if no
 79363:   // text at all is selected.  (This always happens when accessibility is off.
 79363:   // It doesn't happen in Firefox releases because Apple has (on OS X 10.7)
 79363:   // special-cased the handling of apps whose CFBundleIdentifier is
 79363:   // org.mozilla.firefox.)
 79363:   //
 79363:   // We work around this problem by only returning AXChildren that are
 79363:   // mozAccessible object or are one of the titlebar's buttons (which
 79363:   // instantiate subclasses of NSButtonCell).
 98723:   if (nsCocoaFeatures::OnLionOrLater() && [retval isKindOfClass:[NSArray class]] &&
 79363:       [attribute isEqualToString:@"AXChildren"]) {
 79363:     NSMutableArray *holder = [NSMutableArray arrayWithCapacity:10];
 79363:     [holder addObjectsFromArray:(NSArray *)retval];
 79363:     NSUInteger count = [holder count];
 79363:     for (NSInteger i = count - 1; i >= 0; --i) {
 79363:       id item = [holder objectAtIndex:i];
 79363:       // Remove anything from holder that isn't one of the titlebar's buttons
 79363:       // (which instantiate subclasses of NSButtonCell) or a mozAccessible
 79363:       // object (or one of its subclasses).
 79363:       if (![item isKindOfClass:[NSButtonCell class]] &&
 79363:           ![item respondsToSelector:@selector(hasRepresentedView)]) {
 79363:         [holder removeObjectAtIndex:i];
 79363:       }
 79363:     }
 79363:     retval = [NSArray arrayWithArray:holder];
 79363:   }
 79363: 
 79363:   return retval;
 79363: }
 79363: 
  7242: @end
  7242: 
120690: // This class allows us to have a "unified toolbar" style window. It works like this:
  7242: // 1) We set the window's style to textured.
  7242: // 2) Because of this, the background color applies to the entire window, including
  7242: //     the titlebar area. For normal textured windows, the default pattern is a 
 19295: //    "brushed metal" image on Tiger and a unified gradient on Leopard.
  7242: // 3) We set the background color to a custom NSColor subclass that knows how tall the window is.
  7242: //    When -set is called on it, it sets a pattern (with a draw callback) as the fill. In that callback,
 19295: //    it paints the the titlebar and background colors in the correct areas of the context it's given,
  7242: //    which will fill the entire window (CG will tile it horizontally for us).
 19295: // 4) Whenever the window's main state changes and when [window display] is called,
 19295: //    Cocoa redraws the titlebar using the patternDraw callback function.
  7242: //
  7242: // This class also provides us with a pill button to show/hide the toolbar.
 19295: //
 19295: // Drawing the unified gradient in the titlebar and the toolbar works like this:
 19295: // 1) In the style sheet we set the toolbar's -moz-appearance to -moz-mac-unified-toolbar.
 48165: // 2) When the toolbar is visible and we paint the application chrome
 60289: //    window, the array that Gecko passes nsChildView::UpdateThemeGeometries
 60289: //    will contain an entry for the widget type NS_THEME_TOOLBAR or
 48165: //    NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR.
 60289: // 3) nsChildView::UpdateThemeGeometries finds the toolbar frame's ToolbarWindow
 60289: //    and passes the toolbar frame's height to setUnifiedToolbarHeight.
 60289: // 4) If the toolbar height has changed, a titlebar redraw is triggered and the
 60289: //    upper part of the unified gradient is drawn in the titlebar.
 60289: // 5) The lower part of the unified gradient in the toolbar is drawn during
 60289: //    normal window content painting in nsNativeThemeCocoa::DrawUnifiedToolbar.
 19295: //
 19295: // Whenever the unified gradient is drawn in the titlebar or the toolbar, both
 19295: // titlebar height and toolbar height must be known in order to construct the
 19295: // correct gradient (which is a linear gradient with the length
 19295: // titlebarHeight + toolbarHeight - 1). But you can only get from the toolbar frame
 19295: // to the containing window - the other direction doesn't work. That's why the
 19295: // toolbar height is cached in the ToolbarWindow but nsNativeThemeCocoa can simply
 19295: // query the window for its titlebar height when drawing the toolbar.
  2029: @implementation ToolbarWindow
  2029: 
 31548: - (id)initWithContentRect:(NSRect)aContentRect styleMask:(NSUInteger)aStyle backing:(NSBackingStoreType)aBufferingType defer:(BOOL)aFlag
  7242: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
  7242:   aStyle = aStyle | NSTexturedBackgroundWindowMask;
  7242:   if ((self = [super initWithContentRect:aContentRect styleMask:aStyle backing:aBufferingType defer:aFlag])) {
 34487:     mColor = [[TitlebarAndBackgroundColor alloc] initWithWindow:self];
 34487:     // Bypass our guard method below.
  7242:     [super setBackgroundColor:mColor];
 86577:     mBackgroundColor = [[NSColor whiteColor] retain];
  7242: 
 19295:     mUnifiedToolbarHeight = 0.0f;
 19295: 
  7242:     // setBottomCornerRounded: is a private API call, so we check to make sure
  7242:     // we respond to it just in case.
  7242:     if ([self respondsToSelector:@selector(setBottomCornerRounded:)])
  7242:       [self setBottomCornerRounded:NO];
 34855: 
 34855:     [self setAutorecalculatesContentBorderThickness:NO forEdge:NSMaxYEdge];
 34855:     [self setContentBorderThickness:0.0f forEdge:NSMaxYEdge];
  7242:   }
  7242:   return self;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
  7242: }
  7242: 
  7242: - (void)dealloc
  7242: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
  7242:   [mColor release];
 34487:   [mBackgroundColor release];
  7242:   [super dealloc];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  7242: }
  7242: 
 34487: - (void)setTitlebarColor:(NSColor*)aColor forActiveWindow:(BOOL)aActive
 34487: {
 34487:   [super setTitlebarColor:aColor forActiveWindow:aActive];
 34487:   [self setTitlebarNeedsDisplayInRect:[self titlebarRect]];
 34487: }
 34487: 
  7242: - (void)setBackgroundColor:(NSColor*)aColor
  7242: {
 34487:   [aColor retain];
 34487:   [mBackgroundColor release];
 34487:   mBackgroundColor = aColor;
  7242: }
  7242: 
  7242: - (NSColor*)windowBackgroundColor
  7242: {
 34487:   return mBackgroundColor;
  7242: }
  7242: 
 34054: - (void)setTitlebarNeedsDisplayInRect:(NSRect)aRect
 34054: {
 34054:   [self setTitlebarNeedsDisplayInRect:aRect sync:NO];
 34054: }
 34054: 
 34054: - (void)setTitlebarNeedsDisplayInRect:(NSRect)aRect sync:(BOOL)aSync
 34054: {
 34054:   NSRect titlebarRect = [self titlebarRect];
 34054:   NSRect rect = NSIntersectionRect(titlebarRect, aRect);
 34054:   if (NSIsEmptyRect(rect))
 34054:     return;
 34054: 
 34054:   NSView* borderView = [[self contentView] superview];
 34054:   if (!borderView)
 34054:     return;
 34054: 
 34054:   if (aSync) {
 34054:     [borderView displayRect:rect];
 34054:   } else {
 34054:     [borderView setNeedsDisplayInRect:rect];
 34054:   }
 34054: }
 34054: 
 34054: - (NSRect)titlebarRect
 34054: {
 34054:   return NSMakeRect(0, [[self contentView] bounds].size.height,
 34054:                     [self frame].size.width, [self titlebarHeight]);
 14886: }
 14886: 
 19295: - (float)unifiedToolbarHeight
 14886: {
 19295:   return mUnifiedToolbarHeight;
  7242: }
  7242: 
 19295: - (float)titlebarHeight
 19295: {
 19295:   NSRect frameRect = [self frame];
 19295:   return frameRect.size.height - [self contentRectForFrameRect:frameRect].size.height;
 19295: }
 19295: 
 60289: - (void)setUnifiedToolbarHeight:(float)aHeight
 37194: {
 60289:   if ([self drawsContentsIntoWindowFrame] || aHeight == mUnifiedToolbarHeight)
 48165:     return;
 48165: 
 60289:   mUnifiedToolbarHeight = aHeight;
 60289: 
 60289:   // Update sheet positioning hint.
 48165:   [self setContentBorderThickness:mUnifiedToolbarHeight forEdge:NSMaxYEdge];
 48165: 
 60289:   // Redraw the title bar. If we're inside painting, we'll do it right now,
 60289:   // otherwise we'll just invalidate it.
 60289:   BOOL needSyncRedraw = ([NSView focusView] != nil);
 60289:   [self setTitlebarNeedsDisplayInRect:[self titlebarRect] sync:needSyncRedraw];
 37194: }
 37194: 
 34054: - (void)setDrawsContentsIntoWindowFrame:(BOOL)aState
 34054: {
 34487:   BOOL stateChanged = ([self drawsContentsIntoWindowFrame] != aState);
 34487:   [super setDrawsContentsIntoWindowFrame:aState];
 57862:   if (stateChanged && [[self delegate] isKindOfClass:[WindowDelegate class]]) {
 57862:     WindowDelegate *windowDelegate = (WindowDelegate *)[self delegate];
 57862:     nsCocoaWindow *geckoWindow = [windowDelegate geckoWidget];
 34054:     if (geckoWindow) {
 34054:       // Re-layout our contents.
 34054:       geckoWindow->ReportSizeEvent();
 34054:     }
 75392: 
 75392:     // Resizing the content area causes a reflow which would send a synthesized
 75392:     // mousemove event to the old mouse position relative to the top left
 75392:     // corner of the content area. But the mouse has shifted relative to the
 75392:     // content area, so that event would have wrong position information. So
 75392:     // we'll send a mouse move event with the correct new position.
 75392:     ChildViewMouseTracker::ResendLastMouseMoveEvent();
 75392: 
120690:     [self setTitlebarNeedsDisplayInRect:[self titlebarRect]];
120206:   }
120206: }
 34054: 
 31160: // Returning YES here makes the setShowsToolbarButton method work even though
 31160: // the window doesn't contain an NSToolbar.
  2029: - (BOOL)_hasToolbar
  2029: {
  2029:   return YES;
  2029: }
  2029: 
  7242: // Dispatch a toolbar pill button clicked message to Gecko.
  2029: - (void)_toolbarPillButtonClicked:(id)sender
  2029: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 39602:   RollUpPopups();
 39602: 
 57862:   if ([[self delegate] isKindOfClass:[WindowDelegate class]]) {
 57862:     WindowDelegate *windowDelegate = (WindowDelegate *)[self delegate];
 57862:     nsCocoaWindow *geckoWindow = [windowDelegate geckoWidget];
 15025:     if (!geckoWindow)
 15025:       return;
108457: 
108457:     nsIWidgetListener* listener = geckoWindow->GetWidgetListener();
108457:     if (listener)
108457:       listener->OSToolbarButtonPressed();
 57862:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  2029: }
  2029: 
  7106: // Retain and release "self" to avoid crashes when our widget (and its native
  7106: // window) is closed as a result of processing a key equivalent (e.g.
  7106: // Command+w or Command+q).  This workaround is only needed for a window
  7106: // that can become key.
  7106: - (BOOL)performKeyEquivalent:(NSEvent*)theEvent
  7106: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
  7106:   NSWindow *nativeWindow = [self retain];
  7106:   BOOL retval = [super performKeyEquivalent:theEvent];
  7106:   [nativeWindow release];
  7106:   return retval;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
  7106: }
  7106: 
 13491: - (void)sendEvent:(NSEvent *)anEvent
 13491: {
 13491:   NSEventType type = [anEvent type];
 13491:   
 13491:   switch (type) {
 13491:     case NSScrollWheel:
 13491:     case NSLeftMouseDown:
 13491:     case NSLeftMouseUp:
 13491:     case NSRightMouseDown:
 13491:     case NSRightMouseUp:
 13491:     case NSOtherMouseDown:
 13491:     case NSOtherMouseUp:
 13491:     case NSMouseMoved:
 13491:     case NSLeftMouseDragged:
 13491:     case NSRightMouseDragged:
 13491:     case NSOtherMouseDragged:
 13520:     {
 13491:       // Drop all mouse events if a modal window has appeared above us.
 13491:       // This helps make us behave as if the OS were running a "real" modal
 13491:       // event loop.
 13491:       id delegate = [self delegate];
 13491:       if (delegate && [delegate isKindOfClass:[WindowDelegate class]]) {
 13491:         nsCocoaWindow *widget = [(WindowDelegate *)delegate geckoWidget];
 13491:         if (widget) {
 26321:           if (gGeckoAppModalWindowList && (widget != gGeckoAppModalWindowList->window))
 13491:             return;
 13491:           if (widget->HasModalDescendents())
 13491:             return;
 13491:         }
 13491:       }
 13491:       break;
 13520:     }
 13491:     default:
 13491:       break;
 13491:   }
 13491: 
 13491:   [super sendEvent:anEvent];
 13491: }
 13491: 
120690: @end
120690: 
120690: // Custom NSColor subclass where most of the work takes place for drawing in
120690: // the titlebar area.
120690: @implementation TitlebarAndBackgroundColor
120690: 
120690: - (id)initWithWindow:(ToolbarWindow*)aWindow
120690: {
120690:   if ((self = [super init])) {
120690:     mWindow = aWindow; // weak ref to avoid a cycle
120690:   }
120690:   return self;
120690: }
120690: 
120690: static void
120690: DrawNativeTitlebar(CGContextRef aContext, CGRect aTitlebarRect,
120690:                    float aToolbarHeight, BOOL aIsMain)
120690: {
120690:   if (aTitlebarRect.size.width * aTitlebarRect.size.height > CUIDRAW_MAX_AREA) {
120690:     return;
120690:   }
120690:   int unifiedHeight = aTitlebarRect.size.height + aToolbarHeight;
120690:   CUIDraw([NSWindow coreUIRenderer], aTitlebarRect, aContext,
120690:           (CFDictionaryRef)[NSDictionary dictionaryWithObjectsAndKeys:
120690:             @"kCUIWidgetWindowFrame", @"widget",
120690:             @"regularwin", @"windowtype",
120690:             (aIsMain ? @"normal" : @"inactive"), @"state",
120690:             [NSNumber numberWithInt:unifiedHeight], @"kCUIWindowFrameUnifiedTitleBarHeightKey",
120690:             [NSNumber numberWithBool:YES], @"kCUIWindowFrameDrawTitleSeparatorKey",
120690:             nil],
120690:           nil);
120690: 
120690:   if (nsCocoaFeatures::OnLionOrLater()) {
120690:     // On Lion the call to CUIDraw doesn't draw the top pixel strip at some
120690:     // window widths. We don't want to have a flickering transparent line, so
120690:     // we overdraw it.
120690:     CGContextSetRGBFillColor(aContext, 0.95, 0.95, 0.95, 1);
120690:     CGContextFillRect(aContext, CGRectMake(0, CGRectGetMaxY(aTitlebarRect) - 1,
120690:                                            aTitlebarRect.size.width, 1));
120690:   }
120690: }
120690: 
120690: // Pattern draw callback for standard titlebar gradients and solid titlebar colors
120690: static void
120690: TitlebarDrawCallback(void* aInfo, CGContextRef aContext)
120690: {
120690:   ToolbarWindow *window = (ToolbarWindow*)aInfo;
120690:   NSRect titlebarRect = [window titlebarRect];
120690: 
120690:   if ([window drawsContentsIntoWindowFrame]) {
120690:     NSView* view = [[[window contentView] subviews] lastObject];
120690:     if (!view || ![view isKindOfClass:[ChildView class]])
120690:       return;
120690: 
120690:     // Gecko drawing assumes flippedness, but the current context isn't flipped
120690:     // (because we're painting into the window's border view, which is not a
120690:     // ChildView, so it isn't flipped).
120690:     // So we need to set a flip transform.
120690:     CGContextScaleCTM(aContext, 1.0f, -1.0f);
120690:     CGContextTranslateCTM(aContext, 0.0f, -[window frame].size.height);
120690: 
120690:     NSRect flippedTitlebarRect = { NSZeroPoint, titlebarRect.size };
120690:     [(ChildView*)view drawRect:flippedTitlebarRect inTitlebarContext:aContext];
120690:   } else {
120690:     BOOL isMain = [window isMainWindow];
120690:     NSColor *titlebarColor = [window titlebarColorForActiveWindow:isMain];
120690:     if (!titlebarColor) {
120690:       // If the titlebar color is nil, draw the default titlebar shading.
120690:       DrawNativeTitlebar(aContext, NSRectToCGRect(titlebarRect),
120690:                          [window unifiedToolbarHeight], isMain);
120690:     } else {
120690:       // If the titlebar color is not nil, just set and draw it normally.
120690:       [NSGraphicsContext saveGraphicsState];
120690:       [NSGraphicsContext setCurrentContext:[NSGraphicsContext graphicsContextWithGraphicsPort:aContext flipped:NO]];
120690:       [titlebarColor set];
120690:       NSRectFill(titlebarRect);
120690:       [NSGraphicsContext restoreGraphicsState];
120690:     }
120690:   }
120690: }
120690: 
120690: - (void)setFill
120690: {
120690:   float patternWidth = [mWindow frame].size.width;
120690: 
120690:   CGPatternCallbacks callbacks = {0, &TitlebarDrawCallback, NULL};
120690:   CGPatternRef pattern = CGPatternCreate(mWindow, CGRectMake(0.0f, 0.0f, patternWidth, [mWindow frame].size.height), 
120690:                                          CGAffineTransformIdentity, patternWidth, [mWindow frame].size.height,
120690:                                          kCGPatternTilingConstantSpacing, true, &callbacks);
120690: 
120690:   // Set the pattern as the fill, which is what we were asked to do. All our
120690:   // drawing will take place in the patternDraw callback.
120690:   CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(NULL);
120690:   CGContextRef context = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
120690:   CGContextSetFillColorSpace(context, patternSpace);
120690:   CGColorSpaceRelease(patternSpace);
120690:   CGFloat component = 1.0f;
120690:   CGContextSetFillPattern(context, pattern, &component);
120690:   CGPatternRelease(pattern);
120690: }
120690: 
120690: - (void)set
120690: {
120690:   [self setFill];
120690: }
120690: 
120690: - (NSString*)colorSpaceName
120690: {
120690:   return NSDeviceRGBColorSpace;
120690: }
120690: 
120690: @end
120690: 
120690: @implementation PopupWindow
120690: 
120690: - (id)initWithContentRect:(NSRect)contentRect styleMask:(NSUInteger)styleMask
120690:       backing:(NSBackingStoreType)bufferingType defer:(BOOL)deferCreation
120690: {
120690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
120690: 
120690:   mIsContextMenu = false;
120690:   return [super initWithContentRect:contentRect styleMask:styleMask
120690:           backing:bufferingType defer:deferCreation];
120690: 
120690:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
120690: }
120690: 
120690: - (BOOL)isContextMenu
120690: {
120690:   return mIsContextMenu;
120690: }
120690: 
120690: - (void)setIsContextMenu:(BOOL)flag
120690: {
120690:   mIsContextMenu = flag;
120690: }
120690: 
120690: - (BOOL)canBecomeMainWindow
120690: {
120690:   // This is overriden because the default is 'yes' when a titlebar is present.
120690:   return NO;
120690: }
120690: 
120690: @end
120690: 
120690: // According to Apple's docs on [NSWindow canBecomeKeyWindow] and [NSWindow
120690: // canBecomeMainWindow], windows without a title bar or resize bar can't (by
120690: // default) become key or main.  But if a window can't become key, it can't
120690: // accept keyboard input (bmo bug 393250).  And it should also be possible for
120690: // an otherwise "ordinary" window to become main.  We need to override these
120690: // two methods to make this happen.
120690: @implementation BorderlessWindow
120690: 
120690: - (BOOL)canBecomeKeyWindow
120690: {
120690:   return YES;
120690: }
120690: 
120690: - (void)sendEvent:(NSEvent *)anEvent
120690: {
120690:   NSEventType type = [anEvent type];
120690:   
120690:   switch (type) {
120690:     case NSScrollWheel:
120690:     case NSLeftMouseDown:
120690:     case NSLeftMouseUp:
120690:     case NSRightMouseDown:
120690:     case NSRightMouseUp:
120690:     case NSOtherMouseDown:
120690:     case NSOtherMouseUp:
120690:     case NSMouseMoved:
120690:     case NSLeftMouseDragged:
120690:     case NSRightMouseDragged:
120690:     case NSOtherMouseDragged:
120690:     {
120690:       // Drop all mouse events if a modal window has appeared above us.
120690:       // This helps make us behave as if the OS were running a "real" modal
120690:       // event loop.
120690:       id delegate = [self delegate];
120690:       if (delegate && [delegate isKindOfClass:[WindowDelegate class]]) {
120690:         nsCocoaWindow *widget = [(WindowDelegate *)delegate geckoWidget];
120690:         if (widget) {
120690:           if (gGeckoAppModalWindowList && (widget != gGeckoAppModalWindowList->window))
120690:             return;
120690:           if (widget->HasModalDescendents())
120690:             return;
120690:         }
120690:       }
120690:       break;
120690:     }
120690:     default:
120690:       break;
120690:   }
120690: 
120690:   [super sendEvent:anEvent];
120690: }
120690: 
  7042: // Apple's doc on this method says that the NSWindow class's default is not to
  7042: // become main if the window isn't "visible" -- so we should replicate that
  7042: // behavior here.  As best I can tell, the [NSWindow isVisible] method is an
  7042: // accurate test of what Apple means by "visibility".
  7042: - (BOOL)canBecomeMainWindow
  7042: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
  7042:   if (![self isVisible])
  7042:     return NO;
  7042:   return YES;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
  7042: }
  7042: 
  7106: // Retain and release "self" to avoid crashes when our widget (and its native
  7106: // window) is closed as a result of processing a key equivalent (e.g.
  7106: // Command+w or Command+q).  This workaround is only needed for a window
  7106: // that can become key.
  7106: - (BOOL)performKeyEquivalent:(NSEvent*)theEvent
  7106: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
  7106:   NSWindow *nativeWindow = [self retain];
  7106:   BOOL retval = [super performKeyEquivalent:theEvent];
  7106:   [nativeWindow release];
  7106:   return retval;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
  7106: }
  7106: 
  7042: @end
