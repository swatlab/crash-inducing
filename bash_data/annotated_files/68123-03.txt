51215: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
51215:  *
51215:  * ***** BEGIN LICENSE BLOCK *****
51215:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
51215:  *
51215:  * The contents of this file are subject to the Mozilla Public License Version
51215:  * 1.1 (the "License"); you may not use this file except in compliance with
51215:  * the License. You may obtain a copy of the License at
51215:  * http://www.mozilla.org/MPL/
51215:  *
51215:  * Software distributed under the License is distributed on an "AS IS" basis,
51215:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
51215:  * for the specific language governing rights and limitations under the
51215:  * License.
51215:  *
51215:  * The Original Code is mozilla.org code.
51215:  *
51215:  * The Initial Developer of the Original Code is
51215:  * Netscape Communications Corporation.
51215:  * Portions created by the Initial Developer are Copyright (C) 2001
51215:  * the Initial Developer. All Rights Reserved.
51215:  *
51215:  * Contributor(s):
51215:  *   Scott MacGregor <mscott@netscape.com>
51215:  *   Bobby Holley <bobbyholley@gmail.com>
51215:  *
51215:  * Alternatively, the contents of this file may be used under the terms of
51215:  * either the GNU General Public License Version 2 or later (the "GPL"), or
51215:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
51215:  * in which case the provisions of the GPL or the LGPL are applicable instead
51215:  * of those above. If you wish to allow use of your version of this file only
51215:  * under the terms of either the GPL or the LGPL, and not to allow others to
51215:  * use your version of this file under the terms of the MPL, indicate your
51215:  * decision by deleting the provisions above and replace them with the notice
51215:  * and other provisions required by the GPL or the LGPL. If you do not delete
51215:  * the provisions above, a recipient may use your version of this file under
51215:  * the terms of any one of the MPL, the GPL or the LGPL.
51215:  *
51215:  * ***** END LICENSE BLOCK ***** */
51215: 
51215: #include "nsIconDecoder.h"
51215: #include "nsIInputStream.h"
51215: #include "RasterImage.h"
51215: #include "imgIContainerObserver.h"
51215: #include "nspr.h"
51215: #include "nsRect.h"
51215: 
51215: #include "ImageErrors.h"
51215: 
51241: namespace mozilla {
51241: namespace imagelib {
51215: 
51215: nsIconDecoder::nsIconDecoder() :
51215:   mWidth(-1),
51215:   mHeight(-1),
51215:   mPixBytesRead(0),
51215:   mPixBytesTotal(0),
51215:   mImageData(nsnull),
53669:   mState(iconStateStart)
51215: {
51215:   // Nothing to do
51215: }
51215: 
51215: nsIconDecoder::~nsIconDecoder()
51215: { }
51215: 
53664: void
51241: nsIconDecoder::WriteInternal(const char *aBuffer, PRUint32 aCount)
51215: {
53675:   NS_ABORT_IF_FALSE(!HasError(), "Shouldn't call WriteInternal after error!");
53662: 
51215:   // We put this here to avoid errors about crossing initialization with case
51215:   // jumps on linux.
51215:   PRUint32 bytesToRead = 0;
53673:   nsresult rv;
51215: 
51215:   // Performance isn't critical here, so our update rectangle is 
51215:   // always the full icon
51215:   nsIntRect r(0, 0, mWidth, mHeight);
51215: 
51215:   // Loop until the input data is gone
51215:   while (aCount > 0) {
51215:     switch (mState) {
51215:       case iconStateStart:
51215: 
51215:         // Grab the width
51215:         mWidth = (PRUint8)*aBuffer;
51215: 
51215:         // Book Keeping
51215:         aBuffer++;
51215:         aCount--;
51215:         mState = iconStateHaveHeight;
51215:         break;
51215: 
51215:       case iconStateHaveHeight:
51215: 
51215:         // Grab the Height
51215:         mHeight = (PRUint8)*aBuffer;
51215: 
51245:         // Post our size to the superclass
51245:         PostSize(mWidth, mHeight);
68123:         if (HasError()) {
68123:           // Setting the size lead to an error; this can happen when for example
68123:           // a multipart channel sends an image of a different size.
68123:           mState = iconStateFinished;
68123:           return;
68123:         }
51215: 
51244:         // If We're doing a size decode, we're done
51244:         if (IsSizeDecode()) {
51215:           mState = iconStateFinished;
51215:           break;
51215:         }
51215: 
51215:         // Add the frame and signal
51215:         rv = mImage->AppendFrame(0, 0, mWidth, mHeight,
51215:                                  gfxASurface::ImageFormatARGB32,
51215:                                  &mImageData, &mPixBytesTotal);
51215:         if (NS_FAILED(rv)) {
53662:           PostDecoderError(rv);
53664:           return;
51215:         }
51246: 
51246:         // Tell the superclass we're starting a frame
51246:         PostFrameStart();
51215: 
51215:         // Book Keeping
51215:         aBuffer++;
51215:         aCount--;
51215:         mState = iconStateReadPixels;
51215:         break;
51215: 
51215:       case iconStateReadPixels:
51215: 
51215:         // How many bytes are we reading?
51215:         bytesToRead = PR_MIN(aCount, mPixBytesTotal - mPixBytesRead);
51215: 
51215:         // Copy the bytes
51215:         memcpy(mImageData + mPixBytesRead, aBuffer, bytesToRead);
51215: 
51592:         // Invalidate
51592:         PostInvalidation(r);
51215: 
51215:         // Book Keeping
51215:         aBuffer += bytesToRead;
51215:         aCount -= bytesToRead;
51215:         mPixBytesRead += bytesToRead;
51215: 
51215:         // If we've got all the pixel bytes, we're finished
51215:         if (mPixBytesRead == mPixBytesTotal) {
53669:           PostFrameStop();
53669:           PostDecodeDone();
51215:           mState = iconStateFinished;
51215:         }
51215:         break;
51215: 
51215:       case iconStateFinished:
51215: 
51215:         // Consume all excess data silently
51215:         aCount = 0;
51215: 
51215:         break;
51215:     }
51215:   }
51215: }
51215: 
51241: } // namespace imagelib
51241: } // namespace mozilla
