51237: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
51237: /* ***** BEGIN LICENSE BLOCK *****
51237:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
51237:  *
51237:  * The contents of this file are subject to the Mozilla Public License Version
51237:  * 1.1 (the "License"); you may not use this file except in compliance with
51237:  * the License. You may obtain a copy of the License at
51237:  * http://www.mozilla.org/MPL/
51237:  *
51237:  * Software distributed under the License is distributed on an "AS IS" basis,
51237:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
51237:  * for the specific language governing rights and limitations under the
51237:  * License.
51237:  *
51237:  * The Original Code is mozilla.org code.
51237:  *
51237:  * The Initial Developer of the Original Code is
51237:  * the Mozilla Foundation.
51237:  * Portions created by the Initial Developer are Copyright (C) 2010.
51237:  * the Initial Developer. All Rights Reserved.
51237:  *
51237:  * Contributor(s):
51237:  *   Bobby Holley <bobbyholley@gmail.com>
51237:  *
51237:  * Alternatively, the contents of this file may be used under the terms of
51237:  * either the GNU General Public License Version 2 or later (the "GPL"), or
51237:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
51237:  * in which case the provisions of the GPL or the LGPL are applicable instead
51237:  * of those above. If you wish to allow use of your version of this file only
51237:  * under the terms of either the GPL or the LGPL, and not to allow others to
51237:  * use your version of this file under the terms of the MPL, indicate your
51237:  * decision by deleting the provisions above and replace them with the notice
51237:  * and other provisions required by the GPL or the LGPL. If you do not delete
51237:  * the provisions above, a recipient may use your version of this file under
51237:  * the terms of any one of the MPL, the GPL or the LGPL.
51237:  *
51237:  * ***** END LICENSE BLOCK ***** */
51237: 
51237: #ifndef MOZILLA_IMAGELIB_DECODER_H_
51237: #define MOZILLA_IMAGELIB_DECODER_H_
51237: 
51237: #include "RasterImage.h"
51237: 
51237: #include "imgIDecoderObserver.h"
51237: 
51237: namespace mozilla {
51237: namespace imagelib {
51237: 
51248: class Decoder
51237: {
51237: public:
51237: 
51237:   Decoder();
51237:   virtual ~Decoder();
51237: 
51237:   /**
51247:    * Initialize an image decoder. Decoders may not be re-initialized.
51237:    *
51237:    * @param aContainer The image container to decode to.
51237:    * @param aObserver The observer for decode notification events.
51237:    *
51237:    * Notifications Sent: TODO
51237:    */
53672:   void Init(RasterImage* aImage, imgIDecoderObserver* aObserver);
51237: 
51237:   /**
51237:    * Writes data to the decoder.
51237:    *
51237:    * @param aBuffer buffer containing the data to be written
51237:    * @param aCount the number of bytes to write
51237:    *
51237:    * Any errors are reported by setting the appropriate state on the decoder.
51237:    *
51237:    * Notifications Sent: TODO
51237:    */
53672:   void Write(const char* aBuffer, PRUint32 aCount);
51237: 
51237:   /**
51237:    * Informs the decoder that all the data has been written.
51237:    *
51237:    * Notifications Sent: TODO
51237:    */
53672:   void Finish();
51237: 
51591:   /**
51593:    * Tells the decoder to flush any pending invalidations. This informs the image
51593:    * frame of its decoded region, and sends the appropriate OnDataAvailable call
51593:    * to consumers.
51593:    *
51593:    * This can be called any time when we're midway through decoding a frame,
51593:    * and must be called after finishing a frame (before starting a new one).
51591:    */
51591:   void FlushInvalidations();
51591: 
51237:   // We're not COM-y, so we don't get refcounts by default
51248:   NS_INLINE_DECL_REFCOUNTING(Decoder)
51237: 
51244:   /*
51244:    * State.
51244:    */
51244: 
51244:   // If we're doing a "size decode", we more or less pass through the image
51244:   // data, stopping only to scoop out the image dimensions. A size decode
51244:   // must be enabled by SetSizeDecode() _before_calling Init().
51244:   bool IsSizeDecode() { return mSizeDecode; };
51244:   void SetSizeDecode(bool aSizeDecode)
51244:   {
51244:     NS_ABORT_IF_FALSE(!mInitialized, "Can't set size decode after Init()!");
51244:     mSizeDecode = aSizeDecode;
51244:   }
51244: 
51246:   // The number of frames we have, including anything in-progress. Thus, this
51246:   // is only 0 if we haven't begun any frames.
51246:   PRUint32 GetFrameCount() { return mFrameCount; }
51246: 
53666:   // The number of complete frames we have (ie, not including anything in-progress).
53666:   PRUint32 GetCompleteFrameCount() { return mInFrame ? mFrameCount - 1 : mFrameCount; }
53666: 
53661:   // Error tracking
53675:   bool HasError() { return HasDataError() || HasDecoderError(); };
53675:   bool HasDataError() { return mDataError; };
53675:   bool HasDecoderError() { return NS_FAILED(mFailCode); };
53661:   nsresult GetDecoderError() { return mFailCode; };
69680:   void PostResizeError() { PostDataError(); }
53661: 
60418:   // flags.  Keep these in sync with imgIContainer.idl.
60418:   // SetDecodeFlags must be called before Init(), otherwise
60418:   // default flags are assumed.
60418:   enum {
60418:     DECODER_NO_PREMULTIPLY_ALPHA = 0x2,
60418:     DECODER_NO_COLORSPACE_CONVERSION = 0x4
60418:   };
60418:   void SetDecodeFlags(PRUint32 aFlags) { mDecodeFlags = aFlags; }
60418:   PRUint32 GetDecodeFlags() { return mDecodeFlags; }
60418: 
51237: protected:
51237: 
51237:   /*
51237:    * Internal hooks. Decoder implementations may override these and
51237:    * only these methods.
51237:    */
53664:   virtual void InitInternal();
53664:   virtual void WriteInternal(const char* aBuffer, PRUint32 aCount);
53664:   virtual void FinishInternal();
51237: 
51237:   /*
51245:    * Progress notifications.
51245:    */
51245: 
51245:   // Called by decoders when they determine the size of the image. Informs
51245:   // the image of its size and sends notifications.
51245:   void PostSize(PRInt32 aWidth, PRInt32 aHeight);
51245: 
51246:   // Called by decoders when they begin/end a frame. Informs the image, sends
51246:   // notifications, and does internal book-keeping.
51246:   void PostFrameStart();
51246:   void PostFrameStop();
51246: 
51591:   // Called by the decoders when they have a region to invalidate. We may not
51591:   // actually pass these invalidations on right away.
51591:   void PostInvalidation(nsIntRect& aRect);
51245: 
53669:   // Called by the decoders when they have successfully decoded the image. This
53669:   // may occur as the result of the decoder getting to the appropriate point in
53669:   // the stream, or by us calling FinishInternal().
53669:   //
53669:   // May not be called mid-frame.
53669:   void PostDecodeDone();
53669: 
53661:   // Data errors are the fault of the source data, decoder errors are our fault
53661:   void PostDataError();
53661:   void PostDecoderError(nsresult aFailCode);
53661: 
51245:   /*
51237:    * Member variables.
51237:    *
51237:    */
51237:   nsRefPtr<RasterImage> mImage;
53670: 
60418:   PRUint32 mDecodeFlags;
60418: 
53670: private:
51237:   nsCOMPtr<imgIDecoderObserver> mObserver;
51237: 
51246:   PRUint32 mFrameCount; // Number of frames, including anything in-progress
51246: 
51591:   nsIntRect mInvalidRect; // Tracks an invalidation region in the current frame.
51591: 
53661:   nsresult mFailCode;
53661: 
51237:   bool mInitialized;
51244:   bool mSizeDecode;
51246:   bool mInFrame;
53669:   bool mDecodeDone;
53661:   bool mDataError;
51237: };
51237: 
51237: } // namespace imagelib
51237: } // namespace mozilla
51237: 
51237: #endif // MOZILLA_IMAGELIB_DECODER_H_
