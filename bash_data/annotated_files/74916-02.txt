29929: /**
29929:  * This file provides set of helper functions to test nsIAccessibleTable
29929:  * interface.
29929:  *
29929:  * Required:
29929:  *   common.js
32381:  *   role.js
29929:  *   states.js
29929:  */
29929: 
28493: /**
32381:  * Constants used to describe cells array.
32381:  */
32381: const kDataCell = 1; // Indicates the cell is origin data cell
32381: const kRowHeaderCell = 2; // Indicates the cell is row header cell
38158: const kColHeaderCell = 4; // Indicated the cell is column header cell
32381: const kOrigin = kDataCell | kRowHeaderCell | kColHeaderCell;
32381: 
32381: const kRowSpanned = 8; // Indicates the cell is not origin and row spanned 
32381: const kColSpanned = 16; // Indicates the cell is not origin and column spanned
32381: const kSpanned = kRowSpanned | kColSpanned;
32381: 
32381: /**
32381:  * Constants to define column header type.
32381:  */
32381: const kNoColumnHeader = 0;
32381: const kListboxColumnHeader = 1;
32381: const kTreeColumnHeader = 2;
32381: 
32381: /**
32381:  * Test table structure and related methods.
32381:  *
32381:  * @param  aIdentifier     [in] table accessible identifier
32381:  * @param  aCellsArray     [in] two dimensional array (row X columns) of
32381:  *                          cell types (see constants defined above).
32381:  * @param  aColHeaderType  [in] specifies wether column header cells are
32381:  *                          arranged into the list.
32381:  * @param  aCaption        [in] caption text if any
32381:  * @param  aSummary        [in] summary text if any
32479:  * @param  aIsTreeTable    [in] specifies whether given table is tree table
32381:  */
32381: function testTableStruct(aIdentifier, aCellsArray, aColHeaderType,
32479:                          aCaption, aSummary, aIsTreeTable)
32381: {
32381:   var tableNode = getNode(aIdentifier);
32381:   var isGrid = tableNode.getAttribute("role") == "grid" ||
32479:     tableNode.getAttribute("role") == "treegrid" ||
32381:     tableNode.localName == "tree";
32381: 
32381:   var rowCount = aCellsArray.length;
74916:   var colsCount = aCellsArray[0] ? aCellsArray[0].length : 0;
32381: 
32381:   // Test table accessible tree.
32381:   var tableObj = {
32479:     role: aIsTreeTable ? ROLE_TREE_TABLE : ROLE_TABLE,
32381:     children: []
32381:   };
32381: 
32381:   // caption accessible handling
32381:   if (aCaption) {
32381:     var captionObj = {
32381:       role: ROLE_CAPTION,
32381:       children: [
32381:         {
32381:           role: ROLE_TEXT_LEAF,
32381:           name: aCaption
32381:         }
32381:       ]
32381:     };
32381: 
32381:     tableObj.children.push(captionObj);
32381:   }
32381: 
32381:   // special types of column headers handling
32381:   if (aColHeaderType) {
32381:     var headersObj = {
32381:       role: ROLE_LIST,
32381:       children: []
32381:     };
32381: 
32381:     for (var idx = 0; idx < colsCount; idx++) {
32381:       var headerCellObj = {
32381:         role: ROLE_COLUMNHEADER
32381:       };
32381:       headersObj.children.push(headerCellObj);
32381:     }
32381: 
32381:     if (aColHeaderType == kTreeColumnHeader) {
32381:       var columnPickerObj = {
32381:         role: ROLE_PUSHBUTTON
32381:       };
32381: 
32381:       headersObj.children.push(columnPickerObj);
32381:     }
32381: 
32381:     tableObj.children.push(headersObj);
32381:   }
32381: 
32381:   // rows and cells accessibles
32381:   for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {
32381:     var rowObj = {
32381:       role: ROLE_ROW,
32381:       children: []
32381:     };
32381: 
32381:     for (var colIdx = 0; colIdx < colsCount; colIdx++) {
32381:       var celltype = aCellsArray[rowIdx][colIdx];
32381: 
32381:       var role = ROLE_NOTHING;
32381:       switch (celltype) {
32381:         case kDataCell:
32381:           role = (isGrid ? ROLE_GRID_CELL : ROLE_CELL);
32381:           break;
32381:         case kRowHeaderCell:
32381:           role = ROLE_ROWHEADER;
32381:           break;
32381:         case kColHeaderCell:
32381:           role = ROLE_COLUMNHEADER;
32381:           break;
32381:       }
32381: 
32381:       if (role != ROLE_NOTHING) {
32381:         var cellObj = {
32381:           role: role
32381:         };
32381:         rowObj.children.push(cellObj);
32381:       }
32381:     }
32381: 
32381:     tableObj.children.push(rowObj);
32381:   }
32381: 
32381:   testAccessibleTree(aIdentifier, tableObj);
32381: 
32381:   // Test table table interface.
32381:   var table = getAccessible(aIdentifier, [nsIAccessibleTable]);
32381: 
32381:   // summary
32381:   if (aSummary)
32381:     is(table.summary, aSummary,
32381:        "Wrong summary of the table " + prettyName(aIdentifier));
32381: 
32381:   // rowCount and columnCount
32381:   is(table.rowCount, rowCount,
32381:      "Wrong rows count of " + prettyName(aIdentifier));
32381:   is(table.columnCount, colsCount,
32381:      "Wrong columns count of " + prettyName(aIdentifier));
32381: 
32381:   // rows and columns extents
32381:   for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {
32381:     for (var colIdx = 0; colIdx < colsCount; colIdx++) {
32381:       var celltype = aCellsArray[rowIdx][colIdx];
32381:       if (celltype & kOrigin) {
32381: 
32381:         // table getRowExtentAt
32381:         var rowExtent = table.getRowExtentAt(rowIdx, colIdx);
32381:         for (var idx = rowIdx + 1;
32381:              idx < rowCount && (aCellsArray[idx][colIdx] & kRowSpanned);
32381:              idx++);
32381: 
32381:         var expectedRowExtent = idx - rowIdx;
32381:         is(rowExtent, expectedRowExtent,
32381:            "getRowExtentAt: Wrong number of spanned rows at (" + rowIdx + ", " +
32381:            colIdx + ") for " + prettyName(aIdentifier));
32381: 
32381:         // table getColumnExtentAt
32381:         var colExtent = table.getColumnExtentAt(rowIdx, colIdx);
32381:         for (var idx = colIdx + 1;
32381:              idx < colsCount && (aCellsArray[rowIdx][idx] & kColSpanned);
32381:              idx++);
32381: 
32381:         var expectedColExtent = idx - colIdx;
32381:         is(colExtent, expectedColExtent,
32381:            "getColumnExtentAt: Wrong number of spanned columns at (" + rowIdx +
32381:            ", " + colIdx + ") for " + prettyName(aIdentifier));
32381: 
32381:         // cell rowExtent and columnExtent
32381:         var cell = getAccessible(table.getCellAt(rowIdx, colIdx),
32381:                                  [nsIAccessibleTableCell]);
32381: 
32381:         is(cell.rowExtent, expectedRowExtent,
32381:            "rowExtent: Wrong number of spanned rows at (" + rowIdx + ", " +
32381:            colIdx + ") for " + prettyName(aIdentifier));
32381: 
32381:         is(cell.columnExtent, expectedColExtent,
32381:            "columnExtent: Wrong number of spanned column at (" + rowIdx + ", " +
32381:            colIdx + ") for " + prettyName(aIdentifier));
32381:       }
32381:     }
32381:   }
32381: }
32381: 
32381: /**
28493:  * Test table indexes.
28493:  *
28493:  * @param  aIdentifier  [in] table accessible identifier
29821:  * @param  aIdxes       [in] two dimensional array of cell indexes
28493:  */
29821: function testTableIndexes(aIdentifier, aIdxes)
28493: {
28493:   var tableAcc = getAccessible(aIdentifier, [nsIAccessibleTable]);
28493:   if (!tableAcc)
28493:     return;
28493: 
29821:   var obtainedRowIdx, obtainedColIdx, obtainedIdx;
28493:   var cellAcc;
28493: 
28493:   var id = prettyName(aIdentifier);
28493: 
29821:   var rowCount = aIdxes.length;
29821:   for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {
29821:     var colCount = aIdxes[rowIdx].length;
29821:     for (var colIdx = 0; colIdx < colCount; colIdx++) {
29821:       var idx = aIdxes[rowIdx][colIdx];
29931: 
32381:       // getCellAt
29931:       try {
29931:         cellAcc = null;
32381:         cellAcc = tableAcc.getCellAt(rowIdx, colIdx);
29931:       } catch (e) { }
29931: 
29931:       ok(idx != -1 && cellAcc || idx == -1 && !cellAcc,
29931:          id + ": Can't get cell accessible at row = " + rowIdx + ", column = " + colIdx);
29931: 
29821:       if (idx != - 1) {
32381: 
47173:         // getRowIndexAt
29821:         var origRowIdx = rowIdx;
29821:         while (origRowIdx > 0 &&
29821:                aIdxes[rowIdx][colIdx] == aIdxes[origRowIdx - 1][colIdx])
29821:           origRowIdx--;
29821: 
28493:         try {
32381:           obtainedRowIdx = tableAcc.getRowIndexAt(idx);
28493:         } catch (e) {
29821:           ok(false, id + ": can't get row index for cell index " + idx + "," + e);
28493:         }
28493: 
29821:         is(obtainedRowIdx, origRowIdx,
47173:            id + ": row for index " + idx + " is not correct (getRowIndexAt)");
29821: 
47173:         // getColumnIndexAt
29821:         var origColIdx = colIdx;
29821:         while (origColIdx > 0 &&
29821:                aIdxes[rowIdx][colIdx] == aIdxes[rowIdx][origColIdx - 1])
29821:           origColIdx--;
29821: 
28493:         try {
32381:           obtainedColIdx = tableAcc.getColumnIndexAt(idx);
28493:         } catch (e) {
29821:           ok(false, id + ": can't get column index for cell index " + idx + "," + e);
28493:         }
28493: 
29821:         is(obtainedColIdx, origColIdx,
47173:            id + ": column  for index " + idx + " is not correct (getColumnIndexAt)");
47173: 
47173:         // getRowAndColumnIndicesAt
47173:         var obtainedRowIdxObj = { }, obtainedColIdxObj = { };
47173:         try {
47173:           tableAcc.getRowAndColumnIndicesAt(idx, obtainedRowIdxObj,
47173:                                             obtainedColIdxObj);
47173:         } catch (e) {
47173:           ok(false, id + ": can't get row and column indices for cell index " + idx + "," + e);
47173:         }
47173: 
47173:         is(obtainedRowIdxObj.value, origRowIdx,
47173:            id + ": row for index " + idx + " is not correct (getRowAndColumnIndicesAt)");
47173:         is(obtainedColIdxObj.value, origColIdx,
47173:            id + ": column  for index " + idx + " is not correct (getRowAndColumnIndicesAt)");
28493: 
28493:         if (cellAcc) {
32381: 
32381:           var cellId = prettyName(cellAcc);
32381:           cellAcc = getAccessible(cellAcc, [nsIAccessibleTableCell]);
32381: 
32381:           // cell: 'table-cell-index' attribute
28493:           var attrs = cellAcc.attributes;
28493:           var strIdx = "";
28493:           try {
28493:             strIdx = attrs.getStringProperty("table-cell-index");
28493:           } catch (e) {
28493:             ok(false,
32381:                cellId + ": no cell index from object attributes on the cell accessible at index " + idx + ".");
28493:           }
28493: 
28493:           if (strIdx) {
29821:             is (parseInt(strIdx), idx,
32381:                 cellId + ": cell index from object attributes of cell accessible isn't corrent.");
28493:           }
29821: 
32381:           // cell: table
29821:           try {
32381:             is(cellAcc.table, tableAcc,
32381:                cellId + ": wrong table accessible for the cell.");
32381: 
32381:           } catch (e) {
32381:             ok(false,
32381:                cellId + ": can't get table accessible from the cell.");
32381:           }
32381: 
32381:           // cell: getRowIndex
32381:           try {
32381:             obtainedRowIdx = cellAcc.rowIndex;
32381:           } catch (e) {
32381:             ok(false,
32381:                cellId + ": can't get row index of the cell at index " + idx + "," + e);
32381:           }
32381: 
32381:           is(obtainedRowIdx, origRowIdx,
32381:              cellId + ": row for the cell at index " + idx +" is not correct");
32381: 
32381:           // cell: getColumnIndex
32381:           try {
32381:             obtainedColIdx = cellAcc.columnIndex;
32381:           } catch (e) {
32381:             ok(false,
32381:                cellId + ": can't get column index of the cell at index " + idx + "," + e);
32381:           }
32381: 
32381:           is(obtainedColIdx, origColIdx,
32381:              id + ": column for the cell at index " + idx +" is not correct");
32381:         }
32381:       }
32381: 
32381:       // getCellIndexAt
32381:       try {
32381:         obtainedIdx = tableAcc.getCellIndexAt(rowIdx, colIdx);
29821:       } catch (e) {
29821:         obtainedIdx = -1;
29821:       }
29821: 
29821:       is(obtainedIdx, idx,
29821:          id + ": row " + rowIdx + " /column " + colIdx + " and index " + obtainedIdx + " aren't inconsistent.");
29821:     }
29821:   }
28493: }
29126: 
29126: /**
29126:  * Test table getters selection methods.
29126:  *
29126:  * @param  aIdentifier  [in] table accessible identifier
32354:  * @param  aCellsArray  [in] two dimensional array (row X columns) of cells
32354:  *                       states (either boolean (selected/unselected) if cell is
32381:  *                       origin, otherwise kRowSpanned or kColSpanned constant).
29126:  * @param  aMsg         [in] text appended before every message
29126:  */
30059: function testTableSelection(aIdentifier, aCellsArray, aMsg)
29126: {
29126:   var msg = aMsg ? aMsg : "";
29126:   var acc = getAccessible(aIdentifier, [nsIAccessibleTable]);
29126:   if (!acc)
29126:     return;
29126: 
32381:   var rowCount = aCellsArray.length;
29126:   var colsCount = aCellsArray[0].length;
29126: 
29126:   // Columns selection tests.
29126:   var selCols = new Array();
29126: 
29126:   // isColumnSelected test
29126:   for (var colIdx = 0; colIdx < colsCount; colIdx++) {
29126:     var isColSelected = true;
32381:     for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {
29966:       if (aCellsArray[rowIdx][colIdx] == false) {
29126:         isColSelected = false;
29126:         break;
29126:       }
29126:     }
29126: 
29126:     is(acc.isColumnSelected(colIdx), isColSelected,
29126:        msg + "Wrong selection state of " + colIdx + " column for " +
29126:        prettyName(aIdentifier));
29126: 
29126:     if (isColSelected)
29126:       selCols.push(colIdx);
29126:   }
29126: 
29126:   // selectedColsCount test
32387:   is(acc.selectedColumnCount, selCols.length,
29126:      msg + "Wrong count of selected columns for " + prettyName(aIdentifier));
29126: 
29126:   // getSelectedColumns test
29126:   var actualSelColsCountObj = { value: null };
32381:   var actualSelCols = acc.getSelectedColumnIndices(actualSelColsCountObj);
29126: 
29126:   var actualSelColsCount = actualSelColsCountObj.value;
29126:   is (actualSelColsCount, selCols.length,
29126:       msg + "Wrong count of selected columns for " + prettyName(aIdentifier) +
29126:       "from getSelectedColumns.");
29126: 
29126:   for (var i = 0; i < actualSelColsCount; i++) {
29126:     is (actualSelCols[i], selCols[i],
29126:         msg + "Column at index " + selCols[i] + " should be selected.");
29126:   }
29126: 
29126:   // Rows selection tests.
29126:   var selRows = new Array();
29126: 
29126:   // isRowSelected test
32381:   var selrowCount = 0;
32381:   for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {
29126:     var isRowSelected = true;
29126:     for (var colIdx = 0; colIdx < colsCount; colIdx++) {
29966:       if (aCellsArray[rowIdx][colIdx] == false) {
29126:         isRowSelected = false;
29126:         break;
29126:       }
29126:     }
29126: 
29126:     is(acc.isRowSelected(rowIdx), isRowSelected,
29126:        msg + "Wrong selection state of " + rowIdx + " row for " +
29126:        prettyName(aIdentifier));
29126: 
29126:     if (isRowSelected)
29126:       selRows.push(rowIdx);
29126:   }
29126: 
32387:   // selectedRowCount test
32387:   is(acc.selectedRowCount, selRows.length,
29126:      msg + "Wrong count of selected rows for " + prettyName(aIdentifier));
29126: 
29126:   // getSelectedRows test
32381:   var actualSelrowCountObj = { value: null };
32381:   var actualSelRows = acc.getSelectedRowIndices(actualSelrowCountObj);
29126: 
32381:   var actualSelrowCount = actualSelrowCountObj.value;
32381:   is (actualSelrowCount, selRows.length,
29126:       msg + "Wrong count of selected rows for " + prettyName(aIdentifier) +
29126:       "from getSelectedRows.");
29126: 
32381:   for (var i = 0; i < actualSelrowCount; i++) {
29126:     is (actualSelRows[i], selRows[i],
29126:         msg + "Row at index " + selRows[i] + " should be selected.");
29126:   }
29126: 
29126:   // Cells selection tests.
29126:   var selCells = new Array();
29126: 
29126:   // isCellSelected test
32381:   for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {
29126:     for (var colIdx = 0; colIdx < colsCount; colIdx++) {
32381:       if (aCellsArray[rowIdx][colIdx] & kSpanned)
29966:         continue;
29966: 
29126:       is(acc.isCellSelected(rowIdx, colIdx), aCellsArray[rowIdx][colIdx],
29126:          msg + "Wrong selection state of cell at " + rowIdx + " row and " +
29126:          colIdx + " column for " + prettyName(aIdentifier));
29126: 
29126:       if (aCellsArray[rowIdx][colIdx])
32381:         selCells.push(acc.getCellIndexAt(rowIdx, colIdx));
29126:     }
29126:   }
29126: 
32381:   // selectedCellCount tests
32381:   is(acc.selectedCellCount, selCells.length,
29126:      msg + "Wrong count of selected cells for " + prettyName(aIdentifier));
29126: 
32381:   // getSelectedCellIndices test
29126:   var actualSelCellsCountObj = { value: null };
32381:   var actualSelCells = acc.getSelectedCellIndices(actualSelCellsCountObj);
29126: 
29126:   var actualSelCellsCount = actualSelCellsCountObj.value;
29126:   is(actualSelCellsCount, selCells.length,
29126:      msg + "Wrong count of selected cells for " + prettyName(aIdentifier) +
29126:      "from getSelectedCells.");
29126: 
29126:   for (var i = 0; i < actualSelCellsCount; i++) {
29126:     is(actualSelCells[i], selCells[i],
32381:        msg + "getSelectedCellIndices: Cell at index " + selCells[i] +
32381:        " should be selected.");
32381:   }
32381: 
32381:   // selectedCells and isSelected tests
32381:   var actualSelCellsArray = acc.selectedCells;
32381:   for (var i = 0; i < actualSelCellsCount; i++) {
32381:     var actualSelCellAccessible =
32381:       actualSelCellsArray.queryElementAt(i, nsIAccessibleTableCell);
32381: 
32381:     var colIdx = acc.getColumnIndexAt(selCells[i]);
32381:     var rowIdx = acc.getRowIndexAt(selCells[i]);
32381:     var expectedSelCellAccessible = acc.getCellAt(rowIdx, colIdx);
32381: 
32381:     ok(actualSelCellAccessible, expectedSelCellAccessible,
32381:        msg + "getSelectedCells: Cell at index " + selCells[i] +
32381:        " should be selected.");
32381: 
32381:     ok(actualSelCellAccessible.isSelected(),
32381:        "isSelected: Cell at index " + selCells[i] + " should be selected.");
29126:   }
29929: 
29929:   // selected states tests
32381:   for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {
29929:     for (var colIdx = 0; colIdx < colsCount; colIdx++) {
32381:       if (aCellsArray[rowIdx][colIdx] & kSpanned)
29966:         continue;
29966: 
32381:       var cell = acc.getCellAt(rowIdx, colIdx);
29929:       var isSel = aCellsArray[rowIdx][colIdx];
29929:       if (isSel)
29929:         testStates(cell, STATE_SELECTED);
29929:       else
30059:         testStates(cell, STATE_SELECTABLE, 0, STATE_SELECTED);
29929:     }
29929:   }
29126: }
29126: 
29126: /**
29126:  * Test unselectColumn method of accessible table.
29126:  */
29126: function testUnselectTableColumn(aIdentifier, aColIdx, aCellsArray)
29126: {
29126:   var acc = getAccessible(aIdentifier, [nsIAccessibleTable]);
29126:   if (!acc)
29126:     return;
29126: 
32381:   var rowCount = aCellsArray.length;
32381:   for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {
32354:     var cellState = aCellsArray[rowIdx][aColIdx];
32354:     // Unselect origin cell.
32354:     var [origRowIdx, origColIdx] =
32354:       getOrigRowAndColumn(aCellsArray, rowIdx, aColIdx);
32354:     aCellsArray[origRowIdx][origColIdx] = false;
29966:   }
29126: 
29126:   acc.unselectColumn(aColIdx);
29126:   testTableSelection(aIdentifier, aCellsArray,
29126:                      "Unselect " + aColIdx + " column: ");
29126: }
29126: 
29126: /**
29126:  * Test selectColumn method of accessible table.
29126:  */
29126: function testSelectTableColumn(aIdentifier, aColIdx, aCellsArray)
29126: {
29126:   var acc = getAccessible(aIdentifier, [nsIAccessibleTable]);
29126:   if (!acc)
29126:     return;
29126: 
32381:   var rowCount = aCellsArray.length;
29126:   var colsCount = aCellsArray[0].length;
29126: 
32381:   for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {
29966:     for (var colIdx = 0; colIdx < colsCount; colIdx++) {
32354:       var cellState = aCellsArray[rowIdx][colIdx];
32354: 
32354:       if (colIdx == aColIdx) { // select target column
32381:         if (!(cellState & kSpanned)) {
32354:           // Select the cell if it is origin.
32354:           aCellsArray[rowIdx][colIdx] = true;
32354: 
32354:         } else {
32354:           // If the cell is spanned then search origin cell and select it.
32354:           var [origRowIdx, origColIdx] = getOrigRowAndColumn(aCellsArray,
32354:                                                              rowIdx, colIdx);
32354:           aCellsArray[origRowIdx][origColIdx] = true;
32354:         }
32354: 
32381:       } else if (!(cellState & kSpanned)) { // unselect other columns
32354:         if (colIdx > aColIdx) {
32354:           // Unselect the cell if traversed column index is greater than column
32354:           // index of target cell.
32354:           aCellsArray[rowIdx][colIdx] = false;
32354: 
32381:         } else if (!(aCellsArray[rowIdx][aColIdx] & kColSpanned)) {
32354:           // Unselect the cell if the target cell is not row spanned.
32354:           aCellsArray[rowIdx][colIdx] = false;
32354: 
32354:         } else {
32354:           // Unselect the cell if it is not spanned to the target cell.
32354:           for (var spannedColIdx = colIdx + 1; spannedColIdx < aColIdx;
32354:                spannedColIdx++) {
32354:             var spannedCellState = aCellsArray[rowIdx][spannedColIdx];
32381:             if (!(spannedCellState & kRowSpanned)) {
32354:               aCellsArray[rowIdx][colIdx] = false;
32354:               break;
32354:             }
32354:           }
32354:         }
32354:       }
29126:     }
29966:   }
29126: 
29126:   acc.selectColumn(aColIdx);
29126:   testTableSelection(aIdentifier, aCellsArray,
29126:                      "Select " + aColIdx + " column: ");
29126: }
29126: 
29126: /**
29126:  * Test unselectRow method of accessible table.
29126:  */
29126: function testUnselectTableRow(aIdentifier, aRowIdx, aCellsArray)
29126: {
29126:   var acc = getAccessible(aIdentifier, [nsIAccessibleTable]);
29126:   if (!acc)
29126:     return;
29126: 
29126:   var colsCount = aCellsArray[0].length;
29966:   for (var colIdx = 0; colIdx < colsCount; colIdx++) {
32354:     // Unselect origin cell.
32354:     var [origRowIdx, origColIdx] = getOrigRowAndColumn(aCellsArray,
32354:                                                        aRowIdx, colIdx);
32354:     aCellsArray[origRowIdx][origColIdx] = false;
29966:   }
29126: 
29126:   acc.unselectRow(aRowIdx);
29126:   testTableSelection(aIdentifier, aCellsArray,
29126:                      "Unselect " + aRowIdx + " row: ");
29126: }
29126: 
29126: /**
29126:  * Test selectRow method of accessible table.
29126:  */
30059: function testSelectTableRow(aIdentifier, aRowIdx, aCellsArray)
29126: {
29126:   var acc = getAccessible(aIdentifier, [nsIAccessibleTable]);
29126:   if (!acc)
29126:     return;
29126: 
32381:   var rowCount = aCellsArray.length;
29126:   var colsCount = aCellsArray[0].length;
29126: 
32381:   for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {
29966:     for (var colIdx = 0; colIdx < colsCount; colIdx++) {
32354:       var cellState = aCellsArray[rowIdx][colIdx];
32354: 
32354:       if (rowIdx == aRowIdx) { // select the given row
32381:         if (!(cellState & kSpanned)) {
32354:           // Select the cell if it is origin.
32354:           aCellsArray[rowIdx][colIdx] = true;
32354: 
32354:         } else {
32354:           // If the cell is spanned then search origin cell and select it.
32354:           var [origRowIdx, origColIdx] = getOrigRowAndColumn(aCellsArray,
32354:                                                              rowIdx, colIdx);
32354: 
32354:           aCellsArray[origRowIdx][origColIdx] = true;
32354:         }
32354: 
32381:       } else if (!(cellState & kSpanned)) { // unselect other rows
32354:         if (rowIdx > aRowIdx) {
32354:           // Unselect the cell if traversed row index is greater than row
32354:           // index of target cell.
32354:           aCellsArray[rowIdx][colIdx] = false;
32354: 
32381:         } else if (!(aCellsArray[aRowIdx][colIdx] & kRowSpanned)) {
32354:           // Unselect the cell if the target cell is not row spanned.
32354:           aCellsArray[rowIdx][colIdx] = false;
32354: 
32354:         } else {
32354:           // Unselect the cell if it is not spanned to the target cell.
32354:           for (var spannedRowIdx = rowIdx + 1; spannedRowIdx < aRowIdx;
32354:                spannedRowIdx++) {
32354:             var spannedCellState = aCellsArray[spannedRowIdx][colIdx];
32381:             if (!(spannedCellState & kRowSpanned)) {
32354:               aCellsArray[rowIdx][colIdx] = false;
32354:               break;
32354:             }
32354:           }
32354:         }
32354:       }
29126:     }
29966:   }
29126: 
29126:   acc.selectRow(aRowIdx);
29126:   testTableSelection(aIdentifier, aCellsArray,
30059:                      "Select " + aRowIdx + " row: ");
29126: }
32354: 
32381: /**
32381:  * Test columnHeaderCells and rowHeaderCells of accessible table.
32381:  */
32381: function testHeaderCells(aHeaderInfoMap)
32381: {
32381:   for (var testIdx = 0; testIdx < aHeaderInfoMap.length; testIdx++) {
32381:     var dataCellIdentifier = aHeaderInfoMap[testIdx].cell;
32381:     var dataCell = getAccessible(dataCellIdentifier, [nsIAccessibleTableCell]);
32381: 
32381:     // row header cells
32381:     var rowHeaderCells = aHeaderInfoMap[testIdx].rowHeaderCells;
32381:     var rowHeaderCellsCount = rowHeaderCells.length;
32381:     var actualRowHeaderCells = dataCell.rowHeaderCells;
32381:     var actualRowHeaderCellsCount = actualRowHeaderCells.length;
32381: 
32381:     is(actualRowHeaderCellsCount, rowHeaderCellsCount,
32381:        "Wrong number of row header cells for the cell " +
32381:        prettyName(dataCellIdentifier));
32381: 
32381:     if (actualRowHeaderCellsCount == rowHeaderCellsCount) {
32381:       for (var idx = 0; idx < rowHeaderCellsCount; idx++) {
32381:         var rowHeaderCell = getAccessible(rowHeaderCells[idx]);
32381:         var actualRowHeaderCell =
32381:           actualRowHeaderCells.queryElementAt(idx, nsIAccessible);
32381:         ok(actualRowHeaderCell, rowHeaderCell,
32381:            "Wrong row header cell at index " + idx + " for the cell " +
32381:            prettyName(rowHeaderCells[idx]));
32381:       }
32381:     }
32381: 
32381:     // column header cells
32381:     var colHeaderCells = aHeaderInfoMap[testIdx].columnHeaderCells;
32381:     var colHeaderCellsCount = colHeaderCells.length;
32381:     var actualColHeaderCells = dataCell.columnHeaderCells;
32381:     var actualColHeaderCellsCount = actualColHeaderCells.length;
32381: 
32381:     is(actualColHeaderCellsCount, colHeaderCellsCount,
32381:        "Wrong number of column header cells for the cell " +
32381:        prettyName(dataCellIdentifier));
32381: 
32381:     if (actualColHeaderCellsCount == colHeaderCellsCount) {
32381:       for (var idx = 0; idx < colHeaderCellsCount; idx++) {
32381:         var colHeaderCell = getAccessible(colHeaderCells[idx]);
32381:         var actualColHeaderCell =
32381:           actualColHeaderCells.queryElementAt(idx, nsIAccessible);
32381:         ok(actualColHeaderCell, colHeaderCell,
32381:            "Wrong column header cell at index " + idx + " for the cell " +
32381:            prettyName(colHeaderCells[idx]));
32381:       }
32381:     }
32381:   }
32381: }
32381: 
32354: ////////////////////////////////////////////////////////////////////////////////
32354: // private implementation
32354: 
32354: /**
32354:  * Return row and column of orig cell for the given spanned cell.
32354:  */
32354: function getOrigRowAndColumn(aCellsArray, aRowIdx, aColIdx)
32354: {
32354:   var cellState = aCellsArray[aRowIdx][aColIdx];
32354: 
32354:   var origRowIdx = aRowIdx, origColIdx = aColIdx;
32381:   if (cellState & kRowSpanned) {
32354:     for (var prevRowIdx = aRowIdx - 1; prevRowIdx >= 0; prevRowIdx--) {
32354:       var prevCellState = aCellsArray[prevRowIdx][aColIdx];
32381:       if (!(prevCellState & kRowSpanned)) {
32354:         origRowIdx = prevRowIdx;
32354:         break;
32354:       }
32354:     }
32354:   }
32354: 
32381:   if (cellState & kColSpanned) {
32354:     for (var prevColIdx = aColIdx - 1; prevColIdx >= 0; prevColIdx--) {
32354:       var prevCellState = aCellsArray[aRowIdx][prevColIdx];
32381:       if (!(prevCellState & kColSpanned)) {
32354:         origColIdx = prevColIdx;
32354:         break;
32354:       }
32354:     }
32354:   }
32354: 
32354:   return [origRowIdx, origColIdx];
32354: }
