29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JavaScript API.
    1:  */
    1: #include <ctype.h>
    1: #include <stdarg.h>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsarena.h"
55477: #include "jsutil.h"
    1: #include "jsclist.h"
    1: #include "jsdhash.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
20408: #include "jsbuiltins.h"
54863: #include "jsclone.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdate.h"
    1: #include "jsemit.h"
    1: #include "jsexn.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
 6464: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsmath.h"
    1: #include "jsnum.h"
20092: #include "json.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
42733: #include "jsproxy.h"
    1: #include "jsregexp.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
24499: #include "jstracer.h"
22652: #include "jsdbgapi.h"
    1: #include "prmjtime.h"
18989: #include "jsstaticcheck.h"
31819: #include "jsvector.h"
47498: #include "jswrapper.h"
37042: #include "jstypedarray.h"
    1: 
34349: #include "jsatominlines.h"
42714: #include "jscntxtinlines.h"
53840: #include "jsinterpinlines.h"
48470: #include "jsobjinlines.h"
34349: #include "jsscopeinlines.h"
48470: #include "jscntxtinlines.h"
50491: #include "jsregexpinlines.h"
50493: #include "assembler/wtf/Platform.h"
50493: 
50493: #if ENABLE_YARR_JIT
50491: #include "assembler/jit/ExecutableAllocator.h"
50491: #include "methodjit/Logging.h"
50493: #endif
34349: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
53848: class AutoVersionAPI
53848: {
53848:     JSContext   * const cx;
53848:     JSVersion   oldVersion;
53848:     bool        oldVersionWasOverride;
53848:     uint32      oldOptions;
53848: 
53848:   public:
53848:     explicit AutoVersionAPI(JSContext *cx, JSVersion newVersion)
53848:       : cx(cx), oldVersion(cx->findVersion()), oldVersionWasOverride(cx->isVersionOverridden()),
53848:         oldOptions(cx->options) {
53848:         JS_ASSERT(!VersionExtractFlags(newVersion) ||
53848:                   VersionExtractFlags(newVersion) == VersionFlags::HAS_XML);
53848:         cx->options = VersionHasXML(newVersion)
53848:                       ? (cx->options | JSOPTION_XML)
53848:                       : (cx->options & ~JSOPTION_XML);
53848:         cx->maybeOverrideVersion(newVersion);
53848:         SyncOptionsToVersion(cx);
53848:     }
53848: 
53848:     ~AutoVersionAPI() {
53848:         cx->options = oldOptions;
53848:         if (oldVersionWasOverride) {
53848:             JS_ALWAYS_TRUE(cx->maybeOverrideVersion(oldVersion));
53848:         } else {
53848:             cx->clearVersionOverride();
53848:             cx->setDefaultVersion(oldVersion);
53848:         }
53848:         JS_ASSERT(cx->findVersion() == oldVersion);
53848:     }
53848: };
53848: 
    1: #ifdef HAVE_VA_LIST_AS_ARRAY
    1: #define JS_ADDRESSOF_VA_LIST(ap) ((va_list *)(ap))
    1: #else
    1: #define JS_ADDRESSOF_VA_LIST(ap) (&(ap))
    1: #endif
    1: 
48470: #ifdef JS_USE_JSVAL_JSID_STRUCT_TYPES
52503: JS_PUBLIC_DATA(jsid) JS_DEFAULT_XML_NAMESPACE_ID = { size_t(JSID_TYPE_DEFAULT_XML_NAMESPACE) };
52503: JS_PUBLIC_DATA(jsid) JSID_VOID  = { size_t(JSID_TYPE_VOID) };
52503: JS_PUBLIC_DATA(jsid) JSID_EMPTY = { size_t(JSID_TYPE_OBJECT) };
48470: #endif
48470: 
48470: #ifdef JS_USE_JSVAL_JSID_STRUCT_TYPES
48470: JS_PUBLIC_DATA(jsval) JSVAL_NULL  = { BUILD_JSVAL(JSVAL_TAG_NULL,      0) };
48470: JS_PUBLIC_DATA(jsval) JSVAL_ZERO  = { BUILD_JSVAL(JSVAL_TAG_INT32,     0) };
48470: JS_PUBLIC_DATA(jsval) JSVAL_ONE   = { BUILD_JSVAL(JSVAL_TAG_INT32,     1) };
48470: JS_PUBLIC_DATA(jsval) JSVAL_FALSE = { BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   JS_FALSE) };
48470: JS_PUBLIC_DATA(jsval) JSVAL_TRUE  = { BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   JS_TRUE) };
48470: JS_PUBLIC_DATA(jsval) JSVAL_VOID  = { BUILD_JSVAL(JSVAL_TAG_UNDEFINED, 0) };
48470: #endif
25901: 
48540: /* Make sure that jschar is two bytes unsigned integer */
48540: JS_STATIC_ASSERT((jschar)-1 > 0);
48540: JS_STATIC_ASSERT(sizeof(jschar) == 2);
48540: 
    1: JS_PUBLIC_API(int64)
    1: JS_Now()
    1: {
    1:     return PRMJ_Now();
    1: }
    1: 
    1: JS_PUBLIC_API(jsval)
    1: JS_GetNaNValue(JSContext *cx)
    1: {
48470:     return Jsvalify(cx->runtime->NaNValue);
    1: }
    1: 
    1: JS_PUBLIC_API(jsval)
    1: JS_GetNegativeInfinityValue(JSContext *cx)
    1: {
48470:     return Jsvalify(cx->runtime->negativeInfinityValue);
    1: }
    1: 
    1: JS_PUBLIC_API(jsval)
    1: JS_GetPositiveInfinityValue(JSContext *cx)
    1: {
48470:     return Jsvalify(cx->runtime->positiveInfinityValue);
    1: }
    1: 
    1: JS_PUBLIC_API(jsval)
    1: JS_GetEmptyStringValue(JSContext *cx)
    1: {
    1:     return STRING_TO_JSVAL(cx->runtime->emptyString);
    1: }
    1: 
    1: static JSBool
43229: TryArgumentFormatter(JSContext *cx, const char **formatp, JSBool fromJS, jsval **vpp, va_list *app)
    1: {
    1:     const char *format;
    1:     JSArgumentFormatMap *map;
    1: 
    1:     format = *formatp;
    1:     for (map = cx->argumentFormatMap; map; map = map->next) {
    1:         if (!strncmp(format, map->format, map->length)) {
    1:             *formatp = format + map->length;
    1:             return map->formatter(cx, format, fromJS, vpp, app);
    1:         }
    1:     }
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_CHAR, format);
    1:     return JS_FALSE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_ConvertArguments(JSContext *cx, uintN argc, jsval *argv, const char *format, ...)
    1: {
    1:     va_list ap;
    1:     JSBool ok;
    1: 
    1:     va_start(ap, format);
    1:     ok = JS_ConvertArgumentsVA(cx, argc, argv, format, ap);
    1:     va_end(ap);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_ConvertArgumentsVA(JSContext *cx, uintN argc, jsval *argv, const char *format, va_list ap)
    1: {
    1:     jsval *sp;
    1:     JSBool required;
    1:     char c;
    1:     JSFunction *fun;
    1:     jsdouble d;
    1:     JSString *str;
    1:     JSObject *obj;
    1: 
    1:     CHECK_REQUEST(cx);
48470:     assertSameCompartment(cx, JSValueArray(argv - 2, argc + 2));
    1:     sp = argv;
    1:     required = JS_TRUE;
    1:     while ((c = *format++) != '\0') {
    1:         if (isspace(c))
    1:             continue;
    1:         if (c == '/') {
    1:             required = JS_FALSE;
    1:             continue;
    1:         }
    1:         if (sp == argv + argc) {
    1:             if (required) {
48470:                 fun = js_ValueToFunction(cx, Valueify(&argv[-2]), 0);
    1:                 if (fun) {
    1:                     char numBuf[12];
    1:                     JS_snprintf(numBuf, sizeof numBuf, "%u", argc);
57786:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
57786:                                          JSMSG_MORE_ARGS_NEEDED,
57786:                                          JS_GetFunctionName(fun), numBuf,
57786:                                          (argc == 1) ? "" : "s");
    1:                 }
    1:                 return JS_FALSE;
    1:             }
    1:             break;
    1:         }
    1:         switch (c) {
    1:           case 'b':
48470:             *va_arg(ap, JSBool *) = js_ValueToBoolean(Valueify(*sp));
    1:             break;
    1:           case 'c':
12694:             if (!JS_ValueToUint16(cx, *sp, va_arg(ap, uint16 *)))
    1:                 return JS_FALSE;
    1:             break;
    1:           case 'i':
12681:             if (!JS_ValueToECMAInt32(cx, *sp, va_arg(ap, int32 *)))
    1:                 return JS_FALSE;
    1:             break;
    1:           case 'u':
12681:             if (!JS_ValueToECMAUint32(cx, *sp, va_arg(ap, uint32 *)))
    1:                 return JS_FALSE;
    1:             break;
    1:           case 'j':
12694:             if (!JS_ValueToInt32(cx, *sp, va_arg(ap, int32 *)))
    1:                 return JS_FALSE;
    1:             break;
    1:           case 'd':
12694:             if (!JS_ValueToNumber(cx, *sp, va_arg(ap, jsdouble *)))
    1:                 return JS_FALSE;
    1:             break;
    1:           case 'I':
12694:             if (!JS_ValueToNumber(cx, *sp, &d))
    1:                 return JS_FALSE;
    1:             *va_arg(ap, jsdouble *) = js_DoubleToInteger(d);
    1:             break;
    1:           case 's':
    1:           case 'S':
    1:           case 'W':
48470:             str = js_ValueToString(cx, Valueify(*sp));
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             *sp = STRING_TO_JSVAL(str);
    1:             if (c == 's') {
    1:                 const char *bytes = js_GetStringBytes(cx, str);
    1:                 if (!bytes)
    1:                     return JS_FALSE;
    1:                 *va_arg(ap, const char **) = bytes;
    1:             } else if (c == 'W') {
    1:                 const jschar *chars = js_GetStringChars(cx, str);
    1:                 if (!chars)
    1:                     return JS_FALSE;
    1:                 *va_arg(ap, const jschar **) = chars;
    1:             } else {
    1:                 *va_arg(ap, JSString **) = str;
    1:             }
    1:             break;
    1:           case 'o':
48470:             if (!js_ValueToObjectOrNull(cx, Valueify(*sp), &obj))
    1:                 return JS_FALSE;
    1:             *sp = OBJECT_TO_JSVAL(obj);
    1:             *va_arg(ap, JSObject **) = obj;
    1:             break;
    1:           case 'f':
48470:             obj = js_ValueToFunctionObject(cx, Valueify(sp), 0);
    1:             if (!obj)
    1:                 return JS_FALSE;
10574:             *sp = OBJECT_TO_JSVAL(obj);
31452:             *va_arg(ap, JSFunction **) = GET_FUNCTION_PRIVATE(cx, obj);
    1:             break;
    1:           case 'v':
    1:             *va_arg(ap, jsval *) = *sp;
    1:             break;
    1:           case '*':
    1:             break;
    1:           default:
    1:             format--;
    1:             if (!TryArgumentFormatter(cx, &format, JS_TRUE, &sp,
    1:                                       JS_ADDRESSOF_VA_LIST(ap))) {
    1:                 return JS_FALSE;
    1:             }
    1:             /* NB: the formatter already updated sp, so we continue here. */
    1:             continue;
    1:         }
    1:         sp++;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_AddArgumentFormatter(JSContext *cx, const char *format, JSArgumentFormatter formatter)
    1: {
    1:     size_t length;
    1:     JSArgumentFormatMap **mpp, *map;
    1: 
    1:     length = strlen(format);
    1:     mpp = &cx->argumentFormatMap;
    1:     while ((map = *mpp) != NULL) {
    1:         /* Insert before any shorter string to match before prefixes. */
    1:         if (map->length < length)
    1:             break;
    1:         if (map->length == length && !strcmp(map->format, format))
    1:             goto out;
    1:         mpp = &map->next;
    1:     }
30851:     map = (JSArgumentFormatMap *) cx->malloc(sizeof *map);
    1:     if (!map)
    1:         return JS_FALSE;
    1:     map->format = format;
    1:     map->length = length;
    1:     map->next = *mpp;
    1:     *mpp = map;
    1: out:
    1:     map->formatter = formatter;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_RemoveArgumentFormatter(JSContext *cx, const char *format)
    1: {
    1:     size_t length;
    1:     JSArgumentFormatMap **mpp, *map;
    1: 
    1:     length = strlen(format);
    1:     mpp = &cx->argumentFormatMap;
    1:     while ((map = *mpp) != NULL) {
    1:         if (map->length == length && !strcmp(map->format, format)) {
    1:             *mpp = map->next;
30851:             cx->free(map);
    1:             return;
    1:         }
    1:         mpp = &map->next;
    1:     }
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ConvertValue(JSContext *cx, jsval v, JSType type, jsval *vp)
    1: {
10449:     JSBool ok;
    1:     JSObject *obj;
    1:     JSString *str;
48470:     jsdouble d;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
    1:     switch (type) {
    1:       case JSTYPE_VOID:
    1:         *vp = JSVAL_VOID;
    1:         ok = JS_TRUE;
    1:         break;
    1:       case JSTYPE_OBJECT:
48470:         ok = js_ValueToObjectOrNull(cx, Valueify(v), &obj);
    1:         if (ok)
    1:             *vp = OBJECT_TO_JSVAL(obj);
    1:         break;
    1:       case JSTYPE_FUNCTION:
    1:         *vp = v;
48470:         obj = js_ValueToFunctionObject(cx, Valueify(vp), JSV2F_SEARCH_STACK);
    1:         ok = (obj != NULL);
    1:         break;
    1:       case JSTYPE_STRING:
48470:         str = js_ValueToString(cx, Valueify(v));
    1:         ok = (str != NULL);
    1:         if (ok)
    1:             *vp = STRING_TO_JSVAL(str);
    1:         break;
    1:       case JSTYPE_NUMBER:
12694:         ok = JS_ValueToNumber(cx, v, &d);
    1:         if (ok)
48470:             *vp = DOUBLE_TO_JSVAL(d);
    1:         break;
    1:       case JSTYPE_BOOLEAN:
48470:         *vp = BOOLEAN_TO_JSVAL(js_ValueToBoolean(Valueify(v)));
10449:         return JS_TRUE;
    1:       default: {
    1:         char numBuf[12];
    1:         JS_snprintf(numBuf, sizeof numBuf, "%d", (int)type);
43229:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_TYPE, numBuf);
    1:         ok = JS_FALSE;
    1:         break;
    1:       }
    1:     }
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToObject(JSContext *cx, jsval v, JSObject **objp)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
48470:     return js_ValueToObjectOrNull(cx, Valueify(v), objp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_ValueToFunction(JSContext *cx, jsval v)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
48470:     return js_ValueToFunction(cx, Valueify(&v), JSV2F_SEARCH_STACK);
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_ValueToConstructor(JSContext *cx, jsval v)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
48470:     return js_ValueToFunction(cx, Valueify(&v), JSV2F_SEARCH_STACK);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_ValueToString(JSContext *cx, jsval v)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
48470:     return js_ValueToString(cx, Valueify(v));
    1: }
    1: 
21482: JS_PUBLIC_API(JSString *)
21482: JS_ValueToSource(JSContext *cx, jsval v)
21482: {
21482:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
48470:     return js_ValueToSource(cx, Valueify(v));
21482: }
21482: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToNumber(JSContext *cx, jsval v, jsdouble *dp)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
33178: 
48470:     AutoValueRooter tvr(cx, Valueify(v));
48470:     return ValueToNumber(cx, tvr.value(), dp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
39905: JS_DoubleIsInt32(jsdouble d, jsint *ip)
39905: {
48470:     return JSDOUBLE_IS_INT32(d, (int32_t *)ip);
39905: }
39905: 
39905: JS_PUBLIC_API(JSBool)
    1: JS_ValueToECMAInt32(JSContext *cx, jsval v, int32 *ip)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
33178: 
48470:     AutoValueRooter tvr(cx, Valueify(v));
48470:     return ValueToECMAInt32(cx, tvr.value(), (int32_t *)ip);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToECMAUint32(JSContext *cx, jsval v, uint32 *ip)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
33178: 
48470:     AutoValueRooter tvr(cx, Valueify(v));
48470:     return ValueToECMAUint32(cx, tvr.value(), (uint32_t *)ip);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToInt32(JSContext *cx, jsval v, int32 *ip)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
33178: 
48470:     AutoValueRooter tvr(cx, Valueify(v));
48470:     return ValueToInt32(cx, tvr.value(), (int32_t *)ip);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToUint16(JSContext *cx, jsval v, uint16 *ip)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
33178: 
48470:     AutoValueRooter tvr(cx, Valueify(v));
48470:     return ValueToUint16(cx, tvr.value(), (uint16_t *)ip);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToBoolean(JSContext *cx, jsval v, JSBool *bp)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
48470:     *bp = js_ValueToBoolean(Valueify(v));
10449:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSType)
    1: JS_TypeOfValue(JSContext *cx, jsval v)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
48470:     return TypeOfValue(cx, Valueify(v));
    1: }
    1: 
    1: JS_PUBLIC_API(const char *)
    1: JS_GetTypeName(JSContext *cx, JSType type)
    1: {
    1:     if ((uintN)type >= (uintN)JSTYPE_LIMIT)
    1:         return NULL;
 4342:     return JS_TYPE_STR(type);
    1: }
    1: 
28408: JS_PUBLIC_API(JSBool)
28408: JS_StrictlyEqual(JSContext *cx, jsval v1, jsval v2)
28408: {
47485:     assertSameCompartment(cx, v1, v2);
48470:     return StrictlyEqual(cx, Valueify(v1), Valueify(v2));
28408: }
28408: 
32760: JS_PUBLIC_API(JSBool)
32760: JS_SameValue(JSContext *cx, jsval v1, jsval v2)
32760: {
47485:     assertSameCompartment(cx, v1, v2);
48470:     return SameValue(Valueify(v1), Valueify(v2), cx);
32760: }
32760: 
    1: /************************************************************************/
    1: 
 8893: /*
 8893:  * Has a new runtime ever been created?  This flag is used to detect unsafe
 8893:  * changes to js_CStringsAreUTF8 after a runtime has been created, and to
 8893:  * ensure that "first checks" on runtime creation are run only once.
 8893:  */
 8893: #ifdef DEBUG
 8893: static JSBool js_NewRuntimeWasCalled = JS_FALSE;
 8893: #endif
 8893: 
34299: JSRuntime::JSRuntime()
47400:   : gcChunkAllocator(&defaultGCChunkAllocator)
34299: {
34299:     /* Initialize infallibly first, so we can goto bad and JS_DestroyRuntime. */
34299:     JS_INIT_CLIST(&contextList);
34299:     JS_INIT_CLIST(&trapList);
34299:     JS_INIT_CLIST(&watchPointList);
34299: }
34299: 
34299: bool
34299: JSRuntime::init(uint32 maxbytes)
34299: {
50491: #ifdef JS_METHODJIT_SPEW
50491:     JMCheckLogging();
50491: #endif
50491: 
48676: #ifdef DEBUG
48676:     functionMeterFilename = getenv("JS_FUNCTION_STATFILE");
48676:     if (functionMeterFilename) {
48676:         if (!methodReadBarrierCountMap.init())
48676:             return false;
48676:         if (!unjoinedFunctionCountMap.init())
48676:             return false;
48676:     }
52503:     propTreeStatFilename = getenv("JS_PROPTREE_STATFILE");
52503:     propTreeDumpFilename = getenv("JS_PROPTREE_DUMPFILE");
52503:     if (meterEmptyShapes()) {
52503:         if (!emptyShapes.init())
52503:             return false;
52503:     }
48676: #endif
48676: 
47498:     if (!(defaultCompartment = new JSCompartment(this)) ||
49094:         !defaultCompartment->init() ||
49094:         !compartments.append(defaultCompartment)) {
43286:         return false;
47498:     }
43286: 
40339:     if (!js_InitGC(this, maxbytes) || !js_InitAtomState(this))
34299:         return false;
40281: 
50491: #if ENABLE_YARR_JIT
57810:     regExpAllocator = JSC::ExecutableAllocator::create();
50491:     if (!regExpAllocator)
50491:         return false;
50491: #endif
50491: 
56578:     deflatedStringCache = new js::DeflatedStringCache();
56578:     if (!deflatedStringCache || !deflatedStringCache->init())
56578:         return false;
56578: 
47516:     wrapObjectCallback = js::TransparentObjectWrapper;
47516: 
34299: #ifdef JS_THREADSAFE
34299:     /* this is asymmetric with JS_ShutDown: */
34299:     if (!js_SetupLocks(8, 16))
34299:         return false;
34299:     rtLock = JS_NEW_LOCK();
34299:     if (!rtLock)
34299:         return false;
34299:     stateChange = JS_NEW_CONDVAR(gcLock);
34299:     if (!stateChange)
34299:         return false;
34299:     debuggerLock = JS_NEW_LOCK();
34299:     if (!debuggerLock)
34299:         return false;
34299: #endif
56783: 
56783:     debugMode = JS_FALSE;
56783: 
40327:     return propertyTree.init() && js_InitThreads(this);
34299: }
34299: 
34299: JSRuntime::~JSRuntime()
34299: {
34299: #ifdef DEBUG
34299:     /* Don't hurt everyone in leaky ol' Mozilla with a fatal JS_ASSERT! */
34299:     if (!JS_CLIST_IS_EMPTY(&contextList)) {
34299:         JSContext *cx, *iter = NULL;
34299:         uintN cxcount = 0;
34299:         while ((cx = js_ContextIterator(this, JS_TRUE, &iter)) != NULL) {
34299:             fprintf(stderr,
34299: "JS API usage error: found live context at %p\n",
34299:                     (void *) cx);
34299:             cxcount++;
34299:         }
34299:         fprintf(stderr,
34299: "JS API usage error: %u context%s left in runtime upon JS_DestroyRuntime.\n",
34299:                 cxcount, (cxcount == 1) ? "" : "s");
34299:     }
34299: #endif
34299: 
34299:     js_FinishThreads(this);
34299:     js_FreeRuntimeScriptState(this);
34299:     js_FinishAtomState(this);
34299: 
56578:     /*
56578:      * Finish the deflated string cache after the last GC and after
56578:      * calling js_FinishAtomState, which finalizes strings.
56578:      */
56578:     delete deflatedStringCache;
50491: #if ENABLE_YARR_JIT
50491:     delete regExpAllocator;
50491: #endif
34299:     js_FinishGC(this);
34299: #ifdef JS_THREADSAFE
34299:     if (gcLock)
34299:         JS_DESTROY_LOCK(gcLock);
34299:     if (gcDone)
34299:         JS_DESTROY_CONDVAR(gcDone);
34299:     if (requestDone)
34299:         JS_DESTROY_CONDVAR(requestDone);
34299:     if (rtLock)
34299:         JS_DESTROY_LOCK(rtLock);
34299:     if (stateChange)
34299:         JS_DESTROY_CONDVAR(stateChange);
34299:     if (debuggerLock)
34299:         JS_DESTROY_LOCK(debuggerLock);
34299: #endif
40327:     propertyTree.finish();
34299: }
34299: 
    1: JS_PUBLIC_API(JSRuntime *)
    1: JS_NewRuntime(uint32 maxbytes)
    1: {
    1: #ifdef DEBUG
 8893:     if (!js_NewRuntimeWasCalled) {
    1:         /*
    1:          * This code asserts that the numbers associated with the error names
    1:          * in jsmsg.def are monotonically increasing.  It uses values for the
    1:          * error names enumerated in jscntxt.c.  It's not a compile-time check
    1:          * but it's better than nothing.
    1:          */
    1:         int errorNumber = 0;
    1: #define MSG_DEF(name, number, count, exception, format)                       \
    1:     JS_ASSERT(name == errorNumber++);
    1: #include "js.msg"
    1: #undef MSG_DEF
    1: 
    1: #define MSG_DEF(name, number, count, exception, format)                       \
    1:     JS_BEGIN_MACRO                                                            \
    1:         uintN numfmtspecs = 0;                                                \
    1:         const char *fmt;                                                      \
    1:         for (fmt = format; *fmt != '\0'; fmt++) {                             \
    1:             if (*fmt == '{' && isdigit(fmt[1]))                               \
    1:                 ++numfmtspecs;                                                \
    1:         }                                                                     \
    1:         JS_ASSERT(count == numfmtspecs);                                      \
    1:     JS_END_MACRO;
    1: #include "js.msg"
    1: #undef MSG_DEF
    1: 
 8893:         js_NewRuntimeWasCalled = JS_TRUE;
    1:     }
    1: #endif /* DEBUG */
    1: 
34299:     void *mem = js_calloc(sizeof(JSRuntime));
34299:     if (!mem)
    1:         return NULL;
    1: 
34299:     JSRuntime *rt = new (mem) JSRuntime();
34299:     if (!rt->init(maxbytes)) {
    1:         JS_DestroyRuntime(rt);
    1:         return NULL;
    1:     }
    1: 
34299:     return rt;
34299: }
34299: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyRuntime(JSRuntime *rt)
    1: {
34304:     rt->~JSRuntime();
34304: 
34304:     js_free(rt);
    1: }
    1: 
39932: #ifdef JS_REPRMETER
39932: namespace reprmeter {
39932:     extern void js_DumpReprMeter();
39932: }
39932: #endif
39932: 
    1: JS_PUBLIC_API(void)
    1: JS_ShutDown(void)
    1: {
29368: #ifdef MOZ_TRACEVIS
38585:     StopTraceVis();
29368: #endif
29368: 
    1: #ifdef JS_OPMETER
    1:     extern void js_DumpOpMeters();
    1:     js_DumpOpMeters();
    1: #endif
    1: 
39932: #ifdef JS_REPRMETER
39932:     reprmeter::js_DumpReprMeter();
39932: #endif
39932: 
    1: #ifdef JS_THREADSAFE
    1:     js_CleanupLocks();
    1: #endif
 3531:     PRMJ_NowShutdown();
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetRuntimePrivate(JSRuntime *rt)
    1: {
    1:     return rt->data;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetRuntimePrivate(JSRuntime *rt, void *data)
    1: {
    1:     rt->data = data;
    1: }
    1: 
11277: #ifdef JS_THREADSAFE
53548: static void
53548: StartRequest(JSContext *cx)
53548: {
53548:     JSThread *t = cx->thread;
53548:     JS_ASSERT(CURRENT_THREAD_IS_ME(t));
53548:    
56559:     if (t->data.requestDepth) {
56559:         t->data.requestDepth++;
48481:     } else {
30739:         JSRuntime *rt = cx->runtime;
40840:         AutoLockGC lock(rt);
19699: 
    1:         /* Wait until the GC is finished. */
    1:         if (rt->gcThread != cx->thread) {
42715:             while (rt->gcThread)
    1:                 JS_AWAIT_GC_DONE(rt);
    1:         }
    1: 
    1:         /* Indicate that a request is running. */
48481:         rt->requestCount++;
56559:         t->data.requestDepth = 1;
56559: 
56559:         /*
56559:          * Adjust rt->interruptCounter to reflect any interrupts added while the
56559:          * thread was suspended.
56559:          */
56559:         if (t->data.interruptFlags)
56559:             JS_ATOMIC_INCREMENT(&rt->interruptCounter);
50462: 
50463:         if (rt->requestCount == 1 && rt->activityCallback)
50462:             rt->activityCallback(rt->activityCallbackArg, true);
48481:     }
53548: }
53548: 
47439: static void
47439: StopRequest(JSContext *cx)
47439: {
53548:     JSThread *t = cx->thread;
53548:     JS_ASSERT(CURRENT_THREAD_IS_ME(t));
56559:     JS_ASSERT(t->data.requestDepth != 0);
56559:     if (t->data.requestDepth != 1) {
56559:         t->data.requestDepth--;
48481:     } else {
37741:         LeaveTrace(cx);  /* for GC safety */
27577: 
53548:         t->data.conservativeGC.updateForRequestEnd(t->suspendCount);
53548: 
    1:         /* Lock before clearing to interlock with ClaimScope, in jslock.c. */
53548:         JSRuntime *rt = cx->runtime;
40840:         AutoLockGC lock(rt);
43188: 
56559:         t->data.requestDepth = 0;
56559: 
56559:         /*
56559:          * Adjust rt->interruptCounter to reflect any interrupts added while the
56559:          * thread still had active requests.
56559:          */
56559:         if (t->data.interruptFlags)
56559:             JS_ATOMIC_DECREMENT(&rt->interruptCounter);
 3624: 
    1:         /* Give the GC a chance to run if this was the last request running. */
    1:         JS_ASSERT(rt->requestCount > 0);
    1:         rt->requestCount--;
50462:         if (rt->requestCount == 0) {
    1:             JS_NOTIFY_REQUEST_DONE(rt);
50463:             if (rt->activityCallback)
50462:                 rt->activityCallback(rt->activityCallbackArg, false);
50462:         }
48481:     }
47439: }
53548: #endif /* JS_THREADSAFE */
53548: 
53548: JS_PUBLIC_API(void)
53548: JS_BeginRequest(JSContext *cx)
53548: {
53548: #ifdef JS_THREADSAFE
53548:     cx->outstandingRequests++;
53548:     StartRequest(cx);
47439: #endif
53548: }
47439: 
47439: JS_PUBLIC_API(void)
47439: JS_EndRequest(JSContext *cx)
47439: {
47439: #ifdef JS_THREADSAFE
53548:     JS_ASSERT(cx->outstandingRequests != 0);
53548:     cx->outstandingRequests--;
47439:     StopRequest(cx);
11277: #endif
    1: }
    1: 
    1: /* Yield to pending GC operations, regardless of request depth */
    1: JS_PUBLIC_API(void)
    1: JS_YieldRequest(JSContext *cx)
    1: {
11277: #ifdef JS_THREADSAFE
    1:     CHECK_REQUEST(cx);
11716:     JS_ResumeRequest(cx, JS_SuspendRequest(cx));
11277: #endif
    1: }
    1: 
    1: JS_PUBLIC_API(jsrefcount)
    1: JS_SuspendRequest(JSContext *cx)
    1: {
11277: #ifdef JS_THREADSAFE
53548:     JSThread *t = cx->thread;
53548:     JS_ASSERT(CURRENT_THREAD_IS_ME(t));
53548: 
56559:     jsrefcount saveDepth = t->data.requestDepth;
53548:     if (!saveDepth)
47439:         return 0;
47439: 
53548:     t->suspendCount++;
56559:     t->data.requestDepth = 1;
47439:     StopRequest(cx);
    1:     return saveDepth;
11277: #else
11277:     return 0;
11277: #endif
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ResumeRequest(JSContext *cx, jsrefcount saveDepth)
    1: {
11277: #ifdef JS_THREADSAFE
53548:     JSThread *t = cx->thread;
53548:     JS_ASSERT(CURRENT_THREAD_IS_ME(t));
47439:     if (saveDepth == 0)
47439:         return;
53548:     JS_ASSERT(saveDepth >= 1);
56559:     JS_ASSERT(!t->data.requestDepth);
53548:     JS_ASSERT(t->suspendCount);
53548:     StartRequest(cx);
56559:     t->data.requestDepth = saveDepth;
53548:     t->suspendCount--;
11277: #endif
11277: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_Lock(JSRuntime *rt)
    1: {
    1:     JS_LOCK_RUNTIME(rt);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_Unlock(JSRuntime *rt)
    1: {
    1:     JS_UNLOCK_RUNTIME(rt);
    1: }
    1: 
    1: JS_PUBLIC_API(JSContextCallback)
    1: JS_SetContextCallback(JSRuntime *rt, JSContextCallback cxCallback)
    1: {
    1:     JSContextCallback old;
    1: 
    1:     old = rt->cxCallback;
    1:     rt->cxCallback = cxCallback;
    1:     return old;
    1: }
    1: 
    1: JS_PUBLIC_API(JSContext *)
    1: JS_NewContext(JSRuntime *rt, size_t stackChunkSize)
    1: {
    1:     return js_NewContext(rt, stackChunkSize);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyContext(JSContext *cx)
    1: {
    1:     js_DestroyContext(cx, JSDCM_FORCE_GC);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyContextNoGC(JSContext *cx)
    1: {
    1:     js_DestroyContext(cx, JSDCM_NO_GC);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyContextMaybeGC(JSContext *cx)
    1: {
    1:     js_DestroyContext(cx, JSDCM_MAYBE_GC);
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetContextPrivate(JSContext *cx)
    1: {
    1:     return cx->data;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetContextPrivate(JSContext *cx, void *data)
    1: {
    1:     cx->data = data;
    1: }
    1: 
    1: JS_PUBLIC_API(JSRuntime *)
    1: JS_GetRuntime(JSContext *cx)
    1: {
    1:     return cx->runtime;
    1: }
    1: 
    1: JS_PUBLIC_API(JSContext *)
    1: JS_ContextIterator(JSRuntime *rt, JSContext **iterp)
    1: {
    1:     return js_ContextIterator(rt, JS_TRUE, iterp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSVersion)
    1: JS_GetVersion(JSContext *cx)
    1: {
53848:     return VersionNumber(cx->findVersion());
53848: }
53848: 
53848: static void
53848: CheckOptionVersionSync(JSContext *cx)
53848: {
53848: #if DEBUG
53848:     uint32 options = cx->options;
53848:     JSVersion version = cx->findVersion();
53848:     JS_ASSERT(OptionsHasXML(options) == VersionHasXML(version));
53848: #endif
    1: }
    1: 
    1: JS_PUBLIC_API(JSVersion)
53848: JS_SetVersion(JSContext *cx, JSVersion newVersion)
53848: {
53848:     JS_ASSERT(VersionIsKnown(newVersion));
53848:     JS_ASSERT(!VersionHasFlags(newVersion));
53848:     JSVersion newVersionNumber = newVersion;
53848: 
53848:     JSVersion oldVersion = cx->findVersion();
53848:     JSVersion oldVersionNumber = VersionNumber(oldVersion);
53848:     if (oldVersionNumber == newVersionNumber)
53848:         return oldVersionNumber; /* No override actually occurs! */
53628: 
53628:     /* We no longer support 1.4 or below. */
53848:     if (newVersionNumber != JSVERSION_DEFAULT && newVersionNumber <= JSVERSION_1_4)
53848:         return oldVersionNumber;
53848: 
53848:     VersionCloneFlags(oldVersion, &newVersion);
53848:     cx->maybeOverrideVersion(newVersion);
53848:     CheckOptionVersionSync(cx);
53848:     return oldVersionNumber;
    1: }
    1: 
    1: static struct v2smap {
    1:     JSVersion   version;
    1:     const char  *string;
    1: } v2smap[] = {
    1:     {JSVERSION_1_0,     "1.0"},
    1:     {JSVERSION_1_1,     "1.1"},
    1:     {JSVERSION_1_2,     "1.2"},
    1:     {JSVERSION_1_3,     "1.3"},
    1:     {JSVERSION_1_4,     "1.4"},
    1:     {JSVERSION_ECMA_3,  "ECMAv3"},
    1:     {JSVERSION_1_5,     "1.5"},
    1:     {JSVERSION_1_6,     "1.6"},
    1:     {JSVERSION_1_7,     "1.7"},
 1981:     {JSVERSION_1_8,     "1.8"},
34362:     {JSVERSION_ECMA_5,  "ECMAv5"},
    1:     {JSVERSION_DEFAULT, js_default_str},
    1:     {JSVERSION_UNKNOWN, NULL},          /* must be last, NULL is sentinel */
    1: };
    1: 
    1: JS_PUBLIC_API(const char *)
    1: JS_VersionToString(JSVersion version)
    1: {
    1:     int i;
    1: 
    1:     for (i = 0; v2smap[i].string; i++)
    1:         if (v2smap[i].version == version)
    1:             return v2smap[i].string;
    1:     return "unknown";
    1: }
    1: 
    1: JS_PUBLIC_API(JSVersion)
    1: JS_StringToVersion(const char *string)
    1: {
    1:     int i;
    1: 
    1:     for (i = 0; v2smap[i].string; i++)
    1:         if (strcmp(v2smap[i].string, string) == 0)
    1:             return v2smap[i].version;
    1:     return JSVERSION_UNKNOWN;
    1: }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_GetOptions(JSContext *cx)
    1: {
53848:     /*
53848:      * Can't check option/version synchronization here.
53848:      * We may have been synchronized with a script version that was formerly on
53848:      * the stack, but has now been popped.
53848:      */
    1:     return cx->options;
    1: }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_SetOptions(JSContext *cx, uint32 options)
    1: {
40840:     AutoLockGC lock(cx->runtime);
    1:     uint32 oldopts = cx->options;
    1:     cx->options = options;
53848:     SyncOptionsToVersion(cx);
35331:     cx->updateJITEnabled();
53848:     CheckOptionVersionSync(cx);
    1:     return oldopts;
    1: }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_ToggleOptions(JSContext *cx, uint32 options)
    1: {
40840:     AutoLockGC lock(cx->runtime);
53848:     CheckOptionVersionSync(cx);
    1:     uint32 oldopts = cx->options;
    1:     cx->options ^= options;
53848:     (void) SyncOptionsToVersion(cx);
35331:     cx->updateJITEnabled();
53848:     CheckOptionVersionSync(cx);
    1:     return oldopts;
    1: }
    1: 
    1: JS_PUBLIC_API(const char *)
    1: JS_GetImplementationVersion(void)
    1: {
 6602:     return "JavaScript-C 1.8.0 pre-release 1 2007-10-03";
    1: }
    1: 
48503: JS_PUBLIC_API(JSCompartmentCallback)
48503: JS_SetCompartmentCallback(JSRuntime *rt, JSCompartmentCallback callback)
48503: {
48503:     JSCompartmentCallback old = rt->compartmentCallback;
48503:     rt->compartmentCallback = callback;
48503:     return old;
48503: }
48503: 
47516: JS_PUBLIC_API(JSWrapObjectCallback)
55628: JS_SetWrapObjectCallbacks(JSRuntime *rt,
55628:                           JSWrapObjectCallback callback,
55628:                           JSPreWrapCallback precallback)
55574: {
47516:     JSWrapObjectCallback old = rt->wrapObjectCallback;
47516:     rt->wrapObjectCallback = callback;
55628:     rt->preWrapObjectCallback = precallback;
47516:     return old;
47516: }
47516: 
47498: JS_PUBLIC_API(JSCrossCompartmentCall *)
47498: JS_EnterCrossCompartmentCall(JSContext *cx, JSObject *target)
47498: {
47498:     CHECK_REQUEST(cx);
47498: 
48470:     JS_ASSERT(target);
47498:     AutoCompartment *call = new AutoCompartment(cx, target);
47498:     if (!call)
47498:         return NULL;
47498:     if (!call->enter()) {
47498:         delete call;
47498:         return NULL;
47498:     }
47498:     return reinterpret_cast<JSCrossCompartmentCall *>(call);
47498: }
47498: 
47498: JS_PUBLIC_API(void)
47498: JS_LeaveCrossCompartmentCall(JSCrossCompartmentCall *call)
47498: {
47498:     AutoCompartment *realcall = reinterpret_cast<AutoCompartment *>(call);
47498:     CHECK_REQUEST(realcall->context);
47498:     realcall->leave();
47498:     delete realcall;
47498: }
47498: 
48503: bool
54733: JSAutoEnterCompartment::enter(JSContext *cx, JSObject *target)
48503: {
48503:     JS_ASSERT(!call);
56578:     if (cx->compartment == target->getCompartment()) {
55631:         call = reinterpret_cast<JSCrossCompartmentCall*>(1);
48503:         return true;
55631:     }
48503:     call = JS_EnterCrossCompartmentCall(cx, target);
48503:     return call != NULL;
48503: }
48503: 
54733: void
54733: JSAutoEnterCompartment::enterAndIgnoreErrors(JSContext *cx, JSObject *target)
54733: {
54733:     (void) enter(cx, target);
48503: }
48503: 
48503: JS_PUBLIC_API(void *)
48503: JS_SetCompartmentPrivate(JSContext *cx, JSCompartment *compartment, void *data)
48503: {
48503:     CHECK_REQUEST(cx);
48503:     void *old = compartment->data;
48503:     compartment->data = data;
48503:     return old;
48503: }
48503: 
48503: JS_PUBLIC_API(void *)
48503: JS_GetCompartmentPrivate(JSContext *cx, JSCompartment *compartment)
48503: {
48503:     CHECK_REQUEST(cx);
48503:     return compartment->data;
48503: }
48503: 
51450: JS_PUBLIC_API(JSBool)
51450: JS_WrapObject(JSContext *cx, JSObject **objp)
51450: {
51450:     CHECK_REQUEST(cx);
51450:     return cx->compartment->wrap(cx, objp);
51450: }
51450: 
51450: JS_PUBLIC_API(JSBool)
51450: JS_WrapValue(JSContext *cx, jsval *vp)
51450: {
51450:     CHECK_REQUEST(cx);
51450:     return cx->compartment->wrap(cx, Valueify(vp));
51450: }
51450: 
    1: JS_PUBLIC_API(JSObject *)
55574: JS_TransplantWrapper(JSContext *cx, JSObject *wrapper, JSObject *target)
55574: {
55574:     JS_ASSERT(wrapper->isWrapper());
55574: 
55574:     /*
55574:      * This function is called when a window is navigating. In that case, we
55574:      * need to "move" the window from wrapper's compartment to target's
55574:      * compartment.
55574:      */
56578:     JSCompartment *destination = target->getCompartment();
56578:     if (wrapper->getCompartment() == destination) {
55610:         // If the wrapper is in the same compartment as the destination, then
55610:         // we know that we won't find wrapper in the destination's cross
55610:         // compartment map and that the same object will continue to work.
55746:         if (!wrapper->swap(cx, target))
55746:             return NULL;
55610:         return wrapper;
55610:     }
55574: 
55574:     JSObject *obj;
55574:     WrapperMap &map = destination->crossCompartmentWrappers;
55574:     Value wrapperv = ObjectValue(*wrapper);
55574: 
55574:     // There might already be a wrapper for the window in the new compartment.
55574:     if (WrapperMap::Ptr p = map.lookup(wrapperv)) {
55574:         // If there is, make it the primary outer window proxy around the
55574:         // inner (accomplished by swapping target's innards with the old,
55574:         // possibly security wrapper, innards).
55574:         obj = &p->value.toObject();
55574:         map.remove(p);
55746:         if (!obj->swap(cx, target))
55746:             return NULL;
55574:     } else {
55574:         // Otherwise, this is going to be our outer window proxy in the new
55574:         // compartment.
55574:         obj = target;
55574:     }
55574: 
55574:     // Now, iterate through other scopes looking for references to the old
55574:     // outer window. They need to be updated to point at the new outer window.
55574:     // They also might transition between different types of security wrappers
55574:     // based on whether the new compartment is same origin with them.
55610:     Value targetv = ObjectValue(*obj);
55574:     WrapperVector &vector = cx->runtime->compartments;
55751:     AutoValueVector toTransplant(cx);
55751:     toTransplant.reserve(vector.length());
55751: 
55574:     for (JSCompartment **p = vector.begin(), **end = vector.end(); p != end; ++p) {
55574:         WrapperMap &pmap = (*p)->crossCompartmentWrappers;
55574:         if (WrapperMap::Ptr wp = pmap.lookup(wrapperv)) {
55751:             // We found a wrapper. Remember and root it.
55751:             toTransplant.append(wp->value);
55751:         }
55751:     }
55751: 
55751:     for (Value *begin = toTransplant.begin(), *end = toTransplant.end(); begin != end; ++begin) {
55751:         JSObject *wobj = &begin->toObject();
55751:         JSCompartment *wcompartment = wobj->compartment();
55751:         WrapperMap &pmap = wcompartment->crossCompartmentWrappers;
55751:         JS_ASSERT(pmap.lookup(wrapperv));
55751:         pmap.remove(wrapperv);
55610: 
55574:         // First, we wrap it in the new compartment. This will return a
55574:         // new wrapper.
55752:         AutoCompartment ac(cx, wobj);
55574:         JSObject *tobj = obj;
55752:         if (!ac.enter() || !wcompartment->wrap(cx, &tobj))
55574:             return NULL;
55574: 
55574:         // Now, because we need to maintain object identity, we do a brain
55574:         // transplant on the old object. At the same time, we update the
55574:         // entry in the compartment's wrapper map to point to the old
55610:         // wrapper.
55610:         JS_ASSERT(tobj != wobj);
55746:         if (!wobj->swap(cx, tobj))
55746:             return NULL;
55574:         pmap.put(targetv, ObjectValue(*wobj));
55610:     }
55610: 
55610:     // Lastly, update the old outer window proxy to point to the new one.
55610:     {
55752:         AutoCompartment ac(cx, wrapper);
55610:         JSObject *tobj = obj;
55752:         if (!ac.enter() || !JS_WrapObject(cx, &tobj))
55610:             return NULL;
55746:         if (!wrapper->swap(cx, tobj))
55746:             return NULL;
56578:         wrapper->getCompartment()->crossCompartmentWrappers.put(targetv, wrapperv);
55574:     }
55574: 
55574:     return obj;
55574: }
55574: 
55574: JS_PUBLIC_API(JSObject *)
    1: JS_GetGlobalObject(JSContext *cx)
    1: {
    1:     return cx->globalObject;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetGlobalObject(JSContext *cx, JSObject *obj)
    1: {
35586:     CHECK_REQUEST(cx);
47517: 
    1:     cx->globalObject = obj;
55607:     if (!cx->hasfp())
55607:         cx->resetCompartment();
    1: }
    1: 
50513: class AutoResolvingEntry {
50513: public:
50513:     AutoResolvingEntry() : entry(NULL) {}
50513: 
50513:     /*
50513:      * Returns false on error. But N.B. if obj[id] was already being resolved,
50513:      * this is a no-op, and we silently treat that as success.
50513:      */
50513:     bool start(JSContext *cx, JSObject *obj, jsid id, uint32 flag) {
50513:         JS_ASSERT(!entry);
50513:         this->cx = cx;
50513:         key.obj = obj;
50513:         key.id = id;
50513:         this->flag = flag;
50513:         bool ok = !!js_StartResolving(cx, &key, flag, &entry);
50513:         JS_ASSERT_IF(!ok, !entry);
50513:         return ok;
50513:     }
50513: 
50513:     ~AutoResolvingEntry() {
50513:         if (entry)
50513:             js_StopResolving(cx, &key, flag, NULL, 0);
50513:     }
50513: 
50513: private:
50513:     JSContext *cx;
50513:     JSResolvingKey key;
50513:     uint32 flag;
50513:     JSResolvingEntry *entry;
50513: };
50513: 
    1: JSObject *
    1: js_InitFunctionAndObjectClasses(JSContext *cx, JSObject *obj)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     JSObject *fun_proto, *obj_proto;
    1: 
    1:     /* If cx has no global object, use obj so prototypes can be found. */
    1:     if (!cx->globalObject)
    1:         JS_SetGlobalObject(cx, obj);
    1: 
50513:     /* Record Function and Object in cx->resolvingTable. */
50513:     AutoResolvingEntry e1, e2;
50513:     JSAtom **classAtoms = cx->runtime->atomState.classAtoms;
50513:     if (!e1.start(cx, obj, ATOM_TO_JSID(classAtoms[JSProto_Function]), JSRESFLAG_LOOKUP) ||
50513:         !e2.start(cx, obj, ATOM_TO_JSID(classAtoms[JSProto_Object]), JSRESFLAG_LOOKUP)) {
    1:         return NULL;
    1:     }
50513: 
50513:     /* Initialize the function class first so constructors can be made. */
50513:     if (!js_GetClassPrototype(cx, obj, JSProto_Function, &fun_proto))
    1:         return NULL;
14352:     if (!fun_proto) {
    1:         fun_proto = js_InitFunctionClass(cx, obj);
    1:         if (!fun_proto)
50513:             return NULL;
14352:     } else {
14352:         JSObject *ctor;
14352: 
14352:         ctor = JS_GetConstructor(cx, fun_proto);
50513:         if (!ctor)
50513:             return NULL;
31501:         obj->defineProperty(cx, ATOM_TO_JSID(CLASS_ATOM(cx, Function)),
48470:                             ObjectValue(*ctor), 0, 0, 0);
14352:     }
    1: 
    1:     /* Initialize the object class next so Object.prototype works. */
50513:     if (!js_GetClassPrototype(cx, obj, JSProto_Object, &obj_proto))
50513:         return NULL;
14352:     if (!obj_proto)
    1:         obj_proto = js_InitObjectClass(cx, obj);
50513:     if (!obj_proto)
50513:         return NULL;
    1: 
    1:     /* Function.prototype and the global object delegate to Object.prototype. */
39928:     fun_proto->setProto(obj_proto);
39928:     if (!obj->getProto())
39928:         obj->setProto(obj_proto);
    1: 
    1:     return fun_proto;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_InitStandardClasses(JSContext *cx, JSObject *obj)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     CHECK_REQUEST(cx);
    1: 
54154:     /*
54154:      * JS_SetGlobalObject might or might not change cx's compartment, so call
54154:      * it before assertSameCompartment. (The API contract is that *after* this,
54154:      * cx and obj must be in the same compartment.)
54154:      */
54154:     if (!cx->globalObject)
54154:         JS_SetGlobalObject(cx, obj);
47485:     assertSameCompartment(cx, obj);
43290: 
    1:     /* Define a top-level property 'undefined' with the undefined value. */
47517:     JSAtom *atom = cx->runtime->atomState.typeAtoms[JSTYPE_VOID];
48470:     if (!obj->defineProperty(cx, ATOM_TO_JSID(atom), UndefinedValue(),
48470:                              PropertyStub, PropertyStub,
37031:                              JSPROP_PERMANENT | JSPROP_READONLY)) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Function and Object require cooperative bootstrapping magic. */
    1:     if (!js_InitFunctionAndObjectClasses(cx, obj))
    1:         return JS_FALSE;
    1: 
    1:     /* Initialize the rest of the standard objects and functions. */
    1:     return js_InitArrayClass(cx, obj) &&
    1:            js_InitBooleanClass(cx, obj) &&
    1:            js_InitExceptionClasses(cx, obj) &&
    1:            js_InitMathClass(cx, obj) &&
    1:            js_InitNumberClass(cx, obj) &&
20092:            js_InitJSONClass(cx, obj) &&
    1:            js_InitRegExpClass(cx, obj) &&
    1:            js_InitStringClass(cx, obj) &&
37042:            js_InitTypedArrayClasses(cx, obj) &&
    1: #if JS_HAS_XML_SUPPORT
    1:            js_InitXMLClasses(cx, obj) &&
    1: #endif
    1: #if JS_HAS_GENERATORS
    1:            js_InitIteratorClasses(cx, obj) &&
    1: #endif
42733:            js_InitDateClass(cx, obj) &&
42733:            js_InitProxyClass(cx, obj);
    1: }
    1: 
18414: #define CLASP(name)                 (&js_##name##Class)
48622: #define TYPED_ARRAY_CLASP(type)     (&TypedArray::fastClasses[TypedArray::type])
    1: #define EAGER_ATOM(name)            ATOM_OFFSET(name), NULL
    1: #define EAGER_CLASS_ATOM(name)      CLASS_ATOM_OFFSET(name), NULL
    1: #define EAGER_ATOM_AND_CLASP(name)  EAGER_CLASS_ATOM(name), CLASP(name)
    1: #define LAZY_ATOM(name)             ATOM_OFFSET(lazy.name), js_##name##_str
    1: 
    1: typedef struct JSStdName {
    1:     JSObjectOp  init;
    1:     size_t      atomOffset;     /* offset of atom pointer in JSAtomState */
    1:     const char  *name;          /* null if atom is pre-pinned, else name */
48470:     Class       *clasp;
    1: } JSStdName;
    1: 
    1: static JSAtom *
    1: StdNameToAtom(JSContext *cx, JSStdName *stdn)
    1: {
    1:     size_t offset;
    1:     JSAtom *atom;
    1:     const char *name;
    1: 
    1:     offset = stdn->atomOffset;
    1:     atom = OFFSET_TO_ATOM(cx->runtime, offset);
    1:     if (!atom) {
    1:         name = stdn->name;
    1:         if (name) {
    1:             atom = js_Atomize(cx, name, strlen(name), ATOM_PINNED);
    1:             OFFSET_TO_ATOM(cx->runtime, offset) = atom;
    1:         }
    1:     }
    1:     return atom;
    1: }
    1: 
    1: /*
    1:  * Table of class initializers and their atom offsets in rt->atomState.
    1:  * If you add a "standard" class, remember to update this table.
    1:  */
    1: static JSStdName standard_class_atoms[] = {
    1:     {js_InitFunctionAndObjectClasses,   EAGER_ATOM_AND_CLASP(Function)},
    1:     {js_InitFunctionAndObjectClasses,   EAGER_ATOM_AND_CLASP(Object)},
    1:     {js_InitArrayClass,                 EAGER_ATOM_AND_CLASP(Array)},
    1:     {js_InitBooleanClass,               EAGER_ATOM_AND_CLASP(Boolean)},
    1:     {js_InitDateClass,                  EAGER_ATOM_AND_CLASP(Date)},
    1:     {js_InitMathClass,                  EAGER_ATOM_AND_CLASP(Math)},
    1:     {js_InitNumberClass,                EAGER_ATOM_AND_CLASP(Number)},
    1:     {js_InitStringClass,                EAGER_ATOM_AND_CLASP(String)},
    1:     {js_InitExceptionClasses,           EAGER_ATOM_AND_CLASP(Error)},
    1:     {js_InitRegExpClass,                EAGER_ATOM_AND_CLASP(RegExp)},
    1: #if JS_HAS_XML_SUPPORT
    1:     {js_InitXMLClass,                   EAGER_ATOM_AND_CLASP(XML)},
48622:     {js_InitNamespaceClass,             EAGER_ATOM_AND_CLASP(Namespace)},
48622:     {js_InitQNameClass,                 EAGER_ATOM_AND_CLASP(QName)},
    1: #endif
    1: #if JS_HAS_GENERATORS
    1:     {js_InitIteratorClasses,            EAGER_ATOM_AND_CLASP(StopIteration)},
    1: #endif
20092:     {js_InitJSONClass,                  EAGER_ATOM_AND_CLASP(JSON)},
37042:     {js_InitTypedArrayClasses,          EAGER_CLASS_ATOM(ArrayBuffer), &js::ArrayBuffer::jsclass},
    1:     {NULL,                              0, NULL, NULL}
    1: };
    1: 
    1: /*
    1:  * Table of top-level function and constant names and their init functions.
    1:  * If you add a "standard" global function or property, remember to update
    1:  * this table.
    1:  */
    1: static JSStdName standard_class_names[] = {
43236:     {js_InitObjectClass,        EAGER_ATOM(eval), CLASP(Object)},
    1: 
    1:     /* Global properties and functions defined by the Number class. */
43236:     {js_InitNumberClass,        LAZY_ATOM(NaN), CLASP(Number)},
43236:     {js_InitNumberClass,        LAZY_ATOM(Infinity), CLASP(Number)},
43236:     {js_InitNumberClass,        LAZY_ATOM(isNaN), CLASP(Number)},
43236:     {js_InitNumberClass,        LAZY_ATOM(isFinite), CLASP(Number)},
43236:     {js_InitNumberClass,        LAZY_ATOM(parseFloat), CLASP(Number)},
43236:     {js_InitNumberClass,        LAZY_ATOM(parseInt), CLASP(Number)},
    1: 
    1:     /* String global functions. */
43236:     {js_InitStringClass,        LAZY_ATOM(escape), CLASP(String)},
43236:     {js_InitStringClass,        LAZY_ATOM(unescape), CLASP(String)},
43236:     {js_InitStringClass,        LAZY_ATOM(decodeURI), CLASP(String)},
43236:     {js_InitStringClass,        LAZY_ATOM(encodeURI), CLASP(String)},
43236:     {js_InitStringClass,        LAZY_ATOM(decodeURIComponent), CLASP(String)},
43236:     {js_InitStringClass,        LAZY_ATOM(encodeURIComponent), CLASP(String)},
    1: #if JS_HAS_UNEVAL
43236:     {js_InitStringClass,        LAZY_ATOM(uneval), CLASP(String)},
    1: #endif
    1: 
    1:     /* Exception constructors. */
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(Error), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(InternalError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(EvalError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(RangeError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(ReferenceError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(SyntaxError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(TypeError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(URIError), CLASP(Error)},
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:     {js_InitAnyNameClass,       EAGER_ATOM_AND_CLASP(AnyName)},
    1:     {js_InitAttributeNameClass, EAGER_ATOM_AND_CLASP(AttributeName)},
43236:     {js_InitXMLClass,           LAZY_ATOM(XMLList), CLASP(XML)},
43236:     {js_InitXMLClass,           LAZY_ATOM(isXMLName), CLASP(XML)},
    1: #endif
    1: 
    1: #if JS_HAS_GENERATORS
48622:     {js_InitIteratorClasses,    EAGER_ATOM_AND_CLASP(Iterator)},
48622:     {js_InitIteratorClasses,    EAGER_ATOM_AND_CLASP(Generator)},
    1: #endif
    1: 
37042:     /* Typed Arrays */
43236:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(ArrayBuffer), &js::ArrayBuffer::jsclass},
48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Int8Array),    TYPED_ARRAY_CLASP(TYPE_INT8)},
48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint8Array),   TYPED_ARRAY_CLASP(TYPE_UINT8)},
48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Int16Array),   TYPED_ARRAY_CLASP(TYPE_INT16)},
48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint16Array),  TYPED_ARRAY_CLASP(TYPE_UINT16)},
48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Int32Array),   TYPED_ARRAY_CLASP(TYPE_INT32)},
48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint32Array),  TYPED_ARRAY_CLASP(TYPE_UINT32)},
48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Float32Array), TYPED_ARRAY_CLASP(TYPE_FLOAT32)},
48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Float64Array), TYPED_ARRAY_CLASP(TYPE_FLOAT64)},
48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint8ClampedArray),
48622:                                 TYPED_ARRAY_CLASP(TYPE_UINT8_CLAMPED)},
43236: 
43236:     {js_InitProxyClass,         EAGER_ATOM_AND_CLASP(Proxy)},
42733: 
    1:     {NULL,                      0, NULL, NULL}
    1: };
    1: 
    1: static JSStdName object_prototype_names[] = {
    1:     /* Object.prototype properties (global delegates to Object.prototype). */
43236:     {js_InitObjectClass,        EAGER_ATOM(proto), CLASP(Object)},
    1: #if JS_HAS_TOSOURCE
43236:     {js_InitObjectClass,        EAGER_ATOM(toSource), CLASP(Object)},
    1: #endif
43236:     {js_InitObjectClass,        EAGER_ATOM(toString), CLASP(Object)},
43236:     {js_InitObjectClass,        EAGER_ATOM(toLocaleString), CLASP(Object)},
43236:     {js_InitObjectClass,        EAGER_ATOM(valueOf), CLASP(Object)},
    1: #if JS_HAS_OBJ_WATCHPOINT
43236:     {js_InitObjectClass,        LAZY_ATOM(watch), CLASP(Object)},
43236:     {js_InitObjectClass,        LAZY_ATOM(unwatch), CLASP(Object)},
    1: #endif
43236:     {js_InitObjectClass,        LAZY_ATOM(hasOwnProperty), CLASP(Object)},
43236:     {js_InitObjectClass,        LAZY_ATOM(isPrototypeOf), CLASP(Object)},
43236:     {js_InitObjectClass,        LAZY_ATOM(propertyIsEnumerable), CLASP(Object)},
40855: #if OLD_GETTER_SETTER_METHODS
43236:     {js_InitObjectClass,        LAZY_ATOM(defineGetter), CLASP(Object)},
43236:     {js_InitObjectClass,        LAZY_ATOM(defineSetter), CLASP(Object)},
43236:     {js_InitObjectClass,        LAZY_ATOM(lookupGetter), CLASP(Object)},
43236:     {js_InitObjectClass,        LAZY_ATOM(lookupSetter), CLASP(Object)},
    1: #endif
    1: 
    1:     {NULL,                      0, NULL, NULL}
    1: };
    1: 
    1: JS_PUBLIC_API(JSBool)
48470: JS_ResolveStandardClass(JSContext *cx, JSObject *obj, jsid id, JSBool *resolved)
    1: {
    1:     JSString *idstr;
    1:     JSRuntime *rt;
    1:     JSAtom *atom;
    1:     JSStdName *stdnm;
    1:     uintN i;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, id);
    1:     *resolved = JS_FALSE;
    1: 
 4556:     rt = cx->runtime;
 4556:     JS_ASSERT(rt->state != JSRTS_DOWN);
48470:     if (rt->state == JSRTS_LANDING || !JSID_IS_ATOM(id))
    1:         return JS_TRUE;
 4556: 
48470:     idstr = JSID_TO_STRING(id);
    1: 
    1:     /* Check whether we're resolving 'undefined', and define it if so. */
    1:     atom = rt->atomState.typeAtoms[JSTYPE_VOID];
    1:     if (idstr == ATOM_TO_STRING(atom)) {
    1:         *resolved = JS_TRUE;
48470:         return obj->defineProperty(cx, ATOM_TO_JSID(atom), UndefinedValue(),
48470:                                    PropertyStub, PropertyStub,
37031:                                    JSPROP_PERMANENT | JSPROP_READONLY);
    1:     }
    1: 
    1:     /* Try for class constructors/prototypes named by well-known atoms. */
    1:     stdnm = NULL;
    1:     for (i = 0; standard_class_atoms[i].init; i++) {
43236:         JS_ASSERT(standard_class_atoms[i].clasp);
    1:         atom = OFFSET_TO_ATOM(rt, standard_class_atoms[i].atomOffset);
    1:         if (idstr == ATOM_TO_STRING(atom)) {
    1:             stdnm = &standard_class_atoms[i];
    1:             break;
    1:         }
    1:     }
    1: 
    1:     if (!stdnm) {
    1:         /* Try less frequently used top-level functions and constants. */
    1:         for (i = 0; standard_class_names[i].init; i++) {
43236:             JS_ASSERT(standard_class_names[i].clasp);
    1:             atom = StdNameToAtom(cx, &standard_class_names[i]);
    1:             if (!atom)
    1:                 return JS_FALSE;
    1:             if (idstr == ATOM_TO_STRING(atom)) {
    1:                 stdnm = &standard_class_names[i];
    1:                 break;
    1:             }
    1:         }
    1: 
39928:         if (!stdnm && !obj->getProto()) {
    1:             /*
    1:              * Try even less frequently used names delegated from the global
    1:              * object to Object.prototype, but only if the Object class hasn't
    1:              * yet been initialized.
    1:              */
    1:             for (i = 0; object_prototype_names[i].init; i++) {
43236:                 JS_ASSERT(object_prototype_names[i].clasp);
    1:                 atom = StdNameToAtom(cx, &object_prototype_names[i]);
    1:                 if (!atom)
    1:                     return JS_FALSE;
    1:                 if (idstr == ATOM_TO_STRING(atom)) {
41243:                     stdnm = &object_prototype_names[i];
    1:                     break;
    1:                 }
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (stdnm) {
    1:         /*
43236:          * If this standard class is anonymous, then we don't want to resolve
43236:          * by name.
    1:          */
43236:         JS_ASSERT(obj->getClass()->flags & JSCLASS_IS_GLOBAL);
43236:         if (stdnm->clasp->flags & JSCLASS_IS_ANONYMOUS)
    1:             return JS_TRUE;
43236: 
43236:         JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(stdnm->clasp);
48470:         if (obj->getReservedSlot(key).isObject())
43236:             return JS_TRUE;
    1: 
    1:         if (!stdnm->init(cx, obj))
    1:             return JS_FALSE;
    1:         *resolved = JS_TRUE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EnumerateStandardClasses(JSContext *cx, JSObject *obj)
    1: {
    1:     JSRuntime *rt;
    1:     JSAtom *atom;
    1:     uintN i;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
    1:     rt = cx->runtime;
    1: 
    1:     /* Check whether we need to bind 'undefined' and define it if so. */
    1:     atom = rt->atomState.typeAtoms[JSTYPE_VOID];
56567:     if (!obj->nativeContains(ATOM_TO_JSID(atom)) &&
48470:         !obj->defineProperty(cx, ATOM_TO_JSID(atom), UndefinedValue(),
48470:                              PropertyStub, PropertyStub,
39915:                              JSPROP_PERMANENT | JSPROP_READONLY)) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Initialize any classes that have not been resolved yet. */
    1:     for (i = 0; standard_class_atoms[i].init; i++) {
    1:         atom = OFFSET_TO_ATOM(rt, standard_class_atoms[i].atomOffset);
56567:         if (!obj->nativeContains(ATOM_TO_JSID(atom)) &&
    1:             !standard_class_atoms[i].init(cx, obj)) {
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
42733: namespace js {
42733: 
42733: JSIdArray *
15677: NewIdArray(JSContext *cx, jsint length)
15677: {
15677:     JSIdArray *ida;
15677: 
15677:     ida = (JSIdArray *)
42733:         cx->calloc(offsetof(JSIdArray, vector) + length * sizeof(jsval));
47459:     if (ida)
15677:         ida->length = length;
15677:     return ida;
15677: }
15677: 
42733: }
42733: 
15677: /*
15677:  * Unlike realloc(3), this function frees ida on failure.
15677:  */
15677: static JSIdArray *
15677: SetIdArrayLength(JSContext *cx, JSIdArray *ida, jsint length)
15677: {
15677:     JSIdArray *rida;
15677: 
15677:     rida = (JSIdArray *)
15677:            JS_realloc(cx, ida,
15677:                       offsetof(JSIdArray, vector) + length * sizeof(jsval));
42641:     if (!rida) {
15677:         JS_DestroyIdArray(cx, ida);
42641:     } else {
15677:         rida->length = length;
42641:     }
15677:     return rida;
15677: }
15677: 
15677: static JSIdArray *
    1: AddAtomToArray(JSContext *cx, JSAtom *atom, JSIdArray *ida, jsint *ip)
    1: {
    1:     jsint i, length;
    1: 
    1:     i = *ip;
    1:     length = ida->length;
    1:     if (i >= length) {
15677:         ida = SetIdArrayLength(cx, ida, JS_MAX(length * 2, 8));
    1:         if (!ida)
    1:             return NULL;
    1:         JS_ASSERT(i < ida->length);
    1:     }
    1:     ida->vector[i] = ATOM_TO_JSID(atom);
    1:     *ip = i + 1;
    1:     return ida;
    1: }
    1: 
    1: static JSIdArray *
    1: EnumerateIfResolved(JSContext *cx, JSObject *obj, JSAtom *atom, JSIdArray *ida,
    1:                     jsint *ip, JSBool *foundp)
    1: {
56567:     *foundp = obj->nativeContains(ATOM_TO_JSID(atom));
    1:     if (*foundp)
    1:         ida = AddAtomToArray(cx, atom, ida, ip);
    1:     return ida;
    1: }
    1: 
    1: JS_PUBLIC_API(JSIdArray *)
43229: JS_EnumerateResolvedStandardClasses(JSContext *cx, JSObject *obj, JSIdArray *ida)
    1: {
    1:     JSRuntime *rt;
    1:     jsint i, j, k;
    1:     JSAtom *atom;
    1:     JSBool found;
    1:     JSObjectOp init;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, ida);
    1:     rt = cx->runtime;
    1:     if (ida) {
    1:         i = ida->length;
    1:     } else {
15677:         ida = NewIdArray(cx, 8);
    1:         if (!ida)
    1:             return NULL;
    1:         i = 0;
    1:     }
    1: 
    1:     /* Check whether 'undefined' has been resolved and enumerate it if so. */
    1:     atom = rt->atomState.typeAtoms[JSTYPE_VOID];
    1:     ida = EnumerateIfResolved(cx, obj, atom, ida, &i, &found);
    1:     if (!ida)
    1:         return NULL;
    1: 
    1:     /* Enumerate only classes that *have* been resolved. */
    1:     for (j = 0; standard_class_atoms[j].init; j++) {
    1:         atom = OFFSET_TO_ATOM(rt, standard_class_atoms[j].atomOffset);
    1:         ida = EnumerateIfResolved(cx, obj, atom, ida, &i, &found);
    1:         if (!ida)
    1:             return NULL;
    1: 
    1:         if (found) {
    1:             init = standard_class_atoms[j].init;
    1: 
    1:             for (k = 0; standard_class_names[k].init; k++) {
    1:                 if (standard_class_names[k].init == init) {
    1:                     atom = StdNameToAtom(cx, &standard_class_names[k]);
    1:                     ida = AddAtomToArray(cx, atom, ida, &i);
    1:                     if (!ida)
    1:                         return NULL;
    1:                 }
    1:             }
    1: 
    1:             if (init == js_InitObjectClass) {
    1:                 for (k = 0; object_prototype_names[k].init; k++) {
    1:                     atom = StdNameToAtom(cx, &object_prototype_names[k]);
    1:                     ida = AddAtomToArray(cx, atom, ida, &i);
    1:                     if (!ida)
    1:                         return NULL;
    1:                 }
    1:             }
    1:         }
    1:     }
    1: 
15677:     /* Trim to exact length. */
15677:     return SetIdArrayLength(cx, ida, i);
    1: }
    1: 
    1: #undef CLASP
    1: #undef EAGER_ATOM
    1: #undef EAGER_CLASS_ATOM
    1: #undef EAGER_ATOM_CLASP
    1: #undef LAZY_ATOM
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key, JSObject **objp)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
    1:     return js_GetClassObject(cx, obj, key, objp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetScopeChain(JSContext *cx)
    1: {
17070:     CHECK_REQUEST(cx);
56729:     return GetScopeChain(cx);
    1: }
    1: 
 4427: JS_PUBLIC_API(JSObject *)
 4427: JS_GetGlobalForObject(JSContext *cx, JSObject *obj)
 4427: {
47485:     assertSameCompartment(cx, obj);
40424:     return obj->getGlobal();
 4427: }
 4427: 
42766: JS_PUBLIC_API(JSObject *)
42766: JS_GetGlobalForScopeChain(JSContext *cx)
42766: {
56729:     CHECK_REQUEST(cx);
56729:     return GetGlobalForScopeChain(cx);
42766: }
42766: 
11809: JS_PUBLIC_API(jsval)
11809: JS_ComputeThis(JSContext *cx, jsval *vp)
11809: {
48470:     assertSameCompartment(cx, JSValueArray(vp, 2));
48470:     if (!ComputeThisFromVp(cx, Valueify(vp)))
11809:         return JSVAL_NULL;
11809:     return vp[1];
11809: }
11809: 
    1: JS_PUBLIC_API(void *)
    1: JS_malloc(JSContext *cx, size_t nbytes)
    1: {
30851:     return cx->malloc(nbytes);
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_realloc(JSContext *cx, void *p, size_t nbytes)
    1: {
30851:     return cx->realloc(p, nbytes);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_free(JSContext *cx, void *p)
    1: {
30851:     return cx->free(p);
    1: }
    1: 
34383: JS_PUBLIC_API(void)
34383: JS_updateMallocCounter(JSContext *cx, size_t nbytes)
34383: {
53592:     return cx->runtime->updateMallocCounter(nbytes);
34383: }
34383: 
    1: JS_PUBLIC_API(char *)
    1: JS_strdup(JSContext *cx, const char *s)
    1: {
    1:     size_t n;
    1:     void *p;
    1: 
    1:     n = strlen(s) + 1;
30851:     p = cx->malloc(n);
    1:     if (!p)
    1:         return NULL;
    1:     return (char *)memcpy(p, s, n);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_NewNumberValue(JSContext *cx, jsdouble d, jsval *rval)
    1: {
49081:     d = JS_CANONICALIZE_NAN(d);
48470:     Valueify(rval)->setNumber(d);
48470:     return JS_TRUE;
    1: }
    1: 
    1: #undef JS_AddRoot
47403: 
    1: JS_PUBLIC_API(JSBool)
47403: JS_AddValueRoot(JSContext *cx, jsval *vp)
    1: {
    1:     CHECK_REQUEST(cx);
48470:     return js_AddRoot(cx, Valueify(vp), NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
47403: JS_AddStringRoot(JSContext *cx, JSString **rp)
47403: {
47403:     CHECK_REQUEST(cx);
47403:     return js_AddGCThingRoot(cx, (void **)rp, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
47403: JS_AddObjectRoot(JSContext *cx, JSObject **rp)
    1: {
    1:     CHECK_REQUEST(cx);
47403:     return js_AddGCThingRoot(cx, (void **)rp, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
48470: JS_AddGCThingRoot(JSContext *cx, void **rp)
47403: {
47403:     CHECK_REQUEST(cx);
47403:     return js_AddGCThingRoot(cx, (void **)rp, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
48470: JS_AddNamedValueRoot(JSContext *cx, jsval *vp, const char *name)
    1: {
    1:     CHECK_REQUEST(cx);
48470:     return js_AddRoot(cx, Valueify(vp), name);
47403: }
47403: 
47403: JS_PUBLIC_API(JSBool)
47403: JS_AddNamedStringRoot(JSContext *cx, JSString **rp, const char *name)
47403: {
47403:     CHECK_REQUEST(cx);
47403:     return js_AddGCThingRoot(cx, (void **)rp, name);
47403: }
47403: 
47403: JS_PUBLIC_API(JSBool)
47403: JS_AddNamedObjectRoot(JSContext *cx, JSObject **rp, const char *name)
47403: {
47403:     CHECK_REQUEST(cx);
47403:     return js_AddGCThingRoot(cx, (void **)rp, name);
47403: }
47403: 
47403: JS_PUBLIC_API(JSBool)
48470: JS_AddNamedGCThingRoot(JSContext *cx, void **rp, const char *name)
47403: {
47403:     CHECK_REQUEST(cx);
47403:     return js_AddGCThingRoot(cx, (void **)rp, name);
47403: }
47403: 
47403: JS_PUBLIC_API(JSBool)
47403: JS_RemoveValueRoot(JSContext *cx, jsval *vp)
47403: {
47403:     CHECK_REQUEST(cx);
47403:     return js_RemoveRoot(cx->runtime, (void *)vp);
47403: }
47403: 
47403: JS_PUBLIC_API(JSBool)
47403: JS_RemoveStringRoot(JSContext *cx, JSString **rp)
47403: {
47403:     CHECK_REQUEST(cx);
47403:     return js_RemoveRoot(cx->runtime, (void *)rp);
47403: }
47403: 
47403: JS_PUBLIC_API(JSBool)
47403: JS_RemoveObjectRoot(JSContext *cx, JSObject **rp)
47403: {
47403:     CHECK_REQUEST(cx);
47403:     return js_RemoveRoot(cx->runtime, (void *)rp);
47403: }
47403: 
47403: JS_PUBLIC_API(JSBool)
48470: JS_RemoveGCThingRoot(JSContext *cx, void **rp)
47403: {
47403:     CHECK_REQUEST(cx);
47403:     return js_RemoveRoot(cx->runtime, (void *)rp);
47403: }
47403: 
    1: #ifdef DEBUG
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DumpNamedRoots(JSRuntime *rt,
48470:                   void (*dump)(const char *name, void *rp, JSGCRootType type, void *data),
    1:                   void *data)
    1: {
    1:     js_DumpNamedRoots(rt, dump, data);
    1: }
    1: 
    1: #endif /* DEBUG */
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_MapGCRoots(JSRuntime *rt, JSGCRootMapFun map, void *data)
    1: {
    1:     return js_MapGCRoots(rt, map, data);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_LockGCThing(JSContext *cx, void *thing)
    1: {
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
12282:     ok = js_LockGCThingRT(cx->runtime, thing);
    1:     if (!ok)
12282:         JS_ReportOutOfMemory(cx);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_LockGCThingRT(JSRuntime *rt, void *thing)
    1: {
    1:     return js_LockGCThingRT(rt, thing);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_UnlockGCThing(JSContext *cx, void *thing)
    1: {
    1:     CHECK_REQUEST(cx);
36410:     js_UnlockGCThingRT(cx->runtime, thing);
36410:     return true;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_UnlockGCThingRT(JSRuntime *rt, void *thing)
    1: {
36410:     js_UnlockGCThingRT(rt, thing);
36410:     return true;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
  958: JS_SetExtraGCRoots(JSRuntime *rt, JSTraceDataOp traceOp, void *data)
  958: {
  958:     rt->gcExtraRootsTraceOp = traceOp;
  958:     rt->gcExtraRootsData = data;
  958: }
  958: 
  958: JS_PUBLIC_API(void)
  786: JS_TraceRuntime(JSTracer *trc)
  786: {
53548:     TraceRuntime(trc);
  786: }
  786: 
38595: JS_PUBLIC_API(void)
38595: JS_CallTracer(JSTracer *trc, void *thing, uint32 kind)
38595: {
48470:     JS_ASSERT(thing);
54707:     MarkKind(trc, thing, kind);
38595: }
38595: 
  786: #ifdef DEBUG
  786: 
  786: #ifdef HAVE_XPCONNECT
  786: #include "dump_xpc.h"
  786: #endif
  786: 
  786: JS_PUBLIC_API(void)
43229: JS_PrintTraceThingInfo(char *buf, size_t bufsize, JSTracer *trc, void *thing, uint32 kind,
43229:                        JSBool details)
  786: {
  786:     const char *name;
  786:     size_t n;
  786: 
  786:     if (bufsize == 0)
  786:         return;
  786: 
  786:     switch (kind) {
  786:       case JSTRACE_OBJECT:
  786:       {
  786:         JSObject *obj = (JSObject *)thing;
48470:         Class *clasp = obj->getClass();
  786: 
  786:         name = clasp->name;
  786: #ifdef HAVE_XPCONNECT
  786:         if (clasp->flags & JSCLASS_PRIVATE_IS_NSISUPPORTS) {
31452:             void *privateThing = obj->getPrivate();
31452:             if (privateThing) {
  786:                 const char *xpcClassName = GetXPCObjectClassName(privateThing);
  786:                 if (xpcClassName)
  786:                     name = xpcClassName;
  786:             }
  786:         }
  786: #endif
  786:         break;
  786:       }
  786: 
  786:       case JSTRACE_STRING:
29366:         name = ((JSString *)thing)->isDependent()
  786:                ? "substring"
  786:                : "string";
  786:         break;
  786: 
  786: #if JS_HAS_XML_SUPPORT
  786:       case JSTRACE_XML:
  786:         name = "xml";
  786:         break;
  786: #endif
  786:       default:
  786:         JS_ASSERT(0);
  786:         return;
  786:         break;
  786:     }
  786: 
  786:     n = strlen(name);
  786:     if (n > bufsize - 1)
  786:         n = bufsize - 1;
  786:     memcpy(buf, name, n + 1);
  786:     buf += n;
  786:     bufsize -= n;
  786: 
  786:     if (details && bufsize > 2) {
  786:         *buf++ = ' ';
  786:         bufsize--;
  786: 
  786:         switch (kind) {
  786:           case JSTRACE_OBJECT:
  786:           {
  786:             JSObject  *obj = (JSObject *)thing;
48470:             Class *clasp = obj->getClass();
13824:             if (clasp == &js_FunctionClass) {
31452:                 JSFunction *fun = GET_FUNCTION_PRIVATE(trc->context, obj);
13824:                 if (!fun) {
13824:                     JS_snprintf(buf, bufsize, "<newborn>");
13824:                 } else if (FUN_OBJECT(fun) != obj) {
13824:                     JS_snprintf(buf, bufsize, "%p", fun);
13824:                 } else {
48470:                     if (fun->atom)
57721:                         PutEscapedString(buf, bufsize, ATOM_TO_STRING(fun->atom), 0);
13824:                 }
13824:             } else if (clasp->flags & JSCLASS_HAS_PRIVATE) {
31452:                 JS_snprintf(buf, bufsize, "%p", obj->getPrivate());
11846:             } else {
11846:                 JS_snprintf(buf, bufsize, "<no private>");
11846:             }
  786:             break;
  786:           }
  786: 
  786:           case JSTRACE_STRING:
57721:             PutEscapedString(buf, bufsize, (JSString *)thing, 0);
  786:             break;
  786: 
  786: #if JS_HAS_XML_SUPPORT
 4529:           case JSTRACE_XML:
  786:           {
  786:             extern const char *js_xml_class_str[];
  786:             JSXML *xml = (JSXML *)thing;
  786: 
  786:             JS_snprintf(buf, bufsize, "%s", js_xml_class_str[xml->xml_class]);
  786:             break;
  786:           }
  786: #endif
  786:           default:
  786:             JS_ASSERT(0);
  786:             break;
  786:         }
  786:     }
  786:     buf[bufsize - 1] = '\0';
  786: }
  786: 
  786: typedef struct JSHeapDumpNode JSHeapDumpNode;
  786: 
  786: struct JSHeapDumpNode {
  786:     void            *thing;
  786:     uint32          kind;
  786:     JSHeapDumpNode  *next;          /* next sibling */
  786:     JSHeapDumpNode  *parent;        /* node with the thing that refer to thing
  786:                                        from this node */
  786:     char            edgeName[1];    /* name of the edge from parent->thing
  786:                                        into thing */
  786: };
  786: 
  786: typedef struct JSDumpingTracer {
  786:     JSTracer            base;
  786:     JSDHashTable        visited;
  786:     JSBool              ok;
  786:     void                *startThing;
  786:     void                *thingToFind;
  786:     void                *thingToIgnore;
  786:     JSHeapDumpNode      *parentNode;
  786:     JSHeapDumpNode      **lastNodep;
  786:     char                buffer[200];
  786: } JSDumpingTracer;
  786: 
  786: static void
  786: DumpNotify(JSTracer *trc, void *thing, uint32 kind)
  786: {
  786:     JSDumpingTracer *dtrc;
  786:     JSContext *cx;
  786:     JSDHashEntryStub *entry;
  786:     JSHeapDumpNode *node;
  786:     const char *edgeName;
  786:     size_t edgeNameSize;
  786: 
  786:     JS_ASSERT(trc->callback == DumpNotify);
  786:     dtrc = (JSDumpingTracer *)trc;
  786: 
  786:     if (!dtrc->ok || thing == dtrc->thingToIgnore)
  786:         return;
  786: 
  786:     cx = trc->context;
  786: 
  786:     /*
  786:      * Check if we have already seen thing unless it is thingToFind to include
  786:      * it to the graph each time we reach it and print all live things that
  786:      * refer to thingToFind.
  786:      *
  786:      * This does not print all possible paths leading to thingToFind since
  786:      * when a thing A refers directly or indirectly to thingToFind and A is
  786:      * present several times in the graph, we will print only the first path
  786:      * leading to A and thingToFind, other ways to reach A will be ignored.
  786:      */
  786:     if (dtrc->thingToFind != thing) {
  786:         /*
  786:          * The startThing check allows to avoid putting startThing into the
  786:          * hash table before tracing startThing in JS_DumpHeap.
  786:          */
  786:         if (thing == dtrc->startThing)
  786:             return;
  786:         entry = (JSDHashEntryStub *)
  786:             JS_DHashTableOperate(&dtrc->visited, thing, JS_DHASH_ADD);
  786:         if (!entry) {
  786:             JS_ReportOutOfMemory(cx);
  786:             dtrc->ok = JS_FALSE;
  786:             return;
  786:         }
  786:         if (entry->key)
  786:             return;
  786:         entry->key = thing;
  786:     }
  786: 
  786:     if (dtrc->base.debugPrinter) {
  786:         dtrc->base.debugPrinter(trc, dtrc->buffer, sizeof(dtrc->buffer));
  786:         edgeName = dtrc->buffer;
  786:     } else if (dtrc->base.debugPrintIndex != (size_t)-1) {
  786:         JS_snprintf(dtrc->buffer, sizeof(dtrc->buffer), "%s[%lu]",
  786:                     (const char *)dtrc->base.debugPrintArg,
  786:                     dtrc->base.debugPrintIndex);
  786:         edgeName = dtrc->buffer;
  786:     } else {
  786:         edgeName = (const char*)dtrc->base.debugPrintArg;
  786:     }
  786: 
  786:     edgeNameSize = strlen(edgeName) + 1;
  786:     node = (JSHeapDumpNode *)
30851:         cx->malloc(offsetof(JSHeapDumpNode, edgeName) + edgeNameSize);
  786:     if (!node) {
  786:         dtrc->ok = JS_FALSE;
  786:         return;
  786:     }
  786: 
  786:     node->thing = thing;
  786:     node->kind = kind;
  786:     node->next = NULL;
  786:     node->parent = dtrc->parentNode;
  786:     memcpy(node->edgeName, edgeName, edgeNameSize);
  786: 
  786:     JS_ASSERT(!*dtrc->lastNodep);
  786:     *dtrc->lastNodep = node;
  786:     dtrc->lastNodep = &node->next;
  786: }
  786: 
  786: /* Dump node and the chain that leads to thing it contains. */
  786: static JSBool
  917: DumpNode(JSDumpingTracer *dtrc, FILE* fp, JSHeapDumpNode *node)
  786: {
  786:     JSHeapDumpNode *prev, *following;
  786:     size_t chainLimit;
  786:     JSBool ok;
  786:     enum { MAX_PARENTS_TO_PRINT = 10 };
  786: 
  786:     JS_PrintTraceThingInfo(dtrc->buffer, sizeof dtrc->buffer,
  786:                            &dtrc->base, node->thing, node->kind, JS_TRUE);
  917:     if (fprintf(fp, "%p %-22s via ", node->thing, dtrc->buffer) < 0)
  786:         return JS_FALSE;
  786: 
  786:     /*
  786:      * We need to print the parent chain in the reverse order. To do it in
  786:      * O(N) time where N is the chain length we first reverse the chain while
  786:      * searching for the top and then print each node while restoring the
  786:      * chain order.
  786:      */
  786:     chainLimit = MAX_PARENTS_TO_PRINT;
  786:     prev = NULL;
  786:     for (;;) {
  786:         following = node->parent;
  786:         node->parent = prev;
  786:         prev = node;
  786:         node = following;
  786:         if (!node)
  786:             break;
  786:         if (chainLimit == 0) {
  917:             if (fputs("...", fp) < 0)
  786:                 return JS_FALSE;
  786:             break;
  786:         }
  786:         --chainLimit;
  786:     }
  786: 
  786:     node = prev;
  786:     prev = following;
  786:     ok = JS_TRUE;
  786:     do {
  786:         /* Loop must continue even when !ok to restore the parent chain. */
  786:         if (ok) {
  786:             if (!prev) {
  786:                 /* Print edge from some runtime root or startThing. */
  917:                 if (fputs(node->edgeName, fp) < 0)
  786:                     ok = JS_FALSE;
  786:             } else {
  786:                 JS_PrintTraceThingInfo(dtrc->buffer, sizeof dtrc->buffer,
  786:                                        &dtrc->base, prev->thing, prev->kind,
  786:                                        JS_FALSE);
  917:                 if (fprintf(fp, "(%p %s).%s",
  786:                            prev->thing, dtrc->buffer, node->edgeName) < 0) {
  786:                     ok = JS_FALSE;
  786:                 }
  786:             }
  786:         }
  786:         following = node->parent;
  786:         node->parent = prev;
  786:         prev = node;
  786:         node = following;
  786:     } while (node);
  786: 
  917:     return ok && putc('\n', fp) >= 0;
  786: }
  786: 
  786: JS_PUBLIC_API(JSBool)
  917: JS_DumpHeap(JSContext *cx, FILE *fp, void* startThing, uint32 startKind,
  917:             void *thingToFind, size_t maxDepth, void *thingToIgnore)
  786: {
  786:     JSDumpingTracer dtrc;
  786:     JSHeapDumpNode *node, *children, *next, *parent;
  786:     size_t depth;
  786:     JSBool thingToFindWasTraced;
  786: 
  786:     if (maxDepth == 0)
  786:         return JS_TRUE;
  786: 
  786:     JS_TRACER_INIT(&dtrc.base, cx, DumpNotify);
  786:     if (!JS_DHashTableInit(&dtrc.visited, JS_DHashGetStubOps(),
  786:                            NULL, sizeof(JSDHashEntryStub),
  786:                            JS_DHASH_DEFAULT_CAPACITY(100))) {
  786:         JS_ReportOutOfMemory(cx);
  786:         return JS_FALSE;
  786:     }
  786:     dtrc.ok = JS_TRUE;
  786:     dtrc.startThing = startThing;
  786:     dtrc.thingToFind = thingToFind;
  786:     dtrc.thingToIgnore = thingToIgnore;
  786:     dtrc.parentNode = NULL;
  786:     node = NULL;
  786:     dtrc.lastNodep = &node;
  786:     if (!startThing) {
  786:         JS_ASSERT(startKind == 0);
53548:         TraceRuntime(&dtrc.base);
  786:     } else {
  786:         JS_TraceChildren(&dtrc.base, startThing, startKind);
  786:     }
  786: 
  786:     depth = 1;
  786:     if (!node)
  786:         goto dump_out;
  786: 
  786:     thingToFindWasTraced = thingToFind && thingToFind == startThing;
  786:     for (;;) {
  786:         /*
  786:          * Loop must continue even when !dtrc.ok to free all nodes allocated
  786:          * so far.
  786:          */
  786:         if (dtrc.ok) {
  786:             if (thingToFind == NULL || thingToFind == node->thing)
  917:                 dtrc.ok = DumpNode(&dtrc, fp, node);
  786: 
  786:             /* Descend into children. */
  786:             if (dtrc.ok &&
  786:                 depth < maxDepth &&
  786:                 (thingToFind != node->thing || !thingToFindWasTraced)) {
  786:                 dtrc.parentNode = node;
  786:                 children = NULL;
  786:                 dtrc.lastNodep = &children;
  786:                 JS_TraceChildren(&dtrc.base, node->thing, node->kind);
  786:                 if (thingToFind == node->thing)
  786:                     thingToFindWasTraced = JS_TRUE;
  786:                 if (children != NULL) {
  786:                     ++depth;
  786:                     node = children;
  786:                     continue;
  786:                 }
  786:             }
  786:         }
  786: 
  786:         /* Move to next or parents next and free the node. */
  786:         for (;;) {
  786:             next = node->next;
  786:             parent = node->parent;
30851:             cx->free(node);
  786:             node = next;
  786:             if (node)
  786:                 break;
  786:             if (!parent)
  786:                 goto dump_out;
  786:             JS_ASSERT(depth > 1);
  786:             --depth;
  786:             node = parent;
  786:         }
  786:     }
  786: 
  786:   dump_out:
  786:     JS_ASSERT(depth == 1);
  786:     JS_DHashTableFinish(&dtrc.visited);
  786:     return dtrc.ok;
  786: }
  786: 
  786: #endif /* DEBUG */
  786: 
  786: JS_PUBLIC_API(void)
48470: JS_MarkGCThing(JSContext *cx, jsval v, const char *name, void *arg)
    1: {
  583:     JSTracer *trc;
  583: 
  583:     trc = (JSTracer *)arg;
  583:     if (!trc)
  583:         trc = cx->runtime->gcMarkingTracer;
  583:     else
  583:         JS_ASSERT(trc == cx->runtime->gcMarkingTracer);
  583: 
    1: #ifdef JS_THREADSAFE
  583:     JS_ASSERT(cx->runtime->gcThread == trc->context->thread);
    1: #endif
48470:     MarkValue(trc, Valueify(v), name ? name : "unknown");
  583: }
  583: 
  583: extern JS_PUBLIC_API(JSBool)
  583: JS_IsGCMarkingTracer(JSTracer *trc)
  583: {
  583:     return IS_GC_MARKING_TRACER(trc);
  583: }
  583: 
    1: JS_PUBLIC_API(void)
    1: JS_GC(JSContext *cx)
    1: {
37741:     LeaveTrace(cx);
24499: 
    1:     /* Don't nuke active arenas if executing or compiling. */
47609:     if (cx->tempPool.current == &cx->tempPool.first)
47609:         JS_FinishArenaPool(&cx->tempPool);
    1:     js_GC(cx, GC_NORMAL);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_MaybeGC(JSContext *cx)
    1: {
32553:     JSRuntime *rt;
32553:     uint32 bytes, lastBytes;
32553: 
32553:     rt = cx->runtime;
32553: 
48619: #ifdef JS_GC_ZEAL
48619:     if (rt->gcZeal > 0) {
48619:         JS_GC(cx);
48619:         return;
48619:     }
48619: #endif
48619: 
32553:     bytes = rt->gcBytes;
32553:     lastBytes = rt->gcLastBytes;
32553: 
48619:     /*
48619:      * We run the GC if we used all available free GC cells and had to
48619:      * allocate extra 1/3 of GC arenas since the last run of GC, or if
48619:      * we have malloc'd more bytes through JS_malloc than we were told
48619:      * to allocate by JS_NewRuntime.
48619:      *
48619:      * The reason for
48619:      *   bytes > 4/3 lastBytes
48619:      * condition is the following. Bug 312238 changed bytes and lastBytes
48619:      * to mean the total amount of memory that the GC uses now and right
48619:      * after the last GC.
48619:      *
48619:      * Before the bug the variables meant the size of allocated GC things
48619:      * now and right after the last GC. That size did not include the
48619:      * memory taken by free GC cells and the condition was
48619:      *   bytes > 3/2 lastBytes.
48619:      * That is, we run the GC if we have half again as many bytes of
48619:      * GC-things as the last time we GC'd. To be compatible we need to
48619:      * express that condition through the new meaning of bytes and
48619:      * lastBytes.
48619:      *
48619:      * We write the original condition as
48619:      *   B*(1-F) > 3/2 Bl*(1-Fl)
48619:      * where B is the total memory size allocated by GC and F is the free
48619:      * cell density currently and Sl and Fl are the size and the density
48619:      * right after GC. The density by definition is memory taken by free
48619:      * cells divided by total amount of memory. In other words, B and Bl
48619:      * are bytes and lastBytes with the new meaning and B*(1-F) and
48619:      * Bl*(1-Fl) are bytes and lastBytes with the original meaning.
48619:      *
48619:      * Our task is to exclude F and Fl from the last statement. According
48619:      * to the stats from bug 331966 comment 23, Fl is about 10-25% for a
48619:      * typical run of the browser. It means that the original condition
48619:      * implied that we did not run GC unless we exhausted the pool of
48619:      * free cells. Indeed if we still have free cells, then B == Bl since
48619:      * we did not yet allocated any new arenas and the condition means
48619:      *   1 - F > 3/2 (1-Fl) or 3/2Fl > 1/2 + F
48619:      * That implies 3/2 Fl > 1/2 or Fl > 1/3. That cannot be fulfilled
48619:      * for the state described by the stats. So we can write the original
48619:      * condition as:
48619:      *   F == 0 && B > 3/2 Bl(1-Fl)
48619:      * Again using the stats we see that Fl is about 11% when the browser
48619:      * starts up and when we are far from hitting rt->gcMaxBytes. With
48619:      * this F we have
48619:      * F == 0 && B > 3/2 Bl(1-0.11)
48619:      * or approximately F == 0 && B > 4/3 Bl.
48619:      */
48619:     if ((bytes > 8192 && bytes > lastBytes + lastBytes / 3) ||
48619:         rt->isGCMallocLimitReached()) {
32553:         JS_GC(cx);
32553:     }
    1: }
    1: 
    1: JS_PUBLIC_API(JSGCCallback)
    1: JS_SetGCCallback(JSContext *cx, JSGCCallback cb)
    1: {
11022:     CHECK_REQUEST(cx);
    1:     return JS_SetGCCallbackRT(cx->runtime, cb);
    1: }
    1: 
    1: JS_PUBLIC_API(JSGCCallback)
    1: JS_SetGCCallbackRT(JSRuntime *rt, JSGCCallback cb)
    1: {
    1:     JSGCCallback oldcb;
    1: 
    1:     oldcb = rt->gcCallback;
    1:     rt->gcCallback = cb;
    1:     return oldcb;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsAboutToBeFinalized(JSContext *cx, void *thing)
    1: {
    1:     JS_ASSERT(thing);
48479:     JS_ASSERT(!cx->runtime->gcMarkingTracer);
54707:     return IsAboutToBeFinalized(thing);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetGCParameter(JSRuntime *rt, JSGCParamKey key, uint32 value)
    1: {
    1:     switch (key) {
    1:       case JSGC_MAX_BYTES:
    1:         rt->gcMaxBytes = value;
    1:         break;
32553:       case JSGC_MAX_MALLOC_BYTES:
34288:         rt->setGCMaxMallocBytes(value);
32553:         break;
32553:       case JSGC_STACKPOOL_LIFESPAN:
19196:         rt->gcEmptyArenaPoolLifespan = value;
10985:         break;
32553:       default:
32553:         JS_ASSERT(key == JSGC_TRIGGER_FACTOR);
32553:         JS_ASSERT(value >= 100);
32553:         rt->setGCTriggerFactor(value);
32553:         return;
24313:     }
24313: }
24313: 
24313: JS_PUBLIC_API(uint32)
24313: JS_GetGCParameter(JSRuntime *rt, JSGCParamKey key)
24313: {
24313:     switch (key) {
24313:       case JSGC_MAX_BYTES:
24313:         return rt->gcMaxBytes;
32553:       case JSGC_MAX_MALLOC_BYTES:
32553:         return rt->gcMaxMallocBytes;
24313:       case JSGC_STACKPOOL_LIFESPAN:
24313:         return rt->gcEmptyArenaPoolLifespan;
32553:       case JSGC_TRIGGER_FACTOR:
32553:         return rt->gcTriggerFactor;
24313:       case JSGC_BYTES:
24313:         return rt->gcBytes;
24313:       default:
24313:         JS_ASSERT(key == JSGC_NUMBER);
24313:         return rt->gcNumber;
    1:     }
    1: }
    1: 
27884: JS_PUBLIC_API(void)
27884: JS_SetGCParameterForThread(JSContext *cx, JSGCParamKey key, uint32 value)
27884: {
27884:     JS_ASSERT(key == JSGC_MAX_CODE_CACHE_BYTES);
27885: #ifdef JS_TRACER
37741:     SetMaxCodeCacheBytes(cx, value);
27885: #endif
27884: }
27884: 
27884: JS_PUBLIC_API(uint32)
27884: JS_GetGCParameterForThread(JSContext *cx, JSGCParamKey key)
27884: {
27884:     JS_ASSERT(key == JSGC_MAX_CODE_CACHE_BYTES);
27885: #ifdef JS_TRACER
27884:     return JS_THREAD_DATA(cx)->traceMonitor.maxCodeCacheBytes;
27885: #else
27885:     return 0;
27885: #endif
27884: }
27884: 
36712: JS_PUBLIC_API(void)
36712: JS_FlushCaches(JSContext *cx)
36712: {
36714: #ifdef JS_TRACER
37741:     FlushJITCache(cx);
36714: #endif
36712: }
36712: 
    1: JS_PUBLIC_API(intN)
    1: JS_AddExternalStringFinalizer(JSStringFinalizeOp finalizer)
    1: {
    1:     return js_ChangeExternalStringFinalizer(NULL, finalizer);
    1: }
    1: 
    1: JS_PUBLIC_API(intN)
    1: JS_RemoveExternalStringFinalizer(JSStringFinalizeOp finalizer)
    1: {
    1:     return js_ChangeExternalStringFinalizer(finalizer, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewExternalString(JSContext *cx, jschar *chars, size_t length, intN type)
    1: {
    1:     CHECK_REQUEST(cx);
33581:     JS_ASSERT(uintN(type) < JS_EXTERNAL_STRING_LIMIT);
33581: 
33581:     JSString *str = js_NewGCExternalString(cx, uintN(type));
    1:     if (!str)
    1:         return NULL;
29366:     str->initFlat(chars, length);
53592:     cx->runtime->updateMallocCounter((length + 1) * sizeof(jschar));
    1:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(intN)
    1: JS_GetExternalStringGCType(JSRuntime *rt, JSString *str)
    1: {
32686:     /*
32686:      * No need to test this in js_GetExternalStringGCType, which asserts its
32686:      * inverse instead of wasting cycles on testing a condition we can ensure
32686:      * by auditing in-VM calls to the js_... helper.
32686:      */
32686:     if (JSString::isStatic(str))
32686:         return -1;
32686: 
 8005:     return js_GetExternalStringGCType(str);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetThreadStackLimit(JSContext *cx, jsuword limitAddr)
    1: {
    1: #if JS_STACK_GROWTH_DIRECTION > 0
    1:     if (limitAddr == 0)
42740:         limitAddr = jsuword(-1);
    1: #endif
    1:     cx->stackLimit = limitAddr;
    1: }
    1: 
 5344: JS_PUBLIC_API(void)
42740: JS_SetNativeStackQuota(JSContext *cx, size_t stackSize)
42740: {
42740: #ifdef JS_THREADSAFE
42740:     JS_ASSERT(cx->thread);
42740: #endif
42740: 
42740: #if JS_STACK_GROWTH_DIRECTION > 0
42740:     if (stackSize == 0) {
42740:         cx->stackLimit = jsuword(-1);
42740:     } else {
43229:         jsuword stackBase = reinterpret_cast<jsuword>(JS_THREAD_DATA(cx)->nativeStackBase);
42740:         JS_ASSERT(stackBase <= size_t(-1) - stackSize);
42740:         cx->stackLimit = stackBase + stackSize - 1;
42740:     }
42740: #else
42740:     if (stackSize == 0) {
42740:         cx->stackLimit = 0;
42740:     } else {
43229:         jsuword stackBase = reinterpret_cast<jsuword>(JS_THREAD_DATA(cx)->nativeStackBase);
42740:         JS_ASSERT(stackBase >= stackSize);
42740:         cx->stackLimit = stackBase - (stackSize - 1);
42740:     }
42740: #endif
42740: }
42740: 
42740: JS_PUBLIC_API(void)
 5344: JS_SetScriptStackQuota(JSContext *cx, size_t quota)
 5344: {
 5344:     cx->scriptStackQuota = quota;
 5344: }
 5344: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyIdArray(JSContext *cx, JSIdArray *ida)
    1: {
47459:     cx->free(ida);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToId(JSContext *cx, jsval v, jsid *idp)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
48470:     return ValueToId(cx, Valueify(v), idp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IdToValue(JSContext *cx, jsid id, jsval *vp)
    1: {
    1:     CHECK_REQUEST(cx);
48470:     *vp = IdToJsval(id);
47485:     assertSameCompartment(cx, *vp);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
48470: JS_PropertyStub(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EnumerateStub(JSContext *cx, JSObject *obj)
    1: {
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
48470: JS_ResolveStub(JSContext *cx, JSObject *obj, jsid id)
    1: {
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ConvertStub(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
    1: {
40867:     JS_ASSERT(type != JSTYPE_OBJECT && type != JSTYPE_FUNCTION);
48470:     return js_TryValueOf(cx, obj, type, Valueify(vp));
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_FinalizeStub(JSContext *cx, JSObject *obj)
48470: {}
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_InitClass(JSContext *cx, JSObject *obj, JSObject *parent_proto,
    1:              JSClass *clasp, JSNative constructor, uintN nargs,
    1:              JSPropertySpec *ps, JSFunctionSpec *fs,
    1:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
    1: {
25897:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, parent_proto);
48470:     return js_InitClass(cx, obj, parent_proto, Valueify(clasp),
48470:                         Valueify(constructor), nargs,
28086:                         ps, fs, static_ps, static_fs);
25887: }
25887: 
    1: #ifdef JS_THREADSAFE
    1: JS_PUBLIC_API(JSClass *)
    1: JS_GetClass(JSContext *cx, JSObject *obj)
    1: {
48470:     return Jsvalify(obj->getClass());
    1: }
    1: #else
    1: JS_PUBLIC_API(JSClass *)
    1: JS_GetClass(JSObject *obj)
    1: {
48470:     return Jsvalify(obj->getClass());
    1: }
    1: #endif
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_InstanceOf(JSContext *cx, JSObject *obj, JSClass *clasp, jsval *argv)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
48470:     return InstanceOf(cx, obj, Valueify(clasp), Valueify(argv));
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
47485:     assertSameCompartment(cx, obj, v);
48547:     return HasInstance(cx, obj, Valueify(&v), bp);
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetPrivate(JSContext *cx, JSObject *obj)
    1: {
31452:     return obj->getPrivate();
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetPrivate(JSContext *cx, JSObject *obj, void *data)
    1: {
32684:     obj->setPrivate(data);
32684:     return true;
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
43229: JS_GetInstancePrivate(JSContext *cx, JSObject *obj, JSClass *clasp, jsval *argv)
    1: {
48470:     if (!InstanceOf(cx, obj, Valueify(clasp), Valueify(argv)))
    1:         return NULL;
32684:     return obj->getPrivate();
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetPrototype(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
39928:     proto = obj->getProto();
    1: 
    1:     /* Beware ref to dead object (we may be called from obj's finalizer). */
    1:     return proto && proto->map ? proto : NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetPrototype(JSContext *cx, JSObject *obj, JSObject *proto)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, proto);
47465:     return SetProto(cx, obj, proto, JS_FALSE);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetParent(JSContext *cx, JSObject *obj)
    1: {
47485:     assertSameCompartment(cx, obj);
39930:     JSObject *parent = obj->getParent();
    1: 
    1:     /* Beware ref to dead object (we may be called from obj's finalizer). */
    1:     return parent && parent->map ? parent : NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetParent(JSContext *cx, JSObject *obj, JSObject *parent)
    1: {
    1:     CHECK_REQUEST(cx);
50472:     JS_ASSERT(parent || !obj->getParent());
47485:     assertSameCompartment(cx, obj, parent);
47465:     obj->setParent(parent);
47465:     return true;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetConstructor(JSContext *cx, JSObject *proto)
    1: {
48470:     Value cval;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, proto);
19712:     {
19712:         JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
19712: 
31501:         if (!proto->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.constructorAtom), &cval))
    1:             return NULL;
    1:     }
48470:     JSObject *funobj;
48470:     if (!IsFunctionObject(cval, &funobj)) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_CONSTRUCTOR,
40826:                              proto->getClass()->name);
    1:         return NULL;
    1:     }
48470:     return &cval.toObject();
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetObjectId(JSContext *cx, JSObject *obj, jsid *idp)
    1: {
47485:     assertSameCompartment(cx, obj);
    1:     *idp = OBJECT_TO_JSID(obj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
43286: JS_NewGlobalObject(JSContext *cx, JSClass *clasp)
43286: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43286:     CHECK_REQUEST(cx);
43286:     JS_ASSERT(clasp->flags & JSCLASS_IS_GLOBAL);
50450:     JSObject *obj = NewNonFunction<WithProto::Given>(cx, Valueify(clasp), NULL, NULL);
55606:     if (!obj)
53858:         return NULL;
55606: 
57806:     obj->syncSpecialEquality();
57806:     
55606:     /* Construct a regexp statics object for this global object. */
56553:     JSObject *res = regexp_statics_construct(cx, obj);
53858:     if (!res ||
53858:         !js_SetReservedSlot(cx, obj, JSRESERVED_GLOBAL_REGEXP_STATICS,
53858:                             ObjectValue(*res))) {
53858:         return NULL;
53858:     }
53858: 
43286:     return obj;
43286: }
43286: 
43286: JS_PUBLIC_API(JSObject *)
47516: JS_NewCompartmentAndGlobalObject(JSContext *cx, JSClass *clasp, JSPrincipals *principals)
47498: {
47498:     CHECK_REQUEST(cx);
47516:     JSCompartment *compartment = NewCompartment(cx, principals);
47498:     if (!compartment)
47498:         return NULL;
47498: 
47498:     JSCompartment *saved = cx->compartment;
47498:     cx->compartment = compartment;
47498:     JSObject *obj = JS_NewGlobalObject(cx, clasp);
47498:     cx->compartment = saved;
47498: 
47498:     return obj;
47498: }
47498: 
47498: JS_PUBLIC_API(JSObject *)
48470: JS_NewObject(JSContext *cx, JSClass *jsclasp, JSObject *proto, JSObject *parent)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, proto, parent);
50450: 
48470:     Class *clasp = Valueify(jsclasp);
    1:     if (!clasp)
    1:         clasp = &js_ObjectClass;    /* default class is Object */
50450: 
50450:     JS_ASSERT(clasp != &js_FunctionClass);
43286:     JS_ASSERT(!(clasp->flags & JSCLASS_IS_GLOBAL));
50450: 
50450:     JSObject *obj = NewNonFunction<WithProto::Class>(cx, clasp, proto, parent);
57806:     if (obj)
57806:         obj->syncSpecialEquality();
50450: 
43286:     JS_ASSERT_IF(obj, obj->getParent());
43286:     return obj;
 3624: }
 3624: 
11700: JS_PUBLIC_API(JSObject *)
48470: JS_NewObjectWithGivenProto(JSContext *cx, JSClass *jsclasp, JSObject *proto, JSObject *parent)
11700: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
11700:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, proto, parent);
50450: 
48470:     Class *clasp = Valueify(jsclasp);
11700:     if (!clasp)
11700:         clasp = &js_ObjectClass;    /* default class is Object */
50450: 
50450:     JS_ASSERT(clasp != &js_FunctionClass);
43286:     JS_ASSERT(!(clasp->flags & JSCLASS_IS_GLOBAL));
50450: 
57806:     JSObject *obj = NewNonFunction<WithProto::Given>(cx, clasp, proto, parent);
57806:     if (obj)
57806:         obj->syncSpecialEquality();
57806:     return obj;
    1: }
    1: 
53557: JS_PUBLIC_API(JSObject *)
53557: JS_NewObjectForConstructor(JSContext *cx, const jsval *vp)
53557: {
53557:     CHECK_REQUEST(cx);
53557:     assertSameCompartment(cx, *vp);
53557: 
55503:     return js_CreateThis(cx, JSVAL_TO_OBJECT(*vp));
53557: }
53557: 
    1: JS_PUBLIC_API(JSBool)
54565: JS_IsExtensible(JSObject *obj)
54565: {
54565:     return obj->isExtensible();
54565: }
54565: 
54565: JS_PUBLIC_API(JSBool)
54563: JS_FreezeObject(JSContext *cx, JSObject *obj)
    1: {
47485:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
47485: 
54563:     return obj->freeze(cx);
54563: }
54563: 
54563: JS_PUBLIC_API(JSBool)
54563: JS_DeepFreezeObject(JSContext *cx, JSObject *obj)
54563: {
54563:     CHECK_REQUEST(cx);
54563:     assertSameCompartment(cx, obj);
54563: 
54563:     /* Assume that non-extensible objects are already deep-frozen, to avoid divergence. */
54563:     if (obj->isExtensible())
52503:         return true;
    1: 
54563:     if (!obj->freeze(cx))
52503:         return false;
22452: 
    1:     /* Walk slots in obj and if any value is a non-null object, seal it. */
54563:     for (uint32 i = 0, n = obj->slotSpan(); i < n; ++i) {
48470:         const Value &v = obj->getSlot(i);
48470:         if (v.isPrimitive())
    1:             continue;
54563:         if (!JS_DeepFreezeObject(cx, &v.toObject()))
52503:             return false;
52503:     }
54563: 
52503:     return true;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
48470: JS_ConstructObject(JSContext *cx, JSClass *jsclasp, JSObject *proto, JSObject *parent)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, proto, parent);
48470:     Class *clasp = Valueify(jsclasp);
    1:     if (!clasp)
    1:         clasp = &js_ObjectClass;    /* default class is Object */
    1:     return js_ConstructObject(cx, clasp, proto, parent, 0, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
48470: JS_ConstructObjectWithArguments(JSContext *cx, JSClass *jsclasp, JSObject *proto,
    1:                                 JSObject *parent, uintN argc, jsval *argv)
    1: {
    1:     CHECK_REQUEST(cx);
48470:     assertSameCompartment(cx, proto, parent, JSValueArray(argv, argc));
48470:     Class *clasp = Valueify(jsclasp);
    1:     if (!clasp)
    1:         clasp = &js_ObjectClass;    /* default class is Object */
48470:     return js_ConstructObject(cx, clasp, proto, parent, argc, Valueify(argv));
    1: }
    1: 
    1: static JSBool
43228: LookupPropertyById(JSContext *cx, JSObject *obj, jsid id, uintN flags,
43228:                    JSObject **objp, JSProperty **propp)
43228: {
43231:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, id);
43231: 
43228:     JSAutoResolveFlags rf(cx, flags);
43228:     id = js_CheckForStringIndex(id);
43228:     return obj->lookupProperty(cx, id, objp, propp);
43228: }
43228: 
43228: #define AUTO_NAMELEN(s,n)   (((n) == (size_t)-1) ? js_strlen(s) : (n))
43228: 
43228: static JSBool
48470: LookupResult(JSContext *cx, JSObject *obj, JSObject *obj2, jsid id,
48470:              JSProperty *prop, Value *vp)
43228: {
43228:     if (!prop) {
43228:         /* XXX bad API: no way to tell "not defined" from "void value" */
48470:         vp->setUndefined();
43228:         return JS_TRUE;
43228:     }
43228: 
43228:     if (obj2->isNative()) {
52503:         Shape *shape = (Shape *) prop;
52503: 
52503:         if (shape->isMethod()) {
52503:             AutoShapeRooter root(cx, shape);
52503:             vp->setObject(shape->methodObject());
52503:             return obj2->methodReadBarrier(cx, *shape, vp);
43228:         }
43228: 
43228:         /* Peek at the native property's slot value, without doing a Get. */
52503:         if (obj2->containsSlot(shape->slot))
56567:             *vp = obj2->nativeGetSlot(shape->slot);
48470:         else
48470:             vp->setBoolean(true);
43228:     } else if (obj2->isDenseArray()) {
48470:         return js_GetDenseArrayElementValue(cx, obj2, id, vp);
43228:     } else {
43228:         /* XXX bad API: no way to return "defined but value unknown" */
48470:         vp->setBoolean(true);
43228:     }
43290:     return true;
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_LookupPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
43228: {
43228:     JSObject *obj2;
43228:     JSProperty *prop;
43228:     return LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &prop) &&
48470:            LookupResult(cx, obj, obj2, id, prop, Valueify(vp));
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_LookupElement(JSContext *cx, JSObject *obj, jsint index, jsval *vp)
43228: {
43231:     return JS_LookupPropertyById(cx, obj, INT_TO_JSID(index), vp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_LookupProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp)
43228: {
43231:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43231:     return atom && JS_LookupPropertyById(cx, obj, ATOM_TO_JSID(atom), vp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_LookupUCProperty(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen, jsval *vp)
43228: {
43231:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
43231:     return atom && JS_LookupPropertyById(cx, obj, ATOM_TO_JSID(atom), vp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_LookupPropertyWithFlagsById(JSContext *cx, JSObject *obj, jsid id, uintN flags,
43229:                                JSObject **objp, jsval *vp)
43228: {
43228:     JSBool ok;
43228:     JSProperty *prop;
43228: 
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, id);
43228:     ok = obj->isNative()
43228:          ? js_LookupPropertyWithFlags(cx, obj, id, flags, objp, &prop) >= 0
43228:          : obj->lookupProperty(cx, id, objp, &prop);
48470:     return ok && LookupResult(cx, obj, *objp, id, prop, Valueify(vp));
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, const char *name, uintN flags, jsval *vp)
43228: {
43228:     JSObject *obj2;
43231:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43231:     return atom && JS_LookupPropertyWithFlagsById(cx, obj, ATOM_TO_JSID(atom), flags, &obj2, vp);
43231: }
43231: 
43231: JS_PUBLIC_API(JSBool)
43231: JS_HasPropertyById(JSContext *cx, JSObject *obj, jsid id, JSBool *foundp)
43231: {
43231:     JSObject *obj2;
43231:     JSProperty *prop;
56567:     JSBool ok = LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
56567:                                    &obj2, &prop);
56567:     *foundp = (prop != NULL);
56567:     return ok;
43229: }
43229: 
43229: JS_PUBLIC_API(JSBool)
43229: JS_HasElement(JSContext *cx, JSObject *obj, jsint index, JSBool *foundp)
43229: {
43231:     return JS_HasPropertyById(cx, obj, INT_TO_JSID(index), foundp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_HasProperty(JSContext *cx, JSObject *obj, const char *name, JSBool *foundp)
43228: {
43231:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43231:     return atom && JS_HasPropertyById(cx, obj, ATOM_TO_JSID(atom), foundp);
43231: }
43231: 
43231: JS_PUBLIC_API(JSBool)
43231: JS_HasUCProperty(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen, JSBool *foundp)
43231: {
43231:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
43231:     return atom && JS_HasPropertyById(cx, obj, ATOM_TO_JSID(atom), foundp);
43231: }
43231: 
43231: JS_PUBLIC_API(JSBool)
43231: JS_AlreadyHasOwnPropertyById(JSContext *cx, JSObject *obj, jsid id, JSBool *foundp)
43231: {
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, id);
43228: 
43228:     if (!obj->isNative()) {
43228:         JSObject *obj2;
43228:         JSProperty *prop;
43228: 
43229:         if (!LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
43228:                                 &obj2, &prop)) {
43228:             return JS_FALSE;
43228:         }
43228:         *foundp = (obj == obj2);
43228:         return JS_TRUE;
43228:     }
43228: 
52503:     *foundp = obj->nativeContains(id);
43228:     return JS_TRUE;
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_AlreadyHasOwnElement(JSContext *cx, JSObject *obj, jsint index, JSBool *foundp)
43228: {
43231:     return JS_AlreadyHasOwnPropertyById(cx, obj, INT_TO_JSID(index), foundp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_AlreadyHasOwnProperty(JSContext *cx, JSObject *obj, const char *name, JSBool *foundp)
43228: {
43231:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43231:     return atom && JS_AlreadyHasOwnPropertyById(cx, obj, ATOM_TO_JSID(atom), foundp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_AlreadyHasOwnUCProperty(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen,
43228:                            JSBool *foundp)
43228: {
43231:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
43231:     return atom && JS_AlreadyHasOwnPropertyById(cx, obj, ATOM_TO_JSID(atom), foundp);
43228: }
43228: 
43228: static JSBool
48470: DefinePropertyById(JSContext *cx, JSObject *obj, jsid id, const Value &value,
48470:                    PropertyOp getter, PropertyOp setter, uintN attrs,
20964:                    uintN flags, intN tinyid)
20964: {
43232:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, id, value,
47485:                             (attrs & JSPROP_GETTER)
47485:                             ? JS_FUNC_TO_DATA_PTR(JSObject *, getter)
47485:                             : NULL,
47485:                             (attrs & JSPROP_SETTER)
47485:                             ? JS_FUNC_TO_DATA_PTR(JSObject *, setter)
47485:                             : NULL);
43232: 
43232:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DECLARING);
40430:     if (flags != 0 && obj->isNative()) {
27575:         return !!js_DefineNativeProperty(cx, obj, id, value, getter, setter,
20964:                                          attrs, flags, tinyid, NULL);
20964:     }
32573:     return obj->defineProperty(cx, id, value, getter, setter, attrs);
20964: }
20964: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_DefinePropertyById(JSContext *cx, JSObject *obj, jsid id, jsval value,
43228:                       JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
43228: {
48470:     return DefinePropertyById(cx, obj, id, Valueify(value), Valueify(getter),
48470:                               Valueify(setter), attrs, 0, 0);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_DefineElement(JSContext *cx, JSObject *obj, jsint index, jsval value,
43228:                  JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
43228: {
48470:     return DefinePropertyById(cx, obj, INT_TO_JSID(index), Valueify(value),
48470:                               Valueify(getter), Valueify(setter), attrs, 0, 0);
43228: }
43228: 
20964: static JSBool
48470: DefineProperty(JSContext *cx, JSObject *obj, const char *name, const Value &value,
48470:                PropertyOp getter, PropertyOp setter, uintN attrs,
    1:                uintN flags, intN tinyid)
    1: {
    1:     jsid id;
    1:     JSAtom *atom;
    1: 
    1:     if (attrs & JSPROP_INDEX) {
40292:         id = INT_TO_JSID(intptr_t(name));
    1:         atom = NULL;
    1:         attrs &= ~JSPROP_INDEX;
    1:     } else {
    1:         atom = js_Atomize(cx, name, strlen(name), 0);
    1:         if (!atom)
    1:             return JS_FALSE;
    1:         id = ATOM_TO_JSID(atom);
    1:     }
43229:     return DefinePropertyById(cx, obj, id, value, getter, setter, attrs, flags, tinyid);
    1: }
    1: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_DefineProperty(JSContext *cx, JSObject *obj, const char *name, jsval value,
43228:                   JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
43228: {
48470:     return DefineProperty(cx, obj, name, Valueify(value), Valueify(getter),
48470:                           Valueify(setter), attrs, 0, 0);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_DefinePropertyWithTinyId(JSContext *cx, JSObject *obj, const char *name, int8 tinyid,
43229:                             jsval value, JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
43228: {
48470:     return DefineProperty(cx, obj, name, Valueify(value), Valueify(getter),
52503:                           Valueify(setter), attrs, Shape::HAS_SHORTID, tinyid);
43228: }
    1: 
    1: static JSBool
43229: DefineUCProperty(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen,
48470:                  const Value &value, PropertyOp getter, PropertyOp setter, uintN attrs,
    1:                  uintN flags, intN tinyid)
    1: {
43232:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
43232:     return atom && DefinePropertyById(cx, obj, ATOM_TO_JSID(atom), value, getter, setter, attrs,
43232:                                       flags, tinyid);
    1: }
    1: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_DefineUCProperty(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen,
43229:                     jsval value, JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
43228: {
48470:     return DefineUCProperty(cx, obj, name, namelen, Valueify(value),
48470:                             Valueify(getter), Valueify(setter), attrs, 0, 0);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_DefineUCPropertyWithTinyId(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen,
43229:                               int8 tinyid, jsval value, JSPropertyOp getter, JSPropertyOp setter,
43228:                               uintN attrs)
43228: {
48470:     return DefineUCProperty(cx, obj, name, namelen, Valueify(value), Valueify(getter),
52503:                             Valueify(setter), attrs, Shape::HAS_SHORTID, tinyid);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_DefineOwnProperty(JSContext *cx, JSObject *obj, jsid id, jsval descriptor, JSBool *bp)
43228: {
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, id, descriptor);
48470:     return js_DefineOwnProperty(cx, obj, id, Valueify(descriptor), bp);
43228: }
43228: 
    1: JS_PUBLIC_API(JSObject *)
48470: JS_DefineObject(JSContext *cx, JSObject *obj, const char *name, JSClass *jsclasp,
    1:                 JSObject *proto, uintN attrs)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, proto);
50450: 
48470:     Class *clasp = Valueify(jsclasp);
    1:     if (!clasp)
    1:         clasp = &js_ObjectClass;    /* default class is Object */
50450: 
50450:     JSObject *nobj = NewObject<WithProto::Class>(cx, clasp, proto, obj);
    1:     if (!nobj)
    1:         return NULL;
50450: 
57806:     nobj->syncSpecialEquality();
57806: 
48470:     if (!DefineProperty(cx, obj, name, ObjectValue(*nobj), NULL, NULL, attrs, 0, 0))
    1:         return NULL;
50450: 
    1:     return nobj;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DefineConstDoubles(JSContext *cx, JSObject *obj, JSConstDoubleSpec *cds)
    1: {
    1:     JSBool ok;
19712:     uintN attrs;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     for (ok = JS_TRUE; cds->name; cds++) {
48470:         Value value = DoubleValue(cds->dval);
19712:         attrs = cds->flags;
19712:         if (!attrs)
19712:             attrs = JSPROP_READONLY | JSPROP_PERMANENT;
19712:         ok = DefineProperty(cx, obj, cds->name, value, NULL, NULL, attrs, 0, 0);
    1:         if (!ok)
    1:             break;
    1:     }
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DefineProperties(JSContext *cx, JSObject *obj, JSPropertySpec *ps)
    1: {
    1:     JSBool ok;
    1: 
43232:     for (ok = true; ps->name; ps++) {
48470:         ok = DefineProperty(cx, obj, ps->name, UndefinedValue(),
48470:                             Valueify(ps->getter), Valueify(ps->setter),
52503:                             ps->flags, Shape::HAS_SHORTID, ps->tinyid);
    1:         if (!ok)
    1:             break;
    1:     }
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_AliasProperty(JSContext *cx, JSObject *obj, const char *name, const char *alias)
    1: {
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     JSBool ok;
52503:     Shape *shape;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
43231: 
43231:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43231:     if (!atom)
43231:         return JS_FALSE;
43231:     if (!LookupPropertyById(cx, obj, ATOM_TO_JSID(atom), JSRESOLVE_QUALIFIED, &obj2, &prop))
    1:         return JS_FALSE;
    1:     if (!prop) {
    1:         js_ReportIsNotDefined(cx, name);
    1:         return JS_FALSE;
    1:     }
40430:     if (obj2 != obj || !obj->isNative()) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_ALIAS,
40826:                              alias, name, obj2->getClass()->name);
    1:         return JS_FALSE;
    1:     }
    1:     atom = js_Atomize(cx, alias, strlen(alias), 0);
    1:     if (!atom) {
    1:         ok = JS_FALSE;
    1:     } else {
52503:         shape = (Shape *)prop;
    1:         ok = (js_AddNativeProperty(cx, obj, ATOM_TO_JSID(atom),
52503:                                    shape->getter(), shape->setter(), shape->slot,
52503:                                    shape->attributes(), shape->getFlags() | Shape::ALIAS,
52503:                                    shape->shortid)
    1:               != NULL);
    1:     }
    1:     return ok;
    1: }
    1: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_AliasElement(JSContext *cx, JSObject *obj, const char *name, jsint alias)
43228: {
43228:     JSObject *obj2;
43228:     JSProperty *prop;
52503:     Shape *shape;
43228: 
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
43231: 
43231:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43231:     if (!atom)
43231:         return JS_FALSE;
43231:     if (!LookupPropertyById(cx, obj, ATOM_TO_JSID(atom), JSRESOLVE_QUALIFIED, &obj2, &prop))
43228:         return JS_FALSE;
    1:     if (!prop) {
43228:         js_ReportIsNotDefined(cx, name);
43228:         return JS_FALSE;
43228:     }
43228:     if (obj2 != obj || !obj->isNative()) {
43228:         char numBuf[12];
43228:         JS_snprintf(numBuf, sizeof numBuf, "%ld", (long)alias);
43228:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_ALIAS,
43228:                              numBuf, name, obj2->getClass()->name);
43228:         return JS_FALSE;
43228:     }
52503:     shape = (Shape *)prop;
56567:     return js_AddNativeProperty(cx, obj, INT_TO_JSID(alias),
52503:                                 shape->getter(), shape->setter(), shape->slot,
52503:                                 shape->attributes(), shape->getFlags() | Shape::ALIAS,
52503:                                 shape->shortid)
56567:            != NULL;
    1: }
    1: 
    1: static JSBool
43233: GetPropertyDescriptorById(JSContext *cx, JSObject *obj, jsid id, uintN flags,
48470:                           JSBool own, PropertyDescriptor *desc)
    1: {
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1: 
26022:     if (!LookupPropertyById(cx, obj, id, flags, &obj2, &prop))
    1:         return JS_FALSE;
26022: 
26022:     if (!prop || (own && obj != obj2)) {
26022:         desc->obj = NULL;
26022:         desc->attrs = 0;
26022:         desc->getter = NULL;
26022:         desc->setter = NULL;
48470:         desc->value.setUndefined();
    1:         return JS_TRUE;
    1:     }
    1: 
26022:     desc->obj = obj2;
40430:     if (obj2->isNative()) {
52503:         Shape *shape = (Shape *) prop;
52503:         desc->attrs = shape->attributes();
52503: 
52503:         if (shape->isMethod()) {
48470:             desc->getter = desc->setter = PropertyStub;
52503:             desc->value.setObject(shape->methodObject());
42784:         } else {
52503:             desc->getter = shape->getter();
52503:             desc->setter = shape->setter();
52503:             if (obj2->containsSlot(shape->slot))
56567:                 desc->value = obj2->nativeGetSlot(shape->slot);
48470:             else
48470:                 desc->value.setUndefined();
42784:         }
52503:     } else {
52503:         if (obj2->isProxy()) {
42733:             JSAutoResolveFlags rf(cx, flags);
42733:             return own
55592:                    ? JSProxy::getOwnPropertyDescriptor(cx, obj2, id, false, desc)
55592:                    : JSProxy::getPropertyDescriptor(cx, obj2, id, false, desc);
52503:         }
43290:         if (!obj2->getAttributes(cx, id, &desc->attrs))
43290:             return false;
26022:         desc->getter = NULL;
26022:         desc->setter = NULL;
48470:         desc->value.setUndefined();
26022:     }
43290:     return true;
    1: }
    1: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_GetPropertyDescriptorById(JSContext *cx, JSObject *obj, jsid id, uintN flags,
43228:                              JSPropertyDescriptor *desc)
43228: {
48470:     return GetPropertyDescriptorById(cx, obj, id, flags, JS_FALSE, Valueify(desc));
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_GetPropertyAttrsGetterAndSetterById(JSContext *cx, JSObject *obj, jsid id,
24224:                                        uintN *attrsp, JSBool *foundp,
43229:                                        JSPropertyOp *getterp, JSPropertyOp *setterp)
43228: {
48470:     PropertyDescriptor desc;
43233:     if (!GetPropertyDescriptorById(cx, obj, id, JSRESOLVE_QUALIFIED, JS_FALSE, &desc))
43233:         return false;
26022: 
26022:     *attrsp = desc.attrs;
26022:     *foundp = (desc.obj != NULL);
26022:     if (getterp)
48470:         *getterp = Jsvalify(desc.getter);
26022:     if (setterp)
48470:         *setterp = Jsvalify(desc.setter);
43233:     return true;
24145: }
24145: 
24145: JS_PUBLIC_API(JSBool)
43228: JS_GetPropertyAttributes(JSContext *cx, JSObject *obj, const char *name,
43228:                          uintN *attrsp, JSBool *foundp)
43228: {
43233:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43233:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, ATOM_TO_JSID(atom),
43228:                                                           attrsp, foundp, NULL, NULL);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_GetUCPropertyAttributes(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen,
43228:                            uintN *attrsp, JSBool *foundp)
43228: {
43233:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
43233:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, ATOM_TO_JSID(atom),
43228:                                                           attrsp, foundp, NULL, NULL);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_GetPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj, const char *name,
43228:                                    uintN *attrsp, JSBool *foundp,
43229:                                    JSPropertyOp *getterp, JSPropertyOp *setterp)
43228: {
43233:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43233:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, ATOM_TO_JSID(atom),
43228:                                                           attrsp, foundp, getterp, setterp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_GetUCPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj,
43228:                                      const jschar *name, size_t namelen,
43228:                                      uintN *attrsp, JSBool *foundp,
43229:                                      JSPropertyOp *getterp, JSPropertyOp *setterp)
43228: {
43233:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
43233:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, ATOM_TO_JSID(atom),
43228:                                                           attrsp, foundp, getterp, setterp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
43228: {
43228:     CHECK_REQUEST(cx);
48470:     return js_GetOwnPropertyDescriptor(cx, obj, id, Valueify(vp));
43228: }
43228: 
43228: static JSBool
43233: SetPropertyAttributesById(JSContext *cx, JSObject *obj, jsid id, uintN attrs, JSBool *foundp)
43228: {
43228:     JSObject *obj2;
43228:     JSProperty *prop;
43228: 
43233:     if (!LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &prop))
43290:         return false;
43228:     if (!prop || obj != obj2) {
43290:         *foundp = false;
43290:         return true;
43290:     }
43290:     JSBool ok = obj->isNative()
52503:                 ? js_SetNativeAttributes(cx, obj, (Shape *) prop, attrs)
43290:                 : obj->setAttributes(cx, id, &attrs);
43290:     if (ok)
43290:         *foundp = true;
43228:     return ok;
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
    1: JS_SetPropertyAttributes(JSContext *cx, JSObject *obj, const char *name,
    1:                          uintN attrs, JSBool *foundp)
    1: {
43233:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43233:     return atom && SetPropertyAttributesById(cx, obj, ATOM_TO_JSID(atom), attrs, foundp);
    1: }
    1: 
 7927: JS_PUBLIC_API(JSBool)
43229: JS_SetUCPropertyAttributes(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen,
43228:                            uintN attrs, JSBool *foundp)
43228: {
43233:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
43233:     return atom && SetPropertyAttributesById(cx, obj, ATOM_TO_JSID(atom), attrs, foundp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_GetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
43228: {
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, id);
43228:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
48470:     return obj->getProperty(cx, id, Valueify(vp));
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
56211: JS_GetPropertyByIdDefault(JSContext *cx, JSObject *obj, jsid id, jsval def, jsval *vp)
56211: {
56211:     return GetPropertyDefault(cx, obj, id, Valueify(def), Valueify(vp));
56211: }
56211: 
56211: JS_PUBLIC_API(JSBool)
43228: JS_GetElement(JSContext *cx, JSObject *obj, jsint index, jsval *vp)
43228: {
43234:     return JS_GetPropertyById(cx, obj, INT_TO_JSID(index), vp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_GetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp)
 7927: {
43234:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43234:     return atom && JS_GetPropertyById(cx, obj, ATOM_TO_JSID(atom), vp);
 7927: }
 7927: 
    1: JS_PUBLIC_API(JSBool)
56211: JS_GetPropertyDefault(JSContext *cx, JSObject *obj, const char *name, jsval def, jsval *vp)
56211: {
56211:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
56211:     return atom && JS_GetPropertyByIdDefault(cx, obj, ATOM_TO_JSID(atom), def, vp);
56211: }
56211: 
56211: JS_PUBLIC_API(JSBool)
43229: JS_GetUCProperty(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen, jsval *vp)
43228: {
43234:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
43234:     return atom && JS_GetPropertyById(cx, obj, ATOM_TO_JSID(atom), vp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_GetMethodById(JSContext *cx, JSObject *obj, jsid id, JSObject **objp, jsval *vp)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, id);
48470:     if (!js_GetMethod(cx, obj, id, JSGET_METHOD_BARRIER, Valueify(vp)))
    1:         return JS_FALSE;
26187:     if (objp)
    1:         *objp = obj;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_GetMethod(JSContext *cx, JSObject *obj, const char *name, JSObject **objp, jsval *vp)
    1: {
43234:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43234:     return atom && JS_GetMethodById(cx, obj, ATOM_TO_JSID(atom), objp, vp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43228: JS_SetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
43228: {
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, id);
43228:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
54169:     return obj->setProperty(cx, id, Valueify(vp), false);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_SetElement(JSContext *cx, JSObject *obj, jsint index, jsval *vp)
43228: {
43234:     return JS_SetPropertyById(cx, obj, INT_TO_JSID(index), vp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
    1: JS_SetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp)
    1: {
43234:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43234:     return atom && JS_SetPropertyById(cx, obj, ATOM_TO_JSID(atom), vp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_SetUCProperty(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen, jsval *vp)
43228: {
43234:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
43234:     return atom && JS_SetPropertyById(cx, obj, ATOM_TO_JSID(atom), vp);
20964: }
20964: 
20964: JS_PUBLIC_API(JSBool)
43228: JS_DeletePropertyById2(JSContext *cx, JSObject *obj, jsid id, jsval *rval)
43228: {
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, id);
43228:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
54169:     return obj->deleteProperty(cx, id, Valueify(rval), false);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_DeleteElement2(JSContext *cx, JSObject *obj, jsint index, jsval *rval)
43228: {
43234:     return JS_DeletePropertyById2(cx, obj, INT_TO_JSID(index), rval);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_DeleteProperty2(JSContext *cx, JSObject *obj, const char *name, jsval *rval)
    1: {
43234:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
43234:     return atom && JS_DeletePropertyById2(cx, obj, ATOM_TO_JSID(atom), rval);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_DeleteUCProperty2(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen, jsval *rval)
 7927: {
43234:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
43234:     return atom && JS_DeletePropertyById2(cx, obj, ATOM_TO_JSID(atom), rval);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43228: JS_DeletePropertyById(JSContext *cx, JSObject *obj, jsid id)
43228: {
43228:     jsval junk;
43228:     return JS_DeletePropertyById2(cx, obj, id, &junk);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DeleteElement(JSContext *cx, JSObject *obj, jsint index)
    1: {
    1:     jsval junk;
    1:     return JS_DeleteElement2(cx, obj, index, &junk);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43228: JS_DeleteProperty(JSContext *cx, JSObject *obj, const char *name)
43228: {
43228:     jsval junk;
43228:     return JS_DeleteProperty2(cx, obj, name, &junk);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearScope(JSContext *cx, JSObject *obj)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
    1: 
48622:     JSFinalizeOp clearOp = obj->getOps()->clear;
48622:     if (clearOp)
48622:         clearOp(cx, obj);
48622: 
48622:     if (obj->isNative())
48622:         js_ClearNative(cx, obj);
    1: 
    1:     /* Clear cached class objects on the global object. */
40826:     if (obj->getClass()->flags & JSCLASS_IS_GLOBAL) {
 3164:         int key;
    1: 
43258:         for (key = JSProto_Null; key < JSProto_LIMIT * 3; key++)
    1:             JS_SetReservedSlot(cx, obj, key, JSVAL_VOID);
    1:     }
47602: 
47602:     js_InitRandom(cx);
    1: }
    1: 
    1: JS_PUBLIC_API(JSIdArray *)
    1: JS_Enumerate(JSContext *cx, JSObject *obj)
    1: {
42641:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
43290: 
48470:     AutoIdVector props(cx);
    1:     JSIdArray *ida;
54562:     if (!GetPropertyNames(cx, obj, JSITER_OWNONLY, &props) || !VectorToIdArray(cx, props, &ida))
42641:         return false;
42641:     for (size_t n = 0; n < size_t(ida->length); ++n)
42641:         JS_ASSERT(js_CheckForStringIndex(ida->vector[n]) == ida->vector[n]);
42641:     return ida;
    1: }
    1: 
    1: /*
    1:  * XXX reverse iterator for properties, unreverse and meld with jsinterp.c's
    1:  *     prop_iterator_class somehow...
31501:  * + preserve the obj->enumerate API while optimizing the native object case
52503:  * + native case here uses a Shape *, but that iterates in reverse!
    1:  * + so we make non-native match, by reverse-iterating after JS_Enumerating
    1:  */
55746: const uint32 JSSLOT_ITER_INDEX = 0;
    1: 
    1: static void
    1: prop_iter_finalize(JSContext *cx, JSObject *obj)
    1: {
31452:     void *pdata = obj->getPrivate();
31452:     if (!pdata)
    1:         return;
    1: 
55746:     if (obj->getSlot(JSSLOT_ITER_INDEX).toInt32() >= 0) {
    1:         /* Non-native case: destroy the ida enumerated when obj was created. */
31452:         JSIdArray *ida = (JSIdArray *) pdata;
    1:         JS_DestroyIdArray(cx, ida);
    1:     }
    1: }
    1: 
  583: static void
  583: prop_iter_trace(JSTracer *trc, JSObject *obj)
    1: {
31452:     void *pdata = obj->getPrivate();
31452:     if (!pdata)
31452:         return;
31452: 
55746:     if (obj->getSlot(JSSLOT_ITER_INDEX).toInt32() < 0) {
    1:         /* Native case: just mark the next property to visit. */
52503:         ((Shape *) pdata)->trace(trc);
    1:     } else {
    1:         /* Non-native case: mark each id in the JSIdArray private. */
31452:         JSIdArray *ida = (JSIdArray *) pdata;
48470:         MarkIdRange(trc, ida->length, ida->vector, "prop iter");
48470:     }
48470: }
48470: 
48470: static Class prop_iter_class = {
    1:     "PropertyIterator",
  583:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) |
  583:     JSCLASS_MARK_IS_TRACE,
48622:     PropertyStub,   /* addProperty */
48622:     PropertyStub,   /* delProperty */
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub,
48622:     prop_iter_finalize,
48622:     NULL,           /* reserved0   */
48622:     NULL,           /* checkAccess */
48622:     NULL,           /* call        */
48622:     NULL,           /* construct   */
48622:     NULL,           /* xdrObject   */
48622:     NULL,           /* hasInstance */
48622:     JS_CLASS_TRACE(prop_iter_trace)
    1: };
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_NewPropertyIterator(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *iterobj;
52503:     const void *pdata;
    1:     jsint index;
    1:     JSIdArray *ida;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
50450:     iterobj = NewNonFunction<WithProto::Class>(cx, &prop_iter_class, NULL, obj);
    1:     if (!iterobj)
    1:         return NULL;
    1: 
40430:     if (obj->isNative()) {
52503:         /* Native case: start with the last property in obj. */
52503:         pdata = obj->lastProperty();
    1:         index = -1;
    1:     } else {
    1:         /*
    1:          * Non-native case: enumerate a JSIdArray and keep it via private.
    1:          *
    1:          * Note: we have to make sure that we root obj around the call to
    1:          * JS_Enumerate to protect against multiple allocations under it.
    1:          */
48470:         AutoObjectRooter tvr(cx, iterobj);
    1:         ida = JS_Enumerate(cx, obj);
    1:         if (!ida)
31452:             return NULL;
    1:         pdata = ida;
    1:         index = ida->length;
    1:     }
    1: 
    1:     /* iterobj cannot escape to other threads here. */
52503:     iterobj->setPrivate(const_cast<void *>(pdata));
55746:     iterobj->getSlotRef(JSSLOT_ITER_INDEX).setInt32(index);
    1:     return iterobj;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_NextProperty(JSContext *cx, JSObject *iterobj, jsid *idp)
    1: {
    1:     jsint i;
    1:     JSObject *obj;
52503:     const Shape *shape;
    1:     JSIdArray *ida;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, iterobj);
55746:     i = iterobj->getSlot(JSSLOT_ITER_INDEX).toInt32();
    1:     if (i < 0) {
    1:         /* Native case: private data is a property tree node pointer. */
39930:         obj = iterobj->getParent();
40430:         JS_ASSERT(obj->isNative());
52503:         shape = (Shape *) iterobj->getPrivate();
    1: 
    1:         /*
52503:          * If the next property mapped by obj in the property tree ancestor
52503:          * line is not enumerable, or it's an alias, skip it and keep on trying
52503:          * to find an enumerable property that is still in obj.
    1:          */
52503:         while (shape->previous() && (!shape->enumerable() || shape->isAlias()))
52503:             shape = shape->previous();
52503: 
52503:         if (!shape->previous()) {
52503:             JS_ASSERT(JSID_IS_EMPTY(shape->id));
48470:             *idp = JSID_VOID;
    1:         } else {
52503:             iterobj->setPrivate(const_cast<Shape *>(shape->previous()));
52503:             *idp = shape->id;
    1:         }
    1:     } else {
    1:         /* Non-native case: use the ida enumerated when iterobj was created. */
32684:         ida = (JSIdArray *) iterobj->getPrivate();
    1:         JS_ASSERT(i <= ida->length);
55479:         STATIC_ASSUME(i <= ida->length);
    1:         if (i == 0) {
48470:             *idp = JSID_VOID;
    1:         } else {
    1:             *idp = ida->vector[--i];
48470:             iterobj->setSlot(JSSLOT_ITER_INDEX, Int32Value(i));
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43228: JS_GetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval *vp)
43228: {
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
48470:     return js_GetReservedSlot(cx, obj, index, Valueify(vp));
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_SetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval v)
43228: {
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, v);
48470:     return js_SetReservedSlot(cx, obj, index, Valueify(v));
43228: }
43228: 
43228: JS_PUBLIC_API(JSObject *)
43228: JS_NewArrayObject(JSContext *cx, jsint length, jsval *vector)
43228: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43228:     CHECK_REQUEST(cx);
43228:     /* NB: jsuint cast does ToUint32. */
48470:     assertSameCompartment(cx, JSValueArray(vector, vector ? (jsuint)length : 0));
48470:     return js_NewArrayObject(cx, (jsuint)length, Valueify(vector));
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_IsArrayObject(JSContext *cx, JSObject *obj)
43228: {
47485:     assertSameCompartment(cx, obj);
56565:     return obj->isArray() ||
56565:            (obj->isWrapper() && JSWrapper::wrappedObject(obj)->isArray());
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_GetArrayLength(JSContext *cx, JSObject *obj, jsuint *lengthp)
43228: {
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
43228:     return js_GetLengthProperty(cx, obj, lengthp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_SetArrayLength(JSContext *cx, JSObject *obj, jsuint length)
43228: {
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
43228:     return js_SetLengthProperty(cx, obj, length);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43228: JS_HasArrayLength(JSContext *cx, JSObject *obj, jsuint *lengthp)
43228: {
43228:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
43228:     return js_HasLengthProperty(cx, obj, lengthp);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
    1: JS_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
    1:                jsval *vp, uintN *attrsp)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, id);
48470:     return CheckAccess(cx, obj, id, mode, Valueify(vp), attrsp);
    1: }
    1: 
    1: #ifdef JS_THREADSAFE
    1: JS_PUBLIC_API(jsrefcount)
    1: JS_HoldPrincipals(JSContext *cx, JSPrincipals *principals)
    1: {
    1:     return JS_ATOMIC_INCREMENT(&principals->refcount);
    1: }
    1: 
    1: JS_PUBLIC_API(jsrefcount)
    1: JS_DropPrincipals(JSContext *cx, JSPrincipals *principals)
    1: {
    1:     jsrefcount rc = JS_ATOMIC_DECREMENT(&principals->refcount);
    1:     if (rc == 0)
    1:         principals->destroy(cx, principals);
    1:     return rc;
    1: }
    1: #endif
    1: 
18870: JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_SetRuntimeSecurityCallbacks(JSRuntime *rt, JSSecurityCallbacks *callbacks)
18870: {
18870:     JSSecurityCallbacks *oldcallbacks;
18870: 
18870:     oldcallbacks = rt->securityCallbacks;
18870:     rt->securityCallbacks = callbacks;
18870:     return oldcallbacks;
18870: }
18870: 
18870: JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_GetRuntimeSecurityCallbacks(JSRuntime *rt)
18870: {
18870:   return rt->securityCallbacks;
18870: }
18870: 
18870: JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_SetContextSecurityCallbacks(JSContext *cx, JSSecurityCallbacks *callbacks)
18870: {
18870:     JSSecurityCallbacks *oldcallbacks;
18870: 
18870:     oldcallbacks = cx->securityCallbacks;
18870:     cx->securityCallbacks = callbacks;
18870:     return oldcallbacks;
18870: }
18870: 
18870: JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_GetSecurityCallbacks(JSContext *cx)
18870: {
18870:   return cx->securityCallbacks
18870:          ? cx->securityCallbacks
18870:          : cx->runtime->securityCallbacks;
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_NewFunction(JSContext *cx, JSNative native, uintN nargs, uintN flags,
    1:                JSObject *parent, const char *name)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, parent);
    1: 
    1:     if (!name) {
    1:         atom = NULL;
    1:     } else {
    1:         atom = js_Atomize(cx, name, strlen(name), 0);
    1:         if (!atom)
    1:             return NULL;
    1:     }
48470:     return js_NewFunction(cx, NULL, Valueify(native), nargs, flags, parent, atom);
    1: }
    1: 
57721: JS_PUBLIC_API(JSFunction *)
57721: JS_NewFunctionById(JSContext *cx, JSNative native, uintN nargs, uintN flags, JSObject *parent,
57721:                    jsid id)
57721: {
57721:     JS_ASSERT(JSID_IS_STRING(id));
57721:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
57721:     CHECK_REQUEST(cx);
57721:     assertSameCompartment(cx, parent);
57721: 
57721:     return js_NewFunction(cx, NULL, Valueify(native), nargs, flags, parent, JSID_TO_ATOM(id));
57721: }
57721: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_CloneFunctionObject(JSContext *cx, JSObject *funobj, JSObject *parent)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, parent);  // XXX no funobj for now
38604:     if (!parent) {
51446:         if (cx->hasfp())
56729:             parent = GetScopeChain(cx, cx->fp());
38604:         if (!parent)
38604:             parent = cx->globalObject;
38604:         JS_ASSERT(parent);
38604:     }
38604: 
40826:     if (funobj->getClass() != &js_FunctionClass) {
27012:         /*
27012:          * We cannot clone this object, so fail (we used to return funobj, bad
27012:          * idea, but we changed incompatibly to teach any abusers a lesson!).
27012:          */
48470:         Value v = ObjectValue(*funobj);
27012:         js_ReportIsNotFunction(cx, &v, 0);
27012:         return NULL;
27012:     }
27012: 
27012:     JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
52503:     if (!FUN_FLAT_CLOSURE(fun))
52503:         return CloneFunctionObject(cx, fun, parent);
27012: 
27012:     /*
27012:      * A flat closure carries its own environment, so why clone it? In case
27012:      * someone wants to mutate its fixed slots or add ad-hoc properties. API
27012:      * compatibility suggests we not return funobj and let callers mutate the
27012:      * returned object at will.
27012:      *
27012:      * But it's worse than that: API compatibility according to the test for
27012:      * bug 300079 requires we get "upvars" from parent and its ancestors! So
27012:      * we do that (grudgingly!). The scope chain ancestors are searched as if
27012:      * they were activations, respecting the skip field in each upvar's cookie
27012:      * but looking up the property by name instead of frame slot.
27012:      */
52503:     JSObject *clone = js_AllocFlatClosure(cx, fun, parent);
52503:     if (!clone)
27012:         return NULL;
27012: 
32723:     JSUpvarArray *uva = fun->u.i.script->upvars();
52503:     uint32 i = uva->length;
52503:     JS_ASSERT(i != 0);
52503: 
52503:     for (Shape::Range r(fun->lastUpvar()); i-- != 0; r.popFront()) {
27012:         JSObject *obj = parent;
47573:         int skip = uva->vector[i].level();
27111:         while (--skip > 0) {
27012:             if (!obj) {
27012:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
27012:                                      JSMSG_BAD_CLONE_FUNOBJ_SCOPE);
52503:                 return NULL;
27012:             }
39930:             obj = obj->getParent();
27012:         }
27012: 
52503:         if (!obj->getProperty(cx, r.front().id, clone->getFlatClosureUpvars() + i))
27012:             return NULL;
27012:     }
27012: 
27012:     return clone;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFunctionObject(JSFunction *fun)
    1: {
13427:     return FUN_OBJECT(fun);
    1: }
    1: 
    1: JS_PUBLIC_API(const char *)
    1: JS_GetFunctionName(JSFunction *fun)
    1: {
    1:     return fun->atom
    1:            ? JS_GetStringBytes(ATOM_TO_STRING(fun->atom))
    1:            : js_anonymous_str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_GetFunctionId(JSFunction *fun)
    1: {
    1:     return fun->atom ? ATOM_TO_STRING(fun->atom) : NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(uintN)
    1: JS_GetFunctionFlags(JSFunction *fun)
    1: {
    1:     return fun->flags;
    1: }
    1: 
    1: JS_PUBLIC_API(uint16)
    1: JS_GetFunctionArity(JSFunction *fun)
    1: {
    1:     return fun->nargs;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ObjectIsFunction(JSContext *cx, JSObject *obj)
    1: {
40826:     return obj->getClass() == &js_FunctionClass;
    1: }
    1: 
18907: static JSBool
53557: js_generic_native_method_dispatcher(JSContext *cx, uintN argc, Value *vp)
48470: {
    1:     JSFunctionSpec *fs;
    1:     JSObject *tmp;
53557:     Native native;
48470: 
48470:     fs = (JSFunctionSpec *) vp->toObject().getReservedSlot(0).toPrivate();
53557:     JS_ASSERT((fs->flags & JSFUN_GENERIC_NATIVE) != 0);
 4127: 
41988:     if (argc < 1) {
48470:         js_ReportMissingArg(cx, *vp, 0);
41988:         return JS_FALSE;
41988:     }
41988: 
48470:     if (vp[2].isPrimitive()) {
 4127:         /*
 4127:          * Make sure that this is an object or null, as required by the generic
 4127:          * functions.
 4127:          */
48470:         if (!js_ValueToObjectOrNull(cx, vp[2], &tmp))
 4127:             return JS_FALSE;
48470:         vp[2].setObjectOrNull(tmp);
 4127:     }
 4127: 
 4127:     /*
 4127:      * Copy all actual (argc) arguments down over our |this| parameter, vp[1],
 4127:      * which is almost always the class constructor object, e.g. Array.  Then
 4127:      * call the corresponding prototype native method with our first argument
 4127:      * passed as |this|.
 4127:      */
 4127:     memmove(vp + 1, vp + 2, argc * sizeof(jsval));
 4127: 
 4127:     /*
 4127:      * Follow Function.prototype.apply and .call by using the global object as
 4127:      * the 'this' param if no args.
 4127:      */
48470:     if (!ComputeThisFromArgv(cx, vp + 2))
 4127:         return JS_FALSE;
41988: 
25712:     /* Clear the last parameter in case too few arguments were passed. */
48470:     vp[2 + --argc].setUndefined();
 4127: 
20408:     native =
20408: #ifdef JS_TRACER
32669:              (fs->flags & JSFUN_TRCINFO)
53557:              ? JS_FUNC_TO_DATA_PTR(JSNativeTraceInfo *, fs->call)->native
20408:              :
20408: #endif
53557:                Valueify(fs->call);
20408:     return native(cx, argc, vp);
 4127: }
 4127: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DefineFunctions(JSContext *cx, JSObject *obj, JSFunctionSpec *fs)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     uintN flags;
    1:     JSObject *ctor;
    1:     JSFunction *fun;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
    1:     ctor = NULL;
    1:     for (; fs->name; fs++) {
    1:         flags = fs->flags;
    1: 
    1:         /*
    1:          * Define a generic arity N+1 static method for the arity N prototype
    1:          * method if flags contains JSFUN_GENERIC_NATIVE.
    1:          */
    1:         if (flags & JSFUN_GENERIC_NATIVE) {
    1:             if (!ctor) {
    1:                 ctor = JS_GetConstructor(cx, obj);
    1:                 if (!ctor)
    1:                     return JS_FALSE;
    1:             }
    1: 
    1:             flags &= ~JSFUN_GENERIC_NATIVE;
    1:             fun = JS_DefineFunction(cx, ctor, fs->name,
53557:                                     Jsvalify(js_generic_native_method_dispatcher),
20408:                                     fs->nargs + 1,
32669:                                     flags & ~JSFUN_TRCINFO);
    1:             if (!fun)
    1:                 return JS_FALSE;
    1: 
    1:             /*
    1:              * As jsapi.h notes, fs must point to storage that lives as long
    1:              * as fun->object lives.
    1:              */
48470:             Value priv = PrivateValue(fs);
48470:             if (!js_SetReservedSlot(cx, FUN_OBJECT(fun), 0, priv))
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         fun = JS_DefineFunction(cx, obj, fs->name, fs->call, fs->nargs, flags);
    1:         if (!fun)
    1:             return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_DefineFunction(JSContext *cx, JSObject *obj, const char *name, JSNative call,
    1:                   uintN nargs, uintN attrs)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
43235:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
57721:     if (!atom)
57721:         return NULL;
57721:     return js_DefineFunction(cx, obj, ATOM_TO_JSID(atom), Valueify(call), nargs, attrs);
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_DefineUCFunction(JSContext *cx, JSObject *obj,
    1:                     const jschar *name, size_t namelen, JSNative call,
    1:                     uintN nargs, uintN attrs)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
40340:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
43235:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
57721:     if (!atom)
57721:         return NULL;
57721:     return js_DefineFunction(cx, obj, ATOM_TO_JSID(atom), Valueify(call), nargs, attrs);
57721: }
57721: 
57721: extern JS_PUBLIC_API(JSFunction *)
57721: JS_DefineFunctionById(JSContext *cx, JSObject *obj, jsid id, JSNative call,
57721:                     uintN nargs, uintN attrs)
57721: {
57721:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
57721:     CHECK_REQUEST(cx);
57721:     assertSameCompartment(cx, obj);
57721:     return js_DefineFunction(cx, obj, id, Valueify(call), nargs, attrs);
43235: }
43235: 
43235: inline static void
43235: LAST_FRAME_EXCEPTION_CHECK(JSContext *cx, bool result)
43235: {
43235:     if (!result && !(cx->options & JSOPTION_DONT_REPORT_UNCAUGHT))
43235:         js_ReportUncaughtException(cx);
43235: }
43235: 
43235: inline static void
43235: LAST_FRAME_CHECKS(JSContext *cx, bool result)
43235: {
43235:     if (!JS_IsRunning(cx)) {
43235:         LAST_FRAME_EXCEPTION_CHECK(cx, result);
43235:     }
43235: }
43235: 
43235: inline static uint32 
43235: JS_OPTIONS_TO_TCFLAGS(JSContext *cx)
43235: {
43235:     return ((cx->options & JSOPTION_COMPILE_N_GO) ? TCF_COMPILE_N_GO : 0) | 
43235:            ((cx->options & JSOPTION_NO_SCRIPT_RVAL) ? TCF_NO_SCRIPT_RVAL : 0);
43235: }
43228: 
53848: extern JS_PUBLIC_API(JSScript *)
53848: JS_CompileUCScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
53848:                                        JSPrincipals *principals,
53848:                                        const jschar *chars, size_t length,
53848:                                        const char *filename, uintN lineno,
53848:                                        JSVersion version)
53848: {
53848:     AutoVersionAPI avi(cx, version);
53848:     return JS_CompileUCScriptForPrincipals(cx, obj, principals, chars, length, filename, lineno);
53848: }
53848: 
    1: JS_PUBLIC_API(JSScript *)
43229: JS_CompileUCScriptForPrincipals(JSContext *cx, JSObject *obj, JSPrincipals *principals,
43228:                                 const jschar *chars, size_t length,
    1:                                 const char *filename, uintN lineno)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, principals);
43235: 
43235:     uint32 tcflags = JS_OPTIONS_TO_TCFLAGS(cx) | TCF_NEED_MUTABLE_SCRIPT;
43235:     JSScript *script = Compiler::compileScript(cx, obj, NULL, principals, tcflags,
43228:                                                chars, length, NULL, filename, lineno);
51440:     if (script && !js_NewScriptObject(cx, script)) {
51440:         js_DestroyScript(cx, script);
51440:         script = NULL;
51440:     }
43228:     LAST_FRAME_CHECKS(cx, script);
    1:     return script;
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
43229: JS_CompileUCScript(JSContext *cx, JSObject *obj, const jschar *chars, size_t length,
43228:                    const char *filename, uintN lineno)
43228: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43235:     return JS_CompileUCScriptForPrincipals(cx, obj, NULL, chars, length, filename, lineno);
43228: }
43228: 
43228: JS_PUBLIC_API(JSScript *)
57678: JS_CompileScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
57678:                                      JSPrincipals *principals,
57678:                                      const char *bytes, size_t length,
57678:                                      const char *filename, uintN lineno,
57678:                                      JSVersion version)
57678: {
57678:     AutoVersionAPI ava(cx, version);
57678:     return JS_CompileScriptForPrincipals(cx, obj, principals, bytes, length, filename, lineno);   
57678: }
57678: 
57678: JS_PUBLIC_API(JSScript *)
    1: JS_CompileScriptForPrincipals(JSContext *cx, JSObject *obj,
    1:                               JSPrincipals *principals,
    1:                               const char *bytes, size_t length,
    1:                               const char *filename, uintN lineno)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     CHECK_REQUEST(cx);
43235: 
43235:     jschar *chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return NULL;
43235:     JSScript *script = JS_CompileUCScriptForPrincipals(cx, obj, principals, chars, length, filename, lineno);
30851:     cx->free(chars);
    1:     return script;
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
43229: JS_CompileScript(JSContext *cx, JSObject *obj, const char *bytes, size_t length,
    1:                  const char *filename, uintN lineno)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43235:     return JS_CompileScriptForPrincipals(cx, obj, NULL, bytes, length, filename, lineno);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_BufferIsCompilableUnit(JSContext *cx, JSObject *obj, const char *bytes, size_t length)
    1: {
    1:     jschar *chars;
    1:     JSBool result;
    1:     JSExceptionState *exnState;
    1:     JSErrorReporter older;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
    1:     chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return JS_TRUE;
    1: 
    1:     /*
    1:      * Return true on any out-of-memory error, so our caller doesn't try to
    1:      * collect more buffered source.
    1:      */
    1:     result = JS_TRUE;
    1:     exnState = JS_SaveExceptionState(cx);
27012:     {
40860:         Parser parser(cx);
40860:         if (parser.init(chars, length, NULL, NULL, 1)) {
    1:             older = JS_SetErrorReporter(cx, NULL);
40860:             if (!parser.parse(obj) &&
40860:                 parser.tokenStream.isUnexpectedEOF()) {
    1:                 /*
27012:                  * We ran into an error. If it was because we ran out of
27012:                  * source, we return false so our caller knows to try to
27012:                  * collect more buffered source.
    1:                  */
    1:                 result = JS_FALSE;
    1:             }
 6561:             JS_SetErrorReporter(cx, older);
27012:         }
 6561:     }
30851:     cx->free(chars);
    1:     JS_RestoreExceptionState(cx, exnState);
    1:     return result;
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_CompileFile(JSContext *cx, JSObject *obj, const char *filename)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
 6561:     FILE *fp;
 8444:     uint32 tcflags;
    1:     JSScript *script;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj);
 6561:     if (!filename || strcmp(filename, "-") == 0) {
 6561:         fp = stdin;
 6561:     } else {
 6561:         fp = fopen(filename, "r");
 6561:         if (!fp) {
 6561:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_OPEN,
 6561:                                  filename, "No such file or directory");
    1:             return NULL;
 6561:         }
 6561:     }
 6561: 
51439:     tcflags = JS_OPTIONS_TO_TCFLAGS(cx) | TCF_NEED_MUTABLE_SCRIPT;
40860:     script = Compiler::compileScript(cx, obj, NULL, NULL, tcflags,
 8444:                                      NULL, 0, fp, filename, 1);
 6561:     if (fp != stdin)
 6561:         fclose(fp);
51440:     if (script && !js_NewScriptObject(cx, script)) {
51440:         js_DestroyScript(cx, script);
51440:         script = NULL;
51440:     }
    1:     LAST_FRAME_CHECKS(cx, script);
    1:     return script;
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
43229: JS_CompileFileHandleForPrincipals(JSContext *cx, JSObject *obj, const char *filename, FILE *file,
    1:                                   JSPrincipals *principals)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
 8444:     uint32 tcflags;
    1:     JSScript *script;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, principals);
51439:     tcflags = JS_OPTIONS_TO_TCFLAGS(cx) | TCF_NEED_MUTABLE_SCRIPT;
40860:     script = Compiler::compileScript(cx, obj, NULL, principals, tcflags,
 8444:                                      NULL, 0, file, filename, 1);
51440:     if (script && !js_NewScriptObject(cx, script)) {
51440:         js_DestroyScript(cx, script);
51440:         script = NULL;
51440:     }
    1:     LAST_FRAME_CHECKS(cx, script);
    1:     return script;
    1: }
    1: 
43228: JS_PUBLIC_API(JSScript *)
57678: JS_CompileFileHandleForPrincipalsVersion(JSContext *cx, JSObject *obj, const char *filename,
57678:                                          FILE *file, JSPrincipals *principals, JSVersion version)
57678: {
57678:     AutoVersionAPI ava(cx, version);
57678:     return JS_CompileFileHandleForPrincipals(cx, obj, filename, file, principals);
57678: }
57678: 
57678: JS_PUBLIC_API(JSScript *)
43229: JS_CompileFileHandle(JSContext *cx, JSObject *obj, const char *filename, FILE *file)
43228: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43228:     return JS_CompileFileHandleForPrincipals(cx, obj, filename, file, NULL);
43228: }
43228: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_NewScriptObject(JSContext *cx, JSScript *script)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
17070:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, script);
 7359:     if (!script)
50450:         return NewNonFunction<WithProto::Class>(cx, &js_ScriptClass, NULL, NULL);
 7359: 
51440:     /*
51440:      * This function should only ever be applied to JSScripts that had
51440:      * script objects allocated for them when they were created, as
51440:      * described in the comment for JSScript::u.object.
51440:      */
51440:     JS_ASSERT(script->u.object);
55633:     JS_ASSERT(script != JSScript::emptyScript());
51440:     return script->u.object;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetScriptObject(JSScript *script)
    1: {
51440:     /*
51440:      * This function should only ever be applied to JSScripts that had
51440:      * script objects allocated for them when they were created, as
51440:      * described in the comment for JSScript::u.object.
51440:      */
51440:     JS_ASSERT(script->u.object);
18285:     return script->u.object;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyScript(JSContext *cx, JSScript *script)
    1: {
    1:     CHECK_REQUEST(cx);
51440: 
51440:     /*
51440:      * Originally, JSScript lifetimes were managed explicitly, and this function
51440:      * was used to free a JSScript. Now, this function does nothing, and the
51440:      * garbage collector manages JSScripts; you must root the JSScript's script
51440:      * object (obtained via JS_GetScriptObject) to keep it alive.
51440:      *
51440:      * However, since the script objects have taken over this responsibility, it
51440:      * follows that every script passed here must have a script object.
51440:      */
51440:     JS_ASSERT(script->u.object);
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
53848: JS_CompileUCFunctionForPrincipalsVersion(JSContext *cx, JSObject *obj,
53848:                                          JSPrincipals *principals, const char *name,
53848:                                          uintN nargs, const char **argnames,
53848:                                          const jschar *chars, size_t length,
53848:                                          const char *filename, uintN lineno,
53848:                                          JSVersion version)
53848: {
53848:     AutoVersionAPI avi(cx, version);
53848:     return JS_CompileUCFunctionForPrincipals(cx, obj, principals, name, nargs, argnames, chars,
53848:                                              length, filename, lineno);
53848: }
53848: 
53848: JS_PUBLIC_API(JSFunction *)
43228: JS_CompileUCFunctionForPrincipals(JSContext *cx, JSObject *obj,
43228:                                   JSPrincipals *principals, const char *name,
    1:                                   uintN nargs, const char **argnames,
43228:                                   const jschar *chars, size_t length,
    1:                                   const char *filename, uintN lineno)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     JSFunction *fun;
43228:     JSAtom *funAtom, *argAtom;
43228:     uintN i;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, principals);
43228:     if (!name) {
43228:         funAtom = NULL;
43228:     } else {
43228:         funAtom = js_Atomize(cx, name, strlen(name), 0);
43228:         if (!funAtom) {
43228:             fun = NULL;
43228:             goto out2;
43228:         }
43228:     }
43228:     fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED, obj, funAtom);
43228:     if (!fun)
43228:         goto out2;
43228: 
43228:     {
48470:         AutoObjectRooter tvr(cx, FUN_OBJECT(fun));
43228:         MUST_FLOW_THROUGH("out");
43228: 
43228:         for (i = 0; i < nargs; i++) {
43228:             argAtom = js_Atomize(cx, argnames[i], strlen(argnames[i]), 0);
43228:             if (!argAtom) {
43228:                 fun = NULL;
51109:                 goto out2;
43228:             }
52503:             if (!fun->addLocal(cx, argAtom, JSLOCAL_ARG)) {
43228:                 fun = NULL;
51109:                 goto out2;
43228:             }
43228:         }
43228: 
43228:         if (!Compiler::compileFunctionBody(cx, fun, principals,
43228:                                            chars, length, filename, lineno)) {
43228:             fun = NULL;
51109:             goto out2;
43228:         }
43228: 
43228:         if (obj && funAtom &&
48470:             !obj->defineProperty(cx, ATOM_TO_JSID(funAtom), ObjectValue(*fun),
43228:                                  NULL, NULL, JSPROP_ENUMERATE)) {
43228:             fun = NULL;
43228:         }
43228: 
43228: #ifdef JS_SCOPE_DEPTH_METER
43228:         if (fun && obj) {
43228:             JSObject *pobj = obj;
43228:             uintN depth = 1;
43228: 
43228:             while ((pobj = pobj->getParent()) != NULL)
43228:                 ++depth;
43228:             JS_BASIC_STATS_ACCUM(&cx->runtime->hostenvScopeDepthStats, depth);
43228:         }
43228: #endif
43228:     }
43228: 
43228:   out2:
43228:     LAST_FRAME_CHECKS(cx, fun);
43228:     return fun;
43228: }
43228: 
43228: JS_PUBLIC_API(JSFunction *)
43228: JS_CompileUCFunction(JSContext *cx, JSObject *obj, const char *name,
43228:                      uintN nargs, const char **argnames,
43228:                      const jschar *chars, size_t length,
43228:                      const char *filename, uintN lineno)
43228: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43235:     return JS_CompileUCFunctionForPrincipals(cx, obj, NULL, name, nargs, argnames,
43235:                                              chars, length, filename, lineno);
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_CompileFunctionForPrincipals(JSContext *cx, JSObject *obj,
    1:                                 JSPrincipals *principals, const char *name,
    1:                                 uintN nargs, const char **argnames,
    1:                                 const char *bytes, size_t length,
    1:                                 const char *filename, uintN lineno)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43235:     jschar *chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return NULL;
43235:     JSFunction *fun = JS_CompileUCFunctionForPrincipals(cx, obj, principals, name,
    1:                                                         nargs, argnames, chars, length,
    1:                                                         filename, lineno);
30851:     cx->free(chars);
    1:     return fun;
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
43228: JS_CompileFunction(JSContext *cx, JSObject *obj, const char *name,
    1:                    uintN nargs, const char **argnames,
43228:                    const char *bytes, size_t length,
    1:                    const char *filename, uintN lineno)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43235:     return JS_CompileFunctionForPrincipals(cx, obj, NULL, name, nargs, argnames, bytes, length,
    1:                                            filename, lineno);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
43229: JS_DecompileScript(JSContext *cx, JSScript *script, const char *name, uintN indent)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     JSPrinter *jp;
    1:     JSString *str;
    1: 
    1:     CHECK_REQUEST(cx);
56852: #ifdef DEBUG
56852:     if (cx->compartment != script->compartment)
56852:         CompartmentChecker::fail(cx->compartment, script->compartment);
56852: #endif
35112:     jp = js_NewPrinter(cx, name, NULL,
    1:                        indent & ~JS_DONT_PRETTY_PRINT,
35040:                        !(indent & JS_DONT_PRETTY_PRINT),
35113:                        false, false);
    1:     if (!jp)
    1:         return NULL;
    1:     if (js_DecompileScript(jp, script))
    1:         str = js_GetPrinterOutput(jp);
    1:     else
    1:         str = NULL;
    1:     js_DestroyPrinter(jp);
    1:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_DecompileFunction(JSContext *cx, JSFunction *fun, uintN indent)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, fun);
35040:     return js_DecompileToString(cx, "JS_DecompileFunction", fun,
    1:                                 indent & ~JS_DONT_PRETTY_PRINT,
35040:                                 !(indent & JS_DONT_PRETTY_PRINT),
35113:                                 false, false, js_DecompileFunction);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_DecompileFunctionBody(JSContext *cx, JSFunction *fun, uintN indent)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, fun);
35040:     return js_DecompileToString(cx, "JS_DecompileFunctionBody", fun,
    1:                                 indent & ~JS_DONT_PRETTY_PRINT,
35040:                                 !(indent & JS_DONT_PRETTY_PRINT),
35113:                                 false, false, js_DecompileFunctionBody);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ExecuteScript(JSContext *cx, JSObject *obj, JSScript *script, jsval *rval)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, obj, script);
51440:     /* This should receive only scripts handed out via the JSAPI. */
51440:     JS_ASSERT(script == JSScript::emptyScript() || script->u.object);
48470:     ok = Execute(cx, obj, script, NULL, 0, Valueify(rval));
    1:     LAST_FRAME_CHECKS(cx, ok);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
57678: JS_ExecuteScriptVersion(JSContext *cx, JSObject *obj, JSScript *script, jsval *rval,
57678:                         JSVersion version)
57678: {
57678:     AutoVersionAPI ava(cx, version);
57678:     return JS_ExecuteScript(cx, obj, script, rval);
57678: }
57678: 
57678: 
57678: JS_PUBLIC_API(JSBool)
53848: JS_EvaluateUCScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
53848:                                         JSPrincipals *principals,
53848:                                         const jschar *chars, uintN length,
53848:                                         const char *filename, uintN lineno,
53848:                                         jsval *rval, JSVersion version)
53848: {
53848:     AutoVersionAPI avi(cx, version);
53848:     return JS_EvaluateUCScriptForPrincipals(cx, obj, principals, chars, length, filename, lineno,
53848:                                             rval);
53848: }
53848: 
53848: JS_PUBLIC_API(JSBool)
    1: JS_EvaluateUCScriptForPrincipals(JSContext *cx, JSObject *obj,
    1:                                  JSPrincipals *principals,
    1:                                  const jschar *chars, uintN length,
    1:                                  const char *filename, uintN lineno,
    1:                                  jsval *rval)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     JSScript *script;
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
40860:     script = Compiler::compileScript(cx, obj, NULL, principals,
17828:                                      !rval
17828:                                      ? TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL
17828:                                      : TCF_COMPILE_N_GO,
 8444:                                      chars, length, NULL, filename, lineno);
18486:     if (!script) {
18486:         LAST_FRAME_CHECKS(cx, script);
    1:         return JS_FALSE;
18486:     }
48470:     ok = Execute(cx, obj, script, NULL, 0, Valueify(rval));
    1:     LAST_FRAME_CHECKS(cx, ok);
51440:     js_DestroyScript(cx, script);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_EvaluateUCScript(JSContext *cx, JSObject *obj, const jschar *chars, uintN length,
43229:                     const char *filename, uintN lineno, jsval *rval)
43228: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43235:     return JS_EvaluateUCScriptForPrincipals(cx, obj, NULL, chars, length, filename, lineno, rval);
43228: }
43228: 
43228: /* Ancient uintN nbytes is part of API/ABI, so use size_t length local. */
43228: JS_PUBLIC_API(JSBool)
43229: JS_EvaluateScriptForPrincipals(JSContext *cx, JSObject *obj, JSPrincipals *principals,
43228:                                const char *bytes, uintN nbytes,
43229:                                const char *filename, uintN lineno, jsval *rval)
43228: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43228:     size_t length = nbytes;
43235:     jschar *chars = js_InflateString(cx, bytes, &length);
43228:     if (!chars)
43228:         return JS_FALSE;
43235:     JSBool ok = JS_EvaluateUCScriptForPrincipals(cx, obj, principals, chars, length,
43228:                                                  filename, lineno, rval);
43228:     cx->free(chars);
43228:     return ok;
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
57692: JS_EvaluateScriptForPrincipalsVersion(JSContext *cx, JSObject *obj, JSPrincipals *principals,
57692:                                       const char *bytes, uintN nbytes,
57692:                                       const char *filename, uintN lineno, jsval *rval, JSVersion version)
57692: {
57692:     AutoVersionAPI avi(cx, version);
57692:     return JS_EvaluateScriptForPrincipals(cx, obj, principals, bytes, nbytes, filename, lineno,
57692:                                           rval);
57692: }
57692: 
57692: JS_PUBLIC_API(JSBool)
43229: JS_EvaluateScript(JSContext *cx, JSObject *obj, const char *bytes, uintN nbytes,
43229:                   const char *filename, uintN lineno, jsval *rval)
43228: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43235:     return JS_EvaluateScriptForPrincipals(cx, obj, NULL, bytes, nbytes, filename, lineno, rval);
43228: }
43228: 
43228: JS_PUBLIC_API(JSBool)
43229: JS_CallFunction(JSContext *cx, JSObject *obj, JSFunction *fun, uintN argc, jsval *argv,
43229:                 jsval *rval)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43288:     JSBool ok;
43288: 
    1:     CHECK_REQUEST(cx);
48470:     assertSameCompartment(cx, obj, fun, JSValueArray(argv, argc));
53557:     ok = ExternalInvoke(cx, obj, ObjectValue(*fun), argc, Valueify(argv), Valueify(rval));
    1:     LAST_FRAME_CHECKS(cx, ok);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_CallFunctionName(JSContext *cx, JSObject *obj, const char *name, uintN argc, jsval *argv,
43229:                     jsval *rval)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
    1:     CHECK_REQUEST(cx);
48470:     assertSameCompartment(cx, obj, JSValueArray(argv, argc));
26187: 
40389:     AutoValueRooter tvr(cx);
26187:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
26187:     JSBool ok = atom &&
43229:                 js_GetMethod(cx, obj, ATOM_TO_JSID(atom), JSGET_NO_METHOD_BARRIER, tvr.addr()) &&
53557:                 ExternalInvoke(cx, obj, tvr.value(), argc, Valueify(argv), Valueify(rval));
    1:     LAST_FRAME_CHECKS(cx, ok);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_CallFunctionValue(JSContext *cx, JSObject *obj, jsval fval, uintN argc, jsval *argv,
43229:                      jsval *rval)
    1: {
55464:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->defaultCompartment);
43288:     JSBool ok;
43288: 
    1:     CHECK_REQUEST(cx);
48470:     assertSameCompartment(cx, obj, fval, JSValueArray(argv, argc));
53557:     ok = ExternalInvoke(cx, obj, Valueify(fval), argc, Valueify(argv), Valueify(rval));
    1:     LAST_FRAME_CHECKS(cx, ok);
    1:     return ok;
    1: }
    1: 
55717: namespace JS {
55717: 
55717: JS_PUBLIC_API(bool)
55717: Call(JSContext *cx, jsval thisv, jsval fval, uintN argc, jsval *argv, jsval *rval)
55717: {
55717:     JSBool ok;
55717: 
55717:     CHECK_REQUEST(cx);
55717:     assertSameCompartment(cx, thisv, fval, JSValueArray(argv, argc));
55717:     ok = ExternalInvoke(cx, Valueify(thisv), Valueify(fval), argc, Valueify(argv), Valueify(rval));
55717:     LAST_FRAME_CHECKS(cx, ok);
55717:     return ok;
55717: }
55717: 
55717: } // namespace JS
55717: 
40293: JS_PUBLIC_API(JSObject *)
40293: JS_New(JSContext *cx, JSObject *ctor, uintN argc, jsval *argv)
40293: {
40293:     CHECK_REQUEST(cx);
48470:     assertSameCompartment(cx, ctor, JSValueArray(argv, argc));
40293: 
40293:     // This is not a simple variation of JS_CallFunctionValue because JSOP_NEW
40293:     // is not a simple variation of JSOP_CALL. We have to determine what class
40293:     // of object to create, create it, and clamp the return value to an object,
40293:     // among other details. js_InvokeConstructor does the hard work.
42714:     InvokeArgsGuard args;
53840:     if (!cx->stack().pushInvokeArgs(cx, argc, &args))
40293:         return NULL;
42714: 
50468:     args.callee().setObject(*ctor);
50468:     args.thisv().setNull();
50468:     memcpy(args.argv(), argv, argc * sizeof(jsval));
40293: 
48470:     bool ok = InvokeConstructor(cx, args);
57687: 
57687:     JSObject *obj = NULL;
57687:     if (ok) {
57687:         if (args.rval().isObject()) {
57687:             obj = &args.rval().toObject();
57687:         } else {
57687:             /*
57687:              * Although constructors may return primitives (via proxies), this
57687:              * API is asking for an object, so we report an error.
57687:              */
57687:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_NEW_RESULT,
57786:                                  js_ValueToPrintableString(cx, args.rval()));
57687:         }
57687:     }
40293: 
40293:     LAST_FRAME_CHECKS(cx, ok);
40293:     return obj;
40293: }
40293: 
25087: JS_PUBLIC_API(JSOperationCallback)
25087: JS_SetOperationCallback(JSContext *cx, JSOperationCallback callback)
25087: {
25087: #ifdef JS_THREADSAFE
25087:     JS_ASSERT(CURRENT_THREAD_IS_ME(cx->thread));
 9780: #endif
25087:     JSOperationCallback old = cx->operationCallback;
23726:     cx->operationCallback = callback;
25087:     return old;
23726: }
23726: 
23726: JS_PUBLIC_API(JSOperationCallback)
23726: JS_GetOperationCallback(JSContext *cx)
23726: {
23726:     return cx->operationCallback;
23726: }
23726: 
23726: JS_PUBLIC_API(void)
23726: JS_TriggerOperationCallback(JSContext *cx)
23726: {
48538: #ifdef JS_THREADSAFE
56559:     AutoLockGC lock(cx->runtime);
48538: #endif
56559:     TriggerOperationCallback(cx);
23726: }
23726: 
25472: JS_PUBLIC_API(void)
25472: JS_TriggerAllOperationCallbacks(JSRuntime *rt)
25472: {
53592: #ifdef JS_THREADSAFE
53592:     AutoLockGC lock(rt);
53592: #endif
53592:     TriggerAllOperationCallbacks(rt);
25472: }
25472: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsRunning(JSContext *cx)
    1: {
35082:     /*
35082:      * The use of cx->fp below is safe. Rationale: Here we don't care if the
35082:      * interpreter state is stale. We just want to know if there *is* any
35082:      * interpreter state.
35082:      */
22652:     VOUCH_DOES_NOT_REQUIRE_STACK();
22652: 
35082: #ifdef JS_TRACER
51446:     JS_ASSERT_IF(JS_TRACE_MONITOR(cx).tracecx == cx, cx->hasfp());
35082: #endif
51446:     JSStackFrame *fp = cx->maybefp();
47498:     while (fp && fp->isDummyFrame())
53840:         fp = fp->prev();
47498:     return fp != NULL;
47498: }
37739: 
  520: JS_PUBLIC_API(JSStackFrame *)
  520: JS_SaveFrameChain(JSContext *cx)
  520: {
37912:     CHECK_REQUEST(cx);
37777:     JSStackFrame *fp = js_GetTopStackFrame(cx);
  520:     if (!fp)
37777:         return NULL;
48531:     cx->saveActiveSegment();
  520:     return fp;
  520: }
  520: 
  520: JS_PUBLIC_API(void)
  520: JS_RestoreFrameChain(JSContext *cx, JSStackFrame *fp)
  520: {
37912:     CHECK_REQUEST(cx);
24499:     JS_ASSERT_NOT_ON_TRACE(cx);
51446:     JS_ASSERT(!cx->hasfp());
  520:     if (!fp)
  520:         return;
48531:     cx->restoreSegment();
55607:     cx->resetCompartment();
  520: }
  520: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewString(JSContext *cx, char *bytes, size_t nbytes)
    1: {
    1:     size_t length = nbytes;
    1:     jschar *chars;
    1:     JSString *str;
    1: 
    1:     CHECK_REQUEST(cx);
    1: 
    1:     /* Make a UTF-16 vector from the 8-bit char codes in bytes. */
    1:     chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return NULL;
    1: 
    1:     /* Free chars (but not bytes, which caller frees on error) if we fail. */
 4718:     str = js_NewString(cx, chars, length);
    1:     if (!str) {
30851:         cx->free(chars);
    1:         return NULL;
    1:     }
    1: 
    1:     /* Hand off bytes to the deflated string cache, if possible. */
56578:     if (!cx->runtime->deflatedStringCache->setBytes(cx, str, bytes))
30851:         cx->free(bytes);
    1:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewStringCopyN(JSContext *cx, const char *s, size_t n)
    1: {
    1:     jschar *js;
    1:     JSString *str;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     js = js_InflateString(cx, s, &n);
    1:     if (!js)
    1:         return NULL;
 4718:     str = js_NewString(cx, js, n);
    1:     if (!str)
30851:         cx->free(js);
    1:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewStringCopyZ(JSContext *cx, const char *s)
    1: {
    1:     size_t n;
    1:     jschar *js;
    1:     JSString *str;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     if (!s)
    1:         return cx->runtime->emptyString;
    1:     n = strlen(s);
    1:     js = js_InflateString(cx, s, &n);
    1:     if (!js)
    1:         return NULL;
 4718:     str = js_NewString(cx, js, n);
    1:     if (!str)
30851:         cx->free(js);
    1:     return str;
    1: }
    1: 
48470: JS_PUBLIC_API(JSBool)
48470: JS_StringHasBeenInterned(JSString *str)
48470: {
48470:     return str->isAtomized();
48470: }
48470: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_InternString(JSContext *cx, const char *s)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     atom = js_Atomize(cx, s, strlen(s), ATOM_INTERNED);
    1:     if (!atom)
    1:         return NULL;
    1:     return ATOM_TO_STRING(atom);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewUCString(JSContext *cx, jschar *chars, size_t length)
    1: {
    1:     CHECK_REQUEST(cx);
 4718:     return js_NewString(cx, chars, length);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewUCStringCopyN(JSContext *cx, const jschar *s, size_t n)
    1: {
    1:     CHECK_REQUEST(cx);
 4076:     return js_NewStringCopyN(cx, s, n);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewUCStringCopyZ(JSContext *cx, const jschar *s)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (!s)
    1:         return cx->runtime->emptyString;
 4076:     return js_NewStringCopyZ(cx, s);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_InternUCStringN(JSContext *cx, const jschar *s, size_t length)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     atom = js_AtomizeChars(cx, s, length, ATOM_INTERNED);
    1:     if (!atom)
    1:         return NULL;
    1:     return ATOM_TO_STRING(atom);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_InternUCString(JSContext *cx, const jschar *s)
    1: {
    1:     return JS_InternUCStringN(cx, s, js_strlen(s));
    1: }
    1: 
    1: JS_PUBLIC_API(char *)
    1: JS_GetStringBytes(JSString *str)
    1: {
    1:     const char *bytes;
    1: 
    1:     bytes = js_GetStringBytes(NULL, str);
    1:     return (char *)(bytes ? bytes : "");
    1: }
    1: 
    1: JS_PUBLIC_API(jschar *)
    1: JS_GetStringChars(JSString *str)
    1: {
    1:     size_t n, size;
    1:     jschar *s;
    1: 
48491:     str->ensureNotRope();
48491: 
    1:     /*
    1:      * API botch (again, shades of JS_GetStringBytes): we have no cx to report
48491:      * out-of-memory when undepending strings, so we replace JSString::undepend
    1:      * with explicit malloc call and ignore its errors.
    1:      *
    1:      * If we fail to convert a dependent string into an independent one, our
    1:      * caller will not be guaranteed a \u0000 terminator as a backstop.  This
    1:      * may break some clients who already misbehave on embedded NULs.
    1:      *
    1:      * The gain of dependent strings, which cure quadratic and cubic growth
    1:      * rate bugs in string concatenation, is worth this slight loss in API
    1:      * compatibility.
    1:      */
29366:     if (str->isDependent()) {
29366:         n = str->dependentLength();
    1:         size = (n + 1) * sizeof(jschar);
30851:         s = (jschar *) js_malloc(size);
    1:         if (s) {
29366:             memcpy(s, str->dependentChars(), n * sizeof *s);
    1:             s[n] = 0;
40281:             str->initFlat(s, n);
 4718:         } else {
29366:             s = str->dependentChars();
 4718:         }
 4718:     } else {
57701:         str->flatClearExtensible();
29366:         s = str->flatChars();
 4718:     }
 4718:     return s;
    1: }
    1: 
    1: JS_PUBLIC_API(size_t)
    1: JS_GetStringLength(JSString *str)
    1: {
29366:     return str->length();
    1: }
    1: 
33583: JS_PUBLIC_API(const char *)
33583: JS_GetStringBytesZ(JSContext *cx, JSString *str)
33583: {
47485:     assertSameCompartment(cx, str);
33583:     return js_GetStringBytes(cx, str);
33583: }
33583: 
33583: JS_PUBLIC_API(const jschar *)
57721: JS_GetStringCharsAndLength(JSString *str, size_t *lengthp)
57721: {
57721:     *lengthp = str->length();
57721:     return str->chars();
57721: }
57721: 
57721: JS_PUBLIC_API(const jschar *)
33583: JS_GetStringCharsZ(JSContext *cx, JSString *str)
33583: {
47485:     assertSameCompartment(cx, str);
48491:     return str->undepend(cx);
33583: }
33583: 
    1: JS_PUBLIC_API(intN)
    1: JS_CompareStrings(JSString *str1, JSString *str2)
    1: {
    1:     return js_CompareStrings(str1, str2);
    1: }
    1: 
57721: JS_PUBLIC_API(JSBool)
57721: JS_MatchStringAndAscii(JSString *str, const char *asciiBytes)
57721: {
57721:     return MatchStringAndAscii(str, asciiBytes);
57721: }
57721: 
57721: JS_PUBLIC_API(size_t)
57721: JS_PutEscapedString(char *buffer, size_t size, JSString *str, char quote)
57721: {
57721:     return PutEscapedString(buffer, size, str, quote);
57721: }
57721: 
57721: JS_PUBLIC_API(JSBool)
57721: JS_FileEscapedString(FILE *fp, JSString *str, char quote)
57721: {
57721:     return FileEscapedString(fp, str, quote);
57721: }
57721: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewGrowableString(JSContext *cx, jschar *chars, size_t length)
    1: {
    1:     CHECK_REQUEST(cx);
48491:     return js_NewString(cx, chars, length);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
43229: JS_NewDependentString(JSContext *cx, JSString *str, size_t start, size_t length)
    1: {
    1:     CHECK_REQUEST(cx);
 4076:     return js_NewDependentString(cx, str, start, length);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_ConcatStrings(JSContext *cx, JSString *left, JSString *right)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_ConcatStrings(cx, left, right);
    1: }
    1: 
    1: JS_PUBLIC_API(const jschar *)
    1: JS_UndependString(JSContext *cx, JSString *str)
    1: {
    1:     CHECK_REQUEST(cx);
48491:     return str->undepend(cx);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_MakeStringImmutable(JSContext *cx, JSString *str)
    1: {
    1:     CHECK_REQUEST(cx);
 4718:     return js_MakeStringImmutable(cx, str);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_EncodeCharacters(JSContext *cx, const jschar *src, size_t srclen, char *dst, size_t *dstlenp)
    1: {
    1:     size_t n;
    1: 
    1:     if (!dst) {
    1:         n = js_GetDeflatedStringLength(cx, src, srclen);
    1:         if (n == (size_t)-1) {
    1:             *dstlenp = 0;
    1:             return JS_FALSE;
    1:         }
    1:         *dstlenp = n;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     return js_DeflateStringToBuffer(cx, src, srclen, dst, dstlenp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
43229: JS_DecodeBytes(JSContext *cx, const char *src, size_t srclen, jschar *dst, size_t *dstlenp)
    1: {
    1:     return js_InflateStringToBuffer(cx, src, srclen, dst, dstlenp);
    1: }
    1: 
 8893: JS_PUBLIC_API(char *)
 8893: JS_EncodeString(JSContext *cx, JSString *str)
 8893: {
29366:     return js_DeflateString(cx, str->chars(), str->length());
 8893: }
 8893: 
20092: JS_PUBLIC_API(JSBool)
28100: JS_Stringify(JSContext *cx, jsval *vp, JSObject *replacer, jsval space,
20092:              JSONWriteCallback callback, void *data)
20092: {
20092:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, replacer, space);
31890:     JSCharBuffer cb(cx);
48470:     if (!js_Stringify(cx, Valueify(vp), replacer, Valueify(space), cb))
31819:         return false;
31925:     return callback(cb.begin(), cb.length(), data);
20092: }
20092: 
20092: JS_PUBLIC_API(JSBool)
20092: JS_TryJSON(JSContext *cx, jsval *vp)
20092: {
20092:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, *vp);
48470:     return js_TryJSON(cx, Valueify(vp));
20092: }
20092: 
20092: JS_PUBLIC_API(JSONParser *)
20092: JS_BeginJSONParse(JSContext *cx, jsval *vp)
20092: {
20092:     CHECK_REQUEST(cx);
48470:     return js_BeginJSONParse(cx, Valueify(vp));
20092: }
20092: 
20092: JS_PUBLIC_API(JSBool)
20092: JS_ConsumeJSONText(JSContext *cx, JSONParser *jp, const jschar *data, uint32 len)
20092: {
20092:     CHECK_REQUEST(cx);
20092:     return js_ConsumeJSONText(cx, jp, data, len);
20092: }
20092: 
20092: JS_PUBLIC_API(JSBool)
25718: JS_FinishJSONParse(JSContext *cx, JSONParser *jp, jsval reviver)
20092: {
20092:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, reviver);
48470:     return js_FinishJSONParse(cx, jp, Valueify(reviver));
20092: }
20092: 
54863: JS_PUBLIC_API(JSBool)
54863: JS_ReadStructuredClone(JSContext *cx, const uint64 *buf, size_t nbytes, jsval *vp)
54863: {
54863:     return ReadStructuredClone(cx, buf, nbytes, Valueify(vp));
54863: }
54863: 
54863: JS_PUBLIC_API(JSBool)
54863: JS_WriteStructuredClone(JSContext *cx, jsval v, uint64 **bufp, size_t *nbytesp)
54863: {
54863:     return WriteStructuredClone(cx, Valueify(v), (uint64_t **) bufp, nbytesp);
54863: }
54863: 
54863: JS_PUBLIC_API(JSBool)
54863: JS_StructuredClone(JSContext *cx, jsval v, jsval *vp)
54863: {
54863:     JSAutoStructuredCloneBuffer buf(cx);
54863:     return buf.write(v) && buf.read(vp);
54863: }
54863: 
54863: JS_PUBLIC_API(void)
54863: JS_SetStructuredCloneCallbacks(JSRuntime *rt, const JSStructuredCloneCallbacks *callbacks)
54863: {
54863:     rt->structuredCloneCallbacks = callbacks;
54863: }
54863: 
54863: JS_PUBLIC_API(JSBool)
55480: JS_ReadUint32Pair(JSStructuredCloneReader *r, uint32 *p1, uint32 *p2)
54863: {
54863:     return r->input().readPair((uint32_t *) p1, (uint32_t *) p2);
54863: }
54863: 
54863: JS_PUBLIC_API(JSBool)
54863: JS_ReadBytes(JSStructuredCloneReader *r, void *p, size_t len)
54863: {
54863:     return r->input().readBytes(p, len);
54863: }
54863: 
54863: JS_PUBLIC_API(JSBool)
55480: JS_WriteUint32Pair(JSStructuredCloneWriter *w, uint32 tag, uint32 data)
54863: {
54863:     return w->output().writePair(tag, data);
54863: }
54863: 
54863: JS_PUBLIC_API(JSBool)
54863: JS_WriteBytes(JSStructuredCloneWriter *w, const void *p, size_t len)
54863: {
54863:     return w->output().writeBytes(p, len);
54863: }
54863: 
 8893: /*
 8893:  * The following determines whether C Strings are to be treated as UTF-8
 8893:  * or ISO-8859-1.  For correct operation, it must be set prior to the
 8893:  * first call to JS_NewRuntime.
 8893:  */
 8893: #ifndef JS_C_STRINGS_ARE_UTF8
 8893: JSBool js_CStringsAreUTF8 = JS_FALSE;
 8893: #endif
 8893: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_CStringsAreUTF8()
    1: {
 8893:     return js_CStringsAreUTF8;
 8893: }
 8893: 
 8893: JS_PUBLIC_API(void)
 8893: JS_SetCStringsAreUTF8()
 8893: {
 8893:     JS_ASSERT(!js_NewRuntimeWasCalled);
 8893: 
 8893: #ifndef JS_C_STRINGS_ARE_UTF8
 8893:     js_CStringsAreUTF8 = JS_TRUE;
    1: #endif
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ReportError(JSContext *cx, const char *format, ...)
    1: {
    1:     va_list ap;
    1: 
    1:     va_start(ap, format);
    1:     js_ReportErrorVA(cx, JSREPORT_ERROR, format, ap);
    1:     va_end(ap);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ReportErrorNumber(JSContext *cx, JSErrorCallback errorCallback,
    1:                      void *userRef, const uintN errorNumber, ...)
    1: {
    1:     va_list ap;
    1: 
    1:     va_start(ap, errorNumber);
    1:     js_ReportErrorNumberVA(cx, JSREPORT_ERROR, errorCallback, userRef,
    1:                            errorNumber, JS_TRUE, ap);
    1:     va_end(ap);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ReportErrorNumberUC(JSContext *cx, JSErrorCallback errorCallback,
    1:                      void *userRef, const uintN errorNumber, ...)
    1: {
    1:     va_list ap;
    1: 
    1:     va_start(ap, errorNumber);
    1:     js_ReportErrorNumberVA(cx, JSREPORT_ERROR, errorCallback, userRef,
    1:                            errorNumber, JS_FALSE, ap);
    1:     va_end(ap);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ReportWarning(JSContext *cx, const char *format, ...)
    1: {
    1:     va_list ap;
    1:     JSBool ok;
    1: 
    1:     va_start(ap, format);
    1:     ok = js_ReportErrorVA(cx, JSREPORT_WARNING, format, ap);
    1:     va_end(ap);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ReportErrorFlagsAndNumber(JSContext *cx, uintN flags,
    1:                              JSErrorCallback errorCallback, void *userRef,
    1:                              const uintN errorNumber, ...)
    1: {
    1:     va_list ap;
    1:     JSBool ok;
    1: 
    1:     va_start(ap, errorNumber);
    1:     ok = js_ReportErrorNumberVA(cx, flags, errorCallback, userRef,
    1:                                 errorNumber, JS_TRUE, ap);
    1:     va_end(ap);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ReportErrorFlagsAndNumberUC(JSContext *cx, uintN flags,
    1:                                JSErrorCallback errorCallback, void *userRef,
    1:                                const uintN errorNumber, ...)
    1: {
    1:     va_list ap;
    1:     JSBool ok;
    1: 
    1:     va_start(ap, errorNumber);
    1:     ok = js_ReportErrorNumberVA(cx, flags, errorCallback, userRef,
    1:                                 errorNumber, JS_FALSE, ap);
    1:     va_end(ap);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ReportOutOfMemory(JSContext *cx)
    1: {
    1:     js_ReportOutOfMemory(cx);
    1: }
    1: 
12983: JS_PUBLIC_API(void)
12983: JS_ReportAllocationOverflow(JSContext *cx)
12983: {
12983:     js_ReportAllocationOverflow(cx);
12983: }
12983: 
    1: JS_PUBLIC_API(JSErrorReporter)
    1: JS_SetErrorReporter(JSContext *cx, JSErrorReporter er)
    1: {
    1:     JSErrorReporter older;
    1: 
    1:     older = cx->errorReporter;
    1:     cx->errorReporter = er;
    1:     return older;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Regular Expressions.
    1:  */
    1: JS_PUBLIC_API(JSObject *)
53858: JS_NewRegExpObject(JSContext *cx, JSObject *obj, char *bytes, size_t length, uintN flags)
    1: {
    1:     CHECK_REQUEST(cx);
50491:     jschar *chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return NULL;
53858:     RegExpStatics *res = RegExpStatics::extractFrom(obj);
53858:     JSObject *reobj = RegExp::createObject(cx, res, chars, length, flags);
53858:     cx->free(chars);
53858:     return reobj;
53858: }
53858: 
53858: JS_PUBLIC_API(JSObject *)
53858: JS_NewUCRegExpObject(JSContext *cx, JSObject *obj, jschar *chars, size_t length, uintN flags)
53858: {
53858:     CHECK_REQUEST(cx);
53858:     RegExpStatics *res = RegExpStatics::extractFrom(obj);
53858:     return RegExp::createObject(cx, res, chars, length, flags);
53858: }
53858: 
53858: JS_PUBLIC_API(void)
53858: JS_SetRegExpInput(JSContext *cx, JSObject *obj, JSString *input, JSBool multiline)
53858: {
53858:     CHECK_REQUEST(cx);
53858:     assertSameCompartment(cx, input);
53858: 
53858:     RegExpStatics::extractFrom(obj)->reset(input, !!multiline);
53858: }
53858: 
53858: JS_PUBLIC_API(void)
53858: JS_ClearRegExpStatics(JSContext *cx, JSObject *obj)
53858: {
53858:     CHECK_REQUEST(cx);
53858:     JS_ASSERT(obj);
53858: 
53858:     RegExpStatics::extractFrom(obj)->clear();
53858: }
53858: 
53858: JS_PUBLIC_API(JSBool)
53858: JS_ExecuteRegExp(JSContext *cx, JSObject *obj, JSObject *reobj, jschar *chars, size_t length,
53858:                  size_t *indexp, JSBool test, jsval *rval)
53858: {
53858:     CHECK_REQUEST(cx);
53858: 
53858:     RegExp *re = RegExp::extractFrom(reobj);
53858:     if (!re)
53858:         return false;
53858: 
53858:     JSString *str = js_NewStringCopyN(cx, chars, length);
53858:     if (!str)
53858:         return false;
53858: 
53858:     return re->execute(cx, RegExpStatics::extractFrom(obj), str, indexp, test, Valueify(rval));
53858: }
53858: 
53858: JS_PUBLIC_API(JSObject *)
53858: JS_NewRegExpObjectNoStatics(JSContext *cx, char *bytes, size_t length, uintN flags)
53858: {
53858:     CHECK_REQUEST(cx);
53858:     jschar *chars = js_InflateString(cx, bytes, &length);
53858:     if (!chars)
53858:         return NULL;
53858:     JSObject *obj = RegExp::createObjectNoStatics(cx, chars, length, flags);
30851:     cx->free(chars);
    1:     return obj;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
53858: JS_NewUCRegExpObjectNoStatics(JSContext *cx, jschar *chars, size_t length, uintN flags)
    1: {
    1:     CHECK_REQUEST(cx);
53858:     return RegExp::createObjectNoStatics(cx, chars, length, flags);
53858: }
53858: 
53858: JS_PUBLIC_API(JSBool)
53858: JS_ExecuteRegExpNoStatics(JSContext *cx, JSObject *obj, jschar *chars, size_t length,
53858:                           size_t *indexp, JSBool test, jsval *rval)
    1: {
    1:     CHECK_REQUEST(cx);
50911:     
50911:     RegExp *re = RegExp::extractFrom(obj);
53858:     if (!re)
53858:         return false;
50911: 
50911:     JSString *str = js_NewStringCopyN(cx, chars, length);
53858:     if (!str)
53858:         return false;
53858: 
53858:     return re->executeNoStatics(cx, str, indexp, test, Valueify(rval));
53858: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetLocaleCallbacks(JSContext *cx, JSLocaleCallbacks *callbacks)
    1: {
    1:     cx->localeCallbacks = callbacks;
    1: }
    1: 
    1: JS_PUBLIC_API(JSLocaleCallbacks *)
    1: JS_GetLocaleCallbacks(JSContext *cx)
    1: {
    1:     return cx->localeCallbacks;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsExceptionPending(JSContext *cx)
    1: {
    1:     return (JSBool) cx->throwing;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetPendingException(JSContext *cx, jsval *vp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (!cx->throwing)
    1:         return JS_FALSE;
48470:     Valueify(*vp) = cx->exception;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetPendingException(JSContext *cx, jsval v)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
48470:     SetPendingException(cx, Valueify(v));
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearPendingException(JSContext *cx)
    1: {
    1:     cx->throwing = JS_FALSE;
48470:     cx->exception.setUndefined();
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ReportPendingException(JSContext *cx)
    1: {
39928:     JSBool ok;
39928:     JSPackedBool save;
    1: 
    1:     CHECK_REQUEST(cx);
    1: 
    1:     /*
    1:      * Set cx->generatingError to suppress the standard error-to-exception
    1:      * conversion done by all {js,JS}_Report* functions except for OOM.  The
    1:      * cx->generatingError flag was added to suppress recursive divergence
    1:      * under js_ErrorToException, but it serves for our purposes here too.
    1:      */
    1:     save = cx->generatingError;
    1:     cx->generatingError = JS_TRUE;
    1:     ok = js_ReportUncaughtException(cx);
    1:     cx->generatingError = save;
    1:     return ok;
    1: }
    1: 
    1: struct JSExceptionState {
    1:     JSBool throwing;
    1:     jsval  exception;
    1: };
    1: 
    1: JS_PUBLIC_API(JSExceptionState *)
    1: JS_SaveExceptionState(JSContext *cx)
    1: {
    1:     JSExceptionState *state;
    1: 
    1:     CHECK_REQUEST(cx);
30851:     state = (JSExceptionState *) cx->malloc(sizeof(JSExceptionState));
    1:     if (state) {
    1:         state->throwing = JS_GetPendingException(cx, &state->exception);
    1:         if (state->throwing && JSVAL_IS_GCTHING(state->exception))
48470:             js_AddRoot(cx, Valueify(&state->exception), "JSExceptionState.exception");
    1:     }
    1:     return state;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_RestoreExceptionState(JSContext *cx, JSExceptionState *state)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (state) {
    1:         if (state->throwing)
    1:             JS_SetPendingException(cx, state->exception);
    1:         else
    1:             JS_ClearPendingException(cx);
    1:         JS_DropExceptionState(cx, state);
    1:     }
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DropExceptionState(JSContext *cx, JSExceptionState *state)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (state) {
47485:         if (state->throwing && JSVAL_IS_GCTHING(state->exception)) {
47485:             assertSameCompartment(cx, state->exception);
47403:             JS_RemoveValueRoot(cx, &state->exception);
47485:         }
30851:         cx->free(state);
    1:     }
    1: }
    1: 
    1: JS_PUBLIC_API(JSErrorReport *)
    1: JS_ErrorFromException(JSContext *cx, jsval v)
    1: {
    1:     CHECK_REQUEST(cx);
47485:     assertSameCompartment(cx, v);
    1:     return js_ErrorFromException(cx, v);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ThrowReportedError(JSContext *cx, const char *message,
    1:                       JSErrorReport *reportp)
    1: {
36234:     return JS_IsRunning(cx) &&
36234:            js_ErrorToException(cx, message, reportp, NULL, NULL);
    1: }
    1: 
 6464: JS_PUBLIC_API(JSBool)
 6464: JS_ThrowStopIteration(JSContext *cx)
 6464: {
 6464:     return js_ThrowStopIteration(cx);
 6464: }
 6464: 
    1: /*
    1:  * Get the owning thread id of a context. Returns 0 if the context is not
    1:  * owned by any thread.
    1:  */
    1: JS_PUBLIC_API(jsword)
    1: JS_GetContextThread(JSContext *cx)
    1: {
11941: #ifdef JS_THREADSAFE
42712:     return reinterpret_cast<jsword>(JS_THREAD_ID(cx));
11941: #else
11941:     return 0;
11941: #endif
    1: }
    1: 
    1: /*
    1:  * Set the current thread as the owning thread of a context. Returns the
    1:  * old owning thread id, or -1 if the operation failed.
    1:  */
    1: JS_PUBLIC_API(jsword)
    1: JS_SetContextThread(JSContext *cx)
    1: {
11941: #ifdef JS_THREADSAFE
53548:     JS_ASSERT(!cx->outstandingRequests);
24871:     if (cx->thread) {
26569:         JS_ASSERT(CURRENT_THREAD_IS_ME(cx->thread));
42712:         return reinterpret_cast<jsword>(cx->thread->id);
24871:     }
24871: 
26569:     if (!js_InitContextThread(cx)) {
24871:         js_ReportOutOfMemory(cx);
    1:         return -1;
24871:     }
24871: 
26569:     /* Here the GC lock is still held after js_InitContextThread took it. */
26569:     JS_UNLOCK_GC(cx->runtime);
24871: #endif
24871:     return 0;
24871: }
24871: 
24871: JS_PUBLIC_API(jsword)
24871: JS_ClearContextThread(JSContext *cx)
24871: {
24871: #ifdef JS_THREADSAFE
24871:     /*
53548:      * cx must have exited all requests it entered and, if cx is associated
53548:      * with a thread, this must be called only from that thread.  If not, this
53548:      * is a harmless no-op.
24871:      */
53548:     JS_ASSERT(cx->outstandingRequests == 0);
53548:     JSThread *t = cx->thread;
53548:     if (!t)
24871:         return 0;
53548:     JS_ASSERT(CURRENT_THREAD_IS_ME(t));
24871: 
24871:     /*
24871:      * We must not race with a GC that accesses cx->thread for all threads,
24871:      * see bug 476934.
24871:      */
24871:     JSRuntime *rt = cx->runtime;
40840:     AutoLockGC lock(rt);
24871:     js_WaitForGC(rt);
26569:     js_ClearContextThread(cx);
56559:     JS_ASSERT_IF(JS_CLIST_IS_EMPTY(&t->contextList), !t->data.requestDepth);
53548:    
53548:     /*
53548:      * We can access t->id as long as the GC lock is held and we cannot race
53548:      * with the GC that may delete t.
53548:      */
53548:     return reinterpret_cast<jsword>(t->id);
11941: #else
11941:     return 0;
11941: #endif
    1: }
    1: 
50455: #ifdef MOZ_TRACE_JSCALLS
50455: JS_PUBLIC_API(void)
50455: JS_SetFunctionCallback(JSContext *cx, JSFunctionCallback fcb)
50455: {
50455:     cx->functionCallback = fcb;
50455: }
50455: 
50455: JS_PUBLIC_API(JSFunctionCallback)
50455: JS_GetFunctionCallback(JSContext *cx)
50455: {
50455:     return cx->functionCallback;
50455: }
50455: #endif
50455: 
 1492: #ifdef JS_GC_ZEAL
 1492: JS_PUBLIC_API(void)
 1492: JS_SetGCZeal(JSContext *cx, uint8 zeal)
 1492: {
 1492:     cx->runtime->gcZeal = zeal;
 1492: }
 1492: #endif
 1492: 
    1: /************************************************************************/
    1: 
50577: #if !defined(STATIC_EXPORTABLE_JS_API) && !defined(STATIC_JS_API) && defined(XP_WIN) && !defined (WINCE)
11461: 
52897: #include "jswin.h"
11461: 
    1: /*
11461:  * Initialization routine for the JS DLL.
    1:  */
    1: BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
    1: {
    1:     return TRUE;
    1: }
    1: 
11461: #endif
