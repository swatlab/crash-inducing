    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
32658:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsscope_h___
    1: #define jsscope_h___
    1: /*
    1:  * JS symbol tables.
    1:  */
52503: #include <new>
38562: #ifdef DEBUG
38562: #include <stdio.h>
38562: #endif
38562: 
    1: #include "jstypes.h"
40359: #include "jscntxt.h"
52503: #include "jshashtable.h"
    1: #include "jsobj.h"
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
40359: #include "jspropertytree.h"
57817: #include "jsstrinlines.h"
    1: 
33166: #ifdef _MSC_VER
33166: #pragma warning(push)
33166: #pragma warning(disable:4800)
39928: #pragma warning(push)
39928: #pragma warning(disable:4100) /* Silence unreferenced formal parameter warnings */
33166: #endif
33166: 
    1: /*
    1:  * Given P independent, non-unique properties each of size S words mapped by
    1:  * all scopes in a runtime, construct a property tree of N nodes each of size
    1:  * S+L words (L for tree linkage).  A nominal L value is 2 for leftmost-child
    1:  * and right-sibling links.  We hope that the N < P by enough that the space
    1:  * overhead of L, and the overhead of scope entries pointing at property tree
    1:  * nodes, is worth it.
    1:  *
    1:  * The tree construction goes as follows.  If any empty scope in the runtime
    1:  * has a property X added to it, find or create a node under the tree root
52503:  * labeled X, and set obj->lastProp to point at that node.  If any non-empty
    1:  * scope whose most recently added property is labeled Y has another property
    1:  * labeled Z added, find or create a node for Z under the node that was added
52503:  * for Y, and set obj->lastProp to point at that node.
    1:  *
    1:  * A property is labeled by its members' values: id, getter, setter, slot,
    1:  * attributes, tiny or short id, and a field telling for..in order.  Note that
    1:  * labels are not unique in the tree, but they are unique among a node's kids
    1:  * (barring rare and benign multi-threaded race condition outcomes, see below)
    1:  * and along any ancestor line from the tree root to a given leaf node (except
    1:  * for the hard case of duplicate formal parameters to a function).
    1:  *
    1:  * Thus the root of the tree represents all empty scopes, and the first ply
    1:  * of the tree represents all scopes containing one property, etc.  Each node
    1:  * in the tree can stand for any number of scopes having the same ordered set
    1:  * of properties, where that node was the last added to the scope.  (We need
    1:  * not store the root of the tree as a node, and do not -- all we need are
    1:  * links to its kids.)
    1:  *
    1:  * Sidebar on for..in loop order: ECMA requires no particular order, but this
    1:  * implementation has promised and delivered property definition order, and
    1:  * compatibility is king.  We could use an order number per property, which
    1:  * would require a sort in js_Enumerate, and an entry order generation number
    1:  * per scope.  An order number beats a list, which should be doubly-linked for
    1:  * O(1) delete.  An even better scheme is to use a parent link in the property
52503:  * tree, so that the ancestor line can be iterated from obj->lastProp when
    1:  * filling in a JSIdArray from back to front.  This parent link also helps the
    1:  * GC to sweep properties iteratively.
    1:  *
    1:  * What if a property Y is deleted from a scope?  If Y is the last property in
    1:  * the scope, we simply adjust the scope's lastProp member after we remove the
    1:  * scope's hash-table entry pointing at that property node.  The parent link
    1:  * mentioned in the for..in sidebar above makes this adjustment O(1).  But if
    1:  * Y comes between X and Z in the scope, then we might have to "fork" the tree
    1:  * at X, leaving X->Y->Z in case other scopes have those properties added in
    1:  * that order; and to finish the fork, we'd add a node labeled Z with the path
    1:  * X->Z, if it doesn't exist.  This could lead to lots of extra nodes, and to
    1:  * O(n^2) growth when deleting lots of properties.
    1:  *
    1:  * Rather, for O(1) growth all around, we should share the path X->Y->Z among
    1:  * scopes having those three properties added in that order, and among scopes
    1:  * having only X->Z where Y was deleted.  All such scopes have a lastProp that
    1:  * points to the Z child of Y.  But a scope in which Y was deleted does not
    1:  * have a table entry for Y, and when iterating that scope by traversing the
    1:  * ancestor line from Z, we will have to test for a table entry for each node,
    1:  * skipping nodes that lack entries.
    1:  *
    1:  * What if we add Y again?  X->Y->Z->Y is wrong and we'll enumerate Y twice.
35453:  * Therefore we must fork in such a case if not earlier, or do something else.
35453:  * We used to fork on the theory that set after delete is rare, but the Web is
35453:  * a harsh mistress, and we now convert the scope to a "dictionary" on first
35453:  * delete, to avoid O(n^2) growth in the property tree.
    1:  *
    1:  * What about thread safety?  If the property tree operations done by requests
    1:  * are find-node and insert-node, then the only hazard is duplicate insertion.
    1:  * This is harmless except for minor bloat.  When all requests have ended or
    1:  * been suspended, the GC is free to sweep the tree after marking all nodes
 3046:  * reachable from scopes, performing remove-node operations as needed.
    1:  *
    1:  * Is the property tree worth it compared to property storage in each table's
    1:  * entries?  To decide, we must find the relation <> between the words used
    1:  * with a property tree and the words required without a tree.
    1:  *
    1:  * Model all scopes as one super-scope of capacity T entries (T a power of 2).
    1:  * Let alpha be the load factor of this double hash-table.  With the property
    1:  * tree, each entry in the table is a word-sized pointer to a node that can be
    1:  * shared by many scopes.  But all such pointers are overhead compared to the
    1:  * situation without the property tree, where the table stores property nodes
    1:  * directly, as entries each of size S words.  With the property tree, we need
    1:  * L=2 extra words per node for siblings and kids pointers.  Without the tree,
    1:  * (1-alpha)*S*T words are wasted on free or removed sentinel-entries required
    1:  * by double hashing.
    1:  *
    1:  * Therefore,
    1:  *
    1:  *      (property tree)                 <> (no property tree)
    1:  *      N*(S+L) + T                     <> S*T
    1:  *      N*(S+L) + T                     <> P*S + (1-alpha)*S*T
    1:  *      N*(S+L) + alpha*T + (1-alpha)*T <> P*S + (1-alpha)*S*T
    1:  *
    1:  * Note that P is alpha*T by definition, so
    1:  *
    1:  *      N*(S+L) + P + (1-alpha)*T <> P*S + (1-alpha)*S*T
    1:  *      N*(S+L)                   <> P*S - P + (1-alpha)*S*T - (1-alpha)*T
    1:  *      N*(S+L)                   <> (P + (1-alpha)*T) * (S-1)
    1:  *      N*(S+L)                   <> (P + (1-alpha)*P/alpha) * (S-1)
    1:  *      N*(S+L)                   <> P * (1/alpha) * (S-1)
    1:  *
    1:  * Let N = P*beta for a compression ratio beta, beta <= 1:
    1:  *
    1:  *      P*beta*(S+L) <> P * (1/alpha) * (S-1)
    1:  *      beta*(S+L)   <> (S-1)/alpha
    1:  *      beta         <> (S-1)/((S+L)*alpha)
    1:  *
    1:  * For S = 6 (32-bit architectures) and L = 2, the property tree wins iff
    1:  *
    1:  *      beta < 5/(8*alpha)
    1:  *
    1:  * We ensure that alpha <= .75, so the property tree wins if beta < .83_.  An
    1:  * average beta from recent Mozilla browser startups was around .6.
    1:  *
    1:  * Can we reduce L?  Observe that the property tree degenerates into a list of
    1:  * lists if at most one property Y follows X in all scopes.  In or near such a
    1:  * case, we waste a word on the right-sibling link outside of the root ply of
    1:  * the tree.  Note also that the root ply tends to be large, so O(n^2) growth
    1:  * searching it is likely, indicating the need for hashing (but with increased
    1:  * thread safety costs).
    1:  *
    1:  * If only K out of N nodes in the property tree have more than one child, we
    1:  * could eliminate the sibling link and overlay a children list or hash-table
    1:  * pointer on the leftmost-child link (which would then be either null or an
    1:  * only-child link; the overlay could be tagged in the low bit of the pointer,
    1:  * or flagged elsewhere in the property tree node, although such a flag must
    1:  * not be considered when comparing node labels during tree search).
    1:  *
    1:  * For such a system, L = 1 + (K * averageChildrenTableSize) / N instead of 2.
    1:  * If K << N, L approaches 1 and the property tree wins if beta < .95.
    1:  *
    1:  * We observe that fan-out below the root ply of the property tree appears to
    1:  * have extremely low degree (see the MeterPropertyTree code that histograms
    1:  * child-counts in jsscope.c), so instead of a hash-table we use a linked list
    1:  * of child node pointer arrays ("kid chunks").  The details are isolated in
52503:  * jspropertytree.h/.cpp; others must treat js::Shape.kids as opaque.
    1:  *
    1:  * One final twist (can you stand it?): the mean number of entries per scope
    1:  * in Mozilla is < 5, with a large standard deviation (~8).  Instead of always
    1:  * allocating scope->table, we leave it null while initializing all the other
    1:  * scope members as if it were non-null and minimal-length.  Until a property
35453:  * is added that crosses the threshold of 6 or more entries for hashing, we use
52503:  * linear search from obj->lastProp to find a given id, and save on the space
35453:  * overhead of a hash table.
    1:  */
    1: 
53546: #define SHAPE_INVALID_SLOT              0xffffffff
53546: 
52503: namespace js {
35117: 
52503: /*
52503:  * Shapes use multiplicative hashing, _a la_ jsdhash.[ch], but specialized to
59238:  * minimize footprint.  But if a Shape lineage has fewer than HASH_THRESHOLD
59238:  * entries, we use linear search and avoid allocating scope->table.
52503:  */
52503: struct PropertyTable {
59238:     enum {
59238:         HASH_THRESHOLD  = 6,
59238:         MIN_SIZE_LOG2   = 4,
59238:         MIN_SIZE        = JS_BIT(MIN_SIZE_LOG2)
59238:     };
35453: 
52503:     int             hashShift;          /* multiplicative hash shift */
30258: 
    1:     uint32          entryCount;         /* number of entries in table */
    1:     uint32          removedCount;       /* removed entry sentinels in table */
53652:     uint32          freelist;           /* SHAPE_INVALID_SLOT or head of slot
53546:                                            freelist in owning dictionary-mode
53546:                                            object */
52503:     js::Shape       **entries;          /* table of ptrs to shared tree nodes */
52503: 
52509:     PropertyTable(uint32 nentries)
52503:       : hashShift(JS_DHASH_BITS - MIN_SIZE_LOG2),
52509:         entryCount(nentries),
53546:         removedCount(0),
53652:         freelist(SHAPE_INVALID_SLOT)
52503:     {
52503:         /* NB: entries is set by init, which must be called. */
52503:     }
52503: 
52503:     ~PropertyTable() {
52503:         js_free(entries);
52503:     }
52503: 
52503:     /* By definition, hashShift = JS_DHASH_BITS - log2(capacity). */
52503:     uint32 capacity() const { return JS_BIT(JS_DHASH_BITS - hashShift); }
35453: 
58067:     /* Whether we need to grow.  We want to do this if the load factor is >= 0.75 */
58067:     bool needsToGrow() const {
58067:         uint32 size = capacity();
58067:         return entryCount + removedCount >= size - (size >> 2);
58067:     }
58067: 
58067:     /*
58067:      * Try to grow the table.  On failure, reports out of memory on cx
58067:      * and returns false.  This will make any extant pointers into the
58067:      * table invalid.  Don't call this unless needsToGrow() is true.
58067:      */
58067:     bool grow(JSContext *cx);
58067: 
35453:     /*
52503:      * NB: init and change are fallible but do not report OOM, so callers can
56587:      * cope or ignore. They do however use JSRuntime's calloc method in order
56587:      * to update the malloc counter on success.
35453:      */
59238:     bool            init(js::Shape *lastProp, JSContext *cx);
56587:     bool            change(int log2Delta, JSContext *cx);
52503:     js::Shape       **search(jsid id, bool adding);
30258: };
30258: 
52503: } /* namespace js */
30258: 
52503: struct JSObject;
40327: 
41860: namespace js {
41860: 
40327: class PropertyTree;
41860: 
52503: static inline PropertyOp
52503: CastAsPropertyOp(js::Class *clasp)
52503: {
52503:     return JS_DATA_TO_FUNC_PTR(PropertyOp, clasp);
52503: }
40327: 
52503: struct Shape : public JSObjectMap
52503: {
52503:     friend struct ::JSObject;
52503:     friend struct ::JSFunction;
40327:     friend class js::PropertyTree;
54718:     friend bool HasUnreachableGCThings(TreeFragment *f);
52503: 
52503:   protected:
52503:     mutable js::PropertyTable *table;
52503: 
52503:   public:
52503:     inline void freeTable(JSContext *cx);
52503: 
52503:     static bool initRuntimeState(JSContext *cx);
52503:     static void finishRuntimeState(JSContext *cx);
52503: 
52503:     enum {
52503:         EMPTY_ARGUMENTS_SHAPE   = 1,
52503:         EMPTY_BLOCK_SHAPE       = 2,
52503:         EMPTY_CALL_SHAPE        = 3,
52503:         EMPTY_DECL_ENV_SHAPE    = 4,
52503:         EMPTY_ENUMERATOR_SHAPE  = 5,
52503:         EMPTY_WITH_SHAPE        = 6,
52503:         LAST_RESERVED_SHAPE     = 6
52503:     };
38562: 
48470:     jsid                id;
40331: 
52503:   protected:
40331:     union {
48470:         js::PropertyOp  rawGetter;      /* getter and setter hooks or objects */
41860:         JSObject        *getterObj;     /* user-defined callable "get" object or
52503:                                            null if shape->hasGetterValue(); or
48676:                                            joined function object if METHOD flag
48676:                                            is set. */
52503:         js::Class       *clasp;         /* prototype class for empty scope */
40331:     };
40331: 
40331:     union {
48470:         js::PropertyOp  rawSetter;      /* getter is JSObject* and setter is 0
52503:                                            if shape->isMethod() */
41860:         JSObject        *setterObj;     /* user-defined callable "set" object or
52503:                                            null if shape->hasSetterValue() */
40331:     };
40331: 
39894:   public:
    1:     uint32              slot;           /* abstract index in object slots */
40265:   private:
    1:     uint8               attrs;          /* attributes, see jsapi.h JSPROP_* */
52503:     mutable uint8       flags;          /* flags, see below for defines */
38562:   public:
    1:     int16               shortid;        /* tinyid, or local arg/var index */
52503: 
52503:   protected:
52503:     mutable js::Shape   *parent;        /* parent node, reverse for..in order */
35453:     union {
52503:         mutable js::KidsPointer kids;   /* null, single child, or a tagged ptr
    1:                                            to many-kids data structure */
52503:         mutable js::Shape **listp;      /* dictionary list starting at lastProp
35453:                                            has a double-indirect back pointer,
52503:                                            either to shape->parent if not last,
52503:                                            else to obj->lastProp */
35453:     };
30258: 
59238:     static inline js::Shape **search(js::Shape **startp, jsid id, bool adding = false);
52503:     static js::Shape *newDictionaryShape(JSContext *cx, const js::Shape &child, js::Shape **listp);
52503:     static js::Shape *newDictionaryList(JSContext *cx, js::Shape **listp);
52503: 
52503:     inline void removeFromDictionary(JSObject *obj) const;
52503:     inline void insertIntoDictionary(js::Shape **dictp);
52503: 
52503:     js::Shape *getChild(JSContext *cx, const js::Shape &child, js::Shape **listp);
52503: 
59238:     bool maybeHash(JSContext *cx);
52503: 
53650:     void setTable(js::PropertyTable *t) const {
53652:         JS_ASSERT_IF(t && t->freelist != SHAPE_INVALID_SLOT, t->freelist < slotSpan);
53650:         table = t;
53650:     }
53650: 
53650:     /*
53652:      * Setter for parent. The challenge is to maintain JSObjectMap::slotSpan in
53650:      * the face of arbitrary slot order.
53650:      *
53652:      * By induction, an empty shape has a slotSpan member correctly computed as
53650:      * JSCLASS_FREE(clasp) -- see EmptyShape's constructor in jsscopeinlines.h.
53650:      * This is the basis case, where p is null.
53650:      *
53650:      * Any child shape, whether in a shape tree or in a dictionary list, must
53652:      * have a slotSpan either one greater than its slot value (if the child's
56024:      * slot is SHAPE_INVALID_SLOT, this will yield 0; the static assertion
56024:      * below enforces this), or equal to its parent p's slotSpan, whichever is
56024:      * greater. This is the inductive step.
53650:      *
53650:      * If we maintained shape paths such that parent slot was always one less
53650:      * than child slot, possibly with an exception for SHAPE_INVALID_SLOT slot
53652:      * values where we would use another way of computing slotSpan based on the
53652:      * PropertyTable (as JSC does), then we would not need to store slotSpan in
53650:      * Shape (to be precise, in its base struct, JSobjectMap).
53650:      *
53650:      * But we currently scramble slots along shape paths due to resolve-based
53650:      * creation of shapes mapping reserved slots, and we do not have the needed
53650:      * PropertyTable machinery to use as an alternative when parent slot is not
53650:      * one less than child slot. This machinery is neither simple nor free, as
53650:      * it must involve creating a table for any slot-less transition and then
53650:      * pinning the table to its shape.
53650:      *
53650:      * Use of 'delete' can scramble slots along the shape lineage too, although
53650:      * it always switches the target object to dictionary mode, so the cost of
53650:      * a pinned table is less onerous.
53650:      *
53652:      * Note that allocating a uint32 slotSpan member in JSObjectMap takes no
53650:      * net extra space on 64-bit targets (it packs with shape). And on 32-bit
53652:      * targets, adding slotSpan to JSObjectMap takes no gross extra space,
53650:      * because Shape rounds up to an even number of 32-bit words (required for
53650:      * GC-thing and js::Value allocation in any event) on 32-bit targets.
53650:      *
53652:      * So in terms of space, we can afford to maintain both slotSpan and slot,
53652:      * but it might be better if we eliminated slotSpan using slot combined
53650:      * with an auxiliary mechanism based on table.
53650:      */
53650:     void setParent(js::Shape *p) {
56024:         JS_STATIC_ASSERT(uint32(SHAPE_INVALID_SLOT) == ~uint32(0));
53650:         if (p)
53652:             slotSpan = JS_MAX(p->slotSpan, slot + 1);
53652:         JS_ASSERT(slotSpan < JSObject::NSLOTS_LIMIT);
53650:         parent = p;
53650:     }
52503: 
52503:     void insertFree(js::Shape **freep) {
53864: #ifdef DEBUG
53864:         memset(this, JS_FREE_PATTERN, sizeof *this);
53864: #endif
52503:         id = JSID_VOID;
52503:         parent = *freep;
52503:         if (parent)
52503:             parent->listp = &parent;
52503:         listp = freep;
52503:         *freep = this;
52503:     }
52503: 
52503:     void removeFree() {
52503:         JS_ASSERT(JSID_IS_VOID(id));
52503:         *listp = parent;
52503:         if (parent)
52503:             parent->listp = listp;
52503:     }
52503: 
52503:   public:
52503:     const js::Shape *previous() const {
52503:         return parent;
52503:     }
52503: 
52503:     class Range {
52503:       protected:
52503:         friend struct Shape;
52503: 
52503:         const Shape *cursor;
52503:         const Shape *end;
52503: 
52503:       public:
52503:         Range(const Shape *shape) : cursor(shape) { }
52503: 
52503:         bool empty() const {
52503:             JS_ASSERT_IF(!cursor->parent, JSID_IS_EMPTY(cursor->id));
52503:             return !cursor->parent;
52503:         }
52503: 
52503:         const Shape &front() const {
52503:             JS_ASSERT(!empty());
52503:             return *cursor;
52503:         }
52503: 
52503:         void popFront() {
52503:             JS_ASSERT(!empty());
52503:             cursor = cursor->parent;
52503:         }
52503:     };
52503: 
52503:     Range all() const {
52503:         return Range(this);
52503:     }
52503: 
52503:   protected:
40327:     /*
52503:      * Implementation-private bits stored in shape->flags. See public: enum {}
40327:      * flags further below, which were allocated FCFS over time, so interleave
40327:      * with these bits.
40327:      */
38562:     enum {
38562:         /* GC mark flag. */
38562:         MARK            = 0x01,
32658: 
52503:         SHARED_EMPTY    = 0x02,
52503: 
38562:         /*
38562:          * Set during a shape-regenerating GC if the shape has already been
52503:          * regenerated.
38562:          */
52503:         SHAPE_REGEN     = 0x04,
38562: 
38562:         /* Property stored in per-object dictionary, not shared property tree. */
52503:         IN_DICTIONARY   = 0x08,
52503: 
52503:         /* Prevent unwanted mutation of shared JSFunction::u.i.names nodes. */
52503:         FROZEN          = 0x10
38562:     };
38562: 
53650:     Shape(jsid id, js::PropertyOp getter, js::PropertyOp setter, uint32 slot, uintN attrs,
53652:           uintN flags, intN shortid, uint32 shape = INVALID_SHAPE, uint32 slotSpan = 0);
39894: 
52503:     /* Used by EmptyShape (see jsscopeinlines.h). */
52503:     Shape(JSContext *cx, Class *aclasp);
52503: 
38562:     bool marked() const         { return (flags & MARK) != 0; }
52503:     void mark() const           { flags |= MARK; }
38562:     void clearMark()            { flags &= ~MARK; }
38562: 
38562:     bool hasRegenFlag() const   { return (flags & SHAPE_REGEN) != 0; }
38562:     void setRegenFlag()         { flags |= SHAPE_REGEN; }
38562:     void clearRegenFlag()       { flags &= ~SHAPE_REGEN; }
38562: 
38562:     bool inDictionary() const   { return (flags & IN_DICTIONARY) != 0; }
52503:     bool frozen() const         { return (flags & FROZEN) != 0; }
52503:     void setFrozen()            { flags |= FROZEN; }
52503: 
52503:     bool isEmptyShape() const   { JS_ASSERT_IF(!parent, JSID_IS_EMPTY(id)); return !parent; }
38562: 
38562:   public:
52503:     /* Public bits stored in shape->flags. */
38562:     enum {
52503:         ALIAS           = 0x20,
52503:         HAS_SHORTID     = 0x40,
52503:         METHOD          = 0x80,
38562:         PUBLIC_FLAGS    = ALIAS | HAS_SHORTID | METHOD
38562:     };
38562: 
38562:     uintN getFlags() const  { return flags & PUBLIC_FLAGS; }
38562:     bool isAlias() const    { return (flags & ALIAS) != 0; }
38562:     bool hasShortID() const { return (flags & HAS_SHORTID) != 0; }
38562:     bool isMethod() const   { return (flags & METHOD) != 0; }
38562: 
48470:     JSObject &methodObject() const { JS_ASSERT(isMethod()); return *getterObj; }
32658: 
48470:     js::PropertyOp getter() const { return rawGetter; }
39894:     bool hasDefaultGetter() const  { return !rawGetter; }
48470:     js::PropertyOp getterOp() const { JS_ASSERT(!hasGetterValue()); return rawGetter; }
41860:     JSObject *getterObject() const { JS_ASSERT(hasGetterValue()); return getterObj; }
41860: 
41860:     // Per ES5, decode null getterObj as the undefined value, which encodes as null.
48470:     js::Value getterValue() const {
40265:         JS_ASSERT(hasGetterValue());
48470:         return getterObj ? js::ObjectValue(*getterObj) : js::UndefinedValue();
32658:     }
32658: 
48470:     js::Value getterOrUndefined() const {
48519:         return hasGetterValue() && getterObj ? js::ObjectValue(*getterObj) : js::UndefinedValue();
48470:     }
48470: 
48470:     js::PropertyOp setter() const { return rawSetter; }
39894:     bool hasDefaultSetter() const  { return !rawSetter; }
48470:     js::PropertyOp setterOp() const { JS_ASSERT(!hasSetterValue()); return rawSetter; }
41860:     JSObject *setterObject() const { JS_ASSERT(hasSetterValue()); return setterObj; }
41860: 
41860:     // Per ES5, decode null setterObj as the undefined value, which encodes as null.
48470:     js::Value setterValue() const {
40265:         JS_ASSERT(hasSetterValue());
48470:         return setterObj ? js::ObjectValue(*setterObj) : js::UndefinedValue();
48470:     }
48470: 
48470:     js::Value setterOrUndefined() const {
48519:         return hasSetterValue() && setterObj ? js::ObjectValue(*setterObj) : js::UndefinedValue();
32658:     }
32658: 
38562:     inline JSDHashNumber hash() const;
52503:     inline bool matches(const js::Shape *p) const;
48470:     inline bool matchesParamsAfterId(js::PropertyOp agetter, js::PropertyOp asetter,
48470:                                      uint32 aslot, uintN aattrs, uintN aflags,
48470:                                      intN ashortid) const;
38562: 
57739:     bool get(JSContext* cx, JSObject *receiver, JSObject *obj, JSObject *pobj, js::Value* vp) const;
52503:     bool set(JSContext* cx, JSObject *obj, js::Value* vp) const;
32658: 
40327:     inline bool isSharedPermanent() const;
40327: 
52503:     void trace(JSTracer *trc) const;
36991: 
40265:     bool hasSlot() const { return (attrs & JSPROP_SHARED) == 0; }
36991: 
40265:     uint8 attributes() const { return attrs; }
40265:     bool configurable() const { return (attrs & JSPROP_PERMANENT) == 0; }
40265:     bool enumerable() const { return (attrs & JSPROP_ENUMERATE) != 0; }
40265:     bool writable() const {
40265:         // JS_ASSERT(isDataDescriptor());
40265:         return (attrs & JSPROP_READONLY) == 0;
40265:     }
40265:     bool hasGetterValue() const { return attrs & JSPROP_GETTER; }
40265:     bool hasSetterValue() const { return attrs & JSPROP_SETTER; }
40265: 
40265:     bool hasDefaultGetterOrIsMethod() const {
40265:         return hasDefaultGetter() || isMethod();
40265:     }
40265: 
40265:     bool isDataDescriptor() const {
36991:         return (attrs & (JSPROP_SETTER | JSPROP_GETTER)) == 0;
36991:     }
40265:     bool isAccessorDescriptor() const {
36991:         return (attrs & (JSPROP_SETTER | JSPROP_GETTER)) != 0;
36991:     }
38562: 
52503:     uint32 entryCount() const {
52503:         if (table)
52503:             return table->entryCount;
52503: 
52503:         const js::Shape *shape = this;
52503:         uint32 count = 0;
52503:         for (js::Shape::Range r = shape->all(); !r.empty(); r.popFront())
52503:             ++count;
52503:         return count;
52503:     }
52503: 
38562: #ifdef DEBUG
52503:     void dump(JSContext *cx, FILE *fp) const;
52503:     void dumpSubtree(JSContext *cx, int level, FILE *fp) const;
38562: #endif
    1: };
    1: 
52503: struct EmptyShape : public js::Shape
52503: {
52503:     EmptyShape(JSContext *cx, js::Class *aclasp);
    1: 
52503:     js::Class *getClass() const { return clasp; };
    1: 
52503:     static EmptyShape *create(JSContext *cx, js::Class *clasp) {
52503:         js::Shape *eprop = JS_PROPERTY_TREE(cx).newShape(cx);
52503:         if (!eprop)
52503:             return NULL;
52503:         return new (eprop) EmptyShape(cx, clasp);
52503:     }
52503: };
    1: 
52503: } /* namespace js */
    1: 
52503: /* js::Shape pointer tag bit indicating a collision. */
52503: #define SHAPE_COLLISION                 (jsuword(1))
52503: #define SHAPE_REMOVED                   ((js::Shape *) SHAPE_COLLISION)
52503: 
52503: /* Macros to get and set shape pointer values and collision flags. */
52503: #define SHAPE_IS_FREE(shape)            ((shape) == NULL)
52503: #define SHAPE_IS_REMOVED(shape)         ((shape) == SHAPE_REMOVED)
52503: #define SHAPE_IS_LIVE(shape)            ((shape) > SHAPE_REMOVED)
52503: #define SHAPE_FLAG_COLLISION(spp,shape) (*(spp) = (js::Shape *)               \
52503:                                          (jsuword(shape) | SHAPE_COLLISION))
52503: #define SHAPE_HAD_COLLISION(shape)      (jsuword(shape) & SHAPE_COLLISION)
52503: #define SHAPE_FETCH(spp)                SHAPE_CLEAR_COLLISION(*(spp))
52503: 
52503: #define SHAPE_CLEAR_COLLISION(shape)                                          \
52503:     ((js::Shape *) (jsuword(shape) & ~SHAPE_COLLISION))
52503: 
52503: #define SHAPE_STORE_PRESERVING_COLLISION(spp, shape)                          \
52503:     (*(spp) = (js::Shape *) (jsuword(shape) | SHAPE_HAD_COLLISION(*(spp))))
52503: 
52503: inline js::Shape **
52503: JSObject::nativeSearch(jsid id, bool adding)
30258: {
59238:     return js::Shape::search(&lastProp, id, adding);
52503: }
52503: 
52503: inline const js::Shape *
52503: JSObject::nativeLookup(jsid id)
52503: {
57686:     JS_ASSERT(isNative());
52503:     return SHAPE_FETCH(nativeSearch(id));
30258: }
30258: 
32658: inline bool
52503: JSObject::nativeContains(jsid id)
30258: {
52503:     return nativeLookup(id) != NULL;
30258: }
30258: 
52503: inline bool
52503: JSObject::nativeContains(const js::Shape &shape)
35453: {
52503:     return nativeLookup(shape.id) == &shape;
52503: }
52503: 
52503: inline const js::Shape *
52503: JSObject::lastProperty() const
52503: {
52503:     JS_ASSERT(isNative());
52503:     JS_ASSERT(!JSID_IS_VOID(lastProp->id));
35453:     return lastProp;
35453: }
35453: 
52503: inline bool
52503: JSObject::nativeEmpty() const
52503: {
52503:     return lastProperty()->isEmptyShape();
52503: }
52503: 
52503: inline bool
52503: JSObject::inDictionaryMode() const
52503: {
52503:     return lastProperty()->inDictionary();
52503: }
52503: 
52503: inline uint32
52503: JSObject::propertyCount() const
52503: {
52503:     return lastProperty()->entryCount();
52503: }
52503: 
52503: inline bool
52503: JSObject::hasPropertyTable() const
52503: {
52503:     return !!lastProperty()->table;
52503: }
52503: 
35453: /*
52503:  * FIXME: shape must not be null, should use a reference here and other places.
35453:  */
35453: inline void
52503: JSObject::setLastProperty(const js::Shape *shape)
35453: {
52503:     JS_ASSERT(!inDictionaryMode());
52503:     JS_ASSERT(!JSID_IS_VOID(shape->id));
48470:     JS_ASSERT_IF(lastProp, !JSID_IS_VOID(lastProp->id));
35453: 
52503:     lastProp = const_cast<js::Shape *>(shape);
35453: }
35453: 
35453: inline void
52503: JSObject::removeLastProperty()
35453: {
35453:     JS_ASSERT(!inDictionaryMode());
52503:     JS_ASSERT(!JSID_IS_VOID(lastProp->parent->id));
35453: 
35453:     lastProp = lastProp->parent;
52503: }
52503: 
52503: namespace js {
52503: 
52503: inline void
52503: Shape::removeFromDictionary(JSObject *obj) const
52503: {
52503:     JS_ASSERT(!frozen());
52503:     JS_ASSERT(inDictionary());
52503:     JS_ASSERT(obj->inDictionaryMode());
52503:     JS_ASSERT(listp);
52503:     JS_ASSERT(!JSID_IS_VOID(id));
52503: 
52503:     JS_ASSERT(obj->lastProp->inDictionary());
52503:     JS_ASSERT(obj->lastProp->listp == &obj->lastProp);
52503:     JS_ASSERT_IF(obj->lastProp != this, !JSID_IS_VOID(obj->lastProp->id));
52503:     JS_ASSERT_IF(obj->lastProp->parent, !JSID_IS_VOID(obj->lastProp->parent->id));
52503: 
52503:     if (parent)
52503:         parent->listp = listp;
52503:     *listp = parent;
52503:     listp = NULL;
35453: }
35453: 
35453: inline void
52503: Shape::insertIntoDictionary(js::Shape **dictp)
35453: {
35453:     /*
35453:      * Don't assert inDictionaryMode() here because we may be called from
52503:      * JSObject::toDictionaryMode via JSObject::newDictionaryShape.
35453:      */
52503:     JS_ASSERT(inDictionary());
52503:     JS_ASSERT(!listp);
52503:     JS_ASSERT(!JSID_IS_VOID(id));
35453: 
52503:     JS_ASSERT_IF(*dictp, !(*dictp)->frozen());
52503:     JS_ASSERT_IF(*dictp, (*dictp)->inDictionary());
52503:     JS_ASSERT_IF(*dictp, (*dictp)->listp == dictp);
52503:     JS_ASSERT_IF(*dictp, !JSID_IS_VOID((*dictp)->id));
35453: 
53650:     setParent(*dictp);
52503:     if (parent)
52503:         parent->listp = &parent;
52503:     listp = dictp;
52503:     *dictp = this;
35453: }
35453: 
52503: } /* namespace js */
52503: 
    1: /*
52503:  * If SHORTID is set in shape->flags, we use shape->shortid rather
52503:  * than id when calling shape's getter or setter.
    1:  */
52503: #define SHAPE_USERID(shape)                                                   \
52503:     ((shape)->hasShortID() ? INT_TO_JSID((shape)->shortid)                    \
52503:                            : (shape)->id)
    1: 
48619: #ifndef JS_THREADSAFE
48619: # define js_GenerateShape(cx, gcLocked)    js_GenerateShape (cx)
48619: #endif
48619: 
30258: extern uint32
30258: js_GenerateShape(JSContext *cx, bool gcLocked);
30258: 
35453: #ifdef DEBUG
32658: struct JSScopeStats {
32658:     jsrefcount          searches;
32658:     jsrefcount          hits;
32658:     jsrefcount          misses;
32658:     jsrefcount          hashes;
52503:     jsrefcount          hashHits;
52503:     jsrefcount          hashMisses;
32658:     jsrefcount          steps;
32658:     jsrefcount          stepHits;
32658:     jsrefcount          stepMisses;
52503:     jsrefcount          initSearches;
52503:     jsrefcount          changeSearches;
35453:     jsrefcount          tableAllocFails;
35453:     jsrefcount          toDictFails;
35453:     jsrefcount          wrapWatchFails;
32658:     jsrefcount          adds;
35453:     jsrefcount          addFails;
35453:     jsrefcount          puts;
35453:     jsrefcount          redundantPuts;
35453:     jsrefcount          putFails;
35453:     jsrefcount          changes;
54587:     jsrefcount          changePuts;
35453:     jsrefcount          changeFails;
32658:     jsrefcount          compresses;
32658:     jsrefcount          grows;
32658:     jsrefcount          removes;
32658:     jsrefcount          removeFrees;
32658:     jsrefcount          uselessRemoves;
32658:     jsrefcount          shrinks;
32658: };
32658: 
32658: extern JS_FRIEND_DATA(JSScopeStats) js_scope_stats;
32658: 
30281: # define METER(x)       JS_ATOMIC_INCREMENT(&js_scope_stats.x)
30281: #else
30281: # define METER(x)       /* nothing */
30281: #endif
30281: 
52503: namespace js {
52503: 
59701: inline static volatile int *vcopy(volatile int *dst, int *src, size_t bytes)
59701: {
59701:     int *end = src + bytes / sizeof(int);
59701:     for (; src < end; ++src, ++dst)
59701:         *dst = *src;
59701:     return dst;
59701: }
59701: 
52503: JS_ALWAYS_INLINE js::Shape **
59238: Shape::search(js::Shape **startp, jsid id, bool adding)
30281: {
52503:     METER(searches);
59238:     if (!(*startp)->table) {
52503:         /*
59238:          * Not enough properties to justify hashing: search from *startp.
52503:          *
52503:          * We don't use a Range here, or stop at null parent (the empty shape
52503:          * at the end), to avoid an extra load per iteration just to save a
52503:          * load and id test at the end (when missing).
52503:          */
59238:         js::Shape **spp;
59237: 
52509:         for (spp = startp; js::Shape *shape = *spp; spp = &shape->parent) {
52503:             if (shape->id == id) {
30281:                 METER(hits);
30281:                 return spp;
30281:             }
30281:         }
30281:         METER(misses);
30281:         return spp;
30281:     }
59701:     {
59701:         char blackbox[sizeof(Shape) + 8];
59701:         volatile int *p = (int *) blackbox;
59701:         *p++ = 0xfcfcfcfc;
59701:         p = vcopy(p, (int *) *startp, sizeof(Shape));
59701:         *p = 0xfdfdfdfd;
59701:     }
59238:     return (*startp)->table->search(id, adding);
59238: }
30281: 
30281: #undef METER
30281: 
35117: inline bool
52503: Shape::isSharedPermanent() const
40265: {
40327:     return (~attrs & (JSPROP_SHARED | JSPROP_PERMANENT)) == 0;
40265: }
    1: 
50491: }
50491: 
33166: #ifdef _MSC_VER
33166: #pragma warning(pop)
39928: #pragma warning(pop)
33166: #endif
33166: 
    1: #endif /* jsscope_h___ */
