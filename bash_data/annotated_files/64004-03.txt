    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsDocAccessibleWrap.h"
    1: #include "ISimpleDOMDocument_i.c"
    1: #include "nsIAccessibilityService.h"
54220: #include "nsRootAccessible.h"
54220: #include "nsWinUtils.h"
54220: 
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeNode.h"
    1: #include "nsIFrame.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsISelectionController.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIURI.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIWebNavigation.h"
    1: 
    1: /* For documentation of the accessibility architecture, 
    1:  * see http://lxr.mozilla.org/seamonkey/source/accessible/accessible-docs.html
    1:  */
    1: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsDocAccessibleWrap
43310: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsDocAccessibleWrap::
43504:   nsDocAccessibleWrap(nsIDocument *aDocument, nsIContent *aRootContent,
43310:                       nsIWeakReference *aShell) :
54220:   nsDocAccessible(aDocument, aRootContent, aShell), mHWND(NULL)
    1: {
    1: }
    1: 
    1: nsDocAccessibleWrap::~nsDocAccessibleWrap()
    1: {
    1: }
    1: 
    1: //-----------------------------------------------------
    1: // IUnknown interface methods - see iunknown.h for documentation
    1: //-----------------------------------------------------
    1: STDMETHODIMP_(ULONG) nsDocAccessibleWrap::AddRef()
    1: {
    1:   return nsAccessNode::AddRef();
    1: }
    1: 
    1: STDMETHODIMP_(ULONG) nsDocAccessibleWrap::Release()
    1: {
    1:   return nsAccessNode::Release();
    1: }
    1: 
    1: // Microsoft COM QueryInterface
    1: STDMETHODIMP nsDocAccessibleWrap::QueryInterface(REFIID iid, void** ppv)
    1: {
    1:   *ppv = NULL;
    1: 
    1:   if (IID_ISimpleDOMDocument == iid)
 3233:     *ppv = static_cast<ISimpleDOMDocument*>(this);
    1: 
    1:   if (NULL == *ppv)
 1072:     return nsHyperTextAccessibleWrap::QueryInterface(iid, ppv);
    1:     
 3233:   (reinterpret_cast<IUnknown*>(*ppv))->AddRef();
    1:   return S_OK;
    1: }
    1: 
42375: nsAccessible*
42375: nsDocAccessibleWrap::GetXPAccessibleFor(const VARIANT& aVarChild)
    1: {
30528:   // If lVal negative then it is treated as child ID and we should look for
30528:   // accessible through whole accessible subtree including subdocuments.
30528:   // Otherwise we treat lVal as index in parent.
30528: 
52279:   if (aVarChild.vt == VT_I4 && aVarChild.lVal < 0) {
52279:     // Convert child ID to unique ID.
52279:     void* uniqueID = reinterpret_cast<void*>(-aVarChild.lVal);
61461:     return GetAccessibleByUniqueIDInSubtree(uniqueID);
52279:   }
42375: 
42375:   return nsAccessibleWrap::GetXPAccessibleFor(aVarChild);
    1: }
    1: 
    1: STDMETHODIMP nsDocAccessibleWrap::get_URL(/* [out] */ BSTR __RPC_FAR *aURL)
    1: {
11593: __try {
    1:   *aURL = NULL;
13128: 
    1:   nsAutoString URL;
13130:   nsresult rv = GetURL(URL);
13128:   if (NS_FAILED(rv))
13128:     return E_FAIL;
13128: 
13128:   if (URL.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aURL = ::SysAllocStringLen(URL.get(), URL.Length());
13128:   return *aURL ? S_OK : E_OUTOFMEMORY;
13128: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsDocAccessibleWrap::get_title( /* [out] */ BSTR __RPC_FAR *aTitle)
    1: {
11593: __try {
    1:   *aTitle = NULL;
13128: 
    1:   nsAutoString title;
13130:   nsresult rv = GetTitle(title);
13128:   if (NS_FAILED(rv))
13128:     return E_FAIL;
13128: 
13128:   *aTitle = ::SysAllocStringLen(title.get(), title.Length());
13128:   return *aTitle ? S_OK : E_OUTOFMEMORY;
13128: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsDocAccessibleWrap::get_mimeType(/* [out] */ BSTR __RPC_FAR *aMimeType)
    1: {
11593: __try {
    1:   *aMimeType = NULL;
13128: 
    1:   nsAutoString mimeType;
13130:   nsresult rv = GetMimeType(mimeType);
13128:   if (NS_FAILED(rv))
13128:     return E_FAIL;
13128: 
13128:   if (mimeType.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aMimeType = ::SysAllocStringLen(mimeType.get(), mimeType.Length());
13128:   return *aMimeType ? S_OK : E_OUTOFMEMORY;
13128: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsDocAccessibleWrap::get_docType(/* [out] */ BSTR __RPC_FAR *aDocType)
    1: {
11593: __try {
    1:   *aDocType = NULL;
13128: 
    1:   nsAutoString docType;
13130:   nsresult rv = GetDocType(docType);
13128:   if (NS_FAILED(rv))
13128:     return E_FAIL;
13128: 
13128:   if (docType.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aDocType = ::SysAllocStringLen(docType.get(), docType.Length());
13128:   return *aDocType ? S_OK : E_OUTOFMEMORY;
13128: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsDocAccessibleWrap::get_nameSpaceURIForID(/* [in] */  short aNameSpaceID,
    1:   /* [out] */ BSTR __RPC_FAR *aNameSpaceURI)
    1: {
11593: __try {
    1:   *aNameSpaceURI = NULL;
13128: 
13128:   if (aNameSpaceID < 0)
13128:     return E_INVALIDARG;  // -1 is kNameSpaceID_Unknown
13128: 
    1:   nsAutoString nameSpaceURI;
13130:   nsresult rv = GetNameSpaceURIForID(aNameSpaceID, nameSpaceURI);
13128:   if (NS_FAILED(rv))
13128:     return E_FAIL;
13128: 
13128:   if (nameSpaceURI.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aNameSpaceURI = ::SysAllocStringLen(nameSpaceURI.get(),
13128:                                        nameSpaceURI.Length());
13128: 
13128:   return *aNameSpaceURI ? S_OK : E_OUTOFMEMORY;
13128: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_FAIL;
    1: }
    1: 
13128: STDMETHODIMP
13128: nsDocAccessibleWrap::put_alternateViewMediaTypes( /* [in] */ BSTR __RPC_FAR *aCommaSeparatedMediaTypes)
    1: {
13128: __try {
13128:   *aCommaSeparatedMediaTypes = NULL;
13128: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13128: 
    1:   return E_NOTIMPL;
    1: }
    1: 
13094: STDMETHODIMP nsDocAccessibleWrap::get_accValue(
13094:       /* [optional][in] */ VARIANT varChild,
13094:       /* [retval][out] */ BSTR __RPC_FAR *pszValue)
13094: {
13094:   // For backwards-compat, we still support old MSAA hack to provide URL in accValue
13094:   *pszValue = NULL;
13094:   // Check for real value first
13094:   HRESULT hr = nsAccessibleWrap::get_accValue(varChild, pszValue);
13094:   if (FAILED(hr) || *pszValue || varChild.lVal != CHILDID_SELF)
13094:     return hr;
13094:   // If document is being used to create a widget, don't use the URL hack
52089:   PRUint32 role = Role();
13094:   if (role != nsIAccessibleRole::ROLE_DOCUMENT &&
13094:       role != nsIAccessibleRole::ROLE_APPLICATION &&
13094:       role != nsIAccessibleRole::ROLE_DIALOG &&
13094:       role != nsIAccessibleRole::ROLE_ALERT)
13094:     return hr;
13094: 
13094:   return get_URL(pszValue);
13094: }
54220: 
54220: ////////////////////////////////////////////////////////////////////////////////
54220: // nsAccessNode
54220: 
54220: void
54220: nsDocAccessibleWrap::Shutdown()
54220: {
64004:   // Do window emulation specific shutdown if emulation was started.
64004:   if (nsWinUtils::IsWindowEmulationStarted()) {
54220:     // Destroy window created for root document.
54220:     if (nsWinUtils::IsTabDocument(mDocument)) {
64004:       sHWNDCache.Remove(mHWND);
54220:       ::DestroyWindow(static_cast<HWND>(mHWND));
54220:     }
54220: 
54220:     mHWND = nsnull;
54220:   }
54220: 
54220:   nsDocAccessible::Shutdown();
54220: }
54220: 
54220: ////////////////////////////////////////////////////////////////////////////////
63261: // nsDocAccessible public
54220: 
54220: void*
54220: nsDocAccessibleWrap::GetNativeWindow() const
54220: {
54220:   return mHWND ? mHWND : nsDocAccessible::GetNativeWindow();
54220: }
63261: 
63261: ////////////////////////////////////////////////////////////////////////////////
63261: // nsDocAccessible protected
63261: 
63261: void
63261: nsDocAccessibleWrap::NotifyOfInitialUpdate()
63261: {
63310:   nsDocAccessible::NotifyOfInitialUpdate();
63310: 
64004:   if (nsWinUtils::IsWindowEmulationStarted()) {
63261:     // Create window for tab document.
63261:     if (nsWinUtils::IsTabDocument(mDocument)) {
63261:       nsRootAccessible* rootDocument = RootAccessible();
63261: 
63261:       PRBool isActive = PR_TRUE;
63261:       PRInt32 x = CW_USEDEFAULT, y = CW_USEDEFAULT, width = 0, height = 0;
64004:       if (nsWinUtils::IsWindowEmulationFor(kDolphinModuleHandle)) {
63261:         GetBounds(&x, &y, &width, &height);
63261:         PRInt32 rootX = 0, rootY = 0, rootWidth = 0, rootHeight = 0;
63261:         rootDocument->GetBounds(&rootX, &rootY, &rootWidth, &rootHeight);
63261:         x = rootX - x;
63261:         y -= rootY;
63261: 
63261:         nsCOMPtr<nsISupports> container = mDocument->GetContainer();
63261:         nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(container);
63261:         docShell->GetIsActive(&isActive);
63261:       }
63261: 
63261:       HWND parentWnd = static_cast<HWND>(rootDocument->GetNativeWindow());
63261:       mHWND = nsWinUtils::CreateNativeWindow(kClassNameTabContent, parentWnd,
63261:                                              x, y, width, height, isActive);
63261: 
64004:       sHWNDCache.Put(mHWND, this);
63261: 
63261:     } else {
63261:       nsDocAccessible* parentDocument = ParentDocument();
63261:       if (parentDocument)
63261:         mHWND = parentDocument->GetNativeWindow();
63261:     }
63261:   }
63261: }
