    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "imgRequestProxy.h"
    1: 
    1: #include "nsIInputStream.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIMultiPartChannel.h"
    1: 
    1: #include "nsString.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsCRT.h"
    1: 
50546: #include "Image.h"
    1: #include "ImageErrors.h"
    1: #include "ImageLogging.h"
    1: 
    1: #include "nspr.h"
    1: 
50546: using namespace mozilla::imagelib;
50546: 
18557: NS_IMPL_ISUPPORTS4(imgRequestProxy, imgIRequest, nsIRequest,
18557:                    nsISupportsPriority, nsISecurityInfoProvider)
    1: 
    1: imgRequestProxy::imgRequestProxy() :
    1:   mOwner(nsnull),
48319:   mURI(nsnull),
48319:   mImage(nsnull),
48319:   mPrincipal(nsnull),
    1:   mListener(nsnull),
    1:   mLoadFlags(nsIRequest::LOAD_NORMAL),
32516:   mLocksHeld(0),
51297:   mDeferredLocks(0),
    1:   mCanceled(PR_FALSE),
13293:   mIsInLoadGroup(PR_FALSE),
32424:   mListenerIsStrongRef(PR_FALSE),
48321:   mDecodeRequested(PR_FALSE),
49700:   mDeferNotifications(PR_FALSE),
49700:   mSentStartContainer(PR_FALSE)
    1: {
    1:   /* member initializers and constructor code */
    1: 
    1: }
    1: 
    1: imgRequestProxy::~imgRequestProxy()
    1: {
    1:   /* destructor code */
    1:   NS_PRECONDITION(!mListener, "Someone forgot to properly cancel this request!");
22953: 
32516:   // Unlock the image the proper number of times if we're holding locks on it.
32516:   // Note that UnlockImage() decrements mLocksHeld each time it's called.
51297:   while (mLocksHeld || mDeferredLocks)
32424:     UnlockImage();
32424: 
    1:   // Explicitly set mListener to null to ensure that the RemoveProxy
    1:   // call below can't send |this| to an arbitrary listener while |this|
13293:   // is being destroyed.  This is all belt-and-suspenders in view of the
13293:   // above assert.
13293:   NullOutListener();
    1: 
    1:   if (mOwner) {
    1:     if (!mCanceled) {
    1:       mCanceled = PR_TRUE;
    1: 
    1:       /* Call RemoveProxy with a successful status.  This will keep the
    1:          channel, if still downloading data, from being canceled if 'this' is
    1:          the last observer.  This allows the image to continue to download and
    1:          be cached even if no one is using it currently.
    1:          
    1:          Passing false to aNotify means that we will still get
    1:          OnStopRequest, if needed.
    1:        */
    1:       mOwner->RemoveProxy(this, NS_OK, PR_FALSE);
    1:     }
    1:   }
    1: }
    1: 
50546: nsresult imgRequestProxy::Init(imgRequest* request, nsILoadGroup* aLoadGroup, Image* aImage,
48320:                                nsIURI* aURI, imgIDecoderObserver* aObserver)
    1: {
 6229:   NS_PRECONDITION(!mOwner && !mListener, "imgRequestProxy is already initialized");
    1: 
    1:   LOG_SCOPE_WITH_PARAM(gImgLog, "imgRequestProxy::Init", "request", request);
    1: 
    1:   mOwner = request;
    1:   mListener = aObserver;
13293:   // Make sure to addref mListener before the AddProxy call below, since
13293:   // that call might well want to release it if the imgRequest has
13293:   // already seen OnStopRequest.
13293:   if (mListener) {
13293:     mListenerIsStrongRef = PR_TRUE;
13293:     NS_ADDREF(mListener);
13293:   }
    1:   mLoadGroup = aLoadGroup;
48320:   mImage = aImage;
48319:   mURI = aURI;
    1: 
23532:   // Note: AddProxy won't send all the On* notifications immediately
48320:   if (mOwner)
48320:     mOwner->AddProxy(this);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult imgRequestProxy::ChangeOwner(imgRequest *aNewOwner)
    1: {
48319:   NS_PRECONDITION(mOwner, "Cannot ChangeOwner on a proxy without an owner!");
48319: 
48320:   // If we're holding locks, unlock the old image.
48320:   // Note that UnlockImage decrements mLocksHeld each time it's called.
51297:   PRUint32 oldLockCount = mImage ? mLocksHeld : mDeferredLocks;
51297:   while (mLocksHeld || mDeferredLocks)
48320:     UnlockImage();
48320: 
48320:   // Even if we are cancelled, we MUST change our image, because the image
48320:   // holds our status, and the status must always be correct.
48320:   mImage = aNewOwner->mImage;
48320: 
48320:   // If we were locked, apply the locks here
48320:   for (PRUint32 i = 0; i < oldLockCount; i++)
48320:     LockImage();
48320: 
    1:   if (mCanceled)
    1:     return NS_OK;
    1: 
32424:   // Were we decoded before?
32424:   PRBool wasDecoded = PR_FALSE;
51297:   if (mImage &&
51297:       (mImage->GetStatusTracker().GetImageStatus() &
51297:        imgIRequest::STATUS_FRAME_COMPLETE)) {
32424:     wasDecoded = PR_TRUE;
51297:   }
32424: 
    1:   // Passing false to aNotify means that mListener will still get
    1:   // OnStopRequest, if needed.
    1:   mOwner->RemoveProxy(this, NS_IMAGELIB_CHANGING_OWNER, PR_FALSE);
    1: 
    1:   mOwner = aNewOwner;
    1: 
 6229:   mOwner->AddProxy(this);
    1: 
32516:   // If we were decoded, or if we'd previously requested a decode, request a
32516:   // decode on the new image
32516:   if (wasDecoded || mDecodeRequested)
32516:     mOwner->RequestDecode();
32424: 
    1:   return NS_OK;
    1: }
    1: 
    1: void imgRequestProxy::AddToLoadGroup()
    1: {
    1:   NS_ASSERTION(!mIsInLoadGroup, "Whaa, we're already in the loadgroup!");
    1: 
    1:   if (!mIsInLoadGroup && mLoadGroup) {
    1:     mLoadGroup->AddRequest(this, nsnull);
    1:     mIsInLoadGroup = PR_TRUE;
    1:   }
    1: }
    1: 
    1: void imgRequestProxy::RemoveFromLoadGroup(PRBool releaseLoadGroup)
    1: {
    1:   if (!mIsInLoadGroup)
    1:     return;
    1: 
    1:   /* calling RemoveFromLoadGroup may cause the document to finish
    1:      loading, which could result in our death.  We need to make sure
    1:      that we stay alive long enough to fight another battle... at
    1:      least until we exit this function.
    1:   */
    1:   nsCOMPtr<imgIRequest> kungFuDeathGrip(this);
    1: 
42286:   mLoadGroup->RemoveRequest(this, nsnull, NS_OK);
    1:   mIsInLoadGroup = PR_FALSE;
    1: 
    1:   if (releaseLoadGroup) {
    1:     // We're done with the loadgroup, release it.
    1:     mLoadGroup = nsnull;
    1:   }
    1: }
    1: 
    1: 
    1: /**  nsIRequest / imgIRequest methods **/
    1: 
    1: /* readonly attribute wstring name; */
    1: NS_IMETHODIMP imgRequestProxy::GetName(nsACString &aName)
    1: {
    1:   aName.Truncate();
48319: 
48319:   if (mURI)
48319:     mURI->GetSpec(aName);
48319: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* boolean isPending (); */
    1: NS_IMETHODIMP imgRequestProxy::IsPending(PRBool *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* readonly attribute nsresult status; */
    1: NS_IMETHODIMP imgRequestProxy::GetStatus(nsresult *aStatus)
    1: {
24472:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* void cancel (in nsresult status); */
    1: NS_IMETHODIMP imgRequestProxy::Cancel(nsresult status)
    1: {
48320:   if (mCanceled)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   LOG_SCOPE(gImgLog, "imgRequestProxy::Cancel");
    1: 
    1:   mCanceled = PR_TRUE;
    1: 
22953:   nsCOMPtr<nsIRunnable> ev = new imgCancelRunnable(this, status);
22953:   return NS_DispatchToCurrentThread(ev);
22953: }
22953: 
22953: void
22953: imgRequestProxy::DoCancel(nsresult status)
22953: {
    1:   // Passing false to aNotify means that mListener will still get
    1:   // OnStopRequest, if needed.
48320:   if (mOwner)
    1:     mOwner->RemoveProxy(this, status, PR_FALSE);
    1: 
13293:   NullOutListener();
22953: }
22953: 
22953: /* void cancelAndForgetObserver (in nsresult aStatus); */
22953: NS_IMETHODIMP imgRequestProxy::CancelAndForgetObserver(nsresult aStatus)
22953: {
48320:   if (mCanceled)
22953:     return NS_ERROR_FAILURE;
22953: 
22953:   LOG_SCOPE(gImgLog, "imgRequestProxy::CancelAndForgetObserver");
22953: 
22953:   mCanceled = PR_TRUE;
22953: 
39122:   // Now cheat and make sure our removal from loadgroup happens async
39122:   PRBool oldIsInLoadGroup = mIsInLoadGroup;
39122:   mIsInLoadGroup = PR_FALSE;
39122: 
22953:   // Passing false to aNotify means that mListener will still get
22953:   // OnStopRequest, if needed.
48320:   if (mOwner)
22953:     mOwner->RemoveProxy(this, aStatus, PR_FALSE);
22953: 
39122:   mIsInLoadGroup = oldIsInLoadGroup;
39122: 
39122:   if (mIsInLoadGroup) {
39122:     nsCOMPtr<nsIRunnable> ev =
41361:       NS_NewRunnableMethod(this, &imgRequestProxy::DoRemoveFromLoadGroup);
39122:     NS_DispatchToCurrentThread(ev);
39122:   }
39122: 
22953:   NullOutListener();
21421: 
21421:   return NS_OK;
    1: }
    1: 
32424: /* void requestDecode (); */
32424: NS_IMETHODIMP
32424: imgRequestProxy::RequestDecode()
32424: {
32424:   if (!mOwner)
32424:     return NS_ERROR_FAILURE;
32424: 
32516:   // Flag this, so we know to transfer the request if our owner changes
32516:   mDecodeRequested = PR_TRUE;
32424: 
32516:   // Forward the request
32516:   return mOwner->RequestDecode();
32424: }
32424: 
32424: /* void lockImage (); */
32424: NS_IMETHODIMP
32424: imgRequestProxy::LockImage()
32424: {
51297:   NS_ABORT_IF_FALSE(mImage || mLocksHeld == 0,
51297:                     "have locks without an image to have locked");
51297:   NS_ABORT_IF_FALSE(!mImage || mDeferredLocks == 0,
51297:                     "have deferred locks that should have been converted "
51297:                     "into actual locks, since we have an image");
51297:   if (!mImage) {
51297:     // mOwner hasn't instantiated its image yet.
51297:     mDeferredLocks++;
51297:     return NS_OK;
51297:   }
51297: 
32516:   mLocksHeld++;
48319:   return mImage->LockImage();
32424: }
32424: 
32424: /* void unlockImage (); */
32424: NS_IMETHODIMP
32424: imgRequestProxy::UnlockImage()
32424: {
51297:   NS_ABORT_IF_FALSE((mDeferredLocks > 0 && !mImage) ||
51297:                     (mLocksHeld > 0 && mImage),
51297:                     "calling unlock but no locks!");
51297:   NS_ABORT_IF_FALSE(mImage || mLocksHeld == 0,
51297:                     "have locks without an image to have locked");
51297:   NS_ABORT_IF_FALSE(!mImage || mDeferredLocks == 0,
51297:                     "have deferred locks that should have been converted "
51297:                     "into actual locks, since we have an image");
51297: 
51297:   if (!mImage) {
51297:     mDeferredLocks--;
51297:     return NS_OK;
51297:   }
32424: 
32516:   mLocksHeld--;
48319:   return mImage->UnlockImage();
32424: }
32424: 
    1: /* void suspend (); */
    1: NS_IMETHODIMP imgRequestProxy::Suspend()
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* void resume (); */
    1: NS_IMETHODIMP imgRequestProxy::Resume()
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* attribute nsILoadGroup loadGroup */
    1: NS_IMETHODIMP imgRequestProxy::GetLoadGroup(nsILoadGroup **loadGroup)
    1: {
    1:   NS_IF_ADDREF(*loadGroup = mLoadGroup.get());
    1:   return NS_OK;
    1: }
    1: NS_IMETHODIMP imgRequestProxy::SetLoadGroup(nsILoadGroup *loadGroup)
    1: {
    1:   mLoadGroup = loadGroup;
    1:   return NS_OK;
    1: }
    1: 
    1: /* attribute nsLoadFlags loadFlags */
    1: NS_IMETHODIMP imgRequestProxy::GetLoadFlags(nsLoadFlags *flags)
    1: {
    1:   *flags = mLoadFlags;
    1:   return NS_OK;
    1: }
    1: NS_IMETHODIMP imgRequestProxy::SetLoadFlags(nsLoadFlags flags)
    1: {
    1:   mLoadFlags = flags;
    1:   return NS_OK;
    1: }
    1: 
    1: /**  imgIRequest methods **/
    1: 
    1: /* attribute imgIContainer image; */
    1: NS_IMETHODIMP imgRequestProxy::GetImage(imgIContainer * *aImage)
    1: {
51297:   // It's possible that our owner has an image but hasn't notified us of it -
51297:   // that'll happen if we get Canceled before the owner instantiates its image
51297:   // (because Canceling unregisters us as a listener on mOwner). If we're
51297:   // in that situation, just grab the image off of mOwner.
51297:   imgIContainer* imageToReturn = mImage ? mImage : mOwner->mImage;
51297: 
51297:   if (!imageToReturn)
    1:     return NS_ERROR_FAILURE;
    1: 
51297:   NS_ADDREF(*aImage = imageToReturn);
48319: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute unsigned long imageStatus; */
    1: NS_IMETHODIMP imgRequestProxy::GetImageStatus(PRUint32 *aStatus)
    1: {
51297:   *aStatus = GetStatusTracker().GetImageStatus();
    1: 
48319:   return NS_OK;
48319: }
48319: 
    1: /* readonly attribute nsIURI URI; */
    1: NS_IMETHODIMP imgRequestProxy::GetURI(nsIURI **aURI)
    1: {
48319:   if (!mURI)
    1:     return NS_ERROR_FAILURE;
    1: 
48319:   NS_ADDREF(*aURI = mURI);
48319: 
48319:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute imgIDecoderObserver decoderObserver; */
    1: NS_IMETHODIMP imgRequestProxy::GetDecoderObserver(imgIDecoderObserver **aDecoderObserver)
    1: {
    1:   *aDecoderObserver = mListener;
    1:   NS_IF_ADDREF(*aDecoderObserver);
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute string mimeType; */
    1: NS_IMETHODIMP imgRequestProxy::GetMimeType(char **aMimeType)
    1: {
    1:   if (!mOwner)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   const char *type = mOwner->GetMimeType();
    1:   if (!type)
    1:     return NS_ERROR_FAILURE;
    1: 
26655:   *aMimeType = NS_strdup(type);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP imgRequestProxy::Clone(imgIDecoderObserver* aObserver,
    1:                                      imgIRequest** aClone)
    1: {
    1:   NS_PRECONDITION(aClone, "Null out param");
48320: 
48320:   LOG_SCOPE(gImgLog, "imgRequestProxy::Clone");
48320: 
    1:   *aClone = nsnull;
48319:   nsRefPtr<imgRequestProxy> clone = new imgRequestProxy();
    1: 
    1:   // It is important to call |SetLoadFlags()| before calling |Init()| because
    1:   // |Init()| adds the request to the loadgroup.
    1:   // When a request is added to a loadgroup, its load flags are merged
    1:   // with the load flags of the loadgroup.
    1:   // XXXldb That's not true anymore.  Stuff from imgLoader adds the
    1:   // request to the loadgroup.
    1:   clone->SetLoadFlags(mLoadFlags);
51297:   nsresult rv = clone->Init(mOwner, mLoadGroup,
51297:                             mImage ? mImage : mOwner->mImage,
51297:                             mURI, aObserver);
48319:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
48319:   clone->SetPrincipal(mPrincipal);
48319: 
48319:   // Assign to *aClone before calling Notify so that if the caller expects to
48319:   // only be notified for requests it's already holding pointers to it won't be
48319:   // surprised.
48320:   NS_ADDREF(*aClone = clone);
    1: 
48321:   // This is wrong!!! We need to notify asynchronously, but there's code that
48321:   // assumes that we don't. This will be fixed in bug 580466.
48321:   clone->SyncNotifyListener();
    1: 
    1:   return NS_OK;
    1: }
    1: 
 7703: /* readonly attribute nsIPrincipal imagePrincipal; */
 7703: NS_IMETHODIMP imgRequestProxy::GetImagePrincipal(nsIPrincipal **aPrincipal)
 7703: {
48319:   if (!mPrincipal)
 7703:     return NS_ERROR_FAILURE;
 7703: 
48319:   NS_ADDREF(*aPrincipal = mPrincipal);
48319: 
48319:   return NS_OK;
 7703: }
 7703: 
    1: /** nsISupportsPriority methods **/
    1: 
    1: NS_IMETHODIMP imgRequestProxy::GetPriority(PRInt32 *priority)
    1: {
    1:   NS_ENSURE_STATE(mOwner);
    1:   *priority = mOwner->Priority();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP imgRequestProxy::SetPriority(PRInt32 priority)
    1: {
    1:   NS_ENSURE_STATE(mOwner && !mCanceled);
    1:   mOwner->AdjustPriority(this, priority - mOwner->Priority());
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP imgRequestProxy::AdjustPriority(PRInt32 priority)
    1: {
    1:   NS_ENSURE_STATE(mOwner && !mCanceled);
    1:   mOwner->AdjustPriority(this, priority);
    1:   return NS_OK;
    1: }
    1: 
18557: /** nsISecurityInfoProvider methods **/
18557: 
18557: NS_IMETHODIMP imgRequestProxy::GetSecurityInfo(nsISupports** _retval)
18557: {
18557:   if (mOwner)
18557:     return mOwner->GetSecurityInfo(_retval);
18557: 
18557:   *_retval = nsnull;
18557:   return NS_OK;
18557: }
18557: 
25037: NS_IMETHODIMP imgRequestProxy::GetHasTransferredData(PRBool* hasData)
25037: {
25037:   if (mOwner) {
25037:     *hasData = mOwner->HasTransferredData();
25037:   } else {
25037:     // The safe thing to do is to claim we have data
25037:     *hasData = PR_TRUE;
25037:   }
25037:   return NS_OK;
25037: }
25037: 
    1: /** imgIContainerObserver methods **/
    1: 
50544: void imgRequestProxy::FrameChanged(imgIContainer *container,
50544:                                    const nsIntRect *dirtyRect)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::FrameChanged");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
30479:     mListener->FrameChanged(container, dirtyRect);
    1:   }
    1: }
    1: 
    1: /** imgIDecoderObserver methods **/
    1: 
    1: void imgRequestProxy::OnStartDecode()
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStartDecode");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStartDecode(this);
    1:   }
    1: }
    1: 
    1: void imgRequestProxy::OnStartContainer(imgIContainer *image)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStartContainer");
    1: 
49700:   if (mListener && !mCanceled && !mSentStartContainer) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStartContainer(this, image);
49700:     mSentStartContainer = PR_TRUE;
    1:   }
    1: }
    1: 
30479: void imgRequestProxy::OnStartFrame(PRUint32 frame)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStartFrame");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStartFrame(this, frame);
    1:   }
    1: }
    1: 
30479: void imgRequestProxy::OnDataAvailable(PRBool aCurrentFrame, const nsIntRect * rect)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnDataAvailable");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
30479:     mListener->OnDataAvailable(this, aCurrentFrame, rect);
    1:   }
    1: }
    1: 
30479: void imgRequestProxy::OnStopFrame(PRUint32 frame)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStopFrame");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStopFrame(this, frame);
    1:   }
    1: }
    1: 
    1: void imgRequestProxy::OnStopContainer(imgIContainer *image)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStopContainer");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStopContainer(this, image);
    1:   }
    1: }
    1: 
    1: void imgRequestProxy::OnStopDecode(nsresult status, const PRUnichar *statusArg)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStopDecode");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStopDecode(this, status, statusArg);
    1:   }
    1: }
    1: 
32424: void imgRequestProxy::OnDiscard()
32424: {
32424:   LOG_FUNC(gImgLog, "imgRequestProxy::OnDiscard");
32424: 
32424:   if (mListener && !mCanceled) {
32424:     // Hold a ref to the listener while we call it, just in case.
32424:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
32424:     mListener->OnDiscard(this);
32424:   }
32424: }
32424: 
48317: void imgRequestProxy::OnStartRequest()
    1: {
    1: #ifdef PR_LOGGING
    1:   nsCAutoString name;
    1:   GetName(name);
    1:   LOG_FUNC_WITH_PARAM(gImgLog, "imgRequestProxy::OnStartRequest", "name", name.get());
    1: #endif
    1: 
22953:   // Notify even if mCanceled, since OnStartRequest is guaranteed by the
22953:   // nsIStreamListener contract so it makes sense to do the same here.
    1:   if (mListener) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStartRequest(this);
    1:   }
    1: }
    1: 
48317: void imgRequestProxy::OnStopRequest(PRBool lastPart)
    1: {
    1: #ifdef PR_LOGGING
    1:   nsCAutoString name;
    1:   GetName(name);
    1:   LOG_FUNC_WITH_PARAM(gImgLog, "imgRequestProxy::OnStopRequest", "name", name.get());
    1: #endif
13419:   // There's all sorts of stuff here that could kill us (the OnStopRequest call
13419:   // on the listener, the removal from the loadgroup, the release of the
13419:   // listener, etc).  Don't let them do it.
13419:   nsCOMPtr<imgIRequest> kungFuDeathGrip(this);
    1: 
    1:   if (mListener) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStopRequest(this, lastPart);
    1:   }
    1: 
    1:   // If we're expecting more data from a multipart channel, re-add ourself
    1:   // to the loadgroup so that the document doesn't lose track of the load.
    1:   // If the request is already a background request and there's more data
    1:   // coming, we can just leave the request in the loadgroup as-is.
    1:   if (lastPart || (mLoadFlags & nsIRequest::LOAD_BACKGROUND) == 0) {
    1:     RemoveFromLoadGroup(lastPart);
    1:     // More data is coming, so change the request to be a background request
    1:     // and put it back in the loadgroup.
    1:     if (!lastPart) {
    1:       mLoadFlags |= nsIRequest::LOAD_BACKGROUND;
    1:       AddToLoadGroup();
    1:     }
    1:   }
13293: 
13293:   if (mListenerIsStrongRef) {
13293:     NS_PRECONDITION(mListener, "How did that happen?");
13293:     // Drop our strong ref to the listener now that we're done with
13293:     // everything.  Note that this can cancel us and other fun things
13293:     // like that.  Don't add anything in this method after this point.
13293:     imgIDecoderObserver* obs = mListener;
13293:     mListenerIsStrongRef = PR_FALSE;
13293:     NS_RELEASE(obs);
13293:   }
    1: }
    1: 
13293: void imgRequestProxy::NullOutListener()
13293: {
13293:   if (mListenerIsStrongRef) {
13293:     // Releasing could do weird reentery stuff, so just play it super-safe
13293:     nsCOMPtr<imgIDecoderObserver> obs;
13293:     obs.swap(mListener);
13293:     mListenerIsStrongRef = PR_FALSE;
13293:   } else {
13293:     mListener = nsnull;
13293:   }
13293: }
35581: 
35581: NS_IMETHODIMP
35581: imgRequestProxy::GetStaticRequest(imgIRequest** aReturn)
35581: {
35581:   *aReturn = nsnull;
48319: 
48319:   PRBool animated;
51529:   if (!mImage || (NS_SUCCEEDED(mImage->GetAnimated(&animated)) && !animated)) {
48319:     // Early exit - we're not animated, so we don't have to do anything.
35581:     NS_ADDREF(*aReturn = this);
35581:     return NS_OK;
48320:   }
48320: 
48319:   // We are animated. We need to extract the current frame from this image.
35581:   PRInt32 w = 0;
35581:   PRInt32 h = 0;
48320:   mImage->GetWidth(&w);
48320:   mImage->GetHeight(&h);
35581:   nsIntRect rect(0, 0, w, h);
48320:   nsCOMPtr<imgIContainer> currentFrame;
48320:   nsresult rv = mImage->ExtractFrame(imgIContainer::FRAME_CURRENT, rect,
35581:                                      imgIContainer::FLAG_SYNC_DECODE,
35581:                                      getter_AddRefs(currentFrame));
48320:   if (NS_FAILED(rv))
48320:     return rv;
35581: 
50546:   nsRefPtr<Image> frame = static_cast<Image*>(currentFrame.get());
35581: 
48320:   // Create a static imgRequestProxy with our new extracted frame.
48320:   nsRefPtr<imgRequestProxy> req = new imgRequestProxy();
48320:   req->Init(nsnull, nsnull, frame, mURI, nsnull);
48319:   req->SetPrincipal(mPrincipal);
48319: 
35581:   NS_ADDREF(*aReturn = req);
48319: 
35581:   return NS_OK;
35581: }
35581: 
48319: void imgRequestProxy::SetPrincipal(nsIPrincipal *aPrincipal)
48319: {
48319:   mPrincipal = aPrincipal;
48319: }
48319: 
48320: void imgRequestProxy::NotifyListener()
48319: {
48321:   // It would be nice to notify the observer directly in the status tracker
48321:   // instead of through the proxy, but there are several places we do extra
48321:   // processing when we receive notifications (like OnStopRequest()), and we
48321:   // need to check mCanceled everywhere too.
48320: 
48321:   if (mOwner) {
48321:     // Send the notifications to our listener asynchronously.
51297:     GetStatusTracker().Notify(mOwner, this);
48321:   } else {
48321:     // We don't have an imgRequest, so we can only notify the clone of our
48321:     // current state, but we still have to do that asynchronously.
51297:     NS_ABORT_IF_FALSE(mImage,
51297:                       "if we have no imgRequest, we should have an Image");
48321:     mImage->GetStatusTracker().NotifyCurrentState(this);
48319:   }
48321: }
48321: 
48321: void imgRequestProxy::SyncNotifyListener()
48321: {
48321:   // It would be nice to notify the observer directly in the status tracker
48321:   // instead of through the proxy, but there are several places we do extra
48321:   // processing when we receive notifications (like OnStopRequest()), and we
48321:   // need to check mCanceled everywhere too.
48321: 
51297:   GetStatusTracker().SyncNotify(this);
48321: }
51297: 
51297: void
51297: imgRequestProxy::SetImage(Image* aImage)
51297: {
51529:   NS_ABORT_IF_FALSE(aImage,  "Setting null image");
51297:   NS_ABORT_IF_FALSE(!mImage, "Setting image when we already have one");
51297: 
51297:   mImage = aImage;
51297: 
51297:   // Convert deferred locks into real locks.
51297:   NS_ABORT_IF_FALSE(!mLocksHeld, "Can't be holding locks without any image");
51297:   for (PRUint32 i = 0; i < mDeferredLocks; i++) {
51297:     mImage->LockImage();
51297:   }
51297:   mLocksHeld = mDeferredLocks;
51297:   mDeferredLocks = 0;
51297: }
51297: 
51297: imgStatusTracker&
51297: imgRequestProxy::GetStatusTracker()
51297: {
51297:   // NOTE: It's possible that our mOwner has an Image that it didn't notify
51297:   // us about, if we were Canceled before its Image was constructed.
51297:   // (Canceling removes us as an observer, so mOwner has no way to notify us).
51297:   // That's why this method uses mOwner->GetStatusTracker() instead of just
51297:   // mOwner->mStatusTracker -- we might have a null mImage and yet have an
51297:   // mOwner with a non-null mImage (and a null mStatusTracker pointer).
51297:   return mImage ? mImage->GetStatusTracker() : mOwner->GetStatusTracker();
51297: }
