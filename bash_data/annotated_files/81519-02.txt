    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* struct containing the input to nsIFrame::Reflow */
    1: 
    1: #ifndef nsHTMLReflowState_h___
    1: #define nsHTMLReflowState_h___
    1: 
    1: #include "nsMargin.h"
    1: #include "nsStyleCoord.h"
    1: #include "nsIFrame.h"
    1: 
    1: class nsPresContext;
68481: class nsRenderingContext;
23305: class nsFloatManager;
    1: class nsLineLayout;
    1: class nsIPercentHeightObserver;
    1: 
    1: struct nsStyleDisplay;
    1: struct nsStyleVisibility;
    1: struct nsStylePosition;
    1: struct nsStyleBorder;
    1: struct nsStyleMargin;
    1: struct nsStylePadding;
    1: struct nsStyleText;
    1: struct nsHypotheticalBox;
    1: 
10602: template <class NumericType>
10602: NumericType
10602: NS_CSS_MINMAX(NumericType aValue, NumericType aMinValue, NumericType aMaxValue)
10602: {
10602:   NumericType result = aValue;
10602:   if (aMaxValue < result)
10602:     result = aMaxValue;
10602:   if (aMinValue > result)
10602:     result = aMinValue;
10602:   return result;
10602: }
    1: 
    1: /**
    1:  * Constant used to indicate an unconstrained size.
    1:  *
    1:  * @see #Reflow()
    1:  */
    1: #define NS_UNCONSTRAINEDSIZE NS_MAXSIZE
    1: 
    1: /**
    1:  * CSS Frame type. Included as part of the reflow state.
    1:  */
    1: typedef PRUint32  nsCSSFrameType;
    1: 
    1: #define NS_CSS_FRAME_TYPE_UNKNOWN         0
    1: #define NS_CSS_FRAME_TYPE_INLINE          1
    1: #define NS_CSS_FRAME_TYPE_BLOCK           2  /* block-level in normal flow */
    1: #define NS_CSS_FRAME_TYPE_FLOATING        3
    1: #define NS_CSS_FRAME_TYPE_ABSOLUTE        4
    1: #define NS_CSS_FRAME_TYPE_INTERNAL_TABLE  5  /* row group frame, row frame, cell frame, ... */
    1: 
    1: /**
    1:  * Bit-flag that indicates whether the element is replaced. Applies to inline,
    1:  * block-level, floating, and absolutely positioned elements
    1:  */
    1: #define NS_CSS_FRAME_TYPE_REPLACED                0x08000
    1: 
    1: /**
    1:  * Bit-flag that indicates that the element is replaced and contains a block
    1:  * (eg some form controls).  Applies to inline, block-level, floating, and
    1:  * absolutely positioned elements.  Mutually exclusive with
    1:  * NS_CSS_FRAME_TYPE_REPLACED.
    1:  */
    1: #define NS_CSS_FRAME_TYPE_REPLACED_CONTAINS_BLOCK 0x10000
    1: 
    1: /**
    1:  * Helper macros for telling whether items are replaced
    1:  */
    1: #define NS_FRAME_IS_REPLACED_NOBLOCK(_ft) \
    1:   (NS_CSS_FRAME_TYPE_REPLACED == ((_ft) & NS_CSS_FRAME_TYPE_REPLACED))
    1: 
    1: #define NS_FRAME_IS_REPLACED(_ft)            \
    1:   (NS_FRAME_IS_REPLACED_NOBLOCK(_ft) ||      \
    1:    NS_FRAME_IS_REPLACED_CONTAINS_BLOCK(_ft))
    1: 
    1: #define NS_FRAME_REPLACED(_ft) \
    1:   (NS_CSS_FRAME_TYPE_REPLACED | (_ft))
    1: 
    1: #define NS_FRAME_IS_REPLACED_CONTAINS_BLOCK(_ft)         \
    1:   (NS_CSS_FRAME_TYPE_REPLACED_CONTAINS_BLOCK ==         \
    1:    ((_ft) & NS_CSS_FRAME_TYPE_REPLACED_CONTAINS_BLOCK))
    1: 
    1: #define NS_FRAME_REPLACED_CONTAINS_BLOCK(_ft) \
    1:   (NS_CSS_FRAME_TYPE_REPLACED_CONTAINS_BLOCK | (_ft))
    1: 
    1: /**
    1:  * A macro to extract the type. Masks off the 'replaced' bit-flag
    1:  */
    1: #define NS_FRAME_GET_TYPE(_ft)                           \
    1:   ((_ft) & ~(NS_CSS_FRAME_TYPE_REPLACED |                \
    1:              NS_CSS_FRAME_TYPE_REPLACED_CONTAINS_BLOCK))
    1: 
    1: #define NS_INTRINSICSIZE    NS_UNCONSTRAINEDSIZE
    1: #define NS_AUTOHEIGHT       NS_UNCONSTRAINEDSIZE
    1: #define NS_AUTOMARGIN       NS_UNCONSTRAINEDSIZE
    1: #define NS_AUTOOFFSET       NS_UNCONSTRAINEDSIZE
    1: // NOTE: there are assumptions all over that these have the same value, namely NS_UNCONSTRAINEDSIZE
    1: //       if any are changed to be a value other than NS_UNCONSTRAINEDSIZE
    1: //       at least update AdjustComputedHeight/Width and test ad nauseum
    1: 
    1: // A base class of nsHTMLReflowState that computes only the padding,
    1: // border, and margin, since those values are needed more often.
    1: struct nsCSSOffsetState {
    1: public:
    1:   // the frame being reflowed
    1:   nsIFrame*           frame;
    1: 
    1:   // rendering context to use for measurement
68481:   nsRenderingContext* rendContext;
    1: 
    1:   // Computed margin values
    1:   nsMargin         mComputedMargin;
    1: 
    1:   // Cached copy of the border + padding values
    1:   nsMargin         mComputedBorderPadding;
    1: 
    1:   // Computed padding values
    1:   nsMargin         mComputedPadding;
    1: 
    1:   // Callers using this constructor must call InitOffsets on their own.
68481:   nsCSSOffsetState(nsIFrame *aFrame, nsRenderingContext *aRenderingContext)
    1:     : frame(aFrame)
    1:     , rendContext(aRenderingContext)
    1:   {
    1:   }
    1: 
68481:   nsCSSOffsetState(nsIFrame *aFrame, nsRenderingContext *aRenderingContext,
    1:                    nscoord aContainingBlockWidth)
    1:     : frame(aFrame)
    1:     , rendContext(aRenderingContext)
    1:   {
79491:     InitOffsets(aContainingBlockWidth, frame->GetType());
    1:   }
    1: 
41687: #ifdef DEBUG
41687:   // Reflow trace methods.  Defined in nsFrame.cpp so they have access
41687:   // to the display-reflow infrastructure.
41687:   static void* DisplayInitOffsetsEnter(nsIFrame* aFrame,
41687:                                        nsCSSOffsetState* aState,
41687:                                        nscoord aCBWidth,
41687:                                        const nsMargin* aBorder,
41687:                                        const nsMargin* aPadding);
41687:   static void DisplayInitOffsetsExit(nsIFrame* aFrame,
41687:                                      nsCSSOffsetState* aState,
41687:                                      void* aValue);
41687: #endif
41687: 
    1: private:
57167:   /**
57167:    * Computes margin values from the specified margin style information, and
57167:    * fills in the mComputedMargin member.
57167:    * @return PR_TRUE if the margin is dependent on the containing block width
57167:    */
79445:   bool ComputeMargin(nscoord aContainingBlockWidth);
    1:   
57167:   /**
57167:    * Computes padding values from the specified padding style information, and
57167:    * fills in the mComputedPadding member.
57167:    * @return PR_TRUE if the padding is dependent on the containing block width
57167:    */
79491:    bool ComputePadding(nscoord aContainingBlockWidth, nsIAtom* aFrameType);
    1: 
    1: protected:
 1068: 
 4831:   void InitOffsets(nscoord aContainingBlockWidth,
79491:                    nsIAtom* aFrameType,
 4831:                    const nsMargin *aBorder = nsnull,
 4831:                    const nsMargin *aPadding = nsnull);
 4831: 
 1068:   /*
 1068:    * Convert nsStyleCoord to nscoord when percentages depend on the
 1068:    * containing block width, and enumerated values are for width,
 1068:    * min-width, or max-width.  Does not handle auto widths.
 1068:    */
 1068:   inline nscoord ComputeWidthValue(nscoord aContainingBlockWidth,
 1068:                                    nscoord aContentEdgeToBoxSizing,
 1068:                                    nscoord aBoxSizingToMarginEdge,
 1068:                                    const nsStyleCoord& aCoord);
 1068:   // same as previous, but using mComputedBorderPadding, mComputedPadding,
 1068:   // and mComputedMargin
 1068:   nscoord ComputeWidthValue(nscoord aContainingBlockWidth,
 1068:                             PRUint8 aBoxSizing,
 1068:                             const nsStyleCoord& aCoord);
    1: };
    1: 
    1: /**
    1:  * State passed to a frame during reflow or intrinsic size calculation.
    1:  *
    1:  * XXX Refactor so only a base class (nsSizingState?) is used for intrinsic
    1:  * size calculation.
    1:  *
    1:  * @see nsIFrame#Reflow()
    1:  */
    1: struct nsHTMLReflowState : public nsCSSOffsetState {
    1:   // the reflow states are linked together. this is the pointer to the
    1:   // parent's reflow state
    1:   const nsHTMLReflowState* parentReflowState;
    1: 
28329:   // pointer to the float manager associated with this area
28329:   nsFloatManager* mFloatManager;
28329: 
28329:   // LineLayout object (only for inline reflow; set to NULL otherwise)
28329:   nsLineLayout*    mLineLayout;
28329: 
28329:   // The appropriate reflow state for the containing block (for
28329:   // percentage widths, etc.) of this reflow state's frame.
28329:   const nsHTMLReflowState *mCBReflowState;
28329: 
    1:   // the available width in which to reflow the frame. The space
69074:   // represents the amount of room for the frame's margin, border,
69074:   // padding, and content area. The frame size you choose should fit
69074:   // within the available width.
    1:   nscoord              availableWidth;
    1: 
    1:   // A value of NS_UNCONSTRAINEDSIZE for the available height means
    1:   // you can choose whatever size you want. In galley mode the
    1:   // available height is always NS_UNCONSTRAINEDSIZE, and only page
    1:   // mode or multi-column layout involves a constrained height. The
    1:   // element's the top border and padding, and content, must fit. If the
    1:   // element is complete after reflow then its bottom border, padding
    1:   // and margin (and similar for its complete ancestors) will need to
    1:   // fit in this height.
    1:   nscoord              availableHeight;
    1: 
    1:   // The type of frame, from css's perspective. This value is
    1:   // initialized by the Init method below.
    1:   nsCSSFrameType   mFrameType;
    1: 
 4831:   // The amount the in-flow position of the block is moving vertically relative
 4831:   // to its previous in-flow position (i.e. the amount the line containing the
 4831:   // block is moving).
 4831:   // This should be zero for anything which is not a block outside, and it
 4831:   // should be zero for anything which has a non-block parent.
 4831:   // The intended use of this value is to allow the accurate determination
 4831:   // of the potential impact of a float
 4831:   // This takes on an arbitrary value the first time a block is reflowed
 4831:   nscoord mBlockDelta;
 4831: 
    1: private:
    1:   // The computed width specifies the frame's content area width, and it does
    1:   // not apply to inline non-replaced elements
    1:   //
    1:   // For replaced inline frames, a value of NS_INTRINSICSIZE means you should
    1:   // use your intrinsic width as the computed width
    1:   //
    1:   // For block-level frames, the computed width is based on the width of the
    1:   // containing block, the margin/border/padding areas, and the min/max width.
    1:   nscoord          mComputedWidth; 
    1: 
    1:   // The computed height specifies the frame's content height, and it does
    1:   // not apply to inline non-replaced elements
    1:   //
    1:   // For replaced inline frames, a value of NS_INTRINSICSIZE means you should
    1:   // use your intrinsic height as the computed height
    1:   //
    1:   // For non-replaced block-level frames in the flow and floated, a value of
    1:   // NS_AUTOHEIGHT means you choose a height to shrink wrap around the normal
    1:   // flow child frames. The height must be within the limit of the min/max
    1:   // height if there is such a limit
    1:   //
    1:   // For replaced block-level frames, a value of NS_INTRINSICSIZE
    1:   // means you use your intrinsic height as the computed height
    1:   nscoord          mComputedHeight;
    1: 
 4166: public:
    1:   // Computed values for 'left/top/right/bottom' offsets. Only applies to
    1:   // 'positioned' elements
    1:   nsMargin         mComputedOffsets;
    1: 
    1:   // Computed values for 'min-width/max-width' and 'min-height/max-height'
    1:   // XXXldb The width ones here should go; they should be needed only
    1:   // internally.
    1:   nscoord          mComputedMinWidth, mComputedMaxWidth;
    1:   nscoord          mComputedMinHeight, mComputedMaxHeight;
    1: 
    1:   // Cached pointers to the various style structs used during intialization
    1:   const nsStyleDisplay*    mStyleDisplay;
    1:   const nsStyleVisibility* mStyleVisibility;
    1:   const nsStylePosition*   mStylePosition;
    1:   const nsStyleBorder*     mStyleBorder;
    1:   const nsStyleMargin*     mStyleMargin;
    1:   const nsStylePadding*    mStylePadding;
    1:   const nsStyleText*       mStyleText;
    1: 
    1:   // a frame (e.g. nsTableCellFrame) which may need to generate a special 
    1:   // reflow for percent height calculations 
    1:   nsIPercentHeightObserver* mPercentHeightObserver;
    1: 
    1:   // CSS margin collapsing sometimes requires us to reflow
    1:   // optimistically assuming that margins collapse to see if clearance
    1:   // is required. When we discover that clearance is required, we
    1:   // store the frame in which clearance was discovered to the location
    1:   // requested here.
    1:   nsIFrame** mDiscoveredClearance;
    1: 
    1:   // This value keeps track of how deeply nested a given reflow state
    1:   // is from the top of the frame tree.
    1:   PRInt16 mReflowDepth;
    1: 
    1:   struct ReflowStateFlags {
    1:     PRUint16 mSpecialHeightReflow:1; // used by tables to communicate special reflow (in process) to handle
    1:                                      // percent height frames inside cells which may not have computed heights
    1:     PRUint16 mNextInFlowUntouched:1; // nothing in the frame's next-in-flow (or its descendants)
    1:                                      // is changing
49005:     PRUint16 mIsTopOfPage:1;         // Is the current context at the top of a
49005:                                      // page?  When true, we force something
49005:                                      // that's too tall for a page/column to
49005:                                      // fit anyway to avoid infinite loops.
    1:     PRUint16 mBlinks:1;              // Keep track of text-decoration: blink
    1:     PRUint16 mHasClearance:1;        // Block has clearance
    1:     PRUint16 mAssumingHScrollbar:1;  // parent frame is an nsIScrollableFrame and it
    1:                                      // is assuming a horizontal scrollbar
    1:     PRUint16 mAssumingVScrollbar:1;  // parent frame is an nsIScrollableFrame and it
    1:                                      // is assuming a vertical scrollbar
    1: 
    1:     PRUint16 mHResize:1;             // Is frame (a) not dirty and (b) a
    1:                                      // different width than before?
    1: 
    1:     PRUint16 mVResize:1;             // Is frame (a) not dirty and (b) a
    1:                                      // different height than before or
    1:                                      // (potentially) in a context where
    1:                                      // percent heights have a different
    1:                                      // basis?
    1:     PRUint16 mTableIsSplittable:1;   // tables are splittable, this should happen only inside a page
    1:                                      // and never insider a column frame
12040:     PRUint16 mHeightDependsOnAncestorCell:1;   // Does frame height depend on
12040:                                                // an ancestor table-cell?
12040:     
    1:   } mFlags;
    1: 
    1:   // Note: The copy constructor is written by the compiler automatically. You
    1:   // can use that and then override specific values if you want, or you can
    1:   // call Init as desired...
    1: 
    1:   // Initialize a <b>root</b> reflow state with a rendering context to
    1:   // use for measuring things.
    1:   nsHTMLReflowState(nsPresContext*           aPresContext,
    1:                     nsIFrame*                aFrame,
68481:                     nsRenderingContext*     aRenderingContext,
    1:                     const nsSize&            aAvailableSpace);
    1: 
    1:   // Initialize a reflow state for a child frames reflow. Some state
    1:   // is copied from the parent reflow state; the remaining state is
    1:   // computed. 
    1:   nsHTMLReflowState(nsPresContext*           aPresContext,
    1:                     const nsHTMLReflowState& aParentReflowState,
    1:                     nsIFrame*                aFrame,
    1:                     const nsSize&            aAvailableSpace,
    1:                     // These two are used by absolute positioning code
    1:                     // to override default containing block w & h:
    1:                     nscoord                  aContainingBlockWidth = -1,
    1:                     nscoord                  aContainingBlockHeight = -1,
79445:                     bool                     aInit = true);
    1: 
    1:   // This method initializes various data members. It is automatically
    1:   // called by the various constructors
    1:   void Init(nsPresContext* aPresContext,
    1:             nscoord         aContainingBlockWidth = -1,
    1:             nscoord         aContainingBlockHeight = -1,
    1:             const nsMargin* aBorder = nsnull,
    1:             const nsMargin* aPadding = nsnull);
    1:   /**
    1:    * Find the content width of the containing block of aReflowState
    1:    */
    1:   static nscoord
    1:     GetContainingBlockContentWidth(const nsHTMLReflowState* aReflowState);
    1: 
    1:   /**
28519:    * Calculate the used line-height property. The return value will be >= 0.
    1:    */
28519:   nscoord CalcLineHeight() const;
 5256: 
 1102:   /**
28519:    * Same as CalcLineHeight() above, but doesn't need a reflow state.
28519:    *
28519:    * @param aBlockHeight The computed height of the content rect of the block
28519:    *                     that the line should fill.
28519:    *                     Only used with line-height:-moz-block-height.
28519:    *                     NS_AUTOHEIGHT results in a normal line-height for
28519:    *                     line-height:-moz-block-height.
 1102:    */
28519:   static nscoord CalcLineHeight(nsStyleContext* aStyleContext,
28519:                                 nscoord aBlockHeight);
    1: 
    1: 
    1:   void ComputeContainingBlockRectangle(nsPresContext*          aPresContext,
    1:                                        const nsHTMLReflowState* aContainingBlockRS,
    1:                                        nscoord&                 aContainingBlockWidth,
    1:                                        nscoord&                 aContainingBlockHeight);
    1: 
    1:   /**
    1:    * Apply the mComputed(Min/Max)(Width/Height) values to the content
    1:    * size computed so far. If a passed-in pointer is null, we skip
    1:    * adjusting that dimension.
    1:    */
    1:   void ApplyMinMaxConstraints(nscoord* aContentWidth, nscoord* aContentHeight) const;
    1: 
79445:   bool ShouldReflowAllKids() const {
    1:     // Note that we could make a stronger optimization for mVResize if
    1:     // we use it in a ShouldReflowChild test that replaces the current
    1:     // checks of NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN, if it
    1:     // were tested there along with NS_FRAME_CONTAINS_RELATIVE_HEIGHT.
    1:     // This would need to be combined with a slight change in which
    1:     // frames NS_FRAME_CONTAINS_RELATIVE_HEIGHT is marked on.
    1:     return (frame->GetStateBits() & NS_FRAME_IS_DIRTY) ||
    1:            mFlags.mHResize ||
    1:            (mFlags.mVResize && 
    1:             (frame->GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT));
    1:   }
    1: 
    1:   nscoord ComputedWidth() const { return mComputedWidth; }
 4166:   // This method doesn't apply min/max computed widths to the value passed in.
    1:   void SetComputedWidth(nscoord aComputedWidth);
    1: 
 4166:   nscoord ComputedHeight() const { return mComputedHeight; }
 4166:   // This method doesn't apply min/max computed heights to the value passed in.
 4166:   void SetComputedHeight(nscoord aComputedHeight);
 4166: 
24416:   void SetComputedHeightWithoutResettingResizeFlags(nscoord aComputedHeight) {
24416:     // Viewport frames reset the computed height on a copy of their reflow
24416:     // state when reflowing fixed-pos kids.  In that case we actually don't
24416:     // want to mess with the resize flags, because comparing the frame's rect
24416:     // to the munged computed width is pointless.
24416:     mComputedHeight = aComputedHeight;
24416:   }
24416: 
    1:   void SetTruncated(const nsHTMLReflowMetrics& aMetrics, nsReflowStatus* aStatus) const;
    1: 
79445:   bool WillReflowAgainForClearance() const {
 8730:     return mDiscoveredClearance && *mDiscoveredClearance;
 8730:   }
 8730: 
41687: #ifdef DEBUG
41687:   // Reflow trace methods.  Defined in nsFrame.cpp so they have access
41687:   // to the display-reflow infrastructure.
41687:   static void* DisplayInitConstraintsEnter(nsIFrame* aFrame,
41687:                                            nsHTMLReflowState* aState,
41687:                                            nscoord aCBWidth,
41687:                                            nscoord aCBHeight,
41687:                                            const nsMargin* aBorder,
41687:                                            const nsMargin* aPadding);
41687:   static void DisplayInitConstraintsExit(nsIFrame* aFrame,
41687:                                          nsHTMLReflowState* aState,
41687:                                          void* aValue);
41687:   static void* DisplayInitFrameTypeEnter(nsIFrame* aFrame,
41687:                                          nsHTMLReflowState* aState);
41687:   static void DisplayInitFrameTypeExit(nsIFrame* aFrame,
41687:                                        nsHTMLReflowState* aState,
41687:                                        void* aValue);
41687: #endif
41687: 
    1: protected:
79491:   void InitFrameType(nsIAtom* aFrameType);
    1:   void InitCBReflowState();
79491:   void InitResizeFlags(nsPresContext* aPresContext, nsIAtom* aFrameType);
    1: 
    1:   void InitConstraints(nsPresContext* aPresContext,
    1:                        nscoord         aContainingBlockWidth,
    1:                        nscoord         aContainingBlockHeight,
    1:                        const nsMargin* aBorder,
79491:                        const nsMargin* aPadding,
79491:                        nsIAtom*        aFrameType);
    1: 
21929:   // Returns the nearest containing block or block frame (whether or not
21929:   // it is a containing block) for the specified frame.  Also returns
21929:   // the left edge and width of the containing block's content area.
    1:   // These are returned in the coordinate space of the containing block.
21929:   nsIFrame* GetHypotheticalBoxContainer(nsIFrame* aFrame,
21929:                                         nscoord& aCBLeftEdge,
    1:                                         nscoord& aCBWidth);
    1: 
    1:   void CalculateHypotheticalBox(nsPresContext*    aPresContext,
81519:                                 nsIFrame*         aPlaceholderFrame,
    1:                                 nsIFrame*         aContainingBlock,
    1:                                 nscoord           aBlockLeftContentEdge,
    1:                                 nscoord           aBlockContentWidth,
    1:                                 const nsHTMLReflowState* cbrs,
79491:                                 nsHypotheticalBox& aHypotheticalBox,
79491:                                 nsIAtom*          aFrameType);
    1: 
    1:   void InitAbsoluteConstraints(nsPresContext* aPresContext,
    1:                                const nsHTMLReflowState* cbrs,
    1:                                nscoord aContainingBlockWidth,
79491:                                nscoord aContainingBlockHeight,
79491:                                nsIAtom* aFrameType);
    1: 
    1:   void ComputeRelativeOffsets(const nsHTMLReflowState* cbrs,
    1:                               nscoord aContainingBlockWidth,
14460:                               nscoord aContainingBlockHeight,
14460:                               nsPresContext* aPresContext);
    1: 
    1:   // Calculates the computed values for the 'min-Width', 'max-Width',
    1:   // 'min-Height', and 'max-Height' properties, and stores them in the assorted
    1:   // data members
    1:   void ComputeMinMaxValues(nscoord                  aContainingBlockWidth,
    1:                            nscoord                  aContainingBlockHeight,
    1:                            const nsHTMLReflowState* aContainingBlockRS);
    1: 
 1068:   void CalculateHorizBorderPaddingMargin(nscoord aContainingBlockWidth,
 1068:                                          nscoord* aInsideBoxSizing,
 1068:                                          nscoord* aOutsideBoxSizing);
    1: 
 4831:   void CalculateBlockSideMargins(nscoord aAvailWidth,
79491:                                  nscoord aComputedWidth,
79491:                                  nsIAtom* aFrameType);
    1: };
    1: 
    1: #endif /* nsHTMLReflowState_h___ */
    1: 
