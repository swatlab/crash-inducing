    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
30479:  * The Initial Developer of the Original Code is Mozilla Corporation.
30479:  * Portions created by the Initial Developer are Copyright (C) 2009
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
30479:  *   Joe Drew <joe@drew.ca> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
30479:  * either the GNU General Public License Version 2 or later (the "GPL"), or
30479:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
30479: #ifndef imgFrame_h
30479: #define imgFrame_h
    1: 
30479: #include "nsRect.h"
    1: #include "nsPoint.h"
    1: #include "nsSize.h"
30479: #include "gfxTypes.h"
30479: #include "nsID.h"
30479: #include "gfxIFormats.h"
30479: #include "gfxContext.h"
30479: #include "gfxPattern.h"
30479: #include "gfxImageSurface.h"
30479: #if defined(XP_WIN)
30479: #include "gfxWindowsSurface.h"
30479: #elif defined(XP_MACOSX)
30479: #include "gfxQuartzImageSurface.h"
30479: #endif
30479: #include "nsAutoPtr.h"
    1: 
30479: class imgFrame
30479: {
30479: public:
30479:   imgFrame();
30479:   ~imgFrame();
    1: 
30479:   nsresult Init(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, gfxASurface::gfxImageFormat aFormat, PRInt8 aPaletteDepth = 0);
30479:   nsresult Optimize();
30479: 
30479:   void Draw(gfxContext *aContext, gfxPattern::GraphicsFilter aFilter,
30479:             const gfxMatrix &aUserSpaceToImageSpace, const gfxRect& aFill,
30479:             const nsIntMargin &aPadding, const nsIntRect &aSubimage);
30479: 
30479:   nsresult Extract(const nsIntRect& aRegion, imgFrame** aResult);
30479: 
30479:   nsresult ImageUpdated(const nsIntRect &aUpdateRect);
30479: 
30479:   PRInt32 GetX() const;
30479:   PRInt32 GetY() const;
30479:   PRInt32 GetWidth() const;
30479:   PRInt32 GetHeight() const;
30479:   nsIntRect GetRect() const;
30479:   gfxASurface::gfxImageFormat GetFormat() const;
30479:   PRBool GetNeedsBackground() const;
30479:   PRUint32 GetImageBytesPerRow() const;
30479:   PRUint32 GetImageDataLength() const;
30479:   PRBool GetIsPaletted() const;
30479:   PRBool GetHasAlpha() const;
30479:   void GetImageData(PRUint8 **aData, PRUint32 *length) const;
30479:   void GetPaletteData(PRUint32 **aPalette, PRUint32 *length) const;
30479: 
30479:   PRInt32 GetTimeout() const;
30479:   void SetTimeout(PRInt32 aTimeout);
30479: 
30479:   PRInt32 GetFrameDisposalMethod() const;
30479:   void SetFrameDisposalMethod(PRInt32 aFrameDisposalMethod);
30479:   PRInt32 GetBlendMethod() const;
30479:   void SetBlendMethod(PRInt32 aBlendMethod);
30479:   PRBool ImageComplete() const;
30479: 
30479:   void SetHasNoAlpha();
30479: 
34809:   PRBool GetCompositingFailed() const;
34809:   void SetCompositingFailed(PRBool val);
34809: 
30479:   nsresult LockImageData();
30479:   nsresult UnlockImageData();
30479: 
30479:   nsresult GetSurface(gfxASurface **aSurface) const
30479:   {
30479:     *aSurface = ThebesSurface();
30479:     NS_IF_ADDREF(*aSurface);
30479:     return NS_OK;
    1:   }
    1: 
30479:   nsresult GetPattern(gfxPattern **aPattern) const
    1:   {
30479:     if (mSinglePixel)
30479:       *aPattern = new gfxPattern(mSinglePixelColor);
30479:     else
30479:       *aPattern = new gfxPattern(ThebesSurface());
30479:     NS_ADDREF(*aPattern);
30479:     return NS_OK;
 7671:   }
 7671: 
30479:   gfxASurface* ThebesSurface() const
30479:   {
30479:     if (mOptSurface)
30479:       return mOptSurface;
30479: #if defined(XP_WIN) && !defined(WINCE)
30479:     if (mWinSurface)
30479:       return mWinSurface;
30479: #elif defined(XP_MACOSX)
30479:     if (mQuartzSurface)
30479:       return mQuartzSurface;
30479: #endif
30479:     return mImageSurface;
 7671:   }
 7671: 
30479: 
30479: private: // methods
30479:   PRUint32 PaletteDataLength() const {
30479:     return ((1 << mPaletteDepth) * sizeof(PRUint32));
30479:   }
30479: 
30479: private: // data
30479:   nsRefPtr<gfxImageSurface> mImageSurface;
30479:   nsRefPtr<gfxASurface> mOptSurface;
30479: #if defined(XP_WIN) && !defined(WINCE)
30479:   nsRefPtr<gfxWindowsSurface> mWinSurface;
30479: #elif defined(XP_MACOSX)
30479:   nsRefPtr<gfxQuartzImageSurface> mQuartzSurface;
30479: #endif
30479: 
30479:   nsIntSize    mSize;
30479:   nsIntPoint   mOffset;
30479: 
30479:   nsIntRect    mDecoded;
30479: 
30479:   // The palette and image data for images that are paletted, since Cairo
30479:   // doesn't support these images.
30479:   // The paletted data comes first, then the image data itself.
30479:   // Total length is PaletteDataLength() + GetImageDataLength().
30479:   PRUint8*     mPalettedImageData;
30479: 
30479:   gfxRGBA      mSinglePixelColor;
    1: 
    1:   PRInt32      mTimeout; // -1 means display forever
    1:   PRInt32      mDisposalMethod;
 7671: 
30479:   gfxASurface::gfxImageFormat mFormat;
30479:   PRInt8       mPaletteDepth;
 7108:   PRInt8       mBlendMethod;
30479:   PRPackedBool mSinglePixel;
30479:   PRPackedBool mNeverUseDeviceSurface;
30479:   PRPackedBool mFormatChanged;
34809:   PRPackedBool mCompositingFailed;
30479: 
30479: #ifdef XP_WIN
30479:   PRPackedBool mIsDDBSurface;
30479: #endif
30479: 
    1: };
30479: 
30479: #endif /* imgFrame_h */
