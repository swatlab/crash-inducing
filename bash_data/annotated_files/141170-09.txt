 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
121609: // XXX: This must be done prior to including cert.h (directly or indirectly).
121609: // CERT_AddTempCertToPerm is exposed as __CERT_AddTempCertToPerm, but it is
121609: // only exported so PSM can use it for this specific purpose.
121609: #define CERT_AddTempCertToPerm __CERT_AddTempCertToPerm
121609: 
140656: #include "nsNSSComponent.h"
140638: #include "nsNSSCertificateDB.h"
124994: #include "mozilla/Base64.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsNSSCertificate.h"
     1: #include "nsNSSHelper.h"
     1: #include "nsNSSCertHelper.h"
     1: #include "nsNSSCertCache.h"
     1: #include "nsCRT.h"
     1: #include "nsICertificateDialogs.h"
     1: #include "nsNSSCertTrust.h"
101111: #include "nsIFile.h"
     1: #include "nsPKCS12Blob.h"
     1: #include "nsPK11TokenDB.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsIMutableArray.h"
     1: #include "nsArrayUtils.h"
     1: #include "nsNSSShutDown.h"
     1: #include "nsIPrefService.h"
     1: #include "nsIPrefBranch.h"
     1: #include "nsComponentManagerUtils.h"
     1: #include "nsIPrompt.h"
 81303: #include "nsThreadUtils.h"
140655: #include "ScopedNSSTypes.h"
125910: #include "nsIObserverService.h"
125910: #include "nsRecentBadCerts.h"
125914: #include "SharedSSLState.h"
     1: 
     1: #include "nspr.h"
     1: #include "certdb.h"
     1: #include "secerr.h"
     1: #include "nssb64.h"
     1: #include "secasn1.h"
     1: #include "secder.h"
     1: #include "ssl.h"
     1: #include "ocsp.h"
     1: #include "plbase64.h"
     1: 
119899: using namespace mozilla;
125914: using mozilla::psm::SharedSSLState;
119899: 
     1: #ifdef PR_LOGGING
     1: extern PRLogModuleInfo* gPIPNSSLog;
     1: #endif
     1: 
     1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
     1: 
     1: 
 14100: NS_IMPL_THREADSAFE_ISUPPORTS2(nsNSSCertificateDB, nsIX509CertDB, nsIX509CertDB2)
     1: 
     1: nsNSSCertificateDB::nsNSSCertificateDB()
125914: : mBadCertsLock("nsNSSCertificateDB::mBadCertsLock")
     1: {
125914:   SharedSSLState::NoteCertDBServiceInstantiated();
     1: }
     1: 
     1: nsNSSCertificateDB::~nsNSSCertificateDB()
     1: {
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificateDB::FindCertByNickname(nsISupports *aToken,
     1:                                       const nsAString &nickname,
     1:                                       nsIX509Cert **_rvCert)
     1: {
124992:   NS_ENSURE_ARG_POINTER(_rvCert);
124992:   *_rvCert = nullptr;
124992: 
     1:   nsNSSShutDownPreventionLock locker;
124992:   ScopedCERTCertificate cert;
119899:   char *asciiname = nullptr;
     1:   NS_ConvertUTF16toUTF8 aUtf8Nickname(nickname);
  3233:   asciiname = const_cast<char*>(aUtf8Nickname.get());
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Getting \"%s\"\n", asciiname));
     1: #if 0
     1:   // what it should be, but for now...
     1:   if (aToken) {
119899:     cert = PK11_FindCertFromNickname(asciiname, nullptr);
     1:   } else {
     1:     cert = CERT_FindCertByNickname(CERT_GetDefaultCertDB(), asciiname);
     1:   }
     1: #endif
119899:   cert = PK11_FindCertFromNickname(asciiname, nullptr);
     1:   if (!cert) {
     1:     cert = CERT_FindCertByNickname(CERT_GetDefaultCertDB(), asciiname);
     1:   }
     1:   if (cert) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("got it\n"));
 56495:     nsCOMPtr<nsIX509Cert> pCert = nsNSSCertificate::Create(cert);
 56495:     if (pCert) {
124992:       pCert.forget(_rvCert);
     1:       return NS_OK;
     1:     }
 56495:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSCertificateDB::FindCertByDBKey(const char *aDBkey, nsISupports *aToken,
     1:                                    nsIX509Cert **_cert)
     1: {
124992:   NS_ENSURE_ARG_POINTER(aDBkey);
124992:   NS_ENSURE_ARG(aDBkey[0]);
124992:   NS_ENSURE_ARG_POINTER(_cert);
124992:   *_cert = nullptr;
124992: 
     1:   nsNSSShutDownPreventionLock locker;
106838:   SECItem keyItem = {siBuffer, nullptr, 0};
     1:   SECItem *dummy;
     1:   CERTIssuerAndSN issuerSN;
 90628:   //unsigned long moduleID,slotID;
  1331: 
106838:   dummy = NSSBase64_DecodeBuffer(nullptr, &keyItem, aDBkey,
108991:                                  (uint32_t)PL_strlen(aDBkey)); 
  5980:   if (!dummy || keyItem.len < NS_NSS_LONG*4) {
  5980:     PR_FREEIF(keyItem.data);
  5980:     return NS_ERROR_INVALID_ARG;
  5980:   }
  1331: 
124992:   ScopedCERTCertificate cert;
     1:   // someday maybe we can speed up the search using the moduleID and slotID
 90628:   // moduleID = NS_NSS_GET_LONG(keyItem.data);
 90628:   // slotID = NS_NSS_GET_LONG(&keyItem.data[NS_NSS_LONG]);
     1: 
     1:   // build the issuer/SN structure
     1:   issuerSN.serialNumber.len = NS_NSS_GET_LONG(&keyItem.data[NS_NSS_LONG*2]);
     1:   issuerSN.derIssuer.len = NS_NSS_GET_LONG(&keyItem.data[NS_NSS_LONG*3]);
  5980:   if (issuerSN.serialNumber.len == 0 || issuerSN.derIssuer.len == 0
  5980:       || issuerSN.serialNumber.len + issuerSN.derIssuer.len
  5980:          != keyItem.len - NS_NSS_LONG*4) {
  5980:     PR_FREEIF(keyItem.data);
  5980:     return NS_ERROR_INVALID_ARG;
  5980:   }
     1:   issuerSN.serialNumber.data= &keyItem.data[NS_NSS_LONG*4];
     1:   issuerSN.derIssuer.data= &keyItem.data[NS_NSS_LONG*4+
     1:                                               issuerSN.serialNumber.len];
     1: 
     1:   cert = CERT_FindCertByIssuerAndSN(CERT_GetDefaultCertDB(), &issuerSN);
     1:   PR_FREEIF(keyItem.data);
     1:   if (cert) {
124992:     nsCOMPtr<nsIX509Cert> nssCert = nsNSSCertificate::Create(cert);
119899:     if (!nssCert)
     1:       return NS_ERROR_OUT_OF_MEMORY;
124992:     nssCert.forget(_cert);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSCertificateDB::FindCertNicknames(nsISupports *aToken, 
108991:                                      uint32_t      aType,
108991:                                      uint32_t     *_count,
     1:                                      PRUnichar  ***_certNames)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv = NS_ERROR_FAILURE;
     1:   /*
     1:    * obtain the cert list from NSS
     1:    */
124992:   ScopedCERTCertList certList;
     1:   PK11CertListType pk11type;
     1: #if 0
     1:   // this would seem right, but it didn't work...
     1:   // oh, I know why - bonks out on internal slot certs
     1:   if (aType == nsIX509Cert::USER_CERT)
     1:     pk11type = PK11CertListUser;
     1:   else 
     1: #endif
     1:     pk11type = PK11CertListUnique;
119899:   certList = PK11_ListCerts(pk11type, nullptr);
     1:   if (!certList)
     1:     goto cleanup;
     1:   /*
     1:    * get list of cert names from list of certs
     1:    * XXX also cull the list (NSS only distinguishes based on user/non-user
     1:    */
     1:   getCertNames(certList, aType, _count, _certNames);
     1:   rv = NS_OK;
     1:   /*
     1:    * finish up
     1:    */
     1: cleanup:
     1:   return rv;
     1: }
     1: 
115027: SECStatus
     1: collect_certs(void *arg, SECItem **certs, int numcerts)
     1: {
     1:   CERTDERCerts *collectArgs;
     1:   SECItem *cert;
     1:   SECStatus rv;
     1: 
     1:   collectArgs = (CERTDERCerts *)arg;
     1: 
     1:   collectArgs->numcerts = numcerts;
     1:   collectArgs->rawCerts = (SECItem *) PORT_ArenaZAlloc(collectArgs->arena,
     1:                                            sizeof(SECItem) * numcerts);
119899:   if (!collectArgs->rawCerts)
     1:     return(SECFailure);
     1: 
     1:   cert = collectArgs->rawCerts;
     1: 
     1:   while ( numcerts-- ) {
     1:     rv = SECITEM_CopyItem(collectArgs->arena, cert, *certs);
     1:     if ( rv == SECFailure )
     1:       return(SECFailure);
     1:     cert++;
     1:     certs++;
     1:   }
     1: 
     1:   return (SECSuccess);
     1: }
     1: 
     1: CERTDERCerts*
119200: nsNSSCertificateDB::getCertsFromPackage(PLArenaPool *arena, uint8_t *data, 
108991:                                         uint32_t length)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   CERTDERCerts *collectArgs = 
     1:                (CERTDERCerts *)PORT_ArenaZAlloc(arena, sizeof(CERTDERCerts));
119899:   if (!collectArgs)
106838:     return nullptr;
     1: 
     1:   collectArgs->arena = arena;
  3233:   SECStatus sec_rv = CERT_DecodeCertPackage(reinterpret_cast<char *>(data), 
     1:                                             length, collect_certs, 
     1:                                             (void *)collectArgs);
     1:   if (sec_rv != SECSuccess)
106838:     return nullptr;
     1: 
     1:   return collectArgs;
     1: }
     1: 
     1: nsresult
     1: nsNSSCertificateDB::handleCACertDownload(nsIArray *x509Certs,
     1:                                          nsIInterfaceRequestor *ctx)
     1: {
     1:   // First thing we have to do is figure out which certificate we're 
     1:   // gonna present to the user.  The CA may have sent down a list of 
     1:   // certs which may or may not be a chained list of certs.  Until
     1:   // the day we can design some solid UI for the general case, we'll
     1:   // code to the > 90% case.  That case is where a CA sends down a
     1:   // list that is a hierarchy whose root is either the first or 
     1:   // the last cert.  What we're gonna do is compare the first 
     1:   // 2 entries, if the second was signed by the first, we assume
     1:   // the root cert is the first cert and display it.  Otherwise,
     1:   // we compare the last 2 entries, if the second to last cert was
     1:   // signed by the last cert, then we assume the last cert is the
     1:   // root and display it.
     1: 
     1:   nsNSSShutDownPreventionLock locker;
     1: 
108991:   uint32_t numCerts;
     1: 
     1:   x509Certs->GetLength(&numCerts);
     1:   NS_ASSERTION(numCerts > 0, "Didn't get any certs to import.");
     1:   if (numCerts == 0)
     1:     return NS_OK; // Nothing to import, so nothing to do.
     1: 
     1:   nsCOMPtr<nsIX509Cert> certToShow;
     1:   nsCOMPtr<nsISupports> isupports;
108991:   uint32_t selCertIndex;
     1:   if (numCerts == 1) {
     1:     // There's only one cert, so let's show it.
     1:     selCertIndex = 0;
     1:     certToShow = do_QueryElementAt(x509Certs, selCertIndex);
     1:   } else {
     1:     nsCOMPtr<nsIX509Cert> cert0;    // first cert
     1:     nsCOMPtr<nsIX509Cert> cert1;    // second cert
     1:     nsCOMPtr<nsIX509Cert> certn_2;  // second to last cert
     1:     nsCOMPtr<nsIX509Cert> certn_1;  // last cert
     1: 
     1:     cert0 = do_QueryElementAt(x509Certs, 0);
     1:     cert1 = do_QueryElementAt(x509Certs, 1);
     1:     certn_2 = do_QueryElementAt(x509Certs, numCerts-2);
     1:     certn_1 = do_QueryElementAt(x509Certs, numCerts-1);
     1: 
     1:     nsXPIDLString cert0SubjectName;
     1:     nsXPIDLString cert1IssuerName;
     1:     nsXPIDLString certn_2IssuerName;
     1:     nsXPIDLString certn_1SubjectName;
     1: 
     1:     cert0->GetSubjectName(cert0SubjectName);
     1:     cert1->GetIssuerName(cert1IssuerName);
     1:     certn_2->GetIssuerName(certn_2IssuerName);
     1:     certn_1->GetSubjectName(certn_1SubjectName);
     1: 
     1:     if (cert1IssuerName.Equals(cert0SubjectName)) {
     1:       // In this case, the first cert in the list signed the second,
     1:       // so the first cert is the root.  Let's display it. 
     1:       selCertIndex = 0;
     1:       certToShow = cert0;
     1:     } else 
     1:     if (certn_2IssuerName.Equals(certn_1SubjectName)) { 
     1:       // In this case the last cert has signed the second to last cert.
     1:       // The last cert is the root, so let's display it.
     1:       selCertIndex = numCerts-1;
     1:       certToShow = certn_1;
     1:     } else {
     1:       // It's not a chain, so let's just show the first one in the 
     1:       // downloaded list.
     1:       selCertIndex = 0;
     1:       certToShow = cert0;
     1:     }
     1:   }
     1: 
     1:   if (!certToShow)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsICertificateDialogs> dialogs;
     1:   nsresult rv = ::getNSSDialogs(getter_AddRefs(dialogs), 
     1:                                 NS_GET_IID(nsICertificateDialogs),
     1:                                 NS_CERTIFICATEDIALOGS_CONTRACTID);
     1:                        
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1:  
     1:   SECItem der;
108991:   rv=certToShow->GetRawDER(&der.len, (uint8_t **)&der.data);
     1: 
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Creating temp cert\n"));
124992:   ScopedCERTCertificate tmpCert;
     1:   CERTCertDBHandle *certdb = CERT_GetDefaultCertDB();
     1:   tmpCert = CERT_FindCertByDERCert(certdb, &der);
     1:   if (!tmpCert) {
     1:     tmpCert = CERT_NewTempCertificate(certdb, &der,
106838:                                       nullptr, false, true);
     1:   }
     1:   nsMemory::Free(der.data);
106838:   der.data = nullptr;
     1:   der.len = 0;
     1:   
     1:   if (!tmpCert) {
 43756:     NS_ERROR("Couldn't create cert from DER blob");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
119899:   if (!CERT_IsCACert(tmpCert, nullptr)) {
     1:     DisplayCertificateAlert(ctx, "NotACACert", certToShow);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   if (tmpCert->isperm) {
     1:     DisplayCertificateAlert(ctx, "CaCertExists", certToShow);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
108991:   uint32_t trustBits;
 79445:   bool allows;
     1:   rv = dialogs->ConfirmDownloadCACert(ctx, certToShow, &trustBits, &allows);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   if (!allows)
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("trust is %d\n", trustBits));
     1:   nsXPIDLCString nickname;
     1:   nickname.Adopt(CERT_MakeCANickname(tmpCert));
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Created nick \"%s\"\n", nickname.get()));
     1: 
     1:   nsNSSCertTrust trust;
     1:   trust.SetValidCA();
 19743:   trust.AddCATrust(!!(trustBits & nsIX509CertDB::TRUSTED_SSL),
 19743:                    !!(trustBits & nsIX509CertDB::TRUSTED_EMAIL),
 19743:                    !!(trustBits & nsIX509CertDB::TRUSTED_OBJSIGN));
     1: 
121609:   SECStatus srv = __CERT_AddTempCertToPerm(tmpCert,
  3233:                                            const_cast<char*>(nickname.get()),
     1:                                            trust.GetTrust());
     1: 
     1:   if (srv != SECSuccess)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   // Import additional delivered certificates that can be verified.
     1: 
     1:   // build a CertList for filtering
124992:   ScopedCERTCertList certList(CERT_NewCertList());
119899:   if (!certList) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   // get all remaining certs into temp store
     1: 
108991:   for (uint32_t i=0; i<numCerts; i++) {
     1:     if (i == selCertIndex) {
     1:       // we already processed that one
     1:       continue;
     1:     }
     1: 
     1:     certToShow = do_QueryElementAt(x509Certs, i);
108991:     certToShow->GetRawDER(&der.len, (uint8_t **)&der.data);
     1: 
     1:     CERTCertificate *tmpCert2 = 
106838:       CERT_NewTempCertificate(certdb, &der, nullptr, false, true);
     1: 
     1:     nsMemory::Free(der.data);
106838:     der.data = nullptr;
     1:     der.len = 0;
     1: 
     1:     if (!tmpCert2) {
 43756:       NS_ERROR("Couldn't create temp cert from DER blob");
     1:       continue;  // Let's try to import the rest of 'em
     1:     }
     1:     
     1:     CERT_AddCertToListTail(certList, tmpCert2);
     1:   }
     1: 
     1:   return ImportValidCACertsInList(certList, ctx);
     1: }
     1: 
     1: /*
     1:  *  [noscript] void importCertificates(in charPtr data, in unsigned long length,
     1:  *                                     in unsigned long type, 
     1:  *                                     in nsIInterfaceRequestor ctx);
     1:  */
     1: NS_IMETHODIMP 
108991: nsNSSCertificateDB::ImportCertificates(uint8_t * data, uint32_t length, 
108991:                                        uint32_t type, 
     1:                                        nsIInterfaceRequestor *ctx)
     1: 
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult nsrv;
     1: 
119200:   PLArenaPool *arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     1:   if (!arena)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   CERTDERCerts *certCollection = getCertsFromPackage(arena, data, length);
     1:   if (!certCollection) {
 80486:     PORT_FreeArena(arena, false);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   nsCOMPtr<nsIMutableArray> array =
     1:     do_CreateInstance(NS_ARRAY_CONTRACTID, &nsrv);
     1:   if (NS_FAILED(nsrv)) {
 80486:     PORT_FreeArena(arena, false);
     1:     return nsrv;
     1:   }
     1: 
     1:   // Now let's create some certs to work with
     1:   nsCOMPtr<nsIX509Cert> x509Cert;
     1:   nsNSSCertificate *nssCert;
     1:   SECItem *currItem;
     1:   for (int i=0; i<certCollection->numcerts; i++) {
     1:      currItem = &certCollection->rawCerts[i];
     1:      nssCert = nsNSSCertificate::ConstructFromDER((char*)currItem->data, currItem->len);
     1:      if (!nssCert)
     1:        return NS_ERROR_FAILURE;
     1:      x509Cert = do_QueryInterface((nsIX509Cert*)nssCert);
 80486:      array->AppendElement(x509Cert, false);
     1:   }
     1:   switch (type) {
     1:   case nsIX509Cert::CA_CERT:
     1:     nsrv = handleCACertDownload(array, ctx);
     1:     break;
     1:   default:
     1:     // We only deal with import CA certs in this method currently.
     1:      nsrv = NS_ERROR_FAILURE;
     1:      break;
     1:   }  
 80486:   PORT_FreeArena(arena, false);
     1:   return nsrv;
     1: }
     1: 
     1: 
     1: /*
     1:  *  [noscript] void importEmailCertificates(in charPtr data, in unsigned long length,
     1:  *                                     in nsIInterfaceRequestor ctx);
     1:  */
     1: NS_IMETHODIMP
108991: nsNSSCertificateDB::ImportEmailCertificate(uint8_t * data, uint32_t length, 
     1:                                        nsIInterfaceRequestor *ctx)
     1: 
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   SECStatus srv = SECFailure;
     1:   nsresult nsrv = NS_OK;
     1:   CERTCertDBHandle *certdb;
119899:   CERTCertificate **certArray = nullptr;
124992:   ScopedCERTCertList certList;
     1:   CERTCertListNode *node;
140656:   PRTime now;
140656:   SECCertUsage certusage;
140656:   SECCertificateUsage certificateusage;
     1:   SECItem **rawArray;
     1:   int numcerts;
     1:   int i;
 69383: 
119200:   PLArenaPool *arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     1:   if (!arena)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   CERTDERCerts *certCollection = getCertsFromPackage(arena, data, length);
     1:   if (!certCollection) {
 80486:     PORT_FreeArena(arena, false);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   certdb = CERT_GetDefaultCertDB();
140656:   certusage = certUsageEmailRecipient;
140656:   certificateusage = certificateUsageEmailRecipient;
     1: 
     1:   numcerts = certCollection->numcerts;
     1: 
     1:   rawArray = (SECItem **) PORT_Alloc(sizeof(SECItem *) * numcerts);
     1:   if ( !rawArray ) {
     1:     nsrv = NS_ERROR_FAILURE;
     1:     goto loser;
     1:   }
     1: 
     1:   for (i=0; i < numcerts; i++) {
     1:     rawArray[i] = &certCollection->rawCerts[i];
     1:   }
     1: 
140656:   srv = CERT_ImportCerts(certdb, certusage, numcerts, rawArray, 
119899:                          &certArray, false, false, nullptr);
     1: 
     1:   PORT_Free(rawArray);
119899:   rawArray = nullptr;
     1: 
     1:   if (srv != SECSuccess) {
     1:     nsrv = NS_ERROR_FAILURE;
     1:     goto loser;
     1:   }
     1: 
     1:   // build a CertList for filtering
     1:   certList = CERT_NewCertList();
119899:   if (!certList) {
     1:     nsrv = NS_ERROR_FAILURE;
     1:     goto loser;
     1:   }
     1:   for (i=0; i < numcerts; i++) {
     1:     CERTCertificate *cert = certArray[i];
     1:     if (cert)
     1:       cert = CERT_DupCertificate(cert);
     1:     if (cert)
     1:       CERT_AddCertToListTail(certList, cert);
     1:   }
     1: 
     1:   /* go down the remaining list of certs and verify that they have
     1:    * valid chains, then import them.
     1:    */
140656:   now = PR_Now();
 69383: 
     1:   for (node = CERT_LIST_HEAD(certList);
     1:        !CERT_LIST_END(node,certList);
     1:        node = CERT_LIST_NEXT(node)) {
     1: 
140655:     bool alert_and_skip = false;
140655: 
     1:     if (!node->cert) {
     1:       continue;
     1:     }
     1: 
141170: #ifndef NSS_NO_LIBPKIX
140656:     if (!nsNSSComponent::globalConstFlagUsePKIXVerification) {
141170: #endif
140656:       if (CERT_VerifyCert(certdb, node->cert,
140656:           true, certusage, now, ctx, nullptr) != SECSuccess) {
140655:         alert_and_skip = true;
140655:       }
141170: #ifndef NSS_NO_LIBPKIX
140656:     }
140656:     else {
141170:       nsCOMPtr<nsINSSComponent> inss = do_GetService(kNSSComponentCID, &nsrv);
141170:       if (!inss)
141170:         return nsrv;
141170:       RefPtr<nsCERTValInParamWrapper> survivingParams;
141170:       nsrv = inss->GetDefaultCERTValInParam(survivingParams);
141170:       if (NS_FAILED(nsrv))
141170:         return nsrv;
141170:       CERTValOutParam cvout[1];
141170:       cvout[0].type = cert_po_end;
140656:       if (CERT_PKIXVerifyCert(node->cert, certificateusage,
140656:                               survivingParams->GetRawPointerForNSS(),
140656:                               cvout, ctx)
140656:           != SECSuccess) {
140656:         alert_and_skip = true;
140656:       }
140656:     }
141170: #endif
140639: 
140655:     ScopedCERTCertificateList certChain;
140639: 
140655:     if (!alert_and_skip) {
140656:       certChain = CERT_CertChainFromCert(node->cert, certusage, false);
140655:       if (!certChain) {
140655:         alert_and_skip = true;
140655:       }
140655:     }
140655: 
140655:     if (alert_and_skip) {    
 56495:       nsCOMPtr<nsIX509Cert> certToShow = nsNSSCertificate::Create(node->cert);
     1:       DisplayCertificateAlert(ctx, "NotImportingUnverifiedCert", certToShow);
     1:       continue;
     1:     }
140655: 
140655:     /*
140655:      * CertChain returns an array of SECItems, import expects an array of
140655:      * SECItem pointers. Create the SECItem Pointers from the array of
140655:      * SECItems.
140655:      */
140655:     rawArray = (SECItem **) PORT_Alloc(certChain->len * sizeof(SECItem *));
140655:     if (!rawArray) {
140655:       continue;
     1:     }
140655:     for (i=0; i < certChain->len; i++) {
140655:       rawArray[i] = &certChain->certs[i];
140655:     }
140656:     CERT_ImportCerts(certdb, certusage, certChain->len, 
140655:                             rawArray,  nullptr, true, false, nullptr);
140655: 
119899:     CERT_SaveSMimeProfile(node->cert, nullptr, nullptr);
     1: 
140655:     PORT_Free(rawArray);
     1:   }
     1: 
     1: loser:
     1:   if (certArray) {
     1:     CERT_DestroyCertArray(certArray, numcerts);
     1:   }
     1:   if (arena) 
 80486:     PORT_FreeArena(arena, true);
     1:   return nsrv;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsNSSCertificateDB::ImportServerCertificate(uint8_t * data, uint32_t length, 
     1:                                             nsIInterfaceRequestor *ctx)
     1: 
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   SECStatus srv = SECFailure;
     1:   nsresult nsrv = NS_OK;
124992:   ScopedCERTCertificate cert;
106838:   SECItem **rawCerts = nullptr;
     1:   int numcerts;
     1:   int i;
     1:   nsNSSCertTrust trust;
106838:   char *serverNickname = nullptr;
     1:  
119200:   PLArenaPool *arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     1:   if (!arena)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   CERTDERCerts *certCollection = getCertsFromPackage(arena, data, length);
     1:   if (!certCollection) {
 80486:     PORT_FreeArena(arena, false);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), certCollection->rawCerts,
119899:                                  nullptr, false, true);
     1:   if (!cert) {
     1:     nsrv = NS_ERROR_FAILURE;
     1:     goto loser;
     1:   }
     1:   numcerts = certCollection->numcerts;
     1:   rawCerts = (SECItem **) PORT_Alloc(sizeof(SECItem *) * numcerts);
     1:   if ( !rawCerts ) {
     1:     nsrv = NS_ERROR_FAILURE;
     1:     goto loser;
     1:   }
     1: 
     1:   for ( i = 0; i < numcerts; i++ ) {
     1:     rawCerts[i] = &certCollection->rawCerts[i];
     1:   }
     1: 
     1:   serverNickname = nsNSSCertificate::defaultServerNickname(cert);
     1:   srv = CERT_ImportCerts(CERT_GetDefaultCertDB(), certUsageSSLServer,
119899:              numcerts, rawCerts, nullptr, true, false,
     1:              serverNickname);
     1:   PR_FREEIF(serverNickname);
     1:   if ( srv != SECSuccess ) {
     1:     nsrv = NS_ERROR_FAILURE;
     1:     goto loser;
     1:   }
     1: 
     1:   trust.SetValidServerPeer();
     1:   srv = CERT_ChangeCertTrust(CERT_GetDefaultCertDB(), cert, trust.GetTrust());
     1:   if ( srv != SECSuccess ) {
     1:     nsrv = NS_ERROR_FAILURE;
     1:     goto loser;
     1:   }
     1: loser:
     1:   PORT_Free(rawCerts);
     1:   if (arena) 
 80486:     PORT_FreeArena(arena, true);
     1:   return nsrv;
     1: }
     1: 
     1: nsresult
     1: nsNSSCertificateDB::ImportValidCACerts(int numCACerts, SECItem *CACerts, nsIInterfaceRequestor *ctx)
     1: {
124992:   ScopedCERTCertList certList;
     1:   SECItem **rawArray;
     1: 
     1:   // build a CertList for filtering
     1:   certList = CERT_NewCertList();
119899:   if (!certList) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   // get all certs into temp store
     1:   SECStatus srv = SECFailure;
119899:   CERTCertificate **certArray = nullptr;
     1: 
     1:   rawArray = (SECItem **) PORT_Alloc(sizeof(SECItem *) * numCACerts);
     1:   if ( !rawArray ) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   for (int i=0; i < numCACerts; i++) {
     1:     rawArray[i] = &CACerts[i];
     1:   }
     1: 
     1:   srv = CERT_ImportCerts(CERT_GetDefaultCertDB(), certUsageAnyCA, numCACerts, rawArray, 
119899:                          &certArray, false, true, nullptr);
     1: 
     1:   PORT_Free(rawArray);
119899:   rawArray = nullptr;
     1: 
     1:   if (srv != SECSuccess) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   for (int i2=0; i2 < numCACerts; i2++) {
     1:     CERTCertificate *cacert = certArray[i2];
     1:     if (cacert)
     1:       cacert = CERT_DupCertificate(cacert);
     1:     if (cacert)
     1:       CERT_AddCertToListTail(certList, cacert);
     1:   }
     1: 
     1:   CERT_DestroyCertArray(certArray, numCACerts);
     1: 
     1:   return ImportValidCACertsInList(certList, ctx);
     1: }
     1: 
     1: nsresult
     1: nsNSSCertificateDB::ImportValidCACertsInList(CERTCertList *certList, nsIInterfaceRequestor *ctx)
     1: {
     1:   SECItem **rawArray;
140656:   nsresult nsrv;
     1: 
     1:   /* filter out the certs we don't want */
 80486:   SECStatus srv = CERT_FilterCertListByUsage(certList, certUsageAnyCA, true);
     1:   if (srv != SECSuccess) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   /* go down the remaining list of certs and verify that they have
     1:    * valid chains, if yes, then import.
     1:    */
     1:   CERTCertListNode *node;
 69383: 
     1:   for (node = CERT_LIST_HEAD(certList);
     1:        !CERT_LIST_END(node,certList);
     1:        node = CERT_LIST_NEXT(node)) {
     1: 
140655:     bool alert_and_skip = false;
     1: 
141170: #ifndef NSS_NO_LIBPKIX
140656:     if (!nsNSSComponent::globalConstFlagUsePKIXVerification) {
141170: #endif
140656:       if (CERT_VerifyCert(CERT_GetDefaultCertDB(), node->cert, 
140656:           true, certUsageVerifyCA, PR_Now(), ctx, nullptr) != SECSuccess) {
140655:         alert_and_skip = true;
140655:       }
141170: #ifndef NSS_NO_LIBPKIX
140656:     }
140656:     else {
141170:       nsCOMPtr<nsINSSComponent> inss = do_GetService(kNSSComponentCID, &nsrv);
141170:       if (!inss)
141170:         return nsrv;
141170:       RefPtr<nsCERTValInParamWrapper> survivingParams;
141170:       nsrv = inss->GetDefaultCERTValInParam(survivingParams);
141170:       if (NS_FAILED(nsrv))
141170:         return nsrv;
141170:       CERTValOutParam cvout[1];
141170:       cvout[0].type = cert_po_end;
140656:       if (CERT_PKIXVerifyCert(node->cert, certificateUsageVerifyCA,
140656:                               survivingParams->GetRawPointerForNSS(),
140656:                               cvout, ctx)
140656:           != SECSuccess) {
140656:         alert_and_skip = true;
140656:       }
140656:     }
141170: #endif
140639: 
140655:     ScopedCERTCertificateList certChain;
140639: 
140655:     if (!alert_and_skip) {    
140655:       certChain = CERT_CertChainFromCert(node->cert, certUsageAnyCA, false);
140655:       if (!certChain) {
140655:         alert_and_skip = true;
140655:       }
140655:     }
140655: 
140655:     if (alert_and_skip) {    
 56495:       nsCOMPtr<nsIX509Cert> certToShow = nsNSSCertificate::Create(node->cert);
     1:       DisplayCertificateAlert(ctx, "NotImportingUnverifiedCert", certToShow);
     1:       continue;
     1:     }
     1: 
140655:     /*
140655:      * CertChain returns an array of SECItems, import expects an array of
140655:      * SECItem pointers. Create the SECItem Pointers from the array of
140655:      * SECItems.
140655:      */
140655:     rawArray = (SECItem **) PORT_Alloc(certChain->len * sizeof(SECItem *));
140655:     if (!rawArray) {
140655:       continue;
140655:     }
140655:     for (int i=0; i < certChain->len; i++) {
140655:       rawArray[i] = &certChain->certs[i];
140655:     }
140655:     CERT_ImportCerts(CERT_GetDefaultCertDB(), certUsageAnyCA, certChain->len, 
140655:                             rawArray,  nullptr, true, true, nullptr);
140655: 
140655:     PORT_Free(rawArray);
     1:   }
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: void nsNSSCertificateDB::DisplayCertificateAlert(nsIInterfaceRequestor *ctx, 
     1:                                                  const char *stringID, 
     1:                                                  nsIX509Cert *certToShow)
     1: {
 81303:   if (!NS_IsMainThread()) {
 81303:     NS_ERROR("nsNSSCertificateDB::DisplayCertificateAlert called off the main thread");
 81303:     return;
 81303:   }
 81303: 
     1:   nsPSMUITracker tracker;
     1:   if (!tracker.isUIForbidden()) {
     1: 
 81303:     nsCOMPtr<nsIInterfaceRequestor> my_ctx = ctx;
 81303:     if (!my_ctx)
 81303:       my_ctx = new PipUIContext();
     1: 
     1:     // This shall be replaced by embedding ovverridable prompts
     1:     // as discussed in bug 310446, and should make use of certToShow.
     1: 
     1:     nsresult rv;
     1:     nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:     if (NS_SUCCEEDED(rv)) {
     1:       nsAutoString tmpMessage;
     1:       nssComponent->GetPIPNSSBundleString(stringID, tmpMessage);
     1: 
 81303:       nsCOMPtr<nsIPrompt> prompt (do_GetInterface(my_ctx));
     1:       if (!prompt)
     1:         return;
     1:     
106838:       prompt->Alert(nullptr, tmpMessage.get());
     1:     }
     1:   }
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
108991: nsNSSCertificateDB::ImportUserCertificate(uint8_t *data, uint32_t length, nsIInterfaceRequestor *ctx)
     1: {
 81303:   if (!NS_IsMainThread()) {
 81303:     NS_ERROR("nsNSSCertificateDB::ImportUserCertificate called off the main thread");
 81303:     return NS_ERROR_NOT_SAME_THREAD;
 81303:   }
 81303:   
     1:   nsNSSShutDownPreventionLock locker;
124992:   ScopedPK11SlotInfo slot;
110974:   nsAutoCString nickname;
     1:   nsresult rv = NS_ERROR_FAILURE;
     1:   int numCACerts;
     1:   SECItem *CACerts;
     1:   CERTDERCerts * collectArgs;
119200:   PLArenaPool *arena;
124992:   ScopedCERTCertificate cert;
     1: 
     1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
119899:   if (!arena) {
     1:     goto loser;
     1:   }
     1: 
     1:   collectArgs = getCertsFromPackage(arena, data, length);
     1:   if (!collectArgs) {
     1:     goto loser;
     1:   }
     1: 
     1:   cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), collectArgs->rawCerts,
119899:                                  nullptr, false, true);
     1:   if (!cert) {
     1:     goto loser;
     1:   }
     1: 
119899:   slot = PK11_KeyForCertExists(cert, nullptr, ctx);
119899:   if (!slot) {
 56495:     nsCOMPtr<nsIX509Cert> certToShow = nsNSSCertificate::Create(cert);
     1:     DisplayCertificateAlert(ctx, "UserCertIgnoredNoPrivateKey", certToShow);
     1:     goto loser;
     1:   }
124992:   slot = nullptr;
     1: 
     1:   /* pick a nickname for the cert */
     1:   if (cert->nickname) {
     1: 	/* sigh, we need a call to look up other certs with this subject and
     1: 	 * identify nicknames from them. We can no longer walk down internal
     1: 	 * database structures  rjr */
     1:   	nickname = cert->nickname;
     1:   }
     1:   else {
 15320:     get_default_nickname(cert, ctx, nickname);
     1:   }
     1: 
     1:   /* user wants to import the cert */
 15320:   {
 15320:     char *cast_const_away = const_cast<char*>(nickname.get());
 15320:     slot = PK11_ImportCertForKey(cert, cast_const_away, ctx);
 15320:   }
     1:   if (!slot) {
     1:     goto loser;
     1:   }
124992:   slot = nullptr;
     1: 
     1:   {
 56495:     nsCOMPtr<nsIX509Cert> certToShow = nsNSSCertificate::Create(cert);
     1:     DisplayCertificateAlert(ctx, "UserCertImported", certToShow);
     1:   }
     1:   rv = NS_OK;
     1: 
     1:   numCACerts = collectArgs->numcerts - 1;
     1:   if (numCACerts) {
     1:     CACerts = collectArgs->rawCerts+1;
     1:     rv = ImportValidCACerts(numCACerts, CACerts, ctx);
     1:   }
     1:   
     1: loser:
     1:   if (arena) {
 80486:     PORT_FreeArena(arena, false);
     1:   }
     1:   return rv;
     1: }
     1: 
     1: /*
     1:  * void deleteCertificate(in nsIX509Cert aCert);
     1:  */
     1: NS_IMETHODIMP 
     1: nsNSSCertificateDB::DeleteCertificate(nsIX509Cert *aCert)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsCOMPtr<nsIX509Cert2> nssCert = do_QueryInterface(aCert);
124992:   ScopedCERTCertificate cert(nssCert->GetCert());
     1:   if (!cert) return NS_ERROR_FAILURE;
     1:   SECStatus srv = SECSuccess;
     1: 
108991:   uint32_t certType;
     1:   nssCert->GetCertType(&certType);
     1:   if (NS_FAILED(nssCert->MarkForPermDeletion()))
     1:   {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   if (cert->slot && certType != nsIX509Cert::USER_CERT) {
     1:     // To delete a cert of a slot (builtin, most likely), mark it as
     1:     // completely untrusted.  This way we keep a copy cached in the
     1:     // local database, and next time we try to load it off of the 
     1:     // external token/slot, we'll know not to trust it.  We don't 
     1:     // want to do that with user certs, because a user may  re-store
     1:     // the cert onto the card again at which point we *will* want to 
     1:     // trust that cert if it chains up properly.
     1:     nsNSSCertTrust trust(0, 0, 0);
     1:     srv = CERT_ChangeCertTrust(CERT_GetDefaultCertDB(), 
     1:                                cert, trust.GetTrust());
     1:   }
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("cert deleted: %d", srv));
     1:   return (srv) ? NS_ERROR_FAILURE : NS_OK;
     1: }
     1: 
     1: /*
     1:  * void setCertTrust(in nsIX509Cert cert,
     1:  *                   in unsigned long type,
     1:  *                   in unsigned long trust);
     1:  */
     1: NS_IMETHODIMP 
     1: nsNSSCertificateDB::SetCertTrust(nsIX509Cert *cert, 
108991:                                  uint32_t type,
108991:                                  uint32_t trusted)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   SECStatus srv;
     1:   nsNSSCertTrust trust;
     1:   nsCOMPtr<nsIX509Cert2> pipCert = do_QueryInterface(cert);
  3770:   if (!pipCert)
  3770:     return NS_ERROR_FAILURE;
124992:   ScopedCERTCertificate nsscert(pipCert->GetCert());
124992: 
     1:   if (type == nsIX509Cert::CA_CERT) {
     1:     // always start with untrusted and move up
     1:     trust.SetValidCA();
 19743:     trust.AddCATrust(!!(trusted & nsIX509CertDB::TRUSTED_SSL),
 19743:                      !!(trusted & nsIX509CertDB::TRUSTED_EMAIL),
 19743:                      !!(trusted & nsIX509CertDB::TRUSTED_OBJSIGN));
     1:     srv = CERT_ChangeCertTrust(CERT_GetDefaultCertDB(), 
     1:                                nsscert,
     1:                                trust.GetTrust());
     1:   } else if (type == nsIX509Cert::SERVER_CERT) {
     1:     // always start with untrusted and move up
     1:     trust.SetValidPeer();
     1:     trust.AddPeerTrust(trusted & nsIX509CertDB::TRUSTED_SSL, 0, 0);
     1:     srv = CERT_ChangeCertTrust(CERT_GetDefaultCertDB(), 
     1:                                nsscert,
     1:                                trust.GetTrust());
     1:   } else if (type == nsIX509Cert::EMAIL_CERT) {
     1:     // always start with untrusted and move up
     1:     trust.SetValidPeer();
 19743:     trust.AddPeerTrust(0, !!(trusted & nsIX509CertDB::TRUSTED_EMAIL), 0);
     1:     srv = CERT_ChangeCertTrust(CERT_GetDefaultCertDB(), 
     1:                                nsscert,
     1:                                trust.GetTrust());
     1:   } else {
     1:     // ignore user certs
     1:     return NS_OK;
     1:   }
     1:   return (srv) ? NS_ERROR_FAILURE : NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSCertificateDB::IsCertTrusted(nsIX509Cert *cert, 
108991:                                   uint32_t certType,
108991:                                   uint32_t trustType,
 79445:                                   bool *_isTrusted)
     1: {
     1:   NS_ENSURE_ARG_POINTER(_isTrusted);
 80486:   *_isTrusted = false;
     1: 
     1:   nsNSSShutDownPreventionLock locker;
     1:   SECStatus srv;
     1:   nsCOMPtr<nsIX509Cert2> pipCert = do_QueryInterface(cert);
124992:   ScopedCERTCertificate nsscert(pipCert->GetCert());
     1:   CERTCertTrust nsstrust;
     1:   srv = CERT_GetCertTrust(nsscert, &nsstrust);
     1:   if (srv != SECSuccess)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   nsNSSCertTrust trust(&nsstrust);
     1:   if (certType == nsIX509Cert::CA_CERT) {
     1:     if (trustType & nsIX509CertDB::TRUSTED_SSL) {
 80486:       *_isTrusted = trust.HasTrustedCA(true, false, false);
     1:     } else if (trustType & nsIX509CertDB::TRUSTED_EMAIL) {
 80486:       *_isTrusted = trust.HasTrustedCA(false, true, false);
     1:     } else if (trustType & nsIX509CertDB::TRUSTED_OBJSIGN) {
 80486:       *_isTrusted = trust.HasTrustedCA(false, false, true);
     1:     } else {
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:   } else if (certType == nsIX509Cert::SERVER_CERT) {
     1:     if (trustType & nsIX509CertDB::TRUSTED_SSL) {
 80486:       *_isTrusted = trust.HasTrustedPeer(true, false, false);
     1:     } else if (trustType & nsIX509CertDB::TRUSTED_EMAIL) {
 80486:       *_isTrusted = trust.HasTrustedPeer(false, true, false);
     1:     } else if (trustType & nsIX509CertDB::TRUSTED_OBJSIGN) {
 80486:       *_isTrusted = trust.HasTrustedPeer(false, false, true);
     1:     } else {
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:   } else if (certType == nsIX509Cert::EMAIL_CERT) {
     1:     if (trustType & nsIX509CertDB::TRUSTED_SSL) {
 80486:       *_isTrusted = trust.HasTrustedPeer(true, false, false);
     1:     } else if (trustType & nsIX509CertDB::TRUSTED_EMAIL) {
 80486:       *_isTrusted = trust.HasTrustedPeer(false, true, false);
     1:     } else if (trustType & nsIX509CertDB::TRUSTED_OBJSIGN) {
 80486:       *_isTrusted = trust.HasTrustedPeer(false, false, true);
     1:     } else {
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:   } /* user: ignore */
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSCertificateDB::ImportCertsFromFile(nsISupports *aToken, 
101111:                                         nsIFile *aFile,
108991:                                         uint32_t aType)
     1: {
  3771:   NS_ENSURE_ARG(aFile);
     1:   switch (aType) {
     1:     case nsIX509Cert::CA_CERT:
     1:     case nsIX509Cert::EMAIL_CERT:
     1:     case nsIX509Cert::SERVER_CERT:
     1:       // good
     1:       break;
     1:     
     1:     default:
     1:       // not supported (yet)
     1:       return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   nsresult rv;
106838:   PRFileDesc *fd = nullptr;
     1: 
     1:   rv = aFile->OpenNSPRFileDesc(PR_RDONLY, 0, &fd);
     1: 
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   if (!fd)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   PRFileInfo file_info;
     1:   if (PR_SUCCESS != PR_GetOpenFileInfo(fd, &file_info))
     1:     return NS_ERROR_FAILURE;
     1:   
     1:   unsigned char *buf = new unsigned char[file_info.size];
     1:   
108991:   int32_t bytes_obtained = PR_Read(fd, buf, file_info.size);
     1:   PR_Close(fd);
     1:   
     1:   if (bytes_obtained != file_info.size)
     1:     rv = NS_ERROR_FAILURE;
     1:   else {
     1: 	  nsCOMPtr<nsIInterfaceRequestor> cxt = new PipUIContext();
     1: 
     1:     switch (aType) {
     1:       case nsIX509Cert::CA_CERT:
     1:         rv = ImportCertificates(buf, bytes_obtained, aType, cxt);
     1:         break;
     1:         
     1:       case nsIX509Cert::SERVER_CERT:
     1:         rv = ImportServerCertificate(buf, bytes_obtained, cxt);
     1:         break;
     1: 
     1:       case nsIX509Cert::EMAIL_CERT:
     1:         rv = ImportEmailCertificate(buf, bytes_obtained, cxt);
     1:         break;
     1:       
     1:       default:
     1:         break;
     1:     }
     1:   }
     1: 
     1:   delete [] buf;
     1:   return rv;  
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSCertificateDB::ImportPKCS12File(nsISupports *aToken, 
101111:                                      nsIFile *aFile)
     1: {
     1:   NS_ENSURE_ARG(aFile);
     1:   nsPKCS12Blob blob;
     1:   nsCOMPtr<nsIPK11Token> token = do_QueryInterface(aToken);
     1:   if (token) {
     1:     blob.SetToken(token);
     1:   }
     1:   return blob.ImportFromFile(aFile);
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSCertificateDB::ExportPKCS12File(nsISupports     *aToken, 
101111:                                      nsIFile          *aFile,
108991:                                      uint32_t          count,
     1:                                      nsIX509Cert     **certs)
     1:                                      //const PRUnichar **aCertNames)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   NS_ENSURE_ARG(aFile);
     1:   nsPKCS12Blob blob;
     1:   if (count == 0) return NS_OK;
     1:   nsCOMPtr<nsIPK11Token> localRef;
     1:   if (!aToken) {
124992:     ScopedPK11SlotInfo keySlot(PK11_GetInternalKeySlot());
     1:     NS_ASSERTION(keySlot,"Failed to get the internal key slot");
     1:     localRef = new nsPK11Token(keySlot);
     1:   }
     1:   else {
     1:     localRef = do_QueryInterface(aToken);
     1:   }
     1:   blob.SetToken(localRef);
     1:   //blob.LoadCerts(aCertNames, count);
     1:   //return blob.ExportToFile(aFile);
     1:   return blob.ExportToFile(aFile, certs, count);
     1: }
     1: 
     1: /*
     1:  * NSS Helper Routines (private to nsNSSCertificateDB)
     1:  */
     1: 
     1: #define DELIM '\001'
     1: 
     1: /*
     1:  * GetSortedNameList
     1:  *
     1:  * Converts a CERTCertList to a list of certificate names
     1:  */
     1: void
     1: nsNSSCertificateDB::getCertNames(CERTCertList *certList,
108991:                                  uint32_t      type, 
108991:                                  uint32_t     *_count,
     1:                                  PRUnichar  ***_certNames)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   CERTCertListNode *node;
108991:   uint32_t numcerts = 0, i=0;
119899:   PRUnichar **tmpArray = nullptr;
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("List of certs %d:\n", type));
     1:   for (node = CERT_LIST_HEAD(certList);
     1:        !CERT_LIST_END(node, certList);
     1:        node = CERT_LIST_NEXT(node)) {
     1:     if (getCertType(node->cert) == type) {
     1:       numcerts++;
     1:     }
     1:   }
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("num certs: %d\n", numcerts));
     1:   int nc = (numcerts == 0) ? 1 : numcerts;
     1:   tmpArray = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * nc);
     1:   if (numcerts == 0) goto finish;
     1:   for (node = CERT_LIST_HEAD(certList);
     1:        !CERT_LIST_END(node, certList);
     1:        node = CERT_LIST_NEXT(node)) {
     1:     if (getCertType(node->cert) == type) {
     1:       nsNSSCertificate pipCert(node->cert);
119899:       char *dbkey = nullptr;
119899:       char *namestr = nullptr;
     1:       nsAutoString certstr;
 90628:       pipCert.GetDbKey(&dbkey);
     1:       nsAutoString keystr = NS_ConvertASCIItoUTF16(dbkey);
     1:       PR_FREEIF(dbkey);
     1:       if (type == nsIX509Cert::EMAIL_CERT) {
     1:         namestr = node->cert->emailAddr;
     1:       } else {
     1:         namestr = node->cert->nickname;
     1:         if (namestr) {
     1:           char *sc = strchr(namestr, ':');
     1:           if (sc) *sc = DELIM;
     1:         }
     1:       }
 31636:       nsAutoString certname = NS_ConvertASCIItoUTF16(namestr ? namestr : "");
     1:       certstr.Append(PRUnichar(DELIM));
     1:       certstr += certname;
     1:       certstr.Append(PRUnichar(DELIM));
     1:       certstr += keystr;
     1:       tmpArray[i++] = ToNewUnicode(certstr);
     1:     }
     1:   }
     1: finish:
     1:   *_count = numcerts;
     1:   *_certNames = tmpArray;
     1: }
     1: 
     1: /* nsIX509Cert getDefaultEmailEncryptionCert (); */
     1: NS_IMETHODIMP
     1: nsNSSCertificateDB::FindEmailEncryptionCert(const nsAString &aNickname, nsIX509Cert **_retval)
     1: {
124992:   NS_ENSURE_ARG_POINTER(_retval);
124992:   *_retval = nullptr;
     1: 
     1:   if (aNickname.IsEmpty())
     1:     return NS_OK;
     1: 
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
119899:   char *asciiname = nullptr;
     1:   NS_ConvertUTF16toUTF8 aUtf8Nickname(aNickname);
  3233:   asciiname = const_cast<char*>(aUtf8Nickname.get());
     1: 
     1:   /* Find a good cert in the user's database */
124992:   ScopedCERTCertificate cert;
     1:   cert = CERT_FindUserCertByUsage(CERT_GetDefaultCertDB(), asciiname, 
 80486:            certUsageEmailRecipient, true, ctx);
124992:   if (!cert) {
124992:     return NS_OK;
124992:   }
124544: 
124992:   nsCOMPtr<nsIX509Cert> nssCert = nsNSSCertificate::Create(cert);
124544:   if (!nssCert) {
124992:     return NS_ERROR_OUT_OF_MEMORY;
124538:   }
124992:   nssCert.forget(_retval);
124992:   return NS_OK;
     1: }
     1: 
     1: /* nsIX509Cert getDefaultEmailSigningCert (); */
     1: NS_IMETHODIMP
     1: nsNSSCertificateDB::FindEmailSigningCert(const nsAString &aNickname, nsIX509Cert **_retval)
     1: {
124992:   NS_ENSURE_ARG_POINTER(_retval);
124992:   *_retval = nullptr;
     1: 
     1:   if (aNickname.IsEmpty())
     1:     return NS_OK;
     1: 
     1:   nsNSSShutDownPreventionLock locker;
124992:   ScopedCERTCertificate cert;
     1:   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
119899:   char *asciiname = nullptr;
     1:   NS_ConvertUTF16toUTF8 aUtf8Nickname(aNickname);
  3233:   asciiname = const_cast<char*>(aUtf8Nickname.get());
     1: 
     1:   /* Find a good cert in the user's database */
     1:   cert = CERT_FindUserCertByUsage(CERT_GetDefaultCertDB(), asciiname, 
 80486:            certUsageEmailSigner, true, ctx);
124992:   if (!cert) {
124992:     return NS_OK;
124992:   }
124544: 
124992:   nsCOMPtr<nsIX509Cert> nssCert = nsNSSCertificate::Create(cert);
124544:   if (!nssCert) {
124992:     return NS_ERROR_OUT_OF_MEMORY;
124538:   }
124992:   nssCert.forget(_retval);
124992:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificateDB::FindCertByEmailAddress(nsISupports *aToken, const char *aEmailAddress, nsIX509Cert **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   
124992:   ScopedCERTCertList certlist(
124992:       PK11_FindCertsFromEmailAddress(aEmailAddress, nullptr));
     1:   if (!certlist)
     1:     return NS_ERROR_FAILURE;  
     1: 
 72609:   // certlist now contains certificates with the right email address,
 72609:   // but they might not have the correct usage or might even be invalid
 72609: 
 72609:   if (CERT_LIST_END(CERT_LIST_HEAD(certlist), certlist))
 72609:     return NS_ERROR_FAILURE; // no certs found
 72609: 
 72609:   CERTCertListNode *node;
 72609:   // search for a valid certificate
 72609:   for (node = CERT_LIST_HEAD(certlist);
 72609:        !CERT_LIST_END(node, certlist);
 72609:        node = CERT_LIST_NEXT(node)) {
 72609: 
141170: #ifndef NSS_NO_LIBPKIX
140656:     if (!nsNSSComponent::globalConstFlagUsePKIXVerification) {
141170: #endif
140656:       if (CERT_VerifyCert(CERT_GetDefaultCertDB(), node->cert,
140656:           true, certUsageEmailRecipient, PR_Now(), nullptr, nullptr) == SECSuccess) {
140656:         // found a valid certificate
 72609:         break;
 72609:       }
141170: #ifndef NSS_NO_LIBPKIX
 72609:     }
140656:     else {
141170:       nsCOMPtr<nsINSSComponent> inss = do_GetService(kNSSComponentCID, &nsrv);
141170:       if (!inss)
141170:         return nsrv;
141170:       RefPtr<nsCERTValInParamWrapper> survivingParams;
141170:       nsresult nsrv = inss->GetDefaultCERTValInParam(survivingParams);
141170:       if (NS_FAILED(nsrv))
141170:         return nsrv;
140656:       CERTValOutParam cvout[1];
140656:       cvout[0].type = cert_po_end;
140656:       if (CERT_PKIXVerifyCert(node->cert, certificateUsageEmailRecipient,
140656:                               survivingParams->GetRawPointerForNSS(),
140656:                               cvout, nullptr)
140656:           == SECSuccess) {
140656:         // found a valid certificate
140656:         break;
140656:       }
140656:     }
141170: #endif
140656:   }
 72609: 
 72609:   if (CERT_LIST_END(node, certlist)) {
 72609:     // no valid cert found
     1:     return NS_ERROR_FAILURE;
 72609:   }
     1: 
 72609:   // node now contains the first valid certificate with correct usage 
 72609:   nsNSSCertificate *nssCert = nsNSSCertificate::Create(node->cert);
     1:   if (!nssCert)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   NS_ADDREF(nssCert);
  3233:   *_retval = static_cast<nsIX509Cert*>(nssCert);
     1:   return NS_OK;
     1: }
     1: 
     1: /* nsIX509Cert constructX509FromBase64 (in string base64); */
     1: NS_IMETHODIMP
 63978: nsNSSCertificateDB::ConstructX509FromBase64(const char *base64,
 63978:                                             nsIX509Cert **_retval)
     1: {
 63978:   NS_ENSURE_ARG_POINTER(_retval);
 63978: 
 63978:   // sure would be nice to have a smart pointer class for PL_ allocations
 63978:   // unfortunately, we cannot distinguish out-of-memory from bad-input here
108991:   uint32_t len = PL_strlen(base64);
119899:   char *certDER = PL_Base64Decode(base64, len, nullptr);
 63978:   if (!certDER)
 63978:     return NS_ERROR_ILLEGAL_VALUE;
 63978:   if (!*certDER) {
 63978:     PL_strfree(certDER);
 63978:     return NS_ERROR_ILLEGAL_VALUE;
 63978:   }
 63978: 
 63978:   // If we get to this point, we know we had well-formed base64 input;
 63978:   // therefore the input string cannot have been less than two
 63978:   // characters long.  Compute the unpadded length of the decoded data.
108991:   uint32_t lengthDER = (len * 3) / 4;
 63978:   if (base64[len-1] == '=') {
 63978:     lengthDER--;
 63978:     if (base64[len-2] == '=')
 63978:       lengthDER--;
     1:   }
     1: 
     1:   nsNSSShutDownPreventionLock locker;
     1:   SECItem secitem_cert;
     1:   secitem_cert.type = siDERCertBuffer;
     1:   secitem_cert.data = (unsigned char*)certDER;
     1:   secitem_cert.len = lengthDER;
     1: 
124992:   ScopedCERTCertificate cert;
124992:   cert =
 63978:     CERT_NewTempCertificate(CERT_GetDefaultCertDB(), &secitem_cert,
106838:                             nullptr, false, true);
 63978:   PL_strfree(certDER);
     1: 
 63978:   if (!cert)
 63978:     return (PORT_GetError() == SEC_ERROR_NO_MEMORY)
 63978:       ? NS_ERROR_OUT_OF_MEMORY : NS_ERROR_FAILURE;
 63978: 
124992:   nsCOMPtr<nsIX509Cert> nssCert = nsNSSCertificate::Create(cert);
124992:   if (!nssCert) {
 63978:     return NS_ERROR_OUT_OF_MEMORY;
124992:   }
124992:   nssCert.forget(_retval);
124992:   return NS_OK;
     1: }
     1: 
 15320: void
 15320: nsNSSCertificateDB::get_default_nickname(CERTCertificate *cert, 
 15320:                                          nsIInterfaceRequestor* ctx,
 15320:                                          nsCString &nickname)
 15320: {
 15320:   nickname.Truncate();
     1: 
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv;
     1:   CK_OBJECT_HANDLE keyHandle;
     1: 
     1:   CERTCertDBHandle *defaultcertdb = CERT_GetDefaultCertDB();
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
 15320:   if (NS_FAILED(rv))
 15320:     return;
     1: 
110974:   nsAutoCString username;
 15320:   char *temp_un = CERT_GetCommonName(&cert->subject);
 15320:   if (temp_un) {
 15320:     username = temp_un;
 15320:     PORT_Free(temp_un);
106838:     temp_un = nullptr;
 15320:   }
     1: 
110974:   nsAutoCString caname;
 15320:   char *temp_ca = CERT_GetOrgName(&cert->issuer);
 15320:   if (temp_ca) {
 15320:     caname = temp_ca;
 15320:     PORT_Free(temp_ca);
106838:     temp_ca = nullptr;
 15320:   }
     1: 
 15320:   nsAutoString tmpNickFmt;
 15320:   nssComponent->GetPIPNSSBundleString("nick_template", tmpNickFmt);
 15320:   NS_ConvertUTF16toUTF8 nickFmt(tmpNickFmt);
     1: 
110974:   nsAutoCString baseName;
 15320:   char *temp_nn = PR_smprintf(nickFmt.get(), username.get(), caname.get());
 15320:   if (!temp_nn) {
 15320:     return;
 15320:   } else {
 15320:     baseName = temp_nn;
 15320:     PR_smprintf_free(temp_nn);
106838:     temp_nn = nullptr;
 15320:   }
     1: 
 15320:   nickname = baseName;
     1: 
     1:   /*
     1:    * We need to see if the private key exists on a token, if it does
     1:    * then we need to check for nicknames that already exist on the smart
     1:    * card.
     1:    */
124992:   ScopedPK11SlotInfo slot(PK11_KeyForCertExists(cert, &keyHandle, ctx));
 15320:   if (!slot)
 15320:     return;
 15320: 
 15320:   if (!PK11_IsInternal(slot)) {
 15320:     char *tmp = PR_smprintf("%s:%s", PK11_GetTokenName(slot), baseName.get());
 15320:     if (!tmp) {
 15320:       nickname.Truncate();
 15320:       return;
     1:     }
 15320:     baseName = tmp;
 15320:     PR_smprintf_free(tmp);
 15320: 
 15320:     nickname = baseName;
     1:   }
     1: 
 15320:   int count = 1;
 15320:   while (true) {
 15320:     if ( count > 1 ) {
 15320:       char *tmp = PR_smprintf("%s #%d", baseName.get(), count);
 15320:       if (!tmp) {
 15320:         nickname.Truncate();
 15320:         return;
 15320:       }
 15320:       nickname = tmp;
 15320:       PR_smprintf_free(tmp);
 15320:     }
 15320: 
124992:     ScopedCERTCertificate dummycert;
     1: 
     1:     if (PK11_IsInternal(slot)) {
     1:       /* look up the nickname to make sure it isn't in use already */
 15320:       dummycert = CERT_FindCertByNickname(defaultcertdb, nickname.get());
     1: 
     1:     } else {
     1:       /*
     1:        * Check the cert against others that already live on the smart 
     1:        * card.
     1:        */
 15320:       dummycert = PK11_FindCertFromNickname(nickname.get(), ctx);
119899:       if (dummycert) {
     1: 	/*
     1: 	 * Make sure the subject names are different.
     1: 	 */ 
     1: 	if (CERT_CompareName(&cert->subject, &dummycert->subject) == SECEqual)
     1: 	{
     1: 	  /*
     1: 	   * There is another certificate with the same nickname and
     1: 	   * the same subject name on the smart card, so let's use this
     1: 	   * nickname.
     1: 	   */
119899: 	  dummycert = nullptr;
     1: 	}
     1:       }
     1:     }
 15320:     if (!dummycert) 
 15320:       break;
     1:     
     1:     count++;
     1:   }
     1: }
     1: 
     1: NS_IMETHODIMP nsNSSCertificateDB::AddCertFromBase64(const char *aBase64, const char *aTrust, const char *aName)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aBase64);
     1:   nsCOMPtr <nsIX509Cert> newCert;
     1: 
     1:   nsNSSCertTrust trust;
     1: 
     1:   // need to calculate the trust bits from the aTrust string.
106860:   SECStatus stat = CERT_DecodeTrustString(trust.GetTrust(),
106860:     /* this is const, but not declared that way */(char *) aTrust);
106860:   NS_ENSURE_STATE(stat == SECSuccess); // if bad trust passed in, return error.
     1: 
     1: 
106860:   nsresult rv = ConstructX509FromBase64(aBase64, getter_AddRefs(newCert));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   SECItem der;
108991:   rv = newCert->GetRawDER(&der.len, (uint8_t **)&der.data);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Creating temp cert\n"));
     1:   CERTCertDBHandle *certdb = CERT_GetDefaultCertDB();
124992:   ScopedCERTCertificate tmpCert(CERT_FindCertByDERCert(certdb, &der));
     1:   if (!tmpCert) 
     1:     tmpCert = CERT_NewTempCertificate(certdb, &der,
106838:                                       nullptr, false, true);
     1:   nsMemory::Free(der.data);
106838:   der.data = nullptr;
     1:   der.len = 0;
     1: 
     1:   if (!tmpCert) {
 43756:     NS_ERROR("Couldn't create cert from DER blob");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   if (tmpCert->isperm) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsXPIDLCString nickname;
     1:   nickname.Adopt(CERT_MakeCANickname(tmpCert));
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Created nick \"%s\"\n", nickname.get()));
     1: 
121609:   SECStatus srv = __CERT_AddTempCertToPerm(tmpCert,
  3233:                                            const_cast<char*>(nickname.get()),
     1:                                            trust.GetTrust());
     1: 
     1: 
     1:   return (srv == SECSuccess) ? NS_OK : NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
124994: nsNSSCertificateDB::AddCert(const nsACString & aCertDER, const char *aTrust,
124994:                             const char *aName)
124994: {
124994:   nsCString base64;
124994:   nsresult rv = Base64Encode(aCertDER, base64);
124994:   NS_ENSURE_SUCCESS(rv, rv);
124994:   return AddCertFromBase64(base64.get(), aTrust, aName);
124994: }
124994: 
124994: NS_IMETHODIMP 
     1: nsNSSCertificateDB::GetCerts(nsIX509CertList **_retval)
     1: {
     1:   CERTCertList *certList;
     1: 
     1:   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
     1:   nsCOMPtr<nsIX509CertList> nssCertList;
     1:   certList = PK11_ListCerts(PK11CertListUnique, ctx);
     1: 
119899:   // nsNSSCertList 1) adopts certList, and 2) handles the nullptr case fine.
     1:   // (returns an empty list) 
 80486:   nssCertList = new nsNSSCertList(certList, true);
     1: 
     1:   *_retval = nssCertList;
     1:   NS_ADDREF(*_retval);
     1:   return NS_OK;
     1: }
125910: 
125910: NS_IMETHODIMP
125910: nsNSSCertificateDB::GetRecentBadCerts(bool isPrivate, nsIRecentBadCerts** result)
125910: {
125914:   MutexAutoLock lock(mBadCertsLock);
125910:   if (isPrivate) {
125910:     if (!mPrivateRecentBadCerts) {
125910:       mPrivateRecentBadCerts = new nsRecentBadCerts;
125910:     }
125910:     NS_ADDREF(*result = mPrivateRecentBadCerts);
125910:   } else {
125910:     if (!mPublicRecentBadCerts) {
125910:       mPublicRecentBadCerts = new nsRecentBadCerts;
125910:     }
125910:     NS_ADDREF(*result = mPublicRecentBadCerts);
125910:   }
125910:   return NS_OK;
125910: }
