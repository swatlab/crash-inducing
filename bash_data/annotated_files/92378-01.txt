47525: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
47525:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
47525:  *
47525:  * ***** BEGIN LICENSE BLOCK *****
47525:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
47525:  *
47525:  * The contents of this file are subject to the Mozilla Public License Version
47525:  * 1.1 (the "License"); you may not use this file except in compliance with
47525:  * the License. You may obtain a copy of the License at
47525:  * http://www.mozilla.org/MPL/
47525:  *
47525:  * Software distributed under the License is distributed on an "AS IS" basis,
47525:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
47525:  * for the specific language governing rights and limitations under the
47525:  * License.
47525:  *
47525:  * The Original Code is mozilla.org code, released
47525:  * June 24, 2010.
47525:  *
47525:  * The Initial Developer of the Original Code is
47525:  *    The Mozilla Foundation
47525:  *
47525:  * Contributor(s):
47525:  *    Andreas Gal <gal@mozilla.com>
47525:  *
47525:  * Alternatively, the contents of this file may be used under the terms of
47525:  * either of the GNU General Public License Version 2 or later (the "GPL"),
47525:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
47525:  * in which case the provisions of the GPL or the LGPL are applicable instead
47525:  * of those above. If you wish to allow use of your version of this file only
47525:  * under the terms of either the GPL or the LGPL, and not to allow others to
47525:  * use your version of this file under the terms of the MPL, indicate your
47525:  * decision by deleting the provisions above and replace them with the notice
47525:  * and other provisions required by the GPL or the LGPL. If you do not delete
47525:  * the provisions above, a recipient may use your version of this file under
47525:  * the terms of any one of the MPL, the GPL or the LGPL.
47525:  *
47525:  * ***** END LICENSE BLOCK ***** */
47525: 
47525: #include "WrapperFactory.h"
47574: #include "CrossOriginWrapper.h"
47574: #include "FilteringWrapper.h"
47574: #include "XrayWrapper.h"
47525: #include "AccessCheck.h"
55628: #include "XPCWrapper.h"
47525: 
47574: #include "xpcprivate.h"
80072: #include "dombindings.h"
80384: #include "XPCMaps.h"
47574: 
87284: #include "jsfriendapi.h"
86985: 
79386: using namespace js;
79386: 
47525: namespace xpc {
47525: 
47574: // When chrome pulls a naked property across the membrane using
47574: // .wrappedJSObject, we want it to cross the membrane into the
47574: // chrome compartment without automatically being wrapped into an
47574: // X-ray wrapper. We achieve this by wrapping it into a special
47574: // transparent wrapper in the origin (non-chrome) compartment. When
47574: // an object with that special wrapper applied crosses into chrome,
47574: // we know to not apply an X-ray wrapper.
79386: Wrapper WaiveXrayWrapperWrapper(WrapperFactory::WAIVE_XRAY_WRAPPER_FLAG);
47574: 
61453: // Objects that haven't been explicitly waived, but have been exposed
61453: // to chrome don't want a CrossOriginWrapper, since that deeply-waives
61453: // but need the transparent behavior of a CrossOriginWrapper. The
61453: // NoWaiverWrapper is like a CrossOriginWrapper that can also hand out
61453: // XrayWrappers as return values.
61453: NoWaiverWrapper NoWaiverWrapper::singleton(0);
61453: 
47574: // When objects for which we waived the X-ray wrapper cross into
47574: // chrome, we wrap them into a special cross-compartment wrapper
47574: // that transitively extends the waiver to all properties we get
47574: // off it.
55691: CrossOriginWrapper CrossOriginWrapper::singleton(0);
55691: 
55691: static JSObject *
56105: GetCurrentOuter(JSContext *cx, JSObject *obj)
56105: {
79734:     obj = JS_ObjectToOuterObject(cx, obj);
92378:     if (!obj)
92378:         return NULL;
92378: 
79734:     if (IsWrapper(obj) && !js::GetObjectClass(obj)->ext.innerObject) {
79734:         obj = UnwrapObject(obj);
79734:         NS_ASSERTION(js::GetObjectClass(obj)->ext.innerObject,
56105:                      "weird object, expecting an outer window proxy");
56105:     }
56105: 
56105:     return obj;
56105: }
56105: 
47574: JSObject *
60580: WrapperFactory::WaiveXray(JSContext *cx, JSObject *obj)
60580: {
79734:     obj = UnwrapObject(obj);
61061: 
60580:     // We have to make sure that if we're wrapping an outer window, that
60580:     // the .wrappedJSObject also wraps the outer window.
60580:     obj = GetCurrentOuter(cx, obj);
60580: 
60580:     {
60580:         // See if we already have a waiver wrapper for this object.
60580:         CompartmentPrivate *priv =
91250:             (CompartmentPrivate *)JS_GetCompartmentPrivate(js::GetObjectCompartment(obj));
60580:         JSObject *wobj = nsnull;
89966:         if (priv && priv->waiverWrapperMap) {
60580:             wobj = priv->waiverWrapperMap->Find(obj);
89966:             xpc_UnmarkGrayObject(wobj);
89966:         }
60580: 
60580:         // No wrapper yet, make one.
60580:         if (!wobj) {
79734:             JSObject *proto = js::GetObjectProto(obj);
60580:             if (proto && !(proto = WaiveXray(cx, proto)))
60580:                 return nsnull;
60580: 
61046:             JSAutoEnterCompartment ac;
74424:             if (!ac.enter(cx, obj) || !JS_WrapObject(cx, &proto))
61046:                 return nsnull;
79386:             wobj = Wrapper::New(cx, obj, proto, JS_GetGlobalForObject(cx, obj),
68955:                                 &WaiveXrayWrapperWrapper);
60580:             if (!wobj)
60580:                 return nsnull;
60580: 
60580:             // Add the new wrapper so we find it next time.
60580:             if (priv) {
60580:                 if (!priv->waiverWrapperMap) {
60580:                     priv->waiverWrapperMap = JSObject2JSObjectMap::newMap(XPC_WRAPPER_MAP_SIZE);
60580:                     if (!priv->waiverWrapperMap)
60580:                         return nsnull;
60580:                 }
60580:                 if (!priv->waiverWrapperMap->Add(obj, wobj))
60580:                     return nsnull;
60580:             }
60580:         }
60580: 
60580:         obj = wobj;
60580:     }
60580: 
60580:     return obj;
60580: }
60580: 
71303: // DoubleWrap is called from PrepareForWrapping to maintain the state that
71303: // we're supposed to waive Xray wrappers for the given on. On entrance, it
71303: // expects |cx->compartment != obj->compartment()|. The returned object will
71303: // be in the same compartment as |obj|.
60580: JSObject *
91237: WrapperFactory::DoubleWrap(JSContext *cx, JSObject *obj, unsigned flags)
60580: {
60580:     if (flags & WrapperFactory::WAIVE_XRAY_WRAPPER_FLAG) {
61061:         JSAutoEnterCompartment ac;
61061:         if (!ac.enter(cx, obj))
61061:             return nsnull;
61061: 
60580:         return WaiveXray(cx, obj);
60580:     }
60580:     return obj;
60580: }
60580: 
60580: JSObject *
91237: WrapperFactory::PrepareForWrapping(JSContext *cx, JSObject *scope, JSObject *obj, unsigned flags)
55628: {
55691:     // Don't unwrap an outer window, just double wrap it if needed.
79734:     if (js::GetObjectClass(obj)->ext.innerObject)
55691:         return DoubleWrap(cx, obj, flags);
55691: 
55628:     // Here are the rules for wrapping:
55628:     // We should never get a proxy here (the JS engine unwraps those for us).
79734:     JS_ASSERT(!IsWrapper(obj));
55628: 
55628:     // As soon as an object is wrapped in a security wrapper, it morphs to be
55628:     // a fat wrapper. (see also: bug XXX).
55628:     if (IS_SLIM_WRAPPER(obj) && !MorphSlimWrapper(cx, obj))
55628:         return nsnull;
55628: 
55628:     // We only hand out outer objects to script.
56106:     obj = GetCurrentOuter(cx, obj);
92378:     if (!obj)
92378:         return nsnull;
92378: 
79734:     if (js::GetObjectClass(obj)->ext.innerObject)
56105:         return DoubleWrap(cx, obj, flags);
55628: 
55628:     // Now, our object is ready to be wrapped, but several objects (notably
55628:     // nsJSIIDs) have a wrapper per scope. If we are about to wrap one of
55628:     // those objects in a security wrapper, then we need to hand back the
55689:     // wrapper for the new scope instead. Also, global objects don't move
55689:     // between scopes so for those we also want to return the wrapper. So...
79734:     if (!IS_WN_WRAPPER(obj) || !js::GetObjectParent(obj))
55691:         return DoubleWrap(cx, obj, flags);
55628: 
55628:     XPCWrappedNative *wn = static_cast<XPCWrappedNative *>(xpc_GetJSPrivate(obj));
55628: 
55947:     // If the object doesn't have classinfo we want to return the same
55947:     // XPCWrappedNative so that we keep the same set of interfaces.
55947:     if (!wn->GetClassInfo())
55947:         return DoubleWrap(cx, obj, flags);
55947: 
62405:     JSAutoEnterCompartment ac;
62405:     if (!ac.enter(cx, obj))
62405:         return nsnull;
55628:     XPCCallContext ccx(JS_CALLER, cx, obj);
62582: 
62582:     {
55628:         if (NATIVE_HAS_FLAG(&ccx, WantPreCreate)) {
55628:             // We have a precreate hook. This object might enforce that we only
55628:             // ever create JS object for it.
55628:             JSObject *originalScope = scope;
55628:             nsresult rv = wn->GetScriptableInfo()->GetCallback()->
55628:                 PreCreate(wn->Native(), cx, scope, &scope);
55691:             NS_ENSURE_SUCCESS(rv, DoubleWrap(cx, obj, flags));
55628: 
55628:             // If the handed back scope differs from the passed-in scope and is in
55628:             // a separate compartment, then this object is explicitly requesting
55628:             // that we don't create a second JS object for it: create a security
55628:             // wrapper.
79734:             if (js::GetObjectCompartment(originalScope) != js::GetObjectCompartment(scope))
55691:                 return DoubleWrap(cx, obj, flags);
55628: 
55628:             // Note: this penalizes objects that only have one wrapper, but are
55628:             // being accessed across compartments. We would really prefer to
55628:             // replace the above code with a test that says "do you only have one
55628:             // wrapper?"
55628:         }
62405:     }
55628: 
56818:     // NB: Passing a holder here inhibits slim wrappers under
56818:     // WrapNativeToJSVal.
56818:     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
62582: 
62582:     // This public WrapNativeToJSVal API enters the compartment of 'scope'
62582:     // so we don't have to.
55628:     jsval v;
55628:     nsresult rv =
55628:         nsXPConnect::FastGetXPConnect()->WrapNativeToJSVal(cx, scope, wn->Native(), nsnull,
80486:                                                            &NS_GET_IID(nsISupports), false,
56818:                                                            &v, getter_AddRefs(holder));
56818:     if (NS_SUCCEEDED(rv)) {
55691:         obj = JSVAL_TO_OBJECT(v);
56818:         NS_ASSERTION(IS_WN_WRAPPER(obj), "bad object");
56818: 
56818:         XPCWrappedNative *newwn = static_cast<XPCWrappedNative *>(xpc_GetJSPrivate(obj));
57182:         if (newwn->GetSet()->GetInterfaceCount() < wn->GetSet()->GetInterfaceCount())
56818:             newwn->SetSet(wn->GetSet());
56818:     }
56818: 
55691:     return DoubleWrap(cx, obj, flags);
55628: }
55628: 
70911: static XPCWrappedNative *
70911: GetWrappedNative(JSContext *cx, JSObject *obj)
70911: {
79734:     obj = JS_ObjectToInnerObject(cx, obj);
70911:     return IS_WN_WRAPPER(obj)
79734:            ? static_cast<XPCWrappedNative *>(js::GetObjectPrivate(obj))
70911:            : nsnull;
70911: }
70911: 
80072: static bool
80072: CanXray(JSObject *obj, bool *proxy)
80072: {
80072:     if (IS_WN_WRAPPER(obj) || js::GetObjectClass(obj)->ext.innerObject) {
80072:         *proxy = false;
80072:         return true;
80072:     }
80092:     return (*proxy = mozilla::dom::binding::instanceIsProxy(obj));
80072: }
80072: 
55628: JSObject *
55580: WrapperFactory::Rewrap(JSContext *cx, JSObject *obj, JSObject *wrappedProto, JSObject *parent,
91237:                        unsigned flags)
47525: {
79734:     NS_ASSERTION(!IsWrapper(obj) ||
79734:                  GetProxyHandler(obj) == &WaiveXrayWrapperWrapper ||
79734:                  js::GetObjectClass(obj)->ext.innerObject,
54404:                  "wrapped object passed to rewrap");
89430:     NS_ASSERTION(JS_GetClass(obj) != &XrayUtils::HolderClass, "trying to wrap a holder");
47574: 
79734:     JSCompartment *origin = js::GetObjectCompartment(obj);
87284:     JSCompartment *target = js::GetContextCompartment(cx);
55599:     JSObject *xrayHolder = nsnull;
47574: 
79386:     Wrapper *wrapper;
78158:     CompartmentPrivate *targetdata =
91250:         static_cast<CompartmentPrivate *>(JS_GetCompartmentPrivate(target));
47574:     if (AccessCheck::isChrome(target)) {
68955:         if (AccessCheck::isChrome(origin)) {
79386:             wrapper = &CrossCompartmentWrapper::singleton;
68955:         } else {
68955:             bool isSystem;
68955:             {
68955:                 JSAutoEnterCompartment ac;
68955:                 if (!ac.enter(cx, obj))
68955:                     return nsnull;
68955:                 JSObject *globalObj = JS_GetGlobalForObject(cx, obj);
68955:                 JS_ASSERT(globalObj);
68955:                 isSystem = JS_IsSystemObject(cx, globalObj);
68955:             }
68955: 
68955:             if (isSystem) {
79386:                 wrapper = &CrossCompartmentWrapper::singleton;
55591:             } else if (flags & WAIVE_XRAY_WRAPPER_FLAG) {
47574:                 // If we waived the X-ray wrapper for this object, wrap it into a
47574:                 // special wrapper to transitively maintain the X-ray waiver.
55691:                 wrapper = &CrossOriginWrapper::singleton;
47574:             } else {
47574:                 // Native objects must be wrapped into an X-ray wrapper.
80072:                 bool proxy;
80072:                 if (CanXray(obj, &proxy)) {
80072:                     if (proxy) {
80072:                         wrapper = &XrayProxy::singleton;
80072:                     } else {
80203:                         typedef XrayWrapper<CrossCompartmentSecurityWrapper> Xray;
55582:                         wrapper = &Xray::singleton;
55599:                         xrayHolder = Xray::createHolder(cx, obj, parent);
55599:                         if (!xrayHolder)
55599:                             return nsnull;
80072:                     }
55582:                 } else {
61453:                     wrapper = &NoWaiverWrapper::singleton;
55582:                 }
47525:             }
68955:         }
47574:     } else if (AccessCheck::isChrome(origin)) {
79734:         JSFunction *fun = JS_GetObjectFunction(obj);
79734:         if (fun) {
64210:             if (JS_IsBuiltinEvalFunction(fun) || JS_IsBuiltinFunctionConstructor(fun)) {
61448:                 JS_ReportError(cx, "Not allowed to access chrome eval or Function from content");
61448:                 return nsnull;
61448:             }
61448:         }
69850: 
69850:         XPCWrappedNative *wn;
70911:         if (targetdata &&
70911:             (wn = GetWrappedNative(cx, obj)) &&
70911:             wn->HasProto() && wn->GetProto()->ClassIsDOMObject()) {
80203:             typedef XrayWrapper<CrossCompartmentSecurityWrapper> Xray;
69850:             wrapper = &FilteringWrapper<Xray,
69850:                                         CrossOriginAccessiblePropertiesOnly>::singleton;
69850:             xrayHolder = Xray::createHolder(cx, obj, parent);
69850:             if (!xrayHolder)
69850:                 return nsnull;
69850:         } else {
80203:             wrapper = &FilteringWrapper<CrossCompartmentSecurityWrapper,
55700:                                         ExposedPropertiesOnly>::singleton;
69850:         }
55700:     } else if (AccessCheck::isSameOrigin(origin, target)) {
55700:         // Same origin we use a transparent wrapper, unless the compartment asks
55700:         // for an Xray or the wrapper needs a SOW.
80072:         bool proxy;
47574:         if (AccessCheck::needsSystemOnlyWrapper(obj)) {
80203:             wrapper = &FilteringWrapper<CrossCompartmentSecurityWrapper,
47574:                                         OnlyIfSubjectIsSystem>::singleton;
80072:         } else if (targetdata && targetdata->wantXrays && CanXray(obj, &proxy)) {
80072:             if (proxy) {
80072:                 wrapper = &XrayProxy::singleton;
80072:             } else {
79386:                 typedef XrayWrapper<CrossCompartmentWrapper> Xray;
55675:                 wrapper = &Xray::singleton;
55675:                 xrayHolder = Xray::createHolder(cx, obj, parent);
55675:                 if (!xrayHolder)
55675:                     return nsnull;
80072:             }
55675:         } else {
79386:             wrapper = &CrossCompartmentWrapper::singleton;
55675:         }
47574:     } else {
55700:         NS_ASSERTION(!AccessCheck::needsSystemOnlyWrapper(obj),
55700:                      "bad object exposed across origins");
55700: 
47574:         // Cross origin we want to disallow scripting and limit access to
47574:         // a predefined set of properties. XrayWrapper adds a property
47574:         // (.wrappedJSObject) which allows bypassing the XrayWrapper, but
47574:         // we filter out access to that property.
80072:         bool proxy;
80072:         if (!CanXray(obj, &proxy)) {
80203:             wrapper = &FilteringWrapper<CrossCompartmentSecurityWrapper,
55582:                                         CrossOriginAccessiblePropertiesOnly>::singleton;
55582:         } else {
80072:             if (proxy) {
80091:                 wrapper = &FilteringWrapper<XrayProxy,
80091:                                             CrossOriginAccessiblePropertiesOnly>::singleton;
80072:             } else {
80203:                 typedef XrayWrapper<CrossCompartmentSecurityWrapper> Xray;
55617: 
55617:                 // Location objects can become same origin after navigation, so we might
55617:                 // have to grant transparent access later on.
55617:                 if (IsLocationObject(obj)) {
55617:                     wrapper = &FilteringWrapper<Xray,
55617:                         SameOriginOrCrossOriginAccessiblePropertiesOnly>::singleton;
55617:                 } else {
55598:                     wrapper = &FilteringWrapper<Xray,
47574:                         CrossOriginAccessiblePropertiesOnly>::singleton;
55617:                 }
55617: 
55599:                 xrayHolder = Xray::createHolder(cx, obj, parent);
55599:                 if (!xrayHolder)
55599:                     return nsnull;
55582:             }
47574:         }
80072:     }
55599: 
79386:     JSObject *wrapperObj = Wrapper::New(cx, obj, wrappedProto, parent, wrapper);
55599:     if (!wrapperObj || !xrayHolder)
55599:         return wrapperObj;
55622: 
80061:     js::SetProxyExtra(wrapperObj, 0, js::ObjectValue(*xrayHolder));
55599:     return wrapperObj;
47525: }
47525: 
80203: typedef FilteringWrapper<XrayWrapper<SameCompartmentSecurityWrapper>,
55617:                          SameOriginOrCrossOriginAccessiblePropertiesOnly> LW;
55617: 
55617: bool
55617: WrapperFactory::IsLocationObject(JSObject *obj)
55617: {
79734:     const char *name = js::GetObjectClass(obj)->name;
55617:     return name[0] == 'L' && !strcmp(name, "Location");
47525: }
55617: 
55617: JSObject *
55617: WrapperFactory::WrapLocationObject(JSContext *cx, JSObject *obj)
55617: {
79734:     JSObject *xrayHolder = LW::createHolder(cx, obj, js::GetObjectParent(obj));
55617:     if (!xrayHolder)
60580:         return nsnull;
79734:     JSObject *wrapperObj = Wrapper::New(cx, obj, js::GetObjectProto(obj), js::GetObjectParent(obj),
56820:                                         &LW::singleton);
55617:     if (!wrapperObj)
60580:         return nsnull;
80061:     js::SetProxyExtra(wrapperObj, 0, js::ObjectValue(*xrayHolder));
55617:     return wrapperObj;
55617: }
55617: 
71303: // Call WaiveXrayAndWrap when you have a JS object that you don't want to be
71303: // wrapped in an Xray wrapper. cx->compartment is the compartment that will be
71303: // using the returned object. If the object to be wrapped is already in the
71303: // correct compartment, then this returns the unwrapped object.
55696: bool
55696: WrapperFactory::WaiveXrayAndWrap(JSContext *cx, jsval *vp)
55696: {
55815:     if (JSVAL_IS_PRIMITIVE(*vp))
55815:         return JS_WrapValue(cx, vp);
55696: 
79734:     JSObject *obj = js::UnwrapObject(JSVAL_TO_OBJECT(*vp));
71303:     obj = GetCurrentOuter(cx, obj);
86111:     if (js::IsObjectInContextCompartment(obj, cx)) {
71303:         *vp = OBJECT_TO_JSVAL(obj);
71303:         return true;
71303:     }
55696: 
60580:     obj = WaiveXray(cx, obj);
60580:     if (!obj)
55696:         return false;
58722: 
55696:     *vp = OBJECT_TO_JSVAL(obj);
55696:     return JS_WrapValue(cx, vp);
55696: }
55696: 
55700: JSObject *
55700: WrapperFactory::WrapSOWObject(JSContext *cx, JSObject *obj)
55700: {
55700:     JSObject *wrapperObj =
89826:         Wrapper::New(cx, obj, JS_GetPrototype(obj), JS_GetGlobalForObject(cx, obj),
80203:                      &FilteringWrapper<SameCompartmentSecurityWrapper,
55700:                      OnlyIfSubjectIsSystem>::singleton);
55700:     return wrapperObj;
55696: }
55700: 
55700: }
