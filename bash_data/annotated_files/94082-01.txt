    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * vim:cindent:ts=2:et:sw=2:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
49314:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  *
    1:  * This Original Code has been modified by IBM Corporation. Modifications made by IBM 
    1:  * described herein are Copyright (c) International Business Machines Corporation, 2000.
    1:  * Modifications to Mozilla code or documentation identified per MPL Section 3.3
    1:  *
    1:  * Date             Modified by     Description of modification
    1:  * 04/20/2000       IBM Corp.      OS/2 VisualAge build.
    1:  */
    1: 
    1: /* storage of the frame tree and information about it */
    1: 
    1: #include "nscore.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsStyleSet.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsStyleContext.h"
    1: #include "nsStyleChangeList.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsCOMPtr.h"
    1: #include "prthread.h"
    1: #include "plhash.h"
    1: #include "nsPlaceholderFrame.h"
 7863: #include "nsContainerFrame.h"
 7046: #include "nsBlockFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsCSSPseudoElements.h"
    1: #ifdef NS_DEBUG
    1: #include "nsIStyleRule.h"
    1: #endif
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsPresState.h"
    1: #include "nsIContent.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDocument.h"
    1: #include "nsIScrollableFrame.h"
    1: 
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMHTMLCollection.h"
    1: #include "nsIFormControl.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMHTMLFormElement.h"
    1: #include "nsIForm.h"
    1: #include "nsContentUtils.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsAutoPtr.h"
    1: #include "imgIRequest.h"
33649: #include "nsTransitionManager.h"
43790: #include "RestyleTracker.h"
79483: #include "nsAbsoluteContainingBlock.h"
    1: 
    1: #include "nsFrameManager.h"
70853: #include "nsRuleProcessorData.h"
    1: 
57448: #ifdef ACCESSIBILITY
61464: #include "nsAccessibilityService.h"
57448: #endif
57448: 
    1:   #ifdef DEBUG
    1:     //#define NOISY_DEBUG
    1:     //#define DEBUG_UNDISPLAYED_MAP
    1:   #else
    1:     #undef NOISY_DEBUG
    1:     #undef DEBUG_UNDISPLAYED_MAP
    1:   #endif
    1: 
    1:   #ifdef NOISY_DEBUG
    1:     #define NOISY_TRACE(_msg) \
    1:       printf("%s",_msg);
    1:     #define NOISY_TRACE_FRAME(_msg,_frame) \
    1:       printf("%s ",_msg); nsFrame::ListTag(stdout,_frame); printf("\n");
    1:   #else
    1:     #define NOISY_TRACE(_msg);
    1:     #define NOISY_TRACE_FRAME(_msg,_frame);
    1:   #endif
    1: 
39965: using namespace mozilla;
44166: using namespace mozilla::dom;
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: struct PlaceholderMapEntry : public PLDHashEntryHdr {
    1:   // key (the out of flow frame) can be obtained through placeholder frame
    1:   nsPlaceholderFrame *placeholderFrame;
    1: };
    1: 
79445: static bool
    1: PlaceholderMapMatchEntry(PLDHashTable *table, const PLDHashEntryHdr *hdr,
    1:                          const void *key)
    1: {
    1:   const PlaceholderMapEntry *entry =
 3233:     static_cast<const PlaceholderMapEntry*>(hdr);
    1:   NS_ASSERTION(entry->placeholderFrame->GetOutOfFlowFrame() !=
    1:                (void*)0xdddddddd,
    1:                "Dead placeholder in placeholder map");
    1:   return entry->placeholderFrame->GetOutOfFlowFrame() == key;
    1: }
    1: 
    1: static PLDHashTableOps PlaceholderMapOps = {
    1:   PL_DHashAllocTable,
    1:   PL_DHashFreeTable,
    1:   PL_DHashVoidPtrKeyStub,
    1:   PlaceholderMapMatchEntry,
    1:   PL_DHashMoveEntryStub,
    1:   PL_DHashClearEntryStub,
    1:   PL_DHashFinalizeStub,
    1:   NULL
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // XXXldb This seems too complicated for what I think it's doing, and it
    1: // should also be using pldhash rather than plhash to use less memory.
    1: 
    1: class UndisplayedNode {
    1: public:
    1:   UndisplayedNode(nsIContent* aContent, nsStyleContext* aStyle)
    1:     : mContent(aContent),
    1:       mStyle(aStyle),
    1:       mNext(nsnull)
    1:   {
    1:     MOZ_COUNT_CTOR(UndisplayedNode);
    1:   }
    1: 
    1:   NS_HIDDEN ~UndisplayedNode()
    1:   {
    1:     MOZ_COUNT_DTOR(UndisplayedNode);
21193: 
21193:     // Delete mNext iteratively to avoid blowing up the stack (bug 460461).
21193:     UndisplayedNode *cur = mNext;
21193:     while (cur) {
21193:       UndisplayedNode *next = cur->mNext;
21193:       cur->mNext = nsnull;
21193:       delete cur;
21193:       cur = next;
21193:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent>      mContent;
    1:   nsRefPtr<nsStyleContext>  mStyle;
    1:   UndisplayedNode*          mNext;
    1: };
    1: 
    1: class nsFrameManagerBase::UndisplayedMap {
    1: public:
    1:   UndisplayedMap(PRUint32 aNumBuckets = 16) NS_HIDDEN;
    1:   ~UndisplayedMap(void) NS_HIDDEN;
    1: 
    1:   NS_HIDDEN_(UndisplayedNode*) GetFirstNode(nsIContent* aParentContent);
    1: 
    1:   NS_HIDDEN_(nsresult) AddNodeFor(nsIContent* aParentContent,
    1:                                   nsIContent* aChild, nsStyleContext* aStyle);
    1: 
    1:   NS_HIDDEN_(void) RemoveNodeFor(nsIContent* aParentContent,
    1:                                  UndisplayedNode* aNode);
    1: 
    1:   NS_HIDDEN_(void) RemoveNodesFor(nsIContent* aParentContent);
    1: 
    1:   // Removes all entries from the hash table
    1:   NS_HIDDEN_(void)  Clear(void);
    1: 
    1: protected:
    1:   NS_HIDDEN_(PLHashEntry**) GetEntryFor(nsIContent* aParentContent);
    1:   NS_HIDDEN_(void)          AppendNodeFor(UndisplayedNode* aNode,
    1:                                           nsIContent* aParentContent);
    1: 
    1:   PLHashTable*  mTable;
    1:   PLHashEntry** mLastLookup;
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsFrameManager::~nsFrameManager()
    1: {
    1:   NS_ASSERTION(!mPresShell, "nsFrameManager::Destroy never called");
    1: }
    1: 
    1: nsresult
89328: nsFrameManager::Init(nsStyleSet* aStyleSet)
    1: {
89328:   if (!mPresShell) {
    1:     NS_ERROR("null pres shell");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (!aStyleSet) {
    1:     NS_ERROR("null style set");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   mStyleSet = aStyleSet;
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameManager::Destroy()
    1: {
    1:   NS_ASSERTION(mPresShell, "Frame manager already shut down.");
    1: 
    1:   // Destroy the frame hierarchy.
80486:   mPresShell->SetIgnoreFrameDestruction(true);
    1: 
    1:   // Unregister all placeholders before tearing down the frame tree
    1:   nsFrameManager::ClearPlaceholderFrameMap();
    1: 
    1:   if (mRootFrame) {
    1:     mRootFrame->Destroy();
    1:     mRootFrame = nsnull;
    1:   }
    1:   
    1:   delete mUndisplayedMap;
    1:   mUndisplayedMap = nsnull;
    1: 
    1:   mPresShell = nsnull;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Placeholder frame functions
    1: nsPlaceholderFrame*
90155: nsFrameManager::GetPlaceholderFrameFor(const nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "null param unexpected");
    1: 
    1:   if (mPlaceholderMap.ops) {
 3233:     PlaceholderMapEntry *entry = static_cast<PlaceholderMapEntry*>
 3233:                                             (PL_DHashTableOperate(const_cast<PLDHashTable*>(&mPlaceholderMap),
    1:                                 aFrame, PL_DHASH_LOOKUP));
    1:     if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
    1:       return entry->placeholderFrame;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsFrameManager::RegisterPlaceholderFrame(nsPlaceholderFrame* aPlaceholderFrame)
    1: {
    1:   NS_PRECONDITION(aPlaceholderFrame, "null param unexpected");
    1:   NS_PRECONDITION(nsGkAtoms::placeholderFrame == aPlaceholderFrame->GetType(),
    1:                   "unexpected frame type");
    1:   if (!mPlaceholderMap.ops) {
    1:     if (!PL_DHashTableInit(&mPlaceholderMap, &PlaceholderMapOps, nsnull,
    1:                            sizeof(PlaceholderMapEntry), 16)) {
    1:       mPlaceholderMap.ops = nsnull;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
 3233:   PlaceholderMapEntry *entry = static_cast<PlaceholderMapEntry*>(PL_DHashTableOperate(&mPlaceholderMap,
    1:                               aPlaceholderFrame->GetOutOfFlowFrame(),
    1:                               PL_DHASH_ADD));
    1:   if (!entry)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ASSERTION(!entry->placeholderFrame, "Registering a placeholder for a frame that already has a placeholder!");
    1:   entry->placeholderFrame = aPlaceholderFrame;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameManager::UnregisterPlaceholderFrame(nsPlaceholderFrame* aPlaceholderFrame)
    1: {
    1:   NS_PRECONDITION(aPlaceholderFrame, "null param unexpected");
    1:   NS_PRECONDITION(nsGkAtoms::placeholderFrame == aPlaceholderFrame->GetType(),
    1:                   "unexpected frame type");
    1: 
    1:   if (mPlaceholderMap.ops) {
    1:     PL_DHashTableOperate(&mPlaceholderMap,
    1:                          aPlaceholderFrame->GetOutOfFlowFrame(),
    1:                          PL_DHASH_REMOVE);
    1:   }
    1: }
    1: 
20261: static PLDHashOperator
    1: UnregisterPlaceholders(PLDHashTable* table, PLDHashEntryHdr* hdr,
    1:                        PRUint32 number, void* arg)
    1: {
 3233:   PlaceholderMapEntry* entry = static_cast<PlaceholderMapEntry*>(hdr);
    1:   entry->placeholderFrame->SetOutOfFlowFrame(nsnull);
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: void
    1: nsFrameManager::ClearPlaceholderFrameMap()
    1: {
    1:   if (mPlaceholderMap.ops) {
    1:     PL_DHashTableEnumerate(&mPlaceholderMap, UnregisterPlaceholders, nsnull);
    1:     PL_DHashTableFinish(&mPlaceholderMap);
    1:     mPlaceholderMap.ops = nsnull;
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsStyleContext*
    1: nsFrameManager::GetUndisplayedContent(nsIContent* aContent)
    1: {
    1:   if (!aContent || !mUndisplayedMap)
    1:     return nsnull;
    1: 
    1:   nsIContent* parent = aContent->GetParent();
    1:   for (UndisplayedNode* node = mUndisplayedMap->GetFirstNode(parent);
    1:          node; node = node->mNext) {
    1:     if (node->mContent == aContent)
    1:       return node->mStyle;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1:   
    1: void
    1: nsFrameManager::SetUndisplayedContent(nsIContent* aContent, 
    1:                                       nsStyleContext* aStyleContext)
    1: {
34387:   NS_PRECONDITION(!aStyleContext->GetPseudo(),
28357:                   "Should only have actual elements here");
28357: 
    1: #ifdef DEBUG_UNDISPLAYED_MAP
    1:   static int i = 0;
    1:   printf("SetUndisplayedContent(%d): p=%p \n", i++, (void *)aContent);
    1: #endif
    1: 
    1:   NS_ASSERTION(!GetUndisplayedContent(aContent),
    1:                "Already have an undisplayed context entry for aContent");
    1: 
    1:   if (! mUndisplayedMap) {
    1:     mUndisplayedMap = new UndisplayedMap;
    1:   }
    1:   nsIContent* parent = aContent->GetParent();
23523:   NS_ASSERTION(parent || (mPresShell && mPresShell->GetDocument() &&
41634:                mPresShell->GetDocument()->GetRootElement() == aContent),
41634:                "undisplayed content must have a parent, unless it's the root "
41634:                "element");
    1:   mUndisplayedMap->AddNodeFor(parent, aContent, aStyleContext);
    1: }
    1: 
    1: void
    1: nsFrameManager::ChangeUndisplayedContent(nsIContent* aContent, 
    1:                                          nsStyleContext* aStyleContext)
    1: {
    1:   NS_ASSERTION(mUndisplayedMap, "no existing undisplayed content");
    1:   
    1: #ifdef DEBUG_UNDISPLAYED_MAP
    1:    static int i = 0;
    1:    printf("ChangeUndisplayedContent(%d): p=%p \n", i++, (void *)aContent);
    1: #endif
    1: 
    1:   for (UndisplayedNode* node = mUndisplayedMap->GetFirstNode(aContent->GetParent());
    1:          node; node = node->mNext) {
    1:     if (node->mContent == aContent) {
    1:       node->mStyle = aStyleContext;
    1:       return;
    1:     }
    1:   }
    1: 
    1:   NS_NOTREACHED("no existing undisplayed content");
    1: }
    1: 
    1: void
    1: nsFrameManager::ClearUndisplayedContentIn(nsIContent* aContent,
    1:                                           nsIContent* aParentContent)
    1: {
    1: #ifdef DEBUG_UNDISPLAYED_MAP
    1:   static int i = 0;
    1:   printf("ClearUndisplayedContent(%d): content=%p parent=%p --> ", i++, (void *)aContent, (void*)aParentContent);
    1: #endif
    1:   
    1:   if (mUndisplayedMap) {
    1:     UndisplayedNode* node = mUndisplayedMap->GetFirstNode(aParentContent);
    1:     while (node) {
    1:       if (node->mContent == aContent) {
    1:         mUndisplayedMap->RemoveNodeFor(aParentContent, node);
    1: 
    1: #ifdef DEBUG_UNDISPLAYED_MAP
    1:         printf( "REMOVED!\n");
    1: #endif
    1: #ifdef DEBUG
    1:         // make sure that there are no more entries for the same content
    1:         nsStyleContext *context = GetUndisplayedContent(aContent);
    1:         NS_ASSERTION(context == nsnull, "Found more undisplayed content data after removal");
    1: #endif
    1:         return;
    1:       }
    1:       node = node->mNext;
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsFrameManager::ClearAllUndisplayedContentIn(nsIContent* aParentContent)
    1: {
    1: #ifdef DEBUG_UNDISPLAYED_MAP
    1:   static int i = 0;
    1:   printf("ClearAllUndisplayedContentIn(%d): parent=%p \n", i++, (void*)aParentContent);
    1: #endif
    1: 
    1:   if (mUndisplayedMap) {
    1:     mUndisplayedMap->RemoveNodesFor(aParentContent);
    1:   }
31228: 
31228:   // Need to look at aParentContent's content list due to XBL insertions.
31228:   // Nodes in aParentContent's content list do not have aParentContent as a
31228:   // parent, but are treated as children of aParentContent. We get access to
31228:   // the content list via GetXBLChildNodesFor and just ignore any nodes we
31228:   // don't care about.
31228:   nsINodeList* list =
80526:     aParentContent->OwnerDoc()->BindingManager()->GetXBLChildNodesFor(aParentContent);
31228:   if (list) {
31228:     PRUint32 length;
31228:     list->GetLength(&length);
31228:     for (PRUint32 i = 0; i < length; ++i) {
31228:       nsIContent* child = list->GetNodeAt(i);
31228:       if (child->GetParent() != aParentContent) {
31228:         ClearUndisplayedContentIn(child, child->GetParent());
31228:       }
31228:     }
31228:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
79483: nsresult
79483: nsFrameManager::AppendFrames(nsIFrame*       aParentFrame,
79483:                              ChildListID     aListID,
79483:                              nsFrameList&    aFrameList)
79483: {
79483:   if (aParentFrame->IsAbsoluteContainer() &&
79483:       aListID == aParentFrame->GetAbsoluteListID()) {
79483:     return aParentFrame->GetAbsoluteContainingBlock()->
79483:            AppendFrames(aParentFrame, aListID, aFrameList);
79483:   } else {
79483:     return aParentFrame->AppendFrames(aListID, aFrameList);
79483:   }
79483: }
    1: 
    1: nsresult
    1: nsFrameManager::InsertFrames(nsIFrame*       aParentFrame,
77154:                              ChildListID     aListID,
    1:                              nsIFrame*       aPrevFrame,
30941:                              nsFrameList&    aFrameList)
    1: {
 7863:   NS_PRECONDITION(!aPrevFrame || (!aPrevFrame->GetNextContinuation()
86530:                   || (aPrevFrame->GetNextContinuation()->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER))
86530:                   && !(aPrevFrame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER),
    1:                   "aPrevFrame must be the last continuation in its chain!");
    1: 
79483:   if (aParentFrame->IsAbsoluteContainer() &&
79483:       aListID == aParentFrame->GetAbsoluteListID()) {
79483:     return aParentFrame->GetAbsoluteContainingBlock()->
79483:            InsertFrames(aParentFrame, aListID, aPrevFrame, aFrameList);
79483:   } else {
77154:     return aParentFrame->InsertFrames(aListID, aPrevFrame, aFrameList);
    1:   }
79483: }
    1: 
    1: nsresult
77154: nsFrameManager::RemoveFrame(ChildListID     aListID,
94082:                             nsIFrame*       aOldFrame,
94082:                             bool            aInvalidate /* = true */)
    1: {
79445:   bool wasDestroyingFrames = mIsDestroyingFrames;
80486:   mIsDestroyingFrames = true;
22726: 
    1:   // In case the reflow doesn't invalidate anything since it just leaves
    1:   // a gap where the old frame was, we invalidate it here.  (This is
    1:   // reasonably likely to happen when removing a last child in a way
    1:   // that doesn't change the size of the parent.)
    1:   // This has to sure to invalidate the entire overflow rect; this
    1:   // is important in the presence of absolute positioning
94082:   if (aInvalidate) {
51756:     aOldFrame->InvalidateFrameSubtree();
94082:   }
    1: 
36646:   NS_ASSERTION(!aOldFrame->GetPrevContinuation() ||
36646:                // exception for nsCSSFrameConstructor::RemoveFloatingFirstLetterFrames
36646:                aOldFrame->GetType() == nsGkAtoms::textFrame,
36646:                "Must remove first continuation.");
36646:   NS_ASSERTION(!(aOldFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW &&
36646:                  GetPlaceholderFrameFor(aOldFrame)),
36646:                "Must call RemoveFrame on placeholder for out-of-flows.");
79483:   nsresult rv = NS_OK;
79483:   nsIFrame* parentFrame = aOldFrame->GetParent();
79483:   if (parentFrame->IsAbsoluteContainer() &&
79483:       aListID == parentFrame->GetAbsoluteListID()) {
79483:     parentFrame->GetAbsoluteContainingBlock()->
79483:       RemoveFrame(parentFrame, aListID, aOldFrame);
79483:   } else {
79483:     rv = parentFrame->RemoveFrame(aListID, aOldFrame);
79483:   }
22726: 
20348:   mIsDestroyingFrames = wasDestroyingFrames;
22726: 
20348:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: void
    1: nsFrameManager::NotifyDestroyingFrame(nsIFrame* aFrame)
    1: {
36646:   nsIContent* content = aFrame->GetContent();
36733:   if (content && content->GetPrimaryFrame() == aFrame) {
36646:     ClearAllUndisplayedContentIn(content);
    1:   }
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: static void
    1: DumpContext(nsIFrame* aFrame, nsStyleContext* aContext)
    1: {
    1:   if (aFrame) {
    1:     fputs("frame: ", stdout);
    1:     nsAutoString  name;
31709:     aFrame->GetFrameName(name);
    1:     fputs(NS_LossyConvertUTF16toASCII(name).get(), stdout);
 3233:     fprintf(stdout, " (%p)", static_cast<void*>(aFrame));
    1:   }
    1:   if (aContext) {
 3233:     fprintf(stdout, " style: %p ", static_cast<void*>(aContext));
    1: 
34387:     nsIAtom* pseudoTag = aContext->GetPseudo();
    1:     if (pseudoTag) {
    1:       nsAutoString  buffer;
    1:       pseudoTag->ToString(buffer);
    1:       fputs(NS_LossyConvertUTF16toASCII(buffer).get(), stdout);
    1:       fputs(" ", stdout);
    1:     }
    1:     fputs("{}\n", stdout);
    1:   }
    1: }
    1: 
    1: static void
    1: VerifySameTree(nsStyleContext* aContext1, nsStyleContext* aContext2)
    1: {
    1:   nsStyleContext* top1 = aContext1;
    1:   nsStyleContext* top2 = aContext2;
    1:   nsStyleContext* parent;
    1:   for (;;) {
    1:     parent = top1->GetParent();
    1:     if (!parent)
    1:       break;
    1:     top1 = parent;
    1:   }
    1:   for (;;) {
    1:     parent = top2->GetParent();
    1:     if (!parent)
    1:       break;
    1:     top2 = parent;
    1:   }
 6739:   NS_ASSERTION(top1 == top2,
 6739:                "Style contexts are not in the same style context tree");
    1: }
    1: 
    1: static void
    1: VerifyContextParent(nsPresContext* aPresContext, nsIFrame* aFrame, 
    1:                     nsStyleContext* aContext, nsStyleContext* aParentContext)
    1: {
    1:   // get the contexts not provided
    1:   if (!aContext) {
    1:     aContext = aFrame->GetStyleContext();
    1:   }
    1: 
    1:   if (!aParentContext) {
    1:     // Get the correct parent context from the frame
    1:     //  - if the frame is a placeholder, we get the out of flow frame's context 
    1:     //    as the parent context instead of asking the frame
    1: 
    1:     // get the parent context from the frame (indirectly)
78202:     nsIFrame* providerFrame = aFrame->GetParentStyleContextFrame();
    1:     if (providerFrame)
    1:       aParentContext = providerFrame->GetStyleContext();
    1:     // aParentContext could still be null
    1:   }
    1: 
    1:   NS_ASSERTION(aContext, "Failure to get required contexts");
    1:   nsStyleContext* actualParentContext = aContext->GetParent();
    1: 
    1:   if (aParentContext) {
    1:     if (aParentContext != actualParentContext) {
    1:       DumpContext(aFrame, aContext);
    1:       if (aContext == aParentContext) {
 6739:         NS_ERROR("Using parent's style context");
    1:       }
    1:       else {
 6739:         NS_ERROR("Wrong parent style context");
    1:         fputs("Wrong parent style context: ", stdout);
    1:         DumpContext(nsnull, actualParentContext);
    1:         fputs("should be using: ", stdout);
    1:         DumpContext(nsnull, aParentContext);
    1:         VerifySameTree(actualParentContext, aParentContext);
    1:         fputs("\n", stdout);
    1:       }
    1:     }
43327: 
    1:   }
    1:   else {
    1:     if (actualParentContext) {
 6739:       NS_ERROR("Have parent context and shouldn't");
    1:       DumpContext(aFrame, aContext);
    1:       fputs("Has parent context: ", stdout);
    1:       DumpContext(nsnull, actualParentContext);
    1:       fputs("Should be null\n\n", stdout);
    1:     }
    1:   }
43327: 
43327:   nsStyleContext* childStyleIfVisited = aContext->GetStyleIfVisited();
43364:   // Either childStyleIfVisited has aContext->GetParent()->GetStyleIfVisited()
43364:   // as the parent or it has a different rulenode from aContext _and_ has
43364:   // aContext->GetParent() as the parent.
43327:   if (childStyleIfVisited &&
43327:       !((childStyleIfVisited->GetRuleNode() != aContext->GetRuleNode() &&
43327:          childStyleIfVisited->GetParent() == aContext->GetParent()) ||
43327:         childStyleIfVisited->GetParent() ==
43362:           aContext->GetParent()->GetStyleIfVisited())) {
43327:     NS_ERROR("Visited style has wrong parent");
43327:     DumpContext(aFrame, aContext);
43327:     fputs("\n", stdout);
43327:   }
    1: }
    1: 
    1: static void
    1: VerifyStyleTree(nsPresContext* aPresContext, nsIFrame* aFrame,
    1:                 nsStyleContext* aParentContext)
    1: {
    1:   nsStyleContext*  context = aFrame->GetStyleContext();
    1:   VerifyContextParent(aPresContext, aFrame, context, nsnull);
    1: 
77153:   nsIFrame::ChildListIterator lists(aFrame);
77153:   for (; !lists.IsDone(); lists.Next()) {
77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
77153:       nsIFrame* child = childFrames.get();
93351:       if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
93351:         // only do frames that are in flow
    1:         if (nsGkAtoms::placeholderFrame == child->GetType()) { 
    1:           // placeholder: first recurse and verify the out of flow frame,
    1:           // then verify the placeholder's context
    1:           nsIFrame* outOfFlowFrame =
    1:             nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
    1: 
    1:           // recurse to out of flow frame, letting the parent context get resolved
93351:           do {
    1:             VerifyStyleTree(aPresContext, outOfFlowFrame, nsnull);
93351:           } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
    1: 
    1:           // verify placeholder using the parent frame's context as
    1:           // parent context
    1:           VerifyContextParent(aPresContext, child, nsnull, nsnull);
    1:         }
    1:         else { // regular frame
    1:           VerifyStyleTree(aPresContext, child, nsnull);
    1:         }
    1:       }
    1:     }
77153:   }
    1:   
    1:   // do additional contexts 
    1:   PRInt32 contextIndex = -1;
    1:   while (1) {
    1:     nsStyleContext* extraContext = aFrame->GetAdditionalStyleContext(++contextIndex);
    1:     if (extraContext) {
    1:       VerifyContextParent(aPresContext, aFrame, extraContext, context);
    1:     }
    1:     else {
    1:       break;
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsFrameManager::DebugVerifyStyleTree(nsIFrame* aFrame)
    1: {
    1:   if (aFrame) {
    1:     nsStyleContext* context = aFrame->GetStyleContext();
    1:     nsStyleContext* parentContext = context->GetParent();
    1:     VerifyStyleTree(GetPresContext(), aFrame, parentContext);
    1:   }
    1: }
    1: 
    1: #endif // DEBUG
    1: 
33649: // aContent must be the content for the frame in question, which may be
33649: // :before/:after content
33649: static void
33649: TryStartingTransition(nsPresContext *aPresContext, nsIContent *aContent,
33649:                       nsStyleContext *aOldStyleContext,
33649:                       nsRefPtr<nsStyleContext> *aNewStyleContext /* inout */)
33649: {
42322:   if (!aContent || !aContent->IsElement()) {
42322:     return;
42322:   }
42322: 
33649:   // Notify the transition manager, and if it starts a transition,
33649:   // it will give us back a transition-covering style rule which
33649:   // we'll use to get *another* style context.  We want to ignore
33649:   // any already-running transitions, but cover up any that we're
33649:   // currently starting with their start value so we don't start
33649:   // them again for descendants that inherit that value.
33649:   nsCOMPtr<nsIStyleRule> coverRule = 
33649:     aPresContext->TransitionManager()->StyleContextChanged(
42322:       aContent->AsElement(), aOldStyleContext, *aNewStyleContext);
33649:   if (coverRule) {
33649:     nsCOMArray<nsIStyleRule> rules;
33649:     rules.AppendObject(coverRule);
40171:     *aNewStyleContext = aPresContext->StyleSet()->
40171:                           ResolveStyleByAddingRules(*aNewStyleContext, rules);
33649:   }
33649: }
33649: 
44166: static inline Element*
44166: ElementForStyleContext(nsIContent* aParentContent,
44166:                        nsIFrame* aFrame,
44166:                        nsCSSPseudoElements::Type aPseudoType)
44166: {
44166:   // We don't expect XUL tree stuff here.
44166:   NS_PRECONDITION(aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
44166:                   aPseudoType == nsCSSPseudoElements::ePseudo_AnonBox ||
44166:                   aPseudoType < nsCSSPseudoElements::ePseudo_PseudoElementCount,
44166:                   "Unexpected pseudo");
44166:   // XXX see the comments about the various element confusion in
44166:   // ReResolveStyleContext.
44166:   if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
44166:     return aFrame->GetContent()->AsElement();
44166:   }
44166: 
44166:   if (aPseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
44166:     return nsnull;
44166:   }
44166: 
44166:   if (aPseudoType == nsCSSPseudoElements::ePseudo_firstLetter) {
44166:     NS_ASSERTION(aFrame->GetType() == nsGkAtoms::letterFrame,
44166:                  "firstLetter pseudoTag without a nsFirstLetterFrame");
44166:     nsBlockFrame* block = nsBlockFrame::GetNearestAncestorBlock(aFrame);
44166:     return block->GetContent()->AsElement();
44166:   }
44166: 
44166:   nsIContent* content = aParentContent ? aParentContent : aFrame->GetContent();
44166:   return content->AsElement();
44166: }
44166: 
75315: static nsIFrame*
75315: GetPrevContinuationWithPossiblySameStyle(nsIFrame* aFrame)
75315: {
75315:   // Account for {ib} splits when looking for "prevContinuation".  In
75315:   // particular, for the first-continuation of a part of an {ib} split we
75315:   // want to use the special prevsibling of the special prevsibling of
75315:   // aFrame, which should have the same style context as aFrame itself.
75315:   // In particular, if aFrame is the first continuation of an inline part
75315:   // of an {ib} split then its special prevsibling is a block, and the
75315:   // special prevsibling of _that_ is an inline, just like aFrame.
75315:   // Similarly, if aFrame is the first continuation of a block part of an
75315:   // {ib} split (an {ib} wrapper block), then its special prevsibling is
75315:   // an inline and the special prevsibling of that is either another {ib}
75315:   // wrapper block block or null.
75315:   nsIFrame *prevContinuation = aFrame->GetPrevContinuation();
75315:   if (!prevContinuation && (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
75315:     // We're the first continuation, so we can just get the frame
75315:     // property directly
75315:     prevContinuation = static_cast<nsIFrame*>(
75315:       aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
75315:     if (prevContinuation) {
75315:       prevContinuation = static_cast<nsIFrame*>(
75315:         prevContinuation->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
75315:     }
75315:   }
75315:   return prevContinuation;
75315: }
75315: 
    1: nsresult
40137: nsFrameManager::ReparentStyleContext(nsIFrame* aFrame)
    1: {
 7656:   if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
49314:     // Also reparent the out-of-flow and all its continuations.
 7656:     nsIFrame* outOfFlow =
 7656:       nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
 7656:     NS_ASSERTION(outOfFlow, "no out-of-flow frame");
49314:     do {
40137:       ReparentStyleContext(outOfFlow);
62664:     } while ((outOfFlow = outOfFlow->GetNextContinuation()));
 7656:   }
 7656: 
    1:   // DO NOT verify the style tree before reparenting.  The frame
    1:   // tree has already been changed, so this check would just fail.
    1:   nsStyleContext* oldContext = aFrame->GetStyleContext();
    1:   // XXXbz can oldContext really ever be null?
    1:   if (oldContext) {
    1:     nsRefPtr<nsStyleContext> newContext;
78202:     nsIFrame* providerFrame = aFrame->GetParentStyleContextFrame();
78202:     bool isChild = providerFrame && providerFrame->GetParent() == aFrame;
78202:     nsStyleContext* newParentContext = nsnull;
    1:     nsIFrame* providerChild = nsnull;
78202:     if (isChild) {
40137:       ReparentStyleContext(providerFrame);
    1:       newParentContext = providerFrame->GetStyleContext();
    1:       providerChild = providerFrame;
    1:     } else if (providerFrame) {
    1:       newParentContext = providerFrame->GetStyleContext();
    1:     } else {
    1:       NS_NOTREACHED("Reparenting something that has no usable parent? "
    1:                     "Shouldn't happen!");
    1:     }
34460:     // XXX need to do something here to produce the correct style context for
34460:     // an IB split whose first inline part is inside a first-line frame.
34460:     // Currently the first IB anonymous block's style context takes the first
34460:     // part's style context as parent, which is wrong since first-line style
34460:     // should not apply to the anonymous block.
    1: 
33987: #ifdef DEBUG
33987:     {
33987:       // Check that our assumption that continuations of the same
33987:       // pseudo-type and with the same style context parent have the
33987:       // same style context is valid before the reresolution.  (We need
33987:       // to check the pseudo-type and style context parent because of
33987:       // :first-letter and :first-line, where we create styled and
33987:       // unstyled letter/line frames distinguished by pseudo-type, and
33987:       // then need to distinguish their descendants based on having
33987:       // different parents.)
33987:       nsIFrame *nextContinuation = aFrame->GetNextContinuation();
33987:       if (nextContinuation) {
33987:         nsStyleContext *nextContinuationContext =
33987:           nextContinuation->GetStyleContext();
33987:         NS_ASSERTION(oldContext == nextContinuationContext ||
34387:                      oldContext->GetPseudo() !=
34387:                        nextContinuationContext->GetPseudo() ||
33987:                      oldContext->GetParent() !=
33987:                        nextContinuationContext->GetParent(),
33987:                      "continuations should have the same style context");
33987:       }
33987:     }
33987: #endif
33987: 
75315:     nsIFrame *prevContinuation =
75315:       GetPrevContinuationWithPossiblySameStyle(aFrame);
33987:     nsStyleContext *prevContinuationContext;
79445:     bool copyFromContinuation =
33987:       prevContinuation &&
33987:       (prevContinuationContext = prevContinuation->GetStyleContext())
34387:         ->GetPseudo() == oldContext->GetPseudo() &&
33987:        prevContinuationContext->GetParent() == newParentContext;
33987:     if (copyFromContinuation) {
33987:       // Just use the style context from the frame's previous
33987:       // continuation (see assertion about aFrame->GetNextContinuation()
33987:       // above, which we would have previously hit for aFrame's previous
33987:       // continuation).
33987:       newContext = prevContinuationContext;
33987:     } else {
44166:       nsIFrame* parentFrame = aFrame->GetParent();
44166:       Element* element =
44166:         ElementForStyleContext(parentFrame ? parentFrame->GetContent() : nsnull,
44166:                                aFrame,
44166:                                oldContext->GetPseudoType());
40136:       newContext = mStyleSet->ReparentStyleContext(oldContext,
44166:                                                    newParentContext,
44166:                                                    element);
33987:     }
33987: 
    1:     if (newContext) {
    1:       if (newContext != oldContext) {
33649:         // We probably don't want to initiate transitions from
40137:         // ReparentStyleContext, since we call it during frame
33649:         // construction rather than in response to dynamic changes.
33649:         // Also see the comment at the start of
33649:         // nsTransitionManager::ConsiderStartingTransition.
33649: #if 0
33987:         if (!copyFromContinuation) {
40136:           TryStartingTransition(GetPresContext(), aFrame->GetContent(),
33649:                                 oldContext, &newContext);
33987:         }
33649: #endif
33649: 
 7656:         // Make sure to call CalcStyleDifference so that the new context ends
 7656:         // up resolving all the structs the old context resolved.
 7656:         nsChangeHint styleChange = oldContext->CalcStyleDifference(newContext);
 7656:         // The style change is always 0 because we have the same rulenode and
 7656:         // CalcStyleDifference optimizes us away.  That's OK, though:
 7656:         // reparenting should never trigger a frame reconstruct, and whenever
 7656:         // it's happening we already plan to reflow and repaint the frames.
 7656:         NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
 7656:                      "Our frame tree is likely to be bogus!");
 7656:         
    1:         aFrame->SetStyleContext(newContext);
    1: 
77153:         nsIFrame::ChildListIterator lists(aFrame);
77153:         for (; !lists.IsDone(); lists.Next()) {
77153:           nsFrameList::Enumerator childFrames(lists.CurrentList());
77153:           for (; !childFrames.AtEnd(); childFrames.Next()) {
77153:             nsIFrame* child = childFrames.get();
93351:             // only do frames that are in flow
93351:             if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
 7656:                 child != providerChild) {
 7656: #ifdef DEBUG
    1:               if (nsGkAtoms::placeholderFrame == child->GetType()) {
    1:                 nsIFrame* outOfFlowFrame =
    1:                   nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
    1:                 NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
    1: 
    1:                 NS_ASSERTION(outOfFlowFrame != providerChild,
    1:                              "Out of flow provider?");
 7656:               }
 7656: #endif
40137:               ReparentStyleContext(child);
    1:             }
    1:           }
77153:         }
    1: 
    1:         // If this frame is part of an IB split, then the style context of
    1:         // the next part of the split might be a child of our style context.
    1:         // Reparent its style context just in case one of our ancestors
    1:         // (split or not) hasn't done so already). It's not a problem to
    1:         // reparent the same frame twice because the "if (newContext !=
    1:         // oldContext)" check will prevent us from redoing work.
    1:         if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
34459:             !aFrame->GetPrevContinuation()) {
39965:           nsIFrame* sib = static_cast<nsIFrame*>
39965:             (aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
    1:           if (sib) {
40137:             ReparentStyleContext(sib);
    1:           }
    1:         }
    1: 
    1:         // do additional contexts 
    1:         PRInt32 contextIndex = -1;
    1:         while (1) {
    1:           nsStyleContext* oldExtraContext =
    1:             aFrame->GetAdditionalStyleContext(++contextIndex);
    1:           if (oldExtraContext) {
    1:             nsRefPtr<nsStyleContext> newExtraContext;
40136:             newExtraContext = mStyleSet->ReparentStyleContext(oldExtraContext,
44166:                                                               newContext,
44166:                                                               nsnull);
    1:             if (newExtraContext) {
 7656:               if (newExtraContext != oldExtraContext) {
 7656:                 // Make sure to call CalcStyleDifference so that the new
 7656:                 // context ends up resolving all the structs the old context
 7656:                 // resolved.
 7656:                 styleChange =
 7656:                   oldExtraContext->CalcStyleDifference(newExtraContext);
 7656:                 // The style change is always 0 because we have the same
 7656:                 // rulenode and CalcStyleDifference optimizes us away.  That's
 7656:                 // OK, though: reparenting should never trigger a frame
 7656:                 // reconstruct, and whenever it's happening we already plan to
 7656:                 // reflow and repaint the frames.
 7656:                 NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
 7656:                              "Our frame tree is likely to be bogus!");
 7656:               }
 7656:               
    1:               aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
    1:             }
    1:           }
    1:           else {
    1:             break;
    1:           }
    1:         }
    1: #ifdef DEBUG
    1:         VerifyStyleTree(GetPresContext(), aFrame, newParentContext);
    1: #endif
    1:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: static nsChangeHint
    1: CaptureChange(nsStyleContext* aOldContext, nsStyleContext* aNewContext,
    1:               nsIFrame* aFrame, nsIContent* aContent,
    1:               nsStyleChangeList* aChangeList, nsChangeHint aMinChange,
    1:               nsChangeHint aChangeToAssume)
    1: {
    1:   nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext);
31283:   NS_ASSERTION(!(ourChange & nsChangeHint_ReflowFrame) ||
31283:                (ourChange & nsChangeHint_NeedReflow),
31283:                "Reflow hint bits set without actually asking for a reflow");
31283: 
    1:   NS_UpdateHint(ourChange, aChangeToAssume);
    1:   if (NS_UpdateHint(aMinChange, ourChange)) {
61102:     if (!(ourChange & nsChangeHint_ReconstructFrame) || aContent) {
    1:       aChangeList->AppendChange(aFrame, aContent, ourChange);
    1:     }
61102:   }
    1:   return aMinChange;
    1: }
    1: 
23168: /**
23168:  * Recompute style for aFrame and accumulate changes into aChangeList
23168:  * given that aMinChange is already accumulated for an ancestor.
23168:  * aParentContent is the content node used to resolve the parent style
23168:  * context.  This means that, for pseudo-elements, it is the content
23168:  * that should be used for selector matching (rather than the fake
23168:  * content node attached to the frame).
23168:  */
    1: nsChangeHint
    1: nsFrameManager::ReResolveStyleContext(nsPresContext     *aPresContext,
    1:                                       nsIFrame          *aFrame,
    1:                                       nsIContent        *aParentContent,
    1:                                       nsStyleChangeList *aChangeList, 
30895:                                       nsChangeHint       aMinChange,
43794:                                       nsRestyleHint      aRestyleHint,
57448:                                       RestyleTracker&    aRestyleTracker,
57448:                                       DesiredA11yNotifications aDesiredA11yNotifications,
70853:                                       nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
70853:                                       TreeMatchContext &aTreeMatchContext)
    1: {
31101:   if (!NS_IsHintSubset(nsChangeHint_NeedDirtyReflow, aMinChange)) {
31283:     // If aMinChange doesn't include nsChangeHint_NeedDirtyReflow, clear out
31283:     // all the reflow change bits from it, so that we'll make sure to append a
31283:     // change to the list for ourselves if we need a reflow.  We need this
31283:     // because the parent may or may not actually end up reflowing us
31283:     // otherwise.
31283:     aMinChange = NS_SubtractHint(aMinChange, nsChangeHint_ReflowFrame);
31283:   } else if (!NS_IsHintSubset(nsChangeHint_ClearDescendantIntrinsics,
31283:                               aMinChange)) {
31283:     // If aMinChange doesn't include nsChangeHint_ClearDescendantIntrinsics,
31283:     // clear out the nsChangeHint_ClearAncestorIntrinsics flag, since it's
31283:     // possible that we had some random ancestor that cleared ancestor
31283:     // intrinsic widths, but we still need to clear intrinsic widths on frames
31283:     // that are our ancestors but its descendants.
31283:     aMinChange =
31283:       NS_SubtractHint(aMinChange, nsChangeHint_ClearAncestorIntrinsics);
31101:   }
31101: 
89652:   // We need to generate a new change list entry for every frame whose style
89652:   // comparision returns one of these hints. These hints don't automatically
89652:   // update all their descendant frames.
89652:   aMinChange = NS_SubtractHint(aMinChange, nsChangeHint_UpdateTransformLayer);
89652:   aMinChange = NS_SubtractHint(aMinChange, nsChangeHint_UpdateOpacityLayer);
89568:   aMinChange = NS_SubtractHint(aMinChange, nsChangeHint_UpdateOverflow);
89568: 
24409:   // It would be nice if we could make stronger assertions here; they
24409:   // would let us simplify the ?: expressions below setting |content|
24409:   // and |pseudoContent| in sensible ways as well as making what
24409:   // |localContent|, |content|, and |pseudoContent| mean make more
24409:   // sense.  However, we can't, because of frame trees like the one in
24409:   // https://bugzilla.mozilla.org/show_bug.cgi?id=472353#c14 .  Once we
24409:   // fix bug 242277 we should be able to make this make more sense.
24409:   NS_ASSERTION(aFrame->GetContent() || !aParentContent ||
24409:                !aParentContent->GetParent(),
24409:                "frame must have content (unless at the top of the tree)");
    1:   // XXXldb get new context from prev-in-flow if possible, to avoid
    1:   // duplication.  (Or should we just let |GetContext| handle that?)
    1:   // Getting the hint would be nice too, but that's harder.
    1: 
    1:   // XXXbryner we may be able to avoid some of the refcounting goop here.
    1:   // We do need a reference to oldContext for the lifetime of this function, and it's possible
    1:   // that the frame has the last reference to it, so AddRef it here.
    1: 
    1:   nsChangeHint assumeDifferenceHint = NS_STYLE_HINT_NONE;
 6632:   // XXXbz oldContext should just be an nsRefPtr
    1:   nsStyleContext* oldContext = aFrame->GetStyleContext();
    1:   nsStyleSet* styleSet = aPresContext->StyleSet();
    1: 
 6632:   // XXXbz the nsIFrame constructor takes an nsStyleContext, so how
 6632:   // could oldContext be null?
    1:   if (oldContext) {
    1:     oldContext->AddRef();
57448: 
57448: #ifdef ACCESSIBILITY
79445:     bool wasFrameVisible = nsIPresShell::IsAccessibilityActive() ?
80486:       oldContext->GetStyleVisibility()->IsVisible() : false;
57448: #endif
57448: 
34387:     nsIAtom* const pseudoTag = oldContext->GetPseudo();
35554:     const nsCSSPseudoElements::Type pseudoType = oldContext->GetPseudoType();
    1:     nsIContent* localContent = aFrame->GetContent();
23168:     // |content| is the node that we used for rule matching of
23168:     // normal elements (not pseudo-elements) and for which we generate
23168:     // framechange hints if we need them.
24409:     // XXXldb Why does it make sense to use aParentContent?  (See
24409:     // comment above assertion at start of function.)
    1:     nsIContent* content = localContent ? localContent : aParentContent;
    1: 
43792:     if (content && content->IsElement()) {
82192:       content->OwnerDoc()->FlushPendingLinkUpdates();
43792:       RestyleTracker::RestyleData restyleData;
43792:       if (aRestyleTracker.GetRestyleData(content->AsElement(), &restyleData)) {
43792:         if (NS_UpdateHint(aMinChange, restyleData.mChangeHint)) {
43792:           aChangeList->AppendChange(aFrame, content, restyleData.mChangeHint);
43792:         }
43794:         aRestyleHint = nsRestyleHint(aRestyleHint | restyleData.mRestyleHint);
43792:       }
43792:     }
43792: 
43794:     nsRestyleHint childRestyleHint = aRestyleHint;
43794: 
43794:     if (childRestyleHint == eRestyle_Self) {
43794:       childRestyleHint = nsRestyleHint(0);
43794:     }
43794: 
    1:     nsStyleContext* parentContext;
    1:     nsIFrame* resolvedChild = nsnull;
    1:     // Get the frame providing the parent style context.  If it is a
    1:     // child, then resolve the provider first.
78202:     nsIFrame* providerFrame = aFrame->GetParentStyleContextFrame();
78202:     bool isChild = providerFrame && providerFrame->GetParent() == aFrame;
78202:     if (!isChild) {
    1:       if (providerFrame)
    1:         parentContext = providerFrame->GetStyleContext();
    1:       else
    1:         parentContext = nsnull;
    1:     }
    1:     else {
92182:       MOZ_ASSERT(providerFrame->GetContent() == aFrame->GetContent(),
92182:                  "Postcondition for GetParentStyleContextFrame() violated. "
92182:                  "That means we need to add the current element to the "
92182:                  "ancestor filter.");
92182: 
    1:       // resolve the provider here (before aFrame below).
    1: 
    1:       // assumeDifferenceHint forces the parent's change to be also
    1:       // applied to this frame, no matter what
10152:       // nsStyleContext::CalcStyleDifference says. CalcStyleDifference
    1:       // can't be trusted because it assumes any changes to the parent
    1:       // style context provider will be automatically propagated to
    1:       // the frame(s) with child style contexts.
30895: 
    1:       assumeDifferenceHint = ReResolveStyleContext(aPresContext, providerFrame,
23168:                                                    aParentContent, aChangeList,
43794:                                                    aMinChange, aRestyleHint,
57448:                                                    aRestyleTracker,
57448:                                                    aDesiredA11yNotifications,
70853:                                                    aVisibleKidsOfHiddenElement,
70853:                                                    aTreeMatchContext);
    1: 
    1:       // The provider's new context becomes the parent context of
    1:       // aFrame's context.
    1:       parentContext = providerFrame->GetStyleContext();
    1:       // Set |resolvedChild| so we don't bother resolving the
    1:       // provider again.
    1:       resolvedChild = providerFrame;
    1:     }
    1: 
33987: #ifdef DEBUG
33987:     {
33987:       // Check that our assumption that continuations of the same
33987:       // pseudo-type and with the same style context parent have the
33987:       // same style context is valid before the reresolution.  (We need
33987:       // to check the pseudo-type and style context parent because of
33987:       // :first-letter and :first-line, where we create styled and
33987:       // unstyled letter/line frames distinguished by pseudo-type, and
33987:       // then need to distinguish their descendants based on having
33987:       // different parents.)
33987:       nsIFrame *nextContinuation = aFrame->GetNextContinuation();
33987:       if (nextContinuation) {
33987:         nsStyleContext *nextContinuationContext =
33987:           nextContinuation->GetStyleContext();
33987:         NS_ASSERTION(oldContext == nextContinuationContext ||
34387:                      oldContext->GetPseudo() !=
34387:                        nextContinuationContext->GetPseudo() ||
33987:                      oldContext->GetParent() !=
33987:                        nextContinuationContext->GetParent(),
33987:                      "continuations should have the same style context");
33987:       }
75315:       // And assert the same thing for {ib} splits.  See the comments in
75315:       // GetPrevContinuationWithPossiblySameStyle for an explanation of
75315:       // why we step two forward in the special sibling chain.
75315:       if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
75315:           !aFrame->GetPrevContinuation()) {
75315:         nsIFrame *nextIBSibling = static_cast<nsIFrame*>(
75315:           aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
75315:         if (nextIBSibling) {
75315:           nextIBSibling = static_cast<nsIFrame*>(
75315:             nextIBSibling->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
75315:         }
75315:         if (nextIBSibling) {
75315:           nsStyleContext *nextIBSiblingContext =
75315:             nextIBSibling->GetStyleContext();
75315:           NS_ASSERTION(oldContext == nextIBSiblingContext ||
75315:                        oldContext->GetPseudo() !=
75315:                          nextIBSiblingContext->GetPseudo() ||
75315:                        oldContext->GetParent() !=
75315:                          nextIBSiblingContext->GetParent(),
75315:                        "continuations should have the same style context");
75315:         }
75315:       }
33987:     }
33987: #endif
33987: 
    1:     // do primary context
32405:     nsRefPtr<nsStyleContext> newContext;
75315:     nsIFrame *prevContinuation =
75315:       GetPrevContinuationWithPossiblySameStyle(aFrame);
33987:     nsStyleContext *prevContinuationContext;
79445:     bool copyFromContinuation =
33987:       prevContinuation &&
33987:       (prevContinuationContext = prevContinuation->GetStyleContext())
34387:         ->GetPseudo() == oldContext->GetPseudo() &&
33987:        prevContinuationContext->GetParent() == parentContext;
33987:     if (copyFromContinuation) {
33987:       // Just use the style context from the frame's previous
33987:       // continuation (see assertion about aFrame->GetNextContinuation()
33987:       // above, which we would have previously hit for aFrame's previous
33987:       // continuation).
33987:       newContext = prevContinuationContext;
33987:     }
33987:     else if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
    1:       NS_ASSERTION(localContent,
    1:                    "non pseudo-element frame without content node");
32405:       newContext = styleSet->ResolveStyleForNonElement(parentContext);
    1:     }
75315:     else if (!aRestyleHint && !prevContinuation) {
75315:       // Unfortunately, if prevContinuation is non-null then we may have
75315:       // already stolen the restyle tracker entry for this element while
75315:       // processing prevContinuation.  So we don't know whether aRestyleHint
75315:       // should really be 0 here or whether it should be eRestyle_Self.  Be
75315:       // pessimistic and force an actual reresolve in that situation.  The good
75315:       // news is that in the common case when prevContinuation is non-null we
75315:       // just used prevContinuationContext anyway and aren't reaching this code
75315:       // to start with.
44166:       newContext =
44166:         styleSet->ReparentStyleContext(oldContext, parentContext,
44166:                                        ElementForStyleContext(aParentContent,
44166:                                                               aFrame,
44166:                                                               pseudoType));
44166:     } else if (pseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
44166:       newContext = styleSet->ResolveAnonymousBoxStyle(pseudoTag,
44166:                                                       parentContext);
44166:     }
44166:     else {
44166:       Element* element = ElementForStyleContext(aParentContent,
44166:                                                 aFrame,
44166:                                                 pseudoType);
44166:       if (pseudoTag) {
    1:         if (pseudoTag == nsCSSPseudoElements::before ||
    1:             pseudoTag == nsCSSPseudoElements::after) {
    1:           // XXX what other pseudos do we need to treat like this?
44166:           newContext = styleSet->ProbePseudoElementStyle(element,
35554:                                                          pseudoType,
70853:                                                          parentContext,
70853:                                                          aTreeMatchContext);
    1:           if (!newContext) {
    1:             // This pseudo should no longer exist; gotta reframe
    1:             NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
44166:             aChangeList->AppendChange(aFrame, element,
    1:                                       nsChangeHint_ReconstructFrame);
    1:             // We're reframing anyway; just keep the same context
    1:             newContext = oldContext;
    1:           }
    1:         } else {
35554:           // Don't expect XUL tree stuff here, since it needs a comparator and
35554:           // all.
35554:           NS_ASSERTION(pseudoType <
35554:                          nsCSSPseudoElements::ePseudo_PseudoElementCount,
35554:                        "Unexpected pseudo type");
44166:           newContext = styleSet->ResolvePseudoElementStyle(element,
35554:                                                            pseudoType,
32405:                                                            parentContext);
    1:         }
    1:       }
    1:       else {
    1:         NS_ASSERTION(localContent,
    1:                      "non pseudo-element frame without content node");
70853:         newContext = styleSet->ResolveStyleFor(element, parentContext,
70853:                                                aTreeMatchContext);
44166:       }
    1:     }
43794: 
    1:     NS_ASSERTION(newContext, "failed to get new style context");
    1:     if (newContext) {
    1:       if (!parentContext) {
68814:         if (oldContext->GetRuleNode() == newContext->GetRuleNode() &&
68814:             oldContext->IsLinkContext() == newContext->IsLinkContext() &&
68814:             oldContext->RelevantLinkVisited() ==
68814:               newContext->RelevantLinkVisited()) {
    1:           // We're the root of the style context tree and the new style
    1:           // context returned has the same rule node.  This means that
    1:           // we can use FindChildWithRules to keep a lot of the old
    1:           // style contexts around.  However, we need to start from the
    1:           // same root.
    1:           newContext = oldContext;
    1:         }
    1:       }
    1: 
    1:       if (newContext != oldContext) {
33987:         if (!copyFromContinuation) {
33649:           TryStartingTransition(aPresContext, aFrame->GetContent(),
33649:                                 oldContext, &newContext);
33987:         }
33649: 
    1:         aMinChange = CaptureChange(oldContext, newContext, aFrame,
    1:                                    content, aChangeList, aMinChange,
    1:                                    assumeDifferenceHint);
    1:         if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
    1:           // if frame gets regenerated, let it keep old context
    1:           aFrame->SetStyleContext(newContext);
    1:         }
    1:       }
    1:       oldContext->Release();
    1:     }
    1:     else {
    1:       NS_ERROR("resolve style context failed");
32405:       newContext = oldContext;  // new context failed, recover...
    1:     }
    1: 
    1:     // do additional contexts
43794:     // XXXbz might be able to avoid selector matching here in some
43794:     // cases; won't worry about it for now.
    1:     PRInt32 contextIndex = -1;
    1:     while (1 == 1) {
    1:       nsStyleContext* oldExtraContext = nsnull;
    1:       oldExtraContext = aFrame->GetAdditionalStyleContext(++contextIndex);
    1:       if (oldExtraContext) {
32405:         nsRefPtr<nsStyleContext> newExtraContext;
34387:         nsIAtom* const extraPseudoTag = oldExtraContext->GetPseudo();
35554:         const nsCSSPseudoElements::Type extraPseudoType =
35554:           oldExtraContext->GetPseudoType();
    1:         NS_ASSERTION(extraPseudoTag &&
    1:                      extraPseudoTag != nsCSSAnonBoxes::mozNonElement,
    1:                      "extra style context is not pseudo element");
35554:         if (extraPseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
35554:           newExtraContext = styleSet->ResolveAnonymousBoxStyle(extraPseudoTag,
32405:                                                                newContext);
35554:         }
35554:         else {
35554:           // Don't expect XUL tree stuff here, since it needs a comparator and
35554:           // all.
35554:           NS_ASSERTION(extraPseudoType <
35554:                          nsCSSPseudoElements::ePseudo_PseudoElementCount,
35554:                        "Unexpected type");
41640:           newExtraContext = styleSet->ResolvePseudoElementStyle(content->AsElement(),
35554:                                                                 extraPseudoType,
35554:                                                                 newContext);
35554:         }
    1:         if (newExtraContext) {
    1:           if (oldExtraContext != newExtraContext) {
    1:             aMinChange = CaptureChange(oldExtraContext, newExtraContext,
    1:                                        aFrame, content, aChangeList,
    1:                                        aMinChange, assumeDifferenceHint);
    1:             if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
    1:               aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
    1:             }
    1:           }
    1:         }
    1:       }
    1:       else {
    1:         break;
    1:       }
    1:     }
    1: 
    1:     // now look for undisplayed child content and pseudos
23830: 
23830:     // When the root element is display:none, we still construct *some*
23830:     // frames that have the root element as their mContent, down to the
23830:     // DocElementContainingBlock.
79445:     bool checkUndisplayed;
23830:     nsIContent *undisplayedParent;
23830:     if (pseudoTag) {
23830:       checkUndisplayed = aFrame == mPresShell->FrameConstructor()->
23830:                                      GetDocElementContainingBlock();
23830:       undisplayedParent = nsnull;
23830:     } else {
23830:       checkUndisplayed = !!localContent;
23830:       undisplayedParent = localContent;
23830:     }
23830:     if (checkUndisplayed && mUndisplayedMap) {
92182:       UndisplayedNode* undisplayed =
23830:         mUndisplayedMap->GetFirstNode(undisplayedParent);
92182:       for (AncestorFilter::AutoAncestorPusher
92182:              pushAncestor(undisplayed, aTreeMatchContext.mAncestorFilter,
92182:                           undisplayedParent ? undisplayedParent->AsElement()
92182:                                             : nsnull);
    1:            undisplayed; undisplayed = undisplayed->mNext) {
23830:         NS_ASSERTION(undisplayedParent ||
23830:                      undisplayed->mContent ==
41634:                        mPresShell->GetDocument()->GetRootElement(),
23830:                      "undisplayed node child of null must be root");
34387:         NS_ASSERTION(!undisplayed->mStyle->GetPseudo(),
28357:                      "Shouldn't have random pseudo style contexts in the "
28357:                      "undisplayed map");
43794:         nsRestyleHint thisChildHint = childRestyleHint;
43792:         RestyleTracker::RestyleData undisplayedRestyleData;
43792:         if (aRestyleTracker.GetRestyleData(undisplayed->mContent->AsElement(),
43792:                                            &undisplayedRestyleData)) {
43794:           thisChildHint =
43794:             nsRestyleHint(thisChildHint | undisplayedRestyleData.mRestyleHint);
43792:         }
43794:         nsRefPtr<nsStyleContext> undisplayedContext;
43794:         if (thisChildHint) {
43794:           undisplayedContext =
43794:             styleSet->ResolveStyleFor(undisplayed->mContent->AsElement(),
70853:                                       newContext,
70853:                                       aTreeMatchContext);
43794:         } else {
43794:           undisplayedContext =
44166:             styleSet->ReparentStyleContext(undisplayed->mStyle, newContext,
44166:                                            undisplayed->mContent->AsElement());
43794:         }
    1:         if (undisplayedContext) {
    1:           const nsStyleDisplay* display = undisplayedContext->GetStyleDisplay();
    1:           if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
41640:             NS_ASSERTION(undisplayed->mContent,
41640:                          "Must have undisplayed content");
41640:             aChangeList->AppendChange(nsnull, undisplayed->mContent, 
    1:                                       NS_STYLE_HINT_FRAMECHANGE);
    1:             // The node should be removed from the undisplayed map when
    1:             // we reframe it.
    1:           } else {
    1:             // update the undisplayed node with the new context
    1:             undisplayed->mStyle = undisplayedContext;
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
43795:     // Check whether we might need to create a new ::before frame.
43795:     // There's no need to do this if we're planning to reframe already
43795:     // or if we're not forcing restyles on kids.
43795:     if (!(aMinChange & nsChangeHint_ReconstructFrame) &&
43795:         childRestyleHint) {
    1:       // Make sure not to do this for pseudo-frames -- those can't have :before
    1:       // or :after content.  Neither can non-elements or leaf frames.
41640:       if (!pseudoTag && localContent && localContent->IsElement() &&
    1:           !aFrame->IsLeaf()) {
    1:         // Check for a new :before pseudo and an existing :before
    1:         // frame, but only if the frame is the first continuation.
    1:         nsIFrame* prevContinuation = aFrame->GetPrevContinuation();
    1:         if (!prevContinuation) {
    1:           // Checking for a :before frame is cheaper than getting the
    1:           // :before style context.
    1:           if (!nsLayoutUtils::GetBeforeFrame(aFrame) &&
    1:               nsLayoutUtils::HasPseudoStyle(localContent, newContext,
35554:                                             nsCSSPseudoElements::ePseudo_before,
    1:                                             aPresContext)) {
    1:             // Have to create the new :before frame
    1:             NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
    1:             aChangeList->AppendChange(aFrame, content,
    1:                                       nsChangeHint_ReconstructFrame);
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
43795:     // Check whether we might need to create a new ::after frame.
43795:     // There's no need to do this if we're planning to reframe already
43795:     // or if we're not forcing restyles on kids.
43795:     if (!(aMinChange & nsChangeHint_ReconstructFrame) &&
43795:         childRestyleHint) {
    1:       // Make sure not to do this for pseudo-frames -- those can't have :before
    1:       // or :after content.  Neither can non-elements or leaf frames.
41640:       if (!pseudoTag && localContent && localContent->IsElement() &&
    1:           !aFrame->IsLeaf()) {
    1:         // Check for new :after content, but only if the frame is the
    1:         // last continuation.
    1:         nsIFrame* nextContinuation = aFrame->GetNextContinuation();
    1: 
    1:         if (!nextContinuation) {
    1:           // Getting the :after frame is more expensive than getting the pseudo
    1:           // context, so get the pseudo context first.
    1:           if (nsLayoutUtils::HasPseudoStyle(localContent, newContext,
35554:                                             nsCSSPseudoElements::ePseudo_after,
    1:                                             aPresContext) &&
    1:               !nsLayoutUtils::GetAfterFrame(aFrame)) {
    1:             // have to create the new :after frame
    1:             NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
    1:             aChangeList->AppendChange(aFrame, content,
    1:                                       nsChangeHint_ReconstructFrame);
    1:           }
    1:         }      
    1:       }
    1:     }
    1: 
    1:     if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
57448:       DesiredA11yNotifications kidsDesiredA11yNotification =
57448:         aDesiredA11yNotifications;
57448: #ifdef ACCESSIBILITY
58609:       A11yNotificationType ourA11yNotification = eDontNotify;
57448:       // Notify a11y for primary frame only if it's a root frame of visibility
57448:       // changes or its parent frame was hidden while it stays visible and
57448:       // it is not inside a {ib} split or is the first frame of {ib} split.
74013:       if (nsIPresShell::IsAccessibilityActive() &&
74013:           !aFrame->GetPrevContinuation() &&
57448:           !nsLayoutUtils::FrameIsNonFirstInIBSplit(aFrame)) {
57448:         if (aDesiredA11yNotifications == eSendAllNotifications) {
79445:           bool isFrameVisible = newContext->GetStyleVisibility()->IsVisible();
57448:           if (isFrameVisible != wasFrameVisible) {
57448:             if (isFrameVisible) {
57448:               // Notify a11y the element (perhaps with its children) was shown.
57448:               // We don't fall into this case if this element gets or stays shown
57448:               // while its parent becomes hidden.
57448:               kidsDesiredA11yNotification = eSkipNotifications;
57448:               ourA11yNotification = eNotifyShown;
57448:             } else {
57448:               // The element is being hidden; its children may stay visible, or
57448:               // become visible after being hidden previously. If we'll find
57448:               // visible children then we should notify a11y about that as if
57448:               // they were inserted into tree. Notify a11y this element was
57448:               // hidden.
57448:               kidsDesiredA11yNotification = eNotifyIfShown;
57448:               ourA11yNotification = eNotifyHidden;
57448:             }
57448:           }
57448:         } else if (aDesiredA11yNotifications == eNotifyIfShown &&
57448:                    newContext->GetStyleVisibility()->IsVisible()) {
57448:           // Notify a11y that element stayed visible while its parent was
57448:           // hidden.
57448:           aVisibleKidsOfHiddenElement.AppendElement(aFrame->GetContent());
57448:           kidsDesiredA11yNotification = eSkipNotifications;
57448:         }
57448:       }
57448: #endif
    1: 
    1:       // There is no need to waste time crawling into a frame's children on a frame change.
    1:       // The act of reconstructing frames will force new style contexts to be resolved on all
    1:       // of this frame's descendants anyway, so we want to avoid wasting time processing
    1:       // style contexts that we're just going to throw away anyway. - dwh
    1: 
    1:       // now do children
77153:       nsIFrame::ChildListIterator lists(aFrame);
92182:       for (AncestorFilter::AutoAncestorPusher
92182:              pushAncestor(!lists.IsDone(),
92182:                           aTreeMatchContext.mAncestorFilter,
92182:                           content && content->IsElement() ? content->AsElement()
92182:                                                           : nsnull);
92182:            !lists.IsDone(); lists.Next()) {
77153:         nsFrameList::Enumerator childFrames(lists.CurrentList());
77153:         for (; !childFrames.AtEnd(); childFrames.Next()) {
77153:           nsIFrame* child = childFrames.get();
93351:           if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
93351:             // only do frames that are in flow
    1:             if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
    1:               // get out of flow frame and recur there
    1:               nsIFrame* outOfFlowFrame =
    1:                 nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
    1:               NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
    1:               NS_ASSERTION(outOfFlowFrame != resolvedChild,
    1:                            "out-of-flow frame not a true descendant");
    1: 
    1:               // Note that the out-of-flow may not be a geometric descendant of
    1:               // the frame where we started the reresolve.  Therefore, even if
    1:               // aMinChange already includes nsChangeHint_ReflowFrame we don't
    1:               // want to pass that on to the out-of-flow reresolve, since that
30710:               // can lead to the out-of-flow not getting reflowed when it should
    1:               // be (eg a reresolve starting at <body> that involves reflowing
    1:               // the <body> would miss reflowing fixed-pos nodes that also need
    1:               // reflow).  In the cases when the out-of-flow _is_ a geometric
    1:               // descendant of a frame we already have a reflow hint for,
    1:               // reflow coalescing should keep us from doing the work twice.
    1: 
    1:               // |nsFrame::GetParentStyleContextFrame| checks being out
    1:               // of flow so that this works correctly.
49314:               do {
    1:                 ReResolveStyleContext(aPresContext, outOfFlowFrame,
    1:                                       content, aChangeList,
    1:                                       NS_SubtractHint(aMinChange,
30895:                                                       nsChangeHint_ReflowFrame),
43794:                                       childRestyleHint,
57448:                                       aRestyleTracker,
57448:                                       kidsDesiredA11yNotification,
70853:                                       aVisibleKidsOfHiddenElement,
70853:                                       aTreeMatchContext);
62664:               } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
    1: 
    1:               // reresolve placeholder's context under the same parent
    1:               // as the out-of-flow frame
    1:               ReResolveStyleContext(aPresContext, child, content,
30895:                                     aChangeList, aMinChange,
43794:                                     childRestyleHint,
57448:                                     aRestyleTracker,
57448:                                     kidsDesiredA11yNotification,
70853:                                     aVisibleKidsOfHiddenElement,
70853:                                     aTreeMatchContext);
    1:             }
    1:             else {  // regular child frame
    1:               if (child != resolvedChild) {
    1:                 ReResolveStyleContext(aPresContext, child, content,
30895:                                       aChangeList, aMinChange,
43794:                                       childRestyleHint,
57448:                                       aRestyleTracker,
57448:                                       kidsDesiredA11yNotification,
70853:                                       aVisibleKidsOfHiddenElement,
70853:                                       aTreeMatchContext);
    1:               } else {
    1:                 NOISY_TRACE_FRAME("child frame already resolved as descendant, skipping",aFrame);
    1:               }
    1:             }
    1:           }
    1:         }
77153:       }
    1:       // XXX need to do overflow frames???
57448: 
57448: #ifdef ACCESSIBILITY
57448:       // Send notifications about visibility changes.
57448:       if (ourA11yNotification == eNotifyShown) {
61464:         nsAccessibilityService* accService = nsIPresShell::AccService();
57448:         if (accService) {
57448:           nsIPresShell* presShell = aFrame->PresContext()->GetPresShell();
57448:           nsIContent* content = aFrame->GetContent();
57448: 
57448:           accService->ContentRangeInserted(presShell, content->GetParent(),
57448:                                            content,
57448:                                            content->GetNextSibling());
    1:         }
57448:       } else if (ourA11yNotification == eNotifyHidden) {
61464:         nsAccessibilityService* accService = nsIPresShell::AccService();
57448:         if (accService) {
57448:           nsIPresShell* presShell = aFrame->PresContext()->GetPresShell();
57448:           nsIContent* content = aFrame->GetContent();
57448:           accService->ContentRemoved(presShell, content->GetParent(), content);
    1: 
57448:           // Process children staying shown.
57448:           PRUint32 visibleContentCount = aVisibleKidsOfHiddenElement.Length();
57448:           for (PRUint32 idx = 0; idx < visibleContentCount; idx++) {
57448:             nsIContent* content = aVisibleKidsOfHiddenElement[idx];
57448:             accService->ContentRangeInserted(presShell, content->GetParent(),
57448:                                              content, content->GetNextSibling());
57448:           }
57448:           aVisibleKidsOfHiddenElement.Clear();
57448:         }
57448:       }
57448: #endif
57448:     }
    1:   }
    1: 
    1:   return aMinChange;
    1: }
    1: 
11409: void
    1: nsFrameManager::ComputeStyleChangeFor(nsIFrame          *aFrame, 
    1:                                       nsStyleChangeList *aChangeList,
43790:                                       nsChangeHint       aMinChange,
43794:                                       RestyleTracker&    aRestyleTracker,
79445:                                       bool               aRestyleDescendants)
    1: {
92182:   nsIContent *content = aFrame->GetContent();
11409:   if (aMinChange) {
92182:     aChangeList->AppendChange(aFrame, content, aMinChange);
11409:   }
11409: 
    1:   nsChangeHint topLevelChange = aMinChange;
    1: 
    1:   nsIFrame* frame = aFrame;
    1:   nsIFrame* frame2 = aFrame;
    1: 
    1:   NS_ASSERTION(!frame->GetPrevContinuation(), "must start with the first in flow");
    1: 
    1:   // We want to start with this frame and walk all its next-in-flows,
    1:   // as well as all its special siblings and their next-in-flows,
    1:   // reresolving style on all the frames we encounter in this walk.
    1: 
39965:   FramePropertyTable *propTable = GetPresContext()->PropertyTable();
    1: 
80486:   TreeMatchContext treeMatchContext(true,
70853:                                     nsRuleWalker::eRelevantLinkUnvisited,
70853:                                     mPresShell->GetDocument());
92182:   nsIContent *parent = content ? content->GetParent() : nsnull;
92182:   Element *parentElement =
92182:     parent && parent->IsElement() ? parent->AsElement() : nsnull;
92182:   treeMatchContext.mAncestorFilter.Init(parentElement);
57448:   nsTArray<nsIContent*> visibleKidsOfHiddenElement;
    1:   do {
    1:     // Outer loop over special siblings
    1:     do {
    1:       // Inner loop over next-in-flows of the current frame
    1:       nsChangeHint frameChange =
    1:         ReResolveStyleContext(GetPresContext(), frame, nsnull,
43794:                               aChangeList, topLevelChange,
43794:                               aRestyleDescendants ?
43794:                                 eRestyle_Subtree : eRestyle_Self,
57448:                               aRestyleTracker,
57448:                               eSendAllNotifications,
70853:                               visibleKidsOfHiddenElement,
70853:                               treeMatchContext);
    1:       NS_UpdateHint(topLevelChange, frameChange);
    1: 
    1:       if (topLevelChange & nsChangeHint_ReconstructFrame) {
    1:         // If it's going to cause a framechange, then don't bother
    1:         // with the continuations or special siblings since they'll be
    1:         // clobbered by the frame reconstruct anyway.
    1:         NS_ASSERTION(!frame->GetPrevContinuation(),
    1:                      "continuing frame had more severe impact than first-in-flow");
11409:         return;
    1:       }
    1: 
    1:       frame = frame->GetNextContinuation();
    1:     } while (frame);
    1: 
    1:     // Might we have special siblings?
    1:     if (!(frame2->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
    1:       // nothing more to do here
11409:       return;
    1:     }
    1:     
 3233:     frame2 = static_cast<nsIFrame*>
39965:       (propTable->Get(frame2, nsIFrame::IBSplitSpecialSibling()));
    1:     frame = frame2;
    1:   } while (frame2);
    1: }
    1: 
    1: // Capture state for a given frame.
    1: // Accept a content id here, in some cases we may not have content (scroll position)
    1: void
    1: nsFrameManager::CaptureFrameStateFor(nsIFrame* aFrame,
    1:                                      nsILayoutHistoryState* aState,
    1:                                      nsIStatefulFrame::SpecialStateID aID)
    1: {
    1:   if (!aFrame || !aState) {
    1:     NS_WARNING("null frame, or state");
    1:     return;
    1:   }
    1: 
    1:   // Only capture state for stateful frames
23554:   nsIStatefulFrame* statefulFrame = do_QueryFrame(aFrame);
    1:   if (!statefulFrame) {
    1:     return;
    1:   }
    1: 
    1:   // Capture the state, exit early if we get null (nothing to save)
    1:   nsAutoPtr<nsPresState> frameState;
    1:   nsresult rv = statefulFrame->SaveState(aID, getter_Transfers(frameState));
    1:   if (!frameState) {
    1:     return;
    1:   }
    1: 
    1:   // Generate the hash key to store the state under
    1:   // Exit early if we get empty key
    1:   nsCAutoString stateKey;
    1:   nsIContent* content = aFrame->GetContent();
    1:   nsIDocument* doc = content ? content->GetCurrentDoc() : nsnull;
    1:   rv = nsContentUtils::GenerateStateKey(content, doc, aID, stateKey);
    1:   if(NS_FAILED(rv) || stateKey.IsEmpty()) {
    1:     return;
    1:   }
    1: 
    1:   // Store the state
    1:   rv = aState->AddState(stateKey, frameState);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // aState owns frameState now.
    1:     frameState.forget();
    1:   }
    1: }
    1: 
    1: void
    1: nsFrameManager::CaptureFrameState(nsIFrame* aFrame,
    1:                                   nsILayoutHistoryState* aState)
    1: {
    1:   NS_PRECONDITION(nsnull != aFrame && nsnull != aState, "null parameters passed in");
    1: 
    1:   CaptureFrameStateFor(aFrame, aState);
    1: 
    1:   // Now capture state recursively for the frame hierarchy rooted at aFrame
77153:   nsIFrame::ChildListIterator lists(aFrame);
77153:   for (; !lists.IsDone(); lists.Next()) {
77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
77153:       CaptureFrameState(childFrames.get(), aState);
    1:     }
77153:   }
    1: }
    1: 
    1: // Restore state for a given frame.
    1: // Accept a content id here, in some cases we may not have content (scroll position)
    1: void
    1: nsFrameManager::RestoreFrameStateFor(nsIFrame* aFrame,
    1:                                      nsILayoutHistoryState* aState,
    1:                                      nsIStatefulFrame::SpecialStateID aID)
    1: {
    1:   if (!aFrame || !aState) {
    1:     NS_WARNING("null frame or state");
    1:     return;
    1:   }
    1: 
22262:   // Only restore state for stateful frames
23554:   nsIStatefulFrame* statefulFrame = do_QueryFrame(aFrame);
    1:   if (!statefulFrame) {
    1:     return;
    1:   }
    1: 
    1:   // Generate the hash key the state was stored under
    1:   // Exit early if we get empty key
    1:   nsIContent* content = aFrame->GetContent();
    1:   // If we don't have content, we can't generate a hash
    1:   // key and there's probably no state information for us.
    1:   if (!content) {
    1:     return;
    1:   }
    1: 
    1:   nsCAutoString stateKey;
    1:   nsIDocument* doc = content->GetCurrentDoc();
    1:   nsresult rv = nsContentUtils::GenerateStateKey(content, doc, aID, stateKey);
    1:   if (NS_FAILED(rv) || stateKey.IsEmpty()) {
    1:     return;
    1:   }
    1: 
    1:   // Get the state from the hash
    1:   nsPresState *frameState;
    1:   rv = aState->GetState(stateKey, &frameState);
    1:   if (!frameState) {
    1:     return;
    1:   }
    1: 
    1:   // Restore it
    1:   rv = statefulFrame->RestoreState(frameState);
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   // If we restore ok, remove the state from the state table
    1:   aState->RemoveState(stateKey);
    1: }
    1: 
    1: void
    1: nsFrameManager::RestoreFrameState(nsIFrame* aFrame,
    1:                                   nsILayoutHistoryState* aState)
    1: {
    1:   NS_PRECONDITION(nsnull != aFrame && nsnull != aState, "null parameters passed in");
    1:   
    1:   RestoreFrameStateFor(aFrame, aState);
    1: 
    1:   // Now restore state recursively for the frame hierarchy rooted at aFrame
77153:   nsIFrame::ChildListIterator lists(aFrame);
77153:   for (; !lists.IsDone(); lists.Next()) {
77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
77153:       RestoreFrameState(childFrames.get(), aState);
    1:     }
77153:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: static PLHashNumber
    1: HashKey(void* key)
    1: {
    1:   return NS_PTR_TO_INT32(key);
    1: }
    1: 
    1: static PRIntn
    1: CompareKeys(void* key1, void* key2)
    1: {
    1:   return key1 == key2;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsFrameManagerBase::UndisplayedMap::UndisplayedMap(PRUint32 aNumBuckets)
    1: {
    1:   MOZ_COUNT_CTOR(nsFrameManagerBase::UndisplayedMap);
    1:   mTable = PL_NewHashTable(aNumBuckets, (PLHashFunction)HashKey,
    1:                            (PLHashComparator)CompareKeys,
    1:                            (PLHashComparator)nsnull,
    1:                            nsnull, nsnull);
    1:   mLastLookup = nsnull;
    1: }
    1: 
    1: nsFrameManagerBase::UndisplayedMap::~UndisplayedMap(void)
    1: {
    1:   MOZ_COUNT_DTOR(nsFrameManagerBase::UndisplayedMap);
    1:   Clear();
    1:   PL_HashTableDestroy(mTable);
    1: }
    1: 
    1: PLHashEntry**  
    1: nsFrameManagerBase::UndisplayedMap::GetEntryFor(nsIContent* aParentContent)
    1: {
    1:   if (mLastLookup && (aParentContent == (*mLastLookup)->key)) {
    1:     return mLastLookup;
    1:   }
    1:   PLHashNumber hashCode = NS_PTR_TO_INT32(aParentContent);
    1:   PLHashEntry** entry = PL_HashTableRawLookup(mTable, hashCode, aParentContent);
    1:   if (*entry) {
    1:     mLastLookup = entry;
    1:   }
    1:   return entry;
    1: }
    1: 
    1: UndisplayedNode* 
    1: nsFrameManagerBase::UndisplayedMap::GetFirstNode(nsIContent* aParentContent)
    1: {
    1:   PLHashEntry** entry = GetEntryFor(aParentContent);
    1:   if (*entry) {
    1:     return (UndisplayedNode*)((*entry)->value);
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: void
    1: nsFrameManagerBase::UndisplayedMap::AppendNodeFor(UndisplayedNode* aNode,
    1:                                                   nsIContent* aParentContent)
    1: {
    1:   PLHashEntry** entry = GetEntryFor(aParentContent);
    1:   if (*entry) {
    1:     UndisplayedNode*  node = (UndisplayedNode*)((*entry)->value);
    1:     while (node->mNext) {
    1:       if (node->mContent == aNode->mContent) {
    1:         // We actually need to check this in optimized builds because
    1:         // there are some callers that do this.  See bug 118014, bug
    1:         // 136704, etc.
    1:         NS_NOTREACHED("node in map twice");
    1:         delete aNode;
    1:         return;
    1:       }
    1:       node = node->mNext;
    1:     }
    1:     node->mNext = aNode;
    1:   }
    1:   else {
    1:     PLHashNumber hashCode = NS_PTR_TO_INT32(aParentContent);
    1:     PL_HashTableRawAdd(mTable, entry, hashCode, aParentContent, aNode);
    1:     mLastLookup = nsnull; // hashtable may have shifted bucket out from under us
    1:   }
    1: }
    1: 
    1: nsresult 
    1: nsFrameManagerBase::UndisplayedMap::AddNodeFor(nsIContent* aParentContent,
    1:                                                nsIContent* aChild, 
    1:                                                nsStyleContext* aStyle)
    1: {
    1:   UndisplayedNode*  node = new UndisplayedNode(aChild, aStyle);
    1: 
    1:   AppendNodeFor(node, aParentContent);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameManagerBase::UndisplayedMap::RemoveNodeFor(nsIContent* aParentContent,
    1:                                                   UndisplayedNode* aNode)
    1: {
    1:   PLHashEntry** entry = GetEntryFor(aParentContent);
    1:   NS_ASSERTION(*entry, "content not in map");
    1:   if (*entry) {
    1:     if ((UndisplayedNode*)((*entry)->value) == aNode) {  // first node
    1:       if (aNode->mNext) {
    1:         (*entry)->value = aNode->mNext;
    1:         aNode->mNext = nsnull;
    1:       }
    1:       else {
    1:         PL_HashTableRawRemove(mTable, entry, *entry);
    1:         mLastLookup = nsnull; // hashtable may have shifted bucket out from under us
    1:       }
    1:     }
    1:     else {
    1:       UndisplayedNode*  node = (UndisplayedNode*)((*entry)->value);
    1:       while (node->mNext) {
    1:         if (node->mNext == aNode) {
    1:           node->mNext = aNode->mNext;
    1:           aNode->mNext = nsnull;
    1:           break;
    1:         }
    1:         node = node->mNext;
    1:       }
    1:     }
    1:   }
    1:   delete aNode;
    1: }
    1: 
    1: void
    1: nsFrameManagerBase::UndisplayedMap::RemoveNodesFor(nsIContent* aParentContent)
    1: {
    1:   PLHashEntry** entry = GetEntryFor(aParentContent);
    1:   NS_ASSERTION(entry, "content not in map");
    1:   if (*entry) {
    1:     UndisplayedNode*  node = (UndisplayedNode*)((*entry)->value);
    1:     NS_ASSERTION(node, "null node for non-null entry in UndisplayedMap");
    1:     delete node;
    1:     PL_HashTableRawRemove(mTable, entry, *entry);
    1:     mLastLookup = nsnull; // hashtable may have shifted bucket out from under us
    1:   }
    1: }
    1: 
20261: static PRIntn
    1: RemoveUndisplayedEntry(PLHashEntry* he, PRIntn i, void* arg)
    1: {
    1:   UndisplayedNode*  node = (UndisplayedNode*)(he->value);
    1:   delete node;
    1:   // Remove and free this entry and continue enumerating
    1:   return HT_ENUMERATE_REMOVE | HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: void
    1: nsFrameManagerBase::UndisplayedMap::Clear(void)
    1: {
    1:   mLastLookup = nsnull;
    1:   PL_HashTableEnumerateEntries(mTable, RemoveUndisplayedEntry, 0);
    1: }
