80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
74961: 
74961: /*
74961:  *
74961:  *
74961:  *
74961:  *
74961:  *
74961:  *
74961:  *
74961:  *********************************** WARNING ***********************************
74961:  *
74961:  * Do not edit this file without understanding where it comes from,
74961:  * Your changes are likely to be overwritten without warning.
74961:  *
80321:  * For more information on GCLI see:
80321:  * - https://github.com/mozilla/gcli/blob/master/docs/index.md
80321:  * - https://wiki.mozilla.org/DevTools/Features/GCLI
80321:  *
74961:  * The original source for this file is:
74961:  *  https://github.com/mozilla/gcli/
74961:  *
80321:  * This build of GCLI for Firefox comes from 4 bits of code:
80321:  * - prefix-gcli.jsm: Initial commentary and EXPORTED_SYMBOLS
80321:  * - console.js: Support code common to web content that is not part of the
80321:  *   default firefox chrome environment and is easy to shim.
80321:  * - mini_require: A very basic commonjs AMD (Asynchronous Modules Definition)
80321:  *   'require' implementation (which is just good enough to load GCLI). For
80321:  *   more, see http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition.
80321:  *   This alleviates the need for requirejs (http://requirejs.org/) which is
80321:  *   used when running in the browser. This code is provided by dryice.
80321:  * - A build of GCLI itself, packaged using dryice
80321:  * - suffix-gcli.jsm - code to require the gcli object for EXPORTED_SYMBOLS.
80321:  *
80321:  * See Makefile.dryice.js for more details of this build.
80321:  * For more details on dryice, see the https://github.com/mozilla/dryice
80321:  *
74961:  *******************************************************************************
74961:  *
74961:  *
74961:  *
74961:  *
74961:  *
74961:  *
74961:  *
74961:  *
74961:  *
74961:  */
74961: 
74961: ///////////////////////////////////////////////////////////////////////////////
74961: 
74961: var EXPORTED_SYMBOLS = [ "gcli" ];
74961: 
74961: 
80321: /**
80321:  * Expose a Node object. This allows us to use the Node constants without
80321:  * resorting to hardcoded numbers
80321:  */
80321: var Node = Components.interfaces.nsIDOMNode;
80321: 
80321: 
80321: Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
80321: 
80321: /**
80321:  * Define setTimeout and clearTimeout to match the browser functions
80321:  */
80321: var setTimeout;
80321: var clearTimeout;
80321: 
80321: (function() {
80321:   /**
80321:    * The next value to be returned by setTimeout
80321:    */
80321:   var nextID = 1;
80321: 
80321:   /**
80321:    * The map of outstanding timeouts
80321:    */
80321:   var timers = {};
80321: 
80321:   /**
80321:    * Object to be passed to Timer.initWithCallback()
80321:    */
80321:   function TimerCallback(callback) {
80321:     this._callback = callback;
80321:     var interfaces = [ Components.interfaces.nsITimerCallback ];
80321:     this.QueryInterface = XPCOMUtils.generateQI(interfaces);
80321:   }
80321: 
80321:   TimerCallback.prototype.notify = function(timer) {
80321:     try {
80321:       for (var timerID in timers) {
80321:         if (timers[timerID] === timer) {
80321:           delete timers[timerID];
80321:           break;
80321:         }
80321:       }
80321:       this._callback.apply(null, []);
80321:     }
80321:     catch (ex) {
80321:       console.error(ex);
80321:     }
80321:   };
80321: 
80321:   /**
80321:    * Executes a code snippet or a function after specified delay.
80321:    * This is designed to have the same interface contract as the browser
80321:    * function.
80321:    * @param callback is the function you want to execute after the delay.
80321:    * @param delay is the number of milliseconds that the function call should
80321:    * be delayed by. Note that the actual delay may be longer, see Notes below.
80321:    * @return the ID of the timeout, which can be used later with
80321:    * window.clearTimeout.
80321:    */
80321:   setTimeout = function setTimeout(callback, delay) {
80321:     var timer = Components.classes["@mozilla.org/timer;1"]
80321:                           .createInstance(Components.interfaces.nsITimer);
80321: 
80321:     var timerID = nextID++;
80321:     timers[timerID] = timer;
80321: 
80321:     timer.initWithCallback(new TimerCallback(callback), delay, timer.TYPE_ONE_SHOT);
80321:     return timerID;
80321:   };
80321: 
80321:   /**
80321:    * Clears the delay set by window.setTimeout() and prevents the callback from
80321:    * being executed (if it hasn't been executed already)
80321:    * @param timerID the ID of the timeout you wish to clear, as returned by
80321:    * window.setTimeout().
80321:    */
80321:   clearTimeout = function clearTimeout(timerID) {
80321:     var timer = timers[timerID];
80321:     if (timer) {
80321:       timer.cancel();
80321:       delete timers[timerID];
80321:     }
80321:   };
80321: })();
80321: 
80321: 
80321: /**
74961:  * This creates a console object that somewhat replicates Firebug's console
74961:  * object. It currently writes to dump(), but should write to the web
74961:  * console's chrome error section (when it has one)
74961:  */
80321: var console = {};
80321: (function() {
74961:   /**
74961:    * String utility to ensure that strings are a specified length. Strings
74961:    * that are too long are truncated to the max length and the last char is
74961:    * set to "_". Strings that are too short are left padded with spaces.
74961:    *
74961:    * @param {string} aStr
74961:    *        The string to format to the correct length
74961:    * @param {number} aMaxLen
74961:    *        The maximum allowed length of the returned string
74961:    * @param {number} aMinLen (optional)
74961:    *        The minimum allowed length of the returned string. If undefined,
74961:    *        then aMaxLen will be used
74961:    * @param {object} aOptions (optional)
74961:    *        An object allowing format customization. The only customization
74961:    *        allowed currently is 'truncate' which can take the value "start" to
74961:    *        truncate strings from the start as opposed to the end.
74961:    * @return {string}
74961:    *        The original string formatted to fit the specified lengths
74961:    */
74961:   function fmt(aStr, aMaxLen, aMinLen, aOptions) {
80321:     if (aMinLen == null) {
74961:       aMinLen = aMaxLen;
74961:     }
74961:     if (aStr == null) {
74961:       aStr = "";
74961:     }
74961:     if (aStr.length > aMaxLen) {
74961:       if (aOptions && aOptions.truncate == "start") {
74961:         return "_" + aStr.substring(aStr.length - aMaxLen + 1);
74961:       }
74961:       else {
74961:         return aStr.substring(0, aMaxLen - 1) + "_";
74961:       }
74961:     }
74961:     if (aStr.length < aMinLen) {
74961:       return Array(aMinLen - aStr.length + 1).join(" ") + aStr;
74961:     }
74961:     return aStr;
74961:   }
74961: 
74961:   /**
74961:    * Utility to extract the constructor name of an object.
74961:    * Object.toString gives: "[object ?????]"; we want the "?????".
74961:    *
74961:    * @param {object} aObj
74961:    *        The object from which to extract the constructor name
74961:    * @return {string}
74961:    *        The constructor name
74961:    */
74961:   function getCtorName(aObj) {
74961:     return Object.prototype.toString.call(aObj).slice(8, -1);
74961:   }
74961: 
74961:   /**
74961:    * A single line stringification of an object designed for use by humans
74961:    *
74961:    * @param {any} aThing
74961:    *        The object to be stringified
74961:    * @return {string}
74961:    *        A single line representation of aThing, which will generally be at
80321:    *        most 80 chars long
74961:    */
74961:   function stringify(aThing) {
74961:     if (aThing === undefined) {
74961:       return "undefined";
74961:     }
74961: 
74961:     if (aThing === null) {
74961:       return "null";
74961:     }
74961: 
74961:     if (typeof aThing == "object") {
80321:       var type = getCtorName(aThing);
80321:       if (type == "XULElement") {
80321:         return debugElement(aThing);
80321:       }
80321:       type = (type == "Object" ? "" : type + " ");
80321:       var json;
74961:       try {
80321:         json = JSON.stringify(aThing);
74961:       }
74961:       catch (ex) {
80321:         // Can't use a real ellipsis here, because cmd.exe isn't unicode-enabled
80321:         json = "{" + Object.keys(aThing).join(":..,") + ":.., " + "}";
80321:       }
80321:       return type + fmt(json, 50, 0);
80321:     }
80321: 
82513:     if (typeof aThing == "function") {
82513:       return fmt(aThing.toString().replace(/\s+/g, " "), 80, 0);
82513:     }
82513: 
82517:     var str = aThing.toString().replace(/\n/g, "|");
80321:     return fmt(str, 80, 0);
80321:   }
80321: 
80321:   /**
80321:    * Create a simple debug representation of a given element.
80321:    *
80321:    * @param {nsIDOMElement} aElement
80321:    *        The element to debug
80321:    * @return {string}
80321:    *        A simple single line representation of aElement
80321:    */
80321:   function debugElement(aElement) {
80321:     return "<" + aElement.tagName +
80321:         (aElement.id ? "#" + aElement.id : "") +
80321:         (aElement.className ?
80321:             "." + aElement.className.split(" ").join(" .") :
80321:             "") +
80321:         ">";
74961:   }
74961: 
74961:   /**
74961:    * A multi line stringification of an object, designed for use by humans
74961:    *
74961:    * @param {any} aThing
74961:    *        The object to be stringified
74961:    * @return {string}
74961:    *        A multi line representation of aThing
74961:    */
74961:   function log(aThing) {
80321:     if (aThing === null) {
80321:       return "null\n";
80321:     }
80321: 
80321:     if (aThing === undefined) {
80321:       return "undefined\n";
74961:     }
74961: 
74961:     if (typeof aThing == "object") {
74961:       var reply = "";
74961:       var type = getCtorName(aThing);
74961:       if (type == "Error") {
74961:         reply += "  " + aThing.message + "\n";
74961:         reply += logProperty("stack", aThing.stack);
74961:       }
80321:       else if (type == "XULElement") {
80321:         reply += "  " + debugElement(aThing) + " (XUL)\n";
80321:       }
74961:       else {
74961:         var keys = Object.getOwnPropertyNames(aThing);
74961:         if (keys.length > 0) {
74961:           reply += type + "\n";
74961:           keys.forEach(function(aProp) {
74961:             reply += logProperty(aProp, aThing[aProp]);
74961:           }, this);
74961:         }
74961:         else {
82513:           reply += type + "\n";
82513:           var root = aThing;
82513:           var logged = [];
82513:           while (root != null) {
82513:             var properties = Object.keys(root);
82513:             properties.sort();
82513:             properties.forEach(function(property) {
82513:               if (!(property in logged)) {
82513:                 logged[property] = property;
82513:                 reply += logProperty(property, aThing[property]);
82513:               }
82513:             });
82513: 
82513:             root = Object.getPrototypeOf(root);
82513:             if (root != null) {
82513:               reply += '  - prototype ' + getCtorName(root) + '\n';
82513:             }
74961:           }
74961:         }
74961:       }
74961: 
74961:       return reply;
74961:     }
74961: 
74961:     return "  " + aThing.toString() + "\n";
74961:   }
74961: 
74961:   /**
74961:    * Helper for log() which converts a property/value pair into an output
74961:    * string
74961:    *
74961:    * @param {string} aProp
74961:    *        The name of the property to include in the output string
74961:    * @param {object} aValue
74961:    *        Value assigned to aProp to be converted to a single line string
74961:    * @return {string}
74961:    *        Multi line output string describing the property/value pair
74961:    */
74961:   function logProperty(aProp, aValue) {
74961:     var reply = "";
74961:     if (aProp == "stack" && typeof value == "string") {
74961:       var trace = parseStack(aValue);
74961:       reply += formatTrace(trace);
74961:     }
74961:     else {
74961:       reply += "    - " + aProp + " = " + stringify(aValue) + "\n";
74961:     }
74961:     return reply;
74961:   }
74961: 
74961:   /**
74961:    * Parse a stack trace, returning an array of stack frame objects, where
74961:    * each has file/line/call members
74961:    *
74961:    * @param {string} aStack
74961:    *        The serialized stack trace
74961:    * @return {object[]}
74961:    *        Array of { file: "...", line: NNN, call: "..." } objects
74961:    */
74961:   function parseStack(aStack) {
74961:     var trace = [];
74961:     aStack.split("\n").forEach(function(line) {
74961:       if (!line) {
74961:         return;
74961:       }
74961:       var at = line.lastIndexOf("@");
74961:       var posn = line.substring(at + 1);
74961:       trace.push({
74961:         file: posn.split(":")[0],
74961:         line: posn.split(":")[1],
74961:         call: line.substring(0, at)
74961:       });
74961:     }, this);
74961:     return trace;
74961:   }
74961: 
74961:   /**
74961:    * parseStack() takes output from an exception from which it creates the an
74961:    * array of stack frame objects, this has the same output but using data from
74961:    * Components.stack
74961:    *
74961:    * @param {string} aFrame
74961:    *        The stack frame from which to begin the walk
74961:    * @return {object[]}
74961:    *        Array of { file: "...", line: NNN, call: "..." } objects
74961:    */
74961:   function getStack(aFrame) {
74961:     if (!aFrame) {
74961:       aFrame = Components.stack.caller;
74961:     }
74961:     var trace = [];
74961:     while (aFrame) {
74961:       trace.push({
74961:         file: aFrame.filename,
74961:         line: aFrame.lineNumber,
74961:         call: aFrame.name
74961:       });
74961:       aFrame = aFrame.caller;
74961:     }
74961:     return trace;
80321:   }
74961: 
74961:   /**
74961:    * Take the output from parseStack() and convert it to nice readable
74961:    * output
74961:    *
74961:    * @param {object[]} aTrace
74961:    *        Array of trace objects as created by parseStack()
74961:    * @return {string} Multi line report of the stack trace
74961:    */
74961:   function formatTrace(aTrace) {
74961:     var reply = "";
74961:     aTrace.forEach(function(frame) {
74961:       reply += fmt(frame.file, 20, 20, { truncate: "start" }) + " " +
74961:                fmt(frame.line, 5, 5) + " " +
74961:                fmt(frame.call, 75, 75) + "\n";
74961:     });
74961:     return reply;
74961:   }
74961: 
74961:   /**
74961:    * Create a function which will output a concise level of output when used
74961:    * as a logging function
74961:    *
74961:    * @param {string} aLevel
74961:    *        A prefix to all output generated from this function detailing the
74961:    *        level at which output occurred
74961:    * @return {function}
74961:    *        A logging function
74961:    * @see createMultiLineDumper()
74961:    */
74961:   function createDumper(aLevel) {
74961:     return function() {
74961:       var args = Array.prototype.slice.call(arguments, 0);
74961:       var data = args.map(function(arg) {
74961:         return stringify(arg);
74961:       });
74961:       dump(aLevel + ": " + data.join(", ") + "\n");
74961:     };
74961:   }
74961: 
74961:   /**
74961:    * Create a function which will output more detailed level of output when
74961:    * used as a logging function
74961:    *
74961:    * @param {string} aLevel
74961:    *        A prefix to all output generated from this function detailing the
74961:    *        level at which output occurred
74961:    * @return {function}
74961:    *        A logging function
74961:    * @see createDumper()
74961:    */
74961:   function createMultiLineDumper(aLevel) {
74961:     return function() {
74961:       dump(aLevel + "\n");
74961:       var args = Array.prototype.slice.call(arguments, 0);
74961:       args.forEach(function(arg) {
74961:         dump(log(arg));
74961:       });
74961:     };
74961:   }
74961: 
74961:   /**
80321:    * Build out the console object
80321:    */
80321:   console.debug = createMultiLineDumper("debug");
80321:   console.log = createDumper("log");
80321:   console.info = createDumper("info");
80321:   console.warn = createDumper("warn");
80321:   console.error = createMultiLineDumper("error");
80321:   console.trace = function Console_trace() {
74961:     var trace = getStack(Components.stack.caller);
74961:     dump(formatTrace(trace) + "\n");
74961:   },
80321:   console.clear = function Console_clear() {};
80321: 
80321:   console.dir = createMultiLineDumper("dir");
80321:   console.dirxml = createMultiLineDumper("dirxml");
80321:   console.group = createDumper("group");
80321:   console.groupEnd = createDumper("groupEnd");
80321: 
80321: })();
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
74961: 
74961: /**
74961:  * Define a module along with a payload.
80321:  * @param moduleName Name for the payload
80321:  * @param deps Ignored. For compatibility with CommonJS AMD Spec
80321:  * @param payload Function with (require, exports, module) params
74961:  */
74961: function define(moduleName, deps, payload) {
74961:   if (typeof moduleName != "string") {
74961:     console.error(this.depth + " Error: Module name is not a string.");
74961:     console.trace();
74961:     return;
74961:   }
74961: 
74961:   if (arguments.length == 2) {
74961:     payload = deps;
74961:   }
74961: 
80321:   if (define.debugDependencies) {
74961:     console.log("define: " + moduleName + " -> " + payload.toString()
74961:         .slice(0, 40).replace(/\n/, '\\n').replace(/\r/, '\\r') + "...");
74961:   }
74961: 
74961:   if (moduleName in define.modules) {
74961:     console.error(this.depth + " Error: Redefining module: " + moduleName);
74961:   }
74961:   define.modules[moduleName] = payload;
80321: }
74961: 
74961: /**
74961:  * The global store of un-instantiated modules
74961:  */
74961: define.modules = {};
74961: 
80321: /**
80321:  * Should we console.log on module definition/instantiation/requirement?
80321:  */
80321: define.debugDependencies = false;
80321: 
80321: 
80321: /**
80321:  * Self executing function in which Domain is defined, and attached to define
80321:  */
80321: (function() {
74961:   /**
74961:    * We invoke require() in the context of a Domain so we can have multiple
74961:    * sets of modules running separate from each other.
74961:    * This contrasts with JSMs which are singletons, Domains allows us to
74961:    * optionally load a CommonJS module twice with separate data each time.
74961:    * Perhaps you want 2 command lines with a different set of commands in each,
74961:    * for example.
74961:    */
74961:   function Domain() {
74961:     this.modules = {};
74961: 
80321:     if (define.debugDependencies) {
74961:       this.depth = "";
74961:     }
74961:   }
74961: 
74961:   /**
74961:    * Lookup module names and resolve them by calling the definition function if
74961:    * needed.
74961:    * There are 2 ways to call this, either with an array of dependencies and a
74961:    * callback to call when the dependencies are found (which can happen
80321:    * asynchronously in an in-page context) or with a single string an no
80321:    * callback where the dependency is resolved synchronously and returned.
74961:    * The API is designed to be compatible with the CommonJS AMD spec and
74961:    * RequireJS.
80321:    * @param deps A name, or array of names for the payload
80321:    * @param callback Function to call when the dependencies are resolved
80321:    * @return The module required or undefined for array/callback method
74961:    */
74961:   Domain.prototype.require = function(deps, callback) {
74961:     if (Array.isArray(deps)) {
74961:       var params = deps.map(function(dep) {
74961:         return this.lookup(dep);
74961:       }, this);
74961:       if (callback) {
74961:         callback.apply(null, params);
74961:       }
74961:       return undefined;
74961:     }
74961:     else {
74961:       return this.lookup(deps);
74961:     }
74961:   };
74961: 
74961:   /**
74961:    * Lookup module names and resolve them by calling the definition function if
74961:    * needed.
80321:    * @param moduleName A name for the payload to lookup
80321:    * @return The module specified by aModuleName or null if not found
74961:    */
74961:   Domain.prototype.lookup = function(moduleName) {
74961:     if (moduleName in this.modules) {
74961:       var module = this.modules[moduleName];
80321:       if (define.debugDependencies) {
74961:         console.log(this.depth + " Using module: " + moduleName);
74961:       }
74961:       return module;
74961:     }
74961: 
74961:     if (!(moduleName in define.modules)) {
74961:       console.error(this.depth + " Missing module: " + moduleName);
74961:       return null;
74961:     }
74961: 
74961:     var module = define.modules[moduleName];
74961: 
80321:     if (define.debugDependencies) {
74961:       console.log(this.depth + " Compiling module: " + moduleName);
74961:     }
74961: 
74961:     if (typeof module == "function") {
80321:       if (define.debugDependencies) {
74961:         this.depth += ".";
74961:       }
74961: 
74961:       var exports = {};
74961:       try {
74961:         module(this.require.bind(this), exports, { id: moduleName, uri: "" });
74961:       }
74961:       catch (ex) {
74961:         console.error("Error using module: " + moduleName, ex);
74961:         throw ex;
74961:       }
74961:       module = exports;
74961: 
80321:       if (define.debugDependencies) {
74961:         this.depth = this.depth.slice(0, -1);
74961:       }
74961:     }
74961: 
74961:     // cache the resulting module object for next time
74961:     this.modules[moduleName] = module;
74961: 
74961:     return module;
74961:   };
74961: 
74961:   /**
74961:    * Expose the Domain constructor and a global domain (on the define function
80321:    * to avoid exporting more than we need. This is a common pattern with
80321:    * require systems)
74961:    */
74961:   define.Domain = Domain;
74961:   define.globalDomain = new Domain();
80321: })();
74961: 
74961: /**
74961:  * Expose a default require function which is the require of the global
74961:  * sandbox to make it easy to use.
74961:  */
74961: var require = define.globalDomain.require.bind(define.globalDomain);
74961: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80931: var mozl10n = {};
80931: 
80931: (function(aMozl10n) {
80931:   var temp = {};
80931:   Components.utils.import("resource://gre/modules/Services.jsm", temp);
80931:   var stringBundle = temp.Services.strings.createBundle(
80931:           "chrome://browser/locale/devtools/gclicommands.properties");
80931: 
80931:   /**
80931:    * Lookup a string in the GCLI string bundle
80931:    * @param name The name to lookup
80931:    * @return The looked up name
80931:    */
80931:   aMozl10n.lookup = function(name) {
80931:     try {
80931:       return stringBundle.GetStringFromName(name);
80931:     }
80931:     catch (ex) {
80931:       throw new Error("Failure in lookup('" + name + "')");
80931:     }
80931:   };
80931: 
80931:   /**
80931:    * Lookup a string in the GCLI string bundle
80931:    * @param name The name to lookup
80931:    * @param swaps An array of swaps. See stringBundle.formatStringFromName
80931:    * @return The looked up name
80931:    */
80931:   aMozl10n.lookupFormat = function(name, swaps) {
80931:     try {
80931:       return stringBundle.formatStringFromName(name, swaps, swaps.length);
80931:     }
80931:     catch (ex) {
80931:       throw new Error("Failure in lookupFormat('" + name + "')");
80931:     }
80931:   };
80931: 
80931: })(mozl10n);
80931: 
84247: define('gcli/index', ['require', 'exports', 'module' , 'gcli/canon', 'gcli/types/basic', 'gcli/types/javascript', 'gcli/types/node', 'gcli/cli', 'gcli/commands/help', 'gcli/ui/console'], function(require, exports, module) {
80321: 
80321:   // The API for use by command authors
80321:   exports.addCommand = require('gcli/canon').addCommand;
80321:   exports.removeCommand = require('gcli/canon').removeCommand;
80931:   exports.lookup = mozl10n.lookup;
80931:   exports.lookupFormat = mozl10n.lookupFormat;
80321: 
80321:   // Internal startup process. Not exported
80321:   require('gcli/types/basic').startup();
80321:   require('gcli/types/javascript').startup();
80321:   require('gcli/types/node').startup();
80321:   require('gcli/cli').startup();
84244:   require('gcli/commands/help').startup();
80321: 
80321:   var Requisition = require('gcli/cli').Requisition;
84247:   var Console = require('gcli/ui/console').Console;
82513: 
80321:   var cli = require('gcli/cli');
80321:   var jstype = require('gcli/types/javascript');
80321:   var nodetype = require('gcli/types/node');
80321: 
80321:   /**
80321:    * API for use by HUDService only.
80321:    * This code is internal and subject to change without notice.
80321:    */
80321:   exports._internal = {
80321:     require: require,
80321:     define: define,
80321:     console: console,
80321: 
80321:     /**
80321:      * createView() for Firefox requires an options object with the following
80321:      * members:
80321:      * - contentDocument: From the window of the attached tab
80321:      * - chromeDocument: GCLITerm.document
80321:      * - environment.hudId: GCLITerm.hudId
80321:      * - jsEnvironment.globalObject: 'window'
80321:      * - jsEnvironment.evalFunction: 'eval' in a sandbox
80321:      * - inputElement: GCLITerm.inputNode
80321:      * - completeElement: GCLITerm.completeNode
80321:      * - gcliTerm: GCLITerm
80321:      * - hintElement: GCLITerm.hintNode
80321:      * - inputBackgroundElement: GCLITerm.inputStack
80321:      */
80321:     createView: function(opts) {
80321:       jstype.setGlobalObject(opts.jsEnvironment.globalObject);
80321:       nodetype.setDocument(opts.contentDocument);
80321:       cli.setEvalFunction(opts.jsEnvironment.evalFunction);
80321: 
82513:       if (opts.requisition == null) {
82513:         opts.requisition = new Requisition(opts.environment, opts.chromeDocument);
82513:       }
82513: 
84247:       opts.console = new Console(opts);
80321:     },
80321: 
80321:     /**
80321:      * Undo the effects of createView() to prevent memory leaks
80321:      */
80321:     removeView: function(opts) {
84247:       opts.console.destroy();
84247:       delete opts.console;
82513: 
82513:       opts.requisition.destroy();
82513:       delete opts.requisition;
80321: 
80321:       cli.unsetEvalFunction();
80321:       nodetype.unsetDocument();
80321:       jstype.unsetGlobalObject();
80321:     },
80321: 
80321:     commandOutputManager: require('gcli/canon').commandOutputManager
80321:   };
74961: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/canon', ['require', 'exports', 'module' , 'gcli/util', 'gcli/l10n', 'gcli/types', 'gcli/types/basic'], function(require, exports, module) {
80321: var canon = exports;
80321: 
80321: 
81345: var util = require('gcli/util');
80321: var l10n = require('gcli/l10n');
80321: 
80321: var types = require('gcli/types');
80321: var Status = require('gcli/types').Status;
80321: var BooleanType = require('gcli/types/basic').BooleanType;
80321: 
80321: 
80321: /**
80321:  * A lookup hash of our registered commands
80321:  */
80321: var commands = {};
80321: 
80321: /**
80321:  * A sorted list of command names, we regularly want them in order, so pre-sort
80321:  */
80321: var commandNames = [];
80321: 
80321: /**
80321:  * Implement the localization algorithm for any documentation objects (i.e.
80321:  * description and manual) in a command.
80321:  * @param data The data assigned to a description or manual property
80321:  * @param onUndefined If data == null, should we return the data untouched or
80321:  * lookup a 'we don't know' key in it's place.
80321:  */
80321: function lookup(data, onUndefined) {
80321:   if (data == null) {
80321:     if (onUndefined) {
80321:       return l10n.lookup(onUndefined);
80321:     }
80321: 
80321:     return data;
80321:   }
80321: 
80321:   if (typeof data === 'string') {
80321:     return data;
80321:   }
80321: 
80321:   if (typeof data === 'object') {
80321:     if (data.key) {
80321:       return l10n.lookup(data.key);
80321:     }
80321: 
80321:     var locales = l10n.getPreferredLocales();
80321:     var translated;
80321:     locales.some(function(locale) {
80321:       translated = data[locale];
80321:       return translated != null;
80321:     });
80321:     if (translated != null) {
80321:       return translated;
80321:     }
80321: 
80321:     console.error('Can\'t find locale in descriptions: ' +
80321:             'locales=' + JSON.stringify(locales) + ', ' +
80321:             'description=' + JSON.stringify(data));
80321:     return '(No description)';
80321:   }
80321: 
80321:   return l10n.lookup(onUndefined);
80321: }
80321: 
80321: /**
80321:  * The command object is mostly just setup around a commandSpec (as passed to
80321:  * #addCommand()).
80321:  */
80321: function Command(commandSpec) {
80321:   Object.keys(commandSpec).forEach(function(key) {
80321:     this[key] = commandSpec[key];
80321:   }, this);
80321: 
80321:   if (!this.name) {
80321:     throw new Error('All registered commands must have a name');
80321:   }
80321: 
80321:   if (this.params == null) {
80321:     this.params = [];
80321:   }
80321:   if (!Array.isArray(this.params)) {
80321:     throw new Error('command.params must be an array in ' + this.name);
80321:   }
80321: 
80321:   this.description = 'description' in this ? this.description : undefined;
80321:   this.description = lookup(this.description, 'canonDescNone');
80321:   this.manual = 'manual' in this ? this.manual : undefined;
80321:   this.manual = lookup(this.manual);
80321: 
80321:   // At this point this.params has nested param groups. We want to flatten it
80321:   // out and replace the param object literals with Parameter objects
80321:   var paramSpecs = this.params;
80321:   this.params = [];
80321: 
80321:   // Track if the user is trying to mix default params and param groups.
80321:   // All the non-grouped parameters must come before all the param groups
80321:   // because non-grouped parameters can be assigned positionally, so their
80321:   // index is important. We don't want 'holes' in the order caused by
80321:   // parameter groups.
80321:   var usingGroups = false;
80321: 
80321:   // In theory this could easily be made recursive, so param groups could
80321:   // contain nested param groups. Current thinking is that the added
80321:   // complexity for the UI probably isn't worth it, so this implementation
80321:   // prevents nesting.
80321:   paramSpecs.forEach(function(spec) {
80321:     if (!spec.group) {
80321:       if (usingGroups) {
80321:         console.error('Parameters can\'t come after param groups.' +
80321:             ' Ignoring ' + this.name + '/' + spec.name);
80321:       }
80321:       else {
80321:         var param = new Parameter(spec, this, null);
80321:         this.params.push(param);
80321:       }
80321:     }
80321:     else {
80321:       spec.params.forEach(function(ispec) {
80321:         var param = new Parameter(ispec, this, spec.group);
80321:         this.params.push(param);
80321:       }, this);
80321: 
80321:       usingGroups = true;
80321:     }
80321:   }, this);
80321: }
80321: 
80321: canon.Command = Command;
80321: 
80321: 
80321: /**
80321:  * A wrapper for a paramSpec so we can sort out shortened versions names for
80321:  * option switches
80321:  */
80321: function Parameter(paramSpec, command, groupName) {
80321:   this.command = command || { name: 'unnamed' };
80321: 
80321:   Object.keys(paramSpec).forEach(function(key) {
80321:     this[key] = paramSpec[key];
80321:   }, this);
80321: 
80321:   this.description = 'description' in this ? this.description : undefined;
80321:   this.description = lookup(this.description, 'canonDescNone');
80321:   this.manual = 'manual' in this ? this.manual : undefined;
80321:   this.manual = lookup(this.manual);
80321:   this.groupName = groupName;
80321: 
80321:   if (!this.name) {
80321:     throw new Error('In ' + this.command.name +
80321:       ': all params must have a name');
80321:   }
80321: 
80321:   var typeSpec = this.type;
80321:   this.type = types.getType(typeSpec);
80321:   if (this.type == null) {
80321:     console.error('Known types: ' + types.getTypeNames().join(', '));
80321:     throw new Error('In ' + this.command.name + '/' + this.name +
80321:       ': can\'t find type for: ' + JSON.stringify(typeSpec));
80321:   }
80321: 
80321:   // boolean parameters have an implicit defaultValue:false, which should
80321:   // not be changed. See the docs.
80321:   if (this.type instanceof BooleanType) {
80321:     if ('defaultValue' in this) {
80321:       console.error('In ' + this.command.name + '/' + this.name +
80321:           ': boolean parameters can not have a defaultValue.' +
80321:           ' Ignoring');
80321:     }
80321:     this.defaultValue = false;
80321:   }
80321: 
80321:   // Check the defaultValue for validity.
80321:   // Both undefined and null get a pass on this test. undefined is used when
80321:   // there is no defaultValue, and null is used when the parameter is
80321:   // optional, neither are required to parse and stringify.
80321:   if (this.defaultValue != null) {
80321:     try {
80321:       var defaultText = this.type.stringify(this.defaultValue);
80321:       var defaultConversion = this.type.parseString(defaultText);
80321:       if (defaultConversion.getStatus() !== Status.VALID) {
80321:         console.error('In ' + this.command.name + '/' + this.name +
80321:             ': Error round tripping defaultValue. status = ' +
80321:             defaultConversion.getStatus());
80321:       }
80321:     }
80321:     catch (ex) {
80321:       console.error('In ' + this.command.name + '/' + this.name +
80321:         ': ' + ex);
80321:     }
80321:   }
80321: }
80321: 
80321: /**
80321:  * Does the given name uniquely identify this param (among the other params
80321:  * in this command)
80321:  * @param name The name to check
80321:  */
80321: Parameter.prototype.isKnownAs = function(name) {
80321:   if (name === '--' + this.name) {
80321:     return true;
80321:   }
80321:   return false;
80321: };
80321: 
80321: /**
80321:  * Is the user required to enter data for this parameter? (i.e. has
80321:  * defaultValue been set to something other than undefined)
80321:  */
80321: Parameter.prototype.isDataRequired = function() {
80321:   return this.defaultValue === undefined;
80321: };
80321: 
80321: /**
80321:  * Are we allowed to assign data to this parameter using positional
80321:  * parameters?
80321:  */
80321: Parameter.prototype.isPositionalAllowed = function() {
80321:   return this.groupName == null;
80321: };
80321: 
80321: canon.Parameter = Parameter;
80321: 
80321: 
80321: /**
80321:  * Add a command to the canon of known commands.
80321:  * This function is exposed to the outside world (via gcli/index). It is
80321:  * documented in docs/index.md for all the world to see.
80321:  * @param commandSpec The command and its metadata.
80321:  * @return The new command
80321:  */
80321: canon.addCommand = function addCommand(commandSpec) {
80321:   var command = new Command(commandSpec);
80321:   commands[commandSpec.name] = command;
80321:   commandNames.push(commandSpec.name);
80321:   commandNames.sort();
80321: 
80321:   canon.canonChange();
80321:   return command;
80321: };
80321: 
80321: /**
80321:  * Remove an individual command. The opposite of #addCommand().
80321:  * @param commandOrName Either a command name or the command itself.
80321:  */
80321: canon.removeCommand = function removeCommand(commandOrName) {
80321:   var name = typeof commandOrName === 'string' ?
80321:           commandOrName :
80321:           commandOrName.name;
80321:   delete commands[name];
80321:   commandNames = commandNames.filter(function(test) {
80321:     return test !== name;
80321:   });
80321: 
80321:   canon.canonChange();
80321: };
80321: 
80321: /**
80321:  * Retrieve a command by name
80321:  * @param name The name of the command to retrieve
80321:  */
80321: canon.getCommand = function getCommand(name) {
84244:   // '|| undefined' is to silence 'reference to undefined property' warnings
84244:   return commands[name] || undefined;
80321: };
80321: 
80321: /**
80321:  * Get an array of all the registered commands.
80321:  */
80321: canon.getCommands = function getCommands() {
80321:   // return Object.values(commands);
80321:   return Object.keys(commands).map(function(name) {
80321:     return commands[name];
80321:   }, this);
80321: };
80321: 
80321: /**
80321:  * Get an array containing the names of the registered commands.
80321:  */
80321: canon.getCommandNames = function getCommandNames() {
80321:   return commandNames.slice(0);
80321: };
80321: 
80321: /**
80321:  * Enable people to be notified of changes to the list of commands
80321:  */
81345: canon.canonChange = util.createEvent('canon.canonChange');
80321: 
80321: /**
80321:  * CommandOutputManager stores the output objects generated by executed
80321:  * commands.
80321:  *
80321:  * CommandOutputManager is exposed (via canon.commandOutputManager) to the the
80321:  * outside world and could (but shouldn't) be used before gcli.startup() has
80321:  * been called. This could should be defensive to that where possible, and we
80321:  * should certainly document if the use of it or similar will fail if used too
80321:  * soon.
80321:  */
80321: function CommandOutputManager() {
81345:   this._event = util.createEvent('CommandOutputManager');
80321: }
80321: 
80321: /**
80321:  * Call this method to notify the manager (and therefore all listeners) of a
80321:  * new or updated command output.
80321:  * @param output The command output object that has been created or updated.
80321:  */
80321: CommandOutputManager.prototype.sendCommandOutput = function(output) {
80321:   this._event({ output: output });
80321: };
80321: 
80321: /**
80321:  * Register a function to be called whenever there is a new command output
80321:  * object.
80321:  */
80321: CommandOutputManager.prototype.addListener = function(fn, ctx) {
80321:   this._event.add(fn, ctx);
80321: };
80321: 
80321: /**
80321:  * Undo the effects of CommandOutputManager.addListener()
80321:  */
80321: CommandOutputManager.prototype.removeListener = function(fn, ctx) {
80321:   this._event.remove(fn, ctx);
80321: };
80321: 
80321: canon.CommandOutputManager = CommandOutputManager;
80321: 
80321: /**
80321:  * We maintain a global command output manager for the majority case where
80321:  * there is only one important set of outputs.
80321:  */
80321: canon.commandOutputManager = new CommandOutputManager();
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/util', ['require', 'exports', 'module' ], function(require, exports, module) {
80321: 
80321: /*
82513:  * A number of DOM manipulation and event handling utilities.
80321:  */
80321: 
80321: 
80321: //------------------------------------------------------------------------------
80321: 
80321: /**
80321:  * Create an event.
80321:  * For use as follows:
81344:  *
80321:  *   function Hat() {
80321:  *     this.putOn = createEvent();
80321:  *     ...
80321:  *   }
80321:  *   Hat.prototype.adorn = function(person) {
80321:  *     this.putOn({ hat: hat, person: person });
80321:  *     ...
80321:  *   }
80321:  *
80321:  *   var hat = new Hat();
80321:  *   hat.putOn.add(function(ev) {
80321:  *     console.log('The hat ', ev.hat, ' has is worn by ', ev.person);
80321:  *   }, scope);
81344:  *
81344:  * @param name Optional name to help with debugging
80321:  */
80321: exports.createEvent = function(name) {
80321:   var handlers = [];
80321: 
80321:   /**
80321:    * This is how the event is triggered.
80321:    * @param ev The event object to be passed to the event listeners
80321:    */
80321:   var event = function(ev) {
80321:     // Use for rather than forEach because it step debugs better, which is
80321:     // important for debugging events
80321:     for (var i = 0; i < handlers.length; i++) {
80321:       var handler = handlers[i];
80321:       handler.func.call(handler.scope, ev);
80321:     }
80321:   };
80321: 
80321:   /**
80321:    * Add a new handler function
80321:    * @param func The function to call when this event is triggered
80321:    * @param scope Optional 'this' object for the function call
80321:    */
80321:   event.add = function(func, scope) {
80321:     handlers.push({ func: func, scope: scope });
80321:   };
80321: 
80321:   /**
80321:    * Remove a handler function added through add(). Both func and scope must
80321:    * be strict equals (===) the values used in the call to add()
80321:    * @param func The function to call when this event is triggered
80321:    * @param scope Optional 'this' object for the function call
80321:    */
80321:   event.remove = function(func, scope) {
80321:     handlers = handlers.filter(function(test) {
80321:       return test.func !== func && test.scope !== scope;
80321:     });
80321:   };
80321: 
80321:   /**
80321:    * Remove all handlers.
80321:    * Reset the state of this event back to it's post create state
80321:    */
80321:   event.removeAll = function() {
80321:     handlers = [];
80321:   };
80321: 
80321:   return event;
80321: };
80321: 
80321: 
80321: //------------------------------------------------------------------------------
80321: 
80321: var dom = {};
80321: 
84244: /**
84244:  * XHTML namespace
84244:  */
82513: dom.NS_XHTML = 'http://www.w3.org/1999/xhtml';
80321: 
80321: /**
84244:  * XUL namespace
84244:  */
84244: dom.NS_XUL = 'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul';
84244: 
84244: /**
82516:  * Create an HTML or XHTML element depending on whether the document is HTML
82516:  * or XML based. Where HTML/XHTML elements are distinguished by whether they
82516:  * are created using doc.createElementNS('http://www.w3.org/1999/xhtml', tag)
82516:  * or doc.createElement(tag)
82516:  * If you want to create a XUL element then you don't have a problem knowing
82516:  * what namespace you want.
80321:  * @param doc The document in which to create the element
80321:  * @param tag The name of the tag to create
80321:  * @returns The created element
80321:  */
82516: dom.createElement = function(doc, tag) {
82516:   if (dom.isXmlDocument(doc)) {
82516:     return doc.createElementNS(dom.NS_XHTML, tag);
82516:   }
82516:   else {
80321:     return doc.createElement(tag);
80321:   }
80321: };
80321: 
80321: /**
80321:  * Remove all the child nodes from this node
81344:  * @param elem The element that should have it's children removed
81344:  */
81344: dom.clearElement = function(elem) {
81344:   while (elem.hasChildNodes()) {
81344:     elem.removeChild(elem.firstChild);
80321:   }
80321: };
80321: 
80321: /**
80321:  * Create a style element in the document head, and add the given CSS text to
80321:  * it.
80321:  * @param cssText The CSS declarations to append
80321:  * @param doc The document element to work from
80321:  */
80321: dom.importCss = function(cssText, doc) {
80321:   doc = doc || document;
80321: 
80321:   var style = dom.createElement(doc, 'style');
80321:   style.appendChild(doc.createTextNode(cssText));
80321: 
80321:   var head = doc.getElementsByTagName('head')[0] || doc.documentElement;
80321:   head.appendChild(style);
80321: 
80321:   return style;
80321: };
80321: 
80321: /**
82516:  * There are problems with innerHTML on XML documents, so we need to do a dance
82516:  * using document.createRange().createContextualFragment() when in XML mode
80321:  */
81344: dom.setInnerHtml = function(elem, html) {
82516:   if (dom.isXmlDocument(elem.ownerDocument)) {
84252:     try {
81344:       dom.clearElement(elem);
82513:       html = '<div xmlns="' + dom.NS_XHTML + '">' + html + '</div>';
81344:       var range = elem.ownerDocument.createRange();
84244:       var child = range.createContextualFragment(html).firstChild;
82513:       while (child.hasChildNodes()) {
82513:         elem.appendChild(child.firstChild);
82513:       }
80321:     }
84252:     catch (ex) {
84252:       console.error('Bad XHTML', ex);
84252:       console.trace();
84252:       throw ex;
84252:     }
84252:   }
80321:   else {
81344:     elem.innerHTML = html;
80321:   }
80321: };
80321: 
82516: /**
84245:  * How to detect if we're in an XML document.
84245:  * In a Mozilla we check that document.xmlVersion = null, however in Chrome
84245:  * we use document.contentType = undefined.
82516:  * @param doc The document element to work from (defaulted to the global
82516:  * 'document' if missing
82516:  */
82516: dom.isXmlDocument = function(doc) {
82516:   doc = doc || document;
82516:   // Best test for Firefox
82516:   if (doc.contentType && doc.contentType != 'text/html') {
82516:     return true;
82516:   }
82516:   // Best test for Chrome
82516:   if (doc.xmlVersion != null) {
82516:     return true;
82516:   }
82516:   return false;
82516: };
82516: 
80321: exports.dom = dom;
80321: 
80321: 
80321: //------------------------------------------------------------------------------
80321: 
80321: /**
80321:  * Various event utilities
80321:  */
80321: var event = {};
80321: 
80321: /**
80321:  * Keyboard handling is a mess. http://unixpapa.com/js/key.html
80321:  * It would be good to use DOM L3 Keyboard events,
80321:  * http://www.w3.org/TR/2010/WD-DOM-Level-3-Events-20100907/#events-keyboardevents
80321:  * however only Webkit supports them, and there isn't a shim on Monernizr:
80321:  * https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills
80321:  * and when the code that uses this KeyEvent was written, nothing was clear,
80321:  * so instead, we're using this unmodern shim:
80321:  * http://stackoverflow.com/questions/5681146/chrome-10-keyevent-or-something-similar-to-firefoxs-keyevent
80321:  * See BUG 664991: GCLI's keyboard handling should be updated to use DOM-L3
80321:  * https://bugzilla.mozilla.org/show_bug.cgi?id=664991
80321:  */
80321: if ('KeyEvent' in this) {
80321:   event.KeyEvent = this.KeyEvent;
80321: }
80321: else {
80321:   event.KeyEvent = {
80321:     DOM_VK_CANCEL: 3,
80321:     DOM_VK_HELP: 6,
80321:     DOM_VK_BACK_SPACE: 8,
80321:     DOM_VK_TAB: 9,
80321:     DOM_VK_CLEAR: 12,
80321:     DOM_VK_RETURN: 13,
80321:     DOM_VK_ENTER: 14,
80321:     DOM_VK_SHIFT: 16,
80321:     DOM_VK_CONTROL: 17,
80321:     DOM_VK_ALT: 18,
80321:     DOM_VK_PAUSE: 19,
80321:     DOM_VK_CAPS_LOCK: 20,
80321:     DOM_VK_ESCAPE: 27,
80321:     DOM_VK_SPACE: 32,
80321:     DOM_VK_PAGE_UP: 33,
80321:     DOM_VK_PAGE_DOWN: 34,
80321:     DOM_VK_END: 35,
80321:     DOM_VK_HOME: 36,
80321:     DOM_VK_LEFT: 37,
80321:     DOM_VK_UP: 38,
80321:     DOM_VK_RIGHT: 39,
80321:     DOM_VK_DOWN: 40,
80321:     DOM_VK_PRINTSCREEN: 44,
80321:     DOM_VK_INSERT: 45,
80321:     DOM_VK_DELETE: 46,
80321:     DOM_VK_0: 48,
80321:     DOM_VK_1: 49,
80321:     DOM_VK_2: 50,
80321:     DOM_VK_3: 51,
80321:     DOM_VK_4: 52,
80321:     DOM_VK_5: 53,
80321:     DOM_VK_6: 54,
80321:     DOM_VK_7: 55,
80321:     DOM_VK_8: 56,
80321:     DOM_VK_9: 57,
80321:     DOM_VK_SEMICOLON: 59,
80321:     DOM_VK_EQUALS: 61,
80321:     DOM_VK_A: 65,
80321:     DOM_VK_B: 66,
80321:     DOM_VK_C: 67,
80321:     DOM_VK_D: 68,
80321:     DOM_VK_E: 69,
80321:     DOM_VK_F: 70,
80321:     DOM_VK_G: 71,
80321:     DOM_VK_H: 72,
80321:     DOM_VK_I: 73,
80321:     DOM_VK_J: 74,
80321:     DOM_VK_K: 75,
80321:     DOM_VK_L: 76,
80321:     DOM_VK_M: 77,
80321:     DOM_VK_N: 78,
80321:     DOM_VK_O: 79,
80321:     DOM_VK_P: 80,
80321:     DOM_VK_Q: 81,
80321:     DOM_VK_R: 82,
80321:     DOM_VK_S: 83,
80321:     DOM_VK_T: 84,
80321:     DOM_VK_U: 85,
80321:     DOM_VK_V: 86,
80321:     DOM_VK_W: 87,
80321:     DOM_VK_X: 88,
80321:     DOM_VK_Y: 89,
80321:     DOM_VK_Z: 90,
80321:     DOM_VK_CONTEXT_MENU: 93,
80321:     DOM_VK_NUMPAD0: 96,
80321:     DOM_VK_NUMPAD1: 97,
80321:     DOM_VK_NUMPAD2: 98,
80321:     DOM_VK_NUMPAD3: 99,
80321:     DOM_VK_NUMPAD4: 100,
80321:     DOM_VK_NUMPAD5: 101,
80321:     DOM_VK_NUMPAD6: 102,
80321:     DOM_VK_NUMPAD7: 103,
80321:     DOM_VK_NUMPAD8: 104,
80321:     DOM_VK_NUMPAD9: 105,
80321:     DOM_VK_MULTIPLY: 106,
80321:     DOM_VK_ADD: 107,
80321:     DOM_VK_SEPARATOR: 108,
80321:     DOM_VK_SUBTRACT: 109,
80321:     DOM_VK_DECIMAL: 110,
80321:     DOM_VK_DIVIDE: 111,
80321:     DOM_VK_F1: 112,
80321:     DOM_VK_F2: 113,
80321:     DOM_VK_F3: 114,
80321:     DOM_VK_F4: 115,
80321:     DOM_VK_F5: 116,
80321:     DOM_VK_F6: 117,
80321:     DOM_VK_F7: 118,
80321:     DOM_VK_F8: 119,
80321:     DOM_VK_F9: 120,
80321:     DOM_VK_F10: 121,
80321:     DOM_VK_F11: 122,
80321:     DOM_VK_F12: 123,
80321:     DOM_VK_F13: 124,
80321:     DOM_VK_F14: 125,
80321:     DOM_VK_F15: 126,
80321:     DOM_VK_F16: 127,
80321:     DOM_VK_F17: 128,
80321:     DOM_VK_F18: 129,
80321:     DOM_VK_F19: 130,
80321:     DOM_VK_F20: 131,
80321:     DOM_VK_F21: 132,
80321:     DOM_VK_F22: 133,
80321:     DOM_VK_F23: 134,
80321:     DOM_VK_F24: 135,
80321:     DOM_VK_NUM_LOCK: 144,
80321:     DOM_VK_SCROLL_LOCK: 145,
80321:     DOM_VK_COMMA: 188,
80321:     DOM_VK_PERIOD: 190,
80321:     DOM_VK_SLASH: 191,
80321:     DOM_VK_BACK_QUOTE: 192,
80321:     DOM_VK_OPEN_BRACKET: 219,
80321:     DOM_VK_BACK_SLASH: 220,
80321:     DOM_VK_CLOSE_BRACKET: 221,
80321:     DOM_VK_QUOTE: 222,
80321:     DOM_VK_META: 224
80321:   };
80321: }
80321: 
80321: exports.event = event;
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/l10n', ['require', 'exports', 'module' ], function(require, exports, module) {
80321: 
80321: Components.utils.import('resource://gre/modules/XPCOMUtils.jsm');
80321: Components.utils.import('resource://gre/modules/Services.jsm');
80321: 
80321: XPCOMUtils.defineLazyGetter(this, 'stringBundle', function () {
80321:   return Services.strings.createBundle('chrome://browser/locale/devtools/gcli.properties');
80321: });
80321: 
80321: /*
80321:  * Not supported when embedded - we're doing things the Mozilla way not the
80321:  * require.js way.
80321:  */
80321: exports.registerStringsSource = function(modulePath) {
80321:   throw new Error('registerStringsSource is not available in mozilla');
80321: };
80321: 
80321: exports.unregisterStringsSource = function(modulePath) {
80321:   throw new Error('unregisterStringsSource is not available in mozilla');
80321: };
80321: 
80321: exports.lookupSwap = function(key, swaps) {
80321:   throw new Error('lookupSwap is not available in mozilla');
80321: };
80321: 
80321: exports.lookupPlural = function(key, ord, swaps) {
80321:   throw new Error('lookupPlural is not available in mozilla');
80321: };
80321: 
80321: exports.getPreferredLocales = function() {
80321:   return [ 'root' ];
80321: };
80321: 
80321: /** @see lookup() in lib/gcli/l10n.js */
80321: exports.lookup = function(key) {
80321:   try {
80321:     return stringBundle.GetStringFromName(key);
80321:   }
80321:   catch (ex) {
80321:     console.error('Failed to lookup ', key, ex);
80321:     return key;
80321:   }
80321: };
80321: 
84253: /** @see propertyLookup in lib/gcli/l10n.js */
84253: exports.propertyLookup = Proxy.create({
84253:   get: function(rcvr, name) {
84253:     return exports.lookup(name);
84253:   }
84253: });
84253: 
80321: /** @see lookupFormat in lib/gcli/l10n.js */
80321: exports.lookupFormat = function(key, swaps) {
80321:   try {
80321:     return stringBundle.formatStringFromName(key, swaps, swaps.length);
80321:   }
80321:   catch (ex) {
80321:     console.error('Failed to format ', key, ex);
80321:     return key;
80321:   }
80321: };
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/types', ['require', 'exports', 'module' , 'gcli/argument'], function(require, exports, module) {
80321: var types = exports;
80321: 
80321: 
80321: var Argument = require('gcli/argument').Argument;
80321: 
80321: 
80321: /**
80321:  * Some types can detect validity, that is to say they can distinguish between
80321:  * valid and invalid values.
80321:  * We might want to change these constants to be numbers for better performance
80321:  */
80321: var Status = {
80321:   /**
80321:    * The conversion process worked without any problem, and the value is
80321:    * valid. There are a number of failure states, so the best way to check
80321:    * for failure is (x !== Status.VALID)
80321:    */
80321:   VALID: {
80321:     toString: function() { return 'VALID'; },
80321:     valueOf: function() { return 0; }
80321:   },
80321: 
80321:   /**
80321:    * A conversion process failed, however it was noted that the string
80321:    * provided to 'parse()' could be VALID by the addition of more characters,
80321:    * so the typing may not be actually incorrect yet, just unfinished.
80321:    * @see Status.ERROR
80321:    */
80321:   INCOMPLETE: {
80321:     toString: function() { return 'INCOMPLETE'; },
80321:     valueOf: function() { return 1; }
80321:   },
80321: 
80321:   /**
80321:    * The conversion process did not work, the value should be null and a
80321:    * reason for failure should have been provided. In addition some
80321:    * completion values may be available.
80321:    * @see Status.INCOMPLETE
80321:    */
80321:   ERROR: {
80321:     toString: function() { return 'ERROR'; },
80321:     valueOf: function() { return 2; }
80321:   },
80321: 
80321:   /**
80321:    * A combined status is the worser of the provided statuses. The statuses
80321:    * can be provided either as a set of arguments or a single array
80321:    */
80321:   combine: function() {
80321:     var combined = Status.VALID;
80321:     for (var i = 0; i < arguments.length; i++) {
80321:       var status = arguments[i];
80321:       if (Array.isArray(status)) {
80321:         status = Status.combine.apply(null, status);
80321:       }
80321:       if (status > combined) {
80321:         combined = status;
80321:       }
80321:     }
80321:     return combined;
80321:   }
80321: };
80321: types.Status = Status;
80321: 
80321: /**
80321:  * The type.parse() method converts an Argument into a value, Conversion is
80321:  * a wrapper to that value.
80321:  * Conversion is needed to collect a number of properties related to that
80321:  * conversion in one place, i.e. to handle errors and provide traceability.
80321:  * @param value The result of the conversion
80321:  * @param arg The data from which the conversion was made
80321:  * @param status See the Status values [VALID|INCOMPLETE|ERROR] defined above.
80321:  * The default status is Status.VALID.
80321:  * @param message If status=ERROR, there should be a message to describe the
80321:  * error. A message is not needed unless for other statuses, but could be
80321:  * present for any status including VALID (in the case where we want to note a
80321:  * warning, for example).
80321:  * See BUG 664676: GCLI conversion error messages should be localized
80321:  * @param predictions If status=INCOMPLETE, there could be predictions as to
80321:  * the options available to complete the input.
80321:  * We generally expect there to be about 7 predictions (to match human list
80321:  * comprehension ability) however it is valid to provide up to about 20,
80321:  * or less. It is the job of the predictor to decide a smart cut-off.
80321:  * For example if there are 4 very good matches and 4 very poor ones,
80321:  * probably only the 4 very good matches should be presented.
80321:  * The predictions are presented either as an array of prediction objects or as
80321:  * a function which returns this array when called with no parameters.
80321:  * Each prediction object has the following shape:
80321:  *     {
80321:  *       name: '...',     // textual completion. i.e. what the cli uses
80321:  *       value: { ... },  // value behind the textual completion
80321:  *       incomplete: true // this completion is only partial (optional)
80321:  *     }
80321:  * The 'incomplete' property could be used to denote a valid completion which
80321:  * could have sub-values (e.g. for tree navigation).
80321:  */
80321: function Conversion(value, arg, status, message, predictions) {
80321:   // The result of the conversion process. Will be null if status != VALID
80321:   this.value = value;
80321: 
80321:   // Allow us to trace where this Conversion came from
80321:   this.arg = arg;
80321:   if (arg == null) {
80321:     throw new Error('Missing arg');
80321:   }
80321: 
80321:   this._status = status || Status.VALID;
80321:   this.message = message;
80321:   this.predictions = predictions;
80321: }
80321: 
80321: types.Conversion = Conversion;
80321: 
80321: /**
80321:  * Ensure that all arguments that are part of this conversion know what they
80321:  * are assigned to.
80321:  * @param assignment The Assignment (param/conversion link) to inform the
80321:  * argument about.
80321:  */
80321: Conversion.prototype.assign = function(assignment) {
80321:   this.arg.assign(assignment);
80321: };
80321: 
80321: /**
80321:  * Work out if there is information provided in the contained argument.
80321:  */
80321: Conversion.prototype.isDataProvided = function() {
80321:   var argProvided = this.arg.text !== '';
80321:   return this.value !== undefined || argProvided;
80321: };
80321: 
80321: /**
80321:  * 2 conversions are equal if and only if their args are equal (argEquals) and
80321:  * their values are equal (valueEquals).
80321:  * @param that The conversion object to compare against.
80321:  */
80321: Conversion.prototype.equals = function(that) {
80321:   if (this === that) {
80321:     return true;
80321:   }
80321:   if (that == null) {
80321:     return false;
80321:   }
80321:   return this.valueEquals(that) && this.argEquals(that);
80321: };
80321: 
80321: /**
80321:  * Check that the value in this conversion is strict equal to the value in the
80321:  * provided conversion.
80321:  * @param that The conversion to compare values with
80321:  */
80321: Conversion.prototype.valueEquals = function(that) {
80321:   return this.value === that.value;
80321: };
80321: 
80321: /**
80321:  * Check that the argument in this conversion is equal to the value in the
80321:  * provided conversion as defined by the argument (i.e. arg.equals).
80321:  * @param that The conversion to compare arguments with
80321:  */
80321: Conversion.prototype.argEquals = function(that) {
80321:   return this.arg.equals(that.arg);
80321: };
80321: 
80321: /**
80321:  * Accessor for the status of this conversion
80321:  */
80321: Conversion.prototype.getStatus = function(arg) {
80321:   return this._status;
80321: };
80321: 
80321: /**
80321:  * Defined by the toString() value provided by the argument
80321:  */
80321: Conversion.prototype.toString = function() {
80321:   return this.arg.toString();
80321: };
80321: 
80321: /**
80321:  * If status === INCOMPLETE, then we may be able to provide predictions as to
80321:  * how the argument can be completed.
80321:  * @return An array of items, where each item is an object with the following
80321:  * properties:
80321:  * - name (mandatory): Displayed to the user, and typed in. No whitespace
80321:  * - description (optional): Short string for display in a tool-tip
80321:  * - manual (optional): Longer description which details usage
80321:  * - incomplete (optional): Indicates that the prediction if used should not
80321:  *   be considered necessarily sufficient, which typically will mean that the
80321:  *   UI should not append a space to the completion
80321:  * - value (optional): If a value property is present, this will be used as the
80321:  *   value of the conversion, otherwise the item itself will be used.
80321:  */
80321: Conversion.prototype.getPredictions = function() {
80321:   if (typeof this.predictions === 'function') {
80321:     return this.predictions();
80321:   }
80321:   return this.predictions || [];
80321: };
80321: 
80321: /**
80321:  * ArrayConversion is a special Conversion, needed because arrays are converted
80321:  * member by member rather then as a whole, which means we can track the
80321:  * conversion if individual array elements. So an ArrayConversion acts like a
80321:  * normal Conversion (which is needed as Assignment requires a Conversion) but
80321:  * it can also be devolved into a set of Conversions for each array member.
80321:  */
80321: function ArrayConversion(conversions, arg) {
80321:   this.arg = arg;
80321:   this.conversions = conversions;
80321:   this.value = conversions.map(function(conversion) {
80321:     return conversion.value;
80321:   }, this);
80321: 
80321:   this._status = Status.combine(conversions.map(function(conversion) {
80321:     return conversion.getStatus();
80321:   }));
80321: 
80321:   // This message is just for reporting errors like "not enough values"
80321:   // rather that for problems with individual values.
80321:   this.message = '';
80321: 
80321:   // Predictions are generally provided by individual values
80321:   this.predictions = [];
80321: }
80321: 
80321: ArrayConversion.prototype = Object.create(Conversion.prototype);
80321: 
80321: ArrayConversion.prototype.assign = function(assignment) {
80321:   this.conversions.forEach(function(conversion) {
80321:     conversion.assign(assignment);
80321:   }, this);
80321:   this.assignment = assignment;
80321: };
80321: 
80321: ArrayConversion.prototype.getStatus = function(arg) {
80321:   if (arg && arg.conversion) {
80321:     return arg.conversion.getStatus();
80321:   }
80321:   return this._status;
80321: };
80321: 
80321: ArrayConversion.prototype.isDataProvided = function() {
80321:   return this.conversions.length > 0;
80321: };
80321: 
80321: ArrayConversion.prototype.valueEquals = function(that) {
80321:   if (!(that instanceof ArrayConversion)) {
80321:     throw new Error('Can\'t compare values with non ArrayConversion');
80321:   }
80321: 
80321:   if (this.value === that.value) {
80321:     return true;
80321:   }
80321: 
80321:   if (this.value.length !== that.value.length) {
80321:     return false;
80321:   }
80321: 
80321:   for (var i = 0; i < this.conversions.length; i++) {
80321:     if (!this.conversions[i].valueEquals(that.conversions[i])) {
80321:       return false;
80321:     }
80321:   }
80321: 
80321:   return true;
80321: };
80321: 
80321: ArrayConversion.prototype.toString = function() {
80321:   return '[ ' + this.conversions.map(function(conversion) {
80321:     return conversion.toString();
80321:   }, this).join(', ') + ' ]';
80321: };
80321: 
80321: types.ArrayConversion = ArrayConversion;
80321: 
80321: 
80321: /**
80321:  * Most of our types are 'static' e.g. there is only one type of 'string',
80321:  * however some types like 'selection' and 'deferred' are customizable.
80321:  * The basic Type type isn't useful, but does provide documentation about what
80321:  * types do.
80321:  */
80321: function Type() {
80321: }
80321: 
80321: /**
80321:  * Convert the given <tt>value</tt> to a string representation.
80321:  * Where possible, there should be round-tripping between values and their
80321:  * string representations.
80321:  */
80321: Type.prototype.stringify = function(value) {
80321:   throw new Error('Not implemented');
80321: };
80321: 
80321: /**
80321:  * Convert the given <tt>arg</tt> to an instance of this type.
80321:  * Where possible, there should be round-tripping between values and their
80321:  * string representations.
80321:  * @param arg An instance of <tt>Argument</tt> to convert.
80321:  * @return Conversion
80321:  */
80321: Type.prototype.parse = function(arg) {
80321:   throw new Error('Not implemented');
80321: };
80321: 
80321: /**
80321:  * A convenience method for times when you don't have an argument to parse
80321:  * but instead have a string.
80321:  * @see #parse(arg)
80321:  */
80321: Type.prototype.parseString = function(str) {
80321:   return this.parse(new Argument(str));
80321: },
80321: 
80321: /**
80321:  * The plug-in system, and other things need to know what this type is
80321:  * called. The name alone is not enough to fully specify a type. Types like
80321:  * 'selection' and 'deferred' need extra data, however this function returns
80321:  * only the name, not the extra data.
80321:  */
80321: Type.prototype.name = undefined;
80321: 
80321: /**
80321:  * If there is some concept of a higher value, return it,
80321:  * otherwise return undefined.
80321:  */
80321: Type.prototype.increment = function(value) {
80321:   return undefined;
80321: };
80321: 
80321: /**
80321:  * If there is some concept of a lower value, return it,
80321:  * otherwise return undefined.
80321:  */
80321: Type.prototype.decrement = function(value) {
80321:   return undefined;
80321: };
80321: 
80321: /**
80321:  * There is interesting information (like predictions) in a conversion of
80321:  * nothing, the output of this can sometimes be customized.
80321:  * @return Conversion
80321:  */
80321: Type.prototype.getDefault = undefined;
80321: 
80321: types.Type = Type;
80321: 
80321: /**
80321:  * Private registry of types
80321:  * Invariant: types[name] = type.name
80321:  */
80321: var registeredTypes = {};
80321: 
80321: types.getTypeNames = function() {
80321:   return Object.keys(registeredTypes);
80321: };
80321: 
80321: /**
80321:  * Add a new type to the list available to the system.
80321:  * You can pass 2 things to this function - either an instance of Type, in
80321:  * which case we return this instance when #getType() is called with a 'name'
80321:  * that matches type.name.
80321:  * Also you can pass in a constructor (i.e. function) in which case when
80321:  * #getType() is called with a 'name' that matches Type.prototype.name we will
80321:  * pass the typeSpec into this constructor.
80321:  */
80321: types.registerType = function(type) {
80321:   if (typeof type === 'object') {
80321:     if (type instanceof Type) {
80321:       if (!type.name) {
80321:         throw new Error('All registered types must have a name');
80321:       }
80321:       registeredTypes[type.name] = type;
80321:     }
80321:     else {
80321:       throw new Error('Can\'t registerType using: ' + type);
80321:     }
80321:   }
80321:   else if (typeof type === 'function') {
80321:     if (!type.prototype.name) {
80321:       throw new Error('All registered types must have a name');
80321:     }
80321:     registeredTypes[type.prototype.name] = type;
80321:   }
80321:   else {
80321:     throw new Error('Unknown type: ' + type);
80321:   }
80321: };
80321: 
80321: types.registerTypes = function registerTypes(newTypes) {
80321:   Object.keys(newTypes).forEach(function(name) {
80321:     var type = newTypes[name];
80321:     type.name = name;
80321:     newTypes.registerType(type);
80321:   });
80321: };
80321: 
80321: /**
80321:  * Remove a type from the list available to the system
80321:  */
80321: types.deregisterType = function(type) {
80321:   delete registeredTypes[type.name];
80321: };
80321: 
80321: /**
80321:  * Find a type, previously registered using #registerType()
80321:  */
80321: types.getType = function(typeSpec) {
80321:   var type;
80321:   if (typeof typeSpec === 'string') {
80321:     type = registeredTypes[typeSpec];
80321:     if (typeof type === 'function') {
80321:       type = new type();
80321:     }
80321:     return type;
80321:   }
80321: 
80321:   if (typeof typeSpec === 'object') {
80321:     if (!typeSpec.name) {
80321:       throw new Error('Missing \'name\' member to typeSpec');
80321:     }
80321: 
80321:     type = registeredTypes[typeSpec.name];
80321:     if (typeof type === 'function') {
80321:       type = new type(typeSpec);
80321:     }
80321:     return type;
80321:   }
80321: 
80321:   throw new Error('Can\'t extract type from ' + typeSpec);
80321: };
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/argument', ['require', 'exports', 'module' ], function(require, exports, module) {
80321: var argument = exports;
80321: 
80321: 
80321: /**
80321:  * We record where in the input string an argument comes so we can report
80321:  * errors against those string positions.
80321:  * @param text The string (trimmed) that contains the argument
80321:  * @param prefix Knowledge of quotation marks and whitespace used prior to the
80321:  * text in the input string allows us to re-generate the original input from
80321:  * the arguments.
80321:  * @param suffix Any quotation marks and whitespace used after the text.
80321:  * Whitespace is normally placed in the prefix to the succeeding argument, but
80321:  * can be used here when this is the last argument.
80321:  * @constructor
80321:  */
80321: function Argument(text, prefix, suffix) {
80321:   if (text === undefined) {
80321:     this.text = '';
80321:     this.prefix = '';
80321:     this.suffix = '';
80321:   }
80321:   else {
80321:     this.text = text;
80321:     this.prefix = prefix !== undefined ? prefix : '';
80321:     this.suffix = suffix !== undefined ? suffix : '';
80321:   }
80321: }
80321: 
80321: /**
80321:  * Return the result of merging these arguments.
80321:  * case and some of the arguments are in quotation marks?
80321:  */
80321: Argument.prototype.merge = function(following) {
80321:   // Is it possible that this gets called when we're merging arguments
80321:   // for the single string?
80321:   return new Argument(
80321:     this.text + this.suffix + following.prefix + following.text,
80321:     this.prefix, following.suffix);
80321: };
80321: 
80321: /**
80321:  * Returns a new Argument like this one but with the text set to
80321:  * <tt>replText</tt> and the end adjusted to fit.
80321:  * @param replText Text to replace the old text value
80321:  */
80321: Argument.prototype.beget = function(replText, options) {
80321:   var prefix = this.prefix;
80321:   var suffix = this.suffix;
80321: 
80321:   var quote = (replText.indexOf(' ') >= 0 || replText.length == 0) ?
80321:       '\'' : '';
80321: 
80321:   if (options) {
80321:     prefix = (options.prefixSpace ? ' ' : '') + quote;
80321:     suffix = quote;
80321:   }
80321: 
80321:   return new Argument(replText, prefix, suffix);
80321: };
80321: 
80321: /**
80321:  * Is there any visible content to this argument?
80321:  */
80321: Argument.prototype.isBlank = function() {
80321:   return this.text === '' &&
80321:       this.prefix.trim() === '' &&
80321:       this.suffix.trim() === '';
80321: };
80321: 
80321: /**
80321:  * We need to keep track of which assignment we've been assigned to
80321:  */
80321: Argument.prototype.assign = function(assignment) {
80321:   this.assignment = assignment;
80321: };
80321: 
80321: /**
80321:  * Sub-classes of Argument are collections of arguments, getArgs() gets access
80321:  * to the members of the collection in order to do things like re-create input
80321:  * command lines. For the simple Argument case it's just an array containing
80321:  * only this.
80321:  */
80321: Argument.prototype.getArgs = function() {
80321:   return [ this ];
80321: };
80321: 
80321: /**
80321:  * We define equals to mean all arg properties are strict equals.
80321:  * Used by Conversion.argEquals and Conversion.equals and ultimately
80321:  * Assignment.equals to avoid reporting a change event when a new conversion
80321:  * is assigned.
80321:  */
80321: Argument.prototype.equals = function(that) {
80321:   if (this === that) {
80321:     return true;
80321:   }
80321:   if (that == null || !(that instanceof Argument)) {
80321:     return false;
80321:   }
80321: 
80321:   return this.text === that.text &&
80321:        this.prefix === that.prefix && this.suffix === that.suffix;
80321: };
80321: 
80321: /**
80321:  * Helper when we're putting arguments back together
80321:  */
80321: Argument.prototype.toString = function() {
80321:   // BUG 664207: We should re-escape escaped characters
80321:   // But can we do that reliably?
80321:   return this.prefix + this.text + this.suffix;
80321: };
80321: 
80321: /**
80321:  * Merge an array of arguments into a single argument.
80321:  * All Arguments in the array are expected to have the same emitter
80321:  */
80321: Argument.merge = function(argArray, start, end) {
80321:   start = (start === undefined) ? 0 : start;
80321:   end = (end === undefined) ? argArray.length : end;
80321: 
80321:   var joined;
80321:   for (var i = start; i < end; i++) {
80321:     var arg = argArray[i];
80321:     if (!joined) {
80321:       joined = arg;
80321:     }
80321:     else {
80321:       joined = joined.merge(arg);
80321:     }
80321:   }
80321:   return joined;
80321: };
80321: 
80321: argument.Argument = Argument;
80321: 
80321: 
80321: /**
80321:  * ScriptArgument is a marker that the argument is designed to be Javascript.
80321:  * It also implements the special rules that spaces after the { or before the
80321:  * } are part of the pre/suffix rather than the content.
80321:  */
80321: function ScriptArgument(text, prefix, suffix) {
80321:   this.text = text;
80321:   this.prefix = prefix !== undefined ? prefix : '';
80321:   this.suffix = suffix !== undefined ? suffix : '';
80321: 
80321:   while (this.text.charAt(0) === ' ') {
80321:     this.prefix = this.prefix + ' ';
80321:     this.text = this.text.substring(1);
80321:   }
80321: 
80321:   while (this.text.charAt(this.text.length - 1) === ' ') {
80321:     this.suffix = ' ' + this.suffix;
80321:     this.text = this.text.slice(0, -1);
80321:   }
80321: }
80321: 
80321: ScriptArgument.prototype = Object.create(Argument.prototype);
80321: 
80321: /**
80321:  * Returns a new Argument like this one but with the text set to
80321:  * <tt>replText</tt> and the end adjusted to fit.
80321:  * @param replText Text to replace the old text value
80321:  */
80321: ScriptArgument.prototype.beget = function(replText, options) {
80321:   var prefix = this.prefix;
80321:   var suffix = this.suffix;
80321: 
80321:   var quote = (replText.indexOf(' ') >= 0 || replText.length == 0) ?
80321:       '\'' : '';
80321: 
80321:   if (options && options.normalize) {
80321:     prefix = '{ ';
80321:     suffix = ' }';
80321:   }
80321: 
80321:   return new ScriptArgument(replText, prefix, suffix);
80321: };
80321: 
80321: argument.ScriptArgument = ScriptArgument;
80321: 
80321: 
80321: /**
80321:  * Commands like 'echo' with a single string argument, and used with the
80321:  * special format like: 'echo a b c' effectively have a number of arguments
80321:  * merged together.
80321:  */
80321: function MergedArgument(args, start, end) {
80321:   if (!Array.isArray(args)) {
80321:     throw new Error('args is not an array of Arguments');
80321:   }
80321: 
80321:   if (start === undefined) {
80321:     this.args = args;
80321:   }
80321:   else {
80321:     this.args = args.slice(start, end);
80321:   }
80321: 
80321:   var arg = Argument.merge(this.args);
80321:   this.text = arg.text;
80321:   this.prefix = arg.prefix;
80321:   this.suffix = arg.suffix;
80321: }
80321: 
80321: MergedArgument.prototype = Object.create(Argument.prototype);
80321: 
80321: /**
80321:  * Keep track of which assignment we've been assigned to, and allow the
80321:  * original args to do the same.
80321:  */
80321: MergedArgument.prototype.assign = function(assignment) {
80321:   this.args.forEach(function(arg) {
80321:     arg.assign(assignment);
80321:   }, this);
80321: 
80321:   this.assignment = assignment;
80321: };
80321: 
80321: MergedArgument.prototype.getArgs = function() {
80321:   return this.args;
80321: };
80321: 
80321: MergedArgument.prototype.equals = function(that) {
80321:   if (this === that) {
80321:     return true;
80321:   }
80321:   if (that == null || !(that instanceof MergedArgument)) {
80321:     return false;
80321:   }
80321: 
80321:   // We might need to add a check that args is the same here
80321: 
80321:   return this.text === that.text &&
80321:        this.prefix === that.prefix && this.suffix === that.suffix;
80321: };
80321: 
80321: argument.MergedArgument = MergedArgument;
80321: 
80321: 
80321: /**
80321:  * TrueNamedArguments are for when we have an argument like --verbose which
80321:  * has a boolean value, and thus the opposite of '--verbose' is ''.
80321:  */
80321: function TrueNamedArgument(name, arg) {
80321:   this.arg = arg;
80321:   this.text = arg ? arg.text : '--' + name;
80321:   this.prefix = arg ? arg.prefix : ' ';
80321:   this.suffix = arg ? arg.suffix : '';
80321: }
80321: 
80321: TrueNamedArgument.prototype = Object.create(Argument.prototype);
80321: 
80321: TrueNamedArgument.prototype.assign = function(assignment) {
80321:   if (this.arg) {
80321:     this.arg.assign(assignment);
80321:   }
80321:   this.assignment = assignment;
80321: };
80321: 
80321: TrueNamedArgument.prototype.getArgs = function() {
80321:   // NASTY! getArgs has a fairly specific use: in removing used arguments
80321:   // from a command line. Unlike other arguments which are EITHER used
80321:   // in assignments directly OR grouped in things like MergedArguments,
80321:   // TrueNamedArgument is used raw from the UI, or composed of another arg
80321:   // from the CLI, so we return both here so they can both be removed.
80321:   return this.arg ? [ this, this.arg ] : [ this ];
80321: };
80321: 
80321: TrueNamedArgument.prototype.equals = function(that) {
80321:   if (this === that) {
80321:     return true;
80321:   }
80321:   if (that == null || !(that instanceof TrueNamedArgument)) {
80321:     return false;
80321:   }
80321: 
80321:   return this.text === that.text &&
80321:        this.prefix === that.prefix && this.suffix === that.suffix;
80321: };
80321: 
80321: argument.TrueNamedArgument = TrueNamedArgument;
80321: 
80321: 
80321: /**
80321:  * FalseNamedArguments are for when we don't have an argument like --verbose
80321:  * which has a boolean value, and thus the opposite of '' is '--verbose'.
80321:  */
80321: function FalseNamedArgument() {
80321:   this.text = '';
80321:   this.prefix = '';
80321:   this.suffix = '';
80321: }
80321: 
80321: FalseNamedArgument.prototype = Object.create(Argument.prototype);
80321: 
80321: FalseNamedArgument.prototype.getArgs = function() {
80321:   return [ ];
80321: };
80321: 
80321: FalseNamedArgument.prototype.equals = function(that) {
80321:   if (this === that) {
80321:     return true;
80321:   }
80321:   if (that == null || !(that instanceof FalseNamedArgument)) {
80321:     return false;
80321:   }
80321: 
80321:   return this.text === that.text &&
80321:        this.prefix === that.prefix && this.suffix === that.suffix;
80321: };
80321: 
80321: argument.FalseNamedArgument = FalseNamedArgument;
80321: 
80321: 
80321: /**
80321:  * A named argument is for cases where we have input in one of the following
80321:  * formats:
80321:  * <ul>
80321:  * <li>--param value
80321:  * <li>-p value
80321:  * <li>--pa value
80321:  * <li>-p:value
80321:  * <li>--param=value
80321:  * <li>etc
80321:  * </ul>
80321:  * The general format is:
80321:  * /--?{unique-param-name-prefix}[ :=]{value}/
80321:  * We model this as a normal argument but with a long prefix.
80321:  */
80321: function NamedArgument(nameArg, valueArg) {
80321:   this.nameArg = nameArg;
80321:   this.valueArg = valueArg;
80321: 
80321:   this.text = valueArg.text;
80321:   this.prefix = nameArg.toString() + valueArg.prefix;
80321:   this.suffix = valueArg.suffix;
80321: }
80321: 
80321: NamedArgument.prototype = Object.create(Argument.prototype);
80321: 
80321: NamedArgument.prototype.assign = function(assignment) {
80321:   this.nameArg.assign(assignment);
80321:   this.valueArg.assign(assignment);
80321:   this.assignment = assignment;
80321: };
80321: 
80321: NamedArgument.prototype.getArgs = function() {
80321:   return [ this.nameArg, this.valueArg ];
80321: };
80321: 
80321: NamedArgument.prototype.equals = function(that) {
80321:   if (this === that) {
80321:     return true;
80321:   }
80321:   if (that == null) {
80321:     return false;
80321:   }
80321: 
80321:   if (!(that instanceof NamedArgument)) {
80321:     return false;
80321:   }
80321: 
80321:   // We might need to add a check that nameArg and valueArg are the same
80321: 
80321:   return this.text === that.text &&
80321:        this.prefix === that.prefix && this.suffix === that.suffix;
80321: };
80321: 
80321: argument.NamedArgument = NamedArgument;
80321: 
80321: 
80321: /**
80321:  * An argument the groups together a number of plain arguments together so they
80321:  * can be jointly assigned to a single array parameter
80321:  */
80321: function ArrayArgument() {
80321:   this.args = [];
80321: }
80321: 
80321: ArrayArgument.prototype = Object.create(Argument.prototype);
80321: 
80321: ArrayArgument.prototype.addArgument = function(arg) {
80321:   this.args.push(arg);
80321: };
80321: 
80321: ArrayArgument.prototype.addArguments = function(args) {
80321:   Array.prototype.push.apply(this.args, args);
80321: };
80321: 
80321: ArrayArgument.prototype.getArguments = function() {
80321:   return this.args;
80321: };
80321: 
80321: ArrayArgument.prototype.assign = function(assignment) {
80321:   this.args.forEach(function(arg) {
80321:     arg.assign(assignment);
80321:   }, this);
80321: 
80321:   this.assignment = assignment;
80321: };
80321: 
80321: ArrayArgument.prototype.getArgs = function() {
80321:   return this.args;
80321: };
80321: 
80321: ArrayArgument.prototype.equals = function(that) {
80321:   if (this === that) {
80321:     return true;
80321:   }
80321:   if (that == null) {
80321:     return false;
80321:   }
80321: 
80321:   if (!(that instanceof ArrayArgument)) {
80321:     return false;
80321:   }
80321: 
80321:   if (this.args.length !== that.args.length) {
80321:     return false;
80321:   }
80321: 
80321:   for (var i = 0; i < this.args.length; i++) {
80321:     if (!this.args[i].equals(that.args[i])) {
80321:       return false;
80321:     }
80321:   }
80321: 
80321:   return true;
80321: };
80321: 
80321: /**
80321:  * Helper when we're putting arguments back together
80321:  */
80321: ArrayArgument.prototype.toString = function() {
80321:   return '{' + this.args.map(function(arg) {
80321:     return arg.toString();
80321:   }, this).join(',') + '}';
80321: };
80321: 
80321: argument.ArrayArgument = ArrayArgument;
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/types/basic', ['require', 'exports', 'module' , 'gcli/l10n', 'gcli/types', 'gcli/argument'], function(require, exports, module) {
80321: 
80321: 
80321: var l10n = require('gcli/l10n');
80321: var types = require('gcli/types');
80321: var Type = require('gcli/types').Type;
80321: var Status = require('gcli/types').Status;
80321: var Conversion = require('gcli/types').Conversion;
80321: var ArrayConversion = require('gcli/types').ArrayConversion;
80321: 
80321: var Argument = require('gcli/argument').Argument;
80321: var TrueNamedArgument = require('gcli/argument').TrueNamedArgument;
80321: var FalseNamedArgument = require('gcli/argument').FalseNamedArgument;
80321: var ArrayArgument = require('gcli/argument').ArrayArgument;
80321: 
80321: 
80321: /**
80321:  * Registration and de-registration.
80321:  */
80321: exports.startup = function() {
80321:   types.registerType(StringType);
80321:   types.registerType(NumberType);
80321:   types.registerType(BooleanType);
80321:   types.registerType(BlankType);
80321:   types.registerType(SelectionType);
80321:   types.registerType(DeferredType);
80321:   types.registerType(ArrayType);
80321: };
80321: 
80321: exports.shutdown = function() {
80321:   types.unregisterType(StringType);
80321:   types.unregisterType(NumberType);
80321:   types.unregisterType(BooleanType);
80321:   types.unregisterType(BlankType);
80321:   types.unregisterType(SelectionType);
80321:   types.unregisterType(DeferredType);
80321:   types.unregisterType(ArrayType);
80321: };
80321: 
80321: 
80321: /**
80321:  * 'string' the most basic string type that doesn't need to convert
80321:  */
80321: function StringType(typeSpec) {
80321:   if (typeSpec != null) {
80321:     throw new Error('StringType can not be customized');
80321:   }
80321: }
80321: 
80321: StringType.prototype = Object.create(Type.prototype);
80321: 
80321: StringType.prototype.stringify = function(value) {
80321:   if (value == null) {
80321:     return '';
80321:   }
80321:   return value.toString();
80321: };
80321: 
80321: StringType.prototype.parse = function(arg) {
80321:   if (arg.text == null || arg.text === '') {
80321:     return new Conversion(null, arg, Status.INCOMPLETE, '');
80321:   }
80321:   return new Conversion(arg.text, arg);
80321: };
80321: 
80321: StringType.prototype.name = 'string';
80321: 
80321: exports.StringType = StringType;
80321: 
80321: 
80321: /**
80321:  * We don't currently plan to distinguish between integers and floats
80321:  */
80321: function NumberType(typeSpec) {
80321:   if (typeSpec) {
80321:     this._min = typeSpec.min;
80321:     this._max = typeSpec.max;
80321:     this._step = typeSpec.step || 1;
80321:   }
80321:   else {
80321:     this._step = 1;
80321:   }
80321: }
80321: 
80321: NumberType.prototype = Object.create(Type.prototype);
80321: 
80321: NumberType.prototype.stringify = function(value) {
80321:   if (value == null) {
80321:     return '';
80321:   }
80321:   return '' + value;
80321: };
80321: 
80321: NumberType.prototype.getMin = function() {
80321:   if (this._min) {
80321:     if (typeof this._min === 'function') {
80321:       return this._min();
80321:     }
80321:     if (typeof this._min === 'number') {
80321:       return this._min;
80321:     }
80321:   }
80321:   return 0;
80321: };
80321: 
80321: NumberType.prototype.getMax = function() {
80321:   if (this._max) {
80321:     if (typeof this._max === 'function') {
80321:       return this._max();
80321:     }
80321:     if (typeof this._max === 'number') {
80321:       return this._max;
80321:     }
80321:   }
80321:   return undefined;
80321: };
80321: 
80321: NumberType.prototype.parse = function(arg) {
80321:   if (arg.text.replace(/\s/g, '').length === 0) {
80321:     return new Conversion(null, arg, Status.INCOMPLETE, '');
80321:   }
80321: 
80321:   var value = parseInt(arg.text, 10);
80321:   if (isNaN(value)) {
80321:     return new Conversion(null, arg, Status.ERROR,
80321:         l10n.lookupFormat('typesNumberNan', [ arg.text ]));
80321:   }
80321: 
80321:   if (this.getMax() != null && value > this.getMax()) {
80321:     return new Conversion(null, arg, Status.ERROR,
80321:         l10n.lookupFormat('typesNumberMax', [ value, this.getMax() ]));
80321:   }
80321: 
80321:   if (value < this.getMin()) {
80321:     return new Conversion(null, arg, Status.ERROR,
80321:         l10n.lookupFormat('typesNumberMin', [ value, this.getMin() ]));
80321:   }
80321: 
80321:   return new Conversion(value, arg);
80321: };
80321: 
80321: NumberType.prototype.decrement = function(value) {
80321:   if (typeof value !== 'number' || isNaN(value)) {
80321:     return this.getMax() || 1;
80321:   }
80321:   var newValue = value - this._step;
80321:   // Snap to the nearest incremental of the step
80321:   newValue = Math.ceil(newValue / this._step) * this._step;
80321:   return this._boundsCheck(newValue);
80321: };
80321: 
80321: NumberType.prototype.increment = function(value) {
80321:   if (typeof value !== 'number' || isNaN(value)) {
80321:     return this.getMin();
80321:   }
80321:   var newValue = value + this._step;
80321:   // Snap to the nearest incremental of the step
80321:   newValue = Math.floor(newValue / this._step) * this._step;
80321:   if (this.getMax() == null) {
80321:     return newValue;
80321:   }
80321:   return this._boundsCheck(newValue);
80321: };
80321: 
80321: /**
80321:  * Return the input value so long as it is within the max/min bounds. If it is
80321:  * lower than the minimum, return the minimum. If it is bigger than the maximum
80321:  * then return the maximum.
80321:  */
80321: NumberType.prototype._boundsCheck = function(value) {
80321:   var min = this.getMin();
80321:   if (value < min) {
80321:     return min;
80321:   }
80321:   var max = this.getMax();
80321:   if (value > max) {
80321:     return max;
80321:   }
80321:   return value;
80321: };
80321: 
80321: NumberType.prototype.name = 'number';
80321: 
80321: exports.NumberType = NumberType;
80321: 
80321: /**
80321:  * One of a known set of options
80321:  */
80321: function SelectionType(typeSpec) {
80321:   if (typeSpec) {
80321:     Object.keys(typeSpec).forEach(function(key) {
80321:       this[key] = typeSpec[key];
80321:     }, this);
80321:   }
80321: }
80321: 
80321: SelectionType.prototype = Object.create(Type.prototype);
80321: 
80321: SelectionType.prototype.stringify = function(value) {
80321:   var name = null;
80321:   var lookup = this.getLookup();
80321:   lookup.some(function(item) {
80321:     var test = (item.value == null) ? item : item.value;
80321:     if (test === value) {
80321:       name = item.name;
80321:       return true;
80321:     }
80321:     return false;
80321:   }, this);
80321:   return name;
80321: };
80321: 
80321: /**
80321:  * There are several ways to get selection data. This unifies them into one
80321:  * single function.
80321:  * @return A map of names to values.
80321:  */
80321: SelectionType.prototype.getLookup = function() {
80321:   if (this.lookup) {
80321:     if (typeof this.lookup === 'function') {
80321:       return this.lookup();
80321:     }
80321:     return this.lookup;
80321:   }
80321: 
80321:   if (Array.isArray(this.data)) {
80321:     this.lookup = this._dataToLookup(this.data);
80321:     return this.lookup;
80321:   }
80321: 
80321:   if (typeof(this.data) === 'function') {
80321:     return this._dataToLookup(this.data());
80321:   }
80321: 
80321:   throw new Error('SelectionType has no data');
80321: };
80321: 
80321: /**
80321:  * Selection can be provided with either a lookup object (in the 'lookup'
80321:  * property) or an array of strings (in the 'data' property). Internally we
80321:  * always use lookup, so we need a way to convert a 'data' array to a lookup.
80321:  */
80321: SelectionType.prototype._dataToLookup = function(data) {
80321:   return data.map(function(option) {
80321:     return { name: option, value: option };
80321:   });
80321: };
80321: 
80321: /**
80321:  * Return a list of possible completions for the given arg.
80321:  * This code is very similar to CommandType._findPredictions(). If you are
80321:  * making changes to this code, you should check there too.
80321:  * @param arg The initial input to match
80321:  * @return A trimmed lookup table of string:value pairs
80321:  */
80321: SelectionType.prototype._findPredictions = function(arg) {
80321:   var predictions = [];
80321:   this.getLookup().forEach(function(item) {
80321:     if (item.name.indexOf(arg.text) === 0) {
80321:       predictions.push(item);
80321:     }
80321:   }, this);
80321:   return predictions;
80321: };
80321: 
80321: SelectionType.prototype.parse = function(arg) {
80321:   var predictions = this._findPredictions(arg);
80321: 
80321:   if (predictions.length === 1 && predictions[0].name === arg.text) {
80321:     var value = predictions[0].value ? predictions[0].value : predictions[0];
80321:     return new Conversion(value, arg);
80321:   }
80321: 
80321:   // This is something of a hack it basically allows us to tell the
80321:   // setting type to forget its last setting hack.
80321:   if (this.noMatch) {
80321:     this.noMatch();
80321:   }
80321: 
80321:   if (predictions.length > 0) {
80321:     // Especially at startup, predictions live over the time that things
80321:     // change so we provide a completion function rather than completion
80321:     // values.
80321:     // This was primarily designed for commands, which have since moved
80321:     // into their own type, so technically we could remove this code,
80321:     // except that it provides more up-to-date answers, and it's hard to
80321:     // predict when it will be required.
80321:     var predictFunc = function() {
80321:       return this._findPredictions(arg);
80321:     }.bind(this);
80321:     return new Conversion(null, arg, Status.INCOMPLETE, '', predictFunc);
80321:   }
80321: 
80321:   return new Conversion(null, arg, Status.ERROR,
80321:       l10n.lookupFormat('typesSelectionNomatch', [ arg.text ]));
80321: };
80321: 
80321: /**
80321:  * For selections, up is down and black is white. It's like this, given a list
80321:  * [ a, b, c, d ], it's natural to think that it starts at the top and that
80321:  * going up the list, moves towards 'a'. However 'a' has the lowest index, so
80321:  * for SelectionType, up is down and down is up.
80321:  * Sorry.
80321:  */
80321: SelectionType.prototype.decrement = function(value) {
80321:   var lookup = this.getLookup();
80321:   var index = this._findValue(lookup, value);
80321:   if (index === -1) {
80321:     index = 0;
80321:   }
80321:   index++;
80321:   if (index >= lookup.length) {
80321:     index = 0;
80321:   }
80321:   return lookup[index].value;
80321: };
80321: 
80321: /**
80321:  * See note on SelectionType.decrement()
80321:  */
80321: SelectionType.prototype.increment = function(value) {
80321:   var lookup = this.getLookup();
80321:   var index = this._findValue(lookup, value);
80321:   if (index === -1) {
80321:     // For an increment operation when there is nothing to start from, we
80321:     // want to start from the top, i.e. index 0, so the value before we
80321:     // 'increment' (see note above) must be 1.
80321:     index = 1;
80321:   }
80321:   index--;
80321:   if (index < 0) {
80321:     index = lookup.length - 1;
80321:   }
80321:   return lookup[index].value;
80321: };
80321: 
80321: /**
80321:  * Walk through an array of { name:.., value:... } objects looking for a
80321:  * matching value (using strict equality), returning the matched index (or -1
80321:  * if not found).
80321:  * @param lookup Array of objects with name/value properties to search through
80321:  * @param value The value to search for
80321:  * @return The index at which the match was found, or -1 if no match was found
80321:  */
80321: SelectionType.prototype._findValue = function(lookup, value) {
80321:   var index = -1;
80321:   for (var i = 0; i < lookup.length; i++) {
80321:     var pair = lookup[i];
80321:     if (pair.value === value) {
80321:       index = i;
80321:       break;
80321:     }
80321:   }
80321:   return index;
80321: };
80321: 
80321: SelectionType.prototype.name = 'selection';
80321: 
80321: exports.SelectionType = SelectionType;
80321: 
80321: 
80321: /**
80321:  * true/false values
80321:  */
80321: function BooleanType(typeSpec) {
80321:   if (typeSpec != null) {
80321:     throw new Error('BooleanType can not be customized');
80321:   }
80321: }
80321: 
80321: BooleanType.prototype = Object.create(SelectionType.prototype);
80321: 
80321: BooleanType.prototype.lookup = [
80321:   { name: 'true', value: true },
80321:   { name: 'false', value: false }
80321: ];
80321: 
80321: BooleanType.prototype.parse = function(arg) {
80321:   if (arg instanceof TrueNamedArgument) {
80321:     return new Conversion(true, arg);
80321:   }
80321:   if (arg instanceof FalseNamedArgument) {
80321:     return new Conversion(false, arg);
80321:   }
80321:   return SelectionType.prototype.parse.call(this, arg);
80321: };
80321: 
80321: BooleanType.prototype.stringify = function(value) {
80321:   return '' + value;
80321: };
80321: 
80321: BooleanType.prototype.getDefault = function() {
80321:   return new Conversion(false, new Argument(''));
80321: };
80321: 
80321: BooleanType.prototype.name = 'boolean';
80321: 
80321: exports.BooleanType = BooleanType;
80321: 
80321: 
80321: /**
80321:  * A type for "we don't know right now, but hope to soon".
80321:  */
80321: function DeferredType(typeSpec) {
80321:   if (typeof typeSpec.defer !== 'function') {
80321:     throw new Error('Instances of DeferredType need typeSpec.defer to be a function that returns a type');
80321:   }
80321:   Object.keys(typeSpec).forEach(function(key) {
80321:     this[key] = typeSpec[key];
80321:   }, this);
80321: }
80321: 
80321: DeferredType.prototype = Object.create(Type.prototype);
80321: 
80321: DeferredType.prototype.stringify = function(value) {
80321:   return this.defer().stringify(value);
80321: };
80321: 
80321: DeferredType.prototype.parse = function(arg) {
80321:   return this.defer().parse(arg);
80321: };
80321: 
80321: DeferredType.prototype.decrement = function(value) {
80321:   var deferred = this.defer();
80321:   return (deferred.decrement ? deferred.decrement(value) : undefined);
80321: };
80321: 
80321: DeferredType.prototype.increment = function(value) {
80321:   var deferred = this.defer();
80321:   return (deferred.increment ? deferred.increment(value) : undefined);
80321: };
80321: 
80321: DeferredType.prototype.increment = function(value) {
80321:   var deferred = this.defer();
80321:   return (deferred.increment ? deferred.increment(value) : undefined);
80321: };
80321: 
80321: DeferredType.prototype.name = 'deferred';
80321: 
80321: exports.DeferredType = DeferredType;
80321: 
80321: 
80321: /**
80321:  * 'blank' is a type for use with DeferredType when we don't know yet.
80321:  * It should not be used anywhere else.
80321:  */
80321: function BlankType(typeSpec) {
80321:   if (typeSpec != null) {
80321:     throw new Error('BlankType can not be customized');
80321:   }
80321: }
80321: 
80321: BlankType.prototype = Object.create(Type.prototype);
80321: 
80321: BlankType.prototype.stringify = function(value) {
80321:   return '';
80321: };
80321: 
80321: BlankType.prototype.parse = function(arg) {
80321:   return new Conversion(null, arg);
80321: };
80321: 
80321: BlankType.prototype.name = 'blank';
80321: 
80321: exports.BlankType = BlankType;
80321: 
80321: 
80321: /**
80321:  * A set of objects of the same type
80321:  */
80321: function ArrayType(typeSpec) {
80321:   if (!typeSpec.subtype) {
80321:     console.error('Array.typeSpec is missing subtype. Assuming string.' +
80321:         JSON.stringify(typeSpec));
80321:     typeSpec.subtype = 'string';
80321:   }
80321: 
80321:   Object.keys(typeSpec).forEach(function(key) {
80321:     this[key] = typeSpec[key];
80321:   }, this);
80321:   this.subtype = types.getType(this.subtype);
80321: }
80321: 
80321: ArrayType.prototype = Object.create(Type.prototype);
80321: 
80321: ArrayType.prototype.stringify = function(values) {
80321:   // BUG 664204: Check for strings with spaces and add quotes
80321:   return values.join(' ');
80321: };
80321: 
80321: ArrayType.prototype.parse = function(arg) {
80321:   if (arg instanceof ArrayArgument) {
80321:     var conversions = arg.getArguments().map(function(subArg) {
80321:       var conversion = this.subtype.parse(subArg);
80321:       // Hack alert. ArrayConversion needs to be able to answer questions
80321:       // about the status of individual conversions in addition to the
80321:       // overall state. This allows us to do that easily.
80321:       subArg.conversion = conversion;
80321:       return conversion;
80321:     }, this);
80321:     return new ArrayConversion(conversions, arg);
80321:   }
80321:   else {
80321:     console.error('non ArrayArgument to ArrayType.parse', arg);
80321:     throw new Error('non ArrayArgument to ArrayType.parse');
80321:   }
80321: };
80321: 
80321: ArrayType.prototype.getDefault = function() {
80321:   return new ArrayConversion([], new ArrayArgument());
80321: };
80321: 
80321: ArrayType.prototype.name = 'array';
80321: 
80321: exports.ArrayType = ArrayType;
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/types/javascript', ['require', 'exports', 'module' , 'gcli/l10n', 'gcli/types'], function(require, exports, module) {
80321: 
80321: 
80321: var l10n = require('gcli/l10n');
80321: var types = require('gcli/types');
80321: 
80321: var Conversion = types.Conversion;
80321: var Type = types.Type;
80321: var Status = types.Status;
80321: 
80321: 
80321: /**
80321:  * Registration and de-registration.
80321:  */
80321: exports.startup = function() {
80321:   types.registerType(JavascriptType);
80321: };
80321: 
80321: exports.shutdown = function() {
80321:   types.unregisterType(JavascriptType);
80321: };
80321: 
80321: /**
80321:  * The object against which we complete, which is usually 'window' if it exists
80321:  * but could be something else in non-web-content environments.
80321:  */
80321: var globalObject;
80321: if (typeof window !== 'undefined') {
80321:   globalObject = window;
80321: }
80321: 
80321: /**
80321:  * Setter for the object against which JavaScript completions happen
80321:  */
80321: exports.setGlobalObject = function(obj) {
80321:   globalObject = obj;
80321: };
80321: 
80321: /**
81343:  * Getter for the object against which JavaScript completions happen, for use
81343:  * in testing
81343:  */
81343: exports.getGlobalObject = function() {
81343:   return globalObject;
81343: };
81343: 
81343: /**
80321:  * Remove registration of object against which JavaScript completions happen
80321:  */
80321: exports.unsetGlobalObject = function() {
80321:   globalObject = undefined;
80321: };
80321: 
80321: 
80321: /**
80321:  * 'javascript' handles scripted input
80321:  */
80321: function JavascriptType(typeSpec) {
80321:   if (typeSpec != null) {
80321:     throw new Error('JavascriptType can not be customized');
80321:   }
80321: }
80321: 
80321: JavascriptType.prototype = Object.create(Type.prototype);
80321: 
80321: JavascriptType.prototype.stringify = function(value) {
80321:   if (value == null) {
80321:     return '';
80321:   }
80321:   return value;
80321: };
80321: 
81343: /**
81343:  * When sorting out completions, there is no point in displaying millions of
81343:  * matches - this the number of matches that we aim for
81343:  */
81343: JavascriptType.MAX_COMPLETION_MATCHES = 10;
81343: 
80321: JavascriptType.prototype.parse = function(arg) {
80321:   var typed = arg.text;
80321:   var scope = globalObject;
80321: 
80321:   // Analyze the input text and find the beginning of the last part that
80321:   // should be completed.
80321:   var beginning = this._findCompletionBeginning(typed);
80321: 
80321:   // There was an error analyzing the string.
80321:   if (beginning.err) {
80321:     return new Conversion(typed, arg, Status.ERROR, beginning.err);
80321:   }
80321: 
86922:   // If the current state is ParseState.COMPLEX, then we can't do completion.
86922:   // so bail out now
86922:   if (beginning.state === ParseState.COMPLEX) {
86922:     return new Conversion(typed, arg);
86922:   }
86922: 
80321:   // If the current state is not ParseState.NORMAL, then we are inside of a
80321:   // string which means that no completion is possible.
80321:   if (beginning.state !== ParseState.NORMAL) {
80321:     return new Conversion(typed, arg, Status.INCOMPLETE, '');
80321:   }
80321: 
80321:   var completionPart = typed.substring(beginning.startPos);
80321:   var properties = completionPart.split('.');
80321:   var matchProp;
80321:   var prop;
80321: 
80321:   if (properties.length > 1) {
80321:     matchProp = properties.pop().trimLeft();
80321:     for (var i = 0; i < properties.length; i++) {
80321:       prop = properties[i].trim();
80321: 
80321:       // We can't complete on null.foo, so bail out
80321:       if (scope == null) {
80321:         return new Conversion(typed, arg, Status.ERROR,
80321:                 l10n.lookup('jstypeParseScope'));
80321:       }
80321: 
81343:       if (prop === '') {
81343:         return new Conversion(typed, arg, Status.INCOMPLETE, '');
81343:       }
81343: 
81343:       // Check if prop is a getter function on 'scope'. Functions can change
81343:       // other stuff so we can't execute them to get the next object. Stop here.
81343:       if (this._isSafeProperty(scope, prop)) {
81343:         return new Conversion(typed, arg);
81343:       }
80321: 
80321:       try {
80321:         scope = scope[prop];
80321:       }
80321:       catch (ex) {
81343:         // It would be nice to be able to report this error in some way but
81343:         // as it can happen just when someone types '{sessionStorage.', it
81343:         // almost doesn't really count as an error, so we ignore it
86922:         return new Conversion(typed, arg, Status.VALID, '');
80321:       }
80321:     }
80321:   }
80321:   else {
80321:     matchProp = properties[0].trimLeft();
80321:   }
80321: 
80321:   // If the reason we just stopped adjusting the scope was a non-simple string,
80321:   // then we're not sure if the input is valid or invalid, so accept it
80321:   if (prop && !prop.match(/^[0-9A-Za-z]*$/)) {
80321:     return new Conversion(typed, arg);
80321:   }
80321: 
80321:   // However if the prop was a simple string, it is an error
80321:   if (scope == null) {
80321:     return new Conversion(typed, arg, Status.ERROR,
80321:         l10n.lookupFormat('jstypeParseMissing', [ prop ]));
80321:   }
80321: 
80321:   // If the thing we're looking for isn't a simple string, then we're not going
80321:   // to find it, but we're not sure if it's valid or invalid, so accept it
80321:   if (!matchProp.match(/^[0-9A-Za-z]*$/)) {
80321:     return new Conversion(typed, arg);
80321:   }
80321: 
80321:   // Skip Iterators and Generators.
80321:   if (this._isIteratorOrGenerator(scope)) {
80321:     return null;
80321:   }
80321: 
80321:   var matchLen = matchProp.length;
80321:   var prefix = matchLen === 0 ? typed : typed.slice(0, -matchLen);
80321:   var status = Status.INCOMPLETE;
81343:   var message = '';
81343: 
81343:   // We really want an array of matches (for sorting) but it's easier to
81343:   // detect existing members if we're using a map initially
81343:   var matches = {};
81343: 
81343:   // We only display a maximum of MAX_COMPLETION_MATCHES, so there is no point
81343:   // in digging up the prototype chain for matches that we're never going to
81343:   // use. Initially look for matches directly on the object itself and then
81343:   // look up the chain to find more
81343:   var distUpPrototypeChain = 0;
81343:   var root = scope;
80321:   try {
81343:     while (root != null &&
81343:         Object.keys(matches).length < JavascriptType.MAX_COMPLETION_MATCHES) {
81343: 
81343:       Object.keys(root).forEach(function(property) {
81343:         // Only add matching properties. Also, as we're walking up the
81343:         // prototype chain, properties on 'higher' prototypes don't override
81343:         // similarly named properties lower down
81343:         if (property.indexOf(matchProp) === 0 && !(property in matches)) {
81343:           matches[property] = {
81343:             prop: property,
81343:             distUpPrototypeChain: distUpPrototypeChain
81343:           };
81343:         }
81343:       });
81343: 
81343:       distUpPrototypeChain++;
81343:       root = Object.getPrototypeOf(root);
81343:     }
80321:   }
80321:   catch (ex) {
81343:     return new Conversion(typed, arg, Status.INCOMPLETE, '');
81343:   }
81343: 
81343:   // Convert to an array for sorting, and while we're at it, note if we got
81343:   // an exact match so we know that this input is valid
81343:   matches = Object.keys(matches).map(function(property) {
81343:     if (property === matchProp) {
81343:       status = Status.VALID;
81343:     }
81343:     return matches[property];
81343:   });
81343: 
81343:   // The sort keys are:
81343:   // - Being on the object itself, not in the prototype chain
81343:   // - The lack of existence of a vendor prefix
81343:   // - The name
81343:   matches.sort(function(m1, m2) {
81343:     if (m1.distUpPrototypeChain !== m2.distUpPrototypeChain) {
81343:       return m1.distUpPrototypeChain - m2.distUpPrototypeChain;
81343:     }
81343:     // Push all vendor prefixes to the bottom of the list
81343:     return isVendorPrefixed(m1.prop) ?
81343:       (isVendorPrefixed(m2.prop) ? m1.prop.localeCompare(m2.prop) : 1) :
81343:       (isVendorPrefixed(m2.prop) ? -1 : m1.prop.localeCompare(m2.prop));
81343:   });
81343: 
81343:   // Trim to size. There is a bug for doing a better job of finding matches
81343:   // (bug 682694), but in the mean time there is a performance problem
81343:   // associated with creating a large number of DOM nodes that few people will
81343:   // ever read, so trim ...
81343:   if (matches.length > JavascriptType.MAX_COMPLETION_MATCHES) {
81343:     matches = matches.slice(0, JavascriptType.MAX_COMPLETION_MATCHES - 1);
81343:   }
81343: 
81343:   // Decorate the matches with:
81343:   // - a description
81343:   // - a value (for the menu) and,
81343:   // - an incomplete flag which reports if we should assume that the user isn't
81343:   //   going to carry on the JS expression with this input so far
81343:   var predictions = matches.map(function(match) {
80321:     var description;
80321:     var incomplete = true;
81343: 
81343:     if (this._isSafeProperty(scope, match.prop)) {
81343:       description = '(property getter)';
81343:     }
81343:     else {
81343:       try {
81343:         var value = scope[match.prop];
81343: 
80321:         if (typeof value === 'function') {
80321:           description = '(function)';
80321:         }
81343:         else if (typeof value === 'boolean' || typeof value === 'number') {
80321:           description = '= ' + value;
80321:           incomplete = false;
80321:         }
80321:         else if (typeof value === 'string') {
80321:           if (value.length > 40) {
81343:             value = value.substring(0, 37) + '…';
80321:           }
80321:           description = '= \'' + value + '\'';
80321:           incomplete = false;
80321:         }
80321:         else {
80321:           description = '(' + typeof value + ')';
80321:         }
81343:       }
81343:       catch (ex) {
81343:         description = '(' + l10n.lookup('jstypeParseError') + ')';
81343:       }
81343:     }
81343: 
81343:     return {
81343:       name: prefix + match.prop,
80321:       value: {
81343:         name: prefix + match.prop,
80321:         description: description
80321:       },
81343:       description: description,
80321:       incomplete: incomplete
81343:     };
81343:   }, this);
81343: 
81343:   if (predictions.length === 0) {
81343:     status = Status.ERROR;
80321:     message = l10n.lookupFormat('jstypeParseMissing', [ matchProp ]);
80321:   }
80321: 
80321:   // If the match is the only one possible, and its VALID, predict nothing
81343:   if (predictions.length === 1 && status === Status.VALID) {
81343:     predictions = undefined;
81343:   }
81343: 
81343:   return new Conversion(typed, arg, status, message, predictions);
81343: };
81343: 
81343: /**
81343:  * Does the given property have a prefix that indicates that it is vendor
81343:  * specific?
81343:  */
81343: function isVendorPrefixed(name) {
81343:   return name.indexOf('moz') === 0 ||
81343:          name.indexOf('webkit') === 0 ||
81343:          name.indexOf('ms') === 0;
81343: }
81343: 
81343: /**
81343:  * Constants used in return value of _findCompletionBeginning()
81343:  */
80321: var ParseState = {
86922:   /**
86922:    * We have simple input like window.foo, without any punctuation that makes
86922:    * completion prediction be confusing or wrong
86922:    */
80321:   NORMAL: 0,
86922: 
86922:   /**
86922:    * The cursor is in some Javascript that makes completion hard to predict,
86922:    * like console.log(
86922:    */
86922:   COMPLEX: 1,
86922: 
86922:   /**
86922:    * The cursor is inside single quotes (')
86922:    */
80321:   QUOTE: 2,
86922: 
86922:   /**
86922:    * The cursor is inside single quotes (")
86922:    */
80321:   DQUOTE: 3
80321: };
80321: 
80321: var OPEN_BODY = '{[('.split('');
80321: var CLOSE_BODY = '}])'.split('');
80321: var OPEN_CLOSE_BODY = {
80321:   '{': '}',
80321:   '[': ']',
80321:   '(': ')'
80321: };
80321: 
80321: /**
86922:  * How we distinguish between simple and complex JS input. We attempt
86922:  * completion against simple JS.
86922:  */
86922: var simpleChars = /[a-zA-Z0-9.]/;
86922: 
86922: /**
80321:  * Analyzes a given string to find the last statement that is interesting for
80321:  * later completion.
80321:  * @param text A string to analyze
80321:  * @return If there was an error in the string detected, then a object like
80321:  *   { err: 'ErrorMesssage' }
80321:  * is returned, otherwise a object like
80321:  *   {
80321:  *     state: ParseState.NORMAL|ParseState.QUOTE|ParseState.DQUOTE,
80321:  *     startPos: index of where the last statement begins
80321:  *   }
80321:  */
80321: JavascriptType.prototype._findCompletionBeginning = function(text) {
80321:   var bodyStack = [];
80321: 
80321:   var state = ParseState.NORMAL;
80321:   var start = 0;
80321:   var c;
86922:   var complex = false;
86922: 
80321:   for (var i = 0; i < text.length; i++) {
80321:     c = text[i];
86922:     if (!simpleChars.test(c)) {
86922:       complex = true;
86922:     }
80321: 
80321:     switch (state) {
80321:       // Normal JS state.
80321:       case ParseState.NORMAL:
80321:         if (c === '"') {
80321:           state = ParseState.DQUOTE;
80321:         }
80321:         else if (c === '\'') {
80321:           state = ParseState.QUOTE;
80321:         }
80321:         else if (c === ';') {
80321:           start = i + 1;
80321:         }
80321:         else if (c === ' ') {
80321:           start = i + 1;
80321:         }
80321:         else if (OPEN_BODY.indexOf(c) != -1) {
80321:           bodyStack.push({
80321:             token: c,
80321:             start: start
80321:           });
80321:           start = i + 1;
80321:         }
80321:         else if (CLOSE_BODY.indexOf(c) != -1) {
80321:           var last = bodyStack.pop();
80321:           if (!last || OPEN_CLOSE_BODY[last.token] != c) {
80321:             return { err: l10n.lookup('jstypeBeginSyntax') };
80321:           }
80321:           if (c === '}') {
80321:             start = i + 1;
80321:           }
80321:           else {
80321:             start = last.start;
80321:           }
80321:         }
80321:         break;
80321: 
80321:       // Double quote state > " <
80321:       case ParseState.DQUOTE:
80321:         if (c === '\\') {
80321:           i ++;
80321:         }
80321:         else if (c === '\n') {
80321:           return { err: l10n.lookup('jstypeBeginUnterm') };
80321:         }
80321:         else if (c === '"') {
80321:           state = ParseState.NORMAL;
80321:         }
80321:         break;
80321: 
80321:       // Single quote state > ' <
80321:       case ParseState.QUOTE:
80321:         if (c === '\\') {
80321:           i ++;
80321:         }
80321:         else if (c === '\n') {
80321:           return { err: l10n.lookup('jstypeBeginUnterm') };
80321:         }
80321:         else if (c === '\'') {
80321:           state = ParseState.NORMAL;
80321:         }
80321:         break;
80321:     }
80321:   }
80321: 
86922:   if (state === ParseState.NORMAL && complex) {
86922:     state = ParseState.COMPLEX;
86922:   }
86922: 
80321:   return {
80321:     state: state,
80321:     startPos: start
80321:   };
80321: };
80321: 
80321: /**
80321:  * Return true if the passed object is either an iterator or a generator, and
81343:  * false otherwise
80321:  * @param obj The object to check
80321:  */
80321: JavascriptType.prototype._isIteratorOrGenerator = function(obj) {
80321:   if (obj === null) {
80321:     return false;
80321:   }
80321: 
80321:   if (typeof aObject === 'object') {
80321:     if (typeof obj.__iterator__ === 'function' ||
80321:         obj.constructor && obj.constructor.name === 'Iterator') {
80321:       return true;
80321:     }
80321: 
80321:     try {
80321:       var str = obj.toString();
80321:       if (typeof obj.next === 'function' &&
80321:           str.indexOf('[object Generator') === 0) {
80321:         return true;
80321:       }
80321:     }
80321:     catch (ex) {
80321:       // window.history.next throws in the typeof check above.
80321:       return false;
80321:     }
80321:   }
80321: 
80321:   return false;
80321: };
80321: 
81343: /**
81343:  * Would calling 'scope[prop]' cause the invocation of a non-native (i.e. user
81343:  * defined) function property?
81343:  * Since calling functions can have side effects, it's only safe to do that if
81343:  * explicitly requested, rather than because we're trying things out for the
81343:  * purposes of completion.
81343:  */
81343: JavascriptType.prototype._isSafeProperty = function(scope, prop) {
81343:   if (typeof scope !== 'object') {
81343:     return false;
81343:   }
81343: 
81343:   // Walk up the prototype chain of 'scope' looking for a property descriptor
81343:   // for 'prop'
81343:   var propDesc;
81343:   while (scope) {
81343:     try {
81343:       propDesc = Object.getOwnPropertyDescriptor(scope, prop);
81343:       if (propDesc) {
81343:         break;
81343:       }
81343:     }
81343:     catch (ex) {
81343:       // Native getters throw here. See bug 520882.
81343:       if (ex.name === 'NS_ERROR_XPC_BAD_CONVERT_JS' ||
81343:           ex.name === 'NS_ERROR_XPC_BAD_OP_ON_WN_PROTO') {
81343:         return false;
81343:       }
81343:       return true;
81343:     }
81343:     scope = Object.getPrototypeOf(scope);
81343:   }
81343: 
81343:   if (!propDesc) {
81343:     return false;
81343:   }
81343: 
81343:   if (!propDesc.get) {
81343:     return false;
81343:   }
81343: 
81343:   // The property is safe if 'get' isn't a function or if the function has a
81343:   // prototype (in which case it's native)
81343:   return typeof propDesc.get !== 'function' || 'prototype' in propDesc.get;
81343: };
81343: 
80321: JavascriptType.prototype.name = 'javascript';
80321: 
80321: exports.JavascriptType = JavascriptType;
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80932: define('gcli/types/node', ['require', 'exports', 'module' , 'gcli/host', 'gcli/l10n', 'gcli/types'], function(require, exports, module) {
80932: 
80932: 
80932: var host = require('gcli/host');
80321: var l10n = require('gcli/l10n');
80321: var types = require('gcli/types');
80321: var Type = require('gcli/types').Type;
80321: var Status = require('gcli/types').Status;
80321: var Conversion = require('gcli/types').Conversion;
80321: 
80321: 
80321: /**
80321:  * Registration and de-registration.
80321:  */
80321: exports.startup = function() {
80321:   types.registerType(NodeType);
80321: };
80321: 
80321: exports.shutdown = function() {
80321:   types.unregisterType(NodeType);
80321: };
80321: 
80321: /**
80321:  * The object against which we complete, which is usually 'window' if it exists
80321:  * but could be something else in non-web-content environments.
80321:  */
80321: var doc;
80321: if (typeof document !== 'undefined') {
80321:   doc = document;
80321: }
80321: 
80321: /**
80321:  * Setter for the document that contains the nodes we're matching
80321:  */
80321: exports.setDocument = function(document) {
80321:   doc = document;
80321: };
80321: 
80321: /**
80321:  * Undo the effects of setDocument()
80321:  */
80321: exports.unsetDocument = function() {
80321:   doc = undefined;
80321: };
80321: 
84249: /**
84249:  * Getter for the document that contains the nodes we're matching
84249:  * Most for changing things back to how they were for unit testing
84249:  */
84249: exports.getDocument = function() {
84249:   return doc;
84249: };
84249: 
80321: 
80321: /**
80321:  * A CSS expression that refers to a single node
80321:  */
80321: function NodeType(typeSpec) {
80321:   if (typeSpec != null) {
80321:     throw new Error('NodeType can not be customized');
80321:   }
80321: }
80321: 
80321: NodeType.prototype = Object.create(Type.prototype);
80321: 
80321: NodeType.prototype.stringify = function(value) {
80321:   return value.__gcliQuery || 'Error';
80321: };
80321: 
80321: NodeType.prototype.parse = function(arg) {
80321:   if (arg.text === '') {
80321:     return new Conversion(null, arg, Status.INCOMPLETE,
80321:             l10n.lookup('nodeParseNone'));
80321:   }
80321: 
80321:   var nodes;
80321:   try {
80321:     nodes = doc.querySelectorAll(arg.text);
80321:   }
80321:   catch (ex) {
81344:     return new Conversion(null, arg, Status.ERROR,
81344:             l10n.lookup('nodeParseSyntax'));
80321:   }
80321: 
80321:   if (nodes.length === 0) {
80321:     return new Conversion(null, arg, Status.INCOMPLETE,
80321:         l10n.lookup('nodeParseNone'));
80321:   }
80321: 
80321:   if (nodes.length === 1) {
80321:     var node = nodes.item(0);
80321:     node.__gcliQuery = arg.text;
80321: 
80932:     host.flashNode(node, 'green');
80321: 
80321:     return new Conversion(node, arg, Status.VALID, '');
80321:   }
80321: 
80321:   Array.prototype.forEach.call(nodes, function(n) {
80932:     host.flashNode(n, 'red');
80321:   });
80321: 
80321:   return new Conversion(null, arg, Status.ERROR,
80321:           l10n.lookupFormat('nodeParseMultiple', [ nodes.length ]));
80321: };
80321: 
80321: NodeType.prototype.name = 'node';
80321: 
80321: 
80932: });
80932: /*
80932:  * Copyright 2009-2011 Mozilla Foundation and contributors
80932:  * Licensed under the New BSD license. See LICENSE.txt or:
80932:  * http://opensource.org/licenses/BSD-3-Clause
80932:  */
80932: 
80932: define('gcli/host', ['require', 'exports', 'module' ], function(require, exports, module) {
80932: 
80932: 
80321: /**
80321:  * Helper to turn a node background it's complementary color for 1 second.
80321:  * There is likely a better way to do this, but this will do for now.
80321:  */
80932: exports.flashNode = function(node, color) {
80321:   if (!node.__gcliHighlighting) {
80321:     node.__gcliHighlighting = true;
80321:     var original = node.style.background;
80321:     node.style.background = color;
80321:     setTimeout(function() {
80321:       node.style.background = original;
80321:       delete node.__gcliHighlighting;
80321:     }, 1000);
80321:   }
80932: };
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/cli', ['require', 'exports', 'module' , 'gcli/util', 'gcli/canon', 'gcli/promise', 'gcli/types', 'gcli/types/basic', 'gcli/argument'], function(require, exports, module) {
80321: 
80321: 
81345: var util = require('gcli/util');
80321: 
80321: var canon = require('gcli/canon');
80321: var Promise = require('gcli/promise').Promise;
80321: 
80321: var types = require('gcli/types');
80321: var Status = require('gcli/types').Status;
80321: var Conversion = require('gcli/types').Conversion;
80321: var Type = require('gcli/types').Type;
80321: var ArrayType = require('gcli/types/basic').ArrayType;
80321: var StringType = require('gcli/types/basic').StringType;
80321: var BooleanType = require('gcli/types/basic').BooleanType;
80321: var SelectionType = require('gcli/types/basic').SelectionType;
80321: 
80321: var Argument = require('gcli/argument').Argument;
80321: var ArrayArgument = require('gcli/argument').ArrayArgument;
80321: var NamedArgument = require('gcli/argument').NamedArgument;
80321: var TrueNamedArgument = require('gcli/argument').TrueNamedArgument;
80321: var MergedArgument = require('gcli/argument').MergedArgument;
80321: var ScriptArgument = require('gcli/argument').ScriptArgument;
80321: 
80321: var evalCommand;
80321: 
80321: /**
80321:  * Registration and de-registration.
80321:  */
80321: exports.startup = function() {
80321:   types.registerType(CommandType);
80321:   evalCommand = canon.addCommand(evalCommandSpec);
80321: };
80321: 
80321: exports.shutdown = function() {
80321:   types.unregisterType(CommandType);
80321:   canon.removeCommand(evalCommandSpec.name);
80321:   evalCommand = undefined;
80321: };
80321: 
80321: 
80321: /**
80321:  * Assignment is a link between a parameter and the data for that parameter.
80321:  * The data for the parameter is available as in the preferred type and as
80321:  * an Argument for the CLI.
80321:  * <p>We also record validity information where applicable.
80321:  * <p>For values, null and undefined have distinct definitions. null means
80321:  * that a value has been provided, undefined means that it has not.
80321:  * Thus, null is a valid default value, and common because it identifies an
80321:  * parameter that is optional. undefined means there is no value from
80321:  * the command line.
80321:  *
80321:  * <h2>Events<h2>
80321:  * Assignment publishes the following event:<ul>
80321:  * <li>assignmentChange: Either the value or the text has changed. It is likely
80321:  * that any UI component displaying this argument will need to be updated.
80321:  * The event object looks like:
80321:  * <tt>{ assignment: ..., conversion: ..., oldConversion: ... }</tt>
80321:  * @constructor
80321:  */
80321: function Assignment(param, paramIndex) {
80321:   this.param = param;
80321:   this.paramIndex = paramIndex;
81345:   this.assignmentChange = util.createEvent('Assignment.assignmentChange');
80321: 
80321:   this.setDefault();
80321: }
80321: 
80321: /**
80321:  * The parameter that we are assigning to
80321:  * @readonly
80321:  */
80321: Assignment.prototype.param = undefined;
80321: 
80321: Assignment.prototype.conversion = undefined;
80321: 
80321: /**
80321:  * The index of this parameter in the parent Requisition. paramIndex === -1
80321:  * is the command assignment although this should not be relied upon, it is
80321:  * better to test param instanceof CommandAssignment
80321:  */
80321: Assignment.prototype.paramIndex = undefined;
80321: 
80321: /**
80321:  * Easy accessor for conversion.arg
80321:  */
80321: Assignment.prototype.getArg = function() {
80321:   return this.conversion.arg;
80321: };
80321: 
80321: /**
80321:  * Easy accessor for conversion.value
80321:  */
80321: Assignment.prototype.getValue = function() {
80321:   return this.conversion.value;
80321: };
80321: 
80321: /**
80321:  * Easy (and safe) accessor for conversion.message
80321:  */
80321: Assignment.prototype.getMessage = function() {
80321:   return this.conversion.message ? this.conversion.message : '';
80321: };
80321: 
80321: /**
80321:  * Easy (and safe) accessor for conversion.getPredictions()
80321:  * @return An array of objects with name and value elements. For example:
80321:  * [ { name:'bestmatch', value:foo1 }, { name:'next', value:foo2 }, ... ]
80321:  */
80321: Assignment.prototype.getPredictions = function() {
80321:   return this.conversion.getPredictions();
80321: };
80321: 
80321: /**
80321:  * Report on the status of the last parse() conversion.
80321:  * We force mutations to happen through this method rather than have
80321:  * setValue and setArgument functions to help maintain integrity when we
80321:  * have ArrayArguments and don't want to get confused. This way assignments
80321:  * are just containers for a conversion rather than things that store
80321:  * a connection between an arg/value.
80321:  * @see types.Conversion
80321:  */
80321: Assignment.prototype.setConversion = function(conversion) {
80321:   var oldConversion = this.conversion;
80321: 
80321:   this.conversion = conversion;
80321:   this.conversion.assign(this);
80321: 
80321:   if (this.conversion.equals(oldConversion)) {
80321:     return;
80321:   }
80321: 
80321:   this.assignmentChange({
80321:     assignment: this,
80321:     conversion: this.conversion,
80321:     oldConversion: oldConversion
80321:   });
80321: };
80321: 
80321: /**
80321:  * Find a default value for the conversion either from the parameter, or from
80321:  * the type, or failing that by parsing an empty argument.
80321:  */
80321: Assignment.prototype.setDefault = function() {
80321:   var conversion;
80321:   if (this.param.getDefault) {
80321:     conversion = this.param.getDefault();
80321:   }
80321:   else if (this.param.type.getDefault) {
80321:     conversion = this.param.type.getDefault();
80321:   }
80321:   else {
80321:     conversion = this.param.type.parse(new Argument());
80321:   }
80321: 
80321:   this.setConversion(conversion);
80321: };
80321: 
80321: /**
80321:  * Make sure that there is some content for this argument by using an
80321:  * Argument of '' if needed.
80321:  */
80321: Assignment.prototype.ensureVisibleArgument = function() {
80321:   // It isn't clear if we should be sending events from this method.
80321:   // It should only be called when structural changes are happening in which
80321:   // case we're going to ignore the event anyway. But on the other hand
80321:   // perhaps this function shouldn't need to know how it is used, and should
80321:   // do the inefficient thing.
80321:   if (!this.conversion.arg.isBlank()) {
80321:     return false;
80321:   }
80321: 
80321:   var arg = this.conversion.arg.beget('', {
80321:     prefixSpace: this.param instanceof CommandAssignment
80321:   });
80321:   this.conversion = this.param.type.parse(arg);
80321:   this.conversion.assign(this);
80321: 
80321:   return true;
80321: };
80321: 
80321: /**
80321:  * Work out what the status of the current conversion is which involves looking
80321:  * not only at the conversion, but also checking if data has been provided
80321:  * where it should.
80321:  * @param arg For assignments with multiple args (e.g. array assignments) we
80321:  * can narrow the search for status to a single argument.
80321:  */
80321: Assignment.prototype.getStatus = function(arg) {
80321:   if (this.param.isDataRequired() && !this.conversion.isDataProvided()) {
80321:     return Status.ERROR;
80321:   }
80321: 
80321:   // Selection/Boolean types with a defined range of values will say that
80321:   // '' is INCOMPLETE, but the parameter may be optional, so we don't ask
80321:   // if the user doesn't need to enter something and hasn't done so.
80321:   if (!this.param.isDataRequired() && this.getArg().isBlank()) {
80321:     return Status.VALID;
80321:   }
80321: 
80321:   return this.conversion.getStatus(arg);
80321: };
80321: 
80321: /**
80321:  * Basically <tt>value = conversion.predictions[0])</tt> done in a safe way.
80321:  */
80321: Assignment.prototype.complete = function() {
80321:   var predictions = this.conversion.getPredictions();
80321:   if (predictions.length > 0) {
80321:     var arg = this.conversion.arg.beget(predictions[0].name);
80321:     if (!predictions[0].incomplete) {
80321:       arg.suffix = ' ';
80321:     }
80321:     var conversion = this.param.type.parse(arg);
80321:     this.setConversion(conversion);
80321:   }
80321: };
80321: 
80321: /**
80321:  * Replace the current value with the lower value if such a concept exists.
80321:  */
80321: Assignment.prototype.decrement = function() {
80321:   var replacement = this.param.type.decrement(this.conversion.value);
80321:   if (replacement != null) {
80321:     var str = this.param.type.stringify(replacement);
80321:     var arg = this.conversion.arg.beget(str);
80321:     var conversion = new Conversion(replacement, arg);
80321:     this.setConversion(conversion);
80321:   }
80321: };
80321: 
80321: /**
80321:  * Replace the current value with the higher value if such a concept exists.
80321:  */
80321: Assignment.prototype.increment = function() {
80321:   var replacement = this.param.type.increment(this.conversion.value);
80321:   if (replacement != null) {
80321:     var str = this.param.type.stringify(replacement);
80321:     var arg = this.conversion.arg.beget(str);
80321:     var conversion = new Conversion(replacement, arg);
80321:     this.setConversion(conversion);
80321:   }
80321: };
80321: 
80321: /**
80321:  * Helper when we're rebuilding command lines.
80321:  */
80321: Assignment.prototype.toString = function() {
80321:   return this.conversion.toString();
80321: };
80321: 
80321: exports.Assignment = Assignment;
80321: 
80321: 
80321: /**
80321:  * Select from the available commands.
80321:  * This is very similar to a SelectionType, however the level of hackery in
80321:  * SelectionType to make it handle Commands correctly was to high, so we
80321:  * simplified.
80321:  * If you are making changes to this code, you should check there too.
80321:  */
80321: function CommandType() {
80321: }
80321: 
80321: CommandType.prototype = Object.create(Type.prototype);
80321: 
80321: CommandType.prototype.name = 'command';
80321: 
80321: CommandType.prototype.decrement = SelectionType.prototype.decrement;
80321: CommandType.prototype.increment = SelectionType.prototype.increment;
80321: CommandType.prototype._findValue = SelectionType.prototype._findValue;
80321: 
80321: CommandType.prototype.stringify = function(command) {
80321:   return command.name;
80321: };
80321: 
80321: /**
80321:  * Trim a list of commands (as from canon.getCommands()) according to those
80321:  * that match the provided arg.
80321:  */
80321: CommandType.prototype._findPredictions = function(arg) {
80321:   var predictions = [];
80321:   canon.getCommands().forEach(function(command) {
80321:     if (command.name.indexOf(arg.text) === 0) {
80321:       // The command type needs to exclude sub-commands when the CLI
80321:       // is blank, but include them when we're filtering. This hack
80321:       // excludes matches when the filter text is '' and when the
80321:       // name includes a space.
80321:       if (arg.text.length !== 0 || command.name.indexOf(' ') === -1) {
80321:         predictions.push(command);
80321:       }
80321:     }
80321:   }, this);
80321:   return predictions;
80321: };
80321: 
80321: CommandType.prototype.parse = function(arg) {
80321:   // Especially at startup, predictions live over the time that things change
80321:   // so we provide a completion function rather than completion values
80321:   var predictFunc = function() {
80321:     return this._findPredictions(arg);
80321:   }.bind(this);
80321: 
80321:   var predictions = this._findPredictions(arg);
80321: 
80321:   if (predictions.length === 0) {
80321:     return new Conversion(null, arg, Status.ERROR,
80321:         'Can\'t use \'' + arg.text + '\'.', predictFunc);
80321:   }
80321: 
80321:   var command = predictions[0];
80321: 
80321:   if (predictions.length === 1) {
80321:     // Is it an exact match of an executable command,
80321:     // or just the only possibility?
80321:     if (command.name === arg.text && typeof command.exec === 'function') {
80321:       return new Conversion(command, arg, Status.VALID, '');
80321:     }
80321:     return new Conversion(null, arg, Status.INCOMPLETE, '', predictFunc);
80321:   }
80321: 
80321:   // It's valid if the text matches, even if there are several options
80321:   if (command.name === arg.text) {
80321:     return new Conversion(command, arg, Status.VALID, '', predictFunc);
80321:   }
80321: 
80321:   return new Conversion(null, arg, Status.INCOMPLETE, '', predictFunc);
80321: };
80321: 
80321: 
80321: /**
80321:  * How to dynamically execute JavaScript code
80321:  */
80321: var customEval = eval;
80321: 
80321: /**
80321:  * Setup a function to be called in place of 'eval', generally for security
80321:  * reasons
80321:  */
80321: exports.setEvalFunction = function(newCustomEval) {
80321:   customEval = newCustomEval;
80321: };
80321: 
80321: /**
80321:  * Remove the binding done by setEvalFunction().
80321:  * We purposely set customEval to undefined rather than to 'eval' because there
80321:  * is an implication of setEvalFunction that we're in a security sensitive
80321:  * situation. What if we can trick GCLI into calling unsetEvalFunction() at the
80321:  * wrong time?
80321:  * So to properly undo the effects of setEvalFunction(), you need to call
80321:  * setEvalFunction(eval) rather than unsetEvalFunction(), however the latter is
80321:  * preferred in most cases.
80321:  */
80321: exports.unsetEvalFunction = function() {
80321:   customEval = undefined;
80321: };
80321: 
80321: /**
80321:  * 'eval' command
80321:  */
80321: var evalCommandSpec = {
80321:   name: '{',
80321:   params: [
80321:     {
80321:       name: 'javascript',
80321:       type: 'javascript',
80321:       description: ''
80321:     }
80321:   ],
80321:   returnType: 'html',
80321:   description: { key: 'cliEvalJavascript' },
80321:   exec: function(args, context) {
80321:     // &#x2192; is right arrow. We use explicit entities to ensure XML validity
80321:     var resultPrefix = '<em>{ ' + args.javascript + ' }</em> &#x2192; ';
80321:     try {
80321:       var result = customEval(args.javascript);
80321: 
80321:       if (result === null) {
80321:         return resultPrefix + 'null.';
80321:       }
80321: 
80321:       if (result === undefined) {
80321:         return resultPrefix + 'undefined.';
80321:       }
80321: 
80321:       if (typeof result === 'function') {
80321:         // &#160; is &nbsp;
80321:         return resultPrefix +
80321:             (result + '').replace(/\n/g, '<br>').replace(/ /g, '&#160;');
80321:       }
80321: 
80321:       return resultPrefix + result;
80321:     }
80321:     catch (ex) {
80321:       return resultPrefix + 'Exception: ' + ex.message;
80321:     }
80321:   }
80321: };
80321: 
80321: 
80321: /**
80321:  * This is a special assignment to reflect the command itself.
80321:  */
80321: function CommandAssignment() {
80321:   this.param = new canon.Parameter({
80321:     name: '__command',
80321:     type: 'command',
80321:     description: 'The command to execute'
80321:   });
80321:   this.paramIndex = -1;
81345:   this.assignmentChange = util.createEvent('CommandAssignment.assignmentChange');
80321: 
80321:   this.setDefault();
80321: }
80321: 
80321: CommandAssignment.prototype = Object.create(Assignment.prototype);
80321: 
80321: CommandAssignment.prototype.getStatus = function(arg) {
80321:   return Status.combine(
80321:     Assignment.prototype.getStatus.call(this, arg),
80321:     this.conversion.value && !this.conversion.value.exec ?
80321:       Status.INCOMPLETE : Status.VALID
80321:   );
80321: };
80321: 
80321: 
80321: /**
80321:  * Special assignment used when ignoring parameters that don't have a home
80321:  */
80321: function UnassignedAssignment() {
80321:   this.param = new canon.Parameter({
80321:     name: '__unassigned',
80321:     type: 'string'
80321:   });
80321:   this.paramIndex = -1;
81345:   this.assignmentChange = util.createEvent('UnassignedAssignment.assignmentChange');
80321: 
80321:   this.setDefault();
80321: }
80321: 
80321: UnassignedAssignment.prototype = Object.create(Assignment.prototype);
80321: 
80321: UnassignedAssignment.prototype.getStatus = function(arg) {
80321:   return Status.ERROR;
80321: };
80321: 
80321: UnassignedAssignment.prototype.setUnassigned = function(args) {
80321:   if (!args || args.length === 0) {
80321:     this.setDefault();
80321:   }
80321:   else {
80321:     var conversion = this.param.type.parse(new MergedArgument(args));
80321:     this.setConversion(conversion);
80321:   }
80321: };
80321: 
80321: 
80321: /**
80321:  * A Requisition collects the information needed to execute a command.
80321:  *
80321:  * (For a definition of the term, see http://en.wikipedia.org/wiki/Requisition)
80321:  * This term is used because carries the notion of a work-flow, or process to
80321:  * getting the information to execute a command correct.
80321:  * There is little point in a requisition for parameter-less commands because
80321:  * there is no information to collect. A Requisition is a collection of
80321:  * assignments of values to parameters, each handled by an instance of
80321:  * Assignment.
80321:  *
80321:  * <h2>Events<h2>
80321:  * <p>Requisition publishes the following events:
80321:  * <ul>
80321:  * <li>commandChange: The command has changed. It is likely that a UI
80321:  * structure will need updating to match the parameters of the new command.
80321:  * The event object looks like { command: A }
80321:  * <li>assignmentChange: This is a forward of the Assignment.assignmentChange
80321:  * event. It is fired when any assignment (except the commandAssignment)
80321:  * changes.
80321:  * <li>inputChange: The text to be mirrored in a command line has changed.
80321:  * The event object looks like { newText: X }.
80321:  * </ul>
80321:  *
82513:  * @param environment An optional opaque object passed to commands using
82513:  * ExecutionContext.
82513:  * @param doc A DOM Document passed to commands using ExecutionContext in
82513:  * order to allow creation of DOM nodes. If missing Requisition will use the
82513:  * global 'document'.
80321:  * @constructor
80321:  */
82513: function Requisition(environment, doc) {
80321:   this.environment = environment;
84249:   this.document = doc;
84249:   if (this.document == null) {
84249:     try {
84249:       this.document = document;
84249:     }
84249:     catch (ex) {
84249:       // Ignore
84249:     }
84249:   }
80321: 
80321:   // The command that we are about to execute.
80321:   // @see setCommandConversion()
80321:   this.commandAssignment = new CommandAssignment();
80321: 
80321:   // The object that stores of Assignment objects that we are filling out.
80321:   // The Assignment objects are stored under their param.name for named
80321:   // lookup. Note: We make use of the property of Javascript objects that
80321:   // they are not just hashmaps, but linked-list hashmaps which iterate in
80321:   // insertion order.
80321:   // _assignments excludes the commandAssignment.
80321:   this._assignments = {};
80321: 
80321:   // The count of assignments. Excludes the commandAssignment
80321:   this.assignmentCount = 0;
80321: 
80321:   // Used to store cli arguments in the order entered on the cli
80321:   this._args = [];
80321: 
80321:   // Used to store cli arguments that were not assigned to parameters
80321:   this._unassigned = new UnassignedAssignment();
80321: 
80321:   // Temporarily set this to true to prevent _onAssignmentChange resetting
80321:   // argument positions
80321:   this._structuralChangeInProgress = false;
80321: 
80321:   this.commandAssignment.assignmentChange.add(this._onCommandAssignmentChange, this);
80321:   this.commandAssignment.assignmentChange.add(this._onAssignmentChange, this);
80321: 
80321:   this.commandOutputManager = canon.commandOutputManager;
80321: 
81345:   this.assignmentChange = util.createEvent('Requisition.assignmentChange');
81345:   this.commandChange = util.createEvent('Requisition.commandChange');
81345:   this.inputChange = util.createEvent('Requisition.inputChange');
80321: }
80321: 
80321: /**
80321:  * Some number that is higher than the most args we'll ever have. Would use
80321:  * MAX_INTEGER if that made sense
80321:  */
80321: var MORE_THAN_THE_MOST_ARGS_POSSIBLE = 1000000;
80321: 
80321: /**
80321:  * Avoid memory leaks
80321:  */
80321: Requisition.prototype.destroy = function() {
80321:   this.commandAssignment.assignmentChange.remove(this._onCommandAssignmentChange, this);
80321:   this.commandAssignment.assignmentChange.remove(this._onAssignmentChange, this);
80321: 
80321:   delete this.document;
80321:   delete this.environment;
80321: };
80321: 
80321: /**
80321:  * When any assignment changes, we might need to update the _args array to
80321:  * match and inform people of changes to the typed input text.
80321:  */
80321: Requisition.prototype._onAssignmentChange = function(ev) {
80321:   // Don't report an event if the value is unchanged
80321:   if (ev.oldConversion != null &&
80321:       ev.conversion.valueEquals(ev.oldConversion)) {
80321:     return;
80321:   }
80321: 
80321:   if (this._structuralChangeInProgress) {
80321:     return;
80321:   }
80321: 
80321:   this.assignmentChange(ev);
80321: 
80321:   // Both for argument position and the inputChange event, we only care
80321:   // about changes to the argument.
80321:   if (ev.conversion.argEquals(ev.oldConversion)) {
80321:     return;
80321:   }
80321: 
80321:   this._structuralChangeInProgress = true;
80321: 
80321:   // Refactor? See bug 660765
80321:   // Do preceding arguments need to have dummy values applied so we don't
80321:   // get a hole in the command line?
80321:   if (ev.assignment.param.isPositionalAllowed()) {
80321:     for (var i = 0; i < ev.assignment.paramIndex; i++) {
80321:       var assignment = this.getAssignment(i);
80321:       if (assignment.param.isPositionalAllowed()) {
80321:         if (assignment.ensureVisibleArgument()) {
80321:           this._args.push(assignment.getArg());
80321:         }
80321:       }
80321:     }
80321:   }
80321: 
80321:   // Remember where we found the first match
80321:   var index = MORE_THAN_THE_MOST_ARGS_POSSIBLE;
80321:   for (var i = 0; i < this._args.length; i++) {
80321:     if (this._args[i].assignment === ev.assignment) {
80321:       if (i < index) {
80321:         index = i;
80321:       }
80321:       this._args.splice(i, 1);
80321:       i--;
80321:     }
80321:   }
80321: 
80321:   if (index === MORE_THAN_THE_MOST_ARGS_POSSIBLE) {
80321:     this._args.push(ev.assignment.getArg());
80321:   }
80321:   else {
80321:     // Is there a way to do this that doesn't involve a loop?
80321:     var newArgs = ev.conversion.arg.getArgs();
80321:     for (var i = 0; i < newArgs.length; i++) {
80321:       this._args.splice(index + i, 0, newArgs[i]);
80321:     }
80321:   }
80321:   this._structuralChangeInProgress = false;
80321: 
80321:   this.inputChange();
80321: };
80321: 
80321: /**
80321:  * When the command changes, we need to keep a bunch of stuff in sync
80321:  */
80321: Requisition.prototype._onCommandAssignmentChange = function(ev) {
80321:   this._assignments = {};
80321: 
80321:   var command = this.commandAssignment.getValue();
80321:   if (command) {
80321:     for (var i = 0; i < command.params.length; i++) {
80321:       var param = command.params[i];
80321:       var assignment = new Assignment(param, i);
80321:       assignment.assignmentChange.add(this._onAssignmentChange, this);
80321:       this._assignments[param.name] = assignment;
80321:     }
80321:   }
80321:   this.assignmentCount = Object.keys(this._assignments).length;
80321: 
80321:   this.commandChange({
80321:     requisition: this,
80321:     oldValue: ev.oldValue,
80321:     newValue: command
80321:   });
80321: };
80321: 
80321: /**
80321:  * Assignments have an order, so we need to store them in an array.
80321:  * But we also need named access ...
80931:  * @return The found assignment, or undefined, if no match was found
80321:  */
80321: Requisition.prototype.getAssignment = function(nameOrNumber) {
80321:   var name = (typeof nameOrNumber === 'string') ?
80321:     nameOrNumber :
80321:     Object.keys(this._assignments)[nameOrNumber];
80931:   return this._assignments[name] || undefined;
80321: },
80321: 
80321: /**
80931:  * Where parameter name == assignment names - they are the same
80321:  */
80321: Requisition.prototype.getParameterNames = function() {
80321:   return Object.keys(this._assignments);
80321: },
80321: 
80321: /**
80321:  * A *shallow* clone of the assignments.
80321:  * This is useful for systems that wish to go over all the assignments
80321:  * finding values one way or another and wish to trim an array as they go.
80321:  */
80321: Requisition.prototype.cloneAssignments = function() {
80321:   return Object.keys(this._assignments).map(function(name) {
80321:     return this._assignments[name];
80321:   }, this);
80321: };
80321: 
80321: /**
80321:  * The overall status is the most severe status.
80321:  * There is no such thing as an INCOMPLETE overall status because the
80321:  * definition of INCOMPLETE takes into account the cursor position to say 'this
80321:  * isn't quite ERROR because the user can fix it by typing', however overall,
80321:  * this is still an error status.
80321:  */
80321: Requisition.prototype.getStatus = function() {
80321:   var status = Status.VALID;
80321:   this.getAssignments(true).forEach(function(assignment) {
80321:     var assignStatus = assignment.getStatus();
80321:     if (assignment.getStatus() > status) {
80321:       status = assignStatus;
80321:     }
80321:   }, this);
80321:   if (status === Status.INCOMPLETE) {
80321:     status = Status.ERROR;
80321:   }
80321:   return status;
80321: };
80321: 
80321: /**
80321:  * Extract the names and values of all the assignments, and return as
80321:  * an object.
80321:  */
80321: Requisition.prototype.getArgsObject = function() {
80321:   var args = {};
80321:   this.getAssignments().forEach(function(assignment) {
80321:     args[assignment.param.name] = assignment.getValue();
80321:   }, this);
80321:   return args;
80321: };
80321: 
80321: /**
80321:  * Access the arguments as an array.
80321:  * @param includeCommand By default only the parameter arguments are
80321:  * returned unless (includeCommand === true), in which case the list is
80321:  * prepended with commandAssignment.getArg()
80321:  */
80321: Requisition.prototype.getAssignments = function(includeCommand) {
80321:   var assignments = [];
80321:   if (includeCommand === true) {
80321:     assignments.push(this.commandAssignment);
80321:   }
80321:   Object.keys(this._assignments).forEach(function(name) {
80321:     assignments.push(this.getAssignment(name));
80321:   }, this);
80321:   return assignments;
80321: };
80321: 
80321: /**
80321:  * Reset all the assignments to their default values
80321:  */
80321: Requisition.prototype.setDefaultArguments = function() {
80321:   this.getAssignments().forEach(function(assignment) {
80321:     assignment.setDefault();
80321:   }, this);
80321: };
80321: 
80321: /**
80321:  * Extract a canonical version of the input
80321:  */
80321: Requisition.prototype.toCanonicalString = function() {
80321:   var line = [];
80321: 
80321:   var cmd = this.commandAssignment.getValue() ?
80321:       this.commandAssignment.getValue().name :
80321:       this.commandAssignment.getArg().text;
80321:   line.push(cmd);
80321: 
80321:   Object.keys(this._assignments).forEach(function(name) {
80321:     var assignment = this._assignments[name];
80321:     var type = assignment.param.type;
80321:     // Bug 664377: This will cause problems if there is a non-default value
80321:     // after a default value. Also we need to decide when to use
80321:     // named parameters in place of positional params. Both can wait.
80321:     if (assignment.getValue() !== assignment.param.defaultValue) {
80321:       line.push(' ');
80321:       line.push(type.stringify(assignment.getValue()));
80321:     }
80321:   }, this);
80321: 
80321:   // Canonically, if we've opened with a { then we should have a } to close
80321:   if (cmd === '{') {
80321:     if (this.getAssignment(0).getArg().suffix.indexOf('}') === -1) {
80321:       line.push(' }');
80321:     }
80321:   }
80321: 
80321:   return line.join('');
80321: };
80321: 
80321: /**
80321:  * Input trace gives us an array of Argument tracing objects, one for each
80321:  * character in the typed input, from which we can derive information about how
80321:  * to display this typed input. It's a bit like toString on steroids.
80321:  * <p>
80321:  * The returned object has the following members:<ul>
80321:  * <li>char: The character to which this arg trace refers.
80321:  * <li>arg: The Argument to which this character is assigned.
80321:  * <li>part: One of ['prefix'|'text'|suffix'] - how was this char understood
80321:  * </ul>
80321:  * <p>
80321:  * The Argument objects are as output from #_tokenize() rather than as applied
80321:  * to Assignments by #_assign() (i.e. they are not instances of NamedArgument,
80321:  * ArrayArgument, etc).
80321:  * <p>
80321:  * To get at the arguments applied to the assignments simply call
80321:  * <tt>arg.assignment.arg</tt>. If <tt>arg.assignment.arg !== arg</tt> then
80321:  * the arg applied to the assignment will contain the original arg.
80321:  * See #_assign() for details.
80321:  */
80321: Requisition.prototype.createInputArgTrace = function() {
80321:   if (!this._args) {
80321:     throw new Error('createInputMap requires a command line. See source.');
80321:     // If this is a problem then we can fake command line input using
80321:     // something like the code in #toCanonicalString().
80321:   }
80321: 
80321:   var args = [];
80321:   this._args.forEach(function(arg) {
80321:     for (var i = 0; i < arg.prefix.length; i++) {
80321:       args.push({ arg: arg, char: arg.prefix[i], part: 'prefix' });
80321:     }
80321:     for (var i = 0; i < arg.text.length; i++) {
80321:       args.push({ arg: arg, char: arg.text[i], part: 'text' });
80321:     }
80321:     for (var i = 0; i < arg.suffix.length; i++) {
80321:       args.push({ arg: arg, char: arg.suffix[i], part: 'suffix' });
80321:     }
80321:   });
80321: 
80321:   return args;
80321: };
80321: 
80321: /**
80321:  * Reconstitute the input from the args
80321:  */
80321: Requisition.prototype.toString = function() {
80321:   if (this._args) {
80321:     return this._args.map(function(arg) {
80321:       return arg.toString();
80321:     }).join('');
80321:   }
80321: 
80321:   return this.toCanonicalString();
80321: };
80321: 
80321: /**
80321:  * Return an array of Status scores so we can create a marked up
80321:  * version of the command line input.
82513:  * @param cursor We only take a status of INCOMPLETE to be INCOMPLETE when the
82513:  * cursor is actually in the argument. Otherwise it's an error.
82513:  */
82513: Requisition.prototype.getInputStatusMarkup = function(cursor) {
80321:   var argTraces = this.createInputArgTrace();
80321:   // Generally the 'argument at the cursor' is the argument before the cursor
80321:   // unless it is before the first char, in which case we take the first.
82513:   cursor = cursor === 0 ? 0 : cursor - 1;
80321:   var cTrace = argTraces[cursor];
80321: 
80321:   var statuses = [];
80321:   for (var i = 0; i < argTraces.length; i++) {
80321:     var argTrace = argTraces[i];
80321:     var arg = argTrace.arg;
80321:     var status = Status.VALID;
80321:     if (argTrace.part === 'text') {
80321:       status = arg.assignment.getStatus(arg);
80321:       // Promote INCOMPLETE to ERROR  ...
80321:       if (status === Status.INCOMPLETE) {
80321:         // If the cursor is not in a position to be able to complete it
80321:         if (arg !== cTrace.arg || cTrace.part !== 'text') {
80321:           // And if we're not in the command
80321:           if (!(arg.assignment instanceof CommandAssignment)) {
80321:             status = Status.ERROR;
80321:           }
80321:         }
80321:       }
80321:     }
80321: 
80321:     statuses.push(status);
80321:   }
80321: 
80321:   return statuses;
80321: };
80321: 
80321: /**
80321:  * Look through the arguments attached to our assignments for the assignment
80321:  * at the given position.
80321:  * @param {number} cursor The cursor position to query
80321:  */
80321: Requisition.prototype.getAssignmentAt = function(cursor) {
80321:   if (!this._args) {
80321:     console.trace();
80321:     throw new Error('Missing args');
80321:   }
80321: 
80321:   // We short circuit this one because we may have no args, or no args with
80321:   // any size and the alg below only finds arguments with size.
80321:   if (cursor === 0) {
80321:     return this.commandAssignment;
80321:   }
80321: 
80321:   var assignForPos = [];
80321:   var i, j;
80321:   for (i = 0; i < this._args.length; i++) {
80321:     var arg = this._args[i];
80321:     var assignment = arg.assignment;
80321: 
80321:     // prefix and text are clearly part of the argument
80321:     for (j = 0; j < arg.prefix.length; j++) {
80321:       assignForPos.push(assignment);
80321:     }
80321:     for (j = 0; j < arg.text.length; j++) {
80321:       assignForPos.push(assignment);
80321:     }
80321: 
80321:     // suffix looks forwards
80321:     if (this._args.length > i + 1) {
80321:       // first to the next argument
80321:       assignment = this._args[i + 1].assignment;
80321:     }
80321:     else if (assignment &&
80321:         assignment.paramIndex + 1 < this.assignmentCount) {
80321:       // then to the next assignment
80321:       assignment = this.getAssignment(assignment.paramIndex + 1);
80321:     }
80321: 
80321:     for (j = 0; j < arg.suffix.length; j++) {
80321:       assignForPos.push(assignment);
80321:     }
80321:   }
80321: 
80321:   // Possible shortcut, we don't really need to go through all the args
80321:   // to work out the solution to this
80321: 
80321:   var reply = assignForPos[cursor - 1];
80321: 
80321:   if (!reply) {
80321:     throw new Error('Missing assignment.' +
80321:       ' cursor=' + cursor + ' text.length=' + this.toString().length);
80321:   }
80321: 
80321:   return reply;
80321: };
80321: 
80321: /**
80321:  * Entry point for keyboard accelerators or anything else that wants to execute
80321:  * a command.
80321:  * @param input Object containing data about how to execute the command.
80321:  * Properties of input include:
80321:  * - args: Arguments for the command
80321:  * - typed: The typed command
80321:  * - visible: Ensure that the output from this command is visible
80321:  */
80321: Requisition.prototype.exec = function(input) {
80321:   var command;
80321:   var args;
80321:   var visible = true;
80321: 
80321:   if (input) {
80321:     if (input.args != null) {
80321:       // Fast track by looking up the command directly since passed args
80321:       // means there is no command line to parse.
80321:       command = canon.getCommand(input.typed);
80321:       if (!command) {
80321:         console.error('Command not found: ' + command);
80321:       }
80321:       args = input.args;
80321: 
80321:       // Default visible to false since this is exec is probably the
80321:       // result of a keyboard shortcut
80321:       visible = 'visible' in input ? input.visible : false;
80321:     }
80321:     else {
80321:       this.update(input);
80321:     }
80321:   }
80321: 
80321:   if (!command) {
80321:     command = this.commandAssignment.getValue();
80321:     args = this.getArgsObject();
80321:   }
80321: 
80321:   if (!command) {
80321:     return false;
80321:   }
80321: 
80321:   var outputObject = {
80321:     command: command,
80321:     args: args,
84249:     typed: this.toString(),
84249:     canonical: this.toCanonicalString(),
80321:     completed: false,
80321:     start: new Date()
80321:   };
80321: 
80321:   this.commandOutputManager.sendCommandOutput(outputObject);
80321: 
80321:   var onComplete = (function(output, error) {
80321:     if (visible) {
80321:       outputObject.end = new Date();
80321:       outputObject.duration = outputObject.end.getTime() - outputObject.start.getTime();
80321:       outputObject.error = error;
80321:       outputObject.output = output;
80321:       outputObject.completed = true;
80321:       this.commandOutputManager.sendCommandOutput(outputObject);
80321:     }
80321:   }).bind(this);
80321: 
80321:   try {
84244:     var context = new ExecutionContext(this);
80321:     var reply = command.exec(args, context);
80321: 
80321:     if (reply != null && reply.isPromise) {
80321:       reply.then(
80321:         function(data) { onComplete(data, false); },
80321:         function(error) { onComplete(error, true); });
80321: 
80321:       // Add progress to our promise and add a handler for it here
80321:       // See bug 659300
80321:     }
80321:     else {
80321:       onComplete(reply, false);
80321:     }
80321:   }
80321:   catch (ex) {
80321:     onComplete(ex, true);
80321:   }
80321: 
80321:   this.clear();
80321:   return true;
80321: };
80321: 
80321: /**
80321:  * Called by the UI when ever the user interacts with a command line input
80321:  * @param input A structure that details the state of the input field.
80321:  * It should look something like: { typed:a, cursor: { start:b, end:c } }
80321:  * Where a is the contents of the input field, and b and c are the start
80321:  * and end of the cursor/selection respectively.
80321:  * <p>The general sequence is:
80321:  * <ul>
80321:  * <li>_tokenize(): convert _typed into _parts
80321:  * <li>_split(): convert _parts into _command and _unparsedArgs
80321:  * <li>_assign(): convert _unparsedArgs into requisition
80321:  * </ul>
80321:  */
80321: Requisition.prototype.update = function(input) {
82513:   if (input.cursor == null) {
82513:     input.cursor = { start: input.length, end: input.length };
80321:   }
80321: 
80321:   this._structuralChangeInProgress = true;
80321: 
80321:   this._args = this._tokenize(input.typed);
80321: 
80321:   var args = this._args.slice(0); // i.e. clone
80321:   this._split(args);
80321:   this._assign(args);
80321: 
80321:   this._structuralChangeInProgress = false;
80321: 
80321:   this.inputChange();
80321: };
80321: 
80321: /**
80321:  * Empty the current buffer, and notify listeners that we're now empty
80321:  */
80321: Requisition.prototype.clear = function() {
80321:   this.update({ typed: '', cursor: { start: 0, end: 0 } });
80321: };
80321: 
80321: /**
80321:  * Requisition._tokenize() is a state machine. These are the states.
80321:  */
80321: var In = {
80321:   /**
80321:    * The last character was ' '.
80321:    * Typing a ' ' character will not change the mode
80321:    * Typing one of '"{ will change mode to SINGLE_Q, DOUBLE_Q or SCRIPT.
80321:    * Anything else goes into SIMPLE mode.
80321:    */
80321:   WHITESPACE: 1,
80321: 
80321:   /**
80321:    * The last character was part of a parameter.
80321:    * Typing ' ' returns to WHITESPACE mode. Any other character
80321:    * (including '"{} which are otherwise special) does not change the mode.
80321:    */
80321:   SIMPLE: 2,
80321: 
80321:   /**
80321:    * We're inside single quotes: '
80321:    * Typing ' returns to WHITESPACE mode. Other characters do not change mode.
80321:    */
80321:   SINGLE_Q: 3,
80321: 
80321:   /**
80321:    * We're inside double quotes: "
80321:    * Typing " returns to WHITESPACE mode. Other characters do not change mode.
80321:    */
80321:   DOUBLE_Q: 4,
80321: 
80321:   /**
80321:    * We're inside { and }
80321:    * Typing } returns to WHITESPACE mode. Other characters do not change mode.
80321:    * SCRIPT mode is slightly different from other modes in that spaces between
80321:    * the {/} delimiters and the actual input are not considered significant.
80321:    * e.g: " x " is a 3 character string, delimited by double quotes, however
80321:    * { x } is a 1 character JavaScript surrounded by whitespace and {}
80321:    * delimiters.
80321:    * In the short term we assume that the JS routines can make sense of the
80321:    * extra whitespace, however at some stage we may need to move the space into
80321:    * the Argument prefix/suffix.
80321:    * Also we don't attempt to handle nested {}. See bug 678961
80321:    */
80321:   SCRIPT: 5
80321: };
80321: 
80321: /**
80321:  * Split up the input taking into account ', " and {.
80321:  * We don't consider \t or other classical whitespace characters to split
80321:  * arguments apart. For one thing these characters are hard to type, but also
80321:  * if the user has gone to the trouble of pasting a TAB character into the
80321:  * input field (or whatever it takes), they probably mean it.
80321:  */
80321: Requisition.prototype._tokenize = function(typed) {
80321:   // For blank input, place a dummy empty argument into the list
80321:   if (typed == null || typed.length === 0) {
80321:     return [ new Argument('', '', '') ];
80321:   }
80321: 
80321:   if (isSimple(typed)) {
80321:     return [ new Argument(typed, '', '') ];
80321:   }
80321: 
80321:   var mode = In.WHITESPACE;
80321: 
80321:   // First we un-escape. This list was taken from:
80321:   // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Unicode
80321:   // We are generally converting to their real values except for the strings
80321:   // '\'', '\"', '\ ', '{' and '}' which we are converting to unicode private
80321:   // characters so we can distinguish them from '"', ' ', '{', '}' and ''',
80321:   // which are special. They need swapping back post-split - see unescape2()
80321:   typed = typed
80321:       .replace(/\\\\/g, '\\')
80321:       .replace(/\\b/g, '\b')
80321:       .replace(/\\f/g, '\f')
80321:       .replace(/\\n/g, '\n')
80321:       .replace(/\\r/g, '\r')
80321:       .replace(/\\t/g, '\t')
80321:       .replace(/\\v/g, '\v')
80321:       .replace(/\\n/g, '\n')
80321:       .replace(/\\r/g, '\r')
80321:       .replace(/\\ /g, '\uF000')
80321:       .replace(/\\'/g, '\uF001')
80321:       .replace(/\\"/g, '\uF002')
80321:       .replace(/\\{/g, '\uF003')
80321:       .replace(/\\}/g, '\uF004');
80321: 
80321:   function unescape2(escaped) {
80321:     return escaped
80321:         .replace(/\uF000/g, ' ')
80321:         .replace(/\uF001/g, '\'')
80321:         .replace(/\uF002/g, '"')
80321:         .replace(/\uF003/g, '{')
80321:         .replace(/\uF004/g, '}');
80321:   }
80321: 
80321:   var i = 0;          // The index of the current character
80321:   var start = 0;      // Where did this section start?
80321:   var prefix = '';    // Stuff that comes before the current argument
80321:   var args = [];      // The array that we're creating
80321:   var blockDepth = 0; // For JS with nested {}
80321: 
80321:   // This is just a state machine. We're going through the string char by char
80321:   // The 'mode' is one of the 'In' states. As we go, we're adding Arguments
80321:   // to the 'args' array.
80321: 
80321:   while (true) {
80321:     var c = typed[i];
80321:     switch (mode) {
80321:       case In.WHITESPACE:
80321:         if (c === '\'') {
80321:           prefix = typed.substring(start, i + 1);
80321:           mode = In.SINGLE_Q;
80321:           start = i + 1;
80321:         }
80321:         else if (c === '"') {
80321:           prefix = typed.substring(start, i + 1);
80321:           mode = In.DOUBLE_Q;
80321:           start = i + 1;
80321:         }
80321:         else if (c === '{') {
80321:           prefix = typed.substring(start, i + 1);
80321:           mode = In.SCRIPT;
80321:           blockDepth++;
80321:           start = i + 1;
80321:         }
80321:         else if (/ /.test(c)) {
80321:           // Still whitespace, do nothing
80321:         }
80321:         else {
80321:           prefix = typed.substring(start, i);
80321:           mode = In.SIMPLE;
80321:           start = i;
80321:         }
80321:         break;
80321: 
80321:       case In.SIMPLE:
80321:         // There is an edge case of xx'xx which we are assuming to
80321:         // be a single parameter (and same with ")
80321:         if (c === ' ') {
80321:           var str = unescape2(typed.substring(start, i));
80321:           args.push(new Argument(str, prefix, ''));
80321:           mode = In.WHITESPACE;
80321:           start = i;
80321:           prefix = '';
80321:         }
80321:         break;
80321: 
80321:       case In.SINGLE_Q:
80321:         if (c === '\'') {
80321:           var str = unescape2(typed.substring(start, i));
80321:           args.push(new Argument(str, prefix, c));
80321:           mode = In.WHITESPACE;
80321:           start = i + 1;
80321:           prefix = '';
80321:         }
80321:         break;
80321: 
80321:       case In.DOUBLE_Q:
80321:         if (c === '"') {
80321:           var str = unescape2(typed.substring(start, i));
80321:           args.push(new Argument(str, prefix, c));
80321:           mode = In.WHITESPACE;
80321:           start = i + 1;
80321:           prefix = '';
80321:         }
80321:         break;
80321: 
80321:       case In.SCRIPT:
80321:         if (c === '{') {
80321:           blockDepth++;
80321:         }
80321:         else if (c === '}') {
80321:           blockDepth--;
80321:           if (blockDepth === 0) {
80321:             var str = unescape2(typed.substring(start, i));
80321:             args.push(new ScriptArgument(str, prefix, c));
80321:             mode = In.WHITESPACE;
80321:             start = i + 1;
80321:             prefix = '';
80321:           }
80321:         }
80321:         break;
80321:     }
80321: 
80321:     i++;
80321: 
80321:     if (i >= typed.length) {
80321:       // There is nothing else to read - tidy up
80321:       if (mode === In.WHITESPACE) {
80321:         if (i !== start) {
80321:           // There's whitespace at the end of the typed string. Add it to the
80321:           // last argument's suffix, creating an empty argument if needed.
80321:           var extra = typed.substring(start, i);
80321:           var lastArg = args[args.length - 1];
80321:           if (!lastArg) {
80321:             args.push(new Argument('', extra, ''));
80321:           }
80321:           else {
80321:             lastArg.suffix += extra;
80321:           }
80321:         }
80321:       }
80321:       else if (mode === In.SCRIPT) {
80321:         var str = unescape2(typed.substring(start, i + 1));
80321:         args.push(new ScriptArgument(str, prefix, ''));
80321:       }
80321:       else {
80321:         var str = unescape2(typed.substring(start, i + 1));
80321:         args.push(new Argument(str, prefix, ''));
80321:       }
80321:       break;
80321:     }
80321:   }
80321: 
80321:   return args;
80321: };
80321: 
80321: /**
80321:  * If the input has no spaces, quotes, braces or escapes,
80321:  * we can take the fast track.
80321:  */
80321: function isSimple(typed) {
80321:    for (var i = 0; i < typed.length; i++) {
80321:      var c = typed.charAt(i);
80321:      if (c === ' ' || c === '"' || c === '\'' ||
80321:          c === '{' || c === '}' || c === '\\') {
80321:        return false;
80321:      }
80321:    }
80321:    return true;
80321: }
80321: 
80321: /**
80321:  * Looks in the canon for a command extension that matches what has been
80321:  * typed at the command line.
80321:  */
80321: Requisition.prototype._split = function(args) {
80321:   // Handle the special case of the user typing { javascript(); }
80321:   // We use the hidden 'eval' command directly rather than shift()ing one of
80321:   // the parameters, and parse()ing it.
80321:   if (args[0] instanceof ScriptArgument) {
80321:     // Special case: if the user enters { console.log('foo'); } then we need to
80321:     // use the hidden 'eval' command
80321:     var conversion = new Conversion(evalCommand, new Argument());
80321:     this.commandAssignment.setConversion(conversion);
80321:     return;
80321:   }
80321: 
80321:   var argsUsed = 1;
80321:   var conversion;
80321: 
80321:   while (argsUsed <= args.length) {
80321:     var arg = (argsUsed === 1) ?
80321:       args[0] :
80321:       new MergedArgument(args, 0, argsUsed);
80321:     conversion = this.commandAssignment.param.type.parse(arg);
80321: 
80321:     // We only want to carry on if this command is a parent command,
80321:     // which means that there is a commandAssignment, but not one with
80321:     // an exec function.
80321:     if (!conversion.value || conversion.value.exec) {
80321:       break;
80321:     }
80321: 
80321:     // Previously we needed a way to hide commands depending context.
80321:     // We have not resurrected that feature yet, but if we do we should
80321:     // insert code here to ignore certain commands depending on the
80321:     // context/environment
80321: 
80321:     argsUsed++;
80321:   }
80321: 
80321:   this.commandAssignment.setConversion(conversion);
80321: 
80321:   for (var i = 0; i < argsUsed; i++) {
80321:     args.shift();
80321:   }
80321: 
80321:   // This could probably be re-written to consume args as we go
80321: };
80321: 
80321: /**
80321:  * Work out which arguments are applicable to which parameters.
80321:  */
80321: Requisition.prototype._assign = function(args) {
80321:   if (!this.commandAssignment.getValue()) {
80321:     this._unassigned.setUnassigned(args);
80321:     return;
80321:   }
80321: 
80321:   if (args.length === 0) {
80321:     this.setDefaultArguments();
80321:     this._unassigned.setDefault();
80321:     return;
80321:   }
80321: 
80321:   // Create an error if the command does not take parameters, but we have
80321:   // been given them ...
80321:   if (this.assignmentCount === 0) {
80321:     this._unassigned.setUnassigned(args);
80321:     return;
80321:   }
80321: 
80321:   // Special case: if there is only 1 parameter, and that's of type
80321:   // text, then we put all the params into the first param
80321:   if (this.assignmentCount === 1) {
80321:     var assignment = this.getAssignment(0);
80321:     if (assignment.param.type instanceof StringType) {
80321:       var arg = (args.length === 1) ?
80321:         args[0] :
80321:         new MergedArgument(args);
80321:       var conversion = assignment.param.type.parse(arg);
80321:       assignment.setConversion(conversion);
80321:       this._unassigned.setDefault();
80321:       return;
80321:     }
80321:   }
80321: 
80321:   // Positional arguments can still be specified by name, but if they are
80321:   // then we need to ignore them when working them out positionally
80321:   var names = this.getParameterNames();
80321: 
80321:   // We collect the arguments used in arrays here before assigning
80321:   var arrayArgs = {};
80321: 
80321:   // Extract all the named parameters
80321:   this.getAssignments(false).forEach(function(assignment) {
80321:     // Loop over the arguments
80321:     // Using while rather than loop because we remove args as we go
80321:     var i = 0;
80321:     while (i < args.length) {
80321:       if (assignment.param.isKnownAs(args[i].text)) {
80321:         var arg = args.splice(i, 1)[0];
80321:         names = names.filter(function(test) {
80321:           return test !== assignment.param.name;
80321:         });
80321: 
80321:         // boolean parameters don't have values, default to false
80321:         if (assignment.param.type instanceof BooleanType) {
80321:           arg = new TrueNamedArgument(null, arg);
80321:         }
80321:         else {
80321:           var valueArg = null;
80321:           if (i + 1 >= args.length) {
80321:             valueArg = args.splice(i, 1)[0];
80321:           }
80321:           arg = new NamedArgument(arg, valueArg);
80321:         }
80321: 
80321:         if (assignment.param.type instanceof ArrayType) {
80321:           var arrayArg = arrayArgs[assignment.param.name];
80321:           if (!arrayArg) {
80321:             arrayArg = new ArrayArgument();
80321:             arrayArgs[assignment.param.name] = arrayArg;
80321:           }
80321:           arrayArg.addArgument(arg);
80321:         }
80321:         else {
80321:           var conversion = assignment.param.type.parse(arg);
80321:           assignment.setConversion(conversion);
80321:         }
80321:       }
80321:       else {
80321:         // Skip this parameter and handle as a positional parameter
80321:         i++;
80321:       }
80321:     }
80321:   }, this);
80321: 
80321:   // What's left are positional parameters assign in order
80321:   names.forEach(function(name) {
80321:     var assignment = this.getAssignment(name);
80321: 
80321:     // If not set positionally, and we can't set it non-positionally,
80321:     // we have to default it to prevent previous values surviving
80321:     if (!assignment.param.isPositionalAllowed()) {
80321:       assignment.setDefault();
80321:       return;
80321:     }
80321: 
80321:     // If this is a positional array argument, then it swallows the
80321:     // rest of the arguments.
80321:     if (assignment.param.type instanceof ArrayType) {
80321:       var arrayArg = arrayArgs[assignment.param.name];
80321:       if (!arrayArg) {
80321:         arrayArg = new ArrayArgument();
80321:         arrayArgs[assignment.param.name] = arrayArg;
80321:       }
80321:       arrayArg.addArguments(args);
80321:       args = [];
80321:     }
80321:     else {
80321:       var arg = (args.length > 0) ?
80321:           args.splice(0, 1)[0] :
80321:           new Argument();
80321: 
80321:       var conversion = assignment.param.type.parse(arg);
80321:       assignment.setConversion(conversion);
80321:     }
80321:   }, this);
80321: 
80321:   // Now we need to assign the array argument (if any)
80321:   Object.keys(arrayArgs).forEach(function(name) {
80321:     var assignment = this.getAssignment(name);
80321:     var conversion = assignment.param.type.parse(arrayArgs[name]);
80321:     assignment.setConversion(conversion);
80321:   }, this);
80321: 
80321:   if (args.length > 0) {
80321:     this._unassigned.setUnassigned(args);
80321:   }
80321:   else {
80321:     this._unassigned.setDefault();
80321:   }
80321: };
80321: 
80321: exports.Requisition = Requisition;
80321: 
80321: 
80321: /**
80321:  * Functions and data related to the execution of a command
80321:  */
84244: function ExecutionContext(requisition) {
84244:   this.requisition = requisition;
84244:   this.environment = requisition.environment;
84244:   this.document = requisition.document;
80321: }
80321: 
80321: ExecutionContext.prototype.createPromise = function() {
80321:   return new Promise();
80321: };
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/promise', ['require', 'exports', 'module' ], function(require, exports, module) {
80321: 
80931:   Components.utils.import("resource:///modules/devtools/Promise.jsm");
80321:   exports.Promise = Promise;
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
84244: define('gcli/commands/help', ['require', 'exports', 'module' , 'gcli/canon', 'gcli/util', 'gcli/l10n', 'gcli/ui/domtemplate', 'text!gcli/commands/help.css', 'text!gcli/commands/help_intro.html', 'text!gcli/commands/help_list.html', 'text!gcli/commands/help_man.html'], function(require, exports, module) {
84244: var help = exports;
84244: 
84244: 
84244: var canon = require('gcli/canon');
84244: var util = require('gcli/util');
84244: var l10n = require('gcli/l10n');
84248: var domtemplate = require('gcli/ui/domtemplate');
84244: 
84244: var helpCss = require('text!gcli/commands/help.css');
84244: var helpStyle = undefined;
84244: var helpIntroHtml = require('text!gcli/commands/help_intro.html');
84244: var helpIntroTemplate = undefined;
84244: var helpListHtml = require('text!gcli/commands/help_list.html');
84244: var helpListTemplate = undefined;
84244: var helpManHtml = require('text!gcli/commands/help_man.html');
84244: var helpManTemplate = undefined;
84244: 
84244: /**
84244:  * 'help' command
84244:  * We delay definition of helpCommandSpec until help.startup() to ensure that
84244:  * the l10n strings have been loaded
84244:  */
84244: var helpCommandSpec;
84244: 
84244: /**
84244:  * Registration and de-registration.
84244:  */
84244: help.startup = function() {
84244: 
84244:   helpCommandSpec = {
84244:     name: 'help',
84244:     description: l10n.lookup('helpDesc'),
84244:     manual: l10n.lookup('helpManual'),
84244:     params: [
84244:       {
84244:         name: 'search',
84244:         type: 'string',
84244:         description: l10n.lookup('helpSearchDesc'),
84244:         manual: l10n.lookup('helpSearchManual'),
84244:         defaultValue: null
84244:       }
84244:     ],
84244:     returnType: 'html',
84244: 
84244:     exec: function(args, context) {
84244:       help.onFirstUseStartup(context.document);
84244: 
84244:       var match = canon.getCommand(args.search);
84244:       if (match) {
84244:         var clone = helpManTemplate.cloneNode(true);
84248:         domtemplate.template(clone, getManTemplateData(match, context),
84253:                 { allowEval: true, stack: 'help_man.html' });
84244:         return clone;
84244:       }
84244: 
84244:       var parent = util.dom.createElement(context.document, 'div');
84244:       if (!args.search) {
84244:         parent.appendChild(helpIntroTemplate.cloneNode(true));
84244:       }
84244:       parent.appendChild(helpListTemplate.cloneNode(true));
84248:       domtemplate.template(parent, getListTemplateData(args, context),
84248:               { allowEval: true, stack: 'help_intro.html | help_list.html' });
84244:       return parent;
84244:     }
84244:   };
84244: 
84244:   canon.addCommand(helpCommandSpec);
84244: };
84244: 
84244: help.shutdown = function() {
84244:   canon.removeCommand(helpCommandSpec);
84244: 
84244:   helpListTemplate = undefined;
84244:   helpStyle.parentElement.removeChild(helpStyle);
84244:   helpStyle = undefined;
84244: };
84244: 
84244: /**
84244:  * Called when the command is executed
84244:  */
84244: help.onFirstUseStartup = function(document) {
84244:   if (!helpIntroTemplate) {
84244:     helpIntroTemplate = util.dom.createElement(document, 'div');
84244:     util.dom.setInnerHtml(helpIntroTemplate, helpIntroHtml);
84244:   }
84244:   if (!helpListTemplate) {
84244:     helpListTemplate = util.dom.createElement(document, 'div');
84244:     util.dom.setInnerHtml(helpListTemplate, helpListHtml);
84244:   }
84244:   if (!helpManTemplate) {
84244:     helpManTemplate = util.dom.createElement(document, 'div');
84244:     util.dom.setInnerHtml(helpManTemplate, helpManHtml);
84244:   }
84244:   if (!helpStyle && helpCss != null) {
84244:     helpStyle = util.dom.importCss(helpCss, document);
84244:   }
84244: };
84244: 
84244: /**
84244:  * Find an element within the passed element with the class gcli-help-command
84244:  * and update the requisition to contain this text.
84244:  */
84244: function updateCommand(element, context) {
84244:   context.requisition.update({
84244:     typed: element.querySelector('.gcli-help-command').textContent
84244:   });
84244: }
84244: 
84244: /**
84244:  * Find an element within the passed element with the class gcli-help-command
84244:  * and execute this text.
84244:  */
84244: function executeCommand(element, context) {
84244:   context.requisition.exec({
84244:     visible: true,
84244:     typed: element.querySelector('.gcli-help-command').textContent
84244:   });
84244: }
84244: 
84244: /**
84244:  * Create a block of data suitable to be passed to the help_list.html template
84244:  */
84244: function getListTemplateData(args, context) {
84244:   return {
84253:     l10n: l10n.propertyLookup,
84253:     lang: context.document.defaultView.navigator.language,
84253: 
84244:     onclick: function(ev) {
84244:       updateCommand(ev.currentTarget, context);
84244:     },
84244: 
84244:     ondblclick: function(ev) {
84244:       executeCommand(ev.currentTarget, context);
84244:     },
84244: 
84244:     getHeading: function() {
84244:       return args.search == null ?
84244:               'Available Commands:' :
84244:               'Commands starting with \'' + args.search + '\':';
84244:     },
84244: 
84244:     getMatchingCommands: function() {
84244:       var matching = canon.getCommands().filter(function(command) {
84244:         if (args.search && command.name.indexOf(args.search) !== 0) {
84244:           // Filtered out because they don't match the search
84244:           return false;
84244:         }
84244:         if (!args.search && command.name.indexOf(' ') != -1) {
84244:           // We don't show sub commands with plain 'help'
84244:           return false;
84244:         }
84244:         return true;
84244:       });
84244:       matching.sort();
84244:       return matching;
84244:     }
84244:   };
84244: }
84244: 
84244: /**
84244:  * Create a block of data suitable to be passed to the help_man.html template
84244:  */
84244: function getManTemplateData(command, context) {
84244:   return {
84253:     l10n: l10n.propertyLookup,
84253:     lang: context.document.defaultView.navigator.language,
84253: 
84244:     command: command,
84244: 
84244:     onclick: function(ev) {
84244:       updateCommand(ev.currentTarget, context);
84244:     },
84244: 
84244:     getTypeDescription: function(param) {
84244:       var input = '';
84244:       if (param.defaultValue === undefined) {
84244:         input = 'required';
84244:       }
84244:       else if (param.defaultValue === null) {
84244:         input = 'optional';
84244:       }
84244:       else {
84244:         input = param.defaultValue;
84244:       }
84244:       return '(' + param.type.name + ', ' + input + ')';
84244:     }
84244:   };
84244: }
84244: 
84244: });
84244: /*
84244:  * Copyright 2009-2011 Mozilla Foundation and contributors
84244:  * Licensed under the New BSD license. See LICENSE.txt or:
84244:  * http://opensource.org/licenses/BSD-3-Clause
84244:  */
84244: 
84244: define('gcli/ui/domtemplate', ['require', 'exports', 'module' ], function(require, exports, module) {
84244: 
84248:   var obj = {};
84248:   Components.utils.import('resource:///modules/devtools/Templater.jsm', obj);
84248:   exports.template = obj.template;
84244: 
84244: });
84244: define("text!gcli/commands/help.css", [], void 0);
84244: define("text!gcli/commands/help_intro.html", [], "\n" +
84253:   "<h2>${l10n.introHeader}</h2>\n" +
84244:   "\n" +
84244:   "<p>\n" +
84244:   "</p>\n" +
84244:   "");
84244: 
84244: define("text!gcli/commands/help_list.html", [], "\n" +
84244:   "<h3>${getHeading()}</h3>\n" +
84244:   "\n" +
84244:   "<table>\n" +
84244:   "  <tr foreach=\"command in ${getMatchingCommands()}\"\n" +
84244:   "      onclick=\"${onclick}\" ondblclick=\"${ondblclick}\">\n" +
84244:   "    <th class=\"gcli-help-name\">${command.name}</th>\n" +
84244:   "    <td class=\"gcli-help-arrow\">&#x2192;</td>\n" +
84244:   "    <td>\n" +
84244:   "      ${command.description}\n" +
84244:   "      <span class=\"gcli-out-shortcut gcli-help-command\">help ${command.name}</span>\n" +
84244:   "    </td>\n" +
84244:   "  </tr>\n" +
84244:   "</table>\n" +
84244:   "");
84244: 
84244: define("text!gcli/commands/help_man.html", [], "\n" +
84244:   "<h3>${command.name}</h3>\n" +
84244:   "\n" +
84244:   "<h4 class=\"gcli-help-header\">\n" +
84253:   "  ${l10n.helpManSynopsis}:\n" +
84244:   "  <span class=\"gcli-help-synopsis\" onclick=\"${onclick}\">\n" +
84244:   "    <span class=\"gcli-help-command\">${command.name}</span>\n" +
84244:   "    <span foreach=\"param in ${command.params}\">\n" +
84244:   "      ${param.defaultValue !== undefined ? '[' + param.name + ']' : param.name}\n" +
84244:   "    </span>\n" +
84244:   "  </span>\n" +
84244:   "</h4>\n" +
84244:   "\n" +
84253:   "<h4 class=\"gcli-help-header\">${l10n.helpManDescription}:</h4>\n" +
84244:   "\n" +
84244:   "<p class=\"gcli-help-description\">\n" +
84244:   "  ${command.manual || command.description}\n" +
84244:   "</p>\n" +
84244:   "\n" +
84253:   "<h4 class=\"gcli-help-header\">${l10n.helpManParameters}:</h4>\n" +
84244:   "\n" +
84244:   "<ul class=\"gcli-help-parameter\">\n" +
84253:   "  <li if=\"${command.params.length === 0}\">${l10n.helpManNone}</li>\n" +
84244:   "  <li foreach=\"param in ${command.params}\">\n" +
84244:   "    <tt>${param.name}</tt> ${getTypeDescription(param)}\n" +
84244:   "    <br/>\n" +
84244:   "    ${param.manual || param.description}\n" +
84244:   "  </li>\n" +
84244:   "</ul>\n" +
84244:   "");
84244: 
84244: /*
84244:  * Copyright 2009-2011 Mozilla Foundation and contributors
84244:  * Licensed under the New BSD license. See LICENSE.txt or:
84244:  * http://opensource.org/licenses/BSD-3-Clause
84244:  */
84244: 
84247: define('gcli/ui/console', ['require', 'exports', 'module' , 'gcli/ui/inputter', 'gcli/ui/arg_fetch', 'gcli/ui/menu', 'gcli/ui/focus'], function(require, exports, module) {
82513: 
82513: var Inputter = require('gcli/ui/inputter').Inputter;
82513: var ArgFetcher = require('gcli/ui/arg_fetch').ArgFetcher;
82513: var CommandMenu = require('gcli/ui/menu').CommandMenu;
82513: var FocusManager = require('gcli/ui/focus').FocusManager;
82513: 
82513: /**
84247:  * Console is responsible for generating the UI for GCLI, this implementation
82513:  * is a special case for use inside Firefox
82513:  */
84247: function Console(options) {
82513:   this.hintElement = options.hintElement;
82513:   this.gcliTerm = options.gcliTerm;
82513:   this.consoleWrap = options.consoleWrap;
82513:   this.requisition = options.requisition;
82513: 
82513:   // Create a FocusManager for the various parts to register with
82513:   this.focusManager = new FocusManager({ document: options.chromeDocument });
82513:   this.focusManager.onFocus.add(this.gcliTerm.show, this.gcliTerm);
82513:   this.focusManager.onBlur.add(this.gcliTerm.hide, this.gcliTerm);
82513:   this.focusManager.addMonitoredElement(this.gcliTerm.hintNode, 'gcliTerm');
82513: 
82513:   this.inputter = new Inputter({
86921:     document: options.chromeDocument,
82513:     requisition: options.requisition,
82513:     inputElement: options.inputElement,
82513:     completeElement: options.completeElement,
82513:     completionPrompt: '',
82513:     backgroundElement: options.backgroundElement,
82513:     focusManager: this.focusManager
82513:   });
82513: 
82513:   this.menu = new CommandMenu({
86921:     document: options.chromeDocument,
82513:     requisition: options.requisition,
82513:     menuClass: 'gcliterm-menu'
82513:   });
82513:   this.hintElement.appendChild(this.menu.element);
82513: 
82513:   this.argFetcher = new ArgFetcher({
86921:     document: options.chromeDocument,
82513:     requisition: options.requisition,
82513:     argFetcherClass: 'gcliterm-argfetcher'
82513:   });
82513:   this.hintElement.appendChild(this.argFetcher.element);
82513: 
82513:   this.chromeWindow = options.chromeDocument.defaultView;
82513:   this.resizer = this.resizer.bind(this);
82513:   this.chromeWindow.addEventListener('resize', this.resizer, false);
82513:   this.requisition.commandChange.add(this.resizer, this);
82513: }
82513: 
82513: /**
82513:  * Avoid memory leaks
82513:  */
84247: Console.prototype.destroy = function() {
82513:   this.chromeWindow.removeEventListener('resize', this.resizer, false);
82513:   delete this.resizer;
82513:   delete this.chromeWindow;
82513:   delete this.consoleWrap;
82513: 
82513:   this.hintElement.removeChild(this.menu.element);
82513:   this.menu.destroy();
82513:   this.hintElement.removeChild(this.argFetcher.element);
82513:   this.argFetcher.destroy();
82513: 
82513:   this.inputter.destroy();
82513: 
82513:   this.focusManager.removeMonitoredElement(this.gcliTerm.hintNode, 'gcliTerm');
82513:   this.focusManager.onFocus.remove(this.gcliTerm.show, this.gcliTerm);
82513:   this.focusManager.onBlur.remove(this.gcliTerm.hide, this.gcliTerm);
82513:   this.focusManager.destroy();
82513: 
82513:   delete this.gcliTerm;
82513:   delete this.hintElement;
82513: };
82513: 
82513: /**
82513:  * Called on chrome window resize, or on divider slide
82513:  */
84247: Console.prototype.resizer = function() {
84245:   // Bug 705109: There are several numbers hard-coded in this function.
84245:   // This is simpler than calculating them, but error-prone when the UI setup,
84245:   // the styling or display settings change.
84245: 
82513:   var parentRect = this.consoleWrap.getBoundingClientRect();
84245:   // Magic number: 64 is the size of the toolbar above the output area
82513:   var parentHeight = parentRect.bottom - parentRect.top - 64;
82513: 
84245:   // Magic number: 100 is the size at which we decide the hints are too small
84245:   // to be useful, so we hide them
82513:   if (parentHeight < 100) {
82513:     this.hintElement.classList.add('gcliterm-hint-nospace');
82513:   }
82513:   else {
82513:     this.hintElement.classList.remove('gcliterm-hint-nospace');
82513: 
82513:     var isMenuVisible = this.menu.element.style.display !== 'none';
82513:     if (isMenuVisible) {
82513:       this.menu.setMaxHeight(parentHeight);
82513: 
84245:       // Magic numbers: 19 = height of a menu item, 22 = total vertical padding
84245:       // of container
82513:       var idealMenuHeight = (19 * this.menu.items.length) + 22;
82513:       if (idealMenuHeight > parentHeight) {
84245:         this.hintElement.classList.add('gcliterm-hint-scroll');
82513:       }
82513:       else {
84245:         this.hintElement.classList.remove('gcliterm-hint-scroll');
82513:       }
82513:     }
82513:     else {
82513:       this.argFetcher.setMaxHeight(parentHeight);
82513: 
82513:       this.hintElement.style.overflowY = null;
82513:       this.hintElement.style.borderBottomColor = 'white';
82513:     }
82513:   }
86921: 
86921:   // We also try to make the max-width of any GCLI elements so they don't
86921:   // extend outside the scroll area.
86921:   var doc = this.hintElement.ownerDocument;
86921: 
86921:   var outputNode = this.hintElement.parentNode.parentNode.children[1];
86921:   var outputs = outputNode.getElementsByClassName('gcliterm-msg-body');
86921:   var listItems = outputNode.getElementsByClassName('hud-msg-node');
86921: 
86921:   // This is an top-side estimate. We could try to calculate it, maybe using
86921:   // something along these lines http://www.alexandre-gomes.com/?p=115 However
86921:   // experience has shown this to be hard to get to work reliably
86921:   // Also we don't need to be precise. If we use a number that is too big then
86921:   // the only down-side is too great a right margin
86921:   var scrollbarWidth = 20;
86921: 
86921:   if (listItems.length > 0) {
86921:     var parentWidth = outputNode.getBoundingClientRect().width - scrollbarWidth;
86921:     var otherWidth;
86921:     var body;
86921: 
86921:     for (var i = 0; i < listItems.length; ++i) {
86921:       var listItem = listItems[i];
86921:       // a.k.a 'var otherWidth = 132'
86921:       otherWidth = 0;
86921:       body = null;
86921: 
86921:       for (var j = 0; j < listItem.children.length; j++) {
86921:         var child = listItem.children[j];
86921: 
86921:         if (child.classList.contains('gcliterm-msg-body')) {
86921:           body = child.children[0];
86921:         }
86921:         else {
86921:           otherWidth += child.getBoundingClientRect().width;
86921:         }
86921: 
86921:         var styles = doc.defaultView.getComputedStyle(child, null);
86921:         otherWidth += parseInt(styles.borderLeftWidth, 10) +
86921:                       parseInt(styles.borderRightWidth, 10) +
86921:                       parseInt(styles.paddingLeft, 10) +
86921:                       parseInt(styles.paddingRight, 10) +
86921:                       parseInt(styles.marginLeft, 10) +
86921:                       parseInt(styles.marginRight, 10);
86921:       }
86921: 
86921:       if (body) {
86921:         body.style.width = (parentWidth - otherWidth) + 'px';
86921:       }
86921:     }
86921:   }
82513: };
82513: 
84247: exports.Console = Console;
82513: 
82513: });
82513: /*
82513:  * Copyright 2009-2011 Mozilla Foundation and contributors
82513:  * Licensed under the New BSD license. See LICENSE.txt or:
82513:  * http://opensource.org/licenses/BSD-3-Clause
82513:  */
82513: 
80321: define('gcli/ui/inputter', ['require', 'exports', 'module' , 'gcli/util', 'gcli/types', 'gcli/history', 'text!gcli/ui/inputter.css'], function(require, exports, module) {
80321: var cliView = exports;
80321: 
80321: 
81345: var KeyEvent = require('gcli/util').event.KeyEvent;
80321: var dom = require('gcli/util').dom;
80321: 
80321: var Status = require('gcli/types').Status;
80321: var History = require('gcli/history').History;
80321: 
80321: var inputterCss = require('text!gcli/ui/inputter.css');
80321: 
80321: 
80321: /**
80321:  * A wrapper to take care of the functions concerning an input element
80321:  */
80321: function Inputter(options) {
80321:   this.requisition = options.requisition;
80321: 
80321:   // Suss out where the input element is
82514:   this.element = options.inputElement || 'gcli-input';
80321:   if (typeof this.element === 'string') {
80321:     this.document = options.document || document;
80321:     var name = this.element;
80321:     this.element = this.document.getElementById(name);
80321:     if (!this.element) {
80321:       throw new Error('No element with id=' + name + '.');
80321:     }
80321:   }
80321:   else {
80321:     // Assume we've been passed in the correct node
80321:     this.document = this.element.ownerDocument;
80321:   }
80321: 
80321:   if (inputterCss != null) {
80321:     this.style = dom.importCss(inputterCss, this.document);
80321:   }
80321: 
80321:   this.element.spellcheck = false;
80321: 
80321:   // Used to distinguish focus from TAB in CLI. See onKeyUp()
80321:   this.lastTabDownAt = 0;
80321: 
80321:   // Used to effect caret changes. See _processCaretChange()
80321:   this._caretChange = null;
80321: 
80321:   // Ensure that TAB/UP/DOWN isn't handled by the browser
80321:   this.onKeyDown = this.onKeyDown.bind(this);
80321:   this.onKeyUp = this.onKeyUp.bind(this);
81345:   this.element.addEventListener('keydown', this.onKeyDown, false);
81345:   this.element.addEventListener('keyup', this.onKeyUp, false);
80321: 
82513:   this.completer = options.completer || new Completer(options);
80321:   this.completer.decorate(this);
80321: 
80321:   // Use the provided history object, or instantiate our own
82513:   this.history = options.history || new History(options);
80321:   this._scrollingThroughHistory = false;
80321: 
80321:   // Cursor position affects hint severity
80321:   this.onMouseUp = function(ev) {
80321:     this.completer.update(this.getInputState());
80321:   }.bind(this);
81345:   this.element.addEventListener('mouseup', this.onMouseUp, false);
80321: 
80321:   this.focusManager = options.focusManager;
80321:   if (this.focusManager) {
80321:     this.focusManager.addMonitoredElement(this.element, 'input');
80321:   }
80321: 
80321:   this.requisition.inputChange.add(this.onInputChange, this);
82513: 
82513:   this.update();
80321: }
80321: 
80321: /**
80321:  * Avoid memory leaks
80321:  */
80321: Inputter.prototype.destroy = function() {
80321:   this.requisition.inputChange.remove(this.onInputChange, this);
80321:   if (this.focusManager) {
80321:     this.focusManager.removeMonitoredElement(this.element, 'input');
80321:   }
80321: 
81345:   this.element.removeEventListener('keydown', this.onKeyDown, false);
81345:   this.element.removeEventListener('keyup', this.onKeyUp, false);
80321:   delete this.onKeyDown;
80321:   delete this.onKeyUp;
80321: 
80321:   this.history.destroy();
80321:   this.completer.destroy();
80321: 
80321:   if (this.style) {
80321:     this.style.parentNode.removeChild(this.style);
80321:     delete this.style;
80321:   }
80321: 
80321:   delete this.document;
80321:   delete this.element;
80321: };
80321: 
80321: /**
80321:  * Utility to add an element into the DOM after the input element
80321:  */
80321: Inputter.prototype.appendAfter = function(element) {
80321:   this.element.parentNode.insertBefore(element, this.element.nextSibling);
80321: };
80321: 
80321: /**
80321:  * Handler for the Requisition.inputChange event
80321:  */
80321: Inputter.prototype.onInputChange = function() {
80321:   if (this._caretChange == null) {
80321:     // We weren't expecting a change so this was requested by the hint system
80321:     // we should move the cursor to the end of the 'changed section', and the
80321:     // best we can do for that right now is the end of the current argument.
80321:     this._caretChange = Caret.TO_ARG_END;
80321:   }
80321:   this._setInputInternal(this.requisition.toString());
80321: };
80321: 
80321: /**
80321:  * Internal function to set the input field to a value.
80321:  * This function checks to see if the current value is the same as the new
80321:  * value, and makes no changes if they are the same (except for caret/completer
80321:  * updating - see below). If changes are to be made, they are done in a timeout
80321:  * to avoid XUL bug 676520.
80321:  * This function assumes that the data model is up to date with the new value.
80321:  * It does attempts to leave the caret position in the same position in the
80321:  * input string unless this._caretChange === Caret.TO_ARG_END. This is required
80321:  * for completion events.
80321:  * It does not change the completer decoration unless this._updatePending is
80321:  * set. This is required for completion events.
80321:  */
80321: Inputter.prototype._setInputInternal = function(str, update) {
80321:   if (!this.document) {
80321:     return; // This can happen post-destroy()
80321:   }
80321: 
80321:   if (this.element.value && this.element.value === str) {
80321:     this._processCaretChange(this.getInputState(), false);
80321:     return;
80321:   }
80321: 
80321:   // Updating in a timeout fixes a XUL issue (bug 676520) where textbox gives
80321:   // incorrect values for its content
80321:   this.document.defaultView.setTimeout(function() {
80321:     if (!this.document) {
80321:       return; // This can happen post-destroy()
80321:     }
80321: 
80321:     // Bug 678520 - We could do better caret handling by recording the caret
80321:     // position in terms of offset into an assignment, and then replacing into
80321:     // a similar place
80321:     var input = this.getInputState();
80321:     input.typed = str;
80321:     this._processCaretChange(input);
80321:     this.element.value = str;
80321: 
80321:     if (update) {
80321:       this.update();
80321:     }
80321:   }.bind(this), 0);
80321: };
80321: 
80321: /**
80321:  * Various ways in which we need to manipulate the caret/selection position.
80321:  * A value of null means we're not expecting a change
80321:  */
80321: var Caret = {
80321:   /**
80321:    * We are expecting changes, but we don't need to move the cursor
80321:    */
80321:   NO_CHANGE: 0,
80321: 
80321:   /**
80321:    * We want the entire input area to be selected
80321:    */
80321:   SELECT_ALL: 1,
80321: 
80321:   /**
80321:    * The whole input has changed - push the cursor to the end
80321:    */
80321:   TO_END: 2,
80321: 
80321:   /**
80321:    * A part of the input has changed - push the cursor to the end of the
80321:    * changed section
80321:    */
80321:   TO_ARG_END: 3
80321: };
80321: 
80321: /**
80321:  * If this._caretChange === Caret.TO_ARG_END, we alter the input object to move
80321:  * the selection start to the end of the current argument.
80321:  * @param input An object shaped like { typed:'', cursor: { start:0, end:0 }}
80321:  * @param forceUpdate Do we call this.completer.update even when the cursor has
80321:  * not changed (useful when input.typed has changed)
80321:  */
80321: Inputter.prototype._processCaretChange = function(input, forceUpdate) {
80321:   var start, end;
80321:   switch (this._caretChange) {
80321:     case Caret.SELECT_ALL:
80321:       start = 0;
80321:       end = input.typed.length;
80321:       break;
80321: 
80321:     case Caret.TO_END:
80321:       start = input.typed.length;
80321:       end = input.typed.length;
80321:       break;
80321: 
80321:     case Caret.TO_ARG_END:
80321:       // There could be a fancy way to do this involving assignment/arg math
80321:       // but it doesn't seem easy, so we cheat a move the cursor to just before
80321:       // the next space, or the end of the input
80321:       start = input.cursor.start;
80321:       do {
80321:         start++;
80321:       }
80321:       while (start < input.typed.length && input.typed[start - 1] !== ' ');
80321: 
80321:       end = start;
80321:       break;
80321: 
80321:     case null:
80321:     case Caret.NO_CHANGE:
80321:       start = input.cursor.start;
80321:       end = input.cursor.end;
80321:       break;
80321:   }
80321: 
80321:   start = (start > input.typed.length) ? input.typed.length : start;
80321:   end = (end > input.typed.length) ? input.typed.length : end;
80321: 
80321:   var newInput = { typed: input.typed, cursor: { start: start, end: end }};
80321:   if (start !== input.cursor.start || end !== input.cursor.end || forceUpdate) {
80321:     this.completer.update(newInput);
80321:   }
80321: 
81345:   this.element.selectionStart = newInput.cursor.start;
81345:   this.element.selectionEnd = newInput.cursor.end;
80321: 
80321:   this._caretChange = null;
80321:   return newInput;
80321: };
80321: 
80321: /**
80321:  * Set the input field to a value.
80321:  * This function updates the data model and the completer decoration. It sets
80321:  * the caret to the end of the input. It does not make any similarity checks
80321:  * so calling this function with it's current value resets the cursor position.
80321:  * It does not execute the input or affect the history.
80321:  * This function should not be called internally, by Inputter and never as a
80321:  * result of a keyboard event on this.element or bug 676520 could be triggered.
80321:  */
80321: Inputter.prototype.setInput = function(str) {
80321:   this.element.value = str;
80321:   this.update();
80321: };
80321: 
80321: /**
80321:  * Focus the input element
80321:  */
80321: Inputter.prototype.focus = function() {
80321:   this.element.focus();
80321: };
80321: 
80321: /**
80321:  * Ensure certain keys (arrows, tab, etc) that we would like to handle
80321:  * are not handled by the browser
80321:  */
80321: Inputter.prototype.onKeyDown = function(ev) {
80321:   if (ev.keyCode === KeyEvent.DOM_VK_UP || ev.keyCode === KeyEvent.DOM_VK_DOWN) {
81345:     ev.preventDefault();
80321:   }
80321:   if (ev.keyCode === KeyEvent.DOM_VK_TAB) {
80321:     this.lastTabDownAt = 0;
80321:     if (!ev.shiftKey) {
81345:       ev.preventDefault();
80321:       // Record the timestamp of this TAB down so onKeyUp can distinguish
80321:       // focus from TAB in the CLI.
80321:       this.lastTabDownAt = ev.timeStamp;
80321:     }
80321:     if (ev.metaKey || ev.altKey || ev.crtlKey) {
80321:       if (this.document.commandDispatcher) {
80321:         this.document.commandDispatcher.advanceFocus();
80321:       }
80321:       else {
80321:         this.element.blur();
80321:       }
80321:     }
80321:   }
80321: };
80321: 
80321: /**
80321:  * The main keyboard processing loop
80321:  */
80321: Inputter.prototype.onKeyUp = function(ev) {
80321:   // RETURN does a special exec/highlight thing
80321:   if (ev.keyCode === KeyEvent.DOM_VK_RETURN) {
80321:     var worst = this.requisition.getStatus();
80321:     // Deny RETURN unless the command might work
80321:     if (worst === Status.VALID) {
80321:       this._scrollingThroughHistory = false;
80321:       this.history.add(this.element.value);
80321:       this.requisition.exec();
80321:     }
80321:     // See bug 664135 - On pressing return with an invalid input, GCLI
80321:     // should select the incorrect part of the input for an easy fix
80321:     return;
80321:   }
80321: 
80321:   if (ev.keyCode === KeyEvent.DOM_VK_TAB && !ev.shiftKey) {
80321:     // If the TAB keypress took the cursor from another field to this one,
80321:     // then they get the keydown/keypress, and we get the keyup. In this
80321:     // case we don't want to do any completion.
80321:     // If the time of the keydown/keypress of TAB was close (i.e. within
80321:     // 1 second) to the time of the keyup then we assume that we got them
80321:     // both, and do the completion.
80321:     if (this.lastTabDownAt + 1000 > ev.timeStamp) {
80321:       // It's possible for TAB to not change the input, in which case the
80321:       // onInputChange event will not fire, and the caret move will not be
82513:       // processed. So we check that this is done first
80321:       this._caretChange = Caret.TO_ARG_END;
80321:       this._processCaretChange(this.getInputState(), true);
82513:       this.getCurrentAssignment().complete();
80321:     }
80321:     this.lastTabDownAt = 0;
80321:     this._scrollingThroughHistory = false;
80321:     return;
80321:   }
80321: 
80321:   if (ev.keyCode === KeyEvent.DOM_VK_UP) {
80321:     if (this.element.value === '' || this._scrollingThroughHistory) {
80321:       this._scrollingThroughHistory = true;
80321:       this._setInputInternal(this.history.backward(), true);
80321:     }
80321:     else {
80321:       this.getCurrentAssignment().increment();
80321:     }
80321:     return;
80321:   }
80321: 
80321:   if (ev.keyCode === KeyEvent.DOM_VK_DOWN) {
80321:     if (this.element.value === '' || this._scrollingThroughHistory) {
80321:       this._scrollingThroughHistory = true;
80321:       this._setInputInternal(this.history.forward(), true);
80321:     }
80321:     else {
80321:       this.getCurrentAssignment().decrement();
80321:     }
80321:     return;
80321:   }
80321: 
80321:   this._scrollingThroughHistory = false;
80321:   this._caretChange = Caret.NO_CHANGE;
80321:   this.update();
80321: };
80321: 
80321: /**
80321:  * Accessor for the assignment at the cursor.
80321:  * i.e Requisition.getAssignmentAt(cursorPos);
80321:  */
80321: Inputter.prototype.getCurrentAssignment = function() {
81345:   var start = this.element.selectionStart;
80321:   return this.requisition.getAssignmentAt(start);
80321: };
80321: 
80321: /**
80321:  * Actually parse the input and make sure we're all up to date
80321:  */
80321: Inputter.prototype.update = function() {
80321:   var input = this.getInputState();
80321:   this.requisition.update(input);
80321:   this.completer.update(input);
80321: };
80321: 
80321: /**
80321:  * Pull together an input object, which may include XUL hacks
80321:  */
80321: Inputter.prototype.getInputState = function() {
80321:   var input = {
80321:     typed: this.element.value,
80321:     cursor: {
81345:       start: this.element.selectionStart,
81345:       end: this.element.selectionEnd
80321:     }
80321:   };
80321: 
80321:   // Workaround for potential XUL bug 676520 where textbox gives incorrect
80321:   // values for its content
80321:   if (input.typed == null) {
81345:     input = { typed: '', cursor: { start: 0, end: 0 } };
80321:     console.log('fixing input.typed=""', input);
80321:   }
80321: 
80321:   return input;
80321: };
80321: 
80321: cliView.Inputter = Inputter;
80321: 
80321: 
80321: /**
80321:  * Completer is an 'input-like' element that sits  an input element annotating
80321:  * it with visual goodness.
80321:  * @param {object} options An object that contains various options which
80321:  * customizes how the completer functions.
80321:  * Properties on the options object:
80321:  * - document (required) DOM document to be used in creating elements
80321:  * - requisition (required) A GCLI Requisition object whose state is monitored
80321:  * - completeElement (optional) An element to use
84252:  * - completionPrompt (optional) The prompt - defaults to '\u00bb'
84252:  *   (double greater-than, a.k.a right guillemet). The prompt is used directly
84252:  *   in a TextNode, so HTML entities are not allowed.
80321:  */
80321: function Completer(options) {
82513:   this.document = options.document || document;
80321:   this.requisition = options.requisition;
80321:   this.elementCreated = false;
80321: 
82514:   this.element = options.completeElement || 'gcli-row-complete';
80321:   if (typeof this.element === 'string') {
80321:     var name = this.element;
80321:     this.element = this.document.getElementById(name);
80321: 
80321:     if (!this.element) {
80321:       this.elementCreated = true;
80321:       this.element = dom.createElement(this.document, 'div');
82517:       this.element.className = 'gcli-in-complete gcli-in-valid';
80321:       this.element.setAttribute('tabindex', '-1');
80321:       this.element.setAttribute('aria-live', 'polite');
80321:     }
80321:   }
80321: 
80321:   this.completionPrompt = typeof options.completionPrompt === 'string'
80321:       ? options.completionPrompt
84252:       : '\u00bb';
80321: 
80321:   if (options.inputBackgroundElement) {
80321:     this.backgroundElement = options.inputBackgroundElement;
80321:   }
80321:   else {
80321:     this.backgroundElement = this.element;
80321:   }
80321: }
80321: 
80321: /**
80321:  * Avoid memory leaks
80321:  */
80321: Completer.prototype.destroy = function() {
80321:   delete this.document;
80321:   delete this.element;
80321:   delete this.backgroundElement;
80321: 
80321:   if (this.elementCreated) {
81345:     this.document.defaultView.removeEventListener('resize', this.resizer, false);
80321:   }
80321: 
80321:   delete this.inputter;
80321: };
80321: 
80321: /**
80321:  * A list of the styles that decorate() should copy to make the completion
80321:  * element look like the input element. backgroundColor is a spiritual part of
80321:  * this list, but see comment in decorate().
80321:  */
80321: Completer.copyStyles = [ 'fontSize', 'fontFamily', 'fontWeight', 'fontStyle' ];
80321: 
80321: /**
80321:  * Make ourselves visually similar to the input element, and make the input
80321:  * element transparent so our background shines through
80321:  */
80321: Completer.prototype.decorate = function(inputter) {
80321:   this.inputter = inputter;
80321:   var input = inputter.element;
80321: 
80321:   // If we were told which element to use, then assume it is already
80321:   // correctly positioned. Otherwise insert it alongside the input element
80321:   if (this.elementCreated) {
80321:     this.inputter.appendAfter(this.element);
80321: 
81345:     var styles = this.document.defaultView.getComputedStyle(input, null);
80321:     Completer.copyStyles.forEach(function(style) {
81345:       this.element.style[style] = styles[style];
80321:     }, this);
80321: 
80321:     // The completer text is by default invisible so we make it the same color
80321:     // as the input background.
80321:     this.element.style.color = input.style.backgroundColor;
80321: 
80321:     // If there is a separate backgroundElement, then we make the element
80321:     // transparent, otherwise it inherits the color of the input node
80321:     // It's not clear why backgroundColor doesn't work when used from
80321:     // computedStyle, but it doesn't. Patches welcome!
80321:     this.element.style.backgroundColor = (this.backgroundElement != this.element) ?
80321:         'transparent' :
80321:         input.style.backgroundColor;
80321:     input.style.backgroundColor = 'transparent';
80321: 
80321:     // Make room for the prompt
80321:     input.style.paddingLeft = '20px';
80321: 
80321:     this.resizer = this.resizer.bind(this);
81345:     this.document.defaultView.addEventListener('resize', this.resizer, false);
80321:     this.resizer();
80321:   }
80321: };
80321: 
80321: /**
80321:  * Ensure that the completion element is the same size and the inputter element
80321:  */
80321: Completer.prototype.resizer = function() {
80321:   var rect = this.inputter.element.getBoundingClientRect();
80321:   // -4 to line up with 1px of padding and border, top and bottom
80321:   var height = rect.bottom - rect.top - 4;
80321: 
80321:   this.element.style.top = rect.top + 'px';
80321:   this.element.style.height = height + 'px';
80321:   this.element.style.lineHeight = height + 'px';
80321:   this.element.style.left = rect.left + 'px';
80321:   this.element.style.width = (rect.right - rect.left) + 'px';
80321: };
80321: 
80321: /**
80321:  * Is the completion given, a "strict" completion of the user inputted value?
80321:  * A completion is considered "strict" only if it the user inputted value is an
80321:  * exact prefix of the completion (ignoring leading whitespace)
80321:  */
80321: function isStrictCompletion(inputValue, completion) {
80321:   // Strip any leading whitespace from the user inputted value because the
80321:   // completion will never have leading whitespace.
80321:   inputValue = inputValue.replace(/^\s*/, '');
80321:   // Strict: "ec" -> "echo"
80321:   // Non-Strict: "ls *" -> "ls foo bar baz"
80321:   return completion.indexOf(inputValue) === 0;
80321: }
80321: 
80321: /**
80321:  * Bring the completion element up to date with what the requisition says
80321:  */
80321: Completer.prototype.update = function(input) {
80321:   var current = this.requisition.getAssignmentAt(input.cursor.start);
80321:   var predictions = current.getPredictions();
80321: 
84252:   dom.clearElement(this.element);
84252: 
84252:   // All this DOM manipulation is equivalent to the HTML below.
84252:   // It's not a template because it's very simple except appendMarkupStatus()
84252:   // which is complex due to a need to merge spans.
84252:   // Bug 707131 questions if we couldn't simplify this to use a template.
84252:   //
84252:   // <span class="gcli-prompt">${completionPrompt}</span>
84252:   // ${appendMarkupStatus()}
84252:   // ${prefix}
84252:   // <span class="gcli-in-ontab">${contents}</span>
84252:   // <span class="gcli-in-closebrace" if="${unclosedJs}">}<span>
84252: 
84252:   var document = this.element.ownerDocument;
86921:   var prompt = dom.createElement(document, 'span');
84252:   prompt.classList.add('gcli-prompt');
84252:   prompt.appendChild(document.createTextNode(this.completionPrompt + ' '));
84252:   this.element.appendChild(prompt);
84252: 
80321:   if (input.typed.length > 0) {
82513:     var scores = this.requisition.getInputStatusMarkup(input.cursor.start);
84252:     this.appendMarkupStatus(this.element, scores, input);
80321:   }
80321: 
80321:   if (input.typed.length > 0 && predictions.length > 0) {
80321:     var tab = predictions[0].name;
80321:     var existing = current.getArg().text;
84252: 
84252:     var contents;
84252:     var prefix = null;
84252: 
84252:     if (isStrictCompletion(existing, tab) &&
84252:             input.cursor.start === input.typed.length) {
84252:       // Display the suffix of the prediction as the completion
80321:       var numLeadingSpaces = existing.match(/^(\s*)/)[0].length;
84252:       contents = tab.slice(existing.length - numLeadingSpaces);
80321:     } else {
80321:       // Display the '-> prediction' at the end of the completer element
84252:       prefix = ' \u00a0';         // aka &nbsp;
84252:       contents = '\u21E5 ' + tab; // aka &rarr; the right arrow
84252:     }
84252: 
84252:     if (prefix != null) {
84252:       this.element.appendChild(document.createTextNode(prefix));
84252:     }
84252: 
86921:     var suffix = dom.createElement(document, 'span');
84252:     suffix.classList.add('gcli-in-ontab');
84252:     suffix.appendChild(document.createTextNode(contents));
84252:     this.element.appendChild(suffix);
84252:   }
84252: 
84252:   // Add a grey '}' to the end of the command line when we've opened
80321:   // with a { but haven't closed it
80321:   var command = this.requisition.commandAssignment.getValue();
84252:   var unclosedJs = command && command.name === '{' &&
84252:           this.requisition.getAssignment(0).getArg().suffix.indexOf('}') === -1;
84252:   if (unclosedJs) {
86921:     var close = dom.createElement(document, 'span');
84252:     close.classList.add('gcli-in-closebrace');
84252:     close.appendChild(document.createTextNode(' }'));
84252:     this.element.appendChild(close);
84252:   }
80321: };
80321: 
80321: /**
80321:  * Mark-up an array of Status values with spans
80321:  */
84252: Completer.prototype.appendMarkupStatus = function(element, scores, input) {
80321:   if (scores.length === 0) {
84252:     return;
84252:   }
84252: 
84252:   var document = element.ownerDocument;
80321:   var i = 0;
80321:   var lastStatus = -1;
84252:   var span;
84252:   var contents = '';
84252: 
80321:   while (true) {
80321:     if (lastStatus !== scores[i]) {
80321:       var state = scores[i];
80321:       if (!state) {
80321:         console.error('No state at i=' + i + '. scores.len=' + scores.length);
80321:         state = Status.VALID;
80321:       }
86921:       span = dom.createElement(document, 'span');
84252:       span.classList.add('gcli-in-' + state.toString().toLowerCase());
80321:       lastStatus = scores[i];
80321:     }
80321:     var char = input.typed[i];
80321:     if (char === ' ') {
84252:       char = '\u00a0';
84252:     }
84252:     contents += char;
80321:     i++;
80321:     if (i === input.typed.length) {
84252:       span.appendChild(document.createTextNode(contents));
84252:       this.element.appendChild(span);
80321:       break;
80321:     }
80321:     if (lastStatus !== scores[i]) {
84252:       span.appendChild(document.createTextNode(contents));
84252:       this.element.appendChild(span);
84252:       contents = '';
84252:     }
84252:   }
80321: };
80321: 
80321: cliView.Completer = Completer;
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/history', ['require', 'exports', 'module' ], function(require, exports, module) {
80321: 
80321: /**
80321:  * A History object remembers commands that have been entered in the past and
80321:  * provides an API for accessing them again.
80321:  * See Bug 681340: Search through history (like C-r in bash)?
80321:  */
80321: function History() {
80321:   // This is the actual buffer where previous commands are kept.
80321:   // 'this._buffer[0]' should always be equal the empty string. This is so
80321:   // that when you try to go in to the "future", you will just get an empty
80321:   // command.
80321:   this._buffer = [''];
80321: 
80321:   // This is an index in to the history buffer which points to where we
80321:   // currently are in the history.
80321:   this._current = 0;
80321: }
80321: 
80321: /**
80321:  * Avoid memory leaks
80321:  */
80321: History.prototype.destroy = function() {
80321: //  delete this._buffer;
80321: };
80321: 
80321: /**
80321:  * Record and save a new command in the history.
80321:  */
80321: History.prototype.add = function(command) {
80321:   this._buffer.splice(1, 0, command);
80321:   this._current = 0;
80321: };
80321: 
80321: /**
80321:  * Get the next (newer) command from history.
80321:  */
80321: History.prototype.forward = function() {
80321:   if (this._current > 0 ) {
80321:     this._current--;
80321:   }
80321:   return this._buffer[this._current];
80321: };
80321: 
80321: /**
80321:  * Get the previous (older) item from history.
80321:  */
80321: History.prototype.backward = function() {
80321:   if (this._current < this._buffer.length - 1) {
80321:     this._current++;
80321:   }
80321:   return this._buffer[this._current];
80321: };
80321: 
80321: exports.History = History;
80321: 
80321: });define("text!gcli/ui/inputter.css", [], void 0);
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/ui/arg_fetch', ['require', 'exports', 'module' , 'gcli/util', 'gcli/types', 'gcli/ui/field', 'gcli/ui/domtemplate', 'text!gcli/ui/arg_fetch.css', 'text!gcli/ui/arg_fetch.html'], function(require, exports, module) {
80321: var argFetch = exports;
80321: 
80321: 
80321: var dom = require('gcli/util').dom;
80321: var Status = require('gcli/types').Status;
80321: 
80321: var getField = require('gcli/ui/field').getField;
84248: var domtemplate = require('gcli/ui/domtemplate');
80321: 
80321: var editorCss = require('text!gcli/ui/arg_fetch.css');
80321: var argFetchHtml = require('text!gcli/ui/arg_fetch.html');
80321: 
80321: 
80321: /**
80321:  * A widget to display an inline dialog which allows the user to fill out
80321:  * the arguments to a command.
82513:  * @param options An object containing the customizations, which include:
82513:  * - document: The document to use in creating widgets
82513:  * - requisition: The Requisition to fill out
82513:  * - argFetcherClass: Custom class name when generating the top level element
82513:  *   which allows different layout systems
82513:  */
82513: function ArgFetcher(options) {
82513:   this.document = options.document || document;
82513:   this.requisition = options.requisition;
80321: 
80321:   // FF can be really hard to debug if doc is null, so we check early on
80321:   if (!this.document) {
80321:     throw new Error('No document');
80321:   }
80321: 
80321:   this.element =  dom.createElement(this.document, 'div');
82514:   this.element.className = options.argFetcherClass || 'gcli-argfetch';
80321:   // We cache the fields we create so we can destroy them later
80321:   this.fields = [];
80321: 
80321:   // Populated by template
80321:   this.okElement = null;
80321: 
80321:   // Pull the HTML into the DOM, but don't add it to the document
80321:   if (editorCss != null) {
80321:     this.style = dom.importCss(editorCss, this.document);
80321:   }
80321: 
80321:   var templates = dom.createElement(this.document, 'div');
80321:   dom.setInnerHtml(templates, argFetchHtml);
82514:   this.reqTempl = templates.querySelector('.gcli-af-template');
80321: 
80321:   this.requisition.commandChange.add(this.onCommandChange, this);
80321:   this.requisition.inputChange.add(this.onInputChange, this);
82513: 
82513:   this.onCommandChange();
80321: }
80321: 
80321: /**
80321:  * Avoid memory leaks
80321:  */
80321: ArgFetcher.prototype.destroy = function() {
80321:   this.requisition.inputChange.remove(this.onInputChange, this);
80321:   this.requisition.commandChange.remove(this.onCommandChange, this);
80321: 
80321:   if (this.style) {
80321:     this.style.parentNode.removeChild(this.style);
80321:     delete this.style;
80321:   }
80321: 
80321:   this.fields.forEach(function(field) { field.destroy(); });
80321: 
80321:   delete this.document;
80321:   delete this.element;
80321:   delete this.okElement;
80321:   delete this.reqTempl;
80321: };
80321: 
80321: /**
80321:  * Called whenever the command part of the requisition changes
80321:  */
80321: ArgFetcher.prototype.onCommandChange = function(ev) {
80321:   var command = this.requisition.commandAssignment.getValue();
80321:   if (!command || !command.exec) {
80321:     this.element.style.display = 'none';
80321:   }
80321:   else {
80321:     if (ev && ev.oldValue === ev.newValue) {
80321:       // Just the text has changed
80321:       return;
80321:     }
80321: 
80321:     this.fields.forEach(function(field) { field.destroy(); });
80321:     this.fields = [];
80321: 
80321:     var reqEle = this.reqTempl.cloneNode(true);
84248:     domtemplate.template(reqEle, this,
84248:             { allowEval: true, stack: 'arg_fetch.html' });
80321:     dom.clearElement(this.element);
80321:     this.element.appendChild(reqEle);
80321: 
80321:     var status = this.requisition.getStatus();
80321:     this.okElement.disabled = (status === Status.VALID);
80321: 
80321:     this.element.style.display = 'block';
80321:   }
80321: };
80321: 
80321: /**
80321:  * Called whenever the text input of the requisition changes
80321:  */
80321: ArgFetcher.prototype.onInputChange = function(ev) {
80321:   var command = this.requisition.commandAssignment.getValue();
80321:   if (command && command.exec) {
80321:     var status = this.requisition.getStatus();
80321:     this.okElement.disabled = (status !== Status.VALID);
80321:   }
80321: };
80321: 
80321: /**
80321:  * Called by the template process in #onCommandChange() to get an instance
80321:  * of field for each assignment.
80321:  */
80321: ArgFetcher.prototype.getInputFor = function(assignment) {
82513:   try {
80321:     var newField = getField(assignment.param.type, {
80321:       document: this.document,
80321:       type: assignment.param.type,
80321:       name: assignment.param.name,
80321:       requisition: this.requisition,
80321:       required: assignment.param.isDataRequired(),
80321:       named: !assignment.param.isPositionalAllowed()
80321:     });
80321: 
80321:     // BUG 664198 - remove on delete
80321:     newField.fieldChanged.add(function(ev) {
80321:       assignment.setConversion(ev.conversion);
80321:     }, this);
80321:     assignment.assignmentChange.add(function(ev) {
80321:       newField.setConversion(ev.conversion);
80321:     }.bind(this));
80321: 
80321:     this.fields.push(newField);
80321:     newField.setConversion(this.assignment.conversion);
80321: 
80321:     // Bug 681894: we add the field as a property of the assignment so that
80321:     // #linkMessageElement() can call 'field.setMessageElement(element)'
80321:     assignment.field = newField;
80321: 
80321:     return newField.element;
82513:   }
82513:   catch (ex) {
84248:     // This is called from within template() which can make tracing errors hard
82513:     // so we log here if anything goes wrong
82513:     console.error(ex);
82513:     return '';
82513:   }
80321: };
80321: 
80321: /**
80321:  * Called by the template to setup an mutable message field
80321:  */
80321: ArgFetcher.prototype.linkMessageElement = function(assignment, element) {
80321:   // Bug 681894: See comment in getInputFor()
80321:   var field = assignment.field;
80321:   delete assignment.field;
80321:   if (field == null) {
80321:     console.error('Missing field for ' + assignment.param.name);
80321:     return 'Missing field';
80321:   }
80321:   field.setMessageElement(element);
80321:   return '';
80321: };
80321: 
80321: /**
80321:  * Event handler added by the template menu.html
80321:  */
80321: ArgFetcher.prototype.onFormOk = function(ev) {
80321:   this.requisition.exec();
80321: };
80321: 
80321: /**
80321:  * Event handler added by the template menu.html
80321:  */
80321: ArgFetcher.prototype.onFormCancel = function(ev) {
80321:   this.requisition.clear();
80321: };
80321: 
82513: /**
82513:  * Change how much vertical space this dialog can take up
82513:  */
82513: ArgFetcher.prototype.setMaxHeight = function(height, isTooBig) {
82513:   this.fields.forEach(function(field) {
82513:     if (field.menu) {
82513:       // Magic number alert: 105 is roughly the size taken up by the rest of
82513:       // the dialog for the '{' command. We could spend ages calculating 105
82513:       // by doing math on the various components that contribute to the 105,
82513:       // but I don't think that would make it significantly less fragile under
82513:       // refactoring. Plus this works.
82513:       field.menu.setMaxHeight(height - 105);
82513:     }
82513:   });
82513: };
82513: 
80321: argFetch.ArgFetcher = ArgFetcher;
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/ui/field', ['require', 'exports', 'module' , 'gcli/util', 'gcli/l10n', 'gcli/argument', 'gcli/types', 'gcli/types/basic', 'gcli/types/javascript', 'gcli/ui/menu'], function(require, exports, module) {
80321: 
80321: 
80321: var dom = require('gcli/util').dom;
80321: var createEvent = require('gcli/util').createEvent;
80321: var l10n = require('gcli/l10n');
80321: 
80321: var Argument = require('gcli/argument').Argument;
80321: var TrueNamedArgument = require('gcli/argument').TrueNamedArgument;
80321: var FalseNamedArgument = require('gcli/argument').FalseNamedArgument;
80321: var ArrayArgument = require('gcli/argument').ArrayArgument;
80321: 
80321: var Status = require('gcli/types').Status;
80321: var Conversion = require('gcli/types').Conversion;
80321: var ArrayConversion = require('gcli/types').ArrayConversion;
80321: 
80321: var StringType = require('gcli/types/basic').StringType;
80321: var NumberType = require('gcli/types/basic').NumberType;
80321: var BooleanType = require('gcli/types/basic').BooleanType;
80321: var BlankType = require('gcli/types/basic').BlankType;
80321: var SelectionType = require('gcli/types/basic').SelectionType;
80321: var DeferredType = require('gcli/types/basic').DeferredType;
80321: var ArrayType = require('gcli/types/basic').ArrayType;
80321: var JavascriptType = require('gcli/types/javascript').JavascriptType;
80321: 
80321: var Menu = require('gcli/ui/menu').Menu;
80321: 
80321: 
80321: /**
80321:  * A Field is a way to get input for a single parameter.
80321:  * This class is designed to be inherited from. It's important that all
80321:  * subclasses have a similar constructor signature because they are created
80321:  * via getField(...)
80321:  * @param document The document we use in calling createElement
80321:  * @param type The type to use in conversions
80321:  * @param named Is this parameter named? That is to say, are positional
80321:  * arguments disallowed, if true, then we need to provide updates to the
80321:  * command line that explicitly name the parameter in use (e.g. --verbose, or
80321:  * --name Fred rather than just true or Fred)
80321:  * @param name If this parameter is named, what name should we use
80321:  * @param requ The requisition that we're attached to
80321:  */
80321: function Field(document, type, named, name, requ) {
80321: }
80321: 
80321: /**
80321:  * Subclasses should assign their element with the DOM node that gets added
80321:  * to the 'form'. It doesn't have to be an input node, just something that
80321:  * contains it.
80321:  */
80321: Field.prototype.element = undefined;
80321: 
80321: /**
80321:  * Indicates that this field should drop any resources that it has created
80321:  */
80321: Field.prototype.destroy = function() {
80321:   delete this.messageElement;
80321: };
80321: 
80321: /**
80321:  * Update this field display with the value from this conversion.
80321:  * Subclasses should provide an implementation of this function.
80321:  */
80321: Field.prototype.setConversion = function(conversion) {
80321:   throw new Error('Field should not be used directly');
80321: };
80321: 
80321: /**
80321:  * Extract a conversion from the values in this field.
80321:  * Subclasses should provide an implementation of this function.
80321:  */
80321: Field.prototype.getConversion = function() {
80321:   throw new Error('Field should not be used directly');
80321: };
80321: 
80321: /**
80321:  * Set the element where messages and validation errors will be displayed
80321:  * @see setMessage()
80321:  */
80321: Field.prototype.setMessageElement = function(element) {
80321:   this.messageElement = element;
80321: };
80321: 
80321: /**
80321:  * Display a validation message in the UI
80321:  */
80321: Field.prototype.setMessage = function(message) {
80321:   if (this.messageElement) {
80321:     if (message == null) {
80321:       message = '';
80321:     }
80321:     dom.setInnerHtml(this.messageElement, message);
80321:   }
80321: };
80321: 
80321: /**
80321:  * Method to be called by subclasses when their input changes, which allows us
80321:  * to properly pass on the fieldChanged event.
80321:  */
80321: Field.prototype.onInputChange = function() {
80321:   var conversion = this.getConversion();
80321:   this.fieldChanged({ conversion: conversion });
80321:   this.setMessage(conversion.message);
80321: };
80321: 
80321: /**
80321:  * 'static/abstract' method to allow implementations of Field to lay a claim
80321:  * to a type. This allows claims of various strength to be weighted up.
80321:  * See the Field.*MATCH values.
80321:  */
80321: Field.claim = function() {
80321:   throw new Error('Field should not be used directly');
80321: };
80321: Field.MATCH = 5;
80321: Field.DEFAULT_MATCH = 4;
80321: Field.IF_NOTHING_BETTER = 1;
80321: Field.NO_MATCH = 0;
80321: 
80321: 
80321: /**
80321:  * Managing the current list of Fields
80321:  */
80321: var fieldCtors = [];
80321: function addField(fieldCtor) {
80321:   if (typeof fieldCtor !== 'function') {
80321:     console.error('addField erroring on ', fieldCtor);
80321:     throw new Error('addField requires a Field constructor');
80321:   }
80321:   fieldCtors.push(fieldCtor);
80321: }
80321: 
80321: function removeField(field) {
80321:   if (typeof field !== 'string') {
80321:     fields = fields.filter(function(test) {
80321:       return test !== field;
80321:     });
80321:     delete fields[field];
80321:   }
80321:   else if (field instanceof Field) {
80321:     removeField(field.name);
80321:   }
80321:   else {
80321:     console.error('removeField erroring on ', field);
80321:     throw new Error('removeField requires an instance of Field');
80321:   }
80321: }
80321: 
80321: function getField(type, options) {
80321:   var ctor;
80321:   var highestClaim = -1;
80321:   fieldCtors.forEach(function(fieldCtor) {
80321:     var claim = fieldCtor.claim(type);
80321:     if (claim > highestClaim) {
80321:       highestClaim = claim;
80321:       ctor = fieldCtor;
80321:     }
80321:   });
80321: 
80321:   if (!ctor) {
80321:     console.error('Unknown field type ', type, ' in ', fieldCtors);
80321:     throw new Error('Can\'t find field for ' + type);
80321:   }
80321: 
80321:   return new ctor(type, options);
80321: }
80321: 
80321: exports.Field = Field;
80321: exports.addField = addField;
80321: exports.removeField = removeField;
80321: exports.getField = getField;
80321: 
80321: 
80321: /**
80321:  * A field that allows editing of strings
80321:  */
80321: function StringField(type, options) {
80321:   this.document = options.document;
80321:   this.type = type;
80321:   this.arg = new Argument();
80321: 
82516:   this.element = dom.createElement(this.document, 'input');
80321:   this.element.type = 'text';
84245:   this.element.classList.add('gcli-field');
80321: 
80321:   this.onInputChange = this.onInputChange.bind(this);
80321:   this.element.addEventListener('keyup', this.onInputChange, false);
80321: 
80321:   this.fieldChanged = createEvent('StringField.fieldChanged');
80321: }
80321: 
80321: StringField.prototype = Object.create(Field.prototype);
80321: 
80321: StringField.prototype.destroy = function() {
80321:   Field.prototype.destroy.call(this);
80321:   this.element.removeEventListener('keyup', this.onInputChange, false);
80321:   delete this.element;
80321:   delete this.document;
80321:   delete this.onInputChange;
80321: };
80321: 
80321: StringField.prototype.setConversion = function(conversion) {
80321:   this.arg = conversion.arg;
80321:   this.element.value = conversion.arg.text;
80321:   this.setMessage(conversion.message);
80321: };
80321: 
80321: StringField.prototype.getConversion = function() {
80321:   // This tweaks the prefix/suffix of the argument to fit
80321:   this.arg = this.arg.beget(this.element.value, { prefixSpace: true });
80321:   return this.type.parse(this.arg);
80321: };
80321: 
80321: StringField.claim = function(type) {
80321:   return type instanceof StringType ? Field.MATCH : Field.IF_NOTHING_BETTER;
80321: };
80321: 
80321: exports.StringField = StringField;
80321: addField(StringField);
80321: 
80321: 
80321: /**
80321:  * A field that allows editing of numbers using an [input type=number] field
80321:  */
80321: function NumberField(type, options) {
80321:   this.document = options.document;
80321:   this.type = type;
80321:   this.arg = new Argument();
80321: 
82516:   this.element = dom.createElement(this.document, 'input');
80321:   this.element.type = 'number';
80321:   if (this.type.max) {
80321:     this.element.max = this.type.max;
80321:   }
80321:   if (this.type.min) {
80321:     this.element.min = this.type.min;
80321:   }
80321:   if (this.type.step) {
80321:     this.element.step = this.type.step;
80321:   }
80321: 
80321:   this.onInputChange = this.onInputChange.bind(this);
80321:   this.element.addEventListener('keyup', this.onInputChange, false);
80321: 
80321:   this.fieldChanged = createEvent('NumberField.fieldChanged');
80321: }
80321: 
80321: NumberField.prototype = Object.create(Field.prototype);
80321: 
80321: NumberField.claim = function(type) {
80321:   return type instanceof NumberType ? Field.MATCH : Field.NO_MATCH;
80321: };
80321: 
80321: NumberField.prototype.destroy = function() {
80321:   Field.prototype.destroy.call(this);
80321:   this.element.removeEventListener('keyup', this.onInputChange, false);
80321:   delete this.element;
80321:   delete this.document;
80321:   delete this.onInputChange;
80321: };
80321: 
80321: NumberField.prototype.setConversion = function(conversion) {
80321:   this.arg = conversion.arg;
80321:   this.element.value = conversion.arg.text;
80321:   this.setMessage(conversion.message);
80321: };
80321: 
80321: NumberField.prototype.getConversion = function() {
80321:   this.arg = this.arg.beget(this.element.value, { prefixSpace: true });
80321:   return this.type.parse(this.arg);
80321: };
80321: 
80321: exports.NumberField = NumberField;
80321: addField(NumberField);
80321: 
80321: 
80321: /**
80321:  * A field that uses a checkbox to toggle a boolean field
80321:  */
80321: function BooleanField(type, options) {
80321:   this.document = options.document;
80321:   this.type = type;
80321:   this.name = options.name;
80321:   this.named = options.named;
80321: 
82516:   this.element = dom.createElement(this.document, 'input');
80321:   this.element.type = 'checkbox';
80321:   this.element.id = 'gcliForm' + this.name;
80321: 
80321:   this.onInputChange = this.onInputChange.bind(this);
80321:   this.element.addEventListener('change', this.onInputChange, false);
80321: 
80321:   this.fieldChanged = createEvent('BooleanField.fieldChanged');
80321: }
80321: 
80321: BooleanField.prototype = Object.create(Field.prototype);
80321: 
80321: BooleanField.claim = function(type) {
80321:   return type instanceof BooleanType ? Field.MATCH : Field.NO_MATCH;
80321: };
80321: 
80321: BooleanField.prototype.destroy = function() {
80321:   Field.prototype.destroy.call(this);
80321:   this.element.removeEventListener('change', this.onInputChange, false);
80321:   delete this.element;
80321:   delete this.document;
80321:   delete this.onInputChange;
80321: };
80321: 
80321: BooleanField.prototype.setConversion = function(conversion) {
80321:   this.element.checked = conversion.value;
80321:   this.setMessage(conversion.message);
80321: };
80321: 
80321: BooleanField.prototype.getConversion = function() {
80321:   var value = this.element.checked;
80321:   var arg = this.named ?
80321:     value ? new TrueNamedArgument(this.name) : new FalseNamedArgument() :
80321:     new Argument(' ' + value);
80321:   return new Conversion(value, arg);
80321: };
80321: 
80321: exports.BooleanField = BooleanField;
80321: addField(BooleanField);
80321: 
80321: 
80321: /**
80321:  * Model an instanceof SelectionType as a select input box.
80321:  * <p>There are 3 slightly overlapping concepts to be aware of:
80321:  * <ul>
80321:  * <li>value: This is the (probably non-string) value, known as a value by the
80321:  *   assignment
80321:  * <li>optValue: This is the text value as known by the DOM option element, as
80321:  *   in &lt;option value=???%gt...
80321:  * <li>optText: This is the contents of the DOM option element.
80321:  * </ul>
80321:  */
80321: function SelectionField(type, options) {
80321:   this.document = options.document;
80321:   this.type = type;
80321:   this.items = [];
80321: 
82516:   this.element = dom.createElement(this.document, 'select');
84245:   this.element.classList.add('gcli-field');
80321:   this._addOption({
80321:     name: l10n.lookupFormat('fieldSelectionSelect', [ options.name ])
80321:   });
80321:   var lookup = this.type.getLookup();
80321:   lookup.forEach(this._addOption, this);
80321: 
80321:   this.onInputChange = this.onInputChange.bind(this);
80321:   this.element.addEventListener('change', this.onInputChange, false);
80321: 
80321:   this.fieldChanged = createEvent('SelectionField.fieldChanged');
80321: }
80321: 
80321: SelectionField.prototype = Object.create(Field.prototype);
80321: 
80321: SelectionField.claim = function(type) {
80321:   return type instanceof SelectionType ? Field.DEFAULT_MATCH : Field.NO_MATCH;
80321: };
80321: 
80321: SelectionField.prototype.destroy = function() {
80321:   Field.prototype.destroy.call(this);
80321:   this.element.removeEventListener('change', this.onInputChange, false);
80321:   delete this.element;
80321:   delete this.document;
80321:   delete this.onInputChange;
80321: };
80321: 
80321: SelectionField.prototype.setConversion = function(conversion) {
80321:   var index;
80321:   this.items.forEach(function(item) {
80321:     if (item.value && item.value === conversion.value) {
80321:       index = item.index;
80321:     }
80321:   }, this);
80321:   this.element.value = index;
80321:   this.setMessage(conversion.message);
80321: };
80321: 
80321: SelectionField.prototype.getConversion = function() {
80321:   var item = this.items[this.element.value];
80321:   var arg = new Argument(item.name, ' ');
80321:   var value = item.value ? item.value : item;
80321:   return new Conversion(value, arg);
80321: };
80321: 
80321: SelectionField.prototype._addOption = function(item) {
80321:   item.index = this.items.length;
80321:   this.items.push(item);
80321: 
82516:   var option = dom.createElement(this.document, 'option');
80321:   option.innerHTML = item.name;
80321:   option.value = item.index;
80321:   this.element.appendChild(option);
80321: };
80321: 
80321: exports.SelectionField = SelectionField;
80321: addField(SelectionField);
80321: 
80321: 
80321: /**
80321:  * A field that allows editing of javascript
80321:  */
80321: function JavascriptField(type, options) {
80321:   this.document = options.document;
80321:   this.type = type;
80321:   this.requ = options.requisition;
80321: 
80321:   this.onInputChange = this.onInputChange.bind(this);
80321:   this.arg = new Argument('', '{ ', ' }');
80321: 
82516:   this.element = dom.createElement(this.document, 'div');
82516: 
82516:   this.input = dom.createElement(this.document, 'input');
80321:   this.input.type = 'text';
80321:   this.input.addEventListener('keyup', this.onInputChange, false);
84245:   this.input.classList.add('gcli-field');
84245:   this.input.classList.add('gcli-field-javascript');
80321:   this.element.appendChild(this.input);
80321: 
82513:   this.menu = new Menu({ document: this.document, field: true });
80321:   this.element.appendChild(this.menu.element);
80321: 
80321:   this.setConversion(this.type.parse(new Argument('')));
80321: 
80321:   this.fieldChanged = createEvent('JavascriptField.fieldChanged');
80321: 
80321:   // i.e. Register this.onItemClick as the default action for a menu click
80321:   this.menu.onItemClick = this.onItemClick.bind(this);
80321: }
80321: 
80321: JavascriptField.prototype = Object.create(Field.prototype);
80321: 
80321: JavascriptField.claim = function(type) {
80321:   return type instanceof JavascriptType ? Field.MATCH : Field.NO_MATCH;
80321: };
80321: 
80321: JavascriptField.prototype.destroy = function() {
80321:   Field.prototype.destroy.call(this);
80321:   this.input.removeEventListener('keyup', this.onInputChange, false);
80321:   this.menu.destroy();
80321:   delete this.element;
80321:   delete this.input;
80321:   delete this.menu;
80321:   delete this.document;
80321:   delete this.onInputChange;
80321: };
80321: 
80321: JavascriptField.prototype.setConversion = function(conversion) {
80321:   this.arg = conversion.arg;
80321:   this.input.value = conversion.arg.text;
80321: 
80321:   var prefixLen = 0;
80321:   if (this.type instanceof JavascriptType) {
80321:     var typed = conversion.arg.text;
80321:     var lastDot = typed.lastIndexOf('.');
80321:     if (lastDot !== -1) {
80321:       prefixLen = lastDot;
80321:     }
80321:   }
80321: 
80321:   var items = [];
80321:   var predictions = conversion.getPredictions();
80321:   predictions.forEach(function(item) {
80321:     // Commands can be hidden
80321:     if (!item.hidden) {
80321:       items.push({
80321:         name: item.name.substring(prefixLen),
80321:         complete: item.name,
80321:         description: item.description || ''
80321:       });
80321:     }
80321:   }, this);
80321: 
80321:   this.menu.show(items);
80321:   this.setMessage(conversion.message);
80321: };
80321: 
80321: JavascriptField.prototype.onItemClick = function(ev) {
80321:   this.item = ev.currentTarget.item;
80321:   this.arg = this.arg.beget(this.item.complete, { normalize: true });
80321:   var conversion = this.type.parse(this.arg);
80321:   this.fieldChanged({ conversion: conversion });
80321:   this.setMessage(conversion.message);
80321: };
80321: 
80321: JavascriptField.prototype.onInputChange = function(ev) {
80321:   this.item = ev.currentTarget.item;
80321:   var conversion = this.getConversion();
80321:   this.fieldChanged({ conversion: conversion });
80321:   this.setMessage(conversion.message);
80321: };
80321: 
80321: JavascriptField.prototype.getConversion = function() {
80321:   // This tweaks the prefix/suffix of the argument to fit
80321:   this.arg = this.arg.beget(this.input.value, { normalize: true });
80321:   return this.type.parse(this.arg);
80321: };
80321: 
80321: JavascriptField.DEFAULT_VALUE = '__JavascriptField.DEFAULT_VALUE';
80321: 
80321: exports.JavascriptField = JavascriptField;
80321: addField(JavascriptField);
80321: 
80321: 
80321: /**
80321:  * A field that works with deferred types by delaying resolution until that
80321:  * last possible time
80321:  */
80321: function DeferredField(type, options) {
80321:   this.document = options.document;
80321:   this.type = type;
80321:   this.options = options;
80321:   this.requisition = options.requisition;
80321:   this.requisition.assignmentChange.add(this.update, this);
80321: 
82516:   this.element = dom.createElement(this.document, 'div');
80321:   this.update();
80321: 
80321:   this.fieldChanged = createEvent('DeferredField.fieldChanged');
80321: }
80321: 
80321: DeferredField.prototype = Object.create(Field.prototype);
80321: 
80321: DeferredField.prototype.update = function() {
80321:   var subtype = this.type.defer();
80321:   if (subtype === this.subtype) {
80321:     return;
80321:   }
80321: 
80321:   if (this.field) {
80321:     this.field.destroy();
80321:   }
80321: 
80321:   this.subtype = subtype;
80321:   this.field = getField(subtype, this.options);
80321:   this.field.fieldChanged.add(this.fieldChanged, this);
80321: 
80321:   dom.clearElement(this.element);
80321:   this.element.appendChild(this.field.element);
80321: };
80321: 
80321: DeferredField.claim = function(type) {
80321:   return type instanceof DeferredType ? Field.MATCH : Field.NO_MATCH;
80321: };
80321: 
80321: DeferredField.prototype.destroy = function() {
80321:   Field.prototype.destroy.call(this);
80321:   this.requisition.assignmentChange.remove(this.update, this);
80321:   delete this.element;
80321:   delete this.document;
80321:   delete this.onInputChange;
80321: };
80321: 
80321: DeferredField.prototype.setConversion = function(conversion) {
80321:   this.field.setConversion(conversion);
80321: };
80321: 
80321: DeferredField.prototype.getConversion = function() {
80321:   return this.field.getConversion();
80321: };
80321: 
80321: exports.DeferredField = DeferredField;
80321: addField(DeferredField);
80321: 
80321: 
80321: /**
80321:  * For use with deferred types that do not yet have anything to resolve to.
80321:  * BlankFields are not for general use.
80321:  */
80321: function BlankField(type, options) {
80321:   this.document = options.document;
80321:   this.type = type;
82516:   this.element = dom.createElement(this.document, 'div');
80321: 
80321:   this.fieldChanged = createEvent('BlankField.fieldChanged');
80321: }
80321: 
80321: BlankField.prototype = Object.create(Field.prototype);
80321: 
80321: BlankField.claim = function(type) {
80321:   return type instanceof BlankType ? Field.MATCH : Field.NO_MATCH;
80321: };
80321: 
80321: BlankField.prototype.setConversion = function() { };
80321: 
80321: BlankField.prototype.getConversion = function() {
80321:   return new Conversion(null);
80321: };
80321: 
80321: exports.BlankField = BlankField;
80321: addField(BlankField);
80321: 
80321: 
80321: /**
80321:  * Adds add/delete buttons to a normal field allowing there to be many values
80321:  * given for a parameter.
80321:  */
80321: function ArrayField(type, options) {
80321:   this.document = options.document;
80321:   this.type = type;
80321:   this.options = options;
80321:   this.requ = options.requisition;
80321: 
80321:   this._onAdd = this._onAdd.bind(this);
80321:   this.members = [];
80321: 
80321:   // <div class=gcliArrayParent save="${element}">
82516:   this.element = dom.createElement(this.document, 'div');
84245:   this.element.classList.add('gcli-array-parent');
80321: 
80321:   // <button class=gcliArrayMbrAdd onclick="${_onAdd}" save="${addButton}">Add
82516:   this.addButton = dom.createElement(this.document, 'button');
84245:   this.addButton.classList.add('gcli-array-member-add');
80321:   this.addButton.addEventListener('click', this._onAdd, false);
80321:   this.addButton.innerHTML = l10n.lookup('fieldArrayAdd');
80321:   this.element.appendChild(this.addButton);
80321: 
80321:   // <div class=gcliArrayMbrs save="${mbrElement}">
82516:   this.container = dom.createElement(this.document, 'div');
84245:   this.container.classList.add('gcli-array-members');
80321:   this.element.appendChild(this.container);
80321: 
80321:   this.onInputChange = this.onInputChange.bind(this);
80321: 
80321:   this.fieldChanged = createEvent('ArrayField.fieldChanged');
80321: }
80321: 
80321: ArrayField.prototype = Object.create(Field.prototype);
80321: 
80321: ArrayField.claim = function(type) {
80321:   return type instanceof ArrayType ? Field.MATCH : Field.NO_MATCH;
80321: };
80321: 
80321: ArrayField.prototype.destroy = function() {
80321:   Field.prototype.destroy.call(this);
80321:   this.addButton.removeEventListener('click', this._onAdd, false);
80321: };
80321: 
80321: ArrayField.prototype.setConversion = function(conversion) {
80321:   // BUG 653568: this is too brutal - it removes focus from any the current field
80321:   dom.clearElement(this.container);
80321:   this.members = [];
80321: 
80321:   conversion.conversions.forEach(function(subConversion) {
80321:     this._onAdd(null, subConversion);
80321:   }, this);
80321: };
80321: 
80321: ArrayField.prototype.getConversion = function() {
80321:   var conversions = [];
80321:   var arrayArg = new ArrayArgument();
80321:   for (var i = 0; i < this.members.length; i++) {
80321:     var conversion = this.members[i].field.getConversion();
80321:     conversions.push(conversion);
80321:     arrayArg.addArgument(conversion.arg);
80321:   }
80321:   return new ArrayConversion(conversions, arrayArg);
80321: };
80321: 
80321: ArrayField.prototype._onAdd = function(ev, subConversion) {
80321:   // <div class=gcliArrayMbr save="${element}">
82516:   var element = dom.createElement(this.document, 'div');
84245:   element.classList.add('gcli-array-member');
80321:   this.container.appendChild(element);
80321: 
80321:   // ${field.element}
80321:   var field = getField(this.type.subtype, this.options);
80321:   field.fieldChanged.add(function() {
80321:     var conversion = this.getConversion();
80321:     this.fieldChanged({ conversion: conversion });
80321:     this.setMessage(conversion.message);
80321:   }, this);
80321: 
80321:   if (subConversion) {
80321:     field.setConversion(subConversion);
80321:   }
80321:   element.appendChild(field.element);
80321: 
80321:   // <div class=gcliArrayMbrDel onclick="${_onDel}">
82516:   var delButton = dom.createElement(this.document, 'button');
84245:   delButton.classList.add('gcli-array-member-del');
80321:   delButton.addEventListener('click', this._onDel, false);
80321:   delButton.innerHTML = l10n.lookup('fieldArrayDel');
80321:   element.appendChild(delButton);
80321: 
80321:   var member = {
80321:     element: element,
80321:     field: field,
80321:     parent: this
80321:   };
80321:   member.onDelete = function() {
80321:     this.parent.container.removeChild(this.element);
80321:     this.parent.members = this.parent.members.filter(function(test) {
80321:       return test !== this;
80321:     });
80321:     this.parent.onInputChange();
80321:   }.bind(member);
80321:   delButton.addEventListener('click', member.onDelete, false);
80321: 
80321:   this.members.push(member);
80321: };
80321: 
80321: exports.ArrayField = ArrayField;
80321: addField(ArrayField);
80321: 
80321: 
80321: });
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/ui/menu', ['require', 'exports', 'module' , 'gcli/util', 'gcli/types', 'gcli/argument', 'gcli/canon', 'gcli/ui/domtemplate', 'text!gcli/ui/menu.css', 'text!gcli/ui/menu.html'], function(require, exports, module) {
80321: 
80321: 
80321: var dom = require('gcli/util').dom;
80321: 
80321: var Conversion = require('gcli/types').Conversion;
80321: var Argument = require('gcli/argument').Argument;
80321: var canon = require('gcli/canon');
80321: 
84248: var domtemplate = require('gcli/ui/domtemplate');
80321: 
80321: var menuCss = require('text!gcli/ui/menu.css');
80321: var menuHtml = require('text!gcli/ui/menu.html');
80321: 
80321: 
80321: /**
80321:  * Menu is a display of the commands that are possible given the state of a
80321:  * requisition.
80321:  * @param options A way to customize the menu display. Valid options are:
82513:  * - field: [boolean] Turns the menu display into a drop-down for use inside a
80321:  *   JavascriptField.
82513:  * - document: The document to use in creating widgets
82513:  * - menuClass: Custom class name when generating the top level element
82513:  *   which allows different layout systems
82513:  */
82513: function Menu(options) {
82513:   options = options || {};
82513:   this.document = options.document || document;
82513: 
82513:   // FF can be really hard to debug if doc is null, so we check early on
82513:   if (!this.document) {
82513:     throw new Error('No document');
82513:   }
82513: 
82513:   this.element =  dom.createElement(this.document, 'div');
82514:   this.element.classList.add(options.menuClass || 'gcli-menu');
80321:   if (options && options.field) {
82514:     this.element.classList.add(options.menuFieldClass || 'gcli-menu-field');
80321:   }
80321: 
80321:   // Pull the HTML into the DOM, but don't add it to the document
80321:   if (menuCss != null) {
82513:     this.style = dom.importCss(menuCss, this.document);
82513:   }
82513: 
82513:   var templates = dom.createElement(this.document, 'div');
80321:   dom.setInnerHtml(templates, menuHtml);
82514:   this.optTempl = templates.querySelector('.gcli-menu-template');
80321: 
80321:   // Contains the items that should be displayed
80321:   this.items = null;
80321: }
80321: 
80321: /**
80321:  * Avoid memory leaks
80321:  */
80321: Menu.prototype.destroy = function() {
80321:   if (this.style) {
80321:     this.style.parentNode.removeChild(this.style);
80321:     delete this.style;
80321:   }
80321: 
80321:   delete this.element;
80321:   delete this.items;
80321:   delete this.optTempl;
80321: };
80321: 
80321: /**
80321:  * The default is to do nothing when someone clicks on the menu.
80321:  * Plug an implementation in here before calling show() to do something useful.
80321:  * This is called from template.html
80321:  * @param ev The click event from the browser
80321:  */
80321: Menu.prototype.onItemClick = function(ev) {
80321: };
80321: 
80321: /**
80321:  * Display a number of items in the menu (or hide the menu if there is nothing
80321:  * to display)
80321:  * @param items The items to show in the menu
80321:  * @param error An error message to display
80321:  */
80321: Menu.prototype.show = function(items, error) {
80321:   this.error = error;
80321:   this.items = items;
80321: 
80321:   if (this.error == null && this.items.length === 0) {
80321:     this.element.style.display = 'none';
80321:     return;
80321:   }
80321: 
80321:   var options = this.optTempl.cloneNode(true);
84248:   domtemplate.template(options, this, { allowEval: true, stack: 'menu.html' });
80321: 
80321:   dom.clearElement(this.element);
80321:   this.element.appendChild(options);
80321: 
80321:   this.element.style.display = 'block';
80321: };
80321: 
80321: /**
80321:  * Hide the menu
80321:  */
80321: Menu.prototype.hide = function() {
80321:   this.element.style.display = 'none';
80321: };
80321: 
82513: /**
82513:  * Change how much vertical space this menu can take up
82513:  */
82513: Menu.prototype.setMaxHeight = function(height) {
82513:   this.element.style.maxHeight = height + 'px';
82513: };
82513: 
80321: exports.Menu = Menu;
80321: 
80321: 
80321: /**
80321:  * CommandMenu is a special menu that integrates with a Requisition to display
80321:  * available commands.
82513:  * @param options A way to customize the menu display. Valid options include
82513:  * those valid for Menu(), plus:
82513:  * - requisition: The Requisition to fill out (required)
82513:  */
82513: function CommandMenu(options) {
82513:   Menu.call(this, options);
82513:   this.requisition = options.requisition;
80321: 
80321:   this.requisition.commandChange.add(this.onCommandChange, this);
80321:   canon.canonChange.add(this.onCommandChange, this);
82513: 
82513:   this.onCommandChange();
80321: }
80321: 
80321: CommandMenu.prototype = Object.create(Menu.prototype);
80321: 
80321: /**
80321:  * Avoid memory leaks
80321:  */
80321: CommandMenu.prototype.destroy = function() {
80321:   this.requisition.commandChange.remove(this.onCommandChange, this);
80321:   canon.canonChange.remove(this.onCommandChange, this);
80321: 
80321:   Menu.prototype.destroy.call(this);
80321: };
80321: 
80321: /**
80321:  * We want to fill-in the clicked command in the cli input when the user clicks
80321:  */
80321: CommandMenu.prototype.onItemClick = function(ev) {
80321:   var type = this.requisition.commandAssignment.param.type;
80321: 
82517:   var name = ev.currentTarget.querySelector('.gcli-menu-name').innerHTML;
82517:   var arg = new Argument(name);
80321:   arg.suffix = ' ';
80321: 
80321:   var conversion = type.parse(arg);
80321:   this.requisition.commandAssignment.setConversion(conversion);
80321: };
80321: 
80321: /**
80321:  * Update the various hint components to reflect the changed command
80321:  */
80321: CommandMenu.prototype.onCommandChange = function(ev) {
80321:   var command = this.requisition.commandAssignment.getValue();
80321:   if (!command || !command.exec) {
81343:     var error = this.requisition.commandAssignment.getMessage();
80321:     var predictions = this.requisition.commandAssignment.getPredictions();
80321: 
80321:     if (predictions.length === 0) {
80321:       var commandType = this.requisition.commandAssignment.param.type;
80321:       var conversion = commandType.parse(new Argument());
80321:       predictions = conversion.getPredictions();
80321:     }
80321: 
80321:     predictions.sort(function(command1, command2) {
80321:       return command1.name.localeCompare(command2.name);
80321:     });
80321:     var items = [];
80321:     predictions.forEach(function(item) {
80321:       if (item.description && !item.hidden) {
80321:         items.push(item);
80321:       }
80321:     }, this);
80321: 
80321:     this.show(items, error);
80321:   }
80321:   else {
80321:     if (ev && ev.oldValue === ev.newValue) {
80321:       return; // Just the text has changed
80321:     }
80321: 
80321:     this.hide();
80321:   }
80321: };
80321: 
80321: exports.CommandMenu = CommandMenu;
80321: 
80321: 
80321: });
80321: define("text!gcli/ui/menu.css", [], void 0);
82515: define("text!gcli/ui/menu.html", [], "\n" +
82515:   "<table class=\"gcli-menu-template\" aria-live=\"polite\">\n" +
82515:   "  <tr class=\"gcli-menu-option\" foreach=\"item in ${items}\"\n" +
82517:   "      onclick=\"${onItemClick}\" title=\"${item.manual || ''}\">\n" +
82515:   "    <td class=\"gcli-menu-name\">${item.name}</td>\n" +
82515:   "    <td class=\"gcli-menu-desc\">${item.description}</td>\n" +
82515:   "  </tr>\n" +
82515:   "  <tr if=\"${error}\">\n" +
82515:   "    <td class=\"gcli-menu-error\" colspan=\"2\">${error}</td>\n" +
82515:   "  </tr>\n" +
82515:   "</table>\n" +
80321:   "");
80321: 
80321: define("text!gcli/ui/arg_fetch.css", [], void 0);
82515: define("text!gcli/ui/arg_fetch.html", [], "\n" +
82515:   "<!--\n" +
82515:   "Template for an Assignment.\n" +
82515:   "Evaluated each time the commandAssignment changes\n" +
82515:   "-->\n" +
82515:   "<div class=\"gcli-af-template\" aria-live=\"polite\">\n" +
82515:   "  <div>\n" +
82515:   "    <div class=\"gcli-af-cmddesc\">\n" +
82515:   "      ${requisition.commandAssignment.getValue().description}\n" +
82515:   "    </div>\n" +
82515:   "    <table class=\"gcli-af-params\">\n" +
82515:   "      <tbody foreach=\"assignment in ${requisition.getAssignments()}\">\n" +
82515:   "        <!-- Parameter -->\n" +
82515:   "        <tr>\n" +
82515:   "          <td class=\"gcli-af-paramname\">\n" +
82515:   "            <label for=\"gcliForm${assignment.param.name}\">\n" +
82515:   "              ${assignment.param.description ? assignment.param.description + ':' : ''}\n" +
82515:   "            </label>\n" +
82515:   "          </td>\n" +
82515:   "          <td>${getInputFor(assignment)}</td>\n" +
82515:   "          <td>\n" +
82515:   "            <span class=\"gcli-af-required\" if=\"${assignment.param.isDataRequired()}\">*</span>\n" +
82515:   "          </td>\n" +
82515:   "        </tr>\n" +
82515:   "        <tr>\n" +
82515:   "          <td class=\"gcli-af-error\" colspan=\"2\">\n" +
82515:   "            ${linkMessageElement(assignment, __element)}\n" +
82515:   "          </td>\n" +
82515:   "        </tr>\n" +
82515:   "      </tbody>\n" +
82515:   "      <tfoot>\n" +
82515:   "        <tr>\n" +
82515:   "          <td colspan=\"3\" class=\"gcli-af-submit\">\n" +
82515:   "            <input type=\"submit\" value=\"Cancel\" onclick=\"${onFormCancel}\"/>\n" +
82515:   "            <input type=\"submit\" value=\"OK\" onclick=\"${onFormOk}\" save=\"${okElement}\"/>\n" +
82515:   "          </td>\n" +
82515:   "        </tr>\n" +
82515:   "      </tfoot>\n" +
82515:   "    </table>\n" +
82515:   "  </div>\n" +
82515:   "</div>\n" +
80321:   "");
80321: 
80321: /*
80321:  * Copyright 2009-2011 Mozilla Foundation and contributors
80321:  * Licensed under the New BSD license. See LICENSE.txt or:
80321:  * http://opensource.org/licenses/BSD-3-Clause
80321:  */
80321: 
80321: define('gcli/ui/focus', ['require', 'exports', 'module' , 'gcli/util'], function(require, exports, module) {
80321: 
80321: 
80321: var util = require('gcli/util');
80321: 
80321: /**
80321:  * FocusManager solves the problem of tracking focus among a set of nodes.
80321:  * The specific problem we are solving is when the hint element must be visible
80321:  * if either the command line or any of the inputs in the hint element has the
80321:  * focus, and invisible at other times, without hiding and showing the hint
80321:  * element even briefly as the focus changes between them.
80321:  * It does this simply by postponing the hide events by 250ms to see if
80321:  * something else takes focus.
80321:  * @param options An optional object containing configuration values. Valid
80321:  * properties on the options object are:
80321:  * - document
80321:  * - blurDelay
80321:  * - debug
80321:  * - initialFocus
80321:  */
80321: function FocusManager(options) {
80321:   options = options || {};
80321: 
80321:   this._debug = options.debug || false;
80321:   this._blurDelayTimeout = null; // Result of setTimeout in delaying a blur
80321:   this._monitoredElements = [];  // See addMonitoredElement()
80321: 
80321:   this.hasFocus = false;
80321:   this.blurDelay = options.blurDelay || 250;
80321:   this.document = options.document || document;
80321: 
80321:   this.onFocus = util.createEvent('FocusManager.onFocus');
80321:   this.onBlur = util.createEvent('FocusManager.onBlur');
80321: 
80321:   // We take a focus event anywhere to be an indication that we might be about
80321:   // to lose focus
80321:   this._onDocumentFocus = function() {
80321:     this.reportBlur('document');
80321:   }.bind(this);
80321:   this.document.addEventListener('focus', this._onDocumentFocus, true);
80321: }
80321: 
80321: /**
80321:  * Avoid memory leaks
80321:  */
80321: FocusManager.prototype.destroy = function() {
80321:   this.document.removeEventListener('focus', this._onDocumentFocus, true);
80321:   delete this.document;
80321: 
80321:   for (var i = 0; i < this._monitoredElements.length; i++) {
80321:     var monitor = this._monitoredElements[i];
80321:     console.error('Hanging monitored element: ', monitor.element);
80321: 
80321:     monitor.element.removeEventListener('focus', monitor.onFocus, true);
80321:     monitor.element.removeEventListener('blur', monitor.onBlur, true);
80321:   }
80321: 
80321:   if (this._blurDelayTimeout) {
80321:     clearTimeout(this._blurDelayTimeout);
80321:     this._blurDelayTimeout = null;
80321:   }
80321: };
80321: 
80321: /**
80321:  * The easy way to include an element in the set of things that are part of the
80321:  * aggregate focus. Using [add|remove]MonitoredElement() is a simpler way of
80321:  * option than calling report[Focus|Blur]()
80321:  * @param element The element on which to track focus|blur events
80321:  * @param where Optional source string for debugging only
80321:  */
80321: FocusManager.prototype.addMonitoredElement = function(element, where) {
80321:   if (this._debug) {
80321:     console.log('FocusManager.addMonitoredElement(' + (where || 'unknown') + ')');
80321:   }
80321: 
80321:   var monitor = {
80321:     element: element,
80321:     where: where,
80321:     onFocus: function() { this.reportFocus(where); }.bind(this),
80321:     onBlur: function() { this.reportBlur(where); }.bind(this)
80321:   };
80321: 
80321:   element.addEventListener('focus', monitor.onFocus, true);
80321:   element.addEventListener('blur', monitor.onBlur, true);
80321:   this._monitoredElements.push(monitor);
80321: };
80321: 
80321: /**
80321:  * Undo the effects of addMonitoredElement()
80321:  * @param element The element to stop tracking
80321:  */
80321: FocusManager.prototype.removeMonitoredElement = function(element) {
80321:   var monitor;
80321:   var matchIndex;
80321: 
80321:   for (var i = 0; i < this._monitoredElements.length; i++) {
80321:     if (this._monitoredElements[i].element === element) {
80321:       monitor = this._monitoredElements[i];
80321:       matchIndex = i;
80321:     }
80321:   }
80321: 
80321:   if (!monitor) {
80321:     if (this._debug) {
80321:       console.error('Missing monitor for element. ', element);
80321:     }
80321:     return;
80321:   }
80321: 
80321:   this._monitoredElements.splice(matchIndex, 1);
80321:   element.removeEventListener('focus', monitor.onFocus, true);
80321:   element.removeEventListener('blur', monitor.onBlur, true);
80321: };
80321: 
80321: /**
80321:  * Some component has received a 'focus' event. This sets the internal status
80321:  * straight away and informs the listeners
80321:  * @param where Optional source string for debugging only
80321:  */
80321: FocusManager.prototype.reportFocus = function(where) {
80321:   if (this._debug) {
80321:     console.log('FocusManager.reportFocus(' + (where || 'unknown') + ')');
80321:   }
80321: 
80321:   if (this._blurDelayTimeout) {
80321:     if (this._debug) {
80321:       console.log('FocusManager.cancelBlur');
80321:     }
80321:     clearTimeout(this._blurDelayTimeout);
80321:     this._blurDelayTimeout = null;
80321:   }
80321: 
80321:   if (!this.hasFocus) {
80321:     this.hasFocus = true;
80321:     this.onFocus();
80321:   }
80321: };
80321: 
80321: /**
80321:  * Some component has received a 'blur' event. This waits for a while to see if
80321:  * we are going to get any subsequent 'focus' events and then sets the internal
80321:  * status and informs the listeners
80321:  * @param where Optional source string for debugging only
80321:  */
80321: FocusManager.prototype.reportBlur = function(where) {
80321:   if (this._debug) {
80321:     console.log('FocusManager.reportBlur(' + where + ')');
80321:   }
80321: 
80321:   if (this.hasFocus) {
80321:     if (this._blurDelayTimeout) {
80321:       if (this._debug) {
80321:         console.log('FocusManager.blurPending');
80321:       }
80321:       return;
80321:     }
80321: 
80321:     this._blurDelayTimeout = setTimeout(function() {
80321:       if (this._debug) {
80321:         console.log('FocusManager.blur');
80321:       }
80321:       this.hasFocus = false;
80321:       this.onBlur();
80321:       this._blurDelayTimeout = null;
80321:     }.bind(this), this.blurDelay);
80321:   }
80321: };
80321: 
80321: exports.FocusManager = FocusManager;
80321: 
80321: 
80321: });
74961: 
74961: /*
74961:  * require GCLI so it can be exported as declared in EXPORTED_SYMBOLS
74961:  * The dependencies specified here should be the same as in Makefile.dryice.js
74961:  */
74961: var gcli = require("gcli/index");
