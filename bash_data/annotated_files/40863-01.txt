35117: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35117:  * vim: set ts=8 sw=4 et tw=99:
35117:  *
35117:  * ***** BEGIN LICENSE BLOCK *****
35117:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35117:  *
35117:  * The contents of this file are subject to the Mozilla Public License Version
35117:  * 1.1 (the "License"); you may not use this file except in compliance with
35117:  * the License. You may obtain a copy of the License at
35117:  * http://www.mozilla.org/MPL/
35117:  *
35117:  * Software distributed under the License is distributed on an "AS IS" basis,
35117:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35117:  * for the specific language governing rights and limitations under the
35117:  * License.
35117:  *
35117:  * The Original Code is Mozilla Communicator client code, released
35117:  * March 31, 1998.
35117:  *
35117:  * The Initial Developer of the Original Code is
35117:  * Netscape Communications Corporation.
35117:  * Portions created by the Initial Developer are Copyright (C) 1998
35117:  * the Initial Developer. All Rights Reserved.
35117:  *
35117:  * Contributor(s):
35117:  *
35117:  * Alternatively, the contents of this file may be used under the terms of
35117:  * either of the GNU General Public License Version 2 or later (the "GPL"),
35117:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35117:  * in which case the provisions of the GPL or the LGPL are applicable instead
35117:  * of those above. If you wish to allow use of your version of this file only
35117:  * under the terms of either the GPL or the LGPL, and not to allow others to
35117:  * use your version of this file under the terms of the MPL, indicate your
35117:  * decision by deleting the provisions above and replace them with the notice
35117:  * and other provisions required by the GPL or the LGPL. If you do not delete
35117:  * the provisions above, a recipient may use your version of this file under
35117:  * the terms of any one of the MPL, the GPL or the LGPL.
35117:  *
35117:  * ***** END LICENSE BLOCK ***** */
35117: 
35117: #ifndef jsobjinlines_h___
35117: #define jsobjinlines_h___
35117: 
35117: #include "jsobj.h"
40858: #include "jsiter.h"
35117: #include "jsscope.h"
35117: 
40858: #include "jsscopeinlines.h"
40858: 
40410: inline jsval
40796: JSObject::getSlotMT(JSContext *cx, uintN slot)
40796: {
40410: #ifdef JS_THREADSAFE
40410:     /*
40430:      * If thread-safe, define a getSlotMT() that bypasses, for a native
40410:      * object, the lock-free "fast path" test of
40847:      * (obj->scope()->ownercx == cx), to avoid needlessly switching from
40410:      * lock-free to lock-full scope when doing GC on a different context
40410:      * from the last one to own the scope.  The caller in this case is
40410:      * probably a JSClass.mark function, e.g., fun_mark, or maybe a
40410:      * finalizer.
40410:      */
40410:     OBJ_CHECK_SLOT(this, slot);
40847:     return (scope()->title.ownercx == cx)
40847:            ? this->lockedGetSlot(slot)
40410:            : js_GetSlotThreadSafe(cx, this, slot);
40410: #else
40847:     return this->lockedGetSlot(slot);
40410: #endif
40410: }
40410: 
40410: inline void
40796: JSObject::setSlotMT(JSContext *cx, uintN slot, jsval value)
40796: {
40410: #ifdef JS_THREADSAFE
40410:     /* Thread-safe way to set a slot. */
40410:     OBJ_CHECK_SLOT(this, slot);
40847:     if (scope()->title.ownercx == cx)
40847:         this->lockedSetSlot(slot, value);
40410:     else
40410:         js_SetSlotThreadSafe(cx, this, slot, value);
40410: #else
40847:     this->lockedSetSlot(slot, value);
40410: #endif
40410: }
40410: 
40797: inline void JSObject::staticAssertArrayLengthIsInPrivateSlot()
40797: {
40797:     JS_STATIC_ASSERT(JSSLOT_ARRAY_LENGTH == JSSLOT_PRIVATE);
40797: }
40797: 
40796: inline uint32
40796: JSObject::getArrayLength() const
40796: {
40796:     JS_ASSERT(isArray());
40796:     return uint32(fslots[JSSLOT_ARRAY_LENGTH]);
40796: }
40796: 
40796: inline uint32 
40796: JSObject::getArrayCount() const
40796: {
40796:     JS_ASSERT(isArray());
40796:     return uint32(fslots[JSSLOT_ARRAY_COUNT]);
40796: }
40796: 
40796: inline void 
40796: JSObject::setArrayLength(uint32 length)
40796: {
40796:     JS_ASSERT(isArray());
40796:     fslots[JSSLOT_ARRAY_LENGTH] = length;
40796: }
40796: 
40796: inline void 
40796: JSObject::setArrayCount(uint32 count)
40796: {
40796:     JS_ASSERT(isArray());
40796:     fslots[JSSLOT_ARRAY_COUNT] = count;
40796: }
40796: 
40796: inline void 
40796: JSObject::voidDenseArrayCount()
40796: {
40796:     JS_ASSERT(isDenseArray());
40796:     fslots[JSSLOT_ARRAY_COUNT] = JSVAL_VOID;
40796: }
40796: 
40796: inline void 
40796: JSObject::incArrayCountBy(uint32 posDelta)
40796: {
40796:     JS_ASSERT(isArray());
40796:     fslots[JSSLOT_ARRAY_COUNT] += posDelta;
40796: }
40796: 
40796: inline void 
40796: JSObject::decArrayCountBy(uint32 negDelta)
40796: {
40796:     JS_ASSERT(isArray());
40796:     fslots[JSSLOT_ARRAY_COUNT] -= negDelta;
40796: }
40796: 
40796: inline void
40796: JSObject::voidArrayUnused()
40796: {
40796:     JS_ASSERT(isArray());
40863:     fslots[JSSLOT_ARRAY_UNUSED] = JSVAL_VOID;
40796: }
40796: 
35117: inline void
35117: JSObject::initSharingEmptyScope(JSClass *clasp, JSObject *proto, JSObject *parent,
35117:                                 jsval privateSlotValue)
35117: {
35117:     init(clasp, proto, parent, privateSlotValue);
35117: 
40847:     JSEmptyScope *emptyScope = proto->scope()->emptyScope;
35117:     JS_ASSERT(emptyScope->clasp == clasp);
35117:     emptyScope->hold();
35117:     map = emptyScope;
35117: }
35117: 
36997: inline void
36997: JSObject::freeSlotsArray(JSContext *cx)
36997: {
36997:     JS_ASSERT(hasSlotsArray());
36997:     JS_ASSERT(size_t(dslots[-1]) > JS_INITIAL_NSLOTS);
36997:     cx->free(dslots - 1);
36997: }
36997: 
37685: inline bool
37685: JSObject::unbrand(JSContext *cx)
37685: {
40430:     if (this->isNative()) {
37685:         JS_LOCK_OBJ(cx, this);
40847:         JSScope *scope = this->scope();
37766:         if (scope->isSharedEmpty()) {
37685:             scope = js_GetMutableScope(cx, this);
37685:             if (!scope) {
37685:                 JS_UNLOCK_OBJ(cx, this);
37685:                 return false;
37685:             }
37685:         }
37685:         scope->setGeneric();
37685:         JS_UNLOCK_SCOPE(cx, scope);
37685:     }
37685:     return true;
37685: }
37685: 
40388: namespace js {
40388: 
40388: typedef Vector<PropertyDescriptor, 1> PropertyDescriptorArray;
40388: 
40388: class AutoDescriptorArray : private AutoGCRooter
40388: {
40388:   public:
40388:     AutoDescriptorArray(JSContext *cx)
40388:       : AutoGCRooter(cx, DESCRIPTORS), descriptors(cx)
40388:     { }
40388: 
40388:     PropertyDescriptor *append() {
40388:         if (!descriptors.append(PropertyDescriptor()))
40388:             return NULL;
40388:         return &descriptors.back();
40388:     }
40388: 
40388:     PropertyDescriptor& operator[](size_t i) {
40388:         JS_ASSERT(i < descriptors.length());
40388:         return descriptors[i];
40388:     }
40388: 
40388:     friend void AutoGCRooter::trace(JSTracer *trc);
40388: 
40388:   private:
40388:     PropertyDescriptorArray descriptors;
40388: };
40388: 
40858: static inline bool
40858: InitScopeForObject(JSContext* cx, JSObject* obj, JSClass *clasp, JSObject* proto, JSObjectOps* ops)
40858: {
40858:     JS_ASSERT(ops->isNative());
40858:     JS_ASSERT(proto == obj->getProto());
40858: 
40858:     /* Share proto's emptyScope only if obj is similar to proto. */
40858:     JSScope *scope = NULL;
40858: 
40858:     if (proto && proto->isNative()) {
40858:         JS_LOCK_OBJ(cx, proto);
40858:         scope = proto->scope();
40858:         if (scope->canProvideEmptyScope(ops, clasp)) {
40858:             JSScope *emptyScope = scope->getEmptyScope(cx, clasp);
40858:             JS_UNLOCK_SCOPE(cx, scope);
40858:             if (!emptyScope)
40858:                 goto bad;
40858:             scope = emptyScope;
40858:         } else {
40858:             JS_UNLOCK_SCOPE(cx, scope);
40858:             scope = NULL;
40858:         }
40858:     }
40858: 
40858:     if (!scope) {
40858:         scope = JSScope::create(cx, ops, clasp, obj, js_GenerateShape(cx, false));
40858:         if (!scope)
40858:             goto bad;
40858: 
40858:         /* Let JSScope::create set freeslot so as to reserve slots. */
40858:         JS_ASSERT(scope->freeslot >= JSSLOT_PRIVATE);
40858:         if (scope->freeslot > JS_INITIAL_NSLOTS &&
40858:             !js_AllocSlots(cx, obj, scope->freeslot)) {
40858:             scope->destroy(cx);
40858:             goto bad;
40858:         }
40858:     }
40858: 
40858:     obj->map = scope;
40858:     return true;
40858: 
40858:   bad:
40858:     /* The GC nulls map initially. It should still be null on error. */
40858:     JS_ASSERT(!obj->map);
40858:     return false;
40858: }
40858: 
40858: static inline JSObject *
40858: NewObjectWithGivenProto(JSContext *cx, JSClass *clasp, JSObject *proto,
40858:                         JSObject *parent, size_t objectSize = 0)
40858: {
40858: #ifdef INCLUDE_MOZILLA_DTRACE
40858:     if (JAVASCRIPT_OBJECT_CREATE_START_ENABLED())
40858:         jsdtrace_object_create_start(cx->fp, clasp);
40858: #endif
40858: 
40858:     /* Assert that the class is a proper class. */
40858:     JS_ASSERT_IF(clasp->flags & JSCLASS_IS_EXTENDED,
40858:                  ((JSExtendedClass *)clasp)->equality);
40858: 
40858:     /* Always call the class's getObjectOps hook if it has one. */
40858:     JSObjectOps *ops = clasp->getObjectOps
40858:                        ? clasp->getObjectOps(cx, clasp)
40858:                        : &js_ObjectOps;
40858: 
40858:     /*
40858:      * Allocate an object from the GC heap and initialize all its fields before
40858:      * doing any operation that can potentially trigger GC. Functions have a
40858:      * larger non-standard allocation size.
40858:      */
40858:     JSObject* obj;
40858:     if (clasp == &js_FunctionClass && !objectSize) {
40858:         obj = (JSObject*) js_NewGCFunction(cx);
40858: #ifdef DEBUG
40858:         if (obj) {
40858:             memset((uint8 *) obj + sizeof(JSObject), JS_FREE_PATTERN,
40858:                    sizeof(JSFunction) - sizeof(JSObject));
40858:         }
40858: #endif
40858:     } else {
40858:         JS_ASSERT(!objectSize || objectSize == sizeof(JSObject));
40858:         obj = (clasp == &js_IteratorClass)
40858:             ? js_NewGCIter(cx)
40858:             : js_NewGCObject(cx);
40858:     }
40858:     if (!obj)
40858:         goto out;
40858: 
40858:     /*
40858:      * Default parent to the parent of the prototype, which was set from
40858:      * the parent of the prototype's constructor.
40858:      */
40858:     obj->init(clasp,
40858:               proto,
40858:               (!parent && proto) ? proto->getParent() : parent,
40858:               JSObject::defaultPrivate(clasp));
40858: 
40858:     if (ops->isNative()) {
40858:         if (!InitScopeForObject(cx, obj, clasp, proto, ops)) {
40858:             obj = NULL;
40858:             goto out;
40858:         }
40858:     } else {
40858:         JS_ASSERT(ops->objectMap->ops == ops);
40858:         obj->map = const_cast<JSObjectMap *>(ops->objectMap);
40858:     }
40858: 
40858:     /*
40858:      * Do not call debug hooks on trace, because we might be in a non-_FAIL
40858:      * builtin. See bug 481444.
40858:      */
40858:     if (cx->debugHooks->objectHook && !JS_ON_TRACE(cx)) {
40858:         AutoValueRooter tvr(cx, obj);
40858:         AutoKeepAtoms keep(cx->runtime);
40858:         cx->debugHooks->objectHook(cx, obj, JS_TRUE,
40858:                                    cx->debugHooks->objectHookData);
40858:         cx->weakRoots.finalizableNewborns[FINALIZE_OBJECT] = obj;
40858:     }
40858: 
40858: out:
40858: #ifdef INCLUDE_MOZILLA_DTRACE
40858:     if (JAVASCRIPT_OBJECT_CREATE_ENABLED())
40858:         jsdtrace_object_create(cx, clasp, obj);
40858:     if (JAVASCRIPT_OBJECT_CREATE_DONE_ENABLED())
40858:         jsdtrace_object_create_done(cx->fp, clasp);
40858: #endif
40858:     return obj;
40858: }
40858: 
40858: static inline JSProtoKey
40858: GetClassProtoKey(JSClass *clasp)
40858: {
40858:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
40858:     if (key != JSProto_Null)
40858:         return key;
40858:     if (clasp->flags & JSCLASS_IS_ANONYMOUS)
40858:         return JSProto_Object;
40858:     return JSProto_Null;
40858: }
40858: 
40858: static inline JSObject *
40858: NewObject(JSContext *cx, JSClass *clasp, JSObject *proto,
40858:           JSObject *parent, size_t objectSize = 0)
40858: {
40858:     /* Bootstrap the ur-object, and make it the default prototype object. */
40858:     if (!proto) {
40858:         JSProtoKey protoKey = GetClassProtoKey(clasp);
40858:         if (!js_GetClassPrototype(cx, parent, protoKey, &proto, clasp))
40858:             return NULL;
40858:         if (!proto &&
40858:             !js_GetClassPrototype(cx, parent, JSProto_Object, &proto)) {
40858:             return NULL;
40858:         }
40858:     }
40858: 
40858:     return NewObjectWithGivenProto(cx, clasp, proto, parent, objectSize);
40858: }
40858: 
40388: }
40388: 
35117: #endif /* jsobjinlines_h___ */
