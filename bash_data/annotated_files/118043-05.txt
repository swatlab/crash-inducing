 37880: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 33649: /* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 33649: 
 33649: /*
 33649:  * Code to notify things that animate before a refresh, at an appropriate
 33649:  * refresh rate.  (Perhaps temporary, until replaced by compositor.)
 33649:  */
 33649: 
 80467: #include "mozilla/Util.h"
 80467: 
 33649: #include "nsRefreshDriver.h"
 33649: #include "nsPresContext.h"
 33649: #include "nsComponentManagerUtils.h"
 33649: #include "prlog.h"
 36617: #include "nsAutoPtr.h"
 50365: #include "nsCSSFrameConstructor.h"
 50368: #include "nsIDocument.h"
 50368: #include "nsGUIEvent.h"
 50368: #include "nsEventDispatcher.h"
 50368: #include "jsapi.h"
 51267: #include "nsContentUtils.h"
 70842: #include "mozilla/Preferences.h"
 87344: #include "nsIViewManager.h"
107400: #include "sampler.h"
118043: #include "nsNPAPIPluginInstance.h"
 33649: 
 70842: using namespace mozilla;
 70842: 
 51267: #define DEFAULT_FRAME_RATE 60
 51546: #define DEFAULT_THROTTLED_FRAME_RATE 1
 33649: 
116501: static bool sPrecisePref;
 63688: 
 63688: /* static */ void
 63688: nsRefreshDriver::InitializeStatics()
 63688: {
116501:   Preferences::AddBoolVarCache(&sPrecisePref,
116501:                                "layout.frame_rate.precise",
116501:                                false);
 63688: }
 87356: 
108991: /* static */ int32_t
 87356: nsRefreshDriver::DefaultInterval()
 87356: {
 87356:   return NSToIntRound(1000.0 / DEFAULT_FRAME_RATE);
 87356: }
 87356: 
 51267: // Compute the interval to use for the refresh driver timer, in
 51267: // milliseconds
116501: int32_t
116501: nsRefreshDriver::GetRefreshTimerInterval() const
116267: {
116501:   const char* prefName =
116501:     mThrottled ? "layout.throttled_frame_rate" : "layout.frame_rate";
116501:   int32_t rate = Preferences::GetInt(prefName, -1);
116267:   if (rate <= 0) {
116267:     // TODO: get the rate from the platform
116501:     rate = mThrottled ? DEFAULT_THROTTLED_FRAME_RATE : DEFAULT_FRAME_RATE;
116267:   }
116501:   NS_ASSERTION(rate > 0, "Must have positive rate here");
116501:   int32_t interval = NSToIntRound(1000.0/rate);
116501:   if (mThrottled) {
116501:     interval = NS_MAX(interval, mLastTimerInterval * 2);
116501:   }
116501:   mLastTimerInterval = interval;
116501:   return interval;
116267: }
116267: 
116501: int32_t
116501: nsRefreshDriver::GetRefreshTimerType() const
 51267: {
 63574:   if (mThrottled) {
116501:     return nsITimer::TYPE_ONE_SHOT;
 63574:   }
116501:   if (HaveFrameRequestCallbacks() || sPrecisePref) {
116501:     return nsITimer::TYPE_REPEATING_PRECISE_CAN_SKIP;
116501:   }
116501:   return nsITimer::TYPE_REPEATING_SLACK;
 51267: }
 33649: 
 36615: nsRefreshDriver::nsRefreshDriver(nsPresContext *aPresContext)
 37880:   : mPresContext(aPresContext),
 51546:     mFrozen(false),
 63688:     mThrottled(false),
 67983:     mTestControllingRefreshes(false),
116501:     mTimerIsPrecise(false),
 87344:     mViewManagerFlushIsPending(false),
116501:     mLastTimerInterval(0)
 33649: {
 82097:   mRequests.Init();
 33649: }
 33649: 
 33649: nsRefreshDriver::~nsRefreshDriver()
 33649: {
 33649:   NS_ABORT_IF_FALSE(ObserverCount() == 0,
 33649:                     "observers should have unregistered");
116501:   NS_ABORT_IF_FALSE(!mTimer, "timer should be gone");
115319:   
115319:   for (uint32_t i = 0; i < mPresShellsToInvalidateIfHidden.Length(); i++) {
115319:     mPresShellsToInvalidateIfHidden[i]->InvalidatePresShellIfHidden();
115319:   }
115319:   mPresShellsToInvalidateIfHidden.Clear();
 33649: }
 33649: 
 67983: // Method for testing.  See nsIDOMWindowUtils.advanceTimeAndRefresh
 67983: // for description.
 67983: void
108991: nsRefreshDriver::AdvanceTimeAndRefresh(int64_t aMilliseconds)
 67983: {
 67983:   mTestControllingRefreshes = true;
 67983:   mMostRecentRefreshEpochTime += aMilliseconds * 1000;
116501:   mMostRecentRefresh += TimeDuration::FromMilliseconds(aMilliseconds);
 69357:   nsCxPusher pusher;
 69357:   if (pusher.PushNull()) {
116501:     Notify(nullptr);
 69357:     pusher.Pop();
 69357:   }
 67983: }
 67983: 
 67983: void
 67983: nsRefreshDriver::RestoreNormalRefresh()
 67983: {
 67983:   mTestControllingRefreshes = false;
116501:   nsCxPusher pusher;
116501:   if (pusher.PushNull()) {
116501:     Notify(nullptr); // will call UpdateMostRecentRefresh()
116501:     pusher.Pop();
116501:   }
 67983: }
 67983: 
 33649: TimeStamp
 33649: nsRefreshDriver::MostRecentRefresh() const
 33649: {
116501:   const_cast<nsRefreshDriver*>(this)->EnsureTimerStarted(false);
116501: 
 33649:   return mMostRecentRefresh;
 33649: }
 33649: 
108991: int64_t
 50368: nsRefreshDriver::MostRecentRefreshEpochTime() const
 50368: {
116501:   const_cast<nsRefreshDriver*>(this)->EnsureTimerStarted(false);
116501: 
 50368:   return mMostRecentRefreshEpochTime;
 50368: }
 50368: 
 79445: bool
 33649: nsRefreshDriver::AddRefreshObserver(nsARefreshObserver *aObserver,
 33649:                                     mozFlushType aFlushType)
 33649: {
 33649:   ObserverArray& array = ArrayFor(aFlushType);
106838:   bool success = array.AppendElement(aObserver) != nullptr;
 33649: 
 68771:   EnsureTimerStarted(false);
 33649: 
 33649:   return success;
 33649: }
 33649: 
 79445: bool
 33649: nsRefreshDriver::RemoveRefreshObserver(nsARefreshObserver *aObserver,
 33649:                                        mozFlushType aFlushType)
 33649: {
 33649:   ObserverArray& array = ArrayFor(aFlushType);
 36795:   return array.RemoveElement(aObserver);
 33649: }
 33649: 
 82097: bool
 82097: nsRefreshDriver::AddImageRequest(imgIRequest* aRequest)
 82097: {
 82097:   if (!mRequests.PutEntry(aRequest)) {
 82097:     return false;
 82097:   }
 82097: 
 82097:   EnsureTimerStarted(false);
 82097: 
 82097:   return true;
 82097: }
 82097: 
 82097: void
 82097: nsRefreshDriver::RemoveImageRequest(imgIRequest* aRequest)
 82097: {
 82097:   mRequests.RemoveEntry(aRequest);
 82097: }
 82097: 
 82097: void nsRefreshDriver::ClearAllImageRequests()
 82097: {
 82097:   mRequests.Clear();
 82097: }
 82097: 
 33649: void
 68771: nsRefreshDriver::EnsureTimerStarted(bool aAdjustingTimer)
 33649: {
116501:   if (mTimer || mFrozen || !mPresContext) {
116501:     // It's already been started, or we don't want to start it now or
116501:     // we've been disconnected.
 33649:     return;
 33649:   }
 33649: 
116501:   if (!aAdjustingTimer) {
116501:     // If we didn't already have a timer and aAdjustingTimer is false,
116501:     // then we just got our first observer (or an explicit call to
116501:     // MostRecentRefresh by a caller who's likely to add an observer
116501:     // shortly).  This means we should fake a most-recent-refresh time
116501:     // of now so that said observer gets a reasonable refresh time, so
116501:     // things behave as though the timer had always been running.
116501:     UpdateMostRecentRefresh();
116501:   }
 33649: 
116501:   mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
116501:   if (!mTimer) {
116501:     return;
116501:   }
116501: 
116501:   int32_t timerType = GetRefreshTimerType();
116501:   mTimerIsPrecise = (timerType == nsITimer::TYPE_REPEATING_PRECISE_CAN_SKIP);
116501: 
116501:   nsresult rv = mTimer->InitWithCallback(this,
116501:                                          GetRefreshTimerInterval(),
116501:                                          timerType);
116501:   if (NS_FAILED(rv)) {
116501:     mTimer = nullptr;
116501:   }
 33649: }
 33649: 
 33649: void
 33649: nsRefreshDriver::StopTimer()
 33649: {
116501:   if (!mTimer) {
 33649:     return;
 33649:   }
 33649: 
116501:   mTimer->Cancel();
116501:   mTimer = nullptr;
 33649: }
 33649: 
108991: uint32_t
 33649: nsRefreshDriver::ObserverCount() const
 33649: {
108991:   uint32_t sum = 0;
108991:   for (uint32_t i = 0; i < ArrayLength(mObservers); ++i) {
 33649:     sum += mObservers[i].Length();
 33649:   }
 82097: 
 51546:   // Even while throttled, we need to process layout and style changes.  Style
 51546:   // changes can trigger transitions which fire events when they complete, and
 51546:   // layout changes can affect media queries on child documents, triggering
 51546:   // style changes, etc.
 50365:   sum += mStyleFlushObservers.Length();
 50365:   sum += mLayoutFlushObservers.Length();
 82857:   sum += mFrameRequestCallbackDocs.Length();
 87344:   sum += mViewManagerFlushIsPending;
 33649:   return sum;
 33649: }
 33649: 
108991: uint32_t
 82097: nsRefreshDriver::ImageRequestCount() const
 82097: {
 82097:   return mRequests.Count();
 82097: }
 82097: 
116501: void
116501: nsRefreshDriver::UpdateMostRecentRefresh()
116501: {
116501:   if (mTestControllingRefreshes) {
116501:     return;
116501:   }
116501: 
116501:   // Call JS_Now first, since that can have nonzero latency in some rare cases.
116501:   mMostRecentRefreshEpochTime = JS_Now();
116501:   mMostRecentRefresh = TimeStamp::Now();
116501: }
116501: 
 33649: nsRefreshDriver::ObserverArray&
 33649: nsRefreshDriver::ArrayFor(mozFlushType aFlushType)
 33649: {
 33649:   switch (aFlushType) {
 33649:     case Flush_Style:
 33649:       return mObservers[0];
 33649:     case Flush_Layout:
 33649:       return mObservers[1];
 33649:     case Flush_Display:
 33649:       return mObservers[2];
 33649:     default:
 80486:       NS_ABORT_IF_FALSE(false, "bad flush type");
106838:       return *static_cast<ObserverArray*>(nullptr);
 33649:   }
 33649: }
 33649: 
 33649: /*
 33649:  * nsISupports implementation
 33649:  */
 33649: 
116501: NS_IMPL_ISUPPORTS1(nsRefreshDriver, nsITimerCallback)
 33649: 
 33649: /*
 33649:  * nsITimerCallback implementation
 33649:  */
 33649: 
116501: NS_IMETHODIMP
116501: nsRefreshDriver::Notify(nsITimer *aTimer)
 33649: {
116501:   SAMPLE_LABEL("nsRefreshDriver", "Notify");
116501: 
 37880:   NS_PRECONDITION(!mFrozen, "Why are we notified while frozen?");
 37880:   NS_PRECONDITION(mPresContext, "Why are we notified after disconnection?");
 69357:   NS_PRECONDITION(!nsContentUtils::GetCurrentJSContext(),
 69357:                   "Shouldn't have a JSContext on the stack");
118043:   if (nsNPAPIPluginInstance::InPluginCall()) {
118043:     NS_ERROR("Refresh driver should not run during plugin call!");
118043:     // Try to survive this by just ignoring the refresh tick.
118043:     return NS_OK;
118043:   }
 37880: 
116501:   if (mTestControllingRefreshes && aTimer) {
116501:     // Ignore real refreshes from our timer (but honor the others).
116501:     return NS_OK;
 67983:   }
 67983: 
116501:   UpdateMostRecentRefresh();
 33649: 
 36615:   nsCOMPtr<nsIPresShell> presShell = mPresContext->GetPresShell();
 82097:   if (!presShell || (ObserverCount() == 0 && ImageRequestCount() == 0)) {
 36795:     // Things are being destroyed, or we no longer have any observers.
 36795:     // We don't want to stop the timer when observers are initially
 36795:     // removed, because sometimes observers can be added and removed
 36795:     // often depending on what other things are going on and in that
 36795:     // situation we don't want to thrash our timer.  So instead we
 36795:     // wait until we get a Notify() call when we have no observers
 36795:     // before stopping the timer.
 33649:     StopTimer();
116501:     return NS_OK;
 33649:   }
 33649: 
 36617:   /*
 36617:    * The timer holds a reference to |this| while calling |Notify|.
 36617:    * However, implementations of |WillRefresh| are permitted to destroy
 36617:    * the pres context, which will cause our |mPresContext| to become
 36617:    * null.  If this happens, we must stop notifying observers.
 36617:    */
108991:   for (uint32_t i = 0; i < ArrayLength(mObservers); ++i) {
 33649:     ObserverArray::EndLimitedIterator etor(mObservers[i]);
 33649:     while (etor.HasMore()) {
 36617:       nsRefPtr<nsARefreshObserver> obs = etor.GetNext();
116501:       obs->WillRefresh(mMostRecentRefresh);
 36617:       
 36617:       if (!mPresContext || !mPresContext->GetPresShell()) {
 36617:         StopTimer();
116501:         return NS_OK;
 36617:       }
 33649:     }
 82097: 
 33649:     if (i == 0) {
 82859:       // Grab all of our frame request callbacks up front.
 82857:       nsIDocument::FrameRequestCallbackList frameRequestCallbacks;
108991:       for (uint32_t i = 0; i < mFrameRequestCallbackDocs.Length(); ++i) {
 82857:         mFrameRequestCallbackDocs[i]->
 82857:           TakeFrameRequestCallbacks(frameRequestCallbacks);
 52255:       }
 82857:       // OK, now reset mFrameRequestCallbackDocs so they can be
 52255:       // readded as needed.
 82857:       mFrameRequestCallbackDocs.Clear();
 52255: 
116501:       int64_t eventTime = mMostRecentRefreshEpochTime / PR_USEC_PER_MSEC;
108991:       for (uint32_t i = 0; i < frameRequestCallbacks.Length(); ++i) {
 94465:         nsAutoMicroTask mt;
 82857:         frameRequestCallbacks[i]->Sample(eventTime);
 52255:       }
 52255: 
 33649:       // This is the Flush_Style case.
 60882:       if (mPresContext && mPresContext->GetPresShell()) {
 60882:         nsAutoTArray<nsIPresShell*, 16> observers;
 60882:         observers.AppendElements(mStyleFlushObservers);
108991:         for (uint32_t j = observers.Length();
 60882:              j && mPresContext && mPresContext->GetPresShell(); --j) {
 60882:           // Make sure to not process observers which might have been removed
 60882:           // during previous iterations.
 60882:           nsIPresShell* shell = observers[j - 1];
 60882:           if (!mStyleFlushObservers.Contains(shell))
 60882:             continue;
 60882:           NS_ADDREF(shell);
 60882:           mStyleFlushObservers.RemoveElement(shell);
 80486:           shell->FrameConstructor()->mObservingRefreshDriver = false;
 50365:           shell->FlushPendingNotifications(Flush_Style);
 60882:           NS_RELEASE(shell);
 60882:         }
 50365:       }
 38310:     } else if  (i == 1) {
 38310:       // This is the Flush_Layout case.
 60882:       if (mPresContext && mPresContext->GetPresShell()) {
 60882:         nsAutoTArray<nsIPresShell*, 16> observers;
 60882:         observers.AppendElements(mLayoutFlushObservers);
108991:         for (uint32_t j = observers.Length();
 60882:              j && mPresContext && mPresContext->GetPresShell(); --j) {
 60882:           // Make sure to not process observers which might have been removed
 60882:           // during previous iterations.
 60882:           nsIPresShell* shell = observers[j - 1];
 60882:           if (!mLayoutFlushObservers.Contains(shell))
 60882:             continue;
 60882:           NS_ADDREF(shell);
 60882:           mLayoutFlushObservers.RemoveElement(shell);
 80486:           shell->mReflowScheduled = false;
 80486:           shell->mSuppressInterruptibleReflows = false;
 50365:           shell->FlushPendingNotifications(Flush_InterruptibleLayout);
 60882:           NS_RELEASE(shell);
 60882:         }
 50365:       }
 33649:     }
 33649:   }
 33649: 
 82097:   /*
 82097:    * Perform notification to imgIRequests subscribed to listen
 82097:    * for refresh events.
 82097:    */
 82097: 
116501:   ImageRequestParameters parms = {mMostRecentRefresh};
 82097:   if (mRequests.Count()) {
 82097:     mRequests.EnumerateEntries(nsRefreshDriver::ImageRequestEnumerator, &parms);
116501:     EnsureTimerStarted(false);
 82097:   }
 82097:     
115319:   for (uint32_t i = 0; i < mPresShellsToInvalidateIfHidden.Length(); i++) {
115319:     mPresShellsToInvalidateIfHidden[i]->InvalidatePresShellIfHidden();
115319:   }
115319:   mPresShellsToInvalidateIfHidden.Clear();
115319: 
 87344:   if (mViewManagerFlushIsPending) {
108188: #ifdef DEBUG_INVALIDATIONS
108188:     printf("Starting ProcessPendingUpdates\n");
108188: #endif
 87344:     mViewManagerFlushIsPending = false;
116861:     nsCOMPtr<nsIViewManager> vm = mPresContext->GetPresShell()->GetViewManager();
116861:     vm->ProcessPendingUpdates();
108188: #ifdef DEBUG_INVALIDATIONS
108188:     printf("Ending ProcessPendingUpdates\n");
108188: #endif
 87344:   }
116501: 
116501:   if (mThrottled ||
116501:       (mTimerIsPrecise !=
116501:        (GetRefreshTimerType() == nsITimer::TYPE_REPEATING_PRECISE_CAN_SKIP))) {
116501:     // Stop the timer now and restart it here.  Stopping is in the mThrottled
116501:     // case ok because either it's already one-shot, and it just fired, and all
116501:     // we need to do is null it out, or it's repeating and we need to reset it
116501:     // to be one-shot.  Stopping and restarting in the case when we need to
116501:     // switch from precise to slack timers or vice versa is unfortunately
116501:     // required.
116501: 
116501:     // Note that the EnsureTimerStarted() call here is ok because
116501:     // EnsureTimerStarted makes sure to not start the timer if it shouldn't be
116501:     // started.
116501:     StopTimer();
116501:     EnsureTimerStarted(true);
116501:   }
116501: 
116501:   return NS_OK;
 33649: }
 37880: 
 82097: PLDHashOperator
 82097: nsRefreshDriver::ImageRequestEnumerator(nsISupportsHashKey* aEntry,
 82097:                                         void* aUserArg)
 82097: {
 82097:   ImageRequestParameters* parms =
 82097:     static_cast<ImageRequestParameters*> (aUserArg);
 82097:   mozilla::TimeStamp mostRecentRefresh = parms->ts;
 82097:   imgIRequest* req = static_cast<imgIRequest*>(aEntry->GetKey());
 82097:   NS_ABORT_IF_FALSE(req, "Unable to retrieve the image request");
 82097:   nsCOMPtr<imgIContainer> image;
 82097:   req->GetImage(getter_AddRefs(image));
 82097:   if (image) {
 82097:     image->RequestRefresh(mostRecentRefresh);
 82097:   }
 82097: 
 82097:   return PL_DHASH_NEXT;
 82097: }
 82097: 
 37880: void
 37880: nsRefreshDriver::Freeze()
 37880: {
 37880:   NS_ASSERTION(!mFrozen, "Freeze called on already-frozen refresh driver");
 37880:   StopTimer();
 51546:   mFrozen = true;
 37880: }
 37880: 
 37880: void
 37880: nsRefreshDriver::Thaw()
 37880: {
 37880:   NS_ASSERTION(mFrozen, "Thaw called on an unfrozen refresh driver");
 51546:   mFrozen = false;
 82097:   if (ObserverCount() || ImageRequestCount()) {
 68771:     // FIXME: This isn't quite right, since our EnsureTimerStarted call
 68771:     // updates our mMostRecentRefresh, but the DoRefresh call won't run
 68771:     // and notify our observers until we get back to the event loop.
 68771:     // Thus MostRecentRefresh() will lie between now and the DoRefresh.
 41361:     NS_DispatchToCurrentThread(NS_NewRunnableMethod(this, &nsRefreshDriver::DoRefresh));
 68771:     EnsureTimerStarted(false);
 37880:   }
 37880: }
 37880: 
 37880: void
 51546: nsRefreshDriver::SetThrottled(bool aThrottled)
 51546: {
 51546:   if (aThrottled != mThrottled) {
 51546:     mThrottled = aThrottled;
116501:     if (mTimer) {
 63574:       // We want to switch our timer type here, so just stop and
 63574:       // restart the timer.
116501:       StopTimer();
 68771:       EnsureTimerStarted(true);
 51546:     }
 51546:   }
 51546: }
 51546: 
 51546: void
 37880: nsRefreshDriver::DoRefresh()
 37880: {
 37880:   // Don't do a refresh unless we're in a state where we should be refreshing.
116501:   if (!mFrozen && mPresContext && mTimer) {
116501:     Notify(nullptr);
 37880:   }
 37880: }
 38310: 
 38310: #ifdef DEBUG
 79445: bool
 38310: nsRefreshDriver::IsRefreshObserver(nsARefreshObserver *aObserver,
 38310:                                    mozFlushType aFlushType)
 38310: {
 38310:   ObserverArray& array = ArrayFor(aFlushType);
 38310:   return array.Contains(aObserver);
 38310: }
 38310: #endif
 50368: 
 50368: void
114466: nsRefreshDriver::ScheduleViewManagerFlush()
114466: {
114466:   NS_ASSERTION(mPresContext->IsRoot(),
114466:                "Should only schedule view manager flush on root prescontexts");
114466:   mViewManagerFlushIsPending = true;
114466:   EnsureTimerStarted(false);
114466: }
114466: 
114466: void
 82857: nsRefreshDriver::ScheduleFrameRequestCallbacks(nsIDocument* aDocument)
 52255: {
 82857:   NS_ASSERTION(mFrameRequestCallbackDocs.IndexOf(aDocument) ==
 82857:                mFrameRequestCallbackDocs.NoIndex,
 52255:                "Don't schedule the same document multiple times");
 82857:   mFrameRequestCallbackDocs.AppendElement(aDocument);
116501:   // No need to worry about restarting our timer in precise mode if it's
116501:   // already running; that will happen automatically when it fires.
 68771:   EnsureTimerStarted(false);
 52255: }
 52255: 
 52255: void
 82857: nsRefreshDriver::RevokeFrameRequestCallbacks(nsIDocument* aDocument)
 52255: {
 82857:   mFrameRequestCallbackDocs.RemoveElement(aDocument);
 63688:   // No need to worry about restarting our timer in slack mode if it's already
 63688:   // running; that will happen automatically when it fires.
 52255: }
