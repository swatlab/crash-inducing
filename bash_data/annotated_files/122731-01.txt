113476: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
113476:  * vim: set ts=4 sw=4 et tw=99:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS math package.
     1:  */
 95341: 
107566: #include "mozilla/Constants.h"
 95341: #include "mozilla/FloatingPoint.h"
 95341: 
     1: #include <stdlib.h>
     1: #include "jstypes.h"
     1: #include "prmjtime.h"
     1: #include "jsapi.h"
     1: #include "jsatom.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jslock.h"
     1: #include "jsmath.h"
     1: #include "jsnum.h"
 30269: #include "jslibmath.h"
 59735: #include "jscompartment.h"
     1: 
 77343: #include "jsinferinlines.h"
 77343: #include "jsobjinlines.h"
 77343: 
 40828: using namespace js;
 40828: 
     1: #ifndef M_E
     1: #define M_E             2.7182818284590452354
     1: #endif
     1: #ifndef M_LOG2E
     1: #define M_LOG2E         1.4426950408889634074
     1: #endif
     1: #ifndef M_LOG10E
     1: #define M_LOG10E        0.43429448190325182765
     1: #endif
     1: #ifndef M_LN2
     1: #define M_LN2           0.69314718055994530942
     1: #endif
     1: #ifndef M_LN10
     1: #define M_LN10          2.30258509299404568402
     1: #endif
     1: #ifndef M_SQRT2
     1: #define M_SQRT2         1.41421356237309504880
     1: #endif
     1: #ifndef M_SQRT1_2
     1: #define M_SQRT1_2       0.70710678118654752440
     1: #endif
     1: 
     1: static JSConstDoubleSpec math_constants[] = {
     1:     {M_E,       "E",            0, {0,0,0}},
     1:     {M_LOG2E,   "LOG2E",        0, {0,0,0}},
     1:     {M_LOG10E,  "LOG10E",       0, {0,0,0}},
     1:     {M_LN2,     "LN2",          0, {0,0,0}},
     1:     {M_LN10,    "LN10",         0, {0,0,0}},
     1:     {M_PI,      "PI",           0, {0,0,0}},
     1:     {M_SQRT2,   "SQRT2",        0, {0,0,0}},
     1:     {M_SQRT1_2, "SQRT1_2",      0, {0,0,0}},
     1:     {0,0,0,{0,0,0}}
     1: };
     1: 
 55569: MathCache::MathCache() {
 55569:     memset(table, 0, sizeof(table));
 55569: 
 55569:     /* See comments in lookup(). */
 95341:     JS_ASSERT(MOZ_DOUBLE_IS_NEGATIVE_ZERO(-0.0));
 95341:     JS_ASSERT(!MOZ_DOUBLE_IS_NEGATIVE_ZERO(+0.0));
 55569:     JS_ASSERT(hash(-0.0) != hash(+0.0));
 55569: }
 55569: 
 98702: size_t
 98702: MathCache::sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf)
 98702: {
 98702:     return mallocSizeOf(this);
 98702: }
 98702: 
 77817: Class js::MathClass = {
     1:     js_Math_str,
     1:     JSCLASS_HAS_CACHED_PROTO(JSProto_Math),
 78614:     JS_PropertyStub,         /* addProperty */
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 78614:     JS_ConvertStub
     1: };
     1: 
 56725: JSBool
 91237: js_math_abs(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 20766:     z = fabs(x);
 48470:     vp->setNumber(z);
 48470:     return JS_TRUE;
     1: }
     1: 
     1: static JSBool
 91237: math_acos(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 20765: #if defined(SOLARIS) && defined(__GNUC__)
 14815:     if (x < -1 || 1 < x) {
 48470:         vp->setDouble(js_NaN);
 14815:         return JS_TRUE;
 14815:     }
 14815: #endif
 97464:     MathCache *mathCache = cx->runtime->getMathCache(cx);
 55569:     if (!mathCache)
 55569:         return JS_FALSE;
 55569:     z = mathCache->lookup(acos, x);
 48470:     vp->setDouble(z);
 48470:     return JS_TRUE;
     1: }
     1: 
     1: static JSBool
 91237: math_asin(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 20765: #if defined(SOLARIS) && defined(__GNUC__)
 14815:     if (x < -1 || 1 < x) {
 48470:         vp->setDouble(js_NaN);
 14815:         return JS_TRUE;
 14815:     }
 14815: #endif
 97464:     MathCache *mathCache = cx->runtime->getMathCache(cx);
 55569:     if (!mathCache)
 55569:         return JS_FALSE;
 55569:     z = mathCache->lookup(asin, x);
 48470:     vp->setDouble(z);
 48470:     return JS_TRUE;
     1: }
     1: 
     1: static JSBool
 91237: math_atan(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 97464:     MathCache *mathCache = cx->runtime->getMathCache(cx);
 55569:     if (!mathCache)
 55569:         return JS_FALSE;
 55569:     z = mathCache->lookup(atan, x);
 48470:     vp->setDouble(z);
 48470:     return JS_TRUE;
     1: }
     1: 
 90955: static inline double JS_FASTCALL
 90955: math_atan2_kernel(double x, double y)
 22619: {
 22619: #if defined(_MSC_VER)
 22619:     /*
 22619:      * MSVC's atan2 does not yield the result demanded by ECMA when both x
 22619:      * and y are infinite.
 22619:      * - The result is a multiple of pi/4.
 22619:      * - The sign of x determines the sign of the result.
 22619:      * - The sign of y determines the multiplicator, 1 or 3.
 22619:      */
 95341:     if (MOZ_DOUBLE_IS_INFINITE(x) && MOZ_DOUBLE_IS_INFINITE(y)) {
 90955:         double z = js_copysign(M_PI / 4, x);
 22619:         if (y < 0)
 22619:             z *= 3;
 22619:         return z;
 22619:     }
 22619: #endif
 22619: 
 22619: #if defined(SOLARIS) && defined(__GNUC__)
 22619:     if (x == 0) {
 95341:         if (MOZ_DOUBLE_IS_NEGZERO(y))
 22619:             return js_copysign(M_PI, x);
 22619:         if (y == 0)
 22619:             return x;
 22619:     }
 22619: #endif
 22619:     return atan2(x, y);
 22619: }
 22619: 
     1: static JSBool
 91237: math_atan2(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, y, z;
     1: 
 16519:     if (argc <= 1) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x) || !ToNumber(cx, vp[3], &y))
     1:         return JS_FALSE;
 48470:     z = math_atan2_kernel(x, y);
 48470:     vp->setDouble(z);
 48470:     return JS_TRUE;
     1: }
     1: 
 90955: double
 90955: js_math_ceil_impl(double x)
 23083: {
 23088: #ifdef __APPLE__
 23083:     if (x < 0 && x > -1.0)
 23083:         return js_copysign(0, -1);
 23083: #endif
 23083:     return ceil(x);
 23083: }
 23083: 
 31900: JSBool
 91237: js_math_ceil(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 56184:     z = js_math_ceil_impl(x);
 48470:     vp->setNumber(z);
 48470:     return JS_TRUE;
     1: }
     1: 
113194: double
113194: js::math_cos_impl(MathCache *cache, double x)
113194: {
113194:     return cache->lookup(cos, x);
113194: }
113194: 
113194: JSBool
113194: js::math_cos(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 97464:     MathCache *mathCache = cx->runtime->getMathCache(cx);
 55569:     if (!mathCache)
 55569:         return JS_FALSE;
113194:     z = math_cos_impl(mathCache, x);
 48470:     vp->setDouble(z);
 48470:     return JS_TRUE;
     1: }
     1: 
 55569: static double
 55569: math_exp_body(double d)
 55569: {
 55569: #ifdef _WIN32
 95341:     if (!MOZ_DOUBLE_IS_NaN(d)) {
 55569:         if (d == js_PositiveInfinity)
 55569:             return js_PositiveInfinity;
 55569:         if (d == js_NegativeInfinity)
 55569:             return 0.0;
 55569:     }
 55569: #endif
 55569:     return exp(d);
 55569: }
 55569: 
     1: static JSBool
 91237: math_exp(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 97464:     MathCache *mathCache = cx->runtime->getMathCache(cx);
 55569:     if (!mathCache)
 55569:         return JS_FALSE;
 55569:     z = mathCache->lookup(math_exp_body, x);
 48470:     vp->setNumber(z);
 48470:     return JS_TRUE;
     1: }
     1: 
 90955: double
 90955: js_math_floor_impl(double x)
 56184: {
 56184:     return floor(x);
 56184: }
 56184: 
 31900: JSBool
 91237: js_math_floor(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 56184:     z = js_math_floor_impl(x);
 48470:     vp->setNumber(z);
 48470:     return JS_TRUE;
     1: }
     1: 
113194: double
113194: js::math_log_impl(MathCache *cache, double x)
113194: {
113194: #if defined(SOLARIS) && defined(__GNUC__)
113194:     if (x < 0)
113194:         return js_NaN;
113194: #endif
113194:     return cache->lookup(log, x);
113194: }
113194: 
113194: JSBool
113194: js::math_log(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 97464:     MathCache *mathCache = cx->runtime->getMathCache(cx);
 55569:     if (!mathCache)
 55569:         return JS_FALSE;
113194:     z = math_log_impl(mathCache, x);
 48470:     vp->setNumber(z);
 48470:     return JS_TRUE;
     1: }
     1: 
 31900: JSBool
 91237: js_math_max(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z = js_NegativeInfinity;
 48470:     Value *argv;
 91237:     unsigned i;
     1: 
     1:     if (argc == 0) {
 48470:         vp->setDouble(js_NegativeInfinity);
     1:         return JS_TRUE;
     1:     }
  4127:     argv = vp + 2;
     1:     for (i = 0; i < argc; i++) {
 73894:         if (!ToNumber(cx, argv[i], &x))
     1:             return JS_FALSE;
 95341:         if (MOZ_DOUBLE_IS_NaN(x)) {
 48470:             vp->setDouble(js_NaN);
     1:             return JS_TRUE;
     1:         }
 20893:         if (x == 0 && x == z) {
 20962:             if (js_copysign(1.0, z) == -1)
     1:                 z = x;
 20893:         } else {
     1:             z = (x > z) ? x : z;
     1:         }
 20893:     }
 48470:     vp->setNumber(z);
 48470:     return JS_TRUE;
     1: }
     1: 
 31900: JSBool
 91237: js_math_min(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z = js_PositiveInfinity;
 48470:     Value *argv;
 91237:     unsigned i;
     1: 
     1:     if (argc == 0) {
 48470:         vp->setDouble(js_PositiveInfinity);
     1:         return JS_TRUE;
     1:     }
  4127:     argv = vp + 2;
     1:     for (i = 0; i < argc; i++) {
 73894:         if (!ToNumber(cx, argv[i], &x))
     1:             return JS_FALSE;
 95341:         if (MOZ_DOUBLE_IS_NaN(x)) {
 48470:             vp->setDouble(js_NaN);
     1:             return JS_TRUE;
     1:         }
 20893:         if (x == 0 && x == z) {
 20962:             if (js_copysign(1.0, x) == -1)
     1:                 z = x;
 20916:         } else {
     1:             z = (x < z) ? x : z;
     1:         }
 20916:     }
 48470:     vp->setNumber(z);
 48470:     return JS_TRUE;
     1: }
     1: 
122731: // Disable PGO for Math.pow() and related functions (see bug 791214).
122731: #if defined(_MSC_VER)
122731: # pragma optimize("g", off)
122731: #endif
113476: double
113476: js::powi(double x, int y)
 51119: {
 91612:     unsigned n = (y < 0) ? -y : y;
 90955:     double m = x;
 90955:     double p = 1;
 51119:     while (true) {
 51119:         if ((n & 1) != 0) p *= m;
 51119:         n >>= 1;
 51119:         if (n == 0) {
 51119:             if (y < 0) {
 51119:                 // Unfortunately, we have to be careful when p has reached
 51119:                 // infinity in the computation, because sometimes the higher
 51119:                 // internal precision in the pow() implementation would have
 51119:                 // given us a finite p. This happens very rarely.
 51119: 
 90955:                 double result = 1.0 / p;
 95341:                 return (result == 0 && MOZ_DOUBLE_IS_INFINITE(p))
 90955:                        ? pow(x, static_cast<double>(y))  // Avoid pow(double, int).
 51119:                        : result;
 51119:             }
 51119: 
 51119:             return p;
 51119:         }
 51119:         m *= m;
 51119:     }
 51119: }
122731: #if defined(_MSC_VER)
122731: # pragma optimize("", on)
122731: #endif
 51119: 
122731: // Disable PGO for Math.pow() and related functions (see bug 791214).
122731: #if defined(_MSC_VER)
122731: # pragma optimize("g", off)
122731: #endif
113476: double
113476: js::ecmaPow(double x, double y)
113476: {
113476:     /*
113476:      * Because C99 and ECMA specify different behavior for pow(),
113476:      * we need to wrap the libm call to make it ECMA compliant.
113476:      */
113476:     if (!MOZ_DOUBLE_IS_FINITE(y) && (x == 1.0 || x == -1.0))
113476:         return js_NaN;
113476:     return pow(x, y);
113476: }
122731: #if defined(_MSC_VER)
122731: # pragma optimize("", on)
122731: #endif
113476: 
122731: // Disable PGO for Math.pow() and related functions (see bug 791214).
122731: #if defined(_MSC_VER)
122731: # pragma optimize("g", off)
122731: #endif
 77343: JSBool
 91237: js_math_pow(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, y, z;
     1: 
 16519:     if (argc <= 1) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x) || !ToNumber(cx, vp[3], &y))
     1:         return JS_FALSE;
     1:     /*
 51119:      * Special case for square roots. Note that pow(x, 0.5) != sqrt(x)
 51119:      * when x = -0.0, so we have to guard for this.
 51119:      */
 95341:     if (MOZ_DOUBLE_IS_FINITE(x) && x != 0.0) {
 51119:         if (y == 0.5) {
 51119:             vp->setNumber(sqrt(x));
 51119:             return JS_TRUE;
 51119:         }
 51119:         if (y == -0.5) {
 51119:             vp->setNumber(1.0/sqrt(x));
 51119:             return JS_TRUE;
 51119:         }
 51119:     }
     1:     /* pow(x, +-0) is always 1, even for x = NaN. */
     1:     if (y == 0) {
 48470:         vp->setInt32(1);
     1:         return JS_TRUE;
     1:     }
 51119: 
105914:     /*
105914:      * Use powi if the exponent is an integer or an integer-valued double.
105914:      * We don't have to check for NaN since a comparison with NaN is always
105914:      * false.
105914:      */
105914:     if (int32_t(y) == y)
105914:         z = powi(x, int32_t(y));
 51119:     else
113476:         z = ecmaPow(x, y);
 51119: 
 48470:     vp->setNumber(z);
 48470:     return JS_TRUE;
     1: }
122731: #if defined(_MSC_VER)
122731: # pragma optimize("", on)
122731: #endif
     1: 
 84755: static const int64_t RNG_MULTIPLIER = 0x5DEECE66DLL;
 84755: static const int64_t RNG_ADDEND = 0xBLL;
 84755: static const int64_t RNG_MASK = (1LL << 48) - 1;
 90955: static const double RNG_DSCALE = double(1LL << 53);
 31898: 
     1: /*
     1:  * Math.random() support, lifted from java.util.Random.java.
     1:  */
 90106: extern void
 90106: random_setSeed(int64_t *rngSeed, int64_t seed)
     1: {
 90106:     *rngSeed = (seed ^ RNG_MULTIPLIER) & RNG_MASK;
     1: }
     1: 
 17896: void
 40306: js_InitRandom(JSContext *cx)
     1: {
 40306:     /*
 40306:      * Set the seed from current time. Since we have a RNG per context and we often bring
 40306:      * up several contexts at the same time, we xor in some additional values, namely
 40306:      * the context and its successor. We don't just use the context because it might be
 40306:      * possible to reverse engineer the context pointer if one guesses the time right.
 40306:      */
120888:     random_setSeed(&cx->rngSeed, (PRMJ_Now() / 1000) ^ int64_t(cx) ^ int64_t(cx->getNext()));
     1: }
     1: 
 90106: extern uint64_t
 90106: random_next(int64_t *rngSeed, int bits)
     1: {
 90106:     uint64_t nextseed = *rngSeed * RNG_MULTIPLIER;
 31898:     nextseed += RNG_ADDEND;
 31898:     nextseed &= RNG_MASK;
 90106:     *rngSeed = nextseed;
 31898:     return nextseed >> (48 - bits);
     1: }
     1: 
 90955: static inline double
 40306: random_nextDouble(JSContext *cx)
     1: {
 90955:     return double((random_next(&cx->rngSeed, 26) << 27) + random_next(&cx->rngSeed, 27)) /
 90106:            RNG_DSCALE;
     1: }
     1: 
116303: double
116303: math_random_no_outparam(JSContext *cx)
116303: {
116303:     /* Calculate random without memory traffic, for use in the JITs. */
116303:     return random_nextDouble(cx);
116303: }
116303: 
116303: JSBool
116303: js_math_random(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double z = random_nextDouble(cx);
 48470:     vp->setDouble(z);
 48470:     return JS_TRUE;
     1: }
     1: 
 86431: JSBool /* ES5 15.8.2.15. */
 91237: js_math_round(JSContext *cx, unsigned argc, Value *vp)
 86171: {
 86431:     CallArgs args = CallArgsFromVp(argc, vp);
 86431: 
 86431:     if (args.length() == 0) {
 86431:         args.rval().setDouble(js_NaN);
 86431:         return true;
 86171:     }
 86171: 
 86431:     double x;
 86431:     if (!ToNumber(cx, args[0], &x))
 86431:         return false;
     1: 
 86431:     int32_t i;
 95341:     if (MOZ_DOUBLE_IS_INT32(x, &i)) {
 86431:         args.rval().setInt32(i);
 86431:         return true;
 16519:     }
 86431: 
 86431:     /* Some numbers are so big that adding 0.5 would give the wrong number */
 95341:     if (MOZ_DOUBLE_EXPONENT(x) >= 52) {
 86431:         args.rval().setNumber(x);
 86431:         return true;
 86431:     }
 86431: 
 86431:     args.rval().setNumber(js_copysign(floor(x + 0.5), x));
 86431:     return true;
     1: }
     1: 
113194: double
113194: js::math_sin_impl(MathCache *cache, double x)
113194: {
113194:     return cache->lookup(sin, x);
113194: }
113194: 
113194: JSBool
113194: js::math_sin(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 97464:     MathCache *mathCache = cx->runtime->getMathCache(cx);
 55569:     if (!mathCache)
 55569:         return JS_FALSE;
113194:     z = math_sin_impl(mathCache, x);
 48470:     vp->setDouble(z);
 48470:     return JS_TRUE;
     1: }
     1: 
 77343: JSBool
 91237: js_math_sqrt(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 97464:     MathCache *mathCache = cx->runtime->getMathCache(cx);
 55569:     if (!mathCache)
 55569:         return JS_FALSE;
 55569:     z = mathCache->lookup(sqrt, x);
 48470:     vp->setDouble(z);
 48470:     return JS_TRUE;
     1: }
     1: 
113194: double
113194: js::math_tan_impl(MathCache *cache, double x)
113194: {
113194:     return cache->lookup(tan, x);
113194: }
113194: 
113194: JSBool
113194: js::math_tan(JSContext *cx, unsigned argc, Value *vp)
     1: {
 90955:     double x, z;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 97464:     MathCache *mathCache = cx->runtime->getMathCache(cx);
 55569:     if (!mathCache)
 55569:         return JS_FALSE;
113194:     z = math_tan_impl(mathCache, x);
 48470:     vp->setDouble(z);
 48470:     return JS_TRUE;
     1: }
     1: 
     1: #if JS_HAS_TOSOURCE
     1: static JSBool
 91237: math_toSource(JSContext *cx, unsigned argc, Value *vp)
     1: {
114207:     vp->setString(cx->names().Math);
     1:     return JS_TRUE;
     1: }
     1: #endif
     1: 
     1: static JSFunctionSpec math_static_methods[] = {
     1: #if JS_HAS_TOSOURCE
 16519:     JS_FN(js_toSource_str,  math_toSource,        0, 0),
     1: #endif
 82643:     JS_FN("abs",            js_math_abs,          1, 0),
 82643:     JS_FN("acos",           math_acos,            1, 0),
 82643:     JS_FN("asin",           math_asin,            1, 0),
 82643:     JS_FN("atan",           math_atan,            1, 0),
 82643:     JS_FN("atan2",          math_atan2,           2, 0),
 82643:     JS_FN("ceil",           js_math_ceil,         1, 0),
 82643:     JS_FN("cos",            math_cos,             1, 0),
 82643:     JS_FN("exp",            math_exp,             1, 0),
 82643:     JS_FN("floor",          js_math_floor,        1, 0),
 82643:     JS_FN("log",            math_log,             1, 0),
 82643:     JS_FN("max",            js_math_max,          2, 0),
 82643:     JS_FN("min",            js_math_min,          2, 0),
 82643:     JS_FN("pow",            js_math_pow,          2, 0),
116303:     JS_FN("random",         js_math_random,       0, 0),
 82643:     JS_FN("round",          js_math_round,        1, 0),
 82643:     JS_FN("sin",            math_sin,             1, 0),
 82643:     JS_FN("sqrt",           js_math_sqrt,         1, 0),
 82643:     JS_FN("tan",            math_tan,             1, 0),
  4127:     JS_FS_END
     1: };
     1: 
     1: JSObject *
114748: js_InitMathClass(JSContext *cx, HandleObject obj)
     1: {
 99421:     RootedObject Math(cx, NewObjectWithClassProto(cx, &MathClass, NULL, obj));
108951:     if (!Math || !JSObject::setSingletonType(cx, Math))
 76206:         return NULL;
     1: 
 18266:     if (!JS_DefineProperty(cx, obj, js_Math_str, OBJECT_TO_JSVAL(Math),
 62395:                            JS_PropertyStub, JS_StrictPropertyStub, 0)) {
 18266:         return NULL;
 22628:     }
 18266: 
     1:     if (!JS_DefineFunctions(cx, Math, math_static_methods))
     1:         return NULL;
     1:     if (!JS_DefineConstDoubles(cx, Math, math_constants))
     1:         return NULL;
 69232: 
 77817:     MarkStandardClassInitializedNoProto(obj, &MathClass);
 69232: 
     1:     return Math;
     1: }
