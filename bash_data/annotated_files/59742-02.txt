57308: /* -*- mOde: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52873:  * vim: set ts=4 sw=4 et tw=99:
52873:  *
52873:  * ***** BEGIN LICENSE BLOCK *****
52873:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52873:  *
52873:  * The contents of this file are subject to the Mozilla Public License Version
52873:  * 1.1 (the "License"); you may not use this file except in compliance with
52873:  * the License. You may obtain a copy of the License at
52873:  * http://www.mozilla.org/MPL/
52873:  *
52873:  * Software distributed under the License is distributed on an "AS IS" basis,
52873:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52873:  * for the specific language governing rights and limitations under the
52873:  * License.
52873:  *
52873:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52873:  * May 28, 2008.
52873:  *
52873:  * The Initial Developer of the Original Code is
52873:  *   Brendan Eich <brendan@mozilla.org>
52873:  *
52873:  * Contributor(s):
52873:  *   David Anderson <danderson@mozilla.com>
52873:  *   David Mandelin <dmandelin@mozilla.com>
52873:  *
52873:  * Alternatively, the contents of this file may be used under the terms of
52873:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52873:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52873:  * in which case the provisions of the GPL or the LGPL are applicable instead
52873:  * of those above. If you wish to allow use of your version of this file only
52873:  * under the terms of either the GPL or the LGPL, and not to allow others to
52873:  * use your version of this file under the terms of the MPL, indicate your
52873:  * decision by deleting the provisions above and replace them with the notice
52873:  * and other provisions required by the GPL or the LGPL. If you do not delete
52873:  * the provisions above, a recipient may use your version of this file under
52873:  * the terms of any one of the MPL, the GPL or the LGPL.
52873:  *
52873:  * ***** END LICENSE BLOCK ***** */
52873: 
52873: #include "jscntxt.h"
52873: #include "jsscope.h"
52873: #include "jsobj.h"
52873: #include "jslibmath.h"
52873: #include "jsiter.h"
52873: #include "jsnum.h"
52873: #include "jsxml.h"
52873: #include "jsstaticcheck.h"
52873: #include "jsbool.h"
52873: #include "assembler/assembler/MacroAssemblerCodeRef.h"
53133: #include "assembler/assembler/CodeLocation.h"
52873: #include "jsiter.h"
52873: #include "jstypes.h"
52873: #include "methodjit/StubCalls.h"
52873: #include "jstracer.h"
52873: #include "jspropertycache.h"
53133: #include "methodjit/MonoIC.h"
56602: #include "jsanalyze.h"
58063: #include "methodjit/BaseCompiler.h"
53133: 
53840: #include "jsinterpinlines.h"
52873: #include "jspropertycacheinlines.h"
52873: #include "jsscopeinlines.h"
52873: #include "jsscriptinlines.h"
52873: #include "jsstrinlines.h"
52873: #include "jsobjinlines.h"
52873: #include "jscntxtinlines.h"
52873: #include "jsatominlines.h"
54832: #include "StubCalls-inl.h"
52873: 
52873: #include "jsautooplen.h"
52873: 
52873: using namespace js;
52873: using namespace js::mjit;
52873: using namespace JSC;
52873: 
52873: static jsbytecode *
52873: FindExceptionHandler(JSContext *cx)
52873: {
53482:     JSStackFrame *fp = cx->fp();
53840:     JSScript *script = fp->script();
52873: 
52873: top:
59221:     if (cx->throwing && JSScript::isValidOffset(script->trynotesOffset)) {
52873:         // The PC is updated before every stub call, so we can use it here.
52873:         unsigned offset = cx->regs->pc - script->main;
52873: 
52873:         JSTryNoteArray *tnarray = script->trynotes();
52873:         for (unsigned i = 0; i < tnarray->length; ++i) {
52873:             JSTryNote *tn = &tnarray->vector[i];
57782: 
53496:             // The following if condition actually tests two separate conditions:
53496:             //   (1) offset - tn->start >= tn->length
53496:             //       means the PC is not in the range of this try note, so we
53496:             //       should continue searching, after considering:
53496:             //   (2) offset - tn->start == tn->length
53496:             //       means the PC is at the first op of the exception handler
53496:             //       for this try note. This happens when an exception is thrown
53496:             //       during recording: the interpreter sets the PC to the handler
53496:             //       and then exits. In this case, we are in fact at the right
53496:             //       exception handler. 
53496:             //      
53496:             //       Hypothetically, the op we are at might have thrown an
53496:             //       exception, in which case this would not be the right handler.
53496:             //       But the first ops of exception handlers generated by our
53496:             //       bytecode compiler cannot throw, so this is not possible.
53496:             if (offset - tn->start > tn->length)
52873:                 continue;
52873:             if (tn->stackDepth > cx->regs->sp - fp->base())
52873:                 continue;
52873: 
52873:             jsbytecode *pc = script->main + tn->start + tn->length;
52873:             JSBool ok = js_UnwindScope(cx, tn->stackDepth, JS_TRUE);
52873:             JS_ASSERT(cx->regs->sp == fp->base() + tn->stackDepth);
52873: 
52873:             switch (tn->kind) {
52873:                 case JSTRY_CATCH:
53840:                   JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == JSOP_ENTERBLOCK);
52873: 
52873: #if JS_HAS_GENERATORS
52873:                   /* Catch cannot intercept the closing of a generator. */
52873:                   if (JS_UNLIKELY(cx->exception.isMagic(JS_GENERATOR_CLOSING)))
52873:                       break;
52873: #endif
52873: 
52873:                   /*
52873:                    * Don't clear cx->throwing to save cx->exception from GC
52873:                    * until it is pushed to the stack via [exception] in the
52873:                    * catch block.
52873:                    */
52873:                   return pc;
52873: 
52873:                 case JSTRY_FINALLY:
52873:                   /*
52873:                    * Push (true, exception) pair for finally to indicate that
52873:                    * [retsub] should rethrow the exception.
52873:                    */
52873:                   cx->regs->sp[0].setBoolean(true);
52873:                   cx->regs->sp[1] = cx->exception;
52873:                   cx->regs->sp += 2;
52873:                   cx->throwing = JS_FALSE;
52873:                   return pc;
52873: 
52873:                 case JSTRY_ITER:
52873:                 {
52873:                   /*
52873:                    * This is similar to JSOP_ENDITER in the interpreter loop,
52873:                    * except the code now uses the stack slot normally used by
52873:                    * JSOP_NEXTITER, namely regs.sp[-1] before the regs.sp -= 2
52873:                    * adjustment and regs.sp[1] after, to save and restore the
52873:                    * pending exception.
52873:                    */
52873:                   AutoValueRooter tvr(cx, cx->exception);
53840:                   JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == JSOP_ENDITER);
52873:                   cx->throwing = JS_FALSE;
53100:                   ok = !!js_CloseIterator(cx, &cx->regs->sp[-1].toObject());
52873:                   cx->regs->sp -= 1;
52873:                   if (!ok)
52873:                       goto top;
52873:                   cx->throwing = JS_TRUE;
52873:                   cx->exception = tvr.value();
52873:                 }
52873:             }
52873:         }
52873:     }
52873: 
52873:     return NULL;
52873: }
52873: 
54832: /*
54832:  * Clean up a frame and return.  popFrame indicates whether to additionally pop
54832:  * the frame and store the return value on the caller's stack.  The frame will
54832:  * normally be popped by the caller on return from a call into JIT code,
54832:  * so must be popped here when that caller code will not execute.  This can be
54832:  * either because of a call into an un-JITable script, or because the call is
54832:  * throwing an exception.
54832:  */
56201: static void
56201: InlineReturn(VMFrame &f)
53422: {
53590:     JSContext *cx = f.cx;
53590:     JSStackFrame *fp = f.regs.fp;
53590: 
57308:     JS_ASSERT(f.fp() != f.entryfp);
53590: 
53840:     JS_ASSERT(!js_IsActiveWithOrBlock(cx, &fp->scopeChain(), 0));
53590: 
53840:     Value *newsp = fp->actualArgs() - 1;
53840:     newsp[-1] = fp->returnValue();
53840:     cx->stack().popInlineFrame(cx, fp->prev(), newsp);
54832: }
53590: 
53590: void JS_FASTCALL
53590: stubs::SlowCall(VMFrame &f, uint32 argc)
53590: {
53590:     Value *vp = f.regs.sp - (argc + 2);
53590: 
53590:     if (!Invoke(f.cx, InvokeArgsAlreadyOnTheStack(vp, argc), 0))
53590:         THROW();
53590: }
53590: 
53590: void JS_FASTCALL
53590: stubs::SlowNew(VMFrame &f, uint32 argc)
53590: {
53590:     JSContext *cx = f.cx;
53590:     Value *vp = f.regs.sp - (argc + 2);
53590: 
53590:     if (!InvokeConstructor(cx, InvokeArgsAlreadyOnTheStack(vp, argc)))
53590:         THROW();
53590: }
53590: 
53840: /*
53840:  * This function must only be called after the early prologue, since it depends
53840:  * on fp->exec.fun.
53840:  */
53590: static inline void
53840: RemovePartialFrame(JSContext *cx, JSStackFrame *fp)
53590: {
53840:     JSStackFrame *prev = fp->prev();
53840:     Value *newsp = (Value *)fp;
53840:     cx->stack().popInlineFrame(cx, prev, newsp);
53590: }
53590: 
53840: /*
53840:  * HitStackQuota is called after the early prologue pushing the new frame would
53840:  * overflow f.stackLimit.
53840:  */
53590: void JS_FASTCALL
53840: stubs::HitStackQuota(VMFrame &f)
53590: {
53840:     /* Include space to push another frame. */
53840:     uintN nvals = f.fp()->script()->nslots + VALUES_PER_STACK_FRAME;
53840:     JS_ASSERT(f.regs.sp == f.fp()->base());
57308:     if (f.cx->stack().bumpCommitAndLimit(f.entryfp, f.regs.sp, nvals, &f.stackLimit))
53590:         return;
53590: 
53840:     /* Remove the current partially-constructed frame before throwing. */
53840:     RemovePartialFrame(f.cx, f.fp());
53590:     js_ReportOverRecursed(f.cx);
53590:     THROW();
53590: }
53590: 
53840: /*
53840:  * This function must only be called after the early prologue, since it depends
53840:  * on fp->exec.fun.
53840:  */
53590: void * JS_FASTCALL
53840: stubs::FixupArity(VMFrame &f, uint32 nactual)
53590: {
53590:     JSContext *cx = f.cx;
53840:     JSStackFrame *oldfp = f.fp();
53590: 
53840:     JS_ASSERT(nactual != oldfp->numFormalArgs());
53590: 
53590:     /*
53590:      * Grossssss! *move* the stack frame. If this ends up being perf-critical,
53840:      * we can figure out how to spot-optimize it. Be careful to touch only the
53840:      * members that have been initialized by initCallFrameCallerHalf and the
53840:      * early prologue.
53590:      */
53840:     uint32 flags         = oldfp->isConstructingFlag();
53840:     JSFunction *fun      = oldfp->fun();
53840:     void *ncode          = oldfp->nativeReturnAddress();
53590: 
53590:     /* Pop the inline frame. */
54832:     f.fp() = oldfp->prev();
54832:     f.regs.sp = (Value*) oldfp;
53590: 
53840:     /* Reserve enough space for a callee frame. */
54832:     JSStackFrame *newfp = cx->stack().getInlineFrameWithinLimit(cx, (Value*) oldfp, nactual,
53840:                                                                 fun, fun->script(), &flags,
57308:                                                                 f.entryfp, &f.stackLimit);
53840:     if (!newfp)
53840:         THROWV(NULL);
53590: 
53840:     /* Reset the part of the stack frame set by the caller. */
57715:     newfp->initCallFrameCallerHalf(cx, flags, ncode);
53590: 
53840:     /* Reset the part of the stack frame set by the prologue up to now. */
57715:     newfp->initCallFrameEarlyPrologue(fun, nactual);
53590: 
53840:     /* The caller takes care of assigning fp to regs. */
53590:     return newfp;
53590: }
53590: 
53590: void * JS_FASTCALL
53840: stubs::CompileFunction(VMFrame &f, uint32 nactual)
53590: {
53590:     /*
53590:      * We have a partially constructed frame. That's not really good enough to
53590:      * compile though because we could throw, so get a full, adjusted frame.
53590:      */
53590:     JSContext *cx = f.cx;
53590:     JSStackFrame *fp = f.fp();
53590: 
53840:     /*
53840:      * Since we can only use members set by initCallFrameCallerHalf,
53840:      * we must carefully extract the callee from the nactual.
53840:      */
53840:     JSObject &callee = fp->formalArgsEnd()[-(int(nactual) + 2)].toObject();
53840:     JSFunction *fun = callee.getFunctionPrivate();
53840:     JSScript *script = fun->script();
53590: 
53840:     /*
53840:      * FixupArity/RemovePartialFrame expect to be called after the early
54832:      * prologue. Pass the existing value for ncode, it has already been set
54832:      * by the jit code calling into this stub.
53840:      */
57715:     fp->initCallFrameEarlyPrologue(fun, nactual);
53590: 
53840:     if (nactual != fp->numFormalArgs()) {
53840:         fp = (JSStackFrame *)FixupArity(f, nactual);
53590:         if (!fp)
53590:             return NULL;
53590:     }
53590: 
53840:     /* Finish frame initialization. */
53840:     fp->initCallFrameLatePrologue();
53590: 
53840:     /* These would have been initialized by the prologue. */
53590:     f.regs.fp = fp;
53590:     f.regs.sp = fp->base();
53590:     f.regs.pc = script->code;
53590: 
53590:     if (fun->isHeavyweight() && !js_GetCallObject(cx, fp))
53590:         THROWV(NULL);
53590: 
55503:     CompileStatus status = CanMethodJIT(cx, script, fp);
53590:     if (status == Compile_Okay)
59220:         return script->getJIT(fp->isConstructing())->invokeEntry;
53590: 
53590:     /* Function did not compile... interpret it. */
53590:     JSBool ok = Interpret(cx, fp);
56201:     InlineReturn(f);
53590: 
53590:     if (!ok)
53590:         THROWV(NULL);
53590: 
53590:     return NULL;
53590: }
53590: 
53840: static inline bool
53840: UncachedInlineCall(VMFrame &f, uint32 flags, void **pret, uint32 argc)
52873: {
52873:     JSContext *cx = f.cx;
52873:     Value *vp = f.regs.sp - (argc + 2);
53840:     JSObject &callee = vp->toObject();
53840:     JSFunction *newfun = callee.getFunctionPrivate();
53840:     JSScript *newscript = newfun->script();
52873: 
53840:     /* Get pointer to new frame/slots, prepare arguments. */
53840:     StackSpace &stack = cx->stack();
53840:     JSStackFrame *newfp = stack.getInlineFrameWithinLimit(cx, f.regs.sp, argc,
53840:                                                           newfun, newscript, &flags,
57308:                                                           f.entryfp, &f.stackLimit);
53840:     if (JS_UNLIKELY(!newfp))
53840:         return false;
55503:     JS_ASSERT_IF(!vp[1].isPrimitive() && !(flags & JSFRAME_CONSTRUCTING),
55503:                  IsSaneThisObject(vp[1].toObject()));
52873: 
53840:     /* Initialize frame, locals. */
53840:     newfp->initCallFrame(cx, callee, newfun, argc, flags);
53840:     SetValueRangeToUndefined(newfp->slots(), newscript->nfixed);
52873: 
53840:     /* Officially push the frame. */
53840:     stack.pushInlineFrame(cx, newscript, newfp, &f.regs);
53840:     JS_ASSERT(newfp == f.regs.fp);
53840: 
53840:     /* Scope with a call object parented by callee's parent. */
53840:     if (newfun->isHeavyweight() && !js_GetCallObject(cx, newfp))
53840:         return false;
53840: 
53840:     /* Try to compile if not already compiled. */
55503:     if (newscript->getJITStatus(newfp->isConstructing()) == JITScript_None) {
55503:         if (mjit::TryCompile(cx, newfp) == Compile_Error) {
53840:             /* A runtime exception was thrown, get out. */
56201:             InlineReturn(f);
53840:             return false;
53840:         }
53840:     }
52873: 
53840:     /* If newscript was successfully compiled, run it. */
55503:     if (JITScript *jit = newscript->getJIT(newfp->isConstructing())) {
55503:         *pret = jit->invokeEntry;
52873:         return true;
52873:     }
52873: 
53840:     /* Otherwise, run newscript in the interpreter. */
53482:     bool ok = !!Interpret(cx, cx->fp());
56201:     InlineReturn(f);
52873: 
52873:     *pret = NULL;
52873:     return ok;
52873: }
52873: 
53590: void * JS_FASTCALL
53590: stubs::UncachedNew(VMFrame &f, uint32 argc)
53523: {
54163:     UncachedCallResult ucr;
54163:     UncachedNewHelper(f, argc, &ucr);
54163:     return ucr.codeAddr;
54163: }
54163: 
54163: void
54163: stubs::UncachedNewHelper(VMFrame &f, uint32 argc, UncachedCallResult *ucr)
54163: {
54163:     ucr->init();
54163: 
53523:     JSContext *cx = f.cx;
53590:     Value *vp = f.regs.sp - (argc + 2);
53523: 
53840:     /* Try to do a fast inline call before the general Invoke path. */
59220:     if (IsFunctionObject(*vp, &ucr->fun) && ucr->fun->isInterpreted()) {
54163:         ucr->callee = &vp->toObject();
54163:         if (!UncachedInlineCall(f, JSFRAME_CONSTRUCTING, &ucr->codeAddr, argc))
54163:             THROW();
54578:     } else {
53590:         if (!InvokeConstructor(cx, InvokeArgsAlreadyOnTheStack(vp, argc)))
54163:             THROW();
54578:     }
53523: }
53523: 
53522: void * JS_FASTCALL
53590: stubs::UncachedCall(VMFrame &f, uint32 argc)
53515: {
54163:     UncachedCallResult ucr;
54163:     UncachedCallHelper(f, argc, &ucr);
54163:     return ucr.codeAddr;
54163: }
54163: 
56775: void JS_FASTCALL
56775: stubs::Eval(VMFrame &f, uint32 argc)
56775: {
56775:     Value *vp = f.regs.sp - (argc + 2);
56775: 
56775:     JSObject *callee;
56775:     JSFunction *fun;
56775: 
56775:     if (!IsFunctionObject(*vp, &callee) ||
56775:         !IsBuiltinEvalFunction((fun = callee->getFunctionPrivate())))
56775:     {
57740:         if (!Invoke(f.cx, InvokeArgsAlreadyOnTheStack(vp, argc), 0))
56775:             THROW();
56775:         return;
56775:     }
56775: 
56775:     JS_ASSERT(f.regs.fp == f.cx->fp());
56775:     if (!DirectEval(f.cx, fun, argc, vp))
56775:         THROW();
56775: }
56775: 
54163: void
54163: stubs::UncachedCallHelper(VMFrame &f, uint32 argc, UncachedCallResult *ucr)
54163: {
54163:     ucr->init();
54163: 
53515:     JSContext *cx = f.cx;
52873:     Value *vp = f.regs.sp - (argc + 2);
52873: 
54163:     if (IsFunctionObject(*vp, &ucr->callee)) {
54163:         ucr->callee = &vp->toObject();
54163:         ucr->fun = GET_FUNCTION_PRIVATE(cx, ucr->callee);
52873: 
54163:         if (ucr->fun->isInterpreted()) {
54163:             if (!UncachedInlineCall(f, 0, &ucr->codeAddr, argc))
54163:                 THROW();
54163:             return;
52873:         }
52873: 
54163:         if (ucr->fun->isNative()) {
55479:             if (!CallJSNative(cx, ucr->fun->u.n.native, argc, vp))
54163:                 THROW();
54163:             return;
52873:         }
52873:     }
52873: 
53382:     if (!Invoke(f.cx, InvokeArgsAlreadyOnTheStack(vp, argc), 0))
54163:         THROW();
52873: 
54163:     return;
52873: }
52873: 
52873: void JS_FASTCALL
52873: stubs::PutCallObject(VMFrame &f)
52873: {
53482:     JS_ASSERT(f.fp()->hasCallObj());
53482:     js_PutCallObject(f.cx, f.fp());
52873: }
52873: 
52873: void JS_FASTCALL
53840: stubs::PutActivationObjects(VMFrame &f)
52873: {
53840:     JS_ASSERT(f.fp()->hasCallObj() || f.fp()->hasArgsObj());
53840:     js::PutActivationObjects(f.cx, f.fp());
52873: }
52873: 
52873: extern "C" void *
52873: js_InternalThrow(VMFrame &f)
52873: {
52873:     JSContext *cx = f.cx;
52873: 
52873:     // Make sure sp is up to date.
52873:     JS_ASSERT(cx->regs == &f.regs);
52873: 
53410:     // Call the throw hook if necessary
53410:     JSThrowHook handler = f.cx->debugHooks->throwHook;
53410:     if (handler) {
53410:         Value rval;
53840:         switch (handler(cx, cx->fp()->script(), cx->regs->pc, Jsvalify(&rval),
53410:                         cx->debugHooks->throwHookData)) {
53410:           case JSTRAP_ERROR:
53410:             cx->throwing = JS_FALSE;
53410:             return NULL;
53410: 
53410:           case JSTRAP_RETURN:
53410:             cx->throwing = JS_FALSE;
53482:             cx->fp()->setReturnValue(rval);
53410:             return JS_FUNC_TO_DATA_PTR(void *,
56773:                    cx->jaegerCompartment()->forceReturnTrampoline());
53410: 
53410:           case JSTRAP_THROW:
53410:             cx->exception = rval;
53410:             break;
53410: 
53410:           default:
53410:             break;
53410:         }
53410:     }
53410: 
52873:     jsbytecode *pc = NULL;
52873:     for (;;) {
52873:         pc = FindExceptionHandler(cx);
52873:         if (pc)
52873:             break;
52873: 
53422:         // If on the 'topmost' frame (where topmost means the first frame
53422:         // called into through js_Interpret). In this case, we still unwind,
53422:         // but we shouldn't return from a JS function, because we're not in a
53422:         // JS function.
57308:         bool lastFrame = (f.entryfp == f.fp());
52873:         js_UnwindScope(cx, 0, cx->throwing);
56201: 
56201:         // For consistency with Interpret(), always run the script epilogue.
56201:         // This simplifies interactions with RunTracer(), since it can assume
56201:         // no matter how a function exited (error or not), that the epilogue
56201:         // does not need to be run.
56201:         ScriptEpilogue(f.cx, f.fp(), false);
56201: 
52873:         if (lastFrame)
52873:             break;
52873: 
52873:         JS_ASSERT(f.regs.sp == cx->regs->sp);
56201:         InlineReturn(f);
52873:     }
52873: 
52873:     JS_ASSERT(f.regs.sp == cx->regs->sp);
52873: 
53626:     if (!pc)
52873:         return NULL;
52873: 
55503:     JSStackFrame *fp = cx->fp();
55503:     JSScript *script = fp->script();
55520:     return script->nativeCodeForPC(fp->isConstructing(), pc);
52873: }
52873: 
52873: void JS_FASTCALL
52873: stubs::GetCallObject(VMFrame &f)
52873: {
53840:     JS_ASSERT(f.fp()->fun()->isHeavyweight());
53482:     if (!js_GetCallObject(f.cx, f.fp()))
52873:         THROW();
52873: }
52873: 
55503: void JS_FASTCALL
55503: stubs::CreateThis(VMFrame &f, JSObject *proto)
55503: {
55503:     JSContext *cx = f.cx;
55503:     JSStackFrame *fp = f.fp();
55503:     JSObject *callee = &fp->callee();
55503:     JSObject *obj = js_CreateThisForFunctionWithProto(cx, callee, proto);
55503:     if (!obj)
55503:         THROW();
55503:     fp->formalArgs()[-1].setObject(*obj);
55503: }
55503: 
56201: void JS_FASTCALL
56201: stubs::EnterScript(VMFrame &f)
53133: {
56201:     JSStackFrame *fp = f.fp();
56201:     JSContext *cx = f.cx;
57757: 
57757:     if (fp->script()->debugMode) {
56201:         JSInterpreterHook hook = cx->debugHooks->callHook;
56201:         if (JS_UNLIKELY(hook != NULL) && !fp->isExecuteFrame()) {
56201:             fp->setHookData(hook(cx, fp, JS_TRUE, 0, cx->debugHooks->callHookData));
56201:         }
57757:     }
56201: 
57757:     Probes::enterJSFun(cx, fp->maybeFun(), fp->script());
56201: }
56201: 
56201: void JS_FASTCALL
56201: stubs::LeaveScript(VMFrame &f)
56201: {
56201:     JSStackFrame *fp = f.fp();
56201:     JSContext *cx = f.cx;
57757:     Probes::exitJSFun(cx, fp->maybeFun(), fp->maybeScript());
57757: 
57757:     if (fp->script()->debugMode) {
56201:         JSInterpreterHook hook = cx->debugHooks->callHook;
57830:         void *hookData;
56201: 
57830:         if (hook && (hookData = fp->maybeHookData()) && !fp->isExecuteFrame()) {
56201:             JSBool ok = JS_TRUE;
57830:             hook(cx, fp, JS_FALSE, &ok, hookData);
56201:             if (!ok)
56201:                 THROW();
56201:         }
53133:     }
57757: }
53133: 
53133: #ifdef JS_TRACER
53133: 
56201: /*
56201:  * Called when an error is in progress and the topmost frame could not handle
56201:  * it. This will unwind to a given frame, or find and align to an exception
56201:  * handler in the process.
56201:  */
53133: static inline bool
56201: HandleErrorInExcessFrame(VMFrame &f, JSStackFrame *stopFp, bool searchedTopmostFrame = true)
53133: {
53133:     JSContext *cx = f.cx;
53133: 
54736:     /*
54736:      * Callers of this called either Interpret() or JaegerShot(), which would
54736:      * have searched for exception handlers already. If we see stopFp, just
54736:      * return false. Otherwise, pop the frame, since it's guaranteed useless.
56201:      *
56201:      * Note that this also guarantees ScriptEpilogue() has been called.
54736:      */
54736:     JSStackFrame *fp = cx->fp();
56201:     if (searchedTopmostFrame) {
54736:         if (fp == stopFp)
54736:             return false;
54736: 
56201:         InlineReturn(f);
56201:     }
54736: 
54727:     /* Remove the bottom frame. */
56201:     bool returnOK = false;
54727:     for (;;) {
54736:         fp = cx->fp();
54723: 
54736:         /* Clear imacros. */
54736:         if (fp->hasImacropc()) {
53840:             cx->regs->pc = fp->imacropc();
53840:             fp->clearImacropc();
53133:         }
53840:         JS_ASSERT(!fp->hasImacropc());
53133: 
53133:         /* If there's an exception and a handler, set the pc and leave. */
54736:         if (cx->throwing) {
53133:             jsbytecode *pc = FindExceptionHandler(cx);
53133:             if (pc) {
53133:                 cx->regs->pc = pc;
54736:                 returnOK = true;
53133:                 break;
53133:             }
54736:         }
53133: 
53133:         /* Don't unwind if this was the entry frame. */
53133:         if (fp == stopFp)
53133:             break;
53133: 
53133:         /* Unwind and return. */
54736:         returnOK &= bool(js_UnwindScope(cx, 0, returnOK || cx->throwing));
56201:         returnOK = ScriptEpilogue(cx, fp, returnOK);
56201:         InlineReturn(f);
53133:     }
53133: 
53133:     JS_ASSERT(&f.regs == cx->regs);
54739:     JS_ASSERT_IF(!returnOK, cx->fp() == stopFp);
53133: 
54736:     return returnOK;
53133: }
53133: 
56201: /* Returns whether the current PC has method JIT'd code. */
55520: static inline void *
53133: AtSafePoint(JSContext *cx)
53133: {
53482:     JSStackFrame *fp = cx->fp();
53840:     if (fp->hasImacropc())
53133:         return false;
53133: 
53840:     JSScript *script = fp->script();
55520:     return script->maybeNativeCodeForPC(fp->isConstructing(), cx->regs->pc);
53133: }
53133: 
56201: /*
56201:  * Interprets until either a safe point is reached that has method JIT'd
56201:  * code, or the current frame tries to return.
56201:  */
53133: static inline JSBool
53428: PartialInterpret(VMFrame &f)
53133: {
53428:     JSContext *cx = f.cx;
53482:     JSStackFrame *fp = cx->fp();
53133: 
55503: #ifdef DEBUG
55520:     JSScript *script = fp->script();
56201:     JS_ASSERT(!fp->finishedInInterpreter());
55520:     JS_ASSERT(fp->hasImacropc() ||
55520:               !script->maybeNativeCodeForPC(fp->isConstructing(), cx->regs->pc));
55503: #endif
53133: 
53133:     JSBool ok = JS_TRUE;
53626:     ok = Interpret(cx, fp, 0, JSINTERP_SAFEPOINT);
53133: 
53133:     return ok;
53133: }
53133: 
53133: JS_STATIC_ASSERT(JSOP_NOP == 0);
53133: 
56201: /* Returns whether the current PC would return, popping the frame. */
53133: static inline JSOp
53133: FrameIsFinished(JSContext *cx)
53133: {
53133:     JSOp op = JSOp(*cx->regs->pc);
53133:     return (op == JSOP_RETURN ||
53133:             op == JSOP_RETRVAL ||
53133:             op == JSOP_STOP)
53133:         ? op
53133:         : JSOP_NOP;
53133: }
53133: 
56201: 
56201: /* Simulate an inline_return by advancing the pc. */
56201: static inline void
56201: AdvanceReturnPC(JSContext *cx)
56201: {
56201:     JS_ASSERT(*cx->regs->pc == JSOP_CALL ||
56201:               *cx->regs->pc == JSOP_NEW ||
56201:               *cx->regs->pc == JSOP_EVAL ||
57712:               *cx->regs->pc == JSOP_FUNCALL ||
57712:               *cx->regs->pc == JSOP_FUNAPPLY);
56201:     cx->regs->pc += JSOP_CALL_LENGTH;
56201: }
56201: 
56201: 
56201: /*
56201:  * Given a frame that is about to return, make sure its return value and
56201:  * activation objects are fixed up. Then, pop the frame and advance the
56201:  * current PC. Note that while we could enter the JIT at this point, the
56201:  * logic would still be necessary for the interpreter, so it's easier
56201:  * (and faster) to finish frames in C++ even if at a safe point here.
56201:  */
56201: static bool
56201: HandleFinishedFrame(VMFrame &f, JSStackFrame *entryFrame)
56201: {
56201:     JSContext *cx = f.cx;
56201: 
56201:     JS_ASSERT(FrameIsFinished(cx));
56201: 
56201:     /*
56201:      * This is the most difficult and complicated piece of the tracer
56201:      * integration, and historically has been very buggy. The problem is that
56201:      * although this frame has to be popped (see RemoveExcessFrames), it may
56201:      * be at a JSOP_RETURN opcode, and it might not have ever been executed.
56201:      * That is, fp->rval may not be set to the top of the stack, and if it
56201:      * has, the stack has already been decremented. Note that fp->rval is not
56201:      * the only problem: the epilogue may never have been executed.
56201:      *
56201:      * Here are the edge cases and whether the frame has been exited cleanly:
56201:      *  1. No: A trace exited directly before a RETURN op, and the
56201:      *         interpreter never ran.
56201:      *  2. Yes: The interpreter exited cleanly.
56201:      *  3. No: The interpreter exited on a safe point. LEAVE_ON_SAFE_POINT
56201:      *         is not used in between JSOP_RETURN and advancing the PC,
56201:      *         therefore, it cannot have been run if at a safe point.
56201:      *  4. No: Somewhere in the RunTracer call tree, we removed a frame,
56201:      *         and we returned to a JSOP_RETURN opcode. Note carefully
56201:      *         that in this situation, FrameIsFinished() returns true!
56201:      *  5. Yes: The function exited in the method JIT. However, in this
56201:      *         case, we'll never enter HandleFinishedFrame(): we always
56201:      *         immediately pop JIT'd frames.
56201:      *
56201:      * Since the only scenario where this fixup is NOT needed is a normal exit
56201:      * from the interpreter, we can cleanly check for this scenario by checking
56201:      * a bit it sets in the frame.
56201:      */
56201:     bool returnOK = true;
56201:     if (!cx->fp()->finishedInInterpreter()) {
56201:         if (JSOp(*cx->regs->pc) == JSOP_RETURN)
56201:             cx->fp()->setReturnValue(f.regs.sp[-1]);
56201: 
56201:         returnOK = ScriptEpilogue(cx, cx->fp(), true);
56201:     }
56201: 
56201:     JS_ASSERT_IF(cx->fp()->isFunctionFrame() &&
56201:                  !cx->fp()->isEvalFrame(),
56201:                  !cx->fp()->hasCallObj());
56201: 
56201:     if (cx->fp() != entryFrame) {
56201:         InlineReturn(f);
56201:         AdvanceReturnPC(cx);
56201:     }
56201: 
56201:     return returnOK;
56201: }
56201: 
56201: /*
56201:  * Given a frame newer than the entry frame, try to finish it. If it's at a
56201:  * return position, pop the frame. If it's at a safe point, execute it in
56201:  * Jaeger code. Otherwise, try to interpret until a safe point.
56201:  *
56201:  * While this function is guaranteed to make progress, it may not actually
56201:  * finish or pop the current frame. It can either:
56201:  *   1) Finalize a finished frame, or
56201:  *   2) Finish and finalize the frame in the Method JIT, or
56201:  *   3) Interpret, which can:
56201:  *     a) Propagate an error, or
56201:  *     b) Finish the frame, but not finalize it, or
56201:  *     c) Abruptly leave at any point in the frame, or in a newer frame
56201:  *        pushed by a call, that has method JIT'd code.
56201:  */
56201: static bool
56201: EvaluateExcessFrame(VMFrame &f, JSStackFrame *entryFrame)
56201: {
56201:     JSContext *cx = f.cx;
56201:     JSStackFrame *fp = cx->fp();
56201: 
56201:     /*
56201:      * A "finished" frame is when the interpreter rested on a STOP,
56201:      * RETURN, RETRVAL, etc. We check for finished frames BEFORE looking
56201:      * for a safe point. If the frame was finished, we could have already
56201:      * called ScriptEpilogue(), and entering the JIT could call it twice.
56201:      */
56201:     if (!fp->hasImacropc() && FrameIsFinished(cx))
56201:         return HandleFinishedFrame(f, entryFrame);
56201: 
56201:     if (void *ncode = AtSafePoint(cx)) {
56201:         if (!JaegerShotAtSafePoint(cx, ncode))
56201:             return false;
56201:         InlineReturn(f);
56201:         AdvanceReturnPC(cx);
56201:         return true;
56201:     }
56201: 
56201:     return PartialInterpret(f);
56201: }
56201: 
56201: /*
56201:  * Evaluate frames newer than the entry frame until all are gone. This will
56201:  * always leave f.regs.fp == entryFrame.
56201:  */
53133: static bool
54736: FinishExcessFrames(VMFrame &f, JSStackFrame *entryFrame)
53133: {
53133:     JSContext *cx = f.cx;
56201: 
56033:     while (cx->fp() != entryFrame || entryFrame->hasImacropc()) {
56201:         if (!EvaluateExcessFrame(f, entryFrame)) {
56201:             if (!HandleErrorInExcessFrame(f, entryFrame))
56033:                 return false;
53133:         }
53133:     }
53133: 
53133:     return true;
53133: }
53133: 
53133: #if JS_MONOIC
53133: static void
58063: UpdateTraceHintSingle(Repatcher &repatcher, JSC::CodeLocationJump jump, JSC::CodeLocationLabel target)
53133: {
53133:     /*
53133:      * Hack: The value that will be patched is before the executable address,
53133:      * so to get protection right, just unprotect the general region around
53133:      * the jump.
53133:      */
58063:     repatcher.relink(jump, target);
53277: 
53277:     JaegerSpew(JSpew_PICs, "relinking trace hint %p to %p\n",
54160:                jump.executableAddress(), target.executableAddress());
53277: }
54160: 
54160: static void
56217: DisableTraceHint(VMFrame &f, ic::TraceICInfo &tic)
54160: {
58063:     Repatcher repatcher(f.jit());
58063:     UpdateTraceHintSingle(repatcher, tic.traceHint, tic.jumpTarget);
54160: 
56217:     if (tic.hasSlowTraceHint)
58063:         UpdateTraceHintSingle(repatcher, tic.slowTraceHint, tic.jumpTarget);
56217: }
54160: 
56217: static void
56217: EnableTraceHintAt(JSScript *script, js::mjit::JITScript *jit, jsbytecode *pc, uint16_t index)
56217: {
59742:     if (index >= jit->nTraceICs)
59742:         return;
56217:     ic::TraceICInfo &tic = jit->traceICs[index];
59742:     if (!tic.initialized)
59742:         return;
56217:     
56217:     JS_ASSERT(tic.jumpTargetPC == pc);
56217: 
56217:     JaegerSpew(JSpew_PICs, "Enabling trace IC %u in script %p\n", index, script);
56217: 
58063:     Repatcher repatcher(jit);
58063: 
58063:     UpdateTraceHintSingle(repatcher, tic.traceHint, tic.stubEntry);
56217: 
56217:     if (tic.hasSlowTraceHint)
58063:         UpdateTraceHintSingle(repatcher, tic.slowTraceHint, tic.stubEntry);
53133: }
53133: #endif
53133: 
56217: void
56217: js::mjit::EnableTraceHint(JSScript *script, jsbytecode *pc, uint16_t index)
56217: {
56217: #if JS_MONOIC
56217:     if (script->jitNormal)
56217:         EnableTraceHintAt(script, script->jitNormal, pc, index);
56217: 
56217:     if (script->jitCtor)
56217:         EnableTraceHintAt(script, script->jitCtor, pc, index);
56217: #endif
56217: }
56217: 
53133: #if JS_MONOIC
53133: void *
56217: RunTracer(VMFrame &f, ic::TraceICInfo &tic)
53133: #else
53133: void *
53133: RunTracer(VMFrame &f)
53133: #endif
53133: {
53133:     JSContext *cx = f.cx;
53482:     JSStackFrame *entryFrame = f.fp();
53133:     TracePointAction tpa;
53133: 
53133:     /* :TODO: nuke PIC? */
54175:     if (!cx->traceJitEnabled)
53133:         return NULL;
53133: 
55483:     /*
55483:      * Force initialization of the entry frame's scope chain and return value,
55483:      * if necessary.  The tracer can query the scope chain without needing to
55483:      * check the HAS_SCOPECHAIN flag, and the frame is guaranteed to have the
55483:      * correct return value stored if we trace/interpret through to the end
55483:      * of the frame.
55483:      */
55483:     entryFrame->scopeChain();
55483:     entryFrame->returnValue();
55483: 
53133:     bool blacklist;
53422:     uintN inlineCallCount = 0;
56551:     void **traceData;
56551:     uintN *traceEpoch;
56551: #if JS_MONOIC
56551:     traceData = &tic.traceData;
56551:     traceEpoch = &tic.traceEpoch;
56551: #else
56551:     traceData = NULL;
56551:     traceEpoch = NULL;
56551: #endif
58052:     tpa = MonitorTracePoint(f.cx, inlineCallCount, &blacklist, traceData, traceEpoch);
53133:     JS_ASSERT(!TRACE_RECORDER(cx));
53133: 
53133: #if JS_MONOIC
53133:     if (blacklist)
56217:         DisableTraceHint(f, tic);
53133: #endif
53133: 
56201:     // Even though ExecuteTree() bypasses the interpreter, it should propagate
56201:     // error failures correctly.
56201:     JS_ASSERT_IF(cx->throwing, tpa == TPA_Error);
53133: 
53482: 	f.fp() = cx->fp();
56201:     JS_ASSERT(f.fp() == cx->fp());
53133:     switch (tpa) {
53133:       case TPA_Nothing:
53133:         return NULL;
53133: 
53133:       case TPA_Error:
56201:         if (!HandleErrorInExcessFrame(f, entryFrame, f.fp()->finishedInInterpreter()))
53133:             THROWV(NULL);
53840:         JS_ASSERT(!cx->fp()->hasImacropc());
53133:         break;
53133: 
53133:       case TPA_RanStuff:
53133:       case TPA_Recorded:
53133:         break;
53133:     }
53133: 
53133:     /*
53133:      * The tracer could have dropped us off on any frame at any position.
53133:      * Well, it could not have removed frames (recursion is disabled).
53133:      *
53471:      * Frames after the entryFrame cannot be entered via JaegerShotAtSafePoint()
53471:      * unless each is at a safe point. We can JaegerShotAtSafePoint these
53471:      * frames individually, but we must unwind to the entryFrame.
53471:      *
53471:      * Note carefully that JaegerShotAtSafePoint can resume methods at
53471:      * arbitrary safe points whereas JaegerShot cannot.
53133:      *
53133:      * If we land on entryFrame without a safe point in sight, we'll end up
53133:      * at the RETURN op. This is an edge case with two paths:
53133:      *
53133:      * 1) The entryFrame is the last inline frame. If it fell on a RETURN,
53133:      *    move the return value down.
53133:      * 2) The entryFrame is NOT the last inline frame. Pop the frame.
53133:      *
53471:      * In both cases, we hijack the stub to return to InjectJaegerReturn. This
53471:      * moves |oldFp->rval| into the scripted return registers.
53133:      */
53133: 
53133:   restart:
54736:     /* Step 1. Finish frames created after the entry frame. */
54736:     if (!FinishExcessFrames(f, entryFrame))
53133:         THROWV(NULL);
53133: 
53626:     /* IMacros are guaranteed to have been removed by now. */
56201:     JS_ASSERT(f.fp() == entryFrame);
53840:     JS_ASSERT(!entryFrame->hasImacropc());
53133: 
56201:     /* Step 2. If entryFrame is done, use a special path to return to EnterMethodJIT(). */
56201:     if (FrameIsFinished(cx)) {
56201:         if (!HandleFinishedFrame(f, entryFrame))
53133:             THROWV(NULL);
54832: 
53471:         void *retPtr = JS_FUNC_TO_DATA_PTR(void *, InjectJaegerReturn);
53168:         *f.returnAddressLocation() = retPtr;
53133:         return NULL;
53133:     }
53133: 
56201:     /* Step 3. If entryFrame is at a safe point, just leave. */
56201:     if (void *ncode = AtSafePoint(cx))
56201:         return ncode;
56201: 
53626:     /* Step 4. Do a partial interp, then restart the whole process. */
53428:     if (!PartialInterpret(f)) {
56201:         if (!HandleErrorInExcessFrame(f, entryFrame))
53133:             THROWV(NULL);
53133:     }
53133: 
53133:     goto restart;
53133: }
53133: 
53133: #endif /* JS_TRACER */
53133: 
53136: #if defined JS_TRACER
53136: # if defined JS_MONOIC
53133: void *JS_FASTCALL
56217: stubs::InvokeTracer(VMFrame &f, ic::TraceICInfo *tic)
53133: {
56217:     return RunTracer(f, *tic);
53133: }
53133: 
53133: # else
53133: 
53133: void *JS_FASTCALL
53133: stubs::InvokeTracer(VMFrame &f)
53133: {
53133:     return RunTracer(f);
53133: }
53136: # endif /* JS_MONOIC */
53136: #endif /* JS_TRACER */
53133: 
