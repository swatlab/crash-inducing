16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:  function: psychoacoustics not including preecho
31034:  last mod: $Id: psy.c 16227 2009-07-08 06:58:46Z xiphmont $
16295: 
16295:  ********************************************************************/
16295: 
16295: #include <stdlib.h>
16295: #include <math.h>
16295: #include <string.h>
16295: #include "vorbis/codec.h"
16295: #include "codec_internal.h"
16295: 
16295: #include "masking.h"
16295: #include "psy.h"
16295: #include "os.h"
16295: #include "lpc.h"
16295: #include "smallft.h"
16295: #include "scales.h"
16295: #include "misc.h"
16295: 
16295: #define NEGINF -9999.f
30043: static const double stereo_threshholds[]={0.0, .5, 1.0, 1.5, 2.5, 4.5, 8.5, 16.5, 9e10};
30043: static const double stereo_threshholds_limited[]={0.0, .5, 1.0, 1.5, 2.0, 2.5, 4.5, 8.5, 9e10};
16295: 
16295: vorbis_look_psy_global *_vp_global_look(vorbis_info *vi){
16295:   codec_setup_info *ci=vi->codec_setup;
16295:   vorbis_info_psy_global *gi=&ci->psy_g_param;
16295:   vorbis_look_psy_global *look=_ogg_calloc(1,sizeof(*look));
16295: 
16295:   look->channels=vi->channels;
16295: 
16295:   look->ampmax=-9999.;
16295:   look->gi=gi;
16295:   return(look);
16295: }
16295: 
16295: void _vp_global_free(vorbis_look_psy_global *look){
16295:   if(look){
16295:     memset(look,0,sizeof(*look));
16295:     _ogg_free(look);
16295:   }
16295: }
16295: 
16295: void _vi_gpsy_free(vorbis_info_psy_global *i){
16295:   if(i){
16295:     memset(i,0,sizeof(*i));
16295:     _ogg_free(i);
16295:   }
16295: }
16295: 
16295: void _vi_psy_free(vorbis_info_psy *i){
16295:   if(i){
16295:     memset(i,0,sizeof(*i));
16295:     _ogg_free(i);
16295:   }
16295: }
16295: 
16295: static void min_curve(float *c,
16295:                        float *c2){
16295:   int i;
16295:   for(i=0;i<EHMER_MAX;i++)if(c2[i]<c[i])c[i]=c2[i];
16295: }
16295: static void max_curve(float *c,
16295:                        float *c2){
16295:   int i;
16295:   for(i=0;i<EHMER_MAX;i++)if(c2[i]>c[i])c[i]=c2[i];
16295: }
16295: 
16295: static void attenuate_curve(float *c,float att){
16295:   int i;
16295:   for(i=0;i<EHMER_MAX;i++)
16295:     c[i]+=att;
16295: }
16295: 
16295: static float ***setup_tone_curves(float curveatt_dB[P_BANDS],float binHz,int n,
16295:                                   float center_boost, float center_decay_rate){
16295:   int i,j,k,m;
16295:   float ath[EHMER_MAX];
16295:   float workc[P_BANDS][P_LEVELS][EHMER_MAX];
16295:   float athc[P_LEVELS][EHMER_MAX];
16295:   float *brute_buffer=alloca(n*sizeof(*brute_buffer));
16295: 
16295:   float ***ret=_ogg_malloc(sizeof(*ret)*P_BANDS);
16295: 
16295:   memset(workc,0,sizeof(workc));
16295: 
16295:   for(i=0;i<P_BANDS;i++){
16295:     /* we add back in the ATH to avoid low level curves falling off to
16295:        -infinity and unnecessarily cutting off high level curves in the
16295:        curve limiting (last step). */
16295: 
16295:     /* A half-band's settings must be valid over the whole band, and
16295:        it's better to mask too little than too much */
16295:     int ath_offset=i*4;
16295:     for(j=0;j<EHMER_MAX;j++){
16295:       float min=999.;
16295:       for(k=0;k<4;k++)
16295:         if(j+k+ath_offset<MAX_ATH){
16295:           if(min>ATH[j+k+ath_offset])min=ATH[j+k+ath_offset];
16295:         }else{
16295:           if(min>ATH[MAX_ATH-1])min=ATH[MAX_ATH-1];
16295:         }
16295:       ath[j]=min;
16295:     }
16295: 
16295:     /* copy curves into working space, replicate the 50dB curve to 30
16295:        and 40, replicate the 100dB curve to 110 */
16295:     for(j=0;j<6;j++)
16295:       memcpy(workc[i][j+2],tonemasks[i][j],EHMER_MAX*sizeof(*tonemasks[i][j]));
16295:     memcpy(workc[i][0],tonemasks[i][0],EHMER_MAX*sizeof(*tonemasks[i][0]));
16295:     memcpy(workc[i][1],tonemasks[i][0],EHMER_MAX*sizeof(*tonemasks[i][0]));
16295: 
16295:     /* apply centered curve boost/decay */
16295:     for(j=0;j<P_LEVELS;j++){
16295:       for(k=0;k<EHMER_MAX;k++){
16295:         float adj=center_boost+abs(EHMER_OFFSET-k)*center_decay_rate;
16295:         if(adj<0. && center_boost>0)adj=0.;
16295:         if(adj>0. && center_boost<0)adj=0.;
16295:         workc[i][j][k]+=adj;
16295:       }
16295:     }
16295: 
16295:     /* normalize curves so the driving amplitude is 0dB */
16295:     /* make temp curves with the ATH overlayed */
16295:     for(j=0;j<P_LEVELS;j++){
16295:       attenuate_curve(workc[i][j],curveatt_dB[i]+100.-(j<2?2:j)*10.-P_LEVEL_0);
16295:       memcpy(athc[j],ath,EHMER_MAX*sizeof(**athc));
16295:       attenuate_curve(athc[j],+100.-j*10.f-P_LEVEL_0);
16295:       max_curve(athc[j],workc[i][j]);
16295:     }
16295: 
16295:     /* Now limit the louder curves.
16295: 
16295:        the idea is this: We don't know what the playback attenuation
16295:        will be; 0dB SL moves every time the user twiddles the volume
16295:        knob. So that means we have to use a single 'most pessimal' curve
16295:        for all masking amplitudes, right?  Wrong.  The *loudest* sound
16295:        can be in (we assume) a range of ...+100dB] SL.  However, sounds
16295:        20dB down will be in a range ...+80], 40dB down is from ...+60],
16295:        etc... */
16295: 
16295:     for(j=1;j<P_LEVELS;j++){
16295:       min_curve(athc[j],athc[j-1]);
16295:       min_curve(workc[i][j],athc[j]);
16295:     }
16295:   }
16295: 
16295:   for(i=0;i<P_BANDS;i++){
16295:     int hi_curve,lo_curve,bin;
16295:     ret[i]=_ogg_malloc(sizeof(**ret)*P_LEVELS);
16295: 
16295:     /* low frequency curves are measured with greater resolution than
16295:        the MDCT/FFT will actually give us; we want the curve applied
16295:        to the tone data to be pessimistic and thus apply the minimum
16295:        masking possible for a given bin.  That means that a single bin
16295:        could span more than one octave and that the curve will be a
16295:        composite of multiple octaves.  It also may mean that a single
16295:        bin may span > an eighth of an octave and that the eighth
16295:        octave values may also be composited. */
16295: 
16295:     /* which octave curves will we be compositing? */
16295:     bin=floor(fromOC(i*.5)/binHz);
16295:     lo_curve=  ceil(toOC(bin*binHz+1)*2);
16295:     hi_curve=  floor(toOC((bin+1)*binHz)*2);
16295:     if(lo_curve>i)lo_curve=i;
16295:     if(lo_curve<0)lo_curve=0;
16295:     if(hi_curve>=P_BANDS)hi_curve=P_BANDS-1;
16295: 
16295:     for(m=0;m<P_LEVELS;m++){
16295:       ret[i][m]=_ogg_malloc(sizeof(***ret)*(EHMER_MAX+2));
16295: 
16295:       for(j=0;j<n;j++)brute_buffer[j]=999.;
16295: 
16295:       /* render the curve into bins, then pull values back into curve.
16295:          The point is that any inherent subsampling aliasing results in
16295:          a safe minimum */
16295:       for(k=lo_curve;k<=hi_curve;k++){
16295:         int l=0;
16295: 
16295:         for(j=0;j<EHMER_MAX;j++){
16295:           int lo_bin= fromOC(j*.125+k*.5-2.0625)/binHz;
16295:           int hi_bin= fromOC(j*.125+k*.5-1.9375)/binHz+1;
16295: 
16295:           if(lo_bin<0)lo_bin=0;
16295:           if(lo_bin>n)lo_bin=n;
16295:           if(lo_bin<l)l=lo_bin;
16295:           if(hi_bin<0)hi_bin=0;
16295:           if(hi_bin>n)hi_bin=n;
16295: 
16295:           for(;l<hi_bin && l<n;l++)
16295:             if(brute_buffer[l]>workc[k][m][j])
16295:               brute_buffer[l]=workc[k][m][j];
16295:         }
16295: 
16295:         for(;l<n;l++)
16295:           if(brute_buffer[l]>workc[k][m][EHMER_MAX-1])
16295:             brute_buffer[l]=workc[k][m][EHMER_MAX-1];
16295: 
16295:       }
16295: 
16295:       /* be equally paranoid about being valid up to next half ocatve */
16295:       if(i+1<P_BANDS){
16295:         int l=0;
16295:         k=i+1;
16295:         for(j=0;j<EHMER_MAX;j++){
16295:           int lo_bin= fromOC(j*.125+i*.5-2.0625)/binHz;
16295:           int hi_bin= fromOC(j*.125+i*.5-1.9375)/binHz+1;
16295: 
16295:           if(lo_bin<0)lo_bin=0;
16295:           if(lo_bin>n)lo_bin=n;
16295:           if(lo_bin<l)l=lo_bin;
16295:           if(hi_bin<0)hi_bin=0;
16295:           if(hi_bin>n)hi_bin=n;
16295: 
16295:           for(;l<hi_bin && l<n;l++)
16295:             if(brute_buffer[l]>workc[k][m][j])
16295:               brute_buffer[l]=workc[k][m][j];
16295:         }
16295: 
16295:         for(;l<n;l++)
16295:           if(brute_buffer[l]>workc[k][m][EHMER_MAX-1])
16295:             brute_buffer[l]=workc[k][m][EHMER_MAX-1];
16295: 
16295:       }
16295: 
16295: 
16295:       for(j=0;j<EHMER_MAX;j++){
16295:         int bin=fromOC(j*.125+i*.5-2.)/binHz;
16295:         if(bin<0){
16295:           ret[i][m][j+2]=-999.;
16295:         }else{
16295:           if(bin>=n){
16295:             ret[i][m][j+2]=-999.;
16295:           }else{
16295:             ret[i][m][j+2]=brute_buffer[bin];
16295:           }
16295:         }
16295:       }
16295: 
16295:       /* add fenceposts */
16295:       for(j=0;j<EHMER_OFFSET;j++)
16295:         if(ret[i][m][j+2]>-200.f)break;
16295:       ret[i][m][0]=j;
16295: 
16295:       for(j=EHMER_MAX-1;j>EHMER_OFFSET+1;j--)
16295:         if(ret[i][m][j+2]>-200.f)
16295:           break;
16295:       ret[i][m][1]=j;
16295: 
16295:     }
16295:   }
16295: 
16295:   return(ret);
16295: }
16295: 
16295: void _vp_psy_init(vorbis_look_psy *p,vorbis_info_psy *vi,
16295:                   vorbis_info_psy_global *gi,int n,long rate){
16295:   long i,j,lo=-99,hi=1;
16295:   long maxoc;
16295:   memset(p,0,sizeof(*p));
16295: 
16295:   p->eighth_octave_lines=gi->eighth_octave_lines;
16295:   p->shiftoc=rint(log(gi->eighth_octave_lines*8.f)/log(2.f))-1;
16295: 
16295:   p->firstoc=toOC(.25f*rate*.5/n)*(1<<(p->shiftoc+1))-gi->eighth_octave_lines;
16295:   maxoc=toOC((n+.25f)*rate*.5/n)*(1<<(p->shiftoc+1))+.5f;
16295:   p->total_octave_lines=maxoc-p->firstoc+1;
16295:   p->ath=_ogg_malloc(n*sizeof(*p->ath));
16295: 
16295:   p->octave=_ogg_malloc(n*sizeof(*p->octave));
16295:   p->bark=_ogg_malloc(n*sizeof(*p->bark));
16295:   p->vi=vi;
16295:   p->n=n;
16295:   p->rate=rate;
16295: 
16295:   /* AoTuV HF weighting */
16295:   p->m_val = 1.;
16295:   if(rate < 26000) p->m_val = 0;
16295:   else if(rate < 38000) p->m_val = .94;   /* 32kHz */
16295:   else if(rate > 46000) p->m_val = 1.275; /* 48kHz */
16295: 
16295:   /* set up the lookups for a given blocksize and sample rate */
16295: 
16295:   for(i=0,j=0;i<MAX_ATH-1;i++){
16295:     int endpos=rint(fromOC((i+1)*.125-2.)*2*n/rate);
16295:     float base=ATH[i];
16295:     if(j<endpos){
16295:       float delta=(ATH[i+1]-base)/(endpos-j);
16295:       for(;j<endpos && j<n;j++){
16295:         p->ath[j]=base+100.;
16295:         base+=delta;
16295:       }
16295:     }
16295:   }
16295: 
30043:   for(;j<n;j++){
30043:     p->ath[j]=p->ath[j-1];
30043:   }
30043: 
16295:   for(i=0;i<n;i++){
16295:     float bark=toBARK(rate/(2*n)*i);
16295: 
16295:     for(;lo+vi->noisewindowlomin<i &&
16295:           toBARK(rate/(2*n)*lo)<(bark-vi->noisewindowlo);lo++);
16295: 
16295:     for(;hi<=n && (hi<i+vi->noisewindowhimin ||
16295:           toBARK(rate/(2*n)*hi)<(bark+vi->noisewindowhi));hi++);
16295: 
16295:     p->bark[i]=((lo-1)<<16)+(hi-1);
16295: 
16295:   }
16295: 
16295:   for(i=0;i<n;i++)
16295:     p->octave[i]=toOC((i+.25f)*.5*rate/n)*(1<<(p->shiftoc+1))+.5f;
16295: 
16295:   p->tonecurves=setup_tone_curves(vi->toneatt,rate*.5/n,n,
16295:                                   vi->tone_centerboost,vi->tone_decay);
16295: 
16295:   /* set up rolling noise median */
16295:   p->noiseoffset=_ogg_malloc(P_NOISECURVES*sizeof(*p->noiseoffset));
16295:   for(i=0;i<P_NOISECURVES;i++)
16295:     p->noiseoffset[i]=_ogg_malloc(n*sizeof(**p->noiseoffset));
16295: 
16295:   for(i=0;i<n;i++){
16295:     float halfoc=toOC((i+.5)*rate/(2.*n))*2.;
16295:     int inthalfoc;
16295:     float del;
16295: 
16295:     if(halfoc<0)halfoc=0;
16295:     if(halfoc>=P_BANDS-1)halfoc=P_BANDS-1;
16295:     inthalfoc=(int)halfoc;
16295:     del=halfoc-inthalfoc;
16295: 
16295:     for(j=0;j<P_NOISECURVES;j++)
16295:       p->noiseoffset[j][i]=
16295:         p->vi->noiseoff[j][inthalfoc]*(1.-del) +
16295:         p->vi->noiseoff[j][inthalfoc+1]*del;
16295: 
16295:   }
16295: #if 0
16295:   {
16295:     static int ls=0;
16295:     _analysis_output_always("noiseoff0",ls,p->noiseoffset[0],n,1,0,0);
16295:     _analysis_output_always("noiseoff1",ls,p->noiseoffset[1],n,1,0,0);
16295:     _analysis_output_always("noiseoff2",ls++,p->noiseoffset[2],n,1,0,0);
16295:   }
16295: #endif
16295: }
16295: 
16295: void _vp_psy_clear(vorbis_look_psy *p){
16295:   int i,j;
16295:   if(p){
16295:     if(p->ath)_ogg_free(p->ath);
16295:     if(p->octave)_ogg_free(p->octave);
16295:     if(p->bark)_ogg_free(p->bark);
16295:     if(p->tonecurves){
16295:       for(i=0;i<P_BANDS;i++){
16295:         for(j=0;j<P_LEVELS;j++){
16295:           _ogg_free(p->tonecurves[i][j]);
16295:         }
16295:         _ogg_free(p->tonecurves[i]);
16295:       }
16295:       _ogg_free(p->tonecurves);
16295:     }
16295:     if(p->noiseoffset){
16295:       for(i=0;i<P_NOISECURVES;i++){
16295:         _ogg_free(p->noiseoffset[i]);
16295:       }
16295:       _ogg_free(p->noiseoffset);
16295:     }
16295:     memset(p,0,sizeof(*p));
16295:   }
16295: }
16295: 
16295: /* octave/(8*eighth_octave_lines) x scale and dB y scale */
16295: static void seed_curve(float *seed,
16295:                        const float **curves,
16295:                        float amp,
16295:                        int oc, int n,
16295:                        int linesper,float dBoffset){
16295:   int i,post1;
16295:   int seedptr;
16295:   const float *posts,*curve;
16295: 
16295:   int choice=(int)((amp+dBoffset-P_LEVEL_0)*.1f);
16295:   choice=max(choice,0);
16295:   choice=min(choice,P_LEVELS-1);
16295:   posts=curves[choice];
16295:   curve=posts+2;
16295:   post1=(int)posts[1];
16295:   seedptr=oc+(posts[0]-EHMER_OFFSET)*linesper-(linesper>>1);
16295: 
16295:   for(i=posts[0];i<post1;i++){
16295:     if(seedptr>0){
16295:       float lin=amp+curve[i];
16295:       if(seed[seedptr]<lin)seed[seedptr]=lin;
16295:     }
16295:     seedptr+=linesper;
16295:     if(seedptr>=n)break;
16295:   }
16295: }
16295: 
16295: static void seed_loop(vorbis_look_psy *p,
16295:                       const float ***curves,
16295:                       const float *f,
16295:                       const float *flr,
16295:                       float *seed,
16295:                       float specmax){
16295:   vorbis_info_psy *vi=p->vi;
16295:   long n=p->n,i;
16295:   float dBoffset=vi->max_curve_dB-specmax;
16295: 
16295:   /* prime the working vector with peak values */
16295: 
16295:   for(i=0;i<n;i++){
16295:     float max=f[i];
16295:     long oc=p->octave[i];
16295:     while(i+1<n && p->octave[i+1]==oc){
16295:       i++;
16295:       if(f[i]>max)max=f[i];
16295:     }
16295: 
16295:     if(max+6.f>flr[i]){
16295:       oc=oc>>p->shiftoc;
16295: 
16295:       if(oc>=P_BANDS)oc=P_BANDS-1;
16295:       if(oc<0)oc=0;
16295: 
16295:       seed_curve(seed,
16295:                  curves[oc],
16295:                  max,
16295:                  p->octave[i]-p->firstoc,
16295:                  p->total_octave_lines,
16295:                  p->eighth_octave_lines,
16295:                  dBoffset);
16295:     }
16295:   }
16295: }
16295: 
16295: static void seed_chase(float *seeds, int linesper, long n){
16295:   long  *posstack=alloca(n*sizeof(*posstack));
16295:   float *ampstack=alloca(n*sizeof(*ampstack));
16295:   long   stack=0;
16295:   long   pos=0;
16295:   long   i;
16295: 
16295:   for(i=0;i<n;i++){
16295:     if(stack<2){
16295:       posstack[stack]=i;
16295:       ampstack[stack++]=seeds[i];
16295:     }else{
16295:       while(1){
16295:         if(seeds[i]<ampstack[stack-1]){
16295:           posstack[stack]=i;
16295:           ampstack[stack++]=seeds[i];
16295:           break;
16295:         }else{
16295:           if(i<posstack[stack-1]+linesper){
16295:             if(stack>1 && ampstack[stack-1]<=ampstack[stack-2] &&
16295:                i<posstack[stack-2]+linesper){
16295:               /* we completely overlap, making stack-1 irrelevant.  pop it */
16295:               stack--;
16295:               continue;
16295:             }
16295:           }
16295:           posstack[stack]=i;
16295:           ampstack[stack++]=seeds[i];
16295:           break;
16295: 
16295:         }
16295:       }
16295:     }
16295:   }
16295: 
16295:   /* the stack now contains only the positions that are relevant. Scan
16295:      'em straight through */
16295: 
16295:   for(i=0;i<stack;i++){
16295:     long endpos;
16295:     if(i<stack-1 && ampstack[i+1]>ampstack[i]){
16295:       endpos=posstack[i+1];
16295:     }else{
16295:       endpos=posstack[i]+linesper+1; /* +1 is important, else bin 0 is
16295:                                         discarded in short frames */
16295:     }
16295:     if(endpos>n)endpos=n;
16295:     for(;pos<endpos;pos++)
16295:       seeds[pos]=ampstack[i];
16295:   }
16295: 
16295:   /* there.  Linear time.  I now remember this was on a problem set I
16295:      had in Grad Skool... I didn't solve it at the time ;-) */
16295: 
16295: }
16295: 
16295: /* bleaugh, this is more complicated than it needs to be */
16295: #include<stdio.h>
16295: static void max_seeds(vorbis_look_psy *p,
16295:                       float *seed,
16295:                       float *flr){
16295:   long   n=p->total_octave_lines;
16295:   int    linesper=p->eighth_octave_lines;
16295:   long   linpos=0;
16295:   long   pos;
16295: 
16295:   seed_chase(seed,linesper,n); /* for masking */
16295: 
16295:   pos=p->octave[0]-p->firstoc-(linesper>>1);
16295: 
16295:   while(linpos+1<p->n){
16295:     float minV=seed[pos];
16295:     long end=((p->octave[linpos]+p->octave[linpos+1])>>1)-p->firstoc;
16295:     if(minV>p->vi->tone_abs_limit)minV=p->vi->tone_abs_limit;
16295:     while(pos+1<=end){
16295:       pos++;
16295:       if((seed[pos]>NEGINF && seed[pos]<minV) || minV==NEGINF)
16295:         minV=seed[pos];
16295:     }
16295: 
16295:     end=pos+p->firstoc;
16295:     for(;linpos<p->n && p->octave[linpos]<=end;linpos++)
16295:       if(flr[linpos]<minV)flr[linpos]=minV;
16295:   }
16295: 
16295:   {
16295:     float minV=seed[p->total_octave_lines-1];
16295:     for(;linpos<p->n;linpos++)
16295:       if(flr[linpos]<minV)flr[linpos]=minV;
16295:   }
16295: 
16295: }
16295: 
16295: static void bark_noise_hybridmp(int n,const long *b,
16295:                                 const float *f,
16295:                                 float *noise,
16295:                                 const float offset,
16295:                                 const int fixed){
16295: 
16295:   float *N=alloca(n*sizeof(*N));
16295:   float *X=alloca(n*sizeof(*N));
16295:   float *XX=alloca(n*sizeof(*N));
16295:   float *Y=alloca(n*sizeof(*N));
16295:   float *XY=alloca(n*sizeof(*N));
16295: 
16295:   float tN, tX, tXX, tY, tXY;
16295:   int i;
16295: 
16295:   int lo, hi;
16295:   float R=0.f;
16295:   float A=0.f;
16295:   float B=0.f;
16295:   float D=1.f;
16295:   float w, x, y;
16295: 
16295:   tN = tX = tXX = tY = tXY = 0.f;
16295: 
16295:   y = f[0] + offset;
16295:   if (y < 1.f) y = 1.f;
16295: 
16295:   w = y * y * .5;
16295: 
16295:   tN += w;
16295:   tX += w;
16295:   tY += w * y;
16295: 
16295:   N[0] = tN;
16295:   X[0] = tX;
16295:   XX[0] = tXX;
16295:   Y[0] = tY;
16295:   XY[0] = tXY;
16295: 
16295:   for (i = 1, x = 1.f; i < n; i++, x += 1.f) {
16295: 
16295:     y = f[i] + offset;
16295:     if (y < 1.f) y = 1.f;
16295: 
16295:     w = y * y;
16295: 
16295:     tN += w;
16295:     tX += w * x;
16295:     tXX += w * x * x;
16295:     tY += w * y;
16295:     tXY += w * x * y;
16295: 
16295:     N[i] = tN;
16295:     X[i] = tX;
16295:     XX[i] = tXX;
16295:     Y[i] = tY;
16295:     XY[i] = tXY;
16295:   }
16295: 
16295:   for (i = 0, x = 0.f;; i++, x += 1.f) {
16295: 
16295:     lo = b[i] >> 16;
16295:     if( lo>=0 ) break;
16295:     hi = b[i] & 0xffff;
16295: 
16295:     tN = N[hi] + N[-lo];
16295:     tX = X[hi] - X[-lo];
16295:     tXX = XX[hi] + XX[-lo];
16295:     tY = Y[hi] + Y[-lo];
16295:     tXY = XY[hi] - XY[-lo];
16295: 
16295:     A = tY * tXX - tX * tXY;
16295:     B = tN * tXY - tX * tY;
16295:     D = tN * tXX - tX * tX;
16295:     R = (A + x * B) / D;
16295:     if (R < 0.f)
16295:       R = 0.f;
16295: 
16295:     noise[i] = R - offset;
16295:   }
16295: 
16295:   for ( ;; i++, x += 1.f) {
16295: 
16295:     lo = b[i] >> 16;
16295:     hi = b[i] & 0xffff;
16295:     if(hi>=n)break;
16295: 
16295:     tN = N[hi] - N[lo];
16295:     tX = X[hi] - X[lo];
16295:     tXX = XX[hi] - XX[lo];
16295:     tY = Y[hi] - Y[lo];
16295:     tXY = XY[hi] - XY[lo];
16295: 
16295:     A = tY * tXX - tX * tXY;
16295:     B = tN * tXY - tX * tY;
16295:     D = tN * tXX - tX * tX;
16295:     R = (A + x * B) / D;
16295:     if (R < 0.f) R = 0.f;
16295: 
16295:     noise[i] = R - offset;
16295:   }
16295:   for ( ; i < n; i++, x += 1.f) {
16295: 
16295:     R = (A + x * B) / D;
16295:     if (R < 0.f) R = 0.f;
16295: 
16295:     noise[i] = R - offset;
16295:   }
16295: 
16295:   if (fixed <= 0) return;
16295: 
16295:   for (i = 0, x = 0.f;; i++, x += 1.f) {
16295:     hi = i + fixed / 2;
16295:     lo = hi - fixed;
16295:     if(lo>=0)break;
16295: 
16295:     tN = N[hi] + N[-lo];
16295:     tX = X[hi] - X[-lo];
16295:     tXX = XX[hi] + XX[-lo];
16295:     tY = Y[hi] + Y[-lo];
16295:     tXY = XY[hi] - XY[-lo];
16295: 
16295: 
16295:     A = tY * tXX - tX * tXY;
16295:     B = tN * tXY - tX * tY;
16295:     D = tN * tXX - tX * tX;
16295:     R = (A + x * B) / D;
16295: 
16295:     if (R - offset < noise[i]) noise[i] = R - offset;
16295:   }
16295:   for ( ;; i++, x += 1.f) {
16295: 
16295:     hi = i + fixed / 2;
16295:     lo = hi - fixed;
16295:     if(hi>=n)break;
16295: 
16295:     tN = N[hi] - N[lo];
16295:     tX = X[hi] - X[lo];
16295:     tXX = XX[hi] - XX[lo];
16295:     tY = Y[hi] - Y[lo];
16295:     tXY = XY[hi] - XY[lo];
16295: 
16295:     A = tY * tXX - tX * tXY;
16295:     B = tN * tXY - tX * tY;
16295:     D = tN * tXX - tX * tX;
16295:     R = (A + x * B) / D;
16295: 
16295:     if (R - offset < noise[i]) noise[i] = R - offset;
16295:   }
16295:   for ( ; i < n; i++, x += 1.f) {
16295:     R = (A + x * B) / D;
16295:     if (R - offset < noise[i]) noise[i] = R - offset;
16295:   }
16295: }
16295: 
30043: static const float FLOOR1_fromdB_INV_LOOKUP[256]={
16295:   0.F, 8.81683e+06F, 8.27882e+06F, 7.77365e+06F,
16295:   7.29930e+06F, 6.85389e+06F, 6.43567e+06F, 6.04296e+06F,
16295:   5.67422e+06F, 5.32798e+06F, 5.00286e+06F, 4.69759e+06F,
16295:   4.41094e+06F, 4.14178e+06F, 3.88905e+06F, 3.65174e+06F,
16295:   3.42891e+06F, 3.21968e+06F, 3.02321e+06F, 2.83873e+06F,
16295:   2.66551e+06F, 2.50286e+06F, 2.35014e+06F, 2.20673e+06F,
16295:   2.07208e+06F, 1.94564e+06F, 1.82692e+06F, 1.71544e+06F,
16295:   1.61076e+06F, 1.51247e+06F, 1.42018e+06F, 1.33352e+06F,
16295:   1.25215e+06F, 1.17574e+06F, 1.10400e+06F, 1.03663e+06F,
16295:   973377.F, 913981.F, 858210.F, 805842.F,
16295:   756669.F, 710497.F, 667142.F, 626433.F,
16295:   588208.F, 552316.F, 518613.F, 486967.F,
16295:   457252.F, 429351.F, 403152.F, 378551.F,
16295:   355452.F, 333762.F, 313396.F, 294273.F,
16295:   276316.F, 259455.F, 243623.F, 228757.F,
16295:   214798.F, 201691.F, 189384.F, 177828.F,
16295:   166977.F, 156788.F, 147221.F, 138237.F,
16295:   129802.F, 121881.F, 114444.F, 107461.F,
16295:   100903.F, 94746.3F, 88964.9F, 83536.2F,
16295:   78438.8F, 73652.5F, 69158.2F, 64938.1F,
16295:   60975.6F, 57254.9F, 53761.2F, 50480.6F,
16295:   47400.3F, 44507.9F, 41792.0F, 39241.9F,
16295:   36847.3F, 34598.9F, 32487.7F, 30505.3F,
16295:   28643.8F, 26896.0F, 25254.8F, 23713.7F,
16295:   22266.7F, 20908.0F, 19632.2F, 18434.2F,
16295:   17309.4F, 16253.1F, 15261.4F, 14330.1F,
16295:   13455.7F, 12634.6F, 11863.7F, 11139.7F,
16295:   10460.0F, 9821.72F, 9222.39F, 8659.64F,
16295:   8131.23F, 7635.06F, 7169.17F, 6731.70F,
16295:   6320.93F, 5935.23F, 5573.06F, 5232.99F,
16295:   4913.67F, 4613.84F, 4332.30F, 4067.94F,
16295:   3819.72F, 3586.64F, 3367.78F, 3162.28F,
16295:   2969.31F, 2788.13F, 2617.99F, 2458.24F,
16295:   2308.24F, 2167.39F, 2035.14F, 1910.95F,
16295:   1794.35F, 1684.85F, 1582.04F, 1485.51F,
16295:   1394.86F, 1309.75F, 1229.83F, 1154.78F,
16295:   1084.32F, 1018.15F, 956.024F, 897.687F,
16295:   842.910F, 791.475F, 743.179F, 697.830F,
16295:   655.249F, 615.265F, 577.722F, 542.469F,
16295:   509.367F, 478.286F, 449.101F, 421.696F,
16295:   395.964F, 371.803F, 349.115F, 327.812F,
16295:   307.809F, 289.026F, 271.390F, 254.830F,
16295:   239.280F, 224.679F, 210.969F, 198.096F,
16295:   186.008F, 174.658F, 164.000F, 153.993F,
16295:   144.596F, 135.773F, 127.488F, 119.708F,
16295:   112.404F, 105.545F, 99.1046F, 93.0572F,
16295:   87.3788F, 82.0469F, 77.0404F, 72.3394F,
16295:   67.9252F, 63.7804F, 59.8885F, 56.2341F,
16295:   52.8027F, 49.5807F, 46.5553F, 43.7144F,
16295:   41.0470F, 38.5423F, 36.1904F, 33.9821F,
16295:   31.9085F, 29.9614F, 28.1332F, 26.4165F,
16295:   24.8045F, 23.2910F, 21.8697F, 20.5352F,
16295:   19.2822F, 18.1056F, 17.0008F, 15.9634F,
16295:   14.9893F, 14.0746F, 13.2158F, 12.4094F,
16295:   11.6522F, 10.9411F, 10.2735F, 9.64662F,
16295:   9.05798F, 8.50526F, 7.98626F, 7.49894F,
16295:   7.04135F, 6.61169F, 6.20824F, 5.82941F,
16295:   5.47370F, 5.13970F, 4.82607F, 4.53158F,
16295:   4.25507F, 3.99542F, 3.75162F, 3.52269F,
16295:   3.30774F, 3.10590F, 2.91638F, 2.73842F,
16295:   2.57132F, 2.41442F, 2.26709F, 2.12875F,
16295:   1.99885F, 1.87688F, 1.76236F, 1.65482F,
16295:   1.55384F, 1.45902F, 1.36999F, 1.28640F,
16295:   1.20790F, 1.13419F, 1.06499F, 1.F
16295: };
16295: 
16295: void _vp_remove_floor(vorbis_look_psy *p,
16295:                       float *mdct,
16295:                       int *codedflr,
16295:                       float *residue,
16295:                       int sliding_lowpass){
16295: 
16295:   int i,n=p->n;
16295: 
16295:   if(sliding_lowpass>n)sliding_lowpass=n;
16295: 
16295:   for(i=0;i<sliding_lowpass;i++){
16295:     residue[i]=
16295:       mdct[i]*FLOOR1_fromdB_INV_LOOKUP[codedflr[i]];
16295:   }
16295: 
16295:   for(;i<n;i++)
16295:     residue[i]=0.;
16295: }
16295: 
16295: void _vp_noisemask(vorbis_look_psy *p,
16295:                    float *logmdct,
16295:                    float *logmask){
16295: 
16295:   int i,n=p->n;
16295:   float *work=alloca(n*sizeof(*work));
16295: 
16295:   bark_noise_hybridmp(n,p->bark,logmdct,logmask,
16295:                       140.,-1);
16295: 
16295:   for(i=0;i<n;i++)work[i]=logmdct[i]-logmask[i];
16295: 
16295:   bark_noise_hybridmp(n,p->bark,work,logmask,0.,
16295:                       p->vi->noisewindowfixed);
16295: 
16295:   for(i=0;i<n;i++)work[i]=logmdct[i]-work[i];
16295: 
16295: #if 0
16295:   {
16295:     static int seq=0;
16295: 
16295:     float work2[n];
16295:     for(i=0;i<n;i++){
16295:       work2[i]=logmask[i]+work[i];
16295:     }
16295: 
16295:     if(seq&1)
16295:       _analysis_output("median2R",seq/2,work,n,1,0,0);
16295:     else
16295:       _analysis_output("median2L",seq/2,work,n,1,0,0);
16295: 
16295:     if(seq&1)
16295:       _analysis_output("envelope2R",seq/2,work2,n,1,0,0);
16295:     else
16295:       _analysis_output("envelope2L",seq/2,work2,n,1,0,0);
16295:     seq++;
16295:   }
16295: #endif
16295: 
16295:   for(i=0;i<n;i++){
16295:     int dB=logmask[i]+.5;
16295:     if(dB>=NOISE_COMPAND_LEVELS)dB=NOISE_COMPAND_LEVELS-1;
16295:     if(dB<0)dB=0;
16295:     logmask[i]= work[i]+p->vi->noisecompand[dB];
16295:   }
16295: 
16295: }
16295: 
16295: void _vp_tonemask(vorbis_look_psy *p,
16295:                   float *logfft,
16295:                   float *logmask,
16295:                   float global_specmax,
16295:                   float local_specmax){
16295: 
16295:   int i,n=p->n;
16295: 
16295:   float *seed=alloca(sizeof(*seed)*p->total_octave_lines);
16295:   float att=local_specmax+p->vi->ath_adjatt;
16295:   for(i=0;i<p->total_octave_lines;i++)seed[i]=NEGINF;
16295: 
16295:   /* set the ATH (floating below localmax, not global max by a
16295:      specified att) */
16295:   if(att<p->vi->ath_maxatt)att=p->vi->ath_maxatt;
16295: 
16295:   for(i=0;i<n;i++)
16295:     logmask[i]=p->ath[i]+att;
16295: 
16295:   /* tone masking */
16295:   seed_loop(p,(const float ***)p->tonecurves,logfft,logmask,seed,global_specmax);
16295:   max_seeds(p,seed,logmask);
16295: 
16295: }
16295: 
16295: void _vp_offset_and_mix(vorbis_look_psy *p,
16295:                         float *noise,
16295:                         float *tone,
16295:                         int offset_select,
16295:                         float *logmask,
16295:                         float *mdct,
16295:                         float *logmdct){
16295:   int i,n=p->n;
16295:   float de, coeffi, cx;/* AoTuV */
16295:   float toneatt=p->vi->tone_masteratt[offset_select];
16295: 
16295:   cx = p->m_val;
16295: 
16295:   for(i=0;i<n;i++){
16295:     float val= noise[i]+p->noiseoffset[offset_select][i];
16295:     if(val>p->vi->noisemaxsupp)val=p->vi->noisemaxsupp;
16295:     logmask[i]=max(val,tone[i]+toneatt);
16295: 
16295: 
16295:     /* AoTuV */
16295:     /** @ M1 **
16295:         The following codes improve a noise problem.
16295:         A fundamental idea uses the value of masking and carries out
16295:         the relative compensation of the MDCT.
16295:         However, this code is not perfect and all noise problems cannot be solved.
16295:         by Aoyumi @ 2004/04/18
16295:     */
16295: 
16295:     if(offset_select == 1) {
16295:       coeffi = -17.2;       /* coeffi is a -17.2dB threshold */
16295:       val = val - logmdct[i];  /* val == mdct line value relative to floor in dB */
16295: 
16295:       if(val > coeffi){
16295:         /* mdct value is > -17.2 dB below floor */
16295: 
16295:         de = 1.0-((val-coeffi)*0.005*cx);
16295:         /* pro-rated attenuation:
16295:            -0.00 dB boost if mdct value is -17.2dB (relative to floor)
16295:            -0.77 dB boost if mdct value is 0dB (relative to floor)
16295:            -1.64 dB boost if mdct value is +17.2dB (relative to floor)
16295:            etc... */
16295: 
16295:         if(de < 0) de = 0.0001;
16295:       }else
16295:         /* mdct value is <= -17.2 dB below floor */
16295: 
16295:         de = 1.0-((val-coeffi)*0.0003*cx);
16295:       /* pro-rated attenuation:
16295:          +0.00 dB atten if mdct value is -17.2dB (relative to floor)
16295:          +0.45 dB atten if mdct value is -34.4dB (relative to floor)
16295:          etc... */
16295: 
16295:       mdct[i] *= de;
16295: 
16295:     }
16295:   }
16295: }
16295: 
16295: float _vp_ampmax_decay(float amp,vorbis_dsp_state *vd){
16295:   vorbis_info *vi=vd->vi;
16295:   codec_setup_info *ci=vi->codec_setup;
16295:   vorbis_info_psy_global *gi=&ci->psy_g_param;
16295: 
16295:   int n=ci->blocksizes[vd->W]/2;
16295:   float secs=(float)n/vi->rate;
16295: 
16295:   amp+=secs*gi->ampmax_att_per_sec;
16295:   if(amp<-9999)amp=-9999;
16295:   return(amp);
16295: }
16295: 
16295: static void couple_lossless(float A, float B,
16295:                             float *qA, float *qB){
16295:   int test1=fabs(*qA)>fabs(*qB);
16295:   test1-= fabs(*qA)<fabs(*qB);
16295: 
16295:   if(!test1)test1=((fabs(A)>fabs(B))<<1)-1;
16295:   if(test1==1){
16295:     *qB=(*qA>0.f?*qA-*qB:*qB-*qA);
16295:   }else{
16295:     float temp=*qB;
16295:     *qB=(*qB>0.f?*qA-*qB:*qB-*qA);
16295:     *qA=temp;
16295:   }
16295: 
16295:   if(*qB>fabs(*qA)*1.9999f){
16295:     *qB= -fabs(*qA)*2.f;
16295:     *qA= -*qA;
16295:   }
16295: }
16295: 
30043: static const float hypot_lookup[32]={
16295:   -0.009935, -0.011245, -0.012726, -0.014397,
16295:   -0.016282, -0.018407, -0.020800, -0.023494,
16295:   -0.026522, -0.029923, -0.033737, -0.038010,
16295:   -0.042787, -0.048121, -0.054064, -0.060671,
16295:   -0.068000, -0.076109, -0.085054, -0.094892,
16295:   -0.105675, -0.117451, -0.130260, -0.144134,
16295:   -0.159093, -0.175146, -0.192286, -0.210490,
16295:   -0.229718, -0.249913, -0.271001, -0.292893};
16295: 
16295: static void precomputed_couple_point(float premag,
16295:                                      int floorA,int floorB,
16295:                                      float *mag, float *ang){
16295: 
16295:   int test=(floorA>floorB)-1;
16295:   int offset=31-abs(floorA-floorB);
16295:   float floormag=hypot_lookup[((offset<0)-1)&offset]+1.f;
16295: 
16295:   floormag*=FLOOR1_fromdB_INV_LOOKUP[(floorB&test)|(floorA&(~test))];
16295: 
16295:   *mag=premag*floormag;
16295:   *ang=0.f;
16295: }
16295: 
16295: /* just like below, this is currently set up to only do
16295:    single-step-depth coupling.  Otherwise, we'd have to do more
16295:    copying (which will be inevitable later) */
16295: 
16295: /* doing the real circular magnitude calculation is audibly superior
16295:    to (A+B)/sqrt(2) */
16295: static float dipole_hypot(float a, float b){
16295:   if(a>0.){
16295:     if(b>0.)return sqrt(a*a+b*b);
16295:     if(a>-b)return sqrt(a*a-b*b);
16295:     return -sqrt(b*b-a*a);
16295:   }
16295:   if(b<0.)return -sqrt(a*a+b*b);
16295:   if(-a>b)return -sqrt(a*a-b*b);
16295:   return sqrt(b*b-a*a);
16295: }
16295: static float round_hypot(float a, float b){
16295:   if(a>0.){
16295:     if(b>0.)return sqrt(a*a+b*b);
16295:     if(a>-b)return sqrt(a*a+b*b);
16295:     return -sqrt(b*b+a*a);
16295:   }
16295:   if(b<0.)return -sqrt(a*a+b*b);
16295:   if(-a>b)return -sqrt(a*a+b*b);
16295:   return sqrt(b*b+a*a);
16295: }
16295: 
16295: /* revert to round hypot for now */
16295: float **_vp_quantize_couple_memo(vorbis_block *vb,
16295:                                  vorbis_info_psy_global *g,
16295:                                  vorbis_look_psy *p,
16295:                                  vorbis_info_mapping0 *vi,
16295:                                  float **mdct){
16295: 
16295:   int i,j,n=p->n;
16295:   float **ret=_vorbis_block_alloc(vb,vi->coupling_steps*sizeof(*ret));
16295:   int limit=g->coupling_pointlimit[p->vi->blockflag][PACKETBLOBS/2];
16295: 
16295:   for(i=0;i<vi->coupling_steps;i++){
16295:     float *mdctM=mdct[vi->coupling_mag[i]];
16295:     float *mdctA=mdct[vi->coupling_ang[i]];
16295:     ret[i]=_vorbis_block_alloc(vb,n*sizeof(**ret));
16295:     for(j=0;j<limit;j++)
16295:       ret[i][j]=dipole_hypot(mdctM[j],mdctA[j]);
16295:     for(;j<n;j++)
16295:       ret[i][j]=round_hypot(mdctM[j],mdctA[j]);
16295:   }
16295: 
16295:   return(ret);
16295: }
16295: 
16295: /* this is for per-channel noise normalization */
16295: static int apsort(const void *a, const void *b){
16295:   float f1=fabs(**(float**)a);
16295:   float f2=fabs(**(float**)b);
16295:   return (f1<f2)-(f1>f2);
16295: }
16295: 
16295: int **_vp_quantize_couple_sort(vorbis_block *vb,
16295:                                vorbis_look_psy *p,
16295:                                vorbis_info_mapping0 *vi,
16295:                                float **mags){
16295: 
16295: 
16295:   if(p->vi->normal_point_p){
16295:     int i,j,k,n=p->n;
16295:     int **ret=_vorbis_block_alloc(vb,vi->coupling_steps*sizeof(*ret));
16295:     int partition=p->vi->normal_partition;
16295:     float **work=alloca(sizeof(*work)*partition);
16295: 
16295:     for(i=0;i<vi->coupling_steps;i++){
16295:       ret[i]=_vorbis_block_alloc(vb,n*sizeof(**ret));
16295: 
16295:       for(j=0;j<n;j+=partition){
16295:         for(k=0;k<partition;k++)work[k]=mags[i]+k+j;
16295:         qsort(work,partition,sizeof(*work),apsort);
16295:         for(k=0;k<partition;k++)ret[i][k+j]=work[k]-mags[i];
16295:       }
16295:     }
16295:     return(ret);
16295:   }
16295:   return(NULL);
16295: }
16295: 
16295: void _vp_noise_normalize_sort(vorbis_look_psy *p,
16295:                               float *magnitudes,int *sortedindex){
16295:   int i,j,n=p->n;
16295:   vorbis_info_psy *vi=p->vi;
16295:   int partition=vi->normal_partition;
16295:   float **work=alloca(sizeof(*work)*partition);
16295:   int start=vi->normal_start;
16295: 
16295:   for(j=start;j<n;j+=partition){
16295:     if(j+partition>n)partition=n-j;
16295:     for(i=0;i<partition;i++)work[i]=magnitudes+i+j;
16295:     qsort(work,partition,sizeof(*work),apsort);
16295:     for(i=0;i<partition;i++){
16295:       sortedindex[i+j-start]=work[i]-magnitudes;
16295:     }
16295:   }
16295: }
16295: 
16295: void _vp_noise_normalize(vorbis_look_psy *p,
16295:                          float *in,float *out,int *sortedindex){
16295:   int flag=0,i,j=0,n=p->n;
16295:   vorbis_info_psy *vi=p->vi;
16295:   int partition=vi->normal_partition;
16295:   int start=vi->normal_start;
16295: 
16295:   if(start>n)start=n;
16295: 
16295:   if(vi->normal_channel_p){
16295:     for(;j<start;j++)
16295:       out[j]=rint(in[j]);
16295: 
16295:     for(;j+partition<=n;j+=partition){
16295:       float acc=0.;
16295:       int k;
16295: 
16295:       for(i=j;i<j+partition;i++)
16295:         acc+=in[i]*in[i];
16295: 
16295:       for(i=0;i<partition;i++){
16295:         k=sortedindex[i+j-start];
16295: 
16295:         if(in[k]*in[k]>=.25f){
16295:           out[k]=rint(in[k]);
16295:           acc-=in[k]*in[k];
16295:           flag=1;
16295:         }else{
16295:           if(acc<vi->normal_thresh)break;
16295:           out[k]=unitnorm(in[k]);
16295:           acc-=1.;
16295:         }
16295:       }
16295: 
16295:       for(;i<partition;i++){
16295:         k=sortedindex[i+j-start];
16295:         out[k]=0.;
16295:       }
16295:     }
16295:   }
16295: 
16295:   for(;j<n;j++)
16295:     out[j]=rint(in[j]);
16295: 
16295: }
16295: 
16295: void _vp_couple(int blobno,
16295:                 vorbis_info_psy_global *g,
16295:                 vorbis_look_psy *p,
16295:                 vorbis_info_mapping0 *vi,
16295:                 float **res,
16295:                 float **mag_memo,
16295:                 int   **mag_sort,
16295:                 int   **ifloor,
16295:                 int   *nonzero,
16295:                 int  sliding_lowpass){
16295: 
16295:   int i,j,k,n=p->n;
16295: 
16295:   /* perform any requested channel coupling */
16295:   /* point stereo can only be used in a first stage (in this encoder)
16295:      because of the dependency on floor lookups */
16295:   for(i=0;i<vi->coupling_steps;i++){
16295: 
16295:     /* once we're doing multistage coupling in which a channel goes
16295:        through more than one coupling step, the floor vector
16295:        magnitudes will also have to be recalculated an propogated
16295:        along with PCM.  Right now, we're not (that will wait until 5.1
16295:        most likely), so the code isn't here yet. The memory management
16295:        here is all assuming single depth couplings anyway. */
16295: 
16295:     /* make sure coupling a zero and a nonzero channel results in two
16295:        nonzero channels. */
16295:     if(nonzero[vi->coupling_mag[i]] ||
16295:        nonzero[vi->coupling_ang[i]]){
16295: 
16295: 
16295:       float *rM=res[vi->coupling_mag[i]];
16295:       float *rA=res[vi->coupling_ang[i]];
16295:       float *qM=rM+n;
16295:       float *qA=rA+n;
16295:       int *floorM=ifloor[vi->coupling_mag[i]];
16295:       int *floorA=ifloor[vi->coupling_ang[i]];
16295:       float prepoint=stereo_threshholds[g->coupling_prepointamp[blobno]];
16295:       float postpoint=stereo_threshholds[g->coupling_postpointamp[blobno]];
16295:       int partition=(p->vi->normal_point_p?p->vi->normal_partition:p->n);
16295:       int limit=g->coupling_pointlimit[p->vi->blockflag][blobno];
16295:       int pointlimit=limit;
16295: 
16295:       nonzero[vi->coupling_mag[i]]=1;
16295:       nonzero[vi->coupling_ang[i]]=1;
16295: 
16295:        /* The threshold of a stereo is changed with the size of n */
16295:        if(n > 1000)
16295:          postpoint=stereo_threshholds_limited[g->coupling_postpointamp[blobno]];
16295: 
16295:       for(j=0;j<p->n;j+=partition){
16295:         float acc=0.f;
16295: 
16295:         for(k=0;k<partition;k++){
16295:           int l=k+j;
16295: 
16295:           if(l<sliding_lowpass){
16295:             if((l>=limit && fabs(rM[l])<postpoint && fabs(rA[l])<postpoint) ||
16295:                (fabs(rM[l])<prepoint && fabs(rA[l])<prepoint)){
16295: 
16295: 
16295:               precomputed_couple_point(mag_memo[i][l],
16295:                                        floorM[l],floorA[l],
16295:                                        qM+l,qA+l);
16295: 
16295:               if(rint(qM[l])==0.f)acc+=qM[l]*qM[l];
16295:             }else{
16295:               couple_lossless(rM[l],rA[l],qM+l,qA+l);
16295:             }
16295:           }else{
16295:             qM[l]=0.;
16295:             qA[l]=0.;
16295:           }
16295:         }
16295: 
16295:         if(p->vi->normal_point_p){
16295:           for(k=0;k<partition && acc>=p->vi->normal_thresh;k++){
16295:             int l=mag_sort[i][j+k];
16295:             if(l<sliding_lowpass && l>=pointlimit && rint(qM[l])==0.f){
16295:               qM[l]=unitnorm(qM[l]);
16295:               acc-=1.f;
16295:             }
16295:           }
16295:         }
16295:       }
16295:     }
16295:   }
16295: }
16295: 
16295: /* AoTuV */
16295: /** @ M2 **
16295:    The boost problem by the combination of noise normalization and point stereo is eased.
16295:    However, this is a temporary patch.
16295:    by Aoyumi @ 2004/04/18
16295: */
16295: 
16295: void hf_reduction(vorbis_info_psy_global *g,
16295:                       vorbis_look_psy *p,
16295:                       vorbis_info_mapping0 *vi,
16295:                       float **mdct){
16295: 
16295:   int i,j,n=p->n, de=0.3*p->m_val;
16295:   int limit=g->coupling_pointlimit[p->vi->blockflag][PACKETBLOBS/2];
16295: 
16295:   for(i=0; i<vi->coupling_steps; i++){
16295:     /* for(j=start; j<limit; j++){} // ???*/
16295:     for(j=limit; j<n; j++)
16295:       mdct[i][j] *= (1.0 - de*((float)(j-limit) / (float)(n-limit)));
16295:   }
16295: }
