 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsCRLManager.h"
     1: #include "nsCRLInfo.h"
     1: 
     1: #include "nsCOMPtr.h"
     1: #include "nsComponentManagerUtils.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsNSSComponent.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsICertificateDialogs.h"
     1: #include "nsIMutableArray.h"
     1: #include "nsIPrefService.h"
     1: #include "nsIPrefBranch.h"
     1: #include "nsNSSShutDown.h"
 81303: #include "nsThreadUtils.h"
     1: 
     1: #include "nsNSSCertHeader.h"
     1: 
     1: #include "nspr.h"
119832: extern "C" {
     1: #include "pk11func.h"
     1: #include "certdb.h"
     1: #include "cert.h"
     1: #include "secerr.h"
     1: #include "nssb64.h"
     1: #include "secasn1.h"
     1: #include "secder.h"
119832: }
     1: #include "ssl.h"
     1: #include "ocsp.h"
     1: #include "plbase64.h"
     1: 
     1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
     1: 
     1: NS_IMPL_ISUPPORTS1(nsCRLManager, nsICRLManager)
     1: 
     1: nsCRLManager::nsCRLManager()
     1: {
     1: }
     1: 
     1: nsCRLManager::~nsCRLManager()
     1: {
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsCRLManager::ImportCrl (uint8_t *aData, uint32_t aLength, nsIURI * aURI, uint32_t aType, bool doSilentDownload, const PRUnichar* crlKey)
     1: {
 81303:   if (!NS_IsMainThread()) {
 81303:     NS_ERROR("nsCRLManager::ImportCrl called off the main thread");
 81303:     return NS_ERROR_NOT_SAME_THREAD;
 81303:   }
 81303:   
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv;
119832:   PLArenaPool *arena = NULL;
     1:   CERTCertificate *caCert;
119832:   SECItem derName = { siBuffer, NULL, 0 };
     1:   SECItem derCrl;
     1:   CERTSignedData sd;
     1:   SECStatus sec_rv;
     1:   CERTSignedCrl *crl;
110974:   nsAutoCString url;
     1:   nsCOMPtr<nsICRLInfo> crlData;
 79445:   bool importSuccessful;
108991:   int32_t errorCode;
     1:   nsString errorMessage;
     1:   
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if (NS_FAILED(rv)) return rv;
     1: 	         
     1:   aURI->GetSpec(url);
     1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     1:   if (!arena) {
     1:     goto loser;
     1:   }
     1:   memset(&sd, 0, sizeof(sd));
     1: 
     1:   derCrl.data = (unsigned char*)aData;
     1:   derCrl.len = aLength;
     1:   sec_rv = CERT_KeyFromDERCrl(arena, &derCrl, &derName);
     1:   if (sec_rv != SECSuccess) {
     1:     goto loser;
     1:   }
     1: 
     1:   caCert = CERT_FindCertByName(CERT_GetDefaultCertDB(), &derName);
     1:   if (!caCert) {
     1:     if (aType == SEC_KRL_TYPE){
     1:       goto loser;
     1:     }
     1:   } else {
     1:     sec_rv = SEC_ASN1DecodeItem(arena,
     1:                             &sd, SEC_ASN1_GET(CERT_SignedDataTemplate), 
     1:                             &derCrl);
     1:     if (sec_rv != SECSuccess) {
     1:       goto loser;
     1:     }
     1:     sec_rv = CERT_VerifySignedData(&sd, caCert, PR_Now(),
106838:                                nullptr);
     1:     if (sec_rv != SECSuccess) {
     1:       goto loser;
     1:     }
     1:   }
     1:   
  3233:   crl = SEC_NewCrl(CERT_GetDefaultCertDB(), const_cast<char*>(url.get()), &derCrl,
     1:                    aType);
     1:   
     1:   if (!crl) {
     1:     goto loser;
     1:   }
     1: 
     1:   crlData = new nsCRLInfo(crl);
     1:   SSL_ClearSessionCache();
     1:   SEC_DestroyCrl(crl);
     1:   
 80486:   importSuccessful = true;
     1:   goto done;
     1: 
     1: loser:
 80486:   importSuccessful = false;
     1:   errorCode = PR_GetError();
     1:   switch (errorCode) {
     1:     case SEC_ERROR_CRL_EXPIRED:
     1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureExpired", errorMessage);
     1:       break;
     1: 
     1: 	case SEC_ERROR_CRL_BAD_SIGNATURE:
     1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureBadSignature", errorMessage);
     1:       break;
     1: 
     1: 	case SEC_ERROR_CRL_INVALID:
     1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureInvalid", errorMessage);
     1:       break;
     1: 
     1: 	case SEC_ERROR_OLD_CRL:
     1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureOld", errorMessage);
     1:       break;
     1: 
     1: 	case SEC_ERROR_CRL_NOT_YET_VALID:
     1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureNotYetValid", errorMessage);
     1:       break;
     1: 
     1:     default:
     1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureReasonUnknown", errorMessage);
     1:       errorMessage.AppendInt(errorCode,16);
     1:       break;
     1:   }
     1: 
     1: done:
     1:           
 67654:   if(!doSilentDownload){
     1:     if (!importSuccessful){
     1:       nsString message;
     1:       nsString temp;
  4289:       nssComponent->GetPIPNSSBundleString("CrlImportFailure1x", message);
     1:       message.Append(NS_LITERAL_STRING("\n").get());
     1:       message.Append(errorMessage);
     1:       nssComponent->GetPIPNSSBundleString("CrlImportFailure2", temp);
     1:       message.Append(NS_LITERAL_STRING("\n").get());
     1:       message.Append(temp);
     1: 
 81303:       nsNSSComponent::ShowAlertWithConstructedString(message);
     1:     } else {
     1:       nsCOMPtr<nsICertificateDialogs> certDialogs;
     1:       // Not being able to display the success dialog should not
     1:       // be a fatal error, so don't return a failure code.
     1:       {
     1:         nsPSMUITracker tracker;
     1:         if (tracker.isUIForbidden()) {
     1:           rv = NS_ERROR_NOT_AVAILABLE;
     1:         }
     1:         else {
     1:           rv = ::getNSSDialogs(getter_AddRefs(certDialogs),
     1:             NS_GET_IID(nsICertificateDialogs), NS_CERTIFICATEDIALOGS_CONTRACTID);
     1:         }
     1:       }
     1:       if (NS_SUCCEEDED(rv)) {
     1:         nsCOMPtr<nsIInterfaceRequestor> cxt = new PipUIContext();
     1:         certDialogs->CrlImportStatusDialog(cxt, crlData);
     1:       }
     1:     }
     1:   } else {
119832:     if(crlKey == nullptr){
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:     nsCOMPtr<nsIPrefService> prefSvc = do_GetService(NS_PREFSERVICE_CONTRACTID,&rv);
     1:     nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID,&rv);
     1:     if (NS_FAILED(rv)){
     1:       return rv;
     1:     }
     1:     
110974:     nsAutoCString updateErrCntPrefStr(CRL_AUTOUPDATE_ERRCNT_PREF);
103796:     LossyAppendUTF16toASCII(crlKey, updateErrCntPrefStr);
     1:     if(importSuccessful){
     1:       PRUnichar *updateTime;
110974:       nsAutoCString updateTimeStr;
     1:       nsCString updateURL;
108991:       int32_t timingTypePref;
     1:       double dayCnt;
     1:       char *dayCntStr;
110974:       nsAutoCString updateTypePrefStr(CRL_AUTOUPDATE_TIMIINGTYPE_PREF);
110974:       nsAutoCString updateTimePrefStr(CRL_AUTOUPDATE_TIME_PREF);
110974:       nsAutoCString updateUrlPrefStr(CRL_AUTOUPDATE_URL_PREF);
110974:       nsAutoCString updateDayCntPrefStr(CRL_AUTOUPDATE_DAYCNT_PREF);
110974:       nsAutoCString updateFreqCntPrefStr(CRL_AUTOUPDATE_FREQCNT_PREF);
103796:       LossyAppendUTF16toASCII(crlKey, updateTypePrefStr);
103796:       LossyAppendUTF16toASCII(crlKey, updateTimePrefStr);
103796:       LossyAppendUTF16toASCII(crlKey, updateUrlPrefStr);
103796:       LossyAppendUTF16toASCII(crlKey, updateDayCntPrefStr);
103796:       LossyAppendUTF16toASCII(crlKey, updateFreqCntPrefStr);
     1: 
     1:       pref->GetIntPref(updateTypePrefStr.get(),&timingTypePref);
     1:       
     1:       //Compute and update the next download instant
     1:       if(timingTypePref == TYPE_AUTOUPDATE_TIME_BASED){
     1:         pref->GetCharPref(updateDayCntPrefStr.get(),&dayCntStr);
     1:       }else{
     1:         pref->GetCharPref(updateFreqCntPrefStr.get(),&dayCntStr);
     1:       }
     1:       dayCnt = atof(dayCntStr);
     1:       nsMemory::Free(dayCntStr);
     1: 
 79445:       bool toBeRescheduled = false;
     1:       if(NS_SUCCEEDED(ComputeNextAutoUpdateTime(crlData, timingTypePref, dayCnt, &updateTime))){
     1:         updateTimeStr.AssignWithConversion(updateTime);
     1:         pref->SetCharPref(updateTimePrefStr.get(),updateTimeStr.get());
     1:         //Now, check if this update time is already in the past. This would
     1:         //imply we have downloaded the same crl, or there is something wrong
     1:         //with the next update date. We will not reschedule this crl in this
     1:         //session anymore - or else, we land into a loop. It would anyway be
     1:         //imported once the browser is restarted.
115938:         if(int64_t(updateTime) > int64_t(PR_Now())){
 80486:           toBeRescheduled = true;
     1:         }
 93962:         nsMemory::Free(updateTime);
     1:       }
     1:       
     1:       //Update the url to download from, next time
     1:       crlData->GetLastFetchURL(updateURL);
     1:       pref->SetCharPref(updateUrlPrefStr.get(),updateURL.get());
     1:       
     1:       pref->SetIntPref(updateErrCntPrefStr.get(),0);
     1:       
 17116:       if (toBeRescheduled) {
     1:         nsAutoString hashKey(crlKey);
     1:         nssComponent->RemoveCrlFromList(hashKey);
     1:         nssComponent->DefineNextTimer();
     1:       }
     1: 
     1:     } else{
108991:       int32_t errCnt;
110974:       nsAutoCString errMsg;
110974:       nsAutoCString updateErrDetailPrefStr(CRL_AUTOUPDATE_ERRDETAIL_PREF);
103796:       LossyAppendUTF16toASCII(crlKey, updateErrDetailPrefStr);
     1:       errMsg.AssignWithConversion(errorMessage.get());
     1:       rv = pref->GetIntPref(updateErrCntPrefStr.get(),&errCnt);
     1:       if(NS_FAILED(rv))
     1:         errCnt = 0;
     1: 
     1:       pref->SetIntPref(updateErrCntPrefStr.get(),errCnt+1);
     1:       pref->SetCharPref(updateErrDetailPrefStr.get(),errMsg.get());
     1:     }
106838:     prefSvc->SavePrefFile(nullptr);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: nsCRLManager::UpdateCRLFromURL( const PRUnichar *url, const PRUnichar* key, bool *res)
     1: {
     1:   nsresult rv;
     1:   nsAutoString downloadUrl(url);
     1:   nsAutoString dbKey(key);
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if(NS_FAILED(rv)){
 80486:     *res = false;
     1:     return rv;
     1:   }
     1: 
     1:   rv = nssComponent->DownloadCRLDirectly(downloadUrl, dbKey);
     1:   if(NS_FAILED(rv)){
 80486:     *res = false;
     1:   } else {
 80486:     *res = true;
     1:   }
     1:   return NS_OK;
     1: 
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsCRLManager::RescheduleCRLAutoUpdate(void)
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if(NS_FAILED(rv)){
     1:     return rv;
     1:   }
     1:   rv = nssComponent->DefineNextTimer();
     1:   return rv;
     1: }
     1: 
 67655: /**
     1:  * getCRLs
     1:  *
     1:  * Export a set of certs and keys from the database to a PKCS#12 file.
     1:  */
     1: NS_IMETHODIMP 
     1: nsCRLManager::GetCrls(nsIArray ** aCrls)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   SECStatus sec_rv;
106838:   CERTCrlHeadNode *head = nullptr;
106838:   CERTCrlNode *node = nullptr;
     1:   nsresult rv;
     1:   nsCOMPtr<nsIMutableArray> crlsArray =
     1:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
     1:   // Get the list of certs //
     1:   sec_rv = SEC_LookupCrls(CERT_GetDefaultCertDB(), &head, -1);
     1:   if (sec_rv != SECSuccess) {
 67656:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   if (head) {
119832:     for (node=head->first; node != nullptr; node = node->next) {
     1: 
     1:       nsCOMPtr<nsICRLInfo> entry = new nsCRLInfo((node->crl));
 80486:       crlsArray->AppendElement(entry, false);
     1:     }
 80486:     PORT_FreeArena(head->arena, false);
     1:   }
     1: 
     1:   *aCrls = crlsArray;
     1:   NS_IF_ADDREF(*aCrls);
     1:   return NS_OK;
     1: }
     1: 
 67655: /**
 67655:  * deleteCrl
     1:  *
     1:  * Delete a Crl entry from the cert db.
     1:  */
     1: NS_IMETHODIMP 
108991: nsCRLManager::DeleteCrl(uint32_t aCrlIndex)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
106838:   CERTSignedCrl *realCrl = nullptr;
106838:   CERTCrlHeadNode *head = nullptr;
106838:   CERTCrlNode *node = nullptr;
     1:   SECStatus sec_rv;
108991:   uint32_t i;
     1: 
     1:   // Get the list of certs //
     1:   sec_rv = SEC_LookupCrls(CERT_GetDefaultCertDB(), &head, -1);
     1:   if (sec_rv != SECSuccess) {
 67656:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   if (head) {
119832:     for (i = 0, node=head->first; node != nullptr; i++, node = node->next) {
     1:       if (i != aCrlIndex) {
     1:         continue;
     1:       }
     1:       realCrl = SEC_FindCrlByName(CERT_GetDefaultCertDB(), &(node->crl->crl.derName), node->type);
     1:       SEC_DeletePermCRL(realCrl);
     1:       SEC_DestroyCrl(realCrl);
     1:       SSL_ClearSessionCache();
     1:     }
 80486:     PORT_FreeArena(head->arena, false);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCRLManager::ComputeNextAutoUpdateTime(nsICRLInfo *info, 
108991:   uint32_t autoUpdateType, double dayCnt, PRUnichar **nextAutoUpdate)
     1: {
     1:   if (!info)
     1:     return NS_ERROR_FAILURE;
 93962:   NS_ENSURE_ARG_POINTER(nextAutoUpdate);
     1: 
     1:   PRTime microsecInDayCnt;
     1:   PRTime now = PR_Now();
     1:   PRTime tempTime;
108991:   int64_t diff = 0;
108991:   int64_t secsInDay = 86400UL;
108991:   int64_t temp;
108991:   int64_t cycleCnt = 0;
108991:   int64_t secsInDayCnt;
118767:   double tmpData = double(secsInDay);
118767:   tmpData *= dayCnt;
     1:   LL_F2L(secsInDayCnt,tmpData);
116195:   microsecInDayCnt = secsInDayCnt * PR_USEC_PER_SEC;
     1:     
     1:   PRTime lastUpdate;
     1:   PRTime nextUpdate;
     1:   
     1:   nsresult rv;
     1: 
     1:   rv = info->GetLastUpdate(&lastUpdate);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   rv = info->GetNextUpdate(&nextUpdate);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   switch (autoUpdateType) {
     1:   case TYPE_AUTOUPDATE_FREQ_BASED:
116194:     diff = now - lastUpdate;                    //diff is the no of micro sec between now and last update
116196:     cycleCnt = diff / microsecInDayCnt;       //temp is the number of full cycles from lst update
116197:     temp = diff % microsecInDayCnt;
115934:     if(temp != 0) {
116193:       ++cycleCnt;            //no of complete cycles till next autoupdate instant
     1:     }
116195:     temp = cycleCnt * microsecInDayCnt;    //micro secs from last update
116193:     tempTime = lastUpdate + temp;
     1:     break;  
     1:   case TYPE_AUTOUPDATE_TIME_BASED:
116194:     tempTime = nextUpdate - microsecInDayCnt;
     1:     break;
     1:   default:
     1:     return NS_ERROR_NOT_IMPLEMENTED;
     1:   }
     1: 
     1:   //Now, a basic constraing is that the next auto update date can never be after
     1:   //next update, if one is defined
115938:   if(nextUpdate > 0) {
115938:     if(tempTime > nextUpdate) {
     1:       tempTime = nextUpdate;
     1:     }
     1:   }
     1: 
 93962:   // Return value as string; no pref type for Int64/PRTime
 93962:   char *tempTimeStr = PR_smprintf("%lli", tempTime);
 93962:   *nextAutoUpdate = ToNewUnicode(nsDependentCString(tempTimeStr));
 93962:   PR_smprintf_free(tempTimeStr);
     1: 
     1:   return NS_OK;
     1: }
     1: 
