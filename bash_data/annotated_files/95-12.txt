 1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 1: /* ***** BEGIN LICENSE BLOCK *****
 1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 1:  *
 1:  * The contents of this file are subject to the Mozilla Public License Version
 1:  * 1.1 (the "License"); you may not use this file except in compliance with
 1:  * the License. You may obtain a copy of the License at
 1:  * http://www.mozilla.org/MPL/
 1:  *
 1:  * Software distributed under the License is distributed on an "AS IS" basis,
 1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 1:  * for the specific language governing rights and limitations under the
 1:  * License.
 1:  *
 1:  * The Original Code is mozilla.org code.
 1:  *
 1:  * The Initial Developer of the Original Code is
 1:  * Netscape Communications Corporation.
 1:  * Portions created by the Initial Developer are Copyright (C) 1998
 1:  * the Initial Developer. All Rights Reserved.
 1:  *
 1:  * Contributor(s):
 1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
 1:  *   Pierre Phaneuf <pp@ludusdesign.com>
 1:  *   Dean Tessman <dean_tessman@hotmail.com>
 1:  *
 1:  * Alternatively, the contents of this file may be used under the terms of
 1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 1:  * in which case the provisions of the GPL or the LGPL are applicable instead
 1:  * of those above. If you wish to allow use of your version of this file only
 1:  * under the terms of either the GPL or the LGPL, and not to allow others to
 1:  * use your version of this file under the terms of the MPL, indicate your
 1:  * decision by deleting the provisions above and replace them with the notice
 1:  * and other provisions required by the GPL or the LGPL. If you do not delete
 1:  * the provisions above, a recipient may use your version of this file under
 1:  * the terms of any one of the MPL, the GPL or the LGPL.
 1:  *
 1:  * ***** END LICENSE BLOCK ***** */
 1: 
 1: #include "nsGkAtoms.h"
 1: #include "nsPopupSetFrame.h"
 1: #include "nsIMenuParent.h"
 1: #include "nsMenuFrame.h"
 1: #include "nsBoxFrame.h"
 1: #include "nsIContent.h"
 1: #include "prtypes.h"
 1: #include "nsIAtom.h"
 1: #include "nsPresContext.h"
 1: #include "nsStyleContext.h"
 1: #include "nsCSSRendering.h"
 1: #include "nsINameSpaceManager.h"
 1: #include "nsMenuPopupFrame.h"
 1: #include "nsMenuBarFrame.h"
 1: #include "nsIView.h"
 1: #include "nsIWidget.h"
 1: #include "nsIDocument.h"
 1: #include "nsIDOMNSDocument.h"
 1: #include "nsIDOMDocument.h"
 1: #include "nsIDOMXULDocument.h"
 1: #include "nsIDOMElement.h"
 1: #include "nsISupportsArray.h"
 1: #include "nsIDOMText.h"
 1: #include "nsBoxLayoutState.h"
 1: #include "nsIScrollableFrame.h"
 1: #include "nsCSSFrameConstructor.h"
 1: #include "nsGUIEvent.h"
 1: #include "nsIRootBox.h"
 1: #include "nsIFocusController.h"
 1: #include "nsIDocShellTreeItem.h"
 1: #include "nsIDocShell.h"
 1: #include "nsPIDOMWindow.h"
 1: #include "nsIInterfaceRequestorUtils.h"
 1: #include "nsIBaseWindow.h"
 1: #include "nsIViewManager.h"
 1: 
 1: #define NS_MENU_POPUP_LIST_INDEX   0
 1: 
 1: nsPopupFrameList::nsPopupFrameList(nsIContent* aPopupContent, nsPopupFrameList* aNext)
 1: :mNextPopup(aNext), 
 1:  mPopupFrame(nsnull),
 1:  mPopupContent(aPopupContent),
 1:  mElementContent(nsnull), 
 1:  mCreateHandlerSucceeded(PR_FALSE),
 1:  mIsOpen(PR_FALSE),
 1:  mLastPref(-1,-1)
 1: {
 1: }
 1: 
 1: nsPopupFrameList* nsPopupFrameList::GetEntry(nsIContent* aPopupContent) {
 1:   if (aPopupContent == mPopupContent)
 1:     return this;
 1: 
 1:   if (mNextPopup)
 1:     return mNextPopup->GetEntry(aPopupContent);
 1: 
 1:   return nsnull;
 1: }
 1: 
 1: nsPopupFrameList* nsPopupFrameList::GetEntryByFrame(nsIFrame* aPopupFrame) {
 1:   if (aPopupFrame == mPopupFrame)
 1:     return this;
 1: 
 1:   if (mNextPopup)
 1:     return mNextPopup->GetEntryByFrame(aPopupFrame);
 1: 
 1:   return nsnull;
 1: }
 1: 
 1: //
 1: // NS_NewPopupSetFrame
 1: //
 1: // Wrapper for creating a new menu popup container
 1: //
 1: nsIFrame*
 1: NS_NewPopupSetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 1: {
 1:   return new (aPresShell) nsPopupSetFrame (aPresShell, aContext);
 1: }
 1: 
 1: NS_IMETHODIMP_(nsrefcnt) 
 1: nsPopupSetFrame::AddRef(void)
 1: {
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP_(nsrefcnt) 
 1: nsPopupSetFrame::Release(void)
 1: {
 1:     return NS_OK;
 1: }
 1: 
 1: //
 1: // QueryInterface
 1: //
 1: NS_INTERFACE_MAP_BEGIN(nsPopupSetFrame)
 1:   NS_INTERFACE_MAP_ENTRY(nsIPopupSetFrame)
 1: NS_INTERFACE_MAP_END_INHERITING(nsBoxFrame)
 1: 
 1: NS_IMETHODIMP
 1: nsPopupSetFrame::Init(nsIContent*      aContent,
 1:                       nsIFrame*        aParent,
 1:                       nsIFrame*        aPrevInFlow)
 1: {
 1:   nsresult  rv = nsBoxFrame::Init(aContent, aParent, aPrevInFlow);
 1: 
 1:   nsIRootBox *rootBox;
 1:   nsresult res = CallQueryInterface(aParent->GetParent(), &rootBox);
 1:   NS_ASSERTION(NS_SUCCEEDED(res), "grandparent should be root box");
 1:   if (NS_SUCCEEDED(res)) {
 1:     rootBox->SetPopupSetFrame(this);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsPopupSetFrame::AppendFrames(nsIAtom*        aListName,
 1:                               nsIFrame*       aFrameList)
 1: {
 1:   if (aListName == nsGkAtoms::popupList) {
 1:     return AddPopupFrameList(aFrameList);
 1:   }
 1:   return nsBoxFrame::AppendFrames(aListName, aFrameList);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsPopupSetFrame::RemoveFrame(nsIAtom*        aListName,
 1:                              nsIFrame*       aOldFrame)
 1: {
 1:   if (aListName == nsGkAtoms::popupList) {
 1:     return RemovePopupFrame(aOldFrame);
 1:   }
 1:   return nsBoxFrame::RemoveFrame(aListName, aOldFrame);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsPopupSetFrame::InsertFrames(nsIAtom*        aListName,
 1:                               nsIFrame*       aPrevFrame,
 1:                               nsIFrame*       aFrameList)
 1: {
 1:   if (aListName == nsGkAtoms::popupList) {
 1:     return AddPopupFrameList(aFrameList);
 1:   }
 1:   return nsBoxFrame::InsertFrames(aListName, aPrevFrame, aFrameList);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsPopupSetFrame::SetInitialChildList(nsIAtom*        aListName,
 1:                                      nsIFrame*       aChildList)
 1: {
 1:   if (aListName == nsGkAtoms::popupList) {
 1:     return AddPopupFrameList(aChildList);
 1:   }
 1:   return nsBoxFrame::SetInitialChildList(aListName, aChildList);
 1: }
 1: 
 1: void
 1: nsPopupSetFrame::Destroy()
 1: {
 1:   // Remove our frame list.
 1:   if (mPopupList) {
 1:     // Try to hide any active popups
 1:     if (nsMenuDismissalListener::sInstance) {
 1:       nsIMenuParent *menuParent =
 1:         nsMenuDismissalListener::sInstance->GetCurrentMenuParent();
 1:       nsIFrame* frame;
 1:       CallQueryInterface(menuParent, &frame);
 1:       // Rollup popups, but only if they're ours
 1:       if (frame && mPopupList->GetEntryByFrame(frame)) {
 1:         nsMenuDismissalListener::sInstance->Rollup();
 1:       }
 1:     }
 1: 
 1:     // Actually remove each popup from the list as we go. This
 1:     // keeps things consistent so reentering won't crash us
 1:     while (mPopupList) {
 1:       if (mPopupList->mPopupFrame) {
 1:         mPopupList->mPopupFrame->Destroy();
 1:       }
 1: 
 1:       nsPopupFrameList* temp = mPopupList;
 1:       mPopupList = mPopupList->mNextPopup;
 1:       delete temp;
 1:     }
 1:   }
 1: 
 1:   nsIRootBox *rootBox;
 1:   nsresult res = CallQueryInterface(mParent->GetParent(), &rootBox);
 1:   NS_ASSERTION(NS_SUCCEEDED(res), "grandparent should be root box");
 1:   if (NS_SUCCEEDED(res)) {
 1:     rootBox->SetPopupSetFrame(nsnull);
 1:   }
 1: 
 1:   nsBoxFrame::Destroy();
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsPopupSetFrame::DoLayout(nsBoxLayoutState& aState)
 1: {
 1:   // lay us out
 1:   nsresult rv = nsBoxFrame::DoLayout(aState);
 1: 
 1:   // lay out all of our currently open popups.
 1:   nsPopupFrameList* currEntry = mPopupList;
 1:   while (currEntry) {
 1:     nsIFrame* popupChild = currEntry->mPopupFrame;
 1:     if (popupChild) {
 1:       NS_ASSERTION(popupChild->IsBoxFrame(), "popupChild is not box!!");
 1: 
 1:       // then get its preferred size
 1:       nsSize prefSize = popupChild->GetPrefSize(aState);
 1:       nsSize minSize = popupChild->GetMinSize(aState);
 1:       nsSize maxSize = popupChild->GetMaxSize(aState);
 1: 
 1:       BoundsCheck(minSize, prefSize, maxSize);
 1: 
 1:       // if the pref size changed then set bounds to be the pref size
 1:       // and sync the view. Also set new pref size.
 1:      // if (currEntry->mLastPref != prefSize) {
 1:         popupChild->SetBounds(aState, nsRect(0,0,prefSize.width, prefSize.height));
 1:         RepositionPopup(currEntry, aState);
 1:         currEntry->mLastPref = prefSize;
 1:      // }
 1: 
 1:       // is the new size too small? Make sure we handle scrollbars correctly
 1:       nsIBox* child = popupChild->GetChildBox();
 1: 
 1:       nsRect bounds(popupChild->GetRect());
 1: 
 1:       nsCOMPtr<nsIScrollableFrame> scrollframe = do_QueryInterface(child);
 1:       if (scrollframe &&
 1:           scrollframe->GetScrollbarStyles().mVertical == NS_STYLE_OVERFLOW_AUTO) {
 1:         // if our pref height
 1:         if (bounds.height < prefSize.height) {
 1:           // layout the child
 1:           popupChild->Layout(aState);
 1: 
 1:           nsMargin scrollbars = scrollframe->GetActualScrollbarSizes();
 1:           if (bounds.width < prefSize.width + scrollbars.left + scrollbars.right)
 1:           {
 1:             bounds.width += scrollbars.left + scrollbars.right;
 1:             //printf("Width=%d\n",width);
 1:             popupChild->SetBounds(aState, bounds);
 1:           }
 1:         }
 1:       }
 1:     
 1:       // layout the child
 1:       popupChild->Layout(aState);
 1: 
 1:       // only size popup if open
 1:       if (currEntry->mCreateHandlerSucceeded) {
 1:         nsIView* view = popupChild->GetView();
 1:         nsIViewManager* viewManager = view->GetViewManager();
 1:         nsRect r(0, 0, bounds.width, bounds.height);
 1:         viewManager->ResizeView(view, r);
 1:         viewManager->SetViewVisibility(view, nsViewVisibility_kShow);
 1:       }
 1:     }
 1: 
 1:     currEntry = currEntry->mNextPopup;
 1:   }
 1: 
 1:   SyncLayout(aState);
 1: 
 1:   return rv;
 1: }
 1: 
 1: 
 1: #ifdef DEBUG_LAYOUT
 1: NS_IMETHODIMP
 1: nsPopupSetFrame::SetDebug(nsBoxLayoutState& aState, PRBool aDebug)
 1: {
 1:   // see if our state matches the given debug state
 1:   PRBool debugSet = mState & NS_STATE_CURRENTLY_IN_DEBUG;
 1:   PRBool debugChanged = (!aDebug && debugSet) || (aDebug && !debugSet);
 1: 
 1:   // if it doesn't then tell each child below us the new debug state
 1:   if (debugChanged)
 1:   {
 1:     // XXXdwh fix later.  nobody uses this anymore anyway.
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsPopupSetFrame::SetDebug(nsBoxLayoutState& aState, nsIFrame* aList, PRBool aDebug)
 1: {
 1:       if (!aList)
 1:           return NS_OK;
 1: 
 1:       while (aList) {
 1:         if (aList->IsBoxFrame())
 1:           aList->SetDebug(aState, aDebug);
 1: 
 1:         aList = aList->GetNextSibling();
 1:       }
 1: 
 1:       return NS_OK;
 1: }
 1: #endif
 1: 
 1: 
 1: void
 1: nsPopupSetFrame::RepositionPopup(nsPopupFrameList* aEntry, nsBoxLayoutState& aState)
 1: {
 1:   // Sync up the view.
 1:   if (aEntry && aEntry->mElementContent) {
 1:     nsPresContext* presContext = aState.PresContext();
 1:     nsIFrame* frameToSyncTo = presContext->PresShell()->
 1:       GetPrimaryFrameFor(aEntry->mElementContent);
 1:     ((nsMenuPopupFrame*)(aEntry->mPopupFrame))->SyncViewWithFrame(presContext, 
 1:           aEntry->mPopupAnchor, aEntry->mPopupAlign, frameToSyncTo, aEntry->mXPos, aEntry->mYPos);
 1:   }
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsPopupSetFrame::ShowPopup(nsIContent* aElementContent, nsIContent* aPopupContent, 
 1:                            PRInt32 aXPos, PRInt32 aYPos, 
 1:                            const nsString& aPopupType, const nsString& anAnchorAlignment,
 1:                            const nsString& aPopupAlignment)
 1: {
 1:   if (!MayOpenPopup(this))
 1:     return NS_OK;
 1: 
 1:   nsWeakFrame weakFrame(this);
 1:   // First fire the popupshowing event.
 1:   if (!OnCreate(aXPos, aYPos, aPopupContent) || !weakFrame.IsAlive())
 1:     return NS_OK;
 1:         
 1:   // See if we already have an entry in our list.  We must create a new one on a miss.
 1:   nsPopupFrameList* entry = nsnull;
 1:   if (mPopupList)
 1:     entry = mPopupList->GetEntry(aPopupContent);
 1:   if (!entry) {
 1:     entry = new nsPopupFrameList(aPopupContent, mPopupList);
 1:     if (!entry)
 1:       return NS_ERROR_OUT_OF_MEMORY;
 1:     mPopupList = entry;
 1:   }
 1: 
 1:   // Cache the element content we're supposed to sync to
 1:   entry->mPopupType = aPopupType;
 1:   entry->mElementContent = aElementContent;
 1:   entry->mPopupAlign = aPopupAlignment;
 1:   entry->mPopupAnchor = anAnchorAlignment;
 1:   entry->mXPos = aXPos;
 1:   entry->mYPos = aYPos;
 1: 
 1:   // If a frame exists already, go ahead and use it.
 1:   entry->mPopupFrame = GetPresContext()->PresShell()
 1:     ->GetPrimaryFrameFor(aPopupContent);
 1: 
 1: #ifdef DEBUG_PINK
 1:   printf("X Pos: %d\n", mXPos);
 1:   printf("Y Pos: %d\n", mYPos);
 1: #endif
 1: 
 1:   // Generate the popup.
 1:   entry->mCreateHandlerSucceeded = PR_TRUE;
 1:   entry->mIsOpen = PR_TRUE;
 1:   // This may destroy or change entry->mPopupFrame or remove the entry from
 1:   // mPopupList. |this| may also get deleted.
 1:   MarkAsGenerated(aPopupContent);
 1: 
 1:   if (!weakFrame.IsAlive()) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   nsPopupFrameList* newEntry =
 1:     mPopupList ? mPopupList->GetEntry(aPopupContent) : nsnull;
 1:   if (!newEntry || newEntry != entry) {
 1:     NS_WARNING("The popup entry for aPopupContent has changed!");
 1:     return NS_OK;
 1:   }
 1: 
 1:   // determine if this menu is a context menu and flag it
 1:   nsIMenuParent* childPopup = nsnull;
 1:   if (entry->mPopupFrame)
 1:     CallQueryInterface(entry->mPopupFrame, &childPopup);
 1:   if ( childPopup && aPopupType.EqualsLiteral("context") )
 1:     childPopup->SetIsContextMenu(PR_TRUE);
 1: 
 1:   // Now open the popup.
 1:   OpenPopup(entry, PR_TRUE);
 1:   
 1:   if (!weakFrame.IsAlive()) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   // Now fire the popupshown event.
 1:   OnCreated(aXPos, aYPos, aPopupContent);
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsPopupSetFrame::HidePopup(nsIFrame* aPopup)
 1: {
 1:   if (!mPopupList)
 1:     return NS_OK; // No active popups
 1: 
 1:   nsPopupFrameList* entry = mPopupList->GetEntryByFrame(aPopup);
 1:   if (!entry)
 1:     return NS_OK;
 1: 
 1:   if (entry->mCreateHandlerSucceeded)
 1:     ActivatePopup(entry, PR_FALSE);
 1: 
 1:   if (entry->mElementContent && entry->mPopupType.EqualsLiteral("context")) {
 1:     // If we are a context menu, and if we are attached to a
 1:     // menupopup, then hiding us should also hide the parent menu
 1:     // popup.
 1:     if (entry->mElementContent->Tag() == nsGkAtoms::menupopup) {
 1:       nsIFrame* popupFrame = GetPresContext()->PresShell()
 1:         ->GetPrimaryFrameFor(entry->mElementContent);
 1:       if (popupFrame) {
 1:         nsIMenuParent *menuParent;
 1:         if (NS_SUCCEEDED(CallQueryInterface(popupFrame, &menuParent))) {
 1:           menuParent->HideChain();
 1:         }
 1:       }
 1:     }
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsPopupSetFrame::DestroyPopup(nsIFrame* aPopup, PRBool aDestroyEntireChain)
 1: {
 1:   if (!mPopupList)
 1:     return NS_OK; // No active popups
 1: 
 1:   nsPopupFrameList* entry = mPopupList->GetEntryByFrame(aPopup);
 1: 
 1:   if (entry && entry->mCreateHandlerSucceeded) {    // ensure the popup was created before we try to destroy it
 1:     nsWeakFrame weakFrame(this);
 1:     OpenPopup(entry, PR_FALSE);
 1:     nsCOMPtr<nsIContent> popupContent = entry->mPopupContent;
 1:     if (weakFrame.IsAlive()) {
 1:       if (aDestroyEntireChain && entry->mElementContent && entry->mPopupType.EqualsLiteral("context")) {
 1:         // If we are a context menu, and if we are attached to a
 1:         // menupopup, then destroying us should also dismiss the parent
 1:         // menu popup.
 1:         if (entry->mElementContent->Tag() == nsGkAtoms::menupopup) {
 1:           nsIFrame* popupFrame = GetPresContext()->PresShell()
 1:             ->GetPrimaryFrameFor(entry->mElementContent);
 1:           if (popupFrame) {
 1:             nsIMenuParent *menuParent;
 1:             if (NS_SUCCEEDED(CallQueryInterface(popupFrame, &menuParent))) {
 1:               menuParent->DismissChain();
 1:             }
 1:           }
 1:         }
 1:       }
 1:   
 1:       // clear things out for next time
 1:       entry->mPopupType.Truncate();
 1:       entry->mCreateHandlerSucceeded = PR_FALSE;
 1:       entry->mElementContent = nsnull;
 1:       entry->mXPos = entry->mYPos = 0;
 1:       entry->mLastPref.width = -1;
 1:       entry->mLastPref.height = -1;
 1:     }
 1:     // ungenerate the popup.
 1:     popupContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::menugenerated, PR_TRUE);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: void
 1: nsPopupSetFrame::MarkAsGenerated(nsIContent* aPopupContent)
 1: {
 1:   // Set our attribute, but only if we aren't already generated.
 1:   // Retrieve the menugenerated attribute.
 1:   if (!aPopupContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::menugenerated,
 1:                                   nsGkAtoms::_true, eCaseMatters)) {
 1:     // Generate this element.
 1:     aPopupContent->SetAttr(kNameSpaceID_None, nsGkAtoms::menugenerated, NS_LITERAL_STRING("true"),
 1:                            PR_TRUE);
 1:   }
 1: }
 1: 
 1: void
 1: nsPopupSetFrame::OpenPopup(nsPopupFrameList* aEntry, PRBool aActivateFlag)
 1: {
 1:   nsWeakFrame weakFrame(this);
 1:   nsIFrame* activeChild = aEntry->mPopupFrame;
 1:   nsWeakFrame weakPopupFrame(activeChild);
 1:   nsRefPtr<nsPresContext> presContext = GetPresContext();
 1:   nsCOMPtr<nsIContent> popupContent = aEntry->mPopupContent;
 1:   PRBool createHandlerSucceeded = aEntry->mCreateHandlerSucceeded;
 1:   nsAutoString popupType = aEntry->mPopupType;
 1:   if (aActivateFlag) {
 1:     ActivatePopup(aEntry, PR_TRUE);
 1: 
 1:     // register the rollup listeners, etc, but not if we're a tooltip
 1:     if (!popupType.EqualsLiteral("tooltip")) {
 1:       nsIMenuParent* childPopup = nsnull;
 1:       if (weakPopupFrame.IsAlive())
 1:         CallQueryInterface(activeChild, &childPopup);
 1: 
 1:       // Tooltips don't get keyboard navigation
 1:       if (childPopup && !nsMenuDismissalListener::sInstance) {
 1:         // First check and make sure this popup wants keyboard navigation
 1:         if (!popupContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::ignorekeys,
 1:                                        nsGkAtoms::_true, eCaseMatters))
 1:           childPopup->InstallKeyboardNavigator();
 1:       }
 1: 
 1:       nsMenuDismissalListener* listener = nsMenuDismissalListener::GetInstance();
 1:       if (listener)
 1:         listener->SetCurrentMenuParent(childPopup);
 1:     }
 1:   }
 1:   else {
 1:     if (createHandlerSucceeded && !OnDestroy(popupContent))
 1:       return;
 1: 
 1:     // Unregister, but not if we're a tooltip
 1:     if (!popupType.EqualsLiteral("tooltip") ) {
 1:       nsMenuDismissalListener::Shutdown();
 1:     }
 1:     
 1:     // Remove any keyboard navigators
 1:     nsIMenuParent* childPopup = nsnull;
 1:     if (weakPopupFrame.IsAlive())
 1:       CallQueryInterface(activeChild, &childPopup);
 1:     if (childPopup)
 1:       childPopup->RemoveKeyboardNavigator();
 1: 
 1:     if (weakPopupFrame.IsAlive())
 1:       ActivatePopup(aEntry, PR_FALSE);
 1: 
 1:     OnDestroyed(presContext, popupContent);
 1:   }
 1: 
 1:   if (weakFrame.IsAlive()) {
 1:     AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
 1:     GetPresContext()->PresShell()->FrameNeedsReflow(this, nsIPresShell::eTreeChange);
 1:   }
 1: }
 1: 
 1: void
 1: nsPopupSetFrame::ActivatePopup(nsPopupFrameList* aEntry, PRBool aActivateFlag)
 1: {
 1:   if (aEntry->mPopupContent) {
 1:     // When we sync the popup view with the frame, we'll show the popup if |menutobedisplayed|
 1:     // is set by setting the |menuactive| attribute. This used to trip css into showing the menu
 1:     // but now we do it ourselves. 
 1:     if (aActivateFlag)
 1:       // XXXben hook in |width| and |height| usage here? 
 1:       aEntry->mPopupContent->SetAttr(kNameSpaceID_None, nsGkAtoms::menutobedisplayed, NS_LITERAL_STRING("true"), PR_TRUE);
 1:     else {
 1:       nsWeakFrame weakFrame(this);
 1:       nsWeakFrame weakActiveChild(aEntry->mPopupFrame);
 1:       nsCOMPtr<nsIContent> content = aEntry->mPopupContent;
 1:       content->UnsetAttr(kNameSpaceID_None, nsGkAtoms::menuactive, PR_TRUE);
 1:       content->UnsetAttr(kNameSpaceID_None, nsGkAtoms::menutobedisplayed, PR_TRUE);
 1: 
 1:       // get rid of the reflows we just created. If we leave them hanging around, we
 1:       // can get into trouble if a dialog with a modal event loop comes along and
 1:       // processes the reflows before we get to call DestroyChain(). Processing the
 1:       // reflow will cause the popup to show itself again. (bug 71219)
 1:       nsIDocument* doc = content->GetDocument();
 1:       if (doc)
 1:         doc->FlushPendingNotifications(Flush_OnlyReflow);
 1: 
 1:       // make sure we hide the popup. We can't assume that we'll have a view
 1:       // since we could be cleaning up after someone that didn't correctly 
 1:       // destroy the popup.
 1:       if (weakFrame.IsAlive() && weakActiveChild.IsAlive()) {
 1:         nsIView* view = weakActiveChild.GetFrame()->GetView();
 1:         NS_ASSERTION(view, "View is gone, looks like someone forgot to roll up the popup!");
 1:         if (view) {
 1:           nsIViewManager* viewManager = view->GetViewManager();
 1:           viewManager->SetViewVisibility(view, nsViewVisibility_kHide);
 1:           nsRect r(0, 0, 0, 0);
 1:           viewManager->ResizeView(view, r);
 1:           if (aEntry->mIsOpen) {
 1:             aEntry->mIsOpen = PR_FALSE;
 1:             FireDOMEventSynch(NS_LITERAL_STRING("DOMMenuInactive"), content);
 1:           }
 1:         }
 1:       }
 1:     }
 1:   }
 1: }
 1: 
 1: PRBool
 1: nsPopupSetFrame::OnCreate(PRInt32 aX, PRInt32 aY, nsIContent* aPopupContent)
 1: {
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_SHOWING, nsnull,
 1:                      nsMouseEvent::eReal);
 1:   // XXX This is messed up: it needs to account for widgets.
 1:   nsPoint dummy;
 1:   event.widget = GetClosestView()->GetNearestWidget(&dummy);
 1:   event.refPoint.x = aX;
 1:   event.refPoint.y = aY;
 1: 
 1:   if (aPopupContent) {
 1:     nsCOMPtr<nsIContent> kungFuDeathGrip(aPopupContent);
95:     nsCOMPtr<nsIPresShell> shell = GetPresContext()->GetPresShell();
 1:     if (shell) {
 1:       nsresult rv = shell->HandleDOMEventWithTarget(aPopupContent, &event,
 1:                                                     &status);
 1:       if ( NS_FAILED(rv) || status == nsEventStatus_eConsumeNoDefault )
 1:         return PR_FALSE;
 1:     }
 1: 
 1:     nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(aPopupContent->GetDocument()));
 1:     if (!domDoc) return PR_FALSE;
 1: 
 1:     // The menu is going to show, and the create handler has executed.
 1:     // We should now walk all of our menu item children, checking to see if any
 1:     // of them has a command attribute.  If so, then several attributes must
 1:     // potentially be updated.
 1: 
 1:     PRUint32 count = aPopupContent->GetChildCount();
 1:     for (PRUint32 i = 0; i < count; i++) {
 1:       nsCOMPtr<nsIContent> grandChild = aPopupContent->GetChildAt(i);
 1: 
 1:       if (grandChild->Tag() == nsGkAtoms::menuitem) {
 1:         // See if we have a command attribute.
 1:         nsAutoString command;
 1:         grandChild->GetAttr(kNameSpaceID_None, nsGkAtoms::command, command);
 1:         if (!command.IsEmpty()) {
 1:           // We do! Look it up in our document
 1:           nsCOMPtr<nsIDOMElement> commandElt;
 1:           domDoc->GetElementById(command, getter_AddRefs(commandElt));
 1:           nsCOMPtr<nsIContent> commandContent(do_QueryInterface(commandElt));
 1:           if ( commandContent ) {
 1:             nsAutoString commandValue;
 1:             // The menu's disabled state needs to be updated to match the command.
 1:             if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::disabled, commandValue))
 1:               grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::disabled, commandValue, PR_TRUE);
 1:             else
 1:               grandChild->UnsetAttr(kNameSpaceID_None, nsGkAtoms::disabled, PR_TRUE);
 1: 
 1:             // The menu's label, accesskey and checked states need to be updated
 1:             // to match the command. Note that unlike the disabled state if the
 1:             // command has *no* value, we assume the menu is supplying its own.
 1:             if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, commandValue))
 1:               grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::label, commandValue, PR_TRUE);
 1: 
 1:             if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, commandValue))
 1:               grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, commandValue, PR_TRUE);
 1: 
 1:             if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::checked, commandValue))
 1:               grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::checked, commandValue, PR_TRUE);
 1:           }
 1:         }
 1:       }
 1:     }
 1:   }
 1: 
 1:   return PR_TRUE;
 1: }
 1: 
 1: PRBool
 1: nsPopupSetFrame::OnCreated(PRInt32 aX, PRInt32 aY, nsIContent* aPopupContent)
 1: {
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_SHOWN, nsnull,
 1:                      nsMouseEvent::eReal);
 1:   // XXX See OnCreate above
 1:   //event.point.x = aX;
 1:   //event.point.y = aY;
 1: 
 1:   if (aPopupContent) {
95:     nsCOMPtr<nsIPresShell> shell = GetPresContext()->GetPresShell();
 1:     if (shell) {
 1:       nsresult rv = shell->HandleDOMEventWithTarget(aPopupContent, &event,
 1:                                                     &status);
 1:       if ( NS_FAILED(rv) || status == nsEventStatus_eConsumeNoDefault )
 1:         return PR_FALSE;
 1:     }
 1:   }
 1: 
 1:   return PR_TRUE;
 1: }
 1: 
 1: PRBool
 1: nsPopupSetFrame::OnDestroy(nsIContent* aPopupContent)
 1: {
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_HIDING, nsnull,
 1:                      nsMouseEvent::eReal);
 1: 
 1:   if (aPopupContent) {
 1:     nsCOMPtr<nsIPresShell> shell = GetPresContext()->GetPresShell();
 1:     if (shell) {
 1:       nsresult rv = shell->HandleDOMEventWithTarget(aPopupContent, &event,
 1:                                                     &status);
 1:       if ( NS_FAILED(rv) || status == nsEventStatus_eConsumeNoDefault )
 1:         return PR_FALSE;
 1:     }
 1:   }
 1:   return PR_TRUE;
 1: }
 1: 
 1: PRBool
 1: nsPopupSetFrame::OnDestroyed(nsPresContext* aPresContext,
 1:                              nsIContent* aPopupContent)
 1: {
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_HIDDEN, nsnull,
 1:                      nsMouseEvent::eReal);
 1: 
 1:   if (aPopupContent && aPresContext) {
 1:     nsCOMPtr<nsIPresShell> shell = aPresContext->GetPresShell();
 1:     if (shell) {
 1:       nsresult rv = shell->HandleDOMEventWithTarget(aPopupContent, &event,
 1:                                                     &status);
 1:       if ( NS_FAILED(rv) || status == nsEventStatus_eConsumeNoDefault )
 1:         return PR_FALSE;
 1:     }
 1:   }
 1:   return PR_TRUE;
 1: }
 1: 
 1: nsresult
 1: nsPopupSetFrame::RemovePopupFrame(nsIFrame* aPopup)
 1: {
 1:   // This was called by the Destroy() method of the popup, so all we have to do is
 1:   // get the popup out of our list, so we don't reflow it later.
 1:   nsPopupFrameList* currEntry = mPopupList;
 1:   nsPopupFrameList* temp = nsnull;
 1:   while (currEntry) {
 1:     if (currEntry->mPopupFrame == aPopup) {
 1:       // Remove this entry.
 1:       if (temp)
 1:         temp->mNextPopup = currEntry->mNextPopup;
 1:       else
 1:         mPopupList = currEntry->mNextPopup;
 1:       
 1:       // Destroy the frame.
 1:       currEntry->mPopupFrame->Destroy();
 1: 
 1:       // Delete the entry.
 1:       currEntry->mNextPopup = nsnull;
 1:       delete currEntry;
 1: 
 1:       // Break out of the loop.
 1:       break;
 1:     }
 1: 
 1:     temp = currEntry;
 1:     currEntry = currEntry->mNextPopup;
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsPopupSetFrame::AddPopupFrameList(nsIFrame* aPopupFrameList)
 1: {
 1:   for (nsIFrame* kid = aPopupFrameList; kid; kid = kid->GetNextSibling()) {
 1:     nsresult rv = AddPopupFrame(kid);
 1:     NS_ENSURE_SUCCESS(rv, rv);
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsPopupSetFrame::AddPopupFrame(nsIFrame* aPopup)
 1: {
 1:   // The entry should already exist, but might not (if someone decided to make their
 1:   // popup visible straightaway, e.g., the autocomplete widget).
 1: 
 1:   // First look for an entry by content.
 1:   nsIContent* content = aPopup->GetContent();
 1:   nsPopupFrameList* entry = nsnull;
 1:   if (mPopupList)
 1:     entry = mPopupList->GetEntry(content);
 1:   if (!entry) {
 1:     entry = new nsPopupFrameList(content, mPopupList);
 1:     if (!entry)
 1:       return NS_ERROR_OUT_OF_MEMORY;
 1:     mPopupList = entry;
 1:   }
 1:   else {
 1:     NS_ASSERTION(!entry->mPopupFrame, "Leaking a popup frame");
 1:   }
 1: 
 1:   // Set the frame connection.
 1:   entry->mPopupFrame = aPopup;
 1:   
 1:   // Now return.  The remaining entry values will be filled in if/when showPopup is
 1:   // called for this popup.
 1:   return NS_OK;
 1: }
 1: 
 1: //static
 1: PRBool
 1: nsPopupSetFrame::MayOpenPopup(nsIFrame* aFrame)
 1: {
 1:   nsCOMPtr<nsISupports> cont = aFrame->GetPresContext()->GetContainer();
 1:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(cont);
 1:   if (!dsti)
 1:     return PR_FALSE;
 1: 
 1:   // chrome shells can always open popups
 1:   PRInt32 type = -1;
 1:   if (NS_SUCCEEDED(dsti->GetItemType(&type)) && type == nsIDocShellTreeItem::typeChrome)
 1:     return PR_TRUE;
 1: 
 1:   nsCOMPtr<nsIDocShell> shell = do_QueryInterface(dsti);
 1:   if (!shell)
 1:     return PR_FALSE;
 1: 
 1:   nsCOMPtr<nsPIDOMWindow> win = do_GetInterface(shell);
 1:   if (!win)
 1:     return PR_FALSE;
 1: 
 1:   // only allow popups in active windows
 1:   PRBool active;
 1:   nsIFocusController* focusController = win->GetRootFocusController();
 1:   focusController->GetActive(&active);
 1:   if (!active)
 1:     return PR_FALSE;
 1: 
 1:   nsCOMPtr<nsIBaseWindow> baseWin = do_QueryInterface(shell);
 1:   if (!baseWin)
 1:     return PR_FALSE;
 1: 
 1:   // only allow popups in visible frames
 1:   PRBool visible;
 1:   baseWin->GetVisibility(&visible);
 1:   return visible;
 1: }
 1: 
