35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Ben Turner <bent.mozilla@gmail.com>.
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
35893: #ifndef dom_plugins_PluginModuleChild_h
35893: #define dom_plugins_PluginModuleChild_h 1
35740: 
35740: #include <string>
35740: #include <vector>
35740: 
35746: #include "base/basictypes.h"
35746: 
35740: #include "prlink.h"
35740: 
35740: #include "npapi.h"
35740: #include "npfunctions.h"
35740: 
35747: #include "nsAutoPtr.h"
39742: #include "nsDataHashtable.h"
37477: #include "nsTHashtable.h"
35925: #include "nsHashKeys.h"
35740: 
70434: #ifdef OS_MACOSX
70434: #include "PluginInterposeOSX.h"
70434: #endif
70434: 
35898: #include "mozilla/plugins/PPluginModuleChild.h"
35893: #include "mozilla/plugins/PluginInstanceChild.h"
39742: #include "mozilla/plugins/PluginIdentifierChild.h"
35740: 
35740: // NOTE: stolen from nsNPAPIPlugin.h
35740: 
35740: /*
35740:  * Use this macro before each exported function
35740:  * (between the return address and the function
35740:  * itself), to ensure that the function has the
35740:  * right calling conventions on OS/2.
35740:  */
35740: #ifdef XP_OS2
35740: #define NP_CALLBACK _System
35740: #else
35740: #define NP_CALLBACK
35740: #endif
35740: 
35740: #if defined(XP_WIN)
35740: #define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (__stdcall * _name)
35740: #elif defined(XP_OS2)
35740: #define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (_System * _name)
35740: #else
35740: #define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (* _name)
35740: #endif
35740: 
35740: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_GETENTRYPOINTS) (NPPluginFuncs* pCallbacks);
35740: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGININIT) (const NPNetscapeFuncs* pCallbacks);
35740: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGINUNIXINIT) (const NPNetscapeFuncs* pCallbacks, NPPluginFuncs* fCallbacks);
35740: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGINSHUTDOWN) (void);
35740: 
35740: namespace mozilla {
35740: namespace plugins {
35925: 
43456: #ifdef MOZ_WIDGET_QT
43456: class NestedLoopTimer;
43456: static const int kNestedLoopDetectorIntervalMs = 90;
43456: #endif
43456: 
35925: class PluginScriptableObjectChild;
37477: class PluginInstanceChild;
35740: 
35898: class PluginModuleChild : public PPluginModuleChild
35740: {
35746: protected:
39265:     NS_OVERRIDE
39265:     virtual mozilla::ipc::RPCChannel::RacyRPCPolicy
39265:     MediateRPCRace(const Message& parent, const Message& child)
39265:     {
39265:         return MediateRace(parent, child);
39265:     }
39265: 
35898:     // Implement the PPluginModuleChild interface
60021:     virtual bool AnswerNP_GetEntryPoints(NPError* rv);
40024:     virtual bool AnswerNP_Initialize(NativeThreadId* tid, NPError* rv);
35746: 
39742:     virtual PPluginIdentifierChild*
39742:     AllocPPluginIdentifier(const nsCString& aString,
39742:                            const int32_t& aInt);
39742: 
39742:     virtual bool
39742:     DeallocPPluginIdentifier(PPluginIdentifierChild* aActor);
39742: 
35898:     virtual PPluginInstanceChild*
35943:     AllocPPluginInstance(const nsCString& aMimeType,
35746:                          const uint16_t& aMode,
57141:                          const InfallibleTArray<nsCString>& aNames,
57141:                          const InfallibleTArray<nsCString>& aValues,
35746:                          NPError* rv);
35746: 
35926:     virtual bool
36138:     DeallocPPluginInstance(PPluginInstanceChild* aActor);
35965: 
35965:     virtual bool
35925:     AnswerPPluginInstanceConstructor(PPluginInstanceChild* aActor,
35925:                                      const nsCString& aMimeType,
35925:                                      const uint16_t& aMode,
57141:                                      const InfallibleTArray<nsCString>& aNames,
57141:                                      const InfallibleTArray<nsCString>& aValues,
35746:                                      NPError* rv);
36039:     virtual bool
36039:     AnswerNP_Shutdown(NPError *rv);
35740: 
60021:     virtual bool
62174:     AnswerOptionalFunctionsSupported(bool *aURLRedirectNotify,
62174:                                      bool *aClearSiteData,
62174:                                      bool *aGetSitesWithData);
62174: 
62174:     virtual bool
62174:     AnswerNPP_ClearSiteData(const nsCString& aSite,
62174:                             const uint64_t& aFlags,
62174:                             const uint64_t& aMaxAge,
62174:                             NPError* aResult);
62174: 
62174:     virtual bool
62174:     AnswerNPP_GetSitesWithData(InfallibleTArray<nsCString>* aResult);
60021: 
36140:     virtual void
36140:     ActorDestroy(ActorDestroyReason why);
36140: 
60014:     NS_NORETURN void QuickExit();
60014: 
70027:     NS_OVERRIDE virtual bool
70027:     RecvProcessNativeEventsInRPCCall();
70027: 
35740: public:
35893:     PluginModuleChild();
35893:     virtual ~PluginModuleChild();
35740: 
67685:     // aPluginFilename is UTF8, not native-charset!
35740:     bool Init(const std::string& aPluginFilename,
36016:               base::ProcessHandle aParentProcessHandle,
35740:               MessageLoop* aIOLoop,
35740:               IPC::Channel* aChannel);
35740: 
35740:     void CleanUp();
35740: 
36099:     const char* GetUserAgent();
36099: 
35740:     static const NPNetscapeFuncs sBrowserFuncs;
35740: 
35925:     static PluginModuleChild* current();
35925: 
37477:     bool RegisterActorForNPObject(NPObject* aObject,
35925:                                   PluginScriptableObjectChild* aActor);
35925: 
37477:     void UnregisterActorForNPObject(NPObject* aObject);
35925: 
35925:     PluginScriptableObjectChild* GetActorForNPObject(NPObject* aObject);
35925: 
36073: #ifdef DEBUG
37311:     bool NPObjectIsRegistered(NPObject* aObject);
36073: #endif
36073: 
37477:     /**
37477:      * The child implementation of NPN_CreateObject.
37477:      */
37477:     static NPObject* NP_CALLBACK NPN_CreateObject(NPP aNPP, NPClass* aClass);
37477:     /**
37477:      * The child implementation of NPN_RetainObject.
37477:      */
37477:     static NPObject* NP_CALLBACK NPN_RetainObject(NPObject* aNPObj);
37477:     /**
37477:      * The child implementation of NPN_ReleaseObject.
37477:      */
37477:     static void NP_CALLBACK NPN_ReleaseObject(NPObject* aNPObj);
37477: 
39742:     /**
39742:      * The child implementations of NPIdentifier-related functions.
39742:      */
39742:     static NPIdentifier NP_CALLBACK NPN_GetStringIdentifier(const NPUTF8* aName);
39742:     static void NP_CALLBACK NPN_GetStringIdentifiers(const NPUTF8** aNames,
39742:                                                      int32_t aNameCount,
39742:                                                      NPIdentifier* aIdentifiers);
39742:     static NPIdentifier NP_CALLBACK NPN_GetIntIdentifier(int32_t aIntId);
39742:     static bool NP_CALLBACK NPN_IdentifierIsString(NPIdentifier aIdentifier);
39742:     static NPUTF8* NP_CALLBACK NPN_UTF8FromIdentifier(NPIdentifier aIdentifier);
39742:     static int32_t NP_CALLBACK NPN_IntFromIdentifier(NPIdentifier aIdentifier);
39742: 
48383: #ifdef OS_MACOSX
48383:     void ProcessNativeEvents();
50439:     
50439:     void PluginShowWindow(uint32_t window_id, bool modal, CGRect r) {
50439:         SendPluginShowWindow(window_id, modal, r.origin.x, r.origin.y, r.size.width, r.size.height);
50439:     }
50439: 
50439:     void PluginHideWindow(uint32_t window_id) {
50439:         SendPluginHideWindow(window_id);
50439:     }
70434: 
70434:     void SetCursor(NSCursorInfo& cursorInfo) {
70434:         SendSetCursor(cursorInfo);
70434:     }
70434: 
70434:     void ShowCursor(bool show) {
70434:         SendShowCursor(show);
70434:     }
70434: 
70434:     void PushCursor(NSCursorInfo& cursorInfo) {
70434:         SendPushCursor(cursorInfo);
70434:     }
70434: 
70434:     void PopCursor() {
70434:         SendPopCursor();
70434:     }
70434: 
70434:     bool GetNativeCursorsSupported() {
70434:         bool supported = false;
70434:         SendGetNativeCursorsSupported(&supported);
70434:         return supported;
70434:     }
48383: #endif
48383: 
58734:     // Quirks mode support for various plugin mime types
58734:     enum PluginQuirks {
58734:         QUIRKS_NOT_INITIALIZED                          = 0,
58734:         // Silverlight assumes it is transparent in windowless mode. This quirk
58734:         // matches the logic in nsNPAPIPluginInstance::SetWindowless.
58734:         QUIRK_SILVERLIGHT_DEFAULT_TRANSPARENT           = 1 << 0,
58734:         // Win32: Hook TrackPopupMenu api so that we can swap out parent
58734:         // hwnds. The api will fail with parents not associated with our
58734:         // child ui thread. See WinlessHandleEvent for details.
58734:         QUIRK_WINLESS_TRACKPOPUP_HOOK                   = 1 << 1,
58734:         // Win32: Throttle flash WM_USER+1 heart beat messages to prevent
58734:         // flooding chromium's dispatch loop, which can cause ipc traffic
58734:         // processing lag.
58734:         QUIRK_FLASH_THROTTLE_WMUSER_EVENTS              = 1 << 2,
58734:         // Win32: Catch resets on our subclass by hooking SetWindowLong.
58734:         QUIRK_FLASH_HOOK_SETLONGPTR                     = 1 << 3,
58735:         // X11: Work around a bug in Flash up to 10.1 d51 at least, where
58735:         // expose event top left coordinates within the plugin-rect and
58735:         // not at the drawable origin are misinterpreted.
58735:         QUIRK_FLASH_EXPOSE_COORD_TRANSLATION            = 1 << 4,
58736:         // Win32: Catch get window info calls on the browser and tweak the
58736:         // results so mouse input works when flash is displaying it's settings
58736:         // window.
60621:         QUIRK_FLASH_HOOK_GETWINDOWINFO                  = 1 << 5,
62644:         // Win: Addresses a flash bug with mouse capture and full screen
62644:         // windows.
62706:         QUIRK_FLASH_FIXUP_MOUSE_CAPTURE                 = 1 << 6,
62842:         // Win: QuickTime steals focus on SetWindow calls even if it's hidden.
62842:         // Avoid calling SetWindow in that case.
62842:         QUIRK_QUICKTIME_AVOID_SETWINDOW                 = 1 << 7,
70688:         // Win: Check to make sure the parent window has focus before calling
70688:         // set focus on the child. Addresses a full screen dialog prompt
70688:         // problem in Silverlight.
70688:         QUIRK_SILVERLIGHT_FOCUS_CHECK_PARENT            = 1 << 8,
58734:     };
58734: 
58734:     int GetQuirks() { return mQuirks; }
69479: 
69479: private:
58734:     void AddQuirk(PluginQuirks quirk) {
58734:       if (mQuirks == QUIRKS_NOT_INITIALIZED)
58734:         mQuirks = 0;
58734:       mQuirks |= quirk;
58734:     }
58734:     void InitQuirksModes(const nsCString& aMimeType);
35746:     bool InitGraphics();
62705:     void DeinitGraphics();
38684: #if defined(MOZ_WIDGET_GTK2)
38684:     static gboolean DetectNestedEventLoop(gpointer data);
38684:     static gboolean ProcessBrowserEvents(gpointer data);
38684: 
38684:     NS_OVERRIDE
38684:     virtual void EnteredCxxStack();
38684:     NS_OVERRIDE
38684:     virtual void ExitedCxxStack();
43456: #elif defined(MOZ_WIDGET_QT)
43456: 
43456:     NS_OVERRIDE
43456:     virtual void EnteredCxxStack();
43456:     NS_OVERRIDE
43456:     virtual void ExitedCxxStack();
38684: #endif
35746: 
35740:     PRLibrary* mLibrary;
67685:     nsCString mPluginFilename; // UTF8
36099:     nsCString mUserAgent;
58734:     int mQuirks;
35740: 
35740:     // we get this from the plugin
39534:     NP_PLUGINSHUTDOWN mShutdownFunc;
39534: #ifdef OS_LINUX
35740:     NP_PLUGINUNIXINIT mInitializeFunc;
39534: #elif defined(OS_WIN) || defined(OS_MACOSX)
35746:     NP_PLUGININIT mInitializeFunc;
35746:     NP_GETENTRYPOINTS mGetEntryPointsFunc;
35746: #endif
38684: 
35740:     NPPluginFuncs mFunctions;
35740:     NPSavedData mSavedData;
35925: 
38684: #if defined(MOZ_WIDGET_GTK2)
38684:     // If a plugin spins a nested glib event loop in response to a
38684:     // synchronous IPC message from the browser, the loop might break
38684:     // only after the browser responds to a request sent by the
38684:     // plugin.  This can happen if a plugin uses gtk's synchronous
38684:     // copy/paste, for example.  But because the browser is blocked on
38684:     // a condvar, it can't respond to the request.  This situation
38684:     // isn't technically a deadlock, but the symptoms are basically
38684:     // the same from the user's perspective.
38684:     //
38684:     // We take two steps to prevent this
38684:     //
38684:     //  (1) Detect nested event loops spun by the plugin.  This is
38684:     //      done by scheduling a glib timer event in the plugin
38684:     //      process whenever the browser might block on the plugin.
38684:     //      If the plugin indeed spins a nested loop, this timer event
38684:     //      will fire "soon" thereafter.
38684:     //
38684:     //  (2) When a nested loop is detected, deschedule the
38684:     //      nested-loop-detection timer and in its place, schedule
38684:     //      another timer that periodically calls back into the
38684:     //      browser and spins a mini event loop.  This mini event loop
38684:     //      processes a handful of pending native events.
38684:     //
38684:     // Because only timer (1) or (2) (or neither) may be active at any
38684:     // point in time, we use the same member variable
38684:     // |mNestedLoopTimerId| to refer to both.
38684:     //
38684:     // When the browser no longer might be blocked on a plugin's IPC
38684:     // response, we deschedule whichever of (1) or (2) is active.
38684:     guint mNestedLoopTimerId;
39856: #  ifdef DEBUG
39856:     // Depth of the stack of calls to g_main_context_dispatch before any
39856:     // nested loops are run.  This is 1 when IPC calls are dispatched from
39856:     // g_main_context_iteration, or 0 when dispatched directly from
39856:     // MessagePumpForUI.
39856:     int mTopLoopDepth;
39856: #  endif
43456: #elif defined (MOZ_WIDGET_QT)
43456:     NestedLoopTimer *mNestedLoopTimerObject;
38684: #endif
38684: 
37477:     struct NPObjectData : public nsPtrHashKey<NPObject>
37477:     {
37477:         NPObjectData(const NPObject* key)
37477:             : nsPtrHashKey<NPObject>(key)
37477:             , instance(NULL)
37477:             , actor(NULL)
37477:         { }
37477: 
37477:         // never NULL
37477:         PluginInstanceChild* instance;
37477: 
37477:         // sometimes NULL (no actor associated with an NPObject)
37477:         PluginScriptableObjectChild* actor;
37477:     };
37477:     /**
37477:      * mObjectMap contains all the currently active NPObjects (from NPN_CreateObject until the
37477:      * final release/dealloc, whether or not an actor is currently associated with the object.
37477:      */
37477:     nsTHashtable<NPObjectData> mObjectMap;
37477: 
39742:     nsDataHashtable<nsCStringHashKey, PluginIdentifierChild*> mStringIdentifiers;
39742:     nsDataHashtable<nsUint32HashKey, PluginIdentifierChild*> mIntIdentifiers;
39742: 
38669: public: // called by PluginInstanceChild
37477:     /**
37477:      * Dealloc an NPObject after last-release or when the associated instance
38669:      * is destroyed. This function will remove the object from mObjectMap.
37477:      */
37477:     static void DeallocNPObject(NPObject* o);
37477: 
38669:     NPError NPP_Destroy(PluginInstanceChild* instance) {
38669:         return mFunctions.destroy(instance->GetNPP(), 0);
38669:     }
38669: 
37477:     /**
38669:      * Fill PluginInstanceChild.mDeletingHash with all the remaining NPObjects
38669:      * associated with that instance.
37477:      */
38669:     void FindNPObjectsForInstance(PluginInstanceChild* instance);
38669: 
38669: private:
38669:     static PLDHashOperator CollectForInstance(NPObjectData* d, void* userArg);
41651: 
41651: #if defined(OS_WIN)
41651:     NS_OVERRIDE
41651:     virtual void EnteredCall();
41651:     NS_OVERRIDE
41651:     virtual void ExitedCall();
41651: 
41651:     // Entered/ExitedCall notifications keep track of whether the plugin has
41651:     // entered a nested event loop within this RPC call.
41652:     struct IncallFrame
41652:     {
41652:         IncallFrame()
41652:             : _spinning(false)
41652:             , _savedNestableTasksAllowed(false)
41652:         { }
41652: 
41652:         bool _spinning;
41652:         bool _savedNestableTasksAllowed;
41652:     };
41652: 
41652:     nsAutoTArray<IncallFrame, 8> mIncallPumpingStack;
41651: 
41651:     static LRESULT CALLBACK NestedInputEventHook(int code,
41651:                                                  WPARAM wParam,
41651:                                                  LPARAM lParam);
42136:     static LRESULT CALLBACK CallWindowProcHook(int code,
42136:                                                WPARAM wParam,
42136:                                                LPARAM lParam);
42136:     void SetEventHooks();
42136:     void ResetEventHooks();
41651:     HHOOK mNestedEventHook;
42136:     HHOOK mGlobalCallWndProcHook;
41651: #endif
35740: };
35740: 
35740: } /* namespace plugins */
35740: } /* namespace mozilla */
35740: 
35893: #endif  // ifndef dom_plugins_PluginModuleChild_h
