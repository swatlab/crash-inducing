78085: //* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
78085: /* vim: set ts=2 et sw=2 tw=80: */
78085: /* ***** BEGIN LICENSE BLOCK *****
78085:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
78085:  *
78085:  * The contents of this file are subject to the Mozilla Public License Version
78085:  * 1.1 (the "License"); you may not use this file except in compliance with
78085:  * the License. You may obtain a copy of the License at
78085:  * http://www.mozilla.org/MPL/
78085:  *
78085:  * Software distributed under the License is distributed on an "AS IS" basis,
78085:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
78085:  * for the specific language governing rights and limitations under the
78085:  * License.
78085:  *
78085:  * The Original Code is Url Classifier code
78085:  *
78085:  * The Initial Developer of the Original Code is
78085:  * the Mozilla Foundation.
78085:  * Portions created by the Initial Developer are Copyright (C) 2011
78085:  * the Initial Developer. All Rights Reserved.
78085:  *
78085:  * Contributor(s):
78085:  *   Gian-Carlo Pascutto <gpascutto@mozilla.com>
78085:  *   Mehdi Mulani <mars.martian+bugmail@gmail.com>
78085:  *
78085:  * Alternatively, the contents of this file may be used under the terms of
78085:  * either the GNU General Public License Version 2 or later (the "GPL"), or
78085:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
78085:  * in which case the provisions of the GPL or the LGPL are applicable instead
78085:  * of those above. If you wish to allow use of your version of this file only
78085:  * under the terms of either the GPL or the LGPL, and not to allow others to
78085:  * use your version of this file under the terms of the MPL, indicate your
78085:  * decision by deleting the provisions above and replace them with the notice
78085:  * and other provisions required by the GPL or the LGPL. If you do not delete
78085:  * the provisions above, a recipient may use your version of this file under
78085:  * the terms of any one of the MPL, the GPL or the LGPL.
78085:  *
78085:  * ***** END LICENSE BLOCK ***** */
78085: 
78085: #include "nsAutoPtr.h"
78085: #include "nsCOMPtr.h"
78090: #include "nsDebug.h"
78085: #include "nsTArray.h"
82207: #include "nsString.h"
78085: #include "nsUrlClassifierPrefixSet.h"
78085: #include "nsIUrlClassifierPrefixSet.h"
78092: #include "nsIRandomGenerator.h"
78090: #include "nsIFile.h"
78090: #include "nsILocalFile.h"
78085: #include "nsToolkitCompsCID.h"
78085: #include "nsTArray.h"
78085: #include "nsThreadUtils.h"
78085: #include "mozilla/Mutex.h"
79631: #include "mozilla/Telemetry.h"
78090: #include "mozilla/FileUtils.h"
78085: #include "prlog.h"
78085: 
78087: using namespace mozilla;
78087: 
78085: // NSPR_LOG_MODULES=UrlClassifierPrefixSet:5
78085: #if defined(PR_LOGGING)
78085: static const PRLogModuleInfo *gUrlClassifierPrefixSetLog = nsnull;
78085: #define LOG(args) PR_LOG(gUrlClassifierPrefixSetLog, PR_LOG_DEBUG, args)
78085: #define LOG_ENABLED() PR_LOG_TEST(gUrlClassifierPrefixSetLog, 4)
78085: #else
78085: #define LOG(args)
80486: #define LOG_ENABLED() (false)
78085: #endif
78085: 
82207: class nsPrefixSetReporter : public nsIMemoryReporter
82207: {
82207: public:
82207:   nsPrefixSetReporter(nsUrlClassifierPrefixSet * aParent, const nsACString & aName);
82207:   virtual ~nsPrefixSetReporter() {};
82207: 
82207:   NS_DECL_ISUPPORTS
82207:   NS_DECL_NSIMEMORYREPORTER
82207: 
82207: private:
82207:   nsCString mPath;
82207:   nsUrlClassifierPrefixSet * mParent;
82207: };
82207: 
82207: NS_IMPL_THREADSAFE_ISUPPORTS1(nsPrefixSetReporter, nsIMemoryReporter)
82207: 
84704: NS_MEMORY_REPORTER_MALLOC_SIZEOF_FUN(StoragePrefixSetMallocSizeOf,
84704:                                      "storage/prefixset")
84704: 
82207: nsPrefixSetReporter::nsPrefixSetReporter(nsUrlClassifierPrefixSet * aParent,
82207:                                          const nsACString & aName)
82207: : mParent(aParent)
82207: {
82207:   mPath.Assign(NS_LITERAL_CSTRING("explicit/storage/prefixset"));
82207:   if (!aName.IsEmpty()) {
82207:     mPath.Append("/");
82207:     mPath.Append(aName);
82207:   }
82207: }
82207: 
82207: NS_IMETHODIMP
82207: nsPrefixSetReporter::GetProcess(nsACString & aProcess)
82207: {
82207:   aProcess.Truncate();
82207:   return NS_OK;
82207: }
82207: 
82207: NS_IMETHODIMP
82207: nsPrefixSetReporter::GetPath(nsACString & aPath)
82207: {
82207:   aPath.Assign(mPath);
82207:   return NS_OK;
82207: }
82207: 
82207: NS_IMETHODIMP
82207: nsPrefixSetReporter::GetKind(PRInt32 * aKind)
82207: {
82207:   *aKind = nsIMemoryReporter::KIND_HEAP;
82207:   return NS_OK;
82207: }
82207: 
82207: NS_IMETHODIMP
82207: nsPrefixSetReporter::GetUnits(PRInt32 * aUnits)
82207: {
82207:   *aUnits = nsIMemoryReporter::UNITS_BYTES;
82207:   return NS_OK;
82207: }
82207: 
82207: NS_IMETHODIMP
82207: nsPrefixSetReporter::GetAmount(PRInt64 * aAmount)
82207: {
84704:   *aAmount = mParent->SizeOfIncludingThis(StoragePrefixSetMallocSizeOf);
84704:   return NS_OK;
82207: }
82207: 
82207: NS_IMETHODIMP
82207: nsPrefixSetReporter::GetDescription(nsACString & aDescription)
82207: {
82207:   aDescription.Assign(NS_LITERAL_CSTRING("Memory used by a PrefixSet for "
82207:                                          "UrlClassifier, in bytes."));
82207:   return NS_OK;
82207: }
82207: 
78090: NS_IMPL_THREADSAFE_ISUPPORTS1(nsUrlClassifierPrefixSet, nsIUrlClassifierPrefixSet)
78085: 
78085: nsUrlClassifierPrefixSet::nsUrlClassifierPrefixSet()
78090:   : mPrefixSetLock("mPrefixSetLock"),
78090:     mSetIsReady(mPrefixSetLock, "mSetIsReady"),
80486:     mHasPrefixes(false),
78092:     mRandomKey(0)
78085: {
78085: #if defined(PR_LOGGING)
78085:   if (!gUrlClassifierPrefixSetLog)
78085:     gUrlClassifierPrefixSetLog = PR_NewLogModule("UrlClassifierPrefixSet");
78085: #endif
78092: 
78092:   nsresult rv = InitKey();
78092:   if (NS_FAILED(rv)) {
78092:     LOG(("Failed to initialize PrefixSet"));
78092:   }
82207: 
82207:   mReporter = new nsPrefixSetReporter(this, NS_LITERAL_CSTRING("all"));
82207:   NS_RegisterMemoryReporter(mReporter);
82207: }
82207: 
82207: nsUrlClassifierPrefixSet::~nsUrlClassifierPrefixSet()
82207: {
82207:   NS_UnregisterMemoryReporter(mReporter);
78092: }
78092: 
78092: nsresult
78092: nsUrlClassifierPrefixSet::InitKey()
78092: {
78092:   nsCOMPtr<nsIRandomGenerator> rg =
78092:     do_GetService("@mozilla.org/security/random-generator;1");
78092:   NS_ENSURE_STATE(rg);
78092: 
78092:   PRUint8 *temp;
78092:   nsresult rv = rg->GenerateRandomBytes(sizeof(mRandomKey), &temp);
78092:   NS_ENSURE_SUCCESS(rv, rv);
78092:   memcpy(&mRandomKey, temp, sizeof(mRandomKey));
78092:   NS_Free(temp);
78092: 
78092:   LOG(("Initialized PrefixSet, key = %X", mRandomKey));
78092: 
78092:   return NS_OK;
78085: }
78085: 
78087: NS_IMETHODIMP
78085: nsUrlClassifierPrefixSet::SetPrefixes(const PRUint32 * aArray, PRUint32 aLength)
78085: {
85294:   if (aLength <= 0) {
78090:     MutexAutoLock lock(mPrefixSetLock);
78085:     if (mHasPrefixes) {
78087:       LOG(("Clearing PrefixSet"));
78085:       mDeltas.Clear();
78085:       mIndexPrefixes.Clear();
78085:       mIndexStarts.Clear();
80486:       mHasPrefixes = false;
78085:     }
85294:   } else {
85294:     return MakePrefixSet(aArray, aLength);
78085:   }
78085: 
78085:   return NS_OK;
78085: }
78085: 
85294: nsresult
85294: nsUrlClassifierPrefixSet::MakePrefixSet(const PRUint32 * prefixes, PRUint32 aLength)
78085: {
78085:   if (aLength == 0) {
78085:     return NS_OK;
78085:   }
78085: 
85294: #ifdef DEBUG
85294:   for (PRUint32 i = 1; i < aLength; i++) {
85294:     MOZ_ASSERT(prefixes[i] >= prefixes[i-1]);
85294:   }
85294: #endif
78087: 
85294:   FallibleTArray<PRUint32> newIndexPrefixes;
85294:   FallibleTArray<PRUint32> newIndexStarts;
85294:   FallibleTArray<PRUint16> newDeltas;
85294: 
85294:   if (!newIndexPrefixes.AppendElement(prefixes[0])) {
85294:     return NS_ERROR_OUT_OF_MEMORY;
85294:   }
85294:   if (!newIndexStarts.AppendElement(newDeltas.Length())) {
85294:     return NS_ERROR_OUT_OF_MEMORY;
85294:   }
78085: 
78085:   PRUint32 numOfDeltas = 0;
78085:   PRUint32 currentItem = prefixes[0];
78085:   for (PRUint32 i = 1; i < aLength; i++) {
78085:     if ((numOfDeltas >= DELTAS_LIMIT) ||
78085:           (prefixes[i] - currentItem >= MAX_INDEX_DIFF)) {
85294:       if (!newIndexStarts.AppendElement(newDeltas.Length())) {
85294:         return NS_ERROR_OUT_OF_MEMORY;
85294:       }
85294:       if (!newIndexPrefixes.AppendElement(prefixes[i])) {
85294:         return NS_ERROR_OUT_OF_MEMORY;
85294:       }
78085:       numOfDeltas = 0;
78085:     } else {
78085:       PRUint16 delta = prefixes[i] - currentItem;
85294:       if (!newDeltas.AppendElement(delta)) {
85294:         return NS_ERROR_OUT_OF_MEMORY;
85294:       }
78085:       numOfDeltas++;
78085:     }
78085:     currentItem = prefixes[i];
78085:   }
78085: 
85294:   newIndexPrefixes.Compact();
85294:   newIndexStarts.Compact();
85294:   newDeltas.Compact();
78085: 
85294:   LOG(("Total number of indices: %d", newIndexPrefixes.Length()));
85294:   LOG(("Total number of deltas: %d", newDeltas.Length()));
78088: 
78090:   MutexAutoLock lock(mPrefixSetLock);
78088: 
78088:   // This just swaps some pointers
85294:   mIndexPrefixes.SwapElements(newIndexPrefixes);
85294:   mIndexStarts.SwapElements(newIndexStarts);
85294:   mDeltas.SwapElements(newDeltas);
78085: 
80486:   mHasPrefixes = true;
78090:   mSetIsReady.NotifyAll();
78085: 
78085:   return NS_OK;
78085: }
78085: 
78085: PRUint32 nsUrlClassifierPrefixSet::BinSearch(PRUint32 start,
78085:                                              PRUint32 end,
78085:                                              PRUint32 target)
78085: {
78085:   while (start != end && end >= start) {
78088:     PRUint32 i = start + ((end - start) >> 1);
78088:     PRUint32 value = mIndexPrefixes[i];
78085:     if (value < target) {
78085:       start = i + 1;
78085:     } else if (value > target) {
78085:       end = i - 1;
78085:     } else {
78085:       return i;
78085:     }
78085:   }
78085:   return end;
78085: }
78085: 
85294: nsresult
79445: nsUrlClassifierPrefixSet::Contains(PRUint32 aPrefix, bool * aFound)
78085: {
82207:   mPrefixSetLock.AssertCurrentThreadOwns();
82207: 
80486:   *aFound = false;
78085: 
78085:   if (!mHasPrefixes) {
78085:     return NS_OK;
78085:   }
78085: 
78085:   PRUint32 target = aPrefix;
78085: 
78085:   // We want to do a "Price is Right" binary search, that is, we want to find
78085:   // the index of the value either equal to the target or the closest value
78085:   // that is less than the target.
78085:   //
78085:   if (target < mIndexPrefixes[0]) {
78085:     return NS_OK;
78085:   }
78085: 
78085:   // |binsearch| does not necessarily return the correct index (when the
78085:   // target is not found) but rather it returns an index at least one away
78085:   // from the correct index.
78085:   // Because of this, we need to check if the target lies before the beginning
78085:   // of the indices.
78085: 
78092:   PRUint32 i = BinSearch(0, mIndexPrefixes.Length() - 1, target);
78085:   if (mIndexPrefixes[i] > target && i > 0) {
78085:     i--;
78085:   }
78085: 
78085:   // Now search through the deltas for the target.
78085:   PRUint32 diff = target - mIndexPrefixes[i];
78085:   PRUint32 deltaIndex = mIndexStarts[i];
83145:   PRUint32 deltaSize  = mDeltas.Length();
78085:   PRUint32 end = (i + 1 < mIndexStarts.Length()) ? mIndexStarts[i+1]
83145:                                                  : deltaSize;
83145: 
83145:   // Sanity check the read values
83145:   if (end > deltaSize) {
83145:     return NS_ERROR_FILE_CORRUPTED;
83145:   }
83145: 
78085:   while (diff > 0 && deltaIndex < end) {
78085:     diff -= mDeltas[deltaIndex];
78085:     deltaIndex++;
78085:   }
78085: 
78085:   if (diff == 0) {
80486:     *aFound = true;
78085:   }
78085: 
78085:   return NS_OK;
78085: }
78085: 
84704: size_t
84923: nsUrlClassifierPrefixSet::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf)
78085: {
78090:   MutexAutoLock lock(mPrefixSetLock);
84704:   size_t n = 0;
84923:   n += aMallocSizeOf(this, sizeof(nsUrlClassifierPrefixSet));
84923:   n += mDeltas.SizeOfExcludingThis(aMallocSizeOf);
84923:   n += mIndexPrefixes.SizeOfExcludingThis(aMallocSizeOf);
84923:   n += mIndexStarts.SizeOfExcludingThis(aMallocSizeOf);
84704:   return n;
78085: }
78087: 
78087: NS_IMETHODIMP
79445: nsUrlClassifierPrefixSet::IsEmpty(bool * aEmpty)
78090: {
78090:   MutexAutoLock lock(mPrefixSetLock);
78090:   *aEmpty = !mHasPrefixes;
78090:   return NS_OK;
78090: }
78090: 
78090: NS_IMETHODIMP
78092: nsUrlClassifierPrefixSet::GetKey(PRUint32 * aKey)
78087:  {
78090:    MutexAutoLock lock(mPrefixSetLock);
78092:    *aKey = mRandomKey;
78092:    return NS_OK;
78092: }
78092: 
78092: NS_IMETHODIMP
78092: nsUrlClassifierPrefixSet::Probe(PRUint32 aPrefix, PRUint32 aKey,
79445:                                 bool* aReady, bool* aFound)
78092: {
78092:   MutexAutoLock lock(mPrefixSetLock);
78092: 
80664:   *aFound = false;
80664: 
78092:   // We might have raced here with a LoadPrefixSet call,
78092:   // loading a saved PrefixSet with another key than the one used to probe us.
78092:   // This must occur exactly between the GetKey call and the Probe call.
78092:   // This could cause a false negative immediately after browser start.
78092:   // Claim we are still busy loading instead.
78092:   if (aKey != mRandomKey) {
78092:     LOG(("Potential race condition detected, avoiding"));
80486:     *aReady = false;
78092:     return NS_OK;
78092:   }
78087: 
78087:   // check whether we are opportunistically probing or should wait
78087:   if (*aReady) {
78087:     // we should block until we are ready
78087:     while (!mHasPrefixes) {
78090:       LOG(("Set is empty, probe must wait"));
78090:       mSetIsReady.Wait();
78087:     }
78087:   } else {
78087:     // opportunistic probe -> check if set is loaded
78087:     if (mHasPrefixes) {
80486:       *aReady = true;
78087:     } else {
78087:       return NS_OK;
78087:     }
78087:   }
78087: 
78087:   nsresult rv = Contains(aPrefix, aFound);
78087:   NS_ENSURE_SUCCESS(rv, rv);
78087: 
78087:   return NS_OK;
78087: }
78090: 
78090: nsresult
78090: nsUrlClassifierPrefixSet::LoadFromFd(AutoFDClose & fileFd)
78090: {
78090:   PRUint32 magic;
78090:   PRInt32 read;
78090: 
78090:   read = PR_Read(fileFd, &magic, sizeof(PRUint32));
83145:   NS_ENSURE_TRUE(read == sizeof(PRUint32), NS_ERROR_FAILURE);
78090: 
78090:   if (magic == PREFIXSET_VERSION_MAGIC) {
78090:     PRUint32 indexSize;
78090:     PRUint32 deltaSize;
78090: 
78092:     read = PR_Read(fileFd, &mRandomKey, sizeof(PRUint32));
83145:     NS_ENSURE_TRUE(read == sizeof(PRUint32), NS_ERROR_FILE_CORRUPTED);
78090:     read = PR_Read(fileFd, &indexSize, sizeof(PRUint32));
83145:     NS_ENSURE_TRUE(read == sizeof(PRUint32), NS_ERROR_FILE_CORRUPTED);
78090:     read = PR_Read(fileFd, &deltaSize, sizeof(PRUint32));
83145:     NS_ENSURE_TRUE(read == sizeof(PRUint32), NS_ERROR_FILE_CORRUPTED);
78090: 
78090:     if (indexSize == 0) {
78090:       LOG(("stored PrefixSet is empty!"));
78090:       return NS_ERROR_FAILURE;
78090:     }
78090: 
83145:     if (deltaSize > (indexSize * DELTAS_LIMIT)) {
83145:       return NS_ERROR_FILE_CORRUPTED;
83145:     }
83145: 
78090:     nsTArray<PRUint32> mNewIndexPrefixes;
78090:     nsTArray<PRUint32> mNewIndexStarts;
78090:     nsTArray<PRUint16> mNewDeltas;
78090: 
78090:     mNewIndexStarts.SetLength(indexSize);
78090:     mNewIndexPrefixes.SetLength(indexSize);
78090:     mNewDeltas.SetLength(deltaSize);
78090: 
83145:     PRInt32 toRead = indexSize*sizeof(PRUint32);
83145:     read = PR_Read(fileFd, mNewIndexPrefixes.Elements(), toRead);
83145:     NS_ENSURE_TRUE(read == toRead, NS_ERROR_FILE_CORRUPTED);
83145:     read = PR_Read(fileFd, mNewIndexStarts.Elements(), toRead);
83145:     NS_ENSURE_TRUE(read == toRead, NS_ERROR_FILE_CORRUPTED);
78090:     if (deltaSize > 0) {
83145:       toRead = deltaSize*sizeof(PRUint16);
83145:       read = PR_Read(fileFd, mNewDeltas.Elements(), toRead);
83145:       NS_ENSURE_TRUE(read == toRead, NS_ERROR_FILE_CORRUPTED);
78090:     }
78090: 
78090:     MutexAutoLock lock(mPrefixSetLock);
78090: 
78090:     mIndexPrefixes.SwapElements(mNewIndexPrefixes);
78090:     mIndexStarts.SwapElements(mNewIndexStarts);
78090:     mDeltas.SwapElements(mNewDeltas);
78090: 
80486:     mHasPrefixes = true;
78090:     mSetIsReady.NotifyAll();
78090:   } else {
78090:     LOG(("Version magic mismatch, not loading"));
78090:     return NS_ERROR_FAILURE;
78090:   }
78090: 
78090:   LOG(("Loading PrefixSet successful"));
78090: 
78090:   return NS_OK;
78090: }
78090: 
78090: NS_IMETHODIMP
78090: nsUrlClassifierPrefixSet::LoadFromFile(nsIFile * aFile)
78090: {
78090:   nsresult rv;
78090:   nsCOMPtr<nsILocalFile> file(do_QueryInterface(aFile, &rv));
78090:   NS_ENSURE_SUCCESS(rv, rv);
78090: 
78090:   AutoFDClose fileFd;
79631:   rv = file->OpenNSPRFileDesc(PR_RDONLY | nsILocalFile::OS_READAHEAD, 0, &fileFd);
78090:   NS_ENSURE_SUCCESS(rv, rv);
78090: 
78090:   return LoadFromFd(fileFd);
78090: }
78090: 
78090: nsresult
78090: nsUrlClassifierPrefixSet::StoreToFd(AutoFDClose & fileFd)
78090: {
79631:   {
79631:       Telemetry::AutoTimer<Telemetry::URLCLASSIFIER_PS_FALLOCATE_TIME> timer;
79631:       PRInt64 size = 4 * sizeof(PRUint32);
79631:       size += 2 * mIndexStarts.Length() * sizeof(PRUint32);
79631:       size +=     mDeltas.Length() * sizeof(PRUint16);
79631: 
79631:       mozilla::fallocate(fileFd, size);
79631:   }
79631: 
78090:   PRInt32 written;
78090:   PRUint32 magic = PREFIXSET_VERSION_MAGIC;
78090:   written = PR_Write(fileFd, &magic, sizeof(PRUint32));
78090:   NS_ENSURE_TRUE(written > 0, NS_ERROR_FAILURE);
78090: 
78092:   written = PR_Write(fileFd, &mRandomKey, sizeof(PRUint32));
78092:   NS_ENSURE_TRUE(written > 0, NS_ERROR_FAILURE);
78092: 
78090:   PRUint32 indexSize = mIndexStarts.Length();
78090:   PRUint32 deltaSize = mDeltas.Length();
78090:   written = PR_Write(fileFd, &indexSize, sizeof(PRUint32));
78090:   NS_ENSURE_TRUE(written > 0, NS_ERROR_FAILURE);
78090:   written = PR_Write(fileFd, &deltaSize, sizeof(PRUint32));
78090:   NS_ENSURE_TRUE(written > 0, NS_ERROR_FAILURE);
78090: 
78090:   written = PR_Write(fileFd, mIndexPrefixes.Elements(), indexSize * sizeof(PRUint32));
78090:   NS_ENSURE_TRUE(written > 0, NS_ERROR_FAILURE);
78090:   written = PR_Write(fileFd, mIndexStarts.Elements(), indexSize * sizeof(PRUint32));
78090:   NS_ENSURE_TRUE(written > 0, NS_ERROR_FAILURE);
78090:   if (deltaSize > 0) {
78090:     written = PR_Write(fileFd, mDeltas.Elements(), deltaSize * sizeof(PRUint16));
78090:     NS_ENSURE_TRUE(written > 0, NS_ERROR_FAILURE);
78090:   }
78090: 
78090:   LOG(("Saving PrefixSet successful\n"));
78090: 
78090:   return NS_OK;
78090: }
78090: 
78090: NS_IMETHODIMP
78090: nsUrlClassifierPrefixSet::StoreToFile(nsIFile * aFile)
78090: {
78090:   if (!mHasPrefixes) {
78090:     LOG(("Attempt to serialize empty PrefixSet"));
78090:     return NS_ERROR_FAILURE;
78090:   }
78090: 
78090:   nsresult rv;
78090:   nsCOMPtr<nsILocalFile> file(do_QueryInterface(aFile, &rv));
78090:   NS_ENSURE_SUCCESS(rv, rv);
78090: 
78090:   AutoFDClose fileFd;
78090:   rv = file->OpenNSPRFileDesc(PR_RDWR | PR_TRUNCATE | PR_CREATE_FILE,
78090:                               0644, &fileFd);
78090:   NS_ENSURE_SUCCESS(rv, rv);
78090: 
78090:   MutexAutoLock lock(mPrefixSetLock);
78090: 
78090:   return StoreToFd(fileFd);
78090: }
