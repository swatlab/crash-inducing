67517: // -*- Mode: js2; tab-width: 2; indent-tabs-mode: nil; js2-basic-offset: 2; js2-skip-preprocessor-directives: t; -*-
66264: let Cc = Components.classes;
66264: let Ci = Components.interfaces;
72262: let Cu = Components.utils;
72262: 
72262: Cu.import("resource://gre/modules/Services.jsm");
66264: 
66264: let WebProgressListener = {
78745:   _lastLocation: null,
78745: 
66400:   init: function() {
67237:     let flags = Ci.nsIWebProgress.NOTIFY_LOCATION |
67237:                 Ci.nsIWebProgress.NOTIFY_SECURITY |
67352:                 Ci.nsIWebProgress.NOTIFY_STATE_NETWORK | Ci.nsIWebProgress.NOTIFY_STATE_DOCUMENT;
67237: 
66400:     let webProgress = docShell.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebProgress);
67237:     webProgress.addProgressListener(this, flags);
66400:   },
66400: 
66264:   onStateChange: function onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {
67237:     if (content != aWebProgress.DOMWindow)
67237:       return;
66264: 
66264:     let json = {
67091:       contentWindowId: content.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID,
66264:       stateFlags: aStateFlags,
67237:       status: aStatus
66264:     };
66400: 
67237:     sendAsyncMessage("Content:StateChange", json);
66264:   },
66264: 
66264:   onProgressChange: function onProgressChange(aWebProgress, aRequest, aCurSelf, aMaxSelf, aCurTotal, aMaxTotal) {
66264:   },
66264: 
77160:   _firstPaint: false,
77160: 
66264:   onLocationChange: function onLocationChange(aWebProgress, aRequest, aLocationURI) {
67237:     if (content != aWebProgress.DOMWindow)
67237:       return;
67237: 
67112:     let spec = aLocationURI ? aLocationURI.spec : "";
67112:     let location = spec.split("#")[0];
67112: 
67406:     let charset = content.document.characterSet;
67406: 
66264:     let json = {
67091:       contentWindowId: content.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID,
66265:       documentURI:     aWebProgress.DOMWindow.document.documentURIObject.spec,
67112:       location:        spec,
66264:       canGoBack:       docShell.canGoBack,
67406:       canGoForward:    docShell.canGoForward,
67406:       charset:         charset.toString()
66264:     };
67237: 
67237:     sendAsyncMessage("Content:LocationChange", json);
67112: 
77160:     this._firstPaint = false;
77160:     let self = this;
77160: 
78745:     // Keep track of hash changes
78745:     this.hashChanged = (location == this._lastLocation);
78745:     this._lastLocation = location;
78745: 
67449:     // When a new page is loaded fire a message for the first paint
67449:     addEventListener("MozAfterPaint", function(aEvent) {
67449:       removeEventListener("MozAfterPaint", arguments.callee, true);
67465: 
77160:       self._firstPaint = true;
67465:       let scrollOffset = ContentScroll.getScrollOffset(content);
67465:       sendAsyncMessage("Browser:FirstPaint", scrollOffset);
67449:     }, true);
66264:   },
66264: 
66264:   onStatusChange: function onStatusChange(aWebProgress, aRequest, aStatus, aMessage) {
66264:   },
66264: 
66264:   onSecurityChange: function onSecurityChange(aWebProgress, aRequest, aState) {
67237:     if (content != aWebProgress.DOMWindow)
67237:       return;
67237: 
66917:     let serialization = SecurityUI.getSSLStatusAsString();
66292: 
66264:     let json = {
67091:       contentWindowId: content.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID,
66917:       SSLStatusAsString: serialization,
66264:       state: aState
66264:     };
66264: 
67237:     sendAsyncMessage("Content:SecurityChange", json);
66400:   },
66400: 
66264:   QueryInterface: function QueryInterface(aIID) {
66264:     if (aIID.equals(Ci.nsIWebProgressListener) ||
66264:         aIID.equals(Ci.nsISupportsWeakReference) ||
66264:         aIID.equals(Ci.nsISupports)) {
66264:         return this;
66264:     }
66264: 
66264:     throw Components.results.NS_ERROR_NO_INTERFACE;
66292:   }
66292: };
66264: 
66400: WebProgressListener.init();
66400: 
66292: 
66292: let SecurityUI = {
66917:   getSSLStatusAsString: function() {
66264:     let status = docShell.securityUI.QueryInterface(Ci.nsISSLStatusProvider).SSLStatus;
66264: 
66264:     if (status) {
66917:       let serhelper = Cc["@mozilla.org/network/serialization-helper;1"]
66917:                       .getService(Ci.nsISerializationHelper);
66264: 
66917:       status.QueryInterface(Ci.nsISerializable);
66917:       return serhelper.serializeToString(status);
66264:     }
66264: 
66917:     return null;
66264:   }
66264: };
66264: 
66264: let WebNavigation =  {
66264:   _webNavigation: docShell.QueryInterface(Ci.nsIWebNavigation),
72262:   _timer: null,
66264: 
66264:   init: function() {
66264:     addMessageListener("WebNavigation:GoBack", this);
66264:     addMessageListener("WebNavigation:GoForward", this);
66264:     addMessageListener("WebNavigation:GotoIndex", this);
66264:     addMessageListener("WebNavigation:LoadURI", this);
66264:     addMessageListener("WebNavigation:Reload", this);
66264:     addMessageListener("WebNavigation:Stop", this);
66264:   },
66264: 
66264:   receiveMessage: function(message) {
66264:     switch (message.name) {
66264:       case "WebNavigation:GoBack":
77066:         this.goBack();
66264:         break;
66264:       case "WebNavigation:GoForward":
77066:         this.goForward();
66264:         break;
66264:       case "WebNavigation:GotoIndex":
66264:         this.gotoIndex(message);
66264:         break;
66264:       case "WebNavigation:LoadURI":
66264:         this.loadURI(message);
66264:         break;
66264:       case "WebNavigation:Reload":
66264:         this.reload(message);
66264:         break;
66264:       case "WebNavigation:Stop":
66264:         this.stop(message);
66264:         break;
66264:     }
66264:   },
66264: 
66264:   goBack: function() {
77067:     if (this._webNavigation.canGoBack)
66264:       this._webNavigation.goBack();
66264:   },
66264: 
66264:   goForward: function() {
77067:     if (this._webNavigation.canGoForward)
66264:       this._webNavigation.goForward();
66264:   },
66264: 
66264:   gotoIndex: function(message) {
66264:     this._webNavigation.gotoIndex(message.index);
66264:   },
66264: 
66264:   loadURI: function(message) {
66264:     let flags = message.json.flags || this._webNavigation.LOAD_FLAGS_NONE;
66264:     this._webNavigation.loadURI(message.json.uri, flags, null, null, null);
72262: 
72262:     let tabData = message.json;
72262:     if (tabData.entries) {
72262:       // We are going to load from history so kill the current load. We do not
72262:       // want the load added to the history anyway. We reload after resetting history
72262:       this._webNavigation.stop(this._webNavigation.STOP_ALL);
72262:       this._restoreHistory(tabData, 0);
72262:     }
72262:   },
72262: 
72337:   reload: function(message) {
72337:     let flags = message.json.flags || this._webNavigation.LOAD_FLAGS_NONE;
72337:     this._webNavigation.reload(flags);
72337:   },
72337: 
72337:   stop: function(message) {
72337:     let flags = message.json.flags || this._webNavigation.STOP_ALL;
72337:     this._webNavigation.stop(flags);
72337:   },
72337: 
72262:   _restoreHistory: function _restoreHistory(aTabData, aCount) {
72262:     // We need to wait for the sessionHistory to be initialized and there
72262:     // is no good way to do this. We'll try a wait loop like desktop
72262:     try {
72262:       if (!this._webNavigation.sessionHistory)
72262:         throw new Error();
72262:     } catch (ex) {
72262:       if (aCount < 10) {
72262:         let self = this;
72262:         this._timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
72262:         this._timer.initWithCallback(function(aTimer) {
72262:           self._timer = null;
72262:           self._restoreHistory(aTabData, aCount + 1);
72262:         }, 100, Ci.nsITimer.TYPE_ONE_SHOT);
72262:         return;
72262:       }
72262:     }
72262: 
72262:     let history = this._webNavigation.sessionHistory;
72262:     if (history.count > 0)
72262:       history.PurgeHistory(history.count);
72262:     history.QueryInterface(Ci.nsISHistoryInternal);
72262: 
72262:     // helper hashes for ensuring unique frame IDs and unique document
72262:     // identifiers.
72262:     let idMap = { used: {} };
72262:     let docIdentMap = {};
72262: 
72262:     for (let i = 0; i < aTabData.entries.length; i++) {
72262:       if (!aTabData.entries[i].url)
72262:         continue;
72262:       history.addEntry(this._deserializeHistoryEntry(aTabData.entries[i], idMap, docIdentMap), true);
72262:     }
72262: 
72262:     // We need to force set the active history item and cause it to reload since
72262:     // we stop the load above
72262:     let activeIndex = (aTabData.index || aTabData.entries.length) - 1;
72262:     history.getEntryAtIndex(activeIndex, true);
72262:     history.QueryInterface(Ci.nsISHistory).reloadCurrentEntry();
72262:   },
72262: 
72262:   _deserializeHistoryEntry: function _deserializeHistoryEntry(aEntry, aIdMap, aDocIdentMap) {
72262:     let shEntry = Cc["@mozilla.org/browser/session-history-entry;1"].createInstance(Ci.nsISHEntry);
72262: 
72262:     shEntry.setURI(Services.io.newURI(aEntry.url, null, null));
72262:     shEntry.setTitle(aEntry.title || aEntry.url);
72262:     if (aEntry.subframe)
72262:       shEntry.setIsSubFrame(aEntry.subframe || false);
72262:     shEntry.loadType = Ci.nsIDocShellLoadInfo.loadHistory;
72262:     if (aEntry.contentType)
72262:       shEntry.contentType = aEntry.contentType;
72262:     if (aEntry.referrer)
72262:       shEntry.referrerURI = Services.io.newURI(aEntry.referrer, null, null);
72262: 
72262:     if (aEntry.cacheKey) {
72262:       let cacheKey = Cc["@mozilla.org/supports-PRUint32;1"].createInstance(Ci.nsISupportsPRUint32);
72262:       cacheKey.data = aEntry.cacheKey;
72262:       shEntry.cacheKey = cacheKey;
72262:     }
72262: 
72262:     if (aEntry.ID) {
72262:       // get a new unique ID for this frame (since the one from the last
72262:       // start might already be in use)
72262:       let id = aIdMap[aEntry.ID] || 0;
72262:       if (!id) {
72262:         for (id = Date.now(); id in aIdMap.used; id++);
72262:         aIdMap[aEntry.ID] = id;
72262:         aIdMap.used[id] = true;
72262:       }
72262:       shEntry.ID = id;
72262:     }
72262: 
72262:     if (aEntry.docshellID)
72262:       shEntry.docshellID = aEntry.docshellID;
72262: 
80731:     if (aEntry.structuredCloneState && aEntry.structuredCloneVersion) {
80731:       shEntry.stateData =
80731:         Cc["@mozilla.org/docshell/structured-clone-container;1"].
80731:         createInstance(Ci.nsIStructuredCloneContainer);
80731: 
80731:       shEntry.stateData.initFromBase64(aEntry.structuredCloneState, aEntry.structuredCloneVersion);
80731:     }
72262: 
72262:     if (aEntry.scroll) {
72262:       let scrollPos = aEntry.scroll.split(",");
72262:       scrollPos = [parseInt(scrollPos[0]) || 0, parseInt(scrollPos[1]) || 0];
72262:       shEntry.setScrollPosition(scrollPos[0], scrollPos[1]);
72262:     }
72262: 
72262:     if (aEntry.docIdentifier) {
80731:       // If we have a serialized document identifier, try to find an SHEntry
80731:       // which matches that doc identifier and adopt that SHEntry's
80731:       // BFCacheEntry.  If we don't find a match, insert shEntry as the match
80731:       // for the document identifier.
80731:       let matchingEntry = aDocIdentMap[aEntry.docIdentifier];
80731:       if (!matchingEntry) {
80731:         aDocIdentMap[aEntry.docIdentifier] = shEntry;
72262:       } else {
80731:         shEntry.adoptBFCacheEntry(matchingEntry);
72262:       }
72262:     }
72262: 
72262:     if (aEntry.owner_b64) {
72262:       let ownerInput = Cc["@mozilla.org/io/string-input-stream;1"].createInstance(Ci.nsIStringInputStream);
72262:       let binaryData = atob(aEntry.owner_b64);
72262:       ownerInput.setData(binaryData, binaryData.length);
72262:       let binaryStream = Cc["@mozilla.org/binaryinputstream;1"].createInstance(Ci.nsIObjectInputStream);
72262:       binaryStream.setInputStream(ownerInput);
72262:       try { // Catch possible deserialization exceptions
72262:         shEntry.owner = binaryStream.readObject(true);
72262:       } catch (ex) { dump(ex); }
72262:     }
72262: 
72262:     if (aEntry.children && shEntry instanceof Ci.nsISHContainer) {
72262:       for (let i = 0; i < aEntry.children.length; i++) {
72262:         if (!aEntry.children[i].url)
72262:           continue;
72262:         shEntry.AddChild(this._deserializeHistoryEntry(aEntry.children[i], aIdMap, aDocIdentMap), i);
72262:       }
72262:     }
72262:     
72262:     return shEntry;
66264:   },
66264: 
72337:   sendHistory: function sendHistory() {
72337:     // We need to package up the session history and send it to the sessionstore
72337:     let entries = [];
72337:     let history = docShell.QueryInterface(Ci.nsIWebNavigation).sessionHistory;
72337:     for (let i = 0; i < history.count; i++) {
72337:       let entry = this._serializeHistoryEntry(history.getEntryAtIndex(i, false));
72337:       entries.push(entry);
72337:     }
72337:     let index = history.index + 1;
72337:     sendAsyncMessage("Content:SessionHistory", { entries: entries, index: index });
66264:   },
66264: 
72337:   _serializeHistoryEntry: function _serializeHistoryEntry(aEntry) {
72337:     let entry = { url: aEntry.URI.spec };
72337: 
72337:     if (aEntry.title && aEntry.title != entry.url)
72337:       entry.title = aEntry.title;
72337: 
72337:     if (!(aEntry instanceof Ci.nsISHEntry))
72337:       return entry;
72337: 
72337:     let cacheKey = aEntry.cacheKey;
72337:     if (cacheKey && cacheKey instanceof Ci.nsISupportsPRUint32 && cacheKey.data != 0)
72337:       entry.cacheKey = cacheKey.data;
72337: 
72337:     entry.ID = aEntry.ID;
72337:     entry.docshellID = aEntry.docshellID;
72337: 
72337:     if (aEntry.referrerURI)
72337:       entry.referrer = aEntry.referrerURI.spec;
72337: 
72337:     if (aEntry.contentType)
72337:       entry.contentType = aEntry.contentType;
72337: 
72337:     let x = {}, y = {};
72337:     aEntry.getScrollPosition(x, y);
72337:     if (x.value != 0 || y.value != 0)
72337:       entry.scroll = x.value + "," + y.value;
72337: 
72337:     if (aEntry.owner) {
72337:       try {
72337:         let binaryStream = Cc["@mozilla.org/binaryoutputstream;1"].createInstance(Ci.nsIObjectOutputStream);
72337:         let pipe = Cc["@mozilla.org/pipe;1"].createInstance(Ci.nsIPipe);
72337:         pipe.init(false, false, 0, 0xffffffff, null);
72337:         binaryStream.setOutputStream(pipe.outputStream);
72337:         binaryStream.writeCompoundObject(aEntry.owner, Ci.nsISupports, true);
72337:         binaryStream.close();
72337: 
72337:         // Now we want to read the data from the pipe's input end and encode it.
72337:         let scriptableStream = Cc["@mozilla.org/binaryinputstream;1"].createInstance(Ci.nsIBinaryInputStream);
72337:         scriptableStream.setInputStream(pipe.inputStream);
72337:         let ownerBytes = scriptableStream.readByteArray(scriptableStream.available());
72337:         // We can stop doing base64 encoding once our serialization into JSON
72337:         // is guaranteed to handle all chars in strings, including embedded
72337:         // nulls.
72337:         entry.owner_b64 = btoa(String.fromCharCode.apply(null, ownerBytes));
72337:       } catch (e) { dump(e); }
72337:     }
72337: 
80731:     entry.docIdentifier = aEntry.BFCacheEntry.ID;
72337: 
80731:     if (aEntry.stateData != null) {
80731:       entry.structuredCloneState = aEntry.stateData.getDataAsBase64();
80731:       entry.structuredCloneVersion = aEntry.stateData.formatVersion;
80731:     }
72337: 
72337:     if (!(aEntry instanceof Ci.nsISHContainer))
72337:       return entry;
72337: 
72337:     if (aEntry.childCount > 0) {
72337:       entry.children = [];
72337:       for (let i = 0; i < aEntry.childCount; i++) {
72337:         let child = aEntry.GetChildAt(i);
72337:         if (child)
72337:           entry.children.push(this._serializeHistoryEntry(child));
72337:         else // to maintain the correct frame order, insert a dummy entry 
72337:           entry.children.push({ url: "about:blank" });
72337: 
72337:         // don't try to restore framesets containing wyciwyg URLs (cf. bug 424689 and bug 450595)
72337:         if (/^wyciwyg:\/\//.test(entry.children[i].url)) {
72337:           delete entry.children;
72337:           break;
72337:         }
72337:       }
72337:     }
72337: 
72337:     return entry;
66264:   }
66264: };
66264: 
66264: WebNavigation.init();
66264: 
66264: 
66264: let DOMEvents =  {
66264:   init: function() {
66264:     addEventListener("DOMContentLoaded", this, false);
66264:     addEventListener("DOMTitleChanged", this, false);
66264:     addEventListener("DOMLinkAdded", this, false);
66264:     addEventListener("DOMWillOpenModalDialog", this, false);
66479:     addEventListener("DOMModalDialogClosed", this, true);
66264:     addEventListener("DOMWindowClose", this, false);
66265:     addEventListener("DOMPopupBlocked", this, false);
66265:     addEventListener("pageshow", this, false);
66265:     addEventListener("pagehide", this, false);
66264:   },
66264: 
66264:   handleEvent: function(aEvent) {
66265:     let document = content.document;
66264:     switch (aEvent.type) {
66264:       case "DOMContentLoaded":
66265:         if (document.documentURIObject.spec == "about:blank")
66264:           return;
66264: 
66324:         sendAsyncMessage("DOMContentLoaded", { });
72337: 
72337:         // Send the session history now too
72337:         WebNavigation.sendHistory();
66264:         break;
66265: 
66265:       case "pageshow":
66265:       case "pagehide": {
67279:         if (aEvent.target.defaultView != content)
67279:           break;
67279: 
66265:         let util = aEvent.target.defaultView.QueryInterface(Ci.nsIInterfaceRequestor)
66265:                                             .getInterface(Ci.nsIDOMWindowUtils);
66265: 
66265:         let json = {
67511:           contentWindowWidth: content.innerWidth,
67511:           contentWindowHeight: content.innerHeight,
66265:           windowId: util.outerWindowID,
66265:           persisted: aEvent.persisted
66265:         };
66265: 
78745:         // Clear onload focus to prevent the VKB to be shown unexpectingly
78745:         // but only if the location has really changed and not only the
78745:         // fragment identifier
78745:         let contentWindowID = content.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
78745:         if (!WebProgressListener.hashChanged && contentWindowID == util.currentInnerWindowID) {
78745:           let focusManager = Cc["@mozilla.org/focus-manager;1"].getService(Ci.nsIFocusManager);
78745:           focusManager.clearFocus(content);
78745:         }
78745: 
66324:         sendAsyncMessage(aEvent.type, json);
66265:         break;
66265:       }
66265: 
66265:       case "DOMPopupBlocked": {
66265:         let util = aEvent.requestingWindow.QueryInterface(Ci.nsIInterfaceRequestor)
66265:                                           .getInterface(Ci.nsIDOMWindowUtils);
66265:         let json = {
66265:           windowId: util.outerWindowID,
66265:           popupWindowURI: {
66265:             spec: aEvent.popupWindowURI.spec,
66265:             charset: aEvent.popupWindowURI.originCharset
66265:           },
66265:           popupWindowFeatures: aEvent.popupWindowFeatures,
66265:           popupWindowName: aEvent.popupWindowName
66265:         };
66265: 
66324:         sendAsyncMessage("DOMPopupBlocked", json);
66265:         break;
66265:       }
66265: 
66264:       case "DOMTitleChanged":
66324:         sendAsyncMessage("DOMTitleChanged", { title: document.title });
66264:         break;
66265: 
66264:       case "DOMLinkAdded":
66265:         let target = aEvent.originalTarget;
66265:         if (!target.href || target.disabled)
66264:           return;
66264: 
66264:         let json = {
66302:           windowId: target.ownerDocument.defaultView.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID,
66265:           href: target.href,
66265:           charset: document.characterSet,
66265:           title: target.title,
66265:           rel: target.rel,
66265:           type: target.type
66264:         };
66264:         
73651:         // rel=icon can also have a sizes attribute
73651:         if (target.hasAttribute("sizes"))
73651:           json.sizes = target.getAttribute("sizes");
73651: 
66324:         sendAsyncMessage("DOMLinkAdded", json);
66264:         break;
66265: 
66265:       case "DOMWillOpenModalDialog":
66479:       case "DOMModalDialogClosed":
66265:       case "DOMWindowClose":
66368:         let retvals = sendSyncMessage(aEvent.type, { });
67529:         for (let i in retvals) {
67529:           if (retvals[i].preventDefault) {
66265:             aEvent.preventDefault();
66265:             break;
66265:           }
66265:         }
66265:         break;
66264:     }
66264:   }
66264: };
66264: 
66264: DOMEvents.init();
66306: 
66306: let ContentScroll =  {
67394:   _scrollOffset: { x: 0, y: 0 },
67278: 
66306:   init: function() {
66615:     addMessageListener("Content:SetCacheViewport", this);
66657:     addMessageListener("Content:SetWindowSize", this);
66610: 
66610:     addEventListener("scroll", this, false);
67520:     addEventListener("pagehide", this, false);
66610:     addEventListener("MozScrolledAreaChanged", this, false);
66306:   },
66306: 
67358:   getScrollOffset: function(aWindow) {
67358:     let cwu = aWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
67358:     let scrollX = {}, scrollY = {};
67358:     cwu.getScrollXY(false, scrollX, scrollY);
67358:     return { x: scrollX.value, y: scrollY.value };
67358:   },
67358: 
67394:   getScrollOffsetForElement: function(aElement) {
67516:     if (aElement.parentNode == aElement.ownerDocument)
67394:       return this.getScrollOffset(aElement.ownerDocument.defaultView);
67516:     return { x: aElement.scrollLeft, y: aElement.scrollTop };
67394:   },
67394: 
67394:   setScrollOffsetForElement: function(aElement, aLeft, aTop) {
67516:     if (aElement.parentNode == aElement.ownerDocument) {
67394:       aElement.ownerDocument.defaultView.scrollTo(aLeft, aTop);
67516:     } else {
67516:       aElement.scrollLeft = aLeft;
67516:       aElement.scrollTop = aTop;
67516:     }
67394:   },
67394: 
66306:   receiveMessage: function(aMessage) {
66306:     let json = aMessage.json;
66306:     switch (aMessage.name) {
66615:       case "Content:SetCacheViewport": {
67394:         // Set resolution for root view
67358:         let rootCwu = content.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
77160:         if (json.id == 1) {
67252:           rootCwu.setResolution(json.scale, json.scale);
77160:           if (!WebProgressListener._firstPaint)
77160:             break;
77160:         }
67252: 
66615:         let displayport = new Rect(json.x, json.y, json.w, json.h);
66610:         if (displayport.isEmpty())
66610:           break;
66610: 
67394:         // Map ID to element
71440:         let element = null;
71440:         try {
71440:           element = rootCwu.findElementWithViewId(json.id);
71440:         } catch(e) {
71440:           // This could give NS_ERROR_NOT_AVAILABLE. In that case, the
71440:           // presshell is not available because the page is reloading.
71440:         }
71440: 
67252:         if (!element)
67252:           break;
67252: 
70038:         let binding = element.ownerDocument.getBindingParent(element);
70038:         if (binding instanceof Ci.nsIDOMHTMLInputElement && binding.mozIsTextField(false))
70038:           break;
70038: 
67394:         // Set the scroll offset for this element if specified
67394:         if (json.scrollX >= 0 && json.scrollY >= 0) {
67394:           this.setScrollOffsetForElement(element, json.scrollX, json.scrollY)
67394:           if (json.id == 1)
67394:             this._scrollOffset = this.getScrollOffset(content);
67252:         }
67252: 
67394:         // Set displayport. We want to set this after setting the scroll offset, because
67394:         // it is calculated based on the scroll offset.
67394:         let scrollOffset = this.getScrollOffsetForElement(element);
67466:         let x = displayport.x - scrollOffset.x;
67466:         let y = displayport.y - scrollOffset.y;
67466: 
67466:         if (json.id == 1) {
67466:           x = Math.round(x * json.scale) / json.scale;
67466:           y = Math.round(y * json.scale) / json.scale;
67466:         }
67466: 
67394:         let win = element.ownerDocument.defaultView;
67358:         let winCwu = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
67541:         winCwu.setDisplayPortForElement(x, y, displayport.width, displayport.height, element);
66610:         break;
66610:       }
66610: 
66657:       case "Content:SetWindowSize": {
67358:         let cwu = content.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
66610:         cwu.setCSSViewport(json.width, json.height);
66610:         break;
66610:       }
66610:     }
66610:   },
66610: 
66610:   handleEvent: function(aEvent) {
66610:     switch (aEvent.type) {
67520:       case "pagehide":
67520:         this._scrollOffset = { x: 0, y: 0 };
67520:         break;
67520: 
67252:       case "scroll": {
67252:         let doc = aEvent.target;
67252:         if (doc != content.document)
67394:           break;
67252: 
67448:         this.sendScroll();
66610:         break;
67252:       }
66606: 
66606:       case "MozScrolledAreaChanged": {
66606:         let doc = aEvent.originalTarget;
66651:         if (content != doc.defaultView) // We are only interested in root scroll pane changes
66651:           return;
66651: 
66606:         sendAsyncMessage("MozScrolledAreaChanged", {
70103:           width: aEvent.width,
70103:           height: aEvent.height,
77804:           left: aEvent.x + content.scrollX
66606:         });
66606: 
76820:         // Send event only after painting to make sure content views in the parent process have
76820:         // been updated.
76820:         addEventListener("MozAfterPaint", function afterPaint() {
76820:           removeEventListener("MozAfterPaint", afterPaint, false);
76820:           sendAsyncMessage("Content:UpdateDisplayPort");
76820:         }, false);
76820: 
66606:         break;
66606:       }
66306:     }
67448:   },
67448: 
67448:   sendScroll: function sendScroll() {
67448:     let scrollOffset = this.getScrollOffset(content);
67448:     if (this._scrollOffset.x == scrollOffset.x && this._scrollOffset.y == scrollOffset.y)
67448:       return;
67448: 
67448:     this._scrollOffset = scrollOffset;
67448:     sendAsyncMessage("scroll", scrollOffset);
66306:   }
66306: };
66306: 
66306: ContentScroll.init();
66409: 
67043: let ContentActive =  {
67043:   init: function() {
67043:     addMessageListener("Content:Activate", this);
67043:     addMessageListener("Content:Deactivate", this);
67043:   },
67043: 
67043:   receiveMessage: function(aMessage) {
67043:     let json = aMessage.json;
67043:     switch (aMessage.name) {
67054:       case "Content:Deactivate":
67043:         docShell.isActive = false;
67358:         let cwu = content.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
67541:         cwu.setDisplayPortForElement(0,0,0,0,content.document.documentElement);
67043:         break;
67043: 
67054:       case "Content:Activate":
67043:         docShell.isActive = true;
67043:         break;
67043:     }
67043:   }
67043: };
67043: 
67043: ContentActive.init();
69152: 
69152: /**
69152:  * Helper class for IndexedDB, child part. Listens using
69152:  * the observer service for events regarding IndexedDB
69152:  * prompts, and sends messages to the parent to actually
69152:  * show the prompts.
69152:  */
69152: let IndexedDB = {
69152:   _permissionsPrompt: "indexedDB-permissions-prompt",
69152:   _permissionsResponse: "indexedDB-permissions-response",
69152: 
69152:   _quotaPrompt: "indexedDB-quota-prompt",
69152:   _quotaResponse: "indexedDB-quota-response",
69152:   _quotaCancel: "indexedDB-quota-cancel",
69152: 
69152:   waitingObservers: [],
69152: 
69152:   init: function IndexedDBPromptHelper_init() {
69152:     let os = Services.obs;
69152:     os.addObserver(this, this._permissionsPrompt, false);
69152:     os.addObserver(this, this._quotaPrompt, false);
69152:     os.addObserver(this, this._quotaCancel, false);
69152:     addMessageListener("IndexedDB:Response", this);
69152:   },
69152: 
69152:   observe: function IndexedDBPromptHelper_observe(aSubject, aTopic, aData) {
69152:     if (aTopic != this._permissionsPrompt && aTopic != this._quotaPrompt && aTopic != this._quotaCancel) {
69152:       throw new Error("Unexpected topic!");
69152:     }
69152: 
69152:     let requestor = aSubject.QueryInterface(Ci.nsIInterfaceRequestor);
69152:     let observer = requestor.getInterface(Ci.nsIObserver);
69152: 
69152:     let contentWindow = requestor.getInterface(Ci.nsIDOMWindow);
69152:     let contentDocument = contentWindow.document;
69152: 
69152:     if (aTopic == this._quotaCancel) {
69152:       observer.observe(null, this._quotaResponse, Ci.nsIPermissionManager.UNKNOWN_ACTION);
69152:       return;
69152:     }
69152: 
69152:     // Remote to parent
69152:     sendAsyncMessage("IndexedDB:Prompt", {
69152:       topic: aTopic,
69152:       host: contentDocument.documentURIObject.asciiHost,
69152:       location: contentDocument.location.toString(),
69152:       data: aData,
72262:       observerId: this.addWaitingObserver(observer)
69152:     });
69152:   },
69152: 
69152:   receiveMessage: function(aMessage) {
69152:     let payload = aMessage.json;
69152:     switch (aMessage.name) {
69152:       case "IndexedDB:Response":
69152:         let observer = this.getAndRemoveWaitingObserver(payload.observerId);
69152:         observer.observe(null, payload.responseTopic, payload.permission);
69152:     }
69152:   },
69152: 
69152:   addWaitingObserver: function(aObserver) {
69152:     let observerId = 0;
69152:     while (observerId in this.waitingObservers)
69152:       observerId++;
69152:     this.waitingObservers[observerId] = aObserver;
69152:     return observerId;
69152:   },
69152: 
69152:   getAndRemoveWaitingObserver: function(aObserverId) {
69152:     let observer = this.waitingObservers[aObserverId];
69152:     delete this.waitingObservers[aObserverId];
69152:     return observer;
72262:   }
69152: };
69152: 
69152: IndexedDB.init();
69152: 
