61170: /* ***** BEGIN LICENSE BLOCK *****
61170:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
61170:  *
61170:  * The contents of this file are subject to the Mozilla Public License Version
61170:  * 1.1 (the "License"); you may not use this file except in compliance with
61170:  * the License. You may obtain a copy of the License at
61170:  * http://www.mozilla.org/MPL/
61170:  *
61170:  * Software distributed under the License is distributed on an "AS IS" basis,
61170:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
61170:  * for the specific language governing rights and limitations under the
61170:  * License.
61170:  *
61170:  * The Original Code is elfhack.
61170:  *
61170:  * The Initial Developer of the Original Code is
61170:  * Mozilla Foundation.
61170:  * Portions created by the Initial Developer are Copyright (C) 2010
61170:  * the Initial Developer. All Rights Reserved.
61170:  *
61170:  * Contributor(s):
61170:  *   Mike Hommey <mh@glandium.org>
61170:  *
61170:  * Alternatively, the contents of this file may be used under the terms of
61170:  * either the GNU General Public License Version 2 or later (the "GPL"), or
61170:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
61170:  * in which case the provisions of the GPL or the LGPL are applicable instead
61170:  * of those above. If you wish to allow use of your version of this file only
61170:  * under the terms of either the GPL or the LGPL, and not to allow others to
61170:  * use your version of this file under the terms of the MPL, indicate your
61170:  * decision by deleting the provisions above and replace them with the notice
61170:  * and other provisions required by the GPL or the LGPL. If you do not delete
61170:  * the provisions above, a recipient may use your version of this file under
61170:  * the terms of any one of the MPL, the GPL or the LGPL.
61170:  *
61170:  * ***** END LICENSE BLOCK ***** */
61170: 
61170: #include <stdexcept>
61170: #include <list>
61170: #include <vector>
61170: #include <cstring>
61170: #include <iostream>
61170: #include <fstream>
74783: #include <algorithm>
61170: #include <elf.h>
61170: #include <asm/byteorder.h>
61170: 
61170: // Technically, __*_to_cpu and __cpu_to* function are equivalent,
61170: // so swap can use either of both.
61170: #define def_swap(endian, type, bits) \
61170: static inline type ## bits ## _t swap(type ## bits ## _t i) { \
61170:     return __ ## endian ## bits ## _to_cpu(i); \
61170: }
61170: 
61170: class little_endian {
61170: public:
61170: def_swap(le, uint, 16);
61170: def_swap(le, uint, 32);
61170: def_swap(le, uint, 64);
61170: def_swap(le, int, 16);
61170: def_swap(le, int, 32);
61170: def_swap(le, int, 64);
61170: };
61170: 
61170: class big_endian {
61170: public:
61170: def_swap(be, uint, 16);
61170: def_swap(be, uint, 32);
61170: def_swap(be, uint, 64);
61170: def_swap(be, int, 16);
61170: def_swap(be, int, 32);
61170: def_swap(be, int, 64);
61170: };
61170: 
61170: // forward declaration
61170: class ElfSection;
61170: class ElfSegment;
61170: // TODO: Rename Elf_* types
61170: class Elf_Ehdr;
61170: class Elf_Phdr;
61170: class Elf;
61170: class ElfDynamic_Section;
61170: class ElfStrtab_Section;
61170: 
61170: class Elf_Ehdr_Traits {
61170: public:
61170:     typedef Elf32_Ehdr Type32;
61170:     typedef Elf64_Ehdr Type64;
61170: 
61170:     template <class endian, typename R, typename T>
61170:     static void swap(T &t, R &r);
61170: };
61170: 
61170: class Elf_Phdr_Traits {
61170: public:
61170:     typedef Elf32_Phdr Type32;
61170:     typedef Elf64_Phdr Type64;
61170: 
61170:     template <class endian, typename R, typename T>
61170:     static void swap(T &t, R &r);
61170: };
61170: 
61170: class Elf_Shdr_Traits {
61170: public:
61170:     typedef Elf32_Shdr Type32;
61170:     typedef Elf64_Shdr Type64;
61170: 
61170:     template <class endian, typename R, typename T>
61170:     static void swap(T &t, R &r);
61170: };
61170: 
61170: class Elf_Dyn_Traits {
61170: public:
61170:     typedef Elf32_Dyn Type32;
61170:     typedef Elf64_Dyn Type64;
61170: 
61170:     template <class endian, typename R, typename T>
61170:     static void swap(T &t, R &r);
61170: };
61170: 
61170: class Elf_Sym_Traits {
61170: public:
61170:     typedef Elf32_Sym Type32;
61170:     typedef Elf64_Sym Type64;
61170: 
61170:     template <class endian, typename R, typename T>
61170:     static void swap(T &t, R &r);
61170: };
61170: 
61170: class Elf_Rel_Traits {
61170: public:
61170:     typedef Elf32_Rel Type32;
61170:     typedef Elf64_Rel Type64;
61170: 
61170:     template <class endian, typename R, typename T>
61170:     static void swap(T &t, R &r);
61170: };
61170: 
61170: class Elf_Rela_Traits {
61170: public:
61170:     typedef Elf32_Rela Type32;
61170:     typedef Elf64_Rela Type64;
61170: 
61170:     template <class endian, typename R, typename T>
61170:     static void swap(T &t, R &r);
61170: };
61170: 
61170: class ElfValue {
61170: public:
61170:     virtual unsigned int getValue() { return 0; }
61170:     virtual ElfSection *getSection() { return NULL; }
61170: };
61170: 
61170: class ElfPlainValue: public ElfValue {
61170:     unsigned int value;
61170: public:
61170:     ElfPlainValue(unsigned int val): value(val) {};
61170:     unsigned int getValue() { return value; }
61170: };
61170: 
61170: class ElfLocation: public ElfValue {
61170:     ElfSection *section;
61170:     unsigned int offset;
61170: public:
61509:     enum position { ABSOLUTE, RELATIVE };
61170:     ElfLocation(): section(NULL), offset(0) {};
61509:     ElfLocation(ElfSection *section, unsigned int off, enum position pos = RELATIVE);
61170:     ElfLocation(unsigned int location, Elf *elf);
61170:     unsigned int getValue();
61170:     ElfSection *getSection() { return section; }
61170: };
61170: 
61170: class ElfSize: public ElfValue {
61170:     ElfSection *section;
61170: public:
61170:     ElfSize(ElfSection *s): section(s) {};
61170:     unsigned int getValue();
61170:     ElfSection *getSection() { return section; }
61170: };
61170: 
61170: class ElfEntSize: public ElfValue {
61170:     ElfSection *section;
61170: public:
61170:     ElfEntSize(ElfSection *s): section(s) {};
61170:     unsigned int getValue();
61170:     ElfSection *getSection() { return section; }
61170: };
61170: 
61170: template <typename T>
61170: class serializable: public T::Type32 {
61170: public:
61170:     serializable() {};
61170:     serializable(const typename T::Type32 &p): T::Type32(p) {};
72591: 
72591: private:
72591:     template <typename R>
72591:     void init(const char *buf, size_t len, char ei_data)
72591:     {
72591:         R e;
72591:         assert(len <= sizeof(e));
72591:         memcpy(&e, buf, sizeof(e));
72591:         if (ei_data == ELFDATA2LSB) {
72591:             T::template swap<little_endian>(e, *this);
72591:             return;
72591:         } else if (ei_data == ELFDATA2MSB) {
72591:             T::template swap<big_endian>(e, *this);
72591:             return;
72591:         }
72591:         throw std::runtime_error("Unsupported ELF data encoding");
72591:     }
72591: 
72591: public:
72591:     serializable(const char *buf, size_t len, char ei_class, char ei_data)
72591:     {
72591:         if (ei_class == ELFCLASS32) {
72591:             init<typename T::Type32>(buf, len, ei_data);
72591:             return;
72591:         } else if (ei_class == ELFCLASS64) {
72591:             init<typename T::Type64>(buf, len, ei_data);
72591:             return;
72591:         }
72591:         throw std::runtime_error("Unsupported ELF class");
72591:     }
72591: 
61170:     serializable(std::ifstream &file, char ei_class, char ei_data)
61170:     {
61170:         if (ei_class == ELFCLASS32) {
61170:             typename T::Type32 e;
61170:             file.read((char *)&e, sizeof(e));
61170:             if (ei_data == ELFDATA2LSB) {
61170:                 T::template swap<little_endian>(e, *this);
61170:                 return;
61170:             } else if (ei_data == ELFDATA2MSB) {
61170:                 T::template swap<big_endian>(e, *this);
61170:                 return;
61170:             }
61170:         } else if (ei_class == ELFCLASS64) {
61170:             typename T::Type64 e;
61170:             file.read((char *)&e, sizeof(e));
61170:             if (ei_data == ELFDATA2LSB) {
61170:                 T::template swap<little_endian>(e, *this);
61170:                 return;
61170:             } else if (ei_data == ELFDATA2MSB) {
61170:                 T::template swap<big_endian>(e, *this);
61170:                 return;
61170:             }
61170:         }
61170:         throw std::runtime_error("Unsupported ELF class or data encoding");
61170:     }
61170: 
61170:     void serialize(std::ofstream &file, char ei_class, char ei_data)
61170:     {
61170:         if (ei_class == ELFCLASS32) {
61170:             typename T::Type32 e;
61170:             if (ei_data == ELFDATA2LSB) {
61170:                 T::template swap<little_endian>(*this, e);
61170:                 file.write((char *)&e, sizeof(e));
61170:                 return;
61170:             } else if (ei_data == ELFDATA2MSB) {
61170:                 T::template swap<big_endian>(*this, e);
61170:                 file.write((char *)&e, sizeof(e));
61170:                 return;
61170:             }
61170:         } else if (ei_class == ELFCLASS64) {
61170:             typename T::Type64 e;
61170:             if (ei_data == ELFDATA2LSB) {
61170:                 T::template swap<little_endian>(*this, e);
61170:                 file.write((char *)&e, sizeof(e));
61170:                 return;
61170:             } else if (ei_data == ELFDATA2MSB) {
61170:                 T::template swap<big_endian>(*this, e);
61170:                 file.write((char *)&e, sizeof(e));
61170:                 return;
61170:             }
61170:         }
61170:         throw std::runtime_error("Unsupported ELF class or data encoding");
61170:     }
61170: 
76729:     static inline unsigned int size(char ei_class)
61170:     {
61170:         if (ei_class == ELFCLASS32)
61170:             return sizeof(typename T::Type32);
61170:         else if (ei_class == ELFCLASS64)
61170:             return sizeof(typename T::Type64);
61170:         return 0;
61170:     }
61170: };
61170: 
61170: typedef serializable<Elf_Shdr_Traits> Elf_Shdr;
61170: 
61170: class Elf {
61170: public:
61170:     Elf(std::ifstream &file);
61170:     ~Elf();
61170: 
61170:     /* index == -1 is treated as index == ehdr.e_shstrndx */
61170:     ElfSection *getSection(int index);
61170: 
61170:     ElfSection *getSectionAt(unsigned int offset);
61170: 
61185:     ElfSegment *getSegmentByType(unsigned int type);
61185: 
61170:     ElfDynamic_Section *getDynSection();
61170: 
61170:     void write(std::ofstream &file);
61170: 
61170:     char getClass();
61170:     char getData();
61170:     char getType();
61170:     char getMachine();
61170:     unsigned int getSize();
61170: private:
61170:     Elf_Ehdr *ehdr;
61170:     ElfLocation eh_entry;
61170:     ElfStrtab_Section *eh_shstrndx;
61170:     ElfSection **sections;
61170:     std::vector<ElfSegment *> segments;
61170:     ElfSection *shdr_section, *phdr_section;
61170:     /* Values used only during initialization */
61170:     Elf_Shdr **tmp_shdr;
61170:     std::ifstream *tmp_file;
61170: };
61170: 
61170: class ElfSection {
61170: public:
61170:     typedef union {
61170:         ElfSection *section;
61170:         int index;
61170:     } SectionInfo;
61170: 
61170:     ElfSection(Elf_Shdr &s, std::ifstream *file, Elf *parent);
61170: 
61170:     virtual ~ElfSection() {
61170:         delete[] data;
61170:     }
61170: 
61170:     const char *getName() { return name; }
61170:     unsigned int getType() { return shdr.sh_type; }
61170:     unsigned int getFlags() { return shdr.sh_flags; }
61170:     unsigned int getAddr();
61170:     unsigned int getSize() { return shdr.sh_size; }
61170:     unsigned int getAddrAlign() { return shdr.sh_addralign; }
61170:     unsigned int getEntSize() { return shdr.sh_entsize; }
61170:     const char *getData() { return data; }
61170:     ElfSection *getLink() { return link; }
61170:     SectionInfo getInfo() { return info; }
61170: 
61170:     void shrink(unsigned int newsize) {
61170:         if (newsize < shdr.sh_size) {
61170:             shdr.sh_size = newsize;
61170:             if (next)
61170:                 next->markDirty();
61170:         }
61170:     }
61170: 
61170:     unsigned int getOffset();
61170:     int getIndex();
61170:     Elf_Shdr &getShdr();
61170: 
61170:     ElfSection *getNext() { return next; }
61170:     ElfSection *getPrevious() { return previous; }
61170: 
61170:     virtual bool isRelocatable() {
61501:         return ((getType() == SHT_SYMTAB) ||
61501:                 (getType() == SHT_STRTAB) ||
61501:                 (getType() == SHT_RELA) ||
61501:                 (getType() == SHT_HASH) ||
61501:                 (getType() == SHT_NOTE) ||
61501:                 (getType() == SHT_REL) ||
61501:                 (getType() == SHT_DYNSYM) ||
61501:                 (getType() == SHT_GNU_HASH) ||
61501:                 (getType() == SHT_GNU_verdef) ||
61501:                 (getType() == SHT_GNU_verneed) ||
74783:                 (getType() == SHT_GNU_versym) ||
74783:                 isInSegmentType(PT_INTERP)) &&
61501:                 (getFlags() & SHF_ALLOC);
61170:     }
61170: 
61500:     void insertAfter(ElfSection *section, bool dirty = true) {
61170:         if (previous != NULL)
61170:             previous->next = next;
61170:         if (next != NULL)
61170:             next->previous = previous;
61170:         previous = section;
61170:         if (section != NULL) {
61170:             next = section->next;
61170:             section->next = this;
61170:         } else
61170:             next = NULL;
61170:         if (next != NULL)
61170:             next->previous = this;
61500:         if (dirty)
61170:             markDirty();
61170:     }
61170: 
96672:     void insertBefore(ElfSection *section, bool dirty = true) {
96672:         if (previous != NULL)
96672:             previous->next = next;
96672:         if (next != NULL)
96672:             next->previous = previous;
96672:         next = section;
96672:         if (section != NULL) {
96672:             previous = section->previous;
96672:             section->previous = this;
96672:         } else
96672:             previous = NULL;
96672:         if (previous != NULL)
96672:             previous->next = this;
96672:         if (dirty)
96672:             markDirty();
96672:     }
96672: 
61170:     void markDirty() {
61170:         if (link != NULL)
61170:             shdr.sh_link = -1;
61170:         if (info.index)
61170:             shdr.sh_info = -1;
61170:         shdr.sh_offset = -1;
61170:         if (isRelocatable())
61170:             shdr.sh_addr = -1;
61170:         if (next)
61170:             next->markDirty();
61170:     }
61170: 
61170:     virtual void serialize(std::ofstream &file, char ei_class, char ei_data)
61170:     {
61170:         if (getType() == SHT_NOBITS)
61170:             return;
61170:         file.seekp(getOffset());
61170:         file.write(data, getSize());
61170:     }
74783: 
74783: private:
74783:     friend class ElfSegment;
74783: 
74783:     void addToSegment(ElfSegment *segment) {
74783:         segments.push_back(segment);
74783:     }
74783: 
74783:     void removeFromSegment(ElfSegment *segment) {
74783:         std::vector<ElfSegment *>::iterator i = std::find(segments.begin(), segments.end(), segment);
74783:         segments.erase(i, i + 1);
74783:     }
74783: 
74783:     bool isInSegmentType(unsigned int type);
61170: protected:
61170:     Elf_Shdr shdr;
61170:     char *data;
61170:     const char *name;
61170: private:
61170:     ElfSection *link;
61170:     SectionInfo info;
61170:     ElfSection *next, *previous;
61170:     int index;
74783:     std::vector<ElfSegment *> segments;
61170: };
61170: 
61170: class ElfSegment {
61170: public:
61170:     ElfSegment(Elf_Phdr *phdr);
61170: 
61170:     unsigned int getType() { return type; }
61170:     unsigned int getFlags() { return flags; }
90548:     unsigned int getAlign() { return align; }
61170: 
61170:     ElfSection *getFirstSection() { return sections.empty() ? NULL : sections.front(); }
61170:     int getVPDiff() { return v_p_diff; }
61170:     unsigned int getFileSize();
61170:     unsigned int getMemSize();
62463:     unsigned int getOffset();
62463:     unsigned int getAddr();
61170: 
61170:     void addSection(ElfSection *section);
61170: 
61170:     std::list<ElfSection *>::iterator begin() { return sections.begin(); }
61170:     std::list<ElfSection *>::iterator end() { return sections.end(); }
61170: 
61170:     ElfSegment *splitBefore(ElfSection *section);
61170: private:
61170:     unsigned int type;
61170:     int v_p_diff; // Difference between physical and virtual address
61170:     unsigned int flags;
61170:     unsigned int align;
61170:     std::list<ElfSection *> sections;
62464:     // The following are only really used for PT_GNU_RELRO until something
62464:     // better is found.
62464:     unsigned int vaddr;
62464:     unsigned int filesz, memsz;
61170: };
61170: 
61170: class Elf_Ehdr: public serializable<Elf_Ehdr_Traits>, public ElfSection {
61170: public:
61170:     Elf_Ehdr(std::ifstream &file, char ei_class, char ei_data);
61170:     void serialize(std::ofstream &file, char ei_class, char ei_data)
61170:     {
61170:         serializable<Elf_Ehdr_Traits>::serialize(file, ei_class, ei_data);
61170:     }
61170: };
61170: 
61170: class Elf_Phdr: public serializable<Elf_Phdr_Traits> {
61170: public:
61170:     Elf_Phdr() {};
61170:     Elf_Phdr(std::ifstream &file, char ei_class, char ei_data)
61170:     : serializable<Elf_Phdr_Traits>(file, ei_class, ei_data) {};
61170:     bool contains(ElfSection *section)
61170:     {
61170:         unsigned int size = section->getSize();
61170:         unsigned int addr = section->getAddr();
61170:         // This may be biased, but should work in most cases
61170:         if ((section->getFlags() & SHF_ALLOC) == 0)
61170:             return false;
61496:         // Special case for PT_DYNAMIC. Eventually, this should
61496:         // be better handled than special cases
61496:         if ((p_type == PT_DYNAMIC) && (section->getType() != SHT_DYNAMIC))
61496:             return false;
71880:         // Special case for PT_TLS.
71880:         if ((p_type == PT_TLS) && !(section->getFlags() & SHF_TLS))
71880:             return false;
61170:         return (addr >= p_vaddr) &&
61170:                (addr + size <= p_vaddr + p_memsz);
61170: 
61170:     }
61170: };
61170: 
61170: typedef serializable<Elf_Dyn_Traits> Elf_Dyn;
61170: 
61170: struct Elf_DynValue {
61170:     unsigned int tag;
61170:     ElfValue *value;
61170: };
61170: 
61170: class ElfDynamic_Section: public ElfSection {
61170: public:
61170:     ElfDynamic_Section(Elf_Shdr &s, std::ifstream *file, Elf *parent);
61170:     ~ElfDynamic_Section();
61170: 
61170:     void serialize(std::ofstream &file, char ei_class, char ei_data);
61170: 
61499:     ElfValue *getValueForType(unsigned int tag);
61170:     ElfSection *getSectionForType(unsigned int tag);
61170:     void setValueForType(unsigned int tag, ElfValue *val);
61170: private:
61170:     std::vector<Elf_DynValue> dyns;
61170: };
61170: 
61170: typedef serializable<Elf_Sym_Traits> Elf_Sym;
61170: 
61509: struct Elf_SymValue {
61509:     const char *name;
61509:     unsigned char info;
61509:     unsigned char other;
61509:     ElfLocation value;
61509:     unsigned int size;
61509:     bool defined;
61509: };
61509: 
72590: #define STT(type) (1 << STT_ ##type)
72590: 
61170: class ElfSymtab_Section: public ElfSection {
61170: public:
61170:     ElfSymtab_Section(Elf_Shdr &s, std::ifstream *file, Elf *parent);
61170: 
61509:     void serialize(std::ofstream &file, char ei_class, char ei_data);
61509: 
72590:     Elf_SymValue *lookup(const char *name, unsigned int type_filter = STT(OBJECT) | STT(FUNC));
72590: 
61170: //private: // Until we have a real API
61509:     std::vector<Elf_SymValue> syms;
61170: };
61170: 
61170: class Elf_Rel: public serializable<Elf_Rel_Traits> {
61170: public:
61170:     Elf_Rel(std::ifstream &file, char ei_class, char ei_data)
61170:     : serializable<Elf_Rel_Traits>(file, ei_class, ei_data) {};
61170: 
61170:     static const unsigned int sh_type = SHT_REL;
61170:     static const unsigned int d_tag = DT_REL;
61170:     static const unsigned int d_tag_count = DT_RELCOUNT;
61170: };
61170: 
61170: class Elf_Rela: public serializable<Elf_Rela_Traits> {
61170: public:
61170:     Elf_Rela(std::ifstream &file, char ei_class, char ei_data)
61170:     : serializable<Elf_Rela_Traits>(file, ei_class, ei_data) {};
61170: 
61170:     static const unsigned int sh_type = SHT_RELA;
61170:     static const unsigned int d_tag = DT_RELA;
61170:     static const unsigned int d_tag_count = DT_RELACOUNT;
61170: };
61170: 
61170: template <class Rel>
61170: class ElfRel_Section: public ElfSection {
61170: public:
61170:     ElfRel_Section(Elf_Shdr &s, std::ifstream *file, Elf *parent)
61170:     : ElfSection(s, file, parent)
61170:     {
61170:         int pos = file->tellg();
61170:         file->seekg(shdr.sh_offset);
61170:         for (unsigned int i = 0; i < s.sh_size / s.sh_entsize; i++) {
61170:             Rel r(*file, parent->getClass(), parent->getData());
61170:             rels.push_back(r);
61170:         }
61170:         file->seekg(pos);
61170:     }
61170: 
61170:     void serialize(std::ofstream &file, char ei_class, char ei_data)
61170:     {
61170:         for (typename std::vector<Rel>::iterator i = rels.begin();
61170:              i != rels.end(); ++i)
61170:             (*i).serialize(file, ei_class, ei_data);
61170:     }
61170: //private: // Until we have a real API
61170:     std::vector<Rel> rels;
61170: };
61170: 
61170: class ElfStrtab_Section: public ElfSection {
61170: public:
61170:     ElfStrtab_Section(Elf_Shdr &s, std::ifstream *file, Elf *parent)
61170:     : ElfSection(s, file, parent)
61170:     {
61170:         table.push_back(table_storage(data, shdr.sh_size));
61170:     }
61170: 
61170:     ~ElfStrtab_Section()
61170:     {
61170:         for (std::vector<table_storage>::iterator t = table.begin() + 1;
61170:              t != table.end(); t++)
61170:             delete[] t->buf;
61170:     }
61170: 
61170:     const char *getStr(unsigned int index);
61170: 
61170:     const char *getStr(const char *string);
61170: 
61170:     unsigned int getStrIndex(const char *string);
61170: 
61170:     void serialize(std::ofstream &file, char ei_class, char ei_data);
61170: private:
61170:     struct table_storage {
61170:         unsigned int size, used;
61170:         char *buf;
61170: 
61170:         table_storage(): size(4096), used(0), buf(new char[4096]) {}
61170:         table_storage(const char *data, unsigned int sz)
61170:         : size(sz), used(sz), buf(const_cast<char *>(data)) {}
61170:     };
61170:     std::vector<table_storage> table;
61170: };
61170: 
61170: inline char Elf::getClass() {
61170:     return ehdr->e_ident[EI_CLASS];
61170: }
61170: 
61170: inline char Elf::getData() {
61170:     return ehdr->e_ident[EI_DATA];
61170: }
61170: 
61170: inline char Elf::getType() {
61170:     return ehdr->e_type;
61170: }
61170: 
61170: inline char Elf::getMachine() {
61170:     return ehdr->e_machine;
61170: }
61170: 
61170: inline unsigned int Elf::getSize() {
61170:     ElfSection *section;
61170:     for (section = shdr_section /* It's usually not far from the end */;
61170:         section->getNext() != NULL; section = section->getNext());
61170:     return section->getOffset() + section->getSize();
61170: }
61170: 
74783: inline bool ElfSection::isInSegmentType(unsigned int type) {
74783:     for (std::vector<ElfSegment *>::iterator seg = segments.begin(); seg != segments.end(); seg++)
74783:         if ((*seg)->getType() == type)
74783:             return true;
74783:     return false;
74783: }
74783: 
61509: inline ElfLocation::ElfLocation(ElfSection *section, unsigned int off, enum position pos)
61509: : section(section) {
61509:     if ((pos == ABSOLUTE) && section)
61509:         offset = off - section->getAddr();
61509:     else
61509:         offset = off;
61509: }
61509: 
61170: inline ElfLocation::ElfLocation(unsigned int location, Elf *elf) {
61170:     section = elf->getSectionAt(location);
61495:     offset = location - (section ? section->getAddr() : 0);
61170: }
61170: 
61170: inline unsigned int ElfLocation::getValue() {
61495:     return (section ? section->getAddr() : 0) + offset;
61170: }
61170: 
61170: inline unsigned int ElfSize::getValue() {
61170:     return section->getSize();
61170: }
61170: 
61170: inline unsigned int ElfEntSize::getValue() {
61170:     return section->getEntSize();
61170: }
