 43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 43113: /* vim:set tw=80 ts=4 sts=4 sw=4 et cin: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43113: 
 43113: #include <limits.h>
 43113: #include <ctype.h>
 43113: 
 43113: #include "prprf.h"
 43113: #include "prlog.h"
 43113: #include "prtime.h"
 43113: 
 43113: #include "nsIOService.h"
 43113: #include "nsFTPChannel.h"
 43113: #include "nsFtpConnectionThread.h"
 43113: #include "nsFtpControlConnection.h"
 43113: #include "nsFtpProtocolHandler.h"
 43113: #include "ftpCore.h"
 43113: #include "netCore.h"
 43113: #include "nsCRT.h"
 43113: #include "nsEscape.h"
 43113: #include "nsMimeTypes.h"
 43113: #include "nsNetUtil.h"
 43113: #include "nsThreadUtils.h"
 43113: #include "nsStreamUtils.h"
 43113: #include "nsICacheService.h"
 43113: #include "nsIURL.h"
 43113: #include "nsISocketTransport.h"
 43113: #include "nsIStreamListenerTee.h"
 43113: #include "nsIPrefService.h"
 43113: #include "nsIPrefBranch.h"
 43113: #include "nsIStringBundle.h"
 43113: #include "nsAuthInformationHolder.h"
 43113: #include "nsICharsetConverterManager.h"
115189: #include "nsIProtocolProxyService.h"
115189: #include "nsICancelable.h"
 43113: 
 43113: #if defined(PR_LOGGING)
 43113: extern PRLogModuleInfo* gFTPLog;
 43113: #endif
 43113: #define LOG(args)         PR_LOG(gFTPLog, PR_LOG_DEBUG, args)
 43113: #define LOG_ALWAYS(args)  PR_LOG(gFTPLog, PR_LOG_ALWAYS, args)
 43113: 
 78645: // remove FTP parameters (starting with ";") from the path
 78645: static void
 78645: removeParamsFromPath(nsCString& path)
 78645: {
108991:   int32_t index = path.FindChar(';');
 78645:   if (index >= 0) {
 78645:     path.SetLength(index);
 78645:   }
 78645: }
 78645: 
115189: NS_IMPL_ISUPPORTS_INHERITED5(nsFtpState,
 43113:                              nsBaseContentStream,
 43113:                              nsIInputStreamCallback, 
 43113:                              nsITransportEventSink,
 43113:                              nsICacheListener,
115189:                              nsIRequestObserver,
115189:                              nsIProtocolProxyCallback)
 43113: 
 43113: nsFtpState::nsFtpState()
 80486:     : nsBaseContentStream(true)
 43113:     , mState(FTP_INIT)
 43113:     , mNextState(FTP_S_USER)
 80486:     , mKeepRunning(true)
 80486:     , mReceivedControlData(false)
 80486:     , mTryingCachedControl(false)
 80486:     , mRETRFailed(false)
115421:     , mFileSize(UINT64_MAX)
 43113:     , mServerType(FTP_GENERIC_TYPE)
 43113:     , mAction(GET)
 80486:     , mAnonymous(true)
 80486:     , mRetryPass(false)
 80486:     , mStorReplyReceived(false)
 43113:     , mInternalError(NS_OK)
 80486:     , mReconnectAndLoginAgain(false)
 82649:     , mCacheConnection(true)
 43113:     , mPort(21)
 80486:     , mAddressChecked(false)
 80486:     , mServerIsIPv6(false)
 43113:     , mControlStatus(NS_OK)
115189:     , mDeferredCallbackPending(false)
 43113: {
 43113:     LOG_ALWAYS(("FTP:(%x) nsFtpState created", this));
 43113: 
 43113:     // make sure handler stays around
 43113:     NS_ADDREF(gFtpHandler);
 43113: }
 43113: 
 43113: nsFtpState::~nsFtpState() 
 43113: {
 43113:     LOG_ALWAYS(("FTP:(%x) nsFtpState destroyed", this));
 43113: 
115189:     if (mProxyRequest)
115189:         mProxyRequest->Cancel(NS_ERROR_FAILURE);
115189: 
 43113:     // release reference to handler
 43113:     nsFtpProtocolHandler *handler = gFtpHandler;
 43113:     NS_RELEASE(handler);
 43113: }
 43113: 
 43113: // nsIInputStreamCallback implementation
 43113: NS_IMETHODIMP
 43113: nsFtpState::OnInputStreamReady(nsIAsyncInputStream *aInStream)
 43113: {
 43113:     LOG(("FTP:(%p) data stream ready\n", this));
 43113: 
 43113:     // We are receiving a notification from our data stream, so just forward it
 43113:     // on to our stream callback.
 43113:     if (HasPendingCallback())
 43113:         DispatchCallbackSync();
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: void
108991: nsFtpState::OnControlDataAvailable(const char *aData, uint32_t aDataLen)
 43113: {
 43113:     LOG(("FTP:(%p) control data available [%u]\n", this, aDataLen));
 43113:     mControlConnection->WaitData(this);  // queue up another call
 43113: 
 43113:     if (!mReceivedControlData) {
 43113:         // parameter can be null cause the channel fills them in.
106838:         OnTransportStatus(nullptr, NS_NET_STATUS_BEGIN_FTP_TRANSACTION, 0, 0);
 80486:         mReceivedControlData = true;
 43113:     }
 43113: 
 43113:     // Sometimes we can get two responses in the same packet, eg from LIST.
 43113:     // So we need to parse the response line by line
 43113: 
 43113:     nsCString buffer = mControlReadCarryOverBuf;
 43113: 
 43113:     // Clear the carryover buf - if we still don't have a line, then it will
 43113:     // be reappended below
 43113:     mControlReadCarryOverBuf.Truncate();
 43113: 
 43113:     buffer.Append(aData, aDataLen);
 43113: 
 43113:     const char* currLine = buffer.get();
 43113:     while (*currLine && mKeepRunning) {
108991:         int32_t eolLength = strcspn(currLine, CRLF);
108991:         int32_t currLineLength = strlen(currLine);
 43113: 
 43113:         // if currLine is empty or only contains CR or LF, then bail.  we can
 43113:         // sometimes get an ODA event with the full response line + CR without
 43113:         // the trailing LF.  the trailing LF might come in the next ODA event.
 43113:         // because we are happy enough to process a response line ending only
 43113:         // in CR, we need to take care to discard the extra LF (bug 191220).
 43113:         if (eolLength == 0 && currLineLength <= 1)
 43113:             break;
 43113: 
 43113:         if (eolLength == currLineLength) {
 43113:             mControlReadCarryOverBuf.Assign(currLine);
 43113:             break;
 43113:         }
 43113: 
 43113:         // Append the current segment, including the LF
110974:         nsAutoCString line;
108991:         int32_t crlfLength = 0;
 43113: 
 43113:         if ((currLineLength > eolLength) &&
 43113:             (currLine[eolLength] == nsCRT::CR) &&
 43113:             (currLine[eolLength+1] == nsCRT::LF)) {
 43113:             crlfLength = 2; // CR +LF 
 43113:         } else {
 43113:             crlfLength = 1; // + LF or CR
 43113:         }
 43113: 
 43113:         line.Assign(currLine, eolLength + crlfLength);
 43113:         
 43113:         // Does this start with a response code?
 79445:         bool startNum = (line.Length() >= 3 &&
 43113:                            isdigit(line[0]) &&
 43113:                            isdigit(line[1]) &&
 43113:                            isdigit(line[2]));
 43113: 
 43113:         if (mResponseMsg.IsEmpty()) {
 43113:             // If we get here, then we know that we have a complete line, and
 43113:             // that it is the first one
 43113: 
 43113:             NS_ASSERTION(line.Length() > 4 && startNum,
 43113:                          "Read buffer doesn't include response code");
 43113:             
 43113:             mResponseCode = atoi(PromiseFlatCString(Substring(line,0,3)).get());
 43113:         }
 43113: 
 43113:         mResponseMsg.Append(line);
 43113: 
 43113:         // This is the last line if its 3 numbers followed by a space
 43113:         if (startNum && line[3] == ' ') {
 43113:             // yup. last line, let's move on.
 43113:             if (mState == mNextState) {
 43113:                 NS_ERROR("ftp read state mixup");
 43113:                 mInternalError = NS_ERROR_FAILURE;
 43113:                 mState = FTP_ERROR;
 43113:             } else {
 43113:                 mState = mNextState;
 43113:             }
 43113: 
 43113:             nsCOMPtr<nsIFTPEventSink> ftpSink;
 43113:             mChannel->GetFTPEventSink(ftpSink);
 43113:             if (ftpSink)
 80486:                 ftpSink->OnFTPControlLog(true, mResponseMsg.get());
 43113:             
 43113:             nsresult rv = Process();
 43113:             mResponseMsg.Truncate();
 43113:             if (NS_FAILED(rv)) {
 43113:                 CloseWithStatus(rv);
 43113:                 return;
 43113:             }
 43113:         }
 43113: 
 43113:         currLine = currLine + eolLength + crlfLength;
 43113:     }
 43113: }
 43113: 
 43113: void
 43113: nsFtpState::OnControlError(nsresult status)
 43113: {
 43113:     NS_ASSERTION(NS_FAILED(status), "expecting error condition");
 43113: 
 43113:     LOG(("FTP:(%p) CC(%p) error [%x was-cached=%u]\n",
 43113:          this, mControlConnection.get(), status, mTryingCachedControl));
 43113: 
 43113:     mControlStatus = status;
 43113:     if (mReconnectAndLoginAgain && NS_SUCCEEDED(mInternalError)) {
 80486:         mReconnectAndLoginAgain = false;
 80486:         mAnonymous = false;
 43113:         mControlStatus = NS_OK;
 43113:         Connect();
 43113:     } else if (mTryingCachedControl && NS_SUCCEEDED(mInternalError)) {
 80486:         mTryingCachedControl = false;
 43113:         Connect();
 43113:     } else {
 43113:         CloseWithStatus(status);
 43113:     }
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::EstablishControlConnection()
 43113: {
 43113:     NS_ASSERTION(!mControlConnection, "we already have a control connection");
 43113:             
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("FTP:(%x) trying cached control\n", this));
 43113:         
 43113:     // Look to see if we can use a cached control connection:
106838:     nsFtpControlConnection *connection = nullptr;
 43113:     // Don't use cached control if anonymous (bug #473371)
 43113:     if (!mChannel->HasLoadFlag(nsIRequest::LOAD_ANONYMOUS))
 43113:         gFtpHandler->RemoveConnection(mChannel->URI(), &connection);
 43113: 
 43113:     if (connection) {
 43113:         mControlConnection.swap(connection);
 43113:         if (mControlConnection->IsAlive())
 43113:         {
 43113:             // set stream listener of the control connection to be us.        
 43113:             mControlConnection->WaitData(this);
 43113:             
 43113:             // read cached variables into us. 
 43113:             mServerType = mControlConnection->mServerType;           
 43113:             mPassword   = mControlConnection->mPassword;
 43113:             mPwd        = mControlConnection->mPwd;
 80486:             mTryingCachedControl = true;
 43113:             
 43113:             // we're already connected to this server, skip login.
 43113:             mState = FTP_S_PASV;
 43113:             mResponseCode = 530;  // assume the control connection was dropped.
 43113:             mControlStatus = NS_OK;
 80486:             mReceivedControlData = false;  // For this request, we have not.
 43113: 
 43113:             // if we succeed, return.  Otherwise, we need to create a transport
 43113:             rv = mControlConnection->Connect(mChannel->ProxyInfo(), this);
 43113:             if (NS_SUCCEEDED(rv))
 43113:                 return rv;
 43113:         }
 43113:         LOG(("FTP:(%p) cached CC(%p) is unusable\n", this,
 43113:             mControlConnection.get()));
 43113: 
106838:         mControlConnection->WaitData(nullptr);
106838:         mControlConnection = nullptr;
 43113:     }
 43113: 
 43113:     LOG(("FTP:(%p) creating CC\n", this));
 43113:         
 43113:     mState = FTP_READ_BUF;
 43113:     mNextState = FTP_S_USER;
 43113:     
110974:     nsAutoCString host;
 43113:     rv = mChannel->URI()->GetAsciiHost(host);
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 43113:     mControlConnection = new nsFtpControlConnection(host, mPort);
 43113:     if (!mControlConnection)
 43113:         return NS_ERROR_OUT_OF_MEMORY;
 43113: 
 43113:     rv = mControlConnection->Connect(mChannel->ProxyInfo(), this);
 43113:     if (NS_FAILED(rv)) {
 43113:         LOG(("FTP:(%p) CC(%p) failed to connect [rv=%x]\n", this,
 43113:             mControlConnection.get(), rv));
106838:         mControlConnection = nullptr;
 43113:         return rv;
 43113:     }
 43113: 
 43113:     return mControlConnection->WaitData(this);
 43113: }
 43113: 
 43113: void 
 43113: nsFtpState::MoveToNextState(FTP_STATE nextState)
 43113: {
 43113:     if (NS_FAILED(mInternalError)) {
 43113:         mState = FTP_ERROR;
 43113:         LOG(("FTP:(%x) FAILED (%x)\n", this, mInternalError));
 43113:     } else {
 43113:         mState = FTP_READ_BUF;
 43113:         mNextState = nextState;
 43113:     }  
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::Process() 
 43113: {
 43113:     nsresult    rv = NS_OK;
 79445:     bool        processingRead = true;
 43113:     
 43113:     while (mKeepRunning && processingRead) {
 43113:         switch (mState) {
 43113:           case FTP_COMMAND_CONNECT:
 43113:             KillControlConnection();
 43113:             LOG(("FTP:(%p) establishing CC", this));
 43113:             mInternalError = EstablishControlConnection();  // sets mState
 43113:             if (NS_FAILED(mInternalError)) {
 43113:                 mState = FTP_ERROR;
 43113:                 LOG(("FTP:(%p) FAILED\n", this));
 43113:             } else {
 43113:                 LOG(("FTP:(%p) SUCCEEDED\n", this));
 43113:             }
 43113:             break;
 43113:     
 43113:           case FTP_READ_BUF:
 43113:             LOG(("FTP:(%p) Waiting for CC(%p)\n", this,
 43113:                 mControlConnection.get()));
 80486:             processingRead = false;
 43113:             break;
 43113:           
 43113:           case FTP_ERROR: // xx needs more work to handle dropped control connection cases
 43113:             if ((mTryingCachedControl && mResponseCode == 530 &&
 43113:                 mInternalError == NS_ERROR_FTP_PASV) ||
 43113:                 (mResponseCode == 425 &&
 43113:                 mInternalError == NS_ERROR_FTP_PASV)) {
 43113:                 // The user was logged out during an pasv operation
 43113:                 // we want to restart this request with a new control
 43113:                 // channel.
 43113:                 mState = FTP_COMMAND_CONNECT;
 43113:             } else if (mResponseCode == 421 && 
 43113:                        mInternalError != NS_ERROR_FTP_LOGIN) {
 43113:                 // The command channel dropped for some reason.
 43113:                 // Fire it back up, unless we were trying to login
 43113:                 // in which case the server might just be telling us
 43113:                 // that the max number of users has been reached...
 43113:                 mState = FTP_COMMAND_CONNECT;
 43113:             } else if (mAnonymous && 
 43113:                        mInternalError == NS_ERROR_FTP_LOGIN) {
 43113:                 // If the login was anonymous, and it failed, try again with a username
 43113:                 // Don't reuse old control connection, see #386167
 80486:                 mAnonymous = false;
 43113:                 mState = FTP_COMMAND_CONNECT;
 43113:             } else {
 43113:                 LOG(("FTP:(%x) FTP_ERROR - calling StopProcessing\n", this));
 43113:                 rv = StopProcessing();
 43113:                 NS_ASSERTION(NS_SUCCEEDED(rv), "StopProcessing failed.");
 80486:                 processingRead = false;
 43113:             }
 43113:             break;
 43113:           
 43113:           case FTP_COMPLETE:
 43113:             LOG(("FTP:(%x) COMPLETE\n", this));
 43113:             rv = StopProcessing();
 43113:             NS_ASSERTION(NS_SUCCEEDED(rv), "StopProcessing failed.");
 80486:             processingRead = false;
 43113:             break;
 43113: 
 43113: // USER           
 43113:           case FTP_S_USER:
 43113:             rv = S_user();
 43113:             
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = NS_ERROR_FTP_LOGIN;
 43113:             
 43113:             MoveToNextState(FTP_R_USER);
 43113:             break;
 43113:             
 43113:           case FTP_R_USER:
 43113:             mState = R_user();
 43113:             
 43113:             if (FTP_ERROR == mState)
 43113:                 mInternalError = NS_ERROR_FTP_LOGIN;
 43113:             
 43113:             break;
 43113: // PASS            
 43113:           case FTP_S_PASS:
 43113:             rv = S_pass();
 43113:             
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = NS_ERROR_FTP_LOGIN;
 43113:             
 43113:             MoveToNextState(FTP_R_PASS);
 43113:             break;
 43113:             
 43113:           case FTP_R_PASS:
 43113:             mState = R_pass();
 43113:             
 43113:             if (FTP_ERROR == mState)
 43113:                 mInternalError = NS_ERROR_FTP_LOGIN;
 43113:             
 43113:             break;
 43113: // ACCT            
 43113:           case FTP_S_ACCT:
 43113:             rv = S_acct();
 43113:             
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = NS_ERROR_FTP_LOGIN;
 43113:             
 43113:             MoveToNextState(FTP_R_ACCT);
 43113:             break;
 43113:             
 43113:           case FTP_R_ACCT:
 43113:             mState = R_acct();
 43113:             
 43113:             if (FTP_ERROR == mState)
 43113:                 mInternalError = NS_ERROR_FTP_LOGIN;
 43113:             
 43113:             break;
 43113: 
 43113: // SYST            
 43113:           case FTP_S_SYST:
 43113:             rv = S_syst();
 43113:             
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = NS_ERROR_FTP_LOGIN;
 43113:             
 43113:             MoveToNextState(FTP_R_SYST);
 43113:             break;
 43113:             
 43113:           case FTP_R_SYST:
 43113:             mState = R_syst();
 43113:             
 43113:             if (FTP_ERROR == mState)
 43113:                 mInternalError = NS_ERROR_FTP_LOGIN;
 43113: 
 43113:             break;
 43113: 
 43113: // TYPE            
 43113:           case FTP_S_TYPE:
 43113:             rv = S_type();
 43113:             
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = rv;
 43113:             
 43113:             MoveToNextState(FTP_R_TYPE);
 43113:             break;
 43113:             
 43113:           case FTP_R_TYPE:
 43113:             mState = R_type();
 43113:             
 43113:             if (FTP_ERROR == mState)
 43113:                 mInternalError = NS_ERROR_FAILURE;
 43113:             
 43113:             break;
 43113: // CWD            
 43113:           case FTP_S_CWD:
 43113:             rv = S_cwd();
 43113:             
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = NS_ERROR_FTP_CWD;
 43113:             
 43113:             MoveToNextState(FTP_R_CWD);
 43113:             break;
 43113:             
 43113:           case FTP_R_CWD:
 43113:             mState = R_cwd();
 43113:             
 43113:             if (FTP_ERROR == mState)
 43113:                 mInternalError = NS_ERROR_FTP_CWD;
 43113:             break;
 43113:        
 43113: // LIST
 43113:           case FTP_S_LIST:
 43113:             rv = S_list();
 43113: 
 43113:             if (rv == NS_ERROR_NOT_RESUMABLE) {
 43113:                 mInternalError = rv;
 43113:             } else if (NS_FAILED(rv)) {
 43113:                 mInternalError = NS_ERROR_FTP_CWD;
 43113:             }
 43113:             
 43113:             MoveToNextState(FTP_R_LIST);
 43113:             break;
 43113: 
 43113:           case FTP_R_LIST:        
 43113:             mState = R_list();
 43113:             
 43113:             if (FTP_ERROR == mState)
 43113:                 mInternalError = NS_ERROR_FAILURE;
 43113: 
 43113:             break;
 43113: 
 43113: // SIZE            
 43113:           case FTP_S_SIZE:
 43113:             rv = S_size();
 43113:             
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = rv;
 43113:             
 43113:             MoveToNextState(FTP_R_SIZE);
 43113:             break;
 43113:             
 43113:           case FTP_R_SIZE: 
 43113:             mState = R_size();
 43113:             
 43113:             if (FTP_ERROR == mState)
 43113:                 mInternalError = NS_ERROR_FAILURE;
 43113:             
 43113:             break;
 43113: 
 43113: // REST        
 43113:           case FTP_S_REST:
 43113:             rv = S_rest();
 43113:             
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = rv;
 43113:             
 43113:             MoveToNextState(FTP_R_REST);
 43113:             break;
 43113:             
 43113:           case FTP_R_REST:
 43113:             mState = R_rest();
 43113:             
 43113:             if (FTP_ERROR == mState)
 43113:                 mInternalError = NS_ERROR_FAILURE;
 43113:             
 43113:             break;
 43113: 
 43113: // MDTM
 43113:           case FTP_S_MDTM:
 43113:             rv = S_mdtm();
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = rv;
 43113:             MoveToNextState(FTP_R_MDTM);
 43113:             break;
 43113: 
 43113:           case FTP_R_MDTM:
 43113:             mState = R_mdtm();
 43113: 
 43113:             // Don't want to overwrite a more explicit status code
 43113:             if (FTP_ERROR == mState && NS_SUCCEEDED(mInternalError))
 43113:                 mInternalError = NS_ERROR_FAILURE;
 43113:             
 43113:             break;
 43113:             
 43113: // RETR        
 43113:           case FTP_S_RETR:
 43113:             rv = S_retr();
 43113:             
 43113:             if (NS_FAILED(rv)) 
 43113:                 mInternalError = rv;
 43113:             
 43113:             MoveToNextState(FTP_R_RETR);
 43113:             break;
 43113:             
 43113:           case FTP_R_RETR:
 43113: 
 43113:             mState = R_retr();
 43113:             
 43113:             if (FTP_ERROR == mState)
 43113:                 mInternalError = NS_ERROR_FAILURE;
 43113:             
 43113:             break;
 43113:             
 43113: // STOR        
 43113:           case FTP_S_STOR:
 43113:             rv = S_stor();
 43113: 
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = rv;
 43113:             
 43113:             MoveToNextState(FTP_R_STOR);
 43113:             break;
 43113:             
 43113:           case FTP_R_STOR:
 43113:             mState = R_stor();
 43113: 
 43113:             if (FTP_ERROR == mState)
 43113:                 mInternalError = NS_ERROR_FAILURE;
 43113: 
 43113:             break;
 43113:             
 43113: // PASV        
 43113:           case FTP_S_PASV:
 43113:             rv = S_pasv();
 43113: 
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = NS_ERROR_FTP_PASV;
 43113:             
 43113:             MoveToNextState(FTP_R_PASV);
 43113:             break;
 43113:             
 43113:           case FTP_R_PASV:
 43113:             mState = R_pasv();
 43113: 
 43113:             if (FTP_ERROR == mState) 
 43113:                 mInternalError = NS_ERROR_FTP_PASV;
 43113: 
 43113:             break;
 43113:             
 43113: // PWD        
 43113:           case FTP_S_PWD:
 43113:             rv = S_pwd();
 43113: 
 43113:             if (NS_FAILED(rv))
 43113:                 mInternalError = NS_ERROR_FTP_PWD;
 43113:             
 43113:             MoveToNextState(FTP_R_PWD);
 43113:             break;
 43113:             
 43113:           case FTP_R_PWD:
 43113:             mState = R_pwd();
 43113: 
 43113:             if (FTP_ERROR == mState) 
 43113:                 mInternalError = NS_ERROR_FTP_PWD;
 43113: 
 43113:             break;
 43113:             
 43113:           default:
 43113:             ;
 43113:             
 43113:         }
 43113:     }
 43113: 
 43113:     return rv;
 43113: }
 43113: 
 43113: ///////////////////////////////////
 43113: // STATE METHODS
 43113: ///////////////////////////////////
 43113: nsresult
 43113: nsFtpState::S_user() {
 43113:     // some servers on connect send us a 421 or 521.  (84525) (141784)
 43113:     if ((mResponseCode == 421) || (mResponseCode == 521))
 43113:         return NS_ERROR_FAILURE;
 43113: 
 43113:     nsresult rv;
110974:     nsAutoCString usernameStr("USER ");
 43113: 
 43113:     mResponseMsg = "";
 43113: 
 43113:     if (mAnonymous) {
 80486:         mReconnectAndLoginAgain = true;
 43113:         usernameStr.AppendLiteral("anonymous");
 43113:     } else {
 80486:         mReconnectAndLoginAgain = false;
 43113:         if (mUsername.IsEmpty()) {
 43113: 
 43113:             // No prompt for anonymous requests (bug #473371)
 43113:             if (mChannel->HasLoadFlag(nsIRequest::LOAD_ANONYMOUS))
 43113:               return NS_ERROR_FAILURE;
 43113: 
 43113:             nsCOMPtr<nsIAuthPrompt2> prompter;
 43113:             NS_QueryAuthPrompt2(static_cast<nsIChannel*>(mChannel),
 43113:                                 getter_AddRefs(prompter));
 43113:             if (!prompter)
 43113:                 return NS_ERROR_NOT_INITIALIZED;
 43113: 
 43113:             nsRefPtr<nsAuthInformationHolder> info =
 43113:                 new nsAuthInformationHolder(nsIAuthInformation::AUTH_HOST,
 43113:                                             EmptyString(),
 43113:                                             EmptyCString());
 43113: 
 79445:             bool retval;
 43113:             rv = prompter->PromptAuth(mChannel, nsIAuthPrompt2::LEVEL_NONE,
 43113:                                       info, &retval);
 43113: 
 43113:             // if the user canceled or didn't supply a username we want to fail
 43113:             if (NS_FAILED(rv) || !retval || info->User().IsEmpty())
 43113:                 return NS_ERROR_FAILURE;
 43113: 
 43113:             mUsername = info->User();
 43113:             mPassword = info->Password();
 43113:         }
 43113:         // XXX Is UTF-8 the best choice?
 43113:         AppendUTF16toUTF8(mUsername, usernameStr);
 43113:     }
 43113:     usernameStr.Append(CRLF);
 43113: 
 43113:     return SendFTPCommand(usernameStr);
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_user() {
 80486:     mReconnectAndLoginAgain = false;
 43113:     if (mResponseCode/100 == 3) {
 43113:         // send off the password
 43113:         return FTP_S_PASS;
 43113:     }
 43113:     if (mResponseCode/100 == 2) {
 43113:         // no password required, we're already logged in
 43113:         return FTP_S_SYST;
 43113:     }
 43113:     if (mResponseCode/100 == 5) {
 43113:         // problem logging in. typically this means the server
 43113:         // has reached it's user limit.
 43113:         return FTP_ERROR;
 43113:     }
 43113:     // LOGIN FAILED
 43113:     return FTP_ERROR;
 43113: }
 43113: 
 43113: 
 43113: nsresult
 43113: nsFtpState::S_pass() {
 43113:     nsresult rv;
110974:     nsAutoCString passwordStr("PASS ");
 43113: 
 43113:     mResponseMsg = "";
 43113: 
 43113:     if (mAnonymous) {
 43113:         if (!mPassword.IsEmpty()) {
 43113:             // XXX Is UTF-8 the best choice?
 43113:             AppendUTF16toUTF8(mPassword, passwordStr);
 43113:         } else {
 43113:             nsXPIDLCString anonPassword;
 79445:             bool useRealEmail = false;
 43113:             nsCOMPtr<nsIPrefBranch> prefs =
 43113:                     do_GetService(NS_PREFSERVICE_CONTRACTID);
 43113:             if (prefs) {
 43113:                 rv = prefs->GetBoolPref("advanced.mailftp", &useRealEmail);
 43113:                 if (NS_SUCCEEDED(rv) && useRealEmail) {
 43113:                     prefs->GetCharPref("network.ftp.anonymous_password",
 43113:                                        getter_Copies(anonPassword));
 43113:                 }
 43113:             }
 43113:             if (!anonPassword.IsEmpty()) {
 43113:                 passwordStr.AppendASCII(anonPassword);
 43113:             } else {
 43113:                 // We need to default to a valid email address - bug 101027
 43113:                 // example.com is reserved (rfc2606), so use that
 43113:                 passwordStr.AppendLiteral("mozilla@example.com");
 43113:             }
 43113:         }
 43113:     } else {
 43113:         if (mPassword.IsEmpty() || mRetryPass) {
 43113:             
 43113:             // No prompt for anonymous requests (bug #473371)
 43113:             if (mChannel->HasLoadFlag(nsIRequest::LOAD_ANONYMOUS))
 43113:                 return NS_ERROR_FAILURE;
 43113: 
 43113:             nsCOMPtr<nsIAuthPrompt2> prompter;
 43113:             NS_QueryAuthPrompt2(static_cast<nsIChannel*>(mChannel),
 43113:                                 getter_AddRefs(prompter));
 43113:             if (!prompter)
 43113:                 return NS_ERROR_NOT_INITIALIZED;
 43113: 
 43113:             nsRefPtr<nsAuthInformationHolder> info =
 43113:                 new nsAuthInformationHolder(nsIAuthInformation::AUTH_HOST |
 43113:                                             nsIAuthInformation::ONLY_PASSWORD,
 43113:                                             EmptyString(),
 43113:                                             EmptyCString());
 43113: 
 43113:             info->SetUserInternal(mUsername);
 43113: 
 79445:             bool retval;
 43113:             rv = prompter->PromptAuth(mChannel, nsIAuthPrompt2::LEVEL_NONE,
 43113:                                       info, &retval);
 43113: 
 43113:             // we want to fail if the user canceled. Note here that if they want
 43113:             // a blank password, we will pass it along.
 43113:             if (NS_FAILED(rv) || !retval)
 43113:                 return NS_ERROR_FAILURE;
 43113: 
 43113:             mPassword = info->Password();
 43113:         }
 43113:         // XXX Is UTF-8 the best choice?
 43113:         AppendUTF16toUTF8(mPassword, passwordStr);
 43113:     }
 43113:     passwordStr.Append(CRLF);
 43113: 
 43113:     return SendFTPCommand(passwordStr);
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_pass() {
 43113:     if (mResponseCode/100 == 3) {
 43113:         // send account info
 43113:         return FTP_S_ACCT;
 43113:     }
 43113:     if (mResponseCode/100 == 2) {
 43113:         // logged in
 43113:         return FTP_S_SYST;
 43113:     }
 43113:     if (mResponseCode == 503) {
 43113:         // start over w/ the user command.
 43113:         // note: the password was successful, and it's stored in mPassword
 80486:         mRetryPass = false;
 43113:         return FTP_S_USER;
 43113:     }
 43113:     if (mResponseCode/100 == 5 || mResponseCode==421) {
 43113:         // There is no difference between a too-many-users error,
 43113:         // a wrong-password error, or any other sort of error
 43113: 
 43113:         if (!mAnonymous)
 80486:             mRetryPass = true;
 43113: 
 43113:         return FTP_ERROR;
 43113:     }
 43113:     // unexpected response code
 43113:     return FTP_ERROR;
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::S_pwd() {
 43113:     return SendFTPCommand(NS_LITERAL_CSTRING("PWD" CRLF));
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_pwd() {
 82649:     // Error response to PWD command isn't fatal, but don't cache the connection
 82649:     // if CWD command is sent since correct mPwd is needed for further requests.
 43113:     if (mResponseCode/100 != 2)
 82649:         return FTP_S_TYPE;
 82649: 
110974:     nsAutoCString respStr(mResponseMsg);
108991:     int32_t pos = respStr.FindChar('"');
 43113:     if (pos > -1) {
 43113:         respStr.Cut(0, pos+1);
 43113:         pos = respStr.FindChar('"');
 43113:         if (pos > -1) {
 43113:             respStr.Truncate(pos);
 43113:             if (mServerType == FTP_VMS_TYPE)
 43113:                 ConvertDirspecFromVMS(respStr);
 43113:             if (respStr.Last() != '/')
 43113:                 respStr.Append('/');
 43113:             mPwd = respStr;
 43113:         }
 43113:     }
 43113:     return FTP_S_TYPE;
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::S_syst() {
 43113:     return SendFTPCommand(NS_LITERAL_CSTRING("SYST" CRLF));
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_syst() {
 43113:     if (mResponseCode/100 == 2) {
 43113:         if (( mResponseMsg.Find("L8") > -1) || 
 43113:             ( mResponseMsg.Find("UNIX") > -1) || 
 43113:             ( mResponseMsg.Find("BSD") > -1) ||
 43113:             ( mResponseMsg.Find("MACOS Peter's Server") > -1) ||
 43113:             ( mResponseMsg.Find("MACOS WebSTAR FTP") > -1) ||
 43113:             ( mResponseMsg.Find("MVS") > -1) ||
 43113:             ( mResponseMsg.Find("OS/390") > -1) ||
 43113:             ( mResponseMsg.Find("OS/400") > -1)) {
 43113:             mServerType = FTP_UNIX_TYPE;
 80486:         } else if (( mResponseMsg.Find("WIN32", true) > -1) ||
 80486:                    ( mResponseMsg.Find("windows", true) > -1)) {
 43113:             mServerType = FTP_NT_TYPE;
 80486:         } else if (mResponseMsg.Find("OS/2", true) > -1) {
 43113:             mServerType = FTP_OS2_TYPE;
 80486:         } else if (mResponseMsg.Find("VMS", true) > -1) {
 43113:             mServerType = FTP_VMS_TYPE;
 43113:         } else {
 43113:             NS_ERROR("Server type list format unrecognized.");
 43113:             // Guessing causes crashes.
 43113:             // (Of course, the parsing code should be more robust...)
 43113:             nsCOMPtr<nsIStringBundleService> bundleService =
 43113:                 do_GetService(NS_STRINGBUNDLE_CONTRACTID);
 43113:             if (!bundleService)
 43113:                 return FTP_ERROR;
 43113: 
 43113:             nsCOMPtr<nsIStringBundle> bundle;
 43113:             nsresult rv = bundleService->CreateBundle(NECKO_MSGS_URL,
 43113:                                                       getter_AddRefs(bundle));
 43113:             if (NS_FAILED(rv))
 43113:                 return FTP_ERROR;
 43113:             
 43113:             PRUnichar* ucs2Response = ToNewUnicode(mResponseMsg);
 43113:             const PRUnichar *formatStrings[1] = { ucs2Response };
 43113:             NS_NAMED_LITERAL_STRING(name, "UnsupportedFTPServer");
 43113: 
 43113:             nsXPIDLString formattedString;
 43113:             rv = bundle->FormatStringFromName(name.get(), formatStrings, 1,
 43113:                                               getter_Copies(formattedString));
 43113:             nsMemory::Free(ucs2Response);
 43113:             if (NS_FAILED(rv))
 43113:                 return FTP_ERROR;
 43113: 
 43113:             // TODO(darin): this code should not be dictating UI like this!
 43113:             nsCOMPtr<nsIPrompt> prompter;
 43113:             mChannel->GetCallback(prompter);
 43113:             if (prompter)
106838:                 prompter->Alert(nullptr, formattedString.get());
 43113:             
 43113:             // since we just alerted the user, clear mResponseMsg,
 43113:             // which is displayed to the user.
 43113:             mResponseMsg = "";
 43113:             return FTP_ERROR;
 43113:         }
 43113:         
 43113:         return FTP_S_PWD;
 43113:     }
 43113: 
 43113:     if (mResponseCode/100 == 5) {   
 43113:         // server didn't like the SYST command.  Probably (500, 501, 502)
 43113:         // No clue.  We will just hope it is UNIX type server.
 43113:         mServerType = FTP_UNIX_TYPE;
 43113: 
 43113:         return FTP_S_PWD;
 43113:     }
 43113:     return FTP_ERROR;
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::S_acct() {
 43113:     return SendFTPCommand(NS_LITERAL_CSTRING("ACCT noaccount" CRLF));
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_acct() {
 43113:     if (mResponseCode/100 == 2)
 43113:         return FTP_S_SYST;
 43113: 
 43113:     return FTP_ERROR;
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::S_type() {
 43113:     return SendFTPCommand(NS_LITERAL_CSTRING("TYPE I" CRLF));
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_type() {
 43113:     if (mResponseCode/100 != 2) 
 43113:         return FTP_ERROR;
 43113:     
 43113:     return FTP_S_PASV;
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::S_cwd() {
 82649:     // Don't cache the connection if PWD command failed
 82649:     if (mPwd.IsEmpty())
 94737:         mCacheConnection = false;
 82649: 
110974:     nsAutoCString cwdStr;
 43113:     if (mAction != PUT)
 43113:         cwdStr = mPath;
 43113:     if (cwdStr.IsEmpty() || cwdStr.First() != '/')
 43113:         cwdStr.Insert(mPwd,0);
 43113:     if (mServerType == FTP_VMS_TYPE)
 43113:         ConvertDirspecToVMS(cwdStr);
 43113:     cwdStr.Insert("CWD ",0);
 43113:     cwdStr.Append(CRLF);
 43113: 
 43113:     return SendFTPCommand(cwdStr);
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_cwd() {
 43113:     if (mResponseCode/100 == 2) {
 43113:         if (mAction == PUT)
 43113:             return FTP_S_STOR;
 43113:         
 43113:         return FTP_S_LIST;
 43113:     }
 43113:     
 43113:     return FTP_ERROR;
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::S_size() {
110974:     nsAutoCString sizeBuf(mPath);
 43113:     if (sizeBuf.IsEmpty() || sizeBuf.First() != '/')
 43113:         sizeBuf.Insert(mPwd,0);
 43113:     if (mServerType == FTP_VMS_TYPE)
 43113:         ConvertFilespecToVMS(sizeBuf);
 43113:     sizeBuf.Insert("SIZE ",0);
 43113:     sizeBuf.Append(CRLF);
 43113: 
 43113:     return SendFTPCommand(sizeBuf);
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_size() {
 43113:     if (mResponseCode/100 == 2) {
 43113:         PR_sscanf(mResponseMsg.get() + 4, "%llu", &mFileSize);
119704:         mChannel->SetContentLength(mFileSize);
 43113:     }
 43113: 
 43113:     // We may want to be able to resume this
 43113:     return FTP_S_MDTM;
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::S_mdtm() {
110974:     nsAutoCString mdtmBuf(mPath);
 43113:     if (mdtmBuf.IsEmpty() || mdtmBuf.First() != '/')
 43113:         mdtmBuf.Insert(mPwd,0);
 43113:     if (mServerType == FTP_VMS_TYPE)
 43113:         ConvertFilespecToVMS(mdtmBuf);
 43113:     mdtmBuf.Insert("MDTM ",0);
 43113:     mdtmBuf.Append(CRLF);
 43113: 
 43113:     return SendFTPCommand(mdtmBuf);
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_mdtm() {
 43113:     if (mResponseCode == 213) {
 43113:         mResponseMsg.Cut(0,4);
 43113:         mResponseMsg.Trim(" \t\r\n");
 43113:         // yyyymmddhhmmss
 43113:         if (mResponseMsg.Length() != 14) {
 43113:             NS_ASSERTION(mResponseMsg.Length() == 14, "Unknown MDTM response");
 43113:         } else {
 43113:             mModTime = mResponseMsg;
 43113: 
 43113:             // Save lastModified time for downloaded files.
110974:             nsAutoCString timeString;
106878:             nsresult error;
 43113:             PRExplodedTime exTime;
 43113: 
 43113:             mResponseMsg.Mid(timeString, 0, 4);
 43113:             exTime.tm_year  = timeString.ToInteger(&error, 10);
 43113:             mResponseMsg.Mid(timeString, 4, 2);
 43113:             exTime.tm_month = timeString.ToInteger(&error, 10) - 1; //january = 0
 43113:             mResponseMsg.Mid(timeString, 6, 2);
 43113:             exTime.tm_mday  = timeString.ToInteger(&error, 10);
 43113:             mResponseMsg.Mid(timeString, 8, 2);
 43113:             exTime.tm_hour  = timeString.ToInteger(&error, 10);
 43113:             mResponseMsg.Mid(timeString, 10, 2);
 43113:             exTime.tm_min   = timeString.ToInteger(&error, 10);
 43113:             mResponseMsg.Mid(timeString, 12, 2);
 43113:             exTime.tm_sec   = timeString.ToInteger(&error, 10);
 43113:             exTime.tm_usec  = 0;
 43113: 
 43113:             exTime.tm_params.tp_gmt_offset = 0;
 43113:             exTime.tm_params.tp_dst_offset = 0;
 43113: 
 43113:             PR_NormalizeTime(&exTime, PR_GMTParameters);
 43113:             exTime.tm_params = PR_LocalTimeParameters(&exTime);
 43113: 
 43113:             PRTime time = PR_ImplodeTime(&exTime);
 43113:             (void)mChannel->SetLastModifiedTime(time);
 43113:         }
 43113:     }
 43113: 
 43113:     nsCString entityID;
 43113:     entityID.Truncate();
108991:     entityID.AppendInt(int64_t(mFileSize));
 43113:     entityID.Append('/');
 43113:     entityID.Append(mModTime);
 43113:     mChannel->SetEntityID(entityID);
 43113: 
 43113:     // We weren't asked to resume
 43113:     if (!mChannel->ResumeRequested())
 43113:         return FTP_S_RETR;
 43113: 
 43113:     //if (our entityID == supplied one (if any))
 43113:     if (mSuppliedEntityID.IsEmpty() || entityID.Equals(mSuppliedEntityID))
 43113:         return FTP_S_REST;
 43113: 
 43113:     mInternalError = NS_ERROR_ENTITY_CHANGED;
 43113:     mResponseMsg.Truncate();
 43113:     return FTP_ERROR;
 43113: }
 43113: 
 43113: nsresult 
 43113: nsFtpState::SetContentType()
 43113: {
 43113:     // FTP directory URLs don't always end in a slash.  Make sure they do.
 43113:     // This check needs to be here rather than a more obvious place
 43113:     // (e.g. LIST command processing) so that it ensures the terminating
 43113:     // slash is appended for the new request case, as well as the case
 43113:     // where the URL is being loaded from the cache.
 43113: 
 43113:     if (!mPath.IsEmpty() && mPath.Last() != '/') {
 43113:         nsCOMPtr<nsIURL> url = (do_QueryInterface(mChannel->URI()));
110974:         nsAutoCString filePath;
 43113:         if(NS_SUCCEEDED(url->GetFilePath(filePath))) {
 43113:             filePath.Append('/');
 43113:             url->SetFilePath(filePath);
 43113:         }
 43113:     }
 43113:     return mChannel->SetContentType(
 43113:         NS_LITERAL_CSTRING(APPLICATION_HTTP_INDEX_FORMAT));
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::S_list() {
 43113:     nsresult rv = SetContentType();
 43113:     if (NS_FAILED(rv)) 
106856:         // XXX Invalid cast of FTP_STATE to nsresult -- FTP_ERROR has
106856:         // value < 0x80000000 and will pass NS_SUCCEEDED() (bug 778109)
106856:         return (nsresult)FTP_ERROR;
 43113: 
 43113:     rv = mChannel->PushStreamConverter("text/ftp-dir",
 43113:                                        APPLICATION_HTTP_INDEX_FORMAT);
 43113:     if (NS_FAILED(rv)) {
 43113:         // clear mResponseMsg which is displayed to the user.
 43113:         // TODO: we should probably set this to something meaningful.
 43113:         mResponseMsg = "";
 43113:         return rv;
 43113:     }
 43113:     
 43113:     if (mCacheEntry) {
 43113:         // save off the server type if we are caching.
110974:         nsAutoCString serverType;
 43113:         serverType.AppendInt(mServerType);
 43113:         mCacheEntry->SetMetaDataElement("servertype", serverType.get());
 43113: 
 43113:         // open cache entry for writing, and configure it to receive data.
 43113:         if (NS_FAILED(InstallCacheListener())) {
114159:             mCacheEntry->AsyncDoom(nullptr);
106838:             mCacheEntry = nullptr;
 43113:         }
 43113:     }
 43113: 
 43113:     // dir listings aren't resumable
 43113:     NS_ENSURE_TRUE(!mChannel->ResumeRequested(), NS_ERROR_NOT_RESUMABLE);
 43113: 
 43113:     mChannel->SetEntityID(EmptyCString());
 43113: 
 43113:     const char *listString;
 43113:     if (mServerType == FTP_VMS_TYPE) {
 43113:         listString = "LIST *.*;0" CRLF;
 43113:     } else {
 43113:         listString = "LIST" CRLF;
 43113:     }
 43113: 
 43113:     return SendFTPCommand(nsDependentCString(listString));
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_list() {
 43113:     if (mResponseCode/100 == 1) {
 43113:         // OK, time to start reading from the data connection.
 43113:         if (HasPendingCallback())
 43113:             mDataStream->AsyncWait(this, 0, 0, CallbackTarget());
 43113:         return FTP_READ_BUF;
 43113:     }
 43113: 
 43113:     if (mResponseCode/100 == 2) {
 43113:         //(DONE)
 43113:         mNextState = FTP_COMPLETE;
 80486:         mDoomCache = false;
 43113:         return FTP_COMPLETE;
 43113:     }
 43113:     return FTP_ERROR;
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::S_retr() {
110974:     nsAutoCString retrStr(mPath);
 43113:     if (retrStr.IsEmpty() || retrStr.First() != '/')
 43113:         retrStr.Insert(mPwd,0);
 43113:     if (mServerType == FTP_VMS_TYPE)
 43113:         ConvertFilespecToVMS(retrStr);
 43113:     retrStr.Insert("RETR ",0);
 43113:     retrStr.Append(CRLF);
 43113:     return SendFTPCommand(retrStr);
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_retr() {
 43113:     if (mResponseCode/100 == 2) {
 43113:         //(DONE)
 43113:         mNextState = FTP_COMPLETE;
 43113:         return FTP_COMPLETE;
 43113:     }
 43113: 
 43113:     if (mResponseCode/100 == 1) {
 43113:         // We're going to grab a file, not a directory. So we need to clear
 43113:         // any cache entry, otherwise we'll have problems reading it later.
 43113:         // See bug 122548
 43113:         if (mCacheEntry) {
114159:             (void)mCacheEntry->AsyncDoom(nullptr);
106838:             mCacheEntry = nullptr;
 43113:         }
 43113:         if (HasPendingCallback())
 43113:             mDataStream->AsyncWait(this, 0, 0, CallbackTarget());
 43113:         return FTP_READ_BUF;
 43113:     }
 43113:     
 43113:     // These error codes are related to problems with the connection.  
 43113:     // If we encounter any at this point, do not try CWD and abort.
 43113:     if (mResponseCode == 421 || mResponseCode == 425 || mResponseCode == 426)
 43113:         return FTP_ERROR;
 43113: 
 43113:     if (mResponseCode/100 == 5) {
 80486:         mRETRFailed = true;
 43113:         return FTP_S_PASV;
 43113:     }
 43113: 
 43113:     return FTP_S_CWD;
 43113: }
 43113: 
 43113: 
 43113: nsresult
 43113: nsFtpState::S_rest() {
 43113:     
110974:     nsAutoCString restString("REST ");
108991:     // The int64_t cast is needed to avoid ambiguity
108991:     restString.AppendInt(int64_t(mChannel->StartPos()), 10);
 43113:     restString.Append(CRLF);
 43113: 
 43113:     return SendFTPCommand(restString);
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_rest() {
 43113:     if (mResponseCode/100 == 4) {
 43113:         // If REST fails, then we can't resume
 43113:         mChannel->SetEntityID(EmptyCString());
 43113: 
 43113:         mInternalError = NS_ERROR_NOT_RESUMABLE;
 43113:         mResponseMsg.Truncate();
 43113: 
 43113:         return FTP_ERROR;
 43113:     }
 43113:    
 43113:     return FTP_S_RETR; 
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::S_stor() {
 43113:     NS_ENSURE_STATE(mChannel->UploadStream());
 43113: 
 43113:     NS_ASSERTION(mAction == PUT, "Wrong state to be here");
 43113:     
 43113:     nsCOMPtr<nsIURL> url = do_QueryInterface(mChannel->URI());
 43113:     NS_ASSERTION(url, "I thought you were a nsStandardURL");
 43113: 
110974:     nsAutoCString storStr;
 43113:     url->GetFilePath(storStr);
 43113:     NS_ASSERTION(!storStr.IsEmpty(), "What does it mean to store a empty path");
 43113:         
 43113:     // kill the first slash since we want to be relative to CWD.
 43113:     if (storStr.First() == '/')
 43113:         storStr.Cut(0,1);
 43113: 
 43113:     if (mServerType == FTP_VMS_TYPE)
 43113:         ConvertFilespecToVMS(storStr);
 43113: 
 43113:     NS_UnescapeURL(storStr);
 43113:     storStr.Insert("STOR ",0);
 43113:     storStr.Append(CRLF);
 43113: 
 43113:     return SendFTPCommand(storStr);
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_stor() {
 43113:     if (mResponseCode/100 == 2) {
 43113:         //(DONE)
 43113:         mNextState = FTP_COMPLETE;
 80486:         mStorReplyReceived = true;
 43113: 
 43113:         // Call Close() if it was not called in nsFtpState::OnStoprequest()
 43113:         if (!mUploadRequest && !IsClosed())
 43113:             Close();
 43113: 
 43113:         return FTP_COMPLETE;
 43113:     }
 43113: 
 43113:     if (mResponseCode/100 == 1) {
 43113:         LOG(("FTP:(%x) writing on DT\n", this));
 43113:         return FTP_READ_BUF;
 43113:     }
 43113: 
 80486:    mStorReplyReceived = true;
 43113:    return FTP_ERROR;
 43113: }
 43113: 
 43113: 
 43113: nsresult
 43113: nsFtpState::S_pasv() {
 43113:     if (!mAddressChecked) {
 43113:         // Find socket address
 80486:         mAddressChecked = true;
 43113:         PR_InitializeNetAddr(PR_IpAddrAny, 0, &mServerAddress);
 43113: 
 43113:         nsITransport *controlSocket = mControlConnection->Transport();
 43113:         if (!controlSocket)
106856:             // XXX Invalid cast of FTP_STATE to nsresult -- FTP_ERROR has
106856:             // value < 0x80000000 and will pass NS_SUCCEEDED() (bug 778109)
106856:             return (nsresult)FTP_ERROR;
 43113: 
 43113:         nsCOMPtr<nsISocketTransport> sTrans = do_QueryInterface(controlSocket);
 43113:         if (sTrans) {
 43113:             nsresult rv = sTrans->GetPeerAddr(&mServerAddress);
 43113:             if (NS_SUCCEEDED(rv)) {
 43113:                 if (!PR_IsNetAddrType(&mServerAddress, PR_IpAddrAny))
 43113:                     mServerIsIPv6 = mServerAddress.raw.family == PR_AF_INET6 &&
 43113:                         !PR_IsNetAddrType(&mServerAddress, PR_IpAddrV4Mapped);
 43113:                 else {
 43113:                     /*
 43113:                      * In case of SOCKS5 remote DNS resolution, we do
 43113:                      * not know the remote IP address. Still, if it is
 43113:                      * an IPV6 host, then the external address of the
 43113:                      * socks server should also be IPv6, and this is the
 43113:                      * self address of the transport.
 43113:                      */
 43113:                     PRNetAddr selfAddress;
 43113:                     rv = sTrans->GetSelfAddr(&selfAddress);
 43113:                     if (NS_SUCCEEDED(rv))
 43113:                         mServerIsIPv6 = selfAddress.raw.family == PR_AF_INET6
 43113:                             && !PR_IsNetAddrType(&selfAddress,
 43113:                                                  PR_IpAddrV4Mapped);
 43113:                 }
 43113:             }
 43113:         }
 43113:     }
 43113: 
 43113:     const char *string;
 43113:     if (mServerIsIPv6) {
 43113:         string = "EPSV" CRLF;
 43113:     } else {
 43113:         string = "PASV" CRLF;
 43113:     }
 43113: 
 43113:     return SendFTPCommand(nsDependentCString(string));
 43113:     
 43113: }
 43113: 
 43113: FTP_STATE
 43113: nsFtpState::R_pasv() {
 43113:     if (mResponseCode/100 != 2)
 43113:         return FTP_ERROR;
 43113: 
 43113:     nsresult rv;
108991:     int32_t port;
 43113: 
110974:     nsAutoCString responseCopy(mResponseMsg);
 43113:     char *response = responseCopy.BeginWriting();
 43113: 
 43113:     char *ptr = response;
 43113: 
 43113:     // Make sure to ignore the address in the PASV response (bug 370559)
 43113: 
 43113:     if (mServerIsIPv6) {
 43113:         // The returned string is of the form
 43113:         // text (|||ppp|)
 43113:         // Where '|' can be any single character
 43113:         char delim;
 43113:         while (*ptr && *ptr != '(')
 43113:             ptr++;
 43113:         if (*ptr++ != '(')
 43113:             return FTP_ERROR;
 43113:         delim = *ptr++;
 43113:         if (!delim || *ptr++ != delim ||
 43113:                       *ptr++ != delim || 
 43113:                       *ptr < '0' || *ptr > '9')
 43113:             return FTP_ERROR;
 43113:         port = 0;
 43113:         do {
 43113:             port = port * 10 + *ptr++ - '0';
 43113:         } while (*ptr >= '0' && *ptr <= '9');
 43113:         if (*ptr++ != delim || *ptr != ')')
 43113:             return FTP_ERROR;
 43113:     } else {
 43113:         // The returned address string can be of the form
 43113:         // (xxx,xxx,xxx,xxx,ppp,ppp) or
 43113:         //  xxx,xxx,xxx,xxx,ppp,ppp (without parens)
108991:         int32_t h0, h1, h2, h3, p0, p1;
 43113: 
108991:         uint32_t fields = 0;
 43113:         // First try with parens
 43113:         while (*ptr && *ptr != '(')
 43113:             ++ptr;
 43113:         if (*ptr) {
 43113:             ++ptr;
 43113:             fields = PR_sscanf(ptr, 
 43113:                                "%ld,%ld,%ld,%ld,%ld,%ld",
 43113:                                &h0, &h1, &h2, &h3, &p0, &p1);
 43113:         }
 43113:         if (!*ptr || fields < 6) {
 43113:             // OK, lets try w/o parens
 43113:             ptr = response;
 43113:             while (*ptr && *ptr != ',')
 43113:                 ++ptr;
 43113:             if (*ptr) {
 43113:                 // backup to the start of the digits
 43113:                 do {
 43113:                     ptr--;
 43113:                 } while ((ptr >=response) && (*ptr >= '0') && (*ptr <= '9'));
 43113:                 ptr++; // get back onto the numbers
 43113:                 fields = PR_sscanf(ptr, 
 43113:                                    "%ld,%ld,%ld,%ld,%ld,%ld",
 43113:                                    &h0, &h1, &h2, &h3, &p0, &p1);
 43113:             }
 43113:         }
 43113: 
 43113:         NS_ASSERTION(fields == 6, "Can't parse PASV response");
 43113:         if (fields < 6)
 43113:             return FTP_ERROR;
 43113: 
108991:         port = ((int32_t) (p0<<8)) + p1;
 43113:     }
 43113: 
 79445:     bool newDataConn = true;
 43113:     if (mDataTransport) {
 43113:         // Reuse this connection only if its still alive, and the port
 43113:         // is the same
 43113:         nsCOMPtr<nsISocketTransport> strans = do_QueryInterface(mDataTransport);
 43113:         if (strans) {
108991:             int32_t oldPort;
 43113:             nsresult rv = strans->GetPort(&oldPort);
 43113:             if (NS_SUCCEEDED(rv)) {
 43113:                 if (oldPort == port) {
 79445:                     bool isAlive;
 71858:                     if (NS_SUCCEEDED(strans->IsAlive(&isAlive)) && isAlive)
 80486:                         newDataConn = false;
 43113:                 }
 43113:             }
 43113:         }
 43113: 
 43113:         if (newDataConn) {
 43113:             mDataTransport->Close(NS_ERROR_ABORT);
106838:             mDataTransport = nullptr;
106838:             mDataStream = nullptr;
 43113:         }
 43113:     }
 43113: 
 43113:     if (newDataConn) {
 43113:         // now we know where to connect our data channel
 43113:         nsCOMPtr<nsISocketTransportService> sts =
 43113:             do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID);
 43113:         if (!sts)
 43113:             return FTP_ERROR;
 43113:        
 43113:         nsCOMPtr<nsISocketTransport> strans;
 43113: 
110974:         nsAutoCString host;
 43113:         if (!PR_IsNetAddrType(&mServerAddress, PR_IpAddrAny)) {
 43113:             char buf[64];
 43113:             PR_NetAddrToString(&mServerAddress, buf, sizeof(buf));
 43113:             host.Assign(buf);
 43113:         } else {
 43113:             /*
 43113:              * In case of SOCKS5 remote DNS resolving, the peer address
 43113:              * fetched previously will be invalid (0.0.0.0): it is unknown
 43113:              * to us. But we can pass on the original hostname to the
 43113:              * connect for the data connection.
 43113:              */
 43113:             rv = mChannel->URI()->GetAsciiHost(host);
 43113:             if (NS_FAILED(rv))
 43113:                 return FTP_ERROR;
 43113:         }
 43113: 
106838:         rv =  sts->CreateTransport(nullptr, 0, host,
 43113:                                    port, mChannel->ProxyInfo(),
 43113:                                    getter_AddRefs(strans)); // the data socket
 43113:         if (NS_FAILED(rv))
 43113:             return FTP_ERROR;
 43113:         mDataTransport = strans;
 43113: 
 43113:         strans->SetQoSBits(gFtpHandler->GetDataQoSBits());
 43113:         
 43113:         LOG(("FTP:(%x) created DT (%s:%x)\n", this, host.get(), port));
 43113:         
 43113:         // hook ourself up as a proxy for status notifications
 43113:         rv = mDataTransport->SetEventSink(this, NS_GetCurrentThread());
 43113:         NS_ENSURE_SUCCESS(rv, FTP_ERROR);
 43113: 
 43113:         if (mAction == PUT) {
 43113:             NS_ASSERTION(!mRETRFailed, "Failed before uploading");
 43113: 
 43113:             // nsIUploadChannel requires the upload stream to support ReadSegments.
 43113:             // therefore, we can open an unbuffered socket output stream.
 43113:             nsCOMPtr<nsIOutputStream> output;
 43113:             rv = mDataTransport->OpenOutputStream(nsITransport::OPEN_UNBUFFERED,
 43113:                                                   0, 0, getter_AddRefs(output));
 43113:             if (NS_FAILED(rv))
 43113:                 return FTP_ERROR;
 43113: 
 43113:             // perform the data copy on the socket transport thread.  we do this
 43113:             // because "output" is a socket output stream, so the result is that
 43113:             // all work will be done on the socket transport thread.
 43113:             nsCOMPtr<nsIEventTarget> stEventTarget =
 43113:                 do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID);
 43113:             if (!stEventTarget)
 43113:                 return FTP_ERROR;
 43113:             
 43113:             nsCOMPtr<nsIAsyncStreamCopier> copier;
 43113:             rv = NS_NewAsyncStreamCopier(getter_AddRefs(copier),
 43113:                                          mChannel->UploadStream(),
 43113:                                          output,
 43113:                                          stEventTarget,
 80486:                                          true,   // upload stream is buffered
 80486:                                          false); // output is NOT buffered
 43113:             if (NS_FAILED(rv))
 43113:                 return FTP_ERROR;
 43113:         
106838:             rv = copier->AsyncCopy(this, nullptr);
 43113:             if (NS_FAILED(rv))
 43113:                 return FTP_ERROR;
 43113: 
 43113:             // hold a reference to the copier so we can cancel it if necessary.
 43113:             mUploadRequest = copier;
 43113: 
 43113:             // update the current working directory before sending the STOR
 43113:             // command.  this is needed since we might be reusing a control
 43113:             // connection.
 43113:             return FTP_S_CWD;
 43113:         }
 43113: 
 43113:         //
 43113:         // else, we are reading from the data connection...
 43113:         //
 43113: 
 43113:         // open a buffered, asynchronous socket input stream
 43113:         nsCOMPtr<nsIInputStream> input;
 43113:         rv = mDataTransport->OpenInputStream(0,
 43113:                                              nsIOService::gDefaultSegmentSize,
 43113:                                              nsIOService::gDefaultSegmentCount,
 43113:                                              getter_AddRefs(input));
 43113:         NS_ENSURE_SUCCESS(rv, FTP_ERROR);
 43113:         mDataStream = do_QueryInterface(input);
 43113:     }
 43113: 
 43546:     if (mRETRFailed || mPath.IsEmpty() || mPath.Last() == '/')
 43113:         return FTP_S_CWD;
 43113:     return FTP_S_SIZE;
 43113: }
 43113: 
 43113: ////////////////////////////////////////////////////////////////////////////////
 43113: // nsIRequest methods:
 43113: 
 43113: static inline
108991: uint32_t NowInSeconds()
 43113: {
108991:     return uint32_t(PR_Now() / PR_USEC_PER_SEC);
 43113: }
 43113: 
108991: uint32_t nsFtpState::mSessionStartTime = NowInSeconds();
 43113: 
 43113: /* Is this cache entry valid to use for reading?
 43113:  * Since we make up an expiration time for ftp, use the following rules:
 43113:  * (see bug 103726)
 43113:  *
 43113:  * LOAD_FROM_CACHE                    : always use cache entry, even if expired
 43113:  * LOAD_BYPASS_CACHE                  : overwrite cache entry
 43113:  * LOAD_NORMAL|VALIDATE_ALWAYS        : overwrite cache entry
 43113:  * LOAD_NORMAL                        : honor expiration time
 43113:  * LOAD_NORMAL|VALIDATE_ONCE_PER_SESSION : overwrite cache entry if first access 
 43113:  *                                         this session, otherwise use cache entry 
 43113:  *                                         even if expired.
 43113:  * LOAD_NORMAL|VALIDATE_NEVER         : always use cache entry, even if expired
 43113:  *
 43113:  * Note that in theory we could use the mdtm time on the directory
 43113:  * In practice, the lack of a timezone plus the general lack of support for that
 43113:  * on directories means that its not worth it, I suspect. Revisit if we start
 43113:  * caching files - bbaetz
 43113:  */
 79445: bool
 43113: nsFtpState::CanReadCacheEntry()
 43113: {
 43113:     NS_ASSERTION(mCacheEntry, "must have a cache entry");
 43113: 
 43113:     nsCacheAccessMode access;
 43113:     nsresult rv = mCacheEntry->GetAccessGranted(&access);
 43113:     if (NS_FAILED(rv))
 80486:         return false;
 43113:     
 43113:     // If I'm not granted read access, then I can't reuse it...
 43113:     if (!(access & nsICache::ACCESS_READ))
 80486:         return false;
 43113: 
 43113:     if (mChannel->HasLoadFlag(nsIRequest::LOAD_FROM_CACHE))
 80486:         return true;
 43113: 
 43113:     if (mChannel->HasLoadFlag(nsIRequest::LOAD_BYPASS_CACHE))
 80486:         return false;
 43113:     
 43113:     if (mChannel->HasLoadFlag(nsIRequest::VALIDATE_ALWAYS))
 80486:         return false;
 43113:     
108991:     uint32_t time;
 43113:     if (mChannel->HasLoadFlag(nsIRequest::VALIDATE_ONCE_PER_SESSION)) {
 43113:         rv = mCacheEntry->GetLastModified(&time);
 43113:         if (NS_FAILED(rv))
 80486:             return false;
 43113:         return (mSessionStartTime > time);
 43113:     }
 43113: 
 43113:     if (mChannel->HasLoadFlag(nsIRequest::VALIDATE_NEVER))
 80486:         return true;
 43113: 
 43113:     // OK, now we just check the expiration time as usual
 43113:     rv = mCacheEntry->GetExpirationTime(&time);
 43113:     if (NS_FAILED(rv))
 80486:         return false;
 43113: 
 43113:     return (NowInSeconds() <= time);
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::InstallCacheListener()
 43113: {
 43113:     NS_ASSERTION(mCacheEntry, "must have a cache entry");
 43113: 
 43113:     nsCOMPtr<nsIOutputStream> out;
 43113:     mCacheEntry->OpenOutputStream(0, getter_AddRefs(out));
 43113:     NS_ENSURE_STATE(out);
 43113: 
 43113:     nsCOMPtr<nsIStreamListenerTee> tee =
 43113:             do_CreateInstance(NS_STREAMLISTENERTEE_CONTRACTID);
 43113:     NS_ENSURE_STATE(tee);
 43113: 
106838:     nsresult rv = tee->Init(mChannel->StreamListener(), out, nullptr);
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:     mChannel->SetStreamListener(tee);
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::OpenCacheDataStream()
 43113: {
 43113:     NS_ASSERTION(mCacheEntry, "must have a cache entry");
 43113: 
 43113:     // Get a transport to the cached data...
 43113:     nsCOMPtr<nsIInputStream> input;
 43113:     mCacheEntry->OpenInputStream(0, getter_AddRefs(input));
 43113:     NS_ENSURE_STATE(input);
 43113: 
 43113:     nsCOMPtr<nsIStreamTransportService> sts =
 43113:             do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID);
 43113:     NS_ENSURE_STATE(sts);
 43113: 
 43113:     nsCOMPtr<nsITransport> transport;
 80486:     sts->CreateInputTransport(input, -1, -1, true,
 43113:                               getter_AddRefs(transport));
 43113:     NS_ENSURE_STATE(transport);
 43113: 
 43113:     nsresult rv = transport->SetEventSink(this, NS_GetCurrentThread());
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:     // Open a non-blocking, buffered input stream...
 43113:     nsCOMPtr<nsIInputStream> transportInput;
 43113:     transport->OpenInputStream(0,
 43113:                                nsIOService::gDefaultSegmentSize,
 43113:                                nsIOService::gDefaultSegmentCount,
 43113:                                getter_AddRefs(transportInput));
 43113:     NS_ENSURE_STATE(transportInput);
 43113: 
 43113:     mDataStream = do_QueryInterface(transportInput);
 43113:     NS_ENSURE_STATE(mDataStream);
 43113: 
 43113:     mDataTransport = transport;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::Init(nsFtpChannel *channel)
 43113: {
 43113:     // parameter validation
 43113:     NS_ASSERTION(channel, "FTP: needs a channel");
 43113: 
 43113:     mChannel = channel; // a straight ref ptr to the channel
 43113: 
 80486:     mKeepRunning = true;
 43113:     mSuppliedEntityID = channel->EntityID();
 43113:   
 43113:     if (channel->UploadStream())
 43113:         mAction = PUT;
 43113: 
 43113:     nsresult rv;
 43113:     nsCOMPtr<nsIURL> url = do_QueryInterface(mChannel->URI());
 86629: 
120913:     nsAutoCString host;
120913:     if (url) {
120913:         rv = url->GetAsciiHost(host);
120913:     } else {
120913:         rv = mChannel->URI()->GetAsciiHost(host);
120913:     }
120913:     if (NS_FAILED(rv) || host.IsEmpty()) {
 86629:         return NS_ERROR_MALFORMED_URI;
 86629:     }
 86629: 
120913:     nsAutoCString path;
 43113:     if (url) {
 43113:         rv = url->GetFilePath(path);
 43113:     } else {
 43113:         rv = mChannel->URI()->GetPath(path);
 43113:     }
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 78645:     removeParamsFromPath(path);
 78645:     
 78645:     // FTP parameters such as type=i are ignored
 78645:     if (url) {
 78645:         url->SetFilePath(path);
 78645:     } else {
 78645:         mChannel->URI()->SetPath(path);
 78645:     }
 78645:         
 43113:     // Skip leading slash
 43113:     char *fwdPtr = path.BeginWriting();
 76926:     if (!fwdPtr)
 76926:         return NS_ERROR_OUT_OF_MEMORY;
 76926:     if (*fwdPtr == '/')
 43113:         fwdPtr++;
 43113:     if (*fwdPtr != '\0') {
 43113:         // now unescape it... %xx reduced inline to resulting character
108991:         int32_t len = NS_UnescapeURL(fwdPtr);
 43113:         mPath.Assign(fwdPtr, len);
 43113:         if (IsUTF8(mPath)) {
110974:     	    nsAutoCString originCharset;
 43113:     	    rv = mChannel->URI()->GetOriginCharset(originCharset);
 43113:     	    if (NS_SUCCEEDED(rv) && !originCharset.EqualsLiteral("UTF-8"))
 43113:     	        ConvertUTF8PathToCharset(originCharset);
 43113:         }
 43113: 
 43113: #ifdef DEBUG
 43113:         if (mPath.FindCharInSet(CRLF) >= 0)
 43113:             NS_ERROR("NewURI() should've prevented this!!!");
 43113: #endif
 43113:     }
 43113: 
 43113:     // pull any username and/or password out of the uri
110974:     nsAutoCString uname;
 43113:     rv = mChannel->URI()->GetUsername(uname);
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 43113:     if (!uname.IsEmpty() && !uname.EqualsLiteral("anonymous")) {
 80486:         mAnonymous = false;
 43113:         CopyUTF8toUTF16(NS_UnescapeURL(uname), mUsername);
 43113:         
 43113:         // return an error if we find a CR or LF in the username
 43113:         if (uname.FindCharInSet(CRLF) >= 0)
 43113:             return NS_ERROR_MALFORMED_URI;
 43113:     }
 43113: 
110974:     nsAutoCString password;
 43113:     rv = mChannel->URI()->GetPassword(password);
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 43113:     CopyUTF8toUTF16(NS_UnescapeURL(password), mPassword);
 43113: 
 43113:     // return an error if we find a CR or LF in the password
 43113:     if (mPassword.FindCharInSet(CRLF) >= 0)
 43113:         return NS_ERROR_MALFORMED_URI;
 43113: 
 43113:     // setup the connection cache key
 43113: 
108991:     int32_t port;
 43113:     rv = mChannel->URI()->GetPort(&port);
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 43113:     if (port > 0)
 43113:         mPort = port;
 43113: 
115189:     // Lookup Proxy information asynchronously if it isn't already set
115189:     // on the channel and if we aren't configured explicitly to go directly
115189:     nsCOMPtr<nsIProtocolProxyService> pps =
115189:         do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID);
115189: 
116144:     if (pps && !mChannel->ProxyInfo()) {
115189:         pps->AsyncResolve(mChannel->URI(), 0, this,
115189:                           getter_AddRefs(mProxyRequest));
115189:     }
115189: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: void
 43113: nsFtpState::Connect()
 43113: {
 43113:     mState = FTP_COMMAND_CONNECT;
 43113:     mNextState = FTP_S_USER;
 43113: 
 43113:     nsresult rv = Process();
 43113: 
 43113:     // check for errors.
 43113:     if (NS_FAILED(rv)) {
 43113:         LOG(("FTP:Process() failed: %x\n", rv));
 43113:         mInternalError = NS_ERROR_FAILURE;
 43113:         mState = FTP_ERROR;
 43113:         CloseWithStatus(mInternalError);
 43113:     }
 43113: }
 43113: 
 43113: void
 43113: nsFtpState::KillControlConnection()
 43113: {
 43113:     mControlReadCarryOverBuf.Truncate(0);
 43113: 
 80486:     mAddressChecked = false;
 80486:     mServerIsIPv6 = false;
 43113: 
 43113:     // if everything went okay, save the connection. 
 43113:     // FIX: need a better way to determine if we can cache the connections.
 43113:     //      there are some errors which do not mean that we need to kill the connection
 43113:     //      e.g. fnf.
 43113: 
 43113:     if (!mControlConnection)
 43113:         return;
 43113: 
 43113:     // kill the reference to ourselves in the control connection.
106838:     mControlConnection->WaitData(nullptr);
 43113: 
 43113:     if (NS_SUCCEEDED(mInternalError) &&
 43113:         NS_SUCCEEDED(mControlStatus) &&
 82649:         mControlConnection->IsAlive() &&
 82649:         mCacheConnection) {
 43113: 
 43113:         LOG_ALWAYS(("FTP:(%p) caching CC(%p)", this, mControlConnection.get()));
 43113: 
 43113:         // Store connection persistent data
 43113:         mControlConnection->mServerType = mServerType;           
 43113:         mControlConnection->mPassword = mPassword;
 43113:         mControlConnection->mPwd = mPwd;
 43113:         
 43113:         nsresult rv = NS_OK;
 43113:         // Don't cache controlconnection if anonymous (bug #473371)
 43113:         if (!mChannel->HasLoadFlag(nsIRequest::LOAD_ANONYMOUS))
 43113:             rv = gFtpHandler->InsertConnection(mChannel->URI(),
 43113:                                                mControlConnection);
 43113:         // Can't cache it?  Kill it then.  
 43113:         mControlConnection->Disconnect(rv);
 43113:     } else {
 43113:         mControlConnection->Disconnect(NS_BINDING_ABORTED);
 43113:     }     
 43113: 
106838:     mControlConnection = nullptr;
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::StopProcessing()
 43113: {
 43113:     // Only do this function once.
 43113:     if (!mKeepRunning)
 43113:         return NS_OK;
 80486:     mKeepRunning = false;
 43113: 
 43113:     LOG_ALWAYS(("FTP:(%x) nsFtpState stopping", this));
 43113: 
 43113: #ifdef DEBUG_dougt
 43113:     printf("FTP Stopped: [response code %d] [response msg follows:]\n%s\n", mResponseCode, mResponseMsg.get());
 43113: #endif
 43113: 
 43113:     if (NS_FAILED(mInternalError) && !mResponseMsg.IsEmpty()) {
 43113:         // check to see if the control status is bad.
 43113:         // web shell wont throw an alert.  we better:
 43113: 
 43113:         // XXX(darin): this code should not be dictating UI like this!
 43113:         nsCOMPtr<nsIPrompt> prompter;
 43113:         mChannel->GetCallback(prompter);
 43113:         if (prompter)
106838:             prompter->Alert(nullptr, NS_ConvertASCIItoUTF16(mResponseMsg).get());
 43113:     }
 43113:     
 43113:     nsresult broadcastErrorCode = mControlStatus;
 43113:     if (NS_SUCCEEDED(broadcastErrorCode))
 43113:         broadcastErrorCode = mInternalError;
 43113: 
 43113:     mInternalError = broadcastErrorCode;
 43113: 
 43113:     KillControlConnection();
 43113: 
 43113:     // XXX This can fire before we are done loading data.  Is that a problem?
106838:     OnTransportStatus(nullptr, NS_NET_STATUS_END_FTP_TRANSACTION, 0, 0);
 43113: 
 43113:     if (NS_FAILED(broadcastErrorCode))
 43113:         CloseWithStatus(broadcastErrorCode);
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult 
 43113: nsFtpState::SendFTPCommand(const nsCSubstring& command)
 43113: {
 43113:     NS_ASSERTION(mControlConnection, "null control connection");        
 43113:     
 43113:     // we don't want to log the password:
110974:     nsAutoCString logcmd(command);
 43113:     if (StringBeginsWith(command, NS_LITERAL_CSTRING("PASS "))) 
 43113:         logcmd = "PASS xxxxx";
 43113:     
 43113:     LOG(("FTP:(%x) writing \"%s\"\n", this, logcmd.get()));
 43113: 
 43113:     nsCOMPtr<nsIFTPEventSink> ftpSink;
 43113:     mChannel->GetFTPEventSink(ftpSink);
 43113:     if (ftpSink)
 80486:         ftpSink->OnFTPControlLog(false, logcmd.get());
 43113:     
 43113:     if (mControlConnection)
 43113:         return mControlConnection->Write(command);
 43113: 
 43113:     return NS_ERROR_FAILURE;
 43113: }
 43113: 
 43113: // Convert a unix-style filespec to VMS format
 43113: // /foo/fred/barney/file.txt -> foo:[fred.barney]file.txt
 43113: // /foo/file.txt -> foo:[000000]file.txt
 43113: void
 43113: nsFtpState::ConvertFilespecToVMS(nsCString& fileString)
 43113: {
 43113:     int ntok=1;
 43113:     char *t, *nextToken;
110974:     nsAutoCString fileStringCopy;
 43113: 
 43113:     // Get a writeable copy we can strtok with.
 43113:     fileStringCopy = fileString;
 43113:     t = nsCRT::strtok(fileStringCopy.BeginWriting(), "/", &nextToken);
 43113:     if (t)
 43113:         while (nsCRT::strtok(nextToken, "/", &nextToken))
 43113:             ntok++; // count number of terms (tokens)
 43113:     LOG(("FTP:(%x) ConvertFilespecToVMS ntok: %d\n", this, ntok));
 43113:     LOG(("FTP:(%x) ConvertFilespecToVMS from: \"%s\"\n", this, fileString.get()));
 43113: 
 43113:     if (fileString.First() == '/') {
 43113:         // absolute filespec
 43113:         //   /        -> []
 43113:         //   /a       -> a (doesn't really make much sense)
 43113:         //   /a/b     -> a:[000000]b
 43113:         //   /a/b/c   -> a:[b]c
 43113:         //   /a/b/c/d -> a:[b.c]d
 43113:         if (ntok == 1) {
 43113:             if (fileString.Length() == 1) {
 43113:                 // Just a slash
 43113:                 fileString.Truncate();
 43113:                 fileString.AppendLiteral("[]");
 43113:             } else {
 43113:                 // just copy the name part (drop the leading slash)
 43113:                 fileStringCopy = fileString;
 43113:                 fileString = Substring(fileStringCopy, 1,
 43113:                                        fileStringCopy.Length()-1);
 43113:             }
 43113:         } else {
 43113:             // Get another copy since the last one was written to.
 43113:             fileStringCopy = fileString;
 43113:             fileString.Truncate();
 43113:             fileString.Append(nsCRT::strtok(fileStringCopy.BeginWriting(), 
 43113:                               "/", &nextToken));
 43113:             fileString.AppendLiteral(":[");
 43113:             if (ntok > 2) {
 43113:                 for (int i=2; i<ntok; i++) {
 43113:                     if (i > 2) fileString.Append('.');
 43113:                     fileString.Append(nsCRT::strtok(nextToken,
 43113:                                       "/", &nextToken));
 43113:                 }
 43113:             } else {
 43113:                 fileString.AppendLiteral("000000");
 43113:             }
 43113:             fileString.Append(']');
 43113:             fileString.Append(nsCRT::strtok(nextToken, "/", &nextToken));
 43113:         }
 43113:     } else {
 43113:        // relative filespec
 43113:         //   a       -> a
 43113:         //   a/b     -> [.a]b
 43113:         //   a/b/c   -> [.a.b]c
 43113:         if (ntok == 1) {
 43113:             // no slashes, just use the name as is
 43113:         } else {
 43113:             // Get another copy since the last one was written to.
 43113:             fileStringCopy = fileString;
 43113:             fileString.Truncate();
 43113:             fileString.AppendLiteral("[.");
 43113:             fileString.Append(nsCRT::strtok(fileStringCopy.BeginWriting(),
 43113:                               "/", &nextToken));
 43113:             if (ntok > 2) {
 43113:                 for (int i=2; i<ntok; i++) {
 43113:                     fileString.Append('.');
 43113:                     fileString.Append(nsCRT::strtok(nextToken,
 43113:                                       "/", &nextToken));
 43113:                 }
 43113:             }
 43113:             fileString.Append(']');
 43113:             fileString.Append(nsCRT::strtok(nextToken, "/", &nextToken));
 43113:         }
 43113:     }
 43113:     LOG(("FTP:(%x) ConvertFilespecToVMS   to: \"%s\"\n", this, fileString.get()));
 43113: }
 43113: 
 43113: // Convert a unix-style dirspec to VMS format
 43113: // /foo/fred/barney/rubble -> foo:[fred.barney.rubble]
 43113: // /foo/fred -> foo:[fred]
 43113: // /foo -> foo:[000000]
 43113: // (null) -> (null)
 43113: void
 43113: nsFtpState::ConvertDirspecToVMS(nsCString& dirSpec)
 43113: {
 43113:     LOG(("FTP:(%x) ConvertDirspecToVMS from: \"%s\"\n", this, dirSpec.get()));
 43113:     if (!dirSpec.IsEmpty()) {
 43113:         if (dirSpec.Last() != '/')
 43113:             dirSpec.Append('/');
 43113:         // we can use the filespec routine if we make it look like a file name
 43113:         dirSpec.Append('x');
 43113:         ConvertFilespecToVMS(dirSpec);
 43113:         dirSpec.Truncate(dirSpec.Length()-1);
 43113:     }
 43113:     LOG(("FTP:(%x) ConvertDirspecToVMS   to: \"%s\"\n", this, dirSpec.get()));
 43113: }
 43113: 
 43113: // Convert an absolute VMS style dirspec to UNIX format
 43113: void
 43113: nsFtpState::ConvertDirspecFromVMS(nsCString& dirSpec)
 43113: {
 43113:     LOG(("FTP:(%x) ConvertDirspecFromVMS from: \"%s\"\n", this, dirSpec.get()));
 43113:     if (dirSpec.IsEmpty()) {
 43113:         dirSpec.Insert('.', 0);
 43113:     } else {
 43113:         dirSpec.Insert('/', 0);
 43113:         dirSpec.ReplaceSubstring(":[", "/");
 43113:         dirSpec.ReplaceChar('.', '/');
 43113:         dirSpec.ReplaceChar(']', '/');
 43113:     }
 43113:     LOG(("FTP:(%x) ConvertDirspecFromVMS   to: \"%s\"\n", this, dirSpec.get()));
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsFtpState::OnTransportStatus(nsITransport *transport, nsresult status,
108991:                               uint64_t progress, uint64_t progressMax)
 43113: {
 43113:     // Mix signals from both the control and data connections.
 43113: 
 43113:     // Ignore data transfer events on the control connection.
 43113:     if (mControlConnection && transport == mControlConnection->Transport()) {
 43113:         switch (status) {
 43113:         case NS_NET_STATUS_RESOLVING_HOST:
 70188:         case NS_NET_STATUS_RESOLVED_HOST:
 43113:         case NS_NET_STATUS_CONNECTING_TO:
 43113:         case NS_NET_STATUS_CONNECTED_TO:
 43113:             break;
 43113:         default:
 43113:             return NS_OK;
 43113:         }
 43113:     }
 43113: 
 43113:     // Ignore the progressMax value from the socket.  We know the true size of
 43113:     // the file based on the response from our SIZE request. Additionally, only
 43113:     // report the max progress based on where we started/resumed.
106838:     mChannel->OnTransportStatus(nullptr, status, progress,
 43113:                                 mFileSize - mChannel->StartPos());
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: 
 43113: NS_IMETHODIMP
 43113: nsFtpState::OnCacheEntryAvailable(nsICacheEntryDescriptor *entry,
 43113:                                   nsCacheAccessMode access,
 43113:                                   nsresult status)
 43113: {
 43113:     // We may have been closed while we were waiting for this cache entry.
 43113:     if (IsClosed())
 43113:         return NS_OK;
 43113: 
 43113:     if (NS_SUCCEEDED(status) && entry) {
 80486:         mDoomCache = true;
 43113:         mCacheEntry = entry;
 43113:         if (CanReadCacheEntry() && ReadCacheEntry()) {
 43113:             mState = FTP_READ_CACHE;
 43113:             return NS_OK;
 43113:         }
 43113:     }
 43113: 
 43113:     Connect();
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 93831: nsFtpState::OnCacheEntryDoomed(nsresult status)
 93831: {
 93831:     return NS_ERROR_NOT_IMPLEMENTED;
 93831: }
 93831: 
 93831: //-----------------------------------------------------------------------------
 93831: 
 93831: NS_IMETHODIMP
 43113: nsFtpState::OnStartRequest(nsIRequest *request, nsISupports *context)
 43113: {
 80486:     mStorReplyReceived = false;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsFtpState::OnStopRequest(nsIRequest *request, nsISupports *context,
 43113:                           nsresult status)
 43113: {
106838:     mUploadRequest = nullptr;
 43113: 
 43113:     // Close() will be called when reply to STOR command is received
 43113:     // see bug #389394
 43113:     if (!mStorReplyReceived)
 43113:       return NS_OK;
 43113: 
 43113:     // We're done uploading.  Let our consumer know that we're done.
 43113:     Close();
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
108991: nsFtpState::Available(uint64_t *result)
 43113: {
 43113:     if (mDataStream)
 43113:         return mDataStream->Available(result);
 43113: 
 43113:     return nsBaseContentStream::Available(result);
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsFtpState::ReadSegments(nsWriteSegmentFun writer, void *closure,
108991:                          uint32_t count, uint32_t *result)
 43113: {
 43113:     // Insert a thunk here so that the input stream passed to the writer is this
 43113:     // input stream instead of mDataStream.
 43113: 
 43113:     if (mDataStream) {
 43113:         nsWriteSegmentThunk thunk = { this, writer, closure };
 43113:         return mDataStream->ReadSegments(NS_WriteSegmentThunk, &thunk, count,
 43113:                                          result);
 43113:     }
 43113: 
 43113:     return nsBaseContentStream::ReadSegments(writer, closure, count, result);
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsFtpState::CloseWithStatus(nsresult status)
 43113: {
 43113:     LOG(("FTP:(%p) close [%x]\n", this, status));
 43113: 
 43113:     // Shutdown the control connection processing if we are being closed with an
 43113:     // error.  Note: This method may be called several times.
 43113:     if (!IsClosed() && status != NS_BASE_STREAM_CLOSED && NS_FAILED(status)) {
 43113:         if (NS_SUCCEEDED(mInternalError))
 43113:             mInternalError = status;
 43113:         StopProcessing();
 43113:     }
 43113: 
 43113:     if (mUploadRequest) {
 43113:         mUploadRequest->Cancel(NS_ERROR_ABORT);
106838:         mUploadRequest = nullptr;
 43113:     }
 43113: 
 43113:     if (mDataTransport) {
 43113:         // Shutdown the data transport.
 43113:         mDataTransport->Close(NS_ERROR_ABORT);
106838:         mDataTransport = nullptr;
 43113:     }
 43113: 
106838:     mDataStream = nullptr;
 43113:     if (mDoomCache && mCacheEntry)
114159:         mCacheEntry->AsyncDoom(nullptr);
106838:     mCacheEntry = nullptr;
 43113: 
 43113:     return nsBaseContentStream::CloseWithStatus(status);
 43113: }
 43113: 
115189: static nsresult
115189: CreateHTTPProxiedChannel(nsIURI *uri, nsIProxyInfo *pi, nsIChannel **newChannel)
115189: {
115189:     nsresult rv;
115189:     nsCOMPtr<nsIIOService> ioService = do_GetIOService(&rv);
115189:     if (NS_FAILED(rv))
115189:         return rv;
115189: 
115189:     nsCOMPtr<nsIProtocolHandler> handler;
115189:     rv = ioService->GetProtocolHandler("http", getter_AddRefs(handler));
115189:     if (NS_FAILED(rv))
115189:         return rv;
115189: 
115189:     nsCOMPtr<nsIProxiedProtocolHandler> pph = do_QueryInterface(handler, &rv);
115189:     if (NS_FAILED(rv))
115189:         return rv;
115189: 
115189:     return pph->NewProxiedChannel(uri, pi, 0, nullptr, newChannel);
115189: }
115189: 
115189: NS_IMETHODIMP
115189: nsFtpState::OnProxyAvailable(nsICancelable *request, nsIURI *uri,
115189:                              nsIProxyInfo *pi, nsresult status)
115189: {
115189:   mProxyRequest = nullptr;
115189: 
115189:   // failed status code just implies DIRECT processing
115189: 
115189:   if (NS_SUCCEEDED(status)) {
115189:     nsAutoCString type;
115189:     if (pi && NS_SUCCEEDED(pi->GetType(type)) && type.EqualsLiteral("http")) {
115189:         // Proxy the FTP url via HTTP
115189:         // This would have been easier to just return a HTTP channel directly
115189:         // from nsIIOService::NewChannelFromURI(), but the proxy type cannot
115189:         // be reliabliy determined synchronously without jank due to pac, etc..
115189:         LOG(("FTP:(%p) Configured to use a HTTP proxy channel\n", this));
115189: 
115189:         nsCOMPtr<nsIChannel> newChannel;
115189:         if (NS_SUCCEEDED(CreateHTTPProxiedChannel(uri, pi,
115189:                                                   getter_AddRefs(newChannel))) &&
115189:             NS_SUCCEEDED(mChannel->Redirect(newChannel,
115189:                                             nsIChannelEventSink::REDIRECT_INTERNAL,
115189:                                             true))) {
115189:             LOG(("FTP:(%p) Redirected to use a HTTP proxy channel\n", this));
115189:             return NS_OK;
115189:         }
115189:     }
115189:     else if (pi) {
115189:         // Proxy using the FTP protocol routed through a socks proxy
115189:         LOG(("FTP:(%p) Configured to use a SOCKS proxy channel\n", this));
115189:         mChannel->SetProxyInfo(pi);
115189:     }
115189:   }
115189: 
115189:   if (mDeferredCallbackPending) {
115189:       mDeferredCallbackPending = false;
115189:       OnCallbackPending();
115189:   }
115189:   return NS_OK;
115189: }
115189: 
 43113: void
 43113: nsFtpState::OnCallbackPending()
 43113: {
 43113:     // If this is the first call, then see if we could use the cache.  If we
 43113:     // aren't going to read from (or write to) the cache, then just proceed to
 43113:     // connect to the server.
 43113: 
 43113:     if (mState == FTP_INIT) {
115189:         if (mProxyRequest) {
115189:             mDeferredCallbackPending = true;
115189:             return;
115189:         }
115189: 
 43113:         if (CheckCache()) {
 43113:             mState = FTP_WAIT_CACHE;
 43113:             return;
 43113:         } 
 43113:         if (mCacheEntry && CanReadCacheEntry() && ReadCacheEntry()) {
 43113:             mState = FTP_READ_CACHE;
 43113:             return;
 43113:         }
 43113:         Connect();
 43113:     } else if (mDataStream) {
 43113:         mDataStream->AsyncWait(this, 0, 0, CallbackTarget());
 43113:     }
 43113: }
 43113: 
 79445: bool
 43113: nsFtpState::ReadCacheEntry()
 43113: {
 43113:     NS_ASSERTION(mCacheEntry, "should have a cache entry");
 43113: 
 43113:     // make sure the channel knows wassup
 43113:     SetContentType();
 43113: 
 43113:     nsXPIDLCString serverType;
 43113:     mCacheEntry->GetMetaDataElement("servertype", getter_Copies(serverType));
110974:     nsAutoCString serverNum(serverType.get());
106878:     nsresult err;
 43113:     mServerType = serverNum.ToInteger(&err);
 43113:     
 43113:     mChannel->PushStreamConverter("text/ftp-dir",
 43113:                                   APPLICATION_HTTP_INDEX_FORMAT);
 43113:     
 43113:     mChannel->SetEntityID(EmptyCString());
 43113: 
 43113:     if (NS_FAILED(OpenCacheDataStream()))
 80486:         return false;
 43113: 
 43113:     if (HasPendingCallback())
 43113:         mDataStream->AsyncWait(this, 0, 0, CallbackTarget());
 43113: 
 80486:     mDoomCache = false;
 80486:     return true;
 43113: }
 43113: 
 79445: bool
 43113: nsFtpState::CheckCache()
 43113: {
 43113:     // This function is responsible for setting mCacheEntry if there is a cache
 43113:     // entry that we can use.  It returns true if we end up waiting for access
 43113:     // to the cache.
 43113: 
 43113:     // In some cases, we don't want to use the cache:
 43113:     if (mChannel->UploadStream() || mChannel->ResumeRequested())
 80486:         return false;
 43113: 
 43113:     nsCOMPtr<nsICacheService> cache = do_GetService(NS_CACHESERVICE_CONTRACTID);
 43113:     if (!cache)
 80486:         return false;
 43113: 
106076:     bool isPrivate = NS_UsePrivateBrowsing(mChannel);
 99370:     const char* sessionName = isPrivate ? "FTP-private" : "FTP";
 99370:     nsCacheStoragePolicy policy =
 99370:         isPrivate ? nsICache::STORE_IN_MEMORY : nsICache::STORE_ANYWHERE;
 43113:     nsCOMPtr<nsICacheSession> session;
 99370:     cache->CreateSession(sessionName,
 99370:                          policy,
 43113:                          nsICache::STREAM_BASED,
 43113:                          getter_AddRefs(session));
 43113:     if (!session)
 80486:         return false;
 80486:     session->SetDoomEntriesIfExpired(false);
 99370:     session->SetIsPrivate(isPrivate);
 43113: 
 43113:     // Set cache access requested:
 43113:     nsCacheAccessMode accessReq;
 43113:     if (NS_IsOffline()) {
 43113:         accessReq = nsICache::ACCESS_READ; // can only read
 43113:     } else if (mChannel->HasLoadFlag(nsIRequest::LOAD_BYPASS_CACHE)) {
 43113:         accessReq = nsICache::ACCESS_WRITE; // replace cache entry
 43113:     } else {
 43113:         accessReq = nsICache::ACCESS_READ_WRITE; // normal browsing
 43113:     }
 43113: 
 43113:     // Check to see if we are not allowed to write to the cache:
 43113:     if (mChannel->HasLoadFlag(nsIRequest::INHIBIT_CACHING)) {
 43113:         accessReq &= ~nsICache::ACCESS_WRITE;
 43113:         if (accessReq == nsICache::ACCESS_NONE)
 80486:             return false;
 43113:     }
 43113: 
 43113:     // Generate cache key (remove trailing #ref if any):
110974:     nsAutoCString key;
 43113:     mChannel->URI()->GetAsciiSpec(key);
108991:     int32_t pos = key.RFindChar('#');
 43113:     if (pos != kNotFound)
 43113:         key.Truncate(pos);
 80486:     NS_ENSURE_FALSE(key.IsEmpty(), false);
 43113: 
114262:     nsresult rv = session->AsyncOpenCacheEntry(key, accessReq, this, false);
114262:     return NS_SUCCEEDED(rv);
 43113: 
 43113: }
 43113: 
 43113: nsresult
 43113: nsFtpState::ConvertUTF8PathToCharset(const nsACString &aCharset)
 43113: {
 43113:     nsresult rv;
 43113:     NS_ASSERTION(IsUTF8(mPath), "mPath isn't UTF8 string!");
 43113:     NS_ConvertUTF8toUTF16 ucsPath(mPath);
110974:     nsAutoCString result;
 43113: 
 43113:     nsCOMPtr<nsICharsetConverterManager> charsetMgr(
 43113:         do_GetService("@mozilla.org/charset-converter-manager;1", &rv));
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:     nsCOMPtr<nsIUnicodeEncoder> encoder;
 43113:     rv = charsetMgr->GetUnicodeEncoder(PromiseFlatCString(aCharset).get(),
 43113:                                        getter_AddRefs(encoder));
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
108991:     int32_t len = ucsPath.Length();
108991:     int32_t maxlen;
 43113: 
 43113:     rv = encoder->GetMaxLength(ucsPath.get(), len, &maxlen);
 43113:     NS_ENSURE_SUCCESS(rv, rv);
 43113: 
 43113:     char buf[256], *p = buf;
108991:     if (uint32_t(maxlen) > sizeof(buf) - 1) {
 43113:         p = (char *) malloc(maxlen + 1);
 43113:         if (!p)
 43113:             return NS_ERROR_OUT_OF_MEMORY;
 43113:     }
 43113: 
 43113:     rv = encoder->Convert(ucsPath.get(), &len, p, &maxlen);
 43113:     if (NS_FAILED(rv))
 43113:         goto end;
 43113:     if (rv == NS_ERROR_UENC_NOMAPPING) {
 43113:         NS_WARNING("unicode conversion failed");
 43113:         rv = NS_ERROR_UNEXPECTED;
 43113:         goto end;
 43113:     }
 43113:     p[maxlen] = 0;
 43113:     result.Assign(p);
 43113: 
 43113:     len = sizeof(buf) - 1;
 43113:     rv = encoder->Finish(buf, &len);
 43113:     if (NS_FAILED(rv))
 43113:         goto end;
 43113:     buf[len] = 0;
 43113:     result.Append(buf);
 43113:     mPath = result;
 43113: 
 43113: end:
 43113:     if (p != buf)
 43113:         free(p);
 43113:     return rv;
 43113: }
