 72084: /* -*- Mode: c++; c-basic-offset: 4; tab-width: 40; indent-tabs-mode: nil -*- */
 72084: /* vim: set ts=40 sw=4 et tw=99: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 72084: 
 72084: #ifndef jstypedarrayinlines_h
 72084: #define jstypedarrayinlines_h
 72084: 
 72084: #include "jsapi.h"
 72084: #include "jsobj.h"
 97574: #include "jstypedarray.h"
 97574: 
 97574: #include "jsobjinlines.h"
 72084: 
110924: inline void
110924: js::ArrayBufferObject::setElementsHeader(js::ObjectElements *header, uint32_t bytes)
110924: {
110924:     /*
110924:      * Note that |bytes| may not be a multiple of |sizeof(Value)|, so
110924:      * |capacity * sizeof(Value)| may underestimate the size by up to
110924:      * |sizeof(Value) - 1| bytes.
110924:      */
110924:     header->capacity = bytes / sizeof(js::Value);
110924:     header->initializedLength = bytes;
110924:     header->length = 0;
110924:     header->unused = 0;
110924: }
110924: 
 84755: inline uint32_t
 96828: js::ArrayBufferObject::byteLength() const
 72084: {
 77427:     JS_ASSERT(isArrayBuffer());
110924:     return getElementsHeader()->initializedLength;
 72084: }
 72084: 
 84755: inline uint8_t *
 96828: js::ArrayBufferObject::dataPointer() const
 77343: {
 84755:     return (uint8_t *) elements;
 72084: }
 74875: 
 96828: inline js::ArrayBufferObject &
 96828: JSObject::asArrayBuffer()
 96828: {
 96828:     JS_ASSERT(isArrayBuffer());
 96828:     return *static_cast<js::ArrayBufferObject *>(this);
 96828: }
 96828: 
 97574: inline js::DataViewObject &
 97574: JSObject::asDataView()
 97574: {
 97574:     JS_ASSERT(isDataView());
 97574:     return *static_cast<js::DataViewObject *>(this);
 97574: }
 97574: 
 77427: namespace js {
 77427: 
 96828: inline bool
 96828: ArrayBufferObject::hasData() const
 96828: {
 96828:     return getClass() == &ArrayBufferClass;
 96828: }
 96828: 
 84755: static inline int32_t
 84755: ClampIntForUint8Array(int32_t x)
 77344: {
 77344:     if (x < 0)
 77344:         return 0;
 77344:     if (x > 255)
 77344:         return 255;
 77344:     return x;
 74875: }
 74875: 
103107: inline Value
105479: TypedArray::lengthValue(JSObject *obj)
105479: {
 97573:     JS_ASSERT(obj->isTypedArray());
103107:     return obj->getFixedSlot(FIELD_LENGTH);
 74875: }
 74875: 
 84755: inline uint32_t
105479: TypedArray::length(JSObject *obj)
105479: {
103107:     return lengthValue(obj).toInt32();
103107: }
103107: 
103107: inline Value
105479: TypedArray::byteOffsetValue(JSObject *obj)
105479: {
 97573:     JS_ASSERT(obj->isTypedArray());
103107:     return obj->getFixedSlot(FIELD_BYTEOFFSET);
 74875: }
 74875: 
 84755: inline uint32_t
105479: TypedArray::byteOffset(JSObject *obj)
105479: {
103107:     return byteOffsetValue(obj).toInt32();
103107: }
103107: 
103107: inline Value
105479: TypedArray::byteLengthValue(JSObject *obj)
105479: {
 97573:     JS_ASSERT(obj->isTypedArray());
103107:     return obj->getFixedSlot(FIELD_BYTELENGTH);
 74875: }
 74875: 
 84755: inline uint32_t
105479: TypedArray::byteLength(JSObject *obj)
105479: {
103107:     return byteLengthValue(obj).toInt32();
103107: }
103107: 
103107: inline uint32_t
105479: TypedArray::type(JSObject *obj)
105479: {
 97573:     JS_ASSERT(obj->isTypedArray());
 77415:     return obj->getFixedSlot(FIELD_TYPE).toInt32();
 74875: }
 74875: 
103107: inline Value
105479: TypedArray::bufferValue(JSObject *obj)
105479: {
103107:     JS_ASSERT(obj->isTypedArray());
103107:     return obj->getFixedSlot(FIELD_BUFFER);
103107: }
103107: 
103104: inline ArrayBufferObject *
105479: TypedArray::buffer(JSObject *obj)
105479: {
103107:     return &bufferValue(obj).toObject().asArrayBuffer();
 74875: }
 74875: 
 74875: inline void *
105479: TypedArray::viewData(JSObject *obj)
105479: {
 97573:     JS_ASSERT(obj->isTypedArray());
 83233:     return (void *)obj->getPrivate(NUM_FIXED_SLOTS);
 74875: }
 77415: 
103107: inline uint32_t
103107: TypedArray::slotWidth(int atype) {
103107:     switch (atype) {
103107:     case js::TypedArray::TYPE_INT8:
103107:     case js::TypedArray::TYPE_UINT8:
103107:     case js::TypedArray::TYPE_UINT8_CLAMPED:
103107:         return 1;
103107:     case js::TypedArray::TYPE_INT16:
103107:     case js::TypedArray::TYPE_UINT16:
103107:         return 2;
103107:     case js::TypedArray::TYPE_INT32:
103107:     case js::TypedArray::TYPE_UINT32:
103107:     case js::TypedArray::TYPE_FLOAT32:
103107:         return 4;
103107:     case js::TypedArray::TYPE_FLOAT64:
103107:         return 8;
103107:     default:
103107:         JS_NOT_REACHED("invalid typed array type");
103107:         return 0;
103107:     }
103107: }
103107: 
103107: inline int
103107: TypedArray::slotWidth(JSObject *obj) {
103107:     return slotWidth(type(obj));
103107: }
103107: 
105479: bool
105479: DataViewObject::is(const Value &v)
105479: {
105479:     return v.isObject() && v.toObject().hasClass(&DataViewClass);
105479: }
105479: 
109329: #ifdef JSGC_GENERATIONAL
109329: class TypedArrayPrivateRef : public gc::BufferableRef
109329: {
109329:     JSObject *obj;
109329:     ArrayBufferObject *buffer;
109329:     size_t byteOffset;
109329: 
109329:   public:
109329:     TypedArrayPrivateRef(JSObject *obj, ArrayBufferObject *buffer, size_t byteOffset)
109329:       : obj(obj), buffer(buffer), byteOffset(byteOffset) {}
109329: 
109329:     bool match(void *location) {
109329:         // The private field  of obj is not traced, but needs to be updated by mark.
109329:         return false;
109329:     }
109329: 
109329:     void mark(JSTracer *trc) {}
109329: };
109329: #endif
109329: 
109329: static inline void
109329: InitTypedArrayDataPointer(JSObject *obj, ArrayBufferObject *buffer, size_t byteOffset)
109329: {
109329:     /*
109329:      * N.B. The base of the array's data is stored in the object's
109329:      * private data rather than a slot to avoid alignment restrictions
109329:      * on private Values.
109329:      */
109329:     obj->initPrivate(buffer->dataPointer() + byteOffset);
109329: #ifdef JSGC_GENERATIONAL
109329:     JSCompartment *comp = obj->compartment();
109329:     JS_ASSERT(comp == buffer->compartment());
109329:     if (comp->gcNursery.isInside(buffer))
109329:         comp->gcStoreBuffer.putGeneric(TypedArrayPrivateRef(obj, buffer, byteOffset));
109329: #endif
109329: }
109329: 
 97574: inline DataViewObject *
 97574: DataViewObject::create(JSContext *cx, uint32_t byteOffset, uint32_t byteLength,
107557:                        Handle<ArrayBufferObject*> arrayBuffer, JSObject *protoArg)
 97574: {
 97574:     JS_ASSERT(byteOffset <= INT32_MAX);
 97574:     JS_ASSERT(byteLength <= INT32_MAX);
 97574: 
107557:     RootedObject proto(cx, protoArg);
 99421:     RootedObject obj(cx, NewBuiltinClassInstance(cx, &DataViewClass));
 97574:     if (!obj)
 97574:         return NULL;
 97574: 
 98671:     if (proto) {
103065:         types::TypeObject *type = proto->getNewType(cx);
 98671:         if (!type)
 98671:             return NULL;
103065:         obj->setType(type);
103065:     } else if (cx->typeInferenceEnabled()) {
103065:         if (byteLength >= TypedArray::SINGLETON_TYPE_BYTE_LENGTH) {
108951:             if (!JSObject::setSingletonType(cx, obj))
103065:                 return NULL;
103065:         } else {
103065:             jsbytecode *pc;
103320:             RootedScript script(cx, cx->stack.currentScript(&pc));
103065:             if (script) {
103065:                 if (!types::SetInitializerObjectType(cx, script, pc, obj))
103065:                     return NULL;
103037:             }
103065:         }
103065:     }
 98671: 
 97574:     JS_ASSERT(arrayBuffer->isArrayBuffer());
 97574: 
 97574:     DataViewObject &dvobj = obj->asDataView();
 97574:     dvobj.setFixedSlot(BYTEOFFSET_SLOT, Int32Value(byteOffset));
 97574:     dvobj.setFixedSlot(BYTELENGTH_SLOT, Int32Value(byteLength));
 97574:     dvobj.setFixedSlot(BUFFER_SLOT, ObjectValue(*arrayBuffer));
110924:     dvobj.setFixedSlot(NEXT_VIEW_SLOT, NullValue());
109329:     InitTypedArrayDataPointer(obj, arrayBuffer, byteOffset);
 98329:     JS_ASSERT(byteOffset + byteLength <= arrayBuffer->byteLength());
 97574: 
 97574:     JS_ASSERT(dvobj.numFixedSlots() == RESERVED_SLOTS);
 97574: 
111282:     arrayBuffer->asArrayBuffer().addView(cx, &dvobj);
111282: 
 97574:     return &dvobj;
 97574: }
 97574: 
 97574: inline uint32_t
 97574: DataViewObject::byteLength()
 97574: {
 97574:     JS_ASSERT(isDataView());
 97574:     int32_t length = getReservedSlot(BYTELENGTH_SLOT).toInt32();
 97574:     JS_ASSERT(length >= 0);
 97574:     return static_cast<uint32_t>(length);
 97574: }
 97574: 
 97574: inline uint32_t
 97574: DataViewObject::byteOffset()
 97574: {
 97574:     JS_ASSERT(isDataView());
 97574:     int32_t offset = getReservedSlot(BYTEOFFSET_SLOT).toInt32();
 97574:     JS_ASSERT(offset >= 0);
 97574:     return static_cast<uint32_t>(offset);
 97574: }
 97574: 
 97574: inline void *
 97574: DataViewObject::dataPointer()
 97574: {
 97574:     JS_ASSERT(isDataView());
 97574:     return getPrivate();
 97574: }
 97574: 
110924: inline ArrayBufferObject &
 97574: DataViewObject::arrayBuffer()
 97574: {
 97574:     JS_ASSERT(isDataView());
110924:     return getReservedSlot(BUFFER_SLOT).toObject().asArrayBuffer();
 97574: }
 97574: 
 97574: inline bool
 97574: DataViewObject::hasBuffer() const
 97574: {
 97574:     JS_ASSERT(isDataView());
 97574:     return getReservedSlot(BUFFER_SLOT).isObject();
 97574: }
 97574: 
103107: inline Value
103107: DataViewObject::bufferValue(DataViewObject &view)
103107: {
103107:     return view.hasBuffer() ? ObjectValue(view.arrayBuffer()) : UndefinedValue();
103107: }
103107: 
103107: inline Value
103107: DataViewObject::byteOffsetValue(DataViewObject &view)
103107: {
103107:     return Int32Value(view.byteOffset());
103107: }
103107: 
103107: inline Value
103107: DataViewObject::byteLengthValue(DataViewObject &view)
103107: {
103107:     return Int32Value(view.byteLength());
103107: }
103107: 
 96828: } /* namespace js */
 96828: 
 72084: #endif /* jstypedarrayinlines_h */
