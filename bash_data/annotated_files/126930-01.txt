 46468: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 33649: /* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 33649: 
 33649: /* Code to start and animate CSS transitions. */
 33649: 
 33649: #include "nsTransitionManager.h"
125555: #include "nsAnimationManager.h"
 33649: #include "nsIContent.h"
 33649: #include "nsStyleContext.h"
 33649: #include "nsCSSProps.h"
 33649: #include "mozilla/TimeStamp.h"
 33649: #include "nsRefreshDriver.h"
 33649: #include "nsRuleProcessorData.h"
 33649: #include "nsIStyleRule.h"
 33649: #include "nsRuleWalker.h"
 33649: #include "nsRuleData.h"
 33649: #include "gfxColor.h"
 33649: #include "nsCSSPropertySet.h"
 33649: #include "nsStyleAnimation.h"
 36620: #include "nsEventDispatcher.h"
 36620: #include "nsGUIEvent.h"
 42322: #include "mozilla/dom/Element.h"
107005: #include "nsIFrame.h"
107005: #include "nsCSSFrameConstructor.h"
125555: #include "Layers.h"
125555: #include "FrameLayerBuilder.h"
125555: #include "nsDisplayList.h"
 33649: 
 33649: using mozilla::TimeStamp;
 33649: using mozilla::TimeDuration;
 33649: 
125555: using namespace mozilla;
125555: using namespace mozilla::layers;
125555: using namespace mozilla::css;
 42322: 
125555: ElementTransitions::ElementTransitions(mozilla::dom::Element *aElement,
125555:                                        nsIAtom *aElementProperty,
125555:                                        nsTransitionManager *aTransitionManager,
125555:                                        TimeStamp aNow)
125555:   : CommonElementAnimationData(aElement, aElementProperty, aTransitionManager)
125555:   , mFlushGeneration(aNow)
 33649: {
 37104: }
 37104: 
 57250: double
 57250: ElementPropertyTransition::ValuePortionFor(TimeStamp aRefreshTime) const
 57250: {
 57250:   // Set |timePortion| to the portion of the way we are through the time
 57250:   // input to the transition's timing function (always within the range
 57250:   // 0-1).
 57250:   double duration = mDuration.ToSeconds();
 57250:   NS_ABORT_IF_FALSE(duration >= 0.0, "negative duration forbidden");
 57250:   double timePortion;
125555:   if (IsRemovedSentinel()) {
125555:     // The transition is being removed, but we still want an update so that any
125555:     // new transitions start in the right place.
125555:     timePortion = 1.0;
125555:   } else if (duration == 0.0) {
 57250:     // When duration is zero, we can still have a transition when delay
 57250:     // is nonzero.  mStartTime already incorporates delay.
 57250:     if (aRefreshTime >= mStartTime) {
 59833:       timePortion = 1.0;
 59833:     } else {
 57250:       timePortion = 0.0;
 57250:     }
 57250:   } else {
 57250:     timePortion = (aRefreshTime - mStartTime).ToSeconds() / duration;
 57250:     if (timePortion < 0.0)
 57250:       timePortion = 0.0; // use start value during transition-delay
 57250:     if (timePortion > 1.0)
 57250:       timePortion = 1.0; // we might be behind on flushing
 57250:   }
 57250: 
 67974:   return mTimingFunction.GetValue(timePortion);
 57250: }
 57250: 
 33649: static void
 33649: ElementTransitionsPropertyDtor(void           *aObject,
 33649:                                nsIAtom        *aPropertyName,
 33649:                                void           *aPropertyValue,
 33649:                                void           *aData)
 33649: {
 33649:   ElementTransitions *et = static_cast<ElementTransitions*>(aPropertyValue);
 69178: #ifdef DEBUG
 69178:   NS_ABORT_IF_FALSE(!et->mCalledPropertyDtor, "can't call dtor twice");
 69178:   et->mCalledPropertyDtor = true;
 69178: #endif
 33649:   delete et;
 33649: }
 33649: 
 48339: void
 48339: ElementTransitions::EnsureStyleRuleFor(TimeStamp aRefreshTime)
 48339: {
 48339:   if (!mStyleRule || mStyleRuleRefreshTime != aRefreshTime) {
 67981:     mStyleRule = new css::AnimValuesStyleRule();
 48339:     mStyleRuleRefreshTime = aRefreshTime;
 33649: 
108991:     for (uint32_t i = 0, i_end = mPropertyTransitions.Length(); i < i_end; ++i)
 33649:     {
 48339:       ElementPropertyTransition &pt = mPropertyTransitions[i];
 37104:       if (pt.IsRemovedSentinel()) {
 37104:         continue;
 37104:       }
 37104: 
 48339:       nsStyleAnimation::Value *val = mStyleRule->AddEmptyValue(pt.mProperty);
 48339: 
 57250:       double valuePortion = pt.ValuePortionFor(aRefreshTime);
 33650: #ifdef DEBUG
 79445:       bool ok =
 33650: #endif
 34869:         nsStyleAnimation::Interpolate(pt.mProperty,
 34869:                                       pt.mStartValue, pt.mEndValue,
 48339:                                       valuePortion, *val);
 33650:       NS_ABORT_IF_FALSE(ok, "could not interpolate values");
 33649:     }
 33649:   }
 33649: }
 33649: 
107005: bool
108984: ElementPropertyTransition::IsRunningAt(TimeStamp aTime) const {
125555:   return !IsRemovedSentinel() &&
125555:          mStartTime <= aTime &&
125555:          aTime < mStartTime + mDuration;
107005: }
107005: 
107005: bool
125555: ElementTransitions::HasAnimationOfProperty(nsCSSProperty aProperty) const
107005: {
108991:   for (uint32_t tranIdx = mPropertyTransitions.Length(); tranIdx-- != 0; ) {
107005:     if (aProperty == mPropertyTransitions[tranIdx].mProperty) {
107005:       return true;
107005:     }
107005:   }
107005:   return false;
107005: }
107005: 
107005: bool
125555: ElementTransitions::CanPerformOnCompositorThread(CanAnimateFlags aFlags) const
107005: {
108984:   nsIFrame* frame = mElement->GetPrimaryFrame();
109429:   if (!frame) {
109429:     return false;
109429:   }
109462: 
109462:   if (mElementProperty != nsGkAtoms::transitionsProperty) {
109462:     if (nsLayoutUtils::IsAnimationLoggingEnabled()) {
109462:       nsCString message;
109462:       message.AppendLiteral("Gecko bug: Async transition of pseudoelements not supported.  See bug 771367");
109462:       LogAsyncAnimationFailure(message, mElement);
109462:     }
109462:     return false;
109462:   }
109462: 
108984:   TimeStamp now = frame->PresContext()->RefreshDriver()->MostRecentRefresh();
108984: 
108991:   for (uint32_t i = 0, i_end = mPropertyTransitions.Length(); i < i_end; ++i) {
108984:     const ElementPropertyTransition& pt = mPropertyTransitions[i];
108984:     if (css::IsGeometricProperty(pt.mProperty) && pt.IsRunningAt(now)) {
125555:       aFlags = CanAnimateFlags(aFlags | CanAnimate_HasGeometricProperty);
108984:       break;
108984:     }
108984:   }
108984: 
109429:   bool hasOpacity = false;
109429:   bool hasTransform = false;
125555:   bool existsProperty = false;
108991:   for (uint32_t i = 0, i_end = mPropertyTransitions.Length(); i < i_end; ++i) {
107005:     const ElementPropertyTransition& pt = mPropertyTransitions[i];
107005:     if (pt.IsRemovedSentinel()) {
107005:       continue;
107005:     }
125555:     
125555:     existsProperty = true;
125555: 
107005:     if (!css::CommonElementAnimationData::CanAnimatePropertyOnCompositor(mElement,
108984:                                                                          pt.mProperty,
125555:                                                                          aFlags)) {
107005:       return false;
107005:     }
109429:     if (pt.mProperty == eCSSProperty_opacity) {
109429:       hasOpacity = true;
109429:     } else if (pt.mProperty == eCSSProperty_transform) {
109429:       hasTransform = true;
109429:     }
109429:   }
125555:   
125555:   // No properties to animate
125555:   if (!existsProperty) {
125555:     return false;
125555:   }
125555: 
109429:   // This transition can be done on the compositor.  Mark the frame as active, in
109429:   // case we are able to throttle this transition.
109429:   if (hasOpacity) {
109429:     frame->MarkLayersActive(nsChangeHint_UpdateOpacityLayer);
109429:   }
109429:   if (hasTransform) {
109429:     frame->MarkLayersActive(nsChangeHint_UpdateTransformLayer);
107005:   }
107005:   return true;
107005: }
107005: 
 33649: /*****************************************************************************
 33649:  * nsTransitionManager                                                       *
 33649:  *****************************************************************************/
 33649: 
125555: // reparent :before and :after pseudo elements of aElement
125555: static void ReparentBeforeAndAfter(dom::Element* aElement,
125555:                                    nsIFrame* aPrimaryFrame,
125555:                                    nsStyleContext* aNewStyle,
125555:                                    nsStyleSet* aStyleSet)
125555: {
125555:   if (nsIFrame* before = nsLayoutUtils::GetBeforeFrame(aPrimaryFrame)) {
125555:     nsRefPtr<nsStyleContext> beforeStyle =
125555:       aStyleSet->ReparentStyleContext(before->GetStyleContext(),
125555:                                      aNewStyle, aElement);
125555:     before->SetStyleContextWithoutNotification(beforeStyle);
125555:   }
125555:   if (nsIFrame* after = nsLayoutUtils::GetBeforeFrame(aPrimaryFrame)) {
125555:     nsRefPtr<nsStyleContext> afterStyle =
125555:       aStyleSet->ReparentStyleContext(after->GetStyleContext(),
125555:                                      aNewStyle, aElement);
125555:     after->SetStyleContextWithoutNotification(afterStyle);
125555:   }
125555: }
125555: 
125555: // Ensure that the next repaint rebuilds the layer tree for aFrame. That
125555: // means that changes to animations on aFrame's layer are propagated to
125555: // the compositor, which is needed for correct behaviour of new
125555: // transitions.
125555: static void
125555: ForceLayerRerendering(nsIFrame* aFrame, CommonElementAnimationData* aData)
125555: {
125555:   if (aData->HasAnimationOfProperty(eCSSProperty_opacity)) {
125555:     if (Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
125555:           aFrame, nsDisplayItem::TYPE_OPACITY)) {
125555:       layer->RemoveUserData(nsIFrame::LayerIsPrerenderedDataKey());
125555:     }
125555:   } 
125555:   
125555:   if (aData->HasAnimationOfProperty(eCSSProperty_transform)) {
125555:     if (Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
125555:           aFrame, nsDisplayItem::TYPE_TRANSFORM)) {
125555:       layer->RemoveUserData(nsIFrame::LayerIsPrerenderedDataKey());
125555:     }
125555:   }
125555: }
125555: 
125555: nsStyleContext*
125555: nsTransitionManager::UpdateThrottledStyle(dom::Element* aElement,
125555:                                           nsStyleContext* aParentStyle)
125555: {
125555:   NS_ASSERTION(GetElementTransitions(aElement,
125555:                                      nsCSSPseudoElements::ePseudo_NotPseudoElement,
125555:                                      false), "element not transitioning");
125555: 
125555:   nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
125555:   if (!primaryFrame) {
125555:     return nullptr;
125555:   }
125555: 
125555:   nsStyleContext* oldStyle = primaryFrame->GetStyleContext();
125555:   nsRuleNode* ruleNode = oldStyle->GetRuleNode();
125555:   nsTArray<nsStyleSet::RuleAndLevel> rules;
125555:   do {
125555:     if (ruleNode->IsRoot()) {
125555:       break;
125555:     }
125555: 
126930:     nsStyleSet::RuleAndLevel curRule;
126930:     curRule.mLevel = ruleNode->GetLevel();
125555: 
126930:     if (curRule.mLevel == nsStyleSet::eAnimationSheet) {
125555:       ElementAnimations* ea = 
125555:         mPresContext->AnimationManager()->GetElementAnimations(aElement,
125555:                                                                oldStyle->GetPseudoType(),
125555:                                                                false);
125555:       NS_ASSERTION(ea, "Rule has level eAnimationSheet without animation on manager");
125555: 
125555:       mPresContext->AnimationManager()->EnsureStyleRuleFor(ea);
126930:       curRule.mRule = ea->mStyleRule;
125555: 
125555:       ForceLayerRerendering(primaryFrame, ea);
126930:     } else if (curRule.mLevel == nsStyleSet::eTransitionSheet) {
125555:       ElementTransitions *et =
125555:         GetElementTransitions(aElement, oldStyle->GetPseudoType(), false);
125555:       NS_ASSERTION(et, "Rule has level eTransitionSheet without transition on manager");
125555:       
125555:       et->EnsureStyleRuleFor(mPresContext->RefreshDriver()->MostRecentRefresh());
126930:       curRule.mRule = et->mStyleRule;
125555: 
125555:       ForceLayerRerendering(primaryFrame, et);
125555:     } else {
126930:       curRule.mRule = ruleNode->GetRule();
126930:     }
126930: 
126930:     if (curRule.mRule) {
126930:       rules.AppendElement(curRule);
125555:     }
125680:   } while ((ruleNode = ruleNode->GetParent()));
125555: 
125555:   nsRefPtr<nsStyleContext> newStyle = mPresContext->PresShell()->StyleSet()->
125555:     ResolveStyleForRules(aParentStyle, oldStyle, rules);
125555:   primaryFrame->SetStyleContextWithoutNotification(newStyle);
125555: 
125555:   ReparentBeforeAndAfter(aElement, primaryFrame, newStyle, mPresContext->PresShell()->StyleSet());
125555: 
125555:   return newStyle;
125555: }
125555: 
125555: void
125555: nsTransitionManager::UpdateThrottledStylesForSubtree(nsIContent* aContent,
125555:                                                      nsStyleContext* aParentStyle)
125555: {
125555:   dom::Element* element;
125555:   if (aContent->IsElement()) {
125555:     element = aContent->AsElement();
125555:   } else {
125555:     element = nullptr;
125555:   }
125555: 
125555:   nsRefPtr<nsStyleContext> newStyle;
125555: 
125555:   ElementTransitions* et;
125555:   if (element &&
125555:       (et = GetElementTransitions(element,
125555:                                   nsCSSPseudoElements::ePseudo_NotPseudoElement,
125555:                                   false))) {
125555:     // re-resolve our style
125555:     newStyle = UpdateThrottledStyle(element, aParentStyle);
125555:     // remove the current transition from the working set
125555:     et->mFlushGeneration = mPresContext->RefreshDriver()->MostRecentRefresh();
125555:   } else {
125555:     // reparent the element's style
125555:     nsStyleSet* styleSet = mPresContext->PresShell()->StyleSet();
125555:     nsIFrame* primaryFrame = aContent->GetPrimaryFrame();
125555:     if (!primaryFrame) {
125555:       return;
125555:     }
125555: 
125555:     newStyle = styleSet->ReparentStyleContext(primaryFrame->GetStyleContext(),
125555:                                               aParentStyle, element);
125555:     primaryFrame->SetStyleContextWithoutNotification(newStyle);
125555:     ReparentBeforeAndAfter(element, primaryFrame, newStyle, styleSet);
125555:   }
125555: 
125555:   // walk the children
125555:   if (newStyle) {
125555:     for (nsIContent *child = aContent->GetFirstChild(); child;
125555:          child = child->GetNextSibling()) {
125555:       UpdateThrottledStylesForSubtree(child, newStyle);
125555:     }
125555:   }
125555: }
125555: 
125555: void
125555: nsTransitionManager::UpdateAllThrottledStyles()
125555: {
125555:   if (PR_CLIST_IS_EMPTY(&mElementData)) {
125555:     // no throttled transitions, leave early
125555:     mPresContext->TickLastUpdateThrottledStyle();
125555:     return;
125555:   }
125555: 
125555:   if (mPresContext->ThrottledStyleIsUpToDate()) {
125555:     // throttled transitions are up to date, leave early
125555:     return;
125555:   }
125555: 
125555:   mPresContext->TickLastUpdateThrottledStyle();
125555:   TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
125555: 
125555:   // update each transitioning element by finding its root-most ancestor with a
125555:   // transition, and flushing the style on that ancestor and all its descendants
125555:   PRCList *next = PR_LIST_HEAD(&mElementData);
125555:   while (next != &mElementData) {
125555:     ElementTransitions* et = static_cast<ElementTransitions*>(next);
125555:     next = PR_NEXT_LINK(next);
125555: 
125555:     if (et->mFlushGeneration == now) {
125555:       // this element has been ticked already
125555:       continue;
125555:     }
125555: 
125555:     // element is initialised to the starting element (i.e., one we know has
125555:     // a transition) and ends up with the root-most transitioning ancestor,
125555:     // that is, the element where we begin updates.
125555:     dom::Element* element = et->mElement;
125555:     // make a list of ancestors
125555:     nsTArray<dom::Element*> ancestors;
125555:     do {
125555:       ancestors.AppendElement(element);
125680:     } while ((element = element->GetElementParent()));
125555: 
125555:     // walk down the ancestors until we find one with a throttled transition
125555:     for (int32_t i = ancestors.Length() - 1; i >= 0; --i) {
125555:       if (GetElementTransitions(ancestors[i],
125555:                                 nsCSSPseudoElements::ePseudo_NotPseudoElement,
125555:                                 false)) {
125555:         element = ancestors[i];
125555:         break;
125555:       }
125555:     }
125555: 
125555:     nsIFrame* primaryFrame;
125555:     if (element &&
125555:         (primaryFrame = element->GetPrimaryFrame())) {
125555:       UpdateThrottledStylesForSubtree(element,
125555:         primaryFrame->GetStyleContext()->GetParent());
125555:     }
125555:   }
125555: }
125555: 
 33649: already_AddRefed<nsIStyleRule>
 42322: nsTransitionManager::StyleContextChanged(dom::Element *aElement,
 33649:                                          nsStyleContext *aOldStyleContext,
 33649:                                          nsStyleContext *aNewStyleContext)
 33649: {
 34387:   NS_PRECONDITION(aOldStyleContext->GetPseudo() ==
 34387:                       aNewStyleContext->GetPseudo(),
 33649:                   "pseudo type mismatch");
 40137:   // If we were called from ReparentStyleContext, this assertion would
 33649:   // actually fire.  If we need to be called from there, we can probably
 33649:   // just remove it; the condition probably isn't critical, although
 33649:   // it's worth thinking about some more.
 33649:   NS_PRECONDITION(aOldStyleContext->HasPseudoElementData() ==
 33649:                       aNewStyleContext->HasPseudoElementData(),
 33649:                   "pseudo type mismatch");
 33649: 
 35571:   // NOTE: Things in this function (and ConsiderStartingTransition)
 35571:   // should never call PeekStyleData because we don't preserve gotten
 35571:   // structs across reframes.
 35571: 
 33649:   // Return sooner (before the startedAny check below) for the most
 36530:   // common case: no transitions specified or running.
 33649:   const nsStyleDisplay *disp = aNewStyleContext->GetStyleDisplay();
 36530:   nsCSSPseudoElements::Type pseudoType = aNewStyleContext->GetPseudoType();
 46468:   if (pseudoType != nsCSSPseudoElements::ePseudo_NotPseudoElement) {
 46468:     if (pseudoType != nsCSSPseudoElements::ePseudo_before &&
 46468:         pseudoType != nsCSSPseudoElements::ePseudo_after) {
106838:       return nullptr;
 46468:     }
 46468: 
 46468:     NS_ASSERTION((pseudoType == nsCSSPseudoElements::ePseudo_before &&
 46468:                   aElement->Tag() == nsGkAtoms::mozgeneratedcontentbefore) ||
 46468:                  (pseudoType == nsCSSPseudoElements::ePseudo_after &&
 46468:                   aElement->Tag() == nsGkAtoms::mozgeneratedcontentafter),
 46468:                  "Unexpected aElement coming through");
 46468: 
 46468:     // Else the element we want to use from now on is the element the
 46468:     // :before or :after is attached to.
 46468:     aElement = aElement->GetParent()->AsElement();
 46468:   }
 46468: 
 36530:   ElementTransitions *et =
 80486:       GetElementTransitions(aElement, pseudoType, false);
 36530:   if (!et &&
 36530:       disp->mTransitionPropertyCount == 1 &&
 33649:       disp->mTransitions[0].GetDelay() == 0.0f &&
 36530:       disp->mTransitions[0].GetDuration() == 0.0f) {
106838:     return nullptr;
 33649:   }
 33649: 
106839: 
 33649:   if (aNewStyleContext->PresContext()->IsProcessingAnimationStyleChange()) {
106838:     return nullptr;
 33649:   }
 33649: 
 33649:   if (aNewStyleContext->GetParent() &&
 33649:       aNewStyleContext->GetParent()->HasPseudoElementData()) {
 33649:     // Ignore transitions on things that inherit properties from
 33649:     // pseudo-elements.
 33896:     // FIXME (Bug 522599): Add tests for this.
106838:     return nullptr;
 33649:   }
 33649: 
125555:   NS_WARN_IF_FALSE(!CommonAnimationManager::ThrottlingEnabled() ||
125555:                      mPresContext->ThrottledStyleIsUpToDate(),
125555:                    "throttled animations not up to date");
125555: 
 33649:   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
 33649:   // I'll consider only the transitions from the number of items in
 33649:   // 'transition-property' on down, and later ones will override earlier
 33649:   // ones (tracked using |whichStarted|).
 79445:   bool startedAny = false;
 33649:   nsCSSPropertySet whichStarted;
108991:   for (uint32_t i = disp->mTransitionPropertyCount; i-- != 0; ) {
 33649:     const nsTransition& t = disp->mTransitions[i];
 33649:     // Check delay and duration first, since they default to zero, and
 33649:     // when they're both zero, we can ignore the transition.
 33649:     if (t.GetDelay() != 0.0f || t.GetDuration() != 0.0f) {
 33649:       // We might have something to transition.  See if any of the
 33649:       // properties in question changed and are animatable.
 35571:       // FIXME: Would be good to find a way to share code between this
 35571:       // interpretation of transition-property and the one below.
 33649:       nsCSSProperty property = t.GetProperty();
 33649:       if (property == eCSSPropertyExtra_no_properties ||
 33649:           property == eCSSProperty_UNKNOWN) {
 33649:         // Nothing to do, but need to exclude this from cases below.
 33649:       } else if (property == eCSSPropertyExtra_all_properties) {
 33649:         for (nsCSSProperty p = nsCSSProperty(0);
 33649:              p < eCSSProperty_COUNT_no_shorthands;
 33649:              p = nsCSSProperty(p + 1)) {
 33649:           ConsiderStartingTransition(p, t, aElement, et,
 33649:                                      aOldStyleContext, aNewStyleContext,
 33649:                                      &startedAny, &whichStarted);
 33649:         }
 33649:       } else if (nsCSSProps::IsShorthand(property)) {
 33649:         CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
 33649:           ConsiderStartingTransition(*subprop, t, aElement, et,
 33649:                                      aOldStyleContext, aNewStyleContext,
 33649:                                      &startedAny, &whichStarted);
 33649:         }
 33649:       } else {
 33649:         ConsiderStartingTransition(property, t, aElement, et,
 33649:                                    aOldStyleContext, aNewStyleContext,
 33649:                                    &startedAny, &whichStarted);
 33649:       }
 33649:     }
 33649:   }
 33649: 
 35571:   // Stop any transitions for properties that are no longer in
 35571:   // 'transition-property'.
 36530:   // Also stop any transitions for properties that just changed (and are
 36530:   // still in the set of properties to transition), but we didn't just
 36530:   // start the transition because delay and duration are both zero.
 36530:   if (et) {
 79445:     bool checkProperties =
 36530:       disp->mTransitions[0].GetProperty() != eCSSPropertyExtra_all_properties;
 35571:     nsCSSPropertySet allTransitionProperties;
 36530:     if (checkProperties) {
108991:       for (uint32_t i = disp->mTransitionPropertyCount; i-- != 0; ) {
 35571:         const nsTransition& t = disp->mTransitions[i];
 35571:         // FIXME: Would be good to find a way to share code between this
 35571:         // interpretation of transition-property and the one above.
 35571:         nsCSSProperty property = t.GetProperty();
 35571:         if (property == eCSSPropertyExtra_no_properties ||
 35571:             property == eCSSProperty_UNKNOWN) {
 35571:           // Nothing to do, but need to exclude this from cases below.
 35571:         } else if (property == eCSSPropertyExtra_all_properties) {
 35571:           for (nsCSSProperty p = nsCSSProperty(0);
 35571:                p < eCSSProperty_COUNT_no_shorthands;
 35571:                p = nsCSSProperty(p + 1)) {
 35571:             allTransitionProperties.AddProperty(p);
 35571:           }
 35571:         } else if (nsCSSProps::IsShorthand(property)) {
 35571:           CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
 35571:             allTransitionProperties.AddProperty(*subprop);
 35571:           }
 35571:         } else {
 35571:           allTransitionProperties.AddProperty(property);
 35571:         }
 35571:       }
 36530:     }
 35571: 
 35571:     nsTArray<ElementPropertyTransition> &pts = et->mPropertyTransitions;
108991:     uint32_t i = pts.Length();
 35571:     NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
 36530:     nsStyleAnimation::Value currentValue;
 35571:     do {
 35571:       --i;
 35571:       ElementPropertyTransition &pt = pts[i];
 36530:           // properties no longer in 'transition-property'
 36530:       if ((checkProperties &&
 36530:            !allTransitionProperties.HasProperty(pt.mProperty)) ||
 36530:           // properties whose computed values changed but delay and
 36530:           // duration are both zero
 67981:           !ExtractComputedValueForTransition(pt.mProperty, aNewStyleContext,
 36530:                                              currentValue) ||
 36530:           currentValue != pt.mEndValue) {
 36530:         // stop the transition
 35571:         pts.RemoveElementAt(i);
125555:         et->UpdateAnimationGeneration(mPresContext);
 35571:       }
 35571:     } while (i != 0);
 35571: 
 35571:     if (pts.IsEmpty()) {
 35571:       et->Destroy();
106838:       et = nullptr;
 35571:     }
 35571:   }
 35571: 
 33649:   if (!startedAny) {
106838:     return nullptr;
 33649:   }
 33649: 
 33649:   NS_ABORT_IF_FALSE(et, "must have element transitions if we started "
 33649:                         "any transitions");
 33649: 
 33649:   // In the CSS working group discussion (2009 Jul 15 telecon,
 33649:   // http://www.w3.org/mid/4A5E1470.4030904@inkedblade.net ) of
 33649:   // http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html ,
 33649:   // the working group decided that a transition property on an
 33649:   // element should not cause any transitions if the property change
 33649:   // is itself inheriting a value that is transitioning on an
 33649:   // ancestor.  So, to get the correct behavior, we continue the
 33649:   // restyle that caused this transition using a "covering" rule that
 33649:   // covers up any changes on which we started transitions, so that
 33649:   // descendants don't start their own transitions.  (In the case of
 33649:   // negative transition delay, this covering rule produces different
 33649:   // results than applying the transition rule immediately would).
 33649:   // Our caller is responsible for restyling again using this covering
 33649:   // rule.
 33649: 
 67981:   nsRefPtr<css::AnimValuesStyleRule> coverRule = new css::AnimValuesStyleRule;
 33649: 
 33649:   nsTArray<ElementPropertyTransition> &pts = et->mPropertyTransitions;
108991:   for (uint32_t i = 0, i_end = pts.Length(); i < i_end; ++i) {
 33649:     ElementPropertyTransition &pt = pts[i];
 33649:     if (whichStarted.HasProperty(pt.mProperty)) {
 48339:       coverRule->AddValue(pt.mProperty, pt.mStartValue);
 33649:     }
 33649:   }
 33649: 
 48340:   return coverRule.forget();
 33649: }
 33649: 
 33649: void
 33649: nsTransitionManager::ConsiderStartingTransition(nsCSSProperty aProperty,
 33649:                                                 const nsTransition& aTransition,
 42322:                                                 dom::Element* aElement,
 33649:                                                 ElementTransitions*& aElementTransitions,
 33649:                                                 nsStyleContext* aOldStyleContext,
 33649:                                                 nsStyleContext* aNewStyleContext,
 79445:                                                 bool* aStartedAny,
 33649:                                                 nsCSSPropertySet* aWhichStarted)
 33649: {
 33649:   // IsShorthand itself will assert if aProperty is not a property.
 33649:   NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
 33649:                     "property out of range");
125555:   NS_ASSERTION(!aElementTransitions ||
125555:                aElementTransitions->mElement == aElement, "Element mismatch");
 33649: 
 33649:   if (aWhichStarted->HasProperty(aProperty)) {
 33649:     // A later item in transition-property already started a
 33649:     // transition for this property, so we ignore this one.
 33649:     // See comment above and
 33649:     // http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html .
 33649:     return;
 33649:   }
 33649: 
 33649:   if (nsCSSProps::kAnimTypeTable[aProperty] == eStyleAnimType_None) {
 33649:     return;
 33649:   }
 33649: 
 33649:   ElementPropertyTransition pt;
 34029:   nsStyleAnimation::Value dummyValue;
 79445:   bool haveValues =
 67981:     ExtractComputedValueForTransition(aProperty, aOldStyleContext,
 67981:                                        pt.mStartValue) &&
 67981:     ExtractComputedValueForTransition(aProperty, aNewStyleContext,
 67981:                                        pt.mEndValue);
107005: 
107005:   bool haveChange = pt.mStartValue != pt.mEndValue;
107005:     
 79445:   bool shouldAnimate =
 60638:     haveValues &&
125555:     haveChange &&
 33649:     // Check that we can interpolate between these values
 33649:     // (If this is ever a performance problem, we could add a
 33649:     // CanInterpolate method, but it seems fine for now.)
 34869:     nsStyleAnimation::Interpolate(aProperty, pt.mStartValue, pt.mEndValue,
 34869:                                   0.5, dummyValue);
 33649: 
108991:   uint32_t currentIndex = nsTArray<ElementPropertyTransition>::NoIndex;
 33649:   if (aElementTransitions) {
 33649:     nsTArray<ElementPropertyTransition> &pts =
 33649:       aElementTransitions->mPropertyTransitions;
108991:     for (uint32_t i = 0, i_end = pts.Length(); i < i_end; ++i) {
 33649:       if (pts[i].mProperty == aProperty) {
 33649:         currentIndex = i;
 33649:         break;
 33649:       }
 33649:     }
 33649:   }
 33649: 
 33649:   nsPresContext *presContext = aNewStyleContext->PresContext();
 33649: 
 33649:   if (!shouldAnimate) {
 60638:     nsTArray<ElementPropertyTransition> &pts =
 60638:       aElementTransitions->mPropertyTransitions;
 60638:     if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex &&
 60638:         (!haveValues || pts[currentIndex].mEndValue != pt.mEndValue)) {
 33649:       // We're in the middle of a transition, but just got a
 33649:       // non-transition style change changing to exactly the
 33649:       // current in-progress value.   (This is quite easy to cause
 33649:       // using 'transition-delay'.)
 60638:       //
 60638:       // We also check that this current in-progress value is different
 60638:       // from the end value; we don't want to cancel a transition that
 60638:       // is almost done (and whose current value rounds to its end
 60638:       // value) just because we got an unrelated style change.
 33649:       pts.RemoveElementAt(currentIndex);
125555:       aElementTransitions->UpdateAnimationGeneration(mPresContext);
125555: 
 33649:       if (pts.IsEmpty()) {
 33649:         aElementTransitions->Destroy();
 33649:         // |aElementTransitions| is now a dangling pointer!
106838:         aElementTransitions = nullptr;
 33649:       }
 35571:       // WalkTransitionRule already called RestyleForAnimation.
 33649:     }
 33649:     return;
 33649:   }
 33649: 
 57250:   TimeStamp mostRecentRefresh =
 57250:     presContext->RefreshDriver()->MostRecentRefresh();
 57250: 
 57250:   const nsTimingFunction &tf = aTransition.GetTimingFunction();
 57250:   float delay = aTransition.GetDelay();
 57250:   float duration = aTransition.GetDuration();
 57250:   if (duration < 0.0) {
 57250:     // The spec says a negative duration is treated as zero.
 57250:     duration = 0.0;
 57250:   }
 57250:   pt.mStartForReversingTest = pt.mStartValue;
 57250:   pt.mReversePortion = 1.0;
 33649: 
 33649:   // We need to check two things if we have a currently running
 57250:   // transition for this property.
 33649:   if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex) {
 37104:     const ElementPropertyTransition &oldPT =
 37104:       aElementTransitions->mPropertyTransitions[currentIndex];
 33649: 
 37104:     if (oldPT.mEndValue == pt.mEndValue) {
 33649:       // If we got a style change that changed the value to the endpoint
 33649:       // of the currently running transition, we don't want to interrupt
 33649:       // its timing function.
 35571:       // WalkTransitionRule already called RestyleForAnimation.
 33649:       return;
 33649:     }
 33649: 
 57250:     // If the new transition reverses the old one, we'll need to handle
 57250:     // the timing differently.
 57250:     if (!oldPT.IsRemovedSentinel() &&
 57250:         oldPT.mStartForReversingTest == pt.mEndValue) {
 57250:       // Compute the appropriate negative transition-delay such that right
 57250:       // now we'd end up at the current position.
 57250:       double valuePortion =
 57250:         oldPT.ValuePortionFor(mostRecentRefresh) * oldPT.mReversePortion +
 57250:         (1.0 - oldPT.mReversePortion);
 59406:       // A timing function with negative y1 (or y2!) might make
 59406:       // valuePortion negative.  In this case, we still want to apply our
 59406:       // reversing logic based on relative distances, not make duration
 59406:       // negative.
 59406:       if (valuePortion < 0.0)
 59406:         valuePortion = -valuePortion;
 59406:       // A timing function with y2 (or y1!) greater than one might
 59406:       // advance past its terminal value.  It's probably a good idea to
 59406:       // clamp valuePortion to be at most one to preserve the invariant
 59406:       // that a transition will complete within at most its specified
 59406:       // time.
 59406:       if (valuePortion > 1.0)
 59406:         valuePortion = 1.0;
 33649: 
 57250:       // Negative delays are essentially part of the transition
 57250:       // function, so reduce them along with the duration, but don't
 57250:       // reduce positive delays.
 57250:       if (delay < 0.0f)
 57250:         delay *= valuePortion;
107005: 
 57250:       duration *= valuePortion;
 57250: 
 57250:       pt.mStartForReversingTest = oldPT.mEndValue;
 57250:       pt.mReversePortion = valuePortion;
 33649:     }
 33649:   }
 33649: 
 33649:   pt.mProperty = aProperty;
 57250:   pt.mStartTime = mostRecentRefresh + TimeDuration::FromMilliseconds(delay);
 33649:   pt.mDuration = TimeDuration::FromMilliseconds(duration);
 67974:   pt.mTimingFunction.Init(tf);
 33649:   if (!aElementTransitions) {
 33649:     aElementTransitions =
 35555:       GetElementTransitions(aElement, aNewStyleContext->GetPseudoType(),
 80486:                             true);
 33649:     if (!aElementTransitions) {
 33649:       NS_WARNING("allocating ElementTransitions failed");
 33649:       return;
 33649:     }
 33649:   }
 33649: 
 33649:   nsTArray<ElementPropertyTransition> &pts =
 33649:     aElementTransitions->mPropertyTransitions;
 33649: #ifdef DEBUG
108991:   for (uint32_t i = 0, i_end = pts.Length(); i < i_end; ++i) {
 33649:     NS_ABORT_IF_FALSE(i == currentIndex ||
 33649:                       pts[i].mProperty != aProperty,
 33649:                       "duplicate transitions for property");
 33649:   }
 33649: #endif
 33649:   if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex) {
 33649:     pts[currentIndex] = pt;
 33649:   } else {
 33649:     if (!pts.AppendElement(pt)) {
 33649:       NS_WARNING("out of memory");
 33649:       return;
 33649:     }
 33649:   }
125555:   aElementTransitions->UpdateAnimationGeneration(mPresContext);
 33649: 
 46468:   nsRestyleHint hint =
 46468:     aNewStyleContext->GetPseudoType() ==
 46468:       nsCSSPseudoElements::ePseudo_NotPseudoElement ?
 46468:     eRestyle_Self : eRestyle_Subtree;
 46468:   presContext->PresShell()->RestyleForAnimation(aElement, hint);
 33649: 
 80486:   *aStartedAny = true;
 33649:   aWhichStarted->AddProperty(aProperty);
 33649: }
 33649: 
 33649: ElementTransitions*
 42322: nsTransitionManager::GetElementTransitions(dom::Element *aElement,
 35555:                                            nsCSSPseudoElements::Type aPseudoType,
 79445:                                            bool aCreateIfNeeded)
 33649: {
 67981:   if (!aCreateIfNeeded && PR_CLIST_IS_EMPTY(&mElementData)) {
 36529:     // Early return for the most common case.
106838:     return nullptr;
 36529:   }
 36529: 
 33649:   nsIAtom *propName;
 36529:   if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
 36529:     propName = nsGkAtoms::transitionsProperty;
 36529:   } else if (aPseudoType == nsCSSPseudoElements::ePseudo_before) {
 33649:     propName = nsGkAtoms::transitionsOfBeforeProperty;
 35555:   } else if (aPseudoType == nsCSSPseudoElements::ePseudo_after) {
 33649:     propName = nsGkAtoms::transitionsOfAfterProperty;
 33649:   } else {
 36529:     NS_ASSERTION(!aCreateIfNeeded,
 33649:                  "should never try to create transitions for pseudo "
 33649:                  "other than :before or :after");
106838:     return nullptr;
 33649:   }
 33649:   ElementTransitions *et = static_cast<ElementTransitions*>(
 33649:                              aElement->GetProperty(propName));
 33649:   if (!et && aCreateIfNeeded) {
 33649:     // FIXME: Consider arena-allocating?
125555:     et = new ElementTransitions(aElement, propName, this,
125555:       mPresContext->RefreshDriver()->MostRecentRefresh());
 33649:     nsresult rv = aElement->SetProperty(propName, et,
118463:                                         ElementTransitionsPropertyDtor, false);
 33649:     if (NS_FAILED(rv)) {
 33649:       NS_WARNING("SetProperty failed");
 33649:       delete et;
106838:       return nullptr;
 33649:     }
107005:     if (propName == nsGkAtoms::transitionsProperty) {
107005:       aElement->SetMayHaveAnimations();
107005:     }
 33649: 
 67981:     AddElementData(et);
 33649:   }
 33649: 
 33649:   return et;
 33649: }
 33649: 
 33649: /*
 33649:  * nsIStyleRuleProcessor implementation
 33649:  */
 33649: 
 47891: void
121909: nsTransitionManager::WalkTransitionRule(ElementDependentRuleProcessorData* aData,
 35555:                                         nsCSSPseudoElements::Type aPseudoType)
 33649: {
 35571:   ElementTransitions *et =
 80486:     GetElementTransitions(aData->mElement, aPseudoType, false);
 35571:   if (!et) {
 47891:     return;
 35571:   }
 35571: 
 46468:   if (aData->mPresContext->IsProcessingRestyles() &&
 46468:       !aData->mPresContext->IsProcessingAnimationStyleChange()) {
 33649:     // If we're processing a normal style change rather than one from
 33649:     // animation, don't add the transition rule.  This allows us to
 33649:     // compute the new style value rather than having the transition
 33649:     // override it, so that we can start transitioning differently.
 33649: 
 35571:     // We need to immediately restyle with animation
 35571:     // after doing this.
 35571:     if (et) {
 46468:       nsRestyleHint hint =
 46468:         aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ?
 46468:         eRestyle_Self : eRestyle_Subtree;
 46468:       mPresContext->PresShell()->RestyleForAnimation(aData->mElement, hint);
 33649:     }
 47891:     return;
 33649:   }
 33649: 
 47891:   et->EnsureStyleRuleFor(
 47891:     aData->mPresContext->RefreshDriver()->MostRecentRefresh());
 47891: 
 47891:   aData->mRuleWalker->Forward(et->mStyleRule);
 33649: }
 33649: 
 47891: /* virtual */ void
 33649: nsTransitionManager::RulesMatching(ElementRuleProcessorData* aData)
 33649: {
 33649:   NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
 33649:                     "pres context mismatch");
 47891:   WalkTransitionRule(aData,
 35555:                      nsCSSPseudoElements::ePseudo_NotPseudoElement);
 35555: }
 35555: 
 47891: /* virtual */ void
 35555: nsTransitionManager::RulesMatching(PseudoElementRuleProcessorData* aData)
 35555: {
 35555:   NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
 35555:                     "pres context mismatch");
 35555: 
 35555:   // Note:  If we're the only thing keeping a pseudo-element frame alive
 35555:   // (per ProbePseudoStyleContext), we still want to keep it alive, so
 35555:   // this is ok.
 47891:   WalkTransitionRule(aData, aData->mPseudoType);
 35539: }
 35539: 
 47891: /* virtual */ void
 35556: nsTransitionManager::RulesMatching(AnonBoxRuleProcessorData* aData)
 35556: {
 35556: }
 35556: 
 35558: #ifdef MOZ_XUL
 47891: /* virtual */ void
 35558: nsTransitionManager::RulesMatching(XULTreeRuleProcessorData* aData)
 35539: {
 33649: }
 35558: #endif
 33649: 
 84365: /* virtual */ size_t
 84365: nsTransitionManager::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const
 84365: {
 84365:   return CommonAnimationManager::SizeOfExcludingThis(aMallocSizeOf);
 84365: }
 84365: 
 84365: /* virtual */ size_t
 84365: nsTransitionManager::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf) const
 84365: {
 88300:   return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
 84365: }
 84365: 
 36620: struct TransitionEventInfo {
 36620:   nsCOMPtr<nsIContent> mElement;
 36620:   nsTransitionEvent mEvent;
 36620: 
 36620:   TransitionEventInfo(nsIContent *aElement, nsCSSProperty aProperty,
 36620:                       TimeDuration aDuration)
 36620:     : mElement(aElement),
 80486:       mEvent(true, NS_TRANSITION_END,
 36620:              NS_ConvertUTF8toUTF16(nsCSSProps::GetStringValue(aProperty)),
 36620:              aDuration.ToSeconds())
 36620:   {
 36620:   }
 36620: 
 36620:   // nsTransitionEvent doesn't support copy-construction, so we need
 36620:   // to ourselves in order to work with nsTArray
 36620:   TransitionEventInfo(const TransitionEventInfo &aOther)
 36620:     : mElement(aOther.mElement),
 80486:       mEvent(true, NS_TRANSITION_END,
 36620:              aOther.mEvent.propertyName, aOther.mEvent.elapsedTime)
 36620:   {
 36620:   }
 36620: };
 36620: 
 33649: /* virtual */ void
 33649: nsTransitionManager::WillRefresh(mozilla::TimeStamp aTime)
 33649: {
 36616:   NS_ABORT_IF_FALSE(mPresContext,
 36616:                     "refresh driver should not notify additional observers "
 36616:                     "after pres context has been destroyed");
 53967:   if (!mPresContext->GetPresShell()) {
 53967:     // Someone might be keeping mPresContext alive past the point
 53967:     // where it has been torn down; don't bother doing anything in
 53967:     // this case.  But do get rid of all our transitions so we stop
 53967:     // triggering refreshes.
 67981:     RemoveAllElementData();
 53967:     return;
 53967:   }
 36616: 
125555:   FlushTransitions(Can_Throttle);
125555: }
125555: 
125555: void
125555: nsTransitionManager::FlushTransitions(FlushFlags aFlags)
125555: { 
125555:   if (PR_CLIST_IS_EMPTY(&mElementData)) {
125555:     // no transitions, leave early
125555:     return;
125555:   }
125555: 
 36620:   nsTArray<TransitionEventInfo> events;
125555:   TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
125555:   bool didThrottle = false;
126797:   // Trim transitions that have completed, post restyle events for frames that
126797:   // are still transitioning, and start transitions with delays.
 33649:   {
 67981:     PRCList *next = PR_LIST_HEAD(&mElementData);
 67981:     while (next != &mElementData) {
 33649:       ElementTransitions *et = static_cast<ElementTransitions*>(next);
 33649:       next = PR_NEXT_LINK(next);
 33649: 
125555:       bool canThrottleTick = aFlags == Can_Throttle &&
125555:         et->CanPerformOnCompositorThread(
125555:           CommonElementAnimationData::CanAnimateFlags(0)) &&
125555:         et->CanThrottleAnimation(now);
125555: 
 33649:       NS_ABORT_IF_FALSE(et->mElement->GetCurrentDoc() ==
 33649:                           mPresContext->Document(),
121948:                         "Element::UnbindFromTree should have "
 33649:                         "destroyed the element transitions object");
 33649: 
108991:       uint32_t i = et->mPropertyTransitions.Length();
 33649:       NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
126797:       bool transitionStartedOrEnded = false;
 33649:       do {
 33649:         --i;
 33649:         ElementPropertyTransition &pt = et->mPropertyTransitions[i];
 37104:         if (pt.IsRemovedSentinel()) {
125555:           // Actually remove transitions one throttle-able cycle after their
125555:           // completion. We only clear on a throttle-able cycle because that
125555:           // means it is a regular restyle tick and thus it is safe to discard
125555:           // the transition. If the flush is not throttle-able, we might still
125555:           // have new transitions left to process. See comment below.
125555:           if (aFlags == Can_Throttle) {
 37104:             et->mPropertyTransitions.RemoveElementAt(i);
125555:           }
125555:         } else if (pt.mStartTime + pt.mDuration <= now) {
 47175:           // Fire transitionend events only for transitions on elements
 47175:           // and not those on pseudo-elements, since we can't target an
 47175:           // event at pseudo-elements.
 47175:           if (et->mElementProperty == nsGkAtoms::transitionsProperty) {
 36620:             nsCSSProperty prop = pt.mProperty;
 47175:             if (nsCSSProps::PropHasFlags(prop, CSS_PROPERTY_REPORT_OTHER_NAME))
 47175:             {
 36620:               prop = nsCSSProps::OtherNameFor(prop);
 36620:             }
 36620:             events.AppendElement(
 36620:               TransitionEventInfo(et->mElement, prop, pt.mDuration));
 47175:           }
 36620: 
 37104:           // Leave this transition in the list for one more refresh
 37104:           // cycle, since we haven't yet processed its style change, and
 37104:           // if we also have (already, or will have from processing
 37104:           // transitionend events or other refresh driver notifications)
 37104:           // a non-animation style change that would affect it, we need
 37104:           // to know not to start a new transition for the transition
 37104:           // from the almost-completed value to the final value.
 37104:           pt.SetRemovedSentinel();
125555:           et->UpdateAnimationGeneration(mPresContext);
126797:           transitionStartedOrEnded = true;
126797:         } else if (pt.mStartTime <= now && canThrottleTick &&
126797:                    !pt.mIsRunningOnCompositor) {
126797:           // Start a transition with a delay where we should start the
126797:           // transition proper.
126797:           et->UpdateAnimationGeneration(mPresContext);
126797:           transitionStartedOrEnded = true;
 33649:         }
 33649:       } while (i != 0);
 33649: 
 33649:       // We need to restyle even if the transition rule no longer
 33649:       // applies (in which case we just made it not apply).
 46468:       NS_ASSERTION(et->mElementProperty == nsGkAtoms::transitionsProperty ||
 46468:                    et->mElementProperty == nsGkAtoms::transitionsOfBeforeProperty ||
 46468:                    et->mElementProperty == nsGkAtoms::transitionsOfAfterProperty,
 46468:                    "Unexpected element property; might restyle too much");
126797:       if (!canThrottleTick || transitionStartedOrEnded) {
 46468:         nsRestyleHint hint = et->mElementProperty == nsGkAtoms::transitionsProperty ?
 46468:           eRestyle_Self : eRestyle_Subtree;
 46468:         mPresContext->PresShell()->RestyleForAnimation(et->mElement, hint);
125555:       } else {
125555:         didThrottle = true;
125555:       }
 33649: 
 33649:       if (et->mPropertyTransitions.IsEmpty()) {
 33649:         et->Destroy();
 33649:         // |et| is now a dangling pointer!
106838:         et = nullptr;
 33649:       }
 33649:     }
 33649:   }
 33649: 
 33649:   // We might have removed transitions above.
 67981:   ElementDataRemoved();
 36620: 
125555:   if (didThrottle) {
125555:     mPresContext->Document()->SetNeedStyleFlush();
125555:   }
125555: 
108991:   for (uint32_t i = 0, i_end = events.Length(); i < i_end; ++i) {
 36620:     TransitionEventInfo &info = events[i];
 36620:     nsEventDispatcher::Dispatch(info.mElement, mPresContext, &info.mEvent);
 36620: 
 36620:     if (!mPresContext) {
 36620:       break;
 36620:     }
 36620:   }
 33649: }
