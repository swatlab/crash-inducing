69223: /* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
69223:  * vim: set ts=4 sw=4 et tw=79 ft=cpp:
69223:  *
69223:  * ***** BEGIN LICENSE BLOCK *****
69223:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
69223:  *
69223:  * The contents of this file are subject to the Mozilla Public License Version
69223:  * 1.1 (the "License"); you may not use this file except in compliance with
69223:  * the License. You may obtain a copy of the License at
69223:  * http://www.mozilla.org/MPL/
69223:  *
69223:  * Software distributed under the License is distributed on an "AS IS" basis,
69223:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
69223:  * for the specific language governing rights and limitations under the
69223:  * License.
69223:  *
69223:  * The Original Code is SpiderMonkey JavaScript engine.
69223:  *
69223:  * The Initial Developer of the Original Code is
69223:  * Mozilla Corporation.
69223:  * Portions created by the Initial Developer are Copyright (C) 2009
69223:  * the Initial Developer. All Rights Reserved.
69223:  *
69223:  * Contributor(s):
69223:  *   Luke Wagner <luke@mozilla.com>
69223:  *
69223:  * Alternatively, the contents of this file may be used under the terms of
69223:  * either the GNU General Public License Version 2 or later (the "GPL"), or
69223:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
69223:  * in which case the provisions of the GPL or the LGPL are applicable instead
69223:  * of those above. If you wish to allow use of your version of this file only
69223:  * under the terms of either the GPL or the LGPL, and not to allow others to
69223:  * use your version of this file under the terms of the MPL, indicate your
69223:  * decision by deleting the provisions above and replace them with the notice
69223:  * and other provisions required by the GPL or the LGPL. If you do not delete
69223:  * the provisions above, a recipient may use your version of this file under
69223:  * the terms of any one of the MPL, the GPL or the LGPL.
69223:  *
69223:  * ***** END LICENSE BLOCK ***** */
69223: 
69223: #ifndef Stack_inl_h__
69223: #define Stack_inl_h__
69223: 
70320: #include "jscntxt.h"
70321: #include "jscompartment.h"
70320: 
69223: #include "Stack.h"
69223: 
69827: #include "ArgumentsObject-inl.h"
69827: 
69223: namespace js {
69223: 
69223: inline void
69223: StackFrame::initPrev(JSContext *cx)
69223: {
69223:     JS_ASSERT(flags_ & HAS_PREVPC);
69223:     if (FrameRegs *regs = cx->maybeRegs()) {
69223:         prev_ = regs->fp();
69223:         prevpc_ = regs->pc;
69223:         JS_ASSERT_IF(!prev_->isDummyFrame() && !prev_->hasImacropc(),
69223:                      uint32(prevpc_ - prev_->script()->code) < prev_->script()->length);
69223:     } else {
69223:         prev_ = NULL;
69223: #ifdef DEBUG
69223:         prevpc_ = (jsbytecode *)0xbadc;
69223: #endif
69223:     }
69223: }
69223: 
69223: inline void
69223: StackFrame::resetGeneratorPrev(JSContext *cx)
69223: {
69223:     flags_ |= HAS_PREVPC;
69223:     initPrev(cx);
69223: }
69223: 
69223: inline void
69223: StackFrame::initCallFrame(JSContext *cx, JSObject &callee, JSFunction *fun,
71695:                           JSScript *script, uint32 nactual, StackFrame::Flags flagsArg)
69223: {
69223:     JS_ASSERT((flagsArg & ~(CONSTRUCTING |
69223:                             OVERFLOW_ARGS |
69223:                             UNDERFLOW_ARGS)) == 0);
69223:     JS_ASSERT(fun == callee.getFunctionPrivate());
71695:     JS_ASSERT(script == fun->script());
69223: 
69223:     /* Initialize stack frame members. */
69223:     flags_ = FUNCTION | HAS_PREVPC | HAS_SCOPECHAIN | flagsArg;
69223:     exec.fun = fun;
69223:     args.nactual = nactual;  /* only need to write if over/under-flow */
69223:     scopeChain_ = callee.getParent();
69223:     initPrev(cx);
69223:     JS_ASSERT(!hasImacropc());
69223:     JS_ASSERT(!hasHookData());
69223:     JS_ASSERT(annotation() == NULL);
69223:     JS_ASSERT(!hasCallObj());
71695: 
71695:     SetValueRangeToUndefined(slots(), script->nfixed);
69223: }
69223: 
69223: inline void
71695: StackFrame::resetCallFrame(JSScript *script)
69223: {
71695:     JS_ASSERT(script == this->script());
71695: 
71695:     /* Undo changes to frame made during execution; see also initCallFrame */
69223: 
69223:     putActivationObjects();
72093:     markActivationObjectsAsPut();
69223: 
71695:     if (flags_ & UNDERFLOW_ARGS)
71695:         SetValueRangeToUndefined(formalArgs() + numActualArgs(), formalArgsEnd());
71695: 
69223:     JS_ASSERT(!(flags_ & ~(FUNCTION |
69223:                            OVERFLOW_ARGS |
69223:                            UNDERFLOW_ARGS |
69223:                            OVERRIDE_ARGS |
69223:                            HAS_PREVPC |
69223:                            HAS_RVAL |
69223:                            HAS_SCOPECHAIN |
69223:                            HAS_ANNOTATION |
69223:                            HAS_HOOK_DATA |
69223:                            HAS_CALL_OBJ |
69223:                            HAS_ARGS_OBJ |
69223:                            FINISHED_IN_INTERP)));
69223: 
69223:     /*
69223:      * Since the stack frame is usually popped after PutActivationObjects,
69223:      * these bits aren't cleared. The activation objects must have actually
69223:      * been put, though.
69223:      */
69223:     JS_ASSERT_IF(flags_ & HAS_CALL_OBJ, callObj().getPrivate() == NULL);
69223:     JS_ASSERT_IF(flags_ & HAS_ARGS_OBJ, argsObj().getPrivate() == NULL);
69223: 
69223:     flags_ &= FUNCTION |
69223:               OVERFLOW_ARGS |
69223:               HAS_PREVPC |
69223:               UNDERFLOW_ARGS;
69223: 
69223:     JS_ASSERT(exec.fun == callee().getFunctionPrivate());
69223:     scopeChain_ = callee().getParent();
71695: 
71695:     SetValueRangeToUndefined(slots(), script->nfixed);
69223: }
69223: 
69223: inline void
71695: StackFrame::initJitFrameCallerHalf(JSContext *cx, StackFrame::Flags flags,
69223:                                     void *ncode)
69223: {
71695:     JS_ASSERT((flags & ~(CONSTRUCTING |
69223:                          FUNCTION |
69223:                          OVERFLOW_ARGS |
69223:                          UNDERFLOW_ARGS)) == 0);
69223: 
71695:     flags_ = FUNCTION | flags;
69223:     prev_ = cx->fp();
69223:     ncode_ = ncode;
69223: }
69223: 
69223: /*
72577:  * The "early prologue" refers to either the fast path or arity check path up
72577:  * to the "late prologue".
69223:  */
69223: inline void
71695: StackFrame::initJitFrameEarlyPrologue(JSFunction *fun, uint32 nactual)
69223: {
69223:     exec.fun = fun;
69223:     if (flags_ & (OVERFLOW_ARGS | UNDERFLOW_ARGS))
69223:         args.nactual = nactual;
69223: }
69223: 
69223: /*
72577:  * The "late prologue" (in generatePrologue) extends from the join point of the
72577:  * fast path and arity check to where the call object is (possibly) created.
69223:  */
72577: inline bool
72577: StackFrame::initJitFrameLatePrologue(JSContext *cx, Value **limit)
69223: {
72577:     uintN nvals = script()->nslots + VALUES_PER_STACK_FRAME;
72577:     Value *required = (Value *)this + nvals;
72577:     if (required >= *limit) {
72577:         ContextStack &stack = cx->stack;
72577:         if (!stack.space().tryBumpLimit(NULL, slots(), nvals, limit)) {
72577:             stack.popFrameAfterOverflow();
72577:             js_ReportOverRecursed(cx);
72577:             return false;
72577:         }
72577:     }
72577: 
69223:     SetValueRangeToUndefined(slots(), script()->nfixed);
72577:     return true;
69223: }
69223: 
69223: inline Value &
69223: StackFrame::canonicalActualArg(uintN i) const
69223: {
69223:     if (i < numFormalArgs())
69223:         return formalArg(i);
69223:     JS_ASSERT(i < numActualArgs());
69223:     return actualArgs()[i];
69223: }
69223: 
69223: template <class Op>
69223: inline bool
70319: StackFrame::forEachCanonicalActualArg(Op op, uintN start /* = 0 */, uintN count /* = uintN(-1) */)
69223: {
69223:     uintN nformal = fun()->nargs;
70319:     JS_ASSERT(start <= nformal);
70319: 
69223:     Value *formals = formalArgsEnd() - nformal;
69223:     uintN nactual = numActualArgs();
70319:     if (count == uintN(-1))
70319:         count = nactual - start;
70319: 
70319:     uintN end = start + count;
70319:     JS_ASSERT(end >= start);
70319:     JS_ASSERT(end <= nactual);
70319: 
70319:     if (end <= nformal) {
70319:         Value *p = formals + start;
70319:         for (; start < end; ++p, ++start) {
70319:             if (!op(start, p))
69223:                 return false;
69223:         }
69223:     } else {
70319:         for (Value *p = formals + start; start < nformal; ++p, ++start) {
70319:             if (!op(start, p))
69223:                 return false;
69223:         }
70319:         JS_ASSERT(start >= nformal);
70319:         Value *actuals = formals - (nactual + 2) + start;
70319:         for (Value *p = actuals; start < end; ++p, ++start) {
70319:             if (!op(start, p))
69223:                 return false;
69223:         }
69223:     }
69223:     return true;
69223: }
69223: 
69223: template <class Op>
69223: inline bool
69223: StackFrame::forEachFormalArg(Op op)
69223: {
69223:     Value *formals = formalArgsEnd() - fun()->nargs;
69223:     Value *formalsEnd = formalArgsEnd();
69223:     uintN i = 0;
69223:     for (Value *p = formals; p != formalsEnd; ++p, ++i) {
69223:         if (!op(i, p))
69223:             return false;
69223:     }
69223:     return true;
69223: }
69223: 
69223: struct CopyTo
69223: {
69223:     Value *dst;
69223:     CopyTo(Value *dst) : dst(dst) {}
69223:     bool operator()(uintN, Value *src) {
69223:         *dst++ = *src;
69223:         return true;
69223:     }
69223: };
69223: 
69223: inline uintN
69223: StackFrame::numActualArgs() const
69223: {
69223:     JS_ASSERT(hasArgs());
69223:     if (JS_UNLIKELY(flags_ & (OVERFLOW_ARGS | UNDERFLOW_ARGS)))
69827:         return hasArgsObj() ? argsObj().initialLength() : args.nactual;
69223:     return numFormalArgs();
69223: }
69223: 
69223: inline Value *
69223: StackFrame::actualArgs() const
69223: {
69223:     JS_ASSERT(hasArgs());
69223:     Value *argv = formalArgs();
69223:     if (JS_UNLIKELY(flags_ & OVERFLOW_ARGS)) {
69827:         uintN nactual = hasArgsObj() ? argsObj().initialLength() : args.nactual;
69223:         return argv - (2 + nactual);
69223:     }
69223:     return argv;
69223: }
69223: 
69223: inline Value *
69223: StackFrame::actualArgsEnd() const
69223: {
69223:     JS_ASSERT(hasArgs());
69223:     if (JS_UNLIKELY(flags_ & OVERFLOW_ARGS))
69223:         return formalArgs() - 2;
69223:     return formalArgs() + numActualArgs();
69223: }
69223: 
69223: inline void
69827: StackFrame::setArgsObj(ArgumentsObject &obj)
69223: {
69223:     JS_ASSERT_IF(hasArgsObj(), &obj == args.obj);
69827:     JS_ASSERT_IF(!hasArgsObj(), numActualArgs() == obj.initialLength());
69223:     args.obj = &obj;
69223:     flags_ |= HAS_ARGS_OBJ;
69223: }
69223: 
69223: inline void
69223: StackFrame::setScopeChainNoCallObj(JSObject &obj)
69223: {
69223: #ifdef DEBUG
69223:     JS_ASSERT(&obj != NULL);
69223:     if (&obj != sInvalidScopeChain) {
69223:         if (hasCallObj()) {
69223:             JSObject *pobj = &obj;
69223:             while (pobj && pobj->getPrivate() != this)
69223:                 pobj = pobj->getParent();
69223:             JS_ASSERT(pobj);
69223:         } else {
69223:             for (JSObject *pobj = &obj; pobj; pobj = pobj->getParent())
69223:                 JS_ASSERT_IF(pobj->isCall(), pobj->getPrivate() != this);
69223:         }
69223:     }
69223: #endif
69223:     scopeChain_ = &obj;
69223:     flags_ |= HAS_SCOPECHAIN;
69223: }
69223: 
69223: inline void
69223: StackFrame::setScopeChainWithOwnCallObj(JSObject &obj)
69223: {
69223:     JS_ASSERT(&obj != NULL);
69223:     JS_ASSERT(!hasCallObj() && obj.isCall() && obj.getPrivate() == this);
69223:     scopeChain_ = &obj;
69223:     flags_ |= HAS_SCOPECHAIN | HAS_CALL_OBJ;
69223: }
69223: 
69223: inline JSObject &
69223: StackFrame::callObj() const
69223: {
69223:     JS_ASSERT_IF(isNonEvalFunctionFrame() || isStrictEvalFrame(), hasCallObj());
69223: 
69223:     JSObject *pobj = &scopeChain();
69223:     while (JS_UNLIKELY(pobj->getClass() != &js_CallClass)) {
69223:         JS_ASSERT(IsCacheableNonGlobalScope(pobj) || pobj->isWith());
69223:         pobj = pobj->getParent();
69223:     }
69223:     return *pobj;
69223: }
69223: 
69223: inline void
69223: StackFrame::putActivationObjects()
69223: {
69223:     if (flags_ & (HAS_ARGS_OBJ | HAS_CALL_OBJ)) {
69223:         /* NB: there is an ordering dependency here. */
69223:         if (hasCallObj())
69223:             js_PutCallObject(this);
69223:         else if (hasArgsObj())
69223:             js_PutArgsObject(this);
69223:     }
69223: }
69223: 
69223: inline void
69223: StackFrame::markActivationObjectsAsPut()
69223: {
69223:     if (flags_ & (HAS_ARGS_OBJ | HAS_CALL_OBJ)) {
69223:         if (hasArgsObj() && !argsObj().getPrivate()) {
69827:             args.nactual = args.obj->initialLength();
69223:             flags_ &= ~HAS_ARGS_OBJ;
69223:         }
69223:         if (hasCallObj() && !callObj().getPrivate()) {
69223:             /*
69223:              * For function frames, the call object may or may not have have an
69223:              * enclosing DeclEnv object, so we use the callee's parent, since
69223:              * it was the initial scope chain. For global (strict) eval frames,
69223:              * there is no calle, but the call object's parent is the initial
69223:              * scope chain.
69223:              */
69223:             scopeChain_ = isFunctionFrame()
69223:                           ? callee().getParent()
69223:                           : scopeChain_->getParent();
69223:             flags_ &= ~HAS_CALL_OBJ;
69223:         }
69223:     }
69223: }
69223: 
69223: /*****************************************************************************/
69223: 
70320: #ifdef JS_TRACER
69223: JS_ALWAYS_INLINE bool
69223: StackSpace::ensureEnoughSpaceToEnterTrace()
69223: {
69223:     ptrdiff_t needed = TraceNativeStorage::MAX_NATIVE_STACK_SLOTS +
69223:                        TraceNativeStorage::MAX_CALL_STACK_ENTRIES * VALUES_PER_STACK_FRAME;
69223: #ifdef XP_WIN
69223:     return ensureSpace(NULL, firstUnused(), needed);
69223: #else
69223:     return end_ - firstUnused() > needed;
69223: #endif
69223: }
70320: #endif
69223: 
69223: STATIC_POSTCONDITION(!return || ubound(from) >= nvals)
69223: JS_ALWAYS_INLINE bool
69223: StackSpace::ensureSpace(JSContext *maybecx, Value *from, ptrdiff_t nvals) const
69223: {
69223:     JS_ASSERT(from >= firstUnused());
69223: #ifdef XP_WIN
69223:     JS_ASSERT(from <= commitEnd_);
69223:     if (commitEnd_ - from < nvals)
69223:         return bumpCommit(maybecx, from, nvals);
69223:     return true;
69223: #else
69223:     if (end_ - from < nvals) {
71363:         js_ReportOverRecursed(maybecx);
69223:         return false;
69223:     }
69223:     return true;
69223: #endif
69223: }
69223: 
69223: inline Value *
69223: StackSpace::getStackLimit(JSContext *cx)
69223: {
71363:     Value *limit;
71363: #ifdef XP_WIN
71363:     limit = commitEnd_;
71363: #else
71363:     limit = end_;
71363: #endif
71363: 
71363:     /* See getStackLimit comment in Stack.h. */
69223:     FrameRegs &regs = cx->regs();
69223:     uintN minSpace = regs.fp()->numSlots() + VALUES_PER_STACK_FRAME;
71363:     if (regs.sp + minSpace > limit) {
71363:         js_ReportOverRecursed(cx);
69223:         return NULL;
71363:     }
71363: 
71363:     return limit;
69223: }
69223: 
69223: /*****************************************************************************/
69223: 
69223: JS_ALWAYS_INLINE bool
71695: OOMCheck::operator()(JSContext *cx, StackSpace &space, Value *from, uintN nvals)
69223: {
69223:     return space.ensureSpace(cx, from, nvals);
69223: }
69223: 
69223: JS_ALWAYS_INLINE bool
71695: LimitCheck::operator()(JSContext *cx, StackSpace &space, Value *from, uintN nvals)
69223: {
69223:     /*
69223:      * Include an extra sizeof(StackFrame) to satisfy the method-jit
69223:      * stackLimit invariant.
69223:      */
69223:     nvals += VALUES_PER_STACK_FRAME;
69223:     JS_ASSERT(from < *limit);
69223:     if (*limit - from >= ptrdiff_t(nvals))
69223:         return true;
71363:     return space.tryBumpLimit(cx, from, nvals, limit);
69223: }
69223: 
69223: template <class Check>
69223: JS_ALWAYS_INLINE StackFrame *
71695: ContextStack::getCallFrame(JSContext *cx, const CallArgs &args,
71695:                            JSFunction *fun, JSScript *script,
71695:                            StackFrame::Flags *flags, Check check) const
69223: {
69223:     JS_ASSERT(fun->script() == script);
71695:     JS_ASSERT(space().firstUnused() == args.end());
69223: 
71695:     Value *firstUnused = args.end();
69223:     uintN nvals = VALUES_PER_STACK_FRAME + script->nslots;
69223:     uintN nformal = fun->nargs;
69223: 
69223:     /* Maintain layout invariant: &formalArgs[0] == ((Value *)fp) - nformal. */
69223: 
71695:     if (args.argc() == nformal) {
69223:         if (JS_UNLIKELY(!check(cx, space(), firstUnused, nvals)))
69223:             return NULL;
69223:         return reinterpret_cast<StackFrame *>(firstUnused);
69223:     }
69223: 
71695:     if (args.argc() < nformal) {
71695:         *flags = StackFrame::Flags(*flags | StackFrame::UNDERFLOW_ARGS);
71695:         uintN nmissing = nformal - args.argc();
69223:         if (JS_UNLIKELY(!check(cx, space(), firstUnused, nmissing + nvals)))
69223:             return NULL;
69223:         SetValueRangeToUndefined(firstUnused, nmissing);
69223:         return reinterpret_cast<StackFrame *>(firstUnused + nmissing);
69223:     }
69223: 
71695:     *flags = StackFrame::Flags(*flags | StackFrame::OVERFLOW_ARGS);
69223:     uintN ncopy = 2 + nformal;
69223:     if (JS_UNLIKELY(!check(cx, space(), firstUnused, ncopy + nvals)))
69223:         return NULL;
69223: 
69223:     Value *dst = firstUnused;
71695:     Value *src = args.base();
69223:     PodCopy(dst, src, ncopy);
69223:     return reinterpret_cast<StackFrame *>(firstUnused + ncopy);
69223: }
69223: 
71695: template <class Check>
71695: JS_ALWAYS_INLINE bool
71695: ContextStack::pushInlineFrame(JSContext *cx, FrameRegs &regs, const CallArgs &args,
71695:                               JSObject &callee, JSFunction *fun, JSScript *script,
71695:                               MaybeConstruct construct, Check check)
69223: {
71697:     JS_ASSERT(onTop());
71697:     JS_ASSERT(&regs == &seg_->regs());
71695:     JS_ASSERT(regs.sp == args.end());
71695:     /* Cannot assert callee == args.callee() since this is called from LeaveTree. */
71695:     JS_ASSERT(callee.getFunctionPrivate() == fun);
71695:     JS_ASSERT(fun->script() == script);
69223: 
71695:     StackFrame::Flags flags = ToFrameFlags(construct);
71695:     StackFrame *fp = getCallFrame(cx, args, fun, script, &flags, check);
71695:     if (!fp)
71695:         return false;
71695: 
71695:     /* Initialize frame, locals, regs. */
71695:     fp->initCallFrame(cx, callee, fun, script, args.argc(), flags);
71697:     regs.prepareToRun(*fp, script);
71695:     return true;
69223: }
69223: 
69223: JS_ALWAYS_INLINE StackFrame *
71695: ContextStack::getFixupFrame(JSContext *cx, FrameRegs &regs, const CallArgs &args,
71695:                             JSFunction *fun, JSScript *script, void *ncode,
71695:                             MaybeConstruct construct, LimitCheck check)
69223: {
71697:     JS_ASSERT(onTop());
71695:     JS_ASSERT(&regs == &cx->regs());
71695:     JS_ASSERT(regs.sp == args.end());
71695:     JS_ASSERT(args.callee().getFunctionPrivate() == fun);
71695:     JS_ASSERT(fun->script() == script);
69223: 
71695:     StackFrame::Flags flags = ToFrameFlags(construct);
71695:     StackFrame *fp = getCallFrame(cx, args, fun, script, &flags, check);
71695:     if (!fp)
71695:         return NULL;
69223: 
71695:     /* Do not init late prologue or regs; this is done by jit code. */
71695:     fp->initJitFrameCallerHalf(cx, flags, ncode);
71695:     fp->initJitFrameEarlyPrologue(fun, args.argc());
71695:     return fp;
69223: }
69223: 
69223: JS_ALWAYS_INLINE void
71697: ContextStack::popInlineFrame(FrameRegs &regs)
69223: {
71697:     JS_ASSERT(onTop());
71697:     JS_ASSERT(&regs == &seg_->regs());
69223: 
71697:     StackFrame *fp = regs.fp();
69223:     fp->putActivationObjects();
69223: 
69223:     Value *newsp = fp->actualArgs() - 1;
69223:     JS_ASSERT(newsp >= fp->prev()->base());
69223: 
69223:     newsp[-1] = fp->returnValue();
71697:     regs.popFrame(newsp);
69223: }
69223: 
71697: inline void
71697: ContextStack::popFrameAfterOverflow()
69223: {
71697:     /* Restore the regs to what they were on entry to JSOP_CALL. */
71697:     FrameRegs &regs = seg_->regs();
71697:     StackFrame *fp = regs.fp();
71697:     regs.popFrame(fp->actualArgsEnd());
69223: }
69223: 
70319: namespace detail {
70319: 
70319: struct STATIC_SKIP_INFERENCE CopyNonHoleArgsTo
70319: {
70319:     CopyNonHoleArgsTo(ArgumentsObject *argsobj, Value *dst) : argsobj(*argsobj), dst(dst) {}
70319:     ArgumentsObject &argsobj;
70319:     Value *dst;
70319:     bool operator()(uint32 argi, Value *src) {
70319:         if (argsobj.element(argi).isMagic(JS_ARGS_HOLE))
70319:             return false;
70319:         *dst++ = *src;
70319:         return true;
70319:     }
70319: };
70319: 
70319: } /* namespace detail */
70319: 
70319: inline bool
70319: ArgumentsObject::getElement(uint32 i, Value *vp)
70319: {
70319:     if (i >= initialLength())
70319:         return false;
70319: 
70319:     *vp = element(i);
70319: 
70319:     /*
70319:      * If the argument was overwritten, it could be in any object slot, so we
70319:      * can't optimize.
70319:      */
70319:     if (vp->isMagic(JS_ARGS_HOLE))
70319:         return false;
70319: 
70319:     /*
70319:      * If this arguments object was created on trace the actual argument value
70319:      * could be in a register or something, so we can't optimize.
70319:      */
70319:     StackFrame *fp = reinterpret_cast<StackFrame *>(getPrivate());
70319:     if (fp == JS_ARGUMENTS_OBJECT_ON_TRACE)
70319:         return false;
70319: 
70319:     /*
70319:      * If this arguments object has an associated stack frame, that contains
70319:      * the canonical argument value.  Note that strict arguments objects do not
70319:      * alias named arguments and never have a stack frame.
70319:      */
70319:     JS_ASSERT_IF(isStrictArguments(), !fp);
70319:     if (fp)
70319:         *vp = fp->canonicalActualArg(i);
70319:     return true;
70319: }
70319: 
70319: inline bool
70319: ArgumentsObject::getElements(uint32 start, uint32 count, Value *vp)
70319: {
70319:     JS_ASSERT(start + count >= start);
70319: 
70319:     uint32 length = initialLength();
70319:     if (start > length || start + count > length)
70319:         return false;
70319: 
70319:     StackFrame *fp = reinterpret_cast<StackFrame *>(getPrivate());
70319: 
70319:     /* If there's no stack frame for this, argument values are in elements(). */
70319:     if (!fp) {
70319:         Value *srcbeg = elements() + start;
70319:         Value *srcend = srcbeg + count;
70319:         for (Value *dst = vp, *src = srcbeg; src < srcend; ++dst, ++src) {
70319:             if (src->isMagic(JS_ARGS_HOLE))
70319:                 return false;
70319:             *dst = *src;
70319:         }
70319:         return true;
70319:     }
70319: 
70319:     /* If we're on trace, there's no canonical location for elements: fail. */
70319:     if (fp == JS_ARGUMENTS_OBJECT_ON_TRACE)
70319:         return false;
70319: 
70319:     /* Otherwise, element values are on the stack. */
70319:     JS_ASSERT(fp->numActualArgs() <= JS_ARGS_LENGTH_MAX);
70319:     return fp->forEachCanonicalActualArg(detail::CopyNonHoleArgsTo(this, vp), start, count);
70319: }
70319: 
69223: } /* namespace js */
69223: #endif /* Stack_inl_h__ */
