112662: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
112662:  * vim: set ts=4 sw=4 et tw=99:
111930:  *
113445:  * This Source Code Form is subject to the terms of the Mozilla Public
113445:  * License, v. 2.0. If a copy of the MPL was not distributed with this
113445:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
111930: 
111930: #include "CodeGenerator.h"
111930: #include "IonLinker.h"
112206: #include "IonSpewer.h"
111930: #include "MIRGenerator.h"
111994: #include "shared/CodeGenerator-shared-inl.h"
113388: #include "jsnum.h"
113194: #include "jsmath.h"
112682: #include "jsinterpinlines.h"
111930: 
115132: #include "vm/StringObject-inl.h"
115132: 
111930: using namespace js;
111930: using namespace js::ion;
111930: 
112292: namespace js {
112292: namespace ion {
112292: 
111930: CodeGenerator::CodeGenerator(MIRGenerator *gen, LIRGraph &graph)
111930:   : CodeGeneratorSpecific(gen, graph)
111930: {
111930: }
111930: 
111930: bool
111994: CodeGenerator::visitValueToInt32(LValueToInt32 *lir)
111994: {
111994:     ValueOperand operand = ToValue(lir, LValueToInt32::Input);
111994:     Register output = ToRegister(lir->output());
111994: 
111994:     Label done, simple, isInt32, isBool, notDouble;
111994: 
111994:     // Type-check switch.
112098:     masm.branchTestInt32(Assembler::Equal, operand, &isInt32);
112098:     masm.branchTestBoolean(Assembler::Equal, operand, &isBool);
112098:     masm.branchTestDouble(Assembler::NotEqual, operand, &notDouble);
111994: 
111994:     // If the value is a double, see if it fits in a 32-bit int. We need to ask
111994:     // the platform-specific codegenerator to do this.
111994:     FloatRegister temp = ToFloatRegister(lir->tempFloat());
111994:     masm.unboxDouble(operand, temp);
112035: 
112035:     Label fails;
112044:     switch (lir->mode()) {
112044:       case LValueToInt32::TRUNCATE:
112856:         if (!emitTruncateDouble(temp, output))
112856:             return false;
112044:         break;
112044:       default:
112044:         JS_ASSERT(lir->mode() == LValueToInt32::NORMAL);
112931:         emitDoubleToInt32(temp, output, &fails, lir->mir()->canBeNegativeZero());
112044:         break;
112044:     }
111994:     masm.jump(&done);
111994: 
111994:     masm.bind(&notDouble);
111994: 
112044:     if (lir->mode() == LValueToInt32::NORMAL) {
112044:         // If the value is not null, it's a string, object, or undefined,
112044:         // which we can't handle here.
112098:         masm.branchTestNull(Assembler::NotEqual, operand, &fails);
112044:     } else {
112044:         // Test for string or object - then fallthrough to null, which will
112044:         // also handle undefined.
112098:         masm.branchTestObject(Assembler::Equal, operand, &fails);
112098:         masm.branchTestString(Assembler::Equal, operand, &fails);
112098:     }
112098: 
112098:     if (fails.used() && !bailoutFrom(&fails, lir->snapshot()))
112044:         return false;
111994: 
111994:     // The value is null - just emit 0.
111994:     masm.mov(Imm32(0), output);
111994:     masm.jump(&done);
111994: 
111994:     // Just unbox a bool, the result is 0 or 1.
111994:     masm.bind(&isBool);
111994:     masm.unboxBoolean(operand, output);
111994:     masm.jump(&done);
111994: 
111994:     // Integers can be unboxed.
111994:     masm.bind(&isInt32);
111994:     masm.unboxInt32(operand, output);
111994: 
111994:     masm.bind(&done);
111994: 
111994:     return true;
111994: }
111994: 
111995: static const double DoubleZero = 0.0;
111995: 
111995: bool
111995: CodeGenerator::visitValueToDouble(LValueToDouble *lir)
111995: {
111995:     ValueOperand operand = ToValue(lir, LValueToDouble::Input);
111995:     FloatRegister output = ToFloatRegister(lir->output());
111995: 
111995:     Label isDouble, isInt32, isBool, isNull, done;
111995: 
111995:     // Type-check switch.
112098:     masm.branchTestDouble(Assembler::Equal, operand, &isDouble);
112098:     masm.branchTestInt32(Assembler::Equal, operand, &isInt32);
112098:     masm.branchTestBoolean(Assembler::Equal, operand, &isBool);
112098:     masm.branchTestNull(Assembler::Equal, operand, &isNull);
111995: 
112098:     Assembler::Condition cond = masm.testUndefined(Assembler::NotEqual, operand);
111995:     if (!bailoutIf(cond, lir->snapshot()))
111995:         return false;
111995:     masm.loadStaticDouble(&js_NaN, output);
111995:     masm.jump(&done);
111995: 
111995:     masm.bind(&isNull);
111995:     masm.loadStaticDouble(&DoubleZero, output);
111995:     masm.jump(&done);
111995: 
111995:     masm.bind(&isBool);
111995:     masm.boolValueToDouble(operand, output);
111995:     masm.jump(&done);
111995: 
111995:     masm.bind(&isInt32);
111995:     masm.int32ValueToDouble(operand, output);
111995:     masm.jump(&done);
111995: 
111995:     masm.bind(&isDouble);
111995:     masm.unboxDouble(operand, output);
111995:     masm.bind(&done);
111995: 
111995:     return true;
111995: }
111995: 
111995: bool
111995: CodeGenerator::visitInt32ToDouble(LInt32ToDouble *lir)
111995: {
111995:     masm.convertInt32ToDouble(ToRegister(lir->input()), ToFloatRegister(lir->output()));
111995:     return true;
111995: }
111995: 
111994: bool
112218: CodeGenerator::visitDoubleToInt32(LDoubleToInt32 *lir)
112218: {
112218:     Label fail;
112218:     FloatRegister input = ToFloatRegister(lir->input());
112218:     Register output = ToRegister(lir->output());
112931:     emitDoubleToInt32(input, output, &fail, lir->mir()->canBeNegativeZero());
112218:     if (!bailoutFrom(&fail, lir->snapshot()))
112218:         return false;
112218:     return true;
112218: }
112218: 
112218: bool
112037: CodeGenerator::visitTestVAndBranch(LTestVAndBranch *lir)
112037: {
112037:     const ValueOperand value = ToValue(lir, LTestVAndBranch::Input);
112851:     masm.branchTestValueTruthy(value, lir->ifTrue(), ToFloatRegister(lir->tempFloat()));
112851:     masm.jump(lir->ifFalse());
112037:     return true;
112037: }
112037:  
113368: bool
113430: CodeGenerator::visitPolyInlineDispatch(LPolyInlineDispatch *lir)
113430: {
113430:     MPolyInlineDispatch *mir = lir->mir();
113430:     Register inputReg = ToRegister(lir->input());
113430: 
113482:     InlinePropertyTable *inlinePropTable = mir->inlinePropertyTable();
113482:     if (inlinePropTable) {
113482:         Register tempReg = ToRegister(lir->temp());
113482: 
113482:         masm.loadPtr(Address(inputReg, JSObject::offsetOfType()), tempReg);
113482:         for (size_t i = 0; i < inlinePropTable->numEntries(); i++) {
113482:             types::TypeObject *typeObj = inlinePropTable->getTypeObject(i);
113482:             JSFunction *func = inlinePropTable->getFunction(i);
113482:             LBlock *target = mir->getFunctionBlock(func)->lir();
113482:             masm.branchPtr(Assembler::Equal, tempReg, ImmGCPtr(typeObj), target->label());
113482:         }
113482:         // Jump to fallback block
113482:         LBlock *fallback = mir->fallbackPrepBlock()->lir();
113482:         masm.jump(fallback->label());
113482:     } else {
113430:         for (size_t i = 0; i < mir->numCallees(); i++) {
113431:             JSFunction *func = mir->getFunction(i);
113482:             LBlock *target = mir->getFunctionBlock(i)->lir();
113430:             if (i < mir->numCallees() - 1) {
113430:                 masm.branchPtr(Assembler::Equal, inputReg, ImmGCPtr(func), target->label());
113430:             } else {
113430:                 // Don't generate guard for final case
113430:                 masm.jump(target->label());
113430:             }
113430:         }
113482:     }
113430:     return true;
113430: }
113430: 
113430: bool
112429: CodeGenerator::visitIntToString(LIntToString *lir)
112429: {
115131:     Register input = ToRegister(lir->input());
115131:     Register output = ToRegister(lir->output());
115131: 
114424:     typedef JSFlatString *(*pf)(JSContext *, int);
113218:     static const VMFunction IntToStringInfo = FunctionInfo<pf>(Int32ToString);
112429: 
115131:     OutOfLineCode *ool = oolCallVM(IntToStringInfo, lir, (ArgList(), input),
115131:                                    StoreRegisterTo(output));
115131:     if (!ool)
115131:         return false;
115131: 
115131:     masm.branch32(Assembler::AboveOrEqual, input, Imm32(StaticStrings::INT_STATIC_LIMIT),
115131:                   ool->entry());
115131: 
115131:     masm.movePtr(ImmWord(&gen->compartment->rt->staticStrings.intStaticTable), output);
115131:     masm.loadPtr(BaseIndex(output, input, ScalePointer), output);
115131: 
115131:     masm.bind(ool->rejoin());
115131:     return true;
112541: }
112541: 
112541: bool
112541: CodeGenerator::visitRegExp(LRegExp *lir)
112541: {
113485:     JSObject *proto = lir->mir()->getRegExpPrototype();
112541: 
112541:     typedef JSObject *(*pf)(JSContext *, JSObject *, JSObject *);
112692:     static const VMFunction CloneRegExpObjectInfo = FunctionInfo<pf>(CloneRegExpObject);
112541: 
112541:     pushArg(ImmGCPtr(proto));
112541:     pushArg(ImmGCPtr(lir->mir()->source()));
112692:     return callVM(CloneRegExpObjectInfo, lir);
112429: }
112429: 
112429: bool
113222: CodeGenerator::visitLambdaForSingleton(LLambdaForSingleton *lir)
112691: {
112984:     typedef JSObject *(*pf)(JSContext *, HandleFunction, HandleObject);
112691:     static const VMFunction Info = FunctionInfo<pf>(js::Lambda);
112691: 
112691:     pushArg(ToRegister(lir->scopeChain()));
112691:     pushArg(ImmGCPtr(lir->mir()->fun()));
112691:     return callVM(Info, lir);
112691: }
112691: 
112691: bool
113222: CodeGenerator::visitLambda(LLambda *lir)
113222: {
113222:     Register scopeChain = ToRegister(lir->scopeChain());
113222:     Register output = ToRegister(lir->output());
113485:     JSFunction *fun = lir->mir()->fun();
113222: 
113222:     typedef JSObject *(*pf)(JSContext *, HandleFunction, HandleObject);
113222:     static const VMFunction Info = FunctionInfo<pf>(js::Lambda);
113222: 
113222:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), ImmGCPtr(fun), scopeChain),
113222:                                    StoreRegisterTo(output));
113222:     if (!ool)
113222:         return false;
113222: 
113485:     JS_ASSERT(gen->compartment == fun->compartment());
113222:     JS_ASSERT(!fun->hasSingletonType());
113222: 
113485:     masm.newGCThing(output, fun, ool->entry());
113485:     masm.initGCThing(output, fun);
113222: 
113222:     // Initialize nargs and flags. We do this with a single uint32 to avoid
113222:     // 16-bit writes.
113222:     union {
113222:         struct S {
113222:             uint16_t nargs;
113222:             uint16_t flags;
113222:         } s;
113222:         uint32_t word;
113222:     } u;
113222:     u.s.nargs = fun->nargs;
113222:     u.s.flags = fun->flags & ~JSFUN_EXTENDED;
113222: 
113222:     JS_STATIC_ASSERT(offsetof(JSFunction, flags) == offsetof(JSFunction, nargs) + 2);
113222:     masm.store32(Imm32(u.word), Address(output, offsetof(JSFunction, nargs)));
113485:     masm.storePtr(ImmGCPtr(fun->script()), Address(output, JSFunction::offsetOfNativeOrScript()));
113222:     masm.storePtr(scopeChain, Address(output, JSFunction::offsetOfEnvironment()));
113609:     masm.storePtr(ImmGCPtr(fun->displayAtom()), Address(output, JSFunction::offsetOfAtom()));
113222: 
113222:     masm.bind(ool->rejoin());
113222:     return true;
113222: }
113222: 
113222: bool
112360: CodeGenerator::visitLabel(LLabel *lir)
112360: {
112360:     masm.bind(lir->label());
112360:     return true;
112360: }
112360: 
112360: bool
112444: CodeGenerator::visitNop(LNop *lir)
112444: {
112444:     return true;
112444: }
112444: 
112444: bool
112505: CodeGenerator::visitOsiPoint(LOsiPoint *lir)
112223: {
112505:     // Note: markOsiPoint ensures enough space exists between the last
112505:     // LOsiPoint and this one to patch adjacent call instructions.
112505: 
112505:     JS_ASSERT(masm.framePushed() == frameSize());
112505: 
112924:     uint32 osiCallPointOffset;
112924:     if (!markOsiPoint(lir, &osiCallPointOffset))
112505:         return false;
112505: 
112505:     LSafepoint *safepoint = lir->associatedSafepoint();
112924:     JS_ASSERT(!safepoint->osiCallPointOffset());
112924:     safepoint->setOsiCallPointOffset(osiCallPointOffset);
112223:     return true;
112223: }
112223: 
112223: bool
112317: CodeGenerator::visitGoto(LGoto *lir)
112317: {
112317:     LBlock *target = lir->target()->lir();
112317: 
112317:     // No jump necessary if we can fall through to the next block.
112317:     if (isNextBlock(target))
112317:         return true;
112317: 
112317:     masm.jump(target->label());
112317:     return true;
112317: }
112317: 
112317: bool
112108: CodeGenerator::visitParameter(LParameter *lir)
112108: {
112108:     return true;
112108: }
112108: 
112108: bool
112401: CodeGenerator::visitCallee(LCallee *lir)
112401: {
112401:     return true;
112401: }
112401: 
112401: bool
112108: CodeGenerator::visitStart(LStart *lir)
112108: {
112108:     return true;
112108: }
112108: 
112108: bool
112317: CodeGenerator::visitReturn(LReturn *lir)
112317: {
112317: #if defined(JS_NUNBOX32)
112317:     DebugOnly<LAllocation *> type    = lir->getOperand(TYPE_INDEX);
112317:     DebugOnly<LAllocation *> payload = lir->getOperand(PAYLOAD_INDEX);
112317:     JS_ASSERT(ToRegister(type)    == JSReturnReg_Type);
112317:     JS_ASSERT(ToRegister(payload) == JSReturnReg_Data);
112317: #elif defined(JS_PUNBOX64)
112317:     DebugOnly<LAllocation *> result = lir->getOperand(0);
112317:     JS_ASSERT(ToRegister(result) == JSReturnReg);
112317: #endif
112317:     // Don't emit a jump to the return label if this is the last block.
112317:     if (current->mir() != *gen->graph().poBegin())
112317:         masm.jump(returnLabel_);
112317:     return true;
112317: }
112317: 
112317: bool
112317: CodeGenerator::visitOsrEntry(LOsrEntry *lir)
112219: {
112219:     // Remember the OSR entry offset into the code buffer.
112492:     masm.flushBuffer();
112219:     setOsrEntryOffset(masm.size());
112219: 
112219:     // Allocate the full frame for this function.
112219:     masm.subPtr(Imm32(frameSize()), StackPointer);
112219:     return true;
112219: }
112219: 
112219: bool
112401: CodeGenerator::visitOsrScopeChain(LOsrScopeChain *lir)
112401: {
112401:     const LAllocation *frame   = lir->getOperand(0);
112401:     const LDefinition *object  = lir->getDef(0);
112401: 
112401:     const ptrdiff_t frameOffset = StackFrame::offsetOfScopeChain();
112401: 
112401:     masm.loadPtr(Address(ToRegister(frame), frameOffset), ToRegister(object));
112401:     return true;
112401: }
112401: 
112401: bool
113636: CodeGenerator::visitStackArgT(LStackArgT *lir)
113636: {
113636:     const LAllocation *arg = lir->getArgument();
113636:     MIRType argType = lir->mir()->getArgument()->type();
113636:     uint32 argslot = lir->argslot();
113636: 
113636:     int32 stack_offset = StackOffsetOfPassedArg(argslot);
113636:     Address dest(StackPointer, stack_offset);
113636: 
113636:     if (arg->isFloatReg())
113636:         masm.storeDouble(ToFloatRegister(arg), dest);
113636:     else if (arg->isRegister())
113636:         masm.storeValue(ValueTypeFromMIRType(argType), ToRegister(arg), dest);
113636:     else
113636:         masm.storeValue(*(arg->toConstant()), dest);
113636: 
113636:     return pushedArgumentSlots_.append(StackOffsetToSlot(stack_offset));
113636: }
113636: 
113636: bool
113636: CodeGenerator::visitStackArgV(LStackArgV *lir)
112317: {
112317:     ValueOperand val = ToValue(lir, 0);
112317:     uint32 argslot = lir->argslot();
112317:     int32 stack_offset = StackOffsetOfPassedArg(argslot);
112317: 
112317:     masm.storeValue(val, Address(StackPointer, stack_offset));
113424:     return pushedArgumentSlots_.append(StackOffsetToSlot(stack_offset));
112317: }
112317: 
112317: bool
112317: CodeGenerator::visitInteger(LInteger *lir)
112317: {
112317:     masm.move32(Imm32(lir->getValue()), ToRegister(lir->output()));
112317:     return true;
112317: }
112317: 
112317: bool
112118: CodeGenerator::visitPointer(LPointer *lir)
112118: {
113395:     if (lir->kind() == LPointer::GC_THING)
113395:         masm.movePtr(ImmGCPtr(lir->gcptr()), ToRegister(lir->output()));
113395:     else
113395:         masm.movePtr(ImmWord(lir->ptr()), ToRegister(lir->output()));
112118:     return true;
112118: }
112118: 
112118: bool
112118: CodeGenerator::visitSlots(LSlots *lir)
112118: {
112258:     Address slots(ToRegister(lir->object()), JSObject::offsetOfSlots());
112118:     masm.loadPtr(slots, ToRegister(lir->output()));
112118:     return true;
112118: }
112118: 
112118: bool
112317: CodeGenerator::visitStoreSlotV(LStoreSlotV *store)
112317: {
112317:     Register base = ToRegister(store->slots());
112317:     int32 offset  = store->mir()->slot() * sizeof(Value);
112317: 
112317:     const ValueOperand value = ToValue(store, LStoreSlotV::Value);
112317: 
112726:     if (store->mir()->needsBarrier())
113147:        emitPreBarrier(Address(base, offset), MIRType_Value);
112726: 
112317:     masm.storeValue(value, Address(base, offset));
112317:     return true;
112317: }
112317: 
112317: bool
112258: CodeGenerator::visitElements(LElements *lir)
112258: {
112258:     Address elements(ToRegister(lir->object()), JSObject::offsetOfElements());
112258:     masm.loadPtr(elements, ToRegister(lir->output()));
112258:     return true;
112258: }
112258: 
112258: bool
112401: CodeGenerator::visitFunctionEnvironment(LFunctionEnvironment *lir)
112401: {
112401:     Address environment(ToRegister(lir->function()), JSFunction::offsetOfEnvironment());
112401:     masm.loadPtr(environment, ToRegister(lir->output()));
112401:     return true;
112401: }
112401: 
112401: bool
112118: CodeGenerator::visitTypeBarrier(LTypeBarrier *lir)
112118: {
112118:     ValueOperand operand = ToValue(lir, LTypeBarrier::Input);
112118:     Register scratch = ToRegister(lir->temp());
112118: 
112118:     Label mismatched;
112118:     masm.guardTypeSet(operand, lir->mir()->typeSet(), scratch, &mismatched);
112118:     if (!bailoutFrom(&mismatched, lir->snapshot()))
112118:         return false;
112118:     return true;
112118: }
112118: 
112344: bool
112743: CodeGenerator::visitMonitorTypes(LMonitorTypes *lir)
112743: {
112743:     ValueOperand operand = ToValue(lir, LMonitorTypes::Input);
112743:     Register scratch = ToRegister(lir->temp());
112743: 
112743:     Label mismatched;
112743:     masm.guardTypeSet(operand, lir->mir()->typeSet(), scratch, &mismatched);
112743:     if (!bailoutFrom(&mismatched, lir->snapshot()))
112743:         return false;
112743:     return true;
112743: }
112743: 
112743: bool
112662: CodeGenerator::visitCallNative(LCallNative *call)
112662: {
113575:     JSFunction *target = call->getSingleTarget();
112662:     JS_ASSERT(target);
112662:     JS_ASSERT(target->isNative());
112662: 
112662:     int callargslot = call->argslot();
112662:     int unusedStack = StackOffsetOfPassedArg(callargslot);
112662: 
112662:     // Registers used for callWithABI() argument-passing.
112662:     const Register argJSContextReg = ToRegister(call->getArgJSContextReg());
112662:     const Register argUintNReg     = ToRegister(call->getArgUintNReg());
112662:     const Register argVpReg        = ToRegister(call->getArgVpReg());
112662: 
112662:     // Misc. temporary registers.
112662:     const Register tempReg = ToRegister(call->getTempReg());
112662: 
112662:     DebugOnly<uint32> initialStack = masm.framePushed();
112662: 
112662:     masm.checkStackAlignment();
112662: 
112662:     // Native functions have the signature:
112781:     //  bool (*)(JSContext *, unsigned, Value *vp)
112662:     // Where vp[0] is space for an outparam, vp[1] is |this|, and vp[2] onward
112662:     // are the function arguments.
112662: 
112662:     // Allocate space for the outparam, moving the StackPointer to what will be &vp[1].
112662:     masm.adjustStack(unusedStack);
112662: 
112662:     // Push a Value containing the callee object: natives are allowed to access their callee before
112851:     // setitng the return value. The StackPointer is moved to &vp[0].
112662:     masm.Push(ObjectValue(*target));
112662: 
112662:     // Preload arguments into registers.
112839:     masm.loadJSContext(argJSContextReg);
113196:     masm.move32(Imm32(call->numStackArgs()), argUintNReg);
112662:     masm.movePtr(StackPointer, argVpReg);
112662: 
113196:     masm.Push(argUintNReg);
113196: 
113196:     // Construct native exit frame.
113357:     uint32 safepointOffset;
113357:     if (!masm.buildFakeExitFrame(tempReg, &safepointOffset))
113357:         return false;
113047:     masm.enterFakeExitFrame();
113047: 
112662:     if (!markSafepointAt(safepointOffset, call))
112662:         return false;
112662: 
112662:     // Construct and execute call.
112662:     masm.setupUnalignedABICall(3, tempReg);
112784:     masm.passABIArg(argJSContextReg);
112784:     masm.passABIArg(argUintNReg);
112784:     masm.passABIArg(argVpReg);
112662:     masm.callWithABI(JS_FUNC_TO_DATA_PTR(void *, target->native()));
112662: 
112662:     // Test for failure.
112662:     Label success, exception;
112662:     masm.branchTest32(Assembler::Zero, ReturnReg, ReturnReg, &exception);
112662: 
112662:     // Load the outparam vp[0] into output register(s).
113196:     masm.loadValue(Address(StackPointer, IonNativeExitFrameLayout::offsetOfResult()), JSReturnOperand);
112662:     masm.jump(&success);
112662: 
112662:     // Handle exception case.
112662:     {
112662:         masm.bind(&exception);
112662:         masm.handleException();
112662:     }
112662:     masm.bind(&success);
112662: 
113047:     // The next instruction is removing the footer of the exit frame, so there
113047:     // is no need for leaveFakeExitFrame.
113047: 
113196:     // Move the StackPointer back to its original location, unwinding the native exit frame.
113196:     masm.adjustStack(IonNativeExitFrameLayout::Size() - unusedStack);
112662:     JS_ASSERT(masm.framePushed() == initialStack);
112662: 
113424:     dropArguments(call->numStackArgs() + 1);
112662:     return true;
112662: }
112662: 
112662: bool
113516: CodeGenerator::visitCallDOMNative(LCallDOMNative *call)
113516: {
113575:     JSFunction *target = call->getSingleTarget();
113516:     JS_ASSERT(target);
113516:     JS_ASSERT(target->isNative());
113516:     JS_ASSERT(target->jitInfo());
113516:     JS_ASSERT(call->mir()->isDOMFunction());
113516: 
113516:     int callargslot = call->argslot();
113516:     int unusedStack = StackOffsetOfPassedArg(callargslot);
113516: 
113516:     // Registers used for callWithABI() argument-passing.
113516:     const Register argJSContext = ToRegister(call->getArgJSContext());
113516:     const Register argObj       = ToRegister(call->getArgObj());
113516:     const Register argPrivate   = ToRegister(call->getArgPrivate());
113516:     const Register argArgc      = ToRegister(call->getArgArgc());
113516:     const Register argVp        = ToRegister(call->getArgVp());
113516: 
113516:     DebugOnly<uint32> initialStack = masm.framePushed();
113516: 
113516:     masm.checkStackAlignment();
113516: 
113516:     // DOM methods have the signature:
113516:     //  bool (*)(JSContext *, HandleObject, void *private, unsigned argc, Value *vp)
113516:     // Where vp[0] is space for an outparam and the callee, vp[1] is |this|, and vp[2] onward
113516:     // are the function arguments.
113516: 
113516:     // Nestle the stack up against the pushed arguments, leaving StackPointer at
113516:     // &vp[1]
113516:     masm.adjustStack(unusedStack);
113554:     // argObj is filled with the extracted object, then returned.
113554:     Register obj = masm.extractObject(Address(StackPointer, 0), argObj);
113554:     JS_ASSERT(obj == argObj);
113516: 
113516:     // Push a Value containing the callee object: natives are allowed to access their callee before
113516:     // setitng the return value. The StackPointer is moved to &vp[0].
113516:     masm.Push(ObjectValue(*target));
113516:     masm.movePtr(StackPointer, argVp);
113516: 
113516:     // GetReservedSlot(obj, DOM_PROTO_INSTANCE_CLASS_SLOT).toPrivate()
113516:     masm.loadPrivate(Address(obj, JSObject::getFixedSlotOffset(0)), argPrivate);
113516: 
113516:     // Load argc from the call instruction.
113516:     masm.move32(Imm32(call->numStackArgs()), argArgc);
113516:     // Push argument into what will become the IonExitFrame
113516:     masm.Push(argArgc);
113516: 
113554:     // Push |this| object for passing HandleObject. We push after argc to
113554:     // maintain the same sp-relative location of the object pointer with other
113554:     // DOMExitFrames.
113554:     masm.Push(argObj);
113554:     masm.movePtr(StackPointer, argObj);
113554: 
113516:     // Construct native exit frame.
113516:     uint32 safepointOffset;
113516:     if (!masm.buildFakeExitFrame(argJSContext, &safepointOffset))
113516:         return false;
113554:     masm.enterFakeDOMFrame(ION_FRAME_DOMMETHOD);
113516: 
113516:     if (!markSafepointAt(safepointOffset, call))
113516:         return false;
113516: 
113516:     // Construct and execute call.
113516:     masm.setupUnalignedABICall(5, argJSContext);
113516: 
113516:     masm.loadJSContext(argJSContext);
113516: 
113516:     masm.passABIArg(argJSContext);
113516:     masm.passABIArg(argObj);
113516:     masm.passABIArg(argPrivate);
113516:     masm.passABIArg(argArgc);
113516:     masm.passABIArg(argVp);
113516:     masm.callWithABI(JS_FUNC_TO_DATA_PTR(void *, target->jitInfo()->op));
113516: 
113634:     if (target->jitInfo()->isInfallible) {
113632:         masm.loadValue(Address(StackPointer, IonDOMMethodExitFrameLayout::offsetOfResult()),
113632:                        JSReturnOperand);
113632:     } else {
113516:         // Test for failure.
113516:         Label success, exception;
113516:         masm.branchTest32(Assembler::Zero, ReturnReg, ReturnReg, &exception);
113516: 
113516:         // Load the outparam vp[0] into output register(s).
113632:         masm.loadValue(Address(StackPointer, IonDOMMethodExitFrameLayout::offsetOfResult()),
113632:                        JSReturnOperand);
113516:         masm.jump(&success);
113516: 
113516:         // Handle exception case.
113516:         {
113516:             masm.bind(&exception);
113516:             masm.handleException();
113516:         }
113516:         masm.bind(&success);
113632:     }
113516: 
113516:     // The next instruction is removing the footer of the exit frame, so there
113516:     // is no need for leaveFakeExitFrame.
113516: 
113516:     // Move the StackPointer back to its original location, unwinding the native exit frame.
113554:     masm.adjustStack(IonDOMMethodExitFrameLayout::Size() - unusedStack);
113516:     JS_ASSERT(masm.framePushed() == initialStack);
113516: 
113543:     dropArguments(call->numStackArgs() + 1);
113516:     return true;
113516: }
113516: 
113516: 
113516: bool
113575: CodeGenerator::emitCallInvokeFunction(LInstruction *call, Register calleereg,
113575:                                       uint32 argc, uint32 unusedStack)
113145: {
113145:     typedef bool (*pf)(JSContext *, JSFunction *, uint32, Value *, Value *);
113145:     static const VMFunction InvokeFunctionInfo = FunctionInfo<pf>(InvokeFunction);
113145: 
113145:     // Nestle %esp up to the argument vector.
113145:     // Each path must account for framePushed_ separately, for callVM to be valid.
113145:     masm.freeStack(unusedStack);
113145: 
113145:     pushArg(StackPointer); // argv.
113575:     pushArg(Imm32(argc));  // argc.
113575:     pushArg(calleereg);    // JSFunction *.
113145: 
113145:     if (!callVM(InvokeFunctionInfo, call))
113145:         return false;
113145: 
113145:     // Un-nestle %esp from the argument vector. No prefix was pushed.
113145:     masm.reserveStack(unusedStack);
113145:     return true;
113145: }
113145: 
113145: bool
112344: CodeGenerator::visitCallGeneric(LCallGeneric *call)
112344: {
113575:     Register calleereg = ToRegister(call->getFunction());
113575:     Register objreg    = ToRegister(call->getTempObject());
113575:     Register nargsreg  = ToRegister(call->getNargsReg());
113575:     uint32 unusedStack = StackOffsetOfPassedArg(call->argslot());
113575:     Label invoke, thunk, makeCall, end;
113575: 
113575:     // Known-target case is handled by LCallKnown.
113575:     JS_ASSERT(!call->hasSingleTarget());
113575:     // Unknown constructor case is handled by LCallConstructor.
113575:     JS_ASSERT(!call->mir()->isConstructing());
113575: 
113575:     // Generate an ArgumentsRectifier.
113575:     IonCompartment *ion = gen->ionCompartment();
113575:     IonCode *argumentsRectifier = ion->getArgumentsRectifier(GetIonContext()->cx);
113575:     if (!argumentsRectifier)
113575:         return false;
112344: 
112344:     masm.checkStackAlignment();
112344: 
113575:     // Guard that calleereg is actually a function object.
112344:     masm.loadObjClass(calleereg, nargsreg);
112344:     masm.cmpPtr(nargsreg, ImmWord(&js::FunctionClass));
112344:     if (!bailoutIf(Assembler::NotEqual, call->snapshot()))
112344:         return false;
113575: 
113575:     // Guard that calleereg is a non-native function:
113575:     // Non-native iff (callee->flags & JSFUN_KINDMASK >= JSFUN_INTERPRETED).
113575:     // This is equivalent to testing if any of the bits in JSFUN_KINDMASK are set.
113575:     Address flags(calleereg, offsetof(JSFunction, flags));
113575:     masm.load16ZeroExtend_mask(flags, Imm32(JSFUN_INTERPRETED), nargsreg);
113575:     masm.branch32(Assembler::NotEqual, nargsreg, Imm32(JSFUN_INTERPRETED), &invoke);
113575: 
113575:     // Knowing that calleereg is a non-native function, load the JSScript.
113575:     masm.movePtr(Address(calleereg, offsetof(JSFunction, u.i.script_)), objreg);
113575:     masm.movePtr(Address(objreg, offsetof(JSScript, ion)), objreg);
113575: 
113575:     // Guard that the IonScript has been compiled.
113575:     masm.branchPtr(Assembler::BelowOrEqual, objreg, ImmWord(ION_COMPILING_SCRIPT), &invoke);
113575: 
113575:     // Nestle the StackPointer up to the argument vector.
113575:     masm.freeStack(unusedStack);
113575: 
113575:     // Construct the IonFramePrefix.
113575:     uint32 descriptor = MakeFrameDescriptor(masm.framePushed(), IonFrame_JS);
113575:     masm.Push(Imm32(call->numActualArgs()));
113575:     masm.Push(calleereg);
113575:     masm.Push(Imm32(descriptor));
113575: 
113575:     // Check whether the provided arguments satisfy target argc.
113575:     masm.load16ZeroExtend(Address(calleereg, offsetof(JSFunction, nargs)), nargsreg);
113575:     masm.cmp32(nargsreg, Imm32(call->numStackArgs()));
113575:     masm.j(Assembler::Above, &thunk);
113575: 
113575:     // No argument fixup needed. Load the start of the target IonCode.
113575:     masm.movePtr(Address(objreg, offsetof(IonScript, method_)), objreg);
113575:     masm.movePtr(Address(objreg, IonCode::OffsetOfCode()), objreg);
113575:     masm.jump(&makeCall);
113575: 
113575:     // Argument fixed needed. Load the ArgumentsRectifier.
113575:     masm.bind(&thunk);
113575:     {
113575:         JS_ASSERT(ArgumentsRectifierReg != objreg);
113575:         masm.movePtr(ImmGCPtr(argumentsRectifier), objreg); // Necessary for GC marking.
113575:         masm.movePtr(Address(objreg, IonCode::OffsetOfCode()), objreg);
113575:         masm.move32(Imm32(call->numStackArgs()), ArgumentsRectifierReg);
112674:     }
112344: 
113575:     // Finally call the function in objreg.
113575:     masm.bind(&makeCall);
113593:     uint32 callOffset = masm.callIon(objreg);
113593:     if (!markSafepointAt(callOffset, call))
113575:         return false;
113575: 
113575:     // Increment to remove IonFramePrefix; decrement to fill FrameSizeClass.
113575:     // The return address has already been removed from the Ion frame.
113575:     int prefixGarbage = sizeof(IonJSFrameLayout) - sizeof(void *);
113575:     masm.adjustStack(prefixGarbage - unusedStack);
113575:     masm.jump(&end);
113575: 
113575:     // Handle uncompiled or native functions.
113575:     masm.bind(&invoke);
113575:     if (!emitCallInvokeFunction(call, calleereg, call->numActualArgs(), unusedStack))
113575:         return false;
113575: 
113575:     masm.bind(&end);
113575:     dropArguments(call->numStackArgs() + 1);
113575:     return true;
113575: }
113575: 
113575: bool
113575: CodeGenerator::visitCallKnown(LCallKnown *call)
113575: {
113575:     Register calleereg = ToRegister(call->getFunction());
113575:     Register objreg    = ToRegister(call->getTempObject());
113575:     uint32 unusedStack = StackOffsetOfPassedArg(call->argslot());
113575:     JSFunction *target = call->getSingleTarget();
113575:     Label end, invoke;
113575: 
113575:     // Native single targets are handled by LCallNative.
113575:     JS_ASSERT(!target->isNative());
113575:     // Missing arguments must have been explicitly appended by the IonBuilder.
113575:     JS_ASSERT(target->nargs <= call->numStackArgs());
113575: 
113575:     masm.checkStackAlignment();
113575: 
113145:     // If the function is known to be uncompilable, only emit the call to InvokeFunction.
113575:     if (target->script()->ion == ION_DISABLED_SCRIPT) {
113575:         if (!emitCallInvokeFunction(call, calleereg, call->numActualArgs(), unusedStack))
113485:             return false;
113145: 
113145:         if (call->mir()->isConstructing()) {
113145:             Label notPrimitive;
113145:             masm.branchTestPrimitive(Assembler::NotEqual, JSReturnOperand, &notPrimitive);
113145:             masm.loadValue(Address(StackPointer, unusedStack), JSReturnOperand);
113145:             masm.bind(&notPrimitive);
113145:         }
113145: 
113424:         dropArguments(call->numStackArgs() + 1);
113145:         return true;
113145:     }
113145: 
112344:     // Knowing that calleereg is a non-native function, load the JSScript.
112344:     masm.movePtr(Address(calleereg, offsetof(JSFunction, u.i.script_)), objreg);
112344:     masm.movePtr(Address(objreg, offsetof(JSScript, ion)), objreg);
112344: 
112352:     // Guard that the IonScript has been compiled.
113485:     masm.branchPtr(Assembler::BelowOrEqual, objreg, ImmWord(ION_COMPILING_SCRIPT), &invoke);
112344: 
113575:     // Load the start of the target IonCode.
113575:     masm.movePtr(Address(objreg, offsetof(IonScript, method_)), objreg);
113575:     masm.movePtr(Address(objreg, IonCode::OffsetOfCode()), objreg);
113575: 
113575:     // Nestle the StackPointer up to the argument vector.
112359:     masm.freeStack(unusedStack);
112359: 
112344:     // Construct the IonFramePrefix.
112366:     uint32 descriptor = MakeFrameDescriptor(masm.framePushed(), IonFrame_JS);
113196:     masm.Push(Imm32(call->numActualArgs()));
112344:     masm.Push(calleereg);
112366:     masm.Push(Imm32(descriptor));
112344: 
113168:     // Finally call the function in objreg.
113593:     uint32 callOffset = masm.callIon(objreg);
113593:     if (!markSafepointAt(callOffset, call))
112344:         return false;
112352: 
112344:     // Increment to remove IonFramePrefix; decrement to fill FrameSizeClass.
112344:     // The return address has already been removed from the Ion frame.
112344:     int prefixGarbage = sizeof(IonJSFrameLayout) - sizeof(void *);
112662:     masm.adjustStack(prefixGarbage - unusedStack);
112352:     masm.jump(&end);
112352: 
113575:     // Handle uncompiled functions.
112352:     masm.bind(&invoke);
113575:     if (!emitCallInvokeFunction(call, calleereg, call->numActualArgs(), unusedStack))
113485:         return false;
112352: 
112344:     masm.bind(&end);
112344: 
112874:     // If the return value of the constructing function is Primitive,
112874:     // replace the return value with the Object from CreateThis.
112874:     if (call->mir()->isConstructing()) {
112874:         Label notPrimitive;
112874:         masm.branchTestPrimitive(Assembler::NotEqual, JSReturnOperand, &notPrimitive);
112874:         masm.loadValue(Address(StackPointer, unusedStack), JSReturnOperand);
112874:         masm.bind(&notPrimitive);
112874:     }
112874: 
113424:     dropArguments(call->numStackArgs() + 1);
112874:     return true;
112874: }
112874: 
112874: bool
112874: CodeGenerator::visitCallConstructor(LCallConstructor *call)
112874: {
112874:     JS_ASSERT(call->mir()->isConstructing());
112874: 
112874:     // Holds the function object.
112874:     const LAllocation *callee = call->getFunction();
112874:     Register calleereg = ToRegister(callee);
112874: 
112874:     uint32 callargslot = call->argslot();
112874:     uint32 unusedStack = StackOffsetOfPassedArg(callargslot);
112874: 
113331:     typedef bool (*pf)(JSContext *, JSObject *, uint32, Value *, Value *);
113331:     static const VMFunction InvokeConstructorInfo = FunctionInfo<pf>(ion::InvokeConstructor);
112874: 
112874:     // Nestle %esp up to the argument vector.
112874:     masm.freeStack(unusedStack);
112874: 
112874:     pushArg(StackPointer);                  // argv.
113196:     pushArg(Imm32(call->numActualArgs()));  // argc.
112874:     pushArg(calleereg);                     // JSFunction *.
112874: 
113331:     if (!callVM(InvokeConstructorInfo, call))
112874:         return false;
112874: 
112874:     // Un-nestle %esp from the argument vector. No prefix was pushed.
112874:     masm.reserveStack(unusedStack);
112874: 
113469:     dropArguments(call->numStackArgs() + 1);
112344:     return true;
112344: }
112344: 
113388: bool
113388: CodeGenerator::emitCallInvokeFunction(LApplyArgsGeneric *apply, Register extraStackSize)
113388: {
113388:     Register objreg = ToRegister(apply->getTempObject());
113388:     JS_ASSERT(objreg != extraStackSize);
113388: 
113388:     typedef bool (*pf)(JSContext *, JSFunction *, uint32, Value *, Value *);
113388:     static const VMFunction InvokeFunctionInfo = FunctionInfo<pf>(InvokeFunction);
113388: 
113388:     // Push the space used by the arguments.
113388:     masm.movePtr(StackPointer, objreg);
113388:     masm.Push(extraStackSize);
113388: 
113388:     pushArg(objreg);                           // argv.
113388:     pushArg(ToRegister(apply->getArgc()));     // argc.
113388:     pushArg(ToRegister(apply->getFunction())); // JSFunction *.
113388: 
113388:     // This specialization og callVM restore the extraStackSize after the call.
113388:     if (!callVM(InvokeFunctionInfo, apply, &extraStackSize))
113388:         return false;
113388: 
113388:     masm.Pop(extraStackSize);
113388:     return true;
113388: }
113388: 
113388: // Do not bailout after the execution of this function since the stack no longer
113388: // correspond to what is expected by the snapshots.
113388: void
113388: CodeGenerator::emitPushArguments(LApplyArgsGeneric *apply, Register extraStackSpace)
113388: {
113388:     // Holds the function nargs. Initially undefined.
113388:     Register argcreg = ToRegister(apply->getArgc());
113388: 
113388:     Register copyreg = ToRegister(apply->getTempObject());
113388:     size_t argvOffset = frameSize() + IonJSFrameLayout::offsetOfActualArgs();
113388:     Label end;
113388: 
113388:     // Initialize the loop counter AND Compute the stack usage (if == 0)
113388:     masm.movePtr(argcreg, extraStackSpace);
113388:     masm.branchTestPtr(Assembler::Zero, argcreg, argcreg, &end);
113388: 
113388:     // Copy arguments.
113388:     {
113388:         Register count = extraStackSpace; // <- argcreg
113388:         Label loop;
113388:         masm.bind(&loop);
113388: 
113388:         // We remove sizeof(void*) from argvOffset because withtout it we target
113388:         // the address after the memory area that we want to copy.
113388:         BaseIndex disp(StackPointer, argcreg, ScaleFromShift(sizeof(Value)), argvOffset - sizeof(void*));
113388: 
113388:         // Do not use Push here because other this account to 1 in the framePushed
113388:         // instead of 0.  These push are only counted by argcreg.
113388:         masm.loadPtr(disp, copyreg);
113388:         masm.push(copyreg);
113388: 
113388:         // Handle 32 bits architectures.
113388:         if (sizeof(Value) == 2 * sizeof(void*)) {
113388:             masm.loadPtr(disp, copyreg);
113388:             masm.push(copyreg);
113388:         }
113388: 
113388:         masm.decBranchPtr(Assembler::NonZero, count, Imm32(1), &loop);
113388:     }
113388: 
113388:     // Compute the stack usage.
113388:     masm.movePtr(argcreg, extraStackSpace);
113388:     masm.lshiftPtr(Imm32::ShiftOf(ScaleFromShift(sizeof(Value))), extraStackSpace);
113388: 
113388:     // Join with all arguments copied and the extra stack usage computed.
113388:     masm.bind(&end);
113388: 
113388:     // Push |this|.
113388:     masm.addPtr(Imm32(sizeof(Value)), extraStackSpace);
113388:     masm.pushValue(ToValue(apply, LApplyArgsGeneric::ThisIndex));
113388: }
113388: 
113388: void
113388: CodeGenerator::emitPopArguments(LApplyArgsGeneric *apply, Register extraStackSpace)
113388: {
113388:     // Pop |this| and Arguments.
113388:     masm.freeStack(extraStackSpace);
113388: }
113388: 
113388: bool
113388: CodeGenerator::visitApplyArgsGeneric(LApplyArgsGeneric *apply)
113388: {
113388:     // Holds the function object.
113388:     Register calleereg = ToRegister(apply->getFunction());
113388: 
113388:     // Temporary register for modifying the function object.
113388:     Register objreg = ToRegister(apply->getTempObject());
113388:     Register copyreg = ToRegister(apply->getTempCopy());
113388: 
113388:     // Holds the function nargs. Initially undefined.
113388:     Register argcreg = ToRegister(apply->getArgc());
113388: 
113388:     // Unless already known, guard that calleereg is actually a function object.
113388:     if (!apply->hasSingleTarget()) {
113388:         masm.loadObjClass(calleereg, objreg);
113388:         masm.cmpPtr(objreg, ImmWord(&js::FunctionClass));
113388:         if (!bailoutIf(Assembler::NotEqual, apply->snapshot()))
113388:             return false;
113388:     }
113388: 
113388:     // Copy the arguments of the current function.
113388:     emitPushArguments(apply, copyreg);
113388: 
113388:     masm.checkStackAlignment();
113388: 
113388:     // If the function is known to be uncompilable, only emit the call to InvokeFunction.
113388:     if (apply->hasSingleTarget() &&
113388:         (!apply->getSingleTarget()->isInterpreted() ||
113388:          apply->getSingleTarget()->script()->ion == ION_DISABLED_SCRIPT))
113388:     {
113485:         if (!emitCallInvokeFunction(apply, copyreg))
113485:             return false;
113388:         emitPopArguments(apply, copyreg);
113388:         return true;
113388:     }
113388: 
113388:     Label end, invoke;
113388: 
113388:     // Guard that calleereg is a non-native function:
113388:     // Non-native iff (callee->flags & JSFUN_KINDMASK >= JSFUN_INTERPRETED).
113388:     // This is equivalent to testing if any of the bits in JSFUN_KINDMASK are set.
113388:     if (!apply->hasSingleTarget()) {
113388:         Register kind = objreg;
113388:         Address flags(calleereg, offsetof(JSFunction, flags));
113442:         masm.load16ZeroExtend_mask(flags, Imm32(JSFUN_INTERPRETED), kind);
113442:         masm.branch32(Assembler::NotEqual, kind, Imm32(JSFUN_INTERPRETED), &invoke);
113388:     } else {
113388:         // Native single targets are handled by LCallNative.
113388:         JS_ASSERT(!apply->getSingleTarget()->isNative());
113388:     }
113388: 
113388:     // Knowing that calleereg is a non-native function, load the JSScript.
113388:     masm.movePtr(Address(calleereg, offsetof(JSFunction, u.i.script_)), objreg);
113388:     masm.movePtr(Address(objreg, offsetof(JSScript, ion)), objreg);
113388: 
113388:     // Guard that the IonScript has been compiled.
113485:     masm.branchPtr(Assembler::BelowOrEqual, objreg, ImmWord(ION_COMPILING_SCRIPT), &invoke);
113388: 
113388:     // Call with an Ion frame or a rectifier frame.
113388:     {
113388:         // Create the frame descriptor.
113388:         unsigned pushed = masm.framePushed();
113388:         masm.addPtr(Imm32(pushed), copyreg);
113388:         masm.makeFrameDescriptor(copyreg, IonFrame_JS);
113388: 
113388:         masm.Push(argcreg);
113388:         masm.Push(calleereg);
113388:         masm.Push(copyreg); // descriptor
113388: 
113388:         Label underflow, rejoin;
113388: 
113388:         // Check whether the provided arguments satisfy target argc.
113388:         if (!apply->hasSingleTarget()) {
113388:             masm.load16ZeroExtend(Address(calleereg, offsetof(JSFunction, nargs)), copyreg);
113388:             masm.cmp32(argcreg, copyreg);
113388:             masm.j(Assembler::Below, &underflow);
113388:         } else {
113388:             masm.cmp32(argcreg, Imm32(apply->getSingleTarget()->nargs));
113388:             masm.j(Assembler::Below, &underflow);
113388:         }
113388: 
113388:         // No argument fixup needed. Load the start of the target IonCode.
113388:         {
113388:             masm.movePtr(Address(objreg, offsetof(IonScript, method_)), objreg);
113388:             masm.movePtr(Address(objreg, IonCode::OffsetOfCode()), objreg);
113388: 
113388:             // Skip the construction of the rectifier frame because we have no
113388:             // underflow.
113388:             masm.jump(&rejoin);
113388:         }
113388: 
113388:         // Argument fixup needed. Get ready to call the argumentsRectifier.
113388:         {
113388:             masm.bind(&underflow);
113388: 
113388:             // Hardcode the address of the argumentsRectifier code.
113388:             IonCompartment *ion = gen->ionCompartment();
113485:             IonCode *argumentsRectifier = ion->getArgumentsRectifier(GetIonContext()->cx);
113388:             if (!argumentsRectifier)
113388:                 return false;
113388: 
113388:             JS_ASSERT(ArgumentsRectifierReg != objreg);
114423:             masm.movePtr(ImmGCPtr(argumentsRectifier), objreg); // Necessary for GC marking.
114423:             masm.movePtr(Address(objreg, IonCode::OffsetOfCode()), objreg);
113388:             masm.movePtr(argcreg, ArgumentsRectifierReg);
113388:         }
113388: 
113388:         masm.bind(&rejoin);
113388: 
113388:         // Finally call the function in objreg, as assigned by one of the paths above.
113593:         uint32 callOffset = masm.callIon(objreg);
113593:         if (!markSafepointAt(callOffset, apply))
113388:             return false;
113388: 
113388:         // Recover the number of arguments from the frame descriptor.
113388:         masm.movePtr(Address(StackPointer, 0), copyreg);
113388:         masm.rshiftPtr(Imm32(FRAMESIZE_SHIFT), copyreg);
113388:         masm.subPtr(Imm32(pushed), copyreg);
113388: 
113388:         // Increment to remove IonFramePrefix; decrement to fill FrameSizeClass.
113388:         // The return address has already been removed from the Ion frame.
113388:         int prefixGarbage = sizeof(IonJSFrameLayout) - sizeof(void *);
113388:         masm.adjustStack(prefixGarbage);
113388:         masm.jump(&end);
113388:     }
113388: 
113388:     // Handle uncompiled or native functions.
113388:     {
113388:         masm.bind(&invoke);
113485:         if (!emitCallInvokeFunction(apply, copyreg))
113485:             return false;
113388:     }
113388: 
113388:     // Pop arguments and continue.
113388:     masm.bind(&end);
113388:     emitPopArguments(apply, copyreg);
113388: 
113388:     return true;
113388: }
113388: 
112292: // Registers safe for use before generatePrologue().
112292: static const uint32 EntryTempMask = Registers::TempMask & ~(1 << OsrFrameReg.code());
112292: 
112118: bool
112108: CodeGenerator::generateArgumentsChecks()
112108: {
112108:     MIRGraph &mir = gen->graph();
112108:     MResumePoint *rp = mir.entryResumePoint();
112108: 
112108:     // Reserve the amount of stack the actual frame will use. We have to undo
112108:     // this before falling through to the method proper though, because the
112108:     // monomorphic call case will bypass this entire path.
112108:     masm.reserveStack(frameSize());
112108: 
112108:     // No registers are allocated yet, so it's safe to grab anything.
112292:     Register temp = GeneralRegisterSet(EntryTempMask).getAny();
112108: 
112401:     CompileInfo &info = gen->info();
112401: 
112401:     // Indexes need to be shifted by one, to skip the scope chain slot.
112401:     JS_ASSERT(info.scopeChainSlot() == 0);
112401:     static const uint32 START_SLOT = 1;
112401: 
112108:     Label mismatched;
112401:     for (uint32 i = START_SLOT; i < CountArgSlots(info.fun()); i++) {
112108:         // All initial parameters are guaranteed to be MParameters.
112108:         MParameter *param = rp->getOperand(i)->toParameter();
112108:         types::TypeSet *types = param->typeSet();
112108:         if (!types || types->unknown())
112108:             continue;
112108: 
112108:         // Use ReturnReg as a scratch register here, since not all platforms
112108:         // have an actual ScratchReg.
112401:         int32 offset = ArgToStackOffset((i - START_SLOT) * sizeof(Value));
112108:         masm.guardTypeSet(Address(StackPointer, offset), types, temp, &mismatched);
112108:     }
112108: 
112108:     if (mismatched.used() && !bailoutFrom(&mismatched, graph.entrySnapshot()))
112108:         return false;
112108: 
112108:     masm.freeStack(frameSize());
112108: 
112108:     return true;
112108: }
112108: 
112292: // Out-of-line path to report over-recursed error and fail.
112292: class CheckOverRecursedFailure : public OutOfLineCodeBase<CodeGenerator>
112292: {
112292:     LCheckOverRecursed *lir_;
112292: 
112292:   public:
112292:     CheckOverRecursedFailure(LCheckOverRecursed *lir)
112292:       : lir_(lir)
112292:     { }
112292: 
112292:     bool accept(CodeGenerator *codegen) {
112292:         return codegen->visitCheckOverRecursedFailure(this);
112292:     }
112292: 
112292:     LCheckOverRecursed *lir() const {
112292:         return lir_;
112292:     }
112292: };
112292: 
112292: bool
112292: CodeGenerator::visitCheckOverRecursed(LCheckOverRecursed *lir)
112292: {
112292:     // Ensure that this frame will not cross the stack limit.
112292:     // This is a weak check, justified by Ion using the C stack: we must always
112292:     // be some distance away from the actual limit, since if the limit is
112292:     // crossed, an error must be thrown, which requires more frames.
112292:     //
112292:     // It must always be possible to trespass past the stack limit.
112292:     // Ion may legally place frames very close to the limit. Calling additional
112292:     // C functions may then violate the limit without any checking.
112292: 
113485:     JSRuntime *rt = gen->compartment->rt;
113116:     Register limitReg = ToRegister(lir->limitTemp());
112292: 
112292:     // Since Ion frames exist on the C stack, the stack limit may be
112292:     // dynamically set by JS_SetThreadStackLimit() and JS_SetNativeStackQuota().
112479:     uintptr_t *limitAddr = &rt->ionStackLimit;
112946:     masm.loadPtr(AbsoluteAddress(limitAddr), limitReg);
112292: 
112292:     CheckOverRecursedFailure *ool = new CheckOverRecursedFailure(lir);
112292:     if (!addOutOfLineCode(ool))
112292:         return false;
112292: 
112292:     // Conditional forward (unlikely) branch to failure.
112292:     masm.branchPtr(Assembler::BelowOrEqual, StackPointer, limitReg, ool->entry());
113116:     masm.bind(ool->rejoin());
112292: 
112292:     return true;
112292: }
112292: 
112292: bool
112716: CodeGenerator::visitDefVar(LDefVar *lir)
112716: {
112716:     Register scopeChain = ToRegister(lir->getScopeChain());
112716:     Register nameTemp   = ToRegister(lir->nameTemp());
112716: 
112984:     typedef bool (*pf)(JSContext *, HandlePropertyName, unsigned, HandleObject);
112984:     static const VMFunction DefVarOrConstInfo = FunctionInfo<pf>(DefVarOrConst);
112716: 
113095:     masm.movePtr(ImmGCPtr(lir->mir()->name()), nameTemp);
112716: 
112716:     pushArg(scopeChain); // JSObject *
112781:     pushArg(Imm32(lir->mir()->attrs())); // unsigned
112716:     pushArg(nameTemp); // PropertyName *
112716: 
112716:     if (!callVM(DefVarOrConstInfo, lir))
112716:         return false;
112716: 
112716:     return true;
112716: }
112716: 
112716: bool
112292: CodeGenerator::visitCheckOverRecursedFailure(CheckOverRecursedFailure *ool)
112292: {
112292:     // The OOL path is hit if the recursion depth has been exceeded.
112292:     // Throw an InternalError for over-recursion.
112292: 
112292:     typedef bool (*pf)(JSContext *);
113606:     static const VMFunction CheckOverRecursedInfo =
113606:         FunctionInfo<pf>(CheckOverRecursed);
112292: 
113094:     // LFunctionEnvironment can appear before LCheckOverRecursed, so we have
113606:     // to save all live registers to avoid crashes if CheckOverRecursed triggers
113094:     // a GC.
113094:     saveLive(ool->lir());
113094: 
113606:     if (!callVM(CheckOverRecursedInfo, ool->lir()))
112292:         return false;
112292: 
113116:     restoreLive(ool->lir());
113116:     masm.jump(ool->rejoin());
112292:     return true;
112292: }
112292: 
112108: bool
111930: CodeGenerator::generateBody()
111930: {
111930:     for (size_t i = 0; i < graph.numBlocks(); i++) {
111930:         current = graph.getBlock(i);
111930:         for (LInstructionIterator iter = current->begin(); iter != current->end(); iter++) {
112445:             IonSpew(IonSpew_Codegen, "instruction %s", iter->opName());
113424:             if (iter->safepoint() && pushedArgumentSlots_.length()) {
113424:                 if (!markArgumentSlots(iter->safepoint()))
113424:                     return false;
113424:             }
113424: 
111935:             if (!iter->accept(this))
111936:                 return false;
111930:         }
111935:         if (masm.oom())
111935:             return false;
111930:     }
113469: 
113469:     JS_ASSERT(pushedArgumentSlots_.empty());
111930:     return true;
111930: }
111930: 
112956: // Out-of-line object allocation for LNewArray.
112956: class OutOfLineNewArray : public OutOfLineCodeBase<CodeGenerator>
112956: {
112956:     LNewArray *lir_;
112956: 
112956:   public:
112956:     OutOfLineNewArray(LNewArray *lir)
112956:       : lir_(lir)
112956:     { }
112956: 
112956:     bool accept(CodeGenerator *codegen) {
112956:         return codegen->visitOutOfLineNewArray(this);
112956:     }
112956: 
112956:     LNewArray *lir() const {
112956:         return lir_;
112956:     }
112956: };
112956: 
112956: bool
112956: CodeGenerator::visitNewArrayCallVM(LNewArray *lir)
112956: {
112956:     Register objReg = ToRegister(lir->output());
112956: 
112956:     typedef JSObject *(*pf)(JSContext *, uint32, types::TypeObject *);
112956:     static const VMFunction NewInitArrayInfo = FunctionInfo<pf>(NewInitArray);
112956: 
112956:     JS_ASSERT(!lir->isCall());
112956:     saveLive(lir);
112956: 
113485:     JSObject *templateObject = lir->mir()->templateObject();
113485:     types::TypeObject *type = templateObject->hasSingletonType() ? NULL : templateObject->type();
113485: 
113485:     pushArg(ImmGCPtr(type));
112956:     pushArg(Imm32(lir->mir()->count()));
112956: 
112956:     if (!callVM(NewInitArrayInfo, lir))
112956:         return false;
112956: 
112956:     if (ReturnReg != objReg)
112956:         masm.movePtr(ReturnReg, objReg);
112956: 
112956:     restoreLive(lir);
112956: 
112956:     return true;
112956: }
112956: 
111930: bool
113233: CodeGenerator::visitNewSlots(LNewSlots *lir)
113233: {
113233:     Register temp1 = ToRegister(lir->temp1());
113233:     Register temp2 = ToRegister(lir->temp2());
113233:     Register temp3 = ToRegister(lir->temp3());
113233:     Register output = ToRegister(lir->output());
113233: 
113485:     masm.mov(ImmWord(gen->compartment->rt), temp1);
113233:     masm.mov(Imm32(lir->mir()->nslots()), temp2);
113233: 
113233:     masm.setupUnalignedABICall(2, temp3);
113233:     masm.passABIArg(temp1);
113233:     masm.passABIArg(temp2);
113233:     masm.callWithABI(JS_FUNC_TO_DATA_PTR(void *, NewSlots));
113233: 
113233:     masm.testPtr(output, output);
113233:     if (!bailoutIf(Assembler::Zero, lir->snapshot()))
113233:         return false;
113233: 
113233:     return true;
113233: }
113233: 
113233: bool
112764: CodeGenerator::visitNewArray(LNewArray *lir)
112339: {
112956:     Register objReg = ToRegister(lir->output());
113485:     JSObject *templateObject = lir->mir()->templateObject();
112956:     uint32 count = lir->mir()->count();
112956: 
113333:     JS_ASSERT(count < JSObject::NELEMENTS_LIMIT);
113333: 
112956:     size_t maxArraySlots =
112956:         gc::GetGCKindSlots(gc::FINALIZE_OBJECT_LAST) - ObjectElements::VALUES_PER_HEADER;
112956: 
113529:     // Allocate space using the VMCall
113529:     // when mir hints it needs to get allocated immediatly,
113529:     // but only when data doesn't fit the available array slots.
113529:     bool allocating = lir->mir()->isAllocating() && count > maxArraySlots;
113529: 
113529:     if (templateObject->hasSingletonType() || allocating)
112956:         return visitNewArrayCallVM(lir);
112956: 
112956:     OutOfLineNewArray *ool = new OutOfLineNewArray(lir);
112956:     if (!addOutOfLineCode(ool))
112339:         return false;
112956: 
113485:     masm.newGCThing(objReg, templateObject, ool->entry());
113485:     masm.initGCThing(objReg, templateObject);
113441: 
112956:     masm.bind(ool->rejoin());
112956:     return true;
112956: }
112956: 
112956: bool
112956: CodeGenerator::visitOutOfLineNewArray(OutOfLineNewArray *ool)
112956: {
112956:     if (!visitNewArrayCallVM(ool->lir()))
112956:         return false;
112956:     masm.jump(ool->rejoin());
112339:     return true;
112339: }
112339: 
112955: // Out-of-line object allocation for JSOP_NEWOBJECT.
112955: class OutOfLineNewObject : public OutOfLineCodeBase<CodeGenerator>
112955: {
112955:     LNewObject *lir_;
112955: 
112955:   public:
112955:     OutOfLineNewObject(LNewObject *lir)
112955:       : lir_(lir)
112955:     { }
112955: 
112955:     bool accept(CodeGenerator *codegen) {
112955:         return codegen->visitOutOfLineNewObject(this);
112955:     }
112955: 
112955:     LNewObject *lir() const {
112955:         return lir_;
112955:     }
112955: };
112955: 
112955: bool
112955: CodeGenerator::visitNewObjectVMCall(LNewObject *lir)
112955: {
112955:     Register objReg = ToRegister(lir->output());
112955: 
113485:     typedef JSObject *(*pf)(JSContext *, HandleObject);
112955:     static const VMFunction Info = FunctionInfo<pf>(NewInitObject);
112955: 
112955:     JS_ASSERT(!lir->isCall());
112955:     saveLive(lir);
112955: 
113485:     pushArg(ImmGCPtr(lir->mir()->templateObject()));
112955:     if (!callVM(Info, lir))
112955:         return false;
112955: 
112955:     if (ReturnReg != objReg)
112955:         masm.movePtr(ReturnReg, objReg);
112955: 
112955:     restoreLive(lir);
112955:     return true;
112955: }
112955: 
112339: bool
112764: CodeGenerator::visitNewObject(LNewObject *lir)
112764: {
112955:     Register objReg = ToRegister(lir->output());
112955: 
113485:     JSObject *templateObject = lir->mir()->templateObject();
113485: 
113485:     if (templateObject->hasSingletonType() || templateObject->hasDynamicSlots())
112955:         return visitNewObjectVMCall(lir);
112955: 
112955:     OutOfLineNewObject *ool = new OutOfLineNewObject(lir);
112955:     if (!addOutOfLineCode(ool))
112955:         return false;
112955: 
113485:     masm.newGCThing(objReg, templateObject, ool->entry());
113485:     masm.initGCThing(objReg, templateObject);
113441: 
112955:     masm.bind(ool->rejoin());
112955:     return true;
112955: }
112955: 
112955: bool
112955: CodeGenerator::visitOutOfLineNewObject(OutOfLineNewObject *ool)
112955: {
112955:     if (!visitNewObjectVMCall(ool->lir()))
112955:         return false;
112955:     masm.jump(ool->rejoin());
112955:     return true;
112764: }
112764: 
112976: bool
113175: CodeGenerator::visitNewCallObject(LNewCallObject *lir)
113175: {
113175:     Register obj = ToRegister(lir->output());
113233: 
113614:     typedef JSObject *(*pf)(JSContext *, HandleShape, HandleTypeObject, HeapSlot *);
113175:     static const VMFunction NewCallObjectInfo = FunctionInfo<pf>(NewCallObject);
113175: 
113485:     JSObject *templateObj = lir->mir()->templateObj();
113485: 
113175:     // If we have a template object, we can inline call object creation.
113233:     OutOfLineCode *ool;
113233:     if (lir->slots()->isRegister()) {
113233:         ool = oolCallVM(NewCallObjectInfo, lir,
113233:                         (ArgList(), ImmGCPtr(templateObj->lastProperty()),
113233:                                     ImmGCPtr(templateObj->type()),
113614:                                     ToRegister(lir->slots())),
113175:                         StoreRegisterTo(obj));
113233:     } else {
113233:         ool = oolCallVM(NewCallObjectInfo, lir,
113233:                         (ArgList(), ImmGCPtr(templateObj->lastProperty()),
113233:                                     ImmGCPtr(templateObj->type()),
113614:                                     ImmWord((void *)NULL)),
113233:                         StoreRegisterTo(obj));
113233:     }
113175:     if (!ool)
113175:         return false;
113175: 
113485:     masm.newGCThing(obj, templateObj, ool->entry());
113485:     masm.initGCThing(obj, templateObj);
113441: 
113233:     if (lir->slots()->isRegister())
113233:         masm.storePtr(ToRegister(lir->slots()), Address(obj, JSObject::offsetOfSlots()));
113175:     masm.bind(ool->rejoin());
113175:     return true;
113175: }
113175: 
113175: bool
115132: CodeGenerator::visitNewStringObject(LNewStringObject *lir)
115132: {
115132:     Register input = ToRegister(lir->input());
115132:     Register output = ToRegister(lir->output());
115132:     Register temp = ToRegister(lir->temp());
115132: 
115132:     typedef JSObject *(*pf)(JSContext *, HandleString);
115132:     static const VMFunction NewStringObjectInfo = FunctionInfo<pf>(NewStringObject);
115132: 
115132:     StringObject *templateObj = lir->mir()->templateObj();
115132: 
115132:     OutOfLineCode *ool = oolCallVM(NewStringObjectInfo, lir, (ArgList(), input),
115132:                                    StoreRegisterTo(output));
115132:     if (!ool)
115132:         return false;
115132: 
115132:     masm.newGCThing(output, templateObj, ool->entry());
115132:     masm.initGCThing(output, templateObj);
115132: 
115132:     masm.loadStringLength(input, temp);
115132: 
115132:     masm.storeValue(JSVAL_TYPE_STRING, input, Address(output, StringObject::offsetOfPrimitiveValue()));
115132:     masm.storeValue(JSVAL_TYPE_INT32, temp, Address(output, StringObject::offsetOfLength()));
115132: 
115132:     masm.bind(ool->rejoin());
115132:     return true;
115132: }
115132: 
115132: bool
112976: CodeGenerator::visitInitProp(LInitProp *lir)
112976: {
112976:     Register objReg = ToRegister(lir->getObject());
112976: 
113657:     typedef bool(*pf)(JSContext *, HandleObject, HandlePropertyName, HandleValue);
112976:     static const VMFunction InitPropInfo = FunctionInfo<pf>(InitProp);
112976: 
113003:     pushArg(ToValue(lir, LInitProp::ValueIndex));
113095:     pushArg(ImmGCPtr(lir->mir()->propertyName()));
112976:     pushArg(objReg);
112976: 
112976:     return callVM(InitPropInfo, lir);
112976: }
112976: 
113441: bool
113441: CodeGenerator::visitCreateThis(LCreateThis *lir)
112946: {
113441:     JS_ASSERT(lir->mir()->hasTemplateObject());
113441: 
113485:     JSObject *templateObject = lir->mir()->getTemplateObject();
113441:     gc::AllocKind allocKind = templateObject->getAllocKind();
113441:     int thingSize = (int)gc::Arena::thingSize(allocKind);
113441:     Register objReg = ToRegister(lir->output());
113441: 
113441:     typedef JSObject *(*pf)(JSContext *cx, gc::AllocKind allocKind, size_t thingSize);
113441:     static const VMFunction NewGCThingInfo = FunctionInfo<pf>(js::ion::NewGCThing);
113441: 
113441:     OutOfLineCode *ool = oolCallVM(NewGCThingInfo, lir,
113441:                                    (ArgList(), Imm32(allocKind), Imm32(thingSize)),
113441:                                    StoreRegisterTo(objReg));
113441:     if (!ool)
113441:         return false;
113441: 
113441:     // Allocate. If the FreeList is empty, call to VM, which may GC.
113485:     masm.newGCThing(objReg, templateObject, ool->entry());
113441: 
113441:     // Initialize based on the templateObject.
113441:     masm.bind(ool->rejoin());
113485:     masm.initGCThing(objReg, templateObject);
113441: 
113441:     return true;
112946: }
112946: 
112946: bool
113441: CodeGenerator::visitCreateThisVM(LCreateThisVM *lir)
112946: {
113400:     const LAllocation *proto = lir->getPrototype();
113400:     const LAllocation *callee = lir->getCallee();
113400: 
113400:     typedef JSObject *(*pf)(JSContext *cx, HandleObject callee, JSObject *proto);
113400:     static const VMFunction CreateThisInfo =
113400:         FunctionInfo<pf>(js_CreateThisForFunctionWithProto);
112946: 
113400:     // Push arguments.
113400:     if (proto->isConstant())
113400:         pushArg(ImmGCPtr(&proto->toConstant()->toObject()));
113400:     else
113400:         pushArg(ToRegister(proto));
113400: 
113400:     if (callee->isConstant())
113400:         pushArg(ImmGCPtr(&callee->toConstant()->toObject()));
113400:     else
113400:         pushArg(ToRegister(callee));
112946: 
112946:     if (!callVM(CreateThisInfo, lir))
112946:         return false;
112874:     return true;
112874: }
112874: 
112874: bool
113354: CodeGenerator::visitReturnFromCtor(LReturnFromCtor *lir)
113354: {
113354:     ValueOperand value = ToValue(lir, LReturnFromCtor::ValueIndex);
113354:     Register obj = ToRegister(lir->getObject());
113354:     Register output = ToRegister(lir->output());
113354: 
113354:     Label valueIsObject, end;
113354: 
113354:     masm.branchTestObject(Assembler::Equal, value, &valueIsObject);
113354: 
113354:     // Value is not an object. Return that other object.
113354:     masm.movePtr(obj, output);
113354:     masm.jump(&end);
113354: 
113354:     // Value is an object. Return unbox(Value).
113354:     masm.bind(&valueIsObject);
113354:     Register payload = masm.extractObject(value, output);
113354:     if (payload != output)
113354:         masm.movePtr(payload, output);
113354: 
113354:     masm.bind(&end);
113354:     return true;
113354: }
113354: 
113354: bool
112309: CodeGenerator::visitArrayLength(LArrayLength *lir)
112309: {
112309:     Address length(ToRegister(lir->elements()), ObjectElements::offsetOfLength());
112309:     masm.load32(length, ToRegister(lir->output()));
112309:     return true;
112309: }
112309: 
112309: bool
112867: CodeGenerator::visitTypedArrayLength(LTypedArrayLength *lir)
112867: {
112867:     Register obj = ToRegister(lir->object());
112867:     Register out = ToRegister(lir->output());
112867:     masm.unboxInt32(Address(obj, TypedArray::lengthOffset()), out);
112867:     return true;
112867: }
112867: 
112867: bool
112904: CodeGenerator::visitTypedArrayElements(LTypedArrayElements *lir)
112904: {
112904:     Register obj = ToRegister(lir->object());
112904:     Register out = ToRegister(lir->output());
112904:     masm.loadPtr(Address(obj, TypedArray::dataOffset()), out);
112904:     return true;
112904: }
112904: 
112904: bool
112309: CodeGenerator::visitStringLength(LStringLength *lir)
112309: {
115132:     Register input = ToRegister(lir->string());
112309:     Register output = ToRegister(lir->output());
112309: 
115132:     masm.loadStringLength(input, output);
112309:     return true;
112309: }
112309: 
112429: bool
113532: CodeGenerator::visitMinMaxI(LMinMaxI *ins)
113532: {
113532:     Register first = ToRegister(ins->first());
113532:     Register output = ToRegister(ins->output());
113532: 
113532:     JS_ASSERT(first == output);
113532: 
113532:     if (ins->second()->isConstant())
113532:         masm.cmp32(first, Imm32(ToInt32(ins->second())));
113532:     else
113532:         masm.cmp32(first, ToRegister(ins->second()));
113532: 
113532:     Label done;
113532:     if (ins->mir()->isMax())
113532:         masm.j(Assembler::GreaterThan, &done);
113532:     else
113532:         masm.j(Assembler::LessThan, &done);
113532: 
113532:     if (ins->second()->isConstant())
113532:         masm.move32(Imm32(ToInt32(ins->second())), output);
113532:     else
113532:         masm.mov(ToRegister(ins->second()), output);
113532: 
113532: 
113532:     masm.bind(&done);
113532:     return true;
113532: }
113532: 
113532: bool
112655: CodeGenerator::visitAbsI(LAbsI *ins)
112655: {
112655:     Register input = ToRegister(ins->input());
112655:     Label positive;
112655: 
112655:     JS_ASSERT(input == ToRegister(ins->output()));
112655:     masm.test32(input, input);
112655:     masm.j(Assembler::GreaterThanOrEqual, &positive);
112655:     masm.neg32(input);
113635:     if (ins->snapshot() && !bailoutIf(Assembler::Overflow, ins->snapshot()))
112655:         return false;
112655:     masm.bind(&positive);
112655: 
112655:     return true;
112655: }
112655: 
112655: bool
113476: CodeGenerator::visitPowI(LPowI *ins)
113476: {
113478:     FloatRegister value = ToFloatRegister(ins->value());
114189:     Register power = ToRegister(ins->power());
113476:     Register temp = ToRegister(ins->temp());
113476: 
114189:     JS_ASSERT(power != temp);
114189: 
113476:     // In all implementations, setupUnalignedABICall() relinquishes use of
113476:     // its scratch register. We can therefore save an input register by
113476:     // reusing the scratch register to pass constants to callWithABI.
113476:     masm.setupUnalignedABICall(2, temp);
113478:     masm.passABIArg(value);
114189:     masm.passABIArg(power);
113476: 
113476:     masm.callWithABI(JS_FUNC_TO_DATA_PTR(void *, js::powi), MacroAssembler::DOUBLE);
113476:     JS_ASSERT(ToFloatRegister(ins->output()) == ReturnFloatReg);
113476: 
113476:     return true;
113476: }
113476: 
113476: bool
113476: CodeGenerator::visitPowD(LPowD *ins)
113476: {
113478:     FloatRegister value = ToFloatRegister(ins->value());
113476:     FloatRegister power = ToFloatRegister(ins->power());
113476:     Register temp = ToRegister(ins->temp());
113476: 
113476:     masm.setupUnalignedABICall(2, temp);
113478:     masm.passABIArg(value);
113476:     masm.passABIArg(power);
113476:     masm.callWithABI(JS_FUNC_TO_DATA_PTR(void *, ecmaPow), MacroAssembler::DOUBLE);
113476: 
113476:     JS_ASSERT(ToFloatRegister(ins->output()) == ReturnFloatReg);
113476:     return true;
113476: }
113476: 
113476: bool
113194: CodeGenerator::visitMathFunctionD(LMathFunctionD *ins)
113194: {
113457:     Register temp = ToRegister(ins->temp());
113194:     FloatRegister input = ToFloatRegister(ins->input());
113194:     JS_ASSERT(ToFloatRegister(ins->output()) == ReturnFloatReg);
113194: 
113485:     MathCache *mathCache = ins->mir()->cache();
113194: 
113194:     masm.setupUnalignedABICall(2, temp);
113194:     masm.movePtr(ImmWord(mathCache), temp);
113194:     masm.passABIArg(temp);
113194:     masm.passABIArg(input);
113194: 
113194:     void *funptr = NULL;
113194:     switch (ins->mir()->function()) {
113194:       case MMathFunction::Log:
113194:         funptr = JS_FUNC_TO_DATA_PTR(void *, js::math_log_impl);
113194:         break;
113194:       case MMathFunction::Sin:
113194:         funptr = JS_FUNC_TO_DATA_PTR(void *, js::math_sin_impl);
113194:         break;
113194:       case MMathFunction::Cos:
113194:         funptr = JS_FUNC_TO_DATA_PTR(void *, js::math_cos_impl);
113194:         break;
113194:       case MMathFunction::Tan:
113194:         funptr = JS_FUNC_TO_DATA_PTR(void *, js::math_tan_impl);
113194:         break;
113194:       default:
113194:         JS_NOT_REACHED("Unknown math function");
113194:     }
113194: 
113194:     masm.callWithABI(funptr, MacroAssembler::DOUBLE);
113194:     return true;
113194: }
113194: 
113194: bool
113467: CodeGenerator::visitModD(LModD *ins)
113467: {
113467:     FloatRegister lhs = ToFloatRegister(ins->lhs());
113467:     FloatRegister rhs = ToFloatRegister(ins->rhs());
113467:     Register temp = ToRegister(ins->temp());
113467: 
113467:     JS_ASSERT(ToFloatRegister(ins->output()) == ReturnFloatReg);
113467: 
113467:     masm.setupUnalignedABICall(2, temp);
113467:     masm.passABIArg(lhs);
113467:     masm.passABIArg(rhs);
113467: 
113467:     masm.callWithABI(JS_FUNC_TO_DATA_PTR(void *, NumberMod), MacroAssembler::DOUBLE);
113467:     return true;
113467: }
113467: 
113467: bool
112471: CodeGenerator::visitBinaryV(LBinaryV *lir)
112429: {
113461:     typedef bool (*pf)(JSContext *, HandleScript, jsbytecode *, HandleValue, HandleValue, Value *);
112494:     static const VMFunction AddInfo = FunctionInfo<pf>(js::AddValues);
112494:     static const VMFunction SubInfo = FunctionInfo<pf>(js::SubValues);
112494:     static const VMFunction MulInfo = FunctionInfo<pf>(js::MulValues);
112494:     static const VMFunction DivInfo = FunctionInfo<pf>(js::DivValues);
112494:     static const VMFunction ModInfo = FunctionInfo<pf>(js::ModValues);
112970:     static const VMFunction UrshInfo = FunctionInfo<pf>(js::UrshValues);
112471: 
112471:     pushArg(ToValue(lir, LBinaryV::RhsInput));
112471:     pushArg(ToValue(lir, LBinaryV::LhsInput));
113461:     pushArg(ImmWord(lir->mirRaw()->toInstruction()->resumePoint()->pc()));
113461:     pushArg(ImmGCPtr(current->mir()->info().script()));
112494: 
112494:     switch (lir->jsop()) {
112494:       case JSOP_ADD:
112494:         return callVM(AddInfo, lir);
112494: 
112494:       case JSOP_SUB:
112494:         return callVM(SubInfo, lir);
112494: 
112494:       case JSOP_MUL:
112494:         return callVM(MulInfo, lir);
112494: 
112494:       case JSOP_DIV:
112494:         return callVM(DivInfo, lir);
112494: 
112494:       case JSOP_MOD:
112494:         return callVM(ModInfo, lir);
112494: 
112970:       case JSOP_URSH:
112970:         return callVM(UrshInfo, lir);
112970: 
112494:       default:
112494:         JS_NOT_REACHED("Unexpected binary op");
112494:         return false;
112494:     }
112494: }
112494: 
112494: bool
113209: CodeGenerator::visitCompareS(LCompareS *lir)
113209: {
113428:     JSOp op = lir->mir()->jsop();
113209:     Register left = ToRegister(lir->left());
113209:     Register right = ToRegister(lir->right());
113209:     Register output = ToRegister(lir->output());
113209: 
113209:     typedef bool (*pf)(JSContext *, HandleString, HandleString, JSBool *);
113209:     static const VMFunction stringsEqualInfo = FunctionInfo<pf>(ion::StringsEqual<true>);
113209:     static const VMFunction stringsNotEqualInfo = FunctionInfo<pf>(ion::StringsEqual<false>);
113209: 
113209:     OutOfLineCode *ool = NULL;
113209:     if (op == JSOP_EQ || op == JSOP_STRICTEQ) {
113209:         ool = oolCallVM(stringsEqualInfo, lir, (ArgList(), left, right),  StoreRegisterTo(output));
113209:     } else {
113209:         JS_ASSERT(op == JSOP_NE || op == JSOP_STRICTNE);
113209:         ool = oolCallVM(stringsNotEqualInfo, lir, (ArgList(), left, right), StoreRegisterTo(output));
113209:     }
113209: 
113209:     if (!ool)
113209:         return false;
113209: 
113209:     Label notPointerEqual;
113209:     // Fast path for identical strings
113209:     masm.branchPtr(Assembler::NotEqual, left, right, &notPointerEqual);
113209:     masm.move32(Imm32(op == JSOP_EQ || op == JSOP_STRICTEQ), output);
113209:     masm.jump(ool->rejoin());
113209: 
113209:     masm.bind(&notPointerEqual);
113209: 
113218:     // JSString::isAtom === !(lengthAndFlags & ATOM_MASK)
113571:     Imm32 atomMask(JSString::ATOM_BIT);
113209: 
113209:     // This optimization is only correct for atomized strings,
113209:     // so we need to jump to the ool path.
113572:     masm.branchTest32(Assembler::Zero, Address(left, JSString::offsetOfLengthAndFlags()), 
113209:                       atomMask, ool->entry());
113209: 
113572:     masm.branchTest32(Assembler::Zero, Address(right, JSString::offsetOfLengthAndFlags()), 
113209:                       atomMask, ool->entry());
113209: 
113209:     masm.cmpPtr(left, right);
113209:     emitSet(JSOpToCondition(op), output);
113209: 
113209:     masm.bind(ool->rejoin());
113209:     return true;
113209: }
113209: 
113209: bool
112494: CodeGenerator::visitCompareV(LCompareV *lir)
112494: {
113657:     typedef bool (*pf)(JSContext *, HandleValue, HandleValue, JSBool *);
112494:     static const VMFunction EqInfo = FunctionInfo<pf>(ion::LooselyEqual<true>);
112494:     static const VMFunction NeInfo = FunctionInfo<pf>(ion::LooselyEqual<false>);
112494:     static const VMFunction StrictEqInfo = FunctionInfo<pf>(ion::StrictlyEqual<true>);
112494:     static const VMFunction StrictNeInfo = FunctionInfo<pf>(ion::StrictlyEqual<false>);
112494:     static const VMFunction LtInfo = FunctionInfo<pf>(ion::LessThan);
112494:     static const VMFunction LeInfo = FunctionInfo<pf>(ion::LessThanOrEqual);
112494:     static const VMFunction GtInfo = FunctionInfo<pf>(ion::GreaterThan);
112494:     static const VMFunction GeInfo = FunctionInfo<pf>(ion::GreaterThanOrEqual);
112494: 
112494:     pushArg(ToValue(lir, LBinaryV::RhsInput));
112494:     pushArg(ToValue(lir, LBinaryV::LhsInput));
112494: 
113356:     switch (lir->mir()->jsop()) {
112494:       case JSOP_EQ:
112494:         return callVM(EqInfo, lir);
112494: 
112494:       case JSOP_NE:
112494:         return callVM(NeInfo, lir);
112494: 
112494:       case JSOP_STRICTEQ:
112494:         return callVM(StrictEqInfo, lir);
112494: 
112494:       case JSOP_STRICTNE:
112494:         return callVM(StrictNeInfo, lir);
112494: 
112494:       case JSOP_LT:
112494:         return callVM(LtInfo, lir);
112494: 
112494:       case JSOP_LE:
112494:         return callVM(LeInfo, lir);
112494: 
112494:       case JSOP_GT:
112494:         return callVM(GtInfo, lir);
112494: 
112494:       case JSOP_GE:
112494:         return callVM(GeInfo, lir);
112494: 
112494:       default:
112494:         JS_NOT_REACHED("Unexpected compare op");
112494:         return false;
112494:     }
112429: }
112429: 
112429: bool
112737: CodeGenerator::visitIsNullOrUndefined(LIsNullOrUndefined *lir)
112737: {
112737:     JSOp op = lir->mir()->jsop();
112737:     MIRType specialization = lir->mir()->specialization();
112737:     JS_ASSERT(IsNullOrUndefined(specialization));
112737: 
112737:     const ValueOperand value = ToValue(lir, LIsNullOrUndefined::Value);
112737:     Register output = ToRegister(lir->output());
112737: 
112737:     if (op == JSOP_EQ || op == JSOP_NE) {
112737:         Register tag = masm.splitTagForTest(value);
112737: 
112737:         Label nullOrUndefined, done;
112737:         masm.branchTestNull(Assembler::Equal, tag, &nullOrUndefined);
112737:         masm.branchTestUndefined(Assembler::Equal, tag, &nullOrUndefined);
112737: 
112737:         masm.move32(Imm32(op == JSOP_NE), output);
112737:         masm.jump(&done);
112737: 
112737:         masm.bind(&nullOrUndefined);
112737:         masm.move32(Imm32(op == JSOP_EQ), output);
112737:         masm.bind(&done);
112737:         return true;
112737:     }
112737: 
112737:     JS_ASSERT(op == JSOP_STRICTEQ || op == JSOP_STRICTNE);
112737: 
112737:     Assembler::Condition cond = JSOpToCondition(op);
112737:     if (specialization == MIRType_Null)
112737:         cond = masm.testNull(cond, value);
112737:     else
112737:         cond = masm.testUndefined(cond, value);
112737: 
112737:     emitSet(cond, output);
112737:     return true;
112737: }
112737: 
112737: bool
112737: CodeGenerator::visitIsNullOrUndefinedAndBranch(LIsNullOrUndefinedAndBranch *lir)
112737: {
112737:     JSOp op = lir->mir()->jsop();
112737:     MIRType specialization = lir->mir()->specialization();
112737:     JS_ASSERT(IsNullOrUndefined(specialization));
112737: 
112737:     const ValueOperand value = ToValue(lir, LIsNullOrUndefinedAndBranch::Value);
112737: 
112737:     if (op == JSOP_EQ || op == JSOP_NE) {
112737:         MBasicBlock *ifTrue;
112737:         MBasicBlock *ifFalse;
112737: 
112737:         if (op == JSOP_EQ) {
112737:             ifTrue = lir->ifTrue();
112737:             ifFalse = lir->ifFalse();
112737:         } else {
112737:             // Swap branches.
112737:             ifTrue = lir->ifFalse();
112737:             ifFalse = lir->ifTrue();
112737:             op = JSOP_EQ;
112737:         }
112737: 
112737:         Register tag = masm.splitTagForTest(value);
112737:         masm.branchTestNull(Assembler::Equal, tag, ifTrue->lir()->label());
112737: 
112737:         Assembler::Condition cond = masm.testUndefined(Assembler::Equal, tag);
112737:         emitBranch(cond, ifTrue, ifFalse);
112737:         return true;
112737:     }
112737: 
112737:     JS_ASSERT(op == JSOP_STRICTEQ || op == JSOP_STRICTNE);
112737: 
112737:     Assembler::Condition cond = JSOpToCondition(op);
112737:     if (specialization == MIRType_Null)
112737:         cond = masm.testNull(cond, value);
112737:     else
112737:         cond = masm.testUndefined(cond, value);
112737: 
112737:     emitBranch(cond, lir->ifTrue(), lir->ifFalse());
112737:     return true;
112737: }
112737: 
112737: bool
112429: CodeGenerator::visitConcat(LConcat *lir)
112429: {
112984:     typedef JSString *(*pf)(JSContext *, HandleString, HandleString);
112429:     static const VMFunction js_ConcatStringsInfo = FunctionInfo<pf>(js_ConcatStrings);
112429: 
112429:     pushArg(ToRegister(lir->rhs()));
112429:     pushArg(ToRegister(lir->lhs()));
112429:     if (!callVM(js_ConcatStringsInfo, lir))
112429:         return false;
112429:     return true;
112429: }
112309: 
112309: bool
112728: CodeGenerator::visitCharCodeAt(LCharCodeAt *lir)
112728: {
112728:     Register str = ToRegister(lir->str());
112728:     Register index = ToRegister(lir->index());
112728:     Register output = ToRegister(lir->output());
112728: 
112728:     typedef bool (*pf)(JSContext *, JSString *);
112728:     static const VMFunction ensureLinearInfo = FunctionInfo<pf>(JSString::ensureLinear);
112728:     OutOfLineCode *ool = oolCallVM(ensureLinearInfo, lir, (ArgList(), str), StoreNothing());
112728:     if (!ool)
112728:         return false;
112728: 
112728:     Address lengthAndFlagsAddr(str, JSString::offsetOfLengthAndFlags());
112728:     masm.loadPtr(lengthAndFlagsAddr, output);
112728: 
113571:     masm.branchTest32(Assembler::Zero, output, Imm32(JSString::FLAGS_MASK), ool->entry());
112728:     masm.bind(ool->rejoin());
112728: 
112728:     // getChars
112728:     Address charsAddr(str, JSString::offsetOfChars());
112728:     masm.loadPtr(charsAddr, output);
112967:     masm.load16ZeroExtend(BaseIndex(output, index, TimesTwo, 0), output);
112728: 
112728:     return true;
112728: }
112728: 
112728: bool
112728: CodeGenerator::visitFromCharCode(LFromCharCode *lir)
112728: {
112728:     Register code = ToRegister(lir->code());
112728:     Register output = ToRegister(lir->output());
112728: 
114424:     typedef JSFlatString *(*pf)(JSContext *, int32_t);
114246:     static const VMFunction Info = FunctionInfo<pf>(ion::StringFromCharCode);
114246:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), code), StoreRegisterTo(output));
112728:     if (!ool)
112728:         return false;
112728: 
114246:     // OOL path if code >= UNIT_STATIC_LIMIT.
114246:     masm.branch32(Assembler::AboveOrEqual, code, Imm32(StaticStrings::UNIT_STATIC_LIMIT),
114246:                   ool->entry());
114246: 
113485:     masm.movePtr(ImmWord(&gen->compartment->rt->staticStrings.unitStaticTable), output);
112728:     masm.loadPtr(BaseIndex(output, code, ScalePointer), output);
114246: 
112728:     masm.bind(ool->rejoin());
112728:     return true;
112728: }
112728: 
112728: bool
112231: CodeGenerator::visitInitializedLength(LInitializedLength *lir)
112231: {
112258:     Address initLength(ToRegister(lir->elements()), ObjectElements::offsetOfInitializedLength());
112236:     masm.load32(initLength, ToRegister(lir->output()));
112231:     return true;
112231: }
112231: 
112231: bool
112734: CodeGenerator::visitSetInitializedLength(LSetInitializedLength *lir)
112734: {
112734:     Address initLength(ToRegister(lir->elements()), ObjectElements::offsetOfInitializedLength());
112734:     Int32Key index = ToInt32Key(lir->index());
112734: 
112734:     masm.bumpKey(&index, 1);
112734:     masm.storeKey(index, initLength);
112734:     // Restore register value if it is used/captured after.
112734:     masm.bumpKey(&index, -1);
112734:     return true;
112734: }
112734: 
112734: bool
112851: CodeGenerator::visitNotV(LNotV *lir)
112696: {
112851:     Label setFalse;
112851:     Label join;
112851:     masm.branchTestValueTruthy(ToValue(lir, LNotV::Input), &setFalse, ToFloatRegister(lir->tempFloat()));
112851: 
112851:     // fallthrough to set true
112851:     masm.move32(Imm32(1), ToRegister(lir->getDef(0)));
112851:     masm.jump(&join);
112851: 
112851:     // true case rediercts to setFalse
112851:     masm.bind(&setFalse);
112851:     masm.move32(Imm32(0), ToRegister(lir->getDef(0)));
112851: 
112851:     // both branches meet here.
112851:     masm.bind(&join);
112851:     return true;
112696: }
112696: 
112696: bool
112488: CodeGenerator::visitBoundsCheck(LBoundsCheck *lir)
112488: {
113395:     if (lir->index()->isConstant()) {
113481:         // Use uint32_t so that the comparison is unsigned.
113481:         uint32_t index = ToInt32(lir->index());
113395:         if (lir->length()->isConstant()) {
113481:             uint32_t length = ToInt32(lir->length());
113395:             if (index < length)
113395:                 return true;
113395:             return bailout(lir->snapshot());
113395:         }
113645:         masm.cmp32(ToOperand(lir->length()), Imm32(index));
113395:         return bailoutIf(Assembler::BelowOrEqual, lir->snapshot());
113395:     }
113395:     if (lir->length()->isConstant()) {
113395:         masm.cmp32(ToRegister(lir->index()), Imm32(ToInt32(lir->length())));
113433:         return bailoutIf(Assembler::AboveOrEqual, lir->snapshot());
113395:     }
113645:     masm.cmp32(ToOperand(lir->length()), ToRegister(lir->index()));
112488:     return bailoutIf(Assembler::BelowOrEqual, lir->snapshot());
112488: }
112488: 
112488: bool
112488: CodeGenerator::visitBoundsCheckRange(LBoundsCheckRange *lir)
112488: {
112488:     int32 min = lir->mir()->minimum();
112488:     int32 max = lir->mir()->maximum();
112488:     JS_ASSERT(max >= min);
112488: 
112488:     Register temp = ToRegister(lir->getTemp(0));
112488:     if (lir->index()->isConstant()) {
112488:         int32 nmin, nmax;
112488:         int32 index = ToInt32(lir->index());
112488:         if (SafeAdd(index, min, &nmin) && SafeAdd(index, max, &nmax) && nmin >= 0) {
113645:             masm.cmp32(ToOperand(lir->length()), Imm32(nmax));
112488:             return bailoutIf(Assembler::BelowOrEqual, lir->snapshot());
112488:         }
112488:         masm.mov(Imm32(index), temp);
112488:     } else {
112488:         masm.mov(ToRegister(lir->index()), temp);
112488:     }
112488: 
112488:     // If the minimum and maximum differ then do an underflow check first.
112488:     // If the two are the same then doing an unsigned comparison on the
112488:     // length will also catch a negative index.
112488:     if (min != max) {
112488:         if (min != 0) {
112488:             masm.add32(Imm32(min), temp);
112488:             if (!bailoutIf(Assembler::Overflow, lir->snapshot()))
112488:                 return false;
112488:             int32 diff;
112488:             if (SafeSub(max, min, &diff))
112488:                 max = diff;
112488:             else
112488:                 masm.sub32(Imm32(min), temp);
112488:         }
112488: 
112488:         masm.cmp32(temp, Imm32(0));
112488:         if (!bailoutIf(Assembler::LessThan, lir->snapshot()))
112488:             return false;
112488:     }
112488: 
112488:     // Compute the maximum possible index. No overflow check is needed when
112488:     // max > 0. We can only wraparound to a negative number, which will test as
112488:     // larger than all nonnegative numbers in the unsigned comparison, and the
112488:     // length is required to be nonnegative (else testing a negative length
112488:     // would succeed on any nonnegative index).
112488:     if (max != 0) {
112488:         masm.add32(Imm32(max), temp);
112488:         if (max < 0 && !bailoutIf(Assembler::Overflow, lir->snapshot()))
112488:             return false;
112488:     }
112488: 
113645:     masm.cmp32(ToOperand(lir->length()), temp);
112488:     return bailoutIf(Assembler::BelowOrEqual, lir->snapshot());
112488: }
112488: 
112488: bool
112488: CodeGenerator::visitBoundsCheckLower(LBoundsCheckLower *lir)
112488: {
112488:     int32 min = lir->mir()->minimum();
112488:     masm.cmp32(ToRegister(lir->index()), Imm32(min));
112488:     return bailoutIf(Assembler::LessThan, lir->snapshot());
112488: }
112488: 
112524: class OutOfLineStoreElementHole : public OutOfLineCodeBase<CodeGenerator>
112524: {
112524:     LInstruction *ins_;
112524:     Label rejoinStore_;
112524: 
112524:   public:
112524:     OutOfLineStoreElementHole(LInstruction *ins)
112524:       : ins_(ins)
112524:     {
112524:         JS_ASSERT(ins->isStoreElementHoleV() || ins->isStoreElementHoleT());
112524:     }
112524: 
112524:     bool accept(CodeGenerator *codegen) {
112524:         return codegen->visitOutOfLineStoreElementHole(this);
112524:     }
112524:     LInstruction *ins() const {
112524:         return ins_;
112524:     }
112524:     Label *rejoinStore() {
112524:         return &rejoinStore_;
112524:     }
112524: };
112524: 
112524: bool
112524: CodeGenerator::visitStoreElementT(LStoreElementT *store)
112524: {
112726:     if (store->mir()->needsBarrier())
112726:        emitPreBarrier(ToRegister(store->elements()), store->index(), store->mir()->elementType());
112726: 
112524:     storeElementTyped(store->value(), store->mir()->value()->type(), store->mir()->elementType(),
112524:                       ToRegister(store->elements()), store->index());
112524:     return true;
112524: }
112524: 
112524: bool
112524: CodeGenerator::visitStoreElementV(LStoreElementV *lir)
112524: {
112524:     const ValueOperand value = ToValue(lir, LStoreElementV::Value);
112524:     Register elements = ToRegister(lir->elements());
112524: 
112726:     if (lir->mir()->needsBarrier())
112726:         emitPreBarrier(elements, lir->index(), MIRType_Value);
112726: 
112524:     if (lir->index()->isConstant())
112524:         masm.storeValue(value, Address(elements, ToInt32(lir->index()) * sizeof(js::Value)));
112524:     else
112524:         masm.storeValue(value, BaseIndex(elements, ToRegister(lir->index()), TimesEight));
112524:     return true;
112524: }
112524: 
112524: bool
112524: CodeGenerator::visitStoreElementHoleT(LStoreElementHoleT *lir)
112524: {
112524:     OutOfLineStoreElementHole *ool = new OutOfLineStoreElementHole(lir);
112524:     if (!addOutOfLineCode(ool))
112524:         return false;
112524: 
112524:     Register elements = ToRegister(lir->elements());
112524:     const LAllocation *index = lir->index();
112524: 
112524:     // OOL path if index >= initializedLength.
112524:     Address initLength(elements, ObjectElements::offsetOfInitializedLength());
112524:     masm.branchKey(Assembler::BelowOrEqual, initLength, ToInt32Key(index), ool->entry());
112524: 
112726:     if (lir->mir()->needsBarrier())
112726:         emitPreBarrier(elements, index, lir->mir()->elementType());
112726: 
112524:     masm.bind(ool->rejoinStore());
112524:     storeElementTyped(lir->value(), lir->mir()->value()->type(), lir->mir()->elementType(),
112524:                       elements, index);
112524: 
112524:     masm.bind(ool->rejoin());
112524:     return true;
112524: }
112524: 
112524: bool
112524: CodeGenerator::visitStoreElementHoleV(LStoreElementHoleV *lir)
112524: {
112524:     OutOfLineStoreElementHole *ool = new OutOfLineStoreElementHole(lir);
112524:     if (!addOutOfLineCode(ool))
112524:         return false;
112524: 
112524:     Register elements = ToRegister(lir->elements());
112524:     const LAllocation *index = lir->index();
112524:     const ValueOperand value = ToValue(lir, LStoreElementHoleV::Value);
112524: 
112524:     // OOL path if index >= initializedLength.
112524:     Address initLength(elements, ObjectElements::offsetOfInitializedLength());
112524:     masm.branchKey(Assembler::BelowOrEqual, initLength, ToInt32Key(index), ool->entry());
112524: 
112726:     if (lir->mir()->needsBarrier())
112726:         emitPreBarrier(elements, index, lir->mir()->elementType());
112726: 
112524:     masm.bind(ool->rejoinStore());
112524:     if (lir->index()->isConstant())
112524:         masm.storeValue(value, Address(elements, ToInt32(lir->index()) * sizeof(js::Value)));
112524:     else
112524:         masm.storeValue(value, BaseIndex(elements, ToRegister(lir->index()), TimesEight));
112524: 
112524:     masm.bind(ool->rejoin());
112524:     return true;
112524: }
112524: 
112524: bool
112524: CodeGenerator::visitOutOfLineStoreElementHole(OutOfLineStoreElementHole *ool)
112524: {
112524:     Register object, elements;
112524:     LInstruction *ins = ool->ins();
112524:     const LAllocation *index;
112524:     MIRType valueType;
112524:     ConstantOrRegister value;
112524: 
112524:     if (ins->isStoreElementHoleV()) {
112524:         LStoreElementHoleV *store = ins->toStoreElementHoleV();
112524:         object = ToRegister(store->object());
112524:         elements = ToRegister(store->elements());
112524:         index = store->index();
112524:         valueType = store->mir()->value()->type();
112524:         value = TypedOrValueRegister(ToValue(store, LStoreElementHoleV::Value));
112524:     } else {
112524:         LStoreElementHoleT *store = ins->toStoreElementHoleT();
112524:         object = ToRegister(store->object());
112524:         elements = ToRegister(store->elements());
112524:         index = store->index();
112524:         valueType = store->mir()->value()->type();
112524:         if (store->value()->isConstant())
112524:             value = ConstantOrRegister(*store->value()->toConstant());
112524:         else
112524:             value = TypedOrValueRegister(valueType, ToAnyRegister(store->value()));
112524:     }
112524: 
112524:     // If index == initializedLength, try to bump the initialized length inline.
112524:     // If index > initializedLength, call a stub. Note that this relies on the
112524:     // condition flags sticking from the incoming branch.
112524:     Label callStub;
112524:     masm.j(Assembler::NotEqual, &callStub);
112524: 
112524:     Int32Key key = ToInt32Key(index);
112524: 
112524:     // Check array capacity.
112524:     masm.branchKey(Assembler::BelowOrEqual, Address(elements, ObjectElements::offsetOfCapacity()),
112524:                    key, &callStub);
112524: 
112524:     // Update initialized length. The capacity guard above ensures this won't overflow,
112524:     // due to NELEMENTS_LIMIT.
112524:     masm.bumpKey(&key, 1);
112524:     masm.storeKey(key, Address(elements, ObjectElements::offsetOfInitializedLength()));
112524: 
112524:     // Update length if length < initializedLength.
112524:     Label dontUpdate;
112524:     masm.branchKey(Assembler::AboveOrEqual, Address(elements, ObjectElements::offsetOfLength()),
112524:                    key, &dontUpdate);
112524:     masm.storeKey(key, Address(elements, ObjectElements::offsetOfLength()));
112524:     masm.bind(&dontUpdate);
112524: 
112524:     masm.bumpKey(&key, -1);
112524: 
112524:     if (ins->isStoreElementHoleT() && valueType != MIRType_Double) {
112524:         // The inline path for StoreElementHoleT does not always store the type tag,
112524:         // so we do the store on the OOL path. We use MIRType_None for the element type
112524:         // so that storeElementTyped will always store the type tag.
112524:         storeElementTyped(ins->toStoreElementHoleT()->value(), valueType, MIRType_None, elements,
112524:                           index);
112524:         masm.jump(ool->rejoin());
112524:     } else {
112524:         // Jump to the inline path where we will store the value.
112524:         masm.jump(ool->rejoinStore());
112524:     }
112524: 
112524:     masm.bind(&callStub);
112524:     saveLive(ins);
112524: 
113545:     typedef bool (*pf)(JSContext *, HandleObject, HandleValue, HandleValue, JSBool strict);
112524:     static const VMFunction Info = FunctionInfo<pf>(SetObjectElement);
112524: 
112780:     pushArg(Imm32(current->mir()->strictModeCode()));
112524:     pushArg(value);
112524:     if (index->isConstant())
112524:         pushArg(*index->toConstant());
112524:     else
112524:         pushArg(TypedOrValueRegister(MIRType_Int32, ToAnyRegister(index)));
112524:     pushArg(object);
112524:     if (!callVM(Info, ins))
112524:         return false;
112524: 
112524:     restoreLive(ins);
112524:     masm.jump(ool->rejoin());
112524:     return true;
112524: }
112524: 
112488: bool
112949: CodeGenerator::emitArrayPopShift(LInstruction *lir, const MArrayPopShift *mir, Register obj,
112949:                                  Register elementsTemp, Register lengthTemp, TypedOrValueRegister out)
112949: {
112949:     OutOfLineCode *ool;
113966:     typedef bool (*pf)(JSContext *, HandleObject, MutableHandleValue);
112949: 
112949:     if (mir->mode() == MArrayPopShift::Pop) {
112949:         static const VMFunction Info = FunctionInfo<pf>(ion::ArrayPopDense);
112949:         ool = oolCallVM(Info, lir, (ArgList(), obj), StoreValueTo(out));
112949:         if (!ool)
112949:             return false;
112949:     } else {
112949:         JS_ASSERT(mir->mode() == MArrayPopShift::Shift);
112949:         static const VMFunction Info = FunctionInfo<pf>(ion::ArrayShiftDense);
112949:         ool = oolCallVM(Info, lir, (ArgList(), obj), StoreValueTo(out));
112949:         if (!ool)
112949:             return false;
112949:     }
112949: 
113147:     // VM call if a write barrier is necessary.
113147:     masm.branchTestNeedsBarrier(Assembler::NonZero, lengthTemp, ool->entry());
113147: 
112949:     // Load elements and length.
112949:     masm.loadPtr(Address(obj, JSObject::offsetOfElements()), elementsTemp);
112949:     masm.load32(Address(elementsTemp, ObjectElements::offsetOfLength()), lengthTemp);
112949: 
112949:     // VM call if length != initializedLength.
112949:     Int32Key key = Int32Key(lengthTemp);
112949:     Address initLength(elementsTemp, ObjectElements::offsetOfInitializedLength());
112949:     masm.branchKey(Assembler::NotEqual, initLength, key, ool->entry());
112949: 
112949:     // Test for length != 0. On zero length either take a VM call or generate
112949:     // an undefined value, depending on whether the call is known to produce
112949:     // undefined.
112949:     Label done;
112949:     if (mir->maybeUndefined()) {
112949:         Label notEmpty;
112949:         masm.branchTest32(Assembler::NonZero, lengthTemp, lengthTemp, &notEmpty);
112949:         masm.moveValue(UndefinedValue(), out.valueReg());
112949:         masm.jump(&done);
112949:         masm.bind(&notEmpty);
112949:     } else {
112949:         masm.branchTest32(Assembler::Zero, lengthTemp, lengthTemp, ool->entry());
112949:     }
112949: 
112949:     masm.bumpKey(&key, -1);
112949: 
112949:     if (mir->mode() == MArrayPopShift::Pop) {
112949:         masm.loadElementTypedOrValue(BaseIndex(elementsTemp, lengthTemp, TimesEight), out,
112949:                                      mir->needsHoleCheck(), ool->entry());
112949:     } else {
112949:         JS_ASSERT(mir->mode() == MArrayPopShift::Shift);
112949:         masm.loadElementTypedOrValue(Address(elementsTemp, 0), out, mir->needsHoleCheck(),
112949:                                      ool->entry());
112949:     }
112949: 
112949:     masm.store32(lengthTemp, Address(elementsTemp, ObjectElements::offsetOfLength()));
112949:     masm.store32(lengthTemp, Address(elementsTemp, ObjectElements::offsetOfInitializedLength()));
112949: 
112949:     if (mir->mode() == MArrayPopShift::Shift) {
112949:         // Don't save the temp registers.
112949:         RegisterSet temps;
112949:         temps.add(elementsTemp);
112949:         temps.add(lengthTemp);
112949: 
112949:         saveVolatile(temps);
112949:         masm.setupUnalignedABICall(1, lengthTemp);
112949:         masm.passABIArg(obj);
112949:         masm.callWithABI(JS_FUNC_TO_DATA_PTR(void *, js::ArrayShiftMoveElements));
112949:         restoreVolatile(temps);
112949:     }
112949: 
112949:     masm.bind(&done);
112949:     masm.bind(ool->rejoin());
112949:     return true;
112949: }
112949: 
112949: bool
112949: CodeGenerator::visitArrayPopShiftV(LArrayPopShiftV *lir)
112949: {
112949:     Register obj = ToRegister(lir->object());
112949:     Register elements = ToRegister(lir->temp0());
112949:     Register length = ToRegister(lir->temp1());
112949:     TypedOrValueRegister out(ToOutValue(lir));
112949:     return emitArrayPopShift(lir, lir->mir(), obj, elements, length, out);
112949: }
112949: 
112949: bool
112949: CodeGenerator::visitArrayPopShiftT(LArrayPopShiftT *lir)
112949: {
112949:     Register obj = ToRegister(lir->object());
112949:     Register elements = ToRegister(lir->temp0());
112949:     Register length = ToRegister(lir->temp1());
112949:     TypedOrValueRegister out(lir->mir()->type(), ToAnyRegister(lir->output()));
112949:     return emitArrayPopShift(lir, lir->mir(), obj, elements, length, out);
112949: }
112949: 
112949: bool
112950: CodeGenerator::emitArrayPush(LInstruction *lir, const MArrayPush *mir, Register obj,
112950:                              ConstantOrRegister value, Register elementsTemp, Register length)
112950: {
113966:     typedef bool (*pf)(JSContext *, HandleObject, HandleValue, uint32_t *);
112950:     static const VMFunction Info = FunctionInfo<pf>(ion::ArrayPushDense);
112950:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), obj, value), StoreRegisterTo(length));
112950:     if (!ool)
112950:         return false;
112950: 
112950:     // Load elements and length.
112950:     masm.loadPtr(Address(obj, JSObject::offsetOfElements()), elementsTemp);
112950:     masm.load32(Address(elementsTemp, ObjectElements::offsetOfLength()), length);
112950: 
112950:     Int32Key key = Int32Key(length);
112950:     Address initLength(elementsTemp, ObjectElements::offsetOfInitializedLength());
112950:     Address capacity(elementsTemp, ObjectElements::offsetOfCapacity());
112950: 
112950:     // Guard length == initializedLength.
112950:     masm.branchKey(Assembler::NotEqual, initLength, key, ool->entry());
112950: 
112950:     // Guard length < capacity.
112950:     masm.branchKey(Assembler::BelowOrEqual, capacity, key, ool->entry());
112950: 
112950:     masm.storeConstantOrRegister(value, BaseIndex(elementsTemp, length, TimesEight));
112950: 
112950:     masm.bumpKey(&key, 1);
112950:     masm.store32(length, Address(elementsTemp, ObjectElements::offsetOfLength()));
112950:     masm.store32(length, Address(elementsTemp, ObjectElements::offsetOfInitializedLength()));
112950: 
112950:     masm.bind(ool->rejoin());
112950:     return true;
112950: }
112950: 
112950: bool
112950: CodeGenerator::visitArrayPushV(LArrayPushV *lir)
112950: {
112950:     Register obj = ToRegister(lir->object());
112950:     Register elementsTemp = ToRegister(lir->temp());
112950:     Register length = ToRegister(lir->output());
112950:     ConstantOrRegister value = TypedOrValueRegister(ToValue(lir, LArrayPushV::Value));
112950:     return emitArrayPush(lir, lir->mir(), obj, value, elementsTemp, length);
112950: }
112950: 
112950: bool
112950: CodeGenerator::visitArrayPushT(LArrayPushT *lir)
112950: {
112950:     Register obj = ToRegister(lir->object());
112950:     Register elementsTemp = ToRegister(lir->temp());
112950:     Register length = ToRegister(lir->output());
112950:     ConstantOrRegister value;
112950:     if (lir->value()->isConstant())
112950:         value = ConstantOrRegister(*lir->value()->toConstant());
112950:     else
112950:         value = TypedOrValueRegister(lir->mir()->value()->type(), ToAnyRegister(lir->value()));
112950:     return emitArrayPush(lir, lir->mir(), obj, value, elementsTemp, length);
112950: }
112950: 
112950: bool
112663: CodeGenerator::visitCallIteratorStart(LCallIteratorStart *lir)
112663: {
112984:     typedef JSObject *(*pf)(JSContext *, HandleObject, uint32_t);
112663:     static const VMFunction Info = FunctionInfo<pf>(GetIteratorObject);
112663: 
112663:     pushArg(Imm32(lir->mir()->flags()));
112839:     pushArg(ToRegister(lir->object()));
112663:     return callVM(Info, lir);
112663: }
112663: 
112663: bool
112839: CodeGenerator::visitIteratorStart(LIteratorStart *lir)
112663: {
112839:     const Register obj = ToRegister(lir->object());
112839:     const Register output = ToRegister(lir->output());
112839: 
112839:     uint32_t flags = lir->mir()->flags();
112839: 
112984:     typedef JSObject *(*pf)(JSContext *, HandleObject, uint32_t);
112839:     static const VMFunction Info = FunctionInfo<pf>(GetIteratorObject);
112839: 
112839:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), obj, Imm32(flags)), StoreRegisterTo(output));
112839:     if (!ool)
112839:         return false;
112839: 
112839:     const Register temp1 = ToRegister(lir->temp1());
112839:     const Register temp2 = ToRegister(lir->temp2());
112839:     const Register niTemp = ToRegister(lir->temp3()); // Holds the NativeIterator object.
112839: 
112839:     // Iterators other than for-in should use LCallIteratorStart.
112839:     JS_ASSERT(flags == JSITER_ENUMERATE);
112839: 
112839:     // Fetch the most recent iterator and ensure it's not NULL.
113485:     masm.loadPtr(AbsoluteAddress(&gen->compartment->rt->nativeIterCache.last), output);
112839:     masm.branchTestPtr(Assembler::Zero, output, output, ool->entry());
112839: 
112839:     // Load NativeIterator.
112839:     masm.loadObjPrivate(output, JSObject::ITER_CLASS_NFIXED_SLOTS, niTemp);
112839: 
112839:     // Ensure the |active| and |unreusable| bits are not set.
112839:     masm.branchTest32(Assembler::NonZero, Address(niTemp, offsetof(NativeIterator, flags)),
112839:                       Imm32(JSITER_ACTIVE|JSITER_UNREUSABLE), ool->entry());
112839: 
112839:     // Load the iterator's shape array.
112839:     masm.loadPtr(Address(niTemp, offsetof(NativeIterator, shapes_array)), temp2);
112839: 
112839:     // Compare shape of object with the first shape.
112839:     masm.loadObjShape(obj, temp1);
112839:     masm.branchPtr(Assembler::NotEqual, Address(temp2, 0), temp1, ool->entry());
112839: 
112839:     // Compare shape of object's prototype with the second shape.
112839:     masm.loadObjProto(obj, temp1);
112839:     masm.loadObjShape(temp1, temp1);
112839:     masm.branchPtr(Assembler::NotEqual, Address(temp2, sizeof(Shape *)), temp1, ool->entry());
112839: 
112839:     // Ensure the object's prototype's prototype is NULL. The last native iterator
112839:     // will always have a prototype chain length of one (i.e. it must be a plain
112839:     // object), so we do not need to generate a loop here.
112839:     masm.loadObjProto(obj, temp1);
112839:     masm.loadObjProto(temp1, temp1);
112839:     masm.branchTestPtr(Assembler::NonZero, temp1, temp1, ool->entry());
112839: 
112839:     // Write barrier for stores to the iterator. We only need to take a write
112839:     // barrier if NativeIterator::obj is actually going to change.
113147:     {
113147:         Label noBarrier;
113147:         masm.branchTestNeedsBarrier(Assembler::Zero, temp1, &noBarrier);
113147: 
113147:         Address objAddr(niTemp, offsetof(NativeIterator, obj));
113147:         masm.branchPtr(Assembler::NotEqual, objAddr, obj, ool->entry());
113147: 
113147:         masm.bind(&noBarrier);
112839:     }
112839: 
112839:     // Mark iterator as active.
112839:     masm.storePtr(obj, Address(niTemp, offsetof(NativeIterator, obj)));
112839:     masm.or32(Imm32(JSITER_ACTIVE), Address(niTemp, offsetof(NativeIterator, flags)));
112839: 
112839:     // Chain onto the active iterator stack.
112839:     masm.loadJSContext(temp1);
112839:     masm.loadPtr(Address(temp1, offsetof(JSContext, enumerators)), temp2);
112839:     masm.storePtr(temp2, Address(niTemp, offsetof(NativeIterator, next)));
112839:     masm.storePtr(output, Address(temp1, offsetof(JSContext, enumerators)));
112839: 
112839:     masm.bind(ool->rejoin());
112839:     return true;
112839: }
112839: 
112839: static void
112839: LoadNativeIterator(MacroAssembler &masm, Register obj, Register dest, Label *failures)
112839: {
112839:     JS_ASSERT(obj != dest);
112839: 
112839:     // Test class.
113448:     masm.branchTestObjClass(Assembler::NotEqual, obj, dest, &PropertyIteratorObject::class_, failures);
112839: 
112839:     // Load NativeIterator object.
112839:     masm.loadObjPrivate(obj, JSObject::ITER_CLASS_NFIXED_SLOTS, dest);
112839: }
112839: 
112839: bool
112839: CodeGenerator::visitIteratorNext(LIteratorNext *lir)
112839: {
112839:     const Register obj = ToRegister(lir->object());
112839:     const Register temp = ToRegister(lir->temp());
112839:     const ValueOperand output = ToOutValue(lir);
112839: 
114858:     typedef bool (*pf)(JSContext *, HandleObject, MutableHandleValue);
112663:     static const VMFunction Info = FunctionInfo<pf>(js_IteratorNext);
112663: 
112839:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), obj), StoreValueTo(output));
112839:     if (!ool)
112663:         return false;
112663: 
112839:     LoadNativeIterator(masm, obj, temp, ool->entry());
112839: 
113074:     masm.branchTest32(Assembler::NonZero, Address(temp, offsetof(NativeIterator, flags)),
113074:                       Imm32(JSITER_FOREACH), ool->entry());
113074: 
112839:     // Get cursor, next string.
112839:     masm.loadPtr(Address(temp, offsetof(NativeIterator, props_cursor)), output.scratchReg());
112839:     masm.loadPtr(Address(output.scratchReg(), 0), output.scratchReg());
112839:     masm.tagValue(JSVAL_TYPE_STRING, output.scratchReg(), output);
112839: 
112839:     // Increase the cursor.
112839:     masm.addPtr(Imm32(sizeof(JSString *)), Address(temp, offsetof(NativeIterator, props_cursor)));
112839: 
112839:     masm.bind(ool->rejoin());
112663:     return true;
112663: }
112663: 
112663: bool
112839: CodeGenerator::visitIteratorMore(LIteratorMore *lir)
112663: {
112839:     const Register obj = ToRegister(lir->object());
112839:     const Register output = ToRegister(lir->output());
112839:     const Register temp = ToRegister(lir->temp());
112839: 
112984:     typedef bool (*pf)(JSContext *, HandleObject, JSBool *);
112839:     static const VMFunction Info = FunctionInfo<pf>(ion::IteratorMore);
112839:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), obj), StoreRegisterTo(output));
112839:     if (!ool)
112839:         return false;
112839: 
112839:     LoadNativeIterator(masm, obj, output, ool->entry());
112839: 
113074:     masm.branchTest32(Assembler::NonZero, Address(output, offsetof(NativeIterator, flags)),
113074:                       Imm32(JSITER_FOREACH), ool->entry());
113074: 
112839:     // Set output to true if props_cursor < props_end.
112839:     masm.loadPtr(Address(output, offsetof(NativeIterator, props_end)), temp);
112839:     masm.cmpPtr(Address(output, offsetof(NativeIterator, props_cursor)), temp);
112839:     emitSet(Assembler::LessThan, output);
112839: 
112839:     masm.bind(ool->rejoin());
112839:     return true;
112839: }
112839: 
112839: bool
112839: CodeGenerator::visitIteratorEnd(LIteratorEnd *lir)
112839: {
112839:     const Register obj = ToRegister(lir->object());
112839:     const Register temp1 = ToRegister(lir->temp1());
112839:     const Register temp2 = ToRegister(lir->temp2());
112839: 
114858:     typedef bool (*pf)(JSContext *, HandleObject);
112971:     static const VMFunction Info = FunctionInfo<pf>(CloseIterator);
112663: 
112839:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), obj), StoreNothing());
112839:     if (!ool)
112839:         return false;
112839: 
112839:     LoadNativeIterator(masm, obj, temp1, ool->entry());
112839: 
113074:     masm.branchTest32(Assembler::Zero, Address(temp1, offsetof(NativeIterator, flags)),
113074:                       Imm32(JSITER_ENUMERATE), ool->entry());
113074: 
112839:     // Clear active bit.
112839:     masm.and32(Imm32(~JSITER_ACTIVE), Address(temp1, offsetof(NativeIterator, flags)));
112839: 
112839:     // Reset property cursor.
112839:     masm.loadPtr(Address(temp1, offsetof(NativeIterator, props_array)), temp2);
112839:     masm.storePtr(temp2, Address(temp1, offsetof(NativeIterator, props_cursor)));
112839: 
112839:     // Advance enumerators list.
112839:     masm.loadJSContext(temp2);
112839:     masm.loadPtr(Address(temp1, offsetof(NativeIterator, next)), temp1);
112839:     masm.storePtr(temp1, Address(temp2, offsetof(JSContext, enumerators)));
112839: 
112839:     masm.bind(ool->rejoin());
112839:     return true;
112663: }
112663: 
112663: bool
113199: CodeGenerator::visitArgumentsLength(LArgumentsLength *lir)
113199: {
113199:     // read number of actual arguments from the JS frame.
113199:     Register argc = ToRegister(lir->output());
113200:     Address ptr(StackPointer, frameSize() + IonJSFrameLayout::offsetOfNumActualArgs());
113200: 
113199:     masm.movePtr(ptr, argc);
113199:     return true;
113199: }
113199: 
113199: bool
113200: CodeGenerator::visitGetArgument(LGetArgument *lir)
113200: {
113200:     ValueOperand result = GetValueOutput(lir);
113200:     const LAllocation *index = lir->index();
113200:     size_t argvOffset = frameSize() + IonJSFrameLayout::offsetOfActualArgs();
113200: 
113200:     if (index->isConstant()) {
113200:         int32 i = index->toConstant()->toInt32();
113208:         Address argPtr(StackPointer, sizeof(Value) * i + argvOffset);
113200:         masm.loadValue(argPtr, result);
113200:     } else {
113200:         Register i = ToRegister(index);
113208:         BaseIndex argPtr(StackPointer, i, ScaleFromShift(sizeof(Value)), argvOffset);
113200:         masm.loadValue(argPtr, result);
113200:     }
113200:     return true;
113200: }
113200: 
113200: bool
111930: CodeGenerator::generate()
111930: {
113485:     JSContext *cx = GetIonContext()->cx;
111935: 
113424:     unsigned slots = graph.localSlotCount() +
113424:                      (graph.argumentSlotCount() * sizeof(Value) / STACK_SLOT_SIZE);
113424:     if (!safepoints_.init(slots))
112331:         return false;
112331: 
112108:     // Before generating any code, we generate type checks for all parameters.
112108:     // This comes before deoptTable_, because we can't use deopt tables without
112108:     // creating the actual frame.
112108:     if (!generateArgumentsChecks())
112108:         return false;
112108: 
111935:     if (frameClass_ != FrameSizeClass::None()) {
111935:         deoptTable_ = cx->compartment->ionCompartment()->getBailoutTable(cx, frameClass_);
111935:         if (!deoptTable_)
111935:             return false;
111935:     }
111935: 
111930:     if (!generatePrologue())
111930:         return false;
111930:     if (!generateBody())
111930:         return false;
111930:     if (!generateEpilogue())
111930:         return false;
112505:     if (!generateInvalidateEpilogue())
112505:         return false;
111930:     if (!generateOutOfLineCode())
111930:         return false;
111930: 
111935:     if (masm.oom())
111935:         return false;
111935: 
111930:     Linker linker(masm);
111935:     IonCode *code = linker.newCode(cx);
111930:     if (!code)
111930:         return false;
111930: 
112693:     // We encode safepoints after the OSI-point offsets have been determined.
112693:     encodeSafepoints();
112693: 
112139:     JSScript *script = gen->info().script();
113582:     JS_ASSERT(!script->hasIonScript());
111935: 
112505:     uint32 scriptFrameSize = frameClass_ == FrameSizeClass::None()
112505:                            ? frameDepth_
112505:                            : FrameSizeClass::FromDepth(frameDepth_).frameSize();
112505: 
113424:     script->ion = IonScript::New(cx, slots, scriptFrameSize, snapshots_.size(),
112331:                                  bailouts_.length(), graph.numConstants(),
112505:                                  safepointIndices_.length(), osiIndices_.length(),
113147:                                  cacheList_.length(), barrierOffsets_.length(),
114366:                                  safepoints_.size(), graph.mir().numScripts());
112139:     if (!script->ion)
111930:         return false;
112693:     invalidateEpilogueData_.fixup(&masm);
112505:     Assembler::patchDataWithValueCheck(CodeLocationLabel(code, invalidateEpilogueData_),
112505:                                        ImmWord(uintptr_t(script->ion)),
112505:                                        ImmWord(uintptr_t(-1)));
112505: 
112310:     IonSpew(IonSpew_Codegen, "Created IonScript %p (raw %p)",
112310:             (void *) script->ion, (void *) code->raw());
112206: 
112505:     script->ion->setInvalidationEpilogueDataOffset(invalidateEpilogueData_.offset());
112219:     script->ion->setOsrPc(gen->info().osrPc());
112219:     script->ion->setOsrEntryOffset(getOsrEntryOffset());
112739:     ptrdiff_t real_invalidate = masm.actualOffset(invalidate_.offset());
112693:     script->ion->setInvalidationEpilogueOffset(real_invalidate);
112219: 
112139:     script->ion->setMethod(code);
112139:     script->ion->setDeoptTable(deoptTable_);
112331:     if (snapshots_.size())
112139:         script->ion->copySnapshots(&snapshots_);
111935:     if (bailouts_.length())
112139:         script->ion->copyBailoutTable(&bailouts_[0]);
111975:     if (graph.numConstants())
112139:         script->ion->copyConstants(graph.constantPool());
112505:     if (safepointIndices_.length())
112505:         script->ion->copySafepointIndices(&safepointIndices_[0], masm);
112505:     if (osiIndices_.length())
112693:         script->ion->copyOsiIndices(&osiIndices_[0], masm);
112315:     if (cacheList_.length())
112482:         script->ion->copyCacheEntries(&cacheList_[0], masm);
113147:     if (barrierOffsets_.length())
113147:         script->ion->copyPrebarrierEntries(&barrierOffsets_[0], masm);
112331:     if (safepoints_.size())
112331:         script->ion->copySafepoints(&safepoints_);
111975: 
114366:     JS_ASSERT(graph.mir().numScripts() > 0);
114366:     script->ion->copyScriptEntries(graph.mir().scripts());
114366: 
111975:     linkAbsoluteLabels();
111975: 
113158:     // The correct state for prebarriers is unknown until the end of compilation,
113158:     // since a GC can occur during code generation. All barriers are emitted
113158:     // off-by-default, and are toggled on here if necessary.
113158:     if (cx->compartment->needsBarrier())
113158:         script->ion->toggleBarriers(true);
113158: 
111930:     return true;
111930: }
111930: 
112264: // An out-of-line path to convert a boxed int32 to a double.
112292: class OutOfLineUnboxDouble : public OutOfLineCodeBase<CodeGenerator>
112264: {
112264:     LUnboxDouble *unboxDouble_;
112264: 
112264:   public:
112264:     OutOfLineUnboxDouble(LUnboxDouble *unboxDouble)
112264:       : unboxDouble_(unboxDouble)
112264:     { }
112264: 
112264:     bool accept(CodeGenerator *codegen) {
112264:         return codegen->visitOutOfLineUnboxDouble(this);
112264:     }
112264: 
112264:     LUnboxDouble *unboxDouble() const {
112264:         return unboxDouble_;
112264:     }
112264: };
112264: 
112264: bool
112264: CodeGenerator::visitUnboxDouble(LUnboxDouble *lir)
112264: {
112264:     const ValueOperand box = ToValue(lir, LUnboxDouble::Input);
112264:     const LDefinition *result = lir->output();
112264: 
112264:     // Out-of-line path to convert int32 to double or bailout
112264:     // if this instruction is fallible.
112264:     OutOfLineUnboxDouble *ool = new OutOfLineUnboxDouble(lir);
112264:     if (!addOutOfLineCode(ool))
112264:         return false;
112264: 
112264:     masm.branchTestDouble(Assembler::NotEqual, box, ool->entry());
112264:     masm.unboxDouble(box, ToFloatRegister(result));
112264:     masm.bind(ool->rejoin());
112264:     return true;
112264: }
112264: 
112264: bool
112264: CodeGenerator::visitOutOfLineUnboxDouble(OutOfLineUnboxDouble *ool)
112264: {
112264:     LUnboxDouble *ins = ool->unboxDouble();
112264:     const ValueOperand value = ToValue(ins, LUnboxDouble::Input);
112264: 
112264:     if (ins->mir()->fallible()) {
112264:         Assembler::Condition cond = masm.testInt32(Assembler::NotEqual, value);
112264:         if (!bailoutIf(cond, ins->snapshot()))
112264:             return false;
112264:     }
112264:     masm.int32ValueToDouble(value, ToFloatRegister(ins->output()));
112264:     masm.jump(ool->rejoin());
112264:     return true;
112264: }
112292: 
112984: typedef bool (*GetPropertyOrNameFn)(JSContext *, HandleObject, HandlePropertyName, Value *);
112401: 
112339: bool
112401: CodeGenerator::visitCallGetProperty(LCallGetProperty *lir)
112339: {
113545:     typedef bool (*pf)(JSContext *, HandleValue, PropertyName *, MutableHandleValue);
112706:     static const VMFunction Info = FunctionInfo<pf>(GetProperty);
112339: 
113095:     pushArg(ImmGCPtr(lir->mir()->name()));
112706:     pushArg(ToValue(lir, LCallGetProperty::Value));
112401:     return callVM(Info, lir);
112401: }
112401: 
112401: bool
112486: CodeGenerator::visitCallGetElement(LCallGetElement *lir)
112486: {
113545:     typedef bool (*pf)(JSContext *, HandleValue, HandleValue, MutableHandleValue);
112486:     static const VMFunction GetElementInfo = FunctionInfo<pf>(js::GetElement);
112836:     static const VMFunction CallElementInfo = FunctionInfo<pf>(js::CallElement);
112486: 
112486:     pushArg(ToValue(lir, LCallGetElement::RhsInput));
112486:     pushArg(ToValue(lir, LCallGetElement::LhsInput));
112836: 
112836:     JSOp op = JSOp(*lir->mir()->resumePoint()->pc());
112836: 
112836:     if (op == JSOP_GETELEM) {
112486:         return callVM(GetElementInfo, lir);
112836:     } else {
112836:         JS_ASSERT(op == JSOP_CALLELEM);
112836:         return callVM(CallElementInfo, lir);
112836:     }
112486: }
112486: 
112486: bool
112487: CodeGenerator::visitCallSetElement(LCallSetElement *lir)
112487: {
113545:     typedef bool (*pf)(JSContext *, HandleObject, HandleValue, HandleValue, JSBool strict);
112487:     static const VMFunction SetObjectElementInfo = FunctionInfo<pf>(js::SetObjectElement);
112487: 
112780:     pushArg(Imm32(current->mir()->strictModeCode()));
112487:     pushArg(ToValue(lir, LCallSetElement::Value));
112487:     pushArg(ToValue(lir, LCallSetElement::Index));
112487:     pushArg(ToRegister(lir->getOperand(0)));
112487:     return callVM(SetObjectElementInfo, lir);
112487: }
112487: 
112487: bool
112467: CodeGenerator::visitLoadFixedSlotV(LLoadFixedSlotV *ins)
112467: {
112467:     const Register obj = ToRegister(ins->getOperand(0));
112467:     size_t slot = ins->mir()->slot();
112467:     ValueOperand result = GetValueOutput(ins);
112467: 
112467:     masm.loadValue(Address(obj, JSObject::getFixedSlotOffset(slot)), result);
112467:     return true;
112467: }
112467: 
112467: bool
112467: CodeGenerator::visitLoadFixedSlotT(LLoadFixedSlotT *ins)
112467: {
112467:     const Register obj = ToRegister(ins->getOperand(0));
112467:     size_t slot = ins->mir()->slot();
112467:     AnyRegister result = ToAnyRegister(ins->getDef(0));
112467: 
112467:     masm.loadUnboxedValue(Address(obj, JSObject::getFixedSlotOffset(slot)), result);
112467:     return true;
112467: }
112467: 
112467: bool
112467: CodeGenerator::visitStoreFixedSlotV(LStoreFixedSlotV *ins)
112467: {
112467:     const Register obj = ToRegister(ins->getOperand(0));
112467:     size_t slot = ins->mir()->slot();
112467: 
112467:     const ValueOperand value = ToValue(ins, LStoreFixedSlotV::Value);
112726: 
112726:     Address address(obj, JSObject::getFixedSlotOffset(slot));
112726:     if (ins->mir()->needsBarrier())
113147:         emitPreBarrier(address, MIRType_Value);
112726: 
112726:     masm.storeValue(value, address);
112467: 
112467:     return true;
112467: }
112467: 
112467: bool
112467: CodeGenerator::visitStoreFixedSlotT(LStoreFixedSlotT *ins)
112467: {
112467:     const Register obj = ToRegister(ins->getOperand(0));
112467:     size_t slot = ins->mir()->slot();
112467: 
112467:     const LAllocation *value = ins->value();
112467:     MIRType valueType = ins->mir()->value()->type();
112467: 
112467:     ConstantOrRegister nvalue = value->isConstant()
112467:                               ? ConstantOrRegister(*value->toConstant())
112467:                               : TypedOrValueRegister(valueType, ToAnyRegister(value));
112467: 
112726:     Address address(obj, JSObject::getFixedSlotOffset(slot));
112726:     if (ins->mir()->needsBarrier())
113147:         emitPreBarrier(address, MIRType_Value);
112726: 
112726:     masm.storeConstantOrRegister(nvalue, address);
112467: 
112467:     return true;
112467: }
112467: 
112445: // An out-of-line path to call an inline cache function.
112445: class OutOfLineCache : public OutOfLineCodeBase<CodeGenerator>
112315: {
112315:     LInstruction *ins;
113137:     RepatchLabel repatchEntry_;
112315:     CodeOffsetJump inlineJump;
112315:     CodeOffsetLabel inlineLabel;
112315: 
112315:   public:
112445:     OutOfLineCache(LInstruction *ins)
112315:       : ins(ins)
112445:     {}
112315: 
112315:     void setInlineJump(CodeOffsetJump jump, CodeOffsetLabel label) {
112315:         inlineJump = jump;
112315:         inlineLabel = label;
112315:     }
112315: 
112315:     CodeOffsetJump getInlineJump() const {
112315:         return inlineJump;
112315:     }
112315: 
112315:     CodeOffsetLabel getInlineLabel() const {
112315:         return inlineLabel;
112315:     }
112315: 
112315:     bool accept(CodeGenerator *codegen) {
112445:         switch (ins->op()) {
113170:           case LInstruction::LOp_InstanceOfO:
113170:           case LInstruction::LOp_InstanceOfV:
112445:           case LInstruction::LOp_GetPropertyCacheT:
112445:           case LInstruction::LOp_GetPropertyCacheV:
112445:             return codegen->visitOutOfLineCacheGetProperty(this);
112859:           case LInstruction::LOp_GetElementCacheV:
112859:             return codegen->visitOutOfLineGetElementCache(this);
112676:           case LInstruction::LOp_SetPropertyCacheT:
112676:           case LInstruction::LOp_SetPropertyCacheV:
112676:             return codegen->visitOutOfLineSetPropertyCache(this);
112766:           case LInstruction::LOp_BindNameCache:
112766:             return codegen->visitOutOfLineBindNameCache(this);
113177:           case LInstruction::LOp_GetNameCache:
113177:             return codegen->visitOutOfLineGetNameCache(this);
112445:           default:
112445:             JS_NOT_REACHED("Bad instruction");
112445:             return false;
112445:         }
112315:     }
112315: 
112315:     LInstruction *cache() {
112315:         return ins;
112315:     }
113137:     void bind(MacroAssembler *masm) {
113137:         masm->bind(&repatchEntry_);
113137:     }
113137:     RepatchLabel *repatchEntry() {
113137:         return &repatchEntry_;
113137:     }
112315: };
112315: 
112315: bool
112445: CodeGenerator::visitCache(LInstruction *ins)
112315: {
112445:     OutOfLineCache *ool = new OutOfLineCache(ins);
112315:     if (!addOutOfLineCode(ool))
112315:         return false;
112315: 
113137:     CodeOffsetJump jump = masm.jumpWithPatch(ool->repatchEntry());
112315:     CodeOffsetLabel label = masm.labelForPatch();
112315:     masm.bind(ool->rejoin());
112315: 
112315:     ool->setInlineJump(jump, label);
112315:     return true;
112315: }
112315: 
112315: bool
113177: CodeGenerator::visitOutOfLineGetNameCache(OutOfLineCache *ool)
113177: {
113177:     LGetNameCache *lir = ool->cache()->toGetNameCache();
113177:     const MGetNameCache *mir = lir->mir();
113177:     Register scopeChain = ToRegister(lir->scopeObj());
113177:     RegisterSet liveRegs = lir->safepoint()->liveRegs();
113177:     TypedOrValueRegister output(GetValueOutput(lir));
113177: 
113177:     IonCache::Kind kind = (mir->accessKind() == MGetNameCache::NAME)
113177:                           ? IonCache::Name
113177:                           : IonCache::NameTypeOf;
113177:     IonCacheName cache(kind, ool->getInlineJump(), ool->getInlineLabel(),
113177:                        masm.labelForPatch(), liveRegs,
113177:                        scopeChain, mir->name(), output);
113177: 
113177:     cache.setScriptedLocation(mir->block()->info().script(), mir->resumePoint()->pc());
113177:     size_t cacheIndex = allocateCache(cache);
113177: 
113177:     saveLive(lir);
113177: 
113474:     typedef bool (*pf)(JSContext *, size_t, HandleObject, MutableHandleValue);
113177:     static const VMFunction GetNameCacheInfo = FunctionInfo<pf>(GetNameCache);
113177: 
113177:     pushArg(scopeChain);
113177:     pushArg(Imm32(cacheIndex));
113177:     if (!callVM(GetNameCacheInfo, lir))
113177:         return false;
113177: 
113177:     masm.storeCallResultValue(output);
113177:     restoreLive(lir);
113177: 
113177:     masm.jump(ool->rejoin());
113177:     return true;
113177: }
113177: 
113177: bool
112445: CodeGenerator::visitOutOfLineCacheGetProperty(OutOfLineCache *ool)
112315: {
112453:     RegisterSet liveRegs = ool->cache()->safepoint()->liveRegs();
112315: 
113170:     LInstruction *ins = ool->cache();
113170:     const MInstruction *mir = ins->mirRaw()->toInstruction();
112315: 
112315:     TypedOrValueRegister output;
112315: 
113170:     Register objReg;
113170: 
113170:     // Define the input and output registers each opcode wants,
113170:     // and which atom property it should get
113170:     // Note: because all registers are saved, the output register should be
113170:     //       a def register, else the result will be overriden by restoreLive(ins)
113485:     PropertyName *name = NULL;
113170:     switch (ins->op()) {
113170:       case LInstruction::LOp_InstanceOfO:
113170:       case LInstruction::LOp_InstanceOfV:
114207:         name = gen->compartment->rt->atomState.classPrototype;
113170:         objReg = ToRegister(ins->getTemp(1));
113170:         output = TypedOrValueRegister(MIRType_Object, ToAnyRegister(ins->getDef(0)));
113170:         break;
113170:       case LInstruction::LOp_GetPropertyCacheT:
113170:         name = ((LGetPropertyCacheT *) ins)->mir()->name();
113170:         objReg = ToRegister(ins->getOperand(0));
113170:         output = TypedOrValueRegister(mir->type(), ToAnyRegister(ins->getDef(0)));
113170:         break;
113170:       case LInstruction::LOp_GetPropertyCacheV:
113170:         name = ((LGetPropertyCacheV *) ins)->mir()->name();
113170:         objReg = ToRegister(ins->getOperand(0));
112315:         output = TypedOrValueRegister(GetValueOutput(ins));
113170:         break;
113170:       default:
113170:         JS_NOT_REACHED("Bad instruction");
113170:         return false;
112315:     }
112315: 
112315:     IonCacheGetProperty cache(ool->getInlineJump(), ool->getInlineLabel(),
112315:                               masm.labelForPatch(), liveRegs,
113170:                               objReg, name, output);
113386: 
113386:     if (mir->resumePoint())
112761:         cache.setScriptedLocation(mir->block()->info().script(), mir->resumePoint()->pc());
113386:     else
113386:         cache.setIdempotent();
112315:     size_t cacheIndex = allocateCache(cache);
112315: 
113170:     saveLive(ins);
112315: 
113474:     typedef bool (*pf)(JSContext *, size_t, HandleObject, MutableHandleValue);
112339:     static const VMFunction GetPropertyCacheInfo = FunctionInfo<pf>(GetPropertyCache);
112339: 
112315:     pushArg(objReg);
112315:     pushArg(Imm32(cacheIndex));
113170:     if (!callVM(GetPropertyCacheInfo, ins))
112315:         return false;
112315: 
112684:     masm.storeCallResultValue(output);
113170:     restoreLive(ins);
112315: 
112315:     masm.jump(ool->rejoin());
112315: 
112315:     return true;
112315: }
112315: 
112766: bool
112859: CodeGenerator::visitOutOfLineGetElementCache(OutOfLineCache *ool)
112859: {
112859:     LGetElementCacheV *ins = ool->cache()->toGetElementCacheV();
112859:     const MGetElementCache *mir = ins->mir();
112859: 
112859:     Register obj = ToRegister(ins->object());
112859:     ConstantOrRegister index = TypedOrValueRegister(ToValue(ins, LGetElementCacheV::Index));
112859:     TypedOrValueRegister output = TypedOrValueRegister(GetValueOutput(ins));
112859: 
112859:     RegisterSet liveRegs = ins->safepoint()->liveRegs();
112859: 
112859:     IonCacheGetElement cache(ool->getInlineJump(), ool->getInlineLabel(),
112859:                              masm.labelForPatch(), liveRegs,
112859:                              obj, index, output,
112859:                              mir->monitoredResult());
112859: 
112859:     cache.setScriptedLocation(mir->block()->info().script(), mir->resumePoint()->pc());
112859:     size_t cacheIndex = allocateCache(cache);
112859: 
112859:     saveLive(ins);
112859: 
113574:     typedef bool (*pf)(JSContext *, size_t, HandleObject, HandleValue, MutableHandleValue);
112859:     static const VMFunction Info = FunctionInfo<pf>(GetElementCache);
112859: 
112859:     pushArg(index);
112859:     pushArg(obj);
112859:     pushArg(Imm32(cacheIndex));
112859:     if (!callVM(Info, ins))
112859:         return false;
112859: 
112859:     masm.storeCallResultValue(output);
112859:     restoreLive(ins);
112859: 
112859:     masm.jump(ool->rejoin());
112859:     return true;
112859: }
112859: 
112859: bool
112766: CodeGenerator::visitOutOfLineBindNameCache(OutOfLineCache *ool)
112766: {
112766:     LBindNameCache *ins = ool->cache()->toBindNameCache();
112766:     Register scopeChain = ToRegister(ins->scopeChain());
112766:     Register output = ToRegister(ins->output());
112766: 
112766:     RegisterSet liveRegs = ins->safepoint()->liveRegs();
112766: 
112766:     const MBindNameCache *mir = ins->mir();
112766:     IonCacheBindName cache(ool->getInlineJump(), ool->getInlineLabel(),
112766:                            masm.labelForPatch(), liveRegs,
112766:                            scopeChain, mir->name(), output);
112766:     cache.setScriptedLocation(mir->script(), mir->pc());
112766:     size_t cacheIndex = allocateCache(cache);
112766: 
112766:     saveLive(ins);
112766: 
113014:     typedef JSObject *(*pf)(JSContext *, size_t, HandleObject);
112766:     static const VMFunction BindNameCacheInfo = FunctionInfo<pf>(BindNameCache);
112766: 
112766:     pushArg(scopeChain);
112766:     pushArg(Imm32(cacheIndex));
112766:     if (!callVM(BindNameCacheInfo, ins))
112766:         return false;
112766: 
112766:     masm.storeCallResult(output);
112766:     restoreLive(ins);
112766: 
112766:     masm.jump(ool->rejoin());
112766:     return true;
112767: }
112766: 
112445: ConstantOrRegister
112445: CodeGenerator::getSetPropertyValue(LInstruction *ins)
112445: {
112445:     if (ins->getOperand(1)->isConstant()) {
112676:         JS_ASSERT(ins->isSetPropertyCacheT());
112445:         return ConstantOrRegister(*ins->getOperand(1)->toConstant());
112445:     }
112445: 
112445:     switch (ins->op()) {
112675:       case LInstruction::LOp_CallSetProperty:
112675:         return TypedOrValueRegister(ToValue(ins, LCallSetProperty::Value));
112676:       case LInstruction::LOp_SetPropertyCacheV:
112676:         return TypedOrValueRegister(ToValue(ins, LSetPropertyCacheV::Value));
112676:       case LInstruction::LOp_SetPropertyCacheT: {
112676:         LSetPropertyCacheT *ins_ = ins->toSetPropertyCacheT();
112445:         return TypedOrValueRegister(ins_->valueType(), ToAnyRegister(ins->getOperand(1)));
112445:       }
112445:       default:
112445:         JS_NOT_REACHED("Bad opcode");
112445:         return ConstantOrRegister(UndefinedValue());
112445:     }
112445: }
112445: 
112445: bool
112675: CodeGenerator::visitCallSetProperty(LCallSetProperty *ins)
112445: {
112445:     ConstantOrRegister value = getSetPropertyValue(ins);
112445: 
112445:     const Register objReg = ToRegister(ins->getOperand(0));
113016:     bool isSetName = JSOp(*ins->mir()->resumePoint()->pc()) == JSOP_SETNAME;
113016: 
113016:     pushArg(Imm32(isSetName));
113016:     pushArg(Imm32(ins->mir()->strict()));
112445: 
112445:     pushArg(value);
113095:     pushArg(ImmGCPtr(ins->mir()->name()));
112445:     pushArg(objReg);
112445: 
113095:     typedef bool (*pf)(JSContext *, HandleObject, HandlePropertyName, const HandleValue, bool, bool);
113016:     static const VMFunction info = FunctionInfo<pf>(SetProperty);
113016: 
113016:     return callVM(info, ins);
112445: }
112445: 
112445: bool
112834: CodeGenerator::visitCallDeleteProperty(LCallDeleteProperty *lir)
112834: {
113545:     typedef bool (*pf)(JSContext *, HandleValue, HandlePropertyName, JSBool *);
112834: 
114101:     pushArg(ImmGCPtr(lir->mir()->name()));
112834:     pushArg(ToValue(lir, LCallDeleteProperty::Value));
112834: 
112834:     if (lir->mir()->block()->info().script()->strictModeCode) {
112834:         static const VMFunction Info = FunctionInfo<pf>(DeleteProperty<true>);
112834:         return callVM(Info, lir);
112834:     } else {
112834:         static const VMFunction Info = FunctionInfo<pf>(DeleteProperty<false>);
112834:         return callVM(Info, lir);
112834:     }
112834: }
112834: 
112834: bool
112676: CodeGenerator::visitOutOfLineSetPropertyCache(OutOfLineCache *ool)
112445: {
112445:     LInstruction *ins = ool->cache();
112445: 
112445:     Register objReg = ToRegister(ins->getOperand(0));
112454:     RegisterSet liveRegs = ins->safepoint()->liveRegs();
112445: 
112445:     ConstantOrRegister value = getSetPropertyValue(ins);
112675:     const MSetPropertyCache *mir = ins->mirRaw()->toSetPropertyCache();
112445: 
112445:     IonCacheSetProperty cache(ool->getInlineJump(), ool->getInlineLabel(),
112445:                               masm.labelForPatch(), liveRegs,
113095:                               objReg, mir->name(), value,
112445:                               mir->strict());
112445: 
112445:     size_t cacheIndex = allocateCache(cache);
113016:     bool isSetName = JSOp(*mir->resumePoint()->pc()) == JSOP_SETNAME;
112445: 
112456:     saveLive(ins);
112445: 
113016:     pushArg(Imm32(isSetName));
112445:     pushArg(value);
112445:     pushArg(objReg);
112445:     pushArg(Imm32(cacheIndex));
112445: 
113016:     typedef bool (*pf)(JSContext *, size_t, HandleObject, HandleValue, bool);
112445:     static const VMFunction info = FunctionInfo<pf>(ion::SetPropertyCache);
112445: 
112445:     if (!callVM(info, ool->cache()))
112445:         return false;
112445: 
112456:     restoreLive(ins);
112445: 
112445:     masm.jump(ool->rejoin());
112445: 
112445:     return true;
112445: }
112445: 
112478: bool
112478: CodeGenerator::visitThrow(LThrow *lir)
112478: {
113657:     typedef bool (*pf)(JSContext *, HandleValue);
112478:     static const VMFunction ThrowInfo = FunctionInfo<pf>(js::Throw);
112478: 
112478:     pushArg(ToValue(lir, LThrow::Value));
112478:     return callVM(ThrowInfo, lir);
112478: }
112478: 
112508: bool
112682: CodeGenerator::visitBitNotV(LBitNotV *lir)
112682: {
113657:     typedef bool (*pf)(JSContext *, HandleValue, int *p);
112682:     static const VMFunction info = FunctionInfo<pf>(BitNot);
112682: 
112682:     pushArg(ToValue(lir, LBitNotV::Input));
112682:     return callVM(info, lir);
112682: }
112682: 
112749: bool
112749: CodeGenerator::visitBitOpV(LBitOpV *lir)
112749: {
113657:     typedef bool (*pf)(JSContext *, HandleValue, HandleValue, int *p);
112749:     static const VMFunction BitAndInfo = FunctionInfo<pf>(BitAnd);
112749:     static const VMFunction BitOrInfo = FunctionInfo<pf>(BitOr);
112749:     static const VMFunction BitXorInfo = FunctionInfo<pf>(BitXor);
112970:     static const VMFunction BitLhsInfo = FunctionInfo<pf>(BitLsh);
112970:     static const VMFunction BitRhsInfo = FunctionInfo<pf>(BitRsh);
112970: 
112970:     pushArg(ToValue(lir, LBitOpV::RhsInput));
112749:     pushArg(ToValue(lir, LBitOpV::LhsInput));
112749: 
112749:     switch (lir->jsop()) {
112749:       case JSOP_BITAND:
112749:         return callVM(BitAndInfo, lir);
112749:       case JSOP_BITOR:
112749:         return callVM(BitOrInfo, lir);
112749:       case JSOP_BITXOR:
112749:         return callVM(BitXorInfo, lir);
112970:       case JSOP_LSH:
112970:         return callVM(BitLhsInfo, lir);
112970:       case JSOP_RSH:
112970:         return callVM(BitRhsInfo, lir);
112749:       default:
112749:         break;
112749:     }
112749:     JS_NOT_REACHED("unexpected bitop");
112749:     return false;
112749: }
112749: 
112684: class OutOfLineTypeOfV : public OutOfLineCodeBase<CodeGenerator>
112684: {
112684:     LTypeOfV *ins_;
112684: 
112684:   public:
112684:     OutOfLineTypeOfV(LTypeOfV *ins)
112684:       : ins_(ins)
112684:     { }
112684: 
112684:     bool accept(CodeGenerator *codegen) {
112684:         return codegen->visitOutOfLineTypeOfV(this);
112684:     }
112684:     LTypeOfV *ins() const {
112684:         return ins_;
112684:     }
112684: };
112684: 
112684: bool
112684: CodeGenerator::visitTypeOfV(LTypeOfV *lir)
112684: {
112684:     const ValueOperand value = ToValue(lir, LTypeOfV::Input);
112684:     Register output = ToRegister(lir->output());
112684:     Register tag = masm.splitTagForTest(value);
112684: 
112684:     OutOfLineTypeOfV *ool = new OutOfLineTypeOfV(lir);
112684:     if (!addOutOfLineCode(ool))
112684:         return false;
112684: 
114199:     JSRuntime *rt = gen->compartment->rt;
112684: 
112684:     // Jump to the OOL path if the value is an object. Objects are complicated
112684:     // since they may have a typeof hook.
112684:     masm.branchTestObject(Assembler::Equal, tag, ool->entry());
112684: 
112684:     Label done;
112684: 
112684:     Label notNumber;
112684:     masm.branchTestNumber(Assembler::NotEqual, tag, &notNumber);
114207:     masm.movePtr(ImmGCPtr(rt->atomState.number), output);
112684:     masm.jump(&done);
112684:     masm.bind(&notNumber);
112684: 
112684:     Label notUndefined;
112684:     masm.branchTestUndefined(Assembler::NotEqual, tag, &notUndefined);
114207:     masm.movePtr(ImmGCPtr(rt->atomState.undefined), output);
112684:     masm.jump(&done);
112684:     masm.bind(&notUndefined);
112684: 
112684:     Label notNull;
112684:     masm.branchTestNull(Assembler::NotEqual, tag, &notNull);
114207:     masm.movePtr(ImmGCPtr(rt->atomState.object), output);
112684:     masm.jump(&done);
112684:     masm.bind(&notNull);
112684: 
112684:     Label notBoolean;
112684:     masm.branchTestBoolean(Assembler::NotEqual, tag, &notBoolean);
114207:     masm.movePtr(ImmGCPtr(rt->atomState.boolean), output);
112684:     masm.jump(&done);
112684:     masm.bind(&notBoolean);
112684: 
114207:     masm.movePtr(ImmGCPtr(rt->atomState.string), output);
112684: 
112684:     masm.bind(&done);
112684:     masm.bind(ool->rejoin());
112684:     return true;
112684: }
112684: 
112684: bool
112684: CodeGenerator::visitOutOfLineTypeOfV(OutOfLineTypeOfV *ool)
112684: {
113657:     typedef JSString *(*pf)(JSContext *, HandleValue);
112684:     static const VMFunction Info = FunctionInfo<pf>(TypeOfOperation);
112684: 
112684:     LTypeOfV *ins = ool->ins();
112684:     saveLive(ins);
112684: 
112684:     pushArg(ToValue(ins, LTypeOfV::Input));
112684:     if (!callVM(Info, ins))
112684:         return false;
112684: 
112684:     masm.storeCallResult(ToRegister(ins->output()));
112684:     restoreLive(ins);
112684: 
112684:     masm.jump(ool->rejoin());
112684:     return true;
112684: }
112684: 
112682: bool
112705: CodeGenerator::visitToIdV(LToIdV *lir)
112705: {
113651:     typedef bool (*pf)(JSContext *, HandleScript, jsbytecode *, HandleValue, HandleValue,
113651:                        MutableHandleValue);
112705:     static const VMFunction Info = FunctionInfo<pf>(ToIdOperation);
112705: 
112705:     pushArg(ToValue(lir, LToIdV::Index));
112705:     pushArg(ToValue(lir, LToIdV::Object));
113651:     pushArg(ImmWord(lir->mir()->resumePoint()->pc()));
113651:     pushArg(ImmGCPtr(current->mir()->info().script()));
112705:     return callVM(Info, lir);
112705: }
112705: 
112705: bool
112508: CodeGenerator::visitLoadElementV(LLoadElementV *load)
112508: {
112508:     Register elements = ToRegister(load->elements());
112508:     const ValueOperand out = ToOutValue(load);
112508: 
112508:     if (load->index()->isConstant())
112508:         masm.loadValue(Address(elements, ToInt32(load->index()) * sizeof(Value)), out);
112508:     else
112508:         masm.loadValue(BaseIndex(elements, ToRegister(load->index()), TimesEight), out);
112508: 
112508:     if (load->mir()->needsHoleCheck()) {
112508:         Assembler::Condition cond = masm.testMagic(Assembler::Equal, out);
112508:         if (!bailoutIf(cond, load->snapshot()))
112508:             return false;
112508:     }
112508: 
112508:     return true;
112508: }
112508: 
112508: bool
112508: CodeGenerator::visitLoadElementHole(LLoadElementHole *lir)
112508: {
112508:     Register elements = ToRegister(lir->elements());
112508:     Register initLength = ToRegister(lir->initLength());
112508:     const ValueOperand out = ToOutValue(lir);
112508: 
112508:     // If the index is out of bounds, load |undefined|. Otherwise, load the
112508:     // value.
112508:     Label undefined, done;
112508:     if (lir->index()->isConstant()) {
112508:         masm.branch32(Assembler::BelowOrEqual, initLength, Imm32(ToInt32(lir->index())), &undefined);
112508:         masm.loadValue(Address(elements, ToInt32(lir->index()) * sizeof(Value)), out);
112508:     } else {
112508:         masm.branch32(Assembler::BelowOrEqual, initLength, ToRegister(lir->index()), &undefined);
112508:         masm.loadValue(BaseIndex(elements, ToRegister(lir->index()), TimesEight), out);
112508:     }
112508: 
112508:     // If a hole check is needed, and the value wasn't a hole, we're done.
112508:     // Otherwise, we'll load undefined.
112508:     if (lir->mir()->needsHoleCheck())
112508:         masm.branchTestMagic(Assembler::NotEqual, out, &done);
112508:     else
112508:         masm.jump(&done);
112508: 
112508:     masm.bind(&undefined);
112508:     masm.moveValue(UndefinedValue(), out);
112508:     masm.bind(&done);
112508:     return true;
112508: }
112508: 
112904: bool
112904: CodeGenerator::visitLoadTypedArrayElement(LLoadTypedArrayElement *lir)
112904: {
112904:     Register elements = ToRegister(lir->elements());
112904:     Register temp = lir->temp()->isBogusTemp() ? InvalidReg : ToRegister(lir->temp());
112904:     AnyRegister out = ToAnyRegister(lir->output());
112904: 
112904:     int arrayType = lir->mir()->arrayType();
112904:     int shift = TypedArray::slotWidth(arrayType);
112904: 
112904:     Label fail;
112904:     if (lir->index()->isConstant()) {
112904:         Address source(elements, ToInt32(lir->index()) * shift);
112904:         masm.loadFromTypedArray(arrayType, source, out, temp, &fail);
112904:     } else {
112904:         BaseIndex source(elements, ToRegister(lir->index()), ScaleFromShift(shift));
112904:         masm.loadFromTypedArray(arrayType, source, out, temp, &fail);
112904:     }
112904: 
112904:     if (fail.used() && !bailoutFrom(&fail, lir->snapshot()))
112904:         return false;
112904: 
112904:     return true;
112904: }
112904: 
112904: class OutOfLineLoadTypedArray : public OutOfLineCodeBase<CodeGenerator>
112904: {
112904:     LLoadTypedArrayElementHole *ins_;
112904: 
112904:   public:
112904:     OutOfLineLoadTypedArray(LLoadTypedArrayElementHole *ins)
112904:       : ins_(ins)
112904:     { }
112904: 
112904:     bool accept(CodeGenerator *codegen) {
112904:         return codegen->visitOutOfLineLoadTypedArray(this);
112904:     }
112904: 
112904:     LLoadTypedArrayElementHole *ins() const {
112904:         return ins_;
112904:     }
112904: };
112904: 
112904: bool
112904: CodeGenerator::visitLoadTypedArrayElementHole(LLoadTypedArrayElementHole *lir)
112904: {
112904:     Register object = ToRegister(lir->object());
112904:     const ValueOperand out = ToOutValue(lir);
112904: 
112904:     OutOfLineLoadTypedArray *ool = new OutOfLineLoadTypedArray(lir);
112904:     if (!addOutOfLineCode(ool))
112904:         return false;
112904: 
112904:     // Load the length.
112904:     Register scratch = out.scratchReg();
112904:     Int32Key key = ToInt32Key(lir->index());
112904:     masm.unboxInt32(Address(object, TypedArray::lengthOffset()), scratch);
112904: 
112904:     // OOL path if index >= length.
112904:     masm.branchKey(Assembler::BelowOrEqual, scratch, key, ool->entry());
112904: 
112904:     // Load the elements vector.
112904:     masm.loadPtr(Address(object, TypedArray::dataOffset()), scratch);
112904: 
112904:     int arrayType = lir->mir()->arrayType();
112904:     int shift = TypedArray::slotWidth(arrayType);
112904: 
112904:     Label fail;
112904:     if (key.isConstant()) {
112904:         Address source(scratch, key.constant() * shift);
112904:         masm.loadFromTypedArray(arrayType, source, out, lir->mir()->allowDouble(), &fail);
112904:     } else {
112904:         BaseIndex source(scratch, key.reg(), ScaleFromShift(shift));
112904:         masm.loadFromTypedArray(arrayType, source, out, lir->mir()->allowDouble(), &fail);
112904:     }
112904: 
112904:     if (fail.used() && !bailoutFrom(&fail, lir->snapshot()))
112904:         return false;
112904: 
112904:     masm.bind(ool->rejoin());
112904:     return true;
112904: }
112904: 
112904: bool
112904: CodeGenerator::visitOutOfLineLoadTypedArray(OutOfLineLoadTypedArray *ool)
112904: {
112904:     LLoadTypedArrayElementHole *ins = ool->ins();
112904:     saveLive(ins);
112904: 
112904:     Register object = ToRegister(ins->object());
112904:     ValueOperand out = ToOutValue(ins);
112904: 
113545:     typedef bool (*pf)(JSContext *, HandleValue, HandleValue, MutableHandleValue);
112904:     static const VMFunction Info = FunctionInfo<pf>(js::GetElementMonitored);
112904: 
112904:     if (ins->index()->isConstant())
112904:         pushArg(*ins->index()->toConstant());
112904:     else
112904:         pushArg(TypedOrValueRegister(MIRType_Int32, ToAnyRegister(ins->index())));
112904:     pushArg(TypedOrValueRegister(MIRType_Object, AnyRegister(object)));
112904:     if (!callVM(Info, ins))
112904:         return false;
112904: 
112904:     masm.storeCallResultValue(out);
112904:     restoreLive(ins);
112904: 
112904:     masm.jump(ool->rejoin());
112904:     return true;
112904: }
112904: 
112936: template <typename T>
112936: static inline void
112936: StoreToTypedArray(MacroAssembler &masm, int arrayType, const LAllocation *value, const T &dest)
112936: {
112936:     if (arrayType == TypedArray::TYPE_FLOAT32 || arrayType == TypedArray::TYPE_FLOAT64) {
112936:         masm.storeToTypedFloatArray(arrayType, ToFloatRegister(value), dest);
112936:     } else {
112936:         if (value->isConstant())
112936:             masm.storeToTypedIntArray(arrayType, Imm32(ToInt32(value)), dest);
112936:         else
112936:             masm.storeToTypedIntArray(arrayType, ToRegister(value), dest);
112936:     }
112936: }
112936: 
112936: bool
112936: CodeGenerator::visitStoreTypedArrayElement(LStoreTypedArrayElement *lir)
112936: {
112936:     Register elements = ToRegister(lir->elements());
112936:     const LAllocation *value = lir->value();
112936: 
112936:     int arrayType = lir->mir()->arrayType();
112936:     int shift = TypedArray::slotWidth(arrayType);
112936: 
112936:     if (lir->index()->isConstant()) {
112936:         Address dest(elements, ToInt32(lir->index()) * shift);
112936:         StoreToTypedArray(masm, arrayType, value, dest);
112936:     } else {
112936:         BaseIndex dest(elements, ToRegister(lir->index()), ScaleFromShift(shift));
112936:         StoreToTypedArray(masm, arrayType, value, dest);
112936:     }
112936: 
112936:     return true;
112936: }
112936: 
112936: bool
112936: CodeGenerator::visitClampIToUint8(LClampIToUint8 *lir)
112936: {
112936:     Register input = ToRegister(lir->input());
112936:     Register output = ToRegister(lir->output());
112936:     masm.clampIntToUint8(input, output);
112936:     return true;
112936: }
112936: 
112936: bool
112936: CodeGenerator::visitClampDToUint8(LClampDToUint8 *lir)
112936: {
112936:     FloatRegister input = ToFloatRegister(lir->input());
112936:     Register output = ToRegister(lir->output());
112936:     masm.clampDoubleToUint8(input, output);
112936:     return true;
112936: }
112936: 
112936: bool
112936: CodeGenerator::visitClampVToUint8(LClampVToUint8 *lir)
112936: {
112936:     ValueOperand input = ToValue(lir, LClampVToUint8::Input);
112936:     FloatRegister tempFloat = ToFloatRegister(lir->tempFloat());
112936:     Register output = ToRegister(lir->output());
112936: 
112936:     Register tag = masm.splitTagForTest(input);
112936: 
112936:     Label done;
112936:     Label isInt32, isDouble, isBoolean;
112936:     masm.branchTestInt32(Assembler::Equal, tag, &isInt32);
112936:     masm.branchTestDouble(Assembler::Equal, tag, &isDouble);
112936:     masm.branchTestBoolean(Assembler::Equal, tag, &isBoolean);
112936: 
112936:     // Undefined, null and objects are always 0.
112936:     Label isZero;
112936:     masm.branchTestUndefined(Assembler::Equal, tag, &isZero);
112936:     masm.branchTestNull(Assembler::Equal, tag, &isZero);
112936:     masm.branchTestObject(Assembler::Equal, tag, &isZero);
112936: 
112936:     // Bailout for everything else (strings).
112936:     if (!bailout(lir->snapshot()))
112936:         return false;
112936: 
112936:     masm.bind(&isInt32);
112936:     masm.unboxInt32(input, output);
112936:     masm.clampIntToUint8(output, output);
112936:     masm.jump(&done);
112936: 
112936:     masm.bind(&isDouble);
112936:     masm.unboxDouble(input, tempFloat);
112936:     masm.clampDoubleToUint8(tempFloat, output);
112936:     masm.jump(&done);
112936: 
112936:     masm.bind(&isBoolean);
112936:     masm.unboxBoolean(input, output);
112936:     masm.jump(&done);
112936: 
112936:     masm.bind(&isZero);
112936:     masm.move32(Imm32(0), output);
112936: 
112936:     masm.bind(&done);
112936:     return true;
112936: }
112936: 
113170: bool
113170: CodeGenerator::visitInstanceOfO(LInstanceOfO *ins)
113170: {
113170:     Register rhs = ToRegister(ins->getOperand(1));
113170:     return emitInstanceOf(ins, rhs);
113170: }
113170: 
113170: bool
113170: CodeGenerator::visitInstanceOfV(LInstanceOfV *ins)
113170: {
113170:     Register rhs = ToRegister(ins->getOperand(LInstanceOfV::RHS));
113170:     return emitInstanceOf(ins, rhs);
113170: }
113170: 
113170: bool
113170: CodeGenerator::emitInstanceOf(LInstruction *ins, Register rhs)
113170: {
113170:     Register rhsTmp = ToRegister(ins->getTemp(1));
113170:     Register output = ToRegister(ins->getDef(0));
113170: 
113170:     // This temporary is used in other parts of the code.
113170:     // Different names are used so the purpose is clear.
113170:     Register rhsFlags = ToRegister(ins->getTemp(0));
113170:     Register lhsTmp = ToRegister(ins->getTemp(0));
113170: 
113170:     Label callHasInstance;
113170:     Label boundFunctionCheck;
113170:     Label boundFunctionDone;
113170:     Label done;
113170:     Label loopPrototypeChain;
113170: 
113652:     typedef bool (*pf)(JSContext *, HandleObject, HandleValue, JSBool *);
113170:     static const VMFunction HasInstanceInfo = FunctionInfo<pf>(js::HasInstance);
113170: 
113170:     OutOfLineCode *call = oolCallVM(HasInstanceInfo, ins, (ArgList(), rhs, ToValue(ins, 0)),
113170:                                    StoreRegisterTo(output));
113170:     if (!call)
113170:         return false;
113170: 
113170:     // 1. CODE FOR HASINSTANCE_BOUND_FUNCTION
113170: 
113170:     // ASM-equivalent of following code
113170:     //  boundFunctionCheck:
113170:     //      if (!rhs->isFunction())
113170:     //          goto callHasInstance
113170:     //      if (!rhs->isBoundFunction())
113170:     //          goto HasInstanceCunction
113170:     //      rhs = rhs->getBoundFunction();
113170:     //      goto boundFunctionCheck
113170: 
113170:     masm.mov(rhs, rhsTmp);
113170: 
113170:     // Check Function
113170:     masm.bind(&boundFunctionCheck);
113170: 
113170:     masm.loadBaseShape(rhsTmp, output);
113173:     masm.cmpPtr(Address(output, BaseShape::offsetOfClass()), ImmWord(&js::FunctionClass));
113170:     masm.j(Assembler::NotEqual, call->entry());
113170: 
113170:     // Check Bound Function
113170:     masm.loadPtr(Address(output, BaseShape::offsetOfFlags()), rhsFlags);
113173:     masm.and32(Imm32(BaseShape::BOUND_FUNCTION), rhsFlags);
113170:     masm.j(Assembler::Zero, &boundFunctionDone);
113170: 
113170:     // Get Bound Function
113170:     masm.loadPtr(Address(output, BaseShape::offsetOfParent()), rhsTmp);
113170:     masm.jump(&boundFunctionCheck);
113170: 
113170:     // 2. CODE FOR HASINSTANCE_FUNCTION
113170:     masm.bind(&boundFunctionDone);
113170: 
113170:     // ASM-equivalent of following code
113170:     //  if (!lhs->isObject()) {
113170:     //    output = false;
113170:     //    goto done;
113170:     //  }
113170:     //  rhs = rhs->getPrototypeClass();
113170:     //  output = false;
113170:     //  while (1) {
113170:     //    lhs = lhs->getType().proto;
113170:     //    if (lhs == NULL)
113170:     //      goto done;
113170:     //    if (lhs != rhs) {
113170:     //      output = true;
113170:     //      goto done;
113170:     //    }
113170:     //  }
113170: 
113170:     // When lhs is a value: The HasInstance for function objects always
113170:     // return false when lhs isn't an object. So check if
113170:     // lhs is an object and otherwise return false
113170:     if (ins->isInstanceOfV()) {
113170:         Label isObject;
113170:         ValueOperand lhsValue = ToValue(ins, LInstanceOfV::LHS);
113170:         masm.branchTestObject(Assembler::Equal, lhsValue, &isObject);
113170:         masm.mov(Imm32(0), output);
113170:         masm.jump(&done);
113170: 
113170:         masm.bind(&isObject);
113170:         Register tmp = masm.extractObject(lhsValue, lhsTmp);
113170:         masm.mov(tmp, lhsTmp);
113170:     } else {
113170:         masm.mov(ToRegister(ins->getOperand(0)), lhsTmp);
113170:     }
113170: 
113170:     // Get prototype-class by using a OutOfLine GetProperty Cache
113170:     // It will use register 'rhsTmp' as input and register 'output' as output, see r1889
113170:     OutOfLineCache *ool = new OutOfLineCache(ins);
113170:     if (!addOutOfLineCode(ool))
113170:         return false;
113170: 
113170:     CodeOffsetJump jump = masm.jumpWithPatch(ool->repatchEntry());
113170:     CodeOffsetLabel label = masm.labelForPatch();
113170:     masm.bind(ool->rejoin());
113170:     ool->setInlineJump(jump, label);
113170: 
113170:     // Move the OutOfLineCache return value and set the output on false
113170:     masm.mov(output, rhsTmp);
113170:     masm.mov(Imm32(0), output);
113170: 
113170:     // Walk the prototype chain
113170:     masm.bind(&loopPrototypeChain);
113170:     masm.loadPtr(Address(lhsTmp, JSObject::offsetOfType()), lhsTmp);
113170:     masm.loadPtr(Address(lhsTmp, offsetof(types::TypeObject, proto)), lhsTmp);
113170: 
115205:     // Bail out if we hit a lazy proto
115205:     masm.branch32(Assembler::Equal, lhsTmp, Imm32(1), call->entry());
115205: 
115205:     masm.testPtr(lhsTmp, lhsTmp);
113170:     masm.j(Assembler::Zero, &done);
113170: 
113170:     // Check lhs is equal to rhsShape
115205:     masm.cmpPtr(lhsTmp, rhsTmp);
113170:     masm.j(Assembler::NotEqual, &loopPrototypeChain);
113170: 
113170:     // return true
113170:     masm.mov(Imm32(1), output);
113170: 
113170:     masm.bind(call->rejoin());
113170:     masm.bind(&done);
113170:     return true;
113170: }
113170: 
113449: bool
113515: CodeGenerator::visitGetDOMProperty(LGetDOMProperty *ins)
113515: {
113515:     const Register JSContextReg = ToRegister(ins->getJSContextReg());
113515:     const Register ObjectReg = ToRegister(ins->getObjectReg());
113515:     const Register PrivateReg = ToRegister(ins->getPrivReg());
113515:     const Register ValueReg = ToRegister(ins->getValueReg());
113515: 
113515:     DebugOnly<uint32> initialStack = masm.framePushed();
113515: 
113515:     masm.checkStackAlignment();
113515: 
113515:     /* Make Space for the outparam */
113515:     masm.adjustStack((int)-sizeof(Value));
113515:     masm.movePtr(StackPointer, ValueReg);
113515: 
113515:     masm.Push(ObjectReg);
113515: 
113515:     // GetReservedSlot(obj, DOM_PROTO_INSTANCE_CLASS_SLOT).toPrivate()
113515:     masm.loadPrivate(Address(ObjectReg, JSObject::getFixedSlotOffset(0)), PrivateReg);
113515: 
113515:     // Rooting will happen at GC time.
113515:     masm.movePtr(StackPointer, ObjectReg);
113515: 
113515:     uint32 safepointOffset;
113515:     if (!masm.buildFakeExitFrame(JSContextReg, &safepointOffset))
113515:         return false;
113515:     masm.enterFakeDOMFrame(ION_FRAME_DOMGETTER);
113515: 
113515:     if (!markSafepointAt(safepointOffset, ins))
113515:         return false;
113515: 
113515:     masm.setupUnalignedABICall(4, JSContextReg);
113515: 
113515:     masm.loadJSContext(JSContextReg);
113515: 
113515:     masm.passABIArg(JSContextReg);
113515:     masm.passABIArg(ObjectReg);
113515:     masm.passABIArg(PrivateReg);
113515:     masm.passABIArg(ValueReg);
113609:     masm.callWithABI(JS_FUNC_TO_DATA_PTR(void *, ins->mir()->fun()));
113515: 
113515:     if (ins->mir()->isInfallible()) {
113515:         masm.loadValue(Address(StackPointer, IonDOMExitFrameLayout::offsetOfResult()),
113515:                        JSReturnOperand);
113515:     } else {
113515:         Label success, exception;
113515:         masm.branchTest32(Assembler::Zero, ReturnReg, ReturnReg, &exception);
113515: 
113515:         masm.loadValue(Address(StackPointer, IonDOMExitFrameLayout::offsetOfResult()),
113515:                        JSReturnOperand);
113515:         masm.jump(&success);
113515: 
113515:         {
113515:             masm.bind(&exception);
113515:             masm.handleException();
113515:         }
113515:         masm.bind(&success);
113515:     }
113515:     masm.adjustStack(IonDOMExitFrameLayout::Size());
113515: 
113515:     JS_ASSERT(masm.framePushed() == initialStack);
113515:     return true;
113515: }
113515: 
113515: bool
113515: CodeGenerator::visitSetDOMProperty(LSetDOMProperty *ins)
113515: {
113515:     const Register JSContextReg = ToRegister(ins->getJSContextReg());
113515:     const Register ObjectReg = ToRegister(ins->getObjectReg());
113515:     const Register PrivateReg = ToRegister(ins->getPrivReg());
113515:     const Register ValueReg = ToRegister(ins->getValueReg());
113515: 
113515:     DebugOnly<uint32> initialStack = masm.framePushed();
113515: 
113515:     masm.checkStackAlignment();
113515: 
113515:     // Push thei argument. Rooting will happen at GC time.
113515:     ValueOperand argVal = ToValue(ins, LSetDOMProperty::Value);
113515:     masm.Push(argVal);
113515:     masm.movePtr(StackPointer, ValueReg);
113515: 
113515:     masm.Push(ObjectReg);
113515: 
113515:     // GetReservedSlot(obj, DOM_PROTO_INSTANCE_CLASS_SLOT).toPrivate()
113515:     masm.loadPrivate(Address(ObjectReg, JSObject::getFixedSlotOffset(0)), PrivateReg);
113515: 
113515:     // Rooting will happen at GC time.
113515:     masm.movePtr(StackPointer, ObjectReg);
113515: 
113515:     uint32 safepointOffset;
113515:     if (!masm.buildFakeExitFrame(JSContextReg, &safepointOffset))
113515:         return false;
113515:     masm.enterFakeDOMFrame(ION_FRAME_DOMSETTER);
113515: 
113515:     if (!markSafepointAt(safepointOffset, ins))
113515:         return false;
113515: 
113515:     masm.setupUnalignedABICall(4, JSContextReg);
113515: 
113515:     masm.loadJSContext(JSContextReg);
113515: 
113515:     masm.passABIArg(JSContextReg);
113515:     masm.passABIArg(ObjectReg);
113515:     masm.passABIArg(PrivateReg);
113515:     masm.passABIArg(ValueReg);
113609:     masm.callWithABI(JS_FUNC_TO_DATA_PTR(void *, ins->mir()->fun()));
113515: 
113515:     Label success, exception;
113515:     masm.branchTest32(Assembler::Zero, ReturnReg, ReturnReg, &exception);
113515: 
113515:     masm.jump(&success);
113515: 
113515:     {
113515:         masm.bind(&exception);
113515:         masm.handleException();
113515:     }
113515:     masm.bind(&success);
113515:     masm.adjustStack(IonDOMExitFrameLayout::Size());
113515: 
113515:     JS_ASSERT(masm.framePushed() == initialStack);
113515:     return true;
113515: }
113515: 
113515: bool
113587: CodeGenerator::visitFunctionBoundary(LFunctionBoundary *lir)
113449: {
113587:     Register temp = ToRegister(lir->temp()->output());
113587: 
113587:     switch (lir->type()) {
113587:         case MFunctionBoundary::Inline_Enter:
113587:             // Multiple scripts can be inlined at one depth, but there is only
113587:             // one Inline_Exit node to signify this. To deal with this, if we
113587:             // reach the entry of another inline script on the same level, then
113587:             // just reset the sps metadata about the frame. We must balance
113587:             // calls to leave()/reenter(), so perform the balance without
113587:             // emitting any instrumentation. Technically the previous inline
113587:             // call at this same depth has reentered, but the instrumentation
113587:             // will be emitted at the common join point for all inlines at the
113587:             // same depth.
113593:             if (sps_.inliningDepth() == lir->inlineLevel()) {
113593:                 sps_.leaveInlineFrame();
113593:                 sps_.skipNextReenter();
113593:                 sps_.reenter(masm, temp);
113587:             }
113587: 
113593:             sps_.leave(masm, temp);
113593:             if (!sps_.enterInlineFrame())
113587:                 return false;
113587:             // fallthrough
113587: 
113587:         case MFunctionBoundary::Enter:
113593:             if (sps_.slowAssertions()) {
113587:                 typedef bool(*pf)(JSContext *, HandleScript);
113587:                 static const VMFunction SPSEnterInfo = FunctionInfo<pf>(SPSEnter);
113587: 
113587:                 saveLive(lir);
113587:                 pushArg(ImmGCPtr(lir->script()));
113587:                 if (!callVM(SPSEnterInfo, lir))
113587:                     return false;
113587:                 restoreLive(lir);
113593:                 sps_.pushManual(lir->script(), masm, temp);
113449:                 return true;
113449:             }
113449: 
113593:             return sps_.push(GetIonContext()->cx, lir->script(), masm, temp);
113587: 
113587:         case MFunctionBoundary::Inline_Exit:
113587:             // all inline returns were covered with ::Exit, so we just need to
113587:             // maintain the state of inline frames currently active and then
113587:             // reenter the caller
113593:             sps_.leaveInlineFrame();
113593:             sps_.reenter(masm, temp);
113587:             return true;
113587: 
113587:         case MFunctionBoundary::Exit:
113593:             if (sps_.slowAssertions()) {
113587:                 typedef bool(*pf)(JSContext *, HandleScript);
113587:                 static const VMFunction SPSExitInfo = FunctionInfo<pf>(SPSExit);
113587: 
113587:                 saveLive(lir);
113587:                 pushArg(ImmGCPtr(lir->script()));
113587:                 // Once we've exited, then we shouldn't emit instrumentation for
113587:                 // the corresponding reenter() because we no longer have a
113587:                 // frame.
113593:                 sps_.skipNextReenter();
113587:                 if (!callVM(SPSExitInfo, lir))
113587:                     return false;
113587:                 restoreLive(lir);
113449:                 return true;
113449:             }
113449: 
113593:             sps_.pop(masm, temp);
113587:             return true;
113587: 
113587:         default:
113587:             JS_NOT_REACHED("invalid LFunctionBoundary type");
113587:     }
113587: }
113587: 
112292: } // namespace ion
112292: } // namespace js
112508: 
