    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: // YY need to pass isMultiple before create called
    1: 
    1: //#include "nsFormControlFrame.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsLegendFrame.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMHTMLFieldSetElement.h"
    1: #include "nsIDOMHTMLLegendElement.h"
    1: #include "nsCSSRendering.h"
    1: //#include "nsIDOMHTMLCollection.h"
    1: #include "nsIContent.h"
    1: #include "nsIFrame.h"
    1: #include "nsISupports.h"
    1: #include "nsIAtom.h"
    1: #include "nsPresContext.h"
    1: #include "nsFrameManager.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsFont.h"
    1: #include "nsCOMPtr.h"
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #endif
    1: #include "nsIServiceManager.h"
    1: #include "nsDisplayList.h"
    1: 
    1: class nsLegendFrame;
    1: 
    1: class nsFieldSetFrame : public nsHTMLContainerFrame {
    1: public:
    1: 
    1:   nsFieldSetFrame(nsStyleContext* aContext);
    1: 
    1:   NS_IMETHOD SetInitialChildList(nsIAtom*       aListName,
    1:                                  nsIFrame*      aChildList);
    1: 
    1:   NS_HIDDEN_(nscoord)
13093:     GetIntrinsicWidth(nsIRenderingContext* aRenderingContext,
13093:                       nsLayoutUtils::IntrinsicWidthType);
    1:   virtual nscoord GetMinWidth(nsIRenderingContext* aRenderingContext);
    1:   virtual nscoord GetPrefWidth(nsIRenderingContext* aRenderingContext);
    1:   virtual nsSize ComputeSize(nsIRenderingContext *aRenderingContext,
    1:                              nsSize aCBSize, nscoord aAvailableWidth,
    1:                              nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                              PRBool aShrinkWrap);
    1: 
    1:   NS_IMETHOD Reflow(nsPresContext*           aPresContext,
    1:                     nsHTMLReflowMetrics&     aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus&          aStatus);
    1:                                
    1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists);
    1: 
    1:   void PaintBorderBackground(nsIRenderingContext& aRenderingContext,
    1:     nsPoint aPt, const nsRect& aDirtyRect);
    1: 
    1:   NS_IMETHOD AppendFrames(nsIAtom*       aListName,
    1:                           nsIFrame*      aFrameList);
    1:   NS_IMETHOD InsertFrames(nsIAtom*       aListName,
    1:                           nsIFrame*      aPrevFrame,
    1:                           nsIFrame*      aFrameList);
    1:   NS_IMETHOD RemoveFrame(nsIAtom*       aListName,
    1:                          nsIFrame*      aOldFrame);
    1: 
    1:   virtual nsIAtom* GetType() const;
    1:   virtual PRBool IsContainingBlock() const;
    1: 
    1: #ifdef ACCESSIBILITY  
    1:   NS_IMETHOD  GetAccessible(nsIAccessible** aAccessible);
    1: #endif
    1: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const {
    1:     return MakeFrameName(NS_LITERAL_STRING("FieldSet"), aResult);
    1:   }
    1: #endif
    1: 
    1: protected:
    1: 
    1:   virtual PRIntn GetSkipSides() const;
    1:   nsIFrame* MaybeSetLegend(nsIFrame* aFrameList, nsIAtom* aListName);
    1:   void ReParentFrameList(nsIFrame* aFrameList);
    1: 
    1:   nsIFrame* mLegendFrame;
    1:   nsIFrame* mContentFrame;
    1:   nsRect    mLegendRect;
    1:   nscoord   mLegendSpace;
    1: };
    1: 
    1: nsIFrame*
    1: NS_NewFieldSetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsFieldSetFrame(aContext);
    1: }
    1: 
    1: nsFieldSetFrame::nsFieldSetFrame(nsStyleContext* aContext)
    1:   : nsHTMLContainerFrame(aContext)
    1: {
    1:   mContentFrame = nsnull;
    1:   mLegendFrame  = nsnull;
    1:   mLegendSpace  = 0;
    1: }
    1: 
    1: nsIAtom*
    1: nsFieldSetFrame::GetType() const
    1: {
    1:   return nsGkAtoms::fieldSetFrame;
    1: }
    1: 
    1: PRBool
    1: nsFieldSetFrame::IsContainingBlock() const
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFieldSetFrame::SetInitialChildList(nsIAtom*       aListName,
    1:                                      nsIFrame*      aChildList)
    1: {
    1:   // Get the content and legend frames.
    1:   if (aChildList->GetNextSibling()) {
    1:     mContentFrame = aChildList->GetNextSibling();
    1:     mLegendFrame  = aChildList;
    1:   } else {
    1:     mContentFrame = aChildList;
    1:     mLegendFrame  = nsnull;
    1:   }
    1: 
    1:   // Queue up the frames for the content frame
    1:   return nsHTMLContainerFrame::SetInitialChildList(nsnull, aChildList);
    1: }
    1: 
    1: class nsDisplayFieldSetBorderBackground : public nsDisplayItem {
    1: public:
    1:   nsDisplayFieldSetBorderBackground(nsFieldSetFrame* aFrame)
    1:     : nsDisplayItem(aFrame) {
    1:     MOZ_COUNT_CTOR(nsDisplayFieldSetBorderBackground);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayFieldSetBorderBackground() {
    1:     MOZ_COUNT_DTOR(nsDisplayFieldSetBorderBackground);
    1:   }
    1: #endif
    1: 
 9799:   virtual nsIFrame* HitTest(nsDisplayListBuilder* aBuilder, nsPoint aPt,
 9799:                             HitTestState* aState);
    1:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect);
    1:   NS_DISPLAY_DECL_NAME("FieldSetBorderBackground")
    1: };
    1: 
    1: nsIFrame* nsDisplayFieldSetBorderBackground::HitTest(nsDisplayListBuilder* aBuilder,
 9799:     nsPoint aPt, HitTestState* aState)
    1: {
    1:   // aPt is guaranteed to be in this item's bounds. We do the hit test based on the
    1:   // frame bounds even though our background doesn't cover the whole frame.
    1:   // It's not clear whether this is correct.
    1:   return mFrame;
    1: }
    1: 
    1: void
    1: nsDisplayFieldSetBorderBackground::Paint(nsDisplayListBuilder* aBuilder,
    1:      nsIRenderingContext* aCtx, const nsRect& aDirtyRect)
    1: {
 3233:   static_cast<nsFieldSetFrame*>(mFrame)->
    1:     PaintBorderBackground(*aCtx, aBuilder->ToReferenceFrame(mFrame), aDirtyRect);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFieldSetFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                   const nsRect&           aDirtyRect,
    1:                                   const nsDisplayListSet& aLists) {
    1:   // Paint our background and border in a special way.
    1:   // REVIEW: We don't really need to check frame emptiness here; if it's empty,
    1:   // the background/border display item won't do anything, and if it isn't empty,
    1:   // we need to paint the outline
    1:   if (IsVisibleForPainting(aBuilder)) {
24818:     if (GetStyleBorder()->mBoxShadow) {
24663:       nsresult rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
24818:           nsDisplayBoxShadowOuter(this));
24663:       NS_ENSURE_SUCCESS(rv, rv);
24818:     }
24663: 
    1:     // don't bother checking to see if we really have a border or background.
    1:     // we usually will have a border.
24818:     nsresult rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayFieldSetBorderBackground(this));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:     rv = DisplayOutlineUnconditional(aBuilder, aLists);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     DO_GLOBAL_REFLOW_COUNT_DSP("nsFieldSetFrame");
    1:   }
    1: 
    1:   nsDisplayListCollection contentDisplayItems;
    1:   if (mContentFrame) {
    1:     // Collect mContentFrame's display items into their own collection. We need
    1:     // to be calling BuildDisplayList on mContentFrame before mLegendFrame in
    1:     // case it contains out-of-flow frames whose placeholders are under
    1:     // mLegendFrame. However, we want mContentFrame's display items to be
    1:     // after mLegendFrame's display items in z-order, so we need to save them
    1:     // and append them later.
    1:     nsresult rv = BuildDisplayListForChild(aBuilder, mContentFrame, aDirtyRect,
    1:                                            contentDisplayItems);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   if (mLegendFrame) {
 8513:     // The legend's background goes on our BlockBorderBackgrounds list because
 8513:     // it's a block child.
 8513:     nsDisplayListSet set(aLists, aLists.BlockBorderBackgrounds());
    1:     nsresult rv = BuildDisplayListForChild(aBuilder, mLegendFrame, aDirtyRect, set);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   // Put mContentFrame's display items on the master list. Note that
    1:   // this moves mContentFrame's border/background display items to our
    1:   // BorderBackground() list, which isn't really correct, but it's OK because
    1:   // mContentFrame is anonymous and can't have its own border and background.
    1:   contentDisplayItems.MoveTo(aLists);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFieldSetFrame::PaintBorderBackground(nsIRenderingContext& aRenderingContext,
    1:     nsPoint aPt, const nsRect& aDirtyRect)
    1: {
    1:   PRIntn skipSides = GetSkipSides();
    1:   const nsStyleBorder* borderStyle = GetStyleBorder();
    1:        
15992:   nscoord topBorder = borderStyle->GetActualBorderWidth(NS_SIDE_TOP);
    1:   nscoord yoff = 0;
  238:   nsPresContext* presContext = PresContext();
    1:      
    1:   // if the border is smaller than the legend. Move the border down
    1:   // to be centered on the legend. 
    1:   if (topBorder < mLegendRect.height)
    1:     yoff = (mLegendRect.height - topBorder)/2;
    1:       
    1:   nsRect rect(aPt.x, aPt.y + yoff, mRect.width, mRect.height - yoff);
    1: 
    1:   nsCSSRendering::PaintBackground(presContext, aRenderingContext, this,
19614:                                   aDirtyRect, rect, PR_TRUE);
    1: 
24818:   nsCSSRendering::PaintBoxShadowInner(presContext, aRenderingContext,
24818:                                       this, rect, aDirtyRect);
24818: 
    1:    if (mLegendFrame) {
    1: 
    1:     // Use the rect of the legend frame, not mLegendRect, so we draw our
    1:     // border under the legend's left and right margins.
    1:     nsRect legendRect = mLegendFrame->GetRect() + aPt;
    1:     
    1:     // we should probably use PaintBorderEdges to do this but for now just use clipping
    1:     // to achieve the same effect.
    1: 
    1:     // draw left side
    1:     nsRect clipRect(rect);
    1:     clipRect.width = legendRect.x - rect.x;
    1:     clipRect.height = topBorder;
    1: 
    1:     aRenderingContext.PushState();
    1:     aRenderingContext.SetClipRect(clipRect, nsClipCombine_kIntersect);
    1:     nsCSSRendering::PaintBorder(presContext, aRenderingContext, this,
16424:                                 aDirtyRect, rect, *borderStyle, mStyleContext,
16424:                                 skipSides);
    1: 
    1:     aRenderingContext.PopState();
    1: 
    1: 
    1:     // draw right side
    1:     clipRect = rect;
    1:     clipRect.x = legendRect.XMost();
    1:     clipRect.width = rect.XMost() - legendRect.XMost();
    1:     clipRect.height = topBorder;
    1: 
    1:     aRenderingContext.PushState();
    1:     aRenderingContext.SetClipRect(clipRect, nsClipCombine_kIntersect);
    1:     nsCSSRendering::PaintBorder(presContext, aRenderingContext, this,
16424:                                 aDirtyRect, rect, *borderStyle, mStyleContext,
16424:                                 skipSides);
    1: 
    1:     aRenderingContext.PopState();
    1: 
    1:     
    1:     // draw bottom
    1:     clipRect = rect;
    1:     clipRect.y += topBorder;
    1:     clipRect.height = mRect.height - (yoff + topBorder);
    1:     
    1:     aRenderingContext.PushState();
    1:     aRenderingContext.SetClipRect(clipRect, nsClipCombine_kIntersect);
    1:     nsCSSRendering::PaintBorder(presContext, aRenderingContext, this,
16424:                                 aDirtyRect, rect, *borderStyle, mStyleContext,
16424:                                 skipSides);
    1: 
    1:     aRenderingContext.PopState();
    1:   } else {
    1: 
    1:     nsCSSRendering::PaintBorder(presContext, aRenderingContext, this,
    1:                                 aDirtyRect,
    1:                                 nsRect(aPt, mRect.Size()),
    1:                                 *borderStyle, mStyleContext, skipSides);
    1:   }
    1: }
    1: 
13093: nscoord
13093: nsFieldSetFrame::GetIntrinsicWidth(nsIRenderingContext* aRenderingContext,
13093:                                    nsLayoutUtils::IntrinsicWidthType aType)
    1: {
13093:   nscoord legendWidth = 0;
13093:   nscoord contentWidth = 0;
13093:   if (mLegendFrame) {
13093:     legendWidth =
13093:       nsLayoutUtils::IntrinsicForContainer(aRenderingContext, mLegendFrame,
13093:                                            aType);
    1:   }
    1: 
13093:   if (mContentFrame) {
13093:     contentWidth =
13093:       nsLayoutUtils::IntrinsicForContainer(aRenderingContext, mContentFrame,
13093:                                            aType);
    1:   }
    1:       
13093:   return PR_MAX(legendWidth, contentWidth);
13093: }
    1: 
    1: 
    1: nscoord
    1: nsFieldSetFrame::GetMinWidth(nsIRenderingContext* aRenderingContext)
    1: {
    1:   nscoord result = 0;
    1:   DISPLAY_MIN_WIDTH(this, result);
    1: 
13093:   result = GetIntrinsicWidth(aRenderingContext, nsLayoutUtils::MIN_WIDTH);
    1:   return result;
    1: }
    1: 
    1: nscoord
    1: nsFieldSetFrame::GetPrefWidth(nsIRenderingContext* aRenderingContext)
    1: {
    1:   nscoord result = 0;
    1:   DISPLAY_PREF_WIDTH(this, result);
    1: 
13093:   result = GetIntrinsicWidth(aRenderingContext, nsLayoutUtils::PREF_WIDTH);
    1:   return result;
    1: }
    1: 
    1: /* virtual */ nsSize
    1: nsFieldSetFrame::ComputeSize(nsIRenderingContext *aRenderingContext,
    1:                              nsSize aCBSize, nscoord aAvailableWidth,
    1:                              nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                              PRBool aShrinkWrap)
    1: {
    1:   nsSize result =
    1:     nsHTMLContainerFrame::ComputeSize(aRenderingContext, aCBSize,
    1:                                       aAvailableWidth,
    1:                                       aMargin, aBorder, aPadding, aShrinkWrap);
    1: 
    1:   // Fieldsets never shrink below their min width.
    1:   nscoord minWidth = GetMinWidth(aRenderingContext);
    1:   if (minWidth > result.width)
    1:     result.width = minWidth;
    1: 
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsFieldSetFrame::Reflow(nsPresContext*           aPresContext,
    1:                         nsHTMLReflowMetrics&     aDesiredSize,
    1:                         const nsHTMLReflowState& aReflowState,
    1:                         nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsFieldSetFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1: 
    1:   NS_PRECONDITION(aReflowState.ComputedWidth() != NS_INTRINSICSIZE,
    1:                   "Should have a precomputed width!");      
    1:   
    1:   // Initialize OUT parameter
    1:   aStatus = NS_FRAME_COMPLETE;
    1: 
    1:   //------------ Handle Incremental Reflow -----------------
    1:   PRBool reflowContent;
    1:   PRBool reflowLegend;
    1: 
    1:   if (aReflowState.ShouldReflowAllKids()) {
    1:     reflowContent = mContentFrame != nsnull;
    1:     reflowLegend = mLegendFrame != nsnull;
    1:   } else {
 1158:     reflowContent = mContentFrame && NS_SUBTREE_DIRTY(mContentFrame);
 1158:     reflowLegend = mLegendFrame && NS_SUBTREE_DIRTY(mLegendFrame);
    1:   }
    1: 
28110:   // We don't allow fieldsets to break vertically. If we did, we'd
28110:   // need logic here to push and pull overflow frames.
28110:   nsSize availSize(aReflowState.ComputedWidth(), NS_UNCONSTRAINEDSIZE);
    1:   NS_ASSERTION(!mContentFrame ||
13093:       nsLayoutUtils::IntrinsicForContainer(aReflowState.rendContext,
13093:                                            mContentFrame,
13093:                                            nsLayoutUtils::MIN_WIDTH) <=
13093:                availSize.width,
13093:                "Bogus availSize.width; should be bigger");
13093:   NS_ASSERTION(!mLegendFrame ||
13093:       nsLayoutUtils::IntrinsicForContainer(aReflowState.rendContext,
13093:                                            mLegendFrame,
13093:                                            nsLayoutUtils::MIN_WIDTH) <=
13093:                availSize.width,
    1:                "Bogus availSize.width; should be bigger");
    1: 
    1:   // get our border and padding
    1:   const nsMargin &borderPadding = aReflowState.mComputedBorderPadding;
15758:   nsMargin border = borderPadding - aReflowState.mComputedPadding;  
    1: 
    1:   // Figure out how big the legend is if there is one. 
    1:   // get the legend's margin
    1:   nsMargin legendMargin(0,0,0,0);
    1:   // reflow the legend only if needed
    1:   if (reflowLegend) {
    1:     nsHTMLReflowState legendReflowState(aPresContext, aReflowState,
13093:                                         mLegendFrame, availSize);
    1: 
    1:     nsHTMLReflowMetrics legendDesiredSize;
    1: 
    1:     ReflowChild(mLegendFrame, aPresContext, legendDesiredSize, legendReflowState,
    1:                 0, 0, NS_FRAME_NO_MOVE_FRAME, aStatus);
    1: #ifdef NOISY_REFLOW
    1:     printf("  returned (%d, %d)\n", legendDesiredSize.width, legendDesiredSize.height);
    1: #endif
    1:     // figure out the legend's rectangle
15758:     legendMargin = mLegendFrame->GetUsedMargin();
    1:     mLegendRect.width  = legendDesiredSize.width + legendMargin.left + legendMargin.right;
    1:     mLegendRect.height = legendDesiredSize.height + legendMargin.top + legendMargin.bottom;
    1:     mLegendRect.x = borderPadding.left;
    1:     mLegendRect.y = 0;
    1: 
    1:     nscoord oldSpace = mLegendSpace;
    1:     mLegendSpace = 0;
    1:     if (mLegendRect.height > border.top) {
    1:       // center the border on the legend
    1:       mLegendSpace = mLegendRect.height - border.top;
    1:     } else {
    1:       mLegendRect.y = (border.top - mLegendRect.height)/2;
    1:     }
    1: 
    1:     // if the legend space changes then we need to reflow the 
    1:     // content area as well.
    1:     if (mLegendSpace != oldSpace && mContentFrame) {
    1:       reflowContent = PR_TRUE;
    1:     }
    1: 
    1:     FinishReflowChild(mLegendFrame, aPresContext, &legendReflowState, 
    1:                       legendDesiredSize, 0, 0, NS_FRAME_NO_MOVE_FRAME);    
    1:   } else if (!mLegendFrame) {
    1:     mLegendRect.Empty();
    1:     mLegendSpace = 0;
15758:   } else {
15758:     // mLegendSpace and mLegendRect haven't changed, but we need
15758:     // the used margin when placing the legend.
15758:     legendMargin = mLegendFrame->GetUsedMargin();
15758:   }
    1: 
    1:   // reflow the content frame only if needed
    1:   if (reflowContent) {
    1:     nsHTMLReflowState kidReflowState(aPresContext, aReflowState, mContentFrame,
    1:                                      availSize);
 7676:     // Our child is "height:100%" but we actually want its height to be reduced
 7676:     // by the amount of content-height the legend is eating up, unless our
 7676:     // height is unconstrained (in which case the child's will be too).
 7676:     if (aReflowState.ComputedHeight() != NS_UNCONSTRAINEDSIZE) {
 7676:       kidReflowState.SetComputedHeight(PR_MAX(0, aReflowState.ComputedHeight() - mLegendSpace));
 7676:     }
    1: 
16507:     kidReflowState.mComputedMinHeight =
16507:       PR_MAX(0, aReflowState.mComputedMinHeight - mLegendSpace);
16507: 
16507:     if (aReflowState.mComputedMaxHeight != NS_UNCONSTRAINEDSIZE) {
16507:       kidReflowState.mComputedMaxHeight =
16507:         PR_MAX(0, aReflowState.mComputedMaxHeight - mLegendSpace);
16507:     }
16507: 
    1:     nsHTMLReflowMetrics kidDesiredSize(aDesiredSize.mFlags);
    1:     // Reflow the frame
 7676:     NS_ASSERTION(kidReflowState.mComputedMargin == nsMargin(0,0,0,0),
 7676:                  "Margins on anonymous fieldset child not supported!");
 7676:     nsPoint pt(borderPadding.left, borderPadding.top + mLegendSpace);
    1:     ReflowChild(mContentFrame, aPresContext, kidDesiredSize, kidReflowState,
 7676:                 pt.x, pt.y, 0, aStatus);
    1: 
 7676:     FinishReflowChild(mContentFrame, aPresContext, &kidReflowState, 
 7676:                       kidDesiredSize, pt.x, pt.y, 0);
 7676:     NS_FRAME_TRACE_REFLOW_OUT("FieldSet::Reflow", aStatus);
    1:   }
    1: 
 7676:   nsRect contentRect(0,0,0,0);
 7676:   if (mContentFrame) {
15758:     // We don't support margins on mContentFrame, so our "content rect" is just
 7676:     // its rect.
    1:     contentRect = mContentFrame->GetRect();
    1:   }
    1: 
    1:   // use the computed width if the inner content does not fill it
    1:   if (aReflowState.ComputedWidth() > contentRect.width) {
    1:     contentRect.width = aReflowState.ComputedWidth();
    1:   }
    1: 
    1:   if (mLegendFrame) {
    1:     // if the content rect is larger then the  legend we can align the legend
    1:     if (contentRect.width > mLegendRect.width) {
15758:       PRInt32 align = static_cast<nsLegendFrame*>(mLegendFrame)->GetAlign();
    1: 
    1:       switch(align) {
    1:         case NS_STYLE_TEXT_ALIGN_RIGHT:
    1:           mLegendRect.x = contentRect.width - mLegendRect.width + borderPadding.left;
    1:           break;
    1:         case NS_STYLE_TEXT_ALIGN_CENTER:
    1:           // Note: rounding removed; there doesn't seem to be any need
    1:           mLegendRect.x = contentRect.width / 2 - mLegendRect.width / 2 + borderPadding.left;
    1:           break;
    1:       }
    1:   
    1:     } else {
    1:       // otherwise make place for the legend
    1:       contentRect.width = mLegendRect.width;
    1:     }
    1:     // place the legend
    1:     nsRect actualLegendRect(mLegendRect);
    1:     actualLegendRect.Deflate(legendMargin);
    1: 
    1:     nsPoint curOrigin = mLegendFrame->GetPosition();
    1: 
    1:     // only if the origin changed
    1:     if ((curOrigin.x != mLegendRect.x) || (curOrigin.y != mLegendRect.y)) {
    1:       mLegendFrame->SetPosition(nsPoint(actualLegendRect.x , actualLegendRect.y));
    1:       nsContainerFrame::PositionFrameView(mLegendFrame);
    1: 
    1:       // We need to recursively process the legend frame's
    1:       // children since we're moving the frame after Reflow.
    1:       nsContainerFrame::PositionChildViews(mLegendFrame);
    1:     }
    1:   }
    1: 
    1:   // Return our size and our result
 4166:   if (aReflowState.ComputedHeight() == NS_INTRINSICSIZE) {
    1:     aDesiredSize.height = mLegendSpace + 
 4166:                           borderPadding.TopBottom() +
 4166:                           contentRect.height;
    1:   } else {
 4166:     nscoord min = borderPadding.TopBottom() + mLegendRect.height;
 4166:     aDesiredSize.height =
 4166:       aReflowState.ComputedHeight() + borderPadding.TopBottom();
    1:     if (aDesiredSize.height < min)
    1:       aDesiredSize.height = min;
    1:   }
 4166:   aDesiredSize.width = contentRect.width + borderPadding.LeftRight();
    1:   aDesiredSize.mOverflowArea = nsRect(0, 0, aDesiredSize.width, aDesiredSize.height);
    1:   if (mLegendFrame)
    1:     ConsiderChildOverflow(aDesiredSize.mOverflowArea, mLegendFrame);
    1:   if (mContentFrame)
    1:     ConsiderChildOverflow(aDesiredSize.mOverflowArea, mContentFrame);
    1:   FinishAndStoreOverflow(&aDesiredSize);
    1: 
    1:   Invalidate(aDesiredSize.mOverflowArea);
    1: 
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
    1:   return NS_OK;
    1: }
    1: 
    1: PRIntn
    1: nsFieldSetFrame::GetSkipSides() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFieldSetFrame::AppendFrames(nsIAtom*       aListName,
    1:                               nsIFrame*      aFrameList)
    1: {
    1:   aFrameList = MaybeSetLegend(aFrameList, aListName);
    1:   if (aFrameList) {
    1:     ReParentFrameList(aFrameList);
    1:     return mContentFrame->AppendFrames(aListName, aFrameList);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFieldSetFrame::InsertFrames(nsIAtom*       aListName,
    1:                               nsIFrame*      aPrevFrame,
    1:                               nsIFrame*      aFrameList)
    1: {
    1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this ||
    1:                aPrevFrame->GetParent() == mContentFrame,
    1:                "inserting after sibling frame with different parent");
    1: 
    1:   aFrameList = MaybeSetLegend(aFrameList, aListName);
    1:   if (aFrameList) {
    1:     ReParentFrameList(aFrameList);
    1:     if (NS_UNLIKELY(aPrevFrame == mLegendFrame)) {
    1:       aPrevFrame = nsnull;
    1:     }
    1:     return mContentFrame->InsertFrames(aListName, aPrevFrame, aFrameList);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFieldSetFrame::RemoveFrame(nsIAtom*       aListName,
    1:                              nsIFrame*      aOldFrame)
    1: {
    1:   // For reference, see bug 70648, bug 276104 and bug 236071.
    1:   if (aOldFrame == mLegendFrame) {
    1:     NS_ASSERTION(!aListName, "Unexpected frame list when removing legend frame");
    1:     NS_ASSERTION(mLegendFrame->GetParent() == this, "Legend Parent has wrong parent");
    1:     NS_ASSERTION(mLegendFrame->GetNextSibling() == mContentFrame, "mContentFrame is not next sibling");
    1: 
    1:     mFrames.DestroyFrame(mLegendFrame);
    1:     mLegendFrame = nsnull;
  238:     PresContext()->PresShell()->
 1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange, NS_FRAME_IS_DIRTY);
    1:     return NS_OK;
    1:   }
    1:   return mContentFrame->RemoveFrame(aListName, aOldFrame);
    1: }
    1: 
    1: #ifdef ACCESSIBILITY
    1: NS_IMETHODIMP nsFieldSetFrame::GetAccessible(nsIAccessible** aAccessible)
    1: {
    1:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
    1: 
    1:   if (accService) {
 3233:     return accService->CreateHTMLGroupboxAccessible(static_cast<nsIFrame*>(this), aAccessible);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: #endif
    1: 
    1: nsIFrame*
    1: nsFieldSetFrame::MaybeSetLegend(nsIFrame* aFrameList, nsIAtom* aListName)
    1: {
    1:   if (!mLegendFrame && aFrameList->GetType() == nsGkAtoms::legendFrame) {
    1:     NS_ASSERTION(!aListName, "Unexpected frame list when adding legend frame");
    1:     mLegendFrame = aFrameList;
    1:     aFrameList = mLegendFrame->GetNextSibling();
    1:     mLegendFrame->SetNextSibling(mContentFrame);
    1:     mFrames.SetFrames(mLegendFrame);
  238:     PresContext()->PresShell()->
 1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                        NS_FRAME_HAS_DIRTY_CHILDREN);
    1:   }
    1:   return aFrameList;
    1: }
    1: 
    1: void
    1: nsFieldSetFrame::ReParentFrameList(nsIFrame* aFrameList)
    1: {
  238:   nsFrameManager* frameManager = PresContext()->FrameManager();
    1:   for (nsIFrame* frame = aFrameList; frame; frame = frame->GetNextSibling()) {
    1:     frame->SetParent(mContentFrame);
    1:     frameManager->ReParentStyleContext(frame);
    1:   }
    1:   mContentFrame->AddStateBits(GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW);
    1: }
