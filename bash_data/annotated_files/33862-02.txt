26702: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
26702: /* ***** BEGIN LICENSE BLOCK *****
26702:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
26702:  * 
26702:  * The contents of this file are subject to the Mozilla Public License Version
26702:  * 1.1 (the "License"); you may not use this file except in compliance with
26702:  * the License. You may obtain a copy of the License at
26702:  * http://www.mozilla.org/MPL/
26702:  *
26702:  * Software distributed under the License is distributed on an "AS IS" basis,
26702:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
26702:  * for the specific language governing rights and limitations under the
26702:  * License.
26702:  * 
26702:  * The Original Code is Mozilla MathML Project.
26702:  * 
26702:  * The Initial Developer of the Original Code is
26702:  * The University of Queensland.
26702:  * Portions created by the Initial Developer are Copyright (C) 1999
26702:  * the Initial Developer. All Rights Reserved.
26702:  * 
26702:  * Contributor(s): 
26702:  *   Roger B. Sidje <rbs@maths.uq.edu.au>
26702:  *   Karl Tomlinson <karlt+@karlt.net>, Mozilla Corporation
26702:  *
26702:  * Alternatively, the contents of this file may be used under the terms of
26702:  * either the GNU General Public License Version 2 or later (the "GPL"), or
26702:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
26702:  * in which case the provisions of the GPL or the LGPL are applicable instead
26702:  * of those above. If you wish to allow use of your version of this file only
26702:  * under the terms of either the GPL or the LGPL, and not to allow others to
26702:  * use your version of this file under the terms of the MPL, indicate your
26702:  * decision by deleting the provisions above and replace them with the notice
26702:  * and other provisions required by the GPL or the LGPL. If you do not delete
26702:  * the provisions above, a recipient may use your version of this file under
26702:  * the terms of any one of the MPL, the GPL or the LGPL.
26702:  *
26702:  * ***** END LICENSE BLOCK ***** */
26702: 
26702: #include "nsCOMPtr.h"
26702: #include "nsFrame.h"
26702: #include "nsPresContext.h"
26702: #include "nsStyleContext.h"
26702: #include "nsStyleConsts.h"
26702: #include "nsIRenderingContext.h"
26702: #include "nsIFontMetrics.h"
26702: #include "nsContentUtils.h"
26702: #include "nsCSSFrameConstructor.h"
26702: #include "nsMathMLTokenFrame.h"
26702: 
26702: nsIFrame*
26702: NS_NewMathMLTokenFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
26702: {
26702:   return new (aPresShell) nsMathMLTokenFrame(aContext);
26702: }
32423: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsMathMLTokenFrame)
32423: 
26702: nsMathMLTokenFrame::~nsMathMLTokenFrame()
26702: {
26702: }
26702: 
26702: eMathMLFrameType
26702: nsMathMLTokenFrame::GetMathMLFrameType()
26702: {
26702:   // treat everything other than <mi> as ordinary...
26702:   if (mContent->Tag() != nsGkAtoms::mi_) {
26702:     return eMathMLFrameType_Ordinary;
26702:   }
26702: 
26702:   // for <mi>, distinguish between italic and upright...
26702:   // Don't use nsMathMLFrame::GetAttribute for mathvariant or fontstyle as
26702:   // default values are not inherited.
26702:   nsAutoString style;
26702:   // mathvariant overrides fontstyle
26702:   // http://www.w3.org/TR/2003/REC-MathML2-20031021/chapter3.html#presm.deprecatt
26702:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::MOZfontstyle, style) ||
26702:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::mathvariant_, style) ||
26702:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::fontstyle_, style);
26702: 
26702:   if (style.EqualsLiteral("italic") || style.EqualsLiteral("bold-italic") ||
26702:       style.EqualsLiteral("script") || style.EqualsLiteral("bold-script") ||
26702:       style.EqualsLiteral("sans-serif-italic") ||
26702:       style.EqualsLiteral("sans-serif-bold-italic")) {
26702:     return eMathMLFrameType_ItalicIdentifier;
26702:   }
26702:   else if(style.EqualsLiteral("invariant")) {
26702:     nsAutoString data;
26702:     nsContentUtils::GetNodeTextContent(mContent, PR_FALSE, data);
26702:     eMATHVARIANT variant = nsMathMLOperators::LookupInvariantChar(data);
26702: 
26702:     switch (variant) {
26702:     case eMATHVARIANT_italic:
26702:     case eMATHVARIANT_bold_italic:
26702:     case eMATHVARIANT_script:
26702:     case eMATHVARIANT_bold_script:
26702:     case eMATHVARIANT_sans_serif_italic:
26702:     case eMATHVARIANT_sans_serif_bold_italic:
26702:       return eMathMLFrameType_ItalicIdentifier;
26702:     default:
26702:       ; // fall through to upright
26702:     }
26702:   }
26702:   return eMathMLFrameType_UprightIdentifier;
26702: }
26702: 
26702: static void
26702: CompressWhitespace(nsIContent* aContent)
26702: {
26702:   PRUint32 numKids = aContent->GetChildCount();
26702:   for (PRUint32 kid = 0; kid < numKids; kid++) {
26702:     nsIContent* cont = aContent->GetChildAt(kid);
26702:     if (cont && cont->IsNodeOfType(nsINode::eTEXT)) {
26702:       nsAutoString text;
26702:       cont->AppendTextTo(text);
26702:       text.CompressWhitespace();
26702:       cont->SetText(text, PR_FALSE); // not meant to be used if notify is needed
26702:     }
26702:   }
26702: }
26702: 
26702: NS_IMETHODIMP
26702: nsMathMLTokenFrame::Init(nsIContent*      aContent,
26702:                          nsIFrame*        aParent,
26702:                          nsIFrame*        aPrevInFlow)
26702: {
26702:   // leading and trailing whitespace doesn't count -- bug 15402
26702:   // brute force removal for people who do <mi> a </mi> instead of <mi>a</mi>
26702:   // XXX the best fix is to skip these in nsTextFrame
26702:   CompressWhitespace(aContent);
26702: 
26702:   // let the base class do its Init()
26702:   return nsMathMLContainerFrame::Init(aContent, aParent, aPrevInFlow);
26702: }
26702: 
26702: NS_IMETHODIMP
26702: nsMathMLTokenFrame::SetInitialChildList(nsIAtom*        aListName,
30790:                                         nsFrameList&    aChildList)
26702: {
26702:   // First, let the base class do its work
26702:   nsresult rv = nsMathMLContainerFrame::SetInitialChildList(aListName, aChildList);
26702:   if (NS_FAILED(rv))
26702:     return rv;
26702: 
33862:   SetQuotes(PR_FALSE);
26702:   ProcessTextData();
26702:   return rv;
26702: }
26702: 
26702: nsresult
26702: nsMathMLTokenFrame::Reflow(nsPresContext*          aPresContext,
26702:                            nsHTMLReflowMetrics&     aDesiredSize,
26702:                            const nsHTMLReflowState& aReflowState,
26702:                            nsReflowStatus&          aStatus)
26702: {
26702:   nsresult rv = NS_OK;
26702: 
26702:   // initializations needed for empty markup like <mtag></mtag>
26702:   aDesiredSize.width = aDesiredSize.height = 0;
26702:   aDesiredSize.ascent = 0;
26702:   aDesiredSize.mBoundingMetrics.Clear();
26702: 
26702:   nsSize availSize(aReflowState.ComputedWidth(), NS_UNCONSTRAINEDSIZE);
26702:   nsIFrame* childFrame = GetFirstChild(nsnull);
26702:   while (childFrame) {
26702:     // ask our children to compute their bounding metrics
26702:     nsHTMLReflowMetrics childDesiredSize(aDesiredSize.mFlags
26702:                                          | NS_REFLOW_CALC_BOUNDING_METRICS);
26702:     nsHTMLReflowState childReflowState(aPresContext, aReflowState,
26702:                                        childFrame, availSize);
26702:     rv = ReflowChild(childFrame, aPresContext, childDesiredSize,
26702:                      childReflowState, aStatus);
26702:     //NS_ASSERTION(NS_FRAME_IS_COMPLETE(aStatus), "bad status");
26702:     if (NS_FAILED(rv)) {
26702:       // Call DidReflow() for the child frames we successfully did reflow.
26702:       DidReflowChildren(GetFirstChild(nsnull), childFrame);
26702:       return rv;
26702:     }
26702: 
26702:     SaveReflowAndBoundingMetricsFor(childFrame, childDesiredSize,
26702:                                     childDesiredSize.mBoundingMetrics);
26702: 
26702:     childFrame = childFrame->GetNextSibling();
26702:   }
26702: 
26702: 
26702:   // place and size children
26702:   FinalizeReflow(*aReflowState.rendContext, aDesiredSize);
26702: 
26702:   aStatus = NS_FRAME_COMPLETE;
26702:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
26702:   return NS_OK;
26702: }
26702: 
26702: // For token elements, mBoundingMetrics is computed at the ReflowToken
26702: // pass, it is not computed here because our children may be text frames
26702: // that do not implement the GetBoundingMetrics() interface.
26702: /* virtual */ nsresult
26702: nsMathMLTokenFrame::Place(nsIRenderingContext& aRenderingContext,
26702:                           PRBool               aPlaceOrigin,
26702:                           nsHTMLReflowMetrics& aDesiredSize)
26702: {
26702:   mBoundingMetrics.Clear();
26702:   for (nsIFrame* childFrame = GetFirstChild(nsnull); childFrame;
26702:        childFrame = childFrame->GetNextSibling()) {
26702:     nsHTMLReflowMetrics childSize;
26702:     GetReflowAndBoundingMetricsFor(childFrame, childSize,
26702:                                    childSize.mBoundingMetrics, nsnull);
26702:     // compute and cache the bounding metrics
26702:     mBoundingMetrics += childSize.mBoundingMetrics;
26702:   }
26702: 
26702:   nsCOMPtr<nsIFontMetrics> fm =
26702:     PresContext()->GetMetricsFor(GetStyleFont()->mFont);
26702:   nscoord ascent, descent;
26702:   fm->GetMaxAscent(ascent);
26702:   fm->GetMaxDescent(descent);
26702: 
26702:   aDesiredSize.mBoundingMetrics = mBoundingMetrics;
26702:   aDesiredSize.width = mBoundingMetrics.width;
32531:   aDesiredSize.ascent = NS_MAX(mBoundingMetrics.ascent, ascent);
26702:   aDesiredSize.height = aDesiredSize.ascent +
32531:                         NS_MAX(mBoundingMetrics.descent, descent);
26702: 
26702:   if (aPlaceOrigin) {
26702:     nscoord dy, dx = 0;
26702:     for (nsIFrame* childFrame = GetFirstChild(nsnull); childFrame;
26702:          childFrame = childFrame->GetNextSibling()) {
26702:       nsHTMLReflowMetrics childSize;
26702:       GetReflowAndBoundingMetricsFor(childFrame, childSize,
26702:                                      childSize.mBoundingMetrics);
26702: 
26702:       // place and size the child; (dx,0) makes the caret happy - bug 188146
26702:       dy = childSize.height == 0 ? 0 : aDesiredSize.ascent - childSize.ascent;
26702:       FinishReflowChild(childFrame, PresContext(), nsnull, childSize, dx, dy, 0);
26702:       dx += childSize.width;
26702:     }
26702:   }
26702: 
26702:   SetReference(nsPoint(0, aDesiredSize.ascent));
26702: 
26702:   return NS_OK;
26702: }
26702: 
26702: /* virtual */ void
26702: nsMathMLTokenFrame::MarkIntrinsicWidthsDirty()
26702: {
26702:   // this could be called due to changes in the nsTextFrame beneath us
26702:   // when something changed in the text content. So re-process our text
26702:   ProcessTextData();
26702: 
26702:   nsMathMLContainerFrame::MarkIntrinsicWidthsDirty();
26702: }
26702: 
26702: NS_IMETHODIMP
26702: nsMathMLTokenFrame::AttributeChanged(PRInt32         aNameSpaceID,
26702:                                      nsIAtom*        aAttribute,
26702:                                      PRInt32         aModType)
26702: {
26702:   if (nsGkAtoms::lquote_ == aAttribute ||
26702:       nsGkAtoms::rquote_ == aAttribute) {
33862:     SetQuotes(PR_TRUE);
26702:   }
26702: 
26702:   return nsMathMLContainerFrame::
26702:          AttributeChanged(aNameSpaceID, aAttribute, aModType);
26702: }
26702: 
26702: void
26702: nsMathMLTokenFrame::ProcessTextData()
26702: {
26702:   // see if the style changes from normal to italic or vice-versa
26702:   if (!SetTextStyle())
26702:     return;
26702: 
26702:   // explicitly request a re-resolve to pick up the change of style
26702:   PresContext()->PresShell()->FrameConstructor()->
26702:     PostRestyleEvent(mContent, eReStyle_Self, NS_STYLE_HINT_NONE);
26702: }
26702: 
26702: ///////////////////////////////////////////////////////////////////////////
26702: // For <mi>, if the content is not a single character, turn the font to
26702: // normal (this function will also query attributes from the mstyle hierarchy)
26702: // Returns PR_TRUE if there is a style change.
26702: //
26702: // http://www.w3.org/TR/2003/REC-MathML2-20031021/chapter3.html#presm.commatt
26702: //
26702: //  "It is important to note that only certain combinations of
26702: //   character data and mathvariant attribute values make sense.
26702: //   ...
26702: //   By design, the only cases that have an unambiguous
26702: //   interpretation are exactly the ones that correspond to SMP Math
26702: //   Alphanumeric Symbol characters, which are enumerated in Section
26702: //   6.2.3 Mathematical Alphanumeric Symbols Characters. In all other
26702: //   cases, it is suggested that renderers ignore the value of the
26702: //   mathvariant attribute if it is present."
26702: //
26702: // There are no corresponding characters for mathvariant=normal, suggesting
26702: // that this value should be ignored, but this (from the same section of
26702: // Chapter 3) implies that font-style should not be inherited, but set to
26702: // normal for mathvariant=normal:
26702: //
26702: //  "In particular, inheritance of the mathvariant attribute does not follow
26702: //   the CSS model. The default value for this attribute is "normal"
26702: //   (non-slanted) for all tokens except mi. ... (The deprecated fontslant
26702: //   attribute also behaves this way.)"
26702: 
26702: PRBool
26702: nsMathMLTokenFrame::SetTextStyle()
26702: {
26702:   if (mContent->Tag() != nsGkAtoms::mi_)
26702:     return PR_FALSE;
26702: 
26702:   if (!mFrames.FirstChild())
26702:     return PR_FALSE;
26702: 
26702:   // Get the text content that we enclose and its length
26702:   nsAutoString data;
26702:   nsContentUtils::GetNodeTextContent(mContent, PR_FALSE, data);
26702:   PRInt32 length = data.Length();
26702:   if (!length)
26702:     return PR_FALSE;
26702: 
26702:   nsAutoString fontstyle;
26702:   PRBool isSingleCharacter =
26702:     length == 1 ||
26702:     (length == 2 && NS_IS_HIGH_SURROGATE(data[0]));
26702:   if (isSingleCharacter &&
26702:       nsMathMLOperators::LookupInvariantChar(data) != eMATHVARIANT_NONE) {
26702:     // bug 65951 - a non-stylable character has its own intrinsic appearance
26702:     fontstyle.AssignLiteral("invariant");
26702:   }
26702:   else {
26702:     // Attributes override the default behavior.
26702:     if (!(mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::mathvariant_) ||
26702:           mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::fontstyle_))) {
26702:       if (!isSingleCharacter) {
26702:         fontstyle.AssignLiteral("normal");
26702:       }
26702:       else if (length == 1 && // BMP
26702:                !nsMathMLOperators::
26702:                 TransformVariantChar(data[0], eMATHVARIANT_italic).
26702:                 Equals(data)) {
26702:         // Transformation exists.  Try to make the BMP character look like the
26702:         // styled character using the style system until bug 114365 is resolved.
26702:         fontstyle.AssignLiteral("italic");
26702:       }
26702:       // else single character but there is no corresponding Math Alphanumeric
26702:       // Symbol character: "ignore the value of the [default] mathvariant
26702:       // attribute".
26702:     }
26702:   }
26702: 
26702:   // set the -moz-math-font-style attribute without notifying that we want a reflow
26702:   if (fontstyle.IsEmpty()) {
26702:     if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::MOZfontstyle)) {
26702:       mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::MOZfontstyle, PR_FALSE);
26702:       return PR_TRUE;
26702:     }
26702:   }
26702:   else if (!mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::MOZfontstyle,
26702:                                   fontstyle, eCaseMatters)) {
26702:     mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::MOZfontstyle,
26702:                       fontstyle, PR_FALSE);
26702:     return PR_TRUE;
26702:   }
26702: 
26702:   return PR_FALSE;
26702: }
26702: 
26702: ///////////////////////////////////////////////////////////////////////////
26702: // For <ms>, it is assumed that the mathml.css file contains two rules:
26702: // ms:before { content: open-quote; }
26702: // ms:after { content: close-quote; }
26702: // With these two rules, the frame construction code will
26702: // create inline frames that contain text frames which themselves
26702: // contain the text content of the quotes.
26702: // So the main idea in this code is to see if there are lquote and 
26702: // rquote attributes. If these are there, we ovewrite the default
26702: // quotes in the text frames.
33862: // XXX this is somewhat bogus, we probably should map lquote and rquote
33862: // to 'content' style rules
26702: //
26702: // But what if the mathml.css file wasn't loaded? 
26702: // We also check that we are not relying on null pointers...
26702: 
26702: static void
33862: SetQuote(nsIFrame* aFrame, nsString& aValue, PRBool aNotify)
26702: {
33862:   if (!aFrame)
33862:     return;
33862: 
33862:   nsIFrame* textFrame = aFrame->GetFirstChild(nsnull);
33862:   if (!textFrame)
33862:     return;
33862: 
26702:   nsIContent* quoteContent = textFrame->GetContent();
33862:   if (!quoteContent->IsNodeOfType(nsINode::eTEXT))
33862:     return;
33862: 
33862:   quoteContent->SetText(aValue, aNotify);
26702: }
26702: 
26702: void
33862: nsMathMLTokenFrame::SetQuotes(PRBool aNotify)
26702: {
26702:   if (mContent->Tag() != nsGkAtoms::ms_)
26702:     return;
26702: 
26702:   nsAutoString value;
26702:   // lquote
26702:   if (GetAttribute(mContent, mPresentationData.mstyle,
26702:                    nsGkAtoms::lquote_, value)) {
33862:     SetQuote(nsLayoutUtils::GetBeforeFrame(this), value, aNotify);
26702:   }
26702:   // rquote
26702:   if (GetAttribute(mContent, mPresentationData.mstyle,
26702:                    nsGkAtoms::rquote_, value)) {
33862:     SetQuote(nsLayoutUtils::GetAfterFrame(this), value, aNotify);
26702:   }
26702: }
