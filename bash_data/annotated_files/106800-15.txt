     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 95360: #include "HTMLFormControlAccessible.h"
 41384: 
 95352: #include "Accessible-inl.h"
 41384: #include "nsAccUtils.h"
 95352: #include "nsARIAMap.h"
106800: #include "nsEventShell.h"
 41384: #include "nsTextEquivUtils.h"
 87094: #include "Relation.h"
 87094: #include "Role.h"
 87094: #include "States.h"
 41384: 
 99796: #include "nsContentList.h"
 75194: #include "nsIAccessibleRelation.h"
     1: #include "nsIDOMHTMLInputElement.h"
     1: #include "nsIDOMNSEditableElement.h"
     1: #include "nsIDOMHTMLFormElement.h"
     1: #include "nsIDOMHTMLLegendElement.h"
     1: #include "nsIDOMHTMLTextAreaElement.h"
 75263: #include "nsIDOMNodeList.h"
  4625: #include "nsIEditor.h"
 99796: #include "nsIFormControl.h"
     1: #include "nsIFrame.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsISelectionController.h"
  3945: #include "jsapi.h"
  3945: #include "nsIJSContextStack.h"
  3945: #include "nsIServiceManager.h"
     1: #include "nsITextControlFrame.h"
     1: 
 97984: #include "mozilla/Preferences.h"
 97984: 
 97984: using namespace mozilla;
 74618: using namespace mozilla::a11y;
 74618: 
 43504: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLCheckboxAccessible
 43504: ////////////////////////////////////////////////////////////////////////////////
     1: 
 95360: HTMLCheckboxAccessible::
 99568:   HTMLCheckboxAccessible(nsIContent* aContent, DocAccessible* aDoc) :
101054:   LeafAccessible(aContent, aDoc)
     1: {
     1: }
     1: 
 87094: role
 95360: HTMLCheckboxAccessible::NativeRole()
     1: {
 87094:   return roles::CHECKBUTTON;
     1: }
     1: 
 74781: PRUint8
 95360: HTMLCheckboxAccessible::ActionCount()
     1: {
 74781:   return 1;
     1: }
     1: 
 95360: NS_IMETHODIMP
 95360: HTMLCheckboxAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
     1: {
     1:   if (aIndex == eAction_Click) {    // 0 is the magic value for default action
 25871:     // cycle, check or uncheck
 67790:     PRUint64 state = NativeState();
     1: 
 67790:     if (state & states::CHECKED)
     1:       aName.AssignLiteral("uncheck"); 
 67790:     else if (state & states::MIXED)
 25871:       aName.AssignLiteral("cycle"); 
     1:     else
     1:       aName.AssignLiteral("check"); 
     1: 
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
 37481: NS_IMETHODIMP
 95360: HTMLCheckboxAccessible::DoAction(PRUint8 aIndex)
     1: {
 37481:   if (aIndex != 0)
     1:     return NS_ERROR_INVALID_ARG;
 37481: 
 37481:   DoCommand();
 37481:   return NS_OK;
     1: }
     1: 
 67790: PRUint64
 95360: HTMLCheckboxAccessible::NativeState()
     1: {
101054:   PRUint64 state = LeafAccessible::NativeState();
   262: 
 67790:   state |= states::CHECKABLE;
 79445:   bool checkState = false;   // Radio buttons and check boxes can be checked or mixed
     1: 
 43504:   nsCOMPtr<nsIDOMHTMLInputElement> htmlCheckboxElement =
 43504:     do_QueryInterface(mContent);
 48892:            
 24914:   if (htmlCheckboxElement) {
 67790:     htmlCheckboxElement->GetIndeterminate(&checkState);
     1: 
 67790:     if (checkState) {
 67790:       state |= states::MIXED;
 48892:     } else {   // indeterminate can't be checked at the same time.
 67790:       htmlCheckboxElement->GetChecked(&checkState);
 48892:     
 67790:       if (checkState)
 67790:         state |= states::CHECKED;
 24914:     }
 48892:   }
 67790:   return state;
     1: }
     1: 
 36879: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLCheckboxAccessible: Widgets
 79440: 
 79440: bool
 95360: HTMLCheckboxAccessible::IsWidget() const
 79440: {
 79440:   return true;
 79440: }
 79440: 
 79440: 
 79440: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLRadioButtonAccessible
 36879: ////////////////////////////////////////////////////////////////////////////////
     1: 
 95360: HTMLRadioButtonAccessible::
 99568:   HTMLRadioButtonAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 95360:   RadioButtonAccessible(aContent, aDoc)
     1: {
     1: }
     1: 
 67790: PRUint64
 95360: HTMLRadioButtonAccessible::NativeState()
     1: {
 99648:   PRUint64 state = AccessibleWrap::NativeState();
   262: 
 67790:   state |= states::CHECKABLE;
  1157: 
 79445:   bool checked = false;   // Radio buttons and check boxes can be checked
 43504:   nsCOMPtr<nsIDOMHTMLInputElement> htmlRadioElement =
 43504:     do_QueryInterface(mContent);
     1:   if (htmlRadioElement)
     1:     htmlRadioElement->GetChecked(&checked);
     1: 
     1:   if (checked)
 67790:     state |= states::CHECKED;
     1: 
 67790:   return state;
     1: }
     1: 
 36879: void
 95360: HTMLRadioButtonAccessible::GetPositionAndSizeInternal(PRInt32* aPosInSet,
 36879:                                                       PRInt32* aSetSize)
   144: {
 99796:   PRInt32 namespaceId = mContent->NodeInfo()->NamespaceID();
   144:   nsAutoString tagName;
 43504:   mContent->NodeInfo()->GetName(tagName);
   283: 
   283:   nsAutoString type;
 78350:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::type, type);
   283:   nsAutoString name;
 78350:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::name, name);
   283: 
 99796:   nsRefPtr<nsContentList> inputElms;
   392: 
 99796:   nsCOMPtr<nsIFormControl> formControlNode(do_QueryInterface(mContent));
 99796:   dom::Element* formElm = formControlNode->GetFormElement();
 99796:   if (formElm)
 99796:     inputElms = NS_GetContentList(formElm, namespaceId, tagName);
 99796:   else
 99796:     inputElms = NS_GetContentList(mContent->OwnerDoc(), namespaceId, tagName);
 99796:   NS_ENSURE_TRUE(inputElms, );
   144: 
 99796:   PRUint32 inputCount = inputElms->Length(false);
   144: 
 36879:   // Compute posinset and setsize.
   144:   PRInt32 indexOf = 0;
   283:   PRInt32 count = 0;
   283: 
 99796:   for (PRUint32 index = 0; index < inputCount; index++) {
 99796:     nsIContent* inputElm = inputElms->Item(index, false);
 99796:     if (inputElm->AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
   283:                               type, eCaseMatters) &&
 99796:         inputElm->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name,
   283:                               name, eCaseMatters)) {
   283:       count++;
 99796:       if (inputElm == mContent)
   283:         indexOf = count;
   144:     }
   144:   }
   144: 
 36879:   *aPosInSet = indexOf;
 36879:   *aSetSize = count;
   144: }
   144: 
 36879: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLButtonAccessible
 36879: ////////////////////////////////////////////////////////////////////////////////
     1: 
 95360: HTMLButtonAccessible::
 99568:   HTMLButtonAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 99901:   HyperTextAccessibleWrap(aContent, aDoc)
     1: {
     1: }
     1: 
 74781: PRUint8
 95360: HTMLButtonAccessible::ActionCount()
     1: {
 74781:   return 1;
     1: }
     1: 
 95360: NS_IMETHODIMP
 95360: HTMLButtonAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
     1: {
     1:   if (aIndex == eAction_Click) {
     1:     aName.AssignLiteral("press"); 
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
 37481: NS_IMETHODIMP
 95360: HTMLButtonAccessible::DoAction(PRUint8 aIndex)
     1: {
 37481:   if (aIndex != eAction_Click)
     1:     return NS_ERROR_INVALID_ARG;
 37481: 
 37481:   DoCommand();
 37481:   return NS_OK;
     1: }
     1: 
 67790: PRUint64
 95360: HTMLButtonAccessible::State()
 83000: {
 99901:   PRUint64 state = HyperTextAccessibleWrap::State();
 83000:   if (state == states::DEFUNCT)
 83000:     return state;
 83000: 
 83000:   // Inherit states from input@type="file" suitable for the button. Note,
 83000:   // no special processing for unavailable state since inheritance is supplied
 83000:   // other code paths.
 83000:   if (mParent && mParent->IsHTMLFileInput()) {
 83000:     PRUint64 parentState = mParent->State();
 83000:     state |= parentState & (states::BUSY | states::REQUIRED |
 83000:                             states::HASPOPUP | states::INVALID);
 83000:   }
 83000: 
 83000:   return state;
 83000: }
 83000: 
 83000: PRUint64
 95360: HTMLButtonAccessible::NativeState()
     1: {
 99901:   PRUint64 state = HyperTextAccessibleWrap::NativeState();
 11542: 
 79643:   nsEventStates elmState = mContent->AsElement()->State();
 79643:   if (elmState.HasState(NS_EVENT_STATE_DEFAULT))
 67790:     state |= states::DEFAULT;
     1: 
 67790:   return state;
     1: }
     1: 
 87094: role
 95360: HTMLButtonAccessible::NativeRole()
     1: {
 87094:   return roles::PUSHBUTTON;
     1: }
     1: 
 20246: nsresult
 95360: HTMLButtonAccessible::GetNameInternal(nsAString& aName)
     1: {
 99648:   Accessible::GetNameInternal(aName);
 90705:   if (!aName.IsEmpty() || mContent->Tag() != nsGkAtoms::input)
 20452:     return NS_OK;
 20452: 
 20452:   // No name from HTML or ARIA
     1:   nsAutoString name;
 78350:   if (!mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::value,
     1:                          name) &&
 78350:       !mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::alt,
     1:                          name)) {
     1:     // Use the button's (default) label if nothing else works
     1:     nsIFrame* frame = GetFrame();
     1:     if (frame) {
 23554:       nsIFormControlFrame* fcFrame = do_QueryFrame(frame);
     1:       if (fcFrame)
 78350:         fcFrame->GetFormProperty(nsGkAtoms::defaultLabel, name);
     1:     }
     1:   }
 20452: 
     1:   if (name.IsEmpty() &&
 78350:       !mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::src, name)) {
 78350:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::data, name);
     1:   }
     1: 
     1:   name.CompressWhitespace();
     1:   aName = name;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79440: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLButtonAccessible: Widgets
 79440: 
 79440: bool
 95360: HTMLButtonAccessible::IsWidget() const
 79440: {
 79440:   return true;
 79440: }
 79440: 
     1: 
 43504: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLTextFieldAccessible
 43504: ////////////////////////////////////////////////////////////////////////////////
 43504: 
 95360: HTMLTextFieldAccessible::
 99568:   HTMLTextFieldAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 99901:   HyperTextAccessibleWrap(aContent, aDoc)
     1: {
     1: }
     1: 
102362: NS_IMPL_ISUPPORTS_INHERITED2(HTMLTextFieldAccessible,
 99648:                              Accessible,                             
 95360:                              nsIAccessibleText,
 95360:                              nsIAccessibleEditableText)
  7766: 
 87094: role
 95360: HTMLTextFieldAccessible::NativeRole()
     1: {
 78350:   if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
 78350:                             nsGkAtoms::password, eIgnoreCase)) {
 87094:     return roles::PASSWORD_TEXT;
     1:   }
 87094:   
 87094:   return roles::ENTRY;
     1: }
     1: 
 20452: nsresult
 95360: HTMLTextFieldAccessible::GetNameInternal(nsAString& aName)
  2425: {
 99648:   nsresult rv = Accessible::GetNameInternal(aName);
 20246:   NS_ENSURE_SUCCESS(rv, rv);
 20246: 
 20246:   if (!aName.IsEmpty())
 20246:     return NS_OK;
 20246: 
 57106:   if (mContent->GetBindingParent())
 57106:   {
 20452:     // XXX: bug 459640
  2425:     // There's a binding parent.
  2425:     // This means we're part of another control, so use parent accessible for name.
  2425:     // This ensures that a textbox inside of a XUL widget gets
  2425:     // an accessible name.
 99648:     Accessible* parent = Parent();
 74545:     if (parent)
 57106:       parent->GetName(aName);
 57106:   }
 57106: 
 57106:   if (!aName.IsEmpty())
 57106:     return NS_OK;
 57106: 
 57106:   // text inputs and textareas might have useful placeholder text
 78350:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::placeholder, aName);
 57106: 
 57106:   return NS_OK;
  2425: }
  2425: 
 94983: void
 95360: HTMLTextFieldAccessible::Value(nsString& aValue)
     1: {
 94983:   aValue.Truncate();
 67790:   if (NativeState() & states::PROTECTED)    // Don't return password text!
 94983:     return;
     1: 
 43504:   nsCOMPtr<nsIDOMHTMLTextAreaElement> textArea(do_QueryInterface(mContent));
     1:   if (textArea) {
 94983:     textArea->GetValue(aValue);
 94983:     return;
     1:   }
     1:   
 43504:   nsCOMPtr<nsIDOMHTMLInputElement> inputElement(do_QueryInterface(mContent));
     1:   if (inputElement) {
 94983:     inputElement->GetValue(aValue);
     1:   }
     1: }
     1: 
 77694: void
 98724: HTMLTextFieldAccessible::ApplyARIAState(PRUint64* aState) const
 77694: {
 99901:   HyperTextAccessibleWrap::ApplyARIAState(aState);
 77694: 
 94828:   aria::MapToState(aria::eARIAAutoComplete, mContent->AsElement(), aState);
 83000: }
 77694: 
 83000: PRUint64
 95360: HTMLTextFieldAccessible::State()
 83000: {
 99901:   PRUint64 state = HyperTextAccessibleWrap::State();
 83000:   if (state & states::DEFUNCT)
 83000:     return state;
 83000: 
 83000:   // Inherit states from input@type="file" suitable for the button. Note,
 83000:   // no special processing for unavailable state since inheritance is supplied
 83000:   // by other code paths.
 83000:   if (mParent && mParent->IsHTMLFileInput()) {
 83000:     PRUint64 parentState = mParent->State();
 83000:     state |= parentState & (states::BUSY | states::REQUIRED |
 83000:       states::HASPOPUP | states::INVALID);
 83000:   }
 83000: 
 83000:   return state;
 77694: }
 77694: 
 67790: PRUint64
 95360: HTMLTextFieldAccessible::NativeState()
     1: {
 99901:   PRUint64 state = HyperTextAccessibleWrap::NativeState();
     1: 
     1:   // can be focusable, focused, protected. readonly, unavailable, selected
 78350:   if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
 78350:                             nsGkAtoms::password, eIgnoreCase)) {
 67790:     state |= states::PROTECTED;
     1:   }
     1: 
 78350:   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::readonly)) {
 67790:     state |= states::READONLY;
     1:   }
     1: 
 79384:   // Is it an <input> or a <textarea> ?
 43504:   nsCOMPtr<nsIDOMHTMLInputElement> htmlInput(do_QueryInterface(mContent));
 79384:   state |= htmlInput ? states::SINGLE_LINE : states::MULTI_LINE;
 79384: 
 79384:   if (!(state & states::EDITABLE) ||
 79384:       (state & (states::PROTECTED | states::MULTI_LINE)))
 79384:     return state;
 79384: 
 79384:   // Expose autocomplete states if this input is part of autocomplete widget.
 99648:   Accessible* widget = ContainerWidget();
 79384:   if (widget && widget-IsAutoComplete()) {
 79384:     state |= states::HASPOPUP | states::SUPPORTS_AUTOCOMPLETION;
 79384:     return state;
  2089:   }
     1: 
 79951:   // Expose autocomplete state if it has associated autocomplete list.
 79951:   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::list))
 79951:     return state | states::SUPPORTS_AUTOCOMPLETION;
 79951: 
 79384:   // No parent can mean a fake widget created for XUL textbox. If accessible
 79384:   // is unattached from tree then we don't care.
 97984:   if (mParent && Preferences::GetBool("browser.formfill.enable")) {
   374:     // Check to see if autocompletion is allowed on this input. We don't expose
   374:     // it for password fields even though the entire password can be remembered
   374:     // for a page if the user asks it to be. However, the kind of autocomplete
   374:     // we're talking here is based on what the user types, where a popup of
   374:     // possible choices comes up.
     1:     nsAutoString autocomplete;
 78350:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::autocomplete,
   374:                       autocomplete);
   374: 
     1:     if (!autocomplete.LowerCaseEqualsLiteral("off")) {
     1:       nsCOMPtr<nsIDOMHTMLFormElement> form;
     1:       htmlInput->GetForm(getter_AddRefs(form));
   374:       nsCOMPtr<nsIContent> formContent(do_QueryInterface(form));
   374:       if (formContent) {
   374:         formContent->GetAttr(kNameSpaceID_None,
 78350:                              nsGkAtoms::autocomplete, autocomplete);
   374:       }
   374: 
   374:       if (!formContent || !autocomplete.LowerCaseEqualsLiteral("off"))
 67790:         state |= states::SUPPORTS_AUTOCOMPLETION;
   332:     }
   372:   }
     1: 
 67790:   return state;
     1: }
     1: 
 74781: PRUint8
 95360: HTMLTextFieldAccessible::ActionCount()
     1: {
 74781:   return 1;
     1: }
     1: 
 95360: NS_IMETHODIMP
 95360: HTMLTextFieldAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
     1: {
     1:   if (aIndex == eAction_Click) {
     1:     aName.AssignLiteral("activate");
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
 95360: NS_IMETHODIMP
 95360: HTMLTextFieldAccessible::DoAction(PRUint8 aIndex)
     1: {
 95360:   if (aIndex == 0) {
 67818:     nsCOMPtr<nsIDOMHTMLElement> element(do_QueryInterface(mContent));
 95360:     if (element)
  1247:       return element->Focus();
 95360: 
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
 91761: already_AddRefed<nsIEditor>
 95360: HTMLTextFieldAccessible::GetEditor() const
     1: {
 43504:   nsCOMPtr<nsIDOMNSEditableElement> editableElt(do_QueryInterface(mContent));
 91761:   if (!editableElt)
 91761:     return nsnull;
     1: 
  3945:   // nsGenericHTMLElement::GetEditor has a security check.
  3945:   // Make sure we're not restricted by the permissions of
  3945:   // whatever script is currently running.
  3945:   nsCOMPtr<nsIJSContextStack> stack =
  3945:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
 79445:   bool pushed = stack && NS_SUCCEEDED(stack->Push(nsnull));
  3945: 
     1:   nsCOMPtr<nsIEditor> editor;
 91761:   editableElt->GetEditor(getter_AddRefs(editor));
  3945: 
  3945:   if (pushed) {
  3945:     JSContext* cx;
  3945:     stack->Pop(&cx);
  3945:     NS_ASSERTION(!cx, "context should be null");
  3945:   }
  4625: 
 91761:   return editor.forget();
     1: }
     1: 
 43504: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLTextFieldAccessible: Widgets
 79384: 
 79384: bool
 95360: HTMLTextFieldAccessible::IsWidget() const
 79384: {
 79384:   return true;
 79384: }
 79384: 
 99648: Accessible*
 95360: HTMLTextFieldAccessible::ContainerWidget() const
 79384: {
 87094:   return mParent && mParent->Role() == roles::AUTOCOMPLETE ? mParent : nsnull;
 79384: }
 79384: 
 79384: 
 79384: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLFileInputAccessible
 43504: ////////////////////////////////////////////////////////////////////////////////
     1: 
 95360: HTMLFileInputAccessible::
 99568: HTMLFileInputAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 99901:   HyperTextAccessibleWrap(aContent, aDoc)
 83000: {
 83000:   mFlags |= eHTMLFileInputAccessible;
 83000: }
 83000: 
 87094: role
 95360: HTMLFileInputAccessible::NativeRole()
 83000: {
 83000:   // JAWS wants a text container, others don't mind. No specific role in
 83000:   // AT APIs.
 87094:   return roles::TEXT_CONTAINER;
 83000: }
 83000: 
 83000: nsresult
 95360: HTMLFileInputAccessible::HandleAccEvent(AccEvent* aEvent)
 83000: {
 99901:   nsresult rv = HyperTextAccessibleWrap::HandleAccEvent(aEvent);
 83000:   NS_ENSURE_SUCCESS(rv, rv);
 83000: 
 83000:   // Redirect state change events for inherited states to child controls. Note,
 83000:   // unavailable state is not redirected. That's a standard for unavailable
 83000:   // state handling.
 83000:   AccStateChangeEvent* event = downcast_accEvent(aEvent);
 83000:   if (event &&
 83000:       (event->GetState() == states::BUSY ||
 83000:        event->GetState() == states::REQUIRED ||
 83000:        event->GetState() == states::HASPOPUP ||
 83000:        event->GetState() == states::INVALID)) {
 99648:     Accessible* input = GetChildAt(0);
 87094:     if (input && input->Role() == roles::ENTRY) {
 83000:       nsRefPtr<AccStateChangeEvent> childEvent =
 83000:         new AccStateChangeEvent(input, event->GetState(),
 83000:                                 event->IsStateEnabled(),
 83000:                                 (event->IsFromUserInput() ? eFromUserInput : eNoUserInput));
 83000:       nsEventShell::FireEvent(childEvent);
 83000:     }
 83000: 
 99648:     Accessible* button = GetChildAt(1);
 87094:     if (button && button->Role() == roles::PUSHBUTTON) {
 83000:       nsRefPtr<AccStateChangeEvent> childEvent =
 83000:         new AccStateChangeEvent(button, event->GetState(),
 83000:                                 event->IsStateEnabled(),
 83000:                                 (event->IsFromUserInput() ? eFromUserInput : eNoUserInput));
 83000:       nsEventShell::FireEvent(childEvent);
 83000:     }
 83000:   }
 83000:   return NS_OK;
 83000: }
 83000: 
 83000: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLGroupboxAccessible
 83000: ////////////////////////////////////////////////////////////////////////////////
 83000: 
 95360: HTMLGroupboxAccessible::
 99568:   HTMLGroupboxAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 99901:   HyperTextAccessibleWrap(aContent, aDoc)
     1: {
     1: }
     1: 
 87094: role
 95360: HTMLGroupboxAccessible::NativeRole()
     1: {
 87094:   return roles::GROUPING;
     1: }
     1: 
 84146: nsIContent*
 95360: HTMLGroupboxAccessible::GetLegend()
     1: {
 84146:   for (nsIContent* legendContent = mContent->GetFirstChild(); legendContent;
 84146:        legendContent = legendContent->GetNextSibling()) {
 78350:     if (legendContent->NodeInfo()->Equals(nsGkAtoms::legend,
 43504:                                           mContent->GetNameSpaceID())) {
  2985:       // Either XHTML namespace or no namespace
 43504:       return legendContent;
  2985:     }
  2985:   }
  2985: 
  2985:   return nsnull;
     1: }
     1: 
 20246: nsresult
 95360: HTMLGroupboxAccessible::GetNameInternal(nsAString& aName)
     1: {
 99648:   nsresult rv = Accessible::GetNameInternal(aName);
 20246:   NS_ENSURE_SUCCESS(rv, rv);
 18347: 
 20246:   if (!aName.IsEmpty())
     1:     return NS_OK;
     1: 
  2985:   nsIContent *legendContent = GetLegend();
     1:   if (legendContent) {
 25175:     return nsTextEquivUtils::
 25175:       AppendTextEquivFromContent(this, legendContent, &aName);
     1:   }
  2985: 
     1:   return NS_OK;
     1: }
     1: 
 75194: Relation
 95360: HTMLGroupboxAccessible::RelationByType(PRUint32 aType)
     1: {
 99901:   Relation rel = HyperTextAccessibleWrap::RelationByType(aType);
 75194:     // No override for label, so use <legend> for this <fieldset>
 75194:   if (aType == nsIAccessibleRelation::RELATION_LABELLED_BY)
 97941:     rel.AppendTarget(mDoc, GetLegend());
 75124: 
 75194:   return rel;
 75124: }
     1: 
 25822: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLLegendAccessible
 43504: ////////////////////////////////////////////////////////////////////////////////
 25822: 
 95360: HTMLLegendAccessible::
 99568:   HTMLLegendAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 99901:   HyperTextAccessibleWrap(aContent, aDoc)
  2985: {
     1: }
  2985: 
 75194: Relation
 95360: HTMLLegendAccessible::RelationByType(PRUint32 aType)
  2985: {
 99901:   Relation rel = HyperTextAccessibleWrap::RelationByType(aType);
 75194:   if (aType != nsIAccessibleRelation::RELATION_LABEL_FOR)
 75194:     return rel;
  2985: 
 99648:   Accessible* groupbox = Parent();
 87094:   if (groupbox && groupbox->Role() == roles::GROUPING)
 75194:     rel.AppendTarget(groupbox);
 36989: 
 75194:   return rel;
  2985: }
 25822: 
 87094: role
 95360: HTMLLegendAccessible::NativeRole()
 25822: {
 87094:   return roles::LABEL;
 25822: }
 83419: 
 83419: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLFigureAccessible
 83419: ////////////////////////////////////////////////////////////////////////////////
 83419: 
 95360: HTMLFigureAccessible::
 99568:   HTMLFigureAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 99901:   HyperTextAccessibleWrap(aContent, aDoc)
 83419: {
 83419: }
 83419: 
 83419: nsresult
 95360: HTMLFigureAccessible::GetAttributesInternal(nsIPersistentProperties* aAttributes)
 83419: {
 99901:   nsresult rv = HyperTextAccessibleWrap::GetAttributesInternal(aAttributes);
 83419:   NS_ENSURE_SUCCESS(rv, rv);
 83419: 
 83419:   // Expose figure xml-role.
 83419:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
 83419:                          NS_LITERAL_STRING("figure"));
 83419:   return NS_OK;
 83419: }
 83419: 
 87094: role
 95360: HTMLFigureAccessible::NativeRole()
 83419: {
 87094:   return roles::FIGURE;
 83419: }
 83419: 
 83419: nsresult
 95360: HTMLFigureAccessible::GetNameInternal(nsAString& aName)
 83419: {
 99901:   nsresult rv = HyperTextAccessibleWrap::GetNameInternal(aName);
 83419:   NS_ENSURE_SUCCESS(rv, rv);
 83419: 
 83419:   if (!aName.IsEmpty())
 83419:     return NS_OK;
 83419: 
 83419:   nsIContent* captionContent = Caption();
 83419:   if (captionContent) {
 83419:     return nsTextEquivUtils::
 83419:       AppendTextEquivFromContent(this, captionContent, &aName);
 83419:   }
 83419: 
 83419:   return NS_OK;
 83419: }
 83419: 
 83419: Relation
 95360: HTMLFigureAccessible::RelationByType(PRUint32 aType)
 83419: {
 99901:   Relation rel = HyperTextAccessibleWrap::RelationByType(aType);
 83419:   if (aType == nsIAccessibleRelation::RELATION_LABELLED_BY)
 97941:     rel.AppendTarget(mDoc, Caption());
 83419: 
 83419:   return rel;
 83419: }
 83419: 
 83419: nsIContent*
 95360: HTMLFigureAccessible::Caption() const
 83419: {
 83419:   for (nsIContent* childContent = mContent->GetFirstChild(); childContent;
 83419:        childContent = childContent->GetNextSibling()) {
 83419:     if (childContent->NodeInfo()->Equals(nsGkAtoms::figcaption,
 83419:                                          mContent->GetNameSpaceID())) {
 83419:       return childContent;
 83419:     }
 83419:   }
 83419: 
 83419:   return nsnull;
 83419: }
 83419: 
 83419: ////////////////////////////////////////////////////////////////////////////////
 95360: // HTMLFigcaptionAccessible
 83419: ////////////////////////////////////////////////////////////////////////////////
 83419: 
 95360: HTMLFigcaptionAccessible::
 99568:   HTMLFigcaptionAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 99901:   HyperTextAccessibleWrap(aContent, aDoc)
 83419: {
 83419: }
 83419: 
 87094: role
 95360: HTMLFigcaptionAccessible::NativeRole()
 83419: {
 87094:   return roles::CAPTION;
 83419: }
 83419: 
 83419: Relation
 95360: HTMLFigcaptionAccessible::RelationByType(PRUint32 aType)
 83419: {
 99901:   Relation rel = HyperTextAccessibleWrap::RelationByType(aType);
 83419:   if (aType != nsIAccessibleRelation::RELATION_LABEL_FOR)
 83419:     return rel;
 83419: 
 99648:   Accessible* figure = Parent();
 83419:   if (figure &&
 83419:       figure->GetContent()->NodeInfo()->Equals(nsGkAtoms::figure,
 83419:                                                mContent->GetNameSpaceID())) {
 83419:     rel.AppendTarget(figure);
 83419:   }
 83419: 
 83419:   return rel;
 83419: }
