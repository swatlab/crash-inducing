    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Neil Cronin (neil@rackle.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsScrollPortView.h"
    1: #include "nsIWidget.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsViewsCID.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsISupportsArray.h"
    1: #include "nsIScrollPositionListener.h"
    1: #include "nsIRegion.h"
    1: #include "nsViewManager.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsServiceManagerUtils.h"
    1: 
    1: #include <math.h>
    1: 
    1: static NS_DEFINE_IID(kWidgetCID, NS_CHILD_CID);
    1: 
    1: #define SMOOTH_SCROLL_MSECS_PER_FRAME 10
    1: #define SMOOTH_SCROLL_FRAMES    10
    1: 
    1: #define SMOOTH_SCROLL_PREF_NAME "general.smoothScroll"
    1: 
21172: class AsyncScroll {
    1: public:
21172:   AsyncScroll() {}
21172:   ~AsyncScroll() {
21172:     if (mScrollTimer) mScrollTimer->Cancel();
    1:   }
    1: 
21172:   nsCOMPtr<nsITimer> mScrollTimer;
    1:   PRInt32 mVelocities[SMOOTH_SCROLL_FRAMES*2];
    1:   PRInt32 mFrameIndex;
21172:   PRPackedBool mIsSmoothScroll;
    1: };
    1: 
    1: nsScrollPortView::nsScrollPortView(nsViewManager* aViewManager)
    1:   : nsView(aViewManager)
    1: {
    1:   mOffsetX = mOffsetY = 0;
21172:   mDestinationX = mDestinationY = 0;
    1:   nsCOMPtr<nsIDeviceContext> dev;
    1:   mViewManager->GetDeviceContext(*getter_AddRefs(dev));
    1:   mLineHeight = dev->AppUnitsPerInch() / 6; // 12 pt
    1: 
    1:   mListeners = nsnull;
21172:   mAsyncScroll = nsnull;
    1: }
    1: 
    1: nsScrollPortView::~nsScrollPortView()
    1: {    
    1:   if (nsnull != mListeners) {
    1:     mListeners->Clear();
    1:     NS_RELEASE(mListeners);
    1:   }
    1: 
    1:   if (nsnull != mViewManager) {
    1:      nsIScrollableView* scrollingView;
    1:      mViewManager->GetRootScrollableView(&scrollingView);
    1:      if ((nsnull != scrollingView) && (this == scrollingView)) {
    1:        mViewManager->SetRootScrollableView(nsnull);
    1:      }
    1:   }
    1: 
21172:   delete mAsyncScroll;
    1: }
    1: 
    1: nsresult nsScrollPortView::QueryInterface(const nsIID& aIID, void** aInstancePtr)
    1: {
    1:   if (nsnull == aInstancePtr) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1:   *aInstancePtr = nsnull;
    1:   if (aIID.Equals(NS_GET_IID(nsIScrollableView))) {
    1:     *aInstancePtr = (void*)(nsIScrollableView*)this;
    1:     return NS_OK;
    1:   }
    1: 
    1:   return nsView::QueryInterface(aIID, aInstancePtr);
    1: }
    1: 
    1: NS_IMETHODIMP_(nsIView*) nsScrollPortView::View()
    1: {
    1:   return this;
    1: }
    1: 
    1: NS_IMETHODIMP nsScrollPortView::AddScrollPositionListener(nsIScrollPositionListener* aListener)
    1: {
    1:   if (nsnull == mListeners) {
    1:     nsresult rv = NS_NewISupportsArray(&mListeners);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:   }
    1:   return mListeners->AppendElement(aListener);
    1: }
    1: 
    1: NS_IMETHODIMP nsScrollPortView::RemoveScrollPositionListener(nsIScrollPositionListener* aListener)
    1: {
    1:   if (nsnull != mListeners) {
    1:     return mListeners->RemoveElement(aListener);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsScrollPortView::GetContainerSize(nscoord *aWidth, nscoord *aHeight) const
    1: {
    1:   if (!aWidth || !aHeight)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aWidth  = 0;
    1:   *aHeight = 0;
    1: 
    1:   nsView *scrolledView = GetScrolledView();
    1: 
    1:   if (!scrolledView)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsSize sz;
    1:   scrolledView->GetDimensions(sz);
    1:   *aWidth = sz.width;
    1:   *aHeight = sz.height;
    1:   return NS_OK;
    1: }
    1: 
    1: static void ComputeVelocities(PRInt32 aCurVelocity, nscoord aCurPos, nscoord aDstPos,
    1:                               PRInt32* aVelocities, PRInt32 aP2A) {
    1:   // scrolling always works in units of whole pixels. So compute velocities
    1:   // in pixels and then scale them up. This ensures, for example, that
    1:   // a 1-pixel scroll isn't broken into N frames of 1/N pixels each, each
    1:   // frame increment being rounded to 0 whole pixels.
    1:   aCurPos = NSAppUnitsToIntPixels(aCurPos, aP2A);
    1:   aDstPos = NSAppUnitsToIntPixels(aDstPos, aP2A);
    1: 
    1:   PRInt32 i;
    1:   PRInt32 direction = (aCurPos < aDstPos ? 1 : -1);
    1:   PRInt32 absDelta = (aDstPos - aCurPos)*direction;
    1:   PRInt32 baseVelocity = absDelta/SMOOTH_SCROLL_FRAMES;
    1: 
    1:   for (i = 0; i < SMOOTH_SCROLL_FRAMES; i++) {
    1:     aVelocities[i*2] = baseVelocity;
    1:   }
    1:   nscoord total = baseVelocity*SMOOTH_SCROLL_FRAMES;
    1:   for (i = 0; i < SMOOTH_SCROLL_FRAMES; i++) {
    1:     if (total < absDelta) {
    1:       aVelocities[i*2]++;
    1:       total++;
    1:     }
    1:   }
    1:   NS_ASSERTION(total == absDelta, "Invalid velocity sum");
    1: 
    1:   PRInt32 scale = NSIntPixelsToAppUnits(direction, aP2A);
    1:   for (i = 0; i < SMOOTH_SCROLL_FRAMES; i++) {
    1:     aVelocities[i*2] *= scale;
    1:   }
    1: }
    1:   
    1: static nsresult ClampScrollValues(nscoord& aX, nscoord& aY, nsScrollPortView* aThis) {
28609:   // make sure the new position is in bounds
    1:   nsView* scrolledView = aThis->GetScrolledView();
    1:   if (!scrolledView) return NS_ERROR_FAILURE;
    1:   
    1:   nsRect scrolledRect;
    1:   scrolledView->GetDimensions(scrolledRect);
    1:   
    1:   nsSize portSize;
    1:   aThis->GetDimensions(portSize);
    1:   
    1:   nscoord maxX = scrolledRect.XMost() - portSize.width;
    1:   nscoord maxY = scrolledRect.YMost() - portSize.height;
    1:   
    1:   if (aX > maxX)
    1:     aX = maxX;
    1:   
    1:   if (aY > maxY)
    1:     aY = maxY;
    1:   
    1:   if (aX < scrolledRect.x)
    1:     aX = scrolledRect.x;
    1:   
    1:   if (aY < scrolledRect.y)
    1:     aY = scrolledRect.y;
    1:   
    1:   return NS_OK;
    1: }
    1:   
    1: /*
    1:  * this method wraps calls to ScrollToImpl(), either in one shot or incrementally,
    1:  *  based on the setting of the smooth scroll pref
    1:  */
    1: NS_IMETHODIMP nsScrollPortView::ScrollTo(nscoord aDestinationX, nscoord aDestinationY,
    1:                                          PRUint32 aUpdateFlags)
    1: {
21172:   mDestinationX = aDestinationX;
21172:   mDestinationY = aDestinationY;
21172:   ClampScrollValues(mDestinationX, mDestinationY, this);
21172: 
22316:   if (!(aUpdateFlags & (NS_VMREFRESH_DEFERRED | NS_VMREFRESH_SMOOTHSCROLL))) {
21172:     // Asynchronous scrolling is not allowed, so we'll kill any existing
21172:     // async-scrolling process and do an instant scroll
21172:     delete mAsyncScroll;
21172:     mAsyncScroll = nsnull;
21172:     return ScrollToImpl(mDestinationX, mDestinationY);
    1:   }
    1: 
21172:   PRInt32 currentVelocityX = 0;
21172:   PRInt32 currentVelocityY = 0;
21172:   PRBool isSmoothScroll = (aUpdateFlags & NS_VMREFRESH_SMOOTHSCROLL) &&
21172:                           IsSmoothScrollingEnabled();
    1: 
21175:   if (mAsyncScroll) {
21175:     if (mAsyncScroll->mIsSmoothScroll) {
21172:       currentVelocityX = mAsyncScroll->mVelocities[mAsyncScroll->mFrameIndex*2];
21172:       currentVelocityY = mAsyncScroll->mVelocities[mAsyncScroll->mFrameIndex*2 + 1];
21175:     }
    1:   } else {
21172:     mAsyncScroll = new AsyncScroll;
21172:     if (mAsyncScroll) {
21172:       mAsyncScroll->mScrollTimer = do_CreateInstance("@mozilla.org/timer;1");
21172:       if (!mAsyncScroll->mScrollTimer) {
21172:         delete mAsyncScroll;
21172:         mAsyncScroll = nsnull;
    1:       }
    1:     }
21172:     if (!mAsyncScroll) {
    1:       // some allocation failed. Scroll the normal way.
21172:       return ScrollToImpl(mDestinationX, mDestinationY);
    1:     }
21172:     if (isSmoothScroll) {
21172:       mAsyncScroll->mScrollTimer->InitWithFuncCallback(
21172:         AsyncScrollCallback, this, SMOOTH_SCROLL_MSECS_PER_FRAME,
    1:         nsITimer::TYPE_REPEATING_PRECISE);
21172:     } else {
21172:       mAsyncScroll->mScrollTimer->InitWithFuncCallback(
21172:         AsyncScrollCallback, this, 0, nsITimer::TYPE_ONE_SHOT);
21172:     }
    1:   }
    1: 
21172:   mAsyncScroll->mFrameIndex = 0;
21172:   mAsyncScroll->mIsSmoothScroll = isSmoothScroll;
    1: 
21172:   if (isSmoothScroll) {
    1:     nsCOMPtr<nsIDeviceContext> dev;
    1:     mViewManager->GetDeviceContext(*getter_AddRefs(dev));
    1:     PRInt32 p2a = dev->AppUnitsPerDevPixel();
    1: 
    1:     // compute velocity vectors
21172:     ComputeVelocities(currentVelocityX, mOffsetX, mDestinationX,
21172:                       mAsyncScroll->mVelocities, p2a);
21172:     ComputeVelocities(currentVelocityY, mOffsetY, mDestinationY,
21172:                       mAsyncScroll->mVelocities + 1, p2a);
21172:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static void AdjustChildWidgets(nsView *aView,
    1:   nsPoint aWidgetToParentViewOrigin, PRInt32 aP2A, PRBool aInvalidate)
    1: {
    1:   if (aView->HasWidget()) {
    1:     nsIWidget* widget = aView->GetWidget();
    1:     nsWindowType type;
    1:     widget->GetWindowType(type);
    1:     if (type != eWindowType_popup) {
    1:       nsRect bounds = aView->GetBounds();
    1:       nsPoint widgetOrigin = aWidgetToParentViewOrigin
    1:         + nsPoint(bounds.x, bounds.y);
    1:       widget->Move(NSAppUnitsToIntPixels(widgetOrigin.x, aP2A),
    1:                    NSAppUnitsToIntPixels(widgetOrigin.y, aP2A));
    1:       if (aInvalidate) {
    1:         // Force the widget and everything in it to repaint. We can't
    1:         // just use Invalidate because the widget might have child
    1:         // widgets and they wouldn't get updated. We can't call
    1:         // UpdateView(aView) because the area to be repainted might be
    1:         // outside aView's clipped bounds. This isn't the greatest way
    1:         // to achieve this, perhaps, but it works.
    1:         widget->Show(PR_FALSE);
    1:         widget->Show(PR_TRUE);
    1:       }
    1:     }
30540:     // Don't recurse if the view has a widget, because we adjusted the view's
30540:     // widget position, and its child widgets are relative to its position
    1:   } else {
    1:     nsPoint widgetToViewOrigin = aWidgetToParentViewOrigin
    1:       + aView->GetPosition();
    1: 
    1:     for (nsView* kid = aView->GetFirstChild(); kid; kid = kid->GetNextSibling())
    1:     {
    1:       AdjustChildWidgets(kid, widgetToViewOrigin, aP2A, aInvalidate);
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsScrollPortView::SetScrolledView(nsIView *aScrolledView)
    1: {
    1:   NS_ASSERTION(GetFirstChild() == nsnull || GetFirstChild()->GetNextSibling() == nsnull,
    1:                "Error scroll port has too many children");
    1: 
    1:   // if there is already a child so remove it
    1:   if (GetFirstChild() != nsnull)
    1:   {
    1:     mViewManager->RemoveChild(GetFirstChild());
    1:   }
    1: 
    1:   return mViewManager->InsertChild(this, aScrolledView, 0);
    1: }
    1: 
    1: NS_IMETHODIMP nsScrollPortView::GetScrolledView(nsIView *&aScrolledView) const
    1: {
    1:   aScrolledView = GetScrolledView();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsScrollPortView::GetScrollPosition(nscoord &aX, nscoord &aY) const
    1: {
    1:   aX = mOffsetX;
    1:   aY = mOffsetY;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsScrollPortView::SetLineHeight(nscoord aHeight)
    1: {
    1:   mLineHeight = aHeight;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsScrollPortView::GetLineHeight(nscoord *aHeight)
    1: {
    1:   *aHeight = mLineHeight;
    1:   return NS_OK;
    1: }
    1: 
28609: nsresult
28609: nsScrollPortView::CalcScrollOverflow(nscoord aX, nscoord aY,
28609:                                      PRInt32& aPixelOverflowX, PRInt32& aPixelOverflowY)
28609: {
28609:   // make sure the new position is in bounds
28609:   nsView* scrolledView = GetScrolledView();
28609:   if (!scrolledView) return NS_ERROR_FAILURE;
28609:   
28609:   nsRect scrolledRect;
28609:   scrolledView->GetDimensions(scrolledRect);
28609:   
28609:   nsSize portSize;
28609:   this->GetDimensions(portSize);
28609:   
28609:   nscoord maxX = scrolledRect.XMost() - portSize.width;
28609:   nscoord maxY = scrolledRect.YMost() - portSize.height;
28609:   
28609:   nsCOMPtr<nsIDeviceContext> dev;
28609:   mViewManager->GetDeviceContext(*getter_AddRefs(dev));
28609:   float p2a = (float)dev->AppUnitsPerDevPixel();
28609: 
28609:   if (maxX != 0 && aX > maxX)
28609:     aPixelOverflowX = NSAppUnitsToIntPixels(aX - maxX, p2a);
28609: 
28609:   if (maxY != 0 && aY > maxY)
28609:     aPixelOverflowY = NSAppUnitsToIntPixels(aY - maxY, p2a);
28609: 
28609:   if (maxX != 0 && aX < scrolledRect.x)
28609:     aPixelOverflowX = NSAppUnitsToIntPixels(scrolledRect.x - aX, p2a);
28609: 
28609:   if (maxY != 0 && aY < scrolledRect.y)
28609:     aPixelOverflowY = NSAppUnitsToIntPixels(scrolledRect.y - aY, p2a);
28609:   
28609:   return NS_OK;
28609: }
28609: 
28609: NS_IMETHODIMP nsScrollPortView::ScrollByLines(PRInt32 aNumLinesX,
28609:                                               PRInt32 aNumLinesY,
21172:                                               PRUint32 aUpdateFlags)
    1: {
    1:   nscoord dx = mLineHeight*aNumLinesX;
    1:   nscoord dy = mLineHeight*aNumLinesY;
    1: 
21172:   return ScrollTo(mDestinationX + dx, mDestinationY + dy, aUpdateFlags);
    1: }
    1: 
28609: NS_IMETHODIMP nsScrollPortView::ScrollByLinesWithOverflow(PRInt32 aNumLinesX,
28609:                                                           PRInt32 aNumLinesY,
28609:                                                           PRInt32& aOverflowX,
28609:                                                           PRInt32& aOverflowY,
28609:                                                           PRUint32 aUpdateFlags)
28609: {
28609:   nscoord dx = mLineHeight*aNumLinesX;
28609:   nscoord dy = mLineHeight*aNumLinesY;
28609: 
28609:   CalcScrollOverflow(mDestinationX + dx, mDestinationY + dy, aOverflowX, aOverflowY);
28609: 
28609:   return ScrollTo(mDestinationX + dx, mDestinationY + dy, aUpdateFlags);
28609: }
28609: 
    1: NS_IMETHODIMP nsScrollPortView::GetPageScrollDistances(nsSize *aDistances)
    1: {
    1:   nsSize size;
    1:   GetDimensions(size);
    1: 
    1:   // The page increment is the size of the page, minus the smaller of
    1:   // 10% of the size or 2 lines.
    1:   aDistances->width  = size.width  - PR_MIN(size.width  / 10, 2 * mLineHeight);
    1:   aDistances->height = size.height - PR_MIN(size.height / 10, 2 * mLineHeight);
    1: 
    1:   return NS_OK;
    1: }
    1: 
21172: NS_IMETHODIMP nsScrollPortView::ScrollByPages(PRInt32 aNumPagesX, PRInt32 aNumPagesY,
21172:                                               PRUint32 aUpdateFlags)
    1: {
    1:   nsSize delta;
    1:   GetPageScrollDistances(&delta);
    1:     
    1:   // put in the number of pages.
    1:   delta.width *= aNumPagesX;
    1:   delta.height *= aNumPagesY;
    1: 
21172:   return ScrollTo(mDestinationX + delta.width, mDestinationY + delta.height,
21172:                   aUpdateFlags);
    1: }
    1: 
21172: NS_IMETHODIMP nsScrollPortView::ScrollByWhole(PRBool aTop,
21172:                                               PRUint32 aUpdateFlags)
    1: {
    1:   nscoord   newPos = 0;
    1: 
    1:   if (!aTop) {
    1:     nsSize scrolledSize;
    1:     nsView* scrolledView = GetScrolledView();
    1:     scrolledView->GetDimensions(scrolledSize);
    1:     newPos = scrolledSize.height;
    1:   }
    1: 
21172:   ScrollTo(mDestinationX, newPos, aUpdateFlags);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsScrollPortView::ScrollByPixels(PRInt32 aNumPixelsX,
21172:                                                PRInt32 aNumPixelsY,
28609:                                                PRInt32& aOverflowX,
28609:                                                PRInt32& aOverflowY,
21172:                                                PRUint32 aUpdateFlags)
    1: {
    1:   nsCOMPtr<nsIDeviceContext> dev;
    1:   mViewManager->GetDeviceContext(*getter_AddRefs(dev));
    1:   PRInt32 p2a = dev->AppUnitsPerDevPixel(); 
    1: 
    1:   nscoord dx = NSIntPixelsToAppUnits(aNumPixelsX, p2a);
    1:   nscoord dy = NSIntPixelsToAppUnits(aNumPixelsY, p2a);
    1: 
28609:   CalcScrollOverflow(mDestinationX + dx, mDestinationY + dy, aOverflowX, aOverflowY);
28609:   
21172:   return ScrollTo(mDestinationX + dx, mDestinationY + dy, aUpdateFlags);
    1: }
    1: 
    1: NS_IMETHODIMP nsScrollPortView::CanScroll(PRBool aHorizontal,
    1:                                           PRBool aForward,
    1:                                           PRBool &aResult)
    1: {
    1:   nscoord offset = aHorizontal ? mOffsetX : mOffsetY;
    1: 
    1:   nsView* scrolledView = GetScrolledView();
    1:   if (!scrolledView) {
    1:     aResult = PR_FALSE;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsRect scrolledRect;
    1:   scrolledView->GetDimensions(scrolledRect);
    1: 
    1:   // Can scroll to Top or to Left?
    1:   if (!aForward) {
    1:     aResult = offset > (aHorizontal ? scrolledRect.x : scrolledRect.y);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsSize portSize;
    1:   GetDimensions(portSize);
    1: 
    1:   nsCOMPtr<nsIDeviceContext> dev;
    1:   mViewManager->GetDeviceContext(*getter_AddRefs(dev));
    1:   PRInt32 p2a = dev->AppUnitsPerDevPixel();
    1: 
    1:   nscoord max;
    1:   if (aHorizontal) {
    1:     max = scrolledRect.XMost() - portSize.width;
    1:     // Round by pixel
    1:     nscoord maxPx = NSAppUnitsToIntPixels(max, p2a);
    1:     max = NSIntPixelsToAppUnits(maxPx, p2a);
    1:   } else {
    1:     max = scrolledRect.YMost() - portSize.height;
    1:     // Round by pixel
    1:     nscoord maxPx = NSAppUnitsToIntPixels(max, p2a);
    1:     max = NSIntPixelsToAppUnits(maxPx, p2a);
    1:   }
    1: 
    1:   // Can scroll to Bottom or to Right?
    1:   aResult = (offset < max) ? PR_TRUE : PR_FALSE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
31544: /**
31544:  * Given aBlitRegion in appunits, create and return an nsRegion in
31544:  * device pixels that represents the device pixels that are wholly
31544:  * contained in aBlitRegion. Whatever appunit area was removed in that
31544:  * process is added to aRepaintRegion.
31544:  */
31544: static nsRegion
31544: ConvertToInnerPixelRegion(const nsRegion& aBlitRegion,
31544:                           nscoord aAppUnitsPerPixel,
31544:                           nsRegion* aRepaintRegion)
31544: {
31544:   // Basically we compute the inverse of aBlitRegion,
31544:   // expand each of its rectangles out to device pixel boundaries, then
31544:   // invert that.
31544:   nsIntRect boundingBoxPixels =
31544:     aBlitRegion.GetBounds().ToOutsidePixels(aAppUnitsPerPixel);
31544:   nsRect boundingBox = boundingBoxPixels.ToAppUnits(aAppUnitsPerPixel);
31544:   nsRegion outside;
31544:   outside.Sub(boundingBox, aBlitRegion);
31544: 
31544:   nsRegion outsidePixels;
31544:   nsRegion outsideAppUnits;
31544:   const nsRect* r;
31544:   for (nsRegionRectIterator iter(outside); (r = iter.Next());) {
31544:     nsIntRect pixRect = r->ToOutsidePixels(aAppUnitsPerPixel);
31544:     outsidePixels.Or(outsidePixels,
31544:                      nsRect(pixRect.x, pixRect.y, pixRect.width, pixRect.height));
31544:     outsideAppUnits.Or(outsideAppUnits,
31544:                        pixRect.ToAppUnits(aAppUnitsPerPixel));
31544:   }
31544: 
31544:   nsRegion repaint;
31544:   repaint.And(aBlitRegion, outsideAppUnits);
31544:   aRepaintRegion->Or(*aRepaintRegion, repaint);
31544: 
31544:   nsRegion result;
31544:   result.Sub(nsRect(boundingBoxPixels.x, boundingBoxPixels.y,
31544:                     boundingBoxPixels.width, boundingBoxPixels.height),
31544:              outsidePixels);
31544:   return result;
31544: }
31544: 
31544: /**
31544:  * An nsTArray comparator that lets us sort nsIntRects by their right edge.
31544:  */
31544: class RightEdgeComparator {
31544: public:
31544:   /** @return True if the elements are equals; false otherwise. */
31544:   PRBool Equals(const nsIntRect& aA, const nsIntRect& aB) const
31544:   {
31544:     return aA.XMost() == aB.XMost();
31544:   }
31544:   /** @return True if (a < b); false otherwise. */
31544:   PRBool LessThan(const nsIntRect& aA, const nsIntRect& aB) const
31544:   {
31544:     return aA.XMost() < aB.XMost();
31544:   }
31544: };
31544: 
31544: // If aPixDelta has a negative component, flip aRect across the
31544: // axis in that direction. We do this so we can assume all scrolling is
31544: // down and to the right to simplify SortBlitRectsForCopy
31544: static nsIntRect
31544: FlipRect(const nsIntRect& aRect, nsIntPoint aPixDelta)
31544: {
31544:   nsIntRect r = aRect;
31544:   if (aPixDelta.x < 0) {
31544:     r.x = -r.XMost();
31544:   }
31544:   if (aPixDelta.y < 0) {
31544:     r.y = -r.YMost();
31544:   }
31544:   return r;
31544: }
31544: 
31544: // Extract the rectangles from aInnerPixRegion, and sort them into aRects
31544: // so that moving rectangle aRects[i] - aPixDelta to aRects[i] will not
31544: // cause the rectangle to overlap any rectangles that haven't moved yet. See
31544: // http://weblogs.mozillazine.org/roc/archives/2009/08/homework_answer.html
31544: static void
31544: SortBlitRectsForCopy(const nsRegion& aInnerPixRegion,
31544:                      nsIntPoint aPixDelta,
31544:                      nsTArray<nsIntRect>* aResult)
31544: {
31544:   nsTArray<nsIntRect> rects;
31544: 
31544:   const nsRect* r;
31544:   for (nsRegionRectIterator iter(aInnerPixRegion); (r = iter.Next());) {
31544:     nsIntRect rect =
31544:       FlipRect(nsIntRect(r->x, r->y, r->width, r->height), aPixDelta);
31544:     rects.AppendElement(rect);
31544:   }
31544:   rects.Sort(RightEdgeComparator());
31544: 
31544:   // This could probably be improved a bit for some worst-case scenarios.
31544:   // But in common cases this should be very fast, and we shouldn't
31544:   // make it more complex unless we really need to.
31544:   while (!rects.IsEmpty()) {
31544:     PRInt32 i = rects.Length() - 1;
31544:     PRBool overlappedBelow;
31544:     do {
31544:       overlappedBelow = PR_FALSE;
31544:       const nsIntRect& rectI = rects[i];
31544:       // see if any rectangle < i overlaps rectI horizontally and is below
31544:       // rectI
31544:       for (PRInt32 j = i - 1; j >= 0; --j) {
31544:         if (rects[j].XMost() <= rectI.x) {
31544:           // No rectangle with index <= j can overlap rectI horizontally
31544:           break;
31544:         }
31544:         // Rectangle j overlaps rectI horizontally.
31544:         if (rects[j].y >= rectI.y) {
31544:           // Rectangle j is below rectangle i. This is the rightmost such
31544:           // rectangle, so set i to this rectangle and continue.
31544:           i = j;
31544:           overlappedBelow = PR_TRUE;
31544:           break;
31544:         }
31544:       }
31544:     } while (overlappedBelow); 
31544: 
31544:     // Rectangle i has no rectangles to the right or below.
31544:     // Flip it back before saving the result.
31544:     aResult->AppendElement(FlipRect(rects[i], aPixDelta));
31544:     rects.RemoveElementAt(i);
31544:   }
31544: }
31544: 
30540: void nsScrollPortView::Scroll(nsView *aScrolledView, nsPoint aTwipsDelta,
30540:                               nsIntPoint aPixDelta, PRInt32 aP2A,
30540:                               const nsTArray<nsIWidget::Configuration>& aConfigurations)
    1: {
    1:   if (aTwipsDelta.x != 0 || aTwipsDelta.y != 0)
    1:   {
19214:     /* If we should invalidate our wrapped view, we should do so at this
19214:      * point.
19214:      */
19214:     if (aScrolledView->NeedsInvalidateFrameOnScroll())
19214:       GetViewManager()->GetViewObserver()->InvalidateFrameForView(aScrolledView);
19214:     
30540:     nsPoint nearestWidgetOffset;
30540:     nsIWidget *nearestWidget = GetNearestWidget(&nearestWidgetOffset);
31544:     if (!nearestWidget ||
31544:         nearestWidget->GetTransparencyMode() == eTransparencyTransparent) {
    1:       // Just update the view and adjust widgets
    1:       // Recall that our widget's origin is at our bounds' top-left
30540:       if (nearestWidget) {
30540:         nearestWidget->ConfigureChildren(aConfigurations);
30540:       }
    1:       nsRect bounds(GetBounds());
    1:       nsPoint topLeft(bounds.x, bounds.y);
    1:       AdjustChildWidgets(aScrolledView,
    1:                          GetPosition() - topLeft, aP2A, PR_FALSE);
    1:       // We should call this after fixing up the widget positions to be
    1:       // consistent with the view hierarchy.
18882:       mViewManager->UpdateView(this, NS_VMREFRESH_DEFERRED);
30540:     } else {
31544:       nsRegion blitRegion;
31544:       nsRegion repaintRegion;
31544:       mViewManager->GetRegionsForBlit(aScrolledView, aTwipsDelta,
31544:                                       &blitRegion, &repaintRegion);
31544:       blitRegion.MoveBy(nearestWidgetOffset);
31544:       repaintRegion.MoveBy(nearestWidgetOffset);
31544: 
30540:       // We're going to bit-blit.  Let the viewmanager know so it can
30540:       // adjust dirty regions appropriately.
30540:       mViewManager->WillBitBlit(this, aTwipsDelta);
 1913: 
31544:       // innerPixRegion is in device pixels
31544:       nsRegion innerPixRegion =
31544:         ConvertToInnerPixelRegion(blitRegion, aP2A, &repaintRegion);
31544:       nsTArray<nsIntRect> blitRects;
31544:       SortBlitRectsForCopy(innerPixRegion, aPixDelta, &blitRects);
 1913: 
31544:       nearestWidget->Scroll(aPixDelta, blitRects, aConfigurations);
30540:       AdjustChildWidgets(aScrolledView, nearestWidgetOffset, aP2A, PR_TRUE);
31544:       repaintRegion.MoveBy(-nearestWidgetOffset);
31544:       mViewManager->UpdateViewAfterScroll(this, repaintRegion);
    1:     }
    1:   }
    1: }
    1: 
21172: NS_IMETHODIMP nsScrollPortView::ScrollToImpl(nscoord aX, nscoord aY)
    1: {
    1:   PRInt32           dxPx = 0, dyPx = 0;
    1: 
    1:   // convert to pixels
    1:   nsCOMPtr<nsIDeviceContext> dev;
    1:   mViewManager->GetDeviceContext(*getter_AddRefs(dev));
    1:   PRInt32 p2a = dev->AppUnitsPerDevPixel();
    1: 
    1:   // Update the scrolled view's position
    1:   nsresult rv = ClampScrollValues(aX, aY, this);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   
 8082:   PRInt32 xPixels = NSAppUnitsToIntPixels(aX, p2a);
 8082:   PRInt32 yPixels = NSAppUnitsToIntPixels(aY, p2a);
    1:   
 8082:   aX = NSIntPixelsToAppUnits(xPixels, p2a);
 8082:   aY = NSIntPixelsToAppUnits(yPixels, p2a);
    1:   
28609:   // do nothing if we aren't scrolling.
    1:   // this needs to be rechecked because of the clamping and
    1:   // rounding
    1:   if (aX == mOffsetX && aY == mOffsetY) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // figure out the diff by comparing old pos to new
 8082:   dxPx = NSAppUnitsToIntPixels(mOffsetX, p2a) - xPixels;
 8082:   dyPx = NSAppUnitsToIntPixels(mOffsetY, p2a) - yPixels;
    1: 
    1:   // notify the listeners.
    1:   PRUint32 listenerCount;
    1:   const nsIID& kScrollPositionListenerIID = NS_GET_IID(nsIScrollPositionListener);
    1:   nsIScrollPositionListener* listener;
    1:   if (nsnull != mListeners) {
    1:     if (NS_SUCCEEDED(mListeners->Count(&listenerCount))) {
    1:       for (PRUint32 i = 0; i < listenerCount; i++) {
    1:         if (NS_SUCCEEDED(mListeners->QueryElementAt(i, kScrollPositionListenerIID, (void**)&listener))) {
    1:           listener->ScrollPositionWillChange(this, aX, aY);
    1:           NS_RELEASE(listener);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   
    1:   nsView* scrolledView = GetScrolledView();
    1:   if (!scrolledView) return NS_ERROR_FAILURE;
    1: 
    1:   // move the scrolled view to the new location
    1:   scrolledView->SetPositionIgnoringChildWidgets(-aX, -aY);
    1:       
18884:   // notify the listeners.
30540:   nsTArray<nsIWidget::Configuration> configurations;
18884:   if (nsnull != mListeners) {
18884:     if (NS_SUCCEEDED(mListeners->Count(&listenerCount))) {
18884:       for (PRUint32 i = 0; i < listenerCount; i++) {
18884:         if (NS_SUCCEEDED(mListeners->QueryElementAt(i, kScrollPositionListenerIID, (void**)&listener))) {
30540:           listener->ViewPositionDidChange(this, &configurations);
18884:           NS_RELEASE(listener);
18884:         }
18884:       }
18884:     }
18884:   }
18884: 
    1:   nsPoint twipsDelta(aX - mOffsetX, aY - mOffsetY);
    1: 
    1:   // store the new position
    1:   mOffsetX = aX;
    1:   mOffsetY = aY;
    1: 
30540:   Scroll(scrolledView, twipsDelta, nsIntPoint(dxPx, dyPx), p2a, configurations);
    1: 
    1:   mViewManager->SynthesizeMouseMove(PR_TRUE);
    1:   
    1:   // notify the listeners.
    1:   if (nsnull != mListeners) {
    1:     if (NS_SUCCEEDED(mListeners->Count(&listenerCount))) {
    1:       for (PRUint32 i = 0; i < listenerCount; i++) {
    1:         if (NS_SUCCEEDED(mListeners->QueryElementAt(i, kScrollPositionListenerIID, (void**)&listener))) {
    1:           listener->ScrollPositionDidChange(this, aX, aY);
    1:           NS_RELEASE(listener);
    1:         }
    1:       }
    1:     }
    1:   }
    1:  
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool nsScrollPortView::IsSmoothScrollingEnabled() {
    1:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:   if (prefs) {
    1:     PRBool enabled;
    1:     nsresult rv = prefs->GetBoolPref(SMOOTH_SCROLL_PREF_NAME, &enabled);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       return enabled;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: /*
21172:  * Callback function from timer used in nsScrollPortView::ScrollTo
    1:  */
    1: void
21172: nsScrollPortView::AsyncScrollCallback(nsITimer *aTimer, void* anInstance) 
    1: {
 3233:   nsScrollPortView* self = static_cast<nsScrollPortView*>(anInstance);
    1:   if (self) {
    1:     self->IncrementalScroll();
    1:   }
    1: }
    1: 
    1: /*
21172:  * manages data members and calls to ScrollTo from the (static) AsyncScrollCallback method
    1:  */ 
    1: void
    1: nsScrollPortView::IncrementalScroll()
    1: {
21172:   if (!mAsyncScroll)
21172:     return;
21172: 
31777:   nsWeakView thisView = this;
21172:   if (mAsyncScroll->mIsSmoothScroll) {
21172:     if (mAsyncScroll->mFrameIndex < SMOOTH_SCROLL_FRAMES) {
21172:       ScrollToImpl(mOffsetX + mAsyncScroll->mVelocities[mAsyncScroll->mFrameIndex*2],
21172:                    mOffsetY + mAsyncScroll->mVelocities[mAsyncScroll->mFrameIndex*2 + 1]);
31777:       if (!thisView.IsAlive())
31777:         return;
21172:       mAsyncScroll->mFrameIndex++;
    1:       return;
    1:     }
    1:   } else {
21172:     ScrollToImpl(mDestinationX, mDestinationY);
31777:     if (!thisView.IsAlive())
31777:       return;
    1:   }
21172:   delete mAsyncScroll;
21172:   mAsyncScroll = nsnull;
    1: }
