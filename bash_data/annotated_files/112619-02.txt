 86062: #!/usr/bin/env python
 86062: # header.py - Generate C++ header files from IDL.
 86062: #
 86062: # ***** BEGIN LICENSE BLOCK *****
 86062: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
 86062: #
 86062: # The contents of this file are subject to the Mozilla Public License Version
 86062: # 1.1 (the "License"); you may not use this file except in compliance with
 86062: # the License. You may obtain a copy of the License at
 86062: # http://www.mozilla.org/MPL/
 86062: #
 86062: # Software distributed under the License is distributed on an "AS IS" basis,
 86062: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 86062: # for the specific language governing rights and limitations under the
 86062: # License.
 86062: #
 86062: # The Original Code is mozilla.org code.
 86062: #
 86062: # The Initial Developer of the Original Code is
 86062: #   Mozilla Foundation.
 86062: # Portions created by the Initial Developer are Copyright (C) 2011
 86062: # the Initial Developer. All Rights Reserved.
 86062: #
 86062: # Contributor(s):
 86062: #   Olli Pettay <Olli.Pettay@helsinki.fi>
 86062: #
 86062: # Alternatively, the contents of this file may be used under the terms of
 86062: # either of the GNU General Public License Version 2 or later (the "GPL"),
 86062: # or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 86062: # in which case the provisions of the GPL or the LGPL are applicable instead
 86062: # of those above. If you wish to allow use of your version of this file only
 86062: # under the terms of either the GPL or the LGPL, and not to allow others to
 86062: # use your version of this file under the terms of the MPL, indicate your
 86062: # decision by deleting the provisions above and replace them with the notice
 86062: # and other provisions required by the GPL or the LGPL. If you do not delete
 86062: # the provisions above, a recipient may use your version of this file under
 86062: # the terms of any one of the MPL, the GPL or the LGPL.
 86062: #
 86062: # ***** END LICENSE BLOCK *****
 86062: 
 86062: from codegen import *
 86062: import sys, os.path, re, xpidl, itertools
 86062: 
 86062: # --makedepend-output support.
 86062: make_dependencies = []
 86062: make_targets = []
 86062: 
 86062: def strip_begin(text, suffix):
 86062:     if not text.startswith(suffix):
 86062:         return text
 86062:     return text[len(suffix):]
 86062: 
 86062: def strip_end(text, suffix):
 86062:     if not text.endswith(suffix):
 86062:         return text
 86062:     return text[:-len(suffix)]
 86062: 
 86062: # Copied from dombindingsgen.py
 86062: def writeMakeDependOutput(filename):
 86062:     print "Creating makedepend file", filename
 86062:     f = open(filename, 'w')
 86062:     try:
 86062:         if len(make_targets) > 0:
 86062:             f.write("%s:" % makeQuote(make_targets[0]))
 86062:             for filename in make_dependencies:
 86062:                 f.write(' \\\n\t\t%s' % makeQuote(filename))
 86062:             f.write('\n\n')
 86062:             for filename in make_targets[1:]:
 86062:                 f.write('%s: %s\n' % (makeQuote(filename), makeQuote(make_targets[0])))
 86062:     finally:
 86062:         f.close()
 86062: 
 86062: def findIDL(includePath, interfaceFileName):
 86062:     for d in includePath:
 86062:         # Not os.path.join: we need a forward slash even on Windows because
 86062:         # this filename ends up in makedepend output.
 86062:         path = d + '/' + interfaceFileName
 86062:         if os.path.exists(path):
 86062:             return path
 86062:     raise BaseException("No IDL file found for interface %s "
 86062:                         "in include path %r"
 86062:                         % (interfaceFileName, includePath))
 86062: 
 86062: def loadIDL(parser, includePath, filename):
 88041:     idlFile = findIDL(includePath, filename)
 88041:     if not idlFile in make_dependencies:
 88041:         make_dependencies.append(idlFile)
 88041:     idl = p.parse(open(idlFile).read(), idlFile)
 86062:     idl.resolve(includePath, p)
 86062:     return idl
 86062: 
 86062: class Configuration:
 86062:     def __init__(self, filename):
 86062:         config = {}
 86062:         execfile(filename, config)
 86062:         self.dictionaries = config.get('dictionaries', [])
 86062:         self.special_includes = config.get('special_includes', [])
 86062:         self.exclude_automatic_type_include = config.get('exclude_automatic_type_include', [])
 86062: 
 86062: def readConfigFile(filename):
 86062:     return Configuration(filename)
 86062: 
 86062: def firstCap(str):
 86062:     return str[0].upper() + str[1:]
 86062: 
 86062: def attributeGetterName(a):
 86062:     binaryname = a.binaryname is not None and a.binaryname or firstCap(a.name)
 86062:     return "Get%s" % (binaryname)
 86062: 
 86062: def attributeParamlist(prefix, a):
 86062:     if a.realtype.nativeType('in').endswith('*'):
 86062:         l = ["getter_AddRefs(%s%s)" % (prefix, a.name.strip('* '))]
 86062:     elif a.realtype.nativeType('in').count("nsAString"):
 86062:         l = ["%s%s" % (prefix, a.name)]
 86062:     else:
 86062:         l = ["&(%s%s)" % (prefix, a.name)]
 86062: 
 86062:     if a.implicit_jscontext:
 86062:         l.insert(0, "aCx")
 86062: 
 86062:     return ", ".join(l)
 86062: 
 86062: def attributeVariableTypeAndName(a):
 86062:     if a.realtype.nativeType('in').endswith('*'):
 86062:         l = ["nsCOMPtr<%s> %s" % (a.realtype.nativeType('in').strip('* '),
 86062:                    a.name)]
 86062:     elif a.realtype.nativeType('in').count("nsAString"):
 86062:         l = ["nsAutoString %s" % a.name]
 86062:     elif a.realtype.nativeType('in').count("JS::Value"):
 86062:         l = ["JS::Value %s" % a.name]
 86062:     else:
 86062:         l = ["%s%s" % (a.realtype.nativeType('in'),
 86062:                        a.name)]
 86062: 
 86062:     return ", ".join(l)
 86062: 
 86062: def dict_name(iface):
 86062:     return "%s" % strip_begin(iface, "nsI")
 86062: 
 86062: def print_header(idl, fd, conf, dictname, dicts):
 86062:     for p in idl.productions:
 86062:         if p.kind == 'interface' and p.name == dictname:
 86062:             interfaces = []
 86062:             base = p.base
 86062:             baseiface = p.idl.getName(p.base, p.location)
 86062:             while base != "nsISupports" and not base in dicts:
 86062:                 dicts.append(base)
 86062:                 interfaces.append(baseiface)
 86062:                 base = baseiface.base
 86062:                 baseiface = baseiface.idl.getName(baseiface.base, baseiface.location)
 86062: 
 86062:             interfaces.reverse()
 86062:             for iface in interfaces:
 86062:                 write_header(iface, fd)
 86062: 
 86062:             if not p.name in dicts:
 86062:                 dicts.append(p.name)
 86062:                 write_header(p, fd)
 86062: 
 86062: def print_header_file(fd, conf):
 86062:     fd.write("/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */\n\n"
 86062:              "#ifndef _gen_mozilla_idl_dictionary_helpers_h_\n"
 86062:              "#define _gen_mozilla_idl_dictionary_helpers_h_\n\n")
 86062: 
 86062:     fd.write("#include \"jsapi.h\"\n"
 86062:              "#include \"nsString.h\"\n"
 86062:              "#include \"nsCOMPtr.h\"\n\n")
 86062: 
 86062:     forwards = []
 86062:     attrnames = []
 86062:     for d in conf.dictionaries:
 86062:         idl = loadIDL(p, options.incdirs, d[1])
 86062:         collect_names_and_non_primitive_attribute_types(idl, d[0], attrnames, forwards)
 86062:     
 86062:     for c in forwards:
 86062:         fd.write("class %s;\n" % c)
 86062: 
 86062: 
 86062:     fd.write("\n"
 86062:              "namespace mozilla {\n"
 86062:              "namespace dom {\n\n")
 86062: 
 86062:     dicts = []
 86062:     for d in conf.dictionaries:
 86062:         if not d[0] in set(dicts):
 86062:             idl = loadIDL(p, options.incdirs, d[1])
 86062:             print_header(idl, fd, conf, d[0], dicts)
 86062:     fd.write("}\n"
 86062:              "}\n"
 86062:              "#endif\n")
 86062: 
 86062: def collect_names_and_non_primitive_attribute_types(idl, dictname, attrnames, forwards):
 86062:     for p in idl.productions:
 86062:         if p.kind == 'interface' and p.name == dictname:
 86062:             interfaces = []
 86062:             base = p.base
 86062:             baseiface = p.idl.getName(p.base, p.location)
 86062:             while base != "nsISupports":
 86062:                 interfaces.append(baseiface)
 86062:                 base = baseiface.base
 86062:                 baseiface = baseiface.idl.getName(baseiface.base, baseiface.location)    
 86062: 
 86062:             interfaces.reverse()
 86062:             interfaces.append(p)
 86062: 
 86062:             for iface in interfaces:
 86062:                 collect_names_and_non_primitive_attribute_types_from_interface(iface, attrnames, forwards)
 86062: 
 86062: def collect_names_and_non_primitive_attribute_types_from_interface(iface, attrnames, forwards):
 86062:     for member in iface.members:
 86062:         if isinstance(member, xpidl.Attribute):
 86062:             if not member.name in attrnames:
 86062:                 attrnames.append(member.name)
 86062:             if member.realtype.nativeType('in').endswith('*'):
 86062:                 t = member.realtype.nativeType('in').strip('* ')
 86062:                 if not t in forwards:
 86062:                     forwards.append(t)
 86062: 
 86062: def print_cpp(idl, fd, conf, dictname, dicts):
 86062:     for p in idl.productions:
 86062:         if p.kind == 'interface' and p.name == dictname:
 86062:             interfaces = []
 86062:             base = p.base
 86062:             baseiface = p.idl.getName(p.base, p.location)
 86062:             while base != "nsISupports" and not base in dicts:
 86062:                 dicts.append(base)
 86062:                 interfaces.append(baseiface)
 86062:                 base = baseiface.base
 86062:                 baseiface = baseiface.idl.getName(baseiface.base, baseiface.location)
 86062: 
 86062:             interfaces.reverse()
 86062:             for iface in interfaces:
 86062:                 write_cpp(iface, fd)
 86062: 
 86062:             if not p.name in dicts:
 86062:                 dicts.append(p.name)
 86062:                 write_cpp(p, fd)
 86062: 
 86062: def get_jsid(name):
 86062:     return ("gDictionary_id_%s" % name)
 86062: 
 86062: def print_cpp_file(fd, conf):
 86062:     fd.write("/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */\n\n")
 86062:     fd.write('#include "DictionaryHelpers.h"\n')
 86062: 
 86062:     includes = []
 86062:     for s in conf.special_includes:
 86062:         if not s in includes:
 86062:             includes.append(strip_end(s, ".h"))
 86062:     
 86062:     for d in conf.dictionaries:
 86062:         if not d[1] in includes:
 86062:             includes.append(strip_end(d[1], ".idl"))
 86062: 
 86062:     attrnames = []
 86062:     for d in conf.dictionaries:
 86062:         idl = loadIDL(p, options.incdirs, d[1])
 86062:         collect_names_and_non_primitive_attribute_types(idl, d[0], attrnames, includes)
 86062:     
 86062:     for c in includes:
 86062:       if not c in conf.exclude_automatic_type_include:
 86062:             fd.write("#include \"%s.h\"\n" % c)
 86062: 
 86062:     fd.write("\nusing namespace mozilla::dom;\n\n")
 86062: 
 86062:     for a in attrnames:
 86062:         fd.write("static jsid %s = JSID_VOID;\n"% get_jsid(a))
 86062: 
 86062:     fd.write("\n"
 86062:              "static bool\n"
 86062:              "DefineStaticJSVal(JSContext* aCx, jsid &id, const char* aString)\n"
 86062:              "{\n"
 86062:              "  if (JSString* str = JS_InternString(aCx, aString)) {\n"
 86062:              "    id = INTERNED_STRING_TO_JSID(aCx, str);\n"
 86062:              "    return true;\n"
 86062:              "  }\n"
 86062:              "  return false;\n"
 86062:              "}\n\n"
 86062:              "bool\n"
 86062:              "DefineStaticDictionaryJSVals(JSContext* aCx)\n"
 86062:              "{\n"
 86062:              "  JSAutoRequest ar(aCx);\n"
 86062:              "  return\n")
 86062:     for a in attrnames:
 86062:         fd.write("    DefineStaticJSVal(aCx, %s, \"%s\") &&\n"
 86062:                  % (get_jsid(a), a))
 86062: 
 86062:     fd.write("    true;\n")
 86062:     fd.write("}\n\n")
 86062: 
 86062:     dicts = []
 86062:     for d in conf.dictionaries:
 86062:         if not d[0] in set(dicts):
 86062:             idl = p.parse(open(findIDL(options.incdirs, d[1])).read(), d[1])
 86062:             idl.resolve(options.incdirs, p)
 86062:             print_cpp(idl, fd, conf, d[0], dicts)
 86062: 
 86062: def init_value(attribute):
 86062:     realtype = attribute.realtype.nativeType('in')
 86062:     realtype = realtype.strip(' ')
 86062:     if realtype.endswith('*'):
 86062:         return "nsnull"
 86062:     if realtype == "bool":
 86062:         return "false"
 86062:     if realtype.count("nsAString"):
 86062:         return "EmptyString()"
 86062:     if realtype.count("nsACString"):
 86062:         return "EmptyCString()"
 86062:     if realtype.count("JS::Value"):
 86062:         return "JSVAL_VOID"
 86062:     return "0"
 86062: 
 86062: def write_header(iface, fd):
 86062:     attributes = []
 86062:     for member in iface.members:
 86062:         if isinstance(member, xpidl.Attribute):
 86062:             attributes.append(member)
 86062:     
 86062:     fd.write("class %s" % dict_name(iface.name))
 86062:     if iface.base != "nsISupports":
 86062:         fd.write(" : public %s" % dict_name(iface.base))
 86062:     fd.write("\n{\npublic:\n")
 86062:     fd.write("  %s()" % dict_name(iface.name))
 86062: 
 86062:     if iface.base != "nsISupports" or len(attributes) > 0:
 86062:         fd.write(" :\n")
 86062:     
 86062:     if iface.base != "nsISupports":
 86062:         fd.write("    %s()" % dict_name(iface.base))
 86062:         if len(attributes) > 0:
 86062:             fd.write(",\n")
 86062: 
 86062:     for i in range(len(attributes)):
 86062:         fd.write("    %s(%s)" % (attributes[i].name, init_value(attributes[i])))
 86062:         if i < (len(attributes) - 1):
 86062:             fd.write(",")
 86062:         fd.write("\n")
 86062: 
 86062:     fd.write("  {}\n\n")
 86062: 
 86062:     fd.write("  // If aCx or aVal is null, NS_OK is returned and \n"
 86062:              "  // dictionary will use the default values. \n"
 86062:              "  nsresult Init(JSContext* aCx, const jsval* aVal);\n")
 86062:     
 86062:     fd.write("\n")
 86062: 
 86062:     for member in attributes:
 86062:         fd.write("  %s;\n" % attributeVariableTypeAndName(member))
 86062: 
 86062:     fd.write("};\n\n")
 86062: 
 86062: def write_cpp(iface, fd):
 86062:     attributes = []
 86062:     for member in iface.members:
 86062:         if isinstance(member, xpidl.Attribute):
 86062:             attributes.append(member)
 86062: 
 86062:     fd.write("static nsresult\n%s_InitInternal(%s& aDict, %s* aIfaceObject, JSContext* aCx, JSObject* aObj)\n" %
 86062:              (dict_name(iface.name), dict_name(iface.name), iface.name))
 86062:     fd.write("{\n")
 86062:     if iface.base != "nsISupports":
 86062:         fd.write("  nsresult rv = %s_InitInternal(aDict, aIfaceObject, aCx, aObj);\n" %
 86062:                  dict_name(iface.base))
 86062:         fd.write("  NS_ENSURE_SUCCESS(rv, rv);\n")
 86062: 
 86062:     fd.write("  JSBool found = PR_FALSE;\n")
 86062:     for a in attributes:
 86062:         fd.write("  NS_ENSURE_STATE(JS_HasPropertyById(aCx, aObj, %s, &found));\n"
 86062:                  % get_jsid(a.name))
 86062:         fd.write("  if (found) {\n")
 86062:         fd.write("    nsresult rv = aIfaceObject->%s(" % attributeGetterName(a))
 86062:         fd.write("%s" % attributeParamlist("aDict.", a))
 86062:         fd.write(");\n")
 86062:         fd.write("    NS_ENSURE_SUCCESS(rv, rv);\n")
 86062:         fd.write("  }\n")
 86062:     fd.write("  return NS_OK;\n")
 86062:     fd.write("}\n\n")
 86062:     
 86062:     fd.write("nsresult\n%s::Init(JSContext* aCx, const jsval* aVal)\n" % dict_name(iface.name))
 86062:     fd.write("{\n"
 86062:              "  if (!aCx || !aVal) {\n"
 86062:              "    return NS_OK;\n"
 86062:              "  }\n"
112619:              "  NS_ENSURE_STATE(aVal->isObject());\n\n"
112619:              "  JSObject* obj = &aVal->toObject();\n"
 86062:              "  nsCxPusher pusher;\n"
 86062:              "  NS_ENSURE_STATE(pusher.Push(aCx, false));\n"
 86062:              "  JSAutoRequest ar(aCx);\n"
 86062:              "  JSAutoEnterCompartment ac;\n"
 86062:              "  NS_ENSURE_STATE(ac.enter(aCx, obj));\n")
 86062:     fd.write("  nsCOMPtr<%s> dict;\n" % iface.name)
 86062:     fd.write("  nsContentUtils::XPConnect()->WrapJS(aCx, obj,\n")
 86062:     fd.write("                                      NS_GET_IID(%s),\n" % iface.name)
 86062:     fd.write("                                      getter_AddRefs(dict));\n")
 86062:     fd.write("  NS_ENSURE_TRUE(dict, NS_OK);\n")
 86062: 
 86062:     fd.write("  return %s_InitInternal(*this, dict, aCx, obj);\n}\n\n" %
 86062:                  dict_name(iface.name))
 86062: 
 86062: 
 86062: if __name__ == '__main__':
 86062:     from optparse import OptionParser
 86062:     o = OptionParser(usage="usage: %prog [options] configfile")
 86062:     o.add_option('-I', action='append', dest='incdirs', default=['.'],
 86062:                  help="Directory to search for imported files")
 86062:     o.add_option('-o', "--stub-output",
 86062:                  type='string', dest='stub_output', default=None,
 86062:                  help="Quick stub C++ source output file", metavar="FILE")
 86062:     o.add_option('--header-output', type='string', default=None,
 86062:                  help="Quick stub header output file", metavar="FILE")
 86062:     o.add_option('--makedepend-output', type='string', default=None,
 86062:                  help="gnumake dependencies output file", metavar="FILE")
 86062:     o.add_option('--cachedir', dest='cachedir', default='',
 86062:                  help="Directory in which to cache lex/parse tables.")
 86062:     (options, filenames) = o.parse_args()
 86062:     if len(filenames) != 1:
 86062:         o.error("Exactly one config filename is needed.")
 86062:     filename = filenames[0]
 86062: 
 86062:     if options.cachedir is not None:
 86062:         if not os.path.isdir(options.cachedir):
 86062:             os.mkdir(options.cachedir)
 86062:         sys.path.append(options.cachedir)
 86062: 
 86062:     # Instantiate the parser.
 86062:     p = xpidl.IDLParser(outputdir=options.cachedir)
 86062: 
 86062:     conf = readConfigFile(filename)
 86062: 
 86062:     if options.header_output is not None:
 86062:         outfd = open(options.header_output, 'w')
 86062:         print_header_file(outfd, conf)
 86062:         outfd.close()
 86062:     if options.stub_output is not None:
 86062:         make_targets.append(options.stub_output)
 86062:         outfd = open(options.stub_output, 'w')
 86062:         print_cpp_file(outfd, conf)
 86062:         outfd.close()
 86062:         if options.makedepend_output is not None:
 86062:             writeMakeDependOutput(options.makedepend_output)
 86062: 
