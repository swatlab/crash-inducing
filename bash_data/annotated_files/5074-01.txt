4891: <?xml version="1.0"?>
4891: 
4955: <!-- ***** BEGIN LICENSE BLOCK *****
4955:    - Version: MPL 1.1/GPL 2.0/LGPL 2.1
4891:    -
4955:    - The contents of this file are subject to the Mozilla Public License Version
4955:    - 1.1 (the "License"); you may not use this file except in compliance with
4955:    - the License. You may obtain a copy of the License at
4955:    - http://www.mozilla.org/MPL/
4891:    -
4955:    - Software distributed under the License is distributed on an "AS IS" basis,
4955:    - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
4955:    - for the specific language governing rights and limitations under the
4955:    - License.
4891:    -
4955:    - The Original Code is this file as it was released on March 28, 2001.
4955:    -
4955:    - The Initial Developer of the Original Code is
4955:    - David Hyatt.
4955:    - Portions created by the Initial Developer are Copyright (C) 2001
4955:    - the Initial Developer. All Rights Reserved.
4891:    -
4891:    - Contributor(s):
4891:    -   David Hyatt <hyatt@netscape.com> (Original Author of <tabbrowser>)
4972:    -   Mike Connor <mconnor@steelgryphon.com>
4982:    -   Peter Parente <parente@cs.unc.edu>
4983:    -   Giorgio Maone <g.maone@informaction.com>
5059:    -   Asaf Romano <mozilla.mano@sent.com>
5060:    -   Seth Spitzer <sspitzer@mozilla.org>
4891:    -
4955:    - Alternatively, the contents of this file may be used under the terms of
4955:    - either the GNU General Public License Version 2 or later (the "GPL"), or
4955:    - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
4955:    - in which case the provisions of the GPL or the LGPL are applicable instead
4955:    - of those above. If you wish to allow use of your version of this file only
4955:    - under the terms of either the GPL or the LGPL, and not to allow others to
4955:    - use your version of this file under the terms of the MPL, indicate your
4955:    - decision by deleting the provisions above and replace them with the notice
4955:    - and other provisions required by the GPL or the LGPL. If you do not delete
4955:    - the provisions above, a recipient may use your version of this file under
4955:    - the terms of any one of the MPL, the GPL or the LGPL.
4955:    -
4955:    - ***** END LICENSE BLOCK ***** -->
4891: 
4891: <!DOCTYPE bindings [
4891: <!ENTITY % tabBrowserDTD SYSTEM "chrome://global/locale/tabbrowser.dtd" >
4891: %tabBrowserDTD;
5018: <!ENTITY % globalDTD SYSTEM "chrome://global/locale/global.dtd">
5018: %globalDTD;
4891: ]>
4891: 
4891: <bindings id="tabBrowserBindings"
4891:           xmlns="http://www.mozilla.org/xbl"
4891:           xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
4891:           xmlns:xbl="http://www.mozilla.org/xbl">
4891: 
4891:   <binding id="tabbrowser">
4891:     <resources>
4891:       <stylesheet src="chrome://global/skin/browser.css"/>
4891:     </resources>
4891: 
4891:     <content>
5028:       <xul:stringbundle anonid="tbstringbundle" src="chrome://global/locale/tabbrowser.properties"/>
5028:       <xul:tabbox anonid="tabbox" flex="1" eventnode="document" xbl:inherits="handleCtrlPageUpDown"
5027:                   onselect="if (!('updateCurrentBrowser' in this.parentNode) || event.target.localName != 'tabpanels') return; this.parentNode.updateCurrentBrowser();">
5002:         <xul:hbox class="tab-drop-indicator-bar">
5045:           <xul:hbox class="tab-drop-indicator" mousethrough="always"/>
4972:         </xul:hbox>
4981:         <xul:hbox class="tabbrowser-strip" collapsed="true" tooltip="_child" context="_child"
5028:                   anonid="strip"
4972:                   ondraggesture="nsDragAndDrop.startDrag(event, this.parentNode.parentNode); event.stopPropagation();"
4972:                   ondragover="nsDragAndDrop.dragOver(event, this.parentNode.parentNode); event.stopPropagation();"
4972:                   ondragdrop="nsDragAndDrop.drop(event, this.parentNode.parentNode); event.stopPropagation();"
4972:                   ondragexit="nsDragAndDrop.dragExit(event, this.parentNode.parentNode); event.stopPropagation();">
5018:           <xul:tooltip onpopupshowing="return this.parentNode.parentNode.parentNode.createTooltip(event);"/>
4993:           <xul:menupopup anonid="tabContextMenu" onpopupshowing="this.parentNode.parentNode.parentNode.updatePopupMenu(this);">
4891:             <xul:menuitem label="&newTab.label;" accesskey="&newTab.accesskey;"
4891:                           xbl:inherits="oncommand=onnewtab"/>
4891:             <xul:menuseparator/>
4891:             <xul:menuitem label="&reloadTab.label;" accesskey="&reloadTab.accesskey;"
4891:                           oncommand="var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;
4891:                                      tabbrowser.reloadTab(tabbrowser.mContextTab);"/>
4891:             <xul:menuitem label="&reloadAllTabs.label;" accesskey="&reloadAllTabs.accesskey;"
4891:                           tbattr="tabbrowser-multiple"
4891:                           oncommand="var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;
4891:                                      tabbrowser.reloadAllTabs(tabbrowser.mContextTab);"/>
4913:             <xul:menuitem label="&closeOtherTabs.label;" accesskey="&closeOtherTabs.accesskey;"
4913:                           tbattr="tabbrowser-multiple"
4913:                           oncommand="var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;
4913:                                      tabbrowser.removeAllTabsBut(tabbrowser.mContextTab);"/>
4891:             <xul:menuseparator/>
4891:             <xul:menuitem label="&closeTab.label;" accesskey="&closeTab.accesskey;"
4891:                           tbattr="tabbrowser-multiple"
4891:                           oncommand="var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;
4891:                                      tabbrowser.removeTab(tabbrowser.mContextTab);"/>
4891:           </xul:menupopup>
4891: 
5028:           <xul:tabs class="tabbrowser-tabs" flex="1"
5028:                     anonid="tabcontainer"
5028:                     setfocus="false"
4891:                     onclick="this.parentNode.parentNode.parentNode.onTabClick(event);"
4891:                     xbl:inherits="onnewtab"
4936:                     ondblclick="this.parentNode.parentNode.parentNode.onTabBarDblClick(event);"
4891:                     onclosetab="var node = this.parentNode;
4891:                                 while (node.localName != 'tabbrowser')
4891:                                   node = node.parentNode;
4891:                                 node.removeCurrentTab();">
4951:             <xul:tab selected="true" validate="never"
4891:                      onerror="this.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('image'));
4891:                               this.removeAttribute('image');"
5072:                      maxwidth="250" width="0" minwidth="100" flex="100"
4891:                      class="tabbrowser-tab" label="&untitledTab;" crop="end"/>
4891:           </xul:tabs>
4891:         </xul:hbox>
5028:         <xul:tabpanels flex="1" class="plain" selectedIndex="0" anonid="panelcontainer">
5036:           <xul:notificationbox flex="1">
5036:             <xul:browser flex="1" type="content-primary" message="true" disablehistory="true"
5036:                          xbl:inherits="tooltip=contenttooltip,contextmenu=contentcontextmenu,autocompletepopup"/>
5036:           </xul:notificationbox>
4891:         </xul:tabpanels>
4891:       </xul:tabbox>
4891:       <children/>
4891:     </content>
4891:     <implementation>
4891:       <field name="mPrefs" readonly="true">
4891:         Components.classes['@mozilla.org/preferences-service;1']
4891:                   .getService(Components.interfaces.nsIPrefService)
4891:                   .getBranch(null);
4891:       </field>
4957:       <field name="mURIFixup" readonly="true">
4957:         Components.classes["@mozilla.org/docshell/urifixup;1"]
4957:                   .getService(Components.interfaces.nsIURIFixup);
4957:       </field>
5028:       <field name="mTabBox" readonly="true">
5028:         document.getAnonymousElementByAttribute(this, "anonid", "tabbox");
4891:       </field>
5002:       <field name="mTabDropIndicatorBar">
5002:         this.mTabBox.childNodes[0]
5002:       </field>
5028:       <field name="mStrip" readonly="true">
5028:         document.getAnonymousElementByAttribute(this, "anonid", "strip");
4891:       </field>
5028:       <field name="mTabContainer" readonly="true">
5028:         document.getAnonymousElementByAttribute(this, "anonid", "tabcontainer");
4891:       </field>
5028:       <field name="mPanelContainer" readonly="true">
5028:         document.getAnonymousElementByAttribute(this, "anonid", "panelcontainer");
4972:       </field>
5028:       <field name="mTabs" readonly="true">
4972:         this.mTabContainer.childNodes
4891:       </field>
4891:       <field name="mStringBundle">
5028:         document.getAnonymousElementByAttribute(this, "anonid", "tbstringbundle");
4891:       </field>
4891:       <field name="mCurrentTab">
4891:         null
4891:       </field>
4891:       <field name="mCurrentBrowser">
4891:         null
4891:       </field>
4891:       <field name="mProgressListeners">
5028:         []
4891:       </field>
4891:       <field name="mTabListeners">
4891:         new Array()
4891:       </field>
4891:       <field name="mTabFilters">
4891:         new Array()
4891:       </field>
4891:       <field name="mTabbedMode">
4891:         false
4891:       </field>
4891:       <field name="mIsBusy">
4891:         false
4891:       </field>
4891:       <field name="mMissedIconCache">
4891:         null
4891:       </field>
4891:       <field name="mContextTab">
4891:         null
4891:       </field>
4942:       <field name="mModalDialogShowing">
4942:         false
4942:       </field>
4972:       <field name="arrowKeysShouldWrap" readonly="true">
4972: #ifdef XP_MACOSX
4972:         true
4972: #else
4972:         false
4972: #endif
4972:       </field>
4999:       <field name="mAddProgressListenerWasCalled">
4999:         false
4999:       </field>
5041:       <field name="_browsers">
5041:         null
5041:       </field>
4891: 
5059:       <field name="_blockDblClick">
5059:         false
5059:       </field>
5059: 
4943:       <method name="getBrowserAtIndex">
4943:         <parameter name="aIndex"/>
4943:         <body>
4943:           <![CDATA[
4972:             return this.mTabContainer.childNodes[aIndex].linkedBrowser;
4943:           ]]>
4943:         </body>
4943:       </method>
4943: 
4943:       <method name="getBrowserIndexForDocument">
4943:         <parameter name="aDocument"/>
4943:         <body>
4943:           <![CDATA[
4943:             for (var i = 0; i < this.mPanelContainer.childNodes.length; i++) {
4943:               if (this.getBrowserAtIndex(i).contentDocument == aDocument) {
4943:                 return i;
4943:               }
4943:             }
4943:             return -1;
4943:           ]]>
4943:         </body>
4943:       </method>
4943: 
5039:       <method name="getBrowserForDocument">
5039:         <parameter name="aDocument"/>
5039:         <body>
5039:           <![CDATA[
5039:             var index = this.getBrowserIndexForDocument(aDocument);
5039:             if (index < 0)
5039:               return null;
5039:             return this.getBrowserAtIndex(index);
5039:           ]]>
5039:         </body>
5039:       </method>
5039: 
5036:       <method name="getNotificationBox">
4943:         <parameter name="aBrowser"/>
4943:         <body>
4943:           <![CDATA[
5036:             if (aBrowser)
5036:               return aBrowser.parentNode;
5036:             else if (this.mCurrentBrowser)
5036:               return this.mCurrentBrowser.parentNode;
5036:             return null;
4943:           ]]>
4943:         </body>
4943:       </method>
4943: 
4891:       <!-- A web progress listener object definition for a given tab. -->
4891:       <method name="mTabProgressListener">
4891:         <parameter name="aTab"/>
4924:         <parameter name="aBrowser"/>
4891:         <parameter name="aStartsBlank"/>
4891:         <body>
4891:         <![CDATA[
4891:           return ({
4924:             mTabBrowser: this,
4891:             mTab: aTab,
4924:             mBrowser: aBrowser,
4891:             mBlank: aStartsBlank,
4943:             mLastURI: null,
4891: 
5029:             // cache flags for correct status bar update after tab switching
5029:             mStateFlags: 0,
5029:             mStatus: 0,
5029:             mMessage: "",
5029:             mTotalProgress: 0,
5029: 
5033:             // count of open requests (should always be 0 or 1)
5033:             mRequestCount: 0,
5033: 
4891:             onProgressChange : function (aWebProgress, aRequest,
4891:                                          aCurSelfProgress, aMaxSelfProgress,
4920:                                          aCurTotalProgress, aMaxTotalProgress)
4920:             {
4891:               if (!this.mBlank && this.mTabBrowser.mCurrentTab == this.mTab) {
4891:                 for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
4891:                   var p = this.mTabBrowser.mProgressListeners[i];
4891:                   if (p)
4891:                     p.onProgressChange(aWebProgress, aRequest,
4891:                                        aCurSelfProgress, aMaxSelfProgress,
4891:                                        aCurTotalProgress, aMaxTotalProgress);
4891:                 }
4891:               }
5029: 
5029:               this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;
4891:             },
4891: 
4891:             onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
4891:             {
4891:               if (!aRequest)
4891:                 return;
4891: 
4891:               var oldBlank = this.mBlank;
4891: 
4891:               const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
4891:               const nsIChannel = Components.interfaces.nsIChannel;
4924: 
5033:               if (aStateFlags & nsIWebProgressListener.STATE_START) {
5033:                 this.mRequestCount++;
5033:               }
5033:               else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {
5033:                 const NS_ERROR_UNKNOWN_HOST = 2152398878;
5033:                 if (--this.mRequestCount > 0 && aStatus == NS_ERROR_UNKNOWN_HOST) {
5033:                   // to prevent bug 235825: wait for the request handled
5033:                   // by the automatic keyword resolver
5033:                   return;
5033:                 }
5033:                 // since we (try to) only handle STATE_STOP of the last request,
5033:                 // the count of open requests should now be 0
5033:                 this.mRequestCount = 0;
5033:               }
5033: 
4924:               if (aStateFlags & nsIWebProgressListener.STATE_START &&
4891:                   aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
4933:                 // It's okay to clear what the user typed when we start
4997:                 // loading a document. If the user types, this counter gets
4997:                 // set to zero, if the document load ends without an
4997:                 // onLocationChange, this counter gets decremented
4997:                 // (so we keep it while switching tabs after failed loads)
4924:                 if (aWebProgress.DOMWindow == this.mBrowser.contentWindow)
4997:                   this.mBrowser.userTypedClear++;
4924: 
4924:                 if (!this.mBlank) {
4891:                   this.mTab.setAttribute("busy", "true");
4976:                   this.mTabBrowser.updateIcon(this.mTab);
4998:                   this.mTabBrowser.setTabTitleLoading(this.mTab);
4891: 
4891:                   if (this.mTabBrowser.mCurrentTab == this.mTab)
4891:                     this.mTabBrowser.mIsBusy = true;
4891:                 }
4924:               }
4891:               else if (aStateFlags & nsIWebProgressListener.STATE_STOP &&
4891:                        aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
4976:                 if (aWebProgress.DOMWindow == this.mBrowser.contentWindow) {
4997:                   // The document is done loading, we no longer want the
4997:                   // value cleared.
4997:                   if (this.mBrowser.userTypedClear > 0)
4997:                     this.mBrowser.userTypedClear--;
4933: 
4976:                   if (!this.mBrowser.mIconURL)
4976:                     this.mTabBrowser.useDefaultIcon(this.mTab);
4976:                 }
4976: 
4891:                 if (this.mBlank)
4891:                   this.mBlank = false;
4891: 
4891:                 this.mTab.removeAttribute("busy");
4976:                 this.mTabBrowser.updateIcon(this.mTab);
4891: 
4891:                 var location = aRequest.QueryInterface(nsIChannel).URI;
4943: 
4943:                 // For keyword URIs clear the user typed value since they will be changed into real URIs
4943:                 if (location.scheme == "keyword")
4943:                   this.mBrowser.userTypedValue = null;
4943: 
4891:                 if (this.mTab.label == this.mTabBrowser.mStringBundle.getString("tabs.loading"))
4891:                   this.mTabBrowser.setTabTitle(this.mTab);
4891: 
4891:                 if (this.mTabBrowser.mCurrentTab == this.mTab)
4891:                   this.mTabBrowser.mIsBusy = false;
4891:               }
4891: 
5043:               if (this.mTabBrowser.mCurrentTab == this.mTab) {
4891:                 for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
4891:                   var p = this.mTabBrowser.mProgressListeners[i];
5043:                   if (p && !oldBlank)
4891:                     p.onStateChange(aWebProgress, aRequest, aStateFlags, aStatus);
5043:                   // make sure that the visible status of new blank tabs is correctly set
5043:                   else if (p && "onUpdateCurrentBrowser" in p)
5043:                     p.onUpdateCurrentBrowser(aStateFlags, aStatus, "", 0);
4891:                 }
4891:               }
5029: 
5029:               if (aStateFlags & (nsIWebProgressListener.STATE_START |
5029:                                  nsIWebProgressListener.STATE_STOP)) {
5029:                 // reset cached temporary values at beginning and end
5029:                 this.mMessage = "";
5029:                 this.mTotalProgress = 0;
5029:               }
5029:               this.mStateFlags = aStateFlags;
5029:               this.mStatus = aStatus;
4945:             },
4891: 
4945:             onLocationChange : function(aWebProgress, aRequest, aLocation)
4945:             {
4933:               // The document loaded correctly, clear the value if we should
5012:               if (this.mBrowser.userTypedClear > 0 && aRequest)
4933:                 this.mBrowser.userTypedValue = null;
4933: 
5001:               if (aWebProgress.DOMWindow == this.mBrowser.contentWindow &&
5001:                   aWebProgress.isLoadingDocument)
4976:                 this.mTabBrowser.setIcon(this.mTab, null);
4976: 
5038:               // changing location, clear out the missing plugins list
5038:               this.mTab.missingPlugins = null;
5038: 
4891:               if (!this.mBlank && this.mTabBrowser.mCurrentTab == this.mTab) {
4891:                 for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
4891:                   var p = this.mTabBrowser.mProgressListeners[i];
4891:                   if (p)
4891:                     p.onLocationChange(aWebProgress, aRequest, aLocation);
4891:                 }
4891:               }
4891:             },
4891: 
4945:             onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
4945:             {
4920:               if (this.mBlank)
4891:                 return;
4891: 
4891:               if (this.mTabBrowser.mCurrentTab == this.mTab) {
4891:                 for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
4891:                   var p = this.mTabBrowser.mProgressListeners[i];
4891:                   if (p)
4891:                     p.onStatusChange(aWebProgress, aRequest, aStatus, aMessage);
4891:                 }
4891:               }
5029: 
5029:               this.mMessage = aMessage;
4891:             },
4891: 
4920:             onSecurityChange : function(aWebProgress, aRequest, aState)
4920:             {
4891:               if (this.mTabBrowser.mCurrentTab == this.mTab) {
4891:                 for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
4891:                   var p = this.mTabBrowser.mProgressListeners[i];
4891:                   if (p)
4891:                     p.onSecurityChange(aWebProgress, aRequest, aState);
4891:                 }
4891:               }
4891:             },
4891: 
4891:             QueryInterface : function(aIID)
4891:             {
4891:               if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
4891:                   aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
4891:                   aIID.equals(Components.interfaces.nsISupports))
4891:                 return this;
4891:               throw Components.results.NS_NOINTERFACE;
4891:             }
4891:           });
4891:         ]]>
4891:         </body>
4891:       </method>
4891: 
4976:       <method name="setIcon">
4976:         <parameter name="aTab"/>
4891:         <parameter name="aURI"/>
4891:         <body>
4891:           <![CDATA[
4976:             var browser = this.getBrowserForTab(aTab);
4976:             browser.mIconURL = aURI;
4976: 
4976:             this.updateIcon(aTab);
4976: 
4976:             for (var i = 0; i < this.mProgressListeners.length; i++) {
4976:               var p = this.mProgressListeners[i];
4976:               if ('onLinkIconAvailable' in p)
4976:                 p.onLinkIconAvailable(browser);
4976:             }
4976:           ]]>
4976:         </body>
4976:       </method>
4976: 
4976:       <method name="updateIcon">
4976:         <parameter name="aTab"/>
4976:         <body>
4976:           <![CDATA[
4976:             var browser = this.getBrowserForTab(aTab);
4976:             if (!aTab.hasAttribute("busy") && browser.mIconURL)
4976:               aTab.setAttribute("image", browser.mIconURL);
4976:             else
4976:               aTab.removeAttribute("image");
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="shouldLoadFavIcon">
4891:         <parameter name="aURI"/>
4891:         <body>
4891:           <![CDATA[
4891:             return (aURI && this.mPrefs.getBoolPref("browser.chrome.site_icons") &&
4891:                     this.mPrefs.getBoolPref("browser.chrome.favicons") &&
4891:                     ("schemeIs" in aURI) && (aURI.schemeIs("http") || aURI.schemeIs("https")));
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4976:       <method name="useDefaultIcon">
4976:         <parameter name="aTab"/>
4891:         <body>
4891:           <![CDATA[
4976:             var browser = this.getBrowserForTab(aTab);
4976:             if (browser.contentDocument instanceof ImageDocument) {
4994:               if (this.mPrefs.getBoolPref("browser.chrome.site_icons")) {
4994:                 try {
4994:                   var sz = this.mPrefs.getIntPref("browser.chrome.image_icons.max_size");
4994:                   if (!sz)
4994:                     return;
4994: 
4994:                   var req = browser.contentDocument.imageRequest;
4994:                   if (!req || !req.image ||
4994:                       req.image.width > sz ||
4994:                       req.image.height > sz)
4994:                     return;
4994: 
4976:                   this.setIcon(aTab, browser.currentURI.spec);
4994:                 } catch (e) { }
4994:               }
4976:             }
4976:             else if (this.shouldLoadFavIcon(browser.currentURI)) {
4976:               var url = browser.currentURI.prePath + "/favicon.ico";
4976:               if (!this.isIconKnownMissing(url))
4976:                 this.setIcon(aTab, url);
4976:             }
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="addToMissedIconCache">
4891:         <parameter name="aURI"/>
4891:         <body>
4891:           <![CDATA[
4920:             var entry = this.openCacheEntry(aURI, Components.interfaces.nsICache.ACCESS_READ_WRITE);
4920:             if (!entry)
4920:               return;
4920: 
4891:             if (entry.accessGranted == Components.interfaces.nsICache.ACCESS_WRITE)
4891:               // It's a new entry.  Just write a bit of metadata in to the entry.
4891:               entry.setMetaDataElement("Icon", "Missed");
4891:             entry.markValid();
4891:             entry.close();
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4920:       <method name="openCacheEntry">
4920:         <parameter name="key"/>
4920:         <parameter name="access"/>
4920:         <body>
4920:           <![CDATA[
4920:             try {
4920:               if (!this.mMissedIconCache) {
4920:                 var cacheService = Components.classes['@mozilla.org/network/cache-service;1'].getService(Components.interfaces.nsICacheService);
4920:                 this.mMissedIconCache = cacheService.createSession("MissedIconCache", Components.interfaces.nsICache.STORE_ANYWHERE, true);
4920:                 if (!this.mMissedIconCache)
4920:                   return null;
4920:               }
4920:               return this.mMissedIconCache.openCacheEntry(key, access, true);
4920:             }
4920:             catch (e) {
4920:               return null;
4920:             }
4920:           ]]>
4920:         </body>
4920:       </method>
4920: 
4976:       <method name="isIconKnownMissing">
4943:         <parameter name="key"/>
4943:         <body>
4943:           <![CDATA[
4943:             var e = this.openCacheEntry(key, Components.interfaces.nsICache.ACCESS_READ);
4943:             if (e) {
4943:                 e.close();
4943:                 return true;
4943:             }
4943:             return false;
4943:           ]]>
4943:         </body>
4943:       </method>
4943: 
4891:       <method name="updateTitlebar">
4891:         <body>
4891:           <![CDATA[
4891:             var newTitle = "";
4891:             var docTitle;
5005:             var docElement = this.ownerDocument.documentElement;
5005:             var sep = docElement.getAttribute("titlemenuseparator");
5005: 
4891:             if (this.docShell.contentViewer)
4937:               docTitle = this.contentTitle;
4891: 
4915:             if (!docTitle)
5005:               docTitle = docElement.getAttribute("titledefault");
4915: 
5005:             var modifier = docElement.getAttribute("titlemodifier");
4891:             if (docTitle) {
5005:               newTitle += docElement.getAttribute("titlepreface");
4891:               newTitle += docTitle;
4918:               if (modifier)
4918:                 newTitle += sep;
4891:             }
4918:             newTitle += modifier;
5005: 
5005:             // If location bar is hidden and the URL type supports a host,
5005:             // add the scheme and host to the title to prevent spoofing.
5005:             // XXX https://bugzilla.mozilla.org/show_bug.cgi?id=22183#c239
5008:             // (only for schemes that support a host)
5005:             try {
5005:               if (docElement.getAttribute("chromehidden").indexOf("location") != -1) {
5008:                 var uri = this.mURIFixup.createExposableURI(
5008:                             this.mCurrentBrowser.currentURI);
5008:                 if (uri.host)
5008:                   newTitle = uri.prePath + sep + newTitle;
5005:               }
5005:             } catch (e) {}
5005: 
4944:             this.ownerDocument.title = newTitle;
4943:           ]]>
4943:         </body>
4943:       </method>
4943: 
4891:       <method name="updatePopupMenu">
4891:         <parameter name="aPopupMenu"/>
4891:         <body>
4891:           <![CDATA[
4947:             this.mContextTab = document.popupNode;
4891:             var disabled = this.mPanelContainer.childNodes.length == 1;
4891:             var menuItems = aPopupMenu.getElementsByAttribute("tbattr", "tabbrowser-multiple");
4891:             for (var i = 0; i < menuItems.length; i++)
4966:               menuItems[i].disabled = disabled;
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="updateCurrentBrowser">
4891:         <body>
4891:           <![CDATA[
4972:             var newBrowser = this.getBrowserAtIndex(this.mTabContainer.selectedIndex);
4901:             if (this.mCurrentBrowser == newBrowser)
4901:               return;
4901: 
4925:             if (this.mCurrentBrowser) {
4962:               // Only save the focused element if it is in our content window
4962:               // or in an ancestor window.
4962:               var focusedWindow = document.commandDispatcher.focusedWindow;
4962:               var saveFocus = false;
4962: 
4985:               if (focusedWindow && focusedWindow.top == window.content) {
4962:                 saveFocus = true;
4962:               } else {
4962:                 var contentWindow = window;
4962: 
4962:                 while (contentWindow) {
4962:                   if (contentWindow == focusedWindow) {
4962:                     saveFocus = true;
4962:                     break;
4962:                   }
4962: 
4962:                   if (contentWindow.parent == contentWindow) {
4962:                     break;
4962:                   }
4962: 
4962:                   contentWindow = contentWindow.parent;
4962:                 }
4962:               }
4962: 
4962:               if (saveFocus) {
4962:                 // Preserve the currently-focused element or DOM window for
4962:                 // this tab.
4962: 
4962:                 this.mCurrentBrowser.focusedWindow = focusedWindow;
4925:                 this.mCurrentBrowser.focusedElement = document.commandDispatcher.focusedElement;
4962:               }
4962: 
4946:               if (this.mCurrentBrowser.focusedElement) {
4946:                 // Clear focus outline before we draw on top of it
4946:                 this.mCurrentBrowser.focusedElement.blur();
4946:               }
5025:               this.mCurrentBrowser.setAttribute("type", "content-targetable");
4925:             }
4891: 
4902:             var updatePageReport = false;
4902:             if ((this.mCurrentBrowser.pageReport && !newBrowser.pageReport) ||
4902:                 (!this.mCurrentBrowser.pageReport && newBrowser.pageReport))
4902:               updatePageReport = true;
4902: 
4891:             newBrowser.setAttribute("type", "content-primary");
4891:             this.mCurrentBrowser = newBrowser;
4891:             this.mCurrentTab = this.selectedTab;
4891: 
4902:             if (updatePageReport)
4902:               this.mCurrentBrowser.updatePageReport();
4902: 
4891:             // Update the URL bar.
4891:             var loc = this.mCurrentBrowser.currentURI;
4974:             if (!loc)
4974:               loc = ({ spec: "" });
4902: 
4891:             var webProgress = this.mCurrentBrowser.webProgress;
4891:             var securityUI = this.mCurrentBrowser.securityUI;
5012: 
4891:             var i, p;
4891:             for (i = 0; i < this.mProgressListeners.length; i++) {
4891:               p = this.mProgressListeners[i];
4891:               if (p) {
4891:                 p.onLocationChange(webProgress, null, loc);
4891:                 if (securityUI)
4891:                   p.onSecurityChange(webProgress, null, securityUI.state);
5029: 
5029:                 // make sure that all status indicators are properly updated
5029:                 if ("onUpdateCurrentBrowser" in p) {
5029:                   var listener = this.mTabListeners[this.mTabContainer.selectedIndex] || null;
5029:                   if (listener && listener.mStateFlags)
5029:                     p.onUpdateCurrentBrowser(listener.mStateFlags, listener.mStatus,
5029:                                              listener.mMessage, listener.mTotalProgress);
5029:                 }
4891:               }
4943:             }
4891: 
4943:             this._fastFind.setDocShell(this.mCurrentBrowser.docShell);
4943: 
4891:             // Update the window title.
4891:             this.updateTitlebar();
4891: 
4891:             // If the new tab is busy, and our current state is not busy, then
4891:             // we need to fire a start to all progress listeners.
4891:             const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
4891:             if (this.mCurrentTab.hasAttribute("busy") && !this.mIsBusy) {
4891:               this.mIsBusy = true;
4891:               webProgress = this.mCurrentBrowser.webProgress;
4891:               for (i = 0; i < this.mProgressListeners.length; i++) {
4891:                 p = this.mProgressListeners[i];
4891:                 if (p)
4891:                   p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_START | nsIWebProgressListener.STATE_IS_NETWORK, 0);
4891:               }
4891:             }
4891: 
4891:             // If the new tab is not busy, and our current state is busy, then
4891:             // we need to fire a stop to all progress listeners.
4891:             if (!this.mCurrentTab.hasAttribute("busy") && this.mIsBusy) {
4891:               this.mIsBusy = false;
4891:               webProgress = this.mCurrentBrowser.webProgress;
4891:               for (i = 0; i < this.mProgressListeners.length; i++) {
4891:                 p = this.mProgressListeners[i];
4891:                 if (p)
4891:                   p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_STOP | nsIWebProgressListener.STATE_IS_NETWORK, 0);
4891:               }
4891:             }
4891: 
4946:             if (document.commandDispatcher.focusedElement &&
4946:                 document.commandDispatcher.focusedElement.parentNode ==
4946:                 this.mCurrentTab.parentNode) {
4946:               // The focus is on a tab in the same tab panel
4946:               return;  // If focus was on a tab, switching tabs focuses the new tab
4925:             }
4925: 
4946:             var whatToFocus = window.content;
4946: 
4925:             // Focus the previously focused element or window
4946:             if (newBrowser.focusedElement) {
4946:               if (newBrowser.focusedElement.parentNode !=
4946:                   this.mCurrentTab.parentNode) {
4946:                 // Focus the remembered element unless it's in the current tab panel
4946:                 whatToFocus = newBrowser.focusedElement;
4946:               }
4946:             }
4946:             else if (newBrowser.focusedWindow) {
4946:               whatToFocus = newBrowser.focusedWindow;
4946:             }
4946: 
4946:             function setFocus(element) {
4943:               document.commandDispatcher.suppressFocusScroll = true;
4986:               element.focus();
4946:               document.commandDispatcher.suppressFocusScroll = false;
4930:             }
4946: 
4949:             // Use setTimeout to avoid focus outline ghosting.
4949:             setTimeout(setFocus, 0, whatToFocus);
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="onTabClick">
4891:         <parameter name="event"/>
4891:         <body>
4891:           <![CDATA[
5013:             if (event.button != 1 || event.target.localName != 'tab')
4891:               return;
4891: 
4891:             this.removeTab(event.target);
4891:             event.stopPropagation();
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="onLinkAdded">
4891:         <parameter name="event"/>
4891:         <body>
4891:           <![CDATA[
5028:             if (!this.mPrefs.getBoolPref("browser.chrome.site_icons"))
4891:               return;
4891: 
5000:             if (!event.originalTarget.rel.match((/(?:^|\s)icon(?:\s|$)/i)))
4891:               return;
4891: 
4891:             // We have an icon.
5000:             var href = event.originalTarget.href;
4891:             if (!href)
4891:               return;
4891: 
4935:             const nsIContentPolicy = Components.interfaces.nsIContentPolicy;
4929:             try {
4929:               var contentPolicy =
4929:                 Components.classes['@mozilla.org/layout/content-policy;1']
4935:                           .getService(nsIContentPolicy);
4929:             } catch(e) {
4891:               return; // Refuse to load if we can't do a security check.
4929:             }
4891: 
4929:             // Verify that the load of this icon is legal.
4929:             // We check first with the security manager
4929:             const secMan =
4929:               Components.classes["@mozilla.org/scriptsecuritymanager;1"]
4929:                         .getService(Components.interfaces.nsIScriptSecurityManager);
4929: 
4929:             // Get the IOService so we can make URIs
4929:             const ioService =
4929:               Components.classes["@mozilla.org/network/io-service;1"]
4929:                         .getService(Components.interfaces.nsIIOService);
4929: 
4986:             const targetDoc = event.target.ownerDocument;
4891:             // Make a URI out of our href.
4986:             var uri = ioService.newURI(href, targetDoc.characterSet, null);
4929: 
4986:             var origURI = ioService.newURI(targetDoc.documentURI, targetDoc.characterSet, null);
4929: 
4929:             const nsIScriptSecMan =
4929:               Components.interfaces.nsIScriptSecurityManager;
4929: 
4929:             try {
4992:               // error pages can load their favicon
4992:               // to be on the safe side, only allow chrome:// favicons
4992:               const aboutNeterr = "about:neterror?";
4992:               if (origURI.spec.substr(0, aboutNeterr.length) != aboutNeterr ||
4992:                   !uri.schemeIs("chrome"))
4969:                 secMan.checkLoadURI(origURI, uri,
4969:                                     nsIScriptSecMan.DISALLOW_SCRIPT);
4929:             } catch(e) {
4929:               return;
4929:             }
4891: 
4929:             // Security says okay, now ask content policy
4935:             if (contentPolicy.shouldLoad(nsIContentPolicy.TYPE_IMAGE,
4929:                                          uri, origURI, event.target,
4986:                                          event.target.type,
4935:                                          null) != nsIContentPolicy.ACCEPT)
4891:               return;
4891: 
5028:             var browserIndex = this.getBrowserIndexForDocument(targetDoc);
4935:             // no browser? no favicon.
4935:             if (browserIndex == -1)
4891:               return;
4891: 
5028:             var tab = this.mTabContainer.childNodes[browserIndex];
5028:             this.setIcon(tab, href);
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="onTitleChanged">
4891:         <parameter name="evt"/>
4891:         <body>
4891:           <![CDATA[
4891:             if (evt.target != this.contentDocument)
4891:               return;
4891: 
4891:             var i = 0;
4943:             for ( ; i < this.parentNode.parentNode.childNodes.length; i++) {
5036:               if (this.parentNode.parentNode.childNodes[i].firstChild == this)
4891:                 break;
4891:             }
4891: 
4943:             var tabBrowser = this.parentNode.parentNode.parentNode.parentNode;
4943: 
4972:             var tab = document.getAnonymousElementByAttribute(tabBrowser, "linkedpanel", this.parentNode.id);
4891:             tabBrowser.setTabTitle(tab);
4891: 
4891:             if (tab == tabBrowser.mCurrentTab)
4891:               tabBrowser.updateTitlebar();
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4998:       <method name="setTabTitleLoading">
4998:         <parameter name="aTab"/>
4998:         <body>
4998:           <![CDATA[
4998:             aTab.label = this.mStringBundle.getString("tabs.loading");
4998:             aTab.setAttribute("crop", "end");
4998:           ]]>
4998:         </body>
4998:       </method>
4998: 
4891:       <method name="setTabTitle">
4891:         <parameter name="aTab"/>
4891:         <body>
4891:           <![CDATA[
4891:             var browser = this.getBrowserForTab(aTab);
4891:             var crop = "end";
4974:             var title = browser.contentDocument.title;
4957: 
4957:             if (!title) {
4957:               if (browser.currentURI.spec) {
4957:                 try {
4957:                   title = this.mURIFixup.createExposableURI(browser.currentURI).spec;
4957:                 } catch(ex) {
4902:                   title = browser.currentURI.spec;
4957:                 }
4957:               }
4957: 
4957:               if (title && title != "about:blank") {
4957:                 // At this point, we now have a URI.
4957:                 // Let's try to unescape it using a character set
4957:                 // in case the URI is not ASCII.
4957:                 try {
4986:                   var characterSet = browser.contentDocument.characterSet;
4957:                   const textToSubURI = Components.classes["@mozilla.org/intl/texttosuburi;1"]
4957:                                                  .getService(Components.interfaces.nsITextToSubURI);
4957:                   title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);
4957:                 } catch(ex) { /* Do nothing. */ }
4957: 
4902:                 crop = "center";
4957: 
4957:               } else // Still no title?  Fall back to our untitled string.
4957:                 title = this.mStringBundle.getString("tabs.untitled");
4900:             }
4891: 
4891:             aTab.label = title;
4891:             aTab.setAttribute("crop", crop);
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="setStripVisibilityTo">
4891:         <parameter name="aShow"/>
4891:         <body>
4891:         <![CDATA[
4891:           this.mStrip.collapsed = !aShow;
4891:           if (aShow) {
4891:             // XXXdwh temporary unclean dependency on specific menu items in navigator.xul
4891:             document.getElementById("menu_closeWindow").hidden = false;
4891:             document.getElementById("menu_close").setAttribute("label", this.mStringBundle.getString("tabs.closeTab"));
4891:             if (!this.mTabbedMode)
4891:               this.enterTabbedMode();
4891:           }
4891:           else {
4891:             // XXXdwh temporary unclean dependency on specific menu items in navigator.xul
4891:             document.getElementById("menu_closeWindow").hidden = true;
4891:             document.getElementById("menu_close").setAttribute("label", this.mStringBundle.getString("tabs.close"));
4891:           }
4891:         ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="getStripVisibility">
4891:         <body>
4891:           return !this.mStrip.collapsed;
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="enterTabbedMode">
4891:         <body>
4891:           <![CDATA[
4891:             this.mTabbedMode = true; // Welcome to multi-tabbed mode.
4891: 
4902:             // Get the first tab all hooked up with a title listener and popup blocking listener.
5040:             this.mCurrentBrowser.addEventListener("DOMTitleChanged", this.onTitleChanged, true);
4891: 
4998:             var throbberElement = document.getElementById("navigator-throbber");
4998:             if (throbberElement && throbberElement.hasAttribute("busy")) {
4998:               this.mCurrentTab.setAttribute("busy", "true");
4998:               this.mIsBusy = true;
4998:               this.setTabTitleLoading(this.mCurrentTab);
4998:               this.updateIcon(this.mCurrentTab);
4998:             } else {
4891:               this.setTabTitle(this.mCurrentTab);
4976:               this.setIcon(this.mCurrentTab, this.mCurrentBrowser.mIconURL);
4998:             }
4891: 
4891:             var filter;
4891:             if (this.mTabFilters.length > 0) {
4891:               // Use the filter hooked up in our addProgressListener
4891:               filter = this.mTabFilters[0];
4891:             } else {
4891:               // create a filter and hook it up to our first browser
4891:               filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
4891:                                  .createInstance(Components.interfaces.nsIWebProgress);
4891:               this.mTabFilters[0] = filter;
4891:               this.mCurrentBrowser.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
4891:             }
4891: 
4891:             // Remove all our progress listeners from the active browser's filter.
4891:             for (var i = 0; i < this.mProgressListeners.length; i++) {
4891:               var p = this.mProgressListeners[i];
4891:               if (p)
4891:                 filter.removeProgressListener(p);
4891:             }
4891: 
4891:             // Wire up a progress listener to our filter.
4945:             const listener = this.mTabProgressListener(this.mCurrentTab,
4945:                                                        this.mCurrentBrowser,
4945:                                                        false);
4891:             filter.addProgressListener(listener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
4891:             this.mTabListeners[0] = listener;
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4990:       <method name="loadOneTab">
4990:         <parameter name="aURI"/>
4990:         <parameter name="aReferrerURI"/>
4990:         <parameter name="aCharset"/>
4990:         <parameter name="aPostData"/>
4990:         <parameter name="aLoadInBackground"/>
5032:         <parameter name="aAllowThirdPartyFixup"/>
4990:         <body>
4990:           <![CDATA[
5070:             var bgLoad = (aLoadInBackground != null) ? aLoadInBackground :
5070:                          this.mPrefs.getBoolPref("browser.tabs.loadInBackground");
5070:             var owner = bgLoad ? null : this.selectedTab;
5032:             var tab = this.addTab(aURI, aReferrerURI, aCharset, aPostData, owner,
5032:                                   aAllowThirdPartyFixup);
4990:             // Set newly selected tab after quick timeout, otherwise hideous focus problems
4990:             // can occur when "browser.tabs.loadInBackground" is false and presshell is not ready
4990:             if (!bgLoad) {
4990:               function selectNewForegroundTab(browser, tab) {
4991:                 browser.selectedTab = tab;
4990:               }
4990:               setTimeout(selectNewForegroundTab, 0, getBrowser(), tab);
4990:             }
5018:             if (!bgLoad)
5018:               this.selectedTab = tab;
5060:             else
5060:               this.mTabContainer._notifyBackgroundTab(tab);
5060:             
4990:             return tab;
4990:          ]]>
4990:         </body>
4990:       </method>
4990: 
5018:       <method name="loadTabs">
5018:         <parameter name="aURIs"/>
5018:         <parameter name="aLoadInBackground"/>
5018:         <parameter name="aReplace"/>
5018:         <body><![CDATA[
5018:           // The tab selected after this new tab is closed (i.e. the new tab's
5018:           // "owner") is the next adjacent tab (i.e. not the previously viewed tab)
5018:           // when several urls are opened here (i.e. closing the first should select
5018:           // the next of many URLs opened) or if the pref to have UI links opened in
5018:           // the background is set (i.e. the link is not being opened modally)
5018:           //
5018:           // i.e.
5018:           //    Number of URLs    Load UI Links in BG       Focus Last Viewed?
5018:           //    == 1              false                     YES
5018:           //    == 1              true                      NO
5018:           //    > 1               false/true                NO
5018:           var owner = (aURIs.length > 1) || aLoadInBackground ? null : gBrowser.selectedTab;
5018:           var firstTabAdded = null;
5018:           if (aReplace)
5018:             this.loadURI(aURIs[0], null, null);
5018:           else
5032:             firstTabAdded = gBrowser.addTab(aURIs[0], null, null, null, owner, false);
5018: 
5068:           var tabNum = this.mTabContainer.selectedIndex;
5068:           for (var i = 1; i < aURIs.length; ++i) {
5068:             var tab = gBrowser.addTab(aURIs[i]);
5068:             if (aReplace)
5068:               this.moveTabTo(tab, ++tabNum);
5068:           }
5068: 
5018:           if (!aLoadInBackground) {
5018:             if (firstTabAdded) {
5018:               // .selectedTab setter focuses the content area
5018:               this.selectedTab = firstTabAdded;
5018:             }
5018:             else
5018:               window.content.focus();
5018:           }
5018:         ]]></body>
5018:       </method>
5018: 
4891:       <method name="addTab">
4891:         <parameter name="aURI"/>
4891:         <parameter name="aReferrerURI"/>
4911:         <parameter name="aCharset"/>
4927:         <parameter name="aPostData"/>
5018:         <parameter name="aOwner"/>
5032:         <parameter name="aAllowThirdPartyFixup"/>
4891:         <body>
4891:           <![CDATA[
5041:             this._browsers = null; // invalidate cache
5041: 
4891:             if (!this.mTabbedMode)
4891:               this.enterTabbedMode();
4891: 
5050:             // if we're adding tabs, we're past interrupt mode, ditch the owner
5050:             if (this.mCurrentTab.owner)
5050:               this.mCurrentTab.owner = null;
5050: 
5060:             var t = document.createElementNS(
5060:               "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
4891:                                              "tab");
4891: 
4945:             var blank = (aURI == "about:blank");
4945: 
4891:             if (blank)
4891:               t.setAttribute("label", this.mStringBundle.getString("tabs.untitled"));
4891:             else
4891:               t.setAttribute("label", aURI);
4891: 
4891:             t.setAttribute("crop", "end");
4891:             t.maxWidth = 250;
5053:             t.minWidth = this.mTabContainer.mTabMinWidth;
4891:             t.width = 0;
4891:             t.setAttribute("flex", "100");
4891:             t.setAttribute("validate", "never");
4891:             t.setAttribute("onerror", "this.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('image')); this.removeAttribute('image');");
5018:             t.className = "tabbrowser-tab";
5050: 
4891:             this.mTabContainer.appendChild(t);
5073: 
5073:             if (document.defaultView
5073:                         .getComputedStyle(this.mTabContainer, "")
5073:                         .direction == "rtl") {
5073:               /* In RTL UI, the tab is visually added to the left side of the
5073:                * tabstrip. This means the tabstip has to be scrolled back in
5073:                * order to make sure the same set of tabs is visible before and
5073:                * after the new tab is added */
5073: 
5073:               this.mTabContainer.mTabstrip.scrollBoxObject
5073:                   .scrollBy(this.mTabContainer.firstChild.boxObject.width, 0);
5073:             }
5073: 
5050:             // invalidate cache, because mTabContainer is about to change
5050:             this._browsers = null; 
5050: 
5018:             // If this new tab is owned by another, assert that relationship
5018:             if (aOwner !== undefined && aOwner !== null) {
5018:               t.owner = aOwner;
5018: 
5018:               var self = this;
5018:               function attrChanged(event) {
5018:                 if (event.attrName == "selectedIndex" &&
5018:                     event.prevValue != event.newValue)
5018:                   self.resetOwner(parseInt(event.prevValue));
5018:               }
5018:               if (!this.mTabChangedListenerAdded) {
5018:                 this.mTabBox.addEventListener("DOMAttrModified", attrChanged, false);
5018:                 this.mTabChangedListenerAdded = true;
5018:               }
5018:             }
4891: 
5060:             var b = document.createElementNS(
5060:               "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
4945:                                              "browser");
5025:             b.setAttribute("type", "content-targetable");
4943:             b.setAttribute("message", "true");
4891:             b.setAttribute("contextmenu", this.getAttribute("contentcontextmenu"));
4891:             b.setAttribute("tooltip", this.getAttribute("contenttooltip"));
5010:             if (this.hasAttribute("autocompletepopup"))
4909:               b.setAttribute("autocompletepopup", this.getAttribute("autocompletepopup"));
4917: 
4943:             // Add the Message and the Browser to the box
5036:             var notificationbox = document.createElementNS(
5036:                                     "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
5036:                                     "notificationbox");
5036:             notificationbox.setAttribute("flex", "1");
5036:             notificationbox.appendChild(b);
4943:             b.setAttribute("flex", "1");
5036:             this.mPanelContainer.appendChild(notificationbox);
4891: 
5040:             b.addEventListener("DOMTitleChanged", this.onTitleChanged, true);
4891: 
4891:             if (this.mStrip.collapsed)
4891:               this.setStripVisibilityTo(true);
4891: 
4891:             this.mPrefs.setBoolPref("browser.tabs.forceHide", false);
4891: 
4891:             // wire up a progress listener for the new browser object.
4891:             var position = this.mTabContainer.childNodes.length-1;
4924:             var tabListener = this.mTabProgressListener(t, b, blank);
4891:             const filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
4891:                                      .createInstance(Components.interfaces.nsIWebProgress);
4891:             filter.addProgressListener(tabListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
4891:             b.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
4891:             this.mTabListeners[position] = tabListener;
4891:             this.mTabFilters[position] = filter;
4891: 
4943:             b._fastFind = this.fastFind;
4943: 
4972:             var uniqueId = "panel" + Date.now() + position;
4972:             this.mPanelContainer.lastChild.id = uniqueId;
4972:             t.linkedPanel = uniqueId;
4972:             t.linkedBrowser = b;
4972:             t._tPos = position;
4972:             if (t.previousSibling.selected)
4972:               t.setAttribute("afterselected", true);
4972: 
4927:             if (!blank) {
4933:               // pretend the user typed this so it'll be available till
4933:               // the document successfully loads
4933:               b.userTypedValue = aURI;
4933: 
4927:               if (aPostData === undefined)
4927:                 aPostData = null;
5032:               const nsIWebNavigation = Components.interfaces.nsIWebNavigation;
5032:               var flags = nsIWebNavigation.LOAD_FLAGS_NONE;
5032:               if (aAllowThirdPartyFixup) {
5032:                 flags = nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
5032:               }
5032:               b.loadURIWithFlags(aURI, flags, aReferrerURI, aCharset, aPostData);
4927:             }
4891: 
5063:             // |setTimeout| here to ensure we're post reflow
5063:             var _delayedUpdate = function(aTabContainer) {
5063:               aTabContainer.adjustTabstrip(false);
5063: 
5063:               // XXXmano: this is a temporary workaround to bug 343585
5063:               // We need to manually update the scroll buttons disabled state
5063:               // if a tab was inserted to the overflow area or removed from it
5063:               // without any scrolling and when the tabbar has already
5063:               // overflowed.
5063:               aTabContainer.mTabstrip._updateScrollButtonsDisabledState();
5063:             }
5063:             setTimeout(_delayedUpdate, 0, this.mTabContainer);
5060: 
5050:             // Dispatch a new tab notification.  We do this once we're
5050:             // entirely done, so that things are in a consistent state
5050:             // even if the event listener opens or closes tabs.
5050:             var evt = document.createEvent("Events");
5050:             evt.initEvent("TabOpen", true, false);
5050:             t.dispatchEvent(evt);
4891:             return t;
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4943:       <method name="warnAboutClosingTabs">
4943:       <parameter name="aAll"/>
4943:       <body>
4943:         <![CDATA[
4943:           var numTabs = this.mTabContainer.childNodes.length;
4943:           var reallyClose = true;
4943:           if (numTabs <= 1)
4943:             return reallyClose;
4943: 
4943:           const pref = "browser.tabs.warnOnClose";
4943:           var shouldPrompt = this.mPrefs.getBoolPref(pref);
4943: 
4943:           if (shouldPrompt) {
4943:             var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
4943:                                           .getService(Components.interfaces.nsIPromptService);
4943: 
4943:             //default to true: if it were false, we wouldn't get this far
4943:             var warnOnClose = { value:true };
4943:             var bundle = this.mStringBundle;
4943:             var tabsToClose = numTabs;  //number of tabs to be removed
4943:             if (!aAll)
4943:               --tabsToClose;
4943: 
4943:             var messageKey = (tabsToClose == 1) ? "tabs.closeWarningOne" : "tabs.closeWarningMultiple";
4943:             var closeKey = (tabsToClose == 1) ? "tabs.closeButtonOne" : "tabs.closeButtonMultiple";
4943:             var buttonPressed = promptService.confirmEx(window,
4943:                                                         bundle.getString('tabs.closeWarningTitle'),
4943:                                                         bundle.getFormattedString(messageKey, [tabsToClose]),
4943:                                                         (promptService.BUTTON_TITLE_IS_STRING * promptService.BUTTON_POS_0)
4943:                                                         + (promptService.BUTTON_TITLE_CANCEL * promptService.BUTTON_POS_1),
4943:                                                         bundle.getString(closeKey),
4943:                                                         null, null,
4943:                                                         bundle.getString('tabs.closeWarningPromptMe'),
4943:                                                         warnOnClose);
4943:             reallyClose = (buttonPressed == 0);
4943:             // don't set the pref unless they press OK and it's false
4943:             if (reallyClose && !warnOnClose.value)
4943:               this.mPrefs.setBoolPref(pref, false);
4943:           }
4943:           return reallyClose;
4943:         ]]>
4943:       </body>
4943:       </method>
4943: 
4912:       <method name="removeAllTabsBut">
4912:         <parameter name="aTab"/>
4912:         <body>
4912:           <![CDATA[
4943:               if (this.warnAboutClosingTabs(false)) {
4912:                 if (aTab.localName != "tab")
4912:                   aTab = this.mCurrentTab;
4912:                 else
4912:                   this.mTabContainer.selectedItem = aTab;
4912: 
4926:                 var childNodes = this.mTabContainer.childNodes;
4943: 
4926:                 for (var i = childNodes.length - 1; i >= 0; --i) {
4926:                   if (childNodes[i] != aTab)
4926:                     this.removeTab(childNodes[i]);
4926:                 }
4943:               }
4943:             }
4912:           ]]>
4912:         </body>
4912:       </method>
4912: 
4891:       <method name="removeCurrentTab">
4891:         <body>
4891:           <![CDATA[
4891:             return this.removeTab(this.mCurrentTab);
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
5018:       <method name="resetOwner">
5018:         <parameter name="oldIndex"/>
5018:         <body>
5018:           <![CDATA[
5018:             // Reset the owner property, since we're leaving the modally opened
5018:             // tab for another.
5018:             if (oldIndex < this.mTabContainer.childNodes.length) {
5018:               var tab = this.mTabContainer.childNodes[oldIndex];
5018:               tab.owner = null;
5018:             }
5018:           ]]>
5018:         </body>
5018:       </method>
5018: 
4891:       <method name="removeTab">
4891:         <parameter name="aTab"/>
4891:         <body>
4891:           <![CDATA[
5041:             this._browsers = null; // invalidate cache
4891:             if (aTab.localName != "tab")
4891:               aTab = this.mCurrentTab;
4891: 
4891:             var l = this.mTabContainer.childNodes.length;
5044:             if (l == 1 && this.mPrefs.getBoolPref("browser.tabs.autoHide")) {
4891:               // hide the tab bar
4891:               this.mPrefs.setBoolPref("browser.tabs.forceHide", true);
4891:               this.setStripVisibilityTo(false);
4891:               return;
4891:             }
4891: 
4926:             var ds = this.getBrowserForTab(aTab).docShell;
4926:             if (ds.contentViewer && !ds.contentViewer.permitUnload())
4926:               return;
4926: 
5063:             // see notes in addTab
5063:             var _delayedUpdate = function(aTabContainer) {
5063:               aTabContainer.adjustTabstrip(true);
5063:               aTabContainer.mTabstrip._updateScrollButtonsDisabledState();
5063:             }
5063:             setTimeout(_delayedUpdate, 0, this.mTabContainer);
5063: 
5044:             if (l == 1) {
5071:               // add a new blank tab to replace the one we're about to close
5044:               // (this ensures that the remaining tab is as good as new)
5044:               this.addTab("about:blank");
5044:               l++;
5044:             }
5044:             else if (l == 2) {
4891:               var autohide = this.mPrefs.getBoolPref("browser.tabs.autoHide");
4981:               var tabStripHide = !window.toolbar.visible;
4981:               if (autohide || tabStripHide)
4891:                 this.setStripVisibilityTo(false);
4891:             }
4891: 
5071:             // We're committed to closing the tab now.  
5071:             // Dispatch a notification.
5071:             // We dispatch it before any teardown so that event listeners can
5071:             // inspect the tab that's about to close.
5071:             var evt = document.createEvent("Events");
5071:             evt.initEvent("TabClose", true, false);
5071:             aTab.dispatchEvent(evt);
5071: 
4891:             var index = -1;
4891:             if (this.mCurrentTab == aTab)
4972:               index = this.mTabContainer.selectedIndex;
4891:             else {
4891:               // Find and locate the tab in our list.
4891:               for (var i = 0; i < l; i++)
4891:                 if (this.mTabContainer.childNodes[i] == aTab)
4891:                   index = i;
4891:             }
4891: 
4891:             // Remove the tab's filter and progress listener.
4891:             const filter = this.mTabFilters[index];
4943:             var oldBrowser = this.getBrowserAtIndex(index);
4891:             oldBrowser.webProgress.removeProgressListener(filter);
4891:             filter.removeProgressListener(this.mTabListeners[index]);
4891:             this.mTabFilters.splice(index, 1);
4891:             this.mTabListeners.splice(index, 1);
4891: 
4902:             // Remove our title change and blocking listeners
5040:             oldBrowser.removeEventListener("DOMTitleChanged", this.onTitleChanged, true);
4891: 
4891:             // We are no longer the primary content area.
5025:             oldBrowser.setAttribute("type", "content-targetable");
4891: 
5019:             // Get the index of the tab we're removing before unselecting it
4972:             var currentIndex = this.mTabContainer.selectedIndex;
4891: 
4891:             var oldTab = aTab;
4891: 
4891:             // clean up the before/afterselected attributes before removing the tab
4891:             oldTab.selected = false;
4891: 
5018:             // Remove this tab as the owner of any other tabs, since it's going away.
5018:             for (i = 0; i < this.mTabContainer.childNodes.length; ++i) {
5019:               var tab = this.mTabContainer.childNodes[i];
5019:               if ("owner" in tab && tab.owner == oldTab)
5020:                 // |tab| is a child of the tab we're removing, make it an orphan
5018:                 tab.owner = null;
5018:             }
5018: 
4958:             // Because of the way XBL works (fields just set JS
4958:             // properties on the element) and the code we have in place
4958:             // to preserve the JS objects for any elements that have
4958:             // JS properties set on them, the browser element won't be
4958:             // destroyed until the document goes away.  So we force a
4958:             // cleanup ourselves.
4960:             // This has to happen before we remove the child so that the
4958:             // XBL implementation of nsIObserver still works.  But
4958:             // clearing focusedWindow happens below because it gets
4958:             // reset by updateCurrentBrowser.
4902:             oldBrowser.destroy();
4902: 
5019:             // Remove the tab
4891:             this.mTabContainer.removeChild(oldTab);
5050:             // invalidate cache, because mTabContainer is about to change
5050:             this._browsers = null; 
4972:             this.mPanelContainer.removeChild(oldBrowser.parentNode);
4891: 
5019:             // Find the tab to select
5019:             var newIndex = -1;
5019:             if (currentIndex > index)
5019:               newIndex = currentIndex-1;
5019:             else if (currentIndex < index)
5019:               newIndex = currentIndex;
5019:             else {
5019:               if ("owner" in oldTab && oldTab.owner &&
5019:                   this.mPrefs.getBoolPref("browser.tabs.selectOwnerOnClose")) {
5019:                 for (i = 0; i < this.mTabContainer.childNodes.length; ++i) {
5019:                   tab = this.mTabContainer.childNodes[i];
5019:                   if (tab == oldTab.owner) {
5019:                     newIndex = i;
5019:                     break;
5019:                   }
5019:                 }
5019:               }
5019:               if (newIndex == -1)
5019:                 newIndex = (index == l - 1) ? index - 1 : index;
5019:             }
5019: 
5019:             // Select the new tab
4891:             this.selectedTab = this.mTabContainer.childNodes[newIndex];
5019: 
4972:             for (i = oldTab._tPos; i < this.mTabContainer.childNodes.length; i++) {
4972:               this.mTabContainer.childNodes[i]._tPos = i;
4972:             }
4972:             this.mTabBox.selectedPanel = this.getBrowserForTab(this.mCurrentTab).parentNode;
4972:             this.mCurrentTab.selected = true;
4891: 
4891:             this.updateCurrentBrowser();
4958: 
4958:             // see comment above destroy above
4958:             oldBrowser.focusedWindow = null;
4959:             oldBrowser.focusedElement = null;
4902:             }
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="reloadAllTabs">
4891:         <body>
4891:           <![CDATA[
4891:             var l = this.mPanelContainer.childNodes.length;
4920:             for (var i = 0; i < l; i++) {
4920:               try {
4943:                 this.getBrowserAtIndex(i).reload();
4920:               } catch (e) {
4920:                 // ignore failure to reload so others will be reloaded
4920:               }
4920:             }
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="reloadTab">
4891:         <parameter name="aTab"/>
4891:         <body>
4891:           <![CDATA[
4920:             if (aTab.localName != "tab")
4920:               aTab = this.mCurrentTab;
4920: 
4920:             this.getBrowserForTab(aTab).reload();
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4936:       <method name="onTabBarDblClick">
4936:         <parameter name="aEvent"/>
4936:         <body>
4936:           <![CDATA[
5059:             // See hack note in the tabbrowser-close-button binding
5059:             if (!this._blockDblClick && aEvent.button == 0 &&
5050:                 aEvent.originalTarget.localName == "box") {
5050:               // xxx this needs to check that we're in the empty area of the tabstrip
4978:               var e = document.createEvent("Events");
5027:               e.initEvent("NewTab", true, true);
4978:               this.dispatchEvent(e);
4978:             }
4936:           ]]>
4936:         </body>
4936:       </method>
4936: 
4891:       <method name="addProgressListener">
4891:         <parameter name="aListener"/>
4891:         <parameter name="aMask"/>
4891:         <body>
4891:           <![CDATA[
4999:             if (!this.mAddProgressListenerWasCalled) {
4999:               this.mAddProgressListenerWasCalled = true;
4999:               var autoHide = this.mPrefs.getBoolPref("browser.tabs.autoHide");
4999:               var forceHide = this.mPrefs.getBoolPref("browser.tabs.forceHide");
4999:               var tabStripHide = !window.toolbar.visible;
4999:               if (!autoHide && !forceHide && !tabStripHide)
4999:                 this.setStripVisibilityTo(true);
4999:             }
4999: 
4928:             if (!this.mTabbedMode && this.mProgressListeners.length == 1) {
4928:               // If we are adding a 2nd progress listener, we need to enter tabbed mode
4928:               // because the browser status filter can only handle one progress listener.
4928:               // In tabbed mode, mTabProgressListener is used which will iterate over all listeners.
4928:               this.enterTabbedMode();
4928:             }
4928: 
4891:             this.mProgressListeners.push(aListener);
4891: 
4891:             if (!this.mTabbedMode) {
4928:               // If someone does this:
4928:               // addProgressListener, removeProgressListener, addProgressListener
4928:               // don't create a new filter; reuse the existing filter.
4928:               if (this.mTabFilters.length == 0) {
4891:                 // hook a filter up to our first browser
4891:                 const filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
4891:                                          .createInstance(Components.interfaces.nsIWebProgress);
4891:                 this.mTabFilters[0] = filter;
4891:                 this.mCurrentBrowser.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
4928:               }
4891: 
4891:               // Directly hook the listener up to the filter for better performance
4891:               this.mTabFilters[0].addProgressListener(aListener, aMask);
4891:             }
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="removeProgressListener">
4891:         <parameter name="aListener"/>
4891:         <body>
4891:           <![CDATA[
4891:             for (var i = 0; i < this.mProgressListeners.length; i++) {
4891:               if (this.mProgressListeners[i] == aListener) {
4988:                 this.mProgressListeners.splice(i, 1);
4891:                 break;
4891:               }
4891:             }
4891: 
4891:             if (!this.mTabbedMode)
4891:               // Don't forget to remove it from the filter we hooked it up to
4891:               this.mTabFilters[0].removeProgressListener(aListener);
4891:          ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="getBrowserForTab">
4891:         <parameter name="aTab"/>
4891:         <body>
4891:         <![CDATA[
4972:           return aTab.linkedBrowser;
4891:         ]]>
4891:         </body>
4891:       </method>
4891: 
4926:       <property name="tabContainer">
4926:         <getter>
4926:           return this.mTabContainer;
4926:         </getter>
4926:       </property>
4926: 
4891:       <property name="selectedTab">
4891:         <getter>
4891:           return this.mTabBox.selectedTab;
4891:         </getter>
4891:         <setter>
4891:           <![CDATA[
4989:           // Update the tab
4989:           this.mTabBox.selectedTab = val;
4891:           return val;
4891:           ]]>
4891:         </setter>
4891:       </property>
4891: 
4891:       <property name="selectedBrowser"
4891:                 onget="return this.mCurrentBrowser;"
4891:                 readonly="true"/>
4891: 
4972:       <property name="browsers" readonly="true">
4972:        <getter>
4972:           <![CDATA[
5041:             if (!this._browsers) {
4972:               var browsers = [];
4972:               var i;
4972:               browsers.item = function(i) {return this[i];}
4972:               for (i = 0; i < this.mTabContainer.childNodes.length; i++)
4972:                 browsers.push(this.mTabContainer.childNodes[i].linkedBrowser);
5041:               this._browsers = browsers;
5041:             }
5041:             return this._browsers;
4972:           ]]>
4972:         </getter>
4972:       </property>
4891: 
4891:       <!-- Drag and drop observer API -->
4972:       <method name="onDragStart">
4891:         <parameter name="aEvent"/>
4891:         <parameter name="aXferData"/>
4891:         <parameter name="aDragAction"/>
4972:         <body>
4972:         <![CDATA[
5018:           if (aEvent.target.localName == "tab" &&
5018:               aEvent.originalTarget.localName != "toolbarbutton") {
4972:             aXferData.data = new TransferData();
4972: 
4972:             var URI = this.getBrowserForTab(aEvent.target).currentURI;
4972:             if (URI) {
5035:               aXferData.data.addDataForFlavour("text/x-moz-url", URI.spec + "\n" + aEvent.target.label);
4972:               aXferData.data.addDataForFlavour("text/unicode", URI.spec);
4972:               aXferData.data.addDataForFlavour("text/html", '<a href="' + URI.spec + '">' + aEvent.target.label + '</a>');
5004:             } else {
5004:               aXferData.data.addDataForFlavour("text/unicode", "about:blank");
4972:             }
4972:           }
4972:         ]]>
4972:         </body>
4972:       </method>
4891: 
5064:       <method name="canDrop">
5064:         <parameter name="aEvent"/>
5064:         <parameter name="aDragSession"/>
5064:         <body>
5064:           <![CDATA[
5064:             if (aDragSession.sourceNode.parentNode == this.mTabContainer &&
5064:                 (aEvent.screenX >= aDragSession.sourceNode.boxObject.screenX &&
5064:                  aEvent.screenX <= (aDragSession.sourceNode.boxObject.screenX +
5064:                                     aDragSession.sourceNode.boxObject.width)))
5064:                 return false;
5064:             return true;
5064:           ]]>
5064:         </body>
5064:       </method>
5064: 
4891:       <method name="onDragOver">
4891:         <parameter name="aEvent"/>
4891:         <parameter name="aFlavour"/>
4891:         <parameter name="aDragSession"/>
4891:         <body>
4891:           <![CDATA[
5064:             if (aDragSession.sourceNode) {
5064:               if (!aDragSession.canDrop) {
5064:                 this.mTabDropIndicatorBar.setAttribute('dragging','false');
5064:                 return;
5064:               }
5064: 
5055:               var tabStrip = this.mTabContainer.mTabstrip;
5055: 
5055:               // autoscroll the tab strip if we drag over the scroll
5050:               // buttons, even if we aren't dragging a tab, but then
5050:               // return to avoid drawing the drop indicator
5050:               var pixelsToScroll = 0;
5055: 
5055:               var targetAnonid = aEvent.originalTarget.getAttribute("anonid");
5055:               if (targetAnonid == "scrollbutton-up") {
5050:                 pixelsToScroll = tabStrip.scrollIncrement * -1;
5055:                 tabStrip.scrollByPixels(pixelsToScroll);
5055:               }
5055:               else if (targetAnonid == "scrollbutton-down") {
5050:                 pixelsToScroll = tabStrip.scrollIncrement;
5050:                 tabStrip.scrollByPixels(pixelsToScroll);
5050:               }
5050: 
5055:               var isTabDrag = (aDragSession.sourceNode.parentNode == this.mTabContainer);
5050:               if (!isTabDrag)
5050:                 return;
5050: 
4972:               var newIndex = this.getNewIndex(aEvent);
4972: 
5002:               var ib = this.mTabDropIndicatorBar;
5002:               var ind = ib.firstChild;
4972:               ib.setAttribute('dragging','true');
4972: 
5050:               var tabStripBoxObject = tabStrip.scrollBoxObject;
5050:               var halfIndWidth = Math.floor((ind.boxObject.width + 1) / 2);
5050:               if (window.getComputedStyle(this.parentNode, null)
5050:                         .direction == "ltr") {
5050:                 var newMarginLeft;
5057:                 var minMarginLeft = tabStripBoxObject.x - halfIndWidth -
5057:                                     ib.boxObject.x;
5050:                 // make sure we don't place the tab drop indicator past the
5050:                 // edge, or the containing box will flex and stretch
5050:                 // the tab drop indicator bar, which will flex the url bar.  
5050:                 // XXX todo
5050:                 // just use first value if you can figure out how to get
5050:                 // the tab drop indicator to crop instead of flex and stretch
5050:                 // the tab drop indicator bar.
5050:                 var maxMarginLeft = Math.min(
5050:                   (minMarginLeft + tabStripBoxObject.width), 
5050:                   (ib.boxObject.x + ib.boxObject.width - ind.boxObject.width));
5050: 
5050:                 // if we are scrolling, put the drop indicator at the edge
5050:                 // so that it doesn't jump while scrolling
5050:                 if (pixelsToScroll > 0)
5050:                   newMarginLeft = maxMarginLeft;
5050:                 else if (pixelsToScroll < 0)
5050:                   newMarginLeft = minMarginLeft;
5050:                 else {
4972:                 if (newIndex == this.mTabs.length) {
5050:                     newMarginLeft = this.mTabs[newIndex-1].boxObject.screenX +
5050:                                     this.mTabs[newIndex-1].boxObject.width - 
5050:                                     this.boxObject.screenX - halfIndWidth;
4972:                 } else {
5050:                     newMarginLeft = this.mTabs[newIndex].boxObject.screenX - 
5050:                                     this.boxObject.screenX - halfIndWidth;
4972:                 }
5050: 
5050:                   // ensure we never place the drop indicator beyond
5050:                   // our limits
5050:                   if (newMarginLeft < minMarginLeft)
5050:                     newMarginLeft = minMarginLeft;
5050:                   else if (newMarginLeft > maxMarginLeft)
5050:                     newMarginLeft = maxMarginLeft;
5050:                 }
5050:                 ind.style.marginLeft = newMarginLeft + 'px';
4972:               } else {
5050:                 var newMarginRight;
5057:                 var minMarginRight = tabStripBoxObject.x - halfIndWidth -
5057:                                      ib.boxObject.x;
5050:                 // make sure we don't place the tab drop indicator past the
5050:                 // edge, or the containing box will flex and stretch
5050:                 // the tab drop indicator bar, which will flex the url bar.  
5050:                 // XXX todo
5050:                 // just use first value if you can figure out how to get
5050:                 // the tab drop indicator to crop instead of flex and stretch
5050:                 // the tab drop indicator bar.
5050:                 var maxMarginRight = Math.min(
5050:                   (minMarginRight + tabStripBoxObject.width), 
5050:                   (ib.boxObject.x + ib.boxObject.width - ind.boxObject.width));
5050: 
5050:                 // if we are scrolling, put the drop indicator at the edge
5050:                 // so that it doesn't jump while scrolling
5050:                 if (pixelsToScroll > 0)
5050:                   newMarginRight = maxMarginRight;
5050:                 else if (pixelsToScroll < 0)
5050:                   newMarginRight = minMarginRight;
5050:                 else {
5011:                 if (newIndex == this.mTabs.length) {
5050:                     newMarginRight = this.boxObject.width + 
5050:                                      this.boxObject.screenX -
5050:                                      this.mTabs[newIndex-1].boxObject.screenX -
5050:                                      halfIndWidth;
4972:                 } else {
5050:                     newMarginRight = this.boxObject.width + 
5050:                                      this.boxObject.screenX -
5050:                                      this.mTabs[newIndex].boxObject.screenX -
5050:                                      this.mTabs[newIndex].boxObject.width -
5050:                                      halfIndWidth;
4972:                   }
5050: 
5050:                   // ensure we never place the drop indicator beyond
5050:                   // our limits
5050:                   if (newMarginRight < minMarginRight)
5050:                     newMarginRight = minMarginRight;
5050:                   else if (newMarginRight > maxMarginRight)
5050:                     newMarginRight = maxMarginRight;
5050:                 }
5050:                 ind.style.marginRight = newMarginRight + 'px';
4972:               }
4972:             }
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="onDrop">
4891:         <parameter name="aEvent"/>
4891:         <parameter name="aXferData"/>
4891:         <parameter name="aDragSession"/>
4891:         <body>
4891:           <![CDATA[
4975:             if (aDragSession.sourceNode && aDragSession.sourceNode.parentNode == this.mTabContainer) {
4972:               var newIndex = this.getNewIndex(aEvent);
5004:               var oldIndex = aDragSession.sourceNode._tPos;
5004: 
5004:               if (newIndex > oldIndex)
4972:                 newIndex--;
5004:               if (newIndex != oldIndex)
5004:                 this.moveTabTo(this.mTabs[oldIndex], newIndex);
4972:             } else {
4891:               var url = transferUtils.retrieveURLFromData(aXferData.data, aXferData.flavour.contentType);
4891: 
4956:               // valid urls don't contain spaces ' '; if we have a space it isn't a valid url.
4956:               // Also disallow dropping javascript: or data: urls--bail out
4956:               if (!url || !url.length || url.indexOf(" ", 0) != -1 ||
4956:                   /^\s*(javascript|data):/.test(url))
4891:                 return;
4891: 
4964:               this.dragDropSecurityCheck(aEvent, aDragSession, url);
4964: 
5003:               var bgLoad = true;
5003:               try {
5003:                 bgLoad = this.mPrefs.getBoolPref("browser.tabs.loadInBackground");
5003:               }
5003:               catch (e) { }
5003: 
5003:               if (aEvent.shiftKey)
5003:                 bgLoad = !bgLoad;
5003: 
5024:               if (document.getBindingParent(aEvent.originalTarget).localName != "tab") {
5007:                 // We're adding a new tab.
5032:                 this.loadOneTab(getShortcutOrURI(url), null, null, null, bgLoad, false);
4920:               }
4920:               else {
4920:                 // Load in an existing tab.
5018:                 var tab = aEvent.target;
5047:                 try {
4920:                   this.getBrowserForTab(tab).loadURI(getShortcutOrURI(url));
5007:                   if (this.mCurrentTab != tab && !bgLoad)
5007:                     this.selectedTab = tab;
5047:                 } catch(ex) {
5047:                   // Just ignore invalid urls
5047:                 }
4920:               }
4972:             }
4972:           ]]>
4972:         </body>
4972:       </method>
4972: 
4972:       <method name="onDragExit">
4972:         <parameter name="aEvent"/>
4972:         <parameter name="aDragSession"/>
4972:         <body>
4972:           <![CDATA[
5064:             if (aDragSession.sourceNode &&
5064:                 aDragSession.sourceNode.parentNode == this.mTabContainer &&
5064:                 aDragSession.canDrop) {
5064:               var target = aEvent.relatedTarget;
5064:               while (target && target != this.mStrip)
5064:                 target = target.parentNode;
5064:               if (target)
5064:                 return;
5064:             }
5002:             this.mTabDropIndicatorBar.setAttribute('dragging','false');
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="getSupportedFlavours">
4891:         <body>
4891:         <![CDATA[
4891:           var flavourSet = new FlavourSet();
4891:           flavourSet.appendFlavour("text/x-moz-url");
4891:           flavourSet.appendFlavour("text/unicode");
4891:           flavourSet.appendFlavour("application/x-moz-file", "nsIFile");
4891:           return flavourSet;
4891:         ]]>
4891:         </body>
4891:       </method>
4891: 
4972:       <method name="moveTabTo">
4972:         <parameter name="aTab"/>
4972:         <parameter name="aIndex"/>
4972:         <body>
4972:         <![CDATA[
5041:           this._browsers = null; // invalidate cache
4972:           this.mTabFilters.splice(aIndex, 0, this.mTabFilters.splice(aTab._tPos, 1)[0]);
4972:           this.mTabListeners.splice(aIndex, 0, this.mTabListeners.splice(aTab._tPos, 1)[0]);
4972: 
5050:           var oldPosition = aTab._tPos;
5050: 
4972:           aIndex = aIndex < aTab._tPos ? aIndex: aIndex+1;
4972:           this.mCurrentTab.selected = false;
4972:           this.mTabContainer.insertBefore(aTab, this.mTabContainer.childNodes[aIndex]);
5050:           // invalidate cache, because mTabContainer is about to change
5050:           this._browsers = null;
5006: 
4972:           var i;
4972:           for (i = 0; i < this.mTabContainer.childNodes.length; i++) {
4972:             this.mTabContainer.childNodes[i]._tPos = i;
4972:           }
4972:           this.mCurrentTab.selected = true;
5056:           this.mTabContainer.mTabstrip.scrollBoxObject.ensureElementIsVisible(this.mCurrentTab);
5050: 
5050:           var evt = document.createEvent("UIEvents");
5050:           evt.initUIEvent("TabMove", true, false, window, oldPosition);
5050:           aTab.dispatchEvent(evt);
5050: 
4972:           return aTab;
4972:         ]]>
4972:         </body>
4972:       </method>
4972: 
4972:       <method name="getNewIndex">
4972:         <parameter name="aEvent"/>
4972:         <body>
4972:           <![CDATA[
4972:             var i;
4972:             if (window.getComputedStyle(this.parentNode, null).direction == "ltr") {
4972:               for (i = aEvent.target.localName == "tab" ? aEvent.target._tPos : 0; i < this.mTabs.length; i++)
5050:                 if (aEvent.screenX < this.mTabs[i].boxObject.screenX + this.mTabs[i].boxObject.width / 2) 
4972:                   return i;
4972:             } else {
4972:                for (i = aEvent.target.localName == "tab" ? aEvent.target._tPos : 0; i < this.mTabs.length; i++)
5050:                 if (aEvent.screenX > this.mTabs[i].boxObject.screenX + this.mTabs[i].boxObject.width / 2)
4972:                   return i;
4972:             }
4972: 
4972:             return this.mTabs.length;
4972:           ]]>
4972:         </body>
4972:       </method>
4972: 
4972: 
4972:       <method name="moveTabForward">
4972:         <body>
4972:           <![CDATA[
4972:             var tabPos = this.mCurrentTab._tPos;
4972:             if (tabPos < this.browsers.length - 1) {
4972:               this.moveTabTo(this.mCurrentTab, tabPos + 1);
4972:               this.mCurrentTab.focus();
4972:             }
4972:             else if (this.arrowKeysShouldWrap)
4972:               this.moveTabToStart();
4972:           ]]>
4972:         </body>
4972:       </method>
4972: 
4972:       <method name="moveTabBackward">
4972:         <body>
4972:           <![CDATA[
4972:             var tabPos = this.mCurrentTab._tPos;
4972:             if (tabPos > 0) {
4972:               this.moveTabTo(this.mCurrentTab, tabPos - 1);
4972:               this.mCurrentTab.focus();
4972:             }
4972:             else if (this.arrowKeysShouldWrap)
4972:               this.moveTabToEnd();
4972:           ]]>
4972:         </body>
4972:       </method>
4972: 
4972:       <method name="moveTabToStart">
4972:         <body>
4972:           <![CDATA[
4972:             var tabPos = this.mCurrentTab._tPos;
4972:             if (tabPos > 0) {
4972:               this.moveTabTo(this.mCurrentTab, 0);
4972:               this.mCurrentTab.focus();
4972:             }
4972:           ]]>
4972:         </body>
4972:       </method>
4972: 
4972:       <method name="moveTabToEnd">
4972:         <body>
4972:           <![CDATA[
4972:             var tabPos = this.mCurrentTab._tPos;
4972:             if (tabPos < this.browsers.length - 1) {
4972:               this.moveTabTo(this.mCurrentTab,
4972:                                         this.browsers.length - 1);
4972:               this.mCurrentTab.focus();
4972:             }
4972:           ]]>
4972:         </body>
4972:       </method>
4972: 
4972:       <method name="moveTabOver">
4972:         <parameter name="aEvent"/>
4972:         <body>
4972:           <![CDATA[
4972:             var direction = window.getComputedStyle(this.parentNode, null).direction;
4972:             if ((direction == "ltr" && aEvent.keyCode == KeyEvent.DOM_VK_RIGHT) ||
4972:                 (direction == "rtl" && aEvent.keyCode == KeyEvent.DOM_VK_LEFT))
4972:               this.moveTabForward();
4972:             else
4972:               this.moveTabBackward();
4972:           ]]>
4972:         </body>
4972:       </method>
4972: 
4891:       <!-- BEGIN FORWARDED BROWSER PROPERTIES.  IF YOU ADD A PROPERTY TO THE BROWSER ELEMENT
4891:            MAKE SURE TO ADD IT HERE AS WELL. -->
4891:       <property name="canGoBack"
4891:                 onget="return this.mCurrentBrowser.canGoBack;"
4891:                 readonly="true"/>
4891: 
4891:       <property name="canGoForward"
4891:                 onget="return this.mCurrentBrowser.canGoForward;"
4891:                 readonly="true"/>
4891: 
4891:       <method name="goBack">
4891:         <body>
4891:           <![CDATA[
4891:             return this.mCurrentBrowser.goBack();
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="goForward">
4891:         <body>
4891:           <![CDATA[
4891:             return this.mCurrentBrowser.goForward();
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="reload">
4891:         <body>
4891:           <![CDATA[
4891:             return this.mCurrentBrowser.reload();
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="reloadWithFlags">
4891:         <parameter name="aFlags"/>
4891:         <body>
4891:           <![CDATA[
4891:             return this.mCurrentBrowser.reloadWithFlags(aFlags);
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="stop">
4891:         <body>
4891:           <![CDATA[
4891:             return this.mCurrentBrowser.stop();
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <!-- throws exception for unknown schemes -->
4891:       <method name="loadURI">
4891:         <parameter name="aURI"/>
4891:         <parameter name="aReferrerURI"/>
4911:         <parameter name="aCharset"/>
4891:         <body>
4891:           <![CDATA[
4911:             return this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <!-- throws exception for unknown schemes -->
4891:       <method name="loadURIWithFlags">
4891:         <parameter name="aURI"/>
4891:         <parameter name="aFlags"/>
4891:         <parameter name="aReferrerURI"/>
4911:         <parameter name="aCharset"/>
4891:         <body>
4891:           <![CDATA[
4911:             return this.mCurrentBrowser.loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset);
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <method name="goHome">
4891:         <body>
4891:           <![CDATA[
4891:             return this.mCurrentBrowser.goHome();
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4891:       <property name="homePage">
4891:         <getter>
4891:           <![CDATA[
4891:             return this.mCurrentBrowser.homePage;
4891:           ]]>
4891:         </getter>
4891:         <setter>
4891:           <![CDATA[
4891:             this.mCurrentBrowser.homePage = val;
4891:             return val;
4891:           ]]>
4891:         </setter>
4891:       </property>
4891: 
4891:       <method name="gotoIndex">
4891:         <parameter name="aIndex"/>
4891:         <body>
4891:           <![CDATA[
4891:             return this.mCurrentBrowser.gotoIndex(aIndex);
4891:           ]]>
4891:         </body>
4891:       </method>
4891: 
4908:       <method name="attachFormFill">
4908:         <body><![CDATA[
4943:           for (var i = 0; i < this.mPanelContainer.childNodes.length; ++i) {
4943:             var cb = this.getBrowserAtIndex(i);
4917:             cb.attachFormFill();
4917:           }
4908:         ]]></body>
4908:       </method>
4908: 
4908:       <method name="detachFormFill">
4908:         <body><![CDATA[
4943:           for (var i = 0; i < this.mPanelContainer.childNodes.length; ++i) {
4943:             var cb = this.getBrowserAtIndex(i);
4917:             cb.detachFormFill();
4917:           }
4908:         ]]></body>
4908:       </method>
4908: 
4902:       <property name="pageReport"
4902:                 onget="return this.mCurrentBrowser.pageReport;"
4902:                 readonly="true"/>
4902: 
4891:       <property name="currentURI"
4891:                 onget="return this.mCurrentBrowser.currentURI;"
4891:                 readonly="true"/>
4891: 
4943:       <field name="_fastFind">null</field>
4943:       <property name="fastFind"
4943:                 readonly="true">
4943:         <getter>
4943:         <![CDATA[
4943:           if (!this._fastFind) {
4943:             this._fastFind = Components.classes["@mozilla.org/typeaheadfind;1"]
4943:                                        .createInstance(Components.interfaces.nsITypeAheadFind);
4943:             this._fastFind.init(this.docShell);
4943:           }
4943:           return this._fastFind;
4943:         ]]>
4943:         </getter>
4943:       </property>
4943: 
4943:       <property name="findString"
4943:                 onget="return this.mCurrentBrowser.findString;"
4943:                 readonly="true"/>
4943: 
4891:       <property name="docShell"
4891:                 onget="return this.mCurrentBrowser.docShell"
4891:                 readonly="true"/>
4891: 
4891:       <property name="webNavigation"
4891:                 onget="return this.mCurrentBrowser.webNavigation"
4891:                 readonly="true"/>
4891: 
4891:       <property name="webBrowserFind"
4891:                 readonly="true"
4891:                 onget="return this.mCurrentBrowser.webBrowserFind"/>
4891: 
4891:       <property name="webProgress"
4891:                 readonly="true"
4891:                 onget="return this.mCurrentBrowser.webProgress"/>
4891: 
4891:       <property name="contentWindow"
4891:                 readonly="true"
4891:                 onget="return this.mCurrentBrowser.contentWindow"/>
4891: 
4891:       <property name="sessionHistory"
4891:                 onget="return this.mCurrentBrowser.sessionHistory;"
4891:                 readonly="true"/>
4891: 
4891:       <property name="markupDocumentViewer"
4891:                 onget="return this.mCurrentBrowser.markupDocumentViewer;"
4891:                 readonly="true"/>
4891: 
4891:       <property name="contentViewerEdit"
4891:                 onget="return this.mCurrentBrowser.contentViewerEdit;"
4891:                 readonly="true"/>
4891: 
4891:       <property name="contentViewerFile"
4891:                 onget="return this.mCurrentBrowser.contentViewerFile;"
4891:                 readonly="true"/>
4891: 
4891:       <property name="documentCharsetInfo"
4891:                 onget="return this.mCurrentBrowser.documentCharsetInfo;"
4891:                 readonly="true"/>
4891: 
4891:       <property name="contentDocument"
4891:                 onget="return this.mCurrentBrowser.contentDocument;"
4891:                 readonly="true"/>
4891: 
4937:       <property name="contentTitle"
4937:                 onget="return this.mCurrentBrowser.contentTitle;"
4937:                 readonly="true"/>
4937: 
4891:       <property name="securityUI"
4891:                 onget="return this.mCurrentBrowser.securityUI;"
4891:                 readonly="true"/>
4891: 
4923:       <method name="find">
4923:         <body>
4923:           <![CDATA[
4923:             return this.mCurrentBrowser.find();
4923:           ]]>
4923:         </body>
4923:       </method>
4923: 
4923:       <method name="findAgain">
4923:         <body>
4923:           <![CDATA[
4923:             return this.mCurrentBrowser.findAgain();
4923:           ]]>
4923:         </body>
4923:       </method>
4923: 
4923:       <method name="findPrevious">
4923:         <body>
4923:           <![CDATA[
4923:             return this.mCurrentBrowser.findPrevious();
4923:           ]]>
4923:         </body>
4923:       </method>
4964: 
4964:       <method name="dragDropSecurityCheck">
4964:         <parameter name="aEvent"/>
4964:         <parameter name="aDragSession"/>
4984:         <parameter name="aUri"/>
4964:         <body>
4964:           <![CDATA[
4964:             // Do a security check for drag n' drop. Make sure the
4964:             // source document can load the dragged link.
4964:             var sourceDoc = aDragSession.sourceDocument;
4964: 
4964:             if (sourceDoc) {
4984:               // Strip leading and trailing whitespace, then try to
4984:               // create a URI from the dropped string. If that
4984:               // succeeds, we're dropping a URI and we need to do a
4984:               // security check to make sure the source document can
4984:               // load the dropped URI. We don't so much care about
4984:               // creating the real URI here (i.e. encoding differences
4984:               // etc don't matter), we just want to know if aUri
4984:               // really is a URI.
4984: 
4984:               var uriStr = aUri.replace(/^\s*|\s*$/g, '');
4984:               var uri = null;
4984: 
4984:               try {
4984:                 uri = Components.classes["@mozilla.org/network/io-service;1"]
4984:                   .getService(Components.interfaces.nsIIOService)
4984:                   .newURI(uriStr, null, null);
4984:               } catch (e) {
4984:               }
4984: 
4984:               if (uri) {
4984:                 // aUri is a URI, do the security check.
4964:                 var sourceURI = sourceDoc.documentURI;
4964: 
4964:                 const nsIScriptSecurityManager =
4964:                   Components.interfaces.nsIScriptSecurityManager;
4964:                 var secMan =
4964:                   Components.classes["@mozilla.org/scriptsecuritymanager;1"]
4964:                   .getService(nsIScriptSecurityManager);
4964: 
4964:                 try {
4984:                   secMan.checkLoadURIStr(sourceURI, uriStr,
4964:                                          nsIScriptSecurityManager.STANDARD);
4964:                 } catch (e) {
4965:                   // Stop event propagation right here.
4964:                   aEvent.stopPropagation();
4964: 
4984:                   throw "Drop of " + aUri + " denied.";
4984:                 }
4964:               }
4964:             }
4964:           ]]>
4964:         </body>
4964:       </method>
4964: 
4943:       <field name="_keyEventHandler" readonly="true">
4943:       <![CDATA[({
4943:         tabbrowser: this,
4943:         handleEvent: function handleEvent(aEvent) {
4943:           if (!aEvent.isTrusted) {
4943:             // Don't let untrusted events mess with tabs.
4943:             return;
4943:           }
4943: 
4979:           if (('shiftKey' in aEvent && aEvent.shiftKey) ||
4979:               ('altKey' in aEvent && aEvent.altKey))
4979:             return;
4972: #ifdef XP_MACOSX
4972:           if ('metaKey' in aEvent && aEvent.metaKey) {
4972: #else
4979:           if (('ctrlKey' in aEvent && aEvent.ctrlKey) &&
4979:               !('metaKey' in aEvent && aEvent.metaKey)) {
4972:             if (aEvent.keyCode == KeyEvent.DOM_VK_F4 &&
4972:                 this.tabbrowser.mTabBox.handleCtrlPageUpDown) {
4943:               this.tabbrowser.removeCurrentTab();
5034: 
5034:               aEvent.stopPropagation();
5034:               aEvent.preventDefault();
4972:               return;
4972:             }
4950: #endif
4972:             if (aEvent.target.localName == "tabbrowser") {
4972:               switch (aEvent.keyCode) {
4972:                 case KeyEvent.DOM_VK_UP:
4972:                   this.tabbrowser.moveTabBackward();
4972:                   break;
4972:                 case KeyEvent.DOM_VK_DOWN:
4972:                   this.tabbrowser.moveTabForward();
4972:                   break;
4972:                 case KeyEvent.DOM_VK_RIGHT:
4972:                 case KeyEvent.DOM_VK_LEFT:
4972:                   this.tabbrowser.moveTabOver(aEvent);
4972:                   break;
4972:                 case KeyEvent.DOM_VK_HOME:
4972:                   this.tabbrowser.moveTabToStart();
4972:                   break;
4972:                 case KeyEvent.DOM_VK_END:
4972:                   this.tabbrowser.moveTabToEnd();
4972:                   break;
4972:                 default:
4979:                   // Stop the keypress event for the above keyboard
4979:                   // shortcuts only.
4979:                   return;
4972:               }
4979:               aEvent.stopPropagation();
4979:               aEvent.preventDefault();
4972:             }
4972:           }
4943:         }
4943:       })]]>
4943:       </field>
4923: 
4933:       <property name="userTypedClear"
4933:                 onget="return this.mCurrentBrowser.userTypedClear;"
4933:                 onset="return this.mCurrentBrowser.userTypedClear = val;"/>
4933: 
4924:       <property name="userTypedValue"
4924:                 onget="return this.mCurrentBrowser.userTypedValue;"
4924:                 onset="return this.mCurrentBrowser.userTypedValue = val;"/>
4924: 
4942:       <property name="forceSyncURLBarUpdate"
4942:                 onget="return this.mModalDialogShowing;"/>
4942: 
5018:       <method name="createTooltip">
5018:         <parameter name="event"/>
5018:         <body>
5018:           <![CDATA[
5031:             event.stopPropagation();
5018:             var tn = document.tooltipNode;
5018:             if (tn.localName != "tab")
5018:               return false; // Not a tab, so cancel the tooltip
5018:             if ("mOverCloseButton" in tn && tn.mOverCloseButton) {
5018:               event.target.setAttribute("label", tn.getAttribute("closetabtext"));
5018:               return true;
5018:             }
5018:             if (tn.hasAttribute("label")) {
5018:               event.target.setAttribute("label", tn.getAttribute("label"));
5018:               return true;
5018:             }
5018:             return false;
5018:           ]]>
5018:         </body>
5018:       </method>
5018: 
4891:       <constructor>
4891:         <![CDATA[
5036:           this.mCurrentBrowser = this.mPanelContainer.childNodes[0].firstChild;
4891:           this.mCurrentTab = this.mTabContainer.firstChild;
4943:           document.addEventListener("keypress", this._keyEventHandler, false);
4972: 
4972:           var uniqueId = "panel" + Date.now();
4972:           this.mPanelContainer.childNodes[0].id = uniqueId;
4972:           this.mTabContainer.childNodes[0].linkedPanel = uniqueId;
4972:           this.mTabContainer.childNodes[0]._tPos = 0;
5036:           this.mTabContainer.childNodes[0].linkedBrowser = this.mPanelContainer.childNodes[0].firstChild;
4891:         ]]>
4891:       </constructor>
4891: 
4891:       <destructor>
4891:         <![CDATA[
4891:           for (var i = 0; i < this.mTabListeners.length; ++i) {
4943:             this.getBrowserAtIndex(i).webProgress.removeProgressListener(this.mTabFilters[i]);
4891:             this.mTabFilters[i].removeProgressListener(this.mTabListeners[i]);
4891:             this.mTabFilters[i] = null;
4891:             this.mTabListeners[i] = null;
5040:             this.getBrowserAtIndex(i).removeEventListener("DOMTitleChanged", this.onTitleChanged, true);
4891:           }
4943:           document.removeEventListener("keypress", this._keyEventHandler, false);
4891:         ]]>
4891:       </destructor>
4891:     </implementation>
4891: 
4891:     <handlers>
5040:       <handler event="DOMLinkAdded" phase="capturing" action="this.onLinkAdded(event);"/>
5028: 
5040:       <handler event="DOMWindowClose" phase="capturing">
4891:         <![CDATA[
4941:           if (!event.isTrusted)
4941:             return;
4941: 
4943:           const browsers = this.mPanelContainer.childNodes;
4943:           if (browsers.length == 1) {
4943:             // There's only one browser left. If a window is being
4943:             // closed and the window is *not* the window in the
4943:             // browser that's still around, prevent the event's default
4943:             // action to prevent closing a window that's being closed
4943:             // already.
4943:             if (this.getBrowserAtIndex(0).contentWindow != event.target)
4943:               event.preventDefault();
4943: 
4891:             return;
4943:           }
4943: 
4891:           var i = 0;
4891:           for (; i < browsers.length; ++i) {
4943:             if (this.getBrowserAtIndex(i).contentWindow == event.target) {
4943:               this.removeTab(this.mTabContainer.childNodes[i]);
4943:               event.preventDefault();
4943: 
4891:               break;
4891:             }
4943:           }
4891:         ]]>
4891:       </handler>
5040:       <handler event="DOMWillOpenModalDialog" phase="capturing">
4942:         <![CDATA[
4942:           if (!event.isTrusted)
4942:             return;
4942: 
4942:           // We're about to open a modal dialog, make sure the opening
4942:           // tab is brought to the front.
4942: 
4971:           var targetTop = event.target.top;
4954: 
4942:           for (var i = 0; i < browsers.length; ++i) {
4954:             if (this.getBrowserAtIndex(i).contentWindow == targetTop) {
4942:               this.mModalDialogShowing = true;
4942:               this.selectedTab = this.mTabContainer.childNodes[i];
4942: 
4942:               break;
4942:             }
4942:           }
4942:         ]]>
4942:       </handler>
5040:       <handler event="DOMModalDialogClosed" phase="capturing">
4942:         <![CDATA[
4942:           if (!event.isTrusted)
4942:             return;
4942: 
4942:           this.mModalDialogShowing = false;
4942:         ]]>
4942:       </handler>
4891:     </handlers>
4891:   </binding>
4891: 
5018:   <binding id="tabbrowser-tabs"
5018:            extends="chrome://global/content/bindings/tabbox.xml#tabs">
5018:     <content>
5050:       <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1" style="min-width: 1px;" clicktoscroll="true">
5018:         <children includes="tab"/>
5050:       </xul:arrowscrollbox>
5060:       <xul:hbox class="tabs-alltabs-box" align="center" pack="end" 
5060:                 anonid="alltabs-box">
5074:         <xul:toolbarbutton class="tabs-alltabs-button" type="menu">
5060:           <xul:menupopup class="tabs-alltabs-popup"
5060:                          anonid="alltabs-popup" 
5060:                          position="after_end"/>
5060:         </xul:toolbarbutton>
5060:       </xul:hbox>
5050:       <xul:hbox class="tabs-closebutton-box" align="center" pack="end" anonid="tabstrip-closebutton">
5059:         <xul:toolbarbutton class="close-button tabs-closebutton"/>
5018:       </xul:hbox>
5018:     </content>
5060:     <implementation implements="nsITimerCallback">
5018:       <constructor>
5053:         <![CDATA[
5018:           var pb2 =
5018:               Components.classes['@mozilla.org/preferences-service;1'].
5018:               getService(Components.interfaces.nsIPrefBranch2);
5060: 
5018:           try {
5053:             this.mTabMinWidth = pb2.getIntPref("browser.tabs.tabMinWidth");
5018:             this.mTabClipWidth = pb2.getIntPref("browser.tabs.tabClipWidth");
5050:             this.mCloseButtons = pb2.getIntPref("browser.tabs.closeButtons");
5018:           }
5018:           catch (e) {
5018:           }
5018: 
5053:           this.firstChild.minWidth = this.mTabMinWidth;
5018:           this._updateDisableBackgroundClose();
5050:           this.adjustTabstrip(false);
5050: 
5060:           pb2.addObserver("browser.tabs.disableBackgroundClose", 
5060:                           this._prefObserver, true);
5060:           pb2.addObserver("browser.tabs.closeButtons", 
5060:                           this._prefObserver, true);
5018: 
5018:           var self = this;
5018:           function onResize() {
5054:             var width = self.mTabstrip.boxObject.width;
5054:             if (width != self.mTabstripWidth) {
5050:               self.adjustTabstrip(false);
5054:               self.mTabstrip.scrollByIndex(1);
5053:               self.mTabstrip.scrollBoxObject
5053:                             .ensureElementIsVisible(self.selectedItem);
5054:               self.mTabstripWidth = width;
5054:             }
5018:           }
5018:           window.addEventListener("resize", onResize, false);
5053:         ]]>
5018:       </constructor>
5018: 
5060:       <destructor>
5060:         <![CDATA[
5060:           // Release timer to avoid reference cycles.
5060:           if (this.mFlashTimer) {
5060:             this.mFlashTimer.cancel();
5060:             this.mFlashTimer = null;
5060:           }
5060:         ]]>
5060:       </destructor>
5060: 
5054:       <field name="mTabstripWidth">0</field>
5054: 
5050:       <field name="mTabstrip">
5050:         document.getAnonymousElementByAttribute(this, "anonid", "arrowscrollbox");
5050:       </field>
5050: 
5050:       <field name="mTabstripClosebutton">
5050:         document.getAnonymousElementByAttribute(this, "anonid", "tabstrip-closebutton");
5050:       </field>
5050: 
5018:       <method name="_updateDisableBackgroundClose">
5018:         <body><![CDATA[
5018:           var prefs =
5018:               Components.classes['@mozilla.org/preferences-service;1'].
5018:               getService(Components.interfaces.nsIPrefBranch);
5018:           try {
5018:             if (prefs.getBoolPref("browser.tabs.disableBackgroundClose"))
5018:               this.setAttribute("disablebackgroundclose", "true");
5018:             else
5018:               this.removeAttribute("disablebackgroundclose");
5018:           }
5018:           catch (e) {
5018:             this.setAttribute("disablebackgroundclose", "true");
5018:           }
5018:         ]]></body>
5018:       </method>
5050: 
5046:       <field name="_prefObserver">({
5046:         tabbox: this,
5046:   
5046:         observe: function(subject, topic, data)
5046:         {
5050:           if (topic == "nsPref:changed") {
5050:             switch (data) {
5050:             case "browser.tabs.disableBackgroundClose":
5052:               this.tabbox._updateDisableBackgroundClose();
5050:               break;
5050:             case "browser.tabs.closeButtons":
5050:               var pb2 =
5050:                   Components.classes['@mozilla.org/preferences-service;1'].
5050:                   getService(Components.interfaces.nsIPrefBranch2);
5052:               this.tabbox.mCloseButtons = pb2.getIntPref("browser.tabs.closeButtons");
5052:               this.tabbox.adjustTabstrip(false);
5050:               break;
5050:             }
5050:           }
5046:         },
5046:   
5046:         QueryInterface : function(aIID)
5046:         {
5046:           if (aIID.equals(Components.interfaces.nsIObserver) ||
5046:               aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
5046:               aIID.equals(Components.interfaces.nsISupports))
5046:             return this;
5046:           throw Components.results.NS_NOINTERFACE;
5046:         }
5046:         });
5046:       </field>
5072:       <field name="mTabMinWidth">100</field>
5058:       <field name="mTabClipWidth">140</field>
5050:       <field name="mCloseButtons">1</field>
5050: 
5050:       <method name="adjustTabstrip">
5050:         <parameter name="aRemovingTab"/>
5018:         <body><![CDATA[
5050:           // modes for tabstrip
5050:           // 0 - activetab  = close button on active tab only
5050:           // 1 - alltabs    = close buttons on all tabs
5050:           // 2 - noclose    = no close buttons at all
5050:           // 3 - closeatend = close button at the end of the tabstrip
5050:           switch (this.mCloseButtons) {
5050:           case 0:
5050:             this.setAttribute("closebuttons", "activetab");
5050:             break;
5050:           case 1:
5018:             try {
5018:               var width = this.firstChild.boxObject.width;
5053:               // 0 width is an invalid value and indicates 
5053:               // an item without display, so ignore.
5018:               if (width > this.mTabClipWidth || width == 0)
5050:                 this.setAttribute("closebuttons", "alltabs");
5018:               else
5050:                 this.setAttribute("closebuttons", "activetab");
5050:             }
5018:             catch (e) {
5065:               // XXXzeniko what error are we catching here?
5018:             }
5050:             break;
5050:           case 2:
5050:           case 3:
5050:             this.setAttribute("closebuttons", "noclose");
5050:             break;
5050:           }
5050:           this.mTabstripClosebutton.collapsed = this.mCloseButtons != 3;
5050:           if (aRemovingTab) {
5050:             // if we're at the end of the tabstrip, we need to ensure 
5050:             // that we stay completely scrolled to the end
5050:             // this is a hack to determine if that's where we are already
5050:             var tabWidth = this.firstChild.boxObject.width;
5050:             var scrollPos = {};
5050:             this.mTabstrip.scrollBoxObject.getPosition(scrollPos, {});
5050:             if (scrollPos.value + this.mTabstrip.boxObject.width > tabWidth * (this.childNodes.length - 1))
5050:               this.mTabstrip.scrollByPixels(-1 * this.firstChild.boxObject.width);
5050:           }
5050:         ]]></body>
5050:       </method>
5050:         
5050:       <field name="_mPrefs">null</field>
5050:       <property name="mPrefs" readonly="true">
5050:         <getter>
5050:         <![CDATA[
5050:           if (!this._mPrefs) {
5050:             this._mPrefs =
5050:               Components.classes['@mozilla.org/preferences-service;1'].
5050:               getService(Components.interfaces.nsIPrefBranch2);
5050:           }
5050:           return this._mPrefs;
5050:         ]]>
5050:         </getter>
5050:       </property>
5050:         
5050:       <method name="_handleTabSelect">
5050:         <body><![CDATA[
5060:           this.mTabstrip.scrollBoxObject
5060:                         .ensureElementIsVisible(this.selectedItem);
5050:         ]]></body>
5050:       </method>
5050:         
5060:       <field name="mAllTabsPopup">
5060:         document.getAnonymousElementByAttribute(this, 
5060:                                                 "anonid", "alltabs-popup");
5060:       </field>
5060: 
5060:       <field name="mAllTabsBox">
5060:         document.getAnonymousElementByAttribute(this, 
5060:                                                 "anonid", "alltabs-box");
5060:       </field>
5060: 
5060:       <field name="mFlashTimer">null</field>
5060:       <field name="mFlashStage">0</field>
5060:       <field name="mFlashStart">6</field>
5060:       <field name="mFlashDelay">150</field>
5060: 
5060:       <method name="_notifyBackgroundTab">
5060:         <parameter name="aTab"/>
5060:         <body><![CDATA[
5060:           if (this.mFlashStage)
5060:             return;
5060: 
5060:           var tsbo = this.mTabstrip.scrollBoxObject;
5060:           var tsboStart = tsbo.screenX;
5060:           var tsboEnd = tsboStart + tsbo.width;
5060: 
5060:           var ctbo = aTab.boxObject;
5060:           var ctboStart = ctbo.screenX;
5060:           var ctboEnd = ctboStart + ctbo.width;
5060: 
5060:           // only start the flash timer if the new tab (which was loaded in
5060:           // the background) is not completely visible
5060:           if (tsboStart > ctboStart || ctboEnd > tsboEnd) {
5060:             this.mFlashStage = this.mFlashStart;
5060: 
5060:             if (!this.mFlashTimer) 
5060:               this.mFlashTimer =
5060:                 Components.classes["@mozilla.org/timer;1"]
5060:                           .createInstance(Components.interfaces.nsITimer);
5060:             else
5060:                this.mFlashTimer.cancel();
5060: 
5060:             this.mFlashTimer.initWithCallback(this,
5060:                          this.mFlashDelay,
5060:                          Components.interfaces.nsITimer.TYPE_REPEATING_SLACK);
5060:           }
5060:         ]]></body>
5060:       </method>
5060:       
5060:       <method name="notify">
5060:         <parameter name="aTimer"/>
5060:         <body><![CDATA[
5060:           if (!document)
5060:             aTimer.cancel();
5060: 
5060:           this.mFlashStage--;
5060: 
5060:           this.mAllTabsBox.setAttribute("flash",
5060:             (this.mFlashStage % 2) ? "true" : "false");
5060: 
5060:           if (!this.mFlashStage)
5060:             aTimer.cancel();
5060:         ]]></body>
5060:       </method>
5018:     </implementation>
5018:     <handlers>
5054:       <handler event="TabSelect" action="this._handleTabSelect();"/>
5018:     </handlers>
5018:   </binding>
5018: 
5060:   <!-- alltabs-popup binding
5060:        This binding relies on the structure of the tabbrowser binding.
5060:        Therefore it should only be used as a child of the tabs element.
5060:        This binding is exposed as a pseudo-public-API so themes can customize
5060:        the tabbar appearance without having to be scriptable
5060:        (see globalBindings.xml in Pinstripe for example).
5060:   -->
5060:   <binding id="tabbrowser-alltabs-popup"
5060:            extends="chrome://global/content/bindings/popup.xml#popup">
5069:     <implementation implements="nsIDOMEventListener">
5069:       <method name="_menuItemOnCommand">
5069:         <parameter name="aEvent"/>
5069:         <body><![CDATA[
5060:           // note, the tab may not be valid (if after we built the popup
5060:           // the tab was closed.  but selectedItem setter handles that
5060:           // gracefully.
5069:           var tabcontainer = document.getBindingParent(this);
5060:           tabcontainer.selectedItem = aEvent.target.tab;
5069:         ]]></body>
5069:       </method>
5069: 
5069:       <method name="_tabOnAttrModified">
5069:         <parameter name="aEvent"/>
5069:         <body><![CDATA[
5069:           var menuItem = aEvent.target.mCorrespondingMenuitem;
5069:           if (menuItem) {
5069:             var attrName = aEvent.attrName;
5069:             switch (attrName) {
5069:               case "label":
5069:               case "crop":
5069:               case "busy":
5069:               case "image":
5069:                 if (aEvent.attrChange == aEvent.REMOVAL)
5069:                   menuItem.removeAttribute(attrName);
5069:                 else
5069:                   menuItem.setAttribute(attrName, aEvent.newValue);
5060:             }
5069:           }
5069:         ]]></body>
5069:       </method>
5069: 
5069:       <method name="handleEvent">
5069:         <parameter name="aEvent"/>
5069:         <body><![CDATA[
5069:           if (!aEvent.isTrusted)
5069:             return;
5069: 
5069:           switch (aEvent.type) {
5069:             case "command":
5069:               this._menuItemOnCommand(aEvent);
5069:               break;
5069:             case "DOMAttrModified":
5069:               this._tabOnAttrModified(aEvent);
5069:           }
5069:         ]]></body>
5069:       </method>
5060: 
5060:       <method name="_onHidingAllTabsPopup">
5060:         <body><![CDATA[
5060:           // clear out the menu popup and remove the listeners
5060:           while (this.hasChildNodes()) {
5060:             var menuItem = this.lastChild;
5069:             menuItem.removeEventListener("command", this, false);
5069:             menuItem.tab.removeEventListener("DOMAttrModified", this, false);
5069:             menuItem.tab.mCorrespondingMenuitem = null;
5060:             this.removeChild(menuItem);
5060:           }
5060:         ]]></body>
5060:       </method>
5060: 
5060:       <method name="_onShowingAllTabsPopup">
5060:         <body><![CDATA[
5060:           // set up the menu popup
5060:           var tabcontainer = document.getBindingParent(this);
5060:           var tabs = tabcontainer.childNodes;
5060: 
5060:           for (var i = 0; i < tabs.length; i++) {
5060:             var menuItem = document.createElementNS(
5060:               "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", 
5060:               "menuitem");
5060:             var curTab = tabs[i];
5060: 
5060:             if (curTab.selected)
5060:               menuItem.setAttribute("selected", "true");
5060:             menuItem.setAttribute("class", "menuitem-iconic alltabs-item");
5060: 
5060:             menuItem.setAttribute("label", curTab.label);
5069:             menuItem.setAttribute("crop", curTab.getAttribute("crop"));
5060:             menuItem.setAttribute("image", curTab.getAttribute("image"));
5069:             if (curTab.hasAttribute("busy"))
5069:               menuItem.setAttribute("busy", curTab.getAttribute("busy"));
5069: 
5060:             // XXX todo
5060:             // statustext not working yet, since I don't have a menubar
5060:             // reuse the menubar statustext logic
5069:             var URI = curTab.linkedBrowser.currentURI.spec;
5060:             menuItem.setAttribute("statustext", URI);
5069: 
5069:             // Keep some attributes of the menuitem in sync with its
5069:             // corresponding tab (e.g. the tab label)
5069:             curTab.mCorrespondingMenuitem = menuItem;
5069:             curTab.addEventListener("DOMAttrModified", this, false);
5069: 
5060:             menuItem.tab = curTab;
5069:             menuItem.addEventListener("command", this, false);
5060:             this.appendChild(menuItem);
5060:           }
5060:         ]]></body>
5060:       </method>
5060:     </implementation>
5060:     <handlers>
5060:       <handler event="popupshowing"><![CDATA[
5060:         if (event.target == this)
5060:           this._onShowingAllTabsPopup();
5060:       ]]></handler>
5060:       <handler event="popuphiding"><![CDATA[
5060:         if (event.target == this)
5060:           this._onHidingAllTabsPopup();
5060:       ]]></handler>
5060:     </handlers>
5060:   </binding>
5060: 
5059:   <!-- close-tab-button binding
5059:        This binding relies on the structure of the tabbrowser binding.
5060:        Therefore it should only be used as a child of the tab or the tabs
5059:        element (in both cases, when they are anonymous nodes of <tabbrowser>).
5059:        This binding is exposed as a pseudo-public-API so themes can customize
5059:        the tabbar appearance without having to be scriptable
5059:        (see globalBindings.xml in Pinstripe for example).
5059:   -->
5059:   <binding id="tabbrowser-close-tab-button"
5059:            extends="chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton">
5059:     <handlers>
5059:       <handler event="command"><![CDATA[
5059:         var bindingParent = document.getBindingParent(this);
5059:         if (bindingParent) {
5059:           var tabbedBrowser = document.getBindingParent(bindingParent);
5059:           if (bindingParent.localName == "tab") {
5059:             tabbedBrowser.removeTab(bindingParent);
5059:             tabbedBrowser._blockDblClick = true;
5059: 
5059:             /* XXXmano hack (see bug 343628):
5059:              * Since we're removing the event target, if the user
5059:              * double-clicks this button, the dblclick event will be dispatched
5059:              * with the tabbar as its event target (and explicit/originalTarget),
5059:              * which treats that as a mouse gesture for opening a new tab.
5059:              * In this context, there is no way to prevent the dispatching
5059:              * of the dblclick event, so we're manually blocking it (see
5059:              * onTabBarDblClick) until the mouse is moved.
5059:              */
5059:             function mouseMoveHandler() {
5059:               tabbedBrowser._blockDblClick = false;
5059:               tabbedBrowser.removeEventListener("mousemove", mouseMoveHandler, false);
5059:             }
5059:             tabbedBrowser.addEventListener("mousemove",  mouseMoveHandler, false);
5059:           }
5059:           else // "tabs"
5059:             tabbedBrowser.removeCurrentTab();
5059:         }
5059:       ]]></handler>
5059:       <handler event="dblclick" phase="capturing">
5059:         // for the one-close-button case
5059:         event.stopPropagation();
5059:       </handler>
5059:     </handlers>
5059:   </binding>
5059: 
5018:   <binding id="tabbrowser-tab" display="xul:box"
5018:            extends="chrome://global/content/bindings/tabbox.xml#tab">
5021:     <content chromedir="&locale.dir;"
5018:              closetabtext="&closeTab.label;">
5018:       <xul:hbox class="tab-middle box-inherit" xbl:inherits="align,dir,pack,orient,selected" flex="1">
5018:         <xul:image class="tab-icon" xbl:inherits="validate,src=image"/>
5018:         <xul:label class="tab-text" xbl:inherits="value=label,accesskey,crop,disabled" flex="1"/>
5018:       </xul:hbox>
5018:       <xul:image anonid="close-button-placeholder" class="tab-close-button-placeholder"/>
5018:       <xul:toolbarbutton anonid="close-button" class="tab-close-button"/>
5018:     </content>
5018: 
5018:     <implementation>
5018:       <field name="mOverCloseButton">false</field>
5069:       <field name="mCorrespondingMenuitem">null</field>
5018:     </implementation>
5018: 
5018:     <handlers>
5018:       <handler event="mouseover">
5018:         var anonid = event.originalTarget.getAttribute("anonid");
5018:         if (anonid == "close-button")
5018:           this.mOverCloseButton = true;
5018:       </handler>
5018:       <handler event="mouseout">
5018:         var anonid = event.originalTarget.getAttribute("anonid");
5018:         if (anonid == "close-button")
5018:           this.mOverCloseButton = false;
5018:       </handler>
5018:       <handler event="mousedown" button="0" phase="capturing">
5018:       <![CDATA[
5018:         if (this.mOverCloseButton)
5018:           event.stopPropagation();
5018:       ]]>
5018:       </handler>
5018:     </handlers>
5018:   </binding>
5018: 
4891: </bindings>
