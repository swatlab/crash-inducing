    1: /* -*- Mode: C++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * David Hyatt (hyatt@netscape.com).
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Tim Hill (tim@prismelite.com)
    1:  *   James Ross (silver@warwickcompsoc.co.uk)
 3477:  *   Simon BÃ¼nzli (zeniko@gmail.com)
49249:  *   Jim Mathies (jmathies@mozilla.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include <windows.h>
    1: #include "nsNativeThemeWin.h"
68481: #include "nsRenderingContext.h"
    1: #include "nsRect.h"
    1: #include "nsSize.h"
    1: #include "nsTransform2D.h"
    1: #include "nsThemeConstants.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsIFrame.h"
68780: #include "nsEventStates.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDOMHTMLInputElement.h"
73634: #include "nsMenuFrame.h"
80435: #include "nsGkAtoms.h"
    1: #include <malloc.h>
 4756: #include "nsWindow.h"
12632: #include "nsIComboboxControlFrame.h"
69598: #include "prinrval.h"
    1: 
 4313: #include "gfxPlatform.h"
    1: #include "gfxContext.h"
    1: #include "gfxMatrix.h"
51036: #include "gfxWindowsPlatform.h"
    1: #include "gfxWindowsSurface.h"
    1: #include "gfxWindowsNativeDrawing.h"
    1: 
16026: #include "nsUXThemeData.h"
16026: #include "nsUXThemeConstants.h"
    1: 
76714: #ifdef PR_LOGGING
76714: extern PRLogModuleInfo* gWindowsLog;
76714: #endif
76714: 
57445: NS_IMPL_ISUPPORTS_INHERITED1(nsNativeThemeWin, nsNativeTheme, nsITheme)
    1: 
79445: static inline bool IsHTMLContent(nsIFrame *frame)
12424: {
12424:   nsIContent* content = frame->GetContent();
33329:   return content && content->IsHTML();
12424: }
12424: 
49249: static PRInt32 GetTopLevelWindowActiveState(nsIFrame *aFrame)
49249: {
49249:   // Get the widget. nsIFrame's GetNearestWidget walks up the view chain
49249:   // until it finds a real window.
49249:   nsIWidget* widget = aFrame->GetNearestWidget();
49249:   nsWindow * window = static_cast<nsWindow*>(widget);
83181:   if (!window)
83181:     return mozilla::widget::themeconst::FS_INACTIVE;
49249:   if (widget && !window->IsTopLevelWidget() &&
79626:       !(window = window->GetParentWindow(false)))
83181:     return mozilla::widget::themeconst::FS_INACTIVE;
49249: 
49249:   if (window->GetWindowHandle() == ::GetActiveWindow())
49249:     return mozilla::widget::themeconst::FS_ACTIVE;
49249:   return mozilla::widget::themeconst::FS_INACTIVE;
49249: }
49249: 
56168: static PRInt32 GetWindowFrameButtonState(nsIFrame *aFrame, nsEventStates eventState)
49249: {
49249:   if (GetTopLevelWindowActiveState(aFrame) ==
49250:       mozilla::widget::themeconst::FS_INACTIVE) {
56168:     if (eventState.HasState(NS_EVENT_STATE_HOVER))
49250:       return mozilla::widget::themeconst::BS_HOT;
49249:     return mozilla::widget::themeconst::BS_INACTIVE;
49250:   }
49249: 
57443:   if (eventState.HasState(NS_EVENT_STATE_HOVER)) {
56168:     if (eventState.HasState(NS_EVENT_STATE_ACTIVE))
49249:       return mozilla::widget::themeconst::BS_PUSHED;
49249:     return mozilla::widget::themeconst::BS_HOT;
57443:   }
49249:   return mozilla::widget::themeconst::BS_NORMAL;
49249: }
49249: 
56168: static PRInt32 GetClassicWindowFrameButtonState(nsEventStates eventState)
49249: {
57568:   if (eventState.HasState(NS_EVENT_STATE_ACTIVE) &&
57568:       eventState.HasState(NS_EVENT_STATE_HOVER))
49249:     return DFCS_BUTTONPUSH|DFCS_PUSHED;
49249:   return DFCS_BUTTONPUSH;
49249: }
49249: 
49250: static void QueryForButtonData(nsIFrame *aFrame)
49250: {
57470:   if (nsUXThemeData::sTitlebarInfoPopulatedThemed && nsUXThemeData::sTitlebarInfoPopulatedAero)
57470:     return;
49250:   nsIWidget* widget = aFrame->GetNearestWidget();
49250:   nsWindow * window = static_cast<nsWindow*>(widget);
49250:   if (!window)
49250:     return;
49250:   if (!window->IsTopLevelWidget() &&
79626:       !(window = window->GetParentWindow(false)))
49250:     return;
49250: 
49250:   nsUXThemeData::UpdateTitlebarInfo(window->GetWindowHandle());
49250: }
49250: 
    1: nsNativeThemeWin::nsNativeThemeWin() {
    1:   // If there is a relevant change in forms.css for windows platform,
    1:   // static widget style variables (e.g. sButtonBorderSize) should be 
    1:   // reinitialized here.
    1: }
    1: 
    1: nsNativeThemeWin::~nsNativeThemeWin() {
16026:   nsUXThemeData::Invalidate();
    1: }
    1: 
79445: static bool IsTopLevelMenu(nsIFrame *aFrame)
 4313: {
79445:   bool isTopLevel(false);
73634:   nsMenuFrame *menuFrame = do_QueryFrame(aFrame);
 4313:   if (menuFrame) {
 4313:     isTopLevel = menuFrame->IsOnMenuBar();
 4313:   }
 4313:   return isTopLevel;
 4313: }
 4313: 
31799: static MARGINS GetCheckboxMargins(HANDLE theme, HDC hdc)
31799: {
31799:     MARGINS checkboxContent = {0};
31799:     nsUXThemeData::getThemeMargins(theme, hdc, MENU_POPUPCHECK, MCB_NORMAL, TMT_CONTENTMARGINS, NULL, &checkboxContent);
31799:     return checkboxContent;
31799: }
31799: static SIZE GetCheckboxBGSize(HANDLE theme, HDC hdc)
 4313: {
 4313:     SIZE checkboxSize;
16026:     nsUXThemeData::getThemePartSize(theme, hdc, MENU_POPUPCHECK, MC_CHECKMARKNORMAL, NULL, TS_TRUE, &checkboxSize);
 4313: 
31799:     MARGINS checkboxMargins = GetCheckboxMargins(theme, hdc);
 4313: 
31799:     int leftMargin = checkboxMargins.cxLeftWidth;
31799:     int rightMargin = checkboxMargins.cxRightWidth;
31799:     int topMargin = checkboxMargins.cyTopHeight;
31799:     int bottomMargin = checkboxMargins.cyBottomHeight;
 4313: 
 4313:     int width = leftMargin + checkboxSize.cx + rightMargin;
 4313:     int height = topMargin + checkboxSize.cy + bottomMargin;
 4313:     SIZE ret;
 4313:     ret.cx = width;
 4313:     ret.cy = height;
 4313:     return ret;
 4313: }
31799: static SIZE GetCheckboxBGBounds(HANDLE theme, HDC hdc)
 4313: {
31799:     MARGINS checkboxBGSizing = {0};
31799:     MARGINS checkboxBGContent = {0};
31799:     nsUXThemeData::getThemeMargins(theme, hdc, MENU_POPUPCHECKBACKGROUND, MCB_NORMAL, TMT_SIZINGMARGINS, NULL, &checkboxBGSizing);
31799:     nsUXThemeData::getThemeMargins(theme, hdc, MENU_POPUPCHECKBACKGROUND, MCB_NORMAL, TMT_CONTENTMARGINS, NULL, &checkboxBGContent);
 4313: 
 4313: #define posdx(d) ((d) > 0 ? d : 0)
 4313: 
31799:     int dx = posdx(checkboxBGContent.cxRightWidth - checkboxBGSizing.cxRightWidth) + posdx(checkboxBGContent.cxLeftWidth - checkboxBGSizing.cxLeftWidth);
31799:     int dy = posdx(checkboxBGContent.cyTopHeight - checkboxBGSizing.cyTopHeight) + posdx(checkboxBGContent.cyBottomHeight - checkboxBGSizing.cyBottomHeight);
 4313: 
 4313: #undef posdx
 4313: 
31799:     SIZE ret(GetCheckboxBGSize(theme, hdc));
 4313:     ret.cx += dx;
 4313:     ret.cy += dy;
 4313:     return ret;
 4313: }
 4313: static SIZE GetGutterSize(HANDLE theme, HDC hdc)
 4313: {
 4313:     SIZE gutterSize;
16026:     nsUXThemeData::getThemePartSize(theme, hdc, MENU_POPUPGUTTER, 0, NULL, TS_TRUE, &gutterSize);
 4313: 
31799:     SIZE checkboxBGSize(GetCheckboxBGBounds(theme, hdc));
 4313: 
 4313:     SIZE itemSize;
16026:     nsUXThemeData::getThemePartSize(theme, hdc, MENU_POPUPITEM, MPI_NORMAL, NULL, TS_TRUE, &itemSize);
 4313: 
71173:     int width = NS_MAX(itemSize.cx, checkboxBGSize.cx + gutterSize.cx);
71173:     int height = NS_MAX(itemSize.cy, checkboxBGSize.cy);
 4313:     SIZE ret;
 4313:     ret.cx = width;
 4313:     ret.cy = height;
 4313:     return ret;
 4313: }
 4313: 
16044: static HRESULT DrawThemeBGRTLAware(HANDLE theme, HDC hdc, int part, int state,
16044:                                    const RECT *widgetRect, const RECT *clipRect,
79445:                                    bool isRTL)
16044: {
16044:   /* Some widgets are not direction-neutral and need to be drawn reversed for
16044:    * RTL.  Windows provides a way to do this with SetLayout, but this reverses
16044:    * the entire drawing area of a given device context, which means that its
16044:    * use will also affect the positioning of the widget.  There are two ways
16044:    * to work around this:
16044:    *
16044:    * Option 1: Alter the position of the rect that we send so that we cancel
16044:    *           out the positioning effects of SetLayout
16044:    * Option 2: Create a memory DC with the widgetRect's dimensions, draw onto
16044:    *           that, and then transfer the results back to our DC
16044:    *
16044:    * This function tries to implement option 1, under the assumption that the
16044:    * correct way to reverse the effects of SetLayout is to translate the rect
16044:    * such that the offset from the DC bitmap's left edge to the old rect's
16044:    * left edge is equal to the offset from the DC bitmap's right edge to the
16044:    * new rect's right edge.  In other words,
16044:    * (oldRect.left + vpOrg.x) == ((dcBMP.width - vpOrg.x) - newRect.right)
16044:    *
16044:    * I am not 100% sure that this is the correct approach, but I have yet to
16044:    * find a problem with it.
16044:    */
16044: 
16044:   if (isRTL) {
16044:     HGDIOBJ hObj = GetCurrentObject(hdc, OBJ_BITMAP);
16044:     BITMAP bitmap;
16044:     POINT vpOrg;
16044: 
16044:     if (hObj &&
16044:         GetObject(hObj, sizeof(bitmap), &bitmap) &&
16044:         GetViewportOrgEx(hdc, &vpOrg))
16044:     {
16044:       RECT newWRect(*widgetRect);
16044:       newWRect.left = bitmap.bmWidth - (widgetRect->right + 2*vpOrg.x);
16044:       newWRect.right = bitmap.bmWidth - (widgetRect->left + 2*vpOrg.x);
16044: 
16044:       RECT newCRect;
16044:       RECT *newCRectPtr = NULL;
16044: 
16044:       if (clipRect) {
16044:         newCRect.top = clipRect->top;
16044:         newCRect.bottom = clipRect->bottom;
16044:         newCRect.left = bitmap.bmWidth - (clipRect->right + 2*vpOrg.x);
16044:         newCRect.right = bitmap.bmWidth - (clipRect->left + 2*vpOrg.x);
16044:         newCRectPtr = &newCRect;
16044:       }
16044: 
16044:       SetLayout(hdc, LAYOUT_RTL);
16044:       HRESULT hr = nsUXThemeData::drawThemeBG(theme, hdc, part, state, &newWRect, newCRectPtr);
16044:       SetLayout(hdc, 0);
16044: 
16044:       if (hr == S_OK)
16044:         return hr;
16044:     }
16044:   }
16044: 
16044:   // Draw normally if LTR or if anything went wrong
16044:   return nsUXThemeData::drawThemeBG(theme, hdc, part, state, widgetRect, clipRect);
16044: }
16044: 
58328: /*
58328:   Caption button padding data - 'hot' button padding.
58328:   These areas are considered hot, in that they activate
58328:   a button when hovered or clicked. The button graphic
58328:   is drawn inside the padding border. Unrecognized themes
58328:   are treated as their recognized counterparts for now.
58328:                        left      top    right   bottom
58328:   classic min             1        2        0        1
58328:   classic max             0        2        1        1
58328:   classic close           1        2        2        1
58328: 
58328:   aero basic min          1        2        0        2
58328:   aero basic max          0        2        1        2
58328:   aero basic close        1        2        1        2
58328: 
58328:   xp theme min            0        2        0        2
58328:   xp theme max            0        2        1        2
58328:   xp theme close          1        2        2        2
58328: 
58328:   'cold' button padding - generic button padding, should
58328:   be handled in css.
58328:                        left      top    right   bottom
58328:   classic min             0        0        0        0
58328:   classic max             0        0        0        0
58328:   classic close           0        0        0        0
58328: 
58328:   aero basic min          0        0        1        0
58328:   aero basic max          1        0        0        0
58328:   aero basic close        0        0        0        0
58328: 
58328:   xp theme min            0        0        1        0
58328:   xp theme max            1        0        0        0
58328:   xp theme close          0        0        0        0
58328: */
58328: 
58328: enum CaptionDesktopTheme {
58328:   CAPTION_CLASSIC = 0,
58328:   CAPTION_BASIC,
58328:   CAPTION_XPTHEME,
58328: };
58328: 
58328: enum CaptionButton {
58328:   CAPTIONBUTTON_MINIMIZE = 0,
58328:   CAPTIONBUTTON_RESTORE,
58328:   CAPTIONBUTTON_CLOSE,
58328: };
58328: 
58328: struct CaptionButtonPadding {
58328:   RECT hotPadding[3];
58328: };
58328: 
58328: // RECT: left, top, right, bottom
58328: static CaptionButtonPadding buttonData[3] = {
58328:   { 
58328:     { { 1, 2, 0, 1 }, { 0, 2, 1, 1 }, { 1, 2, 2, 1 } }
58328:   },
58328:   { 
58328:     { { 1, 2, 0, 2 }, { 0, 2, 1, 2 }, { 1, 2, 2, 2 } }
58328:   },
58328:   { 
58328:     { { 0, 2, 0, 2 }, { 0, 2, 1, 2 }, { 1, 2, 2, 2 } }
58328:   }
58328: };
58328: 
69596: /**
69596:  * Progress bar related constants.
69598:  * These values are found by experimenting and comparing against native widgets
69598:  * used by the system. They are very unlikely exact but try to not be too wrong.
69596:  */
69991: // The width of the overlay used to animate the horizontal progress bar (Vista and later).
69991: static const PRInt32 kProgressHorizontalVistaOverlaySize = 120;
69991: // The width of the overlay used for the horizontal indeterminate progress bars on XP.
69991: static const PRInt32 kProgressHorizontalXPOverlaySize = 55;
69991: // The height of the overlay used to animate the vertical progress bar (Vista and later).
69991: static const PRInt32 kProgressVerticalOverlaySize = 45;
69991: // The height of the overlay used for the vertical indeterminate progress bar (Vista and later).
69991: static const PRInt32 kProgressVerticalIndeterminateOverlaySize = 60;
74266: // The width of the overlay used to animate the indeterminate progress bar (Windows Classic).
74266: static const PRInt32 kProgressClassicOverlaySize = 40;
69599: // Speed (px per ms) of the animation for determined Vista and later progress bars.
69600: static const double kProgressDeterminedVistaSpeed = 0.225;
69599: // Speed (px per ms) of the animation for indeterminate progress bars.
69599: static const double kProgressIndeterminateSpeed = 0.175;
74266: // Speed (px per ms) of the animation for indeterminate progress bars (Windows Classic).
74266: static const double kProgressClassicIndeterminateSpeed = 0.0875;
69600: // Delay (in ms) between two indeterminate progress bar cycles.
69599: static const PRInt32 kProgressIndeterminateDelay = 500;
69600: // Delay (in ms) between two determinate progress bar animation on Vista/7.
69600: static const PRInt32 kProgressDeterminedVistaDelay = 1000;
69596: 
58328: // Adds "hot" caption button padding to minimum widget size.
58328: static void AddPaddingRect(nsIntSize* aSize, CaptionButton button) {
58328:   if (!aSize)
58328:     return;
58328:   RECT offset;
58328:   if (!nsUXThemeData::IsAppThemed())
58328:     offset = buttonData[CAPTION_CLASSIC].hotPadding[button];
58328:   else if (nsWindow::GetWindowsVersion() == WINXP_VERSION)
58328:     offset = buttonData[CAPTION_XPTHEME].hotPadding[button];
58328:   else
58328:     offset = buttonData[CAPTION_BASIC].hotPadding[button];
58328:   aSize->width += offset.left + offset.right;
58328:   aSize->height += offset.top + offset.bottom;
58328: }
58328: 
58328: // If we've added padding to the minimum widget size, offset
58328: // the area we draw into to compensate.
58328: static void OffsetBackgroundRect(RECT& rect, CaptionButton button) {
58328:   RECT offset;
58328:   if (!nsUXThemeData::IsAppThemed())
58328:     offset = buttonData[CAPTION_CLASSIC].hotPadding[button];
58328:   else if (nsWindow::GetWindowsVersion() == WINXP_VERSION)
58328:     offset = buttonData[CAPTION_XPTHEME].hotPadding[button];
58328:   else
58328:     offset = buttonData[CAPTION_BASIC].hotPadding[button];
58328:   rect.left += offset.left;
58328:   rect.top += offset.top;
58328:   rect.right -= offset.right;
58328:   rect.bottom -= offset.bottom;
58328: }
58328: 
    1: HANDLE
    1: nsNativeThemeWin::GetTheme(PRUint8 aWidgetType)
    1: { 
16026:   if (!nsUXThemeData::sIsVistaOrLater) {
14697:     // On XP or earlier, render dropdowns as textfields;
14697:     // doing it the right way works fine with the MS themes,
14697:     // but breaks on a lot of custom themes (presumably because MS
14697:     // apps do the textfield border business as well).
14697:     if (aWidgetType == NS_THEME_DROPDOWN)
14697:       aWidgetType = NS_THEME_TEXTFIELD;
14697:   }
14697: 
    1:   switch (aWidgetType) {
    1:     case NS_THEME_BUTTON:
    1:     case NS_THEME_RADIO:
 1321:     case NS_THEME_CHECKBOX:
26072:     case NS_THEME_GROUPBOX:
16026:       return nsUXThemeData::GetTheme(eUXButton);
    1:     case NS_THEME_TEXTFIELD:
16026:     case NS_THEME_TEXTFIELD_MULTILINE:
16026:       return nsUXThemeData::GetTheme(eUXEdit);
16026:     case NS_THEME_TOOLTIP:
15057:       // BUG #161600: XP/2K3 should force a classic treatment of tooltips
16026:       return nsUXThemeData::sIsVistaOrLater ? nsUXThemeData::GetTheme(eUXTooltip) : NULL;
16026:     case NS_THEME_TOOLBOX:
16026:       return nsUXThemeData::GetTheme(eUXRebar);
16026:     case NS_THEME_WIN_MEDIA_TOOLBOX:
16026:       return nsUXThemeData::GetTheme(eUXMediaRebar);
16026:     case NS_THEME_WIN_COMMUNICATIONS_TOOLBOX:
16026:       return nsUXThemeData::GetTheme(eUXCommunicationsRebar);
16026:     case NS_THEME_WIN_BROWSER_TAB_BAR_TOOLBOX:
16026:       return nsUXThemeData::GetTheme(eUXBrowserTabBarRebar);
    1:     case NS_THEME_TOOLBAR:
 5281:     case NS_THEME_TOOLBAR_BUTTON:
16026:     case NS_THEME_TOOLBAR_SEPARATOR:
16026:       return nsUXThemeData::GetTheme(eUXToolbar);
    1:     case NS_THEME_PROGRESSBAR:
    1:     case NS_THEME_PROGRESSBAR_VERTICAL:
    1:     case NS_THEME_PROGRESSBAR_CHUNK:
16026:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
16026:       return nsUXThemeData::GetTheme(eUXProgress);
    1:     case NS_THEME_TAB:
    1:     case NS_THEME_TAB_PANEL:
16026:     case NS_THEME_TAB_PANELS:
16026:       return nsUXThemeData::GetTheme(eUXTab);
    1:     case NS_THEME_SCROLLBAR:
 3459:     case NS_THEME_SCROLLBAR_SMALL:
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:     case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
16026:       return nsUXThemeData::GetTheme(eUXScrollbar);
    1:     case NS_THEME_SCALE_HORIZONTAL:
    1:     case NS_THEME_SCALE_VERTICAL:
    1:     case NS_THEME_SCALE_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCALE_THUMB_VERTICAL:
16026:       return nsUXThemeData::GetTheme(eUXTrackbar);
    1:     case NS_THEME_SPINNER_UP_BUTTON:
    1:     case NS_THEME_SPINNER_DOWN_BUTTON:
16026:       return nsUXThemeData::GetTheme(eUXSpin);
    1:     case NS_THEME_STATUSBAR:
    1:     case NS_THEME_STATUSBAR_PANEL:
    1:     case NS_THEME_STATUSBAR_RESIZER_PANEL:
    1:     case NS_THEME_RESIZER:
16026:       return nsUXThemeData::GetTheme(eUXStatus);
12424:     case NS_THEME_DROPDOWN:
16026:     case NS_THEME_DROPDOWN_BUTTON:
16026:       return nsUXThemeData::GetTheme(eUXCombobox);
    1:     case NS_THEME_TREEVIEW_HEADER_CELL:
16026:     case NS_THEME_TREEVIEW_HEADER_SORTARROW:
16026:       return nsUXThemeData::GetTheme(eUXHeader);
    1:     case NS_THEME_LISTBOX:
    1:     case NS_THEME_LISTBOX_LISTITEM:
    1:     case NS_THEME_TREEVIEW:
    1:     case NS_THEME_TREEVIEW_TWISTY_OPEN:
16026:     case NS_THEME_TREEVIEW_TREEITEM:
16026:       return nsUXThemeData::GetTheme(eUXListview);
 4313:     case NS_THEME_MENUBAR:
 4313:     case NS_THEME_MENUPOPUP:
 4313:     case NS_THEME_MENUITEM:
 4313:     case NS_THEME_CHECKMENUITEM:
 4313:     case NS_THEME_RADIOMENUITEM:
 4313:     case NS_THEME_MENUCHECKBOX:
 4313:     case NS_THEME_MENURADIO:
 4313:     case NS_THEME_MENUSEPARATOR:
 4313:     case NS_THEME_MENUARROW:
 4313:     case NS_THEME_MENUIMAGE:
 4313:     case NS_THEME_MENUITEMTEXT:
16026:       return nsUXThemeData::GetTheme(eUXMenu);
49249:     case NS_THEME_WINDOW_TITLEBAR:
49249:     case NS_THEME_WINDOW_TITLEBAR_MAXIMIZED:
49249:     case NS_THEME_WINDOW_FRAME_LEFT:
49249:     case NS_THEME_WINDOW_FRAME_RIGHT:
49249:     case NS_THEME_WINDOW_FRAME_BOTTOM:
49249:     case NS_THEME_WINDOW_BUTTON_CLOSE:
49249:     case NS_THEME_WINDOW_BUTTON_MINIMIZE:
49249:     case NS_THEME_WINDOW_BUTTON_MAXIMIZE:
49249:     case NS_THEME_WINDOW_BUTTON_RESTORE:
49250:     case NS_THEME_WINDOW_BUTTON_BOX:
49250:     case NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED:
56101:     case NS_THEME_WIN_GLASS:
56101:     case NS_THEME_WIN_BORDERLESS_GLASS:
49249:       return nsUXThemeData::GetTheme(eUXWindowFrame);
    1:   }
    1:   return NULL;
    1: }
    1: 
12424: PRInt32
12424: nsNativeThemeWin::StandardGetState(nsIFrame* aFrame, PRUint8 aWidgetType,
79445:                                    bool wantFocused)
12424: {
56168:   nsEventStates eventState = GetContentState(aFrame, aWidgetType);
56168:   if (eventState.HasAllStates(NS_EVENT_STATE_HOVER | NS_EVENT_STATE_ACTIVE))
12424:     return TS_ACTIVE;
72737:   if (eventState.HasState(NS_EVENT_STATE_HOVER))
72737:     return TS_HOVER;
56168:   if (wantFocused && eventState.HasState(NS_EVENT_STATE_FOCUS))
12424:     return TS_FOCUSED;
12424: 
12424:   return TS_NORMAL;
12424: }
12424: 
79445: bool
12680: nsNativeThemeWin::IsMenuActive(nsIFrame *aFrame, PRUint8 aWidgetType)
12424: {
30672:   nsIContent* content = aFrame->GetContent();
33329:   if (content->IsXUL() &&
80435:       content->NodeInfo()->Equals(nsGkAtoms::richlistitem))
80435:     return CheckBooleanAttr(aFrame, nsGkAtoms::selected);
80435: 
80435:   return CheckBooleanAttr(aFrame, nsGkAtoms::menuactive);
12424: }
12424: 
43487: /**
43487:  * aPart is filled in with the UXTheme part code. On return, values > 0
43487:  * are the actual UXTheme part code; -1 means the widget will be drawn by
43487:  * us; 0 means that we should use part code 0, which isn't a real part code
43487:  * but elicits some kind of default behaviour from UXTheme when drawing
43487:  * (but isThemeBackgroundPartiallyTransparent may not work).
43487:  */
    1: nsresult 
    1: nsNativeThemeWin::GetThemePartAndState(nsIFrame* aFrame, PRUint8 aWidgetType, 
    1:                                        PRInt32& aPart, PRInt32& aState)
    1: {
16026:   if (!nsUXThemeData::sIsVistaOrLater) {
14697:     // See GetTheme
14697:     if (aWidgetType == NS_THEME_DROPDOWN)
14697:       aWidgetType = NS_THEME_TEXTFIELD;
14697:   }
14697: 
    1:   switch (aWidgetType) {
    1:     case NS_THEME_BUTTON: {
    1:       aPart = BP_BUTTON;
    1:       if (!aFrame) {
    1:         aState = TS_NORMAL;
    1:         return NS_OK;
    1:       }
    1: 
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
54683:       if (IsDisabled(aFrame, eventState)) {
    1:         aState = TS_DISABLED;
    1:         return NS_OK;
26124:       } else if (IsOpenButton(aFrame) ||
26124:                  IsCheckedButton(aFrame)) {
15846:         aState = TS_ACTIVE;
15846:         return NS_OK;
    1:       }
12424: 
79626:       aState = StandardGetState(aFrame, aWidgetType, true);
    1:       
    1:       // Check for default dialog buttons.  These buttons should always look
    1:       // focused.
    1:       if (aState == TS_NORMAL && IsDefaultButton(aFrame))
    1:         aState = TS_FOCUSED;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_CHECKBOX:
21220:     case NS_THEME_RADIO: {
21220:       bool isCheckbox = (aWidgetType == NS_THEME_CHECKBOX);
 1321:       aPart = isCheckbox ? BP_CHECKBOX : BP_RADIO;
    1: 
24662:       enum InputState {
24662:         UNCHECKED = 0, CHECKED, INDETERMINATE
24662:       };
24662:       InputState inputState = UNCHECKED;
79445:       bool isXULCheckboxRadio = false;
    1: 
24662:       if (!aFrame) {
    1:         aState = TS_NORMAL;
24662:       } else {
24662:         if (GetCheckedOrSelected(aFrame, !isCheckbox)) {
24662:           inputState = CHECKED;
24662:         } if (isCheckbox && GetIndeterminate(aFrame)) {
24662:           inputState = INDETERMINATE;
    1:         }
    1: 
56168:         nsEventStates eventState = GetContentState(isXULCheckboxRadio ? aFrame->GetParent()
54344:                                                                       : aFrame,
54344:                                              aWidgetType);
54683:         if (IsDisabled(aFrame, eventState)) {
    1:           aState = TS_DISABLED;
24662:         } else {
79626:           aState = StandardGetState(aFrame, aWidgetType, false);
    1:         }
    1:       }
    1: 
24662:       // 4 unchecked states, 4 checked states, 4 indeterminate states.
24662:       aState += inputState * 4;
    1:       return NS_OK;
    1:     }
26072:     case NS_THEME_GROUPBOX: {
26072:       aPart = BP_GROUPBOX;
26072:       aState = TS_NORMAL;
26072:       // Since we don't support groupbox disabled and GBS_DISABLED looks the
26072:       // same as GBS_NORMAL don't bother supporting GBS_DISABLED.
26072:       return NS_OK;
26072:     }
    1:     case NS_THEME_TEXTFIELD:
12424:     case NS_THEME_TEXTFIELD_MULTILINE: {
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
54344: 
16026:       if (nsUXThemeData::sIsVistaOrLater) {
12424:         /* Note: the NOSCROLL type has a rounded corner in each
12424:          * corner.  The more specific HSCROLL, VSCROLL, HVSCROLL types
12424:          * have side and/or top/bottom edges rendered as straight
23537:          * horizontal lines with sharp corners to accommodate a
12424:          * scrollbar.  However, the scrollbar gets rendered on top of
12424:          * this for us, so we don't care, and can just use NOSCROLL
12424:          * here.
12424:          */
12424:         aPart = TFP_EDITBORDER_NOSCROLL;
12424: 
    1:         if (!aFrame) {
12632:           aState = TFS_EDITBORDER_NORMAL;
54683:         } else if (IsDisabled(aFrame, eventState)) {
12632:           aState = TFS_EDITBORDER_DISABLED;
12632:         } else if (IsReadOnly(aFrame)) {
12632:           /* no special read-only state */
12632:           aState = TFS_EDITBORDER_NORMAL;
12632:         } else {
12632:           nsIContent* content = aFrame->GetContent();
12632: 
12632:           /* XUL textboxes don't get focused themselves, because they have child
12632:            * html:input.. but we can check the XUL focused attributes on them
12632:            */
33329:           if (content && content->IsXUL() && IsFocused(aFrame))
12632:             aState = TFS_EDITBORDER_FOCUSED;
56168:           else if (eventState.HasAtLeastOneOfStates(NS_EVENT_STATE_ACTIVE | NS_EVENT_STATE_FOCUS))
12632:             aState = TFS_EDITBORDER_FOCUSED;
56168:           else if (eventState.HasState(NS_EVENT_STATE_HOVER))
12632:             aState = TFS_EDITBORDER_HOVER;
12632:           else
12632:             aState = TFS_EDITBORDER_NORMAL;
12632:         }
12632:       } else {
12632:         aPart = TFP_TEXTFIELD;
12632:         
12632:         if (!aFrame)
    1:           aState = TS_NORMAL;
54683:         else if (IsDisabled(aFrame, eventState))
12632:           aState = TS_DISABLED;
12632:         else if (IsReadOnly(aFrame))
12632:           aState = TFS_READONLY;
12632:         else
79626:           aState = StandardGetState(aFrame, aWidgetType, true);
    1:       }
    1: 
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_TOOLTIP: {
    1:       aPart = TTP_STANDARD;
    1:       aState = TS_NORMAL;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_PROGRESSBAR: {
69991:       aPart = IsVerticalProgress(aFrame) ? PP_BARVERT : PP_BAR;
    1:       aState = TS_NORMAL;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_PROGRESSBAR_CHUNK: {
69599:       nsIFrame* stateFrame = aFrame->GetParent();
69599:       nsEventStates eventStates = GetContentState(stateFrame, aWidgetType);
69991: 
69991:       if (IsIndeterminateProgress(stateFrame, eventStates)) {
69599:         // If the element is indeterminate, we are going to render it ourself so
69599:         // we have to return aPart = -1.
69991:         aPart = -1;
69991:       } else if (IsVerticalProgress(stateFrame)) {
69991:         aPart = nsUXThemeData::sIsVistaOrLater ? PP_FILLVERT : PP_CHUNKVERT;
69991:       } else {
69991:         aPart = nsUXThemeData::sIsVistaOrLater ? PP_FILL : PP_CHUNK;
69991:       }
69991: 
    1:       aState = TS_NORMAL;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_PROGRESSBAR_VERTICAL: {
    1:       aPart = PP_BARVERT;
    1:       aState = TS_NORMAL;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL: {
    1:       aPart = PP_CHUNKVERT;
    1:       aState = TS_NORMAL;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_TOOLBAR_BUTTON: {
    1:       aPart = BP_BUTTON;
    1:       if (!aFrame) {
    1:         aState = TS_NORMAL;
    1:         return NS_OK;
    1:       }
    1: 
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
54683:       if (IsDisabled(aFrame, eventState)) {
    1:         aState = TS_DISABLED;
    1:         return NS_OK;
    1:       }
26124:       if (IsOpenButton(aFrame)) {
26124:         aState = TS_ACTIVE;
26124:         return NS_OK;
26124:       }
54344: 
56168:       if (eventState.HasAllStates(NS_EVENT_STATE_HOVER | NS_EVENT_STATE_ACTIVE))
    1:         aState = TS_ACTIVE;
56168:       else if (eventState.HasState(NS_EVENT_STATE_HOVER)) {
    1:         if (IsCheckedButton(aFrame))
    1:           aState = TB_HOVER_CHECKED;
    1:         else
    1:           aState = TS_HOVER;
    1:       }
    1:       else {
    1:         if (IsCheckedButton(aFrame))
    1:           aState = TB_CHECKED;
    1:         else
    1:           aState = TS_NORMAL;
    1:       }
    1:      
    1:       return NS_OK;
    1:     }
 5281:     case NS_THEME_TOOLBAR_SEPARATOR: {
 5281:       aPart = TP_SEPARATOR;
 5281:       aState = TS_NORMAL;
 5281:       return NS_OK;
 5281:     }
    1:     case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT: {
    1:       aPart = SP_BUTTON;
    1:       aState = (aWidgetType - NS_THEME_SCROLLBAR_BUTTON_UP)*4;
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
    1:       if (!aFrame)
    1:         aState += TS_NORMAL;
54683:       else if (IsDisabled(aFrame, eventState))
    1:         aState += TS_DISABLED;
    1:       else {
 4756:         nsIFrame *parent = aFrame->GetParent();
56168:         nsEventStates parentState = GetContentState(parent, parent->GetStyleDisplay()->mAppearance);
56168:         if (eventState.HasAllStates(NS_EVENT_STATE_HOVER | NS_EVENT_STATE_ACTIVE))
    1:           aState += TS_ACTIVE;
56168:         else if (eventState.HasState(NS_EVENT_STATE_HOVER))
    1:           aState += TS_HOVER;
56168:         else if (nsUXThemeData::sIsVistaOrLater && parentState.HasState(NS_EVENT_STATE_HOVER))
 4756:           aState = (aWidgetType - NS_THEME_SCROLLBAR_BUTTON_UP) + SP_BUTTON_IMPLICIT_HOVER_BASE;
    1:         else
    1:           aState += TS_NORMAL;
    1:       }
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL: {
    1:       aPart = (aWidgetType == NS_THEME_SCROLLBAR_TRACK_HORIZONTAL) ?
    1:               SP_TRACKSTARTHOR : SP_TRACKSTARTVERT;
    1:       aState = TS_NORMAL;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL: {
    1:       aPart = (aWidgetType == NS_THEME_SCROLLBAR_THUMB_HORIZONTAL) ?
    1:               SP_THUMBHOR : SP_THUMBVERT;
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
    1:       if (!aFrame)
    1:         aState = TS_NORMAL;
54683:       else if (IsDisabled(aFrame, eventState))
    1:         aState = TS_DISABLED;
    1:       else {
56168:         if (eventState.HasState(NS_EVENT_STATE_ACTIVE)) // Hover is not also a requirement for
    1:                                                         // the thumb, since the drag is not canceled
    1:                                                         // when you move outside the thumb.
    1:           aState = TS_ACTIVE;
56168:         else if (eventState.HasState(NS_EVENT_STATE_HOVER))
    1:           aState = TS_HOVER;
    1:         else 
    1:           aState = TS_NORMAL;
    1:       }
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_SCALE_HORIZONTAL:
    1:     case NS_THEME_SCALE_VERTICAL: {
    1:       aPart = (aWidgetType == NS_THEME_SCALE_HORIZONTAL) ?
    1:               TKP_TRACK : TKP_TRACKVERT;
    1: 
    1:       aState = TS_NORMAL;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_SCALE_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCALE_THUMB_VERTICAL: {
    1:       aPart = (aWidgetType == NS_THEME_SCALE_THUMB_HORIZONTAL) ?
    1:               TKP_THUMB : TKP_THUMBVERT;
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
    1:       if (!aFrame)
    1:         aState = TS_NORMAL;
54683:       else if (IsDisabled(aFrame, eventState)) {
    1:         aState = TKP_DISABLED;
    1:       }
    1:       else {
56168:         if (eventState.HasState(NS_EVENT_STATE_ACTIVE)) // Hover is not also a requirement for
    1:                                                         // the thumb, since the drag is not canceled
    1:                                                         // when you move outside the thumb.
    1:           aState = TS_ACTIVE;
56168:         else if (eventState.HasState(NS_EVENT_STATE_FOCUS))
    1:           aState = TKP_FOCUSED;
56168:         else if (eventState.HasState(NS_EVENT_STATE_HOVER))
    1:           aState = TS_HOVER;
    1:         else
    1:           aState = TS_NORMAL;
    1:       }
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_SPINNER_UP_BUTTON:
    1:     case NS_THEME_SPINNER_DOWN_BUTTON: {
    1:       aPart = (aWidgetType == NS_THEME_SPINNER_UP_BUTTON) ?
    1:               SPNP_UP : SPNP_DOWN;
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
    1:       if (!aFrame)
    1:         aState = TS_NORMAL;
54683:       else if (IsDisabled(aFrame, eventState))
    1:         aState = TS_DISABLED;
    1:       else
79626:         aState = StandardGetState(aFrame, aWidgetType, false);
    1:       return NS_OK;    
    1:     }
    1:     case NS_THEME_TOOLBOX:
15048:     case NS_THEME_WIN_MEDIA_TOOLBOX:
15048:     case NS_THEME_WIN_COMMUNICATIONS_TOOLBOX:
15048:     case NS_THEME_WIN_BROWSER_TAB_BAR_TOOLBOX:
    1:     case NS_THEME_STATUSBAR:
 3459:     case NS_THEME_SCROLLBAR:
 3459:     case NS_THEME_SCROLLBAR_SMALL: {
12425:       aState = 0;
16026:       if (nsUXThemeData::sIsVistaOrLater) {
12425:         // On vista, they have a part
12425:         aPart = RP_BACKGROUND;
12425:       } else {
12425:         // Otherwise, they don't.  (But I bet
12425:         // RP_BACKGROUND would work here, too);
12425:         aPart = 0;
12425:       }
12425:       return NS_OK;
    1:     }
    1:     case NS_THEME_TOOLBAR: {
    1:       // Use -1 to indicate we don't wish to have the theme background drawn
    1:       // for this item. We will pass any nessessary information via aState,
    1:       // and will render the item using separate code.
    1:       aPart = -1;
    1:       aState = 0;
    1:       if (aFrame) {
    1:         nsIContent* content = aFrame->GetContent();
    1:         nsIContent* parent = content->GetParent();
 3477:         // XXXzeniko hiding the first toolbar will result in an unwanted margin
    1:         if (parent && parent->GetChildAt(0) == content) {
    1:           aState = 1;
    1:         }
    1:       }
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_STATUSBAR_PANEL:
    1:     case NS_THEME_STATUSBAR_RESIZER_PANEL:
    1:     case NS_THEME_RESIZER: {
    1:       aPart = (aWidgetType - NS_THEME_STATUSBAR_PANEL) + 1;
    1:       aState = TS_NORMAL;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_TREEVIEW:
    1:     case NS_THEME_LISTBOX: {
    1:       aPart = TREEVIEW_BODY;
    1:       aState = TS_NORMAL;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_TAB_PANELS: {
    1:       aPart = TABP_PANELS;
    1:       aState = TS_NORMAL;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_TAB_PANEL: {
    1:       aPart = TABP_PANEL;
    1:       aState = TS_NORMAL;
    1:       return NS_OK;
    1:     }
23290:     case NS_THEME_TAB: {
    1:       aPart = TABP_TAB;
    1:       if (!aFrame) {
    1:         aState = TS_NORMAL;
    1:         return NS_OK;
    1:       }
    1: 
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
54683:       if (IsDisabled(aFrame, eventState)) {
    1:         aState = TS_DISABLED;
    1:         return NS_OK;
    1:       }
    1: 
    1:       if (IsSelectedTab(aFrame)) {
    1:         aPart = TABP_TAB_SELECTED;
    1:         aState = TS_ACTIVE; // The selected tab is always "pressed".
    1:       }
    1:       else
79626:         aState = StandardGetState(aFrame, aWidgetType, true);
    1:       
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_TREEVIEW_HEADER_SORTARROW: {
    1:       // XXX Probably will never work due to a bug in the Luna theme.
    1:       aPart = 4;
    1:       aState = 1;
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_TREEVIEW_HEADER_CELL: {
    1:       aPart = 1;
    1:       if (!aFrame) {
    1:         aState = TS_NORMAL;
    1:         return NS_OK;
    1:       }
    1:       
79626:       aState = StandardGetState(aFrame, aWidgetType, true);
12424:       
12424:       return NS_OK;
12424:     }
12424:     case NS_THEME_DROPDOWN: {
12424:       nsIContent* content = aFrame->GetContent();
79445:       bool isHTML = content && content->IsHTML();
79445:       bool useDropBorder = isHTML || IsMenuListEditable(aFrame);
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
12632: 
72835:       /* On Vista/Win7, we use CBP_DROPBORDER instead of DROPFRAME for HTML
72835:        * content or for editable menulists; this gives us the thin outline,
72835:        * instead of the gradient-filled background */
72835:       if (useDropBorder)
12424:         aPart = CBP_DROPBORDER;
12424:       else
12424:         aPart = CBP_DROPFRAME;
12424: 
54683:       if (IsDisabled(aFrame, eventState)) {
12914:         aState = TS_DISABLED;
12914:       } else if (IsReadOnly(aFrame)) {
12914:         aState = TS_NORMAL;
26124:       } else if (IsOpenButton(aFrame)) {
12424:         aState = TS_ACTIVE;
12632:       } else {
72835:         if (useDropBorder && (eventState.HasState(NS_EVENT_STATE_FOCUS) || IsFocused(aFrame)))
12632:           aState = TS_ACTIVE;
56168:         else if (eventState.HasAllStates(NS_EVENT_STATE_HOVER | NS_EVENT_STATE_ACTIVE))
    1:           aState = TS_ACTIVE;
56168:         else if (eventState.HasState(NS_EVENT_STATE_HOVER))
    1:           aState = TS_HOVER;
    1:         else
    1:           aState = TS_NORMAL;
12632:       }
    1: 
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_DROPDOWN_BUTTON: {
79445:       bool isHTML = IsHTMLContent(aFrame);
    1:       nsIFrame* parentFrame = aFrame->GetParent();
80435:       bool isMenulist = !isHTML && parentFrame->GetType() == nsGkAtoms::menuFrame;
79445:       bool isOpen = false;
26124: 
26124:       // HTML select and XUL menulist dropdown buttons get state from the parent.
26124:       if (isHTML || isMenulist)
    1:         aFrame = parentFrame;
    1: 
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
16026:       aPart = nsUXThemeData::sIsVistaOrLater ? CBP_DROPMARKER_VISTA : CBP_DROPMARKER;
12632: 
15845:       // For HTML controls with author styling, we should fall
15845:       // back to the old dropmarker style to avoid clashes with
15845:       // author-specified backgrounds and borders (bug #441034)
15845:       if (isHTML && IsWidgetStyled(aFrame->PresContext(), aFrame, NS_THEME_DROPDOWN))
15845:         aPart = CBP_DROPMARKER;
15845: 
54683:       if (IsDisabled(aFrame, eventState)) {
12632:         aState = TS_DISABLED;
12632:         return NS_OK;
12632:       }
12632: 
26124:       if (isHTML) {
26124:         nsIComboboxControlFrame* ccf = do_QueryFrame(aFrame);
26124:         isOpen = (ccf && ccf->IsDroppedDown());
26124:       }
26124:       else
26124:         isOpen = IsOpenButton(aFrame);
26124: 
16026:       if (nsUXThemeData::sIsVistaOrLater) {
72835:         if (isHTML || IsMenuListEditable(aFrame)) {
26124:           if (isOpen) {
12632:             /* Hover is propagated, but we need to know whether we're
12632:              * hovering just the combobox frame, not the dropdown frame.
12632:              * But, we can't get that information, since hover is on the
12632:              * content node, and they share the same content node.  So,
12632:              * instead, we cheat -- if the dropdown is open, we always
12632:              * show the hover state.  This looks fine in practice.
12424:              */
12632:             aState = TS_HOVER;
12632:             return NS_OK;
12632:           }
14629:         } else {
14629:           /* On Vista, the dropdown indicator on a menulist button in  
14629:            * chrome is not given a hover effect. When the frame isn't
14629:            * isn't HTML content, we cheat and force the dropdown state
14629:            * to be normal. (Bug 430434)
14629:            */
14629:           aState = TS_NORMAL;
14629:           return NS_OK;
14629:         }
12632:       }
12632: 
26124:       aState = TS_NORMAL;
    1: 
26124:       // Dropdown button active state doesn't need :hover.
56168:       if (eventState.HasState(NS_EVENT_STATE_ACTIVE)) {
26124:         if (isOpen && (isHTML || isMenulist)) {
26124:           // XXX Button should look active until the mouse is released, but
26124:           //     without making it look active when the popup is clicked.
26124:           return NS_OK;
26124:         }
26124:         aState = TS_ACTIVE;
26124:       }
56168:       else if (eventState.HasState(NS_EVENT_STATE_HOVER)) {
26124:         // No hover effect for XUL menulists and autocomplete dropdown buttons
26124:         // while the dropdown menu is open.
26124:         if (isOpen) {
26124:           // XXX HTML select dropdown buttons should have the hover effect when
26124:           //     hovering the combobox frame, but not the popup frame.
26124:           return NS_OK;
26124:         }
26124:         aState = TS_HOVER;
26124:       }
    1:       return NS_OK;
    1:     }
 4313:     case NS_THEME_MENUPOPUP: {
 4313:       aPart = MENU_POPUPBACKGROUND;
 4313:       aState = MB_ACTIVE;
 4313:       return NS_OK;
 4313:     }
 4313:     case NS_THEME_MENUITEM:
 4313:     case NS_THEME_CHECKMENUITEM: 
 4313:     case NS_THEME_RADIOMENUITEM: {
79445:       bool isTopLevel = false;
79445:       bool isOpen = false;
79445:       bool isHover = false;
73634:       nsMenuFrame *menuFrame = do_QueryFrame(aFrame);
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
 4313: 
 4313:       isTopLevel = IsTopLevelMenu(aFrame);
 4313: 
 4313:       if (menuFrame)
 4313:         isOpen = menuFrame->IsOpen();
12424: 
12680:       isHover = IsMenuActive(aFrame, aWidgetType);
 4313: 
 4313:       if (isTopLevel) {
 4313:         aPart = MENU_BARITEM;
 4313: 
 4313:         if (isOpen)
 4313:           aState = MBI_PUSHED;
 4313:         else if (isHover)
 4313:           aState = MBI_HOT;
 4313:         else
 4313:           aState = MBI_NORMAL;
 4313: 
 4313:         // the disabled states are offset by 3
54683:         if (IsDisabled(aFrame, eventState))
 4313:           aState += 3;
 4313:       } else {
 4313:         aPart = MENU_POPUPITEM;
 4313: 
 4313:         if (isHover)
 4313:           aState = MPI_HOT;
 4313:         else
 4313:           aState = MPI_NORMAL;
 4313: 
 4313:         // the disabled states are offset by 2
54683:         if (IsDisabled(aFrame, eventState))
 4313:           aState += 2;
 4313:       }
 4313: 
 4313:       return NS_OK;
 4313:     }
 4313:     case NS_THEME_MENUSEPARATOR:
 4313:       aPart = MENU_POPUPSEPARATOR;
 4313:       aState = 0;
 4313:       return NS_OK;
 4313:     case NS_THEME_MENUARROW:
54344:       {
 4313:         aPart = MENU_POPUPSUBMENU;
56168:         nsEventStates eventState = GetContentState(aFrame, aWidgetType);
54683:         aState = IsDisabled(aFrame, eventState) ? MSM_DISABLED : MSM_NORMAL;
 4313:         return NS_OK;
54344:       }
 4313:     case NS_THEME_MENUCHECKBOX:
 4313:     case NS_THEME_MENURADIO:
 4313:       {
79445:         bool isChecked;
56168:         nsEventStates eventState = GetContentState(aFrame, aWidgetType);
54344: 
54344:         // NOTE: we can probably use NS_EVENT_STATE_CHECKED
80435:         isChecked = CheckBooleanAttr(aFrame, nsGkAtoms::checked);
 4313: 
 4313:         aPart = MENU_POPUPCHECK;
 4313:         aState = MC_CHECKMARKNORMAL;
 4313: 
 4313:         // Radio states are offset by 2
 4313:         if (aWidgetType == NS_THEME_MENURADIO)
 4313:           aState += 2;
 4313: 
 4313:         // the disabled states are offset by 1
54683:         if (IsDisabled(aFrame, eventState))
 4313:           aState += 1;
 4313: 
 4313:         return NS_OK;
 4313:       }
 4313:     case NS_THEME_MENUITEMTEXT:
 4313:     case NS_THEME_MENUIMAGE:
 4313:       aPart = -1;
 4313:       aState = 0;
 4313:       return NS_OK;
49249: 
49249:     case NS_THEME_WINDOW_TITLEBAR:
49249:       aPart = mozilla::widget::themeconst::WP_CAPTION;
49249:       aState = GetTopLevelWindowActiveState(aFrame);
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_TITLEBAR_MAXIMIZED:
49249:       aPart = mozilla::widget::themeconst::WP_MAXCAPTION;
49249:       aState = GetTopLevelWindowActiveState(aFrame);
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_FRAME_LEFT:
49249:       aPart = mozilla::widget::themeconst::WP_FRAMELEFT;
49249:       aState = GetTopLevelWindowActiveState(aFrame);
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_FRAME_RIGHT:
49249:       aPart = mozilla::widget::themeconst::WP_FRAMERIGHT;
49249:       aState = GetTopLevelWindowActiveState(aFrame);
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_FRAME_BOTTOM:
49249:       aPart = mozilla::widget::themeconst::WP_FRAMEBOTTOM;
49249:       aState = GetTopLevelWindowActiveState(aFrame);
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_BUTTON_CLOSE:
49249:       aPart = mozilla::widget::themeconst::WP_CLOSEBUTTON;
49249:       aState = GetWindowFrameButtonState(aFrame, GetContentState(aFrame, aWidgetType));
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_BUTTON_MINIMIZE:
49249:       aPart = mozilla::widget::themeconst::WP_MINBUTTON;
49249:       aState = GetWindowFrameButtonState(aFrame, GetContentState(aFrame, aWidgetType));
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_BUTTON_MAXIMIZE:
49249:       aPart = mozilla::widget::themeconst::WP_MAXBUTTON;
49249:       aState = GetWindowFrameButtonState(aFrame, GetContentState(aFrame, aWidgetType));
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_BUTTON_RESTORE:
49249:       aPart = mozilla::widget::themeconst::WP_RESTOREBUTTON;
49249:       aState = GetWindowFrameButtonState(aFrame, GetContentState(aFrame, aWidgetType));
49249:       return NS_OK;
49250:     case NS_THEME_WINDOW_BUTTON_BOX:
49250:     case NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED:
56101:     case NS_THEME_WIN_GLASS:
56101:     case NS_THEME_WIN_BORDERLESS_GLASS:
49250:       aPart = -1;
49250:       aState = 0;
49250:       return NS_OK;
    1:   }
    1: 
    1:   aPart = 0;
    1:   aState = 0;
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
68481: nsNativeThemeWin::DrawWidgetBackground(nsRenderingContext* aContext,
    1:                                        nsIFrame* aFrame,
    1:                                        PRUint8 aWidgetType,
    1:                                        const nsRect& aRect,
16193:                                        const nsRect& aDirtyRect)
    1: {
    1:   HANDLE theme = GetTheme(aWidgetType);
    1:   if (!theme)
16193:     return ClassicDrawWidgetBackground(aContext, aFrame, aWidgetType, aRect, aDirtyRect); 
    1: 
16026:   if (!nsUXThemeData::drawThemeBG)
    1:     return NS_ERROR_FAILURE;    
    1: 
49249: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN
49249:   // ^^ without the right sdk, assume xp theming and fall through.
49249:   if (nsUXThemeData::CheckForCompositor()) {
49249:     switch (aWidgetType) {
49249:       case NS_THEME_WINDOW_TITLEBAR:
49249:       case NS_THEME_WINDOW_TITLEBAR_MAXIMIZED:
49249:       case NS_THEME_WINDOW_FRAME_LEFT:
49249:       case NS_THEME_WINDOW_FRAME_RIGHT:
49249:       case NS_THEME_WINDOW_FRAME_BOTTOM:
49249:         // Nothing to draw, these areas are glass. Minimum dimensions
49249:         // should be set, so xul content should be layed out correctly.
49249:         return NS_OK;
49249:       break;
49249:       case NS_THEME_WINDOW_BUTTON_CLOSE:
49249:       case NS_THEME_WINDOW_BUTTON_MINIMIZE:
49249:       case NS_THEME_WINDOW_BUTTON_MAXIMIZE:
49249:       case NS_THEME_WINDOW_BUTTON_RESTORE:
49249:         // Not conventional bitmaps, can't be retrieved. If we fall
49249:         // through here and call the theme library we'll get aero
49249:         // basic bitmaps. 
49249:         return NS_OK;
49249:       break;
56101:       case NS_THEME_WIN_GLASS:
56101:       case NS_THEME_WIN_BORDERLESS_GLASS:
56101:         // Nothing to draw, this is the glass background.
56101:         return NS_OK;
56101:       break;
49249:     }
49249:   }
49249: #endif // MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN
49249: 
56101:   PRInt32 part, state;
56101:   nsresult rv = GetThemePartAndState(aFrame, aWidgetType, part, state);
56101:   if (NS_FAILED(rv))
56101:     return rv;
56101: 
68486:   gfxFloat p2a = gfxFloat(aContext->AppUnitsPerDevPixel());
56101:   RECT widgetRect;
56101:   RECT clipRect;
56101:   gfxRect tr(aRect.x, aRect.y, aRect.width, aRect.height),
56101:           dr(aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height);
56101: 
56101:   tr.ScaleInverse(p2a);
56101:   dr.ScaleInverse(p2a);
56101: 
56101:   /* See GetWidgetOverflow */
56101:   if (aWidgetType == NS_THEME_DROPDOWN_BUTTON &&
56101:       part == CBP_DROPMARKER_VISTA && IsHTMLContent(aFrame))
56101:   {
68634:     tr.y -= 1.0;
68634:     tr.width += 1.0;
68634:     tr.height += 2.0;
68634: 
68634:     dr.y -= 1.0;
68634:     dr.width += 1.0;
68634:     dr.height += 2.0;
69904: 
69904:     if (IsFrameRTL(aFrame)) {
69904:       tr.x -= 1.0;
69904:       dr.x -= 1.0;
69904:     }
56101:   }
56101: 
 9438:   nsRefPtr<gfxContext> ctx = aContext->ThebesContext();
    1: 
16193:   gfxWindowsNativeDrawing nativeDrawing(ctx, dr, GetWidgetNativeDrawingFlags(aWidgetType));
    1: 
    1: RENDER_AGAIN:
    1: 
    1:   HDC hdc = nativeDrawing.BeginNativeDrawing();
 4414:   if (!hdc)
 4414:     return NS_ERROR_FAILURE;
    1: 
    1:   nativeDrawing.TransformToNativeRect(tr, widgetRect);
16193:   nativeDrawing.TransformToNativeRect(dr, clipRect);
    1: 
    1: #if 0
    1:   {
76714:     PR_LOG(gWindowsLog, PR_LOG_ERROR,
76714:            (stderr, "xform: %f %f %f %f [%f %f]\n", m.xx, m.yx, m.xy, m.yy, 
76714:             m.x0, m.y0));
76714:     PR_LOG(gWindowsLog, PR_LOG_ERROR,
76714:            (stderr, "tr: [%d %d %d %d]\ndr: [%d %d %d %d]\noff: [%f %f]\n",
16193:             tr.x, tr.y, tr.width, tr.height, dr.x, dr.y, dr.width, dr.height,
76714:             offset.x, offset.y));
    1:   }
    1: #endif
    1: 
58326:   if (aWidgetType == NS_THEME_WINDOW_TITLEBAR) {
58326:     // Clip out the left and right corners of the frame, all we want in
58326:     // is the middle section.
58326:     widgetRect.left -= GetSystemMetrics(SM_CXFRAME);
58326:     widgetRect.right += GetSystemMetrics(SM_CXFRAME);
58326:   } else if (aWidgetType == NS_THEME_WINDOW_TITLEBAR_MAXIMIZED) {
58326:     // The origin of the window is off screen when maximized and windows
58326:     // doesn't compensate for this in rendering the background. Push the
58326:     // top of the bitmap down by SM_CYFRAME so we get the full graphic.
58326:     widgetRect.top += GetSystemMetrics(SM_CYFRAME);
58326:   } else if (aWidgetType == NS_THEME_TAB) {
    1:     // For left edge and right edge tabs, we need to adjust the widget
    1:     // rects and clip rects so that the edges don't get drawn.
79445:     bool isLeft = IsLeftToSelectedTab(aFrame);
79445:     bool isRight = !isLeft && IsRightToSelectedTab(aFrame);
23290: 
23290:     if (isLeft || isRight) {
    1:       // HACK ALERT: There appears to be no way to really obtain this value, so we're forced
    1:       // to just use the default value for Luna (which also happens to be correct for
    1:       // all the other skins I've tried).
    1:       PRInt32 edgeSize = 2;
    1:     
    1:       // Armed with the size of the edge, we now need to either shift to the left or to the
    1:       // right.  The clip rect won't include this extra area, so we know that we're
    1:       // effectively shifting the edge out of view (such that it won't be painted).
23290:       if (isLeft)
    1:         // The right edge should not be drawn.  Extend our rect by the edge size.
    1:         widgetRect.right += edgeSize;
    1:       else
    1:         // The left edge should not be drawn.  Move the widget rect's left coord back.
    1:         widgetRect.left -= edgeSize;
    1:     }
23290:   }
58328:   else if (aWidgetType == NS_THEME_WINDOW_BUTTON_MINIMIZE) {
58328:     OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_MINIMIZE);
58328:   }
58328:   else if (aWidgetType == NS_THEME_WINDOW_BUTTON_MAXIMIZE ||
58328:            aWidgetType == NS_THEME_WINDOW_BUTTON_RESTORE) {
58328:     OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_RESTORE);
58328:   }
58328:   else if (aWidgetType == NS_THEME_WINDOW_BUTTON_CLOSE) {
58328:     OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_CLOSE);
58328:   }
    1: 
    1:   // widgetRect is the bounding box for a widget, yet the scale track is only
    1:   // a small portion of this size, so the edges of the scale need to be
    1:   // adjusted to the real size of the track.
    1:   if (aWidgetType == NS_THEME_SCALE_HORIZONTAL ||
    1:       aWidgetType == NS_THEME_SCALE_VERTICAL) {
    1:     RECT contentRect;
16026:     nsUXThemeData::getThemeContentRect(theme, hdc, part, state, &widgetRect, &contentRect);
    1: 
    1:     SIZE siz;
16026:     nsUXThemeData::getThemePartSize(theme, hdc, part, state, &widgetRect, 1, &siz);
    1: 
    1:     if (aWidgetType == NS_THEME_SCALE_HORIZONTAL) {
    1:       PRInt32 adjustment = (contentRect.bottom - contentRect.top - siz.cy) / 2 + 1;
    1:       contentRect.top += adjustment;
    1:       contentRect.bottom -= adjustment;
    1:     }
    1:     else {
    1:       PRInt32 adjustment = (contentRect.right - contentRect.left - siz.cx) / 2 + 1;
    1:       // need to subtract one from the left position, otherwise the scale's
    1:       // border isn't visible
    1:       contentRect.left += adjustment - 1;
    1:       contentRect.right -= adjustment;
    1:     }
    1: 
16026:     nsUXThemeData::drawThemeBG(theme, hdc, part, state, &contentRect, &clipRect);
    1:   }
 4313:   else if (aWidgetType == NS_THEME_MENUCHECKBOX || aWidgetType == NS_THEME_MENURADIO)
 4313:   {
79445:       bool isChecked = false;
80435:       isChecked = CheckBooleanAttr(aFrame, nsGkAtoms::checked);
 4313: 
 4313:       if (isChecked)
 4313:       {
 4313:         int bgState = MCB_NORMAL;
56168:         nsEventStates eventState = GetContentState(aFrame, aWidgetType);
 4313: 
 4313:         // the disabled states are offset by 1
54683:         if (IsDisabled(aFrame, eventState))
 4313:           bgState += 1;
 4313: 
31799:         SIZE checkboxBGSize(GetCheckboxBGSize(theme, hdc));
 4313: 
31799:         RECT checkBGRect = widgetRect;
16045:         if (IsFrameRTL(aFrame)) {
31799:           checkBGRect.left = checkBGRect.right-checkboxBGSize.cx;
16045:         } else {
31799:           checkBGRect.right = checkBGRect.left+checkboxBGSize.cx;
16045:         }
 4313: 
31799:         // Center the checkbox background vertically in the menuitem
31799:         checkBGRect.top += (checkBGRect.bottom - checkBGRect.top)/2 - checkboxBGSize.cy/2;
31799:         checkBGRect.bottom = checkBGRect.top + checkboxBGSize.cy;
 4313: 
31799:         nsUXThemeData::drawThemeBG(theme, hdc, MENU_POPUPCHECKBACKGROUND, bgState, &checkBGRect, &clipRect);
31799: 
31799:         MARGINS checkMargins = GetCheckboxMargins(theme, hdc);
31799:         RECT checkRect = checkBGRect;
31799:         checkRect.left += checkMargins.cxLeftWidth;
31799:         checkRect.right -= checkMargins.cxRightWidth;
31799:         checkRect.top += checkMargins.cyTopHeight;
31799:         checkRect.bottom -= checkMargins.cyBottomHeight;
16026:         nsUXThemeData::drawThemeBG(theme, hdc, MENU_POPUPCHECK, state, &checkRect, &clipRect);
 4313:       }
 4313:   }
 4313:   else if (aWidgetType == NS_THEME_MENUPOPUP)
 4313:   {
16026:     nsUXThemeData::drawThemeBG(theme, hdc, MENU_POPUPBORDERS, /* state */ 0, &widgetRect, &clipRect);
 4313:     SIZE borderSize;
16026:     nsUXThemeData::getThemePartSize(theme, hdc, MENU_POPUPBORDERS, 0, NULL, TS_TRUE, &borderSize);
 4313: 
 4313:     RECT bgRect = widgetRect;
 4313:     bgRect.top += borderSize.cy;
 4313:     bgRect.bottom -= borderSize.cy;
 4313:     bgRect.left += borderSize.cx;
 4313:     bgRect.right -= borderSize.cx;
 4313: 
16026:     nsUXThemeData::drawThemeBG(theme, hdc, MENU_POPUPBACKGROUND, /* state */ 0, &bgRect, &clipRect);
 4313: 
 4313:     SIZE gutterSize(GetGutterSize(theme, hdc));
 4313: 
 4313:     RECT gutterRect;
 4313:     gutterRect.top = bgRect.top;
 4313:     gutterRect.bottom = bgRect.bottom;
16045:     if (IsFrameRTL(aFrame)) {
16045:       gutterRect.right = bgRect.right;
16045:       gutterRect.left = gutterRect.right-gutterSize.cx;
16045:     } else {
 4313:       gutterRect.left = bgRect.left;
 4313:       gutterRect.right = gutterRect.left+gutterSize.cx;
16045:     }
16045: 
16045:     DrawThemeBGRTLAware(theme, hdc, MENU_POPUPGUTTER, /* state */ 0,
16045:                         &gutterRect, &clipRect, IsFrameRTL(aFrame));
 4313:   }
 4313:   else if (aWidgetType == NS_THEME_MENUSEPARATOR)
 4313:   {
 4313:     SIZE gutterSize(GetGutterSize(theme,hdc));
 4313: 
 4313:     RECT sepRect = widgetRect;
16045:     if (IsFrameRTL(aFrame))
16045:       sepRect.right -= gutterSize.cx;
16045:     else
 4313:       sepRect.left += gutterSize.cx;
 4313: 
16026:     nsUXThemeData::drawThemeBG(theme, hdc, MENU_POPUPSEPARATOR, /* state */ 0, &sepRect, &clipRect);
 4313:   }
16045:   // The following widgets need to be RTL-aware
23890:   else if (aWidgetType == NS_THEME_MENUARROW ||
69904:            aWidgetType == NS_THEME_RESIZER ||
69904:            aWidgetType == NS_THEME_DROPDOWN_BUTTON)
23890:   {
16045:     DrawThemeBGRTLAware(theme, hdc, part, state,
16045:                         &widgetRect, &clipRect, IsFrameRTL(aFrame));
16045:   }
    1:   // If part is negative, the element wishes us to not render a themed
    1:   // background, instead opting to be drawn specially below.
    1:   else if (part >= 0) {
16026:     nsUXThemeData::drawThemeBG(theme, hdc, part, state, &widgetRect, &clipRect);
    1:   }
    1: 
    1:   // Draw focus rectangles for XP HTML checkboxes and radio buttons
    1:   // XXX it'd be nice to draw these outside of the frame
51212:   if (((aWidgetType == NS_THEME_CHECKBOX || aWidgetType == NS_THEME_RADIO) &&
51212:         aFrame->GetContent()->IsHTML()) ||
    1:       aWidgetType == NS_THEME_SCALE_HORIZONTAL ||
    1:       aWidgetType == NS_THEME_SCALE_VERTICAL) {
56168:       nsEventStates contentState = GetContentState(aFrame, aWidgetType);
56168: 
56168:       if (contentState.HasState(NS_EVENT_STATE_FOCUS)) {
    1:         POINT vpOrg;
25155:         HPEN hPen = nsnull;
25155: 
25155:         PRUint8 id = SaveDC(hdc);
25155: 
25155:         ::SelectClipRgn(hdc, NULL);
    1:         ::GetViewportOrgEx(hdc, &vpOrg);
    1:         ::SetBrushOrgEx(hdc, vpOrg.x + widgetRect.left, vpOrg.y + widgetRect.top, NULL);
25155: 
25155:         // On vista, choose our own colors and draw an XP style half focus rect
25155:         // for focused checkboxes and a full rect when active.
25155:         if (nsUXThemeData::sIsVistaOrLater && aWidgetType == NS_THEME_CHECKBOX) {
25155:           LOGBRUSH lb;
25155:           lb.lbStyle = BS_SOLID;
25155:           lb.lbColor = RGB(255,255,255);
25155:           lb.lbHatch = 0;
25155: 
25155:           hPen = ::ExtCreatePen(PS_COSMETIC|PS_ALTERNATE, 1, &lb, 0, NULL);
25155:           ::SelectObject(hdc, hPen);
25155: 
25155:           // If pressed, draw the upper left corner of the dotted rect.
56168:           if (contentState.HasState(NS_EVENT_STATE_ACTIVE)) {
25155:             ::MoveToEx(hdc, widgetRect.left, widgetRect.bottom-1, NULL);
25155:             ::LineTo(hdc, widgetRect.left, widgetRect.top);
25155:             ::LineTo(hdc, widgetRect.right-1, widgetRect.top);
25155:           }
25155: 
25155:           // Draw the lower right corner of the dotted rect.
25155:           ::MoveToEx(hdc, widgetRect.right-1, widgetRect.top, NULL);
25155:           ::LineTo(hdc, widgetRect.right-1, widgetRect.bottom-1);
25155:           ::LineTo(hdc, widgetRect.left, widgetRect.bottom-1);
25155:         } else {
25155:           ::SetTextColor(hdc, 0);
    1:           ::DrawFocusRect(hdc, &widgetRect);
25155:         }
25155:         ::RestoreDC(hdc, id);
25155:         if (hPen) {
25155:           ::DeleteObject(hPen);
25155:         }
    1:       }
    1:   }
 3477:   else if (aWidgetType == NS_THEME_TOOLBAR && state == 0) {
 3477:     // Draw toolbar separator lines above all toolbars except the first one.
 3477:     // The lines are part of the Rebar theme, which is loaded for NS_THEME_TOOLBOX.
 3477:     theme = GetTheme(NS_THEME_TOOLBOX);
 3477:     if (!theme)
 3477:       return NS_ERROR_FAILURE;
 3477: 
 3477:     widgetRect.bottom = widgetRect.top + TB_SEPARATOR_HEIGHT;
16026:     nsUXThemeData::drawThemeEdge(theme, hdc, RP_BAND, 0, &widgetRect, EDGE_ETCHED, BF_TOP, NULL);
    1:   }
16607:   else if (aWidgetType == NS_THEME_SCROLLBAR_THUMB_HORIZONTAL ||
16607:            aWidgetType == NS_THEME_SCROLLBAR_THUMB_VERTICAL)
16607:   {
16607:     // Draw the decorative gripper for the scrollbar thumb button, if it fits
16607: 
16607:     SIZE gripSize;
16607:     MARGINS thumbMgns;
16607:     int gripPart = (aWidgetType == NS_THEME_SCROLLBAR_THUMB_HORIZONTAL) ?
16607:                    SP_GRIPPERHOR : SP_GRIPPERVERT;
16607: 
16607:     if (nsUXThemeData::getThemePartSize(theme, hdc, gripPart, state, NULL, TS_TRUE, &gripSize) == S_OK &&
16607:         nsUXThemeData::getThemeMargins(theme, hdc, part, state, TMT_CONTENTMARGINS, NULL, &thumbMgns) == S_OK &&
16607:         gripSize.cx + thumbMgns.cxLeftWidth + thumbMgns.cxRightWidth <= widgetRect.right - widgetRect.left &&
16607:         gripSize.cy + thumbMgns.cyTopHeight + thumbMgns.cyBottomHeight <= widgetRect.bottom - widgetRect.top)
16607:     {
16607:       nsUXThemeData::drawThemeBG(theme, hdc, gripPart, state, &widgetRect, &clipRect);
16607:     }
16607:   }
56363:   else if ((aWidgetType == NS_THEME_WINDOW_BUTTON_BOX ||
56363:             aWidgetType == NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED) &&
56363:             nsUXThemeData::CheckForCompositor())
56098:   {
56098:     // The caption buttons are drawn by the DWM, we just need to clear the area where they
56098:     // are because we might have drawn something above them (like a background-image).
56098:     ctx->Save();
56098:     ctx->ResetClip();
68632:     ctx->Translate(dr.TopLeft());
56098: 
56098:     // Create a rounded rectangle to follow the buttons' look.
68632:     gfxRect buttonbox1(0.0, 0.0, dr.Width(), dr.Height() - 2.0);
68632:     gfxRect buttonbox2(1.0, dr.Height() - 2.0, dr.Width() - 1.0, 1.0);
68632:     gfxRect buttonbox3(2.0, dr.Height() - 1.0, dr.Width() - 3.0, 1.0);
56098: 
56098:     gfxContext::GraphicsOperator currentOp = ctx->CurrentOperator();
56098:     ctx->SetOperator(gfxContext::OPERATOR_CLEAR);
56098: 
56098:    // Each rectangle is drawn individually because OPERATOR_CLEAR takes
56098:    // the fallback path to cairo_d2d_acquire_dest if the area to fill
56098:    // is a complex region.
56098:     ctx->NewPath();
79626:     ctx->Rectangle(buttonbox1, true);
56098:     ctx->Fill();
56098: 
56098:     ctx->NewPath();
79626:     ctx->Rectangle(buttonbox2, true);
56098:     ctx->Fill();
56098: 
56098:     ctx->NewPath();
79626:     ctx->Rectangle(buttonbox3, true);
56098:     ctx->Fill();
56098: 
56098:     ctx->Restore();
56098:     ctx->SetOperator(currentOp);
69599:   } else if (aWidgetType == NS_THEME_PROGRESSBAR_CHUNK) {
69599:     /**
69599:      * Here, we draw the animated part of the progress bar.
69599:      * A progress bar has always an animated part on Windows Vista and later.
69599:      * On Windows XP, a progress bar has an animated part when in an
69599:      * indeterminated state.
69599:      * When the progress bar is indeterminated, no background is painted so we
69599:      * only see the animated part.
69599:      * When the progress bar is determinated, the animated part is a glow draw
69599:      * on top of the background (PP_FILL).
69599:      */
69599:     nsIFrame* stateFrame = aFrame->GetParent();
69599:     nsEventStates eventStates = GetContentState(stateFrame, aWidgetType);
69599:     bool indeterminate = IsIndeterminateProgress(stateFrame, eventStates);
69991:     bool vertical = IsVerticalProgress(stateFrame);
69599: 
69599:     if (indeterminate || nsUXThemeData::sIsVistaOrLater) {
74287:       if (!QueueAnimatedContentForRefresh(aFrame->GetContent(), 30)) {
69598:         NS_WARNING("unable to animate progress widget!");
69598:       }
69598: 
69991:       /**
69991:        * Unfortunately, vertical progress bar support on Windows seems weak and
69991:        * PP_MOVEOVERLAYRECT looks really different from PP_MOVEOVERLAY.
69991:        * Thus, we have to change the size and even don't use it for vertical
69991:        * indeterminate progress bars.
69991:        */
69991:       PRInt32 overlaySize;
69991:       if (nsUXThemeData::sIsVistaOrLater) {
69991:         if (vertical) {
69991:           overlaySize = indeterminate ? kProgressVerticalIndeterminateOverlaySize
69991:                                       : kProgressVerticalOverlaySize;
69991:         } else {
69991:           overlaySize = kProgressHorizontalVistaOverlaySize;
69991:         }
69991:       } else {
69991:         overlaySize = kProgressHorizontalXPOverlaySize;
69991:       }
69991: 
69599:       const double pixelsPerMillisecond = indeterminate
69599:                                             ? kProgressIndeterminateSpeed
69599:                                             : kProgressDeterminedVistaSpeed;
69600:       const PRInt32 delay = indeterminate ? kProgressIndeterminateDelay
69600:                                           : kProgressDeterminedVistaDelay;
69599: 
69991:       const PRInt32 frameSize = vertical ? widgetRect.bottom - widgetRect.top
69991:                                          : widgetRect.right - widgetRect.left;
69991:       const PRInt32 animationSize = frameSize + overlaySize +
69600:                                      static_cast<PRInt32>(pixelsPerMillisecond * delay);
69991:       const double interval = animationSize / pixelsPerMillisecond;
69598:       // We have to pass a double* to modf and we can't pass NULL.
69598:       double tempValue;
69598:       double ratio = modf(PR_IntervalToMilliseconds(PR_IntervalNow())/interval,
69598:                           &tempValue);
69601:       // If the frame direction is RTL, we want to have the animation going RTL.
69601:       // ratio is in [0.0; 1.0[ range, inverting it reverse the animation.
69991:       if (!vertical && IsFrameRTL(aFrame)) {
69601:         ratio = 1.0 - ratio;
69601:       }
69991:       PRInt32 dx = static_cast<PRInt32>(animationSize * ratio) - overlaySize;
69598: 
69598:       RECT overlayRect = widgetRect;
69991:       if (vertical) {
69991:         overlayRect.bottom -= dx;
69991:         overlayRect.top = overlayRect.bottom - overlaySize;
69991:       } else {
69598:         overlayRect.left += dx;
69991:         overlayRect.right = overlayRect.left + overlaySize;
69991:       }
69991: 
69991:       PRInt32 overlayPart;
69991:       if (vertical) {
69991:         if (nsUXThemeData::sIsVistaOrLater) {
69991:           overlayPart = indeterminate ? PP_MOVEOVERLAY : PP_MOVEOVERLAYVERT;
69991:         } else {
69991:           overlayPart = PP_CHUNKVERT;
69991:         }
69991:       } else {
69991:         overlayPart = nsUXThemeData::sIsVistaOrLater ? PP_MOVEOVERLAY : PP_CHUNK;
69991:       }
69991: 
69991:       nsUXThemeData::drawThemeBG(theme, hdc, overlayPart, state, &overlayRect,
69991:                                  &clipRect);
69599:     }
56098:   }
56098: 
    1: 
    1:   nativeDrawing.EndNativeDrawing();
    1: 
    1:   if (nativeDrawing.ShouldRenderAgain())
    1:     goto RENDER_AGAIN;
    1: 
    1:   nativeDrawing.PaintToContext();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
68668: nsNativeThemeWin::GetWidgetBorder(nsDeviceContext* aContext, 
    1:                                   nsIFrame* aFrame,
    1:                                   PRUint8 aWidgetType,
23738:                                   nsIntMargin* aResult)
    1: {
    1:   HANDLE theme = GetTheme(aWidgetType);
    1:   if (!theme)
    1:     return ClassicGetWidgetBorder(aContext, aFrame, aWidgetType, aResult); 
    1: 
    1:   (*aResult).top = (*aResult).bottom = (*aResult).left = (*aResult).right = 0;
    1: 
    1:   if (!WidgetIsContainer(aWidgetType) ||
    1:       aWidgetType == NS_THEME_TOOLBOX || 
15048:       aWidgetType == NS_THEME_WIN_MEDIA_TOOLBOX ||
15048:       aWidgetType == NS_THEME_WIN_COMMUNICATIONS_TOOLBOX ||
15048:       aWidgetType == NS_THEME_WIN_BROWSER_TAB_BAR_TOOLBOX ||
    1:       aWidgetType == NS_THEME_STATUSBAR || 
    1:       aWidgetType == NS_THEME_RESIZER || aWidgetType == NS_THEME_TAB_PANEL ||
    1:       aWidgetType == NS_THEME_SCROLLBAR_TRACK_HORIZONTAL ||
 4313:       aWidgetType == NS_THEME_SCROLLBAR_TRACK_VERTICAL ||
 4313:       aWidgetType == NS_THEME_MENUITEM || aWidgetType == NS_THEME_CHECKMENUITEM ||
 4313:       aWidgetType == NS_THEME_RADIOMENUITEM || aWidgetType == NS_THEME_MENUPOPUP ||
 5281:       aWidgetType == NS_THEME_MENUIMAGE || aWidgetType == NS_THEME_MENUITEMTEXT ||
56101:       aWidgetType == NS_THEME_TOOLBAR_SEPARATOR ||
58328:       aWidgetType == NS_THEME_WINDOW_TITLEBAR ||
58328:       aWidgetType == NS_THEME_WINDOW_TITLEBAR_MAXIMIZED ||
56101:       aWidgetType == NS_THEME_WIN_GLASS || aWidgetType == NS_THEME_WIN_BORDERLESS_GLASS)
    1:     return NS_OK; // Don't worry about it.
    1: 
16026:   if (!nsUXThemeData::getThemeContentRect)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PRInt32 part, state;
    1:   nsresult rv = GetThemePartAndState(aFrame, aWidgetType, part, state);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
 3477:   if (aWidgetType == NS_THEME_TOOLBAR) {
 3477:     // make space for the separator line above all toolbars but the first
 3477:     if (state == 0)
 3477:       aResult->top = TB_SEPARATOR_HEIGHT;
 3477:     return NS_OK;
 3477:   }
 3477: 
    1:   // Get our info.
    1:   RECT outerRect; // Create a fake outer rect.
    1:   outerRect.top = outerRect.left = 100;
    1:   outerRect.right = outerRect.bottom = 200;
    1:   RECT contentRect(outerRect);
16026:   HRESULT res = nsUXThemeData::getThemeContentRect(theme, NULL, part, state, &outerRect, &contentRect);
    1:   
    1:   if (FAILED(res))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Now compute the delta in each direction and place it in our
23738:   // nsIntMargin struct.
    1:   aResult->top = contentRect.top - outerRect.top;
    1:   aResult->bottom = outerRect.bottom - contentRect.bottom;
    1:   aResult->left = contentRect.left - outerRect.left;
    1:   aResult->right = outerRect.right - contentRect.right;
    1: 
    1:   // Remove the edges for tabs that are before or after the selected tab,
23290:   if (aWidgetType == NS_THEME_TAB) {
23290:     if (IsLeftToSelectedTab(aFrame))
    1:       // Remove the right edge, since we won't be drawing it.
    1:       aResult->right = 0;
23290:     else if (IsRightToSelectedTab(aFrame))
    1:       // Remove the left edge, since we won't be drawing it.
    1:       aResult->left = 0;
23290:   }
    1: 
 1191:   if (aFrame && (aWidgetType == NS_THEME_TEXTFIELD || aWidgetType == NS_THEME_TEXTFIELD_MULTILINE)) {
    1:     nsIContent* content = aFrame->GetContent();
33329:     if (content && content->IsHTML()) {
    1:       // We need to pad textfields by 1 pixel, since the caret will draw
    1:       // flush against the edge by default if we don't.
    1:       aResult->top++;
    1:       aResult->left++;
    1:       aResult->bottom++;
    1:       aResult->right++;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
79445: bool
68668: nsNativeThemeWin::GetWidgetPadding(nsDeviceContext* aContext, 
    1:                                    nsIFrame* aFrame,
    1:                                    PRUint8 aWidgetType,
23738:                                    nsIntMargin* aResult)
    1: {
12732:   switch (aWidgetType) {
12732:     // Radios and checkboxes return a fixed size in GetMinimumWidgetSize
12732:     // and have a meaningful baseline, so they can't have
12732:     // author-specified padding.
12732:     case NS_THEME_CHECKBOX:
12732:     case NS_THEME_RADIO:
12732:       aResult->SizeTo(0, 0, 0, 0);
79626:       return true;
12732:   }
12732: 
 4313:   HANDLE theme = GetTheme(aWidgetType);
49250: 
49250:   if (aWidgetType == NS_THEME_WINDOW_BUTTON_BOX ||
49250:       aWidgetType == NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED) {
49250:     aResult->SizeTo(0, 0, 0, 0);
49250: 
49250: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN
49250:     // aero glass doesn't display custom buttons
49250:     if (nsUXThemeData::CheckForCompositor())
79626:       return true;
49250: #endif
49250: 
49250:     // button padding for standard windows
49250:     if (aWidgetType == NS_THEME_WINDOW_BUTTON_BOX) {
49250:       aResult->top = GetSystemMetrics(SM_CXFRAME);
49250:     }
79626:     return true;
49250:   }
49250: 
49250:   // Content padding
49250:   if (aWidgetType == NS_THEME_WINDOW_TITLEBAR ||
49250:       aWidgetType == NS_THEME_WINDOW_TITLEBAR_MAXIMIZED) {
49250:     aResult->SizeTo(0, 0, 0, 0);
49250:     // Maximized windows have an offscreen offset equal to
49250:     // the border padding. (windows quirk)
49250:     if (aWidgetType == NS_THEME_WINDOW_TITLEBAR_MAXIMIZED)
49250:       aResult->top = GetSystemMetrics(SM_CXFRAME);
79626:     return true;
49250:   }
49250: 
15078:   if (!theme)
72222:     return ClassicGetWidgetPadding(aContext, aFrame, aWidgetType, aResult);
 4313: 
 4313:   if (aWidgetType == NS_THEME_MENUPOPUP)
 4313:   {
 4313:     SIZE popupSize;
16026:     nsUXThemeData::getThemePartSize(theme, NULL, MENU_POPUPBORDERS, /* state */ 0, NULL, TS_TRUE, &popupSize);
 4313:     aResult->top = aResult->bottom = popupSize.cy;
 4313:     aResult->left = aResult->right = popupSize.cx;
79626:     return true;
 4313:   }
 4313: 
16026:   if (nsUXThemeData::sIsVistaOrLater) {
14697:     if (aWidgetType == NS_THEME_TEXTFIELD ||
14697:         aWidgetType == NS_THEME_TEXTFIELD_MULTILINE ||
14697:         aWidgetType == NS_THEME_DROPDOWN)
14697:     {
14697:       /* If we have author-specified padding for these elements, don't do the fixups below */
14697:       if (aFrame->PresContext()->HasAuthorSpecifiedRules(aFrame, NS_AUTHOR_SPECIFIED_PADDING))
79626:         return false;
14697:     }
14697: 
14553:     /* textfields need extra pixels on all sides, otherwise they
12424:      * wrap their content too tightly.  The actual border is drawn 1px
12424:      * inside the specified rectangle, so Gecko will end up making the
14553:      * contents look too small.  Instead, we add 2px padding for the
14553:      * contents and fix this. (Used to be 1px added, see bug 430212)
12424:      */
12424:     if (aWidgetType == NS_THEME_TEXTFIELD || aWidgetType == NS_THEME_TEXTFIELD_MULTILINE) {
14553:       aResult->top = aResult->bottom = 2;
14553:       aResult->left = aResult->right = 2;
79626:       return true;
14697:     } else if (IsHTMLContent(aFrame) && aWidgetType == NS_THEME_DROPDOWN) {
12424:       /* For content menulist controls, we need an extra pixel so
12424:        * that we have room to draw our focus rectangle stuff.
12542:        * Otherwise, the focus rect might overlap the control's
12424:        * border.
12424:        */
12424:       aResult->top = aResult->bottom = 1;
12424:       aResult->left = aResult->right = 1;
79626:       return true;
12424:     }
12424:   }
12424: 
 4313:   PRInt32 right, left, top, bottom;
 4313:   right = left = top = bottom = 0;
 4313:   switch (aWidgetType)
 4313:   {
 4313:     case NS_THEME_MENUIMAGE:
15078:         right = 8;
 4313:         left = 3;
 4313:         break;
 4313:     case NS_THEME_MENUCHECKBOX:
 4313:     case NS_THEME_MENURADIO:
 4757:         right = 8;
 4313:         left = 0;
 4313:         break;
 4313:     case NS_THEME_MENUITEMTEXT:
 4313:         // There seem to be exactly 4 pixels from the edge
15078:         // of the gutter to the text: 2px margin (CSS) + 2px padding (here)
15438:         {
 4313:           SIZE size(GetGutterSize(theme, NULL));
15078:           left = size.cx + 2;
15438:         }
 4313:         break;
 4313:     case NS_THEME_MENUSEPARATOR:
 4313:         {
 4313:           SIZE size(GetGutterSize(theme, NULL));
 4313:           left = size.cx + 5;
 4313:           top = 10;
 4313:           bottom = 7;
 4313:         }
 4313:         break;
 4313:     default:
79626:         return false;
 4313:   }
 4313: 
 4313:   if (IsFrameRTL(aFrame))
 4313:   {
 4313:     aResult->right = left;
 4313:     aResult->left = right;
 4313:   }
 4313:   else
 4313:   {
 4313:     aResult->right = right;
 4313:     aResult->left = left;
 4313:   }
 4313:   
79626:   return true;
    1: }
    1: 
79445: bool
68668: nsNativeThemeWin::GetWidgetOverflow(nsDeviceContext* aContext, 
12424:                                     nsIFrame* aFrame,
13812:                                     PRUint8 aOverflowRect,
12424:                                     nsRect* aResult)
12424: {
12494:   /* This is disabled for now, because it causes invalidation problems --
47643:    * see bug 420381.  The effect of not updating the overflow area is that
12494:    * for dropdown buttons in content areas, there is a 1px border on 3 sides
12494:    * where, if invalidated, the dropdown control probably won't be repainted.
12494:    * This is fairly minor, as by default there is nothing in that area, and
12494:    * a border only shows up if the widget is being hovered.
12494:    */
12494: #if 0
16026:   if (nsUXThemeData::sIsVistaOrLater) {
12424:     /* We explicitly draw dropdown buttons in HTML content 1px bigger
12424:      * up, right, and bottom so that they overlap the dropdown's border
12424:      * like they're supposed to.
12424:      */
12424:     if (aWidgetType == NS_THEME_DROPDOWN_BUTTON &&
15845:         IsHTMLContent(aFrame) &&
15845:         !IsWidgetStyled(aFrame->GetParent()->PresContext(),
15845:                         aFrame->GetParent(),
15845:                         NS_THEME_DROPDOWN))
12424:     {
12424:       PRInt32 p2a = aContext->AppUnitsPerDevPixel();
12424:       /* Note: no overflow on the left */
12424:       nsMargin m(0, p2a, p2a, p2a);
13812:       aOverflowRect->Inflate (m);
79626:       return true;
12424:     }
12424:   }
12494: #endif
12424: 
79626:   return false;
12424: }
12424: 
    1: NS_IMETHODIMP
68481: nsNativeThemeWin::GetMinimumWidgetSize(nsRenderingContext* aContext, nsIFrame* aFrame,
    1:                                        PRUint8 aWidgetType,
79445:                                        nsIntSize* aResult, bool* aIsOverridable)
    1: {
    1:   (*aResult).width = (*aResult).height = 0;
79626:   *aIsOverridable = true;
    1: 
    1:   HANDLE theme = GetTheme(aWidgetType);
    1:   if (!theme)
    1:     return ClassicGetMinimumWidgetSize(aContext, aFrame, aWidgetType, aResult, aIsOverridable);
    1: 
26455:   switch (aWidgetType) {
33847:     case NS_THEME_GROUPBOX:
26455:     case NS_THEME_TEXTFIELD:
26455:     case NS_THEME_TOOLBOX:
26455:     case NS_THEME_WIN_MEDIA_TOOLBOX:
26455:     case NS_THEME_WIN_COMMUNICATIONS_TOOLBOX:
26455:     case NS_THEME_WIN_BROWSER_TAB_BAR_TOOLBOX:
26455:     case NS_THEME_TOOLBAR:
26455:     case NS_THEME_STATUSBAR:
26455:     case NS_THEME_PROGRESSBAR_CHUNK:
26455:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
26455:     case NS_THEME_TAB_PANELS:
26455:     case NS_THEME_TAB_PANEL:
26455:     case NS_THEME_LISTBOX:
26455:     case NS_THEME_TREEVIEW:
26455:     case NS_THEME_MENUITEMTEXT:
56101:     case NS_THEME_WIN_GLASS:
56101:     case NS_THEME_WIN_BORDERLESS_GLASS:
    1:       return NS_OK; // Don't worry about it.
26455:   }
    1: 
 4313:   if (aWidgetType == NS_THEME_MENUITEM && IsTopLevelMenu(aFrame))
 4313:       return NS_OK; // Don't worry about it for top level menus
 4313: 
16026:   if (!nsUXThemeData::getThemePartSize)
    1:     return NS_ERROR_FAILURE;
    1:   
    1:   // Call GetSystemMetrics to determine size for WinXP scrollbars
    1:   // (GetThemeSysSize API returns the optimal size for the theme, but 
    1:   //  Windows appears to always use metrics when drawing standard scrollbars)
49248:   PRInt32 sizeReq = TS_TRUE; // Best-fit size
    1:   switch (aWidgetType) {
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:     case NS_THEME_DROPDOWN_BUTTON:
    1:       return ClassicGetMinimumWidgetSize(aContext, aFrame, aWidgetType, aResult, aIsOverridable);
49248: 
 4313:     case NS_THEME_MENUITEM:
 4313:     case NS_THEME_CHECKMENUITEM:
 4313:     case NS_THEME_RADIOMENUITEM:
 4313:       if(!IsTopLevelMenu(aFrame))
 4313:       {
 4313:         SIZE gutterSize(GetGutterSize(theme, NULL));
 4313:         aResult->width = gutterSize.cx;
 4313:         aResult->height = gutterSize.cy;
 4313:         return NS_OK;
 4313:       }
 4313:       break;
49248: 
 4313:     case NS_THEME_MENUIMAGE:
 4313:     case NS_THEME_MENUCHECKBOX:
 4313:     case NS_THEME_MENURADIO:
 4313:       {
 4313:         SIZE boxSize(GetGutterSize(theme, NULL));
15078:         aResult->width = boxSize.cx+2;
 4313:         aResult->height = boxSize.cy;
79626:         *aIsOverridable = false;
 4313:       }
49248: 
 4313:     case NS_THEME_MENUITEMTEXT:
 4313:       return NS_OK;
49248: 
 4313:     case NS_THEME_MENUARROW:
 4313:       aResult->width = 26;
 4313:       aResult->height = 16;
 4313:       return NS_OK;
    1: 
49248:     case NS_THEME_PROGRESSBAR:
49248:     case NS_THEME_PROGRESSBAR_VERTICAL:
49248:       // Best-fit size for progress meters is too large for most 
49248:       // themes. We want these widgets to be able to really shrink
49248:       // down, so use the min-size request value (of 0).
49248:       sizeReq = TS_MIN; 
49248:       break;
49248: 
49248:     case NS_THEME_RESIZER:
79626:       *aIsOverridable = false;
49248:       break;
49248: 
49248:     case NS_THEME_SCALE_THUMB_HORIZONTAL:
49248:     case NS_THEME_SCALE_THUMB_VERTICAL:
49248:     {
79626:       *aIsOverridable = false;
11249:       // on Vista, GetThemePartAndState returns odd values for
11249:       // scale thumbs, so use a hardcoded size instead.
16026:       if (nsUXThemeData::sIsVistaOrLater) {
11249:         if (aWidgetType == NS_THEME_SCALE_THUMB_HORIZONTAL) {
11249:           aResult->width = 12;
11249:           aResult->height = 20;
11249:         }
11249:         else {
11249:           aResult->width = 20;
11249:           aResult->height = 12;
11249:         }
11249:         return NS_OK;
11249:       }
49248:       break;
    1:     }
49248: 
49248:     case NS_THEME_TOOLBAR_SEPARATOR:
 5281:       // that's 2px left margin, 2px right margin and 2px separator
 5281:       // (the margin is drawn as part of the separator, though)
 5281:       aResult->width = 6;
 5281:       return NS_OK;
49248: 
49248:     case NS_THEME_BUTTON:
49248:       // We should let HTML buttons shrink to their min size.
49248:       // FIXME bug 403934: We should probably really separate
49248:       // GetPreferredWidgetSize from GetMinimumWidgetSize, so callers can
49248:       // use the one they want.
49248:       if (aFrame->GetContent()->IsHTML()) {
49248:         sizeReq = TS_MIN;
49248:       }
49248:       break;
49249: 
49249:     case NS_THEME_WINDOW_BUTTON_MAXIMIZE:
49249:     case NS_THEME_WINDOW_BUTTON_RESTORE:
49249:       // The only way to get accurate titlebar button info is to query a
49249:       // window w/buttons when it's visible. nsWindow takes care of this and
49249:       // stores that info in nsUXThemeData.
49250:       QueryForButtonData(aFrame);
49249:       aResult->width = nsUXThemeData::sCommandButtons[CMDBUTTONIDX_RESTORE].cx;
49249:       aResult->height = nsUXThemeData::sCommandButtons[CMDBUTTONIDX_RESTORE].cy;
49250:       // For XP, subtract 4 from system metrics dimensions.
49250:       if (nsWindow::GetWindowsVersion() == WINXP_VERSION) {
49250:         aResult->width -= 4;
49250:         aResult->height -= 4;
49250:       }
58328:       AddPaddingRect(aResult, CAPTIONBUTTON_RESTORE);
79626:       *aIsOverridable = false;
49249:       return NS_OK;
49249: 
49249:     case NS_THEME_WINDOW_BUTTON_MINIMIZE:
49250:       QueryForButtonData(aFrame);
49249:       aResult->width = nsUXThemeData::sCommandButtons[CMDBUTTONIDX_MINIMIZE].cx;
49249:       aResult->height = nsUXThemeData::sCommandButtons[CMDBUTTONIDX_MINIMIZE].cy;
49250:       if (nsWindow::GetWindowsVersion() == WINXP_VERSION) {
49250:         aResult->width -= 4;
49250:         aResult->height -= 4;
49250:       }
58328:       AddPaddingRect(aResult, CAPTIONBUTTON_MINIMIZE);
79626:       *aIsOverridable = false;
49249:       return NS_OK;
49249: 
49249:     case NS_THEME_WINDOW_BUTTON_CLOSE:
49250:       QueryForButtonData(aFrame);
49249:       aResult->width = nsUXThemeData::sCommandButtons[CMDBUTTONIDX_CLOSE].cx;
49249:       aResult->height = nsUXThemeData::sCommandButtons[CMDBUTTONIDX_CLOSE].cy;
49250:       if (nsWindow::GetWindowsVersion() == WINXP_VERSION) {
49250:         aResult->width -= 4;
49250:         aResult->height -= 4;
49250:       }
58328:       AddPaddingRect(aResult, CAPTIONBUTTON_CLOSE);
79626:       *aIsOverridable = false;
49249:       return NS_OK;
49249: 
49249:     case NS_THEME_WINDOW_TITLEBAR:
49249:     case NS_THEME_WINDOW_TITLEBAR_MAXIMIZED:
49249:       aResult->height = GetSystemMetrics(SM_CYCAPTION);
49249:       aResult->height += GetSystemMetrics(SM_CYFRAME);
79626:       *aIsOverridable = false;
49249:       return NS_OK;
49249: 
56099:     case NS_THEME_WINDOW_BUTTON_BOX:
56099:     case NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED:
56364:       if (nsUXThemeData::CheckForCompositor()) {
56099:         QueryForButtonData(aFrame);
56099:         aResult->width = nsUXThemeData::sCommandButtons[CMDBUTTONIDX_BUTTONBOX].cx;
56099:         aResult->height = nsUXThemeData::sCommandButtons[CMDBUTTONIDX_BUTTONBOX].cy
56099:                           - GetSystemMetrics(SM_CYFRAME);
56099:         if (aWidgetType == NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED) {
56099:           aResult->width += 1;
56099:           aResult->height -= 2;
56099:         }
79626:         *aIsOverridable = false;
56099:         return NS_OK;
56364:       }
56364:       break;
56099: 
49249:     case NS_THEME_WINDOW_FRAME_LEFT:
49249:     case NS_THEME_WINDOW_FRAME_RIGHT:
49249:     case NS_THEME_WINDOW_FRAME_BOTTOM:
49249:       aResult->width = GetSystemMetrics(SM_CXFRAME);
49249:       aResult->height = GetSystemMetrics(SM_CYFRAME);
79626:       *aIsOverridable = false;
49249:       return NS_OK;
 5281:   }
    1: 
    1:   PRInt32 part, state;
    1:   nsresult rv = GetThemePartAndState(aFrame, aWidgetType, part, state);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
51036:   HDC hdc = gfxWindowsPlatform::GetPlatform()->GetScreenDC();
    1:   if (!hdc)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   SIZE sz;
16026:   nsUXThemeData::getThemePartSize(theme, hdc, part, state, NULL, sizeReq, &sz);
    1:   aResult->width = sz.cx;
    1:   aResult->height = sz.cy;
    1: 
49248:   switch(aWidgetType) {
49248:     case NS_THEME_SPINNER_UP_BUTTON:
49248:     case NS_THEME_SPINNER_DOWN_BUTTON:
    1:       aResult->width++;
    1:       aResult->height = aResult->height / 2 + 1;
49248:       break;
49248: 
49248:     case NS_THEME_MENUSEPARATOR:
 4313:     {
 4313:       SIZE gutterSize(GetGutterSize(theme,hdc));
 4313:       aResult->width += gutterSize.cx;
49248:       break;
 4313:     }
49248:   }
49248: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNativeThemeWin::WidgetStateChanged(nsIFrame* aFrame, PRUint8 aWidgetType, 
79445:                                      nsIAtom* aAttribute, bool* aShouldRepaint)
    1: {
    1:   // Some widget types just never change state.
12425:   if (aWidgetType == NS_THEME_TOOLBOX ||
15048:       aWidgetType == NS_THEME_WIN_MEDIA_TOOLBOX ||
15048:       aWidgetType == NS_THEME_WIN_COMMUNICATIONS_TOOLBOX ||
15048:       aWidgetType == NS_THEME_WIN_BROWSER_TAB_BAR_TOOLBOX ||
12425:       aWidgetType == NS_THEME_TOOLBAR ||
    1:       aWidgetType == NS_THEME_STATUSBAR || aWidgetType == NS_THEME_STATUSBAR_PANEL ||
    1:       aWidgetType == NS_THEME_STATUSBAR_RESIZER_PANEL ||
    1:       aWidgetType == NS_THEME_PROGRESSBAR_CHUNK ||
    1:       aWidgetType == NS_THEME_PROGRESSBAR_CHUNK_VERTICAL ||
    1:       aWidgetType == NS_THEME_PROGRESSBAR ||
    1:       aWidgetType == NS_THEME_PROGRESSBAR_VERTICAL ||
    1:       aWidgetType == NS_THEME_TOOLTIP ||
    1:       aWidgetType == NS_THEME_TAB_PANELS ||
 5281:       aWidgetType == NS_THEME_TAB_PANEL ||
56101:       aWidgetType == NS_THEME_TOOLBAR_SEPARATOR ||
56101:       aWidgetType == NS_THEME_WIN_GLASS ||
56101:       aWidgetType == NS_THEME_WIN_BORDERLESS_GLASS) {
79626:     *aShouldRepaint = false;
    1:     return NS_OK;
    1:   }
    1: 
49249:   if (aWidgetType == NS_THEME_WINDOW_TITLEBAR ||
49249:       aWidgetType == NS_THEME_WINDOW_TITLEBAR_MAXIMIZED ||
49249:       aWidgetType == NS_THEME_WINDOW_FRAME_LEFT ||
49249:       aWidgetType == NS_THEME_WINDOW_FRAME_RIGHT ||
49249:       aWidgetType == NS_THEME_WINDOW_FRAME_BOTTOM ||
49249:       aWidgetType == NS_THEME_WINDOW_BUTTON_CLOSE ||
49249:       aWidgetType == NS_THEME_WINDOW_BUTTON_MINIMIZE ||
49249:       aWidgetType == NS_THEME_WINDOW_BUTTON_MINIMIZE ||
49249:       aWidgetType == NS_THEME_WINDOW_BUTTON_RESTORE) {
79626:     *aShouldRepaint = true;
49249:     return NS_OK;
49249:   }
49249: 
 4756:   // On Vista, the scrollbar buttons need to change state when the track has/doesn't have hover
16026:   if (!nsUXThemeData::sIsVistaOrLater &&
 4756:       (aWidgetType == NS_THEME_SCROLLBAR_TRACK_VERTICAL || 
 4756:       aWidgetType == NS_THEME_SCROLLBAR_TRACK_HORIZONTAL)) {
79626:     *aShouldRepaint = false;
 4756:     return NS_OK;
 4756:   }
 4756: 
12632:   // We need to repaint the dropdown arrow in vista HTML combobox controls when
12632:   // the control is closed to get rid of the hover effect.
16026:   if (nsUXThemeData::sIsVistaOrLater &&
12632:       (aWidgetType == NS_THEME_DROPDOWN || aWidgetType == NS_THEME_DROPDOWN_BUTTON) &&
12632:       IsHTMLContent(aFrame))
12632:   {
79626:     *aShouldRepaint = true;
12632:     return NS_OK;
12632:   }
12632: 
    1:   // XXXdwh Not sure what can really be done here.  Can at least guess for
    1:   // specific widgets that they're highly unlikely to have certain states.
    1:   // For example, a toolbar doesn't care about any states.
    1:   if (!aAttribute) {
    1:     // Hover/focus/active changed.  Always repaint.
79626:     *aShouldRepaint = true;
    1:   }
    1:   else {
    1:     // Check the attribute to see if it's relevant.  
    1:     // disabled, checked, dlgtype, default, etc.
79626:     *aShouldRepaint = false;
80435:     if (aAttribute == nsGkAtoms::disabled ||
80435:         aAttribute == nsGkAtoms::checked ||
80435:         aAttribute == nsGkAtoms::selected ||
80435:         aAttribute == nsGkAtoms::readonly ||
80435:         aAttribute == nsGkAtoms::open ||
80435:         aAttribute == nsGkAtoms::menuactive ||
80435:         aAttribute == nsGkAtoms::focused)
79626:       *aShouldRepaint = true;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNativeThemeWin::ThemeChanged()
    1: {
16026:   nsUXThemeData::Invalidate();
    1:   return NS_OK;
    1: }
    1: 
79445: bool 
    1: nsNativeThemeWin::ThemeSupportsWidget(nsPresContext* aPresContext,
    1:                                       nsIFrame* aFrame,
    1:                                       PRUint8 aWidgetType)
    1: {
    1:   // XXXdwh We can go even further and call the API to ask if support exists for
    1:   // specific widgets.
    1: 
    1:   if (aPresContext && !aPresContext->PresShell()->IsThemeSupportEnabled())
79626:     return false;
    1: 
    1:   HANDLE theme = NULL;
    1:   if (aWidgetType == NS_THEME_CHECKBOX_CONTAINER)
    1:     theme = GetTheme(NS_THEME_CHECKBOX);
    1:   else if (aWidgetType == NS_THEME_RADIO_CONTAINER)
    1:     theme = GetTheme(NS_THEME_RADIO);
    1:   else
    1:     theme = GetTheme(aWidgetType);
    1: 
    1:   if ((theme) || (!theme && ClassicThemeSupportsWidget(aPresContext, aFrame, aWidgetType)))
    1:     // turn off theming for some HTML widgets styled by the page
    1:     return (!IsWidgetStyled(aPresContext, aFrame, aWidgetType));
    1:   
79626:   return false;
    1: }
    1: 
79445: bool 
    1: nsNativeThemeWin::WidgetIsContainer(PRUint8 aWidgetType)
    1: {
    1:   // XXXdwh At some point flesh all of this out.
    1:   if (aWidgetType == NS_THEME_DROPDOWN_BUTTON || 
21220:       aWidgetType == NS_THEME_RADIO ||
21220:       aWidgetType == NS_THEME_CHECKBOX)
79626:     return false;
79626:   return true;
    1: }
    1: 
79445: bool
    1: nsNativeThemeWin::ThemeDrawsFocusForWidget(nsPresContext* aPresContext, nsIFrame* aFrame, PRUint8 aWidgetType)
    1: {
79626:   return false;
    1: }
    1: 
79445: bool
 1582: nsNativeThemeWin::ThemeNeedsComboboxDropmarker()
 1582: {
79626:   return true;
 1582: }
 1582: 
43487: nsITheme::Transparency
43487: nsNativeThemeWin::GetWidgetTransparency(nsIFrame* aFrame, PRUint8 aWidgetType)
22675: {
54064:   switch (aWidgetType) {
54064:   case NS_THEME_SCROLLBAR_SMALL:
54064:   case NS_THEME_SCROLLBAR:
54064:   case NS_THEME_STATUSBAR:
54064:     // Knowing that scrollbars and statusbars are opaque improves
54064:     // performance, because we create layers for them. This better be
54064:     // true across all Windows themes! If it's not true, we should
54064:     // paint an opaque background for them to make it true!
54064:     return eOpaque;
56101:   case NS_THEME_WIN_GLASS:
56101:   case NS_THEME_WIN_BORDERLESS_GLASS:
61400:   case NS_THEME_SCALE_HORIZONTAL:
61400:   case NS_THEME_SCALE_VERTICAL:
56101:     return eTransparent;
54064:   }
54064: 
43487:   HANDLE theme = GetTheme(aWidgetType);
43487:   // For the classic theme we don't really have a way of knowing
62303:   if (!theme) {
62620:     // menu backgrounds and tooltips which can't be themed are opaque
62620:     if (aWidgetType == NS_THEME_MENUPOPUP || aWidgetType == NS_THEME_TOOLTIP) {
62303:       return eOpaque;
62303:     }
43487:     return eUnknownTransparency;
62303:   }
43487: 
43487:   PRInt32 part, state;
43487:   nsresult rv = GetThemePartAndState(aFrame, aWidgetType, part, state);
43487:   // Fail conservatively
43487:   NS_ENSURE_SUCCESS(rv, eUnknownTransparency);
43487: 
43487:   if (part <= 0) {
43487:     // Not a real part code, so isThemeBackgroundPartiallyTransparent may
43487:     // not work, so don't call it.
43487:     return eUnknownTransparency;
43487:   }
43487: 
43487:   if (nsUXThemeData::isThemeBackgroundPartiallyTransparent(theme, part, state))
43487:     return eTransparent;
43487:   return eOpaque;
22675: }
22675: 
    1: /* Windows 9x/NT/2000/Classic XP Theme Support */
    1: 
79445: bool 
    1: nsNativeThemeWin::ClassicThemeSupportsWidget(nsPresContext* aPresContext,
    1:                                       nsIFrame* aFrame,
    1:                                       PRUint8 aWidgetType)
    1: {
    1:   switch (aWidgetType) {
43885:     case NS_THEME_RESIZER:
43885:     {
43885:       // The classic native resizer has an opaque grey background which doesn't
43885:       // match the usually white background of the scrollable container, so
43885:       // only support the native resizer if not in a scrollframe.
43885:       nsIFrame* parentFrame = aFrame->GetParent();
80435:       return (!parentFrame || parentFrame->GetType() != nsGkAtoms::scrollFrame);
43885:     }
 3477:     case NS_THEME_MENUBAR:
 3477:     case NS_THEME_MENUPOPUP:
 3477:       // Classic non-flat menus are handled almost entirely through CSS.
16026:       if (!nsUXThemeData::sFlatMenus)
79626:         return false;
    1:     case NS_THEME_BUTTON:
    1:     case NS_THEME_TEXTFIELD:
 1191:     case NS_THEME_TEXTFIELD_MULTILINE:
    1:     case NS_THEME_CHECKBOX:
    1:     case NS_THEME_RADIO:
26072:     case NS_THEME_GROUPBOX:
    1:     case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:     case NS_THEME_SCALE_HORIZONTAL:
    1:     case NS_THEME_SCALE_VERTICAL:
    1:     case NS_THEME_SCALE_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCALE_THUMB_VERTICAL:
    1:     case NS_THEME_DROPDOWN_BUTTON:
    1:     case NS_THEME_SPINNER_UP_BUTTON:
    1:     case NS_THEME_SPINNER_DOWN_BUTTON:
    1:     case NS_THEME_LISTBOX:
    1:     case NS_THEME_TREEVIEW:
    1:     case NS_THEME_DROPDOWN_TEXTFIELD:
    1:     case NS_THEME_DROPDOWN:
    1:     case NS_THEME_TOOLTIP:
    1:     case NS_THEME_STATUSBAR:
    1:     case NS_THEME_STATUSBAR_PANEL:
    1:     case NS_THEME_STATUSBAR_RESIZER_PANEL:
    1:     case NS_THEME_PROGRESSBAR:
    1:     case NS_THEME_PROGRESSBAR_VERTICAL:
    1:     case NS_THEME_PROGRESSBAR_CHUNK:
    1:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
    1:     case NS_THEME_TAB:
    1:     case NS_THEME_TAB_PANEL:
    1:     case NS_THEME_TAB_PANELS:
    1:     case NS_THEME_MENUITEM:
    1:     case NS_THEME_CHECKMENUITEM:
    1:     case NS_THEME_RADIOMENUITEM:
 3477:     case NS_THEME_MENUCHECKBOX:
 3477:     case NS_THEME_MENURADIO:
 3477:     case NS_THEME_MENUARROW:
 4313:     case NS_THEME_MENUSEPARATOR:
 4313:     case NS_THEME_MENUITEMTEXT:
49249:     case NS_THEME_WINDOW_TITLEBAR:
49249:     case NS_THEME_WINDOW_TITLEBAR_MAXIMIZED:
49249:     case NS_THEME_WINDOW_FRAME_LEFT:
49249:     case NS_THEME_WINDOW_FRAME_RIGHT:
49249:     case NS_THEME_WINDOW_FRAME_BOTTOM:
49249:     case NS_THEME_WINDOW_BUTTON_CLOSE:
49249:     case NS_THEME_WINDOW_BUTTON_MINIMIZE:
49249:     case NS_THEME_WINDOW_BUTTON_MAXIMIZE:
49249:     case NS_THEME_WINDOW_BUTTON_RESTORE:
49250:     case NS_THEME_WINDOW_BUTTON_BOX:
49250:     case NS_THEME_WINDOW_BUTTON_BOX_MAXIMIZED:
79626:       return true;
79626:   }
79626:   return false;
    1: }
    1: 
    1: nsresult
68668: nsNativeThemeWin::ClassicGetWidgetBorder(nsDeviceContext* aContext, 
    1:                                   nsIFrame* aFrame,
    1:                                   PRUint8 aWidgetType,
23738:                                   nsIntMargin* aResult)
    1: {
    1:   switch (aWidgetType) {
26072:     case NS_THEME_GROUPBOX:
 6480:     case NS_THEME_BUTTON:
 6480:       (*aResult).top = (*aResult).left = (*aResult).bottom = (*aResult).right = 2; 
    1:       break;
    1:     case NS_THEME_STATUSBAR:
    1:       (*aResult).bottom = (*aResult).left = (*aResult).right = 0;
    1:       (*aResult).top = 2;
    1:       break;
    1:     case NS_THEME_LISTBOX:
    1:     case NS_THEME_TREEVIEW:
    1:     case NS_THEME_DROPDOWN:
    1:     case NS_THEME_DROPDOWN_TEXTFIELD:
    1:     case NS_THEME_TAB:
    1:     case NS_THEME_TEXTFIELD:
 1191:     case NS_THEME_TEXTFIELD_MULTILINE:
    1:       (*aResult).top = (*aResult).left = (*aResult).bottom = (*aResult).right = 2;
    1:       break;
    1:     case NS_THEME_STATUSBAR_PANEL:
    1:     case NS_THEME_STATUSBAR_RESIZER_PANEL: {
    1:       (*aResult).top = 1;      
    1:       (*aResult).left = 1;
    1:       (*aResult).bottom = 1;
    1:       (*aResult).right = aFrame->GetNextSibling() ? 3 : 1;
    1:       break;
    1:     }    
    1:     case NS_THEME_TOOLTIP:
    1:       (*aResult).top = (*aResult).left = (*aResult).bottom = (*aResult).right = 1;
    1:       break;
    1:     case NS_THEME_PROGRESSBAR:
    1:     case NS_THEME_PROGRESSBAR_VERTICAL:
    1:       (*aResult).top = (*aResult).left = (*aResult).bottom = (*aResult).right = 1;
    1:       break;
    1:     case NS_THEME_MENUBAR:
    1:       (*aResult).top = (*aResult).left = (*aResult).bottom = (*aResult).right = 0;
    1:       break;
    1:     case NS_THEME_MENUPOPUP:
 3477:       (*aResult).top = (*aResult).left = (*aResult).bottom = (*aResult).right = 3;
    1:       break;
72222:     default:
72222:       (*aResult).top = (*aResult).bottom = (*aResult).left = (*aResult).right = 0;
72222:       break;
72222:   }
72222:   return NS_OK;
72222: }
72222: 
79445: bool
72222: nsNativeThemeWin::ClassicGetWidgetPadding(nsDeviceContext* aContext,
72222:                                    nsIFrame* aFrame,
72222:                                    PRUint8 aWidgetType,
72222:                                    nsIntMargin* aResult)
72222: {
72222:   switch (aWidgetType) {
    1:     case NS_THEME_MENUITEM:
    1:     case NS_THEME_CHECKMENUITEM:
    1:     case NS_THEME_RADIOMENUITEM: {
 3477:       PRInt32 part, state;
79445:       bool focused;
72222: 
72222:       if (NS_FAILED(ClassicGetThemePartAndState(aFrame, aWidgetType, part, state, focused)))
79626:         return false;
72222: 
72222:       if (part == 1) { // top-level menu
16026:         if (nsUXThemeData::sFlatMenus || !(state & DFCS_PUSHED)) {
 3477:           (*aResult).top = (*aResult).bottom = (*aResult).left = (*aResult).right = 2;
    1:         }
 3477:         else {
 3477:           // make top-level menus look sunken when pushed in the Classic look
 3477:           (*aResult).top = (*aResult).left = 3;
 3477:           (*aResult).bottom = (*aResult).right = 1;
 3477:         }
 3477:       }
 3477:       else {
18823:         (*aResult).top = 0;
18823:         (*aResult).bottom = (*aResult).left = (*aResult).right = 2;
    1:       }
79626:       return true;
    1:     }
72278:     case NS_THEME_PROGRESSBAR:
72278:     case NS_THEME_PROGRESSBAR_VERTICAL:
72278:       (*aResult).top = (*aResult).left = (*aResult).bottom = (*aResult).right = 1;
79626:       return true;
    1:     default:
79626:       return false;
72222:   }
    1: }
    1: 
    1: nsresult
68481: nsNativeThemeWin::ClassicGetMinimumWidgetSize(nsRenderingContext* aContext, nsIFrame* aFrame,
    1:                                        PRUint8 aWidgetType,
79445:                                        nsIntSize* aResult, bool* aIsOverridable)
    1: {
    1:   (*aResult).width = (*aResult).height = 0;
79626:   *aIsOverridable = true;
    1:   switch (aWidgetType) {
    1:     case NS_THEME_RADIO:
    1:     case NS_THEME_CHECKBOX:
    1:       (*aResult).width = (*aResult).height = 13;
    1:       break;
 3477:     case NS_THEME_MENUCHECKBOX:
 3477:     case NS_THEME_MENURADIO:
 3477:     case NS_THEME_MENUARROW:
 3477:       (*aResult).width = ::GetSystemMetrics(SM_CXMENUCHECK);
 3477:       (*aResult).height = ::GetSystemMetrics(SM_CYMENUCHECK);
 3477:       break;
    1:     case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:       (*aResult).width = ::GetSystemMetrics(SM_CXVSCROLL);
    1:       (*aResult).height = ::GetSystemMetrics(SM_CYVSCROLL);
79626:       *aIsOverridable = false;
    1:       break;
    1:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
    1:       (*aResult).width = ::GetSystemMetrics(SM_CXHSCROLL);
    1:       (*aResult).height = ::GetSystemMetrics(SM_CYHSCROLL);
79626:       *aIsOverridable = false;
    1:       break;
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:       // XXX HACK We should be able to have a minimum height for the scrollbar
    1:       // track.  However, this causes problems when uncollapsing a scrollbar
    1:       // inside a tree.  See bug 201379 for details.
    1: 
    1:         //      (*aResult).height = ::GetSystemMetrics(SM_CYVTHUMB) << 1;
    1:       break;
    1:     case NS_THEME_SCALE_THUMB_HORIZONTAL:
    1:       (*aResult).width = 12;
    1:       (*aResult).height = 20;
79626:       *aIsOverridable = false;
    1:       break;
    1:     case NS_THEME_SCALE_THUMB_VERTICAL:
    1:       (*aResult).width = 20;
    1:       (*aResult).height = 12;
79626:       *aIsOverridable = false;
    1:       break;
    1:     case NS_THEME_DROPDOWN_BUTTON:
    1:       (*aResult).width = ::GetSystemMetrics(SM_CXVSCROLL);
    1:       break;
    1:     case NS_THEME_DROPDOWN:
    1:     case NS_THEME_BUTTON:
26072:     case NS_THEME_GROUPBOX:
    1:     case NS_THEME_LISTBOX:
    1:     case NS_THEME_TREEVIEW:
    1:     case NS_THEME_TEXTFIELD:
 1191:     case NS_THEME_TEXTFIELD_MULTILINE:
    1:     case NS_THEME_DROPDOWN_TEXTFIELD:      
    1:     case NS_THEME_STATUSBAR:
    1:     case NS_THEME_STATUSBAR_PANEL:      
    1:     case NS_THEME_STATUSBAR_RESIZER_PANEL:
    1:     case NS_THEME_PROGRESSBAR_CHUNK:
    1:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
    1:     case NS_THEME_TOOLTIP:
    1:     case NS_THEME_PROGRESSBAR:
    1:     case NS_THEME_PROGRESSBAR_VERTICAL:
    1:     case NS_THEME_TAB:
    1:     case NS_THEME_TAB_PANEL:
    1:     case NS_THEME_TAB_PANELS:
    1:       // no minimum widget size
    1:       break;
    1:     case NS_THEME_RESIZER: {     
    1:       NONCLIENTMETRICS nc;
    1:       nc.cbSize = sizeof(nc);
    1:       if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(nc), &nc, 0))
    1:         (*aResult).width = (*aResult).height = abs(nc.lfStatusFont.lfHeight) + 4;
    1:       else
    1:         (*aResult).width = (*aResult).height = 15;
79626:       *aIsOverridable = false;
    1:       break;
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
31779:       (*aResult).width = ::GetSystemMetrics(SM_CXVSCROLL);
31779:       (*aResult).height = ::GetSystemMetrics(SM_CYVTHUMB);
31779:       // Without theming, divide the thumb size by two in order to look more
31779:       // native
31779:       if (!GetTheme(aWidgetType))
31779:         (*aResult).height >>= 1;
79626:       *aIsOverridable = false;
    1:       break;
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
31779:       (*aResult).width = ::GetSystemMetrics(SM_CXHTHUMB);
31779:       (*aResult).height = ::GetSystemMetrics(SM_CYHSCROLL);
31779:       // Without theming, divide the thumb size by two in order to look more
31779:       // native
31779:       if (!GetTheme(aWidgetType))
31779:         (*aResult).width >>= 1;
79626:       *aIsOverridable = false;
    1:       break;
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:       (*aResult).width = ::GetSystemMetrics(SM_CXHTHUMB) << 1;
    1:       break;
    1:     }
 4313:     case NS_THEME_MENUSEPARATOR:
 4313:     {
 4313:       aResult->width = 0;
 4313:       aResult->height = 10;
 4313:       break;
 4313:     }
49249: 
49249:     case NS_THEME_WINDOW_TITLEBAR_MAXIMIZED:
49249:     case NS_THEME_WINDOW_TITLEBAR:
49249:       aResult->height = GetSystemMetrics(SM_CYCAPTION);
49249:       aResult->height += GetSystemMetrics(SM_CYFRAME);
49249:       aResult->width = 0;
49249:     break;
49249:     case NS_THEME_WINDOW_FRAME_LEFT:
49249:     case NS_THEME_WINDOW_FRAME_RIGHT:
49249:       aResult->width = GetSystemMetrics(SM_CXFRAME);
49249:       aResult->height = 0;
49249:     break;
49249: 
49249:     case NS_THEME_WINDOW_FRAME_BOTTOM:
49249:       aResult->height = GetSystemMetrics(SM_CYFRAME);
49249:       aResult->width = 0;
49249:     break;
49249: 
49249:     case NS_THEME_WINDOW_BUTTON_CLOSE:
49249:     case NS_THEME_WINDOW_BUTTON_MINIMIZE:
49249:     case NS_THEME_WINDOW_BUTTON_MAXIMIZE:
49249:     case NS_THEME_WINDOW_BUTTON_RESTORE:
49249:       aResult->width = GetSystemMetrics(SM_CXSIZE);
49249:       aResult->height = GetSystemMetrics(SM_CYSIZE);
49249:       // XXX I have no idea why these caption metrics are always off,
49249:       // but they are.
49249:       aResult->width -= 2;
49249:       aResult->height -= 4;
58328:       if (aWidgetType == NS_THEME_WINDOW_BUTTON_MINIMIZE) {
58328:         AddPaddingRect(aResult, CAPTIONBUTTON_MINIMIZE);
58328:       }
58328:       else if (aWidgetType == NS_THEME_WINDOW_BUTTON_MAXIMIZE ||
58328:                aWidgetType == NS_THEME_WINDOW_BUTTON_RESTORE) {
58328:         AddPaddingRect(aResult, CAPTIONBUTTON_RESTORE);
58328:       }
58328:       else if (aWidgetType == NS_THEME_WINDOW_BUTTON_CLOSE) {
58328:         AddPaddingRect(aResult, CAPTIONBUTTON_CLOSE);
58328:       }
49249:     break;
49249: 
    1:     default:
    1:       return NS_ERROR_FAILURE;
    1:   }  
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult nsNativeThemeWin::ClassicGetThemePartAndState(nsIFrame* aFrame, PRUint8 aWidgetType,
79445:                                  PRInt32& aPart, PRInt32& aState, bool& aFocused)
    1: {  
79626:   aFocused = false;
    1:   switch (aWidgetType) {
    1:     case NS_THEME_BUTTON: {
56168:       nsEventStates contentState;
    1: 
    1:       aPart = DFC_BUTTON;
    1:       aState = DFCS_BUTTONPUSH;
79626:       aFocused = false;
    1: 
    1:       contentState = GetContentState(aFrame, aWidgetType);
54683:       if (IsDisabled(aFrame, contentState))
    1:         aState |= DFCS_INACTIVE;
26124:       else if (IsOpenButton(aFrame))
15846:         aState |= DFCS_PUSHED;
26124:       else if (IsCheckedButton(aFrame))
15846:         aState |= DFCS_CHECKED;
    1:       else {
56168:         if (contentState.HasAllStates(NS_EVENT_STATE_ACTIVE | NS_EVENT_STATE_HOVER)) {
    1:           aState |= DFCS_PUSHED;
    1:           const nsStyleUserInterface *uiData = aFrame->GetStyleUserInterface();
    1:           // The down state is flat if the button is focusable
    1:           if (uiData->mUserFocus == NS_STYLE_USER_FOCUS_NORMAL) {
33329:             if (!aFrame->GetContent()->IsHTML())
    1:               aState |= DFCS_FLAT;
68855: 
79626:             aFocused = true;
    1:           }
    1:         }
56168:         if (contentState.HasState(NS_EVENT_STATE_FOCUS) ||
    1:             (aState == DFCS_BUTTONPUSH && IsDefaultButton(aFrame))) {
79626:           aFocused = true;
    1:         }
    1: 
    1:       }
    1: 
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_CHECKBOX:
21220:     case NS_THEME_RADIO: {
56168:       nsEventStates contentState;
79626:       aFocused = false;
    1: 
    1:       aPart = DFC_BUTTON;
24662:       aState = 0;
    1:       nsIContent* content = aFrame->GetContent();
79445:       bool isCheckbox = (aWidgetType == NS_THEME_CHECKBOX);
79445:       bool isChecked = GetCheckedOrSelected(aFrame, !isCheckbox);
79445:       bool isIndeterminate = isCheckbox && GetIndeterminate(aFrame);
    1: 
24662:       if (isCheckbox) {
24662:         // indeterminate state takes precedence over checkedness.
24662:         if (isIndeterminate) {
24662:           aState = DFCS_BUTTON3STATE | DFCS_CHECKED;
24662:         } else {
24662:           aState = DFCS_BUTTONCHECK;
24662:         }
24662:       } else {
24662:         aState = DFCS_BUTTONRADIO;
24662:       }
24662:       if (isChecked) {
    1:         aState |= DFCS_CHECKED;
    1:       }
24662: 
    1:       contentState = GetContentState(aFrame, aWidgetType);
33329:       if (!content->IsXUL() &&
56168:           contentState.HasState(NS_EVENT_STATE_FOCUS)) {
79626:         aFocused = true;
    1:       }
    1: 
54683:       if (IsDisabled(aFrame, contentState)) {
    1:         aState |= DFCS_INACTIVE;
56168:       } else if (contentState.HasAllStates(NS_EVENT_STATE_ACTIVE |
56168:                                            NS_EVENT_STATE_HOVER)) {
    1:         aState |= DFCS_PUSHED;
24662:       }
    1: 
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_MENUITEM:
    1:     case NS_THEME_CHECKMENUITEM:
    1:     case NS_THEME_RADIOMENUITEM: {
79445:       bool isTopLevel = false;
79445:       bool isOpen = false;
79445:       bool isContainer = false;
73634:       nsMenuFrame *menuFrame = do_QueryFrame(aFrame);
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
    1: 
    1:       // We indicate top-level-ness using aPart. 0 is a normal menu item,
    1:       // 1 is a top-level menu item. The state of the item is composed of
    1:       // DFCS_* flags only.
    1:       aPart = 0;
    1:       aState = 0;
    1: 
    1:       if (menuFrame) {
    1:         // If this is a real menu item, we should check if it is part of the
    1:         // main menu bar or not, and if it is a container, as these affect
    1:         // rendering.
 3129:         isTopLevel = menuFrame->IsOnMenuBar();
 3129:         isOpen = menuFrame->IsOpen();
 3129:         isContainer = menuFrame->IsMenu();
    1:       }
    1: 
54683:       if (IsDisabled(aFrame, eventState))
    1:         aState |= DFCS_INACTIVE;
    1: 
    1:       if (isTopLevel) {
    1:         aPart = 1;
    1:         if (isOpen)
    1:           aState |= DFCS_PUSHED;
    1:       }
    1: 
12680:       if (IsMenuActive(aFrame, aWidgetType))
    1:         aState |= DFCS_HOT;
    1: 
 3477:       return NS_OK;
 3477:     }
 3477:     case NS_THEME_MENUCHECKBOX:
 3477:     case NS_THEME_MENURADIO:
12424:     case NS_THEME_MENUARROW: {
 3477:       aState = 0;
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
54344: 
54683:       if (IsDisabled(aFrame, eventState))
 3477:         aState |= DFCS_INACTIVE;
12680:       if (IsMenuActive(aFrame, aWidgetType))
 3477:         aState |= DFCS_HOT;
12424: 
 3477:       if (aWidgetType == NS_THEME_MENUCHECKBOX || aWidgetType == NS_THEME_MENURADIO) {
    1:         if (IsCheckedButton(aFrame))
    1:           aState |= DFCS_CHECKED;
16045:       } else if (IsFrameRTL(aFrame)) {
 3477:           aState |= DFCS_RTL;
    1:       }
    1:       return NS_OK;
12424:     }
    1:     case NS_THEME_LISTBOX:
    1:     case NS_THEME_TREEVIEW:
    1:     case NS_THEME_TEXTFIELD:
 1191:     case NS_THEME_TEXTFIELD_MULTILINE:
    1:     case NS_THEME_DROPDOWN:
    1:     case NS_THEME_DROPDOWN_TEXTFIELD:
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:     
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:      
    1:     case NS_THEME_SCALE_HORIZONTAL:
    1:     case NS_THEME_SCALE_VERTICAL:
    1:     case NS_THEME_SCALE_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCALE_THUMB_VERTICAL:
    1:     case NS_THEME_STATUSBAR:
    1:     case NS_THEME_STATUSBAR_PANEL:
    1:     case NS_THEME_STATUSBAR_RESIZER_PANEL:
    1:     case NS_THEME_PROGRESSBAR_CHUNK:
    1:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
    1:     case NS_THEME_TOOLTIP:
    1:     case NS_THEME_PROGRESSBAR:
    1:     case NS_THEME_PROGRESSBAR_VERTICAL:
    1:     case NS_THEME_TAB:
    1:     case NS_THEME_TAB_PANEL:
    1:     case NS_THEME_TAB_PANELS:
    1:     case NS_THEME_MENUBAR:
    1:     case NS_THEME_MENUPOPUP:
26072:     case NS_THEME_GROUPBOX:
    1:       // these don't use DrawFrameControl
    1:       return NS_OK;
    1:     case NS_THEME_DROPDOWN_BUTTON: {
    1: 
    1:       aPart = DFC_SCROLL;
    1:       aState = DFCS_SCROLLCOMBOBOX;
    1: 
    1:       nsIFrame* parentFrame = aFrame->GetParent();
79445:       bool isHTML = IsHTMLContent(aFrame);
80435:       bool isMenulist = !isHTML && parentFrame->GetType() == nsGkAtoms::menuFrame;
79445:       bool isOpen = false;
26124: 
26124:       // HTML select and XUL menulist dropdown buttons get state from the parent.
26124:       if (isHTML || isMenulist)
    1:         aFrame = parentFrame;
    1: 
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
54344: 
54683:       if (IsDisabled(aFrame, eventState)) {
    1:         aState |= DFCS_INACTIVE;
26124:         return NS_OK;
26124:       }
26124: 
26124:       if (isHTML) {
26124:         nsIComboboxControlFrame* ccf = do_QueryFrame(aFrame);
26124:         isOpen = (ccf && ccf->IsDroppedDown());
26124:       }
26124:       else
26124:         isOpen = IsOpenButton(aFrame);
26124: 
26124:       // XXX Button should look active until the mouse is released, but
26124:       //     without making it look active when the popup is clicked.
26124:       if (isOpen && (isHTML || isMenulist))
26124:         return NS_OK;
26124: 
26124:       // Dropdown button active state doesn't need :hover.
56168:       if (eventState.HasState(NS_EVENT_STATE_ACTIVE))
    1:         aState |= DFCS_PUSHED | DFCS_FLAT;
    1: 
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT: {
56168:       nsEventStates contentState = GetContentState(aFrame, aWidgetType);
    1: 
    1:       aPart = DFC_SCROLL;
    1:       switch (aWidgetType) {
    1:         case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:           aState = DFCS_SCROLLUP;
    1:           break;
    1:         case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:           aState = DFCS_SCROLLDOWN;
    1:           break;
    1:         case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:           aState = DFCS_SCROLLLEFT;
    1:           break;
    1:         case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
    1:           aState = DFCS_SCROLLRIGHT;
    1:           break;
    1:       }
    1: 
54683:       if (IsDisabled(aFrame, contentState))
    1:         aState |= DFCS_INACTIVE;
    1:       else {
56168:         if (contentState.HasAllStates(NS_EVENT_STATE_HOVER | NS_EVENT_STATE_ACTIVE))
    1:           aState |= DFCS_PUSHED | DFCS_FLAT;
    1:       }
    1: 
    1:       return NS_OK;
    1:     }
    1:     case NS_THEME_SPINNER_UP_BUTTON:
    1:     case NS_THEME_SPINNER_DOWN_BUTTON: {
56168:       nsEventStates contentState = GetContentState(aFrame, aWidgetType);
    1: 
    1:       aPart = DFC_SCROLL;
    1:       switch (aWidgetType) {
    1:         case NS_THEME_SPINNER_UP_BUTTON:
    1:           aState = DFCS_SCROLLUP;
    1:           break;
    1:         case NS_THEME_SPINNER_DOWN_BUTTON:
    1:           aState = DFCS_SCROLLDOWN;
    1:           break;
    1:       }
    1: 
54683:       if (IsDisabled(aFrame, contentState))
    1:         aState |= DFCS_INACTIVE;
    1:       else {
56168:         if (contentState.HasAllStates(NS_EVENT_STATE_HOVER | NS_EVENT_STATE_ACTIVE))
    1:           aState |= DFCS_PUSHED;
    1:       }
    1: 
    1:       return NS_OK;    
    1:     }
    1:     case NS_THEME_RESIZER:    
    1:       aPart = DFC_SCROLL;
23890:       aState = (IsFrameRTL(aFrame)) ?
23890:                DFCS_SCROLLSIZEGRIPRIGHT : DFCS_SCROLLSIZEGRIP;
    1:       return NS_OK;
 4313:     case NS_THEME_MENUSEPARATOR:
 4313:       aPart = 0;
 4313:       aState = 0;
 4313:       return NS_OK;
49249:     case NS_THEME_WINDOW_TITLEBAR:
49249:       aPart = mozilla::widget::themeconst::WP_CAPTION;
49249:       aState = GetTopLevelWindowActiveState(aFrame);
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_TITLEBAR_MAXIMIZED:
49249:       aPart = mozilla::widget::themeconst::WP_MAXCAPTION;
49249:       aState = GetTopLevelWindowActiveState(aFrame);
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_FRAME_LEFT:
49249:       aPart = mozilla::widget::themeconst::WP_FRAMELEFT;
49249:       aState = GetTopLevelWindowActiveState(aFrame);
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_FRAME_RIGHT:
49249:       aPart = mozilla::widget::themeconst::WP_FRAMERIGHT;
49249:       aState = GetTopLevelWindowActiveState(aFrame);
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_FRAME_BOTTOM:
49249:       aPart = mozilla::widget::themeconst::WP_FRAMEBOTTOM;
49249:       aState = GetTopLevelWindowActiveState(aFrame);
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_BUTTON_CLOSE:
49249:       aPart = DFC_CAPTION;
49249:       aState = DFCS_CAPTIONCLOSE |
49249:                GetClassicWindowFrameButtonState(GetContentState(aFrame,
49249:                                                                 aWidgetType));
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_BUTTON_MINIMIZE:
49249:       aPart = DFC_CAPTION;
49249:       aState = DFCS_CAPTIONMIN |
49249:                GetClassicWindowFrameButtonState(GetContentState(aFrame,
49249:                                                                 aWidgetType));
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_BUTTON_MAXIMIZE:
49249:       aPart = DFC_CAPTION;
49249:       aState = DFCS_CAPTIONMAX |
49249:                GetClassicWindowFrameButtonState(GetContentState(aFrame,
49249:                                                                 aWidgetType));
49249:       return NS_OK;
49249:     case NS_THEME_WINDOW_BUTTON_RESTORE:
49249:       aPart = DFC_CAPTION;
49249:       aState = DFCS_CAPTIONRESTORE |
49249:                GetClassicWindowFrameButtonState(GetContentState(aFrame,
49249:                                                                 aWidgetType));
49249:       return NS_OK;
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: // Draw classic Windows tab
    1: // (no system API for this, but DrawEdge can draw all the parts of a tab)
79445: static void DrawTab(HDC hdc, const RECT& R, PRInt32 aPosition, bool aSelected,
79445:                     bool aDrawLeft, bool aDrawRight)
    1: {
    1:   PRInt32 leftFlag, topFlag, rightFlag, lightFlag, shadeFlag;  
    1:   RECT topRect, sideRect, bottomRect, lightRect, shadeRect;
    1:   PRInt32 selectedOffset, lOffset, rOffset;
    1: 
    1:   selectedOffset = aSelected ? 1 : 0;
    1:   lOffset = aDrawLeft ? 2 : 0;
    1:   rOffset = aDrawRight ? 2 : 0;
    1: 
    1:   // Get info for tab orientation/position (Left, Top, Right, Bottom)
    1:   switch (aPosition) {
    1:     case BF_LEFT:
    1:       leftFlag = BF_TOP; topFlag = BF_LEFT;
    1:       rightFlag = BF_BOTTOM;
    1:       lightFlag = BF_DIAGONAL_ENDTOPRIGHT;
    1:       shadeFlag = BF_DIAGONAL_ENDBOTTOMRIGHT;
    1: 
    1:       ::SetRect(&topRect, R.left, R.top+lOffset, R.right, R.bottom-rOffset);
    1:       ::SetRect(&sideRect, R.left+2, R.top, R.right-2+selectedOffset, R.bottom);
    1:       ::SetRect(&bottomRect, R.right-2, R.top, R.right, R.bottom);
    1:       ::SetRect(&lightRect, R.left, R.top, R.left+3, R.top+3);
    1:       ::SetRect(&shadeRect, R.left+1, R.bottom-2, R.left+2, R.bottom-1);
    1:       break;
    1:     case BF_TOP:    
    1:       leftFlag = BF_LEFT; topFlag = BF_TOP;
    1:       rightFlag = BF_RIGHT;
    1:       lightFlag = BF_DIAGONAL_ENDTOPRIGHT;
    1:       shadeFlag = BF_DIAGONAL_ENDBOTTOMRIGHT;
    1: 
    1:       ::SetRect(&topRect, R.left+lOffset, R.top, R.right-rOffset, R.bottom);
    1:       ::SetRect(&sideRect, R.left, R.top+2, R.right, R.bottom-1+selectedOffset);
    1:       ::SetRect(&bottomRect, R.left, R.bottom-1, R.right, R.bottom);
    1:       ::SetRect(&lightRect, R.left, R.top, R.left+3, R.top+3);      
    1:       ::SetRect(&shadeRect, R.right-2, R.top+1, R.right-1, R.top+2);      
    1:       break;
    1:     case BF_RIGHT:    
    1:       leftFlag = BF_TOP; topFlag = BF_RIGHT;
    1:       rightFlag = BF_BOTTOM;
    1:       lightFlag = BF_DIAGONAL_ENDTOPLEFT;
    1:       shadeFlag = BF_DIAGONAL_ENDBOTTOMLEFT;
    1: 
    1:       ::SetRect(&topRect, R.left, R.top+lOffset, R.right, R.bottom-rOffset);
    1:       ::SetRect(&sideRect, R.left+2-selectedOffset, R.top, R.right-2, R.bottom);
    1:       ::SetRect(&bottomRect, R.left, R.top, R.left+2, R.bottom);
    1:       ::SetRect(&lightRect, R.right-3, R.top, R.right-1, R.top+2);
    1:       ::SetRect(&shadeRect, R.right-2, R.bottom-3, R.right, R.bottom-1);
    1:       break;
    1:     case BF_BOTTOM:    
    1:       leftFlag = BF_LEFT; topFlag = BF_BOTTOM;
    1:       rightFlag = BF_RIGHT;
    1:       lightFlag = BF_DIAGONAL_ENDTOPLEFT;
    1:       shadeFlag = BF_DIAGONAL_ENDBOTTOMLEFT;
    1: 
    1:       ::SetRect(&topRect, R.left+lOffset, R.top, R.right-rOffset, R.bottom);
    1:       ::SetRect(&sideRect, R.left, R.top+2-selectedOffset, R.right, R.bottom-2);
    1:       ::SetRect(&bottomRect, R.left, R.top, R.right, R.top+2);
    1:       ::SetRect(&lightRect, R.left, R.bottom-3, R.left+2, R.bottom-1);
    1:       ::SetRect(&shadeRect, R.right-2, R.bottom-3, R.right, R.bottom-1);
    1:       break;
    1:   }
    1: 
    1:   // Background
    1:   ::FillRect(hdc, &R, (HBRUSH) (COLOR_3DFACE+1) );
    1: 
    1:   // Tab "Top"
    1:   ::DrawEdge(hdc, &topRect, EDGE_RAISED, BF_SOFT | topFlag);
    1: 
    1:   // Tab "Bottom"
    1:   if (!aSelected)
    1:     ::DrawEdge(hdc, &bottomRect, EDGE_RAISED, BF_SOFT | topFlag);
    1: 
    1:   // Tab "Sides"
    1:   if (!aDrawLeft)
    1:     leftFlag = 0;
    1:   if (!aDrawRight)
    1:     rightFlag = 0;
    1:   ::DrawEdge(hdc, &sideRect, EDGE_RAISED, BF_SOFT | leftFlag | rightFlag);
    1: 
    1:   // Tab Diagonal Corners
    1:   if (aDrawLeft)
    1:     ::DrawEdge(hdc, &lightRect, EDGE_RAISED, BF_SOFT | lightFlag);
    1: 
    1:   if (aDrawRight)
    1:     ::DrawEdge(hdc, &shadeRect, EDGE_RAISED, BF_SOFT | shadeFlag);
    1: }
    1: 
    1: static void DrawMenuImage(HDC hdc, const RECT& rc, PRInt32 aComponent, PRUint32 aColor)
    1: {
    1:   // This procedure creates a memory bitmap to contain the check mark, draws
    1:   // it into the bitmap (it is a mask image), then composes it onto the menu
    1:   // item in appropriate colors.
    1:   HDC hMemoryDC = ::CreateCompatibleDC(hdc);
    1:   if (hMemoryDC) {
    1:     // XXXjgr We should ideally be caching these, but we wont be notified when
    1:     // they change currently, so we can't do so easily. Same for the bitmap.
    1:     int checkW = ::GetSystemMetrics(SM_CXMENUCHECK);
    1:     int checkH = ::GetSystemMetrics(SM_CYMENUCHECK);
    1: 
    1:     HBITMAP hMonoBitmap = ::CreateBitmap(checkW, checkH, 1, 1, NULL);
    1:     if (hMonoBitmap) {
    1: 
    1:       HBITMAP hPrevBitmap = (HBITMAP) ::SelectObject(hMemoryDC, hMonoBitmap);
    1:       if (hPrevBitmap) {
    1: 
    1:         // XXXjgr This will go pear-shaped if the image is bigger than the
    1:         // provided rect. What should we do?
    1:         RECT imgRect = { 0, 0, checkW, checkH };
    1:         POINT imgPos = {
    1:               rc.left + (rc.right  - rc.left - checkW) / 2,
    1:               rc.top  + (rc.bottom - rc.top  - checkH) / 2
    1:             };
    1: 
 3477:         // XXXzeniko Windows renders these 1px lower than you'd expect
 3477:         if (aComponent == DFCS_MENUCHECK || aComponent == DFCS_MENUBULLET)
 3477:           imgPos.y++;
 3477: 
    1:         ::DrawFrameControl(hMemoryDC, &imgRect, DFC_MENU, aComponent);
    1:         COLORREF oldTextCol = ::SetTextColor(hdc, 0x00000000);
    1:         COLORREF oldBackCol = ::SetBkColor(hdc, 0x00FFFFFF);
    1:         ::BitBlt(hdc, imgPos.x, imgPos.y, checkW, checkH, hMemoryDC, 0, 0, SRCAND);
    1:         ::SetTextColor(hdc, ::GetSysColor(aColor));
    1:         ::SetBkColor(hdc, 0x00000000);
    1:         ::BitBlt(hdc, imgPos.x, imgPos.y, checkW, checkH, hMemoryDC, 0, 0, SRCPAINT);
    1:         ::SetTextColor(hdc, oldTextCol);
    1:         ::SetBkColor(hdc, oldBackCol);
    1:         ::SelectObject(hMemoryDC, hPrevBitmap);
    1:       }
    1:       ::DeleteObject(hMonoBitmap);
    1:     }
    1:     ::DeleteDC(hMemoryDC);
    1:   }
    1: }
    1: 
    1: void nsNativeThemeWin::DrawCheckedRect(HDC hdc, const RECT& rc, PRInt32 fore, PRInt32 back,
    1:                                        HBRUSH defaultBack)
    1: {
    1:   static WORD patBits[8] = {
    1:     0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55
    1:   };
    1:         
    1:   HBITMAP patBmp = ::CreateBitmap(8, 8, 1, 1, patBits);
    1:   if (patBmp) {
    1:     HBRUSH brush = (HBRUSH) ::CreatePatternBrush(patBmp);
    1:     if (brush) {        
    1:       COLORREF oldForeColor = ::SetTextColor(hdc, ::GetSysColor(fore));
    1:       COLORREF oldBackColor = ::SetBkColor(hdc, ::GetSysColor(back));
    1:       POINT vpOrg;
    1: 
    1:       ::UnrealizeObject(brush);
    1:       ::GetViewportOrgEx(hdc, &vpOrg);
    1:       ::SetBrushOrgEx(hdc, vpOrg.x + rc.left, vpOrg.y + rc.top, NULL);
    1:       HBRUSH oldBrush = (HBRUSH) ::SelectObject(hdc, brush);
    1:       ::FillRect(hdc, &rc, brush);
    1:       ::SetTextColor(hdc, oldForeColor);
    1:       ::SetBkColor(hdc, oldBackColor);
    1:       ::SelectObject(hdc, oldBrush);
    1:       ::DeleteObject(brush);          
    1:     }
    1:     else
    1:       ::FillRect(hdc, &rc, defaultBack);
    1:   
    1:     ::DeleteObject(patBmp);
    1:   }
    1: }
    1: 
68481: nsresult nsNativeThemeWin::ClassicDrawWidgetBackground(nsRenderingContext* aContext,
    1:                                   nsIFrame* aFrame,
    1:                                   PRUint8 aWidgetType,
    1:                                   const nsRect& aRect,
16193:                                   const nsRect& aDirtyRect)
    1: {
    1:   PRInt32 part, state;
79445:   bool focused;
    1:   nsresult rv;
    1:   rv = ClassicGetThemePartAndState(aFrame, aWidgetType, part, state, focused);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
68486:   gfxFloat p2a = gfxFloat(aContext->AppUnitsPerDevPixel());
    1:   RECT widgetRect;
 2855:   gfxRect tr(aRect.x, aRect.y, aRect.width, aRect.height),
16193:           dr(aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height);
    1: 
 2855:   tr.ScaleInverse(p2a);
16193:   dr.ScaleInverse(p2a);
    1: 
 9438:   nsRefPtr<gfxContext> ctx = aContext->ThebesContext();
    1: 
16193:   gfxWindowsNativeDrawing nativeDrawing(ctx, dr, GetWidgetNativeDrawingFlags(aWidgetType));
    1: 
    1: RENDER_AGAIN:
    1: 
    1:   HDC hdc = nativeDrawing.BeginNativeDrawing();
 4414:   if (!hdc)
 4414:     return NS_ERROR_FAILURE;
    1: 
    1:   nativeDrawing.TransformToNativeRect(tr, widgetRect);
    1: 
    1:   rv = NS_OK;
    1:   switch (aWidgetType) { 
    1:     // Draw button
    1:     case NS_THEME_BUTTON: {
    1:       if (focused) {
    1:         // draw dark button focus border first
    1:         HBRUSH brush;        
    1:         brush = ::GetSysColorBrush(COLOR_3DDKSHADOW);
    1:         if (brush)
    1:           ::FrameRect(hdc, &widgetRect, brush);
    1:         InflateRect(&widgetRect, -1, -1);
    1:       }
    1:       // fall-through...
    1:     }
    1:     // Draw controls supported by DrawFrameControl
    1:     case NS_THEME_CHECKBOX:
    1:     case NS_THEME_RADIO:
    1:     case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
    1:     case NS_THEME_SPINNER_UP_BUTTON:
    1:     case NS_THEME_SPINNER_DOWN_BUTTON:
    1:     case NS_THEME_DROPDOWN_BUTTON:
    1:     case NS_THEME_RESIZER: {
    1:       PRInt32 oldTA;
    1:       // setup DC to make DrawFrameControl draw correctly
    1:       oldTA = ::SetTextAlign(hdc, TA_TOP | TA_LEFT | TA_NOUPDATECP);
    1:       ::DrawFrameControl(hdc, &widgetRect, part, state);
    1:       ::SetTextAlign(hdc, oldTA);
    1: 
    1:       // Draw focus rectangles for HTML checkboxes and radio buttons
    1:       // XXX it'd be nice to draw these outside of the frame
21220:       if (focused && (aWidgetType == NS_THEME_CHECKBOX || aWidgetType == NS_THEME_RADIO)) {
    1:         // setup DC to make DrawFocusRect draw correctly
    1:         POINT vpOrg;
    1:         ::GetViewportOrgEx(hdc, &vpOrg);
    1:         ::SetBrushOrgEx(hdc, vpOrg.x + widgetRect.left, vpOrg.y + widgetRect.top, NULL);
    1:         PRInt32 oldColor;
    1:         oldColor = ::SetTextColor(hdc, 0);
    1:         // draw focus rectangle
    1:         ::DrawFocusRect(hdc, &widgetRect);
    1:         ::SetTextColor(hdc, oldColor);
    1:       }
    1:       break;
    1:     }
    1:     // Draw controls with 2px 3D inset border
    1:     case NS_THEME_TEXTFIELD:
 1191:     case NS_THEME_TEXTFIELD_MULTILINE:
    1:     case NS_THEME_LISTBOX:
    1:     case NS_THEME_DROPDOWN:
    1:     case NS_THEME_DROPDOWN_TEXTFIELD: {
    1:       // Draw inset edge
    1:       ::DrawEdge(hdc, &widgetRect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
    1: 
    1:       // Fill in background
54683:       if (IsDisabled(aFrame, eventState) ||
33329:           (aFrame->GetContent()->IsXUL() &&
    1:            IsReadOnly(aFrame)))
    1:         ::FillRect(hdc, &widgetRect, (HBRUSH) (COLOR_BTNFACE+1));
    1:       else
    1:         ::FillRect(hdc, &widgetRect, (HBRUSH) (COLOR_WINDOW+1));
    1: 
    1:       break;
    1:     }
    1:     case NS_THEME_TREEVIEW: {
    1:       // Draw inset edge
    1:       ::DrawEdge(hdc, &widgetRect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
    1: 
    1:       // Fill in window color background
    1:       ::FillRect(hdc, &widgetRect, (HBRUSH) (COLOR_WINDOW+1));
    1: 
    1:       break;
    1:     }
    1:     // Draw ToolTip background
    1:     case NS_THEME_TOOLTIP:
 2961:       ::FrameRect(hdc, &widgetRect, ::GetSysColorBrush(COLOR_WINDOWFRAME));
    1:       InflateRect(&widgetRect, -1, -1);
 2961:       ::FillRect(hdc, &widgetRect, ::GetSysColorBrush(COLOR_INFOBK));
    1: 
    1:       break;
26072:     case NS_THEME_GROUPBOX:
26072:       ::DrawEdge(hdc, &widgetRect, EDGE_ETCHED, BF_RECT | BF_ADJUST);
26072:       ::FillRect(hdc, &widgetRect, (HBRUSH) (COLOR_BTNFACE+1));
26072:       break;
    1:     // Draw 3D face background controls
    1:     case NS_THEME_PROGRESSBAR:
    1:     case NS_THEME_PROGRESSBAR_VERTICAL:
    1:       // Draw 3D border
    1:       ::DrawEdge(hdc, &widgetRect, BDR_SUNKENOUTER, BF_RECT | BF_MIDDLE);
    1:       InflateRect(&widgetRect, -1, -1);
    1:       // fall through
    1:     case NS_THEME_TAB_PANEL:
    1:     case NS_THEME_STATUSBAR:
    1:     case NS_THEME_STATUSBAR_RESIZER_PANEL: {
    1:       ::FillRect(hdc, &widgetRect, (HBRUSH) (COLOR_BTNFACE+1));
    1: 
    1:       break;
    1:     }
    1:     // Draw 3D inset statusbar panel
    1:     case NS_THEME_STATUSBAR_PANEL: {
    1:       if (aFrame->GetNextSibling())
    1:         widgetRect.right -= 2; // space between sibling status panels
    1: 
    1:       ::DrawEdge(hdc, &widgetRect, BDR_SUNKENOUTER, BF_RECT | BF_MIDDLE);
    1: 
    1:       break;
    1:     }
    1:     // Draw scrollbar thumb
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
    1:       ::DrawEdge(hdc, &widgetRect, EDGE_RAISED, BF_RECT | BF_MIDDLE);
    1: 
    1:       break;
    1:     case NS_THEME_SCALE_THUMB_VERTICAL:
54344:     case NS_THEME_SCALE_THUMB_HORIZONTAL: {
56168:       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
54344: 
    1:       ::DrawEdge(hdc, &widgetRect, EDGE_RAISED, BF_RECT | BF_SOFT | BF_MIDDLE | BF_ADJUST);
54683:       if (IsDisabled(aFrame, eventState)) {
    1:         DrawCheckedRect(hdc, widgetRect, COLOR_3DFACE, COLOR_3DHILIGHT,
    1:                         (HBRUSH) COLOR_3DHILIGHT);
    1:       }
    1: 
    1:       break;
54344:     }
    1:     // Draw scrollbar track background
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL: {
    1: 
    1:       // Windows fills in the scrollbar track differently 
    1:       // depending on whether these are equal
    1:       DWORD color3D, colorScrollbar, colorWindow;
    1: 
    1:       color3D = ::GetSysColor(COLOR_3DFACE);      
    1:       colorWindow = ::GetSysColor(COLOR_WINDOW);
    1:       colorScrollbar = ::GetSysColor(COLOR_SCROLLBAR);
    1:       
    1:       if ((color3D != colorScrollbar) && (colorWindow != colorScrollbar))
    1:         // Use solid brush
    1:         ::FillRect(hdc, &widgetRect, (HBRUSH) (COLOR_SCROLLBAR+1));
    1:       else
    1:       {
    1:         DrawCheckedRect(hdc, widgetRect, COLOR_3DHILIGHT, COLOR_3DFACE,
    1:                         (HBRUSH) COLOR_SCROLLBAR+1);
    1:       }
    1:       // XXX should invert the part of the track being clicked here
    1:       // but the track is never :active
    1: 
    1:       break;
    1:     }
    1:     // Draw scale track background
    1:     case NS_THEME_SCALE_VERTICAL:
    1:     case NS_THEME_SCALE_HORIZONTAL: {
    1:       if (aWidgetType == NS_THEME_SCALE_HORIZONTAL) {
    1:         PRInt32 adjustment = (widgetRect.bottom - widgetRect.top) / 2 - 2;
    1:         widgetRect.top += adjustment;
    1:         widgetRect.bottom -= adjustment;
    1:       }
    1:       else {
    1:         PRInt32 adjustment = (widgetRect.right - widgetRect.left) / 2 - 2;
    1:         widgetRect.left += adjustment;
    1:         widgetRect.right -= adjustment;
    1:       }
    1: 
    1:       ::DrawEdge(hdc, &widgetRect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
    1:       ::FillRect(hdc, &widgetRect, (HBRUSH) GetStockObject(GRAY_BRUSH));
    1:  
    1:       break;
    1:     }
    1:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
    1:       ::FillRect(hdc, &widgetRect, (HBRUSH) (COLOR_HIGHLIGHT+1));
    1:       break;
74266: 
74266:     case NS_THEME_PROGRESSBAR_CHUNK: {
74266:       nsIFrame* stateFrame = aFrame->GetParent();
74266:       nsEventStates eventStates = GetContentState(stateFrame, aWidgetType);
74266:       const bool indeterminate = IsIndeterminateProgress(stateFrame, eventStates);
74266: 
74266:       if (!indeterminate) {
74266:         ::FillRect(hdc, &widgetRect, (HBRUSH) (COLOR_HIGHLIGHT+1));
74266:         break;
74266:       }
74266: 
74266:       /**
74266:        * The indeterminate rendering is animated: the bar goes from one side to
74266:        * another.
74266:        */
74266:       if (!QueueAnimatedContentForRefresh(aFrame->GetContent(), 30)) {
74266:         NS_WARNING("unable to animate progress widget!");
74266:       }
74266: 
74266:       const bool vertical = IsVerticalProgress(stateFrame);
74266:       const PRInt32 overlaySize = kProgressClassicOverlaySize;
74266:       const double pixelsPerMillisecond = kProgressClassicIndeterminateSpeed;
74266:       const PRInt32 frameSize = vertical ? widgetRect.bottom - widgetRect.top
74266:                                          : widgetRect.right - widgetRect.left;
74266:       const double interval = frameSize / pixelsPerMillisecond;
74266:       // We have to pass a double* to modf and we can't pass NULL.
74266:       double tempValue;
74266:       double ratio = modf(PR_IntervalToMilliseconds(PR_IntervalNow())/interval,
74266:                           &tempValue);
74266:       PRInt32 dx = 0;
74266: 
74266:       // If the frame direction is RTL, we want to have the animation going RTL.
74266:       // ratio is in [0.0; 1.0[ range, inverting it reverse the animation.
74266:       if (!vertical && IsFrameRTL(aFrame)) {
74266:         ratio = 1.0 - ratio;
74266:         dx -= overlaySize;
74266:       }
74266:       dx += static_cast<PRInt32>(frameSize * ratio);
74266: 
74266:       RECT overlayRect = widgetRect;
74266:       if (vertical) {
74266:         overlayRect.bottom -= dx;
74266:         overlayRect.top = overlayRect.bottom - overlaySize;
74266:       } else {
74266:         overlayRect.left += dx;
74266:         overlayRect.right = overlayRect.left + overlaySize;
74266:       }
74266: 
74266:       // Compute the leftover part.
74266:       RECT leftoverRect = widgetRect;
74266:       if (vertical) {
74266:         if (overlayRect.top < widgetRect.top) {
74266:           leftoverRect.bottom = widgetRect.bottom;
74266:           leftoverRect.top = leftoverRect.bottom + overlayRect.top - widgetRect.top;
74266:         }
74266:       } else if (IsFrameRTL(aFrame)) {
74266:         if (overlayRect.left < widgetRect.left) {
74266:           leftoverRect.right = widgetRect.right;
74266:           leftoverRect.left = leftoverRect.right + overlayRect.left - widgetRect.left;
74266:         }
74266:       } else if (overlayRect.right > widgetRect.right) {
74266:         leftoverRect.left = widgetRect.left;
74266:         leftoverRect.right = leftoverRect.left + overlayRect.right - widgetRect.right;
74266:       }
74266: 
74266:       // Only show the leftover if the rect has been modified.
74266:       if (leftoverRect.top != widgetRect.top ||
74266:           leftoverRect.left != widgetRect.left ||
74266:           leftoverRect.right != widgetRect.right) {
74266:         ::FillRect(hdc, &leftoverRect, (HBRUSH) (COLOR_HIGHLIGHT+1));
74266:       }
74266: 
74266:       ::FillRect(hdc, &overlayRect, (HBRUSH) (COLOR_HIGHLIGHT+1));
74266:       break;
74266:     }
74266: 
    1:     // Draw Tab
23290:     case NS_THEME_TAB: {
    1:       DrawTab(hdc, widgetRect,
    1:         IsBottomTab(aFrame) ? BF_BOTTOM : BF_TOP, 
    1:         IsSelectedTab(aFrame),
23290:         !IsRightToSelectedTab(aFrame),
23290:         !IsLeftToSelectedTab(aFrame));
    1: 
    1:       break;
    1:     }
    1:     case NS_THEME_TAB_PANELS:
    1:       ::DrawEdge(hdc, &widgetRect, EDGE_RAISED, BF_SOFT | BF_MIDDLE |
    1:           BF_LEFT | BF_RIGHT | BF_BOTTOM);
    1: 
    1:       break;
    1:     case NS_THEME_MENUBAR:
    1:       break;
    1:     case NS_THEME_MENUPOPUP:
16026:       NS_ASSERTION(nsUXThemeData::sFlatMenus, "Classic menus are styled entirely through CSS");
    1:       ::FillRect(hdc, &widgetRect, (HBRUSH) (COLOR_MENU+1));
    1:       ::FrameRect(hdc, &widgetRect, ::GetSysColorBrush(COLOR_BTNSHADOW));
    1:       break;
    1:     case NS_THEME_MENUITEM:
    1:     case NS_THEME_CHECKMENUITEM:
 3477:     case NS_THEME_RADIOMENUITEM:
    1:       // part == 0 for normal items
    1:       // part == 1 for top-level menu items
16026:       if (nsUXThemeData::sFlatMenus) {
    1:         // Not disabled and hot/pushed.
    1:         if ((state & (DFCS_HOT | DFCS_PUSHED)) != 0) {
    1:           ::FillRect(hdc, &widgetRect, (HBRUSH) (COLOR_MENUHILIGHT+1));
    1:           ::FrameRect(hdc, &widgetRect, ::GetSysColorBrush(COLOR_HIGHLIGHT));
    1:         }
    1:       } else {
    1:         if (part == 1) {
    1:           if ((state & DFCS_INACTIVE) == 0) {
    1:             if ((state & DFCS_PUSHED) != 0) {
    1:               ::DrawEdge(hdc, &widgetRect, BDR_SUNKENOUTER, BF_RECT);
    1:             } else if ((state & DFCS_HOT) != 0) {
    1:               ::DrawEdge(hdc, &widgetRect, BDR_RAISEDINNER, BF_RECT);
    1:             }
    1:           }
    1:         } else {
    1:           if ((state & (DFCS_HOT | DFCS_PUSHED)) != 0) {
    1:             ::FillRect(hdc, &widgetRect, (HBRUSH) (COLOR_HIGHLIGHT+1));
    1:           }
    1:         }
    1:       }
 3477:       break;
 3477:     case NS_THEME_MENUCHECKBOX:
 3477:     case NS_THEME_MENURADIO:
 3477:       if (!(state & DFCS_CHECKED))
 3477:         break; // nothin' to do
 3477:     case NS_THEME_MENUARROW: {
    1:       PRUint32 color = COLOR_MENUTEXT;
 3477:       if ((state & DFCS_INACTIVE))
    1:         color = COLOR_GRAYTEXT;
 3477:       else if ((state & DFCS_HOT))
    1:         color = COLOR_HIGHLIGHTTEXT;
    1:       
 3477:       if (aWidgetType == NS_THEME_MENUCHECKBOX)
 3477:         DrawMenuImage(hdc, widgetRect, DFCS_MENUCHECK, color);
 3477:       else if (aWidgetType == NS_THEME_MENURADIO)
 3477:         DrawMenuImage(hdc, widgetRect, DFCS_MENUBULLET, color);
 3477:       else if (aWidgetType == NS_THEME_MENUARROW)
 3477:         DrawMenuImage(hdc, widgetRect, 
 3477:                       (state & DFCS_RTL) ? DFCS_MENUARROWRIGHT : DFCS_MENUARROW,
 3477:                       color);
 3477:       break;
    1:     }
 4313:     case NS_THEME_MENUSEPARATOR: {
 4313:       // separators are offset by a bit (see menu.css)
 4313:       widgetRect.left++;
 4313:       widgetRect.right--;
 4313: 
 4313:       // This magic number is brought to you by the value in menu.css
 4313:       widgetRect.top += 4;
 4313:       // Our rectangles are 1 pixel high (see border size in menu.css)
 4313:       widgetRect.bottom = widgetRect.top+1;
 4313:       ::FillRect(hdc, &widgetRect, (HBRUSH)(COLOR_3DSHADOW+1));
 4313:       widgetRect.top++;
 4313:       widgetRect.bottom++;
 4313:       ::FillRect(hdc, &widgetRect, (HBRUSH)(COLOR_3DHILIGHT+1));
 4313:       break;
 4313:     }
49249: 
49249:     case NS_THEME_WINDOW_TITLEBAR:
49249:     case NS_THEME_WINDOW_TITLEBAR_MAXIMIZED:
49249:     {
49249:       RECT rect = widgetRect;
49249:       PRInt32 offset = GetSystemMetrics(SM_CXFRAME);
56509:       rect.bottom -= 1;
56509: 
56509:       // first fill the area to the color of the window background
56509:       FillRect(hdc, &rect, (HBRUSH)(COLOR_3DFACE+1));
56509: 
56509:       // inset the caption area so it doesn't overflow.
49249:       rect.top += offset;
49249:       // if enabled, draw a gradient titlebar background, otherwise
49249:       // fill with a solid color.
49249:       BOOL bFlag = TRUE;
51212:       SystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, &bFlag, 0);
49249:       if (!bFlag) {
49249:         if (state == mozilla::widget::themeconst::FS_ACTIVE)
49249:           FillRect(hdc, &rect, (HBRUSH)(COLOR_ACTIVECAPTION+1));
49249:         else
49249:           FillRect(hdc, &rect, (HBRUSH)(COLOR_INACTIVECAPTION+1));
49249:       } else {
49249:         DWORD startColor, endColor;
49249:         if (state == mozilla::widget::themeconst::FS_ACTIVE) {
49249:           startColor = GetSysColor(COLOR_ACTIVECAPTION);
49249:           endColor = GetSysColor(COLOR_GRADIENTACTIVECAPTION);
49249:         } else {
49249:           startColor = GetSysColor(COLOR_INACTIVECAPTION);
49249:           endColor = GetSysColor(COLOR_GRADIENTINACTIVECAPTION);
49249:         }
49249: 
49249:         TRIVERTEX vertex[2];
49249:         vertex[0].x     = rect.left;
49249:         vertex[0].y     = rect.top;
49249:         vertex[0].Red   = GetRValue(startColor) << 8;
49249:         vertex[0].Green = GetGValue(startColor) << 8;
49249:         vertex[0].Blue  = GetBValue(startColor) << 8;
49249:         vertex[0].Alpha = 0;
49249: 
49249:         vertex[1].x     = rect.right;
49249:         vertex[1].y     = rect.bottom; 
49249:         vertex[1].Red   = GetRValue(endColor) << 8;
49249:         vertex[1].Green = GetGValue(endColor) << 8;
49249:         vertex[1].Blue  = GetBValue(endColor) << 8;
49249:         vertex[1].Alpha = 0;
49249: 
49249:         GRADIENT_RECT gRect;
49249:         gRect.UpperLeft  = 0;
49249:         gRect.LowerRight = 1;
49249:         // available on win2k & up
49249:         GradientFill(hdc, vertex, 2, &gRect, 1, GRADIENT_FILL_RECT_H);
49249:       }
49249: 
58326:       if (aWidgetType == NS_THEME_WINDOW_TITLEBAR) {
58326:         // frame things up with a top raised border.
58326:         DrawEdge(hdc, &widgetRect, EDGE_RAISED, BF_TOP);
58326:       }
49249:       break;
49249:     }
49249: 
49249:     case NS_THEME_WINDOW_FRAME_LEFT:
49249:       DrawEdge(hdc, &widgetRect, EDGE_RAISED, BF_LEFT);
49249:       break;
49249: 
49249:     case NS_THEME_WINDOW_FRAME_RIGHT:
49249:       DrawEdge(hdc, &widgetRect, EDGE_RAISED, BF_RIGHT);
49249:       break;
49249: 
49249:     case NS_THEME_WINDOW_FRAME_BOTTOM:
49249:       DrawEdge(hdc, &widgetRect, EDGE_RAISED, BF_BOTTOM);
49249:       break;
49249: 
49249:     case NS_THEME_WINDOW_BUTTON_CLOSE:
49249:     case NS_THEME_WINDOW_BUTTON_MINIMIZE:
49249:     case NS_THEME_WINDOW_BUTTON_MAXIMIZE:
49249:     case NS_THEME_WINDOW_BUTTON_RESTORE:
49249:     {
58328:       if (aWidgetType == NS_THEME_WINDOW_BUTTON_MINIMIZE) {
58328:         OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_MINIMIZE);
58328:       }
58328:       else if (aWidgetType == NS_THEME_WINDOW_BUTTON_MAXIMIZE ||
58328:                aWidgetType == NS_THEME_WINDOW_BUTTON_RESTORE) {
58328:         OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_RESTORE);
58328:       }
58328:       else if (aWidgetType == NS_THEME_WINDOW_BUTTON_CLOSE) {
58328:         OffsetBackgroundRect(widgetRect, CAPTIONBUTTON_CLOSE);
58328:       }
49249:       PRInt32 oldTA = SetTextAlign(hdc, TA_TOP | TA_LEFT | TA_NOUPDATECP);
49249:       DrawFrameControl(hdc, &widgetRect, part, state);
49249:       SetTextAlign(hdc, oldTA);
49249:       break;
49249:     }
49249: 
    1:     default:
    1:       rv = NS_ERROR_FAILURE;
    1:       break;
    1:   }
    1: 
    1:   nativeDrawing.EndNativeDrawing();
    1: 
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   if (nativeDrawing.ShouldRenderAgain())
    1:     goto RENDER_AGAIN;
    1: 
    1:   nativeDrawing.PaintToContext();
    1: 
    1:   return rv;
    1: }
    1: 
    1: PRUint32
    1: nsNativeThemeWin::GetWidgetNativeDrawingFlags(PRUint8 aWidgetType)
    1: {
    1:   switch (aWidgetType) {
    1:     case NS_THEME_BUTTON:
    1:     case NS_THEME_TEXTFIELD:
 1191:     case NS_THEME_TEXTFIELD_MULTILINE:
    1: 
    1:     case NS_THEME_DROPDOWN:
    1:     case NS_THEME_DROPDOWN_TEXTFIELD:
    1:       return
    1:         gfxWindowsNativeDrawing::CANNOT_DRAW_TO_COLOR_ALPHA |
    1:         gfxWindowsNativeDrawing::CAN_AXIS_ALIGNED_SCALE |
    1:         gfxWindowsNativeDrawing::CANNOT_COMPLEX_TRANSFORM;
    1: 
    1:     // need to check these others
    1:     case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:     case NS_THEME_SCALE_HORIZONTAL:
    1:     case NS_THEME_SCALE_VERTICAL:
    1:     case NS_THEME_SCALE_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCALE_THUMB_VERTICAL:
    1:     case NS_THEME_SPINNER_UP_BUTTON:
    1:     case NS_THEME_SPINNER_DOWN_BUTTON:
    1:     case NS_THEME_LISTBOX:
    1:     case NS_THEME_TREEVIEW:
    1:     case NS_THEME_TOOLTIP:
    1:     case NS_THEME_STATUSBAR:
    1:     case NS_THEME_STATUSBAR_PANEL:
    1:     case NS_THEME_STATUSBAR_RESIZER_PANEL:
    1:     case NS_THEME_RESIZER:
    1:     case NS_THEME_PROGRESSBAR:
    1:     case NS_THEME_PROGRESSBAR_VERTICAL:
    1:     case NS_THEME_PROGRESSBAR_CHUNK:
    1:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
    1:     case NS_THEME_TAB:
    1:     case NS_THEME_TAB_PANEL:
    1:     case NS_THEME_TAB_PANELS:
    1:     case NS_THEME_MENUBAR:
    1:     case NS_THEME_MENUPOPUP:
    1:     case NS_THEME_MENUITEM:
    1:       break;
    1: 
    1:     // the dropdown button /almost/ renders correctly with scaling,
    1:     // except that the graphic in the dropdown button (the downward arrow)
    1:     // doesn't get scaled up.
    1:     case NS_THEME_DROPDOWN_BUTTON:
    1:     // these are definitely no; they're all graphics that don't get scaled up
    1:     case NS_THEME_CHECKBOX:
    1:     case NS_THEME_RADIO:
26072:     case NS_THEME_GROUPBOX:
    1:     case NS_THEME_CHECKMENUITEM:
    1:     case NS_THEME_RADIOMENUITEM:
 3477:     case NS_THEME_MENUCHECKBOX:
 3477:     case NS_THEME_MENURADIO:
 3477:     case NS_THEME_MENUARROW:
    1:       return
    1:         gfxWindowsNativeDrawing::CANNOT_DRAW_TO_COLOR_ALPHA |
    1:         gfxWindowsNativeDrawing::CANNOT_AXIS_ALIGNED_SCALE |
    1:         gfxWindowsNativeDrawing::CANNOT_COMPLEX_TRANSFORM;
    1:   }
    1: 
    1:   return
    1:     gfxWindowsNativeDrawing::CANNOT_DRAW_TO_COLOR_ALPHA |
    1:     gfxWindowsNativeDrawing::CANNOT_AXIS_ALIGNED_SCALE |
    1:     gfxWindowsNativeDrawing::CANNOT_COMPLEX_TRANSFORM;
    1: }
    1: 
    1: ///////////////////////////////////////////
    1: // Creation Routine
    1: ///////////////////////////////////////////
25145: 
25145: // from nsWindow.cpp
79445: extern bool gDisableNativeTheme;
25145: 
46998: nsresult NS_NewNativeTheme(nsISupports *aOuter, REFNSIID aIID, void **aResult)
    1: {
25145:   if (gDisableNativeTheme)
25145:     return NS_ERROR_NO_INTERFACE;
25145: 
    1:   if (aOuter)
    1:     return NS_ERROR_NO_AGGREGATION;
    1: 
    1:   nsNativeThemeWin* theme = new nsNativeThemeWin();
    1:   if (!theme)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   return theme->QueryInterface(aIID, aResult);
    1: }
