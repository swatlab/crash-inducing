75154: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
54814:  * ***** BEGIN LICENSE BLOCK *****
54814:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54814:  *
54814:  * The contents of this file are subject to the Mozilla Public License Version
54814:  * 1.1 (the "License"); you may not use this file except in compliance with
54814:  * the License. You may obtain a copy of the License at
54814:  * http://www.mozilla.org/MPL/
54814:  *
54814:  * Software distributed under the License is distributed on an "AS IS" basis,
54814:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54814:  * for the specific language governing rights and limitations under the
54814:  * License.
54814:  *
54814:  * The Original Code is Mozilla Corporation code.
54814:  *
54814:  * The Initial Developer of the Original Code is Mozilla Foundation.
54814:  * Portions created by the Initial Developer are Copyright (C) 2009
54814:  * the Initial Developer. All Rights Reserved.
54814:  *
54814:  * Contributor(s):
54814:  *   Bas Schouten <bschouten@mozilla.com>
54814:  *
54814:  * Alternatively, the contents of this file may be used under the terms of
54814:  * either the GNU General Public License Version 2 or later (the "GPL"), or
54814:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54814:  * in which case the provisions of the GPL or the LGPL are applicable instead
54814:  * of those above. If you wish to allow use of your version of this file only
54814:  * under the terms of either the GPL or the LGPL, and not to allow others to
54814:  * use your version of this file under the terms of the MPL, indicate your
54814:  * decision by deleting the provisions above and replace them with the notice
54814:  * and other provisions required by the GPL or the LGPL. If you do not delete
54814:  * the provisions above, a recipient may use your version of this file under
54814:  * the terms of any one of the MPL, the GPL or the LGPL.
54814:  *
54814:  * ***** END LICENSE BLOCK ***** */
54814: 
75154: #include "mozilla/layers/PLayers.h"
80467: 
80467: /* This must occur *after* layers/PLayers.h to avoid typedefs conflicts. */
80467: #include "mozilla/Util.h"
80467: 
54814: #include "ThebesLayerD3D10.h"
54814: #include "gfxPlatform.h"
54814: 
54814: #include "gfxWindowsPlatform.h"
54814: #ifdef CAIRO_HAS_D2D_SURFACE
54814: #include "gfxD2DSurface.h"
54814: #endif
54814: 
75147: #include "../d3d9/Nv3DVUtils.h"
61473: #include "gfxTeeSurface.h"
61473: #include "gfxUtils.h"
62702: #include "ReadbackLayer.h"
62702: #include "ReadbackProcessor.h"
61473: 
54814: namespace mozilla {
54814: namespace layers {
54814: 
54814: ThebesLayerD3D10::ThebesLayerD3D10(LayerManagerD3D10 *aManager)
54814:   : ThebesLayer(aManager, NULL)
54814:   , LayerD3D10(aManager)
64536:   , mCurrentSurfaceMode(SURFACE_OPAQUE)
54814: {
54814:   mImplData = static_cast<LayerD3D10*>(this);
54814: }
54814: 
54814: ThebesLayerD3D10::~ThebesLayerD3D10()
54814: {
54814: }
54814: 
54814: /**
54814:  * Retention threshold - amount of pixels intersection required to enable
54814:  * layer content retention. This is a guesstimate. Profiling could be done to
54814:  * figure out the optimal threshold.
54814:  */
54814: #define RETENTION_THRESHOLD 16384
54814: 
54814: void
61470: 
61470: ThebesLayerD3D10::InvalidateRegion(const nsIntRegion &aRegion)
54814: {
61470:   mValidRegion.Sub(mValidRegion, aRegion);
54814: }
54814: 
61470: void ThebesLayerD3D10::CopyRegion(ID3D10Texture2D* aSrc, const nsIntPoint &aSrcOffset,
61470:                                   ID3D10Texture2D* aDest, const nsIntPoint &aDestOffset,
72232:                                   const nsIntRegion &aCopyRegion, nsIntRegion* aValidRegion)
61470: {
54814:   nsIntRegion retainedRegion;
61470:   nsIntRegionRectIterator iter(aCopyRegion);
54814:   const nsIntRect *r;
54814:   while ((r = iter.Next())) {
54814:     if (r->width * r->height > RETENTION_THRESHOLD) {
54814:       // Calculate the retained rectangle's position on the old and the new
72232:       // surface.
54814:       D3D10_BOX box;
72232:       box.left = r->x - aSrcOffset.x;
72232:       box.top = r->y - aSrcOffset.y;
72232:       box.right = box.left + r->width;
72232:       box.bottom = box.top + r->height;
61470:       box.back = 1;
54814:       box.front = 0;
54814: 
61470:       device()->CopySubresourceRegion(aDest, 0,
72232:                                       r->x - aDestOffset.x,
72232:                                       r->y - aDestOffset.y,
54814:                                       0,
61470:                                       aSrc, 0,
54814:                                       &box);
54814: 
54814:       retainedRegion.Or(retainedRegion, *r);
54814:     }
54814:   }
54814: 
54814:   // Areas which were valid and were retained are still valid
61470:   aValidRegion->And(*aValidRegion, retainedRegion);  
54814: }
54814: 
54814: void
57097: ThebesLayerD3D10::RenderLayer()
54814: {
54814:   if (!mTexture) {
54814:     return;
54814:   }
54814: 
57097:   SetEffectTransformAndOpacity();
54814: 
54814:   ID3D10EffectTechnique *technique;
64536:   switch (mCurrentSurfaceMode) {
64536:   case SURFACE_COMPONENT_ALPHA:
61473:     technique = effect()->GetTechniqueByName("RenderComponentAlphaLayer");
64536:     break;
64536:   case SURFACE_OPAQUE:
54814:     technique = effect()->GetTechniqueByName("RenderRGBLayerPremul");
64536:     break;
64536:   case SURFACE_SINGLE_CHANNEL_ALPHA:
54814:     technique = effect()->GetTechniqueByName("RenderRGBALayerPremul");
64536:     break;
64536:   default:
64536:     NS_ERROR("Unknown mode");
64536:     return;
54814:   }
54814: 
54814:   nsIntRegionRectIterator iter(mVisibleRegion);
54814: 
54814:   const nsIntRect *iterRect;
54814:   if (mSRView) {
54814:     effect()->GetVariableByName("tRGB")->AsShaderResource()->SetResource(mSRView);
54814:   }
61473:   if (mSRViewOnWhite) {
61473:     effect()->GetVariableByName("tRGBWhite")->AsShaderResource()->SetResource(mSRViewOnWhite);
61473:   }
54814: 
54814:   while ((iterRect = iter.Next())) {
54814:     effect()->GetVariableByName("vLayerQuad")->AsVector()->SetFloatVector(
54814:       ShaderConstantRectD3D10(
54814:         (float)iterRect->x,
54814:         (float)iterRect->y,
54814:         (float)iterRect->width,
54814:         (float)iterRect->height)
54814:       );
54814: 
54814:     effect()->GetVariableByName("vTextureCoords")->AsVector()->SetFloatVector(
54814:       ShaderConstantRectD3D10(
64536:         (float)(iterRect->x - mTextureRect.x) / (float)mTextureRect.width,
64536:         (float)(iterRect->y - mTextureRect.y) / (float)mTextureRect.height,
64536:         (float)iterRect->width / (float)mTextureRect.width,
64536:         (float)iterRect->height / (float)mTextureRect.height)
54814:       );
54814: 
54814:     technique->GetPassByIndex(0)->Apply(0);
54814:     device()->Draw(4, 0);
54814:   }
54814: 
54814:   // Set back to default.
54814:   effect()->GetVariableByName("vTextureCoords")->AsVector()->
54814:     SetFloatVector(ShaderConstantRectD3D10(0, 0, 1.0f, 1.0f));
54814: }
54814: 
54814: void
62702: ThebesLayerD3D10::Validate(ReadbackProcessor *aReadback)
54814: {
54814:   if (mVisibleRegion.IsEmpty()) {
54814:     return;
54814:   }
54814: 
64536:   nsIntRect newTextureRect = mVisibleRegion.GetBounds();
64536: 
61473:   SurfaceMode mode = GetSurfaceMode();
61473:   if (mode == SURFACE_COMPONENT_ALPHA &&
61473:       (!mParent || !mParent->SupportsComponentAlphaChildren())) {
61473:     mode = SURFACE_SINGLE_CHANNEL_ALPHA;
61473:   }
64536:   // If we have a transform that requires resampling of our texture, then
64536:   // we need to make sure we don't sample pixels that haven't been drawn.
64536:   // We clamp sample coordinates to the texture rect, but when the visible region
64536:   // doesn't fill the entire texture rect we need to make sure we draw all the
64536:   // pixels in the texture rect anyway in case they get sampled.
64536:   nsIntRegion neededRegion = mVisibleRegion;
68638:   if (!neededRegion.GetBounds().IsEqualInterior(newTextureRect) ||
64536:       neededRegion.GetNumRects() > 1) {
64536:     gfxMatrix transform2d;
64536:     if (!GetEffectiveTransform().Is2D(&transform2d) ||
64536:         transform2d.HasNonIntegerTranslation()) {
64536:       neededRegion = newTextureRect;
64536:       if (mode == SURFACE_OPAQUE) {
64536:         // We're going to paint outside the visible region, but layout hasn't
64536:         // promised that it will paint opaquely there, so we'll have to
64536:         // treat this layer as transparent.
64536:         mode = SURFACE_SINGLE_CHANNEL_ALPHA;
64536:       }
64536:     }
64536:   }
64536:   mCurrentSurfaceMode = mode;
61473: 
61473:   VerifyContentType(mode);
54814: 
62702:   nsTArray<ReadbackProcessor::Update> readbackUpdates;
62702:   nsIntRegion readbackRegion;
62702:   if (aReadback && UsedForReadback()) {
62702:     aReadback->GetThebesLayerUpdates(this, &readbackUpdates, &readbackRegion);
62702:   }
62702: 
61470:   if (mTexture) {
68638:     if (!mTextureRect.IsEqualInterior(newTextureRect)) {
61470:       nsRefPtr<ID3D10Texture2D> oldTexture = mTexture;
61473:       mTexture = nsnull;
61473:       nsRefPtr<ID3D10Texture2D> oldTextureOnWhite = mTextureOnWhite;
61473:       mTextureOnWhite = nsnull;
61470: 
64536:       nsIntRegion retainRegion = mTextureRect;
61470:       // Old visible region will become the region that is covered by both the
61470:       // old and the new visible region.
61470:       retainRegion.And(retainRegion, mVisibleRegion);
61470:       // No point in retaining parts which were not valid.
61470:       retainRegion.And(retainRegion, mValidRegion);
61470: 
64536:       CreateNewTextures(gfxIntSize(newTextureRect.width, newTextureRect.height), mode);
64536: 
61470:       nsIntRect largeRect = retainRegion.GetLargestRectangle();
61470: 
72232:       // If we had no hardware texture before, or have no retained area larger than
72232:       // the retention threshold, we're not retaining and are done here.
72232:       // If our texture creation failed this can mean a device reset is pending
72232:       // and we should silently ignore the failure. In the future when device
72232:       // failures are properly handled we should test for the type of failure
72232:       // and gracefully handle different failures. See bug 569081.
61470:       if (!oldTexture || !mTexture ||
72232:           largeRect.width * largeRect.height < RETENTION_THRESHOLD) {
61470:         mValidRegion.SetEmpty();
61470:       } else {
64536:         CopyRegion(oldTexture, mTextureRect.TopLeft(),
64536:                    mTexture, newTextureRect.TopLeft(),
72232:                    retainRegion, &mValidRegion);
61473:         if (oldTextureOnWhite) {
64536:           CopyRegion(oldTextureOnWhite, mTextureRect.TopLeft(),
64536:                      mTextureOnWhite, newTextureRect.TopLeft(),
72232:                      retainRegion, &mValidRegion);
61473:         }
61470:       }
61470:     }
61470:   }
64536:   mTextureRect = newTextureRect;
61470: 
61473:   if (!mTexture || (mode == SURFACE_COMPONENT_ALPHA && !mTextureOnWhite)) {
64536:     CreateNewTextures(gfxIntSize(newTextureRect.width, newTextureRect.height), mode);
54814:     mValidRegion.SetEmpty();
54814:   }
54814: 
64536:   nsIntRegion drawRegion;
64536:   drawRegion.Sub(neededRegion, mValidRegion);
64536: 
64536:   if (!drawRegion.IsEmpty()) {
60859:     LayerManagerD3D10::CallbackInfo cbInfo = mD3DManager->GetCallbackInfo();
60859:     if (!cbInfo.Callback) {
60859:       NS_ERROR("D3D10 should never need to update ThebesLayers in an empty transaction");
60859:       return;
60859:     }
60859: 
64536:     DrawRegion(drawRegion, mode);
54814: 
62702:     if (readbackUpdates.Length() > 0) {
62702:       CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM,
64536:                                  newTextureRect.width, newTextureRect.height,
62702:                                  1, 1, 0, D3D10_USAGE_STAGING,
62702:                                  D3D10_CPU_ACCESS_READ);
62702: 
62702:       nsRefPtr<ID3D10Texture2D> readbackTexture;
81355:       HRESULT hr = device()->CreateTexture2D(&desc, NULL, getter_AddRefs(readbackTexture));
81355:       if (FAILED(hr)) {
81355:         LayerManagerD3D10::ReportFailure(NS_LITERAL_CSTRING("ThebesLayerD3D10::Validate(): Failed to create texture"),
81355:                                          hr);
81355:         return;
81355:       }
81355: 
62702:       device()->CopyResource(readbackTexture, mTexture);
62702: 
75147:       for (PRUint32 i = 0; i < readbackUpdates.Length(); i++) {
62702:         mD3DManager->readbackManager()->PostTask(readbackTexture,
62702:                                                  &readbackUpdates[i],
64536:                                                  gfxPoint(newTextureRect.x, newTextureRect.y));
62702:       }
62702:     }
62702: 
64536:     mValidRegion = neededRegion;
54814:   }
54814: }
54814: 
54814: void
54814: ThebesLayerD3D10::LayerManagerDestroyed()
54814: {
54814:   mD3DManager = nsnull;
54814: }
54814: 
54814: Layer*
54814: ThebesLayerD3D10::GetLayer()
54814: {
54814:   return this;
54814: }
54814: 
54814: void
61473: ThebesLayerD3D10::VerifyContentType(SurfaceMode aMode)
54814: {
54814:   if (mD2DSurface) {
61473:     gfxASurface::gfxContentType type = aMode != SURFACE_SINGLE_CHANNEL_ALPHA ?
54814:       gfxASurface::CONTENT_COLOR : gfxASurface::CONTENT_COLOR_ALPHA;
54814: 
54814:     if (type != mD2DSurface->GetContentType()) {  
54814:       mD2DSurface = new gfxD2DSurface(mTexture, type);
54814: 
54814:       if (!mD2DSurface || mD2DSurface->CairoStatus()) {
54814:         NS_WARNING("Failed to create surface for ThebesLayerD3D10.");
54814:         mD2DSurface = nsnull;
54814:         return;
54814:       }
61473: 
54814:       mValidRegion.SetEmpty();
54814:     }
61473:         
61473:     if (aMode != SURFACE_COMPONENT_ALPHA && mTextureOnWhite) {
61473:       // If we've transitioned away from component alpha, we can delete those resources.
61473:       mD2DSurfaceOnWhite = nsnull;
61473:       mSRViewOnWhite = nsnull;
61473:       mTextureOnWhite = nsnull;
61473:       mValidRegion.SetEmpty();
54814:     }
54814:   }
61473: }
61473: 
61473: static void
61473: FillSurface(gfxASurface* aSurface, const nsIntRegion& aRegion,
72232:             const nsIntPoint& aOffset, const gfxRGBA& aColor)
61473: {
61473:   nsRefPtr<gfxContext> ctx = new gfxContext(aSurface);
61473:   ctx->Translate(-gfxPoint(aOffset.x, aOffset.y));
61473:   gfxUtils::PathFromRegion(ctx, aRegion);
61473:   ctx->SetColor(aColor);
61473:   ctx->Fill();
61473: }
54814: 
54814: void
62165: ThebesLayerD3D10::DrawRegion(nsIntRegion &aRegion, SurfaceMode aMode)
54814: {
54814:   nsIntRect visibleRect = mVisibleRegion.GetBounds();
54814: 
54814:   if (!mD2DSurface) {
54814:     return;
54814:   }
54814: 
61473:   nsRefPtr<gfxASurface> destinationSurface;
61473:   
61473:   if (aMode == SURFACE_COMPONENT_ALPHA) {
72232:     FillSurface(mD2DSurface, aRegion, visibleRect.TopLeft(), gfxRGBA(0.0, 0.0, 0.0, 1.0));
72232:     FillSurface(mD2DSurfaceOnWhite, aRegion, visibleRect.TopLeft(), gfxRGBA(1.0, 1.0, 1.0, 1.0));
61473:     gfxASurface* surfaces[2] = { mD2DSurface.get(), mD2DSurfaceOnWhite.get() };
80467:     destinationSurface = new gfxTeeSurface(surfaces, ArrayLength(surfaces));
61473:     // Using this surface as a source will likely go horribly wrong, since
61473:     // only the onBlack surface will really be used, so alpha information will
61473:     // be incorrect.
80486:     destinationSurface->SetAllowUseAsSource(false);
61473:   } else {
61473:     destinationSurface = mD2DSurface;
61473:   }
61473: 
61473:   nsRefPtr<gfxContext> context = new gfxContext(destinationSurface);
54814: 
54814:   nsIntRegionRectIterator iter(aRegion);
54814:   context->Translate(gfxPoint(-visibleRect.x, -visibleRect.y));
54814:   context->NewPath();
54814:   const nsIntRect *iterRect;
54814:   while ((iterRect = iter.Next())) {
54814:     context->Rectangle(gfxRect(iterRect->x, iterRect->y, iterRect->width, iterRect->height));      
54814:   }
54814:   context->Clip();
54814: 
61473:   if (aMode == SURFACE_SINGLE_CHANNEL_ALPHA) {
54814:     context->SetOperator(gfxContext::OPERATOR_CLEAR);
54814:     context->Paint();
54814:     context->SetOperator(gfxContext::OPERATOR_OVER);
54814:   }
54814: 
60658:   mD2DSurface->SetSubpixelAntialiasingEnabled(!(mContentFlags & CONTENT_COMPONENT_ALPHA));
60658: 
54814:   LayerManagerD3D10::CallbackInfo cbInfo = mD3DManager->GetCallbackInfo();
54814:   cbInfo.Callback(this, context, aRegion, nsIntRegion(), cbInfo.CallbackData);
54814: }
54814: 
54814: void
61473: ThebesLayerD3D10::CreateNewTextures(const gfxIntSize &aSize, SurfaceMode aMode)
54814: {
54814:   if (aSize.width == 0 || aSize.height == 0) {
54814:     // Nothing to do.
54814:     return;
54814:   }
54814: 
72232:   CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM, aSize.width, aSize.height, 1, 1);
54814:   desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
54814:   desc.MiscFlags = D3D10_RESOURCE_MISC_GDI_COMPATIBLE;
61473:   HRESULT hr;
54814: 
61473:   if (!mTexture) {
61473:     hr = device()->CreateTexture2D(&desc, NULL, getter_AddRefs(mTexture));
54814: 
54814:     if (FAILED(hr)) {
54814:       NS_WARNING("Failed to create new texture for ThebesLayerD3D10!");
54814:       return;
54814:     }
54814: 
54814:     hr = device()->CreateShaderResourceView(mTexture, NULL, getter_AddRefs(mSRView));
54814: 
54814:     if (FAILED(hr)) {
54814:       NS_WARNING("Failed to create shader resource view for ThebesLayerD3D10.");
54814:     }
54814: 
61473:     mD2DSurface = new gfxD2DSurface(mTexture, aMode != SURFACE_SINGLE_CHANNEL_ALPHA ?
54814:       gfxASurface::CONTENT_COLOR : gfxASurface::CONTENT_COLOR_ALPHA);
54814: 
54814:     if (!mD2DSurface || mD2DSurface->CairoStatus()) {
54814:       NS_WARNING("Failed to create surface for ThebesLayerD3D10.");
54814:       mD2DSurface = nsnull;
54814:       return;
54814:     }
61473: 
61473:   }
61473: 
61473:   if (aMode == SURFACE_COMPONENT_ALPHA && !mTextureOnWhite) {
61473:     hr = device()->CreateTexture2D(&desc, NULL, getter_AddRefs(mTextureOnWhite));
61473: 
61473:     if (FAILED(hr)) {
61473:       NS_WARNING("Failed to create new texture for ThebesLayerD3D10!");
61473:       return;
61473:     }
61473: 
61473:     hr = device()->CreateShaderResourceView(mTextureOnWhite, NULL, getter_AddRefs(mSRViewOnWhite));
61473: 
61473:     if (FAILED(hr)) {
61473:       NS_WARNING("Failed to create shader resource view for ThebesLayerD3D10.");
61473:     }
61473: 
61473:     mD2DSurfaceOnWhite = new gfxD2DSurface(mTextureOnWhite, gfxASurface::CONTENT_COLOR);
61473: 
61473:     if (!mD2DSurfaceOnWhite || mD2DSurfaceOnWhite->CairoStatus()) {
61473:       NS_WARNING("Failed to create surface for ThebesLayerD3D10.");
61473:       mD2DSurfaceOnWhite = nsnull;
61473:       return;
61473:     }
61473:   }
54814: }
54814:  
75154: ShadowThebesLayerD3D10::ShadowThebesLayerD3D10(LayerManagerD3D10* aManager)
75154:   : ShadowThebesLayer(aManager, NULL)
75154:   , LayerD3D10(aManager)
75154: {
75154:   mImplData = static_cast<LayerD3D10*>(this);
75154: }
75154: 
75154: ShadowThebesLayerD3D10::~ShadowThebesLayerD3D10()
75154: {
75154: }
75154: 
75154: void
75154: ShadowThebesLayerD3D10::Swap(
75154:   const ThebesBuffer& aNewFront, const nsIntRegion& aUpdatedRegion,
80169:   OptionalThebesBuffer* aNewBack, nsIntRegion* aNewBackValidRegion,
75154:   OptionalThebesBuffer* aReadOnlyFront, nsIntRegion* aFrontUpdatedRegion)
75154: {
75154:   nsRefPtr<ID3D10Texture2D> newBackBuffer = mTexture;
75154: 
75154:   mTexture = OpenForeign(mD3DManager->device(), aNewFront.buffer());
75154:   NS_ABORT_IF_FALSE(mTexture, "Couldn't open foreign texture");
75154: 
75154:   // The content process tracks back/front buffers on its own, so
75154:   // the newBack is in essence unused.
80169:   aNewBack->get_ThebesBuffer().buffer() = aNewFront.buffer();
75154: 
75154:   // The content process doesn't need to read back from the front
75154:   // buffer (yet).
75154:   *aReadOnlyFront = null_t();
75154: 
75154:   // FIXME/bug 662109: synchronize using KeyedMutex
75154: }
75154: 
75154: void
75154: ShadowThebesLayerD3D10::DestroyFrontBuffer()
75154: {
75154: }
75154: 
75154: void
75154: ShadowThebesLayerD3D10::Disconnect()
75154: {
75154: }
75154: 
75154: void
75154: ShadowThebesLayerD3D10::RenderLayer()
75154: {
75154:   if (!mTexture) {
75154:     return;
75154:   }
75154: 
75154:   // FIXME/bug 662109: synchronize using KeyedMutex
75154:   
75154:   nsRefPtr<ID3D10ShaderResourceView> srView;
75154:   HRESULT hr = device()->CreateShaderResourceView(mTexture, NULL, getter_AddRefs(srView));
75154:   if (FAILED(hr)) {
75154:       NS_WARNING("Failed to create shader resource view for ThebesLayerD3D10.");
75154:   }
75154: 
75154: 
75154:   SetEffectTransformAndOpacity();
75154: 
75154:   ID3D10EffectTechnique *technique =
75154:       effect()->GetTechniqueByName("RenderRGBLayerPremul");
75154: 
75154:   effect()->GetVariableByName("tRGB")->AsShaderResource()->SetResource(srView);
75154: 
75154:   nsIntRect textureRect = GetVisibleRegion().GetBounds();
75154: 
75154:   nsIntRegionRectIterator iter(mVisibleRegion);
75154:   while (const nsIntRect *iterRect = iter.Next()) {
75154:     effect()->GetVariableByName("vLayerQuad")->AsVector()->SetFloatVector(
75154:       ShaderConstantRectD3D10(
75154:         (float)iterRect->x,
75154:         (float)iterRect->y,
75154:         (float)iterRect->width,
75154:         (float)iterRect->height)
75154:       );
75154: 
75154:     effect()->GetVariableByName("vTextureCoords")->AsVector()->SetFloatVector(
75154:       ShaderConstantRectD3D10(
75154:         (float)(iterRect->x - textureRect.x) / (float)textureRect.width,
75154:         (float)(iterRect->y - textureRect.y) / (float)textureRect.height,
75154:         (float)iterRect->width / (float)textureRect.width,
75154:         (float)iterRect->height / (float)textureRect.height)
75154:       );
75154: 
75154:     technique->GetPassByIndex(0)->Apply(0);
75154:     device()->Draw(4, 0);
75154:   }
75154: 
75154:   // FIXME/bug 662109: synchronize using KeyedMutex
75154: 
75154:   // Set back to default.
75154:   effect()->GetVariableByName("vTextureCoords")->AsVector()->
75154:     SetFloatVector(ShaderConstantRectD3D10(0, 0, 1.0f, 1.0f));
75154: }
75154: 
75154: void
75154: ShadowThebesLayerD3D10::Validate()
75154: {
75154: }
75154: 
75154: void
75154: ShadowThebesLayerD3D10::LayerManagerDestroyed()
75154: {
75154: }
75154: 
54814: } /* namespace layers */
54814: } /* namespace mozilla */
