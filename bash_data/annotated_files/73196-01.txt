47426: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
47426:  * vim: set ts=8 sw=4 et tw=99:
47426:  */
47426: 
35331: #include "tests.h"
35331: #include "jsdbgapi.h"
35331: 
35331: static int callCount[2] = {0, 0};
35331: 
35331: static void *
55713: callCountHook(JSContext *cx, JSStackFrame *fp, JSBool before, JSBool *ok, void *closure)
35331: {
35331:     callCount[before]++;
55713: 
55713:     jsval thisv;
55713:     JS_GetFrameThis(cx, fp, &thisv);  // assert if fp is incomplete
55713: 
35331:     return cx;  // any non-null value causes the hook to be called again after
35331: }
35331: 
35331: BEGIN_TEST(testDebugger_bug519719)
35331: {
64363:     CHECK(JS_SetDebugMode(cx, JS_TRUE));
55713:     JS_SetCallHook(rt, callCountHook, NULL);
35331:     EXEC("function call(fn) { fn(0); }\n"
35331:          "function f(g) { for (var i = 0; i < 9; i++) call(g); }\n"
35331:          "f(Math.sin);\n"    // record loop, starting in f
35331:          "f(Math.cos);\n");  // side exit in f -> call
73072:     CHECK_EQUAL(callCount[0], 20);
73072:     CHECK_EQUAL(callCount[1], 20);
35331:     return true;
35331: }
35331: END_TEST(testDebugger_bug519719)
55713: 
55713: static void *
55713: nonStrictThisHook(JSContext *cx, JSStackFrame *fp, JSBool before, JSBool *ok, void *closure)
55713: {
55713:     if (before) {
55713:         bool *allWrapped = (bool *) closure;
55713:         jsval thisv;
55713:         JS_GetFrameThis(cx, fp, &thisv);
55713:         *allWrapped = *allWrapped && !JSVAL_IS_PRIMITIVE(thisv);
55713:     }
55713:     return NULL;
55713: }
55713: 
55713: BEGIN_TEST(testDebugger_getThisNonStrict)
55713: {
55713:     bool allWrapped = true;
64363:     CHECK(JS_SetDebugMode(cx, JS_TRUE));
55713:     JS_SetCallHook(rt, nonStrictThisHook, (void *) &allWrapped);
55713:     EXEC("function nonstrict() { }\n"
55713:          "Boolean.prototype.nonstrict = nonstrict;\n"
55713:          "String.prototype.nonstrict = nonstrict;\n"
55713:          "Number.prototype.nonstrict = nonstrict;\n"
55713:          "Object.prototype.nonstrict = nonstrict;\n"
55713:          "nonstrict.call(true);\n"
55713:          "true.nonstrict();\n"
55713:          "nonstrict.call('');\n"
55713:          "''.nonstrict();\n"
55713:          "nonstrict.call(42);\n"
55713:          "(42).nonstrict();\n"
55713:          // The below don't really get 'wrapped', but it's okay.
55713:          "nonstrict.call(undefined);\n"
55713:          "nonstrict.call(null);\n"
55713:          "nonstrict.call({});\n"
55713:          "({}).nonstrict();\n");
55713:     CHECK(allWrapped);
55713:     return true;
55713: }
55713: END_TEST(testDebugger_getThisNonStrict)
55713: 
55713: static void *
55713: strictThisHook(JSContext *cx, JSStackFrame *fp, JSBool before, JSBool *ok, void *closure)
55713: {
55713:     if (before) {
55713:         bool *anyWrapped = (bool *) closure;
55713:         jsval thisv;
55713:         JS_GetFrameThis(cx, fp, &thisv);
55713:         *anyWrapped = *anyWrapped || !JSVAL_IS_PRIMITIVE(thisv);
55713:     }
55713:     return NULL;
55713: }
55713: 
55713: BEGIN_TEST(testDebugger_getThisStrict)
55713: {
55713:     bool anyWrapped = false;
64363:     CHECK(JS_SetDebugMode(cx, JS_TRUE));
55713:     JS_SetCallHook(rt, strictThisHook, (void *) &anyWrapped);
55713:     EXEC("function strict() { 'use strict'; }\n"
55713:          "Boolean.prototype.strict = strict;\n"
55713:          "String.prototype.strict = strict;\n"
55713:          "Number.prototype.strict = strict;\n"
55713:          "strict.call(true);\n"
55713:          "true.strict();\n"
55713:          "strict.call('');\n"
55713:          "''.strict();\n"
55713:          "strict.call(42);\n"
55713:          "(42).strict();\n"
55713:          "strict.call(undefined);\n"
55713:          "strict.call(null);\n");
55713:     CHECK(!anyWrapped);
55713:     return true;
55713: }
55713: END_TEST(testDebugger_getThisStrict)
73196: 
73196: bool called = false;
73196: 
73196: static JSTrapStatus
73196: ThrowHook(JSContext *cx, JSScript *, jsbytecode *, jsval *rval, void *closure)
73196: {
73196:     called = true;
73196: 
73196:     JSObject *global = JS_GetGlobalForScopeChain(cx);
73196: 
73196:     char text[] = "new Error()";
73196:     jsval _;
73196:     JS_EvaluateScript(cx, global, text, strlen(text), "", 0, &_);
73196: 
73196:     return JSTRAP_CONTINUE;
73196: }
73196: 
73196: BEGIN_TEST(testDebugger_throwHook)
73196: {
73196:     uint32 newopts = JS_GetOptions(cx) | JSOPTION_METHODJIT | JSOPTION_METHODJIT_ALWAYS;
73196:     uint32 oldopts = JS_SetOptions(cx, newopts);
73196: 
73196:     JSDebugHooks hooks = { 0 };
73196:     hooks.throwHook = ThrowHook;
73196:     JSDebugHooks *old = JS_SetContextDebugHooks(cx, &hooks);
73196:     EXEC("function foo() { throw 3 };\n"
73196:          "for (var i = 0; i < 10; ++i) { \n"
73196:          "  var x = <tag></tag>;\n"
73196:          "  try {\n"
73196:          "    foo(); \n"
73196:          "  } catch(e) {}\n"
73196:          "}\n");
73196:     CHECK(called);
73196: 
73196:     JS_SetContextDebugHooks(cx, old);
73196:     JS_SetOptions(cx, oldopts);
73196:     return true;
73196: }
73196: END_TEST(testDebugger_throwHook)
