 95533: /* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 95533: 
 95533: /* Per-block-formatting-context manager of font size inflation for pan and zoom UI. */
 95533: 
 95533: #include "nsFontInflationData.h"
 95533: #include "FramePropertyTable.h"
 95534: #include "nsTextFragment.h"
 95534: #include "nsIFormControlFrame.h"
 97797: #include "nsTextControlFrame.h"
 97797: #include "nsListControlFrame.h"
 97797: #include "nsComboboxControlFrame.h"
 95534: #include "nsHTMLReflowState.h"
 95534: #include "nsTextFrameUtils.h"
 95533: 
 95533: using namespace mozilla;
 95534: using namespace mozilla::layout;
 95533: 
 95533: static void
 95533: DestroyFontInflationData(void *aPropertyValue)
 95533: {
 95533:   delete static_cast<nsFontInflationData*>(aPropertyValue);
 95533: }
 95533: 
 95533: NS_DECLARE_FRAME_PROPERTY(FontInflationDataProperty, DestroyFontInflationData);
 95533: 
 95533: /* static */ nsFontInflationData*
 95533: nsFontInflationData::FindFontInflationDataFor(const nsIFrame *aFrame)
 95533: {
 95533:   // We have one set of font inflation data per block formatting context.
 95533:   const nsIFrame *bfc = FlowRootFor(aFrame);
 95534:   NS_ASSERTION(bfc->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
 95534:                "should have found a flow root");
 95533: 
 95533:   return static_cast<nsFontInflationData*>(
 95533:              bfc->Properties().Get(FontInflationDataProperty()));
 95533: }
 95534: 
 95534: /* static */ void
 95534: nsFontInflationData::UpdateFontInflationDataWidthFor(const nsHTMLReflowState& aReflowState)
 95534: {
 95534:   nsIFrame *bfc = aReflowState.frame;
 95534:   NS_ASSERTION(bfc->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
 95534:                "should have been given a flow root");
 95534:   FrameProperties bfcProps(bfc->Properties());
 95534:   nsFontInflationData *data = static_cast<nsFontInflationData*>(
 95534:                                 bfcProps.Get(FontInflationDataProperty()));
 95534:   if (!data) {
 95534:     data = new nsFontInflationData(bfc);
 95534:     bfcProps.Set(FontInflationDataProperty(), data);
 95534:   }
 95534: 
 95534:   data->UpdateWidth(aReflowState);
 95534: }
 95534: 
 95534: /* static */ void
 95534: nsFontInflationData::MarkFontInflationDataTextDirty(nsIFrame *aBFCFrame)
 95534: {
 95534:   NS_ASSERTION(aBFCFrame->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
 95534:                "should have been given a flow root");
 95534: 
 95534:   FrameProperties bfcProps(aBFCFrame->Properties());
 95534:   nsFontInflationData *data = static_cast<nsFontInflationData*>(
 95534:                                 bfcProps.Get(FontInflationDataProperty()));
 95534:   if (data) {
 95534:     data->MarkTextDirty();
 95534:   }
 95534: }
 95534: 
 95534: nsFontInflationData::nsFontInflationData(nsIFrame *aBFCFrame)
 95534:   : mBFCFrame(aBFCFrame)
 95534:   , mTextAmount(0)
 95534:   , mTextThreshold(0)
 95534:   , mInflationEnabled(false)
 95534:   , mTextDirty(true)
 95534: {
 95534: }
 95534: 
 95534: /**
 95534:  * Find the closest common ancestor between aFrame1 and aFrame2, except
 95534:  * treating the parent of a frame as the first-in-flow of its parent (so
 95534:  * the result doesn't change when breaking changes).
 95534:  *
 95534:  * aKnownCommonAncestor is a known common ancestor of both.
 95534:  */
 95534: static nsIFrame*
 95534: NearestCommonAncestorFirstInFlow(nsIFrame *aFrame1, nsIFrame *aFrame2,
 95534:                                  nsIFrame *aKnownCommonAncestor)
 95534: {
 95534:   aFrame1 = aFrame1->GetFirstInFlow();
 95534:   aFrame2 = aFrame2->GetFirstInFlow();
 95534:   aKnownCommonAncestor = aKnownCommonAncestor->GetFirstInFlow();
 95534: 
 95534:   nsAutoTArray<nsIFrame*, 32> ancestors1, ancestors2;
 95534:   for (nsIFrame *f = aFrame1; f != aKnownCommonAncestor;
 95534:        (f = f->GetParent()) && (f = f->GetFirstInFlow())) {
 95534:     ancestors1.AppendElement(f);
 95534:   }
 95534:   for (nsIFrame *f = aFrame2; f != aKnownCommonAncestor;
 95534:        (f = f->GetParent()) && (f = f->GetFirstInFlow())) {
 95534:     ancestors2.AppendElement(f);
 95534:   }
 95534: 
 95534:   nsIFrame *result = aKnownCommonAncestor;
 95534:   PRUint32 i1 = ancestors1.Length(),
 95534:            i2 = ancestors2.Length();
 95534:   while (i1-- != 0 && i2-- != 0) {
 95534:     if (ancestors1[i1] != ancestors2[i2]) {
 95534:       break;
 95534:     }
 95534:     result = ancestors1[i1];
 95534:   }
 95534: 
 95534:   return result;
 95534: }
 95534: 
 95534: static nscoord
 95534: ComputeDescendantWidth(const nsHTMLReflowState& aAncestorReflowState,
 95534:                        nsIFrame *aDescendantFrame)
 95534: {
 95534:   nsIFrame *ancestorFrame = aAncestorReflowState.frame->GetFirstInFlow();
 95534:   if (aDescendantFrame == ancestorFrame) {
 95534:     return aAncestorReflowState.ComputedWidth();
 95534:   }
 95534: 
 95534:   AutoInfallibleTArray<nsIFrame*, 16> frames;
 95534:   for (nsIFrame *f = aDescendantFrame; f != ancestorFrame;
 97847:        f = f->GetParent()->GetFirstInFlow()) {
 95534:     frames.AppendElement(f);
 95534:   }
 95534: 
 95534:   PRUint32 len = frames.Length();
 95534:   nsHTMLReflowState *reflowStates = static_cast<nsHTMLReflowState*>
 95534:                                 (moz_xmalloc(sizeof(nsHTMLReflowState) * len));
 95534:   nsPresContext *presContext = aDescendantFrame->PresContext();
 95534:   for (PRUint32 i = 0; i < len; ++i) {
 95534:     const nsHTMLReflowState &parentReflowState =
 95534:       (i == 0) ? aAncestorReflowState : reflowStates[i - 1];
 95534:     nsSize availSize(parentReflowState.ComputedWidth(), NS_UNCONSTRAINEDSIZE);
 95534:     nsIFrame *frame = frames[len - i - 1];
 95534:     NS_ABORT_IF_FALSE(frame->GetParent()->GetFirstInFlow() ==
 95534:                         parentReflowState.frame->GetFirstInFlow(),
 95534:                       "bad logic in this function");
 95534:     new (reflowStates + i) nsHTMLReflowState(presContext, parentReflowState,
 95534:                                              frame, availSize);
 95534:   }
 95534: 
 95534:   NS_ABORT_IF_FALSE(reflowStates[len - 1].frame == aDescendantFrame,
 95534:                     "bad logic in this function");
 95534:   nscoord result = reflowStates[len - 1].ComputedWidth();
 95534: 
 95534:   for (PRUint32 i = len; i-- != 0; ) {
 95534:     reflowStates[i].~nsHTMLReflowState();
 95534:   }
 95534:   moz_free(reflowStates);
 95534: 
 95534:   return result;
 95534: }
 95534: 
 95534: void
 95534: nsFontInflationData::UpdateWidth(const nsHTMLReflowState &aReflowState)
 95534: {
 95534:   nsIFrame *bfc = aReflowState.frame;
 95534:   NS_ASSERTION(bfc->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
 95534:                "must be block formatting context");
 95534: 
 95534:   nsIFrame *firstInflatableDescendant =
 95534:              FindEdgeInflatableFrameIn(bfc, eFromStart);
 95534:   if (!firstInflatableDescendant) {
 95534:     mTextAmount = 0;
 95534:     mTextThreshold = 0; // doesn't matter
 95534:     mTextDirty = false;
 95534:     mInflationEnabled = false;
 95534:     return;
 95534:   }
 95534:   nsIFrame *lastInflatableDescendant =
 95534:              FindEdgeInflatableFrameIn(bfc, eFromEnd);
 95534:   NS_ABORT_IF_FALSE(!firstInflatableDescendant == !lastInflatableDescendant,
 95534:                     "null-ness should match; NearestCommonAncestorFirstInFlow"
 95534:                     " will crash when passed null");
 95534: 
 95534:   // Particularly when we're computing for the root BFC, the width of
 95534:   // nca might differ significantly for the width of bfc.
 95534:   nsIFrame *nca = NearestCommonAncestorFirstInFlow(firstInflatableDescendant,
 95534:                                                    lastInflatableDescendant,
 95534:                                                    bfc);
 95534:   while (!nsLayoutUtils::IsContainerForFontSizeInflation(nca)) {
 97614:     nca = nca->GetParent()->GetFirstInFlow();
 95534:   }
 95534: 
 95534:   nscoord newNCAWidth = ComputeDescendantWidth(aReflowState, nca);
 95534: 
 95534:   // See comment above "font.size.inflation.lineThreshold" in
 95534:   // modules/libpref/src/init/all.js .
100286:   nsIPresShell* presShell = bfc->PresContext()->PresShell();
100286:   PRUint32 lineThreshold = presShell->FontSizeInflationLineThreshold();
 95534:   nscoord newTextThreshold = (newNCAWidth * lineThreshold) / 100;
 95534: 
 95534:   if (mTextThreshold <= mTextAmount && mTextAmount < newTextThreshold) {
 95534:     // Because we truncate our scan when we hit sufficient text, we now
 95534:     // need to rescan.
 95534:     mTextDirty = true;
 95534:   }
 95534: 
 98991:   mNCAWidth = newNCAWidth;
 95534:   mTextThreshold = newTextThreshold;
 95534:   mInflationEnabled = mTextAmount >= mTextThreshold;
 95534: }
 95534: 
 95534: /* static */ nsIFrame*
 95534: nsFontInflationData::FindEdgeInflatableFrameIn(nsIFrame* aFrame,
 95534:                                                SearchDirection aDirection)
 95534: {
 95534:   // NOTE: This function has a similar structure to ScanTextIn!
 95534: 
 95534:   // FIXME: Should probably only scan the text that's actually going to
 95534:   // be inflated!
 95534: 
 95534:   nsIFormControlFrame* fcf = do_QueryFrame(aFrame);
 95534:   if (fcf) {
 95534:     return aFrame;
 95534:   }
 95534: 
 95534:   // FIXME: aDirection!
 95534:   nsAutoTArray<FrameChildList, 4> lists;
 95534:   aFrame->GetChildLists(&lists);
 95534:   for (PRUint32 i = 0, len = lists.Length(); i < len; ++i) {
 95534:     const nsFrameList& list =
 95534:       lists[(aDirection == eFromStart) ? i : len - i - 1].mList;
 95534:     for (nsIFrame *kid = (aDirection == eFromStart) ? list.FirstChild()
 95534:                                                     : list.LastChild();
 95534:          kid;
 95534:          kid = (aDirection == eFromStart) ? kid->GetNextSibling()
 95534:                                           : kid->GetPrevSibling()) {
 95534:       if (kid->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
 95534:         // Goes in a different set of inflation data.
 95534:         continue;
 95534:       }
 95534: 
 95534:       if (kid->GetType() == nsGkAtoms::textFrame) {
 95534:         nsIContent *content = kid->GetContent();
 95534:         if (content && kid == content->GetPrimaryFrame()) {
 95534:           PRUint32 len = nsTextFrameUtils::
 95534:             ComputeApproximateLengthWithWhitespaceCompression(
 95534:               content, kid->GetStyleText());
 95534:           if (len != 0) {
 95534:             return kid;
 95534:           }
 95534:         }
 95534:       } else {
 95534:         nsIFrame *kidResult =
 95534:           FindEdgeInflatableFrameIn(kid, aDirection);
 95534:         if (kidResult) {
 95534:           return kidResult;
 95534:         }
 95534:       }
 95534:     }
 95534:   }
 95534: 
 95534:   return nsnull;
 95534: }
 95534: 
 95534: void
 95534: nsFontInflationData::ScanText()
 95534: {
 95534:   mTextDirty = false;
 95534:   mTextAmount = 0;
 95534:   ScanTextIn(mBFCFrame);
 95534:   mInflationEnabled = mTextAmount >= mTextThreshold;
 95534: }
 95534: 
 97797: static PRUint32
 97797: DoCharCountOfLargestOption(nsIFrame *aContainer)
 97797: {
 97797:   PRUint32 result = 0;
 97797:   for (nsIFrame* option = aContainer->GetFirstPrincipalChild();
 97797:        option; option = option->GetNextSibling()) {
 97797:     PRUint32 optionResult;
 97797:     if (option->GetContent()->IsHTML(nsGkAtoms::optgroup)) {
 97797:       optionResult = DoCharCountOfLargestOption(option);
 97797:     } else {
 97797:       // REVIEW: Check the frame structure for this!
 97797:       optionResult = 0;
 97797:       for (nsIFrame *optionChild = option->GetFirstPrincipalChild();
 97797:            optionChild; optionChild = optionChild->GetNextSibling()) {
 97797:         if (optionChild->GetType() == nsGkAtoms::textFrame) {
 97797:           optionResult += nsTextFrameUtils::
 97797:             ComputeApproximateLengthWithWhitespaceCompression(
 97797:               optionChild->GetContent(), optionChild->GetStyleText());
 97797:         }
 97797:       }
 97797:     }
 97797:     if (optionResult > result) {
 97797:       result = optionResult;
 97797:     }
 97797:   }
 97797:   return result;
 97797: }
 97797: 
 97797: static PRUint32
 97797: CharCountOfLargestOption(nsIFrame *aListControlFrame)
 97797: {
 97797:   return DoCharCountOfLargestOption(
 97797:     static_cast<nsListControlFrame*>(aListControlFrame)->GetOptionsContainer());
 97797: }
 97797: 
 95534: void
 95534: nsFontInflationData::ScanTextIn(nsIFrame *aFrame)
 95534: {
 95534:   // NOTE: This function has a similar structure to FindEdgeInflatableFrameIn!
 95534: 
 95534:   // FIXME: Should probably only scan the text that's actually going to
 95534:   // be inflated!
 95534: 
 95534:   nsIFrame::ChildListIterator lists(aFrame);
 95534:   for (; !lists.IsDone(); lists.Next()) {
 95534:     nsFrameList::Enumerator kids(lists.CurrentList());
 95534:     for (; !kids.AtEnd(); kids.Next()) {
 95534:       nsIFrame *kid = kids.get();
 95534:       if (kid->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
 95534:         // Goes in a different set of inflation data.
 95534:         continue;
 95534:       }
 95534: 
 97797:       nsIAtom *fType = kid->GetType();
 97797:       if (fType == nsGkAtoms::textFrame) {
 95534:         nsIContent *content = kid->GetContent();
 95534:         if (content && kid == content->GetPrimaryFrame()) {
 95534:           PRUint32 len = nsTextFrameUtils::
 95534:             ComputeApproximateLengthWithWhitespaceCompression(
 95534:               content, kid->GetStyleText());
 95534:           if (len != 0) {
 95534:             nscoord fontSize = kid->GetStyleFont()->mFont.size;
 95534:             if (fontSize > 0) {
 95534:               mTextAmount += fontSize * len;
 95534:             }
 95534:           }
 95534:         }
 97797:       } else if (fType == nsGkAtoms::textInputFrame) {
 97797:         // We don't want changes to the amount of text in a text input
 97797:         // to change what we count towards inflation.
 97797:         nscoord fontSize = kid->GetStyleFont()->mFont.size;
 97797:         PRInt32 charCount = static_cast<nsTextControlFrame*>(kid)->GetCols();
 97797:         mTextAmount += charCount * fontSize;
 97797:       } else if (fType == nsGkAtoms::comboboxControlFrame) {
 97797:         // See textInputFrame above (with s/amount of text/selected option/).
 97797:         // Don't just recurse down to the list control inside, since we
 97797:         // need to exclude the display frame.
 97797:         nscoord fontSize = kid->GetStyleFont()->mFont.size;
 97797:         PRInt32 charCount = CharCountOfLargestOption(
 97797:           static_cast<nsComboboxControlFrame*>(kid)->GetDropDown());
 97797:         mTextAmount += charCount * fontSize;
 97797:       } else if (fType == nsGkAtoms::listControlFrame) {
 97797:         // See textInputFrame above (with s/amount of text/selected option/).
 97797:         nscoord fontSize = kid->GetStyleFont()->mFont.size;
 97797:         PRInt32 charCount = CharCountOfLargestOption(kid);
 97797:         mTextAmount += charCount * fontSize;
 95534:       } else {
 95534:         // recursive step
 95534:         ScanTextIn(kid);
 95534:       }
 95534: 
 95534:       if (mTextAmount >= mTextThreshold) {
 95534:         return;
 95534:       }
 95534:     }
 95534:   }
 95534: }
