    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsIDocShell.h"
    1: #include "nsPresContext.h"
80058: #include "nsDOMClassInfoID.h"
    1: #include "nsDOMError.h"
    1: #include "nsIDOMNSEvent.h"
34272: #include "nsIPrivateDOMEvent.h"
    1: #include "nsDOMWindowUtils.h"
39629: #include "nsQueryContentEventResult.h"
    1: #include "nsGlobalWindow.h"
    1: #include "nsIDocument.h"
29018: #include "nsFocusManager.h"
54257: #include "nsEventStateManager.h"
63413: #include "nsFrameManager.h"
67983: #include "nsRefreshDriver.h"
87650: #include "nsDOMTouchEvent.h"
87650: #include "nsIDOMTouchEvent.h"
94270: #include "nsObjectLoadingContent.h"
    1: 
37063: #include "nsIScrollableFrame.h"
26714: 
    1: #include "nsContentUtils.h"
39629: #include "nsLayoutUtils.h"
    1: 
    1: #include "nsIFrame.h"
    1: #include "nsIWidget.h"
    1: #include "nsGUIEvent.h"
93784: #include "nsCharsetSource.h"
 7369: #include "nsJSEnvironment.h"
84803: #include "nsJSUtils.h"
    1: 
18474: #include "nsIViewManager.h"
18474: 
22197: #include "nsIDOMHTMLCanvasElement.h"
22197: #include "gfxContext.h"
22197: #include "gfxImageSurface.h"
38650: #include "nsLayoutUtils.h"
40174: #include "nsComputedDOMStyle.h"
51620: #include "nsIPresShell.h"
56404: #include "nsStyleAnimation.h"
56404: #include "nsCSSProps.h"
78955: #include "nsDOMFile.h"
80560: #include "BasicLayers.h"
94270: #include "nsTArrayHelpers.h"
96182: #include "nsIDocShell.h"
96182: #include "nsIContentViewer.h"
96182: #include "nsIMarkupDocumentViewer.h"
96351: #include "nsClientRect.h"
22197: 
15235: #if defined(MOZ_X11) && defined(MOZ_WIDGET_GTK2)
15235: #include <gdk/gdk.h>
    1: #include <gdk/gdkx.h>
    1: #endif
    1: 
51975: #include "Layers.h"
71624: #include "nsIIOService.h"
51975: 
64094: #include "mozilla/dom/Element.h"
84685: #include "mozilla/dom/indexedDB/FileInfo.h"
84685: #include "mozilla/dom/indexedDB/IndexedDatabaseManager.h"
84290: #include "sampler.h"
64094: 
64094: using namespace mozilla::dom;
51975: using namespace mozilla::layers;
82840: using namespace mozilla::widget;
51975: 
79445: static bool IsUniversalXPConnectCapable()
39629: {
79445:   bool hasCap = false;
39629:   nsresult rv = nsContentUtils::GetSecurityManager()->
39629:                   IsCapabilityEnabled("UniversalXPConnect", &hasCap);
80486:   NS_ENSURE_SUCCESS(rv, false);
39629:   return hasCap;
39629: }
39629: 
40490: DOMCI_DATA(WindowUtils, nsDOMWindowUtils)
40490: 
94546: NS_INTERFACE_MAP_BEGIN(nsDOMWindowUtils)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMWindowUtils)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMWindowUtils)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WindowUtils)
    1: NS_INTERFACE_MAP_END
    1: 
94546: NS_IMPL_ADDREF(nsDOMWindowUtils)
94546: NS_IMPL_RELEASE(nsDOMWindowUtils)
    1: 
    1: nsDOMWindowUtils::nsDOMWindowUtils(nsGlobalWindow *aWindow)
    1: {
94546:   nsCOMPtr<nsISupports> supports = do_QueryObject(aWindow);
94546:   mWindow = do_GetWeakReference(supports);
94546:   NS_ASSERTION(aWindow->IsOuterWindow(), "How did that happen?");
    1: }
    1: 
    1: nsDOMWindowUtils::~nsDOMWindowUtils()
    1: {
    1: }
    1: 
54075: nsIPresShell*
54075: nsDOMWindowUtils::GetPresShell()
54075: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   if (!window)
54075:     return nsnull;
54075: 
94546:   nsIDocShell *docShell = window->GetDocShell();
54075:   if (!docShell)
54075:     return nsnull;
54075: 
54075:   nsCOMPtr<nsIPresShell> presShell;
54075:   docShell->GetPresShell(getter_AddRefs(presShell));
54075:   return presShell;
54075: }
54075: 
23350: nsPresContext*
23350: nsDOMWindowUtils::GetPresContext()
23350: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   if (!window)
23350:     return nsnull;
94546:   nsIDocShell *docShell = window->GetDocShell();
23350:   if (!docShell)
23350:     return nsnull;
39823:   nsRefPtr<nsPresContext> presContext;
23350:   docShell->GetPresContext(getter_AddRefs(presContext));
23350:   return presContext;
23350: }
23350: 
    1: NS_IMETHODIMP
    1: nsDOMWindowUtils::GetImageAnimationMode(PRUint16 *aMode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aMode);
    1:   *aMode = 0;
23350:   nsPresContext* presContext = GetPresContext();
    1:   if (presContext) {
    1:     *aMode = presContext->ImageAnimationMode();
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMWindowUtils::SetImageAnimationMode(PRUint16 aMode)
    1: {
23350:   nsPresContext* presContext = GetPresContext();
    1:   if (presContext) {
    1:     presContext->SetImageAnimationMode(aMode);
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDOMWindowUtils::GetDocCharsetIsForced(bool *aIsForced)
 4527: {
80486:   *aIsForced = false;
 4527: 
39630:   if (!IsUniversalXPConnectCapable()) {
 4527:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
 4527: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   if (window) {
94546:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
 4527:     *aIsForced = doc &&
 4527:       doc->GetDocumentCharacterSetSource() >= kCharsetFromParentForced;
 4527:   }
 4527:   return NS_OK;
 4527: }
 4527: 
 4527: NS_IMETHODIMP
    1: nsDOMWindowUtils::GetDocumentMetadata(const nsAString& aName,
    1:                                       nsAString& aValue)
    1: {
39630:   if (!IsUniversalXPConnectCapable()) {
    1:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
    1: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   if (window) {
94546:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
    1:     if (doc) {
    1:       nsCOMPtr<nsIAtom> name = do_GetAtom(aName);
    1:       doc->GetHeaderData(name, aValue);
    1:       return NS_OK;
    1:     }
    1:   }
    1:   
    1:   aValue.Truncate();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
15235: nsDOMWindowUtils::Redraw(PRUint32 aCount, PRUint32 *aDurationOut)
    1: {
15235:   if (aCount == 0)
15235:     aCount = 1;
15235: 
54075:   if (nsIPresShell* presShell = GetPresShell()) {
    1:     nsIFrame *rootFrame = presShell->GetRootFrame();
    1: 
    1:     if (rootFrame) {
    1:       nsRect r(nsPoint(0, 0), rootFrame->GetSize());
15235: 
15235:       PRIntervalTime iStart = PR_IntervalNow();
15235: 
15235:       for (PRUint32 i = 0; i < aCount; i++)
19380:         rootFrame->InvalidateWithFlags(r, nsIFrame::INVALIDATE_IMMEDIATE);
    1: 
15235: #if defined(MOZ_X11) && defined(MOZ_WIDGET_GTK2)
    1:       XSync(GDK_DISPLAY(), False);
    1: #endif
15235: 
15235:       *aDurationOut = PR_IntervalToMilliseconds(PR_IntervalNow() - iStart);
15235: 
    1:       return NS_OK;
    1:     }
    1:   }
51975:   return NS_ERROR_FAILURE;
    1: }
51975: 
51975: NS_IMETHODIMP
54076: nsDOMWindowUtils::SetCSSViewport(float aWidthPx, float aHeightPx)
54076: {
54076:   if (!IsUniversalXPConnectCapable()) {
54076:     return NS_ERROR_DOM_SECURITY_ERR;
54076:   }
54076: 
54076:   if (!(aWidthPx >= 0.0 && aHeightPx >= 0.0)) {
54076:     return NS_ERROR_ILLEGAL_VALUE;
54076:   }
54076: 
54076:   nsIPresShell* presShell = GetPresShell();
54076:   if (!presShell) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
54076:   nscoord width = nsPresContext::CSSPixelsToAppUnits(aWidthPx);
54076:   nscoord height = nsPresContext::CSSPixelsToAppUnits(aHeightPx);
54076: 
54649:   presShell->ResizeReflowOverride(width, height);
54076: 
54076:   return NS_OK;
54076: }
54076: 
63413: static void DestroyNsRect(void* aObject, nsIAtom* aPropertyName,
63413:                           void* aPropertyValue, void* aData)
63413: {
63413:   nsRect* rect = static_cast<nsRect*>(aPropertyValue);
63413:   delete rect;
63413: }
63413: 
96182: static void
96182: MaybeReflowForInflationScreenWidthChange(nsPresContext *aPresContext)
96182: {
96422:   if (aPresContext) {
96422:     nsIPresShell* presShell = aPresContext->GetPresShell();
96422:     if (presShell && nsLayoutUtils::FontSizeInflationEnabled(aPresContext) &&
96422:         presShell->FontSizeInflationMinTwips() != 0) {
96182:       bool changed;
96182:       aPresContext->ScreenWidthInchesForFontInflation(&changed);
96182:       if (changed) {
96182:         nsCOMPtr<nsISupports> container = aPresContext->GetContainer();
96182:         nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(container);
96182:         if (docShell) {
96182:           nsCOMPtr<nsIContentViewer> cv;
96182:           docShell->GetContentViewer(getter_AddRefs(cv));
96182:           nsCOMPtr<nsIMarkupDocumentViewer> mudv = do_QueryInterface(cv);
96182:           if (mudv) {
96182:             nsTArray<nsCOMPtr<nsIMarkupDocumentViewer> > array;
96182:             mudv->AppendSubtree(array);
96182:             for (PRUint32 i = 0, iEnd = array.Length(); i < iEnd; ++i) {
96182:               nsCOMPtr<nsIPresShell> shell;
96182:               nsCOMPtr<nsIContentViewer> cv = do_QueryInterface(array[i]);
96182:               cv->GetPresShell(getter_AddRefs(shell));
96184:               if (shell) {
96184:                 nsIFrame *rootFrame = shell->GetRootFrame();
96182:                 if (rootFrame) {
96182:                   shell->FrameNeedsReflow(rootFrame, nsIPresShell::eResize,
96182:                                           NS_FRAME_IS_DIRTY);
96182:                 }
96182:               }
96182:             }
96182:           }
96182:         }
96182:       }
96182:     }
96183:   }
96422: }
96182: 
54076: NS_IMETHODIMP
63413: nsDOMWindowUtils::SetDisplayPortForElement(float aXPx, float aYPx,
63413:                                            float aWidthPx, float aHeightPx,
63413:                                            nsIDOMElement* aElement)
63413: {
54080:   if (!IsUniversalXPConnectCapable()) {
54080:     return NS_ERROR_DOM_SECURITY_ERR;
54080:   }
54080: 
54080:   nsIPresShell* presShell = GetPresShell();
54080:   if (!presShell) {
54080:     return NS_ERROR_FAILURE;
54080:   }
54080: 
54080:   nsRect displayport(nsPresContext::CSSPixelsToAppUnits(aXPx),
54080:                      nsPresContext::CSSPixelsToAppUnits(aYPx),
54080:                      nsPresContext::CSSPixelsToAppUnits(aWidthPx),
54080:                      nsPresContext::CSSPixelsToAppUnits(aHeightPx));
54080: 
63413:   if (!aElement) {
63413:     return NS_ERROR_INVALID_ARG;
63413:   }
63413: 
63413:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
63413: 
63413:   if (!content) {
63413:     return NS_ERROR_INVALID_ARG;
63413:   }
63413: 
95507:   if (content->GetCurrentDoc() != presShell->GetDocument()) {
95507:     return NS_ERROR_INVALID_ARG;
95507:   }
95507: 
63413:   nsRect lastDisplayPort;
63413:   if (nsLayoutUtils::GetDisplayPort(content, &lastDisplayPort) &&
68638:       displayport.IsEqualInterior(lastDisplayPort)) {
63413:     return NS_OK;
63413:   }
63413: 
63413:   content->SetProperty(nsGkAtoms::DisplayPort, new nsRect(displayport),
63413:                        DestroyNsRect);
63413: 
63413:   nsIFrame* rootScrollFrame = presShell->GetRootScrollFrame();
63413:   if (rootScrollFrame) {
63413:     if (content == rootScrollFrame->GetContent()) {
63414:       // We are setting a root displayport for a document.
63414:       // The pres shell needs a special flag set.
80486:       presShell->SetIgnoreViewportScrolling(true);
96182: 
96182:       // When the "font.size.inflation.minTwips" preference is set, the
96182:       // layout depends on the size of the screen.  Since when the size
96182:       // of the screen changes, the root displayport also changes, we
96182:       // hook in the needed updates here rather than adding a
96182:       // separate notification just for this change.
96182:       nsPresContext* presContext = GetPresContext();
96182:       MaybeReflowForInflationScreenWidthChange(presContext);
63413:     }
63413:   }
63413: 
63414:   nsIFrame* rootFrame = presShell->FrameManager()->GetRootFrame();
63413:   if (rootFrame) {
63773:     nsIContent* rootContent =
63773:       rootScrollFrame ? rootScrollFrame->GetContent() : nsnull;
63773:     nsRect rootDisplayport;
63773:     bool usingDisplayport = rootContent &&
63773:       nsLayoutUtils::GetDisplayPort(rootContent, &rootDisplayport);
63773:     rootFrame->InvalidateWithFlags(
63773:       usingDisplayport ? rootDisplayport : rootFrame->GetVisualOverflowRect(),
63413:       nsIFrame::INVALIDATE_NO_THEBES_LAYERS);
80560: 
96061:     // If we are hiding something that is a display root then send empty paint
96061:     // transaction in order to release retained layers because it won't get
96061:     // any more paint requests when it is hidden.
96061:     if (displayport.IsEmpty() &&
96061:         rootFrame == nsLayoutUtils::GetDisplayRootFrame(rootFrame)) {
80560:       nsCOMPtr<nsIWidget> widget = GetWidget();
80560:       if (widget) {
80560:         bool isRetainingManager;
80560:         LayerManager* manager = widget->GetLayerManager(&isRetainingManager);
80560:         if (isRetainingManager) {
80560:           manager->BeginTransaction();
80560:           nsLayoutUtils::PaintFrame(nsnull, rootFrame, nsRegion(), NS_RGB(255, 255, 255),
80560:                                     nsLayoutUtils::PAINT_WIDGET_LAYERS |
80560:                                     nsLayoutUtils::PAINT_EXISTING_TRANSACTION);
80560:         }
80560:       }
80560:     }
63413:   }
54080: 
54080:   return NS_OK;
54080: }
54080: 
54080: NS_IMETHODIMP
54081: nsDOMWindowUtils::SetResolution(float aXResolution, float aYResolution)
54081: {
54081:   if (!IsUniversalXPConnectCapable()) {
54081:     return NS_ERROR_DOM_SECURITY_ERR;
54081:   }
54081: 
54081:   nsIPresShell* presShell = GetPresShell();
54081:   return presShell ? presShell->SetResolution(aXResolution, aYResolution)
54081:                    : NS_ERROR_FAILURE;
54081: }
54081: 
    1: NS_IMETHODIMP
93057: nsDOMWindowUtils::SetIsFirstPaint(bool aIsFirstPaint)
93057: {
93057:   if (!IsUniversalXPConnectCapable()) {
93057:     return NS_ERROR_DOM_SECURITY_ERR;
93057:   }
93057: 
93057:   nsIPresShell* presShell = GetPresShell();
93057:   if (presShell) {
93057:     presShell->SetIsFirstPaint(aIsFirstPaint);
93057:     return NS_OK;
93057:   }
93057:   return NS_ERROR_FAILURE;
93057: }
93057: 
93057: NS_IMETHODIMP
93057: nsDOMWindowUtils::GetIsFirstPaint(bool *aIsFirstPaint)
93057: {
93057:   if (!IsUniversalXPConnectCapable()) {
93057:     return NS_ERROR_DOM_SECURITY_ERR;
93057:   }
93057: 
93057:   nsIPresShell* presShell = GetPresShell();
93057:   if (presShell) {
93057:     *aIsFirstPaint = presShell->GetIsFirstPaint();
93057:     return NS_OK;
93057:   }
93057:   return NS_ERROR_FAILURE;
93057: }
93057: 
93057: NS_IMETHODIMP
    1: nsDOMWindowUtils::SendMouseEvent(const nsAString& aType,
21967:                                  float aX,
21967:                                  float aY,
    1:                                  PRInt32 aButton,
    1:                                  PRInt32 aClickCount,
20863:                                  PRInt32 aModifiers,
79445:                                  bool aIgnoreRootScrollFrame)
    1: {
51620:   return SendMouseEventCommon(aType, aX, aY, aButton, aClickCount, aModifiers,
80486:                               aIgnoreRootScrollFrame, false);
51620: }
51620: 
51620: NS_IMETHODIMP
51620: nsDOMWindowUtils::SendMouseEventToWindow(const nsAString& aType,
51620:                                          float aX,
51620:                                          float aY,
51620:                                          PRInt32 aButton,
51620:                                          PRInt32 aClickCount,
51620:                                          PRInt32 aModifiers,
79445:                                          bool aIgnoreRootScrollFrame)
51620: {
51620:   return SendMouseEventCommon(aType, aX, aY, aButton, aClickCount, aModifiers,
80486:                               aIgnoreRootScrollFrame, true);
51620: }
51620: 
51620: NS_IMETHODIMP
51620: nsDOMWindowUtils::SendMouseEventCommon(const nsAString& aType,
51620:                                        float aX,
51620:                                        float aY,
51620:                                        PRInt32 aButton,
51620:                                        PRInt32 aClickCount,
51620:                                        PRInt32 aModifiers,
79445:                                        bool aIgnoreRootScrollFrame,
79445:                                        bool aToWindow)
51620: {
39630:   if (!IsUniversalXPConnectCapable()) {
    1:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
    1: 
    1:   // get the widget to send the event to
21967:   nsPoint offset;
21967:   nsCOMPtr<nsIWidget> widget = GetWidget(&offset);
    1:   if (!widget)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PRInt32 msg;
79445:   bool contextMenuKey = false;
    1:   if (aType.EqualsLiteral("mousedown"))
    1:     msg = NS_MOUSE_BUTTON_DOWN;
    1:   else if (aType.EqualsLiteral("mouseup"))
    1:     msg = NS_MOUSE_BUTTON_UP;
    1:   else if (aType.EqualsLiteral("mousemove"))
    1:     msg = NS_MOUSE_MOVE;
    1:   else if (aType.EqualsLiteral("mouseover"))
    1:     msg = NS_MOUSE_ENTER;
    1:   else if (aType.EqualsLiteral("mouseout"))
    1:     msg = NS_MOUSE_EXIT;
 6039:   else if (aType.EqualsLiteral("contextmenu")) {
    1:     msg = NS_CONTEXTMENU;
 6039:     contextMenuKey = (aButton == 0);
 6039:   } else
    1:     return NS_ERROR_FAILURE;
    1: 
80486:   nsMouseEvent event(true, msg, widget, nsMouseEvent::eReal,
 6039:                      contextMenuKey ?
 6039:                        nsMouseEvent::eContextMenuKey : nsMouseEvent::eNormal);
80486:   event.isShift = (aModifiers & nsIDOMNSEvent::SHIFT_MASK) ? true : false;
80486:   event.isControl = (aModifiers & nsIDOMNSEvent::CONTROL_MASK) ? true : false;
80486:   event.isAlt = (aModifiers & nsIDOMNSEvent::ALT_MASK) ? true : false;
80486:   event.isMeta = (aModifiers & nsIDOMNSEvent::META_MASK) ? true : false;
    1:   event.button = aButton;
    1:   event.widget = widget;
    1: 
    1:   event.clickCount = aClickCount;
    1:   event.time = PR_IntervalNow();
33400:   event.flags |= NS_EVENT_FLAG_SYNTHETIC_TEST_EVENT;
21967: 
47902:   nsPresContext* presContext = GetPresContext();
47902:   if (!presContext)
47902:     return NS_ERROR_FAILURE;
47902: 
47902:   PRInt32 appPerDev = presContext->AppUnitsPerDevPixel();
21967:   event.refPoint.x =
21967:     NSAppUnitsToIntPixels(nsPresContext::CSSPixelsToAppUnits(aX) + offset.x,
21967:                           appPerDev);
21967:   event.refPoint.y =
21967:     NSAppUnitsToIntPixels(nsPresContext::CSSPixelsToAppUnits(aY) + offset.y,
21967:                           appPerDev);
22095:   event.ignoreRootScrollFrame = aIgnoreRootScrollFrame;
    1: 
    1:   nsEventStatus status;
51620:   if (aToWindow) {
82568:     nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
51620:     if (!presShell)
51620:       return NS_ERROR_FAILURE;
51620:     nsIViewManager* viewManager = presShell->GetViewManager();
51620:     if (!viewManager)
51620:       return NS_ERROR_FAILURE;
64435:     nsIView* view = viewManager->GetRootView();
64435:     if (!view)
51620:       return NS_ERROR_FAILURE;
51620: 
51620:     status = nsEventStatus_eIgnore;
82568:     return presShell->HandleEvent(view->GetFrame(), &event, false, &status);
51620:   }
64435:   return widget->DispatchEvent(&event, status);
    1: }
    1: 
    1: NS_IMETHODIMP
16604: nsDOMWindowUtils::SendMouseScrollEvent(const nsAString& aType,
21967:                                        float aX,
21967:                                        float aY,
16604:                                        PRInt32 aButton,
16604:                                        PRInt32 aScrollFlags,
16604:                                        PRInt32 aDelta,
16604:                                        PRInt32 aModifiers)
16604: {
39630:   if (!IsUniversalXPConnectCapable()) {
16604:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
16604: 
16604:   // get the widget to send the event to
21967:   nsPoint offset;
21967:   nsCOMPtr<nsIWidget> widget = GetWidget(&offset);
16604:   if (!widget)
16604:     return NS_ERROR_NULL_POINTER;
16604: 
16604:   PRInt32 msg;
16604:   if (aType.EqualsLiteral("DOMMouseScroll"))
16604:     msg = NS_MOUSE_SCROLL;
19319:   else if (aType.EqualsLiteral("MozMousePixelScroll"))
19319:     msg = NS_MOUSE_PIXEL_SCROLL;
16604:   else
16604:     return NS_ERROR_UNEXPECTED;
16604: 
80486:   nsMouseScrollEvent event(true, msg, widget);
80486:   event.isShift = (aModifiers & nsIDOMNSEvent::SHIFT_MASK) ? true : false;
80486:   event.isControl = (aModifiers & nsIDOMNSEvent::CONTROL_MASK) ? true : false;
80486:   event.isAlt = (aModifiers & nsIDOMNSEvent::ALT_MASK) ? true : false;
80486:   event.isMeta = (aModifiers & nsIDOMNSEvent::META_MASK) ? true : false;
16604:   event.button = aButton;
16604:   event.widget = widget;
16604:   event.delta = aDelta;
16604:   event.scrollFlags = aScrollFlags;
16604: 
16604:   event.time = PR_IntervalNow();
21967: 
47902:   nsPresContext* presContext = GetPresContext();
47902:   if (!presContext)
47902:     return NS_ERROR_FAILURE;
47902: 
47902:   PRInt32 appPerDev = presContext->AppUnitsPerDevPixel();
21967:   event.refPoint.x =
21967:     NSAppUnitsToIntPixels(nsPresContext::CSSPixelsToAppUnits(aX) + offset.x,
21967:                           appPerDev);
21967:   event.refPoint.y =
21967:     NSAppUnitsToIntPixels(nsPresContext::CSSPixelsToAppUnits(aY) + offset.y,
21967:                           appPerDev);
16604: 
16604:   nsEventStatus status;
16604:   return widget->DispatchEvent(&event, status);
16604: }
16604: 
87650: 
87650: NS_IMETHODIMP
87650: nsDOMWindowUtils::SendTouchEvent(const nsAString& aType,
87650:                                  PRUint32 *aIdentifiers,
87650:                                  PRInt32 *aXs,
87650:                                  PRInt32 *aYs,
87650:                                  PRUint32 *aRxs,
87650:                                  PRUint32 *aRys,
87650:                                  float *aRotationAngles,
87650:                                  float *aForces,
87650:                                  PRUint32 aCount,
87650:                                  PRInt32 aModifiers,
87650:                                  bool aIgnoreRootScrollFrame,
87650:                                  bool *aPreventDefault)
87650: {
87650:   if (!IsUniversalXPConnectCapable()) {
87650:     return NS_ERROR_DOM_SECURITY_ERR;
87650:   }
87650: 
87650:   // get the widget to send the event to
87650:   nsPoint offset;
87650:   nsCOMPtr<nsIWidget> widget = GetWidget(&offset);
87650:   if (!widget) {
87650:     return NS_ERROR_NULL_POINTER;
87650:   }
87650:   PRInt32 msg;
87650:   if (aType.EqualsLiteral("touchstart")) {
87650:     msg = NS_TOUCH_START;
87650:   } else if (aType.EqualsLiteral("touchmove")) {
87650:     msg = NS_TOUCH_MOVE;
87650:   } else if (aType.EqualsLiteral("touchend")) {
87650:     msg = NS_TOUCH_END;
87650:   } else if (aType.EqualsLiteral("touchcancel")) {
87650:     msg = NS_TOUCH_CANCEL;
87650:   } else {
87650:     return NS_ERROR_UNEXPECTED;
87650:   }
87650:   nsTouchEvent event(true, msg, widget);
87650:   event.isShift = (aModifiers & nsIDOMNSEvent::SHIFT_MASK) ? true : false;
87650:   event.isControl = (aModifiers & nsIDOMNSEvent::CONTROL_MASK) ? true : false;
87650:   event.isAlt = (aModifiers & nsIDOMNSEvent::ALT_MASK) ? true : false;
87650:   event.isMeta = (aModifiers & nsIDOMNSEvent::META_MASK) ? true : false;
87650:   event.widget = widget;
87650:   event.time = PR_Now();
87650: 
87650:   nsPresContext* presContext = GetPresContext();
87650:   if (!presContext) {
87650:     return NS_ERROR_FAILURE;
87650:   }
87650:   event.touches.SetCapacity(aCount);
87650:   PRInt32 appPerDev = presContext->AppUnitsPerDevPixel();
90480:   for (PRUint32 i = 0; i < aCount; ++i) {
87650:     nsIntPoint pt(0, 0);
87650:     pt.x =
87650:       NSAppUnitsToIntPixels(nsPresContext::CSSPixelsToAppUnits(aXs[i]) + offset.x,
87650:                             appPerDev);
87650:     pt.y =
87650:       NSAppUnitsToIntPixels(nsPresContext::CSSPixelsToAppUnits(aYs[i]) + offset.y,
87650:                             appPerDev);
87650:     nsCOMPtr<nsIDOMTouch> t(new nsDOMTouch(aIdentifiers[i],
87650:                                            pt,
87650:                                            nsIntPoint(aRxs[i], aRys[i]),
87650:                                            aRotationAngles[i],
87650:                                            aForces[i]));
87650:     event.touches.AppendElement(t);
87650:   }
87650: 
87650:   nsEventStatus status;
87650:   nsresult rv = widget->DispatchEvent(&event, status);
87650:   *aPreventDefault = (status == nsEventStatus_eConsumeNoDefault);
87650:   return rv;
87650: }
87650: 
16604: NS_IMETHODIMP
    1: nsDOMWindowUtils::SendKeyEvent(const nsAString& aType,
    1:                                PRInt32 aKeyCode,
    1:                                PRInt32 aCharCode,
18388:                                PRInt32 aModifiers,
79445:                                bool aPreventDefault,
79445:                                bool* aDefaultActionTaken)
    1: {
39630:   if (!IsUniversalXPConnectCapable()) {
    1:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
    1: 
    1:   // get the widget to send the event to
 4010:   nsCOMPtr<nsIWidget> widget = GetWidget();
    1:   if (!widget)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PRInt32 msg;
    1:   if (aType.EqualsLiteral("keydown"))
    1:     msg = NS_KEY_DOWN;
    1:   else if (aType.EqualsLiteral("keyup"))
    1:     msg = NS_KEY_UP;
    1:   else if (aType.EqualsLiteral("keypress"))
    1:     msg = NS_KEY_PRESS;
    1:   else
    1:     return NS_ERROR_FAILURE;
    1: 
80486:   nsKeyEvent event(true, msg, widget);
80486:   event.isShift = (aModifiers & nsIDOMNSEvent::SHIFT_MASK) ? true : false;
80486:   event.isControl = (aModifiers & nsIDOMNSEvent::CONTROL_MASK) ? true : false;
80486:   event.isAlt = (aModifiers & nsIDOMNSEvent::ALT_MASK) ? true : false;
80486:   event.isMeta = (aModifiers & nsIDOMNSEvent::META_MASK) ? true : false;
    1: 
    1:   event.keyCode = aKeyCode;
    1:   event.charCode = aCharCode;
    1:   event.refPoint.x = event.refPoint.y = 0;
    1:   event.time = PR_IntervalNow();
    1: 
18388:   if (aPreventDefault) {
18388:     event.flags |= NS_EVENT_FLAG_NO_DEFAULT;
18388:   }
18388: 
    1:   nsEventStatus status;
18388:   nsresult rv = widget->DispatchEvent(&event, status);
18388:   NS_ENSURE_SUCCESS(rv, rv);
18388: 
18388:   *aDefaultActionTaken = (status != nsEventStatus_eConsumeNoDefault);
18388:   
18388:   return NS_OK;
    1: }
    1: 
14962: NS_IMETHODIMP
14962: nsDOMWindowUtils::SendNativeKeyEvent(PRInt32 aNativeKeyboardLayout,
14962:                                      PRInt32 aNativeKeyCode,
14962:                                      PRInt32 aModifiers,
14962:                                      const nsAString& aCharacters,
14962:                                      const nsAString& aUnmodifiedCharacters)
14962: {
39630:   if (!IsUniversalXPConnectCapable()) {
14962:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
14962: 
14962:   // get the widget to send the event to
14962:   nsCOMPtr<nsIWidget> widget = GetWidget();
14962:   if (!widget)
14962:     return NS_ERROR_FAILURE;
14962: 
14998:   return widget->SynthesizeNativeKeyEvent(aNativeKeyboardLayout, aNativeKeyCode,
14962:                                           aModifiers, aCharacters, aUnmodifiedCharacters);
14962: }
14962: 
15578: NS_IMETHODIMP
32976: nsDOMWindowUtils::SendNativeMouseEvent(PRInt32 aScreenX,
32976:                                        PRInt32 aScreenY,
32976:                                        PRInt32 aNativeMessage,
32976:                                        PRInt32 aModifierFlags,
32976:                                        nsIDOMElement* aElement)
32976: {
39630:   if (!IsUniversalXPConnectCapable()) {
32976:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
32976: 
32976:   // get the widget to send the event to
32976:   nsCOMPtr<nsIWidget> widget = GetWidgetForElement(aElement);
32976:   if (!widget)
32976:     return NS_ERROR_FAILURE;
32976: 
32976:   return widget->SynthesizeNativeMouseEvent(nsIntPoint(aScreenX, aScreenY),
32976:                                             aNativeMessage, aModifierFlags);
32976: }
32976: 
32976: NS_IMETHODIMP
93734: nsDOMWindowUtils::SendNativeMouseScrollEvent(PRInt32 aScreenX,
93734:                                              PRInt32 aScreenY,
93734:                                              PRUint32 aNativeMessage,
93734:                                              double aDeltaX,
93734:                                              double aDeltaY,
93734:                                              double aDeltaZ,
93734:                                              PRUint32 aModifierFlags,
93734:                                              PRUint32 aAdditionalFlags,
93734:                                              nsIDOMElement* aElement)
93734: {
93734:   if (!IsUniversalXPConnectCapable()) {
93734:     return NS_ERROR_DOM_SECURITY_ERR;
93734:   }
93734: 
93734:   // get the widget to send the event to
93734:   nsCOMPtr<nsIWidget> widget = GetWidgetForElement(aElement);
93734:   if (!widget) {
93734:     return NS_ERROR_FAILURE;
93734:   }
93734: 
93734:   return widget->SynthesizeNativeMouseScrollEvent(nsIntPoint(aScreenX,
93734:                                                              aScreenY),
93734:                                                   aNativeMessage,
93734:                                                   aDeltaX, aDeltaY, aDeltaZ,
93734:                                                   aModifierFlags,
93734:                                                   aAdditionalFlags);
93734: }
93734: 
93734: NS_IMETHODIMP
15578: nsDOMWindowUtils::ActivateNativeMenuItemAt(const nsAString& indexString)
15578: {
39630:   if (!IsUniversalXPConnectCapable()) {
15578:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
15578: 
15578:   // get the widget to send the event to
15578:   nsCOMPtr<nsIWidget> widget = GetWidget();
15578:   if (!widget)
15578:     return NS_ERROR_FAILURE;
15578: 
15578:   return widget->ActivateNativeMenuItemAt(indexString);
15578: }
15578: 
16264: NS_IMETHODIMP
21081: nsDOMWindowUtils::ForceUpdateNativeMenuAt(const nsAString& indexString)
16264: {
39630:   if (!IsUniversalXPConnectCapable()) {
16264:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
16264: 
16264:   // get the widget to send the event to
16264:   nsCOMPtr<nsIWidget> widget = GetWidget();
16264:   if (!widget)
16264:     return NS_ERROR_FAILURE;
16264: 
21081:   return widget->ForceUpdateNativeMenuAt(indexString);
16264: }
16264: 
    1: nsIWidget*
21967: nsDOMWindowUtils::GetWidget(nsPoint* aOffset)
    1: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   if (window) {
94546:     nsIDocShell *docShell = window->GetDocShell();
    1:     if (docShell) {
    1:       nsCOMPtr<nsIPresShell> presShell;
    1:       docShell->GetPresShell(getter_AddRefs(presShell));
    1:       if (presShell) {
    1:         nsIFrame* frame = presShell->GetRootFrame();
    1:         if (frame)
21967:           return frame->GetView()->GetNearestWidget(aOffset);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
 3416: 
32976: nsIWidget*
32976: nsDOMWindowUtils::GetWidgetForElement(nsIDOMElement* aElement)
32976: {
32976:   if (!aElement)
32976:     return GetWidget();
32976: 
32976:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
32976:   nsIDocument* doc = content->GetCurrentDoc();
46225:   nsIPresShell* presShell = doc ? doc->GetShell() : nsnull;
32976: 
32976:   if (presShell) {
36657:     nsIFrame* frame = content->GetPrimaryFrame();
32976:     if (!frame) {
32976:       frame = presShell->GetRootFrame();
32976:     }
32976:     if (frame)
47148:       return frame->GetNearestWidget();
32976:   }
32976: 
32976:   return nsnull;
32976: }
32976: 
 3416: NS_IMETHODIMP
 3416: nsDOMWindowUtils::Focus(nsIDOMElement* aElement)
 3416: {
39630:   if (!IsUniversalXPConnectCapable()) {
 6799:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
 6799: 
94546:   nsCOMPtr<nsIDOMWindow> window = do_QueryReferent(mWindow);
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm) {
29018:     if (aElement)
29018:       fm->SetFocus(aElement, 0);
29018:     else
94546:       fm->ClearFocus(window);
 3416:   }
 3416: 
 3416:   return NS_OK;
 3416: }
 3416: 
 7057: NS_IMETHODIMP
88519: nsDOMWindowUtils::GarbageCollect(nsICycleCollectorListener *aListener,
88519:                                  PRInt32 aExtraForgetSkippableCalls)
 7057: {
84290:   SAMPLE_LABEL("GC", "GarbageCollect");
48507:   // Always permit this in debug builds.
 7057: #ifndef DEBUG
39630:   if (!IsUniversalXPConnectCapable()) {
 7057:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
 7057: #endif
 7057: 
89410:   nsJSContext::GarbageCollectNow(js::gcreason::DOM_UTILS);
88519:   nsJSContext::CycleCollectNow(aListener, aExtraForgetSkippableCalls);
 7057: 
 7057:   return NS_OK;
 7057: }
18474: 
74347: NS_IMETHODIMP
88519: nsDOMWindowUtils::CycleCollect(nsICycleCollectorListener *aListener,
88519:                                PRInt32 aExtraForgetSkippableCalls)
74347: {
74347:   // Always permit this in debug builds.
74347: #ifndef DEBUG
74347:   if (!IsUniversalXPConnectCapable()) {
74347:     return NS_ERROR_DOM_SECURITY_ERR;
74347:   }
74347: #endif
74347: 
88519:   nsJSContext::CycleCollectNow(aListener, aExtraForgetSkippableCalls);
74347:   return NS_OK;
74347: }
18474: 
18474: NS_IMETHODIMP
20793: nsDOMWindowUtils::SendSimpleGestureEvent(const nsAString& aType,
23284:                                          float aX,
23284:                                          float aY,
20793:                                          PRUint32 aDirection,
20793:                                          PRFloat64 aDelta,
20793:                                          PRInt32 aModifiers)
20793: {
39630:   if (!IsUniversalXPConnectCapable()) {
20793:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
20793: 
20793:   // get the widget to send the event to
23284:   nsPoint offset;
23284:   nsCOMPtr<nsIWidget> widget = GetWidget(&offset);
20793:   if (!widget)
20793:     return NS_ERROR_FAILURE;
20793: 
20793:   PRInt32 msg;
20793:   if (aType.EqualsLiteral("MozSwipeGesture"))
20793:     msg = NS_SIMPLE_GESTURE_SWIPE;
20793:   else if (aType.EqualsLiteral("MozMagnifyGestureStart"))
20793:     msg = NS_SIMPLE_GESTURE_MAGNIFY_START;
20793:   else if (aType.EqualsLiteral("MozMagnifyGestureUpdate"))
20793:     msg = NS_SIMPLE_GESTURE_MAGNIFY_UPDATE;
20793:   else if (aType.EqualsLiteral("MozMagnifyGesture"))
20793:     msg = NS_SIMPLE_GESTURE_MAGNIFY;
20793:   else if (aType.EqualsLiteral("MozRotateGestureStart"))
20793:     msg = NS_SIMPLE_GESTURE_ROTATE_START;
20793:   else if (aType.EqualsLiteral("MozRotateGestureUpdate"))
20793:     msg = NS_SIMPLE_GESTURE_ROTATE_UPDATE;
20793:   else if (aType.EqualsLiteral("MozRotateGesture"))
20793:     msg = NS_SIMPLE_GESTURE_ROTATE;
26874:   else if (aType.EqualsLiteral("MozTapGesture"))
26874:     msg = NS_SIMPLE_GESTURE_TAP;
26874:   else if (aType.EqualsLiteral("MozPressTapGesture"))
26874:     msg = NS_SIMPLE_GESTURE_PRESSTAP;
20793:   else
20793:     return NS_ERROR_FAILURE;
20793:  
80486:   nsSimpleGestureEvent event(true, msg, widget, aDirection, aDelta);
80486:   event.isShift = (aModifiers & nsIDOMNSEvent::SHIFT_MASK) ? true : false;
80486:   event.isControl = (aModifiers & nsIDOMNSEvent::CONTROL_MASK) ? true : false;
80486:   event.isAlt = (aModifiers & nsIDOMNSEvent::ALT_MASK) ? true : false;
80486:   event.isMeta = (aModifiers & nsIDOMNSEvent::META_MASK) ? true : false;
20793:   event.time = PR_IntervalNow();
20793: 
47902:   nsPresContext* presContext = GetPresContext();
47902:   if (!presContext)
47902:     return NS_ERROR_FAILURE;
47902: 
47902:   PRInt32 appPerDev = presContext->AppUnitsPerDevPixel();
23284:   event.refPoint.x =
23284:     NSAppUnitsToIntPixels(nsPresContext::CSSPixelsToAppUnits(aX) + offset.x,
23284:                           appPerDev);
23284:   event.refPoint.y =
23284:     NSAppUnitsToIntPixels(nsPresContext::CSSPixelsToAppUnits(aY) + offset.y,
23284:                           appPerDev);
23284: 
20793:   nsEventStatus status;
20793:   return widget->DispatchEvent(&event, status);
20793: }
21333: 
21333: NS_IMETHODIMP
40200: nsDOMWindowUtils::ElementFromPoint(float aX, float aY,
79445:                                    bool aIgnoreRootScrollFrame,
79445:                                    bool aFlushLayout,
21333:                                    nsIDOMElement** aReturn)
21333: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
94546:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
21333:   NS_ENSURE_STATE(doc);
21333: 
21333:   return doc->ElementFromPointHelper(aX, aY, aIgnoreRootScrollFrame, aFlushLayout,
21333:                                      aReturn);
21333: }
22197: 
40568: NS_IMETHODIMP
40568: nsDOMWindowUtils::NodesFromRect(float aX, float aY,
40568:                                 float aTopSize, float aRightSize,
40568:                                 float aBottomSize, float aLeftSize,
79445:                                 bool aIgnoreRootScrollFrame,
79445:                                 bool aFlushLayout,
40568:                                 nsIDOMNodeList** aReturn)
40568: {
88444:   if (!IsUniversalXPConnectCapable()) {
88444:     return NS_ERROR_DOM_SECURITY_ERR;
88444:   }
88444: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
94546:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
40568:   NS_ENSURE_STATE(doc);
40568: 
40568:   return doc->NodesFromRectHelper(aX, aY, aTopSize, aRightSize, aBottomSize, aLeftSize, 
40568:                                   aIgnoreRootScrollFrame, aFlushLayout, aReturn);
40568: }
40568: 
22197: static already_AddRefed<gfxImageSurface>
83345: CanvasToImageSurface(nsIDOMHTMLCanvasElement* aCanvas)
22197: {
83345:   nsCOMPtr<nsINode> node = do_QueryInterface(aCanvas);
83345:   if (!node) {
83345:     return nsnull;
83345:   }
83345: 
83345:   NS_ABORT_IF_FALSE(node->IsElement(),
83345:                     "An nsINode that implements nsIDOMHTMLCanvasElement should "
83345:                     "be an element.");
38650:   nsLayoutUtils::SurfaceFromElementResult result =
83345:     nsLayoutUtils::SurfaceFromElement(node->AsElement(),
38650:                                       nsLayoutUtils::SFE_WANT_IMAGE_SURFACE);
38650:   return static_cast<gfxImageSurface*>(result.mSurface.forget().get());
22197: }
22197: 
22197: NS_IMETHODIMP
22197: nsDOMWindowUtils::CompareCanvases(nsIDOMHTMLCanvasElement *aCanvas1,
22197:                                   nsIDOMHTMLCanvasElement *aCanvas2,
22197:                                   PRUint32* aMaxDifference,
22197:                                   PRUint32* retVal)
22197: {
39630:   if (!IsUniversalXPConnectCapable()) {
22197:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
22197: 
22197:   if (aCanvas1 == nsnull ||
22197:       aCanvas2 == nsnull ||
22197:       retVal == nsnull)
22197:     return NS_ERROR_FAILURE;
22197: 
22197:   nsRefPtr<gfxImageSurface> img1 = CanvasToImageSurface(aCanvas1);
22197:   nsRefPtr<gfxImageSurface> img2 = CanvasToImageSurface(aCanvas2);
22197: 
22197:   if (img1 == nsnull || img2 == nsnull ||
22197:       img1->GetSize() != img2->GetSize() ||
22197:       img1->Stride() != img2->Stride())
22197:     return NS_ERROR_FAILURE;
22197: 
22197:   int v;
22197:   gfxIntSize size = img1->GetSize();
22197:   PRUint32 stride = img1->Stride();
22197: 
22197:   // we can optimize for the common all-pass case
22197:   if (stride == (PRUint32) size.width * 4) {
22197:     v = memcmp(img1->Data(), img2->Data(), size.width * size.height * 4);
22197:     if (v == 0) {
22197:       if (aMaxDifference)
22197:         *aMaxDifference = 0;
22197:       *retVal = 0;
22197:       return NS_OK;
22197:     }
22197:   }
22197: 
22197:   PRUint32 dc = 0;
22197:   PRUint32 different = 0;
22197: 
22197:   for (int j = 0; j < size.height; j++) {
22197:     unsigned char *p1 = img1->Data() + j*stride;
22197:     unsigned char *p2 = img2->Data() + j*stride;
22197:     v = memcmp(p1, p2, stride);
22197: 
22197:     if (v) {
22197:       for (int i = 0; i < size.width; i++) {
22197:         if (*(PRUint32*) p1 != *(PRUint32*) p2) {
22197: 
22197:           different++;
22197: 
38330:           dc = NS_MAX((PRUint32)abs(p1[0] - p2[0]), dc);
38330:           dc = NS_MAX((PRUint32)abs(p1[1] - p2[1]), dc);
38330:           dc = NS_MAX((PRUint32)abs(p1[2] - p2[2]), dc);
38330:           dc = NS_MAX((PRUint32)abs(p1[3] - p2[3]), dc);
22197:         }
22197: 
22197:         p1 += 4;
22197:         p2 += 4;
22197:       }
22197:     }
22197:   }
22197: 
22197:   if (aMaxDifference)
22197:     *aMaxDifference = dc;
22197: 
22197:   *retVal = different;
22197:   return NS_OK;
22197: }
23350: 
23350: NS_IMETHODIMP
79445: nsDOMWindowUtils::GetIsMozAfterPaintPending(bool *aResult)
23350: {
80486:   *aResult = false;
23350:   nsPresContext* presContext = GetPresContext();
23350:   if (!presContext)
23350:     return NS_OK;
23350:   *aResult = presContext->IsDOMPaintEventPending();
23350:   return NS_OK;
23350: }
24947: 
24947: NS_IMETHODIMP
25579: nsDOMWindowUtils::ClearMozAfterPaintEvents()
25579: {
25579:   nsPresContext* presContext = GetPresContext();
25579:   if (!presContext)
25579:     return NS_OK;
25579:   presContext->ClearMozAfterPaintEvents();
25579:   return NS_OK;
25579: }
25579: 
25579: NS_IMETHODIMP
79445: nsDOMWindowUtils::DisableNonTestMouseEvents(bool aDisable)
24947: {
39630:   if (!IsUniversalXPConnectCapable()) {
24947:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
24947: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
94546:   nsIDocShell *docShell = window->GetDocShell();
24947:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
24947:   nsCOMPtr<nsIPresShell> presShell;
24947:   docShell->GetPresShell(getter_AddRefs(presShell));
24947:   NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
40052:   presShell->DisableNonTestMouseEvents(aDisable);
40052:   return NS_OK;
24947: }
25722: 
25722: NS_IMETHODIMP
79445: nsDOMWindowUtils::SuppressEventHandling(bool aSuppress)
25722: {
39630:   if (!IsUniversalXPConnectCapable()) {
25722:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
25722: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
94546:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
25722:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
25722: 
25722:   if (aSuppress) {
25722:     doc->SuppressEventHandling();
25722:   } else {
80486:     doc->UnsuppressEventHandlingAndFireEvents(true);
25722:   }
26714: 
25722:   return NS_OK;
25722: }
25722: 
26714: NS_IMETHODIMP
79445: nsDOMWindowUtils::GetScrollXY(bool aFlushLayout, PRInt32* aScrollX, PRInt32* aScrollY)
26714: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
94546:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
26714:   NS_ENSURE_STATE(doc);
26714: 
26714:   if (aFlushLayout) {
26714:     doc->FlushPendingNotifications(Flush_Layout);
26714:   }
26714: 
37063:   nsPoint scrollPos(0,0);
46225:   nsIPresShell *presShell = doc->GetShell();
26714:   if (presShell) {
37063:     nsIScrollableFrame* sf = presShell->GetRootScrollFrameAsScrollable();
37063:     if (sf) {
37063:       scrollPos = sf->GetScrollPosition();
26714:     }
26714:   }
26714: 
37063:   *aScrollX = nsPresContext::AppUnitsToIntCSSPixels(scrollPos.x);
37063:   *aScrollY = nsPresContext::AppUnitsToIntCSSPixels(scrollPos.y);
26714: 
26714:   return NS_OK;
26714: }
27984: 
27984: NS_IMETHODIMP
96351: nsDOMWindowUtils::GetRootBounds(nsIDOMClientRect** aResult)
96351: {
96351:   // Weak ref, since we addref it below
96351:   nsClientRect* rect = new nsClientRect();
96351:   NS_ADDREF(*aResult = rect);
96351: 
96351:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
96351:   NS_ENSURE_STATE(window);
96351: 
96351:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
96351:   NS_ENSURE_STATE(doc);
96351: 
96351:   nsRect bounds(0, 0, 0, 0);
96351:   nsIPresShell* presShell = doc->GetShell();
96351:   if (presShell) {
96351:     nsIScrollableFrame* sf = presShell->GetRootScrollFrameAsScrollable();
96351:     if (sf) {
96351:       bounds = sf->GetScrollRange();
96351:       bounds.width += sf->GetScrollPortRect().width;
96351:       bounds.height += sf->GetScrollPortRect().height;
96351:     } else if (presShell->GetRootFrame()) {
96351:       bounds = presShell->GetRootFrame()->GetRect();
96351:     }
96351:   }
96351: 
96351:   rect->SetRect(nsPresContext::AppUnitsToFloatCSSPixels(bounds.x),
96351:                 nsPresContext::AppUnitsToFloatCSSPixels(bounds.y),
96351:                 nsPresContext::AppUnitsToFloatCSSPixels(bounds.width),
96351:                 nsPresContext::AppUnitsToFloatCSSPixels(bounds.height));
96351:   return NS_OK;
96351: }
96351: 
96351: NS_IMETHODIMP
79445: nsDOMWindowUtils::GetIMEIsOpen(bool *aState)
27984: {
27984:   NS_ENSURE_ARG_POINTER(aState);
27984: 
27984:   nsCOMPtr<nsIWidget> widget = GetWidget();
27984:   if (!widget)
27984:     return NS_ERROR_FAILURE;
27984: 
27984:   // Open state should not be available when IME is not enabled.
82841:   InputContext context = widget->GetInputContext();
82842:   if (context.mIMEState.mEnabled != IMEState::ENABLED) {
27984:     return NS_ERROR_NOT_AVAILABLE;
82840:   }
27984: 
82842:   if (context.mIMEState.mOpen == IMEState::OPEN_STATE_NOT_SUPPORTED) {
82842:     return NS_ERROR_NOT_IMPLEMENTED;
82842:   }
82842:   *aState = (context.mIMEState.mOpen == IMEState::OPEN);
82842:   return NS_OK;
27984: }
27984: 
27984: NS_IMETHODIMP
27984: nsDOMWindowUtils::GetIMEStatus(PRUint32 *aState)
27984: {
27984:   NS_ENSURE_ARG_POINTER(aState);
27984: 
27984:   nsCOMPtr<nsIWidget> widget = GetWidget();
27984:   if (!widget)
27984:     return NS_ERROR_FAILURE;
27984: 
82841:   InputContext context = widget->GetInputContext();
82842:   *aState = static_cast<PRUint32>(context.mIMEState.mEnabled);
58019:   return NS_OK;
58019: }
58019: 
58019: NS_IMETHODIMP
58019: nsDOMWindowUtils::GetFocusedInputType(char** aType)
58019: {
58019:   NS_ENSURE_ARG_POINTER(aType);
58019: 
58019:   nsCOMPtr<nsIWidget> widget = GetWidget();
58019:   if (!widget) {
58019:     return NS_ERROR_FAILURE;
58019:   }
58019: 
82841:   InputContext context = widget->GetInputContext();
58019:   *aType = ToNewCString(context.mHTMLInputType);
58019:   return NS_OK;
27984: }
27984: 
31084: NS_IMETHODIMP
60450: nsDOMWindowUtils::FindElementWithViewId(nsViewID aID,
60450:                                         nsIDOMElement** aResult)
60450: {
60450:   if (aID == FrameMetrics::ROOT_SCROLL_ID) {
60450:     nsPresContext* presContext = GetPresContext();
61804:     if (!presContext) {
61804:       return NS_ERROR_NOT_AVAILABLE;
61804:     }
61804: 
60450:     nsIDocument* document = presContext->Document();
60451:     mozilla::dom::Element* rootElement = document->GetRootElement();
60451:     if (!rootElement) {
60451:       return NS_ERROR_NOT_AVAILABLE;
60451:     }
61804: 
60451:     CallQueryInterface(rootElement, aResult);
60450:     return NS_OK;
60450:   }
60450: 
60450:   nsRefPtr<nsIContent> content = nsLayoutUtils::FindContentFor(aID);
61804:   return content ? CallQueryInterface(content, aResult) : NS_OK;
60450: }
60450: 
60450: NS_IMETHODIMP
31084: nsDOMWindowUtils::GetScreenPixelsPerCSSPixel(float* aScreenPixels)
31084: {
31084:   *aScreenPixels = 1;
31084: 
31084:   if (!nsContentUtils::IsCallerTrustedForRead())
31084:     return NS_ERROR_DOM_SECURITY_ERR;
31084:   nsPresContext* presContext = GetPresContext();
31084:   if (!presContext)
31084:     return NS_OK;
31084: 
31084:   *aScreenPixels = float(nsPresContext::AppUnitsPerCSSPixel())/
31084:       presContext->AppUnitsPerDevPixel();
31084:   return NS_OK;
31084: }
33962: 
33962: NS_IMETHODIMP
34272: nsDOMWindowUtils::DispatchDOMEventViaPresShell(nsIDOMNode* aTarget,
34272:                                                nsIDOMEvent* aEvent,
79445:                                                bool aTrusted,
79445:                                                bool* aRetVal)
34272: {
34272:   if (!nsContentUtils::IsCallerTrustedForRead()) {
34272:     return NS_ERROR_DOM_SECURITY_ERR;
34272:   }
34272: 
34272:   nsPresContext* presContext = GetPresContext();
34272:   NS_ENSURE_STATE(presContext);
34272:   nsCOMPtr<nsIPresShell> shell = presContext->GetPresShell();
34272:   NS_ENSURE_STATE(shell);
34272:   nsCOMPtr<nsIPrivateDOMEvent> event = do_QueryInterface(aEvent);
34272:   NS_ENSURE_STATE(event);
34272:   event->SetTrusted(aTrusted);
34272:   nsEvent* internalEvent = event->GetInternalNSEvent();
34272:   NS_ENSURE_STATE(internalEvent);
34272:   nsCOMPtr<nsIContent> content = do_QueryInterface(aTarget);
34272:   NS_ENSURE_STATE(content);
34272: 
34272:   nsEventStatus status = nsEventStatus_eIgnore;
34272:   shell->HandleEventWithTarget(internalEvent, nsnull, content,
34272:                                &status);
34272:   *aRetVal = (status != nsEventStatus_eConsumeNoDefault);
34272:   return NS_OK;
34272: }
36577: 
39629: static void
39629: InitEvent(nsGUIEvent &aEvent, nsIntPoint *aPt = nsnull)
39629: {
39629:   if (aPt) {
39629:     aEvent.refPoint = *aPt;
39629:   }
39629:   aEvent.time = PR_IntervalNow();
39629: }
39629: 
39629: NS_IMETHODIMP
78627: nsDOMWindowUtils::SendCompositionEvent(const nsAString& aType,
78627:                                        const nsAString& aData,
78627:                                        const nsAString& aLocale)
39629: {
39629:   if (!IsUniversalXPConnectCapable()) {
39629:     return NS_ERROR_DOM_SECURITY_ERR;
39629:   }
39629: 
39629:   // get the widget to send the event to
39629:   nsCOMPtr<nsIWidget> widget = GetWidget();
39629:   if (!widget) {
39629:     return NS_ERROR_FAILURE;
39629:   }
39629: 
39629:   PRUint32 msg;
39629:   if (aType.EqualsLiteral("compositionstart")) {
39629:     msg = NS_COMPOSITION_START;
39629:   } else if (aType.EqualsLiteral("compositionend")) {
39629:     msg = NS_COMPOSITION_END;
78627:   } else if (aType.EqualsLiteral("compositionupdate")) {
78627:     msg = NS_COMPOSITION_UPDATE;
39629:   } else {
39629:     return NS_ERROR_FAILURE;
39629:   }
39629: 
80486:   nsCompositionEvent compositionEvent(true, msg, widget);
39629:   InitEvent(compositionEvent);
78627:   if (msg != NS_COMPOSITION_START) {
78627:     compositionEvent.data = aData;
78627:   }
39629: 
39629:   nsEventStatus status;
39629:   nsresult rv = widget->DispatchEvent(&compositionEvent, status);
39629:   NS_ENSURE_SUCCESS(rv, rv);
39629: 
39629:   return NS_OK;
39629: }
39629: 
39629: static void
39629: AppendClause(PRInt32 aClauseLength, PRUint32 aClauseAttr,
39629:              nsTArray<nsTextRange>* aRanges)
39629: {
39629:   NS_PRECONDITION(aRanges, "aRange is null");
39629:   if (aClauseLength == 0) {
39629:     return;
39629:   }
39629:   nsTextRange range;
39629:   range.mStartOffset = aRanges->Length() == 0 ? 0 :
39629:     aRanges->ElementAt(aRanges->Length() - 1).mEndOffset + 1;
39629:   range.mEndOffset = range.mStartOffset + aClauseLength;
39629:   NS_ASSERTION(range.mStartOffset <= range.mEndOffset, "range is invalid");
39629:   NS_PRECONDITION(aClauseAttr == NS_TEXTRANGE_RAWINPUT ||
39629:                   aClauseAttr == NS_TEXTRANGE_SELECTEDRAWTEXT ||
39629:                   aClauseAttr == NS_TEXTRANGE_CONVERTEDTEXT ||
39629:                   aClauseAttr == NS_TEXTRANGE_SELECTEDCONVERTEDTEXT,
39629:                   "aClauseAttr is invalid value");
39629:   range.mRangeType = aClauseAttr;
39629:   aRanges->AppendElement(range);
39629: }
39629: 
39629: NS_IMETHODIMP
39629: nsDOMWindowUtils::SendTextEvent(const nsAString& aCompositionString,
39629:                                 PRInt32 aFirstClauseLength,
39629:                                 PRUint32 aFirstClauseAttr,
39629:                                 PRInt32 aSecondClauseLength,
39629:                                 PRUint32 aSecondClauseAttr,
39629:                                 PRInt32 aThirdClauseLength,
39629:                                 PRUint32 aThirdClauseAttr,
39629:                                 PRInt32 aCaretStart,
39629:                                 PRInt32 aCaretLength)
39629: {
39629:   if (!IsUniversalXPConnectCapable()) {
39629:     return NS_ERROR_DOM_SECURITY_ERR;
39629:   }
39629: 
39629:   // get the widget to send the event to
39629:   nsCOMPtr<nsIWidget> widget = GetWidget();
39629:   if (!widget) {
39629:     return NS_ERROR_FAILURE;
39629:   }
39629: 
80486:   nsTextEvent textEvent(true, NS_TEXT_TEXT, widget);
39629:   InitEvent(textEvent);
39629: 
39629:   nsAutoTArray<nsTextRange, 4> textRanges;
39629:   NS_ENSURE_TRUE(aFirstClauseLength >= 0,  NS_ERROR_INVALID_ARG);
39629:   NS_ENSURE_TRUE(aSecondClauseLength >= 0, NS_ERROR_INVALID_ARG);
39629:   NS_ENSURE_TRUE(aThirdClauseLength >= 0,  NS_ERROR_INVALID_ARG);
39629:   AppendClause(aFirstClauseLength,  aFirstClauseAttr, &textRanges);
39629:   AppendClause(aSecondClauseLength, aSecondClauseAttr, &textRanges);
39629:   AppendClause(aThirdClauseLength,  aThirdClauseAttr, &textRanges);
39629:   PRInt32 len = aFirstClauseLength + aSecondClauseLength + aThirdClauseLength;
40682:   NS_ENSURE_TRUE(len == 0 || PRUint32(len) == aCompositionString.Length(),
39629:                  NS_ERROR_FAILURE);
39629: 
39629:   if (aCaretStart >= 0) {
39629:     nsTextRange range;
39629:     range.mStartOffset = aCaretStart;
39629:     range.mEndOffset = range.mStartOffset + aCaretLength;
39629:     range.mRangeType = NS_TEXTRANGE_CARETPOSITION;
39629:     textRanges.AppendElement(range);
39629:   }
39629: 
39629:   textEvent.theText = aCompositionString;
39629: 
39629:   textEvent.rangeCount = textRanges.Length();
39629:   textEvent.rangeArray = textRanges.Elements();
39629: 
39629:   nsEventStatus status;
39629:   nsresult rv = widget->DispatchEvent(&textEvent, status);
39629:   NS_ENSURE_SUCCESS(rv, rv);
39629: 
39629:   return NS_OK;
39629: }
39629: 
39629: NS_IMETHODIMP
39629: nsDOMWindowUtils::SendQueryContentEvent(PRUint32 aType,
39629:                                         PRUint32 aOffset, PRUint32 aLength,
39629:                                         PRInt32 aX, PRInt32 aY,
39629:                                         nsIQueryContentEventResult **aResult)
39629: {
39629:   *aResult = nsnull;
39629: 
39629:   if (!IsUniversalXPConnectCapable()) {
39629:     return NS_ERROR_DOM_SECURITY_ERR;
39629:   }
39629: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
48255: 
94546:   nsIDocShell *docShell = window->GetDocShell();
48255:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
48255: 
48255:   nsCOMPtr<nsIPresShell> presShell;
48255:   docShell->GetPresShell(getter_AddRefs(presShell));
48255:   NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
48255: 
48255:   nsPresContext* presContext = presShell->GetPresContext();
48255:   NS_ENSURE_TRUE(presContext, NS_ERROR_FAILURE);
48255: 
39629:   // get the widget to send the event to
39629:   nsCOMPtr<nsIWidget> widget = GetWidget();
39629:   if (!widget) {
39629:     return NS_ERROR_FAILURE;
39629:   }
39629: 
39629:   if (aType != NS_QUERY_SELECTED_TEXT &&
39629:       aType != NS_QUERY_TEXT_CONTENT &&
39629:       aType != NS_QUERY_CARET_RECT &&
39629:       aType != NS_QUERY_TEXT_RECT &&
39629:       aType != NS_QUERY_EDITOR_RECT &&
39629:       aType != NS_QUERY_CHARACTER_AT_POINT) {
39629:     return NS_ERROR_INVALID_ARG;
39629:   }
39629: 
39629:   nsCOMPtr<nsIWidget> targetWidget = widget;
39629:   nsIntPoint pt(aX, aY);
39629: 
39629:   if (aType == QUERY_CHARACTER_AT_POINT) {
39629:     // Looking for the widget at the point.
80486:     nsQueryContentEvent dummyEvent(true, NS_QUERY_CONTENT_STATE, widget);
39629:     InitEvent(dummyEvent, &pt);
39629:     nsIFrame* popupFrame =
48255:       nsLayoutUtils::GetPopupFrameForEventCoordinates(presContext->GetRootPresContext(), &dummyEvent);
39629: 
39629:     nsIntRect widgetBounds;
39629:     nsresult rv = widget->GetClientBounds(widgetBounds);
40682:     NS_ENSURE_SUCCESS(rv, rv);
83107:     widgetBounds.MoveTo(0, 0);
39629: 
39629:     // There is no popup frame at the point and the point isn't in our widget,
39629:     // we cannot process this request.
39629:     NS_ENSURE_TRUE(popupFrame || widgetBounds.Contains(pt),
39629:                    NS_ERROR_FAILURE);
39629: 
39629:     // Fire the event on the widget at the point
39629:     if (popupFrame) {
47148:       targetWidget = popupFrame->GetNearestWidget();
39629:     }
39629:   }
39629: 
39629:   pt += widget->WidgetToScreenOffset() - targetWidget->WidgetToScreenOffset();
39629: 
80486:   nsQueryContentEvent queryEvent(true, aType, targetWidget);
39629:   InitEvent(queryEvent, &pt);
39629: 
39629:   switch (aType) {
39629:     case NS_QUERY_TEXT_CONTENT:
39629:       queryEvent.InitForQueryTextContent(aOffset, aLength);
39629:       break;
39629:     case NS_QUERY_CARET_RECT:
39629:       queryEvent.InitForQueryCaretRect(aOffset);
39629:       break;
39629:     case NS_QUERY_TEXT_RECT:
39629:       queryEvent.InitForQueryTextRect(aOffset, aLength);
39629:       break;
39629:   }
39629: 
39629:   nsEventStatus status;
39629:   nsresult rv = targetWidget->DispatchEvent(&queryEvent, status);
39629:   NS_ENSURE_SUCCESS(rv, rv);
39629: 
39629:   nsQueryContentEventResult* result = new nsQueryContentEventResult();
39629:   NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
39629:   result->SetEventResult(widget, queryEvent);
39629:   NS_ADDREF(*aResult = result);
39629:   return NS_OK;
39629: }
39629: 
39629: NS_IMETHODIMP
39629: nsDOMWindowUtils::SendSelectionSetEvent(PRUint32 aOffset,
39629:                                         PRUint32 aLength,
79445:                                         bool aReverse,
79445:                                         bool *aResult)
39629: {
80486:   *aResult = false;
39629: 
39629:   if (!IsUniversalXPConnectCapable()) {
39629:     return NS_ERROR_DOM_SECURITY_ERR;
39629:   }
39629: 
39629:   // get the widget to send the event to
39629:   nsCOMPtr<nsIWidget> widget = GetWidget();
39629:   if (!widget) {
39629:     return NS_ERROR_FAILURE;
39629:   }
39629: 
80486:   nsSelectionEvent selectionEvent(true, NS_SELECTION_SET, widget);
39629:   InitEvent(selectionEvent);
39629: 
39629:   selectionEvent.mOffset = aOffset;
39629:   selectionEvent.mLength = aLength;
39629:   selectionEvent.mReversed = aReverse;
39629: 
39629:   nsEventStatus status;
39629:   nsresult rv = widget->DispatchEvent(&selectionEvent, status);
39629:   NS_ENSURE_SUCCESS(rv, rv);
39629: 
39629:   *aResult = selectionEvent.mSucceeded;
39629:   return NS_OK;
39629: }
39629: 
36577: NS_IMETHODIMP
36983: nsDOMWindowUtils::SendContentCommandEvent(const nsAString& aType,
36983:                                           nsITransferable * aTransferable)
36983: {
39630:   if (!IsUniversalXPConnectCapable()) {
36983:     return NS_ERROR_DOM_SECURITY_ERR;
39630:   }
36983: 
36983:   // get the widget to send the event to
36983:   nsCOMPtr<nsIWidget> widget = GetWidget();
36983:   if (!widget)
36983:     return NS_ERROR_FAILURE;
36983: 
36983:   PRInt32 msg;
36983:   if (aType.EqualsLiteral("cut"))
36983:     msg = NS_CONTENT_COMMAND_CUT;
36983:   else if (aType.EqualsLiteral("copy"))
36983:     msg = NS_CONTENT_COMMAND_COPY;
36983:   else if (aType.EqualsLiteral("paste"))
36983:     msg = NS_CONTENT_COMMAND_PASTE;
36983:   else if (aType.EqualsLiteral("delete"))
36983:     msg = NS_CONTENT_COMMAND_DELETE;
36983:   else if (aType.EqualsLiteral("undo"))
36983:     msg = NS_CONTENT_COMMAND_UNDO;
36983:   else if (aType.EqualsLiteral("redo"))
36983:     msg = NS_CONTENT_COMMAND_REDO;
36983:   else if (aType.EqualsLiteral("pasteTransferable"))
36983:     msg = NS_CONTENT_COMMAND_PASTE_TRANSFERABLE;
36983:   else
36983:     return NS_ERROR_FAILURE;
36983:  
80486:   nsContentCommandEvent event(true, msg, widget);
36983:   if (msg == NS_CONTENT_COMMAND_PASTE_TRANSFERABLE) {
36983:     event.mTransferable = aTransferable;
36983:   }
36983: 
36983:   nsEventStatus status;
36983:   return widget->DispatchEvent(&event, status);
36983: }
36983: 
36983: NS_IMETHODIMP
83346: nsDOMWindowUtils::GetClassName(const JS::Value& aObject, JSContext* aCx, char** aName)
36577: {
36577:   if (!nsContentUtils::IsCallerTrustedForRead()) {
36577:     return NS_ERROR_DOM_SECURITY_ERR;
36577:   }
36577: 
83346:   // Our argument must be a non-null object.
83346:   if (JSVAL_IS_PRIMITIVE(aObject)) {
83346:     return NS_ERROR_XPC_BAD_CONVERT_JS;
83346:   }
36577: 
89430:   *aName = NS_strdup(JS_GetClass(JSVAL_TO_OBJECT(aObject))->name);
83346:   NS_ABORT_IF_FALSE(*aName, "NS_strdup should be infallible.");
83346:   return NS_OK;
36577: }
40174: 
40174: NS_IMETHODIMP
40174: nsDOMWindowUtils::GetVisitedDependentComputedStyle(
40174:                     nsIDOMElement *aElement, const nsAString& aPseudoElement,
40174:                     const nsAString& aPropertyName, nsAString& aResult)
40174: {
40174:   aResult.Truncate();
40174: 
40174:   if (!IsUniversalXPConnectCapable()) {
40174:     return NS_ERROR_DOM_SECURITY_ERR;
40174:   }
40174: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
40174:   nsCOMPtr<nsIDOMCSSStyleDeclaration> decl;
40174:   nsresult rv =
94546:     window->GetComputedStyle(aElement, aPseudoElement, getter_AddRefs(decl));
40174:   NS_ENSURE_SUCCESS(rv, rv);
40174: 
80486:   static_cast<nsComputedDOMStyle*>(decl.get())->SetExposeVisitedStyle(true);
40174:   rv = decl->GetPropertyValue(aPropertyName, aResult);
80486:   static_cast<nsComputedDOMStyle*>(decl.get())->SetExposeVisitedStyle(false);
40174: 
40174:   return rv;
40174: }
41968: 
41968: NS_IMETHODIMP
47268: nsDOMWindowUtils::EnterModalState()
47268: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
94546:   window->EnterModalState();
47268:   return NS_OK;
47268: }
47268: 
47268: NS_IMETHODIMP
47268: nsDOMWindowUtils::LeaveModalState()
47268: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
94546:   window->LeaveModalState(nsnull);
61768:   return NS_OK;
61768: }
61768: 
61768: NS_IMETHODIMP
61768: nsDOMWindowUtils::EnterModalStateWithWindow(nsIDOMWindow **aWindow)
61768: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
94546:   *aWindow = window->EnterModalState();
61768:   NS_IF_ADDREF(*aWindow);
61768:   return NS_OK;
61768: }
61768: 
61768: NS_IMETHODIMP
61768: nsDOMWindowUtils::LeaveModalStateWithWindow(nsIDOMWindow *aWindow)
61768: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
61768:   NS_ENSURE_ARG_POINTER(aWindow);
94546:   window->LeaveModalState(aWindow);
47268:   return NS_OK;
47268: }
47268: 
47268: NS_IMETHODIMP
79445: nsDOMWindowUtils::IsInModalState(bool *retval)
47268: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
94546:   *retval = static_cast<nsGlobalWindow*>(window.get())->IsInModalState();
47268:   return NS_OK;
47268: }
47268: 
47268: NS_IMETHODIMP
82301: nsDOMWindowUtils::GetParent(const JS::Value& aObject,
82301:                             JSContext* aCx,
82301:                             JS::Value* aParent)
41968: {
41968:   // This wasn't privileged in the past, but better to expose less than more.
41968:   if (!IsUniversalXPConnectCapable()) {
41968:     return NS_ERROR_DOM_SECURITY_ERR;
41968:   }
41968: 
82301:   // First argument must be an object.
82301:   if (JSVAL_IS_PRIMITIVE(aObject)) {
82301:     return NS_ERROR_XPC_BAD_CONVERT_JS;
82301:   }
41968: 
89826:   JSObject* parent = JS_GetParent(JSVAL_TO_OBJECT(aObject));
82301:   *aParent = OBJECT_TO_JSVAL(parent);
41973: 
48622:   // Outerize if necessary.
42728:   if (parent) {
82301:     if (JSObjectOp outerize = js::GetObjectClass(parent)->ext.outerObject) {
82301:       *aParent = OBJECT_TO_JSVAL(outerize(aCx, parent));
82301:     }
41973:   }
41973: 
41968:   return NS_OK;
41968: }
41968: 
42108: NS_IMETHODIMP
42108: nsDOMWindowUtils::GetOuterWindowID(PRUint64 *aWindowID)
42108: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
94546:   NS_ASSERTION(window->IsOuterWindow(), "How did that happen?");
94546:   *aWindowID = window->WindowID();
42108:   return NS_OK;
42108: }
42108: 
42108: NS_IMETHODIMP
42108: nsDOMWindowUtils::GetCurrentInnerWindowID(PRUint64 *aWindowID)
42108: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_TRUE(window, NS_ERROR_NOT_AVAILABLE);
94546: 
94546:   NS_ASSERTION(window->IsOuterWindow(), "How did that happen?");
94546:   nsGlobalWindow* inner =
94546:     static_cast<nsGlobalWindow*>(window.get())->GetCurrentInnerWindowInternal();
42108:   if (!inner) {
42108:     return NS_ERROR_NOT_AVAILABLE;
42108:   }
56273:   *aWindowID = inner->WindowID();
42108:   return NS_OK;
42108: }
48101: 
48101: NS_IMETHODIMP
48101: nsDOMWindowUtils::SuspendTimeouts()
48101: {
48101:   if (!IsUniversalXPConnectCapable()) {
48101:     return NS_ERROR_DOM_SECURITY_ERR;
48101:   }
48101: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
94546: 
94546:   window->SuspendTimeouts();
48101: 
48101:   return NS_OK;
48101: }
48101: 
48101: NS_IMETHODIMP
48101: nsDOMWindowUtils::ResumeTimeouts()
48101: {
48101:   if (!IsUniversalXPConnectCapable()) {
48101:     return NS_ERROR_DOM_SECURITY_ERR;
48101:   }
48101: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
94546: 
94546:   window->ResumeTimeouts();
48101: 
48101:   return NS_OK;
48101: }
51975: 
51975: NS_IMETHODIMP
51975: nsDOMWindowUtils::GetLayerManagerType(nsAString& aType)
51975: {
51975:   nsCOMPtr<nsIWidget> widget = GetWidget();
51975:   if (!widget)
51975:     return NS_ERROR_FAILURE;
51975: 
51975:   LayerManager *mgr = widget->GetLayerManager();
51975:   if (!mgr)
51975:     return NS_ERROR_FAILURE;
51975: 
51975:   mgr->GetBackendName(aType);
51975: 
51975:   return NS_OK;
51975: }
54230: 
86724: NS_IMETHODIMP
86724: nsDOMWindowUtils::StartFrameTimeRecording()
86724: {
86724:   nsCOMPtr<nsIWidget> widget = GetWidget();
86724:   if (!widget)
86724:     return NS_ERROR_FAILURE;
86724: 
86724:   LayerManager *mgr = widget->GetLayerManager();
86724:   if (!mgr)
86724:     return NS_ERROR_FAILURE;
86724: 
86724:   mgr->StartFrameTimeRecording();
86724: 
86724:   return NS_OK;
86724: }
86724: 
86724: NS_IMETHODIMP
86724: nsDOMWindowUtils::StopFrameTimeRecording(PRUint32 *frameCount NS_OUTPARAM, float **frames NS_OUTPARAM)
86724: {
86724:   NS_ENSURE_ARG_POINTER(frameCount);
86724:   NS_ENSURE_ARG_POINTER(frames);
86724: 
86724:   nsCOMPtr<nsIWidget> widget = GetWidget();
86724:   if (!widget)
86724:     return NS_ERROR_FAILURE;
86724: 
86724:   LayerManager *mgr = widget->GetLayerManager();
86724:   if (!mgr)
86724:     return NS_ERROR_FAILURE;
86724: 
86724:   nsTArray<float> frameTimes = mgr->StopFrameTimeRecording();
86724: 
86724:   *frames = nsnull;
86724:   *frameCount = frameTimes.Length();
86724: 
86724:   if (*frameCount != 0) {
86724:     *frames = (float*)nsMemory::Alloc(*frameCount * sizeof(float*));
86724:     if (!*frames)
86724:       return NS_ERROR_OUT_OF_MEMORY;
86724: 
86724:     /* copy over the frame times into the array we just allocated */
86724:     for (PRUint32 i = 0; i < *frameCount; i++) {
86724:       (*frames)[i] = frameTimes[i];
86724:     }
86724:   }
86724: 
86724:   return NS_OK;
86724: }
86724: 
79445: static bool
64094: ComputeAnimationValue(nsCSSProperty aProperty,
64094:                       Element* aElement,
56404:                       const nsAString& aInput,
56404:                       nsStyleAnimation::Value& aOutput)
56404: {
56404: 
64094:   if (!nsStyleAnimation::ComputeValue(aProperty, aElement, aInput,
80486:                                       false, aOutput)) {
80486:     return false;
56404:   }
56404: 
56404:   // This matches TransExtractComputedValue in nsTransitionManager.cpp.
56404:   if (aProperty == eCSSProperty_visibility) {
56404:     NS_ABORT_IF_FALSE(aOutput.GetUnit() == nsStyleAnimation::eUnit_Enumerated,
56404:                       "unexpected unit");
56404:     aOutput.SetIntValue(aOutput.GetIntValue(),
56404:                         nsStyleAnimation::eUnit_Visibility);
56404:   }
56404: 
80486:   return true;
56404: }
56404: 
56404: NS_IMETHODIMP
67983: nsDOMWindowUtils::AdvanceTimeAndRefresh(PRInt64 aMilliseconds)
67983: {
67983:   if (!IsUniversalXPConnectCapable()) {
67983:     return NS_ERROR_DOM_SECURITY_ERR;
67983:   }
67983: 
67983:   GetPresContext()->RefreshDriver()->AdvanceTimeAndRefresh(aMilliseconds);
67983: 
67983:   return NS_OK;
67983: }
67983: 
67983: NS_IMETHODIMP
67983: nsDOMWindowUtils::RestoreNormalRefresh()
67983: {
67983:   if (!IsUniversalXPConnectCapable()) {
67983:     return NS_ERROR_DOM_SECURITY_ERR;
67983:   }
67983: 
67983:   GetPresContext()->RefreshDriver()->RestoreNormalRefresh();
67983: 
67983:   return NS_OK;
67983: }
67983: 
67983: NS_IMETHODIMP
56404: nsDOMWindowUtils::ComputeAnimationDistance(nsIDOMElement* aElement,
56404:                                            const nsAString& aProperty,
56404:                                            const nsAString& aValue1,
56404:                                            const nsAString& aValue2,
56404:                                            double* aResult)
56404: {
56404:   if (!IsUniversalXPConnectCapable()) {
56404:     return NS_ERROR_DOM_SECURITY_ERR;
56404:   }
56404: 
56404:   nsresult rv;
56404:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement, &rv);
56404:   NS_ENSURE_SUCCESS(rv, rv);
56404: 
56404:   // Convert direction-dependent properties as appropriate, e.g.,
56404:   // border-left to border-left-value.
56404:   nsCSSProperty property = nsCSSProps::LookupProperty(aProperty);
56404:   if (property != eCSSProperty_UNKNOWN && nsCSSProps::IsShorthand(property)) {
56404:     nsCSSProperty subprop0 = *nsCSSProps::SubpropertyEntryFor(property);
56404:     if (nsCSSProps::PropHasFlags(subprop0, CSS_PROPERTY_REPORT_OTHER_NAME) &&
56404:         nsCSSProps::OtherNameFor(subprop0) == property) {
56404:       property = subprop0;
56404:     } else {
56404:       property = eCSSProperty_UNKNOWN;
56404:     }
56404:   }
56404: 
56404:   NS_ABORT_IF_FALSE(property == eCSSProperty_UNKNOWN ||
56404:                     !nsCSSProps::IsShorthand(property),
56404:                     "should not have shorthand");
56404: 
56404:   nsStyleAnimation::Value v1, v2;
56404:   if (property == eCSSProperty_UNKNOWN ||
64094:       !ComputeAnimationValue(property, content->AsElement(), aValue1, v1) ||
64094:       !ComputeAnimationValue(property, content->AsElement(), aValue2, v2)) {
56404:     return NS_ERROR_ILLEGAL_VALUE;
56404:   }
56404: 
56404:   if (!nsStyleAnimation::ComputeDistance(property, v1, v2, *aResult)) {
56404:     return NS_ERROR_FAILURE;
56404:   }
56404: 
56404:   return NS_OK;
56404: }
56404: 
54230: nsresult
54230: nsDOMWindowUtils::RenderDocument(const nsRect& aRect,
54230:                                  PRUint32 aFlags,
54230:                                  nscolor aBackgroundColor,
54230:                                  gfxContext* aThebesContext)
54230: {
94546:     nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:     NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
94546: 
54230:     // Get DOM Document
54230:     nsresult rv;
54230:     nsCOMPtr<nsIDOMDocument> ddoc;
94546:     rv = window->GetDocument(getter_AddRefs(ddoc));
54230:     NS_ENSURE_SUCCESS(rv, rv);
54230: 
54230:     // Get Document
54230:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(ddoc, &rv);
54230:     NS_ENSURE_SUCCESS(rv, rv);
54230: 
54230:     // Get Primary Shell
54230:     nsCOMPtr<nsIPresShell> presShell = doc->GetShell();
54230:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
54230: 
54230:     // Render Document
54230:     return presShell->RenderDocument(aRect, aFlags, aBackgroundColor, aThebesContext);
54230: }
54257: 
54257: NS_IMETHODIMP 
54257: nsDOMWindowUtils::GetCursorType(PRInt16 *aCursor)
54257: {
54257:   NS_ENSURE_ARG_POINTER(aCursor);
54257: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);  
94546: 
79445:   bool isSameDoc = false;
94546:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
54257: 
54257:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
54257: 
54257:   do {
54257:     if (nsEventStateManager::sMouseOverDocument == doc.get()) {
80486:       isSameDoc = true;
54257:       break;
54257:     }
54257:   } while ((doc = doc->GetParentDocument()));
54257: 
54257:   if (!isSameDoc) {
54257:     *aCursor = eCursor_none;
54257:     return NS_OK;
54257:   }
54257: 
54257:   nsCOMPtr<nsIWidget> widget = GetWidget();
54257:   if (!widget)
54257:     return NS_ERROR_FAILURE;
54257: 
54257:   // fetch cursor value from window's widget
54257:   *aCursor = widget->GetCursor();
54257: 
54257:   return NS_OK;
54257: }
56274: 
56274: NS_IMETHODIMP
71624: nsDOMWindowUtils::GoOnline()
71624: {
71624:   // This is only allowed from about:neterror, which is unprivileged, so it
71624:   // can't access the io-service itself.
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
94546:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
71624:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
71624:   nsCOMPtr<nsIURI> documentURI;
71624:   documentURI = doc->GetDocumentURI();
71624: 
71624:   nsCAutoString spec;
71624:   documentURI->GetSpec(spec);
71624:   if (!StringBeginsWith(spec,  NS_LITERAL_CSTRING("about:neterror?")))
71624:     return NS_ERROR_DOM_SECURITY_ERR;
71624: 
71624:   nsCOMPtr<nsIIOService> ios = do_GetService("@mozilla.org/network/io-service;1");
71624:   if (ios) {
80486:     ios->SetOffline(false); // !offline
71624:     return NS_OK;
71624:   }
71624:   return NS_ERROR_NOT_AVAILABLE;
71624: }
71624: 
71624: NS_IMETHODIMP
56331: nsDOMWindowUtils::GetDisplayDPI(float *aDPI)
56331: {
56331:   nsCOMPtr<nsIWidget> widget = GetWidget();
56331:   if (!widget)
56331:     return NS_ERROR_FAILURE;
56331: 
56331:   *aDPI = widget->GetDPI();
56331: 
56331:   return NS_OK;
56331: }
56331: 
56331: 
56331: NS_IMETHODIMP
56274: nsDOMWindowUtils::GetOuterWindowWithId(PRUint64 aWindowID,
56274:                                        nsIDOMWindow** aWindow)
56274: {
56286:   if (!IsUniversalXPConnectCapable()) {
56286:     return NS_ERROR_DOM_SECURITY_ERR;
56286:   }
56286: 
56274:   *aWindow = nsGlobalWindow::GetOuterWindowWithId(aWindowID);
56274:   NS_IF_ADDREF(*aWindow);
56274:   return NS_OK;
56274: }
61838: 
78955: NS_IMETHODIMP
78955: nsDOMWindowUtils::WrapDOMFile(nsIFile *aFile,
78955:                               nsIDOMFile **aDOMFile) {
78955:   NS_ADDREF(*aDOMFile = new nsDOMFileFile(aFile));
78955:   return NS_OK;
78955: }
78955: 
61838: #ifdef DEBUG
79445: static bool
61838: CheckLeafLayers(Layer* aLayer, const nsIntPoint& aOffset, nsIntRegion* aCoveredRegion)
61838: {
61838:   gfxMatrix transform;
61838:   if (!aLayer->GetTransform().Is2D(&transform) ||
61838:       transform.HasNonIntegerTranslation())
80486:     return false;
61838:   transform.NudgeToIntegers();
61838:   nsIntPoint offset = aOffset + nsIntPoint(transform.x0, transform.y0);
61838: 
61838:   Layer* child = aLayer->GetFirstChild();
61838:   if (child) {
61838:     while (child) {
61838:       if (!CheckLeafLayers(child, offset, aCoveredRegion))
80486:         return false;
61838:       child = child->GetNextSibling();
61838:     }
61838:   } else {
61838:     nsIntRegion rgn = aLayer->GetVisibleRegion();
61838:     rgn.MoveBy(offset);
61838:     nsIntRegion tmp;
61838:     tmp.And(rgn, *aCoveredRegion);
61838:     if (!tmp.IsEmpty())
80486:       return false;
61838:     aCoveredRegion->Or(*aCoveredRegion, rgn);
61838:   }
61838: 
80486:   return true;
61838: }
61838: #endif
61838: 
61838: NS_IMETHODIMP
79445: nsDOMWindowUtils::LeafLayersPartitionWindow(bool* aResult)
61838: {
61838:   if (!IsUniversalXPConnectCapable()) {
61838:     return NS_ERROR_DOM_SECURITY_ERR;
61838:   }
61838: 
80486:   *aResult = true;
61838: #ifdef DEBUG
61838:   nsIWidget* widget = GetWidget();
61838:   if (!widget)
61838:     return NS_ERROR_FAILURE;
61838:   LayerManager* manager = widget->GetLayerManager();
61838:   if (!manager)
61838:     return NS_ERROR_FAILURE;
61838:   nsPresContext* presContext = GetPresContext();
61838:   if (!presContext)
61838:     return NS_ERROR_FAILURE;
61838:   Layer* root = manager->GetRoot();
61838:   if (!root)
61838:     return NS_ERROR_FAILURE;
61838: 
61838:   nsIntPoint offset(0, 0);
61838:   nsIntRegion coveredRegion;
61838:   if (!CheckLeafLayers(root, offset, &coveredRegion)) {
80486:     *aResult = false;
61838:   }
61838:   if (!coveredRegion.IsEqual(root->GetVisibleRegion())) {
80486:     *aResult = false;
61838:   }
61838: #endif
61838:   return NS_OK;
61838: }
68880: 
68880: NS_IMETHODIMP
79445: nsDOMWindowUtils::GetMayHaveTouchEventListeners(bool* aResult)
68880: {
68880:   if (!IsUniversalXPConnectCapable()) {
68880:     return NS_ERROR_DOM_SECURITY_ERR;
68880:   }
68880: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
94546: 
94546:   nsPIDOMWindow* innerWindow = window->GetCurrentInnerWindow();
80486:   *aResult = innerWindow ? innerWindow->HasTouchEventListeners() : false;
68880:   return NS_OK;
68880: }
68880: 
80875: NS_IMETHODIMP
80875: nsDOMWindowUtils::CheckAndClearPaintedState(nsIDOMElement* aElement, bool* aResult)
80875: {
80875:   if (!aElement) {
80875:     return NS_ERROR_INVALID_ARG;
80875:   }
80875: 
80875:   nsresult rv;
80875:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement, &rv);
80875:   NS_ENSURE_SUCCESS(rv, rv);
80875: 
80875:   nsIFrame* frame = content->GetPrimaryFrame();
80875: 
80875:   if (!frame) {
80875:     *aResult = false;
80875:     return NS_OK;
80875:   }
80875: 
80875:   *aResult = frame->CheckAndClearPaintedState();
80875:   return NS_OK;
80875: }
80875: 
84685: NS_IMETHODIMP
84685: nsDOMWindowUtils::GetFileId(nsIDOMBlob* aBlob, PRInt64* aResult)
84685: {
84685:   if (!IsUniversalXPConnectCapable()) {
84685:     return NS_ERROR_DOM_SECURITY_ERR;
84685:   }
84685: 
84685:   *aResult = aBlob->GetFileId();
84685:   return NS_OK;
84685: }
84685: 
84685: NS_IMETHODIMP
84685: nsDOMWindowUtils::GetFileReferences(const nsAString& aDatabaseName,
84685:                                     PRInt64 aId, PRInt32* aRefCnt,
84685:                                     PRInt32* aDBRefCnt, PRInt32* aSliceRefCnt,
84685:                                     bool* aResult)
84685: {
84685:   if (!IsUniversalXPConnectCapable()) {
84685:     return NS_ERROR_DOM_SECURITY_ERR;
84685:   }
84685: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
84685: 
84685:   nsCString origin;
84685:   nsresult rv = indexedDB::IndexedDatabaseManager::GetASCIIOriginFromWindow(
94546:     window, origin);
84685:   NS_ENSURE_SUCCESS(rv, rv);
84685: 
84685:   nsRefPtr<indexedDB::IndexedDatabaseManager> mgr =
85093:     indexedDB::IndexedDatabaseManager::Get();
84685: 
85093:   if (mgr) {
84685:     nsRefPtr<indexedDB::FileManager> fileManager =
85093:       mgr->GetFileManager(origin, aDatabaseName);
84685: 
85093:     if (fileManager) {
84685:       nsRefPtr<indexedDB::FileInfo> fileInfo = fileManager->GetFileInfo(aId);
85093: 
84685:       if (fileInfo) {
84685:         fileInfo->GetReferences(aRefCnt, aDBRefCnt, aSliceRefCnt);
85093: 
85093:         if (*aRefCnt != -1) {
85093:           // We added an extra temp ref, so account for that accordingly.
85093:           (*aRefCnt)--;
85093:         }
85093: 
84685:         *aResult = true;
84685:         return NS_OK;
84685:       }
85093:     }
85093:   }
84685: 
84685:   *aRefCnt = *aDBRefCnt = *aSliceRefCnt = -1;
84685:   *aResult = false;
84685:   return NS_OK;
84685: }
84803: 
86098: NS_IMETHODIMP
90410: nsDOMWindowUtils::IsIncrementalGCEnabled(JSContext* cx, bool* aResult)
90410: {
90410:   *aResult = js::IsIncrementalGCEnabled(JS_GetRuntime(cx));
90410:   return NS_OK;
90410: }
90410: 
90410: NS_IMETHODIMP
86098: nsDOMWindowUtils::StartPCCountProfiling(JSContext* cx)
84803: {
84803:   js::StartPCCountProfiling(cx);
84803:   return NS_OK;
84803: }
84803: 
84803: NS_IMETHODIMP
86098: nsDOMWindowUtils::StopPCCountProfiling(JSContext* cx)
84803: {
84803:   js::StopPCCountProfiling(cx);
84803:   return NS_OK;
84803: }
84803: 
84803: NS_IMETHODIMP
86098: nsDOMWindowUtils::PurgePCCounts(JSContext* cx)
84803: {
84803:   js::PurgePCCounts(cx);
84803:   return NS_OK;
84803: }
84803: 
84803: NS_IMETHODIMP
86098: nsDOMWindowUtils::GetPCCountScriptCount(JSContext* cx, PRInt32 *result)
84803: {
84803:   *result = js::GetPCCountScriptCount(cx);
84803:   return NS_OK;
84803: }
84803: 
84803: NS_IMETHODIMP
86098: nsDOMWindowUtils::GetPCCountScriptSummary(PRInt32 script, JSContext* cx, nsAString& result)
84803: {
84803:   JSString *text = js::GetPCCountScriptSummary(cx, script);
84803:   if (!text)
84803:     return NS_ERROR_FAILURE;
84803: 
84803:   nsDependentJSString str;
84803:   if (!str.init(cx, text))
84803:     return NS_ERROR_FAILURE;
84803: 
84803:   result = str;
84803:   return NS_OK;
84803: }
84803: 
84803: NS_IMETHODIMP
86098: nsDOMWindowUtils::GetPCCountScriptContents(PRInt32 script, JSContext* cx, nsAString& result)
84803: {
84803:   JSString *text = js::GetPCCountScriptContents(cx, script);
84803:   if (!text)
84803:     return NS_ERROR_FAILURE;
84803: 
84803:   nsDependentJSString str;
84803:   if (!str.init(cx, text))
84803:     return NS_ERROR_FAILURE;
84803: 
84803:   result = str;
84803:   return NS_OK;
84803: }
86563: 
86563: NS_IMETHODIMP
86563: nsDOMWindowUtils::GetPaintingSuppressed(bool *aPaintingSuppressed)
86563: {
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
94546:   nsIDocShell *docShell = window->GetDocShell();
86563:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
86563: 
86563:   nsCOMPtr<nsIPresShell> presShell;
86563:   docShell->GetPresShell(getter_AddRefs(presShell));
86563:   NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
86563: 
86563:   *aPaintingSuppressed = presShell->IsPaintingSuppressed();
86563:   return NS_OK;
86563: }
86563: 
94270: NS_IMETHODIMP
94270: nsDOMWindowUtils::GetPlugins(JSContext* cx, jsval* aPlugins)
94270: {
94270:   if (!IsUniversalXPConnectCapable()) {
94270:     return NS_ERROR_DOM_SECURITY_ERR;
94270:   }
94270: 
94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
94546:   NS_ENSURE_STATE(window);
94546: 
94546:   nsIDOMDocument* ddoc = window->GetExtantDocument();
94270: 
94270:   nsresult rv;
94270:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(ddoc, &rv);
94270:   NS_ENSURE_SUCCESS(rv, rv);
94270: 
94270:   nsTArray<nsIObjectLoadingContent*> plugins;
94270:   doc->GetPlugins(plugins);
94270: 
94270:   JSObject* jsPlugins = nsnull;
94270:   rv = nsTArrayToJSArray(cx, plugins, &jsPlugins);
94270:   NS_ENSURE_SUCCESS(rv, rv);
94270: 
94270:   *aPlugins = OBJECT_TO_JSVAL(jsPlugins);
94270:   return NS_OK;
94270: }
95977: 
95977: NS_IMETHODIMP
95977: nsDOMWindowUtils::SetScrollPositionClampingScrollPortSize(float aWidth, float aHeight)
95977: {
95977:   if (!IsUniversalXPConnectCapable()) {
95977:     return NS_ERROR_DOM_SECURITY_ERR;
95977:   }
95977: 
95977:   if (!(aWidth >= 0.0 && aHeight >= 0.0)) {
95977:     return NS_ERROR_ILLEGAL_VALUE;
95977:   }
95977: 
95977:   nsIPresShell* presShell = GetPresShell();
95977:   if (!presShell) {
95977:     return NS_ERROR_FAILURE;
95977:   }
95977: 
95977:   presShell->SetScrollPositionClampingScrollPortSize(
95977:     nsPresContext::CSSPixelsToAppUnits(aWidth),
95977:     nsPresContext::CSSPixelsToAppUnits(aHeight));
95977: 
95977:   return NS_OK;
95977: }
