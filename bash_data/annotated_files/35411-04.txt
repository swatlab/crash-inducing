    1: //* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla History System
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brett Wilson <brettw@gmail.com> (original author)
 4037:  *   Dietrich Ayala <dietrich@mozilla.com>
  713:  *   Asaf Romano <mano@mozilla.com>
27458:  *   Marco Bonardo <mak77@bonardo.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include <stdio.h>
    1: #include "nsNavHistory.h"
    1: #include "nsNavBookmarks.h"
27458: #include "nsFaviconService.h"
27458: #include "nsITaggingService.h"
27458: #include "nsAnnotationService.h"
27458: 
    1: #include "nsDebug.h"
    1: #include "nsNetUtil.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsString.h"
    1: #include "nsUnicharUtils.h"
    1: #include "prtime.h"
    1: #include "prprf.h"
27458: 
27458: #include "nsIDynamicContainer.h"
    1: #include "mozStorageHelper.h"
 7025: #include "nsCycleCollectionParticipant.h"
33340: #include "nsIClassInfo.h"
33340: #include "nsIProgrammingLanguage.h"
33340: #include "nsIXPCScriptable.h"
    1: 
    1: // What we want is: NS_INTERFACE_MAP_ENTRY(self) for static IID accessors,
    1: // but some of our classes (like nsNavHistoryResult) have an ambiguous base
    1: // class of nsISupports which prevents this from working (the default macro
    1: // converts it to nsISupports, then addrefs it, then returns it). Therefore, we
    1: // expand the macro here and change it so that it works. Yuck.
    1: #define NS_INTERFACE_MAP_STATIC_AMBIGUOUS(_class) \
    1:   if (aIID.Equals(NS_GET_IID(_class))) { \
    1:     NS_ADDREF(this); \
    1:     *aInstancePtr = this; \
    1:     return NS_OK; \
    1:   } else
    1: 
    1: // emulate string comparison (used for sorting) for PRTime and int
    1: inline PRInt32 ComparePRTime(PRTime a, PRTime b)
    1: {
    1:   if (LL_CMP(a, <, b))
    1:     return -1;
    1:   else if (LL_CMP(a, >, b))
    1:     return 1;
    1:   return 0;
    1: }
    1: inline PRInt32 CompareIntegers(PRUint32 a, PRUint32 b)
    1: {
    1:   return a - b;
    1: }
    1: 
33340: namespace mozilla {
33340:   namespace places {
33340:     // Class-info and the scriptable helper are implemented in order to
33340:     // allow the JS frontend code to set expando properties on result nodes.
33340:     class ResultNodeClassInfo : public nsIClassInfo
33340:                               , public nsIXPCScriptable
33340:     {
33340:       NS_DECL_ISUPPORTS
33340:       NS_DECL_NSIXPCSCRIPTABLE
33340: 
33340:       // TODO: Bug 517718.
33340:       NS_IMETHODIMP
33340:       GetInterfaces(PRUint32 *_count, nsIID ***_array)
33340:       {
33340:         *_count = 0;
33340:         *_array = nsnull;
33340: 
33340:         return NS_OK;
33340:       }
33340: 
33340:       NS_IMETHODIMP
33340:       GetHelperForLanguage(PRUint32 aLanguage, nsISupports **_helper)
33340:       {
33340:         if (aLanguage == nsIProgrammingLanguage::JAVASCRIPT) {
33340:           *_helper = static_cast<nsIXPCScriptable *>(this);
33340:           NS_ADDREF(*_helper);
33340:         }
33340:         else
33340:           *_helper = nsnull;
33340: 
33340:         return NS_OK;
33340:       }
33340: 
33340:       NS_IMETHODIMP
33340:       GetContractID(char **_contractID)
33340:       {
33340:         *_contractID = nsnull;
33340:         return NS_OK;
33340:       }
33340: 
33340:       NS_IMETHODIMP
33340:       GetClassDescription(char **_desc)
33340:       {
33340:         *_desc = nsnull;
33340:         return NS_OK;
33340:       }
33340: 
33340:       NS_IMETHODIMP
33340:       GetClassID(nsCID **_id)
33340:       {
33340:         *_id = nsnull;
33340:         return NS_OK;
33340:       }
33340: 
33340:       NS_IMETHODIMP
33340:       GetImplementationLanguage(PRUint32 *_language)
33340:       {
33340:         *_language = nsIProgrammingLanguage::CPLUSPLUS;
33340:         return NS_OK;
33340:       }
33340: 
33340:       NS_IMETHODIMP
33340:       GetFlags(PRUint32 *_flags)
33340:       {
33340:         *_flags = 0;
33340:         return NS_OK;
33340:       }
33340: 
33340:       NS_IMETHODIMP
33340:       GetClassIDNoAlloc(nsCID *_cid)
33340:       {
33340:         return NS_ERROR_NOT_AVAILABLE;
33340:       }
33340:     };
33340: 
33340:     /**
33340:      * As a static implementation of classinfo, we violate XPCOM rules andjust
33340:      * pretend to use the refcount mechanism.  See classinfo documentation at
33340:      * https://developer.mozilla.org/en/Using_nsIClassInfo
33340:      */
33340:     NS_IMETHODIMP_(nsrefcnt) ResultNodeClassInfo::AddRef()
33340:     {
33340:       return 2;
33340:     }
33340:     NS_IMETHODIMP_(nsrefcnt) ResultNodeClassInfo::Release()
33340:     {
33340:       return 1;
33340:     }
33340: 
33340:     NS_IMPL_QUERY_INTERFACE2(ResultNodeClassInfo, nsIClassInfo, nsIXPCScriptable)
33340: 
33340: #define XPC_MAP_CLASSNAME ResultNodeClassInfo
33340: #define XPC_MAP_QUOTED_CLASSNAME "ResultNodeClassInfo"
33340: #define XPC_MAP_FLAGS nsIXPCScriptable::USE_JSSTUB_FOR_ADDPROPERTY | \
33340:                       nsIXPCScriptable::USE_JSSTUB_FOR_DELPROPERTY | \
33340:                       nsIXPCScriptable::USE_JSSTUB_FOR_SETPROPERTY
33340: 
33340: // xpc_map_end contains implementation for nsIXPCScriptable, that used the
33340: // constant define above
33340: #include "xpc_map_end.h"    
33340: 
33340:     static ResultNodeClassInfo sResultNodeClassInfo;
33340:   } // namespace places
33340: } // namespace mozilla
33340: 
33340: using namespace mozilla::places;
    1: 
    1: // nsNavHistoryResultNode ******************************************************
    1: 
15172: NS_IMPL_CYCLE_COLLECTION_CLASS(nsNavHistoryResultNode)
15172: 
15172: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsNavHistoryResultNode)
15172:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mParent)
15172: NS_IMPL_CYCLE_COLLECTION_UNLINK_END 
15172: 
15172: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsNavHistoryResultNode)
15172:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mParent, nsINavHistoryContainerResultNode);
15172: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 7025: 
 7025: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNavHistoryResultNode)
 7025:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsINavHistoryResultNode)
33340:   if (aIID.Equals(NS_GET_IID(nsIClassInfo)))
33340:     foundInterface = static_cast<nsIClassInfo *>(&mozilla::places::sResultNodeClassInfo);
33340:   else
 7025:   NS_INTERFACE_MAP_ENTRY(nsINavHistoryResultNode)
 7025: NS_INTERFACE_MAP_END
 7025: 
 7025: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsNavHistoryResultNode, nsINavHistoryResultNode)
 7025: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsNavHistoryResultNode, nsINavHistoryResultNode)
    1: 
    1: nsNavHistoryResultNode::nsNavHistoryResultNode(
    1:     const nsACString& aURI, const nsACString& aTitle, PRUint32 aAccessCount,
    1:     PRTime aTime, const nsACString& aIconURI) :
    1:   mParent(nsnull),
    1:   mURI(aURI),
    1:   mTitle(aTitle),
    1:   mAccessCount(aAccessCount),
    1:   mTime(aTime),
    1:   mFaviconURI(aIconURI),
    1:   mBookmarkIndex(-1),
 1337:   mItemId(-1),
33458:   mFolderId(-1),
 1604:   mDateAdded(0),
 1604:   mLastModified(0),
33340:   mIndentLevel(-1)
    1: {
 9553:   mTags.SetIsVoid(PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
33340: nsNavHistoryResultNode::GetIcon(nsACString& aIcon)
    1: {
    1:   if (mFaviconURI.IsEmpty()) {
33340:     aIcon.Truncate();
    1:     return NS_OK;
    1:   }
33340: 
15040:   nsFaviconService* faviconService = nsFaviconService::GetFaviconService();
15040:   NS_ENSURE_TRUE(faviconService, NS_ERROR_OUT_OF_MEMORY);
33340:   faviconService->GetFaviconSpecForIconString(mFaviconURI, aIcon);
33340:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryResultNode::GetParent(nsINavHistoryContainerResultNode** aParent)
    1: {
    1:   NS_IF_ADDREF(*aParent = mParent);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 7159: nsNavHistoryResultNode::GetParentResult(nsINavHistoryResult** aResult)
 7159: {
 7159:   *aResult = nsnull;
 7159:   if (IsContainer() && GetAsContainer()->mResult) {
 7159:     NS_ADDREF(*aResult = GetAsContainer()->mResult);
 7159:   } else if (mParent && mParent->mResult) {
 7159:     NS_ADDREF(*aResult = mParent->mResult);
 7159:   } else {
 7159:    return NS_ERROR_UNEXPECTED;
 7159:   }
 7159: 
 7159:   return NS_OK;
 7159: }
 7159: 
 7159: NS_IMETHODIMP
 9553: nsNavHistoryResultNode::GetTags(nsAString& aTags) {
 9553:   // Only URI-nodes may be associated with tags
 9553:   if (!IsURI()) {
 9553:     aTags.Truncate();
 9553:     return NS_OK;
 9553:   }
 9553: 
11421:   // Initially, the tags string is set to a void string (see constructor). We
 9553:   // then build it the first time this method called is called (and by that,
 9553:   // implicitly unset the void flag). Result observers may re-set the void flag
 9553:   // in order to force rebuilding of the tags string.
24582:   if (!mTags.IsVoid()) {
 9553:     aTags.Assign(mTags);
 9553:     return NS_OK;
 9553:   }
 9553: 
21343:   // Fetch the tags
21343:   nsNavHistory *history = nsNavHistory::GetHistoryService();
35411:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
21343:   mozIStorageStatement *getTagsStatement = history->DBGetTags();
35411:   NS_ENSURE_STATE(getTagsStatement);
21343:   mozStorageStatementScoper scoper(getTagsStatement);
33458:   nsresult rv = getTagsStatement->BindInt64Parameter(0, history->GetTagsFolder());
 9553:   NS_ENSURE_SUCCESS(rv, rv);
33458:   rv = getTagsStatement->BindUTF8StringParameter(1, mURI);
 9553:   NS_ENSURE_SUCCESS(rv, rv);
21343: 
21343:   PRBool hasTags = PR_FALSE;
21343:   if (NS_SUCCEEDED(getTagsStatement->ExecuteStep(&hasTags)) && hasTags) {
21343:     rv = getTagsStatement->GetString(0, mTags);
21343:     NS_ENSURE_SUCCESS(rv, rv);
 9553:     aTags.Assign(mTags);
21343:   }
 9553: 
 9553:   // If this node is a child of a history, we need to make sure
 9553:   // bookmarks-liveupdate is turned on for this query
 9553:   if (mParent && mParent->IsQuery()) {
 9553:     nsNavHistoryQueryResultNode* query = mParent->GetAsQuery();
 9553:     if (query->mLiveUpdate != QUERYUPDATE_COMPLEX_WITH_BOOKMARKS) {
 9553:       query->mLiveUpdate = QUERYUPDATE_COMPLEX_WITH_BOOKMARKS;
 9553:       nsNavHistoryResult* result = query->GetResult();
 9553:       NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
 9553:       result->AddAllBookmarksObserver(query);
 9553:     }
 9553:   }
 9553:   return NS_OK;
 9553: }
 9553: 
    1: // nsNavHistoryResultNode::OnRemoving
    1: //
    1: //    This will zero out some values in case somebody still holds a reference
    1: 
    1: void
    1: nsNavHistoryResultNode::OnRemoving()
    1: {
    1:   mParent = nsnull;
    1: }
    1: 
    1: 
    1: // nsNavHistoryResultNode::GetResult
    1: //
    1: //    This will find the result for this node. We can ask the nearest container
    1: //    for this value (either ourselves or our parents should be a container,
    1: //    and all containers have result pointers).
    1: 
    1: nsNavHistoryResult*
    1: nsNavHistoryResultNode::GetResult()
    1: {
    1:   nsNavHistoryResultNode* node = this;
    1:   do {
    1:     if (node->IsContainer()) {
    1:       nsNavHistoryContainerResultNode* container =
 3233:         static_cast<nsNavHistoryContainerResultNode*>(node);
    1:       NS_ASSERTION(container->mResult, "Containers must have valid results");
    1:       return container->mResult;
    1:     }
    1:     node = node->mParent;
    1:   } while (node);
    1:   NS_NOTREACHED("No container node found in hierarchy!");
    1:   return nsnull;
    1: }
    1: 
    1: // nsNavHistoryResultNode::GetGeneratingOptions
    1: //
    1: //    Searches up the tree for the closest node that has an options structure.
    1: //    This will tell us the options that were used to generate this node.
    1: //
    1: //    Be careful, this function walks up the tree, so it can not be used when
    1: //    result nodes are created because they have no parent. Only call this
    1: //    function after the tree has been built.
    1: 
    1: nsNavHistoryQueryOptions*
    1: nsNavHistoryResultNode::GetGeneratingOptions()
    1: {
    1:   if (! mParent) {
    1:     // When we have no parent, it either means we haven't built the tree yet,
    1:     // in which case calling this function is a bug, or this node is the root
    1:     // of the tree. When we are the root of the tree, our own options are the
 4179:     // generating options.
 4179:     if (IsContainer())
 4179:       return GetAsContainer()->mOptions;
    1:     NS_NOTREACHED("Can't find a generating node for this container, perhaps FillStats has not been called on this tree yet?");
    1:     return nsnull;
    1:   }
    1: 
    1:   nsNavHistoryContainerResultNode* cur = mParent;
    1:   while (cur) {
    1:     if (cur->IsFolder())
    1:       return cur->GetAsFolder()->mOptions;
    1:     else if (cur->IsQuery())
    1:       return cur->GetAsQuery()->mOptions;
    1:     cur = cur->mParent;
    1:   }
    1:   // we should always find a folder or query node as an ancestor
    1:   NS_NOTREACHED("Can't find a generating node for this container, the tree seemes corrupted.");
    1:   return nsnull;
    1: }
    1: 
    1: 
    1: // nsNavHistoryVisitResultNode *************************************************
    1: 
    1: NS_IMPL_ISUPPORTS_INHERITED1(nsNavHistoryVisitResultNode,
    1:                              nsNavHistoryResultNode,
    1:                              nsINavHistoryVisitResultNode)
    1: 
    1: nsNavHistoryVisitResultNode::nsNavHistoryVisitResultNode(
    1:     const nsACString& aURI, const nsACString& aTitle, PRUint32 aAccessCount,
    1:     PRTime aTime, const nsACString& aIconURI, PRInt64 aSession) :
    1:   nsNavHistoryResultNode(aURI, aTitle, aAccessCount, aTime, aIconURI),
    1:   mSessionId(aSession)
    1: {
    1: }
    1: 
    1: 
    1: // nsNavHistoryFullVisitResultNode *********************************************
    1: 
    1: NS_IMPL_ISUPPORTS_INHERITED1(nsNavHistoryFullVisitResultNode,
    1:                              nsNavHistoryVisitResultNode,
    1:                              nsINavHistoryFullVisitResultNode)
    1: 
    1: nsNavHistoryFullVisitResultNode::nsNavHistoryFullVisitResultNode(
    1:     const nsACString& aURI, const nsACString& aTitle, PRUint32 aAccessCount,
    1:     PRTime aTime, const nsACString& aIconURI, PRInt64 aSession,
    1:     PRInt64 aVisitId, PRInt64 aReferringVisitId, PRInt32 aTransitionType) :
    1:   nsNavHistoryVisitResultNode(aURI, aTitle, aAccessCount, aTime, aIconURI,
    1:                               aSession),
    1:   mVisitId(aVisitId),
    1:   mReferringVisitId(aReferringVisitId),
    1:   mTransitionType(aTransitionType)
    1: {
    1: }
    1: 
    1: // nsNavHistoryContainerResultNode *********************************************
    1: 
 7025: NS_IMPL_CYCLE_COLLECTION_CLASS(nsNavHistoryContainerResultNode)
 7025: 
 7025: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsNavHistoryContainerResultNode, nsNavHistoryResultNode)
 7025:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mResult)
 7025:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mChildren)
 7025: NS_IMPL_CYCLE_COLLECTION_UNLINK_END 
 7025: 
 7025: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsNavHistoryContainerResultNode, nsNavHistoryResultNode)
 7025:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mResult, nsINavHistoryResult)
 7025:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mChildren)
 7025: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 7025: 
    1: NS_IMPL_ADDREF_INHERITED(nsNavHistoryContainerResultNode, nsNavHistoryResultNode)
    1: NS_IMPL_RELEASE_INHERITED(nsNavHistoryContainerResultNode, nsNavHistoryResultNode)
    1: 
 7025: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsNavHistoryContainerResultNode)
    1:   NS_INTERFACE_MAP_STATIC_AMBIGUOUS(nsNavHistoryContainerResultNode)
    1:   NS_INTERFACE_MAP_ENTRY(nsINavHistoryContainerResultNode)
    1: NS_INTERFACE_MAP_END_INHERITING(nsNavHistoryResultNode)
    1: 
    1: nsNavHistoryContainerResultNode::nsNavHistoryContainerResultNode(
    1:     const nsACString& aURI, const nsACString& aTitle,
    1:     const nsACString& aIconURI, PRUint32 aContainerType, PRBool aReadOnly,
 4179:     const nsACString& aDynamicContainerType, nsNavHistoryQueryOptions* aOptions) :
    1:   nsNavHistoryResultNode(aURI, aTitle, 0, 0, aIconURI),
    1:   mResult(nsnull),
    1:   mContainerType(aContainerType),
    1:   mExpanded(PR_FALSE),
    1:   mChildrenReadOnly(aReadOnly),
12001:   mOptions(aOptions),
12001:   mDynamicContainerType(aDynamicContainerType)
    1: {
    1: }
    1: 
12328: nsNavHistoryContainerResultNode::nsNavHistoryContainerResultNode(
12328:     const nsACString& aURI, const nsACString& aTitle,
12328:     PRTime aTime,
12328:     const nsACString& aIconURI, PRUint32 aContainerType, PRBool aReadOnly,
12328:     const nsACString& aDynamicContainerType, 
12328:     nsNavHistoryQueryOptions* aOptions) :
12328:   nsNavHistoryResultNode(aURI, aTitle, 0, aTime, aIconURI),
12328:   mResult(nsnull),
12328:   mContainerType(aContainerType),
12328:   mExpanded(PR_FALSE),
12328:   mChildrenReadOnly(aReadOnly),
14274:   mOptions(aOptions),
14274:   mDynamicContainerType(aDynamicContainerType)
12328: {
12328: }
    1: 
27458: nsNavHistoryContainerResultNode::~nsNavHistoryContainerResultNode()
27458: {
27458:   // Explicitly clean up array of children of this container.  We must ensure
27458:   // all references are gone and all of their destructors are called.
27458:   mChildren.Clear();
27458: }
27458: 
    1: // nsNavHistoryContainerResultNode::OnRemoving
    1: //
    1: //    Containers should notify their children that they are being removed
    1: //    when the container is being removed.
    1: 
    1: void
    1: nsNavHistoryContainerResultNode::OnRemoving()
    1: {
    1:   nsNavHistoryResultNode::OnRemoving();
    1:   for (PRInt32 i = 0; i < mChildren.Count(); i ++)
    1:     mChildren[i]->OnRemoving();
    1:   mChildren.Clear();
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::AreChildrenVisible
    1: 
    1: PRBool
    1: nsNavHistoryContainerResultNode::AreChildrenVisible()
    1: {
    1:   nsNavHistoryResult* result = GetResult();
    1:   if (!result) {
    1:     NS_NOTREACHED("Invalid result");
    1:     return PR_FALSE;
    1:   }
33340: 
33340:   // can't see children when we're invisible
33340:   if (!mExpanded)
33340:     return PR_FALSE;
33340: 
33340:   // Now check if any ancestor is closed.
33340:   nsNavHistoryContainerResultNode* ancestor = mParent;
33340:   while (ancestor) {
33340:     if (!ancestor->mExpanded)
33340:       return PR_FALSE;
33340: 
33340:     ancestor = ancestor->mParent;
33340:   }
33340: 
33314:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::GetContainerOpen
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::GetContainerOpen(PRBool *aContainerOpen)
    1: {
    1:   *aContainerOpen = mExpanded;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::SetContainerOpen
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::SetContainerOpen(PRBool aContainerOpen)
    1: {
    1:   if (mExpanded && ! aContainerOpen)
    1:     CloseContainer();
    1:   else if (! mExpanded && aContainerOpen)
    1:     OpenContainer();
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::OpenContainer
    1: //
    1: //    This handles the generic container case. Other container types should
    1: //    override this to do their own handling.
    1: 
    1: nsresult
    1: nsNavHistoryContainerResultNode::OpenContainer()
    1: {
    1:   NS_ASSERTION(! mExpanded, "Container must be expanded to close it");
    1:   mExpanded = PR_TRUE;
    1: 
 4179:   if (IsDynamicContainer()) {
 4179:     // dynamic container API may want to fill us
    1:     nsresult rv;
 4179:     nsCOMPtr<nsIDynamicContainer> svc = do_GetService(mDynamicContainerType.get(), &rv);
    1:     if (NS_SUCCEEDED(rv)) {
 4179:       svc->OnContainerNodeOpening(this, GetGeneratingOptions());
    1:     } else {
 4179:       NS_WARNING("Unable to get dynamic container for ");
 4179:       NS_WARNING(mDynamicContainerType.get());
    1:     }
    1:     PRInt32 oldAccessCount = mAccessCount;
    1:     FillStats();
    1:     ReverseUpdateStats(mAccessCount - oldAccessCount);
    1:   }
    1: 
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1:   if (result->GetView())
    1:     result->GetView()->ContainerOpened(this);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::CloseContainer
    1: //
    1: //    Set aUpdateVisible to redraw the screen, this is the normal operation.
    1: //    This is set to false for the recursive calls since the root container
    1: //    that is being closed will handle recomputation of the visible elements
    1: //    for its entire subtree.
    1: 
    1: nsresult
    1: nsNavHistoryContainerResultNode::CloseContainer(PRBool aUpdateView)
    1: {
    1:   NS_ASSERTION(mExpanded, "Container must be expanded to close it");
    1: 
    1:   // recursively close all child containers
    1:   for (PRInt32 i = 0; i < mChildren.Count(); i ++) {
29235:     if (mChildren[i]->IsContainer() &&
29235:         mChildren[i]->GetAsContainer()->mExpanded)
    1:       mChildren[i]->GetAsContainer()->CloseContainer(PR_FALSE);
    1:   }
    1: 
    1:   mExpanded = PR_FALSE;
    1: 
    1:   nsresult rv;
 4179:   if (IsDynamicContainer()) {
 4179:     // notify dynamic containers that we are closing
29235:     nsCOMPtr<nsIDynamicContainer> svc =
29235:       do_GetService(mDynamicContainerType.get(), &rv);
    1:     if (NS_SUCCEEDED(rv))
 4179:       svc->OnContainerNodeClosed(this);
 4179:   }
    1: 
29235:   nsNavHistoryResult* result = GetResult();
    1:   if (aUpdateView) {
    1:     NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1:     if (result->GetView())
    1:       result->GetView()->ContainerClosed(this);
    1:   }
29235: 
29235:   // If this is the root container of a result, we can tell the result to stop
29235:   // observing changes, otherwise the result will stay in memory and updates
29235:   // itself till it is cycle collected.
31038:   if (result->mRootNode == this) {
29235:     result->StopObserving();
31038:     // When reopening this node its result will be out of sync.
31038:     // We must clear our children to ensure we will call FillChildren
31038:     // again in such a case.
31038:     if (this->IsQuery())
31038:       this->GetAsQuery()->ClearChildren(PR_TRUE);
31038:     else if (this->IsFolder())
31038:       this->GetAsFolder()->ClearChildren(PR_TRUE);
31038:   }
29235: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::FillStats
    1: //
    1: //    This builds up tree statistics from the bottom up. Call with a container
    1: //    and the indent level of that container. To init the full tree, call with
    1: //    the root container. The default indent level is -1, which is appropriate
    1: //    for the root level.
    1: //
    1: //    CALL THIS AFTER FILLING ANY CONTAINER to update the parent and result
    1: //    node pointers, even if you don't care about visit counts and last visit
    1: //    dates.
    1: 
    1: void
    1: nsNavHistoryContainerResultNode::FillStats()
    1: {
12328:   PRUint32 accessCount = 0;
12328:   PRTime newTime = 0;
12328: 
    1:   for (PRInt32 i = 0; i < mChildren.Count(); i ++) {
    1:     nsNavHistoryResultNode* node = mChildren[i];
    1:     node->mParent = this;
    1:     node->mIndentLevel = mIndentLevel + 1;
    1:     if (node->IsContainer()) {
    1:       nsNavHistoryContainerResultNode* container = node->GetAsContainer();
    1:       container->mResult = mResult;
    1:       container->FillStats();
    1:     }
12328:     accessCount += node->mAccessCount;
    1:     // this is how container nodes get sorted by date
    1:     // The container gets the most recent time of the child nodes.
12328:     if (node->mTime > newTime)
12328:       newTime = node->mTime;
12328:   }
12328: 
12328:   if (mExpanded) {
12328:     mAccessCount = accessCount;
12328:     if (!IsQuery() || newTime > mTime)
12328:       mTime = newTime;
    1:   }
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::ReverseUpdateStats
    1: //
    1: //    This is used when one container changes to do a minimal update of the
    1: //    tree structure. When something changes, you want to call FillStats if
    1: //    necessary and update this container completely. Then call this function
    1: //    which will walk up the tree and fill in the previous containers.
    1: //
    1: //    Note that you have to tell us by how much our access count changed. Our
    1: //    access count should already be set to the new value; this is used to
    1: //    change the parents without having to re-count all their children.
    1: //
    1: //    This does NOT update the last visit date downward. Therefore, if you are
    1: //    deleting a node that has the most recent last visit date, the parents
    1: //    will not get their last visit dates downshifted accordingly. This is a
    1: //    rather unusual case: we don't often delete things, and we usually don't
    1: //    even show the last visit date for folders. Updating would be slower
    1: //    because we would have to recompute it from scratch.
    1: 
    1: void
    1: nsNavHistoryContainerResultNode::ReverseUpdateStats(PRInt32 aAccessCountChange)
    1: {
    1:   if (mParent) {
33340:     nsNavHistoryResult* result = GetResult();
33340:     PRBool shouldUpdateView = result && result->GetView() &&
33340:                               mParent->mParent &&
33340:                               mParent->mParent->AreChildrenVisible();
33340: 
    1:     mParent->mAccessCount += aAccessCountChange;
    1:     PRBool timeChanged = PR_FALSE;
    1:     if (mTime > mParent->mTime) {
    1:       timeChanged = PR_TRUE;
    1:       mParent->mTime = mTime;
    1:     }
    1: 
33340:     if (shouldUpdateView) {
33340:       result->GetView()->NodeHistoryDetailsChanged(
33340:         static_cast<nsINavHistoryContainerResultNode*>(mParent),
33340:         mParent->mTime,
33340:         mParent->mAccessCount);
33340:     }
33340: 
    1:     // check sorting, the stats may have caused this node to move if the
    1:     // sorting depended on something we are changing.
  809:     PRUint16 sortMode = mParent->GetSortType();
33340:     PRBool sortingByVisitCount =
33340:       sortMode == nsINavHistoryQueryOptions::SORT_BY_VISITCOUNT_ASCENDING ||
33340:       sortMode == nsINavHistoryQueryOptions::SORT_BY_VISITCOUNT_DESCENDING;
33340:     PRBool sortingByTime =
33340:       sortMode == nsINavHistoryQueryOptions::SORT_BY_DATE_ASCENDING ||
33340:       sortMode == nsINavHistoryQueryOptions::SORT_BY_DATE_DESCENDING;
33340: 
33340:     if ((sortingByVisitCount && aAccessCountChange != 0) ||
33340:         (sortingByTime && timeChanged)) {
 9714:       PRUint32 ourIndex = mParent->FindChild(this);
33340:       EnsureItemPosition(ourIndex);
    1:     }
    1: 
    1:     mParent->ReverseUpdateStats(aAccessCountChange);
    1:   }
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::GetSortType
    1: //
    1: //    This walks up the tree until we find a query result node or the root to
    1: //    get the sorting type.
    1: //
    1: //    See nsNavHistoryQueryResultNode::GetSortType
    1: 
  809: PRUint16
    1: nsNavHistoryContainerResultNode::GetSortType()
    1: {
    1:   if (mParent)
    1:     return mParent->GetSortType();
    1:   else if (mResult)
    1:     return mResult->mSortingMode;
    1:   NS_NOTREACHED("We should always have a result");
    1:   return nsINavHistoryQueryOptions::SORT_BY_NONE;
    1: }
    1: 
  713: void
  713: nsNavHistoryContainerResultNode::GetSortingAnnotation(nsACString& aAnnotation)
  713: {
  713:   if (mParent)
  713:     mParent->GetSortingAnnotation(aAnnotation);
  713:   else if (mResult)
  713:     aAnnotation.Assign(mResult->mSortingAnnotation);
  713:   else
  713:     NS_NOTREACHED("We should always have a result");
  713: }
    1: 
    1: // nsNavHistoryContainerResultNode::GetSortingComparator
    1: //
    1: //    Returns the sorting comparator function for the give sort type.
    1: //    RETURNS NULL if there is no comparator.
    1: 
    1: nsNavHistoryContainerResultNode::SortComparator
  809: nsNavHistoryContainerResultNode::GetSortingComparator(PRUint16 aSortType)
    1: {
    1:   switch (aSortType)
    1:   {
    1:     case nsINavHistoryQueryOptions::SORT_BY_NONE:
    1:       return &SortComparison_Bookmark;
    1:     case nsINavHistoryQueryOptions::SORT_BY_TITLE_ASCENDING:
    1:       return &SortComparison_TitleLess;
    1:     case nsINavHistoryQueryOptions::SORT_BY_TITLE_DESCENDING:
    1:       return &SortComparison_TitleGreater;
    1:     case nsINavHistoryQueryOptions::SORT_BY_DATE_ASCENDING:
    1:       return &SortComparison_DateLess;
    1:     case nsINavHistoryQueryOptions::SORT_BY_DATE_DESCENDING:
    1:       return &SortComparison_DateGreater;
    1:     case nsINavHistoryQueryOptions::SORT_BY_URI_ASCENDING:
    1:       return &SortComparison_URILess;
    1:     case nsINavHistoryQueryOptions::SORT_BY_URI_DESCENDING:
    1:       return &SortComparison_URIGreater;
    1:     case nsINavHistoryQueryOptions::SORT_BY_VISITCOUNT_ASCENDING:
    1:       return &SortComparison_VisitCountLess;
    1:     case nsINavHistoryQueryOptions::SORT_BY_VISITCOUNT_DESCENDING:
    1:       return &SortComparison_VisitCountGreater;
 1429:     case nsINavHistoryQueryOptions::SORT_BY_KEYWORD_ASCENDING:
 1429:       return &SortComparison_KeywordLess;
 1429:     case nsINavHistoryQueryOptions::SORT_BY_KEYWORD_DESCENDING:
 1429:       return &SortComparison_KeywordGreater;
  713:     case nsINavHistoryQueryOptions::SORT_BY_ANNOTATION_ASCENDING:
  713:       return &SortComparison_AnnotationLess;
  713:     case nsINavHistoryQueryOptions::SORT_BY_ANNOTATION_DESCENDING:
  713:       return &SortComparison_AnnotationGreater;
 1604:     case nsINavHistoryQueryOptions::SORT_BY_DATEADDED_ASCENDING:
 1604:       return &SortComparison_DateAddedLess;
 1604:     case nsINavHistoryQueryOptions::SORT_BY_DATEADDED_DESCENDING:
 1604:       return &SortComparison_DateAddedGreater;
 1604:     case nsINavHistoryQueryOptions::SORT_BY_LASTMODIFIED_ASCENDING:
 1604:       return &SortComparison_LastModifiedLess;
 1604:     case nsINavHistoryQueryOptions::SORT_BY_LASTMODIFIED_DESCENDING:
 1604:       return &SortComparison_LastModifiedGreater;
 9553:     case nsINavHistoryQueryOptions::SORT_BY_TAGS_ASCENDING:
 9553:       return &SortComparison_TagsLess;
 9553:     case nsINavHistoryQueryOptions::SORT_BY_TAGS_DESCENDING:
 9553:       return &SortComparison_TagsGreater;
    1:     default:
    1:       NS_NOTREACHED("Bad sorting type");
    1:       return nsnull;
    1:   }
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::RecursiveSort
    1: //
    1: //    This is used by Result::SetSortingMode and QueryResultNode::FillChildren to sort
    1: //    the child list.
    1: //
    1: //    This does NOT update any visibility or tree information. The caller will
    1: //    have to completely rebuild the visible list after this.
    1: 
    1: void
    1: nsNavHistoryContainerResultNode::RecursiveSort(
  713:     const char* aData, SortComparator aComparator)
    1: {
 3233:   void* data = const_cast<void*>(static_cast<const void*>(aData));
  713: 
  713:   mChildren.Sort(aComparator, data);
    1:   for (PRInt32 i = 0; i < mChildren.Count(); i ++) {
    1:     if (mChildren[i]->IsContainer())
  713:       mChildren[i]->GetAsContainer()->RecursiveSort(aData, aComparator);
    1:   }
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::FindInsertionPoint
    1: //
    1: //    This returns the index that the given item would fall on if it were to
    1: //    be inserted using the given sorting.
    1: 
    1: PRUint32
    1: nsNavHistoryContainerResultNode::FindInsertionPoint(
  713:     nsNavHistoryResultNode* aNode, SortComparator aComparator,
12328:     const char* aData, PRBool* aItemExists)
    1: {
12328:   if (aItemExists)
12328:     (*aItemExists) = PR_FALSE;
12328: 
    1:   if (mChildren.Count() == 0)
    1:     return 0;
    1: 
 3233:   void* data = const_cast<void*>(static_cast<const void*>(aData));
    1: 
    1:   // The common case is the beginning or the end because this is used to insert
    1:   // new items that are added to history, which is usually sorted by date.
12328:   PRInt32 res;
12328:   res = aComparator(aNode, mChildren[0], data);
12328:   if (res <= 0) {
12328:     if (aItemExists && res == 0)
12328:       (*aItemExists) = PR_TRUE;
    1:     return 0;
12328:   }
12328:   res = aComparator(aNode, mChildren[mChildren.Count() - 1], data);
12328:   if (res >= 0) {
12328:     if (aItemExists && res == 0)
12328:       (*aItemExists) = PR_TRUE;
    1:     return mChildren.Count();
12328:   }
    1: 
    1:   PRUint32 beginRange = 0; // inclusive
    1:   PRUint32 endRange = mChildren.Count(); // exclusive
    1:   while (1) {
    1:     if (beginRange == endRange)
    1:       return endRange;
    1:     PRUint32 center = beginRange + (endRange - beginRange) / 2;
12328:     PRInt32 res = aComparator(aNode, mChildren[center], data);
12328:     if (res <= 0) {
    1:       endRange = center; // left side
12328:       if (aItemExists && res == 0)
12328:         (*aItemExists) = PR_TRUE;
12328:     }
12328:     else {
    1:       beginRange = center + 1; // right site
    1:     }
    1:   }
12328: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::DoesChildNeedResorting
    1: //
    1: //    This checks the child node at the given index to see if its sorting is
    1: //    correct. Returns true if not and it should be resorted. This is called
    1: //    when nodes are updated and we need to see whether we need to move it.
    1: 
    1: PRBool
    1: nsNavHistoryContainerResultNode::DoesChildNeedResorting(PRUint32 aIndex,
  713:     SortComparator aComparator, const char* aData)
    1: {
    1:   NS_ASSERTION(aIndex >= 0 && aIndex < PRUint32(mChildren.Count()),
    1:                "Input index out of range");
    1:   if (mChildren.Count() == 1)
    1:     return PR_FALSE;
    1: 
 3233:   void* data = const_cast<void*>(static_cast<const void*>(aData));
  713: 
  713:   if (aIndex > 0) {
  713:     // compare to previous item
  713:     if (aComparator(mChildren[aIndex - 1], mChildren[aIndex], data) > 0)
  713:       return PR_TRUE;
  713:   }
  713:   if (aIndex < PRUint32(mChildren.Count()) - 1) {
  713:     // compare to next item
  713:     if (aComparator(mChildren[aIndex], mChildren[aIndex + 1], data) > 0)
  713:       return PR_TRUE;
  713:   }
  713:   return PR_FALSE;
  713: }
  713: 
  713: 
  713: /* static */
  713: PRInt32 nsNavHistoryContainerResultNode::SortComparison_StringLess(
  713:     const nsAString& a, const nsAString& b) {
  713: 
    1:   nsNavHistory* history = nsNavHistory::GetHistoryService();
    1:   NS_ENSURE_TRUE(history, 0);
    1:   nsICollation* collation = history->GetCollation();
12328:   NS_ENSURE_TRUE(collation, 0);
  713: 
  713:   PRInt32 res = 0;
  713:   collation->CompareString(nsICollation::kCollationCaseInSensitive, a, b, &res);
  713:   return res;
  713: }
    1: 
    1: // nsNavHistoryContainerResultNode::SortComparison_Bookmark
    1: //
    1: //    When there are bookmark indices, we should never have ties, so we don't
    1: //    need to worry about tiebreaking. When there are no bookmark indices,
    1: //    everything will be -1 and we don't worry about sorting.
    1: 
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_Bookmark(
    1:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
    1: {
    1:   return a->mBookmarkIndex - b->mBookmarkIndex;
    1: }
    1: 
    1: // nsNavHistoryContainerResultNode::SortComparison_Title*
    1: //
    1: //    These are a little more complicated because they do a localization
    1: //    conversion. If this is too slow, we can compute the sort keys once in
    1: //    advance, sort that array, and then reorder the real array accordingly.
    1: //    This would save some key generations.
    1: //
    1: //    The collation object must be allocated before sorting on title!
    1: 
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_TitleLess(
    1:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
    1: {
  387:   PRUint32 aType;
    1:   a->GetType(&aType);
    1: 
  713:   PRInt32 value = SortComparison_StringLess(NS_ConvertUTF8toUTF16(a->mTitle),
  713:                                             NS_ConvertUTF8toUTF16(b->mTitle));
    1:   if (value == 0) {
    1:     // resolve by URI
    1:     if (a->IsURI()) {
    1:       value = a->mURI.Compare(b->mURI.get());
    1:     }
    1:     if (value == 0) {
    1:       // resolve by date
  863:       value = ComparePRTime(a->mTime, b->mTime);
  863:       if (value == 0)
  863:         value = nsNavHistoryContainerResultNode::SortComparison_Bookmark(a, b, closure);
    1:     }
    1:   }
    1:   return value;
    1: }
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_TitleGreater(
    1:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
    1: {
    1:   return -SortComparison_TitleLess(a, b, closure);
    1: }
    1: 
    1: // nsNavHistoryContainerResultNode::SortComparison_Date*
    1: //
    1: //    Equal times will be very unusual, but it is important that there is some
    1: //    deterministic ordering of the results so they don't move around.
    1: 
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_DateLess(
    1:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
    1: {
    1:   PRInt32 value = ComparePRTime(a->mTime, b->mTime);
    1:   if (value == 0) {
  713:     value = SortComparison_StringLess(NS_ConvertUTF8toUTF16(a->mTitle),
  713:                                       NS_ConvertUTF8toUTF16(b->mTitle));
  863:     if (value == 0)
  863:       value = nsNavHistoryContainerResultNode::SortComparison_Bookmark(a, b, closure);
    1:   }
    1:   return value;
    1: }
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_DateGreater(
    1:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
    1: {
  863:   return -nsNavHistoryContainerResultNode::SortComparison_DateLess(a, b, closure);
    1: }
    1: 
 1604: // nsNavHistoryContainerResultNode::SortComparison_DateAdded*
 1604: //
 1604: 
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_DateAddedLess(
 1604:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
 1604: {
 1604:   PRInt32 value = ComparePRTime(a->mDateAdded, b->mDateAdded);
 1604:   if (value == 0) {
 1604:     value = SortComparison_StringLess(NS_ConvertUTF8toUTF16(a->mTitle),
 1604:                                       NS_ConvertUTF8toUTF16(b->mTitle));
 1604:     if (value == 0)
 1604:       value = nsNavHistoryContainerResultNode::SortComparison_Bookmark(a, b, closure);
 1604:   }
 1604:   return value;
 1604: }
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_DateAddedGreater(
 1604:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
 1604: {
 1604:   return -nsNavHistoryContainerResultNode::SortComparison_DateAddedLess(a, b, closure);
 1604: }
 1604: 
 1604: 
 1604: // nsNavHistoryContainerResultNode::SortComparison_LastModified*
 1604: //
 1604: 
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_LastModifiedLess(
 1604:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
 1604: {
 1604:   PRInt32 value = ComparePRTime(a->mLastModified, b->mLastModified);
 1604:   if (value == 0) {
 1604:     value = SortComparison_StringLess(NS_ConvertUTF8toUTF16(a->mTitle),
 1604:                                       NS_ConvertUTF8toUTF16(b->mTitle));
 1604:     if (value == 0)
 1604:       value = nsNavHistoryContainerResultNode::SortComparison_Bookmark(a, b, closure);
 1604:   }
 1604:   return value;
 1604: }
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_LastModifiedGreater(
 1604:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
 1604: {
 1604:   return -nsNavHistoryContainerResultNode::SortComparison_LastModifiedLess(a, b, closure);
 1604: }
    1: 
    1: // nsNavHistoryContainerResultNode::SortComparison_URI*
    1: //
    1: //    Certain types of parent nodes are treated specially because URIs are not
    1: //    valid (like days or hosts).
    1: 
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_URILess(
    1:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
    1: {
    1:   PRInt32 value;
  387:   if (a->IsURI() && b->IsURI()) {
    1:     // normal URI or visit
    1:     value = a->mURI.Compare(b->mURI.get());
    1:   } else {
    1:     // for everything else, use title (= host name)
  713:     value = SortComparison_StringLess(NS_ConvertUTF8toUTF16(a->mTitle),
  713:                                       NS_ConvertUTF8toUTF16(b->mTitle));
    1:   }
    1: 
    1:   if (value == 0) {
  863:     value = ComparePRTime(a->mTime, b->mTime);
  863:     if (value == 0)
  863:       value = nsNavHistoryContainerResultNode::SortComparison_Bookmark(a, b, closure);
    1:   }
    1:   return value;
    1: }
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_URIGreater(
    1:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
    1: {
    1:   return -SortComparison_URILess(a, b, closure);
    1: }
    1: 
 1429: // nsNavHistoryContainerResultNode::SortComparison_Keyword*
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_KeywordLess(
 1429:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
 1429: {
 1429:   PRInt32 value = 0;
 1429:   if (a->mItemId != -1 || b->mItemId != -1) {
 1429:     // compare the keywords
23868:     nsAutoString keywordA, keywordB;
 1429:     nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
 1429:     NS_ENSURE_TRUE(bookmarks, 0);
 1429: 
 1429:     nsresult rv;
 1429:     if (a->mItemId != -1) {
23868:       rv = bookmarks->GetKeywordForBookmark(a->mItemId, keywordA);
 1429:       NS_ENSURE_SUCCESS(rv, 0);
 1429:     }
 1429:     if (b->mItemId != -1) {
23868:       rv = bookmarks->GetKeywordForBookmark(b->mItemId, keywordB);
 1429:       NS_ENSURE_SUCCESS(rv, 0);
 1429:     }
 1429: 
23868:     value = SortComparison_StringLess(keywordA, keywordB);
 1429:   }
 1429: 
 1429:   // fall back to title sorting
 1429:   if (value == 0)
 1429:     value = SortComparison_TitleLess(a, b, closure);
 1429: 
 1429:   return value;
 1429: }
 1429: 
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_KeywordGreater(
 1429:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
 1429: {
 1429:   return -SortComparison_KeywordLess(a, b, closure);
 1429: }
    1: 
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_AnnotationLess(
  713:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
  713: {
 3233:   nsCAutoString annoName(static_cast<char*>(closure));
  713:   NS_ENSURE_TRUE(!annoName.IsEmpty(), 0);
  713:   
  713:   nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
  713:   NS_ENSURE_TRUE(bookmarks, 0);
  713: 
 1337:   PRBool a_itemAnno = PR_FALSE;
 1337:   PRBool b_itemAnno = PR_FALSE;
 1337: 
 1337:   // Not used for item annos
 1337:   nsCOMPtr<nsIURI> a_uri, b_uri;
 1337:   if (a->mItemId != -1) {
 1337:     a_itemAnno = PR_TRUE;
  713:   } else {
  713:     nsCAutoString spec;
  713:     if (NS_SUCCEEDED(a->GetUri(spec)))
  713:       NS_NewURI(getter_AddRefs(a_uri), spec);
  713:     NS_ENSURE_TRUE(a_uri, 0);
 1337:   }
 1337: 
 1337:   if (b->mItemId != -1) {
 1337:     b_itemAnno = PR_TRUE;
  713:   } else {
  713:     nsCAutoString spec;
  713:     if (NS_SUCCEEDED(b->GetUri(spec)))
  713:       NS_NewURI(getter_AddRefs(b_uri), spec);
  713:     NS_ENSURE_TRUE(b_uri, 0);
 1337:   }
  713: 
  713:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
  713:   NS_ENSURE_TRUE(annosvc, 0);
  713: 
  713:   PRBool a_hasAnno, b_hasAnno;
 1337:   if (a_itemAnno) {
 1337:     NS_ENSURE_SUCCESS(annosvc->ItemHasAnnotation(a->mItemId, annoName,
 1337:                                                  &a_hasAnno), 0);
 1337:   } else {
 1337:     NS_ENSURE_SUCCESS(annosvc->PageHasAnnotation(a_uri, annoName,
 1337:                                                  &a_hasAnno), 0);
 1337:   }
 1337:   if (b_itemAnno) {
 1337:     NS_ENSURE_SUCCESS(annosvc->ItemHasAnnotation(b->mItemId, annoName,
 1337:                                                  &b_hasAnno), 0);
 1337:   } else {
 1337:     NS_ENSURE_SUCCESS(annosvc->PageHasAnnotation(b_uri, annoName,
 1337:                                                  &b_hasAnno), 0);    
 1337:   }
  713: 
  713:   PRInt32 value = 0;
 1337:   if (a_hasAnno || b_hasAnno) {
 1337:     PRUint16 annoType;
 1337:     if (a_hasAnno) {
 1337:       if (a_itemAnno) {
 1337:         NS_ENSURE_SUCCESS(annosvc->GetItemAnnotationType(a->mItemId,
 1337:                                                          annoName,
 1337:                                                          &annoType), 0);
 1337:       } else {
 1337:         NS_ENSURE_SUCCESS(annosvc->GetPageAnnotationType(a_uri, annoName,
 1337:                                                          &annoType), 0);
 1337:       }
 1337:     }
 1337:     if (b_hasAnno) {
 1337:       PRUint16 b_type;
 1337:       if (b_itemAnno) {
 1337:         NS_ENSURE_SUCCESS(annosvc->GetItemAnnotationType(b->mItemId,
 1337:                                                          annoName,
 1337:                                                          &b_type), 0);
 1337:       } else {
 1337:         NS_ENSURE_SUCCESS(annosvc->GetPageAnnotationType(b_uri, annoName,
 1337:                                                          &b_type), 0);
 1337:       }
 1337:       // We better make the API not support this state, really
 3330:       // XXXmano: this is actually wrong for double<->int and int64<->int32
 1429:       if (a_hasAnno && b_type != annoType)
 1337:         return 0;
 1429:       annoType = b_type;
 1337:     }
 1337: 
 1337: #define GET_ANNOTATIONS_VALUES(METHOD_ITEM, METHOD_PAGE, A_VAL, B_VAL)        \
 1337:         if (a_hasAnno) {                                                      \
 1337:           if (a_itemAnno) {                                                   \
 1337:             NS_ENSURE_SUCCESS(annosvc->METHOD_ITEM(a->mItemId, annoName,      \
 1337:                                                    A_VAL), 0);                \
 1337:           } else {                                                            \
 1337:             NS_ENSURE_SUCCESS(annosvc->METHOD_PAGE(a_uri, annoName,           \
 1337:                                                    A_VAL), 0);                \
 1337:           }                                                                   \
 1337:         }                                                                     \
 1337:         if (b_hasAnno) {                                                      \
 1337:           if (b_itemAnno) {                                                   \
 1337:             NS_ENSURE_SUCCESS(annosvc->METHOD_ITEM(b->mItemId, annoName,      \
 1337:                                                    B_VAL), 0);                \
 1337:           } else {                                                            \
 1337:             NS_ENSURE_SUCCESS(annosvc->METHOD_PAGE(b_uri, annoName,           \
 1337:                                                    B_VAL), 0);                \
 1337:           }                                                                   \
 1337:         }
  713: 
  713:     // Surprising as it is, we don't support sorting by a binary annotation
 1337:     if (annoType != nsIAnnotationService::TYPE_BINARY) {
 1337:       if (annoType == nsIAnnotationService::TYPE_STRING) {
  713:         nsAutoString a_val, b_val;
 1337:         GET_ANNOTATIONS_VALUES(GetItemAnnotationString,
 1337:                                GetPageAnnotationString, a_val, b_val);
  713:         value = SortComparison_StringLess(a_val, b_val);
  713:       }
 1337:       else if (annoType == nsIAnnotationService::TYPE_INT32) {
 1337:         PRInt32 a_val = 0, b_val = 0;
 1337:         GET_ANNOTATIONS_VALUES(GetItemAnnotationInt32,
 1337:                                GetPageAnnotationInt32, &a_val, &b_val);
24465:         value = (a_val < b_val) ? -1 : (a_val > b_val) ? 1 : 0;
  713:       }
 1337:       else if (annoType == nsIAnnotationService::TYPE_INT64) {
 1337:         PRInt64 a_val = 0, b_val = 0;
 1337:         GET_ANNOTATIONS_VALUES(GetItemAnnotationInt64,
 1337:                                GetPageAnnotationInt64, &a_val, &b_val);
24465:         value = (a_val < b_val) ? -1 : (a_val > b_val) ? 1 : 0;
  713:       }
 1337:       else if (annoType == nsIAnnotationService::TYPE_DOUBLE) {
 1337:         double a_val = 0, b_val = 0;
 1337:         GET_ANNOTATIONS_VALUES(GetItemAnnotationDouble,
 1337:                                GetPageAnnotationDouble, &a_val, &b_val);
24465:         value = (a_val < b_val) ? -1 : (a_val > b_val) ? 1 : 0;
  713:       }
  713:     }
  713:   }
  713: 
  713:   // Note we also fall back to the title-sorting route one of the items didn't
  713:   // have the annotation set or if both had it set but in a different storage
  713:   // type
  713:   if (value == 0)
  713:     return SortComparison_TitleLess(a, b, nsnull);
  713: 
  713:   return value;
  713: }
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_AnnotationGreater(
  713:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
  713: {
  713:   return -SortComparison_AnnotationLess(a, b, closure);
  713: }
  713: 
    1: // nsNavHistoryContainerResultNode::SortComparison_VisitCount*
    1: //
    1: //    Fall back on dates for conflict resolution
    1: 
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_VisitCountLess(
    1:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
    1: {
    1:   PRInt32 value = CompareIntegers(a->mAccessCount, b->mAccessCount);
  863:   if (value == 0) {
  863:     value = ComparePRTime(a->mTime, b->mTime);
    1:     if (value == 0)
  863:       value = nsNavHistoryContainerResultNode::SortComparison_Bookmark(a, b, closure);
  863:   }
    1:   return value;
    1: }
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_VisitCountGreater(
    1:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
    1: {
  863:   return -nsNavHistoryContainerResultNode::SortComparison_VisitCountLess(a, b, closure);
    1: }
    1: 
    1: 
 9553: // nsNavHistoryContainerResultNode::SortComparison_Tags*
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_TagsLess(
 9553:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
 9553: {
 9553:   PRInt32 value = 0;
 9553:   nsAutoString aTags, bTags;
 9553: 
 9553:   nsresult rv = a->GetTags(aTags);
 9553:   NS_ENSURE_SUCCESS(rv, 0);
 9553: 
 9553:   rv = b->GetTags(bTags);
 9553:   NS_ENSURE_SUCCESS(rv, 0);
 9553: 
 9553:   value = SortComparison_StringLess(aTags, bTags);
 9553: 
 9553:   // fall back to title sorting
 9553:   if (value == 0)
 9553:     value = SortComparison_TitleLess(a, b, closure);
 9553: 
 9553:   return value;
 9553: }
 9553: 
20261: PRInt32 nsNavHistoryContainerResultNode::SortComparison_TagsGreater(
 9553:     nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure)
 9553: {
 9553:   return -SortComparison_TagsLess(a, b, closure);
 9553: }
 9553: 
    1: // nsNavHistoryContainerResultNode::FindChildURI
    1: //
    1: //    Searches this folder for a node with the given URI. Returns null if not
    1: //    found. Does not addref the node!
    1: 
    1: nsNavHistoryResultNode*
    1: nsNavHistoryContainerResultNode::FindChildURI(const nsACString& aSpec,
    1:     PRUint32* aNodeIndex)
    1: {
    1:   for (PRInt32 i = 0; i < mChildren.Count(); i ++) {
    1:     if (mChildren[i]->IsURI()) {
    1:       if (aSpec.Equals(mChildren[i]->mURI)) {
    1:         *aNodeIndex = i;
    1:         return mChildren[i];
    1:       }
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: //  nsNavHistoryContainerResultNode::FindChildContainerByName
    1: //
    1: //    Searches this container for a subfolder with the given name. This is used
    1: //    to find host and "day" nodes. Returns null if not found. DOES NOT ADDREF.
    1: 
    1: nsNavHistoryContainerResultNode*
    1: nsNavHistoryContainerResultNode::FindChildContainerByName(
    1:     const nsACString& aTitle, PRUint32* aNodeIndex)
    1: {
    1:   for (PRInt32 i = 0; i < mChildren.Count(); i ++) {
    1:     if (mChildren[i]->IsContainer()) {
    1:       nsNavHistoryContainerResultNode* container =
    1:           mChildren[i]->GetAsContainer();
    1:       if (container->mTitle.Equals(aTitle)) {
    1:         *aNodeIndex = i;
    1:         return container;
    1:       }
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::InsertChildAt
    1: //
    1: //    This does the work of adding a child to the container. This child can be
    1: //    a container, or a single item that may even be collapsed with the
    1: //    adjacent ones.
    1: //
    1: //    Some inserts are "temporary" meaning that they are happening immediately
    1: //    after a temporary remove. We do this when movings elements when they
    1: //    change to keep them in the proper sorting position. In these cases, we
    1: //    don't need to recompute any statistics.
    1: 
    1: nsresult
    1: nsNavHistoryContainerResultNode::InsertChildAt(nsNavHistoryResultNode* aNode,
    1:                                                PRInt32 aIndex,
    1:                                                PRBool aIsTemporary)
    1: {
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1: 
    1:   aNode->mParent = this;
    1:   aNode->mIndentLevel = mIndentLevel + 1;
    1:   if (! aIsTemporary && aNode->IsContainer()) {
    1:     // need to update all the new item's children
    1:     nsNavHistoryContainerResultNode* container = aNode->GetAsContainer();
    1:     container->mResult = mResult;
    1:     container->FillStats();
    1:   }
    1: 
    1:   if (! mChildren.InsertObjectAt(aNode, aIndex))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // update our (the container) stats and refresh our row on the screen
    1:   if (! aIsTemporary) {
    1:     mAccessCount += aNode->mAccessCount;
    1:     if (mTime < aNode->mTime)
    1:       mTime = aNode->mTime;
 5933:     if (result->GetView() && (!mParent || mParent->AreChildrenVisible()))
33340:       result->GetView()->NodeHistoryDetailsChanged(
33340:           static_cast<nsINavHistoryContainerResultNode*>(this), mTime,
33340:           mAccessCount);
    1:     ReverseUpdateStats(aNode->mAccessCount);
    1:   }
    1: 
    1:   // Update tree if we are visible. Note that we could be here and not expanded,
    1:   // like when there is a bookmark folder being updated because its parent is
    1:   // visible.
 5933:   if (result->GetView() && AreChildrenVisible())
33340:     result->GetView()->NodeInserted(this, aNode, aIndex);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::InsertSortedChild
    1: //
    1: //    This locates the proper place for insertion according to the current sort
    1: //    and calls InsertChildAt
    1: 
    1: nsresult
    1: nsNavHistoryContainerResultNode::InsertSortedChild(
12328:     nsNavHistoryResultNode* aNode, 
12328:     PRBool aIsTemporary, PRBool aIgnoreDuplicates)
    1: {
    1: 
    1:   if (mChildren.Count() == 0)
    1:     return InsertChildAt(aNode, 0, aIsTemporary);
    1: 
    1:   SortComparator comparator = GetSortingComparator(GetSortType());
    1:   if (comparator) {
    1:     // When inserting a new node, it must have proper statistics because we use
    1:     // them to find the correct insertion point. The insert function will then
    1:     // recompute these statistics and fill in the proper parents and hierarchy
    1:     // level. Doing this twice shouldn't be a large performance penalty because
    1:     // when we are inserting new containers, they typically contain only one
    1:     // item (because we've browsed a new page).
 6822:     if (! aIsTemporary && aNode->IsContainer()) {
 6822:       // need to update all the new item's children
 6822:       nsNavHistoryContainerResultNode* container = aNode->GetAsContainer();
 6822:       container->mResult = mResult;
 6822:       container->FillStats();
 6822:     }
    1: 
  713:     nsCAutoString sortingAnnotation;
  713:     GetSortingAnnotation(sortingAnnotation);
12328:     PRBool itemExists;
12328:     PRUint32 position = FindInsertionPoint(aNode, comparator, 
12328:                                            sortingAnnotation.get(), 
12328:                                            &itemExists);
12328:     if (aIgnoreDuplicates && itemExists)
12328:       return NS_OK;
12328: 
12328:     return InsertChildAt(aNode, position, aIsTemporary);
    1:   }
    1:   return InsertChildAt(aNode, mChildren.Count(), aIsTemporary);
    1: }
    1: 
 9714: // nsNavHistoryContainerResultNode::EnsureItemPosition
 9714: //
 9714: //  This checks if the item at aIndex is located correctly given the sorting
 9714: //  move. If it's not, the item is moved, and the result view are notified.
 9714: //
 9714: //  Returns true if the item position has been changed, false otherwise.
 9714: 
 9714: PRBool
 9714: nsNavHistoryContainerResultNode::EnsureItemPosition(PRUint32 aIndex) {
27458:   NS_ASSERTION(aIndex >= 0 && aIndex < (PRUint32)mChildren.Count(), "Invalid index");
27458:   if (aIndex < 0 || aIndex >= (PRUint32)mChildren.Count())
 9714:     return PR_FALSE;
 9714: 
 9714:   SortComparator comparator = GetSortingComparator(GetSortType());
 9714:   if (!comparator)
 9714:     return PR_FALSE;
 9714: 
 9714:   nsCAutoString sortAnno;
 9714:   GetSortingAnnotation(sortAnno);
 9714:   if (!DoesChildNeedResorting(aIndex, comparator, sortAnno.get()))
 9714:     return PR_FALSE;
 9714: 
 9714:   nsRefPtr<nsNavHistoryResultNode> node(mChildren[aIndex]);
 9714:   mChildren.RemoveObjectAt(aIndex);
 9714: 
12328:   PRUint32 newIndex = FindInsertionPoint(
12328:                           node, comparator,sortAnno.get(), nsnull);
 9714:   mChildren.InsertObjectAt(node.get(), newIndex);
 9714: 
 9714:   nsNavHistoryResult* result = GetResult();
 9714:   NS_ENSURE_TRUE(result, PR_TRUE);
 9714: 
 9714:   if (result->GetView() && AreChildrenVisible())
33340:     result->GetView()->NodeMoved(node, this, aIndex, this, newIndex);
 9714: 
 9714:   return PR_TRUE;
 9714: }
    1: 
    1: // nsNavHistoryContainerResultNode::MergeResults
    1: //
12328: //    This takes a list of nodes and merges them into the current result set.
12328: //    Any containers that are added must already be sorted.
    1: //
    1: //    This assumes that the items in 'aAddition' are new visits or
    1: //    replacement URIs. We do not update visits.
    1: //
    1: //    PERFORMANCE: In the future, we can do more updates incrementally using
    1: //    this function. When a URI changes in a way we can't easily handle,
    1: //    construct a query with each query object specifying an exact match for
    1: //    the URI in question. Then remove all instances of that URI in the result
    1: //    and call this function.
    1: 
    1: void
    1: nsNavHistoryContainerResultNode::MergeResults(
    1:     nsCOMArray<nsNavHistoryResultNode>* aAddition)
    1: {
    1:   // Generally we will have very few (one) entries in the addition list, so
    1:   // just iterate through it. If we find we may have a lot, we may want to do
    1:   // some hashing to help with the merge.
    1:   for (PRUint32 i = 0; i < PRUint32(aAddition->Count()); i ++) {
    1:     nsNavHistoryResultNode* curAddition = (*aAddition)[i];
    1:     if (curAddition->IsContainer()) {
    1:       PRUint32 containerIndex;
    1:       nsNavHistoryContainerResultNode* container =
    1:         FindChildContainerByName(curAddition->mTitle, &containerIndex);
    1:       if (container) {
    1:         // recursively merge with the existing container
    1:         container->MergeResults(&curAddition->GetAsContainer()->mChildren);
    1:       } else {
    1:         // need to add the new container to our result.
    1:         InsertSortedChild(curAddition);
    1:       }
    1:     } else {
    1:       if (curAddition->IsVisit()) {
    1:         // insert the new visit
    1:         InsertSortedChild(curAddition);
    1:       } else {
    1:         // add the URI, replacing a current one if any
    1:         PRUint32 oldIndex;
    1:         nsNavHistoryResultNode* oldNode =
    1:           FindChildURI(curAddition->mURI, &oldIndex);
 4224:         if (oldNode) {
 4224:           // if we don't have a parent (for example, the history
 4224:           // sidebar, when sorted by last visited or most visited)
 4224:           // we have to manually Remove/Insert instead of Replace
 4224:           // see bug #389782 for details
 4224:           if (mParent)
    1:             ReplaceChildURIAt(oldIndex, curAddition);
 4224:           else {
 4224:             RemoveChildAt(oldIndex, PR_TRUE);
 4224:             InsertSortedChild(curAddition, PR_TRUE);
 4224:           }
 4224:         }
    1:         else
    1:           InsertSortedChild(curAddition);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::ReplaceChildURIAt
    1: //
    1: //    This is called to replace a leaf node. It will update tree stats
    1: //    and redraw the view if any. You can not use this to replace a container.
    1: //
    1: //    This assumes that the node is being replaced with a newer version of
    1: //    itself and so its visit count will not go down. Also, this means that the
    1: //    collapsing of duplicates will not change.
    1: 
    1: nsresult
    1: nsNavHistoryContainerResultNode::ReplaceChildURIAt(PRUint32 aIndex,
    1:     nsNavHistoryResultNode* aNode)
    1: {
    1:   NS_ASSERTION(aIndex < PRUint32(mChildren.Count()),
    1:                "Invalid index for replacement");
    1:   NS_ASSERTION(mChildren[aIndex]->IsURI(),
    1:                "Can not use ReplaceChildAt for a node of another type");
    1:   NS_ASSERTION(mChildren[aIndex]->mURI.Equals(aNode->mURI),
    1:                "We must replace a URI with an updated one of the same");
    1: 
    1:   aNode->mParent = this;
    1:   aNode->mIndentLevel = mIndentLevel + 1;
    1: 
    1:   // update tree stats if needed
    1:   PRUint32 accessCountChange = aNode->mAccessCount - mChildren[aIndex]->mAccessCount;
    1:   if (accessCountChange != 0 || mChildren[aIndex]->mTime != aNode->mTime) {
    1:     NS_ASSERTION(aNode->mAccessCount >= mChildren[aIndex]->mAccessCount,
    1:                  "Replacing a node with one back in time or some nonmatching node");
    1: 
    1:     mAccessCount += accessCountChange;
    1:     if (mTime < aNode->mTime)
    1:       mTime = aNode->mTime;
    1:     ReverseUpdateStats(accessCountChange);
    1:   }
    1: 
    1:   // Hold a reference so it doesn't go away as soon as we remove it from the
    1:   // array. This needs to be passed to the view.
 7025:   nsRefPtr<nsNavHistoryResultNode> oldItem = mChildren[aIndex];
    1: 
    1:   // actually replace
    1:   if (! mChildren.ReplaceObjectAt(aNode, aIndex))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // update view
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
 5933:   if (result->GetView() && AreChildrenVisible())
33340:     result->GetView()->NodeReplaced(this, oldItem, aNode, aIndex);
    1: 
    1:   mChildren[aIndex]->OnRemoving();
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::RemoveChildAt
    1: //
    1: //    This does all the work of removing a child from this container, including
    1: //    updating the tree if necessary. Note that we do not need to be open for
    1: //    this to work.
    1: //
    1: //    Some removes are "temporary" meaning that they'll just get inserted
    1: //    again. We do this for resorting. In these cases, we don't need to
    1: //    recompute any statistics, and we shouldn't notify those container that
    1: //    they are being removed.
    1: 
    1: nsresult
    1: nsNavHistoryContainerResultNode::RemoveChildAt(PRInt32 aIndex,
    1:                                                PRBool aIsTemporary)
    1: {
    1:   NS_ASSERTION(aIndex >= 0 && aIndex < mChildren.Count(), "Invalid index");
    1: 
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1: 
    1:   // hold an owning reference to keep from expiring while we work with it
 7025:   nsRefPtr<nsNavHistoryResultNode> oldNode = mChildren[aIndex];
    1: 
    1:   // stats
    1:   PRUint32 oldAccessCount = 0;
    1:   if (! aIsTemporary) {
    1:     oldAccessCount = mAccessCount;
    1:     mAccessCount -= mChildren[aIndex]->mAccessCount;
    1:     NS_ASSERTION(mAccessCount >= 0, "Invalid access count while updating!");
    1:   }
    1: 
    1:   // remove from our list and notify the tree
    1:   mChildren.RemoveObjectAt(aIndex);
 5933:   if (result->GetView() && AreChildrenVisible())
33340:     result->GetView()->NodeRemoved(this, oldNode, aIndex);
    1: 
    1:   if (! aIsTemporary) {
    1:     ReverseUpdateStats(mAccessCount - oldAccessCount);
    1:     oldNode->OnRemoving();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::RecursiveFindURIs
    1: //
    1: //    This function searches for matches for the given URI.
    1: //
    1: //    If aOnlyOne is set, it will terminate as soon as it finds a single match.
    1: //    This would be used when there are URI results so there will only ever be
    1: //    one copy of any URI.
    1: //
    1: //    When aOnlyOne is false, it will check all elements. This is for visit
    1: //    style results that may have multiple copies of any given URI.
    1: 
    1: void
    1: nsNavHistoryContainerResultNode::RecursiveFindURIs(PRBool aOnlyOne,
    1:     nsNavHistoryContainerResultNode* aContainer, const nsCString& aSpec,
    1:     nsCOMArray<nsNavHistoryResultNode>* aMatches)
    1: {
    1:   for (PRInt32 child = 0; child < aContainer->mChildren.Count(); child ++) {
    1:     PRUint32 type;
    1:     aContainer->mChildren[child]->GetType(&type);
    1:     if (nsNavHistoryResultNode::IsTypeURI(type)) {
    1:       // compare URIs
    1:       nsNavHistoryResultNode* uriNode = aContainer->mChildren[child];
    1:       if (uriNode->mURI.Equals(aSpec)) {
    1:         // found
    1:         aMatches->AppendObject(uriNode);
    1:         if (aOnlyOne)
    1:           return;
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::UpdateURIs
    1: //
    1: //    If aUpdateSort is true, we will also update the sorting of this item.
    1: //    Normally you want this to be true, but it can be false if the thing you
    1: //    are changing can not affect sorting (like favicons).
    1: //
    1: //    You should NOT change any child lists as part of the callback function.
    1: 
    1: void
    1: nsNavHistoryContainerResultNode::UpdateURIs(PRBool aRecursive, PRBool aOnlyOne,
    1:     PRBool aUpdateSort, const nsCString& aSpec,
33340:     void (*aCallback)(nsNavHistoryResultNode*,void*, nsNavHistoryResult*), void* aClosure)
    1: {
    1:   nsNavHistoryResult* result = GetResult();
    1:   if (! result) {
    1:     NS_NOTREACHED("Must have a result for this query");
    1:     return;
    1:   }
    1: 
    1:   // this needs to be owning since sometimes we remove and re-insert nodes
    1:   // in their parents and we don't want them to go away.
    1:   nsCOMArray<nsNavHistoryResultNode> matches;
    1: 
    1:   if (aRecursive) {
    1:     RecursiveFindURIs(aOnlyOne, this, aSpec, &matches);
    1:   } else if (aOnlyOne) {
    1:     PRUint32 nodeIndex;
    1:     nsNavHistoryResultNode* node = FindChildURI(aSpec, &nodeIndex);
    1:     if (node)
    1:       matches.AppendObject(node);
    1:   } else {
    1:     NS_NOTREACHED("UpdateURIs does not handle nonrecursive updates of multiple items.");
    1:     // this case easy to add if you need it, just find all the matching URIs
    1:     // at this level. However, this isn't currently used. History uses recursive,
    1:     // Bookmarks uses one level and knows that the match is unique.
    1:     return;
    1:   }
    1:   if (matches.Count() == 0)
    1:     return;
    1: 
    1:   // PERFORMANCE: This updates each container for each child in it that
    1:   // changes. In some cases, many elements have changed inside the same
    1:   // container. It would be better to compose a list of containers, and
    1:   // update each one only once for all the items that have changed in it.
    1:   for (PRInt32 i = 0; i < matches.Count(); i ++)
    1:   {
    1:     nsNavHistoryResultNode* node = matches[i];
    1:     nsNavHistoryContainerResultNode* parent = node->mParent;
    1:     if (! parent) {
    1:       NS_NOTREACHED("All URI nodes being updated must have parents");
    1:       continue;
    1:     }
 5933: 
    1:     PRUint32 oldAccessCount = node->mAccessCount;
    1:     PRTime oldTime = node->mTime;
33340:     aCallback(node, aClosure, result);
33340: 
33340:     PRBool childrenVisible = result->GetView() != nsnull && parent->AreChildrenVisible();
    1: 
    1:     if (oldAccessCount != node->mAccessCount || oldTime != node->mTime) {
    1:       // need to update/redraw the parent
    1:       parent->mAccessCount += node->mAccessCount - oldAccessCount;
    1:       if (node->mTime > parent->mTime)
    1:         parent->mTime = node->mTime;
 5933:       if (childrenVisible)
33340:         result->GetView()->NodeHistoryDetailsChanged(
33340:             static_cast<nsINavHistoryContainerResultNode*>(parent),
33340:             parent->mTime,
33340:             parent->mAccessCount);
    1:       parent->ReverseUpdateStats(node->mAccessCount - oldAccessCount);
    1:     }
    1: 
    1:     if (aUpdateSort) {
    1:       PRInt32 childIndex = parent->FindChild(node);
33340:       NS_ASSERTION(childIndex >= 0, "Could not find child we just got a reference to");
33340:       if (childIndex >= 0)
33340:         parent->EnsureItemPosition(childIndex);
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::ChangeTitles
    1: //
    1: //    This is used to update the titles in the tree. This is called from both
    1: //    query and bookmark folder containers to update the tree. Bookmark folders
    1: //    should be sure to set recursive to false, since child folders will have
    1: //    their own callbacks registered.
    1: 
20261: static void setTitleCallback(
33340:     nsNavHistoryResultNode* aNode, void* aClosure,
33340:     nsNavHistoryResult* aResult)
    1: {
 3233:   const nsACString* newTitle = reinterpret_cast<nsACString*>(aClosure);
    1:   aNode->mTitle = *newTitle;
33340: 
33340:   if (aResult && aResult->GetView() &&
33340:       (!aNode->mParent || aNode->mParent->AreChildrenVisible())) {
33340:     aResult->GetView()->NodeTitleChanged(aNode, *newTitle);
33340:   }
    1: }
    1: nsresult
    1: nsNavHistoryContainerResultNode::ChangeTitles(nsIURI* aURI,
    1:                                               const nsACString& aNewTitle,
    1:                                               PRBool aRecursive,
    1:                                               PRBool aOnlyOne)
    1: {
    1:   // uri string
    1:   nsCAutoString uriString;
    1:   nsresult rv = aURI->GetSpec(uriString);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // The recursive function will update the result's tree nodes, but only if we
    1:   // give it a non-null pointer. So if there isn't a tree, just pass NULL so
    1:   // it doesn't bother trying to call the result.
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1: 
  809:   PRUint16 sortType = GetSortType();
    1:   PRBool updateSorting =
    1:     (sortType == nsINavHistoryQueryOptions::SORT_BY_TITLE_ASCENDING ||
    1:      sortType == nsINavHistoryQueryOptions::SORT_BY_TITLE_DESCENDING);
    1: 
    1:   UpdateURIs(aRecursive, aOnlyOne, updateSorting, uriString,
    1:              setTitleCallback,
 3233:              const_cast<void*>(reinterpret_cast<const void*>(&aNewTitle)));
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::GetHasChildren
    1: //
    1: //    Complex containers (folders and queries) will override this. Here, we
    1: //    handle the case of simple containers (like host groups) where the children
    1: //    are always stored.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::GetHasChildren(PRBool *aHasChildren)
    1: {
    1:   *aHasChildren = (mChildren.Count() > 0);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::GetChildCount
    1: //
    1: //    This function is only valid when the node is opened.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::GetChildCount(PRUint32* aChildCount)
    1: {
    1:   if (! mExpanded)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   *aChildCount = mChildren.Count();
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::GetChild
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::GetChild(PRUint32 aIndex,
    1:                                           nsINavHistoryResultNode** _retval)
    1: {
    1:   if (! mExpanded)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   if (aIndex >= PRUint32(mChildren.Count()))
    1:     return NS_ERROR_INVALID_ARG;
    1:   NS_ADDREF(*_retval = mChildren[aIndex]);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::GetChildrenReadOnly
    1: //
    1: //    Overridden for folders to query the bookmarks service directly.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::GetChildrenReadOnly(PRBool *aChildrenReadOnly)
    1: {
    1:   *aChildrenReadOnly = mChildrenReadOnly;
    1:   return NS_OK;
    1: }
    1: 
    1: 
 4179: // nsNavHistoryContainerResultNode::GetDynamicContainerType
    1: 
    1: NS_IMETHODIMP
 4179: nsNavHistoryContainerResultNode::GetDynamicContainerType(
 4179:     nsACString& aDynamicContainerType)
    1: {
 4179:   aDynamicContainerType = mDynamicContainerType;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::AppendURINode
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::AppendURINode(
    1:     const nsACString& aURI, const nsACString& aTitle, PRUint32 aAccessCount,
    1:     PRTime aTime, const nsACString& aIconURI, nsINavHistoryResultNode** _retval)
    1: {
    1:   *_retval = nsnull;
 4179:   if (!IsDynamicContainer())
 4179:     return NS_ERROR_INVALID_ARG; // we must be a dynamic container
    1: 
20375:   // If we are child of an ExcludeItems parent or root, we should not append
20375:   // URI Nodes.
20375:   if ((mResult && mResult->mRootNode->mOptions->ExcludeItems()) ||
20375:       (mParent && mParent->mOptions->ExcludeItems()))
20375:     return NS_OK;
20375: 
    1:   nsRefPtr<nsNavHistoryResultNode> result =
    1:       new nsNavHistoryResultNode(aURI, aTitle, aAccessCount, aTime, aIconURI);
    1:   NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // append to our list
 4179:   nsresult rv = InsertChildAt(result, mChildren.Count());
 4179:   NS_ENSURE_SUCCESS(rv, rv);
 4179: 
    1:   NS_ADDREF(*_retval = result);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::AppendVisitNode
    1: 
    1: #if 0 // UNTESTED, commented out until it can be tested
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::AppendVisitNode(
    1:     const nsACString& aURI, const nsACString& aTitle, PRUint32 aAccessCount,
    1:     PRTime aTime, const nsACString& aIconURI, PRInt64 aSession,
    1:     nsINavHistoryVisitResultNode** _retval)
    1: {
    1:   *_retval = nsnull;
 4179:   if (!IsDynamicContainer())
 4179:     return NS_ERROR_INVALID_ARG; // we must be a dynamic container
    1: 
    1:   nsRefPtr<nsNavHistoryVisitResultNode> result =
    1:       new nsNavHistoryVisitResultNode(aURI, aTitle, aAccessCount, aTime,
    1:                                       aIconURI, aSession);
    1:   NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // append to our list
    1:   if (! mChildren.AppendObject(result))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF(*_retval = result);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::AppendFullVisitNode
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::AppendFullVisitNode(
    1:     const nsACString& aURI, const nsACString& aTitle, PRUint32 aAccessCount,
    1:     PRTime aTime, const nsACString& aIconURI, PRInt64 aSession,
    1:     PRInt64 aVisitId, PRInt64 aReferringVisitId, PRInt32 aTransitionType,
    1:     nsINavHistoryFullVisitResultNode** _retval)
    1: {
    1:   *_retval = nsnull;
 4179:   if (!IsDynamicContainer())
 4179:     return NS_ERROR_INVALID_ARG; // we must be a dynamic container
    1: 
    1:   nsRefPtr<nsNavHistoryFullVisitResultNode> result =
    1:       new nsNavHistoryFullVisitResultNode(aURI, aTitle, aAccessCount, aTime,
    1:                                           aIconURI, aSession, aVisitId,
    1:                                           aReferringVisitId, aTransitionType);
    1:   NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // append to our list
    1:   if (! mChildren.AppendObject(result))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF(*_retval = result);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::AppendContainerNode
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::AppendContainerNode(
    1:     const nsACString& aTitle, const nsACString& aIconURI,
 4179:     PRUint32 aContainerType, const nsACString& aDynamicContainerType,
    1:     nsINavHistoryContainerResultNode** _retval)
    1: {
    1:   *_retval = nsnull;
 4179:   if (!IsDynamicContainer())
 4179:     return NS_ERROR_INVALID_ARG; // we must be a dynamic container
    1:   if (! IsTypeContainer(aContainerType) || IsTypeFolder(aContainerType) ||
    1:       IsTypeQuery(aContainerType))
    1:     return NS_ERROR_INVALID_ARG; // not proper container type
 4179:   if (aContainerType == nsNavHistoryResultNode::RESULT_TYPE_DYNAMIC_CONTAINER &&
    1:       aRemoteContainerType.IsEmpty())
 4179:     return NS_ERROR_INVALID_ARG; // dynamic containers must have d.c. type
 4179:   if (aContainerType != nsNavHistoryResultNode::RESULT_TYPE_DYNAMIC_CONTAINER &&
 4179:       ! aDynamicContainerType.IsEmpty())
 4179:     return NS_ERROR_INVALID_ARG; // non-dynamic containers must NOT have d.c. type
    1: 
    1:   nsRefPtr<nsNavHistoryContainerResultNode> result =
    1:       new nsNavHistoryContainerResultNode(EmptyCString(), aTitle, aIconURI,
    1:                                           aContainerType, PR_TRUE,
 4179:                                           aDynamicContainerType);
    1:   NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // append to our list
    1:   if (! mChildren.AppendObject(result))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF(*_retval = result);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::AppendQueryNode
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::AppendQueryNode(
    1:     const nsACString& aQueryURI, const nsACString& aTitle,
    1:     const nsACString& aIconURI, nsINavHistoryQueryResultNode** _retval)
    1: {
    1:   *_retval = nsnull;
 4179:   if (!IsDynamicContainer())
 4179:     return NS_ERROR_INVALID_ARG; // we must be a dynamic container
    1: 
    1:   nsRefPtr<nsNavHistoryQueryResultNode> result =
    1:       new nsNavHistoryQueryResultNode(aQueryURI, aTitle, aIconURI);
    1:   NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // append to our list
    1:   if (! mChildren.AppendObject(result))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF(*_retval = result);
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: // nsNavHistoryContainerResultNode::AppendFolderNode
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::AppendFolderNode(
 4179:     PRInt64 aFolderId, nsINavHistoryContainerResultNode** _retval)
    1: {
    1:   *_retval = nsnull;
 4179:   if (!IsDynamicContainer())
 4179:     return NS_ERROR_INVALID_ARG; // we must be a dynamic container
    1: 
    1:   nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
    1:   NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // create the node, it will be addrefed for us
    1:   nsRefPtr<nsNavHistoryResultNode> result;
 4179:   nsresult rv = bookmarks->ResultNodeForContainer(aFolderId,
    1:                                                   GetGeneratingOptions(),
    1:                                                   getter_AddRefs(result));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // append to our list
 4179:   rv = InsertChildAt(result, mChildren.Count());
 4179:   NS_ENSURE_SUCCESS(rv, rv);
 4179: 
 4179:   NS_ADDREF(*_retval = result->GetAsContainer());
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode::ClearContents
    1: //
 4179: //    Used by the dynamic container API to clear this container
    1: 
    1: #if 0 // UNTESTED, commented out until it can be tested
    1: NS_IMETHODIMP
    1: nsNavHistoryContainerResultNode::ClearContents()
    1: {
 4179:   if (!IsDynamicContainer())
 4179:     return NS_ERROR_INVALID_ARG; // we must be a dynamic container
    1: 
    1:   // we know if CanRemoteContainersChange() then we are a regular container
    1:   // and not a query or folder, so clearing doesn't need anything else to
    1:   // happen (like unregistering observers). Also, since this should only
    1:   // happen when the container is closed, we don't need to redraw the screen.
    1:   mChildren.Clear();
    1: 
    1:   PRUint32 oldAccessCount = mAccessCount;
    1:   mAccessCount = 0;
    1:   mTime = 0;
    1:   ReverseUpdateStats(-PRInt32(oldAccessCount));
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: // nsNavHistoryQueryResultNode *************************************************
    1: //
    1: //    HOW QUERY UPDATING WORKS
    1: //
    1: //    Queries are different than bookmark folders in that we can not always
    1: //    do dynamic updates (easily) and updates are more expensive. Therefore,
    1: //    we do NOT query if we are not open and want to see if we have any children
    1: //    (for drawing a twisty) and always assume we will.
    1: //
    1: //    When the container is opened, we execute the query and register the
    1: //    listeners. Like bookmark folders, we stay registered even when closed,
    1: //    and clear ourselves as soon as a message comes in. This lets us respond
    1: //    quickly if the user closes and reopens the container.
    1: //
    1: //    We try to handle the most common notifications for the most common query
    1: //    types dynamically, that is, figuring out what should happen in response
    1: //    to a message without doing a requery. For complex changes or complex
    1: //    queries, we give up and requery.
    1: 
 1740: NS_IMPL_ISUPPORTS_INHERITED1(nsNavHistoryQueryResultNode,
 1740:                              nsNavHistoryContainerResultNode,
 1740:                              nsINavHistoryQueryResultNode)
    1: 
    1: nsNavHistoryQueryResultNode::nsNavHistoryQueryResultNode(
    1:     const nsACString& aTitle, const nsACString& aIconURI,
    1:     const nsACString& aQueryURI) :
    1:   nsNavHistoryContainerResultNode(aQueryURI, aTitle, aIconURI,
    1:                                   nsNavHistoryResultNode::RESULT_TYPE_QUERY,
 4179:                                   PR_TRUE, EmptyCString(), nsnull),
    1:   mHasSearchTerms(PR_FALSE),
    1:   mContentsValid(PR_FALSE),
    1:   mBatchInProgress(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsNavHistoryQueryResultNode::nsNavHistoryQueryResultNode(
    1:     const nsACString& aTitle, const nsACString& aIconURI,
    1:     const nsCOMArray<nsNavHistoryQuery>& aQueries,
    1:     nsNavHistoryQueryOptions* aOptions) :
    1:   nsNavHistoryContainerResultNode(EmptyCString(), aTitle, aIconURI,
    1:                                   nsNavHistoryResultNode::RESULT_TYPE_QUERY,
 4179:                                   PR_TRUE, EmptyCString(), aOptions),
    1:   mQueries(aQueries),
    1:   mContentsValid(PR_FALSE),
    1:   mBatchInProgress(PR_FALSE)
    1: {
    1:   NS_ASSERTION(aQueries.Count() > 0, "Must have at least one query");
    1: 
    1:   nsNavHistory* history = nsNavHistory::GetHistoryService();
    1:   NS_ASSERTION(history, "History service missing");
    1:   mLiveUpdate = history->GetUpdateRequirements(mQueries, mOptions,
    1:                                                &mHasSearchTerms);
    1: }
    1: 
12328: nsNavHistoryQueryResultNode::nsNavHistoryQueryResultNode(
12328:     const nsACString& aTitle, const nsACString& aIconURI,
12328:     PRTime aTime,
12328:     const nsCOMArray<nsNavHistoryQuery>& aQueries,
12328:     nsNavHistoryQueryOptions* aOptions) :
12328:   nsNavHistoryContainerResultNode(EmptyCString(), aTitle, aTime, aIconURI,
12328:                                   nsNavHistoryResultNode::RESULT_TYPE_QUERY,
12328:                                   PR_TRUE, EmptyCString(), aOptions),
12328:   mQueries(aQueries),
12328:   mContentsValid(PR_FALSE),
12328:   mBatchInProgress(PR_FALSE)
12328: {
12328:   NS_ASSERTION(aQueries.Count() > 0, "Must have at least one query");
12328: 
12328:   nsNavHistory* history = nsNavHistory::GetHistoryService();
12328:   NS_ASSERTION(history, "History service missing");
12328:   mLiveUpdate = history->GetUpdateRequirements(mQueries, mOptions,
12328:                                                &mHasSearchTerms);
12328: }
12328: 
27458: nsNavHistoryQueryResultNode::~nsNavHistoryQueryResultNode() {
27458:   // Remove this node from result's observers.  We don't need to be notified
27458:   // anymore.
27458:   if (mResult && mResult->mAllBookmarksObservers.IndexOf(this) !=
27458:                    mResult->mAllBookmarksObservers.NoIndex)
27458:     mResult->RemoveAllBookmarksObserver(this);
27458:   if (mResult && mResult->mHistoryObservers.IndexOf(this) !=
27458:                    mResult->mHistoryObservers.NoIndex)
27458:     mResult->RemoveHistoryObserver(this);
27458: }
    1: 
    1: // nsNavHistoryQueryResultNode::CanExpand
    1: //
    1: //    Whoever made us may want non-expanding queries. However, we always
    1: //    expand when we are the root node, or else asking for non-expanding
 5542: //    queries would be useless. A query node is not expandable if excludeItems=1
 5542: //    or expandQueries=0.
    1: 
    1: PRBool
    1: nsNavHistoryQueryResultNode::CanExpand()
    1: {
14224:   if (IsContainersQuery())
14224:     return PR_TRUE;
14224: 
29521:   // If we are child of an ExcludeItems parent or root, we should not expand.
29521:   if ((mResult && mResult->mRootNode->mOptions->ExcludeItems()) ||
29521:       (mParent && mParent->mOptions->ExcludeItems()))
14224:     return PR_FALSE;
14224: 
    1:   nsNavHistoryQueryOptions* options = GetGeneratingOptions();
 5542:   if (options) {
 5542:     if (options->ExcludeItems())
 5542:       return PR_FALSE;
 5542:     if (options->ExpandQueries())
    1:       return PR_TRUE;
 5542:   }
    1:   if (mResult && mResult->mRootNode == this)
    1:     return PR_TRUE;
    1:   return PR_FALSE;
    1: }
    1: 
14224: // nsNavHistoryQueryResultNode::IsContainersQuery
14224: //
14224: // Some query with a particular result type can contain other queries,
14224: // they must be always expandable
14224: 
14224: PRBool
14224: nsNavHistoryQueryResultNode::IsContainersQuery()
14224: {
15159:   PRUint16 resultType = Options()->ResultType();
14224:   return resultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_QUERY ||
14224:          resultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_SITE_QUERY ||
14224:          resultType == nsINavHistoryQueryOptions::RESULTS_AS_TAG_QUERY ||
14224:          resultType == nsINavHistoryQueryOptions::RESULTS_AS_SITE_QUERY;
14224: }
    1: 
    1: // nsNavHistoryQueryResultNode::OnRemoving
    1: //
    1: //    Here we do not want to call ContainerResultNode::OnRemoving since our own
    1: //    ClearChildren will do the same thing and more (unregister the observers).
    1: //    The base ResultNode::OnRemoving will clear some regular node stats, so it
    1: //    is OK.
    1: 
    1: void
    1: nsNavHistoryQueryResultNode::OnRemoving()
    1: {
    1:   nsNavHistoryResultNode::OnRemoving();
    1:   ClearChildren(PR_TRUE);
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::OpenContainer
    1: //
    1: //    Marks the container as open, rebuilding results if they are invalid. We
    1: //    may still have valid results if the container was previously open and
    1: //    nothing happened since closing it.
    1: //
    1: //    We do not handle CloseContainer specially. The default one just marks the
    1: //    container as closed, but doesn't actually mark the results as invalid.
    1: //    The results will be invalidated by the next history or bookmark
    1: //    notification that comes in. This means if you open and close the item
    1: //    without anything happening in between, it will be fast (this actually
    1: //    happens when results are used as menus).
    1: 
    1: nsresult
    1: nsNavHistoryQueryResultNode::OpenContainer()
    1: {
 5542:   NS_ASSERTION(!mExpanded, "Container must be closed to open it");
    1:   mExpanded = PR_TRUE;
    1:   if (!CanExpand())
    1:     return NS_OK;
    1:   if (!mContentsValid) {
    1:     nsresult rv = FillChildren();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1:   if (result->GetView())
    1:     result->GetView()->ContainerOpened(
 3233:         static_cast<nsNavHistoryContainerResultNode*>(this));
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::GetHasChildren
    1: //
    1: //    When we have valid results we can always give an exact answer. When we
    1: //    don't we just assume we'll have results, since actually doing the query
    1: //    might be hard. This is used to draw twisties on the tree, so precise
    1: //    results don't matter.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::GetHasChildren(PRBool* aHasChildren)
    1: {
    1:   if (!CanExpand()) {
    1:     *aHasChildren = PR_FALSE;
    1:     return NS_OK;
    1:   }
14224: 
14224:   PRUint16 resultType = mOptions->ResultType();
14224:   // For tag containers query we must check if we have any tag
14224:   if (resultType == nsINavHistoryQueryOptions::RESULTS_AS_TAG_QUERY) {
14224:     nsNavHistory* history = nsNavHistory::GetHistoryService();
14224:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
14224:     mozIStorageConnection *dbConn = history->GetStorageConnection();
14224: 
14224:     nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
14224:     NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
14224:     PRInt64 tagsFolderId;
14224:     nsresult rv = bookmarks->GetTagsFolder(&tagsFolderId);
14224:     NS_ENSURE_SUCCESS(rv, rv);
14224: 
14224:     nsCOMPtr<mozIStorageStatement> hasTagsStatement;
14224:     rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
14224:         "SELECT id FROM moz_bookmarks WHERE parent = ?1 LIMIT 1"),
14224:       getter_AddRefs(hasTagsStatement));
14224:     NS_ENSURE_SUCCESS(rv, rv);
14224:     rv = hasTagsStatement->BindInt64Parameter(0, tagsFolderId);
14224:     NS_ENSURE_SUCCESS(rv, rv);
14224: 
21642:     rv = hasTagsStatement->ExecuteStep(aHasChildren);
21642:     NS_ENSURE_SUCCESS(rv, rv);
21642: 
21642:     return NS_OK;
14224:   }
14224: 
14224:   // For history containers query we must check if we have any history
14224:   if (resultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_QUERY ||
14224:       resultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_SITE_QUERY ||
14224:       resultType == nsINavHistoryQueryOptions::RESULTS_AS_SITE_QUERY) {
14224:     nsNavHistory* history = nsNavHistory::GetHistoryService();
14224:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
14224:     return history->GetHasHistoryEntries(aHasChildren);
14224:   }
14224: 
14224:   //XXX: For other containers queries we must:
14224:   // 1. If it's open, just check mChildren for containers
14224:   // 2. Else null the view (keep it in a var), open container, check mChildren
14224:   //    for containers, close container, reset the view
14224: 
    1:   if (mContentsValid) {
    1:     *aHasChildren = (mChildren.Count() > 0);
    1:     return NS_OK;
    1:   }
    1:   *aHasChildren = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::GetUri
    1: //
    1: //    This doesn't just return mURI because in the case of queries that may
    1: //    be lazily constructed from the query objects.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::GetUri(nsACString& aURI)
    1: {
    1:   nsresult rv = VerifyQueriesSerialized();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   aURI = mURI;
    1:   return NS_OK;
    1: }
    1: 
10675: // nsNavHistoryQueryResultNode::GetFolderItemId
10675: 
10675: NS_IMETHODIMP
10675: nsNavHistoryQueryResultNode::GetFolderItemId(PRInt64* aItemId)
10675: {
10675:   *aItemId = mItemId;
10675:   return NS_OK;
10675: }
    1: 
    1: // nsNavHistoryQueryResultNode::GetQueries
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::GetQueries(PRUint32* queryCount,
    1:                                         nsINavHistoryQuery*** queries)
    1: {
    1:   nsresult rv = VerifyQueriesParsed();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ASSERTION(mQueries.Count() > 0, "Must have >= 1 query");
    1: 
 3233:   *queries = static_cast<nsINavHistoryQuery**>
 3233:                         (nsMemory::Alloc(mQueries.Count() * sizeof(nsINavHistoryQuery*)));
    1:   NS_ENSURE_TRUE(*queries, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   for (PRInt32 i = 0; i < mQueries.Count(); ++i)
    1:     NS_ADDREF((*queries)[i] = mQueries[i]);
    1:   *queryCount = mQueries.Count();
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::GetQueryOptions
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::GetQueryOptions(
    1:                                       nsINavHistoryQueryOptions** aQueryOptions)
    1: {
15159:   *aQueryOptions = Options();
    1:   NS_ADDREF(*aQueryOptions);
    1:   return NS_OK;
    1: }
    1: 
15159: // nsNavHistoryQueryResultNode::Options
15159: //
15159: //  Safe options getter, ensures queries are parsed first.
15159: 
15159: nsNavHistoryQueryOptions*
15159: nsNavHistoryQueryResultNode::Options()
15159: {
15159:   nsresult rv = VerifyQueriesParsed();
15159:   if (NS_FAILED(rv))
15159:     return nsnull;
15159:   NS_ASSERTION(mOptions, "Options invalid, cannot generate from URI");
15159:   return mOptions;
15159: }
    1: 
    1: // nsNavHistoryQueryResultNode::VerifyQueriesParsed
    1: 
    1: nsresult
    1: nsNavHistoryQueryResultNode::VerifyQueriesParsed()
    1: {
    1:   if (mQueries.Count() > 0) {
    1:     NS_ASSERTION(mOptions, "If a result has queries, it also needs options");
    1:     return NS_OK;
    1:   }
    1:   NS_ASSERTION(! mURI.IsEmpty(),
    1:                "Query nodes must have either a URI or query/options");
    1: 
    1:   nsNavHistory* history = nsNavHistory::GetHistoryService();
    1:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsresult rv = history->QueryStringToQueryArray(mURI, &mQueries,
    1:                                                  getter_AddRefs(mOptions));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mLiveUpdate = history->GetUpdateRequirements(mQueries, mOptions,
    1:                                                &mHasSearchTerms);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::VerifyQueriesSerialized
    1: 
    1: nsresult
    1: nsNavHistoryQueryResultNode::VerifyQueriesSerialized()
    1: {
    1:   if (! mURI.IsEmpty()) {
    1:     return NS_OK;
    1:   }
    1:   NS_ASSERTION(mQueries.Count() > 0 && mOptions,
    1:                "Query nodes must have either a URI or query/options");
    1: 
    1:   nsTArray<nsINavHistoryQuery*> flatQueries;
    1:   flatQueries.SetCapacity(mQueries.Count());
    1:   for (PRInt32 i = 0; i < mQueries.Count(); i ++)
 3233:     flatQueries.AppendElement(static_cast<nsINavHistoryQuery*>
 3233:                                          (mQueries.ObjectAt(i)));
    1: 
    1:   nsNavHistory* history = nsNavHistory::GetHistoryService();
    1:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsresult rv = history->QueriesToQueryString(flatQueries.Elements(),
    1:                                               flatQueries.Length(),
    1:                                               mOptions, mURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(! mURI.IsEmpty(), NS_ERROR_FAILURE);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::FillChildren
    1: 
    1: nsresult
    1: nsNavHistoryQueryResultNode::FillChildren()
    1: {
    1:   NS_ASSERTION(! mContentsValid,
    1:                "Don't call FillChildren when contents are valid");
    1:   NS_ASSERTION(mChildren.Count() == 0,
    1:                "We are trying to fill children when there already are some");
    1: 
    1:   nsNavHistory* history = nsNavHistory::GetHistoryService();
    1:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // get the results from the history service
    1:   nsresult rv = VerifyQueriesParsed();
    1:   NS_ENSURE_SUCCESS(rv, rv);
 2597:   rv = history->GetQueryResults(this, mQueries, mOptions, &mChildren);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // it is important to call FillStats to fill in the parents on all
    1:   // nodes and the result node pointers on the containers
    1:   FillStats();
    1: 
12328:   PRUint16 sortType = GetSortType();
12328: 
29235:   if (mResult->mNeedsToApplySortingMode) {
29235:     // We should repopulate container and then apply sortingMode.  To avoid
29235:     // sorting 2 times we simply do that here.
29235:     mResult->SetSortingMode(mResult->mSortingMode);
29235:   }
29235:   else if (mOptions->QueryType() != nsINavHistoryQueryOptions::QUERY_TYPE_HISTORY ||
29235:            sortType != nsINavHistoryQueryOptions::SORT_BY_NONE) {
12328:     // The default SORT_BY_NONE sorts by the bookmark index (position), 
29235:     // which we do not have for history queries.
29235:     // Once we've computed all tree stats, we can sort, because containers will
29235:     // then have proper visit counts and dates.
    1:     SortComparator comparator = GetSortingComparator(GetSortType());
11421:     if (comparator) {
  713:       nsCAutoString sortingAnnotation;
  713:       GetSortingAnnotation(sortingAnnotation);
27616:       // Usually containers queries results comes already sorted from the
27616:       // database, but some locales could have special rules to sort by title.
27616:       // RecursiveSort won't apply these rules to containers in containers
27616:       // queries because when setting sortingMode on the result we want to sort
27616:       // contained items (bug 473157).
27616:       // Base container RecursiveSort will sort both our children and all
27616:       // descendants, and is used in this case because we have to do manual
27616:       // title sorting.
27616:       // Query RecursiveSort will instead only sort descendants if we are a
27616:       // constinaersQuery, e.g. a grouped query that will return other queries.
27616:       // For other type of queries it will act as the base one.
27616:       if (IsContainersQuery() &&
27616:           sortType == mOptions->SortingMode() &&
27616:           (sortType == nsINavHistoryQueryOptions::SORT_BY_TITLE_ASCENDING ||
27616:            sortType == nsINavHistoryQueryOptions::SORT_BY_TITLE_DESCENDING))
27616:         nsNavHistoryContainerResultNode::RecursiveSort(sortingAnnotation.get(), comparator);
27616:       else
  713:         RecursiveSort(sortingAnnotation.get(), comparator);
11421:     }
12328:   }
12328: 
12328:   // if we are limiting our results remove items from the end of the
12328:   // mChildren array after sorting. This is done for root node only.
 6822:   // note, if count < max results, we won't do anything.
12328:   if (!mParent && mOptions->MaxResults()) {
27458:     while ((PRUint32)mChildren.Count() > mOptions->MaxResults())
 6822:       mChildren.RemoveObjectAt(mChildren.Count() - 1);
 6822:   }
 6822: 
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
 2579: 
 2579:   if (mOptions->QueryType() == nsINavHistoryQueryOptions::QUERY_TYPE_HISTORY ||
 2579:       mOptions->QueryType() == nsINavHistoryQueryOptions::QUERY_TYPE_UNIFIED) {
26880:     // Date containers that contain site containers have no reason to observe
26880:     // history, if the inside site container is expanded it will update,
26880:     // otherwise we are going to refresh the parent query.
26880:     if (!mParent || mParent->mOptions->ResultType() != nsINavHistoryQueryOptions::RESULTS_AS_DATE_SITE_QUERY) {
 2579:       // register with the result for history updates
 2579:       result->AddHistoryObserver(this);
 2579:     }
26880:   }
 2579: 
 2579:   if (mOptions->QueryType() == nsINavHistoryQueryOptions::QUERY_TYPE_BOOKMARKS ||
 9553:       mOptions->QueryType() == nsINavHistoryQueryOptions::QUERY_TYPE_UNIFIED ||
 9553:       mLiveUpdate == QUERYUPDATE_COMPLEX_WITH_BOOKMARKS) {
 2579:     // register with the result for bookmark updates
 2579:     result->AddAllBookmarksObserver(this);
 2579:   }
    1: 
    1:   mContentsValid = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::ClearChildren
    1: //
    1: //    Call with unregister = false when we are going to update the children (for
 2579: //    example, when the container is open). This will clear the list and notify
    1: //    all the children that they are going away.
    1: //
    1: //    When the results are becoming invalid and we are not going to refresh
    1: //    them, set unregister = true, which will unregister the listener from the
    1: //    result if any. We use unregister = false when we are refreshing the list
    1: //    immediately so want to stay a notifier.
    1: 
    1: void
    1: nsNavHistoryQueryResultNode::ClearChildren(PRBool aUnregister)
    1: {
    1:   for (PRInt32 i = 0; i < mChildren.Count(); i ++)
    1:     mChildren[i]->OnRemoving();
    1:   mChildren.Clear();
    1: 
    1:   if (aUnregister && mContentsValid) {
    1:     nsNavHistoryResult* result = GetResult();
 2579:     if (result) {
 2579:       result->RemoveHistoryObserver(this);
 2579:       result->RemoveAllBookmarksObserver(this);
 2579:     }
    1:   }
    1:   mContentsValid = PR_FALSE;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::Refresh
    1: //
    1: //    This is called to update the result when something has changed that we
    1: //    can not incrementally update.
    1: 
    1: nsresult
    1: nsNavHistoryQueryResultNode::Refresh()
    1: {
    1:   // Ignore refreshes when there is a batch, EndUpdateBatch will do a refresh
    1:   // to get all the changes.
    1:   if (mBatchInProgress)
    1:     return NS_OK;
    1: 
11550:   // This is not a root node but it does not have a parent - this means that 
11550:   // the node has already been cleared and it is now called, because it was 
11550:   // left in a local copy of the observers array.
11550:   if (mIndentLevel > -1 && !mParent)
11550:     return NS_OK;
11550: 
20368:   // Do not refresh if we are not expanded or if we are child of a query
20368:   // containing other queries. In this case calling Refresh for each child
20368:   // query could cause a major slowdown. We should not refresh nested
20368:   // queries, since we will already refresh the parent one.
20368:   if (!mExpanded ||
20368:       (mParent && mParent->IsQuery() &&
20368:        mParent->GetAsQuery()->IsContainersQuery())) {
20368:     // Don't update, just invalidate and unhook
    1:     ClearChildren(PR_TRUE);
    1:     return NS_OK; // no updates in tree state
    1:   }
    1: 
 2579:   if (mLiveUpdate == QUERYUPDATE_COMPLEX_WITH_BOOKMARKS)
 2579:     ClearChildren(PR_TRUE);
 2579:   else
 2579:     ClearChildren(PR_FALSE);
 2579: 
    1:   // ignore errors from FillChildren, since we will still want to refresh
    1:   // the tree (there just might not be anything in it on error)
 2579:   (void)FillChildren();
    1: 
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1:   if (result->GetView())
    1:     return result->GetView()->InvalidateContainer(
 3233:         static_cast<nsNavHistoryContainerResultNode*>(this));
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::GetSortType
    1: //
    1: //    Here, we override GetSortType to return the current sorting for this
    1: //    query. GetSortType is used when dynamically inserting query results so we
    1: //    can see which comparator we should use to find the proper insertion point
    1: //    (it shouldn't be called from folder containers which maintain their own
    1: //    sorting).
    1: //
    1: //    Normally, the container just forwards it up the chain. This is what
    1: //    we want for host groups, for example. For queries, we often want to
    1: //    use the query's sorting mode.
    1: //
    1: //    However, we only use this query node's sorting when it is not the root.
    1: //    When it is the root, we use the result's sorting mode, which is set
    1: //    according to the column headers in the tree view (if attached). This is
    1: //    because there are two cases:
    1: //
    1: //    - You are looking at a bookmark hierarchy that contains an embedded
    1: //      result. We should always use the query's sort ordering since the result
    1: //      node's headers have nothing to do with us (and are disabled).
    1: //
    1: //    - You are looking at a query in the tree. In this case, we want the
    1: //      result sorting to override ours (it should be initialized to the same
    1: //      sorting mode).
    1: //
    1: //    It might seem like the column headers should set the sorting mode for the
    1: //    query in the result so we don't have to have this special case. But, the
    1: //    UI allows you to save the query in a different place or edit it, and just
    1: //    grabs the parameters and options from the query node. It would be weird
    1: //    to build a query, click a column header, and have the options you built
    1: //    up in the query builder be changed from under you.
    1: 
  809: PRUint16
    1: nsNavHistoryQueryResultNode::GetSortType()
    1: {
    1:   if (mParent) {
    1:     // use our sorting, we are not the root
    1:     return mOptions->SortingMode();
  713:   }
  713:   if (mResult) {
    1:     return mResult->mSortingMode;
    1:   }
    1: 
    1:   NS_NOTREACHED("We should always have a result");
    1:   return nsINavHistoryQueryOptions::SORT_BY_NONE;
    1: }
    1: 
  713: void
  713: nsNavHistoryQueryResultNode::GetSortingAnnotation(nsACString& aAnnotation) {
  713:   if (mParent) {
  713:     // use our sorting, we are not the root
  713:     mOptions->GetSortingAnnotation(aAnnotation);
  713:   }
  713:   else if (mResult) {
  713:     aAnnotation.Assign(mResult->mSortingAnnotation);
  713:   }
  713:   else
  713:     NS_NOTREACHED("We should always have a result");
  713: }
23690: 
23690: void
23690: nsNavHistoryQueryResultNode::RecursiveSort(
23690:     const char* aData, SortComparator aComparator)
23690: {
23690:   void* data = const_cast<void*>(static_cast<const void*>(aData));
23690: 
23690:   if (!IsContainersQuery())
23690:     mChildren.Sort(aComparator, data);
27616: 
27616:   for (PRInt32 i = 0; i < mChildren.Count(); i++) {
27616:     if (mChildren[i]->IsContainer())
23690:       mChildren[i]->GetAsContainer()->RecursiveSort(aData, aComparator);
23690:   }
27616: }
23690: 
23690: 
    1: // nsNavHistoryResultNode::OnBeginUpdateBatch
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::OnBeginUpdateBatch()
    1: {
    1:   mBatchInProgress = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryResultNode::OnEndUpdateBatch
    1: //
    1: //    Always requery when batches are done. These will typically involve large
    1: //    operations (currently delete) and it is likely more efficient to requery
    1: //    than to incrementally update as each message comes in.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::OnEndUpdateBatch()
    1: {
    1:   NS_ASSERTION(mBatchInProgress, "EndUpdateBatch without a begin");
    1:   // must set to false before calling Refresh or Refresh will ignore us
    1:   mBatchInProgress = PR_FALSE;
    1:   return Refresh();
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::OnVisit
    1: //
    1: //    Here we need to update all copies of the URI we have with the new visit
    1: //    count, and potentially add a new entry in our query. This is the most
    1: //    common update operation and it is important that it be as efficient as
    1: //    possible.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::OnVisit(nsIURI* aURI, PRInt64 aVisitId,
    1:                                      PRTime aTime, PRInt64 aSessionId,
    1:                                      PRInt64 aReferringId,
12328:                                      PRUint32 aTransitionType,
12328:                                      PRUint32* aAdded)
    1: {
    1:   // ignore everything during batches
    1:   if (mBatchInProgress)
    1:     return NS_OK;
    1: 
    1:   nsNavHistory* history = nsNavHistory::GetHistoryService();
    1:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsresult rv;
 7025:   nsRefPtr<nsNavHistoryResultNode> addition;
    1:   switch(mLiveUpdate) {
12328: 
12328:     case QUERYUPDATE_HOST: {
12328:       // For these simple yet common cases we can check the host ourselves
12328:       // before doing the overhead of creating a new result node.
12328:       NS_ASSERTION(mQueries.Count() == 1, 
12328:           "Host updated queries can have only one object");
12328:       nsCOMPtr<nsNavHistoryQuery> queryHost = 
12328:           do_QueryInterface(mQueries[0], &rv);
12328:       NS_ENSURE_SUCCESS(rv, rv);
12328: 
12328:       PRBool hasDomain;
12328:       queryHost->GetHasDomain(&hasDomain);
12984:       if (!hasDomain)
12328:         return NS_OK;
12328: 
12328:       nsCAutoString host;
12328:       if (NS_FAILED(aURI->GetAsciiHost(host)))
12328:         return NS_OK;
12328: 
12328:       if (!queryHost->Domain().Equals(host))
12328:         return NS_OK;
12328: 
12328:     } // Let it fall through - we want to check the time too,
12328:       // if the time is not present it will match too.
    1:     case QUERYUPDATE_TIME: {
    1:       // For these simple yet common cases we can check the time ourselves
    1:       // before doing the overhead of creating a new result node.
12328:       NS_ASSERTION(mQueries.Count() == 1, 
12328:           "Time updated queries can have only one object");
12328:       nsCOMPtr<nsNavHistoryQuery> query = 
12328:           do_QueryInterface(mQueries[0], &rv);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       PRBool hasIt;
    1:       query->GetHasBeginTime(&hasIt);
    1:       if (hasIt) {
    1:         PRTime beginTime = history->NormalizeTime(query->BeginTimeReference(),
    1:                                                   query->BeginTime());
    1:         if (aTime < beginTime)
    1:           return NS_OK; // before our time range
    1:       }
    1:       query->GetHasEndTime(&hasIt);
    1:       if (hasIt) {
    1:         PRTime endTime = history->NormalizeTime(query->EndTimeReference(),
    1:                                                 query->EndTime());
    1:         if (aTime > endTime)
    1:           return NS_OK; // after our time range
    1:       }
    1:       // now we know that our visit satisfies the time range, create a new node
    1:       rv = history->VisitIdToResultNode(aVisitId, mOptions,
    1:                                         getter_AddRefs(addition));
12328: 
12328:       // We do not want to add this result to this node
26880:       if (NS_FAILED(rv) || !addition)
12328:           return NS_OK;
12328: 
    1:       break;
    1:     }
    1:     case QUERYUPDATE_SIMPLE: {
    1:       // The history service can tell us whether the new item should appear
    1:       // in the result. We first have to construct a node for it to check.
    1:       rv = history->VisitIdToResultNode(aVisitId, mOptions,
    1:                                         getter_AddRefs(addition));
26880:       if (NS_FAILED(rv) || !addition ||
26880:           !history->EvaluateQueryForNode(mQueries, mOptions, addition))
    1:         return NS_OK; // don't need to include in our query
    1:       break;
    1:     }
    1:     case QUERYUPDATE_COMPLEX:
    1:     case QUERYUPDATE_COMPLEX_WITH_BOOKMARKS:
    1:       // need to requery in complex cases
    1:       return Refresh();
    1:     default:
    1:       NS_NOTREACHED("Invalid value for mLiveUpdate");
    1:       return Refresh();
    1:   }
    1: 
    1:   // NOTE: The dynamic updating never deletes any nodes. Sometimes it replaces
    1:   // URI nodes or adds visits, but never deletes old ones.
    1:   //
    1:   // The only time this might happen in the current implementation is if the
    1:   // title changes and it no longer matches a keyword search. This is not
    1:   // important enough to handle given that we don't do any other deleting. It
    1:   // is arguably more useful behavior anyway, since you're searching your
    1:   // history and the page used to match.
    1:   //
    1:   // When more queries are possible (show pages I've visited less than 5 times)
    1:   // this will be important to add.
    1: 
12328:   nsCOMArray<nsNavHistoryResultNode> mergerNode;
12328: 
12328:   if (!mergerNode.AppendObject(addition))
    1:     return NS_ERROR_OUT_OF_MEMORY;
12328: 
12328:   MergeResults(&mergerNode);
12328: 
12328:   if (aAdded)
12328:     (*aAdded)++;
12328: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::OnTitleChanged
    1: //
    1: //    Find every node that matches this URI and rename it. We try to do
    1: //    incremental updates here, even when we are closed, because changing titles
    1: //    is easier than requerying if we are invalid.
    1: //
    1: //    This actually gets called a lot. Typically, we will get an AddURI message
    1: //    when the user visits the page, and then the title will be set asynchronously
    1: //    when the title element of the page is parsed.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::OnTitleChanged(nsIURI* aURI,
 4037:                                             const nsAString& aPageTitle)
    1: {
    1:   if (mBatchInProgress)
    1:     return NS_OK; // ignore everything during batches
    1:   if (! mExpanded) {
    1:     // When we are not expanded, we don't update, just invalidate and unhook.
    1:     // It would still be pretty easy to traverse the results and update the
    1:     // titles, but when a title changes, its unlikely that it will be the only
    1:     // thing. Therefore, we just give up.
    1:     ClearChildren(PR_TRUE);
    1:     return NS_OK; // no updates in tree state
    1:   }
    1: 
    1:   // See if our queries have any keyword matching. In this case, we can't just
    1:   // replace the title on the items, but must redo the query. This could be
    1:   // handled more efficiently, but it is hard because keyword matching might
    1:   // match anything, including the title and other things.
    1:   if (mHasSearchTerms) {
    1:     return Refresh();
    1:   }
    1: 
    1:   // compute what the new title should be
24715:   NS_ConvertUTF16toUTF8 newTitle(aPageTitle);
    1: 
    1:   PRBool onlyOneEntry = (mOptions->ResultType() ==
14224:                          nsINavHistoryQueryOptions::RESULTS_AS_URI ||
14224:                          mOptions->ResultType() ==
14224:                          nsINavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS
14224:                          );
    1:   return ChangeTitles(aURI, newTitle, PR_TRUE, onlyOneEntry);
    1: }
    1: 
    1: 
27196: NS_IMETHODIMP
27196: nsNavHistoryQueryResultNode::OnBeforeDeleteURI(nsIURI *aURI)
27196: {
27196:   return NS_OK;
27196: }
27196: 
    1: // nsNavHistoryQueryResultNode::OnDeleteURI
    1: //
    1: //    Here, we can always live update by just deleting all occurrences of
    1: //    the given URI.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::OnDeleteURI(nsIURI *aURI)
    1: {
    1:   PRBool onlyOneEntry = (mOptions->ResultType() ==
14224:                          nsINavHistoryQueryOptions::RESULTS_AS_URI ||
14224:                          mOptions->ResultType() ==
14224:                          nsINavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS);
    1:   nsCAutoString spec;
    1:   nsresult rv = aURI->GetSpec(spec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMArray<nsNavHistoryResultNode> matches;
    1:   RecursiveFindURIs(onlyOneEntry, this, spec, &matches);
    1:   if (matches.Count() == 0)
    1:     return NS_OK; // not found
    1: 
    1:   for (PRInt32 i = 0; i < matches.Count(); i ++) {
    1:     nsNavHistoryResultNode* node = matches[i];
    1:     nsNavHistoryContainerResultNode* parent = node->mParent;
 4224:     // URI nodes should always have parents
 4224:     NS_ENSURE_TRUE(parent, NS_ERROR_UNEXPECTED);
    1:     
    1:     PRInt32 childIndex = parent->FindChild(node);
    1:     NS_ASSERTION(childIndex >= 0, "Child not found in parent");
    1:     parent->RemoveChildAt(childIndex);
    1: 
12328:     if (parent->mChildren.Count() == 0 && parent->IsQuery()) {
    1:       // when query subcontainers (like hosts) get empty we should remove them
    1:       // as well. Just append this to our list and it will get evaluated later
    1:       // in the loop.
    1:       matches.AppendObject(parent);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::OnClearHistory
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::OnClearHistory()
    1: {
27458:   (void)Refresh();
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::OnPageChanged
    1: //
    1: 
20261: static void setFaviconCallback(
33340:    nsNavHistoryResultNode* aNode, void* aClosure,
33340:    nsNavHistoryResult* aResult)
    1: {
 3233:   const nsCString* newFavicon = static_cast<nsCString*>(aClosure);
    1:   aNode->mFaviconURI = *newFavicon;
33340: 
33340:   if (aResult && aResult->GetView() &&
33340:       (!aNode->mParent || aNode->mParent->AreChildrenVisible())) {
33340:     aResult->GetView()->NodeIconChanged(aNode);
33340:   }
    1: }
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::OnPageChanged(nsIURI *aURI, PRUint32 aWhat,
    1:                          const nsAString &aValue)
    1: {
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1: 
    1:   nsCAutoString spec;
    1:   nsresult rv = aURI->GetSpec(spec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   switch (aWhat) {
    1:     case nsINavHistoryObserver::ATTRIBUTE_FAVICON: {
24715:       NS_ConvertUTF16toUTF8 newFavicon(aValue);
    1:       PRBool onlyOneEntry = (mOptions->ResultType() ==
14224:                              nsINavHistoryQueryOptions::RESULTS_AS_URI ||
14224:                              mOptions->ResultType() ==
14224:                              nsINavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS);
    1:       UpdateURIs(PR_TRUE, onlyOneEntry, PR_FALSE, spec, setFaviconCallback,
    1:                  &newFavicon);
    1:       break;
    1:     }
    1:     default:
    1:       NS_WARNING("Unknown page changed notification");
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryQueryResultNode::OnPageExpired
    1: //
    1: //    Do nothing. Perhaps we want to handle this case. If so, add the call to
    1: //    the result to enumerate the history observers.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryQueryResultNode::OnPageExpired(nsIURI* aURI, PRTime aVisitTime,
    1:                                            PRBool aWholeEntry)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistoryQueryResultNode bookmark observers
    1: //
    1: //    These are the bookmark observer functions for query nodes. They listen
    1: //    for bookmark events and refresh the results if we have any dependence on
    1: //    the bookmark system.
    1: 
    1: NS_IMETHODIMP
28943: nsNavHistoryQueryResultNode::OnItemAdded(PRInt64 aItemId,
28943:                                          PRInt64 aFolder,
28943:                                          PRInt32 aIndex,
28943:                                          PRUint16 aItemType)
    1: {
33340:   if (aItemType == nsINavBookmarksService::TYPE_BOOKMARK &&
33340:       mLiveUpdate == QUERYUPDATE_COMPLEX_WITH_BOOKMARKS)
    1:     return Refresh();
    1:   return NS_OK;
    1: }
33340: 
    1: NS_IMETHODIMP
33340: nsNavHistoryQueryResultNode::OnBeforeItemRemoved(PRInt64 aItemId,
33340:                                                  PRUint16 aItemType)
26383: {
26383:   return NS_OK;
26383: }
33340: 
26383: NS_IMETHODIMP
 1337: nsNavHistoryQueryResultNode::OnItemRemoved(PRInt64 aItemId, PRInt64 aFolder,
33340:                                            PRInt32 aIndex, PRUint16 aItemType)
    1: {
    1:   if (mLiveUpdate == QUERYUPDATE_COMPLEX_WITH_BOOKMARKS)
    1:     return Refresh();
    1:   return NS_OK;
    1: }
33340: 
    1: NS_IMETHODIMP
 1337: nsNavHistoryQueryResultNode::OnItemChanged(PRInt64 aItemId,
    1:                                            const nsACString& aProperty,
 1337:                                            PRBool aIsAnnotationProperty,
33340:                                            const nsACString& aNewValue,
33340:                                            PRTime aLastModified,
33340:                                            PRUint16 aItemType)
    1: {
15658:   // History observers should not get OnItemChanged
15658:   // but should get the corresponding history notifications instead.
15658:   // For bookmark queries, "all bookmark" observers should get OnItemChanged.
15658:   // For example, when a title of a bookmark changes, we want that to refresh.
33340: 
33340:   if (mLiveUpdate == QUERYUPDATE_COMPLEX_WITH_BOOKMARKS) {
34244:     switch (aItemType) {
34244:       case nsINavBookmarksService::TYPE_SEPARATOR:
34244:         // No separators in queries.
33340:         return NS_OK;
34244:       case nsINavBookmarksService::TYPE_FOLDER:
34244:         // Queries never result as "folders", but the tags-query results as
34244:         // special "tag" containers, which should follow their corresponding
34244:         // folders titles.
34244:         if (mOptions->ResultType() != nsINavHistoryQueryOptions::RESULTS_AS_TAG_QUERY)
34244:           return NS_OK;
34244:       default:
15658:         (void)Refresh();
33340:     }
34244:   }
33340:   else {
 5542:     NS_WARNING("history observers should not get OnItemChanged, but should get the corresponding history notifications instead");
33340:   }
15658: 
15658:   return nsNavHistoryResultNode::OnItemChanged(aItemId, aProperty,
15658:                                                aIsAnnotationProperty,
33340:                                                aNewValue,
33340:                                                aLastModified,
33340:                                                aItemType);
    1: }
 1604: 
    1: NS_IMETHODIMP
 1337: nsNavHistoryQueryResultNode::OnItemVisited(PRInt64 aItemId,
    1:                                            PRInt64 aVisitId, PRTime aTime)
    1: {
 2579:   // for bookmark queries, "all bookmark" observer should get OnItemVisited
 2579:   // but it is ignored.
 2579:   if (mLiveUpdate != QUERYUPDATE_COMPLEX_WITH_BOOKMARKS)
14700:     NS_WARNING("history observers should not get OnItemVisited, but should get OnVisit instead");
    1:   return NS_OK;
    1: }
14224: 
    1: NS_IMETHODIMP
33340: nsNavHistoryQueryResultNode::OnItemMoved(PRInt64 aFolder,
33340:                                          PRInt64 aOldParent, PRInt32 aOldIndex,
33340:                                          PRInt64 aNewParent, PRInt32 aNewIndex,
33340:                                          PRUint16 aItemType)
    1: {
33340:   // 1. The query cannot be affected by the item's position
33340:   // 2. For the time being, we cannot optimize this not to update
33340:   //    queries which are not restricted to some folders, due to way
33340:   //    sub-queries are updated (see Refresh)
33340:   if (mLiveUpdate == QUERYUPDATE_COMPLEX_WITH_BOOKMARKS &&
33340:       aItemType != nsINavBookmarksService::TYPE_SEPARATOR &&
33340:       aOldParent != aNewParent) {
    1:     return Refresh();
33340:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistoryFolderResultNode ************************************************
    1: //
    1: //    HOW DYNAMIC FOLDER UPDATING WORKS
    1: //
    1: //    When you create a result, it will automatically keep itself in sync with
    1: //    stuff that happens in the system. For folder nodes, this means changes
    1: //    to bookmarks.
    1: //
    1: //    A folder will fill its children "when necessary." This means it is being
    1: //    opened or whether we need to see if it is empty for twisty drawing. It
    1: //    will then register its ID with the main result object that owns it. This
    1: //    result object will listen for all bookmark notifications and pass those
    1: //    notifications to folder nodes that have registered for that specific
    1: //    folder ID.
    1: //
    1: //    When a bookmark folder is closed, it will not clear its children. Instead,
    1: //    it will keep them and also stay registered as a listener. This means that
    1: //    you can more quickly re-open the same folder without doing any work. This
    1: //    happens a lot for menus, and bookmarks don't change very often.
    1: //
    1: //    When a message comes in and the folder is open, we will do the correct
    1: //    operations to keep ourselves in sync with the bookmark service. If the
    1: //    folder is closed, we just clear our list to mark it as invalid and
    1: //    unregister as a listener. This means we do not have to keep maintaining
    1: //    an up-to-date list for the entire bookmark menu structure in every place
    1: //    it is used.
    1: //
    1: //    There is an additional wrinkle. If the result is attached to a treeview,
    1: //    and we invalidate but the folder itself is visible (its parent is open),
    1: //    we will immediately get asked if we are full. The folder will then query
    1: //    its children. Thus, the whole benefit of incremental updating is lost.
    1: //    Therefore, if we are in a treeview AND our parent is visible, we will
    1: //    keep incremental updating.
    1: 
 1431: NS_IMPL_ISUPPORTS_INHERITED1(nsNavHistoryFolderResultNode,
    1:                              nsNavHistoryContainerResultNode,
 1431:                              nsINavHistoryQueryResultNode)
    1: 
    1: nsNavHistoryFolderResultNode::nsNavHistoryFolderResultNode(
    1:     const nsACString& aTitle, nsNavHistoryQueryOptions* aOptions,
 4179:     PRInt64 aFolderId, const nsACString& aDynamicContainerType) :
    1:   nsNavHistoryContainerResultNode(EmptyCString(), aTitle, EmptyCString(),
    1:                                   nsNavHistoryResultNode::RESULT_TYPE_FOLDER,
 4179:                                   PR_FALSE, aDynamicContainerType, aOptions),
10046:   mContentsValid(PR_FALSE),
13683:   mQueryItemId(-1),
13683:   mIsRegisteredFolderObserver(PR_FALSE)
    1: {
 1337:   mItemId = aFolderId;
    1: }
    1: 
13683: nsNavHistoryFolderResultNode::~nsNavHistoryFolderResultNode()
13683: {
13683:   if (mIsRegisteredFolderObserver && mResult)
13683:     mResult->RemoveBookmarkFolderObserver(this, mItemId);
13683: }
    1: 
    1: // nsNavHistoryFolderResultNode::OnRemoving
    1: //
    1: //    Here we do not want to call ContainerResultNode::OnRemoving since our own
    1: //    ClearChildren will do the same thing and more (unregister the observers).
    1: //    The base ResultNode::OnRemoving will clear some regular node stats, so it
    1: //    is OK.
    1: 
    1: void
    1: nsNavHistoryFolderResultNode::OnRemoving()
    1: {
    1:   nsNavHistoryResultNode::OnRemoving();
    1:   ClearChildren(PR_TRUE);
    1: }
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode::OpenContainer
    1: //
    1: //    See nsNavHistoryQueryResultNode::OpenContainer
    1: 
    1: nsresult
    1: nsNavHistoryFolderResultNode::OpenContainer()
    1: {
    1:   NS_ASSERTION(! mExpanded, "Container must be expanded to close it");
    1:   nsresult rv;
    1: 
    1:   if (! mContentsValid) {
    1:     rv = FillChildren();
    1:     NS_ENSURE_SUCCESS(rv, rv);
 4179:     if (IsDynamicContainer()) {
 4179:       // dynamic container API may want to change the bookmarks for this folder.
 4179:       nsCOMPtr<nsIDynamicContainer> svc = do_GetService(mDynamicContainerType.get(), &rv);
 4179:       if (NS_SUCCEEDED(rv)) {
 4179:         svc->OnContainerNodeOpening(
 4179:             static_cast<nsNavHistoryContainerResultNode*>(this), mOptions);
 4179:       } else {
 4179:         NS_WARNING("Unable to get dynamic container for ");
 4179:         NS_WARNING(mDynamicContainerType.get());
 4179:       }
 4179:     }
    1:   }
    1:   mExpanded = PR_TRUE;
 4179: 
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1:   if (result->GetView())
    1:     result->GetView()->ContainerOpened(
 3233:         static_cast<nsNavHistoryContainerResultNode*>(this));
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode::GetHasChildren
    1: //
    1: //    See nsNavHistoryQueryResultNode::HasChildren.
    1: //
    1: //    The semantics here are a little different. Querying the contents of a
    1: //    bookmark folder is relatively fast and it is common to have empty folders.
    1: //    Therefore, we always want to return the correct result so that twisties
    1: //    are drawn properly.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryFolderResultNode::GetHasChildren(PRBool* aHasChildren)
    1: {
    1:   if (! mContentsValid) {
    1:     nsresult rv = FillChildren();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   *aHasChildren = (mChildren.Count() > 0);
    1:   return NS_OK;
    1: }
    1: 
10046: // nsNavHistoryFolderResultNode::GetItemId
10046: //
10046: // Returns the id of the item from which the folder node was generated, it
10046: // could be either a concrete folder-itemId or the id used in
10046: // a simple-folder-query-bookmark (place:folder=X)
10046: 
10046: NS_IMETHODIMP
10046: nsNavHistoryFolderResultNode::GetItemId(PRInt64* aItemId)
10046: {
10046:   *aItemId = mQueryItemId == -1 ? mItemId : mQueryItemId;
10046:   return NS_OK;
10046: }
    1: 
    1: // nsNavHistoryFolderResultNode::GetChildrenReadOnly
    1: //
    1: //    Here, we override the getter and ignore the value stored in our object.
    1: //    The bookmarks service can tell us whether this folder should be read-only
    1: //    or not.
    1: //
    1: //    It would be nice to put this code in the folder constructor, but the
    1: //    database was complaining. I believe it is because most folders are
    1: //    created while enumerating the bookmarks table and having a statement
    1: //    open, and doing another statement might make it unhappy in some cases.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryFolderResultNode::GetChildrenReadOnly(PRBool *aChildrenReadOnly)
    1: {
    1:   nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
    1:   NS_ENSURE_TRUE(bookmarks, NS_ERROR_UNEXPECTED);
 1337:   return bookmarks->GetFolderReadonly(mItemId, aChildrenReadOnly);
    1: }
    1: 
    1: 
10675: // nsNavHistoryFolderResultNode::GetFolderItemId
10675: 
10675: NS_IMETHODIMP
10675: nsNavHistoryFolderResultNode::GetFolderItemId(PRInt64* aItemId)
10675: {
10675:   *aItemId = mItemId;
10675:   return NS_OK;
10675: }
10675: 
    1: // nsNavHistoryFolderResultNode::GetUri
    1: //
    1: //    This lazily computes the URI for this specific folder query with
    1: //    the current options.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryFolderResultNode::GetUri(nsACString& aURI)
    1: {
    1:   if (! mURI.IsEmpty()) {
    1:     aURI = mURI;
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRUint32 queryCount;
    1:   nsINavHistoryQuery** queries;
    1:   nsresult rv = GetQueries(&queryCount, &queries);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsNavHistory* history = nsNavHistory::GetHistoryService();
    1:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
 6403: 
    1:   rv = history->QueriesToQueryString(queries, queryCount, mOptions, aURI);
 6403:   for (PRUint32 queryIndex = 0; queryIndex < queryCount;  queryIndex ++) {
 6403:     NS_RELEASE(queries[queryIndex]);
 6403:   }
    1:   nsMemory::Free(queries);
    1:   return rv;
    1: }
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode::GetQueries
    1: //
    1: //    This just returns the queries that give you this bookmarks folder
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryFolderResultNode::GetQueries(PRUint32* queryCount,
    1:                                          nsINavHistoryQuery*** queries)
    1: {
    1:   // get the query object
    1:   nsCOMPtr<nsINavHistoryQuery> query;
    1:   nsNavHistory* history = nsNavHistory::GetHistoryService();
    1:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
    1:   nsresult rv = history->GetNewQuery(getter_AddRefs(query));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // query just has the folder ID set and nothing else
 1337:   rv = query->SetFolders(&mItemId, 1);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // make array of our 1 query
 3233:   *queries = static_cast<nsINavHistoryQuery**>
 3233:                         (nsMemory::Alloc(sizeof(nsINavHistoryQuery*)));
    1:   if (! *queries)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF((*queries)[0] = query);
    1:   *queryCount = 1;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode::GetQueryOptions
    1: //
    1: //    Options for the query that gives you this bookmarks folder. This is just
    1: //    the options for the folder with the current folder ID set.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryFolderResultNode::GetQueryOptions(
    1:                                       nsINavHistoryQueryOptions** aQueryOptions)
    1: {
    1:   NS_ASSERTION(mOptions, "Options invalid");
    1: 
    1:   *aQueryOptions = mOptions;
    1:   NS_ADDREF(*aQueryOptions);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode::FillChildren
    1: //
    1: //    Call to fill the actual children of this folder.
    1: 
    1: nsresult
    1: nsNavHistoryFolderResultNode::FillChildren()
    1: {
    1:   NS_ASSERTION(! mContentsValid,
    1:                "Don't call FillChildren when contents are valid");
    1:   NS_ASSERTION(mChildren.Count() == 0,
    1:                "We are trying to fill children when there already are some");
    1: 
    1:   nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
    1:   NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // actually get the folder children from the bookmark service
 1337:   nsresult rv = bookmarks->QueryFolderChildren(mItemId, mOptions, &mChildren);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // PERFORMANCE: it may be better to also fill any child folders at this point
    1:   // so that we can draw tree twisties without doing a separate query later. If
    1:   // we don't end up drawing twisties a lot, it doesn't matter. If we do this,
    1:   // we should wrap everything in a transaction here on the bookmark service's
    1:   // connection.
    1: 
    1:   // it is important to call FillStats to fill in the parents on all
    1:   // nodes and the result node pointers on the containers
    1:   FillStats();
    1: 
29235:   if (mResult->mNeedsToApplySortingMode) {
29235:     // We should repopulate container and then apply sortingMode.  To avoid
29235:     // sorting 2 times we simply do that here.
29235:     mResult->SetSortingMode(mResult->mSortingMode);
29235:   }
29235:   else {
  861:     // once we've computed all tree stats, we can sort, because containers will
  862:     // then have proper visit counts and dates
  861:     SortComparator comparator = GetSortingComparator(GetSortType());
11421:     if (comparator) {
  861:       nsCAutoString sortingAnnotation;
  861:       GetSortingAnnotation(sortingAnnotation);
  861:       RecursiveSort(sortingAnnotation.get(), comparator);
11421:     }
29235:   }
  861: 
12328:   // if we are limiting our results remove items from the end of the
12328:   // mChildren array after sorting. This is done for root node only.
12328:   // note, if count < max results, we won't do anything.
12328:   if (!mParent && mOptions->MaxResults()) {
27458:     while ((PRUint32)mChildren.Count() > mOptions->MaxResults())
12328:       mChildren.RemoveObjectAt(mChildren.Count() - 1);
12328:   }
12328: 
    1:   // register with the result for updates
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
 2579:   result->AddBookmarkFolderObserver(this, mItemId);
13683:   mIsRegisteredFolderObserver = PR_TRUE;
    1: 
    1:   mContentsValid = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode::ClearChildren
    1: //
    1: //    See nsNavHistoryQueryResultNode::FillChildren
    1: 
    1: void
    1: nsNavHistoryFolderResultNode::ClearChildren(PRBool unregister)
    1: {
    1:   for (PRInt32 i = 0; i < mChildren.Count(); i ++)
    1:     mChildren[i]->OnRemoving();
    1:   mChildren.Clear();
    1: 
    1:   if (unregister && mContentsValid) {
13683:     if (mResult) {
13683:       mResult->RemoveBookmarkFolderObserver(this, mItemId);
13683:       mIsRegisteredFolderObserver = PR_FALSE;
13683:     }
    1:   }
    1:   mContentsValid = PR_FALSE;
    1: }
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode::Refresh
    1: //
    1: //    This is called to update the result when something has changed that we
    1: //    can not incrementally update.
    1: 
    1: nsresult
    1: nsNavHistoryFolderResultNode::Refresh()
    1: {
 2579:   ClearChildren(PR_TRUE);
 2579: 
    1:   if (! mExpanded) {
    1:     // when we are not expanded, we don't update, just invalidate and unhook
    1:     return NS_OK; // no updates in tree state
    1:   }
    1: 
    1:   // ignore errors from FillChildren, since we will still want to refresh
27458:   // the tree (there just might not be anything in it on error). ClearChildren
27458:   // has unregistered us as an observer since FillChildren will try to
27458:   // re-register us.
 2579:   (void)FillChildren();
    1: 
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1:   if (result->GetView())
    1:     return result->GetView()->InvalidateContainer(
 3233:         static_cast<nsNavHistoryContainerResultNode*>(this));
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode::StartIncrementalUpdate
    1: //
    1: //    This implements the logic described above the constructor. This sees if
    1: //    we should do an incremental update and returns true if so. If not, it
    1: //    invalidates our children, unregisters us an observer, and returns false.
    1: 
    1: PRBool
    1: nsNavHistoryFolderResultNode::StartIncrementalUpdate()
    1: {
    1:   // if any items are excluded, we can not do incremental updates since the
    1:   // indices from the bookmark service will not be valid
 6822:   nsCAutoString parentAnnotationToExclude;
 6822:   nsresult rv = mOptions->GetExcludeItemIfParentHasAnnotation(parentAnnotationToExclude);
 6822:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
 6822: 
 6822:   if (! mOptions->ExcludeItems() && 
 6822:       ! mOptions->ExcludeQueries() && 
 6822:       ! mOptions->ExcludeReadOnlyFolders() && 
 6822:       parentAnnotationToExclude.IsEmpty()) {
    1: 
    1:     // easy case: we are visible, always do incremental update
    1:     if (mExpanded || AreChildrenVisible())
    1:       return PR_TRUE;
    1: 
    1:     nsNavHistoryResult* result = GetResult();
    1:     NS_ENSURE_TRUE(result, PR_FALSE);
    1: 
    1:     // when a tree is attached also do incremental updates if our parent is
    1:     // visible so that twisties are drawn correctly.
    1:     if (mParent && result->GetView())
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   // otherwise, we don't do incremental updates, invalidate and unregister
27458:   (void)Refresh();
    1:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode::ReindexRange
    1: //
    1: //    This function adds aDelta to all bookmark indices between the two
    1: //    endpoints, inclusive. It is used when items are added or removed from
    1: //    the bookmark folder.
    1: 
    1: void
    1: nsNavHistoryFolderResultNode::ReindexRange(PRInt32 aStartIndex,
    1:                                            PRInt32 aEndIndex,
    1:                                            PRInt32 aDelta)
    1: {
    1:   for (PRInt32 i = 0; i < mChildren.Count(); i ++) {
    1:     nsNavHistoryResultNode* node = mChildren[i];
    1:     if (node->mBookmarkIndex >= aStartIndex &&
    1:         node->mBookmarkIndex <= aEndIndex)
    1:       node->mBookmarkIndex += aDelta;
    1:   }
    1: }
    1: 
    1: 
 1347: // nsNavHistoryFolderResultNode::FindChildById
    1: //
14492: //    Searches this folder for a node with the given id. Returns null if not
    1: //    found. Does not addref the node!
    1: 
    1: nsNavHistoryResultNode*
 1347: nsNavHistoryFolderResultNode::FindChildById(PRInt64 aItemId,
    1:     PRUint32* aNodeIndex)
    1: {
    1:   for (PRInt32 i = 0; i < mChildren.Count(); i ++) {
14492:     if (mChildren[i]->mItemId == aItemId ||
14492:         (mChildren[i]->IsFolder() &&
14492:          mChildren[i]->GetAsFolder()->mQueryItemId == aItemId)) {
    1:       *aNodeIndex = i;
    1:       return mChildren[i];
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode::OnBeginUpdateBatch (nsINavBookmarkObserver)
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryFolderResultNode::OnBeginUpdateBatch()
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode::OnEndUpdateBatch (nsINavBookmarkObserver)
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryFolderResultNode::OnEndUpdateBatch()
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistoryFolderResultNode::OnItemAdded (nsINavBookmarkObserver)
    1: 
    1: NS_IMETHODIMP
 1337: nsNavHistoryFolderResultNode::OnItemAdded(PRInt64 aItemId,
 1347:                                           PRInt64 aParentFolder,
28943:                                           PRInt32 aIndex,
28943:                                           PRUint16 aItemType)
    1: {
 1347:   NS_ASSERTION(aParentFolder == mItemId, "Got wrong bookmark update");
    1: 
29521:   PRBool excludeItems = (mResult && mResult->mRootNode->mOptions->ExcludeItems()) ||
29521:                         (mParent && mParent->mOptions->ExcludeItems()) ||
29521:                         mOptions->ExcludeItems();
29521: 
    1:   // here, try to do something reasonable if the bookmark service gives us
    1:   // a bogus index.
    1:   if (aIndex < 0) {
    1:     NS_NOTREACHED("Invalid index for item adding: <0");
    1:     aIndex = 0;
28943:   }
28943:   else if (aIndex > mChildren.Count()) {
29521:     if (!excludeItems) {
29521:       // Something wrong happened while updating indexes.
    1:       NS_NOTREACHED("Invalid index for item adding: greater than count");
29521:     }
    1:     aIndex = mChildren.Count();
    1:   }
 1347: 
 1347:   nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
 1347:   NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
 1347: 
28943:   nsresult rv;
 1347: 
 5542:   // check for query URIs, which are bookmarks, but treated as containers
 5542:   // in results and views.
 5542:   PRBool isQuery = PR_FALSE;
28943:   if (aItemType == nsINavBookmarksService::TYPE_BOOKMARK) {
 5542:     nsCOMPtr<nsIURI> itemURI;
 5542:     rv = bookmarks->GetBookmarkURI(aItemId, getter_AddRefs(itemURI));
 5542:     NS_ENSURE_SUCCESS(rv, rv);
 5542:     nsCAutoString itemURISpec;
 5542:     rv = itemURI->GetSpec(itemURISpec);
 5542:     NS_ENSURE_SUCCESS(rv, rv);
 5542:     isQuery = IsQueryURI(itemURISpec);
 5542:   }
 5542: 
28943:   if (aItemType != nsINavBookmarksService::TYPE_FOLDER &&
29521:       !isQuery && excludeItems) {
 1347:     // don't update items when we aren't displaying them, but we still need
 1347:     // to adjust bookmark indices to account for the insertion
 1347:     ReindexRange(aIndex, PR_INT32_MAX, 1);
 1347:     return NS_OK; 
 1347:   }
 1347: 
    1:   if (!StartIncrementalUpdate())
    1:     return NS_OK; // folder was completely refreshed for us
    1: 
 1347:   // adjust indices to account for insertion
    1:   ReindexRange(aIndex, PR_INT32_MAX, 1);
    1: 
 7132:   nsRefPtr<nsNavHistoryResultNode> node;
28943:   if (aItemType == nsINavBookmarksService::TYPE_BOOKMARK) {
    1:     nsNavHistory* history = nsNavHistory::GetHistoryService();
    1:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
 7132:     rv = history->BookmarkIdToResultNode(aItemId, mOptions, getter_AddRefs(node));
 8308:     NS_ENSURE_SUCCESS(rv, rv);
27458:     // Correctly set batch status for new query nodes.
27458:     if (mResult && node->IsQuery())
27458:       node->GetAsQuery()->mBatchInProgress = mResult->mBatchInProgress;
 1347:   }
28943:   else if (aItemType == nsINavBookmarksService::TYPE_FOLDER ||
28943:            aItemType == nsINavBookmarksService::TYPE_DYNAMIC_CONTAINER) {
 7132:     rv = bookmarks->ResultNodeForContainer(aItemId, mOptions, getter_AddRefs(node));
 1347:     NS_ENSURE_SUCCESS(rv, rv);
 1347:   }
28943:   else if (aItemType == nsINavBookmarksService::TYPE_SEPARATOR) {
 1347:     node = new nsNavHistorySeparatorResultNode();
 1347:     NS_ENSURE_TRUE(node, NS_ERROR_OUT_OF_MEMORY);
 1347:     node->mItemId = aItemId;
 1347:   }
    1:   node->mBookmarkIndex = aIndex;
 1347: 
28943:   if (aItemType == nsINavBookmarksService::TYPE_SEPARATOR ||
 1347:       GetSortType() == nsINavHistoryQueryOptions::SORT_BY_NONE) {
    1:     // insert at natural bookmarks position
    1:     return InsertChildAt(node, aIndex);
    1:   }
    1:   // insert at sorted position
    1:   return InsertSortedChild(node, PR_FALSE);
    1: }
    1: 
    1: 
26383: // nsNavHistoryFolderResultNode::OnBeforeItemRemoved (nsINavBookmarkObserver)
26383: 
26383: NS_IMETHODIMP
33340: nsNavHistoryFolderResultNode::OnBeforeItemRemoved(PRInt64 aItemId,
33340:                                                   PRUint16 aItemType)
26383: {
26383:   return NS_OK;
26383: }
26383: 
26383: 
    1: // nsNavHistoryFolderResultNode::OnItemRemoved (nsINavBookmarkObserver)
    1: 
    1: NS_IMETHODIMP
 1337: nsNavHistoryFolderResultNode::OnItemRemoved(PRInt64 aItemId,
28943:                                             PRInt64 aParentFolder,
33340:                                             PRInt32 aIndex,
33340:                                             PRUint16 aItemType)
    1: {
 1347:   // We only care about notifications when a child changes. When the deleted
 1347:   // item is us, our parent should also be registered and will remove us from
 1347:   // its list.
 1347:   if (mItemId == aItemId)
 1347:     return NS_OK;
 1347: 
28943:   NS_ASSERTION(aParentFolder == mItemId, "Got wrong bookmark update");
28943: 
28943:   PRBool excludeItems = (mResult && mResult->mRootNode->mOptions->ExcludeItems()) ||
28943:                         (mParent && mParent->mOptions->ExcludeItems()) ||
28943:                         mOptions->ExcludeItems();
28943: 
 1347:   // don't trust the index from the bookmark service, find it ourselves. The
 1347:   // sorting could be different, or the bookmark services indices and ours might
 1347:   // be out of sync somehow.
 1347:   PRUint32 index;
 1347:   nsNavHistoryResultNode* node = FindChildById(aItemId, &index);
 1347:   if (!node) {
28943:     if (excludeItems)
28943:       return NS_OK;
28943: 
 1347:     NS_NOTREACHED("Removing item we don't have");
 1347:     return NS_ERROR_FAILURE;
 1347:   }
 1347: 
28943:   if ((node->IsURI() || node->IsSeparator()) && excludeItems) {
 6986:     // don't update items when we aren't displaying them, but we do need to
 6986:     // adjust everybody's bookmark indices to account for the removal
 6986:     ReindexRange(aIndex, PR_INT32_MAX, -1);
 6986:     return NS_OK;
 6986:   }
 6986: 
    1:   if (!StartIncrementalUpdate())
 1347:     return NS_OK; // we are completely refreshed
    1: 
    1:   // shift all following indices down
    1:   ReindexRange(aIndex + 1, PR_INT32_MAX, -1);
    1: 
 1347:   return RemoveChildAt(index);
    1: }
    1: 
    1: 
 2551: // nsNavHistoryResultNode::OnItemChanged
 2551: 
 2551: NS_IMETHODIMP
 2551: nsNavHistoryResultNode::OnItemChanged(PRInt64 aItemId,
 2551:                                       const nsACString& aProperty,
 2551:                                       PRBool aIsAnnotationProperty,
33340:                                       const nsACString& aNewValue,
33340:                                       PRTime aLastModified,
33340:                                       PRUint16 aItemType)
 2551: {
18894:   if (aItemId != mItemId)
18894:     return NS_OK;
18894: 
33340:   mLastModified = aLastModified;
33340: 
33340:   nsNavHistoryResult* result = GetResult();
33340:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
33340: 
33340:   PRBool shouldUpdateView =
33340:     result->GetView() && (!mParent || mParent->AreChildrenVisible());
33340: 
33340:   if (aIsAnnotationProperty) {
33340:     if (shouldUpdateView)
33340:       result->GetView()->NodeAnnotationChanged(this, aProperty);
33340:   }
33340:   else if (aProperty.EqualsLiteral("title")) {
33314:     // XXX: what should we do if the new title is void?
33340:     mTitle = aNewValue;
33340:     if (shouldUpdateView)
33340:       result->GetView()->NodeTitleChanged(this, mTitle);
33314:   }
33314:   else if (aProperty.EqualsLiteral("uri")) {
33314:     // clear the tags string as well
33314:     mTags.SetIsVoid(PR_TRUE);
33340:     mURI = aNewValue;
33340:     if (shouldUpdateView)
33340:       result->GetView()->NodeURIChanged(this, mURI);
33314:   }
33314:   else if (aProperty.EqualsLiteral("favicon")) {
33340:     mFaviconURI = aNewValue;
33340:     if (shouldUpdateView)
33340:       result->GetView()->NodeIconChanged(this);
33314:   }
33314:   else if (aProperty.EqualsLiteral("cleartime")) {
33314:     mTime = 0;
33340:     if (shouldUpdateView)
33340:       result->GetView()->NodeHistoryDetailsChanged(this, 0, mAccessCount);
33314:   }
33314:   else if (aProperty.EqualsLiteral("tags")) {
33314:     mTags.SetIsVoid(PR_TRUE);
33340:     if (shouldUpdateView)
33340:       result->GetView()->NodeTagsChanged(this);
33340:   }
33340:   else if (aProperty.EqualsLiteral("dateAdded")) {
33340:     // aNewValue has the date as a string, but we can use aLastModified,
33340:     // because it's set to the same value when dateAdded is changed.
33340:     mDateAdded = aLastModified;
33340:     if (shouldUpdateView)
33340:       result->GetView()->NodeDateAddedChanged(this, mDateAdded);
33340:   }
33340:   else if (aProperty.EqualsLiteral("lastModified")) {
33340:     if (shouldUpdateView)
33340:       result->GetView()->NodeLastModifiedChanged(this, aLastModified);
33340:   }
33340:   else if (aProperty.EqualsLiteral("keyword")) {
33340:     if (shouldUpdateView)
33340:       result->GetView()->NodeKeywordChanged(this, aNewValue);
33340:   }
33340:   else {
33314:     NS_NOTREACHED("Unknown bookmark property changing.");
33314:   }
33314: 
 2551:   if (!mParent)
 2551:     return NS_OK;
 2551: 
 2551:   // DO NOT OPTIMIZE THIS TO CHECK aProperty
 2551:   // the sorting methods fall back to each other so we need to re-sort the
 2551:   // result even if it's not set to sort by the given property
 2551:   PRInt32 ourIndex = mParent->FindChild(this);
 9714:   mParent->EnsureItemPosition(ourIndex);
 2551: 
 2551:   return NS_OK;
 2551: }
    1: 
    1: NS_IMETHODIMP
 1337: nsNavHistoryFolderResultNode::OnItemChanged(PRInt64 aItemId,
    1:                                             const nsACString& aProperty,
 1337:                                             PRBool aIsAnnotationProperty,
33340:                                             const nsACString& aNewValue,
33340:                                             PRTime aLastModified,
33340:                                             PRUint16 aItemType) {
10046:   // The query-item's title is used for simple-query nodes
10046:   if (mQueryItemId != -1) {
10046:     PRBool isTitleChange = aProperty.EqualsLiteral("title");
10046:     if ((mQueryItemId == aItemId && !isTitleChange) ||
10046:         (mQueryItemId != aItemId && isTitleChange)) {
10046:       return NS_OK;
10046:     }
10046:   }
10046: 
 2551:   return nsNavHistoryResultNode::OnItemChanged(aItemId, aProperty,
 2551:                                                aIsAnnotationProperty,
33340:                                                aNewValue,
33340:                                                aLastModified,
33340:                                                aItemType);
    1: }
    1: 
    1: // nsNavHistoryFolderResultNode::OnItemVisited (nsINavBookmarkObserver)
    1: //
    1: //    Update visit count and last visit time and refresh.
    1: 
    1: NS_IMETHODIMP
 1337: nsNavHistoryFolderResultNode::OnItemVisited(PRInt64 aItemId,
    1:                                             PRInt64 aVisitId, PRTime aTime)
    1: {
29521:   PRBool excludeItems = (mResult && mResult->mRootNode->mOptions->ExcludeItems()) ||
29521:                         (mParent && mParent->mOptions->ExcludeItems()) ||
29521:                         mOptions->ExcludeItems();
29521:   if (excludeItems)
    1:     return NS_OK; // don't update items when we aren't displaying them
    1:   if (!StartIncrementalUpdate())
    1:     return NS_OK;
    1: 
    1:   PRUint32 nodeIndex;
 1347:   nsNavHistoryResultNode* node = FindChildById(aItemId, &nodeIndex);
    1:   if (!node)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsNavHistoryResult* result = GetResult();
    1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
    1: 
    1:   // update node
    1:   node->mTime = aTime;
    1:   node->mAccessCount ++;
    1: 
    1:   // update us
    1:   PRInt32 oldAccessCount = mAccessCount;
    1:   mAccessCount ++;
    1:   if (aTime > mTime)
    1:     mTime = aTime;
    1:   ReverseUpdateStats(mAccessCount - oldAccessCount);
    1: 
33340:   if (result->GetView() && AreChildrenVisible()) {
33340:     // Sorting has not changed, just redraw the row if it's visible.
33340:     result->GetView()->NodeHistoryDetailsChanged(node, mTime, mAccessCount);
33340:   }
33340: 
    1:   // update sorting if necessary
    1:   PRUint32 sortType = GetSortType();
    1:   if (sortType == nsINavHistoryQueryOptions::SORT_BY_VISITCOUNT_ASCENDING ||
    1:       sortType == nsINavHistoryQueryOptions::SORT_BY_VISITCOUNT_DESCENDING ||
    1:       sortType == nsINavHistoryQueryOptions::SORT_BY_DATE_ASCENDING ||
    1:       sortType == nsINavHistoryQueryOptions::SORT_BY_DATE_DESCENDING) {
    1:     PRInt32 childIndex = FindChild(node);
    1:     NS_ASSERTION(childIndex >= 0, "Could not find child we just got a reference to");
    1:     if (childIndex >= 0) {
 9714:       EnsureItemPosition(childIndex);
    1:     }
33340:   }
33340: 
    1:   return NS_OK;
    1: }
    1: 
 1726: // nsNavHistoryFolderResultNode::OnItemMoved (nsINavBookmarkObserver)
    1: 
    1: NS_IMETHODIMP
 1726: nsNavHistoryFolderResultNode::OnItemMoved(PRInt64 aItemId, PRInt64 aOldParent,
    1:                                           PRInt32 aOldIndex, PRInt64 aNewParent,
33340:                                           PRInt32 aNewIndex, PRUint16 aItemType)
    1: {
 1337:   NS_ASSERTION(aOldParent == mItemId || aNewParent == mItemId,
    1:                "Got a bookmark message that doesn't belong to us");
    1:   if (! StartIncrementalUpdate())
    1:     return NS_OK; // entire container was refreshed for us
    1: 
    1:   if (aOldParent == aNewParent) {
    1:     // getting moved within the same folder, we don't want to do a remove and
    1:     // an add because that will lose your tree state.
    1: 
    1:     // adjust bookmark indices
    1:     ReindexRange(aOldIndex + 1, PR_INT32_MAX, -1);
    1:     ReindexRange(aNewIndex, PR_INT32_MAX, 1);
    1: 
    1:     PRUint32 index;
 1726:     nsNavHistoryResultNode* node = FindChildById(aItemId, &index);
    1:     if (!node) {
    1:       NS_NOTREACHED("Can't find folder that is moving!");
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     NS_ASSERTION(index >= 0 && index < PRUint32(mChildren.Count()),
    1:                  "Invalid index!");
    1:     node->mBookmarkIndex = aNewIndex;
    1: 
    1:     // adjust position
 9714:     EnsureItemPosition(index);
    1:     return NS_OK;
    1:   } else {
    1:     // moving between two different folders, just do a remove and an add
 1337:     if (aOldParent == mItemId)
33340:       OnItemRemoved(aItemId, aOldParent, aOldIndex, aItemType);
 1337:     if (aNewParent == mItemId)
33340:       OnItemAdded(aItemId, aNewParent, aNewIndex, aItemType);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistorySeparatorResultNode
    1: //
    1: // Separator nodes do not hold any data
    1: 
    1: nsNavHistorySeparatorResultNode::nsNavHistorySeparatorResultNode()
    1:   : nsNavHistoryResultNode(EmptyCString(), EmptyCString(),
    1:                            0, 0, EmptyCString())
    1: {
    1: }
    1: 
  809: 
    1: // nsNavHistoryResult **********************************************************
 7025: NS_IMPL_CYCLE_COLLECTION_CLASS(nsNavHistoryResult)
 7025: 
20261: static PLDHashOperator
15172: RemoveBookmarkFolderObserversCallback(nsTrimInt64HashKey::KeyType aKey,
15172:                                       nsNavHistoryResult::FolderObserverList*& aData,
15172:                                       void* userArg)
15172: {
15172:   delete aData;
15172:   return PL_DHASH_REMOVE;
15172: }
15172: 
 7025: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsNavHistoryResult)
30863:   tmp->StopObserving();
 7025:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mRootNode)
14171:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mView)
15172:   tmp->mBookmarkFolderObservers.Enumerate(&RemoveBookmarkFolderObserversCallback, nsnull);
27458:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSTARRAY(mAllBookmarksObservers)
27458:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSTARRAY(mHistoryObservers)
 7025: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 7025: 
20261: static PLDHashOperator
15172: TraverseBookmarkFolderObservers(nsTrimInt64HashKey::KeyType aKey,
15172:                                 nsNavHistoryResult::FolderObserverList* &aData,
30113:                                 void *aClosure)
15172: {
15172:   nsCycleCollectionTraversalCallback* cb =
30113:     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
30113:   for (PRUint32 i = 0; i < aData->Length(); ++i) {
15172:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
15172:                                        "mBookmarkFolderObservers value[i]");
15172:     nsNavHistoryResultNode* node = aData->ElementAt(i);
15172:     cb->NoteXPCOMChild(node);
15172:   }
15172:   return PL_DHASH_NEXT;
15172: }
15172: 
 7025: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsNavHistoryResult)
 7025:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mRootNode, nsINavHistoryContainerResultNode)
14171:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mView)
15172:   tmp->mBookmarkFolderObservers.Enumerate(&TraverseBookmarkFolderObservers, &cb);
27458:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY_MEMBER(mAllBookmarksObservers, nsNavHistoryQueryResultNode)
27458:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY_MEMBER(mHistoryObservers, nsNavHistoryQueryResultNode)
 7025: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 7025: 
 7025: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNavHistoryResult)
 7025: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNavHistoryResult)
 7025: 
 7025: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNavHistoryResult)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsINavHistoryResult)
    1:   NS_INTERFACE_MAP_STATIC_AMBIGUOUS(nsNavHistoryResult)
    1:   NS_INTERFACE_MAP_ENTRY(nsINavHistoryResult)
    1:   NS_INTERFACE_MAP_ENTRY(nsINavBookmarkObserver)
    1:   NS_INTERFACE_MAP_ENTRY(nsINavHistoryObserver)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1: NS_INTERFACE_MAP_END
    1: 
    1: nsNavHistoryResult::nsNavHistoryResult(nsNavHistoryContainerResultNode* aRoot) :
    1:   mRootNode(aRoot),
    1:   mIsHistoryObserver(PR_FALSE),
 2579:   mIsBookmarkFolderObserver(PR_FALSE),
 4623:   mIsAllBookmarksObserver(PR_FALSE),
29235:   mBatchInProgress(PR_FALSE),
29235:   mNeedsToApplySortingMode(PR_FALSE)
    1: {
    1:   mRootNode->mResult = this;
    1: }
    1: 
    1: nsNavHistoryResult::~nsNavHistoryResult()
    1: {
 2579:   // delete all bookmark folder observer arrays which are allocated on the heap
 2579:   mBookmarkFolderObservers.Enumerate(&RemoveBookmarkFolderObserversCallback, nsnull);
    1: }
    1: 
29235: void
29235: nsNavHistoryResult::StopObserving()
29235: {
29235:   if (mIsBookmarkFolderObserver || mIsAllBookmarksObserver) {
29235:     nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
29235:     if (bookmarks) {
29235:       bookmarks->RemoveObserver(this);
29235:       mIsBookmarkFolderObserver = PR_FALSE;
29235:       mIsAllBookmarksObserver = PR_FALSE;
29235:     }
29235:   }
29235:   if (mIsHistoryObserver) {
29235:     nsNavHistory* history = nsNavHistory::GetHistoryService();
29235:     if (history) {
29235:       history->RemoveObserver(this);
29235:       mIsHistoryObserver = PR_FALSE;
29235:     }
29235:   }
29235: }
    1: 
    1: // nsNavHistoryResult::Init
    1: //
    1: //    Call AddRef before this, since we may do things like register ourselves.
    1: 
    1: nsresult
    1: nsNavHistoryResult::Init(nsINavHistoryQuery** aQueries,
    1:                          PRUint32 aQueryCount,
    1:                          nsNavHistoryQueryOptions *aOptions)
    1: {
    1:   nsresult rv;
    1:   NS_ASSERTION(aOptions, "Must have valid options");
    1:   NS_ASSERTION(aQueries && aQueryCount > 0, "Must have >1 query in result");
    1: 
    1:   // Fill saved source queries with copies of the original (the caller might
    1:   // change their original objects, and we always want to reflect the source
    1:   // parameters).
    1:   for (PRUint32 i = 0; i < aQueryCount; i ++) {
    1:     nsCOMPtr<nsINavHistoryQuery> queryClone;
    1:     rv = aQueries[i]->Clone(getter_AddRefs(queryClone));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (!mQueries.AppendObject(queryClone))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   rv = aOptions->Clone(getter_AddRefs(mOptions));
 6822:   NS_ENSURE_SUCCESS(rv, rv);
    1:   mSortingMode = aOptions->SortingMode();
 6822:   rv = aOptions->GetSortingAnnotation(mSortingAnnotation);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 2579:   if (! mBookmarkFolderObservers.Init(128))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ASSERTION(mRootNode->mIndentLevel == -1,
    1:                "Root node's indent level initialized wrong");
    1:   mRootNode->FillStats();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryResult::NewHistoryResult
    1: //
    1: //    Constructs a new history result object.
    1: 
    1: nsresult // static
    1: nsNavHistoryResult::NewHistoryResult(nsINavHistoryQuery** aQueries,
    1:                                      PRUint32 aQueryCount,
    1:                                      nsNavHistoryQueryOptions* aOptions,
    1:                                      nsNavHistoryContainerResultNode* aRoot,
    1:                                      nsNavHistoryResult** result)
    1: {
    1:   *result = new nsNavHistoryResult(aRoot);
    1:   if (! *result)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF(*result); // must happen before Init
    1:   nsresult rv = (*result)->Init(aQueries, aQueryCount, aOptions);
    1:   if (NS_FAILED(rv)) {
    1:     NS_RELEASE(*result);
    1:     *result = nsnull;
    1:     return rv;
    1:   }
27458: 
27458:   // Correctly set mBatchInProgress for the result based on the root node value.
27458:   if (aRoot->IsQuery())
27458:     (*result)->mBatchInProgress = aRoot->GetAsQuery()->mBatchInProgress;
27458: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
 2579: // nsNavHistoryResult::AddHistoryObserver
    1: 
    1: void
 2579: nsNavHistoryResult::AddHistoryObserver(nsNavHistoryQueryResultNode* aNode)
    1: {
    1:   if (! mIsHistoryObserver) {
    1:       nsNavHistory* history = nsNavHistory::GetHistoryService();
    1:       NS_ASSERTION(history, "Can't create history service");
    1:       history->AddObserver(this, PR_TRUE);
    1:       mIsHistoryObserver = PR_TRUE;
    1:   }
 2579:   if (mHistoryObservers.IndexOf(aNode) != mHistoryObservers.NoIndex) {
27458:     NS_WARNING("Attempting to register as a history observer twice!");
    1:     return;
    1:   }
 2579:   mHistoryObservers.AppendElement(aNode);
 2579: }
 2579: 
 2579: // nsNavHistoryResult::AddAllBookmarksObserver
    1: 
    1: void
 2579: nsNavHistoryResult::AddAllBookmarksObserver(nsNavHistoryQueryResultNode* aNode)
    1: {
27458:   if (!mIsAllBookmarksObserver && !mIsBookmarkFolderObserver) {
    1:     nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
    1:     if (! bookmarks) {
    1:       NS_NOTREACHED("Can't create bookmark service");
    1:       return;
    1:     }
    1:     bookmarks->AddObserver(this, PR_TRUE);
 2579:     mIsAllBookmarksObserver = PR_TRUE;
 2579:   }
 2579:   if (mAllBookmarksObservers.IndexOf(aNode) != mAllBookmarksObservers.NoIndex) {
27458:     NS_WARNING("Attempting to register an all bookmarks observer twice!");
 2579:     return;
 2579:   }
 2579:   mAllBookmarksObservers.AppendElement(aNode);
 2579: }
 2579: 
 2579: 
 2579: // nsNavHistoryResult::AddBookmarkFolderObserver
 2579: //
 2579: //    Here, we also attach as a bookmark service observer if necessary
 2579: 
 2579: void
 2579: nsNavHistoryResult::AddBookmarkFolderObserver(nsNavHistoryFolderResultNode* aNode,
 2579:                                               PRInt64 aFolder)
 2579: {
27458:   if (!mIsBookmarkFolderObserver && !mIsAllBookmarksObserver) {
 2579:     nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
 2579:     if (!bookmarks) {
 2579:       NS_NOTREACHED("Can't create bookmark service");
 2579:       return;
 2579:     }
 2579:     bookmarks->AddObserver(this, PR_TRUE);
 2579:     mIsBookmarkFolderObserver = PR_TRUE;
 2579:   }
 2579: 
 2579:   FolderObserverList* list = BookmarkFolderObserversForId(aFolder, PR_TRUE);
    1:   if (list->IndexOf(aNode) != list->NoIndex) {
27458:     NS_NOTREACHED("Attempting to register as a folder observer twice!");
    1:     return;
    1:   }
    1:   list->AppendElement(aNode);
    1: }
    1: 
    1: 
 2579: // nsNavHistoryResult::RemoveHistoryObserver
    1: 
    1: void
 2579: nsNavHistoryResult::RemoveHistoryObserver(nsNavHistoryQueryResultNode* aNode)
    1: {
 2579:   mHistoryObservers.RemoveElement(aNode);
 2579: }
 2579: 
 2579: // nsNavHistoryResult::RemoveAllBookmarksObserver
    1: 
    1: void
 2579: nsNavHistoryResult::RemoveAllBookmarksObserver(nsNavHistoryQueryResultNode* aNode)
 2579: {
 2579:   mAllBookmarksObservers.RemoveElement(aNode);
 2579: }
 2579: 
 2579: 
 2579: // nsNavHistoryResult::RemoveBookmarkFolderObserver
 2579: 
 2579: void
 2579: nsNavHistoryResult::RemoveBookmarkFolderObserver(nsNavHistoryFolderResultNode* aNode,
    1:                                                  PRInt64 aFolder)
    1: {
 2579:   FolderObserverList* list = BookmarkFolderObserversForId(aFolder, PR_FALSE);
    1:   if (! list)
    1:     return; // we don't even have an entry for that folder
    1:   list->RemoveElement(aNode);
    1: }
    1: 
    1: 
 2579: // nsNavHistoryResult::BookmarkFolderObserversForId
    1: 
    1: nsNavHistoryResult::FolderObserverList*
 2579: nsNavHistoryResult::BookmarkFolderObserversForId(PRInt64 aFolderId, PRBool aCreate)
    1: {
    1:   FolderObserverList* list;
 2579:   if (mBookmarkFolderObservers.Get(aFolderId, &list))
    1:     return list;
    1:   if (! aCreate)
    1:     return nsnull;
    1: 
    1:   // need to create a new list
    1:   list = new FolderObserverList;
 2579:   mBookmarkFolderObservers.Put(aFolderId, list);
    1:   return list;
    1: }
    1: 
    1: // nsNavHistoryResult::GetSortingMode (nsINavHistoryResult)
    1: 
    1: NS_IMETHODIMP
  809: nsNavHistoryResult::GetSortingMode(PRUint16* aSortingMode)
    1: {
    1:   *aSortingMode = mSortingMode;
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistoryResult::SetSortingMode (nsINavHistoryResult)
    1: 
    1: NS_IMETHODIMP
  809: nsNavHistoryResult::SetSortingMode(PRUint16 aSortingMode)
    1: {
  713:   if (aSortingMode > nsINavHistoryQueryOptions::SORT_BY_ANNOTATION_DESCENDING)
    1:     return NS_ERROR_INVALID_ARG;
    1:   if (! mRootNode)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // keep everything in sync
    1:   NS_ASSERTION(mOptions, "Options should always be present for a root query");
    1: 
    1:   mSortingMode = aSortingMode;
    1: 
29235:   if (!mRootNode->mExpanded) {
29235:     // Need to do this later when node will be expanded.
29235:     mNeedsToApplySortingMode = PR_TRUE;
29235:     return NS_OK;
29235:   }
29235: 
    1:   // actually do sorting
    1:   nsNavHistoryContainerResultNode::SortComparator comparator =
    1:       nsNavHistoryContainerResultNode::GetSortingComparator(aSortingMode);
    1:   if (comparator) {
    1:     nsNavHistory* history = nsNavHistory::GetHistoryService();
    1:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
  713:     mRootNode->RecursiveSort(mSortingAnnotation.get(), comparator);
    1:   }
    1: 
    1:   if (mView) {
    1:     mView->SortingChanged(aSortingMode);
33340:     mView->InvalidateContainer(mRootNode);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
  713: NS_IMETHODIMP
  713: nsNavHistoryResult::GetSortingAnnotation(nsACString& _result) {
  713:   _result.Assign(mSortingAnnotation);
  713:   return NS_OK;
  713: }
  713: 
  713: NS_IMETHODIMP
  713: nsNavHistoryResult::SetSortingAnnotation(const nsACString& aSortingAnnotation) {
  713:   mSortingAnnotation.Assign(aSortingAnnotation);
  713:   return NS_OK;
  713: }
    1: 
    1: // nsNavHistoryResult::Viewer (nsINavHistoryResult)
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryResult::GetViewer(nsINavHistoryResultViewer** aViewer)
    1: {
    1:   *aViewer = mView;
    1:   NS_IF_ADDREF(*aViewer);
    1:   return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsNavHistoryResult::SetViewer(nsINavHistoryResultViewer* aViewer)
    1: {
    1:   mView = aViewer;
    1:   if (aViewer)
    1:     aViewer->SetResult(this);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryResult::GetRoot (nsINavHistoryResult)
    1: //
    1: NS_IMETHODIMP
 4179: nsNavHistoryResult::GetRoot(nsINavHistoryContainerResultNode** aRoot)
    1: {
    1:   if (! mRootNode) {
    1:     NS_NOTREACHED("Root is null");
    1:     *aRoot = nsnull;
    1:     return NS_ERROR_FAILURE;
    1:   }
 4179:   return mRootNode->QueryInterface(NS_GET_IID(nsINavHistoryContainerResultNode),
 3233:                                    reinterpret_cast<void**>(aRoot));
    1: }
    1: 
    1: 
    1: // nsINavBookmarkObserver implementation
    1: 
    1: // Here, it is important that we create a COPY of the observer array. Some
    1: // observers will requery themselves, which may cause the observer array to
    1: // be modified or added to.
 2579: #define ENUMERATE_BOOKMARK_FOLDER_OBSERVERS(_folderId, _functionCall) \
27458:   PR_BEGIN_MACRO \
 2579:     FolderObserverList* _fol = BookmarkFolderObserversForId(_folderId, PR_FALSE); \
    1:     if (_fol) { \
    1:       FolderObserverList _listCopy(*_fol); \
    1:       for (PRUint32 _fol_i = 0; _fol_i < _listCopy.Length(); _fol_i ++) { \
    1:         if (_listCopy[_fol_i]) \
    1:           _listCopy[_fol_i]->_functionCall; \
    1:       } \
    1:     } \
27458:   PR_END_MACRO
27458: #define ENUMERATE_QUERY_OBSERVERS(_functionCall, _observersList, _conditionCall) \
27458:   PR_BEGIN_MACRO \
27458:     QueryObserverList _listCopy(_observersList); \
27458:     for (PRUint32 _obs_i = 0; _obs_i < _listCopy.Length(); _obs_i ++) { \
27458:       if (_listCopy[_obs_i] && _listCopy[_obs_i]->_conditionCall) \
27458:         _listCopy[_obs_i]->_functionCall; \
27458:     } \
27458:   PR_END_MACRO
 2579: #define ENUMERATE_ALL_BOOKMARKS_OBSERVERS(_functionCall) \
27458:   ENUMERATE_QUERY_OBSERVERS(_functionCall, mAllBookmarksObservers, IsQuery())
 2579: #define ENUMERATE_HISTORY_OBSERVERS(_functionCall) \
27458:   ENUMERATE_QUERY_OBSERVERS(_functionCall, mHistoryObservers, IsQuery())
    1: 
    1: // nsNavHistoryResult::OnBeginUpdateBatch (nsINavBookmark/HistoryObserver)
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryResult::OnBeginUpdateBatch()
    1: {
 4623:   mBatchInProgress = PR_TRUE;
    1:   ENUMERATE_HISTORY_OBSERVERS(OnBeginUpdateBatch());
 2579:   ENUMERATE_ALL_BOOKMARKS_OBSERVERS(OnBeginUpdateBatch());
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryResult::OnEndUpdateBatch (nsINavBookmark/HistoryObserver)
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryResult::OnEndUpdateBatch()
    1: {
14983:   if (mBatchInProgress) {
 4623:     mBatchInProgress = PR_FALSE;
    1:     ENUMERATE_HISTORY_OBSERVERS(OnEndUpdateBatch());
 2579:     ENUMERATE_ALL_BOOKMARKS_OBSERVERS(OnEndUpdateBatch());
14983:   }
14983:   else
14983:     NS_WARNING("EndUpdateBatch without a begin");
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryResult::OnItemAdded (nsINavBookmarkObserver)
    1: 
    1: NS_IMETHODIMP
 1337: nsNavHistoryResult::OnItemAdded(PRInt64 aItemId,
33340:                                 PRInt64 aParentId,
33340:                                 PRInt32 aIndex,
33340:                                 PRUint16 aItemType)
    1: {
33340:   ENUMERATE_BOOKMARK_FOLDER_OBSERVERS(aParentId,
33340:       OnItemAdded(aItemId, aParentId, aIndex, aItemType));
33340:   ENUMERATE_HISTORY_OBSERVERS(OnItemAdded(aItemId, aParentId, aIndex, aItemType));
33340:   ENUMERATE_ALL_BOOKMARKS_OBSERVERS(OnItemAdded(aItemId, aParentId, aIndex,
33340:                                                 aItemType));
    1:   return NS_OK;
    1: }
    1: 
    1: 
26383: // nsNavHistoryResult::OnBeforeItemRemoved (nsINavBookmarkObserver)
26383: 
26383: NS_IMETHODIMP
33340: nsNavHistoryResult::OnBeforeItemRemoved(PRInt64 aItemId, PRUint16 aItemType)
26383: {
26383:   // Nobody actually does anything with this method, so we do not need to notify
26383:   return NS_OK;
26383: }
26383: 
26383: 
    1: // nsNavHistoryResult::OnItemRemoved (nsINavBookmarkObserver)
    1: 
    1: NS_IMETHODIMP
 1337: nsNavHistoryResult::OnItemRemoved(PRInt64 aItemId,
33340:                                   PRInt64 aParentId, PRInt32 aIndex,
33340:                                   PRUint16 aItemType)
    1: {
33340:   ENUMERATE_BOOKMARK_FOLDER_OBSERVERS(aParentId,
33340:       OnItemRemoved(aItemId, aParentId, aIndex, aItemType));
 2579:   ENUMERATE_ALL_BOOKMARKS_OBSERVERS(
33340:       OnItemRemoved(aItemId, aParentId, aIndex, aItemType));
 2579:   ENUMERATE_HISTORY_OBSERVERS(
33340:       OnItemRemoved(aItemId, aParentId, aIndex, aItemType));
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryResult::OnItemChanged (nsINavBookmarkObserver)
    1: 
    1: NS_IMETHODIMP
 1337: nsNavHistoryResult::OnItemChanged(PRInt64 aItemId,
    1:                                   const nsACString &aProperty,
 1337:                                   PRBool aIsAnnotationProperty,
33340:                                   const nsACString &aNewValue,
33340:                                   PRTime aLastModified,
33340:                                   PRUint16 aItemType)
    1: {
 2579:   ENUMERATE_ALL_BOOKMARKS_OBSERVERS(
33340:     OnItemChanged(aItemId, aProperty, aIsAnnotationProperty, aNewValue,
33340:                   aLastModified, aItemType));
 2551: 
 8193:   // Note: folder-nodes set their own bookmark observer only once they're
 8193:   // opened, meaning we cannot optimize this code path for changes done to
 8193:   // folder-nodes.
 8193: 
28943:   nsNavBookmarks* bookmarkService = nsNavBookmarks::GetBookmarksService();
28943:   NS_ENSURE_TRUE(bookmarkService, NS_ERROR_OUT_OF_MEMORY);
28943: 
 8193:   // Find the changed items under the folders list
    1:   PRInt64 folderId;
28943:   nsresult rv = bookmarkService->GetFolderIdForItem(aItemId, &folderId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
 2551: 
 2579:   FolderObserverList* list = BookmarkFolderObserversForId(folderId, PR_FALSE);
 2551:   if (!list)
 2551:     return NS_OK;
 2551: 
 2551:   for (PRUint32 i = 0; i < list->Length(); i++) {
15172:     nsRefPtr<nsNavHistoryFolderResultNode> folder = list->ElementAt(i);
 2551:     if (folder) {
 2551:       PRUint32 nodeIndex;
28943:       nsRefPtr<nsNavHistoryResultNode> node =
28943:         folder->FindChildById(aItemId, &nodeIndex);
10760:       // if ExcludeItems is true we don't update non visible items
28943:       PRBool excludeItems = (mRootNode->mOptions->ExcludeItems()) ||
28943:                              folder->mOptions->ExcludeItems();
10760:       if (node &&
28943:           (!excludeItems || !(node->IsURI() || node->IsSeparator())) &&
 6986:           folder->StartIncrementalUpdate()) {
33340:         node->OnItemChanged(aItemId, aProperty, aIsAnnotationProperty,
33340:                             aNewValue, aLastModified, aItemType);
 2551:       }
 2551:     }
 2551:   }
    1: 
    1:   // Note: we do NOT call history observers in this case. This notification is
    1:   // the same as other history notification, except that here we know the item
    1:   // is a bookmark. History observers will handle the history notification
    1:   // instead.
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistoryResult::OnItemVisited (nsINavBookmarkObserver)
    1: 
    1: NS_IMETHODIMP
 1337: nsNavHistoryResult::OnItemVisited(PRInt64 aItemId, PRInt64 aVisitId,
 1337:                                   PRTime aVisitTime)
    1: {
    1:   nsresult rv;
    1:   nsNavBookmarks* bookmarkService = nsNavBookmarks::GetBookmarksService();
    1:   NS_ENSURE_TRUE(bookmarkService, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // find the folder to notify about this item
    1:   PRInt64 folderId;
 1337:   rv = bookmarkService->GetFolderIdForItem(aItemId, &folderId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
 2579:   ENUMERATE_BOOKMARK_FOLDER_OBSERVERS(folderId,
 1337:       OnItemVisited(aItemId, aVisitId, aVisitTime));
 2579:   ENUMERATE_ALL_BOOKMARKS_OBSERVERS(
 2579:       OnItemVisited(aItemId, aVisitId, aVisitTime));
    1:   // Note: we do NOT call history observers in this case. This notification is
    1:   // the same as OnVisit, except that here we know the item is a bookmark.
    1:   // History observers will handle the history notification instead.
    1:   return NS_OK;
    1: }
    1: 
    1: 
 1726: // nsNavHistoryResult::OnItemMoved (nsINavBookmarkObserver)
    1: //
    1: //    Need to notify both the source and the destination folders (if they
    1: //    are different).
    1: 
    1: NS_IMETHODIMP
 1726: nsNavHistoryResult::OnItemMoved(PRInt64 aItemId,
    1:                                 PRInt64 aOldParent, PRInt32 aOldIndex,
33340:                                 PRInt64 aNewParent, PRInt32 aNewIndex,
33340:                                 PRUint16 aItemType)
    1: {
    1:   { // scope for loop index for VC6's broken for loop scoping
 2579:     ENUMERATE_BOOKMARK_FOLDER_OBSERVERS(aOldParent,
33340:         OnItemMoved(aItemId, aOldParent, aOldIndex, aNewParent, aNewIndex,
33340:                     aItemType));
    1:   }
    1:   if (aNewParent != aOldParent) {
 2579:     ENUMERATE_BOOKMARK_FOLDER_OBSERVERS(aNewParent,
33340:         OnItemMoved(aItemId, aOldParent, aOldIndex, aNewParent, aNewIndex,
33340:                     aItemType));
 1726:   }
 2579:   ENUMERATE_ALL_BOOKMARKS_OBSERVERS(OnItemMoved(aItemId, aOldParent, aOldIndex,
33340:                                                 aNewParent, aNewIndex,
33340:                                                 aItemType));
 1726:   ENUMERATE_HISTORY_OBSERVERS(OnItemMoved(aItemId, aOldParent, aOldIndex,
33340:                                           aNewParent, aNewIndex, aItemType));
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistoryResult::OnVisit (nsINavHistoryObserver)
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryResult::OnVisit(nsIURI* aURI, PRInt64 aVisitId, PRTime aTime,
    1:                             PRInt64 aSessionId, PRInt64 aReferringId,
12328:                             PRUint32 aTransitionType, PRUint32* aAdded)
    1: {
12328:   PRUint32 added = 0;
12328: 
    1:   ENUMERATE_HISTORY_OBSERVERS(OnVisit(aURI, aVisitId, aTime, aSessionId,
12328:                                       aReferringId, aTransitionType, &added));
12328: 
29519:   if (!mRootNode->mExpanded)
29519:     return NS_OK;
29519: 
29519:   // If this visit is accepted by an overlapped container, and not all
29519:   // overlapped containers are visible, we should still call Refresh if the
29519:   // visit falls into any of them.
29519:   PRBool todayIsMissing = PR_FALSE;
29519:   PRUint32 resultType = mRootNode->mOptions->ResultType();
29519:   if (resultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_QUERY ||
29519:       resultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_SITE_QUERY) {
29519:     PRUint32 childCount;
29519:     nsresult rv = mRootNode->GetChildCount(&childCount);
29519:     NS_ENSURE_SUCCESS(rv, rv);
29519:     if (childCount) {
29519:       nsCOMPtr<nsINavHistoryResultNode> firstChild;
29519:       rv = mRootNode->GetChild(0, getter_AddRefs(firstChild));
29519:       NS_ENSURE_SUCCESS(rv, rv);
29519:       nsCAutoString title;
29519:       rv = firstChild->GetTitle(title);
29519:       NS_ENSURE_SUCCESS(rv, rv);
29519:       nsNavHistory* history = nsNavHistory::GetHistoryService();
29519:       NS_ENSURE_TRUE(history, 0);
29519:       nsCAutoString todayLabel;
29519:       history->GetStringFromName(
29519:         NS_LITERAL_STRING("finduri-AgeInDays-is-0").get(), todayLabel);
29519:       todayIsMissing = !todayLabel.Equals(title);
29519:     }
29519:   }
29519: 
29519:   if (!added || todayIsMissing) {
29519:     // None of registered query observers has accepted our URI.  This means,
12328:     // that a matching query either was not expanded or it does not exist.
12328:     PRUint32 resultType = mRootNode->mOptions->ResultType();
12328:     if (resultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_QUERY ||
26467:         resultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_SITE_QUERY ||
26467:         resultType == nsINavHistoryQueryOptions::RESULTS_AS_SITE_QUERY)
27458:       (void)mRootNode->GetAsQuery()->Refresh();
27072:     else {
27072:       // We are result of a folder node, then we should run through history
27072:       // observers that are containers queries and refresh them.
27072:       // We use a copy of the observers array since requerying could potentially
27072:       // cause changes to the array.
27458:       ENUMERATE_QUERY_OBSERVERS(Refresh(), mHistoryObservers, IsContainersQuery());
27072:     }
12328:   }
12328: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryResult::OnTitleChanged (nsINavHistoryObserver)
    1: 
    1: NS_IMETHODIMP
 4037: nsNavHistoryResult::OnTitleChanged(nsIURI* aURI, const nsAString& aPageTitle)
    1: {
 4037:   ENUMERATE_HISTORY_OBSERVERS(OnTitleChanged(aURI, aPageTitle));
    1:   return NS_OK;
    1: }
    1: 
    1: 
27196: // nsNavHistoryResult::OnBeforeDeleteURI (nsINavHistoryObserver)
27196: NS_IMETHODIMP
27196: nsNavHistoryResult::OnBeforeDeleteURI(nsIURI *aURI)
27196: {
27196:   return NS_OK;
27196: }
27196: 
27196: 
    1: // nsNavHistoryResult::OnDeleteURI (nsINavHistoryObserver)
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryResult::OnDeleteURI(nsIURI *aURI)
    1: {
    1:   ENUMERATE_HISTORY_OBSERVERS(OnDeleteURI(aURI));
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryResult::OnClearHistory (nsINavHistoryObserver)
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryResult::OnClearHistory()
    1: {
    1:   ENUMERATE_HISTORY_OBSERVERS(OnClearHistory());
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryResult::OnPageChanged (nsINavHistoryObserver)
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryResult::OnPageChanged(nsIURI *aURI,
    1:                                   PRUint32 aWhat, const nsAString &aValue)
    1: {
    1:   ENUMERATE_HISTORY_OBSERVERS(OnPageChanged(aURI, aWhat, aValue));
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistoryResult;:OnPageExpired (nsINavHistoryObserver)
    1: //
    1: //    Don't do anything when pages expire. Perhaps we want to find the item
    1: //    to delete it.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistoryResult::OnPageExpired(nsIURI* aURI, PRTime aVisitTime,
    1:                                   PRBool aWholeEntry)
    1: {
    1:   return NS_OK;
    1: }
