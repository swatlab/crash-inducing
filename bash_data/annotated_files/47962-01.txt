    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Patrick C. Beard <beard@netscape.com>
    1:  *   Kevin McCluskey  <kmcclusk@netscape.com>
    1:  *   Robert O'Callahan <roc+@cs.cmu.edu>
    1:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #define PL_ARENA_CONST_ALIGN_MASK (sizeof(void*)-1)
    1: #include "plarena.h"
    1: 
    1: #include "nsAutoPtr.h"
    1: #include "nsViewManager.h"
    1: #include "nsGfxCIID.h"
    1: #include "nsView.h"
    1: #include "nsISupportsArray.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsRegion.h"
    1: #include "nsInt64.h"
    1: #include "nsHashtable.h"
    1: #include "nsCOMArray.h"
    1: #include "nsThreadUtils.h"
13098: #include "nsContentUtils.h"
30522: #include "nsIPluginWidget.h"
    1: 
    1: static NS_DEFINE_IID(kRegionCID, NS_REGION_CID);
    1: 
    1: /**
    1:    XXX TODO XXX
    1: 
    1:    DeCOMify newly private methods
    1:    Optimize view storage
    1: */
    1: 
    1: /**
    1:    A note about platform assumptions:
    1: 
    1:    We assume all native widgets are opaque.
    1:    
    1:    We assume that a widget is z-ordered on top of its parent.
    1:    
    1:    We do NOT assume anything about the relative z-ordering of sibling widgets. Even though
    1:    we ask for a specific z-order, we don't assume that widget z-ordering actually works.
    1: */
    1: 
    1: #define NSCOORD_NONE      PR_INT32_MIN
    1: 
    1: //-------------- Begin Invalidate Event Definition ------------------------
    1: 
    1: class nsInvalidateEvent : public nsViewManagerEvent {
    1: public:
    1:   nsInvalidateEvent(nsViewManager *vm) : nsViewManagerEvent(vm) {}
    1: 
    1:   NS_IMETHOD Run() {
    1:     if (mViewManager)
    1:       mViewManager->ProcessInvalidateEvent();
    1:     return NS_OK;
    1:   }
    1: };
    1: 
    1: //-------------- End Invalidate Event Definition ---------------------------
    1: 
    1: static PRBool IsViewVisible(nsView *aView)
    1: {
30996:   if (!aView->IsEffectivelyVisible())
    1:     return PR_FALSE;
19214: 
    1:   // Find out if the root view is visible by asking the view observer
    1:   // (this won't be needed anymore if we link view trees across chrome /
    1:   // content boundaries in DocumentViewerImpl::MakeWindow).
    1:   nsIViewObserver* vo = aView->GetViewManager()->GetViewObserver();
    1:   return vo && vo->IsVisible();
    1: }
    1: 
    1: void
    1: nsViewManager::PostInvalidateEvent()
    1: {
    1:   NS_ASSERTION(IsRootVM(), "Caller screwed up");
    1: 
    1:   if (!mInvalidateEvent.IsPending()) {
    1:     nsRefPtr<nsViewManagerEvent> ev = new nsInvalidateEvent(this);
    1:     if (NS_FAILED(NS_DispatchToCurrentThread(ev))) {
    1:       NS_WARNING("failed to dispatch nsInvalidateEvent");
    1:     } else {
    1:       mInvalidateEvent = ev;
    1:     }
    1:   }
    1: }
    1: 
    1: #undef DEBUG_MOUSE_LOCATION
    1: 
29263: PRInt32 nsViewManager::mVMCount = 0;
    1: 
    1: // Weakly held references to all of the view managers
29263: nsVoidArray* nsViewManager::gViewManagers = nsnull;
    1: PRUint32 nsViewManager::gLastUserEventTime = 0;
    1: 
    1: nsViewManager::nsViewManager()
    1:   : mMouseLocation(NSCOORD_NONE, NSCOORD_NONE)
    1:   , mDelayedResize(NSCOORD_NONE, NSCOORD_NONE)
    1:   , mRootViewManager(this)
    1: {
    1:   if (gViewManagers == nsnull) {
29263:     NS_ASSERTION(mVMCount == 0, "View Manager count is incorrect");
    1:     // Create an array to hold a list of view managers
29263:     gViewManagers = new nsVoidArray;
    1:   }
    1:  
    1:   gViewManagers->AppendElement(this);
    1: 
29263:   ++mVMCount;
29263: 
    1:   // NOTE:  we use a zeroing operator new, so all data members are
    1:   // assumed to be cleared here.
    1:   mHasPendingUpdates = PR_FALSE;
    1:   mRecursiveRefreshPending = PR_FALSE;
    1:   mUpdateBatchFlags = 0;
    1: }
    1: 
    1: nsViewManager::~nsViewManager()
    1: {
    1:   if (mRootView) {
    1:     // Destroy any remaining views
    1:     mRootView->Destroy();
    1:     mRootView = nsnull;
    1:   }
    1: 
    1:   // Make sure to revoke pending events for all viewmanagers, since some events
    1:   // are posted by a non-root viewmanager.
    1:   mInvalidateEvent.Revoke();
    1:   mSynthMouseMoveEvent.Revoke();
    1:   
    1:   if (!IsRootVM()) {
    1:     // We have a strong ref to mRootViewManager
    1:     NS_RELEASE(mRootViewManager);
    1:   }
    1: 
29263:   NS_ASSERTION((mVMCount > 0), "underflow of viewmanagers");
29263:   --mVMCount;
29263: 
    1: #ifdef DEBUG
    1:   PRBool removed =
    1: #endif
    1:     gViewManagers->RemoveElement(this);
29263:   NS_ASSERTION(removed, "Viewmanager instance not was not in the global list of viewmanagers");
    1: 
29263:   if (0 == mVMCount) {
    1:     // There aren't any more view managers so
    1:     // release the global array of view managers
    1:    
    1:     NS_ASSERTION(gViewManagers != nsnull, "About to delete null gViewManagers");
    1:     delete gViewManagers;
    1:     gViewManagers = nsnull;
    1:   }
    1: 
    1:   mObserver = nsnull;
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsViewManager, nsIViewManager)
    1: 
    1: nsresult
    1: nsViewManager::CreateRegion(nsIRegion* *result)
    1: {
    1:   nsresult rv;
    1: 
    1:   if (!mRegionFactory) {
    1:     mRegionFactory = do_GetClassObject(kRegionCID, &rv);
    1:     if (NS_FAILED(rv)) {
    1:       *result = nsnull;
    1:       return rv;
    1:     }
    1:   }
    1: 
    1:   nsIRegion* region = nsnull;
    1:   rv = CallCreateInstance(mRegionFactory.get(), &region);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     rv = region->Init();
    1:     *result = region;
    1:   }
    1:   return rv;
    1: }
    1: 
    1: // We don't hold a reference to the presentation context because it
    1: // holds a reference to us.
    1: NS_IMETHODIMP nsViewManager::Init(nsIDeviceContext* aContext)
    1: {
    1:   NS_PRECONDITION(nsnull != aContext, "null ptr");
    1: 
    1:   if (nsnull == aContext) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1:   if (nsnull != mContext) {
    1:     return NS_ERROR_ALREADY_INITIALIZED;
    1:   }
    1:   mContext = aContext;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP_(nsIView *)
    1: nsViewManager::CreateView(const nsRect& aBounds,
    1:                           const nsIView* aParent,
    1:                           nsViewVisibility aVisibilityFlag)
    1: {
    1:   nsView *v = new nsView(this, aVisibilityFlag);
    1:   if (v) {
33369:     v->SetParent(static_cast<nsView*>(const_cast<nsIView*>(aParent)));
    1:     v->SetPosition(aBounds.x, aBounds.y);
    1:     nsRect dim(0, 0, aBounds.width, aBounds.height);
    1:     v->SetDimensions(dim, PR_FALSE);
    1:   }
    1:   return v;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::GetRootView(nsIView *&aView)
    1: {
    1:   aView = mRootView;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::SetRootView(nsIView *aView)
    1: {
 3233:   nsView* view = static_cast<nsView*>(aView);
    1: 
    1:   NS_PRECONDITION(!view || view->GetViewManager() == this,
    1:                   "Unexpected viewmanager on root view");
    1:   
    1:   // Do NOT destroy the current root view. It's the caller's responsibility
    1:   // to destroy it
    1:   mRootView = view;
    1: 
    1:   if (mRootView) {
    1:     nsView* parent = mRootView->GetParent();
    1:     if (parent) {
    1:       // Calling InsertChild on |parent| will InvalidateHierarchy() on us, so
    1:       // no need to set mRootViewManager ourselves here.
    1:       parent->InsertChild(mRootView, nsnull);
    1:     } else {
    1:       InvalidateHierarchy();
    1:     }
    1: 
    1:     mRootView->SetZIndex(PR_FALSE, 0, PR_FALSE);
    1:   }
    1:   // Else don't touch mRootViewManager
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::GetWindowDimensions(nscoord *aWidth, nscoord *aHeight)
    1: {
    1:   if (nsnull != mRootView) {
    1:     if (mDelayedResize == nsSize(NSCOORD_NONE, NSCOORD_NONE)) {
    1:       nsRect dim;
    1:       mRootView->GetDimensions(dim);
    1:       *aWidth = dim.width;
    1:       *aHeight = dim.height;
    1:     } else {
    1:       *aWidth = mDelayedResize.width;
    1:       *aHeight = mDelayedResize.height;
    1:     }
    1:   }
    1:   else
    1:     {
    1:       *aWidth = 0;
    1:       *aHeight = 0;
    1:     }
    1:   return NS_OK;
    1: }
    1: 
46193: void nsViewManager::DoSetWindowDimensions(nscoord aWidth, nscoord aHeight)
46193: {
46193:   nsRect oldDim;
46193:   nsRect newDim(0, 0, aWidth, aHeight);
46193:   mRootView->GetDimensions(oldDim);
46193:   // We care about resizes even when one dimension is already zero.
46193:   if (!oldDim.IsExactEqual(newDim)) {
46193:     // Don't resize the widget. It is already being set elsewhere.
46193:     mRootView->SetDimensions(newDim, PR_TRUE, PR_FALSE);
46193:     if (mObserver)
46193:       mObserver->ResizeReflow(mRootView, aWidth, aHeight);
46193:   }
46193: }
46193: 
    1: NS_IMETHODIMP nsViewManager::SetWindowDimensions(nscoord aWidth, nscoord aHeight)
    1: {
    1:   if (mRootView) {
    1:     if (IsViewVisible(mRootView)) {
    1:       mDelayedResize.SizeTo(NSCOORD_NONE, NSCOORD_NONE);
    1:       DoSetWindowDimensions(aWidth, aHeight);
    1:     } else {
    1:       mDelayedResize.SizeTo(aWidth, aHeight);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
19013: NS_IMETHODIMP nsViewManager::FlushDelayedResize()
19013: {
19013:   if (mDelayedResize != nsSize(NSCOORD_NONE, NSCOORD_NONE)) {
19013:     DoSetWindowDimensions(mDelayedResize.width, mDelayedResize.height);
19013:     mDelayedResize.SizeTo(NSCOORD_NONE, NSCOORD_NONE);
19013:   }
19013:   return NS_OK;
19013: }
19013: 
47899: // Convert aIn from being relative to and in appunits of aFromView, to being
47899: // relative to and in appunits of aToView.
47899: static nsRegion ConvertRegionBetweenViews(const nsRegion& aIn,
47899:                                           nsView* aFromView,
47899:                                           nsView* aToView)
    1: {
47899:   nsRegion out = aIn;
47899:   out.MoveBy(aFromView->GetOffsetTo(aToView));
47899:   out = out.ConvertAppUnitsRoundOut(
47899:     aFromView->GetViewManager()->AppUnitsPerDevPixel(),
47899:     aToView->GetViewManager()->AppUnitsPerDevPixel());
38805:   return out;
    1: }
    1: 
    1: static nsView* GetDisplayRootFor(nsView* aView)
    1: {
    1:   nsView *displayRoot = aView;
    1:   for (;;) {
    1:     nsView *displayParent = displayRoot->GetParent();
    1:     if (!displayParent)
    1:       return displayRoot;
    1: 
    1:     if (displayRoot->GetFloating() && !displayParent->GetFloating())
    1:       return displayRoot;
    1:     displayRoot = displayParent;
    1:   }
    1: }
    1: 
    1: /**
    1:    aRegion is given in device coordinates!!
38805:    aContext may be null, in which case layers should be used for
38805:    rendering.
    1: */
38805: void nsViewManager::Refresh(nsView *aView, nsIWidget *aWidget,
38805:                             const nsIntRegion& aRegion,
38805:                             PRUint32 aUpdateFlags)
    1: {
47899:   NS_ASSERTION(aView == nsView::GetViewFor(aWidget), "view widget mismatch");
47899:   NS_ASSERTION(aView->GetViewManager() == this, "wrong view manager");
47899: 
    1:   if (! IsRefreshEnabled())
    1:     return;
    1: 
    1:   // damageRegion is the damaged area, in twips, relative to the view origin
47899:   nsRegion damageRegion = aRegion.ToAppUnits(AppUnitsPerDevPixel());
38805:   // move region from widget coordinates into view coordinates
47899:   damageRegion.MoveBy(-aView->ViewToWidgetOffset());
    1: 
    1:   if (damageRegion.IsEmpty()) {
    1: #ifdef DEBUG_roc
47899:     nsRect viewRect;
47899:     aView->GetDimensions(viewRect);
    1:     nsRect damageRect = damageRegion.GetBounds();
    1:     printf("XXX Damage rectangle (%d,%d,%d,%d) does not intersect the widget's view (%d,%d,%d,%d)!\n",
    1:            damageRect.x, damageRect.y, damageRect.width, damageRect.height,
    1:            viewRect.x, viewRect.y, viewRect.width, viewRect.height);
    1: #endif
    1:     return;
    1:   }
    1: 
    1:   NS_ASSERTION(!IsPainting(), "recursive painting not permitted");
    1:   if (IsPainting()) {
    1:     RootViewManager()->mRecursiveRefreshPending = PR_TRUE;
    1:     return;
    1:   }  
13098: 
13098:   {
34893:     nsAutoScriptBlocker scriptBlocker;
    1:     SetPainting(PR_TRUE);
    1: 
47899:     RenderViews(aView, aWidget, damageRegion, aRegion, PR_FALSE, PR_FALSE);
    1: 
    1:     SetPainting(PR_FALSE);
13098:   }
    1: 
    1:   if (RootViewManager()->mRecursiveRefreshPending) {
    1:     // Unset this flag first, since if aUpdateFlags includes NS_VMREFRESH_IMMEDIATE
    1:     // we'll reenter this code from the UpdateAllViews call.
    1:     RootViewManager()->mRecursiveRefreshPending = PR_FALSE;
    1:     UpdateAllViews(aUpdateFlags);
    1:   }
    1: }
    1: 
16082: // aRC and aRegion are in view coordinates
38805: void nsViewManager::RenderViews(nsView *aView, nsIWidget *aWidget,
47899:                                 const nsRegion& aRegion,
47899:                                 const nsIntRegion& aIntRegion,
47899:                                 PRBool aPaintDefaultBackground,
47899:                                 PRBool aWillSendDidPaint)
    1: {
26953:   nsView* displayRoot = GetDisplayRootFor(aView);
26953:   // Make sure we call Paint from the view manager that owns displayRoot.
26953:   // (Bug 485275)
26953:   nsViewManager* displayRootVM = displayRoot->GetViewManager();
38805:   if (displayRootVM && displayRootVM != this) {
47899:     displayRootVM->
47899:       RenderViews(aView, aWidget, aRegion, aIntRegion, aPaintDefaultBackground,
47899:                   aWillSendDidPaint);
38805:     return;
38805:   }
26953: 
    1:   if (mObserver) {
47899:     nsRegion region = ConvertRegionBetweenViews(aRegion, aView, displayRoot);
47899:     mObserver->Paint(displayRoot, aView, aWidget, region, aIntRegion,
47899:                      aPaintDefaultBackground, aWillSendDidPaint);
    1:   }
    1: }
    1: 
    1: void nsViewManager::ProcessPendingUpdates(nsView* aView, PRBool aDoInvalidate)
    1: {
    1:   NS_ASSERTION(IsRootVM(), "Updates will be missed");
    1: 
    1:   // Protect against a null-view.
    1:   if (!aView) {
    1:     return;
    1:   }
    1: 
    1:   if (aView->HasWidget()) {
    1:     aView->ResetWidgetBounds(PR_FALSE, PR_FALSE, PR_TRUE);
    1:   }
    1: 
    1:   // process pending updates in child view.
    1:   for (nsView* childView = aView->GetFirstChild(); childView;
    1:        childView = childView->GetNextSibling()) {
    1:     ProcessPendingUpdates(childView, aDoInvalidate);
    1:   }
    1: 
    1:   if (aDoInvalidate && aView->HasNonEmptyDirtyRegion()) {
    1:     // Push out updates after we've processed the children; ensures that
    1:     // damage is applied based on the final widget geometry
38273:     NS_ASSERTION(IsRefreshEnabled(), "Cannot process pending updates with refresh disabled");
    1:     nsRegion* dirtyRegion = aView->GetDirtyRegion();
    1:     if (dirtyRegion) {
30522:       nsView* nearestViewWithWidget = aView;
30522:       while (!nearestViewWithWidget->HasWidget() &&
30522:              nearestViewWithWidget->GetParent()) {
47899:         nearestViewWithWidget = nearestViewWithWidget->GetParent();
30522:       }
47899:       nsRegion r =
47899:         ConvertRegionBetweenViews(*dirtyRegion, aView, nearestViewWithWidget);
47149:       nsViewManager* widgetVM = nearestViewWithWidget->GetViewManager();
47149:       widgetVM->
30522:         UpdateWidgetArea(nearestViewWithWidget,
30523:                          nearestViewWithWidget->GetWidget(), r, nsnull);
    1:       dirtyRegion->SetEmpty();
    1:     }
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::Composite()
    1: {
    1:   if (!IsRootVM()) {
    1:     return RootViewManager()->Composite();
    1:   }
31701: #ifndef MOZ_GFX_OPTIMIZE_MOBILE  
    1:   if (UpdateCount() > 0)
31701: #endif
    1:     {
    1:       ForceUpdate();
    1:       ClearUpdateCount();
    1:     }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::UpdateView(nsIView *aView, PRUint32 aUpdateFlags)
    1: {
    1:   // Mark the entire view as damaged
 3233:   nsView* view = static_cast<nsView*>(aView);
    1: 
47897:   nsRect dims = view->GetDimensions();
47897:   return UpdateView(view, dims, aUpdateFlags);
    1: }
    1: 
30522: static PRBool
30522: IsWidgetDrawnByPlugin(nsIWidget* aWidget, nsIView* aView)
30522: {
30522:   if (aView->GetWidget() == aWidget)
30522:     return PR_FALSE;
30522:   nsCOMPtr<nsIPluginWidget> pw = do_QueryInterface(aWidget);
30522:   if (pw) {
30522:     // It's a plugin widget, but one that we are responsible for painting
30522:     // (i.e., a Mac widget)
30522:     return PR_FALSE;
30522:   }
30522:   return PR_TRUE;
30522: }
30522: 
    1: /**
30522:  * @param aWidget the widget for aWidgetView; in some cases the widget
30522:  * is being managed directly by the frame system, so aWidgetView->GetWidget()
30522:  * will return null but nsView::GetViewFor(aWidget) returns aWidgetview
    1:  * @param aDamagedRegion this region, relative to aWidgetView, is invalidated in
    1:  * every widget child of aWidgetView, plus aWidgetView's own widget
    1:  * @param aIgnoreWidgetView if non-null, the aIgnoreWidgetView's widget and its
    1:  * children are not updated.
    1:  */
    1: void
30522: nsViewManager::UpdateWidgetArea(nsView *aWidgetView, nsIWidget* aWidget,
30522:                                 const nsRegion &aDamagedRegion,
    1:                                 nsView* aIgnoreWidgetView)
    1: {
47899:   NS_ASSERTION(aWidgetView->GetViewManager() == this,
47899:                "UpdateWidgetArea called on view we don't own");
47899: 
46193: #if 0
46193:   nsRect dbgBounds = aDamagedRegion.GetBounds();
46193:   printf("UpdateWidgetArea view:%X (%d) widget:%X region: %d, %d, %d, %d\n",
46193:     aWidgetView, aWidgetView->IsAttachedToTopLevel(),
46193:     aWidget, dbgBounds.x, dbgBounds.y, dbgBounds.width, dbgBounds.height);
46193: #endif
46193: 
    1:   if (!IsRefreshEnabled()) {
    1:     // accumulate this rectangle in the view's dirty region, so we can
    1:     // process it later.
    1:     nsRegion* dirtyRegion = aWidgetView->GetDirtyRegion();
    1:     if (!dirtyRegion) return;
    1: 
    1:     dirtyRegion->Or(*dirtyRegion, aDamagedRegion);
    1:     // Don't let dirtyRegion grow beyond 8 rects
    1:     dirtyRegion->SimplifyOutward(8);
    1:     nsViewManager* rootVM = RootViewManager();
    1:     rootVM->mHasPendingUpdates = PR_TRUE;
    1:     rootVM->IncrementUpdateCount();
    1:     return;
    1:     // this should only happen at the top level, and this result
    1:     // should not be consumed by top-level callers, so it doesn't
    1:     // really matter what we return
    1:   }
    1: 
    1:   // If the bounds don't overlap at all, there's nothing to do
    1:   nsRegion intersection;
    1:   intersection.And(aWidgetView->GetDimensions(), aDamagedRegion);
    1:   if (intersection.IsEmpty()) {
    1:     return;
    1:   }
    1: 
    1:   // If the widget is hidden, it don't cover nothing
30522:   if (aWidget) {
    1:     PRBool visible;
30522:     aWidget->IsVisible(visible);
30687:     if (!visible)
    1:       return;
    1:   }
    1: 
    1:   if (aWidgetView == aIgnoreWidgetView) {
    1:     // the widget for aIgnoreWidgetView (and its children) should be treated as already updated.
    1:     return;
    1:   }
    1: 
30522:   if (!aWidget) {
    1:     // The root view or a scrolling view might not have a widget
    1:     // (for example, during printing). We get here when we scroll
    1:     // during printing to show selected options in a listbox, for example.
    1:     return;
    1:   }
    1: 
    1:   // Update all child widgets with the damage. In the process,
    1:   // accumulate the union of all the child widget areas, or at least
    1:   // some subset of that.
    1:   nsRegion children;
30522:   if (aWidget->GetTransparencyMode() != eTransparencyTransparent) {
30522:     for (nsIWidget* childWidget = aWidget->GetFirstChild();
    1:          childWidget;
    1:          childWidget = childWidget->GetNextSibling()) {
    1:       nsView* view = nsView::GetViewFor(childWidget);
    1:       NS_ASSERTION(view != aWidgetView, "will recur infinitely");
30522:       PRBool visible;
30522:       childWidget->IsVisible(visible);
30522:       if (view && visible && !IsWidgetDrawnByPlugin(childWidget, view)) {
    1:         // Don't mess with views that are in completely different view
    1:         // manager trees
47149:         nsViewManager* viewManager = view->GetViewManager();
47149:         if (viewManager->RootViewManager() == RootViewManager()) {
47899:           // get the damage region into view's coordinate system and appunits
47899:           nsRegion damage =
47899:             ConvertRegionBetweenViews(intersection, aWidgetView, view);
46193: 
46193:           // Update the child and it's children
47149:           viewManager->
30522:             UpdateWidgetArea(view, childWidget, damage, aIgnoreWidgetView);
30515: 
46193:           // GetBounds should compensate for chrome on a toplevel widget
30515:           nsIntRect bounds;
30515:           childWidget->GetBounds(bounds);
46193: 
30515:           nsTArray<nsIntRect> clipRects;
30515:           childWidget->GetWindowClipRegion(&clipRects);
30515:           for (PRUint32 i = 0; i < clipRects.Length(); ++i) {
30515:             nsRect rr = (clipRects[i] + bounds.TopLeft()).
43141:               ToAppUnits(AppUnitsPerDevPixel());
30515:             children.Or(children, rr - aWidgetView->ViewToWidgetOffset()); 
    1:             children.SimplifyInward(20);
    1:           }
    1:         }
    1:       }
25427:     }
30515:   }
    1: 
    1:   nsRegion leftOver;
    1:   leftOver.Sub(intersection, children);
    1: 
    1:   if (!leftOver.IsEmpty()) {
    1:     NS_ASSERTION(IsRefreshEnabled(), "Can only get here with refresh enabled, I hope");
    1: 
    1:     const nsRect* r;
    1:     for (nsRegionRectIterator iter(leftOver); (r = iter.Next());) {
47149:       nsIntRect bounds = ViewToWidget(aWidgetView, *r);
30522:       aWidget->Invalidate(bounds, PR_FALSE);
    1:     }
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::UpdateView(nsIView *aView, const nsRect &aRect, PRUint32 aUpdateFlags)
    1: {
    1:   NS_PRECONDITION(nsnull != aView, "null view");
    1: 
 3233:   nsView* view = static_cast<nsView*>(aView);
    1: 
47897:   NS_ASSERTION(view->GetViewManager() == this,
47897:                "UpdateView called on view we don't own");
47897: 
    1:   nsRect damagedRect(aRect);
37073:   if (damagedRect.IsEmpty()) {
    1:     return NS_OK;
    1:   }
    1: 
21941:   nsView* displayRoot = GetDisplayRootFor(view);
47149:   nsViewManager* displayRootVM = displayRoot->GetViewManager();
21941:   // Propagate the update to the displayRoot, since iframes, for example,
21941:   // can overlap each other and be translucent.  So we have to possibly
21941:   // invalidate our rect in each of the widgets we have lying about.
21941:   damagedRect.MoveBy(view->GetOffsetTo(displayRoot));
47897:   PRInt32 rootAPD = displayRootVM->AppUnitsPerDevPixel();
47897:   PRInt32 APD = AppUnitsPerDevPixel();
47897:   damagedRect = damagedRect.ConvertAppUnitsRoundOut(APD, rootAPD);
47149:   displayRootVM->UpdateWidgetArea(displayRoot, displayRoot->GetWidget(),
30522:                                   nsRegion(damagedRect), nsnull);
    1: 
    1:   RootViewManager()->IncrementUpdateCount();
    1: 
    1:   if (!IsRefreshEnabled()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // See if we should do an immediate refresh or wait
    1:   if (aUpdateFlags & NS_VMREFRESH_IMMEDIATE) {
    1:     Composite();
    1:   } 
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::UpdateAllViews(PRUint32 aUpdateFlags)
    1: {
    1:   if (RootViewManager() != this) {
    1:     return RootViewManager()->UpdateAllViews(aUpdateFlags);
    1:   }
    1:   
    1:   UpdateViews(mRootView, aUpdateFlags);
    1:   return NS_OK;
    1: }
    1: 
    1: void nsViewManager::UpdateViews(nsView *aView, PRUint32 aUpdateFlags)
    1: {
    1:   // update this view.
    1:   UpdateView(aView, aUpdateFlags);
    1: 
    1:   // update all children as well.
    1:   nsView* childView = aView->GetFirstChild();
    1:   while (nsnull != childView)  {
47897:     childView->GetViewManager()->UpdateViews(childView, aUpdateFlags);
    1:     childView = childView->GetNextSibling();
    1:   }
    1: }
    1: 
30521: NS_IMETHODIMP nsViewManager::DispatchEvent(nsGUIEvent *aEvent,
30521:                                            nsIView* aView, nsEventStatus *aStatus)
    1: {
47899:   NS_ASSERTION(!aView || static_cast<nsView*>(aView)->GetViewManager() == this,
47899:                "wrong view manager");
47899: 
    1:   *aStatus = nsEventStatus_eIgnore;
    1: 
    1:   switch(aEvent->message)
    1:     {
    1:     case NS_SIZE:
    1:       {
30521:         if (aView)
    1:           {
46193:             // client area dimensions are set on the view
    1:             nscoord width = ((nsSizeEvent*)aEvent)->windowSize->width;
    1:             nscoord height = ((nsSizeEvent*)aEvent)->windowSize->height;
    1: 
    1:             // The root view may not be set if this is the resize associated with
    1:             // window creation
    1: 
30521:             if (aView == mRootView)
    1:               {
43141:                 PRInt32 p2a = AppUnitsPerDevPixel();
    1:                 SetWindowDimensions(NSIntPixelsToAppUnits(width, p2a),
    1:                                     NSIntPixelsToAppUnits(height, p2a));
    1:                 *aStatus = nsEventStatus_eConsumeNoDefault;
    1:               }
    1:           }
    1: 
    1:         break;
    1:       }
    1: 
34856:     case NS_WILL_PAINT:
    1:     case NS_PAINT:
    1:       {
 3233:         nsPaintEvent *event = static_cast<nsPaintEvent*>(aEvent);
    1: 
30521:         if (!aView || !mContext)
    1:           break;
    1: 
    1:         *aStatus = nsEventStatus_eConsumeNoDefault;
    1: 
38805:         if (aEvent->message == NS_PAINT && event->region.IsEmpty())
38805:           break;
38805: 
47899:         NS_ASSERTION(static_cast<nsView*>(aView) ==
47899:                        nsView::GetViewFor(event->widget),
47899:                      "view/widget mismatch");
47899: 
47899:         // The region is in device units, and it's in the coordinate space of
47899:         // its associated widget.
    1: 
    1:         // Refresh the view
    1:         if (IsRefreshEnabled()) {
37088:           nsRefPtr<nsViewManager> rootVM = RootViewManager();
37088: 
    1:           // If an ancestor widget was hidden and then shown, we could
    1:           // have a delayed resize to handle.
    1:           PRBool didResize = PR_FALSE;
    1:           for (nsViewManager *vm = this; vm;
    1:                vm = vm->mRootView->GetParent()
    1:                       ? vm->mRootView->GetParent()->GetViewManager()
    1:                       : nsnull) {
    1:             if (vm->mDelayedResize != nsSize(NSCOORD_NONE, NSCOORD_NONE) &&
    1:                 IsViewVisible(vm->mRootView)) {
19013:               vm->FlushDelayedResize();
    1: 
    1:               // Paint later.
    1:               vm->UpdateView(vm->mRootView, NS_VMREFRESH_NO_SYNC);
    1:               didResize = PR_TRUE;
    1: 
    1:               // not sure if it's valid for us to claim that we
    1:               // ignored this, but we're going to do so anyway, since
    1:               // we didn't actually paint anything
    1:               *aStatus = nsEventStatus_eIgnore;
    1:             }
    1:           }
    1: 
    1:           if (!didResize) {
    1:             //NS_ASSERTION(IsViewVisible(view), "painting an invisible view");
    1: 
33904:             // Notify view observers that we're about to paint.
33904:             // Make sure to not send WillPaint notifications while scrolling.
    1: 
30536:             nsCOMPtr<nsIWidget> widget;
30536:             rootVM->GetRootWidget(getter_AddRefs(widget));
 9499:             PRBool transparentWindow = PR_FALSE;
    1:             if (widget)
16601:                 transparentWindow = widget->GetTransparencyMode() == eTransparencyTransparent;
    1: 
30521:             nsView* view = static_cast<nsView*>(aView);
47755:             if (!transparentWindow) {
    1:               nsIViewObserver* observer = GetViewObserver();
    1:               if (observer) {
    1:                 // Do an update view batch.  Make sure not to do it DEFERRED,
    1:                 // since that would effectively delay any invalidates that are
    1:                 // triggered by the WillPaint notification (they'd happen when
    1:                 // the invalid event fires, which is later than the reflow
    1:                 // event would fire and could end up being after some timer
    1:                 // events, leading to frame dropping in DHTML).  Note that the
    1:                 // observer may try to reenter this code from inside
    1:                 // WillPaint() by trying to do a synchronous paint, but since
    1:                 // refresh will be disabled it won't be able to do the paint.
    1:                 // We should really sort out the rules on our synch painting
    1:                 // api....
10730:                 UpdateViewBatch batch(this);
47756:                 rootVM->CallWillPaintOnObservers(event->willSendDidPaint);
10730:                 batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
  919: 
  919:                 // Get the view pointer again since the code above might have
  919:                 // destroyed it (bug 378273).
  919:                 view = nsView::GetViewFor(aEvent->widget);
    1:               }
    1:             }
    1:             // Make sure to sync up any widget geometry changes we
    1:             // have pending before we paint.
    1:             if (rootVM->mHasPendingUpdates) {
    1:               rootVM->ProcessPendingUpdates(mRootView, PR_FALSE);
    1:             }
  919:             
34856:             if (view && aEvent->message == NS_PAINT) {
38805:               Refresh(view, event->widget,
38805:                       event->region, NS_VMREFRESH_DOUBLE_BUFFER);
    1:             }
  919:           }
34856:         } else if (aEvent->message == NS_PAINT) {
    1:           // since we got an NS_PAINT event, we need to
25385:           // draw something so we don't get blank areas,
25385:           // unless there's no widget or it's transparent.
47899:           nsRegion rgn = event->region.ToAppUnits(AppUnitsPerDevPixel());
47899:           rgn.MoveBy(-aView->ViewToWidgetOffset());
47899:           RenderViews(static_cast<nsView*>(aView), event->widget, rgn,
47899:                       event->region, PR_TRUE, event->willSendDidPaint);
    1:           // Clients like the editor can trigger multiple
    1:           // reflows during what the user perceives as a single
    1:           // edit operation, so it disables view manager
    1:           // refreshing until the edit operation is complete
    1:           // so that users don't see the intermediate steps.
    1:           // 
    1:           // Unfortunately some of these reflows can trigger
    1:           // nsScrollPortView and nsScrollingView Scroll() calls
    1:           // which in most cases force an immediate BitBlt and
    1:           // synchronous paint to happen even if the view manager's
    1:           // refresh is disabled. (Bug 97674)
    1:           //
    1:           // Calling UpdateView() here, is necessary to add
    1:           // the exposed region specified in the synchronous paint
    1:           // event to  the view's damaged region so that it gets
    1:           // painted properly when refresh is enabled.
    1:           //
    1:           // Note that calling UpdateView() here was deemed
    1:           // to have the least impact on performance, since the
    1:           // other alternative was to make Scroll() post an
    1:           // async paint event for the *entire* ScrollPort or
    1:           // ScrollingView's viewable area. (See bug 97674 for this
    1:           // alternate patch.)
    1: 
38805:           UpdateView(aView, rgn.GetBounds(), NS_VMREFRESH_NO_SYNC);
    1:         }
    1: 
    1:         break;
    1:       }
    1: 
47756:     case NS_DID_PAINT: {
47756:       nsRefPtr<nsViewManager> rootVM = RootViewManager();
47756:       rootVM->CallDidPaintOnObservers();
47756:       break;
47756:     }
47756: 
    1:     case NS_CREATE:
    1:     case NS_DESTROY:
    1:     case NS_SETZLEVEL:
    1:     case NS_MOVE:
    1:       /* Don't pass these events through. Passing them through
    1:          causes performance problems on pages with lots of views/frames 
    1:          @see bug 112861 */
    1:       *aStatus = nsEventStatus_eConsumeNoDefault;
    1:       break;
    1: 
    1: 
    1:     case NS_DISPLAYCHANGED:
    1: 
    1:       //Destroy the cached backbuffer to force a new backbuffer
    1:       //be constructed with the appropriate display depth.
    1:       //@see bugzilla bug 6061
    1:       *aStatus = nsEventStatus_eConsumeDoDefault;
    1:       break;
    1: 
    1:     case NS_SYSCOLORCHANGED:
    1:       {
    1:         // Hold a refcount to the observer. The continued existence of the observer will
    1:         // delay deletion of this view hierarchy should the event want to cause its
    1:         // destruction in, say, some JavaScript event handler.
    1:         nsCOMPtr<nsIViewObserver> obs = GetViewObserver();
    1:         if (obs) {
30521:           obs->HandleEvent(aView, aEvent, aStatus);
    1:         }
    1:       }
    1:       break; 
    1: 
    1:     default:
    1:       {
    1:         if ((NS_IS_MOUSE_EVENT(aEvent) &&
39761:              // Ignore mouse events that we synthesize.
 3233:              static_cast<nsMouseEvent*>(aEvent)->reason ==
    1:                nsMouseEvent::eReal &&
    1:              // Ignore mouse exit and enter (we'll get moves if the user
    1:              // is really moving the mouse) since we get them when we
    1:              // create and destroy widgets.
    1:              aEvent->message != NS_MOUSE_EXIT &&
    1:              aEvent->message != NS_MOUSE_ENTER) ||
    1:             NS_IS_KEY_EVENT(aEvent) ||
22788:             NS_IS_IME_EVENT(aEvent) ||
41061:             NS_IS_PLUGIN_EVENT(aEvent) ||
41061:             NS_IS_NON_RETARGETED_PLUGIN_EVENT(aEvent)) {
    1:           gLastUserEventTime = PR_IntervalToMicroseconds(PR_IntervalNow());
    1:         }
    1: 
    1:         if (aEvent->message == NS_DEACTIVATE) {
32435:           // if a window is deactivated, clear the mouse capture regardless
32435:           // of what is capturing
32435:           nsIViewObserver* viewObserver = GetViewObserver();
32435:           if (viewObserver) {
32435:             viewObserver->ClearMouseCapture(nsnull);
32435:           }
    1:         }
    1: 
    1:         //Find the view whose coordinates system we're in.
30521:         nsView* baseView = static_cast<nsView*>(aView);
    1:         nsView* view = baseView;
    1: 
31218:         if (NS_IsEventUsingCoordinates(aEvent)) {
    1:           // will dispatch using coordinates. Pretty bogus but it's consistent
    1:           // with what presshell does.
    1:           view = GetDisplayRootFor(baseView);
    1:         }
    1: 
    1:         if (nsnull != view) {
47898:           PRInt32 APD = AppUnitsPerDevPixel();
    1: 
    1:           if ((aEvent->message == NS_MOUSE_MOVE &&
 3233:                static_cast<nsMouseEvent*>(aEvent)->reason ==
    1:                  nsMouseEvent::eReal) ||
20986:               aEvent->message == NS_MOUSE_ENTER ||
20986:               aEvent->message == NS_MOUSE_BUTTON_DOWN ||
20986:               aEvent->message == NS_MOUSE_BUTTON_UP) {
47898:             // aEvent->point is relative to the widget, so we convert it to be
47898:             // relative to the view origin
47898:             nsPoint pt = -baseView->ViewToWidgetOffset();
47898:             pt += baseView->GetOffsetTo(RootViewManager()->mRootView);
47898:             pt.x += NSIntPixelsToAppUnits(aEvent->refPoint.x, APD);
47898:             pt.y += NSIntPixelsToAppUnits(aEvent->refPoint.y, APD);
47898:             PRInt32 rootAPD = RootViewManager()->AppUnitsPerDevPixel();
47898:             pt = pt.ConvertAppUnits(APD, rootAPD);
47898:             RootViewManager()->mMouseLocation = pt;
    1: #ifdef DEBUG_MOUSE_LOCATION
    1:             if (aEvent->message == NS_MOUSE_ENTER)
    1:               printf("[vm=%p]got mouse enter for %p\n",
    1:                      this, aEvent->widget);
    1:             printf("[vm=%p]setting mouse location to (%d,%d)\n",
    1:                    this, mMouseLocation.x, mMouseLocation.y);
    1: #endif
    1:             if (aEvent->message == NS_MOUSE_ENTER)
    1:               SynthesizeMouseMove(PR_FALSE);
    1:           } else if (aEvent->message == NS_MOUSE_EXIT) {
    1:             // Although we only care about the mouse moving into an area
    1:             // for which this view manager doesn't receive mouse move
    1:             // events, we don't check which view the mouse exit was for
    1:             // since this seems to vary by platform.  Hopefully this
    1:             // won't matter at all since we'll get the mouse move or
    1:             // enter after the mouse exit when the mouse moves from one
    1:             // of our widgets into another.
47898:             RootViewManager()->mMouseLocation =
47898:               nsPoint(NSCOORD_NONE, NSCOORD_NONE);
    1: #ifdef DEBUG_MOUSE_LOCATION
    1:             printf("[vm=%p]got mouse exit for %p\n",
    1:                    this, aEvent->widget);
    1:             printf("[vm=%p]clearing mouse location\n",
    1:                    this);
    1: #endif
    1:           }
    1: 
43139:           *aStatus = HandleEvent(view, aEvent);
    1:         }
    1:     
    1:         break;
    1:       }
    1:     }
    1: 
    1:   return NS_OK;
    1: }
    1: 
43139: nsEventStatus nsViewManager::HandleEvent(nsView* aView, nsGUIEvent* aEvent)
43139: {
46193: #if 0
46193:   printf(" %d %d %d %d (%d,%d) \n", this, event->widget, event->widgetSupports, 
46193:          event->message, event->point.x, event->point.y);
46193: #endif
    1:   // Hold a refcount to the observer. The continued existence of the observer will
    1:   // delay deletion of this view hierarchy should the event want to cause its
    1:   // destruction in, say, some JavaScript event handler.
    1:   nsCOMPtr<nsIViewObserver> obs = aView->GetViewManager()->GetViewObserver();
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   if (obs) {
    1:      obs->HandleEvent(aView, aEvent, &status);
    1:   }
    1: 
    1:   return status;
    1: }
    1: 
    1: // Recursively reparent widgets if necessary 
    1: 
    1: void nsViewManager::ReparentChildWidgets(nsIView* aView, nsIWidget *aNewWidget)
    1: {
    1:   if (aView->HasWidget()) {
    1:     // Check to see if the parent widget is the
    1:     // same as the new parent. If not then reparent
    1:     // the widget, otherwise there is nothing more
    1:     // to do for the view and its descendants
    1:     nsIWidget* widget = aView->GetWidget();
    1:     nsIWidget* parentWidget = widget->GetParent();
14467:     // Toplevel widgets should not be reparented!
14467:     if (parentWidget && parentWidget != aNewWidget) {
    1: #ifdef DEBUG
    1:       nsresult rv =
    1: #endif
    1:         widget->SetParent(aNewWidget);
    1:       NS_ASSERTION(NS_SUCCEEDED(rv), "SetParent failed!");
    1:     }
    1:     return;
    1:   }
    1: 
    1:   // Need to check each of the views children to see
    1:   // if they have a widget and reparent it.
    1: 
 3233:   nsView* view = static_cast<nsView*>(aView);
    1:   for (nsView *kid = view->GetFirstChild(); kid; kid = kid->GetNextSibling()) {
    1:     ReparentChildWidgets(kid, aNewWidget);
    1:   }
    1: }
    1: 
    1: // Reparent a view and its descendant views widgets if necessary
    1: 
    1: void nsViewManager::ReparentWidgets(nsIView* aView, nsIView *aParent)
    1: {
    1:   NS_PRECONDITION(aParent, "Must have a parent");
    1:   NS_PRECONDITION(aView, "Must have a view");
    1:   
    1:   // Quickly determine whether the view has pre-existing children or a
    1:   // widget. In most cases the view will not have any pre-existing 
    1:   // children when this is called.  Only in the case
    1:   // where a view has been reparented by removing it from
    1:   // a reinserting it into a new location in the view hierarchy do we
    1:   // have to consider reparenting the existing widgets for the view and
    1:   // it's descendants.
 3233:   nsView* view = static_cast<nsView*>(aView);
    1:   if (view->HasWidget() || view->GetFirstChild()) {
    1:     nsIWidget* parentWidget = aParent->GetNearestWidget(nsnull);
    1:     if (parentWidget) {
    1:       ReparentChildWidgets(aView, parentWidget);
    1:       return;
    1:     }
    1:     NS_WARNING("Can not find a widget for the parent view");
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::InsertChild(nsIView *aParent, nsIView *aChild, nsIView *aSibling,
    1:                                          PRBool aAfter)
    1: {
 3233:   nsView* parent = static_cast<nsView*>(aParent);
 3233:   nsView* child = static_cast<nsView*>(aChild);
 3233:   nsView* sibling = static_cast<nsView*>(aSibling);
    1:   
    1:   NS_PRECONDITION(nsnull != parent, "null ptr");
    1:   NS_PRECONDITION(nsnull != child, "null ptr");
    1:   NS_ASSERTION(sibling == nsnull || sibling->GetParent() == parent,
    1:                "tried to insert view with invalid sibling");
    1:   NS_ASSERTION(!IsViewInserted(child), "tried to insert an already-inserted view");
    1: 
    1:   if ((nsnull != parent) && (nsnull != child))
    1:     {
    1:       // if aAfter is set, we will insert the child after 'prev' (i.e. after 'kid' in document
    1:       // order, otherwise after 'kid' (i.e. before 'kid' in document order).
    1: 
    1: #if 1
    1:       if (nsnull == aSibling) {
    1:         if (aAfter) {
    1:           // insert at end of document order, i.e., before first view
    1:           // this is the common case, by far
    1:           parent->InsertChild(child, nsnull);
    1:           ReparentWidgets(child, parent);
    1:         } else {
    1:           // insert at beginning of document order, i.e., after last view
    1:           nsView *kid = parent->GetFirstChild();
    1:           nsView *prev = nsnull;
    1:           while (kid) {
    1:             prev = kid;
    1:             kid = kid->GetNextSibling();
    1:           }
    1:           // prev is last view or null if there are no children
    1:           parent->InsertChild(child, prev);
    1:           ReparentWidgets(child, parent);
    1:         }
    1:       } else {
    1:         nsView *kid = parent->GetFirstChild();
    1:         nsView *prev = nsnull;
    1:         while (kid && sibling != kid) {
    1:           //get the next sibling view
    1:           prev = kid;
    1:           kid = kid->GetNextSibling();
    1:         }
    1:         NS_ASSERTION(kid != nsnull,
    1:                      "couldn't find sibling in child list");
    1:         if (aAfter) {
    1:           // insert after 'kid' in document order, i.e. before in view order
    1:           parent->InsertChild(child, prev);
    1:           ReparentWidgets(child, parent);
    1:         } else {
    1:           // insert before 'kid' in document order, i.e. after in view order
    1:           parent->InsertChild(child, kid);
    1:           ReparentWidgets(child, parent);
    1:         }
    1:       }
    1: #else // don't keep consistent document order, but order things by z-index instead
    1:       // essentially we're emulating the old InsertChild(parent, child, zindex)
    1:       PRInt32 zIndex = child->GetZIndex();
    1:       while (nsnull != kid)
    1:         {
    1:           PRInt32 idx = kid->GetZIndex();
    1: 
    1:           if (CompareZIndex(zIndex, child->IsTopMost(), child->GetZIndexIsAuto(),
    1:                             idx, kid->IsTopMost(), kid->GetZIndexIsAuto()) >= 0)
    1:             break;
    1: 
    1:           prev = kid;
    1:           kid = kid->GetNextSibling();
    1:         }
    1: 
    1:       parent->InsertChild(child, prev);
    1:       ReparentWidgets(child, parent);
    1: #endif
    1: 
    1:       // if the parent view is marked as "floating", make the newly added view float as well.
    1:       if (parent->GetFloating())
    1:         child->SetFloating(PR_TRUE);
    1: 
    1:       //and mark this area as dirty if the view is visible...
    1: 
    1:       if (nsViewVisibility_kHide != child->GetVisibility())
47897:         child->GetViewManager()->UpdateView(child, NS_VMREFRESH_NO_SYNC);
    1:     }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::InsertChild(nsIView *aParent, nsIView *aChild, PRInt32 aZIndex)
    1: {
    1:   // no-one really calls this with anything other than aZIndex == 0 on a fresh view
    1:   // XXX this method should simply be eliminated and its callers redirected to the real method
    1:   SetViewZIndex(aChild, PR_FALSE, aZIndex, PR_FALSE);
    1:   return InsertChild(aParent, aChild, nsnull, PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::RemoveChild(nsIView *aChild)
    1: {
 3233:   nsView* child = static_cast<nsView*>(aChild);
    1:   NS_ENSURE_ARG_POINTER(child);
    1: 
    1:   nsView* parent = child->GetParent();
    1: 
47897:   if (nsnull != parent) {
47897:     NS_ASSERTION(child->GetViewManager() == this ||
47897:                  parent->GetViewManager() == this, "wrong view manager");
47897:     child->GetViewManager()->UpdateView(child, NS_VMREFRESH_NO_SYNC);
    1:     parent->RemoveChild(child);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::MoveViewTo(nsIView *aView, nscoord aX, nscoord aY)
    1: {
 3233:   nsView* view = static_cast<nsView*>(aView);
47897:   NS_ASSERTION(view->GetViewManager() == this, "wrong view manager");
    1:   nsPoint oldPt = view->GetPosition();
47897:   nsRect oldBounds = view->GetBoundsInParentUnits();
    1:   view->SetPosition(aX, aY);
    1: 
    1:   // only do damage control if the view is visible
    1: 
    1:   if ((aX != oldPt.x) || (aY != oldPt.y)) {
    1:     if (view->GetVisibility() != nsViewVisibility_kHide) {
    1:       nsView* parentView = view->GetParent();
47897:       if (parentView) {
47897:         nsViewManager* parentVM = parentView->GetViewManager();
47897:         parentVM->UpdateView(parentView, oldBounds, NS_VMREFRESH_NO_SYNC);
47897:         parentVM->UpdateView(parentView, view->GetBoundsInParentUnits(),
47897:                              NS_VMREFRESH_NO_SYNC);
47897:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: void nsViewManager::InvalidateHorizontalBandDifference(nsView *aView, const nsRect& aRect, const nsRect& aCutOut,
    1:   PRUint32 aUpdateFlags, nscoord aY1, nscoord aY2, PRBool aInCutOut) {
    1:   nscoord height = aY2 - aY1;
    1:   if (aRect.x < aCutOut.x) {
    1:     nsRect r(aRect.x, aY1, aCutOut.x - aRect.x, height);
    1:     UpdateView(aView, r, aUpdateFlags);
    1:   }
    1:   if (!aInCutOut && aCutOut.x < aCutOut.XMost()) {
    1:     nsRect r(aCutOut.x, aY1, aCutOut.width, height);
    1:     UpdateView(aView, r, aUpdateFlags);
    1:   }
    1:   if (aCutOut.XMost() < aRect.XMost()) {
    1:     nsRect r(aCutOut.XMost(), aY1, aRect.XMost() - aCutOut.XMost(), height);
    1:     UpdateView(aView, r, aUpdateFlags);
    1:   }
    1: }
    1: 
    1: void nsViewManager::InvalidateRectDifference(nsView *aView, const nsRect& aRect, const nsRect& aCutOut,
    1:   PRUint32 aUpdateFlags) {
    1:   if (aRect.y < aCutOut.y) {
    1:     InvalidateHorizontalBandDifference(aView, aRect, aCutOut, aUpdateFlags, aRect.y, aCutOut.y, PR_FALSE);
    1:   }
    1:   if (aCutOut.y < aCutOut.YMost()) {
    1:     InvalidateHorizontalBandDifference(aView, aRect, aCutOut, aUpdateFlags, aCutOut.y, aCutOut.YMost(), PR_TRUE);
    1:   }
    1:   if (aCutOut.YMost() < aRect.YMost()) {
    1:     InvalidateHorizontalBandDifference(aView, aRect, aCutOut, aUpdateFlags, aCutOut.YMost(), aRect.YMost(), PR_FALSE);
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::ResizeView(nsIView *aView, const nsRect &aRect, PRBool aRepaintExposedAreaOnly)
    1: {
 3233:   nsView* view = static_cast<nsView*>(aView);
47897:   NS_ASSERTION(view->GetViewManager() == this, "wrong view manager");
    1:   nsRect oldDimensions;
    1: 
    1:   view->GetDimensions(oldDimensions);
12354:   if (!oldDimensions.IsExactEqual(aRect)) {
    1:     nsView* parentView = view->GetParent();
    1:     if (parentView == nsnull)
    1:       parentView = view;
    1: 
    1:     // resize the view.
    1:     // Prevent Invalidation of hidden views 
    1:     if (view->GetVisibility() == nsViewVisibility_kHide) {  
    1:       view->SetDimensions(aRect, PR_FALSE);
    1:     } else {
47897:       nsRect oldBounds = view->GetBoundsInParentUnits();
47897:       view->SetDimensions(aRect, PR_TRUE);
    1:       if (!aRepaintExposedAreaOnly) {
    1:         //Invalidate the union of the old and new size
    1:         UpdateView(view, aRect, NS_VMREFRESH_NO_SYNC);
47897:         UpdateView(parentView, oldBounds, NS_VMREFRESH_NO_SYNC);
    1:       } else {
    1:         InvalidateRectDifference(view, aRect, oldDimensions, NS_VMREFRESH_NO_SYNC);
47897:         nsRect newBounds = view->GetBoundsInParentUnits();
47897:         InvalidateRectDifference(parentView, oldBounds, newBounds, NS_VMREFRESH_NO_SYNC);
    1:       } 
    1:     }
    1:   }
    1: 
    1:   // Note that if layout resizes the view and the view has a custom clip
    1:   // region set, then we expect layout to update the clip region too. Thus
    1:   // in the case where mClipRect has been optimized away to just be a null
    1:   // pointer, and this resize is implicitly changing the clip rect, it's OK
    1:   // because layout will change it back again if necessary.
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::SetViewFloating(nsIView *aView, PRBool aFloating)
    1: {
 3233:   nsView* view = static_cast<nsView*>(aView);
    1: 
    1:   NS_ASSERTION(!(nsnull == view), "no view");
    1: 
    1:   view->SetFloating(aFloating);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::SetViewVisibility(nsIView *aView, nsViewVisibility aVisible)
    1: {
 3233:   nsView* view = static_cast<nsView*>(aView);
47897:   NS_ASSERTION(view->GetViewManager() == this, "wrong view manager");
    1: 
    1:   if (aVisible != view->GetVisibility()) {
    1:     view->SetVisibility(aVisible);
    1: 
    1:     if (IsViewInserted(view)) {
    1:       if (!view->HasWidget()) {
    1:         if (nsViewVisibility_kHide == aVisible) {
    1:           nsView* parentView = view->GetParent();
    1:           if (parentView) {
47897:             parentView->GetViewManager()->
47897:               UpdateView(parentView, view->GetBoundsInParentUnits(),
47897:                          NS_VMREFRESH_NO_SYNC);
    1:           }
    1:         }
    1:         else {
    1:           UpdateView(view, NS_VMREFRESH_NO_SYNC);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: void nsViewManager::UpdateWidgetsForView(nsView* aView)
    1: {
    1:   NS_PRECONDITION(aView, "Must have view!");
    1: 
34745:   // No point forcing an update if invalidations have been suppressed.
34745:   if (!IsRefreshEnabled())
34745:     return;  
34745: 
22473:   nsWeakView parentWeakView = aView;
    1:   if (aView->HasWidget()) {
22473:     aView->GetWidget()->Update();  // Flushes Layout!
22473:     if (!parentWeakView.IsAlive()) {
22473:       return;
22473:     }
    1:   }
    1: 
22473:   nsView* childView = aView->GetFirstChild();
22473:   while (childView) {
22473:     nsWeakView childWeakView = childView;
    1:     UpdateWidgetsForView(childView);
22473:     if (NS_LIKELY(childWeakView.IsAlive())) {
22473:       childView = childView->GetNextSibling();
22473:     }
22473:     else {
22473:       // The current view was destroyed - restart at the first child if the
22473:       // parent is still alive.
22473:       childView = parentWeakView.IsAlive() ? aView->GetFirstChild() : nsnull;
22473:     }
    1:   }
    1: }
    1: 
    1: PRBool nsViewManager::IsViewInserted(nsView *aView)
    1: {
    1:   if (mRootView == aView) {
    1:     return PR_TRUE;
    1:   } else if (aView->GetParent() == nsnull) {
    1:     return PR_FALSE;
    1:   } else {
    1:     nsView* view = aView->GetParent()->GetFirstChild();
    1:     while (view != nsnull) {
    1:       if (view == aView) {
    1:         return PR_TRUE;
    1:       }        
    1:       view = view->GetNextSibling();
    1:     }
    1:     return PR_FALSE;
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::SetViewZIndex(nsIView *aView, PRBool aAutoZIndex, PRInt32 aZIndex, PRBool aTopMost)
    1: {
 3233:   nsView* view = static_cast<nsView*>(aView);
    1:   nsresult  rv = NS_OK;
    1: 
    1:   NS_ASSERTION((view != nsnull), "no view");
    1: 
    1:   // don't allow the root view's z-index to be changed. It should always be zero.
    1:   // This could be removed and replaced with a style rule, or just removed altogether, with interesting consequences
    1:   if (aView == mRootView) {
    1:     return rv;
    1:   }
    1: 
    1:   PRBool oldTopMost = view->IsTopMost();
    1:   PRBool oldIsAuto = view->GetZIndexIsAuto();
    1: 
    1:   if (aAutoZIndex) {
    1:     aZIndex = 0;
    1:   }
    1: 
    1:   PRInt32 oldidx = view->GetZIndex();
    1:   view->SetZIndex(aAutoZIndex, aZIndex, aTopMost);
    1: 
    1:   if (oldidx != aZIndex || oldTopMost != aTopMost ||
    1:       oldIsAuto != aAutoZIndex) {
    1:     UpdateView(view, NS_VMREFRESH_NO_SYNC);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::SetViewObserver(nsIViewObserver *aObserver)
    1: {
    1:   mObserver = aObserver;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::GetViewObserver(nsIViewObserver *&aObserver)
    1: {
    1:   if (nsnull != mObserver) {
    1:     aObserver = mObserver;
    1:     NS_ADDREF(mObserver);
    1:     return NS_OK;
    1:   } else
    1:     return NS_ERROR_NO_INTERFACE;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::GetDeviceContext(nsIDeviceContext *&aContext)
    1: {
    1:   NS_IF_ADDREF(mContext);
    1:   aContext = mContext;
    1:   return NS_OK;
    1: }
    1: 
38273: void nsViewManager::TriggerRefresh(PRUint32 aUpdateFlags)
    1: {
    1:   if (!IsRootVM()) {
38273:     RootViewManager()->TriggerRefresh(aUpdateFlags);
38273:     return;
    1:   }
    1:   
    1:   if (mUpdateBatchCnt > 0)
38273:     return;
    1: 
    1:   // nested batching can combine IMMEDIATE with DEFERRED. Favour
18948:   // IMMEDIATE over DEFERRED and DEFERRED over NO_SYNC.  We need to
18948:   // check for IMMEDIATE before checking mHasPendingUpdates, because
18948:   // the latter might be false as far as gecko is concerned but the OS
18948:   // might still have queued up expose events that it hasn't sent yet.
    1:   if (aUpdateFlags & NS_VMREFRESH_IMMEDIATE) {
    1:     FlushPendingInvalidates();
    1:     Composite();
18948:   } else if (!mHasPendingUpdates) {
18948:     // Nothing to do
    1:   } else if (aUpdateFlags & NS_VMREFRESH_DEFERRED) {
    1:     PostInvalidateEvent();
    1:   } else { // NO_SYNC
    1:     FlushPendingInvalidates();
    1:   }
    1: }
    1: 
10730: nsIViewManager* nsViewManager::BeginUpdateViewBatch(void)
    1: {
    1:   if (!IsRootVM()) {
    1:     return RootViewManager()->BeginUpdateViewBatch();
    1:   }
    1:   
    1:   if (mUpdateBatchCnt == 0) {
    1:     mUpdateBatchFlags = 0;
    1:   }
    1: 
    1:   ++mUpdateBatchCnt;
    1: 
10730:   return this;
    1: }
    1: 
    1: NS_IMETHODIMP nsViewManager::EndUpdateViewBatch(PRUint32 aUpdateFlags)
    1: {
10730:   NS_ASSERTION(IsRootVM(), "Should only be called on root");
    1:   
    1:   --mUpdateBatchCnt;
    1: 
    1:   NS_ASSERTION(mUpdateBatchCnt >= 0, "Invalid batch count!");
    1: 
    1:   if (mUpdateBatchCnt < 0)
    1:     {
    1:       mUpdateBatchCnt = 0;
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:   mUpdateBatchFlags |= aUpdateFlags;
    1:   if (mUpdateBatchCnt == 0) {
38273:     TriggerRefresh(mUpdateBatchFlags);
    1:   }
    1: 
38273:   return NS_OK;
    1: }
    1: 
30526: NS_IMETHODIMP nsViewManager::GetRootWidget(nsIWidget **aWidget)
30526: {
30526:   if (!mRootView) {
30526:     *aWidget = nsnull;
30526:     return NS_OK;
30526:   }
30526:   if (mRootView->HasWidget()) {
30526:     *aWidget = mRootView->GetWidget();
30526:     NS_ADDREF(*aWidget);
30526:     return NS_OK;
30526:   }
30526:   if (mRootView->GetParent())
30526:     return mRootView->GetParent()->GetViewManager()->GetRootWidget(aWidget);
30526:   *aWidget = nsnull;
30526:   return NS_OK;
30526: }
30526: 
    1: NS_IMETHODIMP nsViewManager::ForceUpdate()
    1: {
    1:   if (!IsRootVM()) {
    1:     return RootViewManager()->ForceUpdate();
    1:   }
    1: 
    1:   // Walk the view tree looking for widgets, and call Update() on each one
10388:   if (mRootView) {
    1:     UpdateWidgetsForView(mRootView);
10388:   }
10388:   
    1:   return NS_OK;
    1: }
    1: 
47149: nsIntRect nsViewManager::ViewToWidget(nsView *aView, const nsRect &aRect) const
    1: {
47149:   NS_ASSERTION(aView->GetViewManager() == this, "wrong view manager");
    1: 
47149:   // intersect aRect with bounds of aView, to prevent generating any illegal rectangles.
47149:   nsRect bounds = aView->GetDimensions();
47149:   nsRect rect;
47149:   rect.IntersectRect(aRect, bounds);
47149: 
    1:   // account for the view's origin not lining up with the widget's
23738:   rect += aView->ViewToWidgetOffset();
 2899: 
    1:   // finally, convert to device coordinates.
43141:   return rect.ToOutsidePixels(AppUnitsPerDevPixel());
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsViewManager::IsPainting(PRBool& aIsPainting)
    1: {
    1:   aIsPainting = IsPainting();
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsViewManager::FlushPendingInvalidates()
    1: {
47756:   NS_ASSERTION(IsRootVM(), "Must be root VM for this to be called!");
    1:   NS_ASSERTION(mUpdateBatchCnt == 0, "Must not be in an update batch!");
46472:   // XXXbz this is probably not quite OK yet, if callers can explicitly
46472:   // DisableRefresh while we have an event posted.
46472:   // NS_ASSERTION(mRefreshEnabled, "How did we get here?");
46472: 
46472:   // Let all the view observers of all viewmanagers in this tree know that
46472:   // we're about to "paint" (this lets them get in their invalidates now so
46472:   // we don't go through two invalidate-processing cycles).
46472:   NS_ASSERTION(gViewManagers, "Better have a viewmanagers array!");
46472: 
46472:   // Disable refresh while we notify our view observers, so that if they do
46472:   // view update batches we don't reenter this code and so that we batch
46472:   // all of them together.  We don't use
46472:   // BeginUpdateViewBatch/EndUpdateViewBatch, since that would reenter this
46472:   // exact code, but we want the effect of a single big update batch.
46472:   ++mUpdateBatchCnt;
47756:   CallWillPaintOnObservers(PR_FALSE);
46472:   --mUpdateBatchCnt;
    1:   
    1:   if (mHasPendingUpdates) {
    1:     ProcessPendingUpdates(mRootView, PR_TRUE);
    1:     mHasPendingUpdates = PR_FALSE;
    1:   }
    1: }
    1: 
    1: void
47756: nsViewManager::CallWillPaintOnObservers(PRBool aWillSendDidPaint)
33904: {
47756:   NS_PRECONDITION(IsRootVM(), "Must be root VM for this to be called!");
33904:   NS_PRECONDITION(mUpdateBatchCnt > 0, "Must be in an update batch!");
33904: 
33904: #ifdef DEBUG
33904:   PRInt32 savedUpdateBatchCnt = mUpdateBatchCnt;
33904: #endif
33904:   PRInt32 index;
33904:   for (index = 0; index < mVMCount; index++) {
33904:     nsViewManager* vm = (nsViewManager*)gViewManagers->ElementAt(index);
33904:     if (vm->RootViewManager() == this) {
33904:       // One of our kids.
33904:       nsCOMPtr<nsIViewObserver> obs = vm->GetViewObserver();
33904:       if (obs) {
47756:         obs->WillPaint(aWillSendDidPaint);
33904:         NS_ASSERTION(mUpdateBatchCnt == savedUpdateBatchCnt,
33904:                      "Observer did not end view batch?");
33904:       }
33904:     }
33904:   }
33904: }
33904: 
33904: void
47756: nsViewManager::CallDidPaintOnObservers()
47756: {
47756:   NS_PRECONDITION(IsRootVM(), "Must be root VM for this to be called!");
47756: 
47756:   PRInt32 index;
47756:   for (index = 0; index < mVMCount; index++) {
47756:     nsViewManager* vm = (nsViewManager*)gViewManagers->ElementAt(index);
47756:     if (vm->RootViewManager() == this) {
47756:       // One of our kids.
47756:       nsCOMPtr<nsIViewObserver> obs = vm->GetViewObserver();
47756:       if (obs) {
47756:         obs->DidPaint();
47756:       }
47756:     }
47756:   }
47756: }
47756: 
47756: void
    1: nsViewManager::ProcessInvalidateEvent()
    1: {
    1:   NS_ASSERTION(IsRootVM(),
    1:                "Incorrectly targeted invalidate event");
    1:   // If we're in the middle of an update batch, just repost the event,
    1:   // to be processed when the batch ends.
    1:   PRBool processEvent = (mUpdateBatchCnt == 0);
    1:   if (processEvent) {
    1:     FlushPendingInvalidates();
    1:   }
    1:   mInvalidateEvent.Forget();
    1:   if (!processEvent) {
    1:     // We didn't actually process this event... post a new one
    1:     PostInvalidateEvent();
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsViewManager::GetLastUserEventTime(PRUint32& aTime)
    1: {
    1:   aTime = gLastUserEventTime;
    1:   return NS_OK;
    1: }
    1: 
    1: class nsSynthMouseMoveEvent : public nsViewManagerEvent {
    1: public:
    1:   nsSynthMouseMoveEvent(nsViewManager *aViewManager,
    1:                         PRBool aFromScroll)
    1:     : nsViewManagerEvent(aViewManager),
    1:       mFromScroll(aFromScroll) {
    1:   }
    1: 
    1:   NS_IMETHOD Run() {
    1:     if (mViewManager)
    1:       mViewManager->ProcessSynthMouseMoveEvent(mFromScroll);
    1:     return NS_OK;
    1:   }
    1: 
    1: private:
    1:   PRBool mFromScroll;
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsViewManager::SynthesizeMouseMove(PRBool aFromScroll)
    1: {
    1:   if (!IsRootVM())
    1:     return RootViewManager()->SynthesizeMouseMove(aFromScroll);
    1: 
47898:   if (mMouseLocation == nsPoint(NSCOORD_NONE, NSCOORD_NONE))
    1:     return NS_OK;
    1: 
    1:   if (!mSynthMouseMoveEvent.IsPending()) {
    1:     nsRefPtr<nsViewManagerEvent> ev =
    1:         new nsSynthMouseMoveEvent(this, aFromScroll);
    1: 
    1:     if (NS_FAILED(NS_DispatchToCurrentThread(ev))) {
    1:       NS_WARNING("failed to dispatch nsSynthMouseMoveEvent");
    1:       return NS_ERROR_UNEXPECTED;
    1:     }
    1: 
    1:     mSynthMouseMoveEvent = ev;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * Find the first floating view with a widget in a postorder traversal of the
    1:  * view tree that contains the point. Thus more deeply nested floating views
    1:  * are preferred over their ancestors, and floating views earlier in the
    1:  * view hierarchy (i.e., added later) are preferred over their siblings.
    1:  * This is adequate for finding the "topmost" floating view under a point,
    1:  * given that floating views don't supporting having a specific z-index.
    1:  * 
    1:  * We cannot exit early when aPt is outside the view bounds, because floating
    1:  * views aren't necessarily included in their parent's bounds, so this could
    1:  * traverse the entire view hierarchy --- use carefully.
    1:  */
    1: static nsView* FindFloatingViewContaining(nsView* aView, nsPoint aPt)
    1: {
22471:   if (aView->GetVisibility() == nsViewVisibility_kHide)
22471:     // No need to look into descendants.
22471:     return nsnull;
22471: 
    1:   for (nsView* v = aView->GetFirstChild(); v; v = v->GetNextSibling()) {
47898:     nsView* r = FindFloatingViewContaining(v, v->ConvertFromParentCoords(aPt));
    1:     if (r)
    1:       return r;
    1:   }
    1: 
    1:   if (aView->GetFloating() && aView->HasWidget() &&
22471:       aView->GetDimensions().Contains(aPt))
    1:     return aView;
    1:     
    1:   return nsnull;
    1: }
    1: 
22471: /*
22471:  * This finds the first view containing the given point in a postorder
22471:  * traversal of the view tree that contains the point, assuming that the
22471:  * point is not in a floating view.  It assumes that only floating views
22471:  * extend outside the bounds of their parents.
22471:  *
22471:  * This methods should only be called if FindFloatingViewContaining
22471:  * returns null.
22471:  */
22471: static nsView* FindViewContaining(nsView* aView, nsPoint aPt)
22471: {
43140:   if (!aView->GetDimensions().Contains(aPt) ||
43140:       aView->GetVisibility() == nsViewVisibility_kHide) {
43140:     return nsnull;
43140:   }
43140: 
22471:   for (nsView* v = aView->GetFirstChild(); v; v = v->GetNextSibling()) {
47898:     nsView* r = FindViewContaining(v, v->ConvertFromParentCoords(aPt));
22471:     if (r)
22471:       return r;
22471:   }
22471: 
43140:   return aView;
22471: }
22471: 
    1: void
    1: nsViewManager::ProcessSynthMouseMoveEvent(PRBool aFromScroll)
    1: {
    1:   // allow new event to be posted while handling this one only if the
    1:   // source of the event is a scroll (to prevent infinite reflow loops)
    1:   if (aFromScroll)
    1:     mSynthMouseMoveEvent.Forget();
    1: 
    1:   NS_ASSERTION(IsRootVM(), "Only the root view manager should be here");
    1: 
47962:   if (mMouseLocation == nsPoint(NSCOORD_NONE, NSCOORD_NONE) || !mRootView ||
47962:       !mRootView->HasWidget()) {
    1:     mSynthMouseMoveEvent.Forget();
    1:     return;
    1:   }
    1: 
    1:   // Hold a ref to ourselves so DispatchEvent won't destroy us (since
    1:   // we need to access members after we call DispatchEvent).
    1:   nsCOMPtr<nsIViewManager> kungFuDeathGrip(this);
    1:   
    1: #ifdef DEBUG_MOUSE_LOCATION
    1:   printf("[vm=%p]synthesizing mouse move to (%d,%d)\n",
    1:          this, mMouseLocation.x, mMouseLocation.y);
    1: #endif
    1: 
47898:   PRInt32 APD = AppUnitsPerDevPixel();
47898: 
47898:   // this will be mMouseLocation relative to the widget of |view|, the widget
47898:   // we will put in the event we dispatch, in viewAPD appunits
47898:   nsPoint refpoint(0, 0);
47898:   PRInt32 viewAPD;
47898:   // the VM of the view the point is in
47898:   nsViewManager *pointVM;
47898: 
    1:   // This could be a bit slow (traverses entire view hierarchy)
    1:   // but it's OK to do it once per synthetic mouse event
47898:   nsView* view = FindFloatingViewContaining(mRootView, mMouseLocation);
    1:   if (!view) {
    1:     view = mRootView;
47898:     nsView *pointView = FindViewContaining(mRootView, mMouseLocation);
22471:     // pointView can be null in situations related to mouse capture
22471:     pointVM = (pointView ? pointView : view)->GetViewManager();
47898:     refpoint = mMouseLocation + mRootView->ViewToWidgetOffset();
47898:     viewAPD = APD;
    1:   } else {
22471:     pointVM = view->GetViewManager();
47898:     viewAPD = pointVM->AppUnitsPerDevPixel();
47898:     refpoint = mMouseLocation.ConvertAppUnits(APD, viewAPD);
47898:     refpoint -= view->GetOffsetTo(mRootView);
47898:     refpoint += view->ViewToWidgetOffset();
    1:   }
47898:   NS_ASSERTION(view->GetWidget(), "view should have a widget here");
    1:   nsMouseEvent event(PR_TRUE, NS_MOUSE_MOVE, view->GetWidget(),
    1:                      nsMouseEvent::eSynthesized);
47898:   event.refPoint = refpoint.ToNearestPixels(viewAPD);
    1:   event.time = PR_IntervalNow();
    1:   // XXX set event.isShift, event.isControl, event.isAlt, event.isMeta ?
    1: 
22570:   nsCOMPtr<nsIViewObserver> observer = pointVM->GetViewObserver();
22570:   if (observer) {
22570:     observer->DispatchSynthMouseMove(&event, !aFromScroll);
22570:   }
    1: 
    1:   if (!aFromScroll)
    1:     mSynthMouseMoveEvent.Forget();
    1: }
    1: 
    1: void
    1: nsViewManager::InvalidateHierarchy()
    1: {
    1:   if (mRootView) {
    1:     if (!IsRootVM()) {
    1:       NS_RELEASE(mRootViewManager);
    1:     }
    1:     nsView *parent = mRootView->GetParent();
    1:     if (parent) {
    1:       mRootViewManager = parent->GetViewManager()->RootViewManager();
    1:       NS_ADDREF(mRootViewManager);
    1:       NS_ASSERTION(mRootViewManager != this,
    1:                    "Root view had a parent, but it has the same view manager");
    1:     } else {
    1:       mRootViewManager = this;
    1:     }
    1:   }
    1: }
