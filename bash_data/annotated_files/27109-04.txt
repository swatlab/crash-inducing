    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
18084:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS parser.
    1:  *
    1:  * This is a recursive-descent parser for the JavaScript language specified by
    1:  * "The JavaScript 1.5 Language Specification".  It uses lexical and semantic
    1:  * feedback to disambiguate non-LL(1) structures.  It generates trees of nodes
    1:  * induced by the recursive parsing (not precise syntax trees, see jsparse.h).
    1:  * After tree construction, it rewrites trees to fold constants and evaluate
    1:  * compile-time expressions.  Finally, it calls js_EmitTree (see jsemit.h) to
    1:  * generate bytecode.
    1:  *
    1:  * This parser attempts no error recovery.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include <math.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsinterp.h"
15613: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
18989: #include "jsstaticcheck.h"
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: #include "jsdhash.h"
    1: #endif
    1: 
    1: /*
10466:  * Asserts to verify assumptions behind pn_ macros.
10466:  */
27012: #define pn_offsetof(m)  offsetof(JSParseNode, m)
27012: 
27012: JS_STATIC_ASSERT(pn_offsetof(pn_link) == pn_offsetof(dn_uses));
27012: JS_STATIC_ASSERT(pn_offsetof(pn_u.name.atom) == pn_offsetof(pn_u.apair.atom));
27012: 
27012: #undef pn_offsetof
10466: 
10466: /*
    1:  * JS parsers, from lowest to highest precedence.
    1:  *
    1:  * Each parser takes a context, a token stream, and a tree context struct.
    1:  * Each returns a parse node tree or null on error.
    1:  */
    1: 
    1: typedef JSParseNode *
    1: JSParser(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc);
    1: 
    1: typedef JSParseNode *
27012: JSVariablesParser(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
27012:                   bool inLetHead);
27012: 
27012: typedef JSParseNode *
    1: JSMemberParser(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:                JSBool allowCallSyntax);
    1: 
    1: typedef JSParseNode *
    1: JSPrimaryParser(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:                 JSTokenType tt, JSBool afterDot);
    1: 
 1577: typedef JSParseNode *
 1577: JSParenParser(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
 1577:               JSParseNode *pn1, JSBool *genexp);
 1577: 
    1: static JSParser FunctionStmt;
    1: static JSParser FunctionExpr;
    1: static JSParser Statements;
    1: static JSParser Statement;
27012: static JSVariablesParser Variables;
    1: static JSParser Expr;
    1: static JSParser AssignExpr;
    1: static JSParser CondExpr;
    1: static JSParser OrExpr;
    1: static JSParser AndExpr;
    1: static JSParser BitOrExpr;
    1: static JSParser BitXorExpr;
    1: static JSParser BitAndExpr;
    1: static JSParser EqExpr;
    1: static JSParser RelExpr;
    1: static JSParser ShiftExpr;
    1: static JSParser AddExpr;
    1: static JSParser MulExpr;
    1: static JSParser UnaryExpr;
    1: static JSMemberParser  MemberExpr;
    1: static JSPrimaryParser PrimaryExpr;
 1577: static JSParenParser   ParenExpr;
    1: 
    1: /*
    1:  * Insist that the next token be of type tt, or report errno and return null.
    1:  * NB: this macro uses cx and ts from its lexical environment.
    1:  */
    1: #define MUST_MATCH_TOKEN(tt, errno)                                           \
    1:     JS_BEGIN_MACRO                                                            \
    1:         if (js_GetToken(cx, ts) != tt) {                                      \
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR, errno); \
    1:             return NULL;                                                      \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
    1: #ifdef METER_PARSENODES
    1: static uint32 parsenodes = 0;
    1: static uint32 maxparsenodes = 0;
    1: static uint32 recyclednodes = 0;
    1: #endif
    1: 
27012: void
27012: JSParseNode::become(JSParseNode *pn2)
27012: {
27012:     JS_ASSERT(!pn_defn);
27012:     JS_ASSERT(!pn2->pn_defn);
27012: 
27012:     JS_ASSERT(!pn_used);
27012:     if (pn2->pn_used) {
27012:         JSParseNode **pnup = &pn2->pn_lexdef->dn_uses;
27012:         while (*pnup != pn2)
27012:             pnup = &(*pnup)->pn_link;
27012:         *pnup = this;
27012:         pn_link = pn2->pn_link;
27012:         pn_used = true;
27012:         pn2->pn_link = NULL;
27012:         pn2->pn_used = false;
27012:     }
27012: 
27012:     /* If this is a function node fix up the pn_funbox->node back-pointer. */
27012:     if (PN_TYPE(pn2) == TOK_FUNCTION && pn2->pn_arity == PN_FUNC)
27012:         pn2->pn_funbox->node = this;
27012: 
27012:     pn_type = pn2->pn_type;
27012:     pn_op = pn2->pn_op;
27012:     pn_arity = pn2->pn_arity;
27012:     pn_u = pn2->pn_u;
27012:     pn2->clear();
27012: }
27012: 
27012: void
27012: JSParseNode::clear()
27012: {
27012:     pn_type = TOK_EOF;
27012:     pn_op = JSOP_NOP;
27012:     pn_used = pn_defn = false;
27012:     pn_arity = PN_NULLARY;
27012: }
27012: 
27012: bool
27012: JSCompiler::init(const jschar *base, size_t length,
 6561:                  FILE *fp, const char *filename, uintN lineno)
 3235: {
27012:     JSContext *cx = context;
27012: 
27012:     tempPoolMark = JS_ARENA_MARK(&cx->tempPool);
27012:     if (!js_InitTokenStream(cx, TS(this), base, length, fp, filename, lineno)) {
27012:         JS_ARENA_RELEASE(&cx->tempPool, tempPoolMark);
27012:         return false;
27012:     }
 3235: 
 3235:     /* Root atoms and objects allocated for the parsed tree. */
 3235:     JS_KEEP_ATOMS(cx->runtime);
27012:     JS_PUSH_TEMP_ROOT_COMPILER(cx, this, &tempRoot);
27012:     return true;
27012: }
27012: 
27012: JSCompiler::~JSCompiler()
27012: {
27012:     JSContext *cx = context;
27012: 
27012:     if (principals)
27012:         JSPRINCIPALS_DROP(cx, principals);
27012:     JS_ASSERT(tempRoot.u.compiler == this);
27012:     JS_POP_TEMP_ROOT(cx, &tempRoot);
27012:     JS_UNKEEP_ATOMS(cx->runtime);
27012:     js_CloseTokenStream(cx, TS(this));
27012:     JS_ARENA_RELEASE(&cx->tempPool, tempPoolMark);
26970: }
26970: 
26970: void
27012: JSCompiler::setPrincipals(JSPrincipals *prin)
27012: {
27012:     JS_ASSERT(!principals);
27012:     if (prin)
27012:         JSPRINCIPALS_HOLD(context, prin);
27012:     principals = prin;
27012: }
27012: 
27012: JSObjectBox *
27012: JSCompiler::newObjectBox(JSObject *obj)
27012: {
27012:     JS_ASSERT(obj);
 3235: 
 3235:     /*
 3235:      * We use JSContext.tempPool to allocate parsed objects and place them on
11534:      * a list in JSTokenStream to ensure GC safety. Thus the tempPool arenas
11534:      * containing the entries must be alive until we are done with scanning,
 3235:      * parsing and code generation for the whole script or top-level function.
 3235:      */
27012:     JSObjectBox *objbox;
27012:     JS_ARENA_ALLOCATE_TYPE(objbox, JSObjectBox, &context->tempPool);
27012:     if (!objbox) {
27012:         js_ReportOutOfScriptQuota(context);
27012:         return NULL;
27012:     }
27012:     objbox->traceLink = traceListHead;
27012:     traceListHead = objbox;
27012:     objbox->emitLink = NULL;
27012:     objbox->object = obj;
27012:     return objbox;
27012: }
27012: 
27012: JSFunctionBox *
27012: JSCompiler::newFunctionBox(JSObject *obj, JSParseNode *fn, JSTreeContext *tc)
27012: {
26970:     JS_ASSERT(obj);
27012:     JS_ASSERT(HAS_FUNCTION_CLASS(obj));
27012: 
27012:     /*
27012:      * We use JSContext.tempPool to allocate parsed objects and place them on
27012:      * a list in JSTokenStream to ensure GC safety. Thus the tempPool arenas
27012:      * containing the entries must be alive until we are done with scanning,
27012:      * parsing and code generation for the whole script or top-level function.
27012:      */
27012:     JSFunctionBox *funbox;
27012:     JS_ARENA_ALLOCATE_TYPE(funbox, JSFunctionBox, &context->tempPool);
27012:     if (!funbox) {
27012:         js_ReportOutOfScriptQuota(context);
27012:         return NULL;
27012:     }
27012:     funbox->traceLink = traceListHead;
27012:     traceListHead = funbox;
27012:     funbox->emitLink = NULL;
27012:     funbox->object = obj;
27012:     funbox->node = fn;
27012:     funbox->siblings = tc->functionList;
27012:     tc->functionList = funbox;
27012:     ++tc->compiler->functionCount;
27012:     funbox->kids = NULL;
27012:     funbox->parent = tc->funbox;
27012:     funbox->queued = false;
27012:     funbox->level = tc->staticLevel;
27012:     funbox->tcflags = TCF_IN_FUNCTION | (tc->flags & TCF_COMPILE_N_GO);
27012:     return funbox;
27012: }
26970: 
26970: void
27012: JSCompiler::trace(JSTracer *trc)
27012: {
27012:     JSObjectBox *objbox;
27012: 
27012:     JS_ASSERT(tempRoot.u.compiler == this);
27012:     objbox = traceListHead;
27012:     while (objbox) {
27012:         JS_CALL_OBJECT_TRACER(trc, objbox->object, "parser.object");
27012:         objbox = objbox->traceLink;
27012:     }
27012: }
27012: 
27012: static void
27012: UnlinkFunctionBoxes(JSParseNode *pn, JSTreeContext *tc);
27012: 
27012: static void
27012: UnlinkFunctionBox(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     JSFunctionBox *funbox = pn->pn_funbox;
27012:     if (funbox) {
27012:         JS_ASSERT(funbox->node == pn);
27012:         funbox->node = NULL;
27012: 
27012:         JSFunctionBox **funboxp = &tc->functionList;
27012:         while (*funboxp) {
27012:             if (*funboxp == funbox) {
27012:                 *funboxp = funbox->siblings;
27012:                 break;
27012:             }
27012:             funboxp = &(*funboxp)->siblings;
27012:         }
27012: 
27012:         uint16 oldflags = tc->flags;
27012:         JSFunctionBox *oldlist = tc->functionList;
27012: 
27012:         tc->flags = (uint16) funbox->tcflags;
27012:         tc->functionList = funbox->kids;
27012:         UnlinkFunctionBoxes(pn->pn_body, tc);
27012:         funbox->kids = tc->functionList;
27012:         tc->flags = oldflags;
27012:         tc->functionList = oldlist;
27012: 
27012:         // FIXME: use a funbox freelist (consolidate aleFreeList and nodeList).
27012:         pn->pn_funbox = NULL;
27012:     }
27012: }
27012: 
27012: static void
27012: UnlinkFunctionBoxes(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     if (pn) {
27012:         switch (pn->pn_arity) {
27012:           case PN_NULLARY:
27012:             return;
27012:           case PN_UNARY:
27012:             UnlinkFunctionBoxes(pn->pn_kid, tc);
27012:             return;
27012:           case PN_BINARY:
27012:             UnlinkFunctionBoxes(pn->pn_left, tc);
27012:             UnlinkFunctionBoxes(pn->pn_right, tc);
27012:             return;
27012:           case PN_TERNARY:
27012:             UnlinkFunctionBoxes(pn->pn_kid1, tc);
27012:             UnlinkFunctionBoxes(pn->pn_kid2, tc);
27012:             UnlinkFunctionBoxes(pn->pn_kid3, tc);
27012:             return;
27012:           case PN_LIST:
27012:             for (JSParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next)
27012:                 UnlinkFunctionBoxes(pn2, tc);
27012:             return;
27012:           case PN_FUNC:
27012:             UnlinkFunctionBox(pn, tc);
27012:             return;
27012:           case PN_NAME:
27012:             UnlinkFunctionBoxes(pn->maybeExpr(), tc);
27012:             return;
27012:           case PN_NAMESET:
27012:             UnlinkFunctionBoxes(pn->pn_tree, tc);
27012:         }
27012:     }
27012: }
27012: 
27012: static void
27012: RecycleFuncNameKids(JSParseNode *pn, JSTreeContext *tc);
 3235: 
    1: static JSParseNode *
    1: RecycleTree(JSParseNode *pn, JSTreeContext *tc)
    1: {
27012:     JSParseNode *next, **head;
    1: 
    1:     if (!pn)
    1:         return NULL;
 3235: 
 3235:     /* Catch back-to-back dup recycles. */
27012:     JS_ASSERT(pn != tc->compiler->nodeList);
    1:     next = pn->pn_next;
27012:     if (pn->pn_used || pn->pn_defn) {
27012:         /*
27012:          * JSAtomLists own definition nodes along with their used-node chains.
27012:          * Defer recycling such nodes until we unwind to top level to avoid
27012:          * linkage overhead or (alternatively) unlinking runtime complexity.
27012:          * Yes, this means dead code can contribute to static analysis results!
27012:          *
27012:          * Do recycle kids here, since they are no longer needed.
27012:          */
27012:         pn->pn_next = NULL;
27012:         RecycleFuncNameKids(pn, tc);
27012:     } else {
27012:         UnlinkFunctionBoxes(pn, tc);
27012:         head = &tc->compiler->nodeList;
27012:         pn->pn_next = *head;
27012:         *head = pn;
    1: #ifdef METER_PARSENODES
    1:         recyclednodes++;
    1: #endif
27012:     }
    1:     return next;
    1: }
    1: 
27012: static void
27012: RecycleFuncNameKids(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     switch (pn->pn_arity) {
27012:       case PN_FUNC:
27012:         UnlinkFunctionBox(pn, tc);
27012:         /* FALL THROUGH */
27012: 
27012:       case PN_NAME:
27012:         /*
27012:          * Only a definition node might have a non-null strong pn_expr link
27012:          * to recycle, but we test !pn_used to handle PN_FUNC fall through.
27012:          * Every node with the pn_used flag set has a non-null pn_lexdef
27012:          * weak reference to its definition node.
27012:          */
27012:         if (!pn->pn_used && pn->pn_expr) {
27012:             RecycleTree(pn->pn_expr, tc);
27012:             pn->pn_expr = NULL;
27012:         }
27012:         break;
27012: 
27012:       default:
27012:         JS_NOT_REACHED("RecycleFuncNameKids");
27012:     }
27012: }
27012: 
26970: static JSParseNode *
27012: NewOrRecycledNode(JSTreeContext *tc)
27012: {
27012:     JSParseNode *pn, *pn2;
27012: 
27012:     pn = tc->compiler->nodeList;
    1:     if (!pn) {
27012:         JSContext *cx = tc->compiler->context;
27012: 
    1:         JS_ARENA_ALLOCATE_TYPE(pn, JSParseNode, &cx->tempPool);
    1:         if (!pn)
 8296:             js_ReportOutOfScriptQuota(cx);
    1:     } else {
27012:         tc->compiler->nodeList = pn->pn_next;
    1: 
    1:         /* Recycle immediate descendents only, to save work and working set. */
    1:         switch (pn->pn_arity) {
    1:           case PN_FUNC:
    1:             RecycleTree(pn->pn_body, tc);
    1:             break;
    1:           case PN_LIST:
27012:             pn2 = pn->pn_head;
27012:             if (pn2) {
27012:                 while (pn2 && !pn2->pn_used && !pn2->pn_defn)
27012:                     pn2 = pn2->pn_next;
27012:                 if (pn2) {
27012:                     pn2 = pn->pn_head;
27012:                     do {
27012:                         pn2 = RecycleTree(pn2, tc);
27012:                     } while (pn2);
27012:                 } else {
27012:                     *pn->pn_tail = tc->compiler->nodeList;
27012:                     tc->compiler->nodeList = pn->pn_head;
    1: #ifdef METER_PARSENODES
    1:                     recyclednodes += pn->pn_count;
    1: #endif
27012:                     break;
27012:                 }
    1:             }
    1:             break;
    1:           case PN_TERNARY:
    1:             RecycleTree(pn->pn_kid1, tc);
    1:             RecycleTree(pn->pn_kid2, tc);
    1:             RecycleTree(pn->pn_kid3, tc);
    1:             break;
    1:           case PN_BINARY:
15154:             if (pn->pn_left != pn->pn_right)
    1:                 RecycleTree(pn->pn_left, tc);
    1:             RecycleTree(pn->pn_right, tc);
    1:             break;
    1:           case PN_UNARY:
    1:             RecycleTree(pn->pn_kid, tc);
    1:             break;
    1:           case PN_NAME:
27012:             if (!pn->pn_used)
    1:                 RecycleTree(pn->pn_expr, tc);
    1:             break;
    1:           case PN_NULLARY:
    1:             break;
    1:         }
    1:     }
 2567:     if (pn) {
    1: #ifdef METER_PARSENODES
    1:         parsenodes++;
    1:         if (parsenodes - recyclednodes > maxparsenodes)
    1:             maxparsenodes = parsenodes - recyclednodes;
    1: #endif
27012:         pn->pn_used = pn->pn_defn = false;
 1577:         memset(&pn->pn_u, 0, sizeof pn->pn_u);
 1577:         pn->pn_next = NULL;
 2567:     }
    1:     return pn;
    1: }
    1: 
27012: static inline void
27012: InitParseNode(JSParseNode *pn, JSTokenType type, JSOp op, JSParseNodeArity arity)
27012: {
27012:     pn->pn_type = type;
27012:     pn->pn_op = op;
27012:     pn->pn_arity = arity;
27012:     JS_ASSERT(!pn->pn_used);
27012:     JS_ASSERT(!pn->pn_defn);
27012:     pn->pn_next = pn->pn_link = NULL;
27012: }
27012: 
27012: /*
27012:  * Allocate a JSParseNode from tc's node freelist or, failing that, from cx's
27012:  * temporary arena.
    1:  */
    1: static JSParseNode *
27012: NewParseNode(JSParseNodeArity arity, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSToken *tp;
    1: 
27012:     pn = NewOrRecycledNode(tc);
    1:     if (!pn)
    1:         return NULL;
27012:     tp = &CURRENT_TOKEN(&tc->compiler->tokenStream);
27012:     InitParseNode(pn, tp->type, JSOP_NOP, arity);
    1:     pn->pn_pos = tp->pos;
    1:     return pn;
    1: }
    1: 
27012: static inline void
27012: InitNameNodeCommon(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     pn->pn_expr = NULL;
27012:     pn->pn_cookie = FREE_UPVAR_COOKIE;
27012:     pn->pn_dflags = tc->atTopLevel() ? PND_TOPLEVEL : 0;
27012:     if (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)
27012:         pn->pn_dflags |= PND_BLOCKCHILD;
27012:     pn->pn_blockid = tc->blockid();
27012: }
27012: 
    1: static JSParseNode *
27012: NewNameNode(JSContext *cx, JSTokenStream *ts, JSAtom *atom, JSTreeContext *tc)
27012: {
27012:     JSParseNode *pn;
27012: 
27012:     pn = NewParseNode(PN_NAME, tc);
27012:     if (pn) {
27012:         pn->pn_atom = atom;
27012:         InitNameNodeCommon(pn, tc);
27012:     }
27012:     return pn;
27012: }
27012: 
27012: static JSParseNode *
27012: NewBinary(JSTokenType tt, JSOp op, JSParseNode *left, JSParseNode *right,
    1:           JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn1, *pn2;
    1: 
    1:     if (!left || !right)
    1:         return NULL;
    1: 
    1:     /*
    1:      * Flatten a left-associative (left-heavy) tree of a given operator into
    1:      * a list, to reduce js_FoldConstants and js_EmitTree recursion.
    1:      */
27012:     if (PN_TYPE(left) == tt &&
27012:         PN_OP(left) == op &&
    1:         (js_CodeSpec[op].format & JOF_LEFTASSOC)) {
    1:         if (left->pn_arity != PN_LIST) {
    1:             pn1 = left->pn_left, pn2 = left->pn_right;
    1:             left->pn_arity = PN_LIST;
27012:             left->initList(pn1);
27012:             left->append(pn2);
    1:             if (tt == TOK_PLUS) {
    1:                 if (pn1->pn_type == TOK_STRING)
27012:                     left->pn_xflags |= PNX_STRCAT;
    1:                 else if (pn1->pn_type != TOK_NUMBER)
27012:                     left->pn_xflags |= PNX_CANTFOLD;
    1:                 if (pn2->pn_type == TOK_STRING)
27012:                     left->pn_xflags |= PNX_STRCAT;
    1:                 else if (pn2->pn_type != TOK_NUMBER)
27012:                     left->pn_xflags |= PNX_CANTFOLD;
27012:             }
27012:         }
27012:         left->append(right);
    1:         left->pn_pos.end = right->pn_pos.end;
    1:         if (tt == TOK_PLUS) {
    1:             if (right->pn_type == TOK_STRING)
27012:                 left->pn_xflags |= PNX_STRCAT;
    1:             else if (right->pn_type != TOK_NUMBER)
27012:                 left->pn_xflags |= PNX_CANTFOLD;
    1:         }
    1:         return left;
    1:     }
    1: 
    1:     /*
    1:      * Fold constant addition immediately, to conserve node space and, what's
    1:      * more, so js_FoldConstants never sees mixed addition and concatenation
    1:      * operations with more than one leading non-string operand in a PN_LIST
    1:      * generated for expressions such as 1 + 2 + "pt" (which should evaluate
    1:      * to "3pt", not "12pt").
    1:      */
    1:     if (tt == TOK_PLUS &&
    1:         left->pn_type == TOK_NUMBER &&
    1:         right->pn_type == TOK_NUMBER) {
    1:         left->pn_dval += right->pn_dval;
    1:         left->pn_pos.end = right->pn_pos.end;
    1:         RecycleTree(right, tc);
    1:         return left;
    1:     }
    1: 
27012:     pn = NewOrRecycledNode(tc);
    1:     if (!pn)
    1:         return NULL;
27012:     InitParseNode(pn, tt, op, PN_BINARY);
    1:     pn->pn_pos.begin = left->pn_pos.begin;
    1:     pn->pn_pos.end = right->pn_pos.end;
    1:     pn->pn_left = left;
    1:     pn->pn_right = right;
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_GETTER_SETTER
    1: static JSTokenType
    1: CheckGetterOrSetter(JSContext *cx, JSTokenStream *ts, JSTokenType tt)
    1: {
    1:     JSAtom *atom;
    1:     JSRuntime *rt;
    1:     JSOp op;
    1:     const char *name;
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_NAME);
    1:     atom = CURRENT_TOKEN(ts).t_atom;
    1:     rt = cx->runtime;
    1:     if (atom == rt->atomState.getterAtom)
    1:         op = JSOP_GETTER;
    1:     else if (atom == rt->atomState.setterAtom)
    1:         op = JSOP_SETTER;
    1:     else
    1:         return TOK_NAME;
    1:     if (js_PeekTokenSameLine(cx, ts) != tt)
    1:         return TOK_NAME;
    1:     (void) js_GetToken(cx, ts);
    1:     if (CURRENT_TOKEN(ts).t_op != JSOP_NOP) {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_GETTER_OR_SETTER,
    1:                                     (op == JSOP_GETTER)
    1:                                     ? js_getter_str
    1:                                     : js_setter_str);
    1:         return TOK_ERROR;
    1:     }
    1:     CURRENT_TOKEN(ts).t_op = op;
    1:     if (JS_HAS_STRICT_OPTION(cx)) {
    1:         name = js_AtomToPrintableString(cx, atom);
    1:         if (!name ||
 7984:             !js_ReportCompileErrorNumber(cx, ts, NULL,
 7984:                                          JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                          JSMSG_DEPRECATED_USAGE,
    1:                                          name)) {
    1:             return TOK_ERROR;
    1:         }
    1:     }
    1:     return tt;
    1: }
    1: #endif
    1: 
27012: static bool
27012: GenerateBlockId(JSTreeContext *tc, uint32& blockid)
27012: {
27012:     if (tc->blockidGen == JS_BIT(20)) {
27012:         JS_ReportErrorNumber(tc->compiler->context, js_GetErrorMessage, NULL,
27012:                              JSMSG_NEED_DIET, "program");
27012:         return false;
27012:     }
27012:     blockid = tc->blockidGen++;
27012:     return true;
27012: }
27012: 
27012: static bool
27012: GenerateBlockIdForStmtNode(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     JS_ASSERT(tc->topStmt);
27012:     JS_ASSERT(STMT_MAYBE_SCOPE(tc->topStmt));
27012:     JS_ASSERT(pn->pn_type == TOK_LC || pn->pn_type == TOK_LEXICALSCOPE);
27012:     if (!GenerateBlockId(tc, tc->topStmt->blockid))
27012:         return false;
27012:     pn->pn_blockid = tc->topStmt->blockid;
27012:     return true;
27012: }
27012: 
    1: /*
    1:  * Parse a top-level JS script.
    1:  */
 8444: JSParseNode *
27012: JSCompiler::parse(JSObject *chain)
27012: {
    1:     /*
    1:      * Protect atoms from being collected by a GC activation, which might
    1:      * - nest on this thread due to out of memory (the so-called "last ditch"
    1:      *   GC attempted within js_NewGCThing), or
    1:      * - run for any reason on another thread if this thread is suspended on
    1:      *   an object lock before it finishes generating bytecode into a script
    1:      *   protected from the GC by a root or a stack frame reference.
    1:      */
27012:     JSTreeContext tc(this);
27012:     tc.scopeChain = chain;
27012:     if (!GenerateBlockId(&tc, tc.bodyid))
27012:         return NULL;
27012: 
27012:     JSParseNode *pn = Statements(context, TS(this), &tc);
    1:     if (pn) {
27012:         if (!js_MatchToken(context, TS(this), TOK_EOF)) {
27012:             js_ReportCompileErrorNumber(context, TS(this), NULL, JSREPORT_ERROR,
    1:                                         JSMSG_SYNTAX_ERROR);
    1:             pn = NULL;
    1:         } else {
27012:             if (!js_FoldConstants(context, pn, &tc))
    1:                 pn = NULL;
    1:         }
    1:     }
    1:     return pn;
    1: }
    1: 
27012: static inline bool
27012: SetStaticLevel(JSTreeContext *tc, uintN staticLevel)
27012: {
27012:     /*
27012:      * Reserve staticLevel 0xffff in order to reserve FREE_UPVAR_COOKIE. This
27012:      * is simpler than error-checking every MAKE_UPVAR_COOKIE, and practically
27012:      * speaking it leaves more than enough room for upvars. In fact we might
27012:      * want to split cookies with fewer bits for skip and more for slot, but
27012:      * only based on evidence.
27012:      */
27012:     if (staticLevel >= JS_BITMASK(16)) {
27012:         JS_ReportErrorNumber(tc->compiler->context, js_GetErrorMessage, NULL,
27012:                              JSMSG_TOO_DEEP, js_function_str);
27012:         return false;
27012:     }
27012:     tc->staticLevel = staticLevel;
27012:     return true;
27012: }
27012: 
    1: /*
    1:  * Compile a top-level script.
    1:  */
27012: JSScript *
27012: JSCompiler::compileScript(JSContext *cx, JSObject *scopeChain, JSStackFrame *callerFrame,
18955:                           JSPrincipals *principals, uint32 tcflags,
18955:                           const jschar *chars, size_t length,
24375:                           FILE *file, const char *filename, uintN lineno,
27012:                           JSString *source /* = NULL */)
27012: {
27012:     JSCompiler jsc(cx, principals, callerFrame);
 6561:     JSArenaPool codePool, notePool;
 9604:     JSTokenType tt;
    1:     JSParseNode *pn;
16072:     uint32 scriptGlobals;
 6561:     JSScript *script;
    1: #ifdef METER_PARSENODES
    1:     void *sbrk(ptrdiff_t), *before = sbrk(0);
    1: #endif
    1: 
18955:     JS_ASSERT(!(tcflags & ~(TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL |
27012:                             TCF_STATIC_LEVEL_MASK)));
 8444: 
    1:     /*
18955:      * The scripted callerFrame can only be given for compile-and-go scripts
27012:      * and non-zero static level requires callerFrame.
    1:      */
18955:     JS_ASSERT_IF(callerFrame, tcflags & TCF_COMPILE_N_GO);
27012:     JS_ASSERT_IF(TCF_GET_STATIC_LEVEL(tcflags) != 0, callerFrame);
27012: 
27012:     if (!jsc.init(chars, length, file, filename, lineno))
27012:         return NULL;
    1: 
 6561:     JS_INIT_ARENA_POOL(&codePool, "code", 1024, sizeof(jsbytecode),
 6561:                        &cx->scriptStackQuota);
 6561:     JS_INIT_ARENA_POOL(&notePool, "note", 1024, sizeof(jssrcnote),
 6561:                        &cx->scriptStackQuota);
27012: 
27012:     JSCodeGenerator cg(&jsc, &codePool, &notePool, jsc.tokenStream.lineno);
 6561: 
18989:     MUST_FLOW_THROUGH("out");
27012:     cg.flags |= (uint16) tcflags;
27012:     cg.scopeChain = scopeChain;
27012:     if (!SetStaticLevel(&cg, TCF_GET_STATIC_LEVEL(tcflags)))
27012:         return NULL;
27012: 
27012:     /*
27012:      * If funbox is non-null after we create the new script, callerFrame->fun
24375:      * was saved in the 0th object table entry.
21449:      */
27012:     JSObjectBox *funbox = NULL;
24375: 
24375:     if (tcflags & TCF_COMPILE_N_GO) {
24375:         if (source) {
24375:             /*
24375:              * Save eval program source in script->atomMap.vector[0] for the
24375:              * eval cache (see obj_eval in jsobj.cpp).
24375:              */
24375:             JSAtom *atom = js_AtomizeString(cx, source, 0);
27012:             if (!atom || !cg.atomList.add(&jsc, atom))
24375:                 return NULL;
24375:         }
24375: 
24375:         if (callerFrame && callerFrame->fun) {
24375:             /*
24375:              * An eval script in a caller frame needs to have its enclosing
27012:              * function captured in case it refers to an upvar, and someone
27012:              * wishes to decompile it while it's running.
27012:              */
27012:             funbox = jsc.newObjectBox(FUN_OBJECT(callerFrame->fun));
27012:             if (!funbox)
27012:                 return NULL;
27012:             funbox->emitLink = cg.objectList.lastbox;
27012:             cg.objectList.lastbox = funbox;
21449:             cg.objectList.length++;
21449:         }
24375:     }
21449: 
27012:     /*
27012:      * Inline Statements to emit as we go to save AST space. We must generate
27012:      * our script-body blockid since we aren't calling Statements.
27012:      */
27012:     uint32 bodyid;
27012:     if (!GenerateBlockId(&cg, bodyid))
27012:         return NULL;
27012:     cg.bodyid = bodyid;
27012: 
27012:     /* Null script early in case of error, to reduce our code footprint. */
27012:     script = NULL;
 9604:     for (;;) {
27012:         jsc.tokenStream.flags |= TSF_OPERAND;
27012:         tt = js_PeekToken(cx, &jsc.tokenStream);
27012:         jsc.tokenStream.flags &= ~TSF_OPERAND;
 9604:         if (tt <= TOK_EOF) {
 9604:             if (tt == TOK_EOF)
 9604:                 break;
 9604:             JS_ASSERT(tt == TOK_ERROR);
 9604:             goto out;
 9604:         }
 9604: 
27012:         pn = Statement(cx, &jsc.tokenStream, &cg);
27012:         if (!pn)
 6561:             goto out;
27012:         JS_ASSERT(!cg.blockNode);
27012: 
27012:         if (!js_FoldConstants(cx, pn, &cg))
 6561:             goto out;
27012: 
27012:         if (cg.functionList) {
27012:             if (!jsc.analyzeFunctions(cg.functionList, cg.flags))
27012:                 goto out;
27012:             cg.functionList = NULL;
27012:         }
27012: 
27012:         if (!js_EmitTree(cx, &cg, pn))
27012:             goto out;
27012:         RecycleTree(pn, &cg);
 9604:     }
 9604: 
16072:     /*
26974:      * Global variables and regexps share the index space with locals. Due to
17947:      * incremental code generation we need to patch the bytecode to adjust the
17947:      * local references to skip the globals.
16072:      */
27012:     scriptGlobals = cg.ngvars + cg.regexpList.length;
16072:     if (scriptGlobals != 0) {
16072:         jsbytecode *code, *end;
16072:         JSOp op;
16072:         const JSCodeSpec *cs;
16072:         uintN len, slot;
16072: 
16072:         if (scriptGlobals >= SLOTNO_LIMIT)
16072:             goto too_many_slots;
16072:         code = CG_BASE(&cg);
16072:         for (end = code + CG_OFFSET(&cg); code != end; code += len) {
16072:             JS_ASSERT(code < end);
16072:             op = (JSOp) *code;
16072:             cs = &js_CodeSpec[op];
17947:             len = (cs->length > 0)
16072:                   ? (uintN) cs->length
16072:                   : js_GetVariableBytecodeLength(code);
16072:             if (JOF_TYPE(cs->format) == JOF_LOCAL ||
16072:                 (JOF_TYPE(cs->format) == JOF_SLOTATOM)) {
16072:                 /*
16429:                  * JSOP_GETARGPROP also has JOF_SLOTATOM type, but it may be
16429:                  * emitted only for a function.
16072:                  */
16072:                 JS_ASSERT((JOF_TYPE(cs->format) == JOF_SLOTATOM) ==
16072:                           (op == JSOP_GETLOCALPROP));
16072:                 slot = GET_SLOTNO(code);
16072:                 slot += scriptGlobals;
16072:                 if (slot >= SLOTNO_LIMIT)
16072:                     goto too_many_slots;
16072:                 SET_SLOTNO(code, slot);
16072:             }
16072:         }
16072:     }
16072: 
    1: #ifdef METER_PARSENODES
    1:     printf("Parser growth: %d (%u nodes, %u max, %u unrecycled)\n",
    1:            (char *)sbrk(0) - (char *)before,
    1:            parsenodes,
    1:            maxparsenodes,
    1:            parsenodes - recyclednodes);
    1:     before = sbrk(0);
    1: #endif
    1: 
    1:     /*
    1:      * Nowadays the threaded interpreter needs a stop instruction, so we
    1:      * do have to emit that here.
    1:      */
27012:     if (js_Emit1(cx, &cg, JSOP_STOP) < 0)
 6561:         goto out;
    1: #ifdef METER_PARSENODES
    1:     printf("Code-gen growth: %d (%u bytecodes, %u srcnotes)\n",
27012:            (char *)sbrk(0) - (char *)before, CG_OFFSET(&cg), cg.noteCount);
    1: #endif
    1: #ifdef JS_ARENAMETER
    1:     JS_DumpArenaStats(stdout);
    1: #endif
 8444:     script = js_NewScriptFromCG(cx, &cg);
27012:     if (script && funbox)
24375:         script->flags |= JSSF_SAVED_CALLER_FUN;
 6561: 
10217: #ifdef JS_SCOPE_DEPTH_METER
10217:     if (script) {
18955:         JSObject *obj = scopeChain;
10217:         uintN depth = 1;
18955:         while ((obj = OBJ_GET_PARENT(cx, obj)) != NULL)
10217:             ++depth;
10217:         JS_BASIC_STATS_ACCUM(&cx->runtime->hostenvScopeDepthStats, depth);
10217:     }
10217: #endif
10217: 
 6561:   out:
 6561:     JS_FinishArenaPool(&codePool);
 6561:     JS_FinishArenaPool(&notePool);
 6561:     return script;
16072: 
16072:   too_many_slots:
27012:     js_ReportCompileErrorNumber(cx, &jsc.tokenStream, NULL,
16072:                                 JSREPORT_ERROR, JSMSG_TOO_MANY_LOCALS);
16072:     script = NULL;
16072:     goto out;
    1: }
    1: 
    1: /*
    1:  * Insist on a final return before control flows out of pn.  Try to be a bit
    1:  * smart about loops: do {...; return e2;} while(0) at the end of a function
    1:  * that contains an early return e1 will get a strict warning.  Similarly for
    1:  * iloops: while (true){...} is treated as though ... returns.
    1:  */
    1: #define ENDS_IN_OTHER   0
    1: #define ENDS_IN_RETURN  1
    1: #define ENDS_IN_BREAK   2
    1: 
    1: static int
    1: HasFinalReturn(JSParseNode *pn)
    1: {
    1:     JSParseNode *pn2, *pn3;
    1:     uintN rv, rv2, hasDefault;
    1: 
    1:     switch (pn->pn_type) {
    1:       case TOK_LC:
    1:         if (!pn->pn_head)
    1:             return ENDS_IN_OTHER;
27012:         return HasFinalReturn(pn->last());
    1: 
    1:       case TOK_IF:
    1:         if (!pn->pn_kid3)
    1:             return ENDS_IN_OTHER;
    1:         return HasFinalReturn(pn->pn_kid2) & HasFinalReturn(pn->pn_kid3);
    1: 
    1:       case TOK_WHILE:
    1:         pn2 = pn->pn_left;
    1:         if (pn2->pn_type == TOK_PRIMARY && pn2->pn_op == JSOP_TRUE)
    1:             return ENDS_IN_RETURN;
    1:         if (pn2->pn_type == TOK_NUMBER && pn2->pn_dval)
    1:             return ENDS_IN_RETURN;
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_DO:
    1:         pn2 = pn->pn_right;
    1:         if (pn2->pn_type == TOK_PRIMARY) {
    1:             if (pn2->pn_op == JSOP_FALSE)
    1:                 return HasFinalReturn(pn->pn_left);
    1:             if (pn2->pn_op == JSOP_TRUE)
    1:                 return ENDS_IN_RETURN;
    1:         }
    1:         if (pn2->pn_type == TOK_NUMBER) {
    1:             if (pn2->pn_dval == 0)
    1:                 return HasFinalReturn(pn->pn_left);
    1:             return ENDS_IN_RETURN;
    1:         }
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_FOR:
    1:         pn2 = pn->pn_left;
    1:         if (pn2->pn_arity == PN_TERNARY && !pn2->pn_kid2)
    1:             return ENDS_IN_RETURN;
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_SWITCH:
    1:         rv = ENDS_IN_RETURN;
    1:         hasDefault = ENDS_IN_OTHER;
    1:         pn2 = pn->pn_right;
    1:         if (pn2->pn_type == TOK_LEXICALSCOPE)
27012:             pn2 = pn2->expr();
    1:         for (pn2 = pn2->pn_head; rv && pn2; pn2 = pn2->pn_next) {
    1:             if (pn2->pn_type == TOK_DEFAULT)
    1:                 hasDefault = ENDS_IN_RETURN;
    1:             pn3 = pn2->pn_right;
    1:             JS_ASSERT(pn3->pn_type == TOK_LC);
    1:             if (pn3->pn_head) {
27012:                 rv2 = HasFinalReturn(pn3->last());
    1:                 if (rv2 == ENDS_IN_OTHER && pn2->pn_next)
    1:                     /* Falling through to next case or default. */;
    1:                 else
    1:                     rv &= rv2;
    1:             }
    1:         }
    1:         /* If a final switch has no default case, we judge it harshly. */
    1:         rv &= hasDefault;
    1:         return rv;
    1: 
    1:       case TOK_BREAK:
    1:         return ENDS_IN_BREAK;
    1: 
    1:       case TOK_WITH:
    1:         return HasFinalReturn(pn->pn_right);
    1: 
    1:       case TOK_RETURN:
    1:         return ENDS_IN_RETURN;
    1: 
    1:       case TOK_COLON:
    1:       case TOK_LEXICALSCOPE:
27012:         return HasFinalReturn(pn->expr());
    1: 
    1:       case TOK_THROW:
    1:         return ENDS_IN_RETURN;
    1: 
    1:       case TOK_TRY:
    1:         /* If we have a finally block that returns, we are done. */
    1:         if (pn->pn_kid3) {
    1:             rv = HasFinalReturn(pn->pn_kid3);
    1:             if (rv == ENDS_IN_RETURN)
    1:                 return rv;
    1:         }
    1: 
    1:         /* Else check the try block and any and all catch statements. */
    1:         rv = HasFinalReturn(pn->pn_kid1);
    1:         if (pn->pn_kid2) {
    1:             JS_ASSERT(pn->pn_kid2->pn_arity == PN_LIST);
    1:             for (pn2 = pn->pn_kid2->pn_head; pn2; pn2 = pn2->pn_next)
    1:                 rv &= HasFinalReturn(pn2);
    1:         }
    1:         return rv;
    1: 
    1:       case TOK_CATCH:
    1:         /* Check this catch block's body. */
    1:         return HasFinalReturn(pn->pn_kid3);
    1: 
    1:       case TOK_LET:
    1:         /* Non-binary let statements are let declarations. */
    1:         if (pn->pn_arity != PN_BINARY)
    1:             return ENDS_IN_OTHER;
    1:         return HasFinalReturn(pn->pn_right);
    1: 
    1:       default:
    1:         return ENDS_IN_OTHER;
    1:     }
    1: }
    1: 
    1: static JSBool
 8444: ReportBadReturn(JSContext *cx, JSTreeContext *tc, uintN flags, uintN errnum,
    1:                 uintN anonerrnum)
    1: {
    1:     const char *name;
    1: 
 8444:     JS_ASSERT(tc->flags & TCF_IN_FUNCTION);
27012:     if (tc->fun->atom) {
27012:         name = js_AtomToPrintableString(cx, tc->fun->atom);
    1:     } else {
    1:         errnum = anonerrnum;
    1:         name = NULL;
    1:     }
27012:     return js_ReportCompileErrorNumber(cx, TS(tc->compiler), NULL, flags,
 8444:                                        errnum, name);
    1: }
    1: 
    1: static JSBool
 8444: CheckFinalReturn(JSContext *cx, JSTreeContext *tc, JSParseNode *pn)
    1: {
 8444:     JS_ASSERT(tc->flags & TCF_IN_FUNCTION);
    1:     return HasFinalReturn(pn) == ENDS_IN_RETURN ||
 8444:            ReportBadReturn(cx, tc, JSREPORT_WARNING | JSREPORT_STRICT,
    1:                            JSMSG_NO_RETURN_VALUE, JSMSG_ANON_NO_RETURN_VALUE);
    1: }
    1: 
    1: static JSParseNode *
 8444: FunctionBody(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSStmtInfo stmtInfo;
    1:     uintN oldflags, firstLine;
    1:     JSParseNode *pn;
    1: 
 8444:     JS_ASSERT(tc->flags & TCF_IN_FUNCTION);
    1:     js_PushStatement(tc, &stmtInfo, STMT_BLOCK, -1);
    1:     stmtInfo.flags = SIF_BODY_BLOCK;
    1: 
    1:     oldflags = tc->flags;
    1:     tc->flags &= ~(TCF_RETURN_EXPR | TCF_RETURN_VOID);
    1: 
    1:     /*
    1:      * Save the body's first line, and store it in pn->pn_pos.begin.lineno
    1:      * later, because we may have not peeked in ts yet, so Statements won't
    1:      * acquire a valid pn->pn_pos.begin from the current token.
    1:      */
    1:     firstLine = ts->lineno;
 1967: #if JS_HAS_EXPR_CLOSURES
 1967:     if (CURRENT_TOKEN(ts).type == TOK_LC) {
    1:         pn = Statements(cx, ts, tc);
 1967:     } else {
27012:         pn = NewParseNode(PN_UNARY, tc);
 1967:         if (pn) {
 1967:             pn->pn_kid = AssignExpr(cx, ts, tc);
 1967:             if (!pn->pn_kid) {
 1967:                 pn = NULL;
 1967:             } else {
 1967:                 if (tc->flags & TCF_FUN_IS_GENERATOR) {
 8444:                     ReportBadReturn(cx, tc, JSREPORT_ERROR,
 1967:                                     JSMSG_BAD_GENERATOR_RETURN,
 1967:                                     JSMSG_BAD_ANON_GENERATOR_RETURN);
 1967:                     pn = NULL;
 1967:                 } else {
 1967:                     pn->pn_type = TOK_RETURN;
 1967:                     pn->pn_op = JSOP_RETURN;
 1967:                     pn->pn_pos.end = pn->pn_kid->pn_pos.end;
 1967:                 }
 1967:             }
 1967:         }
 1967:     }
 1967: #else
 1967:     pn = Statements(cx, ts, tc);
 1967: #endif
    1: 
10299:     if (pn) {
27012:         JS_ASSERT(!(tc->topStmt->flags & SIF_SCOPE));
    1:         js_PopStatement(tc);
10299:         pn->pn_pos.begin.lineno = firstLine;
    1: 
    1:         /* Check for falling off the end of a function that returns a value. */
10299:         if (JS_HAS_STRICT_OPTION(cx) && (tc->flags & TCF_RETURN_EXPR) &&
10299:             !CheckFinalReturn(cx, tc, pn)) {
    1:             pn = NULL;
    1:         }
10299:     }
 8444: 
26827:     tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1:     return pn;
    1: }
    1: 
27012: static JSAtomListElement *
27012: MakePlaceholder(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     JSAtomListElement *ale = tc->lexdeps.add(tc->compiler, pn->pn_atom);
27012:     if (!ale)
27012:         return NULL;
27012: 
27012:     JSDefinition *dn = (JSDefinition *)
27012:         NewNameNode(tc->compiler->context, TS(tc->compiler), pn->pn_atom, tc);
27012:     if (!dn)
27012:         return NULL;
27012: 
27012:     ALE_SET_DEFN(ale, dn);
27012:     dn->pn_defn = true;
27012:     dn->pn_dflags |= PND_FORWARD | PND_PLACEHOLDER;
27012:     pn->pn_dflags |= PND_FORWARD;
27012:     return ale;
27012: }
27012: 
27012: static bool
27012: Define(JSParseNode *pn, JSAtom *atom, JSTreeContext *tc, bool let = false)
27012: {
27012:     JS_ASSERT(!pn->pn_used);
27012:     JS_ASSERT_IF(pn->pn_defn, pn->isPlaceholder());
27012: 
27012:     JSHashEntry **hep;
27012:     JSAtomListElement *ale = NULL;
27012:     JSAtomList *list = NULL;
27012: 
27012:     if (let)
27012:         ale = (list = &tc->decls)->rawLookup(atom, hep);
27012:     if (!ale)
27012:         ale = (list = &tc->upvars)->rawLookup(atom, hep);
27012:     if (!ale)
27012:         ale = (list = &tc->lexdeps)->rawLookup(atom, hep);
27012: 
27012:     if (ale) {
27012:         JSDefinition *dn = ALE_DEFN(ale);
27012:         if (dn != pn) {
27012:             JSParseNode **pnup = &dn->dn_uses;
27012:             JSParseNode *pnu;
27012:             uintN start = let ? pn->pn_blockid : tc->bodyid;
27012: 
27012:             while ((pnu = *pnup) != NULL && pnu->pn_blockid >= start) {
27012:                 JS_ASSERT(pnu->pn_used);
27012:                 pnu->pn_lexdef = (JSDefinition *) pn;
27012:                 pn->pn_dflags |= pnu->pn_dflags & (PND_ASSIGNED | PND_FUNARG);
27012:                 pnup = &pnu->pn_link;
27012:             }
27012: 
27012:             if (pnu != dn->dn_uses) {
27012:                 *pnup = pn->dn_uses;
27012:                 pn->dn_uses = dn->dn_uses;
27012:                 dn->dn_uses = pnu;
27012: 
27012:                 if ((!pnu || pnu->pn_blockid < tc->bodyid) && list != &tc->decls) {
27012:                     list->rawRemove(tc->compiler, ale, hep);
27012:                     ((list == &tc->upvars) ? &tc->lexdeps : &tc->upvars)
27012:                         ->remove(tc->compiler, atom);
27012:                 }
27012:             }
27012:         }
27012:     }
27012: 
27012:     ale = tc->decls.add(tc->compiler, atom, let ? JSAtomList::SHADOW : JSAtomList::UNIQUE);
27012:     if (!ale)
27012:         return false;
27012:     ALE_SET_DEFN(ale, pn);
27012:     pn->pn_defn = true;
27012:     pn->pn_dflags &= ~PND_PLACEHOLDER;
27012:     return true;
27012: }
27012: 
27012: static void
27012: LinkUseToDef(JSParseNode *pn, JSDefinition *dn, JSTreeContext *tc)
27012: {
27012:     JS_ASSERT(!pn->pn_used);
27012:     JS_ASSERT(!pn->pn_defn);
27012:     JS_ASSERT(pn != dn->dn_uses);
27012:     pn->pn_link = dn->dn_uses;
27012:     dn->dn_uses = pn;
27012:     pn->pn_used = true;
27012:     pn->pn_lexdef = dn;
27012: }
27012: 
27012: static void
27012: ForgetUse(JSParseNode *pn)
27012: {
27012:     if (!pn->pn_used) {
27012:         JS_ASSERT(!pn->pn_defn);
27012:         return;
27012:     }
27012: 
27012:     JSParseNode **pnup = &pn->lexdef()->dn_uses;
27012:     JSParseNode *pnu;
27012:     while ((pnu = *pnup) != pn)
27012:         pnup = &pnu->pn_link;
27012:     *pnup = pn->pn_link;
27012:     pn->pn_used = false;
27012: }
27012: 
27012: static JSParseNode *
27012: MakeAssignment(JSParseNode *pn, JSParseNode *rhs, JSTreeContext *tc)
27012: {
27012:     JSParseNode *lhs = NewOrRecycledNode(tc);
27012:     if (!lhs)
27012:         return NULL;
27012:     *lhs = *pn;
27012: 
27012:     if (pn->pn_used) {
27012:         JSDefinition *dn = pn->pn_lexdef;
27012:         JSParseNode **pnup = &dn->dn_uses;
27012: 
27012:         while (*pnup != pn)
27012:             pnup = &(*pnup)->pn_link;
27012:         *pnup = lhs;
27012:         lhs->pn_link = pn->pn_link;
27012:         pn->pn_link = NULL;
27012:     }
27012: 
27012:     pn->pn_type = TOK_ASSIGN;
27012:     pn->pn_op = JSOP_NOP;
27012:     pn->pn_arity = PN_BINARY;
27012:     pn->pn_used = pn->pn_defn = false;
27012:     pn->pn_left = lhs;
27012:     pn->pn_right = rhs;
27012:     return lhs;
27012: }
27012: 
27012: static JSParseNode *
27012: MakeDefIntoUse(JSDefinition *dn, JSParseNode *pn, JSAtom *atom, JSTreeContext *tc)
27012: {
27012:     /*
27012:      * If dn is var, const, or let, and it has an initializer, then we must
27012:      * rewrite it to be an assignment node, whose freshly allocated left-hand
27012:      * side becomes a use of pn.
27012:      */
27012:     if (dn->isBindingForm()) {
27012:         JSParseNode *rhs = dn->expr();
27012:         if (rhs) {
27012:             JSParseNode *lhs = MakeAssignment(dn, rhs, tc);
27012:             if (!lhs)
27012:                 return NULL;
27012:             //pn->dn_uses = lhs;
27012:             dn = (JSDefinition *) lhs;
27012:         }
27012: 
27012:         dn->pn_op = (js_CodeSpec[dn->pn_op].format & JOF_SET) ? JSOP_SETNAME : JSOP_NAME;
27012:     } else if (dn->kind() == JSDefinition::FUNCTION) {
27012:         JS_ASSERT(dn->isTopLevel());
27012:         JS_ASSERT(dn->pn_op == JSOP_NOP);
27012:         dn->pn_type = TOK_NAME;
27012:         dn->pn_arity = PN_NAME;
27012:         dn->pn_atom = atom;
27012:     }
27012: 
27012:     /* Now make dn no longer a definition, rather a use of pn. */
27012:     JS_ASSERT(dn->pn_type == TOK_NAME);
27012:     JS_ASSERT(dn->pn_arity == PN_NAME);
27012:     JS_ASSERT(dn->pn_atom == atom);
27012: 
27012:     for (JSParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
27012:         JS_ASSERT(pnu->pn_used);
27012:         JS_ASSERT(!pnu->pn_defn);
27012:         pnu->pn_lexdef = (JSDefinition *) pn;
27012:         pn->pn_dflags |= pnu->pn_dflags & (PND_ASSIGNED | PND_FUNARG);
27012:     }
27012:     pn->dn_uses = dn;
27012: 
27012:     dn->pn_defn = false;
27012:     dn->pn_used = true;
27012:     dn->pn_lexdef = (JSDefinition *) pn;
27012:     dn->pn_cookie = FREE_UPVAR_COOKIE;
27012:     dn->pn_dflags &= ~PND_BOUND;
27012:     return dn;
27012: }
27012: 
27012: static bool
27012: DefineArg(JSParseNode *pn, JSAtom *atom, uintN i, JSTreeContext *tc)
27012: {
27012:     JSParseNode *argpn, *argsbody;
27012: 
27012:     /* Flag tc so we don't have to lookup arguments on every use. */
27012:     if (atom == tc->compiler->context->runtime->atomState.argumentsAtom)
27012:         tc->flags |= TCF_FUN_PARAM_ARGUMENTS;
27012: 
27012:     /*
27012:      * Make an argument definition node, distinguished by being in tc->decls
27012:      * but having TOK_NAME type and JSOP_NOP op. Insert it in a TOK_ARGSBODY
27012:      * list node returned via pn->pn_body.
27012:      */
27012:     argpn = NewNameNode(tc->compiler->context, TS(tc->compiler), atom, tc);
27012:     if (!argpn)
27012:         return false;
27012:     JS_ASSERT(PN_TYPE(argpn) == TOK_NAME && PN_OP(argpn) == JSOP_NOP);
27012: 
27012:     /* Arguments are initialized by definition. */
27012:     argpn->pn_dflags |= PND_INITIALIZED;
27012:     if (!Define(argpn, atom, tc))
27012:         return false;
27012: 
27012:     argsbody = pn->pn_body;
27012:     if (!argsbody) {
27012:         argsbody = NewParseNode(PN_LIST, tc);
27012:         if (!argsbody)
27012:             return false;
27012:         argsbody->pn_type = TOK_ARGSBODY;
27012:         argsbody->pn_op = JSOP_NOP;
27012:         argsbody->makeEmpty();
27012:         pn->pn_body = argsbody;
27012:     }
27012:     argsbody->append(argpn);
27012: 
27012:     argpn->pn_op = JSOP_GETARG;
27012:     argpn->pn_cookie = MAKE_UPVAR_COOKIE(tc->staticLevel, i);
27012:     argpn->pn_dflags |= PND_BOUND;
27012:     return true;
27012: }
27012: 
    1: /*
    1:  * Compile a JS function body, which might appear as the value of an event
    1:  * handler attribute in an HTML <INPUT> tag.
    1:  */
27012: bool
27012: JSCompiler::compileFunctionBody(JSContext *cx, JSFunction *fun, JSPrincipals *principals,
 8444:                                 const jschar *chars, size_t length,
 8444:                                 const char *filename, uintN lineno)
    1: {
27012:     JSCompiler jsc(cx, principals);
27012: 
27012:     if (!jsc.init(chars, length, NULL, filename, lineno))
27012:         return false;
27012: 
27012:     /* No early return from after here until the js_FinishArenaPool calls. */
    1:     JSArenaPool codePool, notePool;
 5344:     JS_INIT_ARENA_POOL(&codePool, "code", 1024, sizeof(jsbytecode),
 5344:                        &cx->scriptStackQuota);
 5344:     JS_INIT_ARENA_POOL(&notePool, "note", 1024, sizeof(jssrcnote),
 5344:                        &cx->scriptStackQuota);
27012: 
27012:     JSCodeGenerator funcg(&jsc, &codePool, &notePool, jsc.tokenStream.lineno);
27012:     funcg.flags |= TCF_IN_FUNCTION;
27012:     funcg.fun = fun;
27012:     if (!GenerateBlockId(&funcg, funcg.bodyid))
27012:         return NULL;
27012: 
27012:     /* FIXME: make Function format the source for a function definition. */
27012:     jsc.tokenStream.tokens[0].type = TOK_NAME;
27012:     JSParseNode *fn = NewParseNode(PN_FUNC, &funcg);
27012:     if (fn) {
27012:         fn->pn_body = NULL;
27012:         fn->pn_cookie = FREE_UPVAR_COOKIE;
27012: 
27012:         uintN nargs = fun->nargs;
27012:         if (nargs) {
27012:             jsuword *names = js_GetLocalNameArray(cx, fun, &cx->tempPool);
27012:             if (!names) {
27012:                 fn = NULL;
27012:             } else {
27012:                 for (uintN i = 0; i < nargs; i++) {
27012:                     JSAtom *name = JS_LOCAL_NAME_TO_ATOM(names[i]);
27012:                     if (!DefineArg(fn, name, i, &funcg)) {
27012:                         fn = NULL;
27012:                         break;
27012:                     }
27012:                 }
27012:             }
27012:         }
27012:     }
    1: 
    1:     /*
    1:      * Farble the body so that it looks like a block statement to js_EmitTree,
27012:      * which is called from js_EmitFunctionBody (see jsemit.cpp).  After we're
27012:      * done parsing, we must fold constants, analyze any nested functions, and
27012:      * generate code for this function, including a stop opcode at the end.
27012:      */
27012:     CURRENT_TOKEN(&jsc.tokenStream).type = TOK_LC;
27012:     JSParseNode *pn = fn ? FunctionBody(cx, &jsc.tokenStream, &funcg) : NULL;
    1:     if (pn) {
27012:         if (!js_MatchToken(cx, &jsc.tokenStream, TOK_EOF)) {
27012:             js_ReportCompileErrorNumber(cx, &jsc.tokenStream, NULL,
 8444:                                         JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:             pn = NULL;
27012:         } else if (!js_FoldConstants(cx, pn, &funcg)) {
27012:             /* js_FoldConstants reported the error already. */
27012:             pn = NULL;
27012:         } else if (funcg.functionList &&
27012:                    !jsc.analyzeFunctions(funcg.functionList, funcg.flags)) {
27012:             pn = NULL;
26970:         } else {
27012:             if (fn->pn_body) {
27012:                 JS_ASSERT(PN_TYPE(fn->pn_body) == TOK_ARGSBODY);
27012:                 fn->pn_body->append(pn);
27012:                 pn = fn->pn_body;
27012:             }
27012: 
27012:             if (!js_EmitFunctionScript(cx, &funcg, pn))
26968:                 pn = NULL;
26970:         }
    1:     }
    1: 
    1:     /* Restore saved state and release code generation arenas. */
    1:     JS_FinishArenaPool(&codePool);
    1:     JS_FinishArenaPool(&notePool);
    1:     return pn != NULL;
    1: }
    1: 
    1: /*
    1:  * Parameter block types for the several Binder functions.  We use a common
    1:  * helper function signature in order to share code among destructuring and
    1:  * simple variable declaration parsers.  In the destructuring case, the binder
    1:  * function is called indirectly from the variable declaration parser by way
    1:  * of CheckDestructuring and its friends.
    1:  */
    1: typedef struct BindData BindData;
    1: 
    1: typedef JSBool
    1: (*Binder)(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc);
    1: 
    1: struct BindData {
27012:     JSParseNode     *pn;        /* name node for definition processing and
27012:                                    error source coordinates */
    1:     JSOp            op;         /* prolog bytecode or nop */
    1:     Binder          binder;     /* binder, discriminates u */
    1:     union {
    1:         struct {
    1:             uintN   overflow;
    1:         } let;
27012:     };
    1: };
    1: 
    1: static JSBool
13702: BindLocalVariable(JSContext *cx, JSFunction *fun, JSAtom *atom,
 8444:                   JSLocalKind localKind)
    1: {
 8444:     JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
    1: 
    1:     /*
    1:      * Don't bind a variable with the hidden name 'arguments', per ECMA-262.
    1:      * Instead 'var arguments' always restates the predefined property of the
27012:      * activation objects whose name is 'arguments'. Assignment to such a
27012:      * variable must be handled specially.
    1:      */
    1:     if (atom == cx->runtime->atomState.argumentsAtom)
    1:         return JS_TRUE;
    1: 
 8444:     return js_AddLocal(cx, fun, atom, localKind);
    1: }
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: /*
    1:  * Forward declaration to maintain top-down presentation.
    1:  */
    1: static JSParseNode *
    1: DestructuringExpr(JSContext *cx, BindData *data, JSTreeContext *tc,
    1:                   JSTokenType tt);
    1: 
    1: static JSBool
    1: BindDestructuringArg(JSContext *cx, BindData *data, JSAtom *atom,
    1:                      JSTreeContext *tc)
    1: {
    1:     JSAtomListElement *ale;
27012:     JSParseNode *pn;
    1: 
 8444:     JS_ASSERT(tc->flags & TCF_IN_FUNCTION);
27012:     ale = tc->decls.lookup(atom);
27012:     pn = data->pn;
27012:     if (!ale && !Define(pn, atom, tc))
    1:         return JS_FALSE;
27012: 
27012:     JSLocalKind localKind = js_LookupLocal(cx, tc->fun, atom, NULL);
27012:     if (localKind != JSLOCAL_NONE) {
27012:         js_ReportCompileErrorNumber(cx, TS(tc->compiler), NULL,
26562:                                     JSREPORT_ERROR, JSMSG_DESTRUCT_DUP_ARG);
    1:         return JS_FALSE;
    1:     }
27012: 
27012:     uintN index = tc->fun->u.i.nvars;
27012:     if (!BindLocalVariable(cx, tc->fun, atom, JSLOCAL_VAR))
27012:         return JS_FALSE;
27012:     pn->pn_op = JSOP_SETLOCAL;
27012:     pn->pn_cookie = MAKE_UPVAR_COOKIE(tc->staticLevel, index);
27012:     pn->pn_dflags |= PND_BOUND;
27012:     return JS_TRUE;
    1: }
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
27012: JSFunction *
27012: JSCompiler::newFunction(JSTreeContext *tc, JSAtom *atom, uintN lambda)
 8444: {
 8444:     JSObject *parent;
13702:     JSFunction *fun;
 9481: 
 9481:     JS_ASSERT((lambda & ~JSFUN_LAMBDA) == 0);
27012: 
27012:     /*
27012:      * Find the global compilation context in order to pre-set the newborn
27012:      * function's parent slot to tc->scopeChain. If the global context is a
27012:      * compile-and-go one, we leave the pre-set parent intact; otherwise we
27012:      * clear parent and proto.
27012:      */
27012:     while (tc->parent)
27012:         tc = tc->parent;
27012:     parent = (tc->flags & TCF_IN_FUNCTION) ? NULL : tc->scopeChain;
27012: 
27012:     fun = js_NewFunction(context, NULL, NULL, 0, JSFUN_INTERPRETED | lambda,
13702:                          parent, atom);
27012: 
13691:     if (fun && !(tc->flags & TCF_COMPILE_N_GO)) {
16069:         STOBJ_CLEAR_PARENT(FUN_OBJECT(fun));
16069:         STOBJ_CLEAR_PROTO(FUN_OBJECT(fun));
13691:     }
13691:     return fun;
 8444: }
 8444: 
25110: static JSBool
25110: MatchOrInsertSemicolon(JSContext *cx, JSTokenStream *ts)
25110: {
25110:     JSTokenType tt;
25110: 
25110:     ts->flags |= TSF_OPERAND;
25110:     tt = js_PeekTokenSameLine(cx, ts);
25110:     ts->flags &= ~TSF_OPERAND;
25110:     if (tt == TOK_ERROR)
25110:         return JS_FALSE;
25110:     if (tt != TOK_EOF && tt != TOK_EOL && tt != TOK_SEMI && tt != TOK_RC) {
25110:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
25110:                                     JSMSG_SEMI_BEFORE_STMNT);
25110:         return JS_FALSE;
25110:     }
25110:     (void) js_MatchToken(cx, ts, TOK_SEMI);
25110:     return JS_TRUE;
25110: }
25110: 
27012: bool
27012: JSCompiler::analyzeFunctions(JSFunctionBox *funbox, uint16& tcflags)
27012: {
27012:     if (!markFunArgs(funbox, tcflags))
27012:         return false;
27012:     setFunctionKinds(funbox, tcflags);
27012:     return true;
27012: }
27012: 
27012: /*
27012:  * Mark as funargs any functions that reach up to one or more upvars across an
27012:  * already-known funarg. The parser will flag the o_m lambda as a funarg in:
27012:  *
27012:  *   function f(o, p) {
27012:  *       o.m = function o_m(a) {
27012:  *           function g() { return p; }
27012:  *           function h() { return a; }
27012:  *           return g() + h();
27012:  *       }
27012:  *   }
27012:  *
27012:  * but without this extra marking phase, function g will not be marked as a
27012:  * funarg since it is called from within its parent scope. But g reaches up to
27012:  * f's parameter p, so if o_m escapes f's activation scope, g does too and
27012:  * cannot use JSOP_GETUPVAR to reach p. In contast function h neither escapes
27012:  * nor uses an upvar "above" o_m's level.
27012:  *
27012:  * If function g itself contained lambdas that contained non-lambdas that reach
27012:  * up above its level, then those non-lambdas would have to be marked too. This
27012:  * process is potentially exponential in the number of functions, but generally
27012:  * not so complex. But it can't be done during a single recursive traversal of
27012:  * the funbox tree, so we must use a work queue.
27012:  */
27012: static void
27012: FindFunArgs(JSFunctionBox *funbox, int level, JSFunctionBoxQueue *queue)
27012: {
27012:     do {
27012:         JSParseNode *fn = funbox->node;
27012:         int fnlevel = level;
27012: 
27109:         /*
27109:          * An eval can leak funbox, functions along its ancestor line, and its
27109:          * immediate kids. Since FindFunArgs uses DFS and the parser propagates
27109:          * TCF_FUN_HEAVYWEIGHT bottom up, funbox's ancestor function nodes have
27109:          * already been marked as funargs by this point. Therefore we have to
27109:          * flag only funbox->node and funbox->kids' nodes here.
27109:          */
27109:         if (funbox->tcflags & TCF_FUN_HEAVYWEIGHT) {
27109:             fn->pn_dflags |= PND_FUNARG;
27109:             for (JSFunctionBox *kid = funbox->kids; kid; kid = kid->siblings)
27109:                 kid->node->pn_dflags |= PND_FUNARG;
27109:         }
27109: 
27012:         if (fn->isFunArg()) {
27012:             queue->push(funbox);
27012:             fnlevel = int(funbox->level);
27012:         } else {
27012:             JSParseNode *pn = fn->pn_body;
27012: 
27012:             if (pn->pn_type == TOK_UPVARS) {
27012:                 JSAtomList upvars(pn->pn_names);
27012:                 JS_ASSERT(upvars.count != 0);
27012: 
27012:                 JSAtomListIterator iter(&upvars);
27012:                 JSAtomListElement *ale;
27012: 
27012:                 while ((ale = iter()) != NULL) {
27012:                     JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
27012: 
27012:                     if (!lexdep->isFreeVar() && int(lexdep->frameLevel()) <= fnlevel) {
27012:                         fn->pn_dflags |= PND_FUNARG;
27012:                         queue->push(funbox);
27012:                         break;
27012:                     }
27012:                 }
27012:             }
27012:         }
27012: 
27012:         if (funbox->kids)
27012:             FindFunArgs(funbox->kids, fnlevel, queue);
27012:     } while ((funbox = funbox->siblings) != NULL);
27012: }
27012: 
27012: bool
27012: JSCompiler::markFunArgs(JSFunctionBox *funbox, uintN tcflags)
27012: {
27012:     JSFunctionBoxQueue queue;
27012:     if (!queue.init(functionCount))
27012:         return false;
27012: 
27012:     FindFunArgs(funbox, -1, &queue);
27012:     while ((funbox = queue.pull()) != NULL) {
27012:         JSParseNode *fn = funbox->node;
27012:         JS_ASSERT(fn->isFunArg());
27012: 
27012:         JSParseNode *pn = fn->pn_body;
27012:         if (pn->pn_type == TOK_UPVARS) {
27012:             JSAtomList upvars(pn->pn_names);
27012:             JS_ASSERT(upvars.count != 0);
27012: 
27012:             JSAtomListIterator iter(&upvars);
27012:             JSAtomListElement *ale;
27012: 
27012:             while ((ale = iter()) != NULL) {
27012:                 JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
27012: 
27012:                 if (!lexdep->isFreeVar() &&
27012:                     !lexdep->isFunArg() &&
27012:                     lexdep->kind() == JSDefinition::FUNCTION) {
27012:                     /*
27012:                      * Mark this formerly-Algol-like function as a funarg,
27012:                      * since it is referenced from a funarg and can no longer
27012:                      * use JSOP_{GET,CALL}UPVAR to access upvars.
27012:                      *
27012:                      * Progress is guaranteed since we set PND_FUNARG here,
27012:                      * which suppresses revisiting this function (namely the
27012:                      * !lexdep->isFunArg() test just above).
27012:                      */
27012:                     lexdep->pn_dflags |= PND_FUNARG;
27012: 
27012:                     JSFunctionBox *afunbox = lexdep->pn_funbox;
27012:                     queue.push(afunbox);
27012: 
27012:                     /*
27012:                      * Walk over nested functions again, now that we have
27012:                      * changed the level across which it is unsafe to access
27012:                      * upvars using the runtime dynamic link (frame chain).
27012:                      */
27012:                     if (afunbox->kids)
27012:                         FindFunArgs(afunbox->kids, afunbox->level, &queue);
27012:                 }
27012:             }
27012:         }
27012:     }
27012:     return true;
27012: }
27012: 
27012: static uint32
27012: MinBlockId(JSParseNode *fn, uint32 id)
27012: {
27012:     if (fn->pn_blockid < id)
27012:         return false;
27012:     if (fn->pn_defn) {
27012:         for (JSParseNode *pn = fn->dn_uses; pn; pn = pn->pn_link) {
27012:             if (pn->pn_blockid < id)
27012:                 return false;
27012:         }
27012:     }
27012:     return true;
27012: }
27012: 
27012: static bool
27012: OneBlockId(JSParseNode *fn, uint32 id)
27012: {
27012:     if (fn->pn_blockid != id)
27012:         return false;
27012:     if (fn->pn_defn) {
27012:         for (JSParseNode *pn = fn->dn_uses; pn; pn = pn->pn_link) {
27012:             if (pn->pn_blockid != id)
27012:                 return false;
27012:         }
27012:     }
27012:     return true;
27012: }
27012: 
27012: void
27012: JSCompiler::setFunctionKinds(JSFunctionBox *funbox, uint16& tcflags)
27012: {
27012: #ifdef JS_FUNCTION_METERING
27012: # define FUN_METER(x)   JS_RUNTIME_METER(context->runtime, functionMeter.x)
27012: #else
27012: # define FUN_METER(x)   ((void)0)
27012: #endif
27012:     JSFunctionBox *parent = funbox->parent;
27012: 
27012:     for (;;) {
27012:         JSParseNode *fn = funbox->node;
27012: 
27012:         if (funbox->kids)
27012:             setFunctionKinds(funbox->kids, tcflags);
27012: 
27012:         JSParseNode *pn = fn->pn_body;
27012:         JSFunction *fun = (JSFunction *) funbox->object;
27012: 
27012:         FUN_METER(allfun);
27012:         if (funbox->tcflags & TCF_FUN_HEAVYWEIGHT) {
27012:             FUN_METER(heavy);
27012:             JS_ASSERT(FUN_KIND(fun) == JSFUN_INTERPRETED);
27012:         } else if (pn->pn_type != TOK_UPVARS) {
27012:             /*
27012:              * No lexical dependencies => null closure, for best performance.
27012:              * A null closure needs no scope chain, but alas we've coupled
27012:              * principals-finding to scope (for good fundamental reasons, but
27012:              * the implementation overloads the parent slot and we should fix
27012:              * that). See, e.g., the JSOP_LAMBDA case in jsinterp.cpp.
27012:              *
27012:              * In more detail: the ES3 spec allows the implementation to create
27012:              * "joined function objects", or not, at its discretion. But real-
27012:              * world implementations always create unique function objects for
27012:              * closures, and this can be detected via mutation. Open question:
27012:              * do popular implementations create unique function objects for
27012:              * null closures?
27012:              *
27012:              * FIXME: bug 476950.
27012:              */
27012:             FUN_METER(nofreeupvar);
27012:             FUN_SET_KIND(fun, JSFUN_NULL_CLOSURE);
27012:         } else {
27012:             JSAtomList upvars(pn->pn_names);
27012:             JS_ASSERT(upvars.count != 0);
27012: 
27012:             JSAtomListIterator iter(&upvars);
27012:             JSAtomListElement *ale;
27012: 
27012:             if (!fn->isFunArg()) {
27012:                 /*
27012:                  * This function is Algol-like, it never escapes. So long as it
27012:                  * does not assign to outer variables, it needs only an upvars
27012:                  * array in its script and JSOP_{GET,CALL}UPVAR opcodes in its
27012:                  * bytecode to reach up the frame stack at runtime based on
27012:                  * those upvars' cookies.
27012:                  *
27012:                  * Any assignments to upvars from functions called by this one
27012:                  * will be coherent because of the JSOP_{GET,CALL}UPVAR ops,
27012:                  * which load from stack homes when interpreting or from native
27012:                  * stack slots when executing a trace.
27012:                  *
27012:                  * We could add JSOP_SETUPVAR, etc., but it is uncommon for a
27012:                  * nested function to assign to an outer lexical variable, so
27012:                  * we defer adding yet more code footprint in the absence of
27012:                  * evidence motivating these opcodes.
27012:                  */
27012:                 bool mutation = !!(funbox->tcflags & TCF_FUN_SETS_OUTER_NAME);
27012:                 uintN nupvars = 0;
27012: 
27012:                 /*
27012:                  * Check that at least one outer lexical binding was assigned
27012:                  * to (global variables don't count). This is conservative: we
27012:                  * could limit assignments to those in the current function,
27012:                  * but that's too much work. As with flat closures (handled
27012:                  * below), we optimize for the case where outer bindings are
27012:                  * not reassigned anywhere.
27012:                  */
27012:                 while ((ale = iter()) != NULL) {
27012:                     JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
27012: 
27012:                     if (!lexdep->isFreeVar()) {
27012:                         JS_ASSERT(lexdep->frameLevel() <= funbox->level);
27012:                         ++nupvars;
27012:                         if (lexdep->isAssigned())
27012:                             break;
27012:                     }
27012:                 }
27012:                 if (!ale)
27012:                     mutation = false;
27012: 
27012:                 if (nupvars == 0) {
27012:                     FUN_METER(onlyfreevar);
27012:                     FUN_SET_KIND(fun, JSFUN_NULL_CLOSURE);
27012:                 } else if (!mutation && !(funbox->tcflags & TCF_FUN_IS_GENERATOR)) {
27012:                     /*
27012:                      * Algol-like functions can read upvars using the dynamic
27012:                      * link (cx->fp/fp->down). They do not need to entrain and
27012:                      * search their environment.
27012:                      */
27012:                     FUN_METER(display);
27012:                     FUN_SET_KIND(fun, JSFUN_NULL_CLOSURE);
27012:                 } else {
27012:                     if (!(funbox->tcflags & TCF_FUN_IS_GENERATOR))
27012:                         FUN_METER(setupvar);
27012:                 }
27012:             } else {
27012:                 uintN nupvars = 0;
27012: 
27012:                 /*
27012:                  * For each lexical dependency from this closure to an outer
27012:                  * binding, analyze whether it is safe to copy the binding's
27012:                  * value into a flat closure slot when the closure is formed.
27012:                  */
27012:                 while ((ale = iter()) != NULL) {
27012:                     JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
27012: 
27012:                     if (!lexdep->isFreeVar()) {
27012:                         ++nupvars;
27012: 
27012:                         /*
27012:                          * Consider the current function (the lambda, innermost
27012:                          * below) using a var x defined two static levels up:
27012:                          *
27012:                          *  function f() {
27012:                          *      // z = g();
27012:                          *      var x = 42;
27012:                          *      function g() {
27012:                          *          return function () { return x; };
27012:                          *      }
27012:                          *      return g();
27012:                          *  }
27012:                          *
27012:                          * So long as (1) the initialization in 'var x = 42'
27012:                          * dominates all uses of g and (2) x is not reassigned,
27012:                          * it is safe to optimize the lambda to a flat closure.
27012:                          * Uncommenting the early call to g makes it unsafe to
27012:                          * so optimize (z could name a global setter that calls
27012:                          * its argument).
27012:                          */
27012:                         JSFunctionBox *afunbox = funbox;
27012:                         uintN lexdepLevel = lexdep->frameLevel();
27012: 
27012:                         JS_ASSERT(lexdepLevel <= funbox->level);
27012:                         while (afunbox->level != lexdepLevel) {
27012:                             afunbox = afunbox->parent;
27012: 
27012:                             /*
27012:                              * We can't form a flat closure that reaches up
27012:                              * across a funarg that encloses the closure, or
27012:                              * into the top level (to a 'let' variable in an
27012:                              * enclosing block in global code; this is the
27012:                              * !afunbox case).
27012:                              */
27012:                             if (!afunbox || afunbox->node->isFunArg()) {
27012:                                 JS_ASSERT_IF(!afunbox,
27012:                                              lexdep->isLet() ||
27012:                                              (!(tcflags & TCF_IN_FUNCTION) &&
27012:                                               callerFrame && callerFrame->fun));
27012:                                 goto break2;
27012:                             }
27012:                         }
27012: 
27012:                         /*
27012:                          * If afunbox's function (which is at the same level as
27012:                          * lexdep) is not a lambda, it will be hoisted, so it
27012:                          * could capture the undefined value that by default
27012:                          * initializes var/let/const bindings. And if lexdep is
27012:                          * a function that comes at (meaning a function refers
27012:                          * to its own name) or strictly after afunbox, we also
27012:                          * break to defeat the flat closure optimization.
27012:                          */
27012:                         JSFunction *afun = (JSFunction *) afunbox->object;
27012:                         if (!(afun->flags & JSFUN_LAMBDA)) {
27012:                             if (lexdep->isBindingForm())
27012:                                 break;
27012:                             if (lexdep->pn_pos >= afunbox->node->pn_pos)
27012:                                 break;
27012:                         }
27012: 
27012:                         if (!lexdep->isInitialized())
27012:                             break;
27012: 
27012:                         JSDefinition::Kind lexdepKind = lexdep->kind();
27012:                         if (lexdepKind != JSDefinition::CONST) {
27012:                             if (lexdep->isAssigned())
27012:                                 break;
27012: 
27012:                             /*
27012:                              * Any formal could be mutated behind our back via
27012:                              * the arguments object, so deoptimize if the outer
27012:                              * function uses arguments.
27012:                              *
27012:                              * In a Function constructor call where the final
27012:                              * argument -- the body source for the function to
27012:                              * create -- contains a nested function definition
27012:                              * or expression, afunbox->parent will be null. The
27012:                              * body source might use |arguments| outside of any
27012:                              * nested functions it may contain, so we have to
27012:                              * check the tcflags parameter that was passed in
27012:                              * from JSCompiler::compileFunctionBody.
27012:                              */
27012:                             if (lexdepKind == JSDefinition::ARG &&
27012:                                 ((afunbox->parent ? afunbox->parent->tcflags : tcflags) &
27012:                                  TCF_FUN_USES_ARGUMENTS)) {
27012:                                 break;
27012:                             }
27012:                         }
27012: 
27012:                         /*
27012:                          * Check quick-and-dirty dominance relation. Function
27012:                          * definitions dominate their uses thanks to hoisting.
27012:                          * Other binding forms hoist as undefined, of course,
27012:                          * so check forward-reference and blockid relations.
27012:                          */
27012:                         if (lexdepKind != JSDefinition::FUNCTION) {
27012:                             if (lexdep->isForward())
27012:                                 break;
27012: 
27012:                             /*
27012:                              * Watch out for code such as
27012:                              * 
27012:                              *   (function () {
27012:                              *   ...
27012:                              *   var jQuery = ... = function (...) {
27012:                              *       return new jQuery.foo.bar(baz);
27012:                              *   }
27012:                              *   ...
27012:                              *   })();
27012:                              *
27012:                              * where the jQuery var is not reassigned, but of
27012:                              * course is not initialized at the time that the
27012:                              * would-be-flat closure containing the jQuery
27012:                              * upvar is formed.
27012:                              */
27012:                             if (lexdep->pn_pos.end >= afunbox->node->pn_pos.end)
27012:                                 break;
27012: 
27012:                             if (lexdep->isTopLevel()
27012:                                 ? !MinBlockId(afunbox->node, lexdep->pn_blockid)
27012:                                 : !lexdep->isBlockChild() ||
27012:                                   !afunbox->node->isBlockChild() ||
27012:                                   !OneBlockId(afunbox->node, lexdep->pn_blockid)) {
27012:                                 break;
27012:                             }
27012:                         }
27012:                     }
27012:                 }
27012: 
27012:               break2:
27012:                 if (nupvars == 0) {
27012:                     FUN_METER(onlyfreevar);
27012:                     FUN_SET_KIND(fun, JSFUN_NULL_CLOSURE);
27012:                 } else if (!ale) {
27012:                     /*
27012:                      * We made it all the way through the upvar loop, so it's
27012:                      * safe to optimize to a flat closure.
27012:                      */
27012:                     FUN_METER(flat);
27012:                     FUN_SET_KIND(fun, JSFUN_FLAT_CLOSURE);
27012:                     switch (PN_OP(fn)) {
27012:                       case JSOP_DEFFUN:
27012:                         fn->pn_op = JSOP_DEFFUN_FC;
27012:                         break;
27012:                       case JSOP_DEFLOCALFUN:
27012:                         fn->pn_op = JSOP_DEFLOCALFUN_FC;
27012:                         break;
27012:                       case JSOP_LAMBDA:
27012:                         fn->pn_op = JSOP_LAMBDA_FC;
27012:                         break;
27012:                       default:
27012:                         /* js_EmitTree's case TOK_FUNCTION: will select op. */
27012:                         JS_ASSERT(PN_OP(fn) == JSOP_NOP);
27012:                     }
27012:                 } else {
27012:                     FUN_METER(badfunarg);
27012:                 }
27012:             }
27012:         }
27012: 
27012:         if (FUN_KIND(fun) == JSFUN_INTERPRETED) {
27012:             if (pn->pn_type != TOK_UPVARS) {
27012:                 if (parent)
27012:                     parent->tcflags |= TCF_FUN_HEAVYWEIGHT;
27012:             } else {
27012:                 JSAtomList upvars(pn->pn_names);
27012:                 JS_ASSERT(upvars.count != 0);
27012: 
27012:                 JSAtomListIterator iter(&upvars);
27012:                 JSAtomListElement *ale;
27012: 
27012:                 /*
27012:                  * One or more upvars cannot be safely snapshot into a flat
27012:                  * closure's dslot (see JSOP_GETDSLOT), so we loop again over
27012:                  * all upvars, and for each non-free upvar, ensure that its
27012:                  * containing function has been flagged as heavyweight.
27012:                  *
27012:                  * The emitter must see TCF_FUN_HEAVYWEIGHT accurately before
27012:                  * generating any code for a tree of nested functions.
27012:                  */
27012:                 while ((ale = iter()) != NULL) {
27012:                     JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
27012: 
27012:                     if (!lexdep->isFreeVar()) {
27012:                         JSFunctionBox *afunbox = funbox->parent;
27012:                         uintN lexdepLevel = lexdep->frameLevel();
27012: 
27012:                         if (!afunbox) {
27012:                             if (tcflags & TCF_IN_FUNCTION)
27012:                                 tcflags |= TCF_FUN_HEAVYWEIGHT;
27012:                         } else {
27012:                             do {
27012:                                 /*
27012:                                  * NB: afunbox->level is the static level of
27012:                                  * the definition or expression of the function
27012:                                  * parsed into afunbox, not the static level of
27012:                                  * its body. Therefore we must add 1 to match
27012:                                  * lexdep's level to find the afunbox whose
27012:                                  * body contains the lexdep definition.
27012:                                  */
27012:                                 if (afunbox->level + 1U == lexdepLevel) {
27012:                                     afunbox->tcflags |= TCF_FUN_HEAVYWEIGHT;
27012:                                     break;
27012:                                 }
27012:                             } while ((afunbox = afunbox->parent) != NULL);
27012:                         }
27012:                     }
27012:                 }
27012:             }
27012:         }
27012: 
27012:         funbox = funbox->siblings;
27012:         if (!funbox)
27012:             break;
27012:         JS_ASSERT(funbox->parent == parent);
27012:     }
27012: #undef FUN_METER
27012: }
27012: 
27012: const char js_argument_str[] = "argument";
27012: const char js_variable_str[] = "variable";
27012: const char js_unknown_str[]  = "unknown";
27012: 
27012: const char *
27012: JSDefinition::kindString(Kind kind)
27012: {
27012:     static const char *table[] = {
27012:         js_var_str, js_const_str, js_let_str,
27012:         js_function_str, js_argument_str, js_unknown_str
27012:     };
27012: 
27012:     JS_ASSERT(unsigned(kind) <= unsigned(ARG));
27012:     return table[kind];
27012: }
27012: 
27012: static JSFunctionBox *
27012: EnterFunction(JSParseNode *fn, JSTreeContext *tc, JSTreeContext *funtc,
27012:               JSAtom *funAtom = NULL, uintN lambda = JSFUN_LAMBDA)
27012: {
27012:     JSFunction *fun = tc->compiler->newFunction(tc, funAtom, lambda);
27012:     if (!fun)
27012:         return NULL;
27012: 
27012:     /* Create box for fun->object early to protect against last-ditch GC. */
27012:     JSFunctionBox *funbox = tc->compiler->newFunctionBox(FUN_OBJECT(fun), fn, tc);
27012:     if (!funbox)
27012:         return NULL;
27012: 
27012:     /* Initialize non-default members of funtc. */
27012:     funtc->flags |= funbox->tcflags;
27012:     funtc->blockidGen = tc->blockidGen;
27012:     if (!GenerateBlockId(funtc, funtc->bodyid))
27012:         return NULL;
27012:     funtc->fun = fun;
27012:     funtc->funbox = funbox;
27012:     funtc->parent = tc;
27012:     if (!SetStaticLevel(funtc, tc->staticLevel + 1))
27012:         return NULL;
27012: 
27012:     return funbox;
27012: }
27012: 
27012: static bool
27012: LeaveFunction(JSParseNode *fn, JSTreeContext *funtc, JSTreeContext *tc,
27012:               JSAtom *funAtom = NULL, uintN lambda = JSFUN_LAMBDA)
27012: {
27012:     tc->blockidGen = funtc->blockidGen;
27012: 
27012:     fn->pn_funbox->tcflags |= funtc->flags & (TCF_FUN_FLAGS | TCF_COMPILE_N_GO);
27012: 
27012:     fn->pn_dflags |= PND_INITIALIZED;
27012:     JS_ASSERT_IF(tc->atTopLevel() && lambda == 0 && funAtom,
27012:                  fn->pn_dflags & PND_TOPLEVEL);
27012:     if (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)
27012:         fn->pn_dflags |= PND_BLOCKCHILD;
27012: 
27012:     /*
27012:      * Propagate unresolved lexical names up to tc->lexdeps, and save a copy
27012:      * of funtc->upvars in a TOK_UPVARS node wrapping the function's formal
27012:      * params and body. We do this only if there are lexical dependencies or
27012:      * upvars, to avoid penalizing functions that use only their arguments.
27012:      */
27012:     if (funtc->lexdeps.count != 0) {
27012:         JSAtomListIterator iter(&funtc->lexdeps);
27012:         JSAtomListElement *ale;
27012: 
27012:         while ((ale = iter()) != NULL) {
27012:             JSAtom *atom = ALE_ATOM(ale);
27012:             JSDefinition *dn = ALE_DEFN(ale);
27012:             JS_ASSERT(dn->isPlaceholder());
27012: 
27012:             if (atom == funAtom && lambda != 0) {
27012:                 dn->pn_op = JSOP_CALLEE;
27012:                 dn->pn_cookie = MAKE_UPVAR_COOKIE(funtc->staticLevel, 0);
27012:                 dn->pn_dflags |= PND_BOUND;
27068: 
27068:                 /*
27068:                  * If this named function expression uses its own name other
27068:                  * than to call itself, flag this function as using arguments,
27068:                  * as if it had used arguments.callee instead of its own name.
27068:                  *
27068:                  * This abuses the plain sense of TCF_FUN_USES_ARGUMENTS, but
27068:                  * we are out of tcflags bits at the moment. If it deoptimizes
27068:                  * code unfairly (see JSCompiler::setFunctionKinds, where this
27068:                  * flag is interpreted in its broader sense, not only to mean
27068:                  * "this function might leak arguments.callee"), we can perhaps
27068:                  * try to work harder to add a TCF_FUN_CALLS_ITSELF flag and
27068:                  * use that more precisely, both here and for unnamed function
27068:                  * expressions.
27068:                  */
27068:                 if (dn->isFunArg())
27068:                     fn->pn_funbox->tcflags |= TCF_FUN_USES_ARGUMENTS;
27012:                 continue;
27012:             }
27012: 
27012:             if (!(fn->pn_funbox->tcflags & TCF_FUN_SETS_OUTER_NAME) &&
27012:                 dn->isAssigned()) {
27012:                 /*
27012:                  * Make sure we do not fail to set TCF_FUN_SETS_OUTER_NAME if
27012:                  * any use of dn in funtc assigns. See NoteLValue for the easy
27012:                  * backward-reference case; this is the hard forward-reference
27012:                  * case where we pay a higher price.
27012:                  */
27012:                 for (JSParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
27012:                     if (pnu->isAssigned() && pnu->pn_blockid >= funtc->bodyid) {
27012:                         fn->pn_funbox->tcflags |= TCF_FUN_SETS_OUTER_NAME;
27012:                         break;
27012:                     }
27012:                 }
27012:             }
27012: 
27012:             JSAtomListElement *outer_ale = tc->lexdeps.lookup(atom);
27012:             if (outer_ale) {
27012:                 /*
27012:                  * Insert dn's uses list at the front of outer_dn's list.
27012:                  *
27012:                  * Without loss of generality or correctness, we allow a dn to
27012:                  * be in inner and outer lexdeps, since the purpose of lexdeps
27012:                  * is one-pass coordination of name use and definition across
27012:                  * functions, and if different dn's are used we'll merge lists
27012:                  * when leaving the inner function.
27012:                  *
27012:                  * The dn == outer_dn case arises with generator expressions
27012:                  * (see CompExprTransplanter::transplant, the PN_FUNC/PN_NAME
27012:                  * case), and nowhere else, currently.
27012:                  */
27012:                 JSDefinition *outer_dn = ALE_DEFN(outer_ale);
27012: 
27012:                 if (dn != outer_dn) {
27012:                     JSParseNode **pnup = &dn->dn_uses;
27012:                     JSParseNode *pnu;
27012: 
27012:                     while ((pnu = *pnup) != NULL) {
27012:                         pnu->pn_lexdef = outer_dn;
27012:                         pnup = &pnu->pn_link;
27012:                     }
27012: 
27012:                     /*
27012:                      * Make dn be a use that redirects to outer_dn, because we
27012:                      * can't replace dn with outer_dn in all the pn_namesets in
27012:                      * the AST where it may be. Instead we make it forward to
27012:                      * outer_dn. See JSDefinition::resolve.
27012:                      */
27012:                     *pnup = outer_dn->dn_uses;
27012:                     outer_dn->dn_uses = dn;
27012:                     outer_dn->pn_dflags |= dn->pn_dflags;
27012:                     dn->pn_defn = false;
27012:                     dn->pn_used = true;
27012:                     dn->pn_lexdef = outer_dn;
27012:                 }
27012:             } else {
27012:                 /* Add an outer lexical dependency for ale's definition. */
27012:                 outer_ale = tc->lexdeps.add(tc->compiler, atom);
27012:                 if (!outer_ale)
27012:                     return false;
27012:                 ALE_SET_DEFN(outer_ale, ALE_DEFN(ale));
27012:             }
27012:         }
27012: 
27012:         funtc->lexdeps.clear();
27012:     }
27012: 
27012:     if (funtc->upvars.count != 0) {
27012:         JSParseNode *body = fn->pn_body;
27012: 
27012:         fn->pn_body = NewParseNode(PN_NAMESET, tc);
27012:         if (!fn->pn_body)
27012:             return false;
27012:         fn->pn_body->pn_type = TOK_UPVARS;
27109:         fn->pn_body->pn_pos = body->pn_pos;
27012:         fn->pn_body->pn_names = funtc->upvars;
27012:         fn->pn_body->pn_tree = body;
27012:         funtc->upvars.clear();
27012:     }
27012: 
27012:     return true;
27012: }
27012: 
    1: static JSParseNode *
    1: FunctionDef(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
 9481:             uintN lambda)
    1: {
27012:     JSOp op;
    1:     JSParseNode *pn, *body, *result;
    1:     JSTokenType tt;
 3235:     JSAtom *funAtom;
    1:     JSAtomListElement *ale;
    1: #if JS_HAS_DESTRUCTURING
    1:     JSParseNode *item, *list = NULL;
26562:     bool destructuringArg = false, duplicatedArg = false;
    1: #endif
    1: 
    1:     /* Make a TOK_FUNCTION node. */
    1: #if JS_HAS_GETTER_SETTER
    1:     op = CURRENT_TOKEN(ts).t_op;
    1: #endif
27012:     pn = NewParseNode(PN_FUNC, tc);
    1:     if (!pn)
    1:         return NULL;
27012:     pn->pn_body = NULL;
27012:     pn->pn_cookie = FREE_UPVAR_COOKIE;
27012: 
27012:     /*
27012:      * If a lambda, give up on JSOP_{GET,CALL}UPVAR usage unless this function
27012:      * is immediately applied (we clear PND_FUNARG if so -- see MemberExpr).
27012:      *
27012:      * Also treat function sub-statements (non-lambda, non-top-level functions)
27012:      * as escaping funargs, since we can't statically analyze their definitions
27012:      * and uses.
27012:      */
27012:     bool topLevel = tc->atTopLevel();
27012:     pn->pn_dflags = (lambda || !topLevel) ? PND_FUNARG : 0;
    1: 
    1:     /* Scan the optional function name into funAtom. */
    1:     ts->flags |= TSF_KEYWORD_IS_NAME;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:     if (tt == TOK_NAME) {
    1:         funAtom = CURRENT_TOKEN(ts).t_atom;
    1:     } else {
 9481:         if (lambda == 0 && (cx->options & JSOPTION_ANONFUNFIX)) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
  399:                                         JSMSG_SYNTAX_ERROR);
  399:             return NULL;
  399:         }
    1:         funAtom = NULL;
    1:         js_UngetToken(ts);
    1:     }
    1: 
    1:     /*
    1:      * Record names for function statements in tc->decls so we know when to
    1:      * avoid optimizing variable references that might name a function.
    1:      */
 9481:     if (lambda == 0 && funAtom) {
27012:         ale = tc->decls.lookup(funAtom);
    1:         if (ale) {
27012:             JSDefinition *dn = ALE_DEFN(ale);
27012:             JSDefinition::Kind dn_kind = dn->kind();
27012: 
27012:             JS_ASSERT(!dn->pn_used);
27012:             JS_ASSERT(dn->pn_defn);
27012: 
27012:             if (JS_HAS_STRICT_OPTION(cx) || dn_kind == JSDefinition::CONST) {
    1:                 const char *name = js_AtomToPrintableString(cx, funAtom);
    1:                 if (!name ||
 7984:                     !js_ReportCompileErrorNumber(cx, ts, NULL,
27012:                                                  (dn_kind != JSDefinition::CONST)
27012:                                                  ? JSREPORT_WARNING | JSREPORT_STRICT
 7984:                                                  : JSREPORT_ERROR,
    1:                                                  JSMSG_REDECLARED_VAR,
27012:                                                  JSDefinition::kindString(dn_kind),
    1:                                                  name)) {
    1:                     return NULL;
    1:                 }
    1:             }
27012: 
27012:             if (topLevel) {
27012:                 ALE_SET_DEFN(ale, pn);
27012:                 pn->pn_defn = true;
27012:                 pn->dn_uses = dn;               /* dn->dn_uses is now pn_link */
27012: 
27012:                 if (!MakeDefIntoUse(dn, pn, funAtom, tc))
27012:                     return NULL;
27012:             }
27012:         } else if (topLevel) {
27012:             /*
27012:              * If this function was used before it was defined, claim the
27012:              * pre-created definition node for this function that PrimaryExpr
27012:              * put in tc->lexdeps on first forward reference, and recycle pn.
27012:              */
27012:             JSHashEntry **hep;
27012: 
27012:             ale = tc->lexdeps.rawLookup(funAtom, hep);
27012:             if (ale) {
27012:                 JSDefinition *fn = ALE_DEFN(ale);
27012: 
27012:                 JS_ASSERT(fn->pn_defn);
27012:                 fn->pn_type = TOK_FUNCTION;
27012:                 fn->pn_arity = PN_FUNC;
27012:                 fn->pn_pos.begin = pn->pn_pos.begin;
27012:                 fn->pn_body = NULL;
27012:                 fn->pn_cookie = FREE_UPVAR_COOKIE;
27012: 
27012:                 tc->lexdeps.rawRemove(tc->compiler, ale, hep);
27012:                 tc->upvars.remove(tc->compiler, funAtom);
27012:                 RecycleTree(pn, tc);
27012:                 pn = fn;
27012:             }
27012: 
27012:             if (!Define(pn, funAtom, tc))
27012:                 return NULL;
27012:         }
    1: 
    1:         /*
    1:          * A function nested at top level inside another's body needs only a
    1:          * local variable to bind its name to its value, and not an activation
    1:          * object property (it might also need the activation property, if the
    1:          * outer function contains with statements, e.g., but the stack slot
    1:          * wins when jsemit.c's BindNameToSlot can optimize a JSOP_NAME into a
16429:          * JSOP_GETLOCAL bytecode).
    1:          */
27012:         if (topLevel) {
27012:             pn->pn_dflags |= PND_TOPLEVEL;
27012: 
27012:             if (tc->flags & TCF_IN_FUNCTION) {
 8179:                 JSLocalKind localKind;
27012:                 uintN index;
27012: 
27012:                 /*
27012:                  * Define a local in the outer function so that BindNameToSlot
27012:                  * can properly optimize accesses. Note that we need a local
27012:                  * variable, not an argument, for the function statement. Thus
27012:                  * we add a variable even if a parameter with the given name
27012:                  * already exists.
27012:                  */
27012:                 localKind = js_LookupLocal(cx, tc->fun, funAtom, &index);
27012:                 switch (localKind) {
27012:                   case JSLOCAL_NONE:
27012:                   case JSLOCAL_ARG:
27012:                     index = tc->fun->u.i.nvars;
27012:                     if (!js_AddLocal(cx, tc->fun, funAtom, JSLOCAL_VAR))
27012:                         return NULL;
27012:                     /* FALL THROUGH */
27012: 
27012:                   case JSLOCAL_VAR:
27012:                     pn->pn_cookie = MAKE_UPVAR_COOKIE(tc->staticLevel, index);
27012:                     pn->pn_dflags |= PND_BOUND;
27012:                     break;
27012: 
27012:                   default:;
27012:                 }
27012:             }
27012:         }
27012:     }
27012: 
27012:     /* Initialize early for possible flags mutation via DestructuringExpr. */
27012:     JSTreeContext funtc(tc->compiler);
27012: 
27012:     JSFunctionBox *funbox = EnterFunction(pn, tc, &funtc, funAtom, lambda);
27012:     if (!funbox)
27012:         return NULL;
27012: 
27012:     JSFunction *fun = (JSFunction *) funbox->object;
 8179: 
    1: #if JS_HAS_GETTER_SETTER
    1:     if (op != JSOP_NOP)
    1:         fun->flags |= (op == JSOP_GETTER) ? JSPROP_GETTER : JSPROP_SETTER;
    1: #endif
    1: 
    1:     /* Now parse formal argument list and compute fun->nargs. */
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_FORMAL);
    1:     if (!js_MatchToken(cx, ts, TOK_RP)) {
    1:         do {
    1:             tt = js_GetToken(cx, ts);
    1:             switch (tt) {
    1: #if JS_HAS_DESTRUCTURING
    1:               case TOK_LB:
    1:               case TOK_LC:
    1:               {
 8444:                 BindData data;
    1:                 JSParseNode *lhs, *rhs;
    1:                 jsint slot;
    1: 
26562:                 /* See comment below in the TOK_NAME case. */
26562:                 if (duplicatedArg)
26562:                     goto report_dup_and_destructuring;
26562:                 destructuringArg = true;
26562: 
    1:                 /*
    1:                  * A destructuring formal parameter turns into one or more
    1:                  * local variables initialized from properties of a single
    1:                  * anonymous positional parameter, so here we must tweak our
    1:                  * binder and its data.
    1:                  */
 8444:                 data.pn = NULL;
    1:                 data.op = JSOP_DEFVAR;
    1:                 data.binder = BindDestructuringArg;
    1:                 lhs = DestructuringExpr(cx, &data, &funtc, tt);
    1:                 if (!lhs)
    1:                     return NULL;
    1: 
    1:                 /*
    1:                  * Adjust fun->nargs to count the single anonymous positional
    1:                  * parameter that is to be destructured.
    1:                  */
    1:                 slot = fun->nargs;
13691:                 if (!js_AddLocal(cx, fun, NULL, JSLOCAL_ARG))
    1:                     return NULL;
    1: 
    1:                 /*
    1:                  * Synthesize a destructuring assignment from the single
    1:                  * anonymous positional parameter into the destructuring
    1:                  * left-hand-side expression and accumulate it in list.
    1:                  */
27012:                 rhs = NewNameNode(cx, ts, cx->runtime->atomState.emptyAtom, &funtc);
    1:                 if (!rhs)
    1:                     return NULL;
    1:                 rhs->pn_type = TOK_NAME;
    1:                 rhs->pn_op = JSOP_GETARG;
27012:                 rhs->pn_cookie = MAKE_UPVAR_COOKIE(funtc.staticLevel, slot);
27012:                 rhs->pn_dflags |= PND_BOUND;
27012: 
27012:                 item = NewBinary(TOK_ASSIGN, JSOP_NOP, lhs, rhs, &funtc);
    1:                 if (!item)
    1:                     return NULL;
    1:                 if (!list) {
27012:                     list = NewParseNode(PN_LIST, &funtc);
    1:                     if (!list)
    1:                         return NULL;
    1:                     list->pn_type = TOK_COMMA;
27012:                     list->makeEmpty();
27012:                 }
27012:                 list->append(item);
    1:                 break;
    1:               }
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
    1:               case TOK_NAME:
26562:               {
26562:                 /*
26562:                  * Check for a duplicate parameter name, a "feature" that
27012:                  * ECMA-262 requires. This is a SpiderMonkey strict warning,
27012:                  * soon to be an ES3.1 strict error.
27012:                  *
27012:                  * Further, if any argument is a destructuring pattern, forbid
27012:                  * duplicates. We will report the error either now if we have
27012:                  * seen a destructuring pattern already, or later when we find
27012:                  * the first pattern.
26562:                  */
26562:                 JSAtom *atom = CURRENT_TOKEN(ts).t_atom;
27012:                 if (JS_HAS_STRICT_OPTION(cx) &&
27012:                     js_LookupLocal(cx, fun, atom, NULL) != JSLOCAL_NONE) {
26562: #if JS_HAS_DESTRUCTURING
26562:                     if (destructuringArg)
26562:                         goto report_dup_and_destructuring;
26562:                     duplicatedArg = true;
26562: #endif
26562:                     const char *name = js_AtomToPrintableString(cx, atom);
26562:                     if (!name ||
27012:                         !js_ReportCompileErrorNumber(cx, TS(funtc.compiler),
26562:                                                      NULL,
26562:                                                      JSREPORT_WARNING |
26562:                                                      JSREPORT_STRICT,
26562:                                                      JSMSG_DUPLICATE_FORMAL,
26562:                                                      name)) {
26562:                         return NULL;
26562:                     }
26562:                 }
27012:                 if (!DefineArg(pn, atom, fun->nargs, &funtc))
27012:                     return NULL;
26562:                 if (!js_AddLocal(cx, fun, atom, JSLOCAL_ARG))
    1:                     return NULL;
    1:                 break;
26562:               }
    1: 
    1:               default:
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_MISSING_FORMAL);
27012:                 /* FALL THROUGH */
27012:               case TOK_ERROR:
    1:                 return NULL;
26562: 
26562: #if JS_HAS_DESTRUCTURING
26562:               report_dup_and_destructuring:
27012:                 js_ReportCompileErrorNumber(cx, TS(tc->compiler), NULL,
26562:                                             JSREPORT_ERROR,
26562:                                             JSMSG_DESTRUCT_DUP_ARG);
26562:                 return NULL;
26562: #endif
    1:             }
    1:         } while (js_MatchToken(cx, ts, TOK_COMMA));
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FORMAL);
    1:     }
    1: 
 1967: #if JS_HAS_EXPR_CLOSURES
 1967:     ts->flags |= TSF_OPERAND;
 1967:     tt = js_GetToken(cx, ts);
 1967:     ts->flags &= ~TSF_OPERAND;
 1967:     if (tt != TOK_LC) {
 1967:         js_UngetToken(ts);
 1967:         fun->flags |= JSFUN_EXPR_CLOSURE;
 1967:     }
 1967: #else
    1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_BODY);
 1967: #endif
    1: 
 8444:     body = FunctionBody(cx, ts, &funtc);
    1:     if (!body)
    1:         return NULL;
    1: 
 1967: #if JS_HAS_EXPR_CLOSURES
 1967:     if (tt == TOK_LC)
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
25110:     else if (lambda == 0 && !MatchOrInsertSemicolon(cx, ts))
25110:         return NULL;
 1967: #else
 1967:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
 1967: #endif
    1:     pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:     /*
    1:      * If there were destructuring formal parameters, prepend the initializing
    1:      * comma expression that we synthesized to body.  If the body is a lexical
20413:      * scope node, we must make a special TOK_SEQ node, to prepend the formal
    1:      * parameter destructuring code without bracing the decompilation of the
    1:      * function body's lexical scope.
    1:      */
    1:     if (list) {
    1:         if (body->pn_arity != PN_LIST) {
    1:             JSParseNode *block;
    1: 
27012:             block = NewParseNode(PN_LIST, tc);
    1:             if (!block)
    1:                 return NULL;
20413:             block->pn_type = TOK_SEQ;
    1:             block->pn_pos = body->pn_pos;
27012:             block->initList(body);
    1: 
    1:             body = block;
    1:         }
    1: 
27012:         item = NewParseNode(PN_UNARY, tc);
    1:         if (!item)
    1:             return NULL;
    1: 
    1:         item->pn_type = TOK_SEMI;
    1:         item->pn_pos.begin = item->pn_pos.end = body->pn_pos.begin;
    1:         item->pn_kid = list;
    1:         item->pn_next = body->pn_head;
    1:         body->pn_head = item;
    1:         if (body->pn_tail == &body->pn_head)
    1:             body->pn_tail = &item->pn_next;
    1:         ++body->pn_count;
27012:         body->pn_xflags |= PNX_DESTRUCT;
    1:     }
    1: #endif
    1: 
    1:     /*
    1:      * If we collected flags that indicate nested heavyweight functions, or
27012:      * this function contains heavyweight-making statements (with statement,
27012:      * visible eval call, or assignment to 'arguments'), flag the function as
27012:      * heavyweight (requiring a call object per invocation).
    1:      */
    1:     if (funtc.flags & TCF_FUN_HEAVYWEIGHT) {
    1:         fun->flags |= JSFUN_HEAVYWEIGHT;
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:     } else {
    1:         /*
    1:          * If this function is a named statement function not at top-level
27012:          * (i.e. not a top-level function definiton or expression), then our
27012:          * enclosing function, if any, must be heavyweight.
27012:          */
27012:         if (!topLevel && lambda == 0 && funAtom)
    1:             tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:     }
    1: 
    1:     result = pn;
 9481:     if (lambda != 0) {
    1:         /*
    1:          * ECMA ed. 3 standard: function expression, possibly anonymous.
    1:          */
27012:         op = JSOP_LAMBDA;
    1:     } else if (!funAtom) {
    1:         /*
    1:          * If this anonymous function definition is *not* embedded within a
    1:          * larger expression, we treat it as an expression statement, not as
    1:          * a function declaration -- and not as a syntax error (as ECMA-262
 1967:          * Edition 3 would have it).  Backward compatibility must trump all,
 1967:          * unless JSOPTION_ANONFUNFIX is set.
    1:          */
27012:         result = NewParseNode(PN_UNARY, tc);
    1:         if (!result)
    1:             return NULL;
    1:         result->pn_type = TOK_SEMI;
    1:         result->pn_pos = pn->pn_pos;
    1:         result->pn_kid = pn;
27012:         op = JSOP_LAMBDA;
27012:     } else if (!topLevel) {
    1:         /*
    1:          * ECMA ed. 3 extension: a function expression statement not at the
    1:          * top level, e.g., in a compound statement such as the "then" part
    1:          * of an "if" statement, binds a closure only if control reaches that
    1:          * sub-statement.
    1:          */
18965:         op = JSOP_DEFFUN;
    1:     } else {
    1:         op = JSOP_NOP;
    1:     }
    1: 
27012:     funbox->kids = funtc.functionList;
27012: 
27012:     pn->pn_funbox = funbox;
    1:     pn->pn_op = op;
27012:     if (pn->pn_body)
27012:         pn->pn_body->append(body);
27012:     else
    1:         pn->pn_body = body;
27012: 
27012:     pn->pn_blockid = tc->blockid();
27012: 
27012:     if (!LeaveFunction(pn, &funtc, tc, funAtom, lambda))
27012:         return NULL;
27012: 
    1:     return result;
    1: }
    1: 
    1: static JSParseNode *
    1: FunctionStmt(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
 9481:     return FunctionDef(cx, ts, tc, 0);
    1: }
    1: 
    1: static JSParseNode *
    1: FunctionExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
 9481:     return FunctionDef(cx, ts, tc, JSFUN_LAMBDA);
    1: }
    1: 
    1: /*
    1:  * Parse the statements in a block, creating a TOK_LC node that lists the
    1:  * statements' trees.  If called from block-parsing code, the caller must
    1:  * match { before and } after.
    1:  */
    1: static JSParseNode *
    1: Statements(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2, *saveBlock;
    1:     JSTokenType tt;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
27012:     pn = NewParseNode(PN_LIST, tc);
    1:     if (!pn)
    1:         return NULL;
27012:     pn->pn_type = TOK_LC;
27012:     pn->makeEmpty();
27012:     pn->pn_blockid = tc->blockid();
    1:     saveBlock = tc->blockNode;
    1:     tc->blockNode = pn;
    1: 
 9604:     for (;;) {
    1:         ts->flags |= TSF_OPERAND;
 9604:         tt = js_PeekToken(cx, ts);
    1:         ts->flags &= ~TSF_OPERAND;
10466:         if (tt <= TOK_EOF || tt == TOK_RC) {
24241:             if (tt == TOK_ERROR) {
24241:                 if (ts->flags & TSF_EOF)
24241:                     ts->flags |= TSF_UNEXPECTED_EOF;
24241:                 return NULL;
24241:             }
 9604:             break;
10466:         }
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2) {
    1:             if (ts->flags & TSF_EOF)
    1:                 ts->flags |= TSF_UNEXPECTED_EOF;
    1:             return NULL;
    1:         }
    1: 
10466:         if (pn2->pn_type == TOK_FUNCTION) {
10466:             /*
10466:              * PNX_FUNCDEFS notifies the emitter that the block contains top-
10466:              * level function definitions that should be processed before the
10466:              * rest of nodes.
10466:              *
10466:              * TCF_HAS_FUNCTION_STMT is for the TOK_LC case in Statement. It
10466:              * is relevant only for function definitions not at top-level,
10466:              * which we call function statements.
10466:              */
27012:             if (tc->atTopLevel())
27012:                 pn->pn_xflags |= PNX_FUNCDEFS;
10466:             else
    1:                 tc->flags |= TCF_HAS_FUNCTION_STMT;
10466:         }
27012:         pn->append(pn2);
    1:     }
    1: 
    1:     /*
    1:      * Handle the case where there was a let declaration under this block.  If
    1:      * it replaced tc->blockNode with a new block node then we must refresh pn
    1:      * and then restore tc->blockNode.
    1:      */
    1:     if (tc->blockNode != pn)
    1:         pn = tc->blockNode;
    1:     tc->blockNode = saveBlock;
    1: 
    1:     pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: Condition(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_COND);
 1577:     pn = ParenExpr(cx, ts, tc, NULL, NULL);
    1:     if (!pn)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_COND);
    1: 
    1:     /*
    1:      * Check for (a = b) and warn about possible (a == b) mistype iff b's
    1:      * operator has greater precedence than ==.
    1:      */
    1:     if (pn->pn_type == TOK_ASSIGN &&
    1:         pn->pn_op == JSOP_NOP &&
    1:         pn->pn_right->pn_type > TOK_EQOP)
    1:     {
 7984:         if (!js_ReportCompileErrorNumber(cx, ts, NULL,
 7984:                                          JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                          JSMSG_EQUAL_AS_ASSIGN,
    1:                                          "")) {
    1:             return NULL;
    1:         }
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSBool
    1: MatchLabel(JSContext *cx, JSTokenStream *ts, JSParseNode *pn)
    1: {
    1:     JSAtom *label;
    1:     JSTokenType tt;
    1: 
    1:     tt = js_PeekTokenSameLine(cx, ts);
    1:     if (tt == TOK_ERROR)
    1:         return JS_FALSE;
    1:     if (tt == TOK_NAME) {
    1:         (void) js_GetToken(cx, ts);
    1:         label = CURRENT_TOKEN(ts).t_atom;
    1:     } else {
    1:         label = NULL;
    1:     }
    1:     pn->pn_atom = label;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: BindLet(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc)
    1: {
27012:     JSParseNode *pn;
    1:     JSObject *blockObj;
    1:     JSAtomListElement *ale;
27012:     jsint n;
27012: 
27012:     /*
27012:      * Top-level 'let' is the same as 'var' currently -- this may change in a
27012:      * successor standard to ES3.1 that specifies 'let'.
27012:      */
27012:     JS_ASSERT(!tc->atTopLevel());
27012: 
27012:     pn = data->pn;
 8444:     blockObj = tc->blockChain;
27012:     ale = tc->decls.lookup(atom);
27012:     if (ale && ALE_DEFN(ale)->pn_blockid == tc->blockid()) {
27012:         const char *name = js_AtomToPrintableString(cx, atom);
    1:         if (name) {
27012:             js_ReportCompileErrorNumber(cx, TS(tc->compiler), pn,
 7984:                                         JSREPORT_ERROR, JSMSG_REDECLARED_VAR,
27012:                                         (ale && ALE_DEFN(ale)->isConst())
    1:                                         ? js_const_str
27012:                                         : js_variable_str,
    1:                                         name);
    1:         }
    1:         return JS_FALSE;
    1:     }
    1: 
14688:     n = OBJ_BLOCK_COUNT(cx, blockObj);
14688:     if (n == JS_BIT(16)) {
27012:         js_ReportCompileErrorNumber(cx, TS(tc->compiler), pn,
27012:                                     JSREPORT_ERROR, data->let.overflow);
    1:         return JS_FALSE;
    1:     }
    1: 
27012:     /*
27012:      * Pass push = true to Define so it pushes an ale ahead of any outer scope.
27012:      * This is balanced by PopStatement, defined immediately below.
27012:      */
27012:     if (!Define(pn, atom, tc, true))
27012:         return JS_FALSE;
27012: 
27012:     /*
27012:      * Assign block-local index to pn->pn_cookie right away, encoding it as an
27012:      * upvar cookie whose skip tells the current static level. The emitter will
27012:      * adjust the node's slot based on its stack depth model -- and, for global
27012:      * and eval code, JSCompiler::compileScript will adjust the slot again to
27012:      * include script->nfixed.
27012:      */
27012:     pn->pn_op = JSOP_GETLOCAL;
27012:     pn->pn_cookie = MAKE_UPVAR_COOKIE(tc->staticLevel, n);
27012:     pn->pn_dflags |= PND_LET | PND_BOUND;
27012: 
27012:     /*
27012:      * Use JSPROP_ENUMERATE to aid the disassembler. Define the let binding's
27012:      * property before storing pn in a reserved slot, since block_reserveSlots
27012:      * depends on OBJ_SCOPE(blockObj)->entryCount.
27012:      */
27012:     if (!js_DefineNativeProperty(cx, blockObj, ATOM_TO_JSID(atom), JSVAL_VOID,
27012:                                  NULL, NULL,
14860:                                  JSPROP_ENUMERATE |
14860:                                  JSPROP_PERMANENT |
14860:                                  JSPROP_SHARED,
27012:                                  SPROP_HAS_SHORTID, (int16) n, NULL)) {
27012:         return JS_FALSE;
27012:     }
27012: 
27012:     /*
27012:      * Store pn temporarily in what would be reserved slots in a cloned block
27012:      * object (once the prototype's final population is known, after all 'let'
27012:      * bindings for this block have been parsed). We will free these reserved
27012:      * slots in jsemit.cpp:EmitEnterBlock.
27012:      */
27012:     uintN slot = JSSLOT_FREE(&js_BlockClass) + n;
27012:     if (slot >= STOBJ_NSLOTS(blockObj) &&
27012:         !js_ReallocSlots(cx, blockObj, slot + 1, JS_FALSE)) {
27012:         return JS_FALSE;
27012:     }
27012:     blockObj->map->freeslot = slot + 1;
27012:     STOBJ_SET_SLOT(blockObj, slot, PRIVATE_TO_JSVAL(pn));
27012:     return JS_TRUE;
27012: }
27012: 
27012: static void
27012: PopStatement(JSTreeContext *tc)
27012: {
27012:     JSStmtInfo *stmt = tc->topStmt;
27012: 
27012:     if (stmt->flags & SIF_SCOPE) {
27012:         JSObject *obj = stmt->blockObj;
27012:         JSScope *scope = OBJ_SCOPE(obj);
27012:         JS_ASSERT(scope->object == obj);
27012: 
27012:         for (JSScopeProperty *sprop = scope->lastProp; sprop; sprop = sprop->parent) {
27012:             JSAtom *atom = JSID_TO_ATOM(sprop->id);
27012: 
27012:             /* Beware the empty destructuring dummy. */
27012:             if (atom == tc->compiler->context->runtime->atomState.emptyAtom)
27012:                 continue;
27012:             tc->decls.remove(tc->compiler, atom);
27012:         }
27012:     }
27012:     js_PopStatement(tc);
    1: }
    1: 
    1: static JSBool
    1: BindVarOrConst(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc)
    1: {
27012:     JSStmtInfo *stmt = js_LexicalLookup(tc, atom, NULL);
27012:     JSParseNode *pn = data->pn;
27012: 
27012:     if (stmt && stmt->type == STMT_WITH) {
27012:         pn->pn_op = JSOP_NAME;
27012:         return JS_TRUE;
27012:     }
27012: 
27012:     JSAtomListElement *ale = tc->decls.lookup(atom);
27012:     JSOp op = data->op;
27012: 
27012:     if (stmt || ale) {
27012:         JSDefinition *dn = ale ? ALE_DEFN(ale) : NULL;
27012:         JSDefinition::Kind dn_kind = dn ? dn->kind() : JSDefinition::VAR;
26970:         const char *name;
27012: 
27012:         if (dn_kind == JSDefinition::ARG) {
 8179:             name = js_AtomToPrintableString(cx, atom);
 8179:             if (!name)
 8179:                 return JS_FALSE;
 8179: 
 8179:             if (op == JSOP_DEFCONST) {
27012:                 js_ReportCompileErrorNumber(cx, TS(tc->compiler), pn,
 8179:                                             JSREPORT_ERROR, JSMSG_REDECLARED_PARAM,
 8179:                                             name);
 8179:                 return JS_FALSE;
 8179:             }
27012:             if (!js_ReportCompileErrorNumber(cx, TS(tc->compiler), pn,
 8179:                                              JSREPORT_WARNING | JSREPORT_STRICT,
 8179:                                              JSMSG_VAR_HIDES_ARG, name)) {
 8179:                 return JS_FALSE;
 8179:             }
 8179:         } else {
27012:             if (JS_HAS_STRICT_OPTION(cx)
27012:                 ? op != JSOP_DEFVAR || dn_kind != JSDefinition::VAR
27012:                 : op == JSOP_DEFCONST || dn_kind == JSDefinition::CONST ||
27012:                   dn_kind == JSDefinition::LET) {
27012:                 name = js_AtomToPrintableString(cx, atom);
27012:                 if (!name ||
27012:                     !js_ReportCompileErrorNumber(cx, TS(tc->compiler), pn,
27012:                                                  (op != JSOP_DEFCONST &&
27012:                                                   dn_kind != JSDefinition::CONST &&
27012:                                                   dn_kind != JSDefinition::LET)
27012:                                                  ? JSREPORT_WARNING | JSREPORT_STRICT
27012:                                                  : JSREPORT_ERROR,
27012:                                                  JSMSG_REDECLARED_VAR,
27012:                                                  JSDefinition::kindString(dn_kind),
27012:                                                  name)) {
27012:                     return JS_FALSE;
27012:                 }
27012:             }
27012:         }
27012:     }
27012: 
27012:     if (!ale) {
27012:         if (!Define(pn, atom, tc))
27012:             return JS_FALSE;
27012:     } else {
27012:         /*
27012:          * A var declaration never recreates an existing binding, it restates
27012:          * it and possibly reinitializes its value. Beware that if pn becomes a
27012:          * use of ALE_DEFN(ale), and if we have an initializer for this var or
27012:          * const (typically a const would ;-), then pn must be rewritten into a
27012:          * TOK_ASSIGN node. See Variables, further below.
27012:          *
27012:          * A case such as let (x = 1) { var x = 2; print(x); } is even harder.
27012:          * There the x definition is hoisted but the x = 2 assignment mutates
27012:          * the block-local binding of x.
27012:          */
27012:         JSDefinition *dn = ALE_DEFN(ale);
27012: 
27012:         if (!pn->pn_used) {
27012:             /* Make pnu be a fresh name node that uses dn. */
27012:             JSParseNode *pnu = pn;
27012: 
27012:             if (pn->pn_defn) {
27012:                 pnu = NewNameNode(cx, TS(tc->compiler), atom, tc);
27012:                 if (!pnu)
27012:                     return JS_FALSE;
27012:             }
27012: 
27012:             LinkUseToDef(pnu, dn, tc);
27012:             pnu->pn_op = JSOP_NAME;
27012:         }
27012: 
27012:         while (dn->kind() == JSDefinition::LET) {
27012:             do {
27012:                 ale = ALE_NEXT(ale);
27012:             } while (ale && ALE_ATOM(ale) != atom);
27012:             if (!ale)
27012:                 break;
27012:             dn = ALE_DEFN(ale);
27012:         }
27012: 
27012:         if (ale) {
27012:             JS_ASSERT_IF(data->op == JSOP_DEFCONST,
27012:                          dn->kind() == JSDefinition::CONST);
27012:             return JS_TRUE;
27012:         }
27012: 
27012:         /*
27012:          * A var or const that is shadowed by one or more let bindings of the
27012:          * same name, but that has not been declared until this point, must be
27012:          * hoisted above the let bindings.
27012:          */
27012:         if (!pn->pn_defn) {
27012:             JSHashEntry **hep;
27012: 
27012:             ale = tc->lexdeps.rawLookup(atom, hep);
27012:             if (ale) {
27012:                 pn = ALE_DEFN(ale);
27012:                 tc->lexdeps.rawRemove(tc->compiler, ale, hep);
27012:                 tc->upvars.remove(tc->compiler, atom);
27012:             } else {
27012:                 JSParseNode *pn2 = NewNameNode(cx, TS(tc->compiler), atom, tc);
27012:                 if (!pn2)
27012:                     return JS_FALSE;
27012: 
27012:                 /* The token stream may be past the location for pn. */
27012:                 pn2->pn_type = TOK_NAME;
27012:                 pn2->pn_pos = pn->pn_pos;
27012:                 pn = pn2;
27012:             }
27012:             pn->pn_op = JSOP_NAME;
27012:         }
27012: 
27012:         ale = tc->decls.add(tc->compiler, atom, JSAtomList::HOIST);
27012:         if (!ale)
27012:             return JS_FALSE;
27012:         ALE_SET_DEFN(ale, pn);
27012:         pn->pn_defn = true;
27012:         pn->pn_dflags &= ~PND_PLACEHOLDER;
27012:     }
27012: 
27012:     if (data->op == JSOP_DEFCONST)
27012:         pn->pn_dflags |= PND_CONST;
27012: 
27012:     if (!(tc->flags & TCF_IN_FUNCTION)) {
27012:         /*
27012:          * If we are generating global or eval-called-from-global code, bind a
27012:          * "gvar" here, as soon as possible. The JSOP_GETGVAR, etc., ops speed
27012:          * up global variable access by memoizing name-to-slot mappings in the
27012:          * script prolog (via JSOP_DEFVAR/JSOP_DEFCONST). If the memoization
27012:          * can't be done due to a pre-existing property of the same name as the
27012:          * var or const but incompatible attributes/getter/setter/etc, these
27012:          * ops devolve to JSOP_NAME, etc.
27012:          *
27012:          * For now, don't try to lookup eval frame variables at compile time.
27012:          * Seems sub-optimal: why couldn't we find eval-called-from-a-function
27012:          * upvars early and possibly simplify jsemit.cpp:BindNameToSlot?
27012:          */
27012:         pn->pn_op = JSOP_NAME;
27012:         if ((tc->flags & TCF_COMPILING) && !tc->compiler->callerFrame) {
27012:             JSCodeGenerator *cg = (JSCodeGenerator *) tc;
27012: 
27012:             /* Index atom so we can map fast global number to name. */
27012:             ale = cg->atomList.add(tc->compiler, atom);
27012:             if (!ale)
27012:                 return JS_FALSE;
27012: 
27012:             /* Defend against cg->ngvars 16-bit overflow. */
27012:             uintN slot = ALE_INDEX(ale);
27012:             if ((slot + 1) >> 16)
27012:                 return JS_TRUE;
27012: 
27012:             if ((uint16)(slot + 1) > cg->ngvars)
27012:                 cg->ngvars = (uint16)(slot + 1);
27012: 
27012:             pn->pn_op = JSOP_GETGVAR;
27012:             pn->pn_cookie = MAKE_UPVAR_COOKIE(tc->staticLevel, slot);
27012:             pn->pn_dflags |= PND_BOUND | PND_GVAR;
27012:         }
27012:         return JS_TRUE;
27012:     }
27012: 
27012:     if (atom == cx->runtime->atomState.argumentsAtom) {
27012:         pn->pn_op = JSOP_ARGUMENTS;
27012:         pn->pn_dflags |= PND_BOUND;
27012:         return JS_TRUE;
27012:     }
27012: 
27012:     JSLocalKind localKind = js_LookupLocal(cx, tc->fun, atom, NULL);
27012:     if (localKind == JSLOCAL_NONE) {
27012:         /*
27012:          * Property not found in current variable scope: we have not seen this
27012:          * variable before. Define a new local variable by adding a property to
27012:          * the function's scope and allocating one slot in the function's vars
27012:          * frame. Any locals declared in a with statement body are handled at
27012:          * runtime, by script prolog JSOP_DEFVAR opcodes generated for global
27012:          * and heavyweight-function-local vars.
27012:          */
27012:         localKind = (data->op == JSOP_DEFCONST) ? JSLOCAL_CONST : JSLOCAL_VAR;
27012: 
27012:         uintN index = tc->fun->u.i.nvars;
27012:         if (!BindLocalVariable(cx, tc->fun, atom, localKind))
27012:             return JS_FALSE;
27012:         pn->pn_op = JSOP_GETLOCAL;
27012:         pn->pn_cookie = MAKE_UPVAR_COOKIE(tc->staticLevel, index);
27012:         pn->pn_dflags |= PND_BOUND;
27012:         return JS_TRUE;
27012:     }
27012: 
27012:     if (localKind == JSLOCAL_ARG) {
27012:         /* We checked errors and strict warnings earlier -- see above. */
27012:         JS_ASSERT(ale && ALE_DEFN(ale)->kind() == JSDefinition::ARG);
27012:     } else {
 8179:         /* Not an argument, must be a redeclared local var. */
 8179:         JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
 8179:     }
27012:     pn->pn_op = JSOP_NAME;
 8179:     return JS_TRUE;
    1: }
    1: 
20908: static JSBool
20908: MakeSetCall(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, uintN msg)
20908: {
20908:     JSParseNode *pn2;
20908: 
20908:     JS_ASSERT(pn->pn_arity == PN_LIST);
21460:     JS_ASSERT(pn->pn_op == JSOP_CALL || pn->pn_op == JSOP_EVAL || pn->pn_op == JSOP_APPLY);
20908:     pn2 = pn->pn_head;
27012:     if (pn2->pn_type == TOK_FUNCTION && (pn2->pn_funbox->tcflags & TCF_GENEXP_LAMBDA)) {
27012:         js_ReportCompileErrorNumber(cx, TS(tc->compiler), pn, JSREPORT_ERROR, msg);
20908:         return JS_FALSE;
20908:     }
20908:     pn->pn_op = JSOP_SETCALL;
20908:     return JS_TRUE;
20908: }
20908: 
27012: static void
27012: NoteLValue(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, uintN dflag = PND_ASSIGNED)
27012: {
27012:     if (pn->pn_used) {
27012:         JSDefinition *dn = pn->pn_lexdef;
27012: 
27012:         /*
27012:          * Save the win of PND_INITIALIZED if we can prove 'var x;' and 'x = y'
27012:          * occur as direct kids of the same block with no forward refs to x.
27012:          */
27012:         if (dn->isBlockChild() &&
27012:             pn->isBlockChild() &&
27012:             dn->pn_blockid == pn->pn_blockid &&
27012:             !(~dn->pn_dflags & (PND_INITIALIZED | PND_FORWARD)) &&
27012:             dn->dn_uses == pn) {
27012:             dflag = PND_INITIALIZED;
27012:         }
27012: 
27012:         dn->pn_dflags |= dflag;
27012: 
27012:         if (dn->frameLevel() != tc->staticLevel) {
27012:             /*
27012:              * The above condition takes advantage of the all-ones nature of
27012:              * FREE_UPVAR_COOKIE, and the reserved frame level JS_BITMASK(16).
27012:              * We make a stronger assertion by excluding FREE_UPVAR_COOKIE.
27012:              */
27012:             JS_ASSERT_IF(dn->pn_cookie != FREE_UPVAR_COOKIE,
27012:                          dn->frameLevel() < tc->staticLevel);
27012:             tc->flags |= TCF_FUN_SETS_OUTER_NAME;
27012:         }
27012:     }
27012: 
27012:     pn->pn_dflags |= dflag;
27012: 
27012:     if (pn->pn_atom == cx->runtime->atomState.argumentsAtom)
27012:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
27012: }
27012: 
    1: #if JS_HAS_DESTRUCTURING
    1: 
    1: static JSBool
    1: BindDestructuringVar(JSContext *cx, BindData *data, JSParseNode *pn,
    1:                      JSTreeContext *tc)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     /*
    1:      * Destructuring is a form of assignment, so just as for an initialized
    1:      * simple variable, we must check for assignment to 'arguments' and flag
    1:      * the enclosing function (if any) as heavyweight.
    1:      */
    1:     JS_ASSERT(pn->pn_type == TOK_NAME);
    1:     atom = pn->pn_atom;
    1:     if (atom == cx->runtime->atomState.argumentsAtom)
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1: 
    1:     data->pn = pn;
    1:     if (!data->binder(cx, data, atom, tc))
    1:         return JS_FALSE;
27012: 
27012:     /*
27012:      * Select the appropriate name-setting opcode, respecting eager selection
27012:      * done by the data->binder function.
27012:      */
27012:     if (pn->pn_dflags & PND_BOUND) {
27012:         pn->pn_op = (pn->pn_op == JSOP_ARGUMENTS)
27012:                     ? JSOP_SETNAME
27012:                     : (pn->pn_dflags & PND_GVAR)
27012:                     ? JSOP_SETGVAR
27012:                     : JSOP_SETLOCAL;
 8444:     } else {
27012:         pn->pn_op = (data->op == JSOP_DEFCONST)
27012:                     ? JSOP_SETCONST
27012:                     : JSOP_SETNAME;
27012:     }
27012: 
27012:     if (data->op == JSOP_DEFCONST)
27012:         pn->pn_dflags |= PND_CONST;
27012: 
27012:     NoteLValue(cx, pn, tc, PND_INITIALIZED);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Here, we are destructuring {... P: Q, ...} = R, where P is any id, Q is any
    1:  * LHS expression except a destructuring initialiser, and R is on the stack.
    1:  * Because R is already evaluated, the usual LHS-specialized bytecodes won't
    1:  * work.  After pushing R[P] we need to evaluate Q's "reference base" QB and
    1:  * then push its property name QN.  At this point the stack looks like
    1:  *
    1:  *   [... R, R[P], QB, QN]
    1:  *
    1:  * We need to set QB[QN] = R[P].  This is a job for JSOP_ENUMELEM, which takes
    1:  * its operands with left-hand side above right-hand side:
    1:  *
    1:  *   [rval, lval, xval]
    1:  *
    1:  * and pops all three values, setting lval[xval] = rval.  But we cannot select
    1:  * JSOP_ENUMELEM yet, because the LHS may turn out to be an arg or local var,
    1:  * which can be optimized further.  So we select JSOP_SETNAME.
    1:  */
    1: static JSBool
    1: BindDestructuringLHS(JSContext *cx, JSParseNode *pn, JSTreeContext *tc)
    1: {
    1:     while (pn->pn_type == TOK_RP)
    1:         pn = pn->pn_kid;
    1: 
    1:     switch (pn->pn_type) {
    1:       case TOK_NAME:
27012:         NoteLValue(cx, pn, tc);
    1:         /* FALL THROUGH */
27012: 
    1:       case TOK_DOT:
    1:       case TOK_LB:
    1:         pn->pn_op = JSOP_SETNAME;
    1:         break;
    1: 
    1: #if JS_HAS_LVALUE_RETURN
    1:       case TOK_LP:
 7984:         if (!MakeSetCall(cx, pn, tc, JSMSG_BAD_LEFTSIDE_OF_ASS))
 1577:             return JS_FALSE;
    1:         break;
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_UNARYOP:
    1:         if (pn->pn_op == JSOP_XMLNAME) {
    1:             pn->pn_op = JSOP_BINDXMLNAME;
    1:             break;
    1:         }
    1:         /* FALL THROUGH */
    1: #endif
    1: 
    1:       default:
27012:         js_ReportCompileErrorNumber(cx, TS(tc->compiler), pn,
 7984:                                     JSREPORT_ERROR, JSMSG_BAD_LEFTSIDE_OF_ASS);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: typedef struct FindPropValData {
    1:     uint32          numvars;    /* # of destructuring vars in left side */
    1:     uint32          maxstep;    /* max # of steps searching right side */
    1:     JSDHashTable    table;      /* hash table for O(1) right side search */
    1: } FindPropValData;
    1: 
    1: typedef struct FindPropValEntry {
    1:     JSDHashEntryHdr hdr;
    1:     JSParseNode     *pnkey;
    1:     JSParseNode     *pnval;
    1: } FindPropValEntry;
    1: 
    1: #define ASSERT_VALID_PROPERTY_KEY(pnkey)                                      \
    1:     JS_ASSERT((pnkey)->pn_arity == PN_NULLARY &&                              \
    1:               ((pnkey)->pn_type == TOK_NUMBER ||                              \
    1:                (pnkey)->pn_type == TOK_STRING ||                              \
    1:                (pnkey)->pn_type == TOK_NAME))
    1: 
18907: static JSDHashNumber
    1: HashFindPropValKey(JSDHashTable *table, const void *key)
    1: {
    1:     const JSParseNode *pnkey = (const JSParseNode *)key;
    1: 
    1:     ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:     return (pnkey->pn_type == TOK_NUMBER)
    1:            ? (JSDHashNumber) (JSDOUBLE_HI32(pnkey->pn_dval) ^
    1:                               JSDOUBLE_LO32(pnkey->pn_dval))
 3328:            : ATOM_HASH(pnkey->pn_atom);
    1: }
    1: 
18907: static JSBool
    1: MatchFindPropValEntry(JSDHashTable *table,
    1:                       const JSDHashEntryHdr *entry,
    1:                       const void *key)
    1: {
    1:     const FindPropValEntry *fpve = (const FindPropValEntry *)entry;
    1:     const JSParseNode *pnkey = (const JSParseNode *)key;
    1: 
    1:     ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:     return pnkey->pn_type == fpve->pnkey->pn_type &&
    1:            ((pnkey->pn_type == TOK_NUMBER)
    1:             ? pnkey->pn_dval == fpve->pnkey->pn_dval
    1:             : pnkey->pn_atom == fpve->pnkey->pn_atom);
    1: }
    1: 
    1: static const JSDHashTableOps FindPropValOps = {
    1:     JS_DHashAllocTable,
    1:     JS_DHashFreeTable,
    1:     HashFindPropValKey,
    1:     MatchFindPropValEntry,
    1:     JS_DHashMoveEntryStub,
    1:     JS_DHashClearEntryStub,
    1:     JS_DHashFinalizeStub,
    1:     NULL
    1: };
    1: 
    1: #define STEP_HASH_THRESHOLD     10
    1: #define BIG_DESTRUCTURING        5
    1: #define BIG_OBJECT_INIT         20
    1: 
    1: static JSParseNode *
    1: FindPropertyValue(JSParseNode *pn, JSParseNode *pnid, FindPropValData *data)
    1: {
    1:     FindPropValEntry *entry;
  991:     JSParseNode *pnhit, *pnhead, *pnprop, *pnkey;
    1:     uint32 step;
    1: 
    1:     /* If we have a hash table, use it as the sole source of truth. */
    1:     if (data->table.ops) {
    1:         entry = (FindPropValEntry *)
    1:                 JS_DHashTableOperate(&data->table, pnid, JS_DHASH_LOOKUP);
    1:         return JS_DHASH_ENTRY_IS_BUSY(&entry->hdr) ? entry->pnval : NULL;
    1:     }
    1: 
    1:     /* If pn is not an object initialiser node, we can't do anything here. */
    1:     if (pn->pn_type != TOK_RC)
    1:         return NULL;
    1: 
    1:     /*
    1:      * We must search all the way through pn's list, to handle the case of an
    1:      * id duplicated for two or more property initialisers.
    1:      */
    1:     pnhit = NULL;
    1:     step = 0;
    1:     ASSERT_VALID_PROPERTY_KEY(pnid);
  991:     pnhead = pn->pn_head;
    1:     if (pnid->pn_type == TOK_NUMBER) {
  991:         for (pnprop = pnhead; pnprop; pnprop = pnprop->pn_next) {
    1:             JS_ASSERT(pnprop->pn_type == TOK_COLON);
    1:             if (pnprop->pn_op == JSOP_NOP) {
    1:                 pnkey = pnprop->pn_left;
    1:                 ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:                 if (pnkey->pn_type == TOK_NUMBER &&
    1:                     pnkey->pn_dval == pnid->pn_dval) {
    1:                     pnhit = pnprop;
    1:                 }
    1:                 ++step;
    1:             }
    1:         }
    1:     } else {
  991:         for (pnprop = pnhead; pnprop; pnprop = pnprop->pn_next) {
    1:             JS_ASSERT(pnprop->pn_type == TOK_COLON);
    1:             if (pnprop->pn_op == JSOP_NOP) {
    1:                 pnkey = pnprop->pn_left;
    1:                 ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:                 if (pnkey->pn_type == pnid->pn_type &&
    1:                     pnkey->pn_atom == pnid->pn_atom) {
    1:                     pnhit = pnprop;
    1:                 }
    1:                 ++step;
    1:             }
    1:         }
    1:     }
    1:     if (!pnhit)
    1:         return NULL;
    1: 
    1:     /* Hit via full search -- see whether it's time to create the hash table. */
    1:     JS_ASSERT(!data->table.ops);
    1:     if (step > data->maxstep) {
    1:         data->maxstep = step;
    1:         if (step >= STEP_HASH_THRESHOLD &&
    1:             data->numvars >= BIG_DESTRUCTURING &&
    1:             pn->pn_count >= BIG_OBJECT_INIT &&
    1:             JS_DHashTableInit(&data->table, &FindPropValOps, pn,
    1:                               sizeof(FindPropValEntry),
    1:                               JS_DHASH_DEFAULT_CAPACITY(pn->pn_count)))
    1:         {
  991:             for (pn = pnhead; pn; pn = pn->pn_next) {
  991:                 JS_ASSERT(pnprop->pn_type == TOK_COLON);
    1:                 ASSERT_VALID_PROPERTY_KEY(pn->pn_left);
    1:                 entry = (FindPropValEntry *)
    1:                         JS_DHashTableOperate(&data->table, pn->pn_left,
    1:                                              JS_DHASH_ADD);
    1:                 entry->pnval = pn->pn_right;
    1:             }
    1:         }
    1:     }
    1:     return pnhit->pn_right;
    1: }
    1: 
    1: /*
    1:  * If data is null, the caller is AssignExpr and instead of binding variables,
    1:  * we specialize lvalues in the propery value positions of the left-hand side.
    1:  * If right is null, just check for well-formed lvalues.
    1:  */
    1: static JSBool
    1: CheckDestructuring(JSContext *cx, BindData *data,
    1:                    JSParseNode *left, JSParseNode *right,
    1:                    JSTreeContext *tc)
    1: {
    1:     JSBool ok;
    1:     FindPropValData fpvd;
    1:     JSParseNode *lhs, *rhs, *pn, *pn2;
    1: 
    1:     if (left->pn_type == TOK_ARRAYCOMP) {
27012:         js_ReportCompileErrorNumber(cx, TS(tc->compiler), left,
 7984:                                     JSREPORT_ERROR, JSMSG_ARRAY_COMP_LEFTSIDE);
    1:         return JS_FALSE;
    1:     }
    1: 
18473: #if JS_HAS_DESTRUCTURING_SHORTHAND
27012:     if (right && right->pn_arity == PN_LIST && (right->pn_xflags & PNX_DESTRUCT)) {
27012:         js_ReportCompileErrorNumber(cx, TS(tc->compiler), right,
18473:                                     JSREPORT_ERROR, JSMSG_BAD_OBJECT_INIT);
18473:         return JS_FALSE;
18473:     }
18473: #endif
18473: 
    1:     fpvd.table.ops = NULL;
    1:     lhs = left->pn_head;
    1:     if (left->pn_type == TOK_RB) {
    1:         rhs = (right && right->pn_type == left->pn_type)
    1:               ? right->pn_head
    1:               : NULL;
    1: 
    1:         while (lhs) {
    1:             pn = lhs, pn2 = rhs;
    1:             if (!data) {
    1:                 /* Skip parenthesization if not in a variable declaration. */
    1:                 while (pn->pn_type == TOK_RP)
    1:                     pn = pn->pn_kid;
    1:                 if (pn2) {
    1:                     while (pn2->pn_type == TOK_RP)
    1:                         pn2 = pn2->pn_kid;
    1:                 }
    1:             }
    1: 
    1:             /* Nullary comma is an elision; binary comma is an expression.*/
    1:             if (pn->pn_type != TOK_COMMA || pn->pn_arity != PN_NULLARY) {
    1:                 if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC) {
    1:                     ok = CheckDestructuring(cx, data, pn, pn2, tc);
    1:                 } else {
    1:                     if (data) {
    1:                         if (pn->pn_type != TOK_NAME)
    1:                             goto no_var_name;
    1: 
    1:                         ok = BindDestructuringVar(cx, data, pn, tc);
    1:                     } else {
    1:                         ok = BindDestructuringLHS(cx, pn, tc);
    1:                     }
    1:                 }
    1:                 if (!ok)
    1:                     goto out;
    1:             }
    1: 
    1:             lhs = lhs->pn_next;
    1:             if (rhs)
    1:                 rhs = rhs->pn_next;
    1:         }
    1:     } else {
    1:         JS_ASSERT(left->pn_type == TOK_RC);
    1:         fpvd.numvars = left->pn_count;
    1:         fpvd.maxstep = 0;
    1:         rhs = NULL;
    1: 
    1:         while (lhs) {
    1:             JS_ASSERT(lhs->pn_type == TOK_COLON);
    1:             pn = lhs->pn_right;
    1:             if (!data) {
    1:                 /* Skip parenthesization if not in a variable declaration. */
    1:                 while (pn->pn_type == TOK_RP)
    1:                     pn = pn->pn_kid;
    1:             }
    1: 
    1:             if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC) {
    1:                 if (right) {
    1:                     rhs = FindPropertyValue(right, lhs->pn_left, &fpvd);
    1:                     if (rhs && !data) {
    1:                         while (rhs->pn_type == TOK_RP)
    1:                             rhs = rhs->pn_kid;
    1:                     }
    1:                 }
    1: 
    1:                 ok = CheckDestructuring(cx, data, pn, rhs, tc);
    1:             } else if (data) {
    1:                 if (pn->pn_type != TOK_NAME)
    1:                     goto no_var_name;
    1: 
    1:                 ok = BindDestructuringVar(cx, data, pn, tc);
    1:             } else {
    1:                 ok = BindDestructuringLHS(cx, pn, tc);
    1:             }
    1:             if (!ok)
    1:                 goto out;
    1: 
    1:             lhs = lhs->pn_next;
    1:         }
    1:     }
    1: 
14688:     /*
14688:      * The catch/finally handler implementation in the interpreter assumes
14688:      * that any operation that introduces a new scope (like a "let" or "with"
14688:      * block) increases the stack depth. This way, it is possible to restore
14688:      * the scope chain based on stack depth of the handler alone. "let" with
14688:      * an empty destructuring pattern like in
14688:      *
14688:      *   let [] = 1;
14688:      *
14688:      * would violate this assumption as the there would be no let locals to
14688:      * store on the stack. To satisfy it we add an empty property to such
14688:      * blocks so that OBJ_BLOCK_COUNT(cx, blockObj), which gives the number of
14688:      * slots, would be always positive.
14688:      *
14688:      * Note that we add such a property even if the block has locals due to
14688:      * later let declarations in it. We optimize for code simplicity here,
14688:      * not the fastest runtime performance with empty [] or {}.
14688:      */
14688:     if (data &&
14688:         data->binder == BindLet &&
14688:         OBJ_BLOCK_COUNT(cx, tc->blockChain) == 0) {
14688:         ok = js_DefineNativeProperty(cx, tc->blockChain,
14688:                                      ATOM_TO_JSID(cx->runtime->
14688:                                                   atomState.emptyAtom),
14688:                                      JSVAL_VOID, NULL, NULL,
14860:                                      JSPROP_ENUMERATE |
14860:                                      JSPROP_PERMANENT |
14860:                                      JSPROP_SHARED,
14688:                                      SPROP_HAS_SHORTID, 0, NULL);
14688:         if (!ok)
14688:             goto out;
14688:     }
14688: 
14688:     ok = JS_TRUE;
14688: 
    1:   out:
    1:     if (fpvd.table.ops)
    1:         JS_DHashTableFinish(&fpvd.table);
    1:     return ok;
    1: 
    1:   no_var_name:
27012:     js_ReportCompileErrorNumber(cx, TS(tc->compiler), pn, JSREPORT_ERROR,
    1:                                 JSMSG_NO_VARIABLE_NAME);
    1:     ok = JS_FALSE;
    1:     goto out;
    1: }
    1: 
    1: static JSParseNode *
    1: DestructuringExpr(JSContext *cx, BindData *data, JSTreeContext *tc,
    1:                   JSTokenType tt)
    1: {
27012:     JSTokenStream *ts;
    1:     JSParseNode *pn;
    1: 
27012:     ts = TS(tc->compiler);
27012:     ts->flags |= TSF_DESTRUCTURING;
27012:     pn = PrimaryExpr(cx, ts, tc, tt, JS_FALSE);
27012:     ts->flags &= ~TSF_DESTRUCTURING;
    1:     if (!pn)
    1:         return NULL;
    1:     if (!CheckDestructuring(cx, data, pn, NULL, tc))
    1:         return NULL;
    1:     return pn;
    1: }
    1: 
27012: /*
27012:  * Currently used only #if JS_HAS_DESTRUCTURING, in Statement's TOK_FOR case.
27012:  * This function assumes the cloned tree is for use in the same statement and
27012:  * binding context as the original tree.
27012:  */
20413: static JSParseNode *
27012: CloneParseTree(JSParseNode *opn, JSTreeContext *tc)
20413: {
20413:     JSParseNode *pn, *pn2, *opn2;
20413: 
27012:     pn = NewOrRecycledNode(tc);
20413:     if (!pn)
20413:         return NULL;
20413:     pn->pn_type = opn->pn_type;
20413:     pn->pn_pos = opn->pn_pos;
20413:     pn->pn_op = opn->pn_op;
27012:     pn->pn_used = opn->pn_used;
27012:     pn->pn_defn = opn->pn_defn;
20413:     pn->pn_arity = opn->pn_arity;
20413: 
20413:     switch (pn->pn_arity) {
20419: #define NULLCHECK(e)    JS_BEGIN_MACRO if (!(e)) return NULL; JS_END_MACRO
20413: 
20413:       case PN_FUNC:
27012:         NULLCHECK(pn->pn_funbox =
27012:                   tc->compiler->newFunctionBox(opn->pn_funbox->object, pn, tc));
27012:         NULLCHECK(pn->pn_body = CloneParseTree(opn->pn_body, tc));
27012:         pn->pn_cookie = opn->pn_cookie;
27012:         pn->pn_dflags = opn->pn_dflags;
27012:         pn->pn_blockid = opn->pn_blockid;
20413:         break;
20413: 
20413:       case PN_LIST:
27012:         pn->makeEmpty();
20413:         for (opn2 = opn->pn_head; opn2; opn2 = opn2->pn_next) {
27012:             NULLCHECK(pn2 = CloneParseTree(opn2, tc));
27012:             pn->append(pn2);
27012:         }
27012:         pn->pn_xflags = opn->pn_xflags;
20413:         break;
20413: 
20413:       case PN_TERNARY:
27012:         NULLCHECK(pn->pn_kid1 = CloneParseTree(opn->pn_kid1, tc));
27012:         NULLCHECK(pn->pn_kid2 = CloneParseTree(opn->pn_kid2, tc));
27012:         NULLCHECK(pn->pn_kid3 = CloneParseTree(opn->pn_kid3, tc));
20413:         break;
20413: 
20413:       case PN_BINARY:
27012:         NULLCHECK(pn->pn_left = CloneParseTree(opn->pn_left, tc));
20413:         if (opn->pn_right != opn->pn_left)
27012:             NULLCHECK(pn->pn_right = CloneParseTree(opn->pn_right, tc));
20413:         else
20413:             pn->pn_right = pn->pn_left;
20413:         pn->pn_val = opn->pn_val;
20413:         pn->pn_iflags = opn->pn_iflags;
20413:         break;
20413: 
20413:       case PN_UNARY:
27012:         NULLCHECK(pn->pn_kid = CloneParseTree(opn->pn_kid, tc));
20413:         pn->pn_num = opn->pn_num;
20413:         pn->pn_hidden = opn->pn_hidden;
20413:         break;
20413: 
20413:       case PN_NAME:
20413:         // PN_NAME could mean several arms in pn_u, so copy the whole thing.
20413:         pn->pn_u = opn->pn_u;
27012:         if (opn->pn_used) {
27012:             /*
27012:              * The old name is a use of its pn_lexdef. Make the clone also be a
27012:              * use of that definition.
27012:              */
27012:             JSDefinition *dn = pn->pn_lexdef;
27012: 
27012:             pn->pn_link = dn->dn_uses;
27012:             dn->dn_uses = pn;
27012:         } else if (opn->pn_expr) {
27012:             NULLCHECK(pn->pn_expr = CloneParseTree(opn->pn_expr, tc));
27012: 
27012:             /*
27012:              * If the old name is a definition, the new one has pn_defn set.
27012:              * Make the old name a use of the new node.
27012:              */
27012:             if (opn->pn_defn) {
27012:                 opn->pn_defn = false;
27012:                 LinkUseToDef(opn, (JSDefinition *) pn, tc);
27012:             }
27012:         }
27012:         break;
27012: 
27012:       case PN_NAMESET:
27012:         pn->pn_names = opn->pn_names;
27012:         NULLCHECK(pn->pn_tree = CloneParseTree(opn->pn_tree, tc));
20413:         break;
20413: 
20413:       case PN_NULLARY:
20413:         // Even PN_NULLARY may have data (apair for E4X -- what a botch).
20413:         pn->pn_u = opn->pn_u;
20413:         break;
20413: 
20413: #undef NULLCHECK
20413:     }
20413:     return pn;
20413: }
20413: 
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
    1: extern const char js_with_statement_str[];
    1: 
    1: static JSParseNode *
    1: ContainsStmt(JSParseNode *pn, JSTokenType tt)
    1: {
    1:     JSParseNode *pn2, *pnt;
    1: 
    1:     if (!pn)
    1:         return NULL;
27012:     if (PN_TYPE(pn) == tt)
    1:         return pn;
    1:     switch (pn->pn_arity) {
    1:       case PN_LIST:
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:             pnt = ContainsStmt(pn2, tt);
    1:             if (pnt)
    1:                 return pnt;
    1:         }
    1:         break;
    1:       case PN_TERNARY:
    1:         pnt = ContainsStmt(pn->pn_kid1, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         pnt = ContainsStmt(pn->pn_kid2, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         return ContainsStmt(pn->pn_kid3, tt);
    1:       case PN_BINARY:
    1:         /*
    1:          * Limit recursion if pn is a binary expression, which can't contain a
    1:          * var statement.
    1:          */
    1:         if (pn->pn_op != JSOP_NOP)
    1:             return NULL;
    1:         pnt = ContainsStmt(pn->pn_left, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         return ContainsStmt(pn->pn_right, tt);
    1:       case PN_UNARY:
    1:         if (pn->pn_op != JSOP_NOP)
    1:             return NULL;
    1:         return ContainsStmt(pn->pn_kid, tt);
    1:       case PN_NAME:
27012:         return ContainsStmt(pn->maybeExpr(), tt);
27012:       case PN_NAMESET:
27012:         return ContainsStmt(pn->pn_tree, tt);
    1:       default:;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: static JSParseNode *
    1: ReturnOrYield(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:               JSParser operandParser)
    1: {
    1:     JSTokenType tt, tt2;
    1:     JSParseNode *pn, *pn2;
    1: 
    1:     tt = CURRENT_TOKEN(ts).type;
 1577:     if (tt == TOK_RETURN && !(tc->flags & TCF_IN_FUNCTION)) {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
 1577:                                     JSMSG_BAD_RETURN_OR_YIELD, js_return_str);
    1:         return NULL;
    1:     }
    1: 
27012:     pn = NewParseNode(PN_UNARY, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1: #if JS_HAS_GENERATORS
    1:     if (tt == TOK_YIELD)
    1:         tc->flags |= TCF_FUN_IS_GENERATOR;
    1: #endif
    1: 
    1:     /* This is ugly, but we don't want to require a semicolon. */
    1:     ts->flags |= TSF_OPERAND;
    1:     tt2 = js_PeekTokenSameLine(cx, ts);
    1:     ts->flags &= ~TSF_OPERAND;
    1:     if (tt2 == TOK_ERROR)
    1:         return NULL;
    1: 
    1:     if (tt2 != TOK_EOF && tt2 != TOK_EOL && tt2 != TOK_SEMI && tt2 != TOK_RC
    1: #if JS_HAS_GENERATORS
  339:         && (tt != TOK_YIELD ||
11844:             (tt2 != tt && tt2 != TOK_RB && tt2 != TOK_RP &&
11844:              tt2 != TOK_COLON && tt2 != TOK_COMMA))
    1: #endif
    1:         ) {
    1:         pn2 = operandParser(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1: #if JS_HAS_GENERATORS
    1:         if (tt == TOK_RETURN)
    1: #endif
    1:             tc->flags |= TCF_RETURN_EXPR;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:     } else {
    1: #if JS_HAS_GENERATORS
    1:         if (tt == TOK_RETURN)
    1: #endif
    1:             tc->flags |= TCF_RETURN_VOID;
    1:     }
    1: 
    1:     if ((~tc->flags & (TCF_RETURN_EXPR | TCF_FUN_IS_GENERATOR)) == 0) {
    1:         /* As in Python (see PEP-255), disallow return v; in generators. */
 8444:         ReportBadReturn(cx, tc, JSREPORT_ERROR,
    1:                         JSMSG_BAD_GENERATOR_RETURN,
    1:                         JSMSG_BAD_ANON_GENERATOR_RETURN);
    1:         return NULL;
    1:     }
    1: 
    1:     if (JS_HAS_STRICT_OPTION(cx) &&
    1:         (~tc->flags & (TCF_RETURN_EXPR | TCF_RETURN_VOID)) == 0 &&
 8444:         !ReportBadReturn(cx, tc, JSREPORT_WARNING | JSREPORT_STRICT,
    1:                          JSMSG_NO_RETURN_VALUE,
    1:                          JSMSG_ANON_NO_RETURN_VALUE)) {
    1:         return NULL;
    1:     }
    1: 
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: PushLexicalScope(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
27012:                  JSStmtInfo *stmt)
    1: {
    1:     JSParseNode *pn;
    1:     JSObject *obj;
27012:     JSObjectBox *blockbox;
27012: 
27012:     pn = NewParseNode(PN_NAME, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     obj = js_NewBlockObject(cx);
    1:     if (!obj)
    1:         return NULL;
    1: 
27012:     blockbox = tc->compiler->newObjectBox(obj);
27012:     if (!blockbox)
27012:         return NULL;
27012: 
27012:     js_PushBlockScope(tc, stmt, obj, -1);
    1:     pn->pn_type = TOK_LEXICALSCOPE;
    1:     pn->pn_op = JSOP_LEAVEBLOCK;
27012:     pn->pn_objbox = blockbox;
27012:     pn->pn_cookie = FREE_UPVAR_COOKIE;
27012:     pn->pn_dflags = 0;
27012:     if (!GenerateBlockId(tc, stmt->blockid))
27012:         return NULL;
27012:     pn->pn_blockid = stmt->blockid;
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1: 
    1: static JSParseNode *
    1: LetBlock(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc, JSBool statement)
    1: {
    1:     JSParseNode *pn, *pnblock, *pnlet;
    1:     JSStmtInfo stmtInfo;
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_LET);
    1: 
    1:     /* Create the let binary node. */
27012:     pnlet = NewParseNode(PN_BINARY, tc);
    1:     if (!pnlet)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_LET);
    1: 
    1:     /* This is a let block or expression of the form: let (a, b, c) .... */
    1:     pnblock = PushLexicalScope(cx, ts, tc, &stmtInfo);
    1:     if (!pnblock)
    1:         return NULL;
    1:     pn = pnblock;
    1:     pn->pn_expr = pnlet;
    1: 
27012:     pnlet->pn_left = Variables(cx, ts, tc, true);
    1:     if (!pnlet->pn_left)
    1:         return NULL;
27012:     pnlet->pn_left->pn_xflags = PNX_POPVAR;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_LET);
    1: 
    1:     ts->flags |= TSF_OPERAND;
    1:     if (statement && !js_MatchToken(cx, ts, TOK_LC)) {
    1:         /*
    1:          * If this is really an expression in let statement guise, then we
    1:          * need to wrap the TOK_LET node in a TOK_SEMI node so that we pop
    1:          * the return value of the expression.
    1:          */
27012:         pn = NewParseNode(PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_SEMI;
    1:         pn->pn_num = -1;
    1:         pn->pn_kid = pnblock;
    1: 
    1:         statement = JS_FALSE;
    1:     }
    1:     ts->flags &= ~TSF_OPERAND;
    1: 
    1:     if (statement) {
    1:         pnlet->pn_right = Statements(cx, ts, tc);
    1:         if (!pnlet->pn_right)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_LET);
    1:     } else {
    1:         /*
    1:          * Change pnblock's opcode to the variant that propagates the last
    1:          * result down after popping the block, and clear statement.
    1:          */
    1:         pnblock->pn_op = JSOP_LEAVEBLOCKEXPR;
 1967:         pnlet->pn_right = AssignExpr(cx, ts, tc);
    1:         if (!pnlet->pn_right)
    1:             return NULL;
    1:     }
    1: 
27012:     PopStatement(tc);
    1:     return pn;
    1: }
    1: 
    1: #endif /* JS_HAS_BLOCK_SCOPE */
    1: 
27012: static bool
27012: PushBlocklikeStatement(JSStmtInfo *stmt, JSStmtType type, JSTreeContext *tc)
27012: {
27012:     js_PushStatement(tc, stmt, type, -1);
27012:     return GenerateBlockId(tc, stmt->blockid);
27012: }
27012: 
27012: static JSParseNode *
27012: NewBindingNode(JSTokenStream *ts, JSAtom *atom, JSTreeContext *tc, bool let = false)
27012: {
27012:     JSParseNode *pn = NULL;
27012: 
27012:     JSAtomListElement *ale = tc->decls.lookup(atom);
27012:     if (ale) {
27012:         pn = ALE_DEFN(ale);
27012:         JS_ASSERT(!pn->isPlaceholder());
27012:     } else {
27012:         ale = tc->lexdeps.lookup(atom);
27012:         if (ale) {
27012:             pn = ALE_DEFN(ale);
27012:             JS_ASSERT(pn->isPlaceholder());
27012:         }
27012:     }
27012: 
27012:     if (pn) {
27012:         JS_ASSERT(pn->pn_defn);
27012: 
27012:         /*
27012:          * A let binding at top level becomes a var before we get here, so if
27012:          * pn and tc have the same blockid then that id must not be the bodyid.
27012:          * If pn is a forward placeholder definition from the same or a higher
27012:          * block then we claim it.
27012:          */
27012:         JS_ASSERT_IF(let && pn->pn_blockid == tc->blockid(),
27012:                      pn->pn_blockid != tc->bodyid);
27012: 
27012:         if (pn->isPlaceholder() && pn->pn_blockid >= (let ? tc->blockid() : tc->bodyid)) {
27012:             JS_ASSERT(pn->isForward());
27012:             if (let)
27012:                 pn->pn_blockid = tc->blockid();
27012: 
27012:             tc->lexdeps.remove(tc->compiler, atom);
27012: 
27012:             JSHashEntry **hep;
27012:             ale = tc->upvars.rawLookup(atom, hep);
27012:             if (ale && ALE_DEFN(ale) == pn)
27012:                 tc->upvars.rawRemove(tc->compiler, ale, hep);
27012:             return pn;
27012:         }
27012:     }
27012: 
27012:     /* Make a new node for this declarator name (or destructuring pattern). */
27012:     pn = NewNameNode(tc->compiler->context, ts, atom, tc);
27012:     if (!pn)
27012:         return NULL;
27012:     return pn;
27012: }
27012: 
27012: #if JS_HAS_BLOCK_SCOPE
27012: static bool
27012: RebindLets(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     if (!pn)
27012:         return true;
27012: 
27012:     switch (pn->pn_arity) {
27012:       case PN_LIST:
27012:         for (JSParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next)
27012:             RebindLets(pn2, tc);
27012:         break;
27012: 
27012:       case PN_TERNARY:
27012:         RebindLets(pn->pn_kid1, tc);
27012:         RebindLets(pn->pn_kid2, tc);
27012:         RebindLets(pn->pn_kid3, tc);
27012:         break;
27012: 
27012:       case PN_BINARY:
27012:         RebindLets(pn->pn_left, tc);
27012:         RebindLets(pn->pn_right, tc);
27012:         break;
27012: 
27012:       case PN_UNARY:
27012:         RebindLets(pn->pn_kid, tc);
27012:         break;
27012: 
27012:       case PN_FUNC:
27012:         RebindLets(pn->pn_body, tc);
27012:         break;
27012: 
27012:       case PN_NAME:
27012:         RebindLets(pn->maybeExpr(), tc);
27012: 
27012:         if (pn->pn_defn) {
27012:             JS_ASSERT(pn->pn_blockid > tc->topStmt->blockid);
27012:         } else if (pn->pn_used) {
27012:             if (pn->pn_lexdef->pn_blockid == tc->topStmt->blockid) {
27012:                 ForgetUse(pn);
27012: 
27012:                 JSAtomListElement *ale = tc->decls.lookup(pn->pn_atom);
27012:                 while ((ale = ALE_NEXT(ale)) != NULL) {
27012:                     if (ALE_ATOM(ale) == pn->pn_atom) {
27012:                         LinkUseToDef(pn, ALE_DEFN(ale), tc);
27012:                         return true;
27012:                     }
27012:                 }
27012: 
27012:                 ale = tc->upvars.lookup(pn->pn_atom);
27012:                 if (!ale) {
27012:                     ale = tc->lexdeps.lookup(pn->pn_atom);
27012:                     if (!ale) {
27012:                         ale = MakePlaceholder(pn, tc);
27012:                         if (!ale)
27012:                             return NULL;
27012: 
27012:                         JSDefinition *dn = ALE_DEFN(ale);
27012:                         dn->pn_type = TOK_NAME;
27012:                         dn->pn_op = JSOP_NOP;
27012:                         dn->pn_dflags |= pn->pn_dflags & PND_FUNARG;
27012:                     }
27012:                 }
27012:                 LinkUseToDef(pn, ALE_DEFN(ale), tc);
27012:             }
27012:         }
27012:         break;
27012: 
27012:       case PN_NAMESET:
27012:         RebindLets(pn->pn_tree, tc);
27012:         break;
27012:     }
27012: 
27012:     return true;
27012: }
27012: #endif /* JS_HAS_BLOCK_SCOPE */
27012: 
    1: static JSParseNode *
    1: Statement(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSTokenType tt;
    1:     JSParseNode *pn, *pn1, *pn2, *pn3, *pn4;
    1:     JSStmtInfo stmtInfo, *stmt, *stmt2;
    1:     JSAtom *label;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     ts->flags |= TSF_OPERAND;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_OPERAND;
    1: 
    1: #if JS_HAS_GETTER_SETTER
    1:     if (tt == TOK_NAME) {
    1:         tt = CheckGetterOrSetter(cx, ts, TOK_FUNCTION);
    1:         if (tt == TOK_ERROR)
    1:             return NULL;
    1:     }
    1: #endif
    1: 
    1:     switch (tt) {
    1:       case TOK_FUNCTION:
    1: #if JS_HAS_XML_SUPPORT
    1:         ts->flags |= TSF_KEYWORD_IS_NAME;
    1:         tt = js_PeekToken(cx, ts);
    1:         ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:         if (tt == TOK_DBLCOLON)
    1:             goto expression;
    1: #endif
    1:         return FunctionStmt(cx, ts, tc);
    1: 
    1:       case TOK_IF:
    1:         /* An IF node has three kids: condition, then, and optional else. */
27012:         pn = NewParseNode(PN_TERNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn1 = Condition(cx, ts, tc);
    1:         if (!pn1)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_IF, -1);
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         ts->flags |= TSF_OPERAND;
    1:         if (js_MatchToken(cx, ts, TOK_ELSE)) {
    1:             ts->flags &= ~TSF_OPERAND;
    1:             stmtInfo.type = STMT_ELSE;
    1:             pn3 = Statement(cx, ts, tc);
    1:             if (!pn3)
    1:                 return NULL;
    1:             pn->pn_pos.end = pn3->pn_pos.end;
    1:         } else {
    1:             ts->flags &= ~TSF_OPERAND;
    1:             pn3 = NULL;
    1:             pn->pn_pos.end = pn2->pn_pos.end;
    1:         }
27012:         PopStatement(tc);
    1:         pn->pn_kid1 = pn1;
    1:         pn->pn_kid2 = pn2;
    1:         pn->pn_kid3 = pn3;
    1:         return pn;
    1: 
    1:       case TOK_SWITCH:
    1:       {
    1:         JSParseNode *pn5, *saveBlock;
    1:         JSBool seenDefault = JS_FALSE;
    1: 
27012:         pn = NewParseNode(PN_BINARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_SWITCH);
    1: 
    1:         /* pn1 points to the switch's discriminant. */
 1577:         pn1 = ParenExpr(cx, ts, tc, NULL, NULL);
    1:         if (!pn1)
    1:             return NULL;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_SWITCH);
    1:         MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_SWITCH);
    1: 
27012:         /*
27012:          * NB: we must push stmtInfo before calling GenerateBlockIdForStmtNode
27012:          * because that function states tc->topStmt->blockid.
27012:          */
27012:         js_PushStatement(tc, &stmtInfo, STMT_SWITCH, -1);
27012: 
    1:         /* pn2 is a list of case nodes. The default case has pn_left == NULL */
27012:         pn2 = NewParseNode(PN_LIST, tc);
    1:         if (!pn2)
    1:             return NULL;
27012:         pn2->makeEmpty();
27012:         if (!GenerateBlockIdForStmtNode(pn2, tc))
27012:             return NULL;
    1:         saveBlock = tc->blockNode;
    1:         tc->blockNode = pn2;
    1: 
    1:         while ((tt = js_GetToken(cx, ts)) != TOK_RC) {
    1:             switch (tt) {
    1:               case TOK_DEFAULT:
    1:                 if (seenDefault) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_TOO_MANY_DEFAULTS);
    1:                     return NULL;
    1:                 }
    1:                 seenDefault = JS_TRUE;
 1577:                 /* FALL THROUGH */
    1: 
    1:               case TOK_CASE:
27012:                 pn3 = NewParseNode(PN_BINARY, tc);
    1:                 if (!pn3)
    1:                     return NULL;
 1577:                 if (tt == TOK_CASE) {
    1:                     pn3->pn_left = Expr(cx, ts, tc);
    1:                     if (!pn3->pn_left)
    1:                         return NULL;
    1:                 }
27012:                 pn2->append(pn3);
    1:                 if (pn2->pn_count == JS_BIT(16)) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_TOO_MANY_CASES);
    1:                     return NULL;
    1:                 }
    1:                 break;
    1: 
    1:               case TOK_ERROR:
    1:                 return NULL;
    1: 
    1:               default:
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_SWITCH);
    1:                 return NULL;
    1:             }
    1:             MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_AFTER_CASE);
    1: 
27012:             pn4 = NewParseNode(PN_LIST, tc);
    1:             if (!pn4)
    1:                 return NULL;
    1:             pn4->pn_type = TOK_LC;
27012:             pn4->makeEmpty();
    1:             ts->flags |= TSF_OPERAND;
    1:             while ((tt = js_PeekToken(cx, ts)) != TOK_RC &&
    1:                    tt != TOK_CASE && tt != TOK_DEFAULT) {
    1:                 ts->flags &= ~TSF_OPERAND;
    1:                 if (tt == TOK_ERROR)
    1:                     return NULL;
    1:                 pn5 = Statement(cx, ts, tc);
    1:                 if (!pn5)
    1:                     return NULL;
    1:                 pn4->pn_pos.end = pn5->pn_pos.end;
27012:                 pn4->append(pn5);
    1:                 ts->flags |= TSF_OPERAND;
    1:             }
    1:             ts->flags &= ~TSF_OPERAND;
    1: 
    1:             /* Fix the PN_LIST so it doesn't begin at the TOK_COLON. */
    1:             if (pn4->pn_head)
    1:                 pn4->pn_pos.begin = pn4->pn_head->pn_pos.begin;
    1:             pn3->pn_pos.end = pn4->pn_pos.end;
    1:             pn3->pn_right = pn4;
    1:         }
    1: 
    1:         /*
    1:          * Handle the case where there was a let declaration in any case in
    1:          * the switch body, but not within an inner block.  If it replaced
    1:          * tc->blockNode with a new block node then we must refresh pn2 and
    1:          * then restore tc->blockNode.
    1:          */
    1:         if (tc->blockNode != pn2)
    1:             pn2 = tc->blockNode;
    1:         tc->blockNode = saveBlock;
27012:         PopStatement(tc);
    1: 
    1:         pn->pn_pos.end = pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         pn->pn_left = pn1;
    1:         pn->pn_right = pn2;
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_WHILE:
27012:         pn = NewParseNode(PN_BINARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_WHILE_LOOP, -1);
    1:         pn2 = Condition(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_left = pn2;
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
27012:         PopStatement(tc);
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_right = pn2;
    1:         return pn;
    1: 
    1:       case TOK_DO:
27012:         pn = NewParseNode(PN_BINARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_DO_LOOP, -1);
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_left = pn2;
    1:         MUST_MATCH_TOKEN(TOK_WHILE, JSMSG_WHILE_AFTER_DO);
    1:         pn2 = Condition(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
27012:         PopStatement(tc);
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_right = pn2;
 1599:         if (JSVERSION_NUMBER(cx) != JSVERSION_ECMA_3) {
    1:             /*
    1:              * All legacy and extended versions must do automatic semicolon
    1:              * insertion after do-while.  See the testcase and discussion in
    1:              * http://bugzilla.mozilla.org/show_bug.cgi?id=238945.
    1:              */
    1:             (void) js_MatchToken(cx, ts, TOK_SEMI);
    1:             return pn;
    1:         }
    1:         break;
    1: 
    1:       case TOK_FOR:
    1:       {
20413:         JSParseNode *pnseq = NULL;
    1: #if JS_HAS_BLOCK_SCOPE
20413:         JSParseNode *pnlet = NULL;
    1:         JSStmtInfo blockInfo;
    1: #endif
    1: 
    1:         /* A FOR node is binary, left is loop control and right is the body. */
27012:         pn = NewParseNode(PN_BINARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_FOR_LOOP, -1);
    1: 
15613:         pn->pn_op = JSOP_ITER;
15613:         pn->pn_iflags = 0;
    1:         if (js_MatchToken(cx, ts, TOK_NAME)) {
    1:             if (CURRENT_TOKEN(ts).t_atom == cx->runtime->atomState.eachAtom)
15613:                 pn->pn_iflags = JSITER_FOREACH;
    1:             else
    1:                 js_UngetToken(ts);
    1:         }
    1: 
    1:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
    1:         ts->flags |= TSF_OPERAND;
    1:         tt = js_PeekToken(cx, ts);
    1:         ts->flags &= ~TSF_OPERAND;
27012: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:         bool let = false;
27012: #endif
27012: 
    1:         if (tt == TOK_SEMI) {
15613:             if (pn->pn_iflags & JSITER_FOREACH)
    1:                 goto bad_for_each;
    1: 
    1:             /* No initializer -- set first kid of left sub-node to null. */
    1:             pn1 = NULL;
    1:         } else {
    1:             /*
    1:              * Set pn1 to a var list or an initializing expression.
    1:              *
    1:              * Set the TCF_IN_FOR_INIT flag during parsing of the first clause
    1:              * of the for statement.  This flag will be used by the RelExpr
    1:              * production; if it is set, then the 'in' keyword will not be
    1:              * recognized as an operator, leaving it available to be parsed as
    1:              * part of a for/in loop.
    1:              *
    1:              * A side effect of this restriction is that (unparenthesized)
    1:              * expressions involving an 'in' operator are illegal in the init
    1:              * clause of an ordinary for loop.
    1:              */
    1:             tc->flags |= TCF_IN_FOR_INIT;
    1:             if (tt == TOK_VAR) {
    1:                 (void) js_GetToken(cx, ts);
27012:                 pn1 = Variables(cx, ts, tc, false);
    1: #if JS_HAS_BLOCK_SCOPE
    1:             } else if (tt == TOK_LET) {
27012:                 let = true;
    1:                 (void) js_GetToken(cx, ts);
    1:                 if (js_PeekToken(cx, ts) == TOK_LP) {
    1:                     pn1 = LetBlock(cx, ts, tc, JS_FALSE);
    1:                     tt = TOK_LEXICALSCOPE;
    1:                 } else {
    1:                     pnlet = PushLexicalScope(cx, ts, tc, &blockInfo);
    1:                     if (!pnlet)
    1:                         return NULL;
 9976:                     blockInfo.flags |= SIF_FOR_BLOCK;
27012:                     pn1 = Variables(cx, ts, tc, false);
    1:                 }
    1: #endif
    1:             } else {
    1:                 pn1 = Expr(cx, ts, tc);
    1:                 if (pn1) {
    1:                     while (pn1->pn_type == TOK_RP)
    1:                         pn1 = pn1->pn_kid;
    1:                 }
    1:             }
    1:             tc->flags &= ~TCF_IN_FOR_INIT;
    1:             if (!pn1)
    1:                 return NULL;
    1:         }
    1: 
    1:         /*
    1:          * We can be sure that it's a for/in loop if there's still an 'in'
    1:          * keyword here, even if JavaScript recognizes 'in' as an operator,
    1:          * as we've excluded 'in' from being parsed in RelExpr by setting
    1:          * the TCF_IN_FOR_INIT flag in our JSTreeContext.
    1:          */
    1:         if (pn1 && js_MatchToken(cx, ts, TOK_IN)) {
15613:             pn->pn_iflags |= JSITER_ENUMERATE;
    1:             stmtInfo.type = STMT_FOR_IN_LOOP;
    1: 
    1:             /* Check that the left side of the 'in' is valid. */
27012:             JS_ASSERT(!TOKEN_TYPE_IS_DECL(tt) || PN_TYPE(pn1) == tt);
    1:             if (TOKEN_TYPE_IS_DECL(tt)
    1:                 ? (pn1->pn_count > 1 || pn1->pn_op == JSOP_DEFCONST
    1: #if JS_HAS_DESTRUCTURING
 1599:                    || (JSVERSION_NUMBER(cx) == JSVERSION_1_7 &&
15613:                        pn->pn_op == JSOP_ITER &&
15613:                        !(pn->pn_iflags & JSITER_FOREACH) &&
    1:                        (pn1->pn_head->pn_type == TOK_RC ||
    1:                         (pn1->pn_head->pn_type == TOK_RB &&
    1:                          pn1->pn_head->pn_count != 2) ||
    1:                         (pn1->pn_head->pn_type == TOK_ASSIGN &&
    1:                          (pn1->pn_head->pn_left->pn_type != TOK_RB ||
    1:                           pn1->pn_head->pn_left->pn_count != 2))))
    1: #endif
    1:                   )
    1:                 : (pn1->pn_type != TOK_NAME &&
    1:                    pn1->pn_type != TOK_DOT &&
    1: #if JS_HAS_DESTRUCTURING
 1599:                    ((JSVERSION_NUMBER(cx) == JSVERSION_1_7 &&
15613:                      pn->pn_op == JSOP_ITER &&
15613:                      !(pn->pn_iflags & JSITER_FOREACH))
    1:                     ? (pn1->pn_type != TOK_RB || pn1->pn_count != 2)
    1:                     : (pn1->pn_type != TOK_RB && pn1->pn_type != TOK_RC)) &&
    1: #endif
    1: #if JS_HAS_LVALUE_RETURN
    1:                    pn1->pn_type != TOK_LP &&
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:                    (pn1->pn_type != TOK_UNARYOP ||
    1:                     pn1->pn_op != JSOP_XMLNAME) &&
    1: #endif
    1:                    pn1->pn_type != TOK_LB)) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, pn1, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_FOR_LEFTSIDE);
    1:                 return NULL;
    1:             }
    1: 
20413:             /* pn2 points to the name or destructuring pattern on in's left. */
20413:             pn2 = NULL;
27012:             uintN dflag = PND_ASSIGNED;
20413: 
    1:             if (TOKEN_TYPE_IS_DECL(tt)) {
    1:                 /* Tell js_EmitTree(TOK_VAR) that pn1 is part of a for/in. */
27012:                 pn1->pn_xflags |= PNX_FORINVAR;
    1: 
    1:                 /*
20413:                  * Rewrite 'for (<decl> x = i in o)' where <decl> is 'let',
20413:                  * 'var', or 'const' to hoist the initializer or the entire
20413:                  * decl out of the loop head. TOK_VAR is the type for both
20413:                  * 'var' and 'const'.
    1:                  */
    1:                 pn2 = pn1->pn_head;
27012:                 if ((pn2->pn_type == TOK_NAME && pn2->maybeExpr())
20413: #if JS_HAS_DESTRUCTURING
20413:                     || pn2->pn_type == TOK_ASSIGN
20413: #endif
20413:                     ) {
27012:                     pnseq = NewParseNode(PN_LIST, tc);
20413:                     if (!pnseq)
20413:                         return NULL;
20413:                     pnseq->pn_type = TOK_SEQ;
20413:                     pnseq->pn_pos.begin = pn->pn_pos.begin;
27012: 
27012: #if JS_HAS_BLOCK_SCOPE
20413:                     if (tt == TOK_LET) {
20413:                         /*
20413:                          * Hoist just the 'i' from 'for (let x = i in o)' to
20413:                          * before the loop, glued together via pnseq.
20413:                          */
27012:                         pn3 = NewParseNode(PN_UNARY, tc);
20413:                         if (!pn3)
20413:                             return NULL;
20413:                         pn3->pn_type = TOK_SEMI;
20413:                         pn3->pn_op = JSOP_NOP;
20413: #if JS_HAS_DESTRUCTURING
20413:                         if (pn2->pn_type == TOK_ASSIGN) {
20413:                             pn4 = pn2->pn_right;
20413:                             pn2 = pn1->pn_head = pn2->pn_left;
20413:                         } else
20413: #endif
20413:                         {
20413:                             pn4 = pn2->pn_expr;
20413:                             pn2->pn_expr = NULL;
20413:                         }
27012:                         if (!RebindLets(pn4, tc))
27012:                             return NULL;
20413:                         pn3->pn_pos = pn4->pn_pos;
20413:                         pn3->pn_kid = pn4;
27012:                         pnseq->initList(pn3);
27012:                     } else
27012: #endif /* JS_HAS_BLOCK_SCOPE */
27012:                     {
27012:                         dflag = PND_INITIALIZED;
27012: 
20413:                         /*
20413:                          * All of 'var x = i' is hoisted above 'for (x in o)',
20413:                          * so clear PNX_FORINVAR.
20413:                          *
20413:                          * Request JSOP_POP here since the var is for a simple
20413:                          * name (it is not a destructuring binding's left-hand
20413:                          * side) and it has an initializer.
20413:                          */
27012:                         pn1->pn_xflags &= ~PNX_FORINVAR;
27012:                         pn1->pn_xflags |= PNX_POPVAR;
27012:                         pnseq->initList(pn1);
20413: 
20413: #if JS_HAS_DESTRUCTURING
20413:                         if (pn2->pn_type == TOK_ASSIGN) {
27012:                             pn1 = CloneParseTree(pn2->pn_left, tc);
20413:                             if (!pn1)
20413:                                 return NULL;
20413:                         } else
20413: #endif
20413:                         {
27012:                             JS_ASSERT(pn2->pn_type == TOK_NAME);
27012:                             pn1 = NewNameNode(cx, ts, pn2->pn_atom, tc);
20413:                             if (!pn1)
20413:                                 return NULL;
20413:                             pn1->pn_type = TOK_NAME;
20413:                             pn1->pn_op = JSOP_NAME;
20413:                             pn1->pn_pos = pn2->pn_pos;
27012:                             if (pn2->pn_defn)
27012:                                 LinkUseToDef(pn1, (JSDefinition *) pn2, tc);
20413:                         }
20413:                         pn2 = pn1;
20413:                     }
20413:                 }
20413:             }
20413: 
20413:             if (!pn2) {
    1:                 pn2 = pn1;
    1: #if JS_HAS_LVALUE_RETURN
 1577:                 if (pn2->pn_type == TOK_LP &&
 7984:                     !MakeSetCall(cx, pn2, tc, JSMSG_BAD_LEFTSIDE_OF_ASS)) {
 1577:                     return NULL;
 1577:                 }
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:                 if (pn2->pn_type == TOK_UNARYOP)
    1:                     pn2->pn_op = JSOP_BINDXMLNAME;
    1: #endif
    1:             }
    1: 
    1:             switch (pn2->pn_type) {
    1:               case TOK_NAME:
    1:                 /* Beware 'for (arguments in ...)' with or without a 'var'. */
27012:                 NoteLValue(cx, pn2, tc, dflag);
    1:                 break;
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:               case TOK_ASSIGN:
    1:                 pn2 = pn2->pn_left;
    1:                 JS_ASSERT(pn2->pn_type == TOK_RB || pn2->pn_type == TOK_RC);
    1:                 /* FALL THROUGH */
    1:               case TOK_RB:
    1:               case TOK_RC:
    1:                 /* Check for valid lvalues in var-less destructuring for-in. */
    1:                 if (pn1 == pn2 && !CheckDestructuring(cx, NULL, pn2, NULL, tc))
    1:                     return NULL;
    1: 
 1599:                 if (JSVERSION_NUMBER(cx) == JSVERSION_1_7) {
 1599:                     /*
 1599:                      * Destructuring for-in requires [key, value] enumeration
 1599:                      * in JS1.7.
 1599:                      */
15613:                     JS_ASSERT(pn->pn_op == JSOP_ITER);
15613:                     if (!(pn->pn_iflags & JSITER_FOREACH))
15613:                         pn->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
 1599:                 }
    1:                 break;
    1: #endif
    1: 
    1:               default:;
    1:             }
    1: 
27012:             /*
27012:              * Parse the object expression as the right operand of 'in', first
27012:              * removing the top statement from the statement-stack if this is a
27012:              * 'for (let x in y)' loop.
27012:              */
27012: #if JS_HAS_BLOCK_SCOPE
27012:             JSStmtInfo *save = tc->topStmt;
27012:             if (let)
27012:                 tc->topStmt = save->down;
27012: #endif
27012:             pn2 = Expr(cx, ts, tc);
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (let)
27012:                 tc->topStmt = save;
27012: #endif
27012: 
27012:             pn2 = NewBinary(TOK_IN, JSOP_NOP, pn1, pn2, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn->pn_left = pn2;
    1:         } else {
15613:             if (pn->pn_iflags & JSITER_FOREACH)
    1:                 goto bad_for_each;
    1:             pn->pn_op = JSOP_NOP;
    1: 
    1:             /* Parse the loop condition or null into pn2. */
    1:             MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_INIT);
    1:             ts->flags |= TSF_OPERAND;
    1:             tt = js_PeekToken(cx, ts);
    1:             ts->flags &= ~TSF_OPERAND;
    1:             if (tt == TOK_SEMI) {
    1:                 pn2 = NULL;
    1:             } else {
    1:                 pn2 = Expr(cx, ts, tc);
    1:                 if (!pn2)
    1:                     return NULL;
    1:             }
    1: 
    1:             /* Parse the update expression or null into pn3. */
    1:             MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_COND);
    1:             ts->flags |= TSF_OPERAND;
    1:             tt = js_PeekToken(cx, ts);
    1:             ts->flags &= ~TSF_OPERAND;
    1:             if (tt == TOK_RP) {
    1:                 pn3 = NULL;
    1:             } else {
    1:                 pn3 = Expr(cx, ts, tc);
    1:                 if (!pn3)
    1:                     return NULL;
    1:             }
    1: 
20902:             /* Build the FORHEAD node to use as the left kid of pn. */
27012:             pn4 = NewParseNode(PN_TERNARY, tc);
    1:             if (!pn4)
    1:                 return NULL;
20902:             pn4->pn_type = TOK_FORHEAD;
    1:             pn4->pn_op = JSOP_NOP;
    1:             pn4->pn_kid1 = pn1;
    1:             pn4->pn_kid2 = pn2;
    1:             pn4->pn_kid3 = pn3;
    1:             pn->pn_left = pn4;
    1:         }
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
    1: 
    1:         /* Parse the loop body into pn->pn_right. */
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_right = pn2;
    1: 
    1:         /* Record the absolute line number for source note emission. */
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1:         if (pnlet) {
27012:             PopStatement(tc);
    1:             pnlet->pn_expr = pn;
    1:             pn = pnlet;
    1:         }
    1: #endif
20413:         if (pnseq) {
20413:             pnseq->pn_pos.end = pn->pn_pos.end;
27012:             pnseq->append(pn);
20413:             pn = pnseq;
20413:         }
27012:         PopStatement(tc);
    1:         return pn;
    1: 
    1:       bad_for_each:
 7984:         js_ReportCompileErrorNumber(cx, ts, pn, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_FOR_EACH_LOOP);
    1:         return NULL;
    1:       }
    1: 
    1:       case TOK_TRY: {
    1:         JSParseNode *catchList, *lastCatch;
    1: 
    1:         /*
    1:          * try nodes are ternary.
    1:          * kid1 is the try Statement
    1:          * kid2 is the catch node list or null
    1:          * kid3 is the finally Statement
    1:          *
    1:          * catch nodes are ternary.
    1:          * kid1 is the lvalue (TOK_NAME, TOK_LB, or TOK_LC)
    1:          * kid2 is the catch guard or null if no guard
    1:          * kid3 is the catch block
    1:          *
    1:          * catch lvalue nodes are either:
    1:          *   TOK_NAME for a single identifier
    1:          *   TOK_RB or TOK_RC for a destructuring left-hand side
    1:          *
    1:          * finally nodes are TOK_LC Statement lists.
    1:          */
27012:         pn = NewParseNode(PN_TERNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_op = JSOP_NOP;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_TRY);
27012:         if (!PushBlocklikeStatement(&stmtInfo, STMT_TRY, tc))
27012:             return NULL;
    1:         pn->pn_kid1 = Statements(cx, ts, tc);
    1:         if (!pn->pn_kid1)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_TRY);
27012:         PopStatement(tc);
    1: 
    1:         catchList = NULL;
    1:         tt = js_GetToken(cx, ts);
    1:         if (tt == TOK_CATCH) {
27012:             catchList = NewParseNode(PN_LIST, tc);
    1:             if (!catchList)
    1:                 return NULL;
    1:             catchList->pn_type = TOK_RESERVED;
27012:             catchList->makeEmpty();
    1:             lastCatch = NULL;
    1: 
    1:             do {
    1:                 JSParseNode *pnblock;
    1:                 BindData data;
    1: 
    1:                 /* Check for another catch after unconditional catch. */
    1:                 if (lastCatch && !lastCatch->pn_kid2) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_CATCH_AFTER_GENERAL);
    1:                     return NULL;
    1:                 }
    1: 
    1:                 /*
    1:                  * Create a lexical scope node around the whole catch clause,
    1:                  * including the head.
    1:                  */
    1:                 pnblock = PushLexicalScope(cx, ts, tc, &stmtInfo);
    1:                 if (!pnblock)
    1:                     return NULL;
    1:                 stmtInfo.type = STMT_CATCH;
    1: 
    1:                 /*
    1:                  * Legal catch forms are:
    1:                  *   catch (lhs)
    1:                  *   catch (lhs if <boolean_expression>)
    1:                  * where lhs is a name or a destructuring left-hand side.
    1:                  * (the latter is legal only #ifdef JS_HAS_CATCH_GUARD)
    1:                  */
27012:                 pn2 = NewParseNode(PN_TERNARY, tc);
    1:                 if (!pn2)
    1:                     return NULL;
    1:                 pnblock->pn_expr = pn2;
    1:                 MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_CATCH);
    1: 
    1:                 /*
    1:                  * Contrary to ECMA Ed. 3, the catch variable is lexically
    1:                  * scoped, not a property of a new Object instance.  This is
    1:                  * an intentional change that anticipates ECMA Ed. 4.
    1:                  */
    1:                 data.pn = NULL;
    1:                 data.op = JSOP_NOP;
    1:                 data.binder = BindLet;
27012:                 data.let.overflow = JSMSG_TOO_MANY_CATCH_VARS;
    1: 
    1:                 tt = js_GetToken(cx, ts);
    1:                 switch (tt) {
    1: #if JS_HAS_DESTRUCTURING
    1:                   case TOK_LB:
    1:                   case TOK_LC:
    1:                     pn3 = DestructuringExpr(cx, &data, tc, tt);
    1:                     if (!pn3)
    1:                         return NULL;
    1:                     break;
    1: #endif
    1: 
    1:                   case TOK_NAME:
    1:                     label = CURRENT_TOKEN(ts).t_atom;
27012:                     pn3 = NewBindingNode(ts, label, tc, true);
27012:                     if (!pn3)
27012:                         return NULL;
27012:                     data.pn = pn3;
26970:                     if (!data.binder(cx, &data, label, tc))
26970:                         return NULL;
    1:                     break;
    1: 
    1:                   default:
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_CATCH_IDENTIFIER);
    1:                     return NULL;
    1:                 }
    1: 
    1:                 pn2->pn_kid1 = pn3;
    1: #if JS_HAS_CATCH_GUARD
    1:                 /*
    1:                  * We use 'catch (x if x === 5)' (not 'catch (x : x === 5)')
    1:                  * to avoid conflicting with the JS2/ECMAv4 type annotation
    1:                  * catchguard syntax.
    1:                  */
    1:                 if (js_MatchToken(cx, ts, TOK_IF)) {
    1:                     pn2->pn_kid2 = Expr(cx, ts, tc);
    1:                     if (!pn2->pn_kid2)
    1:                         return NULL;
    1:                 }
    1: #endif
    1:                 MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_CATCH);
    1: 
    1:                 MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_CATCH);
    1:                 pn2->pn_kid3 = Statements(cx, ts, tc);
    1:                 if (!pn2->pn_kid3)
    1:                     return NULL;
    1:                 MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_CATCH);
27012:                 PopStatement(tc);
27012: 
27012:                 catchList->append(pnblock);
    1:                 lastCatch = pn2;
    1:                 ts->flags |= TSF_OPERAND;
    1:                 tt = js_GetToken(cx, ts);
    1:                 ts->flags &= ~TSF_OPERAND;
    1:             } while (tt == TOK_CATCH);
    1:         }
    1:         pn->pn_kid2 = catchList;
    1: 
    1:         if (tt == TOK_FINALLY) {
    1:             MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_FINALLY);
27012:             if (!PushBlocklikeStatement(&stmtInfo, STMT_FINALLY, tc))
27012:                 return NULL;
    1:             pn->pn_kid3 = Statements(cx, ts, tc);
    1:             if (!pn->pn_kid3)
    1:                 return NULL;
    1:             MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_FINALLY);
27012:             PopStatement(tc);
    1:         } else {
    1:             js_UngetToken(ts);
    1:         }
    1:         if (!catchList && !pn->pn_kid3) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_CATCH_OR_FINALLY);
    1:             return NULL;
    1:         }
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_THROW:
27012:         pn = NewParseNode(PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* ECMA-262 Edition 3 says 'throw [no LineTerminator here] Expr'. */
    1:         ts->flags |= TSF_OPERAND;
    1:         tt = js_PeekTokenSameLine(cx, ts);
    1:         ts->flags &= ~TSF_OPERAND;
    1:         if (tt == TOK_ERROR)
    1:             return NULL;
    1:         if (tt == TOK_EOF || tt == TOK_EOL || tt == TOK_SEMI || tt == TOK_RC) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_SYNTAX_ERROR);
    1:             return NULL;
    1:         }
    1: 
    1:         pn2 = Expr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_op = JSOP_THROW;
    1:         pn->pn_kid = pn2;
    1:         break;
    1: 
    1:       /* TOK_CATCH and TOK_FINALLY are both handled in the TOK_TRY case */
    1:       case TOK_CATCH:
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_CATCH_WITHOUT_TRY);
    1:         return NULL;
    1: 
    1:       case TOK_FINALLY:
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_FINALLY_WITHOUT_TRY);
    1:         return NULL;
    1: 
    1:       case TOK_BREAK:
27012:         pn = NewParseNode(PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         if (!MatchLabel(cx, ts, pn))
    1:             return NULL;
    1:         stmt = tc->topStmt;
    1:         label = pn->pn_atom;
    1:         if (label) {
    1:             for (; ; stmt = stmt->down) {
    1:                 if (!stmt) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_LABEL_NOT_FOUND);
    1:                     return NULL;
    1:                 }
27012:                 if (stmt->type == STMT_LABEL && stmt->label == label)
    1:                     break;
    1:             }
    1:         } else {
    1:             for (; ; stmt = stmt->down) {
    1:                 if (!stmt) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_TOUGH_BREAK);
    1:                     return NULL;
    1:                 }
    1:                 if (STMT_IS_LOOP(stmt) || stmt->type == STMT_SWITCH)
    1:                     break;
    1:             }
    1:         }
    1:         if (label)
    1:             pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         break;
    1: 
    1:       case TOK_CONTINUE:
27012:         pn = NewParseNode(PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         if (!MatchLabel(cx, ts, pn))
    1:             return NULL;
    1:         stmt = tc->topStmt;
    1:         label = pn->pn_atom;
    1:         if (label) {
    1:             for (stmt2 = NULL; ; stmt = stmt->down) {
    1:                 if (!stmt) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_LABEL_NOT_FOUND);
    1:                     return NULL;
    1:                 }
    1:                 if (stmt->type == STMT_LABEL) {
27012:                     if (stmt->label == label) {
    1:                         if (!stmt2 || !STMT_IS_LOOP(stmt2)) {
 7984:                             js_ReportCompileErrorNumber(cx, ts, NULL,
    1:                                                         JSREPORT_ERROR,
    1:                                                         JSMSG_BAD_CONTINUE);
    1:                             return NULL;
    1:                         }
    1:                         break;
    1:                     }
    1:                 } else {
    1:                     stmt2 = stmt;
    1:                 }
    1:             }
    1:         } else {
    1:             for (; ; stmt = stmt->down) {
    1:                 if (!stmt) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_BAD_CONTINUE);
    1:                     return NULL;
    1:                 }
    1:                 if (STMT_IS_LOOP(stmt))
    1:                     break;
    1:             }
    1:         }
    1:         if (label)
    1:             pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         break;
    1: 
    1:       case TOK_WITH:
27012:         pn = NewParseNode(PN_BINARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_WITH);
 1577:         pn2 = ParenExpr(cx, ts, tc, NULL, NULL);
    1:         if (!pn2)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_WITH);
    1:         pn->pn_left = pn2;
    1: 
    1:         js_PushStatement(tc, &stmtInfo, STMT_WITH, -1);
    1:         pn2 = Statement(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
27012:         PopStatement(tc);
    1: 
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_right = pn2;
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:         return pn;
    1: 
    1:       case TOK_VAR:
27012:         pn = Variables(cx, ts, tc, false);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* Tell js_EmitTree to generate a final POP. */
27012:         pn->pn_xflags |= PNX_POPVAR;
    1:         break;
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1:       case TOK_LET:
    1:       {
    1:         JSObject *obj;
27012:         JSObjectBox *blockbox;
    1: 
    1:         /* Check for a let statement or let expression. */
    1:         if (js_PeekToken(cx, ts) == TOK_LP) {
    1:             pn = LetBlock(cx, ts, tc, JS_TRUE);
    1:             if (!pn || pn->pn_op == JSOP_LEAVEBLOCK)
    1:                 return pn;
    1: 
    1:             /* Let expressions require automatic semicolon insertion. */
    1:             JS_ASSERT(pn->pn_type == TOK_SEMI ||
    1:                       pn->pn_op == JSOP_LEAVEBLOCKEXPR);
    1:             break;
    1:         }
    1: 
    1:         /*
 9976:          * This is a let declaration. We must be directly under a block per
 9976:          * the proposed ES4 specs, but not an implicit block created due to
 9976:          * 'for (let ...)'. If we pass this error test, make the enclosing
 9976:          * JSStmtInfo be our scope. Further let declarations in this block
 9976:          * will find this scope statement and use the same block object.
 9976:          *
 9976:          * If we are the first let declaration in this block (i.e., when the
 9976:          * enclosing maybe-scope JSStmtInfo isn't yet a scope statement) then
 9976:          * we also need to set tc->blockNode to be our TOK_LEXICALSCOPE.
    1:          */
 9832:         stmt = tc->topStmt;
 9976:         if (stmt &&
 9976:             (!STMT_MAYBE_SCOPE(stmt) || (stmt->flags & SIF_FOR_BLOCK))) {
 9832:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
 9832:                                         JSMSG_LET_DECL_NOT_IN_BLOCK);
 9832:             return NULL;
    1:         }
    1: 
    1:         if (stmt && (stmt->flags & SIF_SCOPE)) {
27012:             JS_ASSERT(tc->blockChain == stmt->blockObj);
    1:             obj = tc->blockChain;
    1:         } else {
16379:             if (!stmt || (stmt->flags & SIF_BODY_BLOCK)) {
    1:                 /*
16379:                  * ES4 specifies that let at top level and at body-block scope
16379:                  * does not shadow var, so convert back to var.
    1:                  */
    1:                 CURRENT_TOKEN(ts).type = TOK_VAR;
    1:                 CURRENT_TOKEN(ts).t_op = JSOP_DEFVAR;
    1: 
27012:                 pn = Variables(cx, ts, tc, false);
    1:                 if (!pn)
    1:                     return NULL;
27012:                 pn->pn_xflags |= PNX_POPVAR;
    1:                 break;
    1:             }
    1: 
18084:             /*
18084:              * Some obvious assertions here, but they may help clarify the
18084:              * situation. This stmt is not yet a scope, so it must not be a
27012:              * catch block (catch is a lexical scope by definition).
18084:              */
18084:             JS_ASSERT(!(stmt->flags & SIF_SCOPE));
18084:             JS_ASSERT(stmt != tc->topScopeStmt);
18084:             JS_ASSERT(stmt->type == STMT_BLOCK ||
18084:                       stmt->type == STMT_SWITCH ||
18084:                       stmt->type == STMT_TRY ||
18084:                       stmt->type == STMT_FINALLY);
18084:             JS_ASSERT(!stmt->downScope);
18084: 
    1:             /* Convert the block statement into a scope statement. */
27012:             JSObject *obj = js_NewBlockObject(tc->compiler->context);
    1:             if (!obj)
    1:                 return NULL;
27012: 
27012:             blockbox = tc->compiler->newObjectBox(obj);
27012:             if (!blockbox)
    1:                 return NULL;
    1: 
    1:             /*
    1:              * Insert stmt on the tc->topScopeStmt/stmtInfo.downScope linked
    1:              * list stack, if it isn't already there.  If it is there, but it
    1:              * lacks the SIF_SCOPE flag, it must be a try, catch, or finally
    1:              * block.
    1:              */
    1:             stmt->flags |= SIF_SCOPE;
 9832:             stmt->downScope = tc->topScopeStmt;
 9832:             tc->topScopeStmt = stmt;
18084:             JS_SCOPE_DEPTH_METERING(++tc->scopeDepth > tc->maxScopeDepth &&
18084:                                     (tc->maxScopeDepth = tc->scopeDepth));
    1: 
    1:             STOBJ_SET_PARENT(obj, tc->blockChain);
    1:             tc->blockChain = obj;
27012:             stmt->blockObj = obj;
    1: 
    1: #ifdef DEBUG
    1:             pn1 = tc->blockNode;
    1:             JS_ASSERT(!pn1 || pn1->pn_type != TOK_LEXICALSCOPE);
    1: #endif
    1: 
    1:             /* Create a new lexical scope node for these statements. */
27012:             pn1 = NewParseNode(PN_NAME, tc);
    1:             if (!pn1)
    1:                 return NULL;
    1: 
    1:             pn1->pn_type = TOK_LEXICALSCOPE;
    1:             pn1->pn_op = JSOP_LEAVEBLOCK;
    1:             pn1->pn_pos = tc->blockNode->pn_pos;
27012:             pn1->pn_objbox = blockbox;
    1:             pn1->pn_expr = tc->blockNode;
27012:             pn1->pn_blockid = tc->blockNode->pn_blockid;
    1:             tc->blockNode = pn1;
    1:         }
    1: 
27012:         pn = Variables(cx, ts, tc, false);
    1:         if (!pn)
    1:             return NULL;
27012:         pn->pn_xflags = PNX_POPVAR;
    1:         break;
    1:       }
    1: #endif /* JS_HAS_BLOCK_SCOPE */
    1: 
    1:       case TOK_RETURN:
    1:         pn = ReturnOrYield(cx, ts, tc, Expr);
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_LC:
    1:       {
    1:         uintN oldflags;
    1: 
    1:         oldflags = tc->flags;
    1:         tc->flags = oldflags & ~TCF_HAS_FUNCTION_STMT;
27012:         if (!PushBlocklikeStatement(&stmtInfo, STMT_BLOCK, tc))
27012:             return NULL;
    1:         pn = Statements(cx, ts, tc);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_COMPOUND);
27012:         PopStatement(tc);
    1: 
    1:         /*
    1:          * If we contain a function statement and our container is top-level
    1:          * or another block, flag pn to preserve braces when decompiling.
    1:          */
    1:         if ((tc->flags & TCF_HAS_FUNCTION_STMT) &&
    1:             (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)) {
27012:             pn->pn_xflags |= PNX_NEEDBRACES;
    1:         }
    1:         tc->flags = oldflags | (tc->flags & (TCF_FUN_FLAGS | TCF_RETURN_FLAGS));
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_EOL:
    1:       case TOK_SEMI:
27012:         pn = NewParseNode(PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_SEMI;
    1:         return pn;
    1: 
    1: #if JS_HAS_DEBUGGER_KEYWORD
    1:       case TOK_DEBUGGER:
27012:         pn = NewParseNode(PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_DEBUGGER;
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:         break;
    1: #endif /* JS_HAS_DEBUGGER_KEYWORD */
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_DEFAULT:
27012:         pn = NewParseNode(PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         if (!js_MatchToken(cx, ts, TOK_NAME) ||
    1:             CURRENT_TOKEN(ts).t_atom != cx->runtime->atomState.xmlAtom ||
    1:             !js_MatchToken(cx, ts, TOK_NAME) ||
    1:             CURRENT_TOKEN(ts).t_atom != cx->runtime->atomState.namespaceAtom ||
    1:             !js_MatchToken(cx, ts, TOK_ASSIGN) ||
    1:             CURRENT_TOKEN(ts).t_op != JSOP_NOP) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_BAD_DEFAULT_XML_NAMESPACE);
    1:             return NULL;
    1:         }
    1:         pn2 = Expr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_op = JSOP_DEFXMLNS;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:         break;
    1: #endif
    1: 
    1:       case TOK_ERROR:
    1:         return NULL;
    1: 
    1:       default:
    1: #if JS_HAS_XML_SUPPORT
    1:       expression:
    1: #endif
    1:         js_UngetToken(ts);
    1:         pn2 = Expr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1: 
    1:         if (js_PeekToken(cx, ts) == TOK_COLON) {
    1:             if (pn2->pn_type != TOK_NAME) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_LABEL);
    1:                 return NULL;
    1:             }
    1:             label = pn2->pn_atom;
    1:             for (stmt = tc->topStmt; stmt; stmt = stmt->down) {
27012:                 if (stmt->type == STMT_LABEL && stmt->label == label) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_DUPLICATE_LABEL);
    1:                     return NULL;
    1:                 }
    1:             }
27012:             ForgetUse(pn2);
27012: 
    1:             (void) js_GetToken(cx, ts);
    1: 
    1:             /* Push a label struct and parse the statement. */
    1:             js_PushStatement(tc, &stmtInfo, STMT_LABEL, -1);
27012:             stmtInfo.label = label;
    1:             pn = Statement(cx, ts, tc);
    1:             if (!pn)
    1:                 return NULL;
    1: 
    1:             /* Normalize empty statement to empty block for the decompiler. */
    1:             if (pn->pn_type == TOK_SEMI && !pn->pn_kid) {
    1:                 pn->pn_type = TOK_LC;
    1:                 pn->pn_arity = PN_LIST;
27012:                 pn->makeEmpty();
    1:             }
    1: 
    1:             /* Pop the label, set pn_expr, and return early. */
27012:             PopStatement(tc);
    1:             pn2->pn_type = TOK_COLON;
    1:             pn2->pn_pos.end = pn->pn_pos.end;
    1:             pn2->pn_expr = pn;
    1:             return pn2;
    1:         }
    1: 
27012:         pn = NewParseNode(PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_SEMI;
    1:         pn->pn_pos = pn2->pn_pos;
    1:         pn->pn_kid = pn2;
    1:         break;
    1:     }
    1: 
    1:     /* Check termination of this primitive statement. */
25110:     return MatchOrInsertSemicolon(cx, ts) ? pn : NULL;
    1: }
    1: 
    1: static JSParseNode *
27012: Variables(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc, bool inLetHead)
    1: {
    1:     JSTokenType tt;
27012:     bool let;
    1:     JSStmtInfo *scopeStmt;
    1:     BindData data;
    1:     JSParseNode *pn, *pn2;
    1:     JSAtom *atom;
    1: 
    1:     /*
    1:      * The three options here are:
    1:      * - TOK_LET: We are parsing a let declaration.
    1:      * - TOK_LP: We are parsing the head of a let block.
    1:      * - Otherwise, we're parsing var declarations.
    1:      */
    1:     tt = CURRENT_TOKEN(ts).type;
    1:     let = (tt == TOK_LET || tt == TOK_LP);
    1:     JS_ASSERT(let || tt == TOK_VAR);
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:     bool popScope = (inLetHead || (let && (tc->flags & TCF_IN_FOR_INIT)));
27012:     JSStmtInfo *save = tc->topStmt, *saveScope = tc->topScopeStmt;
27012: #endif
27012: 
27012:     /* Make sure that Statement set up the tree context correctly. */
    1:     scopeStmt = tc->topScopeStmt;
    1:     if (let) {
    1:         while (scopeStmt && !(scopeStmt->flags & SIF_SCOPE)) {
    1:             JS_ASSERT(!STMT_MAYBE_SCOPE(scopeStmt));
    1:             scopeStmt = scopeStmt->downScope;
    1:         }
    1:         JS_ASSERT(scopeStmt);
    1:     }
    1: 
    1:     data.op = let ? JSOP_NOP : CURRENT_TOKEN(ts).t_op;
27012:     pn = NewParseNode(PN_LIST, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_op = data.op;
27012:     pn->makeEmpty();
27012: 
27012:     /*
27012:      * SpiderMonkey const is really "write once per initialization evaluation"
27012:      * var, whereas let is block scoped. ES-Harmony wants block-scoped const so
27012:      * this code will change soon.
    1:      */
    1:     if (let) {
27012:         JS_ASSERT(tc->blockChain == scopeStmt->blockObj);
 8444:         data.binder = BindLet;
27012:         data.let.overflow = JSMSG_TOO_MANY_LOCALS;
    1:     } else {
 8444:         data.binder = BindVarOrConst;
    1:     }
    1: 
    1:     do {
    1:         tt = js_GetToken(cx, ts);
    1: #if JS_HAS_DESTRUCTURING
    1:         if (tt == TOK_LB || tt == TOK_LC) {
27012:             ts->flags |= TSF_DESTRUCTURING;
    1:             pn2 = PrimaryExpr(cx, ts, tc, tt, JS_FALSE);
27012:             ts->flags &= ~TSF_DESTRUCTURING;
    1:             if (!pn2)
    1:                 return NULL;
    1: 
    1:             if ((tc->flags & TCF_IN_FOR_INIT) &&
    1:                 js_PeekToken(cx, ts) == TOK_IN) {
    1:                 if (!CheckDestructuring(cx, &data, pn2, NULL, tc))
    1:                     return NULL;
27012:                 pn->append(pn2);
    1:                 continue;
    1:             }
    1: 
    1:             MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_BAD_DESTRUCT_DECL);
    1:             if (CURRENT_TOKEN(ts).t_op != JSOP_NOP)
    1:                 goto bad_var_init;
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save->down;
27012:                 tc->topScopeStmt = saveScope->downScope;
27012:             }
27012: #endif
27012:             JSParseNode *init = AssignExpr(cx, ts, tc);
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save;
27012:                 tc->topScopeStmt = saveScope;
27012:             }
27012: #endif
27012: 
27012:             pn2 = NewBinary(TOK_ASSIGN, JSOP_NOP, pn2, init, tc);
    1:             if (!pn2 ||
    1:                 !CheckDestructuring(cx, &data,
    1:                                     pn2->pn_left, pn2->pn_right,
    1:                                     tc)) {
    1:                 return NULL;
    1:             }
27012:             pn->append(pn2);
    1:             continue;
    1:         }
27012: #endif /* JS_HAS_DESTRUCTURING */
    1: 
    1:         if (tt != TOK_NAME) {
27012:             if (tt != TOK_ERROR) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_NO_VARIABLE_NAME);
27012:             }
27012:             return NULL;
27012:         }
27012: 
    1:         atom = CURRENT_TOKEN(ts).t_atom;
27012:         pn2 = NewBindingNode(ts, atom, tc, let);
27012:         if (!pn2)
27012:             return NULL;
27012:         if (data.op == JSOP_DEFCONST)
27012:             pn2->pn_dflags |= PND_CONST;
27012:         data.pn = pn2;
26970:         if (!data.binder(cx, &data, atom, tc))
26970:             return NULL;
27012:         pn->append(pn2);
    1: 
    1:         if (js_MatchToken(cx, ts, TOK_ASSIGN)) {
    1:             if (CURRENT_TOKEN(ts).t_op != JSOP_NOP)
    1:                 goto bad_var_init;
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save->down;
27012:                 tc->topScopeStmt = saveScope->downScope;
27012:             }
27012: #endif
27012:             JSParseNode *init = AssignExpr(cx, ts, tc);
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save;
27012:                 tc->topScopeStmt = saveScope;
27012:             }
27012: #endif
27012:             if (!init)
27012:                 return NULL;
27012: 
27012:             if (pn2->pn_used) {
27012:                 pn2 = MakeAssignment(pn2, init, tc);
27012:                 if (!pn2)
27012:                     return NULL;
27012:             } else {
27012:                 pn2->pn_expr = init;
27012:             }
27012: 
27012:             pn2->pn_op = (PN_OP(pn2) == JSOP_ARGUMENTS)
27012:                          ? JSOP_SETNAME
27012:                          : (pn2->pn_dflags & PND_GVAR)
27012:                          ? JSOP_SETGVAR
27012:                          : (pn2->pn_dflags & PND_BOUND)
27012:                          ? JSOP_SETLOCAL
27012:                          : (data.op == JSOP_DEFCONST)
    1:                          ? JSOP_SETCONST
    1:                          : JSOP_SETNAME;
27012: 
27012:             NoteLValue(cx, pn2, tc, PND_INITIALIZED);
27012: 
27012:             /* The declarator's position must include the initializer. */
27012:             pn2->pn_pos.end = init->pn_pos.end;
27012: 
27012:             if (atom == cx->runtime->atomState.argumentsAtom) {
27012:                 tc->flags |= TCF_FUN_USES_ARGUMENTS;
27012:                 if (!let)
    1:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:             }
27012:         }
    1:     } while (js_MatchToken(cx, ts, TOK_COMMA));
    1: 
27012:     pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     return pn;
    1: 
    1: bad_var_init:
 7984:     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                 JSMSG_BAD_VAR_INIT);
    1:     return NULL;
    1: }
    1: 
    1: static JSParseNode *
    1: Expr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2;
    1: 
    1:     pn = AssignExpr(cx, ts, tc);
    1:     if (pn && js_MatchToken(cx, ts, TOK_COMMA)) {
27012:         pn2 = NewParseNode(PN_LIST, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn2->pn_pos.begin = pn->pn_pos.begin;
27012:         pn2->initList(pn);
    1:         pn = pn2;
    1:         do {
    1: #if JS_HAS_GENERATORS
27012:             pn2 = pn->last();
    1:             if (pn2->pn_type == TOK_YIELD) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, pn2, JSREPORT_ERROR,
 1577:                                             JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                             js_yield_str);
    1:                 return NULL;
    1:             }
    1: #endif
    1:             pn2 = AssignExpr(cx, ts, tc);
    1:             if (!pn2)
    1:                 return NULL;
27012:             pn->append(pn2);
    1:         } while (js_MatchToken(cx, ts, TOK_COMMA));
27012:         pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: AssignExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2;
    1:     JSTokenType tt;
    1:     JSOp op;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1: #if JS_HAS_GENERATORS
    1:     ts->flags |= TSF_OPERAND;
    1:     if (js_MatchToken(cx, ts, TOK_YIELD)) {
    1:         ts->flags &= ~TSF_OPERAND;
    1:         return ReturnOrYield(cx, ts, tc, AssignExpr);
    1:     }
    1:     ts->flags &= ~TSF_OPERAND;
    1: #endif
    1: 
    1:     pn = CondExpr(cx, ts, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     tt = js_GetToken(cx, ts);
    1: #if JS_HAS_GETTER_SETTER
    1:     if (tt == TOK_NAME) {
    1:         tt = CheckGetterOrSetter(cx, ts, TOK_ASSIGN);
    1:         if (tt == TOK_ERROR)
    1:             return NULL;
    1:     }
    1: #endif
    1:     if (tt != TOK_ASSIGN) {
    1:         js_UngetToken(ts);
    1:         return pn;
    1:     }
    1: 
    1:     op = CURRENT_TOKEN(ts).t_op;
    1:     for (pn2 = pn; pn2->pn_type == TOK_RP; pn2 = pn2->pn_kid)
    1:         continue;
    1:     switch (pn2->pn_type) {
    1:       case TOK_NAME:
    1:         pn2->pn_op = JSOP_SETNAME;
27012:         NoteLValue(cx, pn2, tc);
    1:         break;
    1:       case TOK_DOT:
    1:         pn2->pn_op = JSOP_SETPROP;
    1:         break;
    1:       case TOK_LB:
    1:         pn2->pn_op = JSOP_SETELEM;
    1:         break;
    1: #if JS_HAS_DESTRUCTURING
    1:       case TOK_RB:
    1:       case TOK_RC:
    1:         if (op != JSOP_NOP) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_BAD_DESTRUCT_ASS);
    1:             return NULL;
    1:         }
    1:         pn = AssignExpr(cx, ts, tc);
    1:         if (!pn || !CheckDestructuring(cx, NULL, pn2, pn, tc))
    1:             return NULL;
27012:         return NewBinary(TOK_ASSIGN, op, pn2, pn, tc);
    1: #endif
    1: #if JS_HAS_LVALUE_RETURN
    1:       case TOK_LP:
 7984:         if (!MakeSetCall(cx, pn2, tc, JSMSG_BAD_LEFTSIDE_OF_ASS))
 1577:             return NULL;
    1:         break;
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_UNARYOP:
    1:         if (pn2->pn_op == JSOP_XMLNAME) {
    1:             pn2->pn_op = JSOP_SETXMLNAME;
    1:             break;
    1:         }
    1:         /* FALL THROUGH */
    1: #endif
    1:       default:
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_LEFTSIDE_OF_ASS);
    1:         return NULL;
    1:     }
    1: 
27012:     return NewBinary(TOK_ASSIGN, op, pn2, AssignExpr(cx, ts, tc), tc);
    1: }
    1: 
    1: static JSParseNode *
    1: CondExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn1, *pn2, *pn3;
    1:     uintN oldflags;
    1: 
    1:     pn = OrExpr(cx, ts, tc);
    1:     if (pn && js_MatchToken(cx, ts, TOK_HOOK)) {
    1:         pn1 = pn;
27012:         pn = NewParseNode(PN_TERNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         /*
    1:          * Always accept the 'in' operator in the middle clause of a ternary,
    1:          * where it's unambiguous, even if we might be parsing the init of a
    1:          * for statement.
    1:          */
    1:         oldflags = tc->flags;
    1:         tc->flags &= ~TCF_IN_FOR_INIT;
    1:         pn2 = AssignExpr(cx, ts, tc);
    1:         tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1: 
    1:         if (!pn2)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_IN_COND);
    1:         pn3 = AssignExpr(cx, ts, tc);
    1:         if (!pn3)
    1:             return NULL;
    1:         pn->pn_pos.begin = pn1->pn_pos.begin;
    1:         pn->pn_pos.end = pn3->pn_pos.end;
    1:         pn->pn_kid1 = pn1;
    1:         pn->pn_kid2 = pn2;
    1:         pn->pn_kid3 = pn3;
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: OrExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = AndExpr(cx, ts, tc);
 6116:     while (pn && js_MatchToken(cx, ts, TOK_OR))
27012:         pn = NewBinary(TOK_OR, JSOP_OR, pn, AndExpr(cx, ts, tc), tc);
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: AndExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = BitOrExpr(cx, ts, tc);
 6116:     while (pn && js_MatchToken(cx, ts, TOK_AND))
27012:         pn = NewBinary(TOK_AND, JSOP_AND, pn, BitOrExpr(cx, ts, tc), tc);
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: BitOrExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = BitXorExpr(cx, ts, tc);
    1:     while (pn && js_MatchToken(cx, ts, TOK_BITOR)) {
27012:         pn = NewBinary(TOK_BITOR, JSOP_BITOR, pn, BitXorExpr(cx, ts, tc),
    1:                        tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: BitXorExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = BitAndExpr(cx, ts, tc);
    1:     while (pn && js_MatchToken(cx, ts, TOK_BITXOR)) {
27012:         pn = NewBinary(TOK_BITXOR, JSOP_BITXOR, pn, BitAndExpr(cx, ts, tc),
    1:                        tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: BitAndExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = EqExpr(cx, ts, tc);
    1:     while (pn && js_MatchToken(cx, ts, TOK_BITAND))
27012:         pn = NewBinary(TOK_BITAND, JSOP_BITAND, pn, EqExpr(cx, ts, tc), tc);
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: EqExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSOp op;
    1: 
    1:     pn = RelExpr(cx, ts, tc);
    1:     while (pn && js_MatchToken(cx, ts, TOK_EQOP)) {
    1:         op = CURRENT_TOKEN(ts).t_op;
27012:         pn = NewBinary(TOK_EQOP, op, pn, RelExpr(cx, ts, tc), tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: RelExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSTokenType tt;
    1:     JSOp op;
    1:     uintN inForInitFlag = tc->flags & TCF_IN_FOR_INIT;
    1: 
    1:     /*
    1:      * Uses of the in operator in ShiftExprs are always unambiguous,
    1:      * so unset the flag that prohibits recognizing it.
    1:      */
    1:     tc->flags &= ~TCF_IN_FOR_INIT;
    1: 
    1:     pn = ShiftExpr(cx, ts, tc);
    1:     while (pn &&
    1:            (js_MatchToken(cx, ts, TOK_RELOP) ||
    1:             /*
    1:              * Recognize the 'in' token as an operator only if we're not
    1:              * currently in the init expr of a for loop.
    1:              */
    1:             (inForInitFlag == 0 && js_MatchToken(cx, ts, TOK_IN)) ||
    1:             js_MatchToken(cx, ts, TOK_INSTANCEOF))) {
    1:         tt = CURRENT_TOKEN(ts).type;
    1:         op = CURRENT_TOKEN(ts).t_op;
27012:         pn = NewBinary(tt, op, pn, ShiftExpr(cx, ts, tc), tc);
    1:     }
    1:     /* Restore previous state of inForInit flag. */
    1:     tc->flags |= inForInitFlag;
    1: 
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: ShiftExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSOp op;
    1: 
    1:     pn = AddExpr(cx, ts, tc);
    1:     while (pn && js_MatchToken(cx, ts, TOK_SHOP)) {
    1:         op = CURRENT_TOKEN(ts).t_op;
27012:         pn = NewBinary(TOK_SHOP, op, pn, AddExpr(cx, ts, tc), tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: AddExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSTokenType tt;
    1:     JSOp op;
    1: 
    1:     pn = MulExpr(cx, ts, tc);
    1:     while (pn &&
    1:            (js_MatchToken(cx, ts, TOK_PLUS) ||
    1:             js_MatchToken(cx, ts, TOK_MINUS))) {
    1:         tt = CURRENT_TOKEN(ts).type;
    1:         op = (tt == TOK_PLUS) ? JSOP_ADD : JSOP_SUB;
27012:         pn = NewBinary(tt, op, pn, MulExpr(cx, ts, tc), tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: MulExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSTokenType tt;
    1:     JSOp op;
    1: 
    1:     pn = UnaryExpr(cx, ts, tc);
    1:     while (pn &&
    1:            (js_MatchToken(cx, ts, TOK_STAR) ||
    1:             js_MatchToken(cx, ts, TOK_DIVOP))) {
    1:         tt = CURRENT_TOKEN(ts).type;
    1:         op = CURRENT_TOKEN(ts).t_op;
27012:         pn = NewBinary(tt, op, pn, UnaryExpr(cx, ts, tc), tc);
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: SetLvalKid(JSContext *cx, JSTokenStream *ts, JSParseNode *pn, JSParseNode *kid,
    1:            const char *name)
    1: {
    1:     while (kid->pn_type == TOK_RP)
    1:         kid = kid->pn_kid;
    1:     if (kid->pn_type != TOK_NAME &&
    1:         kid->pn_type != TOK_DOT &&
    1: #if JS_HAS_LVALUE_RETURN
  279:         (kid->pn_type != TOK_LP ||
21460:          (kid->pn_op != JSOP_CALL && kid->pn_op != JSOP_EVAL && kid->pn_op != JSOP_APPLY)) &&
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:         (kid->pn_type != TOK_UNARYOP || kid->pn_op != JSOP_XMLNAME) &&
    1: #endif
    1:         kid->pn_type != TOK_LB) {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_OPERAND, name);
    1:         return NULL;
    1:     }
    1:     pn->pn_kid = kid;
    1:     return kid;
    1: }
    1: 
    1: static const char incop_name_str[][10] = {"increment", "decrement"};
    1: 
    1: static JSBool
    1: SetIncOpKid(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:             JSParseNode *pn, JSParseNode *kid,
    1:             JSTokenType tt, JSBool preorder)
    1: {
    1:     JSOp op;
    1: 
    1:     kid = SetLvalKid(cx, ts, pn, kid, incop_name_str[tt == TOK_DEC]);
    1:     if (!kid)
    1:         return JS_FALSE;
    1:     switch (kid->pn_type) {
    1:       case TOK_NAME:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCNAME : JSOP_NAMEINC)
    1:              : (preorder ? JSOP_DECNAME : JSOP_NAMEDEC);
27012:         NoteLValue(cx, kid, tc);
    1:         break;
    1: 
    1:       case TOK_DOT:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCPROP : JSOP_PROPINC)
    1:              : (preorder ? JSOP_DECPROP : JSOP_PROPDEC);
    1:         break;
    1: 
    1: #if JS_HAS_LVALUE_RETURN
    1:       case TOK_LP:
 7984:         if (!MakeSetCall(cx, kid, tc, JSMSG_BAD_INCOP_OPERAND))
 1577:             return JS_FALSE;
    1:         /* FALL THROUGH */
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_UNARYOP:
    1:         if (kid->pn_op == JSOP_XMLNAME)
    1:             kid->pn_op = JSOP_SETXMLNAME;
    1:         /* FALL THROUGH */
    1: #endif
    1:       case TOK_LB:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCELEM : JSOP_ELEMINC)
    1:              : (preorder ? JSOP_DECELEM : JSOP_ELEMDEC);
    1:         break;
    1: 
    1:       default:
    1:         JS_ASSERT(0);
    1:         op = JSOP_NOP;
    1:     }
    1:     pn->pn_op = op;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSParseNode *
    1: UnaryExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSTokenType tt;
    1:     JSParseNode *pn, *pn2;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     ts->flags |= TSF_OPERAND;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_OPERAND;
    1: 
    1:     switch (tt) {
    1:       case TOK_UNARYOP:
    1:       case TOK_PLUS:
    1:       case TOK_MINUS:
27012:         pn = NewParseNode(PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_UNARYOP;      /* PLUS and MINUS are binary */
    1:         pn->pn_op = CURRENT_TOKEN(ts).t_op;
    1:         pn2 = UnaryExpr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:         break;
    1: 
    1:       case TOK_INC:
    1:       case TOK_DEC:
27012:         pn = NewParseNode(PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn2 = MemberExpr(cx, ts, tc, JS_TRUE);
    1:         if (!pn2)
    1:             return NULL;
    1:         if (!SetIncOpKid(cx, ts, tc, pn, pn2, tt, JS_TRUE))
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         break;
    1: 
    1:       case TOK_DELETE:
27012:         pn = NewParseNode(PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn2 = UnaryExpr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1: 
    1:         /*
    1:          * Under ECMA3, deleting any unary expression is valid -- it simply
 1962:          * returns true. Here we strip off any parentheses and fold constants
 1962:          * before checking for a call expression, in order to rule out delete
 1962:          * of a generator expression.
    1:          */
    1:         while (pn2->pn_type == TOK_RP)
    1:             pn2 = pn2->pn_kid;
 1962:         if (!js_FoldConstants(cx, pn2, tc))
 1962:             return NULL;
27012:         switch (pn2->pn_type) {
27012:           case TOK_LP:
27012:             if (pn2->pn_op != JSOP_SETCALL &&
 7984:                 !MakeSetCall(cx, pn2, tc, JSMSG_BAD_DELETE_OPERAND)) {
 1577:                 return NULL;
 1577:             }
27012:             break;
27012:           case TOK_NAME:
27012:             pn2->pn_op = JSOP_DELNAME;
27012:             break;
27012:           default:;
27012:         }
    1:         pn->pn_kid = pn2;
    1:         break;
    1: 
    1:       case TOK_ERROR:
    1:         return NULL;
    1: 
    1:       default:
    1:         js_UngetToken(ts);
    1:         pn = MemberExpr(cx, ts, tc, JS_TRUE);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* Don't look across a newline boundary for a postfix incop. */
    1:         if (ON_CURRENT_LINE(ts, pn->pn_pos)) {
    1:             ts->flags |= TSF_OPERAND;
    1:             tt = js_PeekTokenSameLine(cx, ts);
    1:             ts->flags &= ~TSF_OPERAND;
    1:             if (tt == TOK_INC || tt == TOK_DEC) {
    1:                 (void) js_GetToken(cx, ts);
27012:                 pn2 = NewParseNode(PN_UNARY, tc);
    1:                 if (!pn2)
    1:                     return NULL;
    1:                 if (!SetIncOpKid(cx, ts, tc, pn2, pn, tt, JS_FALSE))
    1:                     return NULL;
    1:                 pn2->pn_pos.begin = pn->pn_pos.begin;
    1:                 pn = pn2;
    1:             }
    1:         }
    1:         break;
    1:     }
    1:     return pn;
    1: }
    1: 
 1577: #if JS_HAS_GENERATORS
 1577: 
 1577: /*
27012:  * A dedicated helper for transplanting the comprehension expression E in
27012:  *
27012:  *   [E for (V in I)]   // array comprehension
27012:  *   (E for (V in I))   // generator expression
27012:  *
27012:  * from its initial location in the AST, on the left of the 'for', to its final
27012:  * position on the right. To avoid a separate pass we do this by adjusting the
27012:  * blockids and name binding links that were established when E was parsed.
27012:  *
27012:  * A generator expression desugars like so:
27012:  *
27012:  *   (E for (V in I)) => (function () { for (var V in I) yield E; })()
27012:  *
27012:  * so the transplanter must adjust static level as well as blockid. E's source
27012:  * coordinates in root->pn_pos are critical to deciding which binding links to
27012:  * preserve and which to cut.
27012:  *
27012:  * NB: This is not a general tree transplanter -- it knows in particular that
27012:  * the one or more bindings induced by V have not yet been created.
27012:  */
27012: class CompExprTransplanter {
27012:     JSParseNode     *root;
27012:     JSTreeContext   *tc;
27012:     bool            genexp;
27012:     uintN           adjust;
27012:     uintN           funcLevel;
27012: 
27012:   public:
27012:     CompExprTransplanter(JSParseNode *pn, JSTreeContext *tc, bool ge, uintN adj)
27012:       : root(pn), tc(tc), genexp(ge), adjust(adj), funcLevel(0)
27012:     {
27012:     }
27012: 
27012:     bool transplant(JSParseNode *pn);
27012: };
27012: 
27012: /*
27012:  * Any definitions nested within the comprehension expression of a generator
27012:  * expression must move "down" one static level, which of course increases the
27012:  * upvar-frame-skip count.
27012:  */
27012: static void
27012: BumpStaticLevel(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     if (pn->pn_cookie != FREE_UPVAR_COOKIE) {
27012:         uintN level = UPVAR_FRAME_SKIP(pn->pn_cookie) + 1;
27012: 
27012:         JS_ASSERT(level >= tc->staticLevel);
27012:         pn->pn_cookie = MAKE_UPVAR_COOKIE(level, UPVAR_FRAME_SLOT(pn->pn_cookie));
27012:     }
27012: }
27012: 
27012: bool
27012: CompExprTransplanter::transplant(JSParseNode *pn)
27012: {
27012:     if (!pn)
27012:         return true;
27012: 
27012:     switch (pn->pn_arity) {
27012:       case PN_LIST:
27012:         for (JSParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next)
27012:             transplant(pn2);
27012:         if (pn->pn_pos >= root->pn_pos)
27012:             pn->pn_blockid += adjust;
27012:         break;
27012: 
27012:       case PN_TERNARY:
27012:         transplant(pn->pn_kid1);
27012:         transplant(pn->pn_kid2);
27012:         transplant(pn->pn_kid3);
27012:         break;
27012: 
27012:       case PN_BINARY:
27012:         transplant(pn->pn_left);
27012:         transplant(pn->pn_right);
27012:         break;
27012: 
27012:       case PN_UNARY:
27012:         transplant(pn->pn_kid);
27012:         break;
27012: 
27012:       case PN_FUNC:
27012:       {
27012:         /*
27012:          * Only the first level of transplant recursion through functions needs
27012:          * to reparent the funbox, since all descendant functions are correctly
27012:          * linked under the top-most funbox. But every visit to this case needs
27012:          * to update funbox->level.
27012:          *
27012:          * Recall that funbox->level is the static level of the code containing
27012:          * the definition or expression of the function and not the static level
27012:          * of the function's body.
27012:          */
27012:         JSFunctionBox *funbox = pn->pn_funbox;
27012: 
27012:         funbox->level = tc->staticLevel + funcLevel;
27012:         if (++funcLevel == 1 && genexp) {
27012:             JSFunctionBox *parent = tc->funbox;
27012: 
27012:             JSFunctionBox **funboxp = &tc->parent->functionList;
27012:             while (*funboxp != funbox)
27012:                 funboxp = &(*funboxp)->siblings;
27012:             *funboxp = funbox->siblings;
27012: 
27012:             funbox->parent = parent;
27012:             funbox->siblings = parent->kids;
27012:             parent->kids = funbox;
27012:             funbox->level = tc->staticLevel;
27012:         }
27012:         /* FALL THROUGH */
27012:       }
27012: 
27012:       case PN_NAME:
27012:         transplant(pn->maybeExpr());
27012:         if (pn->pn_arity == PN_FUNC)
27012:             --funcLevel;
27012: 
27012:         if (pn->pn_defn) {
27012:             if (genexp)
27012:                 BumpStaticLevel(pn, tc);
27012:         } else if (pn->pn_used) {
27012:             JS_ASSERT(pn->pn_op != JSOP_NOP);
27012:             JS_ASSERT(pn->pn_cookie == FREE_UPVAR_COOKIE);
27012: 
27012:             JSDefinition *dn = pn->pn_lexdef;
27012:             JS_ASSERT(dn->pn_defn);
27012: 
27012:             /*
27012:              * Adjust the definition's block id only if it is a placeholder not
27012:              * to the left of the root node, and if pn is the last use visited
27012:              * in the comprehension expression (to avoid adjusting the blockid
27012:              * multiple times).
27012:              *
27012:              * Non-placeholder definitions within the comprehension expression
27012:              * will be visited further below.
27012:              */
27012:             if (dn->isPlaceholder() && dn->pn_pos >= root->pn_pos && dn->dn_uses == pn) {
27012:                 if (genexp)
27012:                     BumpStaticLevel(dn, tc);
27012:                 dn->pn_blockid += adjust;
27012:             }
27012: 
27012:             JSAtom *atom = pn->pn_atom;
27012: #ifdef DEBUG
27012:             JSStmtInfo *stmt = js_LexicalLookup(tc, atom, NULL);
27012:             JS_ASSERT(!stmt || stmt != tc->topStmt);
27012: #endif
27012:             if (genexp && PN_OP(dn) != JSOP_CALLEE) {
27012:                 JS_ASSERT(!tc->decls.lookup(atom));
27012: 
27012:                 if (dn->pn_pos < root->pn_pos || dn->isPlaceholder()) {
27012:                     JSAtomListElement *ale = tc->upvars.add(tc->compiler, atom);
27012:                     if (!ale)
27012:                         return false;
27012:                     ALE_SET_DEFN(ale, dn);
27012: 
27012:                     if (dn->pn_pos >= root->pn_pos)
27012:                         tc->parent->upvars.remove(tc->compiler, atom);
27012:                 }
27012: 
27012:                 if (dn->isPlaceholder()) {
27012:                     JSAtomListElement *ale = tc->lexdeps.add(tc->compiler, atom);
27012:                     if (!ale)
27012:                         return false;
27012:                     ALE_SET_DEFN(ale, dn);
27012: 
27012:                     if (dn->pn_pos >= root->pn_pos)
27012:                         tc->parent->lexdeps.remove(tc->compiler, atom);
27012:                 }
27012:             }
27012:         }
27012: 
27012:         if (pn->pn_pos >= root->pn_pos)
27012:             pn->pn_blockid += adjust;
27012:         break;
27012: 
27012:       case PN_NAMESET:
27012:         transplant(pn->pn_tree);
27012:         break;
27012:     }
27012:     return true;
27012: }
27012: 
27012: /*
 1577:  * Starting from a |for| keyword after the first array initialiser element or
 1577:  * an expression in an open parenthesis, parse the tail of the comprehension
 1577:  * or generator expression signified by this |for| keyword in context.
 1577:  *
 1577:  * Return null on failure, else return the top-most parse node for the array
 1577:  * comprehension or generator expression, with a unary node as the body of the
 1577:  * (possibly nested) for-loop, initialized by |type, op, kid|.
 1577:  */
 1577: static JSParseNode *
27012: ComprehensionTail(JSParseNode *kid, uintN blockid, JSTreeContext *tc,
27012:                   JSTokenType type = TOK_SEMI, JSOp op = JSOP_NOP)
27012: {
27012:     JSContext *cx = tc->compiler->context;
27012:     JSTokenStream *ts = TS(tc->compiler);
27012: 
27012:     uintN adjust;
 1577:     JSParseNode *pn, *pn2, *pn3, **pnp;
 1577:     JSStmtInfo stmtInfo;
 1577:     BindData data;
 1577:     JSTokenType tt;
 1577:     JSAtom *atom;
 1577: 
 1577:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_FOR);
 1577: 
27012:     if (type == TOK_SEMI) {
27012:         /*
27012:          * Generator expression desugars to an immediately applied lambda that
27012:          * yields the next value from a for-in loop (possibly nested, and with
27012:          * optional if guard). Make pn be the TOK_LC body node.
 1577:          */
 1577:         pn = PushLexicalScope(cx, ts, tc, &stmtInfo);
 1577:         if (!pn)
 1577:             return NULL;
27012:         adjust = pn->pn_blockid - blockid;
27012:     } else {
27012:         JS_ASSERT(type == TOK_ARRAYPUSH);
27012: 
27012:         /*
27012:          * Make a parse-node and literal object representing the block scope of
27012:          * this array comprehension. Our caller in PrimaryExpr, the TOK_LB case
27012:          * aka the array initialiser case, has passed the blockid to claim for
27012:          * the comprehension's block scope. We allocate that id or one above it
27012:          * here, by calling js_PushLexicalScope.
27012:          *
27012:          * In the case of a comprehension expression that has nested blocks
27012:          * (e.g., let expressions), we will allocate a higher blockid but then
27012:          * slide all blocks "to the right" to make room for the comprehension's
27012:          * block scope.
27012:          */
27012:         adjust = tc->blockid();
27012:         pn = PushLexicalScope(cx, ts, tc, &stmtInfo);
27012:         if (!pn)
27012:             return NULL;
27012: 
27012:         JS_ASSERT(blockid <= pn->pn_blockid);
27012:         JS_ASSERT(blockid < tc->blockidGen);
27012:         JS_ASSERT(tc->bodyid < blockid);
27012:         pn->pn_blockid = stmtInfo.blockid = blockid;
27012:         JS_ASSERT(adjust < blockid);
27012:         adjust = blockid - adjust;
27012:     }
27012: 
 1577:     pnp = &pn->pn_expr;
 1577: 
27012:     CompExprTransplanter transplanter(kid, tc, type == TOK_SEMI, adjust);
27012:     transplanter.transplant(kid);
27012: 
 1577:     data.pn = NULL;
 1577:     data.op = JSOP_NOP;
 1577:     data.binder = BindLet;
27012:     data.let.overflow = JSMSG_ARRAY_INIT_TOO_BIG;
27012: 
 1577:     do {
 1577:         /*
 1577:          * FOR node is binary, left is loop control and right is body.  Use
 1577:          * index to count each block-local let-variable on the left-hand side
 1577:          * of the IN.
 1577:          */
27012:         pn2 = NewParseNode(PN_BINARY, tc);
 1577:         if (!pn2)
 1577:             return NULL;
 1577: 
15613:         pn2->pn_op = JSOP_ITER;
15613:         pn2->pn_iflags = JSITER_ENUMERATE;
 1577:         if (js_MatchToken(cx, ts, TOK_NAME)) {
27012:             if (CURRENT_TOKEN(ts).t_atom == cx->runtime->atomState.eachAtom)
15613:                 pn2->pn_iflags |= JSITER_FOREACH;
 1577:             else
 1577:                 js_UngetToken(ts);
 1577:         }
 1577:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
 1577: 
27012:         atom = NULL;
 1577:         tt = js_GetToken(cx, ts);
 1577:         switch (tt) {
 1577: #if JS_HAS_DESTRUCTURING
 1577:           case TOK_LB:
 1577:           case TOK_LC:
27012:             ts->flags |= TSF_DESTRUCTURING;
27012:             pn3 = PrimaryExpr(cx, ts, tc, tt, JS_FALSE);
27012:             ts->flags &= ~TSF_DESTRUCTURING;
 1577:             if (!pn3)
 1577:                 return NULL;
 1577:             break;
 1577: #endif
 1577: 
 1577:           case TOK_NAME:
 1577:             atom = CURRENT_TOKEN(ts).t_atom;
 1577: 
 1577:             /*
 1577:              * Create a name node with pn_op JSOP_NAME.  We can't set pn_op to
 1577:              * JSOP_GETLOCAL here, because we don't yet know the block's depth
 1577:              * in the operand stack frame.  The code generator computes that,
 1577:              * and it tries to bind all names to slots, so we must let it do
 1577:              * the deed.
 1577:              */
27012:             pn3 = NewBindingNode(ts, atom, tc, true);
 1577:             if (!pn3)
 1577:                 return NULL;
 1577:             break;
 1577: 
 1577:           default:
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
 1577:                                         JSMSG_NO_VARIABLE_NAME);
 1607: 
 1607:           case TOK_ERROR:
 1577:             return NULL;
 1577:         }
 1577: 
 1577:         MUST_MATCH_TOKEN(TOK_IN, JSMSG_IN_AFTER_FOR_NAME);
27012:         JSParseNode *pn4 = Expr(cx, ts, tc);
27012:         if (!pn4)
27012:             return NULL;
 1577:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
27012: 
27012:         switch (tt) {
27012: #if JS_HAS_DESTRUCTURING
27012:           case TOK_LB:
27012:           case TOK_LC:
27012:             if (!CheckDestructuring(cx, &data, pn3, NULL, tc))
27012:                 return NULL;
27012: 
27012:             if (JSVERSION_NUMBER(cx) == JSVERSION_1_7) {
27012:                 /* Destructuring requires [key, value] enumeration in JS1.7. */
27012:                 if (pn3->pn_type != TOK_RB || pn3->pn_count != 2) {
27012:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
27012:                                                 JSMSG_BAD_FOR_LEFTSIDE);
27012:                     return NULL;
27012:                 }
27012: 
27012:                 JS_ASSERT(pn2->pn_op == JSOP_ITER);
27012:                 JS_ASSERT(pn2->pn_iflags & JSITER_ENUMERATE);
27012:                 if (!(pn2->pn_iflags & JSITER_FOREACH))
27012:                     pn2->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
27012:             }
27012:             break;
27012: #endif
27012: 
27012:           case TOK_NAME:
27012:             data.pn = pn3;
27012:             if (!data.binder(cx, &data, atom, tc))
27012:                 return NULL;
27012:             break;
27012: 
27012:           default:;
27012:         }
27012: 
27012:         pn2->pn_left = NewBinary(TOK_IN, JSOP_NOP, pn3, pn4, tc);
27012:         if (!pn2->pn_left)
27012:             return NULL;
 1577:         *pnp = pn2;
 1577:         pnp = &pn2->pn_right;
 1577:     } while (js_MatchToken(cx, ts, TOK_FOR));
 1577: 
 1577:     if (js_MatchToken(cx, ts, TOK_IF)) {
27012:         pn2 = NewParseNode(PN_TERNARY, tc);
 1577:         if (!pn2)
 1577:             return NULL;
 1577:         pn2->pn_kid1 = Condition(cx, ts, tc);
 1577:         if (!pn2->pn_kid1)
 1577:             return NULL;
 1577:         *pnp = pn2;
 1577:         pnp = &pn2->pn_kid2;
 1577:     }
 1577: 
27012:     pn2 = NewParseNode(PN_UNARY, tc);
 1577:     if (!pn2)
 1577:         return NULL;
 1577:     pn2->pn_type = type;
 1577:     pn2->pn_op = op;
 1577:     pn2->pn_kid = kid;
 1577:     *pnp = pn2;
 1577: 
27012:     if (type == TOK_ARRAYPUSH)
27012:         PopStatement(tc);
 1577:     return pn;
 1577: }
 1577: 
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577: 
 1577: /*
 1577:  * Starting from a |for| keyword after an expression, parse the comprehension
 1577:  * tail completing this generator expression. Wrap the expression at kid in a
 1577:  * generator function that is immediately called to evaluate to the generator
 1577:  * iterator that is the value of this generator expression.
 1577:  *
 1577:  * Callers pass a blank unary node via pn, which GeneratorExpr fills in as the
 1577:  * yield expression, which ComprehensionTail in turn wraps in a TOK_SEMI-type
 1577:  * expression-statement node that constitutes the body of the |for| loop(s) in
 1577:  * the generator function.
 1577:  *
 1577:  * Note how unlike Python, we do not evaluate the expression to the right of
 1577:  * the first |in| in the chain of |for| heads. Instead, a generator expression
 1577:  * is merely sugar for a generator function expression and its application.
 1577:  */
 1577: static JSParseNode *
27012: GeneratorExpr(JSParseNode *pn, JSParseNode *kid, JSTreeContext *tc)
27012: {
 1577:     /* Initialize pn, connecting it to kid. */
 1577:     JS_ASSERT(pn->pn_arity == PN_UNARY);
 1577:     pn->pn_type = TOK_YIELD;
 1577:     pn->pn_op = JSOP_YIELD;
 1577:     pn->pn_pos = kid->pn_pos;
 1577:     pn->pn_kid = kid;
 1577:     pn->pn_hidden = JS_TRUE;
 1577: 
27012:     /* Make a new node for the desugared generator function. */
27012:     JSParseNode *genfn = NewParseNode(PN_FUNC, tc);
27012:     if (!genfn)
27012:         return NULL;
27012:     genfn->pn_type = TOK_FUNCTION;
27012:     genfn->pn_op = JSOP_LAMBDA;
27012:     JS_ASSERT(!genfn->pn_body);
27012:     genfn->pn_dflags = PND_FUNARG;
27012: 
27012:     {
27012:         JSTreeContext gentc(tc->compiler);
27012: 
27012:         JSFunctionBox *funbox = EnterFunction(genfn, tc, &gentc);
27012:         if (!funbox)
27012:             return NULL;
27012: 
27012:         gentc.flags |= TCF_FUN_IS_GENERATOR | TCF_GENEXP_LAMBDA;
27012:         if (tc->flags & TCF_HAS_SHARPS)
27012:             gentc.flags |= TCF_HAS_SHARPS;
27012:         funbox->tcflags |= gentc.flags;
27012:         genfn->pn_funbox = funbox;
27012:         genfn->pn_blockid = gentc.bodyid;
27012: 
27012:         JSParseNode *body = ComprehensionTail(pn, tc->blockid(), &gentc);
 1577:         if (!body)
 1577:             return NULL;
27012:         JS_ASSERT(!genfn->pn_body);
27012:         genfn->pn_body = body;
27012:         genfn->pn_pos.begin = body->pn_pos.begin = kid->pn_pos.begin;
27012:         genfn->pn_pos.end = body->pn_pos.end = CURRENT_TOKEN(TS(tc->compiler)).pos.end;
27012: 
27012:         if (!LeaveFunction(genfn, &gentc, tc))
27012:             return NULL;
27012:     }
27012: 
27012:     /*
27012:      * Our result is a call expression that invokes the anonymous generator
27012:      * function object.
27012:      */
27012:     JSParseNode *result = NewParseNode(PN_LIST, tc);
27012:     if (!result)
27012:         return NULL;
27012:     result->pn_type = TOK_LP;
27012:     result->pn_op = JSOP_CALL;
27012:     result->pn_pos.begin = genfn->pn_pos.begin;
27012:     result->initList(genfn);
27012:     return result;
 1577: }
 1577: 
 1577: static const char js_generator_str[] = "generator";
 1577: 
 1577: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577: #endif /* JS_HAS_GENERATORS */
 1577: 
    1: static JSBool
    1: ArgumentList(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:              JSParseNode *listNode)
    1: {
    1:     JSBool matched;
    1: 
    1:     ts->flags |= TSF_OPERAND;
    1:     matched = js_MatchToken(cx, ts, TOK_RP);
    1:     ts->flags &= ~TSF_OPERAND;
    1:     if (!matched) {
    1:         do {
    1:             JSParseNode *argNode = AssignExpr(cx, ts, tc);
    1:             if (!argNode)
    1:                 return JS_FALSE;
    1: #if JS_HAS_GENERATORS
11844:             if (argNode->pn_type == TOK_YIELD &&
11844:                 js_PeekToken(cx, ts) == TOK_COMMA) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, argNode, JSREPORT_ERROR,
 1577:                                             JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                             js_yield_str);
    1:                 return JS_FALSE;
    1:             }
    1: #endif
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577:             if (js_MatchToken(cx, ts, TOK_FOR)) {
27012:                 JSParseNode *pn = NewParseNode(PN_UNARY, tc);
 1577:                 if (!pn)
 1577:                     return JS_FALSE;
27012:                 argNode = GeneratorExpr(pn, argNode, tc);
 1577:                 if (!argNode)
 1577:                     return JS_FALSE;
 1577:                 if (listNode->pn_count > 1 ||
 1577:                     js_PeekToken(cx, ts) == TOK_COMMA) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, argNode, JSREPORT_ERROR,
 1577:                                                 JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                                 js_generator_str);
 1577:                     return JS_FALSE;
 1577:                 }
 1577:             }
 1577: #endif
27012:             listNode->append(argNode);
    1:         } while (js_MatchToken(cx, ts, TOK_COMMA));
    1: 
    1:         if (js_GetToken(cx, ts) != TOK_RP) {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_PAREN_AFTER_ARGS);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
27012: /* Check for an immediately-applied (new'ed) lambda and clear PND_FUNARG. */
27012: static JSParseNode *
27012: CheckForImmediatelyAppliedLambda(JSParseNode *pn)
27012: {
27012:     while (pn->pn_type == TOK_RP)
27012:         pn = pn->pn_kid;
27012:     if (pn->pn_type == TOK_FUNCTION) {
27012:         JS_ASSERT(pn->pn_arity == PN_FUNC);
27051: 
27051:         JSFunctionBox *funbox = pn->pn_funbox;
27051:         JS_ASSERT(((JSFunction *) funbox->object)->flags & JSFUN_LAMBDA);
27051:         if (!(funbox->tcflags & TCF_FUN_USES_ARGUMENTS))
27012:             pn->pn_dflags &= ~PND_FUNARG;
27012:     }
27012:     return pn;
27012: }
27012: 
    1: static JSParseNode *
    1: MemberExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:            JSBool allowCallSyntax)
    1: {
    1:     JSParseNode *pn, *pn2, *pn3;
    1:     JSTokenType tt;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     /* Check for new expression first. */
    1:     ts->flags |= TSF_OPERAND;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_OPERAND;
    1:     if (tt == TOK_NEW) {
27012:         pn = NewParseNode(PN_LIST, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn2 = MemberExpr(cx, ts, tc, JS_FALSE);
    1:         if (!pn2)
    1:             return NULL;
27012:         pn2 = CheckForImmediatelyAppliedLambda(pn2);
    1:         pn->pn_op = JSOP_NEW;
27012:         pn->initList(pn2);
    1:         pn->pn_pos.begin = pn2->pn_pos.begin;
    1: 
    1:         if (js_MatchToken(cx, ts, TOK_LP) && !ArgumentList(cx, ts, tc, pn))
    1:             return NULL;
    1:         if (pn->pn_count > ARGC_LIMIT) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_TOO_MANY_CON_ARGS);
    1:             return NULL;
    1:         }
27012:         pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     } else {
    1:         pn = PrimaryExpr(cx, ts, tc, tt, JS_FALSE);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         if (pn->pn_type == TOK_ANYNAME ||
    1:             pn->pn_type == TOK_AT ||
    1:             pn->pn_type == TOK_DBLCOLON) {
27012:             pn2 = NewOrRecycledNode(tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_type = TOK_UNARYOP;
    1:             pn2->pn_pos = pn->pn_pos;
    1:             pn2->pn_op = JSOP_XMLNAME;
    1:             pn2->pn_arity = PN_UNARY;
    1:             pn2->pn_kid = pn;
    1:             pn = pn2;
    1:         }
    1:     }
    1: 
    1:     while ((tt = js_GetToken(cx, ts)) > TOK_EOF) {
    1:         if (tt == TOK_DOT) {
27012:             pn2 = NewNameNode(cx, ts, NULL, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1: #if JS_HAS_XML_SUPPORT
    1:             ts->flags |= TSF_OPERAND | TSF_KEYWORD_IS_NAME;
    1:             tt = js_GetToken(cx, ts);
    1:             ts->flags &= ~(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
    1:             pn3 = PrimaryExpr(cx, ts, tc, tt, JS_TRUE);
    1:             if (!pn3)
    1:                 return NULL;
 3164:             tt = PN_TYPE(pn3);
    1:             if (tt == TOK_NAME) {
    1:                 pn2->pn_op = JSOP_GETPROP;
    1:                 pn2->pn_expr = pn;
    1:                 pn2->pn_atom = pn3->pn_atom;
    1:                 RecycleTree(pn3, tc);
    1:             } else {
    1:                 if (TOKEN_TYPE_IS_XML(tt)) {
    1:                     pn2->pn_type = TOK_LB;
    1:                     pn2->pn_op = JSOP_GETELEM;
    1:                 } else if (tt == TOK_RP) {
    1:                     JSParseNode *group = pn3;
    1: 
20928:                     /* Recycle the useless TOK_RP node. */
    1:                     pn3 = group->pn_kid;
    1:                     group->pn_kid = NULL;
    1:                     RecycleTree(group, tc);
    1:                     pn2->pn_type = TOK_FILTER;
    1:                     pn2->pn_op = JSOP_FILTER;
    1: 
    1:                     /* A filtering predicate is like a with statement. */
    1:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:                 } else {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_NAME_AFTER_DOT);
    1:                     return NULL;
    1:                 }
    1:                 pn2->pn_arity = PN_BINARY;
    1:                 pn2->pn_left = pn;
    1:                 pn2->pn_right = pn3;
    1:             }
    1: #else
    1:             ts->flags |= TSF_KEYWORD_IS_NAME;
    1:             MUST_MATCH_TOKEN(TOK_NAME, JSMSG_NAME_AFTER_DOT);
    1:             ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:             pn2->pn_op = JSOP_GETPROP;
    1:             pn2->pn_expr = pn;
    1:             pn2->pn_atom = CURRENT_TOKEN(ts).t_atom;
    1: #endif
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
    1:             pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1: #if JS_HAS_XML_SUPPORT
    1:         } else if (tt == TOK_DBLDOT) {
27012:             pn2 = NewParseNode(PN_BINARY, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             ts->flags |= TSF_OPERAND | TSF_KEYWORD_IS_NAME;
    1:             tt = js_GetToken(cx, ts);
    1:             ts->flags &= ~(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
    1:             pn3 = PrimaryExpr(cx, ts, tc, tt, JS_TRUE);
    1:             if (!pn3)
    1:                 return NULL;
 3164:             tt = PN_TYPE(pn3);
    1:             if (tt == TOK_NAME) {
    1:                 pn3->pn_type = TOK_STRING;
    1:                 pn3->pn_arity = PN_NULLARY;
    1:                 pn3->pn_op = JSOP_QNAMEPART;
    1:             } else if (!TOKEN_TYPE_IS_XML(tt)) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_NAME_AFTER_DOT);
    1:                 return NULL;
    1:             }
    1:             pn2->pn_op = JSOP_DESCENDANTS;
    1:             pn2->pn_left = pn;
    1:             pn2->pn_right = pn3;
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
    1:             pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1: #endif
    1:         } else if (tt == TOK_LB) {
27012:             pn2 = NewParseNode(PN_BINARY, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn3 = Expr(cx, ts, tc);
    1:             if (!pn3)
    1:                 return NULL;
    1: 
    1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_IN_INDEX);
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
    1:             pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1: 
18392:             /*
18392:              * Optimize o['p'] to o.p by rewriting pn2, but avoid rewriting
18392:              * o['0'] to use JSOP_GETPROP, to keep fast indexing disjoint in
18392:              * the interpreter from fast property access. However, if the
18392:              * bracketed string is a uint32, we rewrite pn3 to be a number
18392:              * instead of a string.
18392:              */
18392:             do {
    1:                 if (pn3->pn_type == TOK_STRING) {
18392:                     jsuint index;
18392: 
18392:                     if (!js_IdIsIndex(ATOM_TO_JSID(pn3->pn_atom), &index)) {
    1:                         pn2->pn_type = TOK_DOT;
    1:                         pn2->pn_op = JSOP_GETPROP;
    1:                         pn2->pn_arity = PN_NAME;
    1:                         pn2->pn_expr = pn;
    1:                         pn2->pn_atom = pn3->pn_atom;
18392:                         break;
18392:                     }
18392:                     pn3->pn_type = TOK_NUMBER;
20902:                     pn3->pn_op = JSOP_DOUBLE;
18392:                     pn3->pn_dval = index;
18392:                 }
    1:                 pn2->pn_op = JSOP_GETELEM;
    1:                 pn2->pn_left = pn;
    1:                 pn2->pn_right = pn3;
18392:             } while (0);
    1:         } else if (allowCallSyntax && tt == TOK_LP) {
27012:             pn2 = NewParseNode(PN_LIST, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_op = JSOP_CALL;
27012: 
27012:             /* CheckForImmediatelyAppliedLambda skips useless TOK_RP nodes. */
27012:             pn = CheckForImmediatelyAppliedLambda(pn);
27012:             if (pn->pn_op == JSOP_NAME) {
27012:                 if (pn->pn_atom == cx->runtime->atomState.evalAtom) {
27012:                     /* Select JSOP_EVAL and flag tc as heavyweight. */
    1:                     pn2->pn_op = JSOP_EVAL;
    1:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
27012:                 }
27012:             } else if (pn->pn_op == JSOP_GETPROP) {
27012:                 if (pn->pn_atom == cx->runtime->atomState.applyAtom ||
27012:                     pn->pn_atom == cx->runtime->atomState.callAtom) {
27012:                     /* Select JSOP_APPLY given foo.apply(...). */
21452:                     pn2->pn_op = JSOP_APPLY;
    1:                 }
27012:             }
27012: 
27012:             pn2->initList(pn);
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
    1: 
    1:             if (!ArgumentList(cx, ts, tc, pn2))
    1:                 return NULL;
    1:             if (pn2->pn_count > ARGC_LIMIT) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_TOO_MANY_FUN_ARGS);
    1:                 return NULL;
    1:             }
    1:             pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         } else {
    1:             js_UngetToken(ts);
    1:             return pn;
    1:         }
    1: 
    1:         pn = pn2;
    1:     }
    1:     if (tt == TOK_ERROR)
    1:         return NULL;
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: BracketedExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     uintN oldflags;
    1:     JSParseNode *pn;
    1: 
    1:     /*
    1:      * Always accept the 'in' operator in a parenthesized expression,
    1:      * where it's unambiguous, even if we might be parsing the init of a
    1:      * for statement.
    1:      */
    1:     oldflags = tc->flags;
    1:     tc->flags &= ~TCF_IN_FOR_INIT;
    1:     pn = Expr(cx, ts, tc);
    1:     tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: 
    1: static JSParseNode *
    1: EndBracketedExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = BracketedExpr(cx, ts, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_ATTR_EXPR);
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * From the ECMA-357 grammar in 11.1.1 and 11.1.2:
    1:  *
    1:  *      AttributeIdentifier:
    1:  *              @ PropertySelector
    1:  *              @ QualifiedIdentifier
    1:  *              @ [ Expression ]
    1:  *
    1:  *      PropertySelector:
    1:  *              Identifier
    1:  *              *
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector :: PropertySelector
    1:  *              PropertySelector :: [ Expression ]
    1:  *
    1:  * We adapt AttributeIdentifier and QualifiedIdentier to be LL(1), like so:
    1:  *
    1:  *      AttributeIdentifier:
    1:  *              @ QualifiedIdentifier
    1:  *              @ [ Expression ]
    1:  *
    1:  *      PropertySelector:
    1:  *              Identifier
    1:  *              *
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector :: PropertySelector
    1:  *              PropertySelector :: [ Expression ]
    1:  *              PropertySelector
    1:  *
    1:  * As PrimaryExpression: Identifier is in ECMA-262 and we want the semantics
    1:  * for that rule to result in a name node, but ECMA-357 extends the grammar
    1:  * to include PrimaryExpression: QualifiedIdentifier, we must factor further:
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector QualifiedSuffix
    1:  *
    1:  *      QualifiedSuffix:
    1:  *              :: PropertySelector
    1:  *              :: [ Expression ]
    1:  *              /nothing/
    1:  *
    1:  * And use this production instead of PrimaryExpression: QualifiedIdentifier:
    1:  *
    1:  *      PrimaryExpression:
    1:  *              Identifier QualifiedSuffix
    1:  *
    1:  * We hoist the :: match into callers of QualifiedSuffix, in order to tweak
    1:  * PropertySelector vs. Identifier pn_arity, pn_op, and other members.
    1:  */
    1: static JSParseNode *
    1: PropertySelector(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
27012:     pn = NewParseNode(PN_NULLARY, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     if (pn->pn_type == TOK_STAR) {
    1:         pn->pn_type = TOK_ANYNAME;
    1:         pn->pn_op = JSOP_ANYNAME;
    1:         pn->pn_atom = cx->runtime->atomState.starAtom;
    1:     } else {
    1:         JS_ASSERT(pn->pn_type == TOK_NAME);
    1:         pn->pn_op = JSOP_QNAMEPART;
    1:         pn->pn_arity = PN_NAME;
    1:         pn->pn_atom = CURRENT_TOKEN(ts).t_atom;
27012:         pn->pn_cookie = FREE_UPVAR_COOKIE;
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: QualifiedSuffix(JSContext *cx, JSTokenStream *ts, JSParseNode *pn,
    1:                 JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn2, *pn3;
    1:     JSTokenType tt;
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_DBLCOLON);
27012:     pn2 = NewNameNode(cx, ts, NULL, tc);
    1:     if (!pn2)
    1:         return NULL;
    1: 
    1:     /* Left operand of :: must be evaluated if it is an identifier. */
    1:     if (pn->pn_op == JSOP_QNAMEPART)
    1:         pn->pn_op = JSOP_NAME;
    1: 
    1:     ts->flags |= TSF_KEYWORD_IS_NAME;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:     if (tt == TOK_STAR || tt == TOK_NAME) {
    1:         /* Inline and specialize PropertySelector for JSOP_QNAMECONST. */
    1:         pn2->pn_op = JSOP_QNAMECONST;
27012:         pn2->pn_pos.begin = pn->pn_pos.begin;
    1:         pn2->pn_atom = (tt == TOK_STAR)
    1:                        ? cx->runtime->atomState.starAtom
    1:                        : CURRENT_TOKEN(ts).t_atom;
    1:         pn2->pn_expr = pn;
27012:         pn2->pn_cookie = FREE_UPVAR_COOKIE;
    1:         return pn2;
    1:     }
    1: 
    1:     if (tt != TOK_LB) {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     pn3 = EndBracketedExpr(cx, ts, tc);
    1:     if (!pn3)
    1:         return NULL;
    1: 
    1:     pn2->pn_op = JSOP_QNAME;
    1:     pn2->pn_arity = PN_BINARY;
27012:     pn2->pn_pos.begin = pn->pn_pos.begin;
27012:     pn2->pn_pos.end = pn3->pn_pos.end;
    1:     pn2->pn_left = pn;
    1:     pn2->pn_right = pn3;
    1:     return pn2;
    1: }
    1: 
    1: static JSParseNode *
    1: QualifiedIdentifier(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     pn = PropertySelector(cx, ts, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     if (js_MatchToken(cx, ts, TOK_DBLCOLON))
    1:         pn = QualifiedSuffix(cx, ts, pn, tc);
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: AttributeIdentifier(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2;
    1:     JSTokenType tt;
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_AT);
27012:     pn = NewParseNode(PN_UNARY, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_op = JSOP_TOATTRNAME;
    1:     ts->flags |= TSF_KEYWORD_IS_NAME;
    1:     tt = js_GetToken(cx, ts);
    1:     ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:     if (tt == TOK_STAR || tt == TOK_NAME) {
    1:         pn2 = QualifiedIdentifier(cx, ts, tc);
    1:     } else if (tt == TOK_LB) {
    1:         pn2 = EndBracketedExpr(cx, ts, tc);
    1:     } else {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     if (!pn2)
    1:         return NULL;
    1:     pn->pn_kid = pn2;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Make a TOK_LC unary node whose pn_kid is an expression.
    1:  */
    1: static JSParseNode *
    1: XMLExpr(JSContext *cx, JSTokenStream *ts, JSBool inTag, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2;
    1:     uintN oldflags;
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_LC);
27012:     pn = NewParseNode(PN_UNARY, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     /*
    1:      * Turn off XML tag mode, but don't restore it after parsing this braced
    1:      * expression.  Instead, simply restore ts's old flags.  This is required
    1:      * because XMLExpr is called both from within a tag, and from within text
    1:      * contained in an element, but outside of any start, end, or point tag.
    1:      */
    1:     oldflags = ts->flags;
    1:     ts->flags = oldflags & ~TSF_XMLTAGMODE;
    1:     pn2 = Expr(cx, ts, tc);
    1:     if (!pn2)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_XML_EXPR);
    1:     ts->flags = oldflags;
    1:     pn->pn_kid = pn2;
    1:     pn->pn_op = inTag ? JSOP_XMLTAGEXPR : JSOP_XMLELTEXPR;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Make a terminal node for one of TOK_XMLNAME, TOK_XMLATTR, TOK_XMLSPACE,
    1:  * TOK_XMLTEXT, TOK_XMLCDATA, TOK_XMLCOMMENT, or TOK_XMLPI.  When converting
    1:  * parse tree to XML, we preserve a TOK_XMLSPACE node only if it's the sole
    1:  * child of a container tag.
    1:  */
    1: static JSParseNode *
    1: XMLAtomNode(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn;
    1:     JSToken *tp;
    1: 
27012:     pn = NewParseNode(PN_NULLARY, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     tp = &CURRENT_TOKEN(ts);
    1:     pn->pn_op = tp->t_op;
    1:     pn->pn_atom = tp->t_atom;
    1:     if (tp->type == TOK_XMLPI)
    1:         pn->pn_atom2 = tp->t_atom2;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Parse the productions:
    1:  *
    1:  *      XMLNameExpr:
    1:  *              XMLName XMLNameExpr?
    1:  *              { Expr } XMLNameExpr?
    1:  *
    1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according as XMLNameExpr produces
    1:  * a list of names and/or expressions, a single expression, or a single name.
    1:  * If PN_LIST or PN_NULLARY, pn_type will be TOK_XMLNAME; if PN_UNARY, pn_type
    1:  * will be TOK_LC.
    1:  */
    1: static JSParseNode *
    1: XMLNameExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn2, *list;
    1:     JSTokenType tt;
    1: 
    1:     pn = list = NULL;
    1:     do {
    1:         tt = CURRENT_TOKEN(ts).type;
    1:         if (tt == TOK_LC) {
    1:             pn2 = XMLExpr(cx, ts, JS_TRUE, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:         } else {
    1:             JS_ASSERT(tt == TOK_XMLNAME);
    1:             pn2 = XMLAtomNode(cx, ts, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:         }
    1: 
    1:         if (!pn) {
    1:             pn = pn2;
    1:         } else {
    1:             if (!list) {
27012:                 list = NewParseNode(PN_LIST, tc);
    1:                 if (!list)
    1:                     return NULL;
    1:                 list->pn_type = TOK_XMLNAME;
    1:                 list->pn_pos.begin = pn->pn_pos.begin;
27012:                 list->initList(pn);
27012:                 list->pn_xflags = PNX_CANTFOLD;
    1:                 pn = list;
    1:             }
    1:             pn->pn_pos.end = pn2->pn_pos.end;
27012:             pn->append(pn2);
    1:         }
    1:     } while ((tt = js_GetToken(cx, ts)) == TOK_XMLNAME || tt == TOK_LC);
    1: 
    1:     js_UngetToken(ts);
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Macro to test whether an XMLNameExpr or XMLTagContent node can be folded
    1:  * at compile time into a JSXML tree.
    1:  */
    1: #define XML_FOLDABLE(pn)        ((pn)->pn_arity == PN_LIST                    \
27012:                                  ? ((pn)->pn_xflags & PNX_CANTFOLD) == 0      \
    1:                                  : (pn)->pn_type != TOK_LC)
    1: 
    1: /*
    1:  * Parse the productions:
    1:  *
    1:  *      XMLTagContent:
    1:  *              XMLNameExpr
    1:  *              XMLTagContent S XMLNameExpr S? = S? XMLAttr
    1:  *              XMLTagContent S XMLNameExpr S? = S? { Expr }
    1:  *
    1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according to how XMLTagContent
    1:  * produces a list of name and attribute values and/or braced expressions, a
    1:  * single expression, or a single name.
    1:  *
    1:  * If PN_LIST or PN_NULLARY, pn_type will be TOK_XMLNAME for the case where
    1:  * XMLTagContent: XMLNameExpr.  If pn_type is not TOK_XMLNAME but pn_arity is
    1:  * PN_LIST, pn_type will be tagtype.  If PN_UNARY, pn_type will be TOK_LC and
    1:  * we parsed exactly one expression.
    1:  */
    1: static JSParseNode *
    1: XMLTagContent(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:               JSTokenType tagtype, JSAtom **namep)
    1: {
    1:     JSParseNode *pn, *pn2, *list;
    1:     JSTokenType tt;
    1: 
    1:     pn = XMLNameExpr(cx, ts, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     *namep = (pn->pn_arity == PN_NULLARY) ? pn->pn_atom : NULL;
    1:     list = NULL;
    1: 
    1:     while (js_MatchToken(cx, ts, TOK_XMLSPACE)) {
    1:         tt = js_GetToken(cx, ts);
    1:         if (tt != TOK_XMLNAME && tt != TOK_LC) {
    1:             js_UngetToken(ts);
    1:             break;
    1:         }
    1: 
    1:         pn2 = XMLNameExpr(cx, ts, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         if (!list) {
27012:             list = NewParseNode(PN_LIST, tc);
    1:             if (!list)
    1:                 return NULL;
    1:             list->pn_type = tagtype;
    1:             list->pn_pos.begin = pn->pn_pos.begin;
27012:             list->initList(pn);
    1:             pn = list;
    1:         }
27012:         pn->append(pn2);
    1:         if (!XML_FOLDABLE(pn2))
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1: 
    1:         js_MatchToken(cx, ts, TOK_XMLSPACE);
    1:         MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_NO_ASSIGN_IN_XML_ATTR);
    1:         js_MatchToken(cx, ts, TOK_XMLSPACE);
    1: 
    1:         tt = js_GetToken(cx, ts);
    1:         if (tt == TOK_XMLATTR) {
    1:             pn2 = XMLAtomNode(cx, ts, tc);
    1:         } else if (tt == TOK_LC) {
    1:             pn2 = XMLExpr(cx, ts, JS_TRUE, tc);
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1:         } else {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_BAD_XML_ATTR_VALUE);
    1:             return NULL;
    1:         }
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
27012:         pn->append(pn2);
    1:     }
    1: 
    1:     return pn;
    1: }
    1: 
    1: #define XML_CHECK_FOR_ERROR_AND_EOF(tt,result)                                \
    1:     JS_BEGIN_MACRO                                                            \
    1:         if ((tt) <= TOK_EOF) {                                                \
    1:             if ((tt) == TOK_EOF) {                                            \
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,     \
    1:                                             JSMSG_END_OF_XML_SOURCE);         \
    1:             }                                                                 \
    1:             return result;                                                    \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
    1: static JSParseNode *
    1: XMLElementOrList(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:                  JSBool allowList);
    1: 
    1: /*
    1:  * Consume XML element tag content, including the TOK_XMLETAGO (</) sequence
    1:  * that opens the end tag for the container.
    1:  */
    1: static JSBool
    1: XMLElementContent(JSContext *cx, JSTokenStream *ts, JSParseNode *pn,
    1:                   JSTreeContext *tc)
    1: {
    1:     JSTokenType tt;
    1:     JSParseNode *pn2;
    1:     JSAtom *textAtom;
    1: 
    1:     ts->flags &= ~TSF_XMLTAGMODE;
    1:     for (;;) {
    1:         ts->flags |= TSF_XMLTEXTMODE;
    1:         tt = js_GetToken(cx, ts);
    1:         ts->flags &= ~TSF_XMLTEXTMODE;
    1:         XML_CHECK_FOR_ERROR_AND_EOF(tt, JS_FALSE);
    1: 
    1:         JS_ASSERT(tt == TOK_XMLSPACE || tt == TOK_XMLTEXT);
    1:         textAtom = CURRENT_TOKEN(ts).t_atom;
    1:         if (textAtom) {
    1:             /* Non-zero-length XML text scanned. */
    1:             pn2 = XMLAtomNode(cx, ts, tc);
    1:             if (!pn2)
    1:                 return JS_FALSE;
    1:             pn->pn_pos.end = pn2->pn_pos.end;
27012:             pn->append(pn2);
    1:         }
    1: 
    1:         ts->flags |= TSF_OPERAND;
    1:         tt = js_GetToken(cx, ts);
    1:         ts->flags &= ~TSF_OPERAND;
    1:         XML_CHECK_FOR_ERROR_AND_EOF(tt, JS_FALSE);
    1:         if (tt == TOK_XMLETAGO)
    1:             break;
    1: 
    1:         if (tt == TOK_LC) {
    1:             pn2 = XMLExpr(cx, ts, JS_FALSE, tc);
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1:         } else if (tt == TOK_XMLSTAGO) {
    1:             pn2 = XMLElementOrList(cx, ts, tc, JS_FALSE);
    1:             if (pn2) {
27012:                 pn2->pn_xflags &= ~PNX_XMLROOT;
27012:                 pn->pn_xflags |= pn2->pn_xflags;
    1:             }
    1:         } else {
    1:             JS_ASSERT(tt == TOK_XMLCDATA || tt == TOK_XMLCOMMENT ||
    1:                       tt == TOK_XMLPI);
    1:             pn2 = XMLAtomNode(cx, ts, tc);
    1:         }
    1:         if (!pn2)
    1:             return JS_FALSE;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
27012:         pn->append(pn2);
    1:     }
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_XMLETAGO);
    1:     ts->flags |= TSF_XMLTAGMODE;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Return a PN_LIST node containing an XML or XMLList Initialiser.
    1:  */
    1: static JSParseNode *
    1: XMLElementOrList(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:                  JSBool allowList)
    1: {
    1:     JSParseNode *pn, *pn2, *list;
    1:     JSTokenType tt;
    1:     JSAtom *startAtom, *endAtom;
    1: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_XMLSTAGO);
27012:     pn = NewParseNode(PN_LIST, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     ts->flags |= TSF_XMLTAGMODE;
    1:     tt = js_GetToken(cx, ts);
    1:     if (tt == TOK_ERROR)
    1:         return NULL;
    1: 
    1:     if (tt == TOK_XMLNAME || tt == TOK_LC) {
    1:         /*
    1:          * XMLElement.  Append the tag and its contents, if any, to pn.
    1:          */
    1:         pn2 = XMLTagContent(cx, ts, tc, TOK_XMLSTAGO, &startAtom);
    1:         if (!pn2)
    1:             return NULL;
    1:         js_MatchToken(cx, ts, TOK_XMLSPACE);
    1: 
    1:         tt = js_GetToken(cx, ts);
    1:         if (tt == TOK_XMLPTAGC) {
    1:             /* Point tag (/>): recycle pn if pn2 is a list of tag contents. */
    1:             if (pn2->pn_type == TOK_XMLSTAGO) {
27012:                 pn->makeEmpty();
    1:                 RecycleTree(pn, tc);
    1:                 pn = pn2;
    1:             } else {
    1:                 JS_ASSERT(pn2->pn_type == TOK_XMLNAME ||
    1:                           pn2->pn_type == TOK_LC);
27012:                 pn->initList(pn2);
    1:                 if (!XML_FOLDABLE(pn2))
27012:                     pn->pn_xflags |= PNX_CANTFOLD;
    1:             }
    1:             pn->pn_type = TOK_XMLPTAGC;
27012:             pn->pn_xflags |= PNX_XMLROOT;
    1:         } else {
    1:             /* We had better have a tag-close (>) at this point. */
    1:             if (tt != TOK_XMLTAGC) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1:             pn2->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1: 
    1:             /* Make sure pn2 is a TOK_XMLSTAGO list containing tag contents. */
    1:             if (pn2->pn_type != TOK_XMLSTAGO) {
27012:                 pn->initList(pn2);
    1:                 if (!XML_FOLDABLE(pn2))
27012:                     pn->pn_xflags |= PNX_CANTFOLD;
    1:                 pn2 = pn;
27012:                 pn = NewParseNode(PN_LIST, tc);
    1:                 if (!pn)
    1:                     return NULL;
    1:             }
    1: 
    1:             /* Now make pn a nominal-root TOK_XMLELEM list containing pn2. */
    1:             pn->pn_type = TOK_XMLELEM;
27012:             pn->pn_pos.begin = pn2->pn_pos.begin;
27012:             pn->initList(pn2);
    1:             if (!XML_FOLDABLE(pn2))
27012:                 pn->pn_xflags |= PNX_CANTFOLD;
27012:             pn->pn_xflags |= PNX_XMLROOT;
    1: 
    1:             /* Get element contents and delimiting end-tag-open sequence. */
    1:             if (!XMLElementContent(cx, ts, pn, tc))
    1:                 return NULL;
    1: 
    1:             tt = js_GetToken(cx, ts);
    1:             XML_CHECK_FOR_ERROR_AND_EOF(tt, NULL);
    1:             if (tt != TOK_XMLNAME && tt != TOK_LC) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1: 
    1:             /* Parse end tag; check mismatch at compile-time if we can. */
    1:             pn2 = XMLTagContent(cx, ts, tc, TOK_XMLETAGO, &endAtom);
    1:             if (!pn2)
    1:                 return NULL;
    1:             if (pn2->pn_type == TOK_XMLETAGO) {
    1:                 /* Oops, end tag has attributes! */
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1:             if (endAtom && startAtom && endAtom != startAtom) {
    1:                 JSString *str = ATOM_TO_STRING(startAtom);
    1: 
    1:                 /* End vs. start tag name mismatch: point to the tag name. */
 7984:                 js_ReportCompileErrorNumber(cx, ts, pn2,
 7984:                                             JSREPORT_UC | JSREPORT_ERROR,
    1:                                             JSMSG_XML_TAG_NAME_MISMATCH,
    1:                                             JSSTRING_CHARS(str));
    1:                 return NULL;
    1:             }
    1: 
    1:             /* Make a TOK_XMLETAGO list with pn2 as its single child. */
    1:             JS_ASSERT(pn2->pn_type == TOK_XMLNAME || pn2->pn_type == TOK_LC);
27012:             list = NewParseNode(PN_LIST, tc);
    1:             if (!list)
    1:                 return NULL;
    1:             list->pn_type = TOK_XMLETAGO;
27012:             list->initList(pn2);
27012:             pn->append(list);
    1:             if (!XML_FOLDABLE(pn2)) {
27012:                 list->pn_xflags |= PNX_CANTFOLD;
27012:                 pn->pn_xflags |= PNX_CANTFOLD;
    1:             }
    1: 
    1:             js_MatchToken(cx, ts, TOK_XMLSPACE);
    1:             MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_TAG_SYNTAX);
    1:         }
    1: 
    1:         /* Set pn_op now that pn has been updated to its final value. */
    1:         pn->pn_op = JSOP_TOXML;
    1:     } else if (allowList && tt == TOK_XMLTAGC) {
    1:         /* XMLList Initialiser. */
    1:         pn->pn_type = TOK_XMLLIST;
    1:         pn->pn_op = JSOP_TOXMLLIST;
27012:         pn->makeEmpty();
27012:         pn->pn_xflags |= PNX_XMLROOT;
    1:         if (!XMLElementContent(cx, ts, pn, tc))
    1:             return NULL;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_LIST_SYNTAX);
    1:     } else {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_XML_NAME_SYNTAX);
    1:         return NULL;
    1:     }
    1: 
    1:     pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:     ts->flags &= ~TSF_XMLTAGMODE;
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
    1: XMLElementOrListRoot(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:                      JSBool allowList)
    1: {
    1:     uint32 oldopts;
    1:     JSParseNode *pn;
    1: 
    1:     /*
    1:      * Force XML support to be enabled so that comments and CDATA literals
    1:      * are recognized, instead of <! followed by -- starting an HTML comment
    1:      * to end of line (used in script tags to hide content from old browsers
    1:      * that don't recognize <script>).
    1:      */
    1:     oldopts = JS_SetOptions(cx, cx->options | JSOPTION_XML);
    1:     pn = XMLElementOrList(cx, ts, tc, allowList);
    1:     JS_SetOptions(cx, oldopts);
    1:     return pn;
    1: }
    1: 
27012: JSParseNode *
27012: JSCompiler::parseXMLText(JSObject *chain, bool allowList)
27012: {
    1:     /*
    1:      * Push a compiler frame if we have no frames, or if the top frame is a
    1:      * lightweight function activation, or if its scope chain doesn't match
    1:      * the one passed to us.
    1:      */
27012:     JSTreeContext tc(this);
27012:     tc.scopeChain = chain;
    1: 
    1:     /* Set XML-only mode to turn off special treatment of {expr} in XML. */
27012:     TS(this)->flags |= TSF_OPERAND | TSF_XMLONLYMODE;
27012:     JSTokenType tt = js_GetToken(context, TS(this));
27012:     TS(this)->flags &= ~TSF_OPERAND;
27012: 
27012:     JSParseNode *pn;
    1:     if (tt != TOK_XMLSTAGO) {
27012:         js_ReportCompileErrorNumber(context, TS(this), NULL, JSREPORT_ERROR,
    1:                                     JSMSG_BAD_XML_MARKUP);
    1:         pn = NULL;
    1:     } else {
27012:         pn = XMLElementOrListRoot(context, TS(this), &tc, allowList);
27012:     }
27012: 
27012:     TS(this)->flags &= ~TSF_XMLONLYMODE;
    1:     return pn;
    1: }
    1: 
    1: #endif /* JS_HAS_XMLSUPPORT */
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012: /*
27012:  * Check whether blockid is an active scoping statement in tc. This code is
27012:  * necessary to qualify tc->decls.lookup() hits in PrimaryExpr's TOK_NAME case
27012:  * (below) where the hits come from Scheme-ish let bindings in for loop heads
27012:  * and let blocks and expressions (not let declarations).
27012:  *
27012:  * Unlike let declarations ("let as the new var"), which is a kind of letrec
27012:  * due to hoisting, let in a for loop head, let block, or let expression acts
27012:  * like Scheme's let: initializers are evaluated without the new let bindings
27012:  * being in scope.
27012:  *
27012:  * Name binding analysis is eager with fixups, rather than multi-pass, and let
27012:  * bindings push on the front of the tc->decls JSAtomList (either the singular
27012:  * list or on a hash chain -- see JSAtomList::AddHow) in order to shadow outer
27012:  * scope bindings of the same name.
27012:  *
27012:  * This simplifies binding lookup code at the price of a linear search here,
27012:  * but only if code uses let (var predominates), and even then this function's
27012:  * loop iterates more than once only in crazy cases.
27012:  */
27012: static bool
27012: BlockIdIsScope(uintN blockid, JSTreeContext *tc)
27012: {
27012:     for (JSStmtInfo *stmt = tc->topScopeStmt; stmt; stmt = stmt->downScope) {
27012:         if (stmt->blockid == blockid)
27012:             return true;
27012:     }
27012:     return false;
27012: }
27012: #endif
27012: 
    1: static JSParseNode *
    1: PrimaryExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
    1:             JSTokenType tt, JSBool afterDot)
    1: {
    1:     JSParseNode *pn, *pn2, *pn3;
    1:     JSOp op;
11139: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
11139: 
    1: #if JS_HAS_GETTER_SETTER
    1:     if (tt == TOK_NAME) {
    1:         tt = CheckGetterOrSetter(cx, ts, TOK_FUNCTION);
    1:         if (tt == TOK_ERROR)
    1:             return NULL;
    1:     }
    1: #endif
    1: 
    1:     switch (tt) {
    1:       case TOK_FUNCTION:
    1: #if JS_HAS_XML_SUPPORT
    1:         ts->flags |= TSF_KEYWORD_IS_NAME;
    1:         if (js_MatchToken(cx, ts, TOK_DBLCOLON)) {
    1:             ts->flags &= ~TSF_KEYWORD_IS_NAME;
27012:             pn2 = NewParseNode(PN_NULLARY, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_type = TOK_FUNCTION;
    1:             pn = QualifiedSuffix(cx, ts, pn2, tc);
    1:             if (!pn)
    1:                 return NULL;
    1:             break;
    1:         }
    1:         ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1: #endif
    1:         pn = FunctionExpr(cx, ts, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_LB:
    1:       {
    1:         JSBool matched;
    1:         jsuint index;
    1: 
27012:         pn = NewParseNode(PN_LIST, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_RB;
20902:         pn->pn_op = JSOP_NEWINIT;
27012:         pn->makeEmpty();
27012: 
27012: #if JS_HAS_GENERATORS
27012:         pn->pn_blockid = tc->blockidGen;
27012: #endif
    1: 
    1:         ts->flags |= TSF_OPERAND;
    1:         matched = js_MatchToken(cx, ts, TOK_RB);
    1:         ts->flags &= ~TSF_OPERAND;
    1:         if (!matched) {
    1:             for (index = 0; ; index++) {
    1:                 if (index == ARRAY_INIT_LIMIT) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_ARRAY_INIT_TOO_BIG);
    1:                     return NULL;
    1:                 }
    1: 
    1:                 ts->flags |= TSF_OPERAND;
    1:                 tt = js_PeekToken(cx, ts);
    1:                 ts->flags &= ~TSF_OPERAND;
    1:                 if (tt == TOK_RB) {
27012:                     pn->pn_xflags |= PNX_ENDCOMMA;
    1:                     break;
    1:                 }
    1: 
    1:                 if (tt == TOK_COMMA) {
    1:                     /* So CURRENT_TOKEN gets TOK_COMMA and not TOK_LB. */
    1:                     js_MatchToken(cx, ts, TOK_COMMA);
27012:                     pn2 = NewParseNode(PN_NULLARY, tc);
    1:                 } else {
    1:                     pn2 = AssignExpr(cx, ts, tc);
    1:                 }
    1:                 if (!pn2)
    1:                     return NULL;
27012:                 pn->append(pn2);
    1: 
    1:                 if (tt != TOK_COMMA) {
    1:                     /* If we didn't already match TOK_COMMA in above case. */
    1:                     if (!js_MatchToken(cx, ts, TOK_COMMA))
    1:                         break;
    1:                 }
    1:             }
    1: 
    1: #if JS_HAS_GENERATORS
    1:             /*
    1:              * At this point, (index == 0 && pn->pn_count != 0) implies one
26959:              * element initialiser was parsed.
    1:              *
    1:              * An array comprehension of the form:
    1:              *
    1:              *   [i * j for (i in o) for (j in p) if (i != j)]
    1:              *
    1:              * translates to roughly the following let expression:
    1:              *
    1:              *   let (array = new Array, i, j) {
    1:              *     for (i in o) let {
    1:              *       for (j in p)
    1:              *         if (i != j)
    1:              *           array.push(i * j)
    1:              *     }
    1:              *     array
    1:              *   }
    1:              *
    1:              * where array is a nameless block-local variable.  The "roughly"
    1:              * means that an implementation may optimize away the array.push.
    1:              * An array comprehension opens exactly one block scope, no matter
    1:              * how many for heads it contains.
    1:              *
    1:              * Each let () {...} or for (let ...) ... compiles to:
    1:              *
    1:              *   JSOP_ENTERBLOCK <o> ... JSOP_LEAVEBLOCK <n>
    1:              *
    1:              * where <o> is a literal object representing the block scope,
    1:              * with <n> properties, naming each var declared in the block.
    1:              *
    1:              * Each var declaration in a let-block binds a name in <o> at
    1:              * compile time, and allocates a slot on the operand stack at
    1:              * runtime via JSOP_ENTERBLOCK.  A block-local var is accessed
    1:              * by the JSOP_GETLOCAL and JSOP_SETLOCAL ops, and iterated with
    1:              * JSOP_FORLOCAL.  These ops all have an immediate operand, the
    1:              * local slot's stack index from fp->spbase.
    1:              *
    1:              * The array comprehension iteration step, array.push(i * j) in
    1:              * the example above, is done by <i * j>; JSOP_ARRAYCOMP <array>,
    1:              * where <array> is the index of array's stack slot.
    1:              */
    1:             if (index == 0 &&
    1:                 pn->pn_count != 0 &&
    1:                 js_MatchToken(cx, ts, TOK_FOR)) {
 1577:                 JSParseNode *pnexp, *pntop;
    1: 
    1:                 /* Relabel pn as an array comprehension node. */
    1:                 pn->pn_type = TOK_ARRAYCOMP;
    1: 
    1:                 /*
    1:                  * Remove the comprehension expression from pn's linked list
    1:                  * and save it via pnexp.  We'll re-install it underneath the
    1:                  * ARRAYPUSH node after we parse the rest of the comprehension.
    1:                  */
27012:                 pnexp = pn->last();
    1:                 JS_ASSERT(pn->pn_count == 1 || pn->pn_count == 2);
    1:                 pn->pn_tail = (--pn->pn_count == 1)
    1:                               ? &pn->pn_head->pn_next
    1:                               : &pn->pn_head;
    1:                 *pn->pn_tail = NULL;
    1: 
27012:                 pntop = ComprehensionTail(pnexp, pn->pn_blockid, tc,
27012:                                           TOK_ARRAYPUSH, JSOP_ARRAYPUSH);
    1:                 if (!pntop)
    1:                     return NULL;
27012:                 pn->append(pntop);
    1:             }
    1: #endif /* JS_HAS_GENERATORS */
    1: 
    1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_LIST);
    1:         }
    1:         pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_LC:
    1:       {
    1:         JSBool afterComma;
11039:         JSParseNode *pnval;
    1: 
27012:         pn = NewParseNode(PN_LIST, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_RC;
20902:         pn->pn_op = JSOP_NEWINIT;
27012:         pn->makeEmpty();
    1: 
    1:         afterComma = JS_FALSE;
    1:         for (;;) {
    1:             ts->flags |= TSF_KEYWORD_IS_NAME;
    1:             tt = js_GetToken(cx, ts);
    1:             ts->flags &= ~TSF_KEYWORD_IS_NAME;
    1:             switch (tt) {
    1:               case TOK_NUMBER:
27012:                 pn3 = NewParseNode(PN_NULLARY, tc);
    1:                 if (pn3)
    1:                     pn3->pn_dval = CURRENT_TOKEN(ts).t_dval;
    1:                 break;
    1:               case TOK_NAME:
    1: #if JS_HAS_GETTER_SETTER
    1:                 {
    1:                     JSAtom *atom;
    1: 
    1:                     atom = CURRENT_TOKEN(ts).t_atom;
 1478:                     if (atom == cx->runtime->atomState.getAtom)
 1478:                         op = JSOP_GETTER;
 1478:                     else if (atom == cx->runtime->atomState.setAtom)
 1478:                         op = JSOP_SETTER;
 1478:                     else
 1478:                         goto property_name;
 1478: 
 1478:                     ts->flags |= TSF_KEYWORD_IS_NAME;
 1478:                     tt = js_GetToken(cx, ts);
 1478:                     ts->flags &= ~TSF_KEYWORD_IS_NAME;
 1478:                     if (tt != TOK_NAME) {
 1478:                         js_UngetToken(ts);
 1478:                         goto property_name;
 1478:                     }
27012:                     pn3 = NewNameNode(cx, ts, CURRENT_TOKEN(ts).t_atom, tc);
    1:                     if (!pn3)
    1:                         return NULL;
    1: 
    1:                     /* We have to fake a 'function' token here. */
    1:                     CURRENT_TOKEN(ts).t_op = JSOP_NOP;
    1:                     CURRENT_TOKEN(ts).type = TOK_FUNCTION;
    1:                     pn2 = FunctionExpr(cx, ts, tc);
27012:                     pn2 = NewBinary(TOK_COLON, op, pn3, pn2, tc);
    1:                     goto skip;
    1:                 }
 1478:               property_name:
    1: #endif
    1:               case TOK_STRING:
27012:                 pn3 = NewParseNode(PN_NULLARY, tc);
    1:                 if (pn3)
    1:                     pn3->pn_atom = CURRENT_TOKEN(ts).t_atom;
    1:                 break;
    1:               case TOK_RC:
    1:                 if (afterComma &&
 7984:                     !js_ReportCompileErrorNumber(cx, ts, NULL,
    1:                                                  JSREPORT_WARNING |
    1:                                                  JSREPORT_STRICT,
    1:                                                  JSMSG_TRAILING_COMMA)) {
    1:                         return NULL;
    1:                 }
    1:                 goto end_obj_init;
    1:               default:
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_PROP_ID);
    1:                 return NULL;
    1:             }
    1: 
    1:             tt = js_GetToken(cx, ts);
    1: #if JS_HAS_GETTER_SETTER
    1:             if (tt == TOK_NAME) {
    1:                 tt = CheckGetterOrSetter(cx, ts, TOK_COLON);
    1:                 if (tt == TOK_ERROR)
    1:                     return NULL;
    1:             }
    1: #endif
11039: 
    1:             if (tt != TOK_COLON) {
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:                 if (tt != TOK_COMMA && tt != TOK_RC) {
11039: #endif
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_COLON_AFTER_ID);
    1:                     return NULL;
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:                 }
11039: 
11039:                 /*
11039:                  * Support, e.g., |var {x, y} = o| as destructuring shorthand
11039:                  * for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.
11039:                  */
11039:                 js_UngetToken(ts);
27012:                 pn->pn_xflags |= PNX_DESTRUCT;
11039:                 pnval = pn3;
11039:                 if (pnval->pn_type == TOK_NAME) {
11039:                     pnval->pn_arity = PN_NAME;
27012:                     InitNameNodeCommon(pnval, tc);
11039:                 }
11039:                 op = JSOP_NOP;
11039: #endif
11039:             } else {
    1:                 op = CURRENT_TOKEN(ts).t_op;
11039:                 pnval = AssignExpr(cx, ts, tc);
11039:             }
11039: 
27012:             pn2 = NewBinary(TOK_COLON, op, pn3, pnval, tc);
    1: #if JS_HAS_GETTER_SETTER
    1:           skip:
    1: #endif
    1:             if (!pn2)
    1:                 return NULL;
27012:             pn->append(pn2);
    1: 
    1:             tt = js_GetToken(cx, ts);
    1:             if (tt == TOK_RC)
    1:                 goto end_obj_init;
    1:             if (tt != TOK_COMMA) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_CURLY_AFTER_LIST);
    1:                 return NULL;
    1:             }
    1:             afterComma = JS_TRUE;
    1:         }
 1967: 
    1:       end_obj_init:
    1:         pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         return pn;
    1:       }
    1: 
 1967: #if JS_HAS_BLOCK_SCOPE
 1967:       case TOK_LET:
 1967:         pn = LetBlock(cx, ts, tc, JS_FALSE);
 1967:         if (!pn)
 1967:             return NULL;
 1967:         break;
 1967: #endif
 1967: 
    1: #if JS_HAS_SHARP_VARS
    1:       case TOK_DEFSHARP:
27012:         pn = NewParseNode(PN_UNARY, tc);
26959:         if (!pn)
26959:             return NULL;
26959:         pn->pn_num = (jsint) CURRENT_TOKEN(ts).t_dval;
    1:         ts->flags |= TSF_OPERAND;
    1:         tt = js_GetToken(cx, ts);
    1:         ts->flags &= ~TSF_OPERAND;
26959:         if (tt == TOK_USESHARP || tt == TOK_DEFSHARP ||
26959: #if JS_HAS_XML_SUPPORT
26959:             tt == TOK_STAR || tt == TOK_AT ||
26959:             tt == TOK_XMLSTAGO /* XXXbe could be sharp? */ ||
26959: #endif
26959:             tt == TOK_STRING || tt == TOK_NUMBER || tt == TOK_PRIMARY) {
26959:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
26959:                                         JSMSG_BAD_SHARP_VAR_DEF);
26959:             return NULL;
26959:         }
26959:         pn->pn_kid = PrimaryExpr(cx, ts, tc, tt, JS_FALSE);
26959:         if (!pn->pn_kid)
26959:             return NULL;
26959:         tc->flags |= TCF_HAS_SHARPS;
26959:         break;
    1: 
    1:       case TOK_USESHARP:
    1:         /* Check for forward/dangling references at runtime, to allow eval. */
27012:         pn = NewParseNode(PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_num = (jsint) CURRENT_TOKEN(ts).t_dval;
26959:         tc->flags |= TCF_HAS_SHARPS;
    1:         break;
    1: #endif /* JS_HAS_SHARP_VARS */
    1: 
    1:       case TOK_LP:
 1577:       {
 1577:         JSBool genexp;
 1577: 
27012:         pn = NewParseNode(PN_UNARY, tc);
    1:         if (!pn)
    1:             return NULL;
 1577:         pn2 = ParenExpr(cx, ts, tc, pn, &genexp);
    1:         if (!pn2)
    1:             return NULL;
 1577:         if (genexp)
 1577:             return pn2;
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_IN_PAREN);
26956: 
26956:         /* Check if parentheses were unnecessary. */
    1:         if (pn2->pn_type == TOK_RP ||
    1:             (js_CodeSpec[pn2->pn_op].prec >= js_CodeSpec[JSOP_GETPROP].prec &&
    1:              !afterDot)) {
    1:             RecycleTree(pn, tc);
    1:             pn = pn2;
    1:         } else {
    1:             pn->pn_type = TOK_RP;
 7991:             pn->pn_kid = pn2;
 7991:         }
    1:         pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
    1:         break;
 1577:       }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_STAR:
    1:         pn = QualifiedIdentifier(cx, ts, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_AT:
    1:         pn = AttributeIdentifier(cx, ts, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_XMLSTAGO:
    1:         pn = XMLElementOrListRoot(cx, ts, tc, JS_TRUE);
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:       case TOK_STRING:
    1: #if JS_HAS_SHARP_VARS
    1:         /* FALL THROUGH */
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_XMLCDATA:
    1:       case TOK_XMLCOMMENT:
    1:       case TOK_XMLPI:
    1: #endif
27012:         pn = NewParseNode(PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_atom = CURRENT_TOKEN(ts).t_atom;
    1: #if JS_HAS_XML_SUPPORT
    1:         if (tt == TOK_XMLPI)
    1:             pn->pn_atom2 = CURRENT_TOKEN(ts).t_atom2;
    1:         else
    1: #endif
    1:             pn->pn_op = CURRENT_TOKEN(ts).t_op;
27012:         break;
27012: 
27012:       case TOK_NAME:
27012:         pn = NewNameNode(cx, ts, CURRENT_TOKEN(ts).t_atom, tc);
27012:         if (!pn)
27012:             return NULL;
27012:         JS_ASSERT(CURRENT_TOKEN(ts).t_op == JSOP_NAME);
27012:         pn->pn_op = JSOP_NAME;
27012: 
27012:         if ((tc->flags & (TCF_IN_FUNCTION | TCF_FUN_PARAM_ARGUMENTS)) == TCF_IN_FUNCTION &&
27012:             pn->pn_atom == cx->runtime->atomState.argumentsAtom) {
27012:             /*
27012:              * Flag arguments usage so we can avoid unsafe optimizations such
27012:              * as formal parameter assignment analysis (because of the hated
27012:              * feature whereby arguments alias formals). We do this even for
27012:              * a reference of the form foo.arguments, which ancient code may
27012:              * still use instead of arguments (more hate).
27012:              */
27012:             tc->flags |= TCF_FUN_USES_ARGUMENTS;
27012: 
27012:             /*
27012:              * Bind early to JSOP_ARGUMENTS to relieve later code from having
27012:              * to do this work (new rule for the emitter to count on).
27012:              */
27012:             if (!afterDot && !(ts->flags & TSF_DESTRUCTURING) && !tc->inStatement(STMT_WITH)) {
27012:                 pn->pn_op = JSOP_ARGUMENTS;
27012:                 pn->pn_dflags |= PND_BOUND;
27012:             }
27012:         } else if (!afterDot && !(ts->flags & TSF_DESTRUCTURING)) {
27012:             JSAtomListElement *ale = NULL;
27012:             JSTreeContext *tcx = tc;
27012:             bool hit_named_lambda = false;
27012:             JSDefinition *dn;
27012: 
27012:             do {
27012:                 JSStmtInfo *stmt = js_LexicalLookup(tcx, pn->pn_atom, NULL);
27012: 
27012:                 if (stmt && stmt->type == STMT_WITH)
27012:                     goto losing_with;
27012:                 ale = tcx->decls.lookup(pn->pn_atom);
27012:                 if (ale) {
27012:                     dn = ALE_DEFN(ale);
27012: #if JS_HAS_BLOCK_SCOPE
27012:                     if (!dn->isLet())
27012:                         break;
27012:                     if (dn->pn_blockid <= tc->blockid() && BlockIdIsScope(dn->pn_blockid, tcx))
27012:                         break;
27012:                     ale = NULL;
27012: #else
27012:                     break;
27012: #endif
27012:                 }
27012: 
27012:                 /* If this id names the current lambda's name, we are done. */
27012:                 if ((tc->flags & TCF_IN_FUNCTION) &&
27012:                     (tc->fun->flags & JSFUN_LAMBDA) &&
27012:                     tc->fun->atom == pn->pn_atom) {
27012:                     hit_named_lambda = true;
27012:                     break;
27012:                 }
27012:             } while ((tcx = tcx->parent) != NULL);
27012: 
27012:             if (!ale) {
27012:                 ale = tc->lexdeps.lookup(pn->pn_atom);
27012:                 if (!ale) {
27012:                     /*
27012:                      * No definition before this use in any lexical scope. Add
27012:                      * a mapping in tc->lexdeps from pn->pn_atom to a new node
27012:                      * for the forward-referenced definition. This placeholder
27012:                      * definition node will be adopted when we parse the real
27012:                      * defining declaration form, or left as a free variable
27012:                      * definition if we never see the real definition.
27012:                      */
27012:                     ale = MakePlaceholder(pn, tc);
27012:                     if (!ale)
27012:                         return NULL;
27012:                     dn = ALE_DEFN(ale);
27012: 
27012:                     /*
27012:                      * In case this is a forward reference to a function, we
27012:                      * pessimistically set PND_FUNARG if the next token is not
27012:                      * a left parenthesis. If the eventual definition parsed
27012:                      * into dn is not a function, this flag won't hurt, and if
27012:                      * it is a function, the flag is necessary for safe display
27012:                      * optimization of the closure's static link.
27012:                      */
27012:                     JS_ASSERT(PN_TYPE(dn) == TOK_NAME);
27012:                     JS_ASSERT(dn->pn_op == JSOP_NOP);
27012:                     if (js_PeekToken(cx, ts) != TOK_LP)
27012:                         dn->pn_dflags |= PND_FUNARG;
27012:                 }
27012:             }
27012: 
27012:             dn = ALE_DEFN(ale);
27012:             JS_ASSERT(dn->pn_defn);
27012:             LinkUseToDef(pn, dn, tc);
27012: 
27012:             /*
27012:              * For an upvar reference, map pn->pn_atom to dn in tc->upvars. The
27012:              * subtleties here include:
27012:              *
27012:              * (a) tcx could be null, meaning we add an upvar speculatively for
27012:              * what looks like a free variable reference (it will be removed if
27012:              * a backward definition appears later; see NewBindingNode/Define).
27012:              *
27012:              * (b) If pn names the named function expression whose body we are
27012:              * parsing, there's no way an upvar could be referenced here.
27012:              *
27012:              * (a) is is an optimization to handle forward upvar refs. Without
27012:              * it, if we add only a lexdep, then inner functions making forward
27012:              * refs to upvars will lose track of those upvars as their lexdeps
27012:              * entries are propagated upward to their parent functions.
27012:              */
27012:             if (tcx != tc && !hit_named_lambda) {
27012:                 ale = tc->upvars.add(tc->compiler, pn->pn_atom);
27012:                 if (!ale)
27012:                     return NULL;
27012:                 ALE_SET_DEFN(ale, dn);
27012:             }
27012: 
27012:             /* Here we handle the backward function reference case. */
27012:             if (js_PeekToken(cx, ts) != TOK_LP)
27012:                 dn->pn_dflags |= PND_FUNARG;
27012: 
27012:             pn->pn_dflags |= (dn->pn_dflags & PND_FUNARG);
27012:         }
27012: 
27012:       losing_with:
    1: #if JS_HAS_XML_SUPPORT
    1:         if (js_MatchToken(cx, ts, TOK_DBLCOLON)) {
    1:             if (afterDot) {
    1:                 JSString *str;
    1: 
    1:                 /*
27012:                  * Here PrimaryExpr is called after . or .. followed by a name
27012:                  * followed by ::. This is the only case where a keyword after
27012:                  * . or .. is not treated as a property name.
    1:                  */
    1:                 str = ATOM_TO_STRING(pn->pn_atom);
27012:                 tt = js_CheckKeyword(JSSTRING_CHARS(str), JSSTRING_LENGTH(str));
    1:                 if (tt == TOK_FUNCTION) {
    1:                     pn->pn_arity = PN_NULLARY;
    1:                     pn->pn_type = TOK_FUNCTION;
    1:                 } else if (tt != TOK_EOF) {
27012:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_KEYWORD_NOT_NS);
    1:                     return NULL;
    1:                 }
    1:             }
    1:             pn = QualifiedSuffix(cx, ts, pn, tc);
    1:             if (!pn)
    1:                 return NULL;
    1:         }
    1: #endif
    1:         break;
    1: 
 6561:       case TOK_REGEXP:
 6561:       {
 6561:         JSObject *obj;
 6561: 
27012:         pn = NewParseNode(PN_NULLARY, tc);
 6561:         if (!pn)
 6561:             return NULL;
 6561: 
 6561:         /* Token stream ensures that tokenbuf is NUL-terminated. */
 6561:         JS_ASSERT(*ts->tokenbuf.ptr == (jschar) 0);
 6561:         obj = js_NewRegExpObject(cx, ts,
 6561:                                  ts->tokenbuf.base,
 6561:                                  ts->tokenbuf.ptr - ts->tokenbuf.base,
 6561:                                  CURRENT_TOKEN(ts).t_reflags);
 6561:         if (!obj)
 6561:             return NULL;
 9481:         if (!(tc->flags & TCF_COMPILE_N_GO)) {
16069:             STOBJ_CLEAR_PARENT(obj);
16069:             STOBJ_CLEAR_PROTO(obj);
 9481:         }
 6561: 
27012:         pn->pn_objbox = tc->compiler->newObjectBox(obj);
27012:         if (!pn->pn_objbox)
 6561:             return NULL;
 6561: 
 6561:         pn->pn_op = JSOP_REGEXP;
 6561:         break;
 6561:       }
 6561: 
    1:       case TOK_NUMBER:
27012:         pn = NewParseNode(PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
20902:         pn->pn_op = JSOP_DOUBLE;
    1:         pn->pn_dval = CURRENT_TOKEN(ts).t_dval;
    1:         break;
    1: 
    1:       case TOK_PRIMARY:
27012:         pn = NewParseNode(PN_NULLARY, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_op = CURRENT_TOKEN(ts).t_op;
    1:         break;
    1: 
    1:       case TOK_ERROR:
    1:         /* The scanner or one of its subroutines reported the error. */
    1:         return NULL;
    1: 
    1:       default:
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     return pn;
    1: }
    1: 
 1577: static JSParseNode *
 1577: ParenExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc,
 1577:           JSParseNode *pn1, JSBool *genexp)
 1577: {
 1577:     JSTokenPtr begin;
 1577:     JSParseNode *pn;
 1577: 
 1577:     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_LP);
 1577:     begin = CURRENT_TOKEN(ts).pos.begin;
 1577: 
 1577:     if (genexp)
 1577:         *genexp = JS_FALSE;
 1577:     pn = BracketedExpr(cx, ts, tc);
 1577:     if (!pn)
 1577:         return NULL;
 1577: 
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577:     if (js_MatchToken(cx, ts, TOK_FOR)) {
 1577:         if (pn->pn_type == TOK_YIELD) {
 7984:             js_ReportCompileErrorNumber(cx, ts, pn, JSREPORT_ERROR,
 1577:                                         JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                         js_yield_str);
 1577:             return NULL;
 1577:         }
 1577:         if (pn->pn_type == TOK_COMMA) {
27012:             js_ReportCompileErrorNumber(cx, ts, pn->last(), JSREPORT_ERROR,
 1577:                                         JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                         js_generator_str);
 1577:             return NULL;
 1577:         }
 1577:         if (!pn1) {
27012:             pn1 = NewParseNode(PN_UNARY, tc);
 1577:             if (!pn1)
 1577:                 return NULL;
 1577:         }
27012:         pn = GeneratorExpr(pn1, pn, tc);
27012:         if (!pn)
27012:             return NULL;
26970:         pn->pn_pos.begin = begin;
 1577:         if (genexp) {
 1577:             if (js_GetToken(cx, ts) != TOK_RP) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
 1577:                                             JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                             js_generator_str);
 1577:                 return NULL;
 1577:             }
 1577:             pn->pn_pos.end = CURRENT_TOKEN(ts).pos.end;
 1577:             *genexp = JS_TRUE;
 1577:         }
 1577:     }
 1577: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577: 
 1577:     return pn;
 1577: }
 1577: 
    1: /*
    1:  * Fold from one constant type to another.
    1:  * XXX handles only strings and numbers for now
    1:  */
    1: static JSBool
    1: FoldType(JSContext *cx, JSParseNode *pn, JSTokenType type)
    1: {
27012:     if (PN_TYPE(pn) != type) {
    1:         switch (type) {
    1:           case TOK_NUMBER:
    1:             if (pn->pn_type == TOK_STRING) {
    1:                 jsdouble d;
12694:                 if (!JS_ValueToNumber(cx, ATOM_KEY(pn->pn_atom), &d))
    1:                     return JS_FALSE;
    1:                 pn->pn_dval = d;
    1:                 pn->pn_type = TOK_NUMBER;
 3328:                 pn->pn_op = JSOP_DOUBLE;
    1:             }
    1:             break;
    1: 
    1:           case TOK_STRING:
    1:             if (pn->pn_type == TOK_NUMBER) {
    1:                 JSString *str = js_NumberToString(cx, pn->pn_dval);
    1:                 if (!str)
    1:                     return JS_FALSE;
    1:                 pn->pn_atom = js_AtomizeString(cx, str, 0);
    1:                 if (!pn->pn_atom)
    1:                     return JS_FALSE;
    1:                 pn->pn_type = TOK_STRING;
    1:                 pn->pn_op = JSOP_STRING;
    1:             }
    1:             break;
    1: 
    1:           default:;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Fold two numeric constants.  Beware that pn1 and pn2 are recycled, unless
    1:  * one of them aliases pn, so you can't safely fetch pn2->pn_next, e.g., after
    1:  * a successful call to this function.
    1:  */
    1: static JSBool
    1: FoldBinaryNumeric(JSContext *cx, JSOp op, JSParseNode *pn1, JSParseNode *pn2,
    1:                   JSParseNode *pn, JSTreeContext *tc)
    1: {
    1:     jsdouble d, d2;
    1:     int32 i, j;
    1: 
    1:     JS_ASSERT(pn1->pn_type == TOK_NUMBER && pn2->pn_type == TOK_NUMBER);
    1:     d = pn1->pn_dval;
    1:     d2 = pn2->pn_dval;
    1:     switch (op) {
    1:       case JSOP_LSH:
    1:       case JSOP_RSH:
 9613:         i = js_DoubleToECMAInt32(d);
 9613:         j = js_DoubleToECMAInt32(d2);
    1:         j &= 31;
    1:         d = (op == JSOP_LSH) ? i << j : i >> j;
    1:         break;
    1: 
    1:       case JSOP_URSH:
 9613:         j = js_DoubleToECMAInt32(d2);
    1:         j &= 31;
 9613:         d = js_DoubleToECMAUint32(d) >> j;
    1:         break;
    1: 
    1:       case JSOP_ADD:
    1:         d += d2;
    1:         break;
    1: 
    1:       case JSOP_SUB:
    1:         d -= d2;
    1:         break;
    1: 
    1:       case JSOP_MUL:
    1:         d *= d2;
    1:         break;
    1: 
    1:       case JSOP_DIV:
    1:         if (d2 == 0) {
    1: #if defined(XP_WIN)
    1:             /* XXX MSVC miscompiles such that (NaN == 0) */
    1:             if (JSDOUBLE_IS_NaN(d2))
    1:                 d = *cx->runtime->jsNaN;
    1:             else
    1: #endif
    1:             if (d == 0 || JSDOUBLE_IS_NaN(d))
    1:                 d = *cx->runtime->jsNaN;
    1:             else if ((JSDOUBLE_HI32(d) ^ JSDOUBLE_HI32(d2)) >> 31)
    1:                 d = *cx->runtime->jsNegativeInfinity;
    1:             else
    1:                 d = *cx->runtime->jsPositiveInfinity;
    1:         } else {
    1:             d /= d2;
    1:         }
    1:         break;
    1: 
    1:       case JSOP_MOD:
    1:         if (d2 == 0) {
    1:             d = *cx->runtime->jsNaN;
    1:         } else {
    1: #if defined(XP_WIN)
    1:           /* Workaround MS fmod bug where 42 % (1/0) => NaN, not 42. */
    1:           if (!(JSDOUBLE_IS_FINITE(d) && JSDOUBLE_IS_INFINITE(d2)))
    1: #endif
    1:             d = fmod(d, d2);
    1:         }
    1:         break;
    1: 
    1:       default:;
    1:     }
    1: 
    1:     /* Take care to allow pn1 or pn2 to alias pn. */
    1:     if (pn1 != pn)
    1:         RecycleTree(pn1, tc);
    1:     if (pn2 != pn)
    1:         RecycleTree(pn2, tc);
    1:     pn->pn_type = TOK_NUMBER;
 3328:     pn->pn_op = JSOP_DOUBLE;
    1:     pn->pn_arity = PN_NULLARY;
    1:     pn->pn_dval = d;
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: 
    1: static JSBool
    1: FoldXMLConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc)
    1: {
    1:     JSTokenType tt;
    1:     JSParseNode **pnp, *pn1, *pn2;
    1:     JSString *accum, *str;
    1:     uint32 i, j;
12677:     JSTempValueRooter tvr;
    1: 
    1:     JS_ASSERT(pn->pn_arity == PN_LIST);
 3164:     tt = PN_TYPE(pn);
    1:     pnp = &pn->pn_head;
    1:     pn1 = *pnp;
    1:     accum = NULL;
27012:     if ((pn->pn_xflags & PNX_CANTFOLD) == 0) {
    1:         if (tt == TOK_XMLETAGO)
    1:             accum = ATOM_TO_STRING(cx->runtime->atomState.etagoAtom);
    1:         else if (tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC)
    1:             accum = ATOM_TO_STRING(cx->runtime->atomState.stagoAtom);
    1:     }
    1: 
12677:     /*
12677:      * GC Rooting here is tricky: for most of the loop, |accum| is safe via
12677:      * the newborn string root. However, when |pn2->pn_type| is TOK_XMLCDATA,
12677:      * TOK_XMLCOMMENT, or TOK_XMLPI it is knocked out of the newborn root.
12677:      * Therefore, we have to add additonal protection from GC nesting under
12677:      * js_ConcatStrings.
12677:      */
    1:     for (pn2 = pn1, i = j = 0; pn2; pn2 = pn2->pn_next, i++) {
    1:         /* The parser already rejected end-tags with attributes. */
    1:         JS_ASSERT(tt != TOK_XMLETAGO || i == 0);
    1:         switch (pn2->pn_type) {
    1:           case TOK_XMLATTR:
    1:             if (!accum)
    1:                 goto cantfold;
    1:             /* FALL THROUGH */
    1:           case TOK_XMLNAME:
    1:           case TOK_XMLSPACE:
    1:           case TOK_XMLTEXT:
    1:           case TOK_STRING:
    1:             if (pn2->pn_arity == PN_LIST)
    1:                 goto cantfold;
    1:             str = ATOM_TO_STRING(pn2->pn_atom);
    1:             break;
    1: 
    1:           case TOK_XMLCDATA:
    1:             str = js_MakeXMLCDATAString(cx, ATOM_TO_STRING(pn2->pn_atom));
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case TOK_XMLCOMMENT:
    1:             str = js_MakeXMLCommentString(cx, ATOM_TO_STRING(pn2->pn_atom));
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case TOK_XMLPI:
    1:             str = js_MakeXMLPIString(cx, ATOM_TO_STRING(pn2->pn_atom),
    1:                                          ATOM_TO_STRING(pn2->pn_atom2));
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           cantfold:
    1:           default:
    1:             JS_ASSERT(*pnp == pn1);
    1:             if ((tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC) &&
    1:                 (i & 1) ^ (j & 1)) {
    1: #ifdef DEBUG_brendanXXX
    1:                 printf("1: %d, %d => ", i, j);
    1:                 if (accum)
    1:                     js_FileEscapedString(stdout, accum, 0);
    1:                 else
    1:                     fputs("NULL", stdout);
    1:                 fputc('\n', stdout);
    1: #endif
    1:             } else if (accum && pn1 != pn2) {
    1:                 while (pn1->pn_next != pn2) {
    1:                     pn1 = RecycleTree(pn1, tc);
    1:                     --pn->pn_count;
    1:                 }
    1:                 pn1->pn_type = TOK_XMLTEXT;
    1:                 pn1->pn_op = JSOP_STRING;
    1:                 pn1->pn_arity = PN_NULLARY;
    1:                 pn1->pn_atom = js_AtomizeString(cx, accum, 0);
    1:                 if (!pn1->pn_atom)
    1:                     return JS_FALSE;
    1:                 JS_ASSERT(pnp != &pn1->pn_next);
    1:                 *pnp = pn1;
    1:             }
    1:             pnp = &pn2->pn_next;
    1:             pn1 = *pnp;
    1:             accum = NULL;
    1:             continue;
    1:         }
    1: 
    1:         if (accum) {
12677:             JS_PUSH_TEMP_ROOT_STRING(cx, accum, &tvr);
    1:             str = ((tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC) && i != 0)
    1:                   ? js_AddAttributePart(cx, i & 1, accum, str)
    1:                   : js_ConcatStrings(cx, accum, str);
12677:             JS_POP_TEMP_ROOT(cx, &tvr);
    1:             if (!str)
    1:                 return JS_FALSE;
    1: #ifdef DEBUG_brendanXXX
    1:             printf("2: %d, %d => ", i, j);
    1:             js_FileEscapedString(stdout, str, 0);
    1:             printf(" (%u)\n", JSSTRING_LENGTH(str));
    1: #endif
    1:             ++j;
    1:         }
    1:         accum = str;
    1:     }
    1: 
    1:     if (accum) {
    1:         str = NULL;
27012:         if ((pn->pn_xflags & PNX_CANTFOLD) == 0) {
    1:             if (tt == TOK_XMLPTAGC)
    1:                 str = ATOM_TO_STRING(cx->runtime->atomState.ptagcAtom);
    1:             else if (tt == TOK_XMLSTAGO || tt == TOK_XMLETAGO)
    1:                 str = ATOM_TO_STRING(cx->runtime->atomState.tagcAtom);
    1:         }
    1:         if (str) {
    1:             accum = js_ConcatStrings(cx, accum, str);
    1:             if (!accum)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         JS_ASSERT(*pnp == pn1);
    1:         while (pn1->pn_next) {
    1:             pn1 = RecycleTree(pn1, tc);
    1:             --pn->pn_count;
    1:         }
    1:         pn1->pn_type = TOK_XMLTEXT;
    1:         pn1->pn_op = JSOP_STRING;
    1:         pn1->pn_arity = PN_NULLARY;
    1:         pn1->pn_atom = js_AtomizeString(cx, accum, 0);
    1:         if (!pn1->pn_atom)
    1:             return JS_FALSE;
    1:         JS_ASSERT(pnp != &pn1->pn_next);
    1:         *pnp = pn1;
    1:     }
    1: 
    1:     if (pn1 && pn->pn_count == 1) {
    1:         /*
    1:          * Only one node under pn, and it has been folded: move pn1 onto pn
    1:          * unless pn is an XML root (in which case we need it to tell the code
    1:          * generator to emit a JSOP_TOXML or JSOP_TOXMLLIST op).  If pn is an
    1:          * XML root *and* it's a point-tag, rewrite it to TOK_XMLELEM to avoid
    1:          * extra "<" and "/>" bracketing at runtime.
    1:          */
27012:         if (!(pn->pn_xflags & PNX_XMLROOT)) {
27012:             pn->become(pn1);
    1:         } else if (tt == TOK_XMLPTAGC) {
    1:             pn->pn_type = TOK_XMLELEM;
    1:             pn->pn_op = JSOP_TOXML;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1: static JSBool
    1: StartsWith(JSParseNode *pn, JSTokenType tt)
    1: {
    1: #define TAIL_RECURSE(pn2) JS_BEGIN_MACRO pn = (pn2); goto recur; JS_END_MACRO
    1: 
    1: recur:
27012:     if (PN_TYPE(pn) == tt)
    1:         return JS_TRUE;
    1:     switch (pn->pn_arity) {
    1:       case PN_FUNC:
    1:         return  tt == TOK_FUNCTION;
    1:       case PN_LIST:
    1:         if (pn->pn_head)
    1:             TAIL_RECURSE(pn->pn_head);
    1:         break;
    1:       case PN_TERNARY:
    1:         if (pn->pn_kid1)
    1:             TAIL_RECURSE(pn->pn_kid1);
    1:         break;
    1:       case PN_BINARY:
    1:         if (pn->pn_left)
    1:             TAIL_RECURSE(pn->pn_left);
    1:         break;
    1:       case PN_UNARY:
    1:         /* A parenthesized expression starts with a left parenthesis. */
    1:         if (pn->pn_type == TOK_RP)
    1:             return tt == TOK_LP;
    1:         if (pn->pn_kid)
    1:             TAIL_RECURSE(pn->pn_kid);
    1:         break;
    1:       case PN_NAME:
    1:         if (pn->pn_type == TOK_DOT || pn->pn_type == TOK_DBLDOT)
27012:             TAIL_RECURSE(pn->expr());
27012:         break;
27012:       case PN_NAMESET:
27012:         TAIL_RECURSE(pn->pn_tree);
    1:     }
    1:     return JS_FALSE;
27012: 
    1: #undef TAIL_RECURSE
    1: }
    1: 
20902: static int
20902: Boolish(JSParseNode *pn)
20902: {
20902:     switch (pn->pn_op) {
20902:       case JSOP_DOUBLE:
20918:         return pn->pn_dval != 0 && !JSDOUBLE_IS_NaN(pn->pn_dval);
20902: 
20902:       case JSOP_STRING:
20902:         return JSSTRING_LENGTH(ATOM_TO_STRING(pn->pn_atom)) != 0;
20902: 
20906: #if JS_HAS_GENERATOR_EXPRS
20902:       case JSOP_CALL:
20904:       {
20902:         /*
20902:          * A generator expression as an if or loop condition has no effects, it
20902:          * simply results in a truthy object reference. This condition folding
20903:          * is needed for the decompiler. See bug 442342 and bug 443074.
20902:          */
20902:         if (pn->pn_count != 1)
20902:             break;
20902:         JSParseNode *pn2 = pn->pn_head;
20902:         if (pn2->pn_type != TOK_FUNCTION)
20902:             break;
27012:         if (!(pn2->pn_funbox->tcflags & TCF_GENEXP_LAMBDA))
20902:             break;
20902:         /* FALL THROUGH */
20904:       }
20906: #endif
20902: 
20902:       case JSOP_DEFFUN:
27012:       case JSOP_LAMBDA:
20902:       case JSOP_THIS:
20902:       case JSOP_TRUE:
20902:         return 1;
20902: 
20902:       case JSOP_NULL:
20902:       case JSOP_FALSE:
20902:         return 0;
20902: 
20902:       default:;
20902:     }
20902:     return -1;
20902: }
20902: 
    1: JSBool
20902: js_FoldConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, bool inCond)
    1: {
    1:     JSParseNode *pn1 = NULL, *pn2 = NULL, *pn3 = NULL;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
    1:     switch (pn->pn_arity) {
    1:       case PN_FUNC:
    1:       {
    1:         uint16 oldflags = tc->flags;
27012:         JSFunctionBox *oldlist = tc->functionList;
27012: 
27012:         tc->flags = (uint16) pn->pn_funbox->tcflags;
27012:         tc->functionList = pn->pn_funbox->kids;
    1:         if (!js_FoldConstants(cx, pn->pn_body, tc))
    1:             return JS_FALSE;
27012:         pn->pn_funbox->kids = tc->functionList;
    1:         tc->flags = oldflags;
27012:         tc->functionList = oldlist;
    1:         break;
    1:       }
    1: 
    1:       case PN_LIST:
21457:       {
21457:         /* Propagate inCond through logical connectives. */
21457:         bool cond = inCond && (pn->pn_type == TOK_OR || pn->pn_type == TOK_AND);
21457: 
    1:         /* Save the list head in pn1 for later use. */
    1:         for (pn1 = pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
21457:             if (!js_FoldConstants(cx, pn2, tc, cond))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
21457:       }
    1: 
    1:       case PN_TERNARY:
    1:         /* Any kid may be null (e.g. for (;;)). */
    1:         pn1 = pn->pn_kid1;
    1:         pn2 = pn->pn_kid2;
    1:         pn3 = pn->pn_kid3;
20902:         if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_type == TOK_IF))
    1:             return JS_FALSE;
20902:         if (pn2) {
20902:             if (!js_FoldConstants(cx, pn2, tc, pn->pn_type == TOK_FORHEAD))
    1:                 return JS_FALSE;
20902:             if (pn->pn_type == TOK_FORHEAD && pn2->pn_op == JSOP_TRUE) {
20902:                 RecycleTree(pn2, tc);
20902:                 pn->pn_kid2 = NULL;
20902:             }
20902:         }
    1:         if (pn3 && !js_FoldConstants(cx, pn3, tc))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_BINARY:
    1:         pn1 = pn->pn_left;
    1:         pn2 = pn->pn_right;
20902: 
20902:         /* Propagate inCond through logical connectives. */
20909:         if (pn->pn_type == TOK_OR || pn->pn_type == TOK_AND) {
20902:             if (!js_FoldConstants(cx, pn1, tc, inCond))
    1:                 return JS_FALSE;
20902:             if (!js_FoldConstants(cx, pn2, tc, inCond))
20902:                 return JS_FALSE;
20902:             break;
20902:         }
20902: 
20902:         /* First kid may be null (for default case in switch). */
20902:         if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_type == TOK_WHILE))
20902:             return JS_FALSE;
20902:         if (!js_FoldConstants(cx, pn2, tc, pn->pn_type == TOK_DO))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_UNARY:
    1:         /* Our kid may be null (e.g. return; vs. return e;). */
    1:         pn1 = pn->pn_kid;
20910:         if (pn1 &&
20910:             !js_FoldConstants(cx, pn1, tc,
20910:                               (inCond && pn->pn_type == TOK_RP) ||
20910:                               pn->pn_op == JSOP_NOT)) {
    1:             return JS_FALSE;
20910:         }
    1:         break;
    1: 
    1:       case PN_NAME:
    1:         /*
    1:          * Skip pn1 down along a chain of dotted member expressions to avoid
    1:          * excessive recursion.  Our only goal here is to fold constants (if
    1:          * any) in the primary expression operand to the left of the first
    1:          * dot in the chain.
    1:          */
27012:         if (!pn->pn_used) {
    1:             pn1 = pn->pn_expr;
27012:             while (pn1 && pn1->pn_arity == PN_NAME && !pn1->pn_used)
    1:                 pn1 = pn1->pn_expr;
    1:             if (pn1 && !js_FoldConstants(cx, pn1, tc))
    1:                 return JS_FALSE;
27012:         }
27012:         break;
27012: 
27012:       case PN_NAMESET:
27012:         pn1 = pn->pn_tree;
27012:         if (!js_FoldConstants(cx, pn1, tc))
27012:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_NULLARY:
    1:         break;
    1:     }
    1: 
    1:     switch (pn->pn_type) {
    1:       case TOK_IF:
    1:         if (ContainsStmt(pn2, TOK_VAR) || ContainsStmt(pn3, TOK_VAR))
    1:             break;
    1:         /* FALL THROUGH */
    1: 
    1:       case TOK_HOOK:
    1:         /* Reduce 'if (C) T; else E' into T for true C, E for false. */
    1:         while (pn1->pn_type == TOK_RP)
    1:             pn1 = pn1->pn_kid;
    1:         switch (pn1->pn_type) {
    1:           case TOK_NUMBER:
  207:             if (pn1->pn_dval == 0 || JSDOUBLE_IS_NaN(pn1->pn_dval))
    1:                 pn2 = pn3;
    1:             break;
    1:           case TOK_STRING:
    1:             if (JSSTRING_LENGTH(ATOM_TO_STRING(pn1->pn_atom)) == 0)
    1:                 pn2 = pn3;
    1:             break;
    1:           case TOK_PRIMARY:
    1:             if (pn1->pn_op == JSOP_TRUE)
    1:                 break;
    1:             if (pn1->pn_op == JSOP_FALSE || pn1->pn_op == JSOP_NULL) {
    1:                 pn2 = pn3;
    1:                 break;
    1:             }
    1:             /* FALL THROUGH */
    1:           default:
    1:             /* Early return to dodge common code that copies pn2 to pn. */
    1:             return JS_TRUE;
    1:         }
    1: 
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577:         /* Don't fold a trailing |if (0)| in a generator expression. */
 1577:         if (!pn2 && (tc->flags & TCF_GENEXP_LAMBDA))
 1577:             break;
 1577: #endif
 1577: 
    1:         if (pn2) {
    1:             /*
    1:              * pn2 is the then- or else-statement subtree to compile.  Take
    1:              * care not to expose an object initialiser, which would be parsed
    1:              * as a block, to the Statement parser via eval(uneval(e)) where e
    1:              * is '1 ? {p:2, q:3}[i] : r;' or the like.
    1:              */
    1:             if (pn->pn_type == TOK_HOOK && StartsWith(pn2, TOK_RC)) {
    1:                 pn->pn_type = TOK_RP;
    1:                 pn->pn_arity = PN_UNARY;
    1:                 pn->pn_kid = pn2;
14190:                 if (pn3 && pn3 != pn2)
14190:                     RecycleTree(pn3, tc);
14190:                 break;
14190:             }
27012:             if (!pn2->pn_defn)
27012:                 pn->become(pn2);
    1:         }
    1:         if (!pn2 || (pn->pn_type == TOK_SEMI && !pn->pn_kid)) {
    1:             /*
    1:              * False condition and no else, or an empty then-statement was
    1:              * moved up over pn.  Either way, make pn an empty block (not an
    1:              * empty statement, which does not decompile, even when labeled).
    1:              * NB: pn must be a TOK_IF as TOK_HOOK can never have a null kid
    1:              * or an empty statement for a child.
    1:              */
    1:             pn->pn_type = TOK_LC;
    1:             pn->pn_arity = PN_LIST;
27012:             pn->makeEmpty();
    1:         }
    1:         RecycleTree(pn2, tc);
    1:         if (pn3 && pn3 != pn2)
    1:             RecycleTree(pn3, tc);
    1:         break;
    1: 
20902:       case TOK_OR:
20905:       case TOK_AND:
20902:         if (inCond) {
20905:             if (pn->pn_arity == PN_LIST) {
20905:                 JSParseNode **pnp = &pn->pn_head;
20905:                 JS_ASSERT(*pnp == pn1);
20905:                 do {
20905:                     int cond = Boolish(pn1);
20905:                     if (cond == (pn->pn_type == TOK_OR)) {
20905:                         for (pn2 = pn1->pn_next; pn2; pn2 = pn3) {
20905:                             pn3 = pn2->pn_next;
20905:                             RecycleTree(pn2, tc);
20905:                             --pn->pn_count;
20905:                         }
20905:                         pn1->pn_next = NULL;
20905:                         break;
20905:                     }
20905:                     if (cond != -1) {
20905:                         JS_ASSERT(cond == (pn->pn_type == TOK_AND));
20905:                         if (pn->pn_count == 1)
20905:                             break;
20905:                         *pnp = pn1->pn_next;
20905:                         RecycleTree(pn1, tc);
20905:                         --pn->pn_count;
20905:                     } else {
20905:                         pnp = &pn1->pn_next;
20905:                     }
20905:                 } while ((pn1 = *pnp) != NULL);
20905: 
20905:                 // We may have to change arity from LIST to BINARY.
20911:                 pn1 = pn->pn_head;
20905:                 if (pn->pn_count == 2) {
20905:                     pn2 = pn1->pn_next;
20905:                     pn1->pn_next = NULL;
20905:                     JS_ASSERT(!pn2->pn_next);
20905:                     pn->pn_arity = PN_BINARY;
20905:                     pn->pn_left = pn1;
20905:                     pn->pn_right = pn2;
20905:                 } else if (pn->pn_count == 1) {
27012:                     pn->become(pn1);
20905:                     RecycleTree(pn1, tc);
20905:                 }
20905:             } else {
20905:                 int cond = Boolish(pn1);
20905:                 if (cond == (pn->pn_type == TOK_OR)) {
20902:                     RecycleTree(pn2, tc);
27012:                     pn->become(pn1);
20905:                 } else if (cond != -1) {
20905:                     JS_ASSERT(cond == (pn->pn_type == TOK_AND));
20902:                     RecycleTree(pn1, tc);
27012:                     pn->become(pn2);
20902:                 }
20902:             }
20902:         }
20902:         break;
20902: 
    1:       case TOK_ASSIGN:
    1:         /*
    1:          * Compound operators such as *= should be subject to folding, in case
    1:          * the left-hand side is constant, and so that the decompiler produces
    1:          * the same string that you get from decompiling a script or function
    1:          * compiled from that same string.  As with +, += is special.
    1:          */
    1:         if (pn->pn_op == JSOP_NOP)
    1:             break;
    1:         if (pn->pn_op != JSOP_ADD)
    1:             goto do_binary_op;
    1:         /* FALL THROUGH */
    1: 
    1:       case TOK_PLUS:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             size_t length, length2;
    1:             jschar *chars;
    1:             JSString *str, *str2;
    1: 
    1:             /*
    1:              * Any string literal term with all others number or string means
    1:              * this is a concatenation.  If any term is not a string or number
    1:              * literal, we can't fold.
    1:              */
    1:             JS_ASSERT(pn->pn_count > 2);
27012:             if (pn->pn_xflags & PNX_CANTFOLD)
    1:                 return JS_TRUE;
27012:             if (pn->pn_xflags != PNX_STRCAT)
    1:                 goto do_binary_op;
    1: 
    1:             /* Ok, we're concatenating: convert non-string constant operands. */
    1:             length = 0;
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 if (!FoldType(cx, pn2, TOK_STRING))
    1:                     return JS_FALSE;
    1:                 /* XXX fold only if all operands convert to string */
    1:                 if (pn2->pn_type != TOK_STRING)
    1:                     return JS_TRUE;
10444:                 length += JSFLATSTR_LENGTH(ATOM_TO_STRING(pn2->pn_atom));
    1:             }
    1: 
    1:             /* Allocate a new buffer and string descriptor for the result. */
    1:             chars = (jschar *) JS_malloc(cx, (length + 1) * sizeof(jschar));
    1:             if (!chars)
    1:                 return JS_FALSE;
 4718:             str = js_NewString(cx, chars, length);
    1:             if (!str) {
    1:                 JS_free(cx, chars);
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             /* Fill the buffer, advancing chars and recycling kids as we go. */
    1:             for (pn2 = pn1; pn2; pn2 = RecycleTree(pn2, tc)) {
    1:                 str2 = ATOM_TO_STRING(pn2->pn_atom);
10444:                 length2 = JSFLATSTR_LENGTH(str2);
10444:                 js_strncpy(chars, JSFLATSTR_CHARS(str2), length2);
    1:                 chars += length2;
    1:             }
    1:             *chars = 0;
    1: 
    1:             /* Atomize the result string and mutate pn to refer to it. */
    1:             pn->pn_atom = js_AtomizeString(cx, str, 0);
    1:             if (!pn->pn_atom)
    1:                 return JS_FALSE;
    1:             pn->pn_type = TOK_STRING;
    1:             pn->pn_op = JSOP_STRING;
    1:             pn->pn_arity = PN_NULLARY;
    1:             break;
    1:         }
    1: 
    1:         /* Handle a binary string concatenation. */
    1:         JS_ASSERT(pn->pn_arity == PN_BINARY);
    1:         if (pn1->pn_type == TOK_STRING || pn2->pn_type == TOK_STRING) {
    1:             JSString *left, *right, *str;
    1: 
    1:             if (!FoldType(cx, (pn1->pn_type != TOK_STRING) ? pn1 : pn2,
    1:                           TOK_STRING)) {
    1:                 return JS_FALSE;
    1:             }
    1:             if (pn1->pn_type != TOK_STRING || pn2->pn_type != TOK_STRING)
    1:                 return JS_TRUE;
    1:             left = ATOM_TO_STRING(pn1->pn_atom);
    1:             right = ATOM_TO_STRING(pn2->pn_atom);
    1:             str = js_ConcatStrings(cx, left, right);
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             pn->pn_atom = js_AtomizeString(cx, str, 0);
    1:             if (!pn->pn_atom)
    1:                 return JS_FALSE;
    1:             pn->pn_type = TOK_STRING;
    1:             pn->pn_op = JSOP_STRING;
    1:             pn->pn_arity = PN_NULLARY;
    1:             RecycleTree(pn1, tc);
    1:             RecycleTree(pn2, tc);
    1:             break;
    1:         }
    1: 
    1:         /* Can't concatenate string literals, let's try numbers. */
    1:         goto do_binary_op;
    1: 
    1:       case TOK_STAR:
    1:       case TOK_SHOP:
    1:       case TOK_MINUS:
    1:       case TOK_DIVOP:
    1:       do_binary_op:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             JS_ASSERT(pn->pn_count > 2);
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 if (!FoldType(cx, pn2, TOK_NUMBER))
    1:                     return JS_FALSE;
    1:             }
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 /* XXX fold only if all operands convert to number */
    1:                 if (pn2->pn_type != TOK_NUMBER)
    1:                     break;
    1:             }
    1:             if (!pn2) {
 3164:                 JSOp op = PN_OP(pn);
    1: 
    1:                 pn2 = pn1->pn_next;
    1:                 pn3 = pn2->pn_next;
    1:                 if (!FoldBinaryNumeric(cx, op, pn1, pn2, pn, tc))
    1:                     return JS_FALSE;
    1:                 while ((pn2 = pn3) != NULL) {
    1:                     pn3 = pn2->pn_next;
    1:                     if (!FoldBinaryNumeric(cx, op, pn, pn2, pn, tc))
    1:                         return JS_FALSE;
    1:                 }
    1:             }
    1:         } else {
    1:             JS_ASSERT(pn->pn_arity == PN_BINARY);
    1:             if (!FoldType(cx, pn1, TOK_NUMBER) ||
    1:                 !FoldType(cx, pn2, TOK_NUMBER)) {
    1:                 return JS_FALSE;
    1:             }
    1:             if (pn1->pn_type == TOK_NUMBER && pn2->pn_type == TOK_NUMBER) {
 3164:                 if (!FoldBinaryNumeric(cx, PN_OP(pn), pn1, pn2, pn, tc))
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1: 
    1:       case TOK_UNARYOP:
    1:         while (pn1->pn_type == TOK_RP)
    1:             pn1 = pn1->pn_kid;
    1:         if (pn1->pn_type == TOK_NUMBER) {
    1:             jsdouble d;
    1: 
    1:             /* Operate on one numeric constant. */
    1:             d = pn1->pn_dval;
    1:             switch (pn->pn_op) {
    1:               case JSOP_BITNOT:
 9613:                 d = ~js_DoubleToECMAInt32(d);
    1:                 break;
    1: 
    1:               case JSOP_NEG:
    1: #ifdef HPUX
    1:                 /*
    1:                  * Negation of a zero doesn't produce a negative
    1:                  * zero on HPUX. Perform the operation by bit
    1:                  * twiddling.
    1:                  */
    1:                 JSDOUBLE_HI32(d) ^= JSDOUBLE_HI32_SIGNBIT;
    1: #else
    1:                 d = -d;
    1: #endif
    1:                 break;
    1: 
    1:               case JSOP_POS:
    1:                 break;
    1: 
    1:               case JSOP_NOT:
    1:                 pn->pn_type = TOK_PRIMARY;
  207:                 pn->pn_op = (d == 0 || JSDOUBLE_IS_NaN(d)) ? JSOP_TRUE : JSOP_FALSE;
    1:                 pn->pn_arity = PN_NULLARY;
    1:                 /* FALL THROUGH */
    1: 
    1:               default:
    1:                 /* Return early to dodge the common TOK_NUMBER code. */
    1:                 return JS_TRUE;
    1:             }
    1:             pn->pn_type = TOK_NUMBER;
 3328:             pn->pn_op = JSOP_DOUBLE;
    1:             pn->pn_arity = PN_NULLARY;
    1:             pn->pn_dval = d;
    1:             RecycleTree(pn1, tc);
20918:         } else if (pn1->pn_type == TOK_PRIMARY) {
20918:             if (pn->pn_op == JSOP_NOT &&
20918:                 (pn1->pn_op == JSOP_TRUE ||
20918:                  pn1->pn_op == JSOP_FALSE)) {
27012:                 pn->become(pn1);
20918:                 pn->pn_op = (pn->pn_op == JSOP_TRUE) ? JSOP_FALSE : JSOP_TRUE;
20918:                 RecycleTree(pn1, tc);
20918:             }
    1:         }
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_XMLELEM:
    1:       case TOK_XMLLIST:
    1:       case TOK_XMLPTAGC:
    1:       case TOK_XMLSTAGO:
    1:       case TOK_XMLETAGO:
    1:       case TOK_XMLNAME:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             JS_ASSERT(pn->pn_type == TOK_XMLLIST || pn->pn_count != 0);
    1:             if (!FoldXMLConstants(cx, pn, tc))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
    1: 
    1:       case TOK_AT:
    1:         if (pn1->pn_type == TOK_XMLNAME) {
    1:             jsval v;
27012:             JSObjectBox *xmlbox;
    1: 
    1:             v = ATOM_KEY(pn1->pn_atom);
    1:             if (!js_ToAttributeName(cx, &v))
    1:                 return JS_FALSE;
    1:             JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));
 3235: 
27012:             xmlbox = tc->compiler->newObjectBox(JSVAL_TO_OBJECT(v));
27012:             if (!xmlbox)
    1:                 return JS_FALSE;
    1: 
    1:             pn->pn_type = TOK_XMLNAME;
    1:             pn->pn_op = JSOP_OBJECT;
    1:             pn->pn_arity = PN_NULLARY;
27012:             pn->pn_objbox = xmlbox;
    1:             RecycleTree(pn1, tc);
    1:         }
    1:         break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:       default:;
    1:     }
    1: 
20902:     if (inCond) {
20902:         int cond = Boolish(pn);
20902:         if (cond >= 0) {
27012:             switch (pn->pn_arity) {
27012:               case PN_LIST:
20902:                 pn2 = pn->pn_head;
20902:                 do {
20902:                     pn3 = pn2->pn_next;
20902:                     RecycleTree(pn2, tc);
20902:                 } while ((pn2 = pn3) != NULL);
27012:                 break;
27012:               case PN_FUNC:
27012:                 RecycleFuncNameKids(pn, tc);
27012:                 break;
27012:               case PN_NULLARY:
27012:                 break;
27012:               default:
27012:                 JS_NOT_REACHED("unhandled arity");
20902:             }
20902:             pn->pn_type = TOK_PRIMARY;
20902:             pn->pn_op = cond ? JSOP_TRUE : JSOP_FALSE;
20902:             pn->pn_arity = PN_NULLARY;
20902:         }
20902:     }
20902: 
    1:     return JS_TRUE;
    1: }
