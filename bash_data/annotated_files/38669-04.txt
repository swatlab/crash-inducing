35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Ben Turner <bent.mozilla@gmail.com>.
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
38045: #ifdef MOZ_WIDGET_QT
38045: #include <QApplication>
38045: #endif
38045: 
35893: #include "mozilla/plugins/PluginModuleChild.h"
35740: 
37598: #ifdef MOZ_WIDGET_GTK2
35746: #include <gtk/gtk.h>
35746: #endif
35746: 
35740: #include "nsILocalFile.h"
35740: 
36078: #include "pratom.h"
35740: #include "nsDebug.h"
35740: #include "nsCOMPtr.h"
35740: #include "nsPluginsDir.h"
36140: #include "nsXULAppAPI.h"
35740: 
35893: #include "mozilla/plugins/PluginInstanceChild.h"
35919: #include "mozilla/plugins/StreamNotifyChild.h"
35919: #include "mozilla/plugins/BrowserStreamChild.h"
35938: #include "mozilla/plugins/PluginStreamChild.h"
37884: #include "mozilla/plugins/PluginThreadChild.h"
35740: 
36125: #include "nsNPAPIPlugin.h"
36125: 
35913: using mozilla::ipc::NPRemoteIdentifier;
35740: 
35913: using namespace mozilla::plugins;
35913: 
35913: namespace {
35913: PluginModuleChild* gInstance = nsnull;
38045: #ifdef MOZ_WIDGET_QT
38045: static QApplication *gQApp = nsnull;
38045: #endif
35913: }
35740: 
35940: 
35893: PluginModuleChild::PluginModuleChild() :
35746:     mLibrary(0),
35746:     mInitializeFunc(0),
35746:     mShutdownFunc(0)
35746: #ifdef OS_WIN
35746:   , mGetEntryPointsFunc(0)
35746: #endif
35740: //  ,mNextInstanceId(0)
35740: {
35925:     NS_ASSERTION(!gInstance, "Something terribly wrong here!");
35740:     memset(&mFunctions, 0, sizeof(mFunctions));
35740:     memset(&mSavedData, 0, sizeof(mSavedData));
35913:     gInstance = this;
35740: }
35740: 
35893: PluginModuleChild::~PluginModuleChild()
35740: {
35925:     NS_ASSERTION(gInstance == this, "Something terribly wrong here!");
35740:     if (mLibrary) {
35740:         PR_UnloadLibrary(mLibrary);
35740:     }
38045: #ifdef MOZ_WIDGET_QT
38045:     if (gQApp)
38045:         delete gQApp;
38045:     gQApp = nsnull;
38045: #endif
35913:     gInstance = nsnull;
35740: }
35740: 
35925: // static
35925: PluginModuleChild*
35925: PluginModuleChild::current()
35925: {
35925:     NS_ASSERTION(gInstance, "Null instance!");
35925:     return gInstance;
35925: }
35925: 
35740: bool
35893: PluginModuleChild::Init(const std::string& aPluginFilename,
36016:                         base::ProcessHandle aParentProcessHandle,
35740:                         MessageLoop* aIOLoop,
35740:                         IPC::Channel* aChannel)
35740: {
37099:     PLUGIN_LOG_DEBUG_METHOD;
35740: 
35740:     NS_ASSERTION(aChannel, "need a channel");
35740: 
35925:     if (!mObjectMap.Init()) {
35925:        NS_WARNING("Failed to initialize object hashtable!");
35925:        return false;
35925:     }
35925: 
35746:     if (!InitGraphics())
35746:         return false;
35746: 
35740:     nsCString filename;
35740:     filename = aPluginFilename.c_str();
35740:     nsCOMPtr<nsILocalFile> pluginFile;
35740:     NS_NewNativeLocalFile(filename,
35740:                           PR_TRUE,
35740:                           getter_AddRefs(pluginFile));
35740: 
35740:     PRBool exists;
35740:     pluginFile->Exists(&exists);
35740:     NS_ASSERTION(exists, "plugin file ain't there");
35740: 
35740:     nsCOMPtr<nsIFile> pluginIfile;
35740:     pluginIfile = do_QueryInterface(pluginFile);
35740: 
35740:     nsPluginFile lib(pluginIfile);
35740: 
35746:     nsresult rv = lib.LoadPlugin(mLibrary);
35740:     NS_ASSERTION(NS_OK == rv, "trouble with mPluginFile");
35740:     NS_ASSERTION(mLibrary, "couldn't open shared object");
35740: 
36016:     if (!Open(aChannel, aParentProcessHandle, aIOLoop))
35740:         return false;
35740: 
35740:     memset((void*) &mFunctions, 0, sizeof(mFunctions));
35740:     mFunctions.size = sizeof(mFunctions);
35740: 
36039:     // TODO: use PluginPRLibrary here
35740: 
35746: #if defined(OS_LINUX)
35740:     mShutdownFunc =
35740:         (NP_PLUGINSHUTDOWN) PR_FindFunctionSymbol(mLibrary, "NP_Shutdown");
35740: 
35740:     // create the new plugin handler
35740: 
35740:     mInitializeFunc =
35740:         (NP_PLUGINUNIXINIT) PR_FindFunctionSymbol(mLibrary, "NP_Initialize");
35740:     NS_ASSERTION(mInitializeFunc, "couldn't find NP_Initialize()");
35740: 
35746: #elif defined(OS_WIN)
35746:     mShutdownFunc =
35746:         (NP_PLUGINSHUTDOWN)PR_FindFunctionSymbol(mLibrary, "NP_Shutdown");
35740: 
35746:     mGetEntryPointsFunc =
35746:         (NP_GETENTRYPOINTS)PR_FindSymbol(mLibrary, "NP_GetEntryPoints");
35746:     NS_ENSURE_TRUE(mGetEntryPointsFunc, false);
35746: 
35746:     mInitializeFunc =
35746:         (NP_PLUGININIT)PR_FindFunctionSymbol(mLibrary, "NP_Initialize");
35746:     NS_ENSURE_TRUE(mInitializeFunc, false);
36069: #elif defined(OS_MACOSX)
36069: #  warning IMPLEMENT ME
36069: 
35740: #else
35740: 
35740: #  error Please copy the initialization code from nsNPAPIPlugin.cpp
35740: 
35740: #endif
35746:     return true;
35746: }
35746: 
37621: #if defined(MOZ_WIDGET_GTK2)
37346: typedef void (*GObjectDisposeFn)(GObject*);
37347: typedef void (*GtkPlugEmbeddedFn)(GtkPlug*);
37346: 
37346: static GObjectDisposeFn real_gtk_plug_dispose;
37347: static GtkPlugEmbeddedFn real_gtk_plug_embedded;
37346: 
37346: static void
37346: undo_bogus_unref(gpointer data, GObject* object, gboolean is_last_ref) {
37346:     if (!is_last_ref) // recursion in g_object_ref
37346:         return;
37346: 
37346:     g_object_ref(object);
37346: }
37346: 
37346: static void
37346: wrap_gtk_plug_dispose(GObject* object) {
37346:     // Work around Flash Player bug described in bug 538914.
37346:     //
37346:     // This function is called during gtk_widget_destroy and/or before
37346:     // the object's last reference is removed.  A reference to the
37346:     // object is held during the call so the ref count should not drop
37346:     // to zero.  However, Flash Player tries to destroy the GtkPlug
37346:     // using g_object_unref instead of gtk_widget_destroy.  The
37346:     // reference that Flash is removing actually belongs to the
37346:     // GtkPlug.  During real_gtk_plug_dispose, the GtkPlug removes its
37346:     // reference.
37346:     //
37346:     // A toggle ref is added to prevent premature deletion of the object
37346:     // caused by Flash Player's extra unref, and to detect when there are
37346:     // unexpectedly no other references.
37346:     g_object_add_toggle_ref(object, undo_bogus_unref, NULL);
37346:     (*real_gtk_plug_dispose)(object);
37346:     g_object_remove_toggle_ref(object, undo_bogus_unref, NULL);
37346: }
37347: 
37347: static void
37347: wrap_gtk_plug_embedded(GtkPlug* plug) {
37347:     GdkWindow* socket_window = plug->socket_window;
37347:     if (socket_window &&
37347:         g_object_get_data(G_OBJECT(socket_window),
37347:                           "moz-existed-before-set-window")) {
37347:         // Add missing reference for
37347:         // https://bugzilla.gnome.org/show_bug.cgi?id=607061
37347:         g_object_ref(socket_window);
37347:     }
37347: 
37347:     if (*real_gtk_plug_embedded) {
37347:         (*real_gtk_plug_embedded)(plug);
37347:     }
37347: }
37346: #endif
37346: 
35746: bool
35893: PluginModuleChild::InitGraphics()
35746: {
35746:     // FIXME/cjones: is this the place for this?
37598: #if defined(MOZ_WIDGET_GTK2)
37820:     // Work around plugins that don't interact well with GDK
37820:     // client-side windows.
37820:     PR_SetEnv("GDK_NATIVE_WINDOWS=1");
37820: 
35746:     gtk_init(0, 0);
37346: 
37346:     // GtkPlug is a static class so will leak anyway but this ref makes sure.
37346:     gpointer gtk_plug_class = g_type_class_ref(GTK_TYPE_PLUG);
37347: 
37346:     // The dispose method is a good place to hook into the destruction process
37346:     // because the reference count should be 1 the last time dispose is
37346:     // called.  (Toggle references wouldn't detect if the reference count
37346:     // might be higher.)
37346:     GObjectDisposeFn* dispose = &G_OBJECT_CLASS(gtk_plug_class)->dispose;
37346:     NS_ABORT_IF_FALSE(*dispose != wrap_gtk_plug_dispose,
37346:                       "InitGraphics called twice");
37346:     real_gtk_plug_dispose = *dispose;
37346:     *dispose = wrap_gtk_plug_dispose;
37347: 
37347:     GtkPlugEmbeddedFn* embedded = &GTK_PLUG_CLASS(gtk_plug_class)->embedded;
37347:     real_gtk_plug_embedded = *embedded;
37347:     *embedded = wrap_gtk_plug_embedded;
37621: #elif defined(MOZ_WIDGET_QT)
38045:     if (!qApp)
38045:         gQApp = new QApplication(0, NULL);
35746: #else
35746:     // may not be necessary on all platforms
35746: #endif
35746: 
35746:     return true;
35740: }
35740: 
36039: bool
36039: PluginModuleChild::AnswerNP_Shutdown(NPError *rv)
36039: {
36039:     AssertPluginThread();
36039: 
36140:     // the PluginModuleParent shuts down this process after this RPC
36140:     // call pops off its stack
36039: 
36064:     *rv = mShutdownFunc ? mShutdownFunc() : NPERR_NO_ERROR;
36140: 
36140:     // weakly guard against re-entry after NP_Shutdown
36140:     memset(&mFunctions, 0, sizeof(mFunctions));
36140: 
36039:     return true;
36039: }
36039: 
35740: void
36140: PluginModuleChild::ActorDestroy(ActorDestroyReason why)
36140: {
36140:     // doesn't matter why we're being destroyed; it's up to us to
36140:     // initiate (clean) shutdown
36140:     XRE_ShutdownChildProcess();
36140: }
36140: 
36140: void
35893: PluginModuleChild::CleanUp()
35740: {
35740: }
35740: 
36099: const char*
36099: PluginModuleChild::GetUserAgent()
36099: {
36099:     if (!CallNPN_UserAgent(&mUserAgent))
36099:         return NULL;
36099: 
36099:     return NullableStringGet(mUserAgent);
36099: }
36099: 
35925: bool
37477: PluginModuleChild::RegisterActorForNPObject(NPObject* aObject,
35925:                                             PluginScriptableObjectChild* aActor)
35925: {
35971:     AssertPluginThread();
35925:     NS_ASSERTION(mObjectMap.IsInitialized(), "Not initialized!");
35925:     NS_ASSERTION(aObject && aActor, "Null pointer!");
37477: 
37477:     NPObjectData* d = mObjectMap.GetEntry(aObject);
37477:     if (!d) {
37477:         NS_ERROR("NPObject not in object table");
37477:         return false;
37477:     }
37477: 
37477:     d->actor = aActor;
37477:     return true;
35925: }
35925: 
35925: void
37477: PluginModuleChild::UnregisterActorForNPObject(NPObject* aObject)
35925: {
35971:     AssertPluginThread();
35925:     NS_ASSERTION(mObjectMap.IsInitialized(), "Not initialized!");
35925:     NS_ASSERTION(aObject, "Null pointer!");
37477: 
37477:     mObjectMap.GetEntry(aObject)->actor = NULL;
35925: }
35925: 
35925: PluginScriptableObjectChild*
35925: PluginModuleChild::GetActorForNPObject(NPObject* aObject)
35925: {
35971:     AssertPluginThread();
35925:     NS_ASSERTION(mObjectMap.IsInitialized(), "Not initialized!");
35925:     NS_ASSERTION(aObject, "Null pointer!");
37477: 
37477:     NPObjectData* d = mObjectMap.GetEntry(aObject);
37477:     if (!d) {
37477:         NS_ERROR("Plugin using object not created with NPN_CreateObject?");
37477:         return NULL;
37477:     }
37477: 
37477:     return d->actor;
35925: }
35740: 
36073: #ifdef DEBUG
36073: bool
37311: PluginModuleChild::NPObjectIsRegistered(NPObject* aObject)
37311: {
37477:     return !!mObjectMap.GetEntry(aObject);
36073: }
36073: #endif
36073: 
35740: //-----------------------------------------------------------------------------
35740: // FIXME/cjones: just getting this out of the way for the moment ...
35740: 
36125: namespace mozilla {
36125: namespace plugins {
36125: namespace child {
36125: 
35740: static NPError NP_CALLBACK
35740: _requestread(NPStream *pstream, NPByteRange *rangeList);
35740: 
35740: static NPError NP_CALLBACK
35740: _geturlnotify(NPP aNPP, const char* relativeURL, const char* target,
35740:               void* notifyData);
35740: 
35740: static NPError NP_CALLBACK
35740: _getvalue(NPP aNPP, NPNVariable variable, void *r_value);
35740: 
35740: static NPError NP_CALLBACK
35740: _setvalue(NPP aNPP, NPPVariable variable, void *r_value);
35740: 
35740: static NPError NP_CALLBACK
35740: _geturl(NPP aNPP, const char* relativeURL, const char* target);
35740: 
35740: static NPError NP_CALLBACK
35740: _posturlnotify(NPP aNPP, const char* relativeURL, const char *target,
35740:                uint32_t len, const char *buf, NPBool file, void* notifyData);
35740: 
35740: static NPError NP_CALLBACK
35740: _posturl(NPP aNPP, const char* relativeURL, const char *target, uint32_t len,
35740:          const char *buf, NPBool file);
35740: 
35740: static NPError NP_CALLBACK
35740: _newstream(NPP aNPP, NPMIMEType type, const char* window, NPStream** pstream);
35740: 
35740: static int32_t NP_CALLBACK
35740: _write(NPP aNPP, NPStream *pstream, int32_t len, void *buffer);
35740: 
35740: static NPError NP_CALLBACK
35740: _destroystream(NPP aNPP, NPStream *pstream, NPError reason);
35740: 
35740: static void NP_CALLBACK
35740: _status(NPP aNPP, const char *message);
35740: 
35740: static void NP_CALLBACK
35740: _memfree (void *ptr);
35740: 
35740: static uint32_t NP_CALLBACK
35740: _memflush(uint32_t size);
35740: 
35740: static void NP_CALLBACK
35740: _reloadplugins(NPBool reloadPages);
35740: 
35740: static void NP_CALLBACK
35740: _invalidaterect(NPP aNPP, NPRect *invalidRect);
35740: 
35740: static void NP_CALLBACK
35740: _invalidateregion(NPP aNPP, NPRegion invalidRegion);
35740: 
35740: static void NP_CALLBACK
35740: _forceredraw(NPP aNPP);
35740: 
35740: static const char* NP_CALLBACK
35740: _useragent(NPP aNPP);
35740: 
35740: static void* NP_CALLBACK
35740: _memalloc (uint32_t size);
35740: 
35740: // Deprecated entry points for the old Java plugin.
35740: static void* NP_CALLBACK /* OJI type: JRIEnv* */
35740: _getjavaenv(void);
35740: 
35740: // Deprecated entry points for the old Java plugin.
35740: static void* NP_CALLBACK /* OJI type: jref */
35740: _getjavapeer(NPP aNPP);
35740: 
35740: static NPIdentifier NP_CALLBACK
35740: _getstringidentifier(const NPUTF8* name);
35740: 
35740: static void NP_CALLBACK
35740: _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
35740:                       NPIdentifier *identifiers);
35740: 
35740: static bool NP_CALLBACK
35740: _identifierisstring(NPIdentifier identifiers);
35740: 
35740: static NPIdentifier NP_CALLBACK
35740: _getintidentifier(int32_t intid);
35740: 
35740: static NPUTF8* NP_CALLBACK
35740: _utf8fromidentifier(NPIdentifier identifier);
35740: 
35740: static int32_t NP_CALLBACK
35740: _intfromidentifier(NPIdentifier identifier);
35740: 
35740: static bool NP_CALLBACK
35740: _invoke(NPP aNPP, NPObject* npobj, NPIdentifier method, const NPVariant *args,
35740:         uint32_t argCount, NPVariant *result);
35740: 
35740: static bool NP_CALLBACK
35740: _invokedefault(NPP aNPP, NPObject* npobj, const NPVariant *args,
35740:                uint32_t argCount, NPVariant *result);
35740: 
35740: static bool NP_CALLBACK
35740: _evaluate(NPP aNPP, NPObject* npobj, NPString *script, NPVariant *result);
35740: 
35740: static bool NP_CALLBACK
35740: _getproperty(NPP aNPP, NPObject* npobj, NPIdentifier property,
35740:              NPVariant *result);
35740: 
35740: static bool NP_CALLBACK
35740: _setproperty(NPP aNPP, NPObject* npobj, NPIdentifier property,
35740:              const NPVariant *value);
35740: 
35740: static bool NP_CALLBACK
35740: _removeproperty(NPP aNPP, NPObject* npobj, NPIdentifier property);
35740: 
35740: static bool NP_CALLBACK
35740: _hasproperty(NPP aNPP, NPObject* npobj, NPIdentifier propertyName);
35740: 
35740: static bool NP_CALLBACK
35740: _hasmethod(NPP aNPP, NPObject* npobj, NPIdentifier methodName);
35740: 
35740: static bool NP_CALLBACK
35740: _enumerate(NPP aNPP, NPObject *npobj, NPIdentifier **identifier,
35740:            uint32_t *count);
35740: 
35740: static bool NP_CALLBACK
35740: _construct(NPP aNPP, NPObject* npobj, const NPVariant *args,
35740:            uint32_t argCount, NPVariant *result);
35740: 
35740: static void NP_CALLBACK
35740: _releasevariantvalue(NPVariant *variant);
35740: 
35740: static void NP_CALLBACK
35740: _setexception(NPObject* npobj, const NPUTF8 *message);
35740: 
35740: static bool NP_CALLBACK
35740: _pushpopupsenabledstate(NPP aNPP, NPBool enabled);
35740: 
35740: static bool NP_CALLBACK
35740: _poppopupsenabledstate(NPP aNPP);
35740: 
35740: static void NP_CALLBACK
35740: _pluginthreadasynccall(NPP instance, PluginThreadCallback func,
35740:                        void *userData);
35740: 
35956: static NPError NP_CALLBACK
35956: _getvalueforurl(NPP npp, NPNURLVariable variable, const char *url,
35956:                 char **value, uint32_t *len);
35956: 
35956: static NPError NP_CALLBACK
35956: _setvalueforurl(NPP npp, NPNURLVariable variable, const char *url,
35956:                 const char *value, uint32_t len);
35956: 
35956: static NPError NP_CALLBACK
35956: _getauthenticationinfo(NPP npp, const char *protocol,
35956:                        const char *host, int32_t port,
35956:                        const char *scheme, const char *realm,
35956:                        char **username, uint32_t *ulen,
35956:                        char **password, uint32_t *plen);
35956: 
35956: static uint32_t NP_CALLBACK
35956: _scheduletimer(NPP instance, uint32_t interval, NPBool repeat,
35956:                void (*timerFunc)(NPP npp, uint32_t timerID));
35956: 
35956: static void NP_CALLBACK
35956: _unscheduletimer(NPP instance, uint32_t timerID);
35956: 
35956: static NPError NP_CALLBACK
35956: _popupcontextmenu(NPP instance, NPMenu* menu);
35956: 
35956: static NPBool NP_CALLBACK
35956: _convertpoint(NPP instance, 
35956:               double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
35956:               double *destX, double *destY, NPCoordinateSpace destSpace);
35740: 
36125: } /* namespace child */
36125: } /* namespace plugins */
36125: } /* namespace mozilla */
35740: 
35893: const NPNetscapeFuncs PluginModuleChild::sBrowserFuncs = {
35740:     sizeof(sBrowserFuncs),
35740:     (NP_VERSION_MAJOR << 8) + NP_VERSION_MINOR,
36125:     mozilla::plugins::child::_geturl,
36125:     mozilla::plugins::child::_posturl,
36125:     mozilla::plugins::child::_requestread,
36125:     mozilla::plugins::child::_newstream,
36125:     mozilla::plugins::child::_write,
36125:     mozilla::plugins::child::_destroystream,
36125:     mozilla::plugins::child::_status,
36125:     mozilla::plugins::child::_useragent,
36125:     mozilla::plugins::child::_memalloc,
36125:     mozilla::plugins::child::_memfree,
36125:     mozilla::plugins::child::_memflush,
36125:     mozilla::plugins::child::_reloadplugins,
36125:     mozilla::plugins::child::_getjavaenv,
36125:     mozilla::plugins::child::_getjavapeer,
36125:     mozilla::plugins::child::_geturlnotify,
36125:     mozilla::plugins::child::_posturlnotify,
36125:     mozilla::plugins::child::_getvalue,
36125:     mozilla::plugins::child::_setvalue,
36125:     mozilla::plugins::child::_invalidaterect,
36125:     mozilla::plugins::child::_invalidateregion,
36125:     mozilla::plugins::child::_forceredraw,
36125:     mozilla::plugins::child::_getstringidentifier,
36125:     mozilla::plugins::child::_getstringidentifiers,
36125:     mozilla::plugins::child::_getintidentifier,
36125:     mozilla::plugins::child::_identifierisstring,
36125:     mozilla::plugins::child::_utf8fromidentifier,
36125:     mozilla::plugins::child::_intfromidentifier,
37477:     PluginModuleChild::NPN_CreateObject,
37477:     PluginModuleChild::NPN_RetainObject,
37477:     PluginModuleChild::NPN_ReleaseObject,
36125:     mozilla::plugins::child::_invoke,
36125:     mozilla::plugins::child::_invokedefault,
36125:     mozilla::plugins::child::_evaluate,
36125:     mozilla::plugins::child::_getproperty,
36125:     mozilla::plugins::child::_setproperty,
36125:     mozilla::plugins::child::_removeproperty,
36125:     mozilla::plugins::child::_hasproperty,
36125:     mozilla::plugins::child::_hasmethod,
36125:     mozilla::plugins::child::_releasevariantvalue,
36125:     mozilla::plugins::child::_setexception,
36125:     mozilla::plugins::child::_pushpopupsenabledstate,
36125:     mozilla::plugins::child::_poppopupsenabledstate,
36125:     mozilla::plugins::child::_enumerate,
36125:     mozilla::plugins::child::_pluginthreadasynccall,
36125:     mozilla::plugins::child::_construct,
36125:     mozilla::plugins::child::_getvalueforurl,
36125:     mozilla::plugins::child::_setvalueforurl,
36125:     mozilla::plugins::child::_getauthenticationinfo,
36125:     mozilla::plugins::child::_scheduletimer,
36125:     mozilla::plugins::child::_unscheduletimer,
36125:     mozilla::plugins::child::_popupcontextmenu,
36125:     mozilla::plugins::child::_convertpoint
35740: };
35740: 
35919: PluginInstanceChild*
35740: InstCast(NPP aNPP)
35740: {
35968:     NS_ABORT_IF_FALSE(!!(aNPP->ndata), "nil instance");
35919:     return static_cast<PluginInstanceChild*>(aNPP->ndata);
35740: }
35740: 
36125: namespace mozilla {
36125: namespace plugins {
36125: namespace child {
36125: 
35740: NPError NP_CALLBACK
35944: _requestread(NPStream* aStream,
35740:              NPByteRange* aRangeList)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35971: 
35944:     BrowserStreamChild* bs =
35944:         static_cast<BrowserStreamChild*>(static_cast<AStream*>(aStream->ndata));
35944:     bs->EnsureCorrectStream(aStream);
35944:     return bs->NPN_RequestRead(aRangeList);
35740: }
35740: 
35740: NPError NP_CALLBACK
35740: _geturlnotify(NPP aNPP,
35740:               const char* aRelativeURL,
35740:               const char* aTarget,
35740:               void* aNotifyData)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35919: 
35940:     nsCString url = NullableString(aRelativeURL);
36110:     StreamNotifyChild* sn = new StreamNotifyChild(url);
36110: 
35919:     NPError err;
35919:     InstCast(aNPP)->CallPStreamNotifyConstructor(
36110:         sn, url, NullableString(aTarget), false, nsCString(), false, &err);
36110: 
36110:     if (NPERR_NO_ERROR == err) {
36110:         // If NPN_PostURLNotify fails, the parent will immediately send us
36110:         // a PStreamNotifyDestructor, which should not call NPP_URLNotify.
36110:         sn->SetValid(aNotifyData);
36110:     }
36110: 
35919:     return err;
35740: }
35740: 
35740: NPError NP_CALLBACK
35740: _getvalue(NPP aNPP,
35740:           NPNVariable aVariable,
35740:           void* aValue)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
36125: 
36125:     switch (aVariable) {
37886:         // Copied from nsNPAPIPlugin.cpp
37886:         case NPNVToolkit:
37886: #ifdef MOZ_WIDGET_GTK2
37886:             *static_cast<NPNToolkitType*>(aValue) = NPNVGtk2;
37886:             return NPERR_NO_ERROR;
37886: #endif
37886:             return NPERR_GENERIC_ERROR;
37886: 
36125:         case NPNVjavascriptEnabledBool: // Intentional fall-through
36125:         case NPNVasdEnabledBool: // Intentional fall-through
36125:         case NPNVisOfflineBool: // Intentional fall-through
36125:         case NPNVSupportsXEmbedBool: // Intentional fall-through
36125:         case NPNVSupportsWindowless: // Intentional fall-through
36125:         case NPNVprivateModeBool: {
36125:             NPError result;
36125:             bool value;
36125:             PluginModuleChild::current()->
36125:                 CallNPN_GetValue_WithBoolReturn(aVariable, &result, &value);
36125:             *(NPBool*)aValue = value ? true : false;
36125:             return result;
36125:         }
36125: 
36125:         default: {
36125:             if (aNPP) {
35919:                 return InstCast(aNPP)->NPN_GetValue(aVariable, aValue);
35740:             }
35740: 
36125:             NS_WARNING("Null NPP!");
36125:             return NPERR_INVALID_INSTANCE_ERROR;
36125:         }
36125:     }
36125: 
36125:     NS_NOTREACHED("Shouldn't get here!");
36125:     return NPERR_GENERIC_ERROR;
36125: }
35740: 
35740: NPError NP_CALLBACK
35740: _setvalue(NPP aNPP,
35740:           NPPVariable aVariable,
35740:           void* aValue)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35951:     return InstCast(aNPP)->NPN_SetValue(aVariable, aValue);
35740: }
35740: 
35740: NPError NP_CALLBACK
35740: _geturl(NPP aNPP,
35740:         const char* aRelativeURL,
35740:         const char* aTarget)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35971: 
35919:     NPError err;
35940:     InstCast(aNPP)->CallNPN_GetURL(NullableString(aRelativeURL),
35940:                                    NullableString(aTarget), &err);
35919:     return err;
35740: }
35740: 
35740: NPError NP_CALLBACK
35740: _posturlnotify(NPP aNPP,
35740:                const char* aRelativeURL,
35740:                const char* aTarget,
35740:                uint32_t aLength,
35740:                const char* aBuffer,
35740:                NPBool aIsFile,
35740:                void* aNotifyData)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35919: 
36110:     if (!aBuffer)
36110:         return NPERR_INVALID_PARAM;
36110: 
35940:     nsCString url = NullableString(aRelativeURL);
36110:     StreamNotifyChild* sn = new StreamNotifyChild(url);
36110: 
35919:     NPError err;
36110:     InstCast(aNPP)->CallPStreamNotifyConstructor(
36110:         sn, url, NullableString(aTarget), true,
36110:         nsCString(aBuffer, aLength), aIsFile, &err);
35978: 
36110:     if (NPERR_NO_ERROR == err) {
36110:         // If NPN_PostURLNotify fails, the parent will immediately send us
36110:         // a PStreamNotifyDestructor, which should not call NPP_URLNotify.
36110:         sn->SetValid(aNotifyData);
36110:     }
35978: 
35919:     return err;
35740: }
35740: 
35740: NPError NP_CALLBACK
35740: _posturl(NPP aNPP,
35740:          const char* aRelativeURL,
35740:          const char* aTarget,
35740:          uint32_t aLength,
35740:          const char* aBuffer,
35740:          NPBool aIsFile)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35971: 
35919:     NPError err;
35940:     // FIXME what should happen when |aBuffer| is null?
35940:     InstCast(aNPP)->CallNPN_PostURL(NullableString(aRelativeURL),
35940:                                     NullableString(aTarget),
35919:                                     nsDependentCString(aBuffer, aLength),
35919:                                     aIsFile, &err);
35919:     return err;
35740: }
35740: 
35740: NPError NP_CALLBACK
35740: _newstream(NPP aNPP,
35740:            NPMIMEType aMIMEType,
35740:            const char* aWindow,
35740:            NPStream** aStream)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35938:     return InstCast(aNPP)->NPN_NewStream(aMIMEType, aWindow, aStream);
35740: }
35740: 
35740: int32_t NP_CALLBACK
35740: _write(NPP aNPP,
35740:        NPStream* aStream,
35740:        int32_t aLength,
35740:        void* aBuffer)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35971: 
35938:     PluginStreamChild* ps =
35938:         static_cast<PluginStreamChild*>(static_cast<AStream*>(aStream->ndata));
35938:     ps->EnsureCorrectInstance(InstCast(aNPP));
35938:     ps->EnsureCorrectStream(aStream);
35938:     return ps->NPN_Write(aLength, aBuffer);
35740: }
35740: 
35740: NPError NP_CALLBACK
35740: _destroystream(NPP aNPP,
35919:                NPStream* aStream,
35740:                NPError aReason)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35971: 
35919:     PluginInstanceChild* p = InstCast(aNPP);
35938:     AStream* s = static_cast<AStream*>(aStream->ndata);
35938:     if (s->IsBrowserStream()) {
35938:         BrowserStreamChild* bs = static_cast<BrowserStreamChild*>(s);
35919:         bs->EnsureCorrectInstance(p);
38668:         bs->SendNPN_DestroyStream(aReason);
35938:     }
35938:     else {
35938:         PluginStreamChild* ps = static_cast<PluginStreamChild*>(s);
35938:         ps->EnsureCorrectInstance(p);
36138:         PPluginStreamChild::Call__delete__(ps, aReason, false);
35938:     }
35740:     return NPERR_NO_ERROR;
35740: }
35740: 
35740: void NP_CALLBACK
35740: _status(NPP aNPP,
35740:         const char* aMessage)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35740: }
35740: 
35740: void NP_CALLBACK
35740: _memfree(void* aPtr)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35740:     NS_Free(aPtr);
35740: }
35740: 
35740: uint32_t NP_CALLBACK
35740: _memflush(uint32_t aSize)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35740:     return 0;
35740: }
35740: 
35740: void NP_CALLBACK
35740: _reloadplugins(NPBool aReloadPages)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35740: }
35740: 
35740: void NP_CALLBACK
35740: _invalidaterect(NPP aNPP,
35740:                 NPRect* aInvalidRect)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
36835:     InstCast(aNPP)->InvalidateRect(aInvalidRect);
35740: }
35740: 
35740: void NP_CALLBACK
35740: _invalidateregion(NPP aNPP,
35740:                   NPRegion aInvalidRegion)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35958:     // Not implemented in Mozilla.
35740: }
35740: 
35740: void NP_CALLBACK
35740: _forceredraw(NPP aNPP)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35740: }
35740: 
35740: const char* NP_CALLBACK
35740: _useragent(NPP aNPP)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35740: 
36099:     return PluginModuleChild::current()->GetUserAgent();
35740: }
35740: 
35740: void* NP_CALLBACK
35740: _memalloc(uint32_t aSize)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35740:     return NS_Alloc(aSize);
35740: }
35740: 
35740: // Deprecated entry points for the old Java plugin.
35740: void* NP_CALLBACK /* OJI type: JRIEnv* */
35740: _getjavaenv(void)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35740:     return 0;
35740: }
35740: 
35740: void* NP_CALLBACK /* OJI type: jref */
35740: _getjavapeer(NPP aNPP)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35740:     return 0;
35740: }
35740: 
35740: NPIdentifier NP_CALLBACK
35740: _getstringidentifier(const NPUTF8* aName)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35913: 
38646:     NPRemoteIdentifier ident = 0;
38646:     if (aName)
38646:         PluginModuleChild::current()->
38646:             SendNPN_GetStringIdentifier(nsDependentCString(aName), &ident);
35913:     return (NPIdentifier)ident;
35740: }
35740: 
35740: void NP_CALLBACK
35740: _getstringidentifiers(const NPUTF8** aNames,
35740:                       int32_t aNameCount,
35740:                       NPIdentifier* aIdentifiers)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35913: 
35913:     if (!(aNames && aNameCount > 0 && aIdentifiers)) {
35913:         NS_RUNTIMEABORT("Bad input! Headed for a crash!");
35913:     }
35913: 
38646:     // Initialize to zero in case of errors later
38646:     for (int32_t index = 0; index < aNameCount; ++index)
38646:         aIdentifiers[index] = 0;
35913: 
38646:     nsTArray<nsCString> names;
38646:     nsTArray<NPRemoteIdentifier> ids;
38646: 
38646:     names.SetLength(aNameCount);
38646:     for (int32_t index = 0; index < aNameCount; ++index) {
38646:         if (aNames[index]) {
38646:             names[index] = nsDependentCString(aNames[index]);
35913:         }
38646:         else {
38646:             names[index].SetIsVoid(true);
35913:         }
35913:     }
35913: 
38646:     PluginModuleChild::current()->
38646:         SendNPN_GetStringIdentifiers(names, &ids);
38646: 
38646:     for (int32_t index = 0; index < ids.Length(); ++index)
38646:         aIdentifiers[index] = (NPIdentifier)ids[index];
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _identifierisstring(NPIdentifier aIdentifier)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35913: 
35913:     bool isString;
35934:     if (!PluginModuleChild::current()->
35934:              SendNPN_IdentifierIsString((NPRemoteIdentifier)aIdentifier,
35934:                                         &isString)) {
35934:         NS_WARNING("Failed to send message!");
35934:         isString = false;
35934:     }
35913: 
35913:     return isString;
35740: }
35740: 
35740: NPIdentifier NP_CALLBACK
35740: _getintidentifier(int32_t aIntId)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35913: 
35913:     NPRemoteIdentifier ident;
35934:     if (!PluginModuleChild::current()->
35934:              SendNPN_GetIntIdentifier(aIntId, &ident)) {
35934:         NS_WARNING("Failed to send message!");
35934:         ident = 0;
35934:     }
35913: 
35913:     return (NPIdentifier)ident;
35740: }
35740: 
35740: NPUTF8* NP_CALLBACK
35740: _utf8fromidentifier(NPIdentifier aIdentifier)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35913: 
35927:     NPError err;
35913:     nsCAutoString val;
35934:     if (!PluginModuleChild::current()->
35927:              SendNPN_UTF8FromIdentifier((NPRemoteIdentifier)aIdentifier,
35934:                                          &err, &val)) {
35934:         NS_WARNING("Failed to send message!");
35934:         return 0;
35934:     }
35913: 
35927:     return (NPERR_NO_ERROR == err) ? strdup(val.get()) : 0;
35740: }
35740: 
35740: int32_t NP_CALLBACK
35740: _intfromidentifier(NPIdentifier aIdentifier)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35913: 
35927:     NPError err;
35913:     int32_t val;
35934:     if (!PluginModuleChild::current()->
35927:              SendNPN_IntFromIdentifier((NPRemoteIdentifier)aIdentifier,
35934:                                        &err, &val)) {
35934:         NS_WARNING("Failed to send message!");
35934:         return -1;
35934:     }
35913: 
35927:     // -1 for consistency
35927:     return (NPERR_NO_ERROR == err) ? val : -1;
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _invoke(NPP aNPP,
35740:         NPObject* aNPObj,
35740:         NPIdentifier aMethod,
35740:         const NPVariant* aArgs,
35740:         uint32_t aArgCount,
35740:         NPVariant* aResult)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965: 
35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->invoke)
35740:         return false;
35965: 
35965:     return aNPObj->_class->invoke(aNPObj, aMethod, aArgs, aArgCount, aResult);
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _invokedefault(NPP aNPP,
35740:                NPObject* aNPObj,
35740:                const NPVariant* aArgs,
35740:                uint32_t aArgCount,
35740:                NPVariant* aResult)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965: 
35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->invokeDefault)
35740:         return false;
35965: 
35965:     return aNPObj->_class->invokeDefault(aNPObj, aArgs, aArgCount, aResult);
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _evaluate(NPP aNPP,
35983:           NPObject* aObject,
35740:           NPString* aScript,
35740:           NPVariant* aResult)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35971: 
35983:     if (!(aNPP && aObject && aScript && aResult)) {
35983:         NS_ERROR("Bad arguments!");
35740:         return false;
35740:     }
35740: 
35983:     PluginScriptableObjectChild* actor =
35983:       InstCast(aNPP)->GetActorForNPObject(aObject);
35983:     if (!actor) {
35983:         NS_ERROR("Failed to create actor?!");
35983:         return false;
35983:     }
35983: 
35983:     return actor->Evaluate(aScript, aResult);
35983: }
35983: 
35740: bool NP_CALLBACK
35740: _getproperty(NPP aNPP,
35740:              NPObject* aNPObj,
35740:              NPIdentifier aPropertyName,
35740:              NPVariant* aResult)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965: 
35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->getProperty)
35740:         return false;
35965: 
35965:     return aNPObj->_class->getProperty(aNPObj, aPropertyName, aResult);
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _setproperty(NPP aNPP,
35740:              NPObject* aNPObj,
35740:              NPIdentifier aPropertyName,
35740:              const NPVariant* aValue)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965: 
35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->setProperty)
35740:         return false;
35965: 
35965:     return aNPObj->_class->setProperty(aNPObj, aPropertyName, aValue);
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _removeproperty(NPP aNPP,
35740:                 NPObject* aNPObj,
35740:                 NPIdentifier aPropertyName)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965: 
35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->removeProperty)
35740:         return false;
35965: 
35965:     return aNPObj->_class->removeProperty(aNPObj, aPropertyName);
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _hasproperty(NPP aNPP,
35740:              NPObject* aNPObj,
35740:              NPIdentifier aPropertyName)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965: 
35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->hasProperty)
35740:         return false;
35965: 
35965:     return aNPObj->_class->hasProperty(aNPObj, aPropertyName);
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _hasmethod(NPP aNPP,
35740:            NPObject* aNPObj,
35740:            NPIdentifier aMethodName)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965: 
35965:     if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->hasMethod)
35740:         return false;
35965: 
35965:     return aNPObj->_class->hasMethod(aNPObj, aMethodName);
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _enumerate(NPP aNPP,
35740:            NPObject* aNPObj,
35740:            NPIdentifier** aIdentifiers,
35740:            uint32_t* aCount)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965: 
35965:     if (!aNPP || !aNPObj || !aNPObj->_class)
35740:         return false;
35965: 
35965:     if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(aNPObj->_class) ||
35965:         !aNPObj->_class->enumerate) {
35965:         *aIdentifiers = 0;
35965:         *aCount = 0;
35965:         return true;
35965:     }
35965: 
35965:     return aNPObj->_class->enumerate(aNPObj, aIdentifiers, aCount);
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _construct(NPP aNPP,
35740:            NPObject* aNPObj,
35740:            const NPVariant* aArgs,
35740:            uint32_t aArgCount,
35740:            NPVariant* aResult)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965: 
35965:     if (!aNPP || !aNPObj || !aNPObj->_class ||
35965:         !NP_CLASS_STRUCT_VERSION_HAS_CTOR(aNPObj->_class) ||
35965:         !aNPObj->_class->construct) {
35740:         return false;
35740:     }
35740: 
35965:     return aNPObj->_class->construct(aNPObj, aArgs, aArgCount, aResult);
35965: }
35965: 
35740: void NP_CALLBACK
35740: _releasevariantvalue(NPVariant* aVariant)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35971: 
35965:     if (NPVARIANT_IS_STRING(*aVariant)) {
35965:         NPString str = NPVARIANT_TO_STRING(*aVariant);
35965:         free(const_cast<NPUTF8*>(str.UTF8Characters));
35965:     }
35965:     else if (NPVARIANT_IS_OBJECT(*aVariant)) {
35965:         NPObject* object = NPVARIANT_TO_OBJECT(*aVariant);
35965:         if (object) {
37477:             PluginModuleChild::NPN_ReleaseObject(object);
35965:         }
35965:     }
35965:     VOID_TO_NPVARIANT(*aVariant);
35740: }
35740: 
35740: void NP_CALLBACK
35740: _setexception(NPObject* aNPObj,
35740:               const NPUTF8* aMessage)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965:     NS_NOTYETIMPLEMENTED("Implement me!");
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _pushpopupsenabledstate(NPP aNPP,
35740:                         NPBool aEnabled)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35983:     bool retval;
35983:     if (InstCast(aNPP)->CallNPN_PushPopupsEnabledState(aEnabled ? true : false,
35983:                                                        &retval)) {
35983:         return retval;
35983:     }
35740:     return false;
35740: }
35740: 
35740: bool NP_CALLBACK
35740: _poppopupsenabledstate(NPP aNPP)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35983:     bool retval;
35983:     if (InstCast(aNPP)->CallNPN_PopPopupsEnabledState(&retval)) {
35983:         return retval;
35983:     }
35740:     return false;
35740: }
35740: 
35740: void NP_CALLBACK
35740: _pluginthreadasynccall(NPP aNPP,
35740:                        PluginThreadCallback aFunc,
35740:                        void* aUserData)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
36305:     if (!aFunc)
36305:         return;
36305: 
37884:     PluginThreadChild::current()->message_loop()
37884:         ->PostTask(FROM_HERE, new ChildAsyncCall(InstCast(aNPP), aFunc,
37884:                                                  aUserData));
35740: }
35740: 
35956: NPError NP_CALLBACK
35956: _getvalueforurl(NPP npp, NPNURLVariable variable, const char *url,
35956:                 char **value, uint32_t *len)
35956: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
37332: 
37332:     if (!url)
37332:         return NPERR_INVALID_URL;
37332: 
37332:     if (!npp || !value || !len)
37332:         return NPERR_INVALID_PARAM;
37332: 
37332:     switch (variable) {
37332:     case NPNURLVCookie:
37332:     case NPNURLVProxy:
37332:         nsCString v;
37332:         NPError result;
37332:         InstCast(npp)->
37332:             CallNPN_GetValueForURL(variable, nsCString(url), &v, &result);
37332:         if (NPERR_NO_ERROR == result) {
37332:             *value = ToNewCString(v);
37332:             *len = v.Length();
37332:         }
37332:         return result;
37332:     }
37332: 
37332:     return NPERR_INVALID_PARAM;
35956: }
35956: 
35956: NPError NP_CALLBACK
35956: _setvalueforurl(NPP npp, NPNURLVariable variable, const char *url,
35956:                 const char *value, uint32_t len)
35956: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
37332: 
37332:     if (!value)
37332:         return NPERR_INVALID_PARAM;
37332: 
37332:     if (!url)
37332:         return NPERR_INVALID_URL;
37332: 
37332:     switch (variable) {
37332:     case NPNURLVCookie:
37332:     case NPNURLVProxy:
37332:         NPError result;
37332:         InstCast(npp)->CallNPN_SetValueForURL(variable, nsCString(url),
37332:                                               nsDependentCString(value, len),
37332:                                               &result);
37332:         return result;
37332:     }
37332: 
37332:     return NPERR_INVALID_PARAM;
35956: }
35956: 
35956: NPError NP_CALLBACK
35956: _getauthenticationinfo(NPP npp, const char *protocol,
35956:                        const char *host, int32_t port,
35956:                        const char *scheme, const char *realm,
35956:                        char **username, uint32_t *ulen,
35956:                        char **password, uint32_t *plen)
35956: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
37332: 
37332:     if (!protocol || !host || !scheme || !realm || !username || !ulen ||
37332:         !password || !plen)
37332:         return NPERR_INVALID_PARAM;
37332: 
37332:     nsCString u;
37332:     nsCString p;
37332:     NPError result;
37332:     InstCast(npp)->
37332:         CallNPN_GetAuthenticationInfo(nsDependentCString(protocol),
37332:                                       nsDependentCString(host),
37332:                                       port,
37332:                                       nsDependentCString(scheme),
37332:                                       nsDependentCString(realm),
37332:                                       &u, &p, &result);
37332:     if (NPERR_NO_ERROR == result) {
37332:         *username = ToNewCString(u);
37332:         *ulen = u.Length();
37332:         *password = ToNewCString(p);
37332:         *plen = p.Length();
37332:     }
37332:     return result;
35956: }
35956: 
35956: uint32_t NP_CALLBACK
37348: _scheduletimer(NPP npp, uint32_t interval, NPBool repeat,
35956:                void (*timerFunc)(NPP npp, uint32_t timerID))
35956: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
37348: 
37348:     return InstCast(npp)->ScheduleTimer(interval, repeat, timerFunc);
35956: }
35956: 
35956: void NP_CALLBACK
37348: _unscheduletimer(NPP npp, uint32_t timerID)
35956: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
37348:     InstCast(npp)->UnscheduleTimer(timerID);
35956: }
35956: 
35956: NPError NP_CALLBACK
35956: _popupcontextmenu(NPP instance, NPMenu* menu)
35956: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965:     NS_NOTYETIMPLEMENTED("Implement me!");
35956:     return NPERR_GENERIC_ERROR;
35956: }
35956: 
35956: NPBool NP_CALLBACK
35956: _convertpoint(NPP instance, 
35956:               double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
35956:               double *destX, double *destY, NPCoordinateSpace destSpace)
35956: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35965:     NS_NOTYETIMPLEMENTED("Implement me!");
35956:     return 0;
35956: }
35956: 
36125: } /* namespace child */
36125: } /* namespace plugins */
36125: } /* namespace mozilla */
36125: 
35956: //-----------------------------------------------------------------------------
35740: 
35926: bool
35893: PluginModuleChild::AnswerNP_Initialize(NPError* _retval)
35740: {
37099:     PLUGIN_LOG_DEBUG_METHOD;
35971:     AssertPluginThread();
35740: 
35746: #if defined(OS_LINUX)
35748:     *_retval = mInitializeFunc(&sBrowserFuncs, &mFunctions);
35926:     return true;
35746: 
35746: #elif defined(OS_WIN)
35746:     nsresult rv = mGetEntryPointsFunc(&mFunctions);
35926:     if (NS_FAILED(rv)) {
35926:         return false;
35926:     }
35746: 
35746:     NS_ASSERTION(HIBYTE(mFunctions.version) >= NP_VERSION_MAJOR,
35746:                  "callback version is less than NP version");
35746: 
35748:     *_retval = mInitializeFunc(&sBrowserFuncs);
35926:     return true;
36069: #elif defined(OS_MACOSX)
36069: #  warning IMPLEMENT ME
36069:     return false;
36069: 
35740: #else
35740: #  error Please implement me for your platform
35740: #endif
35740: }
35740: 
35898: PPluginInstanceChild*
35943: PluginModuleChild::AllocPPluginInstance(const nsCString& aMimeType,
35740:                                         const uint16_t& aMode,
35820:                                         const nsTArray<nsCString>& aNames,
35820:                                         const nsTArray<nsCString>& aValues,
35746:                                         NPError* rv)
35740: {
37099:     PLUGIN_LOG_DEBUG_METHOD;
35971:     AssertPluginThread();
35740: 
35893:     nsAutoPtr<PluginInstanceChild> childInstance(
38660:         new PluginInstanceChild(&mFunctions, aMimeType));
35747:     if (!childInstance->Initialize()) {
35747:         *rv = NPERR_GENERIC_ERROR;
35747:         return 0;
35747:     }
35925:     return childInstance.forget();
35925: }
35925: 
35926: bool
35925: PluginModuleChild::AnswerPPluginInstanceConstructor(PPluginInstanceChild* aActor,
35925:                                                     const nsCString& aMimeType,
35925:                                                     const uint16_t& aMode,
35925:                                                     const nsTArray<nsCString>& aNames,
35925:                                                     const nsTArray<nsCString>& aValues,
35925:                                                     NPError* rv)
35925: {
37099:     PLUGIN_LOG_DEBUG_METHOD;
35971:     AssertPluginThread();
35925: 
35925:     PluginInstanceChild* childInstance =
35925:         reinterpret_cast<PluginInstanceChild*>(aActor);
35925:     NS_ASSERTION(childInstance, "Null actor!");
35740: 
35740:     // unpack the arguments into a C format
35820:     int argc = aNames.Length();
35820:     NS_ASSERTION(argc == (int) aValues.Length(),
35740:                  "argn.length != argv.length");
35740: 
35820:     nsAutoArrayPtr<char*> argn(new char*[1 + argc]);
35820:     nsAutoArrayPtr<char*> argv(new char*[1 + argc]);
35740:     argn[argc] = 0;
35740:     argv[argc] = 0;
35740: 
35740:     for (int i = 0; i < argc; ++i) {
35940:         argn[i] = const_cast<char*>(NullableStringGet(aNames[i]));
35940:         argv[i] = const_cast<char*>(NullableStringGet(aValues[i]));
35740:     }
35740: 
35740:     NPP npp = childInstance->GetNPP();
35740: 
35740:     // FIXME/cjones: use SAFE_CALL stuff
35940:     *rv = mFunctions.newp((char*)NullableStringGet(aMimeType),
35740:                           npp,
35740:                           aMode,
35740:                           argc,
35740:                           argn,
35740:                           argv,
35740:                           0);
35746:     if (NPERR_NO_ERROR != *rv) {
35927:         return false;
35746:     }
35740: 
35927:     return true;
35746: }
35746: 
35926: bool
36138: PluginModuleChild::DeallocPPluginInstance(PPluginInstanceChild* aActor)
35746: {
37099:     PLUGIN_LOG_DEBUG_METHOD;
35971:     AssertPluginThread();
35747: 
35965:     delete aActor;
35965: 
35965:     return true;
35965: }
35965: 
37477: NPObject* NP_CALLBACK
37477: PluginModuleChild::NPN_CreateObject(NPP aNPP, NPClass* aClass)
37477: {
37477:     PLUGIN_LOG_DEBUG_FUNCTION;
37477:     AssertPluginThread();
37477: 
37477:     PluginInstanceChild* i = InstCast(aNPP);
38669:     if (i->mDeletingHash) {
38669:         NS_ERROR("Plugin used NPP after NPP_Destroy");
38669:         return NULL;
38669:     }
37477: 
37477:     NPObject* newObject;
37477:     if (aClass && aClass->allocate) {
37477:         newObject = aClass->allocate(aNPP, aClass);
37477:     }
37477:     else {
37477:         newObject = reinterpret_cast<NPObject*>(child::_memalloc(sizeof(NPObject)));
37477:     }
37477: 
37477:     if (newObject) {
37477:         newObject->_class = aClass;
37477:         newObject->referenceCount = 1;
37477:         NS_LOG_ADDREF(newObject, 1, "NPObject", sizeof(NPObject));
37477:     }
37477: 
37477:     NPObjectData* d = static_cast<PluginModuleChild*>(i->Manager())
37477:         ->mObjectMap.PutEntry(newObject);
37477:     NS_ASSERTION(!d->instance, "New NPObject already mapped?");
37477:     d->instance = i;
37477: 
37477:     return newObject;
37477: }
37477: 
37477: NPObject* NP_CALLBACK
37477: PluginModuleChild::NPN_RetainObject(NPObject* aNPObj)
37477: {
37477:     AssertPluginThread();
37477: 
37477:     int32_t refCnt = PR_AtomicIncrement((PRInt32*)&aNPObj->referenceCount);
37477:     NS_LOG_ADDREF(aNPObj, refCnt, "NPObject", sizeof(NPObject));
37477: 
37477:     return aNPObj;
37477: }
37477: 
37477: void NP_CALLBACK
37477: PluginModuleChild::NPN_ReleaseObject(NPObject* aNPObj)
37477: {
37477:     AssertPluginThread();
37477: 
38669:     NPObjectData* d = current()->mObjectMap.GetEntry(aNPObj);
38669:     if (!d) {
38669:         NS_ERROR("Releasing object not in mObjectMap?");
38669:         return;
38669:     }
38669: 
38669:     DeletingObjectEntry* doe = NULL;
38669:     if (d->instance->mDeletingHash) {
38669:         doe = d->instance->mDeletingHash->GetEntry(aNPObj);
38669:         if (!doe) {
38669:             NS_ERROR("An object for a destroyed instance isn't in the instance deletion hash");
38669:             return;
38669:         }
38669:         if (doe->mDeleted)
38669:             return;
38669:     }
38669: 
37477:     int32_t refCnt = PR_AtomicDecrement((PRInt32*)&aNPObj->referenceCount);
37477:     NS_LOG_RELEASE(aNPObj, refCnt, "NPObject");
37477: 
37477:     if (refCnt == 0) {
37477:         DeallocNPObject(aNPObj);
38669:         if (doe)
38669:             doe->mDeleted = true;
37477:     }
37477:     return;
37477: }
37477: 
37477: void
37477: PluginModuleChild::DeallocNPObject(NPObject* aNPObj)
37477: {
37477:     if (aNPObj->_class && aNPObj->_class->deallocate) {
37477:         aNPObj->_class->deallocate(aNPObj);
37477:     } else {
37477:         child::_memfree(aNPObj);
37477:     }
38669: 
38669:     NPObjectData* d = current()->mObjectMap.GetEntry(aNPObj);
38669:     if (d->actor)
38669:         d->actor->NPObjectDestroyed();
38669: 
38669:     current()->mObjectMap.RemoveEntry(aNPObj);
38669: }
38669: 
38669: void
38669: PluginModuleChild::FindNPObjectsForInstance(PluginInstanceChild* instance)
38669: {
38669:     NS_ASSERTION(instance->mDeletingHash, "filling null mDeletingHash?");
38669:     mObjectMap.EnumerateEntries(CollectForInstance, instance);
37477: }
37477: 
37477: PLDHashOperator
38669: PluginModuleChild::CollectForInstance(NPObjectData* d, void* userArg)
37477: {
38669:     PluginInstanceChild* instance = static_cast<PluginInstanceChild*>(userArg);
38669:     if (d->instance == instance) {
37477:         NPObject* o = d->GetKey();
38669:         instance->mDeletingHash->PutEntry(o);
37478:     }
37477:     return PL_DHASH_NEXT;
37477: }
