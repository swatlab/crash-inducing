 24963: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 24963: 
 91983: #include "TextAttrs.h"
 24963: 
138050: #include "Accessible-inl.h"
 41384: #include "nsAccUtils.h"
 41384: #include "nsCoreUtils.h"
 91113: #include "StyleInfo.h"
 24963: 
 25728: #include "gfxFont.h"
 68493: #include "nsFontMetrics.h"
 76294: #include "nsLayoutUtils.h"
160532: #include "HyperTextAccessible.h"
163079: #include "mozilla/AppUnits.h"
164848: #include "mozilla/gfx/2D.h"
 25728: 
 91113: using namespace mozilla;
 91113: using namespace mozilla::a11y;
 91113: 
 24963: ////////////////////////////////////////////////////////////////////////////////
 91983: // TextAttrsMgr
 91983: ////////////////////////////////////////////////////////////////////////////////
 24999: 
 91983: void
 91983: TextAttrsMgr::GetAttributes(nsIPersistentProperties* aAttributes,
108991:                             int32_t* aStartHTOffset,
108991:                             int32_t* aEndHTOffset)
 24999: {
 42799:   // 1. Hyper text accessible must be specified always.
 42799:   // 2. Offset accessible and result hyper text offsets must be specified in
 24999:   // the case of text attributes.
 42799:   // 3. Offset accessible and result hyper text offsets must not be specified
 42799:   // but include default text attributes flag and attributes list must be
 42799:   // specified in the case of default text attributes.
 42799:   NS_PRECONDITION(mHyperTextAcc &&
 42799:                   ((mOffsetAcc && mOffsetAccIdx != -1 &&
 42799:                     aStartHTOffset && aEndHTOffset) ||
 42799:                   (!mOffsetAcc && mOffsetAccIdx == -1 &&
 42799:                     !aStartHTOffset && !aEndHTOffset &&
 24999:                    mIncludeDefAttrs && aAttributes)),
 91983:                   "Wrong usage of TextAttrsMgr!");
 24999: 
 42799:   // Embedded objects are combined into own range with empty attributes set.
 42799:   if (mOffsetAcc && nsAccUtils::IsEmbeddedObject(mOffsetAcc)) {
108991:     for (int32_t childIdx = mOffsetAccIdx - 1; childIdx >= 0; childIdx--) {
 99648:       Accessible* currAcc = mHyperTextAcc->GetChildAt(childIdx);
 42799:       if (!nsAccUtils::IsEmbeddedObject(currAcc))
 42799:         break;
 42799: 
 42799:       (*aStartHTOffset)--;
 42799:     }
 42799: 
108991:     uint32_t childCount = mHyperTextAcc->ChildCount();
108991:     for (uint32_t childIdx = mOffsetAccIdx + 1; childIdx < childCount;
 42799:          childIdx++) {
 99648:       Accessible* currAcc = mHyperTextAcc->GetChildAt(childIdx);
 42799:       if (!nsAccUtils::IsEmbeddedObject(currAcc))
 42799:         break;
 42799: 
 42799:       (*aEndHTOffset)++;
 42799:     }
 42799: 
 91983:     return;
 42799:   }
 42799: 
 43504:   // Get the content and frame of the accessible. In the case of document
 43504:   // accessible it's role content and root frame.
 43504:   nsIContent *hyperTextElm = mHyperTextAcc->GetContent();
 43504:   nsIFrame *rootFrame = mHyperTextAcc->GetFrame();
 43504:   NS_ASSERTION(rootFrame, "No frame for accessible!");
 43504:   if (!rootFrame)
 91983:     return;
 42799: 
106838:   nsIContent *offsetNode = nullptr, *offsetElm = nullptr;
106838:   nsIFrame *frame = nullptr;
 42799:   if (mOffsetAcc) {
 43504:     offsetNode = mOffsetAcc->GetContent();
 42799:     offsetElm = nsCoreUtils::GetDOMElementFor(offsetNode);
187029:     NS_ASSERTION(offsetElm, "No element for offset accessible!");
187029:     if (!offsetElm)
187029:       return;
 43504:     frame = offsetElm->GetPrimaryFrame();
 42799:   }
 24999: 
 24999:   // "language" text attribute
 91983:   LangTextAttr langTextAttr(mHyperTextAcc, hyperTextElm, offsetNode);
 24999: 
132091:   // "aria-invalid" text attribute
132091:   InvalidTextAttr invalidTextAttr(hyperTextElm, offsetNode);
132091: 
 24999:   // "background-color" text attribute
 91983:   BGColorTextAttr bgColorTextAttr(rootFrame, frame);
 24999: 
 91113:   // "color" text attribute
 91113:   ColorTextAttr colorTextAttr(rootFrame, frame);
 91113: 
 91236:   // "font-family" text attribute
 91236:   FontFamilyTextAttr fontFamilyTextAttr(rootFrame, frame);
 91236: 
 24999:   // "font-size" text attribute
 91983:   FontSizeTextAttr fontSizeTextAttr(rootFrame, frame);
 24999: 
 91247:   // "font-style" text attribute
 91247:   FontStyleTextAttr fontStyleTextAttr(rootFrame, frame);
 91247: 
 25728:   // "font-weight" text attribute
 91983:   FontWeightTextAttr fontWeightTextAttr(rootFrame, frame);
 25728: 
101616:   // "auto-generated" text attribute
101616:   AutoGeneratedTextAttr autoGenTextAttr(mHyperTextAcc, mOffsetAcc);
101616: 
 91988:   // "text-underline(line-through)-style(color)" text attributes
 91988:   TextDecorTextAttr textDecorTextAttr(rootFrame, frame);
 92053: 
 92059:   // "text-position" text attribute
 92059:   TextPosTextAttr textPosTextAttr(rootFrame, frame);
 92059: 
 92053:   TextAttr* attrArray[] =
 92053:   {
 92053:     &langTextAttr,
132091:     &invalidTextAttr,
 92053:     &bgColorTextAttr,
 92053:     &colorTextAttr,
 92053:     &fontFamilyTextAttr,
 92053:     &fontSizeTextAttr,
 92053:     &fontStyleTextAttr,
 92053:     &fontWeightTextAttr,
101616:     &autoGenTextAttr,
 92059:     &textDecorTextAttr,
 92059:     &textPosTextAttr
 92053:   };
 91988: 
 24999:   // Expose text attributes if applicable.
 24999:   if (aAttributes) {
108991:     for (uint32_t idx = 0; idx < ArrayLength(attrArray); idx++)
 92053:       attrArray[idx]->Expose(aAttributes, mIncludeDefAttrs);
 24999:   }
 24999: 
 24999:   // Expose text attributes range where they are applied if applicable.
 92061:   if (mOffsetAcc)
 92061:     GetRange(attrArray, ArrayLength(attrArray), aStartHTOffset, aEndHTOffset);
 24999: }
 24999: 
 91983: void
108991: TextAttrsMgr::GetRange(TextAttr* aAttrArray[], uint32_t aAttrArrayLen,
108991:                        int32_t* aStartHTOffset, int32_t* aEndHTOffset)
 24999: {
 42799:   // Navigate backward from anchor accessible to find start offset.
108991:   for (int32_t childIdx = mOffsetAccIdx - 1; childIdx >= 0; childIdx--) {
 99648:     Accessible* currAcc = mHyperTextAcc->GetChildAt(childIdx);
 24999: 
 42799:     // Stop on embedded accessible since embedded accessibles are combined into
 42799:     // own range.
 42799:     if (nsAccUtils::IsEmbeddedObject(currAcc))
 42799:       break;
 24999: 
 79445:     bool offsetFound = false;
108991:     for (uint32_t attrIdx = 0; attrIdx < aAttrArrayLen; attrIdx++) {
 92053:       TextAttr* textAttr = aAttrArray[attrIdx];
101616:       if (!textAttr->Equal(currAcc)) {
 80486:         offsetFound = true;
 24999:         break;
 24999:       }
 24999:     }
 42799: 
 42799:     if (offsetFound)
 42799:       break;
 42799: 
 42799:     *(aStartHTOffset) -= nsAccUtils::TextLength(currAcc);
 42799:   }
 42799: 
 42799:   // Navigate forward from anchor accessible to find end offset.
108991:   uint32_t childLen = mHyperTextAcc->ChildCount();
108991:   for (uint32_t childIdx = mOffsetAccIdx + 1; childIdx < childLen; childIdx++) {
 99648:     Accessible* currAcc = mHyperTextAcc->GetChildAt(childIdx);
 42799:     if (nsAccUtils::IsEmbeddedObject(currAcc))
 42799:       break;
 42799: 
 79445:     bool offsetFound = false;
108991:     for (uint32_t attrIdx = 0; attrIdx < aAttrArrayLen; attrIdx++) {
 92053:       TextAttr* textAttr = aAttrArray[attrIdx];
 42799: 
 42799:       // Alter the end offset when text attribute changes its value and stop
 42799:       // the search.
101616:       if (!textAttr->Equal(currAcc)) {
 80486:         offsetFound = true;
 24999:         break;
 24999:       }
 24999:     }
 24999: 
 42799:     if (offsetFound)
 24999:       break;
 24999: 
 42799:     (*aEndHTOffset) += nsAccUtils::TextLength(currAcc);
 24999:   }
 24963: }
 24963: 
 91983: 
 24999: ////////////////////////////////////////////////////////////////////////////////
 91983: // LangTextAttr
 91983: ////////////////////////////////////////////////////////////////////////////////
 24999: 
 91983: TextAttrsMgr::LangTextAttr::
 99901:   LangTextAttr(HyperTextAccessible* aRoot,
 91983:                nsIContent* aRootElm, nsIContent* aElm) :
 91983:   TTextAttr<nsString>(!aElm), mRootContent(aRootElm)
 24999: {
 91983:   aRoot->Language(mRootNativeValue);
 89598:   mIsRootDefined =  !mRootNativeValue.IsEmpty();
 24999: 
101616:   if (aElm) {
101616:     nsCoreUtils::GetLanguageFor(aElm, mRootContent, mNativeValue);
101616:     mIsDefined = !mNativeValue.IsEmpty();
101616:   }
 24999: }
 24999: 
107114: TextAttrsMgr::LangTextAttr::
107114:   ~LangTextAttr() {}
107114: 
 79445: bool
 91983: TextAttrsMgr::LangTextAttr::
101616:   GetValueFor(Accessible* aAccessible, nsString* aValue)
 24999: {
101616:   nsCoreUtils::GetLanguageFor(aAccessible->GetContent(), mRootContent, *aValue);
101616:   return !aValue->IsEmpty();
 24999: }
 24999: 
 24999: void
 91983: TextAttrsMgr::LangTextAttr::
 91983:   ExposeValue(nsIPersistentProperties* aAttributes, const nsString& aValue)
 24999: {
 91983:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::language, aValue);
 24999: }
 24999: 
132091: ////////////////////////////////////////////////////////////////////////////////
132091: // InvalidTextAttr
132091: ////////////////////////////////////////////////////////////////////////////////
132091: 
132091: TextAttrsMgr::InvalidTextAttr::
132091:   InvalidTextAttr(nsIContent* aRootElm, nsIContent* aElm) :
132091:   TTextAttr<uint32_t>(!aElm), mRootElm(aRootElm)
132091: {
132091:   mIsRootDefined = GetValue(mRootElm, &mRootNativeValue);
132091:   if (aElm)
132091:     mIsDefined = GetValue(aElm, &mNativeValue);
132091: }
132091: 
132091: bool
132091: TextAttrsMgr::InvalidTextAttr::
132091:   GetValueFor(Accessible* aAccessible, uint32_t* aValue)
132091: {
132091:   nsIContent* elm = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
132091:   return elm ? GetValue(elm, aValue) : false;
132091: }
132091: 
132091: void
132091: TextAttrsMgr::InvalidTextAttr::
132091:   ExposeValue(nsIPersistentProperties* aAttributes, const uint32_t& aValue)
132091: {
132091:   switch (aValue) {
132091:     case eFalse:
132091:       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::invalid,
132091:                              NS_LITERAL_STRING("false"));
132091:       break;
132091: 
132091:     case eGrammar:
132091:       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::invalid,
132091:                              NS_LITERAL_STRING("grammar"));
132091:       break;
132091: 
132091:     case eSpelling:
132091:       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::invalid,
132091:                              NS_LITERAL_STRING("spelling"));
132091:       break;
132091: 
132091:     case eTrue:
132091:       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::invalid,
132091:                              NS_LITERAL_STRING("true"));
132091:       break;
132091:   }
132091: }
132091: 
132091: bool
132091: TextAttrsMgr::InvalidTextAttr::
132091:   GetValue(nsIContent* aElm, uint32_t* aValue)
132091: {
132091:   nsIContent* elm = aElm;
132091:   do {
132091:     if (nsAccUtils::HasDefinedARIAToken(elm, nsGkAtoms::aria_invalid)) {
132091:       static nsIContent::AttrValuesArray tokens[] =
132091:         { &nsGkAtoms::_false, &nsGkAtoms::grammar, &nsGkAtoms::spelling,
132091:           nullptr };
132091: 
132091:       int32_t idx = elm->FindAttrValueIn(kNameSpaceID_None,
132091:                                          nsGkAtoms::aria_invalid, tokens,
132091:                                          eCaseMatters);
132091:       switch (idx) {
132091:         case 0:
132091:           *aValue = eFalse;
132091:           return true;
132091:         case 1:
132091:           *aValue = eGrammar;
132091:           return true;
132091:         case 2:
132091:           *aValue = eSpelling;
132091:           return true;
132091:         default:
132091:           *aValue = eTrue;
132091:           return true;
132091:       }
132091:     }
132091:   } while ((elm = elm->GetParent()) && elm != mRootElm);
132091: 
132091:   return false;
132091: }
132091: 
 43504: 
 24999: ////////////////////////////////////////////////////////////////////////////////
 91983: // BGColorTextAttr
 43504: ////////////////////////////////////////////////////////////////////////////////
 24963: 
 91983: TextAttrsMgr::BGColorTextAttr::
 91983:   BGColorTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
 91983:   TTextAttr<nscolor>(!aFrame), mRootFrame(aRootFrame)
 24963: {
 24999:   mIsRootDefined = GetColor(mRootFrame, &mRootNativeValue);
 24999:   if (aFrame)
 24999:     mIsDefined = GetColor(aFrame, &mNativeValue);
 24963: }
 24963: 
 79445: bool
 91983: TextAttrsMgr::BGColorTextAttr::
101616:   GetValueFor(Accessible* aAccessible, nscolor* aValue)
 24963: {
101616:   nsIContent* elm = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
101616:   nsIFrame* frame = elm->GetPrimaryFrame();
 91983:   return frame ? GetColor(frame, aValue) : false;
 24999: }
 24999: 
 24999: void
 91983: TextAttrsMgr::BGColorTextAttr::
 91983:   ExposeValue(nsIPersistentProperties* aAttributes, const nscolor& aValue)
 24999: {
 91983:   nsAutoString formattedValue;
 91983:   StyleInfo::FormatColor(aValue, formattedValue);
 91983:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::backgroundColor,
 91983:                          formattedValue);
 24963: }
 24963: 
 79445: bool
 91983: TextAttrsMgr::BGColorTextAttr::
 91983:   GetColor(nsIFrame* aFrame, nscolor* aColor)
 24963: {
132812:   const nsStyleBackground* styleBackground = aFrame->StyleBackground();
 24963: 
 29266:   if (NS_GET_A(styleBackground->mBackgroundColor) > 0) {
 29266:     *aColor = styleBackground->mBackgroundColor;
 80486:     return true;
 24963:   }
 24963: 
 24963:   nsIFrame *parentFrame = aFrame->GetParent();
 24999:   if (!parentFrame) {
 24999:     *aColor = aFrame->PresContext()->DefaultBackgroundColor();
 80486:     return true;
 24999:   }
 24963: 
 24963:   // Each frame of parents chain for the initially passed 'aFrame' has
 24963:   // transparent background color. So background color isn't changed from
 24963:   // 'mRootFrame' to initially passed 'aFrame'.
 24963:   if (parentFrame == mRootFrame)
 80486:     return false;
 24963: 
 24999:   return GetColor(parentFrame, aColor);
 24963: }
 24963: 
 43504: 
 24963: ////////////////////////////////////////////////////////////////////////////////
 91113: // ColorTextAttr
 91113: ////////////////////////////////////////////////////////////////////////////////
 91113: 
 91983: TextAttrsMgr::ColorTextAttr::
 91983:   ColorTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
 91983:   TTextAttr<nscolor>(!aFrame)
 91113: {
132812:   mRootNativeValue = aRootFrame->StyleColor()->mColor;
 91113:   mIsRootDefined = true;
 91113: 
 91113:   if (aFrame) {
132812:     mNativeValue = aFrame->StyleColor()->mColor;
 91113:     mIsDefined = true;
 91113:   }
 91113: }
 91113: 
 91113: bool
 91983: TextAttrsMgr::ColorTextAttr::
101616:   GetValueFor(Accessible* aAccessible, nscolor* aValue)
 91113: {
101616:   nsIContent* elm = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
101616:   nsIFrame* frame = elm->GetPrimaryFrame();
 91113:   if (frame) {
132812:     *aValue = frame->StyleColor()->mColor;
 91113:     return true;
 91113:   }
 91113: 
 91113:   return false;
 91113: }
 91113: 
 91113: void
 91983: TextAttrsMgr::ColorTextAttr::
 91983:   ExposeValue(nsIPersistentProperties* aAttributes, const nscolor& aValue)
 91113: {
 91983:   nsAutoString formattedValue;
 91983:   StyleInfo::FormatColor(aValue, formattedValue);
 91983:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::color, formattedValue);
 91113: }
 91113: 
 91113: 
 91113: ////////////////////////////////////////////////////////////////////////////////
 91236: // FontFamilyTextAttr
 91236: ////////////////////////////////////////////////////////////////////////////////
 91236: 
 91983: TextAttrsMgr::FontFamilyTextAttr::
 91983:   FontFamilyTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
 91983:   TTextAttr<nsString>(!aFrame)
 91236: {
 91236:   mIsRootDefined = GetFontFamily(aRootFrame, mRootNativeValue);
 91236: 
 91236:   if (aFrame)
 91236:     mIsDefined = GetFontFamily(aFrame, mNativeValue);
 91236: }
 91236: 
 91236: bool
 91983: TextAttrsMgr::FontFamilyTextAttr::
101616:   GetValueFor(Accessible* aAccessible, nsString* aValue)
 91236: {
101616:   nsIContent* elm = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
101616:   nsIFrame* frame = elm->GetPrimaryFrame();
 91983:   return frame ? GetFontFamily(frame, *aValue) : false;
 91236: }
 91236: 
 91236: void
 91983: TextAttrsMgr::FontFamilyTextAttr::
 91983:   ExposeValue(nsIPersistentProperties* aAttributes, const nsString& aValue)
 91236: {
 91983:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::font_family, aValue);
 91236: }
 91236: 
 91236: bool
 91983: TextAttrsMgr::FontFamilyTextAttr::
 91983:   GetFontFamily(nsIFrame* aFrame, nsString& aFamily)
 91236: {
 91236:   nsRefPtr<nsFontMetrics> fm;
 91236:   nsLayoutUtils::GetFontMetricsForFrame(aFrame, getter_AddRefs(fm));
 91236: 
 91236:   gfxFontGroup* fontGroup = fm->GetThebesFontGroup();
132860:   gfxFont* font = fontGroup->GetFontAt(0);
132860:   gfxFontEntry* fontEntry = font->GetFontEntry();
132860:   aFamily = fontEntry->FamilyName();
 91236:   return true;
 91236: }
 91236: 
 91236: 
 91236: ////////////////////////////////////////////////////////////////////////////////
 91983: // FontSizeTextAttr
 43504: ////////////////////////////////////////////////////////////////////////////////
 24963: 
 91983: TextAttrsMgr::FontSizeTextAttr::
 91983:   FontSizeTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
 91983:   TTextAttr<nscoord>(!aFrame)
 24963: {
 24999:   mDC = aRootFrame->PresContext()->DeviceContext();
 24999: 
132812:   mRootNativeValue = aRootFrame->StyleFont()->mSize;
 80486:   mIsRootDefined = true;
 24999: 
 24999:   if (aFrame) {
132812:     mNativeValue = aFrame->StyleFont()->mSize;
 80486:     mIsDefined = true;
 24999:   }
 24963: }
 24963: 
 79445: bool
 91983: TextAttrsMgr::FontSizeTextAttr::
101616:   GetValueFor(Accessible* aAccessible, nscoord* aValue)
 24963: {
101616:   nsIContent* content = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
101616:   nsIFrame* frame = content->GetPrimaryFrame();
 91983:   if (frame) {
132812:     *aValue = frame->StyleFont()->mSize;
 80486:     return true;
 24963:   }
 24963: 
 91983:   return false;
 91983: }
 91983: 
 24999: void
 91983: TextAttrsMgr::FontSizeTextAttr::
 91983:   ExposeValue(nsIPersistentProperties* aAttributes, const nscoord& aValue)
 24963: {
 24963:   // Convert from nscoord to pt.
 24963:   //
 24963:   // Note: according to IA2, "The conversion doesn't have to be exact.
 24963:   // The intent is to give the user a feel for the size of the text."
 24963:   //
 24963:   // ATK does not specify a unit and will likely follow IA2 here.
 24963:   //
 24963:   // XXX todo: consider sharing this code with layout module? (bug 474621)
 50790:   float px =
163079:     NSAppUnitsToFloatPixels(aValue, mozilla::AppUnitsPerCSSPixel());
 50790:   // Each pt is 4/3 of a CSS pixel.
 50790:   int pts = NS_lround(px*3/4);
 24963: 
 24963:   nsAutoString value;
 24963:   value.AppendInt(pts);
 24963:   value.Append(NS_LITERAL_STRING("pt"));
 24963: 
 91983:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::font_size, value);
 24963: }
 25728: 
 25728: 
 25728: ////////////////////////////////////////////////////////////////////////////////
 91247: // FontStyleTextAttr
 91247: ////////////////////////////////////////////////////////////////////////////////
 91247: 
 91983: TextAttrsMgr::FontStyleTextAttr::
 91983:   FontStyleTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
 91983:   TTextAttr<nscoord>(!aFrame)
 91247: {
132812:   mRootNativeValue = aRootFrame->StyleFont()->mFont.style;
 91247:   mIsRootDefined = true;
 91247: 
 91247:   if (aFrame) {
132812:     mNativeValue = aFrame->StyleFont()->mFont.style;
 91247:     mIsDefined = true;
 91247:   }
 91247: }
 91247: 
 91247: bool
 91983: TextAttrsMgr::FontStyleTextAttr::
101616:   GetValueFor(Accessible* aAccessible, nscoord* aValue)
 91247: {
101616:   nsIContent* elm = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
101616:   nsIFrame* frame = elm->GetPrimaryFrame();
 91247:   if (frame) {
132812:     *aValue = frame->StyleFont()->mFont.style;
 91247:     return true;
 91247:   }
 91247: 
 91247:   return false;
 91247: }
 91247: 
 91247: void
 91983: TextAttrsMgr::FontStyleTextAttr::
 91983:   ExposeValue(nsIPersistentProperties* aAttributes, const nscoord& aValue)
 91247: {
 91983:   nsAutoString formattedValue;
 91983:   StyleInfo::FormatFontStyle(aValue, formattedValue);
 91983: 
 91983:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::font_style, formattedValue);
 91247: }
 91247: 
 91247: 
 91247: ////////////////////////////////////////////////////////////////////////////////
 91983: // FontWeightTextAttr
 43504: ////////////////////////////////////////////////////////////////////////////////
 25728: 
 91983: TextAttrsMgr::FontWeightTextAttr::
 91983:   FontWeightTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
108991:   TTextAttr<int32_t>(!aFrame)
 25728: {
 25728:   mRootNativeValue = GetFontWeight(aRootFrame);
 80486:   mIsRootDefined = true;
 25728: 
 25728:   if (aFrame) {
 25728:     mNativeValue = GetFontWeight(aFrame);
 80486:     mIsDefined = true;
 25728:   }
 25728: }
 25728: 
 79445: bool
 91983: TextAttrsMgr::FontWeightTextAttr::
108991:   GetValueFor(Accessible* aAccessible, int32_t* aValue)
 25728: {
101616:   nsIContent* elm = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
101616:   nsIFrame* frame = elm->GetPrimaryFrame();
 91983:   if (frame) {
 25728:     *aValue = GetFontWeight(frame);
 80486:     return true;
 25728:   }
 25728: 
 91983:   return false;
 91983: }
 91983: 
 25728: void
 91983: TextAttrsMgr::FontWeightTextAttr::
108991:   ExposeValue(nsIPersistentProperties* aAttributes, const int32_t& aValue)
 25728: {
 91983:   nsAutoString formattedValue;
 91983:   formattedValue.AppendInt(aValue);
 91983: 
 91983:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::fontWeight, formattedValue);
 25728: }
 25728: 
108991: int32_t
 91983: TextAttrsMgr::FontWeightTextAttr::
 91983:   GetFontWeight(nsIFrame* aFrame)
 25728: {
 25728:   // nsFont::width isn't suitable here because it's necessary to expose real
 25728:   // value of font weight (used font might not have some font weight values).
 68493:   nsRefPtr<nsFontMetrics> fm;
 76294:   nsLayoutUtils::GetFontMetricsForFrame(aFrame, getter_AddRefs(fm));
 25728: 
 68491:   gfxFontGroup *fontGroup = fm->GetThebesFontGroup();
 25728:   gfxFont *font = fontGroup->GetFontAt(0);
 25728: 
 25728:   // When there doesn't exist a bold font in the family and so the rendering of
 25728:   // a non-bold font face is changed so that the user sees what looks like a
 25728:   // bold font, i.e. synthetic bolding is used. IsSyntheticBold method is only
 25728:   // needed on Mac, but it is "safe" to use on all platforms.  (For non-Mac
 25728:   // platforms it always return false.)
 25728:   if (font->IsSyntheticBold())
 25728:     return 700;
 25728: 
176643: #if defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
 25728:   // On Linux, font->GetStyle()->weight will give the absolute weight requested
 25728:   // of the font face. The Linux code uses the gfxFontEntry constructor which
 25728:   // doesn't initialize the weight field.
 25728:   return font->GetStyle()->weight;
 25728: #else
 25728:   // On Windows, font->GetStyle()->weight will give the same weight as
 25728:   // fontEntry->Weight(), the weight of the first font in the font group, which
 25728:   // may not be the weight of the font face used to render the characters.
 25728:   // On Mac, font->GetStyle()->weight will just give the same number as
 25728:   // getComputedStyle(). fontEntry->Weight() will give the weight of the font
 25728:   // face used.
 25728:   gfxFontEntry *fontEntry = font->GetFontEntry();
 25728:   return fontEntry->Weight();
 25728: #endif
 25728: }
 91988: 
101616: ////////////////////////////////////////////////////////////////////////////////
101616: // AutoGeneratedTextAttr
101616: ////////////////////////////////////////////////////////////////////////////////
101616: TextAttrsMgr::AutoGeneratedTextAttr::
101616:   AutoGeneratedTextAttr(HyperTextAccessible* aHyperTextAcc,
101616:                         Accessible* aAccessible) :
101616:   TTextAttr<bool>(!aAccessible)
101616: {
101616:   mRootNativeValue = false;
101616:   mIsRootDefined = false;
101616: 
101616:   if (aAccessible)
101616:     mIsDefined = mNativeValue = (aAccessible->NativeRole() == roles::STATICTEXT);
101616: }
101616: 
101616: bool
101616: TextAttrsMgr::AutoGeneratedTextAttr::
101616:   GetValueFor(Accessible* aAccessible, bool* aValue)
101616: {
101616:   return *aValue = (aAccessible->NativeRole() == roles::STATICTEXT);
101616: }
101616: 
101616: void
101616: TextAttrsMgr::AutoGeneratedTextAttr::
101616:   ExposeValue(nsIPersistentProperties* aAttributes, const bool& aValue)
101616: {
101616:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::auto_generated,
101616:                          aValue ? NS_LITERAL_STRING("true") : NS_LITERAL_STRING("false"));
101616: }
101616: 
 91988: 
 91988: ////////////////////////////////////////////////////////////////////////////////
 91988: // TextDecorTextAttr
 91988: ////////////////////////////////////////////////////////////////////////////////
 91988: 
 91988: TextAttrsMgr::TextDecorValue::
 91988:   TextDecorValue(nsIFrame* aFrame)
 91988: {
132812:   const nsStyleTextReset* textReset = aFrame->StyleTextReset();
 91988:   mStyle = textReset->GetDecorationStyle();
 91988: 
 91988:   bool isForegroundColor = false;
 91988:   textReset->GetDecorationColor(mColor, isForegroundColor);
 91988:   if (isForegroundColor)
132812:     mColor = aFrame->StyleColor()->mColor;
 91988: 
 91988:   mLine = textReset->mTextDecorationLine &
 91988:     (NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE |
 91988:      NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH);
 91988: }
 91988: 
 91988: TextAttrsMgr::TextDecorTextAttr::
 91988:   TextDecorTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
 91988:   TTextAttr<TextDecorValue>(!aFrame)
 91988: {
 91988:   mRootNativeValue = TextDecorValue(aRootFrame);
 91988:   mIsRootDefined = mRootNativeValue.IsDefined();
 91988: 
 91988:   if (aFrame) {
 91988:     mNativeValue = TextDecorValue(aFrame);
 91988:     mIsDefined = mNativeValue.IsDefined();
 91988:   }
 91988: }
 91988: 
 91988: bool
 91988: TextAttrsMgr::TextDecorTextAttr::
101616:   GetValueFor(Accessible* aAccessible, TextDecorValue* aValue)
 91988: {
101616:   nsIContent* elm = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
101616:   nsIFrame* frame = elm->GetPrimaryFrame();
 91988:   if (frame) {
 91988:     *aValue = TextDecorValue(frame);
 91988:     return aValue->IsDefined();
 91988:   }
 91988: 
 91988:   return false;
 91988: }
 91988: 
 91988: void
 91988: TextAttrsMgr::TextDecorTextAttr::
 91988:   ExposeValue(nsIPersistentProperties* aAttributes, const TextDecorValue& aValue)
 91988: {
 91988:   if (aValue.IsUnderline()) {
 91988:     nsAutoString formattedStyle;
 91988:     StyleInfo::FormatTextDecorationStyle(aValue.Style(), formattedStyle);
 91988:     nsAccUtils::SetAccAttr(aAttributes,
 91988:                            nsGkAtoms::textUnderlineStyle,
 91988:                            formattedStyle);
 91988: 
 91988:     nsAutoString formattedColor;
 91988:     StyleInfo::FormatColor(aValue.Color(), formattedColor);
 91988:     nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::textUnderlineColor,
 91988:                            formattedColor);
 91988:     return;
 91988:   }
 91988: 
 91988:   if (aValue.IsLineThrough()) {
 91988:     nsAutoString formattedStyle;
 91988:     StyleInfo::FormatTextDecorationStyle(aValue.Style(), formattedStyle);
 91988:     nsAccUtils::SetAccAttr(aAttributes,
 91988:                            nsGkAtoms::textLineThroughStyle,
 91988:                            formattedStyle);
 91988: 
 91988:     nsAutoString formattedColor;
 91988:     StyleInfo::FormatColor(aValue.Color(), formattedColor);
 91988:     nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::textLineThroughColor,
 91988:                            formattedColor);
 91988:   }
 91988: }
 92059: 
 92059: ////////////////////////////////////////////////////////////////////////////////
 92059: // TextPosTextAttr
 92059: ////////////////////////////////////////////////////////////////////////////////
 92059: 
 92059: TextAttrsMgr::TextPosTextAttr::
 92059:   TextPosTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
 92059:   TTextAttr<TextPosValue>(!aFrame)
 92059: {
 92059:   mRootNativeValue = GetTextPosValue(aRootFrame);
 92059:   mIsRootDefined = mRootNativeValue != eTextPosNone;
 92059: 
 92059:   if (aFrame) {
 92059:     mNativeValue = GetTextPosValue(aFrame);
 92059:     mIsDefined = mNativeValue != eTextPosNone;
 92059:   }
 92059: }
 92059: 
 92059: bool
 92059: TextAttrsMgr::TextPosTextAttr::
101616:   GetValueFor(Accessible* aAccessible, TextPosValue* aValue)
 92059: {
101616:   nsIContent* elm = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
101616:   nsIFrame* frame = elm->GetPrimaryFrame();
 92059:   if (frame) {
 92059:     *aValue = GetTextPosValue(frame);
 92059:     return *aValue != eTextPosNone;
 92059:   }
 92059: 
 92059:   return false;
 92059: }
 92059: 
 92059: void
 92059: TextAttrsMgr::TextPosTextAttr::
 92059:   ExposeValue(nsIPersistentProperties* aAttributes, const TextPosValue& aValue)
 92059: {
 92059:   switch (aValue) {
 92059:     case eTextPosBaseline:
 92059:       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::textPosition,
 92059:                              NS_LITERAL_STRING("baseline"));
 92059:       break;
 92059: 
 92059:     case eTextPosSub:
 92059:       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::textPosition,
 92059:                              NS_LITERAL_STRING("sub"));
 92059:       break;
 92059: 
 92059:     case eTextPosSuper:
 92059:       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::textPosition,
 92059:                              NS_LITERAL_STRING("super"));
 92059:       break;
102254: 
102254:     case eTextPosNone:
102254:       break;
 92059:   }
 92059: }
 92059: 
 92059: TextAttrsMgr::TextPosValue
 92059: TextAttrsMgr::TextPosTextAttr::
 92059:   GetTextPosValue(nsIFrame* aFrame) const
 92059: {
132812:   const nsStyleCoord& styleCoord = aFrame->StyleTextReset()->mVerticalAlign;
 92059:   switch (styleCoord.GetUnit()) {
 92059:     case eStyleUnit_Enumerated:
 92059:       switch (styleCoord.GetIntValue()) {
 92059:         case NS_STYLE_VERTICAL_ALIGN_BASELINE:
 92059:           return eTextPosBaseline;
 92059:         case NS_STYLE_VERTICAL_ALIGN_SUB:
 92059:           return eTextPosSub;
 92059:         case NS_STYLE_VERTICAL_ALIGN_SUPER:
 92059:           return eTextPosSuper;
 92059: 
 92059:         // No good guess for these:
 92059:         //   NS_STYLE_VERTICAL_ALIGN_TOP
 92059:         //   NS_STYLE_VERTICAL_ALIGN_TEXT_TOP
 92059:         //   NS_STYLE_VERTICAL_ALIGN_MIDDLE
 92059:         //   NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM
 92059:         //   NS_STYLE_VERTICAL_ALIGN_BOTTOM
 92059:         //   NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE
 92059:         // Do not expose value of text-position attribute.
 92059: 
 92059:         default:
 92059:           break;
 92059:       }
 92059:       return eTextPosNone;
 92059: 
 92059:     case eStyleUnit_Percent:
 92059:     {
 92059:       float percentValue = styleCoord.GetPercentValue();
 92059:       return percentValue > 0 ?
 92059:         eTextPosSuper :
 92059:         (percentValue < 0 ? eTextPosSub : eTextPosBaseline);
 92059:     }
 92059: 
 92059:     case eStyleUnit_Coord:
 92059:     {
 92059:        nscoord coordValue = styleCoord.GetCoordValue();
 92059:        return coordValue > 0 ?
 92059:          eTextPosSuper :
 92059:          (coordValue < 0 ? eTextPosSub : eTextPosBaseline);
 92059:     }
102254: 
102254:     case eStyleUnit_Null:
102254:     case eStyleUnit_Normal:
102254:     case eStyleUnit_Auto:
102254:     case eStyleUnit_None:
102254:     case eStyleUnit_Factor:
102254:     case eStyleUnit_Degree:
102254:     case eStyleUnit_Grad:
102254:     case eStyleUnit_Radian:
102254:     case eStyleUnit_Turn:
102254:     case eStyleUnit_Integer:
102254:     case eStyleUnit_Calc:
102254:       break;
 92059:   }
 92059: 
 94812:   const nsIContent* content = aFrame->GetContent();
 94812:   if (content && content->IsHTML()) {
 94812:     const nsIAtom* tagName = content->Tag();
 94812:     if (tagName == nsGkAtoms::sup) 
 94812:       return eTextPosSuper;
 94812:     if (tagName == nsGkAtoms::sub) 
 94812:       return eTextPosSub;
 94812:   }
 94812: 
 92059:   return eTextPosNone;
 92059: }
