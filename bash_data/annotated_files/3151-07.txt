   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Author: Aaron Leventhal (aaronl@netscape.com)
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsHTMLTableAccessible.h"
   1: #include "nsAccessibilityAtoms.h"
 140: #include "nsAccessibleTreeWalker.h"
   1: #include "nsIDOMElement.h"
1370: #include "nsIDOMDocument.h"
1370: #include "nsIDOMDocumentRange.h"
1370: #include "nsIDOMRange.h"
1370: #include "nsISelection2.h"
1370: #include "nsISelectionPrivate.h"
   1: #include "nsINameSpaceManager.h"
   1: #include "nsIAccessibilityService.h"
   1: #include "nsIDOMCSSStyleDeclaration.h"
   1: #include "nsIDOMHTMLCollection.h"
   1: #include "nsIDOMHTMLTableCellElement.h"
   1: #include "nsIDOMHTMLTableElement.h"
   1: #include "nsIDOMHTMLTableRowElement.h"
   1: #include "nsIDOMHTMLTableSectionElem.h"
   1: #include "nsIDocument.h"
   1: #include "nsIPresShell.h"
   1: #include "nsIServiceManager.h"
   1: #include "nsITableLayout.h"
 666: #include "nsITableCellLayout.h"
   1: 
   1: 
   1: NS_IMPL_ISUPPORTS_INHERITED0(nsHTMLTableCellAccessible, nsHyperTextAccessible)
   1: 
   1: nsHTMLTableCellAccessible::nsHTMLTableCellAccessible(nsIDOMNode* aDomNode, nsIWeakReference* aShell):
 966: nsHyperTextAccessibleWrap(aDomNode, aShell)
   1: { 
   1: }
   1: 
   1: /* unsigned long getRole (); */
   1: NS_IMETHODIMP nsHTMLTableCellAccessible::GetRole(PRUint32 *aResult)
   1: {
   1:   *aResult = nsIAccessibleRole::ROLE_CELL;
   1:   return NS_OK;
   1: }
   1: 
 262: NS_IMETHODIMP
 262: nsHTMLTableCellAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
   1: {
 262:   nsresult rv = nsAccessible::GetState(aState, aExtraState);
 262:   NS_ENSURE_SUCCESS(rv, rv);
 262: 
 262:   // Inherit all states except focusable state since table cells cannot be
 262:   // focused.
 262:   *aState &= ~nsIAccessibleStates::STATE_FOCUSABLE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMPL_ISUPPORTS_INHERITED1(nsHTMLTableAccessible, nsAccessible, nsIAccessibleTable)
   1: 
   1: nsHTMLTableAccessible::nsHTMLTableAccessible(nsIDOMNode* aDomNode, nsIWeakReference* aShell):
   1: nsAccessibleWrap(aDomNode, aShell)
   1: { 
 140: }
 140: 
 140: void nsHTMLTableAccessible::CacheChildren()
 140: {
 140:   if (!mWeakShell) {
 140:     // This node has been shut down
 140:     mAccChildCount = eChildCountUninitialized;
 140:     return;
 140:   }
 140:   
 140:   if (mAccChildCount == eChildCountUninitialized) {
3151:     nsAccessible::CacheChildren();
 140:     nsCOMPtr<nsIAccessible> captionAccessible;
3151:     while (NextChild(captionAccessible)) {
3151:       if (Role(captionAccessible) == nsIAccessibleRole::ROLE_CAPTION) {
3151:         nsCOMPtr<nsIAccessible> captionParentAccessible;
3151:         captionAccessible->GetParent(getter_AddRefs(captionParentAccessible));
3151:         if (captionParentAccessible != this) {
3151:           NS_WARNING("Should not happen: parser ensures caption is the table's child, not the tbody's");
3151:           return;
3151:         }
3151:         nsCOMPtr<nsIAccessible> beforeCaptionAccessible;
3151:         captionAccessible->GetPreviousSibling(getter_AddRefs(beforeCaptionAccessible));
3151:         if (beforeCaptionAccessible) {
3151:           // Move caption accessible so that it's the first child
3151:           nsCOMPtr<nsIAccessible> afterCaptionAccessible;
3151:           captionAccessible->GetNextSibling(getter_AddRefs(afterCaptionAccessible));
3151:           nsCOMPtr<nsPIAccessible> privateAcc = do_QueryInterface(beforeCaptionAccessible);
3151:           privateAcc->SetNextSibling(afterCaptionAccessible);
3151:           GetFirstChild(getter_AddRefs(afterCaptionAccessible));
 140:           SetFirstChild(captionAccessible);
3151:           privateAcc = do_QueryInterface(captionAccessible);
3151:           privateAcc->SetNextSibling(afterCaptionAccessible);        
 140:         }
3151:         // Don't check for more captions, because nsAccessibilityService ensures
3151:         // we don't create accessibles for the other captions, since only the
3151:         // first is actually visible
3151:         break;
 140:       }
 140:     }
 140:   }
   1: }
   1: 
   1: /* unsigned long getRole (); */
   1: NS_IMETHODIMP nsHTMLTableAccessible::GetRole(PRUint32 *aResult)
   1: {
   1:   *aResult = nsIAccessibleRole::ROLE_TABLE;
   1:   return NS_OK;
   1: }
   1: 
 262: NS_IMETHODIMP
 262: nsHTMLTableAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
   1: {
 262:   nsresult rv= nsAccessible::GetState(aState, aExtraState);
 262:   NS_ENSURE_SUCCESS(rv, rv);
 262: 
 262:   *aState |= nsIAccessibleStates::STATE_READONLY;
 262:   // Inherit all states except focusable state since tables cannot be focused.
 262:   *aState &= ~nsIAccessibleStates::STATE_FOCUSABLE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLTableAccessible::GetName(nsAString& aName)
   1: {
   1:   aName.Truncate();  // Default name is blank
   1: 
   1:   nsAccessible::GetName(aName);
3151:   if (aName.IsEmpty()) {
3151:     nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
3151:     if (content) { 
3151:       content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::summary, aName);
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
 401: nsresult
 401: nsHTMLTableAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
   1: {
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;  // Node already shut down
   1:   }
   1: 
 401:   nsresult rv = nsAccessibleWrap::GetAttributesInternal(aAttributes);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
   1:   PRBool isProbablyForLayout;
   1:   IsProbablyForLayout(&isProbablyForLayout);
   1:   if (isProbablyForLayout) {
   1:     nsAutoString oldValueUnused;
 401:     aAttributes->SetStringProperty(NS_LITERAL_CSTRING("layout-guess"),
 401:                                    NS_LITERAL_STRING("true"), oldValueUnused);
   1:   }
   1:   
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
3151: nsHTMLTableAccessible::GetAccessibleRelated(PRUint32 aRelationType,
3151:                                             nsIAccessible **aRelated)
   1: {
3151:   NS_ENSURE_ARG_POINTER(aRelated);
3151:   *aRelated = nsnull;
   1: 
3151:   if (!mDOMNode) {
3151:     return NS_ERROR_FAILURE;
3151:   }
   1: 
3151:   nsresult rv = nsAccessibleWrap::GetAccessibleRelated(aRelationType, aRelated);
3151:   if (NS_FAILED(rv) || *aRelated) {
3151:     // Either the node is shut down, or another relation mechanism has been used
3151:     return rv;
3151:   }
   1: 
3151:   if (aRelationType == nsIAccessibleRelation::RELATION_DESCRIBED_BY) {
3151:     return GetCaption(aRelated);
3151:   }
3151: 
1560:   return NS_OK;
1560: }
   1: 
   1: 
   1: NS_IMETHODIMP
3151: nsHTMLTableAccessible::GetCaption(nsIAccessible **aCaption)
   1: {
3151:   nsCOMPtr<nsIAccessible> firstChild;
3151:   GetFirstChild(getter_AddRefs(firstChild));
3151:   if (firstChild && Role(firstChild) == nsIAccessibleRole::ROLE_CAPTION) {
3151:     NS_ADDREF(*aCaption = firstChild);
3151:   }
3151:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetSummary(nsAString &aSummary)
   1: {
   1:   nsCOMPtr<nsIDOMHTMLTableElement> table(do_QueryInterface(mDOMNode));
   1:   NS_ENSURE_TRUE(table, NS_ERROR_FAILURE);
   1: 
   1:   return table->GetSummary(aSummary);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetColumns(PRInt32 *aColumns)
   1: {
   1:   nsITableLayout *tableLayout;
   1:   nsresult rv = GetTableLayout(&tableLayout);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRInt32 rows;
   1:   return tableLayout->GetTableSize(rows, *aColumns);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetColumnHeader(nsIAccessibleTable **aColumnHeader)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsCOMPtr<nsIDOMHTMLTableElement> table(do_QueryInterface(mDOMNode));
   1:   NS_ENSURE_TRUE(table, NS_ERROR_FAILURE);
   1: 
   1:   nsCOMPtr<nsIDOMHTMLTableSectionElement> section;
   1:   rv = table->GetTHead(getter_AddRefs(section));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIAccessibilityService>
   1:     accService(do_GetService("@mozilla.org/accessibilityService;1"));
   1:   NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);
   1: 
   1:   nsCOMPtr<nsIAccessible> accHead;
   1:   nsCOMPtr<nsIDOMNode> sectionNode(do_QueryInterface(section));
   1:   if (sectionNode) {
   1:     rv = accService->GetCachedAccessible(sectionNode, mWeakShell,
   1:                                          getter_AddRefs(accHead));
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
   1:   if (!accHead) {
   1:      accService->CreateHTMLTableHeadAccessible(section,
   1:                                                getter_AddRefs(accHead));
   1:                                                    
   1:     nsCOMPtr<nsPIAccessNode> accessNode(do_QueryInterface(accHead));
   1:     NS_ENSURE_TRUE(accHead, NS_ERROR_FAILURE);
   1:     rv = accessNode->Init();
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessibleTable> accTableHead(do_QueryInterface(accHead));
   1:   NS_ENSURE_TRUE(accTableHead, NS_ERROR_FAILURE);
   1: 
   1:   *aColumnHeader = accTableHead;
   1:   NS_IF_ADDREF(*aColumnHeader);
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetRows(PRInt32 *aRows)
   1: {
   1:   nsITableLayout *tableLayout;
   1:   nsresult rv = GetTableLayout(&tableLayout);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRInt32 columns;
   1:   return tableLayout->GetTableSize(*aRows, columns);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetRowHeader(nsIAccessibleTable **aRowHeader)
   1: {
   1:   // Can not implement because there is no row header in html table
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetSelectedColumns(PRUint32 *aNumColumns,
   1:                                           PRInt32 **aColumns)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   PRInt32 columnCount;
   1:   rv = GetColumns(&columnCount);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRBool *states = new PRBool[columnCount];
   1:   NS_ENSURE_TRUE(states, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   *aNumColumns = 0;
   1:   PRInt32 index;
   1:   for (index = 0; index < columnCount; index++) {
   1:     rv = IsColumnSelected(index, &states[index]);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     if (states[index]) {
   1:       (*aNumColumns)++;
   1:     }
   1:   }
   1: 
   1:   PRInt32 *outArray = (PRInt32 *)nsMemory::Alloc((*aNumColumns) * sizeof(PRInt32));
   1:   if (!outArray) {
   1:     delete []states;
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   PRInt32 curr = 0;
   1:   for (index = 0; index < columnCount; index++) {
   1:     if (states[index]) {
   1:       outArray[curr++] = index;
   1:     }
   1:   }
   1: 
   1:   delete []states;
   1:   *aColumns = outArray;
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetSelectedRows(PRUint32 *aNumRows, PRInt32 **aRows)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   PRInt32 rowCount;
   1:   rv = GetRows(&rowCount);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRBool *states = new PRBool[rowCount];
   1:   NS_ENSURE_TRUE(states, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   *aNumRows = 0;
   1:   PRInt32 index;
   1:   for (index = 0; index < rowCount; index++) {
   1:     rv = IsRowSelected(index, &states[index]);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     if (states[index]) {
   1:       (*aNumRows)++;
   1:     }
   1:   }
   1: 
   1:   PRInt32 *outArray = (PRInt32 *)nsMemory::Alloc((*aNumRows) * sizeof(PRInt32));
   1:   if (!outArray) {
   1:     delete []states;
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   PRInt32 curr = 0;
   1:   for (index = 0; index < rowCount; index++) {
   1:     if (states[index]) {
   1:       outArray[curr++] = index;
   1:     }
   1:   }
   1: 
   1:   delete []states;
   1:   *aRows = outArray;
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::CellRefAt(PRInt32 aRow, PRInt32 aColumn,
   1:                                  nsIAccessible **aTableCellAccessible)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsCOMPtr<nsIDOMElement> cellElement;
   1:   rv = GetCellAt(aRow, aColumn, *getter_AddRefs(cellElement));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIAccessibilityService>
   1:     accService(do_GetService("@mozilla.org/accessibilityService;1"));
   1:   NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);
   1: 
   1:   return accService->GetAccessibleInWeakShell(cellElement, mWeakShell,
   1:                                               aTableCellAccessible);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetIndexAt(PRInt32 aRow, PRInt32 aColumn,
 666:                                   PRInt32 *aIndex)
   1: {
 666:   NS_ENSURE_ARG_POINTER(aIndex);
   1: 
   1:   nsresult rv = NS_OK;
 666:   nsCOMPtr<nsIDOMElement> domElement;
 666:   rv = GetCellAt(aRow, aColumn, *getter_AddRefs(domElement));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
 666:   nsCOMPtr<nsIAccessible> accessible;
 666:   GetAccService()->GetCachedAccessible(domElement, mWeakShell, getter_AddRefs(accessible));
 666:   if (accessible) {
 666:     rv = accessible->GetIndexInParent(aIndex);
 666:   } else {
 666:     // not found the corresponding cell
 666:     *aIndex = -1;
 140:   }
 666:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
 666: nsHTMLTableAccessible::GetColumnAtIndex(PRInt32 aIndex, PRInt32 *aColumn)
   1: {
 666:   NS_ENSURE_ARG_POINTER(aColumn);
   1: 
 666:   nsCOMPtr<nsIAccessible> child;
 666:   GetChildAt(aIndex, getter_AddRefs(child));
 666:   nsCOMPtr<nsPIAccessNode> childNode(do_QueryInterface(child));
 666:   nsIFrame* frame = childNode->GetFrame();
 666:   nsCOMPtr<nsITableCellLayout> cellLayout(do_QueryInterface(frame));
 666:   NS_ENSURE_TRUE(cellLayout, NS_ERROR_FAILURE);
 666:   return cellLayout->GetColIndex(*aColumn);
   1: }
   1: 
   1: NS_IMETHODIMP
 666: nsHTMLTableAccessible::GetRowAtIndex(PRInt32 aIndex, PRInt32 *aRow)
   1: {
 666:   NS_ENSURE_ARG_POINTER(aRow);
   1: 
 666:   nsCOMPtr<nsIAccessible> child;
 666:   GetChildAt(aIndex, getter_AddRefs(child));
 666:   nsCOMPtr<nsPIAccessNode> childNode(do_QueryInterface(child));
 666:   nsIFrame* frame = childNode->GetFrame();
 666:   nsCOMPtr<nsITableCellLayout> cellLayout(do_QueryInterface(frame));
 666:   NS_ENSURE_TRUE(cellLayout, NS_ERROR_FAILURE);
 666:   return cellLayout->GetRowIndex(*aRow);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetColumnExtentAt(PRInt32 aRow, PRInt32 aColumn,
   1:                                          PRInt32 *_retval)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsCOMPtr<nsIDOMElement> domElement;
   1:   rv = GetCellAt(aRow, aColumn, *getter_AddRefs(domElement));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIDOMHTMLTableCellElement> cell(do_QueryInterface(domElement));
   1:   NS_ENSURE_TRUE(cell, NS_ERROR_FAILURE);
   1: 
   1:   return cell->GetColSpan(_retval);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetRowExtentAt(PRInt32 aRow, PRInt32 aColumn,
   1:                                       PRInt32 *_retval)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsCOMPtr<nsIDOMElement> domElement;
   1:   rv = GetCellAt(aRow, aColumn, *getter_AddRefs(domElement));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIDOMHTMLTableCellElement> cell(do_QueryInterface(domElement));
   1:   NS_ENSURE_TRUE(cell, NS_ERROR_FAILURE);
   1: 
   1:   return cell->GetRowSpan(_retval);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetColumnDescription(PRInt32 aColumn, nsAString &_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::GetRowDescription(PRInt32 aRow, nsAString &_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::IsColumnSelected(PRInt32 aColumn, PRBool *_retval)
   1: {
   1:   NS_ENSURE_ARG_POINTER(_retval);
   1: 
   1:   nsresult rv = NS_OK;
   1: 
   1:   PRInt32 rows;
   1:   rv = GetRows(&rows);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   for (PRInt32 index = 0; index < rows; index++) {
   1:     rv = IsCellSelected(index, aColumn, _retval);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     if (!*_retval) {
   1:       break;
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::IsRowSelected(PRInt32 aRow, PRBool *_retval)
   1: {
   1:   NS_ENSURE_ARG_POINTER(_retval);
   1: 
   1:   nsresult rv = NS_OK;
   1: 
   1:   PRInt32 columns;
   1:   rv = GetColumns(&columns);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   for (PRInt32 index = 0; index < columns; index++) {
   1:     rv = IsCellSelected(aRow, index, _retval);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     if (!*_retval) {
   1:       break;
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableAccessible::IsCellSelected(PRInt32 aRow, PRInt32 aColumn,
   1:                                       PRBool *_retval)
   1: {
   1:   nsITableLayout *tableLayout;
   1:   nsresult rv = GetTableLayout(&tableLayout);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIDOMElement> domElement;
   1:   PRInt32 startRowIndex = 0, startColIndex = 0,
   1:           rowSpan, colSpan, actualRowSpan, actualColSpan;
   1: 
   1:   return tableLayout->GetCellDataAt(aRow, aColumn,
   1:                                     *getter_AddRefs(domElement),
   1:                                     startRowIndex, startColIndex, rowSpan,
   1:                                     colSpan, actualRowSpan, actualColSpan,
   1:                                     *_retval);
   1: }
   1: 
1370: NS_IMETHODIMP
1370: nsHTMLTableAccessible::SelectRow(PRInt32 aRow)
1370: {
1370:   return SelectRowOrColumn(aRow, nsISelectionPrivate::TABLESELECTION_ROW,
1370:                            PR_TRUE);
1370: }
1370: 
1370: NS_IMETHODIMP
1370: nsHTMLTableAccessible::SelectColumn(PRInt32 aColumn)
1370: {
1370:   return SelectRowOrColumn(aColumn, nsISelectionPrivate::TABLESELECTION_COLUMN,
1370:                            PR_TRUE);
1370: }
1370: 
1370: NS_IMETHODIMP
1370: nsHTMLTableAccessible::UnselectRow(PRInt32 aRow)
1370: {
1370:   return SelectRowOrColumn(aRow, nsISelectionPrivate::TABLESELECTION_ROW,
1370:                            PR_FALSE);
1370: }
1370: 
1370: NS_IMETHODIMP
1370: nsHTMLTableAccessible::UnselectColumn(PRInt32 aColumn)
1370: {
1370:   return SelectRowOrColumn(aColumn, nsISelectionPrivate::TABLESELECTION_COLUMN,
1370:                            PR_FALSE);
1370: }
1370: 
1370: nsresult
1370: nsHTMLTableAccessible::SelectRowOrColumn(PRInt32 aIndex, PRUint32 aTarget,
1370:                                          PRBool aDoSelect)
1370: {
1370:   PRBool doSelectRow = (aTarget == nsISelectionPrivate::TABLESELECTION_ROW);
1370: 
1370:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
1370:   if (!content)
1370:     return NS_OK;
1370: 
1370:   nsCOMPtr<nsIDocument> document = content->GetCurrentDoc();
1370:   NS_ENSURE_STATE(document);
1370: 
1370:   nsCOMPtr<nsISelectionController> selController(
1370:     do_QueryInterface(document->GetPrimaryShell()));
1370:   NS_ENSURE_STATE(selController);
1370: 
1370:   nsCOMPtr<nsISelection> selection;
1370:   selController->GetSelection(nsISelectionController::SELECTION_NORMAL,
1370:                               getter_AddRefs(selection));
1370:   NS_ENSURE_STATE(selection);
1370: 
1370:   PRInt32 count = 0;
1370:   nsresult rv = doSelectRow ? GetColumns(&count) : GetRows(&count);
1370:   NS_ENSURE_SUCCESS(rv, rv);
1370: 
1370:   for (PRInt32 index = 0; index < count; index++) {
1370:     nsCOMPtr<nsIDOMElement> cellElm;
1370:     PRInt32 column = doSelectRow ? index : aIndex;
1370:     PRInt32 row = doSelectRow ? aIndex : index;
1370: 
1370:     rv = GetCellAt(row, column, *getter_AddRefs(cellElm));
1370:     NS_ENSURE_SUCCESS(rv, rv);
1370: 
1370:     rv = SelectCell(selection, document, cellElm, aDoSelect);
1370:     NS_ENSURE_SUCCESS(rv, rv);
1370:   }
1382:   
1382:   return NS_OK;
1370: }
1370: 
1370: nsresult
1370: nsHTMLTableAccessible::SelectCell(nsISelection *aSelection,
1370:                                   nsIDocument *aDocument,
1370:                                   nsIDOMElement *aCellElement,
1370:                                   PRBool aDoSelect)
1370: {
1370:   if (aDoSelect) {
1370:     nsCOMPtr<nsIDOMDocumentRange> documentRange(do_QueryInterface(aDocument));
1370:     NS_ENSURE_STATE(documentRange);
1370: 
1370:     nsCOMPtr<nsIDOMRange> range;
1370:     documentRange->CreateRange(getter_AddRefs(range));
1370: 
1370:     nsCOMPtr<nsIDOMNode> cellNode(do_QueryInterface(aCellElement));
1370:     NS_ENSURE_STATE(cellNode);
1370: 
1370:     range->SelectNode(cellNode);
1370:     return aSelection->AddRange(range);
1370:   }
1370: 
1370:   nsCOMPtr<nsIContent> cell(do_QueryInterface(aCellElement));
1370:   NS_ENSURE_STATE(cell);
1370: 
1370:   nsCOMPtr<nsIContent> cellParent = cell->GetParent();
1370:   NS_ENSURE_STATE(cellParent);
1370: 
1370:   PRInt32 offset = cellParent->IndexOf(cell);
1370:   NS_ENSURE_STATE(offset != -1);
1370: 
1370:   nsCOMPtr<nsIDOMNode> parent(do_QueryInterface(cellParent));
1370:   NS_ENSURE_STATE(parent);
1370: 
1370:   nsCOMPtr<nsISelection2> selection2(do_QueryInterface(aSelection));
1370:   NS_ENSURE_STATE(selection2);
1370: 
1370:   nsCOMArray<nsIDOMRange> ranges;
1370:   nsresult rv = selection2->GetRangesForIntervalCOMArray(parent, offset,
1370:                                                          parent, offset,
1370:                                                          PR_TRUE, &ranges);
1370:   NS_ENSURE_SUCCESS(rv, rv);
1370: 
1370:   for (PRInt32 i = 0; i < ranges.Count(); i ++)
1370:     aSelection->RemoveRange(ranges[i]);
1370: 
1370:   return NS_OK;
1370: }
1370: 
   1: nsresult
   1: nsHTMLTableAccessible::GetTableNode(nsIDOMNode **_retval)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsCOMPtr<nsIDOMHTMLTableElement> table(do_QueryInterface(mDOMNode));
   1:   if (table) {
   1:     *_retval = table;
   1:     NS_IF_ADDREF(*_retval);
   1:     return rv;
   1:   }
   1: 
   1:   nsCOMPtr<nsIDOMHTMLTableSectionElement> section(do_QueryInterface(mDOMNode));
   1:   if (section) {
   1:     nsCOMPtr<nsIDOMNode> parent;
   1:     rv = section->GetParentNode(getter_AddRefs(parent));
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     *_retval = parent;
   1:     NS_IF_ADDREF(*_retval);
   1:     return rv;
   1:   }
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: nsresult
   1: nsHTMLTableAccessible::GetTableLayout(nsITableLayout **aLayoutObject)
   1: {
   1:   *aLayoutObject = nsnull;
   1: 
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsCOMPtr<nsIDOMNode> tableNode;
   1:   rv = GetTableNode(getter_AddRefs(tableNode));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(tableNode));
   1:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
   1: 
 981:   nsIPresShell *presShell = content->GetDocument()->GetPrimaryShell();
   1: 
   1:   nsCOMPtr<nsISupports> layoutObject;
   1:   rv = presShell->GetLayoutObjectFor(content, getter_AddRefs(layoutObject));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return CallQueryInterface(layoutObject, aLayoutObject);
   1: }
   1: 
   1: nsresult
   1: nsHTMLTableAccessible::GetCellAt(PRInt32        aRowIndex,
   1:                                  PRInt32        aColIndex,
   1:                                  nsIDOMElement* &aCell)
   1: {
   1:   PRInt32 startRowIndex = 0, startColIndex = 0,
   1:           rowSpan, colSpan, actualRowSpan, actualColSpan;
   1:   PRBool isSelected;
   1: 
   1:   nsITableLayout *tableLayout;
   1:   nsresult rv = GetTableLayout(&tableLayout);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return tableLayout->GetCellDataAt(aRowIndex, aColIndex, aCell,
   1:                                     startRowIndex, startColIndex,
   1:                                     rowSpan, colSpan,
   1:                                     actualRowSpan, actualColSpan,
   1:                                     isSelected);
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLTableAccessible::GetDescription(nsAString& aDescription)
   1: {
   1:   // Helpful for debugging layout vs. data tables
   1:   aDescription.Truncate();
3151:   nsAccessible::GetDescription(aDescription);
3151:   if (!aDescription.IsEmpty()) {
3151:     return NS_OK;
3151:   }
3151: 
3151:   nsCOMPtr<nsIAccessible> captionAccessible;
3151:   GetCaption(getter_AddRefs(captionAccessible));
3151:   nsCOMPtr<nsIAccessNode> captionAccessNode = do_QueryInterface(captionAccessible);
3151:   if (captionAccessNode) {
3151:     nsCOMPtr<nsIDOMNode> captionNode;
3151:     captionAccessNode->GetDOMNode(getter_AddRefs(captionNode));
3151:     nsCOMPtr<nsIContent> captionContent = do_QueryInterface(captionNode);
3151:     if (captionContent) {
3151:       AppendFlatStringFromSubtree(captionContent, &aDescription);
3151:     }
3151:   }
3151: #ifdef SHOW_LAYOUT_HEURISTIC
3151:   if (aDescription.IsEmpty()) {
   1:     PRBool isProbablyForLayout;
   1:     IsProbablyForLayout(&isProbablyForLayout);
   1:     aDescription = mLayoutHeuristic;
3151:   }
   1: #ifdef DEBUG_A11Y
   1:   printf("\nTABLE: %s\n", NS_ConvertUTF16toUTF8(mLayoutHeuristic).get());
   1: #endif
3151: #endif
3151: 
   1:   return NS_OK;
   1: }
   1: 
 438: PRBool nsHTMLTableAccessible::HasDescendant(char *aTagName, PRBool aAllowEmpty)
   1: {
   1:   nsCOMPtr<nsIDOMElement> tableElt(do_QueryInterface(mDOMNode));
   1:   NS_ENSURE_TRUE(tableElt, PR_FALSE);
   1: 
   1:   nsCOMPtr<nsIDOMNodeList> nodeList;
   1:   nsAutoString tagName;
   1:   tagName.AssignWithConversion(aTagName);
   1:   tableElt->GetElementsByTagName(tagName, getter_AddRefs(nodeList));
   1:   NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
   1:   PRUint32 length;
   1:   nodeList->GetLength(&length);
   1:   
   1:   if (length == 1) {
   1:     // Make sure it's not the table itself
 438:     nsCOMPtr<nsIDOMNode> foundItem;
 438:     nodeList->Item(0, getter_AddRefs(foundItem));
 438:     if (foundItem == mDOMNode) {
 438:       return PR_FALSE;
 438:     }
 438:     if (!aAllowEmpty) {
 438:       // Make sure that the item we found has contents
 438:       // and either has multiple children or the
 438:       // found item is not a whitespace-only text node
 438:       nsCOMPtr<nsIContent> foundItemContent = do_QueryInterface(foundItem);
 438:       if (!foundItemContent) {
 438:         return PR_FALSE;
 438:       }
 438:       if (foundItemContent->GetChildCount() > 1) {
 438:         return PR_TRUE; // Treat multiple child nodes as non-empty
 438:       }
 438:       nsIContent *innerItemContent = foundItemContent->GetChildAt(0);
 438:       if (!innerItemContent || innerItemContent->TextIsOnlyWhitespace()) {
 438:         return PR_FALSE;
 438:       }
 438:     }
 438:     return PR_TRUE;
   1:   }
   1: 
   1:   return length > 0;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLTableAccessible::IsProbablyForLayout(PRBool *aIsProbablyForLayout)
   1: {
   1:   // Implement a heuristic to determine if table is most likely used for layout
   1:   // XXX do we want to look for rowspan or colspan, especialy that span all but a couple cells
   1:   // at the beginning or end of a row/col, and especially when they occur at the edge of a table?
   1:   // XXX expose this info via object attributes to AT-SPI
   1: 
   1:   // XXX For now debugging descriptions are always on via SHOW_LAYOUT_HEURISTIC
   1:   // This will allow release trunk builds to be used by testers to refine the algorithm
   1:   // Change to |#define SHOW_LAYOUT_HEURISTIC DEBUG| before final release
   1: #ifdef SHOW_LAYOUT_HEURISTIC
   1: #define RETURN_LAYOUT_ANSWER(isLayout, heuristic) \
   1:   { *aIsProbablyForLayout = isLayout; \
   1:     mLayoutHeuristic = isLayout ? NS_LITERAL_STRING("layout table: ") : NS_LITERAL_STRING("data table: "); \
   1:     mLayoutHeuristic += NS_LITERAL_STRING(heuristic); return NS_OK; }
   1: #else
   1: #define RETURN_LAYOUT_ANSWER(isLayout, heuristic) { *aIsProbablyForLayout = isLayout; return NS_OK; }
   1: #endif
   1: 
   1:   *aIsProbablyForLayout = PR_FALSE;
   1:   
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
   1:   if (!content) {
   1:     return NS_ERROR_FAILURE; // Table shut down
   1:   }
   1: 
 512:   nsCOMPtr<nsIAccessible> docAccessible = do_QueryInterface(nsCOMPtr<nsIAccessibleDocument>(GetDocAccessible()));
 512:   if (docAccessible) {
 512:     PRUint32 state, extState;
 512:     docAccessible->GetFinalState(&state, &extState);
 512:     if (extState & nsIAccessibleStates::EXT_STATE_EDITABLE) {  // Need to see all elements while document is being edited
 512:       RETURN_LAYOUT_ANSWER(PR_FALSE, "In editable document");
 512:     }
 512:   }
 512: 
   1:   // Check role and role attribute
   1:   PRBool hasNonTableRole = (Role(this) != nsIAccessibleRole::ROLE_TABLE);
   1:   if (hasNonTableRole) {
   1:     RETURN_LAYOUT_ANSWER(PR_FALSE, "Has role attribute");
   1:   }
   1: 
   1:   if (HasRoleAttribute(content)) {
   1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "Has role attribute, and role is table");
   1:   }
   1:   
   1:   // Check for legitimate data table elements or attributes
 438:   nsAutoString summary;
 438:   if ((content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::summary, summary) && !summary.IsEmpty()) || 
 438:       HasDescendant("caption", PR_FALSE) || HasDescendant("th") || HasDescendant("thead") ||
 438:       HasDescendant("tfoot")   || HasDescendant("colgroup")) {
   1:     RETURN_LAYOUT_ANSWER(PR_FALSE, "Has caption, summary, th, thead, tfoot or colgroup -- legitimate table structures");
   1:   }
   1:   if (HasDescendant("table")) {
   1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "Has a nested table within it");
   1:   }
   1:   
   1:   // If only 1 column or only 1 row, it's for layout
   1:   PRInt32 columns, rows;
   1:   GetColumns(&columns);
   1:   if (columns <=1) {
   1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "Has only 1 column");
   1:   }
   1:   GetRows(&rows);
   1:   if (rows <=1) {
   1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "Has only 1 row");
   1:   }
   1: 
   1:   // Check for many columns
   1:   if (columns >= 5) {
   1:     RETURN_LAYOUT_ANSWER(PR_FALSE, ">=5 columns");
   1:   }
   1:   
   1:   // Now we know there are 2-4 columns and 2 or more rows
   1:   // Check to see if there are visible borders on the cells
   1:   // XXX currently, we just check the first cell -- do we really need to do more?
   1:   nsCOMPtr<nsIDOMElement> cellElement;
   1:   GetCellAt(0, 0, *getter_AddRefs(cellElement));
   1:   nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElement));
   1:   NS_ENSURE_TRUE(cellContent, NS_ERROR_FAILURE);
   1:   nsCOMPtr<nsIPresShell> shell(GetPresShell());
   1:   nsIFrame *cellFrame = shell->GetPrimaryFrameFor(cellContent);
1560:   if (!cellFrame) {
1560:     return NS_OK;
1560:   }
   1:   nsMargin border;
   1:   cellFrame->GetBorder(border);
   1:   if (border.top && border.bottom && border.left && border.right) {
   1:     RETURN_LAYOUT_ANSWER(PR_FALSE, "Has nonzero border-width on table cell");
   1:   }
   1: 
   1:   /**
   1:    * Rules for non-bordered tables with 2-4 columns and 2+ rows from here on forward
   1:    */
   1: 
   1:   // Check for styled background color across the row
   1:   // Alternating background color is a common way 
   1:   nsCOMPtr<nsIDOMNodeList> nodeList;
   1:   nsCOMPtr<nsIDOMElement> tableElt(do_QueryInterface(mDOMNode));    
   1:   tableElt->GetElementsByTagName(NS_LITERAL_STRING("tr"), getter_AddRefs(nodeList));
   1:   NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
   1:   PRUint32 length;
   1:   nodeList->GetLength(&length);
   1:   nsAutoString color, lastRowColor;
   1:   for (PRInt32 rowCount = 0; rowCount < rows; rowCount ++) {
   1:     nsCOMPtr<nsIDOMNode> rowNode;
   1:     nodeList->Item(rowCount, getter_AddRefs(rowNode));
   1:     nsCOMPtr<nsIDOMElement> rowElement = do_QueryInterface(rowNode);
   1:     nsCOMPtr<nsIDOMCSSStyleDeclaration> styleDecl;
   1:     GetComputedStyleDeclaration(EmptyString(), rowElement, getter_AddRefs(styleDecl));
   1:     NS_ENSURE_TRUE(styleDecl, NS_ERROR_FAILURE);
   1:     lastRowColor = color;
   1:     styleDecl->GetPropertyValue(NS_LITERAL_STRING("background-color"), color);
   1:     if (rowCount > 0 && PR_FALSE == lastRowColor.Equals(color)) {
   1:       RETURN_LAYOUT_ANSWER(PR_FALSE, "2 styles of row background color, non-bordered");
   1:     }
   1:   }
   1: 
   1:   // Check for many rows
   1:   const PRInt32 kMaxLayoutRows = 20;
   1:   if (rows > kMaxLayoutRows) { // A ton of rows, this is probably for data
   1:     RETURN_LAYOUT_ANSWER(PR_FALSE, ">= kMaxLayoutRows (20) and non-bordered");
   1:   }
   1: 
   1:   // Check for very wide table
   1:   nsAutoString styledWidth;
   1:   GetComputedStyleValue(EmptyString(), NS_LITERAL_STRING("width"), styledWidth);
   1:   if (styledWidth.EqualsLiteral("100%")) {
   1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "<=4 columns and 100% width");
   1:   }
   1:   if (styledWidth.Find(NS_LITERAL_STRING("px"))) { // Hardcoded in pixels
   1:     nsIFrame *tableFrame = GetFrame();
   1:     NS_ENSURE_TRUE(tableFrame , NS_ERROR_FAILURE);
   1:     nsSize tableSize  = tableFrame->GetSize();
   1:     nsCOMPtr<nsIAccessibleDocument> docAccessible = GetDocAccessible();
   1:     nsCOMPtr<nsPIAccessNode> docAccessNode(do_QueryInterface(docAccessible));
   1:     NS_ENSURE_TRUE(docAccessNode, NS_ERROR_FAILURE);
   1:     nsIFrame *docFrame = docAccessNode->GetFrame();
   1:     NS_ENSURE_TRUE(docFrame , NS_ERROR_FAILURE);
   1:     nsSize docSize = docFrame->GetSize();
   1:     PRInt32 percentageOfDocWidth = (100 * tableSize.width) / docSize.width;
   1:     if (percentageOfDocWidth > 95) {
   1:       // 3-4 columns, no borders, not a lot of rows, and 95% of the doc's width
   1:       // Probably for layout
   1:       RETURN_LAYOUT_ANSWER(PR_TRUE, "<=4 columns, width hardcoded in pixels and 95% of document width");
   1:     }
   1:   }
   1: 
   1:   // Two column rules
   1:   if (rows * columns <= 10) {
   1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "2-4 columns, 10 cells or less, non-bordered");
   1:   }
   1: 
   1:   if (HasDescendant("embed") || HasDescendant("object") || HasDescendant("applet") || HasDescendant("iframe")) {
   1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "Has no borders, and has iframe, object, applet or iframe, typical of advertisements");
   1:   }
   1: 
   1:   RETURN_LAYOUT_ANSWER(PR_FALSE, "no layout factor strong enough, so will guess data");
   1: }
   1: 
   1: // --------------------------------------------------------
   1: // nsHTMLTableHeadAccessible Accessible
   1: // --------------------------------------------------------
   1: NS_IMPL_ISUPPORTS_INHERITED0(nsHTMLTableHeadAccessible, nsHTMLTableAccessible)
   1: 
   1: nsHTMLTableHeadAccessible::nsHTMLTableHeadAccessible(nsIDOMNode *aDomNode, nsIWeakReference *aShell):
   1: nsHTMLTableAccessible(aDomNode, aShell)
   1: {
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableHeadAccessible::GetRole(PRUint32 *aResult)
   1: {
   1:   *aResult = nsIAccessibleRole::ROLE_COLUMNHEADER;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableHeadAccessible::GetCaption(nsIAccessible **aCaption)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableHeadAccessible::GetSummary(nsAString &aSummary)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableHeadAccessible::GetColumnHeader(nsIAccessibleTable **aColumnHeader)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsHTMLTableHeadAccessible::GetRows(PRInt32 *aRows)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsCOMPtr<nsIDOMHTMLTableSectionElement> head(do_QueryInterface(mDOMNode));
   1:   NS_ENSURE_TRUE(head, NS_ERROR_FAILURE);
   1: 
   1:   nsCOMPtr<nsIDOMHTMLCollection> rows;
   1:   rv = head->GetRows(getter_AddRefs(rows));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return rows->GetLength((PRUint32 *)aRows);
   1: }
   1: 
3151: NS_IMETHODIMP
3151: nsHTMLCaptionAccessible::GetAccessibleRelated(PRUint32 aRelationType,
3151:                                               nsIAccessible **aRelated)
3151: {
3151:   NS_ENSURE_ARG_POINTER(aRelated);
3151:   *aRelated = nsnull;
3151: 
3151:   if (!mDOMNode) {
3151:     return NS_ERROR_FAILURE;
3151:   }
3151: 
3151:   nsresult rv = nsHyperTextAccessible::GetAccessibleRelated(aRelationType, aRelated);
3151:   if (NS_FAILED(rv) || *aRelated) {
3151:     // Either the node is shut down, or another relation mechanism has been used
3151:     return rv;
3151:   }
3151: 
3151:   if (aRelationType == nsIAccessibleRelation::RELATION_DESCRIPTION_FOR) {
3151:     return GetParent(aRelated);
3151:   }
3151: 
3151:   return NS_OK;
3151: }
3151: 
3151: 
3151: 
