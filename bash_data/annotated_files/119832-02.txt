     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "prlog.h"
     1: #include "nsEntropyCollector.h"
119832: #include "nsMemory.h"
 43739: #include "nsAlgorithm.h"
     1: 
     1: nsEntropyCollector::nsEntropyCollector()
     1: :mBytesCollected(0), mWritePointer(mEntropyCache)
     1: {
     1:   // We could use the uninitialized memory in mEntropyCache as initial
     1:   // random data, but that means (if any entropy is collected before NSS
     1:   // initialization and then forwarded) that we'll get warnings from
     1:   // tools like valgrind for every later operation that depends on the
     1:   // entropy.
     1:   memset(mEntropyCache, 0, sizeof(mEntropyCache));
     1: }
     1: 
     1: nsEntropyCollector::~nsEntropyCollector()
     1: {
     1: }
     1: 
     1: NS_IMPL_THREADSAFE_ISUPPORTS2(nsEntropyCollector,
     1:                               nsIEntropyCollector,
     1:                               nsIBufEntropyCollector)
     1: 
     1: NS_IMETHODIMP
108991: nsEntropyCollector::RandomUpdate(void *new_entropy, int32_t bufLen)
     1: {
     1:   if (bufLen > 0) {
     1:     if (mForwardTarget) {
     1:       return mForwardTarget->RandomUpdate(new_entropy, bufLen);
     1:     }
     1:     else {
     1:       const unsigned char *InputPointer = (const unsigned char *)new_entropy;
     1:       const unsigned char *PastEndPointer = mEntropyCache + entropy_buffer_size;
     1: 
     1:       // if the input is large, we only take as much as we can store
108991:       int32_t bytes_wanted = NS_MIN(bufLen, int32_t(entropy_buffer_size));
     1: 
     1:       // remember the number of bytes we will have after storing new_entropy
108991:       mBytesCollected = NS_MIN(int32_t(entropy_buffer_size),
 43739:                                mBytesCollected + bytes_wanted);
     1: 
     1:       // as the above statements limit bytes_wanted to the entropy_buffer_size,
     1:       // this loop will iterate at most twice.
     1:       while (bytes_wanted > 0) {
     1: 
     1:         // how many bytes to end of cyclic buffer?
108991:         const int32_t space_to_end = PastEndPointer - mWritePointer;
     1: 
     1:         // how many bytes can we copy, not reaching the end of the buffer?
108991:         const int32_t this_time = NS_MIN(space_to_end, bytes_wanted);
     1: 
     1:         // copy at most to the end of the cyclic buffer
108991:         for (int32_t i = 0; i < this_time; ++i) {
     1: 
     1:           unsigned int old = *mWritePointer;
     1: 
     1:           // combine new and old value already stored in buffer
     1:           // this logic comes from PSM 1
     1:           *mWritePointer++ = ((old << 1) | (old >> 7)) ^ *InputPointer++;
     1:         }
     1: 
     1:         PR_ASSERT(mWritePointer <= PastEndPointer);
     1:         PR_ASSERT(mWritePointer >= mEntropyCache);
     1: 
     1:         // have we arrived at the end of the buffer?
     1:         if (PastEndPointer == mWritePointer) {
     1:           // reset write pointer back to begining of our buffer
     1:           mWritePointer = mEntropyCache;
     1:         }
     1: 
     1:         // subtract the number of bytes we have already copied
     1:         bytes_wanted -= this_time;
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEntropyCollector::ForwardTo(nsIEntropyCollector *aCollector)
     1: {
     1:   NS_PRECONDITION(!mForwardTarget, "|ForwardTo| should only be called once.");
     1: 
     1:   mForwardTarget = aCollector;
     1:   mForwardTarget->RandomUpdate(mEntropyCache, mBytesCollected);
     1:   mBytesCollected = 0;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEntropyCollector::DontForward()
     1: {
106838:   mForwardTarget = nullptr;
     1:   return NS_OK;
     1: }
