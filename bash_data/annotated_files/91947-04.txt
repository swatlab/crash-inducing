    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1 *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsiter_h___
    1: #define jsiter_h___
 3164: 
    1: /*
    1:  * JavaScript iterators.
    1:  */
56750: #include "jscntxt.h"
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
40327: #include "jsversion.h"
    1: 
82129: #include "gc/Barrier.h"
79734: #include "vm/Stack.h"
42641: 
53519: /*
53519:  * For cacheable native iterators, whether the iterator is currently active.
53519:  * Not serialized by XDR.
53519:  */
53404: #define JSITER_ACTIVE       0x1000
62573: #define JSITER_UNREUSABLE   0x2000
53404: 
55632: namespace js {
55632: 
42641: struct NativeIterator {
82129:     HeapPtrObject obj;
87655:     HeapPtr<JSFlatString> *props_array;
87655:     HeapPtr<JSFlatString> *props_cursor;
87655:     HeapPtr<JSFlatString> *props_end;
83221:     const Shape **shapes_array;
84755:     uint32_t  shapes_length;
84755:     uint32_t  shapes_key;
84755:     uint32_t  flags;
53404:     JSObject  *next;  /* Forms cx->enumerators list, garbage otherwise. */
42641: 
48470:     bool isKeyIter() const { return (flags & JSITER_FOREACH) == 0; }
43190: 
87655:     inline HeapPtr<JSFlatString> *begin() const {
61055:         return props_array;
47516:     }
47516: 
87655:     inline HeapPtr<JSFlatString> *end() const {
61055:         return props_end;
47516:     }
47516: 
48470:     size_t numKeys() const {
61055:         return end() - begin();
48470:     }
48470: 
87655:     HeapPtr<JSFlatString> *current() const {
61055:         JS_ASSERT(props_cursor < props_end);
61055:         return props_cursor;
48470:     }
48470: 
61055:     void incCursor() {
61055:         props_cursor = props_cursor + 1;
48470:     }
48470: 
84755:     static NativeIterator *allocateIterator(JSContext *cx, uint32_t slength,
48470:                                             const js::AutoIdVector &props);
91237:     void init(JSObject *obj, unsigned flags, uint32_t slength, uint32_t key);
48470: 
42641:     void mark(JSTracer *trc);
42641: };
    1: 
89622: class ElementIteratorObject : public JSObject {
89622:   public:
89622:     enum {
89622:         TargetSlot,
89622:         IndexSlot,
89622:         NumSlots
89622:     };
89622: 
89622:     static JSObject *create(JSContext *cx, JSObject *target);
89622: 
89622:     inline uint32_t getIndex() const;
89622:     inline void setIndex(uint32_t index);
89622:     inline JSObject *getTargetObject() const;
89622: 
89622:     /*
89622:         Array iterators are like this:
89622: 
89622:         Array.prototype[iterate] = function () {
89622:             for (var i = 0; i < (this.length >>> 0); i++) {
89622:                 var desc = Object.getOwnPropertyDescriptor(this, i);
89622:                 yield desc === undefined ? undefined : this[i];
89622:             }
89622:         }
89622: 
89622:         This has the following implications:
89622: 
89622:           - Array iterators are generic; Array.prototype[iterate] can be transferred to
89622:             any other object to create iterators over it.
89622: 
89622:           - The next() method of an Array iterator is non-reentrant. Trying to reenter,
89622:             e.g. by using it on an object with a length getter that calls it.next() on
89622:             the same iterator, causes a TypeError.
89622: 
89622:           - The iterator fetches obj.length every time its next() method is called.
89622: 
89622:           - The iterator converts obj.length to a whole number using ToUint32. As a
89622:             consequence the iterator can't go on forever; it can yield at most 2^32-1
89622:             values. Then i will be 0xffffffff, and no possible length value will be
89622:             greater than that.
89622: 
89622:           - The iterator does not skip "array holes". When it encounters a hole, it
89622:             yields undefined.
89622: 
89622:           - The iterator never consults the prototype chain.
89622: 
89622:           - If an element has a getter which throws, the exception is propagated, and
89622:             the iterator is closed (that is, all future calls to next() will simply
89622:             throw StopIteration).
89622: 
89622:         Note that if next() were reentrant, even more details of its inner
89622:         workings would be observable.
89622:     */
89622: 
89622:     /*
89622:      * If there are any more elements to visit, store the value of the next
89622:      * element in *vp, increment the index, and return true. If not, call
89622:      * vp->setMagic(JS_NO_ITER_VALUE) and return true. Return false on error.
89622:      */
89622:     bool iteratorNext(JSContext *cx, Value *vp);
89622: };
89622: 
48470: bool
48470: VectorToIdArray(JSContext *cx, js::AutoIdVector &props, JSIdArray **idap);
42641: 
47460: bool
91237: GetIterator(JSContext *cx, JSObject *obj, unsigned flags, js::Value *vp);
40829: 
42733: bool
91237: VectorToKeyIterator(JSContext *cx, JSObject *obj, unsigned flags, js::AutoIdVector &props, js::Value *vp);
42733: 
42733: bool
91237: VectorToValueIterator(JSContext *cx, JSObject *obj, unsigned flags, js::AutoIdVector &props, js::Value *vp);
48470: 
48470: /*
48470:  * Creates either a key or value iterator, depending on flags. For a value
48470:  * iterator, performs value-lookup to convert the given list of jsids.
48470:  */
48470: bool
91237: EnumeratedIdVectorToIterator(JSContext *cx, JSObject *obj, unsigned flags, js::AutoIdVector &props, js::Value *vp);
42733: 
40829: /*
    1:  * Convert the value stored in *vp to its iteration object. The flags should
91364:  * contain JSITER_ENUMERATE if js::ValueToIterator is called when enumerating
    1:  * for-in semantics are required, and when the caller can guarantee that the
    1:  * iterator will never be exposed to scripts.
    1:  */
91160: extern JSBool
91237: ValueToIterator(JSContext *cx, unsigned flags, js::Value *vp);
    1: 
91160: extern bool
91160: CloseIterator(JSContext *cx, JSObject *iterObj);
91160: 
91160: extern bool
91160: UnwindIteratorForException(JSContext *cx, JSObject *obj);
91160: 
91947: extern void
91947: UnwindIteratorForUncatchableException(JSContext *cx, JSObject *obj);
91947: 
91160: }
 3025: 
86790: extern bool
43281: js_SuppressDeletedProperty(JSContext *cx, JSObject *obj, jsid id);
43281: 
86790: extern bool
84755: js_SuppressDeletedElement(JSContext *cx, JSObject *obj, uint32_t index);
78344: 
86790: extern bool
84755: js_SuppressDeletedElements(JSContext *cx, JSObject *obj, uint32_t begin, uint32_t end);
55519: 
    1: /*
42641:  * IteratorMore() indicates whether another value is available. It might
42641:  * internally call iterobj.next() and then cache the value until its
42641:  * picked up by IteratorNext(). The value is cached in the current context.
    1:  */
42641: extern JSBool
48470: js_IteratorMore(JSContext *cx, JSObject *iterobj, js::Value *rval);
42641: 
42641: extern JSBool
48470: js_IteratorNext(JSContext *cx, JSObject *iterobj, js::Value *rval);
    1: 
 6464: extern JSBool
 6464: js_ThrowStopIteration(JSContext *cx);
 6464: 
91364: namespace js {
91364: 
91364: /*
91364:  * Get the next value from an iterator object.
91364:  *
91364:  * On success, store the next value in *vp and return true; if there are no
91364:  * more values, store the magic value JS_NO_ITER_VALUE in *vp and return true.
91364:  */
91364: inline bool
91364: Next(JSContext *cx, JSObject *iter, Value *vp)
91364: {
91364:     if (!js_IteratorMore(cx, iter, vp))
91364:         return false;
91364:     if (vp->toBoolean())
91364:         return js_IteratorNext(cx, iter, vp);
91364:     vp->setMagic(JS_NO_ITER_VALUE);
91364:     return true;
91364: }
91364: 
91364: /*
91364:  * Imitate a for-of loop. This does the equivalent of the JS code:
91364:  *
91364:  *     for (let v of iterable)
91364:  *         op(v);
91364:  *
91364:  * But the actual signature of op must be:
91364:  *     bool op(JSContext *cx, const Value &v);
91364:  *
91364:  * There is no feature like JS 'break'. op must return false only
91364:  * in case of exception or error.
91364:  */
91364: template <class Op>
91364: bool
91364: ForOf(JSContext *cx, const Value &iterable, Op op)
91364: {
91364:     Value iterv(iterable);
91364:     if (!ValueToIterator(cx, JSITER_FOR_OF, &iterv))
91364:         return false;
91364:     JSObject *iter = &iterv.toObject();
91364: 
91364:     bool ok = true;
91364:     while (ok) {
91364:         Value v;
91364:         ok = Next(cx, iter, &v);
91364:         if (ok) {
91364:             if (v.isMagic(JS_NO_ITER_VALUE))
91364:                 break;
91364:             ok = op(cx, v);
91364:         }
91364:     }
91364: 
91364:     bool throwing = !ok && cx->isExceptionPending();
91364:     Value exc;
91364:     if (throwing) {
91364:         exc = cx->getPendingException();
91364:         cx->clearPendingException();
91364:     }
91364:     bool closedOK = CloseIterator(cx, iter);
91364:     if (throwing && closedOK)
91364:         cx->setPendingException(exc);
91364:     return ok && closedOK;
91364: }
91364: 
91364: } /* namespace js */
91364: 
    1: #if JS_HAS_GENERATORS
    1: 
    1: /*
    1:  * Generator state codes.
    1:  */
    1: typedef enum JSGeneratorState {
    1:     JSGEN_NEWBORN,  /* not yet started */
    1:     JSGEN_OPEN,     /* started by a .next() or .send(undefined) call */
    1:     JSGEN_RUNNING,  /* currently executing via .next(), etc., call */
    1:     JSGEN_CLOSING,  /* close method is doing asynchronous return */
    1:     JSGEN_CLOSED    /* closed, cannot be started or closed again */
    1: } JSGeneratorState;
    1: 
    1: struct JSGenerator {
82129:     js::HeapPtrObject   obj;
    1:     JSGeneratorState    state;
69223:     js::FrameRegs       regs;
43281:     JSObject            *enumerators;
69223:     js::StackFrame      *floating;
90005:     js::HeapValue       floatingStack[1];
42714: 
69223:     js::StackFrame *floatingFrame() {
53840:         return floating;
42714:     }
42714: 
69223:     js::StackFrame *liveFrame() {
42714:         JS_ASSERT((state == JSGEN_RUNNING || state == JSGEN_CLOSING) ==
69223:                   (regs.fp() != floatingFrame()));
69223:         return regs.fp();
42714:     }
42709: };
42708: 
    1: extern JSObject *
37777: js_NewGenerator(JSContext *cx);
    1: 
42714: /*
42714:  * Generator stack frames do not have stable pointers since they get copied to
42714:  * and from the generator object and the stack (see SendToGenerator). This is a
42714:  * problem for Block and With objects, which need to store a pointer to the
42714:  * enclosing stack frame. The solution is for Block and With objects to store
42714:  * a pointer to the "floating" stack frame stored in the generator object,
42714:  * since it is stable, and maintain, in the generator object, a pointer to the
42714:  * "live" stack frame (either a copy on the stack or the floating frame). Thus,
42714:  * Block and With objects must "normalize" to and from the floating/live frames
42714:  * in the case of generators using the following functions.
42714:  */
69223: inline js::StackFrame *
69223: js_FloatingFrameIfGenerator(JSContext *cx, js::StackFrame *fp)
42714: {
53840:     if (JS_UNLIKELY(fp->isGeneratorFrame()))
53840:         return cx->generatorFor(fp)->floatingFrame();
42714:     return fp;
42714: }
42714: 
42714: /* Given a floating frame, given the JSGenerator containing it. */
42714: extern JSGenerator *
69223: js_FloatingFrameToGenerator(js::StackFrame *fp);
42714: 
69223: inline js::StackFrame *
69223: js_LiveFrameIfGenerator(js::StackFrame *fp)
42714: {
53840:     return fp->isGeneratorFrame() ? js_FloatingFrameToGenerator(fp)->liveFrame() : fp;
42714: }
42714: 
    1: #endif
    1: 
    1: extern JSObject *
    1: js_InitIteratorClasses(JSContext *cx, JSObject *obj);
    1: 
    1: #endif /* jsiter_h___ */
