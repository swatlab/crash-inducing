    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla SVG project.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Crocodile Clips Ltd..
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Alex Fritze <alex.fritze@crocodile-clips.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef NSSVGFOREIGNOBJECTFRAME_H__
    1: #define NSSVGFOREIGNOBJECTFRAME_H__
    1: 
 2671: #include "nsContainerFrame.h"
    1: #include "nsISVGChildFrame.h"
84940: #include "nsSVGUtils.h"
    1: #include "nsRegion.h"
 1119: #include "nsIPresShell.h"
    1: 
19380: class nsSVGOuterSVGFrame;
19380: 
    1: typedef nsContainerFrame nsSVGForeignObjectFrameBase;
    1: 
    1: class nsSVGForeignObjectFrame : public nsSVGForeignObjectFrameBase,
    1:                                 public nsISVGChildFrame
    1: {
    1:   friend nsIFrame*
23953:   NS_NewSVGForeignObjectFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: protected:
    1:   nsSVGForeignObjectFrame(nsStyleContext* aContext);
    1: 
23554: public:
23554:   NS_DECL_QUERYFRAME
32423:   NS_DECL_FRAMEARENA_HELPERS
23511: 
    1:   // nsIFrame:
 8210:   NS_IMETHOD  Init(nsIContent* aContent,
 8210:                    nsIFrame*   aParent,
 8210:                    nsIFrame*   aPrevInFlow);
36647:   virtual void DestroyFrom(nsIFrame* aDestructRoot);
    1:   NS_IMETHOD  AttributeChanged(PRInt32         aNameSpaceID,
    1:                                nsIAtom*        aAttribute,
    1:                                PRInt32         aModType);
    1: 
    1:   virtual nsIFrame* GetContentInsertionFrame() {
77154:     return GetFirstPrincipalChild()->GetContentInsertionFrame();
    1:   }
    1: 
    1:   NS_IMETHOD Reflow(nsPresContext*           aPresContext,
    1:                     nsHTMLReflowMetrics&     aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus&          aStatus);
    1: 
    1:   /**
19214:    * Foreign objects are always transformed.
19214:    */
79445:   virtual bool IsTransformed() const
19214:   {
80486:     return true;
19214:   }
19214: 
19214:   /**
19214:    * Foreign objects can return a transform matrix.
19214:    */
74283:   virtual gfx3DMatrix GetTransformMatrix(nsIFrame **aOutAncestor);
19214: 
19214:   /**
    1:    * Get the "type" of the frame
    1:    *
    1:    * @see nsGkAtoms::svgForeignObjectFrame
    1:    */
    1:   virtual nsIAtom* GetType() const;
    1: 
79445:   virtual bool IsFrameOfType(PRUint32 aFlags) const
    1:   {
    1:     return nsSVGForeignObjectFrameBase::IsFrameOfType(aFlags &
    1:       ~(nsIFrame::eSVG | nsIFrame::eSVGForeignObject));
    1:   }
    1: 
    1:   virtual void InvalidateInternal(const nsRect& aDamageRect,
    1:                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
19380:                                   PRUint32 aFlags);
    1: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const
    1:   {
    1:     return MakeFrameName(NS_LITERAL_STRING("SVGForeignObject"), aResult);
    1:   }
    1: #endif
    1: 
    1:   // nsISVGChildFrame interface:
20652:   NS_IMETHOD PaintSVG(nsSVGRenderState *aContext,
20652:                       const nsIntRect *aDirtyRect);
18367:   NS_IMETHOD_(nsIFrame*) GetFrameForPoint(const nsPoint &aPoint);
    1:   NS_IMETHOD_(nsRect) GetCoveredRegion();
    1:   NS_IMETHOD UpdateCoveredRegion();
    1:   NS_IMETHOD InitialUpdate();
10661:   virtual void NotifySVGChanged(PRUint32 aFlags);
    1:   NS_IMETHOD NotifyRedrawSuspended();
    1:   NS_IMETHOD NotifyRedrawUnsuspended();
79556:   virtual gfxRect GetBBoxContribution(const gfxMatrix &aToBBoxUserspace,
79556:                                       PRUint32 aFlags);
79445:   NS_IMETHOD_(bool) IsDisplayContainer() { return true; }
84940:   NS_IMETHOD_(bool) HasValidCoveredRect() {
84940:     return !(GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD);
84940:   }
    1: 
27899:   gfxMatrix GetCanvasTM();
    1: 
 8210:   // This method allows our nsSVGOuterSVGFrame to reflow us as necessary.
 8210:   void MaybeReflowFromOuterSVGFrame();
 8210: 
    1: protected:
    1:   // implementation helpers:
    1:   void DoReflow();
 1119:   void RequestReflow(nsIPresShell::IntrinsicDirty aType);
    1:   void UpdateGraphic();
29327: 
48242:   // Returns GetCanvasTM followed by a scale from CSS px to Dev px. Used for
48242:   // painting, because children expect to paint to device space, not userspace.
48242:   gfxMatrix GetCanvasTMForChildren();
19380:   void InvalidateDirtyRect(nsSVGOuterSVGFrame* aOuter,
19380:                            const nsRect& aRect, PRUint32 aFlags);
55825:   void FlushDirtyRegion(PRUint32 aFlags);
    1: 
 2748:   // If width or height is less than or equal to zero we must disable rendering
79445:   bool IsDisabled() const { return mRect.width <= 0 || mRect.height <= 0; }
 2748: 
78868:   nsAutoPtr<gfxMatrix> mCanvasTM;
29068: 
29068:   // Areas dirtied by changes to decendents that are in our document
19380:   nsRegion mSameDocDirtyRegion;
29068: 
29068:   // Areas dirtied by changes to sub-documents embedded by our decendents
29068:   nsRegion mSubDocDirtyRegion;
    1: 
79445:   bool mInReflow;
    1: };
    1: 
    1: #endif
