    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifdef MOZ_REQUIRE_CURRENT_SDK
    1: #undef WINVER
    1: #define WINVER 0x0500
    1: #undef _WIN32_WINNT
    1: #define _WIN32_WINNT 0x500
    1: #endif
    1: 
    1: /* -------------------------------------------------------------------
    1: To Build This:
    1: 
    1:   You need to add this to the the makefile.win in mozilla/content/base/src:
    1: 
    1: 	.\$(OBJDIR)\nsFlyOwnPrintDialog.obj	\
    1: 
    1: 
    1:   And this to the makefile.win in mozilla/content/build:
    1: 
    1: WIN_LIBS=                                       \
    1:         winspool.lib                           \
    1:         comctl32.lib                           \
    1:         comdlg32.lib
    1: 
    1: ---------------------------------------------------------------------- */
    1: 
    1: #include "prmem.h"
    1: #include "plstr.h"
    1: #include <windows.h>
    1: #include <tchar.h>
    1: 
    1: #include <unknwn.h>
    1: #include <commdlg.h>
    1: 
    1: #include "nsIWebBrowserPrint.h"
    1: #include "nsString.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIPrintSettings.h"
    1: #include "nsIPrintSettingsWin.h"
    1: #include "nsIPrintOptions.h"
    1: 
    1: #include "nsRect.h"
    1: 
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: 
    1: #include "nsCRT.h"
    1: #include "prenv.h" /* for PR_GetEnv */
    1: 
    1: #include <windows.h>
    1: #include <winspool.h> 
    1: 
    1: // For Localization
    1: #include "nsIStringBundle.h"
    1: 
    1: // For NS_CopyUnicodeToNative
    1: #include "nsNativeCharsetUtils.h"
    1: 
    1: // This is for extending the dialog
    1: #include <dlgs.h>
    1: 
    1: // For PrintDlgEx
    1: // needed because there are unicode/ansi versions of this routine
    1: // and we need to make sure we get the correct one.
    1: #define GetPrintDlgExQuoted "PrintDlgExA"
    1: 
    1: // Default labels for the radio buttons
    1: static const char* kAsLaidOutOnScreenStr = "As &laid out on the screen";
    1: static const char* kTheSelectedFrameStr  = "The selected &frame";
    1: static const char* kEachFrameSeparately  = "&Each frame separately";
    1: 
    1: 
    1: //-----------------------------------------------
    1: // Global Data
    1: //-----------------------------------------------
    1: // Identifies which new radio btn was cliked on
    1: static UINT gFrameSelectedRadioBtn = 0;
    1: 
    1: // Indicates whether the native print dialog was successfully extended
    1: static PRPackedBool gDialogWasExtended     = PR_FALSE;
    1: 
    1: #define PRINTDLG_PROPERTIES "chrome://global/locale/printdialog.properties"
    1: 
    1: static HWND gParentWnd = NULL;
    1: 
    1: //******************************************************
    1: // Define native paper sizes
    1: //******************************************************
    1: typedef struct {
    1:   short  mPaperSize; // native enum
    1:   double mWidth;
    1:   double mHeight;
    1:   PRBool mIsInches;
    1: } NativePaperSizes;
    1: 
    1: // There are around 40 default print sizes defined by Windows
    1: const NativePaperSizes kPaperSizes[] = {
    1:   {DMPAPER_LETTER,    8.5,   11.0,  PR_TRUE},
    1:   {DMPAPER_LEGAL,     8.5,   14.0,  PR_TRUE},
    1:   {DMPAPER_A4,        210.0, 297.0, PR_FALSE},
    1:   {DMPAPER_TABLOID,   11.0,  17.0,  PR_TRUE},
    1:   {DMPAPER_LEDGER,    17.0,  11.0,  PR_TRUE},
    1:   {DMPAPER_STATEMENT, 5.5,   8.5,   PR_TRUE},
    1:   {DMPAPER_EXECUTIVE, 7.25,  10.5,  PR_TRUE},
    1:   {DMPAPER_A3,        297.0, 420.0, PR_FALSE},
    1:   {DMPAPER_A5,        148.0, 210.0, PR_FALSE},
    1:   {DMPAPER_CSHEET,    17.0,  22.0,  PR_TRUE},  
    1:   {DMPAPER_DSHEET,    22.0,  34.0,  PR_TRUE},  
    1:   {DMPAPER_ESHEET,    34.0,  44.0,  PR_TRUE},  
    1:   {DMPAPER_LETTERSMALL, 8.5, 11.0,  PR_TRUE},  
    1:   {DMPAPER_A4SMALL,   210.0, 297.0, PR_FALSE}, 
    1:   {DMPAPER_B4,        250.0, 354.0, PR_FALSE}, 
    1:   {DMPAPER_B5,        182.0, 257.0, PR_FALSE},
    1:   {DMPAPER_FOLIO,     8.5,   13.0,  PR_TRUE},
    1:   {DMPAPER_QUARTO,    215.0, 275.0, PR_FALSE},
    1:   {DMPAPER_10X14,     10.0,  14.0,  PR_TRUE},
    1:   {DMPAPER_11X17,     11.0,  17.0,  PR_TRUE},
    1:   {DMPAPER_NOTE,      8.5,   11.0,  PR_TRUE},  
    1:   {DMPAPER_ENV_9,     3.875, 8.875, PR_TRUE},  
    1:   {DMPAPER_ENV_10,    40.125, 9.5,  PR_TRUE},  
    1:   {DMPAPER_ENV_11,    4.5,   10.375, PR_TRUE},  
    1:   {DMPAPER_ENV_12,    4.75,  11.0,  PR_TRUE},  
    1:   {DMPAPER_ENV_14,    5.0,   11.5,  PR_TRUE},  
    1:   {DMPAPER_ENV_DL,    110.0, 220.0, PR_FALSE}, 
    1:   {DMPAPER_ENV_C5,    162.0, 229.0, PR_FALSE}, 
    1:   {DMPAPER_ENV_C3,    324.0, 458.0, PR_FALSE}, 
    1:   {DMPAPER_ENV_C4,    229.0, 324.0, PR_FALSE}, 
    1:   {DMPAPER_ENV_C6,    114.0, 162.0, PR_FALSE}, 
    1:   {DMPAPER_ENV_C65,   114.0, 229.0, PR_FALSE}, 
    1:   {DMPAPER_ENV_B4,    250.0, 353.0, PR_FALSE}, 
    1:   {DMPAPER_ENV_B5,    176.0, 250.0, PR_FALSE}, 
    1:   {DMPAPER_ENV_B6,    176.0, 125.0, PR_FALSE}, 
    1:   {DMPAPER_ENV_ITALY, 110.0, 230.0, PR_FALSE}, 
    1:   {DMPAPER_ENV_MONARCH,  3.875,  7.5, PR_TRUE},  
    1:   {DMPAPER_ENV_PERSONAL, 3.625,  6.5, PR_TRUE},  
    1:   {DMPAPER_FANFOLD_US,   14.875, 11.0, PR_TRUE},  
    1:   {DMPAPER_FANFOLD_STD_GERMAN, 8.5, 12.0, PR_TRUE},  
    1:   {DMPAPER_FANFOLD_LGL_GERMAN, 8.5, 13.0, PR_TRUE},  
    1: };
    1: const PRInt32 kNumPaperSizes = 41;
    1: 
    1: //----------------------------------------------------------------------------------
    1: static PRBool 
    1: CheckForExtendedDialog()
    1: {
    1: #ifdef MOZ_REQUIRE_CURRENT_SDK
    1:   HMODULE lib = GetModuleHandle("comdlg32.dll");
    1:   if ( lib ) {
    1:     return GetProcAddress(lib, GetPrintDlgExQuoted);
    1:   }
    1: #endif
    1:   return PR_FALSE;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: // Map an incoming size to a Windows Native enum in the DevMode
    1: static void 
20801: MapPaperSizeToNativeEnum(LPDEVMODEW aDevMode,
    1:                          PRInt16   aType, 
    1:                          double    aW, 
    1:                          double    aH)
    1: {
    1: 
    1: #ifdef DEBUG_rods
    1:   BOOL doingOrientation = aDevMode->dmFields & DM_ORIENTATION;
    1:   BOOL doingPaperSize   = aDevMode->dmFields & DM_PAPERSIZE;
    1:   BOOL doingPaperLength = aDevMode->dmFields & DM_PAPERLENGTH;
    1:   BOOL doingPaperWidth  = aDevMode->dmFields & DM_PAPERWIDTH;
    1: #endif
    1: 
    1:   const double kThreshold = 0.05;
    1:   for (PRInt32 i=0;i<kNumPaperSizes;i++) {
    1:     double width  = kPaperSizes[i].mWidth;
    1:     double height = kPaperSizes[i].mHeight;
    1:     if (aW < width+kThreshold && aW > width-kThreshold && 
    1:         aH < height+kThreshold && aH > height-kThreshold) {
    1:       aDevMode->dmPaperSize = kPaperSizes[i].mPaperSize;
    1:       aDevMode->dmFields &= ~DM_PAPERLENGTH;
    1:       aDevMode->dmFields &= ~DM_PAPERWIDTH;
    1:       aDevMode->dmFields |= DM_PAPERSIZE;
    1:       return;
    1:     }
    1:   }
    1: 
    1:   short width  = 0;
    1:   short height = 0;
    1:   if (aType == nsIPrintSettings::kPaperSizeInches) {
    1:     width  = short(NS_TWIPS_TO_MILLIMETERS(NS_INCHES_TO_TWIPS(float(aW))) / 10);
    1:     height = short(NS_TWIPS_TO_MILLIMETERS(NS_INCHES_TO_TWIPS(float(aH))) / 10);
    1: 
    1:   } else if (aType == nsIPrintSettings::kPaperSizeMillimeters) {
    1:     width  = short(aW / 10.0);
    1:     height = short(aH / 10.0);
    1:   } else {
    1:     return; // don't set anything
    1:   }
    1: 
    1:   // width and height is in 
    1:   aDevMode->dmPaperSize   = 0;
    1:   aDevMode->dmPaperWidth  = width;
    1:   aDevMode->dmPaperLength = height;
    1: 
    1:   aDevMode->dmFields |= DM_PAPERSIZE;
    1:   aDevMode->dmFields |= DM_PAPERLENGTH;
    1:   aDevMode->dmFields |= DM_PAPERWIDTH;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: // Setup Paper Size & Orientation options into the DevMode
    1: // 
    1: static void 
20801: SetupDevModeFromSettings(LPDEVMODEW aDevMode, nsIPrintSettings* aPrintSettings)
    1: {
    1:   // Setup paper size
    1:   if (aPrintSettings) {
    1:     PRInt16 type;
    1:     aPrintSettings->GetPaperSizeType(&type);
    1:     if (type == nsIPrintSettings::kPaperSizeNativeData) {
    1:       PRInt16 paperEnum;
    1:       aPrintSettings->GetPaperData(&paperEnum);
    1:       aDevMode->dmPaperSize = paperEnum;
    1:       aDevMode->dmFields &= ~DM_PAPERLENGTH;
    1:       aDevMode->dmFields &= ~DM_PAPERWIDTH;
    1:       aDevMode->dmFields |= DM_PAPERSIZE;
    1:     } else {
    1:       PRInt16 unit;
    1:       double width, height;
    1:       aPrintSettings->GetPaperSizeUnit(&unit);
    1:       aPrintSettings->GetPaperWidth(&width);
    1:       aPrintSettings->GetPaperHeight(&height);
    1:       MapPaperSizeToNativeEnum(aDevMode, unit, width, height);
    1:     }
    1: 
    1:     // Setup Orientation
    1:     PRInt32 orientation;
    1:     aPrintSettings->GetOrientation(&orientation);
    1:     aDevMode->dmOrientation = orientation == nsIPrintSettings::kPortraitOrientation?DMORIENT_PORTRAIT:DMORIENT_LANDSCAPE;
    1:     aDevMode->dmFields |= DM_ORIENTATION;
    1: 
    1:     // Setup Number of Copies
    1:     PRInt32 copies;
    1:     aPrintSettings->GetNumCopies(&copies);
    1:     aDevMode->dmCopies = copies;
    1:     aDevMode->dmFields |= DM_COPIES;
    1: 
    1:   }
    1: 
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: // Helper Function - Free and reallocate the string
    1: static nsresult 
    1: SetPrintSettingsFromDevMode(nsIPrintSettings* aPrintSettings, 
20741:                             LPDEVMODEW         aDevMode)
    1: {
    1:   if (aPrintSettings == nsnull) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   aPrintSettings->SetIsInitializedFromPrinter(PR_TRUE);
    1:   if (aDevMode->dmFields & DM_ORIENTATION) {
    1:     PRInt32 orientation  = aDevMode->dmOrientation == DMORIENT_PORTRAIT?
    1:                            nsIPrintSettings::kPortraitOrientation:nsIPrintSettings::kLandscapeOrientation;
    1:     aPrintSettings->SetOrientation(orientation);
    1:   }
    1: 
    1:   // Setup Number of Copies
    1:   if (aDevMode->dmFields & DM_COPIES) {
    1:     aPrintSettings->SetNumCopies(PRInt32(aDevMode->dmCopies));
    1:   }
    1: 
    1:   // Scaling
    1:   // Since we do the scaling, grab their value and reset back to 100
    1:   if (aDevMode->dmFields & DM_SCALE) {
    1:     double origScale = 1.0;
    1:     aPrintSettings->GetScaling(&origScale);
    1:     double scale = double(aDevMode->dmScale) / 100.0f;
    1:     if (origScale == 1.0 || scale != 1.0) {
    1:       aPrintSettings->SetScaling(scale);
    1:     }
    1:     aDevMode->dmScale = 100;
    1:     // To turn this on you must change where the mPrt->mShrinkToFit is being set in the DocumentViewer
    1:     //aPrintSettings->SetShrinkToFit(PR_FALSE);
    1:   }
    1: 
    1:   if (aDevMode->dmFields & DM_PAPERSIZE) {
    1:     aPrintSettings->SetPaperSizeType(nsIPrintSettings::kPaperSizeNativeData);
    1:     aPrintSettings->SetPaperData(aDevMode->dmPaperSize);
    1:     for (PRInt32 i=0;i<kNumPaperSizes;i++) {
    1:       if (kPaperSizes[i].mPaperSize == aDevMode->dmPaperSize) {
    1:         aPrintSettings->SetPaperSizeUnit(kPaperSizes[i].mIsInches?nsIPrintSettings::kPaperSizeInches:nsIPrintSettings::kPaperSizeMillimeters);
    1:         break;
    1:       }
    1:     }
    1: 
    1:   } else if (aDevMode->dmFields & DM_PAPERLENGTH && aDevMode->dmFields & DM_PAPERWIDTH) {
    1:     PRBool found = PR_FALSE;
    1:     for (PRInt32 i=0;i<kNumPaperSizes;i++) {
    1:       if (kPaperSizes[i].mPaperSize == aDevMode->dmPaperSize) {
    1:         aPrintSettings->SetPaperSizeType(nsIPrintSettings::kPaperSizeDefined);
    1:         aPrintSettings->SetPaperWidth(kPaperSizes[i].mWidth);
    1:         aPrintSettings->SetPaperHeight(kPaperSizes[i].mHeight);
    1:         aPrintSettings->SetPaperSizeUnit(kPaperSizes[i].mIsInches?nsIPrintSettings::kPaperSizeInches:nsIPrintSettings::kPaperSizeMillimeters);
    1:         found = PR_TRUE;
    1:         break;
    1:       }
    1:     }
    1:     if (!found) {
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   } else {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: // Return localized bundle for resource strings
    1: static nsresult
    1: GetLocalizedBundle(const char * aPropFileName, nsIStringBundle** aStrBundle)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPropFileName);
    1:   NS_ENSURE_ARG_POINTER(aStrBundle);
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIStringBundle> bundle;
    1:   
    1: 
    1:   // Create bundle
    1:   nsCOMPtr<nsIStringBundleService> stringService = 
    1:     do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
    1:   if (NS_SUCCEEDED(rv) && stringService) {
    1:     rv = stringService->CreateBundle(aPropFileName, aStrBundle);
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: //--------------------------------------------------------
    1: // Return localized string 
    1: static nsresult
    1: GetLocalizedString(nsIStringBundle* aStrBundle, const char* aKey, nsString& oVal)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aStrBundle);
    1:   NS_ENSURE_ARG_POINTER(aKey);
    1: 
    1:   // Determine default label from string bundle
    1:   nsXPIDLString valUni;
    1:   nsAutoString key; 
    1:   key.AssignWithConversion(aKey);
    1:   nsresult rv = aStrBundle->GetStringFromName(key.get(), getter_Copies(valUni));
    1:   if (NS_SUCCEEDED(rv) && valUni) {
    1:     oVal.Assign(valUni);
    1:   } else {
    1:     oVal.Truncate();
    1:   }
    1:   return rv;
    1: }
    1: 
    1: //--------------------------------------------------------
    1: // Set a multi-byte string in the control
    1: static void SetTextOnWnd(HWND aControl, const nsString& aStr)
    1: {
    1:   nsCAutoString text;
    1:   if (NS_SUCCEEDED(NS_CopyUnicodeToNative(aStr, text))) {
    1:     ::SetWindowText(aControl, text.get());
    1:   }
    1: }
    1: 
    1: //--------------------------------------------------------
    1: // Will get the control and localized string by "key"
    1: static void SetText(HWND             aParent, 
    1:                     UINT             aId, 
    1:                     nsIStringBundle* aStrBundle,
    1:                     const char*      aKey) 
    1: {
    1:   HWND wnd = GetDlgItem (aParent, aId);
    1:   if (!wnd) {
    1:     return;
    1:   }
    1:   nsAutoString str;
    1:   nsresult rv = GetLocalizedString(aStrBundle, aKey, str);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     SetTextOnWnd(wnd, str);
    1:   }
    1: }
    1: 
    1: //--------------------------------------------------------
    1: static void SetRadio(HWND         aParent, 
    1:                      UINT         aId, 
    1:                      PRBool       aIsSet,
    1:                      PRBool       isEnabled = PR_TRUE) 
    1: {
    1:   HWND wnd = ::GetDlgItem (aParent, aId);
    1:   if (!wnd) {
    1:     return;
    1:   }
    1:   if (!isEnabled) {
    1:     ::EnableWindow(wnd, FALSE);
    1:     return;
    1:   }
    1:   ::EnableWindow(wnd, TRUE);
    1:   ::SendMessage(wnd, BM_SETCHECK, (WPARAM)aIsSet, (LPARAM)0);
    1: }
    1: 
    1: //--------------------------------------------------------
    1: static void SetRadioOfGroup(HWND aDlg, int aRadId)
    1: {
    1:   int radioIds[] = {rad4, rad5, rad6};
    1:   int numRads = 3;
    1: 
    1:   for (int i=0;i<numRads;i++) {
    1:     HWND radWnd = ::GetDlgItem(aDlg, radioIds[i]);
    1:     if (radWnd != NULL) {
    1:       ::SendMessage(radWnd, BM_SETCHECK, (WPARAM)(radioIds[i] == aRadId), (LPARAM)0);
    1:     }
    1:   }
    1: }
    1: 
    1: //--------------------------------------------------------
    1: typedef struct {
40201:   const char * mKeyStr;
    1:   long   mKeyId;
    1: } PropKeyInfo;
    1: 
    1: // These are the control ids used in the dialog and 
    1: // defined by MS-Windows in commdlg.h
    1: static PropKeyInfo gAllPropKeys[] = {
33700:     {"printFramesTitleWindows", grp3},
33700:     {"asLaidOutWindows", rad4},
33700:     {"selectedFrameWindows", rad5},
33700:     {"separateFramesWindows", rad6},
    1:     {NULL, NULL}};
    1: 
    1: //--------------------------------------------------------
    1: //--------------------------------------------------------
    1: //--------------------------------------------------------
    1: //--------------------------------------------------------
    1: // Get the absolute coords of the child windows relative
    1: // to its parent window
    1: static void GetLocalRect(HWND aWnd, RECT& aRect, HWND aParent)
    1: {
    1:   ::GetWindowRect(aWnd, &aRect);
    1: 
54348:   // MapWindowPoints converts screen coordinates to client coordinates.
54348:   // It works correctly in both left-to-right and right-to-left windows.
54348:   ::MapWindowPoints(NULL, aParent, (LPPOINT)&aRect, 2);
    1: }
    1: 
    1: //--------------------------------------------------------
    1: // Show or Hide the control
    1: static void Show(HWND aWnd, PRBool bState)
    1: {
    1:   if (aWnd) {
    1:     ::ShowWindow(aWnd, bState?SW_SHOW:SW_HIDE);
    1:   }
    1: }
    1: 
    1: //--------------------------------------------------------
    1: // Create a child window "control"
    1: static HWND CreateControl(LPCTSTR          aType,
    1:                           DWORD            aStyle,
    1:                           HINSTANCE        aHInst, 
    1:                           HWND             aHdlg, 
    1:                           int              aId, 
    1:                           const nsAString& aStr, 
23738:                           const nsIntRect& aRect)
    1: {
    1:   nsCAutoString str;
    1:   if (NS_FAILED(NS_CopyUnicodeToNative(aStr, str)))
    1:     return NULL;
    1: 
    1:   HWND hWnd = ::CreateWindow (aType, str.get(),
    1:                               WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | aStyle,
    1:                               aRect.x, aRect.y, aRect.width, aRect.height,
    1:                               (HWND)aHdlg, (HMENU)aId,
    1:                               aHInst, NULL);
    1:   if (hWnd == NULL) return NULL;
    1: 
    1:   // get the native font for the dialog and 
    1:   // set it into the new control
    1:   HFONT hFont = (HFONT)::SendMessage(aHdlg, WM_GETFONT, (WPARAM)0, (LPARAM)0);
    1:   if (hFont != NULL) {
    1:     ::SendMessage(hWnd, WM_SETFONT, (WPARAM) hFont, (LPARAM)0);
    1:   }
    1:   return hWnd;
    1: }
    1: 
    1: //--------------------------------------------------------
    1: // Create a Radio Button
    1: static HWND CreateRadioBtn(HINSTANCE        aHInst, 
    1:                            HWND             aHdlg, 
    1:                            int              aId, 
    1:                            const char*      aStr, 
23738:                            const nsIntRect& aRect)
    1: {
    1:   nsString cStr;
    1:   cStr.AssignWithConversion(aStr);
    1:   return CreateControl("BUTTON", BS_RADIOBUTTON, aHInst, aHdlg, aId, cStr, aRect);
    1: }
    1: 
    1: //--------------------------------------------------------
    1: // Create a Group Box
    1: static HWND CreateGroupBox(HINSTANCE        aHInst, 
    1:                            HWND             aHdlg, 
    1:                            int              aId, 
    1:                            const nsAString& aStr, 
23738:                            const nsIntRect& aRect)
    1: {
    1:   return CreateControl("BUTTON", BS_GROUPBOX, aHInst, aHdlg, aId, aStr, aRect);
    1: }
    1: 
    1: //--------------------------------------------------------
    1: // Localizes and initializes the radio buttons and group
    1: static void InitializeExtendedDialog(HWND hdlg, PRInt16 aHowToEnableFrameUI) 
    1: {
    1:   // Localize the new controls in the print dialog
    1:   nsCOMPtr<nsIStringBundle> strBundle;
    1:   if (NS_SUCCEEDED(GetLocalizedBundle(PRINTDLG_PROPERTIES, getter_AddRefs(strBundle)))) {
    1:     PRInt32 i = 0;
    1:     while (gAllPropKeys[i].mKeyStr != NULL) {
    1:       SetText(hdlg, gAllPropKeys[i].mKeyId, strBundle, gAllPropKeys[i].mKeyStr);
    1:       i++;
    1:     }
    1:   }
    1: 
    1:   // Set up radio buttons
    1:   if (aHowToEnableFrameUI == nsIPrintSettings::kFrameEnableAll) {
    1:     SetRadio(hdlg, rad4, PR_FALSE);  
    1:     SetRadio(hdlg, rad5, PR_TRUE); 
    1:     SetRadio(hdlg, rad6, PR_FALSE);
    1:     // set default so user doesn't have to actually press on it
    1:     gFrameSelectedRadioBtn = rad5;
    1: 
    1:   } else if (aHowToEnableFrameUI == nsIPrintSettings::kFrameEnableAsIsAndEach) {
    1:     SetRadio(hdlg, rad4, PR_FALSE);  
    1:     SetRadio(hdlg, rad5, PR_FALSE, PR_FALSE); 
    1:     SetRadio(hdlg, rad6, PR_TRUE);
    1:     // set default so user doesn't have to actually press on it
    1:     gFrameSelectedRadioBtn = rad6;
    1: 
    1: 
    1:   } else {  // nsIPrintSettings::kFrameEnableNone
    1:     // we are using this function to disabe the group box
    1:     SetRadio(hdlg, grp3, PR_FALSE, PR_FALSE); 
    1:     // now disable radiobuttons
    1:     SetRadio(hdlg, rad4, PR_FALSE, PR_FALSE); 
    1:     SetRadio(hdlg, rad5, PR_FALSE, PR_FALSE); 
    1:     SetRadio(hdlg, rad6, PR_FALSE, PR_FALSE); 
    1:   }
    1: 
    1: }
    1: 
    1: 
    1: //--------------------------------------------------------
    1: // Special Hook Procedure for handling the print dialog messages
    1: static UINT CALLBACK PrintHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam) 
    1: {
    1: 
    1:   if (uiMsg == WM_COMMAND) {
    1:     UINT id = LOWORD(wParam);
    1:     if (id == rad4 || id == rad5 || id == rad6) {
    1:       gFrameSelectedRadioBtn = id;
    1:       SetRadioOfGroup(hdlg, id);
    1:     }
    1: 
    1:   } else if (uiMsg == WM_INITDIALOG) {
    1:     PRINTDLG * printDlg = (PRINTDLG *)lParam;
    1:     if (printDlg == NULL) return 0L;
    1: 
    1:     PRInt16 howToEnableFrameUI = (PRInt16)printDlg->lCustData;
    1: 
29236:     HINSTANCE hInst = (HINSTANCE)::GetWindowLongPtr(hdlg, GWLP_HINSTANCE);
    1:     if (hInst == NULL) return 0L;
    1: 
    1:     // Start by getting the local rects of several of the controls
    1:     // so we can calculate where the new controls are
    1:     HWND wnd = ::GetDlgItem(hdlg, grp1);
    1:     if (wnd == NULL) return 0L;
    1:     RECT dlgRect;
    1:     GetLocalRect(wnd, dlgRect, hdlg);
    1: 
    1:     wnd = ::GetDlgItem(hdlg, rad1); // this is the top control "All"
    1:     if (wnd == NULL) return 0L;
    1:     RECT rad1Rect;
    1:     GetLocalRect(wnd, rad1Rect, hdlg);
    1: 
    1:     wnd = ::GetDlgItem(hdlg, rad2); // this is the bottom control "Selection"
    1:     if (wnd == NULL) return 0L;
    1:     RECT rad2Rect;
    1:     GetLocalRect(wnd, rad2Rect, hdlg);
    1: 
    1:     wnd = ::GetDlgItem(hdlg, rad3); // this is the middle control "Pages"
    1:     if (wnd == NULL) return 0L;
    1:     RECT rad3Rect;
    1:     GetLocalRect(wnd, rad3Rect, hdlg);
    1: 
    1:     HWND okWnd = ::GetDlgItem(hdlg, IDOK);
    1:     if (okWnd == NULL) return 0L;
    1:     RECT okRect;
    1:     GetLocalRect(okWnd, okRect, hdlg);
    1: 
    1:     wnd = ::GetDlgItem(hdlg, grp4); // this is the "Print range" groupbox
    1:     if (wnd == NULL) return 0L;
    1:     RECT prtRect;
    1:     GetLocalRect(wnd, prtRect, hdlg);
    1: 
    1: 
    1:     // calculate various different "gaps" for layout purposes
    1: 
    1:     int rbGap     = rad3Rect.top - rad1Rect.bottom;     // gap between radiobtns
    1:     int grpBotGap = dlgRect.bottom - rad2Rect.bottom;   // gap from bottom rb to bottom of grpbox
    1:     int grpGap    = dlgRect.top - prtRect.bottom ;      // gap between group boxes
    1:     int top       = dlgRect.bottom + grpGap;            
    1:     int radHgt    = rad1Rect.bottom - rad1Rect.top + 1; // top of new group box
    1:     int y         = top+(rad1Rect.top-dlgRect.top);     // starting pos of first radio
    1:     int rbWidth   = dlgRect.right - rad1Rect.left - 5;  // measure from rb left to the edge of the groupbox
    1:                                                         // (5 is arbitrary)
23738:     nsIntRect rect;
    1: 
    1:     // Create and position the radio buttons
    1:     //
    1:     // If any one control cannot be created then 
    1:     // hide the others and bail out
    1:     //
    1:     rect.SetRect(rad1Rect.left, y, rbWidth,radHgt);
    1:     HWND rad4Wnd = CreateRadioBtn(hInst, hdlg, rad4, kAsLaidOutOnScreenStr, rect);
    1:     if (rad4Wnd == NULL) return 0L;
    1:     y += radHgt + rbGap;
    1: 
    1:     rect.SetRect(rad1Rect.left, y, rbWidth, radHgt);
    1:     HWND rad5Wnd = CreateRadioBtn(hInst, hdlg, rad5, kTheSelectedFrameStr, rect);
    1:     if (rad5Wnd == NULL) {
    1:       Show(rad4Wnd, FALSE); // hide
    1:       return 0L;
    1:     }
    1:     y += radHgt + rbGap;
    1: 
    1:     rect.SetRect(rad1Rect.left, y, rbWidth, radHgt);
    1:     HWND rad6Wnd = CreateRadioBtn(hInst, hdlg, rad6, kEachFrameSeparately, rect);
    1:     if (rad6Wnd == NULL) {
    1:       Show(rad4Wnd, FALSE); // hide
    1:       Show(rad5Wnd, FALSE); // hide
    1:       return 0L;
    1:     }
    1:     y += radHgt + grpBotGap;
    1: 
    1:     // Create and position the group box
    1:     rect.SetRect (dlgRect.left, top, dlgRect.right-dlgRect.left+1, y-top+1);
    1:     HWND grpBoxWnd = CreateGroupBox(hInst, hdlg, grp3, NS_LITERAL_STRING("Print Frame"), rect);
    1:     if (grpBoxWnd == NULL) {
    1:       Show(rad4Wnd, FALSE); // hide
    1:       Show(rad5Wnd, FALSE); // hide
    1:       Show(rad6Wnd, FALSE); // hide
    1:       return 0L;
    1:     }
    1: 
    1:     // Here we figure out the old height of the dlg
24693:     // then figure its gap from the old grpbx to the bottom
    1:     // then size the dlg
    1:     RECT pr, cr; 
    1:     ::GetWindowRect(hdlg, &pr);
    1:     ::GetClientRect(hdlg, &cr);
    1: 
    1:     int dlgHgt = (cr.bottom - cr.top) + 1;
    1:     int bottomGap = dlgHgt - okRect.bottom;
    1:     pr.bottom += (dlgRect.bottom-dlgRect.top) + grpGap + 1 - (dlgHgt-dlgRect.bottom) + bottomGap;
    1: 
    1:     ::SetWindowPos(hdlg, NULL, pr.left, pr.top, pr.right-pr.left+1, pr.bottom-pr.top+1, 
    1:                    SWP_NOMOVE|SWP_NOREDRAW|SWP_NOZORDER);
    1: 
    1:     // figure out the new height of the dialog
    1:     ::GetClientRect(hdlg, &cr);
    1:     dlgHgt = (cr.bottom - cr.top) + 1;
    1:  
    1:     // Reposition the OK and Cancel btns
    1:     int okHgt = okRect.bottom - okRect.top + 1;
    1:     ::SetWindowPos(okWnd, NULL, okRect.left, dlgHgt-bottomGap-okHgt, 0, 0, 
    1:                    SWP_NOSIZE|SWP_NOREDRAW|SWP_NOZORDER);
    1: 
    1:     HWND cancelWnd = ::GetDlgItem(hdlg, IDCANCEL);
    1:     if (cancelWnd == NULL) return 0L;
    1: 
    1:     RECT cancelRect;
    1:     GetLocalRect(cancelWnd, cancelRect, hdlg);
    1:     int cancelHgt = cancelRect.bottom - cancelRect.top + 1;
    1:     ::SetWindowPos(cancelWnd, NULL, cancelRect.left, dlgHgt-bottomGap-cancelHgt, 0, 0, 
    1:                    SWP_NOSIZE|SWP_NOREDRAW|SWP_NOZORDER);
    1: 
    1:     // localize and initialize the groupbox and radiobuttons
    1:     InitializeExtendedDialog(hdlg, howToEnableFrameUI);
    1: 
    1:     // Looks like we were able to extend the dialog
    1:     gDialogWasExtended = PR_TRUE;
    1:   }
    1:   return 0L;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: // Returns a Global Moveable Memory Handle to a DevMode
    1: // from the Printer by the name of aPrintName
    1: //
    1: // NOTE:
    1: //   This function assumes that aPrintName has already been converted from 
    1: //   unicode
    1: //
58551: static HGLOBAL CreateGlobalDevModeAndInit(const nsXPIDLString& aPrintName, nsIPrintSettings* aPS)
    1: {
    1:   HGLOBAL hGlobalDevMode = NULL;
    1: 
    1:   HANDLE hPrinter = NULL;
    1:   // const cast kludge for silly Win32 api's
58551:   LPWSTR printName = const_cast<wchar_t*>(aPrintName.get());
20801:   BOOL status = ::OpenPrinterW(printName, &hPrinter, NULL);
    1:   if (status) {
    1: 
20801:     LPDEVMODEW  pNewDevMode;
    1:     DWORD       dwNeeded, dwRet;
    1: 
    1:     // Get the buffer size
20801:     dwNeeded = ::DocumentPropertiesW(gParentWnd, hPrinter, printName, NULL, NULL, 0);
    1:     if (dwNeeded == 0) {
    1:       return NULL;
    1:     }
    1: 
    1:     // Allocate a buffer of the correct size.
20801:     pNewDevMode = (LPDEVMODEW)::HeapAlloc (::GetProcessHeap(), HEAP_ZERO_MEMORY, dwNeeded);
    1:     if (!pNewDevMode) return NULL;
    1: 
    1:     hGlobalDevMode = (HGLOBAL)::GlobalAlloc(GHND, dwNeeded);
    1:     if (!hGlobalDevMode) {
    1:       ::HeapFree(::GetProcessHeap(), 0, pNewDevMode);
    1:       return NULL;
    1:     }
    1: 
20801:     dwRet = ::DocumentPropertiesW(gParentWnd, hPrinter, printName, pNewDevMode, NULL, DM_OUT_BUFFER);
    1: 
    1:     if (dwRet != IDOK) {
    1:       ::HeapFree(::GetProcessHeap(), 0, pNewDevMode);
    1:       ::GlobalFree(hGlobalDevMode);
    1:       ::ClosePrinter(hPrinter);
    1:       return NULL;
    1:     }
    1: 
    1:     // Lock memory and copy contents from DEVMODE (current printer)
    1:     // to Global Memory DEVMODE
20801:     LPDEVMODEW devMode = (DEVMODEW *)::GlobalLock(hGlobalDevMode);
    1:     if (devMode) {
    1:       memcpy(devMode, pNewDevMode, dwNeeded);
    1:       // Initialize values from the PrintSettings
    1:       SetupDevModeFromSettings(devMode, aPS);
    1: 
    1:       // Sets back the changes we made to the DevMode into the Printer Driver
20801:       dwRet = ::DocumentPropertiesW(gParentWnd, hPrinter, printName, devMode, devMode, DM_IN_BUFFER | DM_OUT_BUFFER);
    1:       if (dwRet != IDOK) {
    1:         ::GlobalUnlock(hGlobalDevMode);
    1:         ::GlobalFree(hGlobalDevMode);
    1:         ::HeapFree(::GetProcessHeap(), 0, pNewDevMode);
    1:         ::ClosePrinter(hPrinter);
    1:         return NULL;
    1:       }
    1: 
    1:       ::GlobalUnlock(hGlobalDevMode);
    1:     } else {
    1:       ::GlobalFree(hGlobalDevMode);
    1:       hGlobalDevMode = NULL;
    1:     }
    1: 
    1:     ::HeapFree(::GetProcessHeap(), 0, pNewDevMode);
    1: 
    1:     ::ClosePrinter(hPrinter);
    1: 
    1:   } else {
    1:     return NULL;
    1:   }
    1: 
    1:   return hGlobalDevMode;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: // helper
58551: static void GetDefaultPrinterNameFromGlobalPrinters(nsXPIDLString &printerName)
    1: {
23780:   nsCOMPtr<nsIPrinterEnumerator> prtEnum = do_GetService("@mozilla.org/gfx/printerenumerator;1");
    1:   if (prtEnum) {
58551:     prtEnum->GetDefaultPrinterName(getter_Copies(printerName));
    1:   }
    1: }
    1: 
    1: // Determine whether we have a completely native dialog
    1: // or whether we cshould extend it
    1: static PRBool ShouldExtendPrintDialog()
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIPrefService> prefs =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, PR_TRUE);
    1:   nsCOMPtr<nsIPrefBranch> prefBranch;
    1:   rv = prefs->GetBranch(nsnull, getter_AddRefs(prefBranch));
    1:   NS_ENSURE_SUCCESS(rv, PR_TRUE);
    1: 
    1:   PRBool result;
    1:   rv = prefBranch->GetBoolPref("print.extend_native_print_dialog", &result);
    1:   NS_ENSURE_SUCCESS(rv, PR_TRUE);
    1:   return result;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: // Displays the native Print Dialog
    1: static nsresult 
    1: ShowNativePrintDialog(HWND              aHWnd,
    1:                       nsIPrintSettings* aPrintSettings)
    1: {
    1:   //NS_ENSURE_ARG_POINTER(aHWnd);
    1:   NS_ENSURE_ARG_POINTER(aPrintSettings);
    1: 
    1:   gDialogWasExtended  = PR_FALSE;
    1: 
    1:   HGLOBAL hGlobalDevMode = NULL;
    1:   HGLOBAL hDevNames      = NULL;
    1: 
    1:   // Get the Print Name to be used
58551:   nsXPIDLString printerName;
58551:   aPrintSettings->GetPrinterName(getter_Copies(printerName));
    1: 
    1:   // If there is no name then use the default printer
58551:   if (printerName.IsEmpty()) {
58551:     GetDefaultPrinterNameFromGlobalPrinters(printerName);
    1:   } else {
    1:     HANDLE hPrinter = NULL;
58551:     if(!::OpenPrinterW(const_cast<wchar_t*>(printerName.get()), &hPrinter, NULL)) {
    1:       // If the last used printer is not found, we should use default printer.
58551:       GetDefaultPrinterNameFromGlobalPrinters(printerName);
    1:     } else {
    1:       ::ClosePrinter(hPrinter);
    1:     }
    1:   }
    1: 
58551:   NS_ASSERTION(!printerName.IsEmpty(), "We have to have a printer name");
58551:   if (printerName.IsEmpty()) {
58551:     return NS_ERROR_FAILURE;
58551:   }
    1: 
    1:   // Now create a DEVNAMES struct so the the dialog is initialized correctly.
    1: 
58551:   PRUint32 len = printerName.Length();
20801:   hDevNames = (HGLOBAL)::GlobalAlloc(GHND, sizeof(wchar_t) * (len + 1) + 
20801:                                      sizeof(DEVNAMES));
58551:   if (!hDevNames) {
58551:     return NS_ERROR_OUT_OF_MEMORY;
58551:   }
58551: 
    1:   DEVNAMES* pDevNames = (DEVNAMES*)::GlobalLock(hDevNames);
58551:   if (!pDevNames) {
58551:     ::GlobalFree(hDevNames);
58551:     return NS_ERROR_FAILURE;
58551:   }
40201:   pDevNames->wDriverOffset = sizeof(DEVNAMES)/sizeof(wchar_t);
40201:   pDevNames->wDeviceOffset = sizeof(DEVNAMES)/sizeof(wchar_t);
40201:   pDevNames->wOutputOffset = sizeof(DEVNAMES)/sizeof(wchar_t)+len;
    1:   pDevNames->wDefault      = 0;
    1: 
40201:   memcpy(pDevNames+1, printerName, (len + 1) * sizeof(wchar_t));
    1:   ::GlobalUnlock(hDevNames);
    1: 
    1:   // Create a Moveable Memory Object that holds a new DevMode
    1:   // from the Printer Name
    1:   // The PRINTDLG.hDevMode requires that it be a moveable memory object
    1:   // NOTE: We only need to free hGlobalDevMode when the dialog is cancelled
    1:   // When the user prints, it comes back in the printdlg struct and 
    1:   // is used and cleaned up later
20801:   hGlobalDevMode = CreateGlobalDevModeAndInit(printerName, aPrintSettings);
    1: 
    1:   // Prepare to Display the Print Dialog
20801:   PRINTDLGW  prntdlg;
20801:   memset(&prntdlg, 0, sizeof(PRINTDLGW));
    1: 
    1:   prntdlg.lStructSize = sizeof(prntdlg);
    1:   prntdlg.hwndOwner   = aHWnd;
    1:   prntdlg.hDevMode    = hGlobalDevMode;
    1:   prntdlg.hDevNames   = hDevNames;
    1:   prntdlg.hDC         = NULL;
    1:   prntdlg.Flags       = PD_ALLPAGES | PD_RETURNIC | PD_USEDEVMODECOPIESANDCOLLATE;
    1: 
    1:   // if there is a current selection then enable the "Selection" radio button
    1:   PRInt16 howToEnableFrameUI = nsIPrintSettings::kFrameEnableNone;
    1:   PRBool isOn;
    1:   aPrintSettings->GetPrintOptions(nsIPrintSettings::kEnableSelectionRB, &isOn);
    1:   if (!isOn) {
    1:     prntdlg.Flags |= PD_NOSELECTION;
    1:   }
    1:   aPrintSettings->GetHowToEnableFrameUI(&howToEnableFrameUI);
    1: 
    1:   PRInt32 pg = 1;
    1:   aPrintSettings->GetStartPageRange(&pg);
    1:   prntdlg.nFromPage           = pg;
    1:   
    1:   aPrintSettings->GetEndPageRange(&pg);
    1:   prntdlg.nToPage             = pg;
    1: 
    1:   prntdlg.nMinPage            = 1;
    1:   prntdlg.nMaxPage            = 0xFFFF;
    1:   prntdlg.nCopies             = 1;
    1:   prntdlg.lpfnSetupHook       = NULL;
    1:   prntdlg.lpSetupTemplateName = NULL;
    1:   prntdlg.hPrintTemplate      = NULL;
    1:   prntdlg.hSetupTemplate      = NULL;
    1: 
    1:   prntdlg.hInstance           = NULL;
    1:   prntdlg.lpPrintTemplateName = NULL;
    1: 
    1:   if (!ShouldExtendPrintDialog()) {
    1:     prntdlg.lCustData         = NULL;
    1:     prntdlg.lpfnPrintHook     = NULL;
    1:   } else {
    1:     // Set up print dialog "hook" procedure for extending the dialog
    1:     prntdlg.lCustData         = (DWORD)howToEnableFrameUI;
    1:     prntdlg.lpfnPrintHook     = (LPPRINTHOOKPROC)PrintHookProc;
    1:     prntdlg.Flags            |= PD_ENABLEPRINTHOOK;
    1:   }
    1: 
20801:   BOOL result = ::PrintDlgW(&prntdlg);
    1: 
    1:   if (TRUE == result) {
    1:     // check to make sure we don't have any NULL pointers
    1:     NS_ENSURE_TRUE(aPrintSettings && prntdlg.hDevMode, NS_ERROR_FAILURE);
    1: 
    1:     if (prntdlg.hDevNames == NULL) {
    1:       ::GlobalFree(hGlobalDevMode);
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     // Lock the deviceNames and check for NULL
    1:     DEVNAMES *devnames = (DEVNAMES *)::GlobalLock(prntdlg.hDevNames);
    1:     if (devnames == NULL) {
    1:       ::GlobalFree(hGlobalDevMode);
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
20801:     wchar_t* device = &(((wchar_t *)devnames)[devnames->wDeviceOffset]);
20801:     wchar_t* driver = &(((wchar_t *)devnames)[devnames->wDriverOffset]);
    1: 
    1:     // Check to see if the "Print To File" control is checked
    1:     // then take the name from devNames and set it in the PrintSettings
    1:     //
    1:     // NOTE:
    1:     // As per Microsoft SDK documentation the returned value offset from
    1:     // devnames->wOutputOffset is either "FILE:" or NULL
    1:     // if the "Print To File" checkbox is checked it MUST be "FILE:"
    1:     // We assert as an extra safety check.
    1:     if (prntdlg.Flags & PD_PRINTTOFILE) {
20801:       wchar_t* fileName = &(((wchar_t *)devnames)[devnames->wOutputOffset]);
20801:       NS_ASSERTION(wcscmp(fileName, L"FILE:") == 0, "FileName must be `FILE:`");
20801:       aPrintSettings->SetToFileName(fileName);
    1:       aPrintSettings->SetPrintToFile(PR_TRUE);
    1:     } else {
    1:       // clear "print to file" info
    1:       aPrintSettings->SetPrintToFile(PR_FALSE);
    1:       aPrintSettings->SetToFileName(nsnull);
    1:     }
    1: 
    1:     nsCOMPtr<nsIPrintSettingsWin> psWin(do_QueryInterface(aPrintSettings));
    1:     if (!psWin) {
    1:       ::GlobalFree(hGlobalDevMode);
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // Setup local Data members
20801:     psWin->SetDeviceName(device);
20801:     psWin->SetDriverName(driver);
    1: 
    1: #if defined(DEBUG_rods) || defined(DEBUG_dcone)
20801:     wprintf(L"printer: driver %s, device %s  flags: %d\n", driver, device, prntdlg.Flags);
    1: #endif
    1:     // fill the print options with the info from the dialog
    1: 
20801:     aPrintSettings->SetPrinterName(device);
    1: 
    1:     if (prntdlg.Flags & PD_SELECTION) {
    1:       aPrintSettings->SetPrintRange(nsIPrintSettings::kRangeSelection);
    1: 
    1:     } else if (prntdlg.Flags & PD_PAGENUMS) {
    1:       aPrintSettings->SetPrintRange(nsIPrintSettings::kRangeSpecifiedPageRange);
    1:       aPrintSettings->SetStartPageRange(prntdlg.nFromPage);
    1:       aPrintSettings->SetEndPageRange(prntdlg.nToPage);
    1: 
    1:     } else { // (prntdlg.Flags & PD_ALLPAGES)
    1:       aPrintSettings->SetPrintRange(nsIPrintSettings::kRangeAllPages);
    1:     }
    1: 
    1:     if (howToEnableFrameUI != nsIPrintSettings::kFrameEnableNone) {
    1:       // make sure the dialog got extended
    1:       if (gDialogWasExtended) {
    1:         // check to see about the frame radio buttons
    1:         switch (gFrameSelectedRadioBtn) {
    1:           case rad4: 
    1:             aPrintSettings->SetPrintFrameType(nsIPrintSettings::kFramesAsIs);
    1:             break;
    1:           case rad5: 
    1:             aPrintSettings->SetPrintFrameType(nsIPrintSettings::kSelectedFrame);
    1:             break;
    1:           case rad6: 
    1:             aPrintSettings->SetPrintFrameType(nsIPrintSettings::kEachFrameSep);
    1:             break;
    1:         } // switch
    1:       } else {
    1:         // if it didn't get extended then have it default to printing
    1:         // each frame separately
    1:         aPrintSettings->SetPrintFrameType(nsIPrintSettings::kEachFrameSep);
    1:       }
    1:     } else {
    1:       aPrintSettings->SetPrintFrameType(nsIPrintSettings::kNoFrames);
    1:     }
    1:     // Unlock DeviceNames
    1:     ::GlobalUnlock(prntdlg.hDevNames);
    1: 
    1:     // Transfer the settings from the native data to the PrintSettings
20741:     LPDEVMODEW devMode = (LPDEVMODEW)::GlobalLock(prntdlg.hDevMode);
    1:     if (devMode == NULL) {
    1:       ::GlobalFree(hGlobalDevMode);
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     psWin->SetDevMode(devMode); // copies DevMode
    1:     SetPrintSettingsFromDevMode(aPrintSettings, devMode);
    1:     ::GlobalUnlock(prntdlg.hDevMode);
    1: 
    1: #if defined(DEBUG_rods) || defined(DEBUG_dcone)
    1:     PRBool  printSelection = prntdlg.Flags & PD_SELECTION;
    1:     PRBool  printAllPages  = prntdlg.Flags & PD_ALLPAGES;
    1:     PRBool  printNumPages  = prntdlg.Flags & PD_PAGENUMS;
    1:     PRInt32 fromPageNum    = 0;
    1:     PRInt32 toPageNum      = 0;
    1: 
    1:     if (printNumPages) {
    1:       fromPageNum = prntdlg.nFromPage;
    1:       toPageNum   = prntdlg.nToPage;
    1:     } 
    1:     if (printSelection) {
    1:       printf("Printing the selection\n");
    1: 
    1:     } else if (printAllPages) {
    1:       printf("Printing all the pages\n");
    1: 
    1:     } else {
    1:       printf("Printing from page no. %d to %d\n", fromPageNum, toPageNum);
    1:     }
    1: #endif
    1:     
    1:   } else {
    1:     aPrintSettings->SetIsCancelled(PR_TRUE);
    1:     if (hGlobalDevMode) ::GlobalFree(hGlobalDevMode);
    1:     return NS_ERROR_ABORT;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: #ifdef MOZ_REQUIRE_CURRENT_SDK
    1: //------------------------------------------------------------------
    1: // Callback for Property Sheet
    1: static BOOL APIENTRY PropSheetCallBack(HWND hdlg, UINT uiMsg, UINT wParam, LONG lParam)
    1: {
    1:   if (uiMsg == WM_COMMAND) {
    1:     UINT id = LOWORD(wParam);
    1:     if (id == rad4 || id == rad5 || id == rad6) {
    1:       gFrameSelectedRadioBtn = id;
    1:       SetRadioOfGroup(hdlg, id);
    1:     }
    1: 
    1:   } else if (uiMsg == WM_INITDIALOG) {
    1:     // Create the groupbox and Radiobuttons on the "Options" Property Sheet
    1: 
    1:     // We temporarily borrowed the global value for initialization
    1:     // now clear it before the dialog appears
    1:     PRInt16 howToEnableFrameUI = gFrameSelectedRadioBtn;
    1:     gFrameSelectedRadioBtn     = 0;
    1: 
29236:     HINSTANCE hInst = (HINSTANCE)::GetWindowLongPtr(hdlg, GWLP_HINSTANCE);
    1:     if (hInst == NULL) return 0L;
    1: 
    1:     // Get default font for the dialog & then its font metrics
    1:     // we need the text height to determine the height of the radio buttons
    1:     TEXTMETRIC metrics;
    1:     HFONT hFont = (HFONT)::SendMessage(hdlg, WM_GETFONT, (WPARAM)0, (LPARAM)0);
    1:     HDC localDC = ::GetDC(hdlg);
    1:     ::SelectObject(localDC, (HGDIOBJ)hFont);
    1:     ::GetTextMetrics(localDC, &metrics);
    1:     ::ReleaseDC(hdlg, localDC);
    1: 
    1:     // calculate various different "gaps" for layout purposes
    1:      RECT dlgr; 
    1:     ::GetWindowRect(hdlg, &dlgr);
    1: 
    1:     int horzGap    = 5;                                 // generic horz gap
    1:     int vertGap    = 5;                                 // generic vert gap
    1:     int rbGap      = metrics.tmHeight / 2;               // gap between radiobtns
    1:     int top        = vertGap*2;                            // start at the top
    1:     int radHgt     = metrics.tmHeight;                   // top of new group box
    1:     int y          = top;                                // starting pos of first radio
    1:     int x          = horzGap*2;
    1:     int rbWidth    = dlgr.right - dlgr.left - (5*horzGap);  
    1:     int grpWidth   = dlgr.right - dlgr.left - (2*horzGap);  
    1: 
    1:     nsRect rect;
    1: 
    1:     // Create and position the radio buttons
    1:     //
    1:     // If any one control cannot be created then 
    1:     // hide the others and bail out
    1:     //
    1:     x += horzGap*2;
    1:     y += vertGap + metrics.tmHeight;
    1:     rect.SetRect(x, y, rbWidth,radHgt);
    1:     HWND rad4Wnd = CreateRadioBtn(hInst, hdlg, rad4, kAsLaidOutOnScreenStr, rect);
    1:     if (rad4Wnd == NULL) return 0L;
    1:     y += radHgt + rbGap;
    1: 
    1:     rect.SetRect(x, y, rbWidth, radHgt);
    1:     HWND rad5Wnd = CreateRadioBtn(hInst, hdlg, rad5, kTheSelectedFrameStr, rect);
    1:     if (rad5Wnd == NULL) {
    1:       Show(rad4Wnd, FALSE); // hide
    1:       return 0L;
    1:     }
    1:     y += radHgt + rbGap;
    1: 
    1:     rect.SetRect(x, y, rbWidth, radHgt);
    1:     HWND rad6Wnd = CreateRadioBtn(hInst, hdlg, rad6, kEachFrameSeparately, rect);
    1:     if (rad6Wnd == NULL) {
    1:       Show(rad4Wnd, FALSE); // hide
    1:       Show(rad5Wnd, FALSE); // hide
    1:       return 0L;
    1:     }
    1:     y += radHgt + (vertGap*2);
    1: 
    1:     x -= horzGap*2;
    1:     // Create and position the group box
    1:     rect.SetRect (x, top, grpWidth, y-top+1);
    1:     HWND grpBoxWnd = CreateGroupBox(hInst, hdlg, grp3, NS_LITERAL_STRING("Print Frame"), rect);
    1:     if (grpBoxWnd == NULL) {
    1:       Show(rad4Wnd, FALSE); // hide
    1:       Show(rad5Wnd, FALSE); // hide
    1:       Show(rad6Wnd, FALSE); // hide
    1:       return 0L;
    1:     }
    1: 
    1:     // localize and initialize the groupbox and radiobuttons
    1:     InitializeExtendedDialog(hdlg, howToEnableFrameUI);
    1: 
    1:     // Looks like we were able to extend the dialog
    1:     gDialogWasExtended = PR_TRUE;
    1:   }
    1:   return 0L;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: // Creates the "Options" Property Sheet
    1: static HPROPSHEETPAGE ExtendPrintDialog(HWND aHWnd, char* aTitle)
    1: {
    1:   // The resource "OPTPROPSHEET" comes out of the widget/build/widget.rc file
29236:   HINSTANCE hInst = (HINSTANCE)::GetWindowLongPtr(aHWnd, GWLP_HINSTANCE);
    1:   PROPSHEETPAGE psp;
    1:   memset(&psp, 0, sizeof(PROPSHEETPAGE));
    1:   psp.dwSize      = sizeof(PROPSHEETPAGE);
    1:   psp.dwFlags     = PSP_USETITLE | PSP_PREMATURE;
    1:   psp.hInstance   = hInst;
    1:   psp.pszTemplate = "OPTPROPSHEET";
    1:   psp.pfnDlgProc  = PropSheetCallBack;
    1:   psp.pszTitle    = aTitle?aTitle:"Options";
    1: 
    1:   HPROPSHEETPAGE newPropSheet = ::CreatePropertySheetPage(&psp);
    1:   return newPropSheet;
    1: 
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: // Displays the native Print Dialog
    1: static nsresult 
    1: ShowNativePrintDialogEx(HWND              aHWnd,
    1:                         nsIPrintSettings* aPrintSettings)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aHWnd);
    1:   NS_ENSURE_ARG_POINTER(aPrintSettings);
    1: 
    1:   gDialogWasExtended  = PR_FALSE;
    1: 
    1:   // Create a Moveable Memory Object that holds a new DevMode
    1:   // from the Printer Name
    1:   // The PRINTDLG.hDevMode requires that it be a moveable memory object
    1:   // NOTE: We only need to free hGlobalDevMode when the dialog is cancelled
    1:   // When the user prints, it comes back in the printdlg struct and 
    1:   // is used and cleaned up later
58551:   nsXPIDLString printerName;
58551:   aPrintSettings->GetPrinterName(getter_Copies(printerName));
    1:   HGLOBAL hGlobalDevMode = NULL;
58551:   if (!printerName.IsEmpty()) {
20801:     hGlobalDevMode = CreateGlobalDevModeAndInit(printerName, aPrintSettings);
    1:   }
    1: 
    1:   // Prepare to Display the Print Dialog
    1:   PRINTDLGEX  prntdlg;
    1:   memset(&prntdlg, 0, sizeof(PRINTDLGEX));
    1: 
    1:   prntdlg.lStructSize = sizeof(prntdlg);
    1:   prntdlg.hwndOwner   = aHWnd;
    1:   prntdlg.hDevMode    = hGlobalDevMode;
    1:   prntdlg.Flags       = PD_ALLPAGES | PD_RETURNDC | PD_USEDEVMODECOPIESANDCOLLATE |
    1:                         PD_NOCURRENTPAGE;
    1:   prntdlg.nStartPage  = START_PAGE_GENERAL;
    1: 
    1:   // if there is a current selection then enable the "Selection" radio button
    1:   PRInt16 howToEnableFrameUI = nsIPrintSettings::kFrameEnableNone;
    1:   if (aPrintSettings != nsnull) {
    1:     PRBool isOn;
    1:     aPrintSettings->GetPrintOptions(nsIPrintSettings::kEnableSelectionRB, &isOn);
    1:     if (!isOn) {
    1:       prntdlg.Flags |= PD_NOSELECTION;
    1:     }
    1:     aPrintSettings->GetHowToEnableFrameUI(&howToEnableFrameUI);
    1:   }
    1: 
    1:   // At the moment we can only support one page range
    1:   // from all the documentation I can find, it appears that this 
    1:   // will get cleanup automatically when the struct goes away
    1:   const int kNumPageRanges     = 1;
    1:   LPPRINTPAGERANGE pPageRanges = (LPPRINTPAGERANGE) GlobalAlloc(GPTR, kNumPageRanges * sizeof(PRINTPAGERANGE));
    1:   if (!pPageRanges)
    1:       return E_OUTOFMEMORY;
    1: 
    1:   prntdlg.nPageRanges    = 0;
    1:   prntdlg.nMaxPageRanges = kNumPageRanges;
    1:   prntdlg.lpPageRanges   = pPageRanges;
    1:   prntdlg.nMinPage       = 1;
    1:   prntdlg.nMaxPage       = 0xFFFF;
    1:   prntdlg.nCopies        = 1;
    1: 
    1:   if (ShouldExtendPrintDialog()) {
    1:     // lLcalize the Property Sheet (Tab) title
    1:     nsCAutoString title;
    1:     nsString optionsStr;
33700:     if (NS_SUCCEEDED(GetLocalizedString(strBundle, "optionsTitleWindows", optionsStr))) {
    1:       // Failure here just means a blank string
    1:       NS_CopyUnicodeToNative(optionsStr, title);
    1:     }
    1: 
    1:     // Temporarily borrow this variable for setting up the radiobuttons
    1:     // if we don't use this, we will need to define a new global var
    1:     gFrameSelectedRadioBtn = howToEnableFrameUI;
    1:     HPROPSHEETPAGE psp[1];
    1:     psp[0] = ExtendPrintDialog(aHWnd, title.get());
    1:     prntdlg.nPropertyPages      = 1;
    1:     prntdlg.lphPropertyPages    = psp;
    1:   }
    1: 
    1:   HRESULT result = ::PrintDlgEx(&prntdlg);
    1: 
    1:   if (S_OK == result && (prntdlg.dwResultAction == PD_RESULT_PRINT)) {
    1: 
    1:     // check to make sure we don't have any NULL pointers
    1:     NS_ENSURE_TRUE(aPrintSettings && prntdlg.hDevMode, NS_ERROR_FAILURE);
    1: 
    1:     if (prntdlg.hDevNames == NULL) {
    1:       ::GlobalFree(hGlobalDevMode);
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     // Lock the deviceNames and check for NULL
    1:     DEVNAMES *devnames = (DEVNAMES *)::GlobalLock(prntdlg.hDevNames);
    1:     if (devnames == NULL) {
    1:       ::GlobalFree(hGlobalDevMode);
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     char* device = &(((char *)devnames)[devnames->wDeviceOffset]);
    1:     char* driver = &(((char *)devnames)[devnames->wDriverOffset]);
    1: 
    1:     // Check to see if the "Print To File" control is checked
    1:     // then take the name from devNames and set it in the PrintSettings
    1:     //
    1:     // NOTE:
    1:     // As per Microsoft SDK documentation the returned value offset from
    1:     // devnames->wOutputOffset is either "FILE:" or NULL
    1:     // if the "Print To File" checkbox is checked it MUST be "FILE:"
    1:     // We assert as an extra safety check.
    1:     if (prntdlg.Flags & PD_PRINTTOFILE) {
    1:       char* fileName = &(((char *)devnames)[devnames->wOutputOffset]);
    1:       NS_ASSERTION(strcmp(fileName, "FILE:") == 0, "FileName must be `FILE:`");
    1:       aPrintSettings->SetToFileName(NS_ConvertASCIItoUTF16(fileName).get());
    1:       aPrintSettings->SetPrintToFile(PR_TRUE);
    1:     } else {
    1:       // clear "print to file" info
    1:       aPrintSettings->SetPrintToFile(PR_FALSE);
    1:       aPrintSettings->SetToFileName(nsnull);
    1:     }
    1: 
    1:     nsCOMPtr<nsIPrintSettingsWin> psWin(do_QueryInterface(aPrintSettings));
    1:     if (!psWin) {
    1:       ::GlobalFree(hGlobalDevMode);
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // Setup local Data members
    1:     psWin->SetDeviceName(device);
    1:     psWin->SetDriverName(driver);
    1: 
    1: #if defined(DEBUG_rods) || defined(DEBUG_dcone)
    1:     printf("printer: driver %s, device %s  flags: %d\n", driver, device, prntdlg.Flags);
    1: #endif
    1:     ::GlobalUnlock(prntdlg.hDevNames);
    1: 
    1:     // fill the print options with the info from the dialog
    1:     if (aPrintSettings != nsnull) {
    1: 
    1:       if (prntdlg.Flags & PD_SELECTION) {
    1:         aPrintSettings->SetPrintRange(nsIPrintSettings::kRangeSelection);
    1: 
    1:       } else if (prntdlg.Flags & PD_PAGENUMS) {
    1:         aPrintSettings->SetPrintRange(nsIPrintSettings::kRangeSpecifiedPageRange);
    1:         aPrintSettings->SetStartPageRange(pPageRanges->nFromPage);
    1:         aPrintSettings->SetEndPageRange(pPageRanges->nToPage);
    1: 
    1:       } else { // (prntdlg.Flags & PD_ALLPAGES)
    1:         aPrintSettings->SetPrintRange(nsIPrintSettings::kRangeAllPages);
    1:       }
    1: 
    1:       if (howToEnableFrameUI != nsIPrintSettings::kFrameEnableNone) {
    1:         // make sure the dialog got extended
    1:         if (gDialogWasExtended) {
    1:           // check to see about the frame radio buttons
    1:           switch (gFrameSelectedRadioBtn) {
    1:             case rad4: 
    1:               aPrintSettings->SetPrintFrameType(nsIPrintSettings::kFramesAsIs);
    1:               break;
    1:             case rad5: 
    1:               aPrintSettings->SetPrintFrameType(nsIPrintSettings::kSelectedFrame);
    1:               break;
    1:             case rad6: 
    1:               aPrintSettings->SetPrintFrameType(nsIPrintSettings::kEachFrameSep);
    1:               break;
    1:           } // switch
    1:         } else {
    1:           // if it didn't get extended then have it default to printing
    1:           // each frame separately
    1:           aPrintSettings->SetPrintFrameType(nsIPrintSettings::kEachFrameSep);
    1:         }
    1:       } else {
    1:         aPrintSettings->SetPrintFrameType(nsIPrintSettings::kNoFrames);
    1:       }
    1:     }
    1: 
    1:     // Unlock DeviceNames
    1:     ::GlobalUnlock(prntdlg.hDevNames);
    1: 
    1:     // Transfer the settings from the native data to the PrintSettings
20801:     LPDEVMODEW devMode = (LPDEVMODEW)::GlobalLock(prntdlg.hDevMode);
    1:     if (devMode == NULL) {
    1:       ::GlobalFree(hGlobalDevMode);
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     psWin->SetDevMode(devMode); // copies DevMode
    1:     SetPrintSettingsFromDevMode(aPrintSettings, devMode);
    1:     ::GlobalUnlock(prntdlg.hDevMode);
    1: 
    1: #if defined(DEBUG_rods) || defined(DEBUG_dcone)
    1:     PRBool  printSelection = prntdlg.Flags & PD_SELECTION;
    1:     PRBool  printAllPages  = prntdlg.Flags & PD_ALLPAGES;
    1:     PRBool  printNumPages  = prntdlg.Flags & PD_PAGENUMS;
    1:     PRInt32 fromPageNum    = 0;
    1:     PRInt32 toPageNum      = 0;
    1: 
    1:     if (printNumPages) {
    1:       fromPageNum = pPageRanges->nFromPage;
    1:       toPageNum   = pPageRanges->nToPage;
    1:     } 
    1:     if (printSelection) {
    1:       printf("Printing the selection\n");
    1: 
    1:     } else if (printAllPages) {
    1:       printf("Printing all the pages\n");
    1: 
    1:     } else {
    1:       printf("Printing from page no. %d to %d\n", fromPageNum, toPageNum);
    1:     }
    1: #endif
    1:     
    1:   } else {
    1:     if (hGlobalDevMode) ::GlobalFree(hGlobalDevMode);
    1:     return NS_ERROR_ABORT;
    1:   }
    1: 
    1:   ::GlobalFree(pPageRanges);
    1: 
    1:   return NS_OK;
    1: }
    1: #endif // MOZ_REQUIRE_CURRENT_SDK
    1: 
    1: //------------------------------------------------------------------
    1: static void 
    1: PrepareForPrintDialog(nsIWebBrowserPrint* aWebBrowserPrint, nsIPrintSettings* aPS)
    1: {
    1:   NS_ASSERTION(aWebBrowserPrint, "Can't be null");
    1:   NS_ASSERTION(aPS, "Can't be null");
    1: 
    1:   PRBool isFramesetDocument;
    1:   PRBool isFramesetFrameSelected;
    1:   PRBool isIFrameSelected;
    1:   PRBool isRangeSelection;
    1: 
    1:   aWebBrowserPrint->GetIsFramesetDocument(&isFramesetDocument);
    1:   aWebBrowserPrint->GetIsFramesetFrameSelected(&isFramesetFrameSelected);
    1:   aWebBrowserPrint->GetIsIFrameSelected(&isIFrameSelected);
    1:   aWebBrowserPrint->GetIsRangeSelection(&isRangeSelection);
    1: 
    1:   // Setup print options for UI
    1:   if (isFramesetDocument) {
    1:     if (isFramesetFrameSelected) {
    1:       aPS->SetHowToEnableFrameUI(nsIPrintSettings::kFrameEnableAll);
    1:     } else {
    1:       aPS->SetHowToEnableFrameUI(nsIPrintSettings::kFrameEnableAsIsAndEach);
    1:     }
    1:   } else {
    1:     aPS->SetHowToEnableFrameUI(nsIPrintSettings::kFrameEnableNone);
    1:   }
    1: 
    1:   // Now determine how to set up the Frame print UI
    1:   aPS->SetPrintOptions(nsIPrintSettings::kEnableSelectionRB, isRangeSelection || isIFrameSelected);
    1: 
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: //-- Show Print Dialog
    1: //----------------------------------------------------------------------------------
    1: nsresult NativeShowPrintDialog(HWND                aHWnd,
    1:                                nsIWebBrowserPrint* aWebBrowserPrint,
    1:                                nsIPrintSettings*   aPrintSettings)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   PrepareForPrintDialog(aWebBrowserPrint, aPrintSettings);
    1: 
    1: #ifdef MOZ_REQUIRE_CURRENT_SDK
    1:   if (CheckForExtendedDialog()) {
    1:     rv = ShowNativePrintDialogEx(aHWnd, aPrintSettings);
    1:   } else {
    1:     rv = ShowNativePrintDialog(aHWnd, aPrintSettings);
    1:   }
    1: #else
    1:   rv = ShowNativePrintDialog(aHWnd, aPrintSettings);
    1: #endif
52079:   if (aHWnd) {
52079:     ::DestroyWindow(aHWnd);
52079:   }
    1: 
    1:   return rv;
    1: }
    1: 
