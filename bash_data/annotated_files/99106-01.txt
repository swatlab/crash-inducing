    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
98983: /* This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
    1: 
    1: #include "nsHTMLTableAccessible.h"
39503: 
95352: #include "Accessible-inl.h"
41384: #include "nsAccessibilityService.h"
47105: #include "nsAccTreeWalker.h"
41384: #include "nsAccUtils.h"
39503: #include "nsDocAccessible.h"
41384: #include "nsTextEquivUtils.h"
87094: #include "Relation.h"
87094: #include "Role.h"
87094: #include "States.h"
39503: 
75194: #include "nsIAccessibleRelation.h"
    1: #include "nsIDOMElement.h"
 1370: #include "nsIDOMDocument.h"
 1370: #include "nsIDOMRange.h"
 1370: #include "nsISelectionPrivate.h"
    1: #include "nsINameSpaceManager.h"
75263: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMHTMLCollection.h"
    1: #include "nsIDOMHTMLTableCellElement.h"
    1: #include "nsIDOMHTMLTableElement.h"
    1: #include "nsIDOMHTMLTableRowElement.h"
    1: #include "nsIDOMHTMLTableSectionElem.h"
    1: #include "nsIDocument.h"
    1: #include "nsIPresShell.h"
    1: #include "nsITableLayout.h"
  666: #include "nsITableCellLayout.h"
32354: #include "nsFrameSelection.h"
12645: #include "nsLayoutErrors.h"
32381: #include "nsArrayUtils.h"
75263: #include "nsComponentManagerUtils.h"
    1: 
74618: using namespace mozilla::a11y;
74618: 
14327: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableCellAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
28316: 
32381: nsHTMLTableCellAccessible::
89799:   nsHTMLTableCellAccessible(nsIContent* aContent, nsDocAccessible* aDoc) :
89799:   nsHyperTextAccessibleWrap(aContent, aDoc)
    1: {
    1: }
    1: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableCellAccessible: nsISupports implementation
32381: 
32381: NS_IMPL_ISUPPORTS_INHERITED1(nsHTMLTableCellAccessible,
32381:                              nsHyperTextAccessible,
32381:                              nsIAccessibleTableCell)
32381: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableCellAccessible: nsAccessible implementation
28316: 
87094: role
52027: nsHTMLTableCellAccessible::NativeRole()
    1: {
87094:   return roles::CELL;
    1: }
    1: 
67790: PRUint64
67790: nsHTMLTableCellAccessible::NativeState()
30059: {
67790:   PRUint64 state = nsHyperTextAccessibleWrap::NativeState();
30059: 
43504:   nsIFrame *frame = mContent->GetPrimaryFrame();
30059:   NS_ASSERTION(frame, "No frame for valid cell accessible!");
30059: 
30059:   if (frame) {
67790:     state |= states::SELECTABLE;
85101:     if (frame->IsSelected())
67790:       state |= states::SELECTED;
30059:   }
30059: 
67790:   return state;
30059: }
30059: 
30059: nsresult
14327: nsHTMLTableCellAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
14327: {
14327:   if (IsDefunct())
14327:     return NS_ERROR_FAILURE;
14327: 
14327:   nsresult rv = nsHyperTextAccessibleWrap::GetAttributesInternal(aAttributes);
14327:   NS_ENSURE_SUCCESS(rv, rv);
14327: 
82721:   // table-cell-index attribute
28316:   nsCOMPtr<nsIAccessibleTable> tableAcc(GetTableAccessible());
28316:   if (!tableAcc)
28316:     return NS_OK;
28316: 
28316:   PRInt32 rowIdx = -1, colIdx = -1;
28316:   rv = GetCellIndexes(rowIdx, colIdx);
28316:   NS_ENSURE_SUCCESS(rv, rv);
28316: 
28316:   PRInt32 idx = -1;
32381:   rv = tableAcc->GetCellIndexAt(rowIdx, colIdx, &idx);
28316:   NS_ENSURE_SUCCESS(rv, rv);
28316: 
28316:   nsAutoString stringIdx;
28316:   stringIdx.AppendInt(idx);
78350:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::tableCellIndex, stringIdx);
82721: 
82721:   // abbr attribute
82721: 
82721:   // Pick up object attribute from abbr DOM element (a child of the cell) or
82721:   // from abbr DOM attribute.
82721:   nsAutoString abbrText;
82721:   if (GetChildCount() == 1) {
82721:     nsAccessible* abbr = FirstChild();
82721:     if (abbr->IsAbbreviation()) {
82721:       nsTextEquivUtils::
82721:         AppendTextEquivFromTextContent(abbr->GetContent()->GetFirstChild(),
82721:                                        &abbrText);
82721:     }
82721:   }
82721:   if (abbrText.IsEmpty())
82721:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::abbr, abbrText);
82721: 
82721:   if (!abbrText.IsEmpty())
82721:     nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::abbr, abbrText);
82721: 
82722:   // axis attribute
82722:   nsAutoString axisText;
82722:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::axis, axisText);
82722:   if (!axisText.IsEmpty())
82722:     nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::axis, axisText);
82722: 
28316:   return NS_OK;
28316: }
28316: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableCellAccessible: nsIAccessibleTableCell implementation
28316: 
28316: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetTable(nsIAccessibleTable **aTable)
28316: {
32381:   NS_ENSURE_ARG_POINTER(aTable);
32381:   *aTable = nsnull;
28316: 
32381:   if (IsDefunct())
28316:     return NS_OK;
28316: 
32381:   nsCOMPtr<nsIAccessibleTable> table = GetTableAccessible();
32381:   table.swap(*aTable);
28316: 
32381:   return NS_OK;
28316: }
28316: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetColumnIndex(PRInt32 *aColumnIndex)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aColumnIndex);
32381:   *aColumnIndex = -1;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsITableCellLayout* cellLayout = GetCellLayout();
32381:   NS_ENSURE_STATE(cellLayout);
32381: 
32381:   return cellLayout->GetColIndex(*aColumnIndex);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetRowIndex(PRInt32 *aRowIndex)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aRowIndex);
32381:   *aRowIndex = -1;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsITableCellLayout* cellLayout = GetCellLayout();
32381:   NS_ENSURE_STATE(cellLayout);
32381: 
32381:   return cellLayout->GetRowIndex(*aRowIndex);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetColumnExtent(PRInt32 *aExtentCount)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
32381:   *aExtentCount = 1;
32381: 
32381:   PRInt32 rowIdx = -1, colIdx = -1;
32381:   GetCellIndexes(rowIdx, colIdx);
32381: 
32381:   nsCOMPtr<nsIAccessibleTable> table = GetTableAccessible();
32381:   NS_ENSURE_STATE(table);
32381: 
32381:   return table->GetColumnExtentAt(rowIdx, colIdx, aExtentCount);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetRowExtent(PRInt32 *aExtentCount)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
32381:   *aExtentCount = 1;
32381: 
32381:   PRInt32 rowIdx = -1, colIdx = -1;
32381:   GetCellIndexes(rowIdx, colIdx);
32381: 
32381:   nsCOMPtr<nsIAccessibleTable> table = GetTableAccessible();
32381:   NS_ENSURE_STATE(table);
32381: 
32381:   return table->GetRowExtentAt(rowIdx, colIdx, aExtentCount);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetColumnHeaderCells(nsIArray **aHeaderCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
32381:   *aHeaderCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   return GetHeaderCells(nsAccUtils::eColumnHeaderCells, aHeaderCells);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetRowHeaderCells(nsIArray **aHeaderCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
32381:   *aHeaderCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   return GetHeaderCells(nsAccUtils::eRowHeaderCells, aHeaderCells);
32381: }
32381: 
32381: NS_IMETHODIMP
79445: nsHTMLTableCellAccessible::IsSelected(bool *aIsSelected)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aIsSelected);
80486:   *aIsSelected = false;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   PRInt32 rowIdx = -1, colIdx = -1;
32381:   GetCellIndexes(rowIdx, colIdx);
32381: 
32381:   nsCOMPtr<nsIAccessibleTable> table = GetTableAccessible();
32381:   NS_ENSURE_STATE(table);
32381: 
32381:   return table->IsCellSelected(rowIdx, colIdx, aIsSelected);
32381: }
32381: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableCellAccessible: protected implementation
28316: 
28316: already_AddRefed<nsIAccessibleTable>
28316: nsHTMLTableCellAccessible::GetTableAccessible()
28316: {
52089:   nsAccessible* parent = this;
74545:   while ((parent = parent->Parent())) {
87094:     roles::Role role = parent->Role();
87094:     if (role == roles::TABLE || role == roles::TREE_TABLE) {
28316:       nsIAccessibleTable* tableAcc = nsnull;
52089:       CallQueryInterface(parent, &tableAcc);
28316:       return tableAcc;
28316:     }
28316:   }
28316: 
28316:   return nsnull;
28316: }
28316: 
32381: nsITableCellLayout*
32381: nsHTMLTableCellAccessible::GetCellLayout()
32381: {
43504:   nsIFrame *frame = mContent->GetPrimaryFrame();
32381:   NS_ASSERTION(frame, "The frame cannot be obtaied for HTML table cell.");
32381:   if (!frame)
32381:     return nsnull;
32381: 
32381:   nsITableCellLayout *cellLayout = do_QueryFrame(frame);
32381:   return cellLayout;
32381: }
32381: 
28316: nsresult
28316: nsHTMLTableCellAccessible::GetCellIndexes(PRInt32& aRowIndex,
28316:                                           PRInt32& aColIndex)
28316: {
32381:   nsITableCellLayout *cellLayout = GetCellLayout();
14327:   NS_ENSURE_STATE(cellLayout);
14327: 
28316:   return cellLayout->GetCellIndexes(aRowIndex, aColIndex);
28316: }
28316: 
28316: nsresult
32381: nsHTMLTableCellAccessible::GetHeaderCells(PRInt32 aRowOrColumnHeaderCell,
32381:                                           nsIArray **aHeaderCells)
28316: {
32381:   // Get header cells from @header attribute.
93856:   IDRefsIterator iter(mDoc, mContent, nsGkAtoms::headers);
57626:   nsIContent* headerCellElm = iter.NextElem();
57626:   if (headerCellElm) {
32381:     nsresult rv = NS_OK;
32381:     nsCOMPtr<nsIMutableArray> headerCells =
32381:       do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
14327:     NS_ENSURE_SUCCESS(rv, rv);
87094:     roles::Role desiredRole = static_cast<roles::Role>(-1) ;
72478:     if (aRowOrColumnHeaderCell == nsAccUtils::eRowHeaderCells)
87094:       desiredRole = roles::ROWHEADER;
72478:     else if (aRowOrColumnHeaderCell == nsAccUtils::eColumnHeaderCells)
87094:       desiredRole = roles::COLUMNHEADER;
14327: 
57626:     do {
89799:       nsAccessible* headerCell = mDoc->GetAccessible(headerCellElm);
14327: 
72478:       if (headerCell && headerCell->Role() == desiredRole)
42795:         headerCells->AppendElement(static_cast<nsIAccessible*>(headerCell),
80486:                                    false);
57626:     } while ((headerCellElm = iter.NextElem()));
14327: 
32381:     NS_ADDREF(*aHeaderCells = headerCells);
32381:     return NS_OK;
28316:   }
28316: 
32381:   // Otherwise calculate header cells from hierarchy (see 11.4.3 "Algorithm to
32381:   // find heading information" of w3c HTML 4.01).
32381:   nsCOMPtr<nsIAccessibleTable> table = GetTableAccessible();
32381:   if (table) {
32381:     return nsAccUtils::GetHeaderCellsFor(table, this, aRowOrColumnHeaderCell,
32381:                                          aHeaderCells);
14327:   }
14327: 
14327:   return NS_OK;
14327: }
14327: 
28316: ////////////////////////////////////////////////////////////////////////////////
28316: // nsHTMLTableHeaderAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
28316: 
32381: nsHTMLTableHeaderCellAccessible::
43504:   nsHTMLTableHeaderCellAccessible(nsIContent* aContent,
89799:                                   nsDocAccessible* aDoc) :
89799:   nsHTMLTableCellAccessible(aContent, aDoc)
28316: {
28316: }
28316: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableHeaderAccessible: nsAccessible implementation
32381: 
87094: role
52027: nsHTMLTableHeaderCellAccessible::NativeRole()
28316: {
28316:   // Check value of @scope attribute.
28316:   static nsIContent::AttrValuesArray scopeValues[] =
78350:     {&nsGkAtoms::col, &nsGkAtoms::row, nsnull};
28316:   PRInt32 valueIdx = 
78350:     mContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::scope,
28316:                               scopeValues, eCaseMatters);
28316: 
28316:   switch (valueIdx) {
28316:     case 0:
87094:       return roles::COLUMNHEADER;
28316:     case 1:
87094:       return roles::ROWHEADER;
28316:   }
28316: 
28316:   // Assume it's columnheader if there are headers in siblings, oterwise
28316:   // rowheader.
84146:   nsIContent* parentContent = mContent->GetParent();
84146:   if (!parentContent) {
52027:     NS_ERROR("Deattached content on alive accessible?");
87094:     return roles::NOTHING;
52027:   }
34720: 
84146:   for (nsIContent* siblingContent = mContent->GetPreviousSibling(); siblingContent;
84146:        siblingContent = siblingContent->GetPreviousSibling()) {
84146:     if (siblingContent->IsElement()) {
87094:       return nsCoreUtils::IsHTMLTableHeader(siblingContent) ? 
87094: 	     roles::COLUMNHEADER : roles::ROWHEADER;
28316:     }
28316:   }
28316: 
84146:   for (nsIContent* siblingContent = mContent->GetNextSibling(); siblingContent;
84146:        siblingContent = siblingContent->GetNextSibling()) {
84146:     if (siblingContent->IsElement()) {
87094:       return nsCoreUtils::IsHTMLTableHeader(siblingContent) ? 
87094: 	     roles::COLUMNHEADER : roles::ROWHEADER;
28316:     }
28316:   }
28316: 
35582:   // No elements in siblings what means the table has one column only. Therefore
35582:   // it should be column header.
87094:   return roles::COLUMNHEADER;
28316: }
28316: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
32381: 
32381: nsHTMLTableAccessible::
89799:   nsHTMLTableAccessible(nsIContent* aContent, nsDocAccessible* aDoc) :
94235:   nsAccessibleWrap(aContent, aDoc), xpcAccessibleTable(this)
28316: {
28316: }
28316: 
14327: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableAccessible: nsISupports implementation
14327: 
95104: NS_IMPL_ISUPPORTS_INHERITED1(nsHTMLTableAccessible, nsAccessible,
95104:                              nsIAccessibleTable)
    1: 
94235: ////////////////////////////////////////////////////////////////////////////////
94235: //nsAccessNode
94235: 
94235: void
94235: nsHTMLTableAccessible::Shutdown()
94235: {
94235:   mTable = nsnull;
94235:   nsAccessibleWrap::Shutdown();
94235: }
94235: 
32381: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableAccessible: nsAccessible implementation
  140: 
35523: void
35523: nsHTMLTableAccessible::CacheChildren()
  140: {
47105:   // Move caption accessible so that it's the first child. Check for the first
47105:   // caption only, because nsAccessibilityService ensures we don't create
47105:   // accessibles for the other captions, since only the first is actually
47105:   // visible.
89801:   nsAccTreeWalker walker(mDoc, mContent, CanHaveAnonChildren());
35136: 
64506:   nsAccessible* child = nsnull;
64506:   while ((child = walker.NextChild())) {
87094:     if (child->Role() == roles::CAPTION) {
47105:       InsertChildAt(0, child);
64506:       while ((child = walker.NextChild()) && AppendChild(child));
35133:       break;
35136:     }
47105:     AppendChild(child);
  140:   }
  140: }
    1: 
87094: role
52027: nsHTMLTableAccessible::NativeRole()
    1: {
87094:   return roles::TABLE;
    1: }
    1: 
67790: PRUint64
67790: nsHTMLTableAccessible::NativeState()
    1: {
67790:   return nsAccessible::NativeState() | states::READONLY;
    1: }
    1: 
20246: nsresult
20246: nsHTMLTableAccessible::GetNameInternal(nsAString& aName)
    1: {
20246:   nsAccessible::GetNameInternal(aName);
72333:   if (!aName.IsEmpty())
72333:     return NS_OK;
    1: 
72333:   // Use table caption as a name.
72333:   nsAccessible* caption = Caption();
72333:   if (caption) {
72333:     nsIContent* captionContent = caption->GetContent();
72333:     if (captionContent) {
72333:       nsTextEquivUtils::AppendTextEquivFromContent(this, captionContent, &aName);
72333:       if (!aName.IsEmpty())
72333:         return NS_OK;
72333:     }
72333:   }
72333: 
72333:   // If no caption then use summary as a name.
78350:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::summary, aName);
    1:   return NS_OK;
    1: }
    1: 
  401: nsresult
  401: nsHTMLTableAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
    1: {
  401:   nsresult rv = nsAccessibleWrap::GetAttributesInternal(aAttributes);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
94235:   if (IsProbablyLayoutTable()) {
    1:     nsAutoString oldValueUnused;
  401:     aAttributes->SetStringProperty(NS_LITERAL_CSTRING("layout-guess"),
  401:                                    NS_LITERAL_STRING("true"), oldValueUnused);
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableAccessible: nsIAccessible implementation
32381: 
75194: Relation
75194: nsHTMLTableAccessible::RelationByType(PRUint32 aType)
    1: {
75194:   Relation rel = nsAccessibleWrap::RelationByType(aType);
75194:   if (aType == nsIAccessibleRelation::RELATION_LABELLED_BY)
75194:     rel.AppendTarget(Caption());
    1: 
75194:   return rel;
 1560: }
    1: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableAccessible: nsIAccessibleTable implementation
    1: 
94235: nsAccessible*
94235: nsHTMLTableAccessible::Caption()
    1: {
94235:   nsAccessible* child = mChildren.SafeElementAt(0, nsnull);
94235:   return child && child->Role() == roles::CAPTION ? child : nsnull;
    1: }
    1: 
95493: void
95493: nsHTMLTableAccessible::Summary(nsString& aSummary)
    1: {
43504:   nsCOMPtr<nsIDOMHTMLTableElement> table(do_QueryInterface(mContent));
    1:   
95493:   if (table)
95493:     table->GetSummary(aSummary);
    1: }
    1: 
96901: PRUint32
96901: nsHTMLTableAccessible::ColCount()
    1: {
96901:   nsITableLayout* tableLayout = GetTableLayout();
99106:   if (!tableLayout)
99106:     return 0;
32381: 
96901:   PRInt32 rowCount = 0, colCount = 0;
96901:   tableLayout->GetTableSize(rowCount, colCount);
96901:   return colCount;
    1: }
    1: 
96901: PRUint32
96901: nsHTMLTableAccessible::RowCount()
    1: {
96901:   nsITableLayout* tableLayout = GetTableLayout();
99106:   if (!tableLayout)
99106:     return 0;
    1: 
96901:   PRInt32 rowCount = 0, colCount = 0;
96901:   tableLayout->GetTableSize(rowCount, colCount);
96901:   return rowCount;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedCellCount(PRUint32* aCount)
 3337: {
 3337:   NS_ENSURE_ARG_POINTER(aCount);
 3337:   *aCount = 0;
 3337: 
32381:   PRInt32 rowCount = 0;
32381:   nsresult rv = GetRowCount(&rowCount);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
29966: 
29966:   nsCOMPtr<nsIDOMElement> domElement;
29966:   PRInt32 startRowIndex = 0, startColIndex = 0,
29966:     rowSpan, colSpan, actualRowSpan, actualColSpan;
79445:   bool isSelected = false;
29966: 
 3337:   PRInt32 rowIndex;
32381:   for (rowIndex = 0; rowIndex < rowCount; rowIndex++) {
 3337:     PRInt32 columnIndex;
32381:     for (columnIndex = 0; columnIndex < columnCount; columnIndex++) {
29966:       rv = tableLayout->GetCellDataAt(rowIndex, columnIndex,
29966:                                       *getter_AddRefs(domElement),
29966:                                       startRowIndex, startColIndex,
29966:                                       rowSpan, colSpan,
29966:                                       actualRowSpan, actualColSpan,
29966:                                       isSelected);
 3337: 
29966:       if (NS_SUCCEEDED(rv) && startRowIndex == rowIndex &&
29966:           startColIndex == columnIndex && isSelected) {
 3337:         (*aCount)++;
 3337:       }
 3337:     }
29966:   }
 3337: 
 3337:   return NS_OK;
 3337: }
 3337: 
 3337: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedColumnCount(PRUint32* aCount)
 3337: {
 3337:   NS_ENSURE_ARG_POINTER(aCount);
 3337:   *aCount = 0;
 3337: 
 3337:   PRInt32 count = 0;
32381:   nsresult rv = GetColumnCount(&count);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
 3337:   PRInt32 index;
 3337:   for (index = 0; index < count; index++) {
79445:     bool state = false;
 3337:     rv = IsColumnSelected(index, &state);
 3337:     NS_ENSURE_SUCCESS(rv, rv);
 3337: 
 3337:     if (state)
 3337:       (*aCount)++;
 3337:   }
 3337: 
 3337:   return NS_OK;
 3337: }
 3337: 
 3337: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedRowCount(PRUint32* aCount)
 3337: {
 3337:   NS_ENSURE_ARG_POINTER(aCount);
 3337:   *aCount = 0;
 3337: 
 3337:   PRInt32 count = 0;
32381:   nsresult rv = GetRowCount(&count);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
 3337:   PRInt32 index;
 3337:   for (index = 0; index < count; index++) {
79445:     bool state = false;
 3337:     rv = IsRowSelected(index, &state);
 3337:     NS_ENSURE_SUCCESS(rv, rv);
 3337: 
 3337:     if (state)
 3337:       (*aCount)++;
 3337:   }
 3337: 
 3337:   return NS_OK;
 3337: }
 3337: 
 3337: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedCells(nsIArray **aCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aCells);
32381:   *aCells = nsnull;
32381: 
32381:   PRInt32 rowCount = 0;
32381:   nsresult rv = GetRowCount(&rowCount);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
32381: 
32381:   nsCOMPtr<nsIMutableArray> selCells =
32381:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   nsCOMPtr<nsIDOMElement> cellElement;
32381:   PRInt32 startRowIndex = 0, startColIndex = 0,
32381:     rowSpan, colSpan, actualRowSpan, actualColSpan;
79445:   bool isSelected = false;
32381: 
32381:   PRInt32 rowIndex, index;
32381:   for (rowIndex = 0, index = 0; rowIndex < rowCount; rowIndex++) {
32381:     PRInt32 columnIndex;
32381:     for (columnIndex = 0; columnIndex < columnCount; columnIndex++, index++) {
32381:       rv = tableLayout->GetCellDataAt(rowIndex, columnIndex,
32381:                                       *getter_AddRefs(cellElement),
32381:                                       startRowIndex, startColIndex,
32381:                                       rowSpan, colSpan,
32381:                                       actualRowSpan, actualColSpan,
32381:                                       isSelected);
32381: 
32381:       if (NS_SUCCEEDED(rv) && startRowIndex == rowIndex &&
32381:           startColIndex == columnIndex && isSelected) {
43504:         nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElement));
89799:         nsAccessible *cell = mDoc->GetAccessible(cellContent);
80486:         selCells->AppendElement(static_cast<nsIAccessible*>(cell), false);
32381:       }
32381:     }
32381:   }
32381: 
32381:   NS_ADDREF(*aCells = selCells);
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedCellIndices(PRUint32 *aNumCells,
 3337:                                               PRInt32 **aCells)
 3337: {
 3337:   NS_ENSURE_ARG_POINTER(aNumCells);
 3337:   *aNumCells = 0;
 3337:   NS_ENSURE_ARG_POINTER(aCells);
 3337:   *aCells = nsnull;
 3337: 
32381:   PRInt32 rowCount = 0;
32381:   nsresult rv = GetRowCount(&rowCount);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
29966: 
29966:   nsCOMPtr<nsIDOMElement> domElement;
29966:   PRInt32 startRowIndex = 0, startColIndex = 0,
29966:     rowSpan, colSpan, actualRowSpan, actualColSpan;
79445:   bool isSelected = false;
29966: 
32381:   PRInt32 cellsCount = columnCount * rowCount;
79445:   nsAutoArrayPtr<bool> states(new bool[cellsCount]);
 3337:   NS_ENSURE_TRUE(states, NS_ERROR_OUT_OF_MEMORY);
 3337: 
 3337:   PRInt32 rowIndex, index;
32381:   for (rowIndex = 0, index = 0; rowIndex < rowCount; rowIndex++) {
 3337:     PRInt32 columnIndex;
32381:     for (columnIndex = 0; columnIndex < columnCount; columnIndex++, index++) {
29966:       rv = tableLayout->GetCellDataAt(rowIndex, columnIndex,
29966:                                       *getter_AddRefs(domElement),
29966:                                       startRowIndex, startColIndex,
29966:                                       rowSpan, colSpan,
29966:                                       actualRowSpan, actualColSpan,
29966:                                       isSelected);
 3337: 
29966:       if (NS_SUCCEEDED(rv) && startRowIndex == rowIndex &&
29966:           startColIndex == columnIndex && isSelected) {
80486:         states[index] = true;
 3337:         (*aNumCells)++;
29966:       } else {
80486:         states[index] = false;
29966:       }
 3337:     }
 3337:   }
 3337: 
 3337:   PRInt32 *cellsArray =
32381:     static_cast<PRInt32*>(nsMemory::Alloc((*aNumCells) * sizeof(PRInt32)));
 3337:   NS_ENSURE_TRUE(cellsArray, NS_ERROR_OUT_OF_MEMORY);
 3337: 
 3337:   PRInt32 curr = 0;
32381:   for (rowIndex = 0, index = 0; rowIndex < rowCount; rowIndex++) {
 3337:     PRInt32 columnIndex;
32381:     for (columnIndex = 0; columnIndex < columnCount; columnIndex++, index++) {
 3337:       if (states[index]) {
 3337:         PRInt32 cellIndex = -1;
32381:         GetCellIndexAt(rowIndex, columnIndex, &cellIndex);
 3337:         cellsArray[curr++] = cellIndex;
 3337:       }
 3337:     }
 3337:   }
 3337: 
 3337:   *aCells = cellsArray;
 3337:   return NS_OK;
 3337: }
 3337: 
 3337: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedColumnIndices(PRUint32 *aNumColumns,
    1:                                                 PRInt32 **aColumns)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   PRInt32 columnCount;
32381:   rv = GetColumnCount(&columnCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
79445:   bool *states = new bool[columnCount];
    1:   NS_ENSURE_TRUE(states, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   *aNumColumns = 0;
    1:   PRInt32 index;
    1:   for (index = 0; index < columnCount; index++) {
    1:     rv = IsColumnSelected(index, &states[index]);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (states[index]) {
    1:       (*aNumColumns)++;
    1:     }
    1:   }
    1: 
    1:   PRInt32 *outArray = (PRInt32 *)nsMemory::Alloc((*aNumColumns) * sizeof(PRInt32));
    1:   if (!outArray) {
    1:     delete []states;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   PRInt32 curr = 0;
    1:   for (index = 0; index < columnCount; index++) {
    1:     if (states[index]) {
    1:       outArray[curr++] = index;
    1:     }
    1:   }
    1: 
    1:   delete []states;
    1:   *aColumns = outArray;
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedRowIndices(PRUint32 *aNumRows,
32381:                                              PRInt32 **aRows)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   PRInt32 rowCount;
32381:   rv = GetRowCount(&rowCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
79445:   bool *states = new bool[rowCount];
    1:   NS_ENSURE_TRUE(states, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   *aNumRows = 0;
    1:   PRInt32 index;
    1:   for (index = 0; index < rowCount; index++) {
    1:     rv = IsRowSelected(index, &states[index]);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (states[index]) {
    1:       (*aNumRows)++;
    1:     }
    1:   }
    1: 
    1:   PRInt32 *outArray = (PRInt32 *)nsMemory::Alloc((*aNumRows) * sizeof(PRInt32));
    1:   if (!outArray) {
    1:     delete []states;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   PRInt32 curr = 0;
    1:   for (index = 0; index < rowCount; index++) {
    1:     if (states[index]) {
    1:       outArray[curr++] = index;
    1:     }
    1:   }
    1: 
    1:   delete []states;
    1:   *aRows = outArray;
    1:   return rv;
    1: }
    1: 
99104: nsAccessible*
99104: nsHTMLTableAccessible::CellAt(PRUint32 aRowIndex, PRUint32 aColumnIndex)
    1: { 
    1:   nsCOMPtr<nsIDOMElement> cellElement;
99104:   GetCellAt(aRowIndex, aColumnIndex, *getter_AddRefs(cellElement));
99104:   if (!cellElement)
99104:     return nsnull;
    1: 
43504:   nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElement));
99104:   if (!cellContent)
99104:     return nsnull;
99104: 
89799:   nsAccessible* cell = mDoc->GetAccessible(cellContent);
49702: 
49701:   // XXX bug 576838: crazy tables (like table6 in tables/test_table2.html) may
49701:   // return itself as a cell what makes Orca hang.
99104:   return cell == this ? nsnull : cell;
    1: }
    1: 
98239: PRInt32
98239: nsHTMLTableAccessible::CellIndexAt(PRUint32 aRowIdx, PRUint32 aColIdx)
    1: {
98239:   nsITableLayout* tableLayout = GetTableLayout();
    1: 
98239:   PRInt32 index = -1;
98239:   tableLayout->GetIndexByRowAndColumn(aRowIdx, aColIdx, &index);
98239:   return index;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetColumnIndexAt(PRInt32 aIndex, PRInt32 *aColumn)
    1: {
  666:   NS_ENSURE_ARG_POINTER(aColumn);
    1: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
11311: 
11311:   PRInt32 row;
34001:   nsresult rv = tableLayout->GetRowAndColumnByIndex(aIndex, &row, aColumn);
34001:   NS_ENSURE_SUCCESS(rv, rv);
34001: 
34001:   return (row == -1 || *aColumn == -1) ? NS_ERROR_INVALID_ARG : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetRowIndexAt(PRInt32 aIndex, PRInt32 *aRow)
    1: {
  666:   NS_ENSURE_ARG_POINTER(aRow);
    1: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
11311: 
11311:   PRInt32 column;
34001:   nsresult rv = tableLayout->GetRowAndColumnByIndex(aIndex, aRow, &column);
34001:   NS_ENSURE_SUCCESS(rv, rv);
34001: 
34001:   return (*aRow == -1 || column == -1) ? NS_ERROR_INVALID_ARG : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
47173: nsHTMLTableAccessible::GetRowAndColumnIndicesAt(PRInt32 aIndex,
47173:                                                 PRInt32* aRowIdx,
47173:                                                 PRInt32* aColumnIdx)
47173: {
47173:   NS_ENSURE_ARG_POINTER(aRowIdx);
47173:   *aRowIdx = -1;
47173:   NS_ENSURE_ARG_POINTER(aColumnIdx);
47173:   *aColumnIdx = -1;
47173: 
47173:   if (IsDefunct())
47173:     return NS_ERROR_FAILURE;
47173: 
47173:   nsITableLayout* tableLayout = GetTableLayout();
47173:   if (tableLayout)
47173:     tableLayout->GetRowAndColumnByIndex(aIndex, aRowIdx, aColumnIdx);
47173: 
47173:   return (*aRowIdx == -1 || *aColumnIdx == -1) ? NS_ERROR_INVALID_ARG : NS_OK;
47173: }
47173: 
47173: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetColumnExtentAt(PRInt32 aRowIndex,
32381:                                          PRInt32 aColumnIndex,
32381:                                          PRInt32 *aExtentCount)
    1: {
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
    1: 
    1:   nsCOMPtr<nsIDOMElement> domElement;
32381:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan;
79445:   bool isSelected;
    1: 
34001:   nsresult rv = tableLayout->
32381:     GetCellDataAt(aRowIndex, aColumnIndex, *getter_AddRefs(domElement),
32381:                   startRowIndex, startColIndex, rowSpan, colSpan,
32381:                   actualRowSpan, *aExtentCount, isSelected);
34001: 
34001:   return (rv == NS_TABLELAYOUT_CELL_NOT_FOUND) ? NS_ERROR_INVALID_ARG : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetRowExtentAt(PRInt32 aRowIndex, PRInt32 aColumnIndex,
32381:                                       PRInt32 *aExtentCount)
    1: {
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
    1: 
    1:   nsCOMPtr<nsIDOMElement> domElement;
32381:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualColSpan;
79445:   bool isSelected;
    1: 
34001:   nsresult rv = tableLayout->
32381:     GetCellDataAt(aRowIndex, aColumnIndex, *getter_AddRefs(domElement),
32381:                   startRowIndex, startColIndex, rowSpan, colSpan,
32381:                   *aExtentCount, actualColSpan, isSelected);
34001: 
34001:   return (rv == NS_TABLELAYOUT_CELL_NOT_FOUND) ? NS_ERROR_INVALID_ARG : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLTableAccessible::GetColumnDescription(PRInt32 aColumn, nsAString &_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLTableAccessible::GetRowDescription(PRInt32 aRow, nsAString &_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsHTMLTableAccessible::IsColumnSelected(PRInt32 aColumn, bool *aIsSelected)
    1: {
34001:   NS_ENSURE_ARG_POINTER(aIsSelected);
80486:   *aIsSelected = false;
    1: 
34001:   PRInt32 colCount = 0;
34001:   nsresult rv = GetColumnCount(&colCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
34001:   if (aColumn < 0 || aColumn >= colCount)
34001:     return NS_ERROR_INVALID_ARG;
34001: 
34001:   PRInt32 rowCount = 0;
34001:   rv = GetRowCount(&rowCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
34001: 
34001:   for (PRInt32 rowIdx = 0; rowIdx < rowCount; rowIdx++) {
79445:     bool isSelected = false;
34001:     rv = IsCellSelected(rowIdx, aColumn, &isSelected);
34001:     if (NS_SUCCEEDED(rv)) {
34001:       *aIsSelected = isSelected;
34001:       if (!isSelected)
    1:         break;
    1:     }
    1:   }
    1: 
34001:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsHTMLTableAccessible::IsRowSelected(PRInt32 aRow, bool *aIsSelected)
    1: {
34001:   NS_ENSURE_ARG_POINTER(aIsSelected);
80486:   *aIsSelected = false;
    1: 
34001:   PRInt32 rowCount = 0;
34001:   nsresult rv = GetRowCount(&rowCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
34001:   if (aRow < 0 || aRow >= rowCount)
34001:     return NS_ERROR_INVALID_ARG;
34001: 
34001:   PRInt32 colCount = 0;
34001:   rv = GetColumnCount(&colCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
34001: 
34001:   for (PRInt32 colIdx = 0; colIdx < colCount; colIdx++) {
79445:     bool isSelected = false;
34001:     rv = IsCellSelected(aRow, colIdx, &isSelected);
34001:     if (NS_SUCCEEDED(rv)) {
34001:       *aIsSelected = isSelected;
34001:       if (!isSelected)
    1:         break;
    1:     }
    1:   }
    1: 
34001:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLTableAccessible::IsCellSelected(PRInt32 aRow, PRInt32 aColumn,
79445:                                       bool *aIsSelected)
    1: {
12645:   NS_ENSURE_ARG_POINTER(aIsSelected);
80486:   *aIsSelected = false;
 9759: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
    1: 
    1:   nsCOMPtr<nsIDOMElement> domElement;
    1:   PRInt32 startRowIndex = 0, startColIndex = 0,
    1:           rowSpan, colSpan, actualRowSpan, actualColSpan;
    1: 
32381:   nsresult rv = tableLayout->
32381:     GetCellDataAt(aRow, aColumn, *getter_AddRefs(domElement),
32381:                   startRowIndex, startColIndex, rowSpan, colSpan,
12645:                   actualRowSpan, actualColSpan, *aIsSelected);
12645: 
12645:   if (rv == NS_TABLELAYOUT_CELL_NOT_FOUND)
12645:     return NS_ERROR_INVALID_ARG;
12645:   return rv;
    1: }
    1: 
 1370: NS_IMETHODIMP
 1370: nsHTMLTableAccessible::SelectRow(PRInt32 aRow)
 1370: {
32354:   if (IsDefunct())
32354:     return NS_ERROR_FAILURE;
32354: 
32354:   nsresult rv =
32354:     RemoveRowsOrColumnsFromSelection(aRow,
32354:                                      nsISelectionPrivate::TABLESELECTION_ROW,
80486:                                      true);
32354:   NS_ENSURE_SUCCESS(rv, rv);
32354: 
32354:   return AddRowOrColumnToSelection(aRow,
32354:                                    nsISelectionPrivate::TABLESELECTION_ROW);
 1370: }
 1370: 
 1370: NS_IMETHODIMP
 1370: nsHTMLTableAccessible::SelectColumn(PRInt32 aColumn)
 1370: {
32354:   if (IsDefunct())
32354:     return NS_ERROR_FAILURE;
32354: 
32354:   nsresult rv =
32354:     RemoveRowsOrColumnsFromSelection(aColumn,
32354:                                      nsISelectionPrivate::TABLESELECTION_COLUMN,
80486:                                      true);
32354:   NS_ENSURE_SUCCESS(rv, rv);
32354: 
32354:   return AddRowOrColumnToSelection(aColumn,
32354:                                    nsISelectionPrivate::TABLESELECTION_COLUMN);
 1370: }
 1370: 
97028: void
97028: nsHTMLTableAccessible::UnselectRow(PRUint32 aRowIdx)
 1370: {
97028:   RemoveRowsOrColumnsFromSelection(aRowIdx,
32354:                                    nsISelectionPrivate::TABLESELECTION_ROW,
80486:                                    false);
 1370: }
 1370: 
97028: void
97028: nsHTMLTableAccessible::UnselectCol(PRUint32 aColIdx)
 1370: {
97028:   RemoveRowsOrColumnsFromSelection(aColIdx,
32354:                                    nsISelectionPrivate::TABLESELECTION_COLUMN,
80486:                                    false);
 1370: }
 1370: 
 1370: nsresult
32354: nsHTMLTableAccessible::AddRowOrColumnToSelection(PRInt32 aIndex,
32354:                                                  PRUint32 aTarget)
 1370: {
79445:   bool doSelectRow = (aTarget == nsISelectionPrivate::TABLESELECTION_ROW);
 1370: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
 1370: 
32354:   nsCOMPtr<nsIDOMElement> cellElm;
32354:   PRInt32 startRowIdx, startColIdx, rowSpan, colSpan,
32354:     actualRowSpan, actualColSpan;
79445:   bool isSelected = false;
 1370: 
32381:   nsresult rv = NS_OK;
 1370:   PRInt32 count = 0;
32354:   if (doSelectRow)
32381:     rv = GetColumnCount(&count);
32354:   else
32381:     rv = GetRowCount(&count);
32354: 
 1370:   NS_ENSURE_SUCCESS(rv, rv);
 1370: 
89799:   nsIPresShell* presShell(mDoc->PresShell());
32354:   nsRefPtr<nsFrameSelection> tableSelection =
32354:     const_cast<nsFrameSelection*>(presShell->ConstFrameSelection());
 1370: 
32354:   for (PRInt32 idx = 0; idx < count; idx++) {
32354:     PRInt32 rowIdx = doSelectRow ? aIndex : idx;
32354:     PRInt32 colIdx = doSelectRow ? idx : aIndex;
32354:     rv = tableLayout->GetCellDataAt(rowIdx, colIdx,
32354:                                     *getter_AddRefs(cellElm),
32354:                                     startRowIdx, startColIdx,
32354:                                     rowSpan, colSpan,
32354:                                     actualRowSpan, actualColSpan,
32354:                                     isSelected);      
32354: 
32354:     if (NS_SUCCEEDED(rv) && !isSelected) {
32354:       nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElm));
32354:       rv = tableSelection->SelectCellElement(cellContent);
 1370:       NS_ENSURE_SUCCESS(rv, rv);
32354:     }
 1370:   }
 1382: 
 1382:   return NS_OK;
 1370: }
 1370: 
 1370: nsresult
32354: nsHTMLTableAccessible::RemoveRowsOrColumnsFromSelection(PRInt32 aIndex,
32354:                                                         PRUint32 aTarget,
79445:                                                         bool aIsOuter)
 1370: {
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
 1370: 
89799:   nsIPresShell* presShell(mDoc->PresShell());
32354:   nsRefPtr<nsFrameSelection> tableSelection =
32354:     const_cast<nsFrameSelection*>(presShell->ConstFrameSelection());
 1370: 
79445:   bool doUnselectRow = (aTarget == nsISelectionPrivate::TABLESELECTION_ROW);
32354:   PRInt32 count = 0;
72479:   nsresult rv = doUnselectRow ? GetColumnCount(&count) : GetRowCount(&count);
72479:   NS_ENSURE_SUCCESS(rv, rv);
32354: 
32354:   PRInt32 startRowIdx = doUnselectRow ? aIndex : 0;
32354:   PRInt32 endRowIdx = doUnselectRow ? aIndex : count - 1;
32354:   PRInt32 startColIdx = doUnselectRow ? 0 : aIndex;
32354:   PRInt32 endColIdx = doUnselectRow ? count - 1 : aIndex;
32354: 
32354:   if (aIsOuter)
43504:     return tableSelection->RestrictCellsToSelection(mContent,
32354:                                                     startRowIdx, startColIdx, 
32354:                                                     endRowIdx, endColIdx);
32354: 
43504:   return tableSelection->RemoveCellsFromSelection(mContent,
32354:                                                   startRowIdx, startColIdx, 
32354:                                                   endRowIdx, endColIdx);
 1370: }
 1370: 
32381: nsITableLayout*
32381: nsHTMLTableAccessible::GetTableLayout()
    1: {
43504:   nsIFrame *frame = mContent->GetPrimaryFrame();
23554:   if (!frame)
32381:     return nsnull;
23554: 
32381:   nsITableLayout *tableLayout = do_QueryFrame(frame);
32381:   return tableLayout;
    1: }
    1: 
    1: nsresult
    1: nsHTMLTableAccessible::GetCellAt(PRInt32        aRowIndex,
    1:                                  PRInt32        aColIndex,
    1:                                  nsIDOMElement* &aCell)
    1: {
    1:   PRInt32 startRowIndex = 0, startColIndex = 0,
    1:           rowSpan, colSpan, actualRowSpan, actualColSpan;
79445:   bool isSelected;
    1: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
    1: 
32381:   nsresult rv = tableLayout->
32381:     GetCellDataAt(aRowIndex, aColIndex, aCell, startRowIndex, startColIndex,
32381:                   rowSpan, colSpan, actualRowSpan, actualColSpan, isSelected);
12645: 
12645:   if (rv == NS_TABLELAYOUT_CELL_NOT_FOUND)
12645:     return NS_ERROR_INVALID_ARG;
12645:   return rv;
    1: }
    1: 
69342: void
69342: nsHTMLTableAccessible::Description(nsString& aDescription)
    1: {
    1:   // Helpful for debugging layout vs. data tables
    1:   aDescription.Truncate();
69342:   nsAccessible::Description(aDescription);
69342:   if (!aDescription.IsEmpty())
69342:     return;
 3151: 
72333:   // Use summary as description if it weren't used as a name.
72333:   // XXX: get rid code duplication with NameInternal().
72333:   nsAccessible* caption = Caption();
72333:   if (caption) {
72333:     nsIContent* captionContent = caption->GetContent();
72333:     if (captionContent) {
72333:       nsAutoString captionText;
69342:       nsTextEquivUtils::AppendTextEquivFromContent(this, captionContent,
72333:                                                    &captionText);
72333: 
72333:       if (!captionText.IsEmpty()) { // summary isn't used as a name.
78350:         mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::summary,
72333:                           aDescription);
 3151:       }
72333:     }
72333:   }
72333: 
 3151: #ifdef SHOW_LAYOUT_HEURISTIC
 3151:   if (aDescription.IsEmpty()) {
94235:     bool isProbablyForLayout = IsProbablyLayoutTable();
    1:     aDescription = mLayoutHeuristic;
 3151:   }
    1:   printf("\nTABLE: %s\n", NS_ConvertUTF16toUTF8(mLayoutHeuristic).get());
    1: #endif
    1: }
    1: 
79445: bool
30060: nsHTMLTableAccessible::HasDescendant(const nsAString& aTagName,
79445:                                      bool aAllowEmpty)
    1: {
43504:   nsCOMPtr<nsIDOMElement> tableElt(do_QueryInterface(mContent));
80486:   NS_ENSURE_TRUE(tableElt, false);
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
30060:   tableElt->GetElementsByTagName(aTagName, getter_AddRefs(nodeList));
80486:   NS_ENSURE_TRUE(nodeList, false);
    1: 
  438:   nsCOMPtr<nsIDOMNode> foundItem;
  438:   nodeList->Item(0, getter_AddRefs(foundItem));
30060:   if (!foundItem)
80486:     return false;
30060: 
30060:   if (aAllowEmpty)
80486:     return true;
30060: 
30060:   // Make sure that the item we found has contents and either has multiple
30060:   // children or the found item is not a whitespace-only text node.
  438:   nsCOMPtr<nsIContent> foundItemContent = do_QueryInterface(foundItem);
30060:   if (foundItemContent->GetChildCount() > 1)
80486:     return true; // Treat multiple child nodes as non-empty
30060: 
88030:   nsIContent *innerItemContent = foundItemContent->GetFirstChild();
30060:   if (innerItemContent && !innerItemContent->TextIsOnlyWhitespace())
80486:     return true;
    1: 
30060:   // If we found more than one node then return true not depending on
30060:   // aAllowEmpty flag.
30060:   // XXX it might be dummy but bug 501375 where we changed this addresses
30060:   // performance problems only. Note, currently 'aAllowEmpty' flag is used for
30060:   // caption element only. On another hand we create accessible object for
30060:   // the first entry of caption element (see
30060:   // nsHTMLTableAccessible::CacheChildren).
30060:   nodeList->Item(1, getter_AddRefs(foundItem));
30060:   return !!foundItem;
    1: }
    1: 
94235: bool
94235: nsHTMLTableAccessible::IsProbablyLayoutTable()
    1: {
    1:   // Implement a heuristic to determine if table is most likely used for layout
    1:   // XXX do we want to look for rowspan or colspan, especialy that span all but a couple cells
    1:   // at the beginning or end of a row/col, and especially when they occur at the edge of a table?
    1:   // XXX expose this info via object attributes to AT-SPI
    1: 
    1:   // XXX For now debugging descriptions are always on via SHOW_LAYOUT_HEURISTIC
    1:   // This will allow release trunk builds to be used by testers to refine the algorithm
    1:   // Change to |#define SHOW_LAYOUT_HEURISTIC DEBUG| before final release
    1: #ifdef SHOW_LAYOUT_HEURISTIC
    1: #define RETURN_LAYOUT_ANSWER(isLayout, heuristic) \
94235:   { \
94235:     mLayoutHeuristic = isLayout ? \
94235:       NS_LITERAL_STRING("layout table: " heuristic) : \
94235:       NS_LITERAL_STRING("data table: " heuristic); \
94235:     return isLayout; \
94235:   }
    1: #else
94235: #define RETURN_LAYOUT_ANSWER(isLayout, heuristic) { return isLayout; }
    1: #endif
    1: 
89800:   nsDocAccessible* docAccessible = Document();
  512:   if (docAccessible) {
67790:     PRUint64 docState = docAccessible->State();
67790:     if (docState & states::EDITABLE) {  // Need to see all elements while document is being edited
79590:       RETURN_LAYOUT_ANSWER(false, "In editable document");
  512:     }
  512:   }
  512: 
29980:   // Check to see if an ARIA role overrides the role from native markup,
29980:   // but for which we still expose table semantics (treegrid, for example).
87094:   if (Role() != roles::TABLE) 
79590:     RETURN_LAYOUT_ANSWER(false, "Has role attribute");
    1: 
78350:   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::role)) {
29980:     // Role attribute is present, but overridden roles have already been dealt with.
29980:     // Only landmarks and other roles that don't override the role from native
29980:     // markup are left to deal with here.
79590:     RETURN_LAYOUT_ANSWER(false, "Has role attribute, weak role, and role is table");
    1:   }
    1: 
82942:   if (mContent->Tag() != nsGkAtoms::table)
82942:     RETURN_LAYOUT_ANSWER(true, "table built by CSS display:table style");
82942: 
80571:   // Check if datatable attribute has "0" value.
80571:   if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::datatable,
80571:                             NS_LITERAL_STRING("0"), eCaseMatters)) {
80571:     RETURN_LAYOUT_ANSWER(true, "Has datatable = 0 attribute, it's for layout");
80571:   }
80571: 
79590:   // Check for legitimate data table attributes.
  438:   nsAutoString summary;
79590:   if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::summary, summary) &&
79590:       !summary.IsEmpty())
79590:     RETURN_LAYOUT_ANSWER(false, "Has summary -- legitimate table structures");
79590: 
79590:   // Check for legitimate data table elements.
79590:   nsAccessible* caption = FirstChild();
87094:   if (caption && caption->Role() == roles::CAPTION && caption->HasChildren()) 
87094:     RETURN_LAYOUT_ANSWER(false, "Not empty caption -- legitimate table structures");
79590: 
79595:   for (nsIContent* childElm = mContent->GetFirstChild(); childElm;
79595:        childElm = childElm->GetNextSibling()) {
79590:     if (!childElm->IsHTML())
79590:       continue;
79590: 
79590:     if (childElm->Tag() == nsGkAtoms::col ||
79590:         childElm->Tag() == nsGkAtoms::colgroup ||
79590:         childElm->Tag() == nsGkAtoms::tfoot ||
79590:         childElm->Tag() == nsGkAtoms::thead) {
79590:       RETURN_LAYOUT_ANSWER(false,
79590:                            "Has col, colgroup, tfoot or thead -- legitimate table structures");
79590:     }
79590: 
79590:     if (childElm->Tag() == nsGkAtoms::tbody) {
79595:       for (nsIContent* rowElm = childElm->GetFirstChild(); rowElm;
79595:            rowElm = rowElm->GetNextSibling()) {
79590:         if (rowElm->IsHTML() && rowElm->Tag() == nsGkAtoms::tr) {
79595:           for (nsIContent* cellElm = rowElm->GetFirstChild(); cellElm;
79595:                cellElm = cellElm->GetNextSibling()) {
92109:             if (cellElm->IsHTML()) {
92109:               
92109:               if (cellElm->NodeInfo()->Equals(nsGkAtoms::th)) {
79590:                 RETURN_LAYOUT_ANSWER(false,
79590:                                      "Has th -- legitimate table structures");
79590:               }
92109: 
92109:               if (cellElm->HasAttr(kNameSpaceID_None, nsGkAtoms::headers) ||
92109:                   cellElm->HasAttr(kNameSpaceID_None, nsGkAtoms::scope) ||
92109:                   cellElm->HasAttr(kNameSpaceID_None, nsGkAtoms::abbr)) {
92109:                 RETURN_LAYOUT_ANSWER(false,
92109:                                      "Has headers, scope, or abbr attribute -- legitimate table structures");
92109:               }
92109: 
92109:               nsAccessible* cell = mDoc->GetAccessible(cellElm);
92109:               if (cell && cell->GetChildCount() == 1 &&
92109:                   cell->FirstChild()->IsAbbreviation()) {
92109:                 RETURN_LAYOUT_ANSWER(false,
92109:                                      "has abbr -- legitimate table structures");
92109:               }
92109:             }
79590:           }
79590:         }
79590:       }
79590:     }
79590:   }
79590: 
30060:   if (HasDescendant(NS_LITERAL_STRING("table"))) {
79590:     RETURN_LAYOUT_ANSWER(true, "Has a nested table within it");
    1:   }
    1: 
    1:   // If only 1 column or only 1 row, it's for layout
    1:   PRInt32 columns, rows;
32381:   GetColumnCount(&columns);
    1:   if (columns <=1) {
79590:     RETURN_LAYOUT_ANSWER(true, "Has only 1 column");
    1:   }
32381:   GetRowCount(&rows);
    1:   if (rows <=1) {
79590:     RETURN_LAYOUT_ANSWER(true, "Has only 1 row");
    1:   }
    1: 
    1:   // Check for many columns
    1:   if (columns >= 5) {
79590:     RETURN_LAYOUT_ANSWER(false, ">=5 columns");
    1:   }
    1: 
    1:   // Now we know there are 2-4 columns and 2 or more rows
    1:   // Check to see if there are visible borders on the cells
    1:   // XXX currently, we just check the first cell -- do we really need to do more?
    1:   nsCOMPtr<nsIDOMElement> cellElement;
12645:   nsresult rv = GetCellAt(0, 0, *getter_AddRefs(cellElement));
12645:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
12645: 
    1:   nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElement));
    1:   NS_ENSURE_TRUE(cellContent, NS_ERROR_FAILURE);
36654:   nsIFrame *cellFrame = cellContent->GetPrimaryFrame();
 1560:   if (!cellFrame) {
 1560:     return NS_OK;
 1560:   }
    1:   nsMargin border;
    1:   cellFrame->GetBorder(border);
    1:   if (border.top && border.bottom && border.left && border.right) {
79590:     RETURN_LAYOUT_ANSWER(false, "Has nonzero border-width on table cell");
    1:   }
    1: 
    1:   /**
    1:    * Rules for non-bordered tables with 2-4 columns and 2+ rows from here on forward
    1:    */
    1: 
90355:   // Check for styled background color across rows (alternating background
90355:   // color is a common feature for data tables).
90355:   PRUint32 childCount = GetChildCount();
91487:   nscolor rowColor, prevRowColor;
90355:   for (PRUint32 childIdx = 0; childIdx < childCount; childIdx++) {
90355:     nsAccessible* child = GetChildAt(childIdx);
90355:     if (child->Role() == roles::ROW) {
90355:       prevRowColor = rowColor;
91487:       nsIFrame* rowFrame = child->GetFrame();
91487:       rowColor = rowFrame->GetStyleBackground()->mBackgroundColor;
91487: 
91487:       if (childIdx > 0 && prevRowColor != rowColor)
79590:         RETURN_LAYOUT_ANSWER(false, "2 styles of row background color, non-bordered");
    1:     }
    1:   }
    1: 
    1:   // Check for many rows
    1:   const PRInt32 kMaxLayoutRows = 20;
    1:   if (rows > kMaxLayoutRows) { // A ton of rows, this is probably for data
79590:     RETURN_LAYOUT_ANSWER(false, ">= kMaxLayoutRows (20) and non-bordered");
    1:   }
    1: 
90430:   // Check for very wide table.
90430:   nsIFrame* documentFrame = Document()->GetFrame();
90430:   nsSize documentSize = documentFrame->GetSize();
90430:   if (documentSize.width > 0) {
90430:     nsSize tableSize = GetFrame()->GetSize();
90430:     PRInt32 percentageOfDocWidth = (100 * tableSize.width) / documentSize.width;
    1:     if (percentageOfDocWidth > 95) {
    1:       // 3-4 columns, no borders, not a lot of rows, and 95% of the doc's width
    1:       // Probably for layout
90430:       RETURN_LAYOUT_ANSWER(true,
90430:                            "<= 4 columns, table width is 95% of document width");
    1:     }
15310:   }
    1: 
    1:   // Two column rules
    1:   if (rows * columns <= 10) {
79590:     RETURN_LAYOUT_ANSWER(true, "2-4 columns, 10 cells or less, non-bordered");
    1:   }
    1: 
30060:   if (HasDescendant(NS_LITERAL_STRING("embed")) ||
30060:       HasDescendant(NS_LITERAL_STRING("object")) ||
30060:       HasDescendant(NS_LITERAL_STRING("applet")) ||
30060:       HasDescendant(NS_LITERAL_STRING("iframe"))) {
79590:     RETURN_LAYOUT_ANSWER(true, "Has no borders, and has iframe, object, applet or iframe, typical of advertisements");
    1:   }
    1: 
79590:   RETURN_LAYOUT_ANSWER(false, "no layout factor strong enough, so will guess data");
    1: }
    1: 
    1: 
25822: ////////////////////////////////////////////////////////////////////////////////
25822: // nsHTMLCaptionAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
25822: 
75194: Relation
75194: nsHTMLCaptionAccessible::RelationByType(PRUint32 aType)
 3151: {
75194:   Relation rel = nsHyperTextAccessible::RelationByType(aType);
75194:   if (aType == nsIAccessibleRelation::RELATION_LABEL_FOR)
75194:     rel.AppendTarget(Parent());
 3151: 
75194:   return rel;
 3151: }
 3151: 
87094: role
52027: nsHTMLCaptionAccessible::NativeRole()
25822: {
87094:   return roles::CAPTION;
25822: }
