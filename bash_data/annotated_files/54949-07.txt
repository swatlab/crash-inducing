    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@netscape.com>
30324:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "imgLoader.h"
50546: #include "imgRequestProxy.h"
50546: 
50551: #include "RasterImage.h"
50546: /* We end up pulling in windows.h because we eventually hit gfxWindowsSurface;
50546:  * windows.h defines LoadImage, so we have to #undef it or imgLoader::LoadImage
50546:  * gets changed.
50546:  * This #undef needs to be in multiple places because we don't always pull
50546:  * headers in in the same order.
50546:  */
50546: #undef LoadImage
    1: 
    1: #include "nsCOMPtr.h"
    1: 
    1: #include "nsNetUtil.h"
    1: #include "nsIHttpChannel.h"
    1: #include "nsICachingChannel.h"
30795: #include "nsIInterfaceRequestor.h"
30324: #include "nsIPrefBranch2.h"
18827: #include "nsIPrefService.h"
30795: #include "nsIProgressEventSink.h"
31432: #include "nsIChannelEventSink.h"
48889: #include "nsIAsyncVerifyRedirectCallback.h"
    1: #include "nsIProxyObjectManager.h"
    1: #include "nsIServiceManager.h"
18827: #include "nsIFileURL.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsCRT.h"
    1: 
    1: #include "netCore.h"
    1: 
25034: #include "nsURILoader.h"
    1: #include "ImageLogging.h"
    1: 
    1: #include "nsIComponentRegistrar.h"
    1: 
23324: #include "nsIApplicationCache.h"
23324: #include "nsIApplicationCacheContainer.h"
23324: 
42553: #include "nsIMemoryReporter.h"
47315: #include "nsIPrivateBrowsingService.h"
42553: 
    1: // we want to explore making the document own the load group
    1: // so we can associate the document URI with the load group.
    1: // until this point, we have an evil hack:
    1: #include "nsIHttpChannelInternal.h"  
42509: #include "nsIContentSecurityPolicy.h"
42509: #include "nsIChannelPolicy.h"
    1: 
42480: #include "mozilla/FunctionTimer.h"
42480: 
50549: using namespace mozilla::imagelib;
50549: 
    1: #if defined(DEBUG_pavlov) || defined(DEBUG_timeless)
    1: #include "nsISimpleEnumerator.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsComponentManagerUtils.h"
    1: 
50549: 
    1: static void PrintImageDecoders()
    1: {
    1:   nsCOMPtr<nsIComponentRegistrar> compMgr;
    1:   if (NS_FAILED(NS_GetComponentRegistrar(getter_AddRefs(compMgr))) || !compMgr)
    1:     return;
    1:   nsCOMPtr<nsISimpleEnumerator> enumer;
    1:   if (NS_FAILED(compMgr->EnumerateContractIDs(getter_AddRefs(enumer))) || !enumer)
    1:     return;
    1:   
    1:   nsCString str;
    1:   nsCOMPtr<nsISupports> s;
    1:   PRBool more = PR_FALSE;
    1:   while (NS_SUCCEEDED(enumer->HasMoreElements(&more)) && more) {
    1:     enumer->GetNext(getter_AddRefs(s));
    1:     if (s) {
    1:       nsCOMPtr<nsISupportsCString> ss(do_QueryInterface(s));
    1: 
    1:       nsCAutoString xcs;
    1:       ss->GetData(xcs);
    1: 
32424:       NS_NAMED_LITERAL_CSTRING(decoderContract, "@mozilla.org/image/decoder;3?type=");
    1: 
    1:       if (StringBeginsWith(xcs, decoderContract)) {
    1:         printf("Have decoder for mime type: %s\n", xcs.get()+decoderContract.Length());
    1:       }
    1:     }
    1:   }
    1: }
    1: #endif
    1: 
42553: 
42553: class imgMemoryReporter :
42553:   public nsIMemoryReporter
42553: {
42553: public:
42553:   enum ReporterType {
42553:     CHROME_BIT = PR_BIT(0),
42553:     USED_BIT   = PR_BIT(1),
42553:     RAW_BIT    = PR_BIT(2),
42553: 
42553:     ChromeUsedRaw             = CHROME_BIT | USED_BIT | RAW_BIT,
42553:     ChromeUsedUncompressed    = CHROME_BIT | USED_BIT,
42553:     ChromeUnusedRaw           = CHROME_BIT | RAW_BIT,
42553:     ChromeUnusedUncompressed  = CHROME_BIT,
42553:     ContentUsedRaw            = USED_BIT | RAW_BIT,
42553:     ContentUsedUncompressed   = USED_BIT,
42553:     ContentUnusedRaw          = RAW_BIT,
42553:     ContentUnusedUncompressed = 0
42553:   };
42553: 
42553:   imgMemoryReporter(ReporterType aType)
42553:     : mType(aType)
42553:   { }
42553: 
42553:   NS_DECL_ISUPPORTS
42553: 
42553:   NS_IMETHOD GetPath(char **memoryPath)
42553:   {
42553:     if (mType == ChromeUsedRaw) {
42553:       *memoryPath = strdup("images/chrome/used/raw");
42553:     } else if (mType == ChromeUsedUncompressed) {
42553:       *memoryPath = strdup("images/chrome/used/uncompressed");
42553:     } else if (mType == ChromeUnusedRaw) {
42553:       *memoryPath = strdup("images/chrome/unused/raw");
42553:     } else if (mType == ChromeUnusedUncompressed) {
42553:       *memoryPath = strdup("images/chrome/unused/uncompressed");
42553:     } else if (mType == ContentUsedRaw) {
42553:       *memoryPath = strdup("images/content/used/raw");
42553:     } else if (mType == ContentUsedUncompressed) {
42553:       *memoryPath = strdup("images/content/used/uncompressed");
42553:     } else if (mType == ContentUnusedRaw) {
42553:       *memoryPath = strdup("images/content/unused/raw");
42553:     } else if (mType == ContentUnusedUncompressed) {
42553:       *memoryPath = strdup("images/content/unused/uncompressed");
42553:     }
42553:     return NS_OK;
42553:   }
42553: 
42553:   NS_IMETHOD GetDescription(char **desc)
42553:   {
42553:     if (mType == ChromeUsedRaw) {
42553:       *desc = strdup("Memory used by in-use chrome images, compressed data");
42553:     } else if (mType == ChromeUsedUncompressed) {
42553:       *desc = strdup("Memory used by in-use chrome images, uncompressed data");
42553:     } else if (mType == ChromeUnusedRaw) {
42553:       *desc = strdup("Memory used by not in-use chrome images, compressed data");
42553:     } else if (mType == ChromeUnusedUncompressed) {
42553:       *desc = strdup("Memory used by not in-use chrome images, uncompressed data");
42553:     } else if (mType == ContentUsedRaw) {
42553:       *desc = strdup("Memory used by in-use content images, compressed data");
42553:     } else if (mType == ContentUsedUncompressed) {
42553:       *desc = strdup("Memory used by in-use content images, uncompressed data");
42553:     } else if (mType == ContentUnusedRaw) {
42553:       *desc = strdup("Memory used by not in-use content images, compressed data");
42553:     } else if (mType == ContentUnusedUncompressed) {
42553:       *desc = strdup("Memory used by not in-use content images, uncompressed data");
42553:     }
42553:     return NS_OK;
42553:   }
42553: 
42553:   struct EnumArg {
42553:     EnumArg(ReporterType aType)
42553:       : rtype(aType), value(0)
42553:     { }
42553: 
42553:     ReporterType rtype;
42553:     PRInt32 value;
42553:   };
42553: 
42553:   static PLDHashOperator EnumEntries(const nsACString&,
42553:                                      imgCacheEntry *entry,
42553:                                      void *userArg)
42553:   {
42553:     EnumArg *arg = static_cast<EnumArg*>(userArg);
42553:     ReporterType rtype = arg->rtype;
42553: 
42553:     if (rtype & USED_BIT) {
42553:       if (entry->HasNoProxies())
42553:         return PL_DHASH_NEXT;
42553:     } else {
42553:       if (!entry->HasNoProxies())
42553:         return PL_DHASH_NEXT;
42553:     }
42553: 
42553:     nsRefPtr<imgRequest> req = entry->GetRequest();
54949:     Image *image = static_cast<Image*>(req->mImage.get());
50549:     if (!image)
42553:       return PL_DHASH_NEXT;
42553: 
42553:     if (rtype & RAW_BIT) {
50549:       arg->value += image->GetSourceDataSize();
42553:     } else {
50549:       arg->value += image->GetDecodedDataSize();
42553:     }
42553: 
42553:     return PL_DHASH_NEXT;
42553:   }
42553: 
42553:   NS_IMETHOD GetMemoryUsed(PRInt64 *memoryUsed)
42553:   {
42553:     EnumArg arg(mType);
42553:     if (mType & CHROME_BIT) {
42553:       imgLoader::sChromeCache.EnumerateRead(EnumEntries, &arg);
42553:     } else {
42553:       imgLoader::sCache.EnumerateRead(EnumEntries, &arg);
42553:     }
42553: 
42553:     *memoryUsed = arg.value;
42553:     return NS_OK;
42553:   }
42553: 
42553:   ReporterType mType;
42553: };
42553: 
42553: NS_IMPL_ISUPPORTS1(imgMemoryReporter, nsIMemoryReporter)
42553: 
42553: 
30795: /**
30795:  * A class that implements nsIProgressEventSink and forwards all calls to it to
30795:  * the original notification callbacks of the channel. Also implements
30795:  * nsIInterfaceRequestor and gives out itself for nsIProgressEventSink calls,
30795:  * and forwards everything else to the channel's notification callbacks.
30795:  */
30795: class nsProgressNotificationProxy : public nsIProgressEventSink
31432:                                   , public nsIChannelEventSink
30795:                                   , public nsIInterfaceRequestor
30795: {
30795:   public:
30795:     nsProgressNotificationProxy(nsIChannel* channel,
30795:                                 imgIRequest* proxy)
30795:         : mChannel(channel), mImageRequest(proxy) {
30795:       channel->GetNotificationCallbacks(getter_AddRefs(mOriginalCallbacks));
30795:     }
30795: 
30795:     NS_DECL_ISUPPORTS
30795:     NS_DECL_NSIPROGRESSEVENTSINK
31432:     NS_DECL_NSICHANNELEVENTSINK
30795:     NS_DECL_NSIINTERFACEREQUESTOR
30795:   private:
30795:     ~nsProgressNotificationProxy() {}
30795: 
30795:     nsCOMPtr<nsIChannel> mChannel;
30795:     nsCOMPtr<nsIInterfaceRequestor> mOriginalCallbacks;
30795:     nsCOMPtr<nsIRequest> mImageRequest;
30795: };
30795: 
31432: NS_IMPL_ISUPPORTS3(nsProgressNotificationProxy,
30795:                      nsIProgressEventSink,
31432:                      nsIChannelEventSink,
30795:                      nsIInterfaceRequestor)
30795: 
30795: NS_IMETHODIMP
30795: nsProgressNotificationProxy::OnProgress(nsIRequest* request,
30795:                                         nsISupports* ctxt,
30795:                                         PRUint64 progress,
30795:                                         PRUint64 progressMax) {
30795:   nsCOMPtr<nsILoadGroup> loadGroup;
30795:   mChannel->GetLoadGroup(getter_AddRefs(loadGroup));
30795: 
30795:   nsCOMPtr<nsIProgressEventSink> target;
30795:   NS_QueryNotificationCallbacks(mOriginalCallbacks,
30795:                                 loadGroup,
30795:                                 NS_GET_IID(nsIProgressEventSink),
30795:                                 getter_AddRefs(target));
30795:   if (!target)
30795:     return NS_OK;
30795:   return target->OnProgress(mImageRequest, ctxt, progress, progressMax);
30795: }
30795: 
30795: NS_IMETHODIMP
30795: nsProgressNotificationProxy::OnStatus(nsIRequest* request,
30795:                                       nsISupports* ctxt,
30795:                                       nsresult status,
30795:                                       const PRUnichar* statusArg) {
30795:   nsCOMPtr<nsILoadGroup> loadGroup;
30795:   mChannel->GetLoadGroup(getter_AddRefs(loadGroup));
30795: 
30795:   nsCOMPtr<nsIProgressEventSink> target;
30795:   NS_QueryNotificationCallbacks(mOriginalCallbacks,
30795:                                 loadGroup,
30795:                                 NS_GET_IID(nsIProgressEventSink),
30795:                                 getter_AddRefs(target));
30795:   if (!target)
30795:     return NS_OK;
30795:   return target->OnStatus(mImageRequest, ctxt, status, statusArg);
30795: }
30795: 
30795: NS_IMETHODIMP
48889: nsProgressNotificationProxy::AsyncOnChannelRedirect(nsIChannel *oldChannel,
31432:                                                     nsIChannel *newChannel,
48889:                                                     PRUint32 flags,
48889:                                                     nsIAsyncVerifyRedirectCallback *cb) {
31432:   // The 'old' channel should match the current one
31432:   NS_ABORT_IF_FALSE(oldChannel == mChannel,
31432:                     "old channel doesn't match current!");
31432: 
31432:   // Save the new channel
31432:   mChannel = newChannel;
31432: 
31432:   // Tell the original original callbacks about it too
31432:   nsCOMPtr<nsILoadGroup> loadGroup;
31432:   mChannel->GetLoadGroup(getter_AddRefs(loadGroup));
31432:   nsCOMPtr<nsIChannelEventSink> target;
31432:   NS_QueryNotificationCallbacks(mOriginalCallbacks,
31432:                                 loadGroup,
31432:                                 NS_GET_IID(nsIChannelEventSink),
31432:                                 getter_AddRefs(target));
48889:   if (!target) {
48889:       cb->OnRedirectVerifyCallback(NS_OK);
31432:       return NS_OK;
48889:   }
48889: 
48889:   // Delegate to |target| if set, reusing |cb|
48889:   return target->AsyncOnChannelRedirect(oldChannel, newChannel, flags, cb);
31432: }
31432: 
31432: NS_IMETHODIMP
30795: nsProgressNotificationProxy::GetInterface(const nsIID& iid,
30795:                                           void** result) {
30795:   if (iid.Equals(NS_GET_IID(nsIProgressEventSink))) {
30795:     *result = static_cast<nsIProgressEventSink*>(this);
30797:     NS_ADDREF_THIS();
30795:     return NS_OK;
30795:   }
31432:   if (iid.Equals(NS_GET_IID(nsIChannelEventSink))) {
31432:     *result = static_cast<nsIChannelEventSink*>(this);
31432:     NS_ADDREF_THIS();
31432:     return NS_OK;
31432:   }
30795:   if (mOriginalCallbacks)
30795:     return mOriginalCallbacks->GetInterface(iid, result);
30795:   return NS_NOINTERFACE;
30795: }
30795: 
18827: static PRBool NewRequestAndEntry(nsIURI *uri, imgRequest **request, imgCacheEntry **entry)
18827: {
18827:   // If file, force revalidation on expiration
18827:   PRBool isFile;
18827:   uri->SchemeIs("file", &isFile);
18801: 
18827:   *request = new imgRequest();
18827:   if (!*request)
18827:     return PR_FALSE;
18827: 
18827:   *entry = new imgCacheEntry(*request, /* mustValidateIfExpired = */ isFile);
18827:   if (!*entry) {
18827:     delete *request;
18827:     return PR_FALSE;
    1:   }
    1: 
18827:   NS_ADDREF(*request);
18827:   NS_ADDREF(*entry);
18827: 
18827:   return PR_TRUE;
    1: }
    1: 
18827: static PRBool ShouldRevalidateEntry(imgCacheEntry *aEntry,
    1:                               nsLoadFlags aFlags,
    1:                               PRBool aHasExpired)
    1: {
    1:   PRBool bValidateEntry = PR_FALSE;
    1: 
18827:   if (aFlags & nsIRequest::LOAD_BYPASS_CACHE)
18827:     return PR_FALSE;
    1: 
    1:   if (aFlags & nsIRequest::VALIDATE_ALWAYS) {
    1:     bValidateEntry = PR_TRUE;
    1:   }
    1:   //
    1:   // The cache entry has expired...  Determine whether the stale cache
    1:   // entry can be used without validation...
    1:   //
    1:   else if (aHasExpired) {
    1:     //
    1:     // VALIDATE_NEVER and VALIDATE_ONCE_PER_SESSION allow stale cache
    1:     // entries to be used unless they have been explicitly marked to
    1:     // indicate that revalidation is necessary.
    1:     //
    1:     if (aFlags & (nsIRequest::VALIDATE_NEVER | 
    1:                   nsIRequest::VALIDATE_ONCE_PER_SESSION)) 
    1:     {
18827:       bValidateEntry = aEntry->GetMustValidateIfExpired();
    1:     }
    1:     //
    1:     // LOAD_FROM_CACHE allows a stale cache entry to be used... Otherwise,
    1:     // the entry must be revalidated.
    1:     //
    1:     else if (!(aFlags & nsIRequest::LOAD_FROM_CACHE)) {
    1:       bValidateEntry = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return bValidateEntry;
    1: }
    1: 
    1: static nsresult NewImageChannel(nsIChannel **aResult,
    1:                                 nsIURI *aURI,
    1:                                 nsIURI *aInitialDocumentURI,
    1:                                 nsIURI *aReferringURI,
    1:                                 nsILoadGroup *aLoadGroup,
30324:                                 const nsCString& aAcceptHeader,
42509:                                 nsLoadFlags aLoadFlags,
42509:                                 nsIChannelPolicy *aPolicy)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIChannel> newChannel;
    1:   nsCOMPtr<nsIHttpChannel> newHttpChannel;
    1:  
    1:   nsCOMPtr<nsIInterfaceRequestor> callbacks;
    1: 
    1:   if (aLoadGroup) {
    1:     // Get the notification callbacks from the load group for the new channel.
    1:     //
    1:     // XXX: This is not exactly correct, because the network request could be
    1:     //      referenced by multiple windows...  However, the new channel needs
    1:     //      something.  So, using the 'first' notification callbacks is better
    1:     //      than nothing...
    1:     //
    1:     aLoadGroup->GetNotificationCallbacks(getter_AddRefs(callbacks));
    1:   }
    1: 
    1:   // Pass in a NULL loadgroup because this is the underlying network request.
    1:   // This request may be referenced by several proxy image requests (psossibly
    1:   // in different documents).
    1:   // If all of the proxy requests are canceled then this request should be
    1:   // canceled too.
    1:   //
    1:   rv = NS_NewChannel(aResult,
    1:                      aURI,        // URI 
    1:                      nsnull,      // Cached IOService
    1:                      nsnull,      // LoadGroup
    1:                      callbacks,   // Notification Callbacks
42509:                      aLoadFlags,
42509:                      aPolicy);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // Initialize HTTP-specific attributes
    1:   newHttpChannel = do_QueryInterface(*aResult);
    1:   if (newHttpChannel) {
    1:     newHttpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Accept"),
30324:                                      aAcceptHeader,
    1:                                      PR_FALSE);
    1: 
    1:     nsCOMPtr<nsIHttpChannelInternal> httpChannelInternal = do_QueryInterface(newHttpChannel);
    1:     NS_ENSURE_TRUE(httpChannelInternal, NS_ERROR_UNEXPECTED);
    1:     httpChannelInternal->SetDocumentURI(aInitialDocumentURI);
    1:     newHttpChannel->SetReferrer(aReferringURI);
    1:   }
    1: 
    1:   // Image channels are loaded by default with reduced priority.
    1:   nsCOMPtr<nsISupportsPriority> p = do_QueryInterface(*aResult);
    1:   if (p) {
    1:     PRUint32 priority = nsISupportsPriority::PRIORITY_LOW;
    1: 
    1:     if (aLoadFlags & nsIRequest::LOAD_BACKGROUND)
    1:       ++priority; // further reduce priority for background loads
    1: 
    1:     p->AdjustPriority(priority);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
18827: static PRUint32 SecondsFromPRTime(PRTime prTime)
    1: {
18827:   return PRUint32(PRInt64(prTime) / PRInt64(PR_USEC_PER_SEC));
    1: }
    1: 
18827: imgCacheEntry::imgCacheEntry(imgRequest *request, PRBool mustValidateIfExpired /* = PR_FALSE */)
18827:  : mRequest(request),
18827:    mDataSize(0),
18827:    mTouchedTime(SecondsFromPRTime(PR_Now())),
18827:    mExpiryTime(0),
18827:    mMustValidateIfExpired(mustValidateIfExpired),
25078:    mEvicted(PR_FALSE),
25078:    mHasNoProxies(PR_TRUE)
18827: {}
    1: 
25078: imgCacheEntry::~imgCacheEntry()
25078: {
25078:   LOG_FUNC(gImgLog, "imgCacheEntry::~imgCacheEntry()");
25078: }
25078: 
18827: void imgCacheEntry::Touch(PRBool updateTime /* = PR_TRUE */)
18827: {
18827:   LOG_SCOPE(gImgLog, "imgCacheEntry::Touch");
    1: 
18827:   if (updateTime)
18827:     mTouchedTime = SecondsFromPRTime(PR_Now());
    1: 
32424:   UpdateCache();
32424: }
32424: 
32424: void imgCacheEntry::UpdateCache(PRInt32 diff /* = 0 */)
32424: {
25078:   // Don't update the cache if we've been removed from it or it doesn't care
25078:   // about our size or usage.
25078:   if (!Evicted() && HasNoProxies()) {
18827:     nsCOMPtr<nsIURI> uri;
23036:     mRequest->GetKeyURI(getter_AddRefs(uri));
32424:     imgLoader::CacheEntriesChanged(uri, diff);
18827:   }
    1: }
    1: 
25078: void imgCacheEntry::SetHasNoProxies(PRBool hasNoProxies)
25078: {
25078: #if defined(PR_LOGGING)
25078:   nsCOMPtr<nsIURI> uri;
25078:   mRequest->GetKeyURI(getter_AddRefs(uri));
25078:   nsCAutoString spec;
25078:   if (uri)
25078:     uri->GetSpec(spec);
25078:   if (hasNoProxies)
25078:     LOG_FUNC_WITH_PARAM(gImgLog, "imgCacheEntry::SetHasNoProxies true", "uri", spec.get());
25078:   else
25078:     LOG_FUNC_WITH_PARAM(gImgLog, "imgCacheEntry::SetHasNoProxies false", "uri", spec.get());
25078: #endif
25078: 
25078:   mHasNoProxies = hasNoProxies;
25078: }
25078: 
18827: imgCacheQueue::imgCacheQueue()
18827:  : mDirty(PR_FALSE),
18827:    mSize(0)
18827: {}
18827: 
18827: void imgCacheQueue::UpdateSize(PRInt32 diff)
18827: {
18827:   mSize += diff;
    1: }
    1: 
18827: PRUint32 imgCacheQueue::GetSize() const
18827: {
18827:   return mSize;
    1: }
    1: 
18827: #include <algorithm>
19153: using namespace std;
17072: 
18827: void imgCacheQueue::Remove(imgCacheEntry *entry)
18827: {
18827:   queueContainer::iterator it = find(mQueue.begin(), mQueue.end(), entry);
18827:   if (it != mQueue.end()) {
18827:     mSize -= (*it)->GetDataSize();
18827:     mQueue.erase(it);
18827:     MarkDirty();
18827:   }
    1: }
    1: 
18827: void imgCacheQueue::Push(imgCacheEntry *entry)
18827: {
18827:   mSize += entry->GetDataSize();
    1: 
18827:   nsRefPtr<imgCacheEntry> refptr(entry);
18827:   mQueue.push_back(refptr);
18827:   MarkDirty();
    1: }
    1: 
18827: already_AddRefed<imgCacheEntry> imgCacheQueue::Pop()
18827: {
18827:   if (mQueue.empty())
18827:     return nsnull;
18827:   if (IsDirty())
18827:     Refresh();
18827: 
18827:   nsRefPtr<imgCacheEntry> entry = mQueue[0];
18827:   std::pop_heap(mQueue.begin(), mQueue.end(), imgLoader::CompareCacheEntries);
18827:   mQueue.pop_back();
18827: 
18827:   mSize -= entry->GetDataSize();
18827:   imgCacheEntry *ret = entry;
18827:   NS_ADDREF(ret);
18827:   return ret;
    1: }
    1: 
18827: void imgCacheQueue::Refresh()
18827: {
18827:   std::make_heap(mQueue.begin(), mQueue.end(), imgLoader::CompareCacheEntries);
18827:   mDirty = PR_FALSE;
    1: }
    1: 
18827: void imgCacheQueue::MarkDirty()
18827: {
18827:   mDirty = PR_TRUE;
    1: }
    1: 
18827: PRBool imgCacheQueue::IsDirty()
18827: {
18827:   return mDirty;
    1: }
    1: 
18827: PRUint32 imgCacheQueue::GetNumElements() const
18827: {
18827:   return mQueue.size();
    1: }
    1: 
18827: imgCacheQueue::iterator imgCacheQueue::begin()
18827: {
18827:   return mQueue.begin();
18827: }
18827: imgCacheQueue::const_iterator imgCacheQueue::begin() const
18827: {
18827:   return mQueue.begin();
    1: }
    1: 
18827: imgCacheQueue::iterator imgCacheQueue::end()
18827: {
18827:   return mQueue.end();
18827: }
18827: imgCacheQueue::const_iterator imgCacheQueue::end() const
18827: {
18827:   return mQueue.end();
    1: }
    1: 
18827: nsresult imgLoader::CreateNewProxyForRequest(imgRequest *aRequest, nsILoadGroup *aLoadGroup,
    1:                                              imgIDecoderObserver *aObserver,
    1:                                              nsLoadFlags aLoadFlags, imgIRequest *aProxyRequest,
    1:                                              imgIRequest **_retval)
    1: {
    1:   LOG_SCOPE_WITH_PARAM(gImgLog, "imgLoader::CreateNewProxyForRequest", "imgRequest", aRequest);
    1: 
    1:   /* XXX If we move decoding onto separate threads, we should save off the
    1:      calling thread here and pass it off to |proxyRequest| so that it call
    1:      proxy calls to |aObserver|.
    1:    */
    1: 
    1:   imgRequestProxy *proxyRequest;
    1:   if (aProxyRequest) {
 3233:     proxyRequest = static_cast<imgRequestProxy *>(aProxyRequest);
    1:   } else {
47223:     proxyRequest = new imgRequestProxy();
    1:     if (!proxyRequest) return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   NS_ADDREF(proxyRequest);
    1: 
    1:   /* It is important to call |SetLoadFlags()| before calling |Init()| because
    1:      |Init()| adds the request to the loadgroup.
    1:    */
    1:   proxyRequest->SetLoadFlags(aLoadFlags);
    1: 
48319:   nsCOMPtr<nsIURI> uri;
48319:   aRequest->GetURI(getter_AddRefs(uri));
48319: 
    1:   // init adds itself to imgRequest's list of observers
48320:   nsresult rv = proxyRequest->Init(aRequest, aLoadGroup, aRequest->mImage, uri, aObserver);
    1:   if (NS_FAILED(rv)) {
    1:     NS_RELEASE(proxyRequest);
    1:     return rv;
    1:   }
    1: 
    1:   // transfer reference to caller
 3233:   *_retval = static_cast<imgIRequest*>(proxyRequest);
    1: 
    1:   return NS_OK;
    1: }
    1: 
18827: class imgCacheObserver : public nsIObserver
18827: {
18827: public:
18827:   NS_DECL_ISUPPORTS
18827:   NS_DECL_NSIOBSERVER
18827: private:
18827:   imgLoader mLoader;
18827: };
18827: 
18827: NS_IMPL_ISUPPORTS1(imgCacheObserver, nsIObserver)
18827: 
18827: NS_IMETHODIMP
18827: imgCacheObserver::Observe(nsISupports* aSubject, const char* aTopic, const PRUnichar* aSomeData)
18827: {
18827:   if (strcmp(aTopic, "memory-pressure") == 0) {
28083:     mLoader.MinimizeCaches();
18827:   } else if (strcmp(aTopic, "chrome-flush-skin-caches") == 0 ||
18827:              strcmp(aTopic, "chrome-flush-caches") == 0) {
28083:     mLoader.ClearChromeImageCache();
18827:   }
18827:   return NS_OK;
18827: }
18827: 
18827: class imgCacheExpirationTracker : public nsExpirationTracker<imgCacheEntry, 3>
18827: {
18827:   enum { TIMEOUT_SECONDS = 10 };
18827: public:
18827:   imgCacheExpirationTracker();
18827: 
18827: protected:
18827:   void NotifyExpired(imgCacheEntry *entry);
18827: };
18827: 
18827: imgCacheExpirationTracker::imgCacheExpirationTracker()
18827:  : nsExpirationTracker<imgCacheEntry, 3>(TIMEOUT_SECONDS * 1000)
18827: {}
18827: 
18827: void imgCacheExpirationTracker::NotifyExpired(imgCacheEntry *entry)
18827: {
25508:   // Hold on to a reference to this entry, because the expiration tracker
25508:   // mechanism doesn't.
25508:   nsRefPtr<imgCacheEntry> kungFuDeathGrip(entry);
25508: 
25078: #if defined(PR_LOGGING)
25078:   nsRefPtr<imgRequest> req(entry->GetRequest());
25078:   if (req) {
25078:     nsCOMPtr<nsIURI> uri;
25078:     req->GetKeyURI(getter_AddRefs(uri));
25078:     nsCAutoString spec;
25078:     uri->GetSpec(spec);
25078:     LOG_FUNC_WITH_PARAM(gImgLog, "imgCacheExpirationTracker::NotifyExpired", "entry", spec.get());
25078:   }
25078: #endif
25078: 
18827:   // We can be called multiple times on the same entry. Don't do work multiple
18827:   // times.
18827:   if (!entry->Evicted())
18827:     imgLoader::RemoveFromCache(entry);
18827: 
18827:   imgLoader::VerifyCacheSizes();
18827: }
18827: 
18827: imgCacheObserver *gCacheObserver;
18827: imgCacheExpirationTracker *gCacheTracker;
18827: 
18827: imgLoader::imgCacheTable imgLoader::sCache;
18827: imgCacheQueue imgLoader::sCacheQueue;
18827: 
18827: imgLoader::imgCacheTable imgLoader::sChromeCache;
18827: imgCacheQueue imgLoader::sChromeCacheQueue;
18827: 
18827: PRFloat64 imgLoader::sCacheTimeWeight;
18827: PRUint32 imgLoader::sCacheMaxSize;
18827: 
30324: NS_IMPL_ISUPPORTS5(imgLoader, imgILoader, nsIContentSniffer, imgICache, nsISupportsWeakReference, nsIObserver)
18827: 
18827: imgLoader::imgLoader()
18827: {
18827:   /* member initializers and constructor code */
18827: }
18827: 
18827: imgLoader::~imgLoader()
18827: {
18827:   /* destructor code */
18827: }
18827: 
18827: void imgLoader::VerifyCacheSizes()
18827: {
41697: #ifdef DEBUG
18827:   if (!gCacheTracker)
18827:     return;
18827: 
25078:   PRUint32 cachesize = sCache.Count() + sChromeCache.Count();
24984:   PRUint32 queuesize = sCacheQueue.GetNumElements() + sChromeCacheQueue.GetNumElements();
18827:   PRUint32 trackersize = 0;
18827:   for (nsExpirationTracker<imgCacheEntry, 3>::Iterator it(gCacheTracker); it.Next(); )
18827:     trackersize++;
25078:   NS_ABORT_IF_FALSE(queuesize == trackersize, "Queue and tracker sizes out of sync!");
25078:   NS_ABORT_IF_FALSE(queuesize <= cachesize, "Queue has more elements than cache!");
41697: #endif
18827: }
18827: 
18827: imgLoader::imgCacheTable & imgLoader::GetCache(nsIURI *aURI)
18827: {
18827:   PRBool chrome = PR_FALSE;
18827:   aURI->SchemeIs("chrome", &chrome);
18827:   if (chrome)
18827:     return sChromeCache;
18827:   else
18827:     return sCache;
18827: }
18827: 
18827: imgCacheQueue & imgLoader::GetCacheQueue(nsIURI *aURI)
18827: {
18827:   PRBool chrome = PR_FALSE;
18827:   aURI->SchemeIs("chrome", &chrome);
18827:   if (chrome)
18827:     return sChromeCacheQueue;
18827:   else
18827:     return sCacheQueue;
18827: }
18827: 
18827: nsresult imgLoader::InitCache()
18827: {
42480:   NS_TIME_FUNCTION;
42480: 
18827:   nsresult rv;
41540:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
41540:   if (!os)
41540:     return NS_ERROR_FAILURE;
18827:   
18827:   gCacheObserver = new imgCacheObserver();
18827:   if (!gCacheObserver) 
18827:     return NS_ERROR_OUT_OF_MEMORY;
18827:   NS_ADDREF(gCacheObserver);
18827: 
18827:   os->AddObserver(gCacheObserver, "memory-pressure", PR_FALSE);
18827:   os->AddObserver(gCacheObserver, "chrome-flush-skin-caches", PR_FALSE);
18827:   os->AddObserver(gCacheObserver, "chrome-flush-caches", PR_FALSE);
18827: 
18827:   gCacheTracker = new imgCacheExpirationTracker();
18827:   if (!gCacheTracker)
18827:     return NS_ERROR_OUT_OF_MEMORY;
18827: 
18827:   if (!sCache.Init())
18827:       return NS_ERROR_OUT_OF_MEMORY;
18827:   if (!sChromeCache.Init())
18827:       return NS_ERROR_OUT_OF_MEMORY;
18827: 
18827:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv); 
18827:   if (NS_FAILED(rv))
18827:     return rv;
18827: 
18827:   PRInt32 timeweight;
18827:   rv = prefs->GetIntPref("image.cache.timeweight", &timeweight);
18827:   if (NS_SUCCEEDED(rv))
18827:     sCacheTimeWeight = timeweight / 1000.0;
18827:   else
18827:     sCacheTimeWeight = 0.5;
18827: 
18827:   PRInt32 cachesize;
18827:   rv = prefs->GetIntPref("image.cache.size", &cachesize);
18827:   if (NS_SUCCEEDED(rv))
18827:     sCacheMaxSize = cachesize;
18827:   else
18827:     sCacheMaxSize = 5 * 1024 * 1024;
18827: 
42553:   NS_RegisterMemoryReporter(new imgMemoryReporter(imgMemoryReporter::ChromeUsedRaw));
42553:   NS_RegisterMemoryReporter(new imgMemoryReporter(imgMemoryReporter::ChromeUsedUncompressed));
42553:   NS_RegisterMemoryReporter(new imgMemoryReporter(imgMemoryReporter::ChromeUnusedRaw));
42553:   NS_RegisterMemoryReporter(new imgMemoryReporter(imgMemoryReporter::ChromeUnusedUncompressed));
42553:   NS_RegisterMemoryReporter(new imgMemoryReporter(imgMemoryReporter::ContentUsedRaw));
42553:   NS_RegisterMemoryReporter(new imgMemoryReporter(imgMemoryReporter::ContentUsedUncompressed));
42553:   NS_RegisterMemoryReporter(new imgMemoryReporter(imgMemoryReporter::ContentUnusedRaw));
42553:   NS_RegisterMemoryReporter(new imgMemoryReporter(imgMemoryReporter::ContentUnusedUncompressed));
42553:   
18827:   return NS_OK;
18827: }
18827: 
30324: nsresult imgLoader::Init()
30324: {
30324:   nsresult rv;
30324:   nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv); 
30324:   if (NS_FAILED(rv))
30324:     return rv;
30324: 
30324:   ReadAcceptHeaderPref(prefs);
30324: 
30324:   prefs->AddObserver("image.http.accept", this, PR_TRUE);
30324: 
47315:   // Listen for when we leave private browsing mode
47315:   nsCOMPtr<nsIObserverService> obService = mozilla::services::GetObserverService();
47315:   if (obService)
47315:     obService->AddObserver(this, NS_PRIVATE_BROWSING_SWITCH_TOPIC, PR_TRUE);
47315: 
30324:   return NS_OK;
30324: }
30324: 
30324: NS_IMETHODIMP
30324: imgLoader::Observe(nsISupports* aSubject, const char* aTopic, const PRUnichar* aData)
30324: {
47315:   // We listen for pref change notifications...
47315:   if (!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
47315:     if (!strcmp(NS_ConvertUTF16toUTF8(aData).get(), "image.http.accept")) {
30324:       nsCOMPtr<nsIPrefBranch> prefs = do_QueryInterface(aSubject);
30324:       ReadAcceptHeaderPref(prefs);
30324:     }
47315:   }
47315: 
47315:   // ...and exits from private browsing.
47315:   else if (!strcmp(aTopic, NS_PRIVATE_BROWSING_SWITCH_TOPIC)) {
47315:     if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_LEAVE).Equals(aData))
47315:       ClearImageCache();
47315:   }
47315: 
47315:   // (Nothing else should bring us here)
47315:   else {
47315:     NS_ABORT_IF_FALSE(0, "Invalid topic received");
47315:   }
47315: 
30324:   return NS_OK;
30324: }
30324: 
30324: void imgLoader::ReadAcceptHeaderPref(nsIPrefBranch *aBranch)
30324: {
30324:   NS_ASSERTION(aBranch, "Pref branch is null");
30324: 
30324:   nsXPIDLCString accept;
30324:   nsresult rv = aBranch->GetCharPref("image.http.accept", getter_Copies(accept));
30324:   if (NS_SUCCEEDED(rv))
30324:     mAcceptHeader = accept;
30324:   else
30324:     mAcceptHeader = "image/png,image/*;q=0.8,*/*;q=0.5";
30324: }
30324: 
18827: /* void clearCache (in boolean chrome); */
18827: NS_IMETHODIMP imgLoader::ClearCache(PRBool chrome)
18827: {
18827:   if (chrome)
18827:     return ClearChromeImageCache();
18827:   else
18827:     return ClearImageCache();
18827: }
18827: 
18827: /* void removeEntry(in nsIURI uri); */
18827: NS_IMETHODIMP imgLoader::RemoveEntry(nsIURI *uri)
18827: {
18827:   if (RemoveFromCache(uri))
18827:     return NS_OK;
18827: 
18827:   return NS_ERROR_NOT_AVAILABLE;
18827: }
18827: 
18827: /* imgIRequest findEntry(in nsIURI uri); */
18827: NS_IMETHODIMP imgLoader::FindEntryProperties(nsIURI *uri, nsIProperties **_retval)
18827: {
18827:   nsRefPtr<imgCacheEntry> entry;
18827:   nsCAutoString spec;
18827:   imgCacheTable &cache = GetCache(uri);
18827: 
18827:   uri->GetSpec(spec);
18827:   *_retval = nsnull;
18827: 
18827:   if (cache.Get(spec, getter_AddRefs(entry)) && entry) {
25078:     if (gCacheTracker && entry->HasNoProxies())
18827:       gCacheTracker->MarkUsed(entry);
25078: 
18827:     nsRefPtr<imgRequest> request = getter_AddRefs(entry->GetRequest());
18827:     if (request) {
18827:       *_retval = request->Properties();
18827:       NS_ADDREF(*_retval);
18827:     }
18827:   }
18827: 
18827:   return NS_OK;
18827: }
18827: 
18827: void imgLoader::Shutdown()
18827: {
18827:   ClearChromeImageCache();
18827:   ClearImageCache();
18827:   NS_IF_RELEASE(gCacheObserver);
18827:   delete gCacheTracker;
18827:   gCacheTracker = nsnull;
18827: }
18827: 
18827: nsresult imgLoader::ClearChromeImageCache()
18827: {
28083:   return EvictEntries(sChromeCache);
18827: }
18827: 
18827: nsresult imgLoader::ClearImageCache()
18827: {
28083:   return EvictEntries(sCache);
28083: }
28083: 
28083: void imgLoader::MinimizeCaches()
28083: {
28083:   EvictEntries(sCacheQueue);
28083:   EvictEntries(sChromeCacheQueue);
18827: }
18827: 
18827: PRBool imgLoader::PutIntoCache(nsIURI *key, imgCacheEntry *entry)
18827: {
18827:   imgCacheTable &cache = GetCache(key);
18827: 
18827:   nsCAutoString spec;
18827:   key->GetSpec(spec);
18827: 
25078:   LOG_STATIC_FUNC_WITH_PARAM(gImgLog, "imgLoader::PutIntoCache", "uri", spec.get());
25078: 
18827:   // Check to see if this request already exists in the cache and is being
18827:   // loaded on a different thread. If so, don't allow this entry to be added to
18827:   // the cache.
18827:   nsRefPtr<imgCacheEntry> tmpCacheEntry;
18827:   if (cache.Get(spec, getter_AddRefs(tmpCacheEntry)) && tmpCacheEntry) {
18827:     PR_LOG(gImgLog, PR_LOG_DEBUG,
18827:            ("[this=%p] imgLoader::PutIntoCache -- Element already in the cache", nsnull));
18827:     nsRefPtr<imgRequest> tmpRequest = getter_AddRefs(tmpCacheEntry->GetRequest());
18827:     void *cacheId = NS_GetCurrentThread();
18827: 
25748:     // If the existing request is currently loading, or loading on a different
25748:     // thread, we'll leave it be, and not put this new entry into the cache.
18827:     if (!tmpRequest->IsReusable(cacheId))
18827:       return PR_FALSE;
18827: 
19932:     // If it already exists, and we're putting the same key into the cache, we
19932:     // should remove the old version.
19932:     PR_LOG(gImgLog, PR_LOG_DEBUG,
19932:            ("[this=%p] imgLoader::PutIntoCache -- Replacing cached element", nsnull));
18827: 
19932:     RemoveFromCache(key);
19932:   } else {
18827:     PR_LOG(gImgLog, PR_LOG_DEBUG,
18827:            ("[this=%p] imgLoader::PutIntoCache -- Element NOT already in the cache", nsnull));
19932:   }
18827: 
18827:   if (!cache.Put(spec, entry))
18827:     return PR_FALSE;
18827: 
26259:   // We can be called to resurrect an evicted entry.
26259:   if (entry->Evicted())
26259:     entry->SetEvicted(PR_FALSE);
26259: 
26259:   // If we're resurrecting an entry with no proxies, put it back in the
26259:   // tracker and queue.
26259:   if (entry->HasNoProxies()) {
26259:     nsresult addrv = NS_OK;
26259: 
26259:     if (gCacheTracker)
26259:       addrv = gCacheTracker->AddObject(entry);
26259: 
26259:     if (NS_SUCCEEDED(addrv)) {
26259:       imgCacheQueue &queue = GetCacheQueue(key);
26259:       queue.Push(entry);
26259:     }
26259:   }
26259: 
26259:   nsRefPtr<imgRequest> request(getter_AddRefs(entry->GetRequest()));
26259:   request->SetIsInCache(PR_TRUE);
26259: 
25078:   return PR_TRUE;
25078: }
25078: 
25078: PRBool imgLoader::SetHasNoProxies(nsIURI *key, imgCacheEntry *entry)
25078: {
25078: #if defined(PR_LOGGING)
25078:   nsCAutoString spec;
25078:   key->GetSpec(spec);
25078: 
25078:   LOG_STATIC_FUNC_WITH_PARAM(gImgLog, "imgLoader::SetHasNoProxies", "uri", spec.get());
25078: #endif
25078: 
25078:   if (entry->Evicted())
25078:     return PR_FALSE;
25078: 
18827:   imgCacheQueue &queue = GetCacheQueue(key);
25078: 
25078:   nsresult addrv = NS_OK;
18827: 
18827:   if (gCacheTracker)
25078:     addrv = gCacheTracker->AddObject(entry);
18827: 
25078:   if (NS_SUCCEEDED(addrv)) {
25078:     queue.Push(entry);
25078:     entry->SetHasNoProxies(PR_TRUE);
25078:   }
25078: 
25078:   imgCacheTable &cache = GetCache(key);
18827:   CheckCacheLimits(cache, queue);
18827: 
18827:   return PR_TRUE;
18827: }
18827: 
25078: PRBool imgLoader::SetHasProxies(nsIURI *key)
25078: {
25078:   VerifyCacheSizes();
25078: 
25078:   imgCacheTable &cache = GetCache(key);
25078: 
25078:   nsCAutoString spec;
25078:   key->GetSpec(spec);
25078: 
25078:   LOG_STATIC_FUNC_WITH_PARAM(gImgLog, "imgLoader::SetHasProxies", "uri", spec.get());
25078: 
25078:   nsRefPtr<imgCacheEntry> entry;
25078:   if (cache.Get(spec, getter_AddRefs(entry)) && entry && entry->HasNoProxies()) {
25078:     imgCacheQueue &queue = GetCacheQueue(key);
25078:     queue.Remove(entry);
25078: 
25078:     if (gCacheTracker)
25078:       gCacheTracker->RemoveObject(entry);
25078: 
25078:     entry->SetHasNoProxies(PR_FALSE);
25078: 
25078:     return PR_TRUE;
25078:   }
25078: 
25078:   return PR_FALSE;
25078: }
25078: 
18827: void imgLoader::CacheEntriesChanged(nsIURI *uri, PRInt32 sizediff /* = 0 */)
18827: {
18827:   imgCacheQueue &queue = GetCacheQueue(uri);
18827:   queue.MarkDirty();
18827:   queue.UpdateSize(sizediff);
18827: }
18827: 
18827: void imgLoader::CheckCacheLimits(imgCacheTable &cache, imgCacheQueue &queue)
18827: {
18827:   if (queue.GetNumElements() == 0)
18827:     NS_ASSERTION(queue.GetSize() == 0, 
18827:                  "imgLoader::CheckCacheLimits -- incorrect cache size");
18827: 
18827:   // Remove entries from the cache until we're back under our desired size.
18827:   while (queue.GetSize() >= sCacheMaxSize) {
18827:     // Remove the first entry in the queue.
18827:     nsRefPtr<imgCacheEntry> entry(queue.Pop());
18827: 
18827:     NS_ASSERTION(entry, "imgLoader::CheckCacheLimits -- NULL entry pointer");
18827: 
25078: #if defined(PR_LOGGING)
25078:     nsRefPtr<imgRequest> req(entry->GetRequest());
25078:     if (req) {
25078:       nsCOMPtr<nsIURI> uri;
25078:       req->GetKeyURI(getter_AddRefs(uri));
25078:       nsCAutoString spec;
25078:       uri->GetSpec(spec);
25078:       LOG_STATIC_FUNC_WITH_PARAM(gImgLog, "imgLoader::CheckCacheLimits", "entry", spec.get());
25078:     }
25078: #endif
25078: 
18827:     if (entry)
18827:       RemoveFromCache(entry);
18827:   }
18827: }
18827: 
18827: PRBool imgLoader::ValidateRequestWithNewChannel(imgRequest *request,
18827:                                                 nsIURI *aURI,
18827:                                                 nsIURI *aInitialDocumentURI,
18827:                                                 nsIURI *aReferrerURI,
18827:                                                 nsILoadGroup *aLoadGroup,
18827:                                                 imgIDecoderObserver *aObserver,
18827:                                                 nsISupports *aCX,
18827:                                                 nsLoadFlags aLoadFlags,
18827:                                                 imgIRequest *aExistingRequest,
42509:                                                 imgIRequest **aProxyRequest,
42509:                                                 nsIChannelPolicy *aPolicy)
18827: {
18827:   // now we need to insert a new channel request object inbetween the real
18827:   // request and the proxy that basically delays loading the image until it
18827:   // gets a 304 or figures out that this needs to be a new request
18827: 
18827:   nsresult rv;
18827: 
25078:   // If we're currently in the middle of validating this request, just hand
25078:   // back a proxy to it; the required work will be done for us.
18827:   if (request->mValidator) {
18827:     rv = CreateNewProxyForRequest(request, aLoadGroup, aObserver,
18827:                                   aLoadFlags, aExistingRequest, 
18827:                                   reinterpret_cast<imgIRequest **>(aProxyRequest));
18827: 
48936:     if (*aProxyRequest) {
48936:       imgRequestProxy* proxy = static_cast<imgRequestProxy*>(*aProxyRequest);
48936: 
48936:       // We will send notifications from imgCacheValidator::OnStartRequest().
48936:       // In the mean time, we must defer notifications because we are added to
48936:       // the imgRequest's proxy list, and we can get extra notifications
48936:       // resulting from methods such as RequestDecode(). See bug 579122.
48936:       proxy->SetNotificationsDeferred(PR_TRUE);
48936: 
48936:       // Attach the proxy without notifying
48936:       request->mValidator->AddProxy(proxy);
48936:     }
18827: 
18827:     return NS_SUCCEEDED(rv);
18827: 
18827:   } else {
18827:     nsCOMPtr<nsIChannel> newChannel;
18827:     rv = NewImageChannel(getter_AddRefs(newChannel),
18827:                          aURI,
18827:                          aInitialDocumentURI,
18827:                          aReferrerURI,
18827:                          aLoadGroup,
30324:                          mAcceptHeader,
42509:                          aLoadFlags,
42509:                          aPolicy);
18827:     if (NS_FAILED(rv)) {
18827:       return PR_FALSE;
18827:     }
18827: 
18827:     nsCOMPtr<nsICachingChannel> cacheChan(do_QueryInterface(newChannel));
18827: 
18827:     if (cacheChan) {
18827:       // since this channel supports nsICachingChannel, we can ask it
18827:       // to only stream us data if the data comes off the net.
18827:       PRUint32 loadFlags;
18827:       if (NS_SUCCEEDED(newChannel->GetLoadFlags(&loadFlags)))
18827:         newChannel->SetLoadFlags(loadFlags | nsICachingChannel::LOAD_ONLY_IF_MODIFIED);
18827:     }
18827: 
18827:     nsCOMPtr<imgIRequest> req;
18827:     rv = CreateNewProxyForRequest(request, aLoadGroup, aObserver,
18827:                                   aLoadFlags, aExistingRequest, getter_AddRefs(req));
18827:     if (NS_FAILED(rv)) {
18827:       return PR_FALSE;
18827:     }
18827: 
30795:     // Make sure that OnStatus/OnProgress calls have the right request set...
30795:     nsCOMPtr<nsIInterfaceRequestor> requestor(
30795:         new nsProgressNotificationProxy(newChannel, req));
30795:     if (!requestor)
30795:       return PR_FALSE;
30795:     newChannel->SetNotificationCallbacks(requestor);
30795: 
18827:     imgCacheValidator *hvc = new imgCacheValidator(request, aCX);
18827:     if (!hvc) {
18827:       return PR_FALSE;
18827:     }
18827: 
18827:     NS_ADDREF(hvc);
18827:     request->mValidator = hvc;
18827: 
48936:     imgRequestProxy* proxy = static_cast<imgRequestProxy*>
48936:                                (static_cast<imgIRequest*>(req.get()));
48936: 
48936:     // We will send notifications from imgCacheValidator::OnStartRequest().
48936:     // In the mean time, we must defer notifications because we are added to
48936:     // the imgRequest's proxy list, and we can get extra notifications
48936:     // resulting from methods such as RequestDecode(). See bug 579122.
48936:     proxy->SetNotificationsDeferred(PR_TRUE);
48936: 
48936:     // Add the proxy without notifying
48936:     hvc->AddProxy(proxy);
18827: 
18827:     rv = newChannel->AsyncOpen(static_cast<nsIStreamListener *>(hvc), nsnull);
18827:     if (NS_SUCCEEDED(rv))
18827:       NS_ADDREF(*aProxyRequest = req.get());
18827: 
18827:     NS_RELEASE(hvc);
18827: 
18827:     return NS_SUCCEEDED(rv);
18827:   }
18827: }
18827: 
18827: PRBool imgLoader::ValidateEntry(imgCacheEntry *aEntry,
18827:                                 nsIURI *aURI,
18827:                                 nsIURI *aInitialDocumentURI,
18827:                                 nsIURI *aReferrerURI,
18827:                                 nsILoadGroup *aLoadGroup,
18827:                                 imgIDecoderObserver *aObserver,
18827:                                 nsISupports *aCX,
18827:                                 nsLoadFlags aLoadFlags,
18827:                                 PRBool aCanMakeNewChannel,
18827:                                 imgIRequest *aExistingRequest,
42509:                                 imgIRequest **aProxyRequest,
42509:                                 nsIChannelPolicy *aPolicy = nsnull)
18827: {
18827:   LOG_SCOPE(gImgLog, "imgLoader::ValidateEntry");
18827: 
18827:   PRBool hasExpired;
18827:   PRUint32 expirationTime = aEntry->GetExpiryTime();
18827:   if (expirationTime <= SecondsFromPRTime(PR_Now())) {
18827:     hasExpired = PR_TRUE;
18827:   } else {
18827:     hasExpired = PR_FALSE;
18827:   }
18827: 
18827:   nsresult rv;
18827: 
18827:   // Special treatment for file URLs - aEntry has expired if file has changed
18827:   nsCOMPtr<nsIFileURL> fileUrl(do_QueryInterface(aURI));
18827:   if (fileUrl) {
18827:     PRUint32 lastModTime = aEntry->GetTouchedTime();
18827: 
18827:     nsCOMPtr<nsIFile> theFile;
18827:     rv = fileUrl->GetFile(getter_AddRefs(theFile));
18827:     if (NS_SUCCEEDED(rv)) {
18827:       PRInt64 fileLastMod;
18827:       rv = theFile->GetLastModifiedTime(&fileLastMod);
18827:       if (NS_SUCCEEDED(rv)) {
18827:         // nsIFile uses millisec, NSPR usec
18827:         fileLastMod *= 1000;
18827:         hasExpired = SecondsFromPRTime((PRTime)fileLastMod) > lastModTime;
18827:       }
18827:     }
18827:   }
18827: 
18827:   nsRefPtr<imgRequest> request(aEntry->GetRequest());
18827: 
18827:   if (!request)
18827:     return PR_FALSE;
18827: 
18827:   PRBool validateRequest = PR_FALSE;
18827: 
18827:   // If the request's loadId is the same as the aCX, then it is ok to use
18827:   // this one because it has already been validated for this context.
18827:   //
18827:   // XXX: nsnull seems to be a 'special' key value that indicates that NO
18827:   //      validation is required.
18827:   //
18827:   void *key = (void *)aCX;
18827:   if (request->mLoadId != key) {
34806:     // If we would need to revalidate this entry, but we're being told to
34806:     // bypass the cache, we don't allow this entry to be used.
34806:     if (aLoadFlags & nsIRequest::LOAD_BYPASS_CACHE)
34806:       return PR_FALSE;
34806: 
18827:     // Determine whether the cache aEntry must be revalidated...
18827:     validateRequest = ShouldRevalidateEntry(aEntry, aLoadFlags, hasExpired);
18827: 
18827:     PR_LOG(gImgLog, PR_LOG_DEBUG,
18827:            ("imgLoader::ValidateEntry validating cache entry. " 
18827:             "validateRequest = %d", validateRequest));
18827:   }
18827: #if defined(PR_LOGGING)
18827:   else if (!key) {
18827:     nsCAutoString spec;
18827:     aURI->GetSpec(spec);
18827: 
18827:     PR_LOG(gImgLog, PR_LOG_DEBUG,
18827:            ("imgLoader::ValidateEntry BYPASSING cache validation for %s " 
18827:             "because of NULL LoadID", spec.get()));
18827:   }
18827: #endif
18827: 
18827:   //
18827:   // Get the current thread...  This is used as a cacheId to prevent
18827:   // sharing requests which are being loaded across multiple threads...
18827:   //
18827:   void *cacheId = NS_GetCurrentThread();
18827:   if (!request->IsReusable(cacheId)) {
18827:     //
18827:     // The current request is still being loaded and lives on a different
18827:     // event queue.
18827:     //
18827:     // Since its event queue is NOT active, do not reuse this imgRequest.
18827:     // PutIntoCache() will also ensure that we don't cache it.
18827:     //
18827:     PR_LOG(gImgLog, PR_LOG_DEBUG,
18827:            ("imgLoader::ValidateEntry -- DANGER!! Unable to use cached "
18827:             "imgRequest [request=%p]\n", address_of(request)));
18827: 
18827:     return PR_FALSE;
18827:   }
18827: 
23324:   // We can't use a cached request if it comes from a different
23324:   // application cache than this load is expecting.
23324:   nsCOMPtr<nsIApplicationCacheContainer> appCacheContainer;
23324:   nsCOMPtr<nsIApplicationCache> requestAppCache;
23324:   nsCOMPtr<nsIApplicationCache> groupAppCache;
23324:   if ((appCacheContainer = do_GetInterface(request->mRequest)))
23324:     appCacheContainer->GetApplicationCache(getter_AddRefs(requestAppCache));
23324:   if ((appCacheContainer = do_QueryInterface(aLoadGroup)))
23324:     appCacheContainer->GetApplicationCache(getter_AddRefs(groupAppCache));
23324: 
23324:   if (requestAppCache != groupAppCache) {
23324:     PR_LOG(gImgLog, PR_LOG_DEBUG,
23324:            ("imgLoader::ValidateEntry - Unable to use cached imgRequest "
23324:             "[request=%p] because of mismatched application caches\n",
23324:             address_of(request)));
23324:     return PR_FALSE;
23324:   }
23324: 
18827:   if (validateRequest && aCanMakeNewChannel) {
18827:     LOG_SCOPE(gImgLog, "imgLoader::ValidateRequest |cache hit| must validate");
18827: 
18827:     return ValidateRequestWithNewChannel(request, aURI, aInitialDocumentURI,
18827:                                          aReferrerURI, aLoadGroup, aObserver,
18827:                                          aCX, aLoadFlags, aExistingRequest,
42509:                                          aProxyRequest, aPolicy);
18827:   } 
18827: 
18827:   return !validateRequest;
18827: }
18827: 
18827: 
18827: PRBool imgLoader::RemoveFromCache(nsIURI *aKey)
18827: {
18827:   if (!aKey) return PR_FALSE;
18827: 
18827:   imgCacheTable &cache = GetCache(aKey);
18827:   imgCacheQueue &queue = GetCacheQueue(aKey);
18827: 
18827:   nsCAutoString spec;
18827:   aKey->GetSpec(spec);
18827: 
25078:   LOG_STATIC_FUNC_WITH_PARAM(gImgLog, "imgLoader::RemoveFromCache", "uri", spec.get());
25078: 
18827:   nsRefPtr<imgCacheEntry> entry;
18827:   if (cache.Get(spec, getter_AddRefs(entry)) && entry) {
25078:     cache.Remove(spec);
25078: 
25078:     NS_ABORT_IF_FALSE(!entry->Evicted(), "Evicting an already-evicted cache entry!");
25078: 
25078:     // Entries with no proxies are in the tracker.
25078:     if (entry->HasNoProxies()) {
18827:       if (gCacheTracker)
18827:         gCacheTracker->RemoveObject(entry);
18827:       queue.Remove(entry);
25078:     }
25078: 
18827:     entry->SetEvicted(PR_TRUE);
25078: 
26259:     nsRefPtr<imgRequest> request(getter_AddRefs(entry->GetRequest()));
26259:     request->SetIsInCache(PR_FALSE);
26259: 
18827:     return PR_TRUE;
18827:   }
18827:   else
18827:     return PR_FALSE;
18827: }
18827: 
18827: PRBool imgLoader::RemoveFromCache(imgCacheEntry *entry)
18827: {
18827:   LOG_STATIC_FUNC(gImgLog, "imgLoader::RemoveFromCache entry");
25078: 
18827:   nsRefPtr<imgRequest> request(getter_AddRefs(entry->GetRequest()));
18827:   if (request) {
18827:     nsCOMPtr<nsIURI> key;
25078:     if (NS_SUCCEEDED(request->GetKeyURI(getter_AddRefs(key))) && key) {
25078:       imgCacheTable &cache = GetCache(key);
25078:       imgCacheQueue &queue = GetCacheQueue(key);
25078:       nsCAutoString spec;
25078:       key->GetSpec(spec);
25078: 
25078:       LOG_STATIC_FUNC_WITH_PARAM(gImgLog, "imgLoader::RemoveFromCache", "entry's uri", spec.get());
25078: 
25078:       cache.Remove(spec);
25078: 
25078:       if (entry->HasNoProxies()) {
25078:         LOG_STATIC_FUNC(gImgLog, "imgLoader::RemoveFromCache removing from tracker");
25078:         if (gCacheTracker)
25078:           gCacheTracker->RemoveObject(entry);
25078:         queue.Remove(entry);
18827:       }
18827: 
25078:       entry->SetEvicted(PR_TRUE);
26259:       request->SetIsInCache(PR_FALSE);
25078: 
25078:       return PR_TRUE;
25078:     }
25078:   }
25078: 
25078:   return PR_FALSE;
25078: }
25078: 
25078: static PLDHashOperator EnumEvictEntries(const nsACString&, 
25078:                                         nsRefPtr<imgCacheEntry> &aData,
25078:                                         void *data)
25078: {
25078:   nsTArray<nsRefPtr<imgCacheEntry> > *entries = 
25078:     reinterpret_cast<nsTArray<nsRefPtr<imgCacheEntry> > *>(data);
25078: 
25078:   entries->AppendElement(aData);
25078: 
25078:   return PL_DHASH_NEXT;
18827: }
18827: 
28083: nsresult imgLoader::EvictEntries(imgCacheTable &aCacheToClear)
18827: {
28083:   LOG_STATIC_FUNC(gImgLog, "imgLoader::EvictEntries table");
18827: 
18827:   // We have to make a temporary, since RemoveFromCache removes the element
18827:   // from the queue, invalidating iterators.
18827:   nsTArray<nsRefPtr<imgCacheEntry> > entries;
25078:   aCacheToClear.Enumerate(EnumEvictEntries, &entries);
18827: 
18827:   for (PRUint32 i = 0; i < entries.Length(); ++i)
18827:     if (!RemoveFromCache(entries[i]))
18827:       return NS_ERROR_FAILURE;
18827: 
18827:   return NS_OK;
18827: }
18827: 
28083: nsresult imgLoader::EvictEntries(imgCacheQueue &aQueueToClear)
28083: {
28083:   LOG_STATIC_FUNC(gImgLog, "imgLoader::EvictEntries queue");
28083: 
28083:   // We have to make a temporary, since RemoveFromCache removes the element
28083:   // from the queue, invalidating iterators.
28083:   nsTArray<nsRefPtr<imgCacheEntry> > entries(aQueueToClear.GetNumElements());
28083:   for (imgCacheQueue::const_iterator i = aQueueToClear.begin(); i != aQueueToClear.end(); ++i)
28083:     entries.AppendElement(*i);
28083: 
28083:   for (PRUint32 i = 0; i < entries.Length(); ++i)
28083:     if (!RemoveFromCache(entries[i]))
28083:       return NS_ERROR_FAILURE;
28083: 
28083:   return NS_OK;
28083: }
28083: 
18827: #define LOAD_FLAGS_CACHE_MASK    (nsIRequest::LOAD_BYPASS_CACHE | \
18827:                                   nsIRequest::LOAD_FROM_CACHE)
18827: 
18827: #define LOAD_FLAGS_VALIDATE_MASK (nsIRequest::VALIDATE_ALWAYS |   \
18827:                                   nsIRequest::VALIDATE_NEVER |    \
18827:                                   nsIRequest::VALIDATE_ONCE_PER_SESSION)
18827: 
18827: 
18827: /* imgIRequest loadImage (in nsIURI aURI, in nsIURI initialDocumentURI, in nsILoadGroup aLoadGroup, in imgIDecoderObserver aObserver, in nsISupports aCX, in nsLoadFlags aLoadFlags, in nsISupports cacheKey, in imgIRequest aRequest); */
18827: 
18827: NS_IMETHODIMP imgLoader::LoadImage(nsIURI *aURI, 
18827:                                    nsIURI *aInitialDocumentURI,
18827:                                    nsIURI *aReferrerURI,
18827:                                    nsILoadGroup *aLoadGroup,
18827:                                    imgIDecoderObserver *aObserver,
18827:                                    nsISupports *aCX,
18827:                                    nsLoadFlags aLoadFlags,
18827:                                    nsISupports *aCacheKey,
18827:                                    imgIRequest *aRequest,
42509:                                    nsIChannelPolicy *aPolicy,
18827:                                    imgIRequest **_retval)
18827: {
18827:   VerifyCacheSizes();
18827: 
18827:   NS_ASSERTION(aURI, "imgLoader::LoadImage -- NULL URI pointer");
18827: 
18827:   if (!aURI)
18827:     return NS_ERROR_NULL_POINTER;
18827: 
18827:   nsCAutoString spec;
18827:   aURI->GetSpec(spec);
18827:   LOG_SCOPE_WITH_PARAM(gImgLog, "imgLoader::LoadImage", "aURI", spec.get());
18827: 
18827:   *_retval = nsnull;
18827: 
18827:   nsRefPtr<imgRequest> request;
18827: 
18827:   nsresult rv;
18827:   nsLoadFlags requestFlags = nsIRequest::LOAD_NORMAL;
18827: 
18827:   // Get the default load flags from the loadgroup (if possible)...
18827:   if (aLoadGroup) {
18827:     aLoadGroup->GetLoadFlags(&requestFlags);
18827:   }
18827:   //
18827:   // Merge the default load flags with those passed in via aLoadFlags.
18827:   // Currently, *only* the caching, validation and background load flags
18827:   // are merged...
18827:   //
18827:   // The flags in aLoadFlags take precedence over the default flags!
18827:   //
18827:   if (aLoadFlags & LOAD_FLAGS_CACHE_MASK) {
18827:     // Override the default caching flags...
18827:     requestFlags = (requestFlags & ~LOAD_FLAGS_CACHE_MASK) |
18827:                    (aLoadFlags & LOAD_FLAGS_CACHE_MASK);
18827:   }
18827:   if (aLoadFlags & LOAD_FLAGS_VALIDATE_MASK) {
18827:     // Override the default validation flags...
18827:     requestFlags = (requestFlags & ~LOAD_FLAGS_VALIDATE_MASK) |
18827:                    (aLoadFlags & LOAD_FLAGS_VALIDATE_MASK);
18827:   }
18827:   if (aLoadFlags & nsIRequest::LOAD_BACKGROUND) {
18827:     // Propagate background loading...
18827:     requestFlags |= nsIRequest::LOAD_BACKGROUND;
18827:   }
18827: 
18827:   nsRefPtr<imgCacheEntry> entry;
18827: 
18827:   // Look in the cache for our URI, and then validate it.
18827:   // XXX For now ignore aCacheKey. We will need it in the future
18827:   // for correctly dealing with image load requests that are a result
18827:   // of post data.
18827:   imgCacheTable &cache = GetCache(aURI);
23007: 
18827:   if (cache.Get(spec, getter_AddRefs(entry)) && entry) {
42509:     if (ValidateEntry(entry, aURI, aInitialDocumentURI, aReferrerURI,
42509:                       aLoadGroup, aObserver, aCX, requestFlags, PR_TRUE,
42509:                       aRequest, _retval, aPolicy)) {
18827:       request = getter_AddRefs(entry->GetRequest());
18827: 
25078:       // If this entry has no proxies, its request has no reference to the entry.
25078:       if (entry->HasNoProxies()) {
25078:         LOG_FUNC_WITH_PARAM(gImgLog, "imgLoader::LoadImage() adding proxyless entry", "uri", spec.get());
25078:         NS_ABORT_IF_FALSE(!request->HasCacheEntry(), "Proxyless entry's request has cache entry!");
25078:         request->SetCacheEntry(entry);
25078: 
25078:         if (gCacheTracker)
25078:           gCacheTracker->MarkUsed(entry);
25078:       } 
25078: 
18827:       entry->Touch();
25078: 
18827: #ifdef DEBUG_joe
18827:       printf("CACHEGET: %d %s %d\n", time(NULL), spec.get(), entry->GetDataSize());
18827: #endif
18827:     }
34806:     else {
34806:       // We can't use this entry. We'll try to load it off the network, and if
34806:       // successful, overwrite the old entry in the cache with a new one.
18827:       entry = nsnull;
18827:     }
18827:   }
18827: 
30795:   // Keep the channel in this scope, so we can adjust its notificationCallbacks
30795:   // later when we create the proxy.
30795:   nsCOMPtr<nsIChannel> newChannel;
18827:   // If we didn't get a cache hit, we need to load from the network.
18827:   if (!request) {
18827:     LOG_SCOPE(gImgLog, "imgLoader::LoadImage |cache miss|");
18827: 
18827:     rv = NewImageChannel(getter_AddRefs(newChannel),
18827:                          aURI,
18827:                          aInitialDocumentURI,
18827:                          aReferrerURI,
18827:                          aLoadGroup,
30324:                          mAcceptHeader,
42509:                          requestFlags,
42509:                          aPolicy);
18827:     if (NS_FAILED(rv))
18827:       return NS_ERROR_FAILURE;
18827: 
18827:     if (!NewRequestAndEntry(aURI, getter_AddRefs(request), getter_AddRefs(entry)))
18827:       return NS_ERROR_OUT_OF_MEMORY;
18827: 
18827:     PR_LOG(gImgLog, PR_LOG_DEBUG,
18827:            ("[this=%p] imgLoader::LoadImage -- Created new imgRequest [request=%p]\n", this, request.get()));
18827: 
18827:     // Create a loadgroup for this new channel.  This way if the channel
18827:     // is redirected, we'll have a way to cancel the resulting channel.
18827:     nsCOMPtr<nsILoadGroup> loadGroup =
18827:         do_CreateInstance(NS_LOADGROUP_CONTRACTID);
18827:     newChannel->SetLoadGroup(loadGroup);
18827: 
18827:     void *cacheId = NS_GetCurrentThread();
23036:     request->Init(aURI, aURI, loadGroup, newChannel, entry, cacheId, aCX);
18827: 
18827:     // create the proxy listener
18827:     ProxyListener *pl = new ProxyListener(static_cast<nsIStreamListener *>(request.get()));
18827:     if (!pl) {
23007:       request->CancelAndAbort(NS_ERROR_OUT_OF_MEMORY);
18827:       return NS_ERROR_OUT_OF_MEMORY;
18827:     }
18827: 
18827:     NS_ADDREF(pl);
18827: 
18827:     PR_LOG(gImgLog, PR_LOG_DEBUG,
18827:            ("[this=%p] imgLoader::LoadImage -- Calling channel->AsyncOpen()\n", this));
18827: 
18827:     nsresult openRes = newChannel->AsyncOpen(static_cast<nsIStreamListener *>(pl), nsnull);
18827: 
18827:     NS_RELEASE(pl);
18827: 
18827:     if (NS_FAILED(openRes)) {
18827:       PR_LOG(gImgLog, PR_LOG_DEBUG,
18827:              ("[this=%p] imgLoader::LoadImage -- AsyncOpen() failed: 0x%x\n",
18827:               this, openRes));
23007:       request->CancelAndAbort(openRes);
18827:       return openRes;
18827:     }
18827: 
18827:     // Try to add the new request into the cache.
26259:     PutIntoCache(aURI, entry);
18827:   } else {
18827:     LOG_MSG_WITH_PARAM(gImgLog, 
18827:                        "imgLoader::LoadImage |cache hit|", "request", request);
34807:   }
18827: 
18827: 
18827:   // If we didn't get a proxy when validating the cache entry, we need to create one.
18827:   if (!*_retval) {
34807:     // ValidateEntry() has three return values: "Is valid," "might be valid --
34807:     // validating over network", and "not valid." If we don't have a _retval,
34807:     // we know ValidateEntry is not validating over the network, so it's safe
34807:     // to SetLoadId here because we know this request is valid for this context.
34807:     //
34807:     // Note, however, that this doesn't guarantee the behaviour we want (one
34807:     // URL maps to the same image on a page) if we load the same image in a
34807:     // different tab (see bug 528003), because its load id will get re-set, and
34807:     // that'll cause us to validate over the network.
34807:     request->SetLoadId(aCX);
34807: 
18827:     LOG_MSG(gImgLog, "imgLoader::LoadImage", "creating proxy request.");
18827:     rv = CreateNewProxyForRequest(request, aLoadGroup, aObserver,
18827:                                   requestFlags, aRequest, _retval);
18827:     imgRequestProxy *proxy = static_cast<imgRequestProxy *>(*_retval);
18827: 
30795:     // Make sure that OnStatus/OnProgress calls have the right request set, if
30795:     // we did create a channel here.
30795:     if (newChannel) {
30795:       nsCOMPtr<nsIInterfaceRequestor> requestor(
30795:           new nsProgressNotificationProxy(newChannel, proxy));
30795:       if (!requestor)
30795:         return NS_ERROR_OUT_OF_MEMORY;
30795:       newChannel->SetNotificationCallbacks(requestor);
30795:     }
30795: 
18827:     // Note that it's OK to add here even if the request is done.  If it is,
48319:     // it'll send a OnStopRequest() to the proxy in imgRequestProxy::Notify and
48319:     // the proxy will be removed from the loadgroup.
18827:     proxy->AddToLoadGroup();
18827: 
48321:     // If we're loading off the network, explicitly don't notify our proxy,
48321:     // because necko (or things called from necko, such as imgCacheValidator)
48321:     // are going to call our notifications asynchronously, and we can't make it
48321:     // further asynchronous because observers might rely on imagelib completing
48321:     // its work between the channel's OnStartRequest and OnStopRequest.
48321:     if (!newChannel)
48319:       proxy->NotifyListener();
18827: 
18827:     return rv;
18827:   }
18827: 
18827:   NS_ASSERTION(*_retval, "imgLoader::LoadImage -- no return value");
18827: 
18827:   return NS_OK;
18827: }
18827: 
18827: /* imgIRequest loadImageWithChannel(in nsIChannel channel, in imgIDecoderObserver aObserver, in nsISupports cx, out nsIStreamListener); */
18827: NS_IMETHODIMP imgLoader::LoadImageWithChannel(nsIChannel *channel, imgIDecoderObserver *aObserver, nsISupports *aCX, nsIStreamListener **listener, imgIRequest **_retval)
18827: {
18827:   NS_ASSERTION(channel, "imgLoader::LoadImageWithChannel -- NULL channel pointer");
18827: 
18827:   nsresult rv;
18827:   nsRefPtr<imgRequest> request;
18827: 
18827:   nsCOMPtr<nsIURI> uri;
18827:   channel->GetURI(getter_AddRefs(uri));
18827: 
18827:   nsLoadFlags requestFlags = nsIRequest::LOAD_NORMAL;
18827:   channel->GetLoadFlags(&requestFlags);
18827: 
18827:   nsRefPtr<imgCacheEntry> entry;
18827: 
18827:   if (requestFlags & nsIRequest::LOAD_BYPASS_CACHE) {
18827:     RemoveFromCache(uri);
18827:   } else {
18827:     // Look in the cache for our URI, and then validate it.
18827:     // XXX For now ignore aCacheKey. We will need it in the future
18827:     // for correctly dealing with image load requests that are a result
18827:     // of post data.
18827:     imgCacheTable &cache = GetCache(uri);
18827:     nsCAutoString spec;
18827: 
18827:     uri->GetSpec(spec);
18827: 
18827:     if (cache.Get(spec, getter_AddRefs(entry)) && entry) {
18827:       // We don't want to kick off another network load. So we ask
18827:       // ValidateEntry to only do validation without creating a new proxy. If
18827:       // it says that the entry isn't valid any more, we'll only use the entry
18827:       // we're getting if the channel is loading from the cache anyways.
18827:       //
18827:       // XXX -- should this be changed? it's pretty much verbatim from the old
18827:       // code, but seems nonsensical.
18827:       if (ValidateEntry(entry, uri, nsnull, nsnull, nsnull, aObserver, aCX,
18827:                         requestFlags, PR_FALSE, nsnull, nsnull)) {
18827:         request = getter_AddRefs(entry->GetRequest());
18827:       } else {
18827:         nsCOMPtr<nsICachingChannel> cacheChan(do_QueryInterface(channel));
18827:         PRBool bUseCacheCopy;
18827: 
18827:         if (cacheChan)
18827:           cacheChan->IsFromCache(&bUseCacheCopy);
18827:         else
18827:           bUseCacheCopy = PR_FALSE;
18827: 
18827:         if (!bUseCacheCopy)
18827:           entry = nsnull;
18827:         else {
18827:           request = getter_AddRefs(entry->GetRequest());
18827:         }
18827:       }
25078: 
25078:       if (request && entry) {
25078:         // If this entry has no proxies, its request has no reference to the entry.
25078:         if (entry->HasNoProxies()) {
25078:           LOG_FUNC_WITH_PARAM(gImgLog, "imgLoader::LoadImageWithChannel() adding proxyless entry", "uri", spec.get());
25078:           NS_ABORT_IF_FALSE(!request->HasCacheEntry(), "Proxyless entry's request has cache entry!");
25078:           request->SetCacheEntry(entry);
25078: 
25078:           if (gCacheTracker)
25078:             gCacheTracker->MarkUsed(entry);
25078:         } 
25078:       }
18827:     }
18827:   }
18827: 
18827:   nsCOMPtr<nsILoadGroup> loadGroup;
18827:   channel->GetLoadGroup(getter_AddRefs(loadGroup));
18827: 
48321:   // XXX: It looks like the wrong load flags are being passed in...
48321:   requestFlags &= 0xFFFF;
48321: 
18827:   if (request) {
18827:     // we have this in our cache already.. cancel the current (document) load
18827: 
25034:     channel->Cancel(NS_ERROR_PARSED_DATA_CACHED); // this should fire an OnStopRequest
18827: 
18827:     *listener = nsnull; // give them back a null nsIStreamListener
48321: 
48321:     rv = CreateNewProxyForRequest(request, loadGroup, aObserver,
48321:                                   requestFlags, nsnull, _retval);
48321:     static_cast<imgRequestProxy*>(*_retval)->NotifyListener();
18827:   } else {
25078:     if (!NewRequestAndEntry(uri, getter_AddRefs(request), getter_AddRefs(entry)))
25078:       return NS_ERROR_OUT_OF_MEMORY;
18827: 
23007:     // We use originalURI here to fulfil the imgIRequest contract on GetURI.
18827:     nsCOMPtr<nsIURI> originalURI;
18827:     channel->GetOriginalURI(getter_AddRefs(originalURI));
23036:     request->Init(originalURI, uri, channel, channel, entry, NS_GetCurrentThread(), aCX);
18827: 
18827:     ProxyListener *pl = new ProxyListener(static_cast<nsIStreamListener *>(request.get()));
25078:     if (!pl) {
25078:       request->CancelAndAbort(NS_ERROR_OUT_OF_MEMORY);
18827:       return NS_ERROR_OUT_OF_MEMORY;
25078:     }
18827: 
18827:     NS_ADDREF(pl);
18827: 
18827:     *listener = static_cast<nsIStreamListener*>(pl);
18827:     NS_ADDREF(*listener);
18827: 
18827:     NS_RELEASE(pl);
18827: 
18827:     // Try to add the new request into the cache.
26259:     PutIntoCache(uri, entry);
18827: 
18827:     rv = CreateNewProxyForRequest(request, loadGroup, aObserver,
18827:                                   requestFlags, nsnull, _retval);
48321: 
48321:     // Explicitly don't notify our proxy, because we're loading off the
48321:     // network, and necko (or things called from necko, such as
48321:     // imgCacheValidator) are going to call our notifications asynchronously,
48321:     // and we can't make it further asynchronous because observers might rely
48321:     // on imagelib completing its work between the channel's OnStartRequest and
48321:     // OnStopRequest.
48321:   }
18827: 
18827:   return rv;
18827: }
18827: 
    1: NS_IMETHODIMP imgLoader::SupportImageWithMimeType(const char* aMimeType, PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1:   nsCAutoString mimeType(aMimeType);
    1:   ToLowerCase(mimeType);
51234:   *_retval = (Image::GetDecoderType(mimeType.get()) == Image::eDecoderType_unknown)
51234:     ? PR_FALSE : PR_TRUE;
51234:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP imgLoader::GetMIMETypeFromContent(nsIRequest* aRequest,
    1:                                                 const PRUint8* aContents,
    1:                                                 PRUint32 aLength,
    1:                                                 nsACString& aContentType)
    1: {
    1:   return GetMimeTypeFromContent((const char*)aContents, aLength, aContentType);
    1: }
    1: 
    1: /* static */
    1: nsresult imgLoader::GetMimeTypeFromContent(const char* aContents, PRUint32 aLength, nsACString& aContentType)
    1: {
    1:   /* Is it a GIF? */
26949:   if (aLength >= 6 && (!nsCRT::strncmp(aContents, "GIF87a", 6) ||
26949:                        !nsCRT::strncmp(aContents, "GIF89a", 6)))
26949:   {
    1:     aContentType.AssignLiteral("image/gif");
    1:   }
    1: 
    1:   /* or a PNG? */
26949:   else if (aLength >= 8 && ((unsigned char)aContents[0]==0x89 &&
    1:                    (unsigned char)aContents[1]==0x50 &&
    1:                    (unsigned char)aContents[2]==0x4E &&
26949:                    (unsigned char)aContents[3]==0x47 &&
26949:                    (unsigned char)aContents[4]==0x0D &&
26949:                    (unsigned char)aContents[5]==0x0A &&
26949:                    (unsigned char)aContents[6]==0x1A &&
26949:                    (unsigned char)aContents[7]==0x0A))
    1:   { 
    1:     aContentType.AssignLiteral("image/png");
    1:   }
    1: 
    1:   /* maybe a JPEG (JFIF)? */
    1:   /* JFIF files start with SOI APP0 but older files can start with SOI DQT
    1:    * so we test for SOI followed by any marker, i.e. FF D8 FF
    1:    * this will also work for SPIFF JPEG files if they appear in the future.
    1:    *
    1:    * (JFIF is 0XFF 0XD8 0XFF 0XE0 <skip 2> 0X4A 0X46 0X49 0X46 0X00)
    1:    */
    1:   else if (aLength >= 3 &&
    1:      ((unsigned char)aContents[0])==0xFF &&
    1:      ((unsigned char)aContents[1])==0xD8 &&
    1:      ((unsigned char)aContents[2])==0xFF)
    1:   {
    1:     aContentType.AssignLiteral("image/jpeg");
    1:   }
    1: 
    1:   /* or how about ART? */
    1:   /* ART begins with JG (4A 47). Major version offset 2.
    1:    * Minor version offset 3. Offset 4 must be NULL.
    1:    */
    1:   else if (aLength >= 5 &&
    1:    ((unsigned char) aContents[0])==0x4a &&
    1:    ((unsigned char) aContents[1])==0x47 &&
    1:    ((unsigned char) aContents[4])==0x00 )
    1:   {
    1:     aContentType.AssignLiteral("image/x-jg");
    1:   }
    1: 
    1:   else if (aLength >= 2 && !nsCRT::strncmp(aContents, "BM", 2)) {
    1:     aContentType.AssignLiteral("image/bmp");
    1:   }
    1: 
    1:   // ICOs always begin with a 2-byte 0 followed by a 2-byte 1.
    1:   // CURs begin with 2-byte 0 followed by 2-byte 2.
    1:   else if (aLength >= 4 && (!memcmp(aContents, "\000\000\001\000", 4) ||
    1:                             !memcmp(aContents, "\000\000\002\000", 4))) {
    1:     aContentType.AssignLiteral("image/x-icon");
    1:   }
    1: 
    1:   else {
    1:     /* none of the above?  I give up */
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * proxy stream listener class used to handle multipart/x-mixed-replace
    1:  */
    1: 
    1: #include "nsIRequest.h"
    1: #include "nsIStreamConverterService.h"
    1: #include "nsXPIDLString.h"
    1: 
    1: NS_IMPL_ISUPPORTS2(ProxyListener, nsIStreamListener, nsIRequestObserver)
    1: 
    1: ProxyListener::ProxyListener(nsIStreamListener *dest) :
    1:   mDestListener(dest)
    1: {
    1:   /* member initializers and constructor code */
    1: }
    1: 
    1: ProxyListener::~ProxyListener()
    1: {
    1:   /* destructor code */
    1: }
    1: 
    1: 
    1: /** nsIRequestObserver methods **/
    1: 
    1: /* void onStartRequest (in nsIRequest request, in nsISupports ctxt); */
    1: NS_IMETHODIMP ProxyListener::OnStartRequest(nsIRequest *aRequest, nsISupports *ctxt)
    1: {
    1:   if (!mDestListener)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
    1:   if (channel) {
    1:     nsCAutoString contentType;
    1:     nsresult rv = channel->GetContentType(contentType);
    1: 
    1:     if (!contentType.IsEmpty()) {
    1:      /* If multipart/x-mixed-replace content, we'll insert a MIME decoder
    1:         in the pipeline to handle the content and pass it along to our
    1:         original listener.
    1:       */
    1:       if (NS_LITERAL_CSTRING("multipart/x-mixed-replace").Equals(contentType)) {
    1: 
    1:         nsCOMPtr<nsIStreamConverterService> convServ(do_GetService("@mozilla.org/streamConverters;1", &rv));
    1:         if (NS_SUCCEEDED(rv)) {
    1:           nsCOMPtr<nsIStreamListener> toListener(mDestListener);
    1:           nsCOMPtr<nsIStreamListener> fromListener;
    1: 
    1:           rv = convServ->AsyncConvertData("multipart/x-mixed-replace",
    1:                                           "*/*",
    1:                                           toListener,
    1:                                           nsnull,
    1:                                           getter_AddRefs(fromListener));
    1:           if (NS_SUCCEEDED(rv))
    1:             mDestListener = fromListener;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return mDestListener->OnStartRequest(aRequest, ctxt);
    1: }
    1: 
    1: /* void onStopRequest (in nsIRequest request, in nsISupports ctxt, in nsresult status); */
    1: NS_IMETHODIMP ProxyListener::OnStopRequest(nsIRequest *aRequest, nsISupports *ctxt, nsresult status)
    1: {
    1:   if (!mDestListener)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mDestListener->OnStopRequest(aRequest, ctxt, status);
    1: }
    1: 
    1: /** nsIStreamListener methods **/
    1: 
    1: /* void onDataAvailable (in nsIRequest request, in nsISupports ctxt, in nsIInputStream inStr, in unsigned long sourceOffset, in unsigned long count); */
    1: NS_IMETHODIMP ProxyListener::OnDataAvailable(nsIRequest *aRequest, nsISupports *ctxt, nsIInputStream *inStr, PRUint32 sourceOffset, PRUint32 count)
    1: {
    1:   if (!mDestListener)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mDestListener->OnDataAvailable(aRequest, ctxt, inStr, sourceOffset, count);
    1: }
    1: 
    1: /**
    1:  * http validate class.  check a channel for a 304
    1:  */
    1: 
    1: NS_IMPL_ISUPPORTS2(imgCacheValidator, nsIStreamListener, nsIRequestObserver)
    1: 
18827: imgLoader imgCacheValidator::sImgLoader;
18827: 
18801: imgCacheValidator::imgCacheValidator(imgRequest *request, void *aContext) :
18827:   mRequest(request),
18801:   mContext(aContext)
18827: {}
    1: 
    1: imgCacheValidator::~imgCacheValidator()
    1: {
    1:   if (mRequest) {
    1:     mRequest->mValidator = nsnull;
    1:   }
    1: }
    1: 
    1: void imgCacheValidator::AddProxy(imgRequestProxy *aProxy)
    1: {
    1:   // aProxy needs to be in the loadgroup since we're validating from
    1:   // the network.
    1:   aProxy->AddToLoadGroup();
    1: 
    1:   mProxies.AppendObject(aProxy);
    1: }
    1: 
    1: /** nsIRequestObserver methods **/
    1: 
    1: /* void onStartRequest (in nsIRequest request, in nsISupports ctxt); */
    1: NS_IMETHODIMP imgCacheValidator::OnStartRequest(nsIRequest *aRequest, nsISupports *ctxt)
    1: {
48320:   // If this request is coming from cache, the request all our proxies are
48320:   // pointing at is valid, and all we have to do is tell them to notify their
48320:   // listeners.
    1:   nsCOMPtr<nsICachingChannel> cacheChan(do_QueryInterface(aRequest));
    1:   if (cacheChan) {
    1:     PRBool isFromCache;
    1:     if (NS_SUCCEEDED(cacheChan->IsFromCache(&isFromCache)) && isFromCache) {
    1: 
    1:       PRUint32 count = mProxies.Count();
    1:       for (PRInt32 i = count-1; i>=0; i--) {
 3233:         imgRequestProxy *proxy = static_cast<imgRequestProxy *>(mProxies[i]);
48321: 
48936:         // Proxies waiting on cache validation should be deferring notifications.
48936:         // Undefer them.
48936:         NS_ABORT_IF_FALSE(proxy->NotificationsDeferred(),
48936:                           "Proxies waiting on cache validation should be "
48936:                           "deferring notifications!");
48936:         proxy->SetNotificationsDeferred(PR_FALSE);
48936: 
48321:         // Notify synchronously, because we're already in OnStartRequest, an
48321:         // asynchronously-called function.
48321:         proxy->SyncNotifyListener();
    1:       }
    1: 
    1:       mRequest->SetLoadId(mContext);
    1:       mRequest->mValidator = nsnull;
    1: 
18827:       mRequest = nsnull;
    1: 
    1:       return NS_OK;
    1:     }
    1:   }
18827: 
25078:   // We can't load out of cache. We have to create a whole new request for the
25078:   // data that's coming in off the channel.
    1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
18827:   nsRefPtr<imgCacheEntry> entry;
    1:   nsCOMPtr<nsIURI> uri;
    1: 
25078:   mRequest->GetURI(getter_AddRefs(uri));
25078: 
25078: #if defined(PR_LOGGING)
25078:   nsCAutoString spec;
25078:   uri->GetSpec(spec);
25078:   LOG_MSG_WITH_PARAM(gImgLog, "imgCacheValidator::OnStartRequest creating new request", "uri", spec.get());
25078: #endif
25078: 
    1:   // Doom the old request's cache entry
    1:   mRequest->RemoveFromCache();
    1: 
    1:   mRequest->mValidator = nsnull;
18827:   mRequest = nsnull;
    1: 
    1:   imgRequest *request;
    1: 
18827:   if (!NewRequestAndEntry(uri, &request, getter_AddRefs(entry)))
18827:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
23007:   // We use originalURI here to fulfil the imgIRequest contract on GetURI.
    1:   nsCOMPtr<nsIURI> originalURI;
    1:   channel->GetOriginalURI(getter_AddRefs(originalURI));
23036:   request->Init(originalURI, uri, channel, channel, entry, NS_GetCurrentThread(), mContext);
    1: 
 3233:   ProxyListener *pl = new ProxyListener(static_cast<nsIStreamListener *>(request));
    1:   if (!pl) {
25078:     request->CancelAndAbort(NS_ERROR_OUT_OF_MEMORY);
    1:     NS_RELEASE(request);
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
 3233:   mDestListener = static_cast<nsIStreamListener*>(pl);
    1: 
25078:   // Try to add the new request into the cache. Note that the entry must be in
25078:   // the cache before the proxies' ownership changes, because adding a proxy
25078:   // changes the caching behaviour for imgRequests.
26259:   sImgLoader.PutIntoCache(uri, entry);
25078: 
    1:   PRUint32 count = mProxies.Count();
    1:   for (PRInt32 i = count-1; i>=0; i--) {
 3233:     imgRequestProxy *proxy = static_cast<imgRequestProxy *>(mProxies[i]);
    1:     proxy->ChangeOwner(request);
48321: 
48936:     // Proxies waiting on cache validation should be deferring notifications.
48936:     // Undefer them.
48936:     NS_ABORT_IF_FALSE(proxy->NotificationsDeferred(),
48936:                       "Proxies waiting on cache validation should be "
48936:                       "deferring notifications!");
48936:     proxy->SetNotificationsDeferred(PR_FALSE);
48936: 
48321:     // Notify synchronously, because we're already in OnStartRequest, an
48321:     // asynchronously-called function.
48321:     proxy->SyncNotifyListener();
    1:   }
    1: 
    1:   NS_RELEASE(request);
    1: 
    1:   if (!mDestListener)
    1:     return NS_OK;
    1: 
    1:   return mDestListener->OnStartRequest(aRequest, ctxt);
    1: }
    1: 
    1: /* void onStopRequest (in nsIRequest request, in nsISupports ctxt, in nsresult status); */
    1: NS_IMETHODIMP imgCacheValidator::OnStopRequest(nsIRequest *aRequest, nsISupports *ctxt, nsresult status)
    1: {
    1:   if (!mDestListener)
    1:     return NS_OK;
    1: 
    1:   return mDestListener->OnStopRequest(aRequest, ctxt, status);
    1: }
    1: 
    1: /** nsIStreamListener methods **/
    1: 
    1: 
    1: // XXX see bug 113959
    1: static NS_METHOD dispose_of_data(nsIInputStream* in, void* closure,
    1:                                  const char* fromRawSegment, PRUint32 toOffset,
    1:                                  PRUint32 count, PRUint32 *writeCount)
    1: {
    1:   *writeCount = count;
    1:   return NS_OK;
    1: }
    1: 
    1: /* void onDataAvailable (in nsIRequest request, in nsISupports ctxt, in nsIInputStream inStr, in unsigned long sourceOffset, in unsigned long count); */
    1: NS_IMETHODIMP imgCacheValidator::OnDataAvailable(nsIRequest *aRequest, nsISupports *ctxt, nsIInputStream *inStr, PRUint32 sourceOffset, PRUint32 count)
    1: {
    1: #ifdef DEBUG
    1:   nsCOMPtr<nsICachingChannel> cacheChan(do_QueryInterface(aRequest));
    1:   if (cacheChan) {
    1:     PRBool isFromCache;
    1:     if (NS_SUCCEEDED(cacheChan->IsFromCache(&isFromCache)) && isFromCache)
    1:       NS_ERROR("OnDataAvailable not suppressed by LOAD_ONLY_IF_MODIFIED load flag");
    1:   }
    1: #endif
    1: 
    1:   if (!mDestListener) {
    1:     // XXX see bug 113959
    1:     PRUint32 _retval;
    1:     inStr->ReadSegments(dispose_of_data, nsnull, count, &_retval);
    1:     return NS_OK;
    1:   }
    1: 
    1:   return mDestListener->OnDataAvailable(aRequest, ctxt, inStr, sourceOffset, count);
    1: }
