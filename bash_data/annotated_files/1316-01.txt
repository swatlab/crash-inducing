   1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
   1:  * vim: set sw=4 ts=8 et tw=78:
   1:  *
   1:  * ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Mozilla Communicator client code, released
   1:  * March 31, 1998.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: /*
   1:  * JS bytecode descriptors, disassemblers, and decompilers.
   1:  */
   1: #include "jsstddef.h"
   1: #ifdef HAVE_MEMORY_H
   1: #include <memory.h>
   1: #endif
   1: #include <stdarg.h>
   1: #include <stdio.h>
   1: #include <stdlib.h>
   1: #include <string.h>
   1: #include "jstypes.h"
   1: #include "jsarena.h" /* Added by JSIFY */
   1: #include "jsutil.h" /* Added by JSIFY */
   1: #include "jsdtoa.h"
   1: #include "jsprf.h"
   1: #include "jsapi.h"
   1: #include "jsarray.h"
   1: #include "jsatom.h"
   1: #include "jscntxt.h"
   1: #include "jsconfig.h"
   1: #include "jsdbgapi.h"
   1: #include "jsemit.h"
   1: #include "jsfun.h"
   1: #include "jslock.h"
   1: #include "jsobj.h"
   1: #include "jsopcode.h"
   1: #include "jsregexp.h"
   1: #include "jsscan.h"
   1: #include "jsscope.h"
   1: #include "jsscript.h"
   1: #include "jsstr.h"
   1: 
   1: #if JS_HAS_DESTRUCTURING
   1: # include "jsnum.h"
   1: #endif
   1: 
   1: static const char js_incop_strs[][3] = {"++", "--"};
   1: 
1154: const JSCodeSpec js_CodeSpec[] = {
   1: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
1154:     {length,nuses,ndefs,prec,format},
   1: #include "jsopcode.tbl"
   1: #undef OPDEF
   1: };
   1: 
1154: uintN js_NumCodeSpecs = JS_ARRAY_LENGTH(js_CodeSpec);
1154: 
1154: /*
1154:  * Each element of the array is either a source literal associated with JS
1154:  * bytecode or null.
1154:  */
1154: static const char *CodeToken[] = {
1154: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
1154:     token,
1154: #include "jsopcode.tbl"
1154: #undef OPDEF
1154: };
1154: 
1154: #ifdef DEBUG
1154: /*
1154:  * Array of JS bytecode names used by DEBUG-only js_Disassemble.
1154:  */
1154: static const char *CodeName[] = {
1154: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
1154:     name,
1154: #include "jsopcode.tbl"
1154: #undef OPDEF
1154: };
1154: #endif
   1: 
   1: /************************************************************************/
   1: 
   1: static ptrdiff_t
   1: GetJumpOffset(jsbytecode *pc, jsbytecode *pc2)
   1: {
   1:     uint32 type;
   1: 
   1:     type = (js_CodeSpec[*pc].format & JOF_TYPEMASK);
   1:     if (JOF_TYPE_IS_EXTENDED_JUMP(type))
   1:         return GET_JUMPX_OFFSET(pc2);
   1:     return GET_JUMP_OFFSET(pc2);
   1: }
   1: 
   1: JSAtom *
   1: js_GetAtomFromBytecode(JSScript *script, jsbytecode *pc, ptrdiff_t pcoff)
   1: {
   1:     JSOp op;
   1:     uintN span, atomBase;
   1: 
   1:     op = (JSOp)*pc;
   1:     JS_ASSERT(js_CodeSpec[op].length >= 1 + pcoff + ATOM_INDEX_LEN);
   1: 
   1:     /*
   1:      * We need to detect atom base prefix. It presents when resetbase
   1:      * follows the bytecode.
   1:      */
   1:     span = js_CodeSpec[op].length;
   1:     atomBase = 0;
   1:     if (pc - script->code + span < script->length) {
   1:         if (pc[span] == JSOP_RESETBASE) {
   1:             atomBase = GET_ATOMBASE(pc - JSOP_ATOMBASE_LENGTH);
   1:         } else if (pc[span] == JSOP_RESETBASE0) {
   1:             JS_ASSERT(JSOP_ATOMBASE1 <= pc[-1] || pc[-1] <= JSOP_ATOMBASE3);
   1:             atomBase = (pc[-1] - JSOP_ATOMBASE1 + 1) << 16;
   1:         }
   1:     }
   1:     JS_ASSERT(atomBase < script->atomMap.length);
   1:     return GET_ATOM(script, script->atomMap.vector + atomBase, pc + pcoff);
   1: }
   1: 
   1: #ifdef DEBUG
   1: 
   1: JS_FRIEND_API(JSBool)
   1: js_Disassemble(JSContext *cx, JSScript *script, JSBool lines, FILE *fp)
   1: {
   1:     jsbytecode *pc, *end;
   1:     uintN len;
   1: 
   1:     pc = script->code;
   1:     end = pc + script->length;
   1:     while (pc < end) {
   1:         if (pc == script->main)
   1:             fputs("main:\n", fp);
   1:         len = js_Disassemble1(cx, script, pc,
   1:                               PTRDIFF(pc, script->code, jsbytecode),
   1:                               lines, fp);
   1:         if (!len)
   1:             return JS_FALSE;
   1:         pc += len;
   1:     }
   1:     return JS_TRUE;
   1: }
   1: 
   1: const char *
   1: ToDisassemblySource(JSContext *cx, jsval v)
   1: {
   1:     JSObject *obj;
   1:     JSScopeProperty *sprop;
   1:     char *source;
   1:     const char *bytes;
   1:     JSString *str;
   1: 
   1:     if (!JSVAL_IS_PRIMITIVE(v)) {
   1:         obj = JSVAL_TO_OBJECT(v);
   1:         if (OBJ_GET_CLASS(cx, obj) == &js_BlockClass) {
   1:             source = JS_sprintf_append(NULL, "depth %d {",
   1:                                        OBJ_BLOCK_DEPTH(cx, obj));
   1:             for (sprop = OBJ_SCOPE(obj)->lastProp; sprop;
   1:                  sprop = sprop->parent) {
   1:                 bytes = js_AtomToPrintableString(cx, JSID_TO_ATOM(sprop->id));
   1:                 if (!bytes)
   1:                     return NULL;
   1:                 source = JS_sprintf_append(source, "%s: %d%s",
   1:                                            bytes, sprop->shortid,
   1:                                            sprop->parent ? ", " : "");
   1:             }
   1:             source = JS_sprintf_append(source, "}");
   1:             if (!source)
   1:                 return NULL;
   1:             str = JS_NewString(cx, source, strlen(source));
   1:             if (!str)
   1:                 return NULL;
   1:             return js_GetStringBytes(cx, str);
   1:         }
   1:     }
   1:     return js_ValueToPrintableSource(cx, v);
   1: }
   1: 
   1: JS_FRIEND_API(uintN)
   1: js_Disassemble1(JSContext *cx, JSScript *script, jsbytecode *pc,
   1:                 uintN loc, JSBool lines, FILE *fp)
   1: {
   1:     JSOp op;
   1:     const JSCodeSpec *cs;
   1:     ptrdiff_t len, off, jmplen;
   1:     uint32 type;
   1:     JSAtom *atom;
   1:     const char *bytes;
   1: 
   1:     op = (JSOp)*pc;
   1:     if (op >= JSOP_LIMIT) {
   1:         char numBuf1[12], numBuf2[12];
   1:         JS_snprintf(numBuf1, sizeof numBuf1, "%d", op);
   1:         JS_snprintf(numBuf2, sizeof numBuf2, "%d", JSOP_LIMIT);
   1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
   1:                              JSMSG_BYTECODE_TOO_BIG, numBuf1, numBuf2);
   1:         return 0;
   1:     }
   1:     cs = &js_CodeSpec[op];
   1:     len = (ptrdiff_t) cs->length;
   1:     fprintf(fp, "%05u:", loc);
   1:     if (lines)
   1:         fprintf(fp, "%4u", JS_PCToLineNumber(cx, script, pc));
1154:     fprintf(fp, "  %s", CodeName[op]);
   1:     type = cs->format & JOF_TYPEMASK;
   1:     switch (type) {
   1:       case JOF_BYTE:
   1:         if (op == JSOP_TRAP) {
   1:             op = JS_GetTrapOpcode(cx, script, pc);
   1:             if (op == JSOP_LIMIT)
   1:                 return 0;
   1:             len = (ptrdiff_t) js_CodeSpec[op].length;
   1:         }
   1:         break;
   1: 
   1:       case JOF_JUMP:
   1:       case JOF_JUMPX:
   1:         off = GetJumpOffset(pc, pc);
   1:         fprintf(fp, " %u (%d)", loc + off, off);
   1:         break;
   1: 
   1:       case JOF_CONST:
   1:         atom = js_GetAtomFromBytecode(script, pc, 0);
   1:         bytes = ToDisassemblySource(cx, ATOM_KEY(atom));
   1:         if (!bytes)
   1:             return 0;
   1:         fprintf(fp, " %s", bytes);
   1:         break;
   1: 
   1:       case JOF_UINT16:
   1:       case JOF_LOCAL:
   1:         fprintf(fp, " %u", GET_UINT16(pc));
   1:         break;
   1: 
   1:       case JOF_2BYTE:
   1:         fprintf(fp, " %u", (uintN)pc[1]);
   1:         break;
   1: 
   1:       case JOF_TABLESWITCH:
   1:       case JOF_TABLESWITCHX:
   1:       {
   1:         jsbytecode *pc2;
   1:         jsint i, low, high;
   1: 
   1:         jmplen = (type == JOF_TABLESWITCH) ? JUMP_OFFSET_LEN
   1:                                            : JUMPX_OFFSET_LEN;
   1:         pc2 = pc;
   1:         off = GetJumpOffset(pc, pc2);
   1:         pc2 += jmplen;
   1:         low = GET_JUMP_OFFSET(pc2);
   1:         pc2 += JUMP_OFFSET_LEN;
   1:         high = GET_JUMP_OFFSET(pc2);
   1:         pc2 += JUMP_OFFSET_LEN;
   1:         fprintf(fp, " defaultOffset %d low %d high %d", off, low, high);
   1:         for (i = low; i <= high; i++) {
   1:             off = GetJumpOffset(pc, pc2);
   1:             fprintf(fp, "\n\t%d: %d", i, off);
   1:             pc2 += jmplen;
   1:         }
   1:         len = 1 + pc2 - pc;
   1:         break;
   1:       }
   1: 
   1:       case JOF_LOOKUPSWITCH:
   1:       case JOF_LOOKUPSWITCHX:
   1:       {
   1:         jsbytecode *pc2;
   1:         jsatomid npairs;
   1: 
   1:         jmplen = (type == JOF_LOOKUPSWITCH) ? JUMP_OFFSET_LEN
   1:                                             : JUMPX_OFFSET_LEN;
   1:         pc2 = pc;
   1:         off = GetJumpOffset(pc, pc2);
   1:         pc2 += jmplen;
   1:         npairs = GET_UINT16(pc2);
   1:         pc2 += UINT16_LEN;
   1:         fprintf(fp, " offset %d npairs %u", off, (uintN) npairs);
   1:         while (npairs) {
   1:             atom = GET_ATOM(script, script->atomMap.vector, pc2);
   1:             pc2 += ATOM_INDEX_LEN;
   1:             off = GetJumpOffset(pc, pc2);
   1:             pc2 += jmplen;
   1: 
   1:             bytes = ToDisassemblySource(cx, ATOM_KEY(atom));
   1:             if (!bytes)
   1:                 return 0;
   1:             fprintf(fp, "\n\t%s: %d", bytes, off);
   1:             npairs--;
   1:         }
   1:         len = 1 + pc2 - pc;
   1:         break;
   1:       }
   1: 
   1:       case JOF_QARG:
   1:         fprintf(fp, " %u", GET_ARGNO(pc));
   1:         break;
   1: 
   1:       case JOF_QVAR:
   1:         fprintf(fp, " %u", GET_VARNO(pc));
   1:         break;
   1: 
   1:       case JOF_INDEXCONST:
   1:         fprintf(fp, " %u", GET_VARNO(pc));
   1:         atom = js_GetAtomFromBytecode(script, pc, VARNO_LEN);
   1:         bytes = ToDisassemblySource(cx, ATOM_KEY(atom));
   1:         if (!bytes)
   1:             return 0;
   1:         fprintf(fp, " %s", bytes);
   1:         break;
   1: 
   1:       case JOF_UINT24:
   1:         JS_ASSERT(op == JSOP_UINT24);
   1:         fprintf(fp, " %u", GET_UINT24(pc));
   1:         break;
   1: 
   1:       default: {
   1:         char numBuf[12];
   1:         JS_snprintf(numBuf, sizeof numBuf, "%lx", (unsigned long) cs->format);
   1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
   1:                              JSMSG_UNKNOWN_FORMAT, numBuf);
   1:         return 0;
   1:       }
   1:     }
   1:     fputs("\n", fp);
   1:     return len;
   1: }
   1: 
   1: #endif /* DEBUG */
   1: 
   1: /************************************************************************/
   1: 
   1: /*
   1:  * Sprintf, but with unlimited and automatically allocated buffering.
   1:  */
   1: typedef struct Sprinter {
   1:     JSContext       *context;       /* context executing the decompiler */
   1:     JSArenaPool     *pool;          /* string allocation pool */
   1:     char            *base;          /* base address of buffer in pool */
   1:     size_t          size;           /* size of buffer allocated at base */
   1:     ptrdiff_t       offset;         /* offset of next free char in buffer */
   1: } Sprinter;
   1: 
   1: #define INIT_SPRINTER(cx, sp, ap, off) \
   1:     ((sp)->context = cx, (sp)->pool = ap, (sp)->base = NULL, (sp)->size = 0,  \
   1:      (sp)->offset = off)
   1: 
   1: #define OFF2STR(sp,off) ((sp)->base + (off))
   1: #define STR2OFF(sp,str) ((str) - (sp)->base)
   1: #define RETRACT(sp,str) ((sp)->offset = STR2OFF(sp, str))
   1: 
   1: static JSBool
   1: SprintAlloc(Sprinter *sp, size_t nb)
   1: {
   1:     if (!sp->base) {
   1:         JS_ARENA_ALLOCATE_CAST(sp->base, char *, sp->pool, nb);
   1:     } else {
   1:         JS_ARENA_GROW_CAST(sp->base, char *, sp->pool, sp->size, nb);
   1:     }
   1:     if (!sp->base) {
   1:         JS_ReportOutOfMemory(sp->context);
   1:         return JS_FALSE;
   1:     }
   1:     sp->size += nb;
   1:     return JS_TRUE;
   1: }
   1: 
   1: static ptrdiff_t
   1: SprintPut(Sprinter *sp, const char *s, size_t len)
   1: {
   1:     ptrdiff_t nb, offset;
   1:     char *bp;
   1: 
   1:     /* Allocate space for s, including the '\0' at the end. */
   1:     nb = (sp->offset + len + 1) - sp->size;
   1:     if (nb > 0 && !SprintAlloc(sp, nb))
   1:         return -1;
   1: 
   1:     /* Advance offset and copy s into sp's buffer. */
   1:     offset = sp->offset;
   1:     sp->offset += len;
   1:     bp = sp->base + offset;
   1:     memmove(bp, s, len);
   1:     bp[len] = 0;
   1:     return offset;
   1: }
   1: 
   1: static ptrdiff_t
   1: SprintCString(Sprinter *sp, const char *s)
   1: {
   1:     return SprintPut(sp, s, strlen(s));
   1: }
   1: 
   1: static ptrdiff_t
   1: SprintString(Sprinter *sp, JSString *str)
   1: {
   1:     jschar *chars;
   1:     size_t length, size;
   1:     ptrdiff_t offset;
   1: 
   1:     chars = JSSTRING_CHARS(str);
   1:     length = JSSTRING_LENGTH(str);
   1:     if (length == 0)
   1:         return sp->offset;
   1: 
   1:     size = js_GetDeflatedStringLength(sp->context, chars, length);
   1:     if (size == (size_t)-1 || !SprintAlloc(sp, size + 1))
   1:         return -1;
   1: 
   1:     offset = sp->offset;
   1:     sp->offset += size;
   1:     js_DeflateStringToBuffer(sp->context, chars, length, sp->base + offset,
   1:                              &size);
   1:     sp->base[sp->offset] = 0;
   1:     return offset;
   1: }
   1: 
   1: 
   1: static ptrdiff_t
   1: Sprint(Sprinter *sp, const char *format, ...)
   1: {
   1:     va_list ap;
   1:     char *bp;
   1:     ptrdiff_t offset;
   1: 
   1:     va_start(ap, format);
   1:     bp = JS_vsmprintf(format, ap);      /* XXX vsaprintf */
   1:     va_end(ap);
   1:     if (!bp) {
   1:         JS_ReportOutOfMemory(sp->context);
   1:         return -1;
   1:     }
   1:     offset = SprintCString(sp, bp);
   1:     free(bp);
   1:     return offset;
   1: }
   1: 
   1: const char js_EscapeMap[] = {
   1:     '\b', 'b',
   1:     '\f', 'f',
   1:     '\n', 'n',
   1:     '\r', 'r',
   1:     '\t', 't',
   1:     '\v', 'v',
   1:     '"',  '"',
   1:     '\'', '\'',
   1:     '\\', '\\',
   1:     0
   1: };
   1: 
   1: #define DONT_ESCAPE     0x10000
   1: 
   1: static char *
   1: QuoteString(Sprinter *sp, JSString *str, uint32 quote)
   1: {
   1:     JSBool dontEscape, ok;
   1:     jschar qc, c;
   1:     ptrdiff_t off, len, nb;
   1:     const jschar *s, *t, *z;
   1:     const char *e;
   1:     char *bp;
   1: 
   1:     /* Sample off first for later return value pointer computation. */
   1:     dontEscape = (quote & DONT_ESCAPE) != 0;
   1:     qc = (jschar) quote;
   1:     off = sp->offset;
   1:     if (qc && Sprint(sp, "%c", (char)qc) < 0)
   1:         return NULL;
   1: 
   1:     /* Loop control variables: z points at end of string sentinel. */
   1:     s = JSSTRING_CHARS(str);
   1:     z = s + JSSTRING_LENGTH(str);
   1:     for (t = s; t < z; s = ++t) {
   1:         /* Move t forward from s past un-quote-worthy characters. */
   1:         c = *t;
   1:         while (JS_ISPRINT(c) && c != qc && c != '\\' && !(c >> 8)) {
   1:             c = *++t;
   1:             if (t == z)
   1:                 break;
   1:         }
   1:         len = PTRDIFF(t, s, jschar);
   1: 
   1:         /* Allocate space for s, including the '\0' at the end. */
   1:         nb = (sp->offset + len + 1) - sp->size;
   1:         if (nb > 0 && !SprintAlloc(sp, nb))
   1:             return NULL;
   1: 
   1:         /* Advance sp->offset and copy s into sp's buffer. */
   1:         bp = sp->base + sp->offset;
   1:         sp->offset += len;
   1:         while (--len >= 0)
   1:             *bp++ = (char) *s++;
   1:         *bp = '\0';
   1: 
   1:         if (t == z)
   1:             break;
   1: 
   1:         /* Use js_EscapeMap, \u, or \x only if necessary. */
   1:         if (!(c >> 8) && (e = strchr(js_EscapeMap, (int)c)) != NULL) {
   1:             ok = dontEscape
   1:                  ? Sprint(sp, "%c", (char)c) >= 0
   1:                  : Sprint(sp, "\\%c", e[1]) >= 0;
   1:         } else {
   1: #ifdef JS_C_STRINGS_ARE_UTF8
   1:             /* If this is a surrogate pair, make sure to print the pair. */
   1:             if (c >= 0xD800 && c <= 0xDBFF) {
   1:                 jschar buffer[3];
   1:                 buffer[0] = c;
   1:                 buffer[1] = *++t;
   1:                 buffer[2] = 0;
   1:                 if (t == z) {
   1:                     char numbuf[10];
   1:                     JS_snprintf(numbuf, sizeof numbuf, "0x%x", c);
 121:                     JS_ReportErrorFlagsAndNumber(sp->context, JSREPORT_ERROR,
   1:                                                  js_GetErrorMessage, NULL,
   1:                                                  JSMSG_BAD_SURROGATE_CHAR,
   1:                                                  numbuf);
   1:                     ok = JS_FALSE;
   1:                     break;
   1:                 }
   1:                 ok = Sprint(sp, "%hs", buffer) >= 0;
   1:             } else {
   1:                 /* Print as UTF-8 string. */
   1:                 ok = Sprint(sp, "%hc", c) >= 0;
   1:             }
   1: #else
   1:             /* Use \uXXXX or \xXX  if the string can't be displayed as UTF-8. */
   1:             ok = Sprint(sp, (c >> 8) ? "\\u%04X" : "\\x%02X", c) >= 0;
   1: #endif
   1:         }
   1:         if (!ok)
   1:             return NULL;
   1:     }
   1: 
   1:     /* Sprint the closing quote and return the quoted string. */
   1:     if (qc && Sprint(sp, "%c", (char)qc) < 0)
   1:         return NULL;
   1: 
   1:     /*
   1:      * If we haven't Sprint'd anything yet, Sprint an empty string so that
   1:      * the OFF2STR below gives a valid result.
   1:      */
   1:     if (off == sp->offset && Sprint(sp, "") < 0)
   1:         return NULL;
   1:     return OFF2STR(sp, off);
   1: }
   1: 
   1: JSString *
   1: js_QuoteString(JSContext *cx, JSString *str, jschar quote)
   1: {
   1:     void *mark;
   1:     Sprinter sprinter;
   1:     char *bytes;
   1:     JSString *escstr;
   1: 
   1:     mark = JS_ARENA_MARK(&cx->tempPool);
   1:     INIT_SPRINTER(cx, &sprinter, &cx->tempPool, 0);
   1:     bytes = QuoteString(&sprinter, str, quote);
   1:     escstr = bytes ? JS_NewStringCopyZ(cx, bytes) : NULL;
   1:     JS_ARENA_RELEASE(&cx->tempPool, mark);
   1:     return escstr;
   1: }
   1: 
   1: /************************************************************************/
   1: 
   1: #if JS_HAS_BLOCK_SCOPE
   1: typedef enum JSBraceState {
   1:     ALWAYS_BRACE,
   1:     MAYBE_BRACE,
   1:     DONT_BRACE
   1: } JSBraceState;
   1: #endif
   1: 
   1: struct JSPrinter {
   1:     Sprinter        sprinter;       /* base class state */
   1:     JSArenaPool     pool;           /* string allocation pool */
   1:     uintN           indent;         /* indentation in spaces */
   1:     JSPackedBool    pretty;         /* pretty-print: indent, use newlines */
   1:     JSPackedBool    grouped;        /* in parenthesized expression context */
   1:     JSScript        *script;        /* script being printed */
   1:     jsbytecode      *dvgfence;      /* js_DecompileValueGenerator fencepost */
   1:     JSScope         *scope;         /* script function scope */
   1: #if JS_HAS_BLOCK_SCOPE
   1:     JSBraceState    braceState;     /* remove braces around let declaration */
   1:     ptrdiff_t       spaceOffset;    /* -1 or offset of space before maybe-{ */
   1: #endif
   1: };
   1: 
   1: /*
   1:  * Hack another flag, a la JS_DONT_PRETTY_PRINT, into uintN indent parameters
   1:  * to functions such as js_DecompileFunction and js_NewPrinter.  This time, as
   1:  * opposed to JS_DONT_PRETTY_PRINT back in the dark ages, we can assume that a
   1:  * uintN is at least 32 bits.
   1:  */
   1: #define JS_IN_GROUP_CONTEXT 0x10000
   1: 
   1: JSPrinter *
 437: JS_NEW_PRINTER(JSContext *cx, const char *name, uintN indent, JSBool pretty)
   1: {
   1:     JSPrinter *jp;
   1: 
   1:     jp = (JSPrinter *) JS_malloc(cx, sizeof(JSPrinter));
   1:     if (!jp)
   1:         return NULL;
   1:     INIT_SPRINTER(cx, &jp->sprinter, &jp->pool, 0);
 437:     JS_INIT_ARENA_POOL(&jp->pool, name, 256, 1);
   1:     jp->indent = indent & ~JS_IN_GROUP_CONTEXT;
   1:     jp->pretty = pretty;
   1:     jp->grouped = (indent & JS_IN_GROUP_CONTEXT) != 0;
   1:     jp->script = NULL;
   1:     jp->dvgfence = NULL;
   1:     jp->scope = NULL;
   1: #if JS_HAS_BLOCK_SCOPE
   1:     jp->braceState = ALWAYS_BRACE;
   1:     jp->spaceOffset = -1;
   1: #endif
   1:     return jp;
   1: }
   1: 
   1: void
   1: js_DestroyPrinter(JSPrinter *jp)
   1: {
   1:     JS_FinishArenaPool(&jp->pool);
   1:     JS_free(jp->sprinter.context, jp);
   1: }
   1: 
   1: JSString *
   1: js_GetPrinterOutput(JSPrinter *jp)
   1: {
   1:     JSContext *cx;
   1:     JSString *str;
   1: 
   1:     cx = jp->sprinter.context;
   1:     if (!jp->sprinter.base)
   1:         return cx->runtime->emptyString;
   1:     str = JS_NewStringCopyZ(cx, jp->sprinter.base);
   1:     if (!str)
   1:         return NULL;
   1:     JS_FreeArenaPool(&jp->pool);
   1:     INIT_SPRINTER(cx, &jp->sprinter, &jp->pool, 0);
   1:     return str;
   1: }
   1: 
   1: #if !JS_HAS_BLOCK_SCOPE
   1: # define SET_MAYBE_BRACE(jp)    jp
   1: # define CLEAR_MAYBE_BRACE(jp)  jp
   1: #else
   1: # define SET_MAYBE_BRACE(jp)    ((jp)->braceState = MAYBE_BRACE, (jp))
   1: # define CLEAR_MAYBE_BRACE(jp)  ((jp)->braceState = ALWAYS_BRACE, (jp))
   1: 
   1: static void
   1: SetDontBrace(JSPrinter *jp)
   1: {
   1:     ptrdiff_t offset;
   1:     const char *bp;
   1: 
   1:     /* When not pretty-printing, newline after brace is chopped. */
   1:     JS_ASSERT(jp->spaceOffset < 0);
   1:     offset = jp->sprinter.offset - (jp->pretty ? 3 : 2);
   1: 
   1:     /* The shortest case is "if (x) {". */
   1:     JS_ASSERT(offset >= 6);
   1:     bp = jp->sprinter.base;
   1:     if (bp[offset+0] == ' ' && bp[offset+1] == '{') {
   1:         JS_ASSERT(!jp->pretty || bp[offset+2] == '\n');
   1:         jp->spaceOffset = offset;
   1:         jp->braceState = DONT_BRACE;
   1:     }
   1: }
   1: #endif
   1: 
   1: int
   1: js_printf(JSPrinter *jp, const char *format, ...)
   1: {
   1:     va_list ap;
   1:     char *bp, *fp;
   1:     int cc;
   1: 
   1:     if (*format == '\0')
   1:         return 0;
   1: 
   1:     va_start(ap, format);
   1: 
   1:     /* If pretty-printing, expand magic tab into a run of jp->indent spaces. */
   1:     if (*format == '\t') {
   1:         format++;
   1: 
   1: #if JS_HAS_BLOCK_SCOPE
   1:         if (*format == '}' && jp->braceState != ALWAYS_BRACE) {
   1:             JSBraceState braceState;
   1: 
   1:             braceState = jp->braceState;
   1:             jp->braceState = ALWAYS_BRACE;
   1:             if (braceState == DONT_BRACE) {
   1:                 ptrdiff_t offset, delta, from;
   1: 
   1:                 JS_ASSERT(format[1] == '\n' || format[1] == ' ');
   1:                 offset = jp->spaceOffset;
   1:                 JS_ASSERT(offset >= 6);
   1: 
   1:                 /* Replace " {\n" at the end of jp->sprinter with "\n". */
   1:                 bp = jp->sprinter.base;
   1:                 if (bp[offset+0] == ' ' && bp[offset+1] == '{') {
   1:                     delta = 2;
   1:                     if (jp->pretty) {
   1:                         /* If pretty, we don't have to worry about 'else'. */
   1:                         JS_ASSERT(bp[offset+2] == '\n');
   1:                     } else if (bp[offset-1] != ')') {
   1:                         /* Must keep ' ' to avoid 'dolet' or 'elselet'. */
   1:                         ++offset;
   1:                         delta = 1;
   1:                     }
   1: 
   1:                     from = offset + delta;
   1:                     memmove(bp + offset, bp + from, jp->sprinter.offset - from);
   1:                     jp->sprinter.offset -= delta;
   1:                     jp->spaceOffset = -1;
   1: 
   1:                     format += 2;
   1:                     if (*format == '\0')
   1:                         return 0;
   1:                 }
   1:             }
   1:         }
   1: #endif
   1: 
   1:         if (jp->pretty && Sprint(&jp->sprinter, "%*s", jp->indent, "") < 0)
   1:             return -1;
   1:     }
   1: 
   1:     /* Suppress newlines (must be once per format, at the end) if not pretty. */
   1:     fp = NULL;
   1:     if (!jp->pretty && format[cc = strlen(format) - 1] == '\n') {
   1:         fp = JS_strdup(jp->sprinter.context, format);
   1:         if (!fp)
   1:             return -1;
   1:         fp[cc] = '\0';
   1:         format = fp;
   1:     }
   1: 
   1:     /* Allocate temp space, convert format, and put. */
   1:     bp = JS_vsmprintf(format, ap);      /* XXX vsaprintf */
   1:     if (fp) {
   1:         JS_free(jp->sprinter.context, fp);
   1:         format = NULL;
   1:     }
   1:     if (!bp) {
   1:         JS_ReportOutOfMemory(jp->sprinter.context);
   1:         return -1;
   1:     }
   1: 
   1:     cc = strlen(bp);
   1:     if (SprintPut(&jp->sprinter, bp, (size_t)cc) < 0)
   1:         cc = -1;
   1:     free(bp);
   1: 
   1:     va_end(ap);
   1:     return cc;
   1: }
   1: 
   1: JSBool
   1: js_puts(JSPrinter *jp, const char *s)
   1: {
   1:     return SprintCString(&jp->sprinter, s) >= 0;
   1: }
   1: 
   1: /************************************************************************/
   1: 
   1: typedef struct SprintStack {
   1:     Sprinter    sprinter;       /* sprinter for postfix to infix buffering */
   1:     ptrdiff_t   *offsets;       /* stack of postfix string offsets */
   1:     jsbytecode  *opcodes;       /* parallel stack of JS opcodes */
   1:     uintN       top;            /* top of stack index */
   1:     uintN       inArrayInit;    /* array initialiser/comprehension level */
   1:     JSPrinter   *printer;       /* permanent output goes here */
   1: } SprintStack;
   1: 
   1: /*
   1:  * Get a stacked offset from ss->sprinter.base, or if the stacked value |off|
   1:  * is negative, lazily fetch the generating pc at |spindex = 1 + off| and try
   1:  * to decompile the code that generated the missing value.  This is used when
   1:  * reporting errors, where the model stack will lack |pcdepth| non-negative
   1:  * offsets (see js_DecompileValueGenerator and js_DecompileCode).
   1:  *
   1:  * If the stacked offset is -1, return 0 to index the NUL padding at the start
   1:  * of ss->sprinter.base.  If this happens, it means there is a decompiler bug
   1:  * to fix, but it won't violate memory safety.
   1:  */
   1: static ptrdiff_t
   1: GetOff(SprintStack *ss, uintN i)
   1: {
   1:     ptrdiff_t off;
   1:     char *bytes;
   1: 
   1:     off = ss->offsets[i];
   1:     if (off < 0) {
   1: #if defined DEBUG_brendan || defined DEBUG_mrbkap || defined DEBUG_crowder
   1:         JS_ASSERT(off < -1);
   1: #endif
   1:         if (++off == 0) {
   1:             if (!ss->sprinter.base && SprintPut(&ss->sprinter, "", 0) >= 0)
   1:                 memset(ss->sprinter.base, 0, ss->sprinter.offset);
   1:             return 0;
   1:         }
   1: 
   1:         bytes = js_DecompileValueGenerator(ss->sprinter.context, off,
   1:                                            JSVAL_NULL, NULL);
   1:         if (!bytes)
   1:             return 0;
   1:         off = SprintCString(&ss->sprinter, bytes);
   1:         if (off < 0)
   1:             off = 0;
   1:         ss->offsets[i] = off;
   1:         JS_free(ss->sprinter.context, bytes);
   1:     }
   1:     return off;
   1: }
   1: 
   1: static const char *
   1: GetStr(SprintStack *ss, uintN i)
   1: {
   1:     ptrdiff_t off;
   1: 
   1:     /*
   1:      * Must call GetOff before using ss->sprinter.base, since it may be null
   1:      * until bootstrapped by GetOff.
   1:      */
   1:     off = GetOff(ss, i);
   1:     return OFF2STR(&ss->sprinter, off);
   1: }
   1: 
   1: /* Gap between stacked strings to allow for insertion of parens and commas. */
   1: #define PAREN_SLOP      (2 + 1)
   1: 
   1: /*
   1:  * These pseudo-ops help js_DecompileValueGenerator decompile JSOP_SETNAME,
   1:  * JSOP_SETPROP, and JSOP_SETELEM, respectively.  They are never stored in
   1:  * bytecode, so they don't preempt valid opcodes.
   1:  */
   1: #define JSOP_GETPROP2   256
   1: #define JSOP_GETELEM2   257
   1: 
   1: static JSBool
   1: PushOff(SprintStack *ss, ptrdiff_t off, JSOp op)
   1: {
   1:     uintN top;
   1: 
   1:     if (!SprintAlloc(&ss->sprinter, PAREN_SLOP))
   1:         return JS_FALSE;
   1: 
   1:     /* ss->top points to the next free slot; be paranoid about overflow. */
   1:     top = ss->top;
   1:     JS_ASSERT(top < ss->printer->script->depth);
   1:     if (top >= ss->printer->script->depth) {
   1:         JS_ReportOutOfMemory(ss->sprinter.context);
   1:         return JS_FALSE;
   1:     }
   1: 
   1:     /* The opcodes stack must contain real bytecodes that index js_CodeSpec. */
   1:     ss->offsets[top] = off;
   1:     ss->opcodes[top] = (op == JSOP_GETPROP2) ? JSOP_GETPROP
   1:                      : (op == JSOP_GETELEM2) ? JSOP_GETELEM
   1:                      : (jsbytecode) op;
   1:     ss->top = ++top;
   1:     memset(OFF2STR(&ss->sprinter, ss->sprinter.offset), 0, PAREN_SLOP);
   1:     ss->sprinter.offset += PAREN_SLOP;
   1:     return JS_TRUE;
   1: }
   1: 
   1: static ptrdiff_t
   1: PopOff(SprintStack *ss, JSOp op)
   1: {
   1:     uintN top;
   1:     const JSCodeSpec *cs, *topcs;
   1:     ptrdiff_t off;
   1: 
   1:     /* ss->top points to the next free slot; be paranoid about underflow. */
   1:     top = ss->top;
   1:     JS_ASSERT(top != 0);
   1:     if (top == 0)
   1:         return 0;
   1: 
   1:     ss->top = --top;
   1:     off = GetOff(ss, top);
   1:     topcs = &js_CodeSpec[ss->opcodes[top]];
   1:     cs = &js_CodeSpec[op];
   1:     if (topcs->prec != 0 && topcs->prec < cs->prec) {
   1:         ss->sprinter.offset = ss->offsets[top] = off - 2;
   1:         off = Sprint(&ss->sprinter, "(%s)", OFF2STR(&ss->sprinter, off));
   1:     } else {
   1:         ss->sprinter.offset = off;
   1:     }
   1:     return off;
   1: }
   1: 
   1: static const char *
   1: PopStr(SprintStack *ss, JSOp op)
   1: {
   1:     ptrdiff_t off;
   1: 
   1:     off = PopOff(ss, op);
   1:     return OFF2STR(&ss->sprinter, off);
   1: }
   1: 
   1: typedef struct TableEntry {
   1:     jsval       key;
   1:     ptrdiff_t   offset;
   1:     JSAtom      *label;
   1:     jsint       order;          /* source order for stable tableswitch sort */
   1: } TableEntry;
   1: 
   1: static JSBool
   1: CompareOffsets(void *arg, const void *v1, const void *v2, int *result)
   1: {
   1:     ptrdiff_t offset_diff;
   1:     const TableEntry *te1 = (const TableEntry *) v1,
   1:                      *te2 = (const TableEntry *) v2;
   1: 
   1:     offset_diff = te1->offset - te2->offset;
   1:     *result = (offset_diff == 0 ? te1->order - te2->order
   1:                : offset_diff < 0 ? -1
   1:                : 1);
   1:     return JS_TRUE;
   1: }
   1: 
 259: static ptrdiff_t
 259: SprintDoubleValue(Sprinter *sp, jsval v, JSOp *opp)
 259: {
 259:     jsdouble d;
 259:     ptrdiff_t todo;
 259:     char *s, buf[DTOSTR_STANDARD_BUFFER_SIZE];
 259: 
 259:     JS_ASSERT(JSVAL_IS_DOUBLE(v));
 259:     d = *JSVAL_TO_DOUBLE(v);
 259:     if (JSDOUBLE_IS_NEGZERO(d)) {
 259:         todo = SprintCString(sp, "-0");
 259:         *opp = JSOP_NEG;
 259:     } else if (!JSDOUBLE_IS_FINITE(d)) {
 259:         /* Don't use Infinity and NaN, they're mutable. */
 259:         todo = SprintCString(sp,
 259:                              JSDOUBLE_IS_NaN(d)
 259:                              ? "0 / 0"
 259:                              : (d < 0)
 259:                              ? "1 / -0"
 259:                              : "1 / 0");
 259:         *opp = JSOP_DIV;
 259:     } else {
 259:         s = JS_dtostr(buf, sizeof buf, DTOSTR_STANDARD, 0, d);
 259:         if (!s) {
 259:             JS_ReportOutOfMemory(sp->context);
 259:             return -1;
 259:         }
 259:         JS_ASSERT(strcmp(s, js_Infinity_str) &&
 259:                   (*s != '-' ||
 259:                    strcmp(s + 1, js_Infinity_str)) &&
 259:                   strcmp(s, js_NaN_str));
 259:         todo = Sprint(sp, s);
 259:     }
 259:     return todo;
 259: }
 259: 
   1: static jsbytecode *
   1: Decompile(SprintStack *ss, jsbytecode *pc, intN nb);
   1: 
   1: static JSBool
   1: DecompileSwitch(SprintStack *ss, TableEntry *table, uintN tableLength,
   1:                 jsbytecode *pc, ptrdiff_t switchLength,
   1:                 ptrdiff_t defaultOffset, JSBool isCondSwitch)
   1: {
   1:     JSContext *cx;
   1:     JSPrinter *jp;
 259:     ptrdiff_t off, off2, diff, caseExprOff, todo;
   1:     char *lval, *rval;
   1:     uintN i;
   1:     jsval key;
   1:     JSString *str;
   1: 
   1:     cx = ss->sprinter.context;
   1:     jp = ss->printer;
   1: 
   1:     /* JSOP_CONDSWITCH doesn't pop, unlike JSOP_{LOOKUP,TABLE}SWITCH. */
   1:     off = isCondSwitch ? GetOff(ss, ss->top-1) : PopOff(ss, JSOP_NOP);
   1:     lval = OFF2STR(&ss->sprinter, off);
   1: 
   1:     js_printf(CLEAR_MAYBE_BRACE(jp), "\tswitch (%s) {\n", lval);
   1: 
   1:     if (tableLength) {
   1:         diff = table[0].offset - defaultOffset;
   1:         if (diff > 0) {
   1:             jp->indent += 2;
   1:             js_printf(jp, "\t%s:\n", js_default_str);
   1:             jp->indent += 2;
   1:             if (!Decompile(ss, pc + defaultOffset, diff))
   1:                 return JS_FALSE;
   1:             jp->indent -= 4;
   1:         }
   1: 
   1:         caseExprOff = isCondSwitch ? JSOP_CONDSWITCH_LENGTH : 0;
   1: 
   1:         for (i = 0; i < tableLength; i++) {
   1:             off = table[i].offset;
   1:             off2 = (i + 1 < tableLength) ? table[i + 1].offset : switchLength;
   1: 
   1:             key = table[i].key;
   1:             if (isCondSwitch) {
   1:                 ptrdiff_t nextCaseExprOff;
   1: 
   1:                 /*
   1:                  * key encodes the JSOP_CASE bytecode's offset from switchtop.
   1:                  * The next case expression follows immediately, unless we are
   1:                  * at the last case.
   1:                  */
   1:                 nextCaseExprOff = (ptrdiff_t)JSVAL_TO_INT(key);
   1:                 nextCaseExprOff += js_CodeSpec[pc[nextCaseExprOff]].length;
   1:                 jp->indent += 2;
   1:                 if (!Decompile(ss, pc + caseExprOff,
   1:                                nextCaseExprOff - caseExprOff)) {
   1:                     return JS_FALSE;
   1:                 }
   1:                 caseExprOff = nextCaseExprOff;
   1: 
   1:                 /* Balance the stack as if this JSOP_CASE matched. */
   1:                 --ss->top;
   1:             } else {
   1:                 /*
   1:                  * key comes from an atom, not the decompiler, so we need to
   1:                  * quote it if it's a string literal.  But if table[i].label
   1:                  * is non-null, key was constant-propagated and label is the
   1:                  * name of the const we should show as the case label.  We set
   1:                  * key to undefined so this identifier is escaped, if required
   1:                  * by non-ASCII characters, but not quoted, by QuoteString.
   1:                  */
 259:                 todo = -1;
   1:                 if (table[i].label) {
   1:                     str = ATOM_TO_STRING(table[i].label);
   1:                     key = JSVAL_VOID;
 259:                 } else if (JSVAL_IS_DOUBLE(key)) {
 259:                     JSOp junk;
 259: 
 259:                     todo = SprintDoubleValue(&ss->sprinter, key, &junk);
 259:                     str = NULL;
   1:                 } else {
   1:                     str = js_ValueToString(cx, key);
   1:                     if (!str)
   1:                         return JS_FALSE;
   1:                 }
 259:                 if (todo >= 0) {
 259:                     rval = OFF2STR(&ss->sprinter, todo);
 259:                 } else {
 259:                     rval = QuoteString(&ss->sprinter, str, (jschar)
 259:                                        (JSVAL_IS_STRING(key) ? '"' : 0));
   1:                     if (!rval)
   1:                         return JS_FALSE;
 259:                 }
   1:                 RETRACT(&ss->sprinter, rval);
   1:                 jp->indent += 2;
   1:                 js_printf(jp, "\tcase %s:\n", rval);
   1:             }
   1: 
   1:             jp->indent += 2;
   1:             if (off <= defaultOffset && defaultOffset < off2) {
   1:                 diff = defaultOffset - off;
   1:                 if (diff != 0) {
   1:                     if (!Decompile(ss, pc + off, diff))
   1:                         return JS_FALSE;
   1:                     off = defaultOffset;
   1:                 }
   1:                 jp->indent -= 2;
   1:                 js_printf(jp, "\t%s:\n", js_default_str);
   1:                 jp->indent += 2;
   1:             }
   1:             if (!Decompile(ss, pc + off, off2 - off))
   1:                 return JS_FALSE;
   1:             jp->indent -= 4;
   1: 
   1:             /* Re-balance as if last JSOP_CASE or JSOP_DEFAULT mismatched. */
   1:             if (isCondSwitch)
   1:                 ++ss->top;
   1:         }
   1:     }
   1: 
   1:     if (defaultOffset == switchLength) {
   1:         jp->indent += 2;
   1:         js_printf(jp, "\t%s:;\n", js_default_str);
   1:         jp->indent -= 2;
   1:     }
   1:     js_printf(jp, "\t}\n");
   1: 
   1:     /* By the end of a JSOP_CONDSWITCH, the discriminant has been popped. */
   1:     if (isCondSwitch)
   1:         --ss->top;
   1:     return JS_TRUE;
   1: }
   1: 
   1: static JSAtom *
   1: GetSlotAtom(JSPrinter *jp, JSPropertyOp getter, uintN slot)
   1: {
   1:     JSScope *scope;
   1:     JSScopeProperty *sprop;
   1:     JSObject *obj, *proto;
   1: 
   1:     scope = jp->scope;
   1:     while (scope) {
   1:         for (sprop = SCOPE_LAST_PROP(scope); sprop; sprop = sprop->parent) {
   1:             if (sprop->getter != getter)
   1:                 continue;
   1:             JS_ASSERT(sprop->flags & SPROP_HAS_SHORTID);
   1:             JS_ASSERT(JSID_IS_ATOM(sprop->id));
   1:             if ((uintN) sprop->shortid == slot)
   1:                 return JSID_TO_ATOM(sprop->id);
   1:         }
   1:         obj = scope->object;
   1:         if (!obj)
   1:             break;
   1:         proto = OBJ_GET_PROTO(jp->sprinter.context, obj);
   1:         if (!proto)
   1:             break;
   1:         scope = OBJ_SCOPE(proto);
   1:     }
   1:     return NULL;
   1: }
   1: 
   1: static JSBool
   1: PushSlotAtom(SprintStack *ss, JSPropertyOp getter, uintN slot, JSOp op)
   1: {
   1:     JSAtom *atom;
   1:     char *lval;
   1: 
   1:     atom = GetSlotAtom(ss->printer, getter, slot);
   1:     if (!atom)
   1:         return JS_FALSE;
   1:     JS_ASSERT(ATOM_IS_STRING(atom));
   1:     lval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:     if (!lval)
   1:         return JS_FALSE;
   1:     return PushOff(ss, STR2OFF(&ss->sprinter, lval), op);
   1: }
   1: 
   1: /*
   1:  * NB: Indexed by SRC_DECL_* defines from jsemit.h.
   1:  */
   1: static const char * const var_prefix[] = {"var ", "const ", "let "};
   1: 
   1: static const char *
   1: VarPrefix(jssrcnote *sn)
   1: {
   1:     if (sn && (SN_TYPE(sn) == SRC_DECL || SN_TYPE(sn) == SRC_GROUPASSIGN)) {
   1:         ptrdiff_t type = js_GetSrcNoteOffset(sn, 0);
   1:         if ((uintN)type <= SRC_DECL_LET)
   1:             return var_prefix[type];
   1:     }
   1:     return "";
   1: }
   1: #define LOCAL_ASSERT_RV(expr, rv)                                             \
   1:     JS_BEGIN_MACRO                                                            \
   1:         JS_ASSERT(expr);                                                      \
   1:         if (!(expr)) return (rv);                                             \
   1:     JS_END_MACRO
   1: 
   1: const char *
   1: GetLocal(SprintStack *ss, jsint i)
   1: {
   1:     ptrdiff_t off;
   1:     JSContext *cx;
   1:     JSScript *script;
   1:     jsatomid j, n;
   1:     JSAtom *atom;
   1:     JSObject *obj;
   1:     jsint depth, count;
   1:     JSScopeProperty *sprop;
   1:     const char *rval;
   1: 
   1: #define LOCAL_ASSERT(expr)      LOCAL_ASSERT_RV(expr, "")
   1: 
   1:     off = ss->offsets[i];
   1:     if (off >= 0)
   1:         return OFF2STR(&ss->sprinter, off);
   1: 
   1:     /*
   1:      * We must be called from js_DecompileValueGenerator (via Decompile) when
   1:      * dereferencing a local that's undefined or null.  Search script->atomMap
   1:      * for the block containing this local by its stack index, i.
   1:      */
   1:     cx = ss->sprinter.context;
   1:     script = ss->printer->script;
   1:     for (j = 0, n = script->atomMap.length; j < n; j++) {
   1:         atom = script->atomMap.vector[j];
   1:         if (ATOM_IS_OBJECT(atom)) {
   1:             obj = ATOM_TO_OBJECT(atom);
   1:             if (OBJ_GET_CLASS(cx, obj) == &js_BlockClass) {
   1:                 depth = OBJ_BLOCK_DEPTH(cx, obj);
   1:                 count = OBJ_BLOCK_COUNT(cx, obj);
   1:                 if ((jsuint)(i - depth) < (jsuint)count)
   1:                     break;
   1:             }
   1:         }
   1:     }
   1: 
   1:     LOCAL_ASSERT(j < n);
   1:     i -= depth;
   1:     for (sprop = OBJ_SCOPE(obj)->lastProp; sprop; sprop = sprop->parent) {
   1:         if (sprop->shortid == i)
   1:             break;
   1:     }
   1: 
   1:     LOCAL_ASSERT(sprop && JSID_IS_ATOM(sprop->id));
   1:     atom = JSID_TO_ATOM(sprop->id);
   1:     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:     if (!rval)
   1:         return NULL;
   1:     RETRACT(&ss->sprinter, rval);
   1:     return rval;
   1: 
   1: #undef LOCAL_ASSERT
   1: }
   1: 
   1: #if JS_HAS_DESTRUCTURING
   1: 
   1: #define LOCAL_ASSERT(expr)  LOCAL_ASSERT_RV(expr, NULL)
   1: #define LOAD_OP_DATA(pc)    (oplen = (cs = &js_CodeSpec[op = *pc])->length)
   1: 
   1: static jsbytecode *
   1: DecompileDestructuring(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc);
   1: 
   1: static jsbytecode *
   1: DecompileDestructuringLHS(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc,
   1:                           JSBool *hole)
   1: {
   1:     JSContext *cx;
   1:     JSPrinter *jp;
   1:     JSOp op;
   1:     const JSCodeSpec *cs;
   1:     uintN oplen, i;
   1:     const char *lval, *xval;
   1:     ptrdiff_t todo;
   1:     JSAtom *atom;
   1: 
   1:     *hole = JS_FALSE;
   1:     cx = ss->sprinter.context;
   1:     jp = ss->printer;
   1:     LOAD_OP_DATA(pc);
   1: 
   1:     switch (op) {
   1:       case JSOP_POP:
   1:         *hole = JS_TRUE;
   1:         todo = SprintPut(&ss->sprinter, ", ", 2);
   1:         break;
   1: 
   1:       case JSOP_DUP:
   1:         pc = DecompileDestructuring(ss, pc, endpc);
   1:         if (!pc)
   1:             return NULL;
   1:         if (pc == endpc)
   1:             return pc;
   1:         LOAD_OP_DATA(pc);
   1:         lval = PopStr(ss, JSOP_NOP);
   1:         todo = SprintCString(&ss->sprinter, lval);
1289:         if (op == JSOP_POPN)
   1:             return pc;
   1:         LOCAL_ASSERT(*pc == JSOP_POP);
   1:         break;
   1: 
   1:       case JSOP_SETARG:
   1:       case JSOP_SETVAR:
   1:       case JSOP_SETGVAR:
   1:       case JSOP_SETLOCAL:
1289:         LOCAL_ASSERT(pc[oplen] == JSOP_POP || pc[oplen] == JSOP_POPN);
   1:         /* FALL THROUGH */
   1: 
   1:       case JSOP_SETLOCALPOP:
   1:         i = GET_UINT16(pc);
   1:         atom = NULL;
   1:         lval = NULL;
   1:         if (op == JSOP_SETARG)
   1:             atom = GetSlotAtom(jp, js_GetArgument, i);
   1:         else if (op == JSOP_SETVAR)
   1:             atom = GetSlotAtom(jp, js_GetLocalVariable, i);
   1:         else if (op == JSOP_SETGVAR)
   1:             atom = js_GetAtomFromBytecode(jp->script, pc, 0);
   1:         else
   1:             lval = GetLocal(ss, i);
   1:         if (atom)
   1:             lval = js_AtomToPrintableString(cx, atom);
   1:         LOCAL_ASSERT(lval);
   1:         todo = SprintCString(&ss->sprinter, lval);
   1:         if (op != JSOP_SETLOCALPOP) {
   1:             pc += oplen;
   1:             if (pc == endpc)
   1:                 return pc;
   1:             LOAD_OP_DATA(pc);
1289:             if (op == JSOP_POPN)
   1:                 return pc;
   1:             LOCAL_ASSERT(op == JSOP_POP);
   1:         }
   1:         break;
   1: 
   1:       default:
   1:         /*
   1:          * We may need to auto-parenthesize the left-most value decompiled
   1:          * here, so add back PAREN_SLOP temporarily.  Then decompile until the
   1:          * opcode that would reduce the stack depth to (ss->top-1), which we
   1:          * pass to Decompile encoded as -(ss->top-1) - 1 or just -ss->top for
   1:          * the nb parameter.
   1:          */
   1:         todo = ss->sprinter.offset;
   1:         ss->sprinter.offset = todo + PAREN_SLOP;
   1:         pc = Decompile(ss, pc, -ss->top);
   1:         if (!pc)
   1:             return NULL;
   1:         if (pc == endpc)
   1:             return pc;
   1:         LOAD_OP_DATA(pc);
   1:         LOCAL_ASSERT(op == JSOP_ENUMELEM || op == JSOP_ENUMCONSTELEM);
   1:         xval = PopStr(ss, JSOP_NOP);
   1:         lval = PopStr(ss, JSOP_GETPROP);
   1:         ss->sprinter.offset = todo;
   1:         if (*lval == '\0') {
   1:             /* lval is from JSOP_BINDNAME, so just print xval. */
   1:             todo = SprintCString(&ss->sprinter, xval);
   1:         } else if (*xval == '\0') {
   1:             /* xval is from JSOP_SETCALL or JSOP_BINDXMLNAME, print lval. */
   1:             todo = SprintCString(&ss->sprinter, lval);
   1:         } else {
   1:             todo = Sprint(&ss->sprinter,
   1:                           (js_CodeSpec[ss->opcodes[ss->top+1]].format
   1:                            & JOF_XMLNAME)
   1:                           ? "%s.%s"
   1:                           : "%s[%s]",
   1:                           lval, xval);
   1:         }
   1:         break;
   1:     }
   1: 
   1:     if (todo < 0)
   1:         return NULL;
   1: 
   1:     LOCAL_ASSERT(pc < endpc);
   1:     pc += oplen;
   1:     return pc;
   1: }
   1: 
   1: /*
   1:  * Starting with a SRC_DESTRUCT-annotated JSOP_DUP, decompile a destructuring
   1:  * left-hand side object or array initialiser, including nested destructuring
   1:  * initialisers.  On successful return, the decompilation will be pushed on ss
   1:  * and the return value will point to the POP or GROUP bytecode following the
   1:  * destructuring expression.
   1:  *
   1:  * At any point, if pc is equal to endpc and would otherwise advance, we stop
   1:  * immediately and return endpc.
   1:  */
   1: static jsbytecode *
   1: DecompileDestructuring(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc)
   1: {
   1:     ptrdiff_t head, todo;
   1:     JSContext *cx;
   1:     JSPrinter *jp;
   1:     JSOp op, saveop;
   1:     const JSCodeSpec *cs;
   1:     uintN oplen;
   1:     jsint i, lasti;
   1:     jsdouble d;
   1:     const char *lval;
   1:     JSAtom *atom;
   1:     jssrcnote *sn;
   1:     JSString *str;
   1:     JSBool hole;
   1: 
   1:     LOCAL_ASSERT(*pc == JSOP_DUP);
   1:     pc += JSOP_DUP_LENGTH;
   1: 
   1:     /*
   1:      * Set head so we can rewrite '[' to '{' as needed.  Back up PAREN_SLOP
   1:      * chars so the destructuring decompilation accumulates contiguously in
   1:      * ss->sprinter starting with "[".
   1:      */
   1:     head = SprintPut(&ss->sprinter, "[", 1);
   1:     if (head < 0 || !PushOff(ss, head, JSOP_NOP))
   1:         return NULL;
   1:     ss->sprinter.offset -= PAREN_SLOP;
   1:     LOCAL_ASSERT(head == ss->sprinter.offset - 1);
   1:     LOCAL_ASSERT(*OFF2STR(&ss->sprinter, head) == '[');
   1: 
   1:     cx = ss->sprinter.context;
   1:     jp = ss->printer;
   1:     lasti = -1;
   1: 
   1:     while (pc < endpc) {
   1:         LOAD_OP_DATA(pc);
   1:         saveop = op;
   1: 
   1:         switch (op) {
   1:           case JSOP_POP:
   1:             pc += oplen;
   1:             goto out;
   1: 
   1:           /* Handle the optimized number-pushing opcodes. */
   1:           case JSOP_ZERO:   d = i = 0; goto do_getelem;
   1:           case JSOP_ONE:    d = i = 1; goto do_getelem;
   1:           case JSOP_UINT16: d = i = GET_UINT16(pc); goto do_getelem;
   1:           case JSOP_UINT24: d = i = GET_UINT24(pc); goto do_getelem;
   1: 
   1:           case JSOP_NUMBER:
   1:             atom = js_GetAtomFromBytecode(jp->script, pc, 0);
   1:             d = *ATOM_TO_DOUBLE(atom);
   1:             LOCAL_ASSERT(JSDOUBLE_IS_FINITE(d) && !JSDOUBLE_IS_NEGZERO(d));
   1:             i = (jsint)d;
   1: 
   1:           do_getelem:
   1:             sn = js_GetSrcNote(jp->script, pc);
   1:             pc += oplen;
   1:             if (pc == endpc)
   1:                 return pc;
   1:             LOAD_OP_DATA(pc);
   1:             LOCAL_ASSERT(op == JSOP_GETELEM);
   1: 
   1:             /* Distinguish object from array by opcode or source note. */
   1:             if (sn && SN_TYPE(sn) == SRC_INITPROP) {
   1:                 *OFF2STR(&ss->sprinter, head) = '{';
   1:                 if (Sprint(&ss->sprinter, "%g: ", d) < 0)
   1:                     return NULL;
   1:             } else {
   1:                 /* Sanity check for the gnarly control flow above. */
   1:                 LOCAL_ASSERT(i == d);
   1: 
   1:                 /* Fill in any holes (holes at the end don't matter). */
   1:                 while (++lasti < i) {
   1:                     if (SprintPut(&ss->sprinter, ", ", 2) < 0)
   1:                         return NULL;
   1:                 }
   1:             }
   1:             break;
   1: 
   1:           case JSOP_CALLPROP:
   1:           case JSOP_GETPROP:
   1:             *OFF2STR(&ss->sprinter, head) = '{';
   1:             atom = js_GetAtomFromBytecode(jp->script, pc, 0);
   1:             str = ATOM_TO_STRING(atom);
   1:             if (!QuoteString(&ss->sprinter, str,
   1:                              js_IsIdentifier(str) ? 0 : (jschar)'\'')) {
   1:                 return NULL;
   1:             }
   1:             if (SprintPut(&ss->sprinter, ": ", 2) < 0)
   1:                 return NULL;
   1:             break;
   1: 
   1:           default:
   1:             LOCAL_ASSERT(0);
   1:         }
   1: 
   1:         pc += oplen;
   1:         if (pc == endpc)
   1:             return pc;
   1: 
   1:         /*
   1:          * Decompile the left-hand side expression whose bytecode starts at pc
   1:          * and continues for a bounded number of bytecodes or stack operations
   1:          * (and which in any event stops before endpc).
   1:          */
   1:         pc = DecompileDestructuringLHS(ss, pc, endpc, &hole);
   1:         if (!pc)
   1:             return NULL;
   1:         if (pc == endpc || *pc != JSOP_DUP)
   1:             break;
   1: 
   1:         /*
   1:          * Check for SRC_DESTRUCT on this JSOP_DUP, which would mean another
   1:          * destructuring initialiser abuts this one, and we should stop.  This
   1:          * happens with source of the form '[a] = [b] = c'.
   1:          */
   1:         sn = js_GetSrcNote(jp->script, pc);
   1:         if (sn && SN_TYPE(sn) == SRC_DESTRUCT)
   1:             break;
   1: 
   1:         if (!hole && SprintPut(&ss->sprinter, ", ", 2) < 0)
   1:             return NULL;
   1: 
   1:         pc += JSOP_DUP_LENGTH;
   1:     }
   1: 
   1: out:
   1:     lval = OFF2STR(&ss->sprinter, head);
   1:     todo = SprintPut(&ss->sprinter, (*lval == '[') ? "]" : "}", 1);
   1:     if (todo < 0)
   1:         return NULL;
   1:     return pc;
   1: }
   1: 
   1: static jsbytecode *
   1: DecompileGroupAssignment(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc,
   1:                          jssrcnote *sn, ptrdiff_t *todop)
   1: {
   1:     JSOp op;
   1:     const JSCodeSpec *cs;
   1:     uintN oplen, start, end, i;
   1:     ptrdiff_t todo;
   1:     JSBool hole;
   1:     const char *rval;
   1: 
   1:     LOAD_OP_DATA(pc);
   1:     LOCAL_ASSERT(op == JSOP_PUSH || op == JSOP_GETLOCAL);
   1: 
   1:     todo = Sprint(&ss->sprinter, "%s[", VarPrefix(sn));
   1:     if (todo < 0 || !PushOff(ss, todo, JSOP_NOP))
   1:         return NULL;
   1:     ss->sprinter.offset -= PAREN_SLOP;
   1: 
   1:     for (;;) {
   1:         pc += oplen;
   1:         if (pc == endpc)
   1:             return pc;
   1:         pc = DecompileDestructuringLHS(ss, pc, endpc, &hole);
   1:         if (!pc)
   1:             return NULL;
   1:         if (pc == endpc)
   1:             return pc;
   1:         LOAD_OP_DATA(pc);
   1:         if (op != JSOP_PUSH && op != JSOP_GETLOCAL)
   1:             break;
   1:         if (!hole && SprintPut(&ss->sprinter, ", ", 2) < 0)
   1:             return NULL;
   1:     }
   1: 
1227:     LOCAL_ASSERT(op == JSOP_POPN);
   1:     if (SprintPut(&ss->sprinter, "] = [", 5) < 0)
   1:         return NULL;
   1: 
   1:     end = ss->top - 1;
1289:     start = end - GET_UINT16(pc);
   1:     for (i = start; i < end; i++) {
   1:         rval = GetStr(ss, i);
1289:         if (Sprint(&ss->sprinter,
1289:                    (i == start) ? "%s" : ", %s",
   1:                    (i == end - 1 && *rval == '\0') ? ", " : rval) < 0) {
   1:             return NULL;
   1:         }
   1:     }
   1: 
   1:     if (SprintPut(&ss->sprinter, "]", 1) < 0)
   1:         return NULL;
   1:     ss->sprinter.offset = ss->offsets[i];
   1:     ss->top = start;
   1:     *todop = todo;
   1:     return pc;
   1: }
   1: 
   1: #undef LOCAL_ASSERT
   1: #undef LOAD_OP_DATA
   1: 
   1: #endif /* JS_HAS_DESTRUCTURING */
   1: 
   1: /*
   1:  * If nb is non-negative, decompile nb bytecodes starting at pc.  Otherwise
   1:  * the decompiler starts at pc and continues until it reaches an opcode for
   1:  * which decompiling would result in the stack depth equaling -(nb + 1).
   1:  */
   1: static jsbytecode *
   1: Decompile(SprintStack *ss, jsbytecode *pc, intN nb)
   1: {
   1:     JSContext *cx;
   1:     JSPrinter *jp, *jp2;
   1:     jsbytecode *startpc, *endpc, *pc2, *done, *forelem_tail, *forelem_done;
   1:     ptrdiff_t tail, todo, len, oplen, cond, next;
   1:     JSOp op, lastop, saveop;
   1:     const JSCodeSpec *cs;
   1:     jssrcnote *sn, *sn2;
1154:     const char *lval, *rval, *xval, *fmt, *token;
   1:     jsint i, argc;
   1:     char **argv;
   1:     JSAtom *atom;
   1:     JSObject *obj;
   1:     JSFunction *fun;
   1:     JSString *str;
   1:     JSBool ok;
   1: #if JS_HAS_XML_SUPPORT
   1:     JSBool foreach, inXML, quoteAttr;
   1: #else
   1: #define inXML JS_FALSE
   1: #endif
   1:     jsval val;
   1:     int stackDummy;
   1: 
   1:     static const char exception_cookie[] = "/*EXCEPTION*/";
   1:     static const char retsub_pc_cookie[] = "/*RETSUB_PC*/";
   1:     static const char forelem_cookie[]   = "/*FORELEM*/";
   1:     static const char with_cookie[]      = "/*WITH*/";
   1:     static const char dot_format[]       = "%s.%s";
   1:     static const char index_format[]     = "%s[%s]";
   1:     static const char predot_format[]    = "%s%s.%s";
   1:     static const char postdot_format[]   = "%s.%s%s";
   1:     static const char preindex_format[]  = "%s%s[%s]";
   1:     static const char postindex_format[] = "%s[%s]%s";
   1:     static const char ss_format[]        = "%s%s";
   1: 
   1: /*
   1:  * Local macros
   1:  */
   1: #define DECOMPILE_CODE(pc,nb)   if (!Decompile(ss, pc, nb)) return NULL
   1: #define POP_STR()               PopStr(ss, op)
   1: #define LOCAL_ASSERT(expr)      LOCAL_ASSERT_RV(expr, JS_FALSE)
   1: 
   1: /*
   1:  * Callers know that ATOM_IS_STRING(atom), and we leave it to the optimizer to
   1:  * common ATOM_TO_STRING(atom) here and near the call sites.
   1:  */
   1: #define ATOM_IS_IDENTIFIER(atom) js_IsIdentifier(ATOM_TO_STRING(atom))
 969: #define ATOM_IS_KEYWORD(atom)                                                 \
 969:     (js_CheckKeyword(JSSTRING_CHARS(ATOM_TO_STRING(atom)),                    \
 969:                      JSSTRING_LENGTH(ATOM_TO_STRING(atom))) != TOK_EOF)
   1: 
   1: /*
   1:  * Given an atom already fetched from jp->script's atom map, quote/escape its
   1:  * string appropriately into rval, and select fmt from the quoted and unquoted
   1:  * alternatives.
   1:  */
   1: #define GET_QUOTE_AND_FMT(qfmt, ufmt, rval)                                   \
   1:     JS_BEGIN_MACRO                                                            \
   1:         jschar quote_;                                                        \
   1:         if (!ATOM_IS_IDENTIFIER(atom)) {                                      \
   1:             quote_ = '\'';                                                    \
   1:             fmt = qfmt;                                                       \
   1:         } else {                                                              \
   1:             quote_ = 0;                                                       \
   1:             fmt = ufmt;                                                       \
   1:         }                                                                     \
   1:         rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), quote_);      \
   1:         if (!rval)                                                            \
   1:             return NULL;                                                      \
   1:     JS_END_MACRO
   1: 
   1: #define LOAD_ATOM(PCOFF)                                                      \
   1:     (atom = js_GetAtomFromBytecode(jp->script, pc, (PCOFF)))
   1: 
   1: /*
   1:  * Get atom from jp->script's atom map, quote/escape its string appropriately
   1:  * into rval, and select fmt from the quoted and unquoted alternatives.
   1:  */
   1: #define GET_ATOM_QUOTE_AND_FMT(qfmt, ufmt, rval)                              \
   1:     JS_BEGIN_MACRO                                                            \
   1:         LOAD_ATOM(0);                                                         \
   1:         GET_QUOTE_AND_FMT(qfmt, ufmt, rval);                                  \
   1:     JS_END_MACRO
   1: 
   1:     cx = ss->sprinter.context;
   1:     if (!JS_CHECK_STACK_SIZE(cx, stackDummy)) {
   1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_OVER_RECURSED);
   1:         return NULL;
   1:     }
   1: 
   1:     jp = ss->printer;
   1:     startpc = pc;
   1:     endpc = (nb < 0) ? jp->script->code + jp->script->length : pc + nb;
   1:     forelem_tail = forelem_done = NULL;
   1:     tail = -1;
   1:     todo = -2;                  /* NB: different from Sprint() error return. */
   1:     saveop = JSOP_NOP;
   1:     sn = NULL;
   1:     rval = NULL;
   1: #if JS_HAS_XML_SUPPORT
   1:     foreach = inXML = quoteAttr = JS_FALSE;
   1: #endif
   1: 
   1:     while (nb < 0 || pc < endpc) {
   1:         /*
   1:          * Move saveop to lastop so prefixed bytecodes can take special action
   1:          * while sharing maximal code.  Set op and saveop to the new bytecode,
   1:          * use op in POP_STR to trigger automatic parenthesization, but push
   1:          * saveop at the bottom of the loop if this op pushes.  Thus op may be
   1:          * set to nop or otherwise mutated to suppress auto-parens.
   1:          */
   1:         lastop = saveop;
   1:         op = (JSOp) *pc;
   1:         cs = &js_CodeSpec[op];
   1:         if (cs->format & JOF_ATOMBASE) {
   1:             /*
   1:              * The decompiler uses js_GetAtomFromBytecode to get atoms and
   1:              * ignores these suffix/prefix bytecodes, thus simplifying code
   1:              * that must process JSOP_GETTER/JSOP_SETTER prefixes.
   1:              */
   1:             pc += cs->length;
   1:             if (pc >= endpc)
   1:                 break;
   1:             op = (JSOp) *pc;
   1:             cs = &js_CodeSpec[op];
   1:         }
   1:         saveop = op;
   1:         len = oplen = cs->length;
   1: 
   1:         if (nb < 0 && -(nb + 1) == (intN)ss->top - cs->nuses + cs->ndefs)
   1:             return pc;
   1: 
   1:         if (pc + oplen == jp->dvgfence) {
   1:             JSStackFrame *fp;
   1:             uint32 format, mode, type;
   1: 
   1:             /*
   1:              * Rewrite non-get ops to their "get" format if the error is in
   1:              * the bytecode at pc, so we don't decompile more than the error
   1:              * expression.
   1:              */
   1:             for (fp = cx->fp; fp && !fp->script; fp = fp->down)
   1:                 continue;
   1:             format = cs->format;
   1:             if (((fp && pc == fp->pc) ||
   1:                  (pc == startpc && cs->nuses != 0)) &&
   1:                 format & (JOF_SET|JOF_DEL|JOF_INCDEC|JOF_IMPORT|JOF_FOR|
   1:                           JOF_VARPROP)) {
   1:                 mode = (format & JOF_MODEMASK);
   1:                 if (mode == JOF_NAME) {
   1:                     /*
   1:                      * JOF_NAME does not imply JOF_CONST, so we must check for
   1:                      * the QARG and QVAR format types, and translate those to
   1:                      * JSOP_GETARG or JSOP_GETVAR appropriately, instead of to
   1:                      * JSOP_NAME.
   1:                      */
   1:                     type = format & JOF_TYPEMASK;
   1:                     op = (type == JOF_QARG)
   1:                          ? JSOP_GETARG
   1:                          : (type == JOF_QVAR)
   1:                          ? JSOP_GETVAR
   1:                          : (type == JOF_LOCAL)
   1:                          ? JSOP_GETLOCAL
   1:                          : JSOP_NAME;
   1: 
   1:                     i = cs->nuses - js_CodeSpec[op].nuses;
   1:                     while (--i >= 0)
   1:                         PopOff(ss, JSOP_NOP);
   1:                 } else {
   1:                     /*
   1:                      * We must replace the faulting pc's bytecode with a
   1:                      * corresponding JSOP_GET* code.  For JSOP_SET{PROP,ELEM},
   1:                      * we must use the "2nd" form of JSOP_GET{PROP,ELEM}, to
   1:                      * throw away the assignment op's right-hand operand and
   1:                      * decompile it as if it were a GET of its left-hand
   1:                      * operand.
   1:                      */
   1:                     if (mode == JOF_PROP) {
   1:                         op = (format & JOF_SET) ? JSOP_GETPROP2 : JSOP_GETPROP;
   1:                     } else if (mode == JOF_ELEM) {
   1:                         op = (format & JOF_SET) ? JSOP_GETELEM2 : JSOP_GETELEM;
   1:                     } else {
   1:                         /*
   1:                          * Zero mode means precisely that op is uncategorized
   1:                          * for our purposes, so we must write per-op special
   1:                          * case code here.
   1:                          */
   1:                         switch (op) {
   1:                           case JSOP_ENUMELEM:
   1:                           case JSOP_ENUMCONSTELEM:
   1:                             op = JSOP_GETELEM;
   1:                             break;
   1: #if JS_HAS_LVALUE_RETURN
   1:                           case JSOP_SETCALL:
   1:                             op = JSOP_CALL;
   1:                             break;
   1: #endif
   1:                           case JSOP_GETARGPROP:
   1:                             op = JSOP_GETARG;
   1:                             break;
   1:                           case JSOP_GETVARPROP:
   1:                             op = JSOP_GETVAR;
   1:                             break;
   1:                           case JSOP_GETLOCALPROP:
   1:                             op = JSOP_GETLOCAL;
   1:                             break;
   1:                           default:
   1:                             LOCAL_ASSERT(0);
   1:                         }
   1:                     }
   1:                 }
   1:             }
   1: 
   1:             saveop = op;
   1:             if (op >= JSOP_LIMIT) {
   1:                 switch (op) {
   1:                   case JSOP_GETPROP2:
   1:                     saveop = JSOP_GETPROP;
   1:                     break;
   1:                   case JSOP_GETELEM2:
   1:                     saveop = JSOP_GETELEM;
   1:                     break;
   1:                   default:;
   1:                 }
   1:             }
   1:             LOCAL_ASSERT(js_CodeSpec[saveop].length == oplen ||
   1:                          (format & JOF_TYPEMASK) == JOF_INDEXCONST);
   1: 
   1:             jp->dvgfence = NULL;
   1:         }
   1: 
1154:         token = CodeToken[op];
1154:         if (token) {
   1:             switch (cs->nuses) {
   1:               case 2:
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 if (sn && SN_TYPE(sn) == SRC_ASSIGNOP) {
   1:                     /*
   1:                      * Avoid over-parenthesizing y in x op= y based on its
   1:                      * expansion: x = x op y (replace y by z = w to see the
   1:                      * problem).
   1:                      */
   1:                     op = pc[oplen];
   1:                     LOCAL_ASSERT(op != saveop);
   1:                 }
   1:                 rval = POP_STR();
   1:                 lval = POP_STR();
   1:                 if (op != saveop) {
   1:                     /* Print only the right operand of the assignment-op. */
   1:                     todo = SprintCString(&ss->sprinter, rval);
   1:                     op = saveop;
   1:                 } else if (!inXML) {
   1:                     todo = Sprint(&ss->sprinter, "%s %s %s",
1154:                                   lval, token, rval);
   1:                 } else {
   1:                     /* In XML, just concatenate the two operands. */
   1:                     LOCAL_ASSERT(op == JSOP_ADD);
   1:                     todo = Sprint(&ss->sprinter, ss_format, lval, rval);
   1:                 }
   1:                 break;
   1: 
   1:               case 1:
   1:                 rval = POP_STR();
1154:                 todo = Sprint(&ss->sprinter, ss_format, token, rval);
   1:                 break;
   1: 
   1:               case 0:
1154:                 todo = SprintCString(&ss->sprinter, token);
   1:                 break;
   1: 
   1:               default:
   1:                 todo = -2;
   1:                 break;
   1:             }
   1:         } else {
   1:             switch (op) {
   1: #define BEGIN_LITOPX_CASE(OP,PCOFF)                                           \
   1:               case OP:                                                        \
   1:                 LOAD_ATOM(PCOFF);
   1: 
   1: #define END_LITOPX_CASE                                                       \
   1:                 break;
   1: 
   1:               case JSOP_NOP:
   1:                 /*
   1:                  * Check for a do-while loop, a for-loop with an empty
   1:                  * initializer part, a labeled statement, a function
   1:                  * definition, or try/finally.
   1:                  */
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 todo = -2;
   1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
   1:                   case SRC_WHILE:
   1:                     ++pc;
   1:                     tail = js_GetSrcNoteOffset(sn, 0) - 1;
   1:                     LOCAL_ASSERT(pc[tail] == JSOP_IFNE ||
   1:                                  pc[tail] == JSOP_IFNEX);
   1:                     js_printf(SET_MAYBE_BRACE(jp), "\tdo {\n");
   1:                     jp->indent += 4;
   1:                     DECOMPILE_CODE(pc, tail);
   1:                     jp->indent -= 4;
   1:                     js_printf(jp, "\t} while (%s);\n", POP_STR());
   1:                     pc += tail;
   1:                     len = js_CodeSpec[*pc].length;
   1:                     todo = -2;
   1:                     break;
   1: 
   1:                   case SRC_FOR:
   1:                     rval = "";
   1: 
   1:                   do_forloop:
   1:                     /* Skip the JSOP_NOP or JSOP_POP bytecode. */
   1:                     pc++;
   1: 
   1:                     /* Get the cond, next, and loop-closing tail offsets. */
   1:                     cond = js_GetSrcNoteOffset(sn, 0);
   1:                     next = js_GetSrcNoteOffset(sn, 1);
   1:                     tail = js_GetSrcNoteOffset(sn, 2);
   1:                     LOCAL_ASSERT(tail + GetJumpOffset(pc+tail, pc+tail) == 0);
   1: 
   1:                     /* Print the keyword and the possibly empty init-part. */
   1:                     js_printf(jp, "\tfor (%s;", rval);
   1: 
   1:                     if (pc[cond] == JSOP_IFEQ || pc[cond] == JSOP_IFEQX) {
   1:                         /* Decompile the loop condition. */
   1:                         DECOMPILE_CODE(pc, cond);
   1:                         js_printf(jp, " %s", POP_STR());
   1:                     }
   1: 
   1:                     /* Need a semicolon whether or not there was a cond. */
   1:                     js_puts(jp, ";");
   1: 
   1:                     if (pc[next] != JSOP_GOTO && pc[next] != JSOP_GOTOX) {
   1:                         /* Decompile the loop updater. */
   1:                         DECOMPILE_CODE(pc + next, tail - next - 1);
   1:                         js_printf(jp, " %s", POP_STR());
   1:                     }
   1: 
   1:                     /* Do the loop body. */
   1:                     js_printf(SET_MAYBE_BRACE(jp), ") {\n");
   1:                     jp->indent += 4;
   1:                     oplen = (cond) ? js_CodeSpec[pc[cond]].length : 0;
   1:                     DECOMPILE_CODE(pc + cond + oplen, next - cond - oplen);
   1:                     jp->indent -= 4;
   1:                     js_printf(jp, "\t}\n");
   1: 
   1:                     /* Set len so pc skips over the entire loop. */
   1:                     len = tail + js_CodeSpec[pc[tail]].length;
   1:                     break;
   1: 
   1:                   case SRC_LABEL:
   1:                     atom = js_GetAtom(cx, &jp->script->atomMap,
   1:                                       (jsatomid) js_GetSrcNoteOffset(sn, 0));
   1:                     jp->indent -= 4;
   1:                     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                     if (!rval)
   1:                         return NULL;
   1:                     RETRACT(&ss->sprinter, rval);
   1:                     js_printf(CLEAR_MAYBE_BRACE(jp), "\t%s:\n", rval);
   1:                     jp->indent += 4;
   1:                     break;
   1: 
   1:                   case SRC_LABELBRACE:
   1:                     atom = js_GetAtom(cx, &jp->script->atomMap,
   1:                                       (jsatomid) js_GetSrcNoteOffset(sn, 0));
   1:                     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                     if (!rval)
   1:                         return NULL;
   1:                     RETRACT(&ss->sprinter, rval);
   1:                     js_printf(CLEAR_MAYBE_BRACE(jp), "\t%s: {\n", rval);
   1:                     jp->indent += 4;
   1:                     break;
   1: 
   1:                   case SRC_ENDBRACE:
   1:                     jp->indent -= 4;
   1:                     js_printf(jp, "\t}\n");
   1:                     break;
   1: 
   1:                   case SRC_FUNCDEF:
   1:                     atom = js_GetAtom(cx, &jp->script->atomMap,
   1:                                       (jsatomid) js_GetSrcNoteOffset(sn, 0));
   1:                     LOCAL_ASSERT(ATOM_IS_OBJECT(atom));
   1:                   do_function:
   1:                     obj = ATOM_TO_OBJECT(atom);
   1:                     fun = (JSFunction *) JS_GetPrivate(cx, obj);
 437:                     jp2 = JS_NEW_PRINTER(cx, "nested_function",
   1:                                          jp->indent, jp->pretty);
   1:                     if (!jp2)
   1:                         return NULL;
   1:                     jp2->scope = jp->scope;
   1:                     js_puts(jp2, "\n");
   1:                     ok = js_DecompileFunction(jp2, fun);
   1:                     if (ok && jp2->sprinter.base) {
   1:                         js_puts(jp, jp2->sprinter.base);
   1:                         js_puts(jp, "\n");
   1:                     }
   1:                     js_DestroyPrinter(jp2);
   1:                     if (!ok)
   1:                         return NULL;
   1:                     js_puts(jp, "\n");
   1:                     break;
   1: 
   1:                   case SRC_BRACE:
   1:                     js_printf(CLEAR_MAYBE_BRACE(jp), "\t{\n");
   1:                     jp->indent += 4;
   1:                     len = js_GetSrcNoteOffset(sn, 0);
   1:                     DECOMPILE_CODE(pc + oplen, len - oplen);
   1:                     jp->indent -= 4;
   1:                     js_printf(jp, "\t}\n");
   1:                     break;
   1: 
   1:                   default:;
   1:                 }
   1:                 break;
   1: 
   1:               case JSOP_GROUP:
   1:                 cs = &js_CodeSpec[lastop];
   1:                 if ((cs->prec != 0 &&
   1:                      cs->prec == js_CodeSpec[pc[JSOP_GROUP_LENGTH]].prec) ||
   1:                     pc[JSOP_GROUP_LENGTH] == JSOP_NULL ||
 206:                     pc[JSOP_GROUP_LENGTH] == JSOP_DUP ||
 206:                     pc[JSOP_GROUP_LENGTH] == JSOP_IFEQ ||
 206:                     pc[JSOP_GROUP_LENGTH] == JSOP_IFNE) {
   1:                     /*
   1:                      * Force parens if this JSOP_GROUP forced re-association
   1:                      * against precedence, or if this is a call or constructor
 206:                      * expression, or if it is destructured (JSOP_DUP), or if
 206:                      * it is an if or loop condition test.
   1:                      *
   1:                      * This is necessary to handle the operator new grammar,
   1:                      * by which new x(y).z means (new x(y))).z.  For example
   1:                      * new (x(y).z) must decompile with the constructor
   1:                      * parenthesized, but normal precedence has JSOP_GETPROP
   1:                      * (for the final .z) higher than JSOP_NEW.  In general,
   1:                      * if the call or constructor expression is parenthesized,
   1:                      * we preserve parens.
   1:                      */
   1:                     op = JSOP_NAME;
   1:                     rval = POP_STR();
   1:                     todo = SprintCString(&ss->sprinter, rval);
   1:                 } else {
   1:                     /*
   1:                      * Don't explicitly parenthesize -- just fix the top
   1:                      * opcode so that the auto-parens magic in PopOff can do
   1:                      * its thing.
   1:                      */
   1:                     LOCAL_ASSERT(ss->top != 0);
   1:                     ss->opcodes[ss->top-1] = saveop = lastop;
   1:                     todo = -2;
   1:                 }
   1:                 break;
   1: 
   1:               case JSOP_PUSH:
   1: #if JS_HAS_DESTRUCTURING
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 if (sn && SN_TYPE(sn) == SRC_GROUPASSIGN) {
   1:                     pc = DecompileGroupAssignment(ss, pc, endpc, sn, &todo);
   1:                     if (!pc)
   1:                         return NULL;
1227:                     LOCAL_ASSERT(*pc == JSOP_POPN);
1227:                     len = oplen = JSOP_POPN_LENGTH;
   1:                     goto end_groupassignment;
   1:                 }
   1: #endif
   1:                 /* FALL THROUGH */
   1: 
   1:               case JSOP_BINDNAME:
   1:                 todo = Sprint(&ss->sprinter, "");
   1:                 break;
   1: 
   1:               case JSOP_TRY:
   1:                 js_printf(CLEAR_MAYBE_BRACE(jp), "\ttry {\n");
   1:                 jp->indent += 4;
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_FINALLY:
   1:                 jp->indent -= 4;
   1:                 js_printf(CLEAR_MAYBE_BRACE(jp), "\t} finally {\n");
   1:                 jp->indent += 4;
   1: 
   1:                 /*
   1:                  * We must push an empty string placeholder for gosub's return
   1:                  * address, popped by JSOP_RETSUB and counted by script->depth
   1:                  * but not by ss->top (see JSOP_SETSP, below).
   1:                  */
   1:                 todo = Sprint(&ss->sprinter, exception_cookie);
   1:                 if (todo < 0 || !PushOff(ss, todo, op))
   1:                     return NULL;
   1:                 todo = Sprint(&ss->sprinter, retsub_pc_cookie);
   1:                 break;
   1: 
   1:               case JSOP_RETSUB:
   1:                 rval = POP_STR();
   1:                 LOCAL_ASSERT(strcmp(rval, retsub_pc_cookie) == 0);
   1:                 lval = POP_STR();
   1:                 LOCAL_ASSERT(strcmp(lval, exception_cookie) == 0);
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_SWAP:
   1:                 /*
   1:                  * We don't generate this opcode currently, and previously we
   1:                  * did not need to decompile it.  If old, serialized bytecode
   1:                  * uses it still, we should fall through and set todo = -2.
   1:                  */
   1:                 /* FALL THROUGH */
   1: 
   1:               case JSOP_GOSUB:
   1:               case JSOP_GOSUBX:
   1:                 /*
   1:                  * JSOP_GOSUB and GOSUBX have no effect on the decompiler's
   1:                  * string stack because the next op in bytecode order finds
   1:                  * the stack balanced by a JSOP_RETSUB executed elsewhere.
   1:                  */
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_SETSP:
1227:               case JSOP_POPN:
   1:               {
   1:                 uintN newtop, oldtop, i;
   1: 
   1:                 /*
   1:                  * The compiler models operand stack depth and fixes the stack
   1:                  * pointer on entry to a catch clause based on its depth model.
   1:                  * The decompiler must match the code generator's model, which
   1:                  * is why JSOP_FINALLY pushes a cookie that JSOP_RETSUB pops.
   1:                  */
1227:                 newtop = GET_UINT16(pc);
   1:                 oldtop = ss->top;
1227:                 if (op == JSOP_POPN)
1227:                     newtop = oldtop - newtop;
   1:                 LOCAL_ASSERT(newtop <= oldtop);
   1:                 todo = -2;
   1: 
1227:                 sn = js_GetSrcNote(jp->script, pc);
1227:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
1227:                     break;
   1: #if JS_HAS_DESTRUCTURING
   1:                 if (sn && SN_TYPE(sn) == SRC_GROUPASSIGN) {
   1:                     todo = Sprint(&ss->sprinter, "%s[] = [",
   1:                                   VarPrefix(sn));
   1:                     if (todo < 0)
   1:                         return NULL;
   1:                     for (i = newtop; i < oldtop; i++) {
   1:                         rval = OFF2STR(&ss->sprinter, ss->offsets[i]);
   1:                         if (Sprint(&ss->sprinter, ss_format,
   1:                                    (i == newtop) ? "" : ", ",
   1:                                    (i == oldtop - 1 && *rval == '\0')
   1:                                    ? ", " : rval) < 0) {
   1:                             return NULL;
   1:                         }
   1:                     }
   1:                     if (SprintPut(&ss->sprinter, "]", 1) < 0)
   1:                         return NULL;
   1: 
   1:                     /*
   1:                      * Kill newtop before the end_groupassignment: label by
   1:                      * retracting/popping early.  Control will either jump to
   1:                      * do_forloop: or do_letheadbody: or else break from our
   1:                      * case JSOP_SETSP: after the switch (*pc2) below.
   1:                      */
   1:                     if (newtop < oldtop) {
   1:                         ss->sprinter.offset = GetOff(ss, newtop);
   1:                         ss->top = newtop;
   1:                     }
   1: 
   1:                   end_groupassignment:
   1:                     /*
   1:                      * Thread directly to the next opcode if we can, to handle
   1:                      * the special cases of a group assignment in the first or
   1:                      * last part of a for(;;) loop head, or in a let block or
   1:                      * expression head.
   1:                      *
   1:                      * NB: todo at this point indexes space in ss->sprinter
   1:                      * that is liable to be overwritten.  The code below knows
   1:                      * exactly how long rval lives, or else copies it down via
   1:                      * SprintCString.
   1:                      */
   1:                     rval = OFF2STR(&ss->sprinter, todo);
   1:                     todo = -2;
   1:                     pc2 = pc + oplen;
   1:                     switch (*pc2) {
   1:                       case JSOP_NOP:
   1:                         /* First part of for(;;) or let block/expr head. */
   1:                         sn = js_GetSrcNote(jp->script, pc2);
   1:                         if (sn) {
   1:                             if (SN_TYPE(sn) == SRC_FOR) {
   1:                                 pc = pc2;
   1:                                 goto do_forloop;
   1:                             }
   1:                             if (SN_TYPE(sn) == SRC_DECL) {
   1:                                 if (ss->top == jp->script->depth) {
   1:                                     /*
   1:                                      * This must be an empty destructuring
   1:                                      * in the head of a let whose body block
   1:                                      * is also empty.
   1:                                      */
   1:                                     pc = pc2 + 1;
   1:                                     len = js_GetSrcNoteOffset(sn, 0);
   1:                                     LOCAL_ASSERT(pc[len] == JSOP_LEAVEBLOCK);
   1:                                     js_printf(jp, "\tlet (%s) {\n", rval);
   1:                                     js_printf(jp, "\t}\n");
   1:                                     goto end_setsp;
   1:                                 }
   1:                                 todo = SprintCString(&ss->sprinter, rval);
   1:                                 if (todo < 0 || !PushOff(ss, todo, JSOP_NOP))
   1:                                     return NULL;
   1:                                 op = JSOP_POP;
   1:                                 pc = pc2 + 1;
   1:                                 goto do_letheadbody;
   1:                             }
   1:                         }
   1:                         break;
   1: 
   1:                       case JSOP_GOTO:
   1:                       case JSOP_GOTOX:
   1:                         /* Third part of for(;;) loop head. */
   1:                         cond = GetJumpOffset(pc2, pc2);
   1:                         sn = js_GetSrcNote(jp->script, pc2 + cond - 1);
   1:                         if (sn && SN_TYPE(sn) == SRC_FOR) {
   1:                             todo = SprintCString(&ss->sprinter, rval);
   1:                             saveop = JSOP_NOP;
   1:                         }
   1:                         break;
   1:                     }
   1: 
   1:                     /*
   1:                      * If control flow reaches this point with todo still -2,
   1:                      * just print rval as an expression statement.
   1:                      */
   1:                     if (todo == -2)
   1:                         js_printf(jp, "\t%s;\n", rval);
   1:                   end_setsp:
   1:                     break;
   1:                 }
   1: #endif
   1:                 if (newtop < oldtop) {
   1:                     ss->sprinter.offset = GetOff(ss, newtop);
   1:                     ss->top = newtop;
   1:                 }
   1:                 break;
   1:               }
   1: 
   1:               case JSOP_EXCEPTION:
   1:                 /* The catch decompiler handles this op itself. */
   1:                 LOCAL_ASSERT(JS_FALSE);
   1:                 break;
   1: 
   1:               case JSOP_POP:
   1:                 /*
   1:                  * By default, do not automatically parenthesize when popping
   1:                  * a stacked expression decompilation.  We auto-parenthesize
   1:                  * only when JSOP_POP is annotated with SRC_PCDELTA, meaning
   1:                  * comma operator.
   1:                  */
   1:                 op = JSOP_POPV;
   1:                 /* FALL THROUGH */
   1: 
   1:               case JSOP_POPV:
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
   1:                   case SRC_FOR:
   1:                     /* Force parens around 'in' expression at 'for' front. */
   1:                     if (ss->opcodes[ss->top-1] == JSOP_IN)
   1:                         op = JSOP_LSH;
   1:                     rval = POP_STR();
   1:                     todo = -2;
   1:                     goto do_forloop;
   1: 
   1:                   case SRC_PCDELTA:
   1:                     /* Comma operator: use JSOP_POP for correct precedence. */
   1:                     op = JSOP_POP;
   1: 
   1:                     /* Pop and save to avoid blowing stack depth budget. */
   1:                     lval = JS_strdup(cx, POP_STR());
   1:                     if (!lval)
   1:                         return NULL;
   1: 
   1:                     /*
   1:                      * The offset tells distance to the end of the right-hand
   1:                      * operand of the comma operator.
   1:                      */
   1:                     done = pc + len;
   1:                     pc += js_GetSrcNoteOffset(sn, 0);
   1:                     len = 0;
   1: 
   1:                     if (!Decompile(ss, done, pc - done)) {
   1:                         JS_free(cx, (char *)lval);
   1:                         return NULL;
   1:                     }
   1: 
   1:                     /* Pop Decompile result and print comma expression. */
   1:                     rval = POP_STR();
   1:                     todo = Sprint(&ss->sprinter, "%s, %s", lval, rval);
   1:                     JS_free(cx, (char *)lval);
   1:                     break;
   1: 
   1:                   case SRC_HIDDEN:
   1:                     /* Hide this pop, it's from a goto in a with or for/in. */
   1:                     todo = -2;
   1:                     break;
   1: 
   1:                   case SRC_DECL:
   1:                     /* This pop is at the end of the let block/expr head. */
   1:                     pc += JSOP_POP_LENGTH;
   1: #if JS_HAS_DESTRUCTURING
   1:                   do_letheadbody:
   1: #endif
   1:                     len = js_GetSrcNoteOffset(sn, 0);
   1:                     if (pc[len] == JSOP_LEAVEBLOCK) {
   1:                         js_printf(CLEAR_MAYBE_BRACE(jp), "\tlet (%s) {\n",
   1:                                   POP_STR());
   1:                         jp->indent += 4;
   1:                         DECOMPILE_CODE(pc, len);
   1:                         jp->indent -= 4;
   1:                         js_printf(jp, "\t}\n");
   1:                         todo = -2;
   1:                     } else {
   1:                         LOCAL_ASSERT(pc[len] == JSOP_LEAVEBLOCKEXPR);
   1: 
   1:                         lval = JS_strdup(cx, POP_STR());
   1:                         if (!lval)
   1:                             return NULL;
   1: 
   1:                         if (!Decompile(ss, pc, len)) {
   1:                             JS_free(cx, (char *)lval);
   1:                             return NULL;
   1:                         }
   1:                         rval = POP_STR();
   1:                         todo = Sprint(&ss->sprinter,
   1:                                       (*rval == '{')
   1:                                       ? "let (%s) (%s)"
   1:                                       : "let (%s) %s",
   1:                                       lval, rval);
   1:                         JS_free(cx, (char *)lval);
   1:                     }
   1:                     break;
   1: 
   1:                   default:
   1:                     /* Turn off parens around a yield statement. */
   1:                     if (ss->opcodes[ss->top-1] == JSOP_YIELD)
   1:                         op = JSOP_NOP;
   1: 
   1:                     rval = POP_STR();
   1:                     if (*rval != '\0') {
   1: #if JS_HAS_BLOCK_SCOPE
   1:                         /*
   1:                          * If a let declaration is the only child of a control
   1:                          * structure that does not require braces, it must not
   1:                          * be braced.  If it were braced explicitly, it would
   1:                          * be bracketed by JSOP_ENTERBLOCK/JSOP_LEAVEBLOCK.
   1:                          */
   1:                         if (jp->braceState == MAYBE_BRACE &&
   1:                             pc + JSOP_POP_LENGTH == endpc &&
   1:                             !strncmp(rval, var_prefix[SRC_DECL_LET], 4) &&
   1:                             rval[4] != '(') {
   1:                             SetDontBrace(jp);
   1:                         }
   1: #endif
   1:                         js_printf(jp,
   1:                                   (*rval == '{' ||
   1:                                    (strncmp(rval, js_function_str, 8) == 0 &&
   1:                                     rval[8] == ' '))
   1:                                   ? "\t(%s);\n"
   1:                                   : "\t%s;\n",
   1:                                   rval);
   1:                     }
   1:                     todo = -2;
   1:                     break;
   1:                 }
 351:                 sn = NULL;
   1:                 break;
   1: 
   1:               case JSOP_ENDITER:
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 todo = -2;
   1:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
   1:                     break;
   1:                 (void) PopOff(ss, op);
   1:                 break;
   1: 
   1:               case JSOP_ENTERWITH:
   1:                 LOCAL_ASSERT(!js_GetSrcNote(jp->script, pc));
   1:                 rval = POP_STR();
   1:                 js_printf(SET_MAYBE_BRACE(jp), "\twith (%s) {\n", rval);
   1:                 jp->indent += 4;
   1:                 todo = Sprint(&ss->sprinter, with_cookie);
   1:                 break;
   1: 
   1:               case JSOP_LEAVEWITH:
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 todo = -2;
   1:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
   1:                     break;
   1:                 rval = POP_STR();
   1:                 LOCAL_ASSERT(strcmp(rval, with_cookie) == 0);
   1:                 jp->indent -= 4;
   1:                 js_printf(jp, "\t}\n");
   1:                 break;
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_ENTERBLOCK, 0)
   1:               {
   1:                 JSAtom **atomv, *smallv[5];
   1:                 JSScopeProperty *sprop;
   1: 
   1:                 obj = ATOM_TO_OBJECT(atom);
   1:                 argc = OBJ_BLOCK_COUNT(cx, obj);
   1:                 if ((size_t)argc <= sizeof smallv / sizeof smallv[0]) {
   1:                     atomv = smallv;
   1:                 } else {
   1:                     atomv = (JSAtom **) JS_malloc(cx, argc * sizeof(JSAtom *));
   1:                     if (!atomv)
   1:                         return NULL;
   1:                 }
   1: 
   1:                 /* From here on, control must flow through enterblock_out. */
   1:                 for (sprop = OBJ_SCOPE(obj)->lastProp; sprop;
   1:                      sprop = sprop->parent) {
   1:                     if (!(sprop->flags & SPROP_HAS_SHORTID))
   1:                         continue;
   1:                     LOCAL_ASSERT(sprop->shortid < argc);
   1:                     atomv[sprop->shortid] = JSID_TO_ATOM(sprop->id);
   1:                 }
   1:                 ok = JS_TRUE;
   1:                 for (i = 0; i < argc; i++) {
   1:                     atom = atomv[i];
   1:                     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                     if (!rval ||
   1:                         !PushOff(ss, STR2OFF(&ss->sprinter, rval), op)) {
   1:                         ok = JS_FALSE;
   1:                         goto enterblock_out;
   1:                     }
   1:                 }
   1: 
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
   1: #if JS_HAS_BLOCK_SCOPE
   1:                   case SRC_BRACE:
   1:                     js_printf(CLEAR_MAYBE_BRACE(jp), "\t{\n");
   1:                     jp->indent += 4;
   1:                     len = js_GetSrcNoteOffset(sn, 0);
   1:                     ok = Decompile(ss, pc + oplen, len - oplen) != NULL;
   1:                     if (!ok)
   1:                         goto enterblock_out;
   1:                     jp->indent -= 4;
   1:                     js_printf(jp, "\t}\n");
   1:                     break;
   1: #endif
   1: 
   1:                   case SRC_CATCH:
   1:                     jp->indent -= 4;
   1:                     js_printf(CLEAR_MAYBE_BRACE(jp), "\t} catch (");
   1: 
   1:                     pc2 = pc;
   1:                     pc += oplen;
   1:                     LOCAL_ASSERT(*pc == JSOP_EXCEPTION);
   1:                     pc += JSOP_EXCEPTION_LENGTH;
 990:                     todo = Sprint(&ss->sprinter, exception_cookie);
 990:                     if (todo < 0 || !PushOff(ss, todo, JSOP_EXCEPTION)) {
 990:                         ok = JS_FALSE;
 990:                         goto enterblock_out;
 990:                     }
 990: 
   1:                     if (*pc == JSOP_DUP) {
   1:                         sn2 = js_GetSrcNote(jp->script, pc);
 990:                         if (!sn2 || SN_TYPE(sn2) != SRC_DESTRUCT) {
   1:                             /*
 990:                              * This is a dup to save the exception for later.
 990:                              * It is emitted only when the catch head contains
 190:                              * an exception guard.
   1:                              */
 190:                             LOCAL_ASSERT(js_GetSrcNoteOffset(sn, 0) != 0);
   1:                             pc += JSOP_DUP_LENGTH;
 990:                             todo = Sprint(&ss->sprinter, exception_cookie);
 990:                             if (todo < 0 ||
 990:                                 !PushOff(ss, todo, JSOP_EXCEPTION)) {
 990:                                 ok = JS_FALSE;
 990:                                 goto enterblock_out;
 990:                             }
 990:                         }
 990:                     }
 990: 
   1: #if JS_HAS_DESTRUCTURING
   1:                     if (*pc == JSOP_DUP) {
   1:                         pc = DecompileDestructuring(ss, pc, endpc);
   1:                         if (!pc) {
   1:                             ok = JS_FALSE;
   1:                             goto enterblock_out;
   1:                         }
   1:                         LOCAL_ASSERT(*pc == JSOP_POP);
   1:                         pc += JSOP_POP_LENGTH;
   1:                         lval = PopStr(ss, JSOP_NOP);
   1:                         js_puts(jp, lval);
   1:                     } else {
   1: #endif
   1:                         LOCAL_ASSERT(*pc == JSOP_SETLOCALPOP);
   1:                         i = GET_UINT16(pc);
   1:                         pc += JSOP_SETLOCALPOP_LENGTH;
   1:                         atom = atomv[i - OBJ_BLOCK_DEPTH(cx, obj)];
   1:                         str = ATOM_TO_STRING(atom);
   1:                         if (!QuoteString(&jp->sprinter, str, 0)) {
   1:                             ok = JS_FALSE;
   1:                             goto enterblock_out;
   1:                         }
   1: #if JS_HAS_DESTRUCTURING
   1:                     }
   1: #endif
   1: 
1041:                     /*
1041:                      * Pop the exception_cookie (or its dup in the case of a
1041:                      * guarded catch head) off the stack now.
1041:                      */
1041:                     rval = PopStr(ss, JSOP_NOP);
1041:                     LOCAL_ASSERT(strcmp(rval, exception_cookie) == 0);
1041: 
   1:                     len = js_GetSrcNoteOffset(sn, 0);
   1:                     if (len) {
   1:                         len -= PTRDIFF(pc, pc2, jsbytecode);
   1:                         LOCAL_ASSERT(len > 0);
   1:                         js_printf(jp, " if ");
   1:                         ok = Decompile(ss, pc, len) != NULL;
   1:                         if (!ok)
   1:                             goto enterblock_out;
   1:                         js_printf(jp, "%s", POP_STR());
   1:                         pc += len;
   1:                         LOCAL_ASSERT(*pc == JSOP_IFEQ || *pc == JSOP_IFEQX);
   1:                         pc += js_CodeSpec[*pc].length;
   1:                     }
   1: 
   1:                     js_printf(jp, ") {\n");
   1:                     jp->indent += 4;
   1:                     len = 0;
   1:                     break;
   1:                 }
   1: 
   1:                 todo = -2;
   1: 
   1:               enterblock_out:
   1:                 if (atomv != smallv)
   1:                     JS_free(cx, atomv);
   1:                 if (!ok)
   1:                     return NULL;
   1:               }
   1:               END_LITOPX_CASE
   1: 
   1:               case JSOP_LEAVEBLOCK:
   1:               case JSOP_LEAVEBLOCKEXPR:
   1:               {
   1:                 uintN top, depth;
   1: 
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 todo = -2;
   1:                 if (op == JSOP_LEAVEBLOCKEXPR) {
   1:                     LOCAL_ASSERT(SN_TYPE(sn) == SRC_PCBASE);
   1:                     rval = POP_STR();
   1:                 } else if (sn) {
   1:                     LOCAL_ASSERT(op == JSOP_LEAVEBLOCK);
   1:                     if (SN_TYPE(sn) == SRC_HIDDEN)
   1:                         break;
 990: 
 990:                     /*
 990:                      * This JSOP_LEAVEBLOCK must be for a catch block. If sn's
 990:                      * offset does not equal the model stack depth, there must
 990:                      * be a copy of the exception value on the stack due to a
 990:                      * catch guard (see above, the JSOP_ENTERBLOCK + SRC_CATCH
 990:                      * case code).
 990:                      */
   1:                     LOCAL_ASSERT(SN_TYPE(sn) == SRC_CATCH);
 990:                     if ((uintN)js_GetSrcNoteOffset(sn, 0) != ss->top) {
 990:                         LOCAL_ASSERT((uintN)js_GetSrcNoteOffset(sn, 0)
 990:                                      == ss->top - 1);
 990:                         rval = POP_STR();
 990:                         LOCAL_ASSERT(strcmp(rval, exception_cookie) == 0);
 990:                     }
   1:                 }
   1:                 top = ss->top;
   1:                 depth = GET_UINT16(pc);
   1:                 LOCAL_ASSERT(top >= depth);
   1:                 top -= depth;
   1:                 ss->top = top;
   1:                 ss->sprinter.offset = GetOff(ss, top);
   1:                 if (op == JSOP_LEAVEBLOCKEXPR)
   1:                     todo = SprintCString(&ss->sprinter, rval);
   1:                 break;
   1:               }
   1: 
   1:               case JSOP_CALLLOCAL:
   1:               case JSOP_GETLOCAL:
   1:                 i = GET_UINT16(pc);
   1:                 LOCAL_ASSERT((uintN)i < ss->top);
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1: 
   1: #if JS_HAS_DESTRUCTURING
   1:                 if (sn && SN_TYPE(sn) == SRC_GROUPASSIGN) {
   1:                     pc = DecompileGroupAssignment(ss, pc, endpc, sn, &todo);
   1:                     if (!pc)
   1:                         return NULL;
1227:                     LOCAL_ASSERT(*pc == JSOP_POPN);
1227:                     len = oplen = JSOP_POPN_LENGTH;
   1:                     goto end_groupassignment;
   1:                 }
   1: #endif
   1: 
   1:                 rval = GetLocal(ss, i);
   1:                 todo = Sprint(&ss->sprinter, ss_format, VarPrefix(sn), rval);
   1:                 break;
   1: 
   1:               case JSOP_SETLOCAL:
   1:               case JSOP_SETLOCALPOP:
   1:                 i = GET_UINT16(pc);
   1:                 lval = GetStr(ss, i);
   1:                 rval = POP_STR();
   1:                 goto do_setlval;
   1: 
   1:               case JSOP_INCLOCAL:
   1:               case JSOP_DECLOCAL:
   1:                 i = GET_UINT16(pc);
   1:                 lval = GetLocal(ss, i);
   1:                 goto do_inclval;
   1: 
   1:               case JSOP_LOCALINC:
   1:               case JSOP_LOCALDEC:
   1:                 i = GET_UINT16(pc);
   1:                 lval = GetLocal(ss, i);
   1:                 goto do_lvalinc;
   1: 
   1:               case JSOP_FORLOCAL:
   1:                 i = GET_UINT16(pc);
   1:                 lval = GetStr(ss, i);
   1:                 atom = NULL;
   1:                 goto do_forlvalinloop;
   1: 
   1:               case JSOP_RETRVAL:
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_SETRVAL:
   1:               case JSOP_RETURN:
   1:                 rval = POP_STR();
   1:                 if (*rval != '\0')
   1:                     js_printf(jp, "\t%s %s;\n", js_return_str, rval);
   1:                 else
   1:                     js_printf(jp, "\t%s;\n", js_return_str);
   1:                 todo = -2;
   1:                 break;
   1: 
   1: #if JS_HAS_GENERATORS
   1:               case JSOP_YIELD:
   1:                 op = JSOP_SETNAME;      /* turn off most parens */
   1:                 rval = POP_STR();
   1:                 todo = (*rval != '\0')
   1:                        ? Sprint(&ss->sprinter,
   1:                                 (strncmp(rval, js_yield_str, 5) == 0 &&
   1:                                  (rval[5] == ' ' || rval[5] == '\0'))
   1:                                 ? "%s (%s)"
   1:                                 : "%s %s",
   1:                                 js_yield_str, rval)
   1:                        : SprintCString(&ss->sprinter, js_yield_str);
   1:                 break;
   1: 
   1:               case JSOP_ARRAYPUSH:
   1:               {
   1:                 uintN pos, blockpos, startpos;
   1:                 ptrdiff_t start;
   1: 
   1:                 rval = POP_STR();
   1:                 pos = ss->top;
   1:                 while ((op = ss->opcodes[--pos]) != JSOP_ENTERBLOCK &&
   1:                        op != JSOP_NEWINIT) {
   1:                     LOCAL_ASSERT(pos != 0);
   1:                 }
   1:                 blockpos = pos;
   1:                 while (ss->opcodes[pos] == JSOP_ENTERBLOCK) {
   1:                     if (pos == 0)
   1:                         break;
   1:                     --pos;
   1:                 }
   1:                 LOCAL_ASSERT(ss->opcodes[pos] == JSOP_NEWINIT);
   1:                 startpos = pos;
   1:                 start = ss->offsets[pos];
   1:                 LOCAL_ASSERT(ss->sprinter.base[start] == '[' ||
   1:                              ss->sprinter.base[start] == '#');
   1:                 pos = blockpos + 1;
   1:                 LOCAL_ASSERT(pos < ss->top);
   1:                 xval = OFF2STR(&ss->sprinter, ss->offsets[pos]);
   1:                 lval = OFF2STR(&ss->sprinter, start);
   1:                 RETRACT(&ss->sprinter, lval);
   1:                 todo = Sprint(&ss->sprinter, "%s%s%.*s",
   1:                               lval, rval, rval - xval, xval);
   1:                 if (todo < 0)
   1:                     return NULL;
   1:                 ss->offsets[startpos] = todo;
   1:                 todo = -2;
   1:                 break;
   1:               }
   1: #endif
   1: 
   1:               case JSOP_THROWING:
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_THROW:
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 todo = -2;
   1:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
   1:                     break;
   1:                 rval = POP_STR();
1154:                 js_printf(jp, "\t%s %s;\n", js_throw_str, rval);
   1:                 break;
   1: 
   1:               case JSOP_GOTO:
   1:               case JSOP_GOTOX:
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
   1:                   case SRC_WHILE:
   1:                     cond = GetJumpOffset(pc, pc);
   1:                     tail = js_GetSrcNoteOffset(sn, 0);
   1:                     DECOMPILE_CODE(pc + cond, tail - cond);
   1:                     rval = POP_STR();
   1:                     js_printf(SET_MAYBE_BRACE(jp), "\twhile (%s) {\n", rval);
   1:                     jp->indent += 4;
   1:                     DECOMPILE_CODE(pc + oplen, cond - oplen);
   1:                     jp->indent -= 4;
   1:                     js_printf(jp, "\t}\n");
   1:                     pc += tail;
   1:                     LOCAL_ASSERT(*pc == JSOP_IFNE || *pc == JSOP_IFNEX);
   1:                     len = js_CodeSpec[*pc].length;
   1:                     todo = -2;
   1:                     break;
   1: 
   1:                   case SRC_CONT2LABEL:
   1:                     atom = js_GetAtom(cx, &jp->script->atomMap,
   1:                                       (jsatomid) js_GetSrcNoteOffset(sn, 0));
   1:                     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                     if (!rval)
   1:                         return NULL;
   1:                     RETRACT(&ss->sprinter, rval);
   1:                     js_printf(jp, "\tcontinue %s;\n", rval);
   1:                     break;
   1: 
   1:                   case SRC_CONTINUE:
   1:                     js_printf(jp, "\tcontinue;\n");
   1:                     break;
   1: 
   1:                   case SRC_BREAK2LABEL:
   1:                     atom = js_GetAtom(cx, &jp->script->atomMap,
   1:                                       (jsatomid) js_GetSrcNoteOffset(sn, 0));
   1:                     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                     if (!rval)
   1:                         return NULL;
   1:                     RETRACT(&ss->sprinter, rval);
   1:                     js_printf(jp, "\tbreak %s;\n", rval);
   1:                     break;
   1: 
   1:                   case SRC_HIDDEN:
   1:                     break;
   1: 
   1:                   default:
   1:                     js_printf(jp, "\tbreak;\n");
   1:                     break;
   1:                 }
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_IFEQ:
   1:               case JSOP_IFEQX:
   1:               {
   1:                 JSBool elseif = JS_FALSE;
   1: 
   1:               if_again:
   1:                 len = GetJumpOffset(pc, pc);
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1: 
   1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
   1:                   case SRC_IF:
   1:                   case SRC_IF_ELSE:
   1:                     op = JSOP_NOP;              /* turn off parens */
   1:                     rval = POP_STR();
   1:                     if (ss->inArrayInit) {
   1:                         LOCAL_ASSERT(SN_TYPE(sn) == SRC_IF);
   1:                         if (Sprint(&ss->sprinter, " if (%s)", rval) < 0)
   1:                             return NULL;
   1:                     } else {
   1:                         js_printf(SET_MAYBE_BRACE(jp),
   1:                                   elseif ? " if (%s) {\n" : "\tif (%s) {\n",
   1:                                   rval);
   1:                         jp->indent += 4;
   1:                     }
   1: 
   1:                     if (SN_TYPE(sn) == SRC_IF) {
   1:                         DECOMPILE_CODE(pc + oplen, len - oplen);
   1:                     } else {
   1:                         LOCAL_ASSERT(!ss->inArrayInit);
   1:                         tail = js_GetSrcNoteOffset(sn, 0);
   1:                         DECOMPILE_CODE(pc + oplen, tail - oplen);
   1:                         jp->indent -= 4;
   1:                         pc += tail;
   1:                         LOCAL_ASSERT(*pc == JSOP_GOTO || *pc == JSOP_GOTOX);
   1:                         oplen = js_CodeSpec[*pc].length;
   1:                         len = GetJumpOffset(pc, pc);
   1:                         js_printf(jp, "\t} else");
   1: 
   1:                         /*
   1:                          * If the second offset for sn is non-zero, it tells
   1:                          * the distance from the goto around the else, to the
   1:                          * ifeq for the if inside the else that forms an "if
   1:                          * else if" chain.  Thus cond spans the condition of
   1:                          * the second if, so we simply decompile it and start
   1:                          * over at label if_again.
   1:                          */
   1:                         cond = js_GetSrcNoteOffset(sn, 1);
   1:                         if (cond != 0) {
   1:                             DECOMPILE_CODE(pc + oplen, cond - oplen);
   1:                             pc += cond;
   1:                             elseif = JS_TRUE;
   1:                             goto if_again;
   1:                         }
   1: 
   1:                         js_printf(SET_MAYBE_BRACE(jp), " {\n");
   1:                         jp->indent += 4;
   1:                         DECOMPILE_CODE(pc + oplen, len - oplen);
   1:                     }
   1: 
   1:                     if (!ss->inArrayInit) {
   1:                         jp->indent -= 4;
   1:                         js_printf(jp, "\t}\n");
   1:                     }
   1:                     todo = -2;
   1:                     break;
   1: 
   1:                   case SRC_COND:
   1:                     xval = JS_strdup(cx, POP_STR());
   1:                     if (!xval)
   1:                         return NULL;
   1:                     len = js_GetSrcNoteOffset(sn, 0);
   1:                     DECOMPILE_CODE(pc + oplen, len - oplen);
   1:                     lval = JS_strdup(cx, POP_STR());
   1:                     if (!lval) {
   1:                         JS_free(cx, (void *)xval);
   1:                         return NULL;
   1:                     }
   1:                     pc += len;
   1:                     LOCAL_ASSERT(*pc == JSOP_GOTO || *pc == JSOP_GOTOX);
   1:                     oplen = js_CodeSpec[*pc].length;
   1:                     len = GetJumpOffset(pc, pc);
   1:                     DECOMPILE_CODE(pc + oplen, len - oplen);
   1:                     rval = POP_STR();
   1:                     todo = Sprint(&ss->sprinter, "%s ? %s : %s",
   1:                                   xval, lval, rval);
   1:                     JS_free(cx, (void *)xval);
   1:                     JS_free(cx, (void *)lval);
   1:                     break;
   1: 
   1:                   default:
   1:                     break;
   1:                 }
   1:                 break;
   1:               }
   1: 
   1:               case JSOP_IFNE:
   1:               case JSOP_IFNEX:
   1:                 LOCAL_ASSERT(0);
   1:                 break;
   1: 
   1:               case JSOP_OR:
   1:               case JSOP_ORX:
   1:                 xval = "||";
   1: 
   1:               do_logical_connective:
   1:                 /* Top of stack is the first clause in a disjunction (||). */
   1:                 lval = JS_strdup(cx, POP_STR());
   1:                 if (!lval)
   1:                     return NULL;
   1:                 done = pc + GetJumpOffset(pc, pc);
   1:                 pc += len;
   1:                 len = PTRDIFF(done, pc, jsbytecode);
   1:                 DECOMPILE_CODE(pc, len);
   1:                 rval = POP_STR();
   1:                 if (jp->pretty &&
   1:                     jp->indent + 4 + strlen(lval) + 4 + strlen(rval) > 75) {
   1:                     rval = JS_strdup(cx, rval);
   1:                     if (!rval) {
   1:                         tail = -1;
   1:                     } else {
   1:                         todo = Sprint(&ss->sprinter, "%s %s\n", lval, xval);
   1:                         tail = Sprint(&ss->sprinter, "%*s%s",
   1:                                       jp->indent + 4, "", rval);
   1:                         JS_free(cx, (char *)rval);
   1:                     }
   1:                     if (tail < 0)
   1:                         todo = -1;
   1:                 } else {
   1:                     todo = Sprint(&ss->sprinter, "%s %s %s", lval, xval, rval);
   1:                 }
   1:                 JS_free(cx, (char *)lval);
   1:                 break;
   1: 
   1:               case JSOP_AND:
   1:               case JSOP_ANDX:
   1:                 xval = "&&";
   1:                 goto do_logical_connective;
   1: 
   1:               case JSOP_FORARG:
   1:                 atom = GetSlotAtom(jp, js_GetArgument, GET_ARGNO(pc));
   1:                 LOCAL_ASSERT(atom);
   1:                 goto do_fornameinloop;
   1: 
   1:               case JSOP_FORVAR:
   1:               case JSOP_FORCONST:
   1:                 atom = GetSlotAtom(jp, js_GetLocalVariable, GET_VARNO(pc));
   1:                 LOCAL_ASSERT(atom);
   1:                 goto do_fornameinloop;
   1: 
   1:               case JSOP_FORNAME:
   1:                 LOAD_ATOM(0);
   1: 
   1:               do_fornameinloop:
   1:                 lval = "";
   1:               do_forlvalinloop:
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 xval = NULL;
   1:                 goto do_forinloop;
   1: 
   1:               case JSOP_FORPROP:
   1:                 xval = NULL;
   1:                 LOAD_ATOM(0);
   1:                 if (!ATOM_IS_IDENTIFIER(atom)) {
   1:                     xval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
   1:                                        (jschar)'\'');
   1:                     if (!xval)
   1:                         return NULL;
   1:                     atom = NULL;
   1:                 }
   1:                 lval = POP_STR();
   1:                 sn = NULL;
   1: 
   1:               do_forinloop:
   1:                 pc += oplen;
   1:                 LOCAL_ASSERT(*pc == JSOP_IFEQ || *pc == JSOP_IFEQX);
   1:                 oplen = js_CodeSpec[*pc].length;
   1:                 len = GetJumpOffset(pc, pc);
   1:                 sn2 = js_GetSrcNote(jp->script, pc);
   1:                 tail = js_GetSrcNoteOffset(sn2, 0);
   1: 
   1:               do_forinhead:
   1:                 if (!atom && xval) {
   1:                     /*
   1:                      * If xval is not a dummy empty string, we have to strdup
   1:                      * it to save it from being clobbered by the first Sprint
   1:                      * below.  Standard dumb decompiler operating procedure!
   1:                      */
   1:                     if (*xval == '\0') {
   1:                         xval = NULL;
   1:                     } else {
   1:                         xval = JS_strdup(cx, xval);
   1:                         if (!xval)
   1:                             return NULL;
   1:                     }
   1:                 }
   1: 
   1: #if JS_HAS_XML_SUPPORT
   1:                 if (foreach) {
   1:                     foreach = JS_FALSE;
   1:                     todo = Sprint(&ss->sprinter, "for %s (%s%s",
   1:                                   js_each_str, VarPrefix(sn), lval);
   1:                 } else
   1: #endif
   1:                 {
   1:                     todo = Sprint(&ss->sprinter, "for (%s%s",
   1:                                   VarPrefix(sn), lval);
   1:                 }
   1:                 if (atom) {
   1:                     if (*lval && SprintPut(&ss->sprinter, ".", 1) < 0)
   1:                         return NULL;
   1:                     xval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                     if (!xval)
   1:                         return NULL;
   1:                 } else if (xval) {
   1:                     LOCAL_ASSERT(*xval != '\0');
   1:                     ok = (Sprint(&ss->sprinter,
   1:                                  (js_CodeSpec[lastop].format & JOF_XMLNAME)
   1:                                  ? ".%s"
   1:                                  : "[%s]",
   1:                                  xval)
   1:                           >= 0);
   1:                     JS_free(cx, (char *)xval);
   1:                     if (!ok)
   1:                         return NULL;
   1:                 }
   1:                 if (todo < 0)
   1:                     return NULL;
   1: 
   1:                 lval = OFF2STR(&ss->sprinter, todo);
   1:                 rval = GetStr(ss, ss->top-1);
   1:                 RETRACT(&ss->sprinter, rval);
   1:                 if (ss->inArrayInit) {
   1:                     todo = Sprint(&ss->sprinter, " %s in %s)", lval, rval);
   1:                     if (todo < 0)
   1:                         return NULL;
   1:                     ss->offsets[ss->top-1] = todo;
   1:                     ss->sprinter.offset += PAREN_SLOP;
   1:                     DECOMPILE_CODE(pc + oplen, tail - oplen);
   1:                 } else {
   1:                     js_printf(SET_MAYBE_BRACE(jp), "\t%s in %s) {\n",
   1:                               lval, rval);
   1:                     jp->indent += 4;
   1:                     DECOMPILE_CODE(pc + oplen, tail - oplen);
   1:                     jp->indent -= 4;
   1:                     js_printf(jp, "\t}\n");
   1:                 }
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_FORELEM:
   1:                 pc++;
   1:                 LOCAL_ASSERT(*pc == JSOP_IFEQ || *pc == JSOP_IFEQX);
   1:                 len = js_CodeSpec[*pc].length;
   1: 
   1:                 /*
   1:                  * Arrange for the JSOP_ENUMELEM case to set tail for use by
   1:                  * do_forinhead: code that uses on it to find the loop-closing
   1:                  * jump (whatever its format, normal or extended), in order to
   1:                  * bound the recursively decompiled loop body.
   1:                  */
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 LOCAL_ASSERT(!forelem_tail);
   1:                 forelem_tail = pc + js_GetSrcNoteOffset(sn, 0);
   1: 
   1:                 /*
   1:                  * This gets a little wacky.  Only the length of the for loop
   1:                  * body PLUS the element-indexing expression is known here, so
   1:                  * we pass the after-loop pc to the JSOP_ENUMELEM case, which
   1:                  * is immediately below, to decompile that helper bytecode via
   1:                  * the 'forelem_done' local.
   1:                  *
   1:                  * Since a for..in loop can't nest in the head of another for
   1:                  * loop, we can use forelem_{tail,done} singletons to remember
   1:                  * state from JSOP_FORELEM to JSOP_ENUMELEM, thence (via goto)
   1:                  * to label do_forinhead.
   1:                  */
   1:                 LOCAL_ASSERT(!forelem_done);
   1:                 forelem_done = pc + GetJumpOffset(pc, pc);
   1: 
   1:                 /* Our net stack balance after forelem;ifeq is +1. */
   1:                 todo = SprintCString(&ss->sprinter, forelem_cookie);
   1:                 break;
   1: 
   1:               case JSOP_ENUMELEM:
   1:               case JSOP_ENUMCONSTELEM:
   1:                 /*
   1:                  * The stack has the object under the (top) index expression.
   1:                  * The "rval" property id is underneath those two on the stack.
   1:                  * The for loop body net and gross lengths can now be adjusted
   1:                  * to account for the length of the indexing expression that
   1:                  * came after JSOP_FORELEM and before JSOP_ENUMELEM.
   1:                  */
   1:                 atom = NULL;
 351:                 op = JSOP_NOP;          /* turn off parens around xval */
   1:                 xval = POP_STR();
   1:                 op = JSOP_GETELEM;      /* lval must have high precedence */
   1:                 lval = POP_STR();
   1:                 op = saveop;
   1:                 rval = POP_STR();
   1:                 LOCAL_ASSERT(strcmp(rval, forelem_cookie) == 0);
   1:                 LOCAL_ASSERT(forelem_tail > pc);
   1:                 tail = forelem_tail - pc;
   1:                 forelem_tail = NULL;
   1:                 LOCAL_ASSERT(forelem_done > pc);
   1:                 len = forelem_done - pc;
   1:                 forelem_done = NULL;
   1:                 goto do_forinhead;
   1: 
   1: #if JS_HAS_GETTER_SETTER
   1:               case JSOP_GETTER:
   1:               case JSOP_SETTER:
   1:                 todo = -2;
   1:                 break;
   1: #endif
   1: 
   1:               case JSOP_DUP2:
   1:                 rval = GetStr(ss, ss->top-2);
   1:                 todo = SprintCString(&ss->sprinter, rval);
   1:                 if (todo < 0 || !PushOff(ss, todo, ss->opcodes[ss->top-2]))
   1:                     return NULL;
   1:                 /* FALL THROUGH */
   1: 
   1:               case JSOP_DUP:
   1: #if JS_HAS_DESTRUCTURING
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 if (sn) {
   1:                     LOCAL_ASSERT(SN_TYPE(sn) == SRC_DESTRUCT);
   1:                     pc = DecompileDestructuring(ss, pc, endpc);
   1:                     if (!pc)
   1:                         return NULL;
   1:                     len = 0;
   1:                     lval = POP_STR();
   1:                     op = saveop = JSOP_ENUMELEM;
   1:                     rval = POP_STR();
   1: 
   1:                     if (strcmp(rval, forelem_cookie) == 0) {
   1:                         LOCAL_ASSERT(forelem_tail > pc);
   1:                         tail = forelem_tail - pc;
   1:                         forelem_tail = NULL;
   1:                         LOCAL_ASSERT(forelem_done > pc);
   1:                         len = forelem_done - pc;
   1:                         forelem_done = NULL;
   1:                         xval = NULL;
   1:                         atom = NULL;
   1: 
   1:                         /*
   1:                          * Null sn if this is a 'for (var [k, v] = i in o)'
   1:                          * loop, because 'var [k, v = i;' has already been
   1:                          * hoisted.
   1:                          */
   1:                         if (js_GetSrcNoteOffset(sn, 0) == SRC_DECL_VAR)
   1:                             sn = NULL;
   1:                         goto do_forinhead;
   1:                     }
   1: 
   1:                     todo = Sprint(&ss->sprinter, "%s%s = %s",
   1:                                   VarPrefix(sn), lval, rval);
   1:                     break;
   1:                 }
   1: #endif
   1: 
   1:                 rval = GetStr(ss, ss->top-1);
   1:                 saveop = ss->opcodes[ss->top-1];
   1:                 todo = SprintCString(&ss->sprinter, rval);
   1:                 break;
   1: 
   1:               case JSOP_SETARG:
   1:                 atom = GetSlotAtom(jp, js_GetArgument, GET_ARGNO(pc));
   1:                 LOCAL_ASSERT(atom);
   1:                 goto do_setname;
   1: 
   1:               case JSOP_SETVAR:
   1:                 atom = GetSlotAtom(jp, js_GetLocalVariable, GET_VARNO(pc));
   1:                 LOCAL_ASSERT(atom);
   1:                 goto do_setname;
   1: 
   1:               case JSOP_SETCONST:
   1:               case JSOP_SETNAME:
   1:               case JSOP_SETGVAR:
   1:                 LOAD_ATOM(0);
   1: 
   1:               do_setname:
   1:                 lval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                 if (!lval)
   1:                     return NULL;
   1:                 rval = POP_STR();
   1:                 if (op == JSOP_SETNAME)
   1:                     (void) PopOff(ss, op);
   1: 
   1:               do_setlval:
   1:                 sn = js_GetSrcNote(jp->script, pc - 1);
   1:                 if (sn && SN_TYPE(sn) == SRC_ASSIGNOP) {
   1:                     todo = Sprint(&ss->sprinter, "%s %s= %s",
   1:                                   lval,
   1:                                   (lastop == JSOP_GETTER)
   1:                                   ? js_getter_str
   1:                                   : (lastop == JSOP_SETTER)
   1:                                   ? js_setter_str
1154:                                   : CodeToken[lastop],
   1:                                   rval);
   1:                 } else {
   1:                     sn = js_GetSrcNote(jp->script, pc);
   1:                     todo = Sprint(&ss->sprinter, "%s%s = %s",
   1:                                   VarPrefix(sn), lval, rval);
   1:                 }
   1:                 if (op == JSOP_SETLOCALPOP) {
   1:                     if (!PushOff(ss, todo, saveop))
   1:                         return NULL;
   1:                     rval = POP_STR();
   1:                     LOCAL_ASSERT(*rval != '\0');
   1:                     js_printf(jp, "\t%s;\n", rval);
   1:                     todo = -2;
   1:                 }
   1:                 break;
   1: 
   1:               case JSOP_NEW:
   1:               case JSOP_CALL:
   1:               case JSOP_EVAL:
   1: #if JS_HAS_LVALUE_RETURN
   1:               case JSOP_SETCALL:
   1: #endif
   1:                 op = JSOP_SETNAME;      /* turn off most parens */
   1:                 argc = GET_ARGC(pc);
   1:                 argv = (char **)
   1:                     JS_malloc(cx, (size_t)(argc + 1) * sizeof *argv);
   1:                 if (!argv)
   1:                     return NULL;
   1: 
   1:                 ok = JS_TRUE;
   1:                 for (i = argc; i > 0; i--) {
   1:                     argv[i] = JS_strdup(cx, POP_STR());
   1:                     if (!argv[i]) {
   1:                         ok = JS_FALSE;
   1:                         break;
   1:                     }
   1:                 }
   1: 
   1:                 /* Skip the JSOP_PUSHOBJ-created empty string. */
   1:                 LOCAL_ASSERT(ss->top >= 2);
   1:                 (void) PopOff(ss, op);
   1: 
 350:                 /*
 350:                  * Special case: new (x(y)(z)) must be parenthesized like so.
 350:                  * Same for new (x(y).z) -- contrast with new x(y).z.
 350:                  */
 350:                 op = ss->opcodes[ss->top-1];
 350:                 lval = PopStr(ss,
 350:                               (saveop == JSOP_NEW &&
 355:                                (op == JSOP_CALL || op == JSOP_EVAL ||
 350:                                 (js_CodeSpec[op].format & JOF_CALLOP)))
 350:                               ? JSOP_NAME
 350:                               : saveop);
   1:                 op = saveop;
 350: 
 350:                 argv[0] = JS_strdup(cx, lval);
   1:                 if (!argv[i])
   1:                     ok = JS_FALSE;
   1: 
   1:                 lval = "(", rval = ")";
   1:                 if (op == JSOP_NEW) {
   1:                     if (argc == 0)
   1:                         lval = rval = "";
   1:                     todo = Sprint(&ss->sprinter, "%s %s%s",
   1:                                   js_new_str, argv[0], lval);
   1:                 } else {
   1:                     todo = Sprint(&ss->sprinter, ss_format,
   1:                                   argv[0], lval);
   1:                 }
   1:                 if (todo < 0)
   1:                     ok = JS_FALSE;
   1: 
   1:                 for (i = 1; i <= argc; i++) {
   1:                     if (!argv[i] ||
   1:                         Sprint(&ss->sprinter, ss_format,
   1:                                argv[i], (i < argc) ? ", " : "") < 0) {
   1:                         ok = JS_FALSE;
   1:                         break;
   1:                     }
   1:                 }
   1:                 if (Sprint(&ss->sprinter, rval) < 0)
   1:                     ok = JS_FALSE;
   1: 
   1:                 for (i = 0; i <= argc; i++) {
   1:                     if (argv[i])
   1:                         JS_free(cx, argv[i]);
   1:                 }
   1:                 JS_free(cx, argv);
   1:                 if (!ok)
   1:                     return NULL;
   1: #if JS_HAS_LVALUE_RETURN
   1:                 if (op == JSOP_SETCALL) {
   1:                     if (!PushOff(ss, todo, op))
   1:                         return NULL;
   1:                     todo = Sprint(&ss->sprinter, "");
   1:                 }
   1: #endif
   1:                 break;
   1: 
   1:               case JSOP_DELNAME:
   1:                 LOAD_ATOM(0);
   1:                 lval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                 if (!lval)
   1:                     return NULL;
   1:                 RETRACT(&ss->sprinter, lval);
   1:               do_delete_lval:
   1:                 todo = Sprint(&ss->sprinter, "%s %s", js_delete_str, lval);
   1:                 break;
   1: 
   1:               case JSOP_DELPROP:
   1:                 GET_ATOM_QUOTE_AND_FMT("%s %s[%s]", "%s %s.%s", rval);
   1:                 lval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, fmt, js_delete_str, lval, rval);
   1:                 break;
   1: 
   1:               case JSOP_DELELEM:
   1:                 op = JSOP_NOP;          /* turn off parens */
   1:                 xval = POP_STR();
   1:                 op = saveop;
   1:                 lval = POP_STR();
   1:                 if (*xval == '\0')
   1:                     goto do_delete_lval;
   1:                 todo = Sprint(&ss->sprinter,
   1:                               (js_CodeSpec[lastop].format & JOF_XMLNAME)
   1:                               ? "%s %s.%s"
   1:                               : "%s %s[%s]",
   1:                               js_delete_str, lval, xval);
   1:                 break;
   1: 
   1: #if JS_HAS_XML_SUPPORT
   1:               case JSOP_DELDESC:
   1:                 xval = POP_STR();
   1:                 lval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, "%s %s..%s",
   1:                               js_delete_str, lval, xval);
   1:                 break;
   1: #endif
   1: 
   1:               case JSOP_TYPEOFEXPR:
   1:               case JSOP_TYPEOF:
   1:               case JSOP_VOID:
   1:                 rval = POP_STR();
1154:                 todo = Sprint(&ss->sprinter, "%s %s",
1154:                               (op == JSOP_VOID) ? js_void_str : js_typeof_str,
1154:                               rval);
   1:                 break;
   1: 
   1:               case JSOP_INCARG:
   1:               case JSOP_DECARG:
   1:                 atom = GetSlotAtom(jp, js_GetArgument, GET_ARGNO(pc));
   1:                 LOCAL_ASSERT(atom);
   1:                 goto do_incatom;
   1: 
   1:               case JSOP_INCVAR:
   1:               case JSOP_DECVAR:
   1:                 atom = GetSlotAtom(jp, js_GetLocalVariable, GET_VARNO(pc));
   1:                 LOCAL_ASSERT(atom);
   1:                 goto do_incatom;
   1: 
   1:               case JSOP_INCNAME:
   1:               case JSOP_DECNAME:
   1:               case JSOP_INCGVAR:
   1:               case JSOP_DECGVAR:
   1:                 LOAD_ATOM(0);
   1:               do_incatom:
   1:                 lval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                 if (!lval)
   1:                     return NULL;
   1:                 RETRACT(&ss->sprinter, lval);
   1:               do_inclval:
   1:                 todo = Sprint(&ss->sprinter, ss_format,
   1:                               js_incop_strs[!(cs->format & JOF_INC)], lval);
   1:                 break;
   1: 
   1:               case JSOP_INCPROP:
   1:               case JSOP_DECPROP:
   1:                 GET_ATOM_QUOTE_AND_FMT(preindex_format, predot_format, rval);
   1: 
   1:                 /*
   1:                  * Force precedence below the numeric literal opcodes, so that
   1:                  * 42..foo or 10000..toString(16), e.g., decompile with parens
   1:                  * around the left-hand side of dot.
   1:                  */
   1:                 op = JSOP_GETPROP;
   1:                 lval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, fmt,
   1:                               js_incop_strs[!(cs->format & JOF_INC)],
   1:                               lval, rval);
   1:                 break;
   1: 
   1:               case JSOP_INCELEM:
   1:               case JSOP_DECELEM:
   1:                 op = JSOP_NOP;          /* turn off parens */
   1:                 xval = POP_STR();
   1:                 op = JSOP_GETELEM;
   1:                 lval = POP_STR();
   1:                 if (*xval != '\0') {
   1:                     todo = Sprint(&ss->sprinter,
   1:                                   (js_CodeSpec[lastop].format & JOF_XMLNAME)
   1:                                   ? predot_format
   1:                                   : preindex_format,
   1:                                   js_incop_strs[!(cs->format & JOF_INC)],
   1:                                   lval, xval);
   1:                 } else {
   1:                     todo = Sprint(&ss->sprinter, ss_format,
   1:                                   js_incop_strs[!(cs->format & JOF_INC)], lval);
   1:                 }
   1:                 break;
   1: 
   1:               case JSOP_ARGINC:
   1:               case JSOP_ARGDEC:
   1:                 atom = GetSlotAtom(jp, js_GetArgument, GET_ARGNO(pc));
   1:                 LOCAL_ASSERT(atom);
   1:                 goto do_atominc;
   1: 
   1:               case JSOP_VARINC:
   1:               case JSOP_VARDEC:
   1:                 atom = GetSlotAtom(jp, js_GetLocalVariable, GET_VARNO(pc));
   1:                 LOCAL_ASSERT(atom);
   1:                 goto do_atominc;
   1: 
   1:               case JSOP_NAMEINC:
   1:               case JSOP_NAMEDEC:
   1:               case JSOP_GVARINC:
   1:               case JSOP_GVARDEC:
   1:                 LOAD_ATOM(0);
   1:               do_atominc:
   1:                 lval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                 if (!lval)
   1:                     return NULL;
   1:                 RETRACT(&ss->sprinter, lval);
   1:               do_lvalinc:
   1:                 todo = Sprint(&ss->sprinter, ss_format,
   1:                               lval, js_incop_strs[!(cs->format & JOF_INC)]);
   1:                 break;
   1: 
   1:               case JSOP_PROPINC:
   1:               case JSOP_PROPDEC:
   1:                 GET_ATOM_QUOTE_AND_FMT(postindex_format, postdot_format, rval);
   1: 
   1:                 /*
   1:                  * Force precedence below the numeric literal opcodes, so that
   1:                  * 42..foo or 10000..toString(16), e.g., decompile with parens
   1:                  * around the left-hand side of dot.
   1:                  */
   1:                 op = JSOP_GETPROP;
   1:                 lval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, fmt, lval, rval,
   1:                               js_incop_strs[!(cs->format & JOF_INC)]);
   1:                 break;
   1: 
   1:               case JSOP_ELEMINC:
   1:               case JSOP_ELEMDEC:
   1:                 op = JSOP_NOP;          /* turn off parens */
   1:                 xval = POP_STR();
   1:                 op = JSOP_GETELEM;
   1:                 lval = POP_STR();
   1:                 if (*xval != '\0') {
   1:                     todo = Sprint(&ss->sprinter,
   1:                                   (js_CodeSpec[lastop].format & JOF_XMLNAME)
   1:                                   ? postdot_format
   1:                                   : postindex_format,
   1:                                   lval, xval,
   1:                                   js_incop_strs[!(cs->format & JOF_INC)]);
   1:                 } else {
   1:                     todo = Sprint(&ss->sprinter, ss_format,
   1:                                   lval, js_incop_strs[!(cs->format & JOF_INC)]);
   1:                 }
   1:                 break;
   1: 
   1:               case JSOP_GETPROP2:
   1:                 op = JSOP_GETPROP;
   1:                 (void) PopOff(ss, lastop);
   1:                 /* FALL THROUGH */
   1: 
   1: #if JS_HAS_XML_SUPPORT
   1:               case JSOP_CALLPROP:
   1: #endif
   1:               case JSOP_GETPROP:
   1:               case JSOP_GETXPROP:
   1:                 LOAD_ATOM(0);
   1: 
   1:               do_getprop:
   1:                 GET_QUOTE_AND_FMT(index_format, dot_format, rval);
   1:                 lval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, fmt, lval, rval);
   1:                 break;
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_GETTHISPROP, 0)
   1:                 GET_QUOTE_AND_FMT(index_format, dot_format, rval);
   1:                 todo = Sprint(&ss->sprinter, fmt, js_this_str, rval);
   1:               END_LITOPX_CASE
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_GETARGPROP, ARGNO_LEN)
   1:                 if (!PushSlotAtom(ss, js_GetArgument, GET_ARGNO(pc), op))
   1:                     return NULL;
   1:                 goto do_getprop;
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_GETVARPROP, VARNO_LEN)
   1:                 if (!PushSlotAtom(ss, js_GetLocalVariable, GET_VARNO(pc), op))
   1:                     return NULL;
   1:                 goto do_getprop;
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_GETLOCALPROP, 2)
   1:                 i = GET_UINT16(pc);
   1:                 LOCAL_ASSERT((uintN)i < ss->top);
   1:                 lval = GetLocal(ss, i);
   1:                 if (!lval)
   1:                     return NULL;
   1:                 todo = SprintCString(&ss->sprinter, lval);
   1:                 if (todo < 0 || !PushOff(ss, todo, op))
   1:                     return NULL;
   1:                 goto do_getprop;
   1: 
   1:               case JSOP_SETPROP:
   1:                 LOAD_ATOM(0);
   1:                 GET_QUOTE_AND_FMT("%s[%s] %s= %s", "%s.%s %s= %s", xval);
   1:                 rval = POP_STR();
   1: 
   1:                 /*
   1:                  * Force precedence below the numeric literal opcodes, so that
   1:                  * 42..foo or 10000..toString(16), e.g., decompile with parens
   1:                  * around the left-hand side of dot.
   1:                  */
   1:                 op = JSOP_GETPROP;
   1:                 lval = POP_STR();
   1:                 sn = js_GetSrcNote(jp->script, pc - 1);
   1:                 todo = Sprint(&ss->sprinter, fmt, lval, xval,
   1:                               (sn && SN_TYPE(sn) == SRC_ASSIGNOP)
   1:                               ? (lastop == JSOP_GETTER)
   1:                                 ? js_getter_str
   1:                                 : (lastop == JSOP_SETTER)
   1:                                 ? js_setter_str
1154:                                 : CodeToken[lastop]
   1:                               : "",
   1:                               rval);
   1:                 break;
   1: 
   1:               case JSOP_GETELEM2:
   1:                 op = JSOP_GETELEM;
   1:                 (void) PopOff(ss, lastop);
   1:                 /* FALL THROUGH */
   1: 
   1:               case JSOP_CALLELEM:
   1:               case JSOP_GETELEM:
   1:                 op = JSOP_NOP;          /* turn off parens */
   1:                 xval = POP_STR();
   1:                 op = saveop;
   1:                 lval = POP_STR();
   1:                 if (*xval == '\0') {
   1:                     todo = Sprint(&ss->sprinter, "%s", lval);
   1:                 } else {
   1:                     todo = Sprint(&ss->sprinter,
   1:                                   (js_CodeSpec[lastop].format & JOF_XMLNAME)
   1:                                   ? dot_format
   1:                                   : index_format,
   1:                                   lval, xval);
   1:                 }
   1:                 break;
   1: 
   1:               case JSOP_SETELEM:
   1:                 rval = POP_STR();
   1:                 op = JSOP_NOP;          /* turn off parens */
   1:                 xval = POP_STR();
   1:                 cs = &js_CodeSpec[ss->opcodes[ss->top]];
   1:                 op = JSOP_GETELEM;      /* lval must have high precedence */
   1:                 lval = POP_STR();
   1:                 op = saveop;
   1:                 if (*xval == '\0')
   1:                     goto do_setlval;
   1:                 sn = js_GetSrcNote(jp->script, pc - 1);
   1:                 todo = Sprint(&ss->sprinter,
   1:                               (cs->format & JOF_XMLNAME)
   1:                               ? "%s.%s %s= %s"
   1:                               : "%s[%s] %s= %s",
   1:                               lval, xval,
   1:                               (sn && SN_TYPE(sn) == SRC_ASSIGNOP)
   1:                               ? (lastop == JSOP_GETTER)
   1:                                 ? js_getter_str
   1:                                 : (lastop == JSOP_SETTER)
   1:                                 ? js_setter_str
1154:                                 : CodeToken[lastop]
   1:                               : "",
   1:                               rval);
   1:                 break;
   1: 
   1:               case JSOP_ARGSUB:
   1:                 i = (jsint) GET_ARGNO(pc);
   1:                 todo = Sprint(&ss->sprinter, "%s[%d]",
   1:                               js_arguments_str, (int) i);
   1:                 break;
   1: 
   1:               case JSOP_ARGCNT:
   1:                 todo = Sprint(&ss->sprinter, dot_format,
   1:                               js_arguments_str, js_length_str);
   1:                 break;
   1: 
   1:               case JSOP_CALLARG:
   1:               case JSOP_GETARG:
   1:                 i = GET_ARGNO(pc);
   1:                 atom = GetSlotAtom(jp, js_GetArgument, i);
   1: #if JS_HAS_DESTRUCTURING
   1:                 if (!atom) {
   1:                     todo = Sprint(&ss->sprinter, "%s[%d]", js_arguments_str, i);
   1:                     break;
   1:                 }
   1: #else
   1:                 LOCAL_ASSERT(atom);
   1: #endif
   1:                 goto do_name;
   1: 
   1:               case JSOP_CALLVAR:
   1:               case JSOP_GETVAR:
   1:                 atom = GetSlotAtom(jp, js_GetLocalVariable, GET_VARNO(pc));
   1:                 LOCAL_ASSERT(atom);
   1:                 goto do_name;
   1: 
   1:               case JSOP_CALLNAME:
   1:               case JSOP_NAME:
   1:               case JSOP_GETGVAR:
   1:               case JSOP_CALLGVAR:
   1:                 LOAD_ATOM(0);
   1:               do_name:
   1:                 lval = "";
   1:               do_qname:
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
   1:                                    inXML ? DONT_ESCAPE : 0);
   1:                 if (!rval)
   1:                     return NULL;
   1:                 RETRACT(&ss->sprinter, rval);
   1:                 todo = Sprint(&ss->sprinter, "%s%s%s",
   1:                               VarPrefix(sn), lval, rval);
   1:                 break;
   1: 
   1:               case JSOP_UINT16:
   1:                 i = (jsint) GET_UINT16(pc);
   1:                 goto do_sprint_int;
   1: 
   1:               case JSOP_UINT24:
   1:                 i = (jsint) GET_UINT24(pc);
   1:               do_sprint_int:
   1:                 todo = Sprint(&ss->sprinter, "%u", (unsigned) i);
   1:                 break;
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_NUMBER, 0)
   1:                 val = ATOM_KEY(atom);
 259:                 todo = JSVAL_IS_INT(val)
 259:                        ? Sprint(&ss->sprinter, "%ld", (long) JSVAL_TO_INT(val))
 259:                        : SprintDoubleValue(&ss->sprinter, val, &saveop);
   1:               END_LITOPX_CASE
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_STRING, 0)
   1:                 rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
   1:                                    inXML ? DONT_ESCAPE : '"');
   1:                 if (!rval)
   1:                     return NULL;
   1:                 todo = STR2OFF(&ss->sprinter, rval);
   1:               END_LITOPX_CASE
   1: 
   1:               case JSOP_OBJECT:
   1:               case JSOP_REGEXP:
   1:               case JSOP_ANONFUNOBJ:
   1:               case JSOP_NAMEDFUNOBJ:
   1:                 LOAD_ATOM(0);
   1:                 if (op == JSOP_OBJECT || op == JSOP_REGEXP) {
   1:                     if (!js_regexp_toString(cx, ATOM_TO_OBJECT(atom), 0, NULL,
   1:                                             &val)) {
   1:                         return NULL;
   1:                     }
   1:                 } else {
   1:                     if (!js_fun_toString(cx, ATOM_TO_OBJECT(atom),
   1:                                          JS_IN_GROUP_CONTEXT |
   1:                                          JS_DONT_PRETTY_PRINT,
   1:                                          0, NULL, &val)) {
   1:                         return NULL;
   1:                     }
   1:                 }
   1:                 str = JSVAL_TO_STRING(val);
   1:                 todo = SprintString(&ss->sprinter, str);
   1:                 break;
   1: 
   1:               case JSOP_TABLESWITCH:
   1:               case JSOP_TABLESWITCHX:
   1:               {
   1:                 ptrdiff_t jmplen, off, off2;
   1:                 jsint j, n, low, high;
   1:                 TableEntry *table, *tmp;
   1: 
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
   1:                 len = js_GetSrcNoteOffset(sn, 0);
   1:                 jmplen = (op == JSOP_TABLESWITCH) ? JUMP_OFFSET_LEN
   1:                                                   : JUMPX_OFFSET_LEN;
   1:                 pc2 = pc;
   1:                 off = GetJumpOffset(pc, pc2);
   1:                 pc2 += jmplen;
   1:                 low = GET_JUMP_OFFSET(pc2);
   1:                 pc2 += JUMP_OFFSET_LEN;
   1:                 high = GET_JUMP_OFFSET(pc2);
   1:                 pc2 += JUMP_OFFSET_LEN;
   1: 
   1:                 n = high - low + 1;
   1:                 if (n == 0) {
   1:                     table = NULL;
   1:                     j = 0;
   1:                     ok = JS_TRUE;
   1:                 } else {
   1:                     table = (TableEntry *)
   1:                             JS_malloc(cx, (size_t)n * sizeof *table);
   1:                     if (!table)
   1:                         return NULL;
   1:                     for (i = j = 0; i < n; i++) {
   1:                         table[j].label = NULL;
   1:                         off2 = GetJumpOffset(pc, pc2);
   1:                         if (off2) {
   1:                             sn = js_GetSrcNote(jp->script, pc2);
   1:                             if (sn) {
   1:                                 LOCAL_ASSERT(SN_TYPE(sn) == SRC_LABEL);
   1:                                 table[j].label =
   1:                                     js_GetAtom(cx, &jp->script->atomMap,
   1:                                                (jsatomid)
   1:                                                js_GetSrcNoteOffset(sn, 0));
   1:                             }
   1:                             table[j].key = INT_TO_JSVAL(low + i);
   1:                             table[j].offset = off2;
   1:                             table[j].order = j;
   1:                             j++;
   1:                         }
   1:                         pc2 += jmplen;
   1:                     }
   1:                     tmp = (TableEntry *)
   1:                           JS_malloc(cx, (size_t)j * sizeof *table);
   1:                     if (tmp) {
   1:                         ok = js_MergeSort(table, (size_t)j, sizeof(TableEntry),
   1:                                           CompareOffsets, NULL, tmp);
   1:                         JS_free(cx, tmp);
   1:                     } else {
   1:                         ok = JS_FALSE;
   1:                     }
   1:                 }
   1: 
   1:                 if (ok) {
   1:                     ok = DecompileSwitch(ss, table, (uintN)j, pc, len, off,
   1:                                          JS_FALSE);
   1:                 }
   1:                 JS_free(cx, table);
   1:                 if (!ok)
   1:                     return NULL;
   1:                 todo = -2;
   1:                 break;
   1:               }
   1: 
   1:               case JSOP_LOOKUPSWITCH:
   1:               case JSOP_LOOKUPSWITCHX:
   1:               {
   1:                 ptrdiff_t jmplen, off, off2;
   1:                 jsatomid npairs, k;
   1:                 TableEntry *table;
   1: 
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
   1:                 len = js_GetSrcNoteOffset(sn, 0);
   1:                 jmplen = (op == JSOP_LOOKUPSWITCH) ? JUMP_OFFSET_LEN
   1:                                                    : JUMPX_OFFSET_LEN;
   1:                 pc2 = pc;
   1:                 off = GetJumpOffset(pc, pc2);
   1:                 pc2 += jmplen;
   1:                 npairs = GET_UINT16(pc2);
   1:                 pc2 += UINT16_LEN;
   1: 
   1:                 table = (TableEntry *)
   1:                     JS_malloc(cx, (size_t)npairs * sizeof *table);
   1:                 if (!table)
   1:                     return NULL;
   1:                 for (k = 0; k < npairs; k++) {
   1:                     sn = js_GetSrcNote(jp->script, pc2);
   1:                     if (sn) {
   1:                         LOCAL_ASSERT(SN_TYPE(sn) == SRC_LABEL);
   1:                         table[k].label =
   1:                             js_GetAtom(cx, &jp->script->atomMap, (jsatomid)
   1:                                        js_GetSrcNoteOffset(sn, 0));
   1:                     } else {
   1:                         table[k].label = NULL;
   1:                     }
   1:                     atom = GET_ATOM(jp->script, jp->script->atomMap.vector,
   1:                                     pc2);
   1:                     pc2 += ATOM_INDEX_LEN;
   1:                     off2 = GetJumpOffset(pc, pc2);
   1:                     pc2 += jmplen;
   1:                     table[k].key = ATOM_KEY(atom);
   1:                     table[k].offset = off2;
   1:                 }
   1: 
   1:                 ok = DecompileSwitch(ss, table, (uintN)npairs, pc, len, off,
   1:                                      JS_FALSE);
   1:                 JS_free(cx, table);
   1:                 if (!ok)
   1:                     return NULL;
   1:                 todo = -2;
   1:                 break;
   1:               }
   1: 
   1:               case JSOP_CONDSWITCH:
   1:               {
   1:                 ptrdiff_t off, off2, caseOff;
   1:                 jsint ncases;
   1:                 TableEntry *table;
   1: 
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1:                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
   1:                 len = js_GetSrcNoteOffset(sn, 0);
   1:                 off = js_GetSrcNoteOffset(sn, 1);
   1: 
   1:                 /*
   1:                  * Count the cases using offsets from switch to first case,
   1:                  * and case to case, stored in srcnote immediates.
   1:                  */
   1:                 pc2 = pc;
   1:                 off2 = off;
   1:                 for (ncases = 0; off2 != 0; ncases++) {
   1:                     pc2 += off2;
   1:                     LOCAL_ASSERT(*pc2 == JSOP_CASE || *pc2 == JSOP_DEFAULT ||
   1:                                  *pc2 == JSOP_CASEX || *pc2 == JSOP_DEFAULTX);
   1:                     if (*pc2 == JSOP_DEFAULT || *pc2 == JSOP_DEFAULTX) {
   1:                         /* End of cases, but count default as a case. */
   1:                         off2 = 0;
   1:                     } else {
   1:                         sn = js_GetSrcNote(jp->script, pc2);
   1:                         LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_PCDELTA);
   1:                         off2 = js_GetSrcNoteOffset(sn, 0);
   1:                     }
   1:                 }
   1: 
   1:                 /*
   1:                  * Allocate table and rescan the cases using their srcnotes,
   1:                  * stashing each case's delta from switch top in table[i].key,
   1:                  * and the distance to its statements in table[i].offset.
   1:                  */
   1:                 table = (TableEntry *)
   1:                     JS_malloc(cx, (size_t)ncases * sizeof *table);
   1:                 if (!table)
   1:                     return NULL;
   1:                 pc2 = pc;
   1:                 off2 = off;
   1:                 for (i = 0; i < ncases; i++) {
   1:                     pc2 += off2;
   1:                     LOCAL_ASSERT(*pc2 == JSOP_CASE || *pc2 == JSOP_DEFAULT ||
   1:                                  *pc2 == JSOP_CASEX || *pc2 == JSOP_DEFAULTX);
   1:                     caseOff = pc2 - pc;
   1:                     table[i].key = INT_TO_JSVAL((jsint) caseOff);
   1:                     table[i].offset = caseOff + GetJumpOffset(pc2, pc2);
   1:                     if (*pc2 == JSOP_CASE || *pc2 == JSOP_CASEX) {
   1:                         sn = js_GetSrcNote(jp->script, pc2);
   1:                         LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_PCDELTA);
   1:                         off2 = js_GetSrcNoteOffset(sn, 0);
   1:                     }
   1:                 }
   1: 
   1:                 /*
   1:                  * Find offset of default code by fetching the default offset
   1:                  * from the end of table.  JSOP_CONDSWITCH always has a default
   1:                  * case at the end.
   1:                  */
   1:                 off = JSVAL_TO_INT(table[ncases-1].key);
   1:                 pc2 = pc + off;
   1:                 off += GetJumpOffset(pc2, pc2);
   1: 
   1:                 ok = DecompileSwitch(ss, table, (uintN)ncases, pc, len, off,
   1:                                      JS_TRUE);
   1:                 JS_free(cx, table);
   1:                 if (!ok)
   1:                     return NULL;
   1:                 todo = -2;
   1:                 break;
   1:               }
   1: 
   1:               case JSOP_CASE:
   1:               case JSOP_CASEX:
   1:               {
   1:                 lval = POP_STR();
   1:                 if (!lval)
   1:                     return NULL;
   1:                 js_printf(jp, "\tcase %s:\n", lval);
   1:                 todo = -2;
   1:                 break;
   1:               }
   1: 
   1:               case JSOP_STRICTEQ:
   1:               case JSOP_STRICTNE:
   1:                 rval = POP_STR();
   1:                 lval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, "%s %c== %s",
   1:                               lval, (op == JSOP_STRICTEQ) ? '=' : '!', rval);
   1:                 break;
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_CLOSURE, 0)
   1:                 LOCAL_ASSERT(ATOM_IS_OBJECT(atom));
   1:                 todo = -2;
   1:                 goto do_function;
   1:               END_LITOPX_CASE
   1: 
   1: #if JS_HAS_EXPORT_IMPORT
   1:               case JSOP_EXPORTALL:
   1:                 js_printf(jp, "\texport *;\n");
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_EXPORTNAME, 0)
   1:                 rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                 if (!rval)
   1:                     return NULL;
   1:                 RETRACT(&ss->sprinter, rval);
   1:                 js_printf(jp, "\texport %s;\n", rval);
   1:                 todo = -2;
   1:               END_LITOPX_CASE
   1: 
   1:               case JSOP_IMPORTALL:
   1:                 lval = POP_STR();
   1:                 js_printf(jp, "\timport %s.*;\n", lval);
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_IMPORTPROP:
   1:               do_importprop:
   1:                 GET_ATOM_QUOTE_AND_FMT("\timport %s[%s];\n",
   1:                                        "\timport %s.%s;\n",
   1:                                        rval);
   1:                 lval = POP_STR();
   1:                 js_printf(jp, fmt, lval, rval);
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_IMPORTELEM:
   1:                 xval = POP_STR();
   1:                 op = JSOP_GETELEM;
   1:                 if (js_CodeSpec[lastop].format & JOF_XMLNAME)
   1:                     goto do_importprop;
   1:                 lval = POP_STR();
   1:                 js_printf(jp, "\timport %s[%s];\n", lval, xval);
   1:                 todo = -2;
   1:                 break;
   1: #endif /* JS_HAS_EXPORT_IMPORT */
   1: 
   1:               case JSOP_TRAP:
   1:                 op = JS_GetTrapOpcode(cx, jp->script, pc);
   1:                 if (op == JSOP_LIMIT)
   1:                     return NULL;
   1:                 saveop = op;
   1:                 *pc = op;
   1:                 cs = &js_CodeSpec[op];
   1:                 len = cs->length;
   1:                 DECOMPILE_CODE(pc, len);
   1:                 *pc = JSOP_TRAP;
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_NEWINIT:
   1:               {
   1:                 JSBool isArray;
   1: 
   1:                 LOCAL_ASSERT(ss->top >= 2);
   1:                 (void) PopOff(ss, op);
   1:                 lval = POP_STR();
   1:                 isArray = (*lval == 'A');
   1:                 todo = ss->sprinter.offset;
   1: #if JS_HAS_SHARP_VARS
   1:                 op = (JSOp)pc[len];
   1:                 if (op == JSOP_DEFSHARP) {
   1:                     pc += len;
   1:                     cs = &js_CodeSpec[op];
   1:                     len = cs->length;
   1:                     i = (jsint) GET_UINT16(pc);
   1:                     if (Sprint(&ss->sprinter, "#%u=", (unsigned) i) < 0)
   1:                         return NULL;
   1:                 }
   1: #endif /* JS_HAS_SHARP_VARS */
   1:                 if (isArray) {
   1:                     ++ss->inArrayInit;
   1:                     if (SprintCString(&ss->sprinter, "[") < 0)
   1:                         return NULL;
   1:                 } else {
   1:                     if (SprintCString(&ss->sprinter, "{") < 0)
   1:                         return NULL;
   1:                 }
   1:                 break;
   1:               }
   1: 
   1:               case JSOP_ENDINIT:
   1:                 op = JSOP_NOP;           /* turn off parens */
   1:                 rval = POP_STR();
   1:                 sn = js_GetSrcNote(jp->script, pc);
   1: 
   1:                 /* Skip any #n= prefix to find the opening bracket. */
   1:                 for (xval = rval; *xval != '[' && *xval != '{'; xval++)
   1:                     continue;
   1:                 if (*xval == '[')
   1:                     --ss->inArrayInit;
   1:                 todo = Sprint(&ss->sprinter, "%s%s%c",
   1:                               rval,
   1:                               (sn && SN_TYPE(sn) == SRC_CONTINUE) ? ", " : "",
   1:                               (*xval == '[') ? ']' : '}');
   1:                 break;
   1: 
   1:               case JSOP_INITPROP:
   1:                 LOAD_ATOM(0);
   1:                 xval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
   1:                                    (jschar)
   1:                                    (ATOM_IS_IDENTIFIER(atom) ? 0 : '\''));
   1:                 if (!xval)
   1:                     return NULL;
   1:                 rval = POP_STR();
   1:                 lval = POP_STR();
   1:               do_initprop:
   1: #ifdef OLD_GETTER_SETTER
   1:                 todo = Sprint(&ss->sprinter, "%s%s%s%s%s:%s",
   1:                               lval,
   1:                               (lval[1] != '\0') ? ", " : "",
   1:                               xval,
   1:                               (lastop == JSOP_GETTER || lastop == JSOP_SETTER)
   1:                               ? " " : "",
   1:                               (lastop == JSOP_GETTER) ? js_getter_str :
   1:                               (lastop == JSOP_SETTER) ? js_setter_str :
   1:                               "",
   1:                               rval);
   1: #else
   1:                 if (lastop == JSOP_GETTER || lastop == JSOP_SETTER) {
1316:                     if (!ATOM_IS_STRING(atom) ||
1316:                         !ATOM_IS_IDENTIFIER(atom) ||
 969:                         ATOM_IS_KEYWORD(atom) ||
 969:                         strncmp(rval, js_function_str, 8) ||
 969:                         rval[8] != ' ') {
 526:                         todo = Sprint(&ss->sprinter, "%s%s%s %s:%s", lval,
   1:                                       (lval[1] != '\0') ? ", " : "", xval,
   1:                                       (lastop == JSOP_GETTER) ? js_getter_str :
   1:                                       (lastop == JSOP_SETTER) ? js_setter_str :
   1:                                       "",
   1:                                       rval);
   1:                     } else {
   1:                         rval += 8 + 1;
   1:                         LOCAL_ASSERT(rval[strlen(rval)-1] == '}');
 526:                         todo = Sprint(&ss->sprinter, "%s%s%s %s%s%s",
   1:                                       lval,
   1:                                       (lval[1] != '\0') ? ", " : "",
   1:                                       (lastop == JSOP_GETTER)
   1:                                       ? js_get_str : js_set_str,
   1:                                       xval,
 526:                                       (rval[0] != '(') ? " " : "",
   1:                                       rval);
   1:                     }
   1:                 } else {
   1:                     todo = Sprint(&ss->sprinter, "%s%s%s:%s",
   1:                                   lval,
   1:                                   (lval[1] != '\0') ? ", " : "",
   1:                                   xval,
   1:                                   rval);
   1:                 }
   1: #endif
   1:                 break;
   1: 
   1:               case JSOP_INITELEM:
   1:                 rval = POP_STR();
   1:                 xval = POP_STR();
   1:                 lval = POP_STR();
   1:                 sn = js_GetSrcNote(jp->script, pc);
1018:                 if (sn && SN_TYPE(sn) == SRC_INITPROP) {
1018:                     atom = NULL;
   1:                     goto do_initprop;
1018:                 }
   1:                 todo = Sprint(&ss->sprinter, "%s%s%s",
   1:                               lval,
   1:                               (lval[1] != '\0' || *xval != '0') ? ", " : "",
   1:                               rval);
   1:                 break;
   1: 
   1: #if JS_HAS_SHARP_VARS
   1:               case JSOP_DEFSHARP:
   1:                 i = (jsint) GET_UINT16(pc);
   1:                 rval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, "#%u=%s", (unsigned) i, rval);
   1:                 break;
   1: 
   1:               case JSOP_USESHARP:
   1:                 i = (jsint) GET_UINT16(pc);
   1:                 todo = Sprint(&ss->sprinter, "#%u#", (unsigned) i);
   1:                 break;
   1: #endif /* JS_HAS_SHARP_VARS */
   1: 
   1: #if JS_HAS_DEBUGGER_KEYWORD
   1:               case JSOP_DEBUGGER:
   1:                 js_printf(jp, "\tdebugger;\n");
   1:                 todo = -2;
   1:                 break;
   1: #endif /* JS_HAS_DEBUGGER_KEYWORD */
   1: 
   1: #if JS_HAS_XML_SUPPORT
   1:               case JSOP_STARTXML:
   1:               case JSOP_STARTXMLEXPR:
   1:                 inXML = op == JSOP_STARTXML;
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_DEFXMLNS:
   1:                 rval = POP_STR();
   1:                 js_printf(jp, "\t%s %s %s = %s;\n",
   1:                           js_default_str, js_xml_str, js_namespace_str, rval);
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_ANYNAME:
   1:                 if (pc[JSOP_ANYNAME_LENGTH] == JSOP_TOATTRNAME) {
   1:                     len += JSOP_TOATTRNAME_LENGTH;
   1:                     todo = SprintPut(&ss->sprinter, "@*", 2);
   1:                 } else {
   1:                     todo = SprintPut(&ss->sprinter, "*", 1);
   1:                 }
   1:                 break;
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_QNAMEPART, 0)
   1:                 if (pc[JSOP_QNAMEPART_LENGTH] == JSOP_TOATTRNAME) {
   1:                     saveop = JSOP_TOATTRNAME;
   1:                     len += JSOP_TOATTRNAME_LENGTH;
   1:                     lval = "@";
   1:                     goto do_qname;
   1:                 }
   1:                 goto do_name;
   1:               END_LITOPX_CASE
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_QNAMECONST, 0)
   1:                 rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
   1:                 if (!rval)
   1:                     return NULL;
   1:                 RETRACT(&ss->sprinter, rval);
   1:                 lval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, "%s::%s", lval, rval);
   1:               END_LITOPX_CASE
   1: 
   1:               case JSOP_QNAME:
   1:                 rval = POP_STR();
   1:                 lval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, "%s::[%s]", lval, rval);
   1:                 break;
   1: 
   1:               case JSOP_TOATTRNAME:
   1:                 op = JSOP_NOP;           /* turn off parens */
   1:                 rval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, "@[%s]", rval);
   1:                 break;
   1: 
   1:               case JSOP_TOATTRVAL:
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_ADDATTRNAME:
   1:                 rval = POP_STR();
   1:                 lval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, "%s %s", lval, rval);
   1:                 /* This gets reset by all XML tag expressions. */
   1:                 quoteAttr = JS_TRUE;
   1:                 break;
   1: 
   1:               case JSOP_ADDATTRVAL:
   1:                 rval = POP_STR();
   1:                 lval = POP_STR();
   1:                 if (quoteAttr)
   1:                     todo = Sprint(&ss->sprinter, "%s=\"%s\"", lval, rval);
   1:                 else
   1:                     todo = Sprint(&ss->sprinter, "%s=%s", lval, rval);
   1:                 break;
   1: 
   1:               case JSOP_BINDXMLNAME:
   1:                 /* Leave the name stacked and push a dummy string. */
   1:                 todo = Sprint(&ss->sprinter, "");
   1:                 break;
   1: 
   1:               case JSOP_SETXMLNAME:
   1:                 /* Pop the r.h.s., the dummy string, and the name. */
   1:                 rval = POP_STR();
   1:                 (void) PopOff(ss, op);
   1:                 lval = POP_STR();
   1:                 goto do_setlval;
   1: 
   1:               case JSOP_XMLELTEXPR:
   1:               case JSOP_XMLTAGEXPR:
   1:                 todo = Sprint(&ss->sprinter, "{%s}", POP_STR());
   1:                 inXML = JS_TRUE;
   1:                 /* If we're an attribute value, we shouldn't quote this. */
   1:                 quoteAttr = JS_FALSE;
   1:                 break;
   1: 
   1:               case JSOP_TOXMLLIST:
   1:                 op = JSOP_NOP;           /* turn off parens */
   1:                 todo = Sprint(&ss->sprinter, "<>%s</>", POP_STR());
   1:                 inXML = JS_FALSE;
   1:                 break;
   1: 
   1:               case JSOP_FOREACH:
   1:                 foreach = JS_TRUE;
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_TOXML:
   1:               case JSOP_CALLXMLNAME:
   1:               case JSOP_XMLNAME:
   1:               case JSOP_FILTER:
   1:                 /* These ops indicate the end of XML expressions. */
   1:                 inXML = JS_FALSE;
   1:                 todo = -2;
   1:                 break;
   1: 
   1:               case JSOP_ENDFILTER:
   1:                 rval = POP_STR();
   1:                 lval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, "%s.(%s)", lval, rval);
   1:                 break;
   1: 
   1:               case JSOP_DESCENDANTS:
   1:                 rval = POP_STR();
   1:                 lval = POP_STR();
   1:                 todo = Sprint(&ss->sprinter, "%s..%s", lval, rval);
   1:                 break;
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_XMLOBJECT, 0)
   1:                 todo = Sprint(&ss->sprinter, "<xml address='%p'>",
   1:                               ATOM_TO_OBJECT(atom));
   1:               END_LITOPX_CASE
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_XMLCDATA, 0)
   1:                 todo = SprintPut(&ss->sprinter, "<![CDATA[", 9);
   1:                 if (!QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
   1:                                  DONT_ESCAPE))
   1:                     return NULL;
   1:                 SprintPut(&ss->sprinter, "]]>", 3);
   1:               END_LITOPX_CASE
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_XMLCOMMENT, 0)
   1:                 todo = SprintPut(&ss->sprinter, "<!--", 4);
   1:                 if (!QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
   1:                                  DONT_ESCAPE))
   1:                     return NULL;
   1:                 SprintPut(&ss->sprinter, "-->", 3);
   1:               END_LITOPX_CASE
   1: 
   1:               BEGIN_LITOPX_CASE(JSOP_XMLPI, 0)
   1:                 rval = JS_strdup(cx, POP_STR());
   1:                 if (!rval)
   1:                     return NULL;
   1:                 todo = SprintPut(&ss->sprinter, "<?", 2);
   1:                 ok = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0) &&
   1:                      (*rval == '\0' ||
   1:                       (SprintPut(&ss->sprinter, " ", 1) >= 0 &&
   1:                        SprintCString(&ss->sprinter, rval)));
   1:                 JS_free(cx, (char *)rval);
   1:                 if (!ok)
   1:                     return NULL;
   1:                 SprintPut(&ss->sprinter, "?>", 2);
   1:               END_LITOPX_CASE
   1: 
   1:               case JSOP_GETFUNNS:
   1:                 todo = SprintPut(&ss->sprinter, js_function_str, 8);
   1:                 break;
   1: #endif /* JS_HAS_XML_SUPPORT */
   1: 
   1:               default:
   1:                 todo = -2;
   1:                 break;
   1: 
   1: #undef BEGIN_LITOPX_CASE
   1: #undef END_LITOPX_CASE
   1:             }
   1:         }
   1: 
   1:         if (todo < 0) {
   1:             /* -2 means "don't push", -1 means reported error. */
   1:             if (todo == -1)
   1:                 return NULL;
   1:         } else {
   1:             if (!PushOff(ss, todo, saveop))
   1:                 return NULL;
   1:         }
   1: 
   1:         if (cs->format & JOF_CALLOP) {
   1:             todo = Sprint(&ss->sprinter, "");
   1:             if (todo < 0 || !PushOff(ss, todo, saveop))
   1:                 return NULL;
   1:         }
   1: 
   1:         pc += len;
   1:     }
   1: 
   1: /*
   1:  * Undefine local macros.
   1:  */
   1: #undef inXML
   1: #undef DECOMPILE_CODE
   1: #undef POP_STR
   1: #undef LOCAL_ASSERT
   1: #undef ATOM_IS_IDENTIFIER
   1: #undef GET_QUOTE_AND_FMT
   1: #undef GET_ATOM_QUOTE_AND_FMT
   1: 
   1:     return pc;
   1: }
   1: 
   1: static JSBool
   1: InitSprintStack(JSContext *cx, SprintStack *ss, JSPrinter *jp, uintN depth)
   1: {
   1:     size_t offsetsz, opcodesz;
   1:     void *space;
   1: 
   1:     INIT_SPRINTER(cx, &ss->sprinter, &cx->tempPool, PAREN_SLOP);
   1: 
   1:     /* Allocate the parallel (to avoid padding) offset and opcode stacks. */
   1:     offsetsz = depth * sizeof(ptrdiff_t);
   1:     opcodesz = depth * sizeof(jsbytecode);
   1:     JS_ARENA_ALLOCATE(space, &cx->tempPool, offsetsz + opcodesz);
   1:     if (!space)
   1:         return JS_FALSE;
   1:     ss->offsets = (ptrdiff_t *) space;
   1:     ss->opcodes = (jsbytecode *) ((char *)space + offsetsz);
   1: 
   1:     ss->top = ss->inArrayInit = 0;
   1:     ss->printer = jp;
   1:     return JS_TRUE;
   1: }
   1: 
   1: JSBool
   1: js_DecompileCode(JSPrinter *jp, JSScript *script, jsbytecode *pc, uintN len,
   1:                  uintN pcdepth)
   1: {
   1:     uintN depth, i;
   1:     SprintStack ss;
   1:     JSContext *cx;
   1:     void *mark;
   1:     JSBool ok;
   1:     JSScript *oldscript;
   1:     char *last;
   1: 
   1:     depth = script->depth;
   1:     JS_ASSERT(pcdepth <= depth);
   1: 
   1:     /* Initialize a sprinter for use with the offset stack. */
   1:     cx = jp->sprinter.context;
   1:     mark = JS_ARENA_MARK(&cx->tempPool);
   1:     ok = InitSprintStack(cx, &ss, jp, depth);
   1:     if (!ok)
   1:         goto out;
   1: 
   1:     /*
   1:      * If we are called from js_DecompileValueGenerator with a portion of
   1:      * script's bytecode that starts with a non-zero model stack depth given
   1:      * by pcdepth, attempt to initialize the missing string offsets in ss to
   1:      * |spindex| negative indexes from fp->sp for the activation fp in which
   1:      * the error arose.
   1:      *
   1:      * See js_DecompileValueGenerator for how its |spindex| parameter is used,
   1:      * and see also GetOff, which makes use of the ss.offsets[i] < -1 that are
   1:      * potentially stored below.
   1:      */
   1:     ss.top = pcdepth;
   1:     if (pcdepth != 0) {
   1:         JSStackFrame *fp;
   1:         ptrdiff_t top;
   1: 
   1:         for (fp = cx->fp; fp && !fp->script; fp = fp->down)
   1:             continue;
   1:         top = fp ? fp->sp - fp->spbase : 0;
   1:         for (i = 0; i < pcdepth; i++) {
   1:             ss.offsets[i] = -1;
   1:             ss.opcodes[i] = JSOP_NOP;
   1:         }
   1:         if (fp && fp->pc == pc && (uintN)top == pcdepth) {
   1:             for (i = 0; i < pcdepth; i++) {
   1:                 ptrdiff_t off;
   1:                 jsbytecode *genpc;
   1: 
   1:                 off = (intN)i - (intN)depth;
   1:                 genpc = (jsbytecode *) fp->spbase[off];
   1:                 if (JS_UPTRDIFF(genpc, script->code) < script->length) {
   1:                     ss.offsets[i] += (ptrdiff_t)i - top;
   1:                     ss.opcodes[i] = *genpc;
   1:                 }
   1:             }
   1:         }
   1:     }
   1: 
   1:     /* Call recursive subroutine to do the hard work. */
   1:     oldscript = jp->script;
   1:     jp->script = script;
   1:     ok = Decompile(&ss, pc, len) != NULL;
   1:     jp->script = oldscript;
   1: 
   1:     /* If the given code didn't empty the stack, do it now. */
   1:     if (ss.top) {
   1:         do {
   1:             last = OFF2STR(&ss.sprinter, PopOff(&ss, JSOP_POP));
   1:         } while (ss.top > pcdepth);
   1:         js_printf(jp, "%s", last);
   1:     }
   1: 
   1: out:
   1:     /* Free all temporary stuff allocated under this call. */
   1:     JS_ARENA_RELEASE(&cx->tempPool, mark);
   1:     return ok;
   1: }
   1: 
   1: JSBool
   1: js_DecompileScript(JSPrinter *jp, JSScript *script)
   1: {
   1:     return js_DecompileCode(jp, script, script->code, (uintN)script->length, 0);
   1: }
   1: 
   1: static const char native_code_str[] = "\t[native code]\n";
   1: 
   1: JSBool
   1: js_DecompileFunctionBody(JSPrinter *jp, JSFunction *fun)
   1: {
   1:     JSScript *script;
   1:     JSScope *scope, *save;
   1:     JSBool ok;
   1: 
   1:     if (!FUN_INTERPRETED(fun)) {
   1:         js_printf(jp, native_code_str);
   1:         return JS_TRUE;
   1:     }
   1:     script = fun->u.i.script;
   1:     scope = fun->object ? OBJ_SCOPE(fun->object) : NULL;
   1:     save = jp->scope;
   1:     jp->scope = scope;
   1:     ok = js_DecompileCode(jp, script, script->code, (uintN)script->length, 0);
   1:     jp->scope = save;
   1:     return ok;
   1: }
   1: 
   1: JSBool
   1: js_DecompileFunction(JSPrinter *jp, JSFunction *fun)
   1: {
   1:     JSContext *cx;
   1:     uintN i, nargs, indent;
   1:     void *mark;
   1:     JSAtom **params;
   1:     JSScope *scope, *oldscope;
   1:     JSScopeProperty *sprop;
   1:     jsbytecode *pc, *endpc;
   1:     ptrdiff_t len;
   1:     JSBool ok;
   1: 
   1:     /*
   1:      * If pretty, conform to ECMA-262 Edition 3, 15.3.4.2, by decompiling a
   1:      * FunctionDeclaration.  Otherwise, check the JSFUN_LAMBDA flag and force
   1:      * an expression by parenthesizing.
   1:      */
   1:     if (jp->pretty) {
   1:         js_printf(jp, "\t");
   1:     } else {
   1:         if (!jp->grouped && (fun->flags & JSFUN_LAMBDA))
   1:             js_puts(jp, "(");
   1:     }
   1:     if (JSFUN_GETTER_TEST(fun->flags))
   1:         js_printf(jp, "%s ", js_getter_str);
   1:     else if (JSFUN_SETTER_TEST(fun->flags))
   1:         js_printf(jp, "%s ", js_setter_str);
   1: 
   1:     js_printf(jp, "%s ", js_function_str);
   1:     if (fun->atom && !QuoteString(&jp->sprinter, ATOM_TO_STRING(fun->atom), 0))
   1:         return JS_FALSE;
   1:     js_puts(jp, "(");
   1: 
   1:     if (FUN_INTERPRETED(fun) && fun->object) {
   1:         size_t paramsize;
   1: #ifdef JS_HAS_DESTRUCTURING
   1:         SprintStack ss;
   1:         JSScript *oldscript;
   1: #endif
   1: 
   1:         /*
   1:          * Print the parameters.
   1:          *
   1:          * This code is complicated by the need to handle duplicate parameter
   1:          * names, as required by ECMA (bah!).  A duplicate parameter is stored
   1:          * as another node with the same id (the parameter name) but different
   1:          * shortid (the argument index) along the property tree ancestor line
   1:          * starting at SCOPE_LAST_PROP(scope).  Only the last duplicate param
   1:          * is mapped by the scope's hash table.
   1:          */
   1:         cx = jp->sprinter.context;
   1:         nargs = fun->nargs;
   1:         mark = JS_ARENA_MARK(&cx->tempPool);
   1:         paramsize = nargs * sizeof(JSAtom *);
   1:         JS_ARENA_ALLOCATE_CAST(params, JSAtom **, &cx->tempPool, paramsize);
   1:         if (!params) {
   1:             JS_ReportOutOfMemory(cx);
   1:             return JS_FALSE;
   1:         }
   1: 
   1:         memset(params, 0, paramsize);
   1:         scope = OBJ_SCOPE(fun->object);
   1:         for (sprop = SCOPE_LAST_PROP(scope); sprop; sprop = sprop->parent) {
   1:             if (sprop->getter != js_GetArgument)
   1:                 continue;
   1:             JS_ASSERT(sprop->flags & SPROP_HAS_SHORTID);
   1:             JS_ASSERT((uint16) sprop->shortid < nargs);
   1:             JS_ASSERT(JSID_IS_ATOM(sprop->id));
   1:             params[(uint16) sprop->shortid] = JSID_TO_ATOM(sprop->id);
   1:         }
   1: 
   1:         pc = fun->u.i.script->main;
   1:         endpc = pc + fun->u.i.script->length;
   1:         ok = JS_TRUE;
   1: 
   1: #ifdef JS_HAS_DESTRUCTURING
   1:         /* Skip JSOP_GENERATOR in case of destructuring parameters. */
   1:         if (*pc == JSOP_GENERATOR)
   1:             pc += JSOP_GENERATOR_LENGTH;
   1: 
   1:         ss.printer = NULL;
   1:         oldscript = jp->script;
   1:         jp->script = fun->u.i.script;
   1:         oldscope = jp->scope;
   1:         jp->scope = scope;
   1: #endif
   1: 
   1:         for (i = 0; i < nargs; i++) {
   1:             if (i > 0)
   1:                 js_puts(jp, ", ");
   1: 
   1: #if JS_HAS_DESTRUCTURING
   1: #define LOCAL_ASSERT(expr)      LOCAL_ASSERT_RV(expr, JS_FALSE)
   1: 
   1:             if (!params[i]) {
   1:                 ptrdiff_t todo;
   1:                 const char *lval;
   1: 
   1:                 LOCAL_ASSERT(*pc == JSOP_GETARG);
   1:                 pc += JSOP_GETARG_LENGTH;
   1:                 LOCAL_ASSERT(*pc == JSOP_DUP);
   1:                 if (!ss.printer) {
   1:                     ok = InitSprintStack(cx, &ss, jp, fun->u.i.script->depth);
   1:                     if (!ok)
   1:                         break;
   1:                 }
   1:                 pc = DecompileDestructuring(&ss, pc, endpc);
   1:                 if (!pc) {
   1:                     ok = JS_FALSE;
   1:                     break;
   1:                 }
   1:                 LOCAL_ASSERT(*pc == JSOP_POP);
   1:                 pc += JSOP_POP_LENGTH;
   1:                 lval = PopStr(&ss, JSOP_NOP);
   1:                 todo = SprintCString(&jp->sprinter, lval);
   1:                 if (todo < 0) {
   1:                     ok = JS_FALSE;
   1:                     break;
   1:                 }
   1:                 continue;
   1:             }
   1: 
   1: #undef LOCAL_ASSERT
   1: #endif
   1: 
   1:             if (!QuoteString(&jp->sprinter, ATOM_TO_STRING(params[i]), 0)) {
   1:                 ok = JS_FALSE;
   1:                 break;
   1:             }
   1:         }
   1: 
   1: #ifdef JS_HAS_DESTRUCTURING
   1:         jp->script = oldscript;
   1:         jp->scope = oldscope;
   1: #endif
   1:         JS_ARENA_RELEASE(&cx->tempPool, mark);
   1:         if (!ok)
   1:             return JS_FALSE;
   1: #ifdef __GNUC__
   1:     } else {
   1:         scope = NULL;
   1:         pc = NULL;
   1: #endif
   1:     }
   1: 
   1:     js_printf(jp, ") {\n");
   1:     indent = jp->indent;
   1:     jp->indent += 4;
   1:     if (FUN_INTERPRETED(fun) && fun->object) {
   1:         oldscope = jp->scope;
   1:         jp->scope = scope;
   1:         len = fun->u.i.script->code + fun->u.i.script->length - pc;
   1:         ok = js_DecompileCode(jp, fun->u.i.script, pc, (uintN)len, 0);
   1:         jp->scope = oldscope;
   1:         if (!ok) {
   1:             jp->indent = indent;
   1:             return JS_FALSE;
   1:         }
   1:     } else {
   1:         js_printf(jp, native_code_str);
   1:     }
   1:     jp->indent -= 4;
   1:     js_printf(jp, "\t}");
   1: 
   1:     if (!jp->pretty) {
   1:         if (!jp->grouped && (fun->flags & JSFUN_LAMBDA))
   1:             js_puts(jp, ")");
   1:     }
   1:     return JS_TRUE;
   1: }
   1: 
   1: #undef LOCAL_ASSERT_RV
   1: 
   1: char *
   1: js_DecompileValueGenerator(JSContext *cx, intN spindex, jsval v,
   1:                            JSString *fallback)
   1: {
   1:     JSStackFrame *fp, *down;
   1:     jsbytecode *pc, *begin, *end;
   1:     jsval *sp, *spbase, *base, *limit;
   1:     intN depth, pcdepth;
   1:     JSScript *script;
   1:     JSOp op;
   1:     const JSCodeSpec *cs;
   1:     jssrcnote *sn;
   1:     ptrdiff_t len, oplen;
   1:     JSPrinter *jp;
   1:     char *name;
   1: 
   1:     for (fp = cx->fp; fp && !fp->script; fp = fp->down)
   1:         continue;
   1:     if (!fp)
   1:         goto do_fallback;
   1: 
   1:     /* Try to find sp's generating pc depth slots under it on the stack. */
   1:     pc = fp->pc;
   1:     sp = fp->sp;
   1:     spbase = fp->spbase;
   1:     if ((uintN)(sp - spbase) > fp->script->depth) {
   1:         /*
   1:          * Preparing to make an internal invocation, using an argv stack
   1:          * segment pushed just above fp's operand stack space.  Such an argv
   1:          * stack has no generating pc "basement", so we must fall back.
   1:          */
   1:         goto do_fallback;
   1:     }
   1: 
   1:     if (spindex == JSDVG_SEARCH_STACK) {
   1:         if (!pc) {
   1:             /*
   1:              * Current frame is native: look under it for a scripted call
   1:              * in which a decompilable bytecode string that generated the
   1:              * value as an actual argument might exist.
   1:              */
   1:             JS_ASSERT(!fp->script && !(fp->fun && FUN_INTERPRETED(fp->fun)));
   1:             down = fp->down;
   1:             if (!down)
   1:                 goto do_fallback;
   1:             script = down->script;
   1:             spbase = down->spbase;
   1:             base = fp->argv;
   1:             limit = base + fp->argc;
   1:         } else {
   1:             /*
   1:              * This should be a script activation, either a top-level
   1:              * script or a scripted function.  But be paranoid about calls
   1:              * to js_DecompileValueGenerator from code that hasn't fully
   1:              * initialized a (default-all-zeroes) frame.
   1:              */
   1:             script = fp->script;
   1:             spbase = base = fp->spbase;
   1:             limit = fp->sp;
   1:         }
   1: 
   1:         /*
   1:          * Pure paranoia about default-zeroed frames being active while
   1:          * js_DecompileValueGenerator is called.  It can't hurt much now;
   1:          * error reporting performance is not an issue.
   1:          */
   1:         if (!script || !base || !limit)
   1:             goto do_fallback;
   1: 
   1:         /*
   1:          * Try to find operand-generating pc depth slots below sp.
   1:          *
   1:          * In the native case, we know the arguments have generating pc's
   1:          * under them, on account of fp->down->script being non-null: all
   1:          * compiled scripts get depth slots for generating pc's allocated
   1:          * upon activation, at the top of js_Interpret.
   1:          *
   1:          * In the script or scripted function case, the same reasoning
   1:          * applies to fp rather than to fp->down.
   1:          *
   1:          * We search from limit to base to find the most recently calculated
   1:          * value matching v under assumption that it is it that caused
   1:          * exception, see bug 328664.
   1:          */
   1:         for (sp = limit;;) {
   1:             if (sp <= base)
   1:                 goto do_fallback;
   1:             --sp;
   1:             if (*sp == v) {
   1:                 depth = (intN)script->depth;
   1:                 sp -= depth;
   1:                 pc = (jsbytecode *) *sp;
   1:                 break;
   1:             }
   1:         }
   1:     } else {
   1:         /*
   1:          * At this point, pc may or may not be null, i.e., we could be in
   1:          * a script activation, or we could be in a native frame that was
   1:          * called by another native function.  Check pc and script.
   1:          */
   1:         if (!pc)
   1:             goto do_fallback;
   1:         script = fp->script;
   1:         if (!script)
   1:             goto do_fallback;
   1: 
   1:         if (spindex != JSDVG_IGNORE_STACK) {
   1:             JS_ASSERT(spindex < 0);
   1:             depth = (intN)script->depth;
   1: #if !JS_HAS_NO_SUCH_METHOD
   1:             JS_ASSERT(-depth <= spindex);
   1: #endif
   1:             spindex -= depth;
   1: 
   1:             base = (jsval *) cx->stackPool.current->base;
   1:             limit = (jsval *) cx->stackPool.current->avail;
   1:             sp = fp->sp + spindex;
   1:             if (JS_UPTRDIFF(sp, base) < JS_UPTRDIFF(limit, base))
   1:                 pc = (jsbytecode *) *sp;
   1:         }
   1:     }
   1: 
   1:     /*
   1:      * Again, be paranoid, this time about possibly loading an invalid pc
   1:      * from fp->sp[-(1+depth)].
   1:      */
   1:     if (JS_UPTRDIFF(pc, script->code) >= (jsuword)script->length) {
   1:         pc = fp->pc;
   1:         if (!pc)
   1:             goto do_fallback;
   1:     }
   1:     op = (JSOp) *pc;
   1:     if (op == JSOP_TRAP)
   1:         op = JS_GetTrapOpcode(cx, script, pc);
   1: 
   1:     /* None of these stack-writing ops generates novel values. */
   1:     JS_ASSERT(op != JSOP_CASE && op != JSOP_CASEX &&
   1:               op != JSOP_DUP && op != JSOP_DUP2 &&
   1:               op != JSOP_SWAP);
   1: 
   1:     /*
   1:      * |this| could convert to a very long object initialiser, so cite it by
   1:      * its keyword name instead.
   1:      */
   1:     if (op == JSOP_THIS)
   1:         return JS_strdup(cx, js_this_str);
   1: 
   1:     /*
   1:      * JSOP_BINDNAME is special: it generates a value, the base object of a
   1:      * reference.  But if it is the generating op for a diagnostic produced by
   1:      * js_DecompileValueGenerator, the name being bound is irrelevant.  Just
   1:      * fall back to the base object.
   1:      */
   1:     if (op == JSOP_BINDNAME)
   1:         goto do_fallback;
   1: 
   1:     /* NAME ops are self-contained, others require left or right context. */
   1:     cs = &js_CodeSpec[op];
   1:     begin = pc;
   1:     end = pc + cs->length;
   1:     switch (cs->format & JOF_MODEMASK) {
   1:       case JOF_PROP:
   1:       case JOF_ELEM:
   1:       case JOF_XMLNAME:
   1:       case 0:
   1:         sn = js_GetSrcNote(script, pc);
   1:         if (!sn)
   1:             goto do_fallback;
   1:         switch (SN_TYPE(sn)) {
   1:           case SRC_PCBASE:
   1:             begin -= js_GetSrcNoteOffset(sn, 0);
   1:             break;
   1:           case SRC_PCDELTA:
   1:             end = begin + js_GetSrcNoteOffset(sn, 0);
   1:             begin += cs->length;
   1:             break;
   1:           default:
   1:             goto do_fallback;
   1:         }
   1:         break;
   1:       default:;
   1:     }
   1:     len = PTRDIFF(end, begin, jsbytecode);
   1:     if (len <= 0)
   1:         goto do_fallback;
   1: 
   1:     /*
   1:      * Walk forward from script->main and compute starting stack depth.
   1:      * FIXME: Code to compute oplen copied from js_Disassemble1 and reduced.
   1:      * FIXME: Optimize to use last empty-stack sequence point.
   1:      */
   1:     pcdepth = 0;
   1:     for (pc = script->main; pc < begin; pc += oplen) {
   1:         uint32 type;
   1:         intN nuses, ndefs;
   1: 
   1:         op = (JSOp) *pc;
   1:         if (op == JSOP_TRAP)
   1:             op = JS_GetTrapOpcode(cx, script, pc);
   1:         cs = &js_CodeSpec[op];
   1:         oplen = cs->length;
   1: 
   1:         if (op == JSOP_SETSP) {
   1:             pcdepth = GET_UINT16(pc);
   1:             continue;
   1:         }
1227:         if (op == JSOP_POPN) {
1227:             pcdepth -= GET_UINT16(pc);
1227:             continue;
1227:         }
   1: 
   1:         /*
   1:          * A (C ? T : E) expression requires skipping either T (if begin is in
   1:          * E) or both T and E (if begin is after the whole expression) before
   1:          * adjusting pcdepth based on the JSOP_IFEQ or JSOP_IFEQX at pc that
   1:          * tests condition C.  We know that the stack depth can't change from
   1:          * what it was with C on top of stack.
   1:          */
   1:         sn = js_GetSrcNote(script, pc);
   1:         if (sn && SN_TYPE(sn) == SRC_COND) {
   1:             ptrdiff_t jmpoff, jmplen;
   1: 
   1:             jmpoff = js_GetSrcNoteOffset(sn, 0);
   1:             if (pc + jmpoff < begin) {
   1:                 pc += jmpoff;
   1:                 op = *pc;
   1:                 JS_ASSERT(op == JSOP_GOTO || op == JSOP_GOTOX);
   1:                 cs = &js_CodeSpec[op];
   1:                 oplen = cs->length;
   1:                 jmplen = GetJumpOffset(pc, pc);
   1:                 if (pc + jmplen < begin) {
   1:                     oplen = (uintN) jmplen;
   1:                     continue;
   1:                 }
   1: 
   1:                 /*
   1:                  * Ok, begin lies in E.  Manually pop C off the model stack,
   1:                  * since we have moved beyond the IFEQ now.
   1:                  */
   1:                 --pcdepth;
   1:             }
   1:         }
   1: 
   1:         type = cs->format & JOF_TYPEMASK;
   1:         switch (type) {
   1:           case JOF_TABLESWITCH:
   1:           case JOF_TABLESWITCHX:
   1:           {
   1:             jsint jmplen, i, low, high;
   1:             jsbytecode *pc2;
   1: 
   1:             jmplen = (type == JOF_TABLESWITCH) ? JUMP_OFFSET_LEN
   1:                                                : JUMPX_OFFSET_LEN;
   1:             pc2 = pc;
   1:             pc2 += jmplen;
   1:             low = GET_JUMP_OFFSET(pc2);
   1:             pc2 += JUMP_OFFSET_LEN;
   1:             high = GET_JUMP_OFFSET(pc2);
   1:             pc2 += JUMP_OFFSET_LEN;
   1:             for (i = low; i <= high; i++)
   1:                 pc2 += jmplen;
   1:             oplen = 1 + pc2 - pc;
   1:             break;
   1:           }
   1: 
   1:           case JOF_LOOKUPSWITCH:
   1:           case JOF_LOOKUPSWITCHX:
   1:           {
   1:             jsint jmplen;
   1:             jsbytecode *pc2;
   1:             jsatomid npairs;
   1: 
   1:             jmplen = (type == JOF_LOOKUPSWITCH) ? JUMP_OFFSET_LEN
   1:                                                 : JUMPX_OFFSET_LEN;
   1:             pc2 = pc;
   1:             pc2 += jmplen;
   1:             npairs = GET_UINT16(pc2);
   1:             pc2 += ATOM_INDEX_LEN;
   1:             while (npairs) {
   1:                 pc2 += ATOM_INDEX_LEN;
   1:                 pc2 += jmplen;
   1:                 npairs--;
   1:             }
   1:             oplen = 1 + pc2 - pc;
   1:             break;
   1:           }
   1: 
   1:           default:;
   1:         }
   1: 
   1:         if (sn && SN_TYPE(sn) == SRC_HIDDEN)
   1:             continue;
   1: 
   1:         nuses = cs->nuses;
   1:         if (nuses < 0) {
   1:             /* Call opcode pushes [callee, this, argv...]. */
   1:             nuses = 2 + GET_ARGC(pc);
   1:         } else if (op == JSOP_RETSUB) {
   1:             /* Pop [exception or hole, retsub pc-index]. */
   1:             JS_ASSERT(nuses == 0);
   1:             nuses = 2;
   1:         } else if (op == JSOP_LEAVEBLOCK || op == JSOP_LEAVEBLOCKEXPR) {
   1:             JS_ASSERT(nuses == 0);
   1:             nuses = GET_UINT16(pc);
   1:         }
   1:         pcdepth -= nuses;
   1:         JS_ASSERT(pcdepth >= 0);
   1: 
   1:         ndefs = cs->ndefs;
   1:         if (op == JSOP_FINALLY) {
   1:             /* Push [exception or hole, retsub pc-index]. */
   1:             JS_ASSERT(ndefs == 0);
   1:             ndefs = 2;
   1:         } else if (op == JSOP_ENTERBLOCK) {
   1:             JSAtom *atom;
   1:             JSObject *obj;
   1: 
   1:             JS_ASSERT(ndefs == 0);
   1:             atom = js_GetAtomFromBytecode(script, pc, 0);
   1:             obj = ATOM_TO_OBJECT(atom);
   1:             JS_ASSERT(OBJ_BLOCK_DEPTH(cx, obj) == pcdepth);
   1:             ndefs = OBJ_BLOCK_COUNT(cx, obj);
   1:         }
   1:         pcdepth += ndefs;
   1:     }
   1: 
   1:     name = NULL;
 437:     jp = JS_NEW_PRINTER(cx, "js_DecompileValueGenerator", 0, JS_FALSE);
   1:     if (jp) {
   1:         if (fp->fun && fp->fun->object) {
   1:             JS_ASSERT(OBJ_IS_NATIVE(fp->fun->object));
   1:             jp->scope = OBJ_SCOPE(fp->fun->object);
   1:         }
   1:         jp->dvgfence = end;
   1:         if (js_DecompileCode(jp, script, begin, (uintN)len, (uintN)pcdepth)) {
   1:             name = (jp->sprinter.base) ? jp->sprinter.base : "";
   1:             name = JS_strdup(cx, name);
   1:         }
   1:         js_DestroyPrinter(jp);
   1:     }
   1:     return name;
   1: 
   1:   do_fallback:
   1:     if (!fallback) {
   1:         fallback = js_ValueToSource(cx, v);
   1:         if (!fallback)
   1:             return NULL;
   1:     }
   1:     return js_DeflateString(cx, JSSTRING_CHARS(fallback),
   1:                             JSSTRING_LENGTH(fallback));
   1: }
