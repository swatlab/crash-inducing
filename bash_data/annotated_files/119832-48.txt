 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsUsageArrayHelper.h"
     1: 
     1: #include "nsCOMPtr.h"
     1: #include "nsIDateTimeFormat.h"
     1: #include "nsDateTimeFormatCID.h"
     1: #include "nsComponentManagerUtils.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsNSSCertificate.h"
     1: 
     1: #include "nspr.h"
     1: #include "nsNSSCertHeader.h"
     1: 
119832: extern "C" {
     1: #include "secerr.h"
119832: }
     1: 
     1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
     1: 
     1: nsUsageArrayHelper::nsUsageArrayHelper(CERTCertificate *aCert)
     1: :mCert(aCert)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   defaultcertdb = CERT_GetDefaultCertDB();
     1:   nssComponent = do_GetService(kNSSComponentCID, &m_rv);
     1: }
     1: 
     1: void
     1: nsUsageArrayHelper::check(const char *suffix,
     1:                         SECCertificateUsage aCertUsage,
108991:                         uint32_t &aCounter,
     1:                         PRUnichar **outUsages)
     1: {
     1:   if (!aCertUsage) return;
110974:   nsAutoCString typestr;
     1:   switch (aCertUsage) {
     1:   case certificateUsageSSLClient:
     1:     typestr = "VerifySSLClient";
     1:     break;
     1:   case certificateUsageSSLServer:
     1:     typestr = "VerifySSLServer";
     1:     break;
     1:   case certificateUsageSSLServerWithStepUp:
     1:     typestr = "VerifySSLStepUp";
     1:     break;
     1:   case certificateUsageEmailSigner:
     1:     typestr = "VerifyEmailSigner";
     1:     break;
     1:   case certificateUsageEmailRecipient:
     1:     typestr = "VerifyEmailRecip";
     1:     break;
     1:   case certificateUsageObjectSigner:
     1:     typestr = "VerifyObjSign";
     1:     break;
     1:   case certificateUsageProtectedObjectSigner:
     1:     typestr = "VerifyProtectObjSign";
     1:     break;
     1:   case certificateUsageUserCertImport:
     1:     typestr = "VerifyUserImport";
     1:     break;
     1:   case certificateUsageSSLCA:
     1:     typestr = "VerifySSLCA";
     1:     break;
     1:   case certificateUsageVerifyCA:
     1:     typestr = "VerifyCAVerifier";
     1:     break;
     1:   case certificateUsageStatusResponder:
     1:     typestr = "VerifyStatusResponder";
     1:     break;
     1:   case certificateUsageAnyCA:
     1:     typestr = "VerifyAnyCA";
     1:     break;
     1:   default:
     1:     break;
     1:   }
     1:   if (!typestr.IsEmpty()) {
     1:     typestr.Append(suffix);
     1:     nsAutoString verifyDesc;
     1:     m_rv = nssComponent->GetPIPNSSBundleString(typestr.get(), verifyDesc);
     1:     if (NS_SUCCEEDED(m_rv)) {
     1:       outUsages[aCounter++] = ToNewUnicode(verifyDesc);
     1:     }
     1:   }
     1: }
     1: 
     1: void
108991: nsUsageArrayHelper::verifyFailed(uint32_t *_verified, int err)
     1: {
     1:   switch (err) {
     1:   /* For these cases, verify only failed for the particular usage */
     1:   case SEC_ERROR_INADEQUATE_KEY_USAGE:
     1:   case SEC_ERROR_INADEQUATE_CERT_TYPE:
     1:     *_verified = nsNSSCertificate::USAGE_NOT_ALLOWED; break;
     1:   /* These are the cases that have individual error messages */
     1:   case SEC_ERROR_REVOKED_CERTIFICATE:
     1:     *_verified = nsNSSCertificate::CERT_REVOKED; break;
     1:   case SEC_ERROR_EXPIRED_CERTIFICATE:
     1:     *_verified = nsNSSCertificate::CERT_EXPIRED; break;
     1:   case SEC_ERROR_UNTRUSTED_CERT:
     1:     *_verified = nsNSSCertificate::CERT_NOT_TRUSTED; break;
     1:   case SEC_ERROR_UNTRUSTED_ISSUER:
     1:     *_verified = nsNSSCertificate::ISSUER_NOT_TRUSTED; break;
     1:   case SEC_ERROR_UNKNOWN_ISSUER:
     1:     *_verified = nsNSSCertificate::ISSUER_UNKNOWN; break;
     1:   case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
     1:     // XXX are there other error for this?
     1:     *_verified = nsNSSCertificate::INVALID_CA; break;
104409:   case SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED:
104409:     *_verified = nsNSSCertificate::SIGNATURE_ALGORITHM_DISABLED; break;
     1:   case SEC_ERROR_CERT_USAGES_INVALID: // XXX what is this?
     1:   // there are some OCSP errors from PSM 1.x to add here
     1:   case SECSuccess:
     1:     // this means, no verification result has ever been received
     1:   default:
     1:     *_verified = nsNSSCertificate::NOT_VERIFIED_UNKNOWN; break;
     1:   }
     1: }
     1: 
     1: nsresult
     1: nsUsageArrayHelper::GetUsagesArray(const char *suffix,
 79445:                       bool localOnly,
108991:                       uint32_t outArraySize,
108991:                       uint32_t *_verified,
108991:                       uint32_t *_count,
     1:                       PRUnichar **outUsages)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (NS_FAILED(m_rv))
     1:     return m_rv;
     1: 
     1:   if (outArraySize < max_returned_out_array_size)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsINSSComponent> nssComponent;
     1: 
 69383:   if (!nsNSSComponent::globalConstFlagUsePKIXVerification && localOnly) {
     1:     nsresult rv;
     1:     nssComponent = do_GetService(kNSSComponentCID, &rv);
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1:     
     1:     if (nssComponent) {
     1:       nssComponent->SkipOcsp();
     1:     }
     1:   }
     1:   
108991:   uint32_t &count = *_count;
     1:   count = 0;
 69383:   SECCertificateUsage usages = 0;
 74084:   int err = 0;
     1:   
 69383: if (!nsNSSComponent::globalConstFlagUsePKIXVerification) {
 74084:   // CERT_VerifyCertificateNow returns SECFailure unless the certificate is
 74084:   // valid for all the given usages. Hoewver, we are only looking for the list
 74084:   // of usages for which the cert *is* valid.
 74084:   (void)
 80486:   CERT_VerifyCertificateNow(defaultcertdb, mCert, true,
     1: 			    certificateUsageSSLClient |
     1: 			    certificateUsageSSLServer |
     1: 			    certificateUsageSSLServerWithStepUp |
     1: 			    certificateUsageEmailSigner |
     1: 			    certificateUsageEmailRecipient |
     1: 			    certificateUsageObjectSigner |
     1: 			    certificateUsageSSLCA |
     1: 			    certificateUsageStatusResponder,
119832: 			    NULL, &usages);
 74084:   err = PR_GetError();
 69383: }
 69383: else {
 69383:   nsresult nsrv;
 69383:   nsCOMPtr<nsINSSComponent> inss = do_GetService(kNSSComponentCID, &nsrv);
 69383:   if (!inss)
 69383:     return nsrv;
119832:   nsRefPtr<nsCERTValInParamWrapper> survivingParams;
 69383:   if (localOnly)
 69383:     nsrv = inss->GetDefaultCERTValInParamLocalOnly(survivingParams);
 69383:   else
 69383:     nsrv = inss->GetDefaultCERTValInParam(survivingParams);
 69383:   
 69383:   if (NS_FAILED(nsrv))
 69383:     return nsrv;
 69383: 
 69383:   CERTValOutParam cvout[2];
 69383:   cvout[0].type = cert_po_usages;
 69383:   cvout[0].value.scalar.usages = 0;
 69383:   cvout[1].type = cert_po_end;
 69383:   
 69383:   CERT_PKIXVerifyCert(mCert, certificateUsageCheckAllUsages,
 69383:                       survivingParams->GetRawPointerForNSS(),
119832:                       cvout, NULL);
 74084:   err = PR_GetError();
 69383:   usages = cvout[0].value.scalar.usages;
 69383: }
 69383: 
     1:   // The following list of checks must be < max_returned_out_array_size
     1:   
     1:   check(suffix, usages & certificateUsageSSLClient, count, outUsages);
     1:   check(suffix, usages & certificateUsageSSLServer, count, outUsages);
     1:   check(suffix, usages & certificateUsageSSLServerWithStepUp, count, outUsages);
     1:   check(suffix, usages & certificateUsageEmailSigner, count, outUsages);
     1:   check(suffix, usages & certificateUsageEmailRecipient, count, outUsages);
     1:   check(suffix, usages & certificateUsageObjectSigner, count, outUsages);
     1: #if 0
     1:   check(suffix, usages & certificateUsageProtectedObjectSigner, count, outUsages);
     1:   check(suffix, usages & certificateUsageUserCertImport, count, outUsages);
     1: #endif
     1:   check(suffix, usages & certificateUsageSSLCA, count, outUsages);
     1: #if 0
     1:   check(suffix, usages & certificateUsageVerifyCA, count, outUsages);
     1: #endif
     1:   check(suffix, usages & certificateUsageStatusResponder, count, outUsages);
     1: #if 0
     1:   check(suffix, usages & certificateUsageAnyCA, count, outUsages);
     1: #endif
     1: 
 69383:   if (!nsNSSComponent::globalConstFlagUsePKIXVerification && localOnly && nssComponent) {
     1:     nssComponent->SkipOcspOff();
     1:   }
     1: 
 74084:   if (count == 0) {
 74084:     verifyFailed(_verified, err);
 74084:   } else {
     1:     *_verified = nsNSSCertificate::VERIFIED_OK;
 74084:   }
     1:   return NS_OK;
     1: }
