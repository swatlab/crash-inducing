    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:ts=2:et:sw=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Dan Rosen <dr@netscape.com>
38004:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * construction of a frame tree that is nearly isomorphic to the content
    1:  * tree and updating of that tree in response to dynamic changes
    1:  */
    1: 
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsCRT.h"
    1: #include "nsIAtom.h"
    1: #include "nsIURL.h"
    1: #include "nsHashtable.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIStyleRule.h"
    1: #include "nsIFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsPresContext.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIDocument.h"
    1: #include "nsTableFrame.h"
    1: #include "nsTableColGroupFrame.h"
    1: #include "nsTableColFrame.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMHTMLTableColElement.h"
    1: #include "nsIDOMHTMLTableCaptionElem.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsIPresShell.h"
33262: #include "nsUnicharUtils.h"
    1: #include "nsStyleSet.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsTableOuterFrame.h"
    1: #include "nsIDOMXULElement.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDOMHTMLSelectElement.h"
    1: #include "nsIDOMHTMLLegendElement.h"
    1: #include "nsIComboboxControlFrame.h"
    1: #include "nsIListControlFrame.h"
    1: #include "nsISelectControlFrame.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsPlaceholderFrame.h"
    1: #include "nsTableRowGroupFrame.h"
    1: #include "nsStyleChangeList.h"
    1: #include "nsIFormControl.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsTextFragment.h"
    1: #include "nsIAnonymousContentCreator.h"
    1: #include "nsFrameManager.h"
    1: #include "nsLegendFrame.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsBindingManager.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsITheme.h"
    1: #include "nsContentCID.h"
    1: #include "nsContentUtils.h"
 7189: #include "nsIScriptError.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsObjectFrame.h"
    1: #include "nsRuleNode.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsChildIterator.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsISelectElement.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsBoxFrame.h"
    1: #include "nsIBoxLayout.h"
    1: #include "nsImageFrame.h"
    1: #include "nsIObjectLoadingContent.h"
    1: #include "nsContentErrors.h"
 3645: #include "nsIPrincipal.h"
    1: #include "nsIDOMWindowInternal.h"
11845: #include "nsStyleUtil.h"
    1: #include "nsBox.h"
24551: #include "nsTArray.h"
27311: #include "nsGenericDOMDataNode.h"
41930: #include "mozilla/dom/Element.h"
47753: #include "FrameLayerBuilder.h"
    1: 
    1: #ifdef MOZ_XUL
    1: #include "nsIRootBox.h"
    1: #include "nsIDOMXULCommandDispatcher.h"
    1: #include "nsIDOMXULDocument.h"
    1: #include "nsIXULDocument.h"
    1: #endif
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #include "nsIAccessibleEvent.h"
    1: #endif
    1: 
    1: #include "nsInlineFrame.h"
    1: #include "nsBlockFrame.h"
    1: 
    1: #include "nsIScrollableFrame.h"
    1: 
    1: #include "nsIXBLService.h"
    1: 
    1: #undef NOISY_FIRST_LETTER
    1: 
    1: #ifdef MOZ_MATHML
    1: #include "nsMathMLParts.h"
    1: #endif
16411: #ifdef MOZ_SVG
28081: #include "nsSVGFeatures.h"
19948: #include "nsSVGEffects.h"
24030: #include "nsSVGUtils.h"
24030: #include "nsSVGOuterSVGFrame.h"
16411: #endif
    1: 
50698: #include "nsRefreshDriver.h"
50698: 
39965: using namespace mozilla;
41634: using namespace mozilla::dom;
39965: 
    1: nsIFrame*
    1: NS_NewHTMLCanvasFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
15751: #if defined(MOZ_MEDIA)
15751: nsIFrame*
15751: NS_NewHTMLVideoFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
15751: #endif
15751: 
    1: #ifdef MOZ_SVG
29052: #include "nsSVGTextContainerFrame.h"
    1: 
    1: PRBool
    1: NS_SVGEnabled();
    1: nsIFrame*
23953: NS_NewSVGOuterSVGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGInnerSVGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGPathGeometryFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGGenericContainerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGForeignObjectFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGAFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGGlyphFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGSwitchFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
15895: nsIFrame*
23953: NS_NewSVGTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGTSpanFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGContainerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGUseFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: extern nsIFrame*
23953: NS_NewSVGLinearGradientFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: extern nsIFrame*
23953: NS_NewSVGRadialGradientFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: extern nsIFrame*
23953: NS_NewSVGStopFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGMarkerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: extern nsIFrame*
23953: NS_NewSVGImageFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGClipPathFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGTextPathFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGFilterFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGPatternFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23953: NS_NewSVGMaskFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
    1: NS_NewSVGLeafFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: #endif
    1: 
    1: #include "nsIDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentXBL.h"
    1: #include "nsIScrollable.h"
    1: #include "nsINodeInfo.h"
    1: #include "prenv.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsIServiceManager.h"
    1: 
    1: // Global object maintenance
    1: nsIXBLService * nsCSSFrameConstructor::gXBLService = nsnull;
    1: 
    1: #ifdef DEBUG
    1: // Set the environment variable GECKO_FRAMECTOR_DEBUG_FLAGS to one or
    1: // more of the following flags (comma separated) for handy debug
    1: // output.
    1: static PRBool gNoisyContentUpdates = PR_FALSE;
    1: static PRBool gReallyNoisyContentUpdates = PR_FALSE;
    1: static PRBool gNoisyInlineConstruction = PR_FALSE;
    1: 
    1: struct FrameCtorDebugFlags {
    1:   const char* name;
    1:   PRBool* on;
    1: };
    1: 
    1: static FrameCtorDebugFlags gFlags[] = {
    1:   { "content-updates",              &gNoisyContentUpdates },
    1:   { "really-noisy-content-updates", &gReallyNoisyContentUpdates },
36653:   { "noisy-inline",                 &gNoisyInlineConstruction }
    1: };
    1: 
    1: #define NUM_DEBUG_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
    1: #endif
    1: 
    1: 
    1: #ifdef MOZ_XUL
    1: #include "nsMenuFrame.h"
38004: #include "nsMenuPopupFrame.h"
    1: #include "nsPopupSetFrame.h"
    1: #include "nsTreeColFrame.h"
    1: #include "nsIBoxObject.h"
    1: #include "nsPIListBoxObject.h"
    1: #include "nsListBoxBodyFrame.h"
    1: #include "nsListItemFrame.h"
23176: #include "nsXULLabelFrame.h"
    1: 
    1: //------------------------------------------------------------------
    1: 
    1: nsIFrame*
    1: NS_NewAutoRepeatBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewRootBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewDocElementBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewThumbFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
23947: NS_NewDeckFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewLeafBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
23947: NS_NewStackFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewProgressMeterFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewImageBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewTextBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewGroupBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewButtonBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewSplitterFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewMenuPopupFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewPopupSetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewMenuFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
    1: 
    1: nsIFrame*
    1: NS_NewMenuBarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewTreeBodyFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: // grid
    1: nsresult
    1: NS_NewGridLayout2 ( nsIPresShell* aPresShell, nsIBoxLayout** aNewLayout );
    1: nsIFrame*
23947: NS_NewGridRowLeafFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: nsIFrame*
23947: NS_NewGridRowGroupFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: // end grid
    1: 
    1: nsIFrame*
    1: NS_NewTitleBarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewResizerFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: 
    1: #endif
    1: 
    1: nsIFrame*
    1: NS_NewHTMLScrollFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot);
    1: 
    1: nsIFrame*
    1: NS_NewXULScrollFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot);
    1: 
    1: nsIFrame*
    1: NS_NewSliderFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewScrollbarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: nsIFrame*
    1: NS_NewScrollbarButtonFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: 
    1: #ifdef NOISY_FINDFRAME
    1: static PRInt32 FFWC_totalCount=0;
    1: static PRInt32 FFWC_doLoop=0;
    1: static PRInt32 FFWC_doSibling=0;
    1: static PRInt32 FFWC_recursions=0;
    1: static PRInt32 FFWC_nextInFlows=0;
    1: #endif
    1: 
    1: static inline nsIFrame*
23176: GetFieldSetBlockFrame(nsIFrame* aFieldsetFrame)
    1: {
    1:   // Depends on the fieldset child frame order - see ConstructFieldSetFrame() below.
    1:   nsIFrame* firstChild = aFieldsetFrame->GetFirstChild(nsnull);
    1:   return firstChild && firstChild->GetNextSibling() ? firstChild->GetNextSibling() : firstChild;
    1: }
    1: 
30785: #define FCDATA_DECL(_flags, _func) \
30785:   { _flags, { (FrameCreationFunc)_func } }
30785: 
    1: //----------------------------------------------------------------------
    1: 
    1: static PRBool
 2829: IsInlineOutside(nsIFrame* aFrame)
 2829: {
 2829:   return aFrame->GetStyleDisplay()->IsInlineOutside();
 2829: }
 2829: 
 4696: /**
 4696:  * True if aFrame is an actual inline frame in the sense of non-replaced
 4696:  * display:inline CSS boxes.  In other words, it can be affected by {ib}
 4696:  * splitting and can contain first-letter frames.  Basically, this is either an
 4696:  * inline frame (positioned or otherwise) or an line frame (this last because
 4696:  * it can contain first-letter and because inserting blocks in the middle of it
 4696:  * needs to terminate it).
 4696:  */
    1: static PRBool
 4696: IsInlineFrame(const nsIFrame* aFrame)
 4696: {
 4696:   return aFrame->IsFrameOfType(nsIFrame::eLineParticipant);
    1: }
    1: 
 7189: /**
 7189:  * If any children require a block parent, return the first such child.
 7189:  * Otherwise return null.
 7189:  */
 7189: static nsIContent*
 7189: AnyKidsNeedBlockParent(nsIFrame *aFrameList)
 7189: {
 7189:   for (nsIFrame *k = aFrameList; k; k = k->GetNextSibling()) {
 7189:     // Line participants, such as text and inline frames, can't be
 7189:     // directly inside a XUL box; they must be wrapped in an
 7189:     // intermediate block.
 7189:     if (k->IsFrameOfType(nsIFrame::eLineParticipant)) {
 7189:       return k->GetContent();
 7189:     }
 7189:   }
 7189:   return nsnull;
 7189: }
 7189: 
 7189: // Reparent a frame into a wrapper frame that is a child of its old parent.
 7189: static void
 7189: ReparentFrame(nsFrameManager* aFrameManager,
 7189:               nsIFrame* aNewParentFrame,
 7189:               nsIFrame* aFrame)
 7189: {
 7189:   aFrame->SetParent(aNewParentFrame);
40137:   aFrameManager->ReparentStyleContext(aFrame);
 7189: }
 7189: 
30785: static void
30785: ReparentFrames(nsFrameManager* aFrameManager,
30785:                nsIFrame* aNewParentFrame,
30785:                const nsFrameList& aFrameList)
30785: {
30785:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
30785:     ReparentFrame(aFrameManager, aNewParentFrame, e.get());
30785:   }
30785: }
30785: 
    1: //----------------------------------------------------------------------
 5324: //
 5324: // When inline frames get weird and have block frames in them, we
 5324: // annotate them to help us respond to incremental content changes
 5324: // more easily.
 5324: 
 5324: static inline PRBool
 5324: IsFrameSpecial(nsIFrame* aFrame)
 5324: {
 5324:   return (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) != 0;
 5324: }
 5324: 
 5324: static nsIFrame* GetSpecialSibling(nsIFrame* aFrame)
 5324: {
34459:   NS_PRECONDITION(IsFrameSpecial(aFrame), "Shouldn't call this");
34459: 
 5324:   // We only store the "special sibling" annotation with the first
 5324:   // frame in the continuation chain. Walk back to find that frame now.
39965:   return static_cast<nsIFrame*>
34459:     (aFrame->GetFirstContinuation()->
39965:        Properties().Get(nsIFrame::IBSplitSpecialSibling()));
34459: }
34459: 
34459: static nsIFrame* GetSpecialPrevSibling(nsIFrame* aFrame)
34459: {
34459:   NS_PRECONDITION(IsFrameSpecial(aFrame), "Shouldn't call this");
 5324:   
 5324:   // We only store the "special sibling" annotation with the first
 5324:   // frame in the continuation chain. Walk back to find that frame now.  
39965:   return static_cast<nsIFrame*>
 5324:     (aFrame->GetFirstContinuation()->
39965:        Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
 5324: }
 5324: 
 5324: static nsIFrame*
34462: GetLastSpecialSibling(nsIFrame* aFrame, PRBool aReturnEmptyTrailingInline)
 5324: {
 5324:   for (nsIFrame *frame = aFrame, *next; ; frame = next) {
 5324:     next = GetSpecialSibling(frame);
25738:     if (!next ||
34462:         (!aReturnEmptyTrailingInline && !next->GetFirstChild(nsnull) &&
34462:          !GetSpecialSibling(next))) {
34462:       NS_ASSERTION(!next || !IsInlineOutside(frame),
34462:                    "Should have a block here!");
 5324:       return frame;
 5324:     }
34462:   }
 5324:   NS_NOTREACHED("unreachable code");
 5324:   return nsnull;
 5324: }
 5324: 
 5324: static void
 5324: SetFrameIsSpecial(nsIFrame* aFrame, nsIFrame* aSpecialSibling)
 5324: {
 5324:   NS_PRECONDITION(aFrame, "bad args!");
 5324: 
34459:   // We should be the only continuation
28217:   NS_ASSERTION(!aFrame->GetPrevContinuation(),
28217:                "assigning special sibling to other than first continuation!");
34462:   NS_ASSERTION(!aFrame->GetNextContinuation() ||
34462:                IsFrameSpecial(aFrame->GetNextContinuation()),
34462:                "should have no non-special continuations here");
34459: 
34459:   // Mark the frame as "special".
34459:   aFrame->AddStateBits(NS_FRAME_IS_SPECIAL);
34459: 
34459:   if (aSpecialSibling) {
34459:     NS_ASSERTION(!aSpecialSibling->GetPrevContinuation(),
34459:                  "assigning something other than the first continuation as the "
34459:                  "special sibling");
 5324: 
 5324:     // Store the "special sibling" (if we were given one) with the
 5324:     // first frame in the flow.
39965:     FramePropertyTable* props = aFrame->PresContext()->PropertyTable();
39965:     props->Set(aFrame, nsIFrame::IBSplitSpecialSibling(), aSpecialSibling);
39965:     props->Set(aSpecialSibling, nsIFrame::IBSplitSpecialPrevSibling(), aFrame);
 5324:   }
 5324: }
 5324: 
 5324: static nsIFrame*
 5324: GetIBContainingBlockFor(nsIFrame* aFrame)
 5324: {
 5324:   NS_PRECONDITION(IsFrameSpecial(aFrame),
 5324:                   "GetIBContainingBlockFor() should only be called on known IB frames");
 5324: 
 5324:   // Get the first "normal" ancestor of the target frame.
 5324:   nsIFrame* parentFrame;
 5324:   do {
 5324:     parentFrame = aFrame->GetParent();
 5324: 
 5324:     if (! parentFrame) {
 5324:       NS_ERROR("no unsplit block frame in IB hierarchy");
 5324:       return aFrame;
 5324:     }
 5324: 
 5324:     // Note that we ignore non-special frames which have a pseudo on their
 5324:     // style context -- they're not the frames we're looking for!  In
 5324:     // particular, they may be hiding a real parent that _is_ special.
 5324:     if (!IsFrameSpecial(parentFrame) &&
34387:         !parentFrame->GetStyleContext()->GetPseudo())
 5324:       break;
 5324: 
 5324:     aFrame = parentFrame;
 5324:   } while (1);
 5324:  
 5324:   // post-conditions
 5324:   NS_ASSERTION(parentFrame, "no normal ancestor found for special frame in GetIBContainingBlockFor");
 5324:   NS_ASSERTION(parentFrame != aFrame, "parentFrame is actually the child frame - bogus reslt");
 5324: 
 5324:   return parentFrame;
 5324: }
 5324: 
 5324: //----------------------------------------------------------------------
    1: 
    1: // Block/inline frame construction logic. We maintain a few invariants here:
    1: //
    1: // 1. Block frames contain block and inline frames.
    1: //
    1: // 2. Inline frames only contain inline frames. If an inline parent has a block
    1: // child then the block child is migrated upward until it lands in a block
    1: // parent (the inline frames containing block is where it will end up).
    1: 
30789: // After this function returns, aLink is pointing to the first link at or
30789: // after its starting position for which the next frame is a block.  If there
30789: // is no such link, it points to the end of the list.
30789: static void
30789: FindFirstBlock(nsFrameList::FrameLinkEnumerator& aLink)
30789: {
30789:   for ( ; !aLink.AtEnd(); aLink.Next()) {
30789:     if (!IsInlineOutside(aLink.NextFrame())) {
30789:       return;
30789:     }
30789:   }
30789: }
30789: 
34462: // This function returns a frame link enumerator pointing to the first link in
34462: // the list for which the next frame is not block.  If there is no such link,
34462: // it points to the end of the list.
30789: static nsFrameList::FrameLinkEnumerator
34462: FindFirstNonBlock(const nsFrameList& aList)
34462: {
34462:   nsFrameList::FrameLinkEnumerator link(aList);
34462:   for (; !link.AtEnd(); link.Next()) {
34462:     if (IsInlineOutside(link.NextFrame())) {
34462:       break;
34462:     }
34462:   }
34462:   return link;
    1: }
    1: 
30790: inline void
30790: SetInitialSingleChild(nsIFrame* aParent, nsIFrame* aFrame)
30790: {
30790:   NS_PRECONDITION(!aFrame->GetNextSibling(), "Should be using a frame list");
32846:   nsFrameList temp(aFrame, aFrame);
30790:   aParent->SetInitialChildList(nsnull, temp);
30790: }
30790: 
    1: // -----------------------------------------------------------
    1: 
32843: // Structure used when constructing formatting object trees.
32843: struct nsFrameItems : public nsFrameList
32843: {
32843:   // Appends the frame to the end of the list
32843:   void AddChild(nsIFrame* aChild);
32843: };
    1: 
    1: void 
    1: nsFrameItems::AddChild(nsIFrame* aChild)
    1: {
32843:   NS_PRECONDITION(aChild, "nsFrameItems::AddChild");
32843: 
32843:   // It'd be really nice if we could just AppendFrames(nsnull, aChild) here,
32843:   // but some of our callers put frames that have different
30785:   // parents (caption, I'm looking at you) on the same framelist, and
30785:   // nsFrameList asserts if you try to do that.
30785:   if (IsEmpty()) {
32843:     SetFrames(aChild);
32843:   }
32843:   else {
32843:     NS_ASSERTION(aChild != mLastChild,
    1:                  "Same frame being added to frame list twice?");
32843:     mLastChild->SetNextSibling(aChild);
32843:     mLastChild = nsLayoutUtils::GetLastSibling(aChild);
32843:   }
    1: }
    1: 
    1: // -----------------------------------------------------------
    1: 
    1: // Structure used when constructing formatting object trees. Contains
    1: // state information needed for absolutely positioned elements
    1: struct nsAbsoluteItems : nsFrameItems {
    1:   // containing block for absolutely positioned elements
    1:   nsIFrame* containingBlock;
    1:   
    1:   nsAbsoluteItems(nsIFrame* aContainingBlock);
    1: #ifdef DEBUG
    1:   // XXXbz Does this need a debug-only assignment operator that nulls out the
    1:   // childList in the nsAbsoluteItems we're copying?  Introducing a difference
    1:   // between debug and non-debug behavior seems bad, so I guess not...
    1:   ~nsAbsoluteItems() {
30785:     NS_ASSERTION(!FirstChild(),
    1:                  "Dangling child list.  Someone forgot to insert it?");
    1:   }
    1: #endif
    1:   
    1:   // Appends the frame to the end of the list
    1:   void AddChild(nsIFrame* aChild);
    1: };
    1: 
    1: nsAbsoluteItems::nsAbsoluteItems(nsIFrame* aContainingBlock)
    1:   : containingBlock(aContainingBlock)
    1: {
    1: }
    1: 
    1: // Additional behavior is that it sets the frame's NS_FRAME_OUT_OF_FLOW flag
    1: void
    1: nsAbsoluteItems::AddChild(nsIFrame* aChild)
    1: {
  238:   NS_ASSERTION(aChild->PresContext()->FrameManager()->
    1:                GetPlaceholderFrameFor(aChild),
    1:                "Child without placeholder being added to nsAbsoluteItems?");
    1:   aChild->AddStateBits(NS_FRAME_OUT_OF_FLOW);
    1:   nsFrameItems::AddChild(aChild);
    1: }
    1: 
    1: // -----------------------------------------------------------
    1: 
    1: // Structure for saving the existing state when pushing/poping containing
    1: // blocks. The destructor restores the state to its previous state
25768: class NS_STACK_CLASS nsFrameConstructorSaveState {
    1: public:
    1:   nsFrameConstructorSaveState();
    1:   ~nsFrameConstructorSaveState();
    1: 
    1: private:
    1:   nsAbsoluteItems* mItems;                // pointer to struct whose data we save/restore
25768:   PRPackedBool*    mFixedPosIsAbsPos;
    1: 
    1:   nsAbsoluteItems  mSavedItems;           // copy of original data
25768:   PRPackedBool     mSavedFixedPosIsAbsPos;
    1: 
    1:   // The name of the child list in which our frames would belong
    1:   nsIAtom* mChildListName;
    1:   nsFrameConstructorState* mState;
    1: 
    1:   friend class nsFrameConstructorState;
    1: };
    1: 
34614: // Structure used to keep track of a list of bindings we need to call
34614: // AddToAttachedQueue on.  These should be in post-order depth-first
34614: // flattened tree traversal order.
34614: struct PendingBinding : public PRCList
34614: {
34614: #ifdef NS_BUILD_REFCNT_LOGGING
34614:   PendingBinding() {
34614:     MOZ_COUNT_CTOR(PendingBinding);
34614:   }
34614:   ~PendingBinding() {
34614:     MOZ_COUNT_DTOR(PendingBinding);
34614:   }
34614: #endif
34614: 
34614:   nsRefPtr<nsXBLBinding> mBinding;
34614: };
34614: 
    1: // Structure used for maintaining state information during the
    1: // frame construction process
15599: class NS_STACK_CLASS nsFrameConstructorState {
    1: public:
    1:   nsPresContext            *mPresContext;
    1:   nsIPresShell             *mPresShell;
    1:   nsFrameManager           *mFrameManager;
    1: 
    1: #ifdef MOZ_XUL
    1:   // Frames destined for the nsGkAtoms::popupList.
    1:   nsAbsoluteItems           mPopupItems;
    1: #endif
    1: 
    1:   // Containing block information for out-of-flow frames.
    1:   nsAbsoluteItems           mFixedItems;
    1:   nsAbsoluteItems           mAbsoluteItems;
    1:   nsAbsoluteItems           mFloatedItems;
19214: 
28329:   nsCOMPtr<nsILayoutHistoryState> mFrameState;
28329:   // These bits will be added to the state bits of any frame we construct
28329:   // using this state.
28329:   nsFrameState              mAdditionalStateBits;
28329: 
19214:   // When working with the -moz-transform property, we want to hook
19214:   // the abs-pos and fixed-pos lists together, since transformed
19214:   // elements are fixed-pos containing blocks.  This flag determines
19214:   // whether or not we want to wire the fixed-pos and abs-pos lists
19214:   // together.
25768:   PRPackedBool              mFixedPosIsAbsPos;
25768: 
25768:   // A boolean to indicate whether we have a "pending" popupgroup.  That is, we
25768:   // have already created the FrameConstructionItem for the root popupgroup but
25768:   // we have not yet created the relevant frame.
25768:   PRPackedBool              mHavePendingPopupgroup;
19214: 
41931:   // If true (which is the default) then call SetPrimaryFrame() as needed
41931:   // during frame construction.  If false, don't make any SetPrimaryFrame()
41931:   // calls.  The mSetPrimaryFrames == PR_FALSE mode is meant to be used for
41931:   // construction of random "extra" frames for elements via normal frame
41931:   // construction APIs (e.g. replication of things across pages in paginated
41931:   // mode).
41931:   PRPackedBool              mSetPrimaryFrames;
41931: 
31438:   nsCOMArray<nsIContent>    mGeneratedTextNodesWithInitializer;
31438: 
    1:   // Constructor
    1:   // Use the passed-in history state.
    1:   nsFrameConstructorState(nsIPresShell*          aPresShell,
    1:                           nsIFrame*              aFixedContainingBlock,
    1:                           nsIFrame*              aAbsoluteContainingBlock,
    1:                           nsIFrame*              aFloatContainingBlock,
    1:                           nsILayoutHistoryState* aHistoryState);
    1:   // Get the history state from the pres context's pres shell.
    1:   nsFrameConstructorState(nsIPresShell*          aPresShell,
    1:                           nsIFrame*              aFixedContainingBlock,
    1:                           nsIFrame*              aAbsoluteContainingBlock,
    1:                           nsIFrame*              aFloatContainingBlock);
    1: 
    1:   ~nsFrameConstructorState();
    1:   
    1:   // Function to push the existing absolute containing block state and
    1:   // create a new scope. Code that uses this function should get matching
    1:   // logic in GetAbsoluteContainingBlock.
    1:   void PushAbsoluteContainingBlock(nsIFrame* aNewAbsoluteContainingBlock,
    1:                                    nsFrameConstructorSaveState& aSaveState);
    1: 
    1:   // Function to push the existing float containing block state and
    1:   // create a new scope. Code that uses this function should get matching
    1:   // logic in GetFloatContainingBlock.
    1:   // Pushing a null float containing block forbids any frames from being
    1:   // floated until a new float containing block is pushed.
    1:   // XXX we should get rid of null float containing blocks and teach the
    1:   // various frame classes to deal with floats instead.
    1:   void PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
23352:                                 nsFrameConstructorSaveState& aSaveState);
    1: 
    1:   // Function to return the proper geometric parent for a frame with display
    1:   // struct given by aStyleDisplay and parent's frame given by
23944:   // aContentParentFrame.
    1:   nsIFrame* GetGeometricParent(const nsStyleDisplay* aStyleDisplay,
    1:                                nsIFrame* aContentParentFrame);
    1: 
    1:   /**
    1:    * Function to add a new frame to the right frame list.  This MUST be called
    1:    * on frames before their children have been processed if the frames might
    1:    * conceivably be out-of-flow; otherwise cleanup in error cases won't work
    1:    * right.  Also, this MUST be called on frames after they have been
    1:    * initialized.
    1:    * @param aNewFrame the frame to add
    1:    * @param aFrameItems the list to add in-flow frames to
    1:    * @param aContent the content pointer for aNewFrame
 7807:    * @param aStyleContext the style context resolved for aContent
    1:    * @param aParentFrame the parent frame for the content if it were in-flow
    1:    * @param aCanBePositioned pass false if the frame isn't allowed to be
    1:    *        positioned
    1:    * @param aCanBeFloated pass false if the frame isn't allowed to be
    1:    *        floated
    1:    * @param aIsOutOfFlowPopup pass true if the frame is an out-of-flow popup
    1:    *        (XUL-only)
    1:    * @throws NS_ERROR_OUT_OF_MEMORY if it happens.
    1:    * @note If this method throws, that means that aNewFrame was not inserted
    1:    *       into any frame lists.  Furthermore, this method will handle cleanup
36646:    *       of aNewFrame (via calling Destroy() on it).
    1:    */
    1:   nsresult AddChild(nsIFrame* aNewFrame,
    1:                     nsFrameItems& aFrameItems,
    1:                     nsIContent* aContent,
    1:                     nsStyleContext* aStyleContext,
    1:                     nsIFrame* aParentFrame,
    1:                     PRBool aCanBePositioned = PR_TRUE,
    1:                     PRBool aCanBeFloated = PR_TRUE,
    1:                     PRBool aIsOutOfFlowPopup = PR_FALSE,
    1:                     PRBool aInsertAfter = PR_FALSE,
    1:                     nsIFrame* aInsertAfterFrame = nsnull);
    1: 
19214:   /**
19214:    * Function to return the fixed-pos element list.  Normally this will just hand back the
19214:    * fixed-pos element list, but in case we're dealing with a transformed element that's
19214:    * acting as an abs-pos and fixed-pos container, we'll hand back the abs-pos list.  Callers should
19214:    * use this function if they want to get the list acting as the fixed-pos item parent.
19214:    */
19214:   nsAbsoluteItems& GetFixedItems()
19214:   {
19214:     return mFixedPosIsAbsPos ? mAbsoluteItems : mFixedItems;
19214:   }
19214:   const nsAbsoluteItems& GetFixedItems() const
19214:   {
19214:     return mFixedPosIsAbsPos ? mAbsoluteItems : mFixedItems;
19214:   }
19214: 
34614: 
34614:   /**
34614:    * class to automatically push and pop a pending binding in the frame
34614:    * constructor state.  See nsCSSFrameConstructor::FrameConstructionItem
34614:    * mPendingBinding documentation.
34614:    */
34614:   class PendingBindingAutoPusher;
34614:   friend class PendingBindingAutoPusher;
34614:   class NS_STACK_CLASS PendingBindingAutoPusher {
34614:   public:
34614:     PendingBindingAutoPusher(nsFrameConstructorState& aState,
34614:                              PendingBinding* aPendingBinding) :
34614:       mState(aState),
34614:       mPendingBinding(aState.mCurrentPendingBindingInsertionPoint)
34614:         {
34614:           NS_PRECONDITION(mPendingBinding, "how did that happen?");
34614:           if (aPendingBinding) {
34614:             aState.mCurrentPendingBindingInsertionPoint = aPendingBinding;
34614:           }
34614:         }
34614: 
34614:     ~PendingBindingAutoPusher()
34614:       {
34614:         mState.mCurrentPendingBindingInsertionPoint = mPendingBinding;
34614:       }
34614: 
34614:   private:
34614:     nsFrameConstructorState& mState;
34614:     PRCList* mPendingBinding;
34614:   };
34614: 
34614:   /**
34614:    * Add a new pending binding to the list
34614:    */
34614:   void AddPendingBinding(PendingBinding* aPendingBinding) {
34614:     PR_INSERT_BEFORE(aPendingBinding, mCurrentPendingBindingInsertionPoint);
34614:   }
34614: 
    1: protected:
    1:   friend class nsFrameConstructorSaveState;
    1: 
    1:   /**
    1:    * ProcessFrameInsertions takes the frames in aFrameItems and adds them as
    1:    * kids to the aChildListName child list of |aFrameItems.containingBlock|.
    1:    */
    1:   void ProcessFrameInsertions(nsAbsoluteItems& aFrameItems,
    1:                               nsIAtom* aChildListName);
34614: 
34614:   // Our list of all pending bindings.  When we're done, we need to call
34614:   // AddToAttachedQueue on all of them, in order.
34614:   PRCList mPendingBindings;
34614: 
34614:   PRCList* mCurrentPendingBindingInsertionPoint;
    1: };
    1: 
    1: nsFrameConstructorState::nsFrameConstructorState(nsIPresShell*          aPresShell,
    1:                                                  nsIFrame*              aFixedContainingBlock,
    1:                                                  nsIFrame*              aAbsoluteContainingBlock,
    1:                                                  nsIFrame*              aFloatContainingBlock,
    1:                                                  nsILayoutHistoryState* aHistoryState)
    1:   : mPresContext(aPresShell->GetPresContext()),
    1:     mPresShell(aPresShell),
    1:     mFrameManager(aPresShell->FrameManager()),
    1: #ifdef MOZ_XUL    
23951:     mPopupItems(nsnull),
    1: #endif
    1:     mFixedItems(aFixedContainingBlock),
    1:     mAbsoluteItems(aAbsoluteContainingBlock),
    1:     mFloatedItems(aFloatContainingBlock),
22341:     // See PushAbsoluteContaningBlock below
28329:     mFrameState(aHistoryState),
28329:     mAdditionalStateBits(0),
22341:     mFixedPosIsAbsPos(aAbsoluteContainingBlock &&
22341:                       aAbsoluteContainingBlock->GetStyleDisplay()->
22341:                         HasTransform()),
34614:     mHavePendingPopupgroup(PR_FALSE),
41931:     mSetPrimaryFrames(PR_TRUE),
34614:     mCurrentPendingBindingInsertionPoint(&mPendingBindings)
    1: {
23951: #ifdef MOZ_XUL
23951:   nsIRootBox* rootBox = nsIRootBox::GetRootBox(aPresShell);
23951:   if (rootBox) {
23951:     mPopupItems.containingBlock = rootBox->GetPopupSetFrame();
23951:   }
23951: #endif
 5327:   MOZ_COUNT_CTOR(nsFrameConstructorState);
34614:   PR_INIT_CLIST(&mPendingBindings);
    1: }
    1: 
    1: nsFrameConstructorState::nsFrameConstructorState(nsIPresShell* aPresShell,
    1:                                                  nsIFrame*     aFixedContainingBlock,
    1:                                                  nsIFrame*     aAbsoluteContainingBlock,
    1:                                                  nsIFrame*     aFloatContainingBlock)
    1:   : mPresContext(aPresShell->GetPresContext()),
    1:     mPresShell(aPresShell),
    1:     mFrameManager(aPresShell->FrameManager()),
    1: #ifdef MOZ_XUL    
23951:     mPopupItems(nsnull),
    1: #endif
    1:     mFixedItems(aFixedContainingBlock),
    1:     mAbsoluteItems(aAbsoluteContainingBlock),
    1:     mFloatedItems(aFloatContainingBlock),
22341:     // See PushAbsoluteContaningBlock below
28329:     mAdditionalStateBits(0),
22341:     mFixedPosIsAbsPos(aAbsoluteContainingBlock &&
22341:                       aAbsoluteContainingBlock->GetStyleDisplay()->
22341:                         HasTransform()),
34614:     mHavePendingPopupgroup(PR_FALSE),
41931:     mSetPrimaryFrames(PR_TRUE),
34614:     mCurrentPendingBindingInsertionPoint(&mPendingBindings)
    1: {
23951: #ifdef MOZ_XUL
23951:   nsIRootBox* rootBox = nsIRootBox::GetRootBox(aPresShell);
23951:   if (rootBox) {
23951:     mPopupItems.containingBlock = rootBox->GetPopupSetFrame();
23951:   }
23951: #endif
 5327:   MOZ_COUNT_CTOR(nsFrameConstructorState);
    1:   mFrameState = aPresShell->GetDocument()->GetLayoutHistoryState();
34614:   PR_INIT_CLIST(&mPendingBindings);
    1: }
    1: 
    1: nsFrameConstructorState::~nsFrameConstructorState()
    1: {
    1:   // Frame order comparison functions only work properly when the placeholders
    1:   // have been inserted into the frame tree. So for example if we have a new float
    1:   // containing the placeholder for a new abs-pos frame, and we process the abs-pos
    1:   // insertion first, then we won't be able to find the right place to insert in
    1:   // in the abs-pos list. So put floats in first, because they can contain placeholders
    1:   // for abs-pos and fixed-pos items whose containing blocks are outside the floats.
    1:   // Then put abs-pos frames in, because they can contain placeholders for fixed-pos
    1:   // items whose containing block is outside the abs-pos frames. 
 5327:   MOZ_COUNT_DTOR(nsFrameConstructorState);
    1:   ProcessFrameInsertions(mFloatedItems, nsGkAtoms::floatList);
    1:   ProcessFrameInsertions(mAbsoluteItems, nsGkAtoms::absoluteList);
    1:   ProcessFrameInsertions(mFixedItems, nsGkAtoms::fixedList);
    1: #ifdef MOZ_XUL
    1:   ProcessFrameInsertions(mPopupItems, nsGkAtoms::popupList);
    1: #endif
31438:   for (PRInt32 i = mGeneratedTextNodesWithInitializer.Count() - 1; i >= 0; --i) {
31438:     mGeneratedTextNodesWithInitializer[i]->
31438:       DeleteProperty(nsGkAtoms::genConInitializerProperty);
31438:   }
34614:   if (!PR_CLIST_IS_EMPTY(&mPendingBindings)) {
34614:     nsBindingManager* bindingManager = mPresShell->GetDocument()->BindingManager();
34614:     do {
34614:       PendingBinding* pendingBinding =
34614:         static_cast<PendingBinding*>(PR_NEXT_LINK(&mPendingBindings));
34614:       PR_REMOVE_LINK(pendingBinding);
34614:       bindingManager->AddToAttachedQueue(pendingBinding->mBinding);
34614:       delete pendingBinding;
34614:     } while (!PR_CLIST_IS_EMPTY(&mPendingBindings));
34614:   }
    1: }
    1: 
    1: static nsIFrame*
 7680: AdjustAbsoluteContainingBlock(nsIFrame* aContainingBlockIn)
    1: {
    1:   if (!aContainingBlockIn) {
    1:     return nsnull;
    1:   }
    1:   
 7680:   // Always use the container's first continuation. (Inline frames can have
 7680:   // non-fluid bidi continuations...)
 7680:   return aContainingBlockIn->GetFirstContinuation();
    1: }
    1: 
    1: void
    1: nsFrameConstructorState::PushAbsoluteContainingBlock(nsIFrame* aNewAbsoluteContainingBlock,
    1:                                                      nsFrameConstructorSaveState& aSaveState)
    1: {
    1:   aSaveState.mItems = &mAbsoluteItems;
    1:   aSaveState.mSavedItems = mAbsoluteItems;
    1:   aSaveState.mChildListName = nsGkAtoms::absoluteList;
    1:   aSaveState.mState = this;
19214: 
19214:   /* Store whether we're wiring the abs-pos and fixed-pos lists together. */
19214:   aSaveState.mFixedPosIsAbsPos = &mFixedPosIsAbsPos;
19214:   aSaveState.mSavedFixedPosIsAbsPos = mFixedPosIsAbsPos;
19214: 
    1:   mAbsoluteItems = 
 7680:     nsAbsoluteItems(AdjustAbsoluteContainingBlock(aNewAbsoluteContainingBlock));
19214: 
19214:   /* See if we're wiring the fixed-pos and abs-pos lists together.  This happens iff
19214:    * we're a transformed element.
19214:    */
19214:   mFixedPosIsAbsPos = (aNewAbsoluteContainingBlock &&
19214:                        aNewAbsoluteContainingBlock->GetStyleDisplay()->HasTransform());
    1: }
    1: 
    1: void
    1: nsFrameConstructorState::PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
23352:                                                   nsFrameConstructorSaveState& aSaveState)
23352: {
    1:   NS_PRECONDITION(!aNewFloatContainingBlock ||
23352:                   aNewFloatContainingBlock->IsFloatContainingBlock(),
    1:                   "Please push a real float containing block!");
    1:   aSaveState.mItems = &mFloatedItems;
    1:   aSaveState.mSavedItems = mFloatedItems;
    1:   aSaveState.mChildListName = nsGkAtoms::floatList;
    1:   aSaveState.mState = this;
    1:   mFloatedItems = nsAbsoluteItems(aNewFloatContainingBlock);
    1: }
    1: 
    1: nsIFrame*
    1: nsFrameConstructorState::GetGeometricParent(const nsStyleDisplay* aStyleDisplay,
    1:                                             nsIFrame* aContentParentFrame)
    1: {
    1:   NS_PRECONDITION(aStyleDisplay, "Must have display struct!");
    1: 
    1:   // If there is no container for a fixed, absolute, or floating root
    1:   // frame, we will ignore the positioning.  This hack is originally
    1:   // brought to you by the letter T: tables, since other roots don't
    1:   // even call into this code.  See bug 178855.
    1:   //
    1:   // XXX Disabling positioning in this case is a hack.  If one was so inclined,
    1:   // one could support this either by (1) inserting a dummy block between the
    1:   // table and the canvas or (2) teaching the canvas how to reflow positioned
    1:   // elements. (1) has the usual problems when multiple frames share the same
    1:   // content (notice all the special cases in this file dealing with inner
    1:   // tables and outer tables which share the same content). (2) requires some
    1:   // work and possible factoring.
    1:   //
    1:   // XXXbz couldn't we just force position to "static" on roots and
    1:   // float to "none"?  That's OK per CSS 2.1, as far as I can tell.
    1:   
    1:   if (aStyleDisplay->IsFloating() && mFloatedItems.containingBlock) {
    1:     NS_ASSERTION(!aStyleDisplay->IsAbsolutelyPositioned(),
    1:                  "Absolutely positioned _and_ floating?");
    1:     return mFloatedItems.containingBlock;
    1:   }
    1: 
    1:   if (aStyleDisplay->mPosition == NS_STYLE_POSITION_ABSOLUTE &&
    1:       mAbsoluteItems.containingBlock) {
    1:     return mAbsoluteItems.containingBlock;
    1:   }
    1: 
    1:   if (aStyleDisplay->mPosition == NS_STYLE_POSITION_FIXED &&
19214:       GetFixedItems().containingBlock) {
19214:     return GetFixedItems().containingBlock;
    1:   }
    1: 
    1:   return aContentParentFrame;
    1: }
    1: 
    1: nsresult
    1: nsFrameConstructorState::AddChild(nsIFrame* aNewFrame,
    1:                                   nsFrameItems& aFrameItems,
    1:                                   nsIContent* aContent,
    1:                                   nsStyleContext* aStyleContext,
    1:                                   nsIFrame* aParentFrame,
    1:                                   PRBool aCanBePositioned,
    1:                                   PRBool aCanBeFloated,
    1:                                   PRBool aIsOutOfFlowPopup,
    1:                                   PRBool aInsertAfter,
    1:                                   nsIFrame* aInsertAfterFrame)
    1: {
30785:   NS_PRECONDITION(!aNewFrame->GetNextSibling(), "Shouldn't happen");
30785:   
 8199:   const nsStyleDisplay* disp = aNewFrame->GetStyleDisplay();
 7807:   
    1:   // The comments in GetGeometricParent regarding root table frames
    1:   // all apply here, unfortunately.
    1: 
    1:   PRBool needPlaceholder = PR_FALSE;
34912:   nsFrameState placeholderType;
    1:   nsFrameItems* frameItems = &aFrameItems;
    1: #ifdef MOZ_XUL
    1:   if (NS_UNLIKELY(aIsOutOfFlowPopup)) {
    1:       NS_ASSERTION(aNewFrame->GetParent() == mPopupItems.containingBlock,
    1:                    "Popup whose parent is not the popup containing block?");
    1:       NS_ASSERTION(mPopupItems.containingBlock, "Must have a popup set frame!");
    1:       needPlaceholder = PR_TRUE;
    1:       frameItems = &mPopupItems;
34912:       placeholderType = PLACEHOLDER_FOR_POPUP;
    1:   }
    1:   else
    1: #endif // MOZ_XUL
 8199:   if (aCanBeFloated && disp->IsFloating() &&
    1:       mFloatedItems.containingBlock) {
    1:     NS_ASSERTION(aNewFrame->GetParent() == mFloatedItems.containingBlock,
    1:                  "Float whose parent is not the float containing block?");
    1:     needPlaceholder = PR_TRUE;
    1:     frameItems = &mFloatedItems;
34912:     placeholderType = PLACEHOLDER_FOR_FLOAT;
    1:   }
    1:   else if (aCanBePositioned) {
 8199:     if (disp->mPosition == NS_STYLE_POSITION_ABSOLUTE &&
    1:         mAbsoluteItems.containingBlock) {
    1:       NS_ASSERTION(aNewFrame->GetParent() == mAbsoluteItems.containingBlock,
    1:                    "Abs pos whose parent is not the abs pos containing block?");
    1:       needPlaceholder = PR_TRUE;
    1:       frameItems = &mAbsoluteItems;
34912:       placeholderType = PLACEHOLDER_FOR_ABSPOS;
    1:     }
 8199:     if (disp->mPosition == NS_STYLE_POSITION_FIXED &&
19214:         GetFixedItems().containingBlock) {
19214:       NS_ASSERTION(aNewFrame->GetParent() == GetFixedItems().containingBlock,
    1:                    "Fixed pos whose parent is not the fixed pos containing block?");
    1:       needPlaceholder = PR_TRUE;
19214:       frameItems = &GetFixedItems();
34912:       placeholderType = PLACEHOLDER_FOR_FIXEDPOS;
    1:     }
    1:   }
    1: 
    1:   if (needPlaceholder) {
    1:     NS_ASSERTION(frameItems != &aFrameItems,
    1:                  "Putting frame in-flow _and_ want a placeholder?");
    1:     nsIFrame* placeholderFrame;
    1:     nsresult rv =
    1:       nsCSSFrameConstructor::CreatePlaceholderFrameFor(mPresShell,
    1:                                                        aContent,
    1:                                                        aNewFrame,
    1:                                                        aStyleContext,
    1:                                                        aParentFrame,
 6219:                                                        nsnull,
34912:                                                        placeholderType,
    1:                                                        &placeholderFrame);
    1:     if (NS_FAILED(rv)) {
    1:       // Note that aNewFrame could be the top frame for a scrollframe setup,
    1:       // hence already set as the primary frame.  So we have to clean up here.
    1:       // But it shouldn't have any out-of-flow kids.
    1:       // XXXbz Maybe add a utility function to assert that?
    1:       aNewFrame->Destroy();
    1:       return rv;
    1:     }
    1: 
16976:     placeholderFrame->AddStateBits(mAdditionalStateBits);
    1:     // Add the placeholder frame to the flow
    1:     aFrameItems.AddChild(placeholderFrame);
    1:   }
    1: #ifdef DEBUG
    1:   else {
    1:     NS_ASSERTION(aNewFrame->GetParent() == aParentFrame,
    1:                  "In-flow frame has wrong parent");
    1:   }
    1: #endif
    1: 
    1:   if (aInsertAfter) {
30785:     frameItems->InsertFrame(nsnull, aInsertAfterFrame, aNewFrame);
    1:   } else {
    1:     frameItems->AddChild(aNewFrame);
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameConstructorState::ProcessFrameInsertions(nsAbsoluteItems& aFrameItems,
    1:                                                 nsIAtom* aChildListName)
    1: {
    1: #define NS_NONXUL_LIST_TEST (&aFrameItems == &mFloatedItems &&             \
    1:                              aChildListName == nsGkAtoms::floatList)    || \
    1:                             (&aFrameItems == &mAbsoluteItems &&            \
    1:                              aChildListName == nsGkAtoms::absoluteList) || \
    1:                             (&aFrameItems == &mFixedItems &&               \
    1:                              aChildListName == nsGkAtoms::fixedList)
    1: #ifdef MOZ_XUL
    1:   NS_PRECONDITION(NS_NONXUL_LIST_TEST ||
    1:                   (&aFrameItems == &mPopupItems &&
    1:                    aChildListName == nsGkAtoms::popupList), 
    1:                   "Unexpected aFrameItems/aChildListName combination");
    1: #else
    1:   NS_PRECONDITION(NS_NONXUL_LIST_TEST,
    1:                   "Unexpected aFrameItems/aChildListName combination");
    1: #endif
    1: 
30785:   if (aFrameItems.IsEmpty()) {
    1:     return;
    1:   }
    1:   
    1:   nsIFrame* containingBlock = aFrameItems.containingBlock;
    1: 
    1:   NS_ASSERTION(containingBlock,
    1:                "Child list without containing block?");
    1:   
    1:   // Insert the frames hanging out in aItems.  We can use SetInitialChildList()
30710:   // if the containing block hasn't been reflowed yet (so NS_FRAME_FIRST_REFLOW
    1:   // is set) and doesn't have any frames in the aChildListName child list yet.
30785:   const nsFrameList& childList = containingBlock->GetChildList(aChildListName);
    1:   nsresult rv = NS_OK;
30785:   if (childList.IsEmpty() &&
30785:       (containingBlock->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
30785:     rv = containingBlock->SetInitialChildList(aChildListName, aFrameItems);
    1:   } else {
    1:     // Note that whether the frame construction context is doing an append or
    1:     // not is not helpful here, since it could be appending to some frame in
    1:     // the middle of the document, which means we're not necessarily
    1:     // appending to the children of the containing block.
    1:     //
    1:     // We need to make sure the 'append to the end of document' case is fast.
    1:     // So first test the last child of the containing block
30785:     nsIFrame* lastChild = childList.LastChild();
    1: 
    1:     // CompareTreePosition uses placeholder hierarchy for out of flow frames,
    1:     // so this will make out-of-flows respect the ordering of placeholders,
    1:     // which is great because it takes care of anonymous content.
30785:     nsIFrame* firstNewFrame = aFrameItems.FirstChild();  
    1:     if (!lastChild ||
    1:         nsLayoutUtils::CompareTreePosition(lastChild, firstNewFrame, containingBlock) < 0) {
32843:       // no lastChild, or lastChild comes before the new children, so just append
32843:       rv = containingBlock->AppendFrames(aChildListName, aFrameItems);
    1:     } else {
    1:       // try the other children
32843:       nsIFrame* insertionPoint = nsnull;
30785:       for (nsIFrame* f = childList.FirstChild(); f != lastChild;
30785:            f = f->GetNextSibling()) {
    1:         PRInt32 compare =
    1:           nsLayoutUtils::CompareTreePosition(f, firstNewFrame, containingBlock);
    1:         if (compare > 0) {
    1:           // f comes after the new children, so stop here and insert after
    1:           // the previous frame
    1:           break;
    1:         }
    1:         insertionPoint = f;
    1:       }
    1:       rv = containingBlock->InsertFrames(aChildListName, insertionPoint,
30941:                                          aFrameItems);
30790:     }
32843:   }
30790: 
30790:   NS_POSTCONDITION(aFrameItems.IsEmpty(), "How did that happen?");
30790: 
    1:   // XXXbz And if NS_FAILED(rv), what?  I guess we need to clean up the list
    1:   // and deal with all the placeholders... but what if the placeholders aren't
    1:   // in the document yet?  Could that happen?
    1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Frames getting lost!");
    1: }
    1: 
    1: 
    1: nsFrameConstructorSaveState::nsFrameConstructorSaveState()
    1:   : mItems(nsnull),
19214:     mFixedPosIsAbsPos(nsnull),
    1:     mSavedItems(nsnull),
19214:     mSavedFixedPosIsAbsPos(PR_FALSE),
    1:     mChildListName(nsnull),
    1:     mState(nsnull)
    1: {
    1: }
    1: 
    1: nsFrameConstructorSaveState::~nsFrameConstructorSaveState()
    1: {
    1:   // Restore the state
    1:   if (mItems) {
    1:     NS_ASSERTION(mState, "Can't have mItems set without having a state!");
    1:     mState->ProcessFrameInsertions(*mItems, mChildListName);
    1:     *mItems = mSavedItems;
    1: #ifdef DEBUG
    1:     // We've transferred the child list, so drop the pointer we held to it.
    1:     // Note that this only matters for the assert in ~nsAbsoluteItems.
30785:     mSavedItems.Clear();
    1: #endif
    1:   }
19214:   if (mFixedPosIsAbsPos) {
19214:     *mFixedPosIsAbsPos = mSavedFixedPosIsAbsPos;
19214:   }
    1: }
    1: 
    1: static 
    1: PRBool IsBorderCollapse(nsIFrame* aFrame)
    1: {
    1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent()) {
    1:     if (nsGkAtoms::tableFrame == frame->GetType()) {
    1:       return ((nsTableFrame*)frame)->IsBorderCollapse();
    1:     }
    1:   }
    1:   NS_ASSERTION(PR_FALSE, "program error");
    1:   return PR_FALSE;
    1: }
    1: 
    1: /**
34464:  * Moves aFrameList from aOldParent to aNewParent.  This updates the parent
51752:  * pointer of the frames in the list, and reparents their views as needed.
51752:  * nsFrame::SetParent sets the NS_FRAME_HAS_VIEW bit on aNewParent and its
51752:  * ancestors as needed. Then it sets the list as the initial child list
51752:  * on aNewParent, unless aNewParent either already has kids or has been
51752:  * reflowed; in that case it appends the new frames.  Note that this
51752:  * method differs from ReparentFrames in that it doesn't change the kids'
51752:  * style contexts.
    1:  */
34464: // XXXbz Since this is only used for {ib} splits, could we just copy the view
34464: // bits from aOldParent to aNewParent and then use the
34464: // nsFrameList::ApplySetParent?  That would still leave us doing two passes
34464: // over the list, of course; if we really wanted to we could factor out the
34464: // relevant part of ReparentFrameViewList, I suppose...  Or just get rid of
34464: // views, which would make most of this function go away.
    1: static void
34464: MoveChildrenTo(nsPresContext* aPresContext,
34464:                nsIFrame* aOldParent,
    1:                nsIFrame* aNewParent,
34464:                nsFrameList& aFrameList)
34464: {
36624:   PRBool sameGrandParent = aOldParent->GetParent() == aNewParent->GetParent();
36624: 
36624:   if (aNewParent->HasView() || aOldParent->HasView() || !sameGrandParent) {
34464:     // Move the frames into the new view
34464:     nsHTMLContainerFrame::ReparentFrameViewList(aPresContext, aFrameList,
34464:                                                 aOldParent, aNewParent);
34464:   }
34464: 
34464:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
34464:     e.get()->SetParent(aNewParent);
    1:   }
    1: 
35611:   if (aNewParent->GetChildList(nsnull).IsEmpty() &&
35611:       (aNewParent->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
34464:     aNewParent->SetInitialChildList(nsnull, aFrameList);
35611:   } else {
35611:     aNewParent->AppendFrames(nsnull, aFrameList);
35611:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsCSSFrameConstructor::nsCSSFrameConstructor(nsIDocument *aDocument,
    1:                                              nsIPresShell *aPresShell)
    1:   : mDocument(aDocument)
    1:   , mPresShell(aPresShell)
24659:   , mRootElementFrame(nsnull)
16509:   , mRootElementStyleFrame(nsnull)
    1:   , mFixedContainingBlock(nsnull)
    1:   , mDocElementContainingBlock(nsnull)
    1:   , mGfxScrollFrame(nsnull)
    1:   , mPageSequenceFrame(nsnull)
    1:   , mUpdateCount(0)
    1:   , mQuotesDirty(PR_FALSE)
    1:   , mCountersDirty(PR_FALSE)
    1:   , mIsDestroyingFrameTree(PR_FALSE)
10073:   , mRebuildAllStyleData(PR_FALSE)
18953:   , mHasRootAbsPosContainingBlock(PR_FALSE)
36797:   , mObservingRefreshDriver(PR_FALSE)
36797:   , mInStyleRefresh(PR_FALSE)
22471:   , mHoverGeneration(0)
22339:   , mRebuildAllExtraHint(nsChangeHint(0))
43788:   , mPendingRestyles(ELEMENT_HAS_PENDING_RESTYLE |
43788:                      ELEMENT_IS_POTENTIAL_RESTYLE_ROOT, this)
43788:   , mPendingAnimationRestyles(ELEMENT_HAS_PENDING_ANIMATION_RESTYLE |
43788:                               ELEMENT_IS_POTENTIAL_ANIMATION_RESTYLE_ROOT, this)
    1: {
    1:   // XXXbz this should be in Init() or something!
32401:   if (!mPendingRestyles.Init() || !mPendingAnimationRestyles.Init()) {
    1:     // now what?
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   static PRBool gFirstTime = PR_TRUE;
    1:   if (gFirstTime) {
    1:     gFirstTime = PR_FALSE;
    1:     char* flags = PR_GetEnv("GECKO_FRAMECTOR_DEBUG_FLAGS");
    1:     if (flags) {
    1:       PRBool error = PR_FALSE;
    1:       for (;;) {
    1:         char* comma = PL_strchr(flags, ',');
    1:         if (comma)
    1:           *comma = '\0';
    1: 
    1:         PRBool found = PR_FALSE;
    1:         FrameCtorDebugFlags* flag = gFlags;
    1:         FrameCtorDebugFlags* limit = gFlags + NUM_DEBUG_FLAGS;
    1:         while (flag < limit) {
    1:           if (PL_strcasecmp(flag->name, flags) == 0) {
    1:             *(flag->on) = PR_TRUE;
    1:             printf("nsCSSFrameConstructor: setting %s debug flag on\n", flag->name);
    1:             found = PR_TRUE;
    1:             break;
    1:           }
    1:           ++flag;
    1:         }
    1: 
    1:         if (! found)
    1:           error = PR_TRUE;
    1: 
    1:         if (! comma)
    1:           break;
    1: 
    1:         *comma = ',';
    1:         flags = comma + 1;
    1:       }
    1: 
    1:       if (error) {
    1:         printf("Here are the available GECKO_FRAMECTOR_DEBUG_FLAGS:\n");
    1:         FrameCtorDebugFlags* flag = gFlags;
    1:         FrameCtorDebugFlags* limit = gFlags + NUM_DEBUG_FLAGS;
    1:         while (flag < limit) {
    1:           printf("  %s\n", flag->name);
    1:           ++flag;
    1:         }
    1:         printf("Note: GECKO_FRAMECTOR_DEBUG_FLAGS is a comma separated list of flag\n");
    1:         printf("names (no whitespace)\n");
    1:       }
    1:     }
    1:   }
    1: #endif
    1: }
    1: 
    1: nsIXBLService * nsCSSFrameConstructor::GetXBLService()
    1: {
    1:   if (!gXBLService) {
    1:     nsresult rv = CallGetService("@mozilla.org/xbl;1", &gXBLService);
    1:     if (NS_FAILED(rv))
    1:       gXBLService = nsnull;
    1:   }
    1:   
    1:   return gXBLService;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::NotifyDestroyingFrame(nsIFrame* aFrame)
    1: {
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while destroying frames");
 6518: 
16477:   if (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) {
16477:     if (mQuoteList.DestroyNodesFor(aFrame))
    1:       QuotesDirty();
    1:   }
16477: 
16477:   if (mCounterManager.DestroyNodesFor(aFrame)) {
    1:     // Technically we don't need to update anything if we destroyed only
    1:     // USE nodes.  However, this is unlikely to happen in the real world
    1:     // since USE nodes generally go along with INCREMENT nodes.
    1:     CountersDirty();
    1:   }
    1: }
16477: 
16976: struct nsGenConInitializer {
16976:   nsAutoPtr<nsGenConNode> mNode;
16976:   nsGenConList*           mList;
16976:   void (nsCSSFrameConstructor::*mDirtyAll)();
16976:   
16976:   nsGenConInitializer(nsGenConNode* aNode, nsGenConList* aList,
16976:                       void (nsCSSFrameConstructor::*aDirtyAll)())
16976:     : mNode(aNode), mList(aList), mDirtyAll(aDirtyAll) {}
16976: };
16976: 
16976: static void
16976: DestroyGenConInitializer(void*    aFrame,
16976:                          nsIAtom* aPropertyName,
16976:                          void*    aPropertyValue,
16976:                          void*    aDtorData)
16976: {
16976:   delete static_cast<nsGenConInitializer*>(aPropertyValue);
16976: }
16976: 
16976: already_AddRefed<nsIContent>
31438: nsCSSFrameConstructor::CreateGenConTextNode(nsFrameConstructorState& aState,
31438:                                             const nsString& aString,
16976:                                             nsCOMPtr<nsIDOMCharacterData>* aText,
16976:                                             nsGenConInitializer* aInitializer)
16976: {
16976:   nsCOMPtr<nsIContent> content;
16976:   NS_NewTextNode(getter_AddRefs(content), mDocument->NodeInfoManager());
16976:   if (!content) {
16976:     // XXX The quotes/counters code doesn't like the text pointer
16976:     // being null in case of dynamic changes!
16976:     NS_ASSERTION(!aText, "this OOM case isn't handled very well");
16976:     return nsnull;
16976:   }
16976:   content->SetText(aString, PR_FALSE);
16976:   if (aText) {
16976:     *aText = do_QueryInterface(content);
16976:   }
16976:   if (aInitializer) {
16976:     content->SetProperty(nsGkAtoms::genConInitializerProperty, aInitializer,
16976:                          DestroyGenConInitializer);
31438:     aState.mGeneratedTextNodesWithInitializer.AppendObject(content);
16976:   }
16976:   return content.forget();
16976: }
16976: 
16976: already_AddRefed<nsIContent>
31438: nsCSSFrameConstructor::CreateGeneratedContent(nsFrameConstructorState& aState,
31438:                                               nsIContent*     aParentContent,
16477:                                               nsStyleContext* aStyleContext,
16976:                                               PRUint32        aContentIndex)
16976: {
    1:   // Get the content value
16976:   const nsStyleContentData &data =
16976:     aStyleContext->GetStyleContent()->ContentAt(aContentIndex);
    1:   nsStyleContentType type = data.mType;
    1: 
    1:   if (eStyleContentType_Image == type) {
    1:     if (!data.mContent.mImage) {
    1:       // CSS had something specified that couldn't be converted to an
    1:       // image object
16976:       return nsnull;
    1:     }
    1:     
    1:     // Create an image content object and pass it the image request.
    1:     // XXX Check if it's an image type we can handle...
    1: 
    1:     nsCOMPtr<nsINodeInfo> nodeInfo;
19197:     nodeInfo = mDocument->NodeInfoManager()->GetNodeInfo(nsGkAtoms::mozgeneratedcontentimage, nsnull,
19197:                                                          kNameSpaceID_XHTML);
    1: 
16976:     nsCOMPtr<nsIContent> content;
48124:     NS_NewGenConImageContent(getter_AddRefs(content), nodeInfo.forget(),
    1:                              data.mContent.mImage);
16976:     return content.forget();
16976:   }
    1: 
    1:   switch (type) {
    1:   case eStyleContentType_String:
31438:     return CreateGenConTextNode(aState,
31438:                                 nsDependentString(data.mContent.mString),
31438:                                 nsnull, nsnull);
    1: 
    1:   case eStyleContentType_Attr:
    1:     {
    1:       nsCOMPtr<nsIAtom> attrName;
    1:       PRInt32 attrNameSpace = kNameSpaceID_None;
16976:       nsAutoString contentString(data.mContent.mString);
33262:       
    1:       PRInt32 barIndex = contentString.FindChar('|'); // CSS namespace delimiter
    1:       if (-1 != barIndex) {
    1:         nsAutoString  nameSpaceVal;
    1:         contentString.Left(nameSpaceVal, barIndex);
    1:         PRInt32 error;
    1:         attrNameSpace = nameSpaceVal.ToInteger(&error, 10);
    1:         contentString.Cut(0, barIndex + 1);
    1:         if (contentString.Length()) {
33329:           if (mDocument->IsHTML() && aParentContent->IsHTML()) {
33262:             ToLowerCase(contentString);
33262:           }
    1:           attrName = do_GetAtom(contentString);
    1:         }
    1:       }
    1:       else {
33329:         if (mDocument->IsHTML() && aParentContent->IsHTML()) {
33262:           ToLowerCase(contentString);
33262:         }
    1:         attrName = do_GetAtom(contentString);
    1:       }
    1: 
    1:       if (!attrName) {
16976:         return nsnull;
16976:       }
16976: 
16976:       nsCOMPtr<nsIContent> content;
16976:       NS_NewAttributeContent(mDocument->NodeInfoManager(),
16976:                              attrNameSpace, attrName, getter_AddRefs(content));
16976:       return content.forget();
16976:     }
    1: 
    1:   case eStyleContentType_Counter:
    1:   case eStyleContentType_Counters:
    1:     {
    1:       nsCSSValue::Array* counters = data.mContent.mCounters;
    1:       nsCounterList* counterList = mCounterManager.CounterListFor(
    1:           nsDependentString(counters->Item(0).GetStringBufferValue()));
    1:       if (!counterList)
16976:         return nsnull;
    1: 
    1:       nsCounterUseNode* node =
16976:         new nsCounterUseNode(counters, aContentIndex,
16477:                              type == eStyleContentType_Counters);
    1:       if (!node)
16976:         return nsnull;
16976: 
16976:       nsGenConInitializer* initializer =
16976:         new nsGenConInitializer(node, counterList,
16976:                                 &nsCSSFrameConstructor::CountersDirty);
31438:       return CreateGenConTextNode(aState, EmptyString(), &node->mText,
31438:                                   initializer);
16976:     }
    1: 
    1:   case eStyleContentType_Image:
    1:     NS_NOTREACHED("handled by if above");
16976:     return nsnull;
    1: 
    1:   case eStyleContentType_OpenQuote:
    1:   case eStyleContentType_CloseQuote:
    1:   case eStyleContentType_NoOpenQuote:
    1:   case eStyleContentType_NoCloseQuote:
    1:     {
16976:       nsQuoteNode* node =
16976:         new nsQuoteNode(type, aContentIndex);
    1:       if (!node)
16976:         return nsnull;
16976: 
16976:       nsGenConInitializer* initializer =
16976:         new nsGenConInitializer(node, &mQuoteList,
16976:                                 &nsCSSFrameConstructor::QuotesDirty);
31438:       return CreateGenConTextNode(aState, EmptyString(), &node->mText,
31438:                                   initializer);
16976:     }
    1:   
    1:   case eStyleContentType_AltContent:
    1:     {
    1:       // Use the "alt" attribute; if that fails and the node is an HTML
    1:       // <input>, try the value attribute and then fall back to some default
    1:       // localized text we have.
16976:       // XXX what if the 'alt' attribute is added later, how will we
16976:       // detect that and do the right thing here?
16976:       if (aParentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::alt)) {
16976:         nsCOMPtr<nsIContent> content;
16976:         NS_NewAttributeContent(mDocument->NodeInfoManager(),
16976:                                kNameSpaceID_None, nsGkAtoms::alt, getter_AddRefs(content));
16976:         return content.forget();
16976:       }
16976: 
33329:       if (aParentContent->IsHTML() &&
16976:           aParentContent->NodeInfo()->Equals(nsGkAtoms::input)) {
16976:         if (aParentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
16976:           nsCOMPtr<nsIContent> content;
16976:           NS_NewAttributeContent(mDocument->NodeInfoManager(),
16976:                                  kNameSpaceID_None, nsGkAtoms::value, getter_AddRefs(content));
16976:           return content.forget();
16976:         }
16976: 
    1:         nsXPIDLString temp;
16976:         nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
    1:                                            "Submit", temp);
31438:         return CreateGenConTextNode(aState, temp, nsnull, nsnull);
16976:       }
16976: 
    1:       break;
16976:     }
    1:   } // switch
    1: 
16976:   return nsnull;
16976: }
16976: 
    1: /*
16976:  * aParentFrame - the frame that should be the parent of the generated
    1:  *   content.  This is the frame for the corresponding content node,
    1:  *   which must not be a leaf frame.
16976:  * 
25768:  * Any items created are added to aItems.
16976:  * 
16976:  * We create an XML element (tag _moz_generated_content_before or
16976:  * _moz_generated_content_after) representing the pseudoelement. We
16976:  * create a DOM node for each 'content' item and make those nodes the
16976:  * children of the XML element. Then we create a frame subtree for
16976:  * the XML element as if it were a regular child of
16976:  * aParentFrame/aParentContent, giving the XML element the ::before or
16976:  * ::after style.
    1:  */
16976: void
25768: nsCSSFrameConstructor::CreateGeneratedContentItem(nsFrameConstructorState& aState,
16976:                                                   nsIFrame*        aParentFrame,
16976:                                                   nsIContent*      aParentContent,
    1:                                                   nsStyleContext*  aStyleContext,
35554:                                                   nsCSSPseudoElements::Type aPseudoElement,
25774:                                                   FrameConstructionItemList& aItems)
25768: {
25768:   // XXXbz is this ever true?
41640:   if (!aParentContent->IsElement()) {
41640:     NS_ERROR("Bogus generated content parent");
16976:     return;
41640:   }
    1: 
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1: 
    1:   // Probe for the existence of the pseudo-element
    1:   nsRefPtr<nsStyleContext> pseudoStyleContext;
41640:   pseudoStyleContext =
41640:     styleSet->ProbePseudoElementStyle(aParentContent->AsElement(),
    1:                                       aPseudoElement,
    1:                                       aStyleContext);
16976:   if (!pseudoStyleContext)
16976:     return;
16976:   // |ProbePseudoStyleFor| checked the 'display' property and the
    1:   // |ContentCount()| of the 'content' property for us.
16976:   nsCOMPtr<nsINodeInfo> nodeInfo;
35554:   nsIAtom* elemName = aPseudoElement == nsCSSPseudoElements::ePseudo_before ?
16976:     nsGkAtoms::mozgeneratedcontentbefore : nsGkAtoms::mozgeneratedcontentafter;
19197:   nodeInfo = mDocument->NodeInfoManager()->GetNodeInfo(elemName, nsnull,
19197:                                                        kNameSpaceID_None);
25768:   nsCOMPtr<nsIContent> container;
48124:   nsresult rv = NS_NewXMLElement(getter_AddRefs(container), nodeInfo.forget());
16976:   if (NS_FAILED(rv))
16976:     return;
16976:   container->SetNativeAnonymous();
16976: 
16976:   rv = container->BindToTree(mDocument, aParentContent, aParentContent, PR_TRUE);
16976:   if (NS_FAILED(rv)) {
16976:     container->UnbindFromTree();
16976:     return;
16976:   }
16976: 
16976:   PRUint32 contentCount = pseudoStyleContext->GetStyleContent()->ContentCount();
    1:   for (PRUint32 contentIndex = 0; contentIndex < contentCount; contentIndex++) {
16976:     nsCOMPtr<nsIContent> content =
31438:       CreateGeneratedContent(aState, aParentContent, pseudoStyleContext,
31438:                              contentIndex);
16976:     if (content) {
16976:       container->AppendChildTo(content, PR_FALSE);
16976:     }
16976:   }
16976: 
25771:   AddFrameConstructionItemsInternal(aState, container, aParentFrame, elemName,
47661:                                     kNameSpaceID_None, PR_TRUE,
47661:                                     pseudoStyleContext,
25768:                                     ITEM_IS_GENERATED_CONTENT, aItems);
    1: }
    1:     
    1: /****************************************************
    1:  **  BEGIN TABLE SECTION
    1:  ****************************************************/
    1: 
    1: // The term pseudo frame is being used instead of anonymous frame, since anonymous
    1: // frame has been used elsewhere to refer to frames that have generated content
    1: 
    1: static PRBool
26208: IsTableRelated(nsIAtom* aParentType)
26208: {
26208:   return
30133:     nsGkAtoms::tableOuterFrame    == aParentType ||
26208:     nsGkAtoms::tableFrame         == aParentType ||
26208:     nsGkAtoms::tableRowGroupFrame == aParentType ||
26208:     nsGkAtoms::tableRowFrame      == aParentType ||
26208:     nsGkAtoms::tableCaptionFrame  == aParentType ||
26208:     nsGkAtoms::tableColGroupFrame == aParentType ||
26208:     nsGkAtoms::tableColFrame      == aParentType ||
26208:     IS_TABLE_CELL(aParentType);
26208: }
26208: 
26471: // Return whether the given frame is a table pseudo-frame.  Note that
26471: // cell-content and table-outer frames have pseudo-types, but are always
26471: // created, even for non-anonymous cells and tables respectively.  So for those
26471: // we have to examine the cell or table frame to see whether it's a pseudo
26471: // frame.  In particular, a lone table caption will have an outer table as its
26471: // parent, but will also trigger construction of an empty inner table, which
26471: // will be the one we can examine to see whether the outer was a pseudo-frame.
26471: static PRBool
26471: IsTablePseudo(nsIFrame* aFrame)
26471: {
34387:   nsIAtom* pseudoType = aFrame->GetStyleContext()->GetPseudo();
26471:   return pseudoType &&
26471:     (pseudoType == nsCSSAnonBoxes::table ||
26471:      pseudoType == nsCSSAnonBoxes::inlineTable ||
26471:      pseudoType == nsCSSAnonBoxes::tableColGroup ||
26471:      pseudoType == nsCSSAnonBoxes::tableRowGroup ||
26471:      pseudoType == nsCSSAnonBoxes::tableRow ||
26471:      pseudoType == nsCSSAnonBoxes::tableCell ||
26471:      (pseudoType == nsCSSAnonBoxes::cellContent &&
34387:       aFrame->GetParent()->GetStyleContext()->GetPseudo() ==
26471:         nsCSSAnonBoxes::tableCell) ||
26471:      (pseudoType == nsCSSAnonBoxes::tableOuter &&
34387:       (aFrame->GetFirstChild(nsnull)->GetStyleContext()->GetPseudo() ==
26471:          nsCSSAnonBoxes::table ||
34387:        aFrame->GetFirstChild(nsnull)->GetStyleContext()->GetPseudo() ==
26471:          nsCSSAnonBoxes::inlineTable)));
26471: }
26471: 
26208: /* static */
26208: nsCSSFrameConstructor::ParentType
29580: nsCSSFrameConstructor::GetParentType(nsIAtom* aFrameType)
29580: {
29580:   if (aFrameType == nsGkAtoms::tableFrame) {
26208:     return eTypeTable;
26208:   }
29580:   if (aFrameType == nsGkAtoms::tableRowGroupFrame) {
26208:     return eTypeRowGroup;
26208:   }
29580:   if (aFrameType == nsGkAtoms::tableRowFrame) {
26208:     return eTypeRow;
26208:   }
29580:   if (aFrameType == nsGkAtoms::tableColGroupFrame) {
26208:     return eTypeColGroup;
26208:   }
26208: 
26208:   return eTypeBlock;
    1: }
    1:            
    1: static nsIFrame*
    1: AdjustCaptionParentFrame(nsIFrame* aParentFrame) 
    1: {
    1:   if (nsGkAtoms::tableFrame == aParentFrame->GetType()) {
    1:     return aParentFrame->GetParent();;
    1:   }
    1:   return aParentFrame;
    1: }
    1:  
    1: /**
    1:  * If the parent frame is a |tableFrame| and the child is a
    1:  * |captionFrame|, then we want to insert the frames beneath the
    1:  * |tableFrame|'s parent frame. Returns |PR_TRUE| if the parent frame
    1:  * needed to be fixed up.
    1:  */
    1: static PRBool
    1: GetCaptionAdjustedParent(nsIFrame*        aParentFrame,
    1:                          const nsIFrame*  aChildFrame,
    1:                          nsIFrame**       aAdjParentFrame)
    1: {
    1:   *aAdjParentFrame = aParentFrame;
    1:   PRBool haveCaption = PR_FALSE;
    1: 
    1:   if (nsGkAtoms::tableCaptionFrame == aChildFrame->GetType()) {
    1:     haveCaption = PR_TRUE;
    1:     *aAdjParentFrame = AdjustCaptionParentFrame(aParentFrame);
    1:   }
    1:   return haveCaption;
    1: }
    1: 
26208: void
26208: nsCSSFrameConstructor::AdjustParentFrame(nsIFrame* &                  aParentFrame,
23955:                                          const FrameConstructionData* aFCData,
26208:                                          nsStyleContext*              aStyleContext)
    1: {
25768:   NS_PRECONDITION(aStyleContext, "Must have child's style context");
25131:   NS_PRECONDITION(aFCData, "Must have frame construction data");
    1: 
25131:   PRBool tablePart = ((aFCData->mBits & FCDATA_IS_TABLE_PART) != 0);
25131: 
26208:   if (tablePart && aStyleContext->GetStyleDisplay()->mDisplay ==
26208:       NS_STYLE_DISPLAY_TABLE_CAPTION) {
26207:     aParentFrame = AdjustCaptionParentFrame(aParentFrame);
26208:   }
    1: }
    1: 
 4368: // Pull all the captions present in aItems out  into aCaptions
 4368: static void
 4368: PullOutCaptionFrames(nsFrameItems& aItems, nsFrameItems& aCaptions)
 4368: {
30785:   nsIFrame *child = aItems.FirstChild();
 4368:   while (child) {
 4368:     nsIFrame *nextSibling = child->GetNextSibling();
 4368:     if (nsGkAtoms::tableCaptionFrame == child->GetType()) {
33388:       aItems.RemoveFrame(child);
 4368:       aCaptions.AddChild(child);
 4368:     }
 4368:     child = nextSibling;
 4368:   }
 4368: }
 4368: 
 4368: 
    1: // Construct the outer, inner table frames and the children frames for the table. 
    1: // XXX Page break frames for pseudo table frames are not constructed to avoid the risk
    1: // associated with revising the pseudo frame mechanism. The long term solution
    1: // of having frames handle page-break-before/after will solve the problem. 
    1: nsresult
26208: nsCSSFrameConstructor::ConstructTable(nsFrameConstructorState& aState,
26208:                                       FrameConstructionItem&   aItem,
26208:                                       nsIFrame*                aParentFrame,
26208:                                       const nsStyleDisplay*    aDisplay,
26208:                                       nsFrameItems&            aFrameItems,
26208:                                       nsIFrame**               aNewFrame)
26208: {
26208:   NS_PRECONDITION(aDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE ||
26208:                   aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_TABLE,
26208:                   "Unexpected call");
26208: 
26208:   nsIContent* const content = aItem.mContent;
26208:   nsStyleContext* const styleContext = aItem.mStyleContext;
26208:   const PRUint32 nameSpaceID = aItem.mNameSpaceID;
26208:   
    1:   nsresult rv = NS_OK;
    1: 
    1:   // create the pseudo SC for the outer table as a child of the inner SC
    1:   nsRefPtr<nsStyleContext> outerStyleContext;
    1:   outerStyleContext = mPresShell->StyleSet()->
35554:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::tableOuter, styleContext);
    1: 
    1:   // Create the outer table frame which holds the caption and inner table frame
26208:   nsIFrame* newFrame;
    1: #ifdef MOZ_MATHML
26208:   if (kNameSpaceID_MathML == nameSpaceID)
26208:     newFrame = NS_NewMathMLmtableOuterFrame(mPresShell, outerStyleContext);
    1:   else
    1: #endif
26208:     newFrame = NS_NewTableOuterFrame(mPresShell, outerStyleContext);
26208: 
26208:   nsIFrame* geometricParent =
26208:     aState.GetGeometricParent(outerStyleContext->GetStyleDisplay(),
26208:                               aParentFrame);
    1: 
    1:   // Init the table outer frame and see if we need to create a view, e.g.
    1:   // the frame is absolutely positioned  
26208:   InitAndRestoreFrame(aState, content, geometricParent, nsnull, newFrame);  
26208:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:   // Create the inner table frame
26208:   nsIFrame* innerFrame;
    1: #ifdef MOZ_MATHML
26208:   if (kNameSpaceID_MathML == nameSpaceID)
26208:     innerFrame = NS_NewMathMLmtableFrame(mPresShell, styleContext);
    1:   else
    1: #endif
26208:     innerFrame = NS_NewTableFrame(mPresShell, styleContext);
26208:  
26208:   InitAndRestoreFrame(aState, content, newFrame, nsnull, innerFrame);
26208: 
    1:   // Put the newly created frames into the right child list
30790:   SetInitialSingleChild(newFrame, innerFrame);
26208: 
26208:   rv = aState.AddChild(newFrame, aFrameItems, content, styleContext,
26208:                        aParentFrame);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
24659:   if (!mRootElementFrame) {
24659:     // The frame we're constructing will be the root element frame.
24659:     // Set mRootElementFrame before processing children.
26208:     mRootElementFrame = newFrame;
20147:   }
20147: 
    1:   nsFrameItems childItems;
26208:   if (aItem.mFCData->mBits & FCDATA_USE_CHILD_ITEMS) {
26208:     rv = ConstructFramesFromItemList(aState, aItem.mChildItems,
26208:                                      innerFrame, childItems);
26208:   } else {
26208:     rv = ProcessChildren(aState, content, styleContext, innerFrame,
34614:                          PR_TRUE, childItems, PR_FALSE, aItem.mPendingBinding);
26208:   }
    1:   // XXXbz what about cleaning up?
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   nsFrameItems captionItems;
 4368:   PullOutCaptionFrames(childItems, captionItems);
 4368: 
    1:   // Set the inner table frame's initial primary list 
30785:   innerFrame->SetInitialChildList(nsnull, childItems);
    1: 
    1:   // Set the outer table frame's secondary childlist lists
30785:   if (captionItems.NotEmpty()) {
30785:     newFrame->SetInitialChildList(nsGkAtoms::captionList, captionItems);
    1:   }
26208: 
26208:   *aNewFrame = newFrame;
    1:   return rv;
    1: }
    1: 
    1: nsresult
26208: nsCSSFrameConstructor::ConstructTableRow(nsFrameConstructorState& aState,
26208:                                          FrameConstructionItem&   aItem,
26208:                                          nsIFrame*                aParentFrame,
26208:                                          const nsStyleDisplay*    aDisplay,
26208:                                          nsFrameItems&            aFrameItems,
26208:                                          nsIFrame**               aNewFrame)
26208: {
26208:   NS_PRECONDITION(aDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_ROW,
26208:                   "Unexpected call");
26208:   nsIContent* const content = aItem.mContent;
26208:   nsStyleContext* const styleContext = aItem.mStyleContext;
26208:   const PRUint32 nameSpaceID = aItem.mNameSpaceID;
26208: 
26208:   nsIFrame* newFrame;
    1: #ifdef MOZ_MATHML
26208:   if (kNameSpaceID_MathML == nameSpaceID)
26208:     newFrame = NS_NewMathMLmtrFrame(mPresShell, styleContext);
    1:   else
    1: #endif
26208:     newFrame = NS_NewTableRowFrame(mPresShell, styleContext);
26208: 
26208:   if (NS_UNLIKELY(!newFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
26208:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, newFrame);
26208:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
26208: 
    1:   nsFrameItems childItems;
26208:   nsresult rv;
26208:   if (aItem.mFCData->mBits & FCDATA_USE_CHILD_ITEMS) {
26208:     rv = ConstructFramesFromItemList(aState, aItem.mChildItems, newFrame,
26208:                                      childItems);
26208:   } else {
26208:     rv = ProcessChildren(aState, content, styleContext, newFrame,
34614:                          PR_TRUE, childItems, PR_FALSE, aItem.mPendingBinding);
26208:   }
    1:   if (NS_FAILED(rv)) return rv;
    1: 
30785:   newFrame->SetInitialChildList(nsnull, childItems);
26208:   aFrameItems.AddChild(newFrame);
26208:   *aNewFrame = newFrame;
    1: 
25130:   return NS_OK;
    1: }
    1: 
    1: nsresult
26207: nsCSSFrameConstructor::ConstructTableCol(nsFrameConstructorState& aState,
26207:                                          FrameConstructionItem&   aItem,
26207:                                          nsIFrame*                aParentFrame,
26207:                                          const nsStyleDisplay*    aStyleDisplay,
26207:                                          nsFrameItems&            aFrameItems,
26207:                                          nsIFrame**               aNewFrame)
26207: {
26207:   nsIContent* const content = aItem.mContent;
26207:   nsStyleContext* const styleContext = aItem.mStyleContext;
26207: 
26207:   nsTableColFrame* colFrame = NS_NewTableColFrame(mPresShell, styleContext);
32841:   if (NS_UNLIKELY(!colFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
26207:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, colFrame);
26207: 
26207:   NS_ASSERTION(colFrame->GetStyleContext() == styleContext,
26207:                "Unexpected style context");
    1: 
32841:   aFrameItems.AddChild(colFrame);
32841:   *aNewFrame = colFrame;
32841: 
    1:   // construct additional col frames if the col frame has a span > 1
 8151:   PRInt32 span = colFrame->GetSpan();
    1:   for (PRInt32 spanX = 1; spanX < span; spanX++) {
 8151:     nsTableColFrame* newCol = NS_NewTableColFrame(mPresShell, styleContext);
    1:     if (NS_UNLIKELY(!newCol)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
26207:     InitAndRestoreFrame(aState, content, aParentFrame, nsnull, newCol,
26207:                         PR_FALSE);
32841:     aFrameItems.LastChild()->SetNextContinuation(newCol);
32841:     newCol->SetPrevContinuation(aFrameItems.LastChild());
32841:     aFrameItems.AddChild(newCol);
 8151:     newCol->SetColType(eColAnonymousCol);
32841:   }
    1: 
25130:   return NS_OK;
    1: }
    1: 
    1: nsresult
26208: nsCSSFrameConstructor::ConstructTableCell(nsFrameConstructorState& aState,
26208:                                           FrameConstructionItem&   aItem,
26208:                                           nsIFrame*                aParentFrame,
26208:                                           const nsStyleDisplay*    aDisplay,
26208:                                           nsFrameItems&            aFrameItems,
26208:                                           nsIFrame**               aNewFrame)
26208: {
26208:   NS_PRECONDITION(aDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_CELL,
26208:                   "Unexpected call");
26208: 
26208:   nsIContent* const content = aItem.mContent;
26208:   nsStyleContext* const styleContext = aItem.mStyleContext;
26208:   const PRUint32 nameSpaceID = aItem.mNameSpaceID;
26208: 
26208:   PRBool borderCollapse = IsBorderCollapse(aParentFrame);
26208:   nsIFrame* newFrame;
    1: #ifdef MOZ_MATHML
    1:   // <mtable> is border separate in mathml.css and the MathML code doesn't implement
    1:   // border collapse. For those users who style <mtable> with border collapse,
26208:   // give them the default non-MathML table frames that understand border collapse.
    1:   // This won't break us because MathML table frames are all subclasses of the default
    1:   // table code, and so we can freely mix <mtable> with <mtr> or <tr>, <mtd> or <td>.
    1:   // What will happen is just that non-MathML frames won't understand MathML attributes
    1:   // and will therefore miss the special handling that the MathML code does.
26208:   if (kNameSpaceID_MathML == nameSpaceID && !borderCollapse)
26208:     newFrame = NS_NewMathMLmtdFrame(mPresShell, styleContext);
    1:   else
    1: #endif
 8578:     // Warning: If you change this and add a wrapper frame around table cell
 8578:     // frames, make sure Bug 368554 doesn't regress!
 8578:     // See IsInAutoWidthTableCellForQuirk() in nsImageFrame.cpp.    
26208:     newFrame = NS_NewTableCellFrame(mPresShell, styleContext, borderCollapse);
26208: 
26208:   if (NS_UNLIKELY(!newFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // Initialize the table cell frame
26208:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, newFrame);
26208:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:   
    1:   // Resolve pseudo style and initialize the body cell frame
    1:   nsRefPtr<nsStyleContext> innerPseudoStyle;
    1:   innerPseudoStyle = mPresShell->StyleSet()->
35554:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::cellContent, styleContext);
    1: 
    1:   // Create a block frame that will format the cell's content
 6818:   PRBool isBlock;
26208:   nsIFrame* cellInnerFrame;
    1: #ifdef MOZ_MATHML
26208:   if (kNameSpaceID_MathML == nameSpaceID) {
26208:     cellInnerFrame = NS_NewMathMLmtdInnerFrame(mPresShell, innerPseudoStyle);
 6818:     isBlock = PR_FALSE;
 6818:   }
    1:   else
    1: #endif
 6818:   {
26208:     cellInnerFrame = NS_NewBlockFormattingContext(mPresShell, innerPseudoStyle);
 6818:     isBlock = PR_TRUE;
 6818:   }
    1: 
26208:   if (NS_UNLIKELY(!cellInnerFrame)) {
26208:     newFrame->Destroy();
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
26208:   InitAndRestoreFrame(aState, content, newFrame, nsnull, cellInnerFrame);
26208: 
26208:   nsFrameItems childItems;
26208:   nsresult rv;
26208:   if (aItem.mFCData->mBits & FCDATA_USE_CHILD_ITEMS) {
26208:     // Need to push ourselves as a float containing block.
26208:     // XXXbz it might be nice to work on getting the parent
26208:     // FrameConstructionItem down into ProcessChildren and just making use of
26208:     // the push there, but that's a bit of work.
26208:     nsFrameConstructorSaveState floatSaveState;
26208:     if (!isBlock) { /* MathML case */
26208:       aState.PushFloatContainingBlock(nsnull, floatSaveState);
26208:     } else {
26208:       aState.PushFloatContainingBlock(cellInnerFrame, floatSaveState);
26208:     }
26208: 
26208:     rv = ConstructFramesFromItemList(aState, aItem.mChildItems, cellInnerFrame,
26208:                                      childItems);
26208:   } else {
    1:     // Process the child content
26208:     rv = ProcessChildren(aState, content, styleContext, cellInnerFrame,
34614:                          PR_TRUE, childItems, isBlock, aItem.mPendingBinding);
26208:   }
    1:   
    1:   if (NS_FAILED(rv)) {
    1:     // Clean up
    1:     // XXXbz kids of this stuff need to be cleaned up too!
26208:     cellInnerFrame->Destroy();
26208:     newFrame->Destroy();
    1:     return rv;
    1:   }
    1: 
30785:   cellInnerFrame->SetInitialChildList(nsnull, childItems);
30790:   SetInitialSingleChild(newFrame, cellInnerFrame);
26208:   aFrameItems.AddChild(newFrame);
26208:   *aNewFrame = newFrame;
    1: 
25130:   return NS_OK;
    1: }
    1: 
41931: static inline PRBool 
41931: NeedFrameFor(const nsFrameConstructorState& aState,
41931:              nsIFrame*   aParentFrame,
    1:              nsIContent* aChildContent) 
    1: {
37483:   // XXX the GetContent() != aChildContent check is needed due to bug 135040.
37483:   // Remove it once that's fixed.
37483:   NS_PRECONDITION(!aChildContent->GetPrimaryFrame() ||
41931:                   !aState.mSetPrimaryFrames ||
37483:                   aChildContent->GetPrimaryFrame()->GetContent() != aChildContent,
37483:                   "Why did we get called?");
36794: 
16976:   // don't create a whitespace frame if aParentFrame doesn't want it.
16976:   // always create frames for children in generated content. counter(),
16976:   // quotes, and attr() content can easily change dynamically and we don't
16976:   // want to be reconstructing frames. It's not even clear that these
16976:   // should be considered ignorable just because they evaluate to
16976:   // whitespace.
27311: 
27311:   // We could handle all this in CreateNeededTablePseudos or some other place
27311:   // after we build our frame construction items, but that would involve
27311:   // creating frame construction items for whitespace kids of
27311:   // eExcludesIgnorableWhitespace frames, where we know we'll be dropping them
27311:   // all anyway, and involve an extra walk down the frame construction item
27311:   // list.
27311:   if (!aParentFrame->IsFrameOfType(nsIFrame::eExcludesIgnorableWhitespace) ||
27311:       aParentFrame->IsGeneratedContentFrame() ||
27311:       !aChildContent->IsNodeOfType(nsINode::eTEXT)) {
27311:     return PR_TRUE;
27311:   }
27311: 
29809:   aChildContent->SetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE |
29809:                           NS_REFRAME_IF_WHITESPACE);
27311:   return !aChildContent->TextIsOnlyWhitespace();
    1: }
    1: 
    1: /***********************************************
    1:  * END TABLE SECTION
    1:  ***********************************************/
    1: 
    1: static PRBool CheckOverflow(nsPresContext* aPresContext,
    1:                             const nsStyleDisplay* aDisplay)
    1: {
    1:   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
    1:     return PR_FALSE;
    1: 
    1:   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_CLIP)
    1:     aPresContext->SetViewportOverflowOverride(NS_STYLE_OVERFLOW_HIDDEN,
    1:                                               NS_STYLE_OVERFLOW_HIDDEN);
    1:   else
    1:     aPresContext->SetViewportOverflowOverride(aDisplay->mOverflowX,
    1:                                               aDisplay->mOverflowY);
    1:   return PR_TRUE;
    1: }
    1: 
    1: /**
    1:  * This checks the root element and the HTML BODY, if any, for an "overflow" property
    1:  * that should be applied to the viewport. If one is found then we return the
    1:  * element that we took the overflow from (which should then be treated as
    1:  * "overflow:visible"), and we store the overflow style in the prescontext.
    1:  * @return if scroll was propagated from some content node, the content node it
    1:  *         was propagated from.
    1:  */
    1: nsIContent*
    1: nsCSSFrameConstructor::PropagateScrollToViewport()
    1: {
    1:   // Set default
    1:   nsPresContext* presContext = mPresShell->GetPresContext();
    1:   presContext->SetViewportOverflowOverride(NS_STYLE_OVERFLOW_AUTO,
    1:                                            NS_STYLE_OVERFLOW_AUTO);
    1: 
    1:   // We never mess with the viewport scroll state
    1:   // when printing or in print preview
    1:   if (presContext->IsPaginated()) {
    1:     return nsnull;
    1:   }
    1: 
41634:   Element* docElement = mDocument->GetRootElement();
    1: 
    1:   // Check the style on the document root element
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1:   nsRefPtr<nsStyleContext> rootStyle;
    1:   rootStyle = styleSet->ResolveStyleFor(docElement, nsnull);
    1:   if (!rootStyle) {
    1:     return nsnull;
    1:   }
    1:   if (CheckOverflow(presContext, rootStyle->GetStyleDisplay())) {
    1:     // tell caller we stole the overflow style from the root element
    1:     return docElement;
    1:   }
    1:   
    1:   // Don't look in the BODY for non-HTML documents or HTML documents
    1:   // with non-HTML roots
    1:   // XXX this should be earlier; we shouldn't even look at the document root
    1:   // for non-HTML documents. Fix this once we support explicit CSS styling
    1:   // of the viewport
    1:   // XXX what about XHTML?
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(mDocument));
33329:   if (!htmlDoc || !docElement->IsHTML()) {
    1:     return nsnull;
    1:   }
    1:   
    1:   nsCOMPtr<nsIDOMHTMLElement> body;
    1:   htmlDoc->GetBody(getter_AddRefs(body));
    1:   nsCOMPtr<nsIContent> bodyElement = do_QueryInterface(body);
    1:   
    1:   if (!bodyElement ||
    1:       !bodyElement->NodeInfo()->Equals(nsGkAtoms::body)) {
    1:     // The body is not a <body> tag, it's a <frameset>.
    1:     return nsnull;
    1:   }
    1: 
    1:   nsRefPtr<nsStyleContext> bodyStyle;
41640:   bodyStyle = styleSet->ResolveStyleFor(bodyElement->AsElement(), rootStyle);
    1:   if (!bodyStyle) {
    1:     return nsnull;
    1:   }
    1: 
    1:   if (CheckOverflow(presContext, bodyStyle->GetStyleDisplay())) {
    1:     // tell caller we stole the overflow style from the body element
    1:     return bodyElement;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
41640: nsCSSFrameConstructor::ConstructDocElementFrame(Element*                 aDocElement,
28215:                                                 nsILayoutHistoryState*   aFrameState,
    1:                                                 nsIFrame**               aNewFrame)
    1: {
28215:   NS_PRECONDITION(mFixedContainingBlock,
28215:                   "No viewport?  Someone forgot to call ConstructRootFrame!");
28215:   NS_PRECONDITION(mFixedContainingBlock == mPresShell->FrameManager()->GetRootFrame(),
28215:                   "Unexpected mFixedContainingBlock");
30941:   NS_PRECONDITION(!mDocElementContainingBlock,
30941:                   "Shouldn't have a doc element containing block here");
28215: 
    1:   *aNewFrame = nsnull;
    1: 
30585:   // Make sure to call PropagateScrollToViewport before
30585:   // SetUpDocElementContainingBlock, since it sets up our scrollbar state
30585:   // properly.
30585:   nsIContent* propagatedScrollFrom = PropagateScrollToViewport();
30585: 
28215:   SetUpDocElementContainingBlock(aDocElement);
28215: 
28215:   NS_ASSERTION(mDocElementContainingBlock, "Should have parent by now");
28215: 
28215:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock, nsnull,
28215:                                 nsnull, aFrameState);
28215: 
28215:   // XXXbz why, exactly?
    1:   if (!mTempFrameTreeState)
28215:     state.mPresShell->CaptureHistoryState(getter_AddRefs(mTempFrameTreeState));
    1: 
43792:   // Make sure that we'll handle restyles for this document element in
43792:   // the future.  We need this, because the document element might
43792:   // have stale restyle bits from a previous frame constructor for
43792:   // this document.  Unlike in AddFrameConstructionItems, it's safe to
43792:   // unset all element restyle flags, since we don't have any
43792:   // siblings.
43792:   aDocElement->UnsetFlags(ELEMENT_ALL_RESTYLE_FLAGS);
43792: 
    1:   // --------- CREATE AREA OR BOX FRAME -------
    1:   nsRefPtr<nsStyleContext> styleContext;
    1:   styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
    1:                                                          nsnull);
    1: 
    1:   const nsStyleDisplay* display = styleContext->GetStyleDisplay();
    1: 
    1:   // Ensure that our XBL bindings are installed.
    1:   if (display->mBinding) {
    1:     // Get the XBL loader.
    1:     nsresult rv;
    1:     PRBool resolveStyle;
    1:     
    1:     nsIXBLService * xblService = GetXBLService();
    1:     if (!xblService)
    1:       return NS_ERROR_FAILURE;
    1: 
34550:     nsRefPtr<nsXBLBinding> binding;
 3645:     rv = xblService->LoadBindings(aDocElement, display->mBinding->mURI,
 3645:                                   display->mBinding->mOriginPrincipal,
34550:                                   PR_FALSE, getter_AddRefs(binding),
 3645:                                   &resolveStyle);
53759:     if (NS_FAILED(rv))
    1:       return NS_OK; // Binding will load asynchronously.
    1: 
34550:     if (binding) {
34614:       // For backwards compat, keep firing the root's constructor
34614:       // after all of its kids' constructors.  So tell the binding
34614:       // manager about it right now.
34550:       mDocument->BindingManager()->AddToAttachedQueue(binding);
53759:     }
    1: 
    1:     if (resolveStyle) {
    1:       styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
    1:                                                              nsnull);
    1:       display = styleContext->GetStyleDisplay();
    1:     }
    1:   }
    1: 
    1:   // --------- IF SCROLLABLE WRAP IN SCROLLFRAME --------
    1: 
    1: #ifdef DEBUG
    1:   NS_ASSERTION(!display->IsScrollableOverflow() || 
28215:                state.mPresContext->IsPaginated() ||
30585:                propagatedScrollFrom == aDocElement,
    1:                "Scrollbars should have been propagated to the viewport");
    1: #endif
    1: 
19172:   if (NS_UNLIKELY(display->mDisplay == NS_STYLE_DISPLAY_NONE)) {
28215:     state.mFrameManager->SetUndisplayedContent(aDocElement, styleContext);
19172:     return NS_OK;
19172:   }
19172: 
18953:   nsFrameConstructorSaveState absoluteSaveState;
18953:   if (mHasRootAbsPosContainingBlock) {
18953:     // Push the absolute containing block now so we can absolutely position
18953:     // the root element
28215:     state.PushAbsoluteContainingBlock(mDocElementContainingBlock,
28215:                                       absoluteSaveState);
18953:   }
18953: 
    1:   nsresult rv;
    1: 
    1:   // The rules from CSS 2.1, section 9.2.4, have already been applied
    1:   // by the style system, so we can assume that display->mDisplay is
    1:   // either NONE, BLOCK, or TABLE.
    1: 
18953:   // contentFrame is the primary frame for the root element. *aNewFrame
18953:   // is the frame that will be the child of the initial containing block.
18953:   // These are usually the same frame but they can be different, in
18953:   // particular if the root frame is positioned, in which case
18953:   // contentFrame is the out-of-flow frame and *aNewFrame is the
18953:   // placeholder.
18953:   nsIFrame* contentFrame;
18953:   PRBool processChildren = PR_FALSE;
23938: 
23938:   // Check whether we need to build a XUL box or SVG root frame
23938: #ifdef MOZ_XUL
33329:   if (aDocElement->IsXUL()) {
23938:     contentFrame = NS_NewDocElementBoxFrame(mPresShell, styleContext);
23938:     if (NS_UNLIKELY(!contentFrame)) {
23938:       return NS_ERROR_OUT_OF_MEMORY;
23938:     }
28215:     InitAndRestoreFrame(state, aDocElement, mDocElementContainingBlock, nsnull,
28215:                         contentFrame);
23938:     *aNewFrame = contentFrame;
23938:     processChildren = PR_TRUE;
23938:   }
23938:   else
23938: #endif
23938: #ifdef MOZ_SVG
23938:   if (aDocElement->GetNameSpaceID() == kNameSpaceID_SVG) {
23938:     if (aDocElement->Tag() == nsGkAtoms::svg && NS_SVGEnabled()) {
23953:       contentFrame = NS_NewSVGOuterSVGFrame(mPresShell, styleContext);
23938:       if (NS_UNLIKELY(!contentFrame)) {
23938:         return NS_ERROR_OUT_OF_MEMORY;
23938:       }
28215:       InitAndRestoreFrame(state, aDocElement,
28215:                           state.GetGeometricParent(display,
28215:                                                    mDocElementContainingBlock),
23938:                           nsnull, contentFrame);
23938: 
23938:       // AddChild takes care of transforming the frame tree for fixed-pos
23938:       // or abs-pos situations
23938:       nsFrameItems frameItems;
28215:       rv = state.AddChild(contentFrame, frameItems, aDocElement,
28215:                           styleContext, mDocElementContainingBlock);
30785:       if (NS_FAILED(rv) || frameItems.IsEmpty()) {
23938:         return rv;
23938:       }
30785:       *aNewFrame = frameItems.FirstChild();
23938:       processChildren = PR_TRUE;
23938: 
23938:       // See if we need to create a view
23938:       nsHTMLContainerFrame::CreateViewForFrame(contentFrame, PR_FALSE);
23938:     } else {
23938:       return NS_ERROR_FAILURE;
23938:     }
23938:   }
23938:   else
23938: #endif
23938:   {
23938:     PRBool docElemIsTable = (display->mDisplay == NS_STYLE_DISPLAY_TABLE);
    1:     if (docElemIsTable) {
26208:       // We're going to call the right function ourselves, so no need to give a
26208:       // function to this FrameConstructionData.
26208: 
26208:       // XXXbz on the other hand, if we converted this whole function to
26208:       // FrameConstructionData/Item, then we'd need the right function
26208:       // here... but would probably be able to get away with less code in this
26208:       // function in general.
34614:       // Use a null PendingBinding, since our binding is not in fact pending.
30785:       static const FrameConstructionData rootTableData = FCDATA_DECL(0, nsnull);
26208:       nsRefPtr<nsStyleContext> extraRef(styleContext);
26208:       FrameConstructionItem item(&rootTableData, aDocElement,
26208:                                  aDocElement->Tag(), kNameSpaceID_None,
47661:                                  nsnull, extraRef.forget(), PR_TRUE);
26208: 
18953:       nsFrameItems frameItems;
    1:       // if the document is a table then just populate it.
28215:       rv = ConstructTable(state, item, mDocElementContainingBlock,
26208:                           styleContext->GetStyleDisplay(),
26208:                           frameItems, &contentFrame);
18953:       if (NS_FAILED(rv))
18953:         return rv;
30785:       if (!contentFrame || frameItems.IsEmpty())
18953:         return NS_ERROR_FAILURE;
30785:       *aNewFrame = frameItems.FirstChild();
30785:       NS_ASSERTION(frameItems.OnlyChild(), "multiple root element frames");
    1:     } else {
18953:       contentFrame = NS_NewBlockFrame(mPresShell, styleContext,
23305:         NS_BLOCK_FLOAT_MGR|NS_BLOCK_MARGIN_ROOT);
18953:       if (!contentFrame)
18885:         return NS_ERROR_OUT_OF_MEMORY;
18953:       nsFrameItems frameItems;
34614:       // Use a null PendingBinding, since our binding is not in fact pending.
28215:       rv = ConstructBlock(state, display, aDocElement,
28215:                           state.GetGeometricParent(display,
28215:                                                    mDocElementContainingBlock),
28215:                           mDocElementContainingBlock, styleContext,
34614:                           &contentFrame, frameItems, display->IsPositioned(),
34614:                           nsnull);
30785:       if (NS_FAILED(rv) || frameItems.IsEmpty())
18953:         return rv;
30785:       *aNewFrame = frameItems.FirstChild();
30785:       NS_ASSERTION(frameItems.OnlyChild(), "multiple root element frames");
18953:     }
    1:   }
    1: 
    1:   // set the primary frame
36653:   aDocElement->SetPrimaryFrame(contentFrame);
    1: 
24659:   NS_ASSERTION(processChildren ? !mRootElementFrame :
24659:                  mRootElementFrame == contentFrame,
24659:                "unexpected mRootElementFrame");
24659:   mRootElementFrame = contentFrame;
    1: 
16509:   // Figure out which frame has the main style for the document element,
16509:   // assigning it to mRootElementStyleFrame.
16509:   // Backgrounds should be propagated from that frame to the viewport.
16509:   PRBool isChild;
28215:   contentFrame->GetParentStyleContextFrame(state.mPresContext,
16509:           &mRootElementStyleFrame, &isChild);
16509:   if (!isChild) {
24659:     mRootElementStyleFrame = mRootElementFrame;
16509:   }
16509: 
18953:   if (processChildren) {
18953:     // Still need to process the child content
    1:     nsFrameItems childItems;
    1: 
18953:     NS_ASSERTION(!nsLayoutUtils::GetAsBlock(contentFrame),
18953:                  "Only XUL and SVG frames should reach here");
34614:     // Use a null PendingBinding, since our binding is not in fact pending.
28215:     ProcessChildren(state, aDocElement, styleContext, contentFrame, PR_TRUE,
34614:                     childItems, PR_FALSE, nsnull);
    1: 
    1:     // Set the initial child lists
30785:     contentFrame->SetInitialChildList(nsnull, childItems);
    1:   }
    1: 
30941:   SetInitialSingleChild(mDocElementContainingBlock, *aNewFrame);
28215: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
28215: nsCSSFrameConstructor::ConstructRootFrame(nsIFrame** aNewFrame)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
    1:   NS_PRECONDITION(aNewFrame, "null out param");
    1: 
28215:   nsStyleSet *styleSet = mPresShell->StyleSet();
28215: 
28215:   // Set up our style rule observer.
28215:   // XXXbz wouldn't this make more sense as part of presshell init?
28215:   {
28215:     styleSet->SetBindingManager(mDocument->BindingManager());
28215:   }
28215: 
28215:   // --------- BUILD VIEWPORT -----------
28215:   nsIFrame*                 viewportFrame = nsnull;
28215:   nsRefPtr<nsStyleContext> viewportPseudoStyle;
28215: 
35554:   viewportPseudoStyle =
35554:     styleSet->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::viewport, nsnull);
28215: 
28215:   viewportFrame = NS_NewViewportFrame(mPresShell, viewportPseudoStyle);
28215: 
28215:   // XXXbz do we _have_ to pass a null content pointer to that frame?
28215:   // Would it really kill us to pass in the root element or something?
28215:   // What would that break?
28215:   viewportFrame->Init(nsnull, nsnull, nsnull);
28215: 
28215:   // Bind the viewport frame to the root view
28215:   nsIView*        rootView;
28215:   mPresShell->GetViewManager()->GetRootView(rootView);
28215:   viewportFrame->SetView(rootView);
28215: 
28215:   nsContainerFrame::SyncFrameViewProperties(mPresShell->GetPresContext(), viewportFrame,
28215:                                             viewportPseudoStyle, rootView);
31401:   nsContainerFrame::SyncWindowProperties(mPresShell->GetPresContext(), viewportFrame,
31401:                                          rootView);
28215: 
28215:   // The viewport is the containing block for 'fixed' elements
28215:   mFixedContainingBlock = viewportFrame;
28215: 
28215:   *aNewFrame = viewportFrame;
28215:   return NS_OK;
28215: }
28215: 
28215: nsresult
28215: nsCSSFrameConstructor::SetUpDocElementContainingBlock(nsIContent* aDocElement)
28215: {
28215:   NS_PRECONDITION(aDocElement, "No element?");
28215:   NS_PRECONDITION(!aDocElement->GetParent(), "Not root content?");
28215:   NS_PRECONDITION(aDocElement->GetCurrentDoc(), "Not in a document?");
41634:   NS_PRECONDITION(aDocElement->GetCurrentDoc()->GetRootElement() ==
28215:                   aDocElement, "Not the root of the document?");
28215: 
    1:   /*
18953:     how the root frame hierarchy should look
18953: 
18953:   Galley presentation, non-XUL, with scrolling (i.e. not a frameset):
18953:   
18953:       ViewportFrame [fixed-cb]
18953:         nsHTMLScrollFrame
34149:           nsCanvasFrame [abs-cb]
18953:             root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
18953:                                 nsTableOuterFrame, nsPlaceholderFrame)
18953: 
18953:   Galley presentation, non-XUL, without scrolling (i.e. a frameset):
18953:   
18953:       ViewportFrame [fixed-cb]
34149:         nsCanvasFrame [abs-cb]
18953:           root element frame (nsBlockFrame)
18953: 
18953:   Galley presentation, XUL
18953:   
18953:       ViewportFrame [fixed-cb]
18953:         nsRootBoxFrame
18953:           root element frame (nsDocElementBoxFrame)
18953: 
18953:   Print presentation, non-XUL
18953: 
18953:       ViewportFrame
18953:         nsSimplePageSequenceFrame
18953:           nsPageFrame [fixed-cb]
18953:             nsPageContentFrame
34149:               nsCanvasFrame [abs-cb]
18953:                 root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
18953:                                     nsTableOuterFrame, nsPlaceholderFrame)
18953: 
18953:   Print-preview presentation, non-XUL
18953: 
18953:       ViewportFrame
18953:         nsHTMLScrollFrame
18953:           nsSimplePageSequenceFrame
18953:             nsPageFrame [fixed-cb]
18953:               nsPageContentFrame
34149:                 nsCanvasFrame [abs-cb]
18953:                   root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
18953:                                       nsTableOuterFrame, nsPlaceholderFrame)
18953: 
18953:   Print/print preview of XUL is not supported.
18953:   [fixed-cb]: the default containing block for fixed-pos content
18953:   [abs-cb]: the default containing block for abs-pos content
18953:  
18953:   Meaning of nsCSSFrameConstructor fields:
28215:     mRootElementFrame is "root element frame".  This is the primary frame for
28215:       the root element.
24659:     mDocElementContainingBlock is the parent of mRootElementFrame
34149:       (i.e. nsCanvasFrame or nsRootBoxFrame)
18953:     mFixedContainingBlock is the [fixed-cb]
18953:     mGfxScrollFrame is the nsHTMLScrollFrame mentioned above, or null if there isn't one
18953:     mPageSequenceFrame is the nsSimplePageSequenceFrame, or null if there isn't one
    1:   */
    1: 
    1:   // --------- CREATE ROOT FRAME -------
    1: 
    1: 
    1:   // Create the root frame. The document element's frame is a child of the
    1:   // root frame.
    1:   //
    1:   // The root frame serves two purposes:
    1:   // - reserves space for any margins needed for the document element's frame
    1:   // - renders the document element's background. This ensures the background covers
    1:   //   the entire canvas as specified by the CSS2 spec
    1: 
28215:   nsPresContext* presContext = mPresShell->GetPresContext();
    1:   PRBool isPaginated = presContext->IsRootPaginatedDocument();
28215:   nsIFrame* viewportFrame = mFixedContainingBlock;
28215:   nsStyleContext* viewportPseudoStyle = viewportFrame->GetStyleContext();
    1: 
    1:   nsIFrame* rootFrame = nsnull;
    1:   nsIAtom* rootPseudo;
    1:         
    1:   if (!isPaginated) {
    1: #ifdef MOZ_XUL
33329:     if (aDocElement->IsXUL())
    1:     {
    1:       // pass a temporary stylecontext, the correct one will be set later
    1:       rootFrame = NS_NewRootBoxFrame(mPresShell, viewportPseudoStyle);
    1:     } else
    1: #endif
    1:     {
    1:       // pass a temporary stylecontext, the correct one will be set later
    1:       rootFrame = NS_NewCanvasFrame(mPresShell, viewportPseudoStyle);
18953:       mHasRootAbsPosContainingBlock = PR_TRUE;
    1:     }
    1: 
    1:     rootPseudo = nsCSSAnonBoxes::canvas;
    1:     mDocElementContainingBlock = rootFrame;
    1:   } else {
    1:     // Create a page sequence frame
    1:     rootFrame = NS_NewSimplePageSequenceFrame(mPresShell, viewportPseudoStyle);
    1:     mPageSequenceFrame = rootFrame;
    1:     rootPseudo = nsCSSAnonBoxes::pageSequence;
    1:   }
    1: 
    1: 
    1:   // --------- IF SCROLLABLE WRAP IN SCROLLFRAME --------
    1: 
    1:   // If the device supports scrolling (e.g., in galley mode on the screen and
    1:   // for print-preview, but not when printing), then create a scroll frame that
    1:   // will act as the scrolling mechanism for the viewport. 
    1:   // XXX Do we even need a viewport when printing to a printer?
    1: 
28078:   // As long as the docshell doesn't prohibit it, and the device supports
    1:   // it, create a scroll frame that will act as the scolling mechanism for
    1:   // the viewport.
    1:   //
    1:   // Threre are three possible values stored in the docshell:
    1:   //  1) nsIScrollable::Scrollbar_Never = no scrollbars
    1:   //  2) nsIScrollable::Scrollbar_Auto = scrollbars appear if needed
    1:   //  3) nsIScrollable::Scrollbar_Always = scrollbars always
    1:   // Only need to create a scroll frame/view for cases 2 and 3.
    1: 
33329:   PRBool isHTML = aDocElement->IsHTML();
    1:   PRBool isXUL = PR_FALSE;
    1: 
    1:   if (!isHTML) {
33329:     isXUL = aDocElement->IsXUL();
    1:   }
    1: 
    1:   // Never create scrollbars for XUL documents
    1:   PRBool isScrollable = !isXUL;
    1: 
    1:   // Never create scrollbars for frameset documents.
    1:   if (isHTML) {
    1:     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
    1:     if (htmlDoc && htmlDoc->GetIsFrameset())
    1:       isScrollable = PR_FALSE;
    1:   }
    1: 
    1:   if (isPaginated) {
    1:     isScrollable = presContext->HasPaginatedScrolling();
    1:   }
    1: 
    1:   // We no longer need to do overflow propagation here. It's taken care of
    1:   // when we construct frames for the element whose overflow might be
    1:   // propagated
    1:   NS_ASSERTION(!isScrollable || !isXUL,
    1:                "XUL documents should never be scrollable - see above");
    1: 
    1:   nsIFrame* newFrame = rootFrame;
    1:   nsRefPtr<nsStyleContext> rootPseudoStyle;
    1:   // we must create a state because if the scrollbars are GFX it needs the 
    1:   // state to build the scrollbar frames.
    1:   nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull);
    1: 
28215:   // Start off with the viewport as parent; we'll adjust it as needed.
    1:   nsIFrame* parentFrame = viewportFrame;
    1: 
28215:   nsStyleSet* styleSet = mPresShell->StyleSet();
    1:   // If paginated, make sure we don't put scrollbars in
    1:   if (!isScrollable) {
35554:     rootPseudoStyle = styleSet->ResolveAnonymousBoxStyle(rootPseudo,
    1:                                                          viewportPseudoStyle);
    1:   } else {
    1:       if (rootPseudo == nsCSSAnonBoxes::canvas) {
    1:         rootPseudo = nsCSSAnonBoxes::scrolledCanvas;
    1:       } else {
    1:         NS_ASSERTION(rootPseudo == nsCSSAnonBoxes::pageSequence,
    1:                      "Unknown root pseudo");
    1:         rootPseudo = nsCSSAnonBoxes::scrolledPageSequence;
    1:       }
    1: 
28215:       // Build the frame. We give it the content we are wrapping which is the
28215:       // document element, the root frame, the parent view port frame, and we
28215:       // should get back the new frame and the scrollable view if one was
28215:       // created.
    1: 
    1:       // resolve a context for the scrollframe
    1:       nsRefPtr<nsStyleContext>  styleContext;
35554:       styleContext = styleSet->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::viewportScroll,
    1:                                                         viewportPseudoStyle);
    1: 
    1:       // Note that the viewport scrollframe is always built with
    1:       // overflow:auto style. This forces the scroll frame to create
    1:       // anonymous content for both scrollbars. This is necessary even
    1:       // if the HTML or BODY elements are overriding the viewport
    1:       // scroll style to 'hidden' --- dynamic style changes might put
    1:       // scrollbars back on the viewport and we don't want to have to
    1:       // reframe the viewport to create the scrollbar content.
    1:       newFrame = nsnull;
    1:       rootPseudoStyle = BeginBuildingScrollFrame( state,
    1:                                                   aDocElement,
    1:                                                   styleContext,
    1:                                                   viewportFrame,
    1:                                                   rootPseudo,
    1:                                                   PR_TRUE,
    1:                                                   newFrame);
    1:       parentFrame = newFrame;
    1:       mGfxScrollFrame = newFrame;
    1:   }
    1:   
    1:   rootFrame->SetStyleContextWithoutNotification(rootPseudoStyle);
    1:   rootFrame->Init(aDocElement, parentFrame, nsnull);
    1:   
    1:   if (isScrollable) {
    1:     FinishBuildingScrollFrame(parentFrame, rootFrame);
    1:   }
    1:   
    1:   if (isPaginated) { // paginated
    1:     // Create the first page
    1:     // Set the initial child lists
18953:     nsIFrame *pageFrame, *canvasFrame;
    1:     ConstructPageFrame(mPresShell, presContext, rootFrame, nsnull,
18953:                        pageFrame, canvasFrame);
30790:     SetInitialSingleChild(rootFrame, pageFrame);
    1: 
    1:     // The eventual parent of the document element frame.
    1:     // XXX should this be set for every new page (in ConstructPageFrame)?
18953:     mDocElementContainingBlock = canvasFrame;
18953:     mHasRootAbsPosContainingBlock = PR_TRUE;
    1:   }
    1: 
28215:   if (viewportFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW) {
32846:     SetInitialSingleChild(viewportFrame, newFrame);
28215:   } else {
32846:     nsFrameList newFrameList(newFrame, newFrame);
30941:     viewportFrame->AppendFrames(nsnull, newFrameList);
28215:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructPageFrame(nsIPresShell*  aPresShell,
    1:                                           nsPresContext* aPresContext,
    1:                                           nsIFrame*      aParentFrame,
    1:                                           nsIFrame*      aPrevPageFrame,
    1:                                           nsIFrame*&     aPageFrame,
18953:                                           nsIFrame*&     aCanvasFrame)
    1: {
    1:   nsStyleContext* parentStyleContext = aParentFrame->GetStyleContext();
    1:   nsStyleSet *styleSet = aPresShell->StyleSet();
    1: 
    1:   nsRefPtr<nsStyleContext> pagePseudoStyle;
35554:   pagePseudoStyle = styleSet->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::page,
    1:                                                        parentStyleContext);
    1: 
    1:   aPageFrame = NS_NewPageFrame(aPresShell, pagePseudoStyle);
    1:   if (NS_UNLIKELY(!aPageFrame))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // Initialize the page frame and force it to have a view. This makes printing of
    1:   // the pages easier and faster.
    1:   aPageFrame->Init(nsnull, aParentFrame, aPrevPageFrame);
    1: 
    1:   nsRefPtr<nsStyleContext> pageContentPseudoStyle;
35554:   pageContentPseudoStyle =
35554:     styleSet->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::pageContent,
    1:                                        pagePseudoStyle);
    1: 
18953:   nsIFrame* pageContentFrame = NS_NewPageContentFrame(aPresShell, pageContentPseudoStyle);
18953:   if (NS_UNLIKELY(!pageContentFrame))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // Initialize the page content frame and force it to have a view. Also make it the
    1:   // containing block for fixed elements which are repeated on every page.
 4006:   nsIFrame* prevPageContentFrame = nsnull;
 4006:   if (aPrevPageFrame) {
 4006:     prevPageContentFrame = aPrevPageFrame->GetFirstChild(nsnull);
 4006:     NS_ASSERTION(prevPageContentFrame, "missing page content frame");
 4006:   }
18953:   pageContentFrame->Init(nsnull, aPageFrame, prevPageContentFrame);
30790:   SetInitialSingleChild(aPageFrame, pageContentFrame);
18953:   mFixedContainingBlock = pageContentFrame;
18953: 
18953:   nsRefPtr<nsStyleContext> canvasPseudoStyle;
35554:   canvasPseudoStyle = styleSet->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::canvas,
18953:                                                          pageContentPseudoStyle);
18953: 
18953:   aCanvasFrame = NS_NewCanvasFrame(aPresShell, canvasPseudoStyle);
18953:   if (NS_UNLIKELY(!aCanvasFrame))
18953:     return NS_ERROR_OUT_OF_MEMORY;
18953: 
18953:   nsIFrame* prevCanvasFrame = nsnull;
18953:   if (prevPageContentFrame) {
18953:     prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
18953:     NS_ASSERTION(prevCanvasFrame, "missing canvas frame");
18953:   }
18953:   aCanvasFrame->Init(nsnull, pageContentFrame, prevCanvasFrame);
30790:   SetInitialSingleChild(pageContentFrame, aCanvasFrame);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsCSSFrameConstructor::CreatePlaceholderFrameFor(nsIPresShell*    aPresShell, 
    1:                                                  nsIContent*      aContent,
    1:                                                  nsIFrame*        aFrame,
    1:                                                  nsStyleContext*  aStyleContext,
    1:                                                  nsIFrame*        aParentFrame,
 6219:                                                  nsIFrame*        aPrevInFlow,
34912:                                                  nsFrameState     aTypeBit,
    1:                                                  nsIFrame**       aPlaceholderFrame)
    1: {
    1:   nsRefPtr<nsStyleContext> placeholderStyle = aPresShell->StyleSet()->
    1:     ResolveStyleForNonElement(aStyleContext->GetParent());
    1:   
    1:   // The placeholder frame gets a pseudo style context
    1:   nsPlaceholderFrame* placeholderFrame =
34912:     (nsPlaceholderFrame*)NS_NewPlaceholderFrame(aPresShell, placeholderStyle,
34912:                                                 aTypeBit);
    1: 
    1:   if (placeholderFrame) {
 6219:     placeholderFrame->Init(aContent, aParentFrame, aPrevInFlow);
    1:   
    1:     // The placeholder frame has a pointer back to the out-of-flow frame
    1:     placeholderFrame->SetOutOfFlowFrame(aFrame);
    1:   
    1:     aFrame->AddStateBits(NS_FRAME_OUT_OF_FLOW);
    1: 
    1:     // Add mapping from absolutely positioned frame to its placeholder frame
 6219:     aPresShell->FrameManager()->RegisterPlaceholderFrame(placeholderFrame);
    1: 
 3233:     *aPlaceholderFrame = static_cast<nsIFrame*>(placeholderFrame);
    1:     
    1:     return NS_OK;
    1:   }
    1:   else {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: }
    1: 
47657: // Clears any lazy bits set in the range [aStartContent, aEndContent).  If
47657: // aEndContent is null, that means to clear bits in all siblings starting with
47657: // aStartContent.  aStartContent must not be null unless aEndContent is also
47657: // null.  We do this so that when new children are inserted under elements whose
47657: // frame is a leaf the new children don't cause us to try to construct frames
47657: // for the existing children again.
47657: static inline void
47657: ClearLazyBits(nsIContent* aStartContent, nsIContent* aEndContent)
47657: {
47657:   NS_PRECONDITION(aStartContent || !aEndContent,
47657:                   "Must have start child if we have an end child");
47657:   for (nsIContent* cur = aStartContent; cur != aEndContent;
47657:        cur = cur->GetNextSibling()) {
47657:     cur->UnsetFlags(NODE_DESCENDANTS_NEED_FRAMES | NODE_NEEDS_FRAME);
47657:   }
47657: }
40938: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructButtonFrame(nsFrameConstructorState& aState,
25769:                                             FrameConstructionItem&   aItem,
    1:                                             nsIFrame*                aParentFrame,
    1:                                             const nsStyleDisplay*    aStyleDisplay,
 4461:                                             nsFrameItems&            aFrameItems,
23944:                                             nsIFrame**               aNewFrame)
23944: {
    1:   *aNewFrame = nsnull;
    1:   nsIFrame* buttonFrame = nsnull;
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25769:   if (nsGkAtoms::button == aItem.mTag) {
25769:     buttonFrame = NS_NewHTMLButtonControlFrame(mPresShell, styleContext);
    1:   }
    1:   else {
25769:     buttonFrame = NS_NewGfxButtonControlFrame(mPresShell, styleContext);
    1:   }
    1:   if (NS_UNLIKELY(!buttonFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   // Initialize the button frame
25769:   nsresult rv = InitAndRestoreFrame(aState, content,
    1:                                     aState.GetGeometricParent(aStyleDisplay, aParentFrame),
    1:                                     nsnull, buttonFrame);
    1:   if (NS_FAILED(rv)) {
    1:     buttonFrame->Destroy();
    1:     return rv;
    1:   }
23395:   // See if we need to create a view
23395:   nsHTMLContainerFrame::CreateViewForFrame(buttonFrame, PR_FALSE);
    1: 
25769:   nsRefPtr<nsStyleContext> innerBlockContext;
25769:   innerBlockContext =
35554:     mPresShell->StyleSet()->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::buttonContent,
25769:                                                      styleContext);
25769:                                                                
25769:   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerBlockContext,
23305:                                           NS_BLOCK_FLOAT_MGR);
23167: 
23176:   if (NS_UNLIKELY(!blockFrame)) {
    1:     buttonFrame->Destroy();
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
25769:   rv = InitAndRestoreFrame(aState, content, buttonFrame, nsnull, blockFrame);
    1:   if (NS_FAILED(rv)) {
23176:     blockFrame->Destroy();
    1:     buttonFrame->Destroy();
    1:     return rv;
    1:   }
    1: 
25769:   rv = aState.AddChild(buttonFrame, aFrameItems, content, styleContext,
 8199:                        aParentFrame);
    1:   if (NS_FAILED(rv)) {
23176:     blockFrame->Destroy();
    1:     buttonFrame->Destroy();
    1:     return rv;
    1:   }
    1: 
23343:   PRBool isLeaf = buttonFrame->IsLeaf();
23343: #ifdef DEBUG
23343:   // Make sure that we're an anonymous content creator exactly when we're a
23343:   // leaf
23554:   nsIAnonymousContentCreator* creator = do_QueryFrame(buttonFrame);
23343:   NS_ASSERTION(!creator == !isLeaf,
23343:                "Should be creator exactly when we're a leaf");
23343: #endif
23343:   
23343:   if (!isLeaf) { 
    1:     // Process children
    1:     nsFrameConstructorSaveState absoluteSaveState;
    1:     nsFrameItems                childItems;
    1: 
    1:     if (aStyleDisplay->IsPositioned()) {
    1:       // The area frame becomes a container for child frames that are
    1:       // absolutely positioned
23176:       aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
23176:     }
23176: 
23343: #ifdef DEBUG
23343:     // Make sure that anonymous child creation will have no effect in this case
23554:     nsIAnonymousContentCreator* creator = do_QueryFrame(blockFrame);
23343:     NS_ASSERTION(!creator, "Shouldn't be an anonymous content creator!");
23343: #endif
23343: 
25769:     rv = ProcessChildren(aState, content, styleContext, blockFrame, PR_TRUE,
34614:                          childItems, aStyleDisplay->IsBlockInside(),
34614:                          aItem.mPendingBinding);
    1:     if (NS_FAILED(rv)) return rv;
    1:   
    1:     // Set the areas frame's initial child lists
30785:     blockFrame->SetInitialChildList(nsnull, childItems);
23176:   }
23176: 
30790:   SetInitialSingleChild(buttonFrame, blockFrame);
23167: 
23343:   if (isLeaf) {
47657:     ClearLazyBits(content->GetFirstChild(), nsnull);
40938: 
    1:     nsFrameItems  anonymousChildItems;
23343:     // if there are any anonymous children create frames for them.  Note that
23343:     // we're doing this using a different parent frame from the one we pass to
23343:     // ProcessChildren!
34614:     CreateAnonymousFrames(aState, content, buttonFrame, aItem.mPendingBinding,
34614:                           anonymousChildItems);
30785:     if (anonymousChildItems.NotEmpty()) {
    1:       // the anonymous content is already parented to the area frame
23176:       aState.mFrameManager->AppendFrames(blockFrame, nsnull,
30941:                                          anonymousChildItems);
23167:     }
    1:   }
    1: 
    1:   // our new button frame returned is the top frame. 
    1:   *aNewFrame = buttonFrame; 
    1: 
    1:   return NS_OK;  
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructSelectFrame(nsFrameConstructorState& aState,
25769:                                             FrameConstructionItem&   aItem,
    1:                                             nsIFrame*                aParentFrame,
    1:                                             const nsStyleDisplay*    aStyleDisplay,
23944:                                             nsFrameItems&            aFrameItems,
23944:                                             nsIFrame**               aNewFrame)
    1: {
    1:   nsresult rv = NS_OK;
    1:   const PRInt32 kNoSizeSpecified = -1;
    1: 
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
    1:   // Construct a frame-based listbox or combobox
25769:   nsCOMPtr<nsIDOMHTMLSelectElement> sel(do_QueryInterface(content));
    1:   PRInt32 size = 1;
    1:   if (sel) {
    1:     sel->GetSize(&size); 
    1:     PRBool multipleSelect = PR_FALSE;
    1:     sel->GetMultiple(&multipleSelect);
    1:      // Construct a combobox if size=1 or no size is specified and its multiple select
    1:     if (((1 == size || 0 == size) || (kNoSizeSpecified  == size)) && (PR_FALSE == multipleSelect)) {
    1:         // Construct a frame-based combo box.
    1:         // The frame-based combo box is built out of three parts. A display area, a button and
    1:         // a dropdown list. The display area and button are created through anonymous content.
    1:         // The drop-down list's frame is created explicitly. The combobox frame shares its content
    1:         // with the drop-down list.
23305:       PRUint32 flags = NS_BLOCK_FLOAT_MGR;
25769:       nsIFrame* comboboxFrame = NS_NewComboboxControlFrame(mPresShell, styleContext, flags);
    1: 
    1:       // Save the history state so we don't restore during construction
    1:       // since the complete tree is required before we restore.
    1:       nsILayoutHistoryState *historyState = aState.mFrameState;
    1:       aState.mFrameState = nsnull;
    1:       // Initialize the combobox frame
25769:       InitAndRestoreFrame(aState, content,
    1:                           aState.GetGeometricParent(aStyleDisplay, aParentFrame),
    1:                           nsnull, comboboxFrame);
    1: 
23395:       nsHTMLContainerFrame::CreateViewForFrame(comboboxFrame, PR_FALSE);
    1: 
25769:       rv = aState.AddChild(comboboxFrame, aFrameItems, content, styleContext,
 8199:                            aParentFrame);
    1:       if (NS_FAILED(rv)) {
    1:         return rv;
    1:       }
    1:       
    1:       ///////////////////////////////////////////////////////////////////
    1:       // Combobox - Old Native Implementation
    1:       ///////////////////////////////////////////////////////////////////
23554:       nsIComboboxControlFrame* comboBox = do_QueryFrame(comboboxFrame);
    1:       NS_ASSERTION(comboBox, "NS_NewComboboxControlFrame returned frame that "
    1:                              "doesn't implement nsIComboboxControlFrame");
    1: 
    1:         // Resolve pseudo element style for the dropdown list
    1:       nsRefPtr<nsStyleContext> listStyle;
35554:       listStyle = mPresShell->StyleSet()->
35554:         ResolveAnonymousBoxStyle(nsCSSAnonBoxes::dropDownList, styleContext);
    1: 
    1:         // Create a listbox
    1:       nsIFrame* listFrame = NS_NewListControlFrame(mPresShell, listStyle);
    1: 
    1:         // Notify the listbox that it is being used as a dropdown list.
23554:       nsIListControlFrame * listControlFrame = do_QueryFrame(listFrame);
23554:       if (listControlFrame) {
    1:         listControlFrame->SetComboboxFrame(comboboxFrame);
    1:       }
    1:          // Notify combobox that it should use the listbox as it's popup
    1:       comboBox->SetDropDown(listFrame);
    1: 
    1:       NS_ASSERTION(!listStyle->GetStyleDisplay()->IsPositioned(),
    1:                    "Ended up with positioned dropdown list somehow.");
    1:       NS_ASSERTION(!listStyle->GetStyleDisplay()->IsFloating(),
    1:                    "Ended up with floating dropdown list somehow.");
    1:       
    1:       // Initialize the scroll frame positioned. Note that it is NOT
    1:       // initialized as absolutely positioned.
25769:       nsIFrame* scrolledFrame = NS_NewSelectsAreaFrame(mPresShell, styleContext, flags);
25769: 
25769:       InitializeSelectFrame(aState, listFrame, scrolledFrame, content,
34614:                             comboboxFrame, listStyle, PR_TRUE,
34614:                             aItem.mPendingBinding, aFrameItems);
    1: 
    1:         // Set flag so the events go to the listFrame not child frames.
    1:         // XXX: We should replace this with a real widget manager similar
    1:         // to how the nsFormControlFrame works. Re-directing events is a temporary Kludge.
    1:       NS_ASSERTION(listFrame->GetView(), "ListFrame's view is nsnull");
    1:       //listFrame->GetView()->SetViewFlags(NS_VIEW_PUBLIC_FLAG_DONT_CHECK_CHILDREN);
    1: 
    1:       // Create display and button frames from the combobox's anonymous content.
    1:       // The anonymous content is appended to existing anonymous content for this
    1:       // element (the scrollbars).
    1: 
    1:       nsFrameItems childItems;
34614:       CreateAnonymousFrames(aState, content, comboboxFrame,
34614:                             aItem.mPendingBinding, childItems);
    1:   
30785:       comboboxFrame->SetInitialChildList(nsnull, childItems);
    1: 
    1:       // Initialize the additional popup child list which contains the
    1:       // dropdown list frame.
    1:       nsFrameItems popupItems;
    1:       popupItems.AddChild(listFrame);
 4448:       comboboxFrame->SetInitialChildList(nsGkAtoms::selectPopupList,
30785:                                          popupItems);
    1: 
23944:       *aNewFrame = comboboxFrame;
    1:       aState.mFrameState = historyState;
    1:       if (aState.mFrameState && aState.mFrameManager) {
    1:         // Restore frame state for the entire subtree of |comboboxFrame|.
    1:         aState.mFrameManager->RestoreFrameState(comboboxFrame,
    1:                                                 aState.mFrameState);
    1:       }
    1:     } else {
    1:       ///////////////////////////////////////////////////////////////////
    1:       // ListBox - Old Native Implementation
    1:       ///////////////////////////////////////////////////////////////////
25769:       nsIFrame* listFrame = NS_NewListControlFrame(mPresShell, styleContext);
    1:       if (listFrame) {
    1:         rv = NS_OK;
    1:       }
    1:       else {
    1:         rv = NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1: 
    1:       nsIFrame* scrolledFrame = NS_NewSelectsAreaFrame(
25769:         mPresShell, styleContext, NS_BLOCK_FLOAT_MGR);
    1: 
    1:       // ******* this code stolen from Initialze ScrollFrame ********
    1:       // please adjust this code to use BuildScrollFrame.
    1: 
25769:       InitializeSelectFrame(aState, listFrame, scrolledFrame, content,
34614:                             aParentFrame, styleContext, PR_FALSE,
34614:                             aItem.mPendingBinding, aFrameItems);
    1: 
23944:       *aNewFrame = listFrame;
    1:     }
    1:   }
    1:   return rv;
    1: 
    1: }
    1: 
    1: /**
    1:  * Used to be InitializeScrollFrame but now it's only used for the select tag
    1:  * But the select tag should really be fixed to use GFX scrollbars that can
    1:  * be create with BuildScrollFrame.
    1:  */
    1: nsresult
    1: nsCSSFrameConstructor::InitializeSelectFrame(nsFrameConstructorState& aState,
    1:                                              nsIFrame*                scrollFrame,
    1:                                              nsIFrame*                scrolledFrame,
    1:                                              nsIContent*              aContent,
    1:                                              nsIFrame*                aParentFrame,
    1:                                              nsStyleContext*          aStyleContext,
    1:                                              PRBool                   aBuildCombobox,
34614:                                              PendingBinding*          aPendingBinding,
    1:                                              nsFrameItems&            aFrameItems)
    1: {
    1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
    1: 
    1:   // Initialize it
    1:   nsIFrame* geometricParent = aState.GetGeometricParent(display, aParentFrame);
    1:     
    1:   // We don't call InitAndRestoreFrame for scrollFrame because we can only
    1:   // restore the frame state after its parts have been created (in particular,
    1:   // the scrollable view). So we have to split Init and Restore.
    1: 
    1:   // Initialize the frame
    1:   scrollFrame->Init(aContent, geometricParent, nsnull);
    1: 
    1:   if (!aBuildCombobox) {
 8199:     nsresult rv = aState.AddChild(scrollFrame, aFrameItems, aContent,
 8199:                                   aStyleContext, aParentFrame);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1:   }
    1:       
23395:   nsHTMLContainerFrame::CreateViewForFrame(scrollFrame, aBuildCombobox);
    1:   if (aBuildCombobox) {
    1:     // Give the drop-down list a popup widget
    1:     nsIView* view = scrollFrame->GetView();
    1:     NS_ASSERTION(view, "We asked for a view but didn't get one");
    1:     if (view) {
    1:       view->GetViewManager()->SetViewFloating(view, PR_TRUE);
    1: 
    1:       nsWidgetInitData widgetData;
    1:       widgetData.mWindowType  = eWindowType_popup;
    1:       widgetData.mBorderStyle = eBorderStyle_default;
51050:       view->CreateWidgetForPopup(&widgetData);
    1:     }
    1:   }
    1: 
    1:   BuildScrollFrame(aState, aContent, aStyleContext, scrolledFrame,
23950:                    geometricParent, scrollFrame);
    1: 
    1:   if (aState.mFrameState && aState.mFrameManager) {
    1:     // Restore frame state for the scroll frame
    1:     aState.mFrameManager->RestoreFrameStateFor(scrollFrame, aState.mFrameState);
    1:   }
    1: 
    1:   // Process children
    1:   nsFrameConstructorSaveState absoluteSaveState;
    1:   nsFrameItems                childItems;
    1: 
    1:   if (display->IsPositioned()) {
    1:     // The area frame becomes a container for child frames that are
    1:     // absolutely positioned
    1:     aState.PushAbsoluteContainingBlock(scrolledFrame, absoluteSaveState);
    1:   }
    1: 
23352:   ProcessChildren(aState, aContent, aStyleContext, scrolledFrame, PR_FALSE,
43135:                   childItems, PR_FALSE, aPendingBinding);
    1: 
    1:   // Set the scrolled frame's initial child lists
30785:   scrolledFrame->SetInitialChildList(nsnull, childItems);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructFieldSetFrame(nsFrameConstructorState& aState,
25769:                                               FrameConstructionItem&   aItem,
    1:                                               nsIFrame*                aParentFrame,
23944:                                               const nsStyleDisplay*    aStyleDisplay,
    1:                                               nsFrameItems&            aFrameItems,
23944:                                               nsIFrame**               aNewFrame)
    1: {
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25769:   nsIFrame* newFrame = NS_NewFieldSetFrame(mPresShell, styleContext);
    1:   if (NS_UNLIKELY(!newFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // Initialize it
25769:   InitAndRestoreFrame(aState, content,
    1:                       aState.GetGeometricParent(aStyleDisplay, aParentFrame),
    1:                       nsnull, newFrame);
    1: 
    1:   // See if we need to create a view, e.g. the frame is absolutely
    1:   // positioned
23395:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:   // Resolve style and initialize the frame
25769:   nsRefPtr<nsStyleContext> fieldsetContentStyle;
35554:   fieldsetContentStyle = mPresShell->StyleSet()->
35554:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::fieldsetContent, styleContext);
25769: 
25769:   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, fieldsetContentStyle,
23305:                                           NS_BLOCK_FLOAT_MGR |
23176:                                           NS_BLOCK_MARGIN_ROOT);
25769:   InitAndRestoreFrame(aState, content, newFrame, nsnull, blockFrame);
25769: 
25769:   nsresult rv = aState.AddChild(newFrame, aFrameItems, content, styleContext,
 8199:                                 aParentFrame);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   
    1:   // Process children
    1:   nsFrameConstructorSaveState absoluteSaveState;
    1:   nsFrameItems                childItems;
    1: 
    1:   if (aStyleDisplay->IsPositioned()) {
    1:     // The area frame becomes a container for child frames that are
    1:     // absolutely positioned
23352:     // XXXbz this is probably wrong, and once arbitrary frames can be absolute
23352:     // containing blocks we should fix this..
23176:     aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
23176:   }
23176: 
25769:   ProcessChildren(aState, content, styleContext, blockFrame, PR_TRUE,
34614:                   childItems, PR_TRUE, aItem.mPendingBinding);
    1: 
30790:   nsFrameItems fieldsetKids;
30790:   fieldsetKids.AddChild(blockFrame);
30790: 
33388:   for (nsFrameList::Enumerator e(childItems); !e.AtEnd(); e.Next()) {
33388:     nsLegendFrame* legendFrame = do_QueryFrame(e.get());
23554:     if (legendFrame) {
    1:       // We want the legend to be the first frame in the fieldset child list.
    1:       // That way the EventStateManager will do the right thing when tabbing
    1:       // from a selection point within the legend (bug 236071), which is
    1:       // used for implementing legend access keys (bug 81481).
    1:       // GetAdjustedParentFrame() below depends on this frame order.
33388:       childItems.RemoveFrame(legendFrame);
30790:       // Make sure to reparent the legend so it has the fieldset as the parent.
30790:       fieldsetKids.InsertFrame(newFrame, nsnull, legendFrame);
    1:       break;
    1:     }
30790:   }
30790: 
30790:   // Set the inner frame's initial child lists
30785:   blockFrame->SetInitialChildList(nsnull, childItems);
    1: 
30790:   // Set the outer frame's initial child list
30790:   newFrame->SetInitialChildList(nsnull, fieldsetKids);
    1: 
    1:   // our new frame returned is the top frame which is the list frame. 
23944:   *aNewFrame = newFrame; 
    1: 
    1:   return NS_OK;
    1: }
    1: 
16976: static nsIFrame*
16976: FindAncestorWithGeneratedContentPseudo(nsIFrame* aFrame)
16976: {
16976:   for (nsIFrame* f = aFrame->GetParent(); f; f = f->GetParent()) {
16976:     NS_ASSERTION(f->IsGeneratedContentFrame(),
16976:                  "should not have exited generated content");
34387:     nsIAtom* pseudo = f->GetStyleContext()->GetPseudo();
16976:     if (pseudo == nsCSSPseudoElements::before ||
16976:         pseudo == nsCSSPseudoElements::after)
16976:       return f;
16976:   }
16976:   return nsnull;
16976: }
16976: 
23955: #define SIMPLE_FCDATA(_func) FCDATA_DECL(0, _func)
25131: #define FULL_CTOR_FCDATA(_flags, _func)                     \
25131:   { _flags | FCDATA_FUNC_IS_FULL_CTOR, { nsnull }, _func }
23955: 
23955: /* static */
23955: const nsCSSFrameConstructor::FrameConstructionData*
23955: nsCSSFrameConstructor::FindTextData(nsIFrame* aParentFrame)
23955: {
23167: #ifdef MOZ_SVG
25772:   if (aParentFrame && aParentFrame->IsFrameOfType(nsIFrame::eSVG)) {
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
23167:     if (ancestorFrame) {
29052:       nsSVGTextContainerFrame* metrics = do_QueryFrame(ancestorFrame);
23955:       if (metrics) {
23955:         static const FrameConstructionData sSVGGlyphData =
23955:           SIMPLE_FCDATA(NS_NewSVGGlyphFrame);
23955:         return &sSVGGlyphData;
23955:       }
23955:     }
23955:     return nsnull;
23955:   }
23955: #endif
23955: 
25773:   static const FrameConstructionData sTextData =
25773:     FCDATA_DECL(FCDATA_IS_LINE_PARTICIPANT, NS_NewTextFrame);
23955:   return &sTextData;
23955: }
23955: 
23955: nsresult
23955: nsCSSFrameConstructor::ConstructTextFrame(const FrameConstructionData* aData,
23955:                                           nsFrameConstructorState& aState,
    1:                                           nsIContent*              aContent,
    1:                                           nsIFrame*                aParentFrame,
    1:                                           nsStyleContext*          aStyleContext,
26208:                                           nsFrameItems&            aFrameItems)
    1: {
25131:   NS_PRECONDITION(aData, "Must have frame construction data");
23955: 
23955:   nsIFrame* newFrame = (*aData->mFunc.mCreationFunc)(mPresShell, aStyleContext);
    1: 
    1:   if (NS_UNLIKELY(!newFrame))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsresult rv = InitAndRestoreFrame(aState, aContent, aParentFrame,
    1:                                     nsnull, newFrame);
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     newFrame->Destroy();
    1:     return rv;
    1:   }
    1: 
    1:   // We never need to create a view for a text frame.
    1: 
16976:   if (newFrame->IsGeneratedContentFrame()) {
16976:     nsAutoPtr<nsGenConInitializer> initializer;
16976:     initializer =
16976:       static_cast<nsGenConInitializer*>(
16976:         aContent->UnsetProperty(nsGkAtoms::genConInitializerProperty));
16976:     if (initializer) {
16976:       if (initializer->mNode->InitTextFrame(initializer->mList,
16976:               FindAncestorWithGeneratedContentPseudo(newFrame), newFrame)) {
16976:         (this->*(initializer->mDirtyAll))();
16976:       }
16976:       initializer->mNode.forget();
16976:     }
16976:   }
    1:   
    1:   // Add the newly constructed frame to the flow
    1:   aFrameItems.AddChild(newFrame);
    1: 
41931:   if (aState.mSetPrimaryFrames)
36653:     aContent->SetPrimaryFrame(newFrame);
    1:   
    1:   return rv;
    1: }
    1: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindDataByInt(PRInt32 aInt,
23167:                                      nsIContent* aContent,
23944:                                      nsStyleContext* aStyleContext,
23944:                                      const FrameConstructionDataByInt* aDataPtr,
23944:                                      PRUint32 aDataLength)
23944: {
23944:   for (const FrameConstructionDataByInt *curData = aDataPtr,
23944:          *endData = aDataPtr + aDataLength;
23944:        curData != endData;
23944:        ++curData) {
23944:     if (curData->mInt == aInt) {
23944:       const FrameConstructionData* data = &curData->mData;
23944:       if (data->mBits & FCDATA_FUNC_IS_DATA_GETTER) {
23944:         return data->mFunc.mDataGetter(aContent, aStyleContext);
23944:       }
23944: 
23944:       return data;
23944:     }
23944:   }
23944: 
23944:   return nsnull;
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindDataByTag(nsIAtom* aTag,
23944:                                      nsIContent* aContent,
23944:                                      nsStyleContext* aStyleContext,
23944:                                      const FrameConstructionDataByTag* aDataPtr,
23944:                                      PRUint32 aDataLength)
23944: {
23944:   for (const FrameConstructionDataByTag *curData = aDataPtr,
23944:          *endData = aDataPtr + aDataLength;
23944:        curData != endData;
23944:        ++curData) {
23944:     if (*curData->mTag == aTag) {
23944:       const FrameConstructionData* data = &curData->mData;
23944:       if (data->mBits & FCDATA_FUNC_IS_DATA_GETTER) {
23944:         return data->mFunc.mDataGetter(aContent, aStyleContext);
23944:       }
23944: 
23944:       return data;
23944:     }
23944:   }
23944: 
23944:   return nsnull;
23944: }
23944: 
23952: #define SUPPRESS_FCDATA() FCDATA_DECL(FCDATA_SUPPRESS_FRAME, nsnull)
23944: #define SIMPLE_INT_CREATE(_int, _func) { _int, SIMPLE_FCDATA(_func) }
23944: #define SIMPLE_INT_CHAIN(_int, _func)                       \
23944:   { _int, FCDATA_DECL(FCDATA_FUNC_IS_DATA_GETTER, _func) }
23944: #define COMPLEX_INT_CREATE(_int, _func)         \
25131:   { _int, FULL_CTOR_FCDATA(0, _func) }
23944: 
23944: #define SIMPLE_TAG_CREATE(_tag, _func)          \
23944:   { &nsGkAtoms::_tag, SIMPLE_FCDATA(_func) }
23944: #define SIMPLE_TAG_CHAIN(_tag, _func)                                   \
23944:   { &nsGkAtoms::_tag, FCDATA_DECL(FCDATA_FUNC_IS_DATA_GETTER,  _func) }
23944: #define COMPLEX_TAG_CREATE(_tag, _func)             \
25131:   { &nsGkAtoms::_tag, FULL_CTOR_FCDATA(0, _func) }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindHTMLData(nsIContent* aContent,
23167:                                     nsIAtom* aTag,
23167:                                     PRInt32 aNameSpaceID,
24550:                                     nsIFrame* aParentFrame,
23944:                                     nsStyleContext* aStyleContext)
23167: {
23167:   // Ignore the tag if it's not HTML content and if it doesn't extend (via XBL)
23167:   // a valid HTML namespace.  This check must match the one in
23167:   // ShouldHaveFirstLineStyle.
47707:   if (aNameSpaceID != kNameSpaceID_XHTML) {
23944:     return nsnull;
23944:   }
23944: 
24550:   NS_ASSERTION(!aParentFrame ||
34387:                aParentFrame->GetStyleContext()->GetPseudo() !=
24550:                  nsCSSAnonBoxes::fieldsetContent ||
24550:                aParentFrame->GetParent()->GetType() == nsGkAtoms::fieldSetFrame,
24550:                "Unexpected parent for fieldset content anon box");
24550:   if (aTag == nsGkAtoms::legend &&
24550:       (!aParentFrame ||
24550:        (aParentFrame->GetType() != nsGkAtoms::fieldSetFrame &&
34387:         aParentFrame->GetStyleContext()->GetPseudo() !=
30867:           nsCSSAnonBoxes::fieldsetContent) ||
31229:        !aContent->GetParent() ||
33329:        !aContent->GetParent()->IsHTML() ||
31229:        aContent->GetParent()->Tag() != nsGkAtoms::fieldset ||
30867:        aStyleContext->GetStyleDisplay()->IsFloating() ||
30867:        aStyleContext->GetStyleDisplay()->IsAbsolutelyPositioned())) {
31229:     // <legend> is only special inside fieldset, check both the frame tree
31229:     // parent and content tree parent due to XBL issues. For floated or
30867:     // absolutely positioned legends we want to construct by display type and
31229:     // not do special legend stuff.
24550:     // XXXbz it would be nice if we could just decide this based on the parent
24550:     // tag, and hence just use a SIMPLE_TAG_CHAIN for legend below, but the
24550:     // fact that with XBL we could end up with this legend element in some
24550:     // totally weird insertion point makes that chancy, I think.
24550:     return nsnull;
24550:   }
24550: 
23944:   static const FrameConstructionDataByTag sHTMLData[] = {
23944:     SIMPLE_TAG_CHAIN(img, nsCSSFrameConstructor::FindImgData),
23944:     SIMPLE_TAG_CHAIN(mozgeneratedcontentimage,
23944:                      nsCSSFrameConstructor::FindImgData),
25773:     { &nsGkAtoms::br,
36653:       FCDATA_DECL(FCDATA_IS_LINE_PARTICIPANT | FCDATA_IS_LINE_BREAK,
25773:                   NS_NewBRFrame) },
23977:     SIMPLE_TAG_CREATE(wbr, NS_NewWBRFrame),
23944:     SIMPLE_TAG_CHAIN(input, nsCSSFrameConstructor::FindInputData),
23944:     SIMPLE_TAG_CREATE(textarea, NS_NewTextControlFrame),
23944:     COMPLEX_TAG_CREATE(select, &nsCSSFrameConstructor::ConstructSelectFrame),
23944:     SIMPLE_TAG_CHAIN(object, nsCSSFrameConstructor::FindObjectData),
23944:     SIMPLE_TAG_CHAIN(applet, nsCSSFrameConstructor::FindObjectData),
23944:     SIMPLE_TAG_CHAIN(embed, nsCSSFrameConstructor::FindObjectData),
23944:     COMPLEX_TAG_CREATE(fieldset,
23944:                        &nsCSSFrameConstructor::ConstructFieldSetFrame),
52104:     { &nsGkAtoms::legend,
52104:       FCDATA_DECL(FCDATA_ALLOW_BLOCK_STYLES, NS_NewLegendFrame) },
23944:     SIMPLE_TAG_CREATE(frameset, NS_NewHTMLFramesetFrame),
23944:     SIMPLE_TAG_CREATE(iframe, NS_NewSubDocumentFrame),
23944:     COMPLEX_TAG_CREATE(button, &nsCSSFrameConstructor::ConstructButtonFrame),
23944:     SIMPLE_TAG_CREATE(canvas, NS_NewHTMLCanvasFrame),
23944: #if defined(MOZ_MEDIA)
23944:     SIMPLE_TAG_CREATE(video, NS_NewHTMLVideoFrame),
23944:     SIMPLE_TAG_CREATE(audio, NS_NewHTMLVideoFrame),
23944: #endif
23944:     SIMPLE_TAG_CREATE(isindex, NS_NewIsIndexFrame)
23944:   };
23944: 
23944:   return FindDataByTag(aTag, aContent, aStyleContext, sHTMLData,
23944:                        NS_ARRAY_LENGTH(sHTMLData));
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindImgData(nsIContent* aContent,
23944:                                    nsStyleContext* aStyleContext)
23944: {
23944:   if (!nsImageFrame::ShouldCreateImageFrameFor(aContent, aStyleContext)) {
23944:     return nsnull;
23944:   }
23944: 
23944:   static const FrameConstructionData sImgData = SIMPLE_FCDATA(NS_NewImageFrame);
23944:   return &sImgData;
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindImgControlData(nsIContent* aContent,
23944:                                           nsStyleContext* aStyleContext)
23944: {
23944:   if (!nsImageFrame::ShouldCreateImageFrameFor(aContent, aStyleContext)) {
23944:     return nsnull;
23944:   }
23944: 
23944:   static const FrameConstructionData sImgControlData =
23944:     SIMPLE_FCDATA(NS_NewImageControlFrame);
23944:   return &sImgControlData;
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindInputData(nsIContent* aContent,
23944:                                      nsStyleContext* aStyleContext)
23944: {
23944:   static const FrameConstructionDataByInt sInputData[] = {
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_CHECKBOX, NS_NewGfxCheckboxControlFrame),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_RADIO, NS_NewGfxRadioControlFrame),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_FILE, NS_NewFileControlFrame),
23944:     SIMPLE_INT_CHAIN(NS_FORM_INPUT_IMAGE,
23944:                      nsCSSFrameConstructor::FindImgControlData),
50907:     SIMPLE_INT_CREATE(NS_FORM_INPUT_EMAIL, NS_NewTextControlFrame),
42372:     SIMPLE_INT_CREATE(NS_FORM_INPUT_SEARCH, NS_NewTextControlFrame),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_TEXT, NS_NewTextControlFrame),
42192:     SIMPLE_INT_CREATE(NS_FORM_INPUT_TEL, NS_NewTextControlFrame),
50909:     SIMPLE_INT_CREATE(NS_FORM_INPUT_URL, NS_NewTextControlFrame),
23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_PASSWORD, NS_NewTextControlFrame),
23944:     COMPLEX_INT_CREATE(NS_FORM_INPUT_SUBMIT,
23944:                        &nsCSSFrameConstructor::ConstructButtonFrame),
23944:     COMPLEX_INT_CREATE(NS_FORM_INPUT_RESET,
23944:                        &nsCSSFrameConstructor::ConstructButtonFrame),
23944:     COMPLEX_INT_CREATE(NS_FORM_INPUT_BUTTON,
23944:                        &nsCSSFrameConstructor::ConstructButtonFrame)
23944:     // Keeping hidden inputs out of here on purpose for so they get frames by
23944:     // display (in practice, none).
23944:   };
23944: 
23944:   nsCOMPtr<nsIFormControl> control = do_QueryInterface(aContent);
23944:   NS_ASSERTION(control, "input doesn't implement nsIFormControl?");
23944: 
23944:   return FindDataByInt(control->GetType(), aContent, aStyleContext,
23944:                        sInputData, NS_ARRAY_LENGTH(sInputData));
23944: }
23944: 
23944: /* static */
23944: const nsCSSFrameConstructor::FrameConstructionData*
23944: nsCSSFrameConstructor::FindObjectData(nsIContent* aContent,
23944:                                       nsStyleContext* aStyleContext)
23944: {
23944:   // GetDisplayedType isn't necessarily nsIObjectLoadingContent::TYPE_NULL for
23944:   // cases when the object is broken/suppressed/etc (e.g. a broken image), but
23944:   // we want to treat those cases as TYPE_NULL
23944:   PRUint32 type;
23944:   if (aContent->IntrinsicState() &
23944:       (NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED |
23944:        NS_EVENT_STATE_SUPPRESSED)) {
23944:     type = nsIObjectLoadingContent::TYPE_NULL;
23944:   } else {
23944:     nsCOMPtr<nsIObjectLoadingContent> objContent(do_QueryInterface(aContent));
23944:     NS_ASSERTION(objContent,
23944:                  "applet, embed and object must implement "
23944:                  "nsIObjectLoadingContent!");
23944: 
23944:     objContent->GetDisplayedType(&type);
23944:   }
23944: 
23944:   static const FrameConstructionDataByInt sObjectData[] = {
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_LOADING,
23944:                       NS_NewEmptyFrame),
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_PLUGIN,
23944:                       NS_NewObjectFrame),
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_IMAGE,
23944:                       NS_NewImageFrame),
23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_DOCUMENT,
23944:                       NS_NewSubDocumentFrame)
23944:     // Nothing for TYPE_NULL so we'll construct frames by display there
23944:   };
23944: 
23944:   return FindDataByInt((PRInt32)type, aContent, aStyleContext,
23944:                        sObjectData, NS_ARRAY_LENGTH(sObjectData));
23944: }
23944: 
23944: nsresult
25769: nsCSSFrameConstructor::ConstructFrameFromItemInternal(FrameConstructionItem& aItem,
23944:                                                       nsFrameConstructorState& aState,
    1:                                                       nsIFrame* aParentFrame,
26208:                                                       nsFrameItems& aFrameItems)
    1: {
25769:   const FrameConstructionData* data = aItem.mFCData;
25769:   NS_ASSERTION(data, "Must have frame construction data");
25769: 
25769:   PRUint32 bits = data->mBits;
23944: 
23944:   NS_ASSERTION(!(bits & FCDATA_FUNC_IS_DATA_GETTER),
23944:                "Should have dealt with this inside the data finder");
23944: 
23952:   // Some sets of bits are not compatible with each other
23952: #define CHECK_ONLY_ONE_BIT(_bit1, _bit2)               \
23952:   NS_ASSERTION(!(bits & _bit1) || !(bits & _bit2),     \
23952:                "Only one of these bits should be set")
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_FORCE_NULL_ABSPOS_CONTAINER);
24007: #ifdef MOZ_MATHML
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_WRAP_KIDS_IN_BLOCKS);
24007: #endif
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_MAY_NEED_SCROLLFRAME);
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_IS_POPUP);
23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_SKIP_ABSPOS_PUSH);
23954:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_FORCE_VIEW);
23954:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR,
23954:                      FCDATA_DISALLOW_GENERATED_CONTENT);
26207:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_ALLOW_BLOCK_STYLES);
23954:   CHECK_ONLY_ONE_BIT(FCDATA_MAY_NEED_SCROLLFRAME, FCDATA_FORCE_VIEW);
23952: #undef CHECK_ONLY_ONE_BIT
23952: 
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769:   const nsStyleDisplay* display = styleContext->GetStyleDisplay();
23944: 
23944:   nsIFrame* newFrame;
36793:   nsIFrame* primaryFrame;
23944:   if (bits & FCDATA_FUNC_IS_FULL_CTOR) {
23944:     nsresult rv =
25769:       (this->*(data->mFullConstructor))(aState, aItem, aParentFrame,
25131:                                         display, aFrameItems, &newFrame);
23944:     if (NS_FAILED(rv)) {
23944:       return rv;
23944:     }
36793: 
36793:     primaryFrame = newFrame;
23944:   } else {
25769:     nsIContent* const content = aItem.mContent;
25769: 
23944:     newFrame =
25769:       (*data->mFunc.mCreationFunc)(mPresShell, styleContext);
23944:     if (!newFrame) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
23944: 
23944:     PRBool allowOutOfFlow = !(bits & FCDATA_DISALLOW_OUT_OF_FLOW);
25772:     PRBool isPopup = aItem.mIsPopup;
23952:     NS_ASSERTION(!isPopup ||
23952:                  (aState.mPopupItems.containingBlock &&
23952:                   aState.mPopupItems.containingBlock->GetType() ==
23952:                     nsGkAtoms::popupSetFrame),
23952:                  "Should have a containing block here!");
23952: 
23944:     nsIFrame* geometricParent =
23952:       isPopup ? aState.mPopupItems.containingBlock :
23952:       (allowOutOfFlow ? aState.GetGeometricParent(display, aParentFrame)
23952:                       : aParentFrame);
23952: 
23952:     nsresult rv = NS_OK;
23952: 
23952:     // Must init frameToAddToList to null, since it's inout
23952:     nsIFrame* frameToAddToList = nsnull;
23952:     if ((bits & FCDATA_MAY_NEED_SCROLLFRAME) &&
23952:         display->IsScrollableOverflow()) {
25769:       BuildScrollFrame(aState, content, styleContext, newFrame,
23952:                        geometricParent, frameToAddToList);
23952:     } else {
25769:       rv = InitAndRestoreFrame(aState, content, geometricParent, nsnull,
23944:                                newFrame);
    1:       NS_ASSERTION(NS_SUCCEEDED(rv), "InitAndRestoreFrame failed");
23944:       // See whether we need to create a view
23954:       nsHTMLContainerFrame::CreateViewForFrame(newFrame,
23954:                                                (bits & FCDATA_FORCE_VIEW) != 0);
23952:       frameToAddToList = newFrame;
23952:     }
23952: 
36793:     // Use frameToAddToList as the primary frame.  In the non-scrollframe case
36793:     // they're equal, but in the scrollframe case newFrame is the scrolled
36793:     // frame, while frameToAddToList is the scrollframe (and should be the
36793:     // primary frame).
36793:     primaryFrame = frameToAddToList;
36793: 
25769:     rv = aState.AddChild(frameToAddToList, aFrameItems, content, styleContext,
23952:                          aParentFrame, allowOutOfFlow, allowOutOfFlow, isPopup);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
23167: 
23952: #ifdef MOZ_XUL
23952:     // Icky XUL stuff, sadly
25768: 
25769:     if (aItem.mIsRootPopupgroup) {
25768:       NS_ASSERTION(nsIRootBox::GetRootBox(mPresShell) &&
25768:                    nsIRootBox::GetRootBox(mPresShell)->GetPopupSetFrame() ==
25768:                      newFrame,
23952:                    "Unexpected PopupSetFrame");
25768:       aState.mPopupItems.containingBlock = newFrame;
25768:       aState.mHavePendingPopupgroup = PR_FALSE;
23952:     }
23952: #endif /* MOZ_XUL */
    1: 
    1:     // Process the child content if requested
    1:     nsFrameItems childItems;
    1:     nsFrameConstructorSaveState absoluteSaveState;
23343: 
23944:     if (bits & FCDATA_FORCE_NULL_ABSPOS_CONTAINER) {
23944:       aState.PushAbsoluteContainingBlock(nsnull, absoluteSaveState);
23952:     } else if (!(bits & FCDATA_SKIP_ABSPOS_PUSH) && display->IsPositioned()) {
    1:       aState.PushAbsoluteContainingBlock(newFrame, absoluteSaveState);
    1:     }
23352: 
26208:     if (bits & FCDATA_USE_CHILD_ITEMS) {
26208:       rv = ConstructFramesFromItemList(aState, aItem.mChildItems, newFrame,
26208:                                        childItems);
26208:     } else {
26207:       // Process the child frames.
25769:       rv = ProcessChildren(aState, content, styleContext, newFrame,
23954:                            !(bits & FCDATA_DISALLOW_GENERATED_CONTENT),
26207:                            childItems,
34614:                            (bits & FCDATA_ALLOW_BLOCK_STYLES) != 0,
34614:                            aItem.mPendingBinding);
26208:     }
23167: 
23952: #ifdef MOZ_XUL
23952:     // More icky XUL stuff
25769:     if (aItem.mNameSpaceID == kNameSpaceID_XUL &&
25769:         (aItem.mTag == nsGkAtoms::treechildren || // trees always need titletips
25769:          content->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltiptext) ||
25769:          content->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltip))) {
23952:       nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
23952:       if (rootBox) {
25769:         rootBox->AddTooltipSupport(content);
23952:       }
23952:     }
23952: #endif
23952: 
23946: #ifdef MOZ_MATHML
23946:     if (NS_SUCCEEDED(rv) && (bits & FCDATA_WRAP_KIDS_IN_BLOCKS)) {
23946:       nsFrameItems newItems;
23946:       nsFrameItems currentBlock;
23946:       nsIFrame* f;
30785:       while ((f = childItems.FirstChild()) != nsnull) {
23946:         PRBool wrapFrame = IsInlineFrame(f) || IsFrameSpecial(f);
23946:         if (!wrapFrame) {
25769:           rv = FlushAccumulatedBlock(aState, content, newFrame, &currentBlock, &newItems);
23946:           if (NS_FAILED(rv))
23946:             break;
23946:         }
23946: 
33388:         childItems.RemoveFrame(f);
23946:         if (wrapFrame) {
23946:           currentBlock.AddChild(f);
23946:         } else {
23946:           newItems.AddChild(f);
23946:         }
23946:       }
25769:       rv = FlushAccumulatedBlock(aState, content, newFrame, &currentBlock, &newItems);
23946: 
30785:       if (childItems.NotEmpty()) {
23946:         // an error must have occurred, delete unprocessed frames
30785:         childItems.DestroyFrames();
23946:       }
23946: 
23946:       childItems = newItems;
23946:     }
23946: #endif
    1: 
    1:     // Set the frame's initial child list
23946:     // Note that MathML depends on this being called even if
30785:     // childItems is empty!
30785:     newFrame->SetInitialChildList(nsnull, childItems);
    1:   }
23167: 
25773:   NS_ASSERTION(newFrame->IsFrameOfType(nsIFrame::eLineParticipant) ==
25773:                ((bits & FCDATA_IS_LINE_PARTICIPANT) != 0),
25773:                "Incorrectly set FCDATA_IS_LINE_PARTICIPANT bits");
25773: 
41931:   if (aState.mSetPrimaryFrames && !(bits & FCDATA_SKIP_FRAMESET)) {
36793:     aItem.mContent->SetPrimaryFrame(primaryFrame);
    1:   }
    1: 
23944:   return NS_OK;
    1: }
    1: 
    1: // after the node has been constructed and initialized create any
    1: // anonymous content a node needs.
    1: nsresult
    1: nsCSSFrameConstructor::CreateAnonymousFrames(nsFrameConstructorState& aState,
    1:                                              nsIContent*              aParent,
    1:                                              nsIFrame*                aParentFrame,
34614:                                              PendingBinding*          aPendingBinding,
    1:                                              nsFrameItems&            aChildItems)
    1: {
    1:   nsAutoTArray<nsIContent*, 4> newAnonymousItems;
25768:   nsresult rv = GetAnonymousContent(aParent, aParentFrame, newAnonymousItems);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint32 count = newAnonymousItems.Length();
    1:   if (count == 0) {
    1:     return NS_OK;
    1:   }
    1: 
34614:   nsFrameConstructorState::PendingBindingAutoPusher pusher(aState,
34614:                                                            aPendingBinding);
34614: 
25768:   nsIAnonymousContentCreator* creator = do_QueryFrame(aParentFrame);
25768:   NS_ASSERTION(creator,
25768:                "How can that happen if we have nodes to construct frames for?");
25768: 
    1:   for (PRUint32 i=0; i < count; i++) {
25768:     nsIContent* content = newAnonymousItems[i];
25768:     NS_ASSERTION(content, "null anonymous content?");
25768: 
25768:     nsIFrame* newFrame = creator->CreateFrameFor(content);
25768:     if (newFrame) {
42522:       NS_ASSERTION(content->GetPrimaryFrame(),
42522:                    "Content must have a primary frame now");
25768:       aChildItems.AddChild(newFrame);
25768:     }
25768:     else {
25768:       // create the frame and attach it to our frame
25768:       ConstructFrame(aState, content, aParentFrame, aChildItems);
25768:     }
25768:   }
25768: 
25768:   return NS_OK;
25768: }
25768: 
25768: nsresult
25768: nsCSSFrameConstructor::GetAnonymousContent(nsIContent* aParent,
25768:                                            nsIFrame* aParentFrame,
25768:                                            nsTArray<nsIContent*>& aContent)
25768: {
25768:   nsIAnonymousContentCreator* creator = do_QueryFrame(aParentFrame);
25768:   if (!creator)
25768:     return NS_OK;
25768: 
25768:   nsresult rv = creator->CreateAnonymousContent(aContent);
25768:   NS_ENSURE_SUCCESS(rv, rv);
25768: 
25768:   PRUint32 count = aContent.Length();
25768:   for (PRUint32 i=0; i < count; i++) {
    1:     // get our child's content and set its parent to our content
25768:     nsIContent* content = aContent[i];
    1:     NS_ASSERTION(content, "null anonymous content?");
    1: 
    1: #ifdef MOZ_SVG
    1:     // least-surprise CSS binding until we do the SVG specified
    1:     // cascading rules for <svg:use> - bug 265894
25511:     if (aParent &&
25511:         aParent->NodeInfo()->Equals(nsGkAtoms::use, kNameSpaceID_SVG)) {
25511:       content->SetFlags(NODE_IS_ANONYMOUS);
25511:     } else
12250: #endif
12250:     {
12250:       content->SetNativeAnonymous();
12250:     }
    1: 
23342:     rv = content->BindToTree(mDocument, aParent, aParent, PR_TRUE);
    1:     if (NS_FAILED(rv)) {
    1:       content->UnbindFromTree();
    1:       return rv;
    1:     }
25768:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static
    1: PRBool IsXULDisplayType(const nsStyleDisplay* aDisplay)
    1: {
    1:   return (aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX || 
25114: #ifdef MOZ_XUL
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_GRID || 
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_STACK ||
25114: #endif
25114:           aDisplay->mDisplay == NS_STYLE_DISPLAY_BOX
25114: #ifdef MOZ_XUL
25114:           || aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_STACK ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID_GROUP ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID_LINE ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_DECK ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_POPUP ||
    1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GROUPBOX
25114: #endif
    1:           );
    1: }
    1: 
23952: 
23952: // XUL frames are not allowed to be out of flow.
23952: #define SIMPLE_XUL_FCDATA(_func)                                        \
23952:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_SKIP_ABSPOS_PUSH,    \
23952:               _func)
23952: #define SCROLLABLE_XUL_FCDATA(_func)                                    \
23952:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_SKIP_ABSPOS_PUSH |   \
23952:               FCDATA_MAY_NEED_SCROLLFRAME, _func)
23952: #define SIMPLE_XUL_CREATE(_tag, _func)            \
23952:   { &nsGkAtoms::_tag, SIMPLE_XUL_FCDATA(_func) }
23952: #define SCROLLABLE_XUL_CREATE(_tag, _func)            \
23952:   { &nsGkAtoms::_tag, SCROLLABLE_XUL_FCDATA(_func) }
23952: #define SIMPLE_XUL_INT_CREATE(_int, _func)      \
23952:   { _int, SIMPLE_XUL_FCDATA(_func) }
23952: #define SCROLLABLE_XUL_INT_CREATE(_int, _func)                          \
23952:   { _int, SCROLLABLE_XUL_FCDATA(_func) }
23952: 
23952: static
23952: nsIFrame* NS_NewGridBoxFrame(nsIPresShell* aPresShell,
23952:                              nsStyleContext* aStyleContext)
23952: {
23952:   nsCOMPtr<nsIBoxLayout> layout;
23952:   NS_NewGridLayout2(aPresShell, getter_AddRefs(layout));
23952:   if (!layout) {
23952:     return nsnull;
23952:   }
23952: 
23952:   return NS_NewBoxFrame(aPresShell, aStyleContext, PR_FALSE, layout);
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULTagData(nsIContent* aContent,
    1:                                       nsIAtom* aTag,
    1:                                       PRInt32 aNameSpaceID,
23952:                                       nsStyleContext* aStyleContext)
23952: {
23952:   if (aNameSpaceID != kNameSpaceID_XUL) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionDataByTag sXULTagData[] = {
    1: #ifdef MOZ_XUL
23952:     SCROLLABLE_XUL_CREATE(button, NS_NewButtonBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(checkbox, NS_NewButtonBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(radio, NS_NewButtonBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(autorepeatbutton, NS_NewAutoRepeatBoxFrame),
23952:     SCROLLABLE_XUL_CREATE(titlebar, NS_NewTitleBarFrame),
23952:     SCROLLABLE_XUL_CREATE(resizer, NS_NewResizerFrame),
23952:     SIMPLE_XUL_CREATE(image, NS_NewImageBoxFrame),
23952:     SIMPLE_XUL_CREATE(spring, NS_NewLeafBoxFrame),
23952:     SIMPLE_XUL_CREATE(spacer, NS_NewLeafBoxFrame),
23952:     SIMPLE_XUL_CREATE(treechildren, NS_NewTreeBodyFrame),
23952:     SIMPLE_XUL_CREATE(treecol, NS_NewTreeColFrame),
23952:     SIMPLE_XUL_CREATE(text, NS_NewTextBoxFrame),
23952:     SIMPLE_TAG_CHAIN(label, nsCSSFrameConstructor::FindXULLabelData),
23952:     SIMPLE_TAG_CHAIN(description, nsCSSFrameConstructor::FindXULDescriptionData),
23952:     SIMPLE_XUL_CREATE(menu, NS_NewMenuFrame),
23952:     SIMPLE_XUL_CREATE(menubutton, NS_NewMenuFrame),
23952:     SIMPLE_XUL_CREATE(menuitem, NS_NewMenuItemFrame),
    1: #ifdef XP_MACOSX
23952:     SIMPLE_TAG_CHAIN(menubar, nsCSSFrameConstructor::FindXULMenubarData),
23952: #else
23952:     SIMPLE_XUL_CREATE(menubar, NS_NewMenuBarFrame),
23952: #endif /* XP_MACOSX */
23952:     SIMPLE_TAG_CHAIN(popupgroup, nsCSSFrameConstructor::FindPopupGroupData),
23952:     SIMPLE_XUL_CREATE(iframe, NS_NewSubDocumentFrame),
23952:     SIMPLE_XUL_CREATE(editor, NS_NewSubDocumentFrame),
23952:     SIMPLE_XUL_CREATE(browser, NS_NewSubDocumentFrame),
23952:     SIMPLE_XUL_CREATE(progressmeter, NS_NewProgressMeterFrame),
23952:     SIMPLE_XUL_CREATE(splitter, NS_NewSplitterFrame),
23952:     SIMPLE_TAG_CHAIN(listboxbody,
23952:                      nsCSSFrameConstructor::FindXULListBoxBodyData),
23952:     SIMPLE_TAG_CHAIN(listitem, nsCSSFrameConstructor::FindXULListItemData),
23952: #endif /* MOZ_XUL */
23952:     SIMPLE_XUL_CREATE(slider, NS_NewSliderFrame),
23952:     SIMPLE_XUL_CREATE(scrollbar, NS_NewScrollbarFrame),
23952:     SIMPLE_XUL_CREATE(scrollbarbutton, NS_NewScrollbarButtonFrame)
23952: };
23952: 
23952:   return FindDataByTag(aTag, aContent, aStyleContext, sXULTagData,
23952:                        NS_ARRAY_LENGTH(sXULTagData));
23952: }
23952: 
23952: #ifdef MOZ_XUL
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindPopupGroupData(nsIContent* aContent,
23952:                                           nsStyleContext* /* unused */)
23952: {
23952:   if (!aContent->IsRootOfNativeAnonymousSubtree()) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionData sPopupSetData =
23952:     SIMPLE_XUL_FCDATA(NS_NewPopupSetFrame);
23952:   return &sPopupSetData;
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData
23952: nsCSSFrameConstructor::sXULTextBoxData = SIMPLE_XUL_FCDATA(NS_NewTextBoxFrame);
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULLabelData(nsIContent* aContent,
23952:                                         nsStyleContext* /* unused */)
23952: {
23952:   if (aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
23952:     return &sXULTextBoxData;
23952:   }
23952: 
23952:   static const FrameConstructionData sLabelData =
23952:     SIMPLE_XUL_FCDATA(NS_NewXULLabelFrame);
23952:   return &sLabelData;
23952: }
23952: 
23952: static nsIFrame*
23952: NS_NewXULDescriptionFrame(nsIPresShell* aPresShell, nsStyleContext *aContext)
23952: {
23952:   // XXXbz do we really need to set those flags?  If the parent is not
23952:   // a block we'll get them anyway, and if it is, do we want them?
23952:   return NS_NewBlockFrame(aPresShell, aContext,
23952:                           NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULDescriptionData(nsIContent* aContent,
23952:                                               nsStyleContext* /* unused */)
23952: {
23952:   if (aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
23952:     return &sXULTextBoxData;
23952:   }
23952: 
23952:   static const FrameConstructionData sDescriptionData =
23952:     SIMPLE_XUL_FCDATA(NS_NewXULDescriptionFrame);
23952:   return &sDescriptionData;
23952: }
23952: 
23952: #ifdef XP_MACOSX
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULMenubarData(nsIContent* aContent,
23952:                                           nsStyleContext* aStyleContext)
23952: {
23952:   nsCOMPtr<nsISupports> container =
23952:     aStyleContext->PresContext()->GetContainer();
    1:   if (container) {
    1:     nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
    1:     if (treeItem) {
    1:       PRInt32 type;
    1:       treeItem->GetItemType(&type);
    1:       if (nsIDocShellTreeItem::typeChrome == type) {
    1:         nsCOMPtr<nsIDocShellTreeItem> parent;
    1:         treeItem->GetParent(getter_AddRefs(parent));
23952:         if (!parent) {
23952:           // This is the root.  Suppress the menubar, since on Mac
23952:           // window menus are not attached to the window.
23952:           static const FrameConstructionData sSuppressData = SUPPRESS_FCDATA();
23952:           return &sSuppressData;
23952:         }
23952:       }
23952:     }
23952:   }
23952: 
23952:   static const FrameConstructionData sMenubarData =
23952:     SIMPLE_XUL_FCDATA(NS_NewMenuBarFrame);
23952:   return &sMenubarData;
23952: }
23952: #endif /* XP_MACOSX */
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULListBoxBodyData(nsIContent* aContent,
23952:                                               nsStyleContext* aStyleContext)
23952: {
23952:   if (aStyleContext->GetStyleDisplay()->mDisplay !=
23952:         NS_STYLE_DISPLAY_GRID_GROUP) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionData sListBoxBodyData =
23952:     SCROLLABLE_XUL_FCDATA(NS_NewListBoxBodyFrame);
23952:   return &sListBoxBodyData;
23952: }
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23952: nsCSSFrameConstructor::FindXULListItemData(nsIContent* aContent,
23952:                                            nsStyleContext* aStyleContext)
23952: {
23952:   if (aStyleContext->GetStyleDisplay()->mDisplay !=
23952:         NS_STYLE_DISPLAY_GRID_LINE) {
23952:     return nsnull;
23952:   }
23952: 
23952:   static const FrameConstructionData sListItemData =
23952:     SCROLLABLE_XUL_FCDATA(NS_NewListItemFrame);
23952:   return &sListItemData;
23952: }
23952: 
23952: #endif /* MOZ_XUL */
23952: 
23952: /* static */
23952: const nsCSSFrameConstructor::FrameConstructionData*
23955: nsCSSFrameConstructor::FindXULDisplayData(const nsStyleDisplay* aDisplay,
23955:                                           nsIContent* aContent,
23952:                                           nsStyleContext* aStyleContext)
23952: {
23952:   static const FrameConstructionDataByInt sXULDisplayData[] = {
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_BOX, NS_NewBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_BOX, NS_NewBoxFrame),
    1: #ifdef MOZ_XUL
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_GRID, NS_NewGridBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID, NS_NewGridBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID_GROUP,
23952:                               NS_NewGridRowGroupFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID_LINE,
23952:                               NS_NewGridRowLeafFrame),
23952:     SIMPLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_DECK, NS_NewDeckFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GROUPBOX, NS_NewGroupBoxFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_STACK, NS_NewStackFrame),
23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_STACK, NS_NewStackFrame),
23952:     { NS_STYLE_DISPLAY_POPUP,
23952:       FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_IS_POPUP |
23952:                   FCDATA_SKIP_ABSPOS_PUSH, NS_NewMenuPopupFrame) }
23952: #endif /* MOZ_XUL */
23952:   };
23952: 
23952:   // Processing by display here:
23955:   return FindDataByInt(aDisplay->mDisplay, aContent, aStyleContext,
23952:                        sXULDisplayData, NS_ARRAY_LENGTH(sXULDisplayData));
    1: }
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::BeginBuildingScrollFrame(nsFrameConstructorState& aState,
    1:                                                 nsIContent*              aContent,
    1:                                                 nsStyleContext*          aContentStyle,
    1:                                                 nsIFrame*                aParentFrame,
    1:                                                 nsIAtom*                 aScrolledPseudo,
    1:                                                 PRBool                   aIsRoot,
    1:                                                 nsIFrame*&               aNewFrame)
    1: {
    1:   nsIFrame* gfxScrollFrame = aNewFrame;
    1: 
    1:   nsFrameItems anonymousItems;
    1: 
    1:   nsRefPtr<nsStyleContext> contentStyle = aContentStyle;
    1: 
    1:   if (!gfxScrollFrame) {
    1:     // Build a XULScrollFrame when the child is a box, otherwise an
    1:     // HTMLScrollFrame
25114:     // XXXbz this is the lone remaining consumer of IsXULDisplayType.
25114:     // I wonder whether we can eliminate that somehow.
    1:     if (IsXULDisplayType(aContentStyle->GetStyleDisplay())) {
    1:       gfxScrollFrame = NS_NewXULScrollFrame(mPresShell, contentStyle, aIsRoot);
    1:     } else {
    1:       gfxScrollFrame = NS_NewHTMLScrollFrame(mPresShell, contentStyle, aIsRoot);
    1:     }
    1: 
    1:     InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, gfxScrollFrame);
    1: 
    1:     // Create a view
23395:     nsHTMLContainerFrame::CreateViewForFrame(gfxScrollFrame, PR_FALSE);
    1:   }
    1: 
    1:   // if there are any anonymous children for the scroll frame, create
    1:   // frames for them.
34614:   // Pass a null pending binding: we don't care how constructors for any of
34614:   // this anonymous content order with anything else.  It's never been
34614:   // consistent anyway.
34614:   CreateAnonymousFrames(aState, aContent, gfxScrollFrame, nsnull,
34614:                         anonymousItems);
    1: 
    1:   aNewFrame = gfxScrollFrame;
    1: 
    1:   // we used the style that was passed in. So resolve another one.
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
35554:   nsStyleContext* aScrolledChildStyle =
35554:     styleSet->ResolveAnonymousBoxStyle(aScrolledPseudo, contentStyle).get();
    1: 
    1:   if (gfxScrollFrame) {
30785:      gfxScrollFrame->SetInitialChildList(nsnull, anonymousItems);
    1:   }
    1: 
    1:   return aScrolledChildStyle;
    1: }
    1: 
    1: void
    1: nsCSSFrameConstructor::FinishBuildingScrollFrame(nsIFrame* aScrollFrame,
    1:                                                  nsIFrame* aScrolledFrame)
    1: {
32846:   nsFrameList scrolled(aScrolledFrame, aScrolledFrame);
30941:   aScrollFrame->AppendFrames(nsnull, scrolled);
    1: }
    1: 
    1: 
    1: /**
    1:  * Called to wrap a gfx scrollframe around a frame. The hierarchy will look like this
    1:  *
    1:  * ------- for gfx scrollbars ------
    1:  *
    1:  *
    1:  *            ScrollFrame
    1:  *                 ^
    1:  *                 |
    1:  *               Frame (scrolled frame you passed in)
    1:  *
    1:  *
    1:  *-----------------------------------
    1:  * LEGEND:
    1:  * 
    1:  * ScrollFrame: This is a frame that manages gfx cross platform frame based scrollbars.
    1:  *
    1:  * @param aContent the content node of the child to wrap.
    1:  * @param aScrolledFrame The frame of the content to wrap. This should not be
    1:  *                    Initialized. This method will initialize it with a scrolled pseudo
    1:  *                    and no nsIContent. The content will be attached to the scrollframe 
    1:  *                    returned.
    1:  * @param aContentStyle the style context that has already been resolved for the content being passed in.
    1:  *
    1:  * @param aParentFrame The parent to attach the scroll frame to
    1:  *
    1:  * @param aNewFrame The new scrollframe or gfx scrollframe that we create. It will contain the
    1:  *                  scrolled frame you passed in. (returned)
    1:  *                  If this is not null, we'll just use it
    1:  * @param aScrolledContentStyle the style that was resolved for the scrolled frame. (returned)
    1:  */
    1: nsresult
    1: nsCSSFrameConstructor::BuildScrollFrame(nsFrameConstructorState& aState,
    1:                                         nsIContent*              aContent,
    1:                                         nsStyleContext*          aContentStyle,
    1:                                         nsIFrame*                aScrolledFrame,
    1:                                         nsIFrame*                aParentFrame,
23950:                                         nsIFrame*&               aNewFrame)
    1: {
    1:     nsRefPtr<nsStyleContext> scrolledContentStyle =
    1:       BeginBuildingScrollFrame(aState, aContent, aContentStyle, aParentFrame,
23395:                                nsCSSAnonBoxes::scrolledContent,
    1:                                PR_FALSE, aNewFrame);
    1:     
    1:     aScrolledFrame->SetStyleContextWithoutNotification(scrolledContentStyle);
    1:     InitAndRestoreFrame(aState, aContent, aNewFrame, nsnull, aScrolledFrame);
    1: 
    1:     FinishBuildingScrollFrame(aNewFrame, aScrolledFrame);
    1:     return NS_OK;
    1: }
    1: 
25131: const nsCSSFrameConstructor::FrameConstructionData*
25131: nsCSSFrameConstructor::FindDisplayData(const nsStyleDisplay* aDisplay,
26207:                                        nsIContent* aContent,
26207:                                        nsStyleContext* aStyleContext)
25131: {
26208:   PR_STATIC_ASSERT(eParentTypeCount < (1 << (32 - FCDATA_PARENT_TYPE_OFFSET)));
26208: 
    1:   // The style system ensures that floated and positioned frames are
    1:   // block-level.
    1:   NS_ASSERTION(!(aDisplay->IsFloating() ||
    1:                  aDisplay->IsAbsolutelyPositioned()) ||
 2829:                aDisplay->IsBlockOutside(),
    1:                "Style system did not apply CSS2.1 section 9.7 fixups");
    1: 
    1:   // If this is "body", try propagating its scroll style to the viewport
    1:   // Note that we need to do this even if the body is NOT scrollable;
    1:   // it might have dynamically changed from scrollable to not scrollable,
    1:   // and that might need to be propagated.
25131:   // XXXbz is this the right place to do this?  If this code moves,
25131:   // make this function static.
    1:   PRBool propagatedScrollToViewport = PR_FALSE;
    1:   if (aContent->NodeInfo()->Equals(nsGkAtoms::body) &&
33329:       aContent->IsHTML()) {
    1:     propagatedScrollToViewport =
    1:       PropagateScrollToViewport() == aContent;
    1:   }
    1: 
    1:   // If the frame is a block-level frame and is scrollable, then wrap it
    1:   // in a scroll frame.
    1:   // XXX Ignore tables for the time being
25129:   // XXXbz it would be nice to combine this with the other block
25129:   // case... Think about how do do this?
    1:   if (aDisplay->IsBlockInside() &&
    1:       aDisplay->IsScrollableOverflow() &&
    1:       !propagatedScrollToViewport) {
25131:     static const FrameConstructionData sScrollableBlockData =
25131:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructScrollableBlock);
25131:     return &sScrollableBlockData;
25131:   }
25131: 
25131:   // Handle various non-scrollable blocks
25131:   if (aDisplay->IsBlockInside() ||
25131:       NS_STYLE_DISPLAY_RUN_IN == aDisplay->mDisplay ||
25131:       NS_STYLE_DISPLAY_COMPACT == aDisplay->mDisplay) {  
25131:     static const FrameConstructionData sNonScrollableBlockData =
25131:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructNonScrollableBlock);
25131:     return &sNonScrollableBlockData;
25131:   }
25131: 
26207:   static const FrameConstructionDataByInt sDisplayData[] = {
25131:     // To keep the hash table small don't add inline frames (they're
25131:     // typically things like FONT and B), because we can quickly
25131:     // find them if we need to.
25131:     // XXXbz the "quickly" part is a bald-faced lie!
26207:     { NS_STYLE_DISPLAY_INLINE,
36653:       FULL_CTOR_FCDATA(FCDATA_IS_INLINE | FCDATA_IS_LINE_PARTICIPANT,
26207:                        &nsCSSFrameConstructor::ConstructInline) },
26207:     { NS_STYLE_DISPLAY_MARKER,
36653:       FULL_CTOR_FCDATA(FCDATA_IS_INLINE | FCDATA_IS_LINE_PARTICIPANT,
26207:                        &nsCSSFrameConstructor::ConstructInline) },
26208:     { NS_STYLE_DISPLAY_TABLE,
26208:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructTable) },
26208:     { NS_STYLE_DISPLAY_INLINE_TABLE,
26208:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructTable) },
26207:     { NS_STYLE_DISPLAY_TABLE_CAPTION,
36653:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_ALLOW_BLOCK_STYLES |
36653:                   FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_SKIP_ABSPOS_PUSH |
26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26207:                   NS_NewTableCaptionFrame) },
26207:     { NS_STYLE_DISPLAY_TABLE_ROW_GROUP,
36653:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_DISALLOW_OUT_OF_FLOW |
37262:                   FCDATA_SKIP_ABSPOS_PUSH |
26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26207:                   NS_NewTableRowGroupFrame) },
26207:     { NS_STYLE_DISPLAY_TABLE_HEADER_GROUP,
36653:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_DISALLOW_OUT_OF_FLOW |
37262:                   FCDATA_SKIP_ABSPOS_PUSH |
26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26207:                   NS_NewTableRowGroupFrame) },
26207:     { NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP,
36653:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_DISALLOW_OUT_OF_FLOW |
37262:                   FCDATA_SKIP_ABSPOS_PUSH |
26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26207:                   NS_NewTableRowGroupFrame) },
26207:     { NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP,
36653:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_DISALLOW_OUT_OF_FLOW |
36653:                   FCDATA_SKIP_ABSPOS_PUSH |
26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26207:                   NS_NewTableColGroupFrame) },
26207:     { NS_STYLE_DISPLAY_TABLE_COLUMN,
36653:       FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART |
26208:                        FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeColGroup),
26207:                        &nsCSSFrameConstructor::ConstructTableCol) },
26207:     { NS_STYLE_DISPLAY_TABLE_ROW,
36653:       FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART |
26208:                        FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRowGroup),
26207:                        &nsCSSFrameConstructor::ConstructTableRow) },
26207:     { NS_STYLE_DISPLAY_TABLE_CELL,
36653:       FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART |
26208:                        FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRow),
26207:                        &nsCSSFrameConstructor::ConstructTableCell) }
26207:   };
26207: 
26207:   return FindDataByInt(aDisplay->mDisplay, aContent, aStyleContext,
26207:                        sDisplayData, NS_ARRAY_LENGTH(sDisplayData));
25131: }
25131: 
25131: nsresult
25131: nsCSSFrameConstructor::ConstructScrollableBlock(nsFrameConstructorState& aState,
25769:                                                 FrameConstructionItem&   aItem,
25131:                                                 nsIFrame*                aParentFrame,
25131:                                                 const nsStyleDisplay*    aDisplay,
25131:                                                 nsFrameItems&            aFrameItems,
25131:                                                 nsIFrame**               aNewFrame)
25131: {
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25131:   *aNewFrame = nsnull;
    1:   nsRefPtr<nsStyleContext> scrolledContentStyle
25769:     = BeginBuildingScrollFrame(aState, content, styleContext,
    1:                                aState.GetGeometricParent(aDisplay, aParentFrame),
    1:                                nsCSSAnonBoxes::scrolledContent,
25131:                                PR_FALSE, *aNewFrame);
25131: 
25131:   // Create our block frame
    1:   // pass a temporary stylecontext, the correct one will be set later
    1:   nsIFrame* scrolledFrame =
25769:     NS_NewBlockFormattingContext(mPresShell, styleContext);
    1: 
    1:   nsFrameItems blockItem;
25131:   nsresult rv = ConstructBlock(aState,
25769:                                scrolledContentStyle->GetStyleDisplay(), content,
25131:                                *aNewFrame, *aNewFrame, scrolledContentStyle,
34614:                                &scrolledFrame, blockItem, aDisplay->IsPositioned(),
34614:                                aItem.mPendingBinding);
25131:   if (NS_UNLIKELY(NS_FAILED(rv))) {
25131:     // XXXbz any cleanup needed here?
25131:     return rv;
25131:   }
25131: 
30785:   NS_ASSERTION(blockItem.FirstChild() == scrolledFrame,
    1:                "Scrollframe's frameItems should be exactly the scrolled frame");
25131:   FinishBuildingScrollFrame(*aNewFrame, scrolledFrame);
25131: 
25769:   rv = aState.AddChild(*aNewFrame, aFrameItems, content, styleContext,
 8199:                        aParentFrame);
25131:   return rv;
25131: }
25131: 
25131: nsresult
25131: nsCSSFrameConstructor::ConstructNonScrollableBlock(nsFrameConstructorState& aState,
25769:                                                    FrameConstructionItem&   aItem,
25131:                                                    nsIFrame*                aParentFrame,
25131:                                                    const nsStyleDisplay*    aDisplay,
25131:                                                    nsFrameItems&            aFrameItems,
25131:                                                    nsIFrame**               aNewFrame)
25131: {
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25129:   if (aDisplay->IsAbsolutelyPositioned() ||
25129:       aDisplay->IsFloating() ||
25129:       NS_STYLE_DISPLAY_INLINE_BLOCK == aDisplay->mDisplay) {
25769:     *aNewFrame = NS_NewBlockFormattingContext(mPresShell, styleContext);
25129:   } else {
25769:     *aNewFrame = NS_NewBlockFrame(mPresShell, styleContext);
25769:   }
25769: 
25769:   return ConstructBlock(aState, aDisplay, aItem.mContent,
25129:                         aState.GetGeometricParent(aDisplay, aParentFrame),
25769:                         aParentFrame, styleContext, aNewFrame,
34614:                         aFrameItems, aDisplay->IsPositioned(),
34614:                         aItem.mPendingBinding);
25131: }
25131: 
25131: 
25131: nsresult 
    1: nsCSSFrameConstructor::InitAndRestoreFrame(const nsFrameConstructorState& aState,
    1:                                            nsIContent*              aContent,
    1:                                            nsIFrame*                aParentFrame,
    1:                                            nsIFrame*                aPrevInFlow,
    1:                                            nsIFrame*                aNewFrame,
    1:                                            PRBool                   aAllowCounters)
    1: {
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while creating frames");
 6518:   
    1:   nsresult rv = NS_OK;
    1:   
    1:   NS_ASSERTION(aNewFrame, "Null frame cannot be initialized");
    1:   if (!aNewFrame)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Initialize the frame
    1:   rv = aNewFrame->Init(aContent, aParentFrame, aPrevInFlow);
16976:   aNewFrame->AddStateBits(aState.mAdditionalStateBits);
    1: 
    1:   if (aState.mFrameState && aState.mFrameManager) {
    1:     // Restore frame state for just the newly created frame.
    1:     aState.mFrameManager->RestoreFrameStateFor(aNewFrame, aState.mFrameState);
    1:   }
    1: 
    1:   if (aAllowCounters && !aPrevInFlow &&
    1:       mCounterManager.AddCounterResetsAndIncrements(aNewFrame)) {
    1:     CountersDirty();
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::ResolveStyleContext(nsIFrame*         aParentFrame,
    1:                                            nsIContent*       aContent)
    1: {
18953:   nsStyleContext* parentStyleContext = nsnull;
28215:   NS_ASSERTION(aContent->GetParent(), "Must have parent here");
28215: 
  549:   aParentFrame = nsFrame::CorrectStyleParentFrame(aParentFrame, nsnull);
  549: 
18953:   if (aParentFrame) {
    1:     // Resolve the style context based on the content object and the parent
    1:     // style context
  822:     parentStyleContext = aParentFrame->GetStyleContext();
  822:   } else {
18953:     // Perhaps aParentFrame is a canvasFrame and we're replicating
18953:     // fixed-pos frames.
18953:     // XXX should we create a way to tell ConstructFrame which style
18953:     // context to use, and pass it the style context for the
18953:     // previous page's fixed-pos frame?
18953:   }
    1: 
25772:   return ResolveStyleContext(parentStyleContext, aContent);
25772: }
25772: 
25772: already_AddRefed<nsStyleContext>
25772: nsCSSFrameConstructor::ResolveStyleContext(nsStyleContext* aParentStyleContext,
25772:                                            nsIContent* aContent)
25772: {
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1: 
41640:   if (aContent->IsElement()) {
41640:     return styleSet->ResolveStyleFor(aContent->AsElement(), aParentStyleContext);
25772:   }
    1: 
    1:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
    1:                "shouldn't waste time creating style contexts for "
    1:                "comments and processing instructions");
    1: 
25772:   return styleSet->ResolveStyleForNonElement(aParentStyleContext);
    1: }
    1: 
    1: // MathML Mod - RBS
    1: #ifdef MOZ_MATHML
    1: nsresult
 6862: nsCSSFrameConstructor::FlushAccumulatedBlock(nsFrameConstructorState& aState,
 6862:                                              nsIContent* aContent,
 6862:                                              nsIFrame* aParentFrame,
 6862:                                              nsFrameItems* aBlockItems,
 6862:                                              nsFrameItems* aNewItems)
 6862: {
30785:   if (aBlockItems->IsEmpty()) {
 6862:     // Nothing to do
 6862:     return NS_OK;
 6862:   }
 6862: 
 6862:   nsStyleContext* parentContext =
 6862:     nsFrame::CorrectStyleParentFrame(aParentFrame,
 6862:                                      nsCSSAnonBoxes::mozMathMLAnonymousBlock)->GetStyleContext(); 
 6862:   nsStyleSet *styleSet = mPresShell->StyleSet();
 6862:   nsRefPtr<nsStyleContext> blockContext;
35554:   blockContext = styleSet->
35554:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::mozMathMLAnonymousBlock,
 6862:                              parentContext);
 6862: 
 6862:   // then, create a block frame that will wrap the child frames. Make it a
 6862:   // MathML frame so that Get(Absolute/Float)ContainingBlockFor know that this
 6862:   // is not a suitable block.
 6862:   nsIFrame* blockFrame = NS_NewMathMLmathBlockFrame(mPresShell, blockContext,
23305:                           NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
 6862:   if (NS_UNLIKELY(!blockFrame))
 6862:     return NS_ERROR_OUT_OF_MEMORY;
 6862: 
 6862:   InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, blockFrame);
30785:   ReparentFrames(aState.mFrameManager, blockFrame, *aBlockItems);
 6862:   // abs-pos and floats are disabled in MathML children so we don't have to
 6862:   // worry about messing up those.
30785:   blockFrame->SetInitialChildList(nsnull, *aBlockItems);
30790:   NS_ASSERTION(aBlockItems->IsEmpty(), "What happened?");
30790:   aBlockItems->Clear();
 6862:   aNewItems->AddChild(blockFrame);
 6862:   return NS_OK;
 6862: }
 6862: 
23946: // Only <math> elements can be floated or positioned.  All other MathML
23946: // should be in-flow.
23946: #define SIMPLE_MATHML_CREATE(_tag, _func)                               \
23946:   { &nsGkAtoms::_tag,                                                   \
23946:       FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW |                         \
23946:                   FCDATA_FORCE_NULL_ABSPOS_CONTAINER |                  \
36653:                   FCDATA_WRAP_KIDS_IN_BLOCKS, _func) }
23946: 
23946: /* static */
23946: const nsCSSFrameConstructor::FrameConstructionData*
23946: nsCSSFrameConstructor::FindMathMLData(nsIContent* aContent,
    1:                                       nsIAtom* aTag,
    1:                                       PRInt32 aNameSpaceID,
23946:                                       nsStyleContext* aStyleContext)
    1: {
    1:   // Make sure that we remain confined in the MathML world
    1:   if (aNameSpaceID != kNameSpaceID_MathML) 
23946:     return nsnull;
23946: 
25773:   // Handle <math> specially, because it sometimes produces inlines
25773:   if (aTag == nsGkAtoms::math) {
38776:     // This needs to match the test in EnsureBlockDisplay in
38776:     // nsRuleNode.cpp.  Though the behavior here for the display:table
38776:     // case is pretty weird...
38776:     if (aStyleContext->GetStyleDisplay()->IsBlockOutside()) {
25773:       static const FrameConstructionData sBlockMathData =
25773:         FCDATA_DECL(FCDATA_FORCE_NULL_ABSPOS_CONTAINER |
36653:                     FCDATA_WRAP_KIDS_IN_BLOCKS,
25773:                     NS_CreateNewMathMLmathBlockFrame);
25773:       return &sBlockMathData;
25773:     }
25773: 
25773:     static const FrameConstructionData sInlineMathData =
25773:       FCDATA_DECL(FCDATA_FORCE_NULL_ABSPOS_CONTAINER |
36698:                   FCDATA_IS_LINE_PARTICIPANT |
36653:                   FCDATA_WRAP_KIDS_IN_BLOCKS,
25773:                   NS_NewMathMLmathInlineFrame);
25773:     return &sInlineMathData;
25773:   }
25773:       
25773: 
23946:   static const FrameConstructionDataByTag sMathMLData[] = {
23946:     SIMPLE_MATHML_CREATE(mi_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(mn_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(ms_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(mtext_, NS_NewMathMLTokenFrame),
23946:     SIMPLE_MATHML_CREATE(mo_, NS_NewMathMLmoFrame),
23946:     SIMPLE_MATHML_CREATE(mfrac_, NS_NewMathMLmfracFrame),
23946:     SIMPLE_MATHML_CREATE(msup_, NS_NewMathMLmsupFrame),
23946:     SIMPLE_MATHML_CREATE(msub_, NS_NewMathMLmsubFrame),
23946:     SIMPLE_MATHML_CREATE(msubsup_, NS_NewMathMLmsubsupFrame),
23946:     SIMPLE_MATHML_CREATE(munder_, NS_NewMathMLmunderFrame),
23946:     SIMPLE_MATHML_CREATE(mover_, NS_NewMathMLmoverFrame),
23946:     SIMPLE_MATHML_CREATE(munderover_, NS_NewMathMLmunderoverFrame),
23946:     SIMPLE_MATHML_CREATE(mphantom_, NS_NewMathMLmphantomFrame),
23946:     SIMPLE_MATHML_CREATE(mpadded_, NS_NewMathMLmpaddedFrame),
23946:     SIMPLE_MATHML_CREATE(mspace_, NS_NewMathMLmspaceFrame),
23946:     SIMPLE_MATHML_CREATE(none, NS_NewMathMLmspaceFrame),
23946:     SIMPLE_MATHML_CREATE(mprescripts_, NS_NewMathMLmspaceFrame),
23946:     SIMPLE_MATHML_CREATE(mfenced_, NS_NewMathMLmfencedFrame),
23946:     SIMPLE_MATHML_CREATE(mmultiscripts_, NS_NewMathMLmmultiscriptsFrame),
23946:     SIMPLE_MATHML_CREATE(mstyle_, NS_NewMathMLmstyleFrame),
23946:     SIMPLE_MATHML_CREATE(msqrt_, NS_NewMathMLmsqrtFrame),
23946:     SIMPLE_MATHML_CREATE(mroot_, NS_NewMathMLmrootFrame),
23946:     SIMPLE_MATHML_CREATE(maction_, NS_NewMathMLmactionFrame),
23946:     SIMPLE_MATHML_CREATE(mrow_, NS_NewMathMLmrowFrame),
31351:     SIMPLE_MATHML_CREATE(merror_, NS_NewMathMLmrowFrame),
42199:     SIMPLE_MATHML_CREATE(menclose_, NS_NewMathMLmencloseFrame),
42199:     SIMPLE_MATHML_CREATE(semantics_, NS_NewMathMLsemanticsFrame)
23946:   };
23946: 
23946:   return FindDataByTag(aTag, aContent, aStyleContext, sMathMLData,
23946:                        NS_ARRAY_LENGTH(sMathMLData));
23167: }
23167: #endif // MOZ_MATHML
23167: 
23167: #ifdef MOZ_SVG
23954: // Only outer <svg> elements can be floated or positioned.  All other SVG
    1: // should be in-flow.
23954: #define SIMPLE_SVG_FCDATA(_func)                                        \
23954:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW |                             \
36653:               FCDATA_SKIP_ABSPOS_PUSH |                                 \
23954:               FCDATA_DISALLOW_GENERATED_CONTENT,  _func)
23954: #define SIMPLE_SVG_CREATE(_tag, _func)            \
23954:   { &nsGkAtoms::_tag, SIMPLE_SVG_FCDATA(_func) }
23954: 
23954: /* static */
23954: const nsCSSFrameConstructor::FrameConstructionData*
23954: nsCSSFrameConstructor::FindSVGData(nsIContent* aContent,
    1:                                    nsIAtom* aTag,
    1:                                    PRInt32 aNameSpaceID,
23954:                                    nsIFrame* aParentFrame,
23954:                                    nsStyleContext* aStyleContext)
23954: {
23954:   if (aNameSpaceID != kNameSpaceID_SVG || !NS_SVGEnabled()) {
23954:     return nsnull;
23954:   }
23954: 
23954:   static const FrameConstructionData sSuppressData = SUPPRESS_FCDATA();
23954:   static const FrameConstructionData sGenericContainerData =
23954:     SIMPLE_SVG_FCDATA(NS_NewSVGGenericContainerFrame);
    1: 
    1:   PRBool parentIsSVG = PR_FALSE;
23954:   nsIContent* parentContent =
23954:     aParentFrame ? aParentFrame->GetContent() : nsnull;
23954:   // XXXbz should this really be based on the XBL-resolved tag of the parent
23954:   // frame's content?  Should it not be based on the type of the parent frame
23954:   // (e.g. whether it's an SVG frame)?
23954:   if (parentContent) {
    1:     PRInt32 parentNSID;
    1:     nsIAtom* parentTag =
23954:       parentContent->GetOwnerDoc()->BindingManager()->
23954:         ResolveTag(aParentFrame->GetContent(), &parentNSID);
    1: 
    1:     // It's not clear whether the SVG spec intends to allow any SVG
    1:     // content within svg:foreignObject at all (SVG 1.1, section
    1:     // 23.2), but if it does, it better be svg:svg.  So given that
    1:     // we're allowing it, treat it as a non-SVG parent.
16967:     parentIsSVG = parentNSID == kNameSpaceID_SVG &&
16967:                   parentTag != nsGkAtoms::foreignObject;
    1:   }
    1: 
    1:   if ((aTag != nsGkAtoms::svg && !parentIsSVG) ||
    1:       (aTag == nsGkAtoms::desc || aTag == nsGkAtoms::title)) {
    1:     // Sections 5.1 and G.4 of SVG 1.1 say that SVG elements other than
    1:     // svg:svg not contained within svg:svg are incorrect, although they
    1:     // don't seem to specify error handling.  Ignore them, since many of
    1:     // our frame classes can't deal.  It *may* be that the document
    1:     // should at that point be considered in error according to F.2, but
    1:     // it's hard to tell.
    1:     //
    1:     // Style mutation can't change this situation, so don't bother
    1:     // adding to the undisplayed content map.
    1:     //
    1:     // We don't currently handle any UI for desc/title
23954:     return &sSuppressData;
    1:   }
    1: 
39637:   // We don't need frames for animation elements
39637:   if (aContent->IsNodeOfType(nsINode::eANIMATION)) {
39637:     return &sSuppressData;
39637:   }
39637: 
15895:   // Reduce the number of frames we create unnecessarily. Note that this is not
15895:   // where we select which frame in a <switch> to render! That happens in
15895:   // nsSVGSwitchFrame::PaintSVG.
28081:   if (!nsSVGFeatures::PassesConditionalProcessingTests(aContent)) {
    1:     // Note that just returning is probably not right.  According
    1:     // to the spec, <use> is allowed to use an element that fails its
    1:     // conditional, but because we never actually create the frame when
    1:     // a conditional fails and when we use GetReferencedFrame to find the
    1:     // references, things don't work right.
    1:     // XXX FIXME XXX
23954:     return &sSuppressData;
23954:   }
23954: 
23954:   // Special case for aTag == nsGkAtoms::svg because we don't want to
23954:   // have to recompute parentIsSVG for it.
    1:   if (aTag == nsGkAtoms::svg) {
23954:     if (parentIsSVG) {
23954:       static const FrameConstructionData sInnerSVGData =
23954:         SIMPLE_SVG_FCDATA(NS_NewSVGInnerSVGFrame);
23954:       return &sInnerSVGData;
23954:     }
23954: 
23954:     static const FrameConstructionData sOuterSVGData =
23954:       FCDATA_DECL(FCDATA_FORCE_VIEW | FCDATA_SKIP_ABSPOS_PUSH |
36653:                   FCDATA_DISALLOW_GENERATED_CONTENT,
23954:                   NS_NewSVGOuterSVGFrame);
23954:     return &sOuterSVGData;
23954:   }
23954: 
23954:   // Special cases for text/tspan/textpath, because the kind of frame
23954:   // they get depends on the parent frame.
23954:   if (aTag == nsGkAtoms::text) {
25772:     NS_ASSERTION(aParentFrame, "Should have aParentFrame here");
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
16390:     if (ancestorFrame) {
29052:       nsSVGTextContainerFrame* metrics = do_QueryFrame(ancestorFrame);
16390:       // Text cannot be nested
23954:       if (metrics) {
23954:         return &sGenericContainerData;
23954:       }
    1:     }
16390:   }
40733:   else if (aTag == nsGkAtoms::tspan || aTag == nsGkAtoms::altGlyph) {
25772:     NS_ASSERTION(aParentFrame, "Should have aParentFrame here");
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
    1:     if (ancestorFrame) {
29052:       nsSVGTextContainerFrame* metrics = do_QueryFrame(ancestorFrame);
23954:       if (!metrics) {
23954:         return &sGenericContainerData;
23954:       }
23954:     }
    1:   }
    1:   else if (aTag == nsGkAtoms::textPath) {
25772:     NS_ASSERTION(aParentFrame, "Should have aParentFrame here");
23953:     nsIFrame *ancestorFrame =
23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
23954:     if (!ancestorFrame ||
23954:         ancestorFrame->GetType() != nsGkAtoms::svgTextFrame) {
23954:       return &sGenericContainerData;
23954:     }
23954:   }
23954: 
23954:   static const FrameConstructionDataByTag sSVGData[] = {
23954:     SIMPLE_SVG_CREATE(g, NS_NewSVGGFrame),
23954:     SIMPLE_SVG_CREATE(svgSwitch, NS_NewSVGSwitchFrame),
23954:     SIMPLE_SVG_CREATE(polygon, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(polyline, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(circle, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(ellipse, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(line, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(rect, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(path, NS_NewSVGPathGeometryFrame),
23954:     SIMPLE_SVG_CREATE(defs, NS_NewSVGContainerFrame),
25772:     { &nsGkAtoms::foreignObject,
25772:       FULL_CTOR_FCDATA(FCDATA_DISALLOW_OUT_OF_FLOW,
25772:                        &nsCSSFrameConstructor::ConstructSVGForeignObjectFrame) },
23954:     SIMPLE_SVG_CREATE(a, NS_NewSVGAFrame),
40733:     SIMPLE_SVG_CREATE(altGlyph, NS_NewSVGTSpanFrame),
23954:     SIMPLE_SVG_CREATE(text, NS_NewSVGTextFrame),
23954:     SIMPLE_SVG_CREATE(tspan, NS_NewSVGTSpanFrame),
23954:     SIMPLE_SVG_CREATE(linearGradient, NS_NewSVGLinearGradientFrame),
23954:     SIMPLE_SVG_CREATE(radialGradient, NS_NewSVGRadialGradientFrame),
23954:     SIMPLE_SVG_CREATE(stop, NS_NewSVGStopFrame),
23954:     SIMPLE_SVG_CREATE(use, NS_NewSVGUseFrame),
23954:     SIMPLE_SVG_CREATE(marker, NS_NewSVGMarkerFrame),
23954:     SIMPLE_SVG_CREATE(image, NS_NewSVGImageFrame),
23954:     SIMPLE_SVG_CREATE(clipPath, NS_NewSVGClipPathFrame),
23954:     SIMPLE_SVG_CREATE(textPath, NS_NewSVGTextPathFrame),
23954:     SIMPLE_SVG_CREATE(filter, NS_NewSVGFilterFrame),
23954:     SIMPLE_SVG_CREATE(pattern, NS_NewSVGPatternFrame),
23954:     SIMPLE_SVG_CREATE(mask, NS_NewSVGMaskFrame),
23954:     SIMPLE_SVG_CREATE(feDistantLight, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(fePointLight, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feSpotLight, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feBlend, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feColorMatrix, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncR, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncG, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncB, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFuncA, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feComposite, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feConvolveMatrix, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feDisplacementMap, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feFlood, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feGaussianBlur, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feImage, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feMergeNode, NS_NewSVGLeafFrame),
23954:     SIMPLE_SVG_CREATE(feMorphology, NS_NewSVGLeafFrame), 
23954:     SIMPLE_SVG_CREATE(feOffset, NS_NewSVGLeafFrame), 
23954:     SIMPLE_SVG_CREATE(feTile, NS_NewSVGLeafFrame), 
23954:     SIMPLE_SVG_CREATE(feTurbulence, NS_NewSVGLeafFrame) 
23954:   };
23954: 
23954:   const FrameConstructionData* data =
23954:     FindDataByTag(aTag, aContent, aStyleContext, sSVGData,
23954:                   NS_ARRAY_LENGTH(sSVGData));
23954: 
23954:   if (!data) {
23954:     data = &sGenericContainerData;
23954:   }
23954: 
23954:   return data;
23954: }
23954: 
23954: nsresult
23954: nsCSSFrameConstructor::ConstructSVGForeignObjectFrame(nsFrameConstructorState& aState,
25769:                                                       FrameConstructionItem&   aItem,
23954:                                                       nsIFrame* aParentFrame,
23954:                                                       const nsStyleDisplay* aStyleDisplay,
23954:                                                       nsFrameItems& aFrameItems,
23954:                                                       nsIFrame** aNewFrame)
23954: {
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25769:   nsIFrame* newFrame = NS_NewSVGForeignObjectFrame(mPresShell, styleContext);
23954:   if (NS_UNLIKELY(!newFrame)) {
23954:     return NS_ERROR_OUT_OF_MEMORY;
23954:   }
23954: 
23954:   // We don't allow this frame to be out of flow
25769:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, newFrame);
23954:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
23954: 
25769:   nsresult rv = aState.AddChild(newFrame, aFrameItems, content, styleContext,
23954:                                 aParentFrame, PR_FALSE, PR_FALSE);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsRefPtr<nsStyleContext> innerPseudoStyle;
    1:   innerPseudoStyle = mPresShell->StyleSet()->
35554:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::mozSVGForeignContent, styleContext);
    1: 
    1:   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerPseudoStyle,
23305:                                           NS_BLOCK_FLOAT_MGR |
    1:                                           NS_BLOCK_MARGIN_ROOT);
23954:   if (NS_UNLIKELY(!blockFrame)) {
23954:     newFrame->Destroy();
    1:     return NS_ERROR_OUT_OF_MEMORY;
23954:   }
23954: 
23954:   nsFrameItems childItems;
    1:   // Claim to be relatively positioned so that we end up being the
    1:   // absolute containing block.
25769:   rv = ConstructBlock(aState, innerPseudoStyle->GetStyleDisplay(), content,
    1:                       newFrame, newFrame, innerPseudoStyle,
34614:                       &blockFrame, childItems, PR_TRUE,
34614:                       aItem.mPendingBinding);
23954: 
    1:   // Give the blockFrame a view so that GetOffsetTo works for descendants
    1:   // of blockFrame with views...
23395:   nsHTMLContainerFrame::CreateViewForFrame(blockFrame, PR_TRUE);
23954: 
30785:   newFrame->SetInitialChildList(nsnull, childItems);
23954: 
23954:   *aNewFrame = newFrame;
23954: 
23954:   return rv;
23954: }
23954: 
    1: #endif // MOZ_SVG
    1: 
25771: void
25771: nsCSSFrameConstructor::AddPageBreakItem(nsIContent* aContent,
25771:                                         nsStyleContext* aMainStyleContext,
25774:                                         FrameConstructionItemList& aItems)
    1: {
    1:   nsRefPtr<nsStyleContext> pseudoStyle;
25771:   // Use the same parent style context that |aMainStyleContext| has, since
23162:   // that's easier to re-resolve and it doesn't matter in practice.
23162:   // (Getting different parents can result in framechange hints, e.g.,
23162:   // for user-modify.)
25771:   pseudoStyle =
25771:     mPresShell->StyleSet()->
35554:       ResolveAnonymousBoxStyle(nsCSSAnonBoxes::pageBreak,
25771:                                aMainStyleContext->GetParent());
25772: 
25772:   NS_ASSERTION(pseudoStyle->GetStyleDisplay()->mDisplay ==
25772:                  NS_STYLE_DISPLAY_BLOCK, "Unexpected display");
25772: 
25771:   static const FrameConstructionData sPageBreakData =
36653:     FCDATA_DECL(FCDATA_SKIP_FRAMESET, NS_NewPageBreakFrame);
25771: 
25771:   // Lie about the tag and namespace so we don't trigger anything
25771:   // interesting during frame construction.
25981:   aItems.AppendItem(&sPageBreakData, aContent, nsCSSAnonBoxes::pageBreak,
47661:                     kNameSpaceID_None, nsnull, pseudoStyle.forget(), PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructFrame(nsFrameConstructorState& aState,
    1:                                       nsIContent*              aContent,
    1:                                       nsIFrame*                aParentFrame,
    1:                                       nsFrameItems&            aFrameItems)
    1: 
    1: {
    1:   NS_PRECONDITION(nsnull != aParentFrame, "no parent frame");
25774:   FrameConstructionItemList items;
47661:   AddFrameConstructionItems(aState, aContent, PR_TRUE, aParentFrame, items);
25771: 
25774:   for (FCItemIterator iter(items); !iter.IsDone(); iter.Next()) {
26208:     NS_ASSERTION(iter.item().DesiredParentType() == GetParentType(aParentFrame),
26208:                  "This is not going to work");
25771:     nsresult rv =
25774:       ConstructFramesFromItem(aState, iter, aParentFrame, aFrameItems);
25771:     NS_ENSURE_SUCCESS(rv, rv);
25771:   }
25771: 
25768:   return NS_OK;
25768: }
25768: 
25768: void
25771: nsCSSFrameConstructor::AddFrameConstructionItems(nsFrameConstructorState& aState,
25768:                                                  nsIContent* aContent,
47661:                                                  PRBool aSuppressWhiteSpaceOptimizations,
25768:                                                  nsIFrame* aParentFrame,
25774:                                                  FrameConstructionItemList& aItems)
25768: {
40938:   aContent->UnsetFlags(NODE_DESCENDANTS_NEED_FRAMES | NODE_NEEDS_FRAME);
43792:   if (aContent->IsElement()) {
43792:     // We can't just remove our pending restyle flags, since we may
43792:     // have restyle-later-siblings set on us.  But we _can_ remove the
43792:     // "is possible restyle root" flags, and need to.  Otherwise we can
43792:     // end up with stale such flags (e.g. if we used to have a
43792:     // display:none parent when our last restyle was posted and
43792:     // processed and now no longer do).
43792:     aContent->UnsetFlags(ELEMENT_ALL_RESTYLE_FLAGS &
43792:                          ~ELEMENT_PENDING_RESTYLE_FLAGS);
43792:   }
40938: 
    1:   // don't create a whitespace frame if aParent doesn't want it
41931:   if (!NeedFrameFor(aState, aParentFrame, aContent)) {
25768:     return;
    1:   }
    1: 
    1:   // never create frames for comments or PIs
    1:   if (aContent->IsNodeOfType(nsINode::eCOMMENT) ||
    1:       aContent->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION))
25768:     return;
    1: 
    1:   nsRefPtr<nsStyleContext> styleContext;
    1:   styleContext = ResolveStyleContext(aParentFrame, aContent);
    1: 
25771:   AddFrameConstructionItemsInternal(aState, aContent, aParentFrame,
    1:                                     aContent->Tag(), aContent->GetNameSpaceID(),
47661:                                     aSuppressWhiteSpaceOptimizations,
47661:                                     styleContext,
25768:                                     ITEM_ALLOW_XBL_BASE | ITEM_ALLOW_PAGE_BREAK,
25768:                                     aItems);
25768: }
25768: 
28357: /**
28357:  * Set aContent as undisplayed content with style context aStyleContext.  This
28357:  * method enforces the invariant that all style contexts in the undisplayed
28357:  * content map must be non-pseudo contexts and also handles unbinding
28357:  * undisplayed generated content as needed.
28357:  */
28357: static void
28357: SetAsUndisplayedContent(nsFrameManager* aFrameManager, nsIContent* aContent,
28357:                         nsStyleContext* aStyleContext,
28357:                         PRBool aIsGeneratedContent)
28357: {
34387:   if (aStyleContext->GetPseudo()) {
28357:     if (aIsGeneratedContent) {
28357:       aContent->UnbindFromTree();
28357:     }
28357:     return;
28357:   }
28357: 
28357:   NS_ASSERTION(!aIsGeneratedContent, "Should have had pseudo type");
28357:   aFrameManager->SetUndisplayedContent(aContent, aStyleContext);
28357: }
25768: 
25768: void
25771: nsCSSFrameConstructor::AddFrameConstructionItemsInternal(nsFrameConstructorState& aState,
    1:                                                          nsIContent* aContent,
    1:                                                          nsIFrame* aParentFrame,
    1:                                                          nsIAtom* aTag,
    1:                                                          PRInt32 aNameSpaceID,
47661:                                                          PRBool aSuppressWhiteSpaceOptimizations,
    1:                                                          nsStyleContext* aStyleContext,
25768:                                                          PRUint32 aFlags,
25774:                                                          FrameConstructionItemList& aItems)
    1: {
    1:   // The following code allows the user to specify the base tag
    1:   // of an element using XBL.  XUL and HTML objects (like boxes, menus, etc.)
    1:   // can then be extended arbitrarily.
    1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
    1:   nsRefPtr<nsStyleContext> styleContext(aStyleContext);
34614:   PendingBinding* pendingBinding = nsnull;
25768:   if ((aFlags & ITEM_ALLOW_XBL_BASE) && display->mBinding)
25649:   {
    1:     // Ensure that our XBL bindings are installed.
    1: 
    1:     nsIXBLService * xblService = GetXBLService();
    1:     if (!xblService)
25768:       return;
    1: 
25649:     PRBool resolveStyle;
25649: 
34614:     nsAutoPtr<PendingBinding> newPendingBinding(new PendingBinding());
34614:     if (!newPendingBinding) {
34614:       return;
34614:     }
25649:     nsresult rv = xblService->LoadBindings(aContent, display->mBinding->mURI,
 3645:                                            display->mBinding->mOriginPrincipal,
25649:                                            PR_FALSE,
34614:                                            getter_AddRefs(newPendingBinding->mBinding),
    1:                                            &resolveStyle);
53759:     if (NS_FAILED(rv))
25768:       return;
    1: 
34614:     if (newPendingBinding->mBinding) {
34614:       pendingBinding = newPendingBinding;
34614:       // aState takes over owning newPendingBinding
34614:       aState.AddPendingBinding(newPendingBinding.forget());
53759:     }
34614: 
    1:     if (resolveStyle) {
25772:       styleContext = ResolveStyleContext(styleContext->GetParent(), aContent);
    1:       display = styleContext->GetStyleDisplay();
25649:       aStyleContext = styleContext;
25649:     }
25649: 
25649:     aTag = mDocument->BindingManager()->ResolveTag(aContent, &aNameSpaceID);
    1:   }
    1: 
28357:   PRBool isGeneratedContent = ((aFlags & ITEM_IS_GENERATED_CONTENT) != 0);
28357: 
    1:   // Pre-check for display "none" - if we find that, don't create
    1:   // any frame at all
    1:   if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
28357:     SetAsUndisplayedContent(aState.mFrameManager, aContent, styleContext,
28357:                             isGeneratedContent);
25768:     return;
    1:   }
    1: 
23955:   PRBool isText = aContent->IsNodeOfType(nsINode::eTEXT);
25772:   PRBool isPopup = PR_FALSE;
23955:   // Try to find frame construction data for this content
23955:   const FrameConstructionData* data;
23955:   if (isText) {
23955:     data = FindTextData(aParentFrame);
25131: #ifdef MOZ_SVG
25131:     if (!data) {
25131:       // Nothing to do here; suppressed text inside SVG
25768:       return;
25131:     }
25131: #endif /* MOZ_SVG */
23955:   } else {
25131: #ifdef MOZ_SVG
25131:     // Don't create frames for non-SVG element children of SVG elements.
25131:     if (aNameSpaceID != kNameSpaceID_SVG &&
25131:         aParentFrame &&
25131:         aParentFrame->IsFrameOfType(nsIFrame::eSVG) &&
25131:         !aParentFrame->IsFrameOfType(nsIFrame::eSVGForeignObject)
25131:         ) {
28357:       SetAsUndisplayedContent(aState.mFrameManager, aContent, styleContext,
28357:                               isGeneratedContent);
25768:       return;
25131:     }
25131: #endif /* MOZ_SVG */
25131: 
24550:     data = FindHTMLData(aContent, aTag, aNameSpaceID, aParentFrame,
24550:                         styleContext);
23955:     if (!data) {
23955:       data = FindXULTagData(aContent, aTag, aNameSpaceID, styleContext);
23955:     }
23955: #ifdef MOZ_MATHML
23955:     if (!data) {
23955:       data = FindMathMLData(aContent, aTag, aNameSpaceID, styleContext);
23955:     }
23955: #endif
23955: #ifdef MOZ_SVG
23955:     if (!data) {
23955:       data = FindSVGData(aContent, aTag, aNameSpaceID, aParentFrame,
23955:                          styleContext);
23955:     }
23955: #endif /* MOZ_SVG */
23955: 
25131:     // Now check for XUL display types
25131:     if (!data) {
25649:       data = FindXULDisplayData(display, aContent, styleContext);
25131:     }
25131: 
25131:     // And general display types
25131:     if (!data) {
26207:       data = FindDisplayData(display, aContent, styleContext);
25131:     }
25131: 
25131:     NS_ASSERTION(data, "Should have frame construction data now");
25131: 
25131:     if (data->mBits & FCDATA_SUPPRESS_FRAME) {
28357:       SetAsUndisplayedContent(aState.mFrameManager, aContent, styleContext,
28357:                               isGeneratedContent);
25768:       return;
23955:     }
25650: 
25650: #ifdef MOZ_XUL
25650:     if ((data->mBits & FCDATA_IS_POPUP) &&
25772:         (!aParentFrame || // Parent is inline
25772:          aParentFrame->GetType() != nsGkAtoms::menuFrame)) {
25772:       if (!aState.mPopupItems.containingBlock &&
25768:           !aState.mHavePendingPopupgroup) {
28357:         SetAsUndisplayedContent(aState.mFrameManager, aContent, styleContext,
28357:                                 isGeneratedContent);
25768:         return;
25650:       }
25772: 
25772:       isPopup = PR_TRUE;
25772:     }
25650: #endif /* MOZ_XUL */
23955:   }
23955: 
25772:   PRUint32 bits = data->mBits;
25772: 
25770:   // Inside colgroups, suppress everything except columns.
25770:   if (aParentFrame &&
25770:       aParentFrame->GetType() == nsGkAtoms::tableColGroupFrame &&
25772:       (!(bits & FCDATA_IS_TABLE_PART) ||
25770:        display->mDisplay != NS_STYLE_DISPLAY_TABLE_COLUMN)) {
28357:     SetAsUndisplayedContent(aState.mFrameManager, aContent, styleContext,
28357:                             isGeneratedContent);
25770:     return;
25770:   }
25770: 
25771:   PRBool canHavePageBreak =
25771:     (aFlags & ITEM_ALLOW_PAGE_BREAK) &&
25771:     aState.mPresContext->IsPaginated() &&
25771:     !display->IsAbsolutelyPositioned() &&
25772:     !(bits & FCDATA_IS_TABLE_PART);
25771: 
25771:   if (canHavePageBreak && display->mBreakBefore) {
25771:     AddPageBreakItem(aContent, aStyleContext, aItems);
25771:   }
25771: 
25981:   FrameConstructionItem* item =
47661:     aItems.AppendItem(data, aContent, aTag, aNameSpaceID,
47661:                       pendingBinding, styleContext.forget(),
47661:                       aSuppressWhiteSpaceOptimizations);
25768:   if (!item) {
25768:     if (isGeneratedContent) {
25768:       aContent->UnbindFromTree();
25768:     }
25768:     return;
25768:   }
25768: 
25768:   item->mIsText = isText;
25768:   item->mIsGeneratedContent = isGeneratedContent;
25768:   if (isGeneratedContent) {
25768:     NS_ADDREF(item->mContent);
25768:   }
25769:   item->mIsRootPopupgroup =
25769:     aNameSpaceID == kNameSpaceID_XUL && aTag == nsGkAtoms::popupgroup &&
25769:     aContent->IsRootOfNativeAnonymousSubtree();
25769:   if (item->mIsRootPopupgroup) {
25769:     aState.mHavePendingPopupgroup = PR_TRUE;
25769:   }
25772:   item->mIsPopup = isPopup;
25771: 
25771:   if (canHavePageBreak && display->mBreakAfter) {
25771:     AddPageBreakItem(aContent, aStyleContext, aItems);
25771:   }
25772: 
25772:   if (bits & FCDATA_IS_INLINE) {
25772:     // To correctly set item->mIsAllInline we need to build up our child items
25772:     // right now.
25772:     BuildInlineChildItems(aState, *item);
25773:     item->mHasInlineEnds = PR_TRUE;
34462:     item->mIsBlock = PR_FALSE;
25772:   } else {
34462:     // Compute a boolean isInline which is guaranteed to be false for blocks
34462:     // (but may also be false for some inlines).
34462:     PRBool isInline =
34462:       // Table-internal things are inline-outside if and only if they're kids of
25772:       // inlines, since they'll trigger construction of inline-table
25772:       // pseudos.
25772:       ((bits & FCDATA_IS_TABLE_PART) &&
25772:        (!aParentFrame || // No aParentFrame means inline
25772:         aParentFrame->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE)) ||
25772:       // Things that are inline-outside but aren't inline frames are inline
25772:       display->IsInlineOutside() ||
25772:       // Popups that are certainly out of flow.
25772:       isPopup;
34462: 
34462:     // Set mIsAllInline conservatively.  It just might be that even an inline
34462:     // that has mIsAllInline false doesn't need an {ib} split.  So this is just
34462:     // an optimization to keep from doing too much work in cases when we can
34462:     // show that mIsAllInline is true..
34462:     item->mIsAllInline = item->mHasInlineEnds = isInline ||
34462:       // Figure out whether we're guaranteed this item will be out of flow.
34462:       // This is not a precise test, since one of our ancestor inlines might add
34462:       // an absolute containing block (if it's relatively positioned) when there
34462:       // wasn't such a containing block before.  But it's conservative in the
34462:       // sense that anything that will really end up as an in-flow non-inline
34462:       // will test false here.  In other words, if this test is true we're
34462:       // guaranteed to be inline; if it's false we don't know what we'll end up
34462:       // as.
34462:       //
34462:       // If we make this test precise, we can remove some of the code dealing
34462:       // with the imprecision in ConstructInline and adjust the comments on
34462:       // mIsAllInline and mIsBlock in the header.  And probably remove mIsBlock
34462:       // altogether, since then it will always be equal to !mHasInlineEnds.
34462:       (!(bits & FCDATA_DISALLOW_OUT_OF_FLOW) &&
34462:        aState.GetGeometricParent(display, nsnull));
34462: 
34462:     // Set mIsBlock conservatively.  It's OK to set it false for some real
34462:     // blocks, but not OK to set it true for things that aren't blocks.  Since
34462:     // isOutOfFlow might be false even in cases when the frame will end up
34462:     // out-of-flow, we can't use it here.  But we _can_ say that the frame will
34462:     // for sure end up in-flow if it's not floated or absolutely positioned.
34462:     item->mIsBlock =
34462:       !isInline && !display->IsAbsolutelyPositioned() && !display->IsFloating();
25772:   }
25774: 
25774:   if (item->mIsAllInline) {
25774:     aItems.InlineItemAdded();
34462:   } else if (item->mIsBlock) {
34462:     aItems.BlockItemAdded();
25774:   }
25774: 
29075:   // Our item should be treated as a line participant if we have the relevant
29075:   // bit and are going to be in-flow.  Note that this really only matters if
29075:   // our ancestor is a box or some such, so the fact that we might have an
29075:   // inline ancestor that might become a containing block is not relevant here.
29075:   if ((bits & FCDATA_IS_LINE_PARTICIPANT) &&
29075:       ((bits & FCDATA_DISALLOW_OUT_OF_FLOW) ||
29075:        !aState.GetGeometricParent(display, nsnull))) {
29075:     item->mIsLineParticipant = PR_TRUE;
25774:     aItems.LineParticipantItemAdded();
25774:   }
25768: }
25768: 
39965: static void
39965: DestroyContent(void* aPropertyValue)
25768: {
25768:   nsIContent* content = static_cast<nsIContent*>(aPropertyValue);
25768:   content->UnbindFromTree();
25768:   NS_RELEASE(content);
25768: }
25768: 
39965: NS_DECLARE_FRAME_PROPERTY(BeforeProperty, DestroyContent)
39965: NS_DECLARE_FRAME_PROPERTY(AfterProperty, DestroyContent)
39965: 
39965: static const FramePropertyDescriptor*
39965: GenConPseudoToProperty(nsIAtom* aPseudo)
39965: {
39965:   NS_ASSERTION(aPseudo == nsCSSPseudoElements::before ||
39965:                aPseudo == nsCSSPseudoElements::after,
39965:                "Bad gen-con pseudo");
39965:   return aPseudo == nsCSSPseudoElements::before ? BeforeProperty()
39965:       : AfterProperty();
39965: }
39965: 
29501: /**
29501:  * Return true if the frame construction item pointed to by aIter will
29501:  * create a frame adjacent to a line boundary in the frame tree, and that
29501:  * line boundary is induced by a content node adjacent to the frame's
29501:  * content node in the content tree. The latter condition is necessary so
29501:  * that ContentAppended/ContentInserted/ContentRemoved can easily find any
29501:  * text nodes that were suppressed here.
29501:  */
29501: PRBool
29501: nsCSSFrameConstructor::AtLineBoundary(FCItemIterator& aIter)
29501: {
47661:   if (aIter.item().mSuppressWhiteSpaceOptimizations) {
29501:     return PR_FALSE;
29501:   }
29501: 
29501:   if (aIter.AtStart()) {
29501:     if (aIter.List()->HasLineBoundaryAtStart() &&
47661:         !aIter.item().mContent->GetPreviousSibling())
29501:       return PR_TRUE;
29501:   } else {
29501:     FCItemIterator prev = aIter;
29501:     prev.Prev();
29501:     if (prev.item().IsLineBoundary() &&
47661:         !prev.item().mSuppressWhiteSpaceOptimizations &&
47661:         aIter.item().mContent->GetPreviousSibling() == prev.item().mContent)
29501:       return PR_TRUE;
29501:   }
29501: 
29501:   FCItemIterator next = aIter;
29501:   next.Next();
29501:   if (next.IsDone()) {
29501:     if (aIter.List()->HasLineBoundaryAtEnd() &&
47661:         !aIter.item().mContent->GetNextSibling())
29501:       return PR_TRUE;
29501:   } else {
29501:     if (next.item().IsLineBoundary() &&
47661:         !next.item().mSuppressWhiteSpaceOptimizations &&
47661:         aIter.item().mContent->GetNextSibling() == next.item().mContent)
29501:       return PR_TRUE;
29501:   }
29501: 
29501:   return PR_FALSE;
29501: }
29501: 
25768: nsresult
25768: nsCSSFrameConstructor::ConstructFramesFromItem(nsFrameConstructorState& aState,
29501:                                                FCItemIterator& aIter,
25768:                                                nsIFrame* aParentFrame,
25768:                                                nsFrameItems& aFrameItems)
25768: {
    1:   nsIFrame* adjParentFrame = aParentFrame;
29501:   FrameConstructionItem& item = aIter.item();
29501:   nsStyleContext* styleContext = item.mStyleContext;
29501:   AdjustParentFrame(adjParentFrame, item.mFCData, styleContext);
29501: 
29501:   if (item.mIsText) {
29501:     // If this is collapsible whitespace next to a line boundary,
29809:     // don't create a frame. item.IsWhitespace() also sets the
29809:     // NS_CREATE_FRAME_IF_NON_WHITESPACE flag in the text node. (If we
29809:     // end up creating a frame, nsTextFrame::Init will clear the flag.)
29501:     // We don't do this for generated content, because some generated
29501:     // text content is empty text nodes that are about to be initialized.
29501:     // (We check mAdditionalStateBits because only the generated content
29501:     // container's frame construction item is marked with
29501:     // mIsGeneratedContent, and we might not have an aParentFrame.)
29501:     // We don't do it for content that may have XBL anonymous siblings,
29501:     // because they make it difficult to correctly create the frame
29501:     // due to dynamic changes.
29992:     // We don't do it for text that's not a line participant (i.e. SVG text).
29501:     if (AtLineBoundary(aIter) &&
29501:         !styleContext->GetStyleText()->NewlineIsSignificant() &&
29501:         aIter.List()->ParentHasNoXBLChildren() &&
29501:         !(aState.mAdditionalStateBits & NS_FRAME_GENERATED_CONTENT) &&
29992:         (item.mFCData->mBits & FCDATA_IS_LINE_PARTICIPANT) &&
41931:         item.IsWhitespace(aState))
29501:       return NS_OK;
29501: 
29501:     return ConstructTextFrame(item.mFCData, aState, item.mContent,
25768:                               adjParentFrame, styleContext,
26208:                               aFrameItems);
23955:   }
    1: 
    1:   // Start background loads during frame construction. This is just
    1:   // a hint; the paint code will do the right thing in any case.
    1:   {
    1:     styleContext->GetStyleBackground();
    1:   }
    1: 
25768:   nsFrameState savedStateBits = aState.mAdditionalStateBits;
29501:   if (item.mIsGeneratedContent) {
25768:     // Ensure that frames created here are all tagged with
25768:     // NS_FRAME_GENERATED_CONTENT.
25768:     aState.mAdditionalStateBits |= NS_FRAME_GENERATED_CONTENT;
25768: 
26208:     // Note that we're not necessarily setting this property on the primary
26208:     // frame for the content for which this is generated content.  We might be
26208:     // setting it on a table pseudo-frame inserted under that instead.  That's
26208:     // OK, though; we just need to do the property set so that the content will
26208:     // get cleaned up when the frame is destroyed.
39965:     aParentFrame->Properties().Set(GenConPseudoToProperty(styleContext->GetPseudo()),
39965:                                    item.mContent);
29501: 
29501:     // Now that we've passed ownership of item.mContent to the frame, unset
25768:     // our generated content flag so we don't release or unbind it ourselves.
29501:     item.mIsGeneratedContent = PR_FALSE;
25768:   }
25768: 
25769:   // XXXbz maybe just inline ConstructFrameFromItemInternal here or something?
29501:   nsresult rv = ConstructFrameFromItemInternal(item, aState, adjParentFrame,
26208:                                                aFrameItems);
25649: 
25768:   aState.mAdditionalStateBits = savedStateBits;
25649: 
25649:   return rv;
    1: }
    1: 
    1: 
    1: inline PRBool
    1: IsRootBoxFrame(nsIFrame *aFrame)
    1: {
    1:   return (aFrame->GetType() == nsGkAtoms::rootFrame);
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ReconstructDocElementHierarchy()
    1: {
41634:   return RecreateFramesForContent(mPresShell->GetDocument()->GetRootElement(),
41634: 				  PR_FALSE);
28215: }
    1: 
    1: nsIFrame*
    1: nsCSSFrameConstructor::GetFrameFor(nsIContent* aContent)
    1: {
    1:   // Get the primary frame associated with the content
36656:   nsIFrame* frame = aContent->GetPrimaryFrame();
    1: 
    1:   if (!frame)
    1:     return nsnull;
    1: 
47150:   // If the content of the frame is not the desired content then this is not
47150:   // really a frame for the desired content.
47150:   // XXX This check is needed due to bug 135040. Remove it once that's fixed.
47150:   if (frame->GetContent() != aContent) {
47150:     return nsnull;
47150:   }
47150: 
    1:   nsIFrame* insertionFrame = frame->GetContentInsertionFrame();
    1: 
    1:   NS_ASSERTION(insertionFrame == frame || !frame->IsLeaf(),
    1:     "The insertion frame is the primary frame or the primary frame isn't a leaf");
    1: 
    1:   return insertionFrame;
    1: }
    1: 
    1: nsIFrame*
    1: nsCSSFrameConstructor::GetAbsoluteContainingBlock(nsIFrame* aFrame)
    1: {
24659:   NS_PRECONDITION(nsnull != mRootElementFrame, "no root element frame");
    1:   
    1:   // Starting with aFrame, look for a frame that is absolutely positioned or
    1:   // relatively positioned
    1:   nsIFrame* containingBlock = nsnull;
    1:   for (nsIFrame* frame = aFrame; frame && !containingBlock;
    1:        frame = frame->GetParent()) {
    1:     if (frame->IsFrameOfType(nsIFrame::eMathML)) {
    1:       // If it's mathml, bail out -- no absolute positioning out from inside
    1:       // mathml frames.  Note that we don't make this part of the loop
20147:       // condition because of the stuff at the end of this method...
    1:       return nsnull;
    1:     }
    1:     
    1:     // Is it positioned?
    1:     // If it's table-related then ignore it, because for the time
    1:     // being table-related frames are not containers for absolutely
    1:     // positioned child frames.
    1:     const nsStyleDisplay* disp = frame->GetStyleDisplay();
    1: 
26208:     if (disp->IsPositioned() && !IsTableRelated(frame->GetType())) {
    1:       // Find the outermost wrapped block under this frame
    1:       for (nsIFrame* wrappedFrame = aFrame; wrappedFrame != frame->GetParent();
    1:            wrappedFrame = wrappedFrame->GetParent()) {
    1:         nsIAtom* frameType = wrappedFrame->GetType();
23176:         if (nsGkAtoms::blockFrame == frameType ||
23176: #ifdef MOZ_XUL
23176:             nsGkAtoms::XULLabelFrame == frameType ||
23176: #endif
    1:             nsGkAtoms::positionedInlineFrame == frameType) {
    1:           containingBlock = wrappedFrame;
    1:         } else if (nsGkAtoms::fieldSetFrame == frameType) {
    1:           // If the positioned frame is a fieldset, use the area frame inside it.
    1:           // We don't use GetContentInsertionFrame for fieldsets yet.
23176:           containingBlock = GetFieldSetBlockFrame(wrappedFrame);
    1:         }
    1:       }
    1: 
    1: #ifdef DEBUG
    1:       if (!containingBlock)
    1:         NS_WARNING("Positioned frame that does not handle positioned kids; looking further up the parent chain");
    1: #endif
    1:     }
    1:   }
    1: 
 7680:   // If we found an absolutely positioned containing block, then use the
 7680:   // first-continuation.
    1:   if (containingBlock)
 7680:     return AdjustAbsoluteContainingBlock(containingBlock);
    1: 
18953:   // If we didn't find it, then use the document element containing block
18953:   return mHasRootAbsPosContainingBlock ? mDocElementContainingBlock : nsnull;
    1: }
    1: 
    1: nsIFrame*
    1: nsCSSFrameConstructor::GetFloatContainingBlock(nsIFrame* aFrame)
    1: {
    1:   // Starting with aFrame, look for a frame that is a float containing block.
    1:   // IF we hit a mathml frame, bail out; we don't allow floating out of mathml
    1:   // frames, because they don't seem to be able to deal.
23352:   // The logic here needs to match the logic in ProcessChildren()
    1:   for (nsIFrame* containingBlock = aFrame;
 2192:        containingBlock && !containingBlock->IsFrameOfType(nsIFrame::eMathML) &&
 2192:        !containingBlock->IsBoxFrame();
    1:        containingBlock = containingBlock->GetParent()) {
    1:     if (containingBlock->IsFloatContainingBlock()) {
    1:       return containingBlock;
    1:     }
    1:   }
    1: 
    1:   // If we didn't find a containing block, then there just isn't
    1:   // one.... return null
    1:   return nsnull;
    1: }
    1: 
    1: /**
    1:  * This function will check whether aContainer has :after generated content.
    1:  * If so, appending to it should actually insert.  The return value is the
    1:  * parent to use for newly-appended content.  *aAfterFrame points to the :after
    1:  * frame before which appended content should go, if there is one.
    1:  */
    1: static nsIFrame*
    1: AdjustAppendParentForAfterContent(nsPresContext* aPresContext,
    1:                                   nsIContent* aContainer,
    1:                                   nsIFrame* aParentFrame,
    1:                                   nsIFrame** aAfterFrame)
    1: {
    1:   // See if the parent has an :after pseudo-element.  Check for the presence
    1:   // of style first, since nsLayoutUtils::GetAfterFrame is sorta expensive.
    1:   nsStyleContext* parentStyle = aParentFrame->GetStyleContext();
    1:   if (nsLayoutUtils::HasPseudoStyle(aContainer, parentStyle,
35554:                                     nsCSSPseudoElements::ePseudo_after,
    1:                                     aPresContext)) {
    1:     nsIFrame* afterFrame = nsLayoutUtils::GetAfterFrame(aParentFrame);
    1:     if (afterFrame) {
    1:       *aAfterFrame = afterFrame;
    1:       return afterFrame->GetParent();
    1:     }
    1:   }
    1: 
    1:   *aAfterFrame = nsnull;
34462: 
34462:   if (IsFrameSpecial(aParentFrame)) {
34462:     // We might be in a situation where the last part of the {ib} split was
34462:     // empty.  Since we have no ::after pseudo-element, we do in fact want to be
34462:     // appending to that last part, so advance to it if needed.  Note that here
34462:     // aParentFrame is the result of a GetLastSpecialSibling call, so must be
34462:     // either the last or next to last special sibling.
34462:     nsIFrame* trailingInline = GetSpecialSibling(aParentFrame);
34462:     if (trailingInline) {
34996:       aParentFrame = trailingInline;
34996:     }
34996: 
34996:     // Always make sure to look at the last continuation of the frame
34996:     // for the {ib} case, even if that continuation is empty.  We
34996:     // don't do this for the non-special-frame case, since in the
34996:     // other cases appending to the last nonempty continuation is fine
34996:     // and in fact not doing that can confuse code that doesn't know
34996:     // to pull kids from continuations other than its next one.
34996:     aParentFrame = aParentFrame->GetLastContinuation();
34462:   }
34462: 
    1:   return aParentFrame;
    1: }
    1: 
    1: /**
27310:  * This function will get the previous sibling to use for an append operation.
27310:  * it takes a parent frame (must not be null) and its :after frame (may be
27310:  * null).
27310:  */
27310: static nsIFrame*
27310: FindAppendPrevSibling(nsIFrame* aParentFrame, nsIFrame* aAfterFrame)
27310: {
30827:   if (aAfterFrame) {
27310:     NS_ASSERTION(aAfterFrame->GetParent() == aParentFrame, "Wrong parent");
33388:     return aAfterFrame->GetPrevSibling();
27310:   }
27310: 
30827:   return aParentFrame->GetLastChild(nsnull);
27310: }
27310: 
27310: /**
27310:  * This function will get the next sibling for a frame insert operation given
27310:  * the parent and previous sibling.  aPrevSibling may be null.
27310:  */
27310: static nsIFrame*
27310: GetInsertNextSibling(nsIFrame* aParentFrame, nsIFrame* aPrevSibling)
27310: {
27310:   if (aPrevSibling) {
27310:     return aPrevSibling->GetNextSibling();
27310:   }
27310: 
27310:   return aParentFrame->GetFirstChild(nsnull);
27310: }
27310: 
27310: /**
27310:  * This function is called by ContentAppended() and ContentInserted() when
27310:  * appending flowed frames to a parent's principal child list. It handles the
34462:  * case where the parent is the trailing inline of an {ib} split.
    1:  */
    1: nsresult
 4696: nsCSSFrameConstructor::AppendFrames(nsFrameConstructorState&       aState,
    1:                                     nsIFrame*                      aParentFrame,
 4696:                                     nsFrameItems&                  aFrameList,
36623:                                     nsIFrame*                      aPrevSibling,
36623:                                     PRBool                         aIsRecursiveCall)
27310: {
27310:   NS_PRECONDITION(!IsFrameSpecial(aParentFrame) ||
27310:                   !GetSpecialSibling(aParentFrame) ||
27310:                   !GetSpecialSibling(aParentFrame)->GetFirstChild(nsnull),
27310:                   "aParentFrame has a special sibling with kids?");
27310:   NS_PRECONDITION(!aPrevSibling || aPrevSibling->GetParent() == aParentFrame,
27310:                   "Parent and prevsibling don't match");
27310: 
27310:   nsIFrame* nextSibling = ::GetInsertNextSibling(aParentFrame, aPrevSibling);
27310: 
27310:   NS_ASSERTION(nextSibling ||
27310:                !aParentFrame->GetNextContinuation() ||
36623:                !aParentFrame->GetNextContinuation()->GetFirstChild(nsnull) ||
36623:                aIsRecursiveCall,
27310:                "aParentFrame has later continuations with kids?");
34462:   NS_ASSERTION(nextSibling ||
34462:                !IsFrameSpecial(aParentFrame) ||
34462:                (IsInlineFrame(aParentFrame) &&
34462:                 !GetSpecialSibling(aParentFrame) &&
36623:                 !aParentFrame->GetNextContinuation()) ||
36623:                aIsRecursiveCall,
34462:                "aParentFrame is not last?");
34462: 
34462:   // If we're inserting a list of frames at the end of the trailing inline
34462:   // of an {ib} split, we may need to create additional {ib} siblings to parent
34462:   // them.
34462:   if (!nextSibling && IsFrameSpecial(aParentFrame)) {
35611:     // When we get here, our frame list might start with a block.  If it does
35611:     // so, and aParentFrame is an inline, and it and all its previous
35611:     // continuations have no siblings, then put the initial blocks from the
35611:     // frame list into the previous block of the {ib} split.  Note that we
35611:     // didn't want to stop at the block part of the split when figuring out
35611:     // initial parent, because that could screw up float parenting; it's easier
35611:     // to do this little fixup here instead.
35611:     if (aFrameList.NotEmpty() && !IsInlineOutside(aFrameList.FirstChild())) {
36624:       // See whether our trailing inline is empty
35611:       nsIFrame* firstContinuation = aParentFrame->GetFirstContinuation();
35611:       if (firstContinuation->GetChildList(nsnull).IsEmpty()) {
35611:         // Our trailing inline is empty.  Collect our starting blocks from
35611:         // aFrameList, get the right parent frame for them, and put them in.
35611:         nsFrameList::FrameLinkEnumerator firstNonBlockEnumerator =
35611:           FindFirstNonBlock(aFrameList);
35611:         nsFrameList blockKids = aFrameList.ExtractHead(firstNonBlockEnumerator);
35611:         NS_ASSERTION(blockKids.NotEmpty(), "No blocks?");
35611: 
35611:         nsIFrame* prevBlock =
35611:           GetSpecialPrevSibling(firstContinuation)->GetLastContinuation();
35611:         NS_ASSERTION(prevBlock, "Should have previous block here");
35611: 
35611:         MoveChildrenTo(aState.mPresContext, aParentFrame, prevBlock, blockKids);
35611:       }
35611:     }
35611: 
34462:     // We want to put some of the frames into this inline frame.
34462:     nsFrameList::FrameLinkEnumerator firstBlockEnumerator(aFrameList);
34462:     FindFirstBlock(firstBlockEnumerator);
34462: 
34462:     nsFrameList inlineKids = aFrameList.ExtractHead(firstBlockEnumerator);
34462:     if (!inlineKids.IsEmpty()) {
34462:       aState.mFrameManager->AppendFrames(aParentFrame, nsnull, inlineKids);
34462:     }
34462: 
34462:     if (!aFrameList.IsEmpty()) {
34462:       const nsStyleDisplay* parentDisplay = aParentFrame->GetStyleDisplay();
34462:       PRBool positioned =
34462:         parentDisplay->mPosition == NS_STYLE_POSITION_RELATIVE ||
34462:         parentDisplay->HasTransform();
34462:       nsFrameItems ibSiblings;
34462:       CreateIBSiblings(aState, aParentFrame, positioned, aFrameList,
34462:                        ibSiblings);
34462: 
34462:       // Make sure to trigger reflow of the inline that used to be our
34462:       // last one and now isn't anymore, since its GetSkipSides() has
34462:       // changed.
34462:       mPresShell->FrameNeedsReflow(aParentFrame,
34462:                                    nsIPresShell::eTreeChange,
34462:                                    NS_FRAME_HAS_DIRTY_CHILDREN);
34462: 
35612:       // Recurse so we create new ib siblings as needed for aParentFrame's parent
35612:       return AppendFrames(aState, aParentFrame->GetParent(), ibSiblings,
36623:                           aParentFrame, PR_TRUE);
34462:     }
34462: 
 4696:     return NS_OK;
 4696:   }
 4696:   
36623:   // Insert the frames after our aPrevSibling
27310:   return aState.mFrameManager->InsertFrames(aParentFrame, nsnull, aPrevSibling,
30941:                                             aFrameList);
    1: }
    1: 
 7655: #define UNSET_DISPLAY 255
 7655: 
40939: // This gets called to see if the frames corresponding to aSibling and aContent
40939: // should be siblings in the frame tree. Although (1) rows and cols, (2) row
40939: // groups and col groups, (3) row groups and captions, (4) legends and content
40939: // inside fieldsets, (5) popups and other kids of the menu are siblings from a
40939: // content perspective, they are not considered siblings in the frame tree.
    1: PRBool
 7655: nsCSSFrameConstructor::IsValidSibling(nsIFrame*              aSibling,
 7655:                                       nsIContent*            aContent,
    1:                                       PRUint8&               aDisplay)
    1: {
 8009:   nsIFrame* parentFrame = aSibling->GetParent();
 8009:   nsIAtom* parentType = nsnull;
 8009:   nsIAtom* grandparentType = nsnull;
 8009:   if (parentFrame) {
 8009:     parentType = parentFrame->GetType();
 8009:     nsIFrame* grandparentFrame = parentFrame->GetParent();
 8009:     if (grandparentFrame) {
 8009:       grandparentType = grandparentFrame->GetType();
 8009:     }
 8009:   }
 8009:     
 7655:   PRUint8 siblingDisplay = aSibling->GetStyleDisplay()->mDisplay;
 7655:   if ((NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_COLUMN       == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_CAPTION      == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_ROW_GROUP    == siblingDisplay) ||
 7655:       (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == siblingDisplay) ||
 7655:       nsGkAtoms::menuFrame == parentType) {
    1:     // if we haven't already, construct a style context to find the display type of aContent
    1:     if (UNSET_DISPLAY == aDisplay) {
    1:       nsRefPtr<nsStyleContext> styleContext;
 1502:       nsIFrame* styleParent;
 1502:       PRBool providerIsChild;
 1502:       if (NS_FAILED(aSibling->
 1502:                       GetParentStyleContextFrame(aSibling->PresContext(),
 1502:                                                  &styleParent,
 1502:                                                  &providerIsChild)) ||
 1502:           !styleParent) {
 1502:         NS_NOTREACHED("Shouldn't happen");
 1502:         return PR_FALSE;
 1502:       }
 7655:       styleContext = ResolveStyleContext(styleParent, aContent);
    1:       if (!styleContext) return PR_FALSE;
    1:       const nsStyleDisplay* display = styleContext->GetStyleDisplay();
    1:       aDisplay = display->mDisplay;
    1:     }
 7655:     if (nsGkAtoms::menuFrame == parentType) {
 7655:       return
 7655:         (NS_STYLE_DISPLAY_POPUP == aDisplay) ==
 7655:         (NS_STYLE_DISPLAY_POPUP == siblingDisplay);
 7655:     }
34953:     // To have decent performance we want to return false in cases in which
34953:     // reordering the two siblings has no effect on display.  To ensure
34953:     // correctness, we MUST return false in cases where the two siblings have
34953:     // the same desired parent type and live on different display lists.
34953:     // Specificaly, columns and column groups should only consider columns and
34953:     // column groups as valid siblings.  Captions should only consider other
34953:     // captions.  All other things should consider each other as valid
34953:     // siblings.  The restriction in the |if| above on siblingDisplay is ok,
34953:     // because for correctness the only part that really needs to happen is to
34953:     // not consider captions, column groups, and row/header/footer groups
34953:     // siblings of each other.  Treating a column or colgroup as a valid
34953:     // sibling of a non-table-related frame will just mean we end up reframing.
34953:     if ((siblingDisplay == NS_STYLE_DISPLAY_TABLE_CAPTION) !=
34953:         (aDisplay == NS_STYLE_DISPLAY_TABLE_CAPTION)) {
34953:       // One's a caption and the other is not.  Not valid siblings.
34953:       return PR_FALSE;
34953:     }
34953: 
34953:     if ((siblingDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP ||
34953:          siblingDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN) !=
34953:         (aDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP ||
34953:          aDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN)) {
34953:       // One's a column or column group and the other is not.  Not valid
34953:       // siblings.
34953:       return PR_FALSE;
34953:     }
34953: 
34953:     return PR_TRUE;
    1:   }
 8009:   else if (nsGkAtoms::fieldSetFrame == parentType ||
 8009:            (nsGkAtoms::fieldSetFrame == grandparentType &&
23176:             nsGkAtoms::blockFrame == parentType)) {
    1:     // Legends can be sibling of legends but not of other content in the fieldset
 1502:     nsIAtom* sibType = aSibling->GetType();
 7655:     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(aContent));
    1: 
    1:     if ((legendContent  && (nsGkAtoms::legendFrame != sibType)) ||
    1:         (!legendContent && (nsGkAtoms::legendFrame == sibType)))
    1:       return PR_FALSE;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
 7655: nsIFrame*
 7655: nsCSSFrameConstructor::FindFrameForContentSibling(nsIContent* aContent,
 7655:                                                   nsIContent* aTargetContent,
 7655:                                                   PRUint8& aTargetContentDisplay,
 7655:                                                   PRBool aPrevSibling)
 7655: {
36656:   nsIFrame* sibling = aContent->GetPrimaryFrame();
34147:   if (!sibling || sibling->GetContent() != aContent) {
34147:     // XXX the GetContent() != aContent check is needed due to bug 135040.
34147:     // Remove it once that's fixed.
 7655:     return nsnull;
 7655:   }
 7655: 
36656:   // If the frame is out-of-flow, GetPrimaryFrame() will have returned the
 7655:   // out-of-flow frame; we want the placeholder.
 7655:   if (sibling->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
39668:     nsIFrame* placeholderFrame = mPresShell->FrameManager()->GetPlaceholderFrameFor(sibling);
 7655:     NS_ASSERTION(placeholderFrame, "no placeholder for out-of-flow frame");
 7655:     sibling = placeholderFrame;
 7655:   }
 7655: 
 8406:   // The frame we have now should never be a continuation
 8406:   NS_ASSERTION(!sibling->GetPrevContinuation(), "How did that happen?");
 7655: 
 7655:   if (aPrevSibling) {
 7655:     // The frame may be a special frame (a split inline frame that
 7655:     // contains a block).  Get the last part of that split.
 7655:     if (IsFrameSpecial(sibling)) {
34462:       sibling = GetLastSpecialSibling(sibling, PR_TRUE);
 7655:     }
 7655: 
 7655:     // The frame may have a continuation. If so, we want the last
 7655:     // non-overflow-container continuation as our previous sibling.
10780:     sibling = sibling->GetTailContinuation();
 7655:   }
 7655: 
 7655:   if (aTargetContent &&
 7655:       !IsValidSibling(sibling, aTargetContent, aTargetContentDisplay)) {
 7655:     sibling = nsnull;
 7655:   }
 7655: 
 7655:   return sibling;
 7655: }
 7655: 
    1: nsIFrame*
24404: nsCSSFrameConstructor::FindPreviousSibling(const ChildIterator& aFirst,
40939:                                            ChildIterator aIter,
40939:                                            PRUint8& aTargetContentDisplay)
24404: {
24404:   nsIContent* child = *aIter;
    1: 
    1:   // Note: not all content objects are associated with a frame (e.g., if it's
 7655:   // `display: none') so keep looking until we find a previous frame
47662:   while (aIter != aFirst) {
47662:     --aIter;
 7655:     nsIFrame* prevSibling =
40939:       FindFrameForContentSibling(*aIter, child, aTargetContentDisplay, PR_TRUE);
    1: 
    1:     if (prevSibling) {
    1:       // Found a previous sibling, we're done!
    1:       return prevSibling;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsIFrame*
24404: nsCSSFrameConstructor::FindNextSibling(ChildIterator aIter,
40939:                                        const ChildIterator& aLast,
40939:                                        PRUint8& aTargetContentDisplay)
24404: {
24404:   if (aIter == aLast) {
24404:     // XXXbz Can happen when XBL lies to us about insertion points.  This check
24404:     // might be able to go away once bug 474324 is fixed.
    1:     return nsnull;
24404:   }
24404: 
24404:   nsIContent* child = *aIter;
    1: 
24404:   while (++aIter != aLast) {
    1:     nsIFrame* nextSibling =
40939:       FindFrameForContentSibling(*aIter, child, aTargetContentDisplay, PR_FALSE);
    1: 
    1:     if (nextSibling) {
    1:       // We found a next sibling, we're done!
    1:       return nextSibling;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // For fieldsets, returns the area frame, if the child is not a legend. 
    1: static nsIFrame*
    1: GetAdjustedParentFrame(nsIFrame*       aParentFrame,
    1:                        nsIAtom*        aParentFrameType,
24404:                        nsIContent*     aChildContent)
    1: {
 4194:   NS_PRECONDITION(nsGkAtoms::tableOuterFrame != aParentFrameType,
 4194:                   "Shouldn't be happening!");
 4194:   
    1:   nsIFrame* newParent = nsnull;
    1: 
 4194:   if (nsGkAtoms::fieldSetFrame == aParentFrameType) {
    1:     // If the parent is a fieldSet, use the fieldSet's area frame as the
    1:     // parent unless the new content is a legend. 
24404:     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(aChildContent));
    1:     if (!legendContent) {
23176:       newParent = GetFieldSetBlockFrame(aParentFrame);
    1:     }
    1:   }
    1:   return (newParent) ? newParent : aParentFrame;
    1: }
    1: 
27696: nsIFrame*
27696: nsCSSFrameConstructor::GetInsertionPrevSibling(nsIFrame*& aParentFrame,
27696:                                                nsIContent* aContainer,
27696:                                                nsIContent* aChild,
40939:                                                PRBool* aIsAppend,
40939:                                                PRBool* aIsRangeInsertSafe,
40939:                                                nsIContent* aStartSkipChild,
40939:                                                nsIContent* aEndSkipChild)
40939: {
27696:   *aIsAppend = PR_FALSE;
27696: 
27696:   // Find the frame that precedes the insertion point. Walk backwards
27696:   // from the parent frame to get the parent content, because if an
27696:   // XBL insertion point is involved, we'll need to use _that_ to find
27696:   // the preceding frame.
27696: 
27696:   NS_PRECONDITION(aParentFrame, "Must have parent frame to start with");
27696:   nsIContent* container = aParentFrame->GetContent();
27696: 
27696:   ChildIterator first, last;
27696:   ChildIterator::Init(container, &first, &last);
27696:   ChildIterator iter(first);
47662:   PRBool xblCase = iter.XBLInvolved() || container != aContainer;
47662:   if (xblCase || !aChild->IsRootOfAnonymousSubtree()) {
47662:     // The check for IsRootOfAnonymousSubtree() is because editor is
47662:     // severely broken and calls us directly for native anonymous
47662:     // nodes that it creates.
40939:     if (aStartSkipChild) {
40939:       iter.seek(aStartSkipChild);
40939:     } else {
27696:       iter.seek(aChild);
40939:     }
47662:   }
27696: #ifdef DEBUG
27696:   else {
27696:     NS_WARNING("Someone passed native anonymous content directly into frame "
27696:                "construction.  Stop doing that!");
27696:   }
27696: #endif
27696: 
40939:   PRUint8 childDisplay = UNSET_DISPLAY;
40939:   nsIFrame* prevSibling = FindPreviousSibling(first, iter, childDisplay);
27696: 
27696:   // Now, find the geometric parent so that we can handle
27696:   // continuations properly. Use the prev sibling if we have it;
27696:   // otherwise use the next sibling.
27696:   if (prevSibling) {
27696:     aParentFrame = prevSibling->GetParent()->GetContentInsertionFrame();
27696:   }
27696:   else {
27696:     // If there is no previous sibling, then find the frame that follows
40939:     if (aEndSkipChild) {
40939:       iter.seek(aEndSkipChild);
40939:       iter--;
40939:     }
40939:     nsIFrame* nextSibling = FindNextSibling(iter, last, childDisplay);
27696: 
27696:     if (nextSibling) {
27696:       aParentFrame = nextSibling->GetParent()->GetContentInsertionFrame();
27696:     }
27696:     else {
27696:       // No previous or next sibling, so treat this like an appended frame.
27696:       *aIsAppend = PR_TRUE;
27696:       if (IsFrameSpecial(aParentFrame)) {
27696:         // Since we're appending, we'll walk to the last anonymous frame
27696:         // that was created for the broken inline frame.  But don't walk
27696:         // to the trailing inline if it's empty; stop at the block.
34462:         aParentFrame = GetLastSpecialSibling(aParentFrame, PR_FALSE);
27696:       }
27696:       // Get continuation that parents the last child.  This MUST be done
27696:       // before the AdjustAppendParentForAfterContent call.
27696:       aParentFrame = nsLayoutUtils::GetLastContinuationWithChild(aParentFrame);
27696:       // Deal with fieldsets
27696:       aParentFrame = ::GetAdjustedParentFrame(aParentFrame,
27696:                                               aParentFrame->GetType(),
27696:                                               aChild);
27696:       nsIFrame* appendAfterFrame;
27696:       aParentFrame =
27696:         ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
27696:                                             container, aParentFrame,
27696:                                             &appendAfterFrame);
27696:       prevSibling = ::FindAppendPrevSibling(aParentFrame, appendAfterFrame);
27696:     }
27696:   }
27696: 
40939:   *aIsRangeInsertSafe = (childDisplay == UNSET_DISPLAY);
27696:   return prevSibling;
27696: }
27696: 
    1: static PRBool
    1: IsSpecialFramesetChild(nsIContent* aContent)
    1: {
    1:   // IMPORTANT: This must match the conditions in nsHTMLFramesetFrame::Init.
33329:   return aContent->IsHTML() &&
    1:     (aContent->Tag() == nsGkAtoms::frameset ||
    1:      aContent->Tag() == nsGkAtoms::frame);
    1: }
    1: 
28215: static void
28215: InvalidateCanvasIfNeeded(nsIPresShell* presShell, nsIContent* node);
28215: 
28865: #ifdef MOZ_XUL
28865: 
28865: static
40939: PRBool
40939: IsXULListBox(nsIContent* aContainer)
40939: {
40939:   return (aContainer->IsXUL() && aContainer->Tag() == nsGkAtoms::listbox);
40939: }
40939: 
40939: static
28865: nsListBoxBodyFrame*
28865: MaybeGetListBoxBodyFrame(nsIContent* aContainer, nsIContent* aChild)
28865: {
28865:   if (!aContainer)
28865:     return nsnull;
28865: 
40939:   if (IsXULListBox(aContainer) &&
40939:       aChild->IsXUL() && aChild->Tag() == nsGkAtoms::listitem) {
28865:     nsCOMPtr<nsIDOMXULElement> xulElement = do_QueryInterface(aContainer);
28865:     nsCOMPtr<nsIBoxObject> boxObject;
28865:     xulElement->GetBoxObject(getter_AddRefs(boxObject));
28865:     nsCOMPtr<nsPIListBoxObject> listBoxObject = do_QueryInterface(boxObject);
28865:     if (listBoxObject) {
28865:       return listBoxObject->GetListBoxBody(PR_FALSE);
28865:     }
28865:   }
28865: 
28865:   return nsnull;
28865: }
28865: #endif
28865: 
29501: void
29525: nsCSSFrameConstructor::AddTextItemIfNeeded(nsFrameConstructorState& aState,
29525:                                            nsIFrame* aParentFrame,
47665:                                            nsIContent* aPossibleTextContent,
29501:                                            FrameConstructionItemList& aItems)
29501: {
47665:   NS_PRECONDITION(aPossibleTextContent, "Must have node");
47665:   if (!aPossibleTextContent->IsNodeOfType(nsINode::eTEXT) ||
47665:       !aPossibleTextContent->HasFlag(NS_CREATE_FRAME_IF_NON_WHITESPACE)) {
29501:     // Not text, or not suppressed due to being all-whitespace (if it
29809:     // were being suppressed, it would have the
29809:     // NS_CREATE_FRAME_IF_NON_WHITESPACE flag)
29501:     return;
29501:   }
47665:   NS_ASSERTION(!aPossibleTextContent->GetPrimaryFrame(),
29809:                "Text node has a frame and NS_CREATE_FRAME_IF_NON_WHITESPACE");
47665:   AddFrameConstructionItems(aState, aPossibleTextContent, PR_FALSE,
47665:                             aParentFrame, aItems);
29501: }
29501: 
29501: void
29501: nsCSSFrameConstructor::ReframeTextIfNeeded(nsIContent* aParentContent,
47669:                                            nsIContent* aContent)
47669: {
47669:   if (!aContent->IsNodeOfType(nsINode::eTEXT) ||
47669:       !aContent->HasFlag(NS_CREATE_FRAME_IF_NON_WHITESPACE)) {
29501:     // Not text, or not suppressed due to being all-whitespace (if it
29809:     // were being suppressed, it would have the
29809:     // NS_CREATE_FRAME_IF_NON_WHITESPACE flag)
29501:     return;
29501:   }
47669:   NS_ASSERTION(!aContent->GetPrimaryFrame(),
29809:                "Text node has a frame and NS_CREATE_FRAME_IF_NON_WHITESPACE");
47669:   ContentInserted(aParentContent, aContent, nsnull, PR_FALSE);
40938: }
40938: 
41675: // We want to disable lazy frame construction for nodes that are under an
41675: // editor. We use nsINode::IsEditable, but that includes inputs with type text
41675: // and password and textareas, which are common and aren't really editable (the
41675: // native anonymous content under them is what is actually editable) so we want
41675: // to construct frames for those lazily.
41675: // The logic for this check is based on
41675: // nsGenericHTMLFormElement::UpdateEditableFormControlState and so must be kept
41675: // in sync with that. The presence of the NODE_MAY_HAVE_CONTENT_EDITABLE_ATTR
41675: // flag only indicates a contenteditable attribute, it doesn't indicate if it
41675: // is true or false, so we force eager construction in some cases when the node
41675: // is not editable, but that should be rare.
41675: static inline PRBool
41675: IsActuallyEditable(nsIContent* aContainer, nsIContent* aChild)
41675: {
41675:   return (aChild->IsEditable() &&
41675:           (aContainer->IsEditable() ||
41675:            aChild->HasFlag(NODE_MAY_HAVE_CONTENT_EDITABLE_ATTR)));
41675: }
41675: 
40938: // For inserts aChild should be valid, for appends it should be null.
40938: // Returns true if this operation can be lazy, false if not.
40938: PRBool
40938: nsCSSFrameConstructor::MaybeConstructLazily(Operation aOperation,
40938:                                             nsIContent* aContainer,
47659:                                             nsIContent* aChild)
40938: {
40938:   if (mPresShell->GetPresContext()->IsChrome() || !aContainer ||
40938:       aContainer->IsInNativeAnonymousSubtree() || aContainer->IsXUL()) {
40938:     return PR_FALSE;
40938:   }
40938: 
40938:   if (aOperation == CONTENTINSERT) {
47659:     if (aChild->IsRootOfAnonymousSubtree() ||
41675:         aChild->IsXUL() || IsActuallyEditable(aContainer, aChild)) {
40938:       return PR_FALSE;
40938:     }
40938:   } else { // CONTENTAPPEND
40938:     NS_ASSERTION(aOperation == CONTENTAPPEND,
40938:                  "operation should be either insert or append");
47659:     for (nsIContent* child = aChild; child; child = child->GetNextSibling()) {
47659:       NS_ASSERTION(!child->IsRootOfAnonymousSubtree(),
47659:                    "Should be coming through the CONTENTAPPEND case");
41675:       if (child->IsXUL() || IsActuallyEditable(aContainer, child)) {
40938:         return PR_FALSE;
40938:       }
40938:     }
40938:   }
40938: 
40938:   // We can construct lazily; just need to set suitable bits in the content
40938:   // tree.
40938: 
40938:   // Walk up the tree setting the NODE_DESCENDANTS_NEED_FRAMES bit as we go.
40938:   nsIContent* content = aContainer;
42284: #ifdef DEBUG
42558:   // If we hit a node with no primary frame, or the NODE_NEEDS_FRAME bit set
42558:   // we want to assert, but leaf frames that process their own children and may
42558:   // ignore anonymous children (eg framesets) make this complicated. So we set
42558:   // these two booleans if we encounter these situations and unset them if we
42558:   // hit a node with a leaf frame.
42558:   PRBool noPrimaryFrame = PR_FALSE;
42558:   PRBool needsFrameBitSet = PR_FALSE;
42284: #endif
40938:   while (content &&
40938:          !content->HasFlag(NODE_DESCENDANTS_NEED_FRAMES)) {
42284: #ifdef DEBUG
42558:     if (content->GetPrimaryFrame() && content->GetPrimaryFrame()->IsLeaf()) {
42558:       noPrimaryFrame = needsFrameBitSet = PR_FALSE;
42558:     }
47150:     if (!noPrimaryFrame && !content->GetPrimaryFrame()) {
42558:       noPrimaryFrame = PR_TRUE;
42558:     }
47150:     if (!needsFrameBitSet && content->HasFlag(NODE_NEEDS_FRAME)) {
42558:       needsFrameBitSet = PR_TRUE;
42558:     }
42284: #endif
40938:     content->SetFlags(NODE_DESCENDANTS_NEED_FRAMES);
40938:     content = content->GetFlattenedTreeParent();
40938:   }
42558: #ifdef DEBUG
42558:   if (content && content->GetPrimaryFrame() &&
42558:       content->GetPrimaryFrame()->IsLeaf()) {
42558:     noPrimaryFrame = needsFrameBitSet = PR_FALSE;
42558:   }
42558:   NS_ASSERTION(!noPrimaryFrame, "Ancestors of nodes with frames to be "
42558:     "constructed lazily should have frames");
42558:   NS_ASSERTION(!needsFrameBitSet, "Ancestors of nodes with frames to be "
42558:     "constructed lazily should not have NEEDS_FRAME bit set");
42558: #endif
40938: 
40938:   // Set NODE_NEEDS_FRAME on the new nodes.
40938:   if (aOperation == CONTENTINSERT) {
41678:     NS_ASSERTION(!aChild->GetPrimaryFrame() ||
41678:                  aChild->GetPrimaryFrame()->GetContent() != aChild,
41678:                  //XXX the aChild->GetPrimaryFrame()->GetContent() != aChild
41678:                  // check is needed due to bug 135040. Remove it once that's
41678:                  // fixed.
40938:                  "setting NEEDS_FRAME on a node that already has a frame?");
40938:     aChild->SetFlags(NODE_NEEDS_FRAME);
40938:   } else { // CONTENTAPPEND
47659:     for (nsIContent* child = aChild; child; child = child->GetNextSibling()) {
41678:       NS_ASSERTION(!child->GetPrimaryFrame() ||
41678:                    child->GetPrimaryFrame()->GetContent() != child,
41678:                    //XXX the child->GetPrimaryFrame()->GetContent() != child
41678:                    // check is needed due to bug 135040. Remove it once that's
41678:                    // fixed.
40938:                    "setting NEEDS_FRAME on a node that already has a frame?");
40938:       child->SetFlags(NODE_NEEDS_FRAME);
40938:     }
40938:   }
40938: 
40938:   PostRestyleEventInternal(PR_TRUE);
40938:   return PR_TRUE;
40938: }
40938: 
40938: void
40938: nsCSSFrameConstructor::CreateNeededFrames(nsIContent* aContent)
40938: {
40938:   NS_ASSERTION(!aContent->HasFlag(NODE_NEEDS_FRAME),
40938:     "shouldn't get here with a content node that has needs frame bit set");
40938:   NS_ASSERTION(aContent->HasFlag(NODE_DESCENDANTS_NEED_FRAMES),
40938:     "should only get here with a content node that has descendants needing frames");
40938: 
40938:   aContent->UnsetFlags(NODE_DESCENDANTS_NEED_FRAMES);
40938: 
40938:   // We could either descend first (on nodes that don't have NODE_NEEDS_FRAME
40938:   // set) or issue content notifications for our kids first. In absence of
40938:   // anything definitive either way we'll go with the latter.
40938: 
40938:   // It might be better to use GetChildArray and scan it completely first and
40938:   // then issue all notifications. (We have to scan it completely first because
40938:   // constructing frames can set attributes, which can change the storage of
40938:   // child lists).
40938: 
40938:   // Scan the children of aContent to see what operations (if any) we need to
40938:   // perform.
40938:   PRUint32 childCount = aContent->GetChildCount();
40938:   PRBool inRun = PR_FALSE;
40938:   nsIContent* firstChildInRun = nsnull;
40938:   for (PRUint32 i = 0; i < childCount; i++) {
40938:     nsIContent* child = aContent->GetChildAt(i);
40938:     if (child->HasFlag(NODE_NEEDS_FRAME)) {
41678:       NS_ASSERTION(!child->GetPrimaryFrame() ||
41678:                    child->GetPrimaryFrame()->GetContent() != child,
41678:                    //XXX the child->GetPrimaryFrame()->GetContent() != child
41678:                    // check is needed due to bug 135040. Remove it once that's
41678:                    // fixed.
40938:                    "NEEDS_FRAME set on a node that already has a frame?");
40938:       if (!inRun) {
40938:         inRun = PR_TRUE;
40938:         firstChildInRun = child;
40938:       }
40938:     } else {
40938:       if (inRun) {
40938:         inRun = PR_FALSE;
40939:         // generate a ContentRangeInserted for [startOfRun,i)
47667:         ContentRangeInserted(aContent, firstChildInRun, child, nsnull,
47667:                              PR_FALSE);
40938:       }
40938:     }
40938:   }
40938:   if (inRun) {
47668:     ContentAppended(aContent, firstChildInRun, PR_FALSE);
40938:   }
40938: 
40938:   // Now descend.
40938:   ChildIterator iter, last;
40938:   for (ChildIterator::Init(aContent, &iter, &last);
40938:        iter != last;
40938:        ++iter) {
40938:     nsIContent* child = *iter;
40938:     if (child->HasFlag(NODE_DESCENDANTS_NEED_FRAMES)) {
40938:       CreateNeededFrames(child);
40938:     }
40938:   }
40938: }
40938: 
40938: void nsCSSFrameConstructor::CreateNeededFrames()
40938: {
40938:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
40938:                "Someone forgot a script blocker");
40938: 
41634:   Element* rootElement = mDocument->GetRootElement();
41634:   NS_ASSERTION(!rootElement || !rootElement->HasFlag(NODE_NEEDS_FRAME),
41634:     "root element should not have frame created lazily");
41634:   if (rootElement && rootElement->HasFlag(NODE_DESCENDANTS_NEED_FRAMES)) {
40938:     BeginUpdate();
41634:     CreateNeededFrames(rootElement);
40938:     EndUpdate();
40938:   }
29501: }
29501: 
40939: void
40939: nsCSSFrameConstructor::IssueSingleInsertNofications(nsIContent* aContainer,
47667:                                                     nsIContent* aStartChild,
47667:                                                     nsIContent* aEndChild,
40938:                                                     PRBool aAllowLazyConstruction)
    1: {
47667:   for (nsIContent* child = aStartChild;
47667:        child != aEndChild;
47667:        child = child->GetNextSibling()) {
40939:     if ((child->GetPrimaryFrame() ||
40939:          mPresShell->FrameManager()->GetUndisplayedContent(child))
40939: #ifdef MOZ_XUL
40939:         //  Except listboxes suck, so do NOT skip anything here if
40939:         //  we plan to notify a listbox.
40939:         && !MaybeGetListBoxBodyFrame(aContainer, child)
40939: #endif
40939:         ) {
40939:       // Already have a frame or undisplayed entry for this content; a
40939:       // previous ContentInserted in this loop must have reconstructed
40939:       // its insertion parent.  Skip it.
40939:       continue;
40939:     }
47667:     // Call ContentInserted with this node.
47667:     ContentInserted(aContainer, child, mTempFrameTreeState,
40938:                     aAllowLazyConstruction);
40939:   }
40939: }
40939: 
40939: nsIFrame*
40939: nsCSSFrameConstructor::GetRangeInsertionPoint(nsIContent* aContainer,
40939:                                               nsIFrame* aParentFrame,
47664:                                               nsIContent* aStartChild,
47664:                                               nsIContent* aEndChild,
40939:                                               PRBool aAllowLazyConstruction)
40939: {
    1:   // See if we have an XBL insertion point. If so, then that's our
    1:   // real parent frame; if not, then the frame hasn't been built yet
    1:   // and we just bail.
    1:   nsIFrame* insertionPoint;
    1:   PRBool multiple = PR_FALSE;
40939:   GetInsertionPoint(aParentFrame, nsnull, &insertionPoint, &multiple);
    1:   if (! insertionPoint)
40939:     return nsnull; // Don't build the frames.
    1:  
    1:   PRBool hasInsertion = PR_FALSE;
    1:   if (!multiple) {
47664:     // XXXbz XBL2/sXBL issue
47664:     nsIDocument* document = aStartChild->GetDocument();
47664:     // XXXbz how would |document| be null here?
    1:     if (document &&
47664:         document->BindingManager()->GetInsertionParent(aStartChild)) {
    1:       hasInsertion = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   if (multiple || hasInsertion) {
    1:     // We have an insertion point.  There are some additional tests we need to do
    1:     // in order to ensure that an append is a safe operation.
    1:     PRUint32 childCount = 0;
    1: 
    1:     if (!multiple) {
    1:       // We may need to make multiple ContentInserted calls instead.  A
    1:       // reasonable heuristic to employ (in order to maintain good performance)
    1:       // is to find out if the insertion point's content node contains any
    1:       // explicit children.  If it does not, then it is highly likely that 
    1:       // an append is occurring.  (Note it is not definite, and there are insane
    1:       // cases we will not deal with by employing this heuristic, but it beats
    1:       // always falling back to multiple ContentInserted calls).
    1:       //
    1:       // In the multiple insertion point case, we know we're going to need to do
    1:       // multiple ContentInserted calls anyway.
    1:       childCount = insertionPoint->GetContent()->GetChildCount();
    1:     }
    1:  
40939:     // If we have multiple insertion points or if we have an insertion point
40939:     // and the operation is not a true append or if the insertion point already
40939:     // has explicit children, then we must fall back.
47664:     if (multiple || aEndChild != nsnull || childCount > 0) {
47664:       // Now comes the fun part.  For each inserted child, make a
47667:       // ContentInserted call as if it had just gotten inserted and
47667:       // let ContentInserted handle the mess.
47667:       IssueSingleInsertNofications(aContainer, aStartChild, aEndChild,
47667:                                    aAllowLazyConstruction);
40939:       return nsnull;
40939:     }
40939:   }
40939: 
40939:   return insertionPoint;
40939: }
40939: 
40939: PRBool
47658: nsCSSFrameConstructor::MaybeRecreateForFrameset(nsIFrame* aParentFrame,
47658:                                                 nsIContent* aStartChild,
47658:                                                 nsIContent* aEndChild)
40939: {
40939:   if (aParentFrame->GetType() == nsGkAtoms::frameSetFrame) {
    1:     // Check whether we have any kids we care about.
47658:     for (nsIContent* cur = aStartChild;
47658:          cur != aEndChild;
47658:          cur = cur->GetNextSibling()) {
47658:       if (IsSpecialFramesetChild(cur)) {
    1:         // Just reframe the parent, since framesets are weird like that.
40939:         RecreateFramesForContent(aParentFrame->GetContent(), PR_FALSE);
40939:         return PR_TRUE;
40939:       }
40939:     }
40939:   }
40939:   return PR_FALSE;
40939: }
40939: 
40939: nsresult
40939: nsCSSFrameConstructor::ContentAppended(nsIContent*     aContainer,
42107:                                        nsIContent*     aFirstNewContent,
40939:                                        PRBool          aAllowLazyConstruction)
40939: {
40939:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
40939:   NS_PRECONDITION(mUpdateCount != 0,
40939:                   "Should be in an update while creating frames");
40939: 
40939: #ifdef DEBUG
40939:   if (gNoisyContentUpdates) {
47668:     printf("nsCSSFrameConstructor::ContentAppended container=%p "
47668:            "first-child=%p lazy=%d\n",
47668:            static_cast<void*>(aContainer), aFirstNewContent,
40939:            aAllowLazyConstruction);
40939:     if (gReallyNoisyContentUpdates && aContainer) {
40939:       aContainer->List(stdout, 0);
40939:     }
40939:   }
40939: #endif
40939: 
40939: #ifdef MOZ_XUL
40939:   if (aContainer) {
40939:     PRInt32 namespaceID;
40939:     nsIAtom* tag =
40939:       mDocument->BindingManager()->ResolveTag(aContainer, &namespaceID);
40939: 
40939:     // Just ignore tree tags, anyway we don't create any frames for them.
40939:     if (tag == nsGkAtoms::treechildren ||
40939:         tag == nsGkAtoms::treeitem ||
40939:         tag == nsGkAtoms::treerow)
40939:       return NS_OK;
40939: 
40939:   }
40939: #endif // MOZ_XUL
40939: 
40939:   // Get the frame associated with the content
40939:   nsIFrame* parentFrame = GetFrameFor(aContainer);
40939:   if (! parentFrame)
40939:     return NS_OK;
40939: 
40939:   if (aAllowLazyConstruction &&
47659:       MaybeConstructLazily(CONTENTAPPEND, aContainer, aFirstNewContent)) {
40939:     return NS_OK;
40939:   }
40939: 
30749:   LAYOUT_PHASE_TEMP_EXIT();
40939:   parentFrame = GetRangeInsertionPoint(aContainer, parentFrame,
47664:                                        aFirstNewContent, nsnull,
47664:                                        aAllowLazyConstruction);
30749:   LAYOUT_PHASE_TEMP_REENTER();
40939:   if (!parentFrame) {
40939:     return NS_OK;
40939:   }
40939: 
40939:   LAYOUT_PHASE_TEMP_EXIT();
47658:   if (MaybeRecreateForFrameset(parentFrame, aFirstNewContent, nsnull)) {
40939:     LAYOUT_PHASE_TEMP_REENTER();
40939:     return NS_OK;
40939:   }
40939:   LAYOUT_PHASE_TEMP_REENTER();  
    1: 
    1:   if (parentFrame->IsLeaf()) {
    1:     // Nothing to do here; we shouldn't be constructing kids of leaves
40938:     // Clear lazy bits so we don't try to construct again.
47657:     ClearLazyBits(aFirstNewContent, nsnull);
    1:     return NS_OK;
    1:   }
    1:   
 6862: #ifdef MOZ_MATHML
30749:   if (parentFrame->IsFrameOfType(nsIFrame::eMathML)) {
30749:     LAYOUT_PHASE_TEMP_EXIT();
31031:     nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), PR_FALSE);
30749:     LAYOUT_PHASE_TEMP_REENTER();
30749:     return rv;
30749:   }
 6862: #endif
 6862: 
 4696:   // If the frame we are manipulating is a ``special'' frame (that is, one
 4696:   // that's been created as a result of a block-in-inline situation) then we
 4696:   // need to append to the last special sibling, not to the frame itself.
29501:   PRBool parentSpecial = IsFrameSpecial(parentFrame);
29501:   if (parentSpecial) {
    1: #ifdef DEBUG
    1:     if (gNoisyContentUpdates) {
    1:       printf("nsCSSFrameConstructor::ContentAppended: parentFrame=");
    1:       nsFrame::ListTag(stdout, parentFrame);
    1:       printf(" is special\n");
    1:     }
    1: #endif
    1: 
    1:     // Since we're appending, we'll walk to the last anonymous frame
25738:     // that was created for the broken inline frame.  But don't walk
27309:     // to the trailing inline if it's empty; stop at the block.
34462:     parentFrame = GetLastSpecialSibling(parentFrame, PR_FALSE);
    1:   }
    1: 
27310:   // Get continuation that parents the last child.  This MUST be done
27310:   // before the AdjustAppendParentForAfterContent call.
10780:   parentFrame = nsLayoutUtils::GetLastContinuationWithChild(parentFrame);
    1: 
24404:   // We should never get here with fieldsets, since they have multiple
24404:   // insertion points.
29501:   NS_ASSERTION(parentFrame->GetType() != nsGkAtoms::fieldSetFrame,
24404:                "Unexpected parent");
    1: 
    1:   // Deal with possible :after generated content on the parent
    1:   nsIFrame* parentAfterFrame;
    1:   parentFrame =
    1:     ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
    1:                                         aContainer, parentFrame,
    1:                                         &parentAfterFrame);
    1:   
    1:   // Create some new frames
    1:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                 GetAbsoluteContainingBlock(parentFrame),
    1:                                 GetFloatContainingBlock(parentFrame));
    1: 
    1:   // See if the containing block has :first-letter style applied.
    1:   PRBool haveFirstLetterStyle = PR_FALSE, haveFirstLineStyle = PR_FALSE;
    1:   nsIFrame* containingBlock = state.mFloatedItems.containingBlock;
    1:   if (containingBlock) {
 1254:     haveFirstLetterStyle = HasFirstLetterStyle(containingBlock);
 1243:     haveFirstLineStyle =
 1254:       ShouldHaveFirstLineStyle(containingBlock->GetContent(),
 1243:                                containingBlock->GetStyleContext());
    1:   }
    1: 
    1:   if (haveFirstLetterStyle) {
    1:     // Before we get going, remove the current letter frames
    1:     RemoveLetterFrames(state.mPresContext, state.mPresShell,
    1:                        state.mFrameManager, containingBlock);
    1:   }
    1: 
29501:   nsIAtom* frameType = parentFrame->GetType();
36794:   PRBool haveNoXBLChildren =
36794:     mDocument->BindingManager()->GetXBLChildNodesFor(aContainer) == nsnull;
25774:   FrameConstructionItemList items;
47665:   if (aFirstNewContent->GetPreviousSibling() &&
47665:       GetParentType(frameType) == eTypeBlock &&
36794:       haveNoXBLChildren) {
29838:     // If there's a text node in the normal content list just before the new
29838:     // items, and it has no frame, make a frame construction item for it. If it
29838:     // doesn't need a frame, ConstructFramesFromItemList below won't give it
29838:     // one.  No need to do all this if our parent type is not block, though,
29838:     // since WipeContainingBlock already handles that situation.
29838:     //
29501:     // Because we're appending, we don't need to worry about any text
29501:     // after the appended content; there can only be XBL anonymous content
29501:     // (text in an XBL binding is not suppressed) or generated content
29501:     // (and bare text nodes are not generated). Native anonymous content
29501:     // generated by frames never participates in inline layout.
47665:     AddTextItemIfNeeded(state, parentFrame,
47665:                         aFirstNewContent->GetPreviousSibling(), items);
29501:   }
47668:   for (nsIContent* child = aFirstNewContent;
47668:        child;
47668:        child = child->GetNextSibling()) {
47661:     AddFrameConstructionItems(state, child, PR_FALSE, parentFrame, items);
25773:   }
25773: 
27310:   nsIFrame* prevSibling = ::FindAppendPrevSibling(parentFrame, parentAfterFrame);
27310: 
25773:   // Perform special check for diddling around with the frames in
25773:   // a special inline frame.
25773:   // If we're appending before :after content, then we're not really
25773:   // appending, so let WipeContainingBlock know that.
26720:   LAYOUT_PHASE_TEMP_EXIT();
25773:   if (WipeContainingBlock(state, containingBlock, parentFrame, items,
27310:                           PR_TRUE, prevSibling)) {
26720:     LAYOUT_PHASE_TEMP_REENTER();
25773:     return NS_OK;
25773:   }
26720:   LAYOUT_PHASE_TEMP_REENTER();
25773: 
29501:   // If the parent is a block frame, and we're not in a special case
29501:   // where frames can be moved around, determine if the list is for the
29501:   // start or end of the block.
29501:   if (nsLayoutUtils::GetAsBlock(parentFrame) && !haveFirstLetterStyle &&
29501:       !haveFirstLineStyle && !parentSpecial) {
29501:     items.SetLineBoundaryAtStart(!prevSibling ||
29501:         !prevSibling->GetStyleDisplay()->IsInlineOutside() ||
29501:         prevSibling->GetType() == nsGkAtoms::brFrame);
29501:     // :after content can't be <br> so no need to check it
29501:     items.SetLineBoundaryAtEnd(!parentAfterFrame ||
29501:         !parentAfterFrame->GetStyleDisplay()->IsInlineOutside());
29501:   }
29501:   // To suppress whitespace-only text frames, we have to verify that
29501:   // our container's DOM child list matches its flattened tree child list.
29501:   // This is guaranteed to be true if GetXBLChildNodesFor() returns null.
36794:   items.SetParentHasNoXBLChildren(haveNoXBLChildren);
29501: 
25773:   nsFrameItems frameItems;
26216:   ConstructFramesFromItemList(state, items, parentFrame, frameItems);
26216: 
47668:   for (nsIContent* child = aFirstNewContent;
47668:        child;
47668:        child = child->GetNextSibling()) {
26216:     // Invalidate now instead of before the WipeContainingBlock call, just in
26216:     // case we do wipe; in that case we don't need to do this walk at all.
26216:     // XXXbz does that matter?  Would it make more sense to save some virtual
26216:     // GetChildAt calls instead and do this during construction of our
26216:     // FrameConstructionItemList?
47668:     InvalidateCanvasIfNeeded(mPresShell, child);
26216:   }
26216: 
26216:   // if the container is a table and a caption was appended, it needs to be put
26216:   // in the outer table frame's additional child list.
    1:   nsFrameItems captionItems;
 4368:   if (nsGkAtoms::tableFrame == frameType) {
 4368:     // Pull out the captions.  Note that we don't want to do that as we go,
 4368:     // because processing a single caption can add a whole bunch of things to
 4368:     // the frame items due to pseudoframe processing.  So we'd have to pull
 4368:     // captions from a list anyway; might as well do that here.
26208:     // XXXbz this is no longer true; we could pull captions directly out of the
26208:     // FrameConstructionItemList now.
 4368:     PullOutCaptionFrames(frameItems, captionItems);
 4368:   }
 4368:   
    1:   if (haveFirstLineStyle && parentFrame == containingBlock) {
    1:     // It's possible that some of the new frames go into a
    1:     // first-line frame. Look at them and see...
    1:     AppendFirstLineFrames(state, containingBlock->GetContent(),
    1:                           containingBlock, frameItems); 
    1:   }
    1: 
    1:   // Notify the parent frame passing it the list of new frames
27310:   // Append the flowed frames to the principal child list; captions
27310:   // need special treatment
30785:   if (captionItems.NotEmpty()) { // append the caption to the outer table
27310:     NS_ASSERTION(nsGkAtoms::tableFrame == frameType, "how did that happen?");
    1:     nsIFrame* outerTable = parentFrame->GetParent();
    1:     if (outerTable) {
30941:       state.mFrameManager->AppendFrames(outerTable, nsGkAtoms::captionList,
30941:                                         captionItems);
30785:     }
30785:   }
30785: 
30785:   if (frameItems.NotEmpty()) { // append the in-flow kids
27310:     AppendFrames(state, parentFrame, frameItems, prevSibling);
    1:   }
    1: 
    1:   // Recover first-letter frames
    1:   if (haveFirstLetterStyle) {
23461:     RecoverLetterFrames(containingBlock);
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   if (gReallyNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ContentAppended: resulting frame model:\n");
31709:     parentFrame->List(stdout, 0);
    1:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef MOZ_XUL
    1: 
    1: enum content_operation
    1: {
    1:     CONTENT_INSERTED,
    1:     CONTENT_REMOVED
    1: };
    1: 
    1: // Helper function to lookup the listbox body frame and send a notification
    1: // for insertion or removal of content
    1: static
    1: PRBool NotifyListBoxBody(nsPresContext*    aPresContext,
    1:                          nsIContent*        aContainer,
    1:                          nsIContent*        aChild,
47669:                          // Only used for the removed notification
47669:                          nsIContent*        aOldNextSibling,
    1:                          nsIDocument*       aDocument,                         
    1:                          nsIFrame*          aChildFrame,
    1:                          content_operation  aOperation)
    1: {
28865:   nsListBoxBodyFrame* listBoxBodyFrame =
28865:     MaybeGetListBoxBodyFrame(aContainer, aChild);
20990:   if (listBoxBodyFrame) {
    1:     if (aOperation == CONTENT_REMOVED) {
    1:       // Except if we have an aChildFrame and its parent is not the right
    1:       // thing, then we don't do this.  Pseudo frames are so much fun....
    1:       if (!aChildFrame || aChildFrame->GetParent() == listBoxBodyFrame) {
31436:         listBoxBodyFrame->OnContentRemoved(aPresContext, aContainer,
47669:                                            aChildFrame, aOldNextSibling);
    1:         return PR_TRUE;
    1:       }
    1:     } else {
    1:       listBoxBodyFrame->OnContentInserted(aPresContext, aChild);
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: #endif // MOZ_XUL
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ContentInserted(nsIContent*            aContainer,
    1:                                        nsIContent*            aChild,
40938:                                        nsILayoutHistoryState* aFrameState,
40938:                                        PRBool                 aAllowLazyConstruction)
    1: {
40939:   return ContentRangeInserted(aContainer,
40939:                               aChild,
47656:                               aChild->GetNextSibling(),
40939:                               aFrameState,
40939:                               aAllowLazyConstruction);
40939: }
40939: 
40939: // ContentRangeInserted handles creating frames for a range of nodes that
40939: // aren't at the end of their childlist. ContentRangeInserted isn't a real
40939: // content notification, but rather it handles regular ContentInserted calls
40939: // for a single node as well as the lazy construction of frames for a range of
40939: // nodes when called from CreateNeededFrames. For a range of nodes to be
40939: // suitable to have its frames constructed all at once they must meet the same
40939: // conditions that ContentAppended imposes (GetRangeInsertionPoint checks
40939: // these), plus more. Namely when finding the insertion prevsibling we must not
40939: // need to consult something specific to any one node in the range, so that the
40939: // insertion prevsibling would be the same for each node in the range. So we
40939: // pass the first node in the range to GetInsertionPrevSibling, and if
40939: // IsValidSibling (the only place GetInsertionPrevSibling might look at the
40939: // passed in node itself) needs to resolve style on the node we record this and
40939: // return that this range needs to be split up and inserted separately. Table
40939: // captions need extra attention as we need to determine where to insert them
40939: // in the caption list, while skipping any nodes in the range being inserted
40939: // (because when we treat the caption frames the other nodes have had their
40939: // frames constructed but not yet inserted into the frame tree).
40939: nsresult
40939: nsCSSFrameConstructor::ContentRangeInserted(nsIContent*            aContainer,
47656:                                             nsIContent*            aStartChild,
47656:                                             nsIContent*            aEndChild,
40939:                                             nsILayoutHistoryState* aFrameState,
40939:                                             PRBool                 aAllowLazyConstruction)
40939: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while creating frames");
 6518: 
47656:   NS_PRECONDITION(aStartChild, "must always pass a child");
40939: 
    1:   // XXXldb Do we need to re-resolve style to handle the CSS2 + combinator and
    1:   // the :empty pseudo-class?
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
47656:     printf("nsCSSFrameConstructor::ContentRangeInserted container=%p "
47666:            "start-child=%p end-child=%p lazy=%d\n",
47656:            static_cast<void*>(aContainer),
47656:            static_cast<void*>(aStartChild), static_cast<void*>(aEndChild),
47666:            aAllowLazyConstruction);
    1:     if (gReallyNoisyContentUpdates) {
40939:       if (aContainer) {
40939:         aContainer->List(stdout,0);
40939:       } else {
47656:         aStartChild->List(stdout, 0);
40939:       }
    1:     }
    1:   }
    1: #endif
    1: 
    1:   nsresult rv = NS_OK;
    1: 
47666:   PRBool isSingleInsert = (aStartChild->GetNextSibling() == aEndChild);
40939:   NS_ASSERTION(isSingleInsert || !aAllowLazyConstruction,
40939:                "range insert shouldn't be lazy");
47667:   NS_ASSERTION(isSingleInsert || aEndChild,
47667:                "range should not include all nodes after aStartChild");
40939: 
    1: #ifdef MOZ_XUL
40939:   if (aContainer && IsXULListBox(aContainer)) {
40939:     if (isSingleInsert) {
47656:       if (NotifyListBoxBody(mPresShell->GetPresContext(), aContainer,
47666:                             // The insert case in NotifyListBoxBody
47669:                             // doesn't use "old next sibling".
47669:                             aStartChild, nsnull, 
40939:                             mDocument, nsnull, CONTENT_INSERTED)) {
40939:         return NS_OK;
40939:       }
40939:     } else {
40939:       // We don't handle a range insert to a listbox parent, issue single
40939:       // ContertInserted calls for each node inserted.
40939:       LAYOUT_PHASE_TEMP_EXIT();
47667:       IssueSingleInsertNofications(aContainer, aStartChild, aEndChild,
40939:                                    aAllowLazyConstruction);
40939:       LAYOUT_PHASE_TEMP_REENTER();
40939:       return NS_OK;
40939:     }
40939:   }
    1: #endif // MOZ_XUL
    1:   
28215:   // If we have a null parent, then this must be the document element being
28215:   // inserted, or some other child of the document in the DOM (might be a PI,
28215:   // say).
    1:   if (! aContainer) {
40939:     NS_ASSERTION(isSingleInsert,
40939:                  "root node insertion should be a single insertion");
41634:     Element *docElement = mDocument->GetRootElement();
    1: 
47656:     if (aStartChild != docElement) {
28215:       // Not the root element; just bail out
28215:       return NS_OK;
28215:     }
28215: 
28215:     NS_PRECONDITION(nsnull == mRootElementFrame,
28215:                     "root element frame already created");
    1: 
    1:     // Create frames for the document element and its child elements
    1:     nsIFrame*               docElementFrame;
28215:     rv = ConstructDocElementFrame(docElement, aFrameState, &docElementFrame);
    1: 
 3026:     if (NS_SUCCEEDED(rv) && docElementFrame) {
47656:       InvalidateCanvasIfNeeded(mPresShell, aStartChild);
    1: #ifdef DEBUG
 3026:       if (gReallyNoisyContentUpdates) {
40939:         printf("nsCSSFrameConstructor::ContentRangeInserted: resulting frame "
28215:                "model:\n");
31709:         mFixedContainingBlock->List(stdout, 0);
    1:       }
    1: #endif
    1:     }
28215: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Otherwise, we've got parent content. Find its frame.
    1:   nsIFrame* parentFrame = GetFrameFor(aContainer);
    1:   if (! parentFrame)
28215:     return NS_OK;
    1: 
40938:   if (aAllowLazyConstruction &&
47659:       MaybeConstructLazily(CONTENTINSERT, aContainer, aStartChild)) {
40938:     return NS_OK;
40938:   }
40938: 
40939:   if (isSingleInsert) {
    1:     // See if we have an XBL insertion point. If so, then that's our
    1:     // real parent frame; if not, then the frame hasn't been built yet
    1:     // and we just bail.
    1:     nsIFrame* insertionPoint;
47656:     GetInsertionPoint(parentFrame, aStartChild, &insertionPoint);
    1:     if (! insertionPoint)
    1:       return NS_OK; // Don't build the frames.
    1: 
    1:     parentFrame = insertionPoint;
40939:   } else {
40939:     // Get our insertion point. If we need to issue single ContentInserted's
40939:     // GetRangeInsertionPoint will take care of that for us.
40939:     LAYOUT_PHASE_TEMP_EXIT();
40939:     parentFrame = GetRangeInsertionPoint(aContainer, parentFrame,
47664:                                          aStartChild, aEndChild,
47664:                                          aAllowLazyConstruction);
40939:     LAYOUT_PHASE_TEMP_REENTER();
40939:     if (!parentFrame) {
40939:       return NS_OK;
40939:     }
40939:   }
40939: 
40939:   PRBool isAppend, isRangeInsertSafe;
27696:   nsIFrame* prevSibling =
47663:     GetInsertionPrevSibling(parentFrame, aContainer, aStartChild,
40939:                             &isAppend, &isRangeInsertSafe);
40939: 
40939:   // check if range insert is safe
40939:   if (!isSingleInsert && !isRangeInsertSafe) {
40939:     // must fall back to a single ContertInserted for each child in the range
40939:     LAYOUT_PHASE_TEMP_EXIT();
47667:     IssueSingleInsertNofications(aContainer, aStartChild, aEndChild,
47667:                                  aAllowLazyConstruction);
40939:     LAYOUT_PHASE_TEMP_REENTER();
40939:     return NS_OK;
40939:   }
27696: 
    1:   nsIContent* container = parentFrame->GetContent();
    1: 
29110:   nsIAtom* frameType = parentFrame->GetType();
30749:   LAYOUT_PHASE_TEMP_EXIT();
47658:   if (MaybeRecreateForFrameset(parentFrame, aStartChild, aEndChild)) {
30749:     LAYOUT_PHASE_TEMP_REENTER();
47658:     return NS_OK;
47658:   }
40939:   LAYOUT_PHASE_TEMP_REENTER();
40939: 
40939:   // We should only get here with fieldsets when doing a single insert, because
40939:   // fieldsets have multiple insertion points.
40939:   NS_ASSERTION(isSingleInsert || frameType != nsGkAtoms::fieldSetFrame,
40939:                "Unexpected parent");
29110:   if (frameType == nsGkAtoms::fieldSetFrame &&
47656:       aStartChild->Tag() == nsGkAtoms::legend) {
29110:     // Just reframe the parent, since figuring out whether this
29110:     // should be the new legend and then handling it is too complex.
29110:     // We could do a little better here --- check if the fieldset already
29110:     // has a legend which occurs earlier in its child list than this node,
29110:     // and if so, proceed. But we'd have to extend nsFieldSetFrame
29110:     // to locate this legend in the inserted frames and extract it.
30749:     LAYOUT_PHASE_TEMP_EXIT();
31031:     nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), PR_FALSE);
30749:     LAYOUT_PHASE_TEMP_REENTER();
30749:     return rv;
29110:   }
29110: 
    1:   // Don't construct kids of leaves
    1:   if (parentFrame->IsLeaf()) {
40938:     // Clear lazy bits so we don't try to construct again.
47657:     ClearLazyBits(aStartChild, aEndChild);
    1:     return NS_OK;
    1:   }
    1: 
 6862: #ifdef MOZ_MATHML
30749:   if (parentFrame->IsFrameOfType(nsIFrame::eMathML)) {
30749:     LAYOUT_PHASE_TEMP_EXIT();
31031:     nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), PR_FALSE);
30749:     LAYOUT_PHASE_TEMP_REENTER();
30749:     return rv;
30749:   }
 6862: #endif
 6862: 
    1:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                 GetAbsoluteContainingBlock(parentFrame),
    1:                                 GetFloatContainingBlock(parentFrame),
    1:                                 aFrameState);
    1: 
    1: 
    1:   // Recover state for the containing block - we need to know if
    1:   // it has :first-letter or :first-line style applied to it. The
    1:   // reason we care is that the internal structure in these cases
    1:   // is not the normal structure and requires custom updating
    1:   // logic.
    1:   nsIFrame* containingBlock = state.mFloatedItems.containingBlock;
    1:   PRBool haveFirstLetterStyle = PR_FALSE;
    1:   PRBool haveFirstLineStyle = PR_FALSE;
    1: 
    1:   // In order to shave off some cycles, we only dig up the
    1:   // containing block haveFirst* flags if the parent frame where
    1:   // the insertion/append is occurring is an inline or block
    1:   // container. For other types of containers this isn't relevant.
    1:   const nsStyleDisplay* parentDisplay = parentFrame->GetStyleDisplay();
    1: 
    1:   // Examine the parentFrame where the insertion is taking
    1:   // place. If it's a certain kind of container then some special
    1:   // processing is done.
    1:   if ((NS_STYLE_DISPLAY_BLOCK == parentDisplay->mDisplay) ||
    1:       (NS_STYLE_DISPLAY_LIST_ITEM == parentDisplay->mDisplay) ||
    1:       (NS_STYLE_DISPLAY_INLINE == parentDisplay->mDisplay) ||
    1:       (NS_STYLE_DISPLAY_INLINE_BLOCK == parentDisplay->mDisplay)) {
    1:     // Recover the special style flags for the containing block
    1:     if (containingBlock) {
 1254:       haveFirstLetterStyle = HasFirstLetterStyle(containingBlock);
 1243:       haveFirstLineStyle =
 1254:         ShouldHaveFirstLineStyle(containingBlock->GetContent(),
 1243:                                  containingBlock->GetStyleContext());
    1:     }
    1: 
    1:     if (haveFirstLetterStyle) {
27696:       // If our current parentFrame is a Letter frame, use its parent as our
27696:       // new parent hint
    1:       if (parentFrame->GetType() == nsGkAtoms::letterFrame) {
34148:         // If parentFrame is out of flow, then we actually want the parent of
34148:         // the placeholder frame.
34148:         if (parentFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
34148:           nsPlaceholderFrame* placeholderFrame =
34148:             state.mFrameManager->GetPlaceholderFrameFor(parentFrame);
34148:           NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
34148:           parentFrame = placeholderFrame->GetParent();
34148:         } else {
    1:           parentFrame = parentFrame->GetParent();
    1:         }
34148:       }
    1: 
    1:       // Remove the old letter frames before doing the insertion
    1:       RemoveLetterFrames(state.mPresContext, mPresShell,
    1:                          state.mFrameManager,
    1:                          state.mFloatedItems.containingBlock);
    1: 
    1:       // Removing the letterframes messes around with the frame tree, removing
27696:       // and creating frames.  We need to reget our prevsibling, parent frame,
27696:       // etc.
47656:       prevSibling = GetInsertionPrevSibling(parentFrame, aContainer,
47663:                                             aStartChild, &isAppend,
47663:                                             &isRangeInsertSafe);
40939: 
40939:       // Need check whether a range insert is still safe.
40939:       if (!isSingleInsert && !isRangeInsertSafe) {
40939:         // Need to recover the letter frames first.
40939:         RecoverLetterFrames(state.mFloatedItems.containingBlock);
40939: 
40939:         // must fall back to a single ContertInserted for each child in the range
40939:         LAYOUT_PHASE_TEMP_EXIT();
47667:         IssueSingleInsertNofications(aContainer, aStartChild, aEndChild,
40939:                                      aAllowLazyConstruction);
40939:         LAYOUT_PHASE_TEMP_REENTER();
40939:         return NS_OK;
40939:       }
40939: 
27696:       container = parentFrame->GetContent();
29838:       frameType = parentFrame->GetType();
    1:     }
    1:   }
    1: 
 8154:   if (!prevSibling) {
40939:     // We're inserting the new frames as the first child. See if the
 8154:     // parent has a :before pseudo-element
 8154:     nsIFrame* firstChild = parentFrame->GetFirstChild(nsnull);
 8154: 
 8154:     if (firstChild &&
26101:         nsLayoutUtils::IsGeneratedContentFor(container, firstChild,
 8154:                                              nsCSSPseudoElements::before)) {
 8154:       // Insert the new frames after the last continuation of the :before
10780:       prevSibling = firstChild->GetTailContinuation();
27696:       parentFrame = prevSibling->GetParent()->GetContentInsertionFrame();
27310:       // Don't change isAppend here; we'll can call AppendFrames as needed, and
27310:       // the change to our prevSibling doesn't affect that.
 8154:     }
 8154:   }
 8154: 
25774:   FrameConstructionItemList items;
29838:   ParentType parentType = GetParentType(frameType);
36794:   PRBool haveNoXBLChildren =
36794:     mDocument->BindingManager()->GetXBLChildNodesFor(aContainer) == nsnull;
47665:   if (aStartChild->GetPreviousSibling() &&
47665:       parentType == eTypeBlock && haveNoXBLChildren) {
29838:     // If there's a text node in the normal content list just before the
40939:     // new nodes, and it has no frame, make a frame construction item for
29838:     // it, because it might need a frame now.  No need to do this if our
29838:     // parent type is not block, though, since WipeContainingBlock
29838:     // already handles that sitation.
47665:     AddTextItemIfNeeded(state, parentFrame, aStartChild->GetPreviousSibling(),
29501:                         items);
29501:   }
29501: 
40939:   if (isSingleInsert) {
47666:     AddFrameConstructionItems(state, aStartChild,
47666:                               aStartChild->IsRootOfAnonymousSubtree(),
47656:                               parentFrame, items);
40939:   } else {
47666:     for (nsIContent* child = aStartChild;
47666:          child != aEndChild;
47666:          child = child->GetNextSibling()){
47661:       AddFrameConstructionItems(state, child, PR_FALSE, parentFrame, items);
40939:     }
40939:   }
40939: 
47665:   if (aEndChild && parentType == eTypeBlock && haveNoXBLChildren) {
29838:     // If there's a text node in the normal content list just after the
40939:     // new nodes, and it has no frame, make a frame construction item for
29838:     // it, because it might need a frame now.  No need to do this if our
29838:     // parent type is not block, though, since WipeContainingBlock
29838:     // already handles that sitation.
47665:     AddTextItemIfNeeded(state, parentFrame, aEndChild, items);
29501:   }
25773: 
25773:   // Perform special check for diddling around with the frames in
25773:   // a special inline frame.
25773:   // If we're appending before :after content, then we're not really
25773:   // appending, so let WipeContainingBlock know that.
26720:   LAYOUT_PHASE_TEMP_EXIT();
25773:   if (WipeContainingBlock(state, containingBlock, parentFrame, items,
27310:                           isAppend, prevSibling)) {
26720:     LAYOUT_PHASE_TEMP_REENTER();
25773:     return NS_OK;
26720:   }
26720:   LAYOUT_PHASE_TEMP_REENTER();
25773: 
29501:   // If the container is a table and a caption will be appended, it needs to be
    1:   // put in the outer table frame's additional child list.
29501:   // We make no attempt here to set flags to indicate whether the list
29501:   // will be at the start or end of a block. It doesn't seem worthwhile.
    1:   nsFrameItems frameItems, captionItems;
26216:   ConstructFramesFromItemList(state, items, parentFrame, frameItems);
26216: 
30785:   if (frameItems.NotEmpty()) {
47666:     for (nsIContent* child = aStartChild;
47666:          child != aEndChild;
47666:          child = child->GetNextSibling()){
47666:       InvalidateCanvasIfNeeded(mPresShell, child);
40939:     }
40939: 
40939:     if (nsGkAtoms::tableFrame == frameType ||
40939:         nsGkAtoms::tableOuterFrame == frameType) {
40939:       PullOutCaptionFrames(frameItems, captionItems);
    1:     }
    1:   }
    1: 
 4194:   // If the parent of our current prevSibling is different from the frame we'll
 4194:   // actually use as the parent, then the calculated insertion point is now
 4194:   // invalid and as it is unknown where to insert correctly we append instead
 4194:   // (bug 341858).
27310:   // This can affect our prevSibling and isAppend, but should not have any
27310:   // effect on the WipeContainingBlock above, since this should only happen
27310:   // when neither parent is a special frame and should not affect whitespace
27310:   // handling inside table-related frames (and in fact, can only happen when
27310:   // one of the parents is an outer table and one is an inner table or when the
27311:   // parent is a fieldset or fieldset content frame).  So it won't affect the
27311:   // {ib} or XUL box cases in WipeContainingBlock(), and the table pseudo
27311:   // handling will only be affected by us maybe thinking we're not inserting
27311:   // at the beginning, whereas we really are.  That would have made us reframe
27311:   // unnecessarily, but that's ok.
25773:   // XXXbz we should push our frame construction item code up higher, so we
25773:   // know what our items are by the time we start figuring out previous
25773:   // siblings
30785:   if (prevSibling && frameItems.NotEmpty() &&
30785:       frameItems.FirstChild()->GetParent() != prevSibling->GetParent()) {
25773: #ifdef DEBUG
30785:     nsIFrame* frame1 = frameItems.FirstChild()->GetParent();
25773:     nsIFrame* frame2 = prevSibling->GetParent();
25773:     NS_ASSERTION(!IsFrameSpecial(frame1) && !IsFrameSpecial(frame2),
25773:                  "Neither should be special");
25773:     NS_ASSERTION((frame1->GetType() == nsGkAtoms::tableFrame &&
25773:                   frame2->GetType() == nsGkAtoms::tableOuterFrame) ||
25773:                  (frame1->GetType() == nsGkAtoms::tableOuterFrame &&
25773:                   frame2->GetType() == nsGkAtoms::tableFrame) ||
25773:                  frame1->GetType() == nsGkAtoms::fieldSetFrame ||
25773:                  (frame1->GetParent() &&
25773:                   frame1->GetParent()->GetType() == nsGkAtoms::fieldSetFrame),
25773:                  "Unexpected frame types");
25773: #endif
    1:     isAppend = PR_TRUE;
27310:     nsIFrame* appendAfterFrame;
    1:     parentFrame =
    1:       ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
26101:                                           container,
30785:                                           frameItems.FirstChild()->GetParent(),
    1:                                           &appendAfterFrame);
27310:     prevSibling = ::FindAppendPrevSibling(parentFrame, appendAfterFrame);
    1:   }
    1: 
    1:   if (haveFirstLineStyle && parentFrame == containingBlock) {
    1:     // It's possible that the new frame goes into a first-line
    1:     // frame. Look at it and see...
    1:     if (isAppend) {
    1:       // Use append logic when appending
    1:       AppendFirstLineFrames(state, containingBlock->GetContent(),
    1:                             containingBlock, frameItems); 
    1:     }
    1:     else {
    1:       // Use more complicated insert logic when inserting
26101:       // XXXbz this method is a no-op, so it's easy for the args being passed
26101:       // here to make no sense without anyone noticing...  If it ever stops
26101:       // being a no-op, vet them carefully!
26101:       InsertFirstLineFrames(state, container, containingBlock, &parentFrame,
    1:                             prevSibling, frameItems);
    1:     }
    1:   }
    1:       
40939:   // We might have captions; put them into the caption list of the
40939:   // outer table frame.
40939:   if (captionItems.NotEmpty()) {
40939:     NS_ASSERTION(nsGkAtoms::tableFrame == frameType ||
40939:                  nsGkAtoms::tableOuterFrame == frameType,
40939:                  "parent for caption is not table?");
40939:     // We need to determine where to put the caption items; start with the
40939:     // the parent frame that has already been determined and get the insertion
40939:     // prevsibling of the first caption item.
40939:     nsIFrame* captionParent = parentFrame;
40939:     PRBool captionIsAppend;
40939:     nsIFrame* captionPrevSibling = nsnull;
40939: 
40939:     // aIsRangeInsertSafe is ignored on purpose because it is irrelevant here.
40939:     PRBool ignored;
40939:     if (isSingleInsert) {
40939:       captionPrevSibling =
47656:         GetInsertionPrevSibling(captionParent, aContainer, aStartChild,
47663:                                 &captionIsAppend, &ignored);
40939:     } else {
40939:       nsIContent* firstCaption = captionItems.FirstChild()->GetContent();
40939:       // It is very important here that we skip the children in
47663:       // [aStartChild,aEndChild) when looking for a
40939:       // prevsibling.
40939:       captionPrevSibling =
40939:         GetInsertionPrevSibling(captionParent, aContainer, firstCaption,
47663:                                 &captionIsAppend, &ignored,
47663:                                 aStartChild, aEndChild);
40939:     }
40939: 
40939:     nsIFrame* outerTable = nsnull;
40939:     if (GetCaptionAdjustedParent(captionParent, captionItems.FirstChild(),
40939:                                  &outerTable)) {
40939:       // If the parent is not an outer table frame we will try to add frames
40939:       // to a named child list that the parent does not honour and the frames
40939:       // will get lost
40939:       NS_ASSERTION(nsGkAtoms::tableOuterFrame == outerTable->GetType(),
40939:                    "Pseudo frame construction failure; "
40939:                    "a caption can be only a child of an outer table frame");
40939: 
40939:       // If the parent of our current prevSibling is different from the frame
40939:       // we'll actually use as the parent, then the calculated insertion
40939:       // point is now invalid (bug 341382).
40939:       if (captionPrevSibling &&
40939:           captionPrevSibling->GetParent() != outerTable) {
40939:           captionPrevSibling = nsnull;
40939:       }
40939:       if (captionIsAppend) {
40939:         state.mFrameManager->AppendFrames(outerTable, nsGkAtoms::captionList,
40939:                                           captionItems);
40939:       } else {
40939:         state.mFrameManager->InsertFrames(outerTable, nsGkAtoms::captionList,
40939:                                           captionPrevSibling, captionItems);
40939:       }
40939:     }
40939:   }
40939: 
40939:   if (frameItems.NotEmpty()) {
 3663:     // Notify the parent frame
 3663:     if (isAppend) {
27310:       AppendFrames(state, parentFrame, frameItems, prevSibling);
 3663:     } else {
30785:       state.mFrameManager->InsertFrames(parentFrame, nsnull, prevSibling,
30941:                                         frameItems);
    1:     }
    1:   }
    1: 
    1:   if (haveFirstLetterStyle) {
    1:     // Recover the letter frames for the containing block when
    1:     // it has first-letter style.
23461:     RecoverLetterFrames(state.mFloatedItems.containingBlock);
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   if (gReallyNoisyContentUpdates && parentFrame) {
40939:     printf("nsCSSFrameConstructor::ContentRangeInserted: resulting frame model:\n");
31709:     parentFrame->List(stdout, 0);
    1:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ContentRemoved(nsIContent* aContainer,
    1:                                       nsIContent* aChild,
47669:                                       nsIContent* aOldNextSibling,
29501:                                       RemoveFlags aFlags,
 7681:                                       PRBool*     aDidReconstruct)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
 6518:   NS_PRECONDITION(mUpdateCount != 0,
 6518:                   "Should be in an update while destroying frames");
 6518: 
 7681:   *aDidReconstruct = PR_FALSE;
 7681:   
    1:   // XXXldb Do we need to re-resolve style to handle the CSS2 + combinator and
    1:   // the :empty pseudo-class?
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
47669:     printf("nsCSSFrameConstructor::ContentRemoved container=%p child=%p "
47669:            "old-next-sibling=%p\n",
 3233:            static_cast<void*>(aContainer),
 3233:            static_cast<void*>(aChild),
47669:            static_cast<void*>(aOldNextSibling));
    1:     if (gReallyNoisyContentUpdates) {
    1:       aContainer->List(stdout, 0);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   nsFrameManager *frameManager = mPresShell->FrameManager();
    1:   nsPresContext *presContext = mPresShell->GetPresContext();
    1:   nsresult                  rv = NS_OK;
    1: 
    1:   // Find the child frame that maps the content
36656:   nsIFrame* childFrame = aChild->GetPrimaryFrame();
    1: 
21936:   if (!childFrame || childFrame->GetContent() != aChild) {
21936:     // XXXbz the GetContent() != aChild check is needed due to bug 135040.
21936:     // Remove it once that's fixed.
    1:     frameManager->ClearUndisplayedContentIn(aChild, aContainer);
    1:   }
    1: 
    1: #ifdef MOZ_XUL
47669:   if (NotifyListBoxBody(presContext, aContainer, aChild, aOldNextSibling, 
23941:                         mDocument, childFrame, CONTENT_REMOVED))
    1:     return NS_OK;
    1: 
    1: #endif // MOZ_XUL
    1: 
28215:   // If we're removing the root, then make sure to remove things starting at
28215:   // the viewport's child instead of the primary frame (which might even be
28215:   // null if the root had an XBL binding or display:none, even though the
28215:   // frames above it got created).  We do the adjustment after the childFrame
28215:   // check above, because we do want to clear any undisplayed content we might
28215:   // have for the root.  Detecting removal of a root is a little exciting; in
28215:   // particular, having a null aContainer is necessary but NOT sufficient.  Due
28215:   // to how we process reframes, the content node might not even be in our
28215:   // document by now.  So explicitly check whether the viewport's first kid's
28215:   // content node is aChild.
28215:   PRBool isRoot = PR_FALSE;
28215:   if (!aContainer) {
28215:     nsIFrame* viewport = frameManager->GetRootFrame();
28215:     if (viewport) {
28215:       nsIFrame* firstChild = viewport->GetFirstChild(nsnull);
28215:       if (firstChild && firstChild->GetContent() == aChild) {
28215:         isRoot = PR_TRUE;
28215:         childFrame = firstChild;
28215:         NS_ASSERTION(!childFrame->GetNextSibling(), "How did that happen?");
28215:       }
28215:     }
28215:   }
28215: 
    1:   if (childFrame) {
26216:     InvalidateCanvasIfNeeded(mPresShell, aChild);
    1:     
26471:     // See whether we need to remove more than just childFrame
30749:     LAYOUT_PHASE_TEMP_EXIT();
26471:     if (MaybeRecreateContainerForFrameRemoval(childFrame, &rv)) {
30749:       LAYOUT_PHASE_TEMP_REENTER();
 7681:       *aDidReconstruct = PR_TRUE;
 4696:       return rv;
    1:     }
30749:     LAYOUT_PHASE_TEMP_REENTER();
    1: 
    1:     // Get the childFrame's parent frame
    1:     nsIFrame* parentFrame = childFrame->GetParent();
 6862:     nsIAtom* parentType = parentFrame->GetType();
 6862: 
 6862:     if (parentType == nsGkAtoms::frameSetFrame &&
    1:         IsSpecialFramesetChild(aChild)) {
    1:       // Just reframe the parent, since framesets are weird like that.
 7681:       *aDidReconstruct = PR_TRUE;
30749:       LAYOUT_PHASE_TEMP_EXIT();
31031:       nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), PR_FALSE);
30749:       LAYOUT_PHASE_TEMP_REENTER();
30749:       return rv;
    1:     }
    1: 
 6862: #ifdef MOZ_MATHML
 6862:     // If we're a child of MathML, then we should reframe the MathML content.
 6862:     // If we're non-MathML, then we would be wrapped in a block so we need to
 6862:     // check our grandparent in that case.
 6862:     nsIFrame* possibleMathMLAncestor = parentType == nsGkAtoms::blockFrame ? 
 6862:          parentFrame->GetParent() : parentFrame;
 7681:     if (possibleMathMLAncestor->IsFrameOfType(nsIFrame::eMathML)) {
 7681:       *aDidReconstruct = PR_TRUE;
30749:       LAYOUT_PHASE_TEMP_EXIT();
31031:       nsresult rv = RecreateFramesForContent(possibleMathMLAncestor->GetContent(), PR_FALSE);
30749:       LAYOUT_PHASE_TEMP_REENTER();
30749:       return rv;
 7681:     }
 6862: #endif
 6862: 
 7189:     // Undo XUL wrapping if it's no longer needed.
 7189:     // (If we're in the XUL block-wrapping situation, parentFrame is the
 7189:     // wrapper frame.)
 7189:     nsIFrame* grandparentFrame = parentFrame->GetParent();
 7189:     if (grandparentFrame && grandparentFrame->IsBoxFrame() &&
 7189:         (grandparentFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
 7189:         // check if this frame is the only one needing wrapping
 7189:         aChild == AnyKidsNeedBlockParent(parentFrame->GetFirstChild(nsnull)) &&
 7189:         !AnyKidsNeedBlockParent(childFrame->GetNextSibling())) {
 7681:       *aDidReconstruct = PR_TRUE;
30749:       LAYOUT_PHASE_TEMP_EXIT();
31031:       nsresult rv = RecreateFramesForContent(grandparentFrame->GetContent(), PR_TRUE);
30749:       LAYOUT_PHASE_TEMP_REENTER();
30749:       return rv;
 7189:     }
 7189:     
    1:     // Examine the containing-block for the removed content and see if
    1:     // :first-letter style applies.
36805:     nsIFrame* inflowChild = childFrame;
36805:     if (childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
36805:       inflowChild = frameManager->GetPlaceholderFrameFor(childFrame);
36805:       NS_ASSERTION(inflowChild, "No placeholder for out-of-flow?");
36805:     }
36805:     nsIFrame* containingBlock =
36805:       GetFloatContainingBlock(inflowChild->GetParent());
 1254:     PRBool haveFLS = containingBlock && HasFirstLetterStyle(containingBlock);
    1:     if (haveFLS) {
    1:       // Trap out to special routine that handles adjusting a blocks
    1:       // frame tree when first-letter style is present.
    1: #ifdef NOISY_FIRST_LETTER
    1:       printf("ContentRemoved: containingBlock=");
    1:       nsFrame::ListTag(stdout, containingBlock);
    1:       printf(" parentFrame=");
    1:       nsFrame::ListTag(stdout, parentFrame);
    1:       printf(" childFrame=");
    1:       nsFrame::ListTag(stdout, childFrame);
    1:       printf("\n");
    1: #endif
    1: 
    1:       // First update the containing blocks structure by removing the
    1:       // existing letter frames. This makes the subsequent logic
    1:       // simpler.
    1:       RemoveLetterFrames(presContext, mPresShell, frameManager,
    1:                          containingBlock);
    1: 
    1:       // Recover childFrame and parentFrame
36656:       childFrame = aChild->GetPrimaryFrame();
21936:       if (!childFrame || childFrame->GetContent() != aChild) {
21936:         // XXXbz the GetContent() != aChild check is needed due to bug 135040.
21936:         // Remove it once that's fixed.
    1:         frameManager->ClearUndisplayedContentIn(aChild, aContainer);
    1:         return NS_OK;
    1:       }
    1:       parentFrame = childFrame->GetParent();
29580:       parentType = parentFrame->GetType();
    1: 
    1: #ifdef NOISY_FIRST_LETTER
    1:       printf("  ==> revised parentFrame=");
    1:       nsFrame::ListTag(stdout, parentFrame);
    1:       printf(" childFrame=");
    1:       nsFrame::ListTag(stdout, childFrame);
    1:       printf("\n");
    1: #endif
    1:     }
    1: 
    1: #ifdef DEBUG
    1:     if (gReallyNoisyContentUpdates) {
    1:       printf("nsCSSFrameConstructor::ContentRemoved: childFrame=");
    1:       nsFrame::ListTag(stdout, childFrame);
31709:       putchar('\n');
31709:       parentFrame->List(stdout, 0);
    1:     }
    1: #endif
    1: 
36646: 
36646:     // Notify the parent frame that it should delete the frame
    1:     if (childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
36646:       childFrame = frameManager->GetPlaceholderFrameFor(childFrame);
36646:       NS_ASSERTION(childFrame, "Missing placeholder frame for out of flow.");
36646:       parentFrame = childFrame->GetParent();
36646:     }
36646:     rv = frameManager->RemoveFrame(nsLayoutUtils::GetChildListNameFor(childFrame),
    1:                                    childFrame);
36646:     //XXXfr NS_ENSURE_SUCCESS(rv, rv) ?
    1: 
28215:     if (isRoot) {
24659:       mRootElementFrame = nsnull;
16509:       mRootElementStyleFrame = nsnull;
28215:       mDocElementContainingBlock = nsnull;
28215:       mPageSequenceFrame = nsnull;
28215:       mGfxScrollFrame = nsnull;
28215:       mHasRootAbsPosContainingBlock = PR_FALSE;
28215:       mFixedContainingBlock = frameManager->GetRootFrame();
    1:     }
    1: 
24659:     if (haveFLS && mRootElementFrame) {
23461:       RecoverLetterFrames(containingBlock);
    1:     }
    1: 
29501:     // If we're just reconstructing frames for the element, then the
29501:     // following ContentInserted notification on the element will
29580:     // take care of fixing up any adjacent text nodes.  We don't need
29580:     // to do this if the table parent type of our parent type is not
29580:     // eTypeBlock, though, because in that case the whitespace isn't
29580:     // being suppressed due to us anyway.
47669:     if (aContainer && !aChild->IsRootOfAnonymousSubtree() &&
29580:         aFlags != REMOVE_FOR_RECONSTRUCTION &&
29580:         GetParentType(parentType) == eTypeBlock) {
29501:       // Adjacent whitespace-only text nodes might have been suppressed if
29501:       // this node does not have inline ends. Create frames for them now
29501:       // if necessary.
29525:       // Reframe any text node just before the node being removed, if there is
29525:       // one, and if it's not the last child or the first child. If a whitespace
29525:       // textframe was being suppressed and it's now the last child or first
29525:       // child then it can stay suppressed since the parent must be a block
29525:       // and hence it's adjacent to a block end.
47669:       // If aOldNextSibling is null, then the text node before the node being
47669:       // removed is the last node, and we don't need to worry about it.
47669:       if (aOldNextSibling) {
47669:         nsIContent* prevSibling = aOldNextSibling->GetPreviousSibling();
47669:         if (prevSibling && prevSibling->GetPreviousSibling()) {
30749:           LAYOUT_PHASE_TEMP_EXIT();
47669:           ReframeTextIfNeeded(aContainer, prevSibling);
30749:           LAYOUT_PHASE_TEMP_REENTER();
29525:         }
47669:       }
29525:       // Reframe any text node just after the node being removed, if there is
29525:       // one, and if it's not the last child or the first child.
47669:       if (aOldNextSibling && aOldNextSibling->GetNextSibling() &&
47669:           aOldNextSibling->GetPreviousSibling()) {
30749:         LAYOUT_PHASE_TEMP_EXIT();
47669:         ReframeTextIfNeeded(aContainer, aOldNextSibling);
30749:         LAYOUT_PHASE_TEMP_REENTER();
29501:       }
29501:     }
29501: 
    1: #ifdef DEBUG
    1:     if (gReallyNoisyContentUpdates && parentFrame) {
    1:       printf("nsCSSFrameConstructor::ContentRemoved: resulting frame model:\n");
31709:       parentFrame->List(stdout, 0);
    1:     }
    1: #endif
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef DEBUG
    1:   // To ensure that the functions below are only called within
    1:   // |ApplyRenderingChangeToTree|.
    1: static PRBool gInApplyRenderingChangeToTree = PR_FALSE;
    1: #endif
    1: 
    1: static void
    1: DoApplyRenderingChangeToTree(nsIFrame* aFrame,
    1:                              nsIViewManager* aViewManager,
    1:                              nsFrameManager* aFrameManager,
    1:                              nsChangeHint aChange);
    1: 
    1: /**
    1:  * @param aBoundsRect returns the bounds enclosing the areas covered by aFrame and its childre
    1:  * This rect is relative to aFrame's parent
    1:  */
    1: static void
    1: UpdateViewsForTree(nsIFrame* aFrame, nsIViewManager* aViewManager,
    1:                    nsFrameManager* aFrameManager,
  134:                    nsChangeHint aChange)
    1: {
    1:   NS_PRECONDITION(gInApplyRenderingChangeToTree,
    1:                   "should only be called within ApplyRenderingChangeToTree");
    1: 
    1:   nsIView* view = aFrame->GetView();
    1:   if (view) {
    1:     if (aChange & nsChangeHint_SyncFrameView) {
  238:       nsContainerFrame::SyncFrameViewProperties(aFrame->PresContext(),
    1:                                                 aFrame, nsnull, view);
    1:     }
    1:   }
    1: 
    1:   // now do children of frame
    1:   PRInt32 listIndex = 0;
    1:   nsIAtom* childList = nsnull;
    1: 
    1:   do {
    1:     nsIFrame* child = aFrame->GetFirstChild(childList);
    1:     while (child) {
 6521:       if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
 6521:           || (child->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
 7655:         // only do frames that don't have placeholders
49314:         if (nsGkAtoms::placeholderFrame == child->GetType()) {
49314:           // do the out-of-flow frame and its continuations
    1:           nsIFrame* outOfFlowFrame =
    1:             nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
49314:           do {
    1:             DoApplyRenderingChangeToTree(outOfFlowFrame, aViewManager,
    1:                                          aFrameManager, aChange);
49314:           } while (outOfFlowFrame = outOfFlowFrame->GetNextContinuation());
48167:         } else if (childList == nsGkAtoms::popupList) {
48167:           DoApplyRenderingChangeToTree(child, aViewManager,
48167:                                        aFrameManager, aChange);
48167:         } else {  // regular frame
48690:           if ((child->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER) &&
48690:               (aChange & nsChangeHint_RepaintFrame)) {
48690:             FrameLayerBuilder::InvalidateThebesLayerContents(child,
48690:               child->GetOverflowRectRelativeToSelf());
48690:           }
  134:           UpdateViewsForTree(child, aViewManager, aFrameManager, aChange);
    1:         }
    1:       }
    1:       child = child->GetNextSibling();
    1:     }
    1:     childList = aFrame->GetAdditionalChildListName(listIndex++);
    1:   } while (childList);
    1: }
    1: 
    1: static void
    1: DoApplyRenderingChangeToTree(nsIFrame* aFrame,
    1:                              nsIViewManager* aViewManager,
    1:                              nsFrameManager* aFrameManager,
    1:                              nsChangeHint aChange)
    1: {
    1:   NS_PRECONDITION(gInApplyRenderingChangeToTree,
    1:                   "should only be called within ApplyRenderingChangeToTree");
    1: 
   94:   for ( ; aFrame; aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame)) {
    1:     // Get view if this frame has one and trigger an update. If the
    1:     // frame doesn't have a view, find the nearest containing view
    1:     // (adjusting r's coordinate system to reflect the nesting) and
    1:     // update there.
  134:     UpdateViewsForTree(aFrame, aViewManager, aFrameManager, aChange);
    1: 
    1:     // if frame has view, will already be invalidated
24030:     if (aChange & nsChangeHint_RepaintFrame) {
24030:       if (aFrame->IsFrameOfType(nsIFrame::eSVG)) {
24030: #ifdef MOZ_SVG
24030:         if (!(aFrame->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)) {
24030:           nsSVGOuterSVGFrame *outerSVGFrame = nsSVGUtils::GetOuterSVGFrame(aFrame);
24030:           if (outerSVGFrame) {
29068:             // We need this to invalidate frames when their 'filter' or 'marker'
29068:             // property changes. XXX in theory changes to 'marker' should be
29068:             // handled in nsSVGPathGeometryFrame::DidSetStyleContext, but for
29068:             // some reason that's broken.
29068:             //
29068:             // This call is also currently the only mechanism for invalidating
29068:             // the area covered by a <foreignObject> when 'opacity' changes on
29068:             // it or one of its ancestors. (For 'opacity' changes on <image> or
29068:             // a graphical element such as <path>, or on one of their
29068:             // ancestors, this is redundant since
29068:             // nsSVGPathGeometryFrame::DidSetStyleContext also invalidates.)
24030:             outerSVGFrame->UpdateAndInvalidateCoveredRegion(aFrame);
24030:           }
24030:         }
24030: #endif
24030:       } else {
39967:         aFrame->InvalidateOverflowRect();
    1:       }
    1:     }
47740:     if (aChange & nsChangeHint_UpdateOpacityLayer) {
47753:       aFrame->MarkLayersActive();
47740:       aFrame->InvalidateLayer(aFrame->GetOverflowRectRelativeToSelf(),
47740:                               nsDisplayItem::TYPE_OPACITY);
47740:     }
48693:     
48693:     if (aChange & nsChangeHint_UpdateTransformLayer) {
48693:       aFrame->MarkLayersActive();
48693:       aFrame->InvalidateLayer(aFrame->GetOverflowRectRelativeToSelf(),
48693:                               nsDisplayItem::TYPE_TRANSFORM);
48693:     }
    1:   }
24030: }
    1: 
    1: static void
    1: ApplyRenderingChangeToTree(nsPresContext* aPresContext,
    1:                            nsIFrame* aFrame,
    1:                            nsChangeHint aChange)
    1: {
    1:   nsIPresShell *shell = aPresContext->PresShell();
40049:   if (shell->IsPaintingSuppressed()) {
    1:     // Don't allow synchronous rendering changes when painting is turned off.
    1:     aChange = NS_SubtractHint(aChange, nsChangeHint_RepaintFrame);
    1:     if (!aChange) {
    1:       return;
    1:     }
    1:   }
    1: 
    1:   // If the frame's background is propagated to an ancestor, walk up to
    1:   // that ancestor.
40177:   nsStyleContext *bgSC;
40177:   while (!nsCSSRendering::FindBackground(aPresContext, aFrame, &bgSC)) {
    1:     aFrame = aFrame->GetParent();
    1:     NS_ASSERTION(aFrame, "root frame must paint");
    1:   }
    1: 
26050:   nsIViewManager* viewManager = shell->GetViewManager();
    1: 
    1:   // Trigger rendering updates by damaging this frame and any
    1:   // continuations of this frame.
    1: 
    1:   // XXX this needs to detect the need for a view due to an opacity change and deal with it...
    1: 
10730:   nsIViewManager::UpdateViewBatch batch(viewManager);
    1: 
    1: #ifdef DEBUG
    1:   gInApplyRenderingChangeToTree = PR_TRUE;
    1: #endif
    1:   DoApplyRenderingChangeToTree(aFrame, viewManager, shell->FrameManager(),
    1:                                aChange);
    1: #ifdef DEBUG
    1:   gInApplyRenderingChangeToTree = PR_FALSE;
    1: #endif
    1:   
10730:   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
    1: }
    1: 
    1: /**
    1:  * This method invalidates the canvas when frames are removed or added for a
    1:  * node that might have its background propagated to the canvas, i.e., a
    1:  * document root node or an HTML BODY which is a child of the root node.
    1:  *
26471:  * @param aFrame a frame for a content node about to be removed or a frame that
    1:  *               was just created for a content node that was inserted.
    1:  */ 
    1: static void
26216: InvalidateCanvasIfNeeded(nsIPresShell* presShell, nsIContent* node)
26216: {
26216:   NS_PRECONDITION(presShell->GetRootFrame(), "What happened here?");
26216:   NS_PRECONDITION(presShell->GetPresContext(), "Say what?");
26216: 
26216:   //  Note that both in ContentRemoved and ContentInserted the content node
    1:   //  will still have the right parent pointer, so looking at that is ok.
    1:   
    1:   nsIContent* parent = node->GetParent();
    1:   if (parent) {
    1:     // Has a parent; might not be what we want
    1:     nsIContent* grandParent = parent->GetParent();
    1:     if (grandParent) {
    1:       // Has a grandparent, so not what we want
    1:       return;
    1:     }
    1: 
    1:     // Check whether it's an HTML body
    1:     if (node->Tag() != nsGkAtoms::body ||
33329:         !node->IsHTML()) {
    1:       return;
    1:     }
    1:   }
    1: 
    1:   // At this point the node has no parent or it's an HTML <body> child of the
    1:   // root.  We might not need to invalidate in this case (eg we might be in
26216:   // XHTML or something), but chances are we want to.  Play it safe.
26216:   // Invalidate the viewport.
26216: 
 7808:   // Wrap this in a DEFERRED view update batch so we don't try to
 7808:   // flush out layout here
 7808: 
26216:   nsIViewManager::UpdateViewBatch batch(presShell->GetViewManager());
34785:   nsIFrame* rootFrame = presShell->GetRootFrame();
51756:   rootFrame->InvalidateFrameSubtree();
10730:   batch.EndUpdateViewBatch(NS_VMREFRESH_DEFERRED);
    1: }
    1: 
    1: nsresult
31101: nsCSSFrameConstructor::StyleChangeReflow(nsIFrame* aFrame,
31101:                                          nsChangeHint aHint)
    1: {
    1:   // If the frame hasn't even received an initial reflow, then don't
    1:   // send it a style-change reflow!
    1:   if (aFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)
    1:     return NS_OK;
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::StyleChangeReflow: aFrame=");
    1:     nsFrame::ListTag(stdout, aFrame);
    1:     printf("\n");
    1:   }
    1: #endif
    1: 
31101:   nsIPresShell::IntrinsicDirty dirtyType;
31101:   if (aHint & nsChangeHint_ClearDescendantIntrinsics) {
31101:     NS_ASSERTION(aHint & nsChangeHint_ClearAncestorIntrinsics,
31101:                  "Please read the comments in nsChangeHint.h");
31101:     dirtyType = nsIPresShell::eStyleChange;
31101:   } else if (aHint & nsChangeHint_ClearAncestorIntrinsics) {
31101:     dirtyType = nsIPresShell::eTreeChange;
31101:   } else {
31101:     dirtyType = nsIPresShell::eResize;
31101:   }
31101: 
31101:   nsFrameState dirtyBits;
31101:   if (aHint & nsChangeHint_NeedDirtyReflow) {
31101:     dirtyBits = NS_FRAME_IS_DIRTY;
31101:   } else {
31101:     dirtyBits = NS_FRAME_HAS_DIRTY_CHILDREN;
31101:   }
    1: 
 6521:   do {
31101:     mPresShell->FrameNeedsReflow(aFrame, dirtyType, dirtyBits);
31101:     aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame);
 6521:   } while (aFrame);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CharacterDataChanged(nsIContent* aContent,
31131:                                             CharacterDataChangeInfo* aInfo)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
    1:   nsresult      rv = NS_OK;
    1: 
29809:   if ((aContent->HasFlag(NS_CREATE_FRAME_IF_NON_WHITESPACE) &&
29809:        !aContent->TextIsOnlyWhitespace()) ||
29809:       (aContent->HasFlag(NS_REFRAME_IF_WHITESPACE) &&
29809:        aContent->TextIsOnlyWhitespace())) {
27311: #ifdef DEBUG
36656:     nsIFrame* frame = aContent->GetPrimaryFrame();
27311:     NS_ASSERTION(!frame || !frame->IsGeneratedContentFrame(),
27311:                  "Bit should never be set on generated content");
27311: #endif
30749:     LAYOUT_PHASE_TEMP_EXIT();
31031:     nsresult rv = RecreateFramesForContent(aContent, PR_FALSE);
30749:     LAYOUT_PHASE_TEMP_REENTER();
30749:     return rv;
27311:   }
27311: 
    1:   // Find the child frame
36656:   nsIFrame* frame = aContent->GetPrimaryFrame();
    1: 
    1:   // Notify the first frame that maps the content. It will generate a reflow
    1:   // command
    1: 
    1:   // It's possible the frame whose content changed isn't inserted into the
    1:   // frame hierarchy yet, or that there is no frame that maps the content
    1:   if (nsnull != frame) {
    1: #if 0
    1:     NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
    1:        ("nsCSSFrameConstructor::CharacterDataChanged: content=%p[%s] subcontent=%p frame=%p",
    1:         aContent, ContentTag(aContent, 0),
    1:         aSubContent, frame));
    1: #endif
    1: 
    1:     // Special check for text content that is a child of a letter frame.  If
    1:     // this happens, we should remove the letter frame, do whatever we're
    1:     // planning to do with this notification, then put the letter frame back.
28215:     // Note that this is basically what RecreateFramesForContent ends up doing;
28215:     // the reason we dont' want to call that here is that our text content
28215:     // could be native anonymous, in which case RecreateFramesForContent would
28215:     // completely barf on it.  And recreating the non-anonymous ancestor would
28215:     // just lead us to come back into this notification (e.g. if quotes or
28215:     // counters are involved), leading to a loop.
    1:     nsIFrame* block = GetFloatContainingBlock(frame);
    1:     PRBool haveFirstLetterStyle = PR_FALSE;
    1:     if (block) {
    1:       // See if the block has first-letter style applied to it.
 1254:       haveFirstLetterStyle = HasFirstLetterStyle(block);
    1:       if (haveFirstLetterStyle) {
    1:         RemoveLetterFrames(mPresShell->GetPresContext(), mPresShell,
    1:                            mPresShell->FrameManager(), block);
    1:         // Reget |frame|, since we might have killed it.
    1:         // Do we really need to call CharacterDataChanged in this case, though?
36656:         frame = aContent->GetPrimaryFrame();
    1:         NS_ASSERTION(frame, "Should have frame here!");
    1:       }
    1:     }
    1: 
31131:     frame->CharacterDataChanged(aInfo);
    1: 
    1:     if (haveFirstLetterStyle) {
23461:       RecoverLetterFrames(block);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
39965: NS_DECLARE_FRAME_PROPERTY(ChangeListProperty, nsnull)
39965: 
    1: nsresult
    1: nsCSSFrameConstructor::ProcessRestyledFrames(nsStyleChangeList& aChangeList)
    1: {
23652:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
23652:                "Someone forgot a script blocker");
    1:   PRInt32 count = aChangeList.Count();
    1:   if (!count)
    1:     return NS_OK;
    1: 
 6467:   // Make sure to not rebuild quote or counter lists while we're
 6467:   // processing restyles
 6467:   BeginUpdate();
 6467: 
30522:   nsPresContext* presContext = mPresShell->GetPresContext();
39965:   FramePropertyTable* propTable = presContext->PropertyTable();
    1: 
    1:   // Mark frames so that we skip frames that die along the way, bug 123049.
    1:   // A frame can be in the list multiple times with different hints. Further
    1:   // optmization is possible if nsStyleChangeList::AppendChange could coalesce
    1:   PRInt32 index = count;
    1: 
    1:   while (0 <= --index) {
    1:     const nsStyleChangeData* changeData;
    1:     aChangeList.ChangeAt(index, &changeData);
    1:     if (changeData->mFrame) {
39965:       propTable->Set(changeData->mFrame, ChangeListProperty(),
39965:                      NS_INT32_TO_PTR(1));
    1:     }
    1:   }
    1: 
    1:   index = count;
30522:   PRBool didInvalidate = PR_FALSE;
30522:   PRBool didReflow = PR_FALSE;
30522: 
    1:   while (0 <= --index) {
    1:     nsIFrame* frame;
    1:     nsIContent* content;
    1:     nsChangeHint hint;
    1:     aChangeList.ChangeAt(index, frame, content, hint);
31101: 
31101:     NS_ASSERTION(!(hint & nsChangeHint_ReflowFrame) ||
31101:                  (hint & nsChangeHint_NeedReflow),
31101:                  "Reflow hint bits set without actually asking for a reflow");
31101: 
21936:     if (frame && frame->GetContent() != content) {
36653:       // XXXbz this is due to image maps messing with the primary frame of
36653:       // <area>s.  See bug 135040.  Remove this block once that's fixed.
21936:       frame = nsnull;
21936:       if (!(hint & nsChangeHint_ReconstructFrame)) {
21936:         continue;
21936:       }
21936:     }
    1: 
    1:     // skip any frame that has been destroyed due to a ripple effect
    1:     if (frame) {
39965:       if (!propTable->Get(frame, ChangeListProperty()))
    1:         continue;
    1:     }
    1: 
    1:     if (hint & nsChangeHint_ReconstructFrame) {
31031:       RecreateFramesForContent(content, PR_FALSE);
    1:     } else {
    1:       NS_ASSERTION(frame, "This shouldn't happen");
16411: #ifdef MOZ_SVG
16411:       if (hint & nsChangeHint_UpdateEffects) {
19948:         nsSVGEffects::UpdateEffects(frame);
16411:       }
16411: #endif
31101:       if (hint & nsChangeHint_NeedReflow) {
31101:         StyleChangeReflow(frame, hint);
30522:         didReflow = PR_TRUE;
    1:       }
47740:       if (hint & (nsChangeHint_RepaintFrame | nsChangeHint_SyncFrameView |
48693:                   nsChangeHint_UpdateOpacityLayer | nsChangeHint_UpdateTransformLayer)) {
30522:         ApplyRenderingChangeToTree(presContext, frame, hint);
30522:         didInvalidate = PR_TRUE;
    1:       }
    1:       if (hint & nsChangeHint_UpdateCursor) {
52492:         mPresShell->SynthesizeMouseMove(PR_FALSE);
    1:       }
    1:     }
    1:   }
    1: 
 6467:   EndUpdate();
 6467: 
30522:   if (didInvalidate && !didReflow) {
30522:     // RepaintFrame changes can indicate changes in opacity etc which
30522:     // can require plugin clipping to change. If we requested a reflow,
30522:     // we don't need to do this since the reflow will do it for us.
30522:     nsIFrame* rootFrame = mPresShell->FrameManager()->GetRootFrame();
37502:     nsRootPresContext* rootPC = presContext->GetRootPresContext();
37502:     if (rootPC) {
47756:       rootPC->RequestUpdatePluginGeometry(rootFrame);
37502:     }
30522:   }
30522: 
 6739:   // cleanup references and verify the style tree.  Note that the latter needs
 6739:   // to happen once we've processed the whole list, since until then the tree
 6739:   // is not in fact in a consistent state.
    1:   index = count;
    1:   while (0 <= --index) {
    1:     const nsStyleChangeData* changeData;
    1:     aChangeList.ChangeAt(index, &changeData);
    1:     if (changeData->mFrame) {
39965:       propTable->Delete(changeData->mFrame, ChangeListProperty());
    1:     }
 6739: 
 6739: #ifdef DEBUG
 6739:     // reget frame from content since it may have been regenerated...
 6739:     if (changeData->mContent) {
36656:       nsIFrame* frame = changeData->mContent->GetPrimaryFrame();
 6739:       if (frame) {
 6739:         mPresShell->FrameManager()->DebugVerifyStyleTree(frame);
 6739:       }
 6739:     } else {
 6739:       NS_WARNING("Unable to test style tree integrity -- no content node");
 6739:     }
 6739: #endif
    1:   }
    1: 
    1:   aChangeList.Clear();
    1:   return NS_OK;
    1: }
    1: 
    1: void
42329: nsCSSFrameConstructor::RestyleElement(Element        *aElement,
    1:                                       nsIFrame       *aPrimaryFrame,
43790:                                       nsChangeHint   aMinHint,
43794:                                       RestyleTracker& aRestyleTracker,
43794:                                       PRBool          aRestyleDescendants)
    1: {
42329:   NS_ASSERTION(aPrimaryFrame == aElement->GetPrimaryFrame(),
11409:                "frame/content mismatch");
42329:   if (aPrimaryFrame && aPrimaryFrame->GetContent() != aElement) {
36653:     // XXXbz this is due to image maps messing with the primary frame pointer
36653:     // of <area>s.  See bug 135040.  We can remove this block once that's fixed.
21936:     aPrimaryFrame = nsnull;
21936:   }
42329:   NS_ASSERTION(!aPrimaryFrame || aPrimaryFrame->GetContent() == aElement,
11409:                "frame/content mismatch");
11409: 
    1:   if (aMinHint & nsChangeHint_ReconstructFrame) {
42329:     RecreateFramesForContent(aElement, PR_FALSE);
    1:   } else if (aPrimaryFrame) {
    1:     nsStyleChangeList changeList;
11409:     mPresShell->FrameManager()->
43790:       ComputeStyleChangeFor(aPrimaryFrame, &changeList, aMinHint,
43794:                             aRestyleTracker, aRestyleDescendants);
    1:     ProcessRestyledFrames(changeList);
    1:   } else {
    1:     // no frames, reconstruct for content
42329:     MaybeRecreateFramesForElement(aElement);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ContentStatesChanged(nsIContent* aContent1,
    1:                                             nsIContent* aContent2,
    1:                                             PRInt32 aStateMask) 
    1: {
42323:   // XXXbz it would be good if this function only took Elements, but
42323:   // we'd have to make ESM guarantee that usefully.
42323:   if (NS_LIKELY(aContent1 && aContent1->IsElement())) {
42323:     DoContentStateChanged(aContent1->AsElement(), aStateMask);
42323:   }
42323:   if (aContent2 && aContent2->IsElement()) {
42323:     DoContentStateChanged(aContent2->AsElement(), aStateMask);
42323:   }
    1:   return NS_OK;
    1: }
    1: 
    1: void
42323: nsCSSFrameConstructor::DoContentStateChanged(Element* aElement,
    1:                                              PRInt32 aStateMask) 
    1: {
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1:   nsPresContext *presContext = mPresShell->GetPresContext();
    1:   NS_ASSERTION(styleSet, "couldn't get style set");
    1: 
    1:   nsChangeHint hint = NS_STYLE_HINT_NONE;
    1:   // Any change to a content state that affects which frames we construct
    1:   // must lead to a frame reconstruct here if we already have a frame.
    1:   // Note that we never decide through non-CSS means to not create frames
    1:   // based on content states, so if we already don't have a frame we don't
    1:   // need to force a reframe -- if it's needed, the HasStateDependentStyle
    1:   // call will handle things.
42323:   nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
    1:   if (primaryFrame) {
    1:     // If it's generated content, ignore LOADING/etc state changes on it.
    1:     if (!primaryFrame->IsGeneratedContentFrame() &&
    1:         (aStateMask & (NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED |
    1:                        NS_EVENT_STATE_SUPPRESSED | NS_EVENT_STATE_LOADING))) {
    1:       hint = nsChangeHint_ReconstructFrame;
    1:     } else {
    1:       PRUint8 app = primaryFrame->GetStyleDisplay()->mAppearance;
    1:       if (app) {
    1:         nsITheme *theme = presContext->GetTheme();
    1:         if (theme && theme->ThemeSupportsWidget(presContext,
    1:                                                 primaryFrame, app)) {
    1:           PRBool repaint = PR_FALSE;
    1:           theme->WidgetStateChanged(primaryFrame, app, nsnull, &repaint);
    1:           if (repaint) {
    1:             NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
40075:   nsRestyleHint rshint = 
42323:     styleSet->HasStateDependentStyle(presContext, aElement, aStateMask);
    1:       
22471:   if ((aStateMask & NS_EVENT_STATE_HOVER) && rshint != 0) {
22471:     ++mHoverGeneration;
22471:   }
22471: 
40172:   if (aStateMask & NS_EVENT_STATE_VISITED) {
40172:     // Exposing information to the page about whether the link is
40172:     // visited or not isn't really something we can worry about here.
40172:     // FIXME: We could probably do this a bit better.
40172:     NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
40172:   }
40172: 
42323:   PostRestyleEvent(aElement, rshint, hint);
    1: }
    1: 
35534: void
51352: nsCSSFrameConstructor::AttributeWillChange(Element* aElement,
35534:                                            PRInt32 aNameSpaceID,
35534:                                            nsIAtom* aAttribute,
35534:                                            PRInt32 aModType)
35534: {
40075:   nsRestyleHint rshint =
42321:     mPresShell->StyleSet()->HasAttributeDependentStyle(mPresShell->GetPresContext(),
42323:                                                        aElement,
35534:                                                        aAttribute,
35534:                                                        aModType,
35534:                                                        PR_FALSE);
42323:   PostRestyleEvent(aElement, rshint, NS_STYLE_HINT_NONE);
35534: }
35534: 
35534: void
51350: nsCSSFrameConstructor::AttributeChanged(Element* aElement,
    1:                                         PRInt32 aNameSpaceID,
    1:                                         nsIAtom* aAttribute,
35535:                                         PRInt32 aModType)
    1: {
    1:   // Hold onto the PresShell to prevent ourselves from being destroyed.
    1:   // XXXbz how, exactly, would this attribute change cause us to be
    1:   // destroyed from inside this function?
    1:   nsCOMPtr<nsIPresShell> shell = mPresShell;
    1: 
    1:   // Get the frame associated with the content which is the highest in the frame tree
42323:   nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
    1: 
    1: #if 0
    1:   NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
    1:      ("HTMLStyleSheet::AttributeChanged: content=%p[%s] frame=%p",
42323:       aContent, ContentTag(aElement, 0), frame));
    1: #endif
    1: 
    1:   // the style tag has its own interpretation based on aHint 
42323:   nsChangeHint hint = aElement->GetAttributeChangeHint(aAttribute, aModType);
    1: 
    1:   PRBool reframe = (hint & nsChangeHint_ReconstructFrame) != 0;
    1: 
    1: #ifdef MOZ_XUL
    1:   // The following listbox widget trap prevents offscreen listbox widget
    1:   // content from being removed and re-inserted (which is what would
    1:   // happen otherwise).
    1:   if (!primaryFrame && !reframe) {
    1:     PRInt32 namespaceID;
    1:     nsIAtom* tag =
42323:       mDocument->BindingManager()->ResolveTag(aElement, &namespaceID);
    1: 
    1:     if (namespaceID == kNameSpaceID_XUL &&
    1:         (tag == nsGkAtoms::listitem ||
    1:          tag == nsGkAtoms::listcell))
35534:       return;
    1:   }
    1: 
    1:   if (aAttribute == nsGkAtoms::tooltiptext ||
    1:       aAttribute == nsGkAtoms::tooltip) 
    1:   {
    1:     nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
    1:     if (rootBox) {
    1:       if (aModType == nsIDOMMutationEvent::REMOVAL)
42323:         rootBox->RemoveTooltipSupport(aElement);
    1:       if (aModType == nsIDOMMutationEvent::ADDITION)
42323:         rootBox->AddTooltipSupport(aElement);
    1:     }
    1:   }
    1: 
    1: #endif // MOZ_XUL
    1: 
    1:   if (primaryFrame) {
    1:     // See if we have appearance information for a theme.
    1:     const nsStyleDisplay* disp = primaryFrame->GetStyleDisplay();
    1:     if (disp->mAppearance) {
    1:       nsPresContext* presContext = mPresShell->GetPresContext();
    1:       nsITheme *theme = presContext->GetTheme();
 4036:       if (theme && theme->ThemeSupportsWidget(presContext, primaryFrame, disp->mAppearance)) {
    1:         PRBool repaint = PR_FALSE;
 4036:         theme->WidgetStateChanged(primaryFrame, disp->mAppearance, aAttribute, &repaint);
    1:         if (repaint)
    1:           NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
    1:       }
    1:     }
    1:    
    1:     // let the frame deal with it now, so we don't have to deal later
35534:     primaryFrame->AttributeChanged(aNameSpaceID, aAttribute, aModType);
    1:     // XXXwaterson should probably check for special IB siblings
    1:     // here, and propagate the AttributeChanged notification to
    1:     // them, as well. Currently, inline frames don't do anything on
    1:     // this notification, so it's not that big a deal.
    1:   }
    1: 
    1:   // See if we can optimize away the style re-resolution -- must be called after
    1:   // the frame's AttributeChanged() in case it does something that affects the style
42321:   nsRestyleHint rshint =
42321:     mPresShell->StyleSet()->HasAttributeDependentStyle(mPresShell->GetPresContext(),
42323:                                                        aElement,
    1:                                                        aAttribute,
 3410:                                                        aModType,
35534:                                                        PR_TRUE);
    1: 
42323:   PostRestyleEvent(aElement, rshint, hint);
    1: }
    1: 
    1: void
11855: nsCSSFrameConstructor::BeginUpdate() {
29072:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
29072:                "Someone forgot a script blocker");
29072: 
11855:   ++mUpdateCount;
11855: }
11855: 
11855: void
    1: nsCSSFrameConstructor::EndUpdate()
    1: {
    1:   if (mUpdateCount == 1) {
    1:     // This is the end of our last update.  Before we decrement
    1:     // mUpdateCount, recalc quotes and counters as needed.
    1: 
  550:     RecalcQuotesAndCounters();
  550:     NS_ASSERTION(mUpdateCount == 1, "Odd update count");
  550:   }
22957:   --mUpdateCount;
  550: }
  550: 
  550: void
  550: nsCSSFrameConstructor::RecalcQuotesAndCounters()
  550: {
    1:   if (mQuotesDirty) {
    1:     mQuotesDirty = PR_FALSE;
    1:     mQuoteList.RecalcAll();
    1:   }
    1: 
    1:   if (mCountersDirty) {
    1:     mCountersDirty = PR_FALSE;
    1:     mCounterManager.RecalcAll();
    1:   }
    1: 
    1:   NS_ASSERTION(!mQuotesDirty, "Quotes updates will be lost");
    1:   NS_ASSERTION(!mCountersDirty, "Counter updates will be lost");  
    1: }
    1: 
    1: void
26803: nsCSSFrameConstructor::WillDestroyFrameTree()
    1: {
    1: #if defined(DEBUG_dbaron_off)
    1:   mCounterManager.Dump();
    1: #endif
    1: 
    1:   mIsDestroyingFrameTree = PR_TRUE;
    1: 
    1:   // Prevent frame tree destruction from being O(N^2)
    1:   mQuoteList.Clear();
    1:   mCounterManager.Clear();
    1: 
50365:   // Remove our presshell as a style flush observer.  But leave
50365:   // mObservingRefreshDriver true so we don't readd to it even if someone tries
50365:   // to post restyle events on us from this point on for some reason.
36797:   mPresShell->GetPresContext()->RefreshDriver()->
50365:     RemoveStyleFlushObserver(mPresShell);
    1: }
    1: 
    1: //STATIC
    1: 
    1: // XXXbz I'd really like this method to go away. Once we have inline-block and
    1: // I can just use that for sized broken images, that can happen, maybe.
    1: void nsCSSFrameConstructor::GetAlternateTextFor(nsIContent*    aContent,
    1:                                                 nsIAtom*       aTag,  // content object's tag
    1:                                                 nsXPIDLString& aAltText)
    1: {
    1:   // The "alt" attribute specifies alternate text that is rendered
    1:   // when the image can not be displayed
    1: 
    1:   // If there's no "alt" attribute, and aContent is an input    
    1:   // element, then use the value of the "value" attribute
    1:   if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::alt, aAltText) &&
    1:       nsGkAtoms::input == aTag) {
    1:     // If there's no "value" attribute either, then use the localized string 
    1:     // for "Submit" as the alternate text.
    1:     if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::value, aAltText)) {
    1:       nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
    1:                                          "Submit", aAltText);      
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateContinuingOuterTableFrame(nsIPresShell*    aPresShell,
    1:                                                        nsPresContext*  aPresContext,
    1:                                                        nsIFrame*        aFrame,
    1:                                                        nsIFrame*        aParentFrame,
    1:                                                        nsIContent*      aContent,
    1:                                                        nsStyleContext*  aStyleContext,
    1:                                                        nsIFrame**       aContinuingFrame)
    1: {
    1:   nsIFrame* newFrame = NS_NewTableOuterFrame(aPresShell, aStyleContext);
    1: 
    1:   if (newFrame) {
    1:     newFrame->Init(aContent, aParentFrame, aFrame);
23395:     nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:     // Create a continuing inner table frame, and if there's a caption then
    1:     // replicate the caption
    1:     nsFrameItems  newChildFrames;
    1: 
    1:     nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
    1:     if (childFrame) {
    1:       nsIFrame* continuingTableFrame;
    1:       nsresult rv = CreateContinuingFrame(aPresContext, childFrame, newFrame,
    1:                                           &continuingTableFrame);
    1:       if (NS_FAILED(rv)) {
    1:         newFrame->Destroy();
    1:         *aContinuingFrame = nsnull;
    1:         return rv;
    1:       }
    1:       newChildFrames.AddChild(continuingTableFrame);
    1:       
    1:       NS_ASSERTION(!childFrame->GetNextSibling(),"there can be only one inner table frame");
    1:     }
    1: 
    1:     // Set the outer table's initial child list
30785:     newFrame->SetInitialChildList(nsnull, newChildFrames);
    1:     
    1:     *aContinuingFrame = newFrame;
    1:     return NS_OK;
    1:   }
    1:   else {
    1:     *aContinuingFrame = nsnull;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateContinuingTableFrame(nsIPresShell* aPresShell, 
    1:                                                   nsPresContext*  aPresContext,
    1:                                                   nsIFrame*        aFrame,
    1:                                                   nsIFrame*        aParentFrame,
    1:                                                   nsIContent*      aContent,
    1:                                                   nsStyleContext*  aStyleContext,
    1:                                                   nsIFrame**       aContinuingFrame)
    1: {
    1:   nsIFrame* newFrame = NS_NewTableFrame(aPresShell, aStyleContext);
    1: 
    1:   if (newFrame) {
    1:     newFrame->Init(aContent, aParentFrame, aFrame);
23395:     nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:     // Replicate any header/footer frames
    1:     nsFrameItems  childFrames;
    1:     nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
    1:     for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
    1:       // See if it's a header/footer, possibly wrapped in a scroll frame.
    1:       nsTableRowGroupFrame* rowGroupFrame =
37262:         static_cast<nsTableRowGroupFrame*>(childFrame);
    1:       // If the row group was continued, then don't replicate it.
    1:       nsIFrame* rgNextInFlow = rowGroupFrame->GetNextInFlow();
    1:       if (rgNextInFlow) {
    1:         rowGroupFrame->SetRepeatable(PR_FALSE);
    1:       }
    1:       else if (rowGroupFrame->IsRepeatable()) {
    1:         // Replicate the header/footer frame.
    1:         nsTableRowGroupFrame*   headerFooterFrame;
    1:         nsFrameItems            childItems;
    1:         nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                       GetAbsoluteContainingBlock(newFrame),
    1:                                       nsnull);
41931:         state.mSetPrimaryFrames = PR_FALSE;
    1: 
 3233:         headerFooterFrame = static_cast<nsTableRowGroupFrame*>
 3233:                                        (NS_NewTableRowGroupFrame(aPresShell, rowGroupFrame->GetStyleContext()));
    1:         nsIContent* headerFooter = rowGroupFrame->GetContent();
    1:         headerFooterFrame->Init(headerFooter, newFrame, nsnull);
23352:         ProcessChildren(state, headerFooter, rowGroupFrame->GetStyleContext(),
34614:                         headerFooterFrame, PR_TRUE, childItems, PR_FALSE,
34614:                         nsnull);
30785:         NS_ASSERTION(state.mFloatedItems.IsEmpty(), "unexpected floated element");
30785:         headerFooterFrame->SetInitialChildList(nsnull, childItems);
    1:         headerFooterFrame->SetRepeatable(PR_TRUE);
    1: 
    1:         // Table specific initialization
    1:         headerFooterFrame->InitRepeatedFrame(aPresContext, rowGroupFrame);
    1: 
    1:         // XXX Deal with absolute and fixed frames...
    1:         childFrames.AddChild(headerFooterFrame);
    1:       }
    1:     }
    1:     
    1:     // Set the table frame's initial child list
30785:     newFrame->SetInitialChildList(nsnull, childFrames);
    1:     
    1:     *aContinuingFrame = newFrame;
    1:     return NS_OK;
    1:   }
    1:   else {
    1:     *aContinuingFrame = nsnull;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateContinuingFrame(nsPresContext* aPresContext,
    1:                                              nsIFrame*       aFrame,
    1:                                              nsIFrame*       aParentFrame,
    1:                                              nsIFrame**      aContinuingFrame,
    1:                                              PRBool          aIsFluid)
    1: {
    1:   nsIPresShell*              shell = aPresContext->PresShell();
    1:   nsStyleContext*            styleContext = aFrame->GetStyleContext();
    1:   nsIFrame*                  newFrame = nsnull;
    1:   nsresult                   rv = NS_OK;
    1:   nsIFrame*                  nextContinuation = aFrame->GetNextContinuation();
    1:   nsIFrame*                  nextInFlow = aFrame->GetNextInFlow();
    1: 
    1:   // Use the frame type to determine what type of frame to create
    1:   nsIAtom* frameType = aFrame->GetType();
    1:   nsIContent* content = aFrame->GetContent();
    1: 
    1:   NS_ASSERTION(aFrame->GetSplittableType() != NS_FRAME_NOT_SPLITTABLE,
    1:                "why CreateContinuingFrame for a non-splittable frame?");
    1:   
    1:   if (nsGkAtoms::textFrame == frameType) {
    1:     newFrame = NS_NewContinuingTextFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:     
    1:   } else if (nsGkAtoms::inlineFrame == frameType) {
    1:     newFrame = NS_NewInlineFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::blockFrame == frameType) {
    1:     newFrame = NS_NewBlockFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
23167:     }
23167:   
23176: #ifdef MOZ_XUL
23176:   } else if (nsGkAtoms::XULLabelFrame == frameType) {
23947:     newFrame = NS_NewXULLabelFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
23167:     }
23176: #endif  
    1:   } else if (nsGkAtoms::columnSetFrame == frameType) {
    1:     newFrame = NS_NewColumnSetFrame(shell, styleContext, 0);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::positionedInlineFrame == frameType) {
    1:     newFrame = NS_NewPositionedInlineFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1: 
    1:   } else if (nsGkAtoms::pageFrame == frameType) {
18953:     nsIFrame* canvasFrame;
    1:     rv = ConstructPageFrame(shell, aPresContext, aParentFrame, aFrame,
18953:                             newFrame, canvasFrame);
    1:   } else if (nsGkAtoms::tableOuterFrame == frameType) {
    1:     rv = CreateContinuingOuterTableFrame(shell, aPresContext, aFrame, aParentFrame,
    1:                                          content, styleContext, &newFrame);
    1: 
    1:   } else if (nsGkAtoms::tableFrame == frameType) {
    1:     rv = CreateContinuingTableFrame(shell, aPresContext, aFrame, aParentFrame,
    1:                                     content, styleContext, &newFrame);
    1: 
    1:   } else if (nsGkAtoms::tableRowGroupFrame == frameType) {
    1:     newFrame = NS_NewTableRowGroupFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1: 
    1:   } else if (nsGkAtoms::tableRowFrame == frameType) {
    1:     newFrame = NS_NewTableRowFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:       // Create a continuing frame for each table cell frame
    1:       nsFrameItems  newChildList;
    1:       nsIFrame* cellFrame = aFrame->GetFirstChild(nsnull);
    1:       while (cellFrame) {
    1:         // See if it's a table cell frame
    1:         if (IS_TABLE_CELL(cellFrame->GetType())) {
    1:           nsIFrame* continuingCellFrame;
    1:           rv = CreateContinuingFrame(aPresContext, cellFrame, newFrame,
    1:                                      &continuingCellFrame);
    1:           if (NS_FAILED(rv)) {
30785:             newChildList.DestroyFrames();
    1:             newFrame->Destroy();
    1:             *aContinuingFrame = nsnull;
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:           }
    1:           newChildList.AddChild(continuingCellFrame);
    1:         }
    1:         cellFrame = cellFrame->GetNextSibling();
    1:       }
    1:       
    1:       // Set the table cell's initial child list
30785:       newFrame->SetInitialChildList(nsnull, newChildList);
    1:     }
    1: 
    1:   } else if (IS_TABLE_CELL(frameType)) {
 8578:     // Warning: If you change this and add a wrapper frame around table cell
 8578:     // frames, make sure Bug 368554 doesn't regress!
 8578:     // See IsInAutoWidthTableCellForQuirk() in nsImageFrame.cpp.
    1:     newFrame = NS_NewTableCellFrame(shell, styleContext, IsBorderCollapse(aParentFrame));
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:       // Create a continuing area frame
23296:       nsIFrame* continuingBlockFrame;
23176:       nsIFrame* blockFrame = aFrame->GetFirstChild(nsnull);
23176:       rv = CreateContinuingFrame(aPresContext, blockFrame, newFrame,
23296:                                  &continuingBlockFrame);
    1:       if (NS_FAILED(rv)) {
    1:         newFrame->Destroy();
    1:         *aContinuingFrame = nsnull;
    1:         return rv;
    1:       }
    1: 
    1:       // Set the table cell's initial child list
30790:       SetInitialSingleChild(newFrame, continuingBlockFrame);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::lineFrame == frameType) {
    1:     newFrame = NS_NewFirstLineFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1:   
    1:   } else if (nsGkAtoms::letterFrame == frameType) {
    1:     newFrame = NS_NewFirstLetterFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1:     }
    1: 
    1:   } else if (nsGkAtoms::imageFrame == frameType) {
    1:     newFrame = NS_NewImageFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
    1:     }
 9869:   } else if (nsGkAtoms::imageControlFrame == frameType) {
 9869:     newFrame = NS_NewImageControlFrame(shell, styleContext);
 9869: 
 9869:     if (newFrame) {
 9869:       newFrame->Init(content, aParentFrame, aFrame);
 9869:     }    
    1:   } else if (nsGkAtoms::placeholderFrame == frameType) {
    1:     // create a continuing out of flow frame
    1:     nsIFrame* oofFrame = nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
    1:     nsIFrame* oofContFrame;
    1:     rv = CreateContinuingFrame(aPresContext, oofFrame, aParentFrame, &oofContFrame);
    1:     if (NS_FAILED(rv)) {
    1:       *aContinuingFrame = nsnull;
    1:       return rv;
    1:     }
    1:     // create a continuing placeholder frame
 6219:     rv = CreatePlaceholderFrameFor(shell, content, oofContFrame, styleContext,
34912:                                    aParentFrame, aFrame,
34912:                                    aFrame->GetStateBits() & PLACEHOLDER_TYPE_MASK,
34912:                                    &newFrame);
    1:     if (NS_FAILED(rv)) {
    1:       oofContFrame->Destroy();
    1:       *aContinuingFrame = nsnull;
    1:       return rv;
    1:     }
    1:   } else if (nsGkAtoms::fieldSetFrame == frameType) {
    1:     newFrame = NS_NewFieldSetFrame(shell, styleContext);
    1: 
    1:     if (newFrame) {
    1:       newFrame->Init(content, aParentFrame, aFrame);
    1: 
23395:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
    1: 
    1:       // Create a continuing area frame
    1:       // XXXbz we really shouldn't have to do this by hand!
23296:       nsIFrame* continuingBlockFrame;
23176:       nsIFrame* blockFrame = GetFieldSetBlockFrame(aFrame);
23176:       rv = CreateContinuingFrame(aPresContext, blockFrame, newFrame,
23296:                                  &continuingBlockFrame);
    1:       if (NS_FAILED(rv)) {
    1:         newFrame->Destroy();
    1:         *aContinuingFrame = nsnull;
    1:         return rv;
    1:       }
    1:       // Set the fieldset's initial child list
30790:       SetInitialSingleChild(newFrame, continuingBlockFrame);
    1:     }
24414:   } else if (nsGkAtoms::legendFrame == frameType) {
24414:     newFrame = NS_NewLegendFrame(shell, styleContext);
24414: 
24414:     if (newFrame) {
24414:       newFrame->Init(content, aParentFrame, aFrame);
24414:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
24414:     }
    1:   } else {
    1:     NS_NOTREACHED("unexpected frame type");
    1:     *aContinuingFrame = nsnull;
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   *aContinuingFrame = newFrame;
    1: 
    1:   if (!newFrame) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // Init() set newFrame to be a fluid continuation of aFrame.
    1:   // If we want a non-fluid continuation, we need to call SetPrevContinuation()
    1:   // to reset NS_FRAME_IS_FLUID_CONTINUATION.
    1:   if (!aIsFluid) {
    1:     newFrame->SetPrevContinuation(aFrame);
    1:   }
    1: 
    1:   // A continuation of generated content is also generated content
    1:   if (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) {
    1:     newFrame->AddStateBits(NS_FRAME_GENERATED_CONTENT);
    1:   }
    1: 
 6521:   // A continuation of an out-of-flow is also an out-of-flow
 6521:   if (aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
 6521:     newFrame->AddStateBits(NS_FRAME_OUT_OF_FLOW);
 6521:   }
 6521: 
    1:   if (nextInFlow) {
    1:     nextInFlow->SetPrevInFlow(newFrame);
    1:     newFrame->SetNextInFlow(nextInFlow);
    1:   } else if (nextContinuation) {
    1:     nextContinuation->SetPrevContinuation(newFrame);
    1:     newFrame->SetNextContinuation(nextContinuation);
    1:   }
32841: 
32841:   NS_POSTCONDITION(!newFrame->GetNextSibling(), "unexpected sibling");
    1:   return NS_OK;
    1: }
    1: 
 4347: nsresult
 4347: nsCSSFrameConstructor::ReplicateFixedFrames(nsPageContentFrame* aParentFrame)
 4347: {
18953:   // Now deal with fixed-pos things....  They should appear on all pages,
18953:   // so we want to move over the placeholders when processing the child
18953:   // of the pageContentFrame.
 4347: 
 4347:   nsIFrame* prevPageContentFrame = aParentFrame->GetPrevInFlow();
    1:   if (!prevPageContentFrame) {
 4347:     return NS_OK;
 4347:   }
18953:   nsIFrame* canvasFrame = aParentFrame->GetFirstChild(nsnull);
18953:   nsIFrame* prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
18953:   if (!canvasFrame || !prevCanvasFrame) {
 4366:     // document's root element frame missing
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   nsFrameItems fixedPlaceholders;
    1:   nsIFrame* firstFixed = prevPageContentFrame->GetFirstChild(nsGkAtoms::fixedList);
    1:   if (!firstFixed) {
    1:     return NS_OK;
    1:   }
    1: 
 8933:   // Don't allow abs-pos descendants of the fixed content to escape the content.
 8933:   // This should not normally be possible (because fixed-pos elements should
 8933:   // be absolute containers) but fixed-pos tables currently aren't abs-pos
 8933:   // containers.
    1:   nsFrameConstructorState state(mPresShell, aParentFrame,
 8933:                                 nsnull,
24659:                                 mRootElementFrame);
41931:   state.mSetPrimaryFrames = PR_FALSE;
    1: 
 4366:   // Iterate across fixed frames and replicate each whose placeholder is a
 4366:   // descendant of aFrame. (We don't want to explicitly copy placeholders that
 4366:   // are within fixed frames, because that would cause duplicates on the new
 4366:   // page - bug 389619)
    1:   for (nsIFrame* fixed = firstFixed; fixed; fixed = fixed->GetNextSibling()) {
39668:     nsIFrame* prevPlaceholder = mPresShell->FrameManager()->GetPlaceholderFrameFor(fixed);
 4366:     if (prevPlaceholder &&
18953:         nsLayoutUtils::IsProperAncestorFrame(prevCanvasFrame, prevPlaceholder)) {
 4347:       nsresult rv = ConstructFrame(state, fixed->GetContent(),
18953:                                    canvasFrame, fixedPlaceholders);
 4347:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
 4366:   }
    1: 
    1:   // Add the placeholders to our primary child list.
18953:   // XXXbz this is a little screwed up, since the fixed frames will have 
18953:   // broken auto-positioning. Oh, well.
18953:   NS_ASSERTION(!canvasFrame->GetFirstChild(nsnull),
 4347:                "leaking frames; doc root continuation must be empty");
30785:   canvasFrame->SetInitialChildList(nsnull, fixedPlaceholders);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::GetInsertionPoint(nsIFrame*     aParentFrame,
    1:                                          nsIContent*   aChildContent,
    1:                                          nsIFrame**    aInsertionPoint,
    1:                                          PRBool*       aMultiple)
    1: {
    1:   // Make the insertion point be the parent frame by default, in case
    1:   // we have to bail early.
    1:   *aInsertionPoint = aParentFrame;
    1: 
    1:   nsIContent* container = aParentFrame->GetContent();
    1:   if (!container)
    1:     return NS_OK;
    1: 
    1:   nsBindingManager *bindingManager = mDocument->BindingManager();
    1: 
    1:   nsIContent* insertionElement;
    1:   if (aChildContent) {
    1:     // We've got an explicit insertion child. Check to see if it's
    1:     // anonymous.
    1:     if (aChildContent->GetBindingParent() == container) {
    1:       // This child content is anonymous. Don't use the insertion
    1:       // point, since that's only for the explicit kids.
    1:       return NS_OK;
    1:     }
    1: 
    1:     PRUint32 index;
    1:     insertionElement = bindingManager->GetInsertionPoint(container,
    1:                                                          aChildContent,
    1:                                                          &index);
    1:   }
    1:   else {
    1:     PRBool multiple;
    1:     PRUint32 index;
    1:     insertionElement = bindingManager->GetSingleInsertionPoint(container,
    1:                                                                &index,
    1:                                                                &multiple);
    1:     if (multiple && aMultiple)
    1:       *aMultiple = multiple; // Record the fact that filters are in use.
    1:   }
    1: 
    1:   if (insertionElement) {
36656:     nsIFrame* insertionPoint = insertionElement->GetPrimaryFrame();
    1:     if (insertionPoint) {
    1:       // Use the content insertion frame of the insertion point.
    1:       insertionPoint = insertionPoint->GetContentInsertionFrame();
    1:       if (insertionPoint && insertionPoint != aParentFrame) 
    1:         GetInsertionPoint(insertionPoint, aChildContent, aInsertionPoint, aMultiple);
    1:     }
    1:     else {
    1:       // There was no frame created yet for the insertion point.
    1:       *aInsertionPoint = nsnull;
    1:     }
    1:   }
    1: 
    1:   // fieldsets have multiple insertion points.  Note that we might
    1:   // have to look at insertionElement here...
    1:   if (aMultiple && !*aMultiple) {
    1:     nsIContent* content = insertionElement ? insertionElement : container;
33329:     if (content->IsHTML() &&
    1:         content->Tag() == nsGkAtoms::fieldset) {
    1:       *aMultiple = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Capture state for the frame tree rooted at the frame associated with the
    1: // content object, aContent
    1: nsresult
    1: nsCSSFrameConstructor::CaptureStateForFramesOf(nsIContent* aContent,
    1:                                                nsILayoutHistoryState* aHistoryState)
    1: {
36656:   nsIFrame* frame = aContent->GetPrimaryFrame();
28215:   if (frame == mRootElementFrame) {
28215:     frame = mFixedContainingBlock;
28215:   }
    1:   if (frame) {
    1:     CaptureStateFor(frame, aHistoryState);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Capture state for the frame tree rooted at aFrame.
    1: nsresult
    1: nsCSSFrameConstructor::CaptureStateFor(nsIFrame* aFrame,
    1:                                        nsILayoutHistoryState* aHistoryState)
    1: {
    1:   if (aFrame && aHistoryState) {
    1:     mPresShell->FrameManager()->CaptureFrameState(aFrame, aHistoryState);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
42329: nsCSSFrameConstructor::MaybeRecreateFramesForElement(Element* aElement)
    1: {
    1:   nsresult result = NS_OK;
    1:   nsFrameManager *frameManager = mPresShell->FrameManager();
    1: 
42329:   nsStyleContext *oldContext = frameManager->GetUndisplayedContent(aElement);
    1:   if (oldContext) {
    1:     // The parent has a frame, so try resolving a new context.
    1:     nsRefPtr<nsStyleContext> newContext = mPresShell->StyleSet()->
42329:       ResolveStyleFor(aElement, oldContext->GetParent());
42329: 
42329:     frameManager->ChangeUndisplayedContent(aElement, newContext);
    1:     if (newContext->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_NONE) {
42329:       result = RecreateFramesForContent(aElement, PR_FALSE);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
27311: static nsIFrame*
27311: FindFirstNonWhitespaceChild(nsIFrame* aParentFrame)
27311: {
27311:   nsIFrame* f = aParentFrame->GetFirstChild(nsnull);
27311:   while (f && f->GetType() == nsGkAtoms::textFrame &&
27311:          f->GetContent()->TextIsOnlyWhitespace()) {
27311:     f = f->GetNextSibling();
27311:   }
27311:   return f;
27311: }
27311: 
27311: static nsIFrame*
27311: FindNextNonWhitespaceSibling(nsIFrame* aFrame)
27311: {
27311:   nsIFrame* f = aFrame;
27311:   do {
27311:     f = f->GetNextSibling();
27311:   } while (f && f->GetType() == nsGkAtoms::textFrame &&
27311:            f->GetContent()->TextIsOnlyWhitespace());
27311:   return f;
27311: }
27311: 
    1: PRBool
26471: nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval(nsIFrame* aFrame,
 4696:                                                              nsresult* aResult)
 4696: {
 4696:   NS_PRECONDITION(aFrame, "Must have a frame");
 4696:   NS_PRECONDITION(aFrame->GetParent(), "Frame shouldn't be root");
 4696:   NS_PRECONDITION(aResult, "Null out param?");
 4696:   NS_PRECONDITION(aFrame == aFrame->GetFirstContinuation(),
36656:                   "aFrame not the result of GetPrimaryFrame()?");
 4696: 
 4696:   if (IsFrameSpecial(aFrame)) {
 4696:     // The removal functions can't handle removal of an {ib} split directly; we
 4696:     // need to rebuild the containing block.
    1: #ifdef DEBUG
    1:     if (gNoisyContentUpdates) {
26471:       printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
 4696:              "frame=");
    1:       nsFrame::ListTag(stdout, aFrame);
    1:       printf(" is special\n");
    1:     }
    1: #endif
 4696: 
    1:     *aResult = ReframeContainingBlock(aFrame);
    1:     return PR_TRUE;
    1:   }
    1: 
29110:   if (aFrame->GetType() == nsGkAtoms::legendFrame &&
29110:       aFrame->GetParent()->GetType() == nsGkAtoms::fieldSetFrame) {
29110:     // When we remove the legend for a fieldset, we should reframe
29110:     // the fieldset to ensure another legend is used, if there is one
31031:     *aResult = RecreateFramesForContent(aFrame->GetParent()->GetContent(), PR_FALSE);
29110:     return PR_TRUE;
29110:   }
29110: 
26471:   // Now check for possibly needing to reconstruct due to a pseudo parent
26471:   nsIFrame* inFlowFrame =
26471:     (aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) ?
26471:       mPresShell->FrameManager()->GetPlaceholderFrameFor(aFrame) : aFrame;
26471:   NS_ASSERTION(inFlowFrame, "How did that happen?");
26471:   nsIFrame* parent = inFlowFrame->GetParent();
26471:   if (IsTablePseudo(parent)) {
27311:     if (FindFirstNonWhitespaceChild(parent) == inFlowFrame ||
27311:         !FindNextNonWhitespaceSibling(inFlowFrame->GetLastContinuation()) ||
26471:         // If we're a table-column-group, then the GetFirstChild check above is
26471:         // not going to catch cases when we're the first child.
26471:         (inFlowFrame->GetType() == nsGkAtoms::tableColGroupFrame &&
26471:          parent->GetFirstChild(nsGkAtoms::colGroupList) == inFlowFrame) ||
26471:         // Similar if we're a table-caption.
26471:         (inFlowFrame->GetType() == nsGkAtoms::tableCaptionFrame &&
26471:          parent->GetFirstChild(nsGkAtoms::captionList) == inFlowFrame)) {
26471:       // We're the first or last frame in the pseudo.  Need to reframe.
26471:       // Good enough to recreate frames for |parent|'s content
31031:       *aResult = RecreateFramesForContent(parent->GetContent(), PR_TRUE);
26471:       return PR_TRUE;
26471:     }
26471:   }
26471: 
26607:   // Might need to reconstruct things if this frame's nextSibling is a table
26607:   // pseudo, since removal of this frame might mean that this pseudo needs to
26607:   // get merged with the frame's prevSibling.
26607:   // XXXbz it would be really nice if we had the prevSibling here too, to check
26607:   // whether this is in fact the case...
27866:   nsIFrame* nextSibling =
27866:     FindNextNonWhitespaceSibling(inFlowFrame->GetLastContinuation());
26607:   NS_ASSERTION(!IsTablePseudo(inFlowFrame), "Shouldn't happen here");
26607:   if (nextSibling && IsTablePseudo(nextSibling)) {
26607: #ifdef DEBUG
26607:     if (gNoisyContentUpdates) {
26607:       printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
26607:              "frame=");
26607:       nsFrame::ListTag(stdout, aFrame);
26607:       printf(" has a table pseudo next sibling of different type\n");
26607:     }
26607: #endif
26607:     // Good enough to recreate frames for aFrame's parent's content; even if
26607:     // aFrame's parent is a table pseudo, that'll be the right content node.
31031:     *aResult = RecreateFramesForContent(parent->GetContent(), PR_TRUE);
26607:     return PR_TRUE;
26607:   }
26607: 
40762: #ifdef MOZ_XUL
40762:   if (aFrame->GetType() == nsGkAtoms::popupSetFrame) {
40762:     nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
40762:     if (rootBox && rootBox->GetPopupSetFrame() == aFrame) {
40762:       *aResult = ReconstructDocElementHierarchy();
40762:       return PR_TRUE;
40762:     }
40762:   }
40762: #endif
40762: 
26471:   // We might still need to reconstruct things if the parent of inFlowFrame is
 4696:   // special, since in that case the removal of aFrame might affect the
 4696:   // splitting of its parent.
 4696:   if (!IsFrameSpecial(parent)) {
 4696:     return PR_FALSE;
 4696:   }
 4696: 
34462:   // If inFlowFrame is not the only in-flow child of |parent|, then removing
34462:   // it will change nothing about the {ib} split.
34462:   if (inFlowFrame != parent->GetFirstChild(nsnull) ||
34462:       inFlowFrame->GetLastContinuation()->GetNextSibling()) {
 4717:     return PR_FALSE;
 4717:   }
 4717: 
34462:   // If the parent is the first or last part of the {ib} split, then
34462:   // removing one of its kids will have no effect on the splitting.
34462:   // Get the first continuation up front so we don't have to do it twice.
34462:   nsIFrame* parentFirstContinuation = parent->GetFirstContinuation();
34462:   if (!GetSpecialSibling(parentFirstContinuation) ||
34462:       !GetSpecialPrevSibling(parentFirstContinuation)) {
26332:     return PR_FALSE;
26332:   }
26332: 
 4696: #ifdef DEBUG
 5310:   if (gNoisyContentUpdates) {
26471:     printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
 4696:            "frame=");
 4696:     nsFrame::ListTag(stdout, parent);
 4696:     printf(" is special\n");
 4696:   }
 4696: #endif
 4696: 
 4696:   *aResult = ReframeContainingBlock(parent);
 4696:   return PR_TRUE;
 4696: }
 4696:  
    1: nsresult
31031: nsCSSFrameConstructor::RecreateFramesForContent(nsIContent* aContent,
31031:                                                 PRBool aAsyncInsert)
    1: {
42328:   NS_PRECONDITION(!aAsyncInsert || aContent->IsElement(),
42328:                   "Can only insert elements async");
    1:   // If there is no document, we don't want to recreate frames for it.  (You
    1:   // shouldn't generally be giving this method content without a document
    1:   // anyway).
    1:   // Rebuilding the frame tree can have bad effects, especially if it's the
    1:   // frame tree for chrome (see bug 157322).
    1:   NS_ENSURE_TRUE(aContent->GetDocument(), NS_ERROR_FAILURE);
    1: 
    1:   // Is the frame `special'? If so, we need to reframe the containing
    1:   // block *here*, rather than trying to remove and re-insert the
    1:   // content (which would otherwise result in *two* nested reframe
    1:   // containing block from ContentRemoved() and ContentInserted(),
 4696:   // below!).  We'd really like to optimize away one of those
 4696:   // containing block reframes, hence the code here.
    1: 
36656:   nsIFrame* frame = aContent->GetPrimaryFrame();
 6862:   if (frame && frame->IsFrameOfType(nsIFrame::eMathML)) {
 6862:     // Reframe the topmost MathML element to prevent exponential blowup
 6862:     // (see bug 397518)
 6862:     while (PR_TRUE) {
 6862:       nsIContent* parentContent = aContent->GetParent();
36656:       nsIFrame* parentContentFrame = parentContent->GetPrimaryFrame();
 6862:       if (!parentContentFrame || !parentContentFrame->IsFrameOfType(nsIFrame::eMathML))
 6862:         break;
 6862:       aContent = parentContent;
 6862:       frame = parentContentFrame;
 6862:     }
 6862:   }
    1: 
21943:   if (frame) {
21943:     nsIFrame* nonGeneratedAncestor = nsLayoutUtils::GetNonGeneratedAncestor(frame);
21943:     if (nonGeneratedAncestor->GetContent() != aContent) {
31031:       return RecreateFramesForContent(nonGeneratedAncestor->GetContent(), aAsyncInsert);
21943:     }
47706: 
47706:     nsIFrame* parent = frame->GetParent();
47706:     nsIContent* parentContent = parent ? parent->GetContent() : nsnull;
47706:     // If the parent frame is a leaf then the subsequent insert will fail to
47706:     // create a frame, so we need to recreate the parent content. This happens
47706:     // with native anonymous content from the editor.
47706:     if (parent && parent->IsLeaf() && parentContent &&
47706:         parentContent != aContent) {
47706:       return RecreateFramesForContent(parentContent, aAsyncInsert);
47706:     }
21943:   }
21943: 
    1:   nsresult rv = NS_OK;
    1: 
26471:   if (frame && MaybeRecreateContainerForFrameRemoval(frame, &rv)) {
    1:     return rv;
    1:   }
    1: 
28215:   nsINode* containerNode = aContent->GetNodeParent();
47669:   // XXXbz how can containerNode be null here?
28215:   if (containerNode) {
    1:     // Before removing the frames associated with the content object,
    1:     // ask them to save their state onto a temporary state object.
    1:     CaptureStateForFramesOf(aContent, mTempFrameTreeState);
    1: 
47669:     // Need the nsIContent parent, which might be null here, since we need to
47669:     // pass it to ContentInserted and ContentRemoved.
28215:     nsCOMPtr<nsIContent> container = aContent->GetParent();
28215: 
47669:     // Remove the frames associated with the content object.
 7681:     PRBool didReconstruct;
47669:     rv = ContentRemoved(container, aContent,
47669:                         aContent->IsRootOfAnonymousSubtree() ?
47669:                           nsnull :
47669:                           aContent->GetNextSibling(),
29501:                         REMOVE_FOR_RECONSTRUCTION, &didReconstruct);
 7681: 
 7681:     if (NS_SUCCEEDED(rv) && !didReconstruct) {
 7681:       // Now, recreate the frames associated with this content object. If
 7681:       // ContentRemoved triggered reconstruction, then we don't need to do this
 7681:       // because the frames will already have been built.
31031:       if (aAsyncInsert) {
42328:         PostRestyleEvent(aContent->AsElement(), nsRestyleHint(0),
42328:                          nsChangeHint_ReconstructFrame);
31031:       } else {
47667:         rv = ContentInserted(container, aContent, mTempFrameTreeState, PR_FALSE);
    1:       }
    1:     }
31031:   }
    1: 
    1: #ifdef ACCESSIBILITY
    1:   if (mPresShell->IsAccessibilityActive()) {
32336:     PRUint32 changeType;
    1:     if (frame) {
36656:       nsIFrame *newFrame = aContent->GetPrimaryFrame();
32336:       changeType = newFrame ? nsIAccessibilityService::FRAME_SIGNIFICANT_CHANGE :
32336:                               nsIAccessibilityService::FRAME_HIDE;
    1:     }
    1:     else {
32336:       changeType = nsIAccessibilityService::FRAME_SHOW;
    1:     }
    1: 
42263:     // A significant enough change occurred that this part
    1:     // of the accessible tree is no longer valid.
    1:     nsCOMPtr<nsIAccessibilityService> accService = 
    1:       do_GetService("@mozilla.org/accessibilityService;1");
    1:     if (accService) {
32336:       accService->InvalidateSubtreeFor(mPresShell, aContent, changeType);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
    1: //////////////////////////////////////////////////////////////////////
    1: 
    1: // Block frame construction code
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::GetFirstLetterStyle(nsIContent* aContent,
    1:                                            nsStyleContext* aStyleContext)
    1: {
    1:   if (aContent) {
    1:     return mPresShell->StyleSet()->
41640:       ResolvePseudoElementStyle(aContent->AsElement(),
35554:                                 nsCSSPseudoElements::ePseudo_firstLetter,
35554:                                 aStyleContext);
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsCSSFrameConstructor::GetFirstLineStyle(nsIContent* aContent,
    1:                                          nsStyleContext* aStyleContext)
    1: {
    1:   if (aContent) {
    1:     return mPresShell->StyleSet()->
41640:       ResolvePseudoElementStyle(aContent->AsElement(),
35554:                                 nsCSSPseudoElements::ePseudo_firstLine,
35554:                                 aStyleContext);
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: // Predicate to see if a given content (block element) has
    1: // first-letter style applied to it.
    1: PRBool
 1254: nsCSSFrameConstructor::ShouldHaveFirstLetterStyle(nsIContent* aContent,
    1:                                                   nsStyleContext* aStyleContext)
    1: {
    1:   return nsLayoutUtils::HasPseudoStyle(aContent, aStyleContext,
35554:                                        nsCSSPseudoElements::ePseudo_firstLetter,
    1:                                        mPresShell->GetPresContext());
    1: }
    1: 
    1: PRBool
 1254: nsCSSFrameConstructor::HasFirstLetterStyle(nsIFrame* aBlockFrame)
  551: {
  551:   NS_PRECONDITION(aBlockFrame, "Need a frame");
15909:   NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlockFrame),
  551:                "Not a block frame?");
  551: 
  551:   return (aBlockFrame->GetStateBits() & NS_BLOCK_HAS_FIRST_LETTER_STYLE) != 0;
  551: }
  551: 
  551: PRBool
 1254: nsCSSFrameConstructor::ShouldHaveFirstLineStyle(nsIContent* aContent,
    1:                                                 nsStyleContext* aStyleContext)
    1: {
16270:   PRBool hasFirstLine =
16270:     nsLayoutUtils::HasPseudoStyle(aContent, aStyleContext,
35554:                                   nsCSSPseudoElements::ePseudo_firstLine,
    1:                                   mPresShell->GetPresContext());
16270:   if (hasFirstLine) {
16270:     // But disable for fieldsets
16270:     PRInt32 namespaceID;
16270:     nsIAtom* tag = mDocument->BindingManager()->ResolveTag(aContent,
16270:                                                            &namespaceID);
23944:     // This check must match the one in FindHTMLData.
16270:     hasFirstLine = tag != nsGkAtoms::fieldset ||
47707:       namespaceID != kNameSpaceID_XHTML;
16270:   }
16274: 
16274:   return hasFirstLine;
    1: }
    1: 
    1: void
 1254: nsCSSFrameConstructor::ShouldHaveSpecialBlockStyle(nsIContent* aContent,
    1:                                                    nsStyleContext* aStyleContext,
    1:                                                    PRBool* aHaveFirstLetterStyle,
    1:                                                    PRBool* aHaveFirstLineStyle)
    1: {
    1:   *aHaveFirstLetterStyle =
 1254:     ShouldHaveFirstLetterStyle(aContent, aStyleContext);
    1:   *aHaveFirstLineStyle =
 1254:     ShouldHaveFirstLineStyle(aContent, aStyleContext);
    1: }
    1: 
26208: /* static */
26208: const nsCSSFrameConstructor::PseudoParentData
26208: nsCSSFrameConstructor::sPseudoParentData[eParentTypeCount] = {
26208:   { // Cell
36653:     FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMESET |
26208:                      FCDATA_USE_CHILD_ITEMS |
26208:                      FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRow),
26208:                      &nsCSSFrameConstructor::ConstructTableCell),
26208:     &nsCSSAnonBoxes::tableCell
26208:   },
26208:   { // Row
36653:     FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMESET |
26208:                      FCDATA_USE_CHILD_ITEMS |
26208:                      FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRowGroup),
26208:                      &nsCSSFrameConstructor::ConstructTableRow),
26208:     &nsCSSAnonBoxes::tableRow
26208:   },
26208:   { // Row group
36653:     FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMESET |
26208:                 FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_USE_CHILD_ITEMS |
26776:                 FCDATA_SKIP_ABSPOS_PUSH |
26208:                 FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26208:                 NS_NewTableRowGroupFrame),
26208:     &nsCSSAnonBoxes::tableRowGroup
26208:   },
26208:   { // Column group
36653:     FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMESET |
26208:                 FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_USE_CHILD_ITEMS |
26776:                 FCDATA_SKIP_ABSPOS_PUSH |
26208:                 FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
26208:                 NS_NewTableColGroupFrame),
26208:     &nsCSSAnonBoxes::tableColGroup
26208:   },
26208:   { // Table
36653:     FULL_CTOR_FCDATA(FCDATA_SKIP_FRAMESET | FCDATA_USE_CHILD_ITEMS,
26208:                      &nsCSSFrameConstructor::ConstructTable),
26208:     &nsCSSAnonBoxes::table
26208:   }
26208: };
26208: 
26208: /*
26208:  * This function works as follows: we walk through the child list (aItems) and
26208:  * find items that cannot have aParentFrame as their parent.  We wrap
26208:  * continuous runs of such items into a FrameConstructionItem for a frame that
26208:  * gets them closer to their desired parents.  For example, a run of non-row
26208:  * children of a row-group will get wrapped in a row.  When we later construct
26208:  * the frame for this wrapper (in this case for the row), it'll be the correct
26208:  * parent for the cells in the set of items we wrapped or we'll wrap cells
26208:  * around everything else.  At the end of this method, aItems is guaranteed to
26208:  * contain only items for frames that can be direct kids of aParentFrame.
26208:  */
26208: nsresult
41931: nsCSSFrameConstructor::CreateNeededTablePseudos(nsFrameConstructorState& aState,
41931:                                                 FrameConstructionItemList& aItems,
26208:                                                 nsIFrame* aParentFrame)
26208: {
26208:   ParentType ourParentType = GetParentType(aParentFrame);
26208:   if (aItems.AllWantParentType(ourParentType)) {
26208:     // Nothing to do here
26208:     return NS_OK;
26208:   }
26208: 
26208:   FCItemIterator iter(aItems);
26208:   do {
27311:     if (iter.SkipItemsWantingParentType(ourParentType)) {
26208:       // Nothing else to do here; we're finished
26208:       return NS_OK;
26208:     }
26208: 
26208:     // Now we're pointing to the first child that wants a different parent
27311:     // type.
26208: 
26208:     // Now try to figure out what kids we can group together.  We can generally
26208:     // group everything that has a different desired parent type from us.  Two
26208:     // exceptions to this:
26208:     // 1) If our parent type is table, we can't group columns with anything
26208:     //    else other than whitespace.
27311:     // 2) Whitespace that lies between two things we can group which both want
27311:     //    a non-block parent should be dropped, even if we can't group them
27311:     //    with each other and even if the whitespace wants a parent of
27311:     //    ourParentType.  Ends of the list count as things that don't want a
27311:     //    block parent (so that for example we'll drop a whitespace-only list).
26208: 
26208:     FCItemIterator endIter(iter); /* iterator to find the end of the group */
26208:     ParentType groupingParentType = endIter.item().DesiredParentType();
27311:     if (aItems.AllWantParentType(groupingParentType) &&
27311:         groupingParentType != eTypeBlock) {
27311:       // Just group them all and be done with it.  We need the check for
27311:       // eTypeBlock here to catch the "all the items are whitespace" case
27311:       // described above.
27311:       endIter.SetToEnd();
27311:     } else {
27311:       // Locate the end of the group.
27311: 
27311:       // Keep track of the type the previous item wanted, in case we have to
27311:       // deal with whitespace.  Start it off with ourParentType, since that's
27311:       // the last thing |iter| would have skipped over.
27311:       ParentType prevParentType = ourParentType;
26208:       do {
27311:         /* Walk an iterator past any whitespace that we might be able to drop from the list */
27311:         FCItemIterator spaceEndIter(endIter);
27311:         if (prevParentType != eTypeBlock &&
27311:             !aParentFrame->IsGeneratedContentFrame() &&
41931:             spaceEndIter.item().IsWhitespace(aState)) {
41931:           PRBool trailingSpaces = spaceEndIter.SkipWhitespace(aState);
27311: 
27311:           // See whether we can drop the whitespace
27311:           if (trailingSpaces ||
27311:               spaceEndIter.item().DesiredParentType() != eTypeBlock) {
27311:             PRBool updateStart = (iter == endIter);
27311:             endIter.DeleteItemsTo(spaceEndIter);
27311:             NS_ASSERTION(trailingSpaces == endIter.IsDone(), "These should match");
27311: 
27311:             if (updateStart) {
27311:               iter = endIter;
27311:             }
27311: 
27311:             if (trailingSpaces) {
27311:               break; /* Found group end */
27311:             }
27311: 
27311:             if (updateStart) {
27311:               // Update groupingParentType, since it might have been eTypeBlock
27311:               // just because of the whitespace.
27311:               groupingParentType = iter.item().DesiredParentType();
27311:             }
27311:           }
27311:         }
27311: 
27311:         // Now endIter points to a non-whitespace item or a non-droppable
27311:         // whitespace item. In the latter case, if this is the end of the group
27311:         // we'll traverse this whitespace again.  But it'll all just be quick
27311:         // DesiredParentType() checks which will match ourParentType (that's
27311:         // what it means that this is the group end), so it's OK.
27311:         prevParentType = endIter.item().DesiredParentType();
27311:         if (prevParentType == ourParentType) {
27311:           // End the group at endIter.
26208:           break;
26208:         }
26208: 
26208:         if (ourParentType == eTypeTable &&
27311:             (prevParentType == eTypeColGroup) !=
26208:             (groupingParentType == eTypeColGroup)) {
26208:           // Either we started with columns and now found something else, or vice
26208:           // versa.  In any case, end the grouping.
26208:           break;
26208:         }
27311: 
27311:         // Include the whitespace we didn't drop (if any) in the group, since
27311:         // this is not the end of the group.  Note that this doesn't change
27311:         // prevParentType, since if we didn't drop the whitespace then we ended
27311:         // at something that wants a block parent.
27311:         endIter = spaceEndIter;
27311: 
27311:         endIter.Next();
27311:       } while (!endIter.IsDone());
27311:     }
27311: 
27311:     if (iter == endIter) {
27311:       // Nothing to wrap here; just skipped some whitespace
27311:       continue;
27311:     }
26208: 
26208:     // Now group together all the items between iter and endIter.  The right
26208:     // parent type to use depends on ourParentType.
26208:     ParentType wrapperType;
26208:     switch (ourParentType) {
26208:       case eTypeBlock:
26208:         wrapperType = eTypeTable;
26208:         break;
26208:       case eTypeRow:
26208:         // The parent type for a cell is eTypeBlock, since that's what a cell
26208:         // looks like to its kids.
26208:         wrapperType = eTypeBlock;
26208:         break;
26208:       case eTypeRowGroup:
26208:         wrapperType = eTypeRow;
26208:         break;
26208:       case eTypeTable:
26208:         // Either colgroup or rowgroup, depending on what we're grouping.
26208:         wrapperType = groupingParentType == eTypeColGroup ?
26208:           eTypeColGroup : eTypeRowGroup;
26208:         break;
26208:       default:
26208:         NS_NOTREACHED("Colgroups should be suppresing non-col child items");
26208:         break;
26208:     }
26208: 
26208:     const PseudoParentData& pseudoData = sPseudoParentData[wrapperType];
26208:     nsIAtom* pseudoType = *pseudoData.mPseudoType;
26208:     nsStyleContext* parentStyle = aParentFrame->GetStyleContext();
26208:     nsIContent* parentContent = aParentFrame->GetContent();
26208: 
26208:     if (pseudoType == nsCSSAnonBoxes::table &&
26208:         parentStyle->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE) {
26208:       pseudoType = nsCSSAnonBoxes::inlineTable;
26208:     }
26208: 
26208:     nsRefPtr<nsStyleContext> wrapperStyle =
35554:       mPresShell->StyleSet()->ResolveAnonymousBoxStyle(pseudoType, parentStyle);
26208:     FrameConstructionItem* newItem =
26208:       new FrameConstructionItem(&pseudoData.mFCData,
26208:                                 // Use the content of our parent frame
26208:                                 parentContent,
26208:                                 // Lie about the tag; it doesn't matter anyway
26208:                                 pseudoType,
26208:                                 // The namespace does matter, however; it needs
26208:                                 // to match that of our first child item to
26208:                                 // match the old behavior
26208:                                 iter.item().mNameSpaceID,
34614:                                 // no pending binding
34614:                                 nsnull,
47661:                                 wrapperStyle.forget(),
47661:                                 PR_TRUE);
26208: 
26208:     if (!newItem) {
26208:       return NS_ERROR_OUT_OF_MEMORY;
26208:     }
26208: 
26208:     // Here we're cheating a tad... technically, table-internal items should be
26208:     // inline if aParentFrame is inline, but they'll get wrapped in an
26208:     // inline-table in the end, so it'll all work out.  In any case, arguably
26208:     // we don't need to maintain this state at this point... but it's better
26208:     // to, I guess.
26208:     newItem->mIsAllInline = newItem->mHasInlineEnds =
26208:       newItem->mStyleContext->GetStyleDisplay()->IsInlineOutside();
26208: 
29501:     // Table pseudo frames always induce line boundaries around their
29501:     // contents.
29501:     newItem->mChildItems.SetLineBoundaryAtStart(PR_TRUE);
29501:     newItem->mChildItems.SetLineBoundaryAtEnd(PR_TRUE);
29501:     // The parent of the items in aItems is also the parent of the items
29501:     // in mChildItems
29501:     newItem->mChildItems.SetParentHasNoXBLChildren(
29501:       aItems.ParentHasNoXBLChildren());
29501: 
26208:     // Eat up all items between |iter| and |endIter| and put them in our wrapper
26208:     // Advances |iter| to point to |endIter|.
26208:     iter.AppendItemsToList(endIter, newItem->mChildItems);
26208: 
26208:     iter.InsertItem(newItem);
26208: 
26208:     // Now |iter| points to the item that was the first one we didn't wrap;
26208:     // loop and see whether we need to skip it or wrap it in something
26208:     // different.
26208:   } while (!iter.IsDone());
26208: 
26208:   return NS_OK;
26208: }
26208: 
41931: inline nsresult
25774: nsCSSFrameConstructor::ConstructFramesFromItemList(nsFrameConstructorState& aState,
25774:                                                    FrameConstructionItemList& aItems,
25772:                                                    nsIFrame* aParentFrame,
25772:                                                    nsFrameItems& aFrameItems)
25772: {
41931:   nsresult rv = CreateNeededTablePseudos(aState, aItems, aParentFrame);
26208:   NS_ENSURE_SUCCESS(rv, rv);
26208: 
26208: #ifdef DEBUG
25774:   for (FCItemIterator iter(aItems); !iter.IsDone(); iter.Next()) {
26208:     NS_ASSERTION(iter.item().DesiredParentType() == GetParentType(aParentFrame),
26208:                  "Needed pseudos didn't get created; expect bad things");
26208:   }
26208: #endif
26208: 
26208:   for (FCItemIterator iter(aItems); !iter.IsDone(); iter.Next()) {
26208:     rv = ConstructFramesFromItem(aState, iter, aParentFrame, aFrameItems);
25772:     NS_ENSURE_SUCCESS(rv, rv);
25772:   }
25772: 
25772:   NS_ASSERTION(!aState.mHavePendingPopupgroup,
25772:                "Should have proccessed it by now");
25772: 
25772:   return NS_OK;
25772: }
25772: 
    1: nsresult
    1: nsCSSFrameConstructor::ProcessChildren(nsFrameConstructorState& aState,
    1:                                        nsIContent*              aContent,
23352:                                        nsStyleContext*          aStyleContext,
    1:                                        nsIFrame*                aFrame,
25768:                                        const PRBool             aCanHaveGeneratedContent,
    1:                                        nsFrameItems&            aFrameItems,
34614:                                        const PRBool             aAllowBlockStyles,
34614:                                        PendingBinding*          aPendingBinding)
23352: {
23352:   NS_PRECONDITION(aFrame, "Must have parent frame here");
23352:   NS_PRECONDITION(aFrame->GetContentInsertionFrame() == aFrame,
23352:                   "Parent frame in ProcessChildren should be its own "
23352:                   "content insertion frame");
23352: 
    1:   // XXXbz ideally, this would do all the pushing of various
    1:   // containing blocks as needed, so callers don't have to do it...
23343: 
23352:   PRBool haveFirstLetterStyle = PR_FALSE, haveFirstLineStyle = PR_FALSE;
23352:   if (aAllowBlockStyles) {
23352:     ShouldHaveSpecialBlockStyle(aContent, aStyleContext, &haveFirstLetterStyle,
23352:                                 &haveFirstLineStyle);
23352:   }
23352: 
23352:   // The logic here needs to match the logic in GetFloatContainingBlock()
23352:   nsFrameConstructorSaveState floatSaveState;
23352:   if (aFrame->IsFrameOfType(nsIFrame::eMathML) ||
23352:       aFrame->IsBoxFrame()) {
23352:     aState.PushFloatContainingBlock(nsnull, floatSaveState);
23352:   } else if (aFrame->IsFloatContainingBlock()) {
23352:     aState.PushFloatContainingBlock(aFrame, floatSaveState);
23352:   }
    1: 
34614:   nsFrameConstructorState::PendingBindingAutoPusher pusher(aState,
34614:                                                            aPendingBinding);
34614: 
25774:   FrameConstructionItemList itemsToConstruct;
25768:   nsresult rv = NS_OK;
25768: 
29501:   // If we have first-letter or first-line style then frames can get
29501:   // moved around so don't set these flags.
29501:   if (aAllowBlockStyles && !haveFirstLetterStyle && !haveFirstLineStyle) {
29501:     itemsToConstruct.SetLineBoundaryAtStart(PR_TRUE);
29501:     itemsToConstruct.SetLineBoundaryAtEnd(PR_TRUE);
29501:   }
29501: 
25811:   // Create any anonymous frames we need here.  This must happen before the
25811:   // non-anonymous children are processed to ensure that popups are never
25811:   // constructed before the popupset.
25768:   nsAutoTArray<nsIContent*, 4> anonymousItems;
25768:   GetAnonymousContent(aContent, aFrame, anonymousItems);
25768:   for (PRUint32 i = 0; i < anonymousItems.Length(); ++i) {
25768: #ifdef DEBUG
25768:     nsIAnonymousContentCreator* creator = do_QueryFrame(aFrame);
25768:     NS_ASSERTION(!creator || !creator->CreateFrameFor(anonymousItems[i]),
25768:                  "If you need to use CreateFrameFor, you need to call "
25768:                  "CreateAnonymousFrames manually and not follow the standard "
25768:                  "ProcessChildren() codepath for this frame");
25768: #endif
47661:     AddFrameConstructionItems(aState, anonymousItems[i], PR_TRUE, aFrame,
25768:                               itemsToConstruct);
25768:   }
25768: 
33641:   if (!aFrame->IsLeaf()) {
23167:     // :before/:after content should have the same style context parent
23167:     // as normal kids.
23352:     // Note that we don't use this style context for looking up things like
23352:     // special block styles because in some cases involving table pseudo-frames
23352:     // it has nothing to do with the parent frame's desired behavior.
25768:     nsStyleContext* styleContext;
25768: 
25768:     if (aCanHaveGeneratedContent) {
25768:       styleContext =
23167:         nsFrame::CorrectStyleParentFrame(aFrame, nsnull)->GetStyleContext();
16976:       // Probe for generated content before
35554:       CreateGeneratedContentItem(aState, aFrame, aContent, styleContext,
35554:                                  nsCSSPseudoElements::ePseudo_before,
25768:                                  itemsToConstruct);
16976:     }
16976: 
    1:     ChildIterator iter, last;
    1:     for (ChildIterator::Init(aContent, &iter, &last);
    1:          iter != last;
    1:          ++iter) {
43792:       nsIContent* child = *iter;
43792:       // Frame construction item construction should not post
43792:       // restyles, so removing restyle flags here is safe.
43792:       if (child->IsElement()) {
43792:         child->UnsetFlags(ELEMENT_ALL_RESTYLE_FLAGS);
43792:       }
47661:       AddFrameConstructionItems(aState, child, iter.XBLInvolved(), aFrame,
47661:                                 itemsToConstruct);
29501:     }
29501:     itemsToConstruct.SetParentHasNoXBLChildren(!iter.XBLInvolved());
    1: 
16976:     if (aCanHaveGeneratedContent) {
16976:       // Probe for generated content after
35554:       CreateGeneratedContentItem(aState, aFrame, aContent, styleContext,
35554:                                  nsCSSPseudoElements::ePseudo_after,
25768:                                  itemsToConstruct);
25768:     }
40938:   } else {
47657:     ClearLazyBits(aContent->GetFirstChild(), nsnull);
25768:   }
25768: 
25774:   rv = ConstructFramesFromItemList(aState, itemsToConstruct, aFrame,
16976:                                    aFrameItems);
25768:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
23352:   NS_ASSERTION(!aAllowBlockStyles || !aFrame->IsBoxFrame(),
22859:                "can't be both block and box");
22859: 
23352:   if (haveFirstLetterStyle) {
23461:     rv = WrapFramesInFirstLetterFrame(aContent, aFrame, aFrameItems);
23167:   }
23352:   if (haveFirstLineStyle) {
30788:     rv = WrapFramesInFirstLineFrame(aState, aContent, aFrame, nsnull,
30788:                                     aFrameItems);
    1:   }
    1: 
26208:   // We might end up with first-line frames that change
26208:   // AnyKidsNeedBlockParent() without changing itemsToConstruct, but that
26208:   // should never happen for cases whan aFrame->IsBoxFrame().
26208:   NS_ASSERTION(!haveFirstLineStyle || !aFrame->IsBoxFrame(),
26208:                "Shouldn't have first-line style if we're a box");
26208:   NS_ASSERTION(!aFrame->IsBoxFrame() ||
26208:                itemsToConstruct.AnyItemsNeedBlockParent() ==
30785:                  (AnyKidsNeedBlockParent(aFrameItems.FirstChild()) != nsnull),
26208:                "Something went awry in our block parent calculations");
26208: 
26208:   if (aFrame->IsBoxFrame() && itemsToConstruct.AnyItemsNeedBlockParent()) {
26208:     // XXXbz we could do this on the FrameConstructionItemList level,
26208:     // no?  And if we cared we could look through the item list
26208:     // instead of groveling through the framelist here..
30785:     nsIContent *badKid = AnyKidsNeedBlockParent(aFrameItems.FirstChild());
39101:     nsDependentAtomString parentTag(aContent->Tag()), kidTag(badKid->Tag());
22859:     const PRUnichar* params[] = { parentTag.get(), kidTag.get() };
22859:     nsStyleContext *frameStyleContext = aFrame->GetStyleContext();
22859:     const nsStyleDisplay *display = frameStyleContext->GetStyleDisplay();
22859:     const char *message =
22859:       (display->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX)
22859:         ? "NeededToWrapXULInlineBox" : "NeededToWrapXUL";
22859:     nsContentUtils::ReportToConsole(nsContentUtils::eXUL_PROPERTIES,
22859:                                     message,
22859:                                     params, NS_ARRAY_LENGTH(params),
22859:                                     mDocument->GetDocumentURI(),
22859:                                     EmptyString(), 0, 0, // not useful
22859:                                     nsIScriptError::warningFlag,
22859:                                     "FrameConstructor");
22859: 
22859:     nsRefPtr<nsStyleContext> blockSC = mPresShell->StyleSet()->
35554:       ResolveAnonymousBoxStyle(nsCSSAnonBoxes::mozXULAnonymousBlock,
22859:                                frameStyleContext);
22859:     nsIFrame *blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
23305:     // We might, in theory, want to set NS_BLOCK_FLOAT_MGR and
22859:     // NS_BLOCK_MARGIN_ROOT, but I think it's a bad idea given that
22859:     // a real block placed here wouldn't get those set on it.
22859: 
22859:     InitAndRestoreFrame(aState, aContent, aFrame, nsnull,
22859:                         blockFrame, PR_FALSE);
22859: 
22859:     NS_ASSERTION(!blockFrame->HasView(), "need to do view reparenting");
30785:     ReparentFrames(aState.mFrameManager, blockFrame, aFrameItems);
30785: 
30790:     blockFrame->SetInitialChildList(nsnull, aFrameItems);
30790:     NS_ASSERTION(aFrameItems.IsEmpty(), "How did that happen?");
30790:     aFrameItems.Clear();
22859:     aFrameItems.AddChild(blockFrame);
22859: 
22859:     aFrame->AddStateBits(NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK);
22859:   }
22859: 
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Support for :first-line style
    1: 
    1: // Special routine to handle placing a list of frames into a block
    1: // frame that has first-line style. The routine ensures that the first
    1: // collection of inline frames end up in a first-line frame.
23461: // NOTE: aState may have containing block information related to a
23461: // different part of the frame tree than where the first line occurs.
23461: // In particular aState may be set up for where ContentInserted or
23461: // ContentAppended is inserting content, which may be some
23461: // non-first-in-flow continuation of the block to which the first-line
23461: // belongs. So this function needs to be careful about how it uses
23461: // aState.
    1: nsresult
    1: nsCSSFrameConstructor::WrapFramesInFirstLineFrame(
    1:   nsFrameConstructorState& aState,
    1:   nsIContent*              aBlockContent,
    1:   nsIFrame*                aBlockFrame,
30788:   nsIFrame*                aLineFrame,
    1:   nsFrameItems&            aFrameItems)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
30788:   // Find the part of aFrameItems that we want to put in the first-line
30788:   nsFrameList::FrameLinkEnumerator link(aFrameItems);
30788:   while (!link.AtEnd() && IsInlineOutside(link.NextFrame())) {
30788:     link.Next();
30788:   }
30788: 
32843:   nsFrameList firstLineChildren = aFrameItems.ExtractHead(link);
30788: 
30788:   if (firstLineChildren.IsEmpty()) {
30788:     // Nothing is supposed to go into the first-line; nothing to do
30788:     return NS_OK;
30788:   }
30788: 
30788:   if (!aLineFrame) {
    1:     // Create line frame
 7706:     nsStyleContext* parentStyle =
 7706:       nsFrame::CorrectStyleParentFrame(aBlockFrame,
 7706:                                        nsCSSPseudoElements::firstLine)->
 7706:         GetStyleContext();
    1:     nsRefPtr<nsStyleContext> firstLineStyle = GetFirstLineStyle(aBlockContent,
    1:                                                                 parentStyle);
    1: 
30788:     aLineFrame = NS_NewFirstLineFrame(mPresShell, firstLineStyle);
30788: 
30788:     if (aLineFrame) {
    1:       // Initialize the line frame
    1:       rv = InitAndRestoreFrame(aState, aBlockContent, aBlockFrame, nsnull,
30788:                                aLineFrame);
    1: 
    1:       // The lineFrame will be the block's first child; the rest of the
    1:       // frame list (after lastInlineFrame) will be the second and
30788:       // subsequent children; insert lineFrame into aFrameItems.
30788:       aFrameItems.InsertFrame(nsnull, nsnull, aLineFrame);
30788: 
30788:       NS_ASSERTION(aLineFrame->GetStyleContext() == firstLineStyle,
30788:                    "Bogus style context on line frame");
30788:     }
30788:   }
30788: 
30788:   if (aLineFrame) {
    1:     // Give the inline frames to the lineFrame <b>after</b> reparenting them
30788:     ReparentFrames(aState.mFrameManager, aLineFrame, firstLineChildren);
30788:     if (aLineFrame->GetChildList(nsnull).IsEmpty() &&
30788:         (aLineFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
30788:       aLineFrame->SetInitialChildList(nsnull, firstLineChildren);
30788:     } else {
30941:       aState.mFrameManager->AppendFrames(aLineFrame, nsnull, firstLineChildren);
30788:     }
    1:   }
    1:   else {
    1:     rv = NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: // Special routine to handle appending a new frame to a block frame's
    1: // child list. Takes care of placing the new frame into the right
    1: // place when first-line style is present.
    1: nsresult
    1: nsCSSFrameConstructor::AppendFirstLineFrames(
    1:   nsFrameConstructorState& aState,
    1:   nsIContent*              aBlockContent,
    1:   nsIFrame*                aBlockFrame,
    1:   nsFrameItems&            aFrameItems)
    1: {
    1:   // It's possible that aBlockFrame needs to have a first-line frame
    1:   // created because it doesn't currently have any children.
30788:   const nsFrameList& blockKids = aBlockFrame->GetChildList(nsnull);
30788:   if (blockKids.IsEmpty()) {
    1:     return WrapFramesInFirstLineFrame(aState, aBlockContent,
30788:                                       aBlockFrame, nsnull, aFrameItems);
    1:   }
    1: 
    1:   // Examine the last block child - if it's a first-line frame then
    1:   // appended frames need special treatment.
30788:   nsIFrame* lastBlockKid = blockKids.LastChild();
    1:   if (lastBlockKid->GetType() != nsGkAtoms::lineFrame) {
    1:     // No first-line frame at the end of the list, therefore there is
30788:     // an intervening block between any first-line frame the frames
    1:     // we are appending. Therefore, we don't need any special
    1:     // treatment of the appended frames.
30788:     return NS_OK;
30788:   }
30788: 
30788:   return WrapFramesInFirstLineFrame(aState, aBlockContent, aBlockFrame,
30788:                                     lastBlockKid, aFrameItems);
    1: }
    1: 
    1: // Special routine to handle inserting a new frame into a block
    1: // frame's child list. Takes care of placing the new frame into the
    1: // right place when first-line style is present.
    1: nsresult
    1: nsCSSFrameConstructor::InsertFirstLineFrames(
    1:   nsFrameConstructorState& aState,
    1:   nsIContent*              aContent,
    1:   nsIFrame*                aBlockFrame,
    1:   nsIFrame**               aParentFrame,
    1:   nsIFrame*                aPrevSibling,
    1:   nsFrameItems&            aFrameItems)
    1: {
    1:   nsresult rv = NS_OK;
30941:   // XXXbz If you make this method actually do something, check to
30941:   // make sure that the caller is passing what you expect.  In
30941:   // particular, which content is aContent?  And audit the rest of
30941:   // this code too; it makes bogus assumptions and may not build.
    1: #if 0
    1:   nsIFrame* parentFrame = *aParentFrame;
    1:   nsIFrame* newFrame = aFrameItems.childList;
 2829:   PRBool isInline = IsInlineOutside(newFrame);
    1: 
    1:   if (!aPrevSibling) {
    1:     // Insertion will become the first frame. Two cases: we either
    1:     // already have a first-line frame or we don't.
    1:     nsIFrame* firstBlockKid = aBlockFrame->GetFirstChild(nsnull);
    1:     if (firstBlockKid->GetType() == nsGkAtoms::lineFrame) {
    1:       // We already have a first-line frame
    1:       nsIFrame* lineFrame = firstBlockKid;
    1: 
    1:       if (isInline) {
    1:         // Easy case: the new inline frame will go into the lineFrame.
    1:         ReparentFrame(aState.mFrameManager, lineFrame, newFrame);
    1:         aState.mFrameManager->InsertFrames(lineFrame, nsnull, nsnull,
    1:                                            newFrame);
    1: 
    1:         // Since the frame is going into the lineFrame, don't let it
    1:         // go into the block too.
    1:         aFrameItems.childList = nsnull;
    1:         aFrameItems.lastChild = nsnull;
    1:       }
    1:       else {
    1:         // Harder case: We are about to insert a block level element
    1:         // before the first-line frame.
    1:         // XXX need a method to steal away frames from the line-frame
    1:       }
    1:     }
    1:     else {
    1:       // We do not have a first-line frame
    1:       if (isInline) {
    1:         // We now need a first-line frame to contain the inline frame.
    1:         nsIFrame* lineFrame = NS_NewFirstLineFrame(firstLineStyle);
    1:         if (!lineFrame) {
    1:           rv = NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1: 
    1:         if (NS_SUCCEEDED(rv)) {
    1:           // Lookup first-line style context
 7706:           nsStyleContext* parentStyle =
 7706:             nsFrame::CorrectStyleParentFrame(aBlockFrame,
 7706:                                              nsCSSPseudoElements::firstLine)->
 7706:               GetStyleContext();
    1:           nsRefPtr<nsStyleContext> firstLineStyle =
    1:             GetFirstLineStyle(aContent, parentStyle);
    1: 
    1:           // Initialize the line frame
    1:           rv = InitAndRestoreFrame(aState, aContent, aBlockFrame,
    1:                                    nsnull, lineFrame);
    1: 
    1:           // Make sure the caller inserts the lineFrame into the
    1:           // blocks list of children.
    1:           aFrameItems.childList = lineFrame;
    1:           aFrameItems.lastChild = lineFrame;
    1: 
    1:           // Give the inline frames to the lineFrame <b>after</b>
    1:           // reparenting them
    1:           NS_ASSERTION(lineFrame->GetStyleContext() == firstLineStyle,
    1:                        "Bogus style context on line frame");
    1:           ReparentFrame(aPresContext, lineFrame, newFrame);
    1:           lineFrame->SetInitialChildList(nsnull, newFrame);
    1:         }
    1:       }
    1:       else {
    1:         // Easy case: the regular insertion logic can insert the new
    1:         // frame because it's a block frame.
    1:       }
    1:     }
    1:   }
    1:   else {
    1:     // Insertion will not be the first frame.
    1:     nsIFrame* prevSiblingParent = aPrevSibling->GetParent();
    1:     if (prevSiblingParent == aBlockFrame) {
    1:       // Easy case: The prev-siblings parent is the block
    1:       // frame. Therefore the prev-sibling is not currently in a
    1:       // line-frame. Therefore the new frame which is going after it,
    1:       // regardless of type, is not going into a line-frame.
    1:     }
    1:     else {
    1:       // If the prevSiblingParent is not the block-frame then it must
    1:       // be a line-frame (if it were a letter-frame, that logic would
    1:       // already have adjusted the prev-sibling to be the
    1:       // letter-frame).
    1:       if (isInline) {
    1:         // Easy case: the insertion can go where the caller thinks it
    1:         // should go (which is into prevSiblingParent).
    1:       }
    1:       else {
    1:         // Block elements don't end up in line-frames, therefore
    1:         // change the insertion point to aBlockFrame. However, there
    1:         // might be more inline elements following aPrevSibling that
    1:         // need to be pulled out of the line-frame and become children
    1:         // of the block.
    1:         nsIFrame* nextSibling = aPrevSibling->GetNextSibling();
    1:         nsIFrame* nextLineFrame = prevSiblingParent->GetNextInFlow();
    1:         if (nextSibling || nextLineFrame) {
    1:           // Oy. We have work to do. Create a list of the new frames
    1:           // that are going into the block by stripping them away from
    1:           // the line-frame(s).
    1:           if (nextSibling) {
    1:             nsLineFrame* lineFrame = (nsLineFrame*) prevSiblingParent;
32841:             nsFrameList tail = lineFrame->StealFramesAfter(aPrevSibling);
32841:             // XXX do something with 'tail'
    1:           }
    1: 
    1:           nsLineFrame* nextLineFrame = (nsLineFrame*) lineFrame;
    1:           for (;;) {
    1:             nextLineFrame = nextLineFrame->GetNextInFlow();
    1:             if (!nextLineFrame) {
    1:               break;
    1:             }
    1:             nsIFrame* kids = nextLineFrame->GetFirstChild(nsnull);
    1:           }
    1:         }
    1:         else {
    1:           // We got lucky: aPrevSibling was the last inline frame in
    1:           // the line-frame.
    1:           ReparentFrame(aState.mFrameManager, aBlockFrame, newFrame);
    1:           aState.mFrameManager->InsertFrames(aBlockFrame, nsnull,
    1:                                              prevSiblingParent, newFrame);
    1:           aFrameItems.childList = nsnull;
    1:           aFrameItems.lastChild = nsnull;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // First-letter support
    1: 
    1: // Determine how many characters in the text fragment apply to the
    1: // first letter
    1: static PRInt32
    1: FirstLetterCount(const nsTextFragment* aFragment)
    1: {
    1:   PRInt32 count = 0;
    1:   PRInt32 firstLetterLength = 0;
    1:   PRBool done = PR_FALSE;
    1: 
    1:   PRInt32 i, n = aFragment->GetLength();
    1:   for (i = 0; i < n; i++) {
    1:     PRUnichar ch = aFragment->CharAt(i);
    1:     if (XP_IS_SPACE(ch)) {
    1:       if (firstLetterLength) {
    1:         done = PR_TRUE;
    1:         break;
    1:       }
    1:       count++;
    1:       continue;
    1:     }
    1:     // XXX I18n
    1:     if ((ch == '\'') || (ch == '\"')) {
    1:       if (firstLetterLength) {
    1:         done = PR_TRUE;
    1:         break;
    1:       }
    1:       // keep looping
    1:       firstLetterLength = 1;
    1:     }
    1:     else {
    1:       count++;
    1:       done = PR_TRUE;
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return count;
    1: }
    1: 
    1: static PRBool
    1: NeedFirstLetterContinuation(nsIContent* aContent)
    1: {
    1:   NS_PRECONDITION(aContent, "null ptr");
    1: 
    1:   PRBool result = PR_FALSE;
    1:   if (aContent) {
    1:     const nsTextFragment* frag = aContent->GetText();
    1:     if (frag) {
    1:       PRInt32 flc = FirstLetterCount(frag);
    1:       PRInt32 tl = frag->GetLength();
    1:       if (flc < tl) {
    1:         result = PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: static PRBool IsFirstLetterContent(nsIContent* aContent)
    1: {
    1:   return aContent->TextLength() &&
    1:          !aContent->TextIsOnlyWhitespace();
    1: }
    1: 
    1: /**
    1:  * Create a letter frame, only make it a floating frame.
    1:  */
    1: void
    1: nsCSSFrameConstructor::CreateFloatingLetterFrame(
    1:   nsFrameConstructorState& aState,
    1:   nsIFrame* aBlockFrame,
    1:   nsIContent* aTextContent,
    1:   nsIFrame* aTextFrame,
    1:   nsIContent* aBlockContent,
    1:   nsIFrame* aParentFrame,
    1:   nsStyleContext* aStyleContext,
    1:   nsFrameItems& aResult)
    1: {
    1:   // Create the first-letter-frame
    1:   nsresult rv;
    1:   nsIFrame* letterFrame;
    1:   nsStyleSet *styleSet = mPresShell->StyleSet();
    1: 
    1:   letterFrame = NS_NewFirstLetterFrame(mPresShell, aStyleContext);
    1:   // We don't want to use a text content for a non-text frame (because we want
    1:   // its primary frame to be a text frame).  So use its parent for the
    1:   // first-letter.
    1:   nsIContent* letterContent = aTextContent->GetParent();
37867:   nsIFrame* containingBlock = aState.GetGeometricParent(
37867:     aStyleContext->GetStyleDisplay(), aParentFrame);
37867:   InitAndRestoreFrame(aState, letterContent, containingBlock, nsnull,
37867:                       letterFrame);
    1: 
    1:   // Init the text frame to refer to the letter frame. Make sure we
    1:   // get a proper style context for it (the one passed in is for the
    1:   // letter frame and will have the float property set on it; the text
    1:   // frame shouldn't have that set).
    1:   nsRefPtr<nsStyleContext> textSC;
    1:   textSC = styleSet->ResolveStyleForNonElement(aStyleContext);
    1:   aTextFrame->SetStyleContextWithoutNotification(textSC);
    1:   InitAndRestoreFrame(aState, aTextContent, letterFrame, nsnull, aTextFrame);
    1: 
    1:   // And then give the text frame to the letter frame
30790:   SetInitialSingleChild(letterFrame, aTextFrame);
    1: 
    1:   // See if we will need to continue the text frame (does it contain
    1:   // more than just the first-letter text or not?) If it does, then we
    1:   // create (in advance) a continuation frame for it.
    1:   nsIFrame* nextTextFrame = nsnull;
    1:   if (NeedFirstLetterContinuation(aTextContent)) {
    1:     // Create continuation
    1:     rv = CreateContinuingFrame(aState.mPresContext, aTextFrame, aParentFrame,
    1:                                &nextTextFrame);
    1:     if (NS_FAILED(rv)) {
    1:       letterFrame->Destroy();
    1:       return;
    1:     }
    1:     // Repair the continuations style context
    1:     nsStyleContext* parentStyleContext = aStyleContext->GetParent();
    1:     if (parentStyleContext) {
    1:       nsRefPtr<nsStyleContext> newSC;
    1:       newSC = styleSet->ResolveStyleForNonElement(parentStyleContext);
    1:       if (newSC) {
    1:         nextTextFrame->SetStyleContext(newSC);
    1:       }
    1:     }
    1:   }
    1: 
30785:   NS_ASSERTION(aResult.IsEmpty(), "aResult should be an empty nsFrameItems!");
37867:   // Put the new float before any of the floats in the block we're doing
37867:   // first-letter for, that is, before any floats whose parent is
37867:   // containingBlock.
30788:   nsFrameList::FrameLinkEnumerator link(aState.mFloatedItems);
37867:   while (!link.AtEnd() && link.NextFrame()->GetParent() != containingBlock) {
30788:     link.Next();
    1:   }
    1: 
 8199:   rv = aState.AddChild(letterFrame, aResult, letterContent, aStyleContext,
 8199:                        aParentFrame, PR_FALSE, PR_TRUE, PR_FALSE, PR_TRUE,
30788:                        link.PrevFrame());
    1: 
    1:   if (nextTextFrame) {
    1:     if (NS_FAILED(rv)) {
    1:       nextTextFrame->Destroy();
    1:     } else {
    1:       aResult.AddChild(nextTextFrame);
    1:     }
    1:   }
    1: }
    1: 
    1: /**
    1:  * Create a new letter frame for aTextFrame. The letter frame will be
    1:  * a child of aParentFrame.
    1:  */
    1: nsresult
23461: nsCSSFrameConstructor::CreateLetterFrame(nsIFrame* aBlockFrame,
37867:                                          nsIFrame* aBlockContinuation,
    1:                                          nsIContent* aTextContent,
    1:                                          nsIFrame* aParentFrame,
    1:                                          nsFrameItems& aResult)
    1: {
    1:   NS_PRECONDITION(aTextContent->IsNodeOfType(nsINode::eTEXT),
    1:                   "aTextContent isn't text");
15909:   NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlockFrame),
  551:                  "Not a block frame?");
  551: 
    1:   // Get style context for the first-letter-frame
 7706:   nsStyleContext* parentStyleContext =
 7706:     nsFrame::CorrectStyleParentFrame(aParentFrame,
 7706:                                      nsCSSPseudoElements::firstLetter)->
 7706:       GetStyleContext();
23461: 
    1:   // Use content from containing block so that we can actually
    1:   // find a matching style rule.
23461:   nsIContent* blockContent = aBlockFrame->GetContent();
    1: 
    1:   // Create first-letter style rule
    1:   nsRefPtr<nsStyleContext> sc = GetFirstLetterStyle(blockContent,
    1:                                                     parentStyleContext);
    1:   if (sc) {
    1:     nsRefPtr<nsStyleContext> textSC;
    1:     textSC = mPresShell->StyleSet()->ResolveStyleForNonElement(sc);
    1:     
    1:     // Create a new text frame (the original one will be discarded)
36793:     // pass a temporary stylecontext, the correct one will be set
36793:     // later.  Start off by unsetting the primary frame for
36793:     // aTextContent, so it's no longer pointing to the to-be-destroyed
36793:     // frame.
36793:     // XXXbz it would be really nice to destroy the old frame _first_,
36793:     // then create the new one, so we could avoid this hack.
36793:     aTextContent->SetPrimaryFrame(nsnull);
    1:     nsIFrame* textFrame = NS_NewTextFrame(mPresShell, textSC);
    1: 
37867:     NS_ASSERTION(aBlockContinuation == GetFloatContainingBlock(aParentFrame),
23461:                  "Containing block is confused");
23461:     nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
23461:                                   GetAbsoluteContainingBlock(aParentFrame),
37867:                                   aBlockContinuation);
23461: 
    1:     // Create the right type of first-letter frame
    1:     const nsStyleDisplay* display = sc->GetStyleDisplay();
    1:     if (display->IsFloating()) {
    1:       // Make a floating first-letter frame
23461:       CreateFloatingLetterFrame(state, aBlockFrame, aTextContent, textFrame,
37867:                                 blockContent, aParentFrame, sc, aResult);
    1:     }
    1:     else {
    1:       // Make an inflow first-letter frame
    1:       nsIFrame* letterFrame = NS_NewFirstLetterFrame(mPresShell, sc);
    1: 
    1:       if (letterFrame) {
    1:         // Initialize the first-letter-frame.  We don't want to use a text
    1:         // content for a non-text frame (because we want its primary frame to
    1:         // be a text frame).  So use its parent for the first-letter.
    1:         nsIContent* letterContent = aTextContent->GetParent();
    1:         letterFrame->Init(letterContent, aParentFrame, nsnull);
    1: 
23461:         InitAndRestoreFrame(state, aTextContent, letterFrame, nsnull,
    1:                             textFrame);
    1: 
30790:         SetInitialSingleChild(letterFrame, textFrame);
30785:         aResult.Clear();
30785:         aResult.AddChild(letterFrame);
36804:         NS_ASSERTION(!aBlockFrame->GetPrevContinuation(),
36804:                      "should have the first continuation here");
 8759:         aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_CHILD);
    1:       }
    1:     }
36653:     aTextContent->SetPrimaryFrame(textFrame);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::WrapFramesInFirstLetterFrame(
    1:   nsIContent*              aBlockContent,
    1:   nsIFrame*                aBlockFrame,
    1:   nsFrameItems&            aBlockFrames)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
  551:   aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_STYLE);
  551: 
    1:   nsIFrame* parentFrame = nsnull;
    1:   nsIFrame* textFrame = nsnull;
    1:   nsIFrame* prevFrame = nsnull;
    1:   nsFrameItems letterFrames;
    1:   PRBool stopLooking = PR_FALSE;
37867:   rv = WrapFramesInFirstLetterFrame(aBlockFrame, aBlockFrame, aBlockFrame,
30785:                                     aBlockFrames.FirstChild(),
    1:                                     &parentFrame, &textFrame, &prevFrame,
    1:                                     letterFrames, &stopLooking);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   if (parentFrame) {
    1:     if (parentFrame == aBlockFrame) {
30785:       // Take textFrame out of the block's frame list and substitute the
    1:       // letter frame(s) instead.
33388:       aBlockFrames.DestroyFrame(textFrame);
30785:       aBlockFrames.InsertFrames(nsnull, prevFrame, letterFrames);
    1:     }
    1:     else {
30941:       // Take the old textFrame out of the inline parent's child list
36646:       mPresShell->FrameManager()->RemoveFrame(nsnull, textFrame);
    1: 
    1:       // Insert in the letter frame(s)
30941:       parentFrame->InsertFrames(nsnull, prevFrame, letterFrames);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::WrapFramesInFirstLetterFrame(
    1:   nsIFrame*                aBlockFrame,
37867:   nsIFrame*                aBlockContinuation,
    1:   nsIFrame*                aParentFrame,
    1:   nsIFrame*                aParentFrameList,
    1:   nsIFrame**               aModifiedParent,
    1:   nsIFrame**               aTextFrame,
    1:   nsIFrame**               aPrevFrame,
    1:   nsFrameItems&            aLetterFrames,
    1:   PRBool*                  aStopLooking)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsIFrame* prevFrame = nsnull;
    1:   nsIFrame* frame = aParentFrameList;
    1: 
    1:   while (frame) {
    1:     nsIFrame* nextFrame = frame->GetNextSibling();
    1: 
16291:     nsIAtom* frameType = frame->GetType();
16291:     if (nsGkAtoms::textFrame == frameType) {
    1:       // Wrap up first-letter content in a letter frame
    1:       nsIContent* textContent = frame->GetContent();
    1:       if (IsFirstLetterContent(textContent)) {
    1:         // Create letter frame to wrap up the text
37867:         rv = CreateLetterFrame(aBlockFrame, aBlockContinuation, textContent,
    1:                                aParentFrame, aLetterFrames);
    1:         if (NS_FAILED(rv)) {
    1:           return rv;
    1:         }
    1: 
    1:         // Provide adjustment information for parent
    1:         *aModifiedParent = aParentFrame;
    1:         *aTextFrame = frame;
    1:         *aPrevFrame = prevFrame;
    1:         *aStopLooking = PR_TRUE;
    1:         return NS_OK;
    1:       }
    1:     }
16291:     else if (IsInlineFrame(frame) && frameType != nsGkAtoms::brFrame) {
    1:       nsIFrame* kids = frame->GetFirstChild(nsnull);
37867:       WrapFramesInFirstLetterFrame(aBlockFrame, aBlockContinuation, frame,
37867:                                    kids, aModifiedParent, aTextFrame,
    1:                                    aPrevFrame, aLetterFrames, aStopLooking);
    1:       if (*aStopLooking) {
    1:         return NS_OK;
    1:       }
    1:     }
    1:     else {
    1:       // This will stop us looking to create more letter frames. For
    1:       // example, maybe the frame-type is "letterFrame" or
    1:       // "placeholderFrame". This keeps us from creating extra letter
    1:       // frames, and also prevents us from creating letter frames when
    1:       // the first real content child of a block is not text (e.g. an
    1:       // image, hr, etc.)
    1:       *aStopLooking = PR_TRUE;
    1:       break;
    1:     }
    1: 
    1:     prevFrame = frame;
    1:     frame = nextFrame;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::RemoveFloatingFirstLetterFrames(
    1:   nsPresContext* aPresContext,
    1:   nsIPresShell* aPresShell,
    1:   nsFrameManager* aFrameManager,
    1:   nsIFrame* aBlockFrame,
    1:   PRBool* aStopLooking)
    1: {
    1:   // First look for the float frame that is a letter frame
    1:   nsIFrame* floatFrame = aBlockFrame->GetFirstChild(nsGkAtoms::floatList);
    1:   while (floatFrame) {
    1:     // See if we found a floating letter frame
    1:     if (nsGkAtoms::letterFrame == floatFrame->GetType()) {
    1:       break;
    1:     }
    1:     floatFrame = floatFrame->GetNextSibling();
    1:   }
    1:   if (!floatFrame) {
    1:     // No such frame
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Take the text frame away from the letter frame (so it isn't
    1:   // destroyed when we destroy the letter frame).
    1:   nsIFrame* textFrame = floatFrame->GetFirstChild(nsnull);
    1:   if (!textFrame) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Discover the placeholder frame for the letter frame
    1:   nsIFrame* parentFrame;
    1:   nsPlaceholderFrame* placeholderFrame = 
    1:     aFrameManager->GetPlaceholderFrameFor(floatFrame);
    1: 
    1:   if (!placeholderFrame) {
    1:     // Somethings really wrong
    1:     return NS_OK;
    1:   }
    1:   parentFrame = placeholderFrame->GetParent();
    1:   if (!parentFrame) {
    1:     // Somethings really wrong
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Create a new text frame with the right style context that maps
    1:   // all of the content that was previously part of the letter frame
    1:   // (and probably continued elsewhere).
    1:   nsStyleContext* parentSC = parentFrame->GetStyleContext();
    1:   if (!parentSC) {
    1:     return NS_OK;
    1:   }
    1:   nsIContent* textContent = textFrame->GetContent();
    1:   if (!textContent) {
    1:     return NS_OK;
    1:   }
    1:   nsRefPtr<nsStyleContext> newSC;
    1:   newSC = aPresShell->StyleSet()->ResolveStyleForNonElement(parentSC);
    1:   if (!newSC) {
    1:     return NS_OK;
    1:   }
    1:   nsIFrame* newTextFrame = NS_NewTextFrame(aPresShell, newSC);
    1:   if (NS_UNLIKELY(!newTextFrame)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;;
    1:   }
    1:   newTextFrame->Init(textContent, parentFrame, nsnull);
    1: 
    1:   // Destroy the old text frame's continuations (the old text frame
    1:   // will be destroyed when its letter frame is destroyed).
27214:   nsIFrame* frameToDelete = textFrame->GetLastContinuation();
27214:   while (frameToDelete != textFrame) {
27214:     nsIFrame* nextFrameToDelete = frameToDelete->GetPrevContinuation();
36646:     aFrameManager->RemoveFrame(nsnull, frameToDelete);
27214:     frameToDelete = nextFrameToDelete;
    1:   }
    1: 
33388:   nsIFrame* prevSibling = placeholderFrame->GetPrevSibling();
    1: 
    1:   // Now that everything is set...
    1: #ifdef NOISY_FIRST_LETTER
    1:   printf("RemoveFloatingFirstLetterFrames: textContent=%p oldTextFrame=%p newTextFrame=%p\n",
    1:          textContent.get(), textFrame, newTextFrame);
    1: #endif
 4162: 
36646:   // Remove placeholder frame and the float
36646:   aFrameManager->RemoveFrame(nsnull, placeholderFrame);
    1: 
36793:   // Now that the old frames are gone, we can start pointing to our
36793:   // new primary frame.
36793:   textContent->SetPrimaryFrame(newTextFrame);
36793: 
    1:   // Insert text frame in its place
32846:   nsFrameList textList(newTextFrame, newTextFrame);
30941:   aFrameManager->InsertFrames(parentFrame, nsnull, prevSibling, textList);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::RemoveFirstLetterFrames(nsPresContext* aPresContext,
    1:                                                nsIPresShell* aPresShell,
    1:                                                nsFrameManager* aFrameManager,
    1:                                                nsIFrame* aFrame,
36804:                                                nsIFrame* aBlockFrame,
    1:                                                PRBool* aStopLooking)
    1: {
    1:   nsIFrame* prevSibling = nsnull;
    1:   nsIFrame* kid = aFrame->GetFirstChild(nsnull);
    1: 
    1:   while (kid) {
 4696:     if (nsGkAtoms::letterFrame == kid->GetType()) {
    1:       // Bingo. Found it. First steal away the text frame.
    1:       nsIFrame* textFrame = kid->GetFirstChild(nsnull);
    1:       if (!textFrame) {
    1:         break;
    1:       }
    1: 
    1:       // Create a new textframe
    1:       nsStyleContext* parentSC = aFrame->GetStyleContext();
    1:       if (!parentSC) {
    1:         break;
    1:       }
    1:       nsIContent* textContent = textFrame->GetContent();
    1:       if (!textContent) {
    1:         break;
    1:       }
    1:       nsRefPtr<nsStyleContext> newSC;
    1:       newSC = aPresShell->StyleSet()->ResolveStyleForNonElement(parentSC);
    1:       if (!newSC) {
    1:         break;
    1:       }
    1:       textFrame = NS_NewTextFrame(aPresShell, newSC);
    1:       textFrame->Init(textContent, aFrame, nsnull);
    1: 
    1:       // Next rip out the kid and replace it with the text frame
36646:       aFrameManager->RemoveFrame(nsnull, kid);
    1: 
36793:       // Now that the old frames are gone, we can start pointing to our
36793:       // new primary frame.
36793:       textContent->SetPrimaryFrame(textFrame);
36793: 
    1:       // Insert text frame in its place
32846:       nsFrameList textList(textFrame, textFrame);
30941:       aFrameManager->InsertFrames(aFrame, nsnull, prevSibling, textList);
    1: 
    1:       *aStopLooking = PR_TRUE;
36804:       NS_ASSERTION(!aBlockFrame->GetPrevContinuation(),
36804:                    "should have the first continuation here");
36804:       aBlockFrame->RemoveStateBits(NS_BLOCK_HAS_FIRST_LETTER_CHILD);
    1:       break;
    1:     }
 4696:     else if (IsInlineFrame(kid)) {
    1:       // Look inside child inline frame for the letter frame
36804:       RemoveFirstLetterFrames(aPresContext, aPresShell, aFrameManager,
36804:                               kid, aBlockFrame, aStopLooking);
    1:       if (*aStopLooking) {
    1:         break;
    1:       }
    1:     }
    1:     prevSibling = kid;
    1:     kid = kid->GetNextSibling();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::RemoveLetterFrames(nsPresContext* aPresContext,
    1:                                           nsIPresShell* aPresShell,
    1:                                           nsFrameManager* aFrameManager,
    1:                                           nsIFrame* aBlockFrame)
    1: {
 8324:   aBlockFrame = aBlockFrame->GetFirstContinuation();
36804:   nsIFrame* continuation = aBlockFrame;
 8324: 
    1:   PRBool stopLooking = PR_FALSE;
10280:   nsresult rv;
10280:   do {
10280:     rv = RemoveFloatingFirstLetterFrames(aPresContext, aPresShell,
    1:                                          aFrameManager,
36804:                                          continuation, &stopLooking);
    1:     if (NS_SUCCEEDED(rv) && !stopLooking) {
    1:       rv = RemoveFirstLetterFrames(aPresContext, aPresShell, aFrameManager,
36804:                                    continuation, aBlockFrame, &stopLooking);
    1:     }
10280:     if (stopLooking) {
10280:       break;
10280:     }
36804:     continuation = continuation->GetNextContinuation();
36804:   }  while (continuation);
    1:   return rv;
    1: }
    1: 
    1: // Fixup the letter frame situation for the given block
    1: nsresult
23461: nsCSSFrameConstructor::RecoverLetterFrames(nsIFrame* aBlockFrame)
    1: {
 8324:   aBlockFrame = aBlockFrame->GetFirstContinuation();
36804:   nsIFrame* continuation = aBlockFrame;
 8324: 
    1:   nsIFrame* parentFrame = nsnull;
    1:   nsIFrame* textFrame = nsnull;
    1:   nsIFrame* prevFrame = nsnull;
    1:   nsFrameItems letterFrames;
    1:   PRBool stopLooking = PR_FALSE;
10280:   nsresult rv;
10280:   do {
10280:     // XXX shouldn't this bit be set already (bug 408493), assert instead?
36804:     continuation->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_STYLE);
37867:     rv = WrapFramesInFirstLetterFrame(aBlockFrame, continuation, continuation,
36804:                                       continuation->GetFirstChild(nsnull),
    1:                                       &parentFrame, &textFrame, &prevFrame,
    1:                                       letterFrames, &stopLooking);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
10280:     if (stopLooking) {
10280:       break;
10280:     }
36804:     continuation = continuation->GetNextContinuation();
36804:   } while (continuation);
10280: 
    1:   if (parentFrame) {
    1:     // Take the old textFrame out of the parents child list
36646:     mPresShell->FrameManager()->RemoveFrame(nsnull, textFrame);
    1: 
    1:     // Insert in the letter frame(s)
30941:     parentFrame->InsertFrames(nsnull, prevFrame, letterFrames);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // listbox Widget Routines
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::CreateListBoxContent(nsPresContext* aPresContext,
    1:                                             nsIFrame*       aParentFrame,
    1:                                             nsIFrame*       aPrevFrame,
    1:                                             nsIContent*     aChild,
    1:                                             nsIFrame**      aNewFrame,
    1:                                             PRBool          aIsAppend,
    1:                                             PRBool          aIsScrollbar,
    1:                                             nsILayoutHistoryState* aFrameState)
    1: {
    1: #ifdef MOZ_XUL
    1:   nsresult rv = NS_OK;
    1: 
    1:   // Construct a new frame
    1:   if (nsnull != aParentFrame) {
    1:     nsFrameItems            frameItems;
    1:     nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
    1:                                   GetAbsoluteContainingBlock(aParentFrame),
    1:                                   GetFloatContainingBlock(aParentFrame), 
    1:                                   mTempFrameTreeState);
    1: 
    1:     nsRefPtr<nsStyleContext> styleContext;
    1:     styleContext = ResolveStyleContext(aParentFrame, aChild);
    1: 
    1:     // Pre-check for display "none" - only if we find that, do we create
    1:     // any frame at all
    1:     const nsStyleDisplay* display = styleContext->GetStyleDisplay();
    1: 
    1:     if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
    1:       *aNewFrame = nsnull;
    1:       return NS_OK;
    1:     }
    1: 
 6737:     BeginUpdate();
 6737: 
25774:     FrameConstructionItemList items;
25771:     AddFrameConstructionItemsInternal(state, aChild, aParentFrame,
25771:                                       aChild->Tag(), aChild->GetNameSpaceID(),
47661:                                       PR_TRUE, styleContext,
47661:                                       ITEM_ALLOW_XBL_BASE, items);
25774:     ConstructFramesFromItemList(state, items, aParentFrame, frameItems);
    1: 
30785:     nsIFrame* newFrame = frameItems.FirstChild();
    1:     *aNewFrame = newFrame;
    1: 
    1:     if (NS_SUCCEEDED(rv) && (nsnull != newFrame)) {
    1:       // Notify the parent frame
    1:       if (aIsAppend)
30941:         rv = ((nsListBoxBodyFrame*)aParentFrame)->ListBoxAppendFrames(frameItems);
    1:       else
30941:         rv = ((nsListBoxBodyFrame*)aParentFrame)->ListBoxInsertFrames(aPrevFrame, frameItems);
    1:     }
 6737: 
 6737:     EndUpdate();
    1:   }
    1: 
    1:   return rv;
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
    1: //----------------------------------------
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructBlock(nsFrameConstructorState& aState,
    1:                                       const nsStyleDisplay*    aDisplay,
    1:                                       nsIContent*              aContent,
    1:                                       nsIFrame*                aParentFrame,
    1:                                       nsIFrame*                aContentParentFrame,
    1:                                       nsStyleContext*          aStyleContext,
    1:                                       nsIFrame**               aNewFrame,
    1:                                       nsFrameItems&            aFrameItems,
34614:                                       PRBool                   aAbsPosContainer,
34614:                                       PendingBinding*          aPendingBinding)
    1: {
    1:   // Create column wrapper if necessary
    1:   nsIFrame* blockFrame = *aNewFrame;
    1:   nsIFrame* parent = aParentFrame;
    1:   nsRefPtr<nsStyleContext> blockStyle = aStyleContext;
    1:   const nsStyleColumn* columns = aStyleContext->GetStyleColumn();
    1: 
    1:   if (columns->mColumnCount != NS_STYLE_COLUMN_COUNT_AUTO
    1:       || columns->mColumnWidth.GetUnit() != eStyleUnit_Auto) {
    1:     nsIFrame* columnSetFrame = nsnull;
    1:     columnSetFrame = NS_NewColumnSetFrame(mPresShell, aStyleContext, 0);
    1:     if (!columnSetFrame) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, columnSetFrame);
23395:     // See if we need to create a view
23395:     nsHTMLContainerFrame::CreateViewForFrame(columnSetFrame, PR_FALSE);
    1:     blockStyle = mPresShell->StyleSet()->
35554:       ResolveAnonymousBoxStyle(nsCSSAnonBoxes::columnContent, aStyleContext);
    1:     parent = columnSetFrame;
    1:     *aNewFrame = columnSetFrame;
    1: 
30790:     SetInitialSingleChild(columnSetFrame, blockFrame);
    1:   }
    1: 
    1:   blockFrame->SetStyleContextWithoutNotification(blockStyle);
    1:   InitAndRestoreFrame(aState, aContent, parent, nsnull, blockFrame);
    1: 
 8199:   nsresult rv = aState.AddChild(*aNewFrame, aFrameItems, aContent,
 8199:                                 aStyleContext,
    1:                                 aContentParentFrame ? aContentParentFrame :
    1:                                                       aParentFrame);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // See if we need to create a view, e.g. the frame is absolutely positioned
23395:   nsHTMLContainerFrame::CreateViewForFrame(blockFrame, PR_FALSE);
    1: 
24659:   if (!mRootElementFrame) {
24659:     // The frame we're constructing will be the root element frame.
24659:     // Set mRootElementFrame before processing children.
24659:     mRootElementFrame = *aNewFrame;
20147:   }
20147: 
    1:   // We should make the outer frame be the absolute containing block,
    1:   // if one is required. We have to do this because absolute
    1:   // positioning must be computed with respect to the CSS dimensions
    1:   // of the element, which are the dimensions of the outer block. But
    1:   // we can't really do that because only blocks can have absolute
    1:   // children. So use the block and try to compensate with hacks
    1:   // in nsBlockFrame::CalculateContainingBlockSizeForAbsolutes.
    1:   nsFrameConstructorSaveState absoluteSaveState;
    1:   if (aAbsPosContainer) {
    1:     //    NS_ASSERTION(aRelPos, "should have made area frame for this");
    1:     aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
    1:   }
    1: 
    1:   // Process the child content
    1:   nsFrameItems childItems;
23352:   rv = ProcessChildren(aState, aContent, aStyleContext, blockFrame, PR_TRUE,
34614:                        childItems, PR_TRUE, aPendingBinding);
    1: 
    1:   // Set the frame's initial child list
30785:   blockFrame->SetInitialChildList(nsnull, childItems);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ConstructInline(nsFrameConstructorState& aState,
25769:                                        FrameConstructionItem&   aItem,
    1:                                        nsIFrame*                aParentFrame,
25131:                                        const nsStyleDisplay*    aDisplay,
25131:                                        nsFrameItems&            aFrameItems,
25131:                                        nsIFrame**               aNewFrame)
25131: {
34462:   // If an inline frame has non-inline kids, then we chop up the child list
34462:   // into runs of blocks and runs of inlines, create anonymous block frames to
34462:   // contain the runs of blocks, inline frames with our style context for the
34462:   // runs of inlines, and put all these frames, in order, into aFrameItems.  We
34462:   // put the first one into *aNewFrame.  The whole setup is called an {ib}
34462:   // split; in what follows "frames in the split" refers to the anonymous blocks
34462:   // and inlines that contain our children.
34462:   //
34462:   // {ib} splits maintain the following invariants:
34462:   // 1) All frames in the split have the NS_FRAME_IS_SPECIAL bit set.
39965:   // 2) Each frame in the split has the nsIFrame::IBSplitSpecialSibling
34462:   //    property pointing to the next frame in the split, except for the last
34462:   //    one, which does not have it set.
39965:   // 3) Each frame in the split has the nsIFrame::IBSplitSpecialPrevSibling
34462:   //    property pointing to the previous frame in the split, except for the
34462:   //    first one, which does not have it set.
34462:   // 4) The first and last frame in the split are always inlines.
34462:   //
34462:   // An invariant that is NOT maintained is that the wrappers are actually
34462:   // linked via GetNextSibling linkage.  A simple example is an inline
34462:   // containing an inline that contains a block.  The three parts of the inner
34462:   // inline end up with three different parents.
34462:   //
34462:   // For example, this HTML:
34462:   // <span>
34462:   //   <div>a</div>
34462:   //   <span>
34462:   //     b
34462:   //     <div>c</div>
34462:   //   </span>
34462:   //   d
34462:   //   <div>e</div>
34462:   //   f
34462:   //  </span>
34462:   // Gives the following frame tree:
34462:   //
34462:   // Inline (outer span)
34462:   // Block (anonymous, outer span)
34462:   //   Block (div)
34462:   //     Text("a")
34462:   // Inline (outer span)
34462:   //   Inline (inner span)
34462:   //     Text("b")
34462:   // Block (anonymous, outer span)
34462:   //   Block (anonymous, inner span)
34462:   //     Block (div)
34462:   //       Text("c")
34462:   // Inline (outer span)
34462:   //   Inline (inner span)
34462:   //   Text("d")
34462:   // Block (anonymous, outer span)
34462:   //   Block (div)
34462:   //     Text("e")
34462:   // Inline (outer span)
34462:   //   Text("f")
34462: 
25769:   nsIContent* const content = aItem.mContent;
25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
25769: 
25131:   nsIFrame *newFrame;
25131: 
25131:   PRBool positioned =
25131:     NS_STYLE_DISPLAY_INLINE == aDisplay->mDisplay &&
25131:     (NS_STYLE_POSITION_RELATIVE == aDisplay->mPosition ||
25131:      aDisplay->HasTransform());
25131:   if (positioned) {
25769:     newFrame = NS_NewPositionedInlineFrame(mPresShell, styleContext);
25131:   } else {
25769:     newFrame = NS_NewInlineFrame(mPresShell, styleContext);
25131:   }
25131: 
    1:   // Initialize the frame
25769:   InitAndRestoreFrame(aState, content, aParentFrame, nsnull, newFrame);
    1: 
    1:   nsFrameConstructorSaveState absoluteSaveState;  // definition cannot be inside next block
    1:                                                   // because the object's destructor is significant
    1:                                                   // this is part of the fix for bug 42372
    1: 
    1:   // Any inline frame might need a view (because of opacity, or fixed background)
25131:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, PR_FALSE);
25131: 
25131:   if (positioned) {                            
    1:     // Relatively positioned frames becomes a container for child
    1:     // frames that are positioned
25131:     aState.PushAbsoluteContainingBlock(newFrame, absoluteSaveState);
    1:   }
    1: 
    1:   // Process the child content
    1:   nsFrameItems childItems;
26208:   nsresult rv = ConstructFramesFromItemList(aState, aItem.mChildItems, newFrame,
26208:                                             childItems);
25772:   if (NS_FAILED(rv)) {
25772:     // Clean up?
25772:     return rv;
25772:   }
25772: 
30789:   nsFrameList::FrameLinkEnumerator firstBlockEnumerator(childItems);
30789:   if (!aItem.mIsAllInline) {
30789:     FindFirstBlock(firstBlockEnumerator);
30789:   }
30789: 
30789:   if (aItem.mIsAllInline || firstBlockEnumerator.AtEnd()) { 
25772:     // This part is easy.  We either already know we have no non-inline kids,
25772:     // or haven't found any when constructing actual frames (the latter can
25772:     // happen only if out-of-flows that we thought had no containing block
25772:     // acquired one when ancestor inline frames and {ib} splits got
25772:     // constructed).  Just put all the kids into the single inline frame and
25772:     // bail.
30785:     newFrame->SetInitialChildList(nsnull, childItems);
25131:     if (NS_SUCCEEDED(rv)) {
25769:       aState.AddChild(newFrame, aFrameItems, content, styleContext, aParentFrame);
25131:       *aNewFrame = newFrame;
25131:     }
    1:     return rv;
    1:   }
    1: 
34462:   // This inline frame contains several types of children. Therefore this frame
34462:   // has to be chopped into several pieces, as described above.
    1: 
30789:   // Grab the first inline's kids
32843:   nsFrameList firstInlineKids = childItems.ExtractHead(firstBlockEnumerator);
30789:   newFrame->SetInitialChildList(nsnull, firstInlineKids);
30789: 
34462:   aFrameItems.AddChild(newFrame);
34462: 
34462:   CreateIBSiblings(aState, newFrame, positioned, childItems, aFrameItems);
34462: 
34462:   *aNewFrame = newFrame;
34462:   return NS_OK;
34462: }
34462: 
34462: void
34462: nsCSSFrameConstructor::CreateIBSiblings(nsFrameConstructorState& aState,
34462:                                         nsIFrame* aInitialInline,
34462:                                         PRBool aIsPositioned,
34462:                                         nsFrameItems& aChildItems,
34462:                                         nsFrameItems& aSiblings)
34462: {
34462:   nsIContent* content = aInitialInline->GetContent();
34462:   nsStyleContext* styleContext = aInitialInline->GetStyleContext();
34462:   nsIFrame* parentFrame = aInitialInline->GetParent();
34462: 
34462:   // Resolve the right style context for our anonymous blocks.
34462:   nsRefPtr<nsStyleContext> blockSC =
34462:     mPresShell->StyleSet()->
35554:       ResolveAnonymousBoxStyle(aIsPositioned ?
34462:                                  nsCSSAnonBoxes::mozAnonymousPositionedBlock :
34462:                                  nsCSSAnonBoxes::mozAnonymousBlock,
34462:                                styleContext);
34462: 
34462:   nsIFrame* lastNewInline = aInitialInline->GetFirstContinuation();
34462:   do {
34462:     // On entry to this loop aChildItems is not empty and the first frame in it
34462:     // is block-level.
34462:     NS_PRECONDITION(aChildItems.NotEmpty(), "Should have child items");
34462:     NS_PRECONDITION(!IsInlineOutside(aChildItems.FirstChild()),
34462:                     "Must have list starting with block");
34462: 
34462:     // The initial run of blocks belongs to an anonymous block that we create
34462:     // right now. The anonymous block will be the parent of these block
34462:     // children of the inline.
    1:     nsIFrame* blockFrame;
    1:     blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
    1: 
34462:     InitAndRestoreFrame(aState, content, parentFrame, nsnull, blockFrame,
34462:                         PR_FALSE);
34462: 
34462:     // Any frame could have a view
23395:     nsHTMLContainerFrame::CreateViewForFrame(blockFrame, PR_FALSE);
    1: 
34462:     // Find the first non-block child which defines the end of our block kids
34462:     // and the start of our next inline's kids
34462:     nsFrameList::FrameLinkEnumerator firstNonBlock =
34462:       FindFirstNonBlock(aChildItems);
34462:     nsFrameList blockKids = aChildItems.ExtractHead(firstNonBlock);
34462: 
34464:     MoveChildrenTo(aState.mPresContext, aInitialInline, blockFrame, blockKids);
34462: 
34462:     SetFrameIsSpecial(lastNewInline, blockFrame);
34462:     aSiblings.AddChild(blockFrame);
34462: 
34462:     // Now grab the initial inlines in aChildItems and put them into an inline
34462:     // frame
25738:     nsIFrame* inlineFrame;
34462:     if (aIsPositioned) {
25769:       inlineFrame = NS_NewPositionedInlineFrame(mPresShell, styleContext);
25738:     }
25738:     else {
25769:       inlineFrame = NS_NewInlineFrame(mPresShell, styleContext);
25769:     }
25769: 
34462:     InitAndRestoreFrame(aState, content, parentFrame, nsnull, inlineFrame,
25738:                         PR_FALSE);
25738: 
25738:     // Any frame might need a view
25738:     nsHTMLContainerFrame::CreateViewForFrame(inlineFrame, PR_FALSE);
25738: 
34462:     if (aChildItems.NotEmpty()) {
34462:       nsFrameList::FrameLinkEnumerator firstBlock(aChildItems);
34462:       FindFirstBlock(firstBlock);
34462:       nsFrameList inlineKids = aChildItems.ExtractHead(firstBlock);
34463: 
34464:       MoveChildrenTo(aState.mPresContext, aInitialInline, inlineFrame,
34464:                      inlineKids);
34462:     }
34462: 
    1:     SetFrameIsSpecial(blockFrame, inlineFrame);
34462:     aSiblings.AddChild(inlineFrame);
34462:     lastNewInline = inlineFrame;
34462:   } while (aChildItems.NotEmpty());
34462: 
34462:   SetFrameIsSpecial(lastNewInline, nsnull);
    1: }
    1: 
25738: void
25772: nsCSSFrameConstructor::BuildInlineChildItems(nsFrameConstructorState& aState,
25772:                                              FrameConstructionItem& aParentItem)
25772: {
25772:   // XXXbz should we preallocate aParentItem.mChildItems to some sane
25772:   // length?  Maybe even to parentContent->GetChildCount()?
34614:   nsFrameConstructorState::PendingBindingAutoPusher
34614:     pusher(aState, aParentItem.mPendingBinding);
25772: 
    1:   // Probe for generated content before
25772:   nsStyleContext* const parentStyleContext = aParentItem.mStyleContext;
25772:   nsIContent* const parentContent = aParentItem.mContent;
35554:   CreateGeneratedContentItem(aState, nsnull, parentContent, parentStyleContext,
35554:                              nsCSSPseudoElements::ePseudo_before,
25772:                              aParentItem.mChildItems);
25772: 
    1:   ChildIterator iter, last;
25772:   for (ChildIterator::Init(parentContent, &iter, &last);
    1:        iter != last;
    1:        ++iter) {
25772:     // Manually check for comments/PIs, since we do't have a frame to pass to
25772:     // AddFrameConstructionItems.  We know our parent is a non-replaced inline,
25772:     // so there is no need to do the NeedFrameFor check.
25772:     nsIContent* content = *iter;
40938:     content->UnsetFlags(NODE_DESCENDANTS_NEED_FRAMES | NODE_NEEDS_FRAME);
25772:     if (content->IsNodeOfType(nsINode::eCOMMENT) ||
25772:         content->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION)) {
25772:       continue;
25772:     }
43792:     if (content->IsElement()) {
43792:       // See comment explaining why we need to remove the "is possible
43792:       // restyle root" flags in AddFrameConstructionItems.  But note
43792:       // that we can remove all restyle flags, just like in
43792:       // ProcessChildren and for the same reason.
43792:       content->UnsetFlags(ELEMENT_ALL_RESTYLE_FLAGS);
43792:     }
25772: 
25772:     nsRefPtr<nsStyleContext> childContext =
25772:       ResolveStyleContext(parentStyleContext, content);
25772: 
25772:     AddFrameConstructionItemsInternal(aState, content, nsnull, content->Tag(),
47661:                                       content->GetNameSpaceID(),
47661:                                       iter.XBLInvolved(), childContext,
25772:                                       ITEM_ALLOW_XBL_BASE | ITEM_ALLOW_PAGE_BREAK,
25772:                                       aParentItem.mChildItems);
25772:   }
25772: 
25768:   // Probe for generated content after
35554:   CreateGeneratedContentItem(aState, nsnull, parentContent, parentStyleContext,
35554:                              nsCSSPseudoElements::ePseudo_after,
25772:                              aParentItem.mChildItems);
25772: 
25774:   aParentItem.mIsAllInline = aParentItem.mChildItems.AreAllItemsInline();
    1: }
    1: 
35612: // return whether it's ok to append (in the AppendFrames sense) to
35612: // aParentFrame if our nextSibling is aNextSibling.  aParentFrame must
35612: // be an {ib} special inline.
35612: static PRBool
35612: IsSafeToAppendToSpecialInline(nsIFrame* aParentFrame, nsIFrame* aNextSibling)
35612: {
35612:   NS_PRECONDITION(IsInlineFrame(aParentFrame),
35612:                   "Must have an inline parent here");
35612:   do {
35612:     NS_ASSERTION(IsFrameSpecial(aParentFrame), "How is this not special?");
35612:     if (aNextSibling || aParentFrame->GetNextContinuation() ||
35612:         GetSpecialSibling(aParentFrame)) {
35612:       return PR_FALSE;
35612:     }
35612: 
35612:     aNextSibling = aParentFrame->GetNextSibling();
35612:     aParentFrame = aParentFrame->GetParent();
35612:   } while (IsInlineFrame(aParentFrame));
36325: 
36325:   return PR_TRUE;
35612: }
35612: 
    1: PRBool
    1: nsCSSFrameConstructor::WipeContainingBlock(nsFrameConstructorState& aState,
    1:                                            nsIFrame* aContainingBlock,
    1:                                            nsIFrame* aFrame,
27311:                                            FrameConstructionItemList& aItems,
 4696:                                            PRBool aIsAppend,
 4696:                                            nsIFrame* aPrevSibling)
 4696: {
25774:   if (aItems.IsEmpty()) {
 4696:     return PR_FALSE;
 4696:   }
 4696:   
34462:   // Before we go and append the frames, we must check for several
 7189:   // special situations.
 7189: 
 7189:   // Situation #1 is a XUL frame that contains frames that are required
 7189:   // to be wrapped in blocks.
 7189:   if (aFrame->IsBoxFrame() &&
 7189:       !(aFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
25774:       aItems.AnyItemsNeedBlockParent()) {
31031:     RecreateFramesForContent(aFrame->GetContent(), PR_TRUE);
 7189:     return PR_TRUE;
 7189:   }
 7189: 
27311:   nsIFrame* nextSibling = ::GetInsertNextSibling(aFrame, aPrevSibling);
27311: 
26607:   // Situation #2 is a case when table pseudo-frames don't work out right
26607:   ParentType parentType = GetParentType(aFrame);
26607:   // If all the kids want a parent of the type that aFrame is, then we're all
26607:   // set to go.  Indeed, there won't be any table pseudo-frames created between
26607:   // aFrame and the kids, so those won't need to be merged with any table
26607:   // pseudo-frames that might already be kids of aFrame.  If aFrame itself is a
26607:   // table pseudo-frame, then all the kids in this list would have wanted a
26607:   // frame of that type wrapping them anyway, so putting them inside it is ok.
26607:   if (!aItems.AllWantParentType(parentType)) {
27311:     // Don't give up yet.  If parentType is not eTypeBlock and the parent is
27311:     // not a generated content frame, then try filtering whitespace out of the
27311:     // list.
27311:     if (parentType != eTypeBlock && !aFrame->IsGeneratedContentFrame()) {
27311:       // For leading whitespace followed by a kid that wants our parent type,
27311:       // there are four cases:
27311:       // 1) We have a previous sibling which is not a table pseudo.  That means
27311:       //    that previous sibling wanted a (non-block) parent of the type we're
27311:       //    looking at.  Then the whitespace comes between two table-internal
27311:       //    elements, so should be collapsed out.
27311:       // 2) We have a previous sibling which is a table pseudo.  It might have
27311:       //    kids who want this whitespace, so we need to reframe.
29838:       // 3) We have no previous sibling and our parent frame is not a table
29838:       //    pseudo.  That means that we'll be at the beginning of our actual
29838:       //    non-block-type parent, and the whitespace is OK to collapse out.
29838:       //    If something is ever inserted before us, it'll find our own parent
29838:       //    as its parent and if it's something that would care about the
29838:       //    whitespace it'll want a block parent, so it'll trigger a reframe at
29838:       //    that point.
29838:       // 4) We have no previous sibling and our parent frame is a table pseudo.
29838:       //    Need to reframe.
29838:       // All that is predicated on finding the correct previous sibling.  We
29838:       // might have to walk backwards along continuations from aFrame to do so.
27311:       //
27311:       // It's always OK to drop whitespace between any two items that want a
27311:       // parent of type parentType.
27311:       //
29838:       // For trailing whitespace preceded by a kid that wants our parent type,
29838:       // there are four cases:
29838:       // 1) We have a next sibling which is not a table pseudo.  That means
29838:       //    that next sibling wanted a (non-block) parent of the type we're
29838:       //    looking at.  Then the whitespace comes between two table-internal
29838:       //    elements, so should be collapsed out.
29838:       // 2) We have a next sibling which is a table pseudo.  It might have
29838:       //    kids who want this whitespace, so we need to reframe.
29838:       // 3) We have no next sibling and our parent frame is not a table
29838:       //    pseudo.  That means that we'll be at the end of our actual
29838:       //    non-block-type parent, and the whitespace is OK to collapse out.
29838:       //    If something is ever inserted after us, it'll find our own parent
29838:       //    as its parent and if it's something that would care about the
29838:       //    whitespace it'll want a block parent, so it'll trigger a reframe at
29838:       //    that point.
29838:       // 4) We have no next sibling and our parent frame is a table pseudo.
29838:       //    Need to reframe.
29838:       // All that is predicated on finding the correct next sibling.  We might
29838:       // have to walk forward along continuations from aFrame to do so.  That
29838:       // said, in the case when nextSibling is null at this point and aIsAppend
29838:       // is true, we know we're in case 3.  Furthermore, in that case we don't
29838:       // even have to worry about the table pseudo situation; we know our
29838:       // parent is not a table pseudo there.
27311:       FCItemIterator iter(aItems);
27311:       FCItemIterator start(iter);
27311:       do {
27311:         if (iter.SkipItemsWantingParentType(parentType)) {
27311:           break;
27311:         }
27311: 
27311:         // iter points to an item that wants a different parent.  If it's not
27311:         // whitespace, we're done; no more point scanning the list.
41931:         if (!iter.item().IsWhitespace(aState)) {
27311:           break;
27311:         }
27311: 
27311:         if (iter == start) {
29838:           // Leading whitespace.  How to handle this depends on our
29838:           // previous sibling and aFrame.  See the long comment above.
29838:           nsIFrame* prevSibling = aPrevSibling;
29838:           if (!prevSibling) {
29838:             // Try to find one after all
29838:             nsIFrame* parentPrevCont = aFrame->GetPrevContinuation();
29838:             while (parentPrevCont) {
32841:               prevSibling = parentPrevCont->GetLastChild(nsnull);
29838:               if (prevSibling) {
29838:                 break;
29838:               }
29838:               parentPrevCont = parentPrevCont->GetPrevContinuation();
29838:             }
29838:           };
29838:           if (prevSibling) {
29838:             if (IsTablePseudo(prevSibling)) {
27311:               // need to reframe
27311:               break;
27311:             }
29838:           } else if (IsTablePseudo(aFrame)) {
27311:             // need to reframe
27311:             break;
27311:           }
27311:         }
27311: 
27311:         FCItemIterator spaceEndIter(iter);
27311:         // Advance spaceEndIter past any whitespace
41931:         PRBool trailingSpaces = spaceEndIter.SkipWhitespace(aState);
27311: 
29838:         PRBool okToDrop;
29838:         if (trailingSpaces) {
29838:           // Trailing whitespace.  How to handle this depeds on aIsAppend, our
29838:           // next sibling and aFrame.  See the long comment above.
29838:           okToDrop = aIsAppend && !nextSibling;
29838:           if (!okToDrop) {
29838:             if (!nextSibling) {
29838:               // Try to find one after all
29838:               nsIFrame* parentNextCont = aFrame->GetNextContinuation();
29838:               while (parentNextCont) {
29838:                 nextSibling = parentNextCont->GetFirstChild(nsnull);
29838:                 if (nextSibling) {
29838:                   break;
29838:                 }
29838:                 parentNextCont = parentNextCont->GetNextContinuation();
29838:               }
29838:             }
29838: 
29838:             okToDrop = (nextSibling && !IsTablePseudo(nextSibling)) ||
29838:                        (!nextSibling && !IsTablePseudo(aFrame));
29838:           }
29838: #ifdef DEBUG
29838:           else {
29838:             NS_ASSERTION(!IsTablePseudo(aFrame), "How did that happen?");
29838:           }
29838: #endif
29838:         } else {
29838:           okToDrop = (spaceEndIter.item().DesiredParentType() == parentType);
29838:         }
29838: 
29838:         if (okToDrop) {
27311:           iter.DeleteItemsTo(spaceEndIter);
27311:         } else {
27311:           // We're done: we don't want to drop the whitespace, and it has the
27311:           // wrong parent type.
27311:           break;
27311:         }
27311: 
27311:         // Now loop, since |iter| points to item right after the whitespace we
27311:         // removed.
27311:       } while (!iter.IsDone());
27311:     }
27311: 
26607:     // We might be able to figure out some sort of optimizations here, but they
26607:     // would have to depend on having a correct aPrevSibling and a correct next
26607:     // sibling.  For example, we can probably avoid reframing if none of
26607:     // aFrame, aPrevSibling, and next sibling are table pseudo-frames.  But it
26607:     // doesn't seem worth it to worry about that for now, especially since we
26607:     // in fact do not have a reliable aPrevSibling, nor any next sibling, in
26607:     // this method.
26607: 
27311:     // aItems might have changed, so recheck the parent type thing.  In fact,
27311:     // it might be empty, so recheck that too.
27311:     if (aItems.IsEmpty()) {
27311:       return PR_FALSE;
27311:     }
27311: 
27311:     if (!aItems.AllWantParentType(parentType)) {
26607:       // Reframing aFrame->GetContent() is good enough, since the content of
26607:       // table pseudo-frames is the ancestor content.
31031:       RecreateFramesForContent(aFrame->GetContent(), PR_TRUE);
26607:       return PR_TRUE;
26607:     }
27311:   }
26607: 
34462:   // Now we have several cases involving {ib} splits.  Put them all in a
34462:   // do/while with breaks to take us to the "go and reconstruct" code.
34462:   do {
 4696:     if (IsInlineFrame(aFrame)) {
25774:       if (aItems.AreAllItemsInline()) {
34462:         // We can just put the kids in.
    1:         return PR_FALSE;
 4696:       }
34462: 
34462:       if (!IsFrameSpecial(aFrame)) {
34462:         // Need to go ahead and reconstruct.
34462:         break;
34462:       }
34462: 
34462:       // Now we're adding kids including some blocks to an inline part of an
34462:       // {ib} split.  If we plan to call AppendFrames, and don't have a next
34462:       // sibling for the new frames, and our parent is the last continuation of
35612:       // the last part of the {ib} split, and the same is true of all our
35612:       // ancestor inlines (they have no following continuations and they're the
35612:       // last part of their {ib} splits and we'd be adding to the end for all
35612:       // of them), then AppendFrames will handle things for us.  Bail out in
35612:       // that case.
35612:       if (aIsAppend && IsSafeToAppendToSpecialInline(aFrame, nextSibling)) {
 4696:         return PR_FALSE;
34462:       }
34462: 
34462:       // Need to reconstruct.
34462:       break;
34462:     }
34462: 
34462:     // Now we know we have a block parent.  If it's not special, we're all set.
34462:     if (!IsFrameSpecial(aFrame)) {
27310:       return PR_FALSE;
27310:     }
27310: 
34462:     // We're adding some kids to a block part of an {ib} split.  If all the
34462:     // kids are blocks, we don't need to reconstruct.
34462:     if (aItems.AreAllItemsBlock()) {
34462:       return PR_FALSE;
34462:     }
34462: 
34462:     // We might have some inline kids for this block.  Just reconstruct.
 5324:     break;
34462:   } while (0);
    1: 
    1:   // If we don't have a containing block, start with aFrame and look for one.
    1:   if (!aContainingBlock) {
    1:     aContainingBlock = aFrame;
    1:   }
    1:   
    1:   // To find the right block to reframe, just walk up the tree until we find a
    1:   // frame that is:
    1:   // 1)  Not part of an IB split (not special)
    1:   // 2)  Not a pseudo-frame
    1:   // 3)  Not an inline frame
    1:   // We're guaranteed to find one, since nsStyleContext::ApplyStyleFixups
    1:   // enforces that the root is display:none, display:table, or display:block.
    1:   // Note that walking up "too far" is OK in terms of correctness, even if it
    1:   // might be a little inefficient.  This is why we walk out of all
    1:   // pseudo-frames -- telling which ones are or are not OK to walk out of is
    1:   // too hard (and I suspect that we do in fact need to walk out of all of
    1:   // them).
 2829:   while (IsFrameSpecial(aContainingBlock) || IsInlineOutside(aContainingBlock) ||
34387:          aContainingBlock->GetStyleContext()->GetPseudo()) {
    1:     aContainingBlock = aContainingBlock->GetParent();
    1:     NS_ASSERTION(aContainingBlock,
    1:                  "Must have non-inline, non-special, non-pseudo frame as root "
    1:                  "(or child of root, for a table root)!");
    1:   }
    1: 
    1:   // Tell parent of the containing block to reformulate the
    1:   // entire block. This is painful and definitely not optimal
    1:   // but it will *always* get the right answer.
    1: 
    1:   nsIContent *blockContent = aContainingBlock->GetContent();
    1: #ifdef DEBUG
    1:   if (gNoisyContentUpdates) {
28215:     printf("nsCSSFrameConstructor::WipeContainingBlock: blockContent=%p\n",
28215:            static_cast<void*>(blockContent));
28215:   }
28215: #endif
31031:   RecreateFramesForContent(blockContent, PR_TRUE);
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsCSSFrameConstructor::ReframeContainingBlock(nsIFrame* aFrame)
    1: {
    1: 
    1: #ifdef DEBUG
    1:   // ReframeContainingBlock is a NASTY routine, it causes terrible performance problems
    1:   // so I want to see when it is happening!  Unfortunately, it is happening way to often because
    1:   // so much content on the web causes 'special' block-in-inline frame situations and we handle them
    1:   // very poorly
    1:   if (gNoisyContentUpdates) {
    1:     printf("nsCSSFrameConstructor::ReframeContainingBlock frame=%p\n",
 3233:            static_cast<void*>(aFrame));
    1:   }
    1: #endif
    1: 
28215:   // XXXbz how exactly would we get here while isReflowing anyway?  Should this
28215:   // whole test be ifdef DEBUG?
40048:   if (mPresShell->IsReflowLocked()) {
    1:     // don't ReframeContainingBlock, this will result in a crash
    1:     // if we remove a tree that's in reflow - see bug 121368 for testcase
31561:     NS_ERROR("Atemptted to nsCSSFrameConstructor::ReframeContainingBlock during a Reflow!!!");
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Get the first "normal" ancestor of the target frame.
    1:   nsIFrame* containingBlock = GetIBContainingBlockFor(aFrame);
    1:   if (containingBlock) {
    1:     // From here we look for the containing block in case the target
    1:     // frame is already a block (which can happen when an inline frame
    1:     // wraps some of its content in an anonymous block; see
    1:     // ConstructInline)
    1:    
    1:     // NOTE: We used to get the FloatContainingBlock here, but it was often wrong.
    1:     // GetIBContainingBlock works much better and provides the correct container in all cases
    1:     // so GetFloatContainingBlock(aFrame) has been removed
    1: 
    1:     // And get the containingBlock's content
    1:     nsCOMPtr<nsIContent> blockContent = containingBlock->GetContent();
    1:     if (blockContent) {
    1: #ifdef DEBUG
    1:       if (gNoisyContentUpdates) {
28215:         printf("  ==> blockContent=%p\n", static_cast<void*>(blockContent));
28215:       }
28215: #endif
31031:       return RecreateFramesForContent(blockContent, PR_TRUE);
    1:     }
    1:   }
    1: 
    1:   // If we get here, we're screwed!
41634:   return RecreateFramesForContent(mPresShell->GetDocument()->GetRootElement(),
41634: 				  PR_TRUE);
    1: }
    1: 
11845: void
42349: nsCSSFrameConstructor::RestyleForEmptyChange(Element* aContainer)
42349: {
42349:   // In some cases (:empty + E, :empty ~ E), a change if the content of
43794:   // an element requires restyling its parent's siblings.
43793:   nsRestyleHint hint = eRestyle_Subtree;
42349:   nsIContent* grandparent = aContainer->GetParent();
42349:   if (grandparent &&
42350:       (grandparent->GetFlags() & NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS)) {
42350:     hint = nsRestyleHint(hint | eRestyle_LaterSiblings);
42350:   }
42350:   PostRestyleEvent(aContainer, hint, NS_STYLE_HINT_NONE);
42349: }
42349: 
42349: void
42324: nsCSSFrameConstructor::RestyleForAppend(Element* aContainer,
42324:                                         nsIContent* aFirstNewContent)
11845: {
11845:   NS_ASSERTION(aContainer, "must have container for append");
15302: #ifdef DEBUG
15302:   {
42324:     for (nsIContent* cur = aFirstNewContent; cur; cur = cur->GetNextSibling()) {
42324:       NS_ASSERTION(!cur->IsRootOfAnonymousSubtree(),
16128:                    "anonymous nodes should not be in child lists");
15302:     }
15302:   }
15302: #endif
11845:   PRUint32 selectorFlags =
11845:     aContainer->GetFlags() & (NODE_ALL_SELECTOR_FLAGS &
42350:                               ~NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS);
11845:   if (selectorFlags == 0)
11845:     return;
11845: 
11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
11845:     // see whether we need to restyle the container
11845:     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
42324:     for (nsIContent* cur = aContainer->GetFirstChild();
42324:          cur != aFirstNewContent;
42324:          cur = cur->GetNextSibling()) {
11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
11845:       // IsSignificantChild less likely to be true, and thus make us more
11845:       // likely to restyle).
42324:       if (nsStyleUtil::IsSignificantChild(cur, PR_TRUE, PR_FALSE)) {
11845:         wasEmpty = PR_FALSE;
11845:         break;
11845:       }
11845:     }
11845:     if (wasEmpty) {
42349:       RestyleForEmptyChange(aContainer);
42349:       return;
42349:     }
42349:   }
42349: 
42349:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
43793:     PostRestyleEvent(aContainer, eRestyle_Subtree, NS_STYLE_HINT_NONE);
11845:     // Restyling the container is the most we can do here, so we're done.
11845:     return;
11845:   }
42349: 
11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
11845:     // restyle the last element child before this node
42324:     for (nsIContent* cur = aFirstNewContent->GetPreviousSibling();
42324:          cur;
42324:          cur = cur->GetPreviousSibling()) {
42324:       if (cur->IsElement()) {
43793:         PostRestyleEvent(cur->AsElement(), eRestyle_Subtree, NS_STYLE_HINT_NONE);
11845:         break;
11845:       }
11845:     }
11845:   }
11845: }
11845: 
42350: // Needed since we can't use PostRestyleEvent on non-elements (with
43793: // eRestyle_LaterSiblings or nsRestyleHint(eRestyle_Subtree |
42350: // eRestyle_LaterSiblings) as appropriate).
42350: static void
42350: RestyleSiblingsStartingWith(nsCSSFrameConstructor *aFrameConstructor,
42350:                             nsIContent *aStartingSibling /* may be null */)
42350: {
43792:   for (nsIContent *sibling = aStartingSibling; sibling;
43792:        sibling = sibling->GetNextSibling()) {
43792:     if (sibling->IsElement()) {
43792:       aFrameConstructor->
43792:         PostRestyleEvent(sibling->AsElement(),
43793:                          nsRestyleHint(eRestyle_Subtree | eRestyle_LaterSiblings),
42350:                          NS_STYLE_HINT_NONE);
43792:       break;
42350:     }
42350:   }
42350: }
42350: 
11845: // Restyling for a ContentInserted or CharacterDataChanged notification.
11845: // This could be used for ContentRemoved as well if we got the
11845: // notification before the removal happened (and sometimes
11845: // CharacterDataChanged is more like a removal than an addition).
11845: // The comments are written and variables are named in terms of it being
11845: // a ContentInserted notification.
11845: void
42324: nsCSSFrameConstructor::RestyleForInsertOrChange(Element* aContainer,
11845:                                                 nsIContent* aChild)
11845: {
16128:   NS_ASSERTION(!aChild->IsRootOfAnonymousSubtree(),
16128:                "anonymous nodes should not be in child lists");
11845:   PRUint32 selectorFlags =
11845:     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
11845:   if (selectorFlags == 0)
11845:     return;
11845: 
11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
11845:     // see whether we need to restyle the container
11845:     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
42324:     for (nsIContent* child = aContainer->GetFirstChild();
42324:          child;
42324:          child = child->GetNextSibling()) {
11845:       if (child == aChild)
11845:         continue;
11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
11845:       // IsSignificantChild less likely to be true, and thus make us more
11845:       // likely to restyle).
11845:       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
11845:         wasEmpty = PR_FALSE;
11845:         break;
11845:       }
11845:     }
11845:     if (wasEmpty) {
42349:       RestyleForEmptyChange(aContainer);
42349:       return;
42349:     }
42349:   }
42349: 
42350:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
43793:     PostRestyleEvent(aContainer, eRestyle_Subtree, NS_STYLE_HINT_NONE);
11845:     // Restyling the container is the most we can do here, so we're done.
11845:     return;
11845:   }
11845: 
42350:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS) {
42350:     // Restyle all later siblings.
42350:     RestyleSiblingsStartingWith(this, aChild->GetNextSibling());
42350:   }
42350: 
11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
11845:     // restyle the previously-first element child if it is after this node
11845:     PRBool passedChild = PR_FALSE;
42324:     for (nsIContent* content = aContainer->GetFirstChild();
42324:          content;
42324:          content = content->GetNextSibling()) {
11845:       if (content == aChild) {
11845:         passedChild = PR_TRUE;
11845:         continue;
11845:       }
41640:       if (content->IsElement()) {
11845:         if (passedChild) {
43793:           PostRestyleEvent(content->AsElement(), eRestyle_Subtree,
42324:                            NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
11845:     }
11845:     // restyle the previously-last element child if it is before this node
11845:     passedChild = PR_FALSE;
42324:     for (nsIContent* content = aContainer->GetLastChild();
42324:          content;
42324:          content = content->GetPreviousSibling()) {
11845:       if (content == aChild) {
11845:         passedChild = PR_TRUE;
11845:         continue;
11845:       }
41640:       if (content->IsElement()) {
11845:         if (passedChild) {
43793:           PostRestyleEvent(content->AsElement(), eRestyle_Subtree,
42324:                            NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
11845:     }
11845:   }
11845: }
11845: 
11845: void
42324: nsCSSFrameConstructor::RestyleForRemove(Element* aContainer,
11845:                                         nsIContent* aOldChild,
42324:                                         nsIContent* aFollowingSibling)
11845: {
16128:   NS_ASSERTION(!aOldChild->IsRootOfAnonymousSubtree(),
16128:                "anonymous nodes should not be in child lists");
11845:   PRUint32 selectorFlags =
11845:     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
11845:   if (selectorFlags == 0)
11845:     return;
11845: 
11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
11845:     // see whether we need to restyle the container
11845:     PRBool isEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
42324:     for (nsIContent* child = aContainer->GetFirstChild();
42324:          child;
42324:          child = child->GetNextSibling()) {
11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
11845:       // IsSignificantChild less likely to be true, and thus make us more
11845:       // likely to restyle).
11845:       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
11845:         isEmpty = PR_FALSE;
11845:         break;
11845:       }
11845:     }
11845:     if (isEmpty) {
42349:       RestyleForEmptyChange(aContainer);
42349:       return;
42349:     }
42349:   }
42349: 
42350:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
43793:     PostRestyleEvent(aContainer, eRestyle_Subtree, NS_STYLE_HINT_NONE);
11845:     // Restyling the container is the most we can do here, so we're done.
11845:     return;
11845:   }
11845: 
42350:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS) {
42350:     // Restyle all later siblings.
42350:     RestyleSiblingsStartingWith(this, aFollowingSibling);
42350:   }
42350: 
11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
42324:     // restyle the now-first element child if it was after aOldChild
42324:     PRBool reachedFollowingSibling = PR_FALSE;
42324:     for (nsIContent* content = aContainer->GetFirstChild();
42324:          content;
42324:          content = content->GetNextSibling()) {
42324:       if (content == aFollowingSibling) {
42324:         reachedFollowingSibling = PR_TRUE;
42324:         // do NOT continue here; we might want to restyle this node
42324:       }
41640:       if (content->IsElement()) {
42324:         if (reachedFollowingSibling) {
43793:           PostRestyleEvent(content->AsElement(), eRestyle_Subtree,
42324:                            NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
11845:     }
42324:     // restyle the now-last element child if it was before aOldChild
42324:     reachedFollowingSibling = (aFollowingSibling == nsnull);
42324:     for (nsIContent* content = aContainer->GetLastChild();
42324:          content;
42324:          content = content->GetPreviousSibling()) {
41640:       if (content->IsElement()) {
42324:         if (reachedFollowingSibling) {
43793:           PostRestyleEvent(content->AsElement(), eRestyle_Subtree, NS_STYLE_HINT_NONE);
11845:         }
11845:         break;
11845:       }
42324:       if (content == aFollowingSibling) {
42324:         reachedFollowingSibling = PR_TRUE;
42324:       }
11845:     }
11845:   }
11845: }
11845: 
11845: 
    1: void
11409: nsCSSFrameConstructor::RebuildAllStyleData(nsChangeHint aExtraHint)
11409: {
11409:   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
11409:                "Should not reconstruct the root of the frame tree.  "
11409:                "Use ReconstructDocElementHierarchy instead.");
11409: 
10073:   mRebuildAllStyleData = PR_FALSE;
22339:   NS_UpdateHint(aExtraHint, mRebuildAllExtraHint);
22339:   mRebuildAllExtraHint = nsChangeHint(0);
10073: 
35581:   if (!mPresShell || !mPresShell->GetRootFrame())
10073:     return;
10073: 
23652:   // Make sure that the viewmanager will outlive the presshell
23652:   nsIViewManager::UpdateViewBatch batch(mPresShell->GetViewManager());
23652: 
21202:   // Processing the style changes could cause a flush that propagates to
21202:   // the parent frame and thus destroys the pres shell.
21202:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(mPresShell);
21202: 
36817:   // We may reconstruct frames below and hence process anything that is in the
36817:   // tree. We don't want to get notified to process those items again after.
36817:   mPresShell->GetDocument()->FlushPendingNotifications(Flush_ContentAndNotify);
36817: 
36817:   nsAutoScriptBlocker scriptBlocker;
36817: 
10073:   // Tell the style set to get the old rule tree out of the way
10073:   // so we can recalculate while maintaining rule tree immutability
10073:   nsresult rv = mPresShell->StyleSet()->BeginReconstruct();
23652:   if (NS_FAILED(rv)) {
23652:     batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
10073:     return;
23652:   }
10073: 
10073:   // Recalculate all of the style contexts for the document
10073:   // Note that we can ignore the return value of ComputeStyleChangeFor
10073:   // because we never need to reframe the root frame
10073:   // XXX This could be made faster by not rerunning rule matching
10073:   // (but note that nsPresShell::SetPreferenceStyleRules currently depends
10073:   // on us re-running rule matching here
10073:   nsStyleChangeList changeList;
11409:   // XXX Does it matter that we're passing aExtraHint to the real root
11409:   // frame and not the root node's primary frame?
43790:   // Note: The restyle tracker we pass in here doesn't matter.
10073:   mPresShell->FrameManager()->ComputeStyleChangeFor(mPresShell->GetRootFrame(),
43790:                                                     &changeList, aExtraHint,
43794:                                                     mPendingRestyles, PR_TRUE);
10073:   // Process the required changes
10073:   ProcessRestyledFrames(changeList);
10073:   // Tell the style set it's safe to destroy the old rule tree.  We
10073:   // must do this after the ProcessRestyledFrames call in case the
10073:   // change list has frame reconstructs in it (since frames to be
10073:   // reconstructed will still have their old style context pointers
10073:   // until they are destroyed).
10073:   mPresShell->StyleSet()->EndReconstruct();
23652:   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
10073: }
10073: 
10073: void
32401: nsCSSFrameConstructor::ProcessPendingRestyles()
32401: {
38816:   NS_PRECONDITION(mDocument, "No document?  Pshaw!");
32401:   NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
32401:                   "Missing a script blocker!");
32401: 
32401:   // Process non-animation restyles...
38816:   nsPresContext *presContext = mPresShell->GetPresContext();
38816:   NS_ABORT_IF_FALSE(!presContext->IsProcessingRestyles(),
38816:                     "Nesting calls to ProcessPendingRestyles?");
38816:   presContext->SetProcessingRestyles(PR_TRUE);
38816: 
43788:   mPendingRestyles.ProcessRestyles();
32401: 
40125: #ifdef DEBUG
40125:   PRUint32 oldPendingRestyleCount = mPendingRestyles.Count();
40125: #endif
36797: 
32401:   // ...and then process animation restyles.  This needs to happen
32401:   // second because we need to start animations that resulted from the
32401:   // first set of restyles (e.g., CSS transitions with negative
32401:   // transition-delay), and because we need to immediately
32401:   // restyle-with-animation any just-restyled elements that are
32401:   // mid-transition (since processing the non-animation restyle ignores
32401:   // the running transition so it can check for a new change on the same
32401:   // property, and then posts an immediate animation style change).
32401:   presContext->SetProcessingAnimationStyleChange(PR_TRUE);
43788:   mPendingAnimationRestyles.ProcessRestyles();
32401:   presContext->SetProcessingAnimationStyleChange(PR_FALSE);
10073: 
38816:   presContext->SetProcessingRestyles(PR_FALSE);
40125:   NS_POSTCONDITION(mPendingRestyles.Count() == oldPendingRestyleCount,
36797:                    "We should not have posted new non-animation restyles while "
36797:                    "processing animation restyles");
36797: 
10073:   if (mRebuildAllStyleData) {
10073:     // We probably wasted a lot of work up above, but this seems safest
10073:     // and it should be rarely used.
36797:     // This might add us as a refresh observer again; that's ok.
11409:     RebuildAllStyleData(nsChangeHint(0));
10073:   }
    1: }
    1: 
    1: void
42328: nsCSSFrameConstructor::PostRestyleEventCommon(Element* aElement,
40075:                                               nsRestyleHint aRestyleHint,
32401:                                               nsChangeHint aMinChangeHint,
32401:                                               PRBool aForAnimation)
    1: {
26803:   if (NS_UNLIKELY(mPresShell->IsDestroying())) {
10402:     return;
10402:   }
10402: 
    1:   if (aRestyleHint == 0 && !aMinChangeHint) {
    1:     // Nothing to do here
    1:     return;
    1:   }
    1: 
43788:   RestyleTracker& tracker =
32401:     aForAnimation ? mPendingAnimationRestyles : mPendingRestyles;
43788:   tracker.AddPendingRestyle(aElement, aRestyleHint, aMinChangeHint);
    1: 
40938:   PostRestyleEventInternal(PR_FALSE);
22339: }
22339:     
22339: void
40938: nsCSSFrameConstructor::PostRestyleEventInternal(PRBool aForLazyConstruction)
22339: {
36797:   // Make sure we're not in a style refresh; if we are, we still have
36797:   // a call to ProcessPendingRestyles coming and there's no need to
36797:   // add ourselves as a refresh observer until then.
50365:   PRBool inRefresh = !aForLazyConstruction && mInStyleRefresh;
40938:   if (!mObservingRefreshDriver && !inRefresh) {
50365:     mObservingRefreshDriver = mPresShell->GetPresContext()->RefreshDriver()->
50365:       AddStyleFlushObserver(mPresShell);
50365:   }
    1: }
    1: 
10073: void
22339: nsCSSFrameConstructor::PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint)
22339: {
22339:   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
22339:                "Should not reconstruct the root of the frame tree.  "
22339:                "Use ReconstructDocElementHierarchy instead.");
22339: 
10073:   mRebuildAllStyleData = PR_TRUE;
22339:   NS_UpdateHint(mRebuildAllExtraHint, aExtraHint);
10073:   // Get a restyle event posted if necessary
40938:   PostRestyleEventInternal(PR_FALSE);
10073: }
10073: 
52061: nsresult
52061: nsCSSFrameConstructor::GenerateChildFrames(nsIFrame* aFrame)
52061: {
23256:   {
23256:     nsAutoScriptBlocker scriptBlocker;
52061:     BeginUpdate();
 6518: 
 3129:     nsFrameItems childItems;
 3129:     nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull);
34614:     // We don't have a parent frame with a pending binding constructor here,
34614:     // so no need to worry about ordering of the kids' constructors with it.
34614:     // Pass null for the PendingBinding.
52061:     nsresult rv = ProcessChildren(state, aFrame->GetContent(), aFrame->GetStyleContext(),
52061:                                   aFrame, PR_FALSE, childItems, PR_FALSE,
34614:                                   nsnull);
23652:     if (NS_FAILED(rv)) {
52061:       EndUpdate();
23652:       return rv;
23652:     }
23167: 
52061:     aFrame->SetInitialChildList(nsnull, childItems);
52061: 
52061:     EndUpdate();
52061:   }
 3129: 
 3129:   // call XBL constructors after the frames are created
 3129:   mPresShell->GetDocument()->BindingManager()->ProcessAttachedQueue();
 3129: 
 3129:   return NS_OK;
 3129: }
26208: 
27311: //////////////////////////////////////////////////////////
27311: // nsCSSFrameConstructor::FrameConstructionItem methods //
27311: //////////////////////////////////////////////////////////
27311: PRBool
41931: nsCSSFrameConstructor::
41931: FrameConstructionItem::IsWhitespace(nsFrameConstructorState& aState) const
41931: {
41931:   NS_PRECONDITION(!aState.mSetPrimaryFrames ||
41931:                   !mContent->GetPrimaryFrame(), "How did that happen?");
27311:   if (!mIsText) {
27311:     return PR_FALSE;
27311:   }
29809:   mContent->SetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE |
29809:                      NS_REFRAME_IF_WHITESPACE);
27311:   return mContent->TextIsOnlyWhitespace();
27311: }
27311: 
26208: //////////////////////////////////////////////////////////////
26208: // nsCSSFrameConstructor::FrameConstructionItemList methods //
26208: //////////////////////////////////////////////////////////////
26208: void
26208: nsCSSFrameConstructor::FrameConstructionItemList::
26208: AdjustCountsForItem(FrameConstructionItem* aItem, PRInt32 aDelta)
26208: {
26208:   NS_PRECONDITION(aDelta == 1 || aDelta == -1, "Unexpected delta");
26208:   mItemCount += aDelta;
26208:   if (aItem->mIsAllInline) {
26208:     mInlineCount += aDelta;
26208:   }
34462:   if (aItem->mIsBlock) {
34462:     mBlockCount += aDelta;
34462:   }
29075:   if (aItem->mIsLineParticipant) {
26208:     mLineParticipantCount += aDelta;
26208:   }
26208:   mDesiredParentCounts[aItem->DesiredParentType()] += aDelta;
26208: }
26208: 
26208: ////////////////////////////////////////////////////////////////////////
26208: // nsCSSFrameConstructor::FrameConstructionItemList::Iterator methods //
26208: ////////////////////////////////////////////////////////////////////////
27311: inline PRBool
27311: nsCSSFrameConstructor::FrameConstructionItemList::
27311: Iterator::SkipItemsWantingParentType(ParentType aParentType)
27311: {
27311:   NS_PRECONDITION(!IsDone(), "Shouldn't be done yet");
27311:   while (item().DesiredParentType() == aParentType) {
27311:     Next();
27311:     if (IsDone()) {
27311:       return PR_TRUE;
27311:     }
27311:   }
27311:   return PR_FALSE;
27311: }
27311: 
27311: inline PRBool
27311: nsCSSFrameConstructor::FrameConstructionItemList::
41931: Iterator::SkipWhitespace(nsFrameConstructorState& aState)
27311: {
27311:   NS_PRECONDITION(!IsDone(), "Shouldn't be done yet");
41931:   NS_PRECONDITION(item().IsWhitespace(aState), "Not pointing to whitespace?");
27311:   do {
27311:     Next();
27311:     if (IsDone()) {
27311:       return PR_TRUE;
27311:     }
41931:   } while (item().IsWhitespace(aState));
27311: 
27311:   return PR_FALSE;
27311: }
27311: 
26208: void
26208: nsCSSFrameConstructor::FrameConstructionItemList::
26208: Iterator::AppendItemToList(FrameConstructionItemList& aTargetList)
26208: {
26208:   NS_ASSERTION(&aTargetList != &mList, "Unexpected call");
26208:   NS_PRECONDITION(!IsDone(), "should not be done");
26208: 
26208:   FrameConstructionItem* item = ToItem(mCurrent);
26208:   Next();
26208:   PR_REMOVE_LINK(item);
26208:   PR_APPEND_LINK(item, &aTargetList.mItems);
26208: 
26208:   mList.AdjustCountsForItem(item, -1);
26208:   aTargetList.AdjustCountsForItem(item, 1);
26208: }
26208: 
26208: void
26208: nsCSSFrameConstructor::FrameConstructionItemList::
26208: Iterator::AppendItemsToList(const Iterator& aEnd,
26208:                             FrameConstructionItemList& aTargetList)
26208: {
26208:   NS_ASSERTION(&aTargetList != &mList, "Unexpected call");
26208:   NS_PRECONDITION(mEnd == aEnd.mEnd, "end iterator for some other list?");
26208: 
26208:   if (!AtStart() || !aEnd.IsDone() || !aTargetList.IsEmpty()) {
26208:     do {
26208:       AppendItemToList(aTargetList);
26208:     } while (*this != aEnd);
26208:     return;
26208:   }
26208: 
26208:   // move over the list of items
26208:   PR_INSERT_AFTER(&aTargetList.mItems, &mList.mItems);
26208:   PR_REMOVE_LINK(&mList.mItems);
26208: 
26208:   // Copy over the various counters
26208:   aTargetList.mInlineCount = mList.mInlineCount;
34462:   aTargetList.mBlockCount = mList.mBlockCount;
26208:   aTargetList.mLineParticipantCount = mList.mLineParticipantCount;
26208:   aTargetList.mItemCount = mList.mItemCount;
26208:   memcpy(aTargetList.mDesiredParentCounts, mList.mDesiredParentCounts,
26208:          sizeof(aTargetList.mDesiredParentCounts));
26208: 
26208:   // reset mList
26208:   new (&mList) FrameConstructionItemList();
26208: 
26208:   // Point ourselves to aEnd, as advertised
26208:   mCurrent = mEnd = &mList.mItems;
26208:   NS_POSTCONDITION(*this == aEnd, "How did that happen?");
26208: }
26208: 
26208: void
26208: nsCSSFrameConstructor::FrameConstructionItemList::
26208: Iterator::InsertItem(FrameConstructionItem* aItem)
26208: {
26208:   // Just insert the item before us.  There's no magic here.
26208:   PR_INSERT_BEFORE(aItem, mCurrent);
26208:   mList.AdjustCountsForItem(aItem, 1);
26208: 
26208:   NS_POSTCONDITION(PR_NEXT_LINK(aItem) == mCurrent, "How did that happen?");
26208: }
26208: 
26208: void
27311: nsCSSFrameConstructor::FrameConstructionItemList::
27311: Iterator::DeleteItemsTo(const Iterator& aEnd)
27311: {
27311:   NS_PRECONDITION(mEnd == aEnd.mEnd, "end iterator for some other list?");
27311:   NS_PRECONDITION(*this != aEnd, "Shouldn't be at aEnd yet");
27311: 
27311:   do {
27311:     NS_ASSERTION(!IsDone(), "Ran off end of list?");
26208:     FrameConstructionItem* item = ToItem(mCurrent);
26208:     Next();
26208:     PR_REMOVE_LINK(item);
26208:     mList.AdjustCountsForItem(item, -1);
26208:     delete item;
27311:   } while (*this != aEnd);
27311: }
