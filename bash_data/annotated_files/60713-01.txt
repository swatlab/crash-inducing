42791: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
42791: /* ***** BEGIN LICENSE BLOCK *****
39997:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
39997:  *
39997:  * The contents of this file are subject to the Mozilla Public License Version
39997:  * 1.1 (the "License"); you may not use this file except in compliance with
39997:  * the License. You may obtain a copy of the License at
39997:  * http://www.mozilla.org/MPL/
39997:  *
39997:  * Software distributed under the License is distributed on an "AS IS" basis,
39997:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
39997:  * for the specific language governing rights and limitations under the
39997:  * License.
39997:  *
39997:  * The Original Code is Mozilla Corporation code.
39997:  *
39997:  * The Initial Developer of the Original Code is Mozilla Foundation.
39997:  * Portions created by the Initial Developer are Copyright (C) 2009
39997:  * the Initial Developer. All Rights Reserved.
39997:  *
39997:  * Contributor(s):
39997:  *   Bas Schouten <bschouten@mozilla.org>
42791:  *   Vladimir Vukicevic <vladimir@pobox.com>
39997:  *
39997:  * Alternatively, the contents of this file may be used under the terms of
39997:  * either the GNU General Public License Version 2 or later (the "GPL"), or
39997:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
39997:  * in which case the provisions of the GPL or the LGPL are applicable instead
39997:  * of those above. If you wish to allow use of your version of this file only
39997:  * under the terms of either the GPL or the LGPL, and not to allow others to
39997:  * use your version of this file under the terms of the MPL, indicate your
39997:  * decision by deleting the provisions above and replace them with the notice
39997:  * and other provisions required by the GPL or the LGPL. If you do not delete
39997:  * the provisions above, a recipient may use your version of this file under
39997:  * the terms of any one of the MPL, the GPL or the LGPL.
39997:  *
39997:  * ***** END LICENSE BLOCK ***** */
39997: 
55455: #ifdef MOZ_IPC
55455: # include "mozilla/layers/PLayers.h"
55455: # include "mozilla/layers/ShadowLayers.h"
55455: #endif
55455: 
48092: #include "ThebesLayerBuffer.h"
39997: #include "ThebesLayerOGL.h"
39997: 
39997: namespace mozilla {
39997: namespace layers {
39997: 
48093: using gl::GLContext;
48092: using gl::TextureImage;
48092: 
57421: // BindAndDrawQuadWithTextureRect can work with either GL_REPEAT (preferred)
57421: // or GL_CLAMP_TO_EDGE textures.  We select based on whether REPEAT is
57421: // valid for non-power-of-two textures -- if we have NPOT support we use it,
57421: // otherwise we stick with CLAMP_TO_EDGE and decompose.
57421: static already_AddRefed<TextureImage>
57421: CreateClampOrRepeatTextureImage(GLContext *aGl,
57421:                                 const nsIntSize& aSize,
57421:                                 TextureImage::ContentType aContentType)
57421: {
57421:   GLenum wrapMode = LOCAL_GL_CLAMP_TO_EDGE;
57421:   if (aGl->IsExtensionSupported(GLContext::ARB_texture_non_power_of_two) ||
57421:       aGl->IsExtensionSupported(GLContext::OES_texture_npot))
57421:   {
57421:     wrapMode = LOCAL_GL_REPEAT;
57421:   }
57421: 
57421:   return aGl->CreateTextureImage(aSize, aContentType, wrapMode);
57421: }
57421: 
54505: // |aTexCoordRect| is the rectangle from the texture that we want to
54505: // draw using the given program.  The program already has a necessary
54505: // offset and scale, so the geometry that needs to be drawn is a unit
54505: // square from 0,0 to 1,1.
54505: //
54505: // |aTexSize| is the actual size of the texture, as it can be larger
54505: // than the rectangle given by |aTexCoordRect|.
48093: static void
57421: BindAndDrawQuadWithTextureRect(GLContext* aGl,
57421:                                LayerProgram *aProg,
48093:                                const nsIntRect& aTexCoordRect,
54505:                                const nsIntSize& aTexSize,
57421:                                GLenum aWrapMode)
48093: {
48093:   GLuint vertAttribIndex =
48093:     aProg->AttribLocation(LayerProgram::VertexAttrib);
48093:   GLuint texCoordAttribIndex =
48093:     aProg->AttribLocation(LayerProgram::TexCoordAttrib);
48093:   NS_ASSERTION(texCoordAttribIndex != GLuint(-1), "no texture coords?");
48093: 
48093:   // clear any bound VBO so that glVertexAttribPointer() goes back to
48093:   // "pointer mode"
48093:   aGl->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, 0);
48093: 
57420:   // Given what we know about these textures and coordinates, we can
57420:   // compute fmod(t, 1.0f) to get the same texture coordinate out.  If
57420:   // the texCoordRect dimension is < 0 or > width/height, then we have
57420:   // wraparound that we need to deal with by drawing multiple quads,
57420:   // because we can't rely on full non-power-of-two texture support
57420:   // (which is required for the REPEAT wrap mode).
57420: 
57420:   GLContext::RectTriangles rects;
57421: 
57421:   if (aWrapMode == LOCAL_GL_REPEAT) {
57421:     rects.addRect(/* dest rectangle */
57421:                   0.0f, 0.0f, 1.0f, 1.0f,
57421:                   /* tex coords */
57421:                   aTexCoordRect.x / GLfloat(aTexSize.width),
57421:                   aTexCoordRect.y / GLfloat(aTexSize.height),
57421:                   aTexCoordRect.XMost() / GLfloat(aTexSize.width),
57421:                   aTexCoordRect.YMost() / GLfloat(aTexSize.height));
57421:   } else {
57420:     GLContext::DecomposeIntoNoRepeatTriangles(aTexCoordRect, aTexSize, rects);
57421:   }
57420: 
48093:   aGl->fVertexAttribPointer(vertAttribIndex, 2,
48093:                             LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0,
57420:                             rects.vertexCoords);
48093: 
48093:   aGl->fVertexAttribPointer(texCoordAttribIndex, 2,
48093:                             LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0,
57420:                             rects.texCoords);
57420: 
48093:   DEBUG_GL_ERROR_CHECK(aGl);
48093: 
48093:   {
48093:     aGl->fEnableVertexAttribArray(texCoordAttribIndex);
48093:     {
48093:       aGl->fEnableVertexAttribArray(vertAttribIndex);
48093: 
57420:       aGl->fDrawArrays(LOCAL_GL_TRIANGLES, 0, rects.numRects * 6);
48093:       DEBUG_GL_ERROR_CHECK(aGl);
48093: 
48093:       aGl->fDisableVertexAttribArray(vertAttribIndex);
48093:     }
48093:     aGl->fDisableVertexAttribArray(texCoordAttribIndex);
48093:   }
48093: 
48093:   DEBUG_GL_ERROR_CHECK(aGl);
48093: }
48093: 
48093: 
48092: class ThebesLayerBufferOGL
48092: {
48092:   NS_INLINE_DECL_REFCOUNTING(ThebesLayerBufferOGL)
48092: public:
48092:   typedef TextureImage::ContentType ContentType;
48092:   typedef ThebesLayerBuffer::PaintState PaintState;
48092: 
55455:   ThebesLayerBufferOGL(ThebesLayer* aLayer, LayerOGL* aOGLLayer)
48092:     : mLayer(aLayer)
55455:     , mOGLLayer(aOGLLayer)
48092:   {}
48092:   virtual ~ThebesLayerBufferOGL() {}
48092: 
48092:   virtual PaintState BeginPaint(ContentType aContentType) = 0;
48092: 
57097:   void RenderTo(const nsIntPoint& aOffset, LayerManagerOGL* aManager);
48092: 
54505:   nsIntSize GetSize() {
54505:     if (mTexImage)
54505:       return mTexImage->GetSize();
54505:     return nsIntSize(0, 0);
54505:   }
54505: 
48092: protected:
54505:   virtual nsIntPoint GetOriginOffset() = 0;
48093: 
55455:   GLContext* gl() const { return mOGLLayer->gl(); }
48092: 
55455:   ThebesLayer* mLayer;
55455:   LayerOGL* mOGLLayer;
48092:   nsRefPtr<TextureImage> mTexImage;
48092: };
48092: 
48092: void
48092: ThebesLayerBufferOGL::RenderTo(const nsIntPoint& aOffset,
57097:                                LayerManagerOGL* aManager)
48092: {
54505:   if (!mTexImage)
54505:     return;
54505: 
52407:   gl()->fActiveTexture(LOCAL_GL_TEXTURE0);
52407: 
48092:   if (!mTexImage->InUpdate() || !mTexImage->EndUpdate()) {
48092:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexImage->Texture());
48092:   }
48092: 
59439:   // Note BGR: Cairo's image surfaces are always in what
59439:   // OpenGL and our shaders consider BGR format.
59439:   ColorTextureLayerProgram *program =
59439:     aManager->GetColorTextureLayerProgram(mTexImage->GetShaderProgramType());
59439: 
55442:   float xres = mLayer->GetXResolution();
55442:   float yres = mLayer->GetYResolution();
55442: 
48092:   program->Activate();
57097:   program->SetLayerOpacity(mLayer->GetEffectiveOpacity());
57097:   program->SetLayerTransform(mLayer->GetEffectiveTransform());
48092:   program->SetRenderOffset(aOffset);
48092:   program->SetTextureUnit(0);
59837: 
59837:   nsIntRegionRectIterator iter(mLayer->GetEffectiveVisibleRegion());
59837:   while (const nsIntRect *iterRect = iter.Next()) {
59837:     nsIntRect quadRect = *iterRect;
59837:     program->SetLayerQuadRect(quadRect);
48092:     DEBUG_GL_ERROR_CHECK(gl());
48092: 
54505:     quadRect.MoveBy(-GetOriginOffset());
55442: 
55442:     // The buffer rect and rotation are resolution-neutral; with a
55442:     // non-1.0 resolution, only the texture size is scaled by the
55442:     // resolution.  So map the quadrent rect into the space scaled to
55442:     // the texture size and let GL do the rest.
55442:     gfxRect sqr(quadRect.x, quadRect.y, quadRect.width, quadRect.height);
55442:     sqr.Scale(xres, yres);
60235:     sqr.Round();
55442:     nsIntRect scaledQuadRect(sqr.pos.x, sqr.pos.y, sqr.size.width, sqr.size.height);
55442: 
57421:     BindAndDrawQuadWithTextureRect(gl(), program, scaledQuadRect,
57421:                                    mTexImage->GetSize(),
57421:                                    mTexImage->GetWrapMode());
48092:     DEBUG_GL_ERROR_CHECK(gl());
48092:   }
54506: }
48092: 
48092: 
48092: // This implementation is the fast-path for when our TextureImage is
48092: // permanently backed with a server-side ASurface.  We can simply
48092: // reuse the ThebesLayerBuffer logic in its entirety and profit.
48092: class SurfaceBufferOGL : public ThebesLayerBufferOGL, private ThebesLayerBuffer
48092: {
48092: public:
48092:   typedef ThebesLayerBufferOGL::ContentType ContentType;
48092:   typedef ThebesLayerBufferOGL::PaintState PaintState;
48092: 
54505:   SurfaceBufferOGL(ThebesLayerOGL* aLayer)
55455:     : ThebesLayerBufferOGL(aLayer, aLayer)
48092:     , ThebesLayerBuffer(SizedToVisibleBounds)
48092:   {
48092:   }
48092:   virtual ~SurfaceBufferOGL() {}
48092: 
48092:   // ThebesLayerBufferOGL interface
48092:   virtual PaintState BeginPaint(ContentType aContentType)
48092:   {
48092:     // Let ThebesLayerBuffer do all the hard work for us! :D
54083:     return ThebesLayerBuffer::BeginPaint(mLayer, aContentType, 1.0, 1.0);
48092:   }
48092: 
48092:   // ThebesLayerBuffer interface
48092:   virtual already_AddRefed<gfxASurface>
48092:   CreateBuffer(ContentType aType, const nsIntSize& aSize)
48092:   {
48092:     NS_ASSERTION(gfxASurface::CONTENT_ALPHA != aType,"ThebesBuffer has color");
48092: 
57421:     mTexImage = CreateClampOrRepeatTextureImage(gl(), aSize, aType);
48092:     return mTexImage ? mTexImage->GetBackingSurface() : nsnull;
48092:   }
48092: 
48093: protected:
54505:   virtual nsIntPoint GetOriginOffset() {
54505:     return BufferRect().TopLeft() - BufferRotation();
48093:   }
48092: };
48092: 
48092: 
48092: // This implementation is (currently) the slow-path for when we can't
48092: // implement pixel retaining using thebes.  This implementation and
48092: // the above could be unified by abstracting buffer-copy operations
48092: // and implementing them here using GL hacketry.
48092: class BasicBufferOGL : public ThebesLayerBufferOGL
48092: {
48092: public:
54505:   BasicBufferOGL(ThebesLayerOGL* aLayer)
55455:     : ThebesLayerBufferOGL(aLayer, aLayer)
54505:     , mBufferRect(0,0,0,0)
54505:     , mBufferRotation(0,0)
48092:   {}
48092:   virtual ~BasicBufferOGL() {}
48092: 
48092:   virtual PaintState BeginPaint(ContentType aContentType);
48092: 
48093: protected:
54505:   enum XSide {
54505:     LEFT, RIGHT
54505:   };
54505:   enum YSide {
54505:     TOP, BOTTOM
54505:   };
54505:   nsIntRect GetQuadrantRectangle(XSide aXSide, YSide aYSide);
54505: 
54505:   virtual nsIntPoint GetOriginOffset() {
54505:     return mBufferRect.TopLeft() - mBufferRotation;
48093:   }
48093: 
48092: private:
48092:   nsIntRect mBufferRect;
54505:   nsIntPoint mBufferRotation;
48092: };
48092: 
54505: static void
54505: WrapRotationAxis(PRInt32* aRotationPoint, PRInt32 aSize)
54505: {
54505:   if (*aRotationPoint < 0) {
54505:     *aRotationPoint += aSize;
54505:   } else if (*aRotationPoint >= aSize) {
54505:     *aRotationPoint -= aSize;
54505:   }
54505: }
54505: 
54505: nsIntRect
54505: BasicBufferOGL::GetQuadrantRectangle(XSide aXSide, YSide aYSide)
54505: {
54505:   // quadrantTranslation is the amount we translate the top-left
54505:   // of the quadrant by to get coordinates relative to the layer
54505:   nsIntPoint quadrantTranslation = -mBufferRotation;
54505:   quadrantTranslation.x += aXSide == LEFT ? mBufferRect.width : 0;
54505:   quadrantTranslation.y += aYSide == TOP ? mBufferRect.height : 0;
54505:   return mBufferRect + quadrantTranslation;
54505: }
54505: 
48092: BasicBufferOGL::PaintState
48092: BasicBufferOGL::BeginPaint(ContentType aContentType)
48092: {
54505:   PaintState result;
48092: 
54505:   result.mRegionToDraw.Sub(mLayer->GetVisibleRegion(), mLayer->GetValidRegion());
54505: 
54505:   if (!mTexImage || mTexImage->GetContentType() != aContentType) {
54505:     // We're effectively clearing the valid region, so we need to draw
54505:     // the entire visible region now.
54505:     //
54505:     // XXX/cjones: a possibly worthwhile optimization to keep in mind
54505:     // is to re-use buffers when the resolution and visible region
54505:     // have changed in such a way that the buffer size stays the same.
54505:     // It might make even more sense to allocate buffers from a
54505:     // recyclable pool, so that we could keep this logic simple and
54505:     // still get back the same buffer.
54505:     result.mRegionToDraw = mLayer->GetVisibleRegion();
54505:     result.mRegionToInvalidate = mLayer->GetValidRegion();
54505:     mTexImage = nsnull;
54505:     mBufferRect.SetRect(0, 0, 0, 0);
54505:     mBufferRotation.MoveTo(0, 0);
54505:   }
54505: 
54505:   if (result.mRegionToDraw.IsEmpty())
54505:     return result;
54505: 
54505:   nsIntRect drawBounds = result.mRegionToDraw.GetBounds();
54505:   nsIntRect visibleBounds = mLayer->GetVisibleRegion().GetBounds();
54505:   nsRefPtr<TextureImage> destBuffer;
54505:   nsIntRect destBufferRect;
54505: 
54505:   if (visibleBounds.Size() <= mBufferRect.Size()) {
54505:     // The current buffer is big enough to hold the visible area.
54505:     if (mBufferRect.Contains(visibleBounds)) {
54505:       // We don't need to adjust mBufferRect.
54505:       destBufferRect = mBufferRect;
54505:     } else {
54505:       // The buffer's big enough but doesn't contain everything that's
54505:       // going to be visible. We'll move it.
54505:       destBufferRect = nsIntRect(visibleBounds.TopLeft(), mBufferRect.Size());
54505:     }
54505:     nsIntRect keepArea;
54505:     if (keepArea.IntersectRect(destBufferRect, mBufferRect)) {
54505:       // Set mBufferRotation so that the pixels currently in mBuffer
54505:       // will still be rendered in the right place when mBufferRect
54505:       // changes to destBufferRect.
54505:       nsIntPoint newRotation = mBufferRotation +
54505:         (destBufferRect.TopLeft() - mBufferRect.TopLeft());
54505:       WrapRotationAxis(&newRotation.x, mBufferRect.width);
54505:       WrapRotationAxis(&newRotation.y, mBufferRect.height);
54505:       NS_ASSERTION(nsIntRect(nsIntPoint(0,0), mBufferRect.Size()).Contains(newRotation),
54505:                    "newRotation out of bounds");
54505:       PRInt32 xBoundary = destBufferRect.XMost() - newRotation.x;
54505:       PRInt32 yBoundary = destBufferRect.YMost() - newRotation.y;
54505:       if ((drawBounds.x < xBoundary && xBoundary < drawBounds.XMost()) ||
54505:           (drawBounds.y < yBoundary && yBoundary < drawBounds.YMost())) {
54505:         // The stuff we need to redraw will wrap around an edge of the
54505:         // buffer, so we will need to do a self-copy
54505:         // If mBufferRotation == nsIntPoint(0,0) we could do a real
54505:         // self-copy but we're not going to do that in GL yet.
54505:         // We can't do a real self-copy because the buffer is rotated.
54505:         // So allocate a new buffer for the destination.
54505:         destBufferRect = visibleBounds;
57421:         destBuffer = CreateClampOrRepeatTextureImage(gl(), visibleBounds.Size(), aContentType);
48092:         DEBUG_GL_ERROR_CHECK(gl());
54505:         if (!destBuffer)
54505:           return result;
54505:       } else {
54505:         mBufferRect = destBufferRect;
54505:         mBufferRotation = newRotation;
48092:       }
54505:     } else {
54505:       // No pixels are going to be kept. The whole visible region
54505:       // will be redrawn, so we don't need to copy anything, so we don't
54505:       // set destBuffer.
54505:       mBufferRect = destBufferRect;
54505:       mBufferRotation = nsIntPoint(0,0);
48092:     }
48092:   } else {
54505:     // The buffer's not big enough, so allocate a new one
54505:     destBufferRect = visibleBounds;
57421:     destBuffer = CreateClampOrRepeatTextureImage(gl(), visibleBounds.Size(), aContentType);
54505:     DEBUG_GL_ERROR_CHECK(gl());
54505:     if (!destBuffer)
54505:       return result;
48092:   }
48092: 
54505:   if (!destBuffer && !mTexImage) {
54505:     return result;
54505:   }
48092: 
54505:   if (destBuffer) {
54505:     if (mTexImage) {
54888:       // BlitTextureImage depends on the FBO texture target being
54888:       // TEXTURE_2D.  This isn't the case on some older X1600-era Radeons.
55455:       if (mOGLLayer->OGLManager()->FBOTextureTarget() == LOCAL_GL_TEXTURE_2D) {
54505:         nsIntRect overlap;
54505:         overlap.IntersectRect(mBufferRect, destBufferRect);
54505: 
54505:         nsIntRect srcRect(overlap), dstRect(overlap);
54505:         srcRect.MoveBy(- mBufferRect.TopLeft() + mBufferRotation);
54505:         dstRect.MoveBy(- destBufferRect.TopLeft());
54505: 
54505:         destBuffer->Resize(destBufferRect.Size());
54505: 
54505:         gl()->BlitTextureImage(mTexImage, srcRect,
54505:                                destBuffer, dstRect);
54888:       } else {
54888:         // can't blit, just draw everything
54888:         destBufferRect = visibleBounds;
57421:         destBuffer = CreateClampOrRepeatTextureImage(gl(), visibleBounds.Size(), aContentType);
54888:       }
54505:     }
54505: 
54505:     mTexImage = destBuffer.forget();
54505:     mBufferRect = destBufferRect;
54505:     mBufferRotation = nsIntPoint(0,0);
54505:   }
54505: 
54505:   nsIntRegion invalidate;
54505:   invalidate.Sub(mLayer->GetValidRegion(), destBufferRect);
54505:   result.mRegionToInvalidate.Or(result.mRegionToInvalidate, invalidate);
54505: 
54505:   // Figure out which quadrant to draw in
54505:   PRInt32 xBoundary = mBufferRect.XMost() - mBufferRotation.x;
54505:   PRInt32 yBoundary = mBufferRect.YMost() - mBufferRotation.y;
54505:   XSide sideX = drawBounds.XMost() <= xBoundary ? RIGHT : LEFT;
54505:   YSide sideY = drawBounds.YMost() <= yBoundary ? BOTTOM : TOP;
54505:   nsIntRect quadrantRect = GetQuadrantRectangle(sideX, sideY);
54505:   NS_ASSERTION(quadrantRect.Contains(drawBounds), "Messed up quadrants");
54505: 
54505:   nsIntPoint offset = -nsIntPoint(quadrantRect.x, quadrantRect.y);
54505:   
54505:   // Make the region to draw relative to the buffer, before
54505:   // passing to BeginUpdate.
54505:   result.mRegionToDraw.MoveBy(offset);
48092:   // BeginUpdate is allowed to modify the given region,
48092:   // if it wants more to be repainted than we request.
54505:   result.mContext = mTexImage->BeginUpdate(result.mRegionToDraw);
54505:   if (!result.mContext) {
48092:     NS_WARNING("unable to get context for update");
54505:     return result;
48092:   }
60713:   result.mContext->Translate(-gfxPoint(quadrantRect.x, quadrantRect.y));
48092:   // Move rgnToPaint back into position so that the thebes callback
48092:   // gets the right coordintes.
54505:   result.mRegionToDraw.MoveBy(-offset);
48092:   
54505:   return result;
48092: }
46143: 
41370: ThebesLayerOGL::ThebesLayerOGL(LayerManagerOGL *aManager)
46981:   : ThebesLayer(aManager, nsnull)
41370:   , LayerOGL(aManager)
48092:   , mBuffer(nsnull)
39997: {
39997:   mImplData = static_cast<LayerOGL*>(this);
39997: }
39997: 
39997: ThebesLayerOGL::~ThebesLayerOGL()
39997: {
49072:   Destroy();
49072: }
49072: 
49072: void
49072: ThebesLayerOGL::Destroy()
49072: {
49072:   if (!mDestroyed) {
48092:     mBuffer = nsnull;
46981:     DEBUG_GL_ERROR_CHECK(gl());
49072: 
49072:     mDestroyed = PR_TRUE;
49072:   }
39997: }
39997: 
46143: PRBool
48092: ThebesLayerOGL::CreateSurface()
39997: {
48092:   NS_ASSERTION(!mBuffer, "buffer already created?");
48092: 
48092:   if (mVisibleRegion.IsEmpty()) {
48092:     return PR_FALSE;
48092:   }
48092: 
54505:   if (gl()->TextureImageSupportsGetBackingSurface()) {
48092:     // use the ThebesLayerBuffer fast-path
54505:     mBuffer = new SurfaceBufferOGL(this);
48092:   } else {
54505:     mBuffer = new BasicBufferOGL(this);
46981:   }
48092:   return PR_TRUE;
46143: }
46143: 
46143: void
46143: ThebesLayerOGL::SetVisibleRegion(const nsIntRegion &aRegion)
46143: {
46143:   if (aRegion.IsEqual(mVisibleRegion))
46143:     return;
46143:   ThebesLayer::SetVisibleRegion(aRegion);
39997: }
39997: 
39997: void
39997: ThebesLayerOGL::InvalidateRegion(const nsIntRegion &aRegion)
39997: {
46981:   mValidRegion.Sub(mValidRegion, aRegion);
39997: }
39997: 
42593: void
54505: ThebesLayerOGL::RenderLayer(int aPreviousFrameBuffer,
57097:                             const nsIntPoint& aOffset)
42593: {
48092:   if (!mBuffer && !CreateSurface()) {
46143:     return;
48092:   }
48092:   NS_ABORT_IF_FALSE(mBuffer, "should have a buffer here");
46143: 
42791:   mOGLManager->MakeCurrent();
42791:   gl()->fActiveTexture(LOCAL_GL_TEXTURE0);
42791: 
48092:   TextureImage::ContentType contentType =
48362:     CanUseOpaqueSurface() ? gfxASurface::CONTENT_COLOR :
48092:                             gfxASurface::CONTENT_COLOR_ALPHA;
48092:   Buffer::PaintState state = mBuffer->BeginPaint(contentType);
48092:   mValidRegion.Sub(mValidRegion, state.mRegionToInvalidate);
47946: 
48092:   if (state.mContext) {
48092:     state.mRegionToInvalidate.And(state.mRegionToInvalidate, mVisibleRegion);
47946: 
48092:     LayerManager::DrawThebesLayerCallback callback =
48092:       mOGLManager->GetThebesLayerCallback();
48092:     void* callbackData = mOGLManager->GetThebesLayerCallbackData();
48092:     callback(this, state.mContext, state.mRegionToDraw,
48092:              state.mRegionToInvalidate, callbackData);
60673:     // Everything that's visible has been validated. Do this instead of
60673:     // OR-ing with aRegionToDraw, since that can lead to a very complex region
60673:     // here (OR doesn't automatically simplify to the simplest possible
60673:     // representation of a region.)
60673:     mValidRegion.Or(mValidRegion, mVisibleRegion);
46981:   }
47946: 
54505:   DEBUG_GL_ERROR_CHECK(gl());
54505: 
54505:   gl()->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, aPreviousFrameBuffer);
57097:   mBuffer->RenderTo(aOffset, mOGLManager);
42791:   DEBUG_GL_ERROR_CHECK(gl());
39997: }
39997: 
39997: Layer*
39997: ThebesLayerOGL::GetLayer()
39997: {
39997:   return this;
39997: }
39997: 
39997: PRBool
39997: ThebesLayerOGL::IsEmpty()
39997: {
48092:   return !mBuffer;
39997: }
39997: 
55455: 
55455: #ifdef MOZ_IPC
55455: 
55455: class ShadowBufferOGL : public ThebesLayerBufferOGL
55455: {
55455: public:
55455:   ShadowBufferOGL(ShadowThebesLayerOGL* aLayer)
55455:     : ThebesLayerBufferOGL(aLayer, aLayer)
55455:   {}
55455: 
55455:   virtual PaintState BeginPaint(ContentType aContentType) {
55455:     NS_RUNTIMEABORT("can't BeginPaint for a shadow layer");
55455:     return PaintState();
55455:   }
55455: 
55455:   void
55455:   CreateTexture(ContentType aType, const nsIntSize& aSize)
55455:   {
55455:     NS_ASSERTION(gfxASurface::CONTENT_ALPHA != aType,"ThebesBuffer has color");
55455: 
57421:     mTexImage = CreateClampOrRepeatTextureImage(gl(), aSize, aType);
55455:   }
55455: 
55455:   void Upload(gfxASurface* aUpdate, const nsIntRegion& aUpdated,
55455:               const nsIntRect& aRect, const nsIntPoint& aRotation);
55455: 
55455: protected:
55455:   virtual nsIntPoint GetOriginOffset() {
55455:     return mBufferRect.TopLeft() - mBufferRotation;
55455:   }
55455: 
55455: private:
55455:   nsIntRect mBufferRect;
55455:   nsIntPoint mBufferRotation;
55455: };
55455: 
55455: void
55455: ShadowBufferOGL::Upload(gfxASurface* aUpdate, const nsIntRegion& aUpdated,
55455:                         const nsIntRect& aRect, const nsIntPoint& aRotation)
55455: {
59744:   gfxIntSize size = aUpdate->GetSize();
59744:   if (GetSize() != nsIntSize(size.width, size.height)) {
59744:     CreateTexture(aUpdate->GetContentType(),
59744:                   nsIntSize(size.width, size.height));
59744:   }
59744: 
55455:   nsIntRegion destRegion(aUpdated);
55455:   // aUpdated is in screen coordinates.  Move it so that the layer's
55455:   // top-left is 0,0
55455:   nsIntPoint visTopLeft = mLayer->GetVisibleRegion().GetBounds().TopLeft();
55455:   destRegion.MoveBy(-visTopLeft);
59030: 
59030:   // |aUpdated|, |aRect|, and |aRotation| are in thebes-layer space,
59030:   // unadjusted for resolution.  The texture is in device space, so
59030:   // first we need to map the update params to device space.
59030:   //
59030:   // XXX this prematurely commits us to updating rects instead of
59030:   // regions here.  This will be a perf penalty on platforms that
59030:   // support region updates.  This is OK for now because the
59030:   // TextureImage backends we care about need to update contiguous
59030:   // rects anyway, and would do this conversion internally.  To fix
59030:   // this, we would need to scale the region instead of its bounds
59030:   // here.
59030:   nsIntRect destBounds = destRegion.GetBounds();
59030:   gfxRect destRect(destBounds.x, destBounds.y, destBounds.width, destBounds.height);
59030:   destRect.Scale(mLayer->GetXResolution(), mLayer->GetYResolution());
59030:   destRect.RoundOut();
59030: 
55455:   // NB: this gfxContext must not escape EndUpdate() below
59030:   nsIntRegion scaledDestRegion(nsIntRect(destRect.pos.x, destRect.pos.y,
59030:                                          destRect.size.width, destRect.size.height));
59443:   mTexImage->DirectUpdate(aUpdate, scaledDestRegion);
55455: 
55455:   mBufferRect = aRect;
55455:   mBufferRotation = aRotation;
55455: }
55455: 
55455: ShadowThebesLayerOGL::ShadowThebesLayerOGL(LayerManagerOGL *aManager)
55455:   : ShadowThebesLayer(aManager, nsnull)
55455:   , LayerOGL(aManager)
55455: {
55455:   mImplData = static_cast<LayerOGL*>(this);
55455: }
55455: 
55455: ShadowThebesLayerOGL::~ShadowThebesLayerOGL()
55455: {}
55455: 
55455: void
59744: ShadowThebesLayerOGL::SetFrontBuffer(const OptionalThebesBuffer& aNewFront,
55455:                                      const nsIntRegion& aValidRegion,
55455:                                      float aXResolution, float aYResolution)
55455: {
55455:   if (mDestroyed) {
55455:     return;
55455:   }
55455: 
55455:   if (!mBuffer) {
55455:     mBuffer = new ShadowBufferOGL(this);
55455:   }
55455: 
59744:   NS_ASSERTION(OptionalThebesBuffer::Tnull_t == aNewFront.type(),
59744:                "Only one system-memory buffer expected");
55455: }
55455: 
55455: void
55455: ShadowThebesLayerOGL::Swap(const ThebesBuffer& aNewFront,
55455:                            const nsIntRegion& aUpdatedRegion,
55455:                            ThebesBuffer* aNewBack,
55455:                            nsIntRegion* aNewBackValidRegion,
56899:                            float* aNewXResolution, float* aNewYResolution,
56899:                            OptionalThebesBuffer* aReadOnlyFront,
56899:                            nsIntRegion* aFrontUpdatedRegion)
55455: {
55455:   if (!mDestroyed && mBuffer) {
55455:     nsRefPtr<gfxASurface> surf = ShadowLayerForwarder::OpenDescriptor(aNewFront.buffer());
55455:     mBuffer->Upload(surf, aUpdatedRegion, aNewFront.rect(), aNewFront.rotation());
55455:   }
55455: 
55455:   *aNewBack = aNewFront;
55455:   *aNewBackValidRegion = mValidRegion;
57319:   *aNewXResolution = mXResolution;
57319:   *aNewYResolution = mYResolution;
56899:   *aReadOnlyFront = null_t();
56899:   aFrontUpdatedRegion->SetEmpty();
55455: }
55455: 
55455: void
55455: ShadowThebesLayerOGL::DestroyFrontBuffer()
55455: {
55455:   mBuffer = nsnull;
55455: }
55455: 
55455: void
60065: ShadowThebesLayerOGL::Disconnect()
60065: {
60065:   Destroy();
60065: }
60065: 
60065: void
55455: ShadowThebesLayerOGL::Destroy()
55455: {
55455:   if (!mDestroyed) {
55455:     mDestroyed = PR_TRUE;
55455:     mBuffer = nsnull;
55455:   }
55455: }
55455: 
55455: Layer*
55455: ShadowThebesLayerOGL::GetLayer()
55455: {
55455:   return this;
55455: }
55455: 
55455: PRBool
55455: ShadowThebesLayerOGL::IsEmpty()
55455: {
55455:   return !mBuffer;
55455: }
55455: 
55455: void
55455: ShadowThebesLayerOGL::RenderLayer(int aPreviousFrameBuffer,
57097:                                   const nsIntPoint& aOffset)
55455: {
55455:   if (!mBuffer) {
55455:     return;
55455:   }
55455:   NS_ABORT_IF_FALSE(mBuffer, "should have a buffer here");
55455: 
55455:   mOGLManager->MakeCurrent();
55455:   gl()->fActiveTexture(LOCAL_GL_TEXTURE0);
55455:   DEBUG_GL_ERROR_CHECK(gl());
55455: 
55455:   gl()->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, aPreviousFrameBuffer);
57097:   mBuffer->RenderTo(aOffset, mOGLManager);
55455:   DEBUG_GL_ERROR_CHECK(gl());
55455: }
55455: 
55455: #endif  // MOZ_IPC
55455: 
55455: 
39997: } /* layers */
39997: } /* mozilla */
