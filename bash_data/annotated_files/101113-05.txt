     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
     1:  * vim: set ts=2 sw=2 et tw=78:
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
     1:  *
     1:  * This Original Code has been modified by IBM Corporation.
     1:  * Modifications made by IBM described herein are
     1:  * Copyright (c) International Business Machines
     1:  * Corporation, 2000
     1:  *
     1:  * Modifications to Mozilla code or documentation
     1:  * identified per MPL Section 3.3
     1:  *
     1:  * Date         Modified by     Description of modification
     1:  * 05/03/2000   IBM Corp.       Observer events for reflow states
     1:  */
     1: 
     1: /* a presentation of a document, part 2 */
     1: 
 78155: #ifndef nsPresShell_h_
 78155: #define nsPresShell_h_
 78155: 
     1: #include "nsIPresShell.h"
     1: #include "nsStubDocumentObserver.h"
 78155: #include "nsISelectionController.h"
 78155: #include "nsIObserver.h"
 78155: #include "nsWeakReference.h"
 78155: #include "nsCRT.h"
 78155: #include "nsAutoPtr.h"
 78155: #include "nsIWidget.h"
     1: #include "nsStyleSet.h"
 78155: #include "nsPresArena.h"
 78155: #include "nsFrameSelection.h"
     1: #include "nsGUIEvent.h"
     1: #include "nsContentUtils.h"
 78227: #include "nsRefreshDriver.h"
 78155: 
 86939: class nsRange;
 78155: class nsIDragService;
 78155: class nsCSSStyleSheet;
 78155: 
 78155: struct RangePaintInfo;
 78155: struct nsCallbackEventRequest;
 27962: #ifdef MOZ_REFLOW_PERF
 78155: class ReflowCountMgr;
     1: #endif
     1: 
     1: class nsPresShellEventCB;
 29804: class nsAutoCauseReflowNotifier;
     1: 
 98653: // 250ms.  This is actually pref-controlled, but we use this value if we fail
 98653: // to get the pref for any reason.
 98653: #define PAINTLOCK_EVENT_DELAY 250
 98653: 
 82568: class PresShell : public nsIPresShell,
     1:                   public nsStubDocumentObserver,
     1:                   public nsISelectionController, public nsIObserver,
 64531:                   public nsSupportsWeakReference
     1: {
     1: public:
     1:   PresShell();
     1: 
     1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
     1: 
     1:   // nsISupports
     1:   NS_DECL_ISUPPORTS
     1: 
     1:   // nsIPresShell
 39668:   virtual NS_HIDDEN_(nsresult) Init(nsIDocument* aDocument,
     1:                                    nsPresContext* aPresContext,
     1:                                    nsIViewManager* aViewManager,
     1:                                    nsStyleSet* aStyleSet,
     1:                                    nsCompatibility aCompatMode);
 39668:   virtual NS_HIDDEN_(void) Destroy();
     1: 
 79445:   virtual NS_HIDDEN_(nsresult) SetPreferenceStyleRules(bool aForceReflow);
     1: 
     1:   NS_IMETHOD GetSelection(SelectionType aType, nsISelection** aSelection);
     1:   virtual nsISelection* GetCurrentSelection(SelectionType aType);
     1: 
     1:   NS_IMETHOD SetDisplaySelection(PRInt16 aToggle);
     1:   NS_IMETHOD GetDisplaySelection(PRInt16 *aToggle);
 56442:   NS_IMETHOD ScrollSelectionIntoView(SelectionType aType, SelectionRegion aRegion,
 56442:                                      PRInt16 aFlags);
     1:   NS_IMETHOD RepaintSelection(SelectionType aType);
     1: 
 39668:   virtual NS_HIDDEN_(void) BeginObservingDocument();
 39668:   virtual NS_HIDDEN_(void) EndObservingDocument();
 39668:   virtual NS_HIDDEN_(nsresult) InitialReflow(nscoord aWidth, nscoord aHeight);
 39668:   virtual NS_HIDDEN_(nsresult) ResizeReflow(nscoord aWidth, nscoord aHeight);
 54649:   virtual NS_HIDDEN_(nsresult) ResizeReflowOverride(nscoord aWidth, nscoord aHeight);
 39668:   virtual NS_HIDDEN_(void) StyleChangeReflow();
 39668:   virtual NS_HIDDEN_(nsIPageSequenceFrame*) GetPageSequenceFrame() const;
 10998:   virtual NS_HIDDEN_(nsIFrame*) GetRealPrimaryFrameFor(nsIContent* aContent) const;
     1: 
 39668:   virtual NS_HIDDEN_(nsIFrame*) GetPlaceholderFrameFor(nsIFrame* aFrame) const;
 39668:   virtual NS_HIDDEN_(void) FrameNeedsReflow(nsIFrame *aFrame, IntrinsicDirty aIntrinsicDirty,
  1161:                                             nsFrameState aBitToAdd);
 39668:   virtual NS_HIDDEN_(void) FrameNeedsToContinueReflow(nsIFrame *aFrame);
 39668:   virtual NS_HIDDEN_(void) CancelAllPendingReflows();
 79445:   virtual NS_HIDDEN_(bool) IsSafeToFlush() const;
 39668:   virtual NS_HIDDEN_(void) FlushPendingNotifications(mozFlushType aType);
     1: 
     1:   /**
     1:    * Recreates the frames for a node
     1:    */
 40046:   virtual NS_HIDDEN_(nsresult) RecreateFramesFor(nsIContent* aContent);
     1: 
     1:   /**
     1:    * Post a callback that should be handled after reflow has finished.
     1:    */
 40046:   virtual NS_HIDDEN_(nsresult) PostReflowCallback(nsIReflowCallback* aCallback);
 40046:   virtual NS_HIDDEN_(void) CancelReflowCallback(nsIReflowCallback* aCallback);
 40046: 
 40046:   virtual NS_HIDDEN_(void) ClearFrameRefs(nsIFrame* aFrame);
 68481:   virtual NS_HIDDEN_(already_AddRefed<nsRenderingContext>) GetReferenceRenderingContext();
 79445:   virtual NS_HIDDEN_(nsresult) GoToAnchor(const nsAString& aAnchorName, bool aScroll);
 40046:   virtual NS_HIDDEN_(nsresult) ScrollToAnchor();
 40046: 
 40046:   virtual NS_HIDDEN_(nsresult) ScrollContentIntoView(nsIContent* aContent,
 93554:                                                      ScrollAxis  aVertical,
 93554:                                                      ScrollAxis  aHorizontal,
 56647:                                                      PRUint32    aFlags);
 79445:   virtual bool ScrollFrameRectIntoView(nsIFrame*     aFrame,
 37077:                                        const nsRect& aRect,
 93554:                                        ScrollAxis    aVertical,
 93554:                                        ScrollAxis    aHorizontal,
 37077:                                        PRUint32      aFlags);
 37073:   virtual nsRectVisibility GetRectVisibility(nsIFrame *aFrame,
 37073:                                              const nsRect &aRect,
 40053:                                              nscoord aMinTwips) const;
     1: 
 79445:   virtual NS_HIDDEN_(void) SetIgnoreFrameDestruction(bool aIgnore);
 40046:   virtual NS_HIDDEN_(void) NotifyDestroyingFrame(nsIFrame* aFrame);
 40046: 
 79445:   virtual NS_HIDDEN_(nsresult) CaptureHistoryState(nsILayoutHistoryState** aLayoutHistoryState, bool aLeavingPage);
 40020: 
 40049:   virtual NS_HIDDEN_(void) UnsuppressPainting();
 40020: 
     1:   virtual nsresult GetAgentStyleSheets(nsCOMArray<nsIStyleSheet>& aSheets);
     1:   virtual nsresult SetAgentStyleSheets(const nsCOMArray<nsIStyleSheet>& aSheets);
     1: 
     1:   virtual nsresult AddOverrideStyleSheet(nsIStyleSheet *aSheet);
     1:   virtual nsresult RemoveOverrideStyleSheet(nsIStyleSheet *aSheet);
     1: 
 40055:   virtual NS_HIDDEN_(nsresult) HandleEventWithTarget(nsEvent* aEvent, nsIFrame* aFrame,
     1:                                                      nsIContent* aContent,
     1:                                                      nsEventStatus* aStatus);
 40047:   virtual NS_HIDDEN_(nsIFrame*) GetEventTargetFrame();
 40047:   virtual NS_HIDDEN_(already_AddRefed<nsIContent>) GetEventTargetContent(nsEvent* aEvent);
 40020: 
     1: 
     1:   virtual nsresult ReconstructFrames(void);
     1:   virtual void Freeze();
     1:   virtual void Thaw();
 79445:   virtual void FireOrClearDelayedEvents(bool aFireEvents);
     1: 
  5680:   virtual nsIFrame* GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt);
  5680: 
 40052:   virtual NS_HIDDEN_(nsresult) RenderDocument(const nsRect& aRect, PRUint32 aFlags,
     1:                                               nscolor aBackgroundColor,
  1735:                                               gfxContext* aThebesContext);
     1: 
     1:   virtual already_AddRefed<gfxASurface> RenderNode(nsIDOMNode* aNode,
 43137:                                                    nsIntRegion* aRegion,
 23738:                                                    nsIntPoint& aPoint,
 23738:                                                    nsIntRect* aScreenRect);
     1: 
     1:   virtual already_AddRefed<gfxASurface> RenderSelection(nsISelection* aSelection,
 23738:                                                         nsIntPoint& aPoint,
 23738:                                                         nsIntRect* aScreenRect);
     1: 
 47198:   virtual already_AddRefed<nsPIDOMWindow> GetRootWindow();
 47198: 
 48947:   virtual LayerManager* GetLayerManager();
 48947: 
 79445:   virtual void SetIgnoreViewportScrolling(bool aIgnore);
 54080: 
 54080:   virtual void SetDisplayPort(const nsRect& aDisplayPort);
 54080: 
 54081:   virtual nsresult SetResolution(float aXResolution, float aYResolution);
 54081: 
     1:   //nsIViewObserver interface
     1: 
 82568:   virtual void Paint(nsIView* aViewToPaint, nsIWidget* aWidget,
 82568:                      const nsRegion& aDirtyRegion, const nsIntRegion& aIntDirtyRegion,
 88468:                      bool aWillSendDidPaint);
 82568:   virtual nsresult HandleEvent(nsIFrame*       aFrame,
     1:                                nsGUIEvent*     aEvent,
 79445:                                bool            aDontRetargetEvents,
     1:                                nsEventStatus*  aEventStatus);
 40055:   virtual NS_HIDDEN_(nsresult) HandleDOMEventWithTarget(nsIContent* aTargetContent,
     1:                                                         nsEvent* aEvent,
     1:                                                         nsEventStatus* aStatus);
 40055:   virtual NS_HIDDEN_(nsresult) HandleDOMEventWithTarget(nsIContent* aTargetContent,
 29844:                                                         nsIDOMEvent* aEvent,
 29844:                                                         nsEventStatus* aStatus);
 82568:   virtual bool ShouldIgnoreInvalidation();
 82568:   virtual void WillPaint(bool aWillSendDidPaint);
 82568:   virtual void DidPaint();
 87344:   virtual void ScheduleViewManagerFlush();
 82568:   virtual void DispatchSynthMouseMove(nsGUIEvent *aEvent, bool aFlushOnHoverChange);
 82568:   virtual void ClearMouseCaptureOnView(nsIView* aView);
 82568:   virtual bool IsVisible();
     1: 
     1:   // caret handling
 40053:   virtual NS_HIDDEN_(already_AddRefed<nsCaret>) GetCaret() const;
 40045:   virtual NS_HIDDEN_(void) MaybeInvalidateCaretPosition();
 79445:   NS_IMETHOD SetCaretEnabled(bool aInEnable);
 79445:   NS_IMETHOD SetCaretReadOnly(bool aReadOnly);
 79445:   NS_IMETHOD GetCaretEnabled(bool *aOutEnabled);
 79445:   NS_IMETHOD SetCaretVisibilityDuringSelection(bool aVisibility);
 79445:   NS_IMETHOD GetCaretVisible(bool *_retval);
 15969:   virtual void SetCaret(nsCaret *aNewCaret);
  6232:   virtual void RestoreCaret();
     1: 
     1:   NS_IMETHOD SetSelectionFlags(PRInt16 aInEnable);
     1:   NS_IMETHOD GetSelectionFlags(PRInt16 *aOutEnable);
     1: 
     1:   // nsISelectionController
     1: 
 79445:   NS_IMETHOD CharacterMove(bool aForward, bool aExtend);
 20532:   NS_IMETHOD CharacterExtendForDelete();
 43298:   NS_IMETHOD CharacterExtendForBackspace();
 79445:   NS_IMETHOD WordMove(bool aForward, bool aExtend);
 79445:   NS_IMETHOD WordExtendForDelete(bool aForward);
 79445:   NS_IMETHOD LineMove(bool aForward, bool aExtend);
 79445:   NS_IMETHOD IntraLineMove(bool aForward, bool aExtend);
 79445:   NS_IMETHOD PageMove(bool aForward, bool aExtend);
 79445:   NS_IMETHOD ScrollPage(bool aForward);
 79445:   NS_IMETHOD ScrollLine(bool aForward);
 86684:   NS_IMETHOD ScrollCharacter(bool aRight);
 79445:   NS_IMETHOD CompleteScroll(bool aForward);
 79445:   NS_IMETHOD CompleteMove(bool aForward, bool aExtend);
     1:   NS_IMETHOD SelectAll();
 79445:   NS_IMETHOD CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, bool *_retval);
 88028:   virtual nsresult CheckVisibilityContent(nsIContent* aNode, PRInt16 aStartOffset,
 88028:                                           PRInt16 aEndOffset, bool* aRetval);
     1: 
     1:   // nsIDocumentObserver
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_BEGINUPDATE
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_ENDUPDATE
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_BEGINLOAD
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_ENDLOAD
 64120:   NS_DECL_NSIDOCUMENTOBSERVER_CONTENTSTATECHANGED
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_DOCUMENTSTATESCHANGED
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETADDED
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETREMOVED
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETAPPLICABLESTATECHANGED
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLERULECHANGED
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLERULEADDED
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLERULEREMOVED
     1: 
  3410:   // nsIMutationObserver
  3410:   NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
 35534:   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTEWILLCHANGE
  3410:   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
  3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
  3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
  3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
  3410: 
     1:   NS_DECL_NSIOBSERVER
     1: 
     1: #ifdef MOZ_REFLOW_PERF
 40052:   virtual NS_HIDDEN_(void) DumpReflows();
 40052:   virtual NS_HIDDEN_(void) CountReflows(const char * aName, nsIFrame * aFrame);
 40052:   virtual NS_HIDDEN_(void) PaintCount(const char * aName,
 68481:                                       nsRenderingContext* aRenderingContext,
 40052:                                       nsPresContext* aPresContext,
 40052:                                       nsIFrame * aFrame,
 68487:                                       const nsPoint& aOffset,
 40052:                                       PRUint32 aColor);
 79445:   virtual NS_HIDDEN_(void) SetPaintFrameCount(bool aOn);
 79445:   virtual bool IsPaintingFrameCounts();
     1: #endif
     1: 
     1: #ifdef DEBUG
     1:   virtual void ListStyleContexts(nsIFrame *aRootFrame, FILE *out,
     1:                                  PRInt32 aIndent = 0);
     1: 
     1:   virtual void ListStyleSheets(FILE *out, PRInt32 aIndent = 0);
     1:   virtual void VerifyStyleTree();
     1: #endif
     1: 
     1: #ifdef PR_LOGGING
     1:   static PRLogModuleInfo* gLog;
     1: #endif
     1: 
 79445:   virtual NS_HIDDEN_(void) DisableNonTestMouseEvents(bool aDisable);
 24947: 
 27834:   virtual void UpdateCanvasBackground();
 27834: 
 64531:   virtual nsresult AddCanvasBackgroundColorItem(nsDisplayListBuilder& aBuilder,
 61411:                                                 nsDisplayList& aList,
 61411:                                                 nsIFrame* aFrame,
 61411:                                                 const nsRect& aBounds,
 61411:                                                 nscolor aBackstopColor,
 61411:                                                 PRUint32 aFlags);
 61411: 
 49166:   virtual nsresult AddPrintPreviewBackgroundItem(nsDisplayListBuilder& aBuilder,
 49166:                                                  nsDisplayList& aList,
 49166:                                                  nsIFrame* aFrame,
 49166:                                                  const nsRect& aBounds);
 49166: 
 49168:   virtual nscolor ComputeBackstopColor(nsIView* aDisplayRoot);
 49168: 
 79445:   virtual NS_HIDDEN_(nsresult) SetIsActive(bool aIsActive);
 50815: 
 79445:   virtual bool GetIsViewportOverridden() { return mViewportOverridden; }
 59572: 
 79445:   virtual bool IsLayoutFlushObserver()
 60746:   {
 60746:     return GetPresContext()->RefreshDriver()->
 60746:       IsLayoutFlushObserver(this);
 60746:   }
 60746: 
 98653:   void SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
 98653:                            size_t *aArenasSize,
 98653:                            size_t *aStyleSetsSize,
 98653:                            size_t *aTextRunsSize,
 98653:                            size_t *aPresContextSize) const;
 98653:   size_t SizeOfTextRuns(nsMallocSizeOfFun aMallocSizeOf) const;
 98653: 
 98654:   // This data is stored as a content property (nsGkAtoms::scrolling) on
 98654:   // mContentToScrollTo when we have a pending ScrollIntoView.
 98654:   struct ScrollIntoViewData {
 98654:     ScrollAxis mContentScrollVAxis;
 98654:     ScrollAxis mContentScrollHAxis;
 98654:     PRUint32   mContentToScrollToFlags;
 98654:   };
 98654: 
     1: protected:
     1:   virtual ~PresShell();
     1: 
 79445:   void HandlePostedReflowCallbacks(bool aInterruptible);
  8509:   void CancelPostedReflowCallbacks();
     1: 
     1:   void UnsuppressAndInvalidate();
     1: 
 29804:   void WillCauseReflow() {
 29804:     nsContentUtils::AddScriptBlocker();
 29804:     ++mChangeNestCount;
 29804:   }
 29804:   nsresult DidCauseReflow();
 29804:   friend class nsAutoCauseReflowNotifier;
 29804: 
 87650:   bool TouchesAreEqual(nsIDOMTouch *aTouch1, nsIDOMTouch *aTouch2);
 87650:   void DispatchTouchEvent(nsEvent *aEvent,
 87650:                           nsEventStatus* aStatus,
 87650:                           nsPresShellEventCB* aEventCB,
 87650:                           bool aTouchIsNew);
 87650: 
     1:   void     WillDoReflow();
 79445:   void     DidDoReflow(bool aInterruptible);
 27993:   // ProcessReflowCommands returns whether we processed all our dirty roots
 27993:   // without interruptions.
 79445:   bool     ProcessReflowCommands(bool aInterruptible);
 38310:   // MaybeScheduleReflow checks if posting a reflow is needed, then checks if
 38310:   // the last reflow was interrupted. In the interrupted case ScheduleReflow is
 29172:   // called off a timer, otherwise it is called directly.
 38310:   void     MaybeScheduleReflow();
 38310:   // Actually schedules a reflow.  This should only be called by
 38310:   // MaybeScheduleReflow and the reflow timer ScheduleReflowOffTimer
 38310:   // sets up.
 38310:   void     ScheduleReflow();
     1: 
 54649:   // Reflow regardless of whether the override bit has been set.
 54649:   nsresult ResizeReflowIgnoreOverride(nscoord aWidth, nscoord aHeight);
 54649: 
 27993:   // DoReflow returns whether the reflow finished without interruption
 79445:   bool DoReflow(nsIFrame* aFrame, bool aInterruptible);
   790: #ifdef DEBUG
   790:   void DoVerifyReflow();
   926:   void VerifyHasDirtyRootAncestor(nsIFrame* aFrame);
   790: #endif
   790: 
 27993:   // Helper for ScrollContentIntoView
 98654:   void DoScrollContentIntoView();
 27993: 
101113:   /**
101113:    * Initialize cached font inflation preference values.
101113:    *
101113:    * @see nsLayoutUtils::sFontSizeInflationEmPerLine
101113:    * @see nsLayoutUtils::sFontSizeInflationMinTwips
101113:    * @see nsLayoutUtils::sFontSizeInflationLineThreshold
101113:    */
101113:   void SetupFontInflation();
101113: 
 54080:   friend struct AutoRenderingStateSaveRestore;
 54080:   friend struct RenderingState;
 54080: 
 54080:   struct RenderingState {
 54080:     RenderingState(PresShell* aPresShell) 
 98653:       : mXResolution(aPresShell->mXResolution)
 54081:       , mYResolution(aPresShell->mYResolution)
 98653:       , mRenderFlags(aPresShell->mRenderFlags)
 54080:     { }
 54081:     float mXResolution;
 54081:     float mYResolution;
 98653:     RenderFlags mRenderFlags;
 54080:   };
 54080: 
 54080:   struct AutoSaveRestoreRenderingState {
 54080:     AutoSaveRestoreRenderingState(PresShell* aPresShell)
 54080:       : mPresShell(aPresShell)
 54080:       , mOldState(aPresShell)
 54080:     {}
 54080: 
 54080:     ~AutoSaveRestoreRenderingState()
 54080:     {
 54080:       mPresShell->mRenderFlags = mOldState.mRenderFlags;
 54081:       mPresShell->mXResolution = mOldState.mXResolution;
 54081:       mPresShell->mYResolution = mOldState.mYResolution;
 54080:     }
 54080: 
 54080:     PresShell* mPresShell;
 54080:     RenderingState mOldState;
 54080:   };
 98653:   static RenderFlags ChangeFlag(RenderFlags aFlags, bool aOnOff,
 98653:                                 eRenderFlag aFlag)
 98653:   {
 98653:     return aOnOff ? (aFlags | aFlag) : (aFlag & ~aFlag);
 98653:   }
 98653: 
 54080: 
 54080:   void SetRenderingState(const RenderingState& aState);
 54080: 
     1:   friend class nsPresShellEventCB;
     1: 
 79445:   bool mCaretEnabled;
     1: #ifdef NS_DEBUG
 72504:   nsStyleSet* CloneStyleSet(nsStyleSet* aSet);
 79445:   bool VerifyIncrementalReflow();
 79445:   bool mInVerifyReflow;
     1:   void ShowEventTargetDebug();
     1: #endif
     1: 
     1:     /**
     1:     * methods that manage rules that are used to implement the associated preferences
     1:     *  - initially created for bugs 31816, 20760, 22963
     1:     */
     1:   nsresult ClearPreferenceStyleRules(void);
     1:   nsresult CreatePreferenceStyleSheet(void);
     1:   nsresult SetPrefLinkRules(void);
     1:   nsresult SetPrefFocusRules(void);
     1:   nsresult SetPrefNoScriptRule();
     1:   nsresult SetPrefNoFramesRule(void);
     1: 
     1:   // methods for painting a range to an offscreen buffer
     1: 
     1:   // given a display list, clip the items within the list to
     1:   // the range
     1:   nsRect ClipListToRange(nsDisplayListBuilder *aBuilder,
     1:                          nsDisplayList* aList,
 86939:                          nsRange* aRange);
     1: 
     1:   // create a RangePaintInfo for the range aRange containing the
     1:   // display list needed to paint the range to a surface
     1:   RangePaintInfo* CreateRangePaintInfo(nsIDOMRange* aRange,
 47337:                                        nsRect& aSurfaceRect,
 79445:                                        bool aForPrimarySelection);
     1: 
     1:   /*
     1:    * Paint the items to a new surface and return it.
     1:    *
     1:    * aSelection - selection being painted, if any
     1:    * aRegion - clip region, if any
     1:    * aArea - area that the surface occupies, relative to the root frame
     1:    * aPoint - reference point, typically the mouse position
     1:    * aScreenRect - [out] set to the area of the screen the painted area should
     1:    *               be displayed at
     1:    */
     1:   already_AddRefed<gfxASurface>
     1:   PaintRangePaintInfo(nsTArray<nsAutoPtr<RangePaintInfo> >* aItems,
     1:                       nsISelection* aSelection,
 43137:                       nsIntRegion* aRegion,
     1:                       nsRect aArea,
 23738:                       nsIntPoint& aPoint,
 23738:                       nsIntRect* aScreenRect);
     1: 
     1:   /**
     1:    * Methods to handle changes to user and UA sheet lists that we get
     1:    * notified about.
     1:    */
     1:   void AddUserSheet(nsISupports* aSheet);
     1:   void AddAgentSheet(nsISupports* aSheet);
     1:   void RemoveSheet(nsStyleSet::sheetType aType, nsISupports* aSheet);
     1: 
   677:   // Hide a view if it is a popup
   677:   void HideViewIfPopup(nsIView* aView);
   677: 
   824:   // Utility method to restore the root scrollframe state
   824:   void RestoreRootScrollPosition();
   824: 
 35522:   void MaybeReleaseCapturingContent()
 35522:   {
 70097:     nsRefPtr<nsFrameSelection> frameSelection = FrameSelection();
 35522:     if (frameSelection) {
 80486:       frameSelection->SetMouseDownState(false);
 35522:     }
 35522:     if (gCaptureInfo.mContent &&
 80526:         gCaptureInfo.mContent->OwnerDoc() == mDocument) {
 35522:       SetCapturingContent(nsnull, 0);
 35522:     }
 35522:   }
 35522: 
 82566:   nsresult HandleRetargetedEvent(nsEvent* aEvent, nsEventStatus* aStatus, nsIContent* aTarget)
 62899:   {
 62899:     PushCurrentEventInfo(nsnull, nsnull);
 62899:     mCurrentEventContent = aTarget;
 62899:     nsresult rv = NS_OK;
 62899:     if (GetCurrentEventFrame()) {
 82566:       rv = HandleEventInternal(aEvent, aStatus);
 62899:     }
 62899:     PopCurrentEventInfo();
 62899:     return rv;
 62899:   }
 62899: 
 28498:   class nsDelayedEvent
 28498:   {
 28498:   public:
 28498:     virtual ~nsDelayedEvent() {};
 28498:     virtual void Dispatch(PresShell* aShell) {}
 28498:   };
 28498: 
 28498:   class nsDelayedInputEvent : public nsDelayedEvent
 28498:   {
 28498:   public:
 28498:     virtual void Dispatch(PresShell* aShell)
 28498:     {
 28498:       if (mEvent && mEvent->widget) {
 28498:         nsCOMPtr<nsIWidget> w = mEvent->widget;
 28498:         nsEventStatus status;
 28498:         w->DispatchEvent(mEvent, status);
 28498:       }
 28498:     }
 28498: 
 28498:   protected:
 28498:     void Init(nsInputEvent* aEvent)
 28498:     {
 28498:       mEvent->time = aEvent->time;
 28498:       mEvent->refPoint = aEvent->refPoint;
 96893:       mEvent->modifiers = aEvent->modifiers;
 28498:     }
 28498: 
 28498:     nsDelayedInputEvent()
 28498:     : nsDelayedEvent(), mEvent(nsnull) {}
 28498: 
 28498:     nsInputEvent* mEvent;
 28498:   };
 28498: 
 28498:   class nsDelayedMouseEvent : public nsDelayedInputEvent
 28498:   {
 28498:   public:
 28498:     nsDelayedMouseEvent(nsMouseEvent* aEvent) : nsDelayedInputEvent()
 28498:     {
 28498:       mEvent = new nsMouseEvent(NS_IS_TRUSTED_EVENT(aEvent),
 28498:                                 aEvent->message,
 28498:                                 aEvent->widget,
 28498:                                 aEvent->reason,
 28498:                                 aEvent->context);
 28498:       Init(aEvent);
 28498:       static_cast<nsMouseEvent*>(mEvent)->clickCount = aEvent->clickCount;
 28498:     }
 28498: 
 28498:     virtual ~nsDelayedMouseEvent()
 28498:     {
 28498:       delete static_cast<nsMouseEvent*>(mEvent);
 28498:     }
 28498:   };
 28498: 
 28498:   class nsDelayedKeyEvent : public nsDelayedInputEvent
 28498:   {
 28498:   public:
 28498:     nsDelayedKeyEvent(nsKeyEvent* aEvent) : nsDelayedInputEvent()
 28498:     {
 28498:       mEvent = new nsKeyEvent(NS_IS_TRUSTED_EVENT(aEvent),
 28498:                               aEvent->message,
 28498:                               aEvent->widget);
 28498:       Init(aEvent);
 28498:       static_cast<nsKeyEvent*>(mEvent)->keyCode = aEvent->keyCode;
 28498:       static_cast<nsKeyEvent*>(mEvent)->charCode = aEvent->charCode;
 28498:       static_cast<nsKeyEvent*>(mEvent)->alternativeCharCodes =
 28498:         aEvent->alternativeCharCodes;
 28498:       static_cast<nsKeyEvent*>(mEvent)->isChar = aEvent->isChar;
 28498:     }
 28498: 
 28498:     virtual ~nsDelayedKeyEvent()
 28498:     {
 28498:       delete static_cast<nsKeyEvent*>(mEvent);
 28498:     }
 28498:   };
 28498: 
 98653:   // Check if aEvent is a mouse event and record the mouse location for later
 98653:   // synth mouse moves.
 98653:   void RecordMouseLocation(nsGUIEvent* aEvent);
 98653:   class nsSynthMouseMoveEvent : public nsARefreshObserver {
 98653:   public:
 98653:     nsSynthMouseMoveEvent(PresShell* aPresShell, bool aFromScroll)
 98653:       : mPresShell(aPresShell), mFromScroll(aFromScroll) {
 98653:       NS_ASSERTION(mPresShell, "null parameter");
 98653:     }
 98653:     ~nsSynthMouseMoveEvent() {
 98653:       Revoke();
 98653:     }
 25722: 
 98653:     NS_INLINE_DECL_REFCOUNTING(nsSynthMouseMoveEvent)
     1:     
 98653:     void Revoke() {
 98653:       if (mPresShell) {
 98653:         mPresShell->GetPresContext()->RefreshDriver()->
 98653:           RemoveRefreshObserver(this, Flush_Display);
 98653:         mPresShell = nsnull;
 98653:       }
 98653:     }
 98653:     virtual void WillRefresh(mozilla::TimeStamp aTime) {
 98653:       if (mPresShell)
 98653:         mPresShell->ProcessSynthMouseMoveEvent(mFromScroll);
 98653:     }
 98653:   private:
 98653:     PresShell* mPresShell;
 98653:     bool mFromScroll;
 98653:   };
 98653:   void ProcessSynthMouseMoveEvent(bool aFromScroll);
     1: 
 98653:   void QueryIsActive();
 98653:   nsresult UpdateImageLockingState();
 97066: 
 97066: #ifdef ANDROID
 97066:   nsIDocument* GetTouchEventTargetDocument();
 97066: #endif
 79445:   bool InZombieDocument(nsIContent *aContent);
 47198:   already_AddRefed<nsIPresShell> GetParentPresShell();
 98653:   nsIFrame* GetCurrentEventFrame();
     1:   nsresult RetargetEventToParent(nsGUIEvent* aEvent,
     1:                                  nsEventStatus*  aEventStatus);
     1:   void PushCurrentEventInfo(nsIFrame* aFrame, nsIContent* aContent);
     1:   void PopCurrentEventInfo();
 82566:   nsresult HandleEventInternal(nsEvent* aEvent, nsEventStatus *aStatus);
 82566:   nsresult HandlePositionedEvent(nsIFrame*      aTargetFrame,
     1:                                  nsGUIEvent*    aEvent,
     1:                                  nsEventStatus* aEventStatus);
 36337:   // This returns the focused DOM window under our top level window.
 36337:   //  I.e., when we are deactive, this returns the *last* focused DOM window.
 36337:   already_AddRefed<nsPIDOMWindow> GetFocusedDOMWindowInOurWindow();
     1: 
 23881:   /*
 23881:    * This and the next two helper methods are used to target and position the
 23881:    * context menu when the keyboard shortcut is used to open it.
 23881:    *
 23881:    * If another menu is open, the context menu is opened relative to the
 23881:    * active menuitem within the menu, or the menu itself if no item is active.
 23881:    * Otherwise, if the caret is visible, the menu is opened near the caret.
 23881:    * Otherwise, if a selectable list such as a listbox is focused, the
 23881:    * current item within the menu is opened relative to this item.
 23881:    * Otherwise, the context menu is opened at the topleft corner of the
 23881:    * view.
 23881:    *
 23881:    * Returns true if the context menu event should fire and false if it should
 23881:    * not.
 23881:    */
 79445:   bool AdjustContextMenuKeyEvent(nsMouseEvent* aEvent);
 23881: 
 23881:   // 
 79445:   bool PrepareToUseCaretPosition(nsIWidget* aEventWidget, nsIntPoint& aTargetPt);
 23881: 
 23881:   // Get the selected item and coordinates in device pixels relative to root
 30534:   // document's root view for element, first ensuring the element is onscreen
 23881:   void GetCurrentItemAndPositionForElement(nsIDOMElement *aCurrentEl,
 23881:                                            nsIContent **aTargetToUse,
 47902:                                            nsIntPoint& aTargetPt,
 47902:                                            nsIWidget *aRootWidget);
 23881: 
     1:   void FireResizeEvent();
 57661:   void FireBeforeResizeEvent();
 31584:   static void AsyncResizeEventCallback(nsITimer* aTimer, void* aPresShell);
     1: 
 79445:   virtual void SynthesizeMouseMove(bool aFromScroll);
 69702: 
 98653:   PresShell* GetRootPresShell();
 98653: 
 98653:   nscolor GetDefaultBackgroundColorToDraw();
 98653: 
 98653:   // The callback for the mPaintSuppressionTimer timer.
 98653:   static void sPaintSuppressionCallback(nsITimer* aTimer, void* aPresShell);
 98653: 
 98653:   // The callback for the mReflowContinueTimer timer.
 98653:   static void sReflowContinueCallback(nsITimer* aTimer, void* aPresShell);
 98653:   bool ScheduleReflowOffTimer();
 98653:   
 98653: #ifdef DEBUG
 98653:   // The reflow root under which we're currently reflowing.  Null when
 98653:   // not in reflow.
 98653:   nsIFrame*                 mCurrentReflowRoot;
 98653:   PRUint32                  mUpdateCount;
 98653: #endif
 98653: 
 98653: #ifdef MOZ_REFLOW_PERF
 98653:   ReflowCountMgr*           mReflowCountMgr;
 98653: #endif
 98653: 
 69702:   // This is used for synthetic mouse events that are sent when what is under
 69702:   // the mouse pointer may have changed without the mouse moving (eg scrolling,
 69702:   // change to the document contents).
 69702:   // It is set only on a presshell for a root document, this value represents
 69702:   // the last observed location of the mouse relative to that root document. It
 69702:   // is set to (NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE) if the mouse isn't
 69702:   // over our window or there is no last observed mouse location for some
 69702:   // reason.
 69702:   nsPoint                   mMouseLocation;
 87190: 
 98653:   // mStyleSet owns it but we maintain a ref, may be null
 98653:   nsRefPtr<nsCSSStyleSheet> mPrefStyleSheet; 
 87190: 
 98653:   // Set of frames that we should mark with NS_FRAME_HAS_DIRTY_CHILDREN after
 98653:   // we finish reflowing mCurrentReflowRoot.
 98653:   nsTHashtable<nsPtrHashKey<nsIFrame> > mFramesToDirty;
 98653: 
 98653:   // Reflow roots that need to be reflowed.
 98653:   nsTArray<nsIFrame*>       mDirtyRoots;
 98653: 
 98653:   nsTArray<nsAutoPtr<nsDelayedEvent> > mDelayedEvents;
 98653:   nsRevocableEventPtr<nsRunnableMethod<PresShell> > mResizeEvent;
 98653:   nsCOMPtr<nsITimer>        mAsyncResizeEventTimer;
 98653:   nsIFrame*                 mCurrentEventFrame;
 98653:   nsCOMPtr<nsIContent>      mCurrentEventContent;
 98653:   nsTArray<nsIFrame*>       mCurrentEventFrameStack;
 98653:   nsCOMArray<nsIContent>    mCurrentEventContentStack;
 69702:   nsRevocableEventPtr<nsSynthMouseMoveEvent> mSynthMouseMoveEvent;
 98653:   nsCOMPtr<nsIContent>      mLastAnchorScrolledTo;
 98653:   nsRefPtr<nsCaret>         mCaret;
 98653:   nsRefPtr<nsCaret>         mOriginalCaret;
 98653:   nsCallbackEventRequest*   mFirstCallbackEventRequest;
 98653:   nsCallbackEventRequest*   mLastCallbackEventRequest;
 69702: 
 98653:   // This timer controls painting suppression.  Until it fires
 98653:   // or all frames are constructed, we won't paint anything but
 98653:   // our <body> background and scrollbars.
 98653:   nsCOMPtr<nsITimer>        mPaintSuppressionTimer;
 69702: 
 98653:   // At least on Win32 and Mac after interupting a reflow we need to post
 98653:   // the resume reflow event off a timer to avoid event starvation because
 98653:   // posted messages are processed before other messages when the modal
 98653:   // moving/sizing loop is running, see bug 491700 for details.
 98653:   nsCOMPtr<nsITimer>        mReflowContinueTimer;
 42982: 
 98653:   // Information needed to properly handle scrolling content into view if the
 98653:   // pre-scroll reflow flush can be interrupted.  mContentToScrollTo is
 98653:   // non-null between the initial scroll attempt and the first time we finish
 98654:   // processing all our dirty roots.  mContentToScrollTo has a content property
 98654:   // storing the details for the scroll operation, see ScrollIntoViewData above.
 98653:   nsCOMPtr<nsIContent>      mContentToScrollTo;
 74692: 
 98653:   nscoord                   mLastAnchorScrollPositionY;
 78004: 
 98653:   // This is used to protect ourselves from triggering reflow while in the
 98653:   // middle of frame construction and the like... it really shouldn't be
 98653:   // needed, one hopes, but it is for now.
 98653:   PRUint16                  mChangeNestCount;
 98653:   
 98653:   bool                      mDocumentLoading : 1;
 98653:   bool                      mIgnoreFrameDestruction : 1;
 98653:   bool                      mHaveShutDown : 1;
 98653:   bool                      mViewportOverridden : 1;
 98653:   bool                      mLastRootReflowHadUnconstrainedHeight : 1;
 98653:   bool                      mNoDelayedMouseEvents : 1;
 98653:   bool                      mNoDelayedKeyEvents : 1;
 98653: 
 98653:   // We've been disconnected from the document.  We will refuse to paint the
 98653:   // document until either our timer fires or all frames are constructed.
 98653:   bool                      mIsDocumentGone : 1;
 98653: 
 98653:   // Indicates that it is safe to unlock painting once all pending reflows
 98653:   // have been processed.
 98653:   bool                      mShouldUnsuppressPainting : 1;
 98653: 
 98653:   bool                      mAsyncResizeTimerIsActive : 1;
 98653:   bool                      mInResize : 1;
 98653: 
 98653:   static bool               sDisableNonTestMouseEvents;
     1: };
     1: 
 78155: #endif /* !defined(nsPresShell_h_) */
