    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* vim:set ts=4 sw=4 cindent et: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
 2659:  *      Prasad Sunkari <prasad@medhas.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsIOService.h"
    1: #include "nsIProtocolHandler.h"
    1: #include "nsIFileProtocolHandler.h"
    1: #include "nscore.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIURI.h"
    1: #include "nsIStreamListener.h"
    1: #include "prprf.h"
    1: #include "prlog.h"
    1: #include "nsLoadGroup.h"
    1: #include "nsInputStreamChannel.h"
    1: #include "nsXPIDLString.h" 
    1: #include "nsReadableUtils.h"
    1: #include "nsIErrorService.h" 
    1: #include "netCore.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch2.h"
    1: #include "nsIPrefLocalizedString.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsIProxiedProtocolHandler.h"
    1: #include "nsIProxyInfo.h"
    1: #include "nsITimelineService.h"
    1: #include "nsEscape.h"
    1: #include "nsNetCID.h"
    1: #include "nsIRecyclingAllocator.h"
    1: #include "nsISocketTransport.h"
    1: #include "nsCRT.h"
31773: #include "nsSimpleNestedURI.h"
    1: #include "nsNetUtil.h"
    1: #include "nsThreadUtils.h"
18430: #include "nsIPermissionManager.h"
24031: #include "nsTArray.h"
35023: #include "nsIConsoleService.h"
35023: #include "nsIUploadChannel2.h"
46844: #include "nsXULAppAPI.h"
    1: 
42480: #include "mozilla/FunctionTimer.h"
42480: 
51789: #if defined(XP_WIN) || defined(MOZ_PLATFORM_MAEMO)
    1: #include "nsNativeConnectionHelper.h"
    1: #endif
    1: 
    1: #define PORT_PREF_PREFIX           "network.security.ports."
    1: #define PORT_PREF(x)               PORT_PREF_PREFIX x
    1: #define AUTODIAL_PREF              "network.autodial-helper.enabled"
23578: #define MANAGE_OFFLINE_STATUS_PREF "network.manage-offline-status"
    1: 
41031: #define NECKO_BUFFER_CACHE_COUNT_PREF "network.buffer.cache.count"
41031: #define NECKO_BUFFER_CACHE_SIZE_PREF  "network.buffer.cache.size"
41031: 
    1: #define MAX_RECURSION_COUNT 50
    1: 
    1: nsIOService* gIOService = nsnull;
35023: static PRBool gHasWarnedUploadChannel2;
    1: 
    1: // A general port blacklist.  Connections to these ports will not be allowed unless 
    1: // the protocol overrides.
    1: //
    1: // TODO: I am sure that there are more ports to be added.  
    1: //       This cut is based on the classic mozilla codebase
    1: 
    1: PRInt16 gBadPortList[] = { 
    1:   1,    // tcpmux          
    1:   7,    // echo     
    1:   9,    // discard          
    1:   11,   // systat   
    1:   13,   // daytime          
    1:   15,   // netstat  
    1:   17,   // qotd             
    1:   19,   // chargen  
    1:   20,   // ftp-data         
    1:   21,   // ftp-cntl 
    1:   22,   // ssh              
    1:   23,   // telnet   
    1:   25,   // smtp     
    1:   37,   // time     
    1:   42,   // name     
    1:   43,   // nicname  
    1:   53,   // domain  
    1:   77,   // priv-rjs 
    1:   79,   // finger   
    1:   87,   // ttylink  
    1:   95,   // supdup   
    1:   101,  // hostriame
    1:   102,  // iso-tsap 
    1:   103,  // gppitnp  
    1:   104,  // acr-nema 
    1:   109,  // pop2     
    1:   110,  // pop3     
    1:   111,  // sunrpc   
    1:   113,  // auth     
    1:   115,  // sftp     
    1:   117,  // uucp-path
    1:   119,  // nntp     
    1:   123,  // NTP
    1:   135,  // loc-srv / epmap         
    1:   139,  // netbios
    1:   143,  // imap2  
    1:   179,  // BGP
    1:   389,  // ldap        
    1:   465,  // smtp+ssl
    1:   512,  // print / exec          
    1:   513,  // login         
    1:   514,  // shell         
    1:   515,  // printer         
    1:   526,  // tempo         
    1:   530,  // courier        
    1:   531,  // Chat         
    1:   532,  // netnews        
    1:   540,  // uucp       
    1:   556,  // remotefs    
    1:   563,  // nntp+ssl
    1:   587,  //
    1:   601,  //       
    1:   636,  // ldap+ssl
    1:   993,  // imap+ssl
    1:   995,  // pop3+ssl
    1:   2049, // nfs
    1:   4045, // lockd
    1:   6000, // x11        
    1:   0,    // This MUST be zero so that we can populating the array
    1: };
    1: 
    1: static const char kProfileChangeNetTeardownTopic[] = "profile-change-net-teardown";
    1: static const char kProfileChangeNetRestoreTopic[] = "profile-change-net-restore";
    1: 
    1: // Necko buffer cache
    1: nsIMemory* nsIOService::gBufferCache = nsnull;
41031: PRUint32   nsIOService::gDefaultSegmentSize = 4096;
41031: PRUint32   nsIOService::gDefaultSegmentCount = 24;
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: 
    1: nsIOService::nsIOService()
58439:     : mOffline(PR_TRUE)
    1:     , mOfflineForProfileChange(PR_FALSE)
29051:     , mManageOfflineStatus(PR_TRUE)
25375:     , mSettingOffline(PR_FALSE)
25375:     , mSetOfflineValue(PR_FALSE)
26303:     , mShutdown(PR_FALSE)
    1:     , mChannelEventSinks(NS_CHANNEL_EVENT_SINK_CATEGORY)
    1:     , mContentSniffers(NS_CONTENT_SNIFFER_CATEGORY)
    1: {
    1: }
    1: 
    1: nsresult
    1: nsIOService::Init()
    1: {
42480:     NS_TIME_FUNCTION;
42480: 
    1:     nsresult rv;
    1: 
58439:     // We need to get references to the DNS service so that we can shut it
    1:     // down later. If we wait until the nsIOService is being shut down,
    1:     // GetService will fail at that point.
    1: 
 5691:     mDNSService = do_GetService(NS_DNSSERVICE_CONTRACTID, &rv);
 2242:     if (NS_FAILED(rv)) {
    1:         NS_WARNING("failed to get DNS service");
 2242:         return rv;
 2242:     }
    1: 
42480:     NS_TIME_FUNCTION_MARK("got DNS Service");
42480: 
    1:     // XXX hack until xpidl supports error info directly (bug 13423)
 5691:     nsCOMPtr<nsIErrorService> errorService = do_GetService(NS_ERRORSERVICE_CONTRACTID);
    1:     if (errorService) {
    1:         errorService->RegisterErrorStringBundle(NS_ERROR_MODULE_NETWORK, NECKO_MSGS_URL);
    1:     }
    1:     else
    1:         NS_WARNING("failed to get error service");
    1:     
42480:     NS_TIME_FUNCTION_MARK("got Error Service");
42480: 
    1:     // setup our bad port list stuff
    1:     for(int i=0; gBadPortList[i]; i++)
25383:         mRestrictedPortList.AppendElement(gBadPortList[i]);
    1: 
    1:     // Further modifications to the port list come from prefs
    1:     nsCOMPtr<nsIPrefBranch2> prefBranch;
    1:     GetPrefBranch(getter_AddRefs(prefBranch));
    1:     if (prefBranch) {
    1:         prefBranch->AddObserver(PORT_PREF_PREFIX, this, PR_TRUE);
    1:         prefBranch->AddObserver(AUTODIAL_PREF, this, PR_TRUE);
23578:         prefBranch->AddObserver(MANAGE_OFFLINE_STATUS_PREF, this, PR_TRUE);
    1:         PrefsChanged(prefBranch);
    1:     }
    1:     
    1:     // Register for profile change notifications
    1:     nsCOMPtr<nsIObserverService> observerService =
41540:         mozilla::services::GetObserverService();
    1:     if (observerService) {
    1:         observerService->AddObserver(this, kProfileChangeNetTeardownTopic, PR_TRUE);
    1:         observerService->AddObserver(this, kProfileChangeNetRestoreTopic, PR_TRUE);
    1:         observerService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, PR_TRUE);
    1:         observerService->AddObserver(this, NS_NETWORK_LINK_TOPIC, PR_TRUE);
    1:     }
    1:     else
    1:         NS_WARNING("failed to get observer service");
    1:         
42480:     NS_TIME_FUNCTION_MARK("Registered observers");
42480: 
41031:     // Get the allocator ready
41031:     if (!gBufferCache) {
41031:         nsresult rv = NS_OK;
41031:         nsCOMPtr<nsIRecyclingAllocator> recyclingAllocator =
41031:             do_CreateInstance(NS_RECYCLINGALLOCATOR_CONTRACTID, &rv);
41031: 
41031:         if (NS_FAILED(rv))
41031:             return rv;
41031:         rv = recyclingAllocator->Init(gDefaultSegmentCount,
41031:                                       (15 * 60), // 15 minutes
41031:                                       "necko");
41031: 
41031:         NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Was unable to allocate.  No gBufferCache.");
41031:         CallQueryInterface(recyclingAllocator, &gBufferCache);
41031:     }
41031: 
42480:     NS_TIME_FUNCTION_MARK("Set up the recycling allocator");
42480: 
    1:     gIOService = this;
    1: 
48350: #ifdef MOZ_IPC
48344:     // go into managed mode if we can, and chrome process
48344:     if (XRE_GetProcessType() == GeckoProcessType_Default)
48350: #endif
    1:         mNetworkLinkService = do_GetService(NS_NETWORK_LINK_SERVICE_CONTRACTID);
48344: 
23578:     if (!mNetworkLinkService)
23578:         mManageOfflineStatus = PR_FALSE;
23578: 
23578:     if (mManageOfflineStatus)
    1:         TrackNetworkLinkStatusForOffline();
    1:     
42480:     NS_TIME_FUNCTION_MARK("Set up network link service");
42480: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsIOService::~nsIOService()
    1: {
    1:     gIOService = nsnull;
    1: }
    1: 
58439: nsresult
58439: nsIOService::InitializeSocketTransportService()
58439: {
58439:     NS_TIME_FUNCTION;
58439: 
58439:     nsresult rv = NS_OK;
58439: 
58439:     if (!mSocketTransportService) {
58439:         mSocketTransportService = do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID, &rv);
58439:         if (NS_FAILED(rv)) {
58439:             NS_WARNING("failed to get socket transport service");
58439:         }
58439:     }
58439: 
58439:     if (mSocketTransportService) {
58439:         rv = mSocketTransportService->Init();
58439:         NS_ASSERTION(NS_SUCCEEDED(rv), "socket transport service init failed");
58439:     }
58439: 
58439:     return rv;
58439: }
58439: 
    1: nsIOService*
    1: nsIOService::GetInstance() {
    1:     if (!gIOService) {
    1:         gIOService = new nsIOService();
    1:         if (!gIOService)
    1:             return nsnull;
    1:         NS_ADDREF(gIOService);
    1: 
    1:         nsresult rv = gIOService->Init();
    1:         if (NS_FAILED(rv)) {
    1:             NS_RELEASE(gIOService);
    1:             return nsnull;
    1:         }
    1:         return gIOService;
    1:     }
    1:     NS_ADDREF(gIOService);
    1:     return gIOService;
    1: }
    1: 
20651: NS_IMPL_THREADSAFE_ISUPPORTS5(nsIOService,
12033:                               nsIIOService,
12033:                               nsIIOService2,
12033:                               nsINetUtil,
12033:                               nsIObserver,
20651:                               nsISupportsWeakReference)
12033: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: 
    1: nsresult
48889: nsIOService::AsyncOnChannelRedirect(nsIChannel* oldChan, nsIChannel* newChan,
48889:                                     PRUint32 flags,
48889:                                     nsAsyncRedirectVerifyHelper *helper)
    1: {
    1:     nsCOMPtr<nsIChannelEventSink> sink =
    1:         do_GetService(NS_GLOBAL_CHANNELEVENTSINK_CONTRACTID);
    1:     if (sink) {
48889:         nsresult rv = helper->DelegateOnChannelRedirect(sink, oldChan,
48889:                                                         newChan, flags);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     // Finally, our category
    1:     const nsCOMArray<nsIChannelEventSink>& entries =
    1:         mChannelEventSinks.GetEntries();
    1:     PRInt32 len = entries.Count();
    1:     for (PRInt32 i = 0; i < len; ++i) {
48889:         nsresult rv = helper->DelegateOnChannelRedirect(entries[i], oldChan,
48889:                                                         newChan, flags);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsIOService::CacheProtocolHandler(const char *scheme, nsIProtocolHandler *handler)
    1: {
    1:     for (unsigned int i=0; i<NS_N(gScheme); i++)
    1:     {
    1:         if (!nsCRT::strcasecmp(scheme, gScheme[i]))
    1:         {
    1:             nsresult rv;
    1:             NS_ASSERTION(!mWeakHandler[i], "Protocol handler already cached");
    1:             // Make sure the handler supports weak references.
    1:             nsCOMPtr<nsISupportsWeakReference> factoryPtr = do_QueryInterface(handler, &rv);
    1:             if (!factoryPtr)
    1:             {
    1:                 // Don't cache handlers that don't support weak reference as
    1:                 // there is real danger of a circular reference.
    1: #ifdef DEBUG_dp
    1:                 printf("DEBUG: %s protcol handler doesn't support weak ref. Not cached.\n", scheme);
    1: #endif /* DEBUG_dp */
    1:                 return NS_ERROR_FAILURE;
    1:             }
    1:             mWeakHandler[i] = do_GetWeakReference(handler);
    1:             return NS_OK;
    1:         }
    1:     }
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: nsresult
    1: nsIOService::GetCachedProtocolHandler(const char *scheme, nsIProtocolHandler **result, PRUint32 start, PRUint32 end)
    1: {
    1:     PRUint32 len = end - start - 1;
    1:     for (unsigned int i=0; i<NS_N(gScheme); i++)
    1:     {
    1:         if (!mWeakHandler[i])
    1:             continue;
    1: 
    1:         // handle unterminated strings
    1:         // start is inclusive, end is exclusive, len = end - start - 1
    1:         if (end ? (!nsCRT::strncasecmp(scheme + start, gScheme[i], len)
    1:                    && gScheme[i][len] == '\0')
    1:                 : (!nsCRT::strcasecmp(scheme, gScheme[i])))
    1:         {
    1:             return CallQueryReferent(mWeakHandler[i].get(), result);
    1:         }
    1:     }
    1:     return NS_ERROR_FAILURE;
    1: }
    1:  
    1: NS_IMETHODIMP
    1: nsIOService::GetProtocolHandler(const char* scheme, nsIProtocolHandler* *result)
    1: {
    1:     nsresult rv;
    1: 
    1:     NS_ENSURE_ARG_POINTER(scheme);
    1:     // XXX we may want to speed this up by introducing our own protocol 
    1:     // scheme -> protocol handler mapping, avoiding the string manipulation
    1:     // and service manager stuff
    1: 
    1:     rv = GetCachedProtocolHandler(scheme, result);
    1:     if (NS_SUCCEEDED(rv))
    1:         return rv;
    1: 
    1:     PRBool externalProtocol = PR_FALSE;
    1:     PRBool listedProtocol   = PR_TRUE;
    1:     nsCOMPtr<nsIPrefBranch2> prefBranch;
    1:     GetPrefBranch(getter_AddRefs(prefBranch));
    1:     if (prefBranch) {
    1:         nsCAutoString externalProtocolPref("network.protocol-handler.external.");
    1:         externalProtocolPref += scheme;
    1:         rv = prefBranch->GetBoolPref(externalProtocolPref.get(), &externalProtocol);
    1:         if (NS_FAILED(rv)) {
    1:             externalProtocol = PR_FALSE;
    1:             listedProtocol   = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     if (!externalProtocol) {
    1:         nsCAutoString contractID(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX);
    1:         contractID += scheme;
    1:         ToLowerCase(contractID);
    1: 
    1:         rv = CallGetService(contractID.get(), result);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             CacheProtocolHandler(scheme, *result);
    1:             return rv;
    1:         }
    1: 
    1: #ifdef MOZ_X11
    1:         // check to see whether GnomeVFS can handle this URI scheme.  if it can
    1:         // create a nsIURI for the "scheme:", then we assume it has support for
    1:         // the requested protocol.  otherwise, we failover to using the default
    1:         // protocol handler.
    1: 
    1:         // XXX should this be generalized into something that searches a
    1:         // category?  (see bug 234714)
    1: 
    1:         rv = CallGetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX"moz-gnomevfs",
    1:                             result);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             nsCAutoString spec(scheme);
    1:             spec.Append(':');
    1: 
    1:             nsIURI *uri;
    1:             rv = (*result)->NewURI(spec, nsnull, nsnull, &uri);
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 NS_RELEASE(uri);
    1:                 return rv;
    1:             }
    1: 
    1:             NS_RELEASE(*result);
    1:         }
    1: #endif
 7714:     }
    1: 
    1:     // Okay we don't have a protocol handler to handle this url type, so use
    1:     // the default protocol handler.  This will cause urls to get dispatched
    1:     // out to the OS ('cause we can't do anything with them) when we try to
    1:     // read from a channel created by the default protocol handler.
    1: 
    1:     rv = CallGetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX"default",
    1:                         result);
    1:     if (NS_FAILED(rv))
    1:         return NS_ERROR_UNKNOWN_PROTOCOL;
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsIOService::ExtractScheme(const nsACString &inURI, nsACString &scheme)
    1: {
    1:     return net_ExtractURLScheme(inURI, nsnull, nsnull, &scheme);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsIOService::GetProtocolFlags(const char* scheme, PRUint32 *flags)
    1: {
    1:     nsCOMPtr<nsIProtocolHandler> handler;
    1:     nsresult rv = GetProtocolHandler(scheme, getter_AddRefs(handler));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = handler->GetProtocolFlags(flags);
    1:     return rv;
    1: }
    1: 
    1: class AutoIncrement
    1: {
    1:     public:
    1:         AutoIncrement(PRUint32 *var) : mVar(var)
    1:         {
    1:             ++*var;
    1:         }
    1:         ~AutoIncrement()
    1:         {
    1:             --*mVar;
    1:         }
    1:     private:
    1:         PRUint32 *mVar;
    1: };
    1: 
    1: nsresult
    1: nsIOService::NewURI(const nsACString &aSpec, const char *aCharset, nsIURI *aBaseURI, nsIURI **result)
    1: {
    1:     NS_ASSERTION(NS_IsMainThread(), "wrong thread");
    1: 
    1:     static PRUint32 recursionCount = 0;
    1:     if (recursionCount >= MAX_RECURSION_COUNT)
    1:         return NS_ERROR_MALFORMED_URI;
    1:     AutoIncrement inc(&recursionCount);
    1: 
    1:     nsCAutoString scheme;
    1:     nsresult rv = ExtractScheme(aSpec, scheme);
    1:     if (NS_FAILED(rv)) {
    1:         // then aSpec is relative
    1:         if (!aBaseURI)
    1:             return NS_ERROR_MALFORMED_URI;
    1: 
    1:         rv = aBaseURI->GetScheme(scheme);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     // now get the handler for this scheme
    1:     nsCOMPtr<nsIProtocolHandler> handler;
    1:     rv = GetProtocolHandler(scheme.get(), getter_AddRefs(handler));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     return handler->NewURI(aSpec, aCharset, aBaseURI, result);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsIOService::NewFileURI(nsIFile *file, nsIURI **result)
    1: {
    1:     nsresult rv;
    1:     NS_ENSURE_ARG_POINTER(file);
    1: 
    1:     nsCOMPtr<nsIProtocolHandler> handler;
    1: 
    1:     rv = GetProtocolHandler("file", getter_AddRefs(handler));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsCOMPtr<nsIFileProtocolHandler> fileHandler( do_QueryInterface(handler, &rv) );
    1:     if (NS_FAILED(rv)) return rv;
    1:     
    1:     return fileHandler->NewFileURI(file, result);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsIOService::NewChannelFromURI(nsIURI *aURI, nsIChannel **result)
    1: {
    1:     nsresult rv;
    1:     NS_ENSURE_ARG_POINTER(aURI);
    1:     NS_TIMELINE_MARK_URI("nsIOService::NewChannelFromURI(%s)", aURI);
    1: 
    1:     nsCAutoString scheme;
    1:     rv = aURI->GetScheme(scheme);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsCOMPtr<nsIProtocolHandler> handler;
    1:     rv = GetProtocolHandler(scheme.get(), getter_AddRefs(handler));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRUint32 protoFlags;
    1:     rv = handler->GetProtocolFlags(&protoFlags);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Talk to the PPS if the protocol handler allows proxying.  Otherwise,
    1:     // skip this step.  This allows us to lazily load the PPS at startup.
    1:     if (protoFlags & nsIProtocolHandler::ALLOWS_PROXY) {
    1:         nsCOMPtr<nsIProxyInfo> pi;
    1:         if (!mProxyService) {
    1:             mProxyService = do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID);
    1:             if (!mProxyService)
    1:                 NS_WARNING("failed to get protocol proxy service");
    1:         }
    1:         if (mProxyService) {
21336:             rv = mProxyService->Resolve(aURI, 0, getter_AddRefs(pi));
    1:             if (NS_FAILED(rv))
    1:                 pi = nsnull;
    1:         }
    1:         if (pi) {
    1:             nsCAutoString type;
    1:             if (NS_SUCCEEDED(pi->GetType(type)) && type.EqualsLiteral("http")) {
    1:                 // we are going to proxy this channel using an http proxy
    1:                 rv = GetProtocolHandler("http", getter_AddRefs(handler));
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1:             }
    1:             nsCOMPtr<nsIProxiedProtocolHandler> pph = do_QueryInterface(handler);
    1:             if (pph)
    1:                 return pph->NewProxiedChannel(aURI, pi, result);
    1:         }
    1:     }
    1: 
35023:     rv = handler->NewChannel(aURI, result);
35023:     NS_ENSURE_SUCCESS(rv, rv);
35023: 
35023:     // Some extensions override the http protocol handler and provide their own
35023:     // implementation. The channels returned from that implementation doesn't
35023:     // seem to always implement the nsIUploadChannel2 interface, presumably
35023:     // because it's a new interface.
35023:     // Eventually we should remove this and simply require that http channels
35023:     // implement the new interface.
35023:     // See bug 529041
35023:     if (!gHasWarnedUploadChannel2 && scheme.EqualsLiteral("http")) {
35023:         nsCOMPtr<nsIUploadChannel2> uploadChannel2 = do_QueryInterface(*result);
35023:         if (!uploadChannel2) {
35023:             nsCOMPtr<nsIConsoleService> consoleService =
35023:                 do_GetService(NS_CONSOLESERVICE_CONTRACTID);
35023:             if (consoleService) {
35023:                 consoleService->LogStringMessage(NS_LITERAL_STRING(
35027:                     "Http channel implementation doesn't support nsIUploadChannel2. An extension has supplied a non-functional http protocol handler. This will break behavior and in future releases not work at all."
35027:                                                                    ).get());
35023:             }
35023:             gHasWarnedUploadChannel2 = PR_TRUE;
35023:         }
35023:     }
35023: 
35023:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsIOService::NewChannel(const nsACString &aSpec, const char *aCharset, nsIURI *aBaseURI, nsIChannel **result)
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIURI> uri;
    1:     rv = NewURI(aSpec, aCharset, aBaseURI, getter_AddRefs(uri));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     return NewChannelFromURI(uri, result);
    1: }
    1: 
21613: PRBool
21613: nsIOService::IsLinkUp()
21613: {
21613:     if (!mNetworkLinkService) {
21613:         // We cannot decide, assume the link is up
21613:         return PR_TRUE;
21613:     }
21613: 
21613:     PRBool isLinkUp;
21613:     nsresult rv;
21613:     rv = mNetworkLinkService->GetIsLinkUp(&isLinkUp);
21613:     if (NS_FAILED(rv)) {
21613:         return PR_TRUE;
21613:     }
21613: 
21613:     return isLinkUp;
21613: }
21613: 
    1: NS_IMETHODIMP
    1: nsIOService::GetOffline(PRBool *offline)
    1: {
    1:     *offline = mOffline;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsIOService::SetOffline(PRBool offline)
    1: {
26303:     // When someone wants to go online (!offline) after we got XPCOM shutdown
26303:     // throw ERROR_NOT_AVAILABLE to prevent return to online state.
26303:     if (mShutdown && !offline)
26303:         return NS_ERROR_NOT_AVAILABLE;
26303: 
25375:     // SetOffline() may re-enter while it's shutting down services.
25375:     // If that happens, save the most recent value and it will be
25375:     // processed when the first SetOffline() call is done bringing
25375:     // down the service.
25375:     mSetOfflineValue = offline;
25375:     if (mSettingOffline) {
25375:         return NS_OK;
25375:     }
46844: 
25375:     mSettingOffline = PR_TRUE;
25375: 
    1:     nsCOMPtr<nsIObserverService> observerService =
41540:         mozilla::services::GetObserverService();
    1: 
46844:     NS_ASSERTION(observerService, "The observer service should not be null");
46844: 
46844: #ifdef MOZ_IPC
46844:     if (XRE_GetProcessType() == GeckoProcessType_Default) {
46844:         if (observerService) {
46844:             (void)observerService->NotifyObservers(nsnull,
46845:                 NS_IPC_IOSERVICE_SET_OFFLINE_TOPIC, offline ? 
46844:                 NS_LITERAL_STRING("true").get() :
46844:                 NS_LITERAL_STRING("false").get());
46844:         }
46844:     }
46844: #endif
46844: 
25375:     while (mSetOfflineValue != mOffline) {
25375:         offline = mSetOfflineValue;
25375: 
    1:         nsresult rv;
    1:         if (offline && !mOffline) {
    1:             NS_NAMED_LITERAL_STRING(offlineString, NS_IOSERVICE_OFFLINE);
    1:             mOffline = PR_TRUE; // indicate we're trying to shutdown
    1: 
    1:             // don't care if notification fails
    1:             // this allows users to attempt a little cleanup before dns and socket transport are shut down.
    1:             if (observerService)
 3233:                 observerService->NotifyObservers(static_cast<nsIIOService *>(this),
    1:                                                  NS_IOSERVICE_GOING_OFFLINE_TOPIC,
    1:                                                  offlineString.get());
    1: 
    1:             // be sure to try and shutdown both (even if the first fails)...
    1:             // shutdown dns service first, because it has callbacks for socket transport
    1:             if (mDNSService) {
    1:                 rv = mDNSService->Shutdown();
    1:                 NS_ASSERTION(NS_SUCCEEDED(rv), "DNS service shutdown failed");
    1:             }
    1:             if (mSocketTransportService) {
    1:                 rv = mSocketTransportService->Shutdown();
    1:                 NS_ASSERTION(NS_SUCCEEDED(rv), "socket transport service shutdown failed");
    1:             }
    1: 
    1:             // don't care if notification fails
    1:             if (observerService)
 3233:                 observerService->NotifyObservers(static_cast<nsIIOService *>(this),
    1:                                                  NS_IOSERVICE_OFFLINE_STATUS_TOPIC,
    1:                                                  offlineString.get());
    1:         }
    1:         else if (!offline && mOffline) {
    1:             // go online
    1:             if (mDNSService) {
    1:                 rv = mDNSService->Init();
    1:                 NS_ASSERTION(NS_SUCCEEDED(rv), "DNS service init failed");
    1:             }
58439:             InitializeSocketTransportService();
    1:             mOffline = PR_FALSE;    // indicate success only AFTER we've
    1:                                     // brought up the services
    1: 
    1:             // trigger a PAC reload when we come back online
    1:             if (mProxyService)
    1:                 mProxyService->ReloadPAC();
    1: 
    1:             // don't care if notification fails
    1:             if (observerService)
 3233:                 observerService->NotifyObservers(static_cast<nsIIOService *>(this),
    1:                                                  NS_IOSERVICE_OFFLINE_STATUS_TOPIC,
    1:                                                  NS_LITERAL_STRING(NS_IOSERVICE_ONLINE).get());
    1:         }
25375:     }
25375: 
25375:     mSettingOffline = PR_FALSE;
25375: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsIOService::AllowPort(PRInt32 inPort, const char *scheme, PRBool *_retval)
    1: {
    1:     PRInt16 port = inPort;
    1:     if (port == -1) {
    1:         *_retval = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1:         
    1:     // first check to see if the port is in our blacklist:
25383:     PRInt32 badPortListCnt = mRestrictedPortList.Length();
    1:     for (int i=0; i<badPortListCnt; i++)
    1:     {
25383:         if (port == mRestrictedPortList[i])
    1:         {
    1:             *_retval = PR_FALSE;
    1: 
    1:             // check to see if the protocol wants to override
    1:             if (!scheme)
    1:                 return NS_OK;
    1:             
    1:             nsCOMPtr<nsIProtocolHandler> handler;
    1:             nsresult rv = GetProtocolHandler(scheme, getter_AddRefs(handler));
    1:             if (NS_FAILED(rv)) return rv;
    1: 
    1:             // let the protocol handler decide
    1:             return handler->AllowPort(port, scheme, _retval);
    1:         }
    1:     }
    1: 
    1:     *_retval = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: 
    1: void
    1: nsIOService::PrefsChanged(nsIPrefBranch *prefs, const char *pref)
    1: {
    1:     if (!prefs) return;
    1: 
    1:     // Look for extra ports to block
    1:     if (!pref || strcmp(pref, PORT_PREF("banned")) == 0)
    1:         ParsePortList(prefs, PORT_PREF("banned"), PR_FALSE);
    1: 
    1:     // ...as well as previous blocks to remove.
    1:     if (!pref || strcmp(pref, PORT_PREF("banned.override")) == 0)
    1:         ParsePortList(prefs, PORT_PREF("banned.override"), PR_TRUE);
    1: 
    1:     if (!pref || strcmp(pref, AUTODIAL_PREF) == 0) {
    1:         PRBool enableAutodial = PR_FALSE;
    1:         nsresult rv = prefs->GetBoolPref(AUTODIAL_PREF, &enableAutodial);
    1:         // If pref not found, default to disabled.
    1:         if (NS_SUCCEEDED(rv)) {
    1:             if (mSocketTransportService)
    1:                 mSocketTransportService->SetAutodialEnabled(enableAutodial);
    1:         }
    1:     }
23578: 
23578:     if (!pref || strcmp(pref, MANAGE_OFFLINE_STATUS_PREF) == 0) {
23578:         PRBool manage;
23578:         if (NS_SUCCEEDED(prefs->GetBoolPref(MANAGE_OFFLINE_STATUS_PREF,
23578:                                             &manage)))
23578:             SetManageOfflineStatus(manage);
23578:     }
41031: 
41031:     if (!pref || strcmp(pref, NECKO_BUFFER_CACHE_COUNT_PREF) == 0) {
41031:         PRInt32 count;
41031:         if (NS_SUCCEEDED(prefs->GetIntPref(NECKO_BUFFER_CACHE_COUNT_PREF,
41031:                                            &count)))
41031:             /* check for bogus values and default if we find such a value */
41031:             if (count > 0)
41031:                 gDefaultSegmentCount = count;
41031:     }
41031:     
41031:     if (!pref || strcmp(pref, NECKO_BUFFER_CACHE_SIZE_PREF) == 0) {
41031:         PRInt32 size;
41031:         if (NS_SUCCEEDED(prefs->GetIntPref(NECKO_BUFFER_CACHE_SIZE_PREF,
41031:                                            &size)))
41031:             /* check for bogus values and default if we find such a value
41031:              * the upper limit here is arbitrary. having a 1mb segment size
41031:              * is pretty crazy.  if you remove this, consider adding some
41031:              * integer rollover test.
41031:              */
41031:             if (size > 0 && size < 1024*1024)
41031:                 gDefaultSegmentSize = size;
41031:         NS_WARN_IF_FALSE( (!(size & (size - 1))) , "network buffer cache size is not a power of 2!");
41031:     }
    1: }
    1: 
    1: void
    1: nsIOService::ParsePortList(nsIPrefBranch *prefBranch, const char *pref, PRBool remove)
    1: {
    1:     nsXPIDLCString portList;
    1: 
    1:     // Get a pref string and chop it up into a list of ports.
    1:     prefBranch->GetCharPref(pref, getter_Copies(portList));
    1:     if (portList) {
24031:         nsTArray<nsCString> portListArray;
24031:         ParseString(portList, ',', portListArray);
24031:         PRUint32 index;
24031:         for (index=0; index < portListArray.Length(); index++) {
24031:             portListArray[index].StripWhitespace();
    1:             PRInt32 aErrorCode, portBegin, portEnd;
    1: 
24031:             if (PR_sscanf(portListArray[index].get(), "%d-%d", &portBegin, &portEnd) == 2) {
    1:                if ((portBegin < 65536) && (portEnd < 65536)) {
    1:                    PRInt32 curPort;
    1:                    if (remove) {
    1:                         for (curPort=portBegin; curPort <= portEnd; curPort++)
25383:                             mRestrictedPortList.RemoveElement(curPort);
    1:                    } else {
    1:                         for (curPort=portBegin; curPort <= portEnd; curPort++)
25383:                             mRestrictedPortList.AppendElement(curPort);
    1:                    }
    1:                }
    1:             } else {
24031:                PRInt32 port = portListArray[index].ToInteger(&aErrorCode);
    1:                if (NS_SUCCEEDED(aErrorCode) && port < 65536) {
    1:                    if (remove)
25383:                        mRestrictedPortList.RemoveElement(port);
    1:                    else
25383:                        mRestrictedPortList.AppendElement(port);
    1:                }
    1:             }
    1: 
    1:         }
    1:     }
    1: }
    1: 
    1: void
    1: nsIOService::GetPrefBranch(nsIPrefBranch2 **result)
    1: {
    1:     *result = nsnull;
    1:     CallGetService(NS_PREFSERVICE_CONTRACTID, result);
    1: }
    1: 
    1: // nsIObserver interface
    1: NS_IMETHODIMP
    1: nsIOService::Observe(nsISupports *subject,
    1:                      const char *topic,
    1:                      const PRUnichar *data)
    1: {
    1:     if (!strcmp(topic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
    1:         nsCOMPtr<nsIPrefBranch> prefBranch = do_QueryInterface(subject);
    1:         if (prefBranch)
    1:             PrefsChanged(prefBranch, NS_ConvertUTF16toUTF8(data).get());
    1:     }
    1:     else if (!strcmp(topic, kProfileChangeNetTeardownTopic)) {
    1:         if (!mOffline) {
    1:             SetOffline(PR_TRUE);
    1:             mOfflineForProfileChange = PR_TRUE;
    1:         }
    1:     }
    1:     else if (!strcmp(topic, kProfileChangeNetRestoreTopic)) {
    1:         if (mOfflineForProfileChange) {
    1:             mOfflineForProfileChange = PR_FALSE;
    1:             if (!mManageOfflineStatus ||
    1:                 NS_FAILED(TrackNetworkLinkStatusForOffline())) {
    1:                 SetOffline(PR_FALSE);
    1:             }
    1:         } 
    1:     }
    1:     else if (!strcmp(topic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)) {
26303:         // Remember we passed XPCOM shutdown notification to prevent any
26303:         // changes of the offline status from now. We must not allow going
26303:         // online after this point.
26303:         mShutdown = PR_TRUE;
26303: 
    1:         SetOffline(PR_TRUE);
    1: 
    1:         // Break circular reference.
    1:         mProxyService = nsnull;
    1:     }
    1:     else if (!strcmp(topic, NS_NETWORK_LINK_TOPIC)) {
    1:         if (!mOfflineForProfileChange && mManageOfflineStatus) {
    1:             TrackNetworkLinkStatusForOffline();
    1:         }
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: // nsINetUtil interface
    1: NS_IMETHODIMP
    1: nsIOService::ParseContentType(const nsACString &aTypeHeader,
    1:                               nsACString &aCharset,
    1:                               PRBool *aHadCharset,
    1:                               nsACString &aContentType)
    1: {
    1:     net_ParseContentType(aTypeHeader, aContentType, aCharset, aHadCharset);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsIOService::ProtocolHasFlags(nsIURI   *uri,
    1:                               PRUint32  flags,
    1:                               PRBool   *result)
    1: {
    1:     NS_ENSURE_ARG(uri);
    1: 
    1:     *result = PR_FALSE;
    1:     nsCAutoString scheme;
    1:     nsresult rv = uri->GetScheme(scheme);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:     PRUint32 protocolFlags;
    1:     rv = GetProtocolFlags(scheme.get(), &protocolFlags);
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:         *result = (protocolFlags & flags) == flags;
    1:     }
    1:   
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsIOService::URIChainHasFlags(nsIURI   *uri,
    1:                               PRUint32  flags,
    1:                               PRBool   *result)
    1: {
    1:     nsresult rv = ProtocolHasFlags(uri, flags, result);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (*result) {
    1:         return rv;
    1:     }
    1: 
    1:     // Dig deeper into the chain.  Note that this is not a do/while loop to
    1:     // avoid the extra addref/release on |uri| in the common (non-nested) case.
    1:     nsCOMPtr<nsINestedURI> nestedURI = do_QueryInterface(uri);
    1:     while (nestedURI) {
    1:         nsCOMPtr<nsIURI> innerURI;
    1:         rv = nestedURI->GetInnerURI(getter_AddRefs(innerURI));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         rv = ProtocolHasFlags(innerURI, flags, result);
    1: 
    1:         if (*result) {
    1:             return rv;
    1:         }
    1: 
    1:         nestedURI = do_QueryInterface(innerURI);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsIOService::ToImmutableURI(nsIURI* uri, nsIURI** result)
    1: {
    1:     if (!uri) {
    1:         *result = nsnull;
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsresult rv = NS_EnsureSafeToReturn(uri, result);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     NS_TryToSetImmutable(*result);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
31773: nsIOService::NewSimpleNestedURI(nsIURI* aURI, nsIURI** aResult)
31773: {
31773:     NS_ENSURE_ARG(aURI);
31773: 
31773:     nsCOMPtr<nsIURI> safeURI;
31773:     nsresult rv = NS_EnsureSafeToReturn(aURI, getter_AddRefs(safeURI));
31773:     NS_ENSURE_SUCCESS(rv, rv);
31773: 
31773:     NS_IF_ADDREF(*aResult = new nsSimpleNestedURI(safeURI));
31773:     return *aResult ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
31773: }
31773: 
31773: NS_IMETHODIMP
    1: nsIOService::SetManageOfflineStatus(PRBool aManage) {
    1:     PRBool wasManaged = mManageOfflineStatus;
    1:     mManageOfflineStatus = aManage;
    1:     if (mManageOfflineStatus && !wasManaged)
    1:         return TrackNetworkLinkStatusForOffline();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsIOService::GetManageOfflineStatus(PRBool* aManage) {
    1:     *aManage = mManageOfflineStatus;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsIOService::TrackNetworkLinkStatusForOffline()
    1: {
    1:     NS_ASSERTION(mManageOfflineStatus,
    1:                  "Don't call this unless we're managing the offline status");
    1:     if (!mNetworkLinkService)
    1:         return NS_ERROR_FAILURE;
    1: 
26303:     if (mShutdown)
26303:         return NS_ERROR_NOT_AVAILABLE;
26303:   
    1:     // check to make sure this won't collide with Autodial
    1:     if (mSocketTransportService) {
    1:         PRBool autodialEnabled = PR_FALSE;
    1:         mSocketTransportService->GetAutodialEnabled(&autodialEnabled);
    1:         // If autodialing-on-link-down is enabled, check if the OS auto dial 
    1:         // option is set to always autodial. If so, then we are 
    1:         // always up for the purposes of offline management.
    1:         if (autodialEnabled) {
51789: #if defined(XP_WIN) || defined(MOZ_PLATFORM_MAEMO)
35003:             // On Windows and Maemo (libconic) we should first check with the OS
35003:             // to see if autodial is enabled.  If it is enabled then we are
35003:             // allowed to manage the offline state.
    1:             if(nsNativeConnectionHelper::IsAutodialEnabled()) 
    1:                 return SetOffline(PR_FALSE);
    1: #else
    1:             return SetOffline(PR_FALSE);
    1: #endif
    1:         }
    1:     }
    1: 
    1:     PRBool isUp;
    1:     nsresult rv = mNetworkLinkService->GetIsLinkUp(&isUp);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     return SetOffline(!isUp);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsIOService::EscapeString(const nsACString& aString,
    1:                           PRUint32 aEscapeType,
    1:                           nsACString& aResult)
    1: {
  730:   NS_ENSURE_ARG_RANGE(aEscapeType, 0, 4);
    1: 
    1:   nsCAutoString stringCopy(aString);
    1:   nsCString result;
    1: 
    1:   if (!NS_Escape(stringCopy, result, (nsEscapeMask) aEscapeType))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   aResult.Assign(result);
    1: 
    1:   return NS_OK;
    1: }
  730: 
  730: NS_IMETHODIMP 
 2659: nsIOService::EscapeURL(const nsACString &aStr, 
 2659:                        PRUint32 aFlags, nsACString &aResult)
  730: {
 2659:   aResult.Truncate();
19253:   NS_EscapeURL(aStr.BeginReading(), aStr.Length(), 
 2659:                aFlags | esc_AlwaysCopy, aResult);
  730:   return NS_OK;
  730: }
 2659: 
 2659: NS_IMETHODIMP 
 2659: nsIOService::UnescapeString(const nsACString &aStr, 
 2659:                             PRUint32 aFlags, nsACString &aResult)
 2659: {
 2659:   aResult.Truncate();
19253:   NS_UnescapeURL(aStr.BeginReading(), aStr.Length(), 
 2659:                  aFlags | esc_AlwaysCopy, aResult);
 2659:   return NS_OK;
 2659: }
 2659: 
 8603: NS_IMETHODIMP
 8603: nsIOService::ExtractCharsetFromContentType(const nsACString &aTypeHeader,
 8603:                                            nsACString &aCharset,
 8603:                                            PRInt32 *aCharsetStart,
 8603:                                            PRInt32 *aCharsetEnd,
 8603:                                            PRBool *aHadCharset)
 8603: {
 8603:     nsCAutoString ignored;
 8603:     net_ParseContentType(aTypeHeader, ignored, aCharset, aHadCharset,
 8603:                          aCharsetStart, aCharsetEnd);
12421:     if (*aHadCharset && *aCharsetStart == *aCharsetEnd) {
 8603:         *aHadCharset = PR_FALSE;
 8603:     }
 8603:     return NS_OK;
 8603: }
