72073: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
72073: /* ***** BEGIN LICENSE BLOCK *****
72073:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
72073:  *
72073:  * The contents of this file are subject to the Mozilla Public License Version
72073:  * 1.1 (the "License"); you may not use this file except in compliance with
72073:  * the License. You may obtain a copy of the License at
72073:  * http://www.mozilla.org/MPL/
72073:  *
72073:  * Software distributed under the License is distributed on an "AS IS" basis,
72073:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
72073:  * for the specific language governing rights and limitations under the
72073:  * License.
72073:  *
72073:  * The Original Code is JavaScript Engine testing utilities.
72073:  *
72073:  * The Initial Developer of the Original Code is
72073:  * Mozilla Foundation.
72073:  * Portions created by the Initial Developer are Copyright (C) 2007
72073:  * the Initial Developer. All Rights Reserved.
72073:  *
72073:  * Contributor(s): Dave Herman
72073:  *
72073:  * Alternatively, the contents of this file may be used under the terms of
72073:  * either the GNU General Public License Version 2 or later (the "GPL"), or
72073:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
72073:  * in which case the provisions of the GPL or the LGPL are applicable instead
72073:  * of those above. If you wish to allow use of your version of this file only
72073:  * under the terms of either the GPL or the LGPL, and not to allow others to
72073:  * use your version of this file under the terms of the MPL, indicate your
72073:  * decision by deleting the provisions above and replace them with the notice
72073:  * and other provisions required by the GPL or the LGPL. If you do not delete
72073:  * the provisions above, a recipient may use your version of this file under
72073:  * the terms of any one of the MPL, the GPL or the LGPL.
72073:  *
72073:  * ***** END LICENSE BLOCK ***** */
72073: 
72073: 
72073: //-----------------------------------------------------------------------------
72073: var BUGNUMBER = 634472;
72073: var summary = 'contextual restrictions for yield and arguments';
72073: var actual = '';
72073: var expect = '';
72073: 
72073: 
72073: function error(str) {
72073:   let base;
72073:   try {
72073:     // the following line must not be broken up into multiple lines
72073:     base = (function(){try{eval('throw new Error()')}catch(e){return e.lineNumber}})(); eval(str);
72073:     return null;
72073:   } catch (e) {
72073:     e.lineNumber = e.lineNumber - base + 1;
72073:     return e;
72073:   }
72073: }
72073: 
72073: const JSMSG_GENEXP_YIELD     = error("(function(){((yield) for (x in []))})").message;
72073: const JSMSG_GENEXP_ARGUMENTS = error("(function(){(arguments for (x in []))})").message;
72073: const JSMSG_TOP_YIELD        = error("yield").message;
72073: const JSMSG_YIELD_PAREN      = error("(function(){yield, 1})").message;
72073: const JSMSG_GENERIC          = error("(for)").message;
72558: const JSMSG_GENEXP_PAREN     = error("print(1, x for (x in []))").message;
72073: 
72073: const cases = [
72073:   // yield expressions
72073:   { expr: "yield",        top: JSMSG_TOP_YIELD, fun: null,              gen: JSMSG_GENEXP_YIELD, desc: "simple yield" },
72073:   { expr: "yield 1",      top: JSMSG_TOP_YIELD, fun: null,              gen: JSMSG_GENEXP_YIELD, desc: "yield w/ arg" },
72073:   { expr: "1, yield",     top: JSMSG_TOP_YIELD, fun: null,              gen: JSMSG_GENEXP_YIELD, desc: "simple yield at end of list" },
72073:   { expr: "1, yield 2",   top: JSMSG_TOP_YIELD, fun: null,              gen: JSMSG_GENEXP_YIELD, desc: "yield w/ arg at end of list" },
72073:   { expr: "yield, 1",     top: JSMSG_TOP_YIELD, fun: JSMSG_YIELD_PAREN, gen: JSMSG_YIELD_PAREN,  desc: "simple yield in list" },
72073:   { expr: "yield 1, 2",   top: JSMSG_TOP_YIELD, fun: JSMSG_YIELD_PAREN, gen: JSMSG_YIELD_PAREN,  desc: "yield w/ arg in list" },
72073:   { expr: "(yield)",      top: JSMSG_TOP_YIELD, fun: null,              gen: JSMSG_GENEXP_YIELD, desc: "simple yield, parenthesized" },
72073:   { expr: "(yield 1)",    top: JSMSG_TOP_YIELD, fun: null,              gen: JSMSG_GENEXP_YIELD, desc: "yield w/ arg, parenthesized" },
72073:   { expr: "(1, yield)",   top: JSMSG_TOP_YIELD, fun: null,              gen: JSMSG_GENEXP_YIELD, desc: "simple yield at end of list, parenthesized" },
72073:   { expr: "(1, yield 2)", top: JSMSG_TOP_YIELD, fun: null,              gen: JSMSG_GENEXP_YIELD, desc: "yield w/ arg at end of list, parenthesized" },
72073:   { expr: "(yield, 1)",   top: JSMSG_TOP_YIELD, fun: JSMSG_YIELD_PAREN, gen: JSMSG_YIELD_PAREN,  desc: "simple yield in list, parenthesized" },
72073:   { expr: "(yield 1, 2)", top: JSMSG_TOP_YIELD, fun: JSMSG_YIELD_PAREN, gen: JSMSG_YIELD_PAREN,  desc: "yield w/ arg in list, parenthesized" },
72073: 
72073:   // deeply nested yield expressions
72073:   { expr: "((((yield))))",   top: JSMSG_TOP_YIELD, fun: null, gen: JSMSG_GENEXP_YIELD, desc: "deeply nested yield" },
72073:   { expr: "((((yield 1))))", top: JSMSG_TOP_YIELD, fun: null, gen: JSMSG_GENEXP_YIELD, desc: "deeply nested yield w/ arg" },
72073: 
72073:   // arguments
72073:   { expr: "arguments",         top: null, fun: null, gen: JSMSG_GENEXP_ARGUMENTS, desc: "simple arguments" },
72073:   { expr: "1, arguments",      top: null, fun: null, gen: JSMSG_GENEXP_ARGUMENTS, desc: "arguments in list" },
72073:   { expr: "(arguments)",       top: null, fun: null, gen: JSMSG_GENEXP_ARGUMENTS, desc: "simple arguments, parenthesized" },
72073:   { expr: "(1, arguments)",    top: null, fun: null, gen: JSMSG_GENEXP_ARGUMENTS, desc: "arguments in list, parenthesized" },
72073:   { expr: "((((arguments))))", top: null, fun: null, gen: JSMSG_GENEXP_ARGUMENTS, desc: "deeply nested arguments" },
72073: 
72073:   // yield in generator expressions
72073:   { expr: "(yield for (x in []))",           top: JSMSG_TOP_YIELD, fun: JSMSG_GENERIC,      gen: JSMSG_GENERIC,      desc: "simple yield in genexp" },
72073:   { expr: "(yield 1 for (x in []))",         top: JSMSG_TOP_YIELD, fun: JSMSG_GENEXP_YIELD, gen: JSMSG_GENEXP_YIELD, desc: "yield w/ arg in genexp" },
72073:   { expr: "(yield, 1 for (x in []))",        top: JSMSG_TOP_YIELD, fun: JSMSG_YIELD_PAREN,  gen: JSMSG_YIELD_PAREN,  desc: "simple yield in list in genexp" },
72073:   { expr: "(yield 1, 2 for (x in []))",      top: JSMSG_TOP_YIELD, fun: JSMSG_YIELD_PAREN,  gen: JSMSG_YIELD_PAREN,  desc: "yield w/ arg in list in genexp" },
72073:   { expr: "(1, yield for (x in []))",        top: JSMSG_TOP_YIELD, fun: JSMSG_GENERIC,      gen: JSMSG_GENERIC,      desc: "simple yield at end of list in genexp" },
72565:   { expr: "(1, yield 2 for (x in []))",      top: JSMSG_TOP_YIELD, fun: { simple: JSMSG_GENEXP_YIELD, call: JSMSG_GENEXP_PAREN },
72565:                                                                                             gen: JSMSG_GENEXP_YIELD, desc: "yield w/ arg at end of list in genexp" },
72073:   { expr: "((yield) for (x in []))",         top: JSMSG_TOP_YIELD, fun: JSMSG_GENEXP_YIELD, gen: JSMSG_GENEXP_YIELD, desc: "simple yield, parenthesized in genexp" },
72073:   { expr: "((yield 1) for (x in []))",       top: JSMSG_TOP_YIELD, fun: JSMSG_GENEXP_YIELD, gen: JSMSG_GENEXP_YIELD, desc: "yield w/ arg, parenthesized in genexp" },
72073:   { expr: "(1, (yield) for (x in []))",      top: JSMSG_TOP_YIELD, fun: JSMSG_GENEXP_YIELD, gen: JSMSG_GENEXP_YIELD, desc: "simple yield, parenthesized in list in genexp" },
72073:   { expr: "(1, (yield 2) for (x in []))",    top: JSMSG_TOP_YIELD, fun: JSMSG_GENEXP_YIELD, gen: JSMSG_GENEXP_YIELD, desc: "yield w/ arg, parenthesized in list in genexp" },
72073:   { expr: "((1, yield) for (x in []))",      top: JSMSG_TOP_YIELD, fun: JSMSG_GENEXP_YIELD, gen: JSMSG_GENEXP_YIELD, desc: "simple yield at end of list, parenthesized in genexp" },
72073:   { expr: "((1, yield 2) for (x in []))",    top: JSMSG_TOP_YIELD, fun: JSMSG_GENEXP_YIELD, gen: JSMSG_GENEXP_YIELD, desc: "yield w/ arg at end of list, parenthesized in genexp" },
72073:   { expr: "(1, (2, yield) for (x in []))",   top: JSMSG_TOP_YIELD, fun: JSMSG_GENEXP_YIELD, gen: JSMSG_GENEXP_YIELD, desc: "simple yield at end of list, parenthesized in list in genexp" },
72073:   { expr: "(1, (2, yield 3) for (x in []))", top: JSMSG_TOP_YIELD, fun: JSMSG_GENEXP_YIELD, gen: JSMSG_GENEXP_YIELD, desc: "yield w/ arg at end of list, parenthesized in list in genexp" },
72073:   { expr: "((yield, 1) for (x in []))",      top: JSMSG_TOP_YIELD, fun: JSMSG_YIELD_PAREN,  gen: JSMSG_YIELD_PAREN,  desc: "simple yield in list, parenthesized in genexp" },
72073:   { expr: "((yield 1, 2) for (x in []))",    top: JSMSG_TOP_YIELD, fun: JSMSG_YIELD_PAREN,  gen: JSMSG_YIELD_PAREN,  desc: "yield w/ arg in list, parenthesized in genexp" },
72073:   { expr: "(1, (yield, 2) for (x in []))",   top: JSMSG_TOP_YIELD, fun: JSMSG_YIELD_PAREN,  gen: JSMSG_YIELD_PAREN,  desc: "simple yield in list, parenthesized in list in genexp" },
72073:   { expr: "(1, (yield 2, 3) for (x in []))", top: JSMSG_TOP_YIELD, fun: JSMSG_YIELD_PAREN,  gen: JSMSG_YIELD_PAREN,  desc: "yield w/ arg in list, parenthesized in list in genexp" },
72073: 
72073:   // deeply nested yield in generator expressions
72073:   { expr: "((((1, yield 2))) for (x in []))",               top: JSMSG_TOP_YIELD, fun: JSMSG_GENEXP_YIELD, gen: JSMSG_GENEXP_YIELD, desc: "deeply nested yield in genexp" },
72073:   { expr: "((((1, yield 2)) for (x in [])) for (y in []))", top: JSMSG_TOP_YIELD, fun: JSMSG_GENEXP_YIELD, gen: JSMSG_GENEXP_YIELD, desc: "deeply nested yield in multiple genexps" },
72073: 
72073:   // arguments in generator expressions
72073:   { expr: "(arguments for (x in []))",         top: JSMSG_GENEXP_ARGUMENTS, fun: JSMSG_GENEXP_ARGUMENTS, gen: JSMSG_GENEXP_ARGUMENTS, desc: "simple arguments in genexp" },
72073:   { expr: "(1, arguments for (x in []))",      top: JSMSG_GENEXP_ARGUMENTS, fun: JSMSG_GENEXP_ARGUMENTS, gen: JSMSG_GENEXP_ARGUMENTS, desc: "arguments in list in genexp" },
72073:   { expr: "((arguments) for (x in []))",       top: JSMSG_GENEXP_ARGUMENTS, fun: JSMSG_GENEXP_ARGUMENTS, gen: JSMSG_GENEXP_ARGUMENTS, desc: "arguments, parenthesized in genexp" },
72073:   { expr: "(1, (arguments) for (x in []))",    top: JSMSG_GENEXP_ARGUMENTS, fun: JSMSG_GENEXP_ARGUMENTS, gen: JSMSG_GENEXP_ARGUMENTS, desc: "arguments, parenthesized in list in genexp" },
72073:   { expr: "((1, arguments) for (x in []))",    top: JSMSG_GENEXP_ARGUMENTS, fun: JSMSG_GENEXP_ARGUMENTS, gen: JSMSG_GENEXP_ARGUMENTS, desc: "arguments in list, parenthesized in genexp" },
72073:   { expr: "(1, (2, arguments) for (x in []))", top: JSMSG_GENEXP_ARGUMENTS, fun: JSMSG_GENEXP_ARGUMENTS, gen: JSMSG_GENEXP_ARGUMENTS, desc: "arguments in list, parenthesized in list in genexp" },
72073: 
72073:   // deeply nested arguments in generator expressions
72073:   { expr: "((((1, arguments))) for (x in []))",               top: JSMSG_GENEXP_ARGUMENTS, fun: JSMSG_GENEXP_ARGUMENTS, gen: JSMSG_GENEXP_ARGUMENTS, desc: "deeply nested arguments in genexp" },
72073:   { expr: "((((1, arguments)) for (x in [])) for (y in []))", top: JSMSG_GENEXP_ARGUMENTS, fun: JSMSG_GENEXP_ARGUMENTS, gen: JSMSG_GENEXP_ARGUMENTS, desc: "deeply nested arguments in multiple genexps" },
72073: 
72073:   // legal yield/arguments in nested function
72073:   { expr: "((function() { yield }) for (x in []))",           top: null, fun: null, gen: null, desc: "legal yield in nested function" },
72073:   { expr: "((function() { arguments }) for (x in []))",       top: null, fun: null, gen: null, desc: "legal arguments in nested function" },
72073:   { expr: "((function() arguments) for (x in []))",           top: null, fun: null, gen: null, desc: "legal arguments in nested expression-closure" }
72073: ];
72073: 
72073: //-----------------------------------------------------------------------------
72073: test();
72073: //-----------------------------------------------------------------------------
72073: 
72073: function splitKeyword(str) {
72073:   return str.
72073:          replace(/yield for/, '\nyield for\n').
72073:          replace(/yield ([0-9])/, '\nyield $1\n').
72073:          replace(/yield([^ ]|$)/, '\nyield\n$1').
72073:          replace(/arguments/, '\narguments\n');
72073: }
72073: 
72073: function expectError1(err, ctx, msg) {
72073:   reportCompare('object', typeof err,     'exn for: ' + msg);
72073:   reportCompare(ctx,      err.message,    'exn message for: ' + msg);
72073:   reportCompare(2,        err.lineNumber, 'exn token for: ' + msg);
72073: }
72073: 
72558: function expectError(expr, call, wrapCtx, expect, msg) {
72558:   let exps = (typeof expect === "string")
72558:            ? { simple: expect, call: expect }
72558:            : expect;
72558:   expectError1(error(wrapCtx(expr)), exps.simple, msg);
72073:   if (call)
72558:     expectError1(error(wrapCtx(call)), exps.call, 'call argument in ' + msg);
72073: }
72073: 
72073: function expectSuccess(err, msg) {
72073:   reportCompare(null, err, 'parse: ' + msg);
72073: }
72073: 
72073: function atTop(str) { return str }
72073: function inFun(str) { return '(function(){' + str + '})' }
72073: function inGen(str) { return '(y for (y in ' + str + '))' }
72073: 
72073: function test()
72073: {
72073:   enterFunc ('test');
72073:   printBugNumber(BUGNUMBER);
72073:   printStatus (summary);
72073: 
72073:   for (let i = 0, len = cases.length; i < len; i++) {
72073:     let {expr, top, fun, gen, desc} = cases[i];
72073: 
72073:     let call = (expr[0] === "(") ? ("print" + expr) : null;
72073: 
72073:     expr = splitKeyword(expr);
72073:     if (call)
72073:       call = splitKeyword(call);
72073: 
72073:     if (top)
72073:       expectError(expr, call, atTop, top, 'top-level context, ' + desc);
72073:     else
72073:       expectSuccess(error(expr), 'top-level context, ' + desc);
72073: 
72073:     if (fun)
72073:       expectError(expr, call, inFun, fun, 'function context, ' + desc);
72073:     else
72073:       expectSuccess(error(inFun(expr)), 'function context, ' + desc);
72073: 
72073:     if (gen)
72073:       expectError(expr, call, inGen, gen, 'genexp context, ' + desc);
72073:     else
72073:       expectSuccess(error(inGen(expr)), 'genexp context, ' + desc);
72073:   }
72073: 
72073:   exitFunc ('test');
72073: }
