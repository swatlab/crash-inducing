 3863: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 3863: /* ***** BEGIN LICENSE BLOCK *****
 3863:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 3863:  *
 3863:  * The contents of this file are subject to the Mozilla Public License Version
 3863:  * 1.1 (the "License"); you may not use this file except in compliance with
 3863:  * the License. You may obtain a copy of the License at
 3863:  * http://www.mozilla.org/MPL/
 3863:  *
 3863:  * Software distributed under the License is distributed on an "AS IS" basis,
 3863:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 3863:  * for the specific language governing rights and limitations under the
 3863:  * License.
 3863:  *
 4389:  * The Original Code is Mozilla Breakpad integration
 3863:  *
 3863:  * The Initial Developer of the Original Code is
 3863:  * Ted Mielczarek <ted.mielczarek@gmail.com>
 3863:  * Portions created by the Initial Developer are Copyright (C) 2006
 3863:  * the Initial Developer. All Rights Reserved.
 3863:  *
 3863:  * Contributor(s):
18492:  *  Josh Aas <josh@mozilla.com>
38030:  *  Justin Dolske <dolske@mozilla.com>
 3863:  *
 3863:  * Alternatively, the contents of this file may be used under the terms of
 3863:  * either the GNU General Public License Version 2 or later (the "GPL"), or
 3863:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 3863:  * in which case the provisions of the GPL or the LGPL are applicable instead
 3863:  * of those above. If you wish to allow use of your version of this file only
 3863:  * under the terms of either the GPL or the LGPL, and not to allow others to
 3863:  * use your version of this file under the terms of the MPL, indicate your
 3863:  * decision by deleting the provisions above and replace them with the notice
 3863:  * and other provisions required by the GPL or the LGPL. If you do not delete
 3863:  * the provisions above, a recipient may use your version of this file under
 3863:  * the terms of any one of the MPL, the GPL or the LGPL.
 3863:  *
 3863:  * ***** END LICENSE BLOCK ***** */
 3863: 
 4389: #include "nsExceptionHandler.h"
 3863: 
 3879: #if defined(XP_WIN32)
 3863: #ifdef WIN32_LEAN_AND_MEAN
 3863: #undef WIN32_LEAN_AND_MEAN
 3863: #endif
 3863: 
38030: #include "nsIWindowsRegKey.h"
37204: #if defined(MOZ_IPC)
37203: #  include "client/windows/crash_generation/crash_generation_server.h"
37204: #endif
 3863: #include "client/windows/handler/exception_handler.h"
37203: #include <DbgHelp.h>
 3863: #include <string.h>
 3879: #elif defined(XP_MACOSX)
 3879: #include "client/mac/handler/exception_handler.h"
 3879: #include <string>
 3879: #include <Carbon/Carbon.h>
 3879: #include <fcntl.h>
 3916: #include <sys/types.h>
 3916: #include <unistd.h>
 3908: #include "mac_utils.h"
 3892: #elif defined(XP_LINUX)
38030: #include "nsDirectoryServiceUtils.h"
38030: #include "nsDirectoryServiceDefs.h"
38030: #include "nsIINIParser.h"
37204: #if defined(MOZ_IPC)
37382: #  include "client/linux/crash_generation/client_info.h"
37203: #  include "client/linux/crash_generation/crash_generation_server.h"
37204: #endif
 3892: #include "client/linux/handler/exception_handler.h"
 3892: #include <fcntl.h>
 3916: #include <sys/types.h>
 3916: #include <unistd.h>
13348: #elif defined(XP_SOLARIS)
13348: #include "client/solaris/handler/exception_handler.h"
13348: #include <fcntl.h>
13348: #include <sys/types.h>
13348: #include <unistd.h>
 3866: #else
 3866: #error "Not yet implemented for this platform"
 3879: #endif // defined(XP_WIN32)
 3866: 
 3863: #include <stdlib.h>
 3934: #include <time.h>
 3863: #include <prenv.h>
 3927: #include <prio.h>
 7861: #include <prmem.h>
37382: #include "mozilla/Mutex.h"
 3863: #include "nsDebug.h"
 3866: #include "nsCRT.h"
 3866: #include "nsILocalFile.h"
37382: #include "nsIFileStreams.h"
 3872: #include "nsDataHashtable.h"
37382: #include "nsInterfaceHashtable.h"
37208: #include "prprf.h"
38030: #include "nsIXULAppInfo.h"
 3863: 
37204: #if defined(MOZ_IPC)
37203: using google_breakpad::CrashGenerationServer;
37203: using google_breakpad::ClientInfo;
37207: 
37382: using mozilla::Mutex;
37382: using mozilla::MutexAutoLock;
37204: #endif
37203: 
 3879: namespace CrashReporter {
 3879: 
 3871: #ifdef XP_WIN32
 3879: typedef wchar_t XP_CHAR;
 3879: #define CONVERT_UTF16_TO_XP_CHAR(x) x
26867: #define CONVERT_XP_CHAR_TO_UTF16(x) x
 3879: #define XP_STRLEN(x) wcslen(x)
 3871: #define CRASH_REPORTER_FILENAME "crashreporter.exe"
 3871: #define PATH_SEPARATOR "\\"
 3879: #define XP_PATH_SEPARATOR L"\\"
 3879: // sort of arbitrary, but MAX_PATH is kinda small
 3879: #define XP_PATH_MAX 4096
 3879: // "<reporter path>" "<minidump path>"
 3879: #define CMDLINE_SIZE ((XP_PATH_MAX * 2) + 6)
 5437: #ifdef _USE_32BIT_TIME_T
 5437: #define XP_TTOA(time, buffer, base) ltoa(time, buffer, base)
 5437: #else
 5437: #define XP_TTOA(time, buffer, base) _i64toa(time, buffer, base)
 5437: #endif
 3871: #else
 3879: typedef char XP_CHAR;
 3879: #define CONVERT_UTF16_TO_XP_CHAR(x) NS_ConvertUTF16toUTF8(x)
26867: #define CONVERT_XP_CHAR_TO_UTF16(x) NS_ConvertUTF8toUTF16(x)
 3879: #define XP_STRLEN(x) strlen(x)
 3871: #define CRASH_REPORTER_FILENAME "crashreporter"
 3871: #define PATH_SEPARATOR "/"
 3879: #define XP_PATH_SEPARATOR "/"
 3879: #define XP_PATH_MAX PATH_MAX
 5437: #define XP_TTOA(time, buffer, base) sprintf(buffer, "%ld", time)
 3879: #endif // XP_WIN32
 3871: 
 3879: static const XP_CHAR dumpFileExtension[] = {'.', 'd', 'm', 'p',
 3879:                                             '\0'}; // .dmp
 3879: static const XP_CHAR extraFileExtension[] = {'.', 'e', 'x', 't',
 3866:                                              'r', 'a', '\0'}; // .extra
 3866: 
 3869: static google_breakpad::ExceptionHandler* gExceptionHandler = nsnull;
 3866: 
 3879: static XP_CHAR* crashReporterPath;
 3866: 
 3881: // if this is false, we don't launch the crash reporter
 3881: static bool doReport = true;
 3881: 
 3908: // if this is true, we pass the exception on to the OS crash reporter
 3908: static bool showOSCrashReporter = false;
 3908: 
 5437: // The time of the last recorded crash, as a time_t value.
 5437: static time_t lastCrashTime = 0;
 5437: // The pathname of a file to store the crash time in
 5437: static XP_CHAR lastCrashTimeFilename[XP_PATH_MAX] = {0};
 5437: 
 5437: // these are just here for readability
 5437: static const char kCrashTimeParameter[] = "CrashTime=";
 5437: static const int kCrashTimeParameterLen = sizeof(kCrashTimeParameter)-1;
 5437: 
 5437: static const char kTimeSinceLastCrashParameter[] = "SecondsSinceLastCrash=";
 5437: static const int kTimeSinceLastCrashParameterLen =
 5437:                                      sizeof(kTimeSinceLastCrashParameter)-1;
 5437: 
 3866: // this holds additional data sent via the API
 3872: static nsDataHashtable<nsCStringHashKey,nsCString>* crashReporterAPIData_Hash;
 3871: static nsCString* crashReporterAPIData = nsnull;
16248: static nsCString* notesField = nsnull;
 3866: 
37204: #if defined(MOZ_IPC)
37203: // OOP crash reporting
37203: static CrashGenerationServer* crashServer; // chrome process has this
37203: 
37203: #  if defined(XP_WIN)
37203: // If crash reporting is disabled, we hand out this "null" pipe to the
37203: // child process and don't attempt to connect to a parent server.
37203: static const char kNullNotifyPipe[] = "-";
37208: static char* childCrashNotifyPipe;
37203: 
37203: #  elif defined(XP_LINUX)
37203: static int serverSocketFd = -1;
37203: static int clientSocketFd = -1;
37203: static const int kMagicChildCrashReportFd = 42;
37203: #  endif
37382: 
37382: // |dumpMapLock| must protect all access to |pidToMinidump|.
37382: static Mutex* dumpMapLock;
37382: typedef nsInterfaceHashtable<nsUint32HashKey, nsIFile> ChildMinidumpMap;
37382: static ChildMinidumpMap* pidToMinidump;
37382: 
37204: #endif  // MOZ_IPC
37203: 
 3879: static XP_CHAR*
 3879: Concat(XP_CHAR* str, const XP_CHAR* toAppend, int* size)
 3879: {
 3879:   int appendLen = XP_STRLEN(toAppend);
 3879:   if (appendLen >= *size) appendLen = *size - 1;
 3879: 
 3879:   memcpy(str, toAppend, appendLen * sizeof(XP_CHAR));
 3879:   str += appendLen;
 3879:   *str = '\0';
 3879:   *size -= appendLen;
 3879: 
 3879:   return str;
 3879: }
 3879: 
 3879: bool MinidumpCallback(const XP_CHAR* dump_path,
 3879:                       const XP_CHAR* minidump_id,
 3869:                       void* context,
 3879: #ifdef XP_WIN32
 3869:                       EXCEPTION_POINTERS* exinfo,
 3869:                       MDRawAssertionInfo* assertion,
 3879: #endif
 3869:                       bool succeeded)
 3863: {
 3908:   bool returnValue = showOSCrashReporter ? false : succeeded;
 3894: 
 3879:   XP_CHAR minidumpPath[XP_PATH_MAX];
 3879:   int size = XP_PATH_MAX;
 3879:   XP_CHAR* p = Concat(minidumpPath, dump_path, &size);
 3879:   p = Concat(p, XP_PATH_SEPARATOR, &size);
 3879:   p = Concat(p, minidump_id, &size);
 3879:   Concat(p, dumpFileExtension, &size);
 3866: 
 3879:   XP_CHAR extraDataPath[XP_PATH_MAX];
 3879:   size = XP_PATH_MAX;
 3879:   p = Concat(extraDataPath, dump_path, &size);
 3879:   p = Concat(p, XP_PATH_SEPARATOR, &size);
 3879:   p = Concat(p, minidump_id, &size);
 3879:   Concat(p, extraFileExtension, &size);
 3866: 
 5437:   // calculate time since last crash (if possible), and store
 5437:   // the time of this crash.
 5437:   time_t crashTime = time(NULL);
 5437:   time_t timeSinceLastCrash = 0;
 5437:   // stringified versions of the above
 5437:   char crashTimeString[32];
 5437:   int crashTimeStringLen = 0;
 5437:   char timeSinceLastCrashString[32];
 5437:   int timeSinceLastCrashStringLen = 0;
 5437: 
 5437:   XP_TTOA(crashTime, crashTimeString, 10);
 5437:   crashTimeStringLen = strlen(crashTimeString);
 5437:   if (lastCrashTime != 0) {
 5437:     timeSinceLastCrash = crashTime - lastCrashTime;
 5437:     XP_TTOA(timeSinceLastCrash, timeSinceLastCrashString, 10);
 5437:     timeSinceLastCrashStringLen = strlen(timeSinceLastCrashString);
 5437:   }
 5437:   // write crash time to file
 5437:   if (lastCrashTimeFilename[0] != 0) {
 5437: #if defined(XP_WIN32)
 5437:     HANDLE hFile = CreateFile(lastCrashTimeFilename, GENERIC_WRITE, 0,
 5437:                               NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
 5437:                               NULL);
 5437:     if(hFile != INVALID_HANDLE_VALUE) {
 5437:       DWORD nBytes;
 5437:       WriteFile(hFile, crashTimeString, crashTimeStringLen, &nBytes, NULL);
 5437:       CloseHandle(hFile);
 5437:     }
 5437: #elif defined(XP_UNIX)
 5437:     int fd = open(lastCrashTimeFilename,
 5437:                   O_WRONLY | O_CREAT | O_TRUNC,
 5437:                   0600);
 5437:     if (fd != -1) {
37382:       ssize_t ignored = write(fd, crashTimeString, crashTimeStringLen);
37382:       (void)ignored;
 5437:       close(fd);
 5437:     }
 5437: #endif
 5437:   }
 5437: 
 5437: #if defined(XP_WIN32)
 3879:   XP_CHAR cmdLine[CMDLINE_SIZE];
 3879:   size = CMDLINE_SIZE;
 3879:   p = Concat(cmdLine, L"\"", &size);
 3879:   p = Concat(p, crashReporterPath, &size);
 3879:   p = Concat(p, L"\" \"", &size);
 3879:   p = Concat(p, minidumpPath, &size);
 3879:   Concat(p, L"\"", &size);
 3879: 
 3871:   if (!crashReporterAPIData->IsEmpty()) {
 3866:     // write out API data
 3879:     HANDLE hFile = CreateFile(extraDataPath, GENERIC_WRITE, 0,
 3866:                               NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
 3866:                               NULL);
 3866:     if(hFile != INVALID_HANDLE_VALUE) {
 3866:       DWORD nBytes;
 3871:       WriteFile(hFile, crashReporterAPIData->get(),
 3871:                 crashReporterAPIData->Length(), &nBytes, NULL);
 5437:       WriteFile(hFile, kCrashTimeParameter, kCrashTimeParameterLen,
 5437:                 &nBytes, NULL);
 5437:       WriteFile(hFile, crashTimeString, crashTimeStringLen, &nBytes, NULL);
 5437:       WriteFile(hFile, "\n", 1, &nBytes, NULL);
 5437:       if (timeSinceLastCrash != 0) {
 5437:         WriteFile(hFile, kTimeSinceLastCrashParameter,
 5437:                   kTimeSinceLastCrashParameterLen, &nBytes, NULL);
 5437:         WriteFile(hFile, timeSinceLastCrashString, timeSinceLastCrashStringLen,
 5437:                   &nBytes, NULL);
 5437:         WriteFile(hFile, "\n", 1, &nBytes, NULL);
 5437:       }
 3866:       CloseHandle(hFile);
 3866:     }
 3866:   }
 3866: 
 3881:   if (!doReport) {
 3908:     return returnValue;
 3881:   }
 3881: 
 3863:   STARTUPINFO si;
 3863:   PROCESS_INFORMATION pi;
 3863: 
 3863:   ZeroMemory(&si, sizeof(si));
 3863:   si.cb = sizeof(si);
 3863:   si.dwFlags = STARTF_USESHOWWINDOW;
 3863:   si.wShowWindow = SW_SHOWNORMAL;
 3863:   ZeroMemory(&pi, sizeof(pi));
 3863: 
 3879:   if (CreateProcess(NULL, (LPWSTR)cmdLine, NULL, NULL, FALSE, 0,
 3866:                     NULL, NULL, &si, &pi)) {
 3863:     CloseHandle( pi.hProcess );
 3863:     CloseHandle( pi.hThread );
 3863:   }
 3863:   // we're not really in a position to do anything if the CreateProcess fails
 3863:   TerminateProcess(GetCurrentProcess(), 1);
 3879: #elif defined(XP_UNIX)
 3879:   if (!crashReporterAPIData->IsEmpty()) {
 3879:     // write out API data
 3879:     int fd = open(extraDataPath,
 3879:                   O_WRONLY | O_CREAT | O_TRUNC,
 3879:                   0666);
 3879: 
 3879:     if (fd != -1) {
 3879:       // not much we can do in case of error
37382:       ssize_t ignored = write(fd, crashReporterAPIData->get(),
37382:                               crashReporterAPIData->Length());
37382:       ignored = write(fd, kCrashTimeParameter, kCrashTimeParameterLen);
37382:       ignored = write(fd, crashTimeString, crashTimeStringLen);
37382:       ignored = write(fd, "\n", 1);
 5437:       if (timeSinceLastCrash != 0) {
37382:         ignored = write(fd, kTimeSinceLastCrashParameter,
37382:                         kTimeSinceLastCrashParameterLen);
37382:         ignored = write(fd, timeSinceLastCrashString,
37382:                         timeSinceLastCrashStringLen);
37382:         ignored = write(fd, "\n", 1);
 5437:       }
 3879:       close (fd);
 3879:     }
 3863:   }
 3863: 
 3881:   if (!doReport) {
 3908:     return returnValue;
 3881:   }
 3881: 
 3879:   pid_t pid = fork();
 3866: 
 3879:   if (pid == -1)
 3879:     return false;
 3879:   else if (pid == 0) {
 8842:     // need to clobber this, as libcurl might load NSS,
 8842:     // and we want it to load the system NSS.
 8842:     unsetenv("LD_LIBRARY_PATH");
 3879:     (void) execl(crashReporterPath,
 3879:                  crashReporterPath, minidumpPath, (char*)0);
 3879:     _exit(1);
 3879:   }
 3879: #endif
 3866: 
 3908:  return returnValue;
 3866: }
 3866: 
37103: #ifdef XP_WIN
37103: /**
37103:  * Filters out floating point exceptions which are handled by nsSigHandlers.cpp
37103:  * and should not be handled as crashes.
37103:  */
37103: static bool FPEFilter(void* context, EXCEPTION_POINTERS* exinfo,
37103:                       MDRawAssertionInfo* assertion)
37103: {
37103:   PEXCEPTION_RECORD e = (PEXCEPTION_RECORD)exinfo->ExceptionRecord;
37103:   switch (e->ExceptionCode) {
37103:     case STATUS_FLOAT_DENORMAL_OPERAND:
37103:     case STATUS_FLOAT_DIVIDE_BY_ZERO:
37103:     case STATUS_FLOAT_INEXACT_RESULT:
37103:     case STATUS_FLOAT_INVALID_OPERATION:
37103:     case STATUS_FLOAT_OVERFLOW:
37103:     case STATUS_FLOAT_STACK_CHECK:
37103:     case STATUS_FLOAT_UNDERFLOW:
37103:     case STATUS_FLOAT_MULTIPLE_FAULTS:
37103:     case STATUS_FLOAT_MULTIPLE_TRAPS:
37103:       return false; // Don't write minidump, continue exception search
37103:   }
37103:   return true;
37103: }
37103: #endif // XP_WIN
37103: 
 3883: nsresult SetExceptionHandler(nsILocalFile* aXREDirectory,
26867:                              bool force/*=false*/)
 3866: {
 3866:   nsresult rv;
 3866: 
 3866:   if (gExceptionHandler)
 3863:     return NS_ERROR_ALREADY_INITIALIZED;
 3863: 
 3912:   const char *envvar = PR_GetEnv("MOZ_CRASHREPORTER_DISABLE");
26867:   if (envvar && *envvar && !force)
 3912:     return NS_OK;
 3912: 
 3881:   // this environment variable prevents us from launching
 3881:   // the crash reporter client
 3912:   envvar = PR_GetEnv("MOZ_CRASHREPORTER_NO_REPORT");
 3912:   if (envvar && *envvar)
 3881:     doReport = false;
 3881: 
 3871:   // allocate our strings
 3871:   crashReporterAPIData = new nsCString();
 3871:   NS_ENSURE_TRUE(crashReporterAPIData, NS_ERROR_OUT_OF_MEMORY);
 3871: 
 3872:   crashReporterAPIData_Hash =
 3872:     new nsDataHashtable<nsCStringHashKey,nsCString>();
 3872:   NS_ENSURE_TRUE(crashReporterAPIData_Hash, NS_ERROR_OUT_OF_MEMORY);
 3872: 
 3872:   rv = crashReporterAPIData_Hash->Init();
 3872:   NS_ENSURE_SUCCESS(rv, rv);
 3872: 
16248:   notesField = new nsCString();
16248:   NS_ENSURE_TRUE(notesField, NS_ERROR_OUT_OF_MEMORY);
16248: 
 3866:   // locate crashreporter executable
 3893:   nsCOMPtr<nsIFile> exePath;
 3893:   rv = aXREDirectory->Clone(getter_AddRefs(exePath));
 3893:   NS_ENSURE_SUCCESS(rv, rv);
 3866: 
 3894: #if defined(XP_MACOSX)
 3894:   exePath->Append(NS_LITERAL_STRING("crashreporter.app"));
 3894:   exePath->Append(NS_LITERAL_STRING("Contents"));
 3894:   exePath->Append(NS_LITERAL_STRING("MacOS"));
 3894: #endif
 3894: 
 5892:   exePath->AppendNative(NS_LITERAL_CSTRING(CRASH_REPORTER_FILENAME));
 3871: 
 5892: #ifdef XP_WIN32
 3893:   nsString crashReporterPath_temp;
 3893:   exePath->GetPath(crashReporterPath_temp);
 3893: 
 5892:   crashReporterPath = ToNewUnicode(crashReporterPath_temp);
 5892: #else
 5892:   nsCString crashReporterPath_temp;
 5892:   exePath->GetNativePath(crashReporterPath_temp);
 5892: 
 5892:   crashReporterPath = ToNewCString(crashReporterPath_temp);
 5892: #endif
 3866: 
 3866:   // get temp path to use for minidump path
 5892: #if defined(XP_WIN32)
 3866:   nsString tempPath;
 5892: 
 3866:   // first figure out buffer size
 3866:   int pathLen = GetTempPath(0, NULL);
 3866:   if (pathLen == 0)
 3863:     return NS_ERROR_FAILURE;
 3863: 
 3866:   tempPath.SetLength(pathLen);
 3866:   GetTempPath(pathLen, (LPWSTR)tempPath.BeginWriting());
 3879: #elif defined(XP_MACOSX)
 5892:   nsCString tempPath;
 3879:   FSRef fsRef;
 3879:   OSErr err = FSFindFolder(kUserDomain, kTemporaryFolderType,
 3879:                            kCreateFolder, &fsRef);
 3879:   if (err != noErr)
 3879:     return NS_ERROR_FAILURE;
 3879: 
 3880:   char path[PATH_MAX];
 3880:   OSStatus status = FSRefMakePath(&fsRef, (UInt8*)path, PATH_MAX);
 3879:   if (status != noErr)
 3879:     return NS_ERROR_FAILURE;
 5892: 
 5892:   tempPath = path;
 3880: 
 3892: #elif defined(XP_UNIX)
 3892:   // we assume it's always /tmp on unix systems
 5892:   nsCString tempPath = NS_LITERAL_CSTRING("/tmp/");
 3879: #else
 5892: #error "Implement this for your platform"
 3866: #endif
 3866: 
 3883:   // now set the exception handler
 3879:   gExceptionHandler = new google_breakpad::
 5892:     ExceptionHandler(tempPath.get(),
37103: #ifdef XP_WIN
37103:                      FPEFilter,
37103: #else
 3869:                      nsnull,
37103: #endif
 3866:                      MinidumpCallback,
 3863:                      nsnull,
 3924: #if defined(XP_WIN32)
 3924:                      google_breakpad::ExceptionHandler::HANDLER_ALL);
 3924: #else
 3863:                      true);
 3924: #endif
 3863: 
 3866:   if (!gExceptionHandler)
 3863:     return NS_ERROR_OUT_OF_MEMORY;
 3863: 
 9612:   // store application start time
 9612:   char timeString[32];
 9612:   XP_TTOA(time(NULL), timeString, 10);
 9612:   AnnotateCrashReport(NS_LITERAL_CSTRING("StartupTime"),
 9612:                       nsDependentCString(timeString));
 9612: 
 3908: #if defined(XP_MACOSX)
 3908:   // On OS X, many testers like to see the OS crash reporting dialog
 3908:   // since it offers immediate stack traces.  We allow them to set
 3908:   // a default to pass exceptions to the OS handler.
 3908:   showOSCrashReporter = PassToOSCrashReporter();
 3908: #endif
 3908: 
 3863:   return NS_OK;
 3863: }
 3863: 
26867: bool GetEnabled()
26867: {
26867:   return gExceptionHandler != nsnull;
26867: }
26867: 
26867: bool GetMinidumpPath(nsAString& aPath)
26867: {
26867:   if (!gExceptionHandler)
26867:     return false;
26867: 
26867:   aPath = CONVERT_XP_CHAR_TO_UTF16(gExceptionHandler->dump_path().c_str());
26867:   return true;
26867: }
26867: 
 3866: nsresult SetMinidumpPath(const nsAString& aPath)
 3863: {
 3866:   if (!gExceptionHandler)
 3863:     return NS_ERROR_NOT_INITIALIZED;
 3863: 
 3879:   gExceptionHandler->set_dump_path(CONVERT_UTF16_TO_XP_CHAR(aPath).BeginReading());
 3866: 
 3863:   return NS_OK;
 3863: }
 3863: 
 3927: static nsresult
 3927: WriteDataToFile(nsIFile* aFile, const nsACString& data)
 3927: {
 5892:   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(aFile);
 5892:   NS_ENSURE_TRUE(localFile, NS_ERROR_FAILURE);
 5892: 
 5892:   PRFileDesc* fd;
 5892:   nsresult rv = localFile->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE, 00600,
 5892:                                             &fd);
 3927:   NS_ENSURE_SUCCESS(rv, rv);
 3927: 
 3927:   rv = NS_OK;
 3927:   if (PR_Write(fd, data.Data(), data.Length()) == -1) {
 3927:     rv = NS_ERROR_FAILURE;
 3927:   }
 3927:   PR_Close(fd);
 3927:   return rv;
 3927: }
 3927: 
 3927: static nsresult
 3927: GetFileContents(nsIFile* aFile, nsACString& data)
 3927: {
 5892:   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(aFile);
 5892:   NS_ENSURE_TRUE(localFile, NS_ERROR_FAILURE);
 5892: 
 5892:   PRFileDesc* fd;
 5892:   nsresult rv = localFile->OpenNSPRFileDesc(PR_RDONLY, 0, &fd);
 3927:   NS_ENSURE_SUCCESS(rv, rv);
 3927: 
 3927:   rv = NS_OK;
 3927:   PRInt32 filesize = PR_Available(fd);
 3927:   if (filesize <= 0) {
 3927:     rv = NS_ERROR_FILE_NOT_FOUND;
 3927:   }
 3927:   else {
 3927:     data.SetLength(filesize);
 3927:     if (PR_Read(fd, data.BeginWriting(), filesize) == -1) {
 3927:       rv = NS_ERROR_FAILURE;
 3927:     }
 3927:   }
 3927:   PR_Close(fd);
 3927:   return rv;
 3927: }
 3927: 
 3927: // Function typedef for initializing a piece of data that we
 3927: // don't already have.
 3927: typedef nsresult (*InitDataFunc)(nsACString&);
 3927: 
 3927: // Attempt to read aFile's contents into aContents, if aFile
 3927: // does not exist, create it and initialize its contents
 3927: // by calling aInitFunc for the data.
 3927: static nsresult
 5892: GetOrInit(nsIFile* aDir, const nsACString& filename,
 3934:           nsACString& aContents, InitDataFunc aInitFunc)
 3927: {
 3927:   PRBool exists;
 3934: 
 3934:   nsCOMPtr<nsIFile> dataFile;
 3934:   nsresult rv = aDir->Clone(getter_AddRefs(dataFile));
 3934:   NS_ENSURE_SUCCESS(rv, rv);
 3934: 
 5892:   rv = dataFile->AppendNative(filename);
 3934:   NS_ENSURE_SUCCESS(rv, rv);
 3934: 
 3934:   rv = dataFile->Exists(&exists);
 3927:   NS_ENSURE_SUCCESS(rv, rv);
 3927: 
 3927:   if (!exists) {
 5437:     if (aInitFunc) {
 3927:       // get the initial value and write it to the file
 3927:       rv = aInitFunc(aContents);
 3927:       NS_ENSURE_SUCCESS(rv, rv);
 3934:       rv = WriteDataToFile(dataFile, aContents);
 3934:     }
 3934:     else {
 5437:       // didn't pass in an init func
 5437:       rv = NS_ERROR_FAILURE;
 5437:     }
 5437:   }
 5437:   else {
 3934:     // just get the file's contents
 3934:     rv = GetFileContents(dataFile, aContents);
 3927:   }
 3927: 
 3934:   return rv;
 3927: }
 3927: 
 3934: // Init the "install time" data.  We're taking an easy way out here
 3934: // and just setting this to "the time when this version was first run".
 3934: static nsresult
 3934: InitInstallTime(nsACString& aInstallTime)
 3934: {
 3934:   time_t t = time(NULL);
 3934:   char buf[16];
 3934:   sprintf(buf, "%ld", t);
 3934:   aInstallTime = buf;
 3934: 
 3934:   return NS_OK;
 3934: }
 3934: 
 5437: // Annotate the crash report with a Unique User ID and time
 5437: // since install.  Also do some prep work for recording
 5437: // time since last crash, which must be calculated at
 5437: // crash time.
 3927: // If any piece of data doesn't exist, initialize it first.
 3934: nsresult SetupExtraData(nsILocalFile* aAppDataDirectory,
 3934:                         const nsACString& aBuildID)
 3927: {
 5437:   nsCOMPtr<nsIFile> dataDirectory;
 5437:   nsresult rv = aAppDataDirectory->Clone(getter_AddRefs(dataDirectory));
 5437:   NS_ENSURE_SUCCESS(rv, rv);
 5437: 
 5892:   rv = dataDirectory->AppendNative(NS_LITERAL_CSTRING("Crash Reports"));
 3927:   NS_ENSURE_SUCCESS(rv, rv);
 3927: 
 5656:   PRBool exists;
 5656:   rv = dataDirectory->Exists(&exists);
 5656:   NS_ENSURE_SUCCESS(rv, rv);
 5656: 
 5656:   if (!exists) {
 5668:     rv = dataDirectory->Create(nsIFile::DIRECTORY_TYPE, 0700);
 5656:     NS_ENSURE_SUCCESS(rv, rv);
 5656:   }
 5656: 
15508: #if defined(XP_WIN32)
15508:   nsAutoString dataDirEnv(NS_LITERAL_STRING("MOZ_CRASHREPORTER_DATA_DIRECTORY="));
 6338: 
 6338:   nsAutoString dataDirectoryPath;
 6338:   rv = dataDirectory->GetPath(dataDirectoryPath);
 6338:   NS_ENSURE_SUCCESS(rv, rv);
 6338: 
15508:   dataDirEnv.Append(dataDirectoryPath);
15508: 
15508:   _wputenv(dataDirEnv.get());
 6338: #else
15508:   // Save this path in the environment for the crash reporter application.
15508:   nsCAutoString dataDirEnv("MOZ_CRASHREPORTER_DATA_DIRECTORY=");
15508: 
 6338:   nsCAutoString dataDirectoryPath;
 6338:   rv = dataDirectory->GetNativePath(dataDirectoryPath);
 6338:   NS_ENSURE_SUCCESS(rv, rv);
 6338: 
 6338:   dataDirEnv.Append(dataDirectoryPath);
 6338: 
 6338:   char* env = ToNewCString(dataDirEnv);
 6338:   NS_ENSURE_TRUE(env, NS_ERROR_OUT_OF_MEMORY);
 6338: 
 6338:   PR_SetEnv(env);
15508: #endif
 6338: 
 3934:   nsCAutoString data;
 5437:   if(NS_SUCCEEDED(GetOrInit(dataDirectory,
 5892:                             NS_LITERAL_CSTRING("InstallTime") + aBuildID,
 3934:                             data, InitInstallTime)))
 3934:     AnnotateCrashReport(NS_LITERAL_CSTRING("InstallTime"), data);
 3934: 
 5437:   // this is a little different, since we can't init it with anything,
 5437:   // since it's stored at crash time, and we can't annotate the
 5437:   // crash report with the stored value, since we really want
 5437:   // (now - LastCrash), so we just get a value if it exists,
 5437:   // and store it in a time_t value.
 5892:   if(NS_SUCCEEDED(GetOrInit(dataDirectory, NS_LITERAL_CSTRING("LastCrash"),
 5437:                             data, NULL))) {
 5437:     lastCrashTime = (time_t)atol(data.get());
 5437:   }
 5437: 
 5437:   // not really the best place to init this, but I have the path I need here
 5437:   nsCOMPtr<nsIFile> lastCrashFile;
 5437:   rv = dataDirectory->Clone(getter_AddRefs(lastCrashFile));
 5437:   NS_ENSURE_SUCCESS(rv, rv);
 5437: 
 5892:   rv = lastCrashFile->AppendNative(NS_LITERAL_CSTRING("LastCrash"));
 5437:   NS_ENSURE_SUCCESS(rv, rv);
 5437:   memset(lastCrashTimeFilename, 0, sizeof(lastCrashTimeFilename));
 5437: 
 5437: #if defined(XP_WIN32)
 5437:   nsAutoString filename;
 5437:   rv = lastCrashFile->GetPath(filename);
 5437:   NS_ENSURE_SUCCESS(rv, rv);
 5437: 
 5437:   if (filename.Length() < XP_PATH_MAX)
 5437:     wcsncpy(lastCrashTimeFilename, filename.get(), filename.Length());
 5437: #else
 5437:   nsCAutoString filename;
 5437:   rv = lastCrashFile->GetNativePath(filename);
 5437:   NS_ENSURE_SUCCESS(rv, rv);
 5437: 
 5437:   if (filename.Length() < XP_PATH_MAX)
 5437:     strncpy(lastCrashTimeFilename, filename.get(), filename.Length());
 5437: #endif
 5437: 
 3927:   return NS_OK;
 3927: }
 3927: 
37385: static void OOPDeinit();
37385: 
 3866: nsresult UnsetExceptionHandler()
 3863: {
30610:   delete gExceptionHandler;
30610: 
 3871:   // do this here in the unlikely case that we succeeded in allocating
 3871:   // our strings but failed to allocate gExceptionHandler.
 3872:   if (crashReporterAPIData_Hash) {
 3872:     delete crashReporterAPIData_Hash;
 3872:     crashReporterAPIData_Hash = nsnull;
 3872:   }
 7157: 
 7157:   if (crashReporterAPIData) {
 7157:     delete crashReporterAPIData;
 7157:     crashReporterAPIData = nsnull;
 7157:   }
 7157: 
16248:   if (notesField) {
16248:     delete notesField;
16248:     notesField = nsnull;
16248:   }
16248: 
 3879:   if (crashReporterPath) {
 3879:     NS_Free(crashReporterPath);
 3879:     crashReporterPath = nsnull;
 3879:   }
 3871: 
 3866:   if (!gExceptionHandler)
 3863:     return NS_ERROR_NOT_INITIALIZED;
 3863: 
 3866:   gExceptionHandler = nsnull;
 3866: 
37385: #ifdef MOZ_IPC
37385:   OOPDeinit();
37385: #endif
37385: 
 3863:   return NS_OK;
 3863: }
 3866: 
 3866: static void ReplaceChar(nsCString& str, const nsACString& character,
 3866:                         const nsACString& replacement)
 3866: {
 3866:   nsCString::const_iterator start, end;
 3866: 
 3866:   str.BeginReading(start);
 3866:   str.EndReading(end);
 3866: 
 3866:   while (FindInReadable(character, start, end)) {
 3866:     PRInt32 pos = end.size_backward();
 3866:     str.Replace(pos - 1, 1, replacement);
 3866: 
 3866:     str.BeginReading(start);
 3866:     start.advance(pos + replacement.Length() - 1);
 3866:     str.EndReading(end);
 3866:   }
 3866: }
 3866: 
 3866: static PRBool DoFindInReadable(const nsACString& str, const nsACString& value)
 3866: {
 3866:   nsACString::const_iterator start, end;
 3866:   str.BeginReading(start);
 3866:   str.EndReading(end);
 3866: 
 3866:   return FindInReadable(value, start, end);
 3866: }
 3866: 
20261: static PLDHashOperator EnumerateEntries(const nsACString& key,
 3872:                                         nsCString entry,
 3872:                                         void* userData)
 3872: {
 3872:   crashReporterAPIData->Append(key + NS_LITERAL_CSTRING("=") + entry +
 3872:                                NS_LITERAL_CSTRING("\n"));
 3872:   return PL_DHASH_NEXT;
 3872: }
 3872: 
 3866: nsresult AnnotateCrashReport(const nsACString& key, const nsACString& data)
 3866: {
 3866:   if (!gExceptionHandler)
 3866:     return NS_ERROR_NOT_INITIALIZED;
 3866: 
 3866:   if (DoFindInReadable(key, NS_LITERAL_CSTRING("=")) ||
 3866:       DoFindInReadable(key, NS_LITERAL_CSTRING("\n")))
 3866:     return NS_ERROR_INVALID_ARG;
 3866: 
 3870:   if (DoFindInReadable(data, NS_LITERAL_CSTRING("\0")))
 3870:     return NS_ERROR_INVALID_ARG;
 3870: 
 3866:   nsCString escapedData(data);
 3866: 
 3866:   // escape backslashes
 3866:   ReplaceChar(escapedData, NS_LITERAL_CSTRING("\\"),
 3866:               NS_LITERAL_CSTRING("\\\\"));
 3866:   // escape newlines
 3866:   ReplaceChar(escapedData, NS_LITERAL_CSTRING("\n"),
 3866:               NS_LITERAL_CSTRING("\\n"));
 3866: 
 3872:   nsresult rv = crashReporterAPIData_Hash->Put(key, escapedData);
 3872:   NS_ENSURE_SUCCESS(rv, rv);
 3872: 
 3872:   // now rebuild the file contents
 3872:   crashReporterAPIData->Truncate(0);
 3872:   crashReporterAPIData_Hash->EnumerateRead(EnumerateEntries,
 3872:                                            crashReporterAPIData);
 3872: 
 3866:   return NS_OK;
 3866: }
 3866: 
16248: nsresult AppendAppNotesToCrashReport(const nsACString& data)
16248: {
16248:   if (!gExceptionHandler)
16248:     return NS_ERROR_NOT_INITIALIZED;
16248: 
16248:   if (DoFindInReadable(data, NS_LITERAL_CSTRING("\0")))
16248:     return NS_ERROR_INVALID_ARG;
16248: 
16248:   notesField->Append(data);
16248:   return AnnotateCrashReport(NS_LITERAL_CSTRING("Notes"), *notesField);
16248: }
16248: 
16248: // Returns true if found, false if not found.
16248: bool GetAnnotation(const nsACString& key, nsACString& data)
16248: {
16248:   if (!gExceptionHandler)
26867:     return false;
16248: 
16248:   nsCAutoString entry;
16248:   if (!crashReporterAPIData_Hash->Get(key, &entry))
16248:     return false;
16248: 
16248:   data = entry;
16248:   return true;
16248: }
16248: 
26867: bool GetServerURL(nsACString& aServerURL)
26867: {
26867:   if (!gExceptionHandler)
26867:     return false;
26867: 
26867:   return GetAnnotation(NS_LITERAL_CSTRING("ServerURL"), aServerURL);
26867: }
26867: 
26867: nsresult SetServerURL(const nsACString& aServerURL)
26867: {
26867:   // store server URL with the API data
26867:   // the client knows to handle this specially
26867:   return AnnotateCrashReport(NS_LITERAL_CSTRING("ServerURL"),
26867:                              aServerURL);
26867: }
26867: 
 3900: nsresult
 3900: SetRestartArgs(int argc, char** argv)
 3900: {
 3912:   if (!gExceptionHandler)
 3912:     return NS_OK;
 3912: 
 3900:   int i;
 3900:   nsCAutoString envVar;
 3901:   char *env;
 3900:   for (i = 0; i < argc; i++) {
 3900:     envVar = "MOZ_CRASHREPORTER_RESTART_ARG_";
 3900:     envVar.AppendInt(i);
 3900:     envVar += "=";
 9608: #if defined(XP_UNIX) && !defined(XP_MACOSX)
 9608:     // we'd like to run the script around the binary
 9608:     // instead of the binary itself, so remove the -bin
 9608:     // if it exists on the first argument
 9608:     int arg_len = 0;
 9608:     if (i == 0 &&
 9608:         (arg_len = strlen(argv[i])) > 4 &&
 9608:         strcmp(argv[i] + arg_len - 4, "-bin") == 0) {
 9608:       envVar.Append(argv[i], arg_len - 4);
 9608:     } else
 9608: #endif
 9608:     {
 3900:       envVar += argv[i];
 9608:     }
 3901: 
 3901:     // PR_SetEnv() wants the string to be available for the lifetime
 3901:     // of the app, so dup it here
 3901:     env = ToNewCString(envVar);
 3901:     if (!env)
 3901:       return NS_ERROR_OUT_OF_MEMORY;
 3901: 
 3901:     PR_SetEnv(env);
 3900:   }
 3900: 
 3900:   // make sure the arg list is terminated
 3900:   envVar = "MOZ_CRASHREPORTER_RESTART_ARG_";
 3900:   envVar.AppendInt(i);
 3900:   envVar += "=";
 3900: 
 3901:   // PR_SetEnv() wants the string to be available for the lifetime
 3901:   // of the app, so dup it here
 3901:   env = ToNewCString(envVar);
 3901:   if (!env)
 3901:     return NS_ERROR_OUT_OF_MEMORY;
 3901: 
 3901:   PR_SetEnv(env);
 3900: 
 3921:   // make sure we save the info in XUL_APP_FILE for the reporter
 3921:   const char *appfile = PR_GetEnv("XUL_APP_FILE");
 3921:   if (appfile && *appfile) {
 3921:     envVar = "MOZ_CRASHREPORTER_RESTART_XUL_APP_FILE=";
 3921:     envVar += appfile;
 3921:     env = ToNewCString(envVar);
 3921:     PR_SetEnv(env);
 3921:   }
 3921: 
 3900:   return NS_OK;
 3900: }
11440: 
11440: #ifdef XP_WIN32
11440: nsresult WriteMinidumpForException(EXCEPTION_POINTERS* aExceptionInfo)
11440: {
11440:   if (!gExceptionHandler)
11440:     return NS_ERROR_NOT_INITIALIZED;
11440: 
11440:   return gExceptionHandler->WriteMinidumpForException(aExceptionInfo) ? NS_OK : NS_ERROR_FAILURE;
11440: }
11440: #endif
11440: 
18492: #ifdef XP_MACOSX
18492: nsresult AppendObjCExceptionInfoToAppNotes(void *inException)
18492: {
18492:   nsCAutoString excString;
18492:   GetObjCExceptionInfo(inException, excString);
18492:   AppendAppNotesToCrashReport(excString);
18492:   return NS_OK;
18492: }
18492: #endif
18492: 
38030: /*
38030:  * Combined code to get/set the crash reporter submission pref on
38030:  * different platforms.
38030:  */
38030: static nsresult PrefSubmitReports(PRBool* aSubmitReports, bool writePref)
38030: {
38030:   nsresult rv;
38030: #if defined(XP_WIN32)
38030:   /*
38030:    * NOTE! This needs to stay in sync with the preference checking code
38030:    *       in toolkit/crashreporter/client/crashreporter_win.cpp
38030:    */
38030:   nsCOMPtr<nsIXULAppInfo> appinfo =
38030:     do_GetService("@mozilla.org/xre/app-info;1", &rv);
38030:   NS_ENSURE_SUCCESS(rv, rv);
38030: 
38030:   nsCAutoString appVendor, appName;
38030:   rv = appinfo->GetVendor(appVendor);
38030:   NS_ENSURE_SUCCESS(rv, rv);
38030:   rv = appinfo->GetName(appName);
38030:   NS_ENSURE_SUCCESS(rv, rv);
38030: 
38030:   nsCOMPtr<nsIWindowsRegKey> regKey
38030:     (do_CreateInstance("@mozilla.org/windows-registry-key;1", &rv));
38030:   NS_ENSURE_SUCCESS(rv, rv);
38030: 
38030:   nsCAutoString regPath;
38030: 
38030:   regPath.AppendLiteral("Software\\");
38030:   if(!appVendor.IsEmpty()) {
38030:     regPath.Append(appVendor);
38030:     regPath.AppendLiteral("\\");
38030:   }
38030:   regPath.Append(appName);
38030:   regPath.AppendLiteral("\\Crash Reporter");
38030: 
38030:   // If we're saving the pref value, just write it to ROOT_KEY_CURRENT_USER
38030:   // and we're done.
38030:   if (writePref) {
38030:     rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER,
38030:                       NS_ConvertUTF8toUTF16(regPath),
38030:                       nsIWindowsRegKey::ACCESS_SET_VALUE);
38030:     NS_ENSURE_SUCCESS(rv, rv);
38030: 
38030:     PRUint32 value = *aSubmitReports ? 1 : 0;
38030:     rv = regKey->WriteIntValue(NS_LITERAL_STRING("SubmitCrashReport"), value);
38030:     regKey->Close();
38030:     return rv;
38030:   }
38030: 
38030:   // We're reading the pref value, so we need to first look under
38030:   // ROOT_KEY_LOCAL_MACHINE to see if it's set there, and then fall back to
38030:   // ROOT_KEY_CURRENT_USER. If it's not set in either place, the pref defaults
38030:   // to "true".
38030:   PRUint32 value;
38030:   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_LOCAL_MACHINE,
38030:                     NS_ConvertUTF8toUTF16(regPath),
38030:                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
38030:   if (NS_SUCCEEDED(rv)) {
38030:     rv = regKey->ReadIntValue(NS_LITERAL_STRING("SubmitCrashReport"), &value);
38030:     regKey->Close();
38030:     if (NS_SUCCEEDED(rv)) {
38030:       *aSubmitReports = !!value;
38030:       return NS_OK;
38030:     }
38030:   }
38030: 
38030:   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER,
38030:                     NS_ConvertUTF8toUTF16(regPath),
38030:                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
38030:   if (NS_FAILED(rv)) {
38030:     *aSubmitReports = PR_TRUE;
38030:     return NS_OK;
38030:   }
38030:   
38030:   rv = regKey->ReadIntValue(NS_LITERAL_STRING("SubmitCrashReport"), &value);
38030:   // default to true on failure
38030:   if (NS_FAILED(rv)) {
38030:     value = 1;
38030:     rv = NS_OK;
38030:   }
38030:   regKey->Close();
38030: 
38030:   *aSubmitReports = !!value;
38030:   return NS_OK;
38036: #elif defined(XP_MACOSX)
38036:   // TODO: Implement for OSX (bug 542379)
38036:   return NS_ERROR_NOT_IMPLEMENTED;
38030: #elif defined(XP_UNIX)
38030:   /*
38030:    * NOTE! This needs to stay in sync with the preference checking code
38030:    *       in toolkit/crashreporter/client/crashreporter_linux.cpp
38030:    */
38030:   nsCOMPtr<nsIFile> reporterINI;
38030:   rv = NS_GetSpecialDirectory("UAppData", getter_AddRefs(reporterINI));
38030:   NS_ENSURE_SUCCESS(rv, rv);
38030:   reporterINI->AppendNative(NS_LITERAL_CSTRING("Crash Reports"));
38030:   reporterINI->AppendNative(NS_LITERAL_CSTRING("crashreporter.ini"));
38030: 
38030:   PRBool exists;
38030:   rv = reporterINI->Exists(&exists);
38030:   NS_ENSURE_SUCCESS(rv, rv);
38030:   if (!exists) {
38030:     if (!writePref) {
38030:         // If reading the pref, default to true if .ini doesn't exist.
38030:         *aSubmitReports = PR_TRUE;
38030:         return NS_OK;
38030:     }
38030:     // Create the file so the INI processor can write to it.
38030:     rv = reporterINI->Create(nsIFile::NORMAL_FILE_TYPE, 0600);
38030:     NS_ENSURE_SUCCESS(rv, rv);
38030:   }
38030: 
38030:   nsCOMPtr<nsIINIParserFactory> iniFactory =
38030:     do_GetService("@mozilla.org/xpcom/ini-processor-factory;1", &rv);
38030:   NS_ENSURE_SUCCESS(rv, rv);
38030: 
38030:   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(reporterINI);
38030:   NS_ENSURE_TRUE(localFile, NS_ERROR_FAILURE);
38030:   nsCOMPtr<nsIINIParser> iniParser;
38030:   rv = iniFactory->CreateINIParser(localFile,
38030:                                    getter_AddRefs(iniParser));
38030:   NS_ENSURE_SUCCESS(rv, rv);
38030: 
38030:   // If we're writing the pref, just set and we're done.
38030:   if (writePref) {
38030:     nsCOMPtr<nsIINIParserWriter> iniWriter = do_QueryInterface(iniParser);
38030:     NS_ENSURE_TRUE(iniWriter, NS_ERROR_FAILURE);
38030: 
38030:     rv = iniWriter->SetString(NS_LITERAL_CSTRING("Crash Reporter"),
38030:                               NS_LITERAL_CSTRING("SubmitReport"),
38030:                               *aSubmitReports ?  NS_LITERAL_CSTRING("1") :
38030:                                                  NS_LITERAL_CSTRING("0"));
38030:     NS_ENSURE_SUCCESS(rv, rv);
38030:     rv = iniWriter->WriteFile(NULL);
38030:     return rv;
38030:   }
38030:   
38030:   nsCAutoString submitReportValue;
38030:   rv = iniParser->GetString(NS_LITERAL_CSTRING("Crash Reporter"),
38030:                             NS_LITERAL_CSTRING("SubmitReport"),
38030:                             submitReportValue);
38030: 
38030:   // Default to "true" if the pref can't be found.
38030:   if (NS_FAILED(rv))
38030:     *aSubmitReports = PR_TRUE;
38030:   else if (submitReportValue.EqualsASCII("0"))
38030:     *aSubmitReports = PR_FALSE;
38030:   else
38030:     *aSubmitReports = PR_TRUE;
38030: 
38030:   return NS_OK;
38030: #else
38030:   return NS_ERROR_NOT_IMPLEMENTED;
38030: #endif
38030: }
38030: 
38030: nsresult GetSubmitReports(PRBool* aSubmitReports)
38030: {
38030:     return PrefSubmitReports(aSubmitReports, false);
38030: }
38030: 
38030: nsresult SetSubmitReports(PRBool aSubmitReports)
38030: {
38030:     return PrefSubmitReports(&aSubmitReports, true);
38030: }
38030: 
38030: 
37204: #if defined(MOZ_IPC)
37382: static PLDHashOperator EnumerateChildAnnotations(const nsACString& key,
37382:                                                  nsCString entry,
37382:                                                  void* userData)
37382: {
37382:   // blacklist of entries from the parent process that we don't want to
37382:   // submit with the child process
37382:   static const char* kBlacklist[] = {
37382:     "FramePoisonBase",
37382:     "FramePoisonSize",
37382:     "StartupTime",
37382:     "URL"
37382:   };
37382:   static const int kBlacklistLength =
37382:     sizeof(kBlacklist) / sizeof(kBlacklist[0]);
37382: 
37382:   // skip entries in the blacklist
37382:   for (int i = 0; i < kBlacklistLength; i++) {
37382:     if (key.EqualsASCII(kBlacklist[i]))
37382:       return PL_DHASH_NEXT;
37382:   }
37382: 
39301:   PRFileDesc* fd =
39301:     reinterpret_cast<PRFileDesc*>(userData);
39301:   
39301:   PR_Write(fd, key.BeginReading(), key.Length());
39301:   PR_Write(fd, "=", 1);
39301:   PR_Write(fd, entry.BeginReading(), entry.Length());
39301:   PR_Write(fd, "\n", 1);
37382:   return PL_DHASH_NEXT;
37382: }
37382: 
38028: static bool
38028: MoveToPending(nsIFile* dumpFile, nsIFile* extraFile)
38028: {
38028:   nsCOMPtr<nsIProperties> dirSvc
38028:     = do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID);
38028:   if (!dirSvc)
38028:     return false;
38028:   nsCOMPtr<nsILocalFile> pendingDir;
38028:   if (NS_FAILED(dirSvc->Get("UAppData",
38028:                             NS_GET_IID(nsILocalFile),
38028:                             getter_AddRefs(pendingDir))) ||
38028:       NS_FAILED(pendingDir->Append(NS_LITERAL_STRING("Crash Reports"))) ||
38028:       NS_FAILED(pendingDir->Append(NS_LITERAL_STRING("pending"))))
38028:       return false;
38028: 
38028:   return NS_FAILED(dumpFile->MoveTo(pendingDir, EmptyString())) ||
38028:     NS_FAILED(extraFile->MoveTo(pendingDir, EmptyString()));
38028: }
38028: 
37203: static void
37203: OnChildProcessDumpRequested(void* aContext,
37203:                             const ClientInfo* aClientInfo,
37203: #if defined(XP_WIN)
37203:                             const std::wstring*
37203: #else
37203:                             const std::string*
37203: #endif
37203:                               aFilePath)
37203: {
37207:   nsCOMPtr<nsILocalFile> lf;
37382:   PRUint32 pid;
37382: 
37207: #ifdef XP_WIN
37207:   NS_NewLocalFile(nsDependentString(aFilePath->c_str()), PR_FALSE,
37207:                   getter_AddRefs(lf));
37382:   pid = aClientInfo->pid();
37207: #else
37207:   NS_NewNativeLocalFile(nsDependentCString(aFilePath->c_str()), PR_FALSE,
37207:                         getter_AddRefs(lf));
37382:   pid = aClientInfo->pid_;
37207: #endif
37382: 
37382:   // Get an .extra file with the same base name as the .dmp file
39301:   nsCOMPtr<nsIFile> file;
39301:   nsresult rv = lf->Clone(getter_AddRefs(file));
39301:   
37382:   if (NS_FAILED(rv))
37382:     return;
39301:   nsCOMPtr<nsILocalFile> extraFile = do_QueryInterface(file);
37382: 
37382:   nsAutoString leafName;
37382:   rv = extraFile->GetLeafName(leafName);
37382:   if (NS_FAILED(rv))
37382:     return;
37382: 
37382:   leafName.Replace(leafName.Length() - 3, 3,
37382:                    NS_LITERAL_STRING("extra"));
37382:   rv = extraFile->SetLeafName(leafName);
37382:   if (NS_FAILED(rv))
37382:     return;
37382: 
37382:   // Now write out the annotations to it
39301:   PRFileDesc* fd;
39301:   rv = extraFile->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE,
39301:                                    0600, &fd);
37382:   if (NS_FAILED(rv))
37382:     return;
37382:   crashReporterAPIData_Hash->EnumerateRead(EnumerateChildAnnotations,
39301:                                            fd);
37382:   // Add CrashTime to extra data
37382:   time_t crashTime = time(NULL);
37382:   char crashTimeString[32];
37382:   XP_TTOA(crashTime, crashTimeString, 10);
37382: 
39301:   PR_Write(fd, kCrashTimeParameter, kCrashTimeParameterLen);
39301:   PR_Write(fd, crashTimeString, strlen(crashTimeString));
39301:   PR_Write(fd, "\n", 1);
39301:   PR_Close(fd);
37382: 
38028:   bool doReport = true;
38028:   char* e = getenv("MOZ_CRASHREPORTER_NO_REPORT");
38028:   if (e && *e)
38028:     doReport = false;
38028: 
38028:   if (doReport)
38028:     MoveToPending(lf, extraFile);
38028: 
37382:   {
37382:     MutexAutoLock lock(*dumpMapLock);
37382:     pidToMinidump->Put(pid, lf);
37382:   }
38028: }
37203: 
37203: static bool
37203: OOPInitialized()
37203: {
37203:   return crashServer != NULL;
37203: }
37203: 
37203: static void
37203: OOPInit()
37203: {
37203:   NS_ABORT_IF_FALSE(!OOPInitialized(),
37203:                     "OOP crash reporter initialized more than once!");
37203:   NS_ABORT_IF_FALSE(gExceptionHandler != NULL,
37203:                     "attempt to initialize OOP crash reporter before in-process crashreporter!");
37203: 
37203: #if defined(XP_WIN)
37203:   childCrashNotifyPipe =
37208:     PR_smprintf("\\\\.\\pipe\\gecko-crash-server-pipe.%i",
37208:                 static_cast<int>(::GetCurrentProcessId()));
37203: 
37203:   const std::wstring dumpPath = gExceptionHandler->dump_path();
37203:   crashServer = new CrashGenerationServer(
37208:     NS_ConvertASCIItoUTF16(childCrashNotifyPipe).get(),
37203:     NULL,                       // default security attributes
37203:     NULL, NULL,                 // we don't care about process connect here
37203:     OnChildProcessDumpRequested, NULL,
37203:     NULL, NULL,                 // we don't care about process exit here
37203:     true,                       // automatically generate dumps
37203:     &dumpPath);
37203: 
37203: #elif defined(XP_LINUX)
37203:   if (!CrashGenerationServer::CreateReportChannel(&serverSocketFd,
37203:                                                   &clientSocketFd))
37203:     NS_RUNTIMEABORT("can't create crash reporter socketpair()");
37203: 
37203:   const std::string dumpPath = gExceptionHandler->dump_path();
37203:   crashServer = new CrashGenerationServer(
37203:     serverSocketFd,
37203:     OnChildProcessDumpRequested, NULL,
37203:     NULL, NULL,                 // we don't care about process exit here
37203:     true,                       // automatically generate dumps
37203:     &dumpPath);
37203: #endif
37203: 
37203:   if (!crashServer->Start())
37203:     NS_RUNTIMEABORT("can't start crash reporter server()");
37382: 
37382:   pidToMinidump = new ChildMinidumpMap();
37382:   pidToMinidump->Init();
37382: 
37382:   dumpMapLock = new Mutex("CrashReporter::dumpMapLock");
37203: }
37203: 
37385: static void
37385: OOPDeinit()
37385: {
37385:   if (!OOPInitialized()) {
37385:     NS_WARNING("OOPDeinit() without successful OOPInit()");
37385:     return;
37385:   }
37385: 
37385:   delete crashServer;
37385:   crashServer = NULL;
37385: 
37385:   delete dumpMapLock;
37385:   dumpMapLock = NULL;
37385: 
37385:   delete pidToMinidump;
37385:   pidToMinidump = NULL;
37385: 
37385: #if defined(XP_WIN)
37385:   PR_Free(childCrashNotifyPipe);
37385:   childCrashNotifyPipe = NULL;
37385: #endif
37385: }
37385: 
37203: #if defined(XP_WIN)
37203: // Parent-side API for children
37208: const char*
37203: GetChildNotificationPipe()
37203: {
37203:   if (!GetEnabled())
37208:     return kNullNotifyPipe;
37203: 
37203:   if (!OOPInitialized())
37203:     OOPInit();
37203: 
37208:   return childCrashNotifyPipe;
37203: }
37203: 
37203: // Child-side API
37203: bool
37203: SetRemoteExceptionHandler(const nsACString& crashPipe)
37203: {
37203:   // crash reporting is disabled
37203:   if (crashPipe.Equals(kNullNotifyPipe))
37203:     return true;
37203: 
37203:   NS_ABORT_IF_FALSE(!gExceptionHandler, "crash client already init'd");
37203: 
37203:   gExceptionHandler = new google_breakpad::
37203:     ExceptionHandler(L"",
37203:                      NULL,    // no filter callback
37203:                      NULL,    // no minidump callback
37203:                      NULL,    // no callback context
37203:                      google_breakpad::ExceptionHandler::HANDLER_ALL,
37203:                      MiniDumpNormal,
37203:                      NS_ConvertASCIItoUTF16(crashPipe).BeginReading(),
37203:                      NULL);
37203: 
37203:   // we either do remote or nothing, no fallback to regular crash reporting
37203:   return gExceptionHandler->IsOutOfProcess();
37203: }
37203: 
37203: //--------------------------------------------------
37203: #elif defined(XP_UNIX)
37203: 
37203: // Parent-side API for children
37203: bool
37203: CreateNotificationPipeForChild(int* childCrashFd, int* childCrashRemapFd)
37203: {
37203:   if (!GetEnabled()) {
37203:     *childCrashFd = -1;
37203:     *childCrashRemapFd = -1;
37203:     return true;
37203:   }
37203: 
37203:   if (!OOPInitialized())
37203:     OOPInit();
37203: 
37203:   *childCrashFd = clientSocketFd;
37203:   *childCrashRemapFd = kMagicChildCrashReportFd;
37203: 
37203:   return true;
37203: }
37203: 
37203: // Child-side API
37203: bool
37203: SetRemoteExceptionHandler()
37203: {
37203:   NS_ABORT_IF_FALSE(!gExceptionHandler, "crash client already init'd");
37203: 
37203:   gExceptionHandler = new google_breakpad::
37203:     ExceptionHandler("",
37203:                      NULL,    // no filter callback
37203:                      NULL,    // no minidump callback
37203:                      NULL,    // no callback context
37203:                      true,    // install signal handlers
37203:                      kMagicChildCrashReportFd);
37203: 
37203:   // we either do remote or nothing, no fallback to regular crash reporting
37203:   return gExceptionHandler->IsOutOfProcess();
37203: }
37203: 
37204: #endif  // XP_WIN
37203: 
37203: 
37203: bool
37382: GetMinidumpForChild(PRUint32 childPid, nsIFile** dump)
37382: {
37382:   if (!GetEnabled())
37382:     return false;
37382: 
37382:   MutexAutoLock lock(*dumpMapLock);
37382:   return pidToMinidump->Get(childPid, dump);
37382: }
37382: 
37382: bool
37203: UnsetRemoteExceptionHandler()
37203: {
37203:   delete gExceptionHandler;
37203:   gExceptionHandler = NULL;
37203:   return true;
37203: }
37203: 
37204: #endif  // MOZ_IPC
37204: 
 3866: } // namespace CrashReporter
