    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
    1:  *   Makoto Kato  <m_kato@ga2.so-net.ne.jp>
    1:  *   Dainis Jonitis <Dainis_Jonitis@swh-t.lv>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
24836:  *   Ningjie Chen <chenn@email.uc.edu>
29835:  *   Jim Mathies <jmathies@mozilla.com>.
42532:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef Window_h__
    1: #define Window_h__
    1: 
29841: /*
29841:  * nsWindow - Native window management and event handling.
29841:  */
29841: 
    1: #include "nsBaseWidget.h"
    1: #include "nsdefs.h"
40944: #include "nsIdleService.h"
    1: #include "nsToolkit.h"
    1: #include "nsString.h"
14476: #include "nsTArray.h"
29835: #include "gfxWindowsSurface.h"
29835: #include "nsWindowDbg.h"
29506: #include "cairo.h"
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727: #include "gfxD2DSurface.h"
38727: #endif
29506: 
29835: #if !defined(WINCE)
29835: #include "nsWinGesture.h"
29835: #endif
    1: 
29835: #if defined(WINCE)
29835: #include "nsWindowCE.h"
29835: #endif
27961: 
31532: #include "WindowHook.h"
33486: #include "TaskbarWindowPreview.h"
31532: 
    1: #ifdef ACCESSIBILITY
    1: #include "OLEACC.H"
42313: #include "nsAccessible.h"
    1: #endif
    1: 
39718: #if !defined(WINCE)
39718: #include "nsUXThemeData.h"
39718: #endif // !defined(WINCE)
29835: /**
29835:  * Forward class definitions
29835:  */
26874: 
29835: class nsNativeDragTarget;
29835: class nsIRollupListener;
29835: class nsIFile;
29835: class imgIContainer;
18536: 
    1: /**
    1:  * Native WIN32 window wrapper.
    1:  */
    1: 
31124: class nsWindow : public nsBaseWidget
    1: {
31532:   typedef mozilla::widget::WindowHook WindowHook;
33486: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486:   typedef mozilla::widget::TaskbarWindowPreview TaskbarWindowPreview;
33486: #endif
    1: public:
    1:   nsWindow();
    1:   virtual ~nsWindow();
    1: 
 4345:   NS_DECL_ISUPPORTS_INHERITED
    1: 
29835:   friend class nsWindowGfx;
29835: 
29835:   /**
29835:    * nsIWidget interface
29835:    */
    1:   NS_IMETHOD              Create(nsIWidget *aParent,
33013:                                  nsNativeWidget aNativeParent,
23738:                                  const nsIntRect &aRect,
    1:                                  EVENT_CALLBACK aHandleEventFunction,
    1:                                  nsIDeviceContext *aContext,
    1:                                  nsIAppShell *aAppShell = nsnull,
    1:                                  nsIToolkit *aToolkit = nsnull,
    1:                                  nsWidgetInitData *aInitData = nsnull);
    1:   NS_IMETHOD              Destroy();
    1:   NS_IMETHOD              SetParent(nsIWidget *aNewParent);
    1:   virtual nsIWidget*      GetParent(void);
    1:   NS_IMETHOD              Show(PRBool bState);
    1:   NS_IMETHOD              IsVisible(PRBool & aState);
    1:   NS_IMETHOD              ConstrainPosition(PRBool aAllowSlop, PRInt32 *aX, PRInt32 *aY);
    1:   NS_IMETHOD              Move(PRInt32 aX, PRInt32 aY);
    1:   NS_IMETHOD              Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint);
    1:   NS_IMETHOD              Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint);
33506: #if !defined(WINCE)
33506:   NS_IMETHOD              BeginResizeDrag(nsGUIEvent* aEvent, PRInt32 aHorizontal, PRInt32 aVertical);
33506: #endif
29835:   NS_IMETHOD              PlaceBehind(nsTopLevelWidgetZPlacement aPlacement, nsIWidget *aWidget, PRBool aActivate);
29835:   NS_IMETHOD              SetSizeMode(PRInt32 aMode);
    1:   NS_IMETHOD              Enable(PRBool aState);
    1:   NS_IMETHOD              IsEnabled(PRBool *aState);
    1:   NS_IMETHOD              SetFocus(PRBool aRaise);
23738:   NS_IMETHOD              GetBounds(nsIntRect &aRect);
29835:   NS_IMETHOD              GetScreenBounds(nsIntRect &aRect);
23738:   NS_IMETHOD              GetClientBounds(nsIntRect &aRect);
    1:   NS_IMETHOD              SetBackgroundColor(const nscolor &aColor);
    1:   NS_IMETHOD              SetCursor(imgIContainer* aCursor,
    1:                                     PRUint32 aHotspotX, PRUint32 aHotspotY);
29835:   NS_IMETHOD              SetCursor(nsCursor aCursor);
30515:   virtual nsresult        ConfigureChildren(const nsTArray<Configuration>& aConfigurations);
30075:   NS_IMETHOD              MakeFullScreen(PRBool aFullScreen);
    1:   NS_IMETHOD              HideWindowChrome(PRBool aShouldHide);
    1:   NS_IMETHOD              Invalidate(PRBool aIsSynchronous);
23738:   NS_IMETHOD              Invalidate(const nsIntRect & aRect, PRBool aIsSynchronous);
    1:   NS_IMETHOD              Update();
31544:   virtual void            Scroll(const nsIntPoint& aDelta,
31544:                                  const nsTArray<nsIntRect>& aDestRects,
30540:                                  const nsTArray<Configuration>& aReconfigureChildren);
    1:   virtual void*           GetNativeData(PRUint32 aDataType);
29835:   virtual void            FreeNativeData(void * data, PRUint32 aDataType);
    1:   NS_IMETHOD              SetTitle(const nsAString& aTitle);
    1:   NS_IMETHOD              SetIcon(const nsAString& aIconSpec);
25183:   virtual nsIntPoint      WidgetToScreenOffset();
    1:   NS_IMETHOD              DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus);
    1:   NS_IMETHOD              EnableDragDrop(PRBool aEnable);
29835:   NS_IMETHOD              CaptureMouse(PRBool aCapture);
36806:   NS_IMETHOD              CaptureRollupEvents(nsIRollupListener * aListener, nsIMenuRollup * aMenuRollup,
36806:                                               PRBool aDoCapture, PRBool aConsumeRollupEvent);
    1:   NS_IMETHOD              GetAttention(PRInt32 aCycleCount);
27993:   virtual PRBool          HasPendingInputEvent();
40028:   virtual LayerManager*   GetLayerManager();
    1:   gfxASurface             *GetThebesSurface();
30327:   NS_IMETHOD              OnDefaultButtonLoaded(const nsIntRect &aButtonRect);
33016:   NS_IMETHOD              OverrideSystemMouseScrollSpeed(PRInt32 aOriginalDelta, PRBool aIsHorizontal, PRInt32 &aOverriddenDelta);
33016: 
29835:   virtual nsresult        SynthesizeNativeKeyEvent(PRInt32 aNativeKeyboardLayout,
29835:                                                    PRInt32 aNativeKeyCode,
29835:                                                    PRUint32 aModifierFlags,
29835:                                                    const nsAString& aCharacters,
29835:                                                    const nsAString& aUnmodifiedCharacters);
33863:   virtual nsresult        SynthesizeNativeMouseEvent(nsIntPoint aPoint,
33863:                                                      PRUint32 aNativeMessage,
33863:                                                      PRUint32 aModifierFlags);
    1:   NS_IMETHOD              ResetInputState();
    1:   NS_IMETHOD              SetIMEOpenState(PRBool aState);
    1:   NS_IMETHOD              GetIMEOpenState(PRBool* aState);
  539:   NS_IMETHOD              SetIMEEnabled(PRUint32 aState);
  539:   NS_IMETHOD              GetIMEEnabled(PRUint32* aState);
    1:   NS_IMETHOD              CancelIMEComposition();
 2475:   NS_IMETHOD              GetToggledKeyState(PRUint32 aKeyCode, PRBool* aLEDState);
29835: #ifdef MOZ_XUL
29835:   virtual void            SetTransparencyMode(nsTransparencyMode aMode);
29835:   virtual nsTransparencyMode GetTransparencyMode();
39718:   virtual void            UpdatePossiblyTransparentRegion(const nsIntRegion &aDirtyRegion, const nsIntRegion& aPossiblyTransparentRegion);
29835: #endif // MOZ_XUL
24836: #ifdef NS_ENABLE_TSF
24836:   NS_IMETHOD              OnIMEFocusChange(PRBool aFocus);
24836:   NS_IMETHOD              OnIMETextChange(PRUint32 aStart, PRUint32 aOldEnd, PRUint32 aNewEnd);
24836:   NS_IMETHOD              OnIMESelectionChange(void);
24836: #endif // NS_ENABLE_TSF
24836: 
29835:   /**
29835:    * Statics used in other classes
29835:    */
29835:   static PRInt32          GetWindowsVersion();
    1: 
29835:   /**
29835:    * Event helpers
29835:    */
29835:   void                    InitEvent(nsGUIEvent& event, nsIntPoint* aPoint = nsnull);
    1:   virtual PRBool          DispatchMouseEvent(PRUint32 aEventType, WPARAM wParam,
    1:                                              LPARAM lParam,
    1:                                              PRBool aIsContextMenuKey = PR_FALSE,
40485:                                              PRInt16 aButton = nsMouseEvent::eLeftButton,
40485:                                              PRUint16 aInputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_MOUSE);
24836:   virtual PRBool          DispatchWindowEvent(nsGUIEvent* event);
24836:   virtual PRBool          DispatchWindowEvent(nsGUIEvent*event, nsEventStatus &aStatus);
27961:   virtual PRBool          DispatchKeyEvent(PRUint32 aEventType, WORD aCharCode,
27961:                                            const nsTArray<nsAlternativeCharCode>* aAlternativeChars,
27961:                                            UINT aVirtualCharCode, const MSG *aMsg,
27961:                                            const nsModifierKeyState &aModKeyState,
27961:                                            PRUint32 aFlags = 0);
29835:   void                    SuppressBlurEvents(PRBool aSuppress); // Called from nsFilePicker
29835:   PRBool                  BlurEventsSuppressed();
29835: #ifdef ACCESSIBILITY
42313:   nsAccessible* DispatchAccessibleEvent(PRUint32 aEventType);
42313:   nsAccessible* GetRootAccessible();
29835: #endif // ACCESSIBILITY
27961: 
29835:   /**
29835:    * Window utilities
29835:    */
29835:   static void             GlobalMsgWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
29835:   nsWindow*               GetTopLevelWindow(PRBool aStopOnDialogOrPopup);
29835:   static HWND             GetTopLevelHWND(HWND aWnd, PRBool aStopOnDialogOrPopup = PR_FALSE);
29835:   HWND                    GetWindowHandle() { return mWnd; }
29835:   WNDPROC                 GetPrevWindowProc() { return mPrevWndProc; }
31532:   static nsWindow*        GetNSWindowPtr(HWND aWnd);
31532:   WindowHook&             GetWindowHook() { return mWindowHook; }
29835: 
29835:   /**
29835:    * Misc.
29835:    */
32194:   virtual PRBool          AutoErase(HDC dc);
23738:   nsIntPoint*             GetLastPoint() { return &mLastPoint; }
27961:   PRBool                  GetIMEEnabled() { return mIMEEnabled; }
29835:   // needed in nsIMM32Handler.cpp
29835:   PRBool                  PluginHasFocus() { return mIMEEnabled == nsIWidget::IME_STATUS_PLUGIN; }
27961: 
33486: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486:   PRBool HasTaskbarIconBeenCreated() { return mHasTaskbarIconBeenCreated; }
33486:   // Called when either the nsWindow or an nsITaskbarTabPreview receives the noticiation that this window
33486:   // has its icon placed on the taskbar.
33486:   void SetHasTaskbarIconBeenCreated(PRBool created = PR_TRUE) { mHasTaskbarIconBeenCreated = created; }
33486: 
33486:   // Getter/setter for the nsITaskbarWindowPreview for this nsWindow
33486:   already_AddRefed<nsITaskbarWindowPreview> GetTaskbarPreview() {
33486:     nsCOMPtr<nsITaskbarWindowPreview> preview(do_QueryReferent(mTaskbarPreview));
33486:     return preview.forget();
33486:   }
33486:   void SetTaskbarPreview(nsITaskbarWindowPreview *preview) { mTaskbarPreview = do_GetWeakReference(preview); }
33486: #endif
33486: 
    1: protected:
    1: 
29835:   /**
29835:    * Callbacks
29835:    */
29835:   static LRESULT CALLBACK WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
29835:   static BOOL CALLBACK    BroadcastMsgToChildren(HWND aWnd, LPARAM aMsg);
29835:   static BOOL CALLBACK    BroadcastMsg(HWND aTopWindow, LPARAM aMsg);
29835:   static BOOL CALLBACK    DispatchStarvedPaints(HWND aTopWindow, LPARAM aMsg);
    1:   static LRESULT CALLBACK MozSpecialMsgFilter(int code, WPARAM wParam, LPARAM lParam);
    1:   static LRESULT CALLBACK MozSpecialWndProc(int code, WPARAM wParam, LPARAM lParam);
    1:   static LRESULT CALLBACK MozSpecialMouseProc(int code, WPARAM wParam, LPARAM lParam);
    1:   static VOID    CALLBACK HookTimerForPopups( HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime );
    1: 
29835:   /**
29835:    * Window utilities
29835:    */
29835:   static BOOL             SetNSWindowPtr(HWND aWnd, nsWindow * ptr);
29835:   LPARAM                  lParamToScreen(LPARAM lParam);
29835:   LPARAM                  lParamToClient(LPARAM lParam);
29835:   nsWindow*               GetParentWindow(PRBool aIncludeOwner);
29835:   virtual void            SubclassWindow(BOOL bState);
29835:   void                    GetNonClientBounds(nsIntRect &aRect);
29835:   PRBool                  CanTakeFocus();
33529: #if !defined(WINCE)
33529:   static void             InitTrackPointHack();
33529: #endif
    1: 
29835:   /**
29835:    * Event processing helpers
29835:    */
    1:   void                    DispatchPendingEvents();
29835:   PRBool                  DispatchPluginEvent(const MSG &aMsg);
29835:   PRBool                  DispatchFocusToTopLevelWindow(PRUint32 aEventType);
29835:   PRBool                  DispatchFocus(PRUint32 aEventType);
29835:   PRBool                  DispatchStandardEvent(PRUint32 aMsg);
29835:   PRBool                  DispatchCommandEvent(PRUint32 aEventCommand);
29835:   void                    RelayMouseEvent(UINT aMsg, WPARAM wParam, LPARAM lParam);
29835:   void                    RemoveMessageAndDispatchPluginEvent(UINT aFirstMsg, UINT aLastMsg);
29835:   static MSG              InitMSG(UINT aMessage, WPARAM wParam, LPARAM lParam);
27961:   virtual PRBool          ProcessMessage(UINT msg, WPARAM &wParam,
27961:                                          LPARAM &lParam, LRESULT *aRetValue);
22788:   PRBool                  ProcessMessageForPlugin(const MSG &aMsg,
22788:                                                   LRESULT *aRetValue, PRBool &aCallDefWndProc);
22788:   LRESULT                 ProcessCharMessage(const MSG &aMsg,
22788:                                              PRBool *aEventDispatched);
22788:   LRESULT                 ProcessKeyUpMessage(const MSG &aMsg,
22788:                                               PRBool *aEventDispatched);
22788:   LRESULT                 ProcessKeyDownMessage(const MSG &aMsg,
22788:                                                 PRBool *aEventDispatched);
29835:   static PRBool           EventIsInsideWindow(UINT Msg, nsWindow* aWindow);
29835:   // Convert nsEventStatus value to a windows boolean
29835:   static PRBool           ConvertStatus(nsEventStatus aStatus);
29835:   static void             PostSleepWakeNotification(const char* aNotification);
32183:   PRBool                  HandleScrollingPlugins(UINT aMsg, WPARAM aWParam, 
32183:                                                  LPARAM aLParam,
35155:                                                  PRBool& aResult,
35155:                                                  LRESULT* aRetValue,
35155:                                                  PRBool& aQuitProcessing);
22788: 
29835:   /**
29835:    * Event handlers
29835:    */
    1:   virtual void            OnDestroy();
    1:   virtual PRBool          OnMove(PRInt32 aX, PRInt32 aY);
23738:   virtual PRBool          OnResize(nsIntRect &aWindowRect);
27961:   LRESULT                 OnChar(const MSG &aMsg,
27961:                                  nsModifierKeyState &aModKeyState,
27961:                                  PRBool *aEventDispatched,
22788:                                  PRUint32 aFlags = 0);
27961:   LRESULT                 OnKeyDown(const MSG &aMsg,
27961:                                     nsModifierKeyState &aModKeyState,
27961:                                     PRBool *aEventDispatched,
14962:                                     nsFakeCharMessage* aFakeCharMessage);
27961:   LRESULT                 OnKeyUp(const MSG &aMsg,
27961:                                   nsModifierKeyState &aModKeyState,
27961:                                   PRBool *aEventDispatched);
22788:   LRESULT                 OnCharRaw(UINT charCode, UINT aScanCode,
27961:                                     nsModifierKeyState &aModKeyState,
22788:                                     PRUint32 aFlags = 0,
22788:                                     const MSG *aMsg = nsnull,
22788:                                     PRBool *aEventDispatched = nsnull);
32183:   virtual PRBool          OnScroll(UINT aMsg, WPARAM aWParam, LPARAM aLParam);
29835:   PRBool                  OnGesture(WPARAM wParam, LPARAM lParam);
29835:   PRBool                  OnHotKey(WPARAM wParam, LPARAM lParam);
29835:   BOOL                    OnInputLangChange(HKL aHKL);
29835:   void                    OnSettingsChange(WPARAM wParam, LPARAM lParam);
29835:   virtual PRBool          OnPaint(HDC aDC = nsnull);
31345:   void                    OnWindowPosChanged(WINDOWPOS *wp, PRBool& aResult);
29835: #if defined(CAIRO_HAS_DDRAW_SURFACE)
29835:   PRBool                  OnPaintImageDDraw16();
29835: #endif // defined(CAIRO_HAS_DDRAW_SURFACE)
29835:   PRBool                  OnMouseWheel(UINT msg, WPARAM wParam, LPARAM lParam, 
29835:                                        PRBool& result, PRBool& getWheelInfo,
29835:                                        LRESULT *aRetValue);
30094: #if !defined(WINCE)
29835:   void                    OnWindowPosChanging(LPWINDOWPOS& info);
29835: #endif // !defined(WINCE)
    1: 
29835:   /**
40944:    * Function that registers when the user has been active (used for detecting
40944:    * when the user is idle).
40944:    */
40944:   void                    UserActivity();
40944: 
40944:   /**
29835:    * Methods for derived classes 
29835:    */
29835:   virtual PRInt32         GetHeight(PRInt32 aProposedHeight);
29835:   virtual LPCWSTR         WindowClass();
29835:   virtual LPCWSTR         WindowPopupClass();
29835:   virtual DWORD           WindowStyle();
29835:   virtual DWORD           WindowExStyle();
    1: 
29835:   /**
29835:    * XP and Vista theming support for windows with rounded edges
29835:    */
26576:   void                    ClearThemeRegion();
26576:   void                    SetThemeRegion();
26616: 
29835:   /**
29835:    * Popup hooks
29835:    */
29835:   static void             ScheduleHookTimer(HWND aWnd, UINT aMsgId);
29835:   static void             RegisterSpecialDropdownHooks();
29835:   static void             UnregisterSpecialDropdownHooks();
29835:   static BOOL             DealWithPopups(HWND inWnd, UINT inMsg, WPARAM inWParam, LPARAM inLParam, LRESULT* outResult);
29835: 
29835:   /**
29835:    * Window transparency helpers
29835:    */
29835: #ifdef MOZ_XUL
29835: private:
29835:   void                    SetWindowTranslucencyInner(nsTransparencyMode aMode);
29835:   nsTransparencyMode      GetWindowTranslucencyInner() const { return mTransparencyMode; }
29835:   void                    ResizeTranslucentWindow(PRInt32 aNewWidth, PRInt32 aNewHeight, PRBool force = PR_FALSE);
29835:   nsresult                UpdateTranslucentWindow();
29835:   void                    SetupTranslucentWindowMemoryBitmap(nsTransparencyMode aMode);
39718:   void                    UpdateGlass();
29835: protected:
29835: #endif // MOZ_XUL
29835: 
38103: #ifdef MOZ_IPC
38103:   static bool             IsAsyncResponseEvent(UINT aMsg, LRESULT& aResult);
38400:   void                    IPCWindowProcHandler(UINT& msg, WPARAM& wParam, LPARAM& lParam);
38103: #endif // MOZ_IPC
38103: 
29835:   /**
29835:    * Misc.
29835:    */
29835:   UINT                    MapFromNativeToDOM(UINT aNativeKeyCode);
26616:   void                    StopFlashing();
29835:   static PRBool           IsTopLevelMouseExit(HWND aWnd);
29835:   static void             SetupKeyModifiersSequence(nsTArray<KeyPair>* aArray, PRUint32 aModifiers);
30515:   nsresult                SetWindowClipRegion(const nsTArray<nsIntRect>& aRects,
30515:                                               PRBool aIntersectWithExisting);
38805:   nsIntRegion             GetRegionToPaint(PRBool aForceFullRepaint, 
32038:                                            PAINTSTRUCT ps, HDC aDC);
34786: #if !defined(WINCE)
34786:   static void             ActivateOtherWindowHelper(HWND aWnd);
40485:   static PRUint16         GetMouseInputSource();
34786: #endif
29835: #ifdef ACCESSIBILITY
29835:   static STDMETHODIMP_(LRESULT) LresultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN pAcc);
29835: #endif // ACCESSIBILITY
    1: 
    1: protected:
42532:   nsCOMPtr<nsIWidget>   mParent;
29835:   nsIntSize             mLastSize;
29835:   nsIntPoint            mLastPoint;
29835:   HWND                  mWnd;
29835:   WNDPROC               mPrevWndProc;
29835:   HBRUSH                mBrush;
29835:   PRPackedBool          mIsTopWidgetWindow;
30223:   PRPackedBool          mInDtor;
29835:   PRPackedBool          mIsVisible;
29835:   PRPackedBool          mIsInMouseCapture;
29835:   PRPackedBool          mUnicodeWidget;
29835:   PRPackedBool          mPainting;
29835:   PRUint32              mBlurSuppressLevel;
29835:   nsContentType         mContentType;
29835:   DWORD_PTR             mOldStyle;
29835:   DWORD_PTR             mOldExStyle;
29835:   HIMC                  mOldIMC;
29835:   PRUint32              mIMEEnabled;
29835:   nsNativeDragTarget*   mNativeDragTarget;
29835:   HKL                   mLastKeyboardLayout;
29835:   nsPopupType           mPopupType;
31443:   PRPackedBool          mDisplayPanFeedback;
31532:   WindowHook            mWindowHook;
29835:   static PRUint32       sInstanceCount;
29835:   static TriStateBool   sCanQuit;
29835:   static nsWindow*      sCurrentWindow;
    1:   static BOOL           sIsRegistered;
    1:   static BOOL           sIsPopupClassRegistered;
29835:   static BOOL           sIsOleInitialized;
29835:   static HCURSOR        sHCursor;
29835:   static imgIContainer* sCursorImgContainer;
29835:   static PRBool         sSwitchKeyboardLayout;
29835:   static PRBool         sJustGotDeactivate;
29835:   static PRBool         sJustGotActivate;
29835:   static int            sTrimOnMinimize;
33529:   static PRBool         sTrackPointHack;
37550: #ifdef MOZ_IPC
37550:   static PRUint32       sOOPPPluginFocusEvent;
37550: #endif
    1: 
40944:   nsCOMPtr<nsIdleService> mIdleService;
40944: 
29835:   // Hook Data Memebers for Dropdowns. sProcessHook Tells the
29835:   // hook methods whether they should be processing the hook
29835:   // messages.
29835:   static HHOOK          sMsgFilterHook;
29835:   static HHOOK          sCallProcHook;
29835:   static HHOOK          sCallMouseHook;
29835:   static PRPackedBool   sProcessHook;
29835:   static UINT           sRollupMsgId;
29835:   static HWND           sRollupMsgWnd;
29835:   static UINT           sHookTimerId;
    1: 
29835:   // Rollup Listener
29835:   static nsIWidget*     sRollupWidget;
29835:   static PRBool         sRollupConsumeEvent;
29835:   static nsIRollupListener* sRollupListener;
36806:   static nsIMenuRollup* sMenuRollup;
    1: 
29835:   // Mouse Clicks - static variable definitions for figuring
29835:   // out 1 - 3 Clicks.
29835:   static POINT          sLastMousePoint;
29835:   static POINT          sLastMouseMovePoint;
29835:   static LONG           sLastMouseDownTime;
29835:   static LONG           sLastClickCount;
29835:   static BYTE           sLastMouseButton;
29835: 
29835:   // Graphics
29835:   HDC                   mPaintDC; // only set during painting
30087: 
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727:   nsRefPtr<gfxD2DSurface>    mD2DWindowSurface; // Surface for this window.
38727: #endif
38727: 
29835:   // Transparency
29835: #ifdef MOZ_XUL
29835:   // Use layered windows to support full 256 level alpha translucency
29835:   nsRefPtr<gfxWindowsSurface> mTransparentSurface;
29835:   HDC                   mMemoryDC;
29835:   nsTransparencyMode    mTransparencyMode;
39718: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN
39718:   nsIntRegion           mPossiblyTransparentRegion;
39718:   MARGINS               mGlassMargins;
39718: #endif // #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN
29835: #endif // MOZ_XUL
29835: 
29835:   // Win7 Gesture processing and management
29835: #if !defined(WINCE)
29835:   nsWinGesture          mGesture;
29835: #endif // !defined(WINCE)
29835: 
33486: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486:   // Weak ref to the nsITaskbarWindowPreview associated with this window
33486:   nsWeakPtr             mTaskbarPreview;
33486:   // True if the taskbar (possibly through the tab preview) tells us that the
33486:   // icon has been created on the taskbar.
33486:   PRBool                mHasTaskbarIconBeenCreated;
33486: #endif
33486: 
29835: #if defined(WINCE_HAVE_SOFTKB)
29835:   static PRBool         sSoftKeyboardState;
29835: #endif // defined(WINCE_HAVE_SOFTKB)
    1: 
    1: #ifdef ACCESSIBILITY
29835:   static BOOL           sIsAccessibilityOn;
29835:   static HINSTANCE      sAccLib;
29835:   static LPFNLRESULTFROMOBJECT sLresultFromObject;
29835: #endif // ACCESSIBILITY
    1: };
    1: 
29835: /**
29835:  * A child window is a window with different style.
29835:  */
    1: class ChildWindow : public nsWindow {
    1: 
    1: public:
    1:   ChildWindow() {}
    1:   PRBool DispatchMouseEvent(PRUint32 aEventType, WPARAM wParam, LPARAM lParam,
    1:                             PRBool aIsContextMenuKey = PR_FALSE,
40485:                             PRInt16 aButton = nsMouseEvent::eLeftButton,
40485:                             PRUint16 aInputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_MOUSE);
    1: 
    1: protected:
    1:   virtual DWORD WindowStyle();
    1: };
    1: 
30075: #endif // Window_h__
