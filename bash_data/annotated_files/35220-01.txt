    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* vim:expandtab:shiftwidth=4:tabstop=4:
    1:  */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is Christopher Blizzard
    1:  * <blizzard@mozilla.org>.  Portions created by the Initial Developer
    1:  * are Copyright (C) 2001 the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsClipboard.h"
    1: #include "nsSupportsPrimitives.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsPrimitiveHelpers.h"
    1: #include "nsICharsetConverterManager.h"
    1: #include "nsIServiceManager.h"
 8873: #include "nsImageToPixbuf.h"
 8873: #include "nsStringStream.h"
    1: 
30479: #include "imgIContainer.h"
30479: 
23281: #include <gtk/gtk.h>
    1: 
    1: // For manipulation of the X event queue
    1: #include <X11/Xlib.h>
    1: #include <gdk/gdkx.h>
    1: #include <sys/time.h>
    1: #include <sys/types.h>
    1: #include <unistd.h>
    1: 
    1: #ifdef POLL_WITH_XCONNECTIONNUMBER
    1: #include <poll.h>
    1: #endif
    1: 
    1: // Callback when someone asks us for the selection
    1: void
    1: invisible_selection_get_cb (GtkWidget          *aWidget,
    1:                             GtkSelectionData   *aSelectionData,
    1:                             guint               aTime,
    1:                             guint               aInfo,
    1:                             nsClipboard        *aClipboard);
    1: 
    1: gboolean
    1: selection_clear_event_cb   (GtkWidget          *aWidget,
    1:                             GdkEventSelection  *aEvent,
    1:                             nsClipboard        *aClipboard);
    1: 
    1: static void
    1: ConvertHTMLtoUCS2          (guchar             *data,
    1:                             PRInt32             dataLength,
    1:                             PRUnichar         **unicodeData,
    1:                             PRInt32            &outUnicodeLen);
    1: 
    1: static void
    1: GetHTMLCharset             (guchar * data, PRInt32 dataLength, nsCString& str);
    1: 
    1: 
    1: // Our own versions of gtk_clipboard_wait_for_contents and
    1: // gtk_clipboard_wait_for_text, which don't run the event loop while
    1: // waiting for the data.  This prevents a lot of problems related to
    1: // dispatching events at unexpected times.
    1: 
    1: static GtkSelectionData *
    1: wait_for_contents          (GtkClipboard *clipboard, GdkAtom target);
    1: 
    1: static gchar *
    1: wait_for_text              (GtkClipboard *clipboard);
    1: 
    1: static Bool
    1: checkEventProc(Display *display, XEvent *event, XPointer arg);
    1: 
    1: struct retrieval_context
    1: {
    1:     PRBool   completed;
    1:     void    *data;
    1: 
    1:     retrieval_context() : completed(PR_FALSE), data(nsnull) { }
    1: };
    1: 
    1: static void
    1: wait_for_retrieval(GtkClipboard *clipboard, retrieval_context *transferData);
    1: 
    1: static void
    1: clipboard_contents_received(GtkClipboard     *clipboard,
    1:                             GtkSelectionData *selection_data,
    1:                             gpointer          data);
    1: 
    1: static void
    1: clipboard_text_received(GtkClipboard *clipboard,
    1:                         const gchar  *text,
    1:                         gpointer      data);
    1: 
    1: nsClipboard::nsClipboard()
    1: {
    1:     mWidget = nsnull;
    1: }
    1: 
    1: nsClipboard::~nsClipboard()
    1: {
    1:     if (mWidget)
    1:         gtk_widget_destroy(mWidget);
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsClipboard, nsIClipboard)
    1: 
    1: nsresult
    1: nsClipboard::Init(void)
    1: {
    1:     mWidget = gtk_invisible_new();
    1:     if (!mWidget)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     g_signal_connect(G_OBJECT(mWidget), "selection_get",
    1:                      G_CALLBACK(invisible_selection_get_cb), this);
    1: 
    1:     g_signal_connect(G_OBJECT(mWidget), "selection_clear_event",
    1:                      G_CALLBACK(selection_clear_event_cb), this);
    1: 
    1:     // XXX make sure to set up the selection_clear event
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsClipboard::SetData(nsITransferable *aTransferable,
    1:                      nsIClipboardOwner *aOwner, PRInt32 aWhichClipboard)
    1: {
    1:     // See if we can short cut
    1:     if ((aWhichClipboard == kGlobalClipboard &&
    1:          aTransferable == mGlobalTransferable.get() &&
    1:          aOwner == mGlobalOwner.get()) ||
    1:         (aWhichClipboard == kSelectionClipboard &&
    1:          aTransferable == mSelectionTransferable.get() &&
    1:          aOwner == mSelectionOwner.get())) {
    1:         return NS_OK;
    1:     }
    1: 
24436:     nsresult rv;
24436:     if (!mPrivacyHandler) {
24436:         rv = NS_NewClipboardPrivacyHandler(getter_AddRefs(mPrivacyHandler));
24436:         NS_ENSURE_SUCCESS(rv, rv);
24436:     }
24436:     rv = mPrivacyHandler->PrepareDataForClipboard(aTransferable);
24436:     NS_ENSURE_SUCCESS(rv, rv);
24436: 
    1:     // Clear out the clipboard in order to set the new data
    1:     EmptyClipboard(aWhichClipboard);
    1: 
    1:     if (aWhichClipboard == kSelectionClipboard) {
    1:         mSelectionOwner = aOwner;
    1:         mSelectionTransferable = aTransferable;
    1:     }
    1:     else {
    1:         mGlobalOwner = aOwner;
    1:         mGlobalTransferable = aTransferable;
    1:     }
    1: 
    1:     // Which selection are we about to claim, CLIPBOARD or PRIMARY?
    1:     GdkAtom selectionAtom = GetSelectionAtom(aWhichClipboard);
    1: 
    1:     // Make ourselves the owner.  If we fail to, return.
    1:     if (!gtk_selection_owner_set(mWidget, selectionAtom, GDK_CURRENT_TIME))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     // Clear the old selection target list.
    1:     gtk_selection_clear_targets(mWidget, selectionAtom);
    1: 
    1:     // Get the types of supported flavors
    1:     nsCOMPtr<nsISupportsArray> flavors;
    1: 
    1:     rv = aTransferable->FlavorsTransferableCanExport(getter_AddRefs(flavors));
    1:     if (!flavors || NS_FAILED(rv))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     // Add all the flavors to this widget's supported type.
33070:     gint nImageTargets = 0;
    1:     PRUint32 count;
    1:     flavors->Count(&count);
    1:     for (PRUint32 i=0; i < count; i++) {
    1:         nsCOMPtr<nsISupports> tastesLike;
    1:         flavors->GetElementAt(i, getter_AddRefs(tastesLike));
    1:         nsCOMPtr<nsISupportsCString> flavor = do_QueryInterface(tastesLike);
    1: 
    1:         if (flavor) {
    1:             nsXPIDLCString flavorStr;
    1:             flavor->ToString(getter_Copies(flavorStr));
    1: 
    1:             // special case text/unicode since we can handle all of
    1:             // the string types
    1:             if (!strcmp(flavorStr, kUnicodeMime)) {
    1:                 AddTarget(gdk_atom_intern("UTF8_STRING", FALSE),
    1:                           selectionAtom);
    1:                 AddTarget(gdk_atom_intern("COMPOUND_TEXT", FALSE),
    1:                           selectionAtom);
    1:                 AddTarget(gdk_atom_intern("TEXT", FALSE), selectionAtom);
    1:                 AddTarget(GDK_SELECTION_TYPE_STRING, selectionAtom);
    1:                 // next loop iteration
    1:                 continue;
    1:             }
    1: 
33070:             if (flavorStr.EqualsLiteral(kNativeImageMime) ||
33070:                 flavorStr.EqualsLiteral(kPNGImageMime) ||
33070:                 flavorStr.EqualsLiteral(kJPEGImageMime) ||
33070:                 flavorStr.EqualsLiteral(kGIFImageMime)) {
33070:                 // don't bother adding image targets twice
33070:                 if (!nImageTargets) {
33070:                     // accept any writable image type
33070:                     GtkTargetList *list = gtk_target_list_new(NULL, 0);
33070:                     gtk_target_list_add_image_targets(list, 0, TRUE);
33070:                     GtkTargetEntry *targets = gtk_target_table_new_from_list(list, &nImageTargets);
33070:                     gtk_selection_add_targets(mWidget, selectionAtom, targets, nImageTargets);
33070:                     gtk_target_table_free(targets, nImageTargets);
33070:                     gtk_target_list_unref(list);
33070:                 }
33070:                 // next loop iteration
 8873:                 continue;
 8873:             }
 8873: 
    1:             // Add this to our list of valid targets
    1:             GdkAtom atom = gdk_atom_intern(flavorStr, FALSE);
    1:             AddTarget(atom, selectionAtom);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsClipboard::GetData(nsITransferable *aTransferable, PRInt32 aWhichClipboard)
    1: {
    1:     if (!aTransferable)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     GtkClipboard *clipboard;
    1:     clipboard = gtk_clipboard_get(GetSelectionAtom(aWhichClipboard));
    1: 
    1:     guchar        *data = NULL;
    1:     gint           length = 0;
    1:     PRBool         foundData = PR_FALSE;
    1:     nsCAutoString  foundFlavor;
    1: 
    1:     // Get a list of flavors this transferable can import
    1:     nsCOMPtr<nsISupportsArray> flavors;
    1:     nsresult rv;
    1:     rv = aTransferable->FlavorsTransferableCanImport(getter_AddRefs(flavors));
    1:     if (!flavors || NS_FAILED(rv))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     PRUint32 count;
    1:     flavors->Count(&count);
    1:     for (PRUint32 i=0; i < count; i++) {
    1:         nsCOMPtr<nsISupports> genericFlavor;
    1:         flavors->GetElementAt(i, getter_AddRefs(genericFlavor));
    1: 
    1:         nsCOMPtr<nsISupportsCString> currentFlavor;
    1:         currentFlavor = do_QueryInterface(genericFlavor);
    1: 
    1:         if (currentFlavor) {
    1:             nsXPIDLCString flavorStr;
    1:             currentFlavor->ToString(getter_Copies(flavorStr));
    1: 
    1:             // Special case text/unicode since we can convert any
    1:             // string into text/unicode
    1:             if (!strcmp(flavorStr, kUnicodeMime)) {
    1:                 gchar* new_text = wait_for_text(clipboard);
    1:                 if (new_text) {
    1:                     // Convert utf-8 into our unicode format.
    1:                     NS_ConvertUTF8toUTF16 ucs2string(new_text);
    1:                     data = (guchar *)ToNewUnicode(ucs2string);
    1:                     length = ucs2string.Length() * 2;
    1:                     g_free(new_text);
    1:                     foundData = PR_TRUE;
    1:                     foundFlavor = kUnicodeMime;
    1:                     break;
    1:                 }
    1:                 // If the type was text/unicode and we couldn't get
    1:                 // text off the clipboard, run the next loop
    1:                 // iteration.
    1:                 continue;
    1:             }
    1: 
 8873:             // For images, we must wrap the data in an nsIInputStream then return instead of break,
 8873:             // because that code below won't help us.
 8873:             if (!strcmp(flavorStr, kJPEGImageMime) || !strcmp(flavorStr, kPNGImageMime) || !strcmp(flavorStr, kGIFImageMime)) {
 8873:                 GdkAtom atom;
 8873:                 if (!strcmp(flavorStr, kJPEGImageMime)) // This is image/jpg, but X only understands image/jpeg
 8873:                     atom = gdk_atom_intern("image/jpeg", FALSE);
 8873:                 else
 8873:                     atom = gdk_atom_intern(flavorStr, FALSE);
 8873: 
 8873:                 GtkSelectionData *selectionData = wait_for_contents(clipboard, atom);
 8873:                 if (!selectionData)
 8873:                     continue;
 8873: 
 8873:                 nsCOMPtr<nsIInputStream> byteStream;
 8873:                 NS_NewByteInputStream(getter_AddRefs(byteStream), (const char*)selectionData->data,
 8873:                                       selectionData->length, NS_ASSIGNMENT_COPY);
 8873:                 aTransferable->SetTransferData(flavorStr, byteStream, sizeof(nsIInputStream*));
 8873:                 gtk_selection_data_free(selectionData);
 8873:                 return NS_OK;
 8873:             }
 8873: 
    1:             // Get the atom for this type and try to request it off
    1:             // the clipboard.
    1:             GdkAtom atom = gdk_atom_intern(flavorStr, FALSE);
    1:             GtkSelectionData *selectionData;
    1:             selectionData = wait_for_contents(clipboard, atom);
    1:             if (selectionData) {
    1:                 length = selectionData->length;
    1:                 // Special case text/html since we can convert into UCS2
    1:                 if (!strcmp(flavorStr, kHTMLMime)) {
    1:                     PRUnichar* htmlBody= nsnull;
    1:                     PRInt32 htmlBodyLen = 0;
    1:                     // Convert text/html into our unicode format
    1:                     ConvertHTMLtoUCS2((guchar *)selectionData->data, length,
    1:                                       &htmlBody, htmlBodyLen);
    1:                     if (!htmlBodyLen)
    1:                         break;
    1:                     data = (guchar *)htmlBody;
    1:                     length = htmlBodyLen * 2;
    1:                 } else {
    1:                     data = (guchar *)nsMemory::Alloc(length);
    1:                     if (!data)
    1:                         break;
    1:                     memcpy(data, selectionData->data, length);
    1:                 }
    1:                 foundData = PR_TRUE;
    1:                 foundFlavor = flavorStr;
    1:                 break;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (foundData) {
    1:         nsCOMPtr<nsISupports> wrapper;
    1:         nsPrimitiveHelpers::CreatePrimitiveForData(foundFlavor.get(),
    1:                                                    data, length,
    1:                                                    getter_AddRefs(wrapper));
    1:         aTransferable->SetTransferData(foundFlavor.get(),
    1:                                        wrapper, length);
    1:     }
    1: 
    1:     if (data)
    1:         nsMemory::Free(data);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsClipboard::EmptyClipboard(PRInt32 aWhichClipboard)
    1: {
    1:     if (aWhichClipboard == kSelectionClipboard) {
    1:         if (mSelectionOwner) {
    1:             mSelectionOwner->LosingOwnership(mSelectionTransferable);
    1:             mSelectionOwner = nsnull;
    1:         }
    1:         mSelectionTransferable = nsnull;
    1:     }
    1:     else {
    1:         if (mGlobalOwner) {
    1:             mGlobalOwner->LosingOwnership(mGlobalTransferable);
    1:             mGlobalOwner = nsnull;
    1:         }
    1:         mGlobalTransferable = nsnull;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 8229: nsClipboard::HasDataMatchingFlavors(const char** aFlavorList, PRUint32 aLength,
    1:                                     PRInt32 aWhichClipboard, PRBool *_retval)
    1: {
 8229:     if (!aFlavorList || !_retval)
 8229:         return NS_ERROR_NULL_POINTER;
 8229: 
    1:     *_retval = PR_FALSE;
    1: 
    1:     GtkSelectionData *selection_data =
    1:         GetTargets(GetSelectionAtom(aWhichClipboard));
    1:     if (!selection_data)
    1:         return NS_OK;
    1: 
    1:     gint n_targets = 0;
    1:     GdkAtom *targets = NULL;
    1: 
    1:     if (!gtk_selection_data_get_targets(selection_data, 
    1:                                         &targets, &n_targets) ||
    1:         !n_targets)
    1:         return NS_OK;
    1: 
    1:     // Walk through the provided types and try to match it to a
    1:     // provided type.
 8229:     for (PRUint32 i = 0; i < aLength && !*_retval; i++) {
    1:         // We special case text/unicode here.
 8229:         if (!strcmp(aFlavorList[i], kUnicodeMime) && 
    1:             gtk_selection_data_targets_include_text(selection_data)) {
    1:             *_retval = PR_TRUE;
    1:             break;
    1:         }
    1: 
    1:         for (PRInt32 j = 0; j < n_targets; j++) {
    1:             gchar *atom_name = gdk_atom_name(targets[j]);
35220:             if (!g_strcmp0(atom_name, aFlavorList[i]))
    1:                 *_retval = PR_TRUE;
    1: 
 8873:             // X clipboard wants image/jpeg, not image/jpg
35220:             if (!g_strcmp0(aFlavorList[i], kJPEGImageMime) && !g_strcmp0(atom_name, "image/jpeg"))
 8873:                 *_retval = PR_TRUE;
 8873: 
    1:             g_free(atom_name);
    1: 
    1:             if (*_retval)
    1:                 break;
    1:         }
    1:     }
    1:     gtk_selection_data_free(selection_data);
    1:     g_free(targets);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsClipboard::SupportsSelectionClipboard(PRBool *_retval)
    1: {
    1:     *_retval = PR_TRUE; // yeah, unix supports the selection clipboard
    1:     return NS_OK;
    1: }
    1: 
    1: /* static */
    1: GdkAtom
    1: nsClipboard::GetSelectionAtom(PRInt32 aWhichClipboard)
    1: {
    1:     if (aWhichClipboard == kGlobalClipboard)
    1:         return GDK_SELECTION_CLIPBOARD;
    1: 
    1:     return GDK_SELECTION_PRIMARY;
    1: }
    1: 
    1: /* static */
    1: GtkSelectionData *
    1: nsClipboard::GetTargets(GdkAtom aWhichClipboard)
    1: {
    1:     GtkClipboard *clipboard = gtk_clipboard_get(aWhichClipboard);
    1:     return wait_for_contents(clipboard, gdk_atom_intern("TARGETS", FALSE));
    1: }
    1: 
    1: nsITransferable *
    1: nsClipboard::GetTransferable(PRInt32 aWhichClipboard)
    1: {
    1:     nsITransferable *retval;
    1: 
    1:     if (aWhichClipboard == kSelectionClipboard)
    1:         retval = mSelectionTransferable.get();
    1:     else
    1:         retval = mGlobalTransferable.get();
    1:         
    1:     return retval;
    1: }
    1: 
    1: void
    1: nsClipboard::AddTarget(GdkAtom aName, GdkAtom aClipboard)
    1: {
    1:     gtk_selection_add_target(mWidget, aClipboard, aName, 0);
    1: }
    1: 
    1: void
    1: nsClipboard::SelectionGetEvent (GtkWidget        *aWidget,
    1:                                 GtkSelectionData *aSelectionData,
    1:                                 guint             aTime)
    1: {
    1:     // Someone has asked us to hand them something.  The first thing
    1:     // that we want to do is see if that something includes text.  If
    1:     // it does, try to give it text/unicode after converting it to
    1:     // utf-8.
    1: 
    1:     PRInt32 whichClipboard;
    1: 
    1:     // which clipboard?
    1:     if (aSelectionData->selection == GDK_SELECTION_PRIMARY)
    1:         whichClipboard = kSelectionClipboard;
    1:     else if (aSelectionData->selection == GDK_SELECTION_CLIPBOARD)
    1:         whichClipboard = kGlobalClipboard;
    1:     else
    1:         return; // THAT AIN'T NO CLIPBOARD I EVER HEARD OF
    1: 
    1:     nsCOMPtr<nsITransferable> trans = GetTransferable(whichClipboard);
    1:     
    1:     nsresult rv;
    1:     nsCOMPtr<nsISupports> item;
    1:     PRUint32 len;
    1: 
    1:     // Check to see if the selection data includes any of the string
    1:     // types that we support.
    1:     if (aSelectionData->target == gdk_atom_intern ("STRING", FALSE) ||
    1:         aSelectionData->target == gdk_atom_intern ("TEXT", FALSE) ||
    1:         aSelectionData->target == gdk_atom_intern ("COMPOUND_TEXT", FALSE) ||
    1:         aSelectionData->target == gdk_atom_intern ("UTF8_STRING", FALSE)) {
    1:         // Try to convert our internal type into a text string.  Get
    1:         // the transferable for this clipboard and try to get the
    1:         // text/unicode type for it.
    1:         rv = trans->GetTransferData("text/unicode", getter_AddRefs(item),
    1:                                     &len);
    1:         if (!item || NS_FAILED(rv))
    1:             return;
    1:         
    1:         nsCOMPtr<nsISupportsString> wideString;
    1:         wideString = do_QueryInterface(item);
    1:         if (!wideString)
    1:             return;
    1: 
    1:         nsAutoString ucs2string;
    1:         wideString->GetData(ucs2string);
    1:         char *utf8string = ToNewUTF8String(ucs2string);
    1:         if (!utf8string)
    1:             return;
    1:         
    1:         gtk_selection_data_set_text (aSelectionData, utf8string,
    1:                                      strlen(utf8string));
    1: 
    1:         nsMemory::Free(utf8string);
    1:         return;
    1:     }
    1: 
33070:     // Check to see if the selection data is an image type
33070:     if (gtk_targets_include_image(&aSelectionData->target, 1, TRUE)) {
33070:         // Look through our transfer data for the image
33070:         static const char* const imageMimeTypes[] = {
33070:             kNativeImageMime, kPNGImageMime, kJPEGImageMime, kGIFImageMime };
33070:         nsCOMPtr<nsISupports> item;
33070:         PRUint32 len;
33070:         nsCOMPtr<nsISupportsInterfacePointer> ptrPrimitive;
33070:         for (PRUint32 i = 0; !ptrPrimitive && i < NS_ARRAY_LENGTH(imageMimeTypes); i++) {
33070:             rv = trans->GetTransferData(imageMimeTypes[i], getter_AddRefs(item), &len);
33070:             ptrPrimitive = do_QueryInterface(item);
33070:         }
33070:         if (!ptrPrimitive)
33070:             return;
33070: 
33070:         nsCOMPtr<nsISupports> primitiveData;
33070:         ptrPrimitive->GetData(getter_AddRefs(primitiveData));
33070:         nsCOMPtr<imgIContainer> image(do_QueryInterface(primitiveData));
33070:         if (!image) // Not getting an image for an image mime type!?
33070:             return;
33070: 
33070:         GdkPixbuf* pixbuf = nsImageToPixbuf::ImageToPixbuf(image);
33070:         if (!pixbuf)
33070:             return;
33070: 
33070:         gtk_selection_data_set_pixbuf(aSelectionData, pixbuf);
33070:         g_object_unref(pixbuf);
33070:         return;
33070:     }
33070: 
    1:     // Try to match up the selection data target to something our
    1:     // transferable provides.
    1:     gchar *target_name = gdk_atom_name(aSelectionData->target);
    1:     if (!target_name)
    1:         return;
    1: 
    1:     rv = trans->GetTransferData(target_name, getter_AddRefs(item), &len);
    1:     // nothing found?
    1:     if (!item || NS_FAILED(rv)) {
    1:         g_free(target_name);
    1:         return;
    1:     }
    1: 
    1:     void *primitive_data = nsnull;
    1:     nsPrimitiveHelpers::CreateDataFromPrimitive(target_name, item,
    1:                                                 &primitive_data, len);
    1: 
    1:     if (primitive_data) {
    1:         // Check to see if the selection data is text/html
    1:         if (aSelectionData->target == gdk_atom_intern (kHTMLMime, FALSE)) {
    1:             /*
    1:              * "text/html" can be encoded UCS2. It is recommended that
    1:              * documents transmitted as UCS2 always begin with a ZERO-WIDTH
    1:              * NON-BREAKING SPACE character (hexadecimal FEFF, also called
    1:              * Byte Order Mark (BOM)). Adding BOM can help other app to
    1:              * detect mozilla use UCS2 encoding when copy-paste.
    1:              */
    1:             guchar *buffer = (guchar *)
    1:                     nsMemory::Alloc((len * sizeof(guchar)) + sizeof(PRUnichar));
    1:             if (!buffer)
    1:                 return;
    1:             PRUnichar prefix = 0xFEFF;
    1:             memcpy(buffer, &prefix, sizeof(prefix));
    1:             memcpy(buffer + sizeof(prefix), primitive_data, len);
    1:             nsMemory::Free((guchar *)primitive_data);
    1:             primitive_data = (guchar *)buffer;
    1:             len += sizeof(prefix);
    1:         }
    1:   
    1:         gtk_selection_data_set(aSelectionData, aSelectionData->target,
    1:                                8, /* 8 bits in a unit */
    1:                                (const guchar *)primitive_data, len);
    1:         nsMemory::Free(primitive_data);
    1:     }
    1: 
    1:     g_free(target_name);
    1:                            
    1: }
    1: 
    1: void
    1: nsClipboard::SelectionClearEvent (GtkWidget         *aWidget,
    1:                                   GdkEventSelection *aEvent)
    1: {
    1:     PRInt32 whichClipboard;
    1: 
    1:     // which clipboard?
    1:     if (aEvent->selection == GDK_SELECTION_PRIMARY)
    1:         whichClipboard = kSelectionClipboard;
    1:     else if (aEvent->selection == GDK_SELECTION_CLIPBOARD)
    1:         whichClipboard = kGlobalClipboard;
    1:     else
    1:         return; // THAT AIN'T NO CLIPBOARD I EVER HEARD OF
    1: 
    1:     EmptyClipboard(whichClipboard);
    1: }
    1: 
    1: void
    1: invisible_selection_get_cb (GtkWidget          *aWidget,
    1:                             GtkSelectionData   *aSelectionData,
    1:                             guint               aTime,
    1:                             guint               aInfo,
    1:                             nsClipboard        *aClipboard)
    1: {
    1:     aClipboard->SelectionGetEvent(aWidget, aSelectionData, aTime);
    1: }
    1: 
    1: gboolean
    1: selection_clear_event_cb   (GtkWidget          *aWidget,
    1:                             GdkEventSelection  *aEvent,
    1:                             nsClipboard        *aClipboard)
    1: {
    1:     aClipboard->SelectionClearEvent(aWidget, aEvent);
    1:     return TRUE;
    1: }
    1: 
    1: /*
    1:  * when copy-paste, mozilla wants data encoded using UCS2,
    1:  * other app such as StarOffice use "text/html"(RFC2854).
    1:  * This function convert data(got from GTK clipboard)
    1:  * to data mozilla wanted.
    1:  *
    1:  * data from GTK clipboard can be 3 forms:
    1:  *  1. From current mozilla
    1:  *     "text/html", charset = utf-16
    1:  *  2. From old version mozilla or mozilla-based app
    1:  *     content("body" only), charset = utf-16
    1:  *  3. From other app who use "text/html" when copy-paste
    1:  *     "text/html", has "charset" info
    1:  *
    1:  * data      : got from GTK clipboard
    1:  * dataLength: got from GTK clipboard
    1:  * body      : pass to Mozilla
    1:  * bodyLength: pass to Mozilla
    1:  */
    1: void ConvertHTMLtoUCS2(guchar * data, PRInt32 dataLength,
    1:                        PRUnichar** unicodeData, PRInt32& outUnicodeLen)
    1: {
    1:     nsCAutoString charset;
    1:     GetHTMLCharset(data, dataLength, charset);// get charset of HTML
    1:     if (charset.EqualsLiteral("UTF-16")) {//current mozilla
    1:         outUnicodeLen = (dataLength / 2) - 1;
 3233:         *unicodeData = reinterpret_cast<PRUnichar*>
 3233:                                        (nsMemory::Alloc((outUnicodeLen + sizeof('\0')) *
    1:                        sizeof(PRUnichar)));
    1:         if (*unicodeData) {
    1:             memcpy(*unicodeData, data + sizeof(PRUnichar),
    1:                    outUnicodeLen * sizeof(PRUnichar));
    1:             (*unicodeData)[outUnicodeLen] = '\0';
    1:         }
    1:     } else if (charset.EqualsLiteral("UNKNOWN")) {
    1:         outUnicodeLen = 0;
    1:         return;
    1:     } else {
    1:         // app which use "text/html" to copy&paste
    1:         nsCOMPtr<nsIUnicodeDecoder> decoder;
    1:         nsresult rv;
    1:         // get the decoder
    1:         nsCOMPtr<nsICharsetConverterManager> ccm =
    1:             do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
    1:         if (NS_FAILED(rv)) {
    1: #ifdef DEBUG_CLIPBOARD
    1:             g_print("        can't get CHARSET CONVERTER MANAGER service\n");
    1: #endif
    1:             outUnicodeLen = 0;
    1:             return;
    1:         }
    1:         rv = ccm->GetUnicodeDecoder(charset.get(), getter_AddRefs(decoder));
    1:         if (NS_FAILED(rv)) {
    1: #ifdef DEBUG_CLIPBOARD
    1:             g_print("        get unicode decoder error\n");
    1: #endif
    1:             outUnicodeLen = 0;
    1:             return;
    1:         }
    1:         // converting
    1:         decoder->GetMaxLength((const char *)data, dataLength, &outUnicodeLen);
    1:         // |outUnicodeLen| is number of chars
    1:         if (outUnicodeLen) {
 3233:             *unicodeData = reinterpret_cast<PRUnichar*>
 3233:                                            (nsMemory::Alloc((outUnicodeLen + sizeof('\0')) *
    1:                            sizeof(PRUnichar)));
    1:             if (*unicodeData) {
    1:                 PRInt32 numberTmp = dataLength;
    1:                 decoder->Convert((const char *)data, &numberTmp,
    1:                                  *unicodeData, &outUnicodeLen);
    1: #ifdef DEBUG_CLIPBOARD
    1:                 if (numberTmp != dataLength)
    1:                     printf("didn't consume all the bytes\n");
    1: #endif
    1:                 // null terminate. Convert() doesn't do it for us
    1:                 (*unicodeData)[outUnicodeLen] = '\0';
    1:             }
    1:         } // if valid length
    1:     }
    1: }
    1: 
    1: /*
    1:  * get "charset" information from clipboard data
    1:  * return value can be:
    1:  *  1. "UTF-16":      mozilla or "text/html" with "charset=utf-16"
    1:  *  2. "UNKNOWN":     mozilla can't detect what encode it use
    1:  *  3. other:         "text/html" with other charset than utf-16
    1:  */
    1: void GetHTMLCharset(guchar * data, PRInt32 dataLength, nsCString& str)
    1: {
    1:     // if detect "FFFE" or "FEFF", assume UTF-16
    1:     PRUnichar* beginChar =  (PRUnichar*)data;
    1:     if ((beginChar[0] == 0xFFFE) || (beginChar[0] == 0xFEFF)) {
    1:         str.AssignLiteral("UTF-16");
    1:         return;
    1:     }
    1:     // no "FFFE" and "FEFF", assume ASCII first to find "charset" info
10727:     const nsDependentCString htmlStr((const char *)data, dataLength);
    1:     nsACString::const_iterator start, end;
    1:     htmlStr.BeginReading(start);
    1:     htmlStr.EndReading(end);
    1:     nsACString::const_iterator valueStart(start), valueEnd(start);
    1: 
    1:     if (CaseInsensitiveFindInReadable(
    1:         NS_LITERAL_CSTRING("CONTENT=\"text/html;"),
    1:         start, end)) {
    1:         start = end;
    1:         htmlStr.EndReading(end);
    1: 
    1:         if (CaseInsensitiveFindInReadable(
    1:             NS_LITERAL_CSTRING("charset="),
    1:             start, end)) {
    1:             valueStart = end;
    1:             start = end;
    1:             htmlStr.EndReading(end);
    1:           
    1:             if (FindCharInReadable('"', start, end))
    1:                 valueEnd = start;
    1:         }
    1:     }
    1:     // find "charset" in HTML
    1:     if (valueStart != valueEnd) {
    1:         str = Substring(valueStart, valueEnd);
    1:         ToUpperCase(str);
    1: #ifdef DEBUG_CLIPBOARD
    1:         printf("Charset of HTML = %s\n", charsetUpperStr.get());
    1: #endif
    1:         return;
    1:     }
    1:     str.AssignLiteral("UNKNOWN");
    1: }
    1: 
    1: static void
    1: DispatchSelectionNotifyEvent(GtkWidget *widget, XEvent *xevent)
    1: {
    1:     GdkEvent event;
    1:     event.selection.type = GDK_SELECTION_NOTIFY;
    1:     event.selection.window = widget->window;
    1:     event.selection.selection = gdk_x11_xatom_to_atom(xevent->xselection.selection);
    1:     event.selection.target = gdk_x11_xatom_to_atom(xevent->xselection.target);
    1:     event.selection.property = gdk_x11_xatom_to_atom(xevent->xselection.property);
    1:     event.selection.time = xevent->xselection.time;
    1: 
    1:     gtk_widget_event(widget, &event);
    1: }
    1: 
    1: static void
    1: DispatchPropertyNotifyEvent(GtkWidget *widget, XEvent *xevent)
    1: {
    1:     if (((GdkWindowObject *) widget->window)->event_mask & GDK_PROPERTY_CHANGE_MASK) {
    1:         GdkEvent event;
    1:         event.property.type = GDK_PROPERTY_NOTIFY;
    1:         event.property.window = widget->window;
    1:         event.property.atom = gdk_x11_xatom_to_atom(xevent->xproperty.atom);
    1:         event.property.time = xevent->xproperty.time;
    1:         event.property.state = xevent->xproperty.state;
    1: 
    1:         gtk_widget_event(widget, &event);
    1:     }
    1: }
    1: 
    1: struct checkEventContext
    1: {
    1:     GtkWidget *cbWidget;
    1:     Atom       selAtom;
    1: };
    1: 
    1: static Bool
    1: checkEventProc(Display *display, XEvent *event, XPointer arg)
    1: {
    1:     checkEventContext *context = (checkEventContext *) arg;
    1: 
    1:     if (event->xany.type == SelectionNotify ||
    1:         (event->xany.type == PropertyNotify &&
    1:          event->xproperty.atom == context->selAtom)) {
    1: 
    1:         GdkWindow *cbWindow = gdk_window_lookup(event->xany.window);
    1:         if (cbWindow) {
    1:             GtkWidget *cbWidget = NULL;
    1:             gdk_window_get_user_data(cbWindow, (gpointer *)&cbWidget);
    1:             if (cbWidget && GTK_IS_WIDGET(cbWidget)) {
    1:                 context->cbWidget = cbWidget;
    1:                 return True;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return False;
    1: }
    1: 
    1: // Idle timeout for receiving selection and property notify events (microsec)
    1: static const int kClipboardTimeout = 500000;
    1: 
    1: static void
    1: wait_for_retrieval(GtkClipboard *clipboard, retrieval_context *r_context)
    1: {
    1:     if (r_context->completed)  // the request completed synchronously
    1:         return;
    1: 
    1:     Display *xDisplay = GDK_DISPLAY();
    1:     checkEventContext context;
    1:     context.cbWidget = NULL;
    1:     context.selAtom = gdk_x11_atom_to_xatom(gdk_atom_intern("GDK_SELECTION",
    1:                                                             FALSE));
    1: 
    1:     // Send X events which are relevant to the ongoing selection retrieval
    1:     // to the clipboard widget.  Wait until either the operation completes, or
    1:     // we hit our timeout.  All other X events remain queued.
    1: 
    1:     int select_result;
    1: 
    1: #ifdef POLL_WITH_XCONNECTIONNUMBER
    1:     struct pollfd fds[1];
    1:     fds[0].fd = XConnectionNumber(xDisplay);
    1:     fds[0].events = POLLIN;
    1: #else
    1:     int cnumber = ConnectionNumber(xDisplay);
    1:     fd_set select_set;
    1:     FD_ZERO(&select_set);
    1:     FD_SET(cnumber, &select_set);
    1:     ++cnumber;
    1:     struct timeval tv;
    1: #endif
    1: 
    1:     do {
    1:         XEvent xevent;
    1: 
    1:         while (XCheckIfEvent(xDisplay, &xevent, checkEventProc,
    1:                              (XPointer) &context)) {
    1: 
    1:             if (xevent.xany.type == SelectionNotify)
    1:                 DispatchSelectionNotifyEvent(context.cbWidget, &xevent);
    1:             else
    1:                 DispatchPropertyNotifyEvent(context.cbWidget, &xevent);
    1: 
    1:             if (r_context->completed)
    1:                 return;
    1:         }
    1: 
    1: #ifdef POLL_WITH_XCONNECTIONNUMBER
    1:         select_result = poll(fds, 1, kClipboardTimeout / 1000);
    1: #else
    1:         tv.tv_sec = 0;
    1:         tv.tv_usec = kClipboardTimeout;
    1:         select_result = select(cnumber, &select_set, NULL, NULL, &tv);
    1: #endif
    1:     } while (select_result == 1);
    1: 
    1: #ifdef DEBUG_CLIPBOARD
    1:     printf("exceeded clipboard timeout\n");
    1: #endif
    1: }
    1: 
    1: static void
    1: clipboard_contents_received(GtkClipboard     *clipboard,
    1:                             GtkSelectionData *selection_data,
    1:                             gpointer          data)
    1: {
 3233:     retrieval_context *context = static_cast<retrieval_context *>(data);
    1:     context->completed = PR_TRUE;
    1: 
    1:     if (selection_data->length >= 0)
    1:         context->data = gtk_selection_data_copy(selection_data);
    1: }
    1: 
    1: 
    1: static GtkSelectionData *
    1: wait_for_contents(GtkClipboard *clipboard, GdkAtom target)
    1: {
    1:     retrieval_context context;
    1:     gtk_clipboard_request_contents(clipboard, target,
    1:                                    clipboard_contents_received,
    1:                                    &context);
    1: 
    1:     wait_for_retrieval(clipboard, &context);
 3233:     return static_cast<GtkSelectionData *>(context.data);
    1: }
    1: 
    1: static void
    1: clipboard_text_received(GtkClipboard *clipboard,
    1:                         const gchar  *text,
    1:                         gpointer      data)
    1: {
 3233:     retrieval_context *context = static_cast<retrieval_context *>(data);
    1:     context->completed = PR_TRUE;
    1:     context->data = g_strdup(text);
    1: }
    1: 
    1: static gchar *
    1: wait_for_text(GtkClipboard *clipboard)
    1: {
    1:     retrieval_context context;
    1:     gtk_clipboard_request_text(clipboard, clipboard_text_received, &context);
    1: 
    1:     wait_for_retrieval(clipboard, &context);
 3233:     return static_cast<gchar *>(context.data);
    1: }
