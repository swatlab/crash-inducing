    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80467: #include "mozilla/Util.h"
80467: 
87729: #include "mozilla/layers/CompositorChild.h"
87729: #include "mozilla/layers/CompositorParent.h"
    1: #include "nsBaseWidget.h"
68668: #include "nsDeviceContext.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsGfxCIID.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsServiceManagerUtils.h"
    1: #include "nsIScreenManager.h"
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsISimpleEnumerator.h"
 8591: #include "nsIContent.h"
    1: #include "nsIServiceManager.h"
70337: #include "mozilla/Preferences.h"
38805: #include "BasicLayers.h"
40028: #include "LayerManagerOGL.h"
51658: #include "nsIXULRuntime.h"
60833: #include "nsIGfxInfo.h"
61041: #include "npapi.h"
87729: #include "base/thread.h"
33016: 
33016: #ifdef DEBUG
    1: #include "nsIObserver.h"
    1: 
    1: static void debug_RegisterPrefCallbacks();
    1: 
79445: static bool debug_InSecureKeyboardInputMode = false;
    1: #endif
    1: 
    1: #ifdef NOISY_WIDGET_LEAKS
    1: static PRInt32 gNumWidgets;
    1: #endif
    1: 
38805: using namespace mozilla::layers;
70337: using namespace mozilla;
87729: using base::Thread;
87729: using mozilla::ipc::AsyncChannel;
38805: 
 8591: nsIContent* nsBaseWidget::mLastRollup = nsnull;
 8591: 
    1: // nsBaseWidget
    1: NS_IMPL_ISUPPORTS1(nsBaseWidget, nsIWidget)
    1: 
    1: 
 8591: nsAutoRollup::nsAutoRollup()
 8591: {
 8591:   // remember if mLastRollup was null, and only clear it upon destruction
 8591:   // if so. This prevents recursive usage of nsAutoRollup from clearing
 8591:   // mLastRollup when it shouldn't.
 8591:   wasClear = !nsBaseWidget::mLastRollup;
 8591: }
 8591: 
 8591: nsAutoRollup::~nsAutoRollup()
 8591: {
 8591:   if (nsBaseWidget::mLastRollup && wasClear) {
 8591:     NS_RELEASE(nsBaseWidget::mLastRollup);
 8591:   }
 8591: }
 8591: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // nsBaseWidget constructor
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: nsBaseWidget::nsBaseWidget()
    1: : mClientData(nsnull)
46192: , mViewWrapperPtr(nsnull)
    1: , mEventCallback(nsnull)
46192: , mViewCallback(nsnull)
    1: , mContext(nsnull)
87729: , mCompositorThread(nsnull)
    1: , mCursor(eCursor_standard)
    1: , mWindowType(eWindowType_child)
    1: , mBorderStyle(eBorderStyle_none)
80486: , mOnDestroyCalled(false)
80486: , mUseAcceleratedRendering(false)
91135: , mForceLayersAcceleration(false)
80486: , mTemporarilyUseBasicLayerManager(false)
    1: , mBounds(0,0,0,0)
    1: , mOriginalBounds(nsnull)
30515: , mClipRectCount(0)
    1: , mZIndex(0)
    1: , mSizeMode(nsSizeMode_Normal)
48254: , mPopupLevel(ePopupLevelTop)
    1: {
    1: #ifdef NOISY_WIDGET_LEAKS
    1:   gNumWidgets++;
    1:   printf("WIDGETS+ = %d\n", gNumWidgets);
    1: #endif
    1: 
    1: #ifdef DEBUG
    1:     debug_RegisterPrefCallbacks();
    1: #endif
    1: }
    1: 
    1: 
94488: static void DestroyCompositor(CompositorParent* aCompositorParent,
94488:                               CompositorChild* aCompositorChild,
94488:                               Thread* aCompositorThread)
94488: {
94488:     aCompositorChild->Destroy();
94488:     delete aCompositorThread;
94488:     aCompositorParent->Release();
94488:     aCompositorChild->Release();
94488: }
94488: 
94488: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // nsBaseWidget destructor
    1: //
    1: //-------------------------------------------------------------------------
    1: nsBaseWidget::~nsBaseWidget()
    1: {
47767:   if (mLayerManager &&
47767:       mLayerManager->GetBackendType() == LayerManager::LAYERS_BASIC) {
47767:     static_cast<BasicLayerManager*>(mLayerManager.get())->ClearRetainerWidget();
47767:   }
47767: 
58810:   if (mLayerManager) {
58810:     mLayerManager->Destroy();
87729:     mLayerManager = nsnull;
87729:   }
87729: 
87729:   if (mCompositorChild) {
94488:     mCompositorChild->SendWillStop();
94488: 
94488:     // The call just made to SendWillStop can result in IPC from the
94488:     // CompositorParent to the CompositorChild (e.g. caused by the destruction
94488:     // of shared memory). We need to ensure this gets processed by the
94488:     // CompositorChild before it gets destroyed. It suffices to ensure that
94488:     // events already in the MessageLoop get processed before the
94488:     // CompositorChild is destroyed, so we add a task to the MessageLoop to
94488:     // handle compositor desctruction.
94488:     MessageLoop::current()->
94488:       PostTask(FROM_HERE,
94488:                NewRunnableFunction(DestroyCompositor, mCompositorParent,
94488:                                    mCompositorChild, mCompositorThread));
94488:     // The DestroyCompositor task we just added to the MessageLoop will handle
94488:     // releasing mCompositorParent and mCompositorChild.
94488:     mCompositorParent.forget();
94488:     mCompositorChild.forget();
58810:   }
58810: 
    1: #ifdef NOISY_WIDGET_LEAKS
    1:   gNumWidgets--;
    1:   printf("WIDGETS- = %d\n", gNumWidgets);
    1: #endif
    1: 
    1:   NS_IF_RELEASE(mContext);
    1:   delete mOriginalBounds;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Basic create.
    1: //
    1: //-------------------------------------------------------------------------
    1: void nsBaseWidget::BaseCreate(nsIWidget *aParent,
23738:                               const nsIntRect &aRect,
    1:                               EVENT_CALLBACK aHandleEventFunction,
68668:                               nsDeviceContext *aContext,
    1:                               nsWidgetInitData *aInitData)
    1: {
    1:   // save the event callback function
    1:   mEventCallback = aHandleEventFunction;
    1:   
    1:   // keep a reference to the device context
    1:   if (aContext) {
    1:     mContext = aContext;
    1:     NS_ADDREF(mContext);
    1:   }
    1:   else {
68667:     mContext = new nsDeviceContext();
68667:     NS_ADDREF(mContext);
    1:     mContext->Init(nsnull);
    1:   }
    1: 
    1:   if (nsnull != aInitData) {
33357:     mWindowType = aInitData->mWindowType;
33357:     mBorderStyle = aInitData->mBorderStyle;
48254:     mPopupLevel = aInitData->mPopupLevel;
    1:   }
    1: 
    1:   if (aParent) {
    1:     aParent->AddChild(this);
    1:   }
    1: }
    1: 
79445: NS_IMETHODIMP nsBaseWidget::CaptureMouse(bool aCapture)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Accessor functions to get/set the client data
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP nsBaseWidget::GetClientData(void*& aClientData)
    1: {
    1:   aClientData = mClientData;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsBaseWidget::SetClientData(void* aClientData)
    1: {
    1:   mClientData = aClientData;
    1:   return NS_OK;
    1: }
    1: 
51049: already_AddRefed<nsIWidget>
51049: nsBaseWidget::CreateChild(const nsIntRect  &aRect,
51049:                           EVENT_CALLBACK   aHandleEventFunction,
68668:                           nsDeviceContext *aContext,
51049:                           nsWidgetInitData *aInitData,
79445:                           bool             aForceUseIWidgetParent)
51049: {
51049:   nsIWidget* parent = this;
51049:   nsNativeWidget nativeParent = nsnull;
51049: 
51049:   if (!aForceUseIWidgetParent) {
51049:     // Use only either parent or nativeParent, not both, to match
51049:     // existing code.  Eventually Create() should be divested of its
51049:     // nativeWidget parameter.
51049:     nativeParent = parent ? parent->GetNativeData(NS_NATIVE_WIDGET) : nsnull;
51049:     parent = nativeParent ? nsnull : parent;
51049:     NS_ABORT_IF_FALSE(!parent || !nativeParent, "messed up logic");
51049:   }
51049: 
51049:   nsCOMPtr<nsIWidget> widget;
51049:   if (aInitData && aInitData->mWindowType == eWindowType_popup) {
51049:     widget = AllocateChildPopupWidget();
51049:   } else {
51049:     static NS_DEFINE_IID(kCChildCID, NS_CHILD_CID);
51049:     widget = do_CreateInstance(kCChildCID);
51049:   }
51049: 
51049:   if (widget &&
51049:       NS_SUCCEEDED(widget->Create(parent, nativeParent, aRect,
51049:                                   aHandleEventFunction,
80842:                                   aContext, aInitData))) {
51049:     return widget.forget();
51049:   }
51049: 
51049:   return nsnull;
51049: }
51049: 
89114: NS_IMETHODIMP
89114: nsBaseWidget::SetEventCallback(EVENT_CALLBACK aEventFunction,
89114:                                nsDeviceContext *aContext)
89114: {
89114:   NS_ASSERTION(aEventFunction, "Must have valid event callback!");
89114: 
89114:   mEventCallback = aEventFunction;
89114: 
89114:   if (aContext) {
89114:     NS_IF_RELEASE(mContext);
89114:     mContext = aContext;
89114:     NS_ADDREF(mContext);
89114:   }
89114: 
89114:   return NS_OK;
89114: }
89114: 
46192: // Attach a view to our widget which we'll send events to. 
46192: NS_IMETHODIMP
46192: nsBaseWidget::AttachViewToTopLevel(EVENT_CALLBACK aViewEventFunction,
68668:                                    nsDeviceContext *aContext)
46192: {
52189:   NS_ASSERTION((mWindowType == eWindowType_toplevel ||
52189:                 mWindowType == eWindowType_dialog ||
62248:                 mWindowType == eWindowType_invisible ||
62248:                 mWindowType == eWindowType_child),
62248:                "Can't attach to window of that type");
46192: 
46192:   mViewCallback = aViewEventFunction;
46192: 
46192:   if (aContext) {
46192:     if (mContext) {
46192:       NS_IF_RELEASE(mContext);
46192:     }
46192:     mContext = aContext;
46192:     NS_ADDREF(mContext);
46192:   }
46192: 
46192:   return NS_OK;
46192: }
46192: 
46192: ViewWrapper* nsBaseWidget::GetAttachedViewPtr()
46192:  {
46192:    return mViewWrapperPtr;
46192:  }
46192:  
46192: NS_IMETHODIMP nsBaseWidget::SetAttachedViewPtr(ViewWrapper* aViewWrapper)
46192:  {
46192:    mViewWrapperPtr = aViewWrapper;
46192:    return NS_OK;
46192:  }
46192: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Close this nsBaseWidget
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsBaseWidget::Destroy()
    1: {
    1:   // Just in case our parent is the only ref to us
    1:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
    1:   // disconnect from the parent
    1:   nsIWidget *parent = GetParent();
    1:   if (parent) {
    1:     parent->RemoveChild(this);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Set this nsBaseWidget's parent
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP nsBaseWidget::SetParent(nsIWidget* aNewParent)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get this nsBaseWidget parent
    1: //
    1: //-------------------------------------------------------------------------
    1: nsIWidget* nsBaseWidget::GetParent(void)
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
19295: // Get this nsBaseWidget top level widget
19295: //
19295: //-------------------------------------------------------------------------
31093: nsIWidget* nsBaseWidget::GetTopLevelWidget()
19295: {
22805:   nsIWidget *topLevelWidget = nsnull, *widget = this;
19295:   while (widget) {
19295:     topLevelWidget = widget;
19295:     widget = widget->GetParent();
19295:   }
19295:   return topLevelWidget;
19295: }
19295: 
19295: //-------------------------------------------------------------------------
19295: //
14886: // Get this nsBaseWidget's top (non-sheet) parent (if it's a sheet)
14886: //
14886: //-------------------------------------------------------------------------
14886: nsIWidget* nsBaseWidget::GetSheetWindowParent(void)
14886: {
14886:   return nsnull;
14886: }
14886: 
50782: float nsBaseWidget::GetDPI()
50782: {
50782:   return 96.0f;
50782: }
50782: 
50782: double nsBaseWidget::GetDefaultScale()
50782: {
50782:   return 1.0;
50782: }
50782: 
14886: //-------------------------------------------------------------------------
14886: //
    1: // Add a child to the list of children
    1: //
    1: //-------------------------------------------------------------------------
    1: void nsBaseWidget::AddChild(nsIWidget* aChild)
    1: {
    1:   NS_PRECONDITION(!aChild->GetNextSibling() && !aChild->GetPrevSibling(),
    1:                   "aChild not properly removed from its old child list");
    1:   
    1:   if (!mFirstChild) {
    1:     mFirstChild = mLastChild = aChild;
    1:   } else {
    1:     // append to the list
    1:     NS_ASSERTION(mLastChild, "Bogus state");
    1:     NS_ASSERTION(!mLastChild->GetNextSibling(), "Bogus state");
    1:     mLastChild->SetNextSibling(aChild);
    1:     aChild->SetPrevSibling(mLastChild);
    1:     mLastChild = aChild;
    1:   }
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Remove a child from the list of children
    1: //
    1: //-------------------------------------------------------------------------
    1: void nsBaseWidget::RemoveChild(nsIWidget* aChild)
    1: {
    1:   NS_ASSERTION(aChild->GetParent() == this, "Not one of our kids!");
    1:   
    1:   if (mLastChild == aChild) {
    1:     mLastChild = mLastChild->GetPrevSibling();
    1:   }
    1:   if (mFirstChild == aChild) {
    1:     mFirstChild = mFirstChild->GetNextSibling();
    1:   }
    1: 
    1:   // Now remove from the list.  Make sure that we pass ownership of the tail
    1:   // of the list correctly before we have aChild let go of it.
    1:   nsIWidget* prev = aChild->GetPrevSibling();
    1:   nsIWidget* next = aChild->GetNextSibling();
    1:   if (prev) {
    1:     prev->SetNextSibling(next);
    1:   }
    1:   if (next) {
    1:     next->SetPrevSibling(prev);
    1:   }
    1:   
    1:   aChild->SetNextSibling(nsnull);
    1:   aChild->SetPrevSibling(nsnull);
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Sets widget's position within its parent's child list.
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP nsBaseWidget::SetZIndex(PRInt32 aZIndex)
    1: {
    1:   // Hold a ref to ourselves just in case, since we're going to remove
    1:   // from our parent.
    1:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
    1:   
    1:   mZIndex = aZIndex;
    1: 
    1:   // reorder this child in its parent's list.
 3233:   nsBaseWidget* parent = static_cast<nsBaseWidget*>(GetParent());
    1:   if (parent) {
    1:     parent->RemoveChild(this);
    1:     // Scope sib outside the for loop so we can check it afterward
    1:     nsIWidget* sib = parent->GetFirstChild();
    1:     for ( ; sib; sib = sib->GetNextSibling()) {
    1:       PRInt32 childZIndex;
    1:       if (NS_SUCCEEDED(sib->GetZIndex(&childZIndex))) {
    1:         if (aZIndex < childZIndex) {
    1:           // Insert ourselves before sib
    1:           nsIWidget* prev = sib->GetPrevSibling();
    1:           mNextSibling = sib;
    1:           mPrevSibling = prev;
    1:           sib->SetPrevSibling(this);
    1:           if (prev) {
    1:             prev->SetNextSibling(this);
    1:           } else {
    1:             NS_ASSERTION(sib == parent->mFirstChild, "Broken child list");
    1:             // We've taken ownership of sib, so it's safe to have parent let
    1:             // go of it
    1:             parent->mFirstChild = this;
    1:           }
80486:           PlaceBehind(eZPlacementBelow, sib, false);
    1:           break;
    1:         }
    1:       }
    1:     }
    1:     // were we added to the list?
    1:     if (!sib) {
    1:       parent->AddChild(this);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Gets widget's position within its parent's child list.
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP nsBaseWidget::GetZIndex(PRInt32* aZIndex)
    1: {
    1:   *aZIndex = mZIndex;
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Places widget behind the given widget (platforms must override)
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP nsBaseWidget::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
79445:                                         nsIWidget *aWidget, bool aActivate)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Maximize, minimize or restore the window. The BaseWidget implementation
    1: // merely stores the state.
    1: //
    1: //-------------------------------------------------------------------------
51547: NS_IMETHODIMP nsBaseWidget::SetSizeMode(PRInt32 aMode)
51547: {
30075:   if (aMode == nsSizeMode_Normal ||
30075:       aMode == nsSizeMode_Minimized ||
30075:       aMode == nsSizeMode_Maximized ||
30075:       aMode == nsSizeMode_Fullscreen) {
    1: 
    1:     mSizeMode = (nsSizeMode) aMode;
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_ILLEGAL_VALUE;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get the size mode (minimized, maximized, that sort of thing...)
    1: //
    1: //-------------------------------------------------------------------------
51547: NS_IMETHODIMP nsBaseWidget::GetSizeMode(PRInt32* aMode)
51547: {
    1:   *aMode = mSizeMode;
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get the foreground color
    1: //
    1: //-------------------------------------------------------------------------
    1: nscolor nsBaseWidget::GetForegroundColor(void)
    1: {
    1:   return mForeground;
    1: }
    1: 
    1:     
    1: //-------------------------------------------------------------------------
    1: //
    1: // Set the foreground color
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsBaseWidget::SetForegroundColor(const nscolor &aColor)
    1: {
    1:   mForeground = aColor;
    1:   return NS_OK;
    1: }
    1: 
    1:     
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get the background color
    1: //
    1: //-------------------------------------------------------------------------
    1: nscolor nsBaseWidget::GetBackgroundColor(void)
    1: {
    1:   return mBackground;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Set the background color
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsBaseWidget::SetBackgroundColor(const nscolor &aColor)
    1: {
    1:   mBackground = aColor;
    1:   return NS_OK;
    1: }
    1:      
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get this component cursor
    1: //
    1: //-------------------------------------------------------------------------
    1: nsCursor nsBaseWidget::GetCursor()
    1: {
    1:   return mCursor;
    1: }
    1: 
    1: NS_METHOD nsBaseWidget::SetCursor(nsCursor aCursor)
    1: {
    1:   mCursor = aCursor; 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsBaseWidget::SetCursor(imgIContainer* aCursor,
    1:                                       PRUint32 aHotspotX, PRUint32 aHotspotY)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1:     
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get the window type for this widget
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP nsBaseWidget::GetWindowType(nsWindowType& aWindowType)
    1: {
    1:   aWindowType = mWindowType;
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Window transparency methods
    1: //
    1: //-------------------------------------------------------------------------
    1: 
16601: void nsBaseWidget::SetTransparencyMode(nsTransparencyMode aMode) {
    1: }
    1: 
16601: nsTransparencyMode nsBaseWidget::GetTransparencyMode() {
16601:   return eTransparencyOpaque;
    1: }
    1: 
79445: bool
30515: nsBaseWidget::StoreWindowClipRegion(const nsTArray<nsIntRect>& aRects)
30515: {
30688:   if (mClipRects && mClipRectCount == aRects.Length() &&
30688:       memcmp(mClipRects, aRects.Elements(), sizeof(nsIntRect)*mClipRectCount) == 0)
80486:     return false;
30688: 
30515:   mClipRectCount = aRects.Length();
30515:   mClipRects = new nsIntRect[mClipRectCount];
30515:   if (mClipRects) {
30515:     memcpy(mClipRects, aRects.Elements(), sizeof(nsIntRect)*mClipRectCount);
30515:   }
80486:   return true;
30515: }
30515: 
30515: void
30515: nsBaseWidget::GetWindowClipRegion(nsTArray<nsIntRect>* aRects)
30515: {
30515:   if (mClipRects) {
30515:     aRects->AppendElements(mClipRects.get(), mClipRectCount);
30515:   } else {
30515:     aRects->AppendElement(nsIntRect(0, 0, mBounds.width, mBounds.height));
30515:   }
30515: }
30515: 
    1: //-------------------------------------------------------------------------
    1: //
20467: // Set window shadow style
20467: //
20467: //-------------------------------------------------------------------------
20467: 
20467: NS_IMETHODIMP nsBaseWidget::SetWindowShadowStyle(PRInt32 aMode)
20467: {
20467:   return NS_ERROR_NOT_IMPLEMENTED;
20467: }
20467: 
20467: //-------------------------------------------------------------------------
20467: //
    1: // Hide window borders/decorations for this widget
    1: //
    1: //-------------------------------------------------------------------------
79445: NS_IMETHODIMP nsBaseWidget::HideWindowChrome(bool aShouldHide)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Put the window into full-screen mode
    1: //
    1: //-------------------------------------------------------------------------
79445: NS_IMETHODIMP nsBaseWidget::MakeFullScreen(bool aFullScreen)
    1: {
30004:   HideWindowChrome(aFullScreen);
29944: 
    1:   if (aFullScreen) {
    1:     if (!mOriginalBounds)
23738:       mOriginalBounds = new nsIntRect();
    1:     GetScreenBounds(*mOriginalBounds);
    1: 
    1:     // Move to top-left corner of screen and size to the screen dimensions
    1:     nsCOMPtr<nsIScreenManager> screenManager;
    1:     screenManager = do_GetService("@mozilla.org/gfx/screenmanager;1"); 
    1:     NS_ASSERTION(screenManager, "Unable to grab screenManager.");
    1:     if (screenManager) {
    1:       nsCOMPtr<nsIScreen> screen;
    1:       screenManager->ScreenForRect(mOriginalBounds->x, mOriginalBounds->y,
    1:                                    mOriginalBounds->width, mOriginalBounds->height,
    1:                                    getter_AddRefs(screen));
    1:       if (screen) {
    1:         PRInt32 left, top, width, height;
    1:         if (NS_SUCCEEDED(screen->GetRect(&left, &top, &width, &height))) {
80486:           Resize(left, top, width, height, true);
    1:         }
    1:       }
    1:     }
    1: 
    1:   } else if (mOriginalBounds) {
    1:     Resize(mOriginalBounds->x, mOriginalBounds->y, mOriginalBounds->width,
80486:            mOriginalBounds->height, true);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
38805: nsBaseWidget::AutoLayerManagerSetup::AutoLayerManagerSetup(
47746:     nsBaseWidget* aWidget, gfxContext* aTarget,
47746:     BasicLayerManager::BufferMode aDoubleBuffering)
38805:   : mWidget(aWidget)
38805: {
38805:   BasicLayerManager* manager =
63893:     static_cast<BasicLayerManager*>(mWidget->GetLayerManager());
38805:   if (manager) {
40028:     NS_ASSERTION(manager->GetBackendType() == LayerManager::LAYERS_BASIC,
40028:       "AutoLayerManagerSetup instantiated for non-basic layer backend!");
47746:     manager->SetDefaultTarget(aTarget, aDoubleBuffering);
38805:   }
38805: }
38805: 
38805: nsBaseWidget::AutoLayerManagerSetup::~AutoLayerManagerSetup()
38805: {
38805:   BasicLayerManager* manager =
63893:     static_cast<BasicLayerManager*>(mWidget->GetLayerManager());
38805:   if (manager) {
40028:     NS_ASSERTION(manager->GetBackendType() == LayerManager::LAYERS_BASIC,
40028:       "AutoLayerManagerSetup instantiated for non-basic layer backend!");
47746:     manager->SetDefaultTarget(nsnull, BasicLayerManager::BUFFER_NONE);
38805:   }
38805: }
38805: 
55858: nsBaseWidget::AutoUseBasicLayerManager::AutoUseBasicLayerManager(nsBaseWidget* aWidget)
55858:   : mWidget(aWidget)
55858: {
80486:   mWidget->mTemporarilyUseBasicLayerManager = true;
55858: }
55858: 
55858: nsBaseWidget::AutoUseBasicLayerManager::~AutoUseBasicLayerManager()
55858: {
80486:   mWidget->mTemporarilyUseBasicLayerManager = false;
55858: }
55858: 
79445: bool
53686: nsBaseWidget::GetShouldAccelerate()
38805: {
93982: #if defined(XP_WIN) || defined(ANDROID) || (MOZ_PLATFORM_MAEMO > 5) || defined(MOZ_GL_PROVIDER)
79445:   bool accelerateByDefault = true;
61002: #elif defined(XP_MACOSX)
61002: /* quickdraw plugins don't work with OpenGL so we need to avoid OpenGL when we want to support
61002:  * them. e.g. 10.5 */
61002: # if defined(NP_NO_QUICKDRAW)
79445:   bool accelerateByDefault = true;
61876: 
61876:   // 10.6.2 and lower have a bug involving textures and pixel buffer objects
61876:   // that caused bug 629016, so we don't allow OpenGL-accelerated layers on
61876:   // those versions of the OS.
61876:   // This will still let full-screen video be accelerated on OpenGL, because
61876:   // that XUL widget opts in to acceleration, but that's probably OK.
61876:   SInt32 major, minor, bugfix;
61876:   OSErr err1 = ::Gestalt(gestaltSystemVersionMajor, &major);
61876:   OSErr err2 = ::Gestalt(gestaltSystemVersionMinor, &minor);
61876:   OSErr err3 = ::Gestalt(gestaltSystemVersionBugFix, &bugfix);
61876:   if (err1 == noErr && err2 == noErr && err3 == noErr) {
61876:     if (major == 10 && minor == 6) {
61876:       if (bugfix <= 2) {
80486:         accelerateByDefault = false;
61876:       }
61876:     }
61876:   }
61876: 
61002: # else
79445:   bool accelerateByDefault = false;
61002: # endif
61002: 
60324: #else
79445:   bool accelerateByDefault = false;
60324: #endif
51655: 
60324:   // we should use AddBoolPrefVarCache
79445:   bool disableAcceleration =
79445:     Preferences::GetBool("layers.acceleration.disabled", false);
91135:   mForceLayersAcceleration =
79445:     Preferences::GetBool("layers.acceleration.force-enabled", false);
42226: 
51978:   const char *acceleratedEnv = PR_GetEnv("MOZ_ACCELERATED");
51978:   accelerateByDefault = accelerateByDefault ||
51978:                         (acceleratedEnv && (*acceleratedEnv != '0'));
51978: 
51658:   nsCOMPtr<nsIXULRuntime> xr = do_GetService("@mozilla.org/xre/runtime;1");
79445:   bool safeMode = false;
51658:   if (xr)
51658:     xr->GetInSafeMode(&safeMode);
51658: 
76848:   bool whitelisted = false;
76848: 
76848:   nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
76848:   if (gfxInfo) {
78440:     // bug 655578: on X11 at least, we must always call GetData (even if we don't need that information)
78440:     // as that's what causes GfxInfo initialization which kills the zombie 'glxtest' process.
78440:     // initially we relied on the fact that GetFeatureStatus calls GetData for us, but bug 681026 showed
78440:     // that assumption to be unsafe.
78440:     gfxInfo->GetData();
78440: 
76848:     PRInt32 status;
76848:     if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_OPENGL_LAYERS, &status))) {
76848:       if (status == nsIGfxInfo::FEATURE_NO_INFO) {
76848:         whitelisted = true;
76848:       }
76848:     }
76848:   }
76848: 
51658:   if (disableAcceleration || safeMode)
80486:     return false;
53686: 
91135:   if (mForceLayersAcceleration)
80486:     return true;
60833:   
76848:   if (!whitelisted) {
60833:     NS_WARNING("OpenGL-accelerated layers are not supported on this system.");
80486:     return false;
60833:   }
60833: 
60833:   if (accelerateByDefault)
80486:     return true;
53686: 
60324:   /* use the window acceleration flag */
53686:   return mUseAcceleratedRendering;
53686: }
53686: 
87729: void nsBaseWidget::CreateCompositor()
87729: {
87729:   mCompositorThread = new Thread("CompositorThread");
93083:   mCompositorParent = new CompositorParent(this, mCompositorThread);
87729:   if (mCompositorThread->Start()) {
87729:     LayerManager* lm = CreateBasicLayerManager();
87729:     MessageLoop *childMessageLoop = mCompositorThread->message_loop();
87729:     mCompositorChild = new CompositorChild(lm);
87729:     AsyncChannel *parentChannel = mCompositorParent->GetIPCChannel();
87729:     AsyncChannel::Side childSide = mozilla::ipc::AsyncChannel::Child;
87729:     mCompositorChild->Open(parentChannel, childMessageLoop, childSide);
87729:     PLayersChild* shadowManager =
87729:       mCompositorChild->SendPLayersConstructor(LayerManager::LAYERS_OPENGL);
87729: 
87729:     if (shadowManager) {
87729:       ShadowLayerForwarder* lf = lm->AsShadowForwarder();
87729:       if (!lf) {
87729:         delete lm;
87729:         mCompositorChild = nsnull;
89233:         return;
87729:       }
87729:       lf->SetShadowManager(shadowManager);
87729:       lf->SetParentBackendType(LayerManager::LAYERS_OPENGL);
87729: 
87729:       mLayerManager = lm;
87729:     } else {
87729:       NS_WARNING("fail to construct LayersChild");
87729:       delete lm;
87729:       mCompositorChild = nsnull;
87729:     }
87729:   }
87729: }
87729: 
75149: LayerManager* nsBaseWidget::GetLayerManager(PLayersChild* aShadowManager,
75149:                                             LayersBackend aBackendHint,
75149:                                             LayerManagerPersistence aPersistence,
58812:                                             bool* aAllowRetaining)
58812: {
53686:   if (!mLayerManager) {
53686: 
53686:     mUseAcceleratedRendering = GetShouldAccelerate();
51655: 
51655:     if (mUseAcceleratedRendering) {
87729: 
87729:       // Try to use an async compositor first, if possible
87729:       bool useCompositor =
87729:         Preferences::GetBool("layers.offmainthreadcomposition.enabled", false);
87729:       if (useCompositor) {
87729:         // e10s uses the parameter to pass in the shadow manager from the TabChild
87729:         // so we don't expect to see it there since this doesn't support e10s.
87729:         NS_ASSERTION(aShadowManager == nsnull, "Async Compositor not supported with e10s");
87729:         CreateCompositor();
87729:       }
87729: 
87729:       if (!mLayerManager) {
75149:         nsRefPtr<LayerManagerOGL> layerManager = new LayerManagerOGL(this);
40028:         /**
40028:          * XXX - On several OSes initialization is expected to fail for now.
87729:          * If we'd get a non-basic layer manager they'd crash. This is ok though
40028:          * since on those platforms it will fail. Anyone implementing new
40028:          * platforms on LayerManagerOGL should ensure their widget is able to
40028:          * deal with it though!
40028:          */
91135: 
91135:         if (layerManager->Initialize(mForceLayersAcceleration)) {
40028:           mLayerManager = layerManager;
40028:         }
40028:       }
87729:     }
40028:     if (!mLayerManager) {
55858:       mBasicLayerManager = mLayerManager = CreateBasicLayerManager();
38805:     }
40028:   }
55858:   if (mTemporarilyUseBasicLayerManager && !mBasicLayerManager) {
55858:     mBasicLayerManager = CreateBasicLayerManager();
55858:   }
55858:   LayerManager* usedLayerManager = mTemporarilyUseBasicLayerManager ?
55858:                                      mBasicLayerManager : mLayerManager;
55858:   if (aAllowRetaining) {
55858:     *aAllowRetaining = (usedLayerManager == mLayerManager);
55858:   }
55858:   return usedLayerManager;
38805: }
38805: 
54111: BasicLayerManager* nsBaseWidget::CreateBasicLayerManager()
54111: {
54111:       return new BasicShadowLayerManager(this);
54111: }
54111: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Return the used device context
    1: //
    1: //-------------------------------------------------------------------------
68668: nsDeviceContext* nsBaseWidget::GetDeviceContext() 
    1: {
    1:   return mContext; 
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get the thebes surface
    1: //
    1: //-------------------------------------------------------------------------
    1: gfxASurface *nsBaseWidget::GetThebesSurface()
    1: {
    1:   // in theory we should get our parent's surface,
    1:   // clone it, and set a device offset before returning
    1:   return nsnull;
    1: }
 5551: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Destroy the window
    1: //
    1: //-------------------------------------------------------------------------
    1: void nsBaseWidget::OnDestroy()
    1: {
80842:   // release references to device context and app shell
    1:   NS_IF_RELEASE(mContext);
    1: }
    1: 
    1: NS_METHOD nsBaseWidget::SetWindowClass(const nsAString& xulWinType)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
83107: NS_METHOD nsBaseWidget::MoveClient(PRInt32 aX, PRInt32 aY)
83107: {
83107:   nsIntPoint clientOffset(GetClientOffset());
83107:   aX -= clientOffset.x;
83107:   aY -= clientOffset.y;
83107:   return Move(aX, aY);
83107: }
83107: 
83107: NS_METHOD nsBaseWidget::ResizeClient(PRInt32 aWidth,
83107:                                      PRInt32 aHeight,
83107:                                      bool aRepaint)
83107: {
83107:   NS_ASSERTION((aWidth >=0) , "Negative width passed to ResizeClient");
83107:   NS_ASSERTION((aHeight >=0), "Negative height passed to ResizeClient");
83107: 
83107:   nsIntRect clientBounds;
83107:   GetClientBounds(clientBounds);
83107:   aWidth = mBounds.width + (aWidth - clientBounds.width);
83107:   aHeight = mBounds.height + (aHeight - clientBounds.height);
83107: 
83107:   return Resize(aWidth, aHeight, aRepaint);
83107: }
83107: 
83107: NS_METHOD nsBaseWidget::ResizeClient(PRInt32 aX,
83107:                                      PRInt32 aY,
83107:                                      PRInt32 aWidth,
83107:                                      PRInt32 aHeight,
83107:                                      bool aRepaint)
83107: {
83107:   NS_ASSERTION((aWidth >=0) , "Negative width passed to ResizeClient");
83107:   NS_ASSERTION((aHeight >=0), "Negative height passed to ResizeClient");
83107: 
83107:   nsIntRect clientBounds;
83107:   GetClientBounds(clientBounds);
83107:   aWidth = mBounds.width + (aWidth - clientBounds.width);
83107:   aHeight = mBounds.height + (aHeight - clientBounds.height);
83107: 
83107:   nsIntPoint clientOffset(GetClientOffset());
83107:   aX -= clientOffset.x;
83107:   aY -= clientOffset.y;
83107: 
83107:   return Resize(aX, aY, aWidth, aHeight, aRepaint);
83107: }
83107: 
46198: //-------------------------------------------------------------------------
46198: //
46198: // Bounds
46198: //
46198: //-------------------------------------------------------------------------
46198: 
    1: /**
    1: * If the implementation of nsWindow supports borders this method MUST be overridden
    1: *
    1: **/
23738: NS_METHOD nsBaseWidget::GetClientBounds(nsIntRect &aRect)
    1: {
    1:   return GetBounds(aRect);
    1: }
    1: 
    1: /**
    1: * If the implementation of nsWindow supports borders this method MUST be overridden
    1: *
    1: **/
23738: NS_METHOD nsBaseWidget::GetBounds(nsIntRect &aRect)
    1: {
    1:   aRect = mBounds;
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1: * If the implementation of nsWindow uses a local coordinate system within the window,
    1: * this method must be overridden
    1: *
    1: **/
23738: NS_METHOD nsBaseWidget::GetScreenBounds(nsIntRect &aRect)
    1: {
    1:   return GetBounds(aRect);
    1: }
    1: 
48256: nsIntPoint nsBaseWidget::GetClientOffset()
46192: {
48256:   return nsIntPoint(0, 0);
46192: }
46192: 
23738: NS_METHOD nsBaseWidget::SetBounds(const nsIntRect &aRect)
    1: {
    1:   mBounds = aRect;
    1: 
    1:   return NS_OK;
    1: }
    1: 
46198: NS_IMETHODIMP
46198: nsBaseWidget::GetNonClientMargins(nsIntMargin &margins)
46198: {
46198:   return NS_ERROR_NOT_IMPLEMENTED;
46198: }
46198:  
46198: NS_IMETHODIMP
46198: nsBaseWidget::SetNonClientMargins(nsIntMargin &margins)
46198: {
46198:   return NS_ERROR_NOT_IMPLEMENTED;
46198: }
46198: 
79445: NS_METHOD nsBaseWidget::EnableDragDrop(bool aEnable)
    1: {
    1:   return NS_OK;
    1: }
    1: 
79445: NS_METHOD nsBaseWidget::SetModal(bool aModal)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBaseWidget::GetAttention(PRInt32 aCycleCount) {
    1:     return NS_OK;
    1: }
    1: 
79445: bool
27993: nsBaseWidget::HasPendingInputEvent()
27993: {
80486:   return false;
27993: }
27993: 
    1: NS_IMETHODIMP
    1: nsBaseWidget::SetIcon(const nsAString&)
    1: {
    1:   return NS_OK;
    1: }
    1: 
 6348: NS_IMETHODIMP
 6348: nsBaseWidget::BeginSecureKeyboardInput()
 6348: {
 6348: #ifdef DEBUG
 6348:   NS_ASSERTION(!debug_InSecureKeyboardInputMode, "Attempting to nest call to BeginSecureKeyboardInput!");
80486:   debug_InSecureKeyboardInputMode = true;
 6348: #endif
 6348:   return NS_OK;
 6348: }
 6348: 
 6348: NS_IMETHODIMP
 6348: nsBaseWidget::EndSecureKeyboardInput()
 6348: {
 6348: #ifdef DEBUG
 6348:   NS_ASSERTION(debug_InSecureKeyboardInputMode, "Calling EndSecureKeyboardInput when it hasn't been enabled!");
80486:   debug_InSecureKeyboardInputMode = false;
 6348: #endif
 6348:   return NS_OK;
 6348: }
 6348: 
 7242: NS_IMETHODIMP
79445: nsBaseWidget::SetWindowTitlebarColor(nscolor aColor, bool aActive)
 7242: {
 7242:   return NS_ERROR_NOT_IMPLEMENTED;
 7242: }
 7242: 
79445: bool
16520: nsBaseWidget::ShowsResizeIndicator(nsIntRect* aResizerRect)
16520: {
80486:   return false;
16520: }
16520: 
33016: NS_IMETHODIMP
79445: nsBaseWidget::SetAcceleratedRendering(bool aEnabled)
40028: {
40028:   if (mUseAcceleratedRendering == aEnabled) {
40028:     return NS_OK;
40028:   }
40028:   mUseAcceleratedRendering = aEnabled;
58810:   if (mLayerManager) {
58810:     mLayerManager->Destroy();
58810:   }
40028:   mLayerManager = NULL;
40028:   return NS_OK;
40028: }
40028: 
79445: bool
40028: nsBaseWidget::GetAcceleratedRendering()
40028: {
40028:   return mUseAcceleratedRendering;
40028: }
40028: 
48711: NS_METHOD nsBaseWidget::RegisterTouchWindow()
48711: {
48711:   return NS_ERROR_NOT_IMPLEMENTED;
48711: }
48711: 
48711: NS_METHOD nsBaseWidget::UnregisterTouchWindow()
48711: {
48711:   return NS_ERROR_NOT_IMPLEMENTED;
48711: }
48711: 
40028: NS_IMETHODIMP
33016: nsBaseWidget::OverrideSystemMouseScrollSpeed(PRInt32 aOriginalDelta,
79445:                                              bool aIsHorizontal,
33016:                                              PRInt32 &aOverriddenDelta)
33016: {
33016:   aOverriddenDelta = aOriginalDelta;
33016: 
33016:   const char* kPrefNameOverrideEnabled =
33016:     "mousewheel.system_scroll_override_on_root_content.enabled";
79445:   bool isOverrideEnabled =
79445:     Preferences::GetBool(kPrefNameOverrideEnabled, false);
70337:   if (!isOverrideEnabled) {
33016:     return NS_OK;
33016:   }
33016: 
33016:   nsCAutoString factorPrefName(
33016:     "mousewheel.system_scroll_override_on_root_content.");
33016:   if (aIsHorizontal) {
33016:     factorPrefName.AppendLiteral("horizontal.");
33016:   } else {
33016:     factorPrefName.AppendLiteral("vertical.");
33016:   }
33016:   factorPrefName.AppendLiteral("factor");
70337:   PRInt32 iFactor = Preferences::GetInt(factorPrefName.get(), 0);
33016:   // The pref value must be larger than 100, otherwise, we don't override the
33016:   // delta value.
70337:   if (iFactor <= 100) {
33016:     return NS_OK;
33016:   }
33016:   double factor = (double)iFactor / 100;
33016:   aOverriddenDelta = PRInt32(NS_round((double)aOriginalDelta * factor));
33016: 
33016:   return NS_OK;
33016: }
33016: 
 7242: 
    1: /**
    1:  * Modifies aFile to point at an icon file with the given name and suffix.  The
    1:  * suffix may correspond to a file extension with leading '.' if appropriate.
    1:  * Returns true if the icon file exists and can be read.
    1:  */
79445: static bool
    1: ResolveIconNameHelper(nsILocalFile *aFile,
    1:                       const nsAString &aIconName,
    1:                       const nsAString &aIconSuffix)
    1: {
    1:   aFile->Append(NS_LITERAL_STRING("icons"));
    1:   aFile->Append(NS_LITERAL_STRING("default"));
    1:   aFile->Append(aIconName + aIconSuffix);
    1: 
79445:   bool readable;
    1:   return NS_SUCCEEDED(aFile->IsReadable(&readable)) && readable;
    1: }
    1: 
    1: /**
    1:  * Resolve the given icon name into a local file object.  This method is
    1:  * intended to be called by subclasses of nsBaseWidget.  aIconSuffix is a
    1:  * platform specific icon file suffix (e.g., ".ico" under Win32).
    1:  *
    1:  * If no file is found matching the given parameters, then null is returned.
    1:  */
    1: void
    1: nsBaseWidget::ResolveIconName(const nsAString &aIconName,
    1:                               const nsAString &aIconSuffix,
    1:                               nsILocalFile **aResult)
    1: { 
    1:   *aResult = nsnull;
    1: 
    1:   nsCOMPtr<nsIProperties> dirSvc = do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID);
    1:   if (!dirSvc)
    1:     return;
    1: 
    1:   // first check auxilary chrome directories
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> dirs;
    1:   dirSvc->Get(NS_APP_CHROME_DIR_LIST, NS_GET_IID(nsISimpleEnumerator),
    1:               getter_AddRefs(dirs));
    1:   if (dirs) {
79445:     bool hasMore;
    1:     while (NS_SUCCEEDED(dirs->HasMoreElements(&hasMore)) && hasMore) {
    1:       nsCOMPtr<nsISupports> element;
    1:       dirs->GetNext(getter_AddRefs(element));
    1:       if (!element)
    1:         continue;
    1:       nsCOMPtr<nsILocalFile> file = do_QueryInterface(element);
    1:       if (!file)
    1:         continue;
    1:       if (ResolveIconNameHelper(file, aIconName, aIconSuffix)) {
    1:         NS_ADDREF(*aResult = file);
    1:         return;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // then check the main app chrome directory
    1: 
    1:   nsCOMPtr<nsILocalFile> file;
    1:   dirSvc->Get(NS_APP_CHROME_DIR, NS_GET_IID(nsILocalFile),
    1:               getter_AddRefs(file));
    1:   if (file && ResolveIconNameHelper(file, aIconName, aIconSuffix))
    1:     NS_ADDREF(*aResult = file);
    1: }
    1: 
 8892: NS_IMETHODIMP 
 8892: nsBaseWidget::BeginResizeDrag(nsGUIEvent* aEvent, PRInt32 aHorizontal, PRInt32 aVertical)
 8892: {
 8892:   return NS_ERROR_NOT_IMPLEMENTED;
 8892: }
 8892: 
47857: NS_IMETHODIMP
47857: nsBaseWidget::BeginMoveDrag(nsMouseEvent* aEvent)
47857: {
47857:   return NS_ERROR_NOT_IMPLEMENTED;
47857: }
47857: 
88239: PRUint32
88239: nsBaseWidget::GetGLFrameBufferFormat()
88239: {
88239:   if (mLayerManager &&
88239:       mLayerManager->GetBackendType() == LayerManager::LAYERS_OPENGL) {
88239:     // Assume that the default framebuffer has RGBA format.  Specific
88239:     // backends that know differently will override this method.
88239:     return LOCAL_GL_RGBA;
88239:   }
88239:   return LOCAL_GL_NONE;
88239: }
88239: 
    1: #ifdef DEBUG
    1: //////////////////////////////////////////////////////////////
    1: //
    1: // Convert a GUI event message code to a string.
    1: // Makes it a lot easier to debug events.
    1: //
    1: // See gtk/nsWidget.cpp and windows/nsWindow.cpp
    1: // for a DebugPrintEvent() function that uses
    1: // this.
    1: //
    1: //////////////////////////////////////////////////////////////
    1: /* static */ nsAutoString
    1: nsBaseWidget::debug_GuiEventToString(nsGUIEvent * aGuiEvent)
    1: {
    1:   NS_ASSERTION(nsnull != aGuiEvent,"cmon, null gui event.");
    1: 
    1:   nsAutoString eventName(NS_LITERAL_STRING("UNKNOWN"));
    1: 
    1: #define _ASSIGN_eventName(_value,_name)\
83428: case _value: eventName.AssignLiteral(_name) ; break
    1: 
    1:   switch(aGuiEvent->message)
    1:   {
    1:     _ASSIGN_eventName(NS_BLUR_CONTENT,"NS_BLUR_CONTENT");
    1:     _ASSIGN_eventName(NS_CREATE,"NS_CREATE");
    1:     _ASSIGN_eventName(NS_DESTROY,"NS_DESTROY");
    1:     _ASSIGN_eventName(NS_DRAGDROP_GESTURE,"NS_DND_GESTURE");
    1:     _ASSIGN_eventName(NS_DRAGDROP_DROP,"NS_DND_DROP");
    1:     _ASSIGN_eventName(NS_DRAGDROP_ENTER,"NS_DND_ENTER");
    1:     _ASSIGN_eventName(NS_DRAGDROP_EXIT,"NS_DND_EXIT");
    1:     _ASSIGN_eventName(NS_DRAGDROP_OVER,"NS_DND_OVER");
    1:     _ASSIGN_eventName(NS_FOCUS_CONTENT,"NS_FOCUS_CONTENT");
    1:     _ASSIGN_eventName(NS_FORM_SELECTED,"NS_FORM_SELECTED");
    1:     _ASSIGN_eventName(NS_FORM_CHANGE,"NS_FORM_CHANGE");
    1:     _ASSIGN_eventName(NS_FORM_INPUT,"NS_FORM_INPUT");
    1:     _ASSIGN_eventName(NS_FORM_RESET,"NS_FORM_RESET");
    1:     _ASSIGN_eventName(NS_FORM_SUBMIT,"NS_FORM_SUBMIT");
    1:     _ASSIGN_eventName(NS_IMAGE_ABORT,"NS_IMAGE_ABORT");
    1:     _ASSIGN_eventName(NS_LOAD_ERROR,"NS_LOAD_ERROR");
    1:     _ASSIGN_eventName(NS_KEY_DOWN,"NS_KEY_DOWN");
    1:     _ASSIGN_eventName(NS_KEY_PRESS,"NS_KEY_PRESS");
    1:     _ASSIGN_eventName(NS_KEY_UP,"NS_KEY_UP");
    1:     _ASSIGN_eventName(NS_MOUSE_ENTER,"NS_MOUSE_ENTER");
    1:     _ASSIGN_eventName(NS_MOUSE_EXIT,"NS_MOUSE_EXIT");
    1:     _ASSIGN_eventName(NS_MOUSE_BUTTON_DOWN,"NS_MOUSE_BUTTON_DOWN");
    1:     _ASSIGN_eventName(NS_MOUSE_BUTTON_UP,"NS_MOUSE_BUTTON_UP");
    1:     _ASSIGN_eventName(NS_MOUSE_CLICK,"NS_MOUSE_CLICK");
    1:     _ASSIGN_eventName(NS_MOUSE_DOUBLECLICK,"NS_MOUSE_DBLCLICK");
    1:     _ASSIGN_eventName(NS_MOUSE_MOVE,"NS_MOUSE_MOVE");
    1:     _ASSIGN_eventName(NS_MOVE,"NS_MOVE");
    1:     _ASSIGN_eventName(NS_LOAD,"NS_LOAD");
37802:     _ASSIGN_eventName(NS_POPSTATE,"NS_POPSTATE");
54146:     _ASSIGN_eventName(NS_BEFORE_SCRIPT_EXECUTE,"NS_BEFORE_SCRIPT_EXECUTE");
54146:     _ASSIGN_eventName(NS_AFTER_SCRIPT_EXECUTE,"NS_AFTER_SCRIPT_EXECUTE");
    1:     _ASSIGN_eventName(NS_PAGE_UNLOAD,"NS_PAGE_UNLOAD");
29975:     _ASSIGN_eventName(NS_HASHCHANGE,"NS_HASHCHANGE");
46273:     _ASSIGN_eventName(NS_READYSTATECHANGE,"NS_READYSTATECHANGE");
    1:     _ASSIGN_eventName(NS_PAINT,"NS_PAINT");
    1:     _ASSIGN_eventName(NS_XUL_BROADCAST, "NS_XUL_BROADCAST");
    1:     _ASSIGN_eventName(NS_XUL_COMMAND_UPDATE, "NS_XUL_COMMAND_UPDATE");
    1:     _ASSIGN_eventName(NS_SCROLLBAR_LINE_NEXT,"NS_SB_LINE_NEXT");
    1:     _ASSIGN_eventName(NS_SCROLLBAR_LINE_PREV,"NS_SB_LINE_PREV");
    1:     _ASSIGN_eventName(NS_SCROLLBAR_PAGE_NEXT,"NS_SB_PAGE_NEXT");
    1:     _ASSIGN_eventName(NS_SCROLLBAR_PAGE_PREV,"NS_SB_PAGE_PREV");
    1:     _ASSIGN_eventName(NS_SCROLLBAR_POS,"NS_SB_POS");
    1:     _ASSIGN_eventName(NS_SIZE,"NS_SIZE");
    1: 
    1: #undef _ASSIGN_eventName
    1: 
    1:   default: 
    1:     {
    1:       char buf[32];
    1:       
    1:       sprintf(buf,"UNKNOWN: %d",aGuiEvent->message);
    1:       
83428:       CopyASCIItoUTF16(buf, eventName);
    1:     }
    1:     break;
    1:   }
    1:   
    1:   return nsAutoString(eventName);
    1: }
    1: //////////////////////////////////////////////////////////////
    1: //
    1: // Code to deal with paint and event debug prefs.
    1: //
    1: //////////////////////////////////////////////////////////////
    1: struct PrefPair
    1: {
    1:   const char * name;
79445:   bool value;
    1: };
    1: 
    1: static PrefPair debug_PrefValues[] =
    1: {
80486:   { "nglayout.debug.crossing_event_dumping", false },
80486:   { "nglayout.debug.event_dumping", false },
80486:   { "nglayout.debug.invalidate_dumping", false },
80486:   { "nglayout.debug.motion_event_dumping", false },
80486:   { "nglayout.debug.paint_dumping", false },
80486:   { "nglayout.debug.paint_flashing", false }
    1: };
    1: 
    1: //////////////////////////////////////////////////////////////
79445: bool
    1: nsBaseWidget::debug_GetCachedBoolPref(const char * aPrefName)
    1: {
    1:   NS_ASSERTION(nsnull != aPrefName,"cmon, pref name is null.");
    1: 
80467:   for (PRUint32 i = 0; i < ArrayLength(debug_PrefValues); i++)
    1:   {
    1:     if (strcmp(debug_PrefValues[i].name, aPrefName) == 0)
    1:     {
    1:       return debug_PrefValues[i].value;
    1:     }
    1:   }
    1: 
80486:   return false;
    1: }
    1: //////////////////////////////////////////////////////////////
79445: static void debug_SetCachedBoolPref(const char * aPrefName,bool aValue)
    1: {
    1:   NS_ASSERTION(nsnull != aPrefName,"cmon, pref name is null.");
    1: 
80467:   for (PRUint32 i = 0; i < ArrayLength(debug_PrefValues); i++)
    1:   {
    1:     if (strcmp(debug_PrefValues[i].name, aPrefName) == 0)
    1:     {
    1:       debug_PrefValues[i].value = aValue;
    1: 
    1:       return;
    1:     }
    1:   }
    1: 
80486:   NS_ASSERTION(false, "cmon, this code is not reached dude.");
    1: }
    1: 
    1: //////////////////////////////////////////////////////////////
    1: class Debug_PrefObserver : public nsIObserver {
    1:   public:
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIOBSERVER
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(Debug_PrefObserver, nsIObserver)
    1: 
    1: NS_IMETHODIMP
    1: Debug_PrefObserver::Observe(nsISupports* subject, const char* topic,
    1:                             const PRUnichar* data)
    1: {
    1:   NS_ConvertUTF16toUTF8 prefName(data);
    1: 
79445:   bool value = Preferences::GetBool(prefName.get(), false);
    1:   debug_SetCachedBoolPref(prefName.get(), value);
    1:   return NS_OK;
    1: }
    1: 
    1: //////////////////////////////////////////////////////////////
    1: /* static */ void
    1: debug_RegisterPrefCallbacks()
    1: {
79445:   static bool once = true;
    1: 
70337:   if (!once) {
70337:     return;
70337:   }
70337: 
80486:   once = false;
    1: 
    1:   nsCOMPtr<nsIObserver> obs(new Debug_PrefObserver());
80467:   for (PRUint32 i = 0; i < ArrayLength(debug_PrefValues); i++) {
    1:     // Initialize the pref values
    1:     debug_PrefValues[i].value =
79445:       Preferences::GetBool(debug_PrefValues[i].name, false);
    1: 
    1:     if (obs) {
    1:       // Register callbacks for when these change
70337:       Preferences::AddStrongObserver(obs, debug_PrefValues[i].name);
    1:     }
    1:   }
    1: }
    1: //////////////////////////////////////////////////////////////
    1: static PRInt32
    1: _GetPrintCount()
    1: {
    1:   static PRInt32 sCount = 0;
    1:   
    1:   return ++sCount;
    1: }
    1: //////////////////////////////////////////////////////////////
79445: /* static */ bool
    1: nsBaseWidget::debug_WantPaintFlashing()
    1: {
    1:   return debug_GetCachedBoolPref("nglayout.debug.paint_flashing");
    1: }
    1: //////////////////////////////////////////////////////////////
    1: /* static */ void
    1: nsBaseWidget::debug_DumpEvent(FILE *                aFileOut,
    1:                               nsIWidget *           aWidget,
    1:                               nsGUIEvent *          aGuiEvent,
    1:                               const nsCAutoString & aWidgetName,
    1:                               PRInt32               aWindowID)
    1: {
    1:   // NS_PAINT is handled by debug_DumpPaintEvent()
    1:   if (aGuiEvent->message == NS_PAINT)
    1:     return;
    1: 
    1:   if (aGuiEvent->message == NS_MOUSE_MOVE)
    1:   {
    1:     if (!debug_GetCachedBoolPref("nglayout.debug.motion_event_dumping"))
    1:       return;
    1:   }
    1:   
    1:   if (aGuiEvent->message == NS_MOUSE_ENTER || 
    1:       aGuiEvent->message == NS_MOUSE_EXIT)
    1:   {
    1:     if (!debug_GetCachedBoolPref("nglayout.debug.crossing_event_dumping"))
    1:       return;
    1:   }
    1: 
    1:   if (!debug_GetCachedBoolPref("nglayout.debug.event_dumping"))
    1:     return;
    1: 
83428:   NS_LossyConvertUTF16toASCII tempString(debug_GuiEventToString(aGuiEvent).get());
    1:   
    1:   fprintf(aFileOut,
    1:           "%4d %-26s widget=%-8p name=%-12s id=%-8p refpt=%d,%d\n",
    1:           _GetPrintCount(),
    1:           tempString.get(),
    1:           (void *) aWidget,
    1:           aWidgetName.get(),
    1:           (void *) (aWindowID ? aWindowID : 0x0),
    1:           aGuiEvent->refPoint.x,
    1:           aGuiEvent->refPoint.y);
    1: }
    1: //////////////////////////////////////////////////////////////
    1: /* static */ void
    1: nsBaseWidget::debug_DumpPaintEvent(FILE *                aFileOut,
    1:                                    nsIWidget *           aWidget,
    1:                                    nsPaintEvent *        aPaintEvent,
    1:                                    const nsCAutoString & aWidgetName,
    1:                                    PRInt32               aWindowID)
    1: {
    1:   NS_ASSERTION(nsnull != aFileOut,"cmon, null output FILE");
    1:   NS_ASSERTION(nsnull != aWidget,"cmon, the widget is null");
    1:   NS_ASSERTION(nsnull != aPaintEvent,"cmon, the paint event is null");
    1: 
    1:   if (!debug_GetCachedBoolPref("nglayout.debug.paint_dumping"))
    1:     return;
    1:   
51040:   nsIntRect rect = aPaintEvent->region.GetBounds();
    1:   fprintf(aFileOut,
51040:           "%4d PAINT      widget=%p name=%-12s id=%-8p bounds-rect=%3d,%-3d %3d,%-3d", 
    1:           _GetPrintCount(),
    1:           (void *) aWidget,
    1:           aWidgetName.get(),
51040:           (void *) aWindowID,
51040:           rect.x, rect.y, rect.width, rect.height
51040:     );
    1:   
    1:   fprintf(aFileOut,"\n");
    1: }
    1: //////////////////////////////////////////////////////////////
    1: /* static */ void
    1: nsBaseWidget::debug_DumpInvalidate(FILE *                aFileOut,
    1:                                    nsIWidget *           aWidget,
23738:                                    const nsIntRect *     aRect,
    1:                                    const nsCAutoString & aWidgetName,
    1:                                    PRInt32               aWindowID)
    1: {
    1:   if (!debug_GetCachedBoolPref("nglayout.debug.invalidate_dumping"))
    1:     return;
    1: 
    1:   NS_ASSERTION(nsnull != aFileOut,"cmon, null output FILE");
    1:   NS_ASSERTION(nsnull != aWidget,"cmon, the widget is null");
    1: 
    1:   fprintf(aFileOut,
    1:           "%4d Invalidate widget=%p name=%-12s id=%-8p",
    1:           _GetPrintCount(),
    1:           (void *) aWidget,
    1:           aWidgetName.get(),
    1:           (void *) aWindowID);
    1: 
    1:   if (aRect) 
    1:   {
    1:     fprintf(aFileOut,
    1:             " rect=%3d,%-3d %3d,%-3d",
    1:             aRect->x, 
    1:             aRect->y,
    1:             aRect->width, 
    1:             aRect->height);
    1:   }
    1:   else
    1:   {
    1:     fprintf(aFileOut,
    1:             " rect=%-15s",
    1:             "none");
    1:   }
    1:   
    1:   fprintf(aFileOut,"\n");
    1: }
    1: //////////////////////////////////////////////////////////////
    1: 
    1: #endif // DEBUG
    1: 
