35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Ben Turner <bent.mozilla@gmail.com>.
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
35893: #ifndef dom_plugins_PluginModuleChild_h
35893: #define dom_plugins_PluginModuleChild_h 1
35740: 
35740: #include <string>
35740: #include <vector>
35740: 
35746: #include "base/basictypes.h"
35746: 
35740: #include "prlink.h"
35740: 
35740: #include "npapi.h"
35740: #include "npfunctions.h"
35740: 
35747: #include "nsAutoPtr.h"
37477: #include "nsTHashtable.h"
35925: #include "nsHashKeys.h"
35740: 
35898: #include "mozilla/plugins/PPluginModuleChild.h"
35893: #include "mozilla/plugins/PluginInstanceChild.h"
35740: 
35740: // NOTE: stolen from nsNPAPIPlugin.h
35740: 
35740: /*
35740:  * Use this macro before each exported function
35740:  * (between the return address and the function
35740:  * itself), to ensure that the function has the
35740:  * right calling conventions on OS/2.
35740:  */
35740: #ifdef XP_OS2
35740: #define NP_CALLBACK _System
35740: #else
35740: #define NP_CALLBACK
35740: #endif
35740: 
35740: #if defined(XP_WIN)
35740: #define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (__stdcall * _name)
35740: #elif defined(XP_OS2)
35740: #define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (_System * _name)
35740: #else
35740: #define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (* _name)
35740: #endif
35740: 
35740: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_GETENTRYPOINTS) (NPPluginFuncs* pCallbacks);
35740: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGININIT) (const NPNetscapeFuncs* pCallbacks);
35740: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGINUNIXINIT) (const NPNetscapeFuncs* pCallbacks, NPPluginFuncs* fCallbacks);
35740: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGINSHUTDOWN) (void);
35740: 
35740: namespace mozilla {
35740: namespace plugins {
35925: 
35925: class PluginScriptableObjectChild;
37477: class PluginInstanceChild;
35740: 
35898: class PluginModuleChild : public PPluginModuleChild
35740: {
35746: protected:
39265:     NS_OVERRIDE
39265:     virtual mozilla::ipc::RPCChannel::RacyRPCPolicy
39265:     MediateRPCRace(const Message& parent, const Message& child)
39265:     {
39265:         return MediateRace(parent, child);
39265:     }
39265: 
35898:     // Implement the PPluginModuleChild interface
35926:     virtual bool AnswerNP_Initialize(NPError* rv);
35746: 
35898:     virtual PPluginInstanceChild*
35943:     AllocPPluginInstance(const nsCString& aMimeType,
35746:                          const uint16_t& aMode,
35820:                          const nsTArray<nsCString>& aNames,
35820:                          const nsTArray<nsCString>& aValues,
35746:                          NPError* rv);
35746: 
35926:     virtual bool
36138:     DeallocPPluginInstance(PPluginInstanceChild* aActor);
35965: 
35965:     virtual bool
35925:     AnswerPPluginInstanceConstructor(PPluginInstanceChild* aActor,
35925:                                      const nsCString& aMimeType,
35925:                                      const uint16_t& aMode,
35925:                                      const nsTArray<nsCString>& aNames,
35925:                                      const nsTArray<nsCString>& aValues,
35746:                                      NPError* rv);
36039:     virtual bool
36039:     AnswerNP_Shutdown(NPError *rv);
35740: 
36140:     virtual void
36140:     ActorDestroy(ActorDestroyReason why);
36140: 
35740: public:
35893:     PluginModuleChild();
35893:     virtual ~PluginModuleChild();
35740: 
35740:     bool Init(const std::string& aPluginFilename,
36016:               base::ProcessHandle aParentProcessHandle,
35740:               MessageLoop* aIOLoop,
35740:               IPC::Channel* aChannel);
35740: 
35740:     void CleanUp();
35740: 
36099:     const char* GetUserAgent();
36099: 
35740:     static const NPNetscapeFuncs sBrowserFuncs;
35740: 
35925:     static PluginModuleChild* current();
35925: 
37477:     bool RegisterActorForNPObject(NPObject* aObject,
35925:                                   PluginScriptableObjectChild* aActor);
35925: 
37477:     void UnregisterActorForNPObject(NPObject* aObject);
35925: 
35925:     PluginScriptableObjectChild* GetActorForNPObject(NPObject* aObject);
35925: 
36073: #ifdef DEBUG
37311:     bool NPObjectIsRegistered(NPObject* aObject);
36073: #endif
36073: 
37477:     /**
37477:      * The child implementation of NPN_CreateObject.
37477:      */
37477:     static NPObject* NP_CALLBACK NPN_CreateObject(NPP aNPP, NPClass* aClass);
37477:     /**
37477:      * The child implementation of NPN_RetainObject.
37477:      */
37477:     static NPObject* NP_CALLBACK NPN_RetainObject(NPObject* aNPObj);
37477:     /**
37477:      * The child implementation of NPN_ReleaseObject.
37477:      */
37477:     static void NP_CALLBACK NPN_ReleaseObject(NPObject* aNPObj);
37477: 
35740: private:
35746:     bool InitGraphics();
38684: #if defined(MOZ_WIDGET_GTK2)
38684:     static gboolean DetectNestedEventLoop(gpointer data);
38684:     static gboolean ProcessBrowserEvents(gpointer data);
38684: 
38684:     NS_OVERRIDE
38684:     virtual void EnteredCxxStack();
38684:     NS_OVERRIDE
38684:     virtual void ExitedCxxStack();
38684: #endif
35746: 
35740:     std::string mPluginFilename;
35740:     PRLibrary* mLibrary;
36099:     nsCString mUserAgent;
35740: 
35740:     // we get this from the plugin
36069: #ifdef OS_POSIX
35740:     NP_PLUGINUNIXINIT mInitializeFunc;
35746: #elif OS_WIN
35746:     NP_PLUGININIT mInitializeFunc;
35746:     NP_GETENTRYPOINTS mGetEntryPointsFunc;
35746: #endif
38684: 
35740:     NP_PLUGINSHUTDOWN mShutdownFunc;
35740:     NPPluginFuncs mFunctions;
35740:     NPSavedData mSavedData;
35925: 
38684: #if defined(MOZ_WIDGET_GTK2)
38684:     // If a plugin spins a nested glib event loop in response to a
38684:     // synchronous IPC message from the browser, the loop might break
38684:     // only after the browser responds to a request sent by the
38684:     // plugin.  This can happen if a plugin uses gtk's synchronous
38684:     // copy/paste, for example.  But because the browser is blocked on
38684:     // a condvar, it can't respond to the request.  This situation
38684:     // isn't technically a deadlock, but the symptoms are basically
38684:     // the same from the user's perspective.
38684:     //
38684:     // We take two steps to prevent this
38684:     //
38684:     //  (1) Detect nested event loops spun by the plugin.  This is
38684:     //      done by scheduling a glib timer event in the plugin
38684:     //      process whenever the browser might block on the plugin.
38684:     //      If the plugin indeed spins a nested loop, this timer event
38684:     //      will fire "soon" thereafter.
38684:     //
38684:     //  (2) When a nested loop is detected, deschedule the
38684:     //      nested-loop-detection timer and in its place, schedule
38684:     //      another timer that periodically calls back into the
38684:     //      browser and spins a mini event loop.  This mini event loop
38684:     //      processes a handful of pending native events.
38684:     //
38684:     // Because only timer (1) or (2) (or neither) may be active at any
38684:     // point in time, we use the same member variable
38684:     // |mNestedLoopTimerId| to refer to both.
38684:     //
38684:     // When the browser no longer might be blocked on a plugin's IPC
38684:     // response, we deschedule whichever of (1) or (2) is active.
38684:     guint mNestedLoopTimerId;
38684: #endif
38684: 
37477:     struct NPObjectData : public nsPtrHashKey<NPObject>
37477:     {
37477:         NPObjectData(const NPObject* key)
37477:             : nsPtrHashKey<NPObject>(key)
37477:             , instance(NULL)
37477:             , actor(NULL)
37477:         { }
37477: 
37477:         // never NULL
37477:         PluginInstanceChild* instance;
37477: 
37477:         // sometimes NULL (no actor associated with an NPObject)
37477:         PluginScriptableObjectChild* actor;
37477:     };
37477:     /**
37477:      * mObjectMap contains all the currently active NPObjects (from NPN_CreateObject until the
37477:      * final release/dealloc, whether or not an actor is currently associated with the object.
37477:      */
37477:     nsTHashtable<NPObjectData> mObjectMap;
37477: 
38669: public: // called by PluginInstanceChild
37477:     /**
37477:      * Dealloc an NPObject after last-release or when the associated instance
38669:      * is destroyed. This function will remove the object from mObjectMap.
37477:      */
37477:     static void DeallocNPObject(NPObject* o);
37477: 
38669:     NPError NPP_Destroy(PluginInstanceChild* instance) {
38669:         return mFunctions.destroy(instance->GetNPP(), 0);
38669:     }
38669: 
37477:     /**
38669:      * Fill PluginInstanceChild.mDeletingHash with all the remaining NPObjects
38669:      * associated with that instance.
37477:      */
38669:     void FindNPObjectsForInstance(PluginInstanceChild* instance);
38669: 
38669: private:
38669:     static PLDHashOperator CollectForInstance(NPObjectData* d, void* userArg);
35740: };
35740: 
35740: } /* namespace plugins */
35740: } /* namespace mozilla */
35740: 
35893: #endif  // ifndef dom_plugins_PluginModuleChild_h
