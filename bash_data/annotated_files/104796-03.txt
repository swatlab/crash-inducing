 43264: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 43264:  * vim: set ts=4 sw=4 et tw=99:
 43264:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43264: 
 43264: #ifndef jswrapper_h___
 43264: #define jswrapper_h___
 43264: 
 82650: #include "mozilla/Attributes.h"
 82325: 
 43264: #include "jsapi.h"
 43264: #include "jsproxy.h"
 43264: 
 79386: namespace js {
 54721: 
 86463: class DummyFrameGuard;
 86463: 
103938: /*
103938:  * A wrapper is essentially a proxy that restricts access to certain traps. The
103938:  * way in which a wrapper restricts access to its traps depends on the
103938:  * particular policy for that wrapper. To allow a wrapper's policy to be
103938:  * customized, the Wrapper base class contains two functions, enter/leave, which
103938:  * are called as a policy enforcement check before/after each trap is forwarded.
103938:  *
103938:  * To minimize code duplication, a set of abstract wrapper classes is
103938:  * provided, from which other wrappers may inherit. These abstract classes are
103938:  * organized in the following hierarchy:
103938:  *
103938:  * BaseProxyHandler Wrapper
103938:  * |                    | |
103938:  * IndirectProxyHandler | |
103938:  * |                  | | |
103938:  * |      IndirectWrapper |
103938:  * |                      |
103938:  * DirectProxyHandler     |
103938:  *                  |     |
103938:  *            DirectWrapper
103938:  */
103121: class JS_FRIEND_API(Wrapper)
 79386: {
 95795:     unsigned mFlags;
103121: 
 47574:   public:
103121:     enum Action {
103121:         GET,
103121:         SET,
103121:         CALL,
103121:         PUNCTURE
103121:     };
 95795: 
103121:     enum Flags {
103121:         CROSS_COMPARTMENT = 1 << 0,
103121:         LAST_USED_FLAG = CROSS_COMPARTMENT
103121:     };
 43264: 
103121:     typedef enum {
103121:         PermitObjectAccess,
103121:         PermitPropertyAccess,
103121:         DenyAccess
103121:     } Permission;
103121: 
103121:     static JSObject *New(JSContext *cx, JSObject *obj, JSObject *proto,
103121:                          JSObject *parent, Wrapper *handler);
103121: 
103121:     static Wrapper *wrapperHandler(const JSObject *wrapper);
103121: 
103121:     static JSObject *wrappedObject(const JSObject *wrapper);
103121: 
103121:     explicit Wrapper(unsigned flags);
103121: 
103121:     unsigned flags() const {
103121:         return mFlags;
103121:     }
103121: 
103121:     /*
103121:      * The function Wrapper::New takes a pointer to a Wrapper as the handler
103121:      * object. It then passes it on to the function NewProxyObject, which
103121:      * expects a pointer to a BaseProxyHandler as the handler object. We don't
103121:      * want to change Wrapper::New to take a pointer to a BaseProxyHandler,
103121:      * because that would allow the creation of wrappers with non-wrapper
103121:      * handlers. Unfortunately, we can't inherit Wrapper from BaseProxyHandler,
103121:      * since that would create a dreaded diamond, and we can't use dynamic_cast
103121:      * to cast Wrapper to BaseProxyHandler, since that would require us to
103121:      * compile with run time type information. Hence the need for this virtual
103121:      * function.
103121:      */
103121:     virtual BaseProxyHandler *toBaseProxyHandler() = 0;
 43264: 
 93955:     /* Policy enforcement traps.
 93955:      *
 93955:      * enter() allows the policy to specify whether the caller may perform |act|
 93955:      * on the underlying object's |id| property. In the case when |act| is CALL,
 93955:      * |id| is generally JSID_VOID.
 93955:      *
 93955:      * The |act| parameter to enter() specifies the action being performed. GET,
103121:      * SET, and CALL are self-explanatory, but PUNCTURE requires more
103121:      * explanation:
 93955:      *
 93955:      * GET and SET allow for a very fine-grained security membrane, through
 93955:      * which access can be granted or denied on a per-property, per-object, and
 93955:      * per-action basis. Sometimes though, we just want to asks if we can access
 93955:      * _everything_ behind the wrapper barrier. For example, when the structured
 93955:      * clone algorithm runs up against a cross-compartment wrapper, it needs to
 93955:      * know whether it can enter the compartment and keep cloning, or whether it
 93955:      * should throw. This is the role of PUNCTURE.
 93955:      *
 93955:      * PUNCTURE allows the policy to specify whether the wrapper barrier may
 93955:      * be lifted - that is to say, whether the caller is allowed to access
 93955:      * anything that the wrapped object could access. This is a very powerful
 93955:      * permission, and thus should generally be denied for security wrappers
 93955:      * except under very special circumstances. When |act| is PUNCTURE, |id|
 93955:      * should be JSID_VOID.
103121:      */
103121:     virtual bool enter(JSContext *cx, JSObject *wrapper, jsid id, Action act,
103121:                        bool *bp);
 95468: };
 95468: 
103121: /*
103938:  * IndirectWrapper forwards its traps by forwarding them to
103938:  * IndirectProxyHandler. In effect, IndirectWrapper behaves the same as
103938:  * IndirectProxyHandler, except that it adds policy enforcement checks to each
103938:  * fundamental trap.
103121:  */
103938: class JS_FRIEND_API(IndirectWrapper) : public Wrapper,
103121:                                        public IndirectProxyHandler
103121: {
103121:   public:
103938:     explicit IndirectWrapper(unsigned flags);
103121: 
103121:     virtual BaseProxyHandler* toBaseProxyHandler() {
103121:         return this;
103121:     }
103121: 
103121:     virtual Wrapper *toWrapper() {
103121:         return this;
103121:     }
103121: 
103121:     /* ES5 Harmony fundamental wrapper traps. */
103121:     virtual bool getPropertyDescriptor(JSContext *cx, JSObject *wrapper,
103121:                                        jsid id, bool set,
103121:                                        PropertyDescriptor *desc) MOZ_OVERRIDE;
103121:     virtual bool getOwnPropertyDescriptor(JSContext *cx, JSObject *wrapper,
103121:                                           jsid id, bool set,
103121:                                           PropertyDescriptor *desc) MOZ_OVERRIDE;
103121:     virtual bool defineProperty(JSContext *cx, JSObject *wrapper, jsid id,
103121:                                 PropertyDescriptor *desc) MOZ_OVERRIDE;
103121:     virtual bool getOwnPropertyNames(JSContext *cx, JSObject *wrapper,
103121:                                      AutoIdVector &props) MOZ_OVERRIDE;
103121:     virtual bool delete_(JSContext *cx, JSObject *wrapper, jsid id,
103121:                          bool *bp) MOZ_OVERRIDE;
103121:     virtual bool enumerate(JSContext *cx, JSObject *wrapper,
103121:                            AutoIdVector &props) MOZ_OVERRIDE;
103121: };
103121: 
103121: /*
103938:  * DirectWrapper forwards its traps by forwarding them to DirectProxyHandler.
103938:  * In effect, DirectWrapper behaves the same as DirectProxyHandler, except that
103938:  * it adds policy enforcement checks to each trap.
103121:  */
103233: class JS_FRIEND_API(DirectWrapper) : public Wrapper, public DirectProxyHandler
 95468: {
 95468:   public:
100027:     explicit DirectWrapper(unsigned flags);
 95468: 
100027:     virtual ~DirectWrapper();
 95468: 
103233:     virtual BaseProxyHandler* toBaseProxyHandler() {
103233:         return this;
103233:     }
103233: 
103233:     virtual Wrapper *toWrapper() {
103233:         return this;
103233:     }
103233: 
103233:     /* ES5 Harmony fundamental wrapper traps. */
103233:     virtual bool getPropertyDescriptor(JSContext *cx, JSObject *wrapper,
103233:                                        jsid id, bool set,
103233:                                        PropertyDescriptor *desc) MOZ_OVERRIDE;
103233:     virtual bool getOwnPropertyDescriptor(JSContext *cx, JSObject *wrapper,
103233:                                           jsid id, bool set,
103233:                                           PropertyDescriptor *desc) MOZ_OVERRIDE;
103233:     virtual bool defineProperty(JSContext *cx, JSObject *wrapper, jsid id,
103233:                                 PropertyDescriptor *desc) MOZ_OVERRIDE;
103233:     virtual bool getOwnPropertyNames(JSContext *cx, JSObject *wrapper,
103233:                                      AutoIdVector &props) MOZ_OVERRIDE;
103233:     virtual bool delete_(JSContext *cx, JSObject *wrapper, jsid id,
103233:                          bool *bp) MOZ_OVERRIDE;
103233:     virtual bool enumerate(JSContext *cx, JSObject *wrapper,
103233:                            AutoIdVector &props) MOZ_OVERRIDE;
103233: 
 95468:     /* ES5 Harmony derived wrapper traps. */
 95468:     virtual bool has(JSContext *cx, JSObject *wrapper, jsid id, bool *bp) MOZ_OVERRIDE;
 95468:     virtual bool hasOwn(JSContext *cx, JSObject *wrapper, jsid id, bool *bp) MOZ_OVERRIDE;
 95468:     virtual bool get(JSContext *cx, JSObject *wrapper, JSObject *receiver, jsid id, Value *vp) MOZ_OVERRIDE;
 95468:     virtual bool set(JSContext *cx, JSObject *wrapper, JSObject *receiver, jsid id, bool strict,
 95468:                      Value *vp) MOZ_OVERRIDE;
 95468:     virtual bool keys(JSContext *cx, JSObject *wrapper, AutoIdVector &props) MOZ_OVERRIDE;
 95468:     virtual bool iterate(JSContext *cx, JSObject *wrapper, unsigned flags, Value *vp) MOZ_OVERRIDE;
 95468: 
 95468:     /* Spidermonkey extensions. */
 95468:     virtual bool call(JSContext *cx, JSObject *wrapper, unsigned argc, Value *vp) MOZ_OVERRIDE;
 95468:     virtual bool construct(JSContext *cx, JSObject *wrapper, unsigned argc, Value *argv, Value *rval) MOZ_OVERRIDE;
 95468:     virtual bool nativeCall(JSContext *cx, JSObject *wrapper, Class *clasp, Native native, CallArgs args) MOZ_OVERRIDE;
 95468:     virtual bool hasInstance(JSContext *cx, JSObject *wrapper, const Value *vp, bool *bp) MOZ_OVERRIDE;
 95468:     virtual JSString *obj_toString(JSContext *cx, JSObject *wrapper) MOZ_OVERRIDE;
 95468:     virtual JSString *fun_toString(JSContext *cx, JSObject *wrapper, unsigned indent) MOZ_OVERRIDE;
 95468: 
100027:     static DirectWrapper singleton;
 43264: 
 55624:     static void *getWrapperFamily();
 43264: };
 43264: 
 47516: /* Base class for all cross compartment wrapper handlers. */
100027: class JS_FRIEND_API(CrossCompartmentWrapper) : public DirectWrapper
 79386: {
 47516:   public:
 91237:     CrossCompartmentWrapper(unsigned flags);
 47525: 
 79386:     virtual ~CrossCompartmentWrapper();
 47516: 
 47574:     /* ES5 Harmony fundamental wrapper traps. */
 55592:     virtual bool getPropertyDescriptor(JSContext *cx, JSObject *wrapper, jsid id, bool set,
 82325:                                        PropertyDescriptor *desc) MOZ_OVERRIDE;
 55592:     virtual bool getOwnPropertyDescriptor(JSContext *cx, JSObject *wrapper, jsid id, bool set,
 82325:                                           PropertyDescriptor *desc) MOZ_OVERRIDE;
 49299:     virtual bool defineProperty(JSContext *cx, JSObject *wrapper, jsid id,
 82325:                                 PropertyDescriptor *desc) MOZ_OVERRIDE;
 82325:     virtual bool getOwnPropertyNames(JSContext *cx, JSObject *wrapper, AutoIdVector &props) MOZ_OVERRIDE;
 82325:     virtual bool delete_(JSContext *cx, JSObject *wrapper, jsid id, bool *bp) MOZ_OVERRIDE;
 82325:     virtual bool enumerate(JSContext *cx, JSObject *wrapper, AutoIdVector &props) MOZ_OVERRIDE;
 47516: 
 47574:     /* ES5 Harmony derived wrapper traps. */
 82325:     virtual bool has(JSContext *cx, JSObject *wrapper, jsid id, bool *bp) MOZ_OVERRIDE;
 82325:     virtual bool hasOwn(JSContext *cx, JSObject *wrapper, jsid id, bool *bp) MOZ_OVERRIDE;
 82325:     virtual bool get(JSContext *cx, JSObject *wrapper, JSObject *receiver, jsid id, Value *vp) MOZ_OVERRIDE;
 62395:     virtual bool set(JSContext *cx, JSObject *wrapper, JSObject *receiver, jsid id, bool strict,
 82325:                      Value *vp) MOZ_OVERRIDE;
 82325:     virtual bool keys(JSContext *cx, JSObject *wrapper, AutoIdVector &props) MOZ_OVERRIDE;
 91237:     virtual bool iterate(JSContext *cx, JSObject *wrapper, unsigned flags, Value *vp) MOZ_OVERRIDE;
 47516: 
 47516:     /* Spidermonkey extensions. */
 91237:     virtual bool call(JSContext *cx, JSObject *wrapper, unsigned argc, Value *vp) MOZ_OVERRIDE;
 91237:     virtual bool construct(JSContext *cx, JSObject *wrapper, unsigned argc, Value *argv, Value *rval) MOZ_OVERRIDE;
 82325:     virtual bool nativeCall(JSContext *cx, JSObject *wrapper, Class *clasp, Native native, CallArgs args) MOZ_OVERRIDE;
 82325:     virtual bool hasInstance(JSContext *cx, JSObject *wrapper, const Value *vp, bool *bp) MOZ_OVERRIDE;
 82325:     virtual JSString *obj_toString(JSContext *cx, JSObject *wrapper) MOZ_OVERRIDE;
 91237:     virtual JSString *fun_toString(JSContext *cx, JSObject *wrapper, unsigned indent) MOZ_OVERRIDE;
 82325:     virtual bool defaultValue(JSContext *cx, JSObject *wrapper, JSType hint, Value *vp) MOZ_OVERRIDE;
 89623:     virtual bool iteratorNext(JSContext *cx, JSObject *wrapper, Value *vp);
 73561: 
 79386:     static CrossCompartmentWrapper singleton;
 47516: };
 47516: 
 79386: /*
 80203:  * Base class for security wrappers. A security wrapper is potentially hiding
 80203:  * all or part of some wrapped object thus SecurityWrapper defaults to denying
 80203:  * access to the wrappee. This is the opposite of Wrapper which tries to be
 80203:  * completely transparent.
 80203:  *
 80203:  * NB: Currently, only a few ProxyHandler operations are overridden to deny
 80203:  * access, relying on derived SecurityWrapper to block access when necessary.
 80203:  */
 80203: template <class Base>
 80203: class JS_FRIEND_API(SecurityWrapper) : public Base
 80203: {
 80203:   public:
 91237:     SecurityWrapper(unsigned flags);
 80203: 
 82325:     virtual bool nativeCall(JSContext *cx, JSObject *wrapper, Class *clasp, Native native, CallArgs args) MOZ_OVERRIDE;
 82325:     virtual bool objectClassIs(JSObject *obj, ESClassValue classValue, JSContext *cx) MOZ_OVERRIDE;
 90851:     virtual bool regexp_toShared(JSContext *cx, JSObject *proxy, RegExpGuard *g) MOZ_OVERRIDE;
 80203: };
 80203: 
100027: typedef SecurityWrapper<DirectWrapper> SameCompartmentSecurityWrapper;
 80203: typedef SecurityWrapper<CrossCompartmentWrapper> CrossCompartmentSecurityWrapper;
 80203: 
 80203: /*
 79386:  * A hacky class that lets a friend force a fake frame. We must already be
 79386:  * in the compartment of |target| when we enter the forced frame.
 79386:  */
 70264: class JS_FRIEND_API(ForceFrame)
 70264: {
 70264:   public:
 70264:     JSContext * const context;
 70264:     JSObject * const target;
 70264:   private:
 71704:     DummyFrameGuard *frame;
 70264: 
 70264:   public:
 70264:     ForceFrame(JSContext *cx, JSObject *target);
 70461:     ~ForceFrame();
 70264:     bool enter();
 70264: };
 70264: 
 47516: extern JSObject *
 55580: TransparentObjectWrapper(JSContext *cx, JSObject *obj, JSObject *wrappedProto, JSObject *parent,
 91237:                          unsigned flags);
 47516: 
 90605: // Proxy family for wrappers. Public so that IsWrapper() can be fully inlined by
 90605: // jsfriendapi users.
 90605: extern JS_FRIEND_DATA(int) sWrapperFamily;
 90605: 
 90605: inline bool
 90605: IsWrapper(const JSObject *obj)
 90605: {
 90605:     return IsProxy(obj) && GetProxyHandler(obj)->family() == &sWrapperFamily;
 90605: }
 89339: 
 89339: // Given a JSObject, returns that object stripped of wrappers. If
 89339: // stopAtOuter is true, then this returns the outer window if it was
 89339: // previously wrapped. Otherwise, this returns the first object for
 89339: // which JSObject::isWrapper returns false.
 99134: JS_FRIEND_API(JSObject *)
 99134: UnwrapObject(JSObject *obj, bool stopAtOuter = true, unsigned *flagsp = NULL);
 89339: 
 93956: // Given a JSObject, returns that object stripped of wrappers. At each stage,
 93956: // the security wrapper has the opportunity to veto the unwrap. Since checked
 93956: // code should never be unwrapping outer window wrappers, we always stop at
 93956: // outer windows.
 99134: JS_FRIEND_API(JSObject *)
 99134: UnwrapObjectChecked(JSContext *cx, JSObject *obj);
 93956: 
100253: JS_FRIEND_API(bool)
 99134: IsCrossCompartmentWrapper(const JSObject *obj);
 99134: 
 99134: void
 99134: NukeCrossCompartmentWrapper(JSObject *wrapper);
 79734: 
103587: bool
103587: RemapWrapper(JSContext *cx, JSObject *wobj, JSObject *newTarget);
103587: 
104796: JS_FRIEND_API(bool)
103588: RemapAllWrappersForObject(JSContext *cx, JSObject *oldTarget,
103588:                           JSObject *newTarget);
103590: 
103590: // API to recompute all cross-compartment wrappers whose source and target
103590: // match the given filters.
103590: //
103590: // These filters are designed to be ephemeral stack classes, and thus don't
103590: // do any rooting or holding of their members.
103590: struct CompartmentFilter {
103590:     virtual bool match(JSCompartment *c) const = 0;
103590: };
103590: 
103590: struct AllCompartments : public CompartmentFilter {
104119:     virtual bool match(JSCompartment *c) const { return true; }
103590: };
103590: 
103590: struct ContentCompartmentsOnly : public CompartmentFilter {
103590:     virtual bool match(JSCompartment *c) const {
103590:         return !IsSystemCompartment(c);
104120:     }
103590: };
103590: 
103590: struct SingleCompartment : public CompartmentFilter {
103590:     JSCompartment *ours;
104119:     SingleCompartment(JSCompartment *c) : ours(c) {}
104119:     virtual bool match(JSCompartment *c) const { return c == ours; }
103590: };
103590: 
103590: struct CompartmentsWithPrincipals : public CompartmentFilter {
103590:     JSPrincipals *principals;
104119:     CompartmentsWithPrincipals(JSPrincipals *p) : principals(p) {}
103590:     virtual bool match(JSCompartment *c) const {
103590:         return JS_GetCompartmentPrincipals(c) == principals;
104120:     }
103590: };
103590: 
103590: JS_FRIEND_API(bool)
103590: RecomputeWrappers(JSContext *cx, const CompartmentFilter &sourceFilter,
103590:                   const CompartmentFilter &targetFilter);
103590: 
 79734: } /* namespace js */
 43264: 
 43264: #endif
