    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim:set ts=2 sts=2 sw=2 et cin: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
26617:  *   Ere Maijala <emaijala@kolumbus.fi>
    1:  *   Mark Hammond <markh@activestate.com>
    1:  *   Michael Lowe <michael.lowe@bigfoot.com>
    1:  *   Peter Bajusz <hyp-x@inf.bme.hu>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   Roy Yokoyama <yokoyama@netscape.com>
    1:  *   Makoto Kato  <m_kato@ga2.so-net.ne.jp>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Dainis Jonitis <Dainis_Jonitis@swh-t.lv>
    1:  *   Christian Biesinger <cbiesinger@web.de>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
24836:  *   Ningjie Chen <chenn@email.uc.edu>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsWindow.h"
    1: #include "nsIAppShell.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsIFontEnumerator.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsFont.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIScreenManager.h"
    1: #include "nsRect.h"
    1: #include "nsTransform2D.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsIObserverService.h"
    1: #include "imgIContainer.h"
    1: #include "gfxIImageFrame.h"
    1: #include "nsNativeCharsetUtils.h"
    1: #include "nsWidgetAtoms.h"
    1: #include <windows.h>
    1: #include <process.h>
14799: #include "nsUnicharUtils.h"
14962: #include "prlog.h"
18536: #include "nsISupportsPrimitives.h"
23691: #include "gfxImageSurface.h"
26874: #include "nsIDOMNSUIEvent.h"
23691: 
    1: #ifdef WINCE
24972: 
    1: #include "aygshell.h"
    1: #include "imm.h"
24972: 
24972: #define PAINT_USE_IMAGE_SURFACE
24972: 
27336: // do 32->24 conversion before calling StretchDIBits
27336: #define PAINT_USE_IMAGE_SURFACE_24BPP
27336: 
24972: #ifdef WINCE_WINDOWS_MOBILE
24972: #define WINCE_HAVE_SOFTKB
    1: #include "tpcshell.h"
 5253: #else
24972: #undef WINCE_HAVE_SOFTKB
24972: #include "winuserm.h"
24972: #endif
24972: 
24972: #else
23335: 
23335: #include "nsUXThemeData.h"
26576: #include "nsUXThemeConstants.h"
23335: #include "nsKeyboardLayout.h"
23335: #include "nsNativeDragTarget.h"
23335: 
23335: #include <pbt.h>
23335: #ifndef PBT_APMRESUMEAUTOMATIC
23335: #define PBT_APMRESUMEAUTOMATIC 0x0012
23335: #endif
23335: 
 5253: // mmsystem.h is needed to build with WIN32_LEAN_AND_MEAN
 5253: #include <mmsystem.h>
23335: #include <zmouse.h>
    1: #endif
    1: 
    1: 
    1: // unknwn.h is needed to build with WIN32_LEAN_AND_MEAN
    1: #include <unknwn.h>
    1: 
    1: //#include "sysmets.h"
    1: #include "nsGfxCIID.h"
    1: #include "resource.h"
    1: #include <commctrl.h>
    1: #include "prtime.h"
    1: #include "gfxContext.h"
    1: #include "gfxWindowsSurface.h"
    1: #include "nsIImage.h"
    1: 
    1: #ifdef ACCESSIBILITY
    1: #include "OLEIDL.H"
 7756: #include <winuser.h>
 7756: #ifndef WINABLEAPI
 7756: #include <winable.h>
 7756: #endif
    1: #include "nsIAccessible.h"
    1: #include "nsIAccessibleDocument.h"
    1: #include "nsIAccessNode.h"
    1: #ifndef WM_GETOBJECT
    1: #define WM_GETOBJECT 0x03d
    1: #endif
    1: #endif
    1: 
    1: #include "nsIRollupListener.h"
    1: #include "nsIMenuRollup.h"
    1: #include "nsIRegion.h"
    1: 
    1: //~~~ windowless plugin support
    1: #include "nsplugindefs.h"
    1: 
    1: // For clipboard support
    1: #include "nsIServiceManager.h"
    1: #include "nsIClipboard.h"
    1: #include "nsWidgetsCID.h"
    1: 
    1: #include "nsITimer.h"
    1: 
    1: #include "nsITheme.h"
    1: 
    1: // For SetIcon
    1: #include "nsILocalFile.h"
    1: #include "nsCRT.h"
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsIFile.h"
    1: 
    1: #include "prprf.h"
    1: #include "prmem.h"
    1: 
24836: #ifdef NS_ENABLE_TSF
24836: #include "nsTextStore.h"
24836: #endif //NS_ENABLE_TSF
23335: 
25020: // Don't put more than this many rects in the dirty region, just fluff
25020: // out to the bounding-box if there are more
25020: #define MAX_RECTS_IN_REGION 100
25020: 
25862: #ifdef PAINT_USE_IMAGE_SURFACE
25862: static nsAutoPtr<PRUint8> gSharedSurfaceData;
25862: static gfxIntSize gSharedSurfaceSize;
25862: #endif
25862: 
24972: /*
24972:  * WinCE helpers
24972:  */
23335: #ifdef WINCE
23335: 
24972: #ifdef WINCE_HAVE_SOFTKB
23335: static PRBool gSoftKeyMenuBar = PR_FALSE;
26485: static PRBool gSoftKeyboardState = PR_FALSE;
26485: 
26485: static void ToggleSoftKB(PRBool show)
26485: {
26485:   HWND hWndSIP = FindWindowW(L"SipWndClass", NULL );
26485:   if (hWndSIP)
26485:     ::ShowWindow(hWndSIP, show ? SW_SHOW: SW_HIDE);
26485: 
26485:   hWndSIP = FindWindowW(L"MS_SIPBUTTON", NULL ); 
26485:   if (hWndSIP)
26485:     ShowWindow(hWndSIP, show ? SW_SHOW: SW_HIDE);
26485: 
26485:   SHSipPreference(NULL, show ? SIP_UP: SIP_DOWN);
26485: }
23335: 
23335: static void CreateSoftKeyMenuBar(HWND wnd)
23335: {
23335:   if (!wnd)
23335:     return;
23335:   
23335:   static HWND gSoftKeyMenuBar = nsnull;
23335:   
23335:   if (gSoftKeyMenuBar != nsnull)
23335:     return;
23335:   
23335:   SHMENUBARINFO mbi;
23335:   ZeroMemory(&mbi, sizeof(SHMENUBARINFO));
23335:   mbi.cbSize = sizeof(SHMENUBARINFO);
23335:   mbi.hwndParent = wnd;
23335:   
23335:   //  On windows ce smartphone, events never occur if the
23335:   //  menubar is empty.  This doesn't work: 
23335:   //  mbi.dwFlags = SHCMBF_EMPTYBAR;
23335:   
23335:   mbi.nToolBarId = IDC_DUMMY_CE_MENUBAR;
23335:   mbi.hInstRes   = GetModuleHandle(NULL);
23335:   
23335:   if (!SHCreateMenuBar(&mbi))
23335:     return;
23335:   
23335:   SetWindowPos(mbi.hwndMB, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOACTIVATE);
23335:   
23335:   SendMessage(mbi.hwndMB, SHCMBM_OVERRIDEKEY, VK_TBACK,
23335:               MAKELPARAM(SHMBOF_NODEFAULT | SHMBOF_NOTIFY,
23335:                          SHMBOF_NODEFAULT | SHMBOF_NOTIFY));
23335:   
23335:   SendMessage(mbi.hwndMB, SHCMBM_OVERRIDEKEY, VK_TSOFT1, 
23335:               MAKELPARAM (SHMBOF_NODEFAULT | SHMBOF_NOTIFY, 
23335:                           SHMBOF_NODEFAULT | SHMBOF_NOTIFY));
23335:   
23335:   SendMessage(mbi.hwndMB, SHCMBM_OVERRIDEKEY, VK_TSOFT2, 
23335:               MAKELPARAM (SHMBOF_NODEFAULT | SHMBOF_NOTIFY, 
23335:                           SHMBOF_NODEFAULT | SHMBOF_NOTIFY));
23335:   
23335:   gSoftKeyMenuBar = mbi.hwndMB;
23335: }
24972: #endif  //defined(WINCE_HAVE_SOFTKB)
23335: 
23335: 
23335: #define IDI_APPLICATION MAKEINTRESOURCE(32512)
23335: 
23335: #define RDW_NOINTERNALPAINT 0
23335: 
25349: #define SetWindowLongPtrA SetWindowLongW
25349: #define SetWindowLongPtrW SetWindowLongW
25349: #define GetWindowLongPtrW GetWindowLongW
25349: #define GWLP_WNDPROC   GWL_WNDPROC
23335: #define GetPropW       GetProp
23335: #define SetPropW       SetProp
23335: #define RemovePropW    RemoveProp
23335: 
23335: #define MapVirtualKeyEx(a,b,c) MapVirtualKey(a,b)
23335: 
23335: inline void FlashWindow(HWND window, BOOL ignore){}
23335: inline int  GetMessageTime() {return 0;}
23335: inline BOOL IsIconic(HWND inWnd){return false;}
23335: 
23335: typedef struct ECWWindows
23335: {
23335:   LPARAM      params;
23335:   WNDENUMPROC func;
23335:   HWND        parent;
23335: } ECWWindows;
23335: 
23335: static BOOL CALLBACK MyEnumWindowsProc(HWND hwnd, LPARAM lParam)
23335: {
23335:   ECWWindows *myParams = (ECWWindows*) lParam;
23335:   
23335:   if (IsChild(myParams->parent, hwnd))
23335:   {
23335:     return myParams->func(hwnd, myParams->params);
23335:   }
23335:   return TRUE;
23335: }
23335: 
23335: inline BOOL EnumChildWindows(HWND inParent, WNDENUMPROC inFunc, LPARAM inParam)
23335: {
23335:   ECWWindows myParams;
23335:   myParams.params = inParam;
23335:   myParams.func   = inFunc;
23335:   myParams.parent = inParent;
23335:   
23335:   return EnumWindows(MyEnumWindowsProc, (LPARAM) &myParams);
23335: }
23335: 
23335: inline BOOL EnumThreadWindows(DWORD inThreadID, WNDENUMPROC inFunc, LPARAM inParam)
23335: {
23335:   return FALSE;
23335: }
23335: 
24972: #endif  //defined(WINCE)
23335: 
23335: 
16601: 
14962: #ifdef PR_LOGGING
14962: PRLogModuleInfo* sWindowsLog = nsnull;
14962: #endif
14962: 
18534: static const PRUnichar kMozHeapDumpMessageString[] = L"MOZ_HeapDump";
    1: 
    1: #define kWindowPositionSlop 20
    1: 
    1: #ifndef WM_MOUSEHWHEEL
    1: #define WM_MOUSEHWHEEL 0x020E
    1: #endif
    1: 
    1: #ifndef SPI_GETWHEELSCROLLCHARS
    1: #define SPI_GETWHEELSCROLLCHARS 0x006C
    1: #endif
    1: 
    1: #ifndef MAPVK_VSC_TO_VK
14970: #define MAPVK_VK_TO_VSC  0
    1: #define MAPVK_VSC_TO_VK  1
    1: #define MAPVK_VK_TO_CHAR 2
    1: #endif
    1: 
22788: // used for checking the lParam of WM_IME_COMPOSITION
22788: #define IS_COMPOSING_LPARAM(lParam) \
22788:           ((lParam) & (GCS_COMPSTR | GCS_COMPATTR | GCS_COMPCLAUSE | GCS_CURSORPOS))
22788: 
23335: static PRBool IsCursorTranslucencySupported() {
    1: #ifdef WINCE
23335:   return PR_FALSE;
23335: #else
    1:   static PRBool didCheck = PR_FALSE;
    1:   static PRBool isSupported = PR_FALSE;
    1:   if (!didCheck) {
    1:     didCheck = PR_TRUE;
    1:     // Cursor translucency is supported on Windows XP and newer
16024:     isSupported = GetWindowsVersion() >= 0x501;
    1:   }
    1: 
    1:   return isSupported;
23335: #endif
23335: }
    1: 
 4313: PRInt32 GetWindowsVersion()
 4313: {
23335: #ifdef WINCE
23335:   return 0x500;
23335: #else
 4313:   static PRInt32 version = 0;
    1:   static PRBool didCheck = PR_FALSE;
 4313: 
 4313:   if (!didCheck)
 4313:   {
12419:     didCheck = PR_TRUE;
 4313:     OSVERSIONINFOEX osInfo;
 4313:     osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
 4313:     // This cast is safe and supposed to be here, don't worry
 4313:     ::GetVersionEx((OSVERSIONINFO*)&osInfo);
 4313:     version = (osInfo.dwMajorVersion & 0xff) << 8 | (osInfo.dwMinorVersion & 0xff);
 4313:   }
 4313:   return version;
23335: #endif
    1: }
    1: 
17163: 
    1: static NS_DEFINE_CID(kCClipboardCID,       NS_CLIPBOARD_CID);
    1: static NS_DEFINE_IID(kRenderingContextCID, NS_RENDERING_CONTEXT_CID);
    1: 
    1: static const char *sScreenManagerContractID = "@mozilla.org/gfx/screenmanager;1";
    1: 
    1: ////////////////////////////////////////////////////
    1: // nsWindow Class static variable definitions
    1: ////////////////////////////////////////////////////
    1: PRUint32   nsWindow::sInstanceCount            = 0;
    1: 
    1: PRBool     nsWindow::sIMEIsComposing           = PR_FALSE;
    1: PRBool     nsWindow::sIMEIsStatusChanged       = PR_FALSE;
    1: 
    1: nsString*  nsWindow::sIMECompUnicode           = NULL;
    1: PRUint8*   nsWindow::sIMEAttributeArray        = NULL;
    1: PRInt32    nsWindow::sIMEAttributeArrayLength  = 0;
    1: PRInt32    nsWindow::sIMEAttributeArraySize    = 0;
    1: PRUint32*  nsWindow::sIMECompClauseArray       = NULL;
    1: PRInt32    nsWindow::sIMECompClauseArrayLength = 0;
    1: PRInt32    nsWindow::sIMECompClauseArraySize   = 0;
22879: 
22879: // Some IMEs (e.g., the standard IME for Korean) don't have caret position,
22879: // then, we should not set caret position to text event.
22879: #define NO_IME_CARET -1
22879: long       nsWindow::sIMECursorPosition        = NO_IME_CARET;
    1: 
25732: PRBool     nsWindow::sIMENativeCaretIsCreated  = PR_FALSE;
25732: 
    1: RECT*      nsWindow::sIMECompCharPos           = nsnull;
    1: 
22411: PRBool     nsWindow::gSwitchKeyboardLayout     = PR_FALSE;
22411: 
24391: // imported in nsWidgetFactory.cpp
24391: PRBool gDisableNativeTheme = PR_FALSE;
24391: 
23335: #ifndef WINCE
22411: static KeyboardLayout gKbdLayout;
23335: #endif
22411: 
18536: TriStateBool nsWindow::sCanQuit = TRI_UNKNOWN;
 4465: 
    1: BOOL nsWindow::sIsRegistered       = FALSE;
    1: BOOL nsWindow::sIsPopupClassRegistered = FALSE;
 7271: BOOL nsWindow::sIsOleInitialized = FALSE;
    1: UINT nsWindow::uWM_MSIME_MOUSE     = 0; // mouse message for MSIME
    1: UINT nsWindow::uWM_HEAP_DUMP       = 0; // Heap Dump to a file
    1: 
    1: HCURSOR        nsWindow::gHCursor            = NULL;
    1: imgIContainer* nsWindow::gCursorImgContainer = nsnull;
    1: 
    1: 
    1: #ifdef ACCESSIBILITY
    1: BOOL nsWindow::gIsAccessibilityOn = FALSE;
    1: #endif
    1: nsWindow* nsWindow::gCurrentWindow = nsnull;
    1: ////////////////////////////////////////////////////
    1: 
    1: ////////////////////////////////////////////////////
    1: // Rollup Listener - static variable definitions
    1: ////////////////////////////////////////////////////
    1: static nsIRollupListener * gRollupListener           = nsnull;
    1: static nsIWidget         * gRollupWidget             = nsnull;
    1: static PRBool              gRollupConsumeRollupEvent = PR_FALSE;
    1: 
    1: // Hook Data Memebers for Dropdowns
    1: //
    1: // gProcessHook Tells the hook methods whether they should be
    1: //              processing the hook messages
    1: //
    1: static HHOOK        gMsgFilterHook = NULL;
    1: static HHOOK        gCallProcHook  = NULL;
    1: static HHOOK        gCallMouseHook = NULL;
    1: static PRPackedBool gProcessHook   = PR_FALSE;
    1: static UINT         gRollupMsgId   = 0;
    1: static HWND         gRollupMsgWnd  = NULL;
    1: static UINT         gHookTimerId   = 0;
    1: ////////////////////////////////////////////////////
    1: 
    1: 
    1: ////////////////////////////////////////////////////
    1: // Mouse Clicks - static variable definitions
    1: // for figuring out 1 - 3 Clicks
    1: ////////////////////////////////////////////////////
    1: static POINT gLastMousePoint;
    1: static POINT gLastMouseMovePoint;
    1: static LONG  gLastMouseDownTime = 0L;
    1: static LONG  gLastClickCount    = 0L;
    1: static BYTE  gLastMouseButton = 0;
    1: ////////////////////////////////////////////////////
    1: 
    1: // The last user input event time in microseconds. If there are any pending
    1: // native toolkit input events it returns the current time. The value is
    1: // compatible with PR_IntervalToMicroseconds(PR_IntervalNow()).
27326: #ifndef WINCE
27326: static
27326: #endif
27326: PRUint32 gLastInputEventTime = 0;
    1: 
    1: static int gTrimOnMinimize = 2; // uninitialized, but still true
    1: 
    1: #if 0
    1: static PRBool is_vk_down(int vk)
    1: {
    1:    SHORT st = GetKeyState(vk);
    1: #ifdef DEBUG
    1:    printf("is_vk_down vk=%x st=%x\n",vk, st);
    1: #endif
    1:    return (st < 0);
    1: }
    1: #define IS_VK_DOWN is_vk_down
    1: #else
    1: #define IS_VK_DOWN(a) (GetKeyState(a) < 0)
    1: #endif
    1: 
    1: //
    1: // App Command messages for IntelliMouse and Natural Keyboard Pro
    1: //
    1: // These messages are not included in Visual C++ 6.0, but are in 7.0
    1: //
    1: #ifndef WM_APPCOMMAND
    1: #define WM_APPCOMMAND  0x0319
    1: #endif
    1: 
    1: #ifndef APPCOMMAND_BROWSER_BACKWARD
    1: #define APPCOMMAND_BROWSER_BACKWARD       1
    1: #define APPCOMMAND_BROWSER_FORWARD        2
    1: #define APPCOMMAND_BROWSER_REFRESH        3
    1: #define APPCOMMAND_BROWSER_STOP           4
    1: #define APPCOMMAND_BROWSER_SEARCH         5
    1: #define APPCOMMAND_BROWSER_FAVORITES      6
    1: #define APPCOMMAND_BROWSER_HOME           7
    1: // keep these around in case we want them later
    1: //#define APPCOMMAND_VOLUME_MUTE            8
    1: //#define APPCOMMAND_VOLUME_DOWN            9
    1: //#define APPCOMMAND_VOLUME_UP              10
    1: //#define APPCOMMAND_MEDIA_NEXTTRACK        11
    1: //#define APPCOMMAND_MEDIA_PREVIOUSTRACK    12
    1: //#define APPCOMMAND_MEDIA_STOP             13
    1: //#define APPCOMMAND_MEDIA_PLAY_PAUSE       14
    1: //#define APPCOMMAND_LAUNCH_MAIL            15
    1: //#define APPCOMMAND_LAUNCH_MEDIA_SELECT    16
    1: //#define APPCOMMAND_LAUNCH_APP1            17
    1: //#define APPCOMMAND_LAUNCH_APP2            18
    1: //#define APPCOMMAND_BASS_DOWN              19
    1: //#define APPCOMMAND_BASS_BOOST             20
    1: //#define APPCOMMAND_BASS_UP                21
    1: //#define APPCOMMAND_TREBLE_DOWN            22
    1: //#define APPCOMMAND_TREBLE_UP              23
    1: 
    1: //#define FAPPCOMMAND_MOUSE 0x8000
    1: //#define FAPPCOMMAND_KEY   0
    1: //#define FAPPCOMMAND_OEM   0x1000
    1: #define FAPPCOMMAND_MASK  0xF000
    1: 
    1: #define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
    1: //#define GET_DEVICE_LPARAM(lParam)     ((WORD)(HIWORD(lParam) & FAPPCOMMAND_MASK))
    1: //#define GET_MOUSEORKEY_LPARAM         GET_DEVICE_LPARAM
    1: //#define GET_FLAGS_LPARAM(lParam)      (LOWORD(lParam))
    1: //#define GET_KEYSTATE_LPARAM(lParam)   GET_FLAGS_LPARAM(lParam)
    1: 
    1: #endif  // #ifndef APPCOMMAND_BROWSER_BACKWARD
    1: 
19016: #define VERIFY_WINDOW_STYLE(s) \
19016:   NS_ASSERTION(((s) & (WS_CHILD | WS_POPUP)) != (WS_CHILD | WS_POPUP), \
19016:                "WS_POPUP and WS_CHILD are mutually exclusive")
19016: 
19016: HWND nsWindow::GetTopLevelHWND(HWND aWnd, PRBool aStopOnDialogOrPopup)
    1: {
    1:   HWND curWnd = aWnd;
    1:   HWND topWnd = NULL;
    1: 
19016:   while (curWnd) {
    1:     topWnd = curWnd;
    1: 
19016:     if (aStopOnDialogOrPopup) {
25349:       DWORD_PTR style = ::GetWindowLongPtrW(curWnd, GWL_STYLE);
    1: 
19016:       VERIFY_WINDOW_STYLE(style);
19016: 
19016:       if (!(style & WS_CHILD)) // first top-level window
    1:         break;
    1:     }
    1: 
    1:     curWnd = ::GetParent(curWnd);       // Parent or owner (if has no parent)
    1:   }
    1: 
    1:   return topWnd;
    1: }
    1: 
    1: // Code to dispatch WM_SYSCOLORCHANGE message to all child windows.
    1: // WM_SYSCOLORCHANGE is only sent to top-level windows, but the
    1: // cross platform API requires that NS_SYSCOLORCHANGE message be sent to
    1: // all child windows as well. When running in an embedded application
    1: // we may not receive a WM_SYSCOLORCHANGE message because the top
    1: // level window is owned by the embeddor. Note: this code can be used to
    1: // dispatch other global messages (i.e messages that must be sent to all
    1: // nsIWidget instances.
    1: 
    1: // Enumerate all child windows sending aMsg to each of them
    1: 
    1: BOOL CALLBACK nsWindow::BroadcastMsgToChildren(HWND aWnd, LPARAM aMsg)
    1: {
25349:   WNDPROC winProc = (WNDPROC)::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
    1:   if (winProc == &nsWindow::WindowProc) {
    1:     // it's one of our windows so go ahead and send a message to it
    1:     ::CallWindowProcW(winProc, aWnd, aMsg, 0, 0);
    1:   }
    1:   return TRUE;
    1: }
    1: 
    1: // Enumerate all top level windows specifying that the children of each
    1: // top level window should be enumerated. Do *not* send the message to
    1: // each top level window since it is assumed that the toolkit will send
    1: // aMsg to them directly.
    1: 
    1: BOOL CALLBACK nsWindow::BroadcastMsg(HWND aTopWindow, LPARAM aMsg)
    1: {
    1:   // Iterate each of aTopWindows child windows sending the aMsg
    1:   // to each of them.
    1:   EnumChildWindows(aTopWindow, nsWindow::BroadcastMsgToChildren, aMsg);
    1:   return TRUE;
    1: }
    1: 
    1: // This method is called from nsToolkit::WindowProc to forward global
    1: // messages which need to be dispatched to all child windows.
    1: 
    1: void nsWindow::GlobalMsgWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
    1: {
    1:   switch (msg) {
    1:     case WM_SYSCOLORCHANGE:
    1:       // System color changes are posted to top-level windows only.
    1:       // The NS_SYSCOLORCHANGE must be dispatched to all child
    1:       // windows as well.
    1:      ::EnumThreadWindows(GetCurrentThreadId(), nsWindow::BroadcastMsg, msg);
    1:     break;
    1:   }
    1: }
    1: 
    1: // End of the methods to dispatch global messages
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // nsWindow constructor
    1: //
    1: //-------------------------------------------------------------------------
    1: nsWindow::nsWindow() : nsBaseWidget()
    1: {
14962: #ifdef PR_LOGGING
14962:   if (!sWindowsLog)
14962:     sWindowsLog = PR_NewLogModule("nsWindowsWidgets");
14962: #endif
14962: 
    1:   mWnd                = 0;
    1:   mPaintDC            = 0;
    1:   mPrevWndProc        = NULL;
    1:   mBackground         = ::GetSysColor(COLOR_BTNFACE);
    1:   mBrush              = ::CreateSolidBrush(NSRGB_2_COLOREF(mBackground));
    1:   mForeground         = ::GetSysColor(COLOR_WINDOWTEXT);
    1:   mIsShiftDown        = PR_FALSE;
    1:   mIsControlDown      = PR_FALSE;
    1:   mIsAltDown          = PR_FALSE;
    1:   mIsDestroying       = PR_FALSE;
    1:   mDeferredPositioner = NULL;
    1:   mLastPoint.x        = 0;
    1:   mLastPoint.y        = 0;
    1:   mIsVisible          = PR_FALSE;
    1:   mHas3DBorder        = PR_FALSE;
    1: #ifdef MOZ_XUL
16601:   mTransparencyMode   = eTransparencyOpaque;
 9499:   mTransparentSurface = nsnull;
    1:   mMemoryDC           = NULL;
    1: #endif
    1:   mWindowType         = eWindowType_child;
    1:   mBorderStyle        = eBorderStyle_default;
    1:   mUnicodeWidget      = PR_TRUE;
    1:   mIsInMouseCapture   = PR_FALSE;
    1:   mIsInMouseWheelProcessing = PR_FALSE;
    1:   mLastSize.width     = 0;
    1:   mLastSize.height    = 0;
    1:   mOldStyle           = 0;
    1:   mOldExStyle         = 0;
    1:   mPainting           = 0;
    1:   mOldIMC             = NULL;
15919:   mIMEEnabled         = nsIWidget::IME_STATUS_ENABLED;
21999:   mIsPluginWindow     = PR_FALSE;
26576:   mPopupType          = ePopupTypeAny;
    1: 
    1:   mLeadByte = '\0';
    1:   mBlurEventSuppressionLevel = 0;
    1: 
    1:   static BOOL gbInitGlobalValue = FALSE;
    1:   if (! gbInitGlobalValue) {
    1:     gbInitGlobalValue = TRUE;
23335: #ifndef WINCE
22411:     gKbdLayout.LoadLayout(::GetKeyboardLayout(0));
23335: #endif
    1:     // mouse message of MSIME98/2000
    1:     nsWindow::uWM_MSIME_MOUSE     = ::RegisterWindowMessage(RWM_MOUSE);
    1: 
    1:     // Heap dump
18534:     nsWindow::uWM_HEAP_DUMP = ::RegisterWindowMessageW(kMozHeapDumpMessageString);
    1:   }
    1: 
    1:   mNativeDragTarget = nsnull;
    1:   mIsTopWidgetWindow = PR_FALSE;
    1:   mLastKeyboardLayout = 0;
    1: 
24836: #ifdef NS_ENABLE_TSF
24836:   if (!sInstanceCount)
24836:     nsTextStore::Initialize();
24836: #endif //NS_ENABLE_TSF
24836: 
12038: #ifndef WINCE
 7271:   if (!sInstanceCount && SUCCEEDED(::OleInitialize(NULL))) {
 7271:     sIsOleInitialized = TRUE;
 7271:   }
 7271:   NS_ASSERTION(sIsOleInitialized, "***** OLE is not initialized!\n");
24836: #endif
24746: 
27326:   // Set gLastInputEventTime to some valid number
27326:   gLastInputEventTime = PR_IntervalToMicroseconds(PR_IntervalNow());
27326: 
    1:   sInstanceCount++;
23335: }
23335: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // nsWindow destructor
    1: //
    1: //-------------------------------------------------------------------------
    1: nsWindow::~nsWindow()
    1: {
    1:   mIsDestroying = PR_TRUE;
    1:   if (gCurrentWindow == this) {
    1:     gCurrentWindow = nsnull;
    1:   }
    1: 
    1:   MouseTrailer* mtrailer = nsToolkit::gMouseTrailer;
    1:   if (mtrailer) {
    1:     if (mtrailer->GetMouseTrailerWindow() == mWnd)
    1:       mtrailer->DestroyTimer();
    1: 
    1:     if (mtrailer->GetCaptureWindow() == mWnd)
    1:       mtrailer->SetCaptureWindow(nsnull);
    1:   }
    1: 
    1:   // If the widget was released without calling Destroy() then the native
    1:   // window still exists, and we need to destroy it
    1:   if (NULL != mWnd) {
    1:     Destroy();
    1:   }
    1: 
    1:   if (mCursor == -1) {
    1:     // A successfull SetCursor call will destroy the custom cursor, if it's ours
    1:     SetCursor(eCursor_standard);
    1:   }
    1: 
24836:   sInstanceCount--;
24836: 
24836: #ifdef NS_ENABLE_TSF
24836:   if (!sInstanceCount)
24836:     nsTextStore::Terminate();
24836: #endif //NS_ENABLE_TSF
24836: 
24831: #ifndef WINCE
24831:   //
24831:   // delete any of the IME structures that we allocated
24831:   //
    1:   if (sInstanceCount == 0) {
    1:     if (sIMECompUnicode) 
    1:       delete sIMECompUnicode;
    1:     if (sIMEAttributeArray) 
    1:       delete [] sIMEAttributeArray;
    1:     if (sIMECompClauseArray) 
    1:       delete [] sIMECompClauseArray;
    1: 
    1:     NS_IF_RELEASE(gCursorImgContainer);
 7271: 
 7271:     if (sIsOleInitialized) {
 7968:       ::OleFlushClipboard();
 7271:       ::OleUninitialize();
 7271:       sIsOleInitialized = FALSE;
 7271:     }
    1:   }
    1: 
    1:   NS_IF_RELEASE(mNativeDragTarget);
23335: #endif
    1: 
    1: }
    1: 
15919: NS_IMPL_ISUPPORTS_INHERITED0(nsWindow, nsBaseWidget)
    1: 
    1: NS_METHOD nsWindow::CaptureMouse(PRBool aCapture)
    1: {
    1:   if (!nsToolkit::gMouseTrailer) {
    1:     NS_ERROR("nsWindow::CaptureMouse called after nsToolkit destroyed");
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (aCapture) {
    1:     nsToolkit::gMouseTrailer->SetCaptureWindow(mWnd);
    1:     ::SetCapture(mWnd);
    1:   } else {
    1:     nsToolkit::gMouseTrailer->SetCaptureWindow(NULL);
    1:     ::ReleaseCapture();
    1:   }
    1:   mIsInMouseCapture = aCapture;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Default for height modification is to do nothing
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: PRInt32 nsWindow::GetHeight(PRInt32 aProposedHeight)
    1: {
    1:   return(aProposedHeight);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Deferred Window positioning
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: NS_METHOD nsWindow::BeginResizingChildren(void)
    1: {
    1:   if (NULL == mDeferredPositioner)
    1:     mDeferredPositioner = ::BeginDeferWindowPos(1);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_METHOD nsWindow::EndResizingChildren(void)
    1: {
    1:   if (NULL != mDeferredPositioner) {
    1:     ::EndDeferWindowPos(mDeferredPositioner);
    1:     mDeferredPositioner = NULL;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
25183: nsIntPoint nsWindow::WidgetToScreenOffset()
    1: {
    1:   POINT point;
25183:   point.x = 0;
25183:   point.y = 0;
    1:   ::ClientToScreen(mWnd, &point);
25183:   return nsIntPoint(point.x, point.y);
    1: }
    1: 
    1: LPARAM nsWindow::lParamToScreen(LPARAM lParam)
    1: {
    1:   POINT pt;
    1:   pt.x = GET_X_LPARAM(lParam);
    1:   pt.y = GET_Y_LPARAM(lParam);
    1:   ::ClientToScreen(mWnd, &pt);
    1:   return MAKELPARAM(pt.x, pt.y);
    1: }
    1: 
    1: LPARAM nsWindow::lParamToClient(LPARAM lParam)
    1: {
    1:   POINT pt;
    1:   pt.x = GET_X_LPARAM(lParam);
    1:   pt.y = GET_Y_LPARAM(lParam);
    1:   ::ScreenToClient(mWnd, &pt);
    1:   return MAKELPARAM(pt.x, pt.y);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Initialize an event to dispatch
    1: //
    1: //-------------------------------------------------------------------------
23738: void nsWindow::InitEvent(nsGUIEvent& event, nsIntPoint* aPoint)
    1: {
    1:   if (nsnull == aPoint) {     // use the point from the event
23738:     // get the message position in client coordinates
    1:     if (mWnd != NULL) {
    1: 
    1:       DWORD pos = ::GetMessagePos();
    1:       POINT cpos;
    1:       
    1:       cpos.x = GET_X_LPARAM(pos);
    1:       cpos.y = GET_Y_LPARAM(pos);
    1: 
    1:       ::ScreenToClient(mWnd, &cpos);
    1:       event.refPoint.x = cpos.x;
    1:       event.refPoint.y = cpos.y;
    1:     } else {
    1:       event.refPoint.x = 0;
    1:       event.refPoint.y = 0;
    1:     }
    1:   }
    1:   else {                      // use the point override if provided
    1:     event.refPoint.x = aPoint->x;
    1:     event.refPoint.y = aPoint->y;
    1:   }
    1: 
    1:   event.time = ::GetMessageTime();
    1: 
    1:   mLastPoint = event.refPoint;
    1: }
    1: 
    1: /* In some circumstances (opening dependent windows) it makes more sense
    1:    (and fixes a crash bug) to not blur the parent window. */
    1: void nsWindow::SuppressBlurEvents(PRBool aSuppress)
    1: {
    1:   if (aSuppress)
    1:     ++mBlurEventSuppressionLevel; // for this widget
    1:   else {
    1:     NS_ASSERTION(mBlurEventSuppressionLevel > 0, "unbalanced blur event suppression");
    1:     if (mBlurEventSuppressionLevel > 0)
    1:       --mBlurEventSuppressionLevel;
    1:   }
    1: }
    1: 
    1: PRBool nsWindow::BlurEventsSuppressed()
    1: {
    1:   // are they suppressed in this window?
    1:   if (mBlurEventSuppressionLevel > 0)
    1:     return PR_TRUE;
    1: 
    1:   // are they suppressed by any container widget?
    1:   HWND parentWnd = ::GetParent(mWnd);
    1:   if (parentWnd) {
    1:     nsWindow *parent = GetNSWindowPtr(parentWnd);
    1:     if (parent)
    1:       return parent->BlurEventsSuppressed();
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Invokes callback and ProcessEvent method on Event Listener object
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP nsWindow::DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus)
    1: {
    1: #ifdef NS_DEBUG
    1:   debug_DumpEvent(stdout,
    1:                   event->widget,
    1:                   event,
    1:                   nsCAutoString("something"),
    1:                   (PRInt32) mWnd);
    1: #endif // NS_DEBUG
    1: 
    1:   aStatus = nsEventStatus_eIgnore;
    1: 
    1:   // skip processing of suppressed blur events
    1:   if ((event->message == NS_DEACTIVATE || event->message == NS_LOSTFOCUS) &&
    1:       BlurEventsSuppressed())
    1:     return NS_OK;
    1: 
    1:   if (nsnull != mEventCallback) {
    1:     aStatus = (*mEventCallback)(event);
    1:   }
    1: 
    1:   // Dispatch to event listener if event was not consumed
    1:   if ((aStatus != nsEventStatus_eIgnore) && (nsnull != mEventListener)) {
    1:     aStatus = mEventListener->ProcessEvent(*event);
    1:   }
    1: 
    1:   // the window can be destroyed during processing of seemingly innocuous events like, say,
    1:   // mousedowns due to the magic of scripting. mousedowns will return nsEventStatus_eIgnore,
    1:   // which causes problems with the deleted window. therefore:
    1:   if (mOnDestroyCalled)
    1:     aStatus = nsEventStatus_eConsumeNoDefault;
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::DispatchWindowEvent(nsGUIEvent* event)
    1: {
    1:   nsEventStatus status;
    1:   DispatchEvent(event, status);
    1:   return ConvertStatus(status);
    1: }
    1: 
    1: PRBool nsWindow::DispatchWindowEvent(nsGUIEvent* event, nsEventStatus &aStatus) {
    1:   DispatchEvent(event, aStatus);
    1:   return ConvertStatus(aStatus);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Dispatch standard event
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: PRBool nsWindow::DispatchStandardEvent(PRUint32 aMsg)
    1: {
    1:   nsGUIEvent event(PR_TRUE, aMsg, this);
    1:   InitEvent(event);
    1: 
    1:   PRBool result = DispatchWindowEvent(&event);
    1:   return result;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Dispatch app command event
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::DispatchCommandEvent(PRUint32 aEventCommand)
    1: {
    1:   nsCOMPtr<nsIAtom> command;
    1:   switch (aEventCommand) {
    1:     case APPCOMMAND_BROWSER_BACKWARD:
    1:       command = nsWidgetAtoms::Back;
    1:       break;
    1:     case APPCOMMAND_BROWSER_FORWARD:
    1:       command = nsWidgetAtoms::Forward;
    1:       break;
    1:     case APPCOMMAND_BROWSER_REFRESH:
    1:       command = nsWidgetAtoms::Reload;
    1:       break;
    1:     case APPCOMMAND_BROWSER_STOP:
    1:       command = nsWidgetAtoms::Stop;
    1:       break;
    1:     case APPCOMMAND_BROWSER_SEARCH:
    1:       command = nsWidgetAtoms::Search;
    1:       break;
    1:     case APPCOMMAND_BROWSER_FAVORITES:
    1:       command = nsWidgetAtoms::Bookmarks;
    1:       break;
    1:     case APPCOMMAND_BROWSER_HOME:
    1:       command = nsWidgetAtoms::Home;
    1:       break;
    1:     default:
    1:       return PR_FALSE;
    1:   }
    1:   nsCommandEvent event(PR_TRUE, nsWidgetAtoms::onAppCommand, command, this);
    1: 
    1:   InitEvent(event);
    1:   DispatchWindowEvent(&event);
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP nsWindow::CaptureRollupEvents(nsIRollupListener * aListener,
    1:                                             PRBool aDoCapture,
    1:                                             PRBool aConsumeRollupEvent)
    1: {
    1:   if (aDoCapture) {
    1:     /* we haven't bothered carrying a weak reference to gRollupWidget because
    1:        we believe lifespan is properly scoped. this next assertion helps
    1:        assure that remains true. */
    1:     NS_ASSERTION(!gRollupWidget, "rollup widget reassigned before release");
    1:     gRollupConsumeRollupEvent = aConsumeRollupEvent;
    1:     NS_IF_RELEASE(gRollupListener);
    1:     NS_IF_RELEASE(gRollupWidget);
    1:     gRollupListener = aListener;
    1:     NS_ADDREF(aListener);
    1:     gRollupWidget = this;
    1:     NS_ADDREF(this);
    1: 
    1: #ifndef WINCE
    1:     if (!gMsgFilterHook && !gCallProcHook && !gCallMouseHook) {
    1:       RegisterSpecialDropdownHooks();
    1:     }
    1:     gProcessHook = PR_TRUE;
    1: #endif
    1:     
    1:   } else {
    1:     NS_IF_RELEASE(gRollupListener);
    1:     NS_IF_RELEASE(gRollupWidget);
    1:     
    1: #ifndef WINCE
    1:     gProcessHook = PR_FALSE;
    1:     UnregisterSpecialDropdownHooks();
    1: #endif
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsWindow::EventIsInsideWindow(UINT Msg, nsWindow* aWindow)
    1: {
    1:   RECT r;
    1: 
19822: #ifndef WINCE
10757:   if (Msg == WM_ACTIVATEAPP)
    1:     // don't care about activation/deactivation
    1:     return PR_FALSE;
23335: #else
23335:   if (Msg == WM_ACTIVATE)
23335:     // but on Windows CE we do care about
23335:     // activation/deactivation because there doesn't exist
23335:     // cancelable Mouse Activation events
23335:     return PR_TRUE;
    1: #endif
    1: 
    1:   ::GetWindowRect(aWindow->mWnd, &r);
    1:   DWORD pos = ::GetMessagePos();
    1:   POINT mp;
    1:   mp.x = GET_X_LPARAM(pos);
    1:   mp.y = GET_Y_LPARAM(pos);
    1: 
    1:   // was the event inside this window?
    1:   return (PRBool) PtInRect(&r, mp);
    1: }
    1: 
18534: static PRUnichar sPropName[40] = L"";
18534: static PRUnichar* GetNSWindowPropName() {
    1:   if (!*sPropName)
    1:   {
23335:     _snwprintf(sPropName, 39, L"MozillansIWidgetPtr%p", GetCurrentProcessId());
    1:     sPropName[39] = '\0';
    1:   }
    1:   return sPropName;
    1: }
    1: 
    1: nsWindow * nsWindow::GetNSWindowPtr(HWND aWnd) {
18534:   return (nsWindow *) ::GetPropW(aWnd, GetNSWindowPropName());
    1: }
    1: 
    1: BOOL nsWindow::SetNSWindowPtr(HWND aWnd, nsWindow * ptr) {
    1:   if (ptr == NULL) {
18534:     ::RemovePropW(aWnd, GetNSWindowPropName());
    1:     return TRUE;
    1:   } else {
18534:     return ::SetPropW(aWnd, GetNSWindowPropName(), (HANDLE)ptr);
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // the nsWindow procedure for all nsWindows in this toolkit
    1: //
    1: //-------------------------------------------------------------------------
    1: LRESULT CALLBACK nsWindow::WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
    1: {
 8591:   // create this here so that we store the last rolled up popup until after
 8591:   // the event has been processed.
 8591:   nsAutoRollup autoRollup;
 8591: 
    1:   LRESULT popupHandlingResult;
    1:   if ( DealWithPopups(hWnd, msg, wParam, lParam, &popupHandlingResult) )
    1:     return popupHandlingResult;
    1: 
    1:   // Get the window which caused the event and ask it to process the message
    1:   nsWindow *someWindow = GetNSWindowPtr(hWnd);
    1: 
    1:   // XXX This fixes 50208 and we are leaving 51174 open to further investigate
    1:   // why we are hitting this assert
    1:   if (nsnull == someWindow) {
    1:     NS_ASSERTION(someWindow, "someWindow is null, cannot call any CallWindowProc");
    1:     return ::DefWindowProcW(hWnd, msg, wParam, lParam);
    1:   }
    1: 
    1:   // hold on to the window for the life of this method, in case it gets
    1:   // deleted during processing. yes, it's a double hack, since someWindow
    1:   // is not really an interface.
    1:   nsCOMPtr<nsISupports> kungFuDeathGrip;
    1:   if (!someWindow->mIsDestroying) // not if we're in the destructor!
    1:     kungFuDeathGrip = do_QueryInterface((nsBaseWidget*)someWindow);
    1: 
    1:   // Re-direct a tab change message destined for its parent window to the
    1:   // the actual window which generated the event.
    1:   if (msg == WM_NOTIFY) {
    1:     LPNMHDR pnmh = (LPNMHDR) lParam;
    1:     if (pnmh->code == TCN_SELCHANGE) {
    1:       someWindow = GetNSWindowPtr(pnmh->hwndFrom);
    1:     }
    1:   }
    1: 
    1:   if (nsnull != someWindow) {
    1:     LRESULT retValue;
    1:     if (PR_TRUE == someWindow->ProcessMessage(msg, wParam, lParam, &retValue)) {
    1:       return retValue;
    1:     }
    1:   }
    1: 
22482:   return ::CallWindowProcW(someWindow->GetPrevWindowProc(),
22482:                            hWnd, msg, wParam, lParam);
    1: }
    1: 
    1: //WINOLEAPI oleStatus;
    1: //-------------------------------------------------------------------------
    1: //
    1: // Utility method for implementing both Create(nsIWidget ...) and
    1: // Create(nsNativeWidget...)
    1: //-------------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsWindow::StandardWindowCreate(nsIWidget *aParent,
23738:                                const nsIntRect &aRect,
    1:                                EVENT_CALLBACK aHandleEventFunction,
    1:                                nsIDeviceContext *aContext,
    1:                                nsIAppShell *aAppShell,
    1:                                nsIToolkit *aToolkit,
    1:                                nsWidgetInitData *aInitData,
    1:                                nsNativeWidget aNativeParent)
    1: {
    1:   nsIWidget *baseParent = aInitData &&
    1:                          (aInitData->mWindowType == eWindowType_dialog ||
    1:                           aInitData->mWindowType == eWindowType_toplevel ||
    1:                           aInitData->mWindowType == eWindowType_invisible) ?
    1:                          nsnull : aParent;
    1: 
    1:   mIsTopWidgetWindow = (nsnull == baseParent);
    1:   mBounds.width = aRect.width;
    1:   mBounds.height = aRect.height;
    1: 
    1:   BaseCreate(baseParent, aRect, aHandleEventFunction, aContext,
    1:              aAppShell, aToolkit, aInitData);
    1: 
    1:   // Switch to the "main gui thread" if necessary... This method must
    1:   // be executed on the "gui thread"...
    1: 
    1:   nsToolkit* toolkit = (nsToolkit *)mToolkit;
    1:   if (toolkit && !toolkit->IsGuiThread()) {
25349:     DWORD_PTR args[7];
25349:     args[0] = (DWORD_PTR)aParent;
25349:     args[1] = (DWORD_PTR)&aRect;
25349:     args[2] = (DWORD_PTR)aHandleEventFunction;
25349:     args[3] = (DWORD_PTR)aContext;
25349:     args[4] = (DWORD_PTR)aAppShell;
25349:     args[5] = (DWORD_PTR)aToolkit;
25349:     args[6] = (DWORD_PTR)aInitData;
    1: 
    1:     if (nsnull != aParent) {
    1:       // nsIWidget parent dispatch
    1:       MethodInfo info(this, nsWindow::CREATE, 7, args);
    1:       toolkit->CallMethod(&info);
    1:       return NS_OK;
    1:     }
    1:     else {
    1:       // Native parent dispatch
    1:       MethodInfo info(this, nsWindow::CREATE_NATIVE, 5, args);
    1:       toolkit->CallMethod(&info);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   HWND parent;
    1:   if (nsnull != aParent) { // has a nsIWidget parent
    1:     parent = ((aParent) ? (HWND)aParent->GetNativeData(NS_NATIVE_WINDOW) : nsnull);
    1:   } else { // has a nsNative parent
    1:     parent = (HWND)aNativeParent;
    1:   }
    1: 
    1:   if (nsnull != aInitData) {
    1:     SetWindowType(aInitData->mWindowType);
    1:     SetBorderStyle(aInitData->mBorderStyle);
26576:     mPopupType = aInitData->mPopupHint;
    1:   }
    1: 
    1:   mContentType = aInitData ? aInitData->mContentType : eContentTypeInherit;
    1: 
    1:   DWORD style = WindowStyle();
    1:   DWORD extendedStyle = WindowExStyle();
    1: 
    1:   if (mWindowType == eWindowType_popup) {
 8408:     // if a parent was specified, don't use WS_EX_TOPMOST so that the popup
 8408:     // only appears above the parent, instead of all windows
 8408:     if (aParent)
 8408:       extendedStyle = WS_EX_TOOLWINDOW;
 8587:     else
 8587:       parent = NULL;
    1:   } else if (nsnull != aInitData) {
    1:     // See if the caller wants to explictly set clip children and clip siblings
    1:     if (aInitData->clipChildren) {
    1:       style |= WS_CLIPCHILDREN;
    1:     } else {
    1:       style &= ~WS_CLIPCHILDREN;
    1:     }
    1:     if (aInitData->clipSiblings) {
    1:       style |= WS_CLIPSIBLINGS;
    1:     }
    1:   }
    1: 
    1:   mHas3DBorder = (extendedStyle & WS_EX_CLIENTEDGE) > 0;
    1: 
    1:   mWnd = ::CreateWindowExW(extendedStyle,
    1:                            aInitData && aInitData->mDropShadow ?
23186:                            WindowPopupClass() : WindowClass(),
    1:                            L"",
    1:                            style,
    1:                            aRect.x,
    1:                            aRect.y,
    1:                            aRect.width,
    1:                            GetHeight(aRect.height),
    1:                            parent,
    1:                            NULL,
    1:                            nsToolkit::mDllInstance,
    1:                            NULL);
    1: 
    1:   if (!mWnd)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   /*mNativeDragTarget = new nsNativeDragTarget(this);
    1:   if (NULL != mNativeDragTarget) {
    1:     mNativeDragTarget->AddRef();
    1:     if (S_OK == ::CoLockObjectExternal((LPUNKNOWN)mNativeDragTarget,TRUE,FALSE)) {
    1:       if (S_OK == ::RegisterDragDrop(mWnd, (LPDROPTARGET)mNativeDragTarget)) {
    1:       }
    1:     }
    1:   }*/
    1: 
    1:   // call the event callback to notify about creation
    1: 
    1:   DispatchStandardEvent(NS_CREATE);
    1:   SubclassWindow(TRUE);
    1: 
    1:   if (gTrimOnMinimize == 2 && mWindowType == eWindowType_invisible) {
    1:     /* The internal variable set by the config.trim_on_minimize pref
    1:        has not yet been initialized, and this is the hidden window
    1:        (conveniently created before any visible windows, and after
    1:        the profile has been initialized).
    1:        
    1:        Default config.trim_on_minimize to false, to fix bug 76831
    1:        for good.  If anyone complains about this new default, saying
    1:        that a Mozilla app hogs too much memory while minimized, they
    1:        will have that entire bug tattooed on their backside. */
    1: 
    1:     gTrimOnMinimize = 0;
    1:     nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:     if (prefs) {
    1:       nsCOMPtr<nsIPrefBranch> prefBranch;
    1:       prefs->GetBranch(0, getter_AddRefs(prefBranch));
    1:       if (prefBranch) {
24391: 
24391:         PRBool temp;
    1:         if (NS_SUCCEEDED(prefBranch->GetBoolPref("config.trim_on_minimize",
24391:                                                  &temp))
24391:             && temp)
    1:           gTrimOnMinimize = 1;
    1: 
    1:         if (NS_SUCCEEDED(prefBranch->GetBoolPref("intl.keyboard.per_window_layout",
24391:                                                  &temp)))
24391:           gSwitchKeyboardLayout = temp;
24391: 
24391:         if (NS_SUCCEEDED(prefBranch->GetBoolPref("mozilla.widget.disable-native-theme",
24391:                                                  &temp)))
24391:           gDisableNativeTheme = temp;
    1:       }
    1:     }
    1:   }
25278: #if defined(WINCE_HAVE_SOFTKB)
    1:   if (mWindowType == eWindowType_dialog || mWindowType == eWindowType_toplevel )
    1:      CreateSoftKeyMenuBar(mWnd);
    1: #endif
    1: 
26874:   // Enable gesture support for this window.
26874:   if (mWindowType != eWindowType_invisible &&
26874:       mWindowType != eWindowType_plugin &&
26874:       mWindowType != eWindowType_java &&
26874:       mWindowType != eWindowType_toplevel) {
26874:     // eWindowType_toplevel is the top level main frame window. Gesture support
26874:     // there prevents the user from interacting with the title bar or nc
26874:     // areas using a single finger. Java and plugin windows can make their
26874:     // own calls.
26874:     mGesture.InitWinGestureSupport(mWnd);
26874:   }
26874: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Create the proper widget
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Create(nsIWidget *aParent,
23738:                            const nsIntRect &aRect,
    1:                            EVENT_CALLBACK aHandleEventFunction,
    1:                            nsIDeviceContext *aContext,
    1:                            nsIAppShell *aAppShell,
    1:                            nsIToolkit *aToolkit,
    1:                            nsWidgetInitData *aInitData)
    1: {
    1:   if (aInitData)
    1:     mUnicodeWidget = aInitData->mUnicode;
    1:   return(StandardWindowCreate(aParent, aRect, aHandleEventFunction,
    1:                               aContext, aAppShell, aToolkit, aInitData,
    1:                               nsnull));
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // create with a native parent
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: NS_METHOD nsWindow::Create(nsNativeWidget aParent,
23738:                            const nsIntRect &aRect,
    1:                            EVENT_CALLBACK aHandleEventFunction,
    1:                            nsIDeviceContext *aContext,
    1:                            nsIAppShell *aAppShell,
    1:                            nsIToolkit *aToolkit,
    1:                            nsWidgetInitData *aInitData)
    1: {
    1:   if (aInitData)
    1:     mUnicodeWidget = aInitData->mUnicode;
    1:   return(StandardWindowCreate(nsnull, aRect, aHandleEventFunction,
    1:                               aContext, aAppShell, aToolkit, aInitData,
    1:                               aParent));
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Close this nsWindow
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Destroy()
    1: {
    1:   // Switch to the "main gui thread" if necessary... This method must
    1:   // be executed on the "gui thread"...
    1:   nsToolkit* toolkit = (nsToolkit *)mToolkit;
    1:   if (toolkit != nsnull && !toolkit->IsGuiThread()) {
    1:     MethodInfo info(this, nsWindow::DESTROY);
    1:     toolkit->CallMethod(&info);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // disconnect from the parent
    1:   if (!mIsDestroying) {
    1:     nsBaseWidget::Destroy();
    1:   }
    1: 
    1:   // just to be safe. If we're going away and for some reason we're still
    1:   // the rollup widget, rollup and turn off capture.
    1:   if ( this == gRollupWidget ) {
    1:     if ( gRollupListener )
 8591:       gRollupListener->Rollup(nsnull);
    1:     CaptureRollupEvents(nsnull, PR_FALSE, PR_TRUE);
    1:   }
    1: 
    1:   EnableDragDrop(PR_FALSE);
    1: 
    1:   // destroy the HWND
    1:   if (mWnd) {
    1:     // prevent the widget from causing additional events
    1:     mEventCallback = nsnull;
    1: 
    1:     // if IME is disabled, restore it.
    1:     if (mOldIMC) {
    1:       mOldIMC = ::ImmAssociateContext(mWnd, mOldIMC);
    1:       NS_ASSERTION(!mOldIMC, "Another IMC was associated");
    1:     }
    1: 
    1:     HICON icon;
    1:     icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM) 0);
    1:     if (icon)
    1:       ::DestroyIcon(icon);
    1: 
    1:     icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM) 0);
    1:     if (icon)
    1:       ::DestroyIcon(icon);
    1: 
    1: #ifdef MOZ_XUL
16601:     if (eTransparencyTransparent == mTransparencyMode)
16601:     {
16601:       SetupTranslucentWindowMemoryBitmap(eTransparencyOpaque);
    1: 
    1:     }
    1: #endif
    1: 
    1:     VERIFY(::DestroyWindow(mWnd));
    1: 
    1:     mWnd = NULL;
    1:     //our windows can be subclassed by
    1:     //others and these nameless, faceless others
    1:     //may not let us know about WM_DESTROY. so,
    1:     //if OnDestroy() didn't get called, just call
    1:     //it now. MMP
    1:     if (PR_FALSE == mOnDestroyCalled)
    1:       OnDestroy();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::SetParent(nsIWidget *aNewParent)
    1: {
    1:   if (aNewParent) {
 3419:     nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
 3419: 
 3419:     nsIWidget* parent = GetParent();
 3419:     if (parent) {
 3419:       parent->RemoveChild(this);
 3419:     }
 3419: 
    1:     HWND newParent = (HWND)aNewParent->GetNativeData(NS_NATIVE_WINDOW);
    1:     NS_ASSERTION(newParent, "Parent widget has a null native window handle");
 3419:     if (newParent && mWnd) {
    1:       ::SetParent(mWnd, newParent);
 3419:     }
 3419: 
 3419:     aNewParent->AddChild(this);
    1: 
    1:     return NS_OK;
    1:   }
 4577: 
 4577:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
 4577: 
 4577:   nsIWidget* parent = GetParent();
 4577: 
 4577:   if (parent) {
 4577:     parent->RemoveChild(this);
 4577:   }
 4577: 
 4577:   if (mWnd) {
 4577:     ::SetParent(mWnd, nsnull);
 4577:   }
 4577: 
 4577:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get this nsWindow parent
    1: //
    1: //-------------------------------------------------------------------------
    1: nsIWidget* nsWindow::GetParent(void)
    1: {
27505:   return GetParentWindow(PR_FALSE);
27505: }
27505: 
27505: nsWindow* nsWindow::GetParentWindow(PRBool aIncludeOwner)
19016: {
19016:   if (mIsTopWidgetWindow) {
    1:     // Must use a flag instead of mWindowType to tell if the window is the
    1:     // owned by the topmost widget, because a child window can be embedded inside
    1:     // a HWND which is not associated with a nsIWidget.
    1:     return nsnull;
    1:   }
19016: 
    1:   // If this widget has already been destroyed, pretend we have no parent.
    1:   // This corresponds to code in Destroy which removes the destroyed
    1:   // widget from its parent's child list.
    1:   if (mIsDestroying || mOnDestroyCalled)
    1:     return nsnull;
    1: 
27505: 
27505:   // aIncludeOwner set to true implies walking the parent chain to retrieve the
27505:   // root owner. aIncludeOwner set to false implies the search will stop at the
27505:   // true parent (default).
    1:   nsWindow* widget = nsnull;
    1:   if (mWnd) {
27505:     HWND parent = nsnull;
27505:     if (aIncludeOwner)
27505:       parent = ::GetParent(mWnd);
27505:     else
27505:       parent = ::GetAncestor(mWnd, GA_PARENT);
    1:     if (parent) {
    1:       widget = GetNSWindowPtr(parent);
    1:       if (widget) {
    1:         // If the widget is in the process of being destroyed then
    1:         // do NOT return it
    1:         if (widget->mIsDestroying) {
    1:           widget = nsnull;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return widget;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Hide or show this component
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool gWindowsVisible;
    1: 
    1: static BOOL CALLBACK gEnumWindowsProc(HWND hwnd, LPARAM lParam)
    1: {
    1:   DWORD pid;
    1:   ::GetWindowThreadProcessId(hwnd, &pid);
23335:   if (pid == GetCurrentProcessId() && ::IsWindowVisible(hwnd))
    1:   {
    1:     gWindowsVisible = PR_TRUE;
    1:     return FALSE;
    1:   }
    1:   return TRUE;
    1: }
    1: 
    1: PRBool nsWindow::CanTakeFocus()
    1: {
    1:   gWindowsVisible = PR_FALSE;
    1:   EnumWindows(gEnumWindowsProc, 0);
    1:   if (!gWindowsVisible) {
    1:     return PR_TRUE;
    1:   } else {
    1:     HWND fgWnd = ::GetForegroundWindow();
    1:     if (!fgWnd) {
    1:       return PR_TRUE;
    1:     }
    1:     DWORD pid;
    1:     GetWindowThreadProcessId(fgWnd, &pid);
23335:     if (pid == GetCurrentProcessId()) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_METHOD nsWindow::Show(PRBool bState)
    1: {
16326:   PRBool wasVisible = mIsVisible;
16326:   // Set the status now so that anyone asking during ShowWindow or
16326:   // SetWindowPos would get the correct answer.
16326:   mIsVisible = bState;
16326: 
    1:   if (mWnd) {
    1:     if (bState) {
16326:       if (!wasVisible && mWindowType == eWindowType_toplevel) {
    1:         switch (mSizeMode) {
24970: #ifdef WINCE
    1:           case nsSizeMode_Maximized :
24795:             ::SetForegroundWindow(mWnd);
    1:             ::ShowWindow(mWnd, SW_SHOWMAXIMIZED);
    1:             break;
24970:           // use default for nsSizeMode_Minimized on Windows CE
24970: #else
24970:           case nsSizeMode_Maximized :
24970:             ::ShowWindow(mWnd, SW_SHOWMAXIMIZED);
24970:             break;
    1:           case nsSizeMode_Minimized :
    1:             ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
24795:             break;
24795: #endif
    1:           default:
    1:             if (CanTakeFocus()) {
25859: #ifdef WINCE
23335:               ::SetForegroundWindow(mWnd);
23335: #endif
24795:               ::ShowWindow(mWnd, SW_SHOWNORMAL);
    1:             } else {
    1:               // Place the window behind the foreground window
    1:               // (as long as it is not topmost)
    1:               HWND wndAfter = ::GetForegroundWindow();
    1:               if (!wndAfter)
    1:                 wndAfter = HWND_BOTTOM;
25349:               else if (GetWindowLongPtrW(wndAfter, GWL_EXSTYLE) & WS_EX_TOPMOST)
    1:                 wndAfter = HWND_TOP;
    1:               ::SetWindowPos(mWnd, wndAfter, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE | 
    1:                              SWP_NOMOVE | SWP_NOACTIVATE);
    1:               GetAttention(2);
    1:             }
23335:             break;
    1:         }
    1:       } else {
    1:         DWORD flags = SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW;
16326:         if (wasVisible)
    1:           flags |= SWP_NOZORDER;
    1: 
    1:         if (mWindowType == eWindowType_popup) {
    1: #ifndef WINCE
    1:           // ensure popups are the topmost of the TOPMOST
    1:           // layer. Remember not to set the SWP_NOZORDER
    1:           // flag as that might allow the taskbar to overlap
    1:           // the popup.  However on windows ce, we need to
    1:           // activate the popup or clicks will not be sent.
    1:           flags |= SWP_NOACTIVATE;
    1: #endif
 8408:           HWND owner = ::GetWindow(mWnd, GW_OWNER);
 8408:           ::SetWindowPos(mWnd, owner ? 0 : HWND_TOPMOST, 0, 0, 0, 0, flags);
    1:         } else {
26616: #ifndef WINCE
26616:           if (mWindowType == eWindowType_dialog && !CanTakeFocus())
26616:             flags |= SWP_NOACTIVATE;
26616: #endif
    1:           ::SetWindowPos(mWnd, HWND_TOP, 0, 0, 0, 0, flags);
    1:         }
    1:       }
    1:     } else {
    1:       if (mWindowType != eWindowType_dialog) {
    1:         ::ShowWindow(mWnd, SW_HIDE);
    1:       } else {
    1:         ::SetWindowPos(mWnd, 0, 0, 0, 0, 0, SWP_HIDEWINDOW | SWP_NOSIZE | SWP_NOMOVE |
    1:                        SWP_NOZORDER | SWP_NOACTIVATE);
    1:       }
    1:     }
    1:   }
    1:   
    1: #ifdef MOZ_XUL
16326:   if (!wasVisible && bState)
    1:     Invalidate(PR_FALSE);
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Return PR_TRUE if the whether the component is visible, PR_FALSE otherwise
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::IsVisible(PRBool & bState)
    1: {
    1:   bState = mIsVisible;
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Position the window behind the given window
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
    1:                                 nsIWidget *aWidget, PRBool aActivate)
    1: {
    1:   HWND behind = HWND_TOP;
    1:   if (aPlacement == eZPlacementBottom)
    1:     behind = HWND_BOTTOM;
    1:   else if (aPlacement == eZPlacementBelow && aWidget)
    1:     behind = (HWND)aWidget->GetNativeData(NS_NATIVE_WINDOW);
    1:   UINT flags = SWP_NOMOVE | SWP_NOREPOSITION | SWP_NOSIZE;
    1:   if (!aActivate)
    1:     flags |= SWP_NOACTIVATE;
    1: 
    1:   if (!CanTakeFocus() && behind == HWND_TOP)
    1:   {
    1:     // Can't place the window to top so place it behind the foreground window
    1:     // (as long as it is not topmost)
    1:     HWND wndAfter = ::GetForegroundWindow();
    1:     if (!wndAfter)
    1:       behind = HWND_BOTTOM;
25349:     else if (!(GetWindowLongPtrW(wndAfter, GWL_EXSTYLE) & WS_EX_TOPMOST))
    1:       behind = wndAfter;
    1:     flags |= SWP_NOACTIVATE;
    1:   }
    1: 
    1:   ::SetWindowPos(mWnd, behind, 0, 0, 0, 0, flags);
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Maximize, minimize or restore the window.
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP nsWindow::SetSizeMode(PRInt32 aMode) {
    1: 
    1:   nsresult rv;
    1: 
    1:   // Let's not try and do anything if we're already in that state.
    1:   // (This is needed to prevent problems when calling window.minimize(), which
    1:   // calls us directly, and then the OS triggers another call to us.)
    1:   if (aMode == mSizeMode)
    1:     return NS_OK;
    1: 
24970: #ifdef WINCE_WINDOWS_MOBILE
24795:   // on windows mobile, dialogs and top level windows are full screen
24795:   // This is partly due to the lack of a GetWindowPlacement.
24795:   if (mWindowType == eWindowType_dialog || mWindowType == eWindowType_toplevel) {
24795:     aMode = nsSizeMode_Maximized;
24795:   }
24799: #endif
24795: 
    1:   // save the requested state
    1:   rv = nsBaseWidget::SetSizeMode(aMode);
    1:   if (NS_SUCCEEDED(rv) && mIsVisible) {
    1:     int mode;
    1: 
    1:     switch (aMode) {
    1:       case nsSizeMode_Maximized :
    1:         mode = SW_MAXIMIZE;
    1:         break;
24795: #ifndef WINCE
    1:       case nsSizeMode_Minimized :
    1:         mode = gTrimOnMinimize ? SW_MINIMIZE : SW_SHOWMINIMIZED;
    1:         if (!gTrimOnMinimize) {
    1:           // Find the next window that is visible and not minimized.
    1:           HWND hwndBelow = ::GetNextWindow(mWnd, GW_HWNDNEXT);
    1:           while (hwndBelow && (!::IsWindowVisible(hwndBelow) ||
    1:                                ::IsIconic(hwndBelow))) {
    1:             hwndBelow = ::GetNextWindow(hwndBelow, GW_HWNDNEXT);
    1:           }
    1: 
    1:           // Push ourselves to the bottom of the stack, then activate the
    1:           // next window.
    1:           ::SetWindowPos(mWnd, HWND_BOTTOM, 0, 0, 0, 0,
    1:                          SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
    1:           if (hwndBelow)
    1:             ::SetForegroundWindow(hwndBelow);
  995: 
  995:           // Play the minimize sound while we're here, since that is also
  995:           // forgotten when we use SW_SHOWMINIMIZED.
18534:           ::PlaySoundW(L"Minimize", nsnull, SND_ALIAS | SND_NODEFAULT | SND_ASYNC);
    1:         }
24795:         break;
24795: #endif
    1:       default :
    1:         mode = SW_RESTORE;
    1:     }
    1:     ::ShowWindow(mWnd, mode);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Constrain a potential move to fit onscreen
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::ConstrainPosition(PRBool aAllowSlop,
    1:                                       PRInt32 *aX, PRInt32 *aY)
    1: {
    1:   if (!mIsTopWidgetWindow) // only a problem for top-level windows
    1:     return NS_OK;
    1: 
    1:   PRBool doConstrain = PR_FALSE; // whether we have enough info to do anything
    1: 
    1:   /* get our playing field. use the current screen, or failing that
    1:     for any reason, use device caps for the default screen. */
    1:   RECT screenRect;
    1: 
    1:   nsCOMPtr<nsIScreenManager> screenmgr = do_GetService(sScreenManagerContractID);
    1:   if (screenmgr) {
    1:     nsCOMPtr<nsIScreen> screen;
    1:     PRInt32 left, top, width, height;
    1: 
    1:     // zero size rects confuse the screen manager
    1:     width = mBounds.width > 0 ? mBounds.width : 1;
    1:     height = mBounds.height > 0 ? mBounds.height : 1;
    1:     screenmgr->ScreenForRect(*aX, *aY, width, height,
    1:                              getter_AddRefs(screen));
    1:     if (screen) {
    1:       screen->GetAvailRect(&left, &top, &width, &height);
    1:       screenRect.left = left;
    1:       screenRect.right = left+width;
    1:       screenRect.top = top;
    1:       screenRect.bottom = top+height;
    1:       doConstrain = PR_TRUE;
    1:     }
    1:   } else {
    1:     if (mWnd) {
    1:       HDC dc = ::GetDC(mWnd);
    1:       if (dc) {
    1:         if (::GetDeviceCaps(dc, TECHNOLOGY) == DT_RASDISPLAY) {
    1:           ::SystemParametersInfo(SPI_GETWORKAREA, 0, &screenRect, 0);
    1:           doConstrain = PR_TRUE;
    1:         }
    1:         ::ReleaseDC(mWnd, dc);
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (aAllowSlop) {
    1:     if (*aX < screenRect.left - mBounds.width + kWindowPositionSlop)
    1:       *aX = screenRect.left - mBounds.width + kWindowPositionSlop;
    1:     else if (*aX >= screenRect.right - kWindowPositionSlop)
    1:       *aX = screenRect.right - kWindowPositionSlop;
    1: 
    1:     if (*aY < screenRect.top - mBounds.height + kWindowPositionSlop)
    1:       *aY = screenRect.top - mBounds.height + kWindowPositionSlop;
    1:     else if (*aY >= screenRect.bottom - kWindowPositionSlop)
    1:       *aY = screenRect.bottom - kWindowPositionSlop;
    1: 
    1:   } else {
    1: 
    1:     if (*aX < screenRect.left)
    1:       *aX = screenRect.left;
    1:     else if (*aX >= screenRect.right - mBounds.width)
    1:       *aX = screenRect.right - mBounds.width;
    1: 
    1:     if (*aY < screenRect.top)
    1:       *aY = screenRect.top;
    1:     else if (*aY >= screenRect.bottom - mBounds.height)
    1:       *aY = screenRect.bottom - mBounds.height;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
26576: // XP and Vista visual styles sometimes require window clipping regions to be applied for proper
26576: // transparency. These routines are called on size and move operations.
26576: 
26576: void nsWindow::ClearThemeRegion()
26576: {
26576: #ifndef WINCE
26650:   if (nsUXThemeData::sIsVistaOrLater && mTransparencyMode != eTransparencyGlass &&
26650:       mWindowType == eWindowType_popup && (mPopupType == ePopupTypeTooltip || mPopupType == ePopupTypePanel)) {
26576:     SetWindowRgn(mWnd, NULL, false);
26650:   }
26576: #endif
26576: }
26576: 
26576: void nsWindow::SetThemeRegion()
26576: {
26576: #ifndef WINCE
26576:   // Popup types that have a visual styles region applied (bug 376408). This can be expanded
26576:   // for other window types as needed. The regions are applied generically to the base window
26576:   // so default constants are used for part and state. At some point we might need part and
26576:   // state values from nsNativeThemeWin's GetThemePartAndState, but currently windows that
26576:   // change shape based on state haven't come up.
26576:   if (nsUXThemeData::sIsVistaOrLater && mTransparencyMode != eTransparencyGlass &&
26576:       mWindowType == eWindowType_popup && (mPopupType == ePopupTypeTooltip || mPopupType == ePopupTypePanel)) {
26576:     HRGN hRgn = nsnull;
26576:     RECT rect = {0,0,mBounds.width,mBounds.height};
26576:     
26576:     nsUXThemeData::getThemeBackgroundRegion(nsUXThemeData::GetTheme(eUXTooltip), GetDC(mWnd), TTP_STANDARD, TS_NORMAL, &rect, &hRgn);
26576:     if (hRgn) {
26576:       if (!SetWindowRgn(mWnd, hRgn, false)) // do not delete or alter hRgn if accepted.
26576:         DeleteObject(hRgn);
26576:     }
26576:   }
26576: #endif
26576: }
26576: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Move this component
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Move(PRInt32 aX, PRInt32 aY)
    1: {
    1:   // Check to see if window needs to be moved first
    1:   // to avoid a costly call to SetWindowPos. This check
    1:   // can not be moved to the calling code in nsView, because
    1:   // some platforms do not position child windows correctly
    1: 
    1:   // Only perform this check for non-popup windows, since the positioning can
    1:   // in fact change even when the x/y do not.  We always need to perform the
    1:   // check. See bug #97805 for details.
    1:   if (mWindowType != eWindowType_popup && (mBounds.x == aX) && (mBounds.y == aY))
    1:   {
    1:     // Nothing to do, since it is already positioned correctly.
    1:     return NS_OK;
    1:   }
    1: 
    1:   mBounds.x = aX;
    1:   mBounds.y = aY;
    1: 
    1:   if (mWnd) {
    1: #ifdef DEBUG
    1:     // complain if a window is moved offscreen (legal, but potentially worrisome)
    1:     if (mIsTopWidgetWindow) { // only a problem for top-level windows
    1:       // Make sure this window is actually on the screen before we move it
    1:       // XXX: Needs multiple monitor support
    1:       HDC dc = ::GetDC(mWnd);
    1:       if (dc) {
    1:         if (::GetDeviceCaps(dc, TECHNOLOGY) == DT_RASDISPLAY) {
    1:           RECT workArea;
    1:           ::SystemParametersInfo(SPI_GETWORKAREA, 0, &workArea, 0);
    1:           // no annoying assertions. just mention the issue.
    1:           if (aX < 0 || aX >= workArea.right || aY < 0 || aY >= workArea.bottom)
    1:             printf("window moved to offscreen position\n");
    1:         }
    1:       ::ReleaseDC(mWnd, dc);
    1:       }
    1:     }
    1: #endif
    1: 
    1:     nsIWidget *par = GetParent();
    1:     HDWP      deferrer = NULL;
    1: 
    1:     if (nsnull != par) {
    1:       deferrer = ((nsWindow *)par)->mDeferredPositioner;
    1:     }
    1: 
    1:     if (NULL != deferrer) {
    1:       VERIFY(((nsWindow *)par)->mDeferredPositioner = ::DeferWindowPos(deferrer,
    1:                             mWnd, NULL, aX, aY, 0, 0,
    1:                             SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE));
    1:     }
    1:     else {
26576:       ClearThemeRegion();
    1:       VERIFY(::SetWindowPos(mWnd, NULL, aX, aY, 0, 0,
    1:                             SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE));
26576:       SetThemeRegion();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Resize this component
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
    1:   NS_ASSERTION((aWidth >=0 ) , "Negative width passed to nsWindow::Resize");
    1:   NS_ASSERTION((aHeight >=0 ), "Negative height passed to nsWindow::Resize");
    1: 
    1: #ifdef MOZ_XUL
16601:   if (eTransparencyTransparent == mTransparencyMode)
    1:     ResizeTranslucentWindow(aWidth, aHeight);
    1: #endif
    1: 
    1:   // Set cached value for lightweight and printing
    1:   mBounds.width  = aWidth;
    1:   mBounds.height = aHeight;
    1: 
    1:   if (mWnd) {
    1:     nsIWidget *par = GetParent();
    1:     HDWP      deferrer = NULL;
    1: 
    1:     if (nsnull != par) {
    1:       deferrer = ((nsWindow *)par)->mDeferredPositioner;
    1:     }
    1: 
    1:     UINT  flags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE;
    1: #ifndef WINCE
    1:     if (!aRepaint) {
    1:       flags |= SWP_NOREDRAW;
    1:     }
    1: #endif
    1: 
    1:     if (NULL != deferrer) {
    1:       VERIFY(((nsWindow *)par)->mDeferredPositioner = ::DeferWindowPos(deferrer,
    1:                             mWnd, NULL, 0, 0, aWidth, GetHeight(aHeight), flags));
    1:     }
    1:     else {
26576:       ClearThemeRegion();
    1:       VERIFY(::SetWindowPos(mWnd, NULL, 0, 0, aWidth, GetHeight(aHeight), flags));
26576:       SetThemeRegion();
    1:     }
    1:   }
    1: 
    1:   if (aRepaint)
    1:     Invalidate(PR_FALSE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Resize this component
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
    1:   NS_ASSERTION((aWidth >=0 ),  "Negative width passed to nsWindow::Resize");
    1:   NS_ASSERTION((aHeight >=0 ), "Negative height passed to nsWindow::Resize");
    1: 
    1: #ifdef MOZ_XUL
16601:   if (eTransparencyTransparent == mTransparencyMode)
    1:     ResizeTranslucentWindow(aWidth, aHeight);
    1: #endif
    1: 
    1:   // Set cached value for lightweight and printing
    1:   mBounds.x      = aX;
    1:   mBounds.y      = aY;
    1:   mBounds.width  = aWidth;
    1:   mBounds.height = aHeight;
    1: 
    1:   if (mWnd) {
    1:     nsIWidget *par = GetParent();
    1:     HDWP      deferrer = NULL;
    1: 
    1:     if (nsnull != par) {
    1:       deferrer = ((nsWindow *)par)->mDeferredPositioner;
    1:     }
    1: 
    1:     UINT  flags = SWP_NOZORDER | SWP_NOACTIVATE;
    1: #ifndef WINCE
    1:     if (!aRepaint) {
    1:       flags |= SWP_NOREDRAW;
    1:     }
    1: #endif
26576: 
    1:     if (NULL != deferrer) {
    1:       VERIFY(((nsWindow *)par)->mDeferredPositioner = ::DeferWindowPos(deferrer,
    1:                             mWnd, NULL, aX, aY, aWidth, GetHeight(aHeight), flags));
    1:     }
    1:     else {
26576:       ClearThemeRegion();
    1:       VERIFY(::SetWindowPos(mWnd, NULL, aX, aY, aWidth, GetHeight(aHeight), flags));
26576:       SetThemeRegion();
    1:     }
    1:   }
    1: 
    1:   if (aRepaint)
    1:     Invalidate(PR_FALSE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Enable/disable this component
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Enable(PRBool bState)
    1: {
    1:   if (mWnd) {
    1:     ::EnableWindow(mWnd, bState);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_METHOD nsWindow::IsEnabled(PRBool *aState)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aState);
23335: 
23335: #ifndef WINCE
    1:   *aState = !mWnd || (::IsWindowEnabled(mWnd) && ::IsWindowEnabled(::GetAncestor(mWnd, GA_ROOT)));
23335: #else
23335:   *aState = !mWnd || (::IsWindowEnabled(mWnd) && ::IsWindowEnabled(mWnd));
23335: #endif
23335: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Give the focus to this component
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::SetFocus(PRBool aRaise)
    1: {
    1:   //
    1:   // Switch to the "main gui thread" if necessary... This method must
    1:   // be executed on the "gui thread"...
    1:   //
    1:   nsToolkit* toolkit = (nsToolkit *)mToolkit;
    1:   NS_ASSERTION(toolkit != nsnull, "This should never be null!"); // Bug 57044
    1:   if (toolkit != nsnull && !toolkit->IsGuiThread()) {
    1:     MethodInfo info(this, nsWindow::SET_FOCUS);
    1:     toolkit->CallMethod(&info);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (mWnd) {
    1:     // Uniconify, if necessary
    1:     HWND toplevelWnd = GetTopLevelHWND(mWnd);
    1:     if (::IsIconic(toplevelWnd))
    1:       ::ShowWindow(toplevelWnd, SW_RESTORE);
    1:     ::SetFocus(mWnd);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get this component dimension
    1: //
    1: //-------------------------------------------------------------------------
23738: NS_METHOD nsWindow::GetBounds(nsIntRect &aRect)
    1: {
    1:   if (mWnd) {
    1:     RECT r;
    1:     VERIFY(::GetWindowRect(mWnd, &r));
    1: 
    1:     // assign size
    1:     aRect.width  = r.right - r.left;
    1:     aRect.height = r.bottom - r.top;
    1: 
    1:     // convert coordinates if parent exists
    1:     HWND parent = ::GetParent(mWnd);
    1:     if (parent) {
    1:       RECT pr;
    1:       VERIFY(::GetWindowRect(parent, &pr));
    1:       r.left -= pr.left;
    1:       r.top  -= pr.top;
    1:     }
    1:     aRect.x = r.left;
    1:     aRect.y = r.top;
    1:   } else {
    1:     aRect = mBounds;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get this component dimension
    1: //
    1: //-------------------------------------------------------------------------
23738: NS_METHOD nsWindow::GetClientBounds(nsIntRect &aRect)
    1: {
    1:   if (mWnd) {
    1:     RECT r;
    1:     VERIFY(::GetClientRect(mWnd, &r));
    1: 
    1:     // assign size
    1:     aRect.x = 0;
    1:     aRect.y = 0;
    1:     aRect.width  = r.right - r.left;
    1:     aRect.height = r.bottom - r.top;
    1: 
    1:   } else {
    1:     aRect.SetRect(0,0,0,0);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //get the bounds, but don't take into account the client size
    1: 
23738: void nsWindow::GetNonClientBounds(nsIntRect &aRect)
    1: {
    1:   if (mWnd) {
    1:     RECT r;
    1:     VERIFY(::GetWindowRect(mWnd, &r));
    1: 
    1:     // assign size
    1:     aRect.width = r.right - r.left;
    1:     aRect.height = r.bottom - r.top;
    1: 
    1:     // convert coordinates if parent exists
    1:     HWND parent = ::GetParent(mWnd);
    1:     if (parent) {
    1:       RECT pr;
    1:       VERIFY(::GetWindowRect(parent, &pr));
    1:       r.left -= pr.left;
    1:       r.top -= pr.top;
    1:     }
    1:     aRect.x = r.left;
    1:     aRect.y = r.top;
    1:   } else {
    1:     aRect.SetRect(0,0,0,0);
    1:   }
    1: }
    1: 
    1: // like GetBounds, but don't offset by the parent
23738: NS_METHOD nsWindow::GetScreenBounds(nsIntRect &aRect)
    1: {
    1:   if (mWnd) {
    1:     RECT r;
    1:     VERIFY(::GetWindowRect(mWnd, &r));
    1: 
    1:     aRect.width  = r.right - r.left;
    1:     aRect.height = r.bottom - r.top;
    1:     aRect.x = r.left;
    1:     aRect.y = r.top;
    1:   } else
    1:     aRect = mBounds;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Set the background color
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::SetBackgroundColor(const nscolor &aColor)
    1: {
    1:   nsBaseWidget::SetBackgroundColor(aColor);
    1: 
    1:   if (mBrush)
    1:     ::DeleteObject(mBrush);
    1: 
    1:   mBrush = ::CreateSolidBrush(NSRGB_2_COLOREF(mBackground));
    1: #ifndef WINCE
    1:   if (mWnd != NULL) {
25349:     ::SetClassLongPtrW(mWnd, GCLP_HBRBACKGROUND, (LONG_PTR)mBrush);
    1:   }
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Set this component cursor
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: NS_METHOD nsWindow::SetCursor(nsCursor aCursor)
    1: {
    1:   // Only change cursor if it's changing
    1: 
    1:   //XXX mCursor isn't always right.  Scrollbars and others change it, too.
    1:   //XXX If we want this optimization we need a better way to do it.
    1:   //if (aCursor != mCursor) {
    1:   HCURSOR newCursor = NULL;
    1: 
    1:   switch (aCursor) {
    1:     case eCursor_select:
    1:       newCursor = ::LoadCursor(NULL, IDC_IBEAM);
    1:       break;
    1: 
    1:     case eCursor_wait:
    1:       newCursor = ::LoadCursor(NULL, IDC_WAIT);
    1:       break;
    1: 
    1:     case eCursor_hyperlink:
    1:     {
    1:       newCursor = ::LoadCursor(NULL, IDC_HAND);
    1:       break;
    1:     }
    1: 
    1:     case eCursor_standard:
    1:       newCursor = ::LoadCursor(NULL, IDC_ARROW);
    1:       break;
    1: 
    1:     case eCursor_n_resize:
    1:     case eCursor_s_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENS);
    1:       break;
    1: 
    1:     case eCursor_w_resize:
    1:     case eCursor_e_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEWE);
    1:       break;
    1: 
    1:     case eCursor_nw_resize:
    1:     case eCursor_se_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENWSE);
    1:       break;
    1: 
    1:     case eCursor_ne_resize:
    1:     case eCursor_sw_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENESW);
    1:       break;
    1: 
    1:     case eCursor_crosshair:
    1:       newCursor = ::LoadCursor(NULL, IDC_CROSS);
    1:       break;
    1: 
    1:     case eCursor_move:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEALL);
    1:       break;
    1: 
    1:     case eCursor_help:
    1:       newCursor = ::LoadCursor(NULL, IDC_HELP);
    1:       break;
    1: 
    1:     case eCursor_copy: // CSS3
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_COPY));
    1:       break;
    1: 
    1:     case eCursor_alias:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ALIAS));
    1:       break;
    1: 
    1:     case eCursor_cell:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_CELL));
    1:       break;
    1: 
    1:     case eCursor_grab:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_GRAB));
    1:       break;
    1: 
    1:     case eCursor_grabbing:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_GRABBING));
    1:       break;
    1: 
    1:     case eCursor_spinning:
    1:       newCursor = ::LoadCursor(NULL, IDC_APPSTARTING);
    1:       break;
    1: 
    1:     case eCursor_context_menu:
    1:       // XXX this CSS3 cursor needs to be implemented
    1:       break;
    1: 
    1:     case eCursor_zoom_in:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ZOOMIN));
    1:       break;
    1: 
    1:     case eCursor_zoom_out:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ZOOMOUT));
    1:       break;
    1: 
    1:     case eCursor_not_allowed:
    1:     case eCursor_no_drop:
    1:       newCursor = ::LoadCursor(NULL, IDC_NO);
    1:       break;
    1: 
    1:     case eCursor_col_resize:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_COLRESIZE));
    1:       break;
    1: 
    1:     case eCursor_row_resize:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ROWRESIZE));
    1:       break;
    1: 
    1:     case eCursor_vertical_text:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_VERTICALTEXT));
    1:       break;
    1: 
    1:     case eCursor_all_scroll:
    1:       // XXX not 100% appropriate perhaps
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEALL);
    1:       break;
    1: 
    1:     case eCursor_nesw_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENESW);
    1:       break;
    1: 
    1:     case eCursor_nwse_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENWSE);
    1:       break;
    1: 
    1:     case eCursor_ns_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENS);
    1:       break;
    1: 
    1:     case eCursor_ew_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEWE);
    1:       break;
    1: 
10405:     case eCursor_none:
10405:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_NONE));
10405:       break;
10405: 
    1:     default:
    1:       NS_ERROR("Invalid cursor type");
    1:       break;
    1:   }
    1: 
    1:   if (NULL != newCursor) {
    1:     mCursor = aCursor;
    1:     HCURSOR oldCursor = ::SetCursor(newCursor);
    1:     
    1:     if (gHCursor == oldCursor) {
    1:       NS_IF_RELEASE(gCursorImgContainer);
    1:       if (gHCursor != NULL)
    1:         ::DestroyIcon(gHCursor);
    1:       gHCursor = NULL;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 4857: static PRUint8* Data32BitTo1Bit(PRUint8* aImageData,
 4857:                                 PRUint32 aWidth, PRUint32 aHeight)
 4857: {
 4857:   // We need (aWidth + 7) / 8 bytes plus zero-padding up to a multiple of
 4857:   // 4 bytes for each row (HBITMAP requirement). Bug 353553.
 4857:   PRUint32 outBpr = ((aWidth + 31) / 8) & ~3;
 4857: 
 6354:   // Allocate and clear mask buffer
 6354:   PRUint8* outData = (PRUint8*)PR_Calloc(outBpr, aHeight);
 4857:   if (!outData)
 4857:     return NULL;
 4857: 
 6354:   PRInt32 *imageRow = (PRInt32*)aImageData;
 4857:   for (PRUint32 curRow = 0; curRow < aHeight; curRow++) {
 6354:     PRUint8 *outRow = outData + curRow * outBpr;
 6354:     PRUint8 mask = 0x80;
 4857:     for (PRUint32 curCol = 0; curCol < aWidth; curCol++) {
 6354:       // Use sign bit to test for transparency, as alpha byte is highest byte
 6354:       if (*imageRow++ < 0)
 6354:         *outRow |= mask;
 6354: 
 6354:       mask >>= 1;
 6354:       if (!mask) {
 6354:         outRow ++;
 6354:         mask = 0x80;
 6354:       }
 6354:     }
 4857:   }
 4857: 
 4857:   return outData;
 4857: }
 4857: 
 6354: /**
 6354:  * Convert the given image data to a HBITMAP. If the requested depth is
 6354:  * 32 bit and the OS supports translucency, a bitmap with an alpha channel
 6354:  * will be returned.
 6354:  *
 6354:  * @param aImageData The image data to convert. Must use the format accepted
 6354:  *                   by CreateDIBitmap.
 6354:  * @param aWidth     With of the bitmap, in pixels.
 6354:  * @param aHeight    Height of the image, in pixels.
 6354:  * @param aDepth     Image depth, in bits. Should be one of 1, 24 and 32.
 6354:  *
 6354:  * @return The HBITMAP representing the image. Caller should call
 6354:  *         DeleteObject when done with the bitmap.
 6354:  *         On failure, NULL will be returned.
 6354:  */
 6354: static HBITMAP DataToBitmap(PRUint8* aImageData,
    1:                             PRUint32 aWidth,
    1:                             PRUint32 aHeight,
    1:                             PRUint32 aDepth)
    1: {
23335: #ifndef WINCE
 6354:   HDC dc = ::GetDC(NULL);
    1: 
    1:   if (aDepth == 32 && IsCursorTranslucencySupported()) {
    1:     // Alpha channel. We need the new header.
    1:     BITMAPV4HEADER head = { 0 };
    1:     head.bV4Size = sizeof(head);
    1:     head.bV4Width = aWidth;
    1:     head.bV4Height = aHeight;
    1:     head.bV4Planes = 1;
    1:     head.bV4BitCount = aDepth;
    1:     head.bV4V4Compression = BI_BITFIELDS;
    1:     head.bV4SizeImage = 0; // Uncompressed
    1:     head.bV4XPelsPerMeter = 0;
    1:     head.bV4YPelsPerMeter = 0;
    1:     head.bV4ClrUsed = 0;
    1:     head.bV4ClrImportant = 0;
    1: 
    1:     head.bV4RedMask   = 0x00FF0000;
    1:     head.bV4GreenMask = 0x0000FF00;
    1:     head.bV4BlueMask  = 0x000000FF;
    1:     head.bV4AlphaMask = 0xFF000000;
    1: 
    1:     HBITMAP bmp = ::CreateDIBitmap(dc,
 3233:                                    reinterpret_cast<CONST BITMAPINFOHEADER*>(&head),
    1:                                    CBM_INIT,
    1:                                    aImageData,
 3233:                                    reinterpret_cast<CONST BITMAPINFO*>(&head),
    1:                                    DIB_RGB_COLORS);
 6354:     ::ReleaseDC(NULL, dc);
    1:     return bmp;
    1:   }
    1: 
 6354:   char reserved_space[sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 2];
 6354:   BITMAPINFOHEADER& head = *(BITMAPINFOHEADER*)reserved_space;
    1: 
    1:   head.biSize = sizeof(BITMAPINFOHEADER);
    1:   head.biWidth = aWidth;
    1:   head.biHeight = aHeight;
    1:   head.biPlanes = 1;
    1:   head.biBitCount = (WORD)aDepth;
    1:   head.biCompression = BI_RGB;
    1:   head.biSizeImage = 0; // Uncompressed
    1:   head.biXPelsPerMeter = 0;
    1:   head.biYPelsPerMeter = 0;
    1:   head.biClrUsed = 0;
    1:   head.biClrImportant = 0;
    1:   
    1:   BITMAPINFO& bi = *(BITMAPINFO*)reserved_space;
    1: 
    1:   if (aDepth == 1) {
    1:     RGBQUAD black = { 0, 0, 0, 0 };
    1:     RGBQUAD white = { 255, 255, 255, 0 };
    1: 
    1:     bi.bmiColors[0] = white;
    1:     bi.bmiColors[1] = black;
    1:   }
    1: 
    1:   HBITMAP bmp = ::CreateDIBitmap(dc, &head, CBM_INIT, aImageData, &bi, DIB_RGB_COLORS);
 6354:   ::ReleaseDC(NULL, dc);
    1:   return bmp;
23335: #else
23335:   return nsnull;
23335: #endif
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,
    1:                                   PRUint32 aHotspotX, PRUint32 aHotspotY)
    1: {
    1:   if (gCursorImgContainer == aCursor && gHCursor) {
    1:     ::SetCursor(gHCursor);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Get the image data
    1:   nsCOMPtr<gfxIImageFrame> frame;
    1:   aCursor->GetFrameAt(0, getter_AddRefs(frame));
    1:   if (!frame)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:   PRInt32 width, height;
    1:   frame->GetWidth(&width);
    1:   frame->GetHeight(&height);
    1: 
 6354:   // Reject cursors greater than 128 pixels in either direction, to prevent
    1:   // spoofing.
    1:   // XXX ideally we should rescale. Also, we could modify the API to
    1:   // allow trusted content to set larger cursors.
    1:   if (width > 128 || height > 128)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:   frame->LockImageData();
    1: 
    1:   PRUint32 dataLen;
    1:   PRUint8 *data;
    1:   nsresult rv = frame->GetImageData(&data, &dataLen);
    1:   if (NS_FAILED(rv)) {
    1:     frame->UnlockImageData();
    1:     return rv;
    1:   }
    1: 
 6354:   HBITMAP bmp = DataToBitmap(data, width, -height, 32);
 6354:   PRUint8* a1data = Data32BitTo1Bit(data, width, height);
    1:   frame->UnlockImageData();
 4857:   if (!a1data) {
 4857:     return NS_ERROR_FAILURE;
 4857:   }
 4857: 
 6354:   HBITMAP mbmp = DataToBitmap(a1data, width, -height, 1);
 6354:   PR_Free(a1data);
    1: 
    1:   ICONINFO info = {0};
    1:   info.fIcon = FALSE;
    1:   info.xHotspot = aHotspotX;
    1:   info.yHotspot = aHotspotY;
 4857:   info.hbmMask = mbmp;
    1:   info.hbmColor = bmp;
    1:   
    1:   HCURSOR cursor = ::CreateIconIndirect(&info);
 4857:   ::DeleteObject(mbmp);
    1:   ::DeleteObject(bmp);
    1:   if (cursor == NULL) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   mCursor = nsCursor(-1);
    1:   ::SetCursor(cursor);
    1: 
    1:   NS_IF_RELEASE(gCursorImgContainer);
    1:   gCursorImgContainer = aCursor;
    1:   NS_ADDREF(gCursorImgContainer);
    1: 
    1:   if (gHCursor != NULL)
    1:     ::DestroyIcon(gHCursor);
    1:   gHCursor = cursor;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::HideWindowChrome(PRBool aShouldHide)
    1: {
    1:   HWND hwnd = GetTopLevelHWND(mWnd, PR_TRUE);
    1:   if (!GetNSWindowPtr(hwnd))
    1:   {
    1:     NS_WARNING("Trying to hide window decorations in an embedded context");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
25349:   DWORD_PTR style, exStyle;
    1:   if (aShouldHide) {
25349:     DWORD_PTR tempStyle = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
25349:     DWORD_PTR tempExStyle = ::GetWindowLongPtrW(hwnd, GWL_EXSTYLE);
    1: 
    1:     style = tempStyle & ~(WS_CAPTION | WS_THICKFRAME);
    1:     exStyle = tempExStyle & ~(WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE |
    1:                               WS_EX_CLIENTEDGE | WS_EX_STATICEDGE);
    1: 
    1:     mOldStyle = tempStyle;
    1:     mOldExStyle = tempExStyle;
    1:   }
    1:   else {
    1:     if (!mOldStyle || !mOldExStyle) {
25349:       mOldStyle = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
25349:       mOldExStyle = ::GetWindowLongPtrW(hwnd, GWL_EXSTYLE);
    1:     }
    1: 
    1:     style = mOldStyle;
    1:     exStyle = mOldExStyle;
    1:   }
    1: 
19016:   VERIFY_WINDOW_STYLE(style);
25349:   ::SetWindowLongPtrW(hwnd, GWL_STYLE, style);
25349:   ::SetWindowLongPtrW(hwnd, GWL_EXSTYLE, exStyle);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // ------------------------------------------------------------------------
    1: //
    1: // Validate a visible area of a widget.
    1: //
    1: // ------------------------------------------------------------------------
    1: 
    1: NS_METHOD nsWindow::Validate()
    1: {
    1:   if (mWnd)
    1:     VERIFY(::ValidateRect(mWnd, NULL));
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Invalidate this component visible area
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Invalidate(PRBool aIsSynchronous)
    1: {
    1:   if (mWnd)
    1:   {
    1: #ifdef NS_DEBUG
    1:     debug_DumpInvalidate(stdout,
    1:                          this,
    1:                          nsnull,
    1:                          aIsSynchronous,
    1:                          nsCAutoString("noname"),
    1:                          (PRInt32) mWnd);
    1: #endif // NS_DEBUG
    1: 
    1:     VERIFY(::InvalidateRect(mWnd, NULL, FALSE));
    1: 
    1:     if (aIsSynchronous) {
    1:       VERIFY(::UpdateWindow(mWnd));
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Invalidate this component visible area
    1: //
    1: //-------------------------------------------------------------------------
23738: NS_METHOD nsWindow::Invalidate(const nsIntRect & aRect, PRBool aIsSynchronous)
    1: {
    1:   if (mWnd)
    1:   {
    1: #ifdef NS_DEBUG
    1:     debug_DumpInvalidate(stdout,
    1:                          this,
    1:                          &aRect,
    1:                          aIsSynchronous,
    1:                          nsCAutoString("noname"),
    1:                          (PRInt32) mWnd);
    1: #endif // NS_DEBUG
    1: 
    1:     RECT rect;
    1: 
    1:     rect.left   = aRect.x;
    1:     rect.top    = aRect.y;
    1:     rect.right  = aRect.x + aRect.width;
    1:     rect.bottom = aRect.y + aRect.height;
    1: 
    1:     VERIFY(::InvalidateRect(mWnd, &rect, FALSE));
    1: 
    1:     if (aIsSynchronous) {
    1:       VERIFY(::UpdateWindow(mWnd));
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Force a synchronous repaint of the window
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP nsWindow::Update()
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   // updates can come through for windows no longer holding an mWnd during
    1:   // deletes triggered by JavaScript in buttons with mouse feedback
    1:   if (mWnd)
    1:     VERIFY(::UpdateWindow(mWnd));
    1: 
    1:   return rv;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Return some native data according to aDataType
    1: //
    1: //-------------------------------------------------------------------------
    1: void* nsWindow::GetNativeData(PRUint32 aDataType)
    1: {
    1:   switch (aDataType) {
21999:     case NS_NATIVE_PLUGIN_PORT:
21999:       mIsPluginWindow = 1;
    1:     case NS_NATIVE_WIDGET:
    1:     case NS_NATIVE_WINDOW:
    1:       return (void*)mWnd;
    1:     case NS_NATIVE_GRAPHIC:
    1:       // XXX:  This is sleezy!!  Remember to Release the DC after using it!
    1: #ifdef MOZ_XUL
16601:       return (void*)(eTransparencyTransparent == mTransparencyMode) ?
    1:         mMemoryDC : ::GetDC(mWnd);
    1: #else
    1:       return (void*)::GetDC(mWnd);
    1: #endif
24836: 
24836: #ifdef NS_ENABLE_TSF
25395:     case NS_NATIVE_TSF_THREAD_MGR:
25395:       return nsTextStore::GetThreadMgr();
25395:     case NS_NATIVE_TSF_CATEGORY_MGR:
25395:       return nsTextStore::GetCategoryMgr();
25395:     case NS_NATIVE_TSF_DISPLAY_ATTR_MGR:
25395:       return nsTextStore::GetDisplayAttrMgr();
24836: #endif //NS_ENABLE_TSF
24836: 
    1:     default:
    1:       break;
    1:   }
    1: 
    1:   return NULL;
    1: }
    1: 
    1: //~~~
    1: void nsWindow::FreeNativeData(void * data, PRUint32 aDataType)
    1: {
    1:   switch (aDataType)
    1:   {
    1:     case NS_NATIVE_GRAPHIC:
    1: #ifdef MOZ_XUL
16601:       if (eTransparencyTransparent != mTransparencyMode)
    1:         ::ReleaseDC(mWnd, (HDC)data);
    1: #else
    1:       ::ReleaseDC(mWnd, (HDC)data);
    1: #endif
    1:       break;
    1:     case NS_NATIVE_WIDGET:
    1:     case NS_NATIVE_WINDOW:
    1:     case NS_NATIVE_PLUGIN_PORT:
    1:       break;
    1:     default:
    1:       break;
    1:   }
    1: }
    1: 
    1: 
 7640: // Invalidates a window if it's not one of ours, for example
 7640: // a window created by a plugin.
 7640: BOOL CALLBACK nsWindow::InvalidateForeignChildWindows(HWND aWnd, LPARAM aMsg)
 7640: {
25349:   LONG_PTR proc = ::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
25349:   if (proc != (LONG_PTR)&nsWindow::WindowProc) {
 7640:     // This window is not one of our windows so invalidate it.
 7640:     VERIFY(::InvalidateRect(aWnd, NULL, FALSE));    
 7640:   }
 7640:   return TRUE;
 7640: }
 7640: 
 7640: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Scroll the bits of a window
    1: //
    1: //-------------------------------------------------------------------------
23738: NS_METHOD nsWindow::Scroll(PRInt32 aDx, PRInt32 aDy, nsIntRect *aClipRect)
    1: {
    1:   RECT  trect;
    1: 
    1:   if (nsnull != aClipRect)
    1:   {
    1:     trect.left = aClipRect->x;
    1:     trect.top = aClipRect->y;
    1:     trect.right = aClipRect->XMost();
    1:     trect.bottom = aClipRect->YMost();
    1:   }
    1: 
 1913:   ::ScrollWindowEx(mWnd, aDx, aDy, NULL, (nsnull != aClipRect) ? &trect : NULL,
    1:                    NULL, NULL, SW_INVALIDATE | SW_SCROLLCHILDREN);
 7640:   // Invalidate all child windows that aren't ours; we're moving them, and we
 7640:   // expect them to be painted at the new location even if they're outside the
 7640:   // region we're bit-blit scrolling. See bug 387701.
 7640:   ::EnumChildWindows(GetWindowHandle(), nsWindow::InvalidateForeignChildWindows, NULL);
    1:   ::UpdateWindow(mWnd);
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Every function that needs a thread switch goes through this function
    1: // by calling SendMessage (..WM_CALLMETHOD..) in nsToolkit::CallMethod.
    1: //
    1: //-------------------------------------------------------------------------
    1: BOOL nsWindow::CallMethod(MethodInfo *info)
    1: {
    1:   BOOL bRet = TRUE;
    1: 
    1:   switch (info->methodId) {
    1:     case nsWindow::CREATE:
    1:       NS_ASSERTION(info->nArgs == 7, "Wrong number of arguments to CallMethod");
    1:       Create((nsIWidget*)(info->args[0]),
23738:              (nsIntRect&)*(nsIntRect*)(info->args[1]),
    1:              (EVENT_CALLBACK)(info->args[2]),
    1:              (nsIDeviceContext*)(info->args[3]),
    1:              (nsIAppShell *)(info->args[4]),
    1:              (nsIToolkit*)(info->args[5]),
    1:              (nsWidgetInitData*)(info->args[6]));
    1:       break;
    1: 
    1:     case nsWindow::CREATE_NATIVE:
    1:       NS_ASSERTION(info->nArgs == 7, "Wrong number of arguments to CallMethod");
    1:       Create((nsNativeWidget)(info->args[0]),
23738:              (nsIntRect&)*(nsIntRect*)(info->args[1]),
    1:              (EVENT_CALLBACK)(info->args[2]),
    1:              (nsIDeviceContext*)(info->args[3]),
    1:              (nsIAppShell *)(info->args[4]),
    1:              (nsIToolkit*)(info->args[5]),
    1:              (nsWidgetInitData*)(info->args[6]));
    1:       return TRUE;
    1: 
    1:     case nsWindow::DESTROY:
    1:       NS_ASSERTION(info->nArgs == 0, "Wrong number of arguments to CallMethod");
    1:       Destroy();
    1:       break;
    1: 
    1:     case nsWindow::SET_FOCUS:
    1:       NS_ASSERTION(info->nArgs == 0, "Wrong number of arguments to CallMethod");
    1:       SetFocus(PR_FALSE);
    1:       break;
    1: 
    1:     default:
    1:       bRet = FALSE;
    1:       break;
    1:   }
    1: 
    1:   return bRet;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: void nsWindow::SetUpForPaint(HDC aHDC)
    1: {
    1:   ::SetBkColor (aHDC, NSRGB_2_COLOREF(mBackground));
    1:   ::SetTextColor(aHDC, NSRGB_2_COLOREF(mForeground));
    1:   ::SetBkMode (aHDC, TRANSPARENT);
    1: }
    1: 
    1: //---------------------------------------------------------
    1: NS_METHOD nsWindow::EnableDragDrop(PRBool aEnable)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: #ifndef WINCE
    1:   if (aEnable) {
    1:     if (nsnull == mNativeDragTarget) {
    1:        mNativeDragTarget = new nsNativeDragTarget(this);
    1:        if (NULL != mNativeDragTarget) {
    1:          mNativeDragTarget->AddRef();
    1:          if (S_OK == ::CoLockObjectExternal((LPUNKNOWN)mNativeDragTarget,TRUE,FALSE)) {
    1:            if (S_OK == ::RegisterDragDrop(mWnd, (LPDROPTARGET)mNativeDragTarget)) {
    1:              rv = NS_OK;
    1:            }
    1:          }
    1:        }
    1:     }
    1:   } else {
    1:     if (nsnull != mWnd && NULL != mNativeDragTarget) {
    1:       ::RevokeDragDrop(mWnd);
    1:       if (S_OK == ::CoLockObjectExternal((LPUNKNOWN)mNativeDragTarget, FALSE, TRUE)) {
    1:         rv = NS_OK;
    1:       }
 6417:       mNativeDragTarget->mDragCancelled = PR_TRUE;
    1:       NS_RELEASE(mNativeDragTarget);
    1:     }
    1:   }
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: UINT nsWindow::MapFromNativeToDOM(UINT aNativeKeyCode)
    1: {
23335: #ifndef WINCE
    1:   switch (aNativeKeyCode) {
    1:     case VK_OEM_1:     return NS_VK_SEMICOLON;     // 0xBA, For the US standard keyboard, the ';:' key
    1:     case VK_OEM_PLUS:  return NS_VK_ADD;           // 0xBB, For any country/region, the '+' key
    1:     case VK_OEM_MINUS: return NS_VK_SUBTRACT;      // 0xBD, For any country/region, the '-' key
    1:   }
23335: #endif
    1: 
    1:   return aNativeKeyCode;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // OnKey
    1: //
    1: //-------------------------------------------------------------------------
14328: PRBool nsWindow::DispatchKeyEvent(PRUint32 aEventType, WORD aCharCode,
14476:                    const nsTArray<nsAlternativeCharCode>* aAlternativeCharCodes,
22788:                    UINT aVirtualCharCode, const MSG *aMsg,
22788:                    PRUint32 aFlags)
    1: {
    1:   nsKeyEvent event(PR_TRUE, aEventType, this);
23738:   nsIntPoint point(0, 0);
    1: 
    1:   InitEvent(event, &point); // this add ref's event.widget
    1: 
    1:   event.flags |= aFlags;
    1:   event.charCode = aCharCode;
14476:   if (aAlternativeCharCodes)
14476:     event.alternativeCharCodes.AppendElements(*aAlternativeCharCodes);
    1:   event.keyCode  = aVirtualCharCode;
    1: 
    1: #ifdef KE_DEBUG
    1:   static cnt=0;
    1:   printf("%d DispatchKE Type: %s charCode %d  keyCode %d ", cnt++,
    1:         (NS_KEY_PRESS == aEventType) ? "PRESS" : (aEventType == NS_KEY_UP ? "Up" : "Down"),
    1:          event.charCode, event.keyCode);
    1:   printf("Shift: %s Control %s Alt: %s \n", 
    1:          (mIsShiftDown ? "D" : "U"), (mIsControlDown ? "D" : "U"), (mIsAltDown ? "D" : "U"));
    1:   printf("[%c][%c][%c] <==   [%c][%c][%c][ space bar ][%c][%c][%c]\n",
    1:          IS_VK_DOWN(NS_VK_SHIFT) ? 'S' : ' ',
    1:          IS_VK_DOWN(NS_VK_CONTROL) ? 'C' : ' ',
    1:          IS_VK_DOWN(NS_VK_ALT) ? 'A' : ' ',
    1:          IS_VK_DOWN(VK_LSHIFT) ? 'S' : ' ',
    1:          IS_VK_DOWN(VK_LCONTROL) ? 'C' : ' ',
    1:          IS_VK_DOWN(VK_LMENU) ? 'A' : ' ',
    1:          IS_VK_DOWN(VK_RMENU) ? 'A' : ' ',
    1:          IS_VK_DOWN(VK_RCONTROL) ? 'C' : ' ',
    1:          IS_VK_DOWN(VK_RSHIFT) ? 'S' : ' ');
    1: #endif
    1: 
    1:   event.isShift   = mIsShiftDown;
    1:   event.isControl = mIsControlDown;
    1:   event.isMeta    = PR_FALSE;
    1:   event.isAlt     = mIsAltDown;
    1: 
    1:   nsPluginEvent pluginEvent;
22788:   if (aMsg && PluginHasFocus()) {
22788:     pluginEvent.event = aMsg->message;
22788:     pluginEvent.wParam = aMsg->wParam;
22788:     pluginEvent.lParam = aMsg->lParam;
    1:     event.nativeMsg = (void *)&pluginEvent;
22788:   }
    1: 
    1:   PRBool result = DispatchWindowEvent(&event);
    1: 
    1:   return result;
    1: }
    1: 
22788: void nsWindow::RemoveMessageAndDispatchPluginEvent(UINT aFirstMsg,
22788:                                                    UINT aLastMsg)
22788: {
22788:   MSG msg;
22788:   ::GetMessageW(&msg, mWnd, aFirstMsg, aLastMsg);
22788:   DispatchPluginEvent(msg);
22788: }
22788: 
14799: static PRBool
22232: StringCaseInsensitiveEquals(const PRUnichar* aChars1, const PRUint32 aNumChars1,
22232:                             const PRUnichar* aChars2, const PRUint32 aNumChars2)
14799: {
14799:   if (aNumChars1 != aNumChars2)
14799:     return PR_FALSE;
14799: 
14799:   nsCaseInsensitiveStringComparator comp;
22232:   return comp(aChars1, aChars2, aNumChars1) == 0;
14799: }
    1: 
14962: /**
14962:  * nsWindow::OnKeyDown peeks into the message queue and pulls out
14962:  * WM_CHAR messages for processing. During testing we don't want to
14962:  * mess with the real message queue. Instead we pass a
14962:  * pseudo-WM_CHAR-message using this structure, and OnKeyDown will use
14962:  * that as if it was in the message queue, and refrain from actually
14962:  * looking at or touching the message queue.
14962:  */
14962: struct nsFakeCharMessage {
14962:   UINT mCharCode;
14962:   UINT mScanCode;
14962: };
14962: 
14962: //-------------------------------------------------------------------------
14962: //
14962: //
14962: //-------------------------------------------------------------------------
22788: LRESULT nsWindow::OnKeyDown(const MSG &aMsg,
22788:                             PRBool *aEventDispatched,
14962:                             nsFakeCharMessage* aFakeCharMessage)
    1: {
22788:   UINT virtualKeyCode = aMsg.wParam;
22788: 
23335: #ifndef WINCE
22788:   gKbdLayout.OnKeyDown (virtualKeyCode);
23335: #endif
    1: 
    1:   // Use only DOMKeyCode for XP processing.
    1:   // Use aVirtualKeyCode for gKbdLayout and native processing.
    1:   UINT DOMKeyCode = sIMEIsComposing ?
22788:                       virtualKeyCode : MapFromNativeToDOM(virtualKeyCode);
    1: 
    1: #ifdef DEBUG
14962:   //printf("In OnKeyDown virt: %d\n", DOMKeyCode);
    1: #endif
    1: 
22788:   PRBool noDefault =
22788:     DispatchKeyEvent(NS_KEY_DOWN, 0, nsnull, DOMKeyCode, &aMsg);
22788:   if (aEventDispatched)
22788:     *aEventDispatched = PR_TRUE;
    1: 
    1:   // If we won't be getting a WM_CHAR, WM_SYSCHAR or WM_DEADCHAR, synthesize a keypress
    1:   // for almost all keys
    1:   switch (DOMKeyCode) {
    1:     case NS_VK_SHIFT:
    1:     case NS_VK_CONTROL:
    1:     case NS_VK_ALT:
    1:     case NS_VK_CAPS_LOCK:
    1:     case NS_VK_NUM_LOCK:
    1:     case NS_VK_SCROLL_LOCK: return noDefault;
    1:   }
    1: 
    1:   PRUint32 extraFlags = (noDefault ? NS_EVENT_FLAG_NO_DEFAULT : 0);
    1:   MSG msg;
14962:   BOOL gotMsg = aFakeCharMessage ||
14962:     ::PeekMessageW(&msg, mWnd, WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE | PM_NOYIELD);
    1:   // Enter and backspace are always handled here to avoid for example the
    1:   // confusion between ctrl-enter and ctrl-J.
    1:   if (DOMKeyCode == NS_VK_RETURN || DOMKeyCode == NS_VK_BACK ||
23335:       ((mIsControlDown || mIsAltDown)
23335: #ifdef WINCE
23335:        ))
23335: #else
23335:        && !gKbdLayout.IsDeadKey() && KeyboardLayout::IsPrintableCharKey(virtualKeyCode)))
23335: #endif
    1:   {
    1:     // Remove a possible WM_CHAR or WM_SYSCHAR messages from the message queue.
    1:     // They can be more than one because of:
    1:     //  * Dead-keys not pairing with base character
    1:     //  * Some keyboard layouts may map up to 4 characters to the single key
14962:     PRBool anyCharMessagesRemoved = PR_FALSE;
14962: 
14962:     if (aFakeCharMessage) {
14962:       anyCharMessagesRemoved = PR_TRUE;
14962:     } else {
    1:       while (gotMsg && (msg.message == WM_CHAR || msg.message == WM_SYSCHAR))
    1:       {
14962:         PR_LOG(sWindowsLog, PR_LOG_ALWAYS,
14962:                ("%s charCode=%d scanCode=%d\n", msg.message == WM_SYSCHAR ? "WM_SYSCHAR" : "WM_CHAR",
14962:                 msg.wParam, HIWORD(msg.lParam) & 0xFF));
22788:         RemoveMessageAndDispatchPluginEvent(WM_KEYFIRST, WM_KEYLAST);
    1:         anyCharMessagesRemoved = PR_TRUE;
    1: 
    1:         gotMsg = ::PeekMessageW (&msg, mWnd, WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE | PM_NOYIELD);
    1:       }
14962:     }
    1: 
    1:     if (!anyCharMessagesRemoved && DOMKeyCode == NS_VK_BACK) {
    1:       MSG imeStartCompositionMsg, imeCompositionMsg;
    1:       if (::PeekMessageW(&imeStartCompositionMsg, mWnd, WM_IME_STARTCOMPOSITION, WM_IME_STARTCOMPOSITION, PM_NOREMOVE | PM_NOYIELD)
    1:        && ::PeekMessageW(&imeCompositionMsg, mWnd, WM_IME_COMPOSITION, WM_IME_COMPOSITION, PM_NOREMOVE | PM_NOYIELD)
    1:        && ::PeekMessageW(&msg, mWnd, WM_CHAR, WM_CHAR, PM_NOREMOVE | PM_NOYIELD)
    1:        && imeStartCompositionMsg.wParam == 0x0 && imeStartCompositionMsg.lParam == 0x0
    1:        && imeCompositionMsg.wParam == 0x0 && imeCompositionMsg.lParam == 0x1BF
    1:        && msg.wParam == NS_VK_BACK && msg.lParam == 0x1
    1:        && imeStartCompositionMsg.time <= imeCompositionMsg.time
    1:        && imeCompositionMsg.time <= msg.time) {
    1:         // This message pattern is "Kakutei-Undo" on ATOK and WXG.
    1:         // (ATOK and WXG are popular IMEs in Japan)
    1:         // In this case, the message queue has following messages:
    1:         // ------------------------------------------------------------------------------------------
    1:         // WM_KEYDOWN              * n (wParam = VK_BACK, lParam = 0x1)
    1:         // WM_KEYUP                * 1 (wParam = VK_BACK, lParam = 0xC0000001) #this is ATOK only
    1:         // WM_IME_STARTCOMPOSITION * 1 (wParam = 0x0, lParam = 0x0)
    1:         // WM_IME_COMPOSITION      * 1 (wParam = 0x0, lParam = 0x1BF)
    1:         // WM_CHAR                 * n (wParam = VK_BACK, lParam = 0x1)
    1:         // WM_KEYUP                * 1 (wParam = VK_BACK, lParam = 0xC00E0001)
    1:         // ------------------------------------------------------------------------------------------
    1:         // This message pattern does not match to the above case;
    1:         // i.e.,WM_KEYDOWN -> WM_CHAR -> WM_KEYDOWN -> WM_CHAR.
    1:         // For more information of this problem:
    1:         // http://bugzilla.mozilla.gr.jp/show_bug.cgi?id=2885 (written in Japanese)
    1:         // http://bugzilla.mozilla.org/show_bug.cgi?id=194559 (written in English)
    1: 
14962:         NS_ASSERTION(!aFakeCharMessage, "We shouldn't be touching the real msg queue");
22788:         RemoveMessageAndDispatchPluginEvent(WM_CHAR, WM_CHAR);
    1:       }
    1:     }
    1:   }
    1:   else if (gotMsg &&
14962:            (aFakeCharMessage ||
14962:             msg.message == WM_CHAR || msg.message == WM_SYSCHAR || msg.message == WM_DEADCHAR)) {
14962:     if (aFakeCharMessage)
22788:       return OnCharRaw(aFakeCharMessage->mCharCode,
22788:                        aFakeCharMessage->mScanCode, extraFlags);
14962: 
    1:     // If prevent default set for keydown, do same for keypress
    1:     ::GetMessageW(&msg, mWnd, msg.message, msg.message);
    1: 
22788:     if (msg.message == WM_DEADCHAR) {
22788:       if (!PluginHasFocus())
    1:         return PR_FALSE;
    1: 
22788:       // We need to send the removed message to focused plug-in.
22788:       DispatchPluginEvent(msg);
22788:       return noDefault;
22788:     }
22788: 
14962:     PR_LOG(sWindowsLog, PR_LOG_ALWAYS,
14962:            ("%s charCode=%d scanCode=%d\n",
14962:             msg.message == WM_SYSCHAR ? "WM_SYSCHAR" : "WM_CHAR",
14962:             msg.wParam, HIWORD(msg.lParam) & 0xFF));
14962: 
22788:     BOOL result = OnChar(msg, nsnull, extraFlags);
 7027:     // If a syschar keypress wasn't processed, Windows may want to 
 7027:     // handle it to activate a native menu.
 7027:     if (!result && msg.message == WM_SYSCHAR)
 7027:       ::DefWindowProcW(mWnd, msg.message, msg.wParam, msg.lParam);
 7027:     return result;
23335:   }
23335: #ifndef WINCE
23335:   else if (!mIsControlDown && !mIsAltDown &&
22788:              (KeyboardLayout::IsPrintableCharKey(virtualKeyCode) ||
22788:               KeyboardLayout::IsNumpadKey(virtualKeyCode)))
    1:   {
    1:     // If this is simple KeyDown event but next message is not WM_CHAR,
    1:     // this event may not input text, so we should ignore this event.
    1:     // See bug 314130.
22788:     return PluginHasFocus() && noDefault;
    1:   }
    1: 
    1:   if (gKbdLayout.IsDeadKey ())
22788:     return PluginHasFocus() && noDefault;
    1: 
    1:   PRUint8 shiftStates[5];
22232:   PRUnichar uniChars[5];
22232:   PRUnichar shiftedChars[5] = {0, 0, 0, 0, 0};
22232:   PRUnichar unshiftedChars[5] = {0, 0, 0, 0, 0};
22232:   PRUnichar shiftedLatinChar = 0;
22232:   PRUnichar unshiftedLatinChar = 0;
    1:   PRUint32 numOfUniChars = 0;
14328:   PRUint32 numOfShiftedChars = 0;
14328:   PRUint32 numOfUnshiftedChars = 0;
    1:   PRUint32 numOfShiftStates = 0;
    1: 
22788:   switch (virtualKeyCode) {
    1:     // keys to be sent as characters
    1:     case VK_ADD:       uniChars [0] = '+';  numOfUniChars = 1;  break;
    1:     case VK_SUBTRACT:  uniChars [0] = '-';  numOfUniChars = 1;  break;
    1:     case VK_DIVIDE:    uniChars [0] = '/';  numOfUniChars = 1;  break;
    1:     case VK_MULTIPLY:  uniChars [0] = '*';  numOfUniChars = 1;  break;
    1:     case VK_NUMPAD0:
    1:     case VK_NUMPAD1:
    1:     case VK_NUMPAD2:
    1:     case VK_NUMPAD3:
    1:     case VK_NUMPAD4:
    1:     case VK_NUMPAD5:
    1:     case VK_NUMPAD6:
    1:     case VK_NUMPAD7:
    1:     case VK_NUMPAD8:
    1:     case VK_NUMPAD9:
22788:       uniChars [0] = virtualKeyCode - VK_NUMPAD0 + '0';
    1:       numOfUniChars = 1;
    1:       break;
    1:     default:
22788:       if (KeyboardLayout::IsPrintableCharKey(virtualKeyCode)) {
14328:         numOfUniChars = numOfShiftStates =
14328:           gKbdLayout.GetUniChars(uniChars, shiftStates,
14328:                                  NS_ARRAY_LENGTH(uniChars));
14328:       }
14328: 
14328:       if (mIsControlDown ^ mIsAltDown) {
14799:         PRUint8 capsLockState = (::GetKeyState(VK_CAPITAL) & 1) ? eCapsLock : 0;
14328:         numOfUnshiftedChars =
22788:           gKbdLayout.GetUniCharsWithShiftState(virtualKeyCode, capsLockState,
14328:                        unshiftedChars, NS_ARRAY_LENGTH(unshiftedChars));
14328:         numOfShiftedChars =
22788:           gKbdLayout.GetUniCharsWithShiftState(virtualKeyCode,
14799:                        capsLockState | eShift,
14328:                        shiftedChars, NS_ARRAY_LENGTH(shiftedChars));
14799: 
14476:         // The current keyboard cannot input alphabets or numerics,
14476:         // we should append them for Shortcut/Access keys.
14476:         // E.g., for Cyrillic keyboard layout.
14799:         if (NS_VK_A <= DOMKeyCode && DOMKeyCode <= NS_VK_Z) {
14476:           shiftedLatinChar = unshiftedLatinChar = DOMKeyCode;
14799:           if (capsLockState)
14799:             shiftedLatinChar += 0x20;
14799:           else
14476:             unshiftedLatinChar += 0x20;
14799:           if (unshiftedLatinChar == unshiftedChars[0] &&
14799:               shiftedLatinChar == shiftedChars[0]) {
14799:               shiftedLatinChar = unshiftedLatinChar = 0;
14799:           }
14799:         } else {
14799:           PRUint16 ch = 0;
14799:           if (NS_VK_0 <= DOMKeyCode && DOMKeyCode <= NS_VK_9) {
14799:             ch = DOMKeyCode;
14799:           } else {
22788:             switch (virtualKeyCode) {
14799:               case VK_OEM_PLUS:   ch = '+'; break;
14799:               case VK_OEM_MINUS:  ch = '-'; break;
14799:             }
14799:           }
14799:           if (ch && unshiftedChars[0] != ch && shiftedChars[0] != ch) {
14799:             // Windows has assigned a virtual key code to the key even though
14799:             // the character can't be produced with this key.  That probably
14799:             // means the character can't be produced with any key in the
14799:             // current layout and so the assignment is based on a QWERTY
14799:             // layout.  Append this code so that users can access the shortcut.
14799:             unshiftedLatinChar = ch;
14799:           }
14799:         }
14799: 
14799:         // If the charCode is not ASCII character, we should replace the
14799:         // charCode with ASCII character only when Ctrl is pressed.
14799:         // But don't replace the charCode when the charCode is not same as
14799:         // unmodified characters. In such case, Ctrl is sometimes used for a
14799:         // part of character inputting key combination like Shift.
14799:         if (mIsControlDown) {
14799:           PRUint8 currentState = eCtrl;
14799:           if (mIsShiftDown)
14799:             currentState |= eShift;
14799: 
14799:           PRUint32 ch = mIsShiftDown ? shiftedLatinChar : unshiftedLatinChar;
14799:           if (ch &&
14799:               (numOfUniChars == 0 ||
14799:                StringCaseInsensitiveEquals(uniChars, numOfUniChars,
14799:                  mIsShiftDown ? shiftedChars : unshiftedChars,
14799:                  mIsShiftDown ? numOfShiftedChars : numOfUnshiftedChars))) {
14799:             numOfUniChars = numOfShiftStates = 1;
14799:             uniChars[0] = ch;
14799:             shiftStates[0] = currentState;
14799:           }
14476:         }
14328:       }
14328:   }
14328: 
14328:   if (numOfUniChars > 0 || numOfShiftedChars > 0 || numOfUnshiftedChars > 0) {
14328:     PRUint32 num = PR_MAX(numOfUniChars,
14328:                           PR_MAX(numOfShiftedChars, numOfUnshiftedChars));
14328:     PRUint32 skipUniChars = num - numOfUniChars;
14328:     PRUint32 skipShiftedChars = num - numOfShiftedChars;
14328:     PRUint32 skipUnshiftedChars = num - numOfUnshiftedChars;
14328:     UINT keyCode = numOfUniChars == 0 ? DOMKeyCode : 0;
14328:     for (PRUint32 cnt = 0; cnt < num; cnt++) {
14328:       PRUint16 uniChar, shiftedChar, unshiftedChar;
14328:       uniChar = shiftedChar = unshiftedChar = 0;
14328:       if (skipUniChars <= cnt) {
14328:         if (cnt - skipUniChars  < numOfShiftStates) {
14328:           // If key in combination with Alt and/or Ctrl produces a different
14328:           // character than without them then do not report these flags
14328:           // because it is separate keyboard layout shift state. If dead-key
14328:           // and base character does not produce a valid composite character
14328:           // then both produced dead-key character and following base
14328:           // character may have different modifier flags, too.
14328:           mIsShiftDown   = (shiftStates[cnt - skipUniChars] & eShift) != 0;
14328:           mIsControlDown = (shiftStates[cnt - skipUniChars] & eCtrl) != 0;
14328:           mIsAltDown     = (shiftStates[cnt - skipUniChars] & eAlt) != 0;
14328:         }
14328:         uniChar = uniChars[cnt - skipUniChars];
14328:       }
14328:       if (skipShiftedChars <= cnt)
14328:         shiftedChar = shiftedChars[cnt - skipShiftedChars];
14328:       if (skipUnshiftedChars <= cnt)
14328:         unshiftedChar = unshiftedChars[cnt - skipUnshiftedChars];
14476:       nsAutoTArray<nsAlternativeCharCode, 5> altArray;
14476: 
14476:       if (shiftedChar || unshiftedChar) {
14476:         nsAlternativeCharCode chars(unshiftedChar, shiftedChar);
14476:         altArray.AppendElement(chars);
14476:       }
14476:       if (cnt == num - 1 && (unshiftedLatinChar || shiftedLatinChar)) {
14476:         nsAlternativeCharCode chars(unshiftedLatinChar, shiftedLatinChar);
14476:         altArray.AppendElement(chars);
14476:       }
14476: 
14476:       DispatchKeyEvent(NS_KEY_PRESS, uniChar, &altArray,
22788:                        keyCode, nsnull, extraFlags);
    1:     }
    1:   } else
23335: #endif
22788:     DispatchKeyEvent(NS_KEY_PRESS, 0, nsnull, DOMKeyCode, nsnull, extraFlags);
    1: 
    1:   return noDefault;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: //
    1: //-------------------------------------------------------------------------
22788: LRESULT nsWindow::OnKeyUp(const MSG &aMsg, PRBool *aEventDispatched)
22788: {
22788:   UINT virtualKeyCode = aMsg.wParam;
22788: 
22788:   PR_LOG(sWindowsLog, PR_LOG_ALWAYS,
22788:          ("nsWindow::OnKeyUp VK=%d\n", virtualKeyCode));
14962: 
22788:   virtualKeyCode =
22788:     sIMEIsComposing ? virtualKeyCode : MapFromNativeToDOM(virtualKeyCode);
22788:   if (aEventDispatched)
22788:     *aEventDispatched = PR_TRUE;
22788:   return DispatchKeyEvent(NS_KEY_UP, 0, nsnull, virtualKeyCode, &aMsg);
22788: }
22788: 
22788: //-------------------------------------------------------------------------
22788: //
22788: //
22788: //-------------------------------------------------------------------------
22788: LRESULT nsWindow::OnChar(const MSG &aMsg, PRBool *aEventDispatched,
22788:                          PRUint32 aFlags)
22788: {
22788:   return OnCharRaw(aMsg.wParam, HIWORD(aMsg.lParam) & 0xFF,
22788:                    aFlags, &aMsg, aEventDispatched);
22788: }
22788: 
22788: //-------------------------------------------------------------------------
22788: //
22788: //
22788: //-------------------------------------------------------------------------
22788: LRESULT nsWindow::OnCharRaw(UINT charCode, UINT aScanCode, PRUint32 aFlags,
22788:                             const MSG *aMsg, PRBool *aEventDispatched)
14962: {
    1:   // ignore [shift+]alt+space so the OS can handle it
    1:   if (mIsAltDown && !mIsControlDown && IS_VK_DOWN(NS_VK_SPACE)) {
    1:     return FALSE;
    1:   }
    1:   
16335:   // Ignore Ctrl+Enter (bug 318235)
16335:   if (mIsControlDown && charCode == 0xA) {
16335:     return FALSE;
16335:   }
16335: 
    1:   // WM_CHAR with Control and Alt (== AltGr) down really means a normal character
    1:   PRBool saveIsAltDown = mIsAltDown;
    1:   PRBool saveIsControlDown = mIsControlDown;
    1:   if (mIsAltDown && mIsControlDown)
    1:     mIsAltDown = mIsControlDown = PR_FALSE;
    1: 
    1:   wchar_t uniChar;
    1: 
    1:   if (sIMEIsComposing) {
    1:     HandleEndComposition();
    1:   }
    1: 
    1:   if (mIsControlDown && charCode <= 0x1A) { // Ctrl+A Ctrl+Z, see Programming Windows 3.1 page 110 for details
    1:     // need to account for shift here.  bug 16486
    1:     if (mIsShiftDown)
    1:       uniChar = charCode - 1 + 'A';
    1:     else
    1:       uniChar = charCode - 1 + 'a';
    1:     charCode = 0;
    1:   }
    1:   else if (mIsControlDown && charCode <= 0x1F) {
    1:     // Fix for 50255 - <ctrl><[> and <ctrl><]> are not being processed.
    1:     // also fixes ctrl+\ (x1c), ctrl+^ (x1e) and ctrl+_ (x1f)
    1:     // for some reason the keypress handler need to have the uniChar code set
    1:     // with the addition of a upper case A not the lower case.
    1:     uniChar = charCode - 1 + 'A';
    1:     charCode = 0;
    1:   } else { // 0x20 - SPACE, 0x3D - EQUALS
    1:     if (charCode < 0x20 || (charCode == 0x3D && mIsControlDown)) {
    1:       uniChar = 0;
    1:     } else {
    1:       uniChar = charCode;
    1:       charCode = 0;
    1:     }
    1:   }
    1: 
    1:   // Keep the characters unshifted for shortcuts and accesskeys and make sure
    1:   // that numbers are always passed as such (among others: bugs 50255 and 351310)
    1:   if (uniChar && (mIsControlDown || mIsAltDown)) {
22411:     UINT virtualKeyCode = ::MapVirtualKeyEx(aScanCode, MAPVK_VSC_TO_VK,
22411:                                             gKbdLayout.GetLayout());
    1:     UINT unshiftedCharCode =
    1:       virtualKeyCode >= '0' && virtualKeyCode <= '9' ? virtualKeyCode :
22411:       mIsShiftDown ? ::MapVirtualKeyEx(virtualKeyCode, MAPVK_VK_TO_CHAR,
22411:                                        gKbdLayout.GetLayout()) : 0;
    1:     // ignore diacritics (top bit set) and key mapping errors (char code 0)
    1:     if ((INT)unshiftedCharCode > 0)
    1:       uniChar = unshiftedCharCode;
    1:   }
    1: 
    1:   // Fix for bug 285161 (and 295095) which was caused by the initial fix for bug 178110.
    1:   // When pressing (alt|ctrl)+char, the char must be lowercase unless shift is 
    1:   // pressed too.
    1:   if (!mIsShiftDown && (saveIsAltDown || saveIsControlDown)) {
    1:     uniChar = towlower(uniChar);
    1:   }
    1: 
14476:   PRBool result = DispatchKeyEvent(NS_KEY_PRESS, uniChar, nsnull,
22788:                                    charCode, aMsg, aFlags);
22788:   if (aEventDispatched)
22788:     *aEventDispatched = PR_TRUE;
    1:   mIsAltDown = saveIsAltDown;
    1:   mIsControlDown = saveIsControlDown;
    1:   return result;
    1: }
    1: 
14962: static const PRUint32 sModifierKeyMap[][3] = {
14962:   { nsIWidget::CAPS_LOCK, VK_CAPITAL, 0 },
14962:   { nsIWidget::NUM_LOCK, VK_NUMLOCK, 0 },
14962:   { nsIWidget::SHIFT_L, VK_SHIFT, VK_LSHIFT },
14962:   { nsIWidget::SHIFT_R, VK_SHIFT, VK_RSHIFT },
14962:   { nsIWidget::CTRL_L, VK_CONTROL, VK_LCONTROL },
14962:   { nsIWidget::CTRL_R, VK_CONTROL, VK_RCONTROL },
14962:   { nsIWidget::ALT_L, VK_MENU, VK_LMENU },
14962:   { nsIWidget::ALT_R, VK_MENU, VK_RMENU }
14962: };
14962: 
14962: struct KeyPair {
14962:   PRUint8 mGeneral;
14962:   PRUint8 mSpecific;
14962:   KeyPair(PRUint32 aGeneral, PRUint32 aSpecific)
14962:     : mGeneral(PRUint8(aGeneral)), mSpecific(PRUint8(aSpecific)) {}
14962: };
14962: 
14962: static void
14962: SetupKeyModifiersSequence(nsTArray<KeyPair>* aArray, PRUint32 aModifiers)
14962: {
14962:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(sModifierKeyMap); ++i) {
14962:     const PRUint32* map = sModifierKeyMap[i];
14962:     if (aModifiers & map[0]) {
14962:       aArray->AppendElement(KeyPair(map[1], map[2]));
14962:     }
14962:   }
14962: }
14962: 
14998: nsresult
14962: nsWindow::SynthesizeNativeKeyEvent(PRInt32 aNativeKeyboardLayout,
14962:                                    PRInt32 aNativeKeyCode,
14962:                                    PRUint32 aModifierFlags,
14962:                                    const nsAString& aCharacters,
14962:                                    const nsAString& aUnmodifiedCharacters)
14962: {
19625: #ifndef WINCE  //Win CE doesn't support many of the calls used in this method, perhaps theres another way
14998:   nsPrintfCString layoutName("%08x", aNativeKeyboardLayout);
14998:   HKL loadedLayout = LoadKeyboardLayoutA(layoutName.get(), KLF_NOTELLSHELL);
14998:   if (loadedLayout == NULL)
14998:     return NS_ERROR_NOT_AVAILABLE;
14998: 
14962:   // Setup clean key state and load desired layout
14962:   BYTE originalKbdState[256];
14962:   ::GetKeyboardState(originalKbdState);
14962:   BYTE kbdState[256];
14962:   memset(kbdState, 0, sizeof(kbdState));
14962:   // This changes the state of the keyboard for the current thread only,
14962:   // and we'll restore it soon, so this should be OK.
14962:   ::SetKeyboardState(kbdState);
22411:   HKL oldLayout = gKbdLayout.GetLayout();
22411:   gKbdLayout.LoadLayout(loadedLayout);
14962: 
14962:   nsAutoTArray<KeyPair,10> keySequence;
14962:   SetupKeyModifiersSequence(&keySequence, aModifierFlags);
14962:   NS_ASSERTION(aNativeKeyCode >= 0 && aNativeKeyCode < 256,
14962:                "Native VK key code out of range");
14962:   keySequence.AppendElement(KeyPair(aNativeKeyCode, 0));
14962: 
14962:   // Simulate the pressing of each modifier key and then the real key
14962:   for (PRUint32 i = 0; i < keySequence.Length(); ++i) {
14962:     PRUint8 key = keySequence[i].mGeneral;
14962:     PRUint8 keySpecific = keySequence[i].mSpecific;
14962:     kbdState[key] = 0x81; // key is down and toggled on if appropriate
14962:     if (keySpecific) {
14962:       kbdState[keySpecific] = 0x81;
14962:     }
14962:     ::SetKeyboardState(kbdState);
14962:     SetupModKeyState();
22788:     MSG msg = InitMSG(WM_KEYDOWN, key, 0);
14962:     if (i == keySequence.Length() - 1 && aCharacters.Length() > 0) {
22411:       UINT scanCode = ::MapVirtualKeyEx(aNativeKeyCode, MAPVK_VK_TO_VSC,
22411:                                         gKbdLayout.GetLayout());
22788:       nsFakeCharMessage fakeMsg = { aCharacters.CharAt(0), scanCode };
22788:       OnKeyDown(msg, nsnull, &fakeMsg);
14962:     } else {
22788:       OnKeyDown(msg, nsnull, nsnull);
14962:     }
14962:   }
14962:   for (PRUint32 i = keySequence.Length(); i > 0; --i) {
14962:     PRUint8 key = keySequence[i - 1].mGeneral;
14962:     PRUint8 keySpecific = keySequence[i - 1].mSpecific;
14962:     kbdState[key] = 0; // key is up and toggled off if appropriate
14962:     if (keySpecific) {
14962:       kbdState[keySpecific] = 0;
14962:     }
14962:     ::SetKeyboardState(kbdState);
14962:     SetupModKeyState();
22788:     MSG msg = InitMSG(WM_KEYUP, key, 0);
22788:     OnKeyUp(msg, nsnull);
14962:   }  
14962: 
14962:   // Restore old key state and layout
14962:   ::SetKeyboardState(originalKbdState);
22411:   gKbdLayout.LoadLayout(oldLayout);
14962:   SetupModKeyState();
14998:   
14998:   UnloadKeyboardLayout(loadedLayout);
14998:   return NS_OK;
19625: #else  //XXX: is there another way to do this?
19625:   return NS_ERROR_NOT_IMPLEMENTED;
19625: #endif  
14962: }
    1: 
    1: void nsWindow::ConstrainZLevel(HWND *aAfter)
    1: {
    1:   nsZLevelEvent  event(PR_TRUE, NS_SETZLEVEL, this);
    1:   nsWindow      *aboveWindow = 0;
    1: 
    1:   InitEvent(event);
    1: 
    1:   if (*aAfter == HWND_BOTTOM)
    1:     event.mPlacement = nsWindowZBottom;
    1:   else if (*aAfter == HWND_TOP || *aAfter == HWND_TOPMOST || *aAfter == HWND_NOTOPMOST)
    1:     event.mPlacement = nsWindowZTop;
    1:   else {
    1:     event.mPlacement = nsWindowZRelative;
    1:     aboveWindow = GetNSWindowPtr(*aAfter);
    1:   }
    1:   event.mReqBelow = aboveWindow;
    1:   event.mActualBelow = nsnull;
    1: 
    1:   event.mImmediate = PR_FALSE;
    1:   event.mAdjusted = PR_FALSE;
    1:   DispatchWindowEvent(&event);
    1: 
    1:   if (event.mAdjusted) {
    1:     if (event.mPlacement == nsWindowZBottom)
    1:       *aAfter = HWND_BOTTOM;
    1:     else if (event.mPlacement == nsWindowZTop)
    1:       *aAfter = HWND_TOP;
    1:     else {
    1:       *aAfter = (HWND)event.mActualBelow->GetNativeData(NS_NATIVE_WINDOW);
    1:     }
    1:   }
    1:   NS_IF_RELEASE(event.mActualBelow);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Process all nsWindows messages
    1: //
    1: //-------------------------------------------------------------------------
 2492: static PRBool gJustGotDeactivate = PR_FALSE;
 2492: static PRBool gJustGotActivate = PR_FALSE;
    1: 
    1: #ifdef NS_DEBUG
    1: 
    1: typedef struct {
    1:   char * mStr;
    1:   long   mId;
    1: } EventMsgInfo;
    1: 
    1: EventMsgInfo gAllEvents[] = {
    1:   {"WM_NULL",                             0x0000},
    1:   {"WM_CREATE",                           0x0001},
    1:   {"WM_DESTROY",                          0x0002},
    1:   {"WM_MOVE",                             0x0003},
    1:   {"WM_SIZE",                             0x0005},
    1:   {"WM_ACTIVATE",                         0x0006},
    1:   {"WM_SETFOCUS",                         0x0007},
    1:   {"WM_KILLFOCUS",                        0x0008},
    1:   {"WM_ENABLE",                           0x000A},
    1:   {"WM_SETREDRAW",                        0x000B},
    1:   {"WM_SETTEXT",                          0x000C},
    1:   {"WM_GETTEXT",                          0x000D},
    1:   {"WM_GETTEXTLENGTH",                    0x000E},
    1:   {"WM_PAINT",                            0x000F},
    1:   {"WM_CLOSE",                            0x0010},
    1:   {"WM_QUERYENDSESSION",                  0x0011},
    1:   {"WM_QUIT",                             0x0012},
    1:   {"WM_QUERYOPEN",                        0x0013},
    1:   {"WM_ERASEBKGND",                       0x0014},
    1:   {"WM_SYSCOLORCHANGE",                   0x0015},
    1:   {"WM_ENDSESSION",                       0x0016},
    1:   {"WM_SHOWWINDOW",                       0x0018},
    1:   {"WM_SETTINGCHANGE",                    0x001A},
    1:   {"WM_DEVMODECHANGE",                    0x001B},
    1:   {"WM_ACTIVATEAPP",                      0x001C},
    1:   {"WM_FONTCHANGE",                       0x001D},
    1:   {"WM_TIMECHANGE",                       0x001E},
    1:   {"WM_CANCELMODE",                       0x001F},
    1:   {"WM_SETCURSOR",                        0x0020},
    1:   {"WM_MOUSEACTIVATE",                    0x0021},
    1:   {"WM_CHILDACTIVATE",                    0x0022},
    1:   {"WM_QUEUESYNC",                        0x0023},
    1:   {"WM_GETMINMAXINFO",                    0x0024},
    1:   {"WM_PAINTICON",                        0x0026},
    1:   {"WM_ICONERASEBKGND",                   0x0027},
    1:   {"WM_NEXTDLGCTL",                       0x0028},
    1:   {"WM_SPOOLERSTATUS",                    0x002A},
    1:   {"WM_DRAWITEM",                         0x002B},
    1:   {"WM_MEASUREITEM",                      0x002C},
    1:   {"WM_DELETEITEM",                       0x002D},
    1:   {"WM_VKEYTOITEM",                       0x002E},
    1:   {"WM_CHARTOITEM",                       0x002F},
    1:   {"WM_SETFONT",                          0x0030},
    1:   {"WM_GETFONT",                          0x0031},
    1:   {"WM_SETHOTKEY",                        0x0032},
    1:   {"WM_GETHOTKEY",                        0x0033},
    1:   {"WM_QUERYDRAGICON",                    0x0037},
    1:   {"WM_COMPAREITEM",                      0x0039},
    1:   {"WM_GETOBJECT",                        0x003D},
    1:   {"WM_COMPACTING",                       0x0041},
    1:   {"WM_COMMNOTIFY",                       0x0044},
    1:   {"WM_WINDOWPOSCHANGING",                0x0046},
    1:   {"WM_WINDOWPOSCHANGED",                 0x0047},
    1:   {"WM_POWER",                            0x0048},
    1:   {"WM_COPYDATA",                         0x004A},
    1:   {"WM_CANCELJOURNAL",                    0x004B},
    1:   {"WM_NOTIFY",                           0x004E},
    1:   {"WM_INPUTLANGCHANGEREQUEST",           0x0050},
    1:   {"WM_INPUTLANGCHANGE",                  0x0051},
    1:   {"WM_TCARD",                            0x0052},
    1:   {"WM_HELP",                             0x0053},
    1:   {"WM_USERCHANGED",                      0x0054},
    1:   {"WM_NOTIFYFORMAT",                     0x0055},
    1:   {"WM_CONTEXTMENU",                      0x007B},
    1:   {"WM_STYLECHANGING",                    0x007C},
    1:   {"WM_STYLECHANGED",                     0x007D},
    1:   {"WM_DISPLAYCHANGE",                    0x007E},
    1:   {"WM_GETICON",                          0x007F},
    1:   {"WM_SETICON",                          0x0080},
    1:   {"WM_NCCREATE",                         0x0081},
    1:   {"WM_NCDESTROY",                        0x0082},
    1:   {"WM_NCCALCSIZE",                       0x0083},
    1:   {"WM_NCHITTEST",                        0x0084},
    1:   {"WM_NCPAINT",                          0x0085},
    1:   {"WM_NCACTIVATE",                       0x0086},
    1:   {"WM_GETDLGCODE",                       0x0087},
    1:   {"WM_SYNCPAINT",                        0x0088},
    1:   {"WM_NCMOUSEMOVE",                      0x00A0},
    1:   {"WM_NCLBUTTONDOWN",                    0x00A1},
    1:   {"WM_NCLBUTTONUP",                      0x00A2},
    1:   {"WM_NCLBUTTONDBLCLK",                  0x00A3},
    1:   {"WM_NCRBUTTONDOWN",                    0x00A4},
    1:   {"WM_NCRBUTTONUP",                      0x00A5},
    1:   {"WM_NCRBUTTONDBLCLK",                  0x00A6},
    1:   {"WM_NCMBUTTONDOWN",                    0x00A7},
    1:   {"WM_NCMBUTTONUP",                      0x00A8},
    1:   {"WM_NCMBUTTONDBLCLK",                  0x00A9},
    1:   {"EM_GETSEL",                           0x00B0},
    1:   {"EM_SETSEL",                           0x00B1},
    1:   {"EM_GETRECT",                          0x00B2},
    1:   {"EM_SETRECT",                          0x00B3},
    1:   {"EM_SETRECTNP",                        0x00B4},
    1:   {"EM_SCROLL",                           0x00B5},
    1:   {"EM_LINESCROLL",                       0x00B6},
    1:   {"EM_SCROLLCARET",                      0x00B7},
    1:   {"EM_GETMODIFY",                        0x00B8},
    1:   {"EM_SETMODIFY",                        0x00B9},
    1:   {"EM_GETLINECOUNT",                     0x00BA},
    1:   {"EM_LINEINDEX",                        0x00BB},
    1:   {"EM_SETHANDLE",                        0x00BC},
    1:   {"EM_GETHANDLE",                        0x00BD},
    1:   {"EM_GETTHUMB",                         0x00BE},
    1:   {"EM_LINELENGTH",                       0x00C1},
    1:   {"EM_REPLACESEL",                       0x00C2},
    1:   {"EM_GETLINE",                          0x00C4},
    1:   {"EM_LIMITTEXT",                        0x00C5},
    1:   {"EM_CANUNDO",                          0x00C6},
    1:   {"EM_UNDO",                             0x00C7},
    1:   {"EM_FMTLINES",                         0x00C8},
    1:   {"EM_LINEFROMCHAR",                     0x00C9},
    1:   {"EM_SETTABSTOPS",                      0x00CB},
    1:   {"EM_SETPASSWORDCHAR",                  0x00CC},
    1:   {"EM_EMPTYUNDOBUFFER",                  0x00CD},
    1:   {"EM_GETFIRSTVISIBLELINE",              0x00CE},
    1:   {"EM_SETREADONLY",                      0x00CF},
    1:   {"EM_SETWORDBREAKPROC",                 0x00D0},
    1:   {"EM_GETWORDBREAKPROC",                 0x00D1},
    1:   {"EM_GETPASSWORDCHAR",                  0x00D2},
    1:   {"EM_SETMARGINS",                       0x00D3},
    1:   {"EM_GETMARGINS",                       0x00D4},
    1:   {"EM_GETLIMITTEXT",                     0x00D5},
    1:   {"EM_POSFROMCHAR",                      0x00D6},
    1:   {"EM_CHARFROMPOS",                      0x00D7},
    1:   {"EM_SETIMESTATUS",                     0x00D8},
    1:   {"EM_GETIMESTATUS",                     0x00D9},
    1:   {"SBM_SETPOS",                          0x00E0},
    1:   {"SBM_GETPOS",                          0x00E1},
    1:   {"SBM_SETRANGE",                        0x00E2},
    1:   {"SBM_SETRANGEREDRAW",                  0x00E6},
    1:   {"SBM_GETRANGE",                        0x00E3},
    1:   {"SBM_ENABLE_ARROWS",                   0x00E4},
    1:   {"SBM_SETSCROLLINFO",                   0x00E9},
    1:   {"SBM_GETSCROLLINFO",                   0x00EA},
    1:   {"WM_KEYDOWN",                          0x0100},
    1:   {"WM_KEYUP",                            0x0101},
    1:   {"WM_CHAR",                             0x0102},
    1:   {"WM_DEADCHAR",                         0x0103},
    1:   {"WM_SYSKEYDOWN",                       0x0104},
    1:   {"WM_SYSKEYUP",                         0x0105},
    1:   {"WM_SYSCHAR",                          0x0106},
    1:   {"WM_SYSDEADCHAR",                      0x0107},
    1:   {"WM_KEYLAST",                          0x0108},
    1:   {"WM_IME_STARTCOMPOSITION",             0x010D},
    1:   {"WM_IME_ENDCOMPOSITION",               0x010E},
    1:   {"WM_IME_COMPOSITION",                  0x010F},
    1:   {"WM_INITDIALOG",                       0x0110},
    1:   {"WM_COMMAND",                          0x0111},
    1:   {"WM_SYSCOMMAND",                       0x0112},
    1:   {"WM_TIMER",                            0x0113},
    1:   {"WM_HSCROLL",                          0x0114},
    1:   {"WM_VSCROLL",                          0x0115},
    1:   {"WM_INITMENU",                         0x0116},
    1:   {"WM_INITMENUPOPUP",                    0x0117},
    1:   {"WM_MENUSELECT",                       0x011F},
    1:   {"WM_MENUCHAR",                         0x0120},
    1:   {"WM_ENTERIDLE",                        0x0121},
    1:   {"WM_MENURBUTTONUP",                    0x0122},
    1:   {"WM_MENUDRAG",                         0x0123},
    1:   {"WM_MENUGETOBJECT",                    0x0124},
    1:   {"WM_UNINITMENUPOPUP",                  0x0125},
    1:   {"WM_MENUCOMMAND",                      0x0126},
    1:   {"WM_CTLCOLORMSGBOX",                   0x0132},
    1:   {"WM_CTLCOLOREDIT",                     0x0133},
    1:   {"WM_CTLCOLORLISTBOX",                  0x0134},
    1:   {"WM_CTLCOLORBTN",                      0x0135},
    1:   {"WM_CTLCOLORDLG",                      0x0136},
    1:   {"WM_CTLCOLORSCROLLBAR",                0x0137},
    1:   {"WM_CTLCOLORSTATIC",                   0x0138},
    1:   {"CB_GETEDITSEL",                       0x0140},
    1:   {"CB_LIMITTEXT",                        0x0141},
    1:   {"CB_SETEDITSEL",                       0x0142},
    1:   {"CB_ADDSTRING",                        0x0143},
    1:   {"CB_DELETESTRING",                     0x0144},
    1:   {"CB_DIR",                              0x0145},
    1:   {"CB_GETCOUNT",                         0x0146},
    1:   {"CB_GETCURSEL",                        0x0147},
    1:   {"CB_GETLBTEXT",                        0x0148},
    1:   {"CB_GETLBTEXTLEN",                     0x0149},
    1:   {"CB_INSERTSTRING",                     0x014A},
    1:   {"CB_RESETCONTENT",                     0x014B},
    1:   {"CB_FINDSTRING",                       0x014C},
    1:   {"CB_SELECTSTRING",                     0x014D},
    1:   {"CB_SETCURSEL",                        0x014E},
    1:   {"CB_SHOWDROPDOWN",                     0x014F},
    1:   {"CB_GETITEMDATA",                      0x0150},
    1:   {"CB_SETITEMDATA",                      0x0151},
    1:   {"CB_GETDROPPEDCONTROLRECT",            0x0152},
    1:   {"CB_SETITEMHEIGHT",                    0x0153},
    1:   {"CB_GETITEMHEIGHT",                    0x0154},
    1:   {"CB_SETEXTENDEDUI",                    0x0155},
    1:   {"CB_GETEXTENDEDUI",                    0x0156},
    1:   {"CB_GETDROPPEDSTATE",                  0x0157},
    1:   {"CB_FINDSTRINGEXACT",                  0x0158},
    1:   {"CB_SETLOCALE",                        0x0159},
    1:   {"CB_GETLOCALE",                        0x015A},
    1:   {"CB_GETTOPINDEX",                      0x015b},
    1:   {"CB_SETTOPINDEX",                      0x015c},
    1:   {"CB_GETHORIZONTALEXTENT",              0x015d},
    1:   {"CB_SETHORIZONTALEXTENT",              0x015e},
    1:   {"CB_GETDROPPEDWIDTH",                  0x015f},
    1:   {"CB_SETDROPPEDWIDTH",                  0x0160},
    1:   {"CB_INITSTORAGE",                      0x0161},
    1:   {"CB_MSGMAX",                           0x0162},
    1:   {"LB_ADDSTRING",                        0x0180},
    1:   {"LB_INSERTSTRING",                     0x0181},
    1:   {"LB_DELETESTRING",                     0x0182},
    1:   {"LB_SELITEMRANGEEX",                   0x0183},
    1:   {"LB_RESETCONTENT",                     0x0184},
    1:   {"LB_SETSEL",                           0x0185},
    1:   {"LB_SETCURSEL",                        0x0186},
    1:   {"LB_GETSEL",                           0x0187},
    1:   {"LB_GETCURSEL",                        0x0188},
    1:   {"LB_GETTEXT",                          0x0189},
    1:   {"LB_GETTEXTLEN",                       0x018A},
    1:   {"LB_GETCOUNT",                         0x018B},
    1:   {"LB_SELECTSTRING",                     0x018C},
    1:   {"LB_DIR",                              0x018D},
    1:   {"LB_GETTOPINDEX",                      0x018E},
    1:   {"LB_FINDSTRING",                       0x018F},
    1:   {"LB_GETSELCOUNT",                      0x0190},
    1:   {"LB_GETSELITEMS",                      0x0191},
    1:   {"LB_SETTABSTOPS",                      0x0192},
    1:   {"LB_GETHORIZONTALEXTENT",              0x0193},
    1:   {"LB_SETHORIZONTALEXTENT",              0x0194},
    1:   {"LB_SETCOLUMNWIDTH",                   0x0195},
    1:   {"LB_ADDFILE",                          0x0196},
    1:   {"LB_SETTOPINDEX",                      0x0197},
    1:   {"LB_GETITEMRECT",                      0x0198},
    1:   {"LB_GETITEMDATA",                      0x0199},
    1:   {"LB_SETITEMDATA",                      0x019A},
    1:   {"LB_SELITEMRANGE",                     0x019B},
    1:   {"LB_SETANCHORINDEX",                   0x019C},
    1:   {"LB_GETANCHORINDEX",                   0x019D},
    1:   {"LB_SETCARETINDEX",                    0x019E},
    1:   {"LB_GETCARETINDEX",                    0x019F},
    1:   {"LB_SETITEMHEIGHT",                    0x01A0},
    1:   {"LB_GETITEMHEIGHT",                    0x01A1},
    1:   {"LB_FINDSTRINGEXACT",                  0x01A2},
    1:   {"LB_SETLOCALE",                        0x01A5},
    1:   {"LB_GETLOCALE",                        0x01A6},
    1:   {"LB_SETCOUNT",                         0x01A7},
    1:   {"LB_INITSTORAGE",                      0x01A8},
    1:   {"LB_ITEMFROMPOINT",                    0x01A9},
    1:   {"LB_MSGMAX",                           0x01B0},
    1:   {"WM_MOUSEMOVE",                        0x0200},
    1:   {"WM_LBUTTONDOWN",                      0x0201},
    1:   {"WM_LBUTTONUP",                        0x0202},
    1:   {"WM_LBUTTONDBLCLK",                    0x0203},
    1:   {"WM_RBUTTONDOWN",                      0x0204},
    1:   {"WM_RBUTTONUP",                        0x0205},
    1:   {"WM_RBUTTONDBLCLK",                    0x0206},
    1:   {"WM_MBUTTONDOWN",                      0x0207},
    1:   {"WM_MBUTTONUP",                        0x0208},
    1:   {"WM_MBUTTONDBLCLK",                    0x0209},
    1:   {"WM_MOUSEWHEEL",                       0x020A},
    1:   {"WM_MOUSEHWHEEL",                      0x020E},
    1:   {"WM_PARENTNOTIFY",                     0x0210},
    1:   {"WM_ENTERMENULOOP",                    0x0211},
    1:   {"WM_EXITMENULOOP",                     0x0212},
    1:   {"WM_NEXTMENU",                         0x0213},
    1:   {"WM_SIZING",                           0x0214},
    1:   {"WM_CAPTURECHANGED",                   0x0215},
    1:   {"WM_MOVING",                           0x0216},
    1:   {"WM_POWERBROADCAST",                   0x0218},
    1:   {"WM_DEVICECHANGE",                     0x0219},
    1:   {"WM_MDICREATE",                        0x0220},
    1:   {"WM_MDIDESTROY",                       0x0221},
    1:   {"WM_MDIACTIVATE",                      0x0222},
    1:   {"WM_MDIRESTORE",                       0x0223},
    1:   {"WM_MDINEXT",                          0x0224},
    1:   {"WM_MDIMAXIMIZE",                      0x0225},
    1:   {"WM_MDITILE",                          0x0226},
    1:   {"WM_MDICASCADE",                       0x0227},
    1:   {"WM_MDIICONARRANGE",                   0x0228},
    1:   {"WM_MDIGETACTIVE",                     0x0229},
    1:   {"WM_MDISETMENU",                       0x0230},
    1:   {"WM_ENTERSIZEMOVE",                    0x0231},
    1:   {"WM_EXITSIZEMOVE",                     0x0232},
    1:   {"WM_DROPFILES",                        0x0233},
    1:   {"WM_MDIREFRESHMENU",                   0x0234},
    1:   {"WM_IME_SETCONTEXT",                   0x0281},
    1:   {"WM_IME_NOTIFY",                       0x0282},
    1:   {"WM_IME_CONTROL",                      0x0283},
    1:   {"WM_IME_COMPOSITIONFULL",              0x0284},
    1:   {"WM_IME_SELECT",                       0x0285},
    1:   {"WM_IME_CHAR",                         0x0286},
    1:   {"WM_IME_REQUEST",                      0x0288},
    1:   {"WM_IME_KEYDOWN",                      0x0290},
    1:   {"WM_IME_KEYUP",                        0x0291},
    1:   {"WM_NCMOUSEHOVER",                     0x02A0},
    1:   {"WM_MOUSEHOVER",                       0x02A1},
    1:   {"WM_MOUSELEAVE",                       0x02A3},
    1:   {"WM_CUT",                              0x0300},
    1:   {"WM_COPY",                             0x0301},
    1:   {"WM_PASTE",                            0x0302},
    1:   {"WM_CLEAR",                            0x0303},
    1:   {"WM_UNDO",                             0x0304},
    1:   {"WM_RENDERFORMAT",                     0x0305},
    1:   {"WM_RENDERALLFORMATS",                 0x0306},
    1:   {"WM_DESTROYCLIPBOARD",                 0x0307},
    1:   {"WM_DRAWCLIPBOARD",                    0x0308},
    1:   {"WM_PAINTCLIPBOARD",                   0x0309},
    1:   {"WM_VSCROLLCLIPBOARD",                 0x030A},
    1:   {"WM_SIZECLIPBOARD",                    0x030B},
    1:   {"WM_ASKCBFORMATNAME",                  0x030C},
    1:   {"WM_CHANGECBCHAIN",                    0x030D},
    1:   {"WM_HSCROLLCLIPBOARD",                 0x030E},
    1:   {"WM_QUERYNEWPALETTE",                  0x030F},
    1:   {"WM_PALETTEISCHANGING",                0x0310},
    1:   {"WM_PALETTECHANGED",                   0x0311},
    1:   {"WM_HOTKEY",                           0x0312},
    1:   {"WM_PRINT",                            0x0317},
    1:   {"WM_PRINTCLIENT",                      0x0318},
    1:   {"WM_THEMECHANGED",                     0x031A},
    1:   {"WM_HANDHELDFIRST",                    0x0358},
    1:   {"WM_HANDHELDLAST",                     0x035F},
    1:   {"WM_AFXFIRST",                         0x0360},
    1:   {"WM_AFXLAST",                          0x037F},
    1:   {"WM_PENWINFIRST",                      0x0380},
    1:   {"WM_PENWINLAST",                       0x038F},
    1:   {"WM_APP",                              0x8000},
25051:   {"WM_DWMCOMPOSITIONCHANGED",            0x031E},
25051:   {"WM_DWMNCRENDERINGCHANGED",            0x031F},
25051:   {"WM_DWMCOLORIZATIONCOLORCHANGED",      0x0320},
25051:   {"WM_DWMWINDOWMAXIMIZEDCHANGE",         0x0321},
26874:   {"WM_TABLET_QUERYSYSTEMGESTURESTATUS",  0x02CC},
26874:   {"WM_GESTURE",                          0x0119},
26874:   {"WM_GESTURENOTIFY",                    0x011A},
    1:   {NULL, 0x0}
    1: };
    1: 
    1: 
    1: static long gEventCounter = 0;
    1: static long gLastEventMsg = 0;
    1: 
    1: void PrintEvent(UINT msg, PRBool aShowAllEvents, PRBool aShowMouseMoves)
    1: {
    1:   int inx = 0;
    1:   while (gAllEvents[inx].mId != (long)msg && gAllEvents[inx].mStr != NULL) {
    1:     inx++;
    1:   }
    1:   if (aShowAllEvents || (!aShowAllEvents && gLastEventMsg != (long)msg)) {
    1:     if (aShowMouseMoves || (!aShowMouseMoves && msg != 0x0020 && msg != 0x0200 && msg != 0x0084)) {
    1:       printf("%6d - 0x%04X %s\n", gEventCounter++, msg, gAllEvents[inx].mStr ? gAllEvents[inx].mStr : "Unknown");
    1:       gLastEventMsg = msg;
    1:     }
    1:   }
    1: }
    1: 
    1: #endif
    1: 
    1: #define WM_XP_THEMECHANGED                 0x031A
    1: 
    1: // Static helper functions for heap dumping
    1: static nsresult HeapDump(const char *filename, const char *heading)
    1: {
    1: #ifdef WINCE
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: #else
    1: 
    1:   PRFileDesc *prfd = PR_Open(filename, PR_CREATE_FILE | PR_APPEND | PR_WRONLY, 0777);
    1:   if (!prfd)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   char buf[1024];
    1:   PRUint32 n;
    1:   PRUint32 written = 0;
    1:   HANDLE heapHandle[64];
    1:   DWORD nheap = GetProcessHeaps(64, heapHandle);
    1:   if (nheap == 0 || nheap > 64) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   n = PR_snprintf(buf, sizeof buf, "BEGIN HEAPDUMP : %s\n", heading);
    1:   PR_Write(prfd, buf, n);
    1:   for (DWORD i = 0; i < nheap; i++) {
    1:     // Dump each heap
    1:     PROCESS_HEAP_ENTRY ent = {0};
    1:     n = PR_snprintf(buf, sizeof buf, "BEGIN heap %d : 0x%p\n", i+1, heapHandle[i]);
    1:     PR_Write(prfd, buf, n);
    1:     ent.lpData = NULL;
    1:     while (HeapWalk(heapHandle[i], &ent)) {
    1:       if (ent.wFlags & PROCESS_HEAP_REGION)
    1:         n = PR_snprintf(buf, sizeof buf, "REGION %08p : overhead %d committed %d uncommitted %d firstblock %08p lastblock %08p\n",
    1:                         ent.lpData, ent.cbOverhead,
    1:                         ent.Region.dwCommittedSize, ent.Region.dwUnCommittedSize,
    1:                         ent.Region.lpFirstBlock, ent.Region.lpLastBlock);
    1:       else
    1:         n = PR_snprintf(buf, sizeof buf, "%s %08p : %6d overhead %2d\n",
    1:                         (ent.wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE) ? "----" : ((ent.wFlags & PROCESS_HEAP_ENTRY_BUSY) ? "USED" : "FREE"),
    1:                         ent.lpData, ent.cbData, ent.cbOverhead);
    1:       PR_Write(prfd, buf, n);
    1:     }
    1:     n = PR_snprintf(buf, sizeof buf, "END heap %d : 0x%p\n", i+1, heapHandle[i]);
    1:     PR_Write(prfd, buf, n);
    1:   }
    1:   n = PR_snprintf(buf, sizeof buf, "END HEAPDUMP : %s\n", heading);
    1:   PR_Write(prfd, buf, n);
    1: 
    1:   PR_Close(prfd);
    1:   return NS_OK;
    1: #endif // WINCE
    1: }
    1: 
    1: // Recursively dispatch synchronous paints for nsIWidget
    1: // descendants with invalidated rectangles.
    1: 
    1: BOOL CALLBACK nsWindow::DispatchStarvedPaints(HWND aWnd, LPARAM aMsg)
    1: {
25349:   LONG_PTR proc = ::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
25349:   if (proc == (LONG_PTR)&nsWindow::WindowProc) {
    1:     // its one of our windows so check to see if it has a
    1:     // invalidated rect. If it does. Dispatch a synchronous
    1:     // paint.
    1:     if (GetUpdateRect(aWnd, NULL, FALSE)) {
    1:       VERIFY(::UpdateWindow(aWnd));
    1:     }
    1:   }
    1:   return TRUE;
    1: }
    1: 
    1: // Check for pending paints and dispatch any pending paint
    1: // messages for any nsIWidget which is a descendant of the
    1: // top-level window that *this* window is embedded within.
    1: // 
    1: // Note: We do not dispatch pending paint messages for non
    1: // nsIWidget managed windows.
    1: 
    1: void nsWindow::DispatchPendingEvents()
    1: {
    1:   gLastInputEventTime = PR_IntervalToMicroseconds(PR_IntervalNow());
    1: 
    1:   // We need to ensure that reflow events do not get starved.
    1:   // At the same time, we don't want to recurse through here
    1:   // as that would prevent us from dispatching starved paints.
    1:   static int recursionBlocker = 0;
    1:   if (recursionBlocker++ == 0) {
    1:     NS_ProcessPendingEvents(nsnull, PR_MillisecondsToInterval(100));
    1:     --recursionBlocker;
    1:   }
    1: 
    1:   // Quickly check to see if there are any
    1:   // paint events pending.
    1:   if (::GetQueueStatus(QS_PAINT)) {
    1:     // Find the top level window.
    1:     HWND topWnd = GetTopLevelHWND(mWnd);
    1: 
    1:     // Dispatch pending paints for all topWnd's descendant windows.
    1:     // Note: EnumChildWindows enumerates all descendant windows not just
    1:     // it's children.
    1:     ::EnumChildWindows(topWnd, nsWindow::DispatchStarvedPaints, NULL);
    1:   }
    1: }
    1: 
    1: #ifndef WINCE
    1: void nsWindow::PostSleepWakeNotification(const char* aNotification)
    1: {
    1:   nsCOMPtr<nsIObserverService> observerService = do_GetService("@mozilla.org/observer-service;1");
    1:   if (observerService)
    1:   {
    1:     observerService->NotifyObservers(nsnull, aNotification, nsnull);
    1:   }
    1: }
    1: #endif
    1: 
14962: void nsWindow::SetupModKeyState()
14962: {
14962:   mIsShiftDown   = IS_VK_DOWN(NS_VK_SHIFT);
14962:   mIsControlDown = IS_VK_DOWN(NS_VK_CONTROL);
14962:   mIsAltDown     = IS_VK_DOWN(NS_VK_ALT);
14962: }
14962: 
    1: PRBool nsWindow::ProcessMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *aRetValue)
    1: {
22788:   if (PluginHasFocus()) {
22788:     PRBool callDefaultWndProc;
22788:     MSG nativeMsg = InitMSG(msg, wParam, lParam);
22788:     if (ProcessMessageForPlugin(nativeMsg, aRetValue, callDefaultWndProc))
22788:       return !callDefaultWndProc;
22788:   }
22788: 
    1:   static UINT vkKeyCached = 0;              // caches VK code fon WM_KEYDOWN
    1:   PRBool result = PR_FALSE;                 // call the default nsWindow proc
    1:   static PRBool getWheelInfo = PR_TRUE;
    1:   *aRetValue = 0;
 2492:   PRBool isMozWindowTakingFocus = PR_TRUE;
    1:   nsPaletteInfo palInfo;
    1: 
    1:   // Uncomment this to see all windows messages
    1:   // first param shows all events
    1:   // second param indicates whether to show mouse move events
    1:   //PrintEvent(msg, PR_FALSE, PR_FALSE);
    1: 
    1:   switch (msg) {
    1:     case WM_COMMAND:
    1:     {
    1:       WORD wNotifyCode = HIWORD(wParam); // notification code
    1:       if ((CBN_SELENDOK == wNotifyCode) || (CBN_SELENDCANCEL == wNotifyCode)) { // Combo box change
    1:         nsGUIEvent event(PR_TRUE, NS_CONTROL_CHANGE, this);
23738:         nsIntPoint point(0,0);
    1:         InitEvent(event, &point); // this add ref's event.widget
    1:         result = DispatchWindowEvent(&event);
    1:       } else if (wNotifyCode == 0) { // Menu selection
    1:         nsMenuEvent event(PR_TRUE, NS_MENU_SELECTED, this);
    1:         event.mCommand = LOWORD(wParam);
    1:         InitEvent(event);
    1:         result = DispatchWindowEvent(&event);
    1:       }
    1:     }
    1:     break;
    1: 
19625: #ifndef WINCE
18536:     // WM_QUERYENDSESSION must be handled by all windows.
18536:     // Otherwise Windows thinks the window can just be killed at will.
18536:     case WM_QUERYENDSESSION:
18536:       if (sCanQuit == TRI_UNKNOWN)
18536:       {
18536:         // Ask if it's ok to quit, and store the answer until we
18536:         // get WM_ENDSESSION signaling the round is complete.
18536:         nsCOMPtr<nsIObserverService> obsServ =
18536:           do_GetService("@mozilla.org/observer-service;1");
18536:         nsCOMPtr<nsISupportsPRBool> cancelQuit =
18536:           do_CreateInstance(NS_SUPPORTS_PRBOOL_CONTRACTID);
18536:         cancelQuit->SetData(PR_FALSE);
18536:         obsServ->NotifyObservers(cancelQuit, "quit-application-requested", nsnull);
18536: 
18536:         PRBool abortQuit;
18536:         cancelQuit->GetData(&abortQuit);
18536:         sCanQuit = abortQuit ? TRI_FALSE : TRI_TRUE;
18536:       }
18536:       *aRetValue = sCanQuit ? TRUE : FALSE;
18536:       result = PR_TRUE;
18536:       break;
18536: 
18536:     case WM_ENDSESSION:
18536:       if (wParam == TRUE && sCanQuit == TRI_TRUE)
18536:       {
18536:         // Let's fake a shutdown sequence without actually closing windows etc.
18536:         // to avoid Windows killing us in the middle. A proper shutdown would
18536:         // require having a chance to pump some messages. Unfortunately
18536:         // Windows won't let us do that. Bug 212316.
18536:         nsCOMPtr<nsIObserverService> obsServ =
18536:           do_GetService("@mozilla.org/observer-service;1");
18536:         NS_NAMED_LITERAL_STRING(context, "shutdown-persist");
18536:         obsServ->NotifyObservers(nsnull, "quit-application-granted", nsnull);
18536:         obsServ->NotifyObservers(nsnull, "quit-application-forced", nsnull);
18536:         obsServ->NotifyObservers(nsnull, "quit-application", nsnull);
18536:         obsServ->NotifyObservers(nsnull, "profile-change-net-teardown", context.get());
18536:         obsServ->NotifyObservers(nsnull, "profile-change-teardown", context.get());
18536:         obsServ->NotifyObservers(nsnull, "profile-before-change", context.get());
18536:         // Then a controlled but very quick exit.
18536:         _exit(0);
18536:       }
18536:       sCanQuit = TRI_UNKNOWN;
18536:       result = PR_TRUE;
18536:       break;
18536: 
    1:     case WM_DISPLAYCHANGE:
    1:       DispatchStandardEvent(NS_DISPLAYCHANGED);
    1:       break;
    1: #endif
    1: 
    1:     case WM_SYSCOLORCHANGE:
    1:       // Note: This is sent for child windows as well as top-level windows.
    1:       // The Win32 toolkit normally only sends these events to top-level windows.
    1:       // But we cycle through all of the childwindows and send it to them as well
    1:       // so all presentations get notified properly.
    1:       // See nsWindow::GlobalMsgWindowProc.
    1:       DispatchStandardEvent(NS_SYSCOLORCHANGED);
    1:       break;
    1: 
    1:     case WM_NOTIFY:
    1:       // TAB change
    1:     {
    1:       LPNMHDR pnmh = (LPNMHDR) lParam;
    1: 
    1:         switch (pnmh->code) {
    1:           case TCN_SELCHANGE:
    1:           {
    1:             DispatchStandardEvent(NS_TABCHANGE);
    1:             result = PR_TRUE;
    1:           }
    1:           break;
    1:         }
    1:     }
    1:     break;
    1: 
    1:     case WM_XP_THEMECHANGED:
    1:     {
    1:       DispatchStandardEvent(NS_THEMECHANGED);
    1: 
    1:       // Invalidate the window so that the repaint will
    1:       // pick up the new theme.
    1:       Invalidate(PR_FALSE);
    1:     }
    1:     break;
    1: 
    1:     case WM_FONTCHANGE:
    1:     {
    1:       nsresult rv;
    1:       PRBool didChange = PR_FALSE;
    1: 
    1:       // update the global font list
    1:       nsCOMPtr<nsIFontEnumerator> fontEnum = do_GetService("@mozilla.org/gfx/fontenumerator;1", &rv);
    1:       if (NS_SUCCEEDED(rv)) {
    1:         fontEnum->UpdateFontList(&didChange);
    1:         //didChange is TRUE only if new font langGroup is added to the list.
    1:         if (didChange)  {
    1:           // update device context font cache
    1:           // Dirty but easiest way:
    1:           // Changing nsIPrefBranch entry which triggers callbacks
    1:           // and flows into calling mDeviceContext->FlushFontCache()
    1:           // to update the font cache in all the instance of Browsers
    1:           nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:           if (prefs) {
    1:             nsCOMPtr<nsIPrefBranch> fiPrefs;
    1:             prefs->GetBranch("font.internaluseonly.", getter_AddRefs(fiPrefs));
    1:             if (fiPrefs) {
    1:               PRBool fontInternalChange = PR_FALSE;
    1:               fiPrefs->GetBoolPref("changed", &fontInternalChange);
    1:               fiPrefs->SetBoolPref("changed", !fontInternalChange);
    1:             }
    1:           }
    1:         }
    1:       } //if (NS_SUCCEEDED(rv))
    1:     }
    1:     break;
    1: 
    1: #ifndef WINCE
    1:     case WM_POWERBROADCAST:
    1:       // only hidden window handle this
    1:       // to prevent duplicate notification
    1:       if (mWindowType == eWindowType_invisible) {
    1:         switch (wParam)
    1:         {
    1:           case PBT_APMSUSPEND:
    1:             PostSleepWakeNotification("sleep_notification");
    1:             break;
    1:           case PBT_APMRESUMEAUTOMATIC:
    1:           case PBT_APMRESUMECRITICAL:
    1:           case PBT_APMRESUMESUSPEND:
    1:             PostSleepWakeNotification("wake_notification");
    1:             break;
    1:         }
    1:       }
    1:       break;
    1: #endif
    1: 
    1:     case WM_MOVE: // Window moved
    1:     {
    1:       PRInt32 x = GET_X_LPARAM(lParam); // horizontal position in screen coordinates
    1:       PRInt32 y = GET_Y_LPARAM(lParam); // vertical position in screen coordinates
    1:       result = OnMove(x, y);
    1:     }
    1:     break;
    1: 
    1:     case WM_CLOSE: // close request
    1:       DispatchStandardEvent(NS_XUL_CLOSE);
    1:       result = PR_TRUE; // abort window closure
    1:       break;
    1: 
    1:     case WM_DESTROY:
    1:       // clean up.
    1:       OnDestroy();
    1:       result = PR_TRUE;
    1:       break;
    1: 
    1:     case WM_PAINT:
    1:       *aRetValue = (int) OnPaint();
    1:       result = PR_TRUE;
    1:       break;
    1: 
    1: #ifndef WINCE
    1:     case WM_PRINTCLIENT:
    1:       result = OnPaint((HDC) wParam);
    1:       break;
    1: #endif
    1: 
    1: #ifdef WINCE
    1:       // This needs to move into nsIDOMKeyEvent.idl && nsGUIEvent.h
    1:     case WM_HOTKEY:
    1:     {
    1:       // SmartPhones has a one or two menu buttons at the
    1:       // bottom of the screen.  They are dispatched via a
    1:       // menu resource, rather then a hotkey.  To make
    1:       // this look consistent, we have mapped this menu to
    1:       // fire hotkey events.  See
    1:       // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/win_ce/html/pwc_TheBackButtonandOtherInterestingButtons.asp
    1:       
    1:       if (VK_TSOFT1 == HIWORD(lParam) && (0 != (MOD_KEYUP & LOWORD(lParam))))
    1:       {
    1:         keybd_event(VK_F19, 0, 0, 0);
    1:         keybd_event(VK_F19, 0, KEYEVENTF_KEYUP, 0);
    1:         result = 0;
    1:         break;
    1:       }
    1:       
    1:       if (VK_TSOFT2 == HIWORD(lParam) && (0 != (MOD_KEYUP & LOWORD(lParam))))
    1:       {
    1:         keybd_event(VK_F20, 0, 0, 0);
    1:         keybd_event(VK_F20, 0, KEYEVENTF_KEYUP, 0);
    1:         result = 0;
    1:         break;
    1:       }
    1:       
    1:       if (VK_TBACK == HIWORD(lParam) && (0 != (MOD_KEYUP & LOWORD(lParam))))
    1:       {
    1:         keybd_event(VK_BACK, 0, 0, 0);
    1:         keybd_event(VK_BACK, 0, KEYEVENTF_KEYUP, 0);
    1:         result = 0;
    1:         break;
    1:       }
    1: 
    1:       switch (wParam) 
    1:       {
    1:         case VK_APP1:
    1:           keybd_event(VK_F1, 0, 0, 0);
    1:           keybd_event(VK_F1, 0, KEYEVENTF_KEYUP, 0);
    1:           result = 0;
    1:           break;
    1: 
    1:         case VK_APP2:
    1:           keybd_event(VK_F2, 0, 0, 0);
    1:           keybd_event(VK_F2, 0, KEYEVENTF_KEYUP, 0);
    1:           result = 0;
    1:           break;
    1: 
    1:         case VK_APP3:
    1:           keybd_event(VK_F3, 0, 0, 0);
    1:           keybd_event(VK_F3, 0, KEYEVENTF_KEYUP, 0);
    1:           result = 0;
    1:           break;
    1: 
    1:         case VK_APP4:
    1:           keybd_event(VK_F4, 0, 0, 0);
    1:           keybd_event(VK_F4, 0, KEYEVENTF_KEYUP, 0);
    1:           result = 0;
    1:           break;
    1: 
    1:         case VK_APP5:
    1:           keybd_event(VK_F5, 0, 0, 0);
    1:           keybd_event(VK_F5, 0, KEYEVENTF_KEYUP, 0);
    1:           result = 0;
    1:           break;
    1: 
    1:         case VK_APP6:
    1:           keybd_event(VK_F6, 0, 0, 0);
    1:           keybd_event(VK_F6, 0, KEYEVENTF_KEYUP, 0);
    1:           result = 0;
    1:           break;
    1:       }
    1:     }
    1:     break;
    1: #endif
    1: 
    1:     case WM_SYSCHAR:
    1:     case WM_CHAR:
    1:     {
22788:       MSG nativeMsg = InitMSG(msg, wParam, lParam);
22788:       result = ProcessCharMessage(nativeMsg, nsnull);
22788:       DispatchPendingEvents();
    1:     }
    1:     break;
    1: 
    1:     case WM_SYSKEYUP:
    1:     case WM_KEYUP:
22788:     {
22788:       MSG nativeMsg = InitMSG(msg, wParam, lParam);
22788:       result = ProcessKeyUpMessage(nativeMsg, nsnull);
    1:       DispatchPendingEvents();
22788:     }
22788:     break;
22788: 
    1:     case WM_SYSKEYDOWN:
    1:     case WM_KEYDOWN:
22788:     {
22788:       MSG nativeMsg = InitMSG(msg, wParam, lParam);
22788:       result = ProcessKeyDownMessage(nativeMsg, nsnull);
    1:       DispatchPendingEvents();
22788:     }
    1:     break;
    1: 
    1:     // say we've dealt with erase background if widget does
    1:     // not need auto-erasing
    1:     case WM_ERASEBKGND:
    1:       if (! AutoErase()) {
    1:         *aRetValue = 1;
    1:         result = PR_TRUE;
    1:       }
    1:       break;
    1: 
    1:     case WM_GETDLGCODE:
    1:       *aRetValue = DLGC_WANTALLKEYS;
    1:       result = PR_TRUE;
    1:       break;
    1: 
    1:     case WM_MOUSEMOVE:
    1:     {
    1:       // Suppress dispatch of pending events
    1:       // when mouse moves are generated by widget
    1:       // creation instead of user input.
    1:       LPARAM lParamScreen = lParamToScreen(lParam);
    1:       POINT mp;
    1:       mp.x      = GET_X_LPARAM(lParamScreen);
    1:       mp.y      = GET_Y_LPARAM(lParamScreen);
    1:       PRBool userMovedMouse = PR_FALSE;
    1:       if ((gLastMouseMovePoint.x != mp.x) || (gLastMouseMovePoint.y != mp.y)) {
    1:         userMovedMouse = PR_TRUE;
    1:       }
    1: 
    1:       result = DispatchMouseEvent(NS_MOUSE_MOVE, wParam, lParam);
    1:       if (userMovedMouse) {
    1:         DispatchPendingEvents();
    1:       }
    1:     }
    1:     break;
    1: 
    1:     case WM_LBUTTONDOWN:
    1:       //SetFocus(); // this is bad
    1:       //RelayMouseEvent(msg,wParam, lParam);
    1:     {
    1:       // check whether IME window do mouse operation
    1:       if (IMEMouseHandling(IMEMOUSE_LDOWN, lParam))
    1:         break;
    1: 
    1:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam,
    1:                                   PR_FALSE, nsMouseEvent::eLeftButton);
    1:       DispatchPendingEvents();
    1:     }
    1:     break;
    1: 
    1:     case WM_LBUTTONUP:
    1:       //RelayMouseEvent(msg,wParam, lParam);
    1:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam,
    1:                                   PR_FALSE, nsMouseEvent::eLeftButton);
    1:       DispatchPendingEvents();
    1:       break;
    1: 
    1: #ifndef WINCE
    1:     case WM_MOUSELEAVE:
    1:     {
12976:       // We need to check mouse button states and put them in for
    1:       // wParam.
    1:       WPARAM mouseState = (GetKeyState(VK_LBUTTON) ? MK_LBUTTON : 0)
    1:         | (GetKeyState(VK_MBUTTON) ? MK_MBUTTON : 0)
    1:         | (GetKeyState(VK_RBUTTON) ? MK_RBUTTON : 0);
12976:       // Synthesize an event position because we don't get one from
12976:       // WM_MOUSELEAVE.
12976:       LPARAM pos = lParamToClient(::GetMessagePos());
12976:       DispatchMouseEvent(NS_MOUSE_EXIT, mouseState, pos);
    1:     }
    1:     break;
    1: #endif
    1: 
    1:     case WM_CONTEXTMENU:
    1:     {
    1:       // if the context menu is brought up from the keyboard, |lParam|
    1:       // will be maxlong.
    1:       LPARAM pos;
    1:       PRBool contextMenukey = PR_FALSE;
    1:       if (lParam == 0xFFFFFFFF)
    1:       {
    1:         contextMenukey = PR_TRUE;
    1:         pos = lParamToClient(GetMessagePos());
    1:       }
    1:       else
    1:       {
    1:         pos = lParamToClient(lParam);
    1:       }
    1:       result = DispatchMouseEvent(NS_CONTEXTMENU, wParam, pos, contextMenukey,
 6039:                                   contextMenukey ?
 6039:                                     nsMouseEvent::eLeftButton :
    1:                                     nsMouseEvent::eRightButton);
    1:     }
    1:     break;
    1: 
    1:     case WM_LBUTTONDBLCLK:
    1:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam, lParam, PR_FALSE,
    1:                                   nsMouseEvent::eLeftButton);
    1:       break;
    1: 
    1:     case WM_MBUTTONDOWN:
    1:     {
    1:       // check whether IME window do mouse operation
    1:       if (IMEMouseHandling(IMEMOUSE_MDOWN, lParam))
    1:         break;
    1:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam, PR_FALSE,
    1:                                   nsMouseEvent::eMiddleButton);
    1:       DispatchPendingEvents();
    1:     }
    1:     break;
    1: 
    1:     case WM_MBUTTONUP:
    1:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam, PR_FALSE,
    1:                                   nsMouseEvent::eMiddleButton);
    1:       DispatchPendingEvents();
    1:       break;
    1: 
    1:     case WM_MBUTTONDBLCLK:
    1:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam, PR_FALSE,
    1:                                   nsMouseEvent::eMiddleButton);
    1:       break;
    1: 
    1:     case WM_RBUTTONDOWN:
    1:     {
    1:       // check whether IME window do mouse operation
    1:       if (IMEMouseHandling(IMEMOUSE_RDOWN, lParam))
    1:         break;
    1:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam, PR_FALSE,
    1:                                   nsMouseEvent::eRightButton);
    1:       DispatchPendingEvents();
    1:     }
    1:     break;
    1: 
    1:     case WM_RBUTTONUP:
    1:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam, PR_FALSE,
    1:                                   nsMouseEvent::eRightButton);
    1:       DispatchPendingEvents();
    1:       break;
    1: 
    1:     case WM_RBUTTONDBLCLK:
    1:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam, lParam, PR_FALSE,
    1:                                   nsMouseEvent::eRightButton);
    1:       break;
    1: 
    1:     case WM_APPCOMMAND:
    1:     {
    1:       PRUint32 appCommand = GET_APPCOMMAND_LPARAM(lParam);
    1: 
    1:       switch (appCommand)
    1:       {
    1:         case APPCOMMAND_BROWSER_BACKWARD:
    1:         case APPCOMMAND_BROWSER_FORWARD:
    1:         case APPCOMMAND_BROWSER_REFRESH:
    1:         case APPCOMMAND_BROWSER_STOP:
    1:         case APPCOMMAND_BROWSER_SEARCH:
    1:         case APPCOMMAND_BROWSER_FAVORITES:
    1:         case APPCOMMAND_BROWSER_HOME:
    1:           DispatchCommandEvent(appCommand);
    1:           // tell the driver that we handled the event
    1:           *aRetValue = 1;
    1:           result = PR_TRUE;
    1:           break;
    1:       }
    1:       // default = PR_FALSE - tell the driver that the event was not handled
    1:     }
    1:     break;
    1: 
    1:     case WM_HSCROLL:
    1:     case WM_VSCROLL:
    1:       // check for the incoming nsWindow handle to be null in which case
    1:       // we assume the message is coming from a horizontal scrollbar inside
    1:       // a listbox and we don't bother processing it (well, we don't have to)
    1:       if (lParam) {
    1:         nsWindow* scrollbar = GetNSWindowPtr((HWND)lParam);
    1: 
    1:         if (scrollbar) {
    1:           result = scrollbar->OnScroll(LOWORD(wParam), (short)HIWORD(wParam));
    1:         }
    1:       }
    1:       break;
    1: 
    1:     case WM_CTLCOLORLISTBOX:
    1:     case WM_CTLCOLOREDIT:
    1:     case WM_CTLCOLORBTN:
    1:     //case WM_CTLCOLORSCROLLBAR: //XXX causes the scrollbar to be drawn incorrectly
    1:     case WM_CTLCOLORSTATIC:
    1:       if (lParam) {
    1:         nsWindow* control = GetNSWindowPtr((HWND)lParam);
    1:           if (control) {
    1:             control->SetUpForPaint((HDC)wParam);
    1:             *aRetValue = (LPARAM)control->OnControlColor();
    1:           }
    1:       }
    1: 
    1:       result = PR_TRUE;
    1:       break;
    1: 
    1:     case WM_ACTIVATE:
17080:       if (mEventCallback) {
    1:         PRInt32 fActive = LOWORD(wParam);
    1: 
26485: #if defined(WINCE_HAVE_SOFTKB)
26485:         if (mIsTopWidgetWindow && gSoftKeyboardState)
26485:           ToggleSoftKB(fActive);
26485: #endif
26485: 
    1:         if (WA_INACTIVE == fActive) {
 2492:           gJustGotDeactivate = PR_TRUE;
24972: #ifndef WINCE
    1:           if (mIsTopWidgetWindow)
22411:             mLastKeyboardLayout = gKbdLayout.GetLayout();
23335: #endif
26485: 
    1:         } else {
26616:           StopFlashing();
26485: 
 2492:           gJustGotActivate = PR_TRUE;
    1:           nsMouseEvent event(PR_TRUE, NS_MOUSE_ACTIVATE, this,
    1:                              nsMouseEvent::eReal);
    1:           InitEvent(event);
    1: 
    1:           event.acceptActivation = PR_TRUE;
    1:   
    1:           PRBool result = DispatchWindowEvent(&event);
23335: #ifndef WINCE
    1:           if (event.acceptActivation)
    1:             *aRetValue = MA_ACTIVATE;
    1:           else
    1:             *aRetValue = MA_NOACTIVATE;
    1: 
    1:           if (gSwitchKeyboardLayout && mLastKeyboardLayout)
    1:             ActivateKeyboardLayout(mLastKeyboardLayout, 0);
23335: #else
23335:           *aRetValue = 0;
23335: #endif
    1:         }
    1:       }
    1:       break;
    1: 
19625: #ifndef WINCE
19625: 
14101:     case WM_MOUSEACTIVATE:
14101:       if (mWindowType == eWindowType_popup) {
14101:         // a popup with a parent owner should not be activated when clicked
14101:         // but should still allow the mouse event to be fired, so the return
14101:         // value is set to MA_NOACTIVATE. But if the owner isn't the frontmost
14101:         // window, just use default processing so that the window is activated.
14101:         HWND owner = ::GetWindow(mWnd, GW_OWNER);
14101:         if (owner && owner == ::GetForegroundWindow()) {
14101:           *aRetValue = MA_NOACTIVATE;
14101:           result = PR_TRUE;
14101:         }
14101:       }
14101:       break;
14101: 
    1:     case WM_WINDOWPOSCHANGING:
    1:     {
    1:       LPWINDOWPOS info = (LPWINDOWPOS) lParam;
    1:       // enforce local z-order rules
    1:       if (!(info->flags & SWP_NOZORDER))
    1:         ConstrainZLevel(&info->hwndInsertAfter);
    1:       // prevent rude external programs from making hidden window visible
    1:       if (mWindowType == eWindowType_invisible)
    1:         info->flags &= ~SWP_SHOWWINDOW;
    1:     }
    1:     break;
    1: #endif
    1: 
    1:     case WM_SETFOCUS:
    1:       result = DispatchFocus(NS_GOTFOCUS, PR_TRUE);
 5416:       if (gJustGotActivate) {
 5416:         gJustGotActivate = PR_FALSE;
 5416:         gJustGotDeactivate = PR_FALSE;
    1:         result = DispatchFocus(NS_ACTIVATE, PR_TRUE);
    1:       }
    1: 
11267: #ifdef ACCESSIBILITY
11267:       if (nsWindow::gIsAccessibilityOn) {
11267:         // Create it for the first time so that it can start firing events
11267:         nsCOMPtr<nsIAccessible> rootAccessible = GetRootAccessible();
11267:       }
11267: #endif
11267: 
25278: #if defined(WINCE_HAVE_SOFTKB)
25278:       {
    1:       // On Windows CE, we have a window that overlaps
    1:       // the ISP button.  In this case, we should always
    1:       // try to hide it when we are activated
25278:       
    1:       // Get current input context
    1:       HIMC hC = ImmGetContext(mWnd);
    1:       // Open the IME 
    1:       ImmSetOpenStatus(hC, TRUE);
    1:       }
    1: #endif
    1:       break;
    1: 
    1:     case WM_KILLFOCUS:
25278: #if defined(WINCE_HAVE_SOFTKB)
25278:       {
    1:         HIMC hC = ImmGetContext(mWnd);
    1:         ImmSetOpenStatus(hC, FALSE);
    1:       }
    1: #endif
    1:       WCHAR className[kMaxClassNameLength];
    1:       ::GetClassNameW((HWND)wParam, className, kMaxClassNameLength);
23186:       if (wcscmp(className, kClassNameUI) &&
23186:           wcscmp(className, kClassNameContent) &&
23186:           wcscmp(className, kClassNameContentFrame) &&
23186:           wcscmp(className, kClassNameDialog) &&
23186:           wcscmp(className, kClassNameGeneral)) {
    1:         isMozWindowTakingFocus = PR_FALSE;
    1:       }
 2492:       if (gJustGotDeactivate) {
 2492:         gJustGotDeactivate = PR_FALSE;
 2492:         result = DispatchFocus(NS_DEACTIVATE, isMozWindowTakingFocus);
 2492:       }
    1:       result = DispatchFocus(NS_LOSTFOCUS, isMozWindowTakingFocus);
25278:       
    1:       break;
    1: 
    1:     case WM_WINDOWPOSCHANGED:
    1:     {
    1:       WINDOWPOS *wp = (LPWINDOWPOS)lParam;
    1: 
    1:       // We only care about a resize, so filter out things like z-order
    1:       // changes. Note: there's a WM_MOVE handler above which is why we're
    1:       // not handling them here...
    1:       if (0 == (wp->flags & SWP_NOSIZE)) {
    1:         // XXX Why are we using the client size area? If the size notification
    1:         // is for the client area then the origin should be (0,0) and not
    1:         // the window origin in screen coordinates...
    1:         RECT r;
    1:         ::GetWindowRect(mWnd, &r);
    1:         PRInt32 newWidth, newHeight;
    1:         newWidth = PRInt32(r.right - r.left);
    1:         newHeight = PRInt32(r.bottom - r.top);
23738:         nsIntRect rect(wp->x, wp->y, newWidth, newHeight);
    1: 
    1: #ifdef MOZ_XUL
16601:         if (eTransparencyTransparent == mTransparencyMode)
    1:           ResizeTranslucentWindow(newWidth, newHeight);
    1: #endif
    1: 
    1:         if (newWidth > mLastSize.width)
    1:         {
    1:           RECT drect;
    1: 
    1:           //getting wider
    1:           drect.left = wp->x + mLastSize.width;
    1:           drect.top = wp->y;
    1:           drect.right = drect.left + (newWidth - mLastSize.width);
    1:           drect.bottom = drect.top + newHeight;
    1: 
    1:           ::RedrawWindow(mWnd, &drect, NULL,
    1:                          RDW_INVALIDATE | RDW_NOERASE | RDW_NOINTERNALPAINT | RDW_ERASENOW | RDW_ALLCHILDREN);
    1:         }
    1:         if (newHeight > mLastSize.height)
    1:         {
    1:           RECT drect;
    1: 
    1:           //getting taller
    1:           drect.left = wp->x;
    1:           drect.top = wp->y + mLastSize.height;
    1:           drect.right = drect.left + newWidth;
    1:           drect.bottom = drect.top + (newHeight - mLastSize.height);
    1: 
    1:           ::RedrawWindow(mWnd, &drect, NULL,
    1:                          RDW_INVALIDATE | RDW_NOERASE | RDW_NOINTERNALPAINT | RDW_ERASENOW | RDW_ALLCHILDREN);
    1:         }
    1: 
    1:         mBounds.width  = newWidth;
    1:         mBounds.height = newHeight;
    1:         mLastSize.width = newWidth;
    1:         mLastSize.height = newHeight;
    1:         ///nsRect rect(wp->x, wp->y, wp->cx, wp->cy);
    1: 
    1:         // If we're being minimized, don't send the resize event to Gecko because
    1:         // it will cause the scrollbar in the content area to go away and we'll
21538:         // forget the scroll position of the page.  Note that we need to check the
21538:         // toplevel window, because child windows seem to go to 0x0 on minimize.
21538:         HWND toplevelWnd = GetTopLevelHWND(mWnd);
21538:         if ( !newWidth && !newHeight && IsIconic(toplevelWnd)) {
    1:           result = PR_FALSE;
    1:           break;
    1:         }
    1: 
    1:         // recalculate the width and height
    1:         // this time based on the client area
    1:         if (::GetClientRect(mWnd, &r)) {
    1:           rect.width  = PRInt32(r.right - r.left);
    1:           rect.height = PRInt32(r.bottom - r.top);
    1:         }
    1:         result = OnResize(rect);
    1:       }
    1: 
    1:       /* handle size mode changes
    1:          (the framechanged message seems a handy place to hook in,
    1:          because it happens early enough (WM_SIZE is too late) and
    1:          because in testing it seems an accurate harbinger of
    1:          an impending min/max/restore change (WM_NCCALCSIZE would
    1:          also work, but it's also sent when merely resizing.)) */
    1:       if (wp->flags & SWP_FRAMECHANGED && ::IsWindowVisible(mWnd)) {
23335:         nsSizeModeEvent event(PR_TRUE, NS_SIZEMODE, this);
23335: #ifndef WINCE
    1:         WINDOWPLACEMENT pl;
    1:         pl.length = sizeof(pl);
    1:         ::GetWindowPlacement(mWnd, &pl);
    1: 
    1:         if (pl.showCmd == SW_SHOWMAXIMIZED)
    1:           event.mSizeMode = nsSizeMode_Maximized;
    1:         else if (pl.showCmd == SW_SHOWMINIMIZED)
    1:           event.mSizeMode = nsSizeMode_Minimized;
    1:         else
    1:           event.mSizeMode = nsSizeMode_Normal;
23335: #else
23335:         event.mSizeMode = nsSizeMode_Normal;
23335: #endif
    1:         InitEvent(event);
    1: 
    1:         result = DispatchWindowEvent(&event);
17080: 
23335: #ifndef WINCE
17080:         if (pl.showCmd == SW_SHOWMINIMIZED) {
17080:           // Deactivate
17080:           WCHAR className[kMaxClassNameLength];
17080:           ::GetClassNameW((HWND)wParam, className, kMaxClassNameLength);
23186:           if (wcscmp(className, kClassNameUI) &&
23186:               wcscmp(className, kClassNameContent) &&
23186:               wcscmp(className, kClassNameContentFrame) &&
23186:               wcscmp(className, kClassNameDialog) &&
23186:               wcscmp(className, kClassNameGeneral)) {
17080:             isMozWindowTakingFocus = PR_FALSE;
17080:           }
17080:           gJustGotDeactivate = PR_FALSE;
17080:           result = DispatchFocus(NS_DEACTIVATE, isMozWindowTakingFocus);
25051:         } else if (pl.showCmd == SW_SHOWNORMAL && !(wp->flags & SWP_NOACTIVATE)){
17080:           // Make sure we're active
17080:           result = DispatchFocus(NS_GOTFOCUS, PR_TRUE);
17080:           result = DispatchFocus(NS_ACTIVATE, PR_TRUE);
17080:         }
23335: #else
23335:         result = DispatchFocus(NS_GOTFOCUS, PR_TRUE);
23335:         result = DispatchFocus(NS_ACTIVATE, PR_TRUE);
23335: #endif
    1:       }
    1:     }
    1:     break;
    1: 
    1:     case WM_SETTINGCHANGE:
    1:         getWheelInfo = PR_TRUE;
    1:       break;
    1: 
    1:     case WM_PALETTECHANGED:
    1:       if ((HWND)wParam == mWnd) {
    1:         // We caused the WM_PALETTECHANGED message so avoid realizing
    1:         // another foreground palette
    1:         result = PR_TRUE;
    1:         break;
    1:       }
    1:       // fall thru...
    1: 
    1:     case WM_QUERYNEWPALETTE:      // this window is about to become active
    1:       mContext->GetPaletteInfo(palInfo);
    1:       if (palInfo.isPaletteDevice && palInfo.palette) {
    1:         HDC hDC = ::GetDC(mWnd);
    1:         HPALETTE hOldPal = ::SelectPalette(hDC, (HPALETTE)palInfo.palette, TRUE);
    1: 
    1:         // Realize the drawing palette
    1:         int i = ::RealizePalette(hDC);
    1: 
    1: #ifdef DEBUG
    1:         //printf("number of colors that changed=%d\n",i);
    1: #endif
    1:         // we should always invalidate.. because the lookup may have changed
    1:         ::InvalidateRect(mWnd, (LPRECT)NULL, TRUE);
    1: 
    1:         ::ReleaseDC(mWnd, hDC);
    1:         *aRetValue = TRUE;
    1:       }
    1:       result = PR_TRUE;
    1:       break;
    1: 
    1: #ifndef WINCE
    1:     case WM_INPUTLANGCHANGEREQUEST:
    1:       *aRetValue = TRUE;
    1:       result = PR_FALSE;
    1:       break;
    1: 
    1:     case WM_INPUTLANGCHANGE:
22411:       result = OnInputLangChange((HKL)lParam);
    1:       break;
    1: 
    1:     case WM_IME_STARTCOMPOSITION:
    1:       result = OnIMEStartComposition();
    1:       break;
    1: 
    1:     case WM_IME_COMPOSITION:
    1:       result = OnIMEComposition(lParam);
    1:       break;
    1: 
    1:     case WM_IME_ENDCOMPOSITION:
    1:       result = OnIMEEndComposition();
    1:       break;
    1: 
    1:     case WM_IME_CHAR:
    1:       // We receive double byte char code. No need to worry about the <Shift>
    1:       mIsShiftDown = PR_FALSE;
22788:       result = OnIMEChar((wchar_t)wParam, lParam);
    1:       break;
    1: 
    1:     case WM_IME_NOTIFY:
22788:       result = OnIMENotify(wParam, lParam);
    1:       break;
    1: 
    1:     // This is a Window 98/2000 only message
    1:     case WM_IME_REQUEST:
    1:       result = OnIMERequest(wParam, lParam, aRetValue);
    1: 
    1:       break;
    1: 
    1:     case WM_IME_SELECT:
    1:       result = OnIMESelect(wParam, (WORD)(lParam & 0x0FFFF));
    1:       break;
    1: 
    1:     case WM_IME_SETCONTEXT:
    1:       result = OnIMESetContext(wParam, lParam);
    1:       break;
    1: 
    1:     case WM_DROPFILES:
    1:     {
    1: #if 0
    1:       HDROP hDropInfo = (HDROP) wParam;
    1:       UINT nFiles = ::DragQueryFile(hDropInfo, (UINT)-1, NULL, 0);
    1: 
    1:       for (UINT iFile = 0; iFile < nFiles; iFile++) {
    1:         TCHAR szFileName[_MAX_PATH];
    1:         ::DragQueryFile(hDropInfo, iFile, szFileName, _MAX_PATH);
    1: #ifdef DEBUG
    1:         printf("szFileName [%s]\n", szFileName);
    1: #endif  // DEBUG
    1:         nsAutoString fileStr(szFileName);
    1:         nsEventStatus status;
    1:         nsDragDropEvent event(NS_DRAGDROP_EVENT, this);
    1:         InitEvent(event);
    1:         event.mType      = nsDragDropEventStatus_eDrop;
    1:         event.mIsFileURL = PR_FALSE;
    1:         event.mURL       = fileStr.get();
    1:         DispatchEvent(&event, status);
    1:       }
    1: #endif // 0
    1:     }
    1:     break;
    1: #endif // WINCE
    1: 
    1:     case WM_DESTROYCLIPBOARD:
    1:     {
    1:       nsIClipboard* clipboard;
    1:       nsresult rv = CallGetService(kCClipboardCID, &clipboard);
    1:       clipboard->EmptyClipboard(nsIClipboard::kGlobalClipboard);
    1:       NS_RELEASE(clipboard);
    1:     }
    1:     break;
    1: 
    1: #ifdef ACCESSIBILITY
    1:     case WM_GETOBJECT:
    1:     {
 2395:       *aRetValue = 0;
    1:       if (lParam == OBJID_CLIENT) { // oleacc.dll will be loaded dynamically
    1:         nsCOMPtr<nsIAccessible> rootAccessible = GetRootAccessible(); // Held by a11y cache
    1:         if (rootAccessible) {
 2395:           IAccessible *msaaAccessible = NULL;
    1:           rootAccessible->GetNativeInterface((void**)&msaaAccessible); // does an addref
    1:           if (msaaAccessible) {
 2395:             *aRetValue = LresultFromObject(IID_IAccessible, wParam, msaaAccessible); // does an addref
    1:             msaaAccessible->Release(); // release extra addref
 2395:             result = PR_TRUE;  // We handled the WM_GETOBJECT message
 2395:           }
 2395:         }
 2395:       }
    1:     }
    1: #endif
    1: 
    1: #ifndef WINCE
    1:     case WM_SYSCOMMAND:
    1:       // prevent Windows from trimming the working set. bug 76831
    1:       if (!gTrimOnMinimize && wParam == SC_MINIMIZE) {
    1:         ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
    1:         result = PR_TRUE;
    1:       }
    1:       break;
    1: #endif
    1: 
    1: 
    1: #ifdef WINCE
    1:   case WM_HIBERNATE:        
    1:     nsMemory::HeapMinimize(PR_TRUE);
    1:     break;
    1: #endif
    1:     default:
    1:     {
    1:       // Handle both flavors of mouse wheel events.
    1: #ifndef WINCE
    1:       if (msg == WM_MOUSEWHEEL || msg == WM_MOUSEHWHEEL) {
    1:         static int iDeltaPerLine, iDeltaPerChar;
    1:         static ULONG ulScrollLines, ulScrollChars = 1;
    1:         static int currentVDelta, currentHDelta;
    1:         static HWND currentWindow = 0;
    1: 
    1:         PRBool isVertical = msg == WM_MOUSEWHEEL;
    1: 
    1:         // Get mouse wheel metrics (but only once).
    1:         if (getWheelInfo) {
    1:           getWheelInfo = PR_FALSE;
    1: 
    1:           SystemParametersInfo (SPI_GETWHEELSCROLLLINES, 0, &ulScrollLines, 0);
    1: 
    1:           // ulScrollLines usually equals 3 or 0 (for no scrolling)
    1:           // WHEEL_DELTA equals 120, so iDeltaPerLine will be 40.
    1: 
    1:           // However, if ulScrollLines > WHEEL_DELTA, we assume that
    1:           // the mouse driver wants a page scroll.  The docs state that
    1:           // ulScrollLines should explicitly equal WHEEL_PAGESCROLL, but
    1:           // since some mouse drivers use an arbitrary large number instead,
    1:           // we have to handle that as well.
    1: 
    1:           iDeltaPerLine = 0;
    1:           if (ulScrollLines) {
    1:             if (ulScrollLines <= WHEEL_DELTA) {
    1:               iDeltaPerLine = WHEEL_DELTA / ulScrollLines;
    1:             } else {
    1:               ulScrollLines = WHEEL_PAGESCROLL;
    1:             }
    1:           }
    1: 
    1:           if (!SystemParametersInfo(SPI_GETWHEELSCROLLCHARS, 0,
    1:                                     &ulScrollChars, 0)) {
    1:             // Note that we may always fail to get the value before Win Vista.
    1:             ulScrollChars = 1;
    1:           }
    1: 
    1:           iDeltaPerChar = 0;
    1:           if (ulScrollChars) {
    1:             if (ulScrollChars <= WHEEL_DELTA) {
    1:               iDeltaPerChar = WHEEL_DELTA / ulScrollChars;
    1:             } else {
    1:               ulScrollChars = WHEEL_PAGESCROLL;
    1:             }
    1:           }
    1:         }
    1: 
    1:         if ((isVertical  && ulScrollLines != WHEEL_PAGESCROLL && !iDeltaPerLine) ||
    1:             (!isVertical && ulScrollChars != WHEEL_PAGESCROLL && !iDeltaPerChar))
    1:           return 0;
    1: 
    1:         // The mousewheel event will be dispatched to the toplevel
    1:         // window.  We need to give it to the child window
    1: 
    1:         POINT point;
    1:         point.x = GET_X_LPARAM(lParam);
    1:         point.y = GET_Y_LPARAM(lParam);
    1:         HWND destWnd = ::WindowFromPoint(point);
    1: 
    1:         // Since we receive mousewheel events for as long as
    1:         // we are focused, it's entirely possible that there
    1:         // is another app's window or no window under the
    1:         // pointer.
    1: 
    1:         if (!destWnd) {
    1:           // No window is under the pointer
    1:           break;
    1:         }
    1: 
    1:         // We don't care about windows belonging to other processes.
    1:         DWORD processId = 0;
    1:         GetWindowThreadProcessId(destWnd, &processId);
    1:         if (processId != GetCurrentProcessId())
    1:         {
    1:           // Somebody elses window
    1:           break;
    1:         }
    1: 
22482:         nsWindow* destWindow = GetNSWindowPtr(destWnd);
22482:         if (!destWindow || destWindow->mIsPluginWindow) {
    1:           // Some other app, or a plugin window.
    1:           // Windows directs WM_MOUSEWHEEL to the focused window.
    1:           // However, Mozilla does not like plugins having focus, so a
    1:           // Mozilla window (ie, the plugin's parent (us!) has focus.)
    1:           // Therefore, plugins etc _should_ get first grab at the
    1:           // message, but this focus vaguary means the plugin misses
    1:           // out. If the window is a child of ours, forward it on.
    1:           // Determine if a child by walking the parent list until
    1:           // we find a parent matching our wndproc.
    1:           HWND parentWnd = ::GetParent(destWnd);
    1:           while (parentWnd) {
22482:             nsWindow* parentWindow = GetNSWindowPtr(parentWnd);
22482:             if (parentWindow) {
    1:               // We have a child window - quite possibly a plugin window.
    1:               // However, not all plugins are created equal - some will handle this message themselves,
    1:               // some will forward directly back to us, while others will call DefWndProc, which
    1:               // itself still forwards back to us.
    1:               // So if we have sent it once, we need to handle it ourself.
    1:               if (mIsInMouseWheelProcessing) {
    1:                 destWnd = parentWnd;
22482:                 destWindow = parentWindow;
    1:               } else {
    1:                 // First time we have seen this message.
    1:                 // Call the child - either it will consume it, or
    1:                 // it will wind it's way back to us, triggering the destWnd case above.
    1:                 // either way, when the call returns, we are all done with the message,
    1:                 mIsInMouseWheelProcessing = PR_TRUE;
    1:                 if (0 == ::SendMessageW(destWnd, msg, wParam, lParam)) {
    1:                   result = PR_TRUE; // consumed - don't call DefWndProc
    1:                 }
    1:                 destWnd = nsnull;
    1:                 mIsInMouseWheelProcessing = PR_FALSE;
    1:               }
    1:               break; // stop parent search
    1:             }
    1:             parentWnd = ::GetParent(parentWnd);
    1:           } // while parentWnd
    1:         }
    1:         if (destWnd == nsnull)
    1:           break; // done with this message.
    1:         if (destWnd != mWnd) {
    1:           if (destWindow) {
    1:             return destWindow->ProcessMessage(msg, wParam, lParam, aRetValue);
    1:           }
    1: #ifdef DEBUG
    1:           else
    1:             printf("WARNING: couldn't get child window for MW event\n");
    1: #endif
    1:         }
    1: 
    1:         // We should cancel the surplus delta if the current window is not
    1:         // same as previous.
    1:         if (currentWindow != mWnd) {
    1:           currentVDelta = 0;
    1:           currentHDelta = 0;
    1:           currentWindow = mWnd;
    1:         }
    1: 
    1:         nsMouseScrollEvent scrollEvent(PR_TRUE, NS_MOUSE_SCROLL, this);
    1:         scrollEvent.delta = 0;
    1:         if (isVertical) {
    1:           scrollEvent.scrollFlags = nsMouseScrollEvent::kIsVertical;
    1:           if (ulScrollLines == WHEEL_PAGESCROLL) {
    1:             scrollEvent.scrollFlags |= nsMouseScrollEvent::kIsFullPage;
    1:             scrollEvent.delta = (((short) HIWORD (wParam)) > 0) ? -1 : 1;
    1:           } else {
    1:             currentVDelta -= (short) HIWORD (wParam);
    1:             if (PR_ABS(currentVDelta) >= iDeltaPerLine) {
    1:               scrollEvent.delta = currentVDelta / iDeltaPerLine;
    1:               currentVDelta %= iDeltaPerLine;
    1:             }
    1:           }
    1:         } else {
    1:           scrollEvent.scrollFlags = nsMouseScrollEvent::kIsHorizontal;
    1:           if (ulScrollChars == WHEEL_PAGESCROLL) {
    1:             scrollEvent.scrollFlags |= nsMouseScrollEvent::kIsFullPage;
    1:             scrollEvent.delta = (((short) HIWORD (wParam)) > 0) ? 1 : -1;
    1:           } else {
    1:             currentHDelta += (short) HIWORD (wParam);
    1:             if (PR_ABS(currentHDelta) >= iDeltaPerChar) {
    1:               scrollEvent.delta = currentHDelta / iDeltaPerChar;
    1:               currentHDelta %= iDeltaPerChar;
    1:             }
    1:           }
    1:         }
    1: 
    1:         scrollEvent.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
    1:         scrollEvent.isControl = IS_VK_DOWN(NS_VK_CONTROL);
    1:         scrollEvent.isMeta    = PR_FALSE;
    1:         scrollEvent.isAlt     = IS_VK_DOWN(NS_VK_ALT);
    1:         InitEvent(scrollEvent);
    1:         if (nsnull != mEventCallback) {
    1:           result = DispatchWindowEvent(&scrollEvent);
    1:         }
    1:         // Note that we should return zero if we process WM_MOUSEWHEEL.
    1:         // But if we process WM_MOUSEHWHEEL, we should return non-zero.
    1:         if (result)
    1:           *aRetValue = isVertical ? 0 : TRUE;
    1:       } // msg == WM_MOUSEWHEEL || msg == WM_MOUSEHWHEEL
    1: 
    1:       else if (msg == nsWindow::uWM_HEAP_DUMP) {
    1:         // XXX for now we use c:\heapdump.txt until we figure out how to
    1:         // XXX pass in message parameters.
    1:         HeapDump("c:\\heapdump.txt", "whatever");
    1:         result = PR_TRUE;
    1:       }
    1: #endif // WINCE
    1: 
24836: #ifdef NS_ENABLE_TSF
24836:       else if (msg == WM_USER_TSF_TEXTCHANGE) {
24836:         nsTextStore::OnTextChangeMsg();
24836:       }
24836: #endif //NS_ENABLE_TSF
24836: 
    1:     }
    1:     break;
23335: #ifndef WINCE
16601:   case WM_DWMCOMPOSITIONCHANGED:
19222:     BroadcastMsg(mWnd, WM_DWMCOMPOSITIONCHANGED);
19222:     DispatchStandardEvent(NS_THEMECHANGED);
16601:     if (nsUXThemeData::CheckForCompositor() && mTransparencyMode == eTransparencyGlass) {
16601:       MARGINS margins = { -1, -1, -1, -1 };
16601:       nsUXThemeData::dwmExtendFrameIntoClientAreaPtr(mWnd, &margins);
16601:     }
19222:     Invalidate(PR_FALSE);
16601:     break;
23335: #endif
26874: 
26874:     /* Gesture support events */
26874: 
26874:     case WM_TABLET_QUERYSYSTEMGESTURESTATUS:
26874:       // According to MS samples, this must be handled to enable
26874:       // rotational support in multi-touch drivers.
26874:       result = PR_TRUE;
26874:       *aRetValue = TABLET_ROTATE_GESTURE_ENABLE;
26874:       break;
26874:     
26874:     case WM_GESTURE:
26874:       result = ProcessGestureMessage(wParam, lParam);
26874:       break;
23335:   }
23335: 
    1:   //*aRetValue = result;
    1:   if (mWnd) {
    1:     return result;
    1:   }
    1:   else {
    1:     //Events which caused mWnd destruction and aren't consumed
    1:     //will crash during the Windows default processing.
    1:     return PR_TRUE;
    1:   }
    1: }
    1: 
26874: PRBool nsWindow::ProcessGestureMessage(WPARAM wParam, LPARAM lParam)
26874: {
26874:   // Treatment for pan events which translate into scroll events:
26874:   if (mGesture.IsPanEvent(lParam)) {
26874:     nsMouseScrollEvent event(PR_TRUE, NS_MOUSE_PIXEL_SCROLL, this);
26874: 
26874:     if ( !mGesture.ProcessPanMessage(mWnd, wParam, lParam) )
26874:       return PR_FALSE; // ignore
26874: 
26874:     nsEventStatus status;
26874: 
26874:     event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
26874:     event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
26874:     event.isMeta    = PR_FALSE;
26874:     event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
26874:     event.button    = 0;
26874:     event.time      = ::GetMessageTime();
26874: 
26874:     if (mGesture.PanDeltaToPixelScrollX(event)) {
26874:       DispatchEvent(&event, status);
26874:     }
26874:     if (mGesture.PanDeltaToPixelScrollY(event)) {
26874:       DispatchEvent(&event, status);
26874:     }
26874: 
26874:     mGesture.CloseGestureInfoHandle((HGESTUREINFO)lParam);
26874: 
26874:     return PR_TRUE;
26874:   }
26874: 
26874:   // Other gestures translate into simple gesture events:
26874:   nsSimpleGestureEvent event(PR_TRUE, 0, this, 0, 0.0);
26874:   if ( !mGesture.ProcessGestureMessage(mWnd, wParam, lParam, event) ) {
26874:     return PR_FALSE; // fall through to DefWndProc
26874:   }
26874:   
26874:   // Polish up and send off the new event
26874:   event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
26874:   event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
26874:   event.isMeta    = PR_FALSE;
26874:   event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
26874:   event.button    = 0;
26874:   event.time      = ::GetMessageTime();
26874: 
26874:   nsEventStatus status;
26874:   DispatchEvent(&event, status);
26874:   if (status == nsEventStatus_eIgnore) {
26874:     return PR_FALSE; // Ignored, fall through
26874:   }
26874: 
26874:   // Only close this if we process and return true.
26874:   mGesture.CloseGestureInfoHandle((HGESTUREINFO)lParam);
26874: 
26874:   return PR_TRUE; // Handled
26874: }
26874: 
22788: LRESULT nsWindow::ProcessCharMessage(const MSG &aMsg, PRBool *aEventDispatched)
22788: {
22788:   NS_PRECONDITION(aMsg.message == WM_CHAR || aMsg.message == WM_SYSCHAR,
22788:                   "message is not keydown event");
22788:   PR_LOG(sWindowsLog, PR_LOG_ALWAYS,
22788:          ("%s charCode=%d scanCode=%d\n",
22788:          aMsg.message == WM_SYSCHAR ? "WM_SYSCHAR" : "WM_CHAR",
22788:          aMsg.wParam, HIWORD(aMsg.lParam) & 0xFF));
22788: 
22788:   // These must be checked here too as a lone WM_CHAR could be received
22788:   // if a child window didn't handle it (for example Alt+Space in a content window)
22788:   SetupModKeyState();
22788: 
22788:   return OnChar(aMsg, aEventDispatched);
22788: }
22788: 
22788: LRESULT nsWindow::ProcessKeyUpMessage(const MSG &aMsg, PRBool *aEventDispatched)
22788: {
22788:   NS_PRECONDITION(aMsg.message == WM_KEYUP || aMsg.message == WM_SYSKEYUP,
22788:                   "message is not keydown event");
22788:   PR_LOG(sWindowsLog, PR_LOG_ALWAYS,
22788:          ("%s VK=%d\n", aMsg.message == WM_SYSKEYDOWN ?
22788:                           "WM_SYSKEYUP" : "WM_KEYUP", aMsg.wParam));
22788: 
22788:   SetupModKeyState();
22788: 
22788:   // Note: the original code passed (HIWORD(lParam)) to OnKeyUp as
22788:   // scan code. However, this breaks Alt+Num pad input.
22788:   // http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/toascii.asp
22788:   // states the following:
22788:   //  Typically, ToAscii performs the translation based on the
22788:   //  virtual-key code. In some cases, however, bit 15 of the
22788:   //  uScanCode parameter may be used to distinguish between a key
22788:   //  press and a key release. The scan code is used for
22788:   //  translating ALT+number key combinations.
22788: 
22788:   // ignore [shift+]alt+space so the OS can handle it
22788:   if (mIsAltDown && !mIsControlDown && IS_VK_DOWN(NS_VK_SPACE))
22788:     return FALSE;
22788: 
22788:   if (!sIMEIsComposing && (aMsg.message != WM_KEYUP || aMsg.message != VK_MENU)) {
22788:     // Ignore VK_MENU if it's not a system key release, so that the menu bar does not trigger
22788:     // This helps avoid triggering the menu bar for ALT key accelerators used in
22788:     // assistive technologies such as Window-Eyes and ZoomText, and when using Alt+Tab
22788:     // to switch back to Mozilla in Windows 95 and Windows 98
22788:     return OnKeyUp(aMsg, aEventDispatched);
22788:   }
22788: 
22788:   return 0;
22788: }
22788: 
22788: LRESULT nsWindow::ProcessKeyDownMessage(const MSG &aMsg,
22788:                                         PRBool *aEventDispatched)
22788: {
22788:   PR_LOG(sWindowsLog, PR_LOG_ALWAYS,
22788:          ("%s VK=%d\n", aMsg.message == WM_SYSKEYDOWN ?
22788:                           "WM_SYSKEYDOWN" : "WM_KEYDOWN", aMsg.wParam));
22788:   NS_PRECONDITION(aMsg.message == WM_KEYDOWN || aMsg.message == WM_SYSKEYDOWN,
22788:                   "message is not keydown event");
22788: 
22788:   SetupModKeyState();
22788: 
22788:   // Note: the original code passed (HIWORD(lParam)) to OnKeyDown as
22788:   // scan code. However, this breaks Alt+Num pad input.
22788:   // http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/toascii.asp
22788:   // states the following:
22788:   //  Typically, ToAscii performs the translation based on the
22788:   //  virtual-key code. In some cases, however, bit 15 of the
22788:   //  uScanCode parameter may be used to distinguish between a key
22788:   //  press and a key release. The scan code is used for
22788:   //  translating ALT+number key combinations.
22788: 
22788:   // ignore [shift+]alt+space so the OS can handle it
22788:   if (mIsAltDown && !mIsControlDown && IS_VK_DOWN(NS_VK_SPACE))
22788:     return FALSE;
22788: 
22788:   LRESULT result = 0;
22788:   if (mIsAltDown && sIMEIsStatusChanged) {
22788:     sIMEIsStatusChanged = PR_FALSE;
22788:   } else if (!sIMEIsComposing) {
22788:     result = OnKeyDown(aMsg, aEventDispatched, nsnull);
22788:   }
22788: 
22788: #ifndef WINCE
22788:   if (aMsg.wParam == VK_MENU || (aMsg.wParam == VK_F10 && !mIsShiftDown)) {
22788:     // We need to let Windows handle this keypress,
22788:     // by returning PR_FALSE, if there's a native menu
22788:     // bar somewhere in our containing window hierarchy.
22788:     // Otherwise we handle the keypress and don't pass
22788:     // it on to Windows, by returning PR_TRUE.
22788:     PRBool hasNativeMenu = PR_FALSE;
22788:     HWND hWnd = mWnd;
22788:     while (hWnd) {
22788:       if (::GetMenu(hWnd)) {
22788:         hasNativeMenu = PR_TRUE;
22788:         break;
22788:       }
22788:       hWnd = ::GetParent(hWnd);
22788:     }
22788:     result = !hasNativeMenu;
22788:   }
22788: #endif
22788: 
22788:   return result;
22788: }
22788: 
22788: PRBool
22788: nsWindow::ProcessMessageForPlugin(const MSG &aMsg,
22788:                                   LRESULT *aResult,
22788:                                   PRBool &aCallDefWndProc)
22788: {
22788:   NS_PRECONDITION(aResult, "aResult must be non-null.");
22788:   *aResult = 0;
22788: 
22788:   aCallDefWndProc = PR_FALSE;
22788:   PRBool fallBackToNonPluginProcess = PR_FALSE;
22788:   PRBool eventDispatched = PR_FALSE;
22788:   switch (aMsg.message) {
22788:     case WM_INPUTLANGCHANGEREQUEST:
22788:     case WM_INPUTLANGCHANGE:
22788:       DispatchPluginEvent(aMsg);
22788:       return PR_FALSE; // go to non-plug-ins processing
22788: 
22788:     case WM_CHAR:
22788:     case WM_SYSCHAR:
22788:       *aResult = ProcessCharMessage(aMsg, &eventDispatched);
22788:       break;
22788: 
22788:     case WM_KEYUP:
22788:     case WM_SYSKEYUP:
22788:       *aResult = ProcessKeyUpMessage(aMsg, &eventDispatched);
22788:       break;
22788: 
22788:     case WM_KEYDOWN:
22788:     case WM_SYSKEYDOWN:
22788:       *aResult = ProcessKeyDownMessage(aMsg, &eventDispatched);
22788:       break;
22788: 
22788:     case WM_IME_COMPOSITION:
22788:       // We should end composition if there is a committed string.
22788:       if (aMsg.lParam & GCS_RESULTSTR)
22788:         sIMEIsComposing = PR_FALSE;
22788:       // Continue composition if there is still a string being composed.
22788:       if (IS_COMPOSING_LPARAM(aMsg.lParam))
22788:         sIMEIsComposing = PR_TRUE;
22788:       break;
22788: 
22788:     case WM_IME_STARTCOMPOSITION:
22788:       sIMEIsComposing = PR_TRUE;
22788:       break;
22788: 
22788:     case WM_IME_ENDCOMPOSITION:
22788:       sIMEIsComposing = PR_FALSE;
22788:       break;
22788: 
22788:     case WM_DEADCHAR:
22788:     case WM_SYSDEADCHAR:
22788:     case WM_CONTEXTMENU:
22788: 
22788:     case WM_CUT:
22788:     case WM_COPY:
22788:     case WM_PASTE:
22788:     case WM_CLEAR:
22788:     case WM_UNDO:
22788: 
22788:     case WM_IME_CHAR:
22788:     case WM_IME_COMPOSITIONFULL:
22788:     case WM_IME_CONTROL:
22788:     case WM_IME_KEYDOWN:
22788:     case WM_IME_KEYUP:
22788:     case WM_IME_NOTIFY:
22788:     case WM_IME_REQUEST:
22788:     case WM_IME_SELECT:
22788:     case WM_IME_SETCONTEXT:
22788:       break;
22788: 
22788:     default:
22788:       return PR_FALSE;
22788:   }
22788: 
22788:   if (!eventDispatched)
22788:     aCallDefWndProc = !DispatchPluginEvent(aMsg);
22788:   DispatchPendingEvents();
22788:   return PR_TRUE;
22788: }
22788: 
22788: PRBool nsWindow::DispatchPluginEvent(const MSG &aMsg)
22788: {
22788:   if (!PluginHasFocus())
22788:     return PR_FALSE;
22788: 
22788:   nsGUIEvent event(PR_TRUE, NS_PLUGIN_EVENT, this);
23738:   nsIntPoint point(0, 0);
22788:   InitEvent(event, &point);
22788:   nsPluginEvent pluginEvent;
22788:   pluginEvent.event = aMsg.message;
22788:   pluginEvent.wParam = aMsg.wParam;
22788:   pluginEvent.lParam = aMsg.lParam;
22788:   event.nativeMsg = (void *)&pluginEvent;
22788:   return DispatchWindowEvent(&event);
22788: }
22788: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // return the window class name and initialize the class if needed
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: #define CS_XP_DROPSHADOW       0x00020000
    1: 
23186: LPCWSTR nsWindow::WindowClass()
    1: {
    1:   if (!nsWindow::sIsRegistered) {
    1:     WNDCLASSW wc;
    1: 
    1: //    wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    1:     wc.style         = CS_DBLCLKS;
22482:     wc.lpfnWndProc   = ::DefWindowProcW;
    1:     wc.cbClsExtra    = 0;
    1:     wc.cbWndExtra    = 0;
    1:     wc.hInstance     = nsToolkit::mDllInstance;
22528:     wc.hIcon         = ::LoadIconW(::GetModuleHandleW(NULL), (LPWSTR)IDI_APPLICATION);
    1:     wc.hCursor       = NULL;
    1:     wc.hbrBackground = mBrush;
    1:     wc.lpszMenuName  = NULL;
23186:     wc.lpszClassName = kClassNameHidden;
    1: 
23335:     BOOL succeeded = ::RegisterClassW(&wc) != 0 && 
23335:       ERROR_CLASS_ALREADY_EXISTS != GetLastError();
    1:     nsWindow::sIsRegistered = succeeded;
    1: 
23186:     wc.lpszClassName = kClassNameContentFrame;
23335:     if (!::RegisterClassW(&wc) && 
23335:       ERROR_CLASS_ALREADY_EXISTS != GetLastError()) {
    1:       nsWindow::sIsRegistered = FALSE;
    1:     }
    1: 
23186:     wc.lpszClassName = kClassNameContent;
23335:     if (!::RegisterClassW(&wc) && 
23335:       ERROR_CLASS_ALREADY_EXISTS != GetLastError()) {
    1:       nsWindow::sIsRegistered = FALSE;
    1:     }
    1: 
23186:     wc.lpszClassName = kClassNameUI;
23335:     if (!::RegisterClassW(&wc) && 
23335:       ERROR_CLASS_ALREADY_EXISTS != GetLastError()) {
    1:       nsWindow::sIsRegistered = FALSE;
    1:     }
    1: 
23186:     wc.lpszClassName = kClassNameGeneral;
    1:     ATOM generalClassAtom = ::RegisterClassW(&wc);
23335:     if (!generalClassAtom && 
23335:       ERROR_CLASS_ALREADY_EXISTS != GetLastError()) {
    1:       nsWindow::sIsRegistered = FALSE;
    1:     }
    1: 
23186:     wc.lpszClassName = kClassNameDialog;
    1:     wc.hIcon = 0;
23335:     if (!::RegisterClassW(&wc) && 
23335:       ERROR_CLASS_ALREADY_EXISTS != GetLastError()) {
    1:       nsWindow::sIsRegistered = FALSE;
    1:     }
    1:   }
    1: 
    1:   if (mWindowType == eWindowType_invisible) {
23186:     return kClassNameHidden;
    1:   }
    1:   if (mWindowType == eWindowType_dialog) {
23186:     return kClassNameDialog;
    1:   }
    1:   if (mContentType == eContentTypeContent) {
23186:     return kClassNameContent;
    1:   }
    1:   if (mContentType == eContentTypeContentFrame) {
23186:     return kClassNameContentFrame;
    1:   }
    1:   if (mContentType == eContentTypeUI) {
23186:     return kClassNameUI;
23186:   }
23186:   return kClassNameGeneral;
23186: }
23186: 
23186: LPCWSTR nsWindow::WindowPopupClass()
    1: {
    1:   const LPCWSTR className = L"MozillaDropShadowWindowClass";
    1: 
    1:   if (!nsWindow::sIsPopupClassRegistered) {
    1:     WNDCLASSW wc;
    1: 
    1:     wc.style = CS_DBLCLKS | CS_XP_DROPSHADOW;
22482:     wc.lpfnWndProc   = ::DefWindowProcW;
    1:     wc.cbClsExtra    = 0;
    1:     wc.cbWndExtra    = 0;
    1:     wc.hInstance     = nsToolkit::mDllInstance;
22528:     wc.hIcon         = ::LoadIconW(::GetModuleHandleW(NULL), (LPWSTR)IDI_APPLICATION);
    1:     wc.hCursor       = NULL;
    1:     wc.hbrBackground = mBrush;
    1:     wc.lpszMenuName  = NULL;
    1:     wc.lpszClassName = className;
    1: 
    1:     nsWindow::sIsPopupClassRegistered = ::RegisterClassW(&wc);
    1:     if (!nsWindow::sIsPopupClassRegistered) {
    1:       // For older versions of Win32 (i.e., not XP), the registration will
    1:       // fail, so we have to re-register without the CS_XP_DROPSHADOW flag.
    1:       wc.style = CS_DBLCLKS;
    1:       nsWindow::sIsPopupClassRegistered = ::RegisterClassW(&wc);
    1:     }
    1:   }
    1: 
    1:   return className;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // return nsWindow styles
    1: //
    1: //-------------------------------------------------------------------------
    1: DWORD nsWindow::WindowStyle()
    1: {
    1:   DWORD style;
    1: 
24970:   /* On Windows Mobile, we want very simple window styles; this is
24970:    * just optimizing for full-screen apps that don't want any
24970:    * titlebar/etc.  UI.  We should probably allow apps some
24970:    * finer-grained control over these types at some point, but for now
24970:    * this will work fine.  If we're on Windows CE, we probably have a
24970:    * full window manager, so we make dialog/toplevel windows be real
24970:    * windows.  In addition, we do the post-processing on the style
24970:    * (e.g. disabling the thick resize window if we don't have resize
24970:    * handles specified in the style).
24970:    */
24970:   /* Note: On Windows CE (and presumably Mobile), WS_OVERLAPPED provides
24970:    * space for a menu bar in the window, which we don't want; it shouldn't
24970:    * be used. */
24970: #if defined(WINCE)
    1:   switch (mWindowType) {
    1:     case eWindowType_child:
    1:       style = WS_CHILD;
    1:       break;
    1: 
    1:     case eWindowType_dialog:
24970:       style = WS_BORDER | WS_POPUP;
25860: #if !defined(WINCE_WINDOWS_MOBILE)
24970:       style |= WS_SYSMENU;
24970:       if (mBorderStyle != eBorderStyle_default)
24970:         style |= WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
24970: #endif
24970:       break;
24970: 
    1:     case eWindowType_popup:
25860:       style = WS_POPUP | WS_BORDER;
    1:       break;
    1: 
    1:     default:
    1:       NS_ASSERTION(0, "unknown border style");
    1:       // fall through
    1: 
    1:     case eWindowType_toplevel:
    1:     case eWindowType_invisible:
    1:       style = WS_BORDER;
25860: #if !defined(WINCE_WINDOWS_MOBILE)
25860:       style |= WS_OVERLAPPED | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
24970: #endif
24970:       break;
24970:   }
    1: #else
    1:   switch (mWindowType) {
    1:     case eWindowType_child:
    1:       style = WS_OVERLAPPED;
    1:       break;
    1: 
    1:     case eWindowType_dialog:
24970:       style = WS_OVERLAPPED | WS_BORDER | WS_DLGFRAME | WS_SYSMENU | DS_3DLOOK | DS_MODALFRAME;
24970:       if (mBorderStyle != eBorderStyle_default)
24970:         style |= WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    1:       break;
    1: 
    1:     case eWindowType_popup:
24970:       style = WS_POPUP;
19222:       if (mTransparencyMode == eTransparencyGlass) {
20046:         /* Glass seems to need WS_CAPTION or WS_THICKFRAME to work.
20046:            WS_THICKFRAME has issues with autohiding popups but looks better */
24970:         style |= WS_THICKFRAME;
19222:       } else {
24970:         style |= WS_OVERLAPPED;
24970:       }
24977:       break;
    1: 
    1:     default:
    1:       NS_ASSERTION(0, "unknown border style");
    1:       // fall through
    1: 
    1:     case eWindowType_toplevel:
    1:     case eWindowType_invisible:
    1:       style = WS_OVERLAPPED | WS_BORDER | WS_DLGFRAME | WS_SYSMENU |
    1:               WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    1:       break;
    1:   }
24970: #endif
24970: 
24970: #ifndef WINCE_WINDOWS_MOBILE
    1:   if (mBorderStyle != eBorderStyle_default && mBorderStyle != eBorderStyle_all) {
    1:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_border))
    1:       style &= ~WS_BORDER;
    1: 
    1:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_title)) {
    1:       style &= ~WS_DLGFRAME;
    1:       style |= WS_POPUP;
19016:       style &= ~WS_CHILD;
    1:     }
    1: 
    1:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_close))
    1:       style &= ~0;
    1:     // XXX The close box can only be removed by changing the window class,
    1:     // as far as I know   --- roc+moz@cs.cmu.edu
    1: 
    1:     if (mBorderStyle == eBorderStyle_none ||
    1:       !(mBorderStyle & (eBorderStyle_menu | eBorderStyle_close)))
    1:       style &= ~WS_SYSMENU;
    1:     // Looks like getting rid of the system menu also does away with the
    1:     // close box. So, we only get rid of the system menu if you want neither it
    1:     // nor the close box. How does the Windows "Dialog" window class get just
    1:     // closebox and no sysmenu? Who knows.
    1: 
    1:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_resizeh))
    1:       style &= ~WS_THICKFRAME;
    1: 
    1:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_minimize))
    1:       style &= ~WS_MINIMIZEBOX;
    1: 
    1:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_maximize))
    1:       style &= ~WS_MAXIMIZEBOX;
    1:   }
    1: #endif // WINCE
19016:   VERIFY_WINDOW_STYLE(style);
    1:   return style;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // return nsWindow extended styles
    1: //
    1: //-------------------------------------------------------------------------
    1: DWORD nsWindow::WindowExStyle()
    1: {
    1:   switch (mWindowType)
    1:   {
    1:     case eWindowType_child:
    1:       return 0;
    1: 
    1:     case eWindowType_dialog:
    1:       return WS_EX_WINDOWEDGE | WS_EX_DLGMODALFRAME;
    1: 
    1:     case eWindowType_popup:
25860:       return
25860: #if defined(WINCE) && !defined(WINCE_WINDOWS_MOBILE)
25860:         WS_EX_NOACTIVATE |
25860: #endif
25860:         WS_EX_TOPMOST | WS_EX_TOOLWINDOW;
    1: 
    1:     default:
    1:       NS_ASSERTION(0, "unknown border style");
    1:       // fall through
    1: 
    1:     case eWindowType_toplevel:
    1:     case eWindowType_invisible:
    1:       return WS_EX_WINDOWEDGE;
    1:   }
    1: }
    1: 
    1: 
    1: // -----------------------------------------------------------------------
    1: //
    1: // Subclass (or remove the subclass from) this component's nsWindow
    1: //
    1: // -----------------------------------------------------------------------
    1: void nsWindow::SubclassWindow(BOOL bState)
    1: {
    1:   if (NULL != mWnd) {
    1:     NS_PRECONDITION(::IsWindow(mWnd), "Invalid window handle");
    1: 
    1:     if (bState) {
    1:       // change the nsWindow proc
    1:       if (mUnicodeWidget)
25349:         mPrevWndProc = (WNDPROC)::SetWindowLongPtrW(mWnd, GWLP_WNDPROC,
25349:                                                 (LONG_PTR)nsWindow::WindowProc);
    1:       else
25349:         mPrevWndProc = (WNDPROC)::SetWindowLongPtrA(mWnd, GWLP_WNDPROC,
25349:                                                 (LONG_PTR)nsWindow::WindowProc);
    1:       NS_ASSERTION(mPrevWndProc, "Null standard window procedure");
    1:       // connect the this pointer to the nsWindow handle
    1:       SetNSWindowPtr(mWnd, this);
    1:     }
    1:     else {
    1:       if (mUnicodeWidget)
25349:         ::SetWindowLongPtrW(mWnd, GWLP_WNDPROC, (LONG_PTR)mPrevWndProc);
    1:       else
25349:         ::SetWindowLongPtrA(mWnd, GWLP_WNDPROC, (LONG_PTR)mPrevWndProc);
    1:       SetNSWindowPtr(mWnd, NULL);
    1:       mPrevWndProc = NULL;
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // WM_DESTROY has been called
    1: //
    1: //-------------------------------------------------------------------------
    1: void nsWindow::OnDestroy()
    1: {
    1:   mOnDestroyCalled = PR_TRUE;
    1: 
    1:   SubclassWindow(FALSE);
 4186: 
 4186:   // We have to destroy the native drag target before we null out our
 4186:   // window pointer
 4186:   EnableDragDrop(PR_FALSE);
 4186: 
    1:   mWnd = NULL;
    1: 
    1:   // free GDI objects
    1:   if (mBrush) {
    1:     VERIFY(::DeleteObject(mBrush));
    1:     mBrush = NULL;
    1:   }
    1: 
    1: #if 0
    1:   if (mPalette) {
    1:     VERIFY(::DeleteObject(mPalette));
    1:     mPalette = NULL;
    1:   }
    1: #endif
    1: 
    1:   // if we were in the middle of deferred window positioning then
    1:   // free the memory for the multiple-window position structure
    1:   if (mDeferredPositioner) {
    1:     VERIFY(::EndDeferWindowPos(mDeferredPositioner));
    1:     mDeferredPositioner = NULL;
    1:   }
    1: 
    1:   // release references to children, device context, toolkit, and app shell
    1:   nsBaseWidget::OnDestroy();
    1: 
    1:   // dispatch the event
    1:   if (!mIsDestroying) {
    1:     // dispatching of the event may cause the reference count to drop to 0
    1:     // and result in this object being destroyed. To avoid that, add a reference
    1:     // and then release it after dispatching the event
    1:     AddRef();
    1:     DispatchStandardEvent(NS_DESTROY);
    1:     Release();
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Move
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::OnMove(PRInt32 aX, PRInt32 aY)
    1: {
    1:   mBounds.x = aX;
    1:   mBounds.y = aY;
    1: 
    1:   nsGUIEvent event(PR_TRUE, NS_MOVE, this);
    1:   InitEvent(event);
    1:   event.refPoint.x = aX;
    1:   event.refPoint.y = aY;
    1: 
11297:   return DispatchWindowEvent(&event);
    1: }
    1: 
13857: static NS_DEFINE_CID(kRegionCID, NS_REGION_CID);
13857: 
25020: static void
25020: AddRECTToRegion(const RECT& aRect, nsIRegion* aRegion)
25020: {
25020:   aRegion->Union(aRect.left, aRect.top, aRect.right - aRect.left, aRect.bottom - aRect.top);
25020: }
25020: 
13857: static already_AddRefed<nsIRegion>
13857: ConvertHRGNToRegion(HRGN aRgn)
13857: {
13857:   NS_ASSERTION(aRgn, "Don't pass NULL region here");
13857: 
13857:   nsCOMPtr<nsIRegion> region = do_CreateInstance(kRegionCID);
13857:   if (!region)
13857:     return nsnull;
13857: 
13857:   region->Init();
13857: 
13857:   DWORD size = ::GetRegionData(aRgn, 0, NULL);
13857:   nsAutoTArray<PRUint8,100> buffer;
13857:   if (!buffer.SetLength(size))
13857:     return region.forget();
13857: 
13857:   RGNDATA* data = reinterpret_cast<RGNDATA*>(buffer.Elements());
13857:   if (!::GetRegionData(aRgn, size, data))
13857:     return region.forget();
13857: 
25020:   if (data->rdh.nCount > MAX_RECTS_IN_REGION) {
25020:     AddRECTToRegion(data->rdh.rcBound, region);
25020:     return region.forget();
25020:   }
25020: 
13857:   RECT* rects = reinterpret_cast<RECT*>(data->Buffer);
13857:   for (PRUint32 i = 0; i < data->rdh.nCount; ++i) {
13857:     RECT* r = rects + i;
25020:     AddRECTToRegion(*r, region);
13857:   }
13857: 
13857:   return region.forget();
13857: }
13857: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Paint
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::OnPaint(HDC aDC)
    1: {
    1:   PRBool result = PR_TRUE;
    1:   PAINTSTRUCT ps;
    1:   nsEventStatus eventStatus = nsEventStatus_eIgnore;
    1: 
    1: #ifdef MOZ_XUL
16601:   if (!aDC && (eTransparencyTransparent == mTransparencyMode))
    1:   {
    1:     // For layered translucent windows all drawing should go to memory DC and no
    1:     // WM_PAINT messages are normally generated. To support asynchronous painting
    1:     // we force generation of WM_PAINT messages by invalidating window areas with
    1:     // RedrawWindow, InvalidateRect or InvalidateRgn function calls.
    1:     // BeginPaint/EndPaint must be called to make Windows think that invalid area
    1:     // is painted. Otherwise it will continue sending the same message endlessly.
    1:     ::BeginPaint(mWnd, &ps);
    1:     ::EndPaint(mWnd, &ps);
    1: 
    1:     aDC = mMemoryDC;
    1:   }
    1: #endif
    1: 
    1:   mPainting = PR_TRUE;
    1: 
    1: #ifdef NS_DEBUG
    1:   HRGN debugPaintFlashRegion = NULL;
    1:   HDC debugPaintFlashDC = NULL;
    1: 
    1:   if (debug_WantPaintFlashing())
    1:   {
    1:     debugPaintFlashRegion = ::CreateRectRgn(0, 0, 0, 0);
    1:     ::GetUpdateRgn(mWnd, debugPaintFlashRegion, TRUE);
    1:     debugPaintFlashDC = ::GetDC(mWnd);
    1:   }
    1: #endif // NS_DEBUG
    1: 
    1:   HDC hDC = aDC ? aDC : (::BeginPaint(mWnd, &ps));
    1:   mPaintDC = hDC;
13857:   HRGN paintRgn = NULL;
    1: 
    1: #ifdef MOZ_XUL
16601:   if (aDC || (eTransparencyTransparent == mTransparencyMode)) {
    1: #else
    1:   if (aDC) {
    1: #endif
19822: 
13857:     RECT paintRect;
    1:     ::GetClientRect(mWnd, &paintRect);
13857:     paintRgn = ::CreateRectRgn(paintRect.left, paintRect.top, paintRect.right, paintRect.bottom);
    1:   }
    1:   else {
23335: #ifndef WINCE
13857:     paintRgn = ::CreateRectRgn(0, 0, 0, 0);
13857:     if (paintRgn != NULL) {
13857:       int result = GetRandomRgn(hDC, paintRgn, SYSRGN);
13857:       if (result == 1) {
13857:         POINT pt = {0,0};
13857:         ::MapWindowPoints(NULL, mWnd, &pt, 1);
13857:         ::OffsetRgn(paintRgn, pt.x, pt.y);
13857:       }
13857:     }
19822: #else
23335:     paintRgn = ::CreateRectRgn(ps.rcPaint.left, ps.rcPaint.top, 
23335:                                ps.rcPaint.right, ps.rcPaint.bottom);
19822: #endif
13857:   }
13857: 
13857:   nsCOMPtr<nsIRegion> paintRgnWin;
13857:   if (paintRgn) {
13857:     paintRgnWin = ConvertHRGNToRegion(paintRgn);
13857:     ::DeleteObject(paintRgn);
13857:   }
13857: 
13857:   if (paintRgnWin && !paintRgnWin->IsEmpty()) {
    1:     // call the event callback
    1:     if (mEventCallback)
    1:     {
    1:       nsPaintEvent event(PR_TRUE, NS_PAINT, this);
    1: 
    1:       InitEvent(event);
    1: 
13857:       event.region = paintRgnWin;
13857:       event.rect = nsnull;
13857:  
    1:       // Should probably pass in a real region here, using GetRandomRgn
    1:       // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/clipping_4q0e.asp
    1: 
    1: #ifdef NS_DEBUG
    1:       debug_DumpPaintEvent(stdout,
    1:                            this,
    1:                            &event,
    1:                            nsCAutoString("noname"),
    1:                            (PRInt32) mWnd);
    1: #endif // NS_DEBUG
    1: 
24972: #if defined(MOZ_XUL) && !defined(PAINT_USE_IMAGE_SURFACE)
  268:       nsRefPtr<gfxASurface> targetSurface;
16601:       if (eTransparencyTransparent == mTransparencyMode) {
20045:         if (mTransparentSurface == nsnull)
20045:           SetupTranslucentWindowMemoryBitmap(mTransparencyMode);
 9499:         targetSurface = mTransparentSurface;
  268:       } else {
  268:         targetSurface = new gfxWindowsSurface(hDC);
  268:       }
24972: #elif defined(PAINT_USE_IMAGE_SURFACE)
25862:       if (!gSharedSurfaceData) {
25862:         gSharedSurfaceSize.height = GetSystemMetrics(SM_CYSCREEN);
25862:         gSharedSurfaceSize.width = GetSystemMetrics(SM_CXSCREEN);
25862:         gSharedSurfaceData = (PRUint8*) malloc(gSharedSurfaceSize.width * gSharedSurfaceSize.height * 4);
25862:       }
25862: 
24972:       gfxIntSize surfaceSize(ps.rcPaint.right - ps.rcPaint.left,
24972:                              ps.rcPaint.bottom - ps.rcPaint.top);
25862: 
25862:       nsRefPtr<gfxImageSurface> targetSurface;
25862: 
25862:       if (!gSharedSurfaceData ||
25862:           surfaceSize.width > gSharedSurfaceSize.width ||
25862:           surfaceSize.height > gSharedSurfaceSize.height)
25862:       {
25862: #ifdef DEBUG_vladimir
25862:           RETAILMSG(1, (L"OnPaint: Paint area bigger than screen! Screen %dx%d, surface %dx%d, HWND %p\r\n", gSharedSurfaceSize.width, gSharedSurfaceSize.height, surfaceSize.width, surfaceSize.height, mWnd));
25862: #endif
25862: 
25862:           // allocate a new oversize surface; hopefully this will just be a one-time thing,
25862:           // and we should really fix whatever's doing it!
25862:           targetSurface = new gfxImageSurface(surfaceSize, gfxASurface::ImageFormatRGB24);
25862:       } else {
25862:           // don't use the shared surface directly; instead, create a new one
25862:           // that just reuses its buffer.
25862:           targetSurface = new gfxImageSurface(gSharedSurfaceData.get(),
25862:                                               surfaceSize,
25862:                                               surfaceSize.width * 4,
23691:                                               gfxASurface::ImageFormatRGB24);
25862:       }
25862: 
23691:       if (targetSurface && !targetSurface->CairoStatus()) {
23691:         targetSurface->SetDeviceOffset(gfxPoint(-ps.rcPaint.left, -ps.rcPaint.top));
23691:       }
24972: #else
24972:       nsRefPtr<gfxASurface> targetSurface = new gfxWindowsSurface(hDC);
24972: #endif
  268: 
    1:       nsRefPtr<gfxContext> thebesContext = new gfxContext(targetSurface);
21082:       thebesContext->SetFlag(gfxContext::FLAG_DESTINED_FOR_SCREEN);
    1: 
24972:       // don't need to double buffer with PAINT_USE_IMAGE_SURFACE;
24972:       // it's implicitly double buffered
24972: #if !defined(PAINT_USE_IMAGE_SURFACE)
23691: # if defined(MOZ_XUL)
16601:       if (eTransparencyGlass == mTransparencyMode && nsUXThemeData::sHaveCompositor) {
16601:         thebesContext->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
16601:       } else if (eTransparencyTransparent == mTransparencyMode) {
    1:         // If we're rendering with translucency, we're going to be
    1:         // rendering the whole window; make sure we clear it first
    1:         thebesContext->SetOperator(gfxContext::OPERATOR_CLEAR);
    1:         thebesContext->Paint();
    1:         thebesContext->SetOperator(gfxContext::OPERATOR_OVER);
16028:       } else {
    1:         // If we're not doing translucency, then double buffer
    1:         thebesContext->PushGroup(gfxASurface::CONTENT_COLOR);
    1:       }
23335: # else
23335:       // If we're not doing translucency, then double buffer
23335:       thebesContext->PushGroup(gfxASurface::CONTENT_COLOR);
    1: # endif
24972: #endif
    1: 
    1:       nsCOMPtr<nsIRenderingContext> rc;
    1:       nsresult rv = mContext->CreateRenderingContextInstance (*getter_AddRefs(rc));
    1:       if (NS_FAILED(rv)) {
    1:         NS_WARNING("CreateRenderingContextInstance failed");
    1:         return PR_FALSE;
    1:       }
    1: 
    1:       rv = rc->Init(mContext, thebesContext);
    1:       if (NS_FAILED(rv)) {
    1:         NS_WARNING("RC::Init failed");
    1:         return PR_FALSE;
    1:       }
    1: 
    1:       event.renderingContext = rc;
    1:       result = DispatchWindowEvent(&event, eventStatus);
    1:       event.renderingContext = nsnull;
    1: 
    1: #ifdef MOZ_XUL
16601:       if (eTransparencyTransparent == mTransparencyMode) {
    1:         // Data from offscreen drawing surface was copied to memory bitmap of transparent
    1:         // bitmap. Now it can be read from memory bitmap to apply alpha channel and after
    1:         // that displayed on the screen.
    1:         UpdateTranslucentWindow();
24972:       } else
24972: #endif
24972:       if (result) {
24972: #ifndef PAINT_USE_IMAGE_SURFACE
    1:         // Only update if DispatchWindowEvent returned TRUE; otherwise, nothing handled
    1:         // this, and we'll just end up painting with black.
    1:         thebesContext->PopGroupToSource();
    1:         thebesContext->SetOperator(gfxContext::OPERATOR_SOURCE);
    1:         thebesContext->Paint();
23691: #else
24972:         // Just blit this directly
24972:         BITMAPINFOHEADER bi;
24972:         memset(&bi, 0, sizeof(BITMAPINFOHEADER));
24972:         bi.biSize = sizeof(BITMAPINFOHEADER);
24972:         bi.biWidth = surfaceSize.width;
24972:         bi.biHeight = - surfaceSize.height;
24972:         bi.biPlanes = 1;
24972:         bi.biBitCount = 32;
24972:         bi.biCompression = BI_RGB;
24972: 
27336: #ifdef PAINT_USE_IMAGE_SURFACE_24BPP
27336:         // On Windows CE/Windows Mobile, 24bpp packed-pixel sources
27336:         // seem to be far faster to blit than 32bpp (see bug 484864).
27336:         // So, convert the bits to 24bpp by stripping out the unused
27336:         // alpha byte.  24bpp DIBs also have scanlines that are 4-byte
27336:         // aligned though, so that must be taken into account.
27336:         int srcstride = surfaceSize.width*4;
27336:         int dststride = surfaceSize.width*3;
27336:         dststride = (dststride + 3) & ~3;
27336: 
27336:         // Convert in place
27336:         for (int j = 0; j < surfaceSize.height; ++j) {
27336:           unsigned int *src = (unsigned int*) (targetSurface->Data() + j*srcstride);
27336:           unsigned int *dst = (unsigned int*) (targetSurface->Data() + j*dststride);
27336: 
27336:           // go 4 pixels at a time, since each 4 pixels
27336:           // turns into 3 DWORDs when converted into BGR:
27336:           // BGRx BGRx BGRx BGRx -> BGRB GRBG RBGR
27336:           //
27336:           // However, since we're dealing with little-endian ints, this is actually:
27336:           // xRGB xrgb xRGB xrgb -> bRGB GBrg rgbR
27336:           int width_left = surfaceSize.width;
27337:           while (width_left >= 4) {
27336:             unsigned int a = *src++;
27336:             unsigned int b = *src++;
27336:             unsigned int c = *src++;
27336:             unsigned int d = *src++;
27336: 
27336:             *dst++ =  (a & 0x00ffffff)        | (b << 24);
27336:             *dst++ = ((b & 0x00ffff00) >> 8)  | (c << 16);
27336:             *dst++ = ((c & 0x00ff0000) >> 16) | (d << 8);
27336: 
27336:             width_left -= 4;
27336:           }
27336: 
27336:           // then finish up whatever number of pixels are left,
27336:           // using bytes.
27336:           unsigned char *bsrc = (unsigned char*) src;
27336:           unsigned char *bdst = (unsigned char*) dst;
27336:           switch (width_left) {
27336:           case 3:
27336:             *bdst++ = *bsrc++;
27336:             *bdst++ = *bsrc++;
27336:             *bdst++ = *bsrc++;
27336:             bsrc++;
27336:           case 2:
27336:             *bdst++ = *bsrc++;
27336:             *bdst++ = *bsrc++;
27336:             *bdst++ = *bsrc++;
27336:             bsrc++;
27336:           case 1:
27336:             *bdst++ = *bsrc++;
27336:             *bdst++ = *bsrc++;
27336:             *bdst++ = *bsrc++;
27336:             bsrc++;
27336:           case 0:
27336:             break;
27336:           }
27336:         }
27336: 
27336:         bi.biBitCount = 24;
27336: #endif
27336: 
24972:         StretchDIBits(hDC,
24972:                       ps.rcPaint.left, ps.rcPaint.top,
24972:                       surfaceSize.width, surfaceSize.height,
24972:                       0, 0,
24972:                       surfaceSize.width, surfaceSize.height,
24972:                       targetSurface->Data(),
24972:                       (BITMAPINFO*) &bi,
24972:                       DIB_RGB_COLORS,
24972:                       SRCCOPY);
24972: #endif
24972:       }
    1:     }
    1:   }
    1: 
    1:   if (!aDC) {
    1:     ::EndPaint(mWnd, &ps);
    1:   }
    1: 
    1:   mPaintDC = nsnull;
    1: 
23335: #if defined(NS_DEBUG) && !defined(WINCE)
    1:   if (debug_WantPaintFlashing())
    1:   {
    1:     // Only flash paint events which have not ignored the paint message.
    1:     // Those that ignore the paint message aren't painting anything so there
    1:     // is only the overhead of the dispatching the paint event.
    1:     if (nsEventStatus_eIgnore != eventStatus) {
    1:       ::InvertRgn(debugPaintFlashDC, debugPaintFlashRegion);
    1:       PR_Sleep(PR_MillisecondsToInterval(30));
    1:       ::InvertRgn(debugPaintFlashDC, debugPaintFlashRegion);
    1:       PR_Sleep(PR_MillisecondsToInterval(30));
    1:     }
    1:     ::ReleaseDC(mWnd, debugPaintFlashDC);
    1:     ::DeleteObject(debugPaintFlashRegion);
    1:   }
23335: #endif // NS_DEBUG && !WINCE
    1: 
    1:   mPainting = PR_FALSE;
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Send a resize message to the listener
    1: //
    1: //-------------------------------------------------------------------------
23738: PRBool nsWindow::OnResize(nsIntRect &aWindowRect)
    1: {
    1:   // call the event callback
    1:   if (mEventCallback) {
    1:     nsSizeEvent event(PR_TRUE, NS_SIZE, this);
    1:     InitEvent(event);
    1:     event.windowSize = &aWindowRect;
    1:     RECT r;
    1:     if (::GetWindowRect(mWnd, &r)) {
    1:       event.mWinWidth  = PRInt32(r.right - r.left);
    1:       event.mWinHeight = PRInt32(r.bottom - r.top);
    1:     } else {
    1:       event.mWinWidth  = 0;
    1:       event.mWinHeight = 0;
    1:     }
11297:     return DispatchWindowEvent(&event);
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
12976: static PRBool IsTopLevelMouseExit(HWND aWnd)
12976: {
12976:   DWORD pos = ::GetMessagePos();
12976:   POINT mp;
12976:   mp.x = GET_X_LPARAM(pos);
12976:   mp.y = GET_Y_LPARAM(pos);
14640:   HWND mouseWnd = ::WindowFromPoint(mp);
14640: 
14640:   // GetTopLevelHWND will return a HWND for the window frame (which includes
14640:   // the non-client area).  If the mouse has moved into the non-client area,
14640:   // we should treat it as a top-level exit.
19016:   HWND mouseTopLevel = nsWindow::GetTopLevelHWND(mouseWnd);
14640:   if (mouseWnd == mouseTopLevel)
14640:     return PR_TRUE;
14640: 
12976:   return nsWindow::GetTopLevelHWND(aWnd) != mouseTopLevel;
12976: }
12976: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Deal with all sort of mouse event
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::DispatchMouseEvent(PRUint32 aEventType, WPARAM wParam,
    1:                                     LPARAM lParam, PRBool aIsContextMenuKey,
    1:                                     PRInt16 aButton)
    1: {
    1:   PRBool result = PR_FALSE;
    1: 
18401:   if (!mEventCallback) {
    1:     return result;
    1:   }
    1: 
23738:   nsIntPoint eventPoint;
    1:   eventPoint.x = GET_X_LPARAM(lParam);
    1:   eventPoint.y = GET_Y_LPARAM(lParam);
    1: 
    1:   nsMouseEvent event(PR_TRUE, aEventType, this, nsMouseEvent::eReal,
    1:                      aIsContextMenuKey
    1:                      ? nsMouseEvent::eContextMenuKey
    1:                      : nsMouseEvent::eNormal);
    1:   if (aEventType == NS_CONTEXTMENU && aIsContextMenuKey) {
23738:     nsIntPoint zero(0, 0);
    1:     InitEvent(event, &zero);
    1:   } else {
    1:     InitEvent(event, &eventPoint);
    1:   }
    1: 
    1:   event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
    1:   event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
    1:   event.isMeta    = PR_FALSE;
    1:   event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
    1:   event.button    = aButton;
    1: 
25183:   nsIntPoint mpScreen = eventPoint + WidgetToScreenOffset();
    1: 
    1:   // Suppress mouse moves caused by widget creation
    1:   if (aEventType == NS_MOUSE_MOVE) 
    1:   {
    1:     if ((gLastMouseMovePoint.x == mpScreen.x) && (gLastMouseMovePoint.y == mpScreen.y))
    1:       return result;
    1:     gLastMouseMovePoint.x = mpScreen.x;
    1:     gLastMouseMovePoint.y = mpScreen.y;
    1:   }
    1: 
    1:   PRBool insideMovementThreshold = (abs(gLastMousePoint.x - eventPoint.x) < (short)::GetSystemMetrics(SM_CXDOUBLECLK)) &&
    1:                                    (abs(gLastMousePoint.y - eventPoint.y) < (short)::GetSystemMetrics(SM_CYDOUBLECLK));
    1: 
    1:   BYTE eventButton;
    1:   switch (aButton) {
    1:     case nsMouseEvent::eLeftButton:
    1:       eventButton = VK_LBUTTON;
    1:       break;
    1:     case nsMouseEvent::eMiddleButton:
    1:       eventButton = VK_MBUTTON;
    1:       break;
    1:     case nsMouseEvent::eRightButton:
    1:       eventButton = VK_RBUTTON;
    1:       break;
    1:     default:
    1:       eventButton = 0;
    1:       break;
    1:   }
    1: 
    1:   // Doubleclicks are used to set the click count, then changed to mousedowns
    1:   // We're going to time double-clicks from mouse *up* to next mouse *down*
    1:   LONG curMsgTime = ::GetMessageTime();
    1: 
    1:   if (aEventType == NS_MOUSE_DOUBLECLICK) {
    1:     event.message = NS_MOUSE_BUTTON_DOWN;
    1:     event.button = aButton;
    1:     gLastClickCount = 2;
    1:   }
    1:   else if (aEventType == NS_MOUSE_BUTTON_UP) {
    1:     // remember when this happened for the next mouse down
    1:     gLastMousePoint.x = eventPoint.x;
    1:     gLastMousePoint.y = eventPoint.y;
    1:     gLastMouseButton = eventButton;
    1:   }
    1:   else if (aEventType == NS_MOUSE_BUTTON_DOWN) {
    1:     // now look to see if we want to convert this to a double- or triple-click
    1: 
    1: #ifdef NS_DEBUG_XX
    1:     printf("Msg: %d Last: %d Dif: %d Max %d\n", curMsgTime, gLastMouseDownTime, curMsgTime-gLastMouseDownTime, ::GetDoubleClickTime());
    1:     printf("Mouse %d %d\n", abs(gLastMousePoint.x - mp.x), abs(gLastMousePoint.y - mp.y));
    1: #endif
    1:     if (((curMsgTime - gLastMouseDownTime) < (LONG)::GetDoubleClickTime()) && insideMovementThreshold &&
    1:         eventButton == gLastMouseButton) {
    1:       gLastClickCount ++;
    1:     } else {
    1:       // reset the click count, to count *this* click
    1:       gLastClickCount = 1;
    1:     }
    1:     // Set last Click time on MouseDown only
    1:     gLastMouseDownTime = curMsgTime;
    1:   }
    1:   else if (aEventType == NS_MOUSE_MOVE && !insideMovementThreshold) {
    1:     gLastClickCount = 0;
    1:   }
12976:   else if (aEventType == NS_MOUSE_EXIT) {
12976:     event.exit = IsTopLevelMouseExit(mWnd) ? nsMouseEvent::eTopLevel : nsMouseEvent::eChild;
12976:   }
    1:   event.clickCount = gLastClickCount;
    1: 
    1: #ifdef NS_DEBUG_XX
    1:   printf("Msg Time: %d Click Count: %d\n", curMsgTime, event.clickCount);
    1: #endif
    1: 
    1:   nsPluginEvent pluginEvent;
    1: 
    1:   switch (aEventType)
    1:   {
    1:     case NS_MOUSE_BUTTON_DOWN:
    1:       switch (aButton) {
    1:         case nsMouseEvent::eLeftButton:
    1:           pluginEvent.event = WM_LBUTTONDOWN;
    1:           break;
    1:         case nsMouseEvent::eMiddleButton:
    1:           pluginEvent.event = WM_MBUTTONDOWN;
    1:           break;
    1:         case nsMouseEvent::eRightButton:
    1:           pluginEvent.event = WM_RBUTTONDOWN;
    1:           break;
    1:         default:
    1:           break;
    1:       }
    1:       break;
    1:     case NS_MOUSE_BUTTON_UP:
    1:       switch (aButton) {
    1:         case nsMouseEvent::eLeftButton:
    1:           pluginEvent.event = WM_LBUTTONUP;
    1:           break;
    1:         case nsMouseEvent::eMiddleButton:
    1:           pluginEvent.event = WM_MBUTTONUP;
    1:           break;
    1:         case nsMouseEvent::eRightButton:
    1:           pluginEvent.event = WM_RBUTTONUP;
    1:           break;
    1:         default:
    1:           break;
    1:       }
    1:       break;
    1:     case NS_MOUSE_DOUBLECLICK:
    1:       switch (aButton) {
    1:         case nsMouseEvent::eLeftButton:
    1:           pluginEvent.event = WM_LBUTTONDBLCLK;
    1:           break;
    1:         case nsMouseEvent::eMiddleButton:
    1:           pluginEvent.event = WM_MBUTTONDBLCLK;
    1:           break;
    1:         case nsMouseEvent::eRightButton:
    1:           pluginEvent.event = WM_RBUTTONDBLCLK;
    1:           break;
    1:         default:
    1:           break;
    1:       }
    1:       break;
    1:     case NS_MOUSE_MOVE:
    1:       pluginEvent.event = WM_MOUSEMOVE;
    1:       break;
    1:     default:
    1:       pluginEvent.event = WM_NULL;
    1:       break;
    1:   }
    1: 
    1:   pluginEvent.wParam = wParam;     // plugins NEED raw OS event flags!
    1:   pluginEvent.lParam = lParam;
    1: 
    1:   event.nativeMsg = (void *)&pluginEvent;
    1: 
    1:   // call the event callback
    1:   if (nsnull != mEventCallback) {
    1:     if (nsToolkit::gMouseTrailer)
    1:       nsToolkit::gMouseTrailer->Disable();
    1:     if (aEventType == NS_MOUSE_MOVE) {
    1:       if (nsToolkit::gMouseTrailer && !mIsInMouseCapture) {
    1:         nsToolkit::gMouseTrailer->SetMouseTrailerWindow(mWnd);
    1:       }
23738:       nsIntRect rect;
    1:       GetBounds(rect);
    1:       rect.x = 0;
    1:       rect.y = 0;
    1: 
    1:       if (rect.Contains(event.refPoint)) {
    1:         if (gCurrentWindow == NULL || gCurrentWindow != this) {
    1:           if ((nsnull != gCurrentWindow) && (!gCurrentWindow->mIsDestroying)) {
    1:             LPARAM pos = gCurrentWindow->lParamToClient(lParamToScreen(lParam));
    1:             gCurrentWindow->DispatchMouseEvent(NS_MOUSE_EXIT, wParam, pos);
    1:           }
    1:           gCurrentWindow = this;
    1:           if (!mIsDestroying) {
    1:             LPARAM pos = gCurrentWindow->lParamToClient(lParamToScreen(lParam));
    1:             gCurrentWindow->DispatchMouseEvent(NS_MOUSE_ENTER, wParam, pos);
    1:           }
    1:         }
    1:       }
    1:     } else if (aEventType == NS_MOUSE_EXIT) {
    1:       if (gCurrentWindow == this) {
    1:         gCurrentWindow = nsnull;
    1:       }
    1:     }
    1: 
    1:     result = DispatchWindowEvent(&event);
    1: 
    1:     if (nsToolkit::gMouseTrailer)
    1:       nsToolkit::gMouseTrailer->Enable();
    1: 
    1:     // Release the widget with NS_IF_RELEASE() just in case
    1:     // the context menu key code in nsEventListenerManager::HandleEvent()
    1:     // released it already.
    1:     return result;
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Deal with accessibile event
    1: //
    1: //-------------------------------------------------------------------------
    1: #ifdef ACCESSIBILITY
23738: PRBool nsWindow::DispatchAccessibleEvent(PRUint32 aEventType, nsIAccessible** aAcc, nsIntPoint* aPoint)
    1: {
    1:   PRBool result = PR_FALSE;
    1: 
    1:   if (nsnull == mEventCallback) {
    1:     return result;
    1:   }
    1: 
    1:   *aAcc = nsnull;
    1: 
    1:   nsAccessibleEvent event(PR_TRUE, aEventType, this);
    1:   InitEvent(event, aPoint);
    1: 
    1:   event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
    1:   event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
    1:   event.isMeta    = PR_FALSE;
    1:   event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
    1:   event.accessible = nsnull;
    1: 
    1:   result = DispatchWindowEvent(&event);
    1: 
    1:   // if the event returned an accesssible get it.
    1:   if (event.accessible)
    1:     *aAcc = event.accessible;
    1: 
    1:   return result;
    1: }
    1: #endif
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Deal with focus messages
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::DispatchFocus(PRUint32 aEventType, PRBool isMozWindowTakingFocus)
    1: {
    1:   // call the event callback
    1:   if (mEventCallback) {
    1:     nsFocusEvent event(PR_TRUE, aEventType, this);
    1:     InitEvent(event);
    1: 
    1:     //focus and blur event should go to their base widget loc, not current mouse pos
    1:     event.refPoint.x = 0;
    1:     event.refPoint.y = 0;
    1: 
    1:     event.isMozWindowTakingFocus = isMozWindowTakingFocus;
    1: 
    1:     nsPluginEvent pluginEvent;
    1: 
    1:     switch (aEventType)//~~~
    1:     {
    1:       case NS_GOTFOCUS:
    1:         pluginEvent.event = WM_SETFOCUS;
    1:         break;
    1:       case NS_LOSTFOCUS:
    1:         pluginEvent.event = WM_KILLFOCUS;
    1:         break;
    1:       case NS_PLUGIN_ACTIVATE:
    1:         pluginEvent.event = WM_KILLFOCUS;
    1:         break;
    1:       default:
    1:         break;
    1:     }
    1: 
    1:     event.nativeMsg = (void *)&pluginEvent;
    1: 
11297:     return DispatchWindowEvent(&event);
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Deal with scrollbar messages (actually implemented only in nsScrollbar)
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::OnScroll(UINT scrollCode, int cPos)
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Return the brush used to paint the background of this control
    1: //
    1: //-------------------------------------------------------------------------
    1: HBRUSH nsWindow::OnControlColor()
    1: {
    1:   return mBrush;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Deal with all sort of mouse event
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool ChildWindow::DispatchMouseEvent(PRUint32 aEventType, WPARAM wParam, LPARAM lParam,
    1:                                        PRBool aIsContextMenuKey, PRInt16 aButton)
    1: {
    1:   PRBool result = PR_FALSE;
    1: 
18401:   if (nsnull == mEventCallback) {
    1:     return result;
    1:   }
    1: 
    1:   switch (aEventType) {
    1:     case NS_MOUSE_BUTTON_DOWN:
    1:       CaptureMouse(PR_TRUE);
    1:       break;
    1: 
    1:     // NS_MOUSE_MOVE and NS_MOUSE_EXIT are here because we need to make sure capture flag
    1:     // isn't left on after a drag where we wouldn't see a button up message (see bug 324131).
    1:     case NS_MOUSE_BUTTON_UP:
    1:     case NS_MOUSE_MOVE:
    1:     case NS_MOUSE_EXIT:
    1:       if (!(wParam & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON)) && mIsInMouseCapture)
    1:         CaptureMouse(PR_FALSE);
    1:       break;
    1: 
    1:     default:
    1:       break;
    1: 
    1:   } // switch
    1: 
    1:   return nsWindow::DispatchMouseEvent(aEventType, wParam, lParam,
    1:                                       aIsContextMenuKey, aButton);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // return the style for a child nsWindow
    1: //
    1: //-------------------------------------------------------------------------
    1: DWORD ChildWindow::WindowStyle()
    1: {
19016:   DWORD style = WS_CLIPCHILDREN | nsWindow::WindowStyle();
19016:   if (!(style & WS_POPUP))
19016:     style |= WS_CHILD; // WS_POPUP and WS_CHILD are mutually exclusive.
19016:   VERIFY_WINDOW_STYLE(style);
19016:   return style;
    1: }
    1: 
    1: NS_METHOD nsWindow::SetTitle(const nsAString& aTitle)
    1: {
    1:   const nsString& strTitle = PromiseFlatString(aTitle);
    1:   ::SendMessageW(mWnd, WM_SETTEXT, (WPARAM)0, (LPARAM)(LPCWSTR)strTitle.get());
    1:   return NS_OK;
    1: }
    1: 
    1: NS_METHOD nsWindow::SetIcon(const nsAString& aIconSpec) 
    1: {
23335: #ifndef WINCE
    1:   // Assume the given string is a local identifier for an icon file.
    1: 
    1:   nsCOMPtr<nsILocalFile> iconFile;
    1:   ResolveIconName(aIconSpec, NS_LITERAL_STRING(".ico"),
    1:                   getter_AddRefs(iconFile));
    1:   if (!iconFile)
    1:     return NS_OK; // not an error if icon is not found
    1: 
    1:   nsAutoString iconPath;
    1:   iconFile->GetPath(iconPath);
    1: 
    1:   // XXX this should use MZLU (see bug 239279)
    1: 
    1:   ::SetLastError(0);
    1: 
    1:   HICON bigIcon = (HICON)::LoadImageW(NULL,
    1:                                       (LPCWSTR)iconPath.get(),
    1:                                       IMAGE_ICON,
    1:                                       ::GetSystemMetrics(SM_CXICON),
    1:                                       ::GetSystemMetrics(SM_CYICON),
    1:                                       LR_LOADFROMFILE );
    1:   HICON smallIcon = (HICON)::LoadImageW(NULL,
    1:                                         (LPCWSTR)iconPath.get(),
    1:                                         IMAGE_ICON,
    1:                                         ::GetSystemMetrics(SM_CXSMICON),
    1:                                         ::GetSystemMetrics(SM_CYSMICON),
    1:                                         LR_LOADFROMFILE );
    1: 
    1:   if (bigIcon) {
    1:     HICON icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM)bigIcon);
    1:     if (icon)
    1:       ::DestroyIcon(icon);
    1:   }
    1: #ifdef DEBUG_SetIcon
    1:   else {
    1:     NS_LossyConvertUTF16toASCII cPath(iconPath);
    1:     printf( "\nIcon load error; icon=%s, rc=0x%08X\n\n", cPath.get(), ::GetLastError() );
    1:   }
    1: #endif
    1:   if (smallIcon) {
    1:     HICON icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)smallIcon);
    1:     if (icon)
    1:       ::DestroyIcon(icon);
    1:   }
    1: #ifdef DEBUG_SetIcon
    1:   else {
    1:     NS_LossyConvertUTF16toASCII cPath(iconPath);
    1:     printf( "\nSmall icon load error; icon=%s, rc=0x%08X\n\n", cPath.get(), ::GetLastError() );
    1:   }
    1: #endif
23335: #endif // WINCE
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: PRBool nsWindow::AutoErase()
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
25732: static PRBool ShouldDrawCompositionStringOurselves()
25732: {
25732: #ifdef WINCE
25732:   // We are not sure we should use native IME behavior...
25732:   return PR_TRUE;
25732: #else
25732:   return gKbdLayout.ShouldDrawCompositionStringOurselves();
25732: #endif
25732: }
25732: 
25732: PRBool
25732: nsWindow::GetCharacterRectOfSelectedTextAt(PRInt32 aOffset,
25732:                                            nsIntRect &aCharRect)
25732: {
25732:   nsIntPoint point(0, 0);
25732: 
25732:   nsQueryContentEvent selection(PR_TRUE, NS_QUERY_SELECTED_TEXT, this);
25732:   InitEvent(selection, &point);
25732:   DispatchWindowEvent(&selection);
25732:   if (!selection.mSucceeded)
25732:     return PR_FALSE;
25732: 
25732:   PRUint32 offset = selection.mReply.mOffset + aOffset;
25732:   PRBool useCaretRect = selection.mReply.mString.IsEmpty();
25732:   if (useCaretRect && ShouldDrawCompositionStringOurselves() &&
25732:       sIMEIsComposing && sIMECompUnicode && !sIMECompUnicode->IsEmpty()) {
25732:     // There is not a normal selection, but we have composition string.
25732:     // XXX mnakano - Should we implement NS_QUERY_IME_SELECTED_TEXT?
25732:     useCaretRect = PR_FALSE;
25732:     if (sIMECursorPosition != NO_IME_CARET) {
25732:       PRUint32 cursorPosition =
25732:         PR_MIN(PRUint32(sIMECursorPosition), sIMECompUnicode->Length());
25732:       offset -= cursorPosition;
25732:       NS_ASSERTION(offset >= 0, "offset is negative!");
25732:     }
25732:   }
25732: 
25732:   nsIntRect r;
25732:   if (!useCaretRect) {
25732:     nsQueryContentEvent charRect(PR_TRUE, NS_QUERY_TEXT_RECT, this);
25732:     charRect.InitForQueryTextRect(offset, 1);
25732:     InitEvent(charRect, &point);
25732:     DispatchWindowEvent(&charRect);
25732:     if (charRect.mSucceeded)
25732:       aCharRect = charRect.mReply.mRect;
25732:     else
25732:       useCaretRect = PR_TRUE;
25732:   }
25732: 
25732:   return useCaretRect ? GetCaretRect(aCharRect) : PR_TRUE;
25732: }
25732: 
25732: PRBool
25732: nsWindow::GetCaretRect(nsIntRect &aCaretRect)
25732: {
25732:   nsIntPoint point(0, 0);
25732: 
25732:   nsQueryContentEvent selection(PR_TRUE, NS_QUERY_SELECTED_TEXT, this);
25732:   InitEvent(selection, &point);
25732:   DispatchWindowEvent(&selection);
25732:   if (!selection.mSucceeded)
25732:     return PR_FALSE;
25732: 
25732:   PRUint32 offset = selection.mReply.mOffset;
25732: 
25732:   nsQueryContentEvent caretRect(PR_TRUE, NS_QUERY_CARET_RECT, this);
25732:   caretRect.InitForQueryCaretRect(offset);
25732:   InitEvent(caretRect, &point);
25732:   DispatchWindowEvent(&caretRect);
25732:   if (!caretRect.mSucceeded)
25732:     return PR_FALSE;
25732:   aCaretRect = caretRect.mReply.mRect;
25732:   return PR_TRUE;
25732: }
25732: 
25732: PRBool
25732: nsWindow::SetIMERelatedWindowsPos(HIMC aIMEContext)
25732: {
25732:   nsIntRect r;
25732:   // Get first character rect of current a normal selected text or a composing
25732:   // string.
25732:   PRBool ret = GetCharacterRectOfSelectedTextAt(0, r);
25732:   NS_ENSURE_TRUE(ret, PR_FALSE);
25732:   nsWindow* toplevelWindow = GetTopLevelWindow(PR_FALSE);
25732:   nsIntRect firstSelectedCharRect;
25732:   ResolveIMECaretPos(toplevelWindow, r, this, firstSelectedCharRect);
25732: 
25732:   // Set native caret size/position to our caret. Some IMEs honor it. E.g.,
25732:   // "Intelligent ABC" (Simplified Chinese) and "MS PinYin 3.0" (Simplified
25732:   // Chinese) on XP.
25732:   nsIntRect caretRect(firstSelectedCharRect);
25732:   if (GetCaretRect(r)) {
25732:     ResolveIMECaretPos(toplevelWindow, r, this, caretRect);
25732:   } else {
25732:     NS_WARNING("failed to get caret rect");
25732:     caretRect.width = 1;
25732:   }
25732:   if (!sIMENativeCaretIsCreated) {
25732:     sIMENativeCaretIsCreated =
25732:       ::CreateCaret(mWnd, nsnull, caretRect.width, caretRect.height);
25732:   }
25732:   ::SetCaretPos(caretRect.x, caretRect.y);
25732: 
25732:   if (ShouldDrawCompositionStringOurselves()) {
25732:     // Get a rect of first character in current target in composition string.
25732:     if (sIMEIsComposing && sIMECompUnicode && !sIMECompUnicode->IsEmpty()) {
25732:       // If there are no targetted selection, we should use it's first character
25732:       // rect instead.
25732:       PRInt32 offset = 0;
25732:       for (int i = 0; i < sIMEAttributeArrayLength; i++) {
25732:         if (sIMEAttributeArray[i] == ATTR_TARGET_NOTCONVERTED ||
25732:             sIMEAttributeArray[i] == ATTR_TARGET_CONVERTED) {
25732:           offset = i;
25732:           break;
25732:         }
25732:       }
25732:       ret = GetCharacterRectOfSelectedTextAt(offset, r);
25732:       NS_ENSURE_TRUE(ret, PR_FALSE);
25732:     } else {
25732:       // If there are no composition string, we should use a first character rect.
25732:       ret = GetCharacterRectOfSelectedTextAt(0, r);
25732:       NS_ENSURE_TRUE(ret, PR_FALSE);
25732:     }
25732:     nsIntRect firstTargetCharRect;
25732:     ResolveIMECaretPos(toplevelWindow, r, this, firstTargetCharRect);
25732: 
25732:     // Move the candidate window to first character position of the target.
25732:     CANDIDATEFORM candForm;
25732:     candForm.dwIndex = 0;
25732:     candForm.dwStyle = CFS_EXCLUDE;
25732:     candForm.ptCurrentPos.x = firstTargetCharRect.x;
25732:     candForm.ptCurrentPos.y = firstTargetCharRect.y;
25732:     candForm.rcArea.right = candForm.rcArea.left = candForm.ptCurrentPos.x;
25732:     candForm.rcArea.top = candForm.ptCurrentPos.y;
25732:     candForm.rcArea.bottom = candForm.ptCurrentPos.y + firstTargetCharRect.height;
25732:     ::ImmSetCandidateWindow(aIMEContext, &candForm);
25732:   } else {
25732:     // Move the composition window to caret position (if selected some
25732:     // characters, we should use first character rect of them).
25732:     // And in this mode, IME adjusts the candidate window position
25732:     // automatically. So, we don't need to set it.
25732:     COMPOSITIONFORM compForm;
25732:     compForm.dwStyle = CFS_POINT;
25732:     compForm.ptCurrentPos.x = firstSelectedCharRect.x;
25732:     compForm.ptCurrentPos.y = firstSelectedCharRect.y;
25732:     ::ImmSetCompositionWindow(aIMEContext, &compForm);
25732:   }
25732: 
25732:   return PR_TRUE;
25732: }
    1: 
    1: void
    1: nsWindow::HandleTextEvent(HIMC hIMEContext, PRBool aCheckAttr)
    1: {
    1:   NS_ASSERTION(sIMECompUnicode, "sIMECompUnicode is null");
    1:   NS_ASSERTION(sIMEIsComposing, "conflict state");
    1: 
    1:   if (!sIMECompUnicode)
    1:     return;
    1: 
25732:   // If we don't need to draw composition string ourselves and this is not
25732:   // commit event (i.e., under composing), we don't need to fire text event
25732:   // during composing.
25732:   if (aCheckAttr && !ShouldDrawCompositionStringOurselves()) {
25732:     // But we need to adjust composition window pos and native caret pos, here.
25732:     SetIMERelatedWindowsPos(hIMEContext);
25732:     return;
25732:   }
25732: 
    1:   nsTextEvent event(PR_TRUE, NS_TEXT_TEXT, this);
23738:   nsIntPoint point(0, 0);
    1: 
    1:   InitEvent(event, &point);
    1: 
    1:   if (aCheckAttr) {
    1:     GetTextRangeList(&(event.rangeCount),&(event.rangeArray));
    1:   } else {
    1:     event.rangeCount = 0;
    1:     event.rangeArray = nsnull;
    1:   }
    1: 
    1:   event.theText = sIMECompUnicode->get();
    1:   event.isShift = mIsShiftDown;
    1:   event.isControl = mIsControlDown;
    1:   event.isMeta = PR_FALSE;
    1:   event.isAlt = mIsAltDown;
    1: 
    1:   DispatchWindowEvent(&event);
    1: 
    1:   if (event.rangeArray)
    1:     delete [] event.rangeArray;
    1: 
    1:   //
    1:   // Post process event
    1:   //
25732: 
25732:   SetIMERelatedWindowsPos(hIMEContext);
25732: 
    1:   if (event.theReply.mCursorPosition.width || event.theReply.mCursorPosition.height)
    1:   {
23738:     nsIntRect cursorPosition;
16603:     ResolveIMECaretPos(event.theReply.mReferenceWidget,
16603:                        event.theReply.mCursorPosition,
16603:                        this, cursorPosition);
    1: 
    1:     // Record previous composing char position
    1:     // The cursor is always on the right char before it, but not necessarily on the
    1:     // left of next char, as what happens in wrapping.
22879:     if (sIMECursorPosition > 0 && sIMECompCharPos &&
    1:         sIMECursorPosition < IME_MAX_CHAR_POS) {
    1:       sIMECompCharPos[sIMECursorPosition-1].right = cursorPosition.x;
    1:       sIMECompCharPos[sIMECursorPosition-1].top = cursorPosition.y;
    1:       sIMECompCharPos[sIMECursorPosition-1].bottom = cursorPosition.YMost();
    1:       if (sIMECompCharPos[sIMECursorPosition-1].top != cursorPosition.y) {
    1:         // wrapping, invalidate left position
    1:         sIMECompCharPos[sIMECursorPosition-1].left = -1;
    1:       }
    1:       sIMECompCharPos[sIMECursorPosition].left = cursorPosition.x;
    1:       sIMECompCharPos[sIMECursorPosition].top = cursorPosition.y;
    1:       sIMECompCharPos[sIMECursorPosition].bottom = cursorPosition.YMost();
    1:     }
    1:   } else {
    1:     // for some reason we don't know yet, theReply may contain invalid result
    1:     // need more debugging in nsCaret to find out the reason
    1:     // the best we can do now is to ignore the invalid result
    1:   }
    1: }
    1: 
25732: void
    1: nsWindow::HandleStartComposition(HIMC hIMEContext)
    1: {
22788:   NS_PRECONDITION(mIMEEnabled != nsIWidget::IME_STATUS_PLUGIN,
22788:     "HandleStartComposition should not be called when a plug-in has focus");
22788: 
    1:   // ATOK send the messages following order at starting composition.
    1:   // 1. WM_IME_COMPOSITION
    1:   // 2. WM_IME_STARTCOMPOSITION
    1:   // We call this function at both step #1 and #2.
    1:   // However, the composition start event should occur only once.
    1:   if (sIMEIsComposing)
25732:     return;
    1: 
    1:   nsCompositionEvent event(PR_TRUE, NS_COMPOSITION_START, this);
23738:   nsIntPoint point(0, 0);
    1:   InitEvent(event, &point);
    1:   DispatchWindowEvent(&event);
    1: 
    1:   //
    1:   // Post process event
    1:   //
25732: 
25732:   SetIMERelatedWindowsPos(hIMEContext);
25732: 
    1:   if (event.theReply.mCursorPosition.width || event.theReply.mCursorPosition.height)
    1:   {
23738:     nsIntRect cursorPosition;
16603:     ResolveIMECaretPos(event.theReply.mReferenceWidget,
16603:                        event.theReply.mCursorPosition,
16603:                        this, cursorPosition);
    1: 
    1:     sIMECompCharPos = (RECT*)PR_MALLOC(IME_MAX_CHAR_POS*sizeof(RECT));
    1:     if (sIMECompCharPos) {
    1:       memset(sIMECompCharPos, -1, sizeof(RECT)*IME_MAX_CHAR_POS);
    1:       sIMECompCharPos[0].left = cursorPosition.x;
    1:       sIMECompCharPos[0].top = cursorPosition.y;
    1:       sIMECompCharPos[0].bottom = cursorPosition.YMost();
    1:     }
    1:   } else {
    1:     // for some reason we don't know yet, theReply may contain invalid result
    1:     // need more debugging in nsCaret to find out the reason
    1:     // the best we can do now is to ignore the invalid result
    1:   }
    1: 
    1:   if (!sIMECompUnicode)
21031:     sIMECompUnicode = new nsString();
    1:   sIMEIsComposing = PR_TRUE;
    1: }
    1: 
    1: void
    1: nsWindow::HandleEndComposition(void)
    1: {
    1:   if (!sIMEIsComposing)
    1:     return;
    1: 
22788:   if (mIMEEnabled == nsIWidget::IME_STATUS_PLUGIN) {
22788:     sIMEIsComposing = PR_FALSE;
22788:     return;
22788:   }
22788: 
    1:   nsCompositionEvent event(PR_TRUE, NS_COMPOSITION_END, this);
23738:   nsIntPoint point(0, 0);
    1: 
25732:   if (sIMENativeCaretIsCreated) {
25732:     ::DestroyCaret();
25732:     sIMENativeCaretIsCreated = PR_FALSE;
    1:   }
    1: 
    1:   InitEvent(event,&point);
    1:   DispatchWindowEvent(&event);
    1:   PR_FREEIF(sIMECompCharPos);
    1:   sIMECompCharPos = nsnull;
    1:   sIMEIsComposing = PR_FALSE;
    1: }
    1: 
    1: static PRUint32 PlatformToNSAttr(PRUint8 aAttr)
    1: {
    1:   switch (aAttr)
    1:   {
    1:     case ATTR_INPUT_ERROR:
    1:     // case ATTR_FIXEDCONVERTED:
    1:     case ATTR_INPUT:
    1:       return NS_TEXTRANGE_RAWINPUT;
    1:     case ATTR_CONVERTED:
    1:       return NS_TEXTRANGE_CONVERTEDTEXT;
    1:     case ATTR_TARGET_NOTCONVERTED:
    1:       return NS_TEXTRANGE_SELECTEDRAWTEXT;
    1:     case ATTR_TARGET_CONVERTED:
    1:       return NS_TEXTRANGE_SELECTEDCONVERTEDTEXT;
    1:     default:
    1:       NS_ASSERTION(PR_FALSE, "unknown attribute");
    1:       return NS_TEXTRANGE_CARETPOSITION;
    1:   }
    1: }
22879: 
22879: 
    1: void
22879: nsWindow::GetTextRangeList(PRUint32* aListLength,
22879:                            nsTextRangeArray* textRangeListResult)
    1: {
    1:   NS_ASSERTION(sIMECompUnicode, "sIMECompUnicode is null");
25732:   // Sogou (Simplified Chinese IME) returns contradictory values: The cursor
25732:   // position is actual cursor position. However, other values (composition
25732:   // string and attributes) are empty. So, if you remove following assertion,
25732:   // be careful.
25732:   NS_ASSERTION(ShouldDrawCompositionStringOurselves(),
25732:     "GetTextRangeList is called when we don't need to fire text event");
    1: 
    1:   if (!sIMECompUnicode)
    1:     return;
    1: 
    1:   long maxlen = sIMECompUnicode->Length();
    1:   long cursor = sIMECursorPosition;
21031:   NS_ASSERTION(cursor <= maxlen, "wrong cursor position");
    1:   if (cursor > maxlen)
    1:     cursor = maxlen;
    1: 
    1:   if (sIMECompClauseArrayLength == 0) {
22879:     // Some IMEs don't return clause array information, then, we assume that
22879:     // all characters in the composition string are in one clause.
22879:     *aListLength = 1;
22879:     // need one more room for caret
22879:     *textRangeListResult = new nsTextRange[*aListLength + 1];
    1:     (*textRangeListResult)[0].mStartOffset = 0;
21031:     (*textRangeListResult)[0].mEndOffset = maxlen;
    1:     (*textRangeListResult)[0].mRangeType = NS_TEXTRANGE_RAWINPUT;
    1:   } else {
22879:     *aListLength = sIMECompClauseArrayLength - 1;
22879: 
22879:     // need one more room for caret
22879:     *textRangeListResult = new nsTextRange[*aListLength + 1];
22879: 
22879:     // iterate over the attributes
    1:     int lastOffset = 0;
24972:     for (unsigned int i = 0; i < *aListLength; i++) {
22879:       long current = sIMECompClauseArray[i + 1];
    1:       NS_ASSERTION(current <= maxlen, "wrong offset");
    1:       if(current > maxlen)
    1:         current = maxlen;
    1: 
    1:       (*textRangeListResult)[i].mRangeType = 
    1:         PlatformToNSAttr(sIMEAttributeArray[lastOffset]);
    1:       (*textRangeListResult)[i].mStartOffset = lastOffset;
    1:       (*textRangeListResult)[i].mEndOffset = current;
    1: 
    1:       lastOffset = current;
    1:     } // for
    1:   } // if else
22879: 
22879:   if (cursor == NO_IME_CARET)
22879:     return;
22879: 
22879:   (*textRangeListResult)[*aListLength].mStartOffset = cursor;
22879:   (*textRangeListResult)[*aListLength].mEndOffset = cursor;
22879:   (*textRangeListResult)[*aListLength].mRangeType = NS_TEXTRANGE_CARETPOSITION;
22879:   ++(*aListLength);
    1: }
    1: 
    1: 
    1: //==========================================================================
22411: BOOL nsWindow::OnInputLangChange(HKL aHKL)
    1: {
    1: #ifdef KE_DEBUG
    1:   printf("OnInputLanguageChange\n");
    1: #endif
25732:   ResetInputState();
25732: 
25732:   if (sIMEIsComposing) {
25732:     HandleEndComposition();
25732:   }
25732: 
23335: #ifndef WINCE
22411:   gKbdLayout.LoadLayout(aHKL);
23335: #endif
    1: 
    1:   return PR_FALSE;   // always pass to child window
    1: }
    1: //==========================================================================
22788: BOOL nsWindow::OnIMEChar(wchar_t uniChar, LPARAM aKeyState)
    1: {
    1: #ifdef DEBUG_IME
    1:   printf("OnIMEChar\n");
    1: #endif
25732: 
25732:   // We don't need to fire any text events from here. This method will be
25732:   // called when the composition string of the current IME is not drawn by us
25732:   // and some characters are committed. In that case, the committed string was
25732:   // processed in nsWindow::OnIMEComposition already.
    1: 
    1:   // We need to return TRUE here so that Windows doesn't
    1:   // send two WM_CHAR msgs
    1:   return PR_TRUE;
    1: }
    1: 
    1: //==========================================================================
    1: // This function is used when aIndex is GCS_COMPSTR, GCS_COMPREADSTR,
    1: // GCS_RESULTSTR, and GCS_RESULTREADSTR.
    1: // Otherwise use ::ImmGetCompositionStringW.
21031: void nsWindow::GetCompositionString(HIMC aHIMC, DWORD aIndex)
21031: {
21031:   // Retrieve the size of the required output buffer.
21031:   long lRtn = ::ImmGetCompositionStringW(aHIMC, aIndex, NULL, 0);
21031:   if (lRtn < 0 ||
21031:       !EnsureStringLength(*sIMECompUnicode, (lRtn / sizeof(WCHAR)) + 1))
21031:     return; // Error or out of memory.
21031: 
21031:   // Actually retrieve the composition string information.
21031:   lRtn = ::ImmGetCompositionStringW(aHIMC, aIndex,
21031:                                     (LPVOID)sIMECompUnicode->BeginWriting(),
21031:                                     lRtn + sizeof(WCHAR));
21031:   sIMECompUnicode->SetLength(lRtn / sizeof(WCHAR));
    1: }
    1: 
22411: PRBool nsWindow::ConvertToANSIString(const nsAFlatString& aStr, UINT aCodePage,
22411:                                      nsACString& aANSIStr)
22411: {
22411:   int len = ::WideCharToMultiByte(aCodePage, 0,
22411:                                   (LPCWSTR)aStr.get(), aStr.Length(),
22411:                                   NULL, 0, NULL, NULL);
22411:   NS_ENSURE_TRUE(len >= 0, PR_FALSE);
22411: 
22411:   if (!EnsureStringLength(aANSIStr, len))
22411:     return PR_FALSE;
22411:   ::WideCharToMultiByte(aCodePage, 0, (LPCWSTR)aStr.get(), aStr.Length(),
22411:                         (LPSTR)aANSIStr.BeginWriting(), len, NULL, NULL);
22411:   return PR_TRUE;
22411: }
22411: 
    1: //==========================================================================
    1: BOOL nsWindow::OnIMEComposition(LPARAM aGCS)
    1: {
    1: #ifdef DEBUG_IME
    1:   printf("OnIMEComposition\n");
    1: #endif
22788:   NS_PRECONDITION(mIMEEnabled != nsIWidget::IME_STATUS_PLUGIN,
22788:     "OnIMEComposition should not be called when a plug-in has focus");
22788: 
    1:   // for bug #60050
    1:   // MS-IME 95/97/98/2000 may send WM_IME_COMPOSITION with non-conversion
    1:   // mode before it send WM_IME_STARTCOMPOSITION.
21031:   if (!sIMECompUnicode) {
21031:     sIMECompUnicode = new nsString();
21031:     if (NS_UNLIKELY(!sIMECompUnicode)) {
    1:       NS_ASSERTION(sIMECompUnicode, "sIMECompUnicode is null");
    1:       return PR_TRUE;
21031:     }
21031:   }
    1: 
    1:   HIMC hIMEContext = ::ImmGetContext(mWnd);
    1:   if (hIMEContext==NULL) 
    1:     return PR_TRUE;
    1: 
    1:   // will change this if an IME message we handle
    1:   BOOL result = PR_FALSE;
    1: 
    1:   PRBool startCompositionMessageHasBeenSent = sIMEIsComposing;
    1: 
    1:   //
    1:   // This catches a fixed result
    1:   //
    1:   if (aGCS & GCS_RESULTSTR) {
    1: #ifdef DEBUG_IME
    1:     printf("Handling GCS_RESULTSTR\n");
    1: #endif
    1:     if (!sIMEIsComposing) 
    1:       HandleStartComposition(hIMEContext);
    1: 
21031:     GetCompositionString(hIMEContext, GCS_RESULTSTR);
    1: #ifdef DEBUG_IME
    1:     printf("GCS_RESULTSTR compStrLen = %d\n", sIMECompUnicode->Length());
    1: #endif
    1:     result = PR_TRUE;
    1:     HandleTextEvent(hIMEContext, PR_FALSE);
    1:     HandleEndComposition();
    1:   }
    1: 
    1: 
    1:   //
    1:   // This provides us with a composition string
    1:   //
22788:   if (IS_COMPOSING_LPARAM(aGCS))
    1:   {
    1: #ifdef DEBUG_IME
    1:     printf("Handling GCS_COMPSTR\n");
    1: #endif
    1: 
    1:     if (!sIMEIsComposing) 
    1:       HandleStartComposition(hIMEContext);
    1: 
    1:     //--------------------------------------------------------
    1:     // 1. Get GCS_COMPSTR
    1:     //--------------------------------------------------------
21031:     GetCompositionString(hIMEContext, GCS_COMPSTR);
    1: 
    1:     // See https://bugzilla.mozilla.org/show_bug.cgi?id=296339
    1:     if (sIMECompUnicode->IsEmpty() &&
    1:         !startCompositionMessageHasBeenSent) {
    1:       // In this case, maybe, the sender is MSPinYin. That sends *only*
    1:       // WM_IME_COMPOSITION with GCS_COMP* and GCS_RESULT* when
    1:       // user inputted the Chinese full stop. So, that doesn't send
    1:       // WM_IME_STARTCOMPOSITION and WM_IME_ENDCOMPOSITION.
    1:       // If WM_IME_STARTCOMPOSITION was not sent and the composition
    1:       // string is null (it indicates the composition transaction ended),
    1:       // WM_IME_ENDCOMPOSITION may not be sent. If so, we cannot run
    1:       // HandleEndComposition() in other place.
    1: #ifdef DEBUG_IME
    1:       printf("Aborting GCS_COMPSTR\n");
    1: #endif
    1:       HandleEndComposition();
    1:       return result;
    1:     }
    1: 
    1: #ifdef DEBUG_IME
    1:     printf("GCS_COMPSTR compStrLen = %d\n", sIMECompUnicode->Length());
    1: #endif
    1: 
    1:     //--------------------------------------------------------
    1:     // 2. Get GCS_COMPCLAUSE
    1:     //--------------------------------------------------------
22411:     long compClauseArrayByteCount =
22411:       ::ImmGetCompositionStringW(hIMEContext, GCS_COMPCLAUSE, NULL, 0);
    1: #ifdef DEBUG_IME
22411:     printf("GCS_COMPCLAUSE compClauseArrayByteCount = %d\n",
22411:            compClauseArrayByteCount);
22411: #endif
22411:     long compClauseArrayLength = compClauseArrayByteCount / sizeof(PRUint32);
22411:     if (compClauseArrayLength > 0) {
22411:       if (compClauseArrayByteCount > sIMECompClauseArraySize) {
    1:         if (sIMECompClauseArray)
    1:           delete [] sIMECompClauseArray;
    1:         // Allocate some extra space to avoid reallocations.
22411:         PRInt32 arrayLength = compClauseArrayLength + 32;
22411:         sIMECompClauseArray = new PRUint32[arrayLength];
22411:         sIMECompClauseArraySize = arrayLength * sizeof(PRUint32);
22411:       }
22411: 
23335: #ifndef WINCE
22411:       // Intelligent ABC IME (Simplified Chinese IME, the code page is 936)
22411:       // will crash in ImmGetCompositionStringW for GCS_COMPCLAUSE (bug 424663).
22411:       // See comment 35 of the bug for the detail. Therefore, we should use A
22411:       // API for it, however, we should not kill Unicode support on all IMEs.
22411:       PRBool useA_API = !(gKbdLayout.GetIMEProperty() & IME_PROP_UNICODE);
23335: #else
23335:       PRBool useA_API =  PR_TRUE;
23335: #endif
23335:       long compClauseArrayByteCount2 = 
23335: #ifndef WINCE
23335:         useA_API ?
22411:         ::ImmGetCompositionStringA(hIMEContext, GCS_COMPCLAUSE,
22411:                                    sIMECompClauseArray,
22411:                                    sIMECompClauseArraySize) :
23335: #endif
22411:         ::ImmGetCompositionStringW(hIMEContext, GCS_COMPCLAUSE,
22411:                                    sIMECompClauseArray,
22411:                                    sIMECompClauseArraySize);
22411:       NS_ASSERTION(compClauseArrayByteCount2 == compClauseArrayByteCount,
22411:                    "strange result");
22411:       if (compClauseArrayByteCount > compClauseArrayByteCount2)
22411:         compClauseArrayLength = compClauseArrayByteCount2 / sizeof(PRUint32);
22411: 
22411:       if (useA_API) {
22411:         // Convert each values of sIMECompClauseArray. The values mean offset of
22411:         // the clauses in ANSI string. But we need the values in Unicode string.
22411:         nsCAutoString compANSIStr;
22411:         if (ConvertToANSIString(*sIMECompUnicode,
23335: #ifndef WINCE
23335:                                 gKbdLayout.GetCodePage(), 
23335: #else
23335:                                 GetACP(),
23335: #endif
23335:                                 compANSIStr)) {
22411:           PRUint32 maxlen = compANSIStr.Length();
22411:           sIMECompClauseArray[0] = 0; // first value must be 0
22411:           for (PRInt32 i = 1; i < compClauseArrayLength; i++) {
22411:             PRUint32 len = PR_MIN(sIMECompClauseArray[i], maxlen);
22411:             sIMECompClauseArray[i] =
23335:               ::MultiByteToWideChar(
23335: #ifndef WINCE
23335:                                     gKbdLayout.GetCodePage(), 
23335: #else
23335:                                     GetACP(),
23335: #endif
23335:                                     MB_PRECOMPOSED,
22411:                                     (LPCSTR)compANSIStr.get(), len, NULL, 0);
22411:           }
22411:         }
22411:       }
22411:     }
22411:     // compClauseArrayLength may be negative. I.e., ImmGetCompositionStringW
22411:     // may return an error code.
22411:     sIMECompClauseArrayLength = PR_MAX(0, compClauseArrayLength);
    1: 
    1:     //--------------------------------------------------------
    1:     // 3. Get GCS_COMPATTR
    1:     //--------------------------------------------------------
    1:     // This provides us with the attribute string necessary 
    1:     // for doing hiliting
    1:     long attrStrLen;
    1:     attrStrLen = ::ImmGetCompositionStringW(hIMEContext, GCS_COMPATTR, NULL, 0);
    1: #ifdef DEBUG_IME
    1:     printf("GCS_COMPATTR attrStrLen = %d\n", attrStrLen);
    1: #endif
    1:     if (attrStrLen > sIMEAttributeArraySize) {
    1:       if (sIMEAttributeArray) 
    1:         delete [] sIMEAttributeArray;
    1:       // Allocate some extra space to avoid reallocations.
22411:       PRInt32 arrayLength = attrStrLen + 64;
22411:       sIMEAttributeArray = new PRUint8[arrayLength];
22411:       sIMEAttributeArraySize = arrayLength * sizeof(PRUint8);
    1:     }
    1:     attrStrLen = ::ImmGetCompositionStringW(hIMEContext, GCS_COMPATTR, sIMEAttributeArray, sIMEAttributeArraySize);
    1: 
22411:     // attrStrLen may be negative. I.e., ImmGetCompositionStringW may return an
22411:     // error code.
22411:     sIMEAttributeArrayLength = PR_MAX(0, attrStrLen);
    1: 
    1:     //--------------------------------------------------------
    1:     // 4. Get GCS_CURSOPOS
    1:     //--------------------------------------------------------
22879:     // Some IMEs (e.g., the standard IME for Korean) don't have caret position.
22879:     if (aGCS & GCS_CURSORPOS) {
22879:       sIMECursorPosition =
22879:         ::ImmGetCompositionStringW(hIMEContext, GCS_CURSORPOS, NULL, 0);
22879:       if (sIMECursorPosition < 0)
22879:         sIMECursorPosition = NO_IME_CARET; // The result is error
22879:     } else {
22879:       sIMECursorPosition = NO_IME_CARET;
22879:     }
    1: 
19625:     NS_ASSERTION(sIMECursorPosition <= (long)sIMECompUnicode->Length(), "illegal pos");
    1: 
    1: #ifdef DEBUG_IME
22879:     if (aGCS & GCS_CURSORPOS)
    1:       printf("sIMECursorPosition(Unicode): %d\n", sIMECursorPosition);
22879:     else
22879:       printf("sIMECursorPosition: None\n");
    1: #endif
    1:     //--------------------------------------------------------
    1:     // 5. Send the text event
    1:     //--------------------------------------------------------
    1:     HandleTextEvent(hIMEContext);
    1:     result = PR_TRUE;
    1:   }
    1:   if (!result) {
    1: #ifdef DEBUG_IME
21031:     fprintf(stderr, "Handle 0 length TextEvent.\n");
    1: #endif
    1:     if (!sIMEIsComposing) 
    1:       HandleStartComposition(hIMEContext);
    1: 
    1:     sIMECompUnicode->Truncate();
    1:     HandleTextEvent(hIMEContext, PR_FALSE);
    1:     result = PR_TRUE;
    1:   }
    1: 
    1:   ::ImmReleaseContext(mWnd, hIMEContext);
25732:   return ShouldDrawCompositionStringOurselves() ? result : PR_FALSE;
    1: }
    1: //==========================================================================
    1: BOOL nsWindow::OnIMECompositionFull()
    1: {
    1: #ifdef DEBUG_IME2
    1:   printf("OnIMECompositionFull\n");
    1: #endif
    1: 
    1:   // not implement yet
    1:   return PR_FALSE;
    1: }
    1: //==========================================================================
    1: BOOL nsWindow::OnIMEEndComposition()
    1: {
    1: #ifdef DEBUG_IME
    1:   printf("OnIMEEndComposition\n");
    1: #endif
    1:   if (sIMEIsComposing) {
22411:     HIMC hIMEContext = ::ImmGetContext(mWnd);
    1:     if (hIMEContext==NULL) 
    1:       return PR_TRUE;
    1: 
    1:     // IME on Korean NT somehow send WM_IME_ENDCOMPOSITION
    1:     // first when we hit space in composition mode
    1:     // we need to clear out the current composition string
    1:     // in that case.
21031:     sIMECompUnicode->Truncate();
    1: 
    1:     HandleTextEvent(hIMEContext, PR_FALSE);
    1: 
    1:     HandleEndComposition();
    1:     ::ImmReleaseContext(mWnd, hIMEContext);
    1:   }
25732:   return ShouldDrawCompositionStringOurselves();
    1: }
    1: //==========================================================================
22788: BOOL nsWindow::OnIMENotify(WPARAM aIMN, LPARAM aData)
    1: {
    1: #ifdef DEBUG_IME2
    1:   printf("OnIMENotify ");
    1:   switch (aIMN) {
    1:     case IMN_CHANGECANDIDATE:
    1:       printf("IMN_CHANGECANDIDATE %x\n", aData);
    1:       break;
    1:     case IMN_CLOSECANDIDATE:
    1:       printf("IMN_CLOSECANDIDATE %x\n", aData);
    1:       break;
    1:     case IMN_CLOSESTATUSWINDOW:
    1:       printf("IMN_CLOSESTATUSWINDOW\n");
    1:       break;
    1:     case IMN_GUIDELINE:
    1:       printf("IMN_GUIDELINE\n");
    1:       break;
    1:     case IMN_OPENCANDIDATE:
    1:       printf("IMN_OPENCANDIDATE %x\n", aData);
    1:       break;
    1:     case IMN_OPENSTATUSWINDOW:
    1:       printf("IMN_OPENSTATUSWINDOW\n");
    1:       break;
    1:     case IMN_SETCANDIDATEPOS:
    1:       printf("IMN_SETCANDIDATEPOS %x\n", aData);
    1:       break;
    1:     case IMN_SETCOMPOSITIONFONT:
    1:       printf("IMN_SETCOMPOSITIONFONT\n");
    1:       break;
    1:     case IMN_SETCOMPOSITIONWINDOW:
    1:       printf("IMN_SETCOMPOSITIONWINDOW\n");
    1:       break;
    1:     case IMN_SETCONVERSIONMODE:
    1:       printf("IMN_SETCONVERSIONMODE\n");
    1:       break;
    1:     case IMN_SETOPENSTATUS:
    1:       printf("IMN_SETOPENSTATUS\n");
    1:       break;
    1:     case IMN_SETSENTENCEMODE:
    1:       printf("IMN_SETSENTENCEMODE\n");
    1:       break;
    1:     case IMN_SETSTATUSWINDOWPOS:
    1:       printf("IMN_SETSTATUSWINDOWPOS\n");
    1:       break;
    1:     case IMN_PRIVATE:
    1:       printf("IMN_PRIVATE\n");
    1:       break;
    1:   };
    1: #endif
    1: 
    1:   // add hacky code here
    1:   if (IS_VK_DOWN(NS_VK_ALT)) {
    1:     mIsShiftDown = PR_FALSE;
    1:     mIsControlDown = PR_FALSE;
    1:     mIsAltDown = PR_TRUE;
    1: 
22788:     DispatchKeyEvent(NS_KEY_PRESS, 0, nsnull, 192, nsnull); // XXX hack hack hack
    1:     if (aIMN == IMN_SETOPENSTATUS)
    1:       sIMEIsStatusChanged = PR_TRUE;
    1:   }
    1:   // not implemented yet
    1:   return PR_FALSE;
    1: }
    1: //==========================================================================
    1: BOOL nsWindow::OnIMERequest(WPARAM aIMR, LPARAM aData, LRESULT *oResult)
    1: {
    1: #ifdef DEBUG_IME
    1:   printf("OnIMERequest\n");
    1: #endif
    1:   PRBool result = PR_FALSE;
    1: 
    1:   switch (aIMR) {
    1:     case IMR_RECONVERTSTRING:
    1:       result = OnIMEReconvert(aData, oResult);
    1:       break;
    1:     case IMR_QUERYCHARPOSITION:
    1:       result = OnIMEQueryCharPosition(aData, oResult);
    1:       break;
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: //==========================================================================
    1: PRBool nsWindow::OnIMEReconvert(LPARAM aData, LRESULT *oResult)
    1: {
    1: #ifdef DEBUG_IME
    1:   printf("OnIMEReconvert\n");
    1: #endif
    1: 
16525:   *oResult = 0;
    1:   RECONVERTSTRING* pReconv = (RECONVERTSTRING*) aData;
16525: 
16525:   nsQueryContentEvent selection(PR_TRUE, NS_QUERY_SELECTED_TEXT, this);
23738:   nsIntPoint point(0, 0);
16525:   InitEvent(selection, &point);
16525:   DispatchWindowEvent(&selection);
16525:   if (!selection.mSucceeded)
16525:     return PR_FALSE;
    1: 
    1:   if (!pReconv) {
16525:     // Return need size to reconvert.
16525:     if (selection.mReply.mString.IsEmpty())
16525:       return PR_FALSE;
16525:     PRUint32 len = selection.mReply.mString.Length();
    1:     *oResult = sizeof(RECONVERTSTRING) + len * sizeof(WCHAR);
16525:     return PR_TRUE;
16525:   }
16525: 
    1:   // Fill reconvert struct
16525:   PRUint32 len = selection.mReply.mString.Length();
16525:   PRUint32 needSize = sizeof(RECONVERTSTRING) + len * sizeof(WCHAR);
16525: 
16525:   if (pReconv->dwSize < needSize)
    1:     return PR_FALSE;
16525: 
16525:   *oResult = needSize;
    1: 
    1:   DWORD tmpSize = pReconv->dwSize;
    1:   ::ZeroMemory(pReconv, tmpSize);
    1:   pReconv->dwSize            = tmpSize;
    1:   pReconv->dwVersion         = 0;
    1:   pReconv->dwStrLen          = len;
    1:   pReconv->dwStrOffset       = sizeof(RECONVERTSTRING);
    1:   pReconv->dwCompStrLen      = len;
    1:   pReconv->dwCompStrOffset   = 0;
    1:   pReconv->dwTargetStrLen    = len;
    1:   pReconv->dwTargetStrOffset = 0;
    1: 
    1:   ::CopyMemory((LPVOID) (aData + sizeof(RECONVERTSTRING)),
16525:                selection.mReply.mString.get(), len * sizeof(WCHAR));
16525:   return PR_TRUE;
    1: }
    1: 
    1: //==========================================================================
    1: PRBool nsWindow::OnIMEQueryCharPosition(LPARAM aData, LRESULT *oResult)
    1: {
    1: #ifdef DEBUG_IME
    1:   printf("OnIMEQueryCharPosition\n");
    1: #endif
16525: 
16525:   PRUint32 len = sIMEIsComposing ? sIMECompUnicode->Length() : 0;
16525:   *oResult = FALSE;
    1:   IMECHARPOSITION* pCharPosition = (IMECHARPOSITION*)aData;
    1:   if (!pCharPosition ||
    1:       pCharPosition->dwSize < sizeof(IMECHARPOSITION) ||
16525:       ::GetFocus() != mWnd ||
16525:       pCharPosition->dwCharPos > len)
    1:     return PR_FALSE;
16525: 
23738:   nsIntRect r;
25732:   PRBool ret = GetCharacterRectOfSelectedTextAt(pCharPosition->dwCharPos, r);
25732:   NS_ENSURE_TRUE(ret, PR_FALSE);
    1: 
23738:   nsIntRect screenRect;
19016:   // We always need top level window that is owner window of the popup window
19016:   // even if the content of the popup window has focus.
19016:   ResolveIMECaretPos(GetTopLevelWindow(PR_FALSE), r, nsnull, screenRect);
    1:   pCharPosition->pt.x = screenRect.x;
    1:   pCharPosition->pt.y = screenRect.y;
    1: 
16525:   pCharPosition->cLineHeight = r.height;
16525: 
16525:   // XXX Should we create "query focused content rect event"?
    1:   ::GetWindowRect(mWnd, &pCharPosition->rcDocument);
    1: 
    1:   *oResult = TRUE;
    1:   return PR_TRUE;
    1: }
    1: 
    1: //==========================================================================
    1: void
16603: nsWindow::ResolveIMECaretPos(nsIWidget* aReferenceWidget,
23738:                              nsIntRect& aCursorRect,
16603:                              nsIWidget* aNewOriginWidget,
23738:                              nsIntRect& aOutRect)
16603: {
16603:   aOutRect = aCursorRect;
16603: 
16603:   if (aReferenceWidget == aNewOriginWidget)
    1:     return;
16603: 
16603:   if (aReferenceWidget)
25183:     aOutRect.MoveBy(aReferenceWidget->WidgetToScreenOffset());
16603: 
16603:   if (aNewOriginWidget)
25183:     aOutRect.MoveBy(-aNewOriginWidget->WidgetToScreenOffset());
    1: }
    1: 
    1: //==========================================================================
    1: BOOL nsWindow::OnIMESelect(BOOL  aSelected, WORD aLangID)
    1: {
    1: #ifdef DEBUG_IME2
    1:   printf("OnIMESelect\n");
    1: #endif
    1: 
    1:   // not implement yet
    1:   return PR_FALSE;
    1: }
    1: //==========================================================================
    1: BOOL nsWindow::OnIMESetContext(BOOL aActive, LPARAM& aISC)
    1: {
    1: #ifdef DEBUG_IME2
    1:   printf("OnIMESetContext %x %s %s %s Candidate[%s%s%s%s]\n", this,
    1:     (aActive ? "Active" : "Deactiv"),
    1:     ((aISC & ISC_SHOWUICOMPOSITIONWINDOW) ? "[Comp]" : ""),
    1:     ((aISC & ISC_SHOWUIGUIDELINE) ? "[GUID]" : ""),
    1:     ((aISC & ISC_SHOWUICANDIDATEWINDOW) ? "0" : ""),
    1:     ((aISC & (ISC_SHOWUICANDIDATEWINDOW<<1)) ? "1" : ""),
    1:     ((aISC & (ISC_SHOWUICANDIDATEWINDOW<<2)) ? "2" : ""),
    1:     ((aISC & (ISC_SHOWUICANDIDATEWINDOW<<3)) ? "3" : ""));
    1: #endif
    1:   if (! aActive)
    1:     ResetInputState();
    1: 
25732:   if (ShouldDrawCompositionStringOurselves()) {
    1:     aISC &= ~ISC_SHOWUICOMPOSITIONWINDOW;
25732:   }
25732: 
25732:   // We still return false here even if we should draw a composition string
25732:   // ourselves. Because we need to pass the aISC w/ ISC_SHOWUICOMPOSITIONWINDOW
25732:   // directly to the default window proc so it will draw the candidate window
25732:   // for us...
    1:   return PR_FALSE;
    1: }
    1: //==========================================================================
    1: BOOL nsWindow::OnIMEStartComposition()
    1: {
    1: #ifdef DEBUG_IME
    1:   printf("OnIMEStartComposition\n");
    1: #endif
22411:   HIMC hIMEContext = ::ImmGetContext(mWnd);
    1:   if (hIMEContext == NULL)
    1:     return PR_TRUE;
    1: 
25732:   HandleStartComposition(hIMEContext);
    1:   ::ImmReleaseContext(mWnd, hIMEContext);
25732:   return ShouldDrawCompositionStringOurselves();
    1: }
    1: 
    1: //==========================================================================
    1: NS_IMETHODIMP nsWindow::ResetInputState()
    1: {
    1: #ifdef DEBUG_KBSTATE
    1:   printf("ResetInputState\n");
    1: #endif
24836: 
24836: #ifdef NS_ENABLE_TSF
24836:   nsTextStore::CommitComposition(PR_FALSE);
24836: #endif //NS_ENABLE_TSF
24836: 
    1:   HIMC hIMC = ::ImmGetContext(mWnd);
    1:   if (hIMC) {
    1:     BOOL ret = FALSE;
    1:     ret = ::ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, NULL);
    1:     ret = ::ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_CANCEL, NULL);
    1:     //NS_ASSERTION(ret, "ImmNotify failed");
    1:     ::ImmReleaseContext(mWnd, hIMC);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //==========================================================================
    1: NS_IMETHODIMP nsWindow::SetIMEOpenState(PRBool aState)
    1: {
    1: #ifdef DEBUG_KBSTATE
    1:   printf("SetIMEOpenState %s\n", (aState ? "Open" : "Close"));
    1: #endif 
24836: 
24836: #ifdef NS_ENABLE_TSF
24836:   nsTextStore::SetIMEOpenState(aState);
24836: #endif //NS_ENABLE_TSF
24836: 
    1:   HIMC hIMC = ::ImmGetContext(mWnd);
    1:   if (hIMC) {
    1:     ::ImmSetOpenStatus(hIMC, aState ? TRUE : FALSE);
    1:     ::ImmReleaseContext(mWnd, hIMC);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //==========================================================================
    1: NS_IMETHODIMP nsWindow::GetIMEOpenState(PRBool* aState)
    1: {
    1:   HIMC hIMC = ::ImmGetContext(mWnd);
    1:   if (hIMC) {
    1:     BOOL isOpen = ::ImmGetOpenStatus(hIMC);
    1:     *aState = isOpen ? PR_TRUE : PR_FALSE;
    1:     ::ImmReleaseContext(mWnd, hIMC);
    1:   } else 
    1:     *aState = PR_FALSE;
24836: 
24836: #ifdef NS_ENABLE_TSF
24836:   *aState |= nsTextStore::GetIMEOpenState();
24836: #endif //NS_ENABLE_TSF
24836: 
    1:   return NS_OK;
    1: }
    1: 
    1: //==========================================================================
  539: NS_IMETHODIMP nsWindow::SetIMEEnabled(PRUint32 aState)
    1: {
24836: #ifdef NS_ENABLE_TSF
24836:   nsTextStore::SetIMEEnabled(aState);
24836: #endif //NS_ENABLE_TSF
25278: #ifdef DEBUG_KBSTATE
25278:   printf("SetIMEEnabled: %s\n", (aState == nsIWidget::IME_STATUS_ENABLED ||
25278:                                  aState == nsIWidget::IME_STATUS_PLUGIN)? 
25278:                                 "Enabled": "Disabled");
25278: #endif 
    1:   if (sIMEIsComposing)
    1:     ResetInputState();
  539:   mIMEEnabled = aState;
22788:   PRBool enable = (aState == nsIWidget::IME_STATUS_ENABLED ||
22788:                    aState == nsIWidget::IME_STATUS_PLUGIN);
25278: 
25278: #if defined(WINCE_HAVE_SOFTKB)
26485:   gSoftKeyboardState = (aState != nsIWidget::IME_STATUS_DISABLED);
26485:   ToggleSoftKB(gSoftKeyboardState);
25278: #endif
25278: 
  539:   if (!enable != !mOldIMC)
    1:     return NS_OK;
  539:   mOldIMC = ::ImmAssociateContext(mWnd, enable ? mOldIMC : NULL);
  539:   NS_ASSERTION(!enable || !mOldIMC, "Another IMC was associated");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //==========================================================================
  539: NS_IMETHODIMP nsWindow::GetIMEEnabled(PRUint32* aState)
  539: {
25278: #ifdef DEBUG_KBSTATE
25278:   printf("GetIMEEnabled: %s\n", mIMEEnabled? "Enabled": "Disabled");
25278: #endif 
  539:   *aState = mIMEEnabled;
    1:   return NS_OK;
    1: }
    1: 
    1: //==========================================================================
    1: NS_IMETHODIMP nsWindow::CancelIMEComposition()
    1: {
    1: #ifdef DEBUG_KBSTATE
    1:   printf("CancelIMEComposition\n");
    1: #endif 
24836: 
24836: #ifdef NS_ENABLE_TSF
24836:   nsTextStore::CommitComposition(PR_TRUE);
24836: #endif //NS_ENABLE_TSF
24836: 
    1:   HIMC hIMC = ::ImmGetContext(mWnd);
    1:   if (hIMC) {
    1:     BOOL ret = FALSE;
    1:     ret = ::ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_CANCEL, NULL);
    1:     ::ImmReleaseContext(mWnd, hIMC);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
 2475: //==========================================================================
 2475: NS_IMETHODIMP
 2475: nsWindow::GetToggledKeyState(PRUint32 aKeyCode, PRBool* aLEDState)
 2475: {
 2475: #ifdef DEBUG_KBSTATE
 2475:   printf("GetToggledKeyState\n");
 2475: #endif 
 2475:   NS_ENSURE_ARG_POINTER(aLEDState);
 2475:   *aLEDState = (::GetKeyState(aKeyCode) & 1) != 0;
 2475:   return NS_OK;
 2475: }
    1: 
    1: #define PT_IN_RECT(pt, rc)  ((pt).x>(rc).left && (pt).x <(rc).right && (pt).y>(rc).top && (pt).y<(rc).bottom)
    1: 
    1: // Mouse operation of IME
    1: PRBool
    1: nsWindow::IMEMouseHandling(PRInt32 aAction, LPARAM lParam)
    1: {
    1: #ifndef WINCE
    1:   POINT ptPos;
    1:   ptPos.x = (short)LOWORD(lParam);
    1:   ptPos.y = (short)HIWORD(lParam);
    1: 
    1:   if (sIMEIsComposing && nsWindow::uWM_MSIME_MOUSE) {
    1:     if (IMECompositionHitTest(&ptPos))
    1:       if (HandleMouseActionOfIME(aAction, &ptPos))
    1:         return PR_TRUE;
    1:   } else {
    1:     HWND parentWnd = ::GetParent(mWnd);
    1:     if (parentWnd) {
    1:       nsWindow* parentWidget = GetNSWindowPtr(parentWnd);
    1:       if (parentWidget && parentWidget->sIMEIsComposing && nsWindow::uWM_MSIME_MOUSE) {
    1:         if (parentWidget->IMECompositionHitTest(&ptPos))
    1:           if (parentWidget->HandleMouseActionOfIME(aAction, &ptPos))
    1:             return PR_TRUE;
    1:       }
    1:     }
    1:   }
    1: #endif
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsWindow::HandleMouseActionOfIME(int aAction, POINT *ptPos)
    1: {
    1:   PRBool IsHandle = PR_FALSE;
    1: 
    1:   if (mWnd) {
    1:     HIMC hIMC = ::ImmGetContext(mWnd);
    1:     if (hIMC) {
    1:       int positioning = 0;
    1:       int offset = 0;
    1: 
    1:       // calcurate positioning and offset
    1:       // char :            JCH1|JCH2|JCH3
    1:       // offset:           0011 1122 2233
    1:       // positioning:      2301 2301 2301
    1: 
    1:       // Note: hitText has been done, so no check of sIMECompCharPos
    1:       // and composing char maximum limit is necessary.
21031:       PRUint32 len = sIMECompUnicode->Length();
    1:       PRUint32 i = 0;
21031:       for (i = 0; i < len; ++i) {
    1:         if (PT_IN_RECT(*ptPos, sIMECompCharPos[i]))
    1:           break;
    1:       }
    1:       offset = i;
    1:       if (ptPos->x - sIMECompCharPos[i].left > sIMECompCharPos[i].right - ptPos->x)
    1:         offset++;
    1: 
    1:       positioning = (ptPos->x - sIMECompCharPos[i].left) * 4 /
    1:                     (sIMECompCharPos[i].right - sIMECompCharPos[i].left);
    1:       positioning = (positioning + 2) % 4;
    1: 
    1:       // send MS_MSIME_MOUSE message to default IME window.
    1:       HWND imeWnd = ::ImmGetDefaultIMEWnd(mWnd);
    1:       if (::SendMessageW(imeWnd, nsWindow::uWM_MSIME_MOUSE,
    1:                          MAKELONG(MAKEWORD(aAction, positioning), offset),
    1:                          (LPARAM) hIMC) == 1)
    1:         IsHandle = PR_TRUE;
    1:     }
    1:     ::ImmReleaseContext(mWnd, hIMC);
    1:   }
    1: 
    1:   return IsHandle;
    1: }
    1: 
    1: //The coordinate is relative to the upper-left corner of the client area.
    1: PRBool nsWindow::IMECompositionHitTest(POINT * ptPos)
    1: {
    1:   PRBool IsHit = PR_FALSE;
    1: 
    1:   if (sIMECompCharPos){
    1:     // figure out how many char in composing string,
    1:     // but keep it below the limit we can handle
    1:     PRInt32 len = sIMECompUnicode->Length();
    1:     if (len > IME_MAX_CHAR_POS)
    1:       len = IME_MAX_CHAR_POS;
    1: 
    1:     PRInt32 i;
    1:     PRInt32 aveWidth = 0;
    1:     // found per char width
    1:     for (i = 0; i < len; i++) {
    1:       if (sIMECompCharPos[i].left >= 0 && sIMECompCharPos[i].right > 0) {
    1:         aveWidth = sIMECompCharPos[i].right - sIMECompCharPos[i].left;
    1:         break;
    1:       }
    1:     }
    1: 
    1:     // validate each rect and test
    1:     for (i = 0; i < len; i++) {
    1:       if (sIMECompCharPos[i].left < 0) {
    1:         if (i != 0 && sIMECompCharPos[i-1].top == sIMECompCharPos[i].top)
    1:           sIMECompCharPos[i].left = sIMECompCharPos[i-1].right;
    1:         else
    1:           sIMECompCharPos[i].left = sIMECompCharPos[i].right - aveWidth;
    1:       }
    1:       if (sIMECompCharPos[i].right < 0)
    1:         sIMECompCharPos[i].right = sIMECompCharPos[i].left + aveWidth;
    1:       if (sIMECompCharPos[i].top < 0) {
    1:         sIMECompCharPos[i].top = sIMECompCharPos[i-1].top;
    1:         sIMECompCharPos[i].bottom = sIMECompCharPos[i-1].bottom;
    1:       }
    1: 
    1:       if (PT_IN_RECT(*ptPos, sIMECompCharPos[i])) {
    1:         IsHit = PR_TRUE;
    1:         break;
    1:       }
    1:     }
    1:   }
    1:   return IsHit;
    1: }
    1: 
24836: #ifdef NS_ENABLE_TSF
24836: NS_IMETHODIMP
24836: nsWindow::OnIMEFocusChange(PRBool aFocus)
24836: {
24836:   return nsTextStore::OnFocusChange(aFocus, this, mIMEEnabled);
24836: }
24836: 
24836: NS_IMETHODIMP
24836: nsWindow::OnIMETextChange(PRUint32 aStart,
24836:                           PRUint32 aOldEnd,
24836:                           PRUint32 aNewEnd)
24836: {
24836:   return nsTextStore::OnTextChange(aStart, aOldEnd, aNewEnd);
24836: }
24836: 
24836: NS_IMETHODIMP
24836: nsWindow::OnIMESelectionChange(void)
24836: {
24836:   return nsTextStore::OnSelectionChange();
24836: }
24836: #endif //NS_ENABLE_TSF
24836: 
24836: 
    1: // Draw user's attention to this window until it comes to foreground.
    1: NS_IMETHODIMP
    1: nsWindow::GetAttention(PRInt32 aCycleCount)
    1: {
26617: #ifndef WINCE
    1:   // Got window?
    1:   if (!mWnd)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
26616:   // Don't flash if the flash count is 0 or if the
26616:   // top level window is already active.
26616:   HWND fgWnd = ::GetForegroundWindow();
26616:   if (aCycleCount == 0 || fgWnd == GetTopLevelHWND(mWnd))
    1:     return NS_OK;
    1: 
26616:   HWND flashWnd = mWnd;
26616:   while (HWND ownerWnd = ::GetWindow(flashWnd, GW_OWNER)) {
26616:     flashWnd = ownerWnd;
26616:   }
26616: 
26616:   // Don't flash if the owner window is active either.
26616:   if (fgWnd == flashWnd)
    1:     return NS_OK;
26616: 
26616:   DWORD defaultCycleCount = 0;
26616:   ::SystemParametersInfo(SPI_GETFOREGROUNDFLASHCOUNT, 0, &defaultCycleCount, 0);
26616: 
26616:   FLASHWINFO flashInfo = { sizeof(FLASHWINFO), flashWnd,
26616:     FLASHW_ALL, aCycleCount > 0 ? aCycleCount : defaultCycleCount, 0 };
26616:   ::FlashWindowEx(&flashInfo);
26617: #endif
26616:   return NS_OK;
26616: }
26616: 
26616: void nsWindow::StopFlashing()
26616: {
26617: #ifndef WINCE
26616:   HWND flashWnd = mWnd;
26616:   while (HWND ownerWnd = ::GetWindow(flashWnd, GW_OWNER)) {
26616:     flashWnd = ownerWnd;
26616:   }
26616: 
26616:   FLASHWINFO flashInfo = { sizeof(FLASHWINFO), flashWnd,
26616:     FLASHW_STOP, 0, 0 };
26616:   ::FlashWindowEx(&flashInfo);
26617: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
26911: nsWindow::GetLastInputEventTime(PRUint32& aTime)
    1: {
    1:   WORD qstatus = HIWORD(GetQueueStatus(QS_INPUT));
    1: 
26911:   // If there is pending input or the user is currently
26911:   // moving the window then return the current time.
26911:   // Note: When the user is moving the window WIN32 spins
26911:   // a separate event loop and input events are not
26911:   // reported to the application.
    1:   nsToolkit* toolkit = (nsToolkit *)mToolkit;
26911:   if (qstatus || (toolkit && toolkit->UserIsMovingWindow())) {
26911:     gLastInputEventTime = PR_IntervalToMicroseconds(PR_IntervalNow());
26911:   }
26911: 
26911:   aTime = gLastInputEventTime;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //-------------------------------------------------------------------------
    1: //-- NOTE!!! These hook functions can be removed when we migrate to
    1: //-- XBL-Form Controls
    1: //-------------------------------------------------------------------------
    1: //-------------------------------------------------------------------------
    1: //#define DISPLAY_NOISY_MSGF_MSG
    1: 
    1: #ifdef DISPLAY_NOISY_MSGF_MSG
    1: typedef struct {
    1:   char * mStr;
    1:   int    mId;
    1: } MSGFEventMsgInfo;
    1: 
    1: MSGFEventMsgInfo gMSGFEvents[] = {
    1:   "MSGF_DIALOGBOX",      0,
    1:   "MSGF_MESSAGEBOX",     1,
    1:   "MSGF_MENU",           2,
    1:   "MSGF_SCROLLBAR",      5,
    1:   "MSGF_NEXTWINDOW",     6,
    1:   "MSGF_MAX",            8,
    1:   "MSGF_USER",           4096,
    1:   NULL, 0};
    1: 
    1:   void PrintEvent(UINT msg, PRBool aShowAllEvents, PRBool aShowMouseMoves);
    1:   int gLastMsgCode = 0;
    1: 
    1: #define DISPLAY_NMM_PRT(_arg) printf((_arg));
    1: #else
    1: #define DISPLAY_NMM_PRT(_arg)
    1: #endif
    1: 
    1: 
    1: 
    1: #ifndef WINCE
    1: //-------------------------------------------------------------------------
    1: // Schedules a timer for a window, so we can rollup after processing the hook event
    1: void nsWindow::ScheduleHookTimer(HWND aWnd, UINT aMsgId)
    1: {
    1:   // In some cases multiple hooks may be scheduled
    1:   // so ignore any other requests once one timer is scheduled
    1:   if (gHookTimerId == 0) {
    1:     // Remember the window handle and the message ID to be used later
    1:     gRollupMsgId = aMsgId;
    1:     gRollupMsgWnd = aWnd;
    1:     // Schedule native timer for doing the rollup after
    1:     // this event is done being processed
    1:     gHookTimerId = ::SetTimer(NULL, 0, 0, (TIMERPROC)HookTimerForPopups);
    1:     NS_ASSERTION(gHookTimerId, "Timer couldn't be created.");
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: // Process Menu messages
    1: // Rollup when when is clicked
    1: 
    1: LRESULT CALLBACK nsWindow::MozSpecialMsgFilter(int code, WPARAM wParam, LPARAM lParam)
    1: {
    1: #ifdef DISPLAY_NOISY_MSGF_MSG
    1:   if (gProcessHook) {
    1:     MSG* pMsg = (MSG*)lParam;
    1: 
    1:     int inx = 0;
    1:     while (gMSGFEvents[inx].mId != code && gMSGFEvents[inx].mStr != NULL) {
    1:       inx++;
    1:     }
    1:     if (code != gLastMsgCode) {
    1:       if (gMSGFEvents[inx].mId == code) {
    1: #ifdef DEBUG
    1:         printf("MozSpecialMessageProc - code: 0x%X  - %s  hw: %p\n", code, gMSGFEvents[inx].mStr, pMsg->hwnd);
    1: #endif
    1:       } else {
    1: #ifdef DEBUG
    1:         printf("MozSpecialMessageProc - code: 0x%X  - %d  hw: %p\n", code, gMSGFEvents[inx].mId, pMsg->hwnd);
    1: #endif
    1:       }
    1:       gLastMsgCode = code;
    1:     }
    1:     PrintEvent(pMsg->message, FALSE, FALSE);
    1:   }
    1: #endif
    1: 
    1:   if (gProcessHook && code == MSGF_MENU) {
    1:     MSG* pMsg = (MSG*)lParam;
    1:     ScheduleHookTimer( pMsg->hwnd, pMsg->message);
    1:   }
    1: 
    1:   return ::CallNextHookEx(gMsgFilterHook, code, wParam, lParam);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: // Process all mouse messages
    1: // Roll up when a click is in a native window that doesn't have an nsIWidget
    1: LRESULT CALLBACK nsWindow::MozSpecialMouseProc(int code, WPARAM wParam, LPARAM lParam)
    1: {
    1:   if (gProcessHook) {
21999:     switch (wParam) {
21999:       case WM_LBUTTONDOWN:
21999:       case WM_RBUTTONDOWN:
21999:       case WM_MBUTTONDOWN:
21999:       case WM_MOUSEWHEEL:
21999:       case WM_MOUSEHWHEEL:
21999:       {
    1:         MOUSEHOOKSTRUCT* ms = (MOUSEHOOKSTRUCT*)lParam;
    1:         nsIWidget* mozWin = (nsIWidget*)GetNSWindowPtr(ms->hwnd);
21999:         if (mozWin) {
21999:           // If this window is windowed plugin window, the mouse events are not
21999:           // sent to us.
21999:           if (static_cast<nsWindow*>(mozWin)->mIsPluginWindow)
    1:             ScheduleHookTimer(ms->hwnd, (UINT)wParam);
21999:         } else {
21999:           ScheduleHookTimer(ms->hwnd, (UINT)wParam);
21999:         }
21999:         break;
    1:       }
    1:     }
    1:   }
    1:   return ::CallNextHookEx(gCallMouseHook, code, wParam, lParam);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: // Process all messages
    1: // Roll up when the window is moving, or is resizing or when maximized or mininized
    1: LRESULT CALLBACK nsWindow::MozSpecialWndProc(int code, WPARAM wParam, LPARAM lParam)
    1: {
    1: #ifdef DISPLAY_NOISY_MSGF_MSG
    1:   if (gProcessHook) {
    1:     CWPSTRUCT* cwpt = (CWPSTRUCT*)lParam;
    1:     PrintEvent(cwpt->message, FALSE, FALSE);
    1:   }
    1: #endif
    1: 
    1:   if (gProcessHook) {
    1:     CWPSTRUCT* cwpt = (CWPSTRUCT*)lParam;
    1:     if (cwpt->message == WM_MOVING ||
    1:         cwpt->message == WM_SIZING ||
    1:         cwpt->message == WM_GETMINMAXINFO) {
    1:       ScheduleHookTimer(cwpt->hwnd, (UINT)cwpt->message);
    1:     }
    1:   }
    1: 
    1:   return ::CallNextHookEx(gCallProcHook, code, wParam, lParam);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: // Register the special "hooks" for dropdown processing
    1: 
    1: void nsWindow::RegisterSpecialDropdownHooks()
    1: {
    1:   NS_ASSERTION(!gMsgFilterHook, "gMsgFilterHook must be NULL!");
    1:   NS_ASSERTION(!gCallProcHook,  "gCallProcHook must be NULL!");
    1: 
    1:   DISPLAY_NMM_PRT("***************** Installing Msg Hooks ***************\n");
    1: 
    1:   //HMODULE hMod = GetModuleHandle("gkwidget.dll");
    1: 
    1:   // Install msg hook for moving the window and resizing
    1:   if (!gMsgFilterHook) {
    1:     DISPLAY_NMM_PRT("***** Hooking gMsgFilterHook!\n");
    1:     gMsgFilterHook = SetWindowsHookEx(WH_MSGFILTER, MozSpecialMsgFilter, NULL, GetCurrentThreadId());
    1: #ifdef DISPLAY_NOISY_MSGF_MSG
    1:     if (!gMsgFilterHook) {
    1:       printf("***** SetWindowsHookEx is NOT installed for WH_MSGFILTER!\n");
    1:     }
    1: #endif
    1:   }
    1: 
    1:   // Install msg hook for menus
    1:   if (!gCallProcHook) {
    1:     DISPLAY_NMM_PRT("***** Hooking gCallProcHook!\n");
    1:     gCallProcHook  = SetWindowsHookEx(WH_CALLWNDPROC, MozSpecialWndProc, NULL, GetCurrentThreadId());
    1: #ifdef DISPLAY_NOISY_MSGF_MSG
    1:     if (!gCallProcHook) {
    1:       printf("***** SetWindowsHookEx is NOT installed for WH_CALLWNDPROC!\n");
    1:     }
    1: #endif
    1:   }
    1: 
    1:   // Install msg hook for the mouse
    1:   if (!gCallMouseHook) {
    1:     DISPLAY_NMM_PRT("***** Hooking gCallMouseHook!\n");
    1:     gCallMouseHook  = SetWindowsHookEx(WH_MOUSE, MozSpecialMouseProc, NULL, GetCurrentThreadId());
    1: #ifdef DISPLAY_NOISY_MSGF_MSG
    1:     if (!gCallMouseHook) {
    1:       printf("***** SetWindowsHookEx is NOT installed for WH_MOUSE!\n");
    1:     }
    1: #endif
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: // Unhook special message hooks for dropdowns
    1: 
    1: void nsWindow::UnregisterSpecialDropdownHooks()
    1: {
    1:   DISPLAY_NMM_PRT("***************** De-installing Msg Hooks ***************\n");
    1: 
    1:   if (gCallProcHook) {
    1:     DISPLAY_NMM_PRT("***** Unhooking gCallProcHook!\n");
    1:     if (!::UnhookWindowsHookEx(gCallProcHook)) {
    1:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for gCallProcHook!\n");
    1:     }
    1:     gCallProcHook = NULL;
    1:   }
    1: 
    1:   if (gMsgFilterHook) {
    1:     DISPLAY_NMM_PRT("***** Unhooking gMsgFilterHook!\n");
    1:     if (!::UnhookWindowsHookEx(gMsgFilterHook)) {
    1:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for gMsgFilterHook!\n");
    1:     }
    1:     gMsgFilterHook = NULL;
    1:   }
    1: 
    1:   if (gCallMouseHook) {
    1:     DISPLAY_NMM_PRT("***** Unhooking gCallMouseHook!\n");
    1:     if (!::UnhookWindowsHookEx(gCallMouseHook)) {
    1:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for gCallMouseHook!\n");
    1:     }
    1:     gCallMouseHook = NULL;
    1:   }
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: // This timer is designed to only fire one time at most each time a "hook" function
    1: // is used to rollup the dropdown
    1: // In some cases, the timer may be scheduled from the hook, but that hook event or
    1: // a subsequent event may roll up the dropdown before this timer function is executed.
    1: //
    1: // For example, if an MFC control takes focus, the combobox will lose focus and rollup
    1: // before this function fires.
    1: //
    1: VOID CALLBACK nsWindow::HookTimerForPopups(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
    1: {
    1:   if (gHookTimerId != 0) {
    1:     // if the window is NULL then we need to use the ID to kill the timer
    1:     BOOL status = ::KillTimer(NULL, gHookTimerId);
    1:     NS_ASSERTION(status, "Hook Timer was not killed.");
    1:     gHookTimerId = 0;
    1:   }
    1: 
    1:   if (gRollupMsgId != 0) {
    1:     // Note: DealWithPopups does the check to make sure that
    1:     // gRollupListener and gRollupWidget are not NULL
    1:     LRESULT popupHandlingResult;
 8591:     nsAutoRollup autoRollup;
    1:     DealWithPopups(gRollupMsgWnd, gRollupMsgId, 0, 0, &popupHandlingResult);
    1:     gRollupMsgId = 0;
    1:     gRollupMsgWnd = NULL;
    1:   }
    1: }
    1: #endif // WinCE
    1: 
21999: static PRBool IsDifferentThreadWindow(HWND aWnd)
21999: {
21999:   return ::GetCurrentThreadId() != ::GetWindowThreadProcessId(aWnd, NULL);
21999: }
21999: 
    1: //
    1: // DealWithPopups
    1: //
    1: // Handle events that may cause a popup (combobox, XPMenu, etc) to need to rollup.
    1: //
    1: 
    1: BOOL
    1: nsWindow :: DealWithPopups ( HWND inWnd, UINT inMsg, WPARAM inWParam, LPARAM inLParam, LRESULT* outResult )
    1: {
    1:   if (gRollupListener && gRollupWidget && ::IsWindowVisible(inWnd)) {
    1: 
    1:     if (inMsg == WM_LBUTTONDOWN || inMsg == WM_RBUTTONDOWN || inMsg == WM_MBUTTONDOWN ||
21999:         inMsg == WM_MOUSEWHEEL || inMsg == WM_MOUSEHWHEEL || inMsg == WM_ACTIVATE ||
21999:         (inMsg == WM_KILLFOCUS && IsDifferentThreadWindow((HWND)inWParam))
    1: #ifndef WINCE
    1:         || 
    1:         inMsg == WM_NCRBUTTONDOWN || 
    1:         inMsg == WM_MOVING || 
    1:         inMsg == WM_SIZING || 
    1:         inMsg == WM_NCLBUTTONDOWN || 
    1:         inMsg == WM_NCMBUTTONDOWN ||
    1:         inMsg == WM_MOUSEACTIVATE ||
    1:         inMsg == WM_ACTIVATEAPP ||
22419:         inMsg == WM_MENUSELECT
    1: #endif
    1:         )
    1:     {
    1:       // Rollup if the event is outside the popup.
    1:       PRBool rollup = !nsWindow::EventIsInsideWindow(inMsg, (nsWindow*)gRollupWidget);
    1: 
    1:       if (rollup && (inMsg == WM_MOUSEWHEEL || inMsg == WM_MOUSEHWHEEL))
    1:       {
    1:         gRollupListener->ShouldRollupOnMouseWheelEvent(&rollup);
    1:         *outResult = PR_TRUE;
    1:       }
    1: 
    1:       // If we're dealing with menus, we probably have submenus and we don't
    1:       // want to rollup if the click is in a parent menu of the current submenu.
    1:       if (rollup) {
    1:         nsCOMPtr<nsIMenuRollup> menuRollup ( do_QueryInterface(gRollupListener) );
    1:         if ( menuRollup ) {
10352:           nsAutoTArray<nsIWidget*, 5> widgetChain;
10352:           menuRollup->GetSubmenuWidgetChain ( &widgetChain );
10352:           for ( PRUint32 i = 0; i < widgetChain.Length(); ++i ) {
10352:             nsIWidget* widget = widgetChain[i];
10352:             if ( nsWindow::EventIsInsideWindow(inMsg, (nsWindow*)widget) ) {
    1:               rollup = PR_FALSE;
    1:               break;
    1:             }
    1:           } // foreach parent menu widget
    1:         } // if rollup listener knows about menus
    1:       }
    1: 
    1: #ifndef WINCE
    1:       if (inMsg == WM_MOUSEACTIVATE) {
    1:         // Prevent the click inside the popup from causing a change in window
    1:         // activation. Since the popup is shown non-activated, we need to eat
    1:         // any requests to activate the window while it is displayed. Windows
    1:         // will automatically activate the popup on the mousedown otherwise.
    1:         if (!rollup) {
    1:           *outResult = MA_NOACTIVATE;
    1:           return TRUE;
    1:         }
    1:         else
    1:         {
    1:           UINT uMsg = HIWORD(inLParam);
    1:           if (uMsg == WM_MOUSEMOVE)
    1:           {
    1:             // WM_MOUSEACTIVATE cause by moving the mouse - X-mouse (eg. TweakUI)
    1:             // must be enabled in Windows.
    1:             gRollupListener->ShouldRollupOnMouseActivate(&rollup);
    1:             if (!rollup)
    1:             {
    1:               *outResult = MA_NOACTIVATE;
    1:               return true;
    1:             }
    1:           }
    1:         }
    1:       }
    1:       // if we've still determined that we should still rollup everything, do it.
    1:       else
    1: #endif
    1:       if ( rollup ) {
21750:         // gRollupConsumeRollupEvent may be modified by
21750:         // nsIRollupListener::Rollup.
21750:         PRBool consumeRollupEvent = gRollupConsumeRollupEvent;
 8591:         // only need to deal with the last rollup for left mouse down events.
 8591:         gRollupListener->Rollup(inMsg == WM_LBUTTONDOWN ? &mLastRollup : nsnull);
    1: 
    1:         // Tell hook to stop processing messages
    1:         gProcessHook = PR_FALSE;
    1:         gRollupMsgId = 0;
    1:         gRollupMsgWnd = NULL;
    1: 
    1:         // return TRUE tells Windows that the event is consumed,
    1:         // false allows the event to be dispatched
    1:         //
    1:         // So if we are NOT supposed to be consuming events, let it go through
21750:         if (consumeRollupEvent && inMsg != WM_RBUTTONDOWN) {
    1:           *outResult = TRUE;
    1:           return TRUE;
    1:         }
    1:       }
    1:     } // if event that might trigger a popup to rollup
    1:   } // if rollup listeners registered
    1: 
    1:   return FALSE;
    1: } // DealWithPopups
    1: 
    1: 
    1: 
    1: #ifdef ACCESSIBILITY
    1: already_AddRefed<nsIAccessible> nsWindow::GetRootAccessible()
    1: {
    1:   nsWindow::gIsAccessibilityOn = TRUE;
    1: 
    1:   if (mIsDestroying || mOnDestroyCalled || mWindowType == eWindowType_invisible) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsIAccessible *rootAccessible = nsnull;
    1: 
    1:   // If accessibility is turned on, we create this even before it is requested
    1:   // when the window gets focused. We need it to be created early so it can 
    1:   // generate accessibility events right away
    1:   nsWindow* accessibleWindow = nsnull;
    1:   if (mContentType != eContentTypeInherit) {
    1:     // We're on a MozillaContentWindowClass or MozillaUIWindowClass window.
    1:     // Search for the correct visible child window to get an accessible 
    1:     // document from. Make sure to use an active child window
    1:     HWND accessibleWnd = ::GetTopWindow(mWnd);
    1:     while (accessibleWnd) {
    1:       // Loop through windows and find the first one with accessibility info
    1:       accessibleWindow = GetNSWindowPtr(accessibleWnd);
    1:       if (accessibleWindow) {
    1:         accessibleWindow->DispatchAccessibleEvent(NS_GETACCESSIBLE, &rootAccessible);
    1:         if (rootAccessible) {
    1:           break;  // Success, one of the child windows was active
    1:         }
    1:       }
    1:       accessibleWnd = ::GetNextWindow(accessibleWnd, GW_HWNDNEXT);
    1:     }
    1:   }
    1:   else {
    1:     DispatchAccessibleEvent(NS_GETACCESSIBLE, &rootAccessible);
    1:   }
    1:   return rootAccessible;
    1: }
    1: 
    1: HINSTANCE nsWindow::gmAccLib = 0;
    1: LPFNLRESULTFROMOBJECT nsWindow::gmLresultFromObject = 0;
    1: 
    1: STDMETHODIMP_(LRESULT) nsWindow::LresultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN pAcc)
    1: {
    1:   // open the dll dynamically
    1:   if (!gmAccLib)
18534:     gmAccLib =::LoadLibraryW(L"OLEACC.DLL");
    1: 
    1:   if (gmAccLib) {
    1:     if (!gmLresultFromObject)
    1:       gmLresultFromObject = (LPFNLRESULTFROMOBJECT)GetProcAddress(gmAccLib,"LresultFromObject");
    1: 
    1:     if (gmLresultFromObject)
    1:       return gmLresultFromObject(riid,wParam,pAcc);
    1:   }
    1: 
    1:   return 0;
    1: }
    1: #endif
    1: 
    1: #ifdef MOZ_XUL
    1: 
19016: nsWindow* nsWindow::GetTopLevelWindow(PRBool aStopOnDialogOrPopup)
    1: {
    1:   nsWindow* curWindow = this;
    1: 
19016:   while (PR_TRUE) {
19016:     if (aStopOnDialogOrPopup) {
19016:       switch (curWindow->mWindowType) {
19016:         case eWindowType_dialog:
19016:         case eWindowType_popup:
19016:           return curWindow;
19016:       }
19016:     }
19016: 
27505:     // Retrieve the top level parent or owner window
27505:     nsWindow* parentWindow = curWindow->GetParentWindow(PR_TRUE);
19016: 
19016:     if (!parentWindow)
19016:       return curWindow;
19016: 
    1:     curWindow = parentWindow;
    1:   }
    1: }
    1: 
    1: gfxASurface *nsWindow::GetThebesSurface()
    1: {
    1:   if (mPaintDC)
    1:     return (new gfxWindowsSurface(mPaintDC));
    1: 
    1:   return (new gfxWindowsSurface(mWnd));
    1: }
    1: 
    1: void nsWindow::ResizeTranslucentWindow(PRInt32 aNewWidth, PRInt32 aNewHeight, PRBool force)
    1: {
    1:   if (!force && aNewWidth == mBounds.width && aNewHeight == mBounds.height)
    1:     return;
    1: 
 9499:   mTransparentSurface = new gfxWindowsSurface(gfxIntSize(aNewWidth, aNewHeight), gfxASurface::ImageFormatARGB32);
 9499:   mMemoryDC = mTransparentSurface->GetDC();
    1: }
    1: 
16601: nsTransparencyMode nsWindow::GetTransparencyMode()
16601: {
19016:   return GetTopLevelWindow(PR_TRUE)->GetWindowTranslucencyInner();
16601: }
16601: 
16601: void nsWindow::SetTransparencyMode(nsTransparencyMode aMode)
16601: {
19016:   GetTopLevelWindow(PR_TRUE)->SetWindowTranslucencyInner(aMode);
16601: }
16601: 
16601: void nsWindow::SetWindowTranslucencyInner(nsTransparencyMode aMode)
16601: {
19822: #ifndef WINCE
19822: 
16601:   if (aMode == mTransparencyMode)
16601:     return;
    1: 
    1:   HWND hWnd = GetTopLevelHWND(mWnd, PR_TRUE);
    1:   nsWindow* topWindow = GetNSWindowPtr(hWnd);
    1: 
    1:   if (!topWindow)
    1:   {
    1:     NS_WARNING("Trying to use transparent chrome in an embedded context");
16601:     return;
    1:   }
    1: 
25349:   LONG_PTR style = 0, exStyle = 0;
16601:   switch(aMode) {
16601:     case eTransparencyTransparent:
16601:       exStyle |= WS_EX_LAYERED;
16601:     case eTransparencyOpaque:
16601:     case eTransparencyGlass:
16601:       topWindow->mTransparencyMode = aMode;
16601:       break;
    1:   }
19222: 
19222:   style |= topWindow->WindowStyle();
19222:   exStyle |= topWindow->WindowExStyle();
19222: 
25427:   if (aMode == eTransparencyTransparent) {
25427:     style &= ~(WS_CAPTION | WS_THICKFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX);
25427:     exStyle &= ~(WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE | WS_EX_STATICEDGE);
25427:   }
25427: 
19016:   VERIFY_WINDOW_STYLE(style);
25349:   ::SetWindowLongPtrW(hWnd, GWL_STYLE, style);
25349:   ::SetWindowLongPtrW(hWnd, GWL_EXSTYLE, exStyle);
    1: 
16601:   mTransparencyMode = aMode;
16601: 
16601:   SetupTranslucentWindowMemoryBitmap(aMode);
16601:   MARGINS margins = { 0, 0, 0, 0 };
16601:   if(eTransparencyGlass == aMode)
16601:     margins.cxLeftWidth = -1;
16601:   if(nsUXThemeData::sHaveCompositor)
16601:     nsUXThemeData::dwmExtendFrameIntoClientAreaPtr(hWnd, &margins);
19822: #endif
16601: }
16601: 
16601: void nsWindow::SetupTranslucentWindowMemoryBitmap(nsTransparencyMode aMode)
16601: {
16601:   if (eTransparencyTransparent == aMode) {
    1:     ResizeTranslucentWindow(mBounds.width, mBounds.height, PR_TRUE);
    1:   } else {
 9499:     mTransparentSurface = nsnull;
    1:     mMemoryDC = NULL;
    1:   }
    1: }
    1: 
    1: nsresult nsWindow::UpdateTranslucentWindow()
    1: {
19822: #ifndef WINCE
    1:   if (mBounds.IsEmpty())
    1:     return NS_OK;
    1: 
    1:   ::GdiFlush();
    1: 
    1:   BLENDFUNCTION bf = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
    1:   SIZE winSize = { mBounds.width, mBounds.height };
    1:   POINT srcPos = { 0, 0 };
    1:   HWND hWnd = GetTopLevelHWND(mWnd, PR_TRUE);
    1:   RECT winRect;
    1:   ::GetWindowRect(hWnd, &winRect);
    1: 
    1:   // perform the alpha blend
 5223:   if (!::UpdateLayeredWindow(hWnd, NULL, (POINT*)&winRect, &winSize, mMemoryDC, &srcPos, 0, &bf, ULW_ALPHA))
 5223:     return NS_ERROR_FAILURE;
19822: #endif
 5223: 
 5223:   return NS_OK;
 5223: }
 5223: 
19822: #endif //MOZ_XUL
