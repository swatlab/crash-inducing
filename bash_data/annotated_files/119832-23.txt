  8186: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
  8186:  *
 99778:  * This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  8186: 
  7105: #include "nsAppDirectoryServiceDefs.h"
  7105: #include "nsStreamUtils.h"
  7105: #include "nsNetUtil.h"
  7105: #include "nsILineInputStream.h"
  7105: #include "nsPromiseFlatString.h"
  7105: #include "nsTArray.h"
  7105: 
  7105: #include "cert.h"
 13140: #include "base64.h"
  7105: #include "nsNSSComponent.h"
 97210: #include "nsSSLStatus.h"
  7105: #include "nsNSSCertificate.h"
  7105: #include "nsNSSCleaner.h"
  7105: 
  7105: #ifdef DEBUG
  7105: #ifndef PSM_ENABLE_TEST_EV_ROOTS
  7105: #define PSM_ENABLE_TEST_EV_ROOTS
  7105: #endif
  7105: #endif
  7105: 
 10258: #ifdef PR_LOGGING
 10258: extern PRLogModuleInfo* gPIPNSSLog;
 10258: #endif
 10258: 
  7105: NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
  7105: NSSCleanupAutoPtrClass(CERTCertList, CERT_DestroyCertList)
 80486: NSSCleanupAutoPtrClass_WithParam(SECItem, SECITEM_FreeItem, TrueParam, true)
  7105: 
  7105: #define CONST_OID static const unsigned char
  7105: #define OI(x) { siDEROID, (unsigned char *)x, sizeof x }
  7105: 
  7105: struct nsMyTrustedEVInfo
  7105: {
 29205:   const char *dotted_oid;
 29205:   const char *oid_name; // Set this to null to signal an invalid structure,
  7105:                   // (We can't have an empty list, so we'll use a dummy entry)
  7105:   SECOidTag oid_tag;
 29205:   const char *ev_root_sha1_fingerprint;
 29205:   const char *issuer_base64;
 29205:   const char *serial_base64;
 13140:   CERTCertificate *cert;
  7105: };
  7105: 
  7105: static struct nsMyTrustedEVInfo myTrustedEVInfos[] = {
 69348:   /*
 69348:    * IMPORTANT! When extending this list, 
 69348:    * pairs of dotted_oid and oid_name should always be unique pairs.
 69348:    * In other words, if you add another list, that uses the same dotted_oid
 69348:    * as an existing entry, then please use the same oid_name.
 69348:    */
  7105:   {
 28724:     // CN=WellsSecure Public Root Certificate Authority,OU=Wells Fargo Bank NA,O=Wells Fargo WellsSecure,C=US
 28724:     "2.16.840.1.114171.500.9",
 28724:     "WellsSecure EV OID",
 28724:     SEC_OID_UNKNOWN,
 28724:     "E7:B4:F6:9D:61:EC:90:69:DB:7E:90:A7:40:1A:3C:F4:7D:4F:E8:EE",
 28724:     "MIGFMQswCQYDVQQGEwJVUzEgMB4GA1UECgwXV2VsbHMgRmFyZ28gV2VsbHNTZWN1"
 28724:     "cmUxHDAaBgNVBAsME1dlbGxzIEZhcmdvIEJhbmsgTkExNjA0BgNVBAMMLVdlbGxz"
 28724:     "U2VjdXJlIFB1YmxpYyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eQ==",
 28724:     "AQ==",
106838:     nullptr
 28724:   },
 28724:   {
 28724:     // OU=Security Communication EV RootCA1,O="SECOM Trust Systems CO.,LTD.",C=JP
 28724:     "1.2.392.200091.100.721.1",
 28724:     "SECOM EV OID",
 28724:     SEC_OID_UNKNOWN,
 28724:     "FE:B8:C4:32:DC:F9:76:9A:CE:AE:3D:D8:90:8F:FD:28:86:65:64:7D",
 28724:     "MGAxCzAJBgNVBAYTAkpQMSUwIwYDVQQKExxTRUNPTSBUcnVzdCBTeXN0ZW1zIENP"
 28724:     "LixMVEQuMSowKAYDVQQLEyFTZWN1cml0eSBDb21tdW5pY2F0aW9uIEVWIFJvb3RD"
 28724:     "QTE=",
 28724:     "AA==",
106838:     nullptr
 28724:   },
 28724:   {
 28724:     // CN=Cybertrust Global Root,O=Cybertrust, Inc
 28724:     "1.3.6.1.4.1.6334.1.100.1",
 28724:     "Cybertrust EV OID",
 28724:     SEC_OID_UNKNOWN,
 28724:     "5F:43:E5:B1:BF:F8:78:8C:AC:1C:C7:CA:4A:9A:C6:22:2B:CC:34:C6",
 28724:     "MDsxGDAWBgNVBAoTD0N5YmVydHJ1c3QsIEluYzEfMB0GA1UEAxMWQ3liZXJ0cnVz"
 28724:     "dCBHbG9iYWwgUm9vdA==",
 28724:     "BAAAAAABD4WqLUg=",
106838:     nullptr
 28724:   },
 28724:   {
 28724:     // CN=SwissSign Gold CA - G2,O=SwissSign AG,C=CH
 28724:     "2.16.756.1.89.1.2.1.1",
 28724:     "SwissSign EV OID",
 28724:     SEC_OID_UNKNOWN,
 28724:     "D8:C5:38:8A:B7:30:1B:1B:6E:D4:7A:E6:45:25:3A:6F:9F:1A:27:61",
 28724:     "MEUxCzAJBgNVBAYTAkNIMRUwEwYDVQQKEwxTd2lzc1NpZ24gQUcxHzAdBgNVBAMT"
 28724:     "FlN3aXNzU2lnbiBHb2xkIENBIC0gRzI=",
 28724:     "ALtAHEP1Xk+w",
106838:     nullptr
 28724:   },
 28724:   {
 28724:     // CN=StartCom Certification Authority,OU=Secure Digital Certificate Signing,O=StartCom Ltd.,C=IL
119351:     "1.3.6.1.4.1.23223.1.1.1",
 28724:     "StartCom EV OID",
 28724:     SEC_OID_UNKNOWN,
 28724:     "3E:2B:F7:F2:03:1B:96:F3:8C:E6:C4:D8:A8:5D:3E:2D:58:47:6A:0F",
 28724:     "MH0xCzAJBgNVBAYTAklMMRYwFAYDVQQKEw1TdGFydENvbSBMdGQuMSswKQYDVQQL"
 28724:     "EyJTZWN1cmUgRGlnaXRhbCBDZXJ0aWZpY2F0ZSBTaWduaW5nMSkwJwYDVQQDEyBT"
 28724:     "dGFydENvbSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eQ==",
 28724:     "AQ==",
106838:     nullptr
 28724:   },
 28724:   {
119351:     // CN=StartCom Certification Authority,OU=Secure Digital Certificate Signing,O=StartCom Ltd.,C=IL
119351:     "1.3.6.1.4.1.23223.1.1.1",
119351:     "StartCom EV OID",
119351:     SEC_OID_UNKNOWN,
119351:     "A3:F1:33:3F:E2:42:BF:CF:C5:D1:4E:8F:39:42:98:40:68:10:D1:A0",
119351:     "MH0xCzAJBgNVBAYTAklMMRYwFAYDVQQKEw1TdGFydENvbSBMdGQuMSswKQYDVQQL"
119351:     "EyJTZWN1cmUgRGlnaXRhbCBDZXJ0aWZpY2F0ZSBTaWduaW5nMSkwJwYDVQQDEyBT"
119351:     "dGFydENvbSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eQ==",
119351:     "LQ==",
119351:     nullptr
119351:   },
119351:   {
119351:     // CN=StartCom Certification Authority G2,O=StartCom Ltd.,C=IL
119351:     "1.3.6.1.4.1.23223.1.1.1",
119351:     "StartCom EV OID",
119351:     SEC_OID_UNKNOWN,
119351:     "31:F1:FD:68:22:63:20:EE:C6:3B:3F:9D:EA:4A:3E:53:7C:7C:39:17",
119351:     "MFMxCzAJBgNVBAYTAklMMRYwFAYDVQQKEw1TdGFydENvbSBMdGQuMSwwKgYDVQQD"
119351:     "EyNTdGFydENvbSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSBHMg==",
119351:     "Ow==",
119351:     nullptr
119351:   },
119351:   {
 14093:     // CN=VeriSign Class 3 Public Primary Certification Authority - G5,OU="(c) 2006 VeriSign, Inc. - For authorized use only",OU=VeriSign Trust Network,O="VeriSign, Inc.",C=US
 14093:     "2.16.840.1.113733.1.7.23.6",
 14093:     "VeriSign EV OID",
 14093:     SEC_OID_UNKNOWN,
 14093:     "4E:B6:D5:78:49:9B:1C:CF:5F:58:1E:AD:56:BE:3D:9B:67:44:A5:E5",
 14093:     "MIHKMQswCQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNV"
 14093:     "BAsTFlZlcmlTaWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAyMDA2IFZl"
 14093:     "cmlTaWduLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMT"
 14093:     "PFZlcmlTaWduIENsYXNzIDMgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBB"
 14093:     "dXRob3JpdHkgLSBHNQ==",
 14093:     "GNrRniZ96LtKIVjNzGs7Sg==",
106838:     nullptr
 14093:   },
 14093:   {
 14093:     // CN=GeoTrust Primary Certification Authority,O=GeoTrust Inc.,C=US
 14093:     "1.3.6.1.4.1.14370.1.6",
 14093:     "GeoTrust EV OID",
 14093:     SEC_OID_UNKNOWN,
 14093:     "32:3C:11:8E:1B:F7:B8:B6:52:54:E2:E2:10:0D:D6:02:90:37:F0:96",
 14093:     "MFgxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMTEwLwYDVQQD"
 14093:     "EyhHZW9UcnVzdCBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5",
 14093:     "GKy1av1pthU6Y2yv2vrEoQ==",
106838:     nullptr
 14093:   },
 14093:   {
 14093:     // CN=thawte Primary Root CA,OU="(c) 2006 thawte, Inc. - For authorized use only",OU=Certification Services Division,O="thawte, Inc.",C=US
 14093:     "2.16.840.1.113733.1.7.48.1",
 14093:     "Thawte EV OID",
 14093:     SEC_OID_UNKNOWN,
 14093:     "91:C6:D6:EE:3E:8A:C8:63:84:E5:48:C2:99:29:5C:75:6C:81:7B:81",
 14093:     "MIGpMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMdGhhd3RlLCBJbmMuMSgwJgYDVQQL"
 14093:     "Ex9DZXJ0aWZpY2F0aW9uIFNlcnZpY2VzIERpdmlzaW9uMTgwNgYDVQQLEy8oYykg"
 14093:     "MjAwNiB0aGF3dGUsIEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTEfMB0G"
 14093:     "A1UEAxMWdGhhd3RlIFByaW1hcnkgUm9vdCBDQQ==",
 14093:     "NE7VVyDV7exJ9C/ON9srbQ==",
106838:     nullptr
 14093:   },
 14093:   {
 14093:     // CN=XRamp Global Certification Authority,O=XRamp Security Services Inc,OU=www.xrampsecurity.com,C=US
 14093:     "2.16.840.1.114404.1.1.2.4.1",
 14093:     "Trustwave EV OID",
 14093:     SEC_OID_UNKNOWN,
 14093:     "B8:01:86:D1:EB:9C:86:A5:41:04:CF:30:54:F3:4C:52:B7:E5:58:C6",
 14093:     "MIGCMQswCQYDVQQGEwJVUzEeMBwGA1UECxMVd3d3LnhyYW1wc2VjdXJpdHkuY29t"
 14093:     "MSQwIgYDVQQKExtYUmFtcCBTZWN1cml0eSBTZXJ2aWNlcyBJbmMxLTArBgNVBAMT"
 14093:     "JFhSYW1wIEdsb2JhbCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eQ==",
 14093:     "UJRs7Bjq1ZxN1ZfvdY+grQ==",
106838:     nullptr
 14093:   },
 14093:   {
 14093:     // CN=SecureTrust CA,O=SecureTrust Corporation,C=US
 14093:     "2.16.840.1.114404.1.1.2.4.1",
 14093:     "Trustwave EV OID",
 14093:     SEC_OID_UNKNOWN,
 14093:     "87:82:C6:C3:04:35:3B:CF:D2:96:92:D2:59:3E:7D:44:D9:34:FF:11",
 14093:     "MEgxCzAJBgNVBAYTAlVTMSAwHgYDVQQKExdTZWN1cmVUcnVzdCBDb3Jwb3JhdGlv"
 14093:     "bjEXMBUGA1UEAxMOU2VjdXJlVHJ1c3QgQ0E=",
 14093:     "DPCOXAgWpa1Cf/DrJxhZ0A==",
106838:     nullptr
 14093:   },
 14093:   {
 14093:     // CN=Secure Global CA,O=SecureTrust Corporation,C=US
 14093:     "2.16.840.1.114404.1.1.2.4.1",
 14093:     "Trustwave EV OID",
 14093:     SEC_OID_UNKNOWN,
 14093:     "3A:44:73:5A:E5:81:90:1F:24:86:61:46:1E:3B:9C:C4:5F:F5:3A:1B",
 14093:     "MEoxCzAJBgNVBAYTAlVTMSAwHgYDVQQKExdTZWN1cmVUcnVzdCBDb3Jwb3JhdGlv"
 14093:     "bjEZMBcGA1UEAxMQU2VjdXJlIEdsb2JhbCBDQQ==",
 14093:     "B1YipOjUiolN9BPI8PjqpQ==",
106838:     nullptr
 14093:   },
 14093:   {
 20742:     // CN=COMODO ECC Certification Authority,O=COMODO CA Limited,L=Salford,ST=Greater Manchester,C=GB
 20742:     "1.3.6.1.4.1.6449.1.2.1.5.1",
 20742:     "Comodo EV OID",
 20742:     SEC_OID_UNKNOWN,
 20742:     "9F:74:4E:9F:2B:4D:BA:EC:0F:31:2C:50:B6:56:3B:8E:2D:93:C3:11",
 20742:     "MIGFMQswCQYDVQQGEwJHQjEbMBkGA1UECBMSR3JlYXRlciBNYW5jaGVzdGVyMRAw"
 20742:     "DgYDVQQHEwdTYWxmb3JkMRowGAYDVQQKExFDT01PRE8gQ0EgTGltaXRlZDErMCkG"
 20742:     "A1UEAxMiQ09NT0RPIEVDQyBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eQ==",
 20742:     "H0evqmIAcFBUTAGem2OZKg==",
106838:     nullptr
 20742:   },
 20742:   {
 14093:     // CN=COMODO Certification Authority,O=COMODO CA Limited,L=Salford,ST=Greater Manchester,C=GB
 14093:     "1.3.6.1.4.1.6449.1.2.1.5.1",
 14093:     "Comodo EV OID",
 14093:     SEC_OID_UNKNOWN,
 14093:     "66:31:BF:9E:F7:4F:9E:B6:C9:D5:A6:0C:BA:6A:BE:D1:F7:BD:EF:7B",
 14093:     "MIGBMQswCQYDVQQGEwJHQjEbMBkGA1UECBMSR3JlYXRlciBNYW5jaGVzdGVyMRAw"
 14093:     "DgYDVQQHEwdTYWxmb3JkMRowGAYDVQQKExFDT01PRE8gQ0EgTGltaXRlZDEnMCUG"
 14093:     "A1UEAxMeQ09NT0RPIENlcnRpZmljYXRpb24gQXV0aG9yaXR5",
 14093:     "ToEtioJl4AsC7j41AkblPQ==",
106838:     nullptr
 14093:   },
 14093:   {
 14093:     // CN=AddTrust External CA Root,OU=AddTrust External TTP Network,O=AddTrust AB,C=SE
 14093:     "1.3.6.1.4.1.6449.1.2.1.5.1",
 14093:     "Comodo EV OID",
 14093:     SEC_OID_UNKNOWN,
 14093:     "02:FA:F3:E2:91:43:54:68:60:78:57:69:4D:F5:E4:5B:68:85:18:68",
 14093:     "MG8xCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRUcnVzdCBBQjEmMCQGA1UECxMd"
 14093:     "QWRkVHJ1c3QgRXh0ZXJuYWwgVFRQIE5ldHdvcmsxIjAgBgNVBAMTGUFkZFRydXN0"
 14093:     "IEV4dGVybmFsIENBIFJvb3Q=",
 14093:     "AQ==",
106838:     nullptr
 14093:   },
 14093:   {
 14093:     // CN=UTN - DATACorp SGC,OU=http://www.usertrust.com,O=The USERTRUST Network,L=Salt Lake City,ST=UT,C=US
 14093:     "1.3.6.1.4.1.6449.1.2.1.5.1",
 14093:     "Comodo EV OID",
 14093:     SEC_OID_UNKNOWN,
 14093:     "58:11:9F:0E:12:82:87:EA:50:FD:D9:87:45:6F:4F:78:DC:FA:D6:D4",
 14093:     "MIGTMQswCQYDVQQGEwJVUzELMAkGA1UECBMCVVQxFzAVBgNVBAcTDlNhbHQgTGFr"
 14093:     "ZSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxITAfBgNVBAsT"
 14093:     "GGh0dHA6Ly93d3cudXNlcnRydXN0LmNvbTEbMBkGA1UEAxMSVVROIC0gREFUQUNv"
 14093:     "cnAgU0dD",
 14093:     "RL4Mi1AAIbQR0ypoBqmtaQ==",
106838:     nullptr
 14093:   },
 14093:   {
 14093:     // CN=UTN-USERFirst-Hardware,OU=http://www.usertrust.com,O=The USERTRUST Network,L=Salt Lake City,ST=UT,C=US
 14093:     "1.3.6.1.4.1.6449.1.2.1.5.1",
 14093:     "Comodo EV OID",
 14093:     SEC_OID_UNKNOWN,
 14093:     "04:83:ED:33:99:AC:36:08:05:87:22:ED:BC:5E:46:00:E3:BE:F9:D7",
 14093:     "MIGXMQswCQYDVQQGEwJVUzELMAkGA1UECBMCVVQxFzAVBgNVBAcTDlNhbHQgTGFr"
 14093:     "ZSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxITAfBgNVBAsT"
 14093:     "GGh0dHA6Ly93d3cudXNlcnRydXN0LmNvbTEfMB0GA1UEAxMWVVROLVVTRVJGaXJz"
 14093:     "dC1IYXJkd2FyZQ==",
 14093:     "RL4Mi1AAJLQR0zYq/mUK/Q==",
106838:     nullptr
 14093:   },
 14093:   {
 12711:     // OU=Go Daddy Class 2 Certification Authority,O=\"The Go Daddy Group, Inc.\",C=US
 12404:     "2.16.840.1.114413.1.7.23.3",
 12404:     "Go Daddy EV OID a",
 12404:     SEC_OID_UNKNOWN,
 12404:     "27:96:BA:E6:3F:18:01:E2:77:26:1B:A0:D7:77:70:02:8F:20:EE:E4",
 13140:     "MGMxCzAJBgNVBAYTAlVTMSEwHwYDVQQKExhUaGUgR28gRGFkZHkgR3JvdXAsIElu"
 13140:     "Yy4xMTAvBgNVBAsTKEdvIERhZGR5IENsYXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRo"
 13140:     "b3JpdHk=",
 13140:     "AA==",
106838:     nullptr
 12404:   },
 12404:   {
 69348:     // CN=Go Daddy Root Certificate Authority - G2,O="GoDaddy.com, Inc.",L=Scottsdale,ST=Arizona,C=US
 69348:     "2.16.840.1.114413.1.7.23.3",
 69348:     "Go Daddy EV OID a",
 69348:     SEC_OID_UNKNOWN,
 69348:     "47:BE:AB:C9:22:EA:E8:0E:78:78:34:62:A7:9F:45:C2:54:FD:E6:8B",
 69348:     "MIGDMQswCQYDVQQGEwJVUzEQMA4GA1UECBMHQXJpem9uYTETMBEGA1UEBxMKU2Nv"
 69348:     "dHRzZGFsZTEaMBgGA1UEChMRR29EYWRkeS5jb20sIEluYy4xMTAvBgNVBAMTKEdv"
 69348:     "IERhZGR5IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IC0gRzI=",
 69348:     "AA==",
106838:     nullptr
 69348:   },
 69348:   {
 12711:     // E=info@valicert.com,CN=http://www.valicert.com/,OU=ValiCert Class 2 Policy Validation Authority,O=\"ValiCert, Inc.\",L=ValiCert Validation Network
 12404:     "2.16.840.1.114413.1.7.23.3",
 12404:     "Go Daddy EV OID a",
 12404:     SEC_OID_UNKNOWN,
 12404:     "31:7A:2A:D0:7F:2B:33:5E:F5:A1:C3:4E:4B:57:E8:B7:D8:F1:FC:A6",
 13140:     "MIG7MSQwIgYDVQQHExtWYWxpQ2VydCBWYWxpZGF0aW9uIE5ldHdvcmsxFzAVBgNV"
 13140:     "BAoTDlZhbGlDZXJ0LCBJbmMuMTUwMwYDVQQLEyxWYWxpQ2VydCBDbGFzcyAyIFBv"
 13140:     "bGljeSBWYWxpZGF0aW9uIEF1dGhvcml0eTEhMB8GA1UEAxMYaHR0cDovL3d3dy52"
 13140:     "YWxpY2VydC5jb20vMSAwHgYJKoZIhvcNAQkBFhFpbmZvQHZhbGljZXJ0LmNvbQ==",
 13140:     "AQ==",
106838:     nullptr
 12404:   },
 12404:   {
 12711:     // E=info@valicert.com,CN=http://www.valicert.com/,OU=ValiCert Class 2 Policy Validation Authority,O=\"ValiCert, Inc.\",L=ValiCert Validation Network
 12404:     "2.16.840.1.114414.1.7.23.3",
 12404:     "Go Daddy EV OID b",
 12404:     SEC_OID_UNKNOWN,
 12404:     "31:7A:2A:D0:7F:2B:33:5E:F5:A1:C3:4E:4B:57:E8:B7:D8:F1:FC:A6",
 13140:     "MIG7MSQwIgYDVQQHExtWYWxpQ2VydCBWYWxpZGF0aW9uIE5ldHdvcmsxFzAVBgNV"
 13140:     "BAoTDlZhbGlDZXJ0LCBJbmMuMTUwMwYDVQQLEyxWYWxpQ2VydCBDbGFzcyAyIFBv"
 13140:     "bGljeSBWYWxpZGF0aW9uIEF1dGhvcml0eTEhMB8GA1UEAxMYaHR0cDovL3d3dy52"
 13140:     "YWxpY2VydC5jb20vMSAwHgYJKoZIhvcNAQkBFhFpbmZvQHZhbGljZXJ0LmNvbQ==",
 13140:     "AQ==",
106838:     nullptr
 12404:   },
 12404:   {
 12711:     // OU=Starfield Class 2 Certification Authority,O=\"Starfield Technologies, Inc.\",C=US
 12404:     "2.16.840.1.114414.1.7.23.3",
 12404:     "Go Daddy EV OID b",
 12404:     SEC_OID_UNKNOWN,
 12404:     "AD:7E:1C:28:B0:64:EF:8F:60:03:40:20:14:C3:D0:E3:37:0E:B5:8A",
 13140:     "MGgxCzAJBgNVBAYTAlVTMSUwIwYDVQQKExxTdGFyZmllbGQgVGVjaG5vbG9naWVz"
 13140:     "LCBJbmMuMTIwMAYDVQQLEylTdGFyZmllbGQgQ2xhc3MgMiBDZXJ0aWZpY2F0aW9u"
 13140:     "IEF1dGhvcml0eQ==",
 13140:     "AA==",
106838:     nullptr
 12404:   },
 12404:   {
 69348:     // CN=Starfield Root Certificate Authority - G2,O="Starfield Technologies, Inc.",L=Scottsdale,ST=Arizona,C=US
 69348:     "2.16.840.1.114414.1.7.23.3",
 69348:     "Go Daddy EV OID b",
 69348:     SEC_OID_UNKNOWN,
 69348:     "B5:1C:06:7C:EE:2B:0C:3D:F8:55:AB:2D:92:F4:FE:39:D4:E7:0F:0E",
 69348:     "MIGPMQswCQYDVQQGEwJVUzEQMA4GA1UECBMHQXJpem9uYTETMBEGA1UEBxMKU2Nv"
 69348:     "dHRzZGFsZTElMCMGA1UEChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjEy"
 69348:     "MDAGA1UEAxMpU3RhcmZpZWxkIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IC0g"
 69348:     "RzI=",
 69348:     "AA==",
106838:     nullptr
 69348:   },
 69348:   {
 12711:     // CN=DigiCert High Assurance EV Root CA,OU=www.digicert.com,O=DigiCert Inc,C=US
 12085:     "2.16.840.1.114412.2.1",
 12085:     "DigiCert EV OID",
 12085:     SEC_OID_UNKNOWN,
 13140:     "5F:B7:EE:06:33:E2:59:DB:AD:0C:4C:9A:E6:D3:8F:1A:61:C7:DC:25",
 13140:     "MGwxCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsT"
 13140:     "EHd3dy5kaWdpY2VydC5jb20xKzApBgNVBAMTIkRpZ2lDZXJ0IEhpZ2ggQXNzdXJh"
 13140:     "bmNlIEVWIFJvb3QgQ0E=",
 13140:     "AqxcJmoLQJuPC3nyrkYldw==",
106838:     nullptr
 12085:   },
 12085:   {
 12711:     // CN=QuoVadis Root CA 2,O=QuoVadis Limited,C=BM
 12084:     "1.3.6.1.4.1.8024.0.2.100.1.2",
 12084:     "Quo Vadis EV OID",
 12084:     SEC_OID_UNKNOWN,
 13140:     "CA:3A:FB:CF:12:40:36:4B:44:B2:16:20:88:80:48:39:19:93:7C:F7",
 13140:     "MEUxCzAJBgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMRswGQYD"
 13140:     "VQQDExJRdW9WYWRpcyBSb290IENBIDI=",
 13140:     "BQk=",
106838:     nullptr
 12084:   },
 12084:   {
 14913:     // CN=Network Solutions Certificate Authority,O=Network Solutions L.L.C.,C=US
 14913:     "1.3.6.1.4.1.782.1.2.1.8.1",
 14913:     "Network Solutions EV OID",
 14913:     SEC_OID_UNKNOWN,
 14913:     "74:F8:A3:C3:EF:E7:B3:90:06:4B:83:90:3C:21:64:60:20:E5:DF:CE",
 14913:     "MGIxCzAJBgNVBAYTAlVTMSEwHwYDVQQKExhOZXR3b3JrIFNvbHV0aW9ucyBMLkwu"
 14913:     "Qy4xMDAuBgNVBAMTJ05ldHdvcmsgU29sdXRpb25zIENlcnRpZmljYXRlIEF1dGhv"
 14913:     "cml0eQ==",
 14913:     "V8szb8JcFuZHFhfjkDFo4A==",
106838:     nullptr
 14913:   },
 14913:   {
 15740:     // CN=Entrust Root Certification Authority,OU="(c) 2006 Entrust, Inc.",OU=www.entrust.net/CPS is incorporated by reference,O="Entrust, Inc.",C=US
 15740:     "2.16.840.1.114028.10.1.2",
 15740:     "Entrust EV OID",
 15740:     SEC_OID_UNKNOWN,
 15740:     "B3:1E:B1:B7:40:E3:6C:84:02:DA:DC:37:D4:4D:F5:D4:67:49:52:F9",
 15740:     "MIGwMQswCQYDVQQGEwJVUzEWMBQGA1UEChMNRW50cnVzdCwgSW5jLjE5MDcGA1UE"
 15740:     "CxMwd3d3LmVudHJ1c3QubmV0L0NQUyBpcyBpbmNvcnBvcmF0ZWQgYnkgcmVmZXJl"
 15740:     "bmNlMR8wHQYDVQQLExYoYykgMjAwNiBFbnRydXN0LCBJbmMuMS0wKwYDVQQDEyRF"
 15740:     "bnRydXN0IFJvb3QgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHk=",
 15740:     "RWtQVA==",
106838:     nullptr
 15740:   },
 15740:   {
 17088:     // CN=GlobalSign Root CA,OU=Root CA,O=GlobalSign nv-sa,C=BE
 17088:     "1.3.6.1.4.1.4146.1.1",
 17088:     "GlobalSign EV OID",
 17088:     SEC_OID_UNKNOWN,
 17088:     "B1:BC:96:8B:D4:F4:9D:62:2A:A8:9A:81:F2:15:01:52:A4:1D:82:9C",
 17088:     "MFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRAwDgYD"
 17088:     "VQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxTaWduIFJvb3QgQ0E=",
 17088:     "BAAAAAABFUtaw5Q=",
106838:     nullptr
 17088:   },
 17088:   {
 17088:     // CN=GlobalSign,O=GlobalSign,OU=GlobalSign Root CA - R2
 17088:     "1.3.6.1.4.1.4146.1.1",
 17088:     "GlobalSign EV OID",
 17088:     SEC_OID_UNKNOWN,
 17088:     "75:E0:AB:B6:13:85:12:27:1C:04:F8:5F:DD:DE:38:E4:B7:24:2E:FE",
 17088:     "MEwxIDAeBgNVBAsTF0dsb2JhbFNpZ24gUm9vdCBDQSAtIFIyMRMwEQYDVQQKEwpH"
 17088:     "bG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWdu",
 17088:     "BAAAAAABD4Ym5g0=",
106838:     nullptr
 17088:   },
 17088:   {
 58225:     // CN=GlobalSign,O=GlobalSign,OU=GlobalSign Root CA - R3
 58225:     "1.3.6.1.4.1.4146.1.1",
 58225:     "GlobalSign EV OID",
 58225:     SEC_OID_UNKNOWN,
 58225:     "D6:9B:56:11:48:F0:1C:77:C5:45:78:C1:09:26:DF:5B:85:69:76:AD",
 58225:     "MEwxIDAeBgNVBAsTF0dsb2JhbFNpZ24gUm9vdCBDQSAtIFIzMRMwEQYDVQQKEwpH"
 58225:     "bG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWdu",
 58225:     "BAAAAAABIVhTCKI=",
106838:     nullptr
 58225:   },
 58225:   {
 35449:     // CN=Buypass Class 3 CA 1,O=Buypass AS-983163327,C=NO
 35449:     "2.16.578.1.26.1.3.3",
119351:     "Buypass EV OID",
 35449:     SEC_OID_UNKNOWN,
 35449:     "61:57:3A:11:DF:0E:D8:7E:D5:92:65:22:EA:D0:56:D7:44:B3:23:71",
 35449:     "MEsxCzAJBgNVBAYTAk5PMR0wGwYDVQQKDBRCdXlwYXNzIEFTLTk4MzE2MzMyNzEd"
 35449:     "MBsGA1UEAwwUQnV5cGFzcyBDbGFzcyAzIENBIDE=",
 35449:     "Ag==",
106838:     nullptr
 35449:   },
 35449:   {
119351:     // CN=Buypass Class 3 Root CA,O=Buypass AS-983163327,C=NO
119351:     "2.16.578.1.26.1.3.3",
119351:     "Buypass EV OID",
119351:     SEC_OID_UNKNOWN,
119351:     "DA:FA:F7:FA:66:84:EC:06:8F:14:50:BD:C7:C2:81:A5:BC:A9:64:57",
119351:     "ME4xCzAJBgNVBAYTAk5PMR0wGwYDVQQKDBRCdXlwYXNzIEFTLTk4MzE2MzMyNzEg"
119351:     "MB4GA1UEAwwXQnV5cGFzcyBDbGFzcyAzIFJvb3QgQ0E=",
119351:     "Ag==",
119351:     nullptr
119351:   },
119351:   {
 41741:     // CN=Class 2 Primary CA,O=Certplus,C=FR
 41741:     "1.3.6.1.4.1.22234.2.5.2.3.1",
 41741:     "Certplus EV OID",
 41741:     SEC_OID_UNKNOWN,
 41741:     "74:20:74:41:72:9C:DD:92:EC:79:31:D8:23:10:8D:C2:81:92:E2:BB",
 41741:     "MD0xCzAJBgNVBAYTAkZSMREwDwYDVQQKEwhDZXJ0cGx1czEbMBkGA1UEAxMSQ2xh"
 41741:     "c3MgMiBQcmltYXJ5IENB",
 41741:     "AIW9S/PY2uNp9pTXX8OlRCM=",
106838:     nullptr
 41741:   },
 41741:   {
 62740:     // CN=Chambers of Commerce Root - 2008,O=AC Camerfirma S.A.,serialNumber=A82743287,L=Madrid (see current address at www.camerfirma.com/address),C=EU
 62740:     "1.3.6.1.4.1.17326.10.14.2.1.2",
 62740:     "Camerfirma EV OID a",
 62740:     SEC_OID_UNKNOWN,
 62740:     "78:6A:74:AC:76:AB:14:7F:9C:6A:30:50:BA:9E:A8:7E:FE:9A:CE:3C",
 62740:     "MIGuMQswCQYDVQQGEwJFVTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3VycmVudCBh"
 62740:     "ZGRyZXNzIGF0IHd3dy5jYW1lcmZpcm1hLmNvbS9hZGRyZXNzKTESMBAGA1UEBRMJ"
 62740:     "QTgyNzQzMjg3MRswGQYDVQQKExJBQyBDYW1lcmZpcm1hIFMuQS4xKTAnBgNVBAMT"
 62740:     "IENoYW1iZXJzIG9mIENvbW1lcmNlIFJvb3QgLSAyMDA4",
 62740:     "AKPaQn6ksa7a",
106838:     nullptr
 62740:   },
 62740:   {
 62740:     // CN=Global Chambersign Root - 2008,O=AC Camerfirma S.A.,serialNumber=A82743287,L=Madrid (see current address at www.camerfirma.com/address),C=EU
 62740:     "1.3.6.1.4.1.17326.10.8.12.1.2",
 62740:     "Camerfirma EV OID b",
 62740:     SEC_OID_UNKNOWN,
 62740:     "4A:BD:EE:EC:95:0D:35:9C:89:AE:C7:52:A1:2C:5B:29:F6:D6:AA:0C",
 62740:     "MIGsMQswCQYDVQQGEwJFVTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3VycmVudCBh"
 62740:     "ZGRyZXNzIGF0IHd3dy5jYW1lcmZpcm1hLmNvbS9hZGRyZXNzKTESMBAGA1UEBRMJ"
 62740:     "QTgyNzQzMjg3MRswGQYDVQQKExJBQyBDYW1lcmZpcm1hIFMuQS4xJzAlBgNVBAMT"
 62740:     "Hkdsb2JhbCBDaGFtYmVyc2lnbiBSb290IC0gMjAwOA==",
 62740:     "AMnN0+nVfSPO",
106838:     nullptr
 62740:   },
 62740:   {
 62740:     // CN=TC TrustCenter Universal CA III,OU=TC TrustCenter Universal CA,O=TC TrustCenter GmbH,C=DE
 62740:     "1.2.276.0.44.1.1.1.4",
 62740:     "TC TrustCenter EV OID",
 62740:     SEC_OID_UNKNOWN,
 62740:     "96:56:CD:7B:57:96:98:95:D0:E1:41:46:68:06:FB:B8:C6:11:06:87",
 62740:     "MHsxCzAJBgNVBAYTAkRFMRwwGgYDVQQKExNUQyBUcnVzdENlbnRlciBHbWJIMSQw"
 62740:     "IgYDVQQLExtUQyBUcnVzdENlbnRlciBVbml2ZXJzYWwgQ0ExKDAmBgNVBAMTH1RD"
 62740:     "IFRydXN0Q2VudGVyIFVuaXZlcnNhbCBDQSBJSUk=",
 62740:     "YyUAAQACFI0zFQLkbPQ=",
106838:     nullptr
 62740:   },
 62740:   {
 69348:     // CN=AffirmTrust Commercial,O=AffirmTrust,C=US
 69348:     "1.3.6.1.4.1.34697.2.1",
 69348:     "AffirmTrust EV OID a",
 69348:     SEC_OID_UNKNOWN,
 69348:     "F9:B5:B6:32:45:5F:9C:BE:EC:57:5F:80:DC:E9:6E:2C:C7:B2:78:B7",
 69348:     "MEQxCzAJBgNVBAYTAlVTMRQwEgYDVQQKDAtBZmZpcm1UcnVzdDEfMB0GA1UEAwwW"
 69348:     "QWZmaXJtVHJ1c3QgQ29tbWVyY2lhbA==",
 69348:     "d3cGJyapsXw=",
106838:     nullptr
 69348:   },
 69348:   {
 69348:     // CN=AffirmTrust Networking,O=AffirmTrust,C=US
 69348:     "1.3.6.1.4.1.34697.2.2",
 69348:     "AffirmTrust EV OID b",
 69348:     SEC_OID_UNKNOWN,
 69348:     "29:36:21:02:8B:20:ED:02:F5:66:C5:32:D1:D6:ED:90:9F:45:00:2F",
 69348:     "MEQxCzAJBgNVBAYTAlVTMRQwEgYDVQQKDAtBZmZpcm1UcnVzdDEfMB0GA1UEAwwW"
 69348:     "QWZmaXJtVHJ1c3QgTmV0d29ya2luZw==",
 69348:     "fE8EORzUmS0=",
106838:     nullptr
 69348:   },
 69348:   {
 69348:     // CN=AffirmTrust Premium,O=AffirmTrust,C=US
 69348:     "1.3.6.1.4.1.34697.2.3",
 69348:     "AffirmTrust EV OID c",
 69348:     SEC_OID_UNKNOWN,
 69348:     "D8:A6:33:2C:E0:03:6F:B1:85:F6:63:4F:7D:6A:06:65:26:32:28:27",
 69348:     "MEExCzAJBgNVBAYTAlVTMRQwEgYDVQQKDAtBZmZpcm1UcnVzdDEcMBoGA1UEAwwT"
 69348:     "QWZmaXJtVHJ1c3QgUHJlbWl1bQ==",
 69348:     "bYwURrGmCu4=",
106838:     nullptr
 69348:   },
 69348:   {
 69348:     // CN=AffirmTrust Premium ECC,O=AffirmTrust,C=US
 69348:     "1.3.6.1.4.1.34697.2.4",
 69348:     "AffirmTrust EV OID d",
 69348:     SEC_OID_UNKNOWN,
 69348:     "B8:23:6B:00:2F:1D:16:86:53:01:55:6C:11:A4:37:CA:EB:FF:C3:BB",
 69348:     "MEUxCzAJBgNVBAYTAlVTMRQwEgYDVQQKDAtBZmZpcm1UcnVzdDEgMB4GA1UEAwwX"
 69348:     "QWZmaXJtVHJ1c3QgUHJlbWl1bSBFQ0M=",
 69348:     "dJclisc/elQ=",
106838:     nullptr
 69348:   },
 69348:   {
 69348:     // CN=Certum Trusted Network CA,OU=Certum Certification Authority,O=Unizeto Technologies S.A.,C=PL
 69348:     "1.2.616.1.113527.2.5.1.1",
 69348:     "Certum EV OID",
 69348:     SEC_OID_UNKNOWN,
 69348:     "07:E0:32:E0:20:B7:2C:3F:19:2F:06:28:A2:59:3A:19:A7:0F:06:9E",
 69348:     "MH4xCzAJBgNVBAYTAlBMMSIwIAYDVQQKExlVbml6ZXRvIFRlY2hub2xvZ2llcyBT"
 69348:     "LkEuMScwJQYDVQQLEx5DZXJ0dW0gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxIjAg"
 69348:     "BgNVBAMTGUNlcnR1bSBUcnVzdGVkIE5ldHdvcmsgQ0E=",
 69348:     "BETA",
106838:     nullptr
 69348:   },
 69348:   {
 69348:     // CN=Izenpe.com,O=IZENPE S.A.,C=ES
 69348:     "1.3.6.1.4.1.14777.6.1.1",
 69348:     "Izenpe EV OID 1",
 69348:     SEC_OID_UNKNOWN,
 69348:     "2F:78:3D:25:52:18:A7:4A:65:39:71:B5:2C:A2:9C:45:15:6F:E9:19",
 69348:     "MDgxCzAJBgNVBAYTAkVTMRQwEgYDVQQKDAtJWkVOUEUgUy5BLjETMBEGA1UEAwwK"
 69348:     "SXplbnBlLmNvbQ==",
 69348:     "ALC3WhZIX7/hy/WL1xnmfQ==",
106838:     nullptr
 69348:   },
 69348:   {
 69348:     // CN=Izenpe.com,O=IZENPE S.A.,C=ES
 69348:     "1.3.6.1.4.1.14777.6.1.2",
 69348:     "Izenpe EV OID 2",
 69348:     SEC_OID_UNKNOWN,
 69348:     "2F:78:3D:25:52:18:A7:4A:65:39:71:B5:2C:A2:9C:45:15:6F:E9:19",
 69348:     "MDgxCzAJBgNVBAYTAkVTMRQwEgYDVQQKDAtJWkVOUEUgUy5BLjETMBEGA1UEAwwK"
 69348:     "SXplbnBlLmNvbQ==",
 69348:     "ALC3WhZIX7/hy/WL1xnmfQ==",
106838:     nullptr
 69348:   },
 69348:   {
 84903:     // CN=A-Trust-nQual-03,OU=A-Trust-nQual-03,O=A-Trust Ges. f. Sicherheitssysteme im elektr. Datenverkehr GmbH,C=AT
 84903:     "1.2.40.0.17.1.22",
 84903:     "A-Trust EV OID",
 84903:     SEC_OID_UNKNOWN,
 84903:     "D3:C0:63:F2:19:ED:07:3E:34:AD:5D:75:0B:32:76:29:FF:D5:9A:F2",
 84903:     "MIGNMQswCQYDVQQGEwJBVDFIMEYGA1UECgw/QS1UcnVzdCBHZXMuIGYuIFNpY2hl"
 84903:     "cmhlaXRzc3lzdGVtZSBpbSBlbGVrdHIuIERhdGVudmVya2VociBHbWJIMRkwFwYD"
 84903:     "VQQLDBBBLVRydXN0LW5RdWFsLTAzMRkwFwYDVQQDDBBBLVRydXN0LW5RdWFsLTAz",
 84903:     "AWwe",
106838:     nullptr
 84903:   },
 84903:   {
 12711:     // OU=Sample Certification Authority,O=\"Sample, Inc.\",C=US
  7105:     "0.0.0.0",
  7105:     0, // for real entries use a string like "Sample INVALID EV OID"
  7105:     SEC_OID_UNKNOWN,
 35449:     "00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33", //UPPERCASE!
 13140:     "Cg==",
 13140:     "Cg==",
106838:     nullptr
  7105:   }
  7105: };
  7105: 
  7105: static SECOidTag
  7105: register_oid(const SECItem *oid_item, const char *oid_name)
  7105: {
  7105:   if (!oid_item)
  7105:     return SEC_OID_UNKNOWN;
  7105: 
  7105:   SECOidData od;
  7105:   od.oid.len = oid_item->len;
  7105:   od.oid.data = oid_item->data;
  7105:   od.offset = SEC_OID_UNKNOWN;
  7105:   od.desc = oid_name;
  7105:   od.mechanism = CKM_INVALID_MECHANISM;
  7105:   od.supportedExtension = INVALID_CERT_EXTENSION;
  7105:   return SECOID_AddEntry(&od);
  7105: }
  7105: 
  7105: #ifdef PSM_ENABLE_TEST_EV_ROOTS
  7105: class nsMyTrustedEVInfoClass : public nsMyTrustedEVInfo
  7105: {
  7105: public:
  7105:   nsMyTrustedEVInfoClass();
  7105:   ~nsMyTrustedEVInfoClass();
  7105: };
  7105: 
  7105: nsMyTrustedEVInfoClass::nsMyTrustedEVInfoClass()
  7105: {
106838:   dotted_oid = nullptr;
106838:   oid_name = nullptr;
  7105:   oid_tag = SEC_OID_UNKNOWN;
106838:   ev_root_sha1_fingerprint = nullptr;
106838:   issuer_base64 = nullptr;
106838:   serial_base64 = nullptr;
106838:   cert = nullptr;
  7105: }
  7105: 
  7105: nsMyTrustedEVInfoClass::~nsMyTrustedEVInfoClass()
  7105: {
 29205:   // Cast away const-ness in order to free these strings
 29205:   free(const_cast<char*>(dotted_oid));
 29205:   free(const_cast<char*>(oid_name));
 29205:   free(const_cast<char*>(ev_root_sha1_fingerprint));
 29205:   free(const_cast<char*>(issuer_base64));
 29205:   free(const_cast<char*>(serial_base64));
 13140:   if (cert)
 13140:     CERT_DestroyCertificate(cert);
  7105: }
  7105: 
  7105: typedef nsTArray< nsMyTrustedEVInfoClass* > testEVArray; 
  7105: static testEVArray *testEVInfos;
 79445: static bool testEVInfosLoaded = false;
  7105: #endif
  7105: 
 79445: static bool isEVMatch(SECOidTag policyOIDTag, 
  7105:                         CERTCertificate *rootCert, 
  7105:                         const nsMyTrustedEVInfo &info)
  7105: {
  7105:   if (!rootCert)
 80486:     return false;
  7105: 
  7105:   NS_ConvertASCIItoUTF16 info_sha1(info.ev_root_sha1_fingerprint);
  7105: 
  7105:   nsNSSCertificate c(rootCert);
  7105: 
  7105:   nsAutoString fingerprint;
  7105:   if (NS_FAILED(c.GetSha1Fingerprint(fingerprint)))
 80486:     return false;
  7105: 
  7105:   if (fingerprint != info_sha1)
 80486:     return false;
  7105: 
  7105:   return (policyOIDTag == info.oid_tag);
  7105: }
  7105: 
  7105: #ifdef PSM_ENABLE_TEST_EV_ROOTS
  7105: static const char kTestEVRootsFileName[] = "test_ev_roots.txt";
  7105: 
  7105: static void
  7105: loadTestEVInfos()
  7105: {
  7105:   if (!testEVInfos)
  7105:     return;
  7105: 
  7105:   testEVInfos->Clear();
  7105: 
  7105:   char *env_val = getenv("ENABLE_TEST_EV_ROOTS_FILE");
  7105:   if (!env_val)
  7105:     return;
  7105:     
  7105:   int enabled_val = atoi(env_val);
  7105:   if (!enabled_val)
  7105:     return;
  7105: 
  7105:   nsCOMPtr<nsIFile> aFile;
  7105:   NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, getter_AddRefs(aFile));
  7105:   if (!aFile)
  7105:     return;
  7105: 
  7105:   aFile->AppendNative(NS_LITERAL_CSTRING(kTestEVRootsFileName));
  7105: 
  7105:   nsresult rv;
  7105:   nsCOMPtr<nsIInputStream> fileInputStream;
  7105:   rv = NS_NewLocalFileInputStream(getter_AddRefs(fileInputStream), aFile);
  7105:   if (NS_FAILED(rv))
  7105:     return;
  7105: 
  7105:   nsCOMPtr<nsILineInputStream> lineInputStream = do_QueryInterface(fileInputStream, &rv);
  7105:   if (NS_FAILED(rv))
  7105:     return;
  7105: 
110974:   nsAutoCString buffer;
 79445:   bool isMore = true;
  7105: 
  7105:   /* file format
  7105:    *
  7105:    * file format must be strictly followed
  7105:    * strings in file must be UTF-8
  7105:    * each record consists of multiple lines
  7105:    * each line consists of a descriptor, a single space, and the data
  7105:    * the descriptors are:
 12711:    *   1_fingerprint (in format XX:XX:XX:...)
 12711:    *   2_readable_oid (treated as a comment)
  7105:    * the input file must strictly follow this order
  7105:    * the input file may contain 0, 1 or many records
  7105:    * completely empty lines are ignored
  7105:    * lines that start with the # char are ignored
  7105:    */
  7105: 
  7105:   int line_counter = 0;
 79445:   bool found_error = false;
  7105: 
  7105:   enum { 
 13140:     pos_fingerprint, pos_readable_oid, pos_issuer, pos_serial
 12711:   } reader_position = pos_fingerprint;
  7105: 
 13140:   nsCString fingerprint, readable_oid, issuer, serial;
  7105: 
  7105:   while (isMore && NS_SUCCEEDED(lineInputStream->ReadLine(buffer, &isMore))) {
  7105:     ++line_counter;
  7105:     if (buffer.IsEmpty() || buffer.First() == '#') {
  7105:       continue;
  7105:     }
  7105: 
108991:     int32_t seperatorIndex = buffer.FindChar(' ', 0);
  7105:     if (seperatorIndex == 0) {
 80486:       found_error = true;
  7105:       break;
  7105:     }
  7105: 
  7105:     const nsASingleFragmentCString &descriptor = Substring(buffer, 0, seperatorIndex);
  7105:     const nsASingleFragmentCString &data = 
  7105:             Substring(buffer, seperatorIndex + 1, 
  7105:                       buffer.Length() - seperatorIndex + 1);
  7105: 
 12711:     if (reader_position == pos_fingerprint &&
 12711:         descriptor.EqualsLiteral(("1_fingerprint"))) {
  7105:       fingerprint = data;
  7105:       reader_position = pos_readable_oid;
  7105:       continue;
  7105:     }
  7105:     else if (reader_position == pos_readable_oid &&
 12711:         descriptor.EqualsLiteral(("2_readable_oid"))) {
  7105:       readable_oid = data;
 13140:       reader_position = pos_issuer;
 14100:       continue;
 13140:     }
 13140:     else if (reader_position == pos_issuer &&
 13140:         descriptor.EqualsLiteral(("3_issuer"))) {
 13140:       issuer = data;
 13140:       reader_position = pos_serial;
 14100:       continue;
 13140:     }
 14100:     else if (reader_position == pos_serial &&
 13140:         descriptor.EqualsLiteral(("4_serial"))) {
 13140:       serial = data;
 12711:       reader_position = pos_fingerprint;
  7105:     }
  7105:     else {
 80486:       found_error = true;
  7105:       break;
  7105:     }
  7105: 
  7105:     nsMyTrustedEVInfoClass *temp_ev = new nsMyTrustedEVInfoClass;
  7105:     if (!temp_ev)
  7105:       return;
  7105: 
  7105:     temp_ev->ev_root_sha1_fingerprint = strdup(fingerprint.get());
  7105:     temp_ev->oid_name = strdup(readable_oid.get());
  7105:     temp_ev->dotted_oid = strdup(readable_oid.get());
 13140:     temp_ev->issuer_base64 = strdup(issuer.get());
 13140:     temp_ev->serial_base64 = strdup(serial.get());
 13140: 
 13140:     SECStatus rv;
 13140:     CERTIssuerAndSN ias;
 13140: 
 13140:     rv = ATOB_ConvertAsciiToItem(&ias.derIssuer, const_cast<char*>(temp_ev->issuer_base64));
 13140:     NS_ASSERTION(rv==SECSuccess, "error converting ascii to binary.");
 13140:     rv = ATOB_ConvertAsciiToItem(&ias.serialNumber, const_cast<char*>(temp_ev->serial_base64));
 13140:     NS_ASSERTION(rv==SECSuccess, "error converting ascii to binary.");
 13140: 
106838:     temp_ev->cert = CERT_FindCertByIssuerAndSN(nullptr, &ias);
 13140:     NS_ASSERTION(temp_ev->cert, "Could not find EV root in NSS storage");
 13140: 
 80486:     SECITEM_FreeItem(&ias.derIssuer, false);
 80486:     SECITEM_FreeItem(&ias.serialNumber, false);
 60704: 
 13140:     if (!temp_ev->cert)
 13140:       return;
 13140: 
 13140:     nsNSSCertificate c(temp_ev->cert);
 13140:     nsAutoString fingerprint;
 13140:     c.GetSha1Fingerprint(fingerprint);
 13140: 
 13140:     NS_ConvertASCIItoUTF16 sha1(temp_ev->ev_root_sha1_fingerprint);
 13140: 
 13140:     if (sha1 != fingerprint) {
 13140:       NS_ASSERTION(sha1 == fingerprint, "found EV root with unexpected SHA1 mismatch");
 13140:       CERT_DestroyCertificate(temp_ev->cert);
106838:       temp_ev->cert = nullptr;
 13140:       return;
 13140:     }
  7105: 
  7105:     SECItem ev_oid_item;
106838:     ev_oid_item.data = nullptr;
  7105:     ev_oid_item.len = 0;
106838:     SECStatus srv = SEC_StringToOID(nullptr, &ev_oid_item,
  7105:                                     readable_oid.get(), readable_oid.Length());
  7105:     if (srv != SECSuccess) {
  7105:       delete temp_ev;
 80486:       found_error = true;
  7105:       break;
  7105:     }
  7105: 
  7105:     temp_ev->oid_tag = register_oid(&ev_oid_item, temp_ev->oid_name);
 80486:     SECITEM_FreeItem(&ev_oid_item, false);
  7105: 
  7105:     testEVInfos->AppendElement(temp_ev);
  7105:   }
  7105: 
  7105:   if (found_error) {
  7105:     fprintf(stderr, "invalid line %d in test_ev_roots file\n", line_counter);
  7105:   }
  7105: }
  7105: 
 79445: static bool 
  7105: isEVPolicyInExternalDebugRootsFile(SECOidTag policyOIDTag)
  7105: {
  7105:   if (!testEVInfos)
 80486:     return false;
  7105: 
  7105:   char *env_val = getenv("ENABLE_TEST_EV_ROOTS_FILE");
  7105:   if (!env_val)
 80486:     return false;
  7105:     
  7105:   int enabled_val = atoi(env_val);
  7105:   if (!enabled_val)
 80486:     return false;
  7105: 
  7105:   for (size_t i=0; i<testEVInfos->Length(); ++i) {
  7105:     nsMyTrustedEVInfoClass *ev = testEVInfos->ElementAt(i);
  7105:     if (!ev)
  7105:       continue;
  7105:     if (policyOIDTag == ev->oid_tag)
 80486:       return true;
  7105:   }
  7105: 
 80486:   return false;
  7105: }
  7105: 
 79445: static bool 
 13140: getRootsForOidFromExternalRootsFile(CERTCertList* certList, 
 13140:                                     SECOidTag policyOIDTag)
 13140: {
 13140:   if (!testEVInfos)
 80486:     return false;
 13140: 
 13140:   char *env_val = getenv("ENABLE_TEST_EV_ROOTS_FILE");
 13140:   if (!env_val)
 80486:     return false;
 13140:     
 13140:   int enabled_val = atoi(env_val);
 13140:   if (!enabled_val)
 80486:     return false;
 13140: 
 13140:   for (size_t i=0; i<testEVInfos->Length(); ++i) {
 13140:     nsMyTrustedEVInfoClass *ev = testEVInfos->ElementAt(i);
 13140:     if (!ev)
 13140:       continue;
 13140:     if (policyOIDTag == ev->oid_tag)
 15736:       CERT_AddCertToListTail(certList, CERT_DupCertificate(ev->cert));
 13140:   }
 13140: 
 80486:   return false;
 13140: }
 13140: 
 79445: static bool 
  7105: isEVMatchInExternalDebugRootsFile(SECOidTag policyOIDTag, 
  7105:                                   CERTCertificate *rootCert)
  7105: {
  7105:   if (!testEVInfos)
 80486:     return false;
  7105: 
  7105:   if (!rootCert)
 80486:     return false;
  7105:   
  7105:   char *env_val = getenv("ENABLE_TEST_EV_ROOTS_FILE");
  7105:   if (!env_val)
 80486:     return false;
  7105:     
  7105:   int enabled_val = atoi(env_val);
  7105:   if (!enabled_val)
 80486:     return false;
  7105: 
  7105:   for (size_t i=0; i<testEVInfos->Length(); ++i) {
  7105:     nsMyTrustedEVInfoClass *ev = testEVInfos->ElementAt(i);
  7105:     if (!ev)
  7105:       continue;
  7105:     if (isEVMatch(policyOIDTag, rootCert, *ev))
 80486:       return true;
  7105:   }
  7105: 
 80486:   return false;
  7105: }
  7105: #endif
  7105: 
 79445: static bool 
  7105: isEVPolicy(SECOidTag policyOIDTag)
  7105: {
  7105:   for (size_t iEV=0; iEV < (sizeof(myTrustedEVInfos)/sizeof(nsMyTrustedEVInfo)); ++iEV) {
  7105:     nsMyTrustedEVInfo &entry = myTrustedEVInfos[iEV];
  7105:     if (!entry.oid_name) // invalid or placeholder list entry
  7105:       continue;
  7105:     if (policyOIDTag == entry.oid_tag) {
 80486:       return true;
  7105:     }
  7105:   }
  7105: 
  7105: #ifdef PSM_ENABLE_TEST_EV_ROOTS
  7105:   if (isEVPolicyInExternalDebugRootsFile(policyOIDTag)) {
 80486:     return true;
  7105:   }
  7105: #endif
  7105: 
 80486:   return false;
  7105: }
  7105: 
 13140: static CERTCertList*
 13140: getRootsForOid(SECOidTag oid_tag)
 13140: {
 13140:   CERTCertList *certList = CERT_NewCertList();
 13140:   if (!certList)
106838:     return nullptr;
 13140: 
 13140:   for (size_t iEV=0; iEV < (sizeof(myTrustedEVInfos)/sizeof(nsMyTrustedEVInfo)); ++iEV) {
 13140:     nsMyTrustedEVInfo &entry = myTrustedEVInfos[iEV];
 13140:     if (!entry.oid_name) // invalid or placeholder list entry
 13140:       continue;
 13140:     if (entry.oid_tag == oid_tag)
 15736:       CERT_AddCertToListTail(certList, CERT_DupCertificate(entry.cert));
 13140:   }
 13140: 
 13140: #ifdef PSM_ENABLE_TEST_EV_ROOTS
 13140:   getRootsForOidFromExternalRootsFile(certList, oid_tag);
 13140: #endif
 13140:   return certList;
 13140: }
 13140: 
 79445: static bool 
  7105: isApprovedForEV(SECOidTag policyOIDTag, CERTCertificate *rootCert)
  7105: {
  7105:   if (!rootCert)
 80486:     return false;
  7105: 
  7105:   for (size_t iEV=0; iEV < (sizeof(myTrustedEVInfos)/sizeof(nsMyTrustedEVInfo)); ++iEV) {
  7105:     nsMyTrustedEVInfo &entry = myTrustedEVInfos[iEV];
  7105:     if (!entry.oid_name) // invalid or placeholder list entry
  7105:       continue;
  7105:     if (isEVMatch(policyOIDTag, rootCert, entry)) {
 80486:       return true;
  7105:     }
  7105:   }
  7105: 
  7105: #ifdef PSM_ENABLE_TEST_EV_ROOTS
  7105:   if (isEVMatchInExternalDebugRootsFile(policyOIDTag, rootCert)) {
 80486:     return true;
  7105:   }
  7105: #endif
  7105: 
 80486:   return false;
  7105: }
  7105: 
115027: PRStatus
  7105: nsNSSComponent::IdentityInfoInit()
  7105: {
  7105:   for (size_t iEV=0; iEV < (sizeof(myTrustedEVInfos)/sizeof(nsMyTrustedEVInfo)); ++iEV) {
  7105:     nsMyTrustedEVInfo &entry = myTrustedEVInfos[iEV];
  7105:     if (!entry.oid_name) // invalid or placeholder list entry
  7105:       continue;
  7105: 
 13140:     SECStatus rv;
 13140:     CERTIssuerAndSN ias;
 13140: 
 13140:     rv = ATOB_ConvertAsciiToItem(&ias.derIssuer, const_cast<char*>(entry.issuer_base64));
 13140:     NS_ASSERTION(rv==SECSuccess, "error converting ascii to binary.");
 13140:     rv = ATOB_ConvertAsciiToItem(&ias.serialNumber, const_cast<char*>(entry.serial_base64));
 13140:     NS_ASSERTION(rv==SECSuccess, "error converting ascii to binary.");
 47879:     ias.serialNumber.type = siUnsignedInteger;
 13140: 
106838:     entry.cert = CERT_FindCertByIssuerAndSN(nullptr, &ias);
 13140:     NS_ASSERTION(entry.cert, "Could not find EV root in NSS storage");
 13140: 
 80486:     SECITEM_FreeItem(&ias.derIssuer, false);
 80486:     SECITEM_FreeItem(&ias.serialNumber, false);
 60704: 
 13140:     if (!entry.cert)
 13140:       continue;
 13140: 
 13140:     nsNSSCertificate c(entry.cert);
 13140:     nsAutoString fingerprint;
 13140:     c.GetSha1Fingerprint(fingerprint);
 13140: 
 13140:     NS_ConvertASCIItoUTF16 sha1(entry.ev_root_sha1_fingerprint);
 13140: 
 13140:     if (sha1 != fingerprint) {
 13140:       NS_ASSERTION(sha1 == fingerprint, "found EV root with unexpected SHA1 mismatch");
 13140:       CERT_DestroyCertificate(entry.cert);
106838:       entry.cert = nullptr;
 13140:       continue;
 13140:     }
 13140: 
  7105:     SECItem ev_oid_item;
106838:     ev_oid_item.data = nullptr;
  7105:     ev_oid_item.len = 0;
106838:     SECStatus srv = SEC_StringToOID(nullptr, &ev_oid_item, 
  7105:                                     entry.dotted_oid, 0);
  7105:     if (srv != SECSuccess)
  7105:       continue;
  7105: 
  7105:     entry.oid_tag = register_oid(&ev_oid_item, entry.oid_name);
  7105: 
 80486:     SECITEM_FreeItem(&ev_oid_item, false);
  7105:   }
  7105: 
  7105: #ifdef PSM_ENABLE_TEST_EV_ROOTS
  7105:   if (!testEVInfosLoaded) {
 80486:     testEVInfosLoaded = true;
  7105:     testEVInfos = new testEVArray;
  7105:     if (testEVInfos) {
  7105:       loadTestEVInfos();
  7105:     }
  7105:   }
  7105: #endif
  7105: 
  7105:   return PR_SUCCESS;
  7105: }
  7105: 
  7105: // Find the first policy OID that is known to be an EV policy OID.
  7105: static SECStatus getFirstEVPolicy(CERTCertificate *cert, SECOidTag &outOidTag)
  7105: {
  7105:   if (!cert)
  7105:     return SECFailure;
  7105: 
  7105:   if (cert->extensions) {
119832:     for (int i=0; cert->extensions[i] != nullptr; i++) {
  7105:       const SECItem *oid = &cert->extensions[i]->id;
  7105: 
  7105:       SECOidTag oidTag = SECOID_FindOIDTag(oid);
  7105:       if (oidTag != SEC_OID_X509_CERTIFICATE_POLICIES)
  7105:         continue;
  7105: 
  7105:       SECItem *value = &cert->extensions[i]->value;
  7105: 
  7105:       CERTCertificatePolicies *policies;
  7105:       CERTPolicyInfo **policyInfos, *policyInfo;
  7105:     
  7105:       policies = CERT_DecodeCertificatePoliciesExtension(value);
  7105:       if (!policies)
  7105:         continue;
  7105:     
  7105:       policyInfos = policies->policyInfos;
  7105: 
 79445:       bool found = false;
119832:       while (*policyInfos != NULL) {
  7105:         policyInfo = *policyInfos++;
  7105: 
 31560:         SECOidTag oid_tag = policyInfo->oid;
 31587:         if (oid_tag != SEC_OID_UNKNOWN && isEVPolicy(oid_tag)) {
 31587:           // in our list of OIDs accepted for EV
  7105:           outOidTag = oid_tag;
 80486:           found = true;
 31587:           break;
 31587:         }
 31587:       }
 31587:       CERT_DestroyCertificatePoliciesExtension(policies);
 31587:       if (found)
  7105:         return SECSuccess;
  7105:     }
  7105:   }
  7105: 
  7105:   return SECFailure;
  7105: }
  5220: 
 81084: NS_IMETHODIMP
 81084: nsSSLStatus::GetIsExtendedValidation(bool* aIsEV)
 10258: {
 81084:   NS_ENSURE_ARG_POINTER(aIsEV);
 81084:   *aIsEV = false;
 81084: 
 81084:   nsCOMPtr<nsIX509Cert> cert = mServerCert;
 81084:   nsresult rv;
 81084:   nsCOMPtr<nsIIdentityInfo> idinfo = do_QueryInterface(cert, &rv);
 81084: 
 81084:   // mServerCert should never be null when this method is called because
 81084:   // nsSSLStatus objects always have mServerCert set right after they are
 81084:   // constructed and before they are returned. GetIsExtendedValidation should
 81084:   // only be called in the chrome process (in e10s), and mServerCert will always
 81084:   // implement nsIIdentityInfo in the chrome process.
 81084:   if (!idinfo) {
 81084:     NS_ERROR("nsSSLStatus has null mServerCert or was called in the content "
 81084:              "process");
 81084:     return NS_ERROR_UNEXPECTED;
 10258:   }
 10258: 
 81084:   // Never allow bad certs for EV, regardless of overrides.
 81301:   if (mHaveCertErrorBits)
  7105:     return NS_OK;
  7105: 
 10258:   return idinfo->GetIsExtendedValidation(aIsEV);
  7105: }
  7105: 
  7105: nsresult
 79445: nsNSSCertificate::hasValidEVOidTag(SECOidTag &resultOidTag, bool &validEV)
  7105: {
  7105:   nsNSSShutDownPreventionLock locker;
  7105:   if (isAlreadyShutDown())
  7105:     return NS_ERROR_NOT_AVAILABLE;
  7105: 
  7105:   nsresult nrv;
  7105:   nsCOMPtr<nsINSSComponent> nssComponent = 
  7105:     do_GetService(PSM_COMPONENT_CONTRACTID, &nrv);
  7105:   if (NS_FAILED(nrv))
  7105:     return nrv;
  7105:   nssComponent->EnsureIdentityInfoLoaded();
  7105: 
 80486:   validEV = false;
  7105:   resultOidTag = SEC_OID_UNKNOWN;
  7105: 
 79445:   bool isOCSPEnabled = false;
 10548:   nsCOMPtr<nsIX509CertDB> certdb;
 10548:   certdb = do_GetService(NS_X509CERTDB_CONTRACTID);
 10548:   if (certdb)
 10548:     certdb->GetIsOcspOn(&isOCSPEnabled);
 10548:   // No OCSP, no EV
 10548:   if (!isOCSPEnabled)
 10548:     return NS_OK;
 10548: 
  7105:   SECOidTag oid_tag;
  7105:   SECStatus rv = getFirstEVPolicy(mCert, oid_tag);
  7105:   if (rv != SECSuccess)
  7105:     return NS_OK;
  7105: 
  7105:   if (oid_tag == SEC_OID_UNKNOWN) // not in our list of OIDs accepted for EV
  7105:     return NS_OK;
  7105: 
 13140:   CERTCertList *rootList = getRootsForOid(oid_tag);
 15736:   CERTCertListCleaner rootListCleaner(rootList);
 13140: 
 13140:   CERTRevocationMethodIndex preferedRevMethods[1] = { 
 13140:     cert_revocation_method_ocsp
 13140:   };
 13140: 
108991:   uint64_t revMethodFlags = 
 13140:     CERT_REV_M_TEST_USING_THIS_METHOD
 13140:     | CERT_REV_M_ALLOW_NETWORK_FETCHING
 13140:     | CERT_REV_M_ALLOW_IMPLICIT_DEFAULT_SOURCE
 13140:     | CERT_REV_M_REQUIRE_INFO_ON_MISSING_SOURCE
 31560:     | CERT_REV_M_IGNORE_MISSING_FRESH_INFO
 13140:     | CERT_REV_M_STOP_TESTING_ON_FRESH_INFO;
 13140: 
108991:   uint64_t revMethodIndependentFlags = 
 13140:     CERT_REV_MI_TEST_ALL_LOCAL_INFORMATION_FIRST
 13140:     | CERT_REV_MI_REQUIRE_SOME_FRESH_INFO_AVAILABLE;
 13140: 
110764:   // We need a PRUint64 here instead of a nice int64_t (until bug 634793 is
110764:   // fixed) to match the type used in security/nss/lib/certdb/certt.h for
110764:   // cert_rev_flags_per_method.
110764:   PRUint64 methodFlags[2];
 13140:   methodFlags[cert_revocation_method_crl] = revMethodFlags;
 13140:   methodFlags[cert_revocation_method_ocsp] = revMethodFlags;
 13140: 
 13140:   CERTRevocationFlags rev;
 13140: 
 13140:   rev.leafTests.number_of_defined_methods = cert_revocation_method_ocsp +1;
 13140:   rev.leafTests.cert_rev_flags_per_method = methodFlags;
 13140:   rev.leafTests.number_of_preferred_methods = 1;
 13140:   rev.leafTests.preferred_methods = preferedRevMethods;
 13140:   rev.leafTests.cert_rev_method_independent_flags =
 13140:     revMethodIndependentFlags;
 13140: 
 13140:   rev.chainTests.number_of_defined_methods = cert_revocation_method_ocsp +1;
 13187:   rev.chainTests.cert_rev_flags_per_method = methodFlags;
 13140:   rev.chainTests.number_of_preferred_methods = 1;
 13140:   rev.chainTests.preferred_methods = preferedRevMethods;
 13140:   rev.chainTests.cert_rev_method_independent_flags =
 13140:     revMethodIndependentFlags;
 13140: 
 20522:   CERTValInParam cvin[4];
  7105:   cvin[0].type = cert_pi_policyOID;
  7105:   cvin[0].value.arraySize = 1; 
  7105:   cvin[0].value.array.oids = &oid_tag;
  8272: 
  7105:   cvin[1].type = cert_pi_revocationFlags;
 13140:   cvin[1].value.pointer.revocation = &rev;
 13140: 
 13140:   cvin[2].type = cert_pi_trustAnchors;
 13140:   cvin[2].value.pointer.chain = rootList;
 13140: 
 13140:   cvin[3].type = cert_pi_end;
  7105: 
  7105:   CERTValOutParam cvout[2];
  7105:   cvout[0].type = cert_po_trustAnchor;
106838:   cvout[0].value.pointer.cert = nullptr;
  7105:   cvout[1].type = cert_po_end;
  7105: 
 10258:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("calling CERT_PKIXVerifyCert nss cert %p\n", mCert));
  7105:   rv = CERT_PKIXVerifyCert(mCert, certificateUsageSSLServer,
106838:                            cvin, cvout, nullptr);
  7105:   if (rv != SECSuccess)
  7105:     return NS_OK;
  7105: 
  7105:   CERTCertificate *issuerCert = cvout[0].value.pointer.cert;
  7105:   CERTCertificateCleaner issuerCleaner(issuerCert);
  7105: 
 13140: #ifdef PR_LOGGING
 13140:   if (PR_LOG_TEST(gPIPNSSLog, PR_LOG_DEBUG)) {
 13140:     nsNSSCertificate ic(issuerCert);
 13140:     nsAutoString fingerprint;
 13140:     ic.GetSha1Fingerprint(fingerprint);
 13140:     NS_LossyConvertUTF16toASCII fpa(fingerprint);
 13140:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CERT_PKIXVerifyCert returned success, issuer: %s, SHA1: %s\n", 
 13140:       issuerCert->subjectName, fpa.get()));
 13140:   }
 13140: #endif
 12404: 
  7105:   validEV = isApprovedForEV(oid_tag, issuerCert);
  7105:   if (validEV)
  7105:     resultOidTag = oid_tag;
  7105:  
  5220:   return NS_OK;
  5220: }
  5220: 
 10258: nsresult
 79445: nsNSSCertificate::getValidEVOidTag(SECOidTag &resultOidTag, bool &validEV)
 10258: {
 10258:   if (mCachedEVStatus != ev_status_unknown) {
 10258:     validEV = (mCachedEVStatus == ev_status_valid);
 10258:     if (validEV)
 10258:       resultOidTag = mCachedEVOidTag;
 10258:     return NS_OK;
 10258:   }
 10258: 
 10258:   nsresult rv = hasValidEVOidTag(resultOidTag, validEV);
 10258:   if (NS_SUCCEEDED(rv)) {
 10258:     if (validEV) {
 10258:       mCachedEVOidTag = resultOidTag;
 10258:     }
 10258:     mCachedEVStatus = validEV ? ev_status_valid : ev_status_invalid;
 10258:   }
 10258:   return rv;
 10258: }
 10258: 
  7105: NS_IMETHODIMP
 79445: nsNSSCertificate::GetIsExtendedValidation(bool* aIsEV)
  7105: {
  7105:   nsNSSShutDownPreventionLock locker;
  7105:   if (isAlreadyShutDown())
  7105:     return NS_ERROR_NOT_AVAILABLE;
  7105: 
  7105:   NS_ENSURE_ARG(aIsEV);
 80486:   *aIsEV = false;
  7105: 
 10258:   if (mCachedEVStatus != ev_status_unknown) {
 10258:     *aIsEV = (mCachedEVStatus == ev_status_valid);
 10258:     return NS_OK;
 10258:   }
 10258: 
  7105:   SECOidTag oid_tag;
 10258:   return getValidEVOidTag(oid_tag, *aIsEV);
  7105: }
  7105: 
  7105: NS_IMETHODIMP
  7105: nsNSSCertificate::GetValidEVPolicyOid(nsACString &outDottedOid)
  7105: {
  7105:   nsNSSShutDownPreventionLock locker;
  7105:   if (isAlreadyShutDown())
  7105:     return NS_ERROR_NOT_AVAILABLE;
  7105: 
  7105:   SECOidTag oid_tag;
 79445:   bool valid;
 10258:   nsresult rv = getValidEVOidTag(oid_tag, valid);
  7105:   if (NS_FAILED(rv))
  7105:     return rv;
  7105: 
  7105:   if (valid) {
  7105:     SECOidData *oid_data = SECOID_FindOIDByTag(oid_tag);
  7105:     if (!oid_data)
  7105:       return NS_ERROR_FAILURE;
  7105: 
  7105:     char *oid_str = CERT_GetOidString(&oid_data->oid);
  7105:     if (!oid_str)
  7105:       return NS_ERROR_FAILURE;
  7105: 
  7105:     outDottedOid = oid_str;
  7105:     PR_smprintf_free(oid_str);
  7105:   }
  7105:   return NS_OK;
  7105: }
  7105: 
  7105: NS_IMETHODIMP
  7105: nsNSSComponent::EnsureIdentityInfoLoaded()
  7105: {
  7105:   PRStatus rv = PR_CallOnce(&mIdentityInfoCallOnce, IdentityInfoInit);
  7105:   return (rv == PR_SUCCESS) ? NS_OK : NS_ERROR_FAILURE; 
  7105: }
  7105: 
  7105: // only called during shutdown
  7105: void
  7105: nsNSSComponent::CleanupIdentityInfo()
  7105: {
 13140:   nsNSSShutDownPreventionLock locker;
 13140:   for (size_t iEV=0; iEV < (sizeof(myTrustedEVInfos)/sizeof(nsMyTrustedEVInfo)); ++iEV) {
 13140:     nsMyTrustedEVInfo &entry = myTrustedEVInfos[iEV];
 13140:     if (entry.cert) {
 13140:       CERT_DestroyCertificate(entry.cert);
106838:       entry.cert = nullptr;
 13140:     }
 13140:   }
 13140: 
  7105: #ifdef PSM_ENABLE_TEST_EV_ROOTS
  7105:   if (testEVInfosLoaded) {
 80486:     testEVInfosLoaded = false;
  7105:     if (testEVInfos) {
 10547:       for (size_t i = 0; i<testEVInfos->Length(); ++i) {
  7105:         delete testEVInfos->ElementAt(i);
  7105:       }
  7105:       testEVInfos->Clear();
  7105:       delete testEVInfos;
106838:       testEVInfos = nullptr;
  7105:     }
  7105:   }
  7105: #endif
  7105:   memset(&mIdentityInfoCallOnce, 0, sizeof(PRCallOnceType));
  7105: }
