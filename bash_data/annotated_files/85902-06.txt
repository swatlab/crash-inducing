54887: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
54887: /* ***** BEGIN LICENSE BLOCK *****
54887:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54887:  *
54887:  * The contents of this file are subject to the Mozilla Public License Version
54887:  * 1.1 (the "License"); you may not use this file except in compliance with
54887:  * the License. You may obtain a copy of the License at
54887:  * http://www.mozilla.org/MPL/
54887:  *
54887:  * Software distributed under the License is distributed on an "AS IS" basis,
54887:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54887:  * for the specific language governing rights and limitations under the
54887:  * License.
54887:  *
54887:  * The Original Code is mozilla.org code.
54887:  *
54887:  * The Initial Developer of the Original Code is
54887:  * Mozilla Foundation.
54887:  * Portions created by the Initial Developer are Copyright (C) 2010
54887:  * the Initial Developer. All Rights Reserved.
54887:  *
54887:  * Contributor(s):
54887:  *   Jonathan Griffin <jgriffin@mozilla.com>
54887:  *
54887:  * Alternatively, the contents of this file may be used under the terms of
54887:  * either the GNU General Public License Version 2 or later (the "GPL"), or
54887:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54887:  * in which case the provisions of the GPL or the LGPL are applicable instead
54887:  * of those above. If you wish to allow use of your version of this file only
54887:  * under the terms of either the GPL or the LGPL, and not to allow others to
54887:  * use your version of this file under the terms of the MPL, indicate your
54887:  * decision by deleting the provisions above and replace them with the notice
54887:  * and other provisions required by the GPL or the LGPL. If you do not delete
54887:  * the provisions above, a recipient may use your version of this file under
54887:  * the terms of any one of the MPL, the GPL or the LGPL.
54887:  *
54887:  * ***** END LICENSE BLOCK ***** */
54887: 
54887: #include <OpenGL/OpenGL.h>
54887: #include <OpenGL/CGLRenderers.h>
54887: 
80467: #include "mozilla/Util.h"
80467: 
54887: #include "GfxInfo.h"
54887: #include "nsUnicharUtils.h"
54887: #include "mozilla/FunctionTimer.h"
63217: #include "nsToolkit.h"
81280: #include "mozilla/Preferences.h"
54887: 
79359: #import <Foundation/Foundation.h>
79359: #import <IOKit/IOKitLib.h>
81328: #import <Cocoa/Cocoa.h>
79359: 
70361: #if defined(MOZ_CRASHREPORTER)
54887: #include "nsExceptionHandler.h"
54887: #include "nsICrashReporter.h"
54887: #define NS_CRASHREPORTER_CONTRACTID "@mozilla.org/toolkit/crash-reporter;1"
54887: #endif
54887: 
81328: #define MAC_OS_X_VERSION_MASK       0x0000FFFF
81328: #define MAC_OS_X_VERSION_MAJOR_MASK 0x0000FFF0
81328: #define MAC_OS_X_VERSION_10_4_HEX   0x00001040 // Not supported
81328: #define MAC_OS_X_VERSION_10_5_HEX   0x00001050
81328: #define MAC_OS_X_VERSION_10_6_HEX   0x00001060
81328: #define MAC_OS_X_VERSION_10_7_HEX   0x00001070
81328: 
80467: using namespace mozilla;
54887: using namespace mozilla::widget;
54887: 
79359: GfxInfo::GfxInfo()
85902:   : mAdapterVendorID(0),
85902:     mAdapterDeviceID(0)
79359: {
79359: }
79359: 
79359: // The following three functions are derived from Chromium code
79359: static CFTypeRef SearchPortForProperty(io_registry_entry_t dspPort,
79359:                                        CFStringRef propertyName)
79359: {
79359:   return IORegistryEntrySearchCFProperty(dspPort,
79359:                                          kIOServicePlane,
79359:                                          propertyName,
79359:                                          kCFAllocatorDefault,
79359:                                          kIORegistryIterateRecursively |
79359:                                          kIORegistryIterateParents);
79359: }
79359: 
79359: static PRUint32 IntValueOfCFData(CFDataRef d)
79359: {
79359:   PRUint32 value = 0;
79359: 
79359:   if (d) {
79359:     const PRUint32 *vp = reinterpret_cast<const PRUint32*>(CFDataGetBytePtr(d));
79359:     if (vp != NULL)
79359:       value = *vp;
79359:   }
79359: 
79359:   return value;
79359: }
79359: 
79359: void
79359: GfxInfo::GetDeviceInfo()
79359: {
79359:   io_registry_entry_t dsp_port = CGDisplayIOServicePort(kCGDirectMainDisplay);
79359:   CFTypeRef vendor_id_ref = SearchPortForProperty(dsp_port, CFSTR("vendor-id"));
79359:   if (vendor_id_ref) {
85902:     mAdapterVendorID = IntValueOfCFData((CFDataRef)vendor_id_ref);
79359:     CFRelease(vendor_id_ref);
79359:   }
79359:   CFTypeRef device_id_ref = SearchPortForProperty(dsp_port, CFSTR("device-id"));
79359:   if (device_id_ref) {
85902:     mAdapterDeviceID = IntValueOfCFData((CFDataRef)device_id_ref);
79359:     CFRelease(device_id_ref);
79359:   }
79359: }
79359: 
85900: static bool
85902: IsATIRadeonX1000(PRUint32 aVendorID, PRUint32 aDeviceID)
85900: {
85902:   if (aVendorID == 0x1002) {
85900:     // this list is from the ATIRadeonX1000.kext Info.plist
85902:     PRUint32 devices[] = {0x7187, 0x7210, 0x71DE, 0x7146, 0x7142, 0x7109, 0x71C5, 0x71C0, 0x7240, 0x7249, 0x7291};
85900:     for (size_t i = 0; i < ArrayLength(devices); i++) {
85902:       if (aDeviceID == devices[i])
85900:         return true;
85900:     }
85900:   }
85900:   return false;
85900: }
85900: 
60893: nsresult
54887: GfxInfo::Init()
54887: {
54887:   NS_TIME_FUNCTION;
54887: 
60893:   nsresult rv = GfxInfoBase::Init();
60893: 
79361:   // Calling CGLQueryRendererInfo causes us to switch to the discrete GPU
79361:   // even when we don't want to. We'll avoid doing so for now and just
79361:   // use the device ids.
79361: #if 0
54887:   CGLRendererInfoObj renderer = 0;
54887:   GLint rendererCount = 0;
54887: 
54887:   memset(mRendererIDs, 0, sizeof(mRendererIDs));
54887: 
54887:   if (CGLQueryRendererInfo(0xffffffff, &renderer, &rendererCount) != kCGLNoError)
60893:     return rv;
54887: 
80467:   rendererCount = (GLint) NS_MIN(rendererCount, (GLint) ArrayLength(mRendererIDs));
54887:   for (GLint i = 0; i < rendererCount; i++) {
54887:     GLint prop = 0;
54887: 
54887:     if (!mRendererIDsString.IsEmpty())
54887:       mRendererIDsString.AppendLiteral(",");
54887:     if (CGLDescribeRenderer(renderer, i, kCGLRPRendererID, &prop) == kCGLNoError) {
54887: #ifdef kCGLRendererIDMatchingMask
54887:       prop = prop & kCGLRendererIDMatchingMask;
54887: #else
54887:       prop = prop & 0x00FE7F00; // this is the mask token above, but it doesn't seem to exist everywhere?
54887: #endif
54887:       mRendererIDs[i] = prop;
54887:       mRendererIDsString.AppendPrintf("0x%04x", prop);
54887:     } else {
58917:       mRendererIDs[i] = 0;
54887:       mRendererIDsString.AppendPrintf("???");
54887:     }
54887:   }
54887: 
54887:   CGLDestroyRendererInfo(renderer);
79361: #endif
54887: 
79359:   GetDeviceInfo();
79359: 
54887:   AddCrashReportAnnotations();
60893: 
60893:   return rv;
54887: }
54887: 
54887: NS_IMETHODIMP
79445: GfxInfo::GetD2DEnabled(bool *aEnabled)
54887: {
54887:   return NS_ERROR_FAILURE;
54887: }
54887: 
54887: NS_IMETHODIMP
79445: GfxInfo::GetAzureEnabled(bool *aEnabled)
72430: {
81280:   bool azure = false;
81280:   nsresult rv = mozilla::Preferences::GetBool("gfx.canvas.azure.enabled", &azure);
81280:   
81280:   if (NS_SUCCEEDED(rv) && azure) {
81280:     *aEnabled = true;
81280:   } else {
81280:     *aEnabled = false;
81280:   }
81280:   return NS_OK;
72430: }
72430: 
72430: NS_IMETHODIMP
79445: GfxInfo::GetDWriteEnabled(bool *aEnabled)
54887: {
54887:   return NS_ERROR_FAILURE;
54887: }
54887: 
60493: /* readonly attribute DOMString DWriteVersion; */
60493: NS_IMETHODIMP
60493: GfxInfo::GetDWriteVersion(nsAString & aDwriteVersion)
60493: {
60493:   return NS_ERROR_FAILURE;
60493: }
60493: 
69664: /* readonly attribute DOMString cleartypeParameters; */
69664: NS_IMETHODIMP
69664: GfxInfo::GetCleartypeParameters(nsAString & aCleartypeParams)
69664: {
69664:   return NS_ERROR_FAILURE;
69664: }
69664: 
54887: /* readonly attribute DOMString adapterDescription; */
54887: NS_IMETHODIMP
54887: GfxInfo::GetAdapterDescription(nsAString & aAdapterDescription)
54887: {
54887:   aAdapterDescription = mRendererIDsString;
54887:   return NS_OK;
54887: }
54887: 
76321: /* readonly attribute DOMString adapterDescription2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDescription2(nsAString & aAdapterDescription)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
54887: /* readonly attribute DOMString adapterRAM; */
54887: NS_IMETHODIMP
54887: GfxInfo::GetAdapterRAM(nsAString & aAdapterRAM)
54887: {
54887:   aAdapterRAM = mAdapterRAMString;
54887:   return NS_OK;
54887: }
54887: 
76321: /* readonly attribute DOMString adapterRAM2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterRAM2(nsAString & aAdapterRAM)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
54887: /* readonly attribute DOMString adapterDriver; */
54887: NS_IMETHODIMP
54887: GfxInfo::GetAdapterDriver(nsAString & aAdapterDriver)
54887: {
54887:   aAdapterDriver.AssignLiteral("");
54887:   return NS_OK;
54887: }
54887: 
76321: /* readonly attribute DOMString adapterDriver2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriver2(nsAString & aAdapterDriver)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
54887: /* readonly attribute DOMString adapterDriverVersion; */
54887: NS_IMETHODIMP
54887: GfxInfo::GetAdapterDriverVersion(nsAString & aAdapterDriverVersion)
54887: {
54887:   aAdapterDriverVersion.AssignLiteral("");
54887:   return NS_OK;
54887: }
54887: 
76321: /* readonly attribute DOMString adapterDriverVersion2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriverVersion2(nsAString & aAdapterDriverVersion)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
54887: /* readonly attribute DOMString adapterDriverDate; */
54887: NS_IMETHODIMP
54887: GfxInfo::GetAdapterDriverDate(nsAString & aAdapterDriverDate)
54887: {
54887:   aAdapterDriverDate.AssignLiteral("");
54887:   return NS_OK;
54887: }
54887: 
76321: /* readonly attribute DOMString adapterDriverDate2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriverDate2(nsAString & aAdapterDriverDate)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
85902: /* readonly attribute unsigned long adapterVendorID; */
54887: NS_IMETHODIMP
85902: GfxInfo::GetAdapterVendorID(PRUint32 *aAdapterVendorID)
54887: {
85902:   *aAdapterVendorID = mAdapterVendorID;
54887:   return NS_OK;
54887: }
54887: 
85902: /* readonly attribute unsigned long adapterVendorID2; */
76321: NS_IMETHODIMP
85902: GfxInfo::GetAdapterVendorID2(PRUint32 *aAdapterVendorID)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
85902: /* readonly attribute unsigned long adapterDeviceID; */
54887: NS_IMETHODIMP
85902: GfxInfo::GetAdapterDeviceID(PRUint32 *aAdapterDeviceID)
54887: {
85902:   *aAdapterDeviceID = mAdapterDeviceID;
54887:   return NS_OK;
54887: }
54887: 
85902: /* readonly attribute unsigned long adapterDeviceID2; */
76321: NS_IMETHODIMP
85902: GfxInfo::GetAdapterDeviceID2(PRUint32 *aAdapterDeviceID)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
76321: /* readonly attribute boolean isGPU2Active; */
76321: NS_IMETHODIMP
79445: GfxInfo::GetIsGPU2Active(bool* aIsGPU2Active)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
54887: void
54887: GfxInfo::AddCrashReportAnnotations()
54887: {
70361: #if defined(MOZ_CRASHREPORTER)
85902:   nsCAutoString deviceIDString, vendorIDString;
85902:   PRUint32 deviceID, vendorID;
54887: 
85902:   GetAdapterDeviceID(&deviceID);
85902:   GetAdapterVendorID(&vendorID);
85902: 
85902:   deviceIDString.AppendPrintf("%04x", deviceID);
85902:   vendorIDString.AppendPrintf("%04x", vendorID);
82953: 
82953:   CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("AdapterVendorID"),
85902:       vendorIDString);
82953:   CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("AdapterDeviceID"),
85902:       deviceIDString);
54887:   /* Add an App Note for now so that we get the data immediately. These
54887:    * can go away after we store the above in the socorro db */
54887:   nsCAutoString note;
54887:   /* AppendPrintf only supports 32 character strings, mrghh. */
85902:   note.AppendPrintf("AdapterVendorID: %04x, ", vendorID);
85902:   note.AppendPrintf("AdapterDeviceID: %04x", deviceID);
54887:   CrashReporter::AppendAppNotesToCrashReport(note);
54887: #endif
54887: }
54887: 
81328: // We don't support checking driver versions on Mac.
81328: #define IMPLEMENT_MAC_DRIVER_BLOCKLIST(os, vendor, device, features, blockOn) \
84603:   APPEND_TO_DRIVER_BLOCKLIST(os, vendor, device, features, blockOn,           \
84603:                              DRIVER_UNKNOWN_COMPARISON, V(0,0,0,0), "")
81328: 
82482: 
84603: const nsTArray<GfxDriverInfo>&
84603: GfxInfo::GetGfxDriverInfo()
84603: {
84603:   if (!mDriverInfo->Length()) {
82482:     IMPLEMENT_MAC_DRIVER_BLOCKLIST(DRIVER_OS_ALL,
85902:       GfxDriverInfo::vendorATI, GfxDriverInfo::allDevices,
84603:       nsIGfxInfo::FEATURE_WEBGL_MSAA, nsIGfxInfo::FEATURE_BLOCKED_OS_VERSION);
84603:   }
84603:   return *mDriverInfo;
81328: }
81328: 
85896: static OperatingSystem
85896: OSXVersionToOperatingSystem(PRUint32 aOSXVersion)
85896: {
85896:   switch (aOSXVersion & MAC_OS_X_VERSION_MAJOR_MASK) {
85896:     case MAC_OS_X_VERSION_10_5_HEX:
85896:       return DRIVER_OS_OS_X_10_5;
85896:     case MAC_OS_X_VERSION_10_6_HEX:
85896:       return DRIVER_OS_OS_X_10_6;
85896:     case MAC_OS_X_VERSION_10_7_HEX:
85896:       return DRIVER_OS_OS_X_10_7;
85896:   }
85896: 
85896:   return DRIVER_OS_UNKNOWN;
85896: }
85896: 
60891: nsresult
81328: GfxInfo::GetFeatureStatusImpl(PRInt32 aFeature, 
81328:                               PRInt32* aStatus,
60894:                               nsAString& aSuggestedDriverVersion,
84603:                               const nsTArray<GfxDriverInfo>& aDriverInfo,
81328:                               OperatingSystem* aOS /* = nsnull */)
54887: {
58917:   NS_ENSURE_ARG_POINTER(aStatus);
85899: 
84607:   aSuggestedDriverVersion.SetIsVoid(true);
85899: 
85899:   PRInt32 status = nsIGfxInfo::FEATURE_STATUS_UNKNOWN;
85899: 
85896:   OperatingSystem os = OSXVersionToOperatingSystem(nsToolkit::OSXVersion());
58917: 
63217:   // Many WebGL issues on 10.5, especially:
63217:   //   * bug 631258: WebGL shader paints using textures belonging to other processes on Mac OS 10.5
63217:   //   * bug 618848: Post process shaders and texture mapping crash OS X 10.5
63217:   if (aFeature == nsIGfxInfo::FEATURE_WEBGL_OPENGL &&
85899:       !nsToolkit::OnSnowLeopardOrLater())
85899:   {
85899:     status = nsIGfxInfo::FEATURE_BLOCKED_OS_VERSION;
63217:   }
63217: 
85900:   if (aFeature == nsIGfxInfo::FEATURE_OPENGL_LAYERS) {
85900:     bool foundGoodDevice = false;
85900: 
85900:     if (!IsATIRadeonX1000(mAdapterVendorID, mAdapterDeviceID)) {
85900:       foundGoodDevice = true;
85900:     }
85900: 
79361: #if 0
58668:     // CGL reports a list of renderers, some renderers are slow (e.g. software)
58917:     // and AFAIK we can't decide which one will be used among them, so let's implement this by returning NO_INFO
58917:     // if any not-known-to-be-bad renderer is found.
58668:     // The assumption that we make here is that the system will spontaneously use the best/fastest renderer in the list.
58668:     // Note that the presence of software renderer fallbacks means that slow software rendering may be automatically
58668:     // used, which seems to be the case in bug 611292 where the user had a Intel GMA 945 card (non programmable hardware).
58668:     // Therefore we need to explicitly blacklist non-OpenGL2 hardware, which could result in a software renderer
58668:     // being used.
54887: 
80467:     for (PRUint32 i = 0; i < ArrayLength(mRendererIDs); ++i) {
58917:       switch (mRendererIDs[i]) {
58668:         case kCGLRendererATIRage128ID: // non-programmable
58668:         case kCGLRendererATIRadeonID: // non-programmable
58668:         case kCGLRendererATIRageProID: // non-programmable
58668:         case kCGLRendererATIRadeon8500ID: // no OpenGL 2 support, http://en.wikipedia.org/wiki/Radeon_R200
58668:         case kCGLRendererATIRadeon9700ID: // no OpenGL 2 support, http://en.wikipedia.org/wiki/Radeon_R200
58668:         case kCGLRendererATIRadeonX1000ID: // can't render to non-power-of-two texture backed framebuffers
58668:         case kCGLRendererIntel900ID: // non-programmable
58668:         case kCGLRendererGeForce2MXID: // non-programmable
58668:         case kCGLRendererGeForce3ID: // no OpenGL 2 support,
58668:                                      // http://en.wikipedia.org/wiki/Comparison_of_Nvidia_graphics_processing_units
58668:         case kCGLRendererGeForceFXID: // incomplete OpenGL 2 support with software fallbacks,
58668:                                       // http://en.wikipedia.org/wiki/Comparison_of_Nvidia_graphics_processing_units
58668:         case kCGLRendererVTBladeXP2ID: // Trident DX8 chip, assuming it's not GL2 capable
58668:         case kCGLRendererMesa3DFXID: // non-programmable
58668:         case kCGLRendererGenericFloatID: // software renderer
58668:         case kCGLRendererGenericID: // software renderer
58668:         case kCGLRendererAppleSWID: // software renderer
58668:           break;
58668:         default:
58917:           if (mRendererIDs[i])
79564:             foundGoodDevice = true;
58668:       }
54887:     }
79361: #endif
85900:     if (!foundGoodDevice)
85900:       status = nsIGfxInfo::FEATURE_BLOCKED_DEVICE;
85900:   }
85900: 
85900:   if (aFeature == nsIGfxInfo::FEATURE_WEBGL_OPENGL) {
85900:     // same comment as above for FEATURE_OPENGL_LAYERS.
85900:     bool foundGoodDevice = true;
85900: 
85900:     // Blacklist the Geforce 7300 GT because of bug 678053
85902:     if (mAdapterVendorID == 0x10de && mAdapterDeviceID == 0x0393) {
85900:       foundGoodDevice = false;
85900:     }
85900: 
85900:     if (!foundGoodDevice)
85900:       status = nsIGfxInfo::FEATURE_BLOCKED_DEVICE;
85900:   }
75271: 
81329:   if (aFeature == nsIGfxInfo::FEATURE_WEBGL_MSAA) {
81329:     // Blacklist all ATI cards on OSX, except for
81329:     // 0x6760 and 0x9488
85902:     if (mAdapterVendorID == GfxDriverInfo::vendorATI && 
85902:           (mAdapterDeviceID == 0x6760 || mAdapterDeviceID == 0x9488)) {
81329:       *aStatus = nsIGfxInfo::FEATURE_NO_INFO;
81329:       return NS_OK;
81329:     }
81329:   }
85899: 
85899:   if (aOS)
85899:     *aOS = os;
85899:   *aStatus = status;
81328: 
81328:   return GfxInfoBase::GetFeatureStatusImpl(aFeature, aStatus, aSuggestedDriverVersion, aDriverInfo, &os);
54887: }
