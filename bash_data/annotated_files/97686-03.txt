69246: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
54707:  *
54707:  * ***** BEGIN LICENSE BLOCK *****
54707:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54707:  *
54707:  * The contents of this file are subject to the Mozilla Public License Version
54707:  * 1.1 (the "License"); you may not use this file except in compliance with
54707:  * the License. You may obtain a copy of the License at
54707:  * http://www.mozilla.org/MPL/
54707:  *
54707:  * Software distributed under the License is distributed on an "AS IS" basis,
54707:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54707:  * for the specific language governing rights and limitations under the
54707:  * License.
54707:  *
54707:  * The Original Code is SpiderMonkey code.
54707:  *
54707:  * The Initial Developer of the Original Code is
54707:  * Mozilla Corporation.
54707:  * Portions created by the Initial Developer are Copyright (C) 2010
54707:  * the Initial Developer. All Rights Reserved.
54707:  *
54707:  * Contributor(s):
54707:  *
54707:  *
54707:  * Alternatively, the contents of this file may be used under the terms of
54707:  * either of the GNU General Public License Version 2 or later (the "GPL"),
54707:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54707:  * in which case the provisions of the GPL or the LGPL are applicable instead
54707:  * of those above. If you wish to allow use of your version of this file only
54707:  * under the terms of either the GPL or the LGPL, and not to allow others to
54707:  * use your version of this file under the terms of the MPL, indicate your
54707:  * decision by deleting the provisions above and replace them with the notice
54707:  * and other provisions required by the GPL or the LGPL. If you do not delete
54707:  * the provisions above, a recipient may use your version of this file under
54707:  * the terms of any one of the MPL, the GPL or the LGPL.
54707:  *
54707:  * ***** END LICENSE BLOCK ***** */
54707: 
54707: #ifndef jsgcinlines_h___
54707: #define jsgcinlines_h___
54707: 
54707: #include "jsgc.h"
54707: #include "jscntxt.h"
54707: #include "jscompartment.h"
80202: #include "jslock.h"
64345: #include "jsscope.h"
72099: #include "jsxml.h"
54707: 
80202: #include "js/TemplateLib.h"
54707: 
55746: namespace js {
64360: 
64360: struct Shape;
64360: 
55746: namespace gc {
55746: 
77659: inline JSGCTraceKind
64356: GetGCThingTraceKind(const void *thing)
64345: {
64345:     JS_ASSERT(thing);
64356:     const Cell *cell = reinterpret_cast<const Cell *>(thing);
77775:     return MapAllocToTraceKind(cell->getAllocKind());
64345: }
64345: 
55746: /* Capacity for slotsToThingKind */
55746: const size_t SLOTS_TO_THING_KIND_LIMIT = 17;
55746: 
55746: /* Get the best kind to use when making an object with the given slot count. */
77775: static inline AllocKind
83231: GetGCObjectKind(size_t numSlots)
55746: {
77775:     extern AllocKind slotsToThingKind[];
55746: 
83231:     if (numSlots >= SLOTS_TO_THING_KIND_LIMIT)
83231:         return FINALIZE_OBJECT16;
83231:     return slotsToThingKind[numSlots];
83231: }
83231: 
83233: static inline AllocKind
83233: GetGCObjectKind(Class *clasp)
83233: {
83234:     if (clasp == &FunctionClass)
83258:         return JSFunction::FinalizeKind;
84755:     uint32_t nslots = JSCLASS_RESERVED_SLOTS(clasp);
83233:     if (clasp->flags & JSCLASS_HAS_PRIVATE)
83233:         nslots++;
83233:     return GetGCObjectKind(nslots);
83233: }
83233: 
83231: /* As for GetGCObjectKind, but for dense array allocation. */
83231: static inline AllocKind
83231: GetGCArrayKind(size_t numSlots)
83231: {
83231:     extern AllocKind slotsToThingKind[];
83231: 
77343:     /*
83231:      * Dense arrays can use their fixed slots to hold their elements array
83231:      * (less two Values worth of ObjectElements header), but if more than the
83231:      * maximum number of fixed slots is needed then the fixed slots will be
83231:      * unused.
77343:      */
83281:     JS_STATIC_ASSERT(ObjectElements::VALUES_PER_HEADER == 2);
83247:     if (numSlots > JSObject::NELEMENTS_LIMIT || numSlots + 2 >= SLOTS_TO_THING_KIND_LIMIT)
83231:         return FINALIZE_OBJECT2;
83231:     return slotsToThingKind[numSlots + 2];
55746: }
55746: 
78194: static inline AllocKind
78194: GetGCObjectFixedSlotsKind(size_t numFixedSlots)
78194: {
78194:     extern AllocKind slotsToThingKind[];
78194: 
78194:     JS_ASSERT(numFixedSlots < SLOTS_TO_THING_KIND_LIMIT);
78194:     return slotsToThingKind[numFixedSlots];
78194: }
78194: 
77343: static inline bool
77775: IsBackgroundAllocKind(AllocKind kind)
77343: {
91956:     JS_ASSERT(kind <= FINALIZE_LAST);
91956:     return kind <= FINALIZE_OBJECT_LAST && kind % 2 == 1;
77343: }
77343: 
77775: static inline AllocKind
77775: GetBackgroundAllocKind(AllocKind kind)
77343: {
77775:     JS_ASSERT(!IsBackgroundAllocKind(kind));
77775:     return (AllocKind) (kind + 1);
77343: }
77343: 
77775: /*
77775:  * Try to get the next larger size for an object, keeping BACKGROUND
77775:  * consistent.
77775:  */
77343: static inline bool
77775: TryIncrementAllocKind(AllocKind *kindp)
77343: {
77775:     size_t next = size_t(*kindp) + 2;
82129:     if (next >= size_t(FINALIZE_OBJECT_LIMIT))
77775:         return false;
77775:     *kindp = AllocKind(next);
77775:     return true;
77343: }
77343: 
55746: /* Get the number of fixed slots and initial capacity associated with a kind. */
55746: static inline size_t
77775: GetGCKindSlots(AllocKind thingKind)
55746: {
55746:     /* Using a switch in hopes that thingKind will usually be a compile-time constant. */
55746:     switch (thingKind) {
55746:       case FINALIZE_OBJECT0:
68896:       case FINALIZE_OBJECT0_BACKGROUND:
55746:         return 0;
55746:       case FINALIZE_OBJECT2:
68896:       case FINALIZE_OBJECT2_BACKGROUND:
55746:         return 2;
55746:       case FINALIZE_OBJECT4:
68896:       case FINALIZE_OBJECT4_BACKGROUND:
55746:         return 4;
55746:       case FINALIZE_OBJECT8:
68896:       case FINALIZE_OBJECT8_BACKGROUND:
55746:         return 8;
55746:       case FINALIZE_OBJECT12:
68896:       case FINALIZE_OBJECT12_BACKGROUND:
55746:         return 12;
55746:       case FINALIZE_OBJECT16:
68896:       case FINALIZE_OBJECT16_BACKGROUND:
55746:         return 16;
55746:       default:
55746:         JS_NOT_REACHED("Bad object finalize kind");
55746:         return 0;
55746:     }
55746: }
55746: 
83247: static inline size_t
83247: GetGCKindSlots(AllocKind thingKind, Class *clasp)
83247: {
83247:     size_t nslots = GetGCKindSlots(thingKind);
83258: 
83258:     /* An object's private data uses the space taken by its last fixed slot. */
83247:     if (clasp->flags & JSCLASS_HAS_PRIVATE) {
83247:         JS_ASSERT(nslots > 0);
83247:         nslots--;
83247:     }
83258: 
83258:     /*
83258:      * Functions have a larger finalize kind than FINALIZE_OBJECT to reserve
83258:      * space for the extra fields in JSFunction, but have no fixed slots.
83258:      */
83258:     if (clasp == &FunctionClass)
83258:         nslots = 0;
83258: 
83247:     return nslots;
83247: }
83247: 
71353: static inline void
89826: GCPoke(JSRuntime *rt, Value oldval)
71353: {
71353:     /*
71353:      * Since we're forcing a GC from JS_GC anyway, don't bother wasting cycles
71353:      * loading oldval.  XXX remove implied force, fix jsinterp.c's "second arg
71353:      * ignored", etc.
71353:      */
71353: #if 1
89826:     rt->gcPoke = true;
71353: #else
89826:     rt->gcPoke = oldval.isGCThing();
71353: #endif
71353: 
71353: #ifdef JS_GC_ZEAL
71353:     /* Schedule a GC to happen "soon" after a GC poke. */
90410:     if (rt->gcZeal() == js::gc::ZealPokeValue)
89826:         rt->gcNextScheduled = 1;
71353: #endif
71353: }
71353: 
77464: /*
77464:  * Invoke ArenaOp and CellOp on every arena and cell in a compartment which
77464:  * have the specified thing kind.
77464:  */
77464: template <class ArenaOp, class CellOp>
77464: void
77775: ForEachArenaAndCell(JSCompartment *compartment, AllocKind thingKind,
77464:                     ArenaOp arenaOp, CellOp cellOp)
77464: {
77775:     size_t thingSize = Arena::thingSize(thingKind);
77775:     ArenaHeader *aheader = compartment->arenas.getFirstArena(thingKind);
77464: 
77464:     for (; aheader; aheader = aheader->next) {
77464:         Arena *arena = aheader->getArena();
77464:         arenaOp(arena);
77464:         FreeSpan firstSpan(aheader->getFirstFreeSpan());
77464:         const FreeSpan *span = &firstSpan;
77464: 
77775:         for (uintptr_t thing = arena->thingsStart(thingKind); ; thing += thingSize) {
77464:             JS_ASSERT(thing <= arena->thingsEnd());
77464:             if (thing == span->first) {
77464:                 if (!span->hasNext())
77464:                     break;
77464:                 thing = span->last;
77464:                 span = span->nextSpan();
77464:             } else {
77464:                 Cell *t = reinterpret_cast<Cell *>(thing);
77464:                 cellOp(t);
77464:             }
77464:         }
77464:     }
77464: }
77464: 
77659: class CellIterImpl
77659: {
77775:     size_t firstThingOffset;
77659:     size_t thingSize;
77659:     ArenaHeader *aheader;
77659:     FreeSpan firstSpan;
77659:     const FreeSpan *span;
77659:     uintptr_t thing;
77659:     Cell *cell;
77659: 
77659:   protected:
77659:     CellIterImpl() {
77659:     }
77659: 
90410:     void initSpan(JSCompartment *comp, AllocKind kind) {
77932:         JS_ASSERT(comp->arenas.isSynchronizedFreeList(kind));
77775:         firstThingOffset = Arena::firstThingOffset(kind);
77775:         thingSize = Arena::thingSize(kind);
77659:         firstSpan.initAsEmpty();
77659:         span = &firstSpan;
77659:         thing = span->first;
90410:     }
90410: 
90410:     void init(ArenaHeader *singleAheader) {
90410:         aheader = singleAheader;
90410:         initSpan(aheader->compartment, aheader->getAllocKind());
90410:         next();
90410:         aheader = NULL;
90410:     }
90410: 
90410:     void init(JSCompartment *comp, AllocKind kind) {
90410:         initSpan(comp, kind);
90410:         aheader = comp->arenas.getFirstArena(kind);
77659:         next();
77659:     }
77659: 
77659:   public:
77659:     bool done() const {
77659:         return !cell;
77659:     }
77659: 
77659:     template<typename T> T *get() const {
77659:         JS_ASSERT(!done());
77659:         return static_cast<T *>(cell);
77659:     }
77659: 
77659:     Cell *getCell() const {
77659:         JS_ASSERT(!done());
77659:         return cell;
77659:     }
77659: 
77659:     void next() {
77659:         for (;;) {
77659:             if (thing != span->first)
77659:                 break;
77659:             if (JS_LIKELY(span->hasNext())) {
77659:                 thing = span->last + thingSize;
77659:                 span = span->nextSpan();
77659:                 break;
77659:             }
77659:             if (!aheader) {
77659:                 cell = NULL;
77659:                 return;
77659:             }
77659:             firstSpan = aheader->getFirstFreeSpan();
77659:             span = &firstSpan;
77775:             thing = aheader->arenaAddress() | firstThingOffset;
77659:             aheader = aheader->next;
77659:         }
77659:         cell = reinterpret_cast<Cell *>(thing);
77659:         thing += thingSize;
77659:     }
77659: };
77659: 
90410: class CellIterUnderGC : public CellIterImpl
90410: {
77659:   public:
77775:     CellIterUnderGC(JSCompartment *comp, AllocKind kind) {
77659:         JS_ASSERT(comp->rt->gcRunning);
77775:         init(comp, kind);
77659:     }
90410: 
90410:     CellIterUnderGC(ArenaHeader *aheader) {
90410:         JS_ASSERT(aheader->compartment->rt->gcRunning);
90410:         init(aheader);
90410:     }
77659: };
77659: 
77659: /*
77659:  * When using the iterator outside the GC the caller must ensure that no GC or
77659:  * allocations of GC things are possible and that the background finalization
77659:  * for the given thing kind is not enabled or is done.
77659:  */
77659: class CellIter : public CellIterImpl
77659: {
77775:     ArenaLists *lists;
77775:     AllocKind kind;
77659: #ifdef DEBUG
77659:     size_t *counter;
77659: #endif
77659:   public:
91287:     CellIter(JSCompartment *comp, AllocKind kind)
77775:       : lists(&comp->arenas),
90410:         kind(kind)
90410:     {
91956:         /*
91956:          * We have a single-threaded runtime, so there's no need to protect
91956:          * against other threads iterating or allocating. However, we do have
91956:          * background finalization; make sure people aren't using CellIter to
91956:          * walk such allocation kinds.
91956:          */
91956:         JS_ASSERT(!IsBackgroundAllocKind(kind));
77775:         if (lists->isSynchronizedFreeList(kind)) {
77659:             lists = NULL;
77659:         } else {
77659:             JS_ASSERT(!comp->rt->gcRunning);
77775:             lists->copyFreeListToArena(kind);
77659:         }
77659: #ifdef DEBUG
91287:         counter = &comp->rt->noGCOrAllocationCheck;
77659:         ++*counter;
77659: #endif
77775:         init(comp, kind);
77659:     }
77659: 
77659:     ~CellIter() {
77659: #ifdef DEBUG
77659:         JS_ASSERT(*counter > 0);
77659:         --*counter;
77659: #endif
77659:         if (lists)
77775:             lists->clearFreeListInArena(kind);
77659:     }
77659: };
77659: 
77464: /* Signatures for ArenaOp and CellOp above. */
77464: 
77464: inline void EmptyArenaOp(Arena *arena) {}
77464: inline void EmptyCellOp(Cell *t) {}
77464: 
94620: class GCCompartmentsIter {
94620:   private:
94620:     JSCompartment **it, **end;
94620: 
94620:   public:
94620:     GCCompartmentsIter(JSRuntime *rt) {
94620:         JS_ASSERT(rt->gcRunning);
94620:         it = rt->compartments.begin();
94620:         end = rt->compartments.end();
94620:         if (!(*it)->isCollecting())
94620:             next();
94620:     }
94620: 
94620:     bool done() const { return it == end; }
94620: 
94620:     void next() {
94620:         JS_ASSERT(!done());
94620:         do {
94620:             it++;
94620:         } while (it != end && !(*it)->isCollecting());
94620:     }
94620: 
94620:     JSCompartment *get() const {
94620:         JS_ASSERT(!done());
94620:         return *it;
94620:     }
94620: 
94620:     operator JSCompartment *() const { return get(); }
94620:     JSCompartment *operator->() const { return get(); }
94620: };
94620: 
54707: /*
54707:  * Allocates a new GC thing. After a successful allocation the caller must
54707:  * fully initialize the thing before calling any function that can potentially
54707:  * trigger GC. This will ensure that GC tracing never sees junk values stored
54707:  * in the partially initialized thing.
54707:  */
54707: 
54707: template <typename T>
68933: inline T *
77775: NewGCThing(JSContext *cx, js::gc::AllocKind kind, size_t thingSize)
54707: {
77775:     JS_ASSERT(thingSize == js::gc::Arena::thingSize(kind));
55464: #ifdef JS_THREADSAFE
60584:     JS_ASSERT_IF((cx->compartment == cx->runtime->atomsCompartment),
77775:                  kind == js::gc::FINALIZE_STRING || kind == js::gc::FINALIZE_SHORT_STRING);
55464: #endif
69856:     JS_ASSERT(!cx->runtime->gcRunning);
88135:     JS_ASSERT(!cx->runtime->noGCOrAllocationCheck);
54707: 
92003:     /* For testing out of memory conditions */
95434:     JS_OOM_POSSIBLY_FAIL_REPORT(cx);
92003: 
71353: #ifdef JS_GC_ZEAL
71353:     if (cx->runtime->needZealousGC())
71353:         js::gc::RunDebugGC(cx);
71353: #endif
71353: 
97353:     MaybeCheckStackRoots(cx);
86437: 
82129:     JSCompartment *comp = cx->compartment;
82129:     void *t = comp->arenas.allocateFromFreeList(kind, thingSize);
82129:     if (!t)
82129:         t = js::gc::ArenaLists::refillFreeList(cx, kind);
90410: 
90410:     JS_ASSERT_IF(t && comp->needsBarrier(),
90410:                  static_cast<T *>(t)->arenaHeader()->allocatedDuringIncremental);
82129:     return static_cast<T *>(t);
54707: }
54707: 
83276: /* Alternate form which allocates a GC thing if doing so cannot trigger a GC. */
83276: template <typename T>
83276: inline T *
83276: TryNewGCThing(JSContext *cx, js::gc::AllocKind kind, size_t thingSize)
83276: {
83276:     JS_ASSERT(thingSize == js::gc::Arena::thingSize(kind));
83276: #ifdef JS_THREADSAFE
83276:     JS_ASSERT_IF((cx->compartment == cx->runtime->atomsCompartment),
83276:                  kind == js::gc::FINALIZE_STRING || kind == js::gc::FINALIZE_SHORT_STRING);
83276: #endif
83276:     JS_ASSERT(!cx->runtime->gcRunning);
88135:     JS_ASSERT(!cx->runtime->noGCOrAllocationCheck);
83276: 
83276: #ifdef JS_GC_ZEAL
83276:     if (cx->runtime->needZealousGC())
83276:         return NULL;
83276: #endif
83276: 
83276:     void *t = cx->compartment->arenas.allocateFromFreeList(kind, thingSize);
90410:     JS_ASSERT_IF(t && cx->compartment->needsBarrier(),
90410:                  static_cast<T *>(t)->arenaHeader()->allocatedDuringIncremental);
83276:     return static_cast<T *>(t);
83276: }
83276: 
83313: } /* namespace gc */
83313: } /* namespace js */
83313: 
54707: inline JSObject *
77775: js_NewGCObject(JSContext *cx, js::gc::AllocKind kind)
54707: {
82138:     JS_ASSERT(kind >= js::gc::FINALIZE_OBJECT0 && kind <= js::gc::FINALIZE_OBJECT_LAST);
83313:     return js::gc::NewGCThing<JSObject>(cx, kind, js::gc::Arena::thingSize(kind));
80202: }
80202: 
83276: inline JSObject *
83276: js_TryNewGCObject(JSContext *cx, js::gc::AllocKind kind)
83276: {
83276:     JS_ASSERT(kind >= js::gc::FINALIZE_OBJECT0 && kind <= js::gc::FINALIZE_OBJECT_LAST);
83313:     return js::gc::TryNewGCThing<JSObject>(cx, kind, js::gc::Arena::thingSize(kind));
54707: }
54707: 
54707: inline JSString *
54707: js_NewGCString(JSContext *cx)
54707: {
83313:     return js::gc::NewGCThing<JSString>(cx, js::gc::FINALIZE_STRING, sizeof(JSString));
54707: }
54707: 
54707: inline JSShortString *
54707: js_NewGCShortString(JSContext *cx)
54707: {
83313:     return js::gc::NewGCThing<JSShortString>(cx, js::gc::FINALIZE_SHORT_STRING, sizeof(JSShortString));
54707: }
54707: 
57817: inline JSExternalString *
72099: js_NewGCExternalString(JSContext *cx)
54707: {
83313:     return js::gc::NewGCThing<JSExternalString>(cx, js::gc::FINALIZE_EXTERNAL_STRING,
72099:                                                 sizeof(JSExternalString));
54707: }
54707: 
77659: inline JSScript *
77659: js_NewGCScript(JSContext *cx)
77659: {
83313:     return js::gc::NewGCThing<JSScript>(cx, js::gc::FINALIZE_SCRIPT, sizeof(JSScript));
77659: }
77659: 
64360: inline js::Shape *
64360: js_NewGCShape(JSContext *cx)
64360: {
83313:     return js::gc::NewGCThing<js::Shape>(cx, js::gc::FINALIZE_SHAPE, sizeof(js::Shape));
64360: }
64360: 
83221: inline js::BaseShape *
83221: js_NewGCBaseShape(JSContext *cx)
83221: {
83313:     return js::gc::NewGCThing<js::BaseShape>(cx, js::gc::FINALIZE_BASE_SHAPE, sizeof(js::BaseShape));
83221: }
83221: 
54707: #if JS_HAS_XML_SUPPORT
74914: extern JSXML *
74914: js_NewGCXML(JSContext *cx);
54707: #endif
54707: 
54707: #endif /* jsgcinlines_h___ */
