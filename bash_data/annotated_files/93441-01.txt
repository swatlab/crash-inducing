    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Oracle Corporation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Oracle Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@pavlov.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "gfxWindowsSurface.h"
    1: #include "gfxContext.h"
    1: #include "gfxPlatform.h"
    1: 
    1: #include "cairo.h"
    1: #include "cairo-win32.h"
    1: 
    1: #include "nsString.h"
    1: 
47767: gfxWindowsSurface::gfxWindowsSurface(HWND wnd, PRUint32 flags) :
80486:     mOwnsDC(true), mForPrinting(false), mWnd(wnd)
    1: {
    1:     mDC = ::GetDC(mWnd);
47767:     InitWithDC(flags);
    1: }
    1: 
 6274: gfxWindowsSurface::gfxWindowsSurface(HDC dc, PRUint32 flags) :
80486:     mOwnsDC(false), mForPrinting(false), mDC(dc), mWnd(nsnull)
    1: {
 6274:     if (flags & FLAG_TAKE_DC)
80486:         mOwnsDC = true;
 6274: 
21300: #ifdef NS_PRINTING
 6274:     if (flags & FLAG_FOR_PRINTING) {
 8452:         Init(cairo_win32_printing_surface_create(mDC));
80486:         mForPrinting = true;
21300:     } else
21300: #endif
47767:     InitWithDC(flags);
47727: }
    1: 
79633: void
79633: gfxWindowsSurface::MakeInvalid(gfxIntSize& size)
79633: {
79633:     size = gfxIntSize(-1, -1);
79633: }
79633: 
79633: gfxWindowsSurface::gfxWindowsSurface(const gfxIntSize& realSize, gfxImageFormat imageFormat) :
80486:     mOwnsDC(false), mForPrinting(false), mWnd(nsnull)
    1: {
79633:     gfxIntSize size(realSize);
 1349:     if (!CheckSurfaceSize(size))
79633:         MakeInvalid(size);
 1349: 
    1:     cairo_surface_t *surf = cairo_win32_surface_create_with_dib((cairo_format_t)imageFormat,
    1:                                                                 size.width, size.height);
42553: 
    1:     Init(surf);
    1: 
42553:     RecordMemoryUsed(size.width * size.height * 4 + sizeof(gfxWindowsSurface));
42553: 
 6615:     if (CairoStatus() == 0)
    1:         mDC = cairo_win32_surface_get_dc(CairoSurface());
 6615:     else
 6615:         mDC = nsnull;
    1: }
    1: 
79633: gfxWindowsSurface::gfxWindowsSurface(HDC dc, const gfxIntSize& realSize, gfxImageFormat imageFormat) :
80486:     mOwnsDC(false), mForPrinting(false), mWnd(nsnull)
    1: {
79633:     gfxIntSize size(realSize);
 1349:     if (!CheckSurfaceSize(size))
79633:         MakeInvalid(size);
 1349: 
    1:     cairo_surface_t *surf = cairo_win32_surface_create_with_ddb(dc, (cairo_format_t)imageFormat,
    1:                                                                 size.width, size.height);
42553: 
    1:     Init(surf);
    1: 
93441:     if (mSurfaceValid) {
42553:         // DDBs will generally only use 3 bytes per pixel when RGB24
42553:         int bytesPerPixel = ((imageFormat == gfxASurface::ImageFormatRGB24) ? 3 : 4);
42553:         RecordMemoryUsed(size.width * size.height * bytesPerPixel + sizeof(gfxWindowsSurface));
93441:     }
42553: 
 6615:     if (CairoStatus() == 0)
    1:         mDC = cairo_win32_surface_get_dc(CairoSurface());
 6615:     else
 6615:         mDC = nsnull;
    1: }
    1: 
    1: gfxWindowsSurface::gfxWindowsSurface(cairo_surface_t *csurf) :
80486:     mOwnsDC(false), mForPrinting(false), mWnd(nsnull)
    1: {
 6615:     if (cairo_surface_status(csurf) == 0)
    1:         mDC = cairo_win32_surface_get_dc(csurf);
 6615:     else
 6615:         mDC = nsnull;
    1: 
 6274:     if (cairo_surface_get_type(csurf) == CAIRO_SURFACE_TYPE_WIN32_PRINTING)
80486:         mForPrinting = true;
 6274: 
80486:     Init(csurf, true);
    1: }
    1: 
47767: void
47767: gfxWindowsSurface::InitWithDC(PRUint32 flags)
47767: {
47767:     if (flags & FLAG_IS_TRANSPARENT) {
47767:         Init(cairo_win32_surface_create_with_alpha(mDC));
47767:     } else {
47767:         Init(cairo_win32_surface_create(mDC));
47767:     }
47767: }
47767: 
61718: already_AddRefed<gfxASurface>
61718: gfxWindowsSurface::CreateSimilarSurface(gfxContentType aContent,
61718:                                         const gfxIntSize& aSize)
61718: {
61718:     if (!mSurface || !mSurfaceValid) {
61718:         return nsnull;
61718:     }
61718: 
61718:     cairo_surface_t *surface;
61718:     if (GetContentType() == CONTENT_COLOR_ALPHA) {
61718:         // When creating a similar surface to a transparent surface, ensure
61718:         // the new surface uses a DIB. cairo_surface_create_similar won't
61718:         // use  a DIB for a CONTENT_COLOR surface if this surface doesn't
61718:         // have a DIB (e.g. if we're a transparent window surface). But
61718:         // we need a DIB to perform well if the new surface is composited into
61718:         // a surface that's the result of create_similar(CONTENT_COLOR_ALPHA)
61718:         // (e.g. a backbuffer for the window) --- that new surface *would*
61718:         // have a DIB.
61718:         surface =
61718:           cairo_win32_surface_create_with_dib(cairo_format_t(gfxASurface::FormatFromContent(aContent)),
61718:                                               aSize.width, aSize.height);
61718:     } else {
61718:         surface =
61718:           cairo_surface_create_similar(mSurface, cairo_content_t(aContent),
61718:                                        aSize.width, aSize.height);
61718:     }
61718: 
61718:     if (cairo_surface_status(surface)) {
61718:         cairo_surface_destroy(surface);
61718:         return nsnull;
61718:     }
61718: 
61718:     nsRefPtr<gfxASurface> result = Wrap(surface);
61718:     cairo_surface_destroy(surface);
61718:     return result.forget();
61718: }
61718: 
    1: gfxWindowsSurface::~gfxWindowsSurface()
    1: {
    1:     if (mOwnsDC) {
    1:         if (mWnd)
    1:             ::ReleaseDC(mWnd, mDC);
    1:         else
    1:             ::DeleteDC(mDC);
    1:     }
    1: }
    1: 
41340: HDC
41340: gfxWindowsSurface::GetDCWithClip(gfxContext *ctx)
41340: {
41340:     return cairo_win32_get_dc_with_clip (ctx->GetCairo());
41340: }
41340: 
    1: already_AddRefed<gfxImageSurface>
57344: gfxWindowsSurface::GetAsImageSurface()
    1: {
10842:     if (!mSurfaceValid) {
10842:         NS_WARNING ("GetImageSurface on an invalid (null) surface; who's calling this without checking for surface errors?");
10842:         return nsnull;
10842:     }
10842: 
10842:     NS_ASSERTION(CairoSurface() != nsnull, "CairoSurface() shouldn't be nsnull when mSurfaceValid is TRUE!");
10842: 
 6274:     if (mForPrinting)
 6274:         return nsnull;
 6274: 
    1:     cairo_surface_t *isurf = cairo_win32_surface_get_image(CairoSurface());
    1:     if (!isurf)
    1:         return nsnull;
    1: 
    1:     nsRefPtr<gfxASurface> asurf = gfxASurface::Wrap(isurf);
    1:     gfxImageSurface *imgsurf = (gfxImageSurface*) asurf.get();
    1:     NS_ADDREF(imgsurf);
    1:     return imgsurf;
    1: }
    1: 
    1: already_AddRefed<gfxWindowsSurface>
    1: gfxWindowsSurface::OptimizeToDDB(HDC dc, const gfxIntSize& size, gfxImageFormat format)
    1: {
 6274:     if (mForPrinting)
 6274:         return nsnull;
 6274: 
 6615:     if (format != ImageFormatRGB24)
    1:         return nsnull;
    1: 
 6615:     nsRefPtr<gfxWindowsSurface> wsurf = new gfxWindowsSurface(dc, size, format);
 6615:     if (wsurf->CairoStatus() != 0)
 6615:         return nsnull;
    1: 
 9751:     gfxContext tmpCtx(wsurf);
 9751:     tmpCtx.SetOperator(gfxContext::OPERATOR_SOURCE);
 9751:     tmpCtx.SetSource(this);
 9751:     tmpCtx.Paint();
    1: 
    1:     gfxWindowsSurface *raw = (gfxWindowsSurface*) (wsurf.get());
    1:     NS_ADDREF(raw);
31392: 
31392:     // we let the new DDB surfaces be converted back to dibsections if
31392:     // acquire_source_image is called on them
31392:     cairo_win32_surface_set_can_convert_to_dib(raw->CairoSurface(), TRUE);
31392: 
    1:     return raw;
    1: }
    1: 
29278: nsresult
29278: gfxWindowsSurface::BeginPrinting(const nsAString& aTitle,
    1:                                  const nsAString& aPrintToFileName)
    1: {
29278: #ifdef NS_PRINTING
57893: #define DOC_TITLE_LENGTH (MAX_PATH-1)
18480:     DOCINFOW docinfo;
    1: 
18480:     nsString titleStr(aTitle);
    1:     if (titleStr.Length() > DOC_TITLE_LENGTH) {
    1:         titleStr.SetLength(DOC_TITLE_LENGTH-3);
    1:         titleStr.AppendLiteral("...");
    1:     }
12902: 
18480:     nsString docName(aPrintToFileName);
    1:     docinfo.cbSize = sizeof(docinfo);
18480:     docinfo.lpszDocName = titleStr.Length() > 0 ? titleStr.get() : L"Mozilla Document";
18480:     docinfo.lpszOutput = docName.Length() > 0 ? docName.get() : nsnull;
    1:     docinfo.lpszDatatype = NULL;
    1:     docinfo.fwType = 0;
    1: 
18480:     ::StartDocW(mDC, &docinfo);
13596: 
    1:     return NS_OK;
29278: #else
29278:     return NS_ERROR_FAILURE;
29278: #endif
    1: }
    1: 
29278: nsresult
29278: gfxWindowsSurface::EndPrinting()
    1: {
29278: #ifdef NS_PRINTING
13596:     int result = ::EndDoc(mDC);
13596:     if (result <= 0)
13596:         return NS_ERROR_FAILURE;
13596: 
    1:     return NS_OK;
29278: #else
29278:     return NS_ERROR_FAILURE;
29278: #endif
    1: }
    1: 
29278: nsresult
29278: gfxWindowsSurface::AbortPrinting()
    1: {
29278: #ifdef NS_PRINTING
13596:     int result = ::AbortDoc(mDC);
13596:     if (result <= 0)
13596:         return NS_ERROR_FAILURE;
    1:     return NS_OK;
29278: #else
29278:     return NS_ERROR_FAILURE;
29278: #endif
    1: }
    1: 
29278: nsresult
29278: gfxWindowsSurface::BeginPage()
    1: {
29278: #ifdef NS_PRINTING
13596:     int result = ::StartPage(mDC);
13596:     if (result <= 0)
13596:         return NS_ERROR_FAILURE;
    1:     return NS_OK;
29278: #else
29278:     return NS_ERROR_FAILURE;
29278: #endif
    1: }
    1: 
29278: nsresult
29278: gfxWindowsSurface::EndPage()
    1: {
29278: #ifdef NS_PRINTING
 6274:     if (mForPrinting)
 6274:         cairo_surface_show_page(CairoSurface());
13596:     int result = ::EndPage(mDC);
13596:     if (result <= 0)
13596:         return NS_ERROR_FAILURE;
    1:     return NS_OK;
29278: #else
29278:     return NS_ERROR_FAILURE;
29278: #endif
    1: }
 8452: 
29278: PRInt32
29278: gfxWindowsSurface::GetDefaultContextFlags() const
 8452: {
 8452:     if (mForPrinting)
 9965:         return gfxContext::FLAG_SIMPLIFY_OPERATORS |
60646:                gfxContext::FLAG_DISABLE_SNAPPING |
60646:                gfxContext::FLAG_DISABLE_COPY_BACKGROUND;
 8452: 
 8452:     return 0;
 8452: }
74887: 
82415: const gfxIntSize 
82415: gfxWindowsSurface::GetSize() const
82415: {
82415:     if (!mSurfaceValid) {
82415:         NS_WARNING ("GetImageSurface on an invalid (null) surface; who's calling this without checking for surface errors?");
82415:         return gfxIntSize(-1, -1);
82415:     }
82415: 
82415:     NS_ASSERTION(mSurface != nsnull, "CairoSurface() shouldn't be nsnull when mSurfaceValid is TRUE!");
82415: 
82415:     return gfxIntSize(cairo_win32_surface_get_width(mSurface),
82415:                       cairo_win32_surface_get_height(mSurface));
82415: }
82415: 
74887: gfxASurface::MemoryLocation
74887: gfxWindowsSurface::GetMemoryLocation() const
74887: {
74887:     return MEMORY_IN_PROCESS_NONHEAP;
74887: }
