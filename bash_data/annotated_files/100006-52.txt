 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 18830:  * vim: set ts=8 sw=4 et tw=99:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 93250: #include "jsgc.h"
 93250: #include "jsinfer.h"
 93250: #include "jsinterp.h"
 80468: 
 93250: #include "vm/GlobalObject.h"
 93250: #include "vm/MethodGuard.h"
 93250: #include "vm/Stack.h"
 94006: #include "vm/Xdr.h"
 80468: 
 93250: #include "jsobjinlines.h"
 80506: 
 93250: #include "gc/Barrier-inl.h"
 93250: #include "vm/ArgumentsObject-inl.h"
     1: 
 37741: using namespace js;
 54707: using namespace js::gc;
 37741: 
100006: struct PutArg
100006: {
100006:     PutArg(JSCompartment *comp, ArgumentsObject &argsobj)
100006:       : compartment(comp), argsobj(argsobj), dst(argsobj.data()->slots) {}
100006:     JSCompartment *compartment;
100006:     ArgumentsObject &argsobj;
100006:     HeapValue *dst;
100006:     bool operator()(unsigned i, Value *src) {
100006:         JS_ASSERT(dst->isUndefined());
100006:         if (!argsobj.isElementDeleted(i))
100006:             dst->set(compartment, *src);
100006:         ++dst;
100006:         return true;
100006:     }
100006: };
100006: 
100006: void
100006: js_PutArgsObject(StackFrame *fp)
100006: {
100006:     ArgumentsObject &argsobj = fp->argsObj();
100006:     if (argsobj.isNormalArguments()) {
100006:         JS_ASSERT(argsobj.maybeStackFrame() == fp);
100006:         JSCompartment *comp = fp->compartment();
100006:         fp->forEachCanonicalActualArg(PutArg(comp, argsobj));
100006:         argsobj.setStackFrame(NULL);
100006:     } else {
100006:         JS_ASSERT(!argsobj.maybeStackFrame());
100006:     }
100006: }
100006: 
 99994: ArgumentsObject *
100006: ArgumentsObject::create(JSContext *cx, uint32_t argc, HandleObject callee)
 93250: {
100006:     JS_ASSERT(argc <= StackSpace::ARGS_LENGTH_MAX);
100006:     JS_ASSERT(!callee->toFunction()->hasRest());
100006: 
100006:     RootedObject proto(cx, callee->global().getOrCreateObjectPrototype(cx));
 93249:     if (!proto)
 93249:         return NULL;
 93249: 
 99421:     RootedTypeObject type(cx);
100006: 
 93249:     type = proto->getNewType(cx);
 93249:     if (!type)
 93249:         return NULL;
 93249: 
100006:     bool strict = callee->toFunction()->inStrictMode();
 93249:     Class *clasp = strict ? &StrictArgumentsObjectClass : &NormalArgumentsObjectClass;
 93249: 
 99421:     RootedShape emptyArgumentsShape(cx);
 93249:     emptyArgumentsShape =
 93249:         EmptyShape::getInitialShape(cx, clasp, proto,
 93249:                                     proto->getParent(), FINALIZE_KIND,
 93249:                                     BaseShape::INDEXED);
 93249:     if (!emptyArgumentsShape)
 93249:         return NULL;
 93249: 
100006:     unsigned numDeletedWords = NumWordsForBitArrayOfLength(argc);
100006:     unsigned numBytes = offsetof(ArgumentsData, slots) +
 93646:                         numDeletedWords * sizeof(size_t) +
100006:                         argc * sizeof(Value);
 93646: 
 93646:     ArgumentsData *data = (ArgumentsData *)cx->malloc_(numBytes);
 93249:     if (!data)
 93249:         return NULL;
 93249: 
100006:     data->callee.init(ObjectValue(*callee));
100006:     for (HeapValue *vp = data->slots; vp != data->slots + argc; vp++)
100006:         vp->init(UndefinedValue());
100006:     data->deletedBits = (size_t *)(data->slots + argc);
 93646:     ClearAllBitArrayElements(data->deletedBits, numDeletedWords);
 93249: 
100006:     /* We have everything needed to fill in the object, so make the object. */
 93249:     JSObject *obj = JSObject::create(cx, FINALIZE_KIND, emptyArgumentsShape, type, NULL);
 93249:     if (!obj)
 93249:         return NULL;
 93249: 
100006:     ArgumentsObject &argsobj = obj->asArguments();
 99994: 
100006:     JS_ASSERT(UINT32_MAX > (uint64_t(argc) << PACKED_BITS_COUNT));
100006:     argsobj.initInitialLength(argc);
100006:     argsobj.initData(data);
100006:     argsobj.setStackFrame(NULL);
 99994: 
100006:     JS_ASSERT(argsobj.numFixedSlots() >= NormalArgumentsObject::RESERVED_SLOTS);
100006:     JS_ASSERT(argsobj.numFixedSlots() >= StrictArgumentsObject::RESERVED_SLOTS);
 99994: 
 93249:     return &argsobj;
 93249: }
 93249: 
 95100: ArgumentsObject *
100006: ArgumentsObject::create(JSContext *cx, StackFrame *fp)
 93249: {
 93250:     JS_ASSERT(fp->script()->needsArgsObj());
100006: 
100006:     ArgumentsObject *argsobj = ArgumentsObject::create(cx, fp->numActualArgs(),
100006:                                                        RootedObject(cx, &fp->callee()));
 93249:     if (!argsobj)
 93250:         return NULL;
 93249: 
100006:     /*
100006:      * Strict mode functions have arguments objects that copy the initial
100006:      * actual parameter values. Non-strict mode arguments use the frame pointer
100006:      * to retrieve up-to-date parameter values.
100006:      */
100006:     if (argsobj->isStrictArguments())
100006:         fp->forEachCanonicalActualArg(PutArg(cx->compartment, *argsobj));
100006:     else
100006:         argsobj->setStackFrame(fp);
100006: 
 93250:     fp->initArgsObj(*argsobj);
 93249:     return argsobj;
 93249: }
 93249: 
 93250: ArgumentsObject *
 93250: ArgumentsObject::createUnexpected(JSContext *cx, StackFrame *fp)
 93249: {
100006:     ArgumentsObject *argsobj = create(cx, fp->numActualArgs(), RootedObject(cx, &fp->callee()));
100006:     if (!argsobj)
100006:         return NULL;
100006: 
100006:     fp->forEachCanonicalActualArg(PutArg(cx->compartment, *argsobj));
100006:     return argsobj;
 93249: }
 93249: 
 93249: static JSBool
 98960: args_delProperty(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
 93249: {
 93249:     ArgumentsObject &argsobj = obj->asArguments();
 93249:     if (JSID_IS_INT(id)) {
 93249:         unsigned arg = unsigned(JSID_TO_INT(id));
100006:         if (arg < argsobj.initialLength() && !argsobj.isElementDeleted(arg)) {
100006:             argsobj.setElement(arg, UndefinedValue());
 93646:             argsobj.markElementDeleted(arg);
100006:         }
 93249:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
 93249:         argsobj.markLengthOverridden();
 93249:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom)) {
 93249:         argsobj.asNormalArguments().clearCallee();
 93249:     }
 93249:     return true;
 93249: }
 93249: 
 93249: static JSBool
 98960: ArgGetter(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
 93249: {
 93249:     if (!obj->isNormalArguments())
 93249:         return true;
 93249: 
 93249:     NormalArgumentsObject &argsobj = obj->asNormalArguments();
 93249:     if (JSID_IS_INT(id)) {
 93249:         /*
 93249:          * arg can exceed the number of arguments if a script changed the
 93249:          * prototype to point to another Arguments object with a bigger argc.
 93249:          */
 93249:         unsigned arg = unsigned(JSID_TO_INT(id));
100006:         if (arg < argsobj.initialLength() && !argsobj.isElementDeleted(arg)) {
100006:             if (StackFrame *fp = argsobj.maybeStackFrame()) {
100006:                 JS_ASSERT_IF(arg < fp->numFormalArgs(), fp->script()->formalIsAliased(arg));
100006:                 *vp = fp->canonicalActualArg(arg);
100006:             } else {
 93249:                 *vp = argsobj.element(arg);
100006:             }
100006:         }
 93249:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
 93249:         if (!argsobj.hasOverriddenLength())
100006:             vp->setInt32(argsobj.initialLength());
 93249:     } else {
 93249:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom));
100006:         const Value &v = argsobj.callee();
100006:         if (!v.isMagic(JS_OVERWRITTEN_CALLEE))
100006:             *vp = v;
 93249:     }
 93249:     return true;
 93249: }
 93249: 
 93249: static JSBool
 98960: ArgSetter(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp)
 93249: {
 93249:     if (!obj->isNormalArguments())
 93249:         return true;
 93249: 
 93249:     NormalArgumentsObject &argsobj = obj->asNormalArguments();
 93249: 
 93249:     if (JSID_IS_INT(id)) {
 93249:         unsigned arg = unsigned(JSID_TO_INT(id));
100006:         if (arg < argsobj.initialLength()) {
100006:             if (StackFrame *fp = argsobj.maybeStackFrame()) {
100006:                 JSScript *script = fp->functionScript();
100006:                 JS_ASSERT(script->needsArgsObj());
100006:                 if (arg < fp->numFormalArgs()) {
100006:                     JS_ASSERT(fp->script()->formalIsAliased(arg));
 93250:                     types::TypeScript::SetArgument(cx, script, arg, *vp);
100006:                 }
100006:                 fp->canonicalActualArg(arg) = *vp;
 93249:                 return true;
 93249:             }
100006:         }
 93249:     } else {
 93249:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom) ||
 93249:                   JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom));
 93249:     }
 93249: 
 93249:     /*
 93249:      * For simplicity we use delete/define to replace the property with one
 93249:      * backed by the default Object getter and setter. Note that we rely on
 93249:      * args_delProperty to clear the corresponding reserved slot so the GC can
 93249:      * collect its value. Note also that we must define the property instead
 93249:      * of setting it in case the user has changed the prototype to an object
 93249:      * that has a setter for this id.
 93249:      */
 99421:     RootedValue value(cx);
 98960:     return baseops::DeleteGeneric(cx, obj, id, value.address(), false) &&
 98960:            baseops::DefineProperty(cx, obj, id, vp, NULL, NULL, JSPROP_ENUMERATE);
 93249: }
 93249: 
 93249: static JSBool
 98960: args_resolve(JSContext *cx, HandleObject obj, HandleId id, unsigned flags,
 93249:              JSObject **objp)
 93249: {
 93249:     *objp = NULL;
 93249: 
 99421:     Rooted<NormalArgumentsObject*> argsobj(cx, &obj->asNormalArguments());
 93249: 
 93249:     unsigned attrs = JSPROP_SHARED | JSPROP_SHADOWABLE;
 93249:     if (JSID_IS_INT(id)) {
 93249:         uint32_t arg = uint32_t(JSID_TO_INT(id));
 95355:         if (arg >= argsobj->initialLength() || argsobj->isElementDeleted(arg))
 93249:             return true;
 93249: 
 93249:         attrs |= JSPROP_ENUMERATE;
 93249:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
 95355:         if (argsobj->hasOverriddenLength())
 93249:             return true;
 93249:     } else {
 93249:         if (!JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom))
 93249:             return true;
 93249: 
 95355:         if (argsobj->callee().isMagic(JS_OVERWRITTEN_CALLEE))
 93249:             return true;
 93249:     }
 93249: 
 93249:     Value undef = UndefinedValue();
 98960:     if (!baseops::DefineProperty(cx, argsobj, id, &undef, ArgGetter, ArgSetter, attrs))
 93249:         return JS_FALSE;
 93249: 
 95355:     *objp = argsobj;
 93249:     return true;
 93249: }
 93249: 
 93250: bool
 93250: NormalArgumentsObject::optimizedGetElem(JSContext *cx, StackFrame *fp, const Value &elem, Value *vp)
 93250: {
100006:     JS_ASSERT(!fp->hasArgsObj());
 93250: 
 93645:     /* Fast path: no need to convert to id when elem is already an int in range. */
 93250:     if (elem.isInt32()) {
 93250:         int32_t i = elem.toInt32();
 93250:         if (i >= 0 && uint32_t(i) < fp->numActualArgs()) {
100006:             *vp = fp->canonicalActualArg(i);
 93250:             return true;
 93250:         }
 93250:     }
 93250: 
 93645:     /* Slow path: create and canonicalize an id, then emulate args_resolve. */
 93645: 
 93250:     jsid id;
 93250:     if (!ValueToId(cx, elem, &id))
 93250:         return false;
 93645: 
 93645:     if (JSID_IS_INT(id)) {
 93645:         int32_t i = JSID_TO_INT(id);
 93645:         if (i >= 0 && uint32_t(i) < fp->numActualArgs()) {
100006:             *vp = fp->canonicalActualArg(i);
 93645:             return true;
 93645:         }
 93645:     }
 93250: 
 97828:     if (id == NameToId(cx->runtime->atomState.lengthAtom)) {
 93250:         *vp = Int32Value(fp->numActualArgs());
 93250:         return true;
 93250:     }
 93250: 
 97828:     if (id == NameToId(cx->runtime->atomState.calleeAtom)) {
 93250:         *vp = ObjectValue(fp->callee());
 93250:         return true;
 93250:     }
 93250: 
 96793:     JSObject *proto = fp->global().getOrCreateObjectPrototype(cx);
 93250:     if (!proto)
 93250:         return false;
 93250: 
 99421:     return proto->getGeneric(cx, RootedId(cx, id), vp);
 93250: }
 93250: 
 93249: static JSBool
 98960: args_enumerate(JSContext *cx, HandleObject obj)
 93249: {
 99421:     Rooted<NormalArgumentsObject*> argsobj(cx, &obj->asNormalArguments());
 99421:     RootedId id(cx);
 93249: 
 93249:     /*
 93249:      * Trigger reflection in args_resolve using a series of js_LookupProperty
 93249:      * calls.
 93249:      */
 97353:     int argc = int(argsobj->initialLength());
 93249:     for (int i = -2; i != argc; i++) {
 98960:         id = (i == -2)
 97828:              ? NameToId(cx->runtime->atomState.lengthAtom)
 93249:              : (i == -1)
 97828:              ? NameToId(cx->runtime->atomState.calleeAtom)
 93249:              : INT_TO_JSID(i);
 93249: 
 93249:         JSObject *pobj;
 93249:         JSProperty *prop;
 98960:         if (!baseops::LookupProperty(cx, argsobj, id, &pobj, &prop))
 93249:             return false;
 93249:     }
 93249:     return true;
 93249: }
 93249: 
 93249: static JSBool
 98960: StrictArgGetter(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
 93249: {
 93249:     if (!obj->isStrictArguments())
 93249:         return true;
 93249: 
 93249:     StrictArgumentsObject &argsobj = obj->asStrictArguments();
 93249: 
 93249:     if (JSID_IS_INT(id)) {
 93249:         /*
 93249:          * arg can exceed the number of arguments if a script changed the
 93249:          * prototype to point to another Arguments object with a bigger argc.
 93249:          */
 93249:         unsigned arg = unsigned(JSID_TO_INT(id));
 93646:         if (arg < argsobj.initialLength() && !argsobj.isElementDeleted(arg))
 93646:             *vp = argsobj.element(arg);
 93249:     } else {
 93249:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
 93249:         if (!argsobj.hasOverriddenLength())
 93249:             vp->setInt32(argsobj.initialLength());
 93249:     }
 93249:     return true;
 93249: }
 93249: 
 93249: static JSBool
 98960: StrictArgSetter(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp)
 93249: {
 93249:     if (!obj->isStrictArguments())
 93249:         return true;
 93249: 
 99421:     Rooted<StrictArgumentsObject*> argsobj(cx, &obj->asStrictArguments());
 93249: 
 93249:     if (JSID_IS_INT(id)) {
 93249:         unsigned arg = unsigned(JSID_TO_INT(id));
 95355:         if (arg < argsobj->initialLength()) {
 95355:             argsobj->setElement(arg, *vp);
 93249:             return true;
 93249:         }
 93249:     } else {
 93249:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
 93249:     }
 93249: 
 93249:     /*
 93249:      * For simplicity we use delete/set to replace the property with one
 93249:      * backed by the default Object getter and setter. Note that we rely on
 93249:      * args_delProperty to clear the corresponding reserved slot so the GC can
 93249:      * collect its value.
 93249:      */
 99421:     RootedValue value(cx);
 98960:     return baseops::DeleteGeneric(cx, argsobj, id, value.address(), strict) &&
 98960:            baseops::SetPropertyHelper(cx, argsobj, id, 0, vp, strict);
 93249: }
 93249: 
 93249: static JSBool
 98960: strictargs_resolve(JSContext *cx, HandleObject obj, HandleId id, unsigned flags, JSObject **objp)
 93249: {
 93249:     *objp = NULL;
 93249: 
 99421:     Rooted<StrictArgumentsObject*> argsobj(cx, &obj->asStrictArguments());
 93249: 
 93249:     unsigned attrs = JSPROP_SHARED | JSPROP_SHADOWABLE;
 93249:     PropertyOp getter = StrictArgGetter;
 93249:     StrictPropertyOp setter = StrictArgSetter;
 93249: 
 93249:     if (JSID_IS_INT(id)) {
 93249:         uint32_t arg = uint32_t(JSID_TO_INT(id));
 97353:         if (arg >= argsobj->initialLength() || argsobj->isElementDeleted(arg))
 93249:             return true;
 93249: 
 93249:         attrs |= JSPROP_ENUMERATE;
 93249:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
 97353:         if (argsobj->hasOverriddenLength())
 93249:             return true;
 93249:     } else {
 93249:         if (!JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom) &&
 93249:             !JSID_IS_ATOM(id, cx->runtime->atomState.callerAtom)) {
 93249:             return true;
 93249:         }
 93249: 
 93249:         attrs = JSPROP_PERMANENT | JSPROP_GETTER | JSPROP_SETTER | JSPROP_SHARED;
 97353:         getter = CastAsPropertyOp(argsobj->global().getThrowTypeError());
 97353:         setter = CastAsStrictPropertyOp(argsobj->global().getThrowTypeError());
 93249:     }
 93249: 
 93249:     Value undef = UndefinedValue();
 98960:     if (!baseops::DefineProperty(cx, argsobj, id, &undef, getter, setter, attrs))
 93249:         return false;
 93249: 
 97353:     *objp = argsobj;
 93249:     return true;
 93249: }
 93249: 
 93249: static JSBool
 98960: strictargs_enumerate(JSContext *cx, HandleObject obj)
 93249: {
 99421:     Rooted<StrictArgumentsObject*> argsobj(cx, &obj->asStrictArguments());
 93249: 
 93249:     /*
 93249:      * Trigger reflection in strictargs_resolve using a series of
 93249:      * js_LookupProperty calls.
 93249:      */
 93249:     JSObject *pobj;
 93249:     JSProperty *prop;
 99421:     RootedId id(cx);
 93249: 
 93249:     // length
 98960:     id = NameToId(cx->runtime->atomState.lengthAtom);
 98960:     if (!baseops::LookupProperty(cx, argsobj, id, &pobj, &prop))
 93249:         return false;
 93249: 
 93249:     // callee
 98960:     id = NameToId(cx->runtime->atomState.calleeAtom);
 98960:     if (!baseops::LookupProperty(cx, argsobj, id, &pobj, &prop))
 93249:         return false;
 93249: 
 93249:     // caller
 98960:     id = NameToId(cx->runtime->atomState.callerAtom);
 98960:     if (!baseops::LookupProperty(cx, argsobj, id, &pobj, &prop))
 93249:         return false;
 93249: 
 93249:     for (uint32_t i = 0, argc = argsobj->initialLength(); i < argc; i++) {
 98960:         id = INT_TO_JSID(i);
 98960:         if (!baseops::LookupProperty(cx, argsobj, id, &pobj, &prop))
 93249:             return false;
 93249:     }
 93249: 
 93249:     return true;
 93249: }
 93249: 
100006: static void
100006: args_finalize(FreeOp *fop, JSObject *obj)
 93249: {
 94738:     fop->free_(reinterpret_cast<void *>(obj->asArguments().data()));
 93249: }
 93249: 
100006: static void
100006: args_trace(JSTracer *trc, JSObject *obj)
 93249: {
 93249:     ArgumentsObject &argsobj = obj->asArguments();
 93249:     ArgumentsData *data = argsobj.data();
 93249:     MarkValue(trc, &data->callee, js_callee_str);
100006:     MarkValueRange(trc, argsobj.initialLength(), data->slots, js_arguments_str);
100006: 
100006:     /*
100006:      * If a generator's arguments or call object escapes, and the generator
100006:      * frame is not executing, the generator object needs to be marked because
100006:      * it is not otherwise reachable. An executing generator is rooted by its
100006:      * invocation.  To distinguish the two cases (which imply different access
100006:      * paths to the generator object), we use the JSFRAME_FLOATING_GENERATOR
100006:      * flag, which is only set on the StackFrame kept in the generator object's
100006:      * JSGenerator.
100006:      */
100006: #if JS_HAS_GENERATORS
100006:     StackFrame *fp = argsobj.maybeStackFrame();
100006:     if (fp && fp->isFloatingGenerator())
100006:         MarkObject(trc, &js_FloatingFrameToGenerator(fp)->obj, "generator object");
100006: #endif
 93249: }
 93249: 
 93249: /*
 93249:  * The classes below collaborate to lazily reflect and synchronize actual
 93249:  * argument values, argument count, and callee function object stored in a
 93249:  * StackFrame with their corresponding property values in the frame's
 93249:  * arguments object.
 93249:  */
 93249: Class js::NormalArgumentsObjectClass = {
 93249:     "Arguments",
 93249:     JSCLASS_NEW_RESOLVE | JSCLASS_IMPLEMENTS_BARRIERS |
 93249:     JSCLASS_HAS_RESERVED_SLOTS(NormalArgumentsObject::RESERVED_SLOTS) |
 93249:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object) |
 93249:     JSCLASS_FOR_OF_ITERATION,
 93249:     JS_PropertyStub,         /* addProperty */
 93249:     args_delProperty,
 93249:     JS_PropertyStub,         /* getProperty */
 93249:     JS_StrictPropertyStub,   /* setProperty */
 93249:     args_enumerate,
 93249:     reinterpret_cast<JSResolveOp>(args_resolve),
 93249:     JS_ConvertStub,
100006:     args_finalize,           /* finalize   */
 93249:     NULL,                    /* checkAccess */
 93249:     NULL,                    /* call        */
 93249:     NULL,                    /* construct   */
 93249:     NULL,                    /* hasInstance */
100006:     args_trace,
 93249:     {
 93249:         NULL,       /* equality    */
 93249:         NULL,       /* outerObject */
 93249:         NULL,       /* innerObject */
 93249:         JS_ElementIteratorStub,
 93249:         NULL,       /* unused      */
 93249:         false,      /* isWrappedNative */
 93249:     }
 93249: };
 93249: 
 93249: /*
 93249:  * Strict mode arguments is significantly less magical than non-strict mode
 93249:  * arguments, so it is represented by a different class while sharing some
 93249:  * functionality.
 93249:  */
 93249: Class js::StrictArgumentsObjectClass = {
 93249:     "Arguments",
 93249:     JSCLASS_NEW_RESOLVE | JSCLASS_IMPLEMENTS_BARRIERS |
 93249:     JSCLASS_HAS_RESERVED_SLOTS(StrictArgumentsObject::RESERVED_SLOTS) |
 93249:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object) |
 93249:     JSCLASS_FOR_OF_ITERATION,
 93249:     JS_PropertyStub,         /* addProperty */
 93249:     args_delProperty,
 93249:     JS_PropertyStub,         /* getProperty */
 93249:     JS_StrictPropertyStub,   /* setProperty */
 93249:     strictargs_enumerate,
 93249:     reinterpret_cast<JSResolveOp>(strictargs_resolve),
 93249:     JS_ConvertStub,
100006:     args_finalize,           /* finalize   */
 93249:     NULL,                    /* checkAccess */
 93249:     NULL,                    /* call        */
 93249:     NULL,                    /* construct   */
 93249:     NULL,                    /* hasInstance */
100006:     args_trace,
 93249:     {
 93249:         NULL,       /* equality    */
 93249:         NULL,       /* outerObject */
 93249:         NULL,       /* innerObject */
 93249:         JS_ElementIteratorStub,
 93249:         NULL,       /* unused      */
 93249:         false,      /* isWrappedNative */
 93249:     }
 93249: };
