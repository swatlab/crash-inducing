    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsparse_h___
    1: #define jsparse_h___
    1: /*
    1:  * JS parser definitions.
    1:  */
18863: #include "jsversion.h"
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
27012: #include "jsatom.h"
    1: #include "jsscan.h"
    1: 
    1: JS_BEGIN_EXTERN_C
    1: 
    1: /*
    1:  * Parsing builds a tree of nodes that directs code generation.  This tree is
    1:  * not a concrete syntax tree in all respects (for example, || and && are left
    1:  * associative, but (A && B && C) translates into the right-associated tree
    1:  * <A && <B && C>> so that code generation can emit a left-associative branch
    1:  * around <B && C> when A is false).  Nodes are labeled by token type, with a
    1:  * JSOp secondary label when needed:
    1:  *
    1:  * Label        Variant     Members
    1:  * -----        -------     -------
    1:  * <Definitions>
27012:  * TOK_FUNCTION name        pn_funbox: ptr to JSFunctionBox holding function
 3235:  *                            object containing arg and var properties.  We
 3235:  *                            create the function object at parse (not emit)
 3235:  *                            time to specialize arg and var bytecodes early.
27012:  *                          pn_body: TOK_UPVARS if the function's source body
27012:  *                                   depends on outer names, else TOK_ARGSBODY
27012:  *                                   if formal parameters, else TOK_LC node for
27012:  *                                   function body statements
27012:  *                          pn_cookie: static level and var index for function
27012:  *                          pn_dflags: PND_* definition/use flags (see below)
27012:  *                          pn_blockid: block id number
27012:  * TOK_ARGSBODY list        list of formal parameters followed by TOK_LC node
27012:  *                            for function body statements as final element
27012:  *                          pn_count: 1 + number of formal parameters
27012:  * TOK_UPVARS   nameset     pn_names: lexical dependencies (JSDefinitions)
27012:  *                            defined in enclosing scopes, or ultimately not
27012:  *                            defined (free variables, either global property
27012:  *                            references or reference errors).
27012:  *                          pn_argsbody: TOK_ARGSBODY or TOK_LC node
    1:  *
    1:  * <Statements>
    1:  * TOK_LC       list        pn_head: list of pn_count statements
    1:  * TOK_IF       ternary     pn_kid1: cond, pn_kid2: then, pn_kid3: else or null
    1:  * TOK_SWITCH   binary      pn_left: discriminant
    1:  *                          pn_right: list of TOK_CASE nodes, with at most one
    1:  *                            TOK_DEFAULT node, or if there are let bindings
    1:  *                            in the top level of the switch body's cases, a
    1:  *                            TOK_LEXICALSCOPE node that contains the list of
    1:  *                            TOK_CASE nodes.
    1:  * TOK_CASE,    binary      pn_left: case expr or null if TOK_DEFAULT
    1:  * TOK_DEFAULT              pn_right: TOK_LC node for this case's statements
    1:  *                          pn_val: constant value if lookup or table switch
    1:  * TOK_WHILE    binary      pn_left: cond, pn_right: body
    1:  * TOK_DO       binary      pn_left: body, pn_right: cond
    1:  * TOK_FOR      binary      pn_left: either
    1:  *                            for/in loop: a binary TOK_IN node with
    1:  *                              pn_left:  TOK_VAR or TOK_NAME to left of 'in'
27012:  *                                if TOK_VAR, its pn_xflags may have PNX_POPVAR
    1:  *                                and PNX_FORINVAR bits set
    1:  *                              pn_right: object expr to right of 'in'
    1:  *                            for(;;) loop: a ternary TOK_RESERVED node with
    1:  *                              pn_kid1:  init expr before first ';'
    1:  *                              pn_kid2:  cond expr before second ';'
    1:  *                              pn_kid3:  update expr after second ';'
    1:  *                              any kid may be null
    1:  *                          pn_right: body
    1:  * TOK_THROW    unary       pn_op: JSOP_THROW, pn_kid: exception
    1:  * TOK_TRY      ternary     pn_kid1: try block
    1:  *                          pn_kid2: null or TOK_RESERVED list of
    1:  *                          TOK_LEXICALSCOPE nodes, each with pn_expr pointing
    1:  *                          to a TOK_CATCH node
    1:  *                          pn_kid3: null or finally block
    1:  * TOK_CATCH    ternary     pn_kid1: TOK_NAME, TOK_RB, or TOK_RC catch var node
    1:  *                                   (TOK_RB or TOK_RC if destructuring)
    1:  *                          pn_kid2: null or the catch guard expression
    1:  *                          pn_kid3: catch block statements
    1:  * TOK_BREAK    name        pn_atom: label or null
    1:  * TOK_CONTINUE name        pn_atom: label or null
    1:  * TOK_WITH     binary      pn_left: head expr, pn_right: body
27012:  * TOK_VAR      list        pn_head: list of TOK_NAME or TOK_ASSIGN nodes
    1:  *                                   each name node has
27012:  *                                     pn_used: false
    1:  *                                     pn_atom: variable name
    1:  *                                     pn_expr: initializer or null
27012:  *                                   each assignment node has
27012:  *                                     pn_left: TOK_NAME with pn_used true and
27012: *                                               pn_lexdef (NOT pn_expr) set
27012:  *                                     pn_right: initializer
    1:  * TOK_RETURN   unary       pn_kid: return expr or null
    1:  * TOK_SEMI     unary       pn_kid: expr or null statement
    1:  * TOK_COLON    name        pn_atom: label, pn_expr: labeled statement
    1:  *
    1:  * <Expressions>
    1:  * All left-associated binary trees of the same type are optimized into lists
    1:  * to avoid recursion when processing expression chains.
    1:  * TOK_COMMA    list        pn_head: list of pn_count comma-separated exprs
    1:  * TOK_ASSIGN   binary      pn_left: lvalue, pn_right: rvalue
    1:  *                          pn_op: JSOP_ADD for +=, etc.
    1:  * TOK_HOOK     ternary     pn_kid1: cond, pn_kid2: then, pn_kid3: else
    1:  * TOK_OR       binary      pn_left: first in || chain, pn_right: rest of chain
    1:  * TOK_AND      binary      pn_left: first in && chain, pn_right: rest of chain
    1:  * TOK_BITOR    binary      pn_left: left-assoc | expr, pn_right: ^ expr
    1:  * TOK_BITXOR   binary      pn_left: left-assoc ^ expr, pn_right: & expr
    1:  * TOK_BITAND   binary      pn_left: left-assoc & expr, pn_right: EQ expr
    1:  * TOK_EQOP     binary      pn_left: left-assoc EQ expr, pn_right: REL expr
    1:  *                          pn_op: JSOP_EQ, JSOP_NE,
    1:  *                                 JSOP_STRICTEQ, JSOP_STRICTNE
    1:  * TOK_RELOP    binary      pn_left: left-assoc REL expr, pn_right: SH expr
    1:  *                          pn_op: JSOP_LT, JSOP_LE, JSOP_GT, JSOP_GE
    1:  * TOK_SHOP     binary      pn_left: left-assoc SH expr, pn_right: ADD expr
    1:  *                          pn_op: JSOP_LSH, JSOP_RSH, JSOP_URSH
    1:  * TOK_PLUS,    binary      pn_left: left-assoc ADD expr, pn_right: MUL expr
27012:  *                          pn_xflags: if a left-associated binary TOK_PLUS
    1:  *                            tree has been flattened into a list (see above
27012:  *                            under <Expressions>), pn_xflags will contain
    1:  *                            PNX_STRCAT if at least one list element is a
    1:  *                            string literal (TOK_STRING); if such a list has
27012:  *                            any non-string, non-number term, pn_xflags will
    1:  *                            contain PNX_CANTFOLD.
    1:  *                          pn_
    1:  * TOK_MINUS                pn_op: JSOP_ADD, JSOP_SUB
    1:  * TOK_STAR,    binary      pn_left: left-assoc MUL expr, pn_right: UNARY expr
    1:  * TOK_DIVOP                pn_op: JSOP_MUL, JSOP_DIV, JSOP_MOD
    1:  * TOK_UNARYOP  unary       pn_kid: UNARY expr, pn_op: JSOP_NEG, JSOP_POS,
    1:  *                          JSOP_NOT, JSOP_BITNOT, JSOP_TYPEOF, JSOP_VOID
    1:  * TOK_INC,     unary       pn_kid: MEMBER expr
    1:  * TOK_DEC
    1:  * TOK_NEW      list        pn_head: list of ctor, arg1, arg2, ... argN
    1:  *                          pn_count: 1 + N (where N is number of args)
    1:  *                          ctor is a MEMBER expr
    1:  * TOK_DELETE   unary       pn_kid: MEMBER expr
    1:  * TOK_DOT,     name        pn_expr: MEMBER expr to left of .
    1:  * TOK_DBLDOT               pn_atom: name to right of .
    1:  * TOK_LB       binary      pn_left: MEMBER expr to left of [
    1:  *                          pn_right: expr between [ and ]
    1:  * TOK_LP       list        pn_head: list of call, arg1, arg2, ... argN
    1:  *                          pn_count: 1 + N (where N is number of args)
    1:  *                          call is a MEMBER expr naming a callable object
    1:  * TOK_RB       list        pn_head: list of pn_count array element exprs
    1:  *                          [,,] holes are represented by TOK_COMMA nodes
27012:  *                          pn_xflags: PN_ENDCOMMA if extra comma at end
    1:  * TOK_RC       list        pn_head: list of pn_count TOK_COLON nodes where
    1:  *                          each has pn_left: property id, pn_right: value
11039:  *                          var {x} = object destructuring shorthand shares
11039:  *                          PN_NAME node for x on left and right of TOK_COLON
27012:  *                          node in TOK_RC's list, has PNX_DESTRUCT flag
    1:  * TOK_DEFSHARP unary       pn_num: jsint value of n in #n=
26959:  *                          pn_kid: primary function, paren, name, object or
26959:  *                                  array literal expressions
    1:  * TOK_USESHARP nullary     pn_num: jsint value of n in #n#
    1:  * TOK_RP       unary       pn_kid: parenthesized expression
    1:  * TOK_NAME,    name        pn_atom: name, string, or object atom
    1:  * TOK_STRING,              pn_op: JSOP_NAME, JSOP_STRING, or JSOP_OBJECT, or
    1:  *                                 JSOP_REGEXP
 6561:  * TOK_REGEXP               If JSOP_NAME, pn_op may be JSOP_*ARG or JSOP_*VAR
27012:  *                          with pn_cookie telling (staticLevel, slot) (see
27012:  *                          jsscript.h's UPVAR macros) and pn_dflags telling
27012:  *                          const-ness and static analysis results
27012:  * TOK_NAME     name        If pn_used, TOK_NAME uses the lexdef member instead
27012:  *                          of the expr member it overlays
    1:  * TOK_NUMBER   dval        pn_dval: double value of numeric literal
    1:  * TOK_PRIMARY  nullary     pn_op: JSOp bytecode
    1:  *
    1:  * <E4X node descriptions>
    1:  * TOK_ANYNAME  nullary     pn_op: JSOP_ANYNAME
    1:  *                          pn_atom: cx->runtime->atomState.starAtom
    1:  * TOK_AT       unary       pn_op: JSOP_TOATTRNAME; pn_kid attribute id/expr
    1:  * TOK_DBLCOLON binary      pn_op: JSOP_QNAME
    1:  *                          pn_left: TOK_ANYNAME or TOK_NAME node
    1:  *                          pn_right: TOK_STRING "*" node, or expr within []
    1:  *              name        pn_op: JSOP_QNAMECONST
    1:  *                          pn_expr: TOK_ANYNAME or TOK_NAME left operand
    1:  *                          pn_atom: name on right of ::
    1:  * TOK_XMLELEM  list        XML element node
    1:  *                          pn_head: start tag, content1, ... contentN, end tag
    1:  *                          pn_count: 2 + N where N is number of content nodes
    1:  *                                    N may be > x.length() if {expr} embedded
    1:  * TOK_XMLLIST  list        XML list node
    1:  *                          pn_head: content1, ... contentN
    1:  * TOK_XMLSTAGO, list       XML start, end, and point tag contents
    1:  * TOK_XMLETAGC,            pn_head: tag name or {expr}, ... XML attrs ...
    1:  * TOK_XMLPTAGO
    1:  * TOK_XMLNAME  nullary     pn_atom: XML name, with no {expr} embedded
    1:  * TOK_XMLNAME  list        pn_head: tag name or {expr}, ... name or {expr}
    1:  * TOK_XMLATTR, nullary     pn_atom: attribute value string; pn_op: JSOP_STRING
    1:  * TOK_XMLCDATA,
    1:  * TOK_XMLCOMMENT
    1:  * TOK_XMLPI    nullary     pn_atom: XML processing instruction target
    1:  *                          pn_atom2: XML PI content, or null if no content
    1:  * TOK_XMLTEXT  nullary     pn_atom: marked-up text, or null if empty string
    1:  * TOK_LC       unary       {expr} in XML tag or content; pn_kid is expr
    1:  *
    1:  * So an XML tag with no {expr} and three attributes is a list with the form:
    1:  *
    1:  *    (tagname attrname1 attrvalue1 attrname2 attrvalue2 attrname2 attrvalue3)
    1:  *
    1:  * An XML tag with embedded expressions like so:
    1:  *
    1:  *    <name1{expr1} name2{expr2}name3={expr3}>
    1:  *
    1:  * would have the form:
    1:  *
    1:  *    ((name1 {expr1}) (name2 {expr2} name3) {expr3})
    1:  *
    1:  * where () bracket a list with elements separated by spaces, and {expr} is a
    1:  * TOK_LC unary node with expr as its kid.
    1:  *
    1:  * Thus, the attribute name/value pairs occupy successive odd and even list
    1:  * locations, where pn_head is the TOK_XMLNAME node at list location 0.  The
    1:  * parser builds the same sort of structures for elements:
    1:  *
    1:  *    <a x={x}>Hi there!<b y={y}>How are you?</b><answer>{x + y}</answer></a>
    1:  *
    1:  * translates to:
    1:  *
    1:  *    ((a x {x}) 'Hi there!' ((b y {y}) 'How are you?') ((answer) {x + y}))
    1:  *
    1:  * <Non-E4X node descriptions, continued>
    1:  *
    1:  * Label              Variant   Members
    1:  * -----              -------   -------
    1:  * TOK_LEXICALSCOPE   name      pn_op: JSOP_LEAVEBLOCK or JSOP_LEAVEBLOCKEXPR
27012:  *                              pn_objbox: block object in JSObjectBox holder
    1:  *                              pn_expr: block body
    1:  * TOK_ARRAYCOMP      list      pn_head: list of pn_count (1 or 2) elements
    1:  *                              if pn_count is 2, first element is #n=[...]
    1:  *                                last element is block enclosing for loop(s)
    1:  *                                and optionally if-guarded TOK_ARRAYPUSH
    1:  * TOK_ARRAYPUSH      unary     pn_op: JSOP_ARRAYCOMP
    1:  *                              pn_kid: array comprehension expression
    1:  */
    1: typedef enum JSParseNodeArity {
27012:     PN_NULLARY,                         /* 0 kids, only pn_atom/pn_dval/etc. */
27012:     PN_UNARY,                           /* one kid, plus a couple of scalars */
27012:     PN_BINARY,                          /* two kids, plus a couple of scalars */
27012:     PN_TERNARY,                         /* three kids */
27012:     PN_FUNC,                            /* function definition node */
27012:     PN_LIST,                            /* generic singly linked list */
27012:     PN_NAME,                            /* name use or definition node */
27012:     PN_NAMESET                          /* JSAtomList + JSParseNode ptr */
    1: } JSParseNodeArity;
    1: 
27012: struct JSDefinition;
27012: 
    1: struct JSParseNode {
27012:     uint32              pn_type:16,     /* TOK_* type, see jsscan.h */
27012:                         pn_op:8,        /* see JSOp enum and jsopcode.tbl */
27012:                         pn_arity:6,     /* see JSParseNodeArity enum */
27012:                         pn_used:1,      /* name node is on a use-chain */
27012:                         pn_defn:1;      /* this node is a JSDefinition */
27012: 
27012: #define PN_OP(pn)    ((JSOp)(pn)->pn_op)
27012: #define PN_TYPE(pn)  ((JSTokenType)(pn)->pn_type)
27012: 
27012:     JSTokenPos          pn_pos;         /* two 16-bit pairs here, for 64 bits */
27012:     int32               pn_offset;      /* first generated bytecode offset */
27012:     JSParseNode         *pn_next;       /* intrinsic link in parent PN_LIST */
27012:     JSParseNode         *pn_link;       /* def/use link (alignment freebie) */
    1:     union {
    1:         struct {                        /* list of next-linked nodes */
    1:             JSParseNode *head;          /* first node in list */
    1:             JSParseNode **tail;         /* ptr to ptr to last node in list */
    1:             uint32      count;          /* number of nodes in list */
27012:             uint32      xflags:12,      /* extra flags, see below */
27012:                         blockid:20;     /* see name variant below */
    1:         } list;
    1:         struct {                        /* ternary: if, for(;;), ?: */
    1:             JSParseNode *kid1;          /* condition, discriminant, etc. */
    1:             JSParseNode *kid2;          /* then-part, case list, etc. */
    1:             JSParseNode *kid3;          /* else-part, default case, etc. */
    1:         } ternary;
    1:         struct {                        /* two kids if binary */
    1:             JSParseNode *left;
    1:             JSParseNode *right;
    1:             jsval       val;            /* switch case value */
15613:             uintN       iflags;         /* JSITER_* flags for TOK_FOR node */
    1:         } binary;
    1:         struct {                        /* one kid if unary */
    1:             JSParseNode *kid;
    1:             jsint       num;            /* -1 or sharp variable number */
 1577:             JSBool      hidden;         /* hidden genexp-induced JSOP_YIELD */
    1:         } unary;
    1:         struct {                        /* name, labeled statement, etc. */
27012:             union {
27012:                 JSAtom        *atom;    /* lexical name or label atom */
27012:                 JSFunctionBox *funbox;  /* function object */
27012:                 JSObjectBox   *objbox;  /* block or regexp object */
27012:             };
27012:             union {
27012:                 JSParseNode  *expr;     /* function body, var initializer, or
27012:                                            base object of TOK_DOT */
27012:                 JSDefinition *lexdef;   /* lexical definition for this use */
27012:             };
27012:             uint32      cookie;         /* upvar cookie with absolute frame
27012:                                            level (not relative skip), possibly
27012:                                            in current frame */
27012:             uint32      dflags:12,      /* definition/use flags, see below */
27012:                         blockid:20;     /* block number, for subset dominance
27012:                                            computation */
    1:         } name;
27012:         struct {                        /* lexical dependencies + sub-tree */
27012:             JSAtomSet   names;          /* set of names with JSDefinitions */
27012:             JSParseNode *tree;          /* sub-tree containing name uses */
27012:         } nameset;
27012:         struct {                        /* PN_NULLARY variant for E4X */
    1:             JSAtom      *atom;          /* first atom in pair */
    1:             JSAtom      *atom2;         /* second atom in pair or null */
    1:         } apair;
    1:         jsdouble        dval;           /* aligned numeric literal value */
    1:     } pn_u;
    1: 
27012: #define pn_funbox       pn_u.name.funbox
27012: #define pn_body         pn_u.name.expr
27012: #define pn_cookie       pn_u.name.cookie
27012: #define pn_dflags       pn_u.name.dflags
27012: #define pn_blockid      pn_u.name.blockid
27012: #define pn_index        pn_u.name.blockid /* reuse as object table index */
    1: #define pn_head         pn_u.list.head
    1: #define pn_tail         pn_u.list.tail
    1: #define pn_count        pn_u.list.count
27012: #define pn_xflags       pn_u.list.xflags
    1: #define pn_kid1         pn_u.ternary.kid1
    1: #define pn_kid2         pn_u.ternary.kid2
    1: #define pn_kid3         pn_u.ternary.kid3
    1: #define pn_left         pn_u.binary.left
    1: #define pn_right        pn_u.binary.right
    1: #define pn_val          pn_u.binary.val
15613: #define pn_iflags       pn_u.binary.iflags
    1: #define pn_kid          pn_u.unary.kid
    1: #define pn_num          pn_u.unary.num
 1577: #define pn_hidden       pn_u.unary.hidden
    1: #define pn_atom         pn_u.name.atom
27012: #define pn_objbox       pn_u.name.objbox
    1: #define pn_expr         pn_u.name.expr
27012: #define pn_lexdef       pn_u.name.lexdef
27012: #define pn_names        pn_u.nameset.names
27012: #define pn_tree         pn_u.nameset.tree
    1: #define pn_dval         pn_u.dval
    1: #define pn_atom2        pn_u.apair.atom2
    1: 
27012:     /*
27012:      * The pn_expr and lexdef members are arms of an unsafe union. Unless you
27012:      * know exactly what you're doing, use only the following methods to access
27012:      * them. For less overhead and assertions for protection, use pn->expr()
27012:      * and pn->lexdef(). Otherwise, use pn->maybeExpr() and pn->maybeLexDef().
27012:      */
27012:     JSParseNode  *expr() const {
27012:         JS_ASSERT(!pn_used);
27012:         JS_ASSERT(pn_arity == PN_NAME || pn_arity == PN_FUNC);
27012:         return pn_expr;
27012:     }
27012: 
27012:     JSDefinition *lexdef() const {
27012:         JS_ASSERT(pn_used);
27012:         JS_ASSERT(pn_arity == PN_NAME);
27012:         return pn_lexdef;
27012:     }
27012: 
27012:     JSParseNode  *maybeExpr()   { return pn_used ? NULL : expr(); }
27012:     JSDefinition *maybeLexDef() { return pn_used ? lexdef() : NULL; }
27012: 
27012: /* PN_FUNC and PN_NAME pn_dflags bits. */
27012: #define PND_LET         0x01            /* let (block-scoped) binding */
27012: #define PND_CONST       0x02            /* const binding (orthogonal to let) */
27012: #define PND_INITIALIZED 0x04            /* initialized declaration */
27012: #define PND_ASSIGNED    0x08            /* set if ever LHS of assignment */
27012: #define PND_TOPLEVEL    0x10            /* function at top of body or prog */
27012: #define PND_BLOCKCHILD  0x20            /* use or def is direct block child */
27012: #define PND_FORWARD     0x40            /* forward referenced definition */
27012: #define PND_PLACEHOLDER 0x80            /* placeholder definition for lexdep */
27012: #define PND_FUNARG     0x100            /* downward or upward funarg usage */
27012: #define PND_BOUND      0x200            /* bound to a stack or global slot */
27012: #define PND_GVAR       0x400            /* gvar binding, can't close over
27012:                                            because it could be deleted */
27012: 
27012: /* PN_LIST pn_xflags bits. */
    1: #define PNX_STRCAT      0x01            /* TOK_PLUS list has string term */
    1: #define PNX_CANTFOLD    0x02            /* TOK_PLUS list has unfoldable term */
    1: #define PNX_POPVAR      0x04            /* TOK_VAR last result needs popping */
    1: #define PNX_FORINVAR    0x08            /* TOK_VAR is left kid of TOK_IN node,
    1:                                            which is left kid of TOK_FOR */
    1: #define PNX_ENDCOMMA    0x10            /* array literal has comma at end */
    1: #define PNX_XMLROOT     0x20            /* top-most node in XML literal tree */
    1: #define PNX_GROUPINIT   0x40            /* var [a, b] = [c, d]; unit list */
    1: #define PNX_NEEDBRACES  0x80            /* braces necessary due to closure */
10466: #define PNX_FUNCDEFS   0x100            /* contains top-level function
10466:                                            statements */
27012: #define PNX_DESTRUCT   0x200            /* destructuring special cases:
27012:                                            1. shorthand syntax used, at present
27012:                                               object destructuring ({x,y}) only;
27012:                                            2. the first child of function body
27012:                                               is code evaluating destructuring
27012:                                               arguments */
27012: 
27012:     uintN frameLevel() const {
27012:         JS_ASSERT(pn_arity == PN_FUNC || pn_arity == PN_NAME);
27012:         return UPVAR_FRAME_SKIP(pn_cookie);
27012:     }
27012: 
27012:     uintN frameSlot() const {
27012:         JS_ASSERT(pn_arity == PN_FUNC || pn_arity == PN_NAME);
27012:         return UPVAR_FRAME_SLOT(pn_cookie);
27012:     }
27012: 
27012:     bool test(uintN flag) const {
27012:         JS_ASSERT(pn_arity == PN_FUNC || pn_arity == PN_NAME);
27012:         return !!(pn_dflags & flag);
27012:     }
27012: 
27012:     bool isLet() const          { return test(PND_LET); }
27012:     bool isConst() const        { return test(PND_CONST); }
27012:     bool isInitialized() const  { return test(PND_INITIALIZED); }
27012:     bool isTopLevel() const     { return test(PND_TOPLEVEL); }
27012:     bool isBlockChild() const   { return test(PND_BLOCKCHILD); }
27012:     bool isForward() const      { return test(PND_FORWARD); }
27012:     bool isPlaceholder() const  { return test(PND_PLACEHOLDER); }
27012: 
27012:     /* Defined below, see after struct JSDefinition. */
27012:     bool isAssigned() const;
27012:     bool isFunArg() const;
27111:     void setFunArg();
27012: 
27012:     void become(JSParseNode *pn2);
27012:     void clear();
27012: 
27012:     /* True if pn is a parsenode representing a literal constant. */
27012:     bool isLiteral() const {
27012:         return PN_TYPE(this) == TOK_NUMBER ||
27012:                PN_TYPE(this) == TOK_STRING ||
27012:                (PN_TYPE(this) == TOK_PRIMARY && PN_OP(this) != JSOP_THIS);
27012:     }
26968: 
26970:     /*
27012:      * Compute a pointer to the last element in a singly-linked list. NB: list
27012:      * must be non-empty for correct PN_LAST usage -- this is asserted!
26970:      */
27012:     JSParseNode *last() const {
27012:         JS_ASSERT(pn_arity == PN_LIST);
27012:         JS_ASSERT(pn_count != 0);
27012:         return (JSParseNode *)((char *)pn_tail - offsetof(JSParseNode, pn_next));
27012:     }
26968: 
27012:     void makeEmpty() {
27012:         JS_ASSERT(pn_arity == PN_LIST);
27012:         pn_head = NULL;
27012:         pn_tail = &pn_head;
27012:         pn_count = 0;
27012:         pn_xflags = 0;
27012:         pn_blockid = 0;
27012:     }
26968: 
27012:     void initList(JSParseNode *pn) {
27012:         JS_ASSERT(pn_arity == PN_LIST);
27012:         pn_head = pn;
27012:         pn_tail = &pn->pn_next;
27012:         pn_count = 1;
27012:         pn_xflags = 0;
27012:         pn_blockid = 0;
27012:     }
26970: 
27012:     void append(JSParseNode *pn) {
27012:         JS_ASSERT(pn_arity == PN_LIST);
27012:         *pn_tail = pn;
27012:         pn_tail = &pn->pn_next;
27012:         pn_count++;
27012:     }
27012: };
11039: 
    1: /*
27012:  * JSDefinition is a degenerate subtype of the PN_FUNC and PN_NAME variants of
27012:  * JSParseNode, allocated only for function, var, const, and let declarations
27012:  * that define truly lexical bindings. This means that a child of a TOK_VAR
27012:  * list may be a JSDefinition instead of a JSParseNode. The pn_defn bit is set
27012:  * for all JSDefinitions, clear otherwise.
27012:  *
27012:  * Note that not all var declarations are definitions: JS allows multiple var
27012:  * declarations in a function or script, but only the first creates the hoisted
27012:  * binding. JS programmers do redeclare variables for good refactoring reasons,
27012:  * for example:
27012:  *
27012:  *   function foo() {
27012:  *       ...
27012:  *       for (var i ...) ...;
27012:  *       ...
27012:  *       for (var i ...) ...;
27012:  *       ...
27012:  *   }
27012:  *
27012:  * Not all definitions bind lexical variables, alas. In global and eval code
27012:  * var may re-declare a pre-existing property having any attributes, with or
27012:  * without JSPROP_PERMANENT. In eval code, indeed, ECMA-262 Editions 1 through
27012:  * 3 require function and var to bind deletable bindings. Global vars thus are
27012:  * properties of the global object, so they can be aliased even if they can't
27012:  * be deleted.
27012:  *
27012:  * Only bindings within function code may be treated as lexical, of course with
27012:  * the caveat that hoisting means use before initialization is allowed. We deal
27012:  * with use before declaration in one pass as follows (error checking elided):
27012:  *
27012:  *   for (each use of unqualified name x in parse order) {
27012:  *       if (this use of x is a declaration) {
27012:  *           if (x in tc->decls) {                          // redeclaring
27012:  *               pn = allocate a PN_NAME JSParseNode;
27012:  *           } else {                                       // defining
27012:  *               dn = lookup x in tc->lexdeps;
27012:  *               if (dn) {                                  // use before def
27012:  *                   remove x from tc->lexdeps;
27012:  *               } else {                                   // def before use
27012:  *                   dn = allocate a PN_NAME JSDefinition;
27012:  *                   map x to dn via tc->decls;
27012:  *               }
27012:  *               pn = dn;
27012:  *           }
27012:  *           insert pn into its parent TOK_VAR list;
27012:  *       } else {
27012:  *           pn = allocate a JSParseNode for this reference to x;
27012:  *           dn = lookup x in tc's lexical scope chain;
27012:  *           if (!dn) {
27012:  *               dn = lookup x in tc->lexdeps;
27012:  *               if (!dn) {
27012:  *                   dn = pre-allocate a JSDefinition for x;
27012:  *                   map x to dn in tc->lexdeps;
27012:  *               }
27012:  *           }
27012:  *           append pn to dn's use chain;
27012:  *       }
27012:  *   }
27012:  *
27012:  * See jsemit.h for JSTreeContext and its top*Stmt, decls, and lexdeps members.
27012:  *
27012:  * Notes:
27012:  *
27012:  *  0. To avoid bloating JSParseNode, we steal a bit from pn_arity for pn_defn
27012:  *     and set it on a JSParseNode instead of allocating a JSDefinition.
27012:  *
27012:  *  1. Due to hoisting, a definition cannot be eliminated even if its "Variable
27012:  *     statement" (ECMA-262 12.2) can be proven to be dead code. RecycleTree in
27012:  *     jsparse.cpp will not recycle a node whose pn_defn bit is set.
27012:  *
27012:  *  2. "lookup x in tc's lexical scope chain" gives up on def/use chaining if a
27012:  *     with statement is found along the the scope chain, which includes tc,
27012:  *     tc->parent, etc. Thus we eagerly connect an inner function's use of an
27012:  *     outer's var x if the var x was parsed before the inner function.
27012:  *
27012:  *  3. A use may be eliminated as dead by the constant folder, which therefore
27012:  *     must remove the dead name node from its singly-linked use chain, which
27012:  *     would mean hashing to find the definition node and searching to update
27012:  *     the pn_link pointing at the use to be removed. This is costly, so as for
27012:  *     dead definitions, we do not recycle dead pn_used nodes.
27012:  *
27012:  * At the end of parsing a function body or global or eval program, tc->lexdeps
27012:  * holds the lexical dependencies of the parsed unit. The name to def/use chain
27012:  * mappings are then merged into the parent tc->lexdeps.
27012:  *
27012:  * Thus if a later var x is parsed in the outer function satisfying an earlier
27012:  * inner function's use of x, we will remove dn from tc->lexdeps and re-use it
27012:  * as the new definition node in the outer function's parse tree.
27012:  *
27012:  * When the compiler unwinds from the outermost tc, tc->lexdeps contains the
27012:  * definition nodes with use chains for all free variables. These are either
27012:  * global variables or reference errors.
27012:  *
27012:  * We analyze whether a binding is initialized, whether the bound names is ever
27012:  * assigned apart from its initializer, and if the bound name definition or use
27012:  * is in a direct child of a block. These PND_* flags allow a subset dominance
27012:  * computation telling whether an initialized var dominates its uses. An inner
27012:  * function using only such outer vars (and formal parameters) can be optimized
27012:  * into a flat closure. See JSOP_{GET,CALL}DSLOT.
27012:  *
27012:  * Another important subset dominance relation: ... { var x = ...; ... x ... }
27012:  * where x is not assigned after initialization and not used outside the block.
27012:  * This style is common in the absence of 'let'. Even though the var x is not
27012:  * at top level, we can tell its initialization dominates all uses cheaply,
27012:  * because the above one-pass algorithm sees the definition before any uses,
27012:  * and because all uses are contained in the same block as the definition.
27012:  *
27012:  * We also analyze function uses to flag upward/downward funargs, optimizing
27012:  * Algol-like (not passed as funargs, only ever called) lightweight functions
27012:  * using cx->display. See JSOP_{GET,CALL}UPVAR.
27012:  *
27012:  * This means that closure optimizations may be frustrated by with, eval, or
27012:  * assignment to an outer var. Such hard cases require heavyweight functions
27012:  * and JSOP_NAME, etc.
    1:  */
27012: #define dn_uses         pn_link
    1: 
27012: struct JSDefinition : public JSParseNode
27012: {
27012:     /*
27012:      * We store definition pointers in PN_NAMESET JSAtomLists in the AST, but
27012:      * due to redefinition these nodes may become uses of other definitions.
27012:      * This is unusual, so we simply chase the pn_lexdef link to find the final
27012:      * definition node. See methods called from JSCompiler::analyzeFunctions.
27012:      *
27012:      * FIXME: MakeAssignment mutates for want of a parent link...
27012:      */
27012:     JSDefinition *resolve() {
27012:         JSParseNode *pn = this;
27012:         while (!pn->pn_defn) {
27012:             if (pn->pn_type == TOK_ASSIGN) {
27012:                 pn = pn->pn_left;
27012:                 continue;
27012:             }
27012:             pn = pn->lexdef();
27012:         }
27012:         return (JSDefinition *) pn;
27012:     }
    1: 
27012:     bool test(uintN flag) const {
27012:         JS_ASSERT(pn_defn);
27012:         if (pn_dflags & flag)
27012:             return true;
27012: #ifdef DEBUG
27012:         for (JSParseNode *pn = dn_uses; pn; pn = pn->pn_link) {
27012:             JS_ASSERT(!pn->pn_defn);
27012:             JS_ASSERT(!(pn->pn_dflags & flag));
27012:         }
27012: #endif
27012:         return false;
27012:     }
    1: 
27012:     bool isAssigned() const {
27012:         return test(PND_ASSIGNED);
27012:     }
26970: 
27012:     bool isFunArg() const {
27012:         return test(PND_FUNARG);
27012:     }
27012: 
27012:     bool isFreeVar() const {
27012:         JS_ASSERT(pn_defn);
27012:         return pn_cookie == FREE_UPVAR_COOKIE || test(PND_GVAR);
27012:     }
27012: 
27012:     // Grr, windows.h or something under it #defines CONST...
27012: #ifdef CONST
27012: # undef CONST
27012: #endif
27012:     enum Kind { VAR, CONST, LET, FUNCTION, ARG, UNKNOWN };
27012: 
27012:     bool isBindingForm() { return int(kind()) <= int(LET); }
27012: 
27012:     static const char *kindString(Kind kind);
27012: 
27012:     Kind kind() {
27012:         if (PN_TYPE(this) == TOK_FUNCTION)
27012:             return FUNCTION;
27012:         JS_ASSERT(PN_TYPE(this) == TOK_NAME);
27012:         if (PN_OP(this) == JSOP_NOP)
27012:             return UNKNOWN;
27012:         if (PN_OP(this) == JSOP_GETARG)
27012:             return ARG;
27012:         if (isConst())
27012:             return CONST;
27012:         if (isLet())
27012:             return LET;
27012:         return VAR;
27012:     }
27012: };
27012: 
27012: /*
27012:  * These two are overridden by JSDefinition and we cannot afford virtual
27012:  * methods -- so we use the mighty 'if' statement!
27012:  */
27012: inline bool
27012: JSParseNode::isAssigned() const
27012: {
27012: #ifdef DEBUG
27012:     if (pn_defn)
27012:         return ((JSDefinition *)this)->isAssigned();
27012: #endif
27012:     return test(PND_ASSIGNED);
27012: }
27012: 
27012: inline bool
27012: JSParseNode::isFunArg() const
27012: {
27012: #ifdef DEBUG
27012:     if (pn_defn)
27012:         return ((JSDefinition *)this)->isFunArg();
27012: #endif
27012:     return test(PND_FUNARG);
27012: }
27012: 
27111: inline void
27111: JSParseNode::setFunArg()
27111: {
27111:     if (pn_defn) {
27111:         ((JSDefinition *)this)->pn_dflags |= PND_FUNARG;
27111:     } else if (pn_used) {
27111:         pn_lexdef->pn_dflags |= PND_FUNARG;
27111:         pn_dflags |= PND_FUNARG;
27111:     }
27111: }
27111: 
27012: struct JSObjectBox {
27012:     JSObjectBox         *traceLink;
27012:     JSObjectBox         *emitLink;
26970:     JSObject            *object;
26970: };
26970: 
27012: struct JSFunctionBox : public JSObjectBox
27012: {
27012:     JSParseNode         *node;
27012:     JSFunctionBox       *siblings;
27012:     JSFunctionBox       *kids;
27012:     JSFunctionBox       *parent;
27012:     uint32              queued:1,
27012:                         level:15,
27012:                         tcflags:16;
27012: };
27012: 
27012: struct JSFunctionBoxQueue {
27012:     JSFunctionBox       **vector;
27012:     size_t              head, tail;
27012:     size_t              lengthMask;
27012: 
27012:     size_t count()  { return head - tail; }
27012:     size_t length() { return lengthMask + 1; }
27012: 
27012:     JSFunctionBoxQueue()
27012:       : vector(NULL), head(0), tail(0), lengthMask(0) { }
27012: 
27012:     bool init(uint32 count) {
27012:         lengthMask = JS_BITMASK(JS_CeilingLog2(count));
27012:         vector = new JSFunctionBox*[length()];
27012:         return !!vector;
27012:     }
27012: 
27012:     ~JSFunctionBoxQueue() { delete[] vector; }
27012: 
27012:     void push(JSFunctionBox *funbox) {
27012:         if (!funbox->queued) {
27012:             JS_ASSERT(count() < length());
27012:             vector[head++ & lengthMask] = funbox;
27012:             funbox->queued = true;
27012:         }
27012:     }
27012: 
27012:     JSFunctionBox *pull() {
27012:         if (tail == head)
27012:             return NULL;
27012:         JS_ASSERT(tail != head);
27012:         JSFunctionBox *funbox = vector[tail++ & lengthMask];
27012:         funbox->queued = false;
27012:         return funbox;
27012:     }
27012: };
27012: 
27012: #define NUM_TEMP_FREELISTS      6U      /* 32 to 2048 byte size classes (32 bit) */
27012: 
27012: struct JSCompiler {
27012:     JSContext           *context;
27012:     JSAtomListElement   *aleFreeList;
27012:     void                *tempFreeList[NUM_TEMP_FREELISTS];
26970:     JSTokenStream       tokenStream;
26970:     void                *tempPoolMark;  /* initial JSContext.tempPool mark */
26970:     JSPrincipals        *principals;    /* principals associated with source */
27012:     JSStackFrame        *callerFrame;   /* scripted caller frame for eval and dbgapi */
27012:     JSParseNode         *nodeList;      /* list of recyclable parse-node structs */
27012:     uint32              functionCount;  /* number of functions in current unit */
27012:     JSObjectBox         *traceListHead; /* list of parsed object for GC tracing */
26970:     JSTempValueRooter   tempRoot;       /* root to trace traceListHead */
27012: 
27012:     JSCompiler(JSContext *cx, JSPrincipals *prin = NULL, JSStackFrame *cfp = NULL)
27012:       : context(cx), aleFreeList(NULL), principals(NULL), callerFrame(cfp),
27012:         nodeList(NULL), functionCount(0), traceListHead(NULL)
27012:     {
27012:         memset(tempFreeList, 0, sizeof tempFreeList);
27012:         setPrincipals(prin);
27012:         JS_ASSERT_IF(cfp, cfp->script);
27012:     }
27012: 
27012:     ~JSCompiler();
 3164: 
    1:     /*
27012:      * Initialize a compiler. Parameters are passed on to js_InitTokenStream.
27012:      * The compiler owns the arena pool "tops-of-stack" space above the current
27012:      * JSContext.tempPool mark. This means you cannot allocate from tempPool
27012:      * and save the pointer beyond the next JSCompiler destructor invocation.
    1:      */
27012:     bool init(const jschar *base, size_t length,
27012:               FILE *fp, const char *filename, uintN lineno);
27012: 
27012:     void setPrincipals(JSPrincipals *prin);
 6561: 
 6561:     /*
    1:      * Parse a top-level JS script.
    1:      */
27012:     JSParseNode *parse(JSObject *chain);
    1: 
27012: #if JS_HAS_XML_SUPPORT
27012:     JSParseNode *parseXMLText(JSObject *chain, bool allowList);
27012: #endif
27012: 
27012:     /*
27012:      * Allocate a new parsed object or function container from cx->tempPool.
27012:      */
27012:     JSObjectBox *newObjectBox(JSObject *obj);
27012: 
27012:     JSFunctionBox *newFunctionBox(JSObject *obj, JSParseNode *fn, JSTreeContext *tc);
27012: 
27012:     /*
27012:      * Create a new function object given tree context (tc), optional name
27012:      * (atom may be null) and lambda flag (JSFUN_LAMBDA or 0).
27012:      */
27012:     JSFunction *newFunction(JSTreeContext *tc, JSAtom *atom, uintN lambda);
27012: 
27012:     /*
27012:      * Analyze the tree of functions nested within a single compilation unit,
27012:      * starting at funbox, recursively walking its kids, then following its
27012:      * siblings, their kids, etc.
27012:      */
27012:     bool analyzeFunctions(JSFunctionBox *funbox, uint16& tcflags);
27012:     bool markFunArgs(JSFunctionBox *funbox, uintN tcflags);
27012:     void setFunctionKinds(JSFunctionBox *funbox, uint16& tcflags);
27012: 
27012:     void trace(JSTracer *trc);
27012: 
27012:     static bool
27012:     compileFunctionBody(JSContext *cx, JSFunction *fun, JSPrincipals *principals,
27012:                         const jschar *chars, size_t length,
27012:                         const char *filename, uintN lineno);
27012: 
27012:     static JSScript *
27012:     compileScript(JSContext *cx, JSObject *scopeChain, JSStackFrame *callerFrame,
18955:                   JSPrincipals *principals, uint32 tcflags,
18955:                   const jschar *chars, size_t length,
24375:                   FILE *file, const char *filename, uintN lineno,
24375:                   JSString *source = NULL);
27012: };
    1: 
27012: /*
27012:  * Convenience macro to access JSCompiler.tokenStream as a pointer.
27012:  */
27012: #define TS(jsc) (&(jsc)->tokenStream)
    1: 
    1: extern JSBool
20902: js_FoldConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc,
20902:                  bool inCond = false);
    1: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jsparse_h___ */
