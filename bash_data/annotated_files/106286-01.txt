     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "PlaceholderTxn.h"
     1: #include "nsEditor.h"
     1: #include "IMETextTxn.h"
 13021: #include "nsGkAtoms.h"
106286: #include "mozilla/Selection.h"
106286: 
106286: using namespace mozilla;
     1: 
     1: PlaceholderTxn::PlaceholderTxn() :  EditAggregateTxn(), 
 80486:                                     mAbsorb(true), 
     1:                                     mForwarding(nsnull),
     1:                                     mIMETextTxn(nsnull),
 80486:                                     mCommitted(false),
     1:                                     mStartSel(nsnull),
     1:                                     mEndSel(),
     1:                                     mEditor(nsnull)
     1: {
     1: }
     1: 
 28154: NS_IMPL_CYCLE_COLLECTION_CLASS(PlaceholderTxn)
     1: 
 28154: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(PlaceholderTxn,
 28154:                                                 EditAggregateTxn)
 28154:   tmp->mStartSel->DoUnlink();
 28154:   tmp->mEndSel.DoUnlink();
 28154: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 28154: 
 28154: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(PlaceholderTxn,
 28154:                                                   EditAggregateTxn)
 28154:   tmp->mStartSel->DoTraverse(cb);
 28154:   tmp->mEndSel.DoTraverse(cb);
 28154: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 28154: 
 28154: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(PlaceholderTxn)
 28154:   NS_INTERFACE_MAP_ENTRY(nsIAbsorbingTransaction)
 28154:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 28154: NS_INTERFACE_MAP_END_INHERITING(EditAggregateTxn)
 28154: 
 28154: NS_IMPL_ADDREF_INHERITED(PlaceholderTxn, EditAggregateTxn)
 28154: NS_IMPL_RELEASE_INHERITED(PlaceholderTxn, EditAggregateTxn)
     1: 
106286: NS_IMETHODIMP
106286: PlaceholderTxn::Init(nsIAtom* aName, nsSelectionState* aSelState,
106286:                      nsEditor* aEditor)
     1: {
 43806:   NS_ENSURE_TRUE(aEditor && aSelState, NS_ERROR_NULL_POINTER);
     1: 
     1:   mName = aName;
     1:   mStartSel = aSelState;
     1:   mEditor = aEditor;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP PlaceholderTxn::DoTransaction(void)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP PlaceholderTxn::UndoTransaction(void)
     1: {
     1:   // undo txns
     1:   nsresult res = EditAggregateTxn::UndoTransaction();
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
 43806:   NS_ENSURE_TRUE(mStartSel, NS_ERROR_NULL_POINTER);
     1: 
     1:   // now restore selection
     1:   nsCOMPtr<nsISelection> selection;
     1:   res = mEditor->GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1:   return mStartSel->RestoreSelection(selection);
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP PlaceholderTxn::RedoTransaction(void)
     1: {
     1:   // redo txns
     1:   nsresult res = EditAggregateTxn::RedoTransaction();
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   // now restore selection
     1:   nsCOMPtr<nsISelection> selection;
     1:   res = mEditor->GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1:   return mEndSel.RestoreSelection(selection);
     1: }
     1: 
     1: 
 79445: NS_IMETHODIMP PlaceholderTxn::Merge(nsITransaction *aTransaction, bool *aDidMerge)
     1: {
 43806:   NS_ENSURE_TRUE(aDidMerge && aTransaction, NS_ERROR_NULL_POINTER);
     1: 
     1:   // set out param default value
 80486:   *aDidMerge=false;
     1:     
     1:   if (mForwarding) 
     1:   {
     1:     NS_NOTREACHED("tried to merge into a placeholder that was in forwarding mode!");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   // check to see if aTransaction is one of the editor's
     1:   // private transactions. If not, we want to avoid merging
     1:   // the foreign transaction into our placeholder since we
     1:   // don't know what it does.
     1: 
     1:   nsCOMPtr<nsPIEditorTransaction> pTxn = do_QueryInterface(aTransaction);
 43806:   NS_ENSURE_TRUE(pTxn, NS_OK); // it's foreign so just bail!
     1: 
     1:   EditTxn *editTxn = (EditTxn*)aTransaction;  //XXX: hack, not safe!  need nsIEditTransaction!
     1:   // determine if this incoming txn is a placeholder txn
     1:   nsCOMPtr<nsIAbsorbingTransaction> plcTxn;// = do_QueryInterface(editTxn);
     1:   // can't do_QueryInterface() above due to our broken transaction interfaces.
     1:   // instead have to brute it below. ugh. 
     1:   editTxn->QueryInterface(NS_GET_IID(nsIAbsorbingTransaction), getter_AddRefs(plcTxn));
     1: 
     1:   // we are absorbing all txn's if mAbsorb is lit.
     1:   if (mAbsorb)
     1:   { 
  3030:     nsRefPtr<IMETextTxn> otherTxn;
  3030:     if (NS_SUCCEEDED(aTransaction->QueryInterface(IMETextTxn::GetCID(), getter_AddRefs(otherTxn))) && otherTxn)
     1:     {
     1:       // special handling for IMETextTxn's: they need to merge with any previous
     1:       // IMETextTxn in this placeholder, if possible.
     1:       if (!mIMETextTxn) 
     1:       {
     1:         // this is the first IME txn in the placeholder
     1:         mIMETextTxn =otherTxn;
     1:         AppendChild(editTxn);
     1:       }
     1:       else  
     1:       {
 79445:         bool didMerge;
     1:         mIMETextTxn->Merge(otherTxn, &didMerge);
     1:         if (!didMerge)
     1:         {
  7793:           // it wouldn't merge.  Earlier IME txn is already committed and will
     1:           // not absorb further IME txns.  So just stack this one after it
     1:           // and remember it as a candidate for further merges.
     1:           mIMETextTxn =otherTxn;
     1:           AppendChild(editTxn);
     1:         }
     1:       }
     1:     }
     1:     else if (!plcTxn)  // see bug 171243: just drop incoming placeholders on the floor.
     1:     {                  // their children will be swallowed by this preexisting one.
     1:       AppendChild(editTxn);
     1:     }
 80486:     *aDidMerge = true;
     1: //  RememberEndingSelection();
     1: //  efficiency hack: no need to remember selection here, as we haven't yet 
  7799: //  finished the initial batch and we know we will be told when the batch ends.
     1: //  we can remeber the selection then.
     1:   }
     1:   else
     1:   { // merge typing or IME or deletion transactions if the selection matches
 13021:     if (((mName.get() == nsGkAtoms::TypingTxnName) ||
 13021:          (mName.get() == nsGkAtoms::IMETxnName)    ||
 13021:          (mName.get() == nsGkAtoms::DeleteTxnName)) 
     1:          && !mCommitted ) 
     1:     {
     1:       nsCOMPtr<nsIAbsorbingTransaction> plcTxn;// = do_QueryInterface(editTxn);
     1:       // can't do_QueryInterface() above due to our broken transaction interfaces.
     1:       // instead have to brute it below. ugh. 
     1:       editTxn->QueryInterface(NS_GET_IID(nsIAbsorbingTransaction), getter_AddRefs(plcTxn));
     1:       if (plcTxn)
     1:       {
     1:         nsCOMPtr<nsIAtom> atom;
     1:         plcTxn->GetTxnName(getter_AddRefs(atom));
     1:         if (atom && (atom == mName))
     1:         {
     1:           // check if start selection of next placeholder matches
     1:           // end selection of this placeholder
 79445:           bool isSame;
     1:           plcTxn->StartSelectionEquals(&mEndSel, &isSame);
     1:           if (isSame)
     1:           {
 80486:             mAbsorb = true;  // we need to start absorbing again
     1:             plcTxn->ForwardEndBatchTo(this);
     1:             // AppendChild(editTxn);
     1:             // see bug 171243: we don't need to merge placeholders
     1:             // into placeholders.  We just reactivate merging in the pre-existing
     1:             // placeholder and drop the new one on the floor.  The EndPlaceHolderBatch()
     1:             // call on the new placeholder will be forwarded to this older one.
     1:             RememberEndingSelection();
 80486:             *aDidMerge = true;
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP PlaceholderTxn::GetTxnDescription(nsAString& aString)
     1: {
     1:   aString.AssignLiteral("PlaceholderTxn: ");
     1: 
     1:   if (mName)
     1:   {
     1:     nsAutoString name;
     1:     mName->ToString(name);
     1:     aString += name;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP PlaceholderTxn::GetTxnName(nsIAtom **aName)
     1: {
     1:   return GetName(aName);
     1: }
     1: 
 79445: NS_IMETHODIMP PlaceholderTxn::StartSelectionEquals(nsSelectionState *aSelState, bool *aResult)
     1: {
     1:   // determine if starting selection matches the given selection state.
     1:   // note that we only care about collapsed selections.
 43806:   NS_ENSURE_TRUE(aResult && aSelState, NS_ERROR_NULL_POINTER);
     1:   if (!mStartSel->IsCollapsed() || !aSelState->IsCollapsed())
     1:   {
 80486:     *aResult = false;
     1:     return NS_OK;
     1:   }
     1:   *aResult = mStartSel->IsEqual(aSelState);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP PlaceholderTxn::EndPlaceHolderBatch()
     1: {
 80486:   mAbsorb = false;
     1:   
     1:   if (mForwarding) 
     1:   {
     1:     nsCOMPtr<nsIAbsorbingTransaction> plcTxn = do_QueryReferent(mForwarding);
     1:     if (plcTxn) plcTxn->EndPlaceHolderBatch();
     1:   }
     1:   
     1:   // remember our selection state.
     1:   return RememberEndingSelection();
     1: }
     1: 
     1: NS_IMETHODIMP PlaceholderTxn::ForwardEndBatchTo(nsIAbsorbingTransaction *aForwardingAddress)
     1: {   
     1:   mForwarding = do_GetWeakReference(aForwardingAddress);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP PlaceholderTxn::Commit()
     1: {
 80486:   mCommitted = true;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP PlaceholderTxn::RememberEndingSelection()
     1: {
106286:   nsRefPtr<Selection> selection = mEditor->GetSelection();
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
106286:   mEndSel.SaveSelection(selection);
106286:   return NS_OK;
     1: }
     1: 
