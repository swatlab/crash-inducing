    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:tabstop=2:expandtab:shiftwidth=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   L. David Baron <dbaron@dbaron.org>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* representation of a CSS style sheet */
    1: 
    1: #include "nsCSSStyleSheet.h"
    1: 
    1: #include "nsCRT.h"
    1: #include "nsIAtom.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsCSSRuleProcessor.h"
    1: #include "nsICSSStyleRule.h"
    1: #include "nsICSSNameSpaceRule.h"
    1: #include "nsICSSGroupRule.h"
    1: #include "nsICSSImportRule.h"
    1: #include "nsIMediaList.h"
    1: #include "nsIDocument.h"
    1: #include "nsPresContext.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsString.h"
24551: #include "nsTArray.h"
    1: #include "nsIDOMStyleSheetList.h"
    1: #include "nsIDOMCSSStyleSheet.h"
    1: #include "nsIDOMCSSRule.h"
    1: #include "nsIDOMCSSImportRule.h"
20752: #include "nsICSSRuleList.h"
    1: #include "nsIDOMMediaList.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsDOMError.h"
    1: #include "nsICSSParser.h"
    1: #include "nsICSSLoader.h"
    1: #include "nsICSSLoaderObserver.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsXMLNameSpaceMap.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIScriptSecurityManager.h"
14228: #include "mozAutoDocUpdate.h"
16222: #include "nsCSSDeclaration.h"
16222: #include "nsRuleNode.h"
    1: 
    1: // -------------------------------
    1: // Style Rule List for the DOM
    1: //
20752: class CSSRuleListImpl : public nsICSSRuleList
    1: {
    1: public:
    1:   CSSRuleListImpl(nsCSSStyleSheet *aStyleSheet);
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIDOMCSSRuleList interface
    1:   NS_IMETHOD    GetLength(PRUint32* aLength); 
    1:   NS_IMETHOD    Item(PRUint32 aIndex, nsIDOMCSSRule** aReturn); 
    1: 
20752:   virtual nsIDOMCSSRule* GetItemAt(PRUint32 aIndex, nsresult* aResult);
20752: 
    1:   void DropReference() { mStyleSheet = nsnull; }
    1: 
    1: protected:
    1:   virtual ~CSSRuleListImpl();
    1: 
    1:   nsCSSStyleSheet*  mStyleSheet;
    1: public:
    1:   PRBool              mRulesAccessed;
    1: };
    1: 
    1: CSSRuleListImpl::CSSRuleListImpl(nsCSSStyleSheet *aStyleSheet)
    1: {
    1:   // Not reference counted to avoid circular references.
    1:   // The style sheet will tell us when its going away.
    1:   mStyleSheet = aStyleSheet;
    1:   mRulesAccessed = PR_FALSE;
    1: }
    1: 
    1: CSSRuleListImpl::~CSSRuleListImpl()
    1: {
    1: }
    1: 
    1: // QueryInterface implementation for CSSRuleList
    1: NS_INTERFACE_MAP_BEGIN(CSSRuleListImpl)
20752:   NS_INTERFACE_MAP_ENTRY(nsICSSRuleList)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRuleList)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
    1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(CSSRuleList)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(CSSRuleListImpl)
    1: NS_IMPL_RELEASE(CSSRuleListImpl)
    1: 
    1: 
    1: NS_IMETHODIMP    
    1: CSSRuleListImpl::GetLength(PRUint32* aLength)
    1: {
    1:   if (nsnull != mStyleSheet) {
    1:     PRInt32 count;
    1:     mStyleSheet->StyleRuleCount(count);
    1:     *aLength = (PRUint32)count;
    1:   }
    1:   else {
    1:     *aLength = 0;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
20752: nsIDOMCSSRule*    
20752: CSSRuleListImpl::GetItemAt(PRUint32 aIndex, nsresult* aResult)
    1: {
    1:   nsresult result = NS_OK;
    1: 
    1:   if (mStyleSheet) {
36783:     // ensure rules have correct parent
36783:     if (mStyleSheet->EnsureUniqueInner() !=
36783:           nsCSSStyleSheet::eUniqueInner_CloneFailed) {
    1:       nsCOMPtr<nsICSSRule> rule;
    1: 
    1:       result = mStyleSheet->GetStyleRuleAt(aIndex, *getter_AddRefs(rule));
    1:       if (rule) {
    1:         mRulesAccessed = PR_TRUE; // signal to never share rules again
20752:         return rule->GetDOMRuleWeak(aResult);
20752:       }
20752:       if (result == NS_ERROR_ILLEGAL_VALUE) {
    1:         result = NS_OK; // per spec: "Return Value ... null if ... not a valid index."
    1:       }
    1:     }
    1:   }
    1: 
20752:   *aResult = result;
20752:   return nsnull;
20752: }
20752: 
20752: NS_IMETHODIMP    
20752: CSSRuleListImpl::Item(PRUint32 aIndex, nsIDOMCSSRule** aReturn)
20752: {
20752:   nsresult rv;
20752:   nsIDOMCSSRule* rule = GetItemAt(aIndex, &rv);
20752:   if (!rule) {
20752:     *aReturn = nsnull;
20752: 
20752:     return rv;
20752:   }
20752: 
20752:   return CallQueryInterface(rule, aReturn);
    1: }
    1: 
16222: template <class Numeric>
16222: PRInt32 DoCompare(Numeric a, Numeric b)
16222: {
16222:   if (a == b)
16222:     return 0;
16222:   if (a < b)
16222:     return -1;
16222:   return 1;
16222: }
16222: 
16222: PRBool
16222: nsMediaExpression::Matches(nsPresContext *aPresContext,
16222:                            const nsCSSValue& aActualValue) const
16222: {
16222:   const nsCSSValue& actual = aActualValue;
16222:   const nsCSSValue& required = mValue;
16222: 
16222:   // If we don't have the feature, the match fails.
16222:   if (actual.GetUnit() == eCSSUnit_Null) {
16222:     return PR_FALSE;
16222:   }
16222: 
16222:   // If the expression had no value to match, the match succeeds,
18892:   // unless the value is an integer 0 or a zero length.
16222:   if (required.GetUnit() == eCSSUnit_Null) {
18892:     if (actual.GetUnit() == eCSSUnit_Integer)
18892:       return actual.GetIntValue() != 0;
18892:     if (actual.IsLengthUnit())
18892:       return actual.GetFloatValue() != 0;
18892:     return PR_TRUE;
16222:   }
16222: 
16222:   NS_ASSERTION(mFeature->mRangeType == nsMediaFeature::eMinMaxAllowed ||
16222:                mRange == nsMediaExpression::eEqual, "yikes");
16222:   PRInt32 cmp; // -1 (actual < required)
16222:                //  0 (actual == required)
16222:                //  1 (actual > required)
16222:   switch (mFeature->mValueType) {
16222:     case nsMediaFeature::eLength:
16222:       {
16222:         NS_ASSERTION(actual.IsLengthUnit(), "bad actual value");
16222:         NS_ASSERTION(required.IsLengthUnit(), "bad required value");
16222:         nscoord actualCoord = nsRuleNode::CalcLengthWithInitialFont(
16222:                                 aPresContext, actual);
16222:         nscoord requiredCoord = nsRuleNode::CalcLengthWithInitialFont(
16222:                                   aPresContext, required);
16222:         cmp = DoCompare(actualCoord, requiredCoord);
16222:       }
16222:       break;
16222:     case nsMediaFeature::eInteger:
18890:     case nsMediaFeature::eBoolInteger:
16222:       {
16222:         NS_ASSERTION(actual.GetUnit() == eCSSUnit_Integer,
16222:                      "bad actual value");
16222:         NS_ASSERTION(required.GetUnit() == eCSSUnit_Integer,
16222:                      "bad required value");
18890:         NS_ASSERTION(mFeature->mValueType != nsMediaFeature::eBoolInteger ||
18890:                      actual.GetIntValue() == 0 || actual.GetIntValue() == 1,
18890:                      "bad actual bool integer value");
18890:         NS_ASSERTION(mFeature->mValueType != nsMediaFeature::eBoolInteger ||
18890:                      required.GetIntValue() == 0 || required.GetIntValue() == 1,
18890:                      "bad required bool integer value");
16222:         cmp = DoCompare(actual.GetIntValue(), required.GetIntValue());
16222:       }
16222:       break;
16222:     case nsMediaFeature::eIntRatio:
16222:       {
16222:         NS_ASSERTION(actual.GetUnit() == eCSSUnit_Array &&
16222:                      actual.GetArrayValue()->Count() == 2 &&
16222:                      actual.GetArrayValue()->Item(0).GetUnit() ==
16222:                        eCSSUnit_Integer &&
16222:                      actual.GetArrayValue()->Item(1).GetUnit() ==
16222:                        eCSSUnit_Integer,
16222:                      "bad actual value");
16222:         NS_ASSERTION(required.GetUnit() == eCSSUnit_Array &&
16222:                      required.GetArrayValue()->Count() == 2 &&
16222:                      required.GetArrayValue()->Item(0).GetUnit() ==
16222:                        eCSSUnit_Integer &&
16222:                      required.GetArrayValue()->Item(1).GetUnit() ==
16222:                        eCSSUnit_Integer,
16222:                      "bad required value");
16222:         // Convert to PRInt64 so we can multiply without worry.  Note
16222:         // that while the spec requires that both halves of |required|
16222:         // be positive, the numerator or denominator of |actual| might
16222:         // be zero (e.g., when testing 'aspect-ratio' on a 0-width or
16222:         // 0-height iframe).
16222:         PRInt64 actualNum = actual.GetArrayValue()->Item(0).GetIntValue(),
16222:                 actualDen = actual.GetArrayValue()->Item(1).GetIntValue(),
16222:                 requiredNum = required.GetArrayValue()->Item(0).GetIntValue(),
16222:                 requiredDen = required.GetArrayValue()->Item(1).GetIntValue();
16222:         cmp = DoCompare(actualNum * requiredDen, requiredNum * actualDen);
16222:       }
16222:       break;
16222:     case nsMediaFeature::eResolution:
16222:       {
16222:         NS_ASSERTION(actual.GetUnit() == eCSSUnit_Inch ||
16222:                      actual.GetUnit() == eCSSUnit_Centimeter,
16222:                      "bad actual value");
16222:         NS_ASSERTION(required.GetUnit() == eCSSUnit_Inch ||
16222:                      required.GetUnit() == eCSSUnit_Centimeter,
16222:                      "bad required value");
16222:         float actualDPI = actual.GetFloatValue();
16222:         if (actual.GetUnit() == eCSSUnit_Centimeter)
16222:           actualDPI = actualDPI * 2.54f;
16222:         float requiredDPI = required.GetFloatValue();
16222:         if (required.GetUnit() == eCSSUnit_Centimeter)
16222:           requiredDPI = requiredDPI * 2.54f;
16222:         cmp = DoCompare(actualDPI, requiredDPI);
16222:       }
16222:       break;
16222:     case nsMediaFeature::eEnumerated:
16222:       {
16222:         NS_ASSERTION(actual.GetUnit() == eCSSUnit_Enumerated,
16222:                      "bad actual value");
16222:         NS_ASSERTION(required.GetUnit() == eCSSUnit_Enumerated,
16222:                      "bad required value");
16222:         NS_ASSERTION(mFeature->mRangeType == nsMediaFeature::eMinMaxNotAllowed,
16222:                      "bad range"); // we asserted above about mRange
16222:         // We don't really need DoCompare, but it doesn't hurt (and
16222:         // maybe the compiler will condense this case with eInteger).
16222:         cmp = DoCompare(actual.GetIntValue(), required.GetIntValue());
16222:       }
16222:       break;
16222:   }
16222:   switch (mRange) {
16222:     case nsMediaExpression::eMin:
16222:       return cmp != -1;
16222:     case nsMediaExpression::eMax:
16222:       return cmp != 1;
16222:     case nsMediaExpression::eEqual:
16222:       return cmp == 0;
16222:   }
16222:   NS_NOTREACHED("unexpected mRange");
16222:   return PR_FALSE;
16222: }
16222: 
16222: void
16223: nsMediaQueryResultCacheKey::AddExpression(const nsMediaExpression* aExpression,
16223:                                           PRBool aExpressionMatches)
16223: {
16223:   const nsMediaFeature *feature = aExpression->mFeature;
16223:   FeatureEntry *entry = nsnull;
16223:   for (PRUint32 i = 0; i < mFeatureCache.Length(); ++i) {
16223:     if (mFeatureCache[i].mFeature == feature) {
16223:       entry = &mFeatureCache[i];
16223:       break;
16223:     }
16223:   }
16223:   if (!entry) {
16223:     entry = mFeatureCache.AppendElement();
16223:     if (!entry) {
16223:       return; /* out of memory */
16223:     }
16223:     entry->mFeature = feature;
16223:   }
16223: 
16223:   ExpressionEntry eentry = { *aExpression, aExpressionMatches };
16223:   entry->mExpressions.AppendElement(eentry);
16223: }
16223: 
16223: PRBool
16223: nsMediaQueryResultCacheKey::Matches(nsPresContext* aPresContext) const
16223: {
16223:   if (aPresContext->Medium() != mMedium) {
16223:     return PR_FALSE;
16223:   }
16223: 
16223:   for (PRUint32 i = 0; i < mFeatureCache.Length(); ++i) {
16223:     const FeatureEntry *entry = &mFeatureCache[i];
16223:     nsCSSValue actual;
33893:     nsresult rv =
33893:       (entry->mFeature->mGetter)(aPresContext, entry->mFeature, actual);
16223:     NS_ENSURE_SUCCESS(rv, PR_FALSE); // any better ideas?
16223: 
16223:     for (PRUint32 j = 0; j < entry->mExpressions.Length(); ++j) {
16223:       const ExpressionEntry &eentry = entry->mExpressions[j];
16223:       if (eentry.mExpression.Matches(aPresContext, actual) !=
16223:           eentry.mExpressionMatches) {
16223:         return PR_FALSE;
16223:       }
16223:     }
16223:   }
16223: 
16223:   return PR_TRUE;
16223: }
16223: 
16223: void
16222: nsMediaQuery::AppendToString(nsAString& aString) const
16222: {
16222:   nsAutoString buffer;
16222: 
16222:   if (mHadUnknownExpression) {
16222:     aString.AppendLiteral("not all");
16222:     return;
16222:   }
16222: 
16222:   NS_ASSERTION(!mNegated || !mHasOnly, "can't have not and only");
16222:   NS_ASSERTION(!mTypeOmitted || (!mNegated && !mHasOnly),
16222:                "can't have not or only when type is omitted");
16222:   if (!mTypeOmitted) {
16222:     if (mNegated) {
16222:       aString.AppendLiteral("not ");
16222:     } else if (mHasOnly) {
16222:       aString.AppendLiteral("only ");
16222:     }
16222:     mMediaType->ToString(buffer);
16222:     aString.Append(buffer);
16222:     buffer.Truncate();
16222:   }
16222: 
16222:   for (PRUint32 i = 0, i_end = mExpressions.Length(); i < i_end; ++i) {
16222:     if (i > 0 || !mTypeOmitted)
16222:       aString.AppendLiteral(" and ");
16222:     aString.AppendLiteral("(");
16222: 
16222:     const nsMediaExpression &expr = mExpressions[i];
16222:     if (expr.mRange == nsMediaExpression::eMin) {
16222:       aString.AppendLiteral("min-");
16222:     } else if (expr.mRange == nsMediaExpression::eMax) {
16222:       aString.AppendLiteral("max-");
16222:     }
16222: 
16222:     const nsMediaFeature *feature = expr.mFeature;
16222:     (*feature->mName)->ToString(buffer);
16222:     aString.Append(buffer);
16222:     buffer.Truncate();
16222: 
16222:     if (expr.mValue.GetUnit() != eCSSUnit_Null) {
16222:       aString.AppendLiteral(": ");
16222:       switch (feature->mValueType) {
16222:         case nsMediaFeature::eLength:
16222:           NS_ASSERTION(expr.mValue.IsLengthUnit(), "bad unit");
16222:           // Use 'width' as a property that takes length values
16222:           // written in the normal way.
16222:           nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_width,
16222:                                                    expr.mValue, aString);
16222:           break;
16222:         case nsMediaFeature::eInteger:
18890:         case nsMediaFeature::eBoolInteger:
16222:           NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Integer,
16222:                        "bad unit");
16222:           // Use 'z-index' as a property that takes integer values
16222:           // written without anything extra.
16222:           nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
16222:                                                    expr.mValue, aString);
16222:           break;
16222:         case nsMediaFeature::eIntRatio:
16222:           {
16222:             NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Array,
16222:                          "bad unit");
16222:             nsCSSValue::Array *array = expr.mValue.GetArrayValue();
16222:             NS_ASSERTION(array->Count() == 2, "unexpected length");
16222:             NS_ASSERTION(array->Item(0).GetUnit() == eCSSUnit_Integer,
16222:                          "bad unit");
16222:             NS_ASSERTION(array->Item(1).GetUnit() == eCSSUnit_Integer,
16222:                          "bad unit");
16222:             nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
16222:                                                      array->Item(0), aString);
16222:             aString.AppendLiteral("/");
16222:             nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
16222:                                                      array->Item(1), aString);
16222:           }
16222:           break;
16222:         case nsMediaFeature::eResolution:
16222:           buffer.AppendFloat(expr.mValue.GetFloatValue());
16222:           aString.Append(buffer);
16222:           buffer.Truncate();
16222:           if (expr.mValue.GetUnit() == eCSSUnit_Inch) {
16222:             aString.AppendLiteral("dpi");
16222:           } else {
16222:             NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Centimeter,
16222:                          "bad unit");
16222:             aString.AppendLiteral("dpcm");
16222:           }
16222:           break;
16222:         case nsMediaFeature::eEnumerated:
16222:           NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Enumerated,
16222:                        "bad unit");
16222:           AppendASCIItoUTF16(
16222:               nsCSSProps::ValueToKeyword(expr.mValue.GetIntValue(),
33892:                                          feature->mData.mKeywordTable),
16222:               aString);
16222:           break;
16222:       }
16222:     }
16222: 
16222:     aString.AppendLiteral(")");
16222:   }
16222: }
16222: 
16222: nsMediaQuery*
16222: nsMediaQuery::Clone() const
16222: {
16222:   nsAutoPtr<nsMediaQuery> result(new nsMediaQuery(*this));
16222:   NS_ENSURE_TRUE(result &&
16222:                    result->mExpressions.Length() == mExpressions.Length(),
16222:                  nsnull);
16222:   return result.forget();
16222: }
16222: 
16222: PRBool
16223: nsMediaQuery::Matches(nsPresContext* aPresContext,
16223:                       nsMediaQueryResultCacheKey& aKey) const
16222: {
16222:   if (mHadUnknownExpression)
16222:     return PR_FALSE;
16222: 
16222:   PRBool match =
16222:     mMediaType == aPresContext->Medium() || mMediaType == nsGkAtoms::all;
16222:   for (PRUint32 i = 0, i_end = mExpressions.Length(); match && i < i_end; ++i) {
16222:     const nsMediaExpression &expr = mExpressions[i];
16222:     nsCSSValue actual;
33893:     nsresult rv =
33893:       (expr.mFeature->mGetter)(aPresContext, expr.mFeature, actual);
16222:     NS_ENSURE_SUCCESS(rv, PR_FALSE); // any better ideas?
16223: 
16222:     match = expr.Matches(aPresContext, actual);
16223:     aKey.AddExpression(&expr, match);
16222:   }
16222: 
16222:   return match == !mNegated;
16222: }
16222: 
    1: NS_INTERFACE_MAP_BEGIN(nsMediaList)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMMediaList)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
    1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(MediaList)
    1: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMPL_ADDREF(nsMediaList)
    1: NS_IMPL_RELEASE(nsMediaList)
    1: 
    1: 
    1: nsMediaList::nsMediaList()
16222:   : mIsEmpty(PR_TRUE)
16222:   , mStyleSheet(nsnull)
    1: {
    1: }
    1: 
    1: nsMediaList::~nsMediaList()
    1: {
    1: }
    1: 
    1: nsresult
    1: nsMediaList::GetText(nsAString& aMediaText)
    1: {
    1:   aMediaText.Truncate();
    1: 
16222:   if (mArray.Length() == 0 && !mIsEmpty) {
16222:     aMediaText.AppendLiteral("not all");
16222:   }
    1: 
16222:   for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
16222:     nsMediaQuery* query = mArray[i];
16222:     NS_ENSURE_TRUE(query, NS_ERROR_FAILURE);
16222: 
16222:     query->AppendToString(aMediaText);
16222: 
    1:     if (i + 1 < i_end) {
    1:       aMediaText.AppendLiteral(", ");
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // XXXbz this is so ill-defined in the spec, it's not clear quite what
    1: // it should be doing....
    1: nsresult
    1: nsMediaList::SetText(const nsAString& aMediaText)
    1: {
    1:   nsCOMPtr<nsICSSParser> parser;
    1:   nsresult rv = NS_NewCSSParser(getter_AddRefs(parser));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool htmlMode = PR_FALSE;
    1:   nsCOMPtr<nsIDOMStyleSheet> domSheet =
 3233:     do_QueryInterface(static_cast<nsICSSStyleSheet*>(mStyleSheet));
    1:   if (domSheet) {
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     domSheet->GetOwnerNode(getter_AddRefs(node));
    1:     htmlMode = !!node;
    1:   }
    1: 
    1:   return parser->ParseMediaList(nsString(aMediaText), nsnull, 0,
    1:                                 this, htmlMode);
    1: }
    1: 
    1: PRBool
16223: nsMediaList::Matches(nsPresContext* aPresContext,
16223:                      nsMediaQueryResultCacheKey& aKey)
    1: {
16222:   for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
16223:     if (mArray[i]->Matches(aPresContext, aKey)) {
    1:       return PR_TRUE;
16222:     }
16222:   }
16222:   return mIsEmpty;
    1: }
    1: 
    1: nsresult
    1: nsMediaList::SetStyleSheet(nsICSSStyleSheet *aSheet)
    1: {
    1:   NS_ASSERTION(aSheet == mStyleSheet || !aSheet || !mStyleSheet,
    1:                "multiple style sheets competing for one media list");
 3233:   mStyleSheet = static_cast<nsCSSStyleSheet*>(aSheet);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsMediaList::Clone(nsMediaList** aResult)
    1: {
    1:   nsRefPtr<nsMediaList> result = new nsMediaList();
16222:   if (!result || !result->mArray.AppendElements(mArray.Length()))
    1:     return NS_ERROR_OUT_OF_MEMORY;
16222:   for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
16222:     if (!(result->mArray[i] = mArray[i]->Clone())) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
16222:     }
16222:   }
30412:   result->mIsEmpty = mIsEmpty;
    1:   NS_ADDREF(*aResult = result);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMediaList::GetMediaText(nsAString& aMediaText)
    1: {
    1:   return GetText(aMediaText);
    1: }
    1: 
    1: // "sheet" should be an nsCSSStyleSheet and "doc" should be an
    1: // nsCOMPtr<nsIDocument>
    1: #define BEGIN_MEDIA_CHANGE(sheet, doc)                         \
    1:   if (sheet) {                                                 \
    1:     rv = sheet->GetOwningDocument(*getter_AddRefs(doc));       \
    1:     NS_ENSURE_SUCCESS(rv, rv);                                 \
    1:   }                                                            \
    1:   mozAutoDocUpdate updateBatch(doc, UPDATE_STYLE, PR_TRUE);    \
    1:   if (sheet) {                                                 \
    1:     rv = sheet->WillDirty();                                   \
    1:     NS_ENSURE_SUCCESS(rv, rv);                                 \
    1:   }
    1: 
    1: #define END_MEDIA_CHANGE(sheet, doc)                           \
    1:   if (sheet) {                                                 \
    1:     sheet->DidDirty();                                         \
    1:   }                                                            \
    1:   /* XXXldb Pass something meaningful? */                      \
    1:   if (doc) {                                                   \
    1:     doc->StyleRuleChanged(sheet, nsnull, nsnull);              \
    1:   }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsMediaList::SetMediaText(const nsAString& aMediaText)
    1: {
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsIDocument> doc;
    1: 
    1:   BEGIN_MEDIA_CHANGE(mStyleSheet, doc)
    1: 
    1:   rv = SetText(aMediaText);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   
    1:   END_MEDIA_CHANGE(mStyleSheet, doc)
    1: 
    1:   return rv;
    1: }
    1:                                
    1: NS_IMETHODIMP
    1: nsMediaList::GetLength(PRUint32* aLength)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aLength);
    1: 
16222:   *aLength = mArray.Length();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMediaList::Item(PRUint32 aIndex, nsAString& aReturn)
    1: {
    1:   PRInt32 index = aIndex;
    1:   if (0 <= index && index < Count()) {
16222:     nsMediaQuery* query = mArray[index];
16222:     NS_ENSURE_TRUE(query, NS_ERROR_FAILURE);
16222: 
16222:     aReturn.Truncate();
16222:     query->AppendToString(aReturn);
    1:   } else {
    1:     SetDOMStringToNull(aReturn);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMediaList::DeleteMedium(const nsAString& aOldMedium)
    1: {
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsIDocument> doc;
    1: 
    1:   BEGIN_MEDIA_CHANGE(mStyleSheet, doc)
    1:   
    1:   rv = Delete(aOldMedium);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   END_MEDIA_CHANGE(mStyleSheet, doc)
    1:   
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMediaList::AppendMedium(const nsAString& aNewMedium)
    1: {
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsIDocument> doc;
    1: 
    1:   BEGIN_MEDIA_CHANGE(mStyleSheet, doc)
    1:   
    1:   rv = Append(aNewMedium);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   END_MEDIA_CHANGE(mStyleSheet, doc)
    1:   
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsMediaList::Delete(const nsAString& aOldMedium)
    1: {
    1:   if (aOldMedium.IsEmpty())
    1:     return NS_ERROR_DOM_NOT_FOUND_ERR;
    1: 
16222:   for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
16222:     nsMediaQuery* query = mArray[i];
16222:     NS_ENSURE_TRUE(query, NS_ERROR_FAILURE);
    1: 
16222:     nsAutoString buf;
16222:     query->AppendToString(buf);
16222:     if (buf == aOldMedium) {
16222:       mArray.RemoveElementAt(i);
16222:       return NS_OK;
16222:     }
    1:   }
    1: 
16222:   return NS_ERROR_DOM_NOT_FOUND_ERR;
    1: }
    1: 
    1: nsresult
    1: nsMediaList::Append(const nsAString& aNewMedium)
    1: {
    1:   if (aNewMedium.IsEmpty())
    1:     return NS_ERROR_DOM_NOT_FOUND_ERR;
    1: 
16222:   Delete(aNewMedium);
    1: 
16222:   nsresult rv = NS_OK;
16222:   nsTArray<nsAutoPtr<nsMediaQuery> > buf;
16222: #ifdef DEBUG
16222:   PRBool ok = 
16222: #endif
16222:     mArray.SwapElements(buf);
16222:   NS_ASSERTION(ok, "SwapElements should never fail when neither array "
16222:                    "is an auto array");
16222:   SetText(aNewMedium);
16222:   if (mArray.Length() == 1) {
16222:     nsMediaQuery *query = mArray[0].forget();
16222:     if (!buf.AppendElement(query)) {
16222:       delete query;
16222:       rv = NS_ERROR_OUT_OF_MEMORY;
    1:     }
16222:   }
16222: #ifdef DEBUG
16222:   ok = 
16222: #endif
16222:     mArray.SwapElements(buf);
16222:   NS_ASSERTION(ok, "SwapElements should never fail when neither array "
16222:                    "is an auto array");
16222:   return rv;
    1: }
    1: 
    1: // -------------------------------
    1: // CSS Style Sheet Inner Data Container
    1: //
    1: 
    1: 
19019: nsCSSStyleSheetInner::nsCSSStyleSheetInner(nsICSSStyleSheet* aPrimarySheet)
    1:   : mSheets(),
    1:     mComplete(PR_FALSE)
  972: #ifdef DEBUG
  972:     , mPrincipalSet(PR_FALSE)
  972: #endif
    1: {
    1:   MOZ_COUNT_CTOR(nsCSSStyleSheetInner);
19019:   mSheets.AppendElement(aPrimarySheet);
  972: 
  972:   mPrincipal = do_CreateInstance("@mozilla.org/nullprincipal;1");
    1: }
    1: 
19019: static PRBool SetStyleSheetReference(nsICSSRule* aRule, void* aSheet)
19019: {
19019:   if (aRule) {
19019:     aRule->SetStyleSheet((nsICSSStyleSheet*)aSheet);
19019:   }
19019:   return PR_TRUE;
19019: }
19019: 
    1: static PRBool
    1: CloneRuleInto(nsICSSRule* aRule, void* aArray)
    1: {
    1:   nsICSSRule* clone = nsnull;
    1:   aRule->Clone(clone);
    1:   if (clone) {
 3233:     static_cast<nsCOMArray<nsICSSRule>*>(aArray)->AppendObject(clone);
    1:     NS_RELEASE(clone);
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
19019: struct ChildSheetListBuilder {
19019:   nsRefPtr<nsCSSStyleSheet>* sheetSlot;
19019:   nsCSSStyleSheet* parent;
19019: 
19019:   void SetParentLinks(nsCSSStyleSheet* aSheet) {
19019:     aSheet->mParent = parent;
19019:     aSheet->SetOwningDocument(parent->mDocument);
19019:   }
19019: };
19019:   
28778: PRBool
28778: nsCSSStyleSheet::RebuildChildList(nsICSSRule* aRule, void* aBuilder)
19019: {
19019:   PRInt32 type;
19019:   aRule->GetType(type);
28808:   if (type < nsICSSRule::IMPORT_RULE) {
28808:     // Keep going till we get to the import rules.
19019:     return PR_TRUE;
19019:   }
19019: 
28808:   if (type != nsICSSRule::IMPORT_RULE) {
28808:     // We're past all the import rules; stop the enumeration.
19019:     return PR_FALSE;
19019:   }
19019: 
19019:   ChildSheetListBuilder* builder =
19019:     static_cast<ChildSheetListBuilder*>(aBuilder);
19019: 
19019:   // XXXbz We really need to decomtaminate all this stuff.  Is there a reason
19019:   // that I can't just QI to nsICSSImportRule and get an nsCSSStyleSheet
19019:   // directly from it?
19019:   nsCOMPtr<nsIDOMCSSImportRule> importRule(do_QueryInterface(aRule));
19019:   NS_ASSERTION(importRule, "GetType lied");
19019: 
19019:   nsCOMPtr<nsIDOMCSSStyleSheet> childSheet;
19019:   importRule->GetStyleSheet(getter_AddRefs(childSheet));
19019: 
19019:   // Have to do this QI to be safe, since XPConnect can fake
19019:   // nsIDOMCSSStyleSheets
19019:   nsCOMPtr<nsICSSStyleSheet> cssSheet = do_QueryInterface(childSheet);
19019:   if (!cssSheet) {
19019:     return PR_TRUE;
19019:   }
19019: 
19019:   (*builder->sheetSlot) = static_cast<nsCSSStyleSheet*>(cssSheet.get());
19019:   builder->SetParentLinks(*builder->sheetSlot);
28778:   builder->sheetSlot = &(*builder->sheetSlot)->mNext;
19019:   return PR_TRUE;
19019: }
19019: 
    1: nsCSSStyleSheetInner::nsCSSStyleSheetInner(nsCSSStyleSheetInner& aCopy,
19019:                                            nsCSSStyleSheet* aPrimarySheet)
    1:   : mSheets(),
    1:     mSheetURI(aCopy.mSheetURI),
10518:     mOriginalSheetURI(aCopy.mOriginalSheetURI),
    1:     mBaseURI(aCopy.mBaseURI),
  972:     mPrincipal(aCopy.mPrincipal),
    1:     mComplete(aCopy.mComplete)
  972: #ifdef DEBUG
  972:     , mPrincipalSet(aCopy.mPrincipalSet)
  972: #endif
    1: {
    1:   MOZ_COUNT_CTOR(nsCSSStyleSheetInner);
24670:   AddSheet(aPrimarySheet);
    1:   aCopy.mOrderedRules.EnumerateForwards(CloneRuleInto, &mOrderedRules);
19019:   mOrderedRules.EnumerateForwards(SetStyleSheetReference, aPrimarySheet);
19019: 
19019:   ChildSheetListBuilder builder = { &mFirstChild, aPrimarySheet };
28778:   mOrderedRules.EnumerateForwards(nsCSSStyleSheet::RebuildChildList, &builder);
19019: 
    1:   RebuildNameSpaces();
    1: }
    1: 
    1: nsCSSStyleSheetInner::~nsCSSStyleSheetInner()
    1: {
    1:   MOZ_COUNT_DTOR(nsCSSStyleSheetInner);
    1:   mOrderedRules.EnumerateForwards(SetStyleSheetReference, nsnull);
    1: }
    1: 
    1: nsCSSStyleSheetInner* 
19019: nsCSSStyleSheetInner::CloneFor(nsCSSStyleSheet* aPrimarySheet)
    1: {
19019:   return new nsCSSStyleSheetInner(*this, aPrimarySheet);
    1: }
    1: 
    1: void
19019: nsCSSStyleSheetInner::AddSheet(nsICSSStyleSheet* aSheet)
    1: {
19019:   mSheets.AppendElement(aSheet);
    1: }
    1: 
    1: void
19019: nsCSSStyleSheetInner::RemoveSheet(nsICSSStyleSheet* aSheet)
    1: {
24551:   if (1 == mSheets.Length()) {
24551:     NS_ASSERTION(aSheet == mSheets.ElementAt(0), "bad parent");
    1:     delete this;
    1:     return;
    1:   }
24551:   if (aSheet == mSheets.ElementAt(0)) {
    1:     mSheets.RemoveElementAt(0);
24551:     NS_ASSERTION(mSheets.Length(), "no parents");
    1:     mOrderedRules.EnumerateForwards(SetStyleSheetReference,
24551:                                     mSheets.ElementAt(0));
    1:   }
    1:   else {
19019:     mSheets.RemoveElement(aSheet);
    1:   }
    1: }
    1: 
20509: static void
20509: AddNamespaceRuleToMap(nsICSSRule* aRule, nsXMLNameSpaceMap* aMap)
20509: {
20509: #ifdef DEBUG
20509:   PRInt32 type;
20509:   aRule->GetType(type);
20509:   NS_ASSERTION(type == nsICSSRule::NAMESPACE_RULE, "Bogus rule type");
20509: #endif
20509: 
20509:   nsCOMPtr<nsICSSNameSpaceRule> nameSpaceRule = do_QueryInterface(aRule);
20509:   
20509:   nsCOMPtr<nsIAtom> prefix;
20509:   nsAutoString  urlSpec;
20509:   nameSpaceRule->GetPrefix(*getter_AddRefs(prefix));
20509:   nameSpaceRule->GetURLSpec(urlSpec);
20509: 
20509:   aMap->AddPrefix(prefix, urlSpec);
20509: }
20509: 
    1: static PRBool
    1: CreateNameSpace(nsICSSRule* aRule, void* aNameSpacePtr)
    1: {
    1:   PRInt32 type = nsICSSRule::UNKNOWN_RULE;
    1:   aRule->GetType(type);
    1:   if (nsICSSRule::NAMESPACE_RULE == type) {
20509:     AddNamespaceRuleToMap(aRule,
20509:                           static_cast<nsXMLNameSpaceMap*>(aNameSpacePtr));
    1:     return PR_TRUE;
    1:   }
20509:   // stop if not namespace, import or charset because namespace can't follow
20509:   // anything else
20509:   return (nsICSSRule::CHARSET_RULE == type || nsICSSRule::IMPORT_RULE == type);
    1: }
    1: 
    1: void 
    1: nsCSSStyleSheetInner::RebuildNameSpaces()
    1: {
20509:   // Just nuke our existing namespace map, if any
20509:   if (NS_SUCCEEDED(CreateNamespaceMap())) {
20509:     mOrderedRules.EnumerateForwards(CreateNameSpace, mNameSpaceMap);
    1:   }
    1: }
    1: 
20509: nsresult
20509: nsCSSStyleSheetInner::CreateNamespaceMap()
20509: {
34393:   mNameSpaceMap = nsXMLNameSpaceMap::Create(PR_FALSE);
20509:   NS_ENSURE_TRUE(mNameSpaceMap, NS_ERROR_OUT_OF_MEMORY);
20509:   // Override the default namespace map behavior for the null prefix to
20509:   // return the wildcard namespace instead of the null namespace.
20509:   mNameSpaceMap->AddPrefix(nsnull, kNameSpaceID_Unknown);
20509:   return NS_OK;
    1: }
    1: 
    1: // -------------------------------
    1: // CSS Style Sheet
    1: //
    1: 
    1: nsCSSStyleSheet::nsCSSStyleSheet()
    1:   : nsICSSStyleSheet(),
    1:     mRefCnt(0),
    1:     mTitle(), 
    1:     mMedia(nsnull),
    1:     mParent(nsnull),
    1:     mOwnerRule(nsnull),
    1:     mRuleCollection(nsnull),
    1:     mDocument(nsnull),
    1:     mOwningNode(nsnull),
    1:     mDisabled(PR_FALSE),
    1:     mDirty(PR_FALSE),
    1:     mRuleProcessors(nsnull)
    1: {
    1: 
    1:   mInner = new nsCSSStyleSheetInner(this);
    1: }
    1: 
    1: nsCSSStyleSheet::nsCSSStyleSheet(const nsCSSStyleSheet& aCopy,
    1:                                  nsICSSStyleSheet* aParentToUse,
    1:                                  nsICSSImportRule* aOwnerRuleToUse,
    1:                                  nsIDocument* aDocumentToUse,
    1:                                  nsIDOMNode* aOwningNodeToUse)
    1:   : nsICSSStyleSheet(),
    1:     mRefCnt(0),
    1:     mTitle(aCopy.mTitle), 
    1:     mMedia(nsnull),
    1:     mParent(aParentToUse),
    1:     mOwnerRule(aOwnerRuleToUse),
    1:     mRuleCollection(nsnull), // re-created lazily
    1:     mDocument(aDocumentToUse),
    1:     mOwningNode(aOwningNodeToUse),
    1:     mDisabled(aCopy.mDisabled),
    1:     mDirty(PR_FALSE),
    1:     mInner(aCopy.mInner),
    1:     mRuleProcessors(nsnull)
    1: {
    1: 
    1:   mInner->AddSheet(this);
    1: 
    1:   if (aCopy.mRuleCollection && 
    1:       aCopy.mRuleCollection->mRulesAccessed) {  // CSSOM's been there, force full copy now
    1:     NS_ASSERTION(mInner->mComplete, "Why have rules been accessed on an incomplete sheet?");
36783:     // FIXME: handle failure?
    1:     EnsureUniqueInner();
    1:   }
    1: 
    1:   if (aCopy.mMedia) {
    1:     // XXX This is wrong; we should be keeping @import rules and
    1:     // sheets in sync!
19019:     aCopy.mMedia->Clone(getter_AddRefs(mMedia));
    1:   }
    1: }
    1: 
    1: nsCSSStyleSheet::~nsCSSStyleSheet()
    1: {
19019:   for (nsCSSStyleSheet* child = mInner->mFirstChild;
19019:        child;
19019:        child = child->mNext) {
19019:     // XXXbz this is a little bogus; see the XXX comment where we
19019:     // declare mFirstChild.
19019:     if (child->mParent == this) {
    1:       child->mParent = nsnull;
    1:       child->mDocument = nsnull;
    1:     }
19019:   }
    1:   if (nsnull != mRuleCollection) {
    1:     mRuleCollection->DropReference();
    1:     NS_RELEASE(mRuleCollection);
    1:   }
    1:   if (mMedia) {
    1:     mMedia->SetStyleSheet(nsnull);
    1:     mMedia = nsnull;
    1:   }
    1:   mInner->RemoveSheet(this);
    1:   // XXX The document reference is not reference counted and should
    1:   // not be released. The document will let us know when it is going
    1:   // away.
    1:   if (mRuleProcessors) {
24551:     NS_ASSERTION(mRuleProcessors->Length() == 0, "destructing sheet with rule processor reference");
    1:     delete mRuleProcessors; // weak refs, should be empty here anyway
    1:   }
    1: }
    1: 
    1: 
    1: // QueryInterface implementation for nsCSSStyleSheet
    1: NS_INTERFACE_MAP_BEGIN(nsCSSStyleSheet)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSStyleSheet)
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleSheet)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMStyleSheet)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSStyleSheet)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSLoaderObserver)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsICSSStyleSheet)
    1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(CSSStyleSheet)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsCSSStyleSheet)
    1: NS_IMPL_RELEASE(nsCSSStyleSheet)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::AddRuleProcessor(nsCSSRuleProcessor* aProcessor)
    1: {
    1:   if (! mRuleProcessors) {
24551:     mRuleProcessors = new nsAutoTArray<nsCSSRuleProcessor*, 8>();
    1:     if (!mRuleProcessors)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
28519:   NS_ASSERTION(mRuleProcessors->NoIndex == mRuleProcessors->IndexOf(aProcessor),
    1:                "processor already registered");
    1:   mRuleProcessors->AppendElement(aProcessor); // weak ref
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::DropRuleProcessor(nsCSSRuleProcessor* aProcessor)
    1: {
    1:   if (!mRuleProcessors)
    1:     return NS_ERROR_FAILURE;
    1:   return mRuleProcessors->RemoveElement(aProcessor)
    1:            ? NS_OK
    1:            : NS_ERROR_FAILURE;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
 7109: nsCSSStyleSheet::SetURIs(nsIURI* aSheetURI, nsIURI* aOriginalSheetURI,
 7109:                          nsIURI* aBaseURI)
    1: {
    1:   NS_PRECONDITION(aSheetURI && aBaseURI, "null ptr");
    1: 
    1:   NS_ASSERTION(mInner->mOrderedRules.Count() == 0 && !mInner->mComplete,
    1:                "Can't call SetURL on sheets that are complete or have rules");
    1: 
    1:   mInner->mSheetURI = aSheetURI;
 7109:   mInner->mOriginalSheetURI = aOriginalSheetURI;
    1:   mInner->mBaseURI = aBaseURI;
    1:   return NS_OK;
    1: }
    1: 
  972: void
  972: nsCSSStyleSheet::SetPrincipal(nsIPrincipal* aPrincipal)
  972: {
  972:   NS_PRECONDITION(!mInner->mPrincipalSet,
  972:                   "Should have an inner whose principal has not yet been set");
  972:   if (aPrincipal) {
  972:     mInner->mPrincipal = aPrincipal;
  972: #ifdef DEBUG
  972:     mInner->mPrincipalSet = PR_TRUE;
  972: #endif
  972:   }
  972: }
  972: 
  972: nsIPrincipal*
  972: nsCSSStyleSheet::Principal() const
  972: {
  972:   return mInner->mPrincipal;
  972: }
  972: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetSheetURI(nsIURI** aSheetURI) const
    1: {
  972:   NS_IF_ADDREF(*aSheetURI = mInner->mSheetURI.get());
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetBaseURI(nsIURI** aBaseURI) const
    1: {
  972:   NS_IF_ADDREF(*aBaseURI = mInner->mBaseURI.get());
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::SetTitle(const nsAString& aTitle)
    1: {
    1:   mTitle = aTitle;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetType(nsString& aType) const
    1: {
    1:   aType.AssignLiteral("text/css");
    1:   return NS_OK;
    1: }
    1: 
16223: PRBool
16223: nsCSSStyleSheet::UseForPresentation(nsPresContext* aPresContext,
16223:                                     nsMediaQueryResultCacheKey& aKey) const
    1: {
    1:   if (mMedia) {
16223:     return mMedia->Matches(aPresContext, aKey);
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::SetMedia(nsMediaList* aMedia)
    1: {
    1:   mMedia = aMedia;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsCSSStyleSheet::HasRules() const
    1: {
    1:   PRInt32 count;
    1:   StyleRuleCount(count);
    1:   return count != 0;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetApplicable(PRBool& aApplicable) const
    1: {
  972:   aApplicable = !mDisabled && mInner->mComplete;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::SetEnabled(PRBool aEnabled)
    1: {
    1:   // Internal method, so callers must handle BeginUpdate/EndUpdate
    1:   PRBool oldDisabled = mDisabled;
    1:   mDisabled = !aEnabled;
    1: 
21896:   if (mInner->mComplete && oldDisabled != mDisabled) {
    1:     ClearRuleCascades();
    1: 
21896:     if (mDocument) {
    1:       mDocument->SetStyleSheetApplicableState(this, !mDisabled);
    1:     }
21896:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetComplete(PRBool& aComplete) const
    1: {
  972:   aComplete = mInner->mComplete;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::SetComplete()
    1: {
    1:   NS_ASSERTION(!mDirty, "Can't set a dirty sheet complete!");
    1:   mInner->mComplete = PR_TRUE;
    1:   if (mDocument && !mDisabled) {
    1:     // Let the document know
    1:     mDocument->BeginUpdate(UPDATE_STYLE);
    1:     mDocument->SetStyleSheetApplicableState(this, PR_TRUE);
    1:     mDocument->EndUpdate(UPDATE_STYLE);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetParentSheet(nsIStyleSheet*& aParent) const
    1: {
    1:   aParent = mParent;
    1:   NS_IF_ADDREF(aParent);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetOwningDocument(nsIDocument*& aDocument) const
    1: {
    1:   aDocument = mDocument;
    1:   NS_IF_ADDREF(aDocument);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::SetOwningDocument(nsIDocument* aDocument)
    1: { // not ref counted
    1:   mDocument = aDocument;
    1:   // Now set the same document on all our child sheets....
19019:   // XXXbz this is a little bogus; see the XXX comment where we
19019:   // declare mFirstChild.
19019:   for (nsCSSStyleSheet* child = mInner->mFirstChild;
19019:        child; child = child->mNext) {
19019:     if (child->mParent == this) {
    1:       child->SetOwningDocument(aDocument);
    1:     }
19019:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::SetOwningNode(nsIDOMNode* aOwningNode)
    1: { // not ref counted
    1:   mOwningNode = aOwningNode;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::SetOwnerRule(nsICSSImportRule* aOwnerRule)
    1: { // not ref counted
    1:   mOwnerRule = aOwnerRule;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetOwnerRule(nsICSSImportRule** aOwnerRule)
    1: {
    1:   *aOwnerRule = mOwnerRule;
    1:   NS_IF_ADDREF(*aOwnerRule);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::AppendStyleSheet(nsICSSStyleSheet* aSheet)
    1: {
    1:   NS_PRECONDITION(nsnull != aSheet, "null arg");
    1: 
    1:   if (NS_SUCCEEDED(WillDirty())) {
    1:     nsCSSStyleSheet* sheet = (nsCSSStyleSheet*)aSheet;
    1: 
19019:     nsRefPtr<nsCSSStyleSheet>* tail = &mInner->mFirstChild;
19019:     while (*tail) {
19019:       tail = &(*tail)->mNext;
    1:     }
19024:     *tail = sheet;
    1:   
    1:     // This is not reference counted. Our parent tells us when
    1:     // it's going away.
    1:     sheet->mParent = this;
    1:     sheet->mDocument = mDocument;
    1:     DidDirty();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::InsertStyleSheetAt(nsICSSStyleSheet* aSheet, PRInt32 aIndex)
    1: {
    1:   NS_PRECONDITION(nsnull != aSheet, "null arg");
    1: 
    1:   nsresult result = WillDirty();
    1: 
    1:   if (NS_SUCCEEDED(result)) {
    1:     nsCSSStyleSheet* sheet = (nsCSSStyleSheet*)aSheet;
    1: 
19019:     nsRefPtr<nsCSSStyleSheet>* tail = &mInner->mFirstChild;
19019:     while (*tail && aIndex) {
19019:       --aIndex;
19019:       tail = &(*tail)->mNext;
    1:     }
19019:     sheet->mNext = *tail;
19019:     *tail = sheet;
    1: 
    1:     // This is not reference counted. Our parent tells us when
    1:     // it's going away.
    1:     sheet->mParent = this;
    1:     sheet->mDocument = mDocument;
    1:     DidDirty();
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::PrependStyleRule(nsICSSRule* aRule)
    1: {
    1:   NS_PRECONDITION(nsnull != aRule, "null arg");
    1: 
    1:   if (NS_SUCCEEDED(WillDirty())) {
    1:     mInner->mOrderedRules.InsertObjectAt(aRule, 0);
    1:     aRule->SetStyleSheet(this);
    1:     DidDirty();
    1: 
    1:     PRInt32 type = nsICSSRule::UNKNOWN_RULE;
    1:     aRule->GetType(type);
    1:     if (nsICSSRule::NAMESPACE_RULE == type) {
    1:       // no api to prepend a namespace (ugh), release old ones and re-create them all
    1:       mInner->RebuildNameSpaces();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::AppendStyleRule(nsICSSRule* aRule)
    1: {
    1:   NS_PRECONDITION(nsnull != aRule, "null arg");
    1: 
    1:   if (NS_SUCCEEDED(WillDirty())) {
    1:     mInner->mOrderedRules.AppendObject(aRule);
    1:     aRule->SetStyleSheet(this);
    1:     DidDirty();
    1: 
    1:     PRInt32 type = nsICSSRule::UNKNOWN_RULE;
    1:     aRule->GetType(type);
    1:     if (nsICSSRule::NAMESPACE_RULE == type) {
20509:       nsresult rv = RegisterNamespaceRule(aRule);
20509:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew)
    1: {
    1:   NS_PRECONDITION(mInner->mOrderedRules.Count() != 0, "can't have old rule");
  972:   NS_PRECONDITION(mInner->mComplete, "No replacing in an incomplete sheet!");
    1: 
    1:   if (NS_SUCCEEDED(WillDirty())) {
    1:     PRInt32 index = mInner->mOrderedRules.IndexOf(aOld);
    1:     NS_ENSURE_TRUE(index != -1, NS_ERROR_UNEXPECTED);
    1:     mInner->mOrderedRules.ReplaceObjectAt(aNew, index);
    1: 
    1:     aNew->SetStyleSheet(this);
    1:     aOld->SetStyleSheet(nsnull);
    1:     DidDirty();
    1: #ifdef DEBUG
    1:     PRInt32 type = nsICSSRule::UNKNOWN_RULE;
    1:     aNew->GetType(type);
    1:     NS_ASSERTION(nsICSSRule::NAMESPACE_RULE != type, "not yet implemented");
    1:     aOld->GetType(type);
    1:     NS_ASSERTION(nsICSSRule::NAMESPACE_RULE != type, "not yet implemented");
    1: #endif
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::StyleRuleCount(PRInt32& aCount) const
    1: {
    1:   aCount = mInner->mOrderedRules.Count();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetStyleRuleAt(PRInt32 aIndex, nsICSSRule*& aRule) const
    1: {
    1:   // Important: If this function is ever made scriptable, we must add
 3088:   // a security check here. See GetCssRules below for an example.
  972:   aRule = mInner->mOrderedRules.SafeObjectAt(aIndex);
  972:   if (aRule) {
  972:     NS_ADDREF(aRule);
  972:     return NS_OK;
  972:   }
    1: 
  972:   return NS_ERROR_ILLEGAL_VALUE;
    1: }
    1: 
    1: nsXMLNameSpaceMap*
    1: nsCSSStyleSheet::GetNameSpaceMap() const
    1: {
    1:   return mInner->mNameSpaceMap;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::StyleSheetCount(PRInt32& aCount) const
    1: {
    1:   // XXX Far from an ideal way to do this, but the hope is that
    1:   // it won't be done too often. If it is, we might want to 
    1:   // consider storing the children in an array.
    1:   aCount = 0;
    1: 
19019:   const nsCSSStyleSheet* child = mInner->mFirstChild;
    1:   while (child) {
    1:     aCount++;
    1:     child = child->mNext;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetStyleSheetAt(PRInt32 aIndex, nsICSSStyleSheet*& aSheet) const
    1: {
    1:   // XXX Ughh...an O(n^2) method for doing iteration. Again, we hope
    1:   // that this isn't done too often. If it is, we need to change the
    1:   // underlying storage mechanism
    1:   aSheet = nsnull;
    1: 
19019:   nsCSSStyleSheet* child = mInner->mFirstChild;
19019:   while (child && (0 != aIndex)) {
    1:     --aIndex;
    1:     child = child->mNext;
    1:   }
    1:     
19019:   NS_IF_ADDREF(aSheet = child);
    1: 
    1:   return NS_OK;
    1: }
    1: 
36783: nsCSSStyleSheet::EnsureUniqueInnerResult
    1: nsCSSStyleSheet::EnsureUniqueInner()
    1: {
36783:   NS_ABORT_IF_FALSE(mInner->mSheets.Length() != 0,
36783:                     "unexpected number of outers");
36783:   if (mInner->mSheets.Length() == 1) {
36783:     return eUniqueInner_AlreadyUnique;
36783:   }
    1:   nsCSSStyleSheetInner* clone = mInner->CloneFor(this);
36783:   if (!clone) {
36783:     return eUniqueInner_CloneFailed;
36783:   }
    1:   mInner->RemoveSheet(this);
    1:   mInner = clone;
36784: 
36784:   // otherwise the rule processor has pointers to the old rules
36784:   ClearRuleCascades();
36784: 
36783:   return eUniqueInner_ClonedInner;
    1: }
    1: 
36785: PRBool
36785: nsCSSStyleSheet::AppendAllChildSheets(nsTArray<nsCSSStyleSheet*>& aArray)
36785: {
36785:   for (nsCSSStyleSheet* child = mInner->mFirstChild; child;
36785:        child = child->mNext) {
36785:     if (!aArray.AppendElement(child)) {
36785:       return PR_FALSE;
36785:     }
36785:   }
36785:   return PR_TRUE;
36785: }
36785: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::Clone(nsICSSStyleSheet* aCloneParent,
    1:                        nsICSSImportRule* aCloneOwnerRule,
    1:                        nsIDocument* aCloneDocument,
    1:                        nsIDOMNode* aCloneOwningNode,
    1:                        nsICSSStyleSheet** aClone) const
    1: {
    1:   NS_PRECONDITION(aClone, "Null out param!");
    1:   nsCSSStyleSheet* clone = new nsCSSStyleSheet(*this,
    1:                                                aCloneParent,
    1:                                                aCloneOwnerRule,
    1:                                                aCloneDocument,
    1:                                                aCloneOwningNode);
    1:   if (clone) {
 3233:     *aClone = static_cast<nsICSSStyleSheet*>(clone);
    1:     NS_ADDREF(*aClone);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef DEBUG
    1: static void
    1: ListRules(const nsCOMArray<nsICSSRule>& aRules, FILE* aOut, PRInt32 aIndent)
    1: {
    1:   for (PRInt32 index = aRules.Count() - 1; index >= 0; --index) {
    1:     aRules.ObjectAt(index)->List(aOut, aIndent);
    1:   }
    1: }
    1: 
    1: struct ListEnumData {
    1:   ListEnumData(FILE* aOut, PRInt32 aIndent)
    1:     : mOut(aOut),
    1:       mIndent(aIndent)
    1:   {
    1:   }
    1:   FILE*   mOut;
    1:   PRInt32 mIndent;
    1: };
    1: 
    1: void nsCSSStyleSheet::List(FILE* out, PRInt32 aIndent) const
    1: {
    1: 
    1:   PRInt32 index;
    1: 
    1:   // Indent
    1:   for (index = aIndent; --index >= 0; ) fputs("  ", out);
    1: 
    1:   fputs("CSS Style Sheet: ", out);
    1:   nsCAutoString urlSpec;
    1:   nsresult rv = mInner->mSheetURI->GetSpec(urlSpec);
    1:   if (NS_SUCCEEDED(rv) && !urlSpec.IsEmpty()) {
    1:     fputs(urlSpec.get(), out);
    1:   }
    1: 
    1:   if (mMedia) {
    1:     fputs(" media: ", out);
    1:     nsAutoString  buffer;
    1:     mMedia->GetText(buffer);
    1:     fputs(NS_ConvertUTF16toUTF8(buffer).get(), out);
    1:   }
    1:   fputs("\n", out);
    1: 
19019:   for (const nsCSSStyleSheet*  child = mInner->mFirstChild;
19019:        child;
19019:        child = child->mNext) {
    1:     child->List(out, aIndent + 1);
    1:   }
    1: 
    1:   fputs("Rules in source order:\n", out);
    1:   ListRules(mInner->mOrderedRules, out, aIndent);
    1: }
    1: #endif
    1: 
    1: void 
    1: nsCSSStyleSheet::ClearRuleCascades()
    1: {
    1:   if (mRuleProcessors) {
24551:     nsCSSRuleProcessor **iter = mRuleProcessors->Elements(),
24551:                        **end = iter + mRuleProcessors->Length();
24551:     for(; iter != end; ++iter) {
24551:       (*iter)->ClearRuleCascades();
24551:     }
    1:   }
    1:   if (mParent) {
    1:     nsCSSStyleSheet* parent = (nsCSSStyleSheet*)mParent;
    1:     parent->ClearRuleCascades();
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsCSSStyleSheet::WillDirty()
    1: {
  972:   if (!mInner->mComplete) {
    1:     // Do nothing
    1:     return NS_OK;
    1:   }
    1: 
36783:   if (EnsureUniqueInner() == eUniqueInner_CloneFailed) {
36783:     return NS_ERROR_OUT_OF_MEMORY;
36783:   }
36783:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsCSSStyleSheet::DidDirty()
    1: {
    1:   ClearRuleCascades();
    1:   mDirty = PR_TRUE;
    1: }
    1: 
 3088: nsresult
 3088: nsCSSStyleSheet::SubjectSubsumesInnerPrincipal() const
 3088: {
 3088:   // Get the security manager and do the subsumes check
 3088:   nsIScriptSecurityManager *securityManager =
 3088:     nsContentUtils::GetSecurityManager();
 3088: 
 3088:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
 3088:   securityManager->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
 3088: 
 3088:   if (!subjectPrincipal) {
10382:     return NS_ERROR_DOM_SECURITY_ERR;
 3088:   }
 3088: 
 3088:   PRBool subsumes;
 3088:   nsresult rv = subjectPrincipal->Subsumes(mInner->mPrincipal, &subsumes);
 3088:   NS_ENSURE_SUCCESS(rv, rv);
 3088: 
 3088:   if (subsumes) {
 3088:     return NS_OK;
 3088:   }
 3088:   
 3088:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
 3088:     return NS_ERROR_DOM_SECURITY_ERR;
 3088:   }
 3088: 
 3088:   return NS_OK;
 3088: }
 3088: 
20509: nsresult
20509: nsCSSStyleSheet::RegisterNamespaceRule(nsICSSRule* aRule)
20509: {
20509:   if (!mInner->mNameSpaceMap) {
20509:     nsresult rv = mInner->CreateNamespaceMap();
20509:     NS_ENSURE_SUCCESS(rv, rv);
20509:   }
20509: 
20509:   AddNamespaceRuleToMap(aRule, mInner->mNameSpaceMap);
20509:   return NS_OK;
20509: }
20509: 
    1: NS_IMETHODIMP 
    1: nsCSSStyleSheet::IsModified(PRBool* aSheetModified) const
    1: {
    1:   *aSheetModified = mDirty;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::SetModified(PRBool aModified)
    1: {
    1:   mDirty = aModified;
    1:   return NS_OK;
    1: }
    1: 
    1:   // nsIDOMStyleSheet interface
    1: NS_IMETHODIMP    
    1: nsCSSStyleSheet::GetType(nsAString& aType)
    1: {
    1:   aType.AssignLiteral("text/css");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsCSSStyleSheet::GetDisabled(PRBool* aDisabled)
    1: {
    1:   *aDisabled = mDisabled;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsCSSStyleSheet::SetDisabled(PRBool aDisabled)
    1: {
    1:   // DOM method, so handle BeginUpdate/EndUpdate
    1:   MOZ_AUTO_DOC_UPDATE(mDocument, UPDATE_STYLE, PR_TRUE);
    1:   nsresult rv = nsCSSStyleSheet::SetEnabled(!aDisabled);
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetOwnerNode(nsIDOMNode** aOwnerNode)
    1: {
    1:   *aOwnerNode = mOwningNode;
    1:   NS_IF_ADDREF(*aOwnerNode);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetParentStyleSheet(nsIDOMStyleSheet** aParentStyleSheet)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aParentStyleSheet);
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (mParent) {
    1:     rv =  mParent->QueryInterface(NS_GET_IID(nsIDOMStyleSheet),
    1:                                   (void **)aParentStyleSheet);
    1:   } else {
    1:     *aParentStyleSheet = nsnull;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetHref(nsAString& aHref)
    1: {
 7109:   if (mInner->mOriginalSheetURI) {
    1:     nsCAutoString str;
 7109:     mInner->mOriginalSheetURI->GetSpec(str);
 7109:     CopyUTF8toUTF16(str, aHref);
 7109:   } else {
 7109:     SetDOMStringToNull(aHref);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetTitle(nsString& aTitle) const
    1: {
    1:   aTitle = mTitle;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetTitle(nsAString& aTitle)
    1: {
    1:   aTitle.Assign(mTitle);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::GetMedia(nsIDOMMediaList** aMedia)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aMedia);
    1:   *aMedia = nsnull;
    1: 
    1:   if (!mMedia) {
    1:     mMedia = new nsMediaList();
    1:     NS_ENSURE_TRUE(mMedia, NS_ERROR_OUT_OF_MEMORY);
    1:     mMedia->SetStyleSheet(this);
    1:   }
    1: 
    1:   *aMedia = mMedia;
    1:   NS_ADDREF(*aMedia);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsCSSStyleSheet::GetOwnerRule(nsIDOMCSSRule** aOwnerRule)
    1: {
    1:   if (mOwnerRule) {
    1:     return mOwnerRule->GetDOMRule(aOwnerRule);
    1:   }
    1: 
    1:   *aOwnerRule = nsnull;
    1:   return NS_OK;    
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsCSSStyleSheet::GetCssRules(nsIDOMCSSRuleList** aCssRules)
    1: {
    1:   // No doing this on incomplete sheets!
    1:   PRBool complete;
    1:   GetComplete(complete);
    1:   if (!complete) {
    1:     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
    1:   }
    1:   
  972:   //-- Security check: Only scripts whose principal subsumes that of the
  972:   //   style sheet can access rule collections.
 3088:   nsresult rv = SubjectSubsumesInnerPrincipal();
 3088:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // OK, security check passed, so get the rule collection
    1:   if (nsnull == mRuleCollection) {
    1:     mRuleCollection = new CSSRuleListImpl(this);
    1:     if (nsnull == mRuleCollection) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     NS_ADDREF(mRuleCollection);
    1:   }
    1: 
    1:   *aCssRules = mRuleCollection;
    1:   NS_ADDREF(mRuleCollection);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsCSSStyleSheet::InsertRule(const nsAString& aRule, 
    1:                             PRUint32 aIndex, 
    1:                             PRUint32* aReturn)
    1: {
10382:   //-- Security check: Only scripts whose principal subsumes that of the
10382:   //   style sheet can modify rule collections.
10382:   nsresult rv = SubjectSubsumesInnerPrincipal();
10382:   NS_ENSURE_SUCCESS(rv, rv);
10382: 
10382:   return InsertRuleInternal(aRule, aIndex, aReturn);
10382: }
10382: 
10382: NS_IMETHODIMP
10382: nsCSSStyleSheet::InsertRuleInternal(const nsAString& aRule, 
10382:                                     PRUint32 aIndex, 
10382:                                     PRUint32* aReturn)
10382: {
    1:   // No doing this if the sheet is not complete!
    1:   PRBool complete;
    1:   GetComplete(complete);
    1:   if (!complete) {
    1:     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
    1:   }
    1: 
    1:   if (aRule.IsEmpty()) {
    1:     // Nothing to do here
    1:     return NS_OK;
    1:   }
    1:   
    1:   nsresult result;
    1:   result = WillDirty();
    1:   if (NS_FAILED(result))
    1:     return result;
    1:   
    1:   if (aIndex > PRUint32(mInner->mOrderedRules.Count()))
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1:   
    1:   NS_ASSERTION(PRUint32(mInner->mOrderedRules.Count()) <= PR_INT32_MAX,
    1:                "Too many style rules!");
    1: 
    1:   // Hold strong ref to the CSSLoader in case the document update
    1:   // kills the document
    1:   nsCOMPtr<nsICSSLoader> loader;
    1:   if (mDocument) {
    1:     loader = mDocument->CSSLoader();
    1:     NS_ASSERTION(loader, "Document with no CSS loader!");
    1:   }
    1:   
    1:   nsCOMPtr<nsICSSParser> css;
    1:   if (loader) {
    1:     result = loader->GetParserFor(this, getter_AddRefs(css));
    1:   }
    1:   else {
    1:     result = NS_NewCSSParser(getter_AddRefs(css));
    1:     if (css) {
    1:       css->SetStyleSheet(this);
    1:     }
    1:   }
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, PR_TRUE);
    1: 
    1:   nsCOMArray<nsICSSRule> rules;
 1036:   result = css->ParseRule(aRule, mInner->mSheetURI, mInner->mBaseURI,
 1036:                           mInner->mPrincipal, rules);
    1:   if (NS_FAILED(result))
    1:     return result;
    1:   
    1:   PRInt32 rulecount = rules.Count();
    1:   if (rulecount == 0) {
    1:     // Since we know aRule was not an empty string, just throw
    1:     return NS_ERROR_DOM_SYNTAX_ERR;
    1:   }
    1:   
    1:   // Hierarchy checking.  Just check the first and last rule in the list.
    1:   
    1:   // check that we're not inserting before a charset rule
    1:   PRInt32 nextType = nsICSSRule::UNKNOWN_RULE;
    1:   nsICSSRule* nextRule = mInner->mOrderedRules.SafeObjectAt(aIndex);
    1:   if (nextRule) {
    1:     nextRule->GetType(nextType);
    1:     if (nextType == nsICSSRule::CHARSET_RULE) {
    1:       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:     }
    1: 
    1:     // check last rule in list
    1:     nsICSSRule* lastRule = rules.ObjectAt(rulecount - 1);
    1:     PRInt32 lastType = nsICSSRule::UNKNOWN_RULE;
    1:     lastRule->GetType(lastType);
    1:     
    1:     if (nextType == nsICSSRule::IMPORT_RULE &&
    1:         lastType != nsICSSRule::CHARSET_RULE &&
    1:         lastType != nsICSSRule::IMPORT_RULE) {
    1:       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:     }
    1:     
    1:     if (nextType == nsICSSRule::NAMESPACE_RULE &&
    1:         lastType != nsICSSRule::CHARSET_RULE &&
    1:         lastType != nsICSSRule::IMPORT_RULE &&
    1:         lastType != nsICSSRule::NAMESPACE_RULE) {
    1:       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:     } 
    1:   }
    1:   
    1:   // check first rule in list
    1:   nsICSSRule* firstRule = rules.ObjectAt(0);
    1:   PRInt32 firstType = nsICSSRule::UNKNOWN_RULE;
    1:   firstRule->GetType(firstType);
    1:   if (aIndex != 0) {
    1:     if (firstType == nsICSSRule::CHARSET_RULE) { // no inserting charset at nonzero position
    1:       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:     }
    1:   
    1:     nsICSSRule* prevRule = mInner->mOrderedRules.SafeObjectAt(aIndex - 1);
    1:     PRInt32 prevType = nsICSSRule::UNKNOWN_RULE;
    1:     prevRule->GetType(prevType);
    1: 
    1:     if (firstType == nsICSSRule::IMPORT_RULE &&
    1:         prevType != nsICSSRule::CHARSET_RULE &&
    1:         prevType != nsICSSRule::IMPORT_RULE) {
    1:       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:     }
    1: 
    1:     if (firstType == nsICSSRule::NAMESPACE_RULE &&
    1:         prevType != nsICSSRule::CHARSET_RULE &&
    1:         prevType != nsICSSRule::IMPORT_RULE &&
    1:         prevType != nsICSSRule::NAMESPACE_RULE) {
    1:       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:     }
    1:   }
    1:   
    1:   PRBool insertResult = mInner->mOrderedRules.InsertObjectsAt(rules, aIndex);
    1:   NS_ENSURE_TRUE(insertResult, NS_ERROR_OUT_OF_MEMORY);
    1:   DidDirty();
    1: 
    1:   for (PRInt32 counter = 0; counter < rulecount; counter++) {
    1:     nsICSSRule* cssRule = rules.ObjectAt(counter);
    1:     cssRule->SetStyleSheet(this);
    1:     
    1:     PRInt32 type = nsICSSRule::UNKNOWN_RULE;
    1:     cssRule->GetType(type);
    1:     if (type == nsICSSRule::NAMESPACE_RULE) {
20509:       // XXXbz does this screw up when inserting a namespace rule before
20509:       // another namespace rule that binds the same prefix to a different
20509:       // namespace?
20509:       result = RegisterNamespaceRule(cssRule);
20509:       NS_ENSURE_SUCCESS(result, result);
    1:     }
    1: 
    1:     // We don't notify immediately for @import rules, but rather when
    1:     // the sheet the rule is importing is loaded
    1:     PRBool notify = PR_TRUE;
    1:     if (type == nsICSSRule::IMPORT_RULE) {
    1:       nsCOMPtr<nsIDOMCSSImportRule> importRule(do_QueryInterface(cssRule));
    1:       NS_ASSERTION(importRule, "Rule which has type IMPORT_RULE and does not implement nsIDOMCSSImportRule!");
    1:       nsCOMPtr<nsIDOMCSSStyleSheet> childSheet;
    1:       importRule->GetStyleSheet(getter_AddRefs(childSheet));
    1:       if (!childSheet) {
    1:         notify = PR_FALSE;
    1:       }
    1:     }
    1:     if (mDocument && notify) {
    1:       mDocument->StyleRuleAdded(this, cssRule);
    1:     }
    1:   }
    1:   
    1:   if (loader) {
    1:     loader->RecycleParser(css);
    1:   }
    1:   
    1:   *aReturn = aIndex;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsCSSStyleSheet::DeleteRule(PRUint32 aIndex)
    1: {
    1:   nsresult result = NS_ERROR_DOM_INDEX_SIZE_ERR;
    1:   // No doing this if the sheet is not complete!
    1:   PRBool complete;
    1:   GetComplete(complete);
    1:   if (!complete) {
    1:     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
    1:   }
    1: 
 3088:   //-- Security check: Only scripts whose principal subsumes that of the
 3088:   //   style sheet can modify rule collections.
 3088:   nsresult rv = SubjectSubsumesInnerPrincipal();
 3088:   NS_ENSURE_SUCCESS(rv, rv);
 3088: 
    1:   // XXX TBI: handle @rule types
    1:   mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, PR_TRUE);
    1:     
    1:   result = WillDirty();
    1: 
    1:   if (NS_SUCCEEDED(result)) {
    1:     if (aIndex >= PRUint32(mInner->mOrderedRules.Count()))
    1:       return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1: 
    1:     NS_ASSERTION(PRUint32(mInner->mOrderedRules.Count()) <= PR_INT32_MAX,
    1:                  "Too many style rules!");
    1: 
    1:     // Hold a strong ref to the rule so it doesn't die when we RemoveObjectAt
    1:     nsCOMPtr<nsICSSRule> rule = mInner->mOrderedRules.ObjectAt(aIndex);
    1:     if (rule) {
    1:       mInner->mOrderedRules.RemoveObjectAt(aIndex);
    1:       rule->SetStyleSheet(nsnull);
    1:       DidDirty();
    1: 
    1:       if (mDocument) {
    1:         mDocument->StyleRuleRemoved(this, rule);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::DeleteRuleFromGroup(nsICSSGroupRule* aGroup, PRUint32 aIndex)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aGroup);
  972:   NS_ASSERTION(mInner->mComplete, "No deleting from an incomplete sheet!");
    1:   nsresult result;
    1:   nsCOMPtr<nsICSSRule> rule;
    1:   result = aGroup->GetStyleRuleAt(aIndex, *getter_AddRefs(rule));
    1:   NS_ENSURE_SUCCESS(result, result);
    1:   
    1:   // check that the rule actually belongs to this sheet!
    1:   nsCOMPtr<nsIStyleSheet> ruleSheet;
    1:   rule->GetStyleSheet(*getter_AddRefs(ruleSheet));
    1:   if (this != ruleSheet) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, PR_TRUE);
    1:   
    1:   result = WillDirty();
    1:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   result = aGroup->DeleteStyleRuleAt(aIndex);
    1:   NS_ENSURE_SUCCESS(result, result);
    1:   
    1:   rule->SetStyleSheet(nsnull);
    1:   
    1:   DidDirty();
    1: 
    1:   if (mDocument) {
    1:     mDocument->StyleRuleRemoved(this, rule);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::InsertRuleIntoGroup(const nsAString & aRule,
    1:                                      nsICSSGroupRule* aGroup,
    1:                                      PRUint32 aIndex,
    1:                                      PRUint32* _retval)
    1: {
    1:   nsresult result;
  972:   NS_ASSERTION(mInner->mComplete, "No inserting into an incomplete sheet!");
    1:   // check that the group actually belongs to this sheet!
    1:   nsCOMPtr<nsIStyleSheet> groupSheet;
    1:   aGroup->GetStyleSheet(*getter_AddRefs(groupSheet));
    1:   if (this != groupSheet) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   if (aRule.IsEmpty()) {
    1:     // Nothing to do here
    1:     return NS_OK;
    1:   }
    1:   
    1:   // Hold strong ref to the CSSLoader in case the document update
    1:   // kills the document
    1:   nsCOMPtr<nsICSSLoader> loader;
    1:   if (mDocument) {
    1:     loader = mDocument->CSSLoader();
    1:     NS_ASSERTION(loader, "Document with no CSS loader!");
    1:   }
    1: 
    1:   nsCOMPtr<nsICSSParser> css;
    1:   if (loader) {
    1:     result = loader->GetParserFor(this, getter_AddRefs(css));
    1:   }
    1:   else {
    1:     result = NS_NewCSSParser(getter_AddRefs(css));
    1:     if (css) {
    1:       css->SetStyleSheet(this);
    1:     }
    1:   }
    1:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   // parse and grab the rule
    1:   mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, PR_TRUE);
    1: 
    1:   result = WillDirty();
    1:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   nsCOMArray<nsICSSRule> rules;
 1036:   result = css->ParseRule(aRule, mInner->mSheetURI, mInner->mBaseURI,
 1036:                           mInner->mPrincipal, rules);
    1:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   PRInt32 rulecount = rules.Count();
    1:   if (rulecount == 0) {
    1:     // Since we know aRule was not an empty string, just throw
    1:     return NS_ERROR_DOM_SYNTAX_ERR;
    1:   }
    1: 
    1:   PRInt32 counter;
    1:   nsICSSRule* rule;
    1:   for (counter = 0; counter < rulecount; counter++) {
    1:     // Only rulesets are allowed in a group as of CSS2
    1:     PRInt32 type = nsICSSRule::UNKNOWN_RULE;
    1:     rule = rules.ObjectAt(counter);
    1:     rule->GetType(type);
    1:     if (type != nsICSSRule::STYLE_RULE) {
    1:       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:     }
    1:   }
    1:   
    1:   result = aGroup->InsertStyleRulesAt(aIndex, rules);
    1:   NS_ENSURE_SUCCESS(result, result);
    1:   DidDirty();
    1:   for (counter = 0; counter < rulecount; counter++) {
    1:     rule = rules.ObjectAt(counter);
    1:   
    1:     if (mDocument) {
    1:       mDocument->StyleRuleAdded(this, rule);
    1:     }
    1:   }
    1: 
    1:   if (loader) {
    1:     loader->RecycleParser(css);
    1:   }
    1: 
    1:   *_retval = aIndex;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::ReplaceRuleInGroup(nsICSSGroupRule* aGroup,
    1:                                       nsICSSRule* aOld, nsICSSRule* aNew)
    1: {
    1:   nsresult result;
  972:   NS_PRECONDITION(mInner->mComplete, "No replacing in an incomplete sheet!");
    1: #ifdef DEBUG
    1:   {
    1:     nsCOMPtr<nsIStyleSheet> groupSheet;
    1:     aGroup->GetStyleSheet(*getter_AddRefs(groupSheet));
    1:     NS_ASSERTION(this == groupSheet, "group doesn't belong to this sheet");
    1:   }
    1: #endif
    1:   result = WillDirty();
    1:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   result = aGroup->ReplaceStyleRule(aOld, aNew);
    1:   DidDirty();
    1:   return result;
    1: }
    1: 
    1: // nsICSSLoaderObserver implementation
    1: NS_IMETHODIMP
    1: nsCSSStyleSheet::StyleSheetLoaded(nsICSSStyleSheet* aSheet,
    1:                                   PRBool aWasAlternate,
    1:                                   nsresult aStatus)
    1: {
    1: #ifdef DEBUG
    1:   nsCOMPtr<nsIStyleSheet> styleSheet(do_QueryInterface(aSheet));
    1:   NS_ASSERTION(styleSheet, "Sheet not implementing nsIStyleSheet!\n");
    1:   nsCOMPtr<nsIStyleSheet> parentSheet;
    1:   aSheet->GetParentSheet(*getter_AddRefs(parentSheet));
    1:   nsCOMPtr<nsIStyleSheet> thisSheet;
    1:   QueryInterface(NS_GET_IID(nsIStyleSheet), getter_AddRefs(thisSheet));
    1:   NS_ASSERTION(thisSheet == parentSheet, "We are being notified of a sheet load for a sheet that is not our child!\n");
    1: #endif
    1:   
    1:   if (mDocument && NS_SUCCEEDED(aStatus)) {
    1:     nsCOMPtr<nsICSSImportRule> ownerRule;
    1:     aSheet->GetOwnerRule(getter_AddRefs(ownerRule));
    1:     
    1:     mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, PR_TRUE);
    1: 
    1:     // XXXldb @import rules shouldn't even implement nsIStyleRule (but
    1:     // they do)!
    1:     nsCOMPtr<nsIStyleRule> styleRule(do_QueryInterface(ownerRule));
    1:     
    1:     mDocument->StyleRuleAdded(this, styleRule);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
25982: NS_IMETHODIMP_(nsIURI*)
25982: nsCSSStyleSheet::GetOriginalURI() const
25982: {
25982:   return mInner->mOriginalSheetURI;
25982: }
25982: 
    1: nsresult
    1: NS_NewCSSStyleSheet(nsICSSStyleSheet** aInstancePtrResult)
    1: {
  972:   *aInstancePtrResult = nsnull;
    1:   nsCSSStyleSheet  *it = new nsCSSStyleSheet();
    1: 
  972:   if (!it) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   NS_ADDREF(it);
  972: 
  972:   if (!it->mInner || !it->mInner->mPrincipal) {
  972:     NS_RELEASE(it);
  972:     return NS_ERROR_OUT_OF_MEMORY;
  972:   }
  972:   
    1:   *aInstancePtrResult = it;
    1:   return NS_OK;
    1: }
