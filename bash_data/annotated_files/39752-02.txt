    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=80: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Travis Bogard <travis@netscape.com>
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Vidur Apparao <vidur@netscape.com>
    1:  *   Johnny Stenback <jst@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsGlobalWindow_h___
    1: #define nsGlobalWindow_h___
    1: 
    1: // Local Includes
    1: // Helper Classes
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsWeakReference.h"
    1: #include "nsHashtable.h"
    1: #include "nsDataHashtable.h"
    1: #include "nsCycleCollectionParticipant.h"
11622: #include "nsDOMScriptObjectHolder.h"
    1: 
    1: // Interfaces Needed
    1: #include "nsDOMWindowList.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsIBrowserDOMWindow.h"
    1: #include "nsIDocShellTreeOwner.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDOMClientInformation.h"
    1: #include "nsIDOMViewCSS.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOM3EventTarget.h"
    1: #include "nsIDOMNSEventTarget.h"
    1: #include "nsIDOMNavigator.h"
16677: #include "nsIDOMNavigatorGeolocation.h"
18869: #include "nsIDOMLocation.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIDOMJSWindow.h"
    1: #include "nsIDOMChromeWindow.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIScriptObjectPrincipal.h"
    1: #include "nsIScriptTimeoutHandler.h"
    1: #include "nsITimer.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsPIDOMWindow.h"
 4040: #include "nsIDOMModalContentWindow.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMCrypto.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsPluginArray.h"
    1: #include "nsMimeTypeArray.h"
    1: #include "nsIXPCScriptable.h"
    1: #include "nsPoint.h"
    1: #include "nsSize.h"
30882: #include "nsRect.h"
    1: #include "mozFlushType.h"
    1: #include "prclist.h"
28438: #include "nsIDOMStorageObsolete.h"
    1: #include "nsIDOMStorageList.h"
    1: #include "nsIDOMStorageWindow.h"
37608: #include "nsIDOMStorageEvent.h"
 1938: #include "nsIDOMOfflineResourceList.h"
    1: #include "nsPIDOMEventTarget.h"
 4040: #include "nsIArray.h"
29018: #include "nsIContent.h"
    1: 
    1: #define DEFAULT_HOME_PAGE "www.mozilla.org"
    1: #define PREF_BROWSER_STARTUP_HOMEPAGE "browser.startup.homepage"
    1: 
    1: class nsIDOMBarProp;
    1: class nsIDocument;
    1: class nsPresContext;
    1: class nsIDOMEvent;
37063: class nsIScrollableFrame;
 6910: class nsIControllers;
    1: 
    1: class nsBarProp;
    1: class nsLocation;
    1: class nsNavigator;
    1: class nsScreen;
    1: class nsHistory;
    1: class nsIDocShellLoadInfo;
    1: class WindowStateHolder;
    1: class nsGlobalWindowObserver;
    1: class nsGlobalWindow;
 6774: class nsDummyJavaPluginOwner;
14898: class PostMessageEvent;
35152: class nsRunnable;
    1: 
 1938: class nsDOMOfflineResourceList;
16677: class nsGeolocation;
 1938: 
    1: extern nsresult
10986: NS_CreateJSTimeoutHandler(nsGlobalWindow *aWindow,
 3106:                           PRBool *aIsInterval,
    1:                           PRInt32 *aInterval,
    1:                           nsIScriptTimeoutHandler **aRet);
    1: 
    1: /*
    1:  * Timeout struct that holds information about each script
    1:  * timeout.  Holds a strong reference to an nsIScriptTimeoutHandler, which
    1:  * abstracts the language specific cruft.
    1:  */
    1: struct nsTimeout : PRCList
    1: {
    1:   nsTimeout();
    1:   ~nsTimeout();
    1: 
24195:   NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(nsTimeout)
24195: 
    1:   nsrefcnt Release();
    1:   nsrefcnt AddRef();
    1: 
    1:   nsTimeout* Next() {
    1:     // Note: might not actually return an nsTimeout.  Use IsTimeout to check.
 3233:     return static_cast<nsTimeout*>(PR_NEXT_LINK(this));
    1:   }
    1: 
    1:   nsTimeout* Prev() {
    1:     // Note: might not actually return an nsTimeout.  Use IsTimeout to check.
 3233:     return static_cast<nsTimeout*>(PR_PREV_LINK(this));
    1:   }
    1: 
    1:   // Window for which this timeout fires
    1:   nsRefPtr<nsGlobalWindow> mWindow;
    1: 
    1:   // The actual timer object
    1:   nsCOMPtr<nsITimer> mTimer;
    1: 
    1:   // True if the timeout was cleared
    1:   PRPackedBool mCleared;
    1: 
    1:   // True if this is one of the timeouts that are currently running
    1:   PRPackedBool mRunning;
    1: 
    1:   // Returned as value of setTimeout()
    1:   PRUint32 mPublicId;
    1: 
    1:   // Non-zero interval in milliseconds if repetitive timeout
    1:   PRUint32 mInterval;
    1: 
    1:   // Nominal time (in microseconds since the epoch) to run this
    1:   // timeout
    1:   PRTime mWhen;
    1: 
    1:   // Principal with which to execute
    1:   nsCOMPtr<nsIPrincipal> mPrincipal;
    1: 
    1:   // stack depth at which timeout is firing
    1:   PRUint32 mFiringDepth;
    1: 
34729:   // 
34729:   PRUint32 mNestingLevel;
34729: 
    1:   // The popup state at timeout creation time if not created from
    1:   // another timeout
    1:   PopupControlState mPopupState;
    1: 
    1:   // The language-specific information about the callback.
    1:   nsCOMPtr<nsIScriptTimeoutHandler> mScriptHandler;
    1: 
    1: private:
    1:   // reference count for shared usage
24195:   nsAutoRefCnt mRefCnt;
    1: };
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow: Global Object for Scripting
    1: //*****************************************************************************
    1: // Beware that all scriptable interfaces implemented by
    1: // nsGlobalWindow will be reachable from JS, if you make this class
    1: // implement new interfaces you better know what you're
    1: // doing. Security wise this is very sensitive code. --
    1: // jst@netscape.com
    1: 
    1: // nsGlobalWindow inherits PRCList for maintaining a list of all inner
10976: // windows still in memory for any given outer window. This list is
    1: // needed to ensure that mOuterWindow doesn't end up dangling. The
    1: // nature of PRCList means that the window itself is always in the
    1: // list, and an outer window's list will also contain all inner window
    1: // objects that are still in memory (and in reality all inner window
    1: // object's lists also contain its outer and all other inner windows
    1: // belonging to the same outer window, but that's an unimportant
    1: // side effect of inheriting PRCList).
    1: 
    1: class nsGlobalWindow : public nsPIDOMWindow,
    1:                        public nsIScriptGlobalObject,
    1:                        public nsIDOMJSWindow,
    1:                        public nsIScriptObjectPrincipal,
 1418:                        public nsIDOMEventTarget,
    1:                        public nsPIDOMEventTarget,
    1:                        public nsIDOM3EventTarget,
    1:                        public nsIDOMNSEventTarget,
    1:                        public nsIDOMViewCSS,
    1:                        public nsIDOMStorageWindow,
    1:                        public nsSupportsWeakReference,
    1:                        public nsIInterfaceRequestor,
    1:                        public PRCListStr
    1: {
    1: public:
    1:   // public methods
    1:   nsPIDOMWindow* GetPrivateParent();
    1:   // callback for close event
    1:   void ReallyCloseWindow();
35152:   void ReallyClearScope(nsRunnable *aRunnable);
    1: 
    1:   // nsISupports
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   // nsIScriptGlobalObject
    1:   virtual nsIScriptContext *GetContext();
    1:   virtual JSObject *GetGlobalJSObject();
    1: 
    1:   virtual nsresult EnsureScriptEnvironment(PRUint32 aLangID);
    1: 
    1:   virtual nsIScriptContext *GetScriptContext(PRUint32 lang);
    1:   virtual void *GetScriptGlobal(PRUint32 lang);
    1: 
    1:   // Set a new script language context for this global.  The native global
    1:   // for the context is created by the context's GetNativeGlobal() method.
    1:   virtual nsresult SetScriptContext(PRUint32 lang, nsIScriptContext *aContext);
    1:   
    1:   virtual void OnFinalize(PRUint32 aLangID, void *aScriptGlobal);
    1:   virtual void SetScriptsEnabled(PRBool aEnabled, PRBool aFireTimeouts);
    1: 
    1:   // nsIScriptObjectPrincipal
    1:   virtual nsIPrincipal* GetPrincipal();
    1: 
    1:   // nsIDOMWindow
    1:   NS_DECL_NSIDOMWINDOW
    1: 
    1:   // nsIDOMWindow2
    1:   NS_DECL_NSIDOMWINDOW2
    1: 
    1:   // nsIDOMWindowInternal
    1:   NS_DECL_NSIDOMWINDOWINTERNAL
    1: 
    1:   // nsIDOMJSWindow
    1:   NS_DECL_NSIDOMJSWINDOW
    1: 
    1:   // nsIDOMEventTarget
    1:   NS_DECL_NSIDOMEVENTTARGET
    1: 
    1:   // nsIDOM3EventTarget
    1:   NS_DECL_NSIDOM3EVENTTARGET
    1: 
    1:   // nsIDOMNSEventTarget
    1:   NS_DECL_NSIDOMNSEVENTTARGET
    1: 
    1:   // nsPIDOMWindow
    1:   virtual NS_HIDDEN_(nsPIDOMWindow*) GetPrivateRoot();
29018:   virtual NS_HIDDEN_(void) ActivateOrDeactivate(PRBool aActivate);
39698:   virtual NS_HIDDEN_(void) SetActive(PRBool aActive);
16549:   virtual NS_HIDDEN_(void) SetChromeEventHandler(nsPIDOMEventTarget* aChromeEventHandler);
    1: 
    1:   virtual NS_HIDDEN_(void) SetOpenerScriptPrincipal(nsIPrincipal* aPrincipal);
    1:   virtual NS_HIDDEN_(nsIPrincipal*) GetOpenerScriptPrincipal();
    1: 
    1:   virtual NS_HIDDEN_(PopupControlState) PushPopupControlState(PopupControlState state, PRBool aForce) const;
    1:   virtual NS_HIDDEN_(void) PopPopupControlState(PopupControlState state) const;
    1:   virtual NS_HIDDEN_(PopupControlState) GetPopupControlState() const;
    1: 
    1:   virtual NS_HIDDEN_(nsresult) SaveWindowState(nsISupports **aState);
    1:   virtual NS_HIDDEN_(nsresult) RestoreWindowState(nsISupports *aState);
25723:   virtual NS_HIDDEN_(void) SuspendTimeouts(PRUint32 aIncrease = 1,
25723:                                            PRBool aFreezeChildren = PR_TRUE);
25723:   virtual NS_HIDDEN_(nsresult) ResumeTimeouts(PRBool aThawChildren = PR_TRUE);
25723:   virtual NS_HIDDEN_(PRUint32) TimeoutSuspendCount();
    1:   virtual NS_HIDDEN_(nsresult) FireDelayedDOMEvents();
10340:   virtual NS_HIDDEN_(PRBool) IsFrozen() const
10340:   {
10340:     return mIsFrozen;
10340:   }
    1: 
    1:   virtual NS_HIDDEN_(PRBool) WouldReuseInnerWindow(nsIDocument *aNewDocument);
    1: 
  588:   virtual NS_HIDDEN_(nsPIDOMEventTarget*) GetTargetForDOMEvent()
  588:   {
 3233:     return static_cast<nsPIDOMEventTarget*>(GetOuterWindowInternal());
  588:   }
  588:   virtual NS_HIDDEN_(nsPIDOMEventTarget*) GetTargetForEventTargetChain()
  588:   {
 3233:     return static_cast<nsPIDOMEventTarget*>(GetCurrentInnerWindowInternal());
  588:   }
    1:   virtual NS_HIDDEN_(nsresult) PreHandleEvent(nsEventChainPreVisitor& aVisitor);
    1:   virtual NS_HIDDEN_(nsresult) PostHandleEvent(nsEventChainPostVisitor& aVisitor);
    1:   virtual NS_HIDDEN_(nsresult) DispatchDOMEvent(nsEvent* aEvent,
    1:                                                 nsIDOMEvent* aDOMEvent,
    1:                                                 nsPresContext* aPresContext,
    1:                                                 nsEventStatus* aEventStatus);
29474:   virtual NS_HIDDEN_(nsIEventListenerManager*) GetListenerManager(PRBool aCreateIfNotFound);
 1418:   virtual NS_HIDDEN_(nsresult) AddEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                                      const nsIID& aIID);
 1418:   virtual NS_HIDDEN_(nsresult) RemoveEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                                         const nsIID& aIID);
 1418:   virtual NS_HIDDEN_(nsresult) GetSystemEventGroup(nsIDOMEventGroup** aGroup);
27700:   virtual NS_HIDDEN_(nsIScriptContext*) GetContextForEventHandlers(nsresult* aRv);
    1: 
    1:   virtual NS_HIDDEN_(void) SetDocShell(nsIDocShell* aDocShell);
    1:   virtual NS_HIDDEN_(nsresult) SetNewDocument(nsIDocument *aDocument,
39376:                                               nsISupports *aState);
    1:   virtual NS_HIDDEN_(void) SetOpenerWindow(nsIDOMWindowInternal *aOpener,
    1:                                            PRBool aOriginalOpener);
    1:   virtual NS_HIDDEN_(void) EnsureSizeUpToDate();
    1: 
    1:   virtual NS_HIDDEN_(void) EnterModalState();
    1:   virtual NS_HIDDEN_(void) LeaveModalState();
    1: 
37611:   virtual NS_HIDDEN_(PRBool) CanClose();
37611:   virtual NS_HIDDEN_(nsresult) ForceClose();
37611: 
31738:   virtual NS_HIDDEN_(void) SetHasOrientationEventListener();
31738: 
    1:   // nsIDOMViewCSS
    1:   NS_DECL_NSIDOMVIEWCSS
    1: 
    1:   // nsIDOMAbstractView
    1:   NS_DECL_NSIDOMABSTRACTVIEW
    1: 
    1:   // nsIDOMStorageWindow
    1:   NS_DECL_NSIDOMSTORAGEWINDOW
    1: 
    1:   // nsIInterfaceRequestor
    1:   NS_DECL_NSIINTERFACEREQUESTOR
    1: 
    1:   // Object Management
    1:   nsGlobalWindow(nsGlobalWindow *aOuterWindow);
    1: 
30001:   static nsGlobalWindow *FromSupports(nsISupports *supports)
30001:   {
30001:     // Make sure this matches the casts we do in QueryInterface().
30001:     return (nsGlobalWindow *)(nsIScriptGlobalObject *)supports;
30001:   }
    1:   static nsGlobalWindow *FromWrapper(nsIXPConnectWrappedNative *wrapper)
    1:   {
30001:     return FromSupports(wrapper->Native());
    1:   }
    1: 
    1:   nsIScriptContext *GetContextInternal()
    1:   {
    1:     if (mOuterWindow) {
    1:       return GetOuterWindowInternal()->mContext;
    1:     }
    1: 
    1:     return mContext;
    1:   }
    1: 
    1:   nsIScriptContext *GetScriptContextInternal(PRUint32 aLangID)
    1:   {
    1:     NS_ASSERTION(NS_STID_VALID(aLangID), "Invalid language");
    1:     if (mOuterWindow) {
    1:       return GetOuterWindowInternal()->mScriptContexts[NS_STID_INDEX(aLangID)];
    1:     }
    1: 
    1:     return mScriptContexts[NS_STID_INDEX(aLangID)];
    1:   }
    1: 
    1:   nsGlobalWindow *GetOuterWindowInternal()
    1:   {
 3233:     return static_cast<nsGlobalWindow *>(GetOuterWindow());
    1:   }
    1: 
    1:   nsGlobalWindow *GetCurrentInnerWindowInternal()
    1:   {
 3233:     return static_cast<nsGlobalWindow *>(mInnerWindow);
    1:   }
    1: 
    1:   nsGlobalWindow *EnsureInnerWindowInternal()
    1:   {
 3233:     return static_cast<nsGlobalWindow *>(EnsureInnerWindow());
    1:   }
    1: 
    1:   PRBool IsCreatingInnerWindow() const
    1:   {
    1:     return  mCreatingInnerWindow;
    1:   }
    1: 
 4209:   PRBool IsChromeWindow() const
 4209:   {
 4209:     return mIsChrome;
 4209:   }
 4209: 
    1:   nsresult Observe(nsISupports* aSubject, const char* aTopic,
    1:                    const PRUnichar* aData);
    1: 
    1:   static void ShutDown();
11622:   static void CleanupCachedXBLHandlers(nsGlobalWindow* aWindow);
    1:   static PRBool IsCallerChrome();
    1:   static void CloseBlockScriptTerminationFunc(nsISupports *aRef);
    1: 
    1:   static void RunPendingTimeoutsRecursive(nsGlobalWindow *aTopWindow,
    1:                                           nsGlobalWindow *aWindow);
    1: 
    1:   friend class WindowStateHolder;
    1: 
11622:   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(nsGlobalWindow,
    1:                                                          nsIScriptGlobalObject)
    1: 
 6774:   void InitJavaProperties();
 6774: 
11622:   virtual NS_HIDDEN_(void*)
11622:     GetCachedXBLPrototypeHandler(nsXBLPrototypeHandler* aKey);
11622: 
11622:   virtual NS_HIDDEN_(void)
11622:     CacheXBLPrototypeHandler(nsXBLPrototypeHandler* aKey,
11622:                              nsScriptObjectHolder& aHandler);
11622: 
29018:   virtual PRBool TakeFocus(PRBool aFocus, PRUint32 aFocusMethod);
29018:   virtual void SetReadyForFocus();
29018:   virtual void PageHidden();
37368:   virtual nsresult DispatchSyncHashchange();
37802:   virtual nsresult DispatchSyncPopState();
37802: 
33525:   virtual nsresult SetArguments(nsIArray *aArguments, nsIPrincipal *aOrigin);
29018: 
21376:   static PRBool DOMWindowDumpEnabled();
11622: 
39378:   void MaybeForgiveSpamCount();
39378:   PRBool IsClosedOrClosing() {
39378:     return (mIsClosed ||
39378:             mInClose ||
39378:             mHavePendingClose ||
39378:             mCleanedUp);
39378:   }
39378: 
    1: protected:
    1:   // Object Management
    1:   virtual ~nsGlobalWindow();
39378:   void CleanUp(PRBool aIgnoreModalDialog);
    1:   void ClearControllers();
37611:   nsresult FinalClose();
    1: 
    1:   void FreeInnerObjects(PRBool aClearScope);
11028:   nsGlobalWindow *CallerInnerWindow();
    1: 
39402:   nsresult InnerSetNewDocument(nsIDocument* aDocument);
39376: 
33525:   nsresult DefineArgumentsProperty(nsIArray *aArguments);
    1: 
    1:   // Get the parent, returns null if this is a toplevel window
    1:   nsIDOMWindowInternal *GetParentInternal();
    1: 
    1:   // popup tracking
    1:   PRBool IsPopupSpamWindow()
    1:   {
    1:     if (IsInnerWindow() && !mOuterWindow) {
    1:       return PR_FALSE;
    1:     }
    1: 
    1:     return GetOuterWindowInternal()->mIsPopupSpam;
    1:   }
    1: 
    1:   void SetPopupSpamWindow(PRBool aPopup)
    1:   {
    1:     if (IsInnerWindow() && !mOuterWindow) {
    1:       NS_ERROR("SetPopupSpamWindow() called on inner window w/o an outer!");
    1: 
    1:       return;
    1:     }
    1: 
    1:     GetOuterWindowInternal()->mIsPopupSpam = aPopup;
    1:   }
    1: 
    1:   // Window Control Functions
    1:   /**
    1:    * @param aURL the URL to load in the new window
    1:    * @param aName the name to use for the new window
    1:    * @param aOptions the window options to use for the new window
    1:    * @param aDialog true when called from variants of OpenDialog.  If this is
    1:    *                true, this method will skip popup blocking checks.  The
    1:    *                aDialog argument is passed on to the window watcher.
    1:    * @param aCalledNoScript true when called via the [noscript] open()
    1:    *                        and openDialog() methods.  When this is true, we do
    1:    *                        NOT want to use the JS stack for things like caller
    1:    *                        determination.
    1:    * @param aDoJSFixups true when this is the content-accessible JS version of
    1:    *                    window opening.  When true, popups do not cause us to
    1:    *                    throw, we save the caller's principal in the new window
    1:    *                    for later consumption, and we make sure that there is a
    1:    *                    document in the newly-opened window.  Note that this
    1:    *                    last will only be done if the newly-opened window is
    1:    *                    non-chrome.
    1:    * @param argv The arguments to pass to the new window.  The first
    1:    *             three args, if present, will be aURL, aName, and aOptions.  So
    1:    *             this param only matters if there are more than 3 arguments.
    1:    * @param argc The number of arguments in argv.
    1:    * @param aExtraArgument Another way to pass arguments in.  This is mutually
    1:    *                       exclusive with the argv/argc approach.
    1:    * @param aJSCallerContext The calling script's context. This must be nsnull
    1:    *                         when aCalledNoScript is true.
    1:    * @param aReturn [out] The window that was opened, if any.
    1:    *
    1:    * @note that the boolean args are const because the function shouldn't be
    1:    * messing with them.  That also makes it easier for the compiler to sort out
    1:    * its build warning stuff.
    1:    */
    1:   NS_HIDDEN_(nsresult) OpenInternal(const nsAString& aUrl,
    1:                                     const nsAString& aName,
    1:                                     const nsAString& aOptions,
    1:                                     PRBool aDialog,
 5814:                                     PRBool aContentModal,
    1:                                     PRBool aCalledNoScript,
    1:                                     PRBool aDoJSFixups,
    1:                                     nsIArray *argv,
    1:                                     nsISupports *aExtraArgument,
    1:                                     nsIPrincipal *aCalleePrincipal,
    1:                                     JSContext *aJSCallerContext,
    1:                                     nsIDOMWindow **aReturn);
    1: 
    1:   static void CloseWindow(nsISupports* aWindow);
    1:   static void ClearWindowScope(nsISupports* aWindow);
    1: 
    1:   // Timeout Functions
    1:   // Language agnostic timeout function (all args passed)
    1:   nsresult SetTimeoutOrInterval(nsIScriptTimeoutHandler *aHandler,
    1:                                 PRInt32 interval,
    1:                                 PRBool aIsInterval, PRInt32 *aReturn);
    1:   nsresult ClearTimeoutOrInterval(PRInt32 aTimerID);
    1: 
    1:   // JS specific timeout functions (JS args grabbed from context).
    1:   nsresult SetTimeoutOrInterval(PRBool aIsInterval, PRInt32* aReturn);
    1:   nsresult ClearTimeoutOrInterval();
    1: 
    1:   // The timeout implementation functions.
    1:   void RunTimeout(nsTimeout *aTimeout);
39752:   void RunTimeout() { RunTimeout(nsnull); }
    1: 
    1:   void ClearAllTimeouts();
    1:   // Insert aTimeout into the list, before all timeouts that would
    1:   // fire after it, but no earlier than mTimeoutInsertionPoint, if any.
    1:   void InsertTimeoutIntoList(nsTimeout *aTimeout);
    1:   static void TimerCallback(nsITimer *aTimer, void *aClosure);
    1: 
    1:   // Helper Functions
    1:   nsresult GetTreeOwner(nsIDocShellTreeOwner** aTreeOwner);
    1:   nsresult GetTreeOwner(nsIBaseWindow** aTreeOwner);
    1:   nsresult GetWebBrowserChrome(nsIWebBrowserChrome** aBrowserChrome);
37063:   // GetScrollFrame does not flush.  Callers should do it themselves as needed,
37063:   // depending on which info they actually want off the scrollable frame.
37063:   nsIScrollableFrame *GetScrollFrame();
    1:   nsresult SecurityCheckURL(const char *aURL);
    1:   nsresult BuildURIfromBase(const char *aURL,
    1:                             nsIURI **aBuiltURI,
    1:                             PRBool *aFreeSecurityPass, JSContext **aCXused);
34524:   PRBool PopupWhitelisted();
34524:   PopupControlState RevisePopupAbuseLevel(PopupControlState);
    1:   void     FireAbuseEvents(PRBool aBlocked, PRBool aWindow,
    1:                            const nsAString &aPopupURL,
    1:                            const nsAString &aPopupWindowName,
    1:                            const nsAString &aPopupWindowFeatures);
    1:   void FireOfflineStatusEvent();
    1: 
    1:   void FlushPendingNotifications(mozFlushType aType);
    1:   void EnsureReflowFlushAndPaint();
    1:   nsresult CheckSecurityWidthAndHeight(PRInt32* width, PRInt32* height);
    1:   nsresult CheckSecurityLeftAndTop(PRInt32* left, PRInt32* top);
    1:   static PRBool CanSetProperty(const char *aPrefName);
    1: 
    1:   static void MakeScriptDialogTitle(nsAString &aOutTitle);
    1: 
13308:   static PRBool CanMoveResizeWindows();
13308: 
    1:   PRBool   GetBlurSuppression();
    1: 
    1:   // If aDoFlush is true, we'll flush our own layout; otherwise we'll try to
    1:   // just flush our parent and only flush ourselves if we think we need to.
    1:   nsresult GetScrollXY(PRInt32* aScrollX, PRInt32* aScrollY,
    1:                        PRBool aDoFlush);
    1:   nsresult GetScrollMaxXY(PRInt32* aScrollMaxX, PRInt32* aScrollMaxY);
    1:   
13806:   nsresult GetOuterSize(nsIntSize* aSizeCSSPixels);
13806:   nsresult SetOuterSize(PRInt32 aLengthCSSPixels, PRBool aIsWidth);
30882:   nsRect GetInnerScreenRect();
13806: 
    1:   PRBool IsFrame()
    1:   {
    1:     return GetParentInternal() != nsnull;
    1:   }
    1: 
    1:   PRBool DispatchCustomEvent(const char *aEventName);
    1: 
    1:   // If aLookForCallerOnJSStack is true, this method will look at the JS stack
    1:   // to determine who the caller is.  If it's false, it'll use |this| as the
    1:   // caller.
    1:   PRBool WindowExists(const nsAString& aName, PRBool aLookForCallerOnJSStack);
    1: 
    1:   already_AddRefed<nsIWidget> GetMainWidget();
30327:   nsIWidget* GetNearestWidget();
    1: 
    1:   void Freeze()
    1:   {
    1:     NS_ASSERTION(!IsFrozen(), "Double-freezing?");
    1:     mIsFrozen = PR_TRUE;
    1:   }
    1: 
    1:   void Thaw()
    1:   {
    1:     mIsFrozen = PR_FALSE;
    1:   }
    1: 
    1:   PRBool IsInModalState();
    1: 
    1:   nsTimeout* FirstTimeout() {
    1:     // Note: might not actually return an nsTimeout.  Use IsTimeout to check.
 3233:     return static_cast<nsTimeout*>(PR_LIST_HEAD(&mTimeouts));
    1:   }
    1: 
    1:   nsTimeout* LastTimeout() {
    1:     // Note: might not actually return an nsTimeout.  Use IsTimeout to check.
 3233:     return static_cast<nsTimeout*>(PR_LIST_TAIL(&mTimeouts));
    1:   }
    1: 
    1:   PRBool IsTimeout(PRCList* aList) {
    1:     return aList != &mTimeouts;
    1:   }
    1: 
24816:   // Convenience functions for the many methods that need to scale
24816:   // from device to CSS pixels or vice versa.  Note: if a presentation
24816:   // context is not available, they will assume a 1:1 ratio.
24816:   PRInt32 DevToCSSIntPixels(PRInt32 px);
24816:   PRInt32 CSSToDevIntPixels(PRInt32 px);
24816:   nsIntSize DevToCSSIntPixels(nsIntSize px);
24816:   nsIntSize CSSToDevIntPixels(nsIntSize px);
24816: 
29018:   virtual nsIContent* GetFocusedNode();
29018:   virtual void SetFocusedNode(nsIContent* aNode,
29018:                               PRUint32 aFocusMethod = 0,
29018:                               PRBool aNeedsFocus = PR_FALSE);
29018: 
29018:   virtual PRUint32 GetFocusMethod();
29018: 
29018:   void UpdateCanvasFocus(PRBool aFocusChanged, nsIContent* aNewContent);
29018: 
38336:   already_AddRefed<nsPIWindowRoot> GetTopWindowRoot();
38336: 
11693:   static void NotifyDOMWindowDestroyed(nsGlobalWindow* aWindow);
11693: 
    1:   // When adding new member variables, be careful not to create cycles
    1:   // through JavaScript.  If there is any chance that a member variable
    1:   // could own objects that are implemented in JavaScript, then those
    1:   // objects will keep the global object (this object) alive.  To prevent
    1:   // these cycles, ownership of such members must be released in
    1:   // |CleanUp| and |SetDocShell|.
    1: 
    1:   // This member is also used on both inner and outer windows, but
    1:   // for slightly different purposes. On inner windows it means the
    1:   // inner window is held onto by session history and should not
    1:   // change. On outer windows it means that the window is in a state
    1:   // where we don't want to force creation of a new inner window since
    1:   // we're in the middle of doing just that.
    1:   PRPackedBool                  mIsFrozen : 1;
    1: 
 6774:   // True if the Java properties have been initialized on this
 6774:   // window. Only used on inner windows.
 6774:   PRPackedBool                  mDidInitJavaProperties : 1;
 6774:   
    1:   // These members are only used on outer window objects. Make sure
    1:   // you never set any of these on an inner object!
30004:   PRPackedBool                  mFullScreen : 1;
    1:   PRPackedBool                  mIsClosed : 1;
    1:   PRPackedBool                  mInClose : 1;
    1:   // mHavePendingClose means we've got a termination function set to
    1:   // close us when the JS stops executing or that we have a close
    1:   // event posted.  If this is set, just ignore window.close() calls.
    1:   PRPackedBool                  mHavePendingClose : 1;
    1:   PRPackedBool                  mHadOriginalOpener : 1;
    1:   PRPackedBool                  mIsPopupSpam : 1;
    1: 
    1:   // Indicates whether scripts are allowed to close this window.
    1:   PRPackedBool                  mBlockScriptedClosingFlag : 1;
    1: 
    1:   // Track what sorts of events we need to fire when thawed
    1:   PRPackedBool                  mFireOfflineStatusChangeEventOnThaw : 1;
    1: 
    1:   // Indicates whether we're in the middle of creating an initializing
    1:   // a new inner window object.
    1:   PRPackedBool                  mCreatingInnerWindow : 1;
    1: 
 4209:   // Fast way to tell if this is a chrome window (without having to QI).
 4209:   PRPackedBool                  mIsChrome : 1;
 4209: 
29018:   // Indicates that the current document has never received a document focus
29018:   // event.
29018:   PRPackedBool           mNeedsFocus : 1;
29018:   PRPackedBool           mHasFocus : 1;
29018: 
31738:   // Indicates whether this window is getting acceleration change events
31738:   PRPackedBool           mHasAcceleration  : 1;
31738: 
    1:   nsCOMPtr<nsIScriptContext>    mContext;
11416:   nsWeakPtr                     mOpener;
    1:   nsCOMPtr<nsIControllers>      mControllers;
    1:   nsCOMPtr<nsIArray>            mArguments;
    1:   nsCOMPtr<nsIArray>            mArgumentsLast;
33525:   nsCOMPtr<nsIPrincipal>        mArgumentsOrigin;
    1:   nsRefPtr<nsNavigator>         mNavigator;
    1:   nsRefPtr<nsScreen>            mScreen;
    1:   nsRefPtr<nsHistory>           mHistory;
    1:   nsRefPtr<nsDOMWindowList>     mFrames;
    1:   nsRefPtr<nsBarProp>           mMenubar;
    1:   nsRefPtr<nsBarProp>           mToolbar;
    1:   nsRefPtr<nsBarProp>           mLocationbar;
    1:   nsRefPtr<nsBarProp>           mPersonalbar;
    1:   nsRefPtr<nsBarProp>           mStatusbar;
    1:   nsRefPtr<nsBarProp>           mScrollbars;
    1:   nsCOMPtr<nsIWeakReference>    mWindowUtils;
    1:   nsRefPtr<nsLocation>          mLocation;
    1:   nsString                      mStatus;
    1:   nsString                      mDefaultStatus;
    1:   // index 0->language_id 1, so index MAX-1 == language_id MAX
    1:   nsCOMPtr<nsIScriptContext>    mScriptContexts[NS_STID_ARRAY_UBOUND];
    1:   void *                        mScriptGlobals[NS_STID_ARRAY_UBOUND];
    1:   nsGlobalWindowObserver*       mObserver;
    1: 
    1:   nsCOMPtr<nsIDOMCrypto>        mCrypto;
    1: 
28438:   nsCOMPtr<nsIDOMStorage>      mLocalStorage;
37608:   nsCOMPtr<nsIDOMStorage>      mSessionStorage;
26323: 
    1:   nsCOMPtr<nsISupports>         mInnerWindowHolders[NS_STID_ARRAY_UBOUND];
    1:   nsCOMPtr<nsIPrincipal> mOpenerScriptPrincipal; // strong; used to determine
    1:                                                  // whether to clear scope
    1: 
    1:   // These member variable are used only on inner windows.
    1:   nsCOMPtr<nsIEventListenerManager> mListenerManager;
    1:   PRCList                       mTimeouts;
    1:   // If mTimeoutInsertionPoint is non-null, insertions should happen after it.
    1:   nsTimeout*                    mTimeoutInsertionPoint;
    1:   PRUint32                      mTimeoutPublicIdCounter;
    1:   PRUint32                      mTimeoutFiringDepth;
    1: 
15819:   // Holder of the dummy java plugin, used to expose window.java and
15819:   // window.packages.
 6774:   nsRefPtr<nsDummyJavaPluginOwner> mDummyJavaPluginOwner;
 6774: 
    1:   // These member variables are used on both inner and the outer windows.
    1:   nsCOMPtr<nsIPrincipal> mDocumentPrincipal;
    1:   nsCOMPtr<nsIDocument> mDoc;  // For fast access to principals
    1:   JSObject* mJSObject;
    1: 
37608:   typedef nsTArray<nsCOMPtr<nsIDOMStorageEvent> > nsDOMStorageEventArray;
37608:   nsDOMStorageEventArray mPendingStorageEvents;
37608:   nsDataHashtable<nsStringHashKey, PRBool> *mPendingStorageEventsObsolete;
    1: 
25074:   PRUint32 mTimeoutsSuspendDepth;
25074: 
29018:   // the element within the document that is currently focused when this
29018:   // window is active
29018:   nsCOMPtr<nsIContent>   mFocusedNode;
29018: 
29018:   // the method that was used to focus mFocusedNode
29018:   PRUint32 mFocusMethod;
29018: 
    1: #ifdef DEBUG
    1:   PRBool mSetOpenerWindowCalled;
11693:   PRUint32 mSerial;
14743:   nsCOMPtr<nsIURI> mLastOpenedURI;
    1: #endif
    1: 
39378:   PRBool mCleanedUp, mCallCleanUpAfterModalDialogCloses;
39378: 
10340:   nsCOMPtr<nsIDOMOfflineResourceList> mApplicationCache;
10340: 
11622:   nsDataHashtable<nsVoidPtrHashKey, void*> mCachedXBLPrototypeHandlers;
11622: 
25722:   nsCOMPtr<nsIDocument> mSuspendedDoc;
25722: 
    1:   friend class nsDOMScriptableHelper;
    1:   friend class nsDOMWindowUtils;
14898:   friend class PostMessageEvent;
22689:   static nsIDOMStorageList* sGlobalStorageList;
    1: };
    1: 
    1: /*
    1:  * nsGlobalChromeWindow inherits from nsGlobalWindow. It is the global
    1:  * object created for a Chrome Window only.
    1:  */
    1: class nsGlobalChromeWindow : public nsGlobalWindow,
    1:                              public nsIDOMChromeWindow
    1: {
    1: public:
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   // nsIDOMChromeWindow interface
    1:   NS_DECL_NSIDOMCHROMEWINDOW
    1: 
    1:   nsGlobalChromeWindow(nsGlobalWindow *aOuterWindow)
    1:     : nsGlobalWindow(aOuterWindow)
    1:   {
 4209:     mIsChrome = PR_TRUE;
    1:   }
    1: 
    1:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(nsGlobalChromeWindow,
    1:                                                      nsGlobalWindow)
    1: 
    1: protected:
    1:   nsCOMPtr<nsIBrowserDOMWindow> mBrowserDOMWindow;
    1: };
    1: 
 4040: /*
 4040:  * nsGlobalModalWindow inherits from nsGlobalWindow. It is the global
 4040:  * object created for a modal content windows only (i.e. not modal
 4040:  * chrome dialogs).
 4040:  */
 4040: class nsGlobalModalWindow : public nsGlobalWindow,
 4040:                             public nsIDOMModalContentWindow
 4040: {
 4040: public:
 4040:   nsGlobalModalWindow(nsGlobalWindow *aOuterWindow)
 4040:     : nsGlobalWindow(aOuterWindow)
 4040:   {
 4040:     mIsModalContentWindow = PR_TRUE;
 4040:   }
 4040: 
 4040:   NS_DECL_ISUPPORTS_INHERITED
 4040:   NS_DECL_NSIDOMMODALCONTENTWINDOW
 4040: 
 4040:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsGlobalModalWindow, nsGlobalWindow)
 4040: 
33525:   virtual NS_HIDDEN_(nsresult) SetNewDocument(nsIDocument *aDocument,
39376:                                               nsISupports *aState);
33525: 
 4040: protected:
 4040:   nsCOMPtr<nsIVariant> mReturnValue;
 4040: };
 4040: 
 4040: 
    1: //*****************************************************************************
    1: // nsNavigator: Script "navigator" object
    1: //*****************************************************************************
    1: 
    1: class nsNavigator : public nsIDOMNavigator,
    1:                     public nsIDOMJSNavigator,
15958:                     public nsIDOMClientInformation,
16677:                     public nsIDOMNavigatorGeolocation
    1: {
    1: public:
    1:   nsNavigator(nsIDocShell *aDocShell);
    1:   virtual ~nsNavigator();
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIDOMNAVIGATOR
    1:   NS_DECL_NSIDOMJSNAVIGATOR
    1:   NS_DECL_NSIDOMCLIENTINFORMATION
16677:   NS_DECL_NSIDOMNAVIGATORGEOLOCATION
    1:   
    1:   void SetDocShell(nsIDocShell *aDocShell);
    1:   nsIDocShell *GetDocShell()
    1:   {
    1:     return mDocShell;
    1:   }
    1: 
    1:   void LoadingNewDocument();
    1:   nsresult RefreshMIMEArray();
    1: 
    1: protected:
    1:   nsRefPtr<nsMimeTypeArray> mMimeTypes;
    1:   nsRefPtr<nsPluginArray> mPlugins;
16677:   nsRefPtr<nsGeolocation> mGeolocation;
    1:   nsIDocShell* mDocShell; // weak reference
    1: 
    1:   static jsval       sPrefInternal_id;
    1: };
    1: 
    1: class nsIURI;
    1: 
    1: //*****************************************************************************
    1: // nsLocation: Script "location" object
    1: //*****************************************************************************
    1: 
18869: class nsLocation : public nsIDOMLocation
    1: {
    1: public:
    1:   nsLocation(nsIDocShell *aDocShell);
    1:   virtual ~nsLocation();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   void SetDocShell(nsIDocShell *aDocShell);
    1:   nsIDocShell *GetDocShell();
    1: 
    1:   // nsIDOMLocation
    1:   NS_DECL_NSIDOMLOCATION
    1: 
    1: protected:
    1:   // In the case of jar: uris, we sometimes want the place the jar was
    1:   // fetched from as the URI instead of the jar: uri itself.  Pass in
    1:   // PR_TRUE for aGetInnermostURI when that's the case.
    1:   nsresult GetURI(nsIURI** aURL, PRBool aGetInnermostURI = PR_FALSE);
    1:   nsresult GetWritableURI(nsIURI** aURL);
    1:   nsresult SetURI(nsIURI* aURL, PRBool aReplace = PR_FALSE);
    1:   nsresult SetHrefWithBase(const nsAString& aHref, nsIURI* aBase,
    1:                            PRBool aReplace);
    1:   nsresult SetHrefWithContext(JSContext* cx, const nsAString& aHref,
    1:                               PRBool aReplace);
    1: 
    1:   nsresult GetSourceBaseURL(JSContext* cx, nsIURI** sourceURL);
    1:   nsresult GetSourceDocument(JSContext* cx, nsIDocument** aDocument);
    1: 
    1:   nsresult CheckURL(nsIURI *url, nsIDocShellLoadInfo** aLoadInfo);
    1: 
    1:   nsWeakPtr mDocShell;
    1: };
    1: 
    1: /* factory function */
 4040: nsresult
 4040: NS_NewScriptGlobalObject(PRBool aIsChrome, PRBool aIsModalContentWindow,
    1:                          nsIScriptGlobalObject **aResult);
    1: 
    1: #endif /* nsGlobalWindow_h___ */
