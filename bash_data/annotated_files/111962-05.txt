111673: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
111673:  * vim: set ts=4 sw=4 et tw=79:
111673:  *
111673:  * ***** BEGIN LICENSE BLOCK *****
111673:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
111673:  *
111673:  * The contents of this file are subject to the Mozilla Public License Version
111673:  * 1.1 (the "License"); you may not use this file except in compliance with
111673:  * the License. You may obtain a copy of the License at
111673:  * http://www.mozilla.org/MPL/
111673:  *
111673:  * Software distributed under the License is distributed on an "AS IS" basis,
111673:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
111673:  * for the specific language governing rights and limitations under the
111673:  * License.
111673:  *
111673:  * The Original Code is Mozilla Communicator client code, released
111673:  * March 31, 1998.
111673:  *
111673:  * The Initial Developer of the Original Code is
111673:  * Netscape Communications Corporation.
111673:  * Portions created by the Initial Developer are Copyright (C) 1998
111673:  * the Initial Developer. All Rights Reserved.
111673:  *
111673:  * Contributor(s):
111673:  *   David Anderson <danderson@mozilla.com>
111673:  *
111673:  * Alternatively, the contents of this file may be used under the terms of
111673:  * either of the GNU General Public License Version 2 or later (the "GPL"),
111673:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
111673:  * in which case the provisions of the GPL or the LGPL are applicable instead
111673:  * of those above. If you wish to allow use of your version of this file only
111673:  * under the terms of either the GPL or the LGPL, and not to allow others to
111673:  * use your version of this file under the terms of the MPL, indicate your
111673:  * decision by deleting the provisions above and replace them with the notice
111673:  * and other provisions required by the GPL or the LGPL. If you do not delete
111673:  * the provisions above, a recipient may use your version of this file under
111673:  * the terms of any one of the MPL, the GPL or the LGPL.
111673:  *
111673:  * ***** END LICENSE BLOCK ***** */
111673: 
111706: #include "IonLIR.h"
111961: #include "Lowering.h"
111706: #include "MIR.h"
111673: #include "MIRGraph.h"
111768: #include "jsbool.h"
111962: #include "shared/Lowering-shared-inl.h"
111673: 
111673: using namespace js;
111706: using namespace ion;
111673: 
111673: bool
111706: LIRGenerator::visitParameter(MParameter *param)
111706: {
111706:     ptrdiff_t offset;
111934:     if (param->index() == -1)
111771:         offset = THIS_FRAME_SLOT;
111706:     else
111934:         offset = 1 + param->index();
111706: 
111706:     LParameter *ins = new LParameter;
111706:     if (!defineBox(ins, param, LDefinition::PRESET))
111706:         return false;
111706: 
111771:     offset *= sizeof(Value);
111706: #if defined(JS_NUNBOX32)
111706: # if defined(IS_BIG_ENDIAN)
111706:     ins->getDef(0)->setOutput(LArgument(offset));
111771:     ins->getDef(1)->setOutput(LArgument(offset + 4));
111706: # else
111771:     ins->getDef(0)->setOutput(LArgument(offset + 4));
111706:     ins->getDef(1)->setOutput(LArgument(offset));
111706: # endif
111706: #elif defined(JS_PUNBOX64)
111706:     ins->getDef(0)->setOutput(LArgument(offset));
111706: #endif
111706: 
111706:     return true;
111706: }
111706: 
111706: bool
111929: LIRGenerator::visitTableSwitch(MTableSwitch *tableswitch)
111929: {
111929:     MDefinition *opd = tableswitch->getOperand(0);
111929: 
111929:     // There should be at least 1 successor. The default case!
111929:     JS_ASSERT(tableswitch->numSuccessors() > 0);
111929: 
111929:     // If there are no cases, the default case is always taken. 
111929:     if (tableswitch->numSuccessors() == 1)
111929:         return add(new LGoto(tableswitch->getDefault()));        
111929: 
111929:     // Case indices are int32, so other types will always go to the default case
111929:     if (opd->type() != MIRType_Int32)
111929:         return add(new LGoto(tableswitch->getDefault()));
111929: 
111929:     // If input of switch is constant, it will always take the same case/default.
111929:     if (opd->isConstant()) {
111929:         MConstant *ins = opd->toConstant();
111929: 
111929:         int32 switchval = ins->value().toInt32();
111929:         if (switchval < tableswitch->low() || switchval > tableswitch->high())
111929:             return add(new LGoto(tableswitch->getDefault()));
111929: 
111929:         return add(new LGoto(tableswitch->getCase(switchval-tableswitch->low())));
111929:     }
111929: 
111929:     // Return a LTableS witch if it isn't constant.
111929:     return add(new LTableSwitch(useRegister(opd), temp(LDefinition::INTEGER),
111929:                                 temp(LDefinition::POINTER), tableswitch));
111929: }
111929: 
111929: bool
111706: LIRGenerator::visitGoto(MGoto *ins)
111706: {
111708:     return add(new LGoto(ins->target()));
111706: }
111706: 
111706: bool
111721: LIRGenerator::visitTest(MTest *test)
111706: {
111795:     MDefinition *opd = test->getOperand(0);
111721:     MBasicBlock *ifTrue = test->ifTrue();
111721:     MBasicBlock *ifFalse = test->ifFalse();
111721: 
111768:     if (opd->isConstant()) {
111768:         MConstant *ins = opd->toConstant();
111768:         JSBool truthy = js_ValueToBoolean(ins->value());
111768:         MBasicBlock *target = truthy ? ifTrue : ifFalse;
111768:         return add(new LGoto(target));
111768:     }
111768: 
111721:     if (opd->type() == MIRType_Value) {
111721:         LTestVAndBranch *lir = new LTestVAndBranch(ifTrue, ifFalse);
111721:         if (!fillBoxUses(lir, 0, opd))
111721:             return false;
111721:         return add(lir);
111721:     }
111721: 
111721:     // These must be explicitly sniffed out since they are constants and have
111721:     // no payload.
111721:     if (opd->type() == MIRType_Undefined || opd->type() == MIRType_Null)
111721:         return add(new LGoto(ifFalse));
111721: 
111721:     if (opd->type() == MIRType_Double)
111721:         return add(new LTestDAndBranch(useRegister(opd), temp(LDefinition::DOUBLE), ifTrue, ifFalse));
111721: 
111721:     return add(new LTestIAndBranch(useRegister(opd), ifTrue, ifFalse));
111706: }
111706: 
111715: static void
111795: ReorderCommutative(MDefinition **lhsp, MDefinition **rhsp)
111715: {
111795:     MDefinition *lhs = *lhsp;
111795:     MDefinition *rhs = *rhsp;
111715: 
111715:     // Put the constant in the left-hand side, if there is one.
111715:     if (lhs->isConstant()) {
111715:         *rhsp = lhs;
111715:         *lhsp = rhs;
111715:     }
111715: }
111715: 
111715: bool
111962: LIRGenerator::lowerBitOp(JSOp op, MInstruction *ins)
111715: {
111795:     MDefinition *lhs = ins->getOperand(0);
111795:     MDefinition *rhs = ins->getOperand(1);
111715: 
111715:     if (lhs->type() == MIRType_Int32 && rhs->type() == MIRType_Int32) {
111715:         ReorderCommutative(&lhs, &rhs);
111962:         return lowerForALU(new LBitOp(op), ins, lhs, rhs);
111715:     }
111715: 
111715:     JS_NOT_REACHED("NYI");
111715:     return false;
111715: }
111715: 
111706: bool
111706: LIRGenerator::visitBitAnd(MBitAnd *ins)
111706: {
111962:     return lowerBitOp(JSOP_BITAND, ins);
111780: }
111780: 
111780: bool
111780: LIRGenerator::visitBitOr(MBitOr *ins)
111780: {
111962:     return lowerBitOp(JSOP_BITOR, ins);
111780: }
111780: 
111780: bool
111798: LIRGenerator::visitBitXor(MBitXor *ins)
111780: {
111962:     return lowerBitOp(JSOP_BITXOR, ins);
111715: }
111715: 
111715: bool
111715: LIRGenerator::visitAdd(MAdd *ins)
111715: {
111795:     MDefinition *lhs = ins->getOperand(0);
111795:     MDefinition *rhs = ins->getOperand(1);
111722: 
111920:     JS_ASSERT(lhs->type() == rhs->type());
111920: 
111920:     if (ins->specialization() == MIRType_Int32) {
111920:         JS_ASSERT(lhs->type() == MIRType_Int32);
111722:         ReorderCommutative(&lhs, &rhs);
111722:         return lowerForALU(new LAddI, ins, lhs, rhs);
111722:     }
111920:     if (ins->specialization() == MIRType_Double) {
111920:         JS_ASSERT(lhs->type() == MIRType_Double);
111920:         return lowerForFPU(new LMathD(JSOP_ADD), ins, lhs, rhs);
111920:     }
111722: 
111722:     JS_NOT_REACHED("NYI");
111722:     return false;
111706: }
111706: 
111706: bool
111715: LIRGenerator::visitStart(MStart *start)
111706: {
111715:     // This is a no-op.
111706:     return true;
111706: }
111706: 
111706: bool
111802: LIRGenerator::visitToDouble(MToDouble *convert)
111802: {
111802:     JS_NOT_REACHED("NYI");
111802:     return false;
111802: }
111802: 
111802: bool
111802: LIRGenerator::visitToInt32(MToInt32 *convert)
111802: {
111802:     JS_NOT_REACHED("NYI");
111802:     return false;
111802: }
111802: 
111802: bool
111802: LIRGenerator::visitTruncateToInt32(MTruncateToInt32 *truncate)
111800: {
111800:     JS_NOT_REACHED("NYI");
111800:     return false;
111800: }
111800: 
111800: bool
111706: LIRGenerator::visitCopy(MCopy *ins)
111706: {
111706:     JS_NOT_REACHED("unexpected copy");
111706:     return false;
111706: }
111706: 
111706: bool
111730: LIRGenerator::visitInstruction(MInstruction *ins)
111730: {
111730:     if (!gen->ensureBallast())
111730:         return false;
111730:     if (!ins->accept(this))
111730:         return false;
111797:     if (ins->snapshot())
111797:         last_snapshot_ = ins->snapshot();
111730:     if (gen->errored())
111730:         return false;
111730: #ifdef DEBUG
111730:     ins->setInWorklistUnchecked();
111730: #endif
111730:     return true;
111730: }
111730: 
111730: bool
111706: LIRGenerator::visitBlock(MBasicBlock *block)
111706: {
111706:     current = LBlock::New(block);
111706:     if (!current)
111706:         return false;
111706: 
111711:     last_snapshot_ = block->entrySnapshot();
111711: 
111897:     for (MPhiIterator phi(block->phisBegin()); phi != block->phisEnd(); phi++) {
111706:         if (!gen->ensureBallast())
111706:             return false;
111897:         if (!preparePhi(*phi))
111706:             return false;
111720: #ifdef DEBUG
111897:         phi->setInWorklist();
111720: #endif
111706:     }
111706: 
111730:     for (MInstructionIterator iter = block->begin(); *iter != block->lastIns(); iter++) {
111730:         if (!visitInstruction(*iter))
111706:             return false;
111720:     }
111720: 
111720:     // For each successor, make sure we've assigned a virtual register to any
111720:     // phi inputs that emit at uses.
111720:     if (block->successorWithPhis()) {
111720:         MBasicBlock *successor = block->successorWithPhis();
111720:         uint32 position = block->positionInPhiSuccessor();
111897:         for (MPhiIterator phi(successor->phisBegin()); phi != successor->phisEnd(); phi++) {
111795:             MDefinition *opd = phi->getOperand(position);
111838:             if (opd->isEmittedAtUses() && !opd->id()) {
111720:                 if (!ensureDefined(opd))
111720:                     return false;
111720:             }
111720:         }
111706:     }
111706: 
111730:     // Now emit the last instruction, which is some form of branch.
111730:     if (!visitInstruction(block->lastIns()))
111730:         return false;
111730: 
111732:     if (!lirGraph_.addBlock(current))
111732:         return false;
111706:     block->assignLir(current);
111706:     return true;
111706: }
111706: 
111706: bool
111706: LIRGenerator::generate()
111673: {
111900:     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); block++) {
111900:         if (!visitBlock(*block))
111673:             return false;
111673:     }
111720: 
111720:     // Emit phis now that all their inputs have definitions.
111900:     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); block++) {
111720:         current = block->lir();
111897:         for (MPhiIterator phi(block->phisBegin()); phi != block->phisEnd(); phi++) {
111897:             if (!lowerPhi(*phi))
111720:                 return false;
111720:         }
111720:     }
111720: 
111673:     return true;
111673: }
111673: 
