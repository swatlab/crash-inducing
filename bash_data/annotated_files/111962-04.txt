111706: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
111706:  * vim: set ts=4 sw=4 et tw=79:
111706:  *
111706:  * ***** BEGIN LICENSE BLOCK *****
111706:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
111706:  *
111706:  * The contents of this file are subject to the Mozilla Public License Version
111706:  * 1.1 (the "License"); you may not use this file except in compliance with
111706:  * the License. You may obtain a copy of the License at
111706:  * http://www.mozilla.org/MPL/
111706:  *
111706:  * Software distributed under the License is distributed on an "AS IS" basis,
111706:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
111706:  * for the specific language governing rights and limitations under the
111706:  * License.
111706:  *
111706:  * The Original Code is Mozilla Communicator client code, released
111706:  * March 31, 1998.
111706:  *
111706:  * The Initial Developer of the Original Code is
111706:  * Netscape Communications Corporation.
111706:  * Portions created by the Initial Developer are Copyright (C) 1998
111706:  * the Initial Developer. All Rights Reserved.
111706:  *
111706:  * Contributor(s):
111706:  *   David Anderson <danderson@mozilla.com>
111706:  *
111706:  * Alternatively, the contents of this file may be used under the terms of
111706:  * either of the GNU General Public License Version 2 or later (the "GPL"),
111706:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
111706:  * in which case the provisions of the GPL or the LGPL are applicable instead
111706:  * of those above. If you wish to allow use of your version of this file only
111706:  * under the terms of either the GPL or the LGPL, and not to allow others to
111706:  * use your version of this file under the terms of the MPL, indicate your
111706:  * decision by deleting the provisions above and replace them with the notice
111706:  * and other provisions required by the GPL or the LGPL. If you do not delete
111706:  * the provisions above, a recipient may use your version of this file under
111706:  * the terms of any one of the MPL, the GPL or the LGPL.
111706:  *
111706:  * ***** END LICENSE BLOCK ***** */
111706: 
111706: #ifndef jsion_lir_common_h__
111706: #define jsion_lir_common_h__
111706: 
111768: #include "ion/shared/Assembler-shared.h"
111768: 
111706: // This file declares LIR instructions that are common to every platform.
111706: 
111706: namespace js {
111706: namespace ion {
111706: 
111785: class LMove
111724: {
111785:     LAllocation *from_;
111785:     LAllocation *to_;
111770: 
111724:   public:
111785:     LMove(LAllocation *from, LAllocation *to)
111770:       : from_(from),
111770:         to_(to)
111770:     { }
111770: 
111785:     LAllocation *from() {
111785:         return from_;
111770:     }
111785:     const LAllocation *from() const {
111785:         return from_;
111785:     }
111785:     LAllocation *to() {
111785:         return to_;
111785:     }
111785:     const LAllocation *to() const {
111785:         return to_;
111785:     }
111785: };
111785: 
111785: class LMoveGroup : public LInstructionHelper<0, 0, 0>
111785: {
111785:     js::Vector<LMove, 2, IonAllocPolicy> moves_;
111785: 
111785:   public:
111785:     LIR_HEADER(MoveGroup);
111785: 
111785:     void printOperands(FILE *fp);
111785:     bool add(LAllocation *from, LAllocation *to) {
111872:         JS_ASSERT(*from != *to);
111785:         return moves_.append(LMove(from, to));
111785:     }
111785:     size_t numMoves() const {
111785:         return moves_.length();
111785:     }
111785:     const LMove &getMove(size_t i) const {
111785:         return moves_[i];
111785:     }
111724: };
111724: 
111706: // Constant 32-bit integer.
111706: class LInteger : public LInstructionHelper<1, 0, 0>
111706: {
111706:     int32 i32_;
111706: 
111706:   public:
111706:     LIR_HEADER(Integer);
111706: 
111706:     LInteger(int32 i32) : i32_(i32)
111706:     { }
111852: 
111852:     int32 getValue() const {
111852:         return i32_;
111852:     }
111706: };
111706: 
111706: // Constant 64-bit pointer.
111706: class LPointer : public LInstructionHelper<1, 0, 0>
111706: {
111706:     void *ptr_;
111706: 
111706:   public:
111706:     LIR_HEADER(Pointer);
111706: 
111706:     LPointer(void *ptr) : ptr_(ptr)
111706:     { }
111706: };
111706: 
111768: // A constant Value.
111768: class LValue : public LInstructionHelper<BOX_PIECES, 0, 0>
111768: {
111768:     Value v_;
111768: 
111768:   public:
111768:     LIR_HEADER(Value);
111768: 
111768:     LValue(const Value &v) : v_(v)
111768:     { }
111768: 
111768:     Value value() const {
111768:         return v_;
111768:     }
111768: };
111768: 
111706: // Formal argument for a function, returning a box. Formal arguments are
111706: // initially read from the stack.
111706: class LParameter : public LInstructionHelper<BOX_PIECES, 0, 0>
111706: {
111706:   public:
111706:     LIR_HEADER(Parameter);
111706: };
111706: 
111708: // Jumps to the start of a basic block.
111706: class LGoto : public LInstructionHelper<0, 0, 0>
111706: {
111708:     MBasicBlock *block_;
111708: 
111708:   public:
111708:     LIR_HEADER(Goto);
111708: 
111708:     LGoto(MBasicBlock *block)
111708:       : block_(block)
111708:     { }
111768: 
111768:     MBasicBlock *target() const {
111768:         return block_;
111768:     }
111706: };
111706: 
111929: // Takes a tableswitch with an integer to decide
111929: class LTableSwitch : public LInstructionHelper<0, 1, 2>
111929: {
111929:     MTableSwitch *mir_;
111929: 
111929:   public:
111929:     LIR_HEADER(TableSwitch);
111929: 
111929:     LTableSwitch(const LAllocation &in, const LDefinition &inputCopy,
111929:                  const LDefinition &jumpTablePointer, MTableSwitch *mir)
111929:       : mir_(mir)
111929:     {
111929:         setOperand(0, in);
111929:         setTemp(0, inputCopy);
111929:         setTemp(1, jumpTablePointer);
111929:     }
111929: 
111929:     MTableSwitch *mir() const {
111929:         return mir_;
111929:     }
111929: };
111929: 
111721: // Takes in either an integer or boolean input and tests it for truthiness.
111721: class LTestIAndBranch : public LInstructionHelper<0, 1, 0>
111706: {
111914:     MBasicBlock *ifTrue_;
111914:     MBasicBlock *ifFalse_;
111721: 
111721:   public:
111721:     LIR_HEADER(TestIAndBranch);
111721: 
111721:     LTestIAndBranch(const LAllocation &in, MBasicBlock *ifTrue, MBasicBlock *ifFalse)
111914:       : ifTrue_(ifTrue),
111914:         ifFalse_(ifFalse)
111721:     {
111721:         setOperand(0, in);
111721:     }
111914: 
111914:     MBasicBlock *ifTrue() const {
111914:         return ifTrue_;
111914:     }
111914:     MBasicBlock *ifFalse() const {
111914:         return ifFalse_;
111914:     }
111721: };
111721: 
111721: // Takes in either an integer or boolean input and tests it for truthiness.
111721: class LTestDAndBranch : public LInstructionHelper<0, 1, 1>
111721: {
111721:     MBasicBlock *ifTrue;
111721:     MBasicBlock *ifFalse;
111721: 
111721:   public:
111721:     LIR_HEADER(TestDAndBranch);
111721: 
111721:     LTestDAndBranch(const LAllocation &in, const LDefinition &temp,
111721:                     MBasicBlock *ifTrue, MBasicBlock *ifFalse)
111721:       : ifTrue(ifTrue),
111721:         ifFalse(ifFalse)
111721:     {
111721:         setOperand(0, in);
111721:         setTemp(0, temp);
111721:     }
111721: };
111721: 
111721: // Takes in a boxed value and tests it for truthiness.
111721: class LTestVAndBranch : public LInstructionHelper<0, BOX_PIECES, 0>
111721: {
111721:     MBasicBlock *ifTrue;
111721:     MBasicBlock *ifFalse;
111721: 
111721:   public:
111721:     LIR_HEADER(TestVAndBranch);
111721: 
111721:     LTestVAndBranch(MBasicBlock *ifTrue, MBasicBlock *ifFalse)
111721:       : ifTrue(ifTrue),
111721:         ifFalse(ifFalse)
111721:     { }
111706: };
111706: 
111706: // Binary bitwise operation, taking two 32-bit integers as inputs and returning
111706: // a 32-bit integer result as an output.
111706: class LBitOp : public LInstructionHelper<1, 2, 0>
111706: {
111706:     JSOp op_;
111706: 
111706:   public:
111715:     LIR_HEADER(BitOp);
111715: 
111962:     LBitOp(JSOp op)
111706:       : op_(op)
111962:     { }
111780: 
111780:     JSOp bitop() {
111780:         return op_;
111780:     }
111706: };
111706: 
111706: // Returns from the function being compiled (not used in inlined frames). The
111706: // input must be a box.
111706: class LReturn : public LInstructionHelper<0, BOX_PIECES, 0>
111706: {
111706:   public:
111706:     LIR_HEADER(Return);
111706: };
111706: 
111722: // Adds two integers, returning an integer value.
111722: class LAddI : public LInstructionHelper<1, 2, 0>
111722: {
111722:   public:
111722:     LIR_HEADER(AddI);
111722: };
111722: 
111920: // Performs an add, sub, mul, or div on two double values.
111920: class LMathD : public LInstructionHelper<1, 2, 0>
111920: {
111920:     JSOp jsop_;
111920: 
111920:   public:
111920:     LIR_HEADER(MathD);
111920: 
111920:     LMathD(JSOp jsop)
111920:       : jsop_(jsop)
111920:     { }
111920: 
111920:     JSOp jsop() const {
111920:         return jsop_;
111920:     }
111920: };
111920: 
111720: class MPhi;
111720: 
111720: // Phi is a pseudo-instruction that emits no code, and is an annotation for the
111720: // register allocator. Like its equivalent in MIR, phis are collected at the
111720: // top of blocks and are meant to be executed in parallel, choosing the input
111720: // corresponding to the predecessor taken in the control flow graph.
111720: class LPhi : public LInstruction
111720: {
111720:     uint32 numInputs_;
111720:     LAllocation *inputs_;
111720:     LDefinition def_;
111720: 
111720:     bool init(MIRGenerator *gen);
111720: 
111720:     LPhi(uint32 numInputs)
111720:       : numInputs_(numInputs)
111720:     { }
111720: 
111720:   public:
111720:     LIR_HEADER(Phi);
111720: 
111720:     static LPhi *New(MIRGenerator *gen, MPhi *phi);
111720: 
111720:     size_t numDefs() const {
111720:         return 1;
111720:     }
111720:     LDefinition *getDef(size_t index) {
111720:         JS_ASSERT(index == 0);
111720:         return &def_;
111720:     }
111720:     void setDef(size_t index, const LDefinition &def) {
111720:         JS_ASSERT(index == 0);
111720:         def_ = def;
111720:     }
111720:     size_t numOperands() const {
111720:         return numInputs_;
111720:     }
111720:     LAllocation *getOperand(size_t index) {
111720:         JS_ASSERT(index < numOperands());
111720:         return &inputs_[index];
111720:     }
111720:     void setOperand(size_t index, const LAllocation &a) {
111720:         JS_ASSERT(index < numOperands());
111720:         inputs_[index] = a;
111720:     }
111720:     size_t numTemps() const {
111720:         return 0;
111720:     }
111720:     LDefinition *getTemp(size_t index) {
111720:         JS_NOT_REACHED("no temps");
111720:         return NULL;
111720:     }
111720:     void setTemp(size_t index, const LDefinition &temp) {
111720:         JS_NOT_REACHED("no temps");
111720:     }
111720: 
111720:     virtual void printInfo(FILE *fp) {
111720:         printOperands(fp);
111720:     }
111720: };
111720: 
111706: } // namespace ion
111706: } // namespace js
111706: 
111706: #endif // jsion_lir_common_h__
111706: 
