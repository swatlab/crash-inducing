35742: # ***** BEGIN LICENSE BLOCK *****
35742: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
35742: #
35742: # The contents of this file are subject to the Mozilla Public License Version
35742: # 1.1 (the "License"); you may not use this file except in compliance with
35742: # the License. You may obtain a copy of the License at
35742: # http://www.mozilla.org/MPL/
35742: #
35742: # Software distributed under the License is distributed on an "AS IS" basis,
35742: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35742: # for the specific language governing rights and limitations under the
35742: # License.
35742: #
35742: # The Original Code is mozilla.org code.
35742: #
35742: # Contributor(s):
35742: #   Chris Jones <jones.chris.g@gmail.com>
35742: #
35742: # Alternatively, the contents of this file may be used under the terms of
35742: # either of the GNU General Public License Version 2 or later (the "GPL"),
35742: # or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35742: # in which case the provisions of the GPL or the LGPL are applicable instead
35742: # of those above. If you wish to allow use of your version of this file only
35742: # under the terms of either the GPL or the LGPL, and not to allow others to
35742: # use your version of this file under the terms of the MPL, indicate your
35742: # decision by deleting the provisions above and replace them with the notice
35742: # and other provisions required by the GPL or the LGPL. If you do not delete
35742: # the provisions above, a recipient may use your version of this file under
35742: # the terms of any one of the MPL, the GPL or the LGPL.
35742: #
35742: # ***** END LICENSE BLOCK *****
35742: 
35990: import os, re, sys
35742: from copy import deepcopy
35742: 
35990: import ipdl.ast
35990: from ipdl.cxx.ast import *
35990: from ipdl.type import TypeVisitor
35990: 
35990: # FIXME/cjones: the chromium Message logging code doesn't work on
35990: # gcc/POSIX, because it wprintf()s across the chromium/mozilla
35990: # boundary. one side builds with -fshort-wchar, the other doesn't.
35990: # this code will remain off until the chromium base lib is replaced
35990: EMIT_LOGGING_CODE = ('win32' == sys.platform)
35990: 
35990: ##-----------------------------------------------------------------------------
35990: ## "Public" interface to lowering
35990: ##
35990: class LowerToCxx:
35990:     def lower(self, tu):
36137:         '''returns |[ header: File ], [ cpp : File ]| representing the
36137: lowered form of |tu|'''
35990:         # annotate the AST with IPDL/C++ IR-type stuff used later
35990:         tu.accept(_DecorateWithCxxStuff())
35990: 
35990:         pname = tu.protocol.name
35990: 
35990:         pheader = File(pname +'.h')
35990:         _GenerateProtocolHeader().lower(tu, pheader)
35990: 
36137:         parentheader, parentcpp = File(pname +'Parent.h'), File(pname +'Parent.cpp')
36137:         _GenerateProtocolParentCode().lower(
36137:             tu, pname+'Parent', parentheader, parentcpp)
36137: 
36137:         childheader, childcpp = File(pname +'Child.h'), File(pname +'Child.cpp')
36137:         _GenerateProtocolChildCode().lower(
36137:             tu, pname+'Child', childheader, childcpp)
36137: 
36137:         return [ pheader, parentheader, childheader ], [ parentcpp, childcpp ]
35990: 
35990: 
35990: ##-----------------------------------------------------------------------------
35990: ## Helper code
35990: ##
36136: 
36136: _NULL_ACTOR_ID = ExprLiteral.ZERO
36136: _FREED_ACTOR_ID = ExprLiteral.ONE
36136: 
35990: class _struct: pass
35990: 
36137: def _protocolHeaderName(p, side=''):
36137:     if side: side = side.title()
36137:     base = p.name + side
36137: 
36137:     
35990:     pfx = '/'.join([ ns.name for ns in p.namespaces ])
36137:     if pfx: return pfx +'/'+ base
36137:     else:   return base
35990: 
35990: def _includeGuardMacroName(headerfile):
35990:     return re.sub(r'[./]', '_', headerfile.name)
35990: 
35990: def _includeGuardStart(headerfile):
35990:     guard = _includeGuardMacroName(headerfile)
35990:     return [ CppDirective('ifndef', guard),
35990:              CppDirective('define', guard)  ]
35990: 
35990: def _includeGuardEnd(headerfile):
35990:     guard = _includeGuardMacroName(headerfile)
35990:     return [ CppDirective('endif', '// ifndef '+ guard) ]
35742: 
35896: def _actorName(pname, side):
35896:     """|pname| is the protocol name. |side| is 'Parent' or 'Child'."""
35990:     tag = side
35990:     if not tag[0].isupper():  tag = side.title()
35990:     return pname + tag
35990: 
35990: def _actorIdType():
35990:     return Type('int32')
35990: 
35990: def _actorId(actor):
35990:     return ExprSelect(actor, '->', 'mId')
35990: 
35990: def _actorHId(actorhandle):
35990:     return ExprSelect(actorhandle, '.', 'mId')
35990: 
35990: def _actorChannel(actor):
35990:     return ExprSelect(actor, '->', 'mChannel')
35990: 
35990: def _actorManager(actor):
35990:     return ExprSelect(actor, '->', 'mManager')
35990: 
36136: def _getActorId(actorexpr, outid, actortype, errfn):
36135:     # if (!actorexpr)
36135:     #   #ifdef NULLABLE
36136:     #     abort()
36135:     #   #else
36135:     #     outid = 0;
36135:     #   #endif
36136:     # else if (id == FREED)
36136:     #     abort()
36135:     # else
36135:     #     outid = _actorId(actorexpr)
36135:     ifnull = StmtIf(ExprNot(actorexpr))
36135:     if not actortype.nullable:
36136:         ifnull.addifstmts(
36136:             errfn("NULL actor value passed to non-nullable param"))
36135:     else:
36135:         ifnull.addifstmt(StmtExpr(ExprAssn(outid, ExprLiteral.ZERO)))
36135: 
36136:     iffreed = StmtIf(ExprBinary(_FREED_ACTOR_ID, '==', _actorId(actorexpr)))
36136:     ifnull.addelsestmt(iffreed)
36136: 
36136:     # this is always a hard-abort, because it means that some C++ code
36136:     # has a live pointer to a freed actor, so we're playing Russian
36136:     # roulette with invalid memory
36136:     iffreed.addifstmt(_runtimeAbort("actor has been delete'd"))
36136:     iffreed.addelsestmt(StmtExpr(ExprAssn(outid, _actorId(actorexpr))))
36135: 
36135:     return ifnull
36135: 
36135: 
36136: def _lookupActor(idexpr, outactor, actortype, cxxactortype, errfn):
36136:     # if (NULLID == idexpr)
36135:     #   #ifndef NULLABLE
36136:     #     abort()
36135:     #   #else
36135:     #     actor = 0;
36135:     #   #endif
36136:     # else if (FREEDID == idexpr)
36136:     #     abort()
36135:     # else {
36135:     #     actor = (cxxactortype*)_lookupListener(idexpr);
36135:     #     // bad actor ID.  always an error
36136:     #     if (!actor) abort();
36135:     # }
36136:     ifzero = StmtIf(ExprBinary(_NULL_ACTOR_ID, '==', idexpr))
36135:     if not actortype.nullable:
36136:         ifzero.addifstmts(errfn("NULL actor ID for non-nullable param"))
36135:     else:
36135:         ifzero.addifstmt(StmtExpr(ExprAssn(outactor, ExprLiteral.NULL)))
36135: 
36136:     iffreed = StmtIf(ExprBinary(_FREED_ACTOR_ID, '==', idexpr))
36136:     ifzero.addelsestmt(iffreed)
36136: 
36136:     iffreed.addifstmts(errfn("received FREED actor ID, evidence that the other side is malfunctioning"))
36136:     iffreed.addelsestmt(
36135:         StmtExpr(ExprAssn(
36135:             outactor,
36136:             ExprCast(_lookupListener(idexpr), cxxactortype, static=1))))
36136: 
36136:     ifnotactor = StmtIf(ExprNot(outactor))
36136:     ifnotactor.addifstmts(errfn("invalid actor ID, evidence that the other side is malfunctioning"))
36136:     iffreed.addelsestmt(ifnotactor)
36135: 
36135:     return ifzero
36135: 
36135: 
36136: def _lookupActorHandle(handle, outactor, actortype, cxxactortype, errfn):
36135:     return _lookupActor(_actorHId(handle), outactor, actortype, cxxactortype,
36136:                         errfn)
35990: 
35990: def _lookupListener(idexpr):
35990:     return ExprCall(ExprVar('Lookup'), args=[ idexpr ])
35896: 
36134: def _shmemType(ptr=0):
36134:     return Type('Shmem', ptr=ptr)
36134: 
36134: def _rawShmemType(ptr=0):
36134:     return Type('Shmem::SharedMemory', ptr=ptr)
36134: 
36134: def _shmemIdType():
36134:     return Type('Shmem::id_t')
36134: 
36134: def _shmemHandleType():
36134:     return Type('Shmem::SharedMemoryHandle')
36134: 
36134: def _shmemBackstagePass():
36134:     return ExprCall(ExprVar(
36134:         'Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead'))
36134: 
36134: def _shmemCtor(rawmem, idexpr):
36134:     return ExprCall(ExprVar('Shmem'),
36134:                     args=[ _shmemBackstagePass(), rawmem, idexpr ])
36134: 
36134: def _shmemId(shmemexpr):
36134:     return ExprCall(ExprSelect(shmemexpr, '.', 'Id'),
36134:                     args=[ _shmemBackstagePass() ])
36134: 
36134: def _shmemAlloc(size):
36134:     # starts out UNprotected
36134:     return ExprCall(ExprVar('Shmem::Alloc'),
36134:                     args=[ _shmemBackstagePass(), size ])
36134: 
36134: def _shmemOpenExisting(size, handle):
36134:     # starts out protected
36134:     return ExprCall(ExprVar('Shmem::OpenExisting'),
36134:                     args=[ _shmemBackstagePass(),
36134:                            # true => protect
36134:                            handle, size, ExprLiteral.TRUE ])
36134: 
36134: def _shmemForget(shmemexpr):
36134:     return ExprCall(ExprSelect(shmemexpr, '.', 'forget'),
36134:                     args=[ _shmemBackstagePass() ])
36134: 
36134: def _shmemRevokeRights(shmemexpr):
36134:     return ExprCall(ExprSelect(shmemexpr, '.', 'RevokeRights'),
36134:                     args=[ _shmemBackstagePass() ])
36134: 
36134: def _shmemCreatedMsgVar():
36134:     return ExprVar('mozilla::ipc::__internal__ipdl__ShmemCreated')
36134: 
36134: def _lookupShmem(idexpr):
36134:     return ExprCall(ExprVar('LookupShmem'), args=[ idexpr ])
36134: 
35900: def _makeForwardDecl(ptype, side):
35900:     clsname = _actorName(ptype.qname.baseid, side)
35848: 
35990:     fd = ForwardDecl(clsname, cls=1)
35900:     if 0 == len(ptype.qname.quals):
35848:         return fd
35848: 
35990:     outerns = Namespace(ptype.qname.quals[0])
35848:     innerns = outerns
35900:     for ns in ptype.qname.quals[1:]:
35990:         tmpns = Namespace(ns)
35848:         innerns.addstmt(tmpns)
35848:         innerns = tmpns
35848: 
35848:     innerns.addstmt(fd)
35848:     return outerns
35742: 
35990: def _putInNamespaces(cxxthing, namespaces):
35990:     """|namespaces| is in order [ outer, ..., inner ]"""
35990:     if 0 == len(namespaces):  return cxxthing
35990: 
35990:     outerns = Namespace(namespaces[0].name)
35990:     innerns = outerns
35990:     for ns in namespaces[1:]:
35990:         newns = Namespace(ns.name)
35990:         innerns.addstmt(newns)
35990:         innerns = newns
35990:     innerns.addstmt(cxxthing)
35990:     return outerns
35990: 
35990: def _sendPrefix(msgtype):
35990:     """Prefix of the name of the C++ method that sends |msgtype|."""
35990:     if msgtype.isRpc():
35990:         return 'Call'
35990:     return 'Send'
35990: 
35990: def _recvPrefix(msgtype):
35990:     """Prefix of the name of the C++ method that handles |msgtype|."""
35990:     if msgtype.isRpc():
35990:         return 'Answer'
35990:     return 'Recv'
35990: 
35990: def _flatTypeName(ipdltype):
35990:     """Return a 'flattened' IPDL type name that can be used as an
35990: identifier.
35990: E.g., |Foo[]| --> |ArrayOfFoo|."""
35990:     # NB: this logic depends heavily on what IPDL types are allowed to
35990:     # be constructed; e.g., Foo[][] is disallowed.  needs to be kept in
35990:     # sync with grammar.
35990:     if ipdltype.isIPDL() and ipdltype.isArray():
35990:         return 'ArrayOf'+ ipdltype.basetype.name()
35990:     return ipdltype.name()
35990: 
35990: 
35990: def _hasVisibleActor(ipdltype):
35990:     """Return true iff a C++ decl of |ipdltype| would have an Actor* type.
35990: For example: |Actor[]| would turn into |nsTArray<ActorParent*>|, so this
35990: function would return true for |Actor[]|."""
35990:     return (ipdltype.isIPDL()
35990:             and (ipdltype.isActor()
35990:                  or (ipdltype.isArray()
35990:                      and _hasVisibleActor(ipdltype.basetype))))
35990: 
35990: def _abortIfFalse(cond, msg):
35990:     return StmtExpr(ExprCall(
35990:         ExprVar('NS_ABORT_IF_FALSE'),
35990:         [ cond, ExprLiteral.String(msg) ]))
35990: 
35990: def _runtimeAbort(msg):
35990:     return StmtExpr(ExprCall(ExprVar('NS_RUNTIMEABORT'),
35990:                                      [ ExprLiteral.String(msg) ]))
35990: 
36134: def _autoptr(T):
36134:     return Type('nsAutoPtr', T=T)
36134: 
36134: def _autoptrForget(expr):
36134:     return ExprCall(ExprSelect(expr, '.', 'forget'))
36134: 
36139: def _cxxArrayType(basetype, const=0, ref=0):
36139:     return Type('nsTArray', T=basetype, const=const, ref=ref)
35990: 
35990: def _callCxxArrayLength(arr):
35990:     return ExprCall(ExprSelect(arr, '.', 'Length'))
35990: 
35990: def _callCxxArraySetLength(arr, lenexpr):
35990:     return ExprCall(ExprSelect(arr, '.', 'SetLength'),
35990:                     args=[ lenexpr ])
35990: 
36139: def _callCxxArrayInsertSorted(arr, elt):
36139:     return ExprCall(ExprSelect(arr, '.', 'InsertElementSorted'),
36139:                     args=[ elt ])
36139: 
36139: def _callCxxArrayRemoveSorted(arr, elt):
36139:     return ExprCall(ExprSelect(arr, '.', 'RemoveElementSorted'),
36139:                     args=[ elt ])
36139: 
36140: def _callCxxArrayClear(arr):
36140:     return ExprCall(ExprSelect(arr, '.', 'Clear'))
36140: 
35990: def _otherSide(side):
35990:     if side == 'child':  return 'parent'
35990:     if side == 'parent':  return 'child'
35990:     assert 0
35742: 
36027: def _ifLogging(stmts):
36028:     iflogging = StmtIf(ExprCall(ExprVar('mozilla::ipc::LoggingEnabled')))
36027:     iflogging.addifstmts(stmts)
36027:     return iflogging
36027: 
36135: # XXX we need to remove these and install proper error handling
36135: def _printErrorMessage(msg):
36136:     if isinstance(msg, str):
36136:         msg = ExprLiteral.String(msg)
36135:     return StmtExpr(
36136:         ExprCall(ExprVar('NS_ERROR'), args=[ msg ]))
36136: 
36136: def _fatalError(msg):
36136:     return StmtExpr(
36136:         ExprCall(ExprVar('FatalError'), args=[ ExprLiteral.String(msg) ]))
36136: 
36136: def _killProcess(pid):
36136:     return ExprCall(
36136:         ExprVar('base::KillProcess'),
36136:         args=[ pid,
36136:                # XXX this is meaningless on POSIX
36136:                ExprVar('base::PROCESS_END_KILLED_BY_USER'),
36136:                ExprLiteral.FALSE ])
36136: 
36136: # Results that IPDL-generated code returns back to *Channel code.
36136: # Users never see these
36136: class _Result:
36137:     @staticmethod
36137:     def Type():
36137:         return Type('Result')
36136: 
36136:     Processed = ExprVar('MsgProcessed')
36136:     NotKnown = ExprVar('MsgNotKnown')
36136:     NotAllowed = ExprVar('MsgNotAllowed')
36136:     PayloadError = ExprVar('MsgPayloadError')
36136:     RouteError = ExprVar('MsgRouteError')
36136:     ValuError = ExprVar('MsgValueError') # [sic]
36136: 
36136: # these |errfn*| are functions that generate code to be executed on an
36136: # error, such as "bad actor ID".  each is given a Python string
36136: # containing a description of the error
36136: 
36136: # used in user-facing Send*() methods
36136: def errfnSend(msg, errcode=ExprLiteral.FALSE):
36136:     return [
36136:         _fatalError(msg),
36136:         StmtReturn(errcode)
36136:     ]
36136: 
36136: def errfnSendCtor(msg):  return errfnSend(msg, errcode=ExprLiteral.NULL)
36136: 
36138: # TODO should this error handling be strengthened for dtors?
36138: def errfnSendDtor(msg):
36138:     return [
36138:         _printErrorMessage(msg),
36138:         StmtReturn(ExprLiteral.FALSE)
36138:     ]
36138: 
36136: # used in |OnMessage*()| handlers that hand in-messages off to Recv*()
36136: # interface methods
36136: def errfnRecv(msg, errcode=_Result.ValuError):
36136:     return [
36136:         _fatalError(msg),
36136:         StmtReturn(errcode)
36136:     ]
36135: 
36140: def _destroyMethod():
36140:     return ExprVar('ActorDestroy')
36140: 
36140: class _DestroyReason:
36140:     @staticmethod
36140:     def Type():  return Type('ActorDestroyReason')
36140: 
36140:     Deletion = ExprVar('Deletion')
36140:     AncestorDeletion = ExprVar('AncestorDeletion')
36140:     NormalShutdown = ExprVar('NormalShutdown')
36140:     AbnormalShutdown = ExprVar('AbnormalShutdown')
36140: 
35742: ##-----------------------------------------------------------------------------
35990: ## Intermediate representation (IR) nodes used during lowering
35990: 
35990: class _ConvertToCxxType(TypeVisitor):
35990:     def __init__(self, side):  self.side = side
35990:     
35990:     def visitBuiltinCxxType(self, t):
35990:         return Type(t.name())
35990: 
35990:     def visitImportedCxxType(self, t):
35990:         return Type(t.name())
35990: 
35990:     def visitActorType(self, a):
35990:         return Type(_actorName(a.protocol.name(), self.side), ptr=1)
35990: 
35990:     def visitUnionType(self, u):
35990:         return Type(u.name())
35990: 
35990:     def visitArrayType(self, a):
35990:         basecxxtype = a.basetype.accept(self)
35990:         return _cxxArrayType(basecxxtype)
35990: 
36134:     def visitShmemType(self, s):
36134:         return Type(s.name())
36134: 
35990:     def visitProtocolType(self, p): assert 0
35990:     def visitMessageType(self, m): assert 0
35990:     def visitVoidType(self, v): assert 0
35990:     def visitStateType(self, st): assert 0
35990: 
36138: def _allocMethod(ptype):
36138:     return ExprVar('Alloc'+ ptype.name())
36138: 
36138: def _deallocMethod(ptype):
36138:     return ExprVar('Dealloc'+ ptype.name())
35990: 
35990: class _ConvertToSerializableCxxType(TypeVisitor):
35990:     def visitBuiltinCxxType(self, t):
35990:         return Type(t.name())
35990: 
35990:     def visitImportedCxxType(self, t):
35990:         return Type(t.name())
35990: 
35990:     def visitActorType(self, a):
35990:         return Type('ActorHandle')
35990: 
35990:     def visitUnionType(self, u):
35990:         return Type(u.name())
35990: 
35990:     def visitArrayType(self, a):
35990:         basecxxtype = a.basetype.accept(self)
35990:         return _cxxArrayType(basecxxtype)
35990: 
36134:     def visitShmemType(self, s):
36134:         return Type(s.name())
36134: 
35990:     def visitProtocolType(self, p): assert 0
35990:     def visitMessageType(self, m): assert 0
35990:     def visitVoidType(self, v): assert 0
35990:     def visitStateType(self): assert 0
35990: 
35990: ##
35990: ## A _HybridDecl straddles IPDL and C++ decls.  It knows which C++
35990: ## types correspond to which IPDL types, and it also knows how
35990: ## serialize and deserialize "special" IPDL C++ types.
35990: ##
35990: ## NB: the current serialization/deserialization strategy is rather
35990: ## simplistic.  We take the values to be serialized, repack them into
35990: ## "safe" values, and then pass those values to the appropriate
35990: ## Msg_* constructor.  This can potentially result in a lot of
35990: ## unnecessary value copying and temporary variables.
35990: ##
35990: ## If this becomes a performance problem, this code should be modified
35990: ## to use a "streaming" model, in which code is generated to directly
35990: ## write serialized values into the Msg_*'s payload.
35990: ##
35990: class _HybridDecl:
35990:     """A hybrid decl stores both an IPDL type and all the C++ type
35990: info needed by later passes, along with a basic name for the decl."""
35990:     def __init__(self, ipdltype, name):
35990:         self.ipdltype = ipdltype
35990:         self.name = name
35990:         self.idnum = 0
35990: 
35990:     def var(self):
35990:         return ExprVar(self.name)
35990: 
35990:     def bareType(self, side):
35990:         """Return this decl's unqualified C++ type."""
35990:         return self.ipdltype.accept(_ConvertToCxxType(side))
35990: 
35990:     def refType(self, side):
35990:         """Return this decl's C++ type as a 'reference' type, which is not
35990: necessarily a C++ reference."""
35990:         t = self.bareType(side)
35990:         t.ref = 1
35990:         return t
35990: 
35990:     def constRefType(self, side):
35990:         """Return this decl's C++ type as a const, 'reference' type."""
35990:         t = self.bareType(side)
35990:         if self.ipdltype.isIPDL() and self.ipdltype.isActor():
35990:             t.const = 1                 # const Actor*
35990:             return t
36134:         if self.ipdltype.isIPDL() and self.ipdltype.isShmem():
36134:             t.ref = 1
36134:             return t
35990:         t.const = 1
35990:         t.ref = 1
35990:         return t
35990: 
35990:     def ptrToType(self, side):
35990:         t = self.bareType(side)
35990:         if self.ipdltype.isIPDL() and self.ipdltype.isActor():
35990:             t.ptr = 0
35990:             t.ptrptr = 1
35990:             return t
35990:         t.ptr = 1
35990:         return t
35990: 
35990:     def constPtrToType(self, side):
35990:         t = self.bareType(side)
35990:         if self.ipdltype.isIPDL() and self.ipdltype.isActor():
35990:             t.ptr = 0
35990:             t.const = 1
35990:             t.ptrconstptr = 1           # const Actor* const*
35990:             return t
35990:         t.const = 1
35990:         t.ptrconst = 1
35990:         return t
35990: 
35990:     def inType(self, side):
35990:         """Return this decl's C++ Type with inparam semantics."""
35990:         if self.ipdltype.isIPDL() and self.ipdltype.isActor():
35990:             return self.bareType(side)
35990:         return self.constRefType(side)
35990: 
35990:     def outType(self, side):
35990:         """Return this decl's C++ Type with outparam semantics."""
35990:         t = self.bareType(side)
35990:         if self.ipdltype.isIPDL() and self.ipdltype.isActor():
35990:             t.ptr = 0;  t.ptrptr = 1
35990:             return t
35990:         t.ptr = 1
35990:         return t
35990: 
35990:     def barePipeType(self):
35990:         """Return this decl's C++ serializable Type."""
35990:         return self.ipdltype.accept(_ConvertToSerializableCxxType())
35990: 
35990:     def inPipeType(self):
35990:         """Return this decl's serializable C++ type with inparam semantics"""
35990:         t = self.barePipeType()
35990:         t.const = 1
35990:         t.ref = 1
35990:         return t
35990: 
35990:     def outPipeType(self):
35990:         """Return this decl's serializable C++ type with outparam semantics"""
35990:         t = self.barePipeType()
35990:         t.ptr = 1
35990:         return t
35990: 
35990:     # the biggies: serialization/deserialization
35990: 
36136:     def serialize(self, expr, side, errfn):
36134:         if not self.speciallySerialized(self.ipdltype):
35990:             return expr, [ ]
35990:         # XXX could use TypeVisitor, but it doesn't feel right here
36136:         _, sexpr, stmts = self._serialize(self.ipdltype, expr, side, errfn)
35990:         return sexpr, stmts
35990: 
36136:     def _serialize(self, etype, expr, side, errfn):
35990:         '''Serialize |expr| of type |etype|, which has some actor type
35990: buried in it.  Return |pipetype, serializedExpr, serializationStmts|.'''
35990:         assert etype.isIPDL()           # only IPDL types may contain actors
35990: 
35990:         if etype.isActor():
36136:             return self._serializeActor(etype, expr, errfn)
35990:         elif etype.isArray():
36136:             return self._serializeArray(etype, expr, side, errfn)
35990:         elif etype.isUnion():
36136:             return self._serializeUnion(etype, expr, side, errfn)
36134:         elif etype.isShmem() or etype.isChmod():
36136:             return self._serializeShmem(etype, expr, side, errfn)
35990:         else: assert 0
35990: 
36134:     def speciallySerialized(self, type):
36134:         return ipdl.type.hasactor(type) or ipdl.type.hasshmem(type)
35990: 
36136:     def _serializeActor(self, actortype, expr, errfn):
35990:         actorhandlevar = ExprVar(self._nextuid('handle'))
35990:         pipetype = Type('ActorHandle')
36135: 
35990:         stmts = [
35990:             Whitespace('// serializing actor type\n', indent=1),
35990:             StmtDecl(Decl(pipetype, actorhandlevar.name)),
36136:             _getActorId(expr, _actorHId(actorhandlevar), actortype, errfn),
35990:             Whitespace.NL
35990:         ]
35990:         return pipetype, actorhandlevar, stmts
35990: 
35990: 
36136:     def _serializeArray(self, arraytype, expr, side, errfn):
35990:         newarrayvar = ExprVar(self._nextuid('serArray'))
35990:         lenvar = ExprVar(self._nextuid('length'))
35990:         ivar = ExprVar(self._nextuid('i'))
35990: 
35990:         # FIXME hacky init of |i|
35990:         forloop = StmtFor(init=ExprAssn(Decl(Type.UINT32, ivar.name),
35990:                                         ExprLiteral.ZERO),
35990:                           cond=ExprBinary(ivar, '<', lenvar),
35990:                           update=ExprPrefixUnop(ivar, '++'))
35990: 
35990:         ithNewElt = ExprIndex(newarrayvar, ivar)
35990:         ithOldElt = ExprIndex(expr, ivar)
35990: 
35990:         eltType, serializedExpr, forbodystmts = self._serialize(
36136:             arraytype.basetype, ithOldElt, side, errfn)
35990: 
35990:         forloop.addstmts(forbodystmts)
35990:         forloop.addstmt(StmtExpr(ExprAssn(ithNewElt, serializedExpr)))
35990: 
35990:         pipetype = _cxxArrayType(eltType)
35990:         stmts = [
35990:             Whitespace('// serializing array type\n', indent=1),
35990:             StmtDecl(Decl(Type.UINT32, lenvar.name),
35990:                      init=_callCxxArrayLength(expr)),
35990:             StmtDecl(Decl(pipetype, newarrayvar.name)),
35990:             StmtExpr(_callCxxArraySetLength(newarrayvar, lenvar)),
35990:             forloop,
35990:             Whitespace.NL
35990:         ]
35990:         return pipetype, newarrayvar, stmts
35990: 
35990: 
36136:     def _serializeUnion(self, uniontype, expr, side, errfn):
36135:         def insaneActorCast(actor, actortype, cxxactortype):
36135:             idvar = ExprVar(self._nextuid('actorid'))
36135:             return (
36135:                 [ StmtDecl(Decl(_actorIdType(), idvar.name)),
36136:                   _getActorId(actor, idvar, actortype, errfn),
36135:                 ],
36135:                 ExprCast(ExprCast(idvar, Type.INTPTR, static=1),
36135:                          cxxactortype,
35990:                          reinterpret=1)
36135:                 )
35990: 
35990:         pipetype = Type(uniontype.name())
35990:         serunionvar = ExprVar(self._nextuid('serUnion'))
35990:         ud = uniontype._ud
35990: 
35990:         switch = StmtSwitch(ud.callType(expr))
35990:         for c in ud.components:
35990:             ct = c.ipdltype
35990:             if not ipdl.type.hasactor(ct):
35990:                 continue
35990:             assert ct.isIPDL()
35990: 
35990:             # we special-case two types here: actor's and actor[]'s.  these
35990:             # get repacked into the out-array.  otherwise we recurse
35990:             case = StmtBlock()
35990:             getvalue = ExprCall(ExprSelect(expr, '.', c.getConstTypeName()))
35990: 
35990:             if ct.isActor():
35990:                 if c.side != side:
35990:                     case.addstmt(_runtimeAbort('wrong side!'))
35990:                 else:
35990:                     # may god have mercy on our souls
36135:                     getidstmts, castexpr = insaneActorCast(
36135:                         getvalue, ct, c.bareType())
36135:                     case.addstmts(
36135:                         getidstmts
36135:                         + [ StmtExpr(ExprAssn(serunionvar, castexpr)) ])
36135: 
35990:             elif ct.isArray() and ct.basetype.isActor():
35990:                 if c.side != side:
35990:                     case.addstmt(_runtimeAbort('wrong side!'))
35990:                 else:
35990:                     # no more apologies
36135:                     cxxactortype = ct.basetype.accept(
36135:                         _ConvertToCxxType(c.side))
35990:                     lenvar = ExprVar(self._nextuid('len'))
35990:                     newarrvar = ExprVar(self._nextuid('idarray'))
35990: 
35990:                     ivar = ExprVar(self._nextuid('i'))
35990:                     ithOldElt = ExprIndex(getvalue, ivar)
35990:                     ithNewElt = ExprIndex(newarrvar, ivar)
35990:                     loop = StmtFor(init=ExprAssn(Decl(Type.UINT32, ivar.name),
35990:                                           ExprLiteral.ZERO),
35990:                                    cond=ExprBinary(ivar, '<', lenvar),
35990:                                    update=ExprPrefixUnop(ivar, '++'))
36135:                     # loop body
36135:                     getidstmts, castexpr = insaneActorCast(
36135:                         ithOldElt, ct.basetype, cxxactortype)
36135:                     loop.addstmts(
36135:                         getidstmts
36135:                         + [ StmtExpr(ExprAssn(ithNewElt, castexpr)) ])
35990: 
35990:                     case.addstmts([
35990:                         StmtDecl(Decl(Type.UINT32, lenvar.name),
35990:                                  init=_callCxxArrayLength(getvalue)),
35990:                         StmtDecl(Decl(c.bareType(), newarrvar.name)),
35990:                         StmtExpr(_callCxxArraySetLength(newarrvar, lenvar)),
35990:                         Whitespace.NL,
35990:                         loop,
35990:                         StmtExpr(ExprAssn(serunionvar, newarrvar))
35990:                     ])
35990:             else:
35990:                 # NB: here we rely on the serialized expression
35990:                 # coming back with the same type
36135:                 _, newexpr, sstmts = self._serialize(ct, getvalue, side,
36136:                                                      errfn)
35990:                 case.addstmts(sstmts
35990:                               + [ Whitespace.NL,
35990:                                   StmtExpr(ExprAssn(serunionvar, newexpr)) ])
35990: 
35990:             case.addstmt(StmtBreak())
35990:             switch.addcase(CaseLabel(c.pqEnum()), case)
35990: 
35990:         switch.addcase(
35990:             DefaultLabel(),
35990:             StmtBlock([ StmtExpr(ExprAssn(serunionvar, expr)),
35990:                         StmtBreak() ]))
35990: 
35990:         stmts = [
35990:             Whitespace('// serializing union type\n', indent=1),
35990:             StmtDecl(Decl(pipetype, serunionvar.name)),
35990:             Whitespace.NL,
35990:             switch
35990:         ]
35990:         return pipetype, serunionvar, stmts
35990: 
35990: 
36136:     def _serializeShmem(self, shmemtype, expr, side, errfn):
36134:         pipetype = _shmemType()
36134:         pipevar = ExprVar(self._nextuid('serShmem'))
36134:         stmts = [
36134:             Whitespace('// serializing shmem type\n', indent=1),
36134:             StmtDecl(Decl(_shmemType(), pipevar.name),
36134:                      init=ExprCall(pipetype, args=[ expr ])),
36134:             StmtExpr(_shmemRevokeRights(expr)),
36134:             StmtExpr(_shmemForget(expr)),
36134:         ]
36134:         return pipetype, pipevar, stmts
36134: 
36134: 
35990:     def makePipeDecls(self, toExpr):
35990:         if not ipdl.type.hasactor(self.ipdltype):
35990:             return 0, toExpr, [ ]
35990:         tempvar = ExprVar(self._nextuid('deTemp'))
35990:         return (1,
35990:                 tempvar,
35990:                 [ StmtDecl(Decl(self.barePipeType(), tempvar.name)) ])
35990: 
35990:     def makeDeserializedDecls(self, side):
35990:         return self.var(), [ StmtDecl(Decl(self.bareType(side),
35990:                                            self.var().name)) ]
35990: 
36134:     def speciallyDeserialized(self, type):
36134:         return ipdl.type.hasactor(type) or ipdl.type.hasshmem(type)
36134: 
36136:     def deserialize(self, expr, side, sems, errfn):
35990:         """|expr| is a pointer the return type."""
36134:         if not self.speciallyDeserialized(self.ipdltype):
35990:             return [ ]
35990:         if sems == 'in':
35990:             toexpr = self.var()
35990:         elif sems == 'out':
35990:             toexpr = ExprDeref(self.var())
35990:         else: assert 0
36135:         _, stmts = self._deserialize(
36136:             expr, self.ipdltype, toexpr, side, errfn)
35990:         return stmts
35990: 
36136:     def _deserialize(self, pipeExpr, targetType, targetExpr, side, errfn):
36134:         if not self.speciallyDeserialized(targetType):
35990:             return targetType, [ ]
35990:         elif targetType.isActor():
35990:             return self._deserializeActor(
36136:                 pipeExpr, targetType, targetExpr, side, errfn)
35990:         elif targetType.isArray():
35990:             return self._deserializeArray(
36136:                 pipeExpr, targetType, targetExpr, side, errfn)
35990:         elif targetType.isUnion():
35990:             return self._deserializeUnion(
36136:                 pipeExpr, targetType, targetExpr, side, errfn)
36134:         elif targetType.isShmem():
36134:             return self._deserializeShmem(
36136:                 pipeExpr, targetType, targetExpr, side, errfn)
35990:         else: assert 0
35990: 
36135:     def _deserializeActor(self, actorhandle, actortype, outactor, side,
36136:                           errfn):
35990:         cxxtype = actortype.accept(_ConvertToCxxType(side))
35990:         return (
35990:             cxxtype,
36135:             [ Whitespace('// deserializing actor type\n', indent=1),
36135:               _lookupActorHandle(actorhandle, outactor, actortype, cxxtype,
36136:                                  errfn)
35990:             ])
35990: 
35990: 
36135:     def _deserializeArray(self, pipearray, arraytype, outarray, side,
36136:                           errfn):
35990:         cxxArrayType = arraytype.accept(_ConvertToCxxType(side))
35990:         lenvar = ExprVar(self._nextuid('length'))
35990: 
35990:         stmts = [
35990:             Whitespace('// deserializing array type\n', indent=1),
35990:             StmtDecl(Decl(Type.UINT32, lenvar.name),
35990:                      _callCxxArrayLength(pipearray)),
35990:             StmtExpr(ExprCall(ExprSelect(outarray, '.', 'SetLength'),
35990:                               args=[ lenvar ])),
35990:             Whitespace.NL
35990:         ]
35990:         ivar = ExprVar(self._nextuid('i'))
35990:         forloop = StmtFor(init=ExprAssn(Decl(Type.UINT32, ivar.name),
35990:                                         ExprLiteral.ZERO),
35990:                           cond=ExprBinary(ivar, '<', lenvar),
35990:                           update=ExprPrefixUnop(ivar, '++'))       
35990:         ithNewElt = ExprIndex(outarray, ivar)
35990:         ithOldElt = ExprIndex(pipearray, ivar)
35990: 
35990:         outelttype, forstmts = self._deserialize(
36136:             ithOldElt, arraytype.basetype, ithNewElt, side, errfn)
35990:         forloop.addstmts(forstmts)
35990: 
35990:         stmts.append(forloop)
35990: 
35990:         return cxxArrayType, stmts
35990: 
35990: 
36135:     def _deserializeUnion(self, pipeunion, uniontype, outunion, side,
36136:                           errfn):
35990:         def actorIdCast(expr):
35990:             return ExprCast(
35990:                 ExprCast(expr, Type.INTPTR, reinterpret=1),
35990:                 _actorIdType(),
35990:                 static=1)
35990: 
35990:         cxxUnionType = Type(uniontype.name())
35990:         ud = uniontype._ud
35990: 
35990:         switch = StmtSwitch(ud.callType(pipeunion))
35990:         for c in ud.components:
35990:             ct = c.ipdltype
36134:             if not self.speciallyDeserialized(ct):
35990:                 continue
35990:             assert ct.isIPDL()
35990: 
35990:             # like in _serializeUnion, we special-case actor's and
35990:             # actor[]'s.  we look up the actors that correspond to the
35990:             # actor ID's we, sigh, packed into the actor pointers
35990:             case = StmtBlock()
35990:             getvalue = ExprCall(ExprSelect(pipeunion, '.', c.getTypeName()))
35990: 
35990:             if ct.isActor():
35990:                 # ParamTraits<union>::Read() magically flips the side on
35990:                 # our behalf
35990:                 if c.side != side:
35990:                     case.addstmt(_runtimeAbort('wrong side!'))
35990:                 else:
35990:                     idvar = ExprVar(self._nextuid('id'))
36135:                     outactorvar = ExprVar(self._nextuid('actor'))
36135:                     actorcxxtype = c.bareType()
35990:                     case.addstmts([
35990:                         StmtDecl(Decl(_actorIdType(), idvar.name),
35990:                                  actorIdCast(getvalue)),
36135:                         StmtDecl(Decl(actorcxxtype, outactorvar.name)),
36135:                         _lookupActor(idvar, outactorvar, ct, actorcxxtype,
36136:                                      errfn),
36135:                         StmtExpr(ExprAssn(outunion, outactorvar))
35990:                     ])
35990:             elif ct.isArray() and ct.basetype.isActor():
35990:                 if c.side != side:
35990:                     case.addstmt(_runtimeAbort('wrong side!'))
35990:                 else:
35990:                     idvar = ExprVar(self._nextuid('id'))
35990:                     arrvar = ExprVar(self._nextuid('arr'))
35990:                     ivar = ExprVar(self._nextuid('i'))
35990:                     ithElt = ExprIndex(arrvar, ivar)
36135:                     actortype = ct.basetype
36135:                     actorcxxtype = ct.basetype.accept(_ConvertToCxxType(side))
35990: 
35990:                     loop = StmtFor(
35990:                         init=ExprAssn(Decl(Type.UINT32, ivar.name),
35990:                                       ExprLiteral.ZERO),
35990:                         cond=ExprBinary(ivar, '<',
35990:                                         _callCxxArrayLength(arrvar)),
35990:                         update=ExprPrefixUnop(ivar, '++'))
35990:                     loop.addstmts([
35990:                         StmtDecl(Decl(_actorIdType(), idvar.name),
35990:                                  actorIdCast(ithElt)),
36135:                         _lookupActor(idvar, ithElt, actortype, actorcxxtype,
36136:                                      errfn),
35990:                     ])
35990:                 
35990:                     case.addstmts([
35990:                         StmtDecl(Decl(c.refType(), arrvar.name),
35990:                                  getvalue),
35990:                         loop,
35990:                         StmtExpr(ExprAssn(outunion, arrvar))
35990:                     ])
35990:             else:
35990:                 tempvar = ExprVar('tempUnionElt')
35990:                 elttype, dstmts = self._deserialize(
36136:                     getvalue, ct, tempvar, side, errfn)
35990:                 case.addstmts(
35990:                     [ StmtDecl(Decl(elttype, tempvar.name)),
35990:                       Whitespace.NL ]
35990:                     + dstmts
35990:                     + [ Whitespace.NL,
35990:                         StmtExpr(ExprAssn(outunion, tempvar)) ])
35990: 
35990:             case.addstmt(StmtBreak())
35990:             switch.addcase(CaseLabel(c.pqEnum()), case)
35990: 
35990:         switch.addcase(
35990:             DefaultLabel(),
35990:             StmtBlock([ StmtExpr(ExprAssn(outunion, pipeunion)),
35990:                         StmtBreak() ]))
35990:         
35990:         stmts = [
35990:             Whitespace('// deserializing union type\n', indent=1),
35990:             switch
35990:         ]
35990: 
35990:         return cxxUnionType, stmts
35990: 
35990: 
36135:     def _deserializeShmem(self, pipeshmem, shmemtype, outshmem, side,
36136:                           errfn):
36134:         # Shmem::id_t id = inshmem.mId
36134:         # Shmem::shmem_t* raw = Lookup(id)
36134:         # if (raw)
36134:         #   outshmem = Shmem(raw, id)
36134:         idvar = ExprVar(self._nextuid('shmemid'))
36134:         rawvar = ExprVar(self._nextuid('rawshmem'))
36134:         iffound = StmtIf(rawvar)
36134:         iffound.addifstmt(StmtExpr(ExprAssn(
36134:             outshmem, _shmemCtor(rawvar, idvar))))
36134: 
36134:         cxxShmemType = _shmemType()
36134:         stmts = [
36134:             Whitespace('// deserializing shmem type\n', indent=1),
36134:             StmtDecl(Decl(_shmemIdType(), idvar.name),
36134:                      init=_shmemId(pipeshmem)),
36134:             StmtDecl(Decl(_rawShmemType(ptr=1), rawvar.name),
36134:                      init=_lookupShmem(idvar)),
36134:             iffound
36134:         ]
36134:         return cxxShmemType, stmts
36134: 
36134: 
35990:     def _nextuid(self, descr):
35990:         """Return an identifier that's unique wrt to |self| and |self.name|."""
35990:         self.idnum += 1
35990:         return '%s_%s_%d'% (self.name, descr, self.idnum)
35990: 
35990: ##--------------------------------------------------
35990: 
35990: class UnionDecl(ipdl.ast.UnionDecl):
35990:     def fqClassName(self):
35990:         return self.decl.type.fullname()
35990: 
35990:     def callType(self, var=None):
35990:         func = ExprVar('type')
35990:         if var is not None:
35990:             func = ExprSelect(var, '.', func.name)
35990:         return ExprCall(func)
35990: 
35990:     @staticmethod
35990:     def upgrade(unionDecl):
35990:         assert isinstance(unionDecl, ipdl.ast.UnionDecl)
35990:         unionDecl.__class__ = UnionDecl
35990:         return unionDecl
35990: 
35990: 
35990: class _UnionMember(_HybridDecl):
35990:     """Not in the AFL sense, but rather a member (e.g. |int;|) of an
35990: IPDL union type."""
35990:     def __init__(self, ipdltype, ud, side=None):
35990:         flatname = _flatTypeName(ipdltype)
35990:         special = _hasVisibleActor(ipdltype)
35990:         if special:
35990:             flatname += side.title()
35990: 
35990:         _HybridDecl.__init__(self, ipdltype, 'V'+ flatname)
35990:         self.flattypename = flatname
35990:         self.side = side
35990:         self.special = special
35990:         self.ud = ud
35990: 
35990:     def enum(self):
35990:         return 'T' + self.flattypename
35990: 
35990:     def pqEnum(self):
35990:         return self.ud.name +'::'+ self.enum()
35990: 
35990:     def enumvar(self):
35990:         return ExprVar(self.enum())
35990: 
35990:     def unionType(self):
35990:         """Type used for storage in generated C union decl."""
35990:         return TypeArray(Type('char'), ExprSizeof(self.bareType()))
35990: 
35990:     def unionValue(self):
35990:         # NB: knows that Union's storage C union is named |mValue|
35990:         return ExprSelect(ExprVar('mValue'), '.', self.name)
35990: 
35990:     def typedef(self):
35990:         return self.flattypename +'__tdef'
35990: 
35990:     def callGetConstPtr(self):
35990:         """Return an expression of type self.constptrToSelfType()"""
35990:         return ExprCall(ExprVar(self.getConstPtrName()))
35990: 
35990:     def callGetPtr(self):
35990:         """Return an expression of type self.ptrToSelfType()"""
35990:         return ExprCall(ExprVar(self.getPtrName()))
35990: 
35990:     def callOperatorEq(self, rhs):
35990:         if self.ipdltype.isIPDL() and self.ipdltype.isActor():
35990:             rhs = ExprCast(rhs, self.bareType(), const=1)
35990:         return ExprAssn(ExprDeref(self.callGetPtr()), rhs)
35990: 
35990:     def callPlacementCtor(self, expr=None):
35990:         assert not isinstance(expr, list)
35990:         
35990:         if expr is None:
35990:             args = None
35990:         elif self.ipdltype.isIPDL() and self.ipdltype.isActor():
35990:             args = [ ExprCast(expr, self.bareType(), const=1) ]
35990:         else:
35990:             args = [ expr ]
35990: 
35990:         return ExprNew(self.bareType(self.side),
35990:                      args=args,
35990:                      newargs=[ self.callGetPtr() ])
35990: 
35990:     def callPlacementDtor(self):
35990:         return ExprCall(
35990:             ExprSelect(self.callGetPtr(), '->', '~'+ self.typedef()))
35990: 
35990:     def getTypeName(self): return 'get_'+ self.flattypename
35990:     def getConstTypeName(self): return 'get_'+ self.flattypename
35990: 
35990:     def getPtrName(self): return 'ptr_'+ self.flattypename
35990:     def getConstPtrName(self): return 'constptr_'+ self.flattypename
35990: 
35990:     def ptrToSelfExpr(self):
35990:         """|*ptrToSelfExpr()| has type |self.bareType()|"""
35990:         return ExprCast(ExprAddrOf(self.unionValue()),
35990:                         self.ptrToType(),
35990:                         reinterpret=1)
35990: 
35990:     def constptrToSelfExpr(self):
35990:         """|*constptrToSelfExpr()| has type |self.constType()|"""
35990:         return ExprCast(ExprAddrOf(self.unionValue()),
35990:                         self.constPtrToType(),
35990:                         reinterpret=1)
35990: 
35990:     # @override the following methods to pass |self.side| instead of
35990:     # forcing the caller to remember which side we're declared to
35990:     # represent.
35990:     def bareType(self, side=None):
35990:         return _HybridDecl.bareType(self, self.side)
35990:     def refType(self, side=None):
35990:         return _HybridDecl.refType(self, self.side)
35990:     def constRefType(self, side=None):
35990:         return _HybridDecl.constRefType(self, self.side)
35990:     def ptrToType(self, side=None):
35990:         return _HybridDecl.ptrToType(self, self.side)
35990:     def constPtrToType(self, side=None):
35990:         return _HybridDecl.constPtrToType(self, self.side)
35990:     def inType(self, side=None):
35990:         return _HybridDecl.inType(self, self.side)
35990: 
35990:     def otherSideBareType(self):
35990:         assert self.ipdltype.isIPDL()
35990:         otherside = _otherSide(self.side)
35990:         it = self.ipdltype
35990: 
35990:         if it.isArray():
35990:             assert it.basetype.isIPDL() and it.basetype.isActor()
35990:             return _cxxArrayType(
35990:                 it.basetype.accept(_ConvertToCxxType(otherside)))
35990:         elif it.isActor():
35990:             return _HybridDecl.bareType(self, otherside)
35990:         else: assert 0
35990: 
35990: ##--------------------------------------------------
35990: 
35990: class MessageDecl(ipdl.ast.MessageDecl):
35990:     def baseName(self):
35990:         return self.name
35990:     
35990:     def recvMethod(self):
35990:         name = _recvPrefix(self.decl.type) + self.baseName()
35990:         if self.decl.type.isCtor():
35990:             name += 'Constructor'
35990:         return ExprVar(name)
35990: 
35990:     def sendMethod(self):
35990:         name = _sendPrefix(self.decl.type) + self.baseName()
35990:         if self.decl.type.isCtor():
35990:             name += 'Constructor'
35990:         return ExprVar(name)
35990: 
35990:     def hasReply(self):
35990:         return (self.decl.type.hasReply()
35990:                 or self.decl.type.isCtor()
35990:                 or self.decl.type.isDtor())
35990: 
35990:     def msgClass(self):
35990:         return 'Msg_%s'% (self.decl.progname)
35990: 
35990:     def pqMsgClass(self):
35990:         return '%s::%s'% (self.namespace, self.msgClass())
35990: 
36027:     def msgCast(self, msgexpr):
36027:         return ExprCast(msgexpr, Type(self.pqMsgClass(), const=1, ptr=1),
36138:                         static=1)
36027: 
35990:     def msgId(self):  return self.msgClass()+ '__ID'
35990:     def pqMsgId(self):
35990:         return '%s::%s'% (self.namespace, self.msgId())
35990: 
35990:     def replyClass(self):
35990:         return 'Reply_%s'% (self.decl.progname)
35990: 
35990:     def pqReplyClass(self):
35990:         return '%s::%s'% (self.namespace, self.replyClass())
35990: 
36027:     def replyCast(self, replyexpr):
36027:         return ExprCast(replyexpr, Type(self.pqReplyClass(), const=1, ptr=1),
36138:                         static=1)
36027: 
35990:     def replyId(self):  return self.replyClass()+ '__ID'
35990:     def pqReplyId(self):
35990:         return '%s::%s'% (self.namespace, self.replyId())
35990: 
35990:     def actorDecl(self):
35990:         return self.params[0]
35990: 
35990:     def makeCxxParams(self, paramsems='in', returnsems='out',
35990:                       pipetypes=0, side=None, implicit=1):
35990:         """Return a list of C++ decls per the spec'd configuration.
35990:     |params| and |returns| is the C++ semantics of those: 'in', 'out', or None.
35990:     |pipetypes| specifies whether to return serializable types."""
35990: 
35990:         def makeDecl(d, sems, pipetypes):
35990:             if sems is 'in' and pipetypes:
35990:                 return Decl(d.inPipeType(), d.name)
35990:             elif sems is 'in':
35990:                 return Decl(d.inType(side), d.name)
35990:             elif sems is 'out' and pipetypes:
35990:                 return Decl(d.outPipeType(), d.name)
35990:             elif sems is 'out':
35990:                 return Decl(d.outType(side), d.name)
35990:             else: assert 0
35990: 
35990:         cxxparams = [ ]
35990:         if paramsems is not None:
35990:             cxxparams.extend(
35990:                 [ makeDecl(d, paramsems, pipetypes) for d in self.params ])
35990: 
35990:         if returnsems is not None:
35990:             cxxparams.extend(
35990:                 [ makeDecl(r, returnsems, pipetypes) for r in self.returns ])
35990: 
35990:         if not implicit and self.decl.type.hasImplicitActorParam():
35990:             cxxparams = cxxparams[1:]
35990: 
35990:         return cxxparams
35990: 
35990:     def makeCxxArgs(self, params=1, retsems='out', retcallsems='out',
35990:                     implicit=1):
35990:         assert not implicit or params     # implicit => params
35990:         assert not retcallsems or retsems # retcallsems => returnsems
35990:         cxxargs = [ ]
35990: 
35990:         if params:
35990:             cxxargs.extend([ p.var() for p in self.params ])
35990: 
35990:         for ret in self.returns:
35990:             if retsems is 'in':
35990:                 if retcallsems is 'in':
35990:                     cxxargs.append(ret.var())
35990:                 elif retcallsems is 'out':
35990:                     cxxargs.append(ExprAddrOf(ret.var()))
35990:                 else: assert 0
35990:             elif retsems is 'out':
35990:                 if retcallsems is 'in':
35990:                     cxxargs.append(ExprDeref(ret.var()))
35990:                 elif retcallsems is 'out':
35990:                     cxxargs.append(ret.var())
35990:                 else: assert 0
35990: 
35990:         if not implicit:
35990:             assert self.decl.type.hasImplicitActorParam()
35990:             cxxargs = cxxargs[1:]
35990: 
35990:         return cxxargs
35990: 
35990: 
35990:     @staticmethod
35990:     def upgrade(messageDecl):
35990:         assert isinstance(messageDecl, ipdl.ast.MessageDecl)
35990:         if messageDecl.decl.type.hasImplicitActorParam():
35990:             messageDecl.params.insert(
35990:                 0,
35990:                 _HybridDecl(
35990:                     ipdl.type.ActorType(
35990:                         messageDecl.decl.type.constructedType()),
35990:                     'actor'))
35990:         messageDecl.__class__ = MessageDecl
35990:         return messageDecl
35990: 
35990: ##--------------------------------------------------
35990: def _semsToChannelParts(sems):
35990:     if ipdl.ast.ASYNC == sems:   channel = 'AsyncChannel'
35990:     elif ipdl.ast.SYNC == sems:  channel = 'SyncChannel'
35990:     elif ipdl.ast.RPC == sems:   channel = 'RPCChannel'
35990:     return [ 'mozilla', 'ipc', channel ]
35990: 
35990: def _semsToListener(sems):
35990:     return { ipdl.ast.ASYNC: 'AsyncListener',
35990:              ipdl.ast.SYNC: 'SyncListener',
35990:              ipdl.ast.RPC: 'RPCListener' }[sems]
35990: 
35990: 
35990: class Protocol(ipdl.ast.Protocol):
35990:     def cxxTypedefs(self):
35990:         return self.decl.cxxtypedefs
35990: 
35990:     def sendSems(self):
35990:         return self.decl.type.toplevel().sendSemantics
35990: 
35990:     def channelName(self):
35990:         return '::'.join(_semsToChannelParts(self.sendSems()))
35990: 
35990:     def channelSel(self):
35990:         if self.decl.type.isToplevel():  return '.'
35990:         return '->'
35990: 
35990:     def channelType(self):
35990:         return Type('Channel', ptr=not self.decl.type.isToplevel())
35990: 
35990:     def channelHeaderFile(self):
35990:         return '/'.join(_semsToChannelParts(self.sendSems())) +'.h'
35990: 
35990:     def listenerName(self):
35990:         return _semsToListener(self.sendSems())
35990: 
35990:     def fqListenerName(self):
35990:         return self.channelName() +'::'+ _semsToListener(self.sendSems())
35990: 
36138:     def managerInterfaceType(self, ptr=0):
35990:         return Type('mozilla::ipc::IProtocolManager',
35990:                     ptr=ptr,
35990:                     T=Type(self.fqListenerName()))
35990: 
36138:     def managerActorType(self, side, ptr=0):
36138:         return Type(_actorName(self.decl.type.manager.name(), side),
36138:                     ptr=ptr)
36138: 
36138:     def managerMethod(self, actorThis=None):
36138:         if actorThis is not None:
36138:             return ExprSelect(actorThis, '->', 'Manager')
36138:         return ExprVar('Manager');
36138: 
36138:     # FIXME/bug 525181: implement
36138:     def stateMethod(self):
36138:         return ExprVar('state');
36138: 
35990:     def registerMethod(self):
35990:         return ExprVar('Register')
35990: 
35990:     def registerIDMethod(self):
35990:         return ExprVar('RegisterID')
35990: 
35990:     def lookupIDMethod(self):
35990:         return ExprVar('Lookup')
35990: 
36138:     def unregisterMethod(self, actorThis=None):
36138:         if actorThis is not None:
36138:             return ExprSelect(actorThis, '->', 'Unregister')
35990:         return ExprVar('Unregister')
35990: 
36016:     def otherProcessMethod(self):
36016:         return ExprVar('OtherProcess')
36016: 
35990:     def nextActorIdExpr(self, side):
36016:         assert self.decl.type.isToplevel()
35990:         if side is 'parent':   op = '++'
35990:         elif side is 'child':  op = '--'
36136:         else: assert 0
35990:         return ExprPrefixUnop(self.lastActorIdVar(), op)
35990: 
36136:     def actorIdInit(self, side):
36136:         assert self.decl.type.isToplevel()
36136: 
36136:         # parents go up from FREED, children go down from NULL
36136:         if side is 'parent':  return _FREED_ACTOR_ID
36136:         elif side is 'child': return _NULL_ACTOR_ID
36136:         else: assert 0
36136: 
35990:     # an actor's C++ private variables
35990:     def lastActorIdVar(self):
35990:         assert self.decl.type.isToplevel()
35990:         return ExprVar('mLastRouteId')
35990: 
35990:     def actorMapVar(self):
35990:         assert self.decl.type.isToplevel()
35990:         return ExprVar('mActorMap')
35990: 
36138:     def channelVar(self, actorThis=None):
36138:         if actorThis is not None:
36138:             return ExprSelect(actorThis, '->', 'mChannel')
35990:         return ExprVar('mChannel')
35990: 
35990:     def channelForSubactor(self):
35990:         if self.decl.type.isToplevel():
35990:             return ExprAddrOf(self.channelVar())
35990:         return self.channelVar()
35990: 
36138:     def routingId(self, actorThis=None):
35990:         if self.decl.type.isToplevel():
35990:             return ExprVar('MSG_ROUTING_CONTROL')
36138:         if actorThis is not None:
36138:             return ExprSelect(actorThis, '->', self.idVar().name)
35990:         return self.idVar()
35990: 
35990:     def idVar(self):
35990:         assert not self.decl.type.isToplevel()
35990:         return ExprVar('mId')
35990: 
35990:     def managerVar(self):
35990:         assert not self.decl.type.isToplevel()
35990:         return ExprVar('mManager')
35990: 
36016:     def otherProcessVar(self):
36016:         assert self.decl.type.isToplevel()
36016:         return ExprVar('mOtherProcess')
36016: 
36139:     def managedCxxType(self, actortype, side):
36139:         assert self.decl.type.isManagerOf(actortype)
36139:         return Type(_actorName(actortype.name(), side), ptr=1)
36139: 
36139:     def managedMethod(self, actortype, side):
36139:         assert self.decl.type.isManagerOf(actortype)
36139:         return ExprVar('Managed'+  _actorName(actortype.name(), side))
36139: 
36139:     def managedVar(self, actortype, side):
36139:         assert self.decl.type.isManagerOf(actortype)
36139:         return ExprVar('mManaged'+ _actorName(actortype.name(), side))
36139: 
36140:     def managedVarType(self, actortype, side, const=0, ref=0):
36140:         assert self.decl.type.isManagerOf(actortype)
36140:         return _cxxArrayType(self.managedCxxType(actortype, side),
36140:                              const=const, ref=ref)
36140: 
36139:     def managerArrayExpr(self, thisvar, side):
36139:         """The member var my manager keeps of actors of my type."""
36139:         assert self.decl.type.isManaged()
36139:         return ExprSelect(
36139:             ExprCall(self.managerMethod(thisvar)),
36139:             '->', 'mManaged'+ _actorName(self.decl.type.name(), side))
36139: 
36134:     # shmem stuff
36134:     def shmemMapVar(self):
36134:         assert self.usesShmem()
36134:         return ExprVar('mShmemMap')
36134: 
36134:     def lastShmemIdVar(self):
36134:         assert self.usesShmem()
36134:         return ExprVar('mLastShmemId')
36134: 
36166:     def shmemIdInit(self, side):
36166:         assert self.usesShmem()
36166:         # use the same scheme for shmem IDs as actor IDs
36166:         if side is 'parent':  return _FREED_ACTOR_ID
36166:         elif side is 'child': return _NULL_ACTOR_ID
36166:         else: assert 0
36166: 
36134:     def nextShmemIdExpr(self, side):
36134:         assert self.usesShmem()
36134:         if side is 'parent':   op = '++'
36134:         elif side is 'child':  op = '--'
36134:         return ExprPrefixUnop(self.lastShmemIdVar(), op)
36134: 
36134:     def lookupShmemVar(self):
36134:         assert self.usesShmem()
36134:         return ExprVar('LookupShmem')
36134: 
36134:     def registerShmemVar(self):
36134:         assert self.usesShmem()
36134:         return ExprVar('RegisterShmem')
36134: 
36134:     def registerShmemIdVar(self):
36134:         assert self.usesShmem()
36134:         return ExprVar('RegisterShmemId')
36134: 
36134:     def unregisterShmemVar(self):
36134:         assert self.usesShmem()
36134:         return ExprVar('UnregisterShmem')
36134: 
36134:     def usesShmem(self):
36134:         for md in self.messageDecls:
36134:             for param in md.inParams:
36134:                 if ipdl.type.hasshmem(param.type):
36134:                     return True
36134:             for ret in md.outParams:
36134:                 if ipdl.type.hasshmem(ret.type):
36134:                     return True
36134:         return False
36134: 
35990:     @staticmethod
35990:     def upgrade(protocol):
35990:         assert isinstance(protocol, ipdl.ast.Protocol)
35990:         protocol.__class__ = Protocol
35990:         return protocol
35990: 
35990: ##-----------------------------------------------------------------------------
35990: 
35990: class _DecorateWithCxxStuff(ipdl.ast.Visitor):
35990:     """Phase 1 of lowering: decorate the IPDL AST with information
35990: relevant to C++ code generation.
35990: 
35990: This pass results in an AST that is a poor man's "IR"; in reality, a
35990: "hybrid" AST mainly consisting of IPDL nodes with new C++ info along
35990: with some new IPDL/C++ nodes that are tuned for C++ codegen."""
35990: 
35742:     def __init__(self):
35990:         # the set of typedefs that allow generated classes to
35990:         # reference known C++ types by their "short name" rather than
35990:         # fully-qualified name. e.g. |Foo| rather than |a::b::Foo|.
36138:         self.typedefs = [ 
36138:             Typedef(Type('mozilla::ipc::ActorHandle'), 'ActorHandle')
36138:         ]
35990:         self.protocolName = None
35990: 
35990:     def visitProtocol(self, pro):
35990:         self.protocolName = pro.name
35990:         pro.decl.cxxtypedefs = self.typedefs
35990:         Protocol.upgrade(pro)
35990:         return ipdl.ast.Visitor.visitProtocol(self, pro)
35990: 
35990: 
35990:     def visitUsingStmt(self, using):
35990:         if using.decl.fullname is not None:
35990:             self.typedefs.append(Typedef(Type(using.decl.fullname),
35990:                                          using.decl.shortname))
35990: 
35990:     def visitUnionDecl(self, ud):
35990:         ud.decl.special = 0
35990:         ud.decl.type._ud = ud           # sucky
35990:         newcomponents = [ ]
35990:         for ctype in ud.decl.type.components:
35990:             if _hasVisibleActor(ctype):
35990:                 ud.decl.special = 1
35990:                 # if ctype has a visible actor, we need both
35990:                 # |ActorParent| and |ActorChild| union members
35990:                 newcomponents.append(_UnionMember(ctype, ud, side='parent'))
35990:                 newcomponents.append(_UnionMember(ctype, ud, side='child'))
35990:             else:
35990:                 newcomponents.append(_UnionMember(ctype, ud))
35990:         ud.components = newcomponents
35990:         UnionDecl.upgrade(ud)
35990: 
35990:         if ud.decl.fullname is not None:
35990:             self.typedefs.append(Typedef(Type(ud.fqClassName()), ud.name))
35990: 
35990: 
35990:     def visitDecl(self, decl):
35990:         return _HybridDecl(decl.type, decl.progname)
35990: 
35990:     def visitMessageDecl(self, md):
35990:         md.namespace = self.protocolName
35990:         md.params = [ param.accept(self) for param in md.inParams ]
35990:         md.returns = [ ret.accept(self) for ret in md.outParams ]
35990:         MessageDecl.upgrade(md)
35990: 
35990:     def visitTransitionStmt(self, ts):
35990:         ts.state.decl.cxxenum = 'State_%s'% (ts.state.decl.progname)
35990: 
35990: ##-----------------------------------------------------------------------------
35990: 
35990: class _GenerateProtocolHeader(ipdl.ast.Visitor):
35990:     '''Creates a header containing code common to both the parent and
35990: child actors.'''
35990:     def __init__(self):
35990:         self.protocol = None     # protocol we're generating a class for
35990:         self.file = None         # File stuff is stuck in
35990: 
35990:     def lower(self, tu, outcxxfile):
35990:         self.protocol = tu.protocol
35742:         self.file = outcxxfile
35742:         tu.accept(self)
35742: 
35742:     def visitTranslationUnit(self, tu):
35742:         f = self.file
35742: 
35990:         f.addthing(Whitespace('''//
35990: // Automatically generated by the IPDL compiler.
35742: // Edit at your own risk
35742: //
35742: 
35742: '''))
35990:         f.addthings(_includeGuardStart(f))
35990:         f.addthing(Whitespace.NL)
35990: 
35990:         ipdl.ast.Visitor.visitTranslationUnit(self, tu)
35990: 
35990:         f.addthing(Whitespace.NL)
35990:         f.addthings(_includeGuardEnd(f))
35742: 
35742: 
35742:     def visitCxxInclude(self, inc):
35990:         self.file.addthing(CppDirective('include', '"'+ inc.file +'"'))
35742: 
35900:     def visitUnionDecl(self, ud):
35990:         self.file.addthings(
35990:             _generateCxxUnionStuff(ud))
35990: 
35990: 
35990:     def visitProtocol(self, p):
35990:         self.file.addthing(Whitespace("""
35990: //-----------------------------------------------------------------------------
35990: // Code common to %sChild and %sParent
35990: //
35990: """% (p.name, p.name)))
35990: 
35990:         # construct the namespace into which we'll stick all our decls
35990:         ns = Namespace(self.protocol.name)
35990:         self.file.addthing(_putInNamespaces(ns, p.namespaces))
35990:         ns.addstmt(Whitespace.NL)
35990: 
35990:         # state information
35990:         stateenum = TypeEnum('State')
35990:         for ts in p.transitionStmts:
35990:             stateenum.addId(ts.state.decl.cxxenum)
35990:         if len(p.transitionStmts):
35990:             startstate = p.transitionStmts[0].state.decl.cxxenum
35990:         else:
35990:             startstate = '0'
35990:         stateenum.addId('StateStart', startstate)
35990:         stateenum.addId('StateError')
35990:         stateenum.addId('StateLast')
35990: 
35990:         ns.addstmts([ StmtDecl(Decl(stateenum,'')), Whitespace.NL ])
35990: 
35990:         # spit out message type enum and classes
35990:         msgenum = TypeEnum('MessageType')
35990:         msgstart = self.protocol.name +'MsgStart << 10'
35990:         msgenum.addId(self.protocol.name +'Start', msgstart)
35990:         msgenum.addId(self.protocol.name +'PreStart', '('+ msgstart +') - 1')
35990: 
35990:         for md in p.messageDecls:
35990:             msgenum.addId(md.msgId())
35990:             if md.hasReply():
35990:                 msgenum.addId(md.replyId())
35990: 
35990:         msgenum.addId(self.protocol.name +'End')
35990:         ns.addstmts([ StmtDecl(Decl(msgenum, '')), Whitespace.NL ])
35990: 
35990:         typedefs = self.protocol.decl.cxxtypedefs
35990:         for md in p.messageDecls:
35990:             paramsIn = md.makeCxxParams(paramsems='in', returnsems=None,
35990:                                         pipetypes=1)
35990:             paramsOut = md.makeCxxParams(paramsems='out', returnsems=None,
35990:                                          pipetypes=1)
35990:             ns.addstmts([
35990:                 _generateMessageClass(md.msgClass(), md.msgId(),
35990:                                       paramsIn, paramsOut, typedefs),
35990:                 Whitespace.NL ])
35990:             if md.hasReply():
35990:                 returnsIn = md.makeCxxParams(paramsems=None, returnsems='in',
35990:                                              pipetypes=1)
35990:                 returnsOut = md.makeCxxParams(paramsems=None, returnsems='out',
35990:                                               pipetypes=1)
35990:                 ns.addstmts([
35990:                     _generateMessageClass(
35990:                         md.replyClass(), md.replyId(), returnsIn, returnsOut,
35990:                         typedefs),
35990:                     Whitespace.NL ])
35990: 
35990:         ns.addstmts([ Whitespace.NL, Whitespace.NL ])
35990: 
35990: ##--------------------------------------------------
35990: 
35990: def _generateMessageClass(clsname, msgid, inparams, outparams, typedefs):
35990:     cls = Class(name=clsname, inherits=[ Inherit(Type('IPC::Message')) ])
35990:     cls.addstmt(Label.PRIVATE)
35990:     cls.addstmts(typedefs)
35990:     cls.addstmt(Whitespace.NL)
35990: 
35990:     cls.addstmt(Label.PUBLIC)
35990: 
35990:     idenum = TypeEnum()
35990:     idenum.addId('ID', msgid)
35990:     cls.addstmt(StmtDecl(Decl(idenum, '')))
35990: 
35990:     # make the message constructor (serializer)
35990:     ctor = ConstructorDefn(
35990:         ConstructorDecl(clsname,
35990:                         params=inparams),
35990:         memberinits=[ExprMemberInit(ExprVar('IPC::Message'),
35990:                                     [ ExprVar('MSG_ROUTING_NONE'),
35990:                                       ExprVar('ID'),
35990:                                       ExprVar('PRIORITY_NORMAL') ]) ])
35990:     ctor.addstmts([
35990:         StmtExpr(ExprCall(ExprVar('IPC::WriteParam'),
35990:                           args=[ ExprVar.THIS, ExprVar(p.name) ]))
35990:         for p in inparams
35990:     ])
35997:     
35990:     cls.addstmts([ ctor, Whitespace.NL ])
35990: 
35990:     # make the message deserializer
35990:     msgvar = ExprVar('msg')
35990:     msgdecl = Decl(Type('Message', ptr=1, const=1), msgvar.name)
35990:     reader = MethodDefn(MethodDecl(
35990:         'Read', params=[ msgdecl ] + outparams, ret=Type.BOOL, static=1))
35990: 
35990:     itervar = ExprVar('iter')
35990:     if len(outparams):
35990:         reader.addstmts([
36134:             StmtDecl(Decl(Type.VOIDPTR, itervar.name),
35990:                      ExprLiteral.ZERO),
35990:             Whitespace.NL ])
35990: 
35990:     for oparam in outparams:
35990:         failif = StmtIf(ExprNot(ExprCall(
35990:             ExprVar('IPC::ReadParam'),
35990:             args=[ msgvar, ExprAddrOf(itervar), ExprVar(oparam.name) ])))
35990:         failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
35990:         reader.addstmts([ failif, Whitespace.NL ])
35990: 
35997:     if len(outparams):
36000:         ifdata = StmtIf(itervar)
36000:         ifdata.addifstmt(StmtExpr(ExprCall(
35997:             ExprSelect(msgvar, '->', 'EndRead'),
35997:             args=[ itervar ])))
36000:         reader.addstmt(ifdata)
35997: 
35990:     reader.addstmt(StmtReturn(ExprLiteral.TRUE))
35990:     cls.addstmts([ reader, Whitespace.NL ])
35990: 
35990:     # generate a logging function
35990:     # 'pfx' will be something like "[FooParent] sent"
35990:     pfxvar = ExprVar('__pfx')
35990:     outfvar = ExprVar('__outf')
35990:     logger = MethodDefn(MethodDecl(
35990:         'Log',
35990:         params=([ Decl(Type('std::string', const=1, ref=1), pfxvar.name),
35990:                   Decl(Type('FILE', ptr=True), outfvar.name) ]),
35990:         const=1))
35990:     # TODO/cjones: allow selecting what information is printed to 
35990:     # the log
35990:     msgvar = ExprVar('__logmsg')
35990:     logger.addstmt(StmtDecl(Decl(Type('std::string'), msgvar.name)))
35990: 
35990:     def appendToMsg(thing):
35990:         return StmtExpr(ExprCall(ExprSelect(msgvar, '.', 'append'),
35990:                                  args=[ thing ]))
35990:     logger.addstmts([
35990:         StmtExpr(ExprCall(
35990:             ExprVar('StringAppendF'),
35990:             args=[ ExprAddrOf(msgvar),
35990:                    ExprLiteral.String('[time:%" PRId64 "]'),
35990:                    ExprCall(ExprVar('PR_Now')) ])),
35990:         appendToMsg(pfxvar),
35990:         appendToMsg(ExprLiteral.String(clsname +'(')),
35990:         Whitespace.NL
35990:     ])
35990: 
35990:     # TODO turn this back on when string stuff is sorted
35990: 
36027:     logger.addstmt(appendToMsg(ExprLiteral.String(')\\n')))
35990: 
35990:     # and actually print the log message
35990:     logger.addstmt(StmtExpr(ExprCall(
35990:         ExprVar('fputs'),
35990:         args=[ ExprCall(ExprSelect(msgvar, '.', 'c_str')), outfvar ])))
35990: 
35990:     cls.addstmt(logger)
35990: 
35990:     return cls
35990: 
35990: ##--------------------------------------------------
35990: 
35990: def _generateCxxUnionStuff(ud):
35990:     # This Union class basically consists of a type (enum) and a
35990:     # union for storage.  The union can contain POD and non-POD
35990:     # types.  Each type needs a copy ctor, assignment operator,
35990:     # and dtor.
35900:     #
35900:     # Rather than templating this class and only providing
35900:     # specializations for the types we support, which is slightly
35990:     # "unsafe" in that C++ code can add additional specializations
35990:     # without the IPDL compiler's knowledge, we instead explicitly
35990:     # implement non-templated methods for each supported type.
35900:     #
35990:     # The one complication that arises is that C++, for arcane
35900:     # reasons, does not allow the placement destructor of a
35900:     # builtin type, like int, to be directly invoked.  So we need
35900:     # to hack around this by internally typedef'ing all
35900:     # constituent types.  Sigh.
35900:     #
35900:     # So, for each type, this "Union" class needs:
35900:     # (private)
35900:     #  - entry in the type enum
35900:     #  - entry in the storage union
35900:     #  - [type]ptr() method to get a type* from the underlying union
35900:     #  - same as above to get a const type*
35900:     #  - typedef to hack around placement delete limitations
35900:     # (public)
35900:     #  - placement delete case for dtor
35900:     #  - copy ctor
35900:     #  - case in generic copy ctor
35900:     #  - operator= impl
35900:     #  - case in generic operator=
35900:     #  - operator [type&]
35900:     #  - operator [const type&] const
35900:     #  - [type&] get_[type]()
35900:     #  - [const type&] get_[type]() const
35900:     #
35990:     cls = Class(ud.name, final=1)
35990:     # const Union&, i.e., Union type with inparam semantics
35990:     inClsType = Type(ud.name, const=1, ref=1)
35990:     refClsType = Type(ud.name, ref=1)
35990:     typetype = Type('Type')
35990:     valuetype = Type('Value')
35990:     mtypevar = ExprVar('mType')
35990:     mvaluevar = ExprVar('mValue')
35990:     maybedtorvar = ExprVar('MaybeDestroy')
35990:     assertsanityvar = ExprVar('AssertSanity')
35990:     tnonevar = ExprVar('T__None')
35990:     tfirstvar = ExprVar('T__First')
35990:     tlastvar = ExprVar('T__Last')
35990: 
35990:     def callAssertSanity(uvar=None, expectTypeVar=None):
35990:         func = assertsanityvar
35990:         args = [ ]
35990:         if uvar is not None:
35990:             func = ExprSelect(uvar, '.', assertsanityvar.name)
35990:         if expectTypeVar is not None:
35990:             args.append(expectTypeVar)
35990:         return ExprCall(func, args=args)
35990: 
35990:     def callMaybeDestroy(newTypeVar):
35990:         return ExprCall(maybedtorvar, args=[ newTypeVar ])
35990: 
35990:     def maybeReconstruct(memb, newTypeVar):
35990:         ifdied = StmtIf(callMaybeDestroy(newTypeVar))
35990:         ifdied.addifstmt(StmtExpr(memb.callPlacementCtor()))
35990:         return ifdied
35990: 
35990:     # compute all the typedefs and forward decls we need to make
35990:     usingTypedefs = [ ]
35990:     forwarddeclstmts = [ ]
35990:     class computeTypeDeps(ipdl.type.TypeVisitor):
35990:         def __init__(self):  self.seen = set()
35990: 
35990:         def maybeTypedef(self, fqname, name):
35990:             if fqname != name:
35990:                 usingTypedefs.append(Typedef(Type(fqname), name))
35990:         
35990:         def visitBuiltinCxxType(self, t):
35990:             if t in self.seen: return
35990:             self.seen.add(t)
35990:             self.maybeTypedef(t.fullname(), t.name())
35990: 
35990:         def visitImportedCxxType(self, t):
35990:             if t in self.seen: return
35990:             self.seen.add(t)
35990:             self.maybeTypedef(t.fullname(), t.name())
35990: 
35990:         def visitActorType(self, t):
35990:             if t in self.seen: return
35990:             self.seen.add(t)
35990:             
35990:             fqname, name = t.fullname(), t.name()
35990: 
35990:             self.maybeTypedef(_actorName(fqname, 'Parent'),
35990:                               _actorName(name, 'Parent'))
35990:             self.maybeTypedef(_actorName(fqname, 'Child'),
35990:                               _actorName(name, 'Child'))
35990: 
35990:             forwarddeclstmts.extend([
35990:                 _makeForwardDecl(t.protocol, 'parent'), Whitespace.NL,
35990:                 _makeForwardDecl(t.protocol, 'child'), Whitespace.NL
35990:             ])
35990: 
35990:         def visitUnionType(self, t):
35990:             if t == ud.decl.type or t in self.seen: return
35990:             self.seen.add(t)
35990:             self.maybeTypedef(t.fullname(), t.name())
35990: 
35990:             return ipdl.type.TypeVisitor.visitUnionType(self, t)
35990: 
35990:         def visitArrayType(self, t):
35990:             return ipdl.type.TypeVisitor.visitArrayType(self, t)
35990: 
35990:         def visitVoidType(self, v): assert 0
35990:         def visitMessageType(self, v): assert 0
35990:         def visitProtocolType(self, v): assert 0
35990:         def visitStateType(self, v): assert 0
35990: 
35990:     gettypedeps = computeTypeDeps()
35990:     for c in ud.components:
35990:         c.ipdltype.accept(gettypedeps)
35990: 
35990: 
35990:     # the |Type| enum, used to switch on the discunion's real type
35990:     cls.addstmt(Label.PUBLIC)
35990:     typeenum = TypeEnum(typetype.name)
35990:     typeenum.addId(tnonevar.name, 0)
35990:     firstid = ud.components[0].enum()
35990:     typeenum.addId(firstid, 1)
35990:     for c in ud.components[1:]:
35990:         typeenum.addId(c.enum())
35990:     typeenum.addId(tfirstvar.name, firstid)
35990:     typeenum.addId(tlastvar.name, ud.components[-1].enum())
35990:     cls.addstmts([ StmtDecl(Decl(typeenum,'')),
35990:                    Whitespace.NL ])
35990: 
35990:     cls.addstmt(Label.PRIVATE)
35990:     cls.addstmts(
35990:         usingTypedefs
35990:                 # hacky typedef's that allow placement dtors of builtins
35990:         + [ Typedef(c.bareType(), c.typedef()) for c in ud.components ])
35990:     cls.addstmt(Whitespace.NL)
35990: 
35990:     # the C++ union the discunion use for storage
35990:     valueunion = TypeUnion(valuetype.name)
35990:     for c in ud.components:
35990:         valueunion.addComponent(c.unionType(), c.name)
35990:     cls.addstmts([ StmtDecl(Decl(valueunion,'')),
35990:                        Whitespace.NL ])
35990: 
35990:     # for each constituent type T, add private accessors that
35990:     # return a pointer to the Value union storage casted to |T*|
35990:     # and |const T*|
35990:     for c in ud.components:
35990:         getptr = MethodDefn(MethodDecl(
35990:             c.getPtrName(), params=[ ], ret=c.ptrToType()))
35990:         getptr.addstmt(StmtReturn(c.ptrToSelfExpr()))
35990: 
35990:         getptrconst = MethodDefn(MethodDecl(
35990:             c.getConstPtrName(), params=[ ], ret=c.constPtrToType(), const=1))
35990:         getptrconst.addstmt(StmtReturn(c.constptrToSelfExpr()))
35990: 
35990:         cls.addstmts([ getptr, getptrconst ])
35990:     cls.addstmt(Whitespace.NL)
35990: 
35990:     # add a helper method that invokes the placement dtor on the
35990:     # current underlying value, only if |aNewType| is different
35990:     # than the current type, and returns true if the underlying
35990:     # value needs to be re-constructed
35990:     newtypevar = ExprVar('aNewType')
35990:     maybedtor = MethodDefn(MethodDecl(
35990:         maybedtorvar.name,
35990:         params=[ Decl(typetype, newtypevar.name) ],
35990:         ret=Type.BOOL))
35990:     # wasn't /actually/ dtor'd, but it needs to be re-constructed
35990:     ifnone = StmtIf(ExprBinary(mtypevar, '==', tnonevar))
35990:     ifnone.addifstmt(StmtReturn(ExprLiteral.TRUE))
35990:     # same type, nothing to see here
35990:     ifnochange = StmtIf(ExprBinary(mtypevar, '==', newtypevar))
35990:     ifnochange.addifstmt(StmtReturn(ExprLiteral.FALSE))
35990:     # need to destroy.  switch on underlying type
35990:     dtorswitch = StmtSwitch(mtypevar)
35990:     for c in ud.components:
35990:         dtorswitch.addcase(
35990:             CaseLabel(c.enum()),
35990:             StmtBlock([ StmtExpr(c.callPlacementDtor()),
35990:                         StmtBreak() ]))
35990:     dtorswitch.addcase(
35990:         DefaultLabel(),
35990:         StmtBlock([ _runtimeAbort("not reached"), StmtBreak() ]))
35990:     maybedtor.addstmts([
35990:         ifnone,
35990:         ifnochange,
35990:         dtorswitch,
35990:         StmtReturn(ExprLiteral.TRUE)
35990:     ])
35990:     cls.addstmts([ maybedtor, Whitespace.NL ])
35990: 
35990:     # add helper methods that ensure the discunion has a
35990:     # valid type
35990:     sanity = MethodDefn(MethodDecl(
36134:         assertsanityvar.name, ret=Type.VOID, const=1))
35990:     sanity.addstmts([
35990:         _abortIfFalse(ExprBinary(tfirstvar, '<=', mtypevar),
35990:                       'invalid type tag'),
35990:         _abortIfFalse(ExprBinary(mtypevar, '<=', tlastvar),
35990:                       'invalid type tag') ])
35990:     cls.addstmt(sanity)
35990: 
35990:     atypevar = ExprVar('aType')
35990:     sanity2 = MethodDefn(
35990:         MethodDecl(assertsanityvar.name,
35990:                        params=[ Decl(typetype, atypevar.name) ],
36134:                        ret=Type.VOID,
35990:                        const=1))
35990:     sanity2.addstmts([
35990:         StmtExpr(ExprCall(assertsanityvar)),
35990:         _abortIfFalse(ExprBinary(mtypevar, '==', atypevar),
35990:                       'unexpected type tag') ])
35990:     cls.addstmts([ sanity2, Whitespace.NL ])
35990: 
35990:     ## ---- begin public methods -----
35990: 
35990:     # Union() default ctor
35990:     cls.addstmts([
35990:         Label.PUBLIC,
35990:         ConstructorDefn(
35990:             ConstructorDecl(ud.name),
35990:             memberinits=[ ExprMemberInit(mtypevar, [ tnonevar ]) ]),
35990:         Whitespace.NL
35990:     ])
35990: 
35990:     # Union(const T&) copy ctors
35990:     othervar = ExprVar('aOther')
35990:     for c in ud.components:
35990:         copyctor = ConstructorDefn(ConstructorDecl(
35990:             ud.name, params=[ Decl(c.inType(), othervar.name) ]))
35990:         copyctor.addstmts([
35990:             StmtExpr(c.callPlacementCtor(othervar)),
35990:             StmtExpr(ExprAssn(mtypevar, c.enumvar())) ])
35990:         cls.addstmts([ copyctor, Whitespace.NL ])
35990: 
35990:     # Union(const Union&) copy ctor
35990:     copyctor = ConstructorDefn(ConstructorDecl(
36045:         ud.name, params=[ Decl(inClsType, othervar.name) ]))
35990:     othertype = ud.callType(othervar)
35990:     copyswitch = StmtSwitch(othertype)
35990:     for c in ud.components:
35990:         copyswitch.addcase(
35990:             CaseLabel(c.enum()),
35990:             StmtBlock([
35990:                 StmtExpr(c.callPlacementCtor(
35990:                     ExprCall(ExprSelect(othervar,
35990:                                         '.', c.getConstTypeName())))),
35990:                 StmtBreak()
35990:             ]))
35990:     copyswitch.addcase(
35990:         DefaultLabel(),
35990:         StmtBlock([ _runtimeAbort('unreached'), StmtReturn() ]))
35990:     copyctor.addstmts([
35990:         StmtExpr(callAssertSanity(uvar=othervar)),
35990:         copyswitch,
35990:         StmtExpr(ExprAssn(mtypevar, othertype))
35990:     ])
35990:     cls.addstmts([ copyctor, Whitespace.NL ])
35990: 
35990:     # ~Union()
35990:     dtor = DestructorDefn(DestructorDecl(ud.name))
35990:     dtor.addstmt(StmtExpr(callMaybeDestroy(tnonevar)))
35990:     cls.addstmts([ dtor, Whitespace.NL ])
35990: 
35990:     # type()
35990:     typemeth = MethodDefn(MethodDecl('type', ret=typetype, const=1))
35990:     typemeth.addstmt(StmtReturn(mtypevar))
35990:     cls.addstmts([ typemeth, Whitespace.NL ])
35990: 
35990:     # Union& operator=(const T&) methods
35990:     rhsvar = ExprVar('aRhs')
35990:     for c in ud.components:
35990:         opeq = MethodDefn(MethodDecl(
35900:             'operator=',
35990:             params=[ Decl(c.inType(), rhsvar.name) ],
35990:             ret=refClsType))
35990:         opeq.addstmts([
35990:             # might need to placement-delete old value first
35990:             maybeReconstruct(c, c.enumvar()),
35990:             StmtExpr(c.callOperatorEq(rhsvar)),
35990:             StmtExpr(ExprAssn(mtypevar, c.enumvar())),
35990:             StmtReturn(ExprDeref(ExprVar.THIS))
35990:         ])
35990:         cls.addstmts([ opeq, Whitespace.NL ])
35990: 
35990:     # Union& operator=(const Union&)
35990:     opeq = MethodDefn(MethodDecl(
35990:         'operator=',
35990:         params=[ Decl(inClsType, rhsvar.name) ],
35990:         ret=refClsType))
35990:     rhstypevar = ExprVar('t')
35990:     opeqswitch = StmtSwitch(rhstypevar)
35990:     for c in ud.components:
35990:         case = StmtBlock()
35990:         case.addstmts([
35990:             maybeReconstruct(c, rhstypevar),
35990:             StmtExpr(c.callOperatorEq(
35990:                 ExprCall(ExprSelect(rhsvar, '.', c.getConstTypeName())))),
35990:             StmtBreak()
35990:         ])
35990:         opeqswitch.addcase(CaseLabel(c.enum()), case)
35990:     opeqswitch.addcase(
35990:         DefaultLabel(),
35990:         StmtBlock([ _runtimeAbort('unreached'), StmtBreak() ]))
35990:     opeq.addstmts([
35990:         StmtExpr(callAssertSanity(uvar=rhsvar)),
35990:         StmtDecl(Decl(typetype, rhstypevar.name), init=ud.callType(rhsvar)),
35990:         opeqswitch,
35990:         StmtExpr(ExprAssn(mtypevar, rhstypevar)),
35990:         StmtReturn(ExprDeref(ExprVar.THIS))
35990:     ])
35990:     cls.addstmts([ opeq, Whitespace.NL ])
35990: 
35990:     # accessors for each type: operator T&, operator const T&,
35990:     # T& get(), const T& get()
35990:     for c in ud.components:
35990:         getValueVar = ExprVar(c.getTypeName())
35990:         getConstValueVar = ExprVar(c.getConstTypeName())
35990: 
35990:         getvalue = MethodDefn(MethodDecl(getValueVar.name, ret=c.refType()))
35990:         getvalue.addstmts([
35990:             StmtExpr(callAssertSanity(expectTypeVar=c.enumvar())),
35990:             StmtReturn(ExprDeref(c.callGetPtr()))
35990:         ])
35990: 
35990:         getconstvalue = MethodDefn(MethodDecl(
35990:             getConstValueVar.name, ret=c.constRefType(), const=1))
35990:         getconstvalue.addstmts([
35990:             StmtExpr(callAssertSanity(expectTypeVar=c.enumvar())),
35990:             StmtReturn(ExprDeref(c.callGetConstPtr()))
35990:         ])
35990: 
35990:         optype = MethodDefn(MethodDecl('', typeop=c.refType()))
35990:         optype.addstmt(StmtReturn(ExprCall(getValueVar)))
35990:         opconsttype = MethodDefn(MethodDecl(
35990:             '', const=1, typeop=c.constRefType()))
35990:         opconsttype.addstmt(StmtReturn(ExprCall(getConstValueVar)))
35990: 
35990:         cls.addstmts([ getvalue, getconstvalue,
35990:                        optype, opconsttype,
35990:                        Whitespace.NL ])
35990: 
35990:     # private vars
35990:     cls.addstmts([
35990:         Label.PRIVATE,
35990:         StmtDecl(Decl(valuetype, mvaluevar.name)),
35990:         StmtDecl(Decl(typetype, mtypevar.name))
35990:     ])
35990: 
35990:     # serializer/deserializer
35990:     fqUnionType = Type(ud.fqClassName())
35990:     pickle = Class(name='ParamTraits', specializes=fqUnionType, struct=1)
35990:     pickle.addstmts(
35990:         [ Label.PRIVATE ]
35990:         + usingTypedefs
35990:         + [ Whitespace.NL,
35990:             Label.PUBLIC,
35990:             Typedef(fqUnionType, 'paramType'),
35990:             Whitespace.NL
35990:         ])
35990: 
35990:     writevar = ExprVar('WriteParam')
35990:     msgvar = ExprVar('aMsg')
35990:     paramvar = ExprVar('aParam')
35990:     callparamtype = ud.callType(paramvar)
35990: 
35990:     # Write(Message*, paramType&)
35990:     serialize = MethodDefn(MethodDecl(
35990:         'Write',
35990:         params=[ Decl(Type('Message', ptr=1), msgvar.name),
35990:                  Decl(Type('paramType', const=1, ref=1), paramvar.name) ],
35990:         static=1))
35990:     serialize.addstmt(StmtExpr(
35990:         ExprCall(
35990:             writevar,
35990:             args=[ ExprVar('aMsg'),
35990:                    ExprCast(callparamtype, Type.INT, static=1) ])))
35990: 
35990:     writeswitch = StmtSwitch(callparamtype)
35990:     for c in ud.components:
35990:         case = StmtBlock()
35990:         getvalue = ExprCall(ExprSelect(paramvar, '.', c.getConstTypeName()))
35990: 
35990:         if not c.special:
35990:             case.addstmt(StmtExpr(
35990:                 ExprCall(writevar, args=[ msgvar, getvalue ])))
35990:         elif c.ipdltype.isActor():
35990:             # going to hell in a handbasket for this ...
35990:             case.addstmt(StmtExpr(
35990:                 ExprCall(writevar,
35990:                          args=[ msgvar,
35990:                                 ExprCast(getvalue, Type.INTPTR,
35990:                                          reinterpret=1) ])))
35900:         else:
35990:             assert c.ipdltype.isArray() and c.ipdltype.basetype.isActor()
35990:             # the devil made me do it!
35990:             lenvar = ExprVar('len')
35990:             case.addstmts([
35990:                 StmtDecl(Decl(Type.UINT32, lenvar.name),
35990:                          init=ExprCall(ExprSelect(getvalue, '.', 'Length'))),
35990:                 StmtExpr(ExprCall(writevar, args=[ msgvar, lenvar ])),
35990:                 StmtExpr(ExprCall(
35990:                     ExprSelect(msgvar, '->', 'WriteBytes'),
35990:                     args=[
35990:                         ExprCast(
35990:                             ExprCall(ExprSelect(getvalue, '.', 'Elements')),
35990:                             Type('void', const=1, ptr=1),
35990:                             reinterpret=1),
35990:                         ExprBinary(lenvar, '*', ExprSizeof(Type.INTPTR))
35990:                     ]))
35990:             ])
35990:         case.addstmt(StmtBreak())
35990: 
35990:         writeswitch.addcase(CaseLabel('paramType::'+ c.enum()), case)
35990:     writeswitch.addcase(
35990:         DefaultLabel(),
35990:         StmtBlock([ _runtimeAbort('unreached'), StmtReturn() ])
35990:     )
35990:     serialize.addstmt(writeswitch)
35990: 
35990:     # Read(const Message& msg, void** iter, paramType* out)
35990:     itervar = ExprVar('aIter')
35990:     deserialize = MethodDefn(MethodDecl(
35990:         'Read',
35990:         params=[ Decl(Type('Message', const=1, ptr=1), msgvar.name),
35990:                  Decl(Type('void', ptrptr=1), itervar.name),
35990:                  Decl(Type('paramType', ptr=1), paramvar.name) ],
35990:         ret=Type.BOOL,
35990:         static=1))
35990: 
35990:     typevar = ExprVar('type')
35990:     readvar = ExprVar('ReadParam')
35990:     fqTfirstVar = ExprVar('paramType::'+ tfirstvar.name)
35990:     fqTlastVar = ExprVar('paramType::'+ tlastvar.name)
35990:     failif = StmtIf(ExprNot(
35990:         ExprBinary(
35990:             ExprCall(readvar, args=[ msgvar, itervar, ExprAddrOf(typevar) ]),
35990:             '&&', ExprBinary(ExprBinary(fqTfirstVar, '<=', typevar),
35990:                              '&&', ExprBinary(typevar, '<=', fqTlastVar)))))
35990:     failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
35990: 
35990:     deserialize.addstmts([
35990:         StmtDecl(Decl(Type.INT, typevar.name)),
35990:         failif,
35990:         Whitespace.NL
35990:     ])
35990: 
35990:     derefunion = ExprDeref(paramvar)
35990:     valvar = ExprVar('val')
35990:     readswitch = StmtSwitch(typevar)
35990:     for c in ud.components:
35990:         case = StmtBlock()
35990: 
35990:         # special-case actor and actor[]
35990:         readstmts = None
35990:         if not c.special:
35990:             failif = StmtIf(ExprNot(ExprCall(
35990:                 readvar, args=[ msgvar, itervar, ExprAddrOf(valvar) ])))
35990:             failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
35990: 
35990:             case.addstmts([
35990:                 StmtDecl(Decl(c.bareType(), valvar.name)),
35990:                 Whitespace.NL,
35990:                 failif,
35990:                 StmtExpr(ExprAssn(derefunion, valvar)),
35990:                 StmtReturn(ExprLiteral.TRUE)
35990:             ])
35990:         elif c.ipdltype.isActor():
35990:             failif = StmtIf(ExprNot(ExprCall(
35990:                 readvar,
35990:                 args=[ msgvar, itervar,
35990:                        ExprCast(ExprAddrOf(valvar),
35990:                                 Type('intptr_t', ptr=1),
35990:                                 reinterpret=1) ])))
35990:             failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
35990: 
35990:             case.addstmts([
35990:                 StmtDecl(Decl(c.otherSideBareType(), valvar.name)),
35990:                 Whitespace.NL,
35990:                 failif,
35990:                 StmtExpr(ExprAssn(derefunion, valvar)),
35990:                 StmtReturn(ExprLiteral.TRUE)
35990:             ])
35900:         else:
35990:             assert c.ipdltype.isArray() and c.ipdltype.basetype.isActor()
35990: 
35990:             lenvar = ExprVar('len')
35990:             failif = StmtIf(ExprNot(ExprCall(
35990:                 readvar, args=[ msgvar, itervar, ExprAddrOf(lenvar) ])))
35990:             failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
35990: 
35990:             ptrvar = ExprVar('ptr')
35990:             failifarray = StmtIf(ExprNot(ExprCall(
35990:                 ExprSelect(msgvar, '->', 'ReadBytes'),
35990:                 args=[ itervar,
35990:                        ExprCast(ExprAddrOf(ptrvar),
35990:                                 Type('char', const=1, ptrptr=1),
35990:                                 reinterpret=1),
35990:                        ExprBinary(lenvar, '*', ExprSizeof(Type.INTPTR)) ])))
35990:             failifarray.addifstmt(StmtReturn(ExprLiteral.FALSE))
35990: 
35990:             cxxtype = c.otherSideBareType()
35990:             actorptr = deepcopy(cxxtype.T)
35990:             actorptr.ptr = 0
35990:             actorptr.ptrptr = 1
35990: 
35990:             actorconstptr = deepcopy(actorptr)
35990:             actorconstptr.const = 1
35990:             actorconstptr.ptrptr = 0
35990:             actorconstptr.ptrconstptr = 1
35990: 
35990:             case.addstmts([
35990:                 StmtDecl(Decl(Type.UINT32, lenvar.name)),
35990:                 StmtDecl(Decl(Type('intptr_t', const=1, ptr=1), ptrvar.name)),
35990:                 StmtDecl(Decl(cxxtype, valvar.name)),
35990:                 Whitespace.NL,
35990:                 failif,
35990:                 failifarray,
35990:                 StmtExpr(ExprCall(
35990:                     ExprSelect(valvar, '.', 'InsertElementsAt'),
35990:                     args=[ ExprLiteral.ZERO,
35990:                            ExprCast(
35990:                                ExprCast(ptrvar, actorconstptr, reinterpret=1),
35990:                                actorptr,
35990:                                const=1),
35990:                            lenvar ])),
35990:                 StmtExpr(ExprAssn(derefunion, valvar)),
35990:                 StmtReturn(ExprLiteral.TRUE)
35990:             ])
35990: 
35990:         readswitch.addcase(CaseLabel('paramType::'+ c.enum()), case)
35990: 
35990:     defaultcase = StmtBlock()
35990:     defaultcase.addstmts([
35990:         _runtimeAbort('unreached'), StmtReturn(ExprLiteral.FALSE) ])
35990:     readswitch.addcase(DefaultLabel(), defaultcase)
35990: 
35990:     deserialize.addstmts([
35990:         readswitch,
35990:         Whitespace.NL
35990:     ])
35990: 
35990:     # Log(const paramType&, std::wstring* log)
35990:     logvar = ExprVar('aLog')
35990:     logger = MethodDefn(MethodDecl(
35990:         'Log',
35990:         params=[ Decl(Type('paramType', const=1, ref=1), 'aParam'),
35990:                  Decl(Type('std::wstring', ptr=1), logvar.name) ],
35990:         static=1))
35990: 
35990:     # TODO: real implementation
35990:     logger.addstmt(StmtExpr(ExprCall(
35990:         ExprSelect(logvar, '->', 'append'),
35990:         args=[ ExprLiteral.WString('('+ ud.name +')') ])))
35990: 
35990:     pickle.addstmts([
35990:         serialize,
35990:         Whitespace.NL,
35990:         deserialize,
35990:         Whitespace.NL,
35990:         logger
35990:     ])
35990: 
35990:     return (
35990:         [
35990:             Whitespace("""
35990: //-----------------------------------------------------------------------------
35990: // Definition of the IPDL type |union %s|
35990: //
35990: """% (ud.name))
35990:         ]
35990:         + forwarddeclstmts
35990:         + [
35990:             _putInNamespaces(cls, ud.namespaces),
35990:             Whitespace("""
35990: //
35990: // serializer/deserializer
35990: //
35990: """),
35990:             _putInNamespaces(pickle, [ Namespace('IPC') ]),
35990:             Whitespace.NL
35990:         ])
35990: 
35990: 
35990: ##-----------------------------------------------------------------------------
35990: 
35998: class _FindFriends(ipdl.ast.Visitor):
35998:     def __init__(self):
35998:         self.mytype = None              # ProtocolType
35998:         self.vtype = None               # ProtocolType
35998:         self.friends = set()            # set<ProtocolType>
35998: 
35998:     def findFriends(self, ptype):
35998:         self.mytype = ptype
36136:         self.walkDownTheProtocolTree(ptype.toplevel())
35998:         return self.friends
35998: 
35998:     # TODO could make this into a _iterProtocolTreeHelper ...
35998:     def walkDownTheProtocolTree(self, ptype):
36067:         if ptype != self.mytype:
36067:             # don't want to |friend| ourself!
36067:             self.visit(ptype)
35998:         for mtype in ptype.manages:
35998:             self.walkDownTheProtocolTree(mtype)
35998: 
35998:     def visit(self, ptype):
36067:         # |vtype| is the type currently being visited
35998:         savedptype = self.vtype
35998:         self.vtype = ptype
35998:         ptype._p.accept(self)
35998:         self.vtype = savedptype
35998: 
35998:     def visitMessageDecl(self, md):
35998:         for it in self.iterActorParams(md):
35998:             if it.protocol == self.mytype:
35998:                 self.friends.add(self.vtype)
35998: 
35998:     def iterActorParams(self, md):
35998:         for param in md.inParams:
35998:             for actor in ipdl.type.iteractortypes(param.type):
35998:                 yield actor
35998:         for ret in md.outParams:
35998:             for actor in ipdl.type.iteractortypes(ret.type):
35998:                 yield actor
35998: 
35998: 
36137: class _GenerateProtocolActorCode(ipdl.ast.Visitor):
35990:     def __init__(self, myside):
35990:         self.side = myside              # "parent" or "child"
35990:         self.prettyside = myside.title()
35990:         self.clsname = None
35990:         self.protocol = None
36137:         self.hdrfile = None
36137:         self.cppfile = None
35990:         self.ns = None
35990:         self.cls = None
35990:         self.includedActorTypedefs = [ ]
36137:         self.protocolCxxIncludes = [ ]
36137: 
36137:     def lower(self, tu, clsname, cxxHeaderFile, cxxFile):
35990:         self.clsname = clsname
36137:         self.hdrfile = cxxHeaderFile
36137:         self.cppfile = cxxFile
35990:         tu.accept(self)
35990: 
36137:     def standardTypedefs(self):
36137:         return [
36137:             Typedef(Type('IPC::Message'), 'Message'),
36137:             Typedef(Type(self.protocol.channelName()), 'Channel'),
36137:             Typedef(Type(self.protocol.fqListenerName()), 'ChannelListener'),
36137:             Typedef(Type('base::ProcessHandle'), 'ProcessHandle')
36137:         ]
36137: 
36137: 
35990:     def visitTranslationUnit(self, tu):
36137:         self.protocol = tu.protocol
36137: 
36137:         hf = self.hdrfile
36137:         cf = self.cppfile
36137: 
36137:         disclaimer = Whitespace('''//
35990: // Automatically generated by ipdlc.
35990: // Edit at your own risk
35990: //
35990: 
36137: ''')
36137:         # make the C++ header
36137:         hf.addthings(
36137:             [ disclaimer ]
36137:             + _includeGuardStart(hf)
36137:             +[
35990:                 Whitespace.NL,
35990:                 CppDirective(
35990:                     'include',
36137:                     '"'+ _protocolHeaderName(tu.protocol) +'.h"')
36137:             ])
35990: 
35990:         for pinc in tu.protocolIncludes:
35990:             pinc.accept(self)
35990: 
36137:         # this generates the actor's full impl in self.cls
35990:         tu.protocol.accept(self)
35990: 
36137:         clsdecl, clsdefn = _ClassDeclDefn().split(self.cls)
36137: 
36137:         # XXX damn C++ ... return types in the method defn aren't in
36137:         # class scope
36137:         for stmt in clsdefn.stmts:
36137:             if isinstance(stmt, MethodDefn):
36137:                 if stmt.decl.ret and stmt.decl.ret.name == 'Result':
36137:                     stmt.decl.ret.name = clsdecl.name +'::'+ stmt.decl.ret.name
36137: 
36137:         def makeNamespace(p, file):
36137:             if 0 == len(p.namespaces):
36137:                 return file
36137:             ns = Namespace(p.namespaces[-1].name)
36137:             outerns = _putInNamespaces(ns, p.namespaces[:-1])
36137:             file.addthing(outerns)
36137:             return ns
36137: 
36137:         hdrns = makeNamespace(self.protocol, self.hdrfile)
36137:         hdrns.addstmts([
36137:             Whitespace.NL,
36137:             Whitespace.NL,
36137:             clsdecl,
36137:             Whitespace.NL,
36137:             Whitespace.NL
36137:         ])
36137: 
36137:         self.hdrfile.addthings(
36137:             ([
36137:                 Whitespace.NL,
36137:                 CppDirective('if', '0') ])
36137:             + _GenerateSkeletonImpl(
36137:                 _actorName(self.protocol.name, self.side)[1:],
36137:                 self.protocol.namespaces).fromclass(self.cls)
36137:             +([
36137:                 CppDirective('endif', '// if 0'),
36137:                 Whitespace.NL ])
36137:             + _includeGuardEnd(hf))
36137: 
36137:         # make the .cpp file
36137:         cf.addthings((
36137:             [ disclaimer,
36137:               Whitespace.NL,
36137:               CppDirective(
36137:                   'include',
36137:                   '"'+ _protocolHeaderName(self.protocol, self.side) +'.h"'),
36137:               Whitespace.NL
36137:             ]
36137:             + self.protocolCxxIncludes
36137:             + [ Whitespace.NL ]
36137:             + self.standardTypedefs()
36137:             + self.includedActorTypedefs
36137:             + tu.protocol.decl.cxxtypedefs
36137:             + [ Whitespace.NL ]))
36137: 
36137:         cppns = makeNamespace(self.protocol, cf)
36137:         cppns.addstmts([
36137:             Whitespace.NL,
36137:             Whitespace.NL,
36137:             clsdefn,
36137:             Whitespace.NL,
36137:             Whitespace.NL
36137:         ])
35990: 
35990: 
35990:     def visitProtocolInclude(self, pi):
35990:         ip = pi.tu.protocol
35990: 
36137:         self.hdrfile.addthings([
36137:             _makeForwardDecl(ip.decl.type, self.side),
36137:             Whitespace.NL
36137:         ])
36137:         self.protocolCxxIncludes.append(
35990:             CppDirective(
35990:                 'include',
36137:                 '"%s.h"'% (_protocolHeaderName(ip, self.side))))
35990: 
35990:         if ip.decl.fullname is not None:
35990:             self.includedActorTypedefs.append(Typedef(
35990:                 Type(_actorName(ip.decl.fullname, self.prettyside)),
35990:                 _actorName(ip.decl.shortname, self.prettyside)))
35742: 
35742: 
35742:     def visitProtocol(self, p):
36137:         self.hdrfile.addthings([
35990:             CppDirective('ifdef', 'DEBUG'),
35990:             CppDirective('include', '"prenv.h"'),
35990:             CppDirective('endif', '// DEBUG')
35990:         ])
35990: 
35990:         self.protocol = p
35990: 
35990:         # FIXME: all actors impl Iface for now
35990:         if p.decl.type.isManager() or 1:
36137:             self.hdrfile.addthing(CppDirective('include', '"base/id_map.h"'))
36137: 
36137:         self.hdrfile.addthings([
35990:             CppDirective('include', '"'+ p.channelHeaderFile() +'"'),
35990:             Whitespace.NL ])
35742: 
36140:         self.cls = Class(
36140:             self.clsname,
36140:             inherits=[ Inherit(Type(p.fqListenerName()), viz='protected'),
36140:                        Inherit(p.managerInterfaceType(), viz='protected') ],
36140:             abstract=True)
35990: 
35998:         friends = _FindFriends().findFriends(p.decl.type)
35990:         if p.decl.type.isManaged():
35998:             friends.add(p.decl.type.manager)
35998: 
36138:         # |friend| managed actors so that they can call our Dealloc*()
36138:         friends.update(p.decl.type.manages)
36138: 
35998:         for friend in friends:
36137:             self.hdrfile.addthings([
35990:                 Whitespace.NL,
35998:                 _makeForwardDecl(friend, self.prettyside),
35990:                 Whitespace.NL
35990:             ])
35990:             self.cls.addstmts([
35998:                 FriendClassDecl(_actorName(friend.fullname(),
35990:                                            self.prettyside)),
35990:                 Whitespace.NL ])
35990: 
35990:         self.cls.addstmt(Label.PROTECTED)
35990:         for typedef in p.cxxTypedefs():
35990:             self.cls.addstmt(typedef)
35990:         for typedef in self.includedActorTypedefs:
35990:             self.cls.addstmt(typedef)
35990:         self.cls.addstmt(Whitespace.NL)
35990: 
35990:         # interface methods that the concrete subclass has to impl
35990:         for md in p.messageDecls:
35990:             isctor, isdtor = md.decl.type.isCtor(), md.decl.type.isDtor()
35990: 
35990:             if self.receivesMessage(md):
35990:                 # generate Recv/Answer* interface
36138:                 implicit = (not isdtor)
35990:                 recvDecl = MethodDecl(
35990:                     md.recvMethod().name,
35990:                     params=md.makeCxxParams(paramsems='in', returnsems='out',
36138:                                             side=self.side, implicit=implicit),
35990:                     ret=Type.BOOL, virtual=1)
35990: 
35990:                 if isctor or isdtor:
35990:                     defaultRecv = MethodDefn(recvDecl)
35990:                     defaultRecv.addstmt(StmtReturn(ExprLiteral.TRUE))
35990:                     self.cls.addstmt(defaultRecv)
35763:                 else:
35990:                     recvDecl.pure = 1
35990:                     self.cls.addstmt(StmtDecl(recvDecl))
35990: 
36138:         for md in p.messageDecls:
36138:             managed = md.decl.type.constructedType()
36138:             if not p.decl.type.isManagerOf(managed):
36138:                 continue
36138: 
36138:             # add the Alloc/Dealloc interface for managed actors
36138:             actortype = md.actorDecl().bareType(self.side)
36138:             
36138:             self.cls.addstmt(StmtDecl(MethodDecl(
36138:                 _allocMethod(managed).name,
36138:                 params=md.makeCxxParams(side=self.side, implicit=0),
36138:                 ret=actortype,
36138:                 virtual=1, pure=1)))
36138: 
36138:             self.cls.addstmt(StmtDecl(MethodDecl(
36138:                 _deallocMethod(managed).name,
36138:                 params=[ Decl(actortype, 'actor') ],
36138:                 ret=Type.BOOL,
36138:                 virtual=1, pure=1)))
36138: 
36140:         # optional Shutdown() method; default is no-op
36140:         self.cls.addstmts([
36140:             Whitespace.NL,
36140:             MethodDefn(MethodDecl(
36140:                 _destroyMethod().name,
36140:                 params=[ Decl(_DestroyReason.Type(), 'why') ],
36140:                 virtual=1))
36140:         ])
36138: 
35990:         self.cls.addstmt(Whitespace.NL)
35990: 
36137:         self.cls.addstmts((
36137:             [ Label.PRIVATE ]
36137:             + self.standardTypedefs()
36137:             + [ Whitespace.NL ]
36137:         ))
35990: 
35990:         self.cls.addstmt(Label.PUBLIC)
35990:         # Actor()
35990:         ctor = ConstructorDefn(ConstructorDecl(self.clsname))
35742:         if p.decl.type.isToplevel():
35744:             ctor.memberinits = [
35990:                 ExprMemberInit(p.channelVar(), [
35990:                     ExprCall(ExprVar('ALLOW_THIS_IN_INITIALIZER_LIST'),
35990:                              [ ExprVar.THIS ]) ]),
36136:                 ExprMemberInit(p.lastActorIdVar(),
36136:                                [ p.actorIdInit(self.side) ])
35929:             ]
35929:         else:
35929:             ctor.memberinits = [
35990:                 ExprMemberInit(p.idVar(), [ ExprLiteral.ZERO ]) ]
35990: 
36166:         if p.usesShmem():
36166:             ctor.memberinits.append(
36166:                 ExprMemberInit(p.lastShmemIdVar(),
36166:                                [ p.shmemIdInit(self.side) ]))
36166: 
35990:         ctor.addstmt(StmtExpr(ExprCall(ExprVar('MOZ_COUNT_CTOR'),
35990:                                        [ ExprVar(self.clsname) ])))
35990:         self.cls.addstmts([ ctor, Whitespace.NL ])
35990: 
35990:         # ~Actor()
35990:         dtor = DestructorDefn(
35990:             DestructorDecl(self.clsname, virtual=True))
35990:         dtor.addstmt(StmtExpr(ExprCall(ExprVar('MOZ_COUNT_DTOR'),
35990:                                                [ ExprVar(self.clsname) ])))
36039: 
35990:         self.cls.addstmts([ dtor, Whitespace.NL ])
35742: 
35742:         if p.decl.type.isToplevel():
35990:             # Open()
35990:             aTransportVar = ExprVar('aTransport')
35990:             aThreadVar = ExprVar('aThread')
36016:             processvar = ExprVar('aOtherProcess')
35990:             openmeth = MethodDefn(
35990:                 MethodDecl(
35742:                     'Open',
35990:                     params=[ Decl(Type('Channel::Transport', ptr=True),
35990:                                       aTransportVar.name),
36016:                              Decl(Type('ProcessHandle'), processvar.name),
36137:                              Param(Type('MessageLoop', ptr=True),
36137:                                    aThreadVar.name,
36137:                                    default=ExprLiteral.NULL) ],
35990:                     ret=Type.BOOL))
35990: 
36016:             openmeth.addstmts([
36016:                 StmtExpr(ExprAssn(p.otherProcessVar(), processvar)),
36016:                 StmtReturn(ExprCall(ExprSelect(p.channelVar(), '.', 'Open'),
36016:                                     [ aTransportVar, aThreadVar ]))
36016:             ])
36016:             self.cls.addstmts([
36016:                 openmeth,
36016:                 Whitespace.NL ])
35990: 
35990:             # Close()
35990:             closemeth = MethodDefn(MethodDecl('Close'))
35990:             closemeth.addstmt(StmtExpr(
35990:                 ExprCall(ExprSelect(p.channelVar(), '.', 'Close'))))
35990:             self.cls.addstmts([ closemeth, Whitespace.NL ])
35990: 
36138:         if not p.decl.type.isToplevel():
36138:             ## manager()
36138:             managertype = p.managerActorType(self.side, ptr=1)
36138:             managermeth = MethodDefn(MethodDecl(
36138:                 p.managerMethod().name, ret=managertype))
36138:             managermeth.addstmt(StmtReturn(p.managerVar()))
36138: 
36138:             self.cls.addstmts([ managermeth, Whitespace.NL ])
36138: 
36139:         ## managed[T]()
36139:         for managed in p.decl.type.manages:
36139:             arrvar = ExprVar('aArr')
36139:             meth = MethodDefn(MethodDecl(
36139:                 p.managedMethod(managed, self.side).name,
36140:                 params=[ Decl(p.managedVarType(managed, self.side, ref=1),
36139:                               arrvar.name) ],
36139:                 const=1))
36139:             meth.addstmt(StmtExpr(ExprAssn(
36139:                 arrvar, p.managedVar(managed, self.side))))
36139:             self.cls.addstmts([ meth, Whitespace.NL ])
36139: 
35990:         ## OnMessageReceived()/OnCallReceived()
35990: 
35990:         # save these away for use in message handler case stmts
35990:         msgvar = ExprVar('msg')
35990:         self.msgvar = msgvar
35990:         replyvar = ExprVar('reply')
35990:         self.replyvar = replyvar
35990:         
35990:         msgtype = ExprCall(ExprSelect(msgvar, '.', 'type'), [ ])
35990:         self.asyncSwitch = StmtSwitch(msgtype)
35849:         if p.decl.type.toplevel().talksSync():
35990:             self.syncSwitch = StmtSwitch(msgtype)
35849:             if p.decl.type.toplevel().talksRpc():
35990:                 self.rpcSwitch = StmtSwitch(msgtype)
35990: 
35990:         # implement Send*() methods and add dispatcher cases to
35990:         # message switch()es
35742:         for md in p.messageDecls:
35742:             self.visitMessageDecl(md)
35742: 
36134:         # "hidden" message that passes shmem mappings from one process
36134:         # to the other
36134:         if p.usesShmem():
36134:             self.asyncSwitch.addcase(
36134:                 CaseLabel('SHMEM_CREATED_MESSAGE_TYPE'),
36134:                 self.genShmemCreatedHandler())
36134: 
35742:         # add default cases
35990:         default = StmtBlock()
35990:         default.addstmt(StmtReturn(_Result.NotKnown))
35990:         self.asyncSwitch.addcase(DefaultLabel(), default)
35849:         if p.decl.type.toplevel().talksSync():
35990:             self.syncSwitch.addcase(DefaultLabel(), default)
35849:             if p.decl.type.toplevel().talksRpc():
35990:                 self.rpcSwitch.addcase(DefaultLabel(), default)
35990: 
35990: 
35990:         def makeHandlerMethod(name, switch, hasReply, dispatches=0):
35990:             params = [ Decl(Type('Message', const=1, ref=1), msgvar.name) ]
35990:             if hasReply:
35990:                 params.append(Decl(Type('Message', ref=1, ptr=1),
35990:                                    replyvar.name))
35990:             
35990:             method = MethodDefn(MethodDecl(name, virtual=True,
36137:                                            params=params, ret=_Result.Type()))
35990:             if dispatches:
35990:                 routevar = ExprVar('__route')
35990:                 routedecl = StmtDecl(
35990:                     Decl(_actorIdType(), routevar.name),
35990:                     init=ExprCall(ExprSelect(msgvar, '.', 'routing_id')))
35990: 
35990:                 routeif = StmtIf(ExprBinary(
35990:                     ExprVar('MSG_ROUTING_CONTROL'), '!=', routevar))
35990:                 routedvar = ExprVar('__routed')
35990:                 routeif.ifb.addstmt(
35990:                     StmtDecl(Decl(Type('ChannelListener', ptr=1),
35990:                                   routedvar.name),
35990:                              _lookupListener(routevar)))
35990:                 failif = StmtIf(ExprPrefixUnop(routedvar, '!'))
35990:                 failif.ifb.addstmt(StmtReturn(_Result.RouteError))
35990:                 routeif.ifb.addstmt(failif)
35990: 
35990:                 routeif.ifb.addstmt(StmtReturn(ExprCall(
35990:                     ExprSelect(routedvar, '->', name),
35990:                     args=[ ExprVar(p.name) for p in params ])))
35990: 
35990:                 method.addstmts([ routedecl, routeif, Whitespace.NL ])
35990: 
35990:             # bug 509581: don't generate the switch stmt if there
35990:             # is only the default case; MSVC doesn't like that
35990:             if switch.nr_cases > 1:
35990:                 method.addstmt(switch)
35990:             else:
35990:                 method.addstmt(StmtReturn(_Result.NotKnown))
35990: 
35990:             return method
35990: 
35990:         dispatches = (p.decl.type.isToplevel() and p.decl.type.isManager())
35990:         self.cls.addstmts([
35990:             makeHandlerMethod('OnMessageReceived', self.asyncSwitch,
35990:                               hasReply=0, dispatches=dispatches),
35990:             Whitespace.NL
35990:         ])
35849:         if p.decl.type.toplevel().talksSync():
35990:             self.cls.addstmts([
35990:                 makeHandlerMethod('OnMessageReceived', self.syncSwitch,
35990:                                   hasReply=1, dispatches=dispatches),
35990:                 Whitespace.NL
35990:             ])
35849:             if p.decl.type.toplevel().talksRpc():
35990:                 self.cls.addstmts([
35990:                     makeHandlerMethod('OnCallReceived', self.rpcSwitch,
35990:                                       hasReply=1, dispatches=dispatches),
35990:                     Whitespace.NL
35990:                 ])
35990: 
36140:         destroysubtreevar = ExprVar('DestroySubtree')
36140:         deallocsubtreevar = ExprVar('DeallocSubtree')
36140: 
36140:         # OnChannelClose()
36140:         onclose = MethodDefn(MethodDecl('OnChannelClose'))
36140:         onclose.addstmt(StmtExpr(ExprCall(
36140:             destroysubtreevar,
36140:             args=[ _DestroyReason.NormalShutdown ])))
36140:         self.cls.addstmts([ onclose, Whitespace.NL ])
36140: 
36140:         # OnChannelClose()
36140:         onerror = MethodDefn(MethodDecl('OnChannelError'))
36140:         onerror.addstmt(StmtExpr(ExprCall(
36140:             destroysubtreevar,
36140:             args=[ _DestroyReason.AbnormalShutdown ])))
36140:         self.cls.addstmts([ onerror, Whitespace.NL ])
36140: 
35900:         # FIXME: only manager protocols and non-manager protocols with
35900:         # union types need Lookup().  we'll give it to all for the
35900:         # time being (simpler)
35900:         if 1 or p.decl.type.isManager():
35990:             self.cls.addstmts(self.implementManagerIface())
35990: 
36134:         if p.usesShmem():
36134:             self.cls.addstmts(self.makeShmemIface())
36134: 
36136:         ## private methods
36136:         self.cls.addstmt(Label.PRIVATE)
36136: 
36136:         ## FatalError()       
36136:         msgvar = ExprVar('msg')
36136:         fatalerror = MethodDefn(MethodDecl(
36136:             'FatalError',
36136:             params=[ Decl(Type('char', const=1, ptrconst=1), msgvar.name) ],
36136:             const=1))
36136:         fatalerror.addstmts([
36136:             _printErrorMessage('IPDL error:'),
36136:             _printErrorMessage(msgvar),
36136:             Whitespace.NL
36136:         ])
36136:         actorname = _actorName(p.name, self.side)
36136:         if self.side is 'parent':
36136:             # if the error happens on the parent side, the parent
36136:             # kills off the child
36136:             fatalerror.addstmts([
36136:                 _printErrorMessage(
36136:                     '['+ actorname +'] killing child side as a result'),
36136:                 Whitespace.NL
36136:             ])
36136: 
36136:             ifkill = StmtIf(ExprNot(
36136:                 _killProcess(ExprCall(p.otherProcessMethod()))))
36136:             ifkill.addifstmt(
36136:                 _printErrorMessage("  may have failed to kill child!"))
36136:             fatalerror.addstmt(ifkill)
36136:         else:
36136:             # and if it happens on the child side, the child commits
36136:             # seppuko
36136:             fatalerror.addstmt(
36136:                 _runtimeAbort('['+ actorname +'] abort()ing as a result'))
36136:         self.cls.addstmts([ fatalerror, Whitespace.NL ])
36136: 
36140:         ## DestroySubtree(bool normal)
36140:         whyvar = ExprVar('why')
36140:         subtreewhyvar = ExprVar('subtreewhy')
36140:         kidsvar = ExprVar('kids')
36140:         ivar = ExprVar('i')
36140:         ithkid = ExprIndex(kidsvar, ivar)
36140: 
36140:         destroysubtree = MethodDefn(MethodDecl(
36140:             destroysubtreevar.name,
36140:             params=[ Decl(_DestroyReason.Type(), whyvar.name) ]))
36140: 
36140:         if p.decl.type.isManager():
36140:             # only declare this for managers to avoid unused var warnings
36140:             destroysubtree.addstmts([
36140:                 StmtDecl(
36140:                     Decl(_DestroyReason.Type(), subtreewhyvar.name),
36140:                     init=ExprConditional(
36140:                         ExprBinary(_DestroyReason.Deletion, '==', whyvar),
36140:                         _DestroyReason.AncestorDeletion, whyvar)),
36140:                 Whitespace.NL
36140:             ])
36140: 
36140:         for managed in p.decl.type.manages:
36140:             foreachdestroy = StmtFor(
36140:                 init=Param(Type.UINT32, ivar.name, ExprLiteral.ZERO),
36140:                 cond=ExprBinary(ivar, '<', _callCxxArrayLength(kidsvar)),
36140:                 update=ExprPrefixUnop(ivar, '++'))
36140:             foreachdestroy.addstmt(StmtExpr(ExprCall(
36140:                 ExprSelect(ithkid, '->', destroysubtreevar.name),
36140:                 args=[ subtreewhyvar ])))
36140: 
36140:             block = StmtBlock()
36140:             block.addstmts([
36140:                 Whitespace(
36140:                     '// Recursively shutting down %s kids\n'% (managed.name()),
36140:                     indent=1),
36140:                 StmtDecl(
36140:                     Decl(p.managedVarType(managed, self.side), kidsvar.name),
36140:                     init=p.managedVar(managed, self.side)),
36140:                 foreachdestroy,
36140:             ])
36140:             destroysubtree.addstmt(block)
36140:         # finally, destroy "us"
36140:         destroysubtree.addstmt(StmtExpr(
36140:             ExprCall(_destroyMethod(), args=[ whyvar ])))
36140: 
36140:         # XXX kick off DeallocSubtree() here rather than in a new
36140:         # event because that may be tricky on shutdown.  revisit if
36140:         # need be
36140:         if p.decl.type.isToplevel():
36140:             destroysubtree.addstmt(StmtExpr(ExprCall(deallocsubtreevar)))
36140:         
36140:         self.cls.addstmts([ destroysubtree, Whitespace.NL ])
36140: 
36140:         ## DeallocSubtree()
36140:         deallocsubtree = MethodDefn(MethodDecl(deallocsubtreevar.name))
36140:         for managed in p.decl.type.manages:
36140:             foreachrecurse = StmtFor(
36140:                 init=Param(Type.UINT32, ivar.name, ExprLiteral.ZERO),
36140:                 cond=ExprBinary(ivar, '<', _callCxxArrayLength(kidsvar)),
36140:                 update=ExprPrefixUnop(ivar, '++'))
36140:             foreachrecurse.addstmt(StmtExpr(ExprCall(
36140:                 ExprSelect(ithkid, '->', deallocsubtreevar.name))))
36140: 
36140:             foreachdealloc = StmtFor(
36140:                 init=Param(Type.UINT32, ivar.name, ExprLiteral.ZERO),
36140:                 cond=ExprBinary(ivar, '<', _callCxxArrayLength(kidsvar)),
36140:                 update=ExprPrefixUnop(ivar, '++'))
36140:             foreachdealloc.addstmts([
36140:                 StmtExpr(ExprCall(_deallocMethod(managed),
36140:                                   args=[ ithkid ]))
36140:             ])
36140: 
36140:             block = StmtBlock()
36140:             block.addstmts([
36140:                 Whitespace(
36140:                     '// Recursively deleting %s kids\n'% (managed.name()),
36140:                     indent=1),
36140:                 StmtDecl(
36140:                     Decl(p.managedVarType(managed, self.side, ref=1),
36140:                          kidsvar.name),
36140:                     init=p.managedVar(managed, self.side)),
36140:                 foreachrecurse,
36140:                 Whitespace.NL,
36140:                 # no need to copy |kids| here; we're the ones deleting
36140:                 # stragglers, no outside C++ is being invoked (except
36140:                 # Dealloc(subactor))
36140:                 foreachdealloc,
36140:                 StmtExpr(_callCxxArrayClear(p.managedVar(managed, self.side))),
36140: 
36140:             ])
36140:             deallocsubtree.addstmt(block)
36140:         # don't delete outselves: either the manager will do it, or
36140:         # we're toplevel
36140:         self.cls.addstmts([ deallocsubtree, Whitespace.NL ])
36140:         
36136:         ## private members
36136:         self.cls.addstmt(StmtDecl(Decl(p.channelType(), 'mChannel')))
35990:         if p.decl.type.isToplevel():
35990:             self.cls.addstmts([
35990:                 StmtDecl(Decl(Type('IDMap', T=Type('ChannelListener')),
35990:                               p.actorMapVar().name)),
36016:                 StmtDecl(Decl(_actorIdType(), p.lastActorIdVar().name)),
36016:                 StmtDecl(Decl(Type('ProcessHandle'),
36016:                               p.otherProcessVar().name))
35990:             ])
35990:         elif p.decl.type.isManaged():
35990:             self.cls.addstmts([
35990:                 StmtDecl(Decl(_actorIdType(), p.idVar().name)),
36138:                 StmtDecl(Decl(p.managerActorType(self.side, ptr=1),
36138:                               p.managerVar().name))
35990:             ])
36134:         if p.usesShmem():
36134:             self.cls.addstmts([
36134:                 StmtDecl(Decl(Type('IDMap', T=_rawShmemType()),
36134:                               p.shmemMapVar().name)),
36134:                 StmtDecl(Decl(_shmemIdType(), p.lastShmemIdVar().name))
36134:             ])
35990: 
36139:         for managed in p.decl.type.manages:
36139:             self.cls.addstmts([
36139:                 Whitespace('// Sorted by pointer value\n', indent=1),
36139:                 StmtDecl(Decl(
36140:                     p.managedVarType(managed, self.side),
36139:                     p.managedVar(managed, self.side).name)) ])
36139: 
35990:     def implementManagerIface(self):
35990:         p = self.protocol
35990:         routedvar = ExprVar('aRouted')
35990:         idvar = ExprVar('aId')
35990:         listenertype = Type('ChannelListener', ptr=1)
35990: 
35990:         register = MethodDefn(MethodDecl(
35990:             p.registerMethod().name,
35990:             params=[ Decl(listenertype, routedvar.name) ],
35990:             ret=_actorIdType(), virtual=1))
35990:         registerid = MethodDefn(MethodDecl(
35990:             p.registerIDMethod().name,
35990:             params=[ Decl(listenertype, routedvar.name),
35990:                      Decl(_actorIdType(), idvar.name) ],
35990:             ret=_actorIdType(),
35744:             virtual=1))
35990:         lookup = MethodDefn(MethodDecl(
35990:             p.lookupIDMethod().name,
35990:             params=[ Decl(_actorIdType(), idvar.name) ],
35990:             ret=listenertype, virtual=1))
35990:         unregister = MethodDefn(MethodDecl(
35990:             p.unregisterMethod().name,
35990:             params=[ Decl(_actorIdType(), idvar.name) ],
35812:             virtual=1))
36016:         otherprocess = MethodDefn(MethodDecl(
36016:             p.otherProcessMethod().name,
36016:             ret=Type('ProcessHandle'),
36136:             const=1,
36016:             virtual=1))
35990: 
35744:         if p.decl.type.isToplevel():
35990:             tmpvar = ExprVar('tmp')
35990:             register.addstmts([
35990:                 StmtDecl(Decl(_actorIdType(), tmpvar.name),
35990:                          p.nextActorIdExpr(self.side)),
35990:                 StmtExpr(ExprCall(
35990:                     ExprSelect(p.actorMapVar(), '.', 'AddWithID'),
35990:                     [ routedvar, tmpvar ])),
35990:                 StmtReturn(tmpvar)
35990:             ])
35990:             registerid.addstmts([
35990:                 StmtExpr(
35990:                     ExprCall(ExprSelect(p.actorMapVar(), '.', 'AddWithID'),
35990:                              [ routedvar, idvar ])),
35990:                 StmtReturn(idvar)
35990:             ])
35990:             lookup.addstmt(StmtReturn(
35990:                 ExprCall(ExprSelect(p.actorMapVar(), '.', 'Lookup'),
35990:                          [ idvar ])))
35990:             unregister.addstmt(StmtReturn(
35990:                 ExprCall(ExprSelect(p.actorMapVar(), '.', 'Remove'),
35990:                          [ idvar ])))
36016:             otherprocess.addstmt(StmtReturn(p.otherProcessVar()))
35990:         # delegate registration to manager
35744:         else:
35990:             register.addstmt(StmtReturn(ExprCall(
35990:                 ExprSelect(p.managerVar(), '->', p.registerMethod().name),
35990:                 [ routedvar ])))
35990:             registerid.addstmt(StmtReturn(ExprCall(
35990:                 ExprSelect(p.managerVar(), '->', p.registerIDMethod().name),
35990:                 [ routedvar, idvar ])))
35990:             lookup.addstmt(StmtReturn(ExprCall(
35990:                 ExprSelect(p.managerVar(), '->', p.lookupIDMethod().name),
35990:                 [ idvar ])))
35990:             unregister.addstmt(StmtReturn(ExprCall(
35990:                 ExprSelect(p.managerVar(), '->', p.unregisterMethod().name),
35990:                 [ idvar ])))
36016:             otherprocess.addstmt(StmtReturn(ExprCall(
36016:                 ExprSelect(p.managerVar(), '->',
36016:                            p.otherProcessMethod().name))))
36016: 
36016:         return [ register,
36016:                  registerid,
36016:                  lookup,
36016:                  unregister,
36016:                  otherprocess,
36016:                  Whitespace.NL ]
36016: 
35990: 
36134:     def makeShmemIface(self):
36134:         p = self.protocol
36134:         idvar = ExprVar('aId')
36134: 
36134:         # bool AllocShmem(size_t size, Shmem* outmem):
36134:         #   nsAutoPtr<shmem_t> shmem(Shmem::Alloc(size));
36134:         #   if (!shmem)
36134:         #     return false
36134:         #   shmemhandle_t handle;
36134:         #   if (!shmem->ShareToProcess(subprocess, &handle))
36134:         #     return false;
36134:         #   Shmem::id_t id = RegisterShmem(shmem);
36134:         #   Message* msg = new __internal__ipdl__ShmemCreated(
36134:         #      mRoutingId, handle, id, size);
36134:         #   if (!Send(msg))
36134:         #     return false;
36134:         #   *aMem = Shmem(shmem, id);
36134:         #   return true;
36134:         sizevar = ExprVar('aSize')
36134:         memvar = ExprVar('aMem')
36134:         allocShmem = MethodDefn(MethodDecl(
36134:             'AllocShmem',
36134:             params=[ Decl(Type.SIZE, sizevar.name),
36134:                      Decl(_shmemType(ptr=1), memvar.name) ],
36134:             ret=Type.BOOL))
36134: 
36134:         rawvar = ExprVar('rawmem')
36134:         allocShmem.addstmt(StmtDecl(
36134:             Decl(_autoptr(_rawShmemType()), rawvar.name),
36134:             initargs=[ _shmemAlloc(sizevar) ]))
36134:         failif = StmtIf(ExprNot(rawvar))
36134:         failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
36134:         allocShmem.addstmt(failif)
36134: 
36134:         handlevar = ExprVar('handle')
36134:         allocShmem.addstmt(StmtDecl(
36134:             Decl(_shmemHandleType(), handlevar.name)))
36134:         failif = StmtIf(ExprNot(ExprCall(
36134:             ExprSelect(rawvar, '->', 'ShareToProcess'),
36134:             args=[ ExprCall(p.otherProcessMethod()),
36134:                    ExprAddrOf(handlevar) ])))
36134:         failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
36134:         allocShmem.addstmt(failif)
36134: 
36134:         allocShmem.addstmt(StmtDecl(
36134:             Decl(_shmemIdType(), idvar.name),
36134:             ExprCall(p.registerShmemVar(), args=[ rawvar ])))
36134: 
36134:         msgvar = ExprVar('msg')
36134:         allocShmem.addstmt(StmtDecl(
36134:             Decl(Type('Message', ptr=1), msgvar.name),
36134:             ExprNew(Type(_shmemCreatedMsgVar().name),
36134:                     args=[ p.routingId(), handlevar, idvar, sizevar ])))
36134: 
36134:         failif = StmtIf(ExprNot(ExprCall(
36134:             ExprSelect(p.channelVar(), p.channelSel(), 'Send'),
36134:             args=[ msgvar ])))
36134:         failif.addifstmts([
36134:             StmtExpr(ExprCall(p.unregisterShmemVar(), args=[ idvar ])),
36134:             StmtReturn(ExprLiteral.FALSE)
36134:         ])
36134:         allocShmem.addstmt(failif)
36134: 
36134:         allocShmem.addstmts([
36134:             StmtExpr(ExprAssn(
36134:                 ExprDeref(memvar), _shmemCtor(_autoptrForget(rawvar), idvar))),
36134:             StmtReturn(ExprLiteral.TRUE)
36134:         ])
36134: 
36134:         # TODO: DeallocShmem().  not needed until actors outlast their
36134:         # shmem mappings.
36134:         
36134:         # This code is pretty similar to |implementManagerIface()|
36134:         lookupShmem = MethodDefn(MethodDecl(
36134:             p.lookupShmemVar().name,
36134:             params=[ Decl(_shmemIdType(), idvar.name) ],
36134:             ret=_rawShmemType(ptr=1)))
36134:         lookupShmem.addstmt(StmtReturn(ExprCall(
36134:             ExprSelect(p.shmemMapVar(), '.', 'Lookup'),
36134:             args=[ idvar ])))
36134: 
36134:         mapvar = ExprVar('aMap')
36134:         tmpvar = ExprVar('tmp')
36134:         registerShmem = MethodDefn(MethodDecl(
36134:             p.registerShmemVar().name,
36134:             params=[ Decl(_rawShmemType(ptr=1), mapvar.name) ],
36134:             ret=_shmemIdType()))
36134:         registerShmem.addstmts([
36134:             StmtDecl(Decl(_shmemIdType(), tmpvar.name),
36134:                      p.nextShmemIdExpr(self.side)),
36134:             StmtExpr(ExprCall(ExprSelect(p.shmemMapVar(), '.', 'AddWithID'),
36134:                               [ mapvar, tmpvar ])),
36134:             StmtReturn(tmpvar)
36134:         ])
36134: 
36134:         registerShmemById = MethodDefn(MethodDecl(
36134:             p.registerShmemIdVar().name,
36134:             params=[ Decl(_rawShmemType(ptr=1), mapvar.name),
36134:                      Decl(_shmemIdType(), idvar.name) ],
36134:             ret=_shmemIdType()))
36134:         registerShmemById.addstmts([
36134:             StmtExpr(ExprCall(ExprSelect(p.shmemMapVar(), '.', 'AddWithID'),
36134:                               [ mapvar, idvar ])),
36134:             StmtReturn(idvar)
36134:         ])
36134: 
36134:         unregisterShmem = MethodDefn(MethodDecl(
36134:             p.unregisterShmemVar().name,
36134:             params=[ Decl(_shmemIdType(), idvar.name) ]))
36134:         unregisterShmem.addstmts([
36134:             StmtExpr(ExprCall(ExprSelect(p.shmemMapVar(), '.', 'Remove'),
36134:                               args=[ idvar ]))
36134:         ])
36134: 
36134:         return [
36134:             Whitespace('// Methods for managing shmem\n', indent=1),
36134:             allocShmem,
36134:             Whitespace.NL,
36134:             Label.PRIVATE,
36134:             lookupShmem,
36134:             registerShmem,
36134:             registerShmemById,
36134:             unregisterShmem,
36134:             Whitespace.NL
36134:         ]
36134: 
36134:     def genShmemCreatedHandler(self):
36134:         case = StmtBlock()                                          
36134: 
36134:         handlevar = ExprVar('handle')
36134:         idvar = ExprVar('id')
36134:         sizevar = ExprVar('size')
36134:         rawvar = ExprVar('rawmem')
36134:         failif = StmtIf(ExprNot(ExprCall(
36134:             ExprVar(_shmemCreatedMsgVar().name +'::Read'),
36134:             args=[ ExprAddrOf(self.msgvar),
36134:                    ExprAddrOf(handlevar),
36134:                    ExprAddrOf(idvar),
36134:                    ExprAddrOf(sizevar) ])))
36134:         failif.addifstmt(StmtReturn(_Result.PayloadError))
36134: 
36134:         case.addstmts([
36134:             StmtDecl(Decl(_shmemHandleType(), handlevar.name)),
36134:             StmtDecl(Decl(_shmemIdType(), idvar.name)),
36134:             StmtDecl(Decl(Type.SIZE, sizevar.name)),
36134:             Whitespace.NL,
36134:             failif,
36134:             Whitespace.NL,
36134:             StmtDecl(Decl(_autoptr(_rawShmemType()), rawvar.name),
36134:                      initargs=[ _shmemOpenExisting(sizevar, handlevar) ])
36134:         ])
36134: 
36134:         failif = StmtIf(ExprNot(rawvar))
36134:         failif.addifstmt(StmtReturn(_Result.ValuError))
36134: 
36134:         case.addstmts([
36134:             failif,
36134:             StmtExpr(ExprCall(self.protocol.registerShmemIdVar(),
36134:                               args=[ _autoptrForget(rawvar), idvar ])),
36134:             Whitespace.NL,
36134:             StmtReturn(_Result.Processed)
36134:         ])
36134: 
36134:         return case
36134: 
35990: 
35990:     ##-------------------------------------------------------------------------
35990:     ## The next few functions are the crux of the IPDL code generator.
35990:     ## They generate code for all the nasty work of message
35990:     ## serialization/deserialization and dispatching handlers for
35990:     ## received messages.
35990:     ##
35742:     def visitMessageDecl(self, md):
35990:         isctor = md.decl.type.isCtor()
35990:         isdtor = md.decl.type.isDtor()
35990:         sems = md.decl.type.sendSemantics
35990:         sendmethod = None
35990:         helpermethod = None
35990:         recvlbl, recvcase = None, None
35990: 
35990:         def addRecvCase(lbl, case):
35990:             if sems is ipdl.ast.ASYNC:
35990:                 self.asyncSwitch.addcase(lbl, case)
35990:             elif sems is ipdl.ast.SYNC:
35990:                 self.syncSwitch.addcase(lbl, case)
35990:             elif sems is ipdl.ast.RPC:
35990:                 self.rpcSwitch.addcase(lbl, case)
35990:             else: assert 0
35742: 
35742:         if self.sendsMessage(md):
35990:             isasync = (sems is ipdl.ast.ASYNC)
35990: 
35990:             if isctor:
35990:                 self.cls.addstmts([ self.genHelperCtor(md), Whitespace.NL ])
35990: 
35990:             if isctor and isasync:
35990:                 sendmethod, (recvlbl, recvcase) = self.genAsyncCtor(md)
35990:             elif isctor:
35990:                 sendmethod = self.genBlockingCtorMethod(md)
35990:             elif isdtor and isasync:
35990:                 sendmethod, (recvlbl, recvcase) = self.genAsyncDtor(md)
35990:             elif isdtor:
35990:                 sendmethod = self.genBlockingDtorMethod(md)
35990:             elif isasync:
35990:                 sendmethod = self.genAsyncSendMethod(md)
35744:             else:
35990:                 sendmethod = self.genBlockingSendMethod(md)
36138: 
36138:         # XXX figure out what to do here
36138:         if isdtor and md.decl.type.constructedType().isToplevel():
36138:             sendmethod = None
36138:                 
35990:         if sendmethod is not None:
35990:             self.cls.addstmts([ sendmethod, Whitespace.NL ])
35990:         if recvcase is not None:
35990:             addRecvCase(recvlbl, recvcase)
35990:             recvlbl, recvcase = None, None
35990: 
35990:         if self.receivesMessage(md):
35990:             if isctor:
35990:                 recvlbl, recvcase = self.genCtorRecvCase(md)
35990:             elif isdtor:
35990:                 recvlbl, recvcase = self.genDtorRecvCase(md)
35990:             else:
35990:                 recvlbl, recvcase = self.genRecvCase(md)
36138: 
36138:             # XXX figure out what to do here
36138:             if isdtor and md.decl.type.constructedType().isToplevel():
36138:                 return
36138: 
35990:             addRecvCase(recvlbl, recvcase)
35990: 
35990: 
35990:     def genAsyncCtor(self, md):
35990:         actor = md.actorDecl()
35990:         method = MethodDefn(self.makeSendMethodDecl(md))
35990:         method.addstmts(self.ctorPrologue(md) + [ Whitespace.NL ])
35990: 
36136:         msgvar, stmts = self.makeMessage(md, errfnSendCtor)
36027:         sendok, sendstmts = self.sendAsync(md, msgvar)
35990:         method.addstmts(
35990:             stmts
36027:             + sendstmts
36027:             + self.failCtorIf(md, ExprNot(sendok))
35990:             + [ StmtReturn(actor.var()) ])
35990: 
35990:         lbl = CaseLabel(md.pqReplyId())
35990:         case = StmtBlock()
35990:         case.addstmt(StmtReturn(_Result.Processed))
35990:         # TODO not really sure what to do with async ctor "replies" yet.
35990:         # destroy actor if there was an error?  tricky ...
35990: 
35990:         return method, (lbl, case)
35990: 
35990: 
35990:     def genBlockingCtorMethod(self, md):
35990:         actor = md.actorDecl()
35990:         method = MethodDefn(self.makeSendMethodDecl(md))
35990:         method.addstmts(self.ctorPrologue(md) + [ Whitespace.NL ])
35990: 
36136:         msgvar, stmts = self.makeMessage(md, errfnSendCtor)
35990: 
35990:         replyvar = self.replyvar
36027:         sendok, sendstmts = self.sendBlocking(md, msgvar, replyvar)
35990:         method.addstmts(
35990:             stmts
35990:             + [ Whitespace.NL,
35990:                 StmtDecl(Decl(Type('Message'), replyvar.name)) ]
36027:             + sendstmts
36027:             + self.failCtorIf(md, ExprNot(sendok)))
36027: 
36027:         readok, stmts = self.deserializeReply(
36136:             md, ExprAddrOf(replyvar), self.side, errfnSendCtor)
35990:         method.addstmts(
35990:             stmts
36027:             + self.failCtorIf(md, ExprNot(readok))
35990:             + [ StmtReturn(actor.var()) ])
35990: 
35990:         return method
35990: 
35990: 
36136:     def ctorPrologue(self, md, errfn=ExprLiteral.NULL, idexpr=None):
35990:         actorvar = md.actorDecl().var()
35990: 
35990:         if idexpr is None:
35990:             idexpr = ExprCall(self.protocol.registerMethod(),
35990:                               args=[ actorvar ])
35990:         else:
35990:             idexpr = ExprCall(self.protocol.registerIDMethod(),
35990:                               args=[ actorvar, idexpr ])
35990: 
35990:         return [
36136:             self.failIfNullActor(actorvar, errfn),
35990:             StmtExpr(ExprAssn(_actorId(actorvar), idexpr)),
35990:             StmtExpr(ExprAssn(_actorManager(actorvar), ExprVar.THIS)),
35990:             StmtExpr(ExprAssn(_actorChannel(actorvar),
35990:                               self.protocol.channelForSubactor())),
36139:             StmtExpr(_callCxxArrayInsertSorted(
36139:                 self.protocol.managedVar(md.decl.type.constructedType(),
36139:                                          self.side),
36139:                 actorvar))
35990:         ]
35990: 
35990:     def failCtorIf(self, md, cond):
35990:         actorvar = md.actorDecl().var()
35990:         failif = StmtIf(cond)
36139:         failif.addifstmts(
36139:             self.unregisterActor(actorvar)
36143:             + [ StmtExpr(ExprCall(_deallocMethod(md.decl.type.constructedType()), args=[actorvar])),
36139:                 StmtExpr(_callCxxArrayRemoveSorted(
36139:                     self.protocol.managedVar(
36139:                         md.decl.type.constructedType(), self.side),
36605:                     actorvar)),
36605:                 StmtReturn(ExprLiteral.NULL),
36139:             ])
35990:         return [ failif ]
35990: 
35990:     def genHelperCtor(self, md):
35990:         helperdecl = self.makeSendMethodDecl(md)
35990:         helperdecl.params = helperdecl.params[1:]
35990:         helper = MethodDefn(helperdecl)
35990: 
35990:         callctor = self.callAllocActor(md, retsems='out')
35990:         helper.addstmt(StmtReturn(ExprCall(
35990:             ExprVar(helperdecl.name), args=[ callctor ] + callctor.args)))
35990:         return helper
35990: 
35990: 
35990:     def genAsyncDtor(self, md):
35990:         actor = md.actorDecl()
36138:         actorvar = actor.var()
36138:         method = MethodDefn(self.makeDtorMethodDecl(md))
35990: 
35990:         method.addstmts(self.dtorPrologue(actor.var()))
36138:         method.addstmts(self.dtorPrologue(actorvar))
36138: 
36138:         msgvar, stmts = self.makeMessage(md, errfnSendDtor, actorvar)
36138:         sendok, sendstmts = self.sendAsync(md, msgvar, actorvar)
35990:         method.addstmts(
35990:             stmts
36027:             + sendstmts
36027:             + [ Whitespace.NL ]
36138:             + self.dtorEpilogue(md, actor.var())
36027:             + [ StmtReturn(sendok) ])
35990: 
35990:         lbl = CaseLabel(md.pqReplyId())
35990:         case = StmtBlock()
35990:         case.addstmt(StmtReturn(_Result.Processed))
35990:         # TODO if the dtor is "inherently racy", keep the actor alive
35990:         # until the other side acks
35990: 
35990:         return method, (lbl, case)
35990: 
35990: 
35990:     def genBlockingDtorMethod(self, md):
35990:         actor = md.actorDecl()
36138:         actorvar = actor.var()
36138:         method = MethodDefn(self.makeDtorMethodDecl(md))
36138: 
36138:         method.addstmts(self.dtorPrologue(actorvar))
36138: 
36138:         msgvar, stmts = self.makeMessage(md, errfnSendDtor, actorvar)
35990: 
35990:         replyvar = self.replyvar
36138:         sendok, sendstmts = self.sendBlocking(md, msgvar, replyvar, actorvar)
35990:         method.addstmts(
35990:             stmts
35990:             + [ Whitespace.NL,
36027:                 StmtDecl(Decl(Type('Message'), replyvar.name)) ]
36027:             + sendstmts)
36027: 
36027:         readok, destmts = self.deserializeReply(
36136:             md, ExprAddrOf(replyvar), self.side, errfnSend)
36027:         ifsendok = StmtIf(sendok)
35990:         ifsendok.addifstmts(destmts)
35990:         ifsendok.addifstmts([ Whitespace.NL,
36027:                               StmtExpr(ExprAssn(sendok, readok, '&=')) ])
35990: 
35990:         method.addstmts(
35990:             [ ifsendok ]
36138:             + self.dtorEpilogue(md, actor.var())
36027:             + [ Whitespace.NL, StmtReturn(sendok) ])
35990: 
35990:         return method
35990: 
35990:     def dtorPrologue(self, actorexpr):
35990:         return [ self.failIfNullActor(actorexpr), Whitespace.NL ]
35990: 
36138:     def dtorEpilogue(self, md, actorexpr):
35990:         return (self.unregisterActor(actorexpr)
36140:                 + [ StmtExpr(self.callActorDestroy(actorexpr)) ]
36140:                 + [ StmtExpr(self.callRemoveActor(actorexpr)) ]
36140:                 + [ StmtExpr(self.callDeallocActor(md, actorexpr))
36139:                 ])
35990: 
35990:     def genAsyncSendMethod(self, md):
35990:         method = MethodDefn(self.makeSendMethodDecl(md))
36136:         msgvar, stmts = self.makeMessage(md, errfnSend)
36027:         sendok, sendstmts = self.sendAsync(md, msgvar)
36027:         method.addstmts(stmts
36027:                         +[ Whitespace.NL ]
36027:                         + sendstmts
36027:                         +[ StmtReturn(sendok) ])
35990:         return method
35990: 
35990: 
36138:     def genBlockingSendMethod(self, md, fromActor=None):
35990:         method = MethodDefn(self.makeSendMethodDecl(md))
35990: 
36138:         msgvar, serstmts = self.makeMessage(md, errfnSend, fromActor)
35990:         replyvar = self.replyvar
35990: 
36027:         sendok, sendstmts = self.sendBlocking(md, msgvar, replyvar)
36027:         failif = StmtIf(ExprNot(sendok))
35990:         failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
35990: 
35990:         readok, desstmts = self.deserializeReply(
36136:             md, ExprAddrOf(replyvar), self.side, errfnSend)
35990: 
35990:         method.addstmts(
35990:             serstmts
35990:             + [ Whitespace.NL,
36027:                 StmtDecl(Decl(Type('Message'), replyvar.name)) ]
36027:             + sendstmts
36027:             + [ failif ]
35990:             + desstmts
36027:             + [ Whitespace.NL,
36027:                 StmtReturn(readok) ])
35990: 
35990:         return method
35990: 
35990: 
35990:     def genCtorRecvCase(self, md):
35990:         lbl = CaseLabel(md.pqMsgId())
35990:         case = StmtBlock()
35990:         actorvar = md.actorDecl().var()
35990: 
36136:         actorhandle, readok, stmts = self.deserializeMessage(md, self.side,
36136:                                                              errfnRecv)
35990:         failif = StmtIf(ExprNot(readok))
35990:         failif.addifstmt(StmtReturn(_Result.PayloadError))
35990: 
35990:         case.addstmts(
35990:             stmts
35990:             + [ failif, Whitespace.NL ]
35990:             + [ StmtDecl(Decl(r.bareType(self.side), r.var().name))
35990:                 for r in md.returns ]
35990:             # alloc the actor, register it under the foreign ID
35990:             + [ StmtExpr(ExprAssn(
35990:                 actorvar,
35990:                 self.callAllocActor(md, retsems='in'))) ]
36136:             + self.ctorPrologue(md, errfn=_Result.ValuError,
35990:                                 idexpr=_actorHId(actorhandle))
35990:             + [ Whitespace.NL ]
35990:             + self.invokeRecvHandler(md)
36136:             + self.makeReply(md, errfnRecv)
35990:             + [ Whitespace.NL,
35990:                 StmtReturn(_Result.Processed) ])
35990: 
35990:         return lbl, case
35990: 
35990: 
35990:     def genDtorRecvCase(self, md):
35990:         lbl = CaseLabel(md.pqMsgId())
35990:         case = StmtBlock()
35990: 
36136:         readok, stmts = self.deserializeMessage(md, self.side, errfnRecv)
35990:         failif = StmtIf(ExprNot(readok))
35990:         failif.addifstmt(StmtReturn(_Result.PayloadError))
35990: 
35990:         case.addstmts(
35990:             stmts
35990:             + [ failif, Whitespace.NL ]
35990:             + [ StmtDecl(Decl(r.bareType(self.side), r.var().name))
35990:                 for r in md.returns ]
36138:             + self.invokeRecvHandler(md, implicit=0)
35990:             + [ Whitespace.NL ]
36138:             + self.dtorEpilogue(md, md.actorDecl().var())
36136:             + self.makeReply(md, errfnRecv)
35990:             + [ Whitespace.NL,
35990:                 StmtReturn(_Result.Processed) ])
35990:         
35990:         return lbl, case
35990: 
35990: 
35990:     def genRecvCase(self, md):
35990:         lbl = CaseLabel(md.pqMsgId())
35990:         case = StmtBlock()
35990: 
36136:         readok, stmts = self.deserializeMessage(md, self.side, errfn=errfnRecv)
35990:         failif = StmtIf(ExprNot(readok))
35990:         failif.addifstmt(StmtReturn(_Result.PayloadError))
35990: 
35990:         case.addstmts(
35990:             stmts
35990:             + [ failif, Whitespace.NL ]
35990:             + [ StmtDecl(Decl(r.bareType(self.side), r.var().name))
35990:                 for r in md.returns ]
35990:             + self.invokeRecvHandler(md)
35990:             + [ Whitespace.NL ]
36136:             + self.makeReply(md, errfnRecv)
35990:             + [ StmtReturn(_Result.Processed) ])
35990: 
35990:         return lbl, case
35990: 
35990: 
35990:     # helper methods
35990: 
35990:     def failIfNullActor(self, actorExpr, retOnNull=ExprLiteral.FALSE):
35990:         failif = StmtIf(ExprNot(actorExpr))
35990:         failif.addifstmt(StmtReturn(retOnNull))
35990:         return failif
35990: 
35990:     def unregisterActor(self, actorexpr):
36138:         return [ StmtExpr(ExprCall(self.protocol.unregisterMethod(actorexpr),
36136:                                    args=[ _actorId(actorexpr) ])),
36136:                  StmtExpr(ExprAssn(_actorId(actorexpr), _FREED_ACTOR_ID)) ]
36136: 
36138:     def makeMessage(self, md, errfn, fromActor=None):
35990:         msgvar = self.msgvar
35990:         stmts = [ StmtDecl(Decl(Type(md.pqMsgClass(), ptr=1), msgvar.name)),
35990:                   Whitespace.NL ]
35990:         msgCtorArgs = [ ]
35990: 
35990:         for param in md.params:
36136:             arg, sstmts = param.serialize(param.var(), self.side, errfn)
35990:             msgCtorArgs.append(arg)
35990:             stmts.extend(sstmts)
35990: 
35990:         stmts.extend([
35990:             StmtExpr(ExprAssn(
35990:                 msgvar,
35990:                 ExprNew(Type(md.pqMsgClass()), args=msgCtorArgs))) ]
36138:             + self.setMessageFlags(md, msgvar, reply=0, actor=fromActor))
35990: 
35990:         return msgvar, stmts
35990: 
35990: 
36136:     def makeReply(self, md, errfn):
35990:         # TODO special cases for async ctor/dtor replies
35990:         if md.decl.type.isAsync():
35990:             return [ ]
35990: 
35990:         replyvar = self.replyvar
35990:         stmts = [ ]
35990:         replyCtorArgs = [ ]
35990:         for ret in md.returns:
36136:             arg, sstmts = ret.serialize(ret.var(), self.side, errfn)
35990:             replyCtorArgs.append(arg)
35990:             stmts.extend(sstmts)
35990: 
35990:         stmts.extend([
35990:             StmtExpr(ExprAssn(
35990:                 replyvar,
35990:                 ExprNew(Type(md.pqReplyClass()), args=replyCtorArgs))) ]
36027:             + self.setMessageFlags(md, replyvar, reply=1)
36027:             +[ self.logMessage(md, md.replyCast(replyvar), 'Sending reply ') ])
35990:         
35990:         return stmts
35990: 
35990: 
36138:     def setMessageFlags(self, md, var, reply, actor=None):
35990:         stmts = [ StmtExpr(ExprCall(
35990:             ExprSelect(var, '->', 'set_routing_id'),
36138:             args=[ self.protocol.routingId(actor) ])) ]
35990: 
35990:         if md.decl.type.isSync():
35990:             stmts.append(StmtExpr(ExprCall(
35990:                 ExprSelect(var, '->', 'set_sync'))))
35990:         elif md.decl.type.isRpc():
35990:             stmts.append(StmtExpr(ExprCall(
35990:                 ExprSelect(var, '->', 'set_rpc'))))
35990: 
35990:         if reply:
35990:             stmts.append(StmtExpr(ExprCall(
35990:                 ExprSelect(var, '->', 'set_reply'))))
35990: 
35990:         return stmts + [ Whitespace.NL ]
35990: 
35990: 
36136:     def deserializeMessage(self, md, side, errfn):
36027:         msgvar = self.msgvar
35990:         isctor = md.decl.type.isCtor()
35990:         vars = [ ]
35990:         readvars = [ ]
36027:         stmts = [
36027:             self.logMessage(md, md.msgCast(ExprAddrOf(msgvar)),
36027:                             'Received '),
36027:             Whitespace.NL
36027:         ]
35990:         for param in md.params:
35990:             var, declstmts = param.makeDeserializedDecls(self.side)
35990:             vars.append(var)
35990:             stmts.extend(declstmts)
35990: 
35990:             fake, readvar, tempdeclstmts = param.makePipeDecls(var)
35990:             readvars.append(readvar)
35990:             stmts.extend(tempdeclstmts)
35990: 
35990:         okvar = ExprVar('__readok')
35990:         stmts.append(
35990:             StmtDecl(Decl(Type.BOOL, okvar.name),
35990:                      ExprCall(ExprVar(md.pqMsgClass() +'::Read'),
36027:                               args=[ ExprAddrOf(msgvar) ]
35990:                               + [ ExprAddrOf(p) for p in readvars ])))
35990: 
35990:         ifok = StmtIf(okvar)
35990:         for i, param in enumerate(md.params):
35990:             # skip deserializing the "implicit" actor for ctor
35990:             # in-messages; the actor doesn't exist yet
35990:             if isctor and i is 0: continue
36135:             ifok.addifstmts(param.deserialize(readvars[i], side, sems='in',
36136:                                               errfn=errfn))
35990:         if len(ifok.ifb.stmts):
35990:             stmts.extend([ Whitespace.NL, ifok ])
35990: 
35990:         if isctor:
35990:             # return the raw actor handle so that its ID can be used
35990:             # to construct the "real" actor
35990:             return readvars[0], okvar, stmts
35990:         return okvar, stmts
35990: 
35990: 
36136:     def deserializeReply(self, md, replyexpr, side, errfn):
35990:         readexprs = [ ]
36027:         stmts = [ Whitespace.NL,
36027:                   self.logMessage(md, md.replyCast(replyexpr),
36027:                                   'Received reply '),
36027:                   Whitespace.NL ]
35990:         for ret in md.returns:
35990:             fake, readvar, declstmts = ret.makePipeDecls(ret.var())
35990:             if fake:
35990:                 readexprs.append(ExprAddrOf(readvar))
35990:             else:
35990:                 readexprs.append(readvar)
35990:             stmts.extend(declstmts)
35990: 
35990:         okvar = ExprVar('__readok')
35990:         stmts.append(
35990:             StmtDecl(Decl(Type.BOOL, okvar.name),
35990:                      ExprCall(ExprVar(md.pqReplyClass() +'::Read'),
35990:                               args=[ replyexpr ]
35990:                               + readexprs)))
35990: 
35990:         ifok = StmtIf(okvar)
35990:         for i, ret in enumerate(md.returns):
35990:             ifok.addifstmts(ret.deserialize(
36135:                 ExprDeref(readexprs[i]), side, sems='out',
36136:                 errfn=errfn))
35990:         if len(ifok.ifb.stmts):
35990:             stmts.extend([ Whitespace.NL, ifok ])
35990: 
35990:         return okvar, stmts
35990: 
35990: 
36138:     def sendAsync(self, md, msgexpr, actor=None):
36027:         sendok = ExprVar('__sendok')
36027:         return (
36027:             sendok,
36027:             [ Whitespace.NL,
36027:               self.logMessage(md, msgexpr, 'Sending '),
36027:               Whitespace.NL,
36027:               StmtDecl(Decl(Type.BOOL, sendok.name),
36027:                        init=ExprCall(
36138:                            ExprSelect(self.protocol.channelVar(actor),
35990:                                       self.protocol.channelSel(), 'Send'),
36027:                            args=[ msgexpr ]))
36027:             ])
35990: 
36138:     def sendBlocking(self, md, msgexpr, replyexpr, actor=None):
36027:         sendok = ExprVar('__sendok')
36027:         return (
36027:             sendok,
36027:             [ Whitespace.NL,
36027:               self.logMessage(md, msgexpr, 'Sending '),
36027:               Whitespace.NL,
36138:               StmtDecl(
36138:                   Decl(Type.BOOL, sendok.name),
36138:                   init=ExprCall(ExprSelect(self.protocol.channelVar(actor),
35990:                                            self.protocol.channelSel(),
35990:                                            _sendPrefix(md.decl.type)),
36138:                                 args=[ msgexpr, ExprAddrOf(replyexpr) ]))
36027:             ])
36027: 
35990:     def callAllocActor(self, md, retsems):
35990:         return ExprCall(
36138:             _allocMethod(md.decl.type.constructedType()),
35990:             args=md.makeCxxArgs(params=1, retsems=retsems, retcallsems='out',
35990:                                 implicit=0))
35990: 
36140:     def callActorDestroy(self, actorexpr, why=_DestroyReason.Deletion):
36140:         return ExprCall(ExprSelect(actorexpr, '->', 'DestroySubtree'),
36140:                         args=[ why ])
36140: 
36140:     def callRemoveActor(self, actorexpr, actorarray=None):
36140:         if not self.protocol.decl.type.isManaged():
36140:             return Whitespace('// unmanaged protocol')
36140:         
36140:         if actorarray is None:
36140:             actorarray = self.protocol.managerArrayExpr(actorexpr, self.side)
36140:         return _callCxxArrayRemoveSorted(actorarray, actorexpr)
36139: 
36138:     def callDeallocActor(self, md, actorexpr):
36138:         actor = md.decl.type.constructedType()
35990:         return ExprCall(
36138:             ExprSelect(ExprCall(self.protocol.managerMethod(actorexpr)), '->',
36138:                        _deallocMethod(md.decl.type.constructedType()).name),
36138:             args=[ actorexpr ])
36138: 
36138:     def invokeRecvHandler(self, md, implicit=1):
35990:         failif = StmtIf(ExprNot(
35990:             ExprCall(md.recvMethod(),
35990:                      args=md.makeCxxArgs(params=1,
36138:                                          retsems='in', retcallsems='out',
36138:                                          implicit=implicit))))
35990:         failif.addifstmt(StmtReturn(_Result.ValuError))
35990:         return [ failif ]
35990: 
36138:     def makeDtorMethodDecl(self, md):
36138:         decl = self.makeSendMethodDecl(md)
36138:         decl.static = 1
36138:         return decl
36138: 
35990:     def makeSendMethodDecl(self, md):
35990:         implicit = md.decl.type.hasImplicitActorParam()
35990:         decl = MethodDecl(
35990:             md.sendMethod().name,
35990:             params=md.makeCxxParams(paramsems='in', returnsems='out',
35990:                                     side=self.side, implicit=implicit),
35990:             ret=Type.BOOL)
35744:         if md.decl.type.isCtor():
35990:             decl.ret = md.actorDecl().bareType(self.side)
35990:         return decl
35990: 
36027:     def logMessage(self, md, msgptr, pfx):
36068:         actorname = _actorName(self.protocol.name, self.side)
36027:         return _ifLogging([
36027:             StmtExpr(ExprCall(
36027:                 ExprSelect(msgptr, '->', 'Log'),
36068:                 args=[ ExprLiteral.String('['+ actorname +'] '+ pfx),
36027:                        ExprVar('stderr') ])) ])
36027: 
35990: 
36137: class _GenerateProtocolParentCode(_GenerateProtocolActorCode):
35742:     def __init__(self):
36137:         _GenerateProtocolActorCode.__init__(self, 'parent')
35742: 
35742:     def sendsMessage(self, md):
35742:         return not md.decl.type.isIn()
35742: 
35742:     def receivesMessage(self, md):
35742:         return md.decl.type.isInout() or md.decl.type.isIn()
35742: 
36137: class _GenerateProtocolChildCode(_GenerateProtocolActorCode):
35742:     def __init__(self):
36137:         _GenerateProtocolActorCode.__init__(self, 'child')
35742: 
35742:     def sendsMessage(self, md):
35742:         return not md.decl.type.isOut()
35742: 
35742:     def receivesMessage(self, md):
35742:         return md.decl.type.isInout() or md.decl.type.isOut()
35768: 
35768: 
35990: ##-----------------------------------------------------------------------------
36137: ## Utility passes
35990: ##
35990: 
36137: class _ClassDeclDefn:
36137:     def split(self, cls):
36137:         """Warning: destructively splits |cls|!"""
36137:         defns = Block()
36137: 
36137:         for i, stmt in enumerate(cls.stmts):
36137:             if isinstance(stmt, MethodDefn):
36137:                 decl, defn = self.splitMethodDefn(stmt, cls.name)
36137:                 cls.stmts[i] = StmtDecl(decl)
36137:                 defns.addstmts([ defn, Whitespace.NL ])
36137: 
36137:         return cls, defns
36137: 
36137:     def splitMethodDefn(self, md, clsname):
36137:         saveddecl = deepcopy(md.decl)
36137:         md.decl.name = (clsname +'::'+ md.decl.name)
36137:         md.decl.virtual = 0
36137:         md.decl.static = 0
36137:         for param in md.decl.params:
36137:             if isinstance(param, Param):
36137:                 param.default = None
36137:         return saveddecl, md
36137: 
36137: 
36137: # XXX this is tantalizingly similar to _SplitDeclDefn, but just
36137: # different enough that I don't see the need to define
36137: # _GenerateSkeleton in terms of that
35990: class _GenerateSkeletonImpl(Visitor):
36137:     def __init__(self, name, namespaces):
35768:         self.name = name
35768:         self.cls = None
36137:         self.namespaces = namespaces
36137:         self.methodimpls = Block()
35768: 
35768:     def fromclass(self, cls):
35768:         cls.accept(self)
36137: 
36137:         nsclass = _putInNamespaces(self.cls, self.namespaces)
36137:         nsmethodimpls = _putInNamespaces(self.methodimpls, self.namespaces)
36137: 
36137:         return [
36137:             Whitespace('''
35768: //-----------------------------------------------------------------------------
35768: // Skeleton implementation of abstract actor class
35768: 
36137: '''),
36137:             Whitespace('// Header file contents\n'),
36137:             nsclass,
36137:             Whitespace.NL,
36137:             Whitespace('\n// C++ file contents\n'),
36137:             nsmethodimpls
36137:         ]
36137: 
35768: 
35768:     def visitClass(self, cls):
35990:         self.cls = Class(self.name, inherits=[ Inherit(Type(cls.name)) ])
35990:         Visitor.visitClass(self, cls)
35768: 
35768:     def visitMethodDecl(self, md):
35768:         if not md.pure:
35768:             return
35768:         decl = deepcopy(md)
35768:         decl.pure = 0
35990:         impl = MethodDefn(MethodDecl(self.implname(md.name),
35768:                                              params=md.params,
35768:                                              ret=md.ret))
35840:         if md.ret.ptr:
35990:             impl.addstmt(StmtReturn(ExprLiteral.ZERO))
35840:         else:
35990:             impl.addstmt(StmtReturn(ExprVar('false')))
35990: 
35990:         self.cls.addstmts([ StmtDecl(decl), Whitespace.NL ])
35768:         self.addmethodimpl(impl)
35768: 
35768:     def visitConstructorDecl(self, cd):
35990:         self.cls.addstmt(StmtDecl(ConstructorDecl(self.name)))
35990:         ctor = ConstructorDefn(ConstructorDecl(self.implname(self.name)))
35990:         ctor.addstmt(StmtExpr(ExprCall(ExprVar( 'MOZ_COUNT_CTOR'),
35990:                                                [ ExprVar(self.name) ])))
35879:         self.addmethodimpl(ctor)
35768:         
35768:     def visitDestructorDecl(self, dd):
35768:         self.cls.addstmt(
35990:             StmtDecl(DestructorDecl(self.name, virtual=1)))
35768:         # FIXME/cjones: hack!
35990:         dtor = DestructorDefn(ConstructorDecl(self.implname('~' +self.name)))
35990:         dtor.addstmt(StmtExpr(ExprCall(ExprVar( 'MOZ_COUNT_DTOR'),
35990:                                                [ ExprVar(self.name) ])))
35879:         self.addmethodimpl(dtor)
35768: 
35768:     def addmethodimpl(self, impl):
36137:         self.methodimpls.addstmts([ impl, Whitespace.NL ])
35768: 
35768:     def implname(self, method):
35768:         return self.name +'::'+ method
