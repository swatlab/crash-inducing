 20627: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 20627: /* vim:set ts=2 sw=2 sts=2 et cindent: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 75263: 
 90148: #include "MediaResource.h"
 75263: 
 64576: #include "mozilla/Mutex.h"
 20627: #include "nsDebug.h"
 20627: #include "nsMediaDecoder.h"
 20627: #include "nsNetUtil.h"
 20627: #include "nsThreadUtils.h"
 20627: #include "nsIFile.h"
 20627: #include "nsIFileChannel.h"
 20627: #include "nsIHttpChannel.h"
 20627: #include "nsISeekableStream.h"
 20627: #include "nsIInputStream.h"
 20627: #include "nsIOutputStream.h"
 20627: #include "nsIRequestObserver.h"
 20627: #include "nsIStreamListener.h"
 20627: #include "nsIScriptSecurityManager.h"
 24155: #include "nsCrossSiteListenerProxy.h"
 24155: #include "nsHTMLMediaElement.h"
108290: #include "nsError.h"
 26836: #include "nsICachingChannel.h"
 26836: #include "nsURILoader.h"
 48889: #include "nsIAsyncVerifyRedirectCallback.h"
 72147: #include "mozilla/Util.h" // for DebugOnly
 75263: #include "nsContentUtils.h"
111255: #include "nsBlobProtocolHandler.h"
 20627: 
115534: #ifdef PR_LOGGING
115534: PRLogModuleInfo* gMediaResourceLog;
115534: #define LOG(msg, ...) PR_LOG(gMediaResourceLog, PR_LOG_DEBUG, \
115534:                              (msg, ##__VA_ARGS__))
115534: // Debug logging macro with object pointer and class name.
115534: #define CMLOG(msg, ...) \
115534:         LOG("%p [ChannelMediaResource]: " msg, this, ##__VA_ARGS__)
115534: #else
115534: #define LOG(msg, ...)
115534: #define CMLOG(msg, ...)
115534: #endif
115534: 
108991: static const uint32_t HTTP_OK_CODE = 200;
108991: static const uint32_t HTTP_PARTIAL_RESPONSE_CODE = 206;
 26836: 
 64576: using namespace mozilla;
 27222: 
 90148: ChannelMediaResource::ChannelMediaResource(nsMediaDecoder* aDecoder,
 26836:     nsIChannel* aChannel, nsIURI* aURI)
 90148:   : MediaResource(aDecoder, aChannel, aURI),
 28487:     mOffset(0), mSuspendCount(0),
 79547:     mReopenOnError(false), mIgnoreClose(false),
 26836:     mCacheStream(this),
 90148:     mLock("ChannelMediaResource.mLock"),
108662:     mIgnoreResume(false),
115534:     mSeekingForMetadata(false),
115534:     mByteRangeDownloads(false),
115534:     mByteRangeFirstOpen(true),
115534:     mSeekOffsetMonitor("media.dashseekmonitor"),
115534:     mSeekOffset(-1)
 20627: {
115534: #ifdef PR_LOGGING
115534:   if (!gMediaResourceLog) {
115534:     gMediaResourceLog = PR_NewLogModule("MediaResource");
115534:   }
115534: #endif
 20627: }
 20627: 
 90148: ChannelMediaResource::~ChannelMediaResource()
 26836: {
 26836:   if (mListener) {
 26836:     // Kill its reference to us since we're going away
 26836:     mListener->Revoke();
 26836:   }
 26836: }
 20627: 
 90148: // ChannelMediaResource::Listener just observes the channel and
 90148: // forwards notifications to the ChannelMediaResource. We use multiple
 26836: // listener objects so that when we open a new stream for a seek we can
 90148: // disconnect the old listener from the ChannelMediaResource and hook up
 26836: // a new listener, so notifications from the old channel are discarded
 26836: // and don't confuse us.
 90148: NS_IMPL_ISUPPORTS4(ChannelMediaResource::Listener,
 28370:                    nsIRequestObserver, nsIStreamListener, nsIChannelEventSink,
 28370:                    nsIInterfaceRequestor)
 26706: 
 26836: nsresult
 90148: ChannelMediaResource::Listener::OnStartRequest(nsIRequest* aRequest,
 26836:                                                nsISupports* aContext)
 26836: {
 90148:   if (!mResource)
 26836:     return NS_OK;
 90148:   return mResource->OnStartRequest(aRequest);
 26836: }
 26706: 
 26836: nsresult
 90148: ChannelMediaResource::Listener::OnStopRequest(nsIRequest* aRequest,
 26836:                                               nsISupports* aContext,
 26836:                                               nsresult aStatus)
 26836: {
 90148:   if (!mResource)
 26836:     return NS_OK;
 90148:   return mResource->OnStopRequest(aRequest, aStatus);
 26836: }
 20627: 
 26836: nsresult
 90148: ChannelMediaResource::Listener::OnDataAvailable(nsIRequest* aRequest,
 26836:                                                 nsISupports* aContext,
 26836:                                                 nsIInputStream* aStream,
111234:                                                 uint64_t aOffset,
108991:                                                 uint32_t aCount)
 26836: {
 90148:   if (!mResource)
 26836:     return NS_OK;
 90148:   return mResource->OnDataAvailable(aRequest, aStream, aCount);
 26836: }
 21394: 
 26836: nsresult
 90148: ChannelMediaResource::Listener::AsyncOnChannelRedirect(nsIChannel* aOldChannel,
 28370:                                                        nsIChannel* aNewChannel,
108991:                                                        uint32_t aFlags,
 48889:                                                        nsIAsyncVerifyRedirectCallback* cb)
 28370: {
 48889:   nsresult rv = NS_OK;
 90148:   if (mResource)
 90148:     rv = mResource->OnChannelRedirect(aOldChannel, aNewChannel, aFlags);
 48889: 
 48889:   if (NS_FAILED(rv))
 48889:     return rv;
 48889: 
 48889:   cb->OnRedirectVerifyCallback(NS_OK);
 28370:   return NS_OK;
 28370: }
 28370: 
 28370: nsresult
 90148: ChannelMediaResource::Listener::GetInterface(const nsIID & aIID, void **aResult)
 28370: {
 28370:   return QueryInterface(aIID, aResult);
 28370: }
 28370: 
 28370: nsresult
 90148: ChannelMediaResource::OnStartRequest(nsIRequest* aRequest)
 26836: {
 26836:   NS_ASSERTION(mChannel.get() == aRequest, "Wrong channel!");
 26706: 
 26836:   nsHTMLMediaElement* element = mDecoder->GetMediaElement();
 26836:   NS_ENSURE_TRUE(element, NS_ERROR_FAILURE);
 33364:   nsresult status;
 33364:   nsresult rv = aRequest->GetStatus(&status);
 33364:   NS_ENSURE_SUCCESS(rv, rv);
 33364: 
 26836:   if (element->ShouldCheckAllowOrigin()) {
 64070:     // If the request was cancelled by nsCORSListenerProxy due to failing
 64070:     // the CORS security check, send an error through to the media element.
 33364:     if (status == NS_ERROR_DOM_BAD_URI) {
 26836:       mDecoder->NetworkError();
 26836:       return NS_ERROR_DOM_BAD_URI;
 26836:     }
 26836:   }
 26836: 
 26836:   nsCOMPtr<nsIHttpChannel> hc = do_QueryInterface(aRequest);
 79445:   bool seekable = false;
 26836:   if (hc) {
108991:     uint32_t responseStatus = 0;
 33364:     hc->GetResponseStatus(&responseStatus);
 79445:     bool succeeded = false;
 33364:     hc->GetRequestSucceeded(&succeeded);
 33364: 
 33364:     if (!succeeded && NS_SUCCEEDED(status)) {
 33364:       // HTTP-level error (e.g. 4xx); treat this as a fatal network-level error.
 33364:       // We might get this on a seek.
 33364:       // (Note that lower-level errors indicated by NS_FAILED(status) are
 33364:       // handled in OnStopRequest.)
 33364:       // A 416 error should treated as EOF here... it's possible
 33364:       // that we don't get Content-Length, we read N bytes, then we
 33364:       // suspend and resume, the resume reopens the channel and we seek to
 33364:       // offset N, but there are no more bytes, so we get a 416
 33364:       // "Requested Range Not Satisfiable".
 33364:       if (responseStatus != HTTP_REQUESTED_RANGE_NOT_SATISFIABLE_CODE) {
 33364:         mDecoder->NetworkError();
 33364:       }
 33364: 
 33364:       // This disconnects our listener so we don't get any more data. We
 33364:       // certainly don't want an error page to end up in our cache!
 33364:       CloseChannel();
 33364:       return NS_OK;
 33364:     }
 33364: 
110974:     nsAutoCString ranges;
 26836:     hc->GetResponseHeader(NS_LITERAL_CSTRING("Accept-Ranges"),
 26836:                           ranges);
 79445:     bool acceptsRanges = ranges.EqualsLiteral("bytes");
 26836: 
 28487:     if (mOffset == 0) {
 37543:       // Look for duration headers from known Ogg content systems.
 37543:       // In the case of multiple options for obtaining the duration
 37543:       // the order of precedence is:
 26836:       // 1) The Media resource metadata if possible (done by the decoder itself).
 37543:       // 2) Content-Duration message header.
 37543:       // 3) X-AMZ-Meta-Content-Duration.
 37543:       // 4) X-Content-Duration.
 37543:       // 5) Perform a seek in the decoder to find the value.
110974:       nsAutoCString durationText;
106878:       nsresult ec = NS_OK;
 37543:       rv = hc->GetResponseHeader(NS_LITERAL_CSTRING("Content-Duration"), durationText);
 26836:       if (NS_FAILED(rv)) {
 26836:         rv = hc->GetResponseHeader(NS_LITERAL_CSTRING("X-AMZ-Meta-Content-Duration"), durationText);
 26836:       }
 37543:       if (NS_FAILED(rv)) {
 37543:         rv = hc->GetResponseHeader(NS_LITERAL_CSTRING("X-Content-Duration"), durationText);
 37543:       }
 26836: 
 26836:       if (NS_SUCCEEDED(rv)) {
 63877:         double duration = durationText.ToDouble(&ec);
 26836:         if (ec == NS_OK && duration >= 0) {
 68450:           mDecoder->SetDuration(duration);
 26836:         }
 74647:       } else {
 79547:         mDecoder->SetInfinite(true);
 26836:       }
 26836:     }
 26836: 
115534:     // Check response code for byte-range requests (seeking, chunk requests).
115534:     if (!mByteRange.IsNull() && (responseStatus == HTTP_PARTIAL_RESPONSE_CODE)) {
115534:       // Byte range requests should get partial response codes and should
115534:       // accept ranges.
115534:       if (!acceptsRanges) {
115534:         CMLOG("Error! HTTP_PARTIAL_RESPONSE_CODE received but server says "
115534:               "range requests are not accepted! Channel[%p]", hc.get());
115534:         mDecoder->NetworkError();
115534:         CloseChannel();
115534:         return NS_OK;
115534:       }
115534: 
115534:       // Parse Content-Range header.
115534:       int64_t rangeStart = 0;
115534:       int64_t rangeEnd = 0;
115534:       int64_t rangeTotal = 0;
115534:       rv = ParseContentRangeHeader(hc, rangeStart, rangeEnd, rangeTotal);
115534:       if (NS_FAILED(rv)) {
115534:         // Content-Range header text should be parse-able.
115534:         CMLOG("Error processing \'Content-Range' for "
115534:               "HTTP_PARTIAL_RESPONSE_CODE: rv[%x]channel [%p]", rv, hc.get());
115534:         mDecoder->NetworkError();
115534:         CloseChannel();
115534:         return NS_OK;
115534:       }
115534: 
115534:       // Give some warnings if the ranges are unexpected.
115534:       // XXX These could be error conditions.
115534:       NS_WARN_IF_FALSE(mByteRange.mStart == rangeStart,
115534:                        "response range start does not match request");
115534:       NS_WARN_IF_FALSE(mOffset == rangeStart,
115534:                        "response range start does not match current offset");
115534:       NS_WARN_IF_FALSE(mByteRange.mEnd == rangeEnd,
115534:                        "response range end does not match request");
115534:       // Notify media cache about the length and start offset of data received.
115534:       // Note: If aRangeTotal == -1, then the total bytes is unknown at this stage.
115534:       //       For now, tell the decoder that the stream is infinite.
115534:       if (rangeTotal != -1) {
115534:         mCacheStream.NotifyDataLength(rangeTotal);
115534:       } else {
115534:         mDecoder->SetInfinite(true);
115534:       }
115534:       mCacheStream.NotifyDataStarted(rangeStart);
115534: 
115534:       mOffset = rangeStart;
115534:       acceptsRanges = true;
115534:     } else if (((mOffset > 0) || !mByteRange.IsNull())
115534:                && (responseStatus == HTTP_OK_CODE)) {
115534:       // If we get an OK response but we were seeking, or requesting a byte
115534:       // range, then we have to assume that seeking doesn't work. We also need
115534:       // to tell the cache that it's getting data for the start of the stream.
 26836:       mCacheStream.NotifyDataStarted(0);
 28487:       mOffset = 0;
 62891: 
 62891:       // The server claimed it supported range requests.  It lied.
 79547:       acceptsRanges = false;
 28487:     } else if (mOffset == 0 &&
 26836:                (responseStatus == HTTP_OK_CODE ||
 26836:                 responseStatus == HTTP_PARTIAL_RESPONSE_CODE)) {
 26836:       // We weren't seeking and got a valid response status,
 26836:       // set the length of the content.
108991:       int64_t cl = -1;
 99850:       nsCOMPtr<nsIPropertyBag2> bag = do_QueryInterface(hc);
 99850: 
 99850:       if (bag) {
 99850:         bag->GetPropertyAsInt64(NS_CHANNEL_PROP_CONTENT_LENGTH, &cl);
 99850:       }
 99850: 
 99850:       if (cl < 0) {
108991:         int32_t cl32;
 99850:         hc->GetContentLength(&cl32);
 99850:         cl = cl32;
 99850:       }
 99850: 
 26836:       if (cl >= 0) {
 26836:         mCacheStream.NotifyDataLength(cl);
 26836:       }
 26836:     }
 28487:     // XXX we probably should examine the Content-Range header in case
 28487:     // the server gave us a range which is not quite what we asked for
 26836: 
 26836:     // If we get an HTTP_OK_CODE response to our byte range request,
 26836:     // and the server isn't sending Accept-Ranges:bytes then we don't
 26836:     // support seeking.
 26836:     seekable =
 26836:       responseStatus == HTTP_PARTIAL_RESPONSE_CODE || acceptsRanges;
 74647: 
 74647:     if (seekable) {
 79547:       mDecoder->SetInfinite(false);
 74647:     }
 26836:   }
 26836:   mDecoder->SetSeekable(seekable);
 26836:   mCacheStream.SetSeekable(seekable);
 26836: 
 26836:   nsCOMPtr<nsICachingChannel> cc = do_QueryInterface(aRequest);
 26836:   if (cc) {
 79445:     bool fromCache = false;
 33364:     rv = cc->IsFromCache(&fromCache);
 26836:     if (NS_SUCCEEDED(rv) && !fromCache) {
 79547:       cc->SetCacheAsFile(true);
 26836:     }
 26836:   }
 26836: 
 26836:   {
 64576:     MutexAutoLock lock(mLock);
 27222:     mChannelStatistics.Start(TimeStamp::Now());
 26836:   }
 26836: 
 79547:   mReopenOnError = false;
108662:   // If we are seeking to get metadata, because we are playing an OGG file,
108662:   // ignore if the channel gets closed without us suspending it explicitly. We
108662:   // don't want to tell the element that the download has finished whereas we
108662:   // just happended to have reached the end of the media while seeking.
108662:   mIgnoreClose = mSeekingForMetadata;
108662: 
 26836:   if (mSuspendCount > 0) {
 26836:     // Re-suspend the channel if it needs to be suspended
 67657:     // No need to call PossiblySuspend here since the channel is
 91073:     // definitely in the right state for us in OnStartRequest.
 26836:     mChannel->Suspend();
 79547:     mIgnoreResume = false;
 26836:   }
 26836: 
 26836:   // Fires an initial progress event and sets up the stall counter so stall events
 26836:   // fire if no download occurs within the required time frame.
 79547:   mDecoder->Progress(false);
 26836: 
 26836:   return NS_OK;
 26836: }
 26836: 
 26836: nsresult
115534: ChannelMediaResource::ParseContentRangeHeader(nsIHttpChannel * aHttpChan,
115534:                                               int64_t& aRangeStart,
115534:                                               int64_t& aRangeEnd,
115534:                                               int64_t& aRangeTotal)
115534: {
115534:   NS_ENSURE_ARG(aHttpChan);
115534: 
115534:   nsAutoCString rangeStr;
115534:   nsresult rv = aHttpChan->GetResponseHeader(NS_LITERAL_CSTRING("Content-Range"),
115534:                                              rangeStr);
115534:   NS_ENSURE_SUCCESS(rv, rv);
115534:   NS_ENSURE_FALSE(rangeStr.IsEmpty(), NS_ERROR_ILLEGAL_VALUE);
115534: 
115534:   // Parse the range header: e.g. Content-Range: bytes 7000-7999/8000.
115534:   int32_t spacePos = rangeStr.Find(NS_LITERAL_CSTRING(" "));
115534:   int32_t dashPos = rangeStr.Find(NS_LITERAL_CSTRING("-"), true, spacePos);
115534:   int32_t slashPos = rangeStr.Find(NS_LITERAL_CSTRING("/"), true, dashPos);
115534: 
115534:   nsAutoCString aRangeStartText;
115534:   rangeStr.Mid(aRangeStartText, spacePos+1, dashPos-(spacePos+1));
115534:   aRangeStart = aRangeStartText.ToInteger64(&rv);
115534:   NS_ENSURE_SUCCESS(rv, rv);
115534:   NS_ENSURE_TRUE(0 <= aRangeStart, NS_ERROR_ILLEGAL_VALUE);
115534: 
115534:   nsAutoCString aRangeEndText;
115534:   rangeStr.Mid(aRangeEndText, dashPos+1, slashPos-(dashPos+1));
115534:   aRangeEnd = aRangeEndText.ToInteger64(&rv);
115534:   NS_ENSURE_SUCCESS(rv, rv);
115534:   NS_ENSURE_TRUE(aRangeStart < aRangeEnd, NS_ERROR_ILLEGAL_VALUE);
115534: 
115534:   nsAutoCString aRangeTotalText;
115534:   rangeStr.Right(aRangeTotalText, rangeStr.Length()-(slashPos+1));
115534:   if (aRangeTotalText[0] == '*') {
115534:     aRangeTotal = -1;
115534:   } else {
115534:     aRangeTotal = aRangeTotalText.ToInteger64(&rv);
115534:     NS_ENSURE_TRUE(aRangeEnd < aRangeTotal, NS_ERROR_ILLEGAL_VALUE);
115534:     NS_ENSURE_SUCCESS(rv, rv);
115534:   }
115534: 
115534:   CMLOG("Received bytes [%d] to [%d] of [%d]",
115534:         aRangeStart, aRangeEnd, aRangeTotal);
115534: 
115534:   return NS_OK;
115534: }
115534: 
115534: nsresult
 90148: ChannelMediaResource::OnStopRequest(nsIRequest* aRequest, nsresult aStatus)
 26836: {
 26836:   NS_ASSERTION(mChannel.get() == aRequest, "Wrong channel!");
 28487:   NS_ASSERTION(mSuspendCount == 0,
 28487:                "How can OnStopRequest fire while we're suspended?");
 26836: 
 26836:   {
 64576:     MutexAutoLock lock(mLock);
 27222:     mChannelStatistics.Stop(TimeStamp::Now());
 26836:   }
 26836: 
115534:   // If we were loading a byte range, notify decoder and return.
115534:   // Skip this for unterminated byte range requests, e.g. seeking for whole
115534:   // file downloads.
115534:   if (mByteRangeDownloads) {
115534:     mDecoder->NotifyDownloadEnded(aStatus);
115534:     return NS_OK;
115534:   }
115534: 
 33859:   // Note that aStatus might have succeeded --- this might be a normal close
 33859:   // --- even in situations where the server cut us off because we were
 33859:   // suspended. So we need to "reopen on error" in that case too. The only
 33859:   // cases where we don't need to reopen are when *we* closed the stream.
 33859:   // But don't reopen if we need to seek and we don't think we can... that would
 33859:   // cause us to just re-read the stream, which would be really bad.
 33859:   if (mReopenOnError &&
 33859:       aStatus != NS_ERROR_PARSED_DATA_CACHED && aStatus != NS_BINDING_ABORTED &&
 33859:       (mOffset == 0 || mCacheStream.IsSeekable())) {
 33859:     // If the stream did close normally, then if the server is seekable we'll
 33859:     // just seek to the end of the resource and get an HTTP 416 error because
 33859:     // there's nothing there, so this isn't bad.
 79547:     nsresult rv = CacheClientSeek(mOffset, false);
 28487:     if (NS_SUCCEEDED(rv))
 28487:       return rv;
 28487:     // If the reopen/reseek fails, just fall through and treat this
 28487:     // error as fatal.
 28487:   }
 28487: 
 28487:   if (!mIgnoreClose) {
 26836:     mCacheStream.NotifyDataEnded(aStatus);
 62568: 
 62568:     // Move this request back into the foreground.  This is necessary for
 62568:     // requests owned by video documents to ensure the load group fires
 62568:     // OnStopRequest when restoring from session history.
 62568:     nsLoadFlags loadFlags;
 72147:     DebugOnly<nsresult> rv = mChannel->GetLoadFlags(&loadFlags);
 62568:     NS_ASSERTION(NS_SUCCEEDED(rv), "GetLoadFlags() failed!");
 62568: 
 91073:     if (loadFlags & nsIRequest::LOAD_BACKGROUND) {
 91073:       ModifyLoadFlags(loadFlags & ~nsIRequest::LOAD_BACKGROUND);
 62568:     }
 28487:   }
 28487: 
 26836:   return NS_OK;
 26836: }
 26836: 
 28370: nsresult
 90148: ChannelMediaResource::OnChannelRedirect(nsIChannel* aOld, nsIChannel* aNew,
108991:                                         uint32_t aFlags)
 28370: {
 28370:   mChannel = aNew;
 28370:   SetupChannelHeaders();
 28370:   return NS_OK;
 28370: }
 28370: 
 28370: struct CopySegmentClosure {
 28370:   nsCOMPtr<nsIPrincipal> mPrincipal;
 90148:   ChannelMediaResource*  mResource;
 28370: };
 28370: 
 26836: NS_METHOD
 90148: ChannelMediaResource::CopySegmentToCache(nsIInputStream *aInStream,
 26836:                                          void *aClosure,
 26836:                                          const char *aFromSegment,
108991:                                          uint32_t aToOffset,
108991:                                          uint32_t aCount,
108991:                                          uint32_t *aWriteCount)
 26836: {
 28370:   CopySegmentClosure* closure = static_cast<CopySegmentClosure*>(aClosure);
 53765: 
 90148:   closure->mResource->mDecoder->NotifyDataArrived(aFromSegment, aCount, closure->mResource->mOffset);
 53765: 
 28487:   // Keep track of where we're up to
 90148:   closure->mResource->mOffset += aCount;
115534:   LOG("%p [ChannelMediaResource]: CopySegmentToCache new mOffset = %d",
115534:       closure->mResource, closure->mResource->mOffset);
 90148:   closure->mResource->mCacheStream.NotifyDataReceived(aCount, aFromSegment,
 28370:                                                       closure->mPrincipal);
 26836:   *aWriteCount = aCount;
 26836:   return NS_OK;
 26836: }
 26836: 
 26836: nsresult
 90148: ChannelMediaResource::OnDataAvailable(nsIRequest* aRequest,
 26836:                                       nsIInputStream* aStream,
108991:                                       uint32_t aCount)
 26836: {
 26836:   NS_ASSERTION(mChannel.get() == aRequest, "Wrong channel!");
 26836: 
 26836:   {
 64576:     MutexAutoLock lock(mLock);
 26836:     mChannelStatistics.AddBytes(aCount);
 26836:   }
 26836: 
 28370:   CopySegmentClosure closure;
 28370:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 28370:   if (secMan && mChannel) {
 28370:     secMan->GetChannelPrincipal(mChannel, getter_AddRefs(closure.mPrincipal));
 28370:   }
 90148:   closure.mResource = this;
 28370: 
108991:   uint32_t count = aCount;
 26836:   while (count > 0) {
108991:     uint32_t read;
 28370:     nsresult rv = aStream->ReadSegments(CopySegmentToCache, &closure, count,
 26836:                                         &read);
 26836:     if (NS_FAILED(rv))
 26836:       return rv;
 26836:     NS_ASSERTION(read > 0, "Read 0 bytes while data was available?");
 26836:     count -= read;
 26836:   }
 26836: 
 26836:   return NS_OK;
 26836: }
 20627: 
115534: /* |OpenByteRange|
115534:  * For terminated byte range requests, use this function.
115534:  * Callback is |nsBuiltinDecoder|::|NotifyByteRangeDownloaded|().
115534:  * See |CacheClientSeek| also.
115534:  */
115534: 
115534: nsresult
115534: ChannelMediaResource::OpenByteRange(nsIStreamListener** aStreamListener,
115534:                                     MediaByteRange const & aByteRange)
115534: {
115534:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
115534: 
115534:   mByteRangeDownloads = true;
115534:   mByteRange = aByteRange;
115534: 
115534:   // OpenByteRange may be called multiple times; same URL, different ranges.
115534:   // For the first call using this URL, forward to Open for some init.
115534:   if (mByteRangeFirstOpen) {
115534:     mByteRangeFirstOpen = false;
115534:     return Open(aStreamListener);
115534:   }
115534: 
115534:   // For subsequent calls, ensure channel is recreated with correct byte range.
115534:   CloseChannel();
115534: 
115534:   nsresult rv = RecreateChannel();
115534:   NS_ENSURE_SUCCESS(rv, rv);
115534: 
115534:   return OpenChannel(aStreamListener);
115534: }
115534: 
 90148: nsresult ChannelMediaResource::Open(nsIStreamListener **aStreamListener)
 20627: {
 26836:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26836: 
 26836:   nsresult rv = mCacheStream.Init();
 26836:   if (NS_FAILED(rv))
 26836:     return rv;
 28487:   NS_ASSERTION(mOffset == 0, "Who set mOffset already?");
 34505: 
 34505:   if (!mChannel) {
 34505:     // When we're a clone, the decoder might ask us to Open even though
 34505:     // we haven't established an mChannel (because we might not need one)
 34505:     NS_ASSERTION(!aStreamListener,
 34505:                  "Should have already been given a channel if we're to return a stream listener");
 34505:     return NS_OK;
 34505:   }
 34505: 
 28487:   return OpenChannel(aStreamListener);
 26706: }
 26706: 
 90148: nsresult ChannelMediaResource::OpenChannel(nsIStreamListener** aStreamListener)
 26706: {
 26706:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26706:   NS_ENSURE_TRUE(mChannel, NS_ERROR_NULL_POINTER);
 26836:   NS_ASSERTION(!mListener, "Listener should have been removed by now");
 26706: 
 21079:   if (aStreamListener) {
106838:     *aStreamListener = nullptr;
 21079:   }
 20627: 
 26836:   mListener = new Listener(this);
 26812:   NS_ENSURE_TRUE(mListener, NS_ERROR_OUT_OF_MEMORY);
 26796: 
 21079:   if (aStreamListener) {
 21079:     *aStreamListener = mListener;
 26706:     NS_ADDREF(*aStreamListener);
 21079:   } else {
 28370:     mChannel->SetNotificationCallbacks(mListener.get());
 28370: 
 26836:     nsCOMPtr<nsIStreamListener> listener = mListener.get();
 26836: 
 24155:     // Ensure that if we're loading cross domain, that the server is sending
 24155:     // an authorizing Access-Control header.
 24155:     nsHTMLMediaElement* element = mDecoder->GetMediaElement();
 24155:     NS_ENSURE_TRUE(element, NS_ERROR_FAILURE);
 24155:     if (element->ShouldCheckAllowOrigin()) {
115775:       nsRefPtr<nsCORSListenerProxy> crossSiteListener =
 64070:         new nsCORSListenerProxy(mListener,
 24155:                                 element->NodePrincipal(),
114321:                                 false);
114321:       nsresult rv = crossSiteListener->Init(mChannel);
 36217:       listener = crossSiteListener;
 36217:       NS_ENSURE_TRUE(crossSiteListener, NS_ERROR_OUT_OF_MEMORY);
 24155:       NS_ENSURE_SUCCESS(rv, rv);
 24188:     } else {
 26836:       nsresult rv = nsContentUtils::GetSecurityManager()->
 24188:         CheckLoadURIWithPrincipal(element->NodePrincipal(),
 24188:                                   mURI,
 24188:                                   nsIScriptSecurityManager::STANDARD);
 24188:       NS_ENSURE_SUCCESS(rv, rv);
 26836:     }
 26812: 
 28370:     SetupChannelHeaders();
 26706: 
106838:     nsresult rv = mChannel->AsyncOpen(listener, nullptr);
 20627:     NS_ENSURE_SUCCESS(rv, rv);
 99848:     // Tell the media element that we are fetching data from a channel.
 99848:     element->DownloadResumed(true);
 21079:   }
 20627: 
 20627:   return NS_OK;
 20627: }
 20627: 
 90148: void ChannelMediaResource::SetupChannelHeaders()
 28370: {
 28370:   // Always use a byte range request even if we're reading from the start
 28370:   // of the resource.
 28370:   // This enables us to detect if the stream supports byte range
 28370:   // requests, and therefore seeking, early.
 28370:   nsCOMPtr<nsIHttpChannel> hc = do_QueryInterface(mChannel);
 28370:   if (hc) {
115534:     // Use |mByteRange| for a specific chunk, or |mOffset| if seeking in a
115534:     // complete file download.
110974:     nsAutoCString rangeString("bytes=");
115534:     if (!mByteRange.IsNull()) {
115534:       rangeString.AppendInt(mByteRange.mStart);
115534:       mOffset = mByteRange.mStart;
115534:     } else {
 28487:       rangeString.AppendInt(mOffset);
115534:     }
 28370:     rangeString.Append("-");
115534:     if (!mByteRange.IsNull()) {
115534:       rangeString.AppendInt(mByteRange.mEnd);
115534:     }
 79547:     hc->SetRequestHeader(NS_LITERAL_CSTRING("Range"), rangeString, false);
 48349: 
 48349:     // Send Accept header for video and audio types only (Bug 489071)
 48349:     NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 48349:     nsHTMLMediaElement* element = mDecoder->GetMediaElement();
 48349:     if (!element) {
 48349:       return;
 48349:     }
 54200:     element->SetRequestHeaders(hc);
 28370:   } else {
 28487:     NS_ASSERTION(mOffset == 0, "Don't know how to seek on this channel type");
 28370:   }
 28370: }
 28370: 
 90148: nsresult ChannelMediaResource::Close()
 20627: {
 26706:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26836: 
 26836:   mCacheStream.Close();
 26836:   CloseChannel();
 26836:   return NS_OK;
 26836: }
 26836: 
 90148: already_AddRefed<nsIPrincipal> ChannelMediaResource::GetCurrentPrincipal()
 28370: {
 28370:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 28370: 
 28370:   nsCOMPtr<nsIPrincipal> principal = mCacheStream.GetCurrentPrincipal();
 28370:   return principal.forget();
 28370: }
 28370: 
 93550: bool ChannelMediaResource::CanClone()
 93550: {
 93550:   return mCacheStream.IsAvailableForSharing();
 93550: }
 93550: 
 90148: MediaResource* ChannelMediaResource::CloneData(nsMediaDecoder* aDecoder)
 32901: {
 32901:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 93550:   NS_ASSERTION(mCacheStream.IsAvailableForSharing(), "Stream can't be cloned");
 32901: 
106838:   ChannelMediaResource* resource = new ChannelMediaResource(aDecoder, nullptr, mURI);
 90148:   if (resource) {
 34505:     // Initially the clone is treated as suspended by the cache, because
 34505:     // we don't have a channel. If the cache needs to read data from the clone
 34505:     // it will call CacheClientResume (or CacheClientSeek with aResume true)
 34505:     // which will recreate the channel. This way, if all of the media data
 34505:     // is already in the cache we don't create an unneccesary HTTP channel
 34505:     // and perform a useless HTTP transaction.
 90148:     resource->mSuspendCount = 1;
 90148:     resource->mCacheStream.InitAsClone(&mCacheStream);
 90148:     resource->mChannelStatistics = mChannelStatistics;
 90148:     resource->mChannelStatistics.Stop(TimeStamp::Now());
 32901:   }
 90148:   return resource;
 32901: }
 32901: 
 90148: void ChannelMediaResource::CloseChannel()
 26836: {
 26836:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26836: 
 26836:   {
 64576:     MutexAutoLock lock(mLock);
 27222:     mChannelStatistics.Stop(TimeStamp::Now());
 26836:   }
 26836: 
 26836:   if (mListener) {
 26836:     mListener->Revoke();
106838:     mListener = nullptr;
 26836:   }
 26836: 
 20627:   if (mChannel) {
 26836:     if (mSuspendCount > 0) {
 26836:       // Resume the channel before we cancel it
 67657:       PossiblyResume();
 26836:     }
 26836:     // The status we use here won't be passed to the decoder, since
 26836:     // we've already revoked the listener. It can however be passed
 26836:     // to DocumentViewerImpl::LoadComplete if our channel is the one
 26836:     // that kicked off creation of a video document. We don't want that
 26836:     // document load to think there was an error.
 26836:     // NS_ERROR_PARSED_DATA_CACHED is the best thing we have for that
 26836:     // at the moment.
 26836:     mChannel->Cancel(NS_ERROR_PARSED_DATA_CACHED);
106838:     mChannel = nullptr;
 21756:   }
 20627: }
 20627: 
 90148: nsresult ChannelMediaResource::ReadFromCache(char* aBuffer,
108991:                                              int64_t aOffset,
108991:                                              uint32_t aCount)
 48904: {
 48904:   return mCacheStream.ReadFromCache(aBuffer, aOffset, aCount);
 48904: }
 48904: 
 90148: nsresult ChannelMediaResource::Read(char* aBuffer,
108991:                                     uint32_t aCount,
108991:                                     uint32_t* aBytes)
 20627: {
 26836:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
 21394: 
 26836:   return mCacheStream.Read(aBuffer, aCount, aBytes);
 20627: }
 20627: 
108991: nsresult ChannelMediaResource::Seek(int32_t aWhence, int64_t aOffset)
 20627: {
 26836:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
 26836: 
115534:   // Remember |aOffset|, because Media Cache may request a diff offset later.
115534:   if (mByteRangeDownloads) {
115534:     ReentrantMonitorAutoEnter mon(mSeekOffsetMonitor);
115534:     mSeekOffset = aOffset;
115534:   }
115534: 
 26836:   return mCacheStream.Seek(aWhence, aOffset);
 20627: }
 20627: 
108662: void ChannelMediaResource::StartSeekingForMetadata()
108662: {
108662:   mSeekingForMetadata = true;
108662: }
108662: 
108662: void ChannelMediaResource::EndSeekingForMetadata()
108662: {
108662:   mSeekingForMetadata = false;
108662: }
108662: 
108991: int64_t ChannelMediaResource::Tell()
 20627: {
 26836:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
 20627: 
 26836:   return mCacheStream.Tell();
 20627: }
 20627: 
 90148: nsresult ChannelMediaResource::GetCachedRanges(nsTArray<MediaByteRange>& aRanges)
 63626: {
 63626:   return mCacheStream.GetCachedRanges(aRanges);
 63626: }
 63626: 
 90148: void ChannelMediaResource::Suspend(bool aCloseImmediately)
 24020: {
 34206:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 26836: 
 28488:   nsHTMLMediaElement* element = mDecoder->GetMediaElement();
 28488:   if (!element) {
 28488:     // Shutting down; do nothing.
 28488:     return;
 28488:   }
 28488: 
 28487:   if (mChannel) {
 28487:     if (aCloseImmediately && mCacheStream.IsSeekable()) {
 28487:       // Kill off our channel right now, but don't tell anyone about it.
 79547:       mIgnoreClose = true;
 28487:       CloseChannel();
 28488:       element->DownloadSuspended();
 28487:     } else if (mSuspendCount == 0) {
 26836:       {
 64576:         MutexAutoLock lock(mLock);
 27222:         mChannelStatistics.Stop(TimeStamp::Now());
 26836:       }
 67657:       PossiblySuspend();
 28488:       element->DownloadSuspended();
 24020:     }
 28487:   }
 28487: 
 26836:   ++mSuspendCount;
 26836: }
 24020: 
 90148: void ChannelMediaResource::Resume()
 24020: {
 34206:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 28487:   NS_ASSERTION(mSuspendCount > 0, "Too many resumes!");
 26836: 
 28488:   nsHTMLMediaElement* element = mDecoder->GetMediaElement();
 28488:   if (!element) {
 28488:     // Shutting down; do nothing.
 28488:     return;
 28488:   }
 28488: 
 34505:   NS_ASSERTION(mSuspendCount > 0, "Resume without previous Suspend!");
 26836:   --mSuspendCount;
 28487:   if (mSuspendCount == 0) {
 28487:     if (mChannel) {
 28487:       // Just wake up our existing channel
 26836:       {
 64576:         MutexAutoLock lock(mLock);
 27222:         mChannelStatistics.Start(TimeStamp::Now());
 26836:       }
 28487:       // if an error occurs after Resume, assume it's because the server
 28487:       // timed out the connection and we should reopen it.
 79547:       mReopenOnError = true;
 67657:       PossiblyResume();
 28488:       element->DownloadResumed();
 28487:     } else {
108991:       int64_t totalLength = mCacheStream.GetLength();
 32909:       // If mOffset is at the end of the stream, then we shouldn't try to
 32909:       // seek to it. The seek will fail and be wasted anyway. We can leave
 32909:       // the channel dead; if the media cache wants to read some other data
 32909:       // in the future, it will call CacheClientSeek itself which will reopen the
 32909:       // channel.
 32909:       if (totalLength < 0 || mOffset < totalLength) {
 32909:         // There is (or may be) data to read at mOffset, so start reading it.
 32909:         // Need to recreate the channel.
 79547:         CacheClientSeek(mOffset, false);
 32909:       }
 28488:       element->DownloadResumed();
 28487:     }
 26836:   }
 26836: }
 26836: 
 26836: nsresult
 90148: ChannelMediaResource::RecreateChannel()
 26836: {
 27217:   nsLoadFlags loadFlags =
 27217:     nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE_IF_BUSY |
 27217:     (mLoadInBackground ? nsIRequest::LOAD_BACKGROUND : 0);
 27217: 
 27217:   nsHTMLMediaElement* element = mDecoder->GetMediaElement();
 27217:   if (!element) {
 26836:     // The decoder is being shut down, so don't bother opening a new channel
 26836:     return NS_OK;
 26836:   }
 27217:   nsCOMPtr<nsILoadGroup> loadGroup = element->GetDocumentLoadGroup();
 27217:   NS_ENSURE_TRUE(loadGroup, NS_ERROR_NULL_POINTER);
 26836: 
111227:   nsresult rv = NS_NewChannel(getter_AddRefs(mChannel),
 32901:                               mURI,
111223:                               nullptr,
 32901:                               loadGroup,
111223:                               nullptr,
 32901:                               loadFlags);
111227: 
111227:   // We have cached the Content-Type, which should not change. Give a hint to
111227:   // the channel to avoid a sniffing failure, which would be expected because we
111227:   // are probably seeking in the middle of the bitstream, and sniffing relies
111227:   // on the presence of a magic number at the beginning of the stream.
111227:   nsAutoCString contentType;
111227:   element->GetMimeType(contentType);
111227:   NS_ASSERTION(!contentType.IsEmpty(),
111227:       "When recreating a channel, we should know the Content-Type.");
111227:   mChannel->SetContentType(contentType);
111227: 
111227:   return rv;
 32901: }
 32901: 
 32905: void
 90148: ChannelMediaResource::DoNotifyDataReceived()
 32905: {
 32905:   mDataReceivedEvent.Revoke();
 32905:   mDecoder->NotifyBytesDownloaded();
 32905: }
 32905: 
 32905: void
 90148: ChannelMediaResource::CacheClientNotifyDataReceived()
 32905: {
 34206:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 34206:   // NOTE: this can be called with the media cache lock held, so don't
 34206:   // block or do anything which might try to acquire a lock!
 32905: 
 32905:   if (mDataReceivedEvent.IsPending())
 32905:     return;
 32905: 
 32905:   mDataReceivedEvent =
 90148:     NS_NewNonOwningRunnableMethod(this, &ChannelMediaResource::DoNotifyDataReceived);
 32905:   NS_DispatchToMainThread(mDataReceivedEvent.get(), NS_DISPATCH_NORMAL);
 32905: }
 32905: 
 32905: class DataEnded : public nsRunnable {
 32905: public:
 32905:   DataEnded(nsMediaDecoder* aDecoder, nsresult aStatus) :
 32905:     mDecoder(aDecoder), mStatus(aStatus) {}
 32905:   NS_IMETHOD Run() {
 32905:     mDecoder->NotifyDownloadEnded(mStatus);
 32905:     return NS_OK;
 32905:   }
 32905: private:
 32905:   nsRefPtr<nsMediaDecoder> mDecoder;
 32905:   nsresult                 mStatus;
 32905: };
 32905: 
 32905: void
 90148: ChannelMediaResource::CacheClientNotifyDataEnded(nsresult aStatus)
 32905: {
 34206:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 34206:   // NOTE: this can be called with the media cache lock held, so don't
 34206:   // block or do anything which might try to acquire a lock!
 32905: 
 32905:   nsCOMPtr<nsIRunnable> event = new DataEnded(mDecoder, aStatus);
 32905:   NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
 32905: }
 32905: 
 97204: void
 97204: ChannelMediaResource::CacheClientNotifyPrincipalChanged()
 97204: {
 97204:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 97204: 
 97204:   mDecoder->NotifyPrincipalChanged();
 97204: }
 97204: 
 32901: nsresult
108991: ChannelMediaResource::CacheClientSeek(int64_t aOffset, bool aResume)
 32901: {
 34206:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 32901: 
 32901:   CloseChannel();
 32901: 
 28487:   if (aResume) {
 28487:     NS_ASSERTION(mSuspendCount > 0, "Too many resumes!");
 28487:     // No need to mess with the channel, since we're making a new one
 28487:     --mSuspendCount;
 28487:   }
 28487: 
115534:   // Note: For chunked downloads, e.g. DASH, we need to determine which chunk
115534:   // contains the requested offset, |mOffset|. This is either previously
115534:   // requested in |Seek| or updated to the most recent bytes downloaded.
115534:   // So the process below is:
115534:   //   1 - Query decoder for chunk containing desired offset, |mOffset|.
115534:   //       Return silently if the offset is not available; suggests decoder is
115534:   //         yet to get range information.
115534:   //       Return with NetworkError for all other errors.
115534:   //
115534:   //   2 - Adjust |mByteRange|.mStart to |aOffset|, requested by media cache.
115534:   //       For seeking, the media cache always requests the start of the cache
115534:   //       block, so we need to adjust the first chunk of a seek.
115534:   //       E.g. For "DASH-WebM On Demand" this means the first chunk after
115534:   //       seeking will most likely be larger than the subsegment (cluster).
115534:   //
115534:   //   3 - Call |OpenByteRange| requesting |mByteRange| bytes.
115534: 
115534:   if (mByteRangeDownloads) {
115534:     // Query decoder for chunk containing desired offset.
115534:     nsresult rv;
115534:     {
115534:       ReentrantMonitorAutoEnter mon(mSeekOffsetMonitor);
115534:       // Ensure that media cache can only request an equal or smaller offset;
115534:       // it may be trying to include the start of a cache block.
115534:       NS_ENSURE_TRUE(aOffset <= mSeekOffset, NS_ERROR_ILLEGAL_VALUE);
115534:       rv = mDecoder->GetByteRangeForSeek(mSeekOffset, mByteRange);
115534:       mSeekOffset = -1;
115534:     }
115534:     if (rv == NS_ERROR_NOT_AVAILABLE) {
115534:       // Assume decoder will request correct bytes when range information
115534:       // becomes available. Return silently.
115534:       return NS_OK;
115534:     } else if (NS_FAILED(rv) || mByteRange.IsNull()) {
115534:       // Decoder reported an error we don't want to handle here; just return.
115534:       mDecoder->NetworkError();
115534:       CloseChannel();
115534:       return rv;
115534:     }
115534:     // Media cache may decrease offset to start of cache data block.
115534:     // Adjust start of byte range accordingly.
115534:     mByteRange.mStart = mOffset = aOffset;
115534:     return OpenByteRange(nullptr, mByteRange);
115534:   }
115534: 
106506:   mOffset = aOffset;
106506: 
106506:   if (mSuspendCount > 0) {
106506:     // Close the existing channel to force the channel to be recreated at
106506:     // the correct offset upon resume.
106506:     if (mChannel) {
106506:       mIgnoreClose = true;
106506:       CloseChannel();
106506:     }
106506:     return NS_OK;
106506:   }
106506: 
 32901:   nsresult rv = RecreateChannel();
 26836:   if (NS_FAILED(rv))
 26836:     return rv;
 32901: 
106838:   return OpenChannel(nullptr);
 26836: }
 26836: 
 26836: nsresult
 90148: ChannelMediaResource::CacheClientSuspend()
 26836: {
 79547:   Suspend(false);
 26836: 
 34206:   mDecoder->NotifySuspendedStatusChanged();
 26836:   return NS_OK;
 26836: }
 26836: 
 26836: nsresult
 90148: ChannelMediaResource::CacheClientResume()
 26836: {
 26836:   Resume();
 26836: 
 34206:   mDecoder->NotifySuspendedStatusChanged();
 26836:   return NS_OK;
 26836: }
 26836: 
108991: int64_t
108991: ChannelMediaResource::GetNextCachedData(int64_t aOffset)
 28471: {
 28471:   return mCacheStream.GetNextCachedData(aOffset);
 28471: }
 28471: 
108991: int64_t
108991: ChannelMediaResource::GetCachedDataEnd(int64_t aOffset)
 26836: {
 26836:   return mCacheStream.GetCachedDataEnd(aOffset);
 26836: }
 26836: 
 79445: bool
108991: ChannelMediaResource::IsDataCachedToEndOfResource(int64_t aOffset)
 26836: {
 26836:   return mCacheStream.IsDataCachedToEndOfStream(aOffset);
 26836: }
 26836: 
 82990: void
 90148: ChannelMediaResource::EnsureCacheUpToDate()
 82990: {
 82990:   mCacheStream.EnsureCacheUpdate();
 82990: }
 82990: 
 79445: bool
 90148: ChannelMediaResource::IsSuspendedByCache(MediaResource** aActiveResource)
 26836: {
 90148:   return mCacheStream.AreAllStreamsForResourceSuspended(aActiveResource);
 26836: }
 26836: 
 79445: bool
 90148: ChannelMediaResource::IsSuspended()
 50369: {
 64576:   MutexAutoLock lock(mLock);
 50369:   return mSuspendCount > 0;
 50369: }
 50369: 
 26836: void
 90148: ChannelMediaResource::SetReadMode(nsMediaCacheStream::ReadMode aMode)
 26836: {
 26836:   mCacheStream.SetReadMode(aMode);
 26836: }
 26836: 
 26836: void
108991: ChannelMediaResource::SetPlaybackRate(uint32_t aBytesPerSecond)
 26836: {
 26836:   mCacheStream.SetPlaybackRate(aBytesPerSecond);
 26836: }
 26836: 
 26836: void
 90148: ChannelMediaResource::Pin()
 26836: {
 26836:   mCacheStream.Pin();
 26836: }
 26836: 
 26836: void
 90148: ChannelMediaResource::Unpin()
 26836: {
 26836:   mCacheStream.Unpin();
 26836: }
 26836: 
 26836: double
 90148: ChannelMediaResource::GetDownloadRate(bool* aIsReliable)
 26836: {
 64576:   MutexAutoLock lock(mLock);
 27222:   return mChannelStatistics.GetRate(TimeStamp::Now(), aIsReliable);
 26836: }
 26836: 
108991: int64_t
 90148: ChannelMediaResource::GetLength()
 26836: {
 26836:   return mCacheStream.GetLength();
 24020: }
 24020: 
 67657: void
 90148: ChannelMediaResource::PossiblySuspend()
 67657: {
 79445:   bool isPending = false;
 67657:   nsresult rv = mChannel->IsPending(&isPending);
 67657:   if (NS_SUCCEEDED(rv) && isPending) {
 67657:     mChannel->Suspend();
 79547:     mIgnoreResume = false;
 67657:   } else {
 79547:     mIgnoreResume = true;
 67657:   }
 67657: }
 67657: 
 67657: void
 90148: ChannelMediaResource::PossiblyResume()
 67657: {
 67657:   if (!mIgnoreResume) {
 67657:     mChannel->Resume();
 67657:   } else {
 79547:     mIgnoreResume = false;
 67657:   }
 67657: }
 67657: 
 90148: class FileMediaResource : public MediaResource
 20627: {
 20627: public:
 90148:   FileMediaResource(nsMediaDecoder* aDecoder, nsIChannel* aChannel, nsIURI* aURI) :
111035:     MediaResource(aDecoder, aChannel, aURI),
111035:     mSize(-1),
110604:     mLock("FileMediaResource.mLock"),
110604:     mSizeInitialized(false)
 20627:   {
 20627:   }
 90148:   ~FileMediaResource()
 26836:   {
 26836:   }
 20627: 
 26836:   // Main thread
 21079:   virtual nsresult Open(nsIStreamListener** aStreamListener);
 20627:   virtual nsresult Close();
 79445:   virtual void     Suspend(bool aCloseImmediately) {}
 26836:   virtual void     Resume() {}
 28370:   virtual already_AddRefed<nsIPrincipal> GetCurrentPrincipal();
 93550:   virtual bool     CanClone();
 90148:   virtual MediaResource* CloneData(nsMediaDecoder* aDecoder);
108991:   virtual nsresult ReadFromCache(char* aBuffer, int64_t aOffset, uint32_t aCount);
 26836: 
 26836:   // These methods are called off the main thread.
 26836: 
 26836:   // Other thread
 26836:   virtual void     SetReadMode(nsMediaCacheStream::ReadMode aMode) {}
108991:   virtual void     SetPlaybackRate(uint32_t aBytesPerSecond) {}
108991:   virtual nsresult Read(char* aBuffer, uint32_t aCount, uint32_t* aBytes);
108991:   virtual nsresult Seek(int32_t aWhence, int64_t aOffset);
108662:   virtual void     StartSeekingForMetadata() {};
108662:   virtual void     EndSeekingForMetadata() {};
108991:   virtual int64_t  Tell();
 26836: 
 26836:   // Any thread
 26836:   virtual void    Pin() {}
 26836:   virtual void    Unpin() {}
 79445:   virtual double  GetDownloadRate(bool* aIsReliable)
 26836:   {
 26836:     // The data's all already here
 79547:     *aIsReliable = true;
 26836:     return 100*1024*1024; // arbitray, use 100MB/s
 26836:   }
110604:   virtual int64_t GetLength() {
110604:     MutexAutoLock lock(mLock);
111035:     if (mInput) {
111035:       EnsureSizeInitialized();
111035:     }
111035:     return mSizeInitialized ? mSize : 0;
110604:   }
108991:   virtual int64_t GetNextCachedData(int64_t aOffset)
 28471:   {
111035:     MutexAutoLock lock(mLock);
111035:     if (!mInput) {
111035:       return -1;
111035:     }
111035:     EnsureSizeInitialized();
 28471:     return (aOffset < mSize) ? aOffset : -1;
 28471:   }
111035:   virtual int64_t GetCachedDataEnd(int64_t aOffset) {
111035:     MutexAutoLock lock(mLock);
111035:     if (!mInput) {
111035:       return aOffset;
111035:     }
111035:     EnsureSizeInitialized();
111035:     return NS_MAX(aOffset, mSize);
111035:   }
108991:   virtual bool    IsDataCachedToEndOfResource(int64_t aOffset) { return true; }
 90148:   virtual bool    IsSuspendedByCache(MediaResource** aActiveResource)
 84350:   {
 90148:     if (aActiveResource) {
106838:       *aActiveResource = nullptr;
 84350:     }
 84350:     return false;
 84350:   }
 79445:   virtual bool    IsSuspended() { return false; }
 20627: 
 90148:   nsresult GetCachedRanges(nsTArray<MediaByteRange>& aRanges);
 63626: 
 20627: private:
110604:   // Ensures mSize is initialized, if it can be.
111035:   // mLock must be held when this is called, and mInput must be non-null.
111035:   void EnsureSizeInitialized();
110604: 
 26836:   // The file size, or -1 if not known. Immutable after Open().
111035:   // Can be used from any thread.
108991:   int64_t mSize;
 26836: 
 26836:   // This lock handles synchronisation between calls to Close() and
 26836:   // the Read, Seek, etc calls. Close must not be called while a
 26836:   // Read or Seek is in progress since it resets various internal
 26836:   // values to null.
111035:   // This lock protects mSeekable, mInput, mSize, and mSizeInitialized.
 64576:   Mutex mLock;
 26836: 
 20627:   // Seekable stream interface to file. This can be used from any
 20627:   // thread.
 20627:   nsCOMPtr<nsISeekableStream> mSeekable;
 20627: 
 20627:   // Input stream for the media data. This can be used from any
111035:   // thread. This is annulled when the decoder is being shutdown.
111035:   // The decoder can be shut down while we're calculating buffered
111035:   // ranges or seeking, so this must be null-checked before it's used.
 20627:   nsCOMPtr<nsIInputStream>  mInput;
110604: 
110604:   // Whether we've attempted to initialize mSize. Note that mSize can be -1
110604:   // when mSizeInitialized is true if we tried and failed to get the size
110604:   // of the file.
110604:   bool mSizeInitialized;
 20627: };
 20627: 
 24721: class LoadedEvent : public nsRunnable
 24721: {
 24721: public:
 26836:   LoadedEvent(nsMediaDecoder* aDecoder) :
 26836:     mDecoder(aDecoder)
 24721:   {
 24721:     MOZ_COUNT_CTOR(LoadedEvent);
 24721:   }
 24721:   ~LoadedEvent()
 24721:   {
 24721:     MOZ_COUNT_DTOR(LoadedEvent);
 24721:   }
 24721: 
 24721:   NS_IMETHOD Run() {
 24721:     mDecoder->NotifyDownloadEnded(NS_OK);
 24721:     return NS_OK;
 24721:   }
 24721: 
 24721: private:
 24721:   nsRefPtr<nsMediaDecoder> mDecoder;
 24721: };
 24721: 
111035: void FileMediaResource::EnsureSizeInitialized()
110604: {
110604:   mLock.AssertCurrentThreadOwns();
111035:   NS_ASSERTION(mInput, "Must have file input stream");
111035:   if (mSizeInitialized) {
110604:     return;
110604:   }
110604:   mSizeInitialized = true;
110604:   // Get the file size and inform the decoder.
110604:   uint64_t size;
110604:   nsresult res = mInput->Available(&size);
115367:   if (NS_SUCCEEDED(res) && size <= INT64_MAX) {
110604:     mSize = (int64_t)size;
110604:     nsCOMPtr<nsIRunnable> event = new LoadedEvent(mDecoder);
110604:     NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
110604:   }
110604: }
110604: 
 90148: nsresult FileMediaResource::GetCachedRanges(nsTArray<MediaByteRange>& aRanges)
 63626: {
110604:   MutexAutoLock lock(mLock);
111035:   if (!mInput) {
111035:     return NS_ERROR_FAILURE;
111035:   }
111035:   EnsureSizeInitialized();
 63626:   if (mSize == -1) {
 63626:     return NS_ERROR_FAILURE;
 63626:   }
 90148:   aRanges.AppendElement(MediaByteRange(0, mSize));
 63626:   return NS_OK;
 63626: }
 63626: 
 90148: nsresult FileMediaResource::Open(nsIStreamListener** aStreamListener)
 20627: {
 26836:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26836: 
 21079:   if (aStreamListener) {
106838:     *aStreamListener = nullptr;
 21079:   }
 21079: 
 68468:   nsresult rv = NS_OK;
 21079:   if (aStreamListener) {
 21079:     // The channel is already open. We need a synchronous stream that
 21079:     // implements nsISeekableStream, so we have to find the underlying
 21079:     // file and reopen it
 21079:     nsCOMPtr<nsIFileChannel> fc(do_QueryInterface(mChannel));
111255:     if (fc) {
 21079:       nsCOMPtr<nsIFile> file;
 21079:       rv = fc->GetFile(getter_AddRefs(file));
 21079:       NS_ENSURE_SUCCESS(rv, rv);
 21079: 
 21079:       rv = NS_NewLocalFileInputStream(getter_AddRefs(mInput), file);
111255:     } else if (IsBlobURI(mURI)) {
111255:       rv = NS_GetStreamForBlobURI(mURI, getter_AddRefs(mInput));
111255:     }
 21079:   } else {
 24189:     // Ensure that we never load a local file from some page on a
 24189:     // web server.
 24189:     nsHTMLMediaElement* element = mDecoder->GetMediaElement();
 24189:     NS_ENSURE_TRUE(element, NS_ERROR_FAILURE);
 24189: 
 24189:     rv = nsContentUtils::GetSecurityManager()->
 24189:            CheckLoadURIWithPrincipal(element->NodePrincipal(),
 24189:                                      mURI,
 24189:                                      nsIScriptSecurityManager::STANDARD);
 24189:     NS_ENSURE_SUCCESS(rv, rv);
 24189: 
 20627:     rv = mChannel->Open(getter_AddRefs(mInput));
 21079:   }
 20627:   NS_ENSURE_SUCCESS(rv, rv);
 20627: 
 20627:   mSeekable = do_QueryInterface(mInput);
 21079:   if (!mSeekable) {
 21079:     // XXX The file may just be a .url or similar
 21079:     // shortcut that points to a Web site. We need to fix this by
 21079:     // doing an async open and waiting until we locate the real resource,
 21079:     // then using that (if it's still a file!).
 21079:     return NS_ERROR_FAILURE;
 21079:   }
 20627: 
 21079:   return NS_OK;
 20627: }
 20627: 
 90148: nsresult FileMediaResource::Close()
 20627: {
 26836:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26836: 
 64576:   MutexAutoLock lock(mLock);
 20627:   if (mChannel) {
 26836:     mChannel->Cancel(NS_ERROR_PARSED_DATA_CACHED);
106838:     mChannel = nullptr;
106838:     mInput = nullptr;
106838:     mSeekable = nullptr;
 20627:   }
 20627: 
 20627:   return NS_OK;
 20627: }
 20627: 
 90148: already_AddRefed<nsIPrincipal> FileMediaResource::GetCurrentPrincipal()
 28370: {
 28370:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 28370: 
 28370:   nsCOMPtr<nsIPrincipal> principal;
 28370:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 28370:   if (!secMan || !mChannel)
106838:     return nullptr;
 28370:   secMan->GetChannelPrincipal(mChannel, getter_AddRefs(principal));
 28370:   return principal.forget();
 28370: }
 28370: 
 93550: bool FileMediaResource::CanClone()
 93550: {
 93550:   return true;
 93550: }
 93550: 
 90148: MediaResource* FileMediaResource::CloneData(nsMediaDecoder* aDecoder)
 32901: {
 32901:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 32901: 
 32901:   nsHTMLMediaElement* element = aDecoder->GetMediaElement();
 32901:   if (!element) {
 32901:     // The decoder is being shut down, so we can't clone
106838:     return nullptr;
 32901:   }
 32901:   nsCOMPtr<nsILoadGroup> loadGroup = element->GetDocumentLoadGroup();
106838:   NS_ENSURE_TRUE(loadGroup, nullptr);
 32901: 
 32901:   nsCOMPtr<nsIChannel> channel;
 32901:   nsresult rv =
106838:     NS_NewChannel(getter_AddRefs(channel), mURI, nullptr, loadGroup, nullptr, 0);
 32901:   if (NS_FAILED(rv))
106838:     return nullptr;
 32901: 
 90148:   return new FileMediaResource(aDecoder, channel, mURI);
 32901: }
 32901: 
108991: nsresult FileMediaResource::ReadFromCache(char* aBuffer, int64_t aOffset, uint32_t aCount)
 48904: {
 64576:   MutexAutoLock lock(mLock);
 48904:   if (!mInput || !mSeekable)
 48904:     return NS_ERROR_FAILURE;
111035:   EnsureSizeInitialized();
108991:   int64_t offset = 0;
 48904:   nsresult res = mSeekable->Tell(&offset);
 48904:   NS_ENSURE_SUCCESS(res,res);
 48904:   res = mSeekable->Seek(nsISeekableStream::NS_SEEK_SET, aOffset);
 48904:   NS_ENSURE_SUCCESS(res,res);
108991:   uint32_t bytesRead = 0;
 48904:   do {
108991:     uint32_t x = 0;
108991:     uint32_t bytesToRead = aCount - bytesRead;
 48904:     res = mInput->Read(aBuffer, bytesToRead, &x);
 48904:     bytesRead += x;
 48904:   } while (bytesRead != aCount && res == NS_OK);
 48904: 
 48904:   // Reset read head to original position so we don't disturb any other
 48904:   // reading thread.
 48904:   nsresult seekres = mSeekable->Seek(nsISeekableStream::NS_SEEK_SET, offset);
 48904: 
 48904:   // If a read failed in the loop above, we want to return its failure code.
 48904:   NS_ENSURE_SUCCESS(res,res);
 48904: 
 48904:   // Else we succeed if the reset-seek succeeds.
 48904:   return seekres;
 48904: }
 48904: 
108991: nsresult FileMediaResource::Read(char* aBuffer, uint32_t aCount, uint32_t* aBytes)
 20627: {
 64576:   MutexAutoLock lock(mLock);
 24721:   if (!mInput)
 24721:     return NS_ERROR_FAILURE;
111035:   EnsureSizeInitialized();
 24721:   return mInput->Read(aBuffer, aCount, aBytes);
 20627: }
 20627: 
108991: nsresult FileMediaResource::Seek(int32_t aWhence, int64_t aOffset)
 20627: {
 26836:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
 26836: 
 64576:   MutexAutoLock lock(mLock);
 24721:   if (!mSeekable)
 24721:     return NS_ERROR_FAILURE;
111035:   EnsureSizeInitialized();
 26836:   return mSeekable->Seek(aWhence, aOffset);
 20627: }
 20627: 
108991: int64_t FileMediaResource::Tell()
 20627: {
 26836:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
 26836: 
 64576:   MutexAutoLock lock(mLock);
 20627:   if (!mSeekable)
 20627:     return 0;
111035:   EnsureSizeInitialized();
 20627: 
108991:   int64_t offset = 0;
 20627:   mSeekable->Tell(&offset);
 20627:   return offset;
 20627: }
 20627: 
 90148: MediaResource*
 90148: MediaResource::Create(nsMediaDecoder* aDecoder, nsIChannel* aChannel)
 20627: {
 20627:   NS_ASSERTION(NS_IsMainThread(),
 90148:                "MediaResource::Open called on non-main thread");
 20627: 
 32899:   // If the channel was redirected, we want the post-redirect URI;
 32899:   // but if the URI scheme was expanded, say from chrome: to jar:file:,
 32899:   // we want the original URI.
 32899:   nsCOMPtr<nsIURI> uri;
 32899:   nsresult rv = NS_GetFinalChannelURI(aChannel, getter_AddRefs(uri));
106838:   NS_ENSURE_SUCCESS(rv, nullptr);
 20627: 
 32899:   nsCOMPtr<nsIFileChannel> fc = do_QueryInterface(aChannel);
111255:   if (fc || IsBlobURI(uri)) {
 90148:     return new FileMediaResource(aDecoder, aChannel, uri);
 26705:   }
 90148:   return new ChannelMediaResource(aDecoder, aChannel, uri);
 20627: }
 26836: 
 90148: void MediaResource::MoveLoadsToBackground() {
 27217:   NS_ASSERTION(!mLoadInBackground, "Why are you calling this more than once?");
 79547:   mLoadInBackground = true;
 27217:   if (!mChannel) {
 27217:     // No channel, resource is probably already loaded.
 27217:     return;
 27217:   }
 27217: 
 27217:   nsHTMLMediaElement* element = mDecoder->GetMediaElement();
 27217:   if (!element) {
 90148:     NS_WARNING("Null element in MediaResource::MoveLoadsToBackground()");
 27217:     return;
 27217:   }
 62568: 
 79445:   bool isPending = false;
 62568:   if (NS_SUCCEEDED(mChannel->IsPending(&isPending)) &&
 27217:       isPending) {
 27217:     nsLoadFlags loadFlags;
 94314:     DebugOnly<nsresult> rv = mChannel->GetLoadFlags(&loadFlags);
 27217:     NS_ASSERTION(NS_SUCCEEDED(rv), "GetLoadFlags() failed!");
 27217: 
 27217:     loadFlags |= nsIRequest::LOAD_BACKGROUND;
 62568:     ModifyLoadFlags(loadFlags);
 62568:   }
 62568: }
 62568: 
 90148: void MediaResource::ModifyLoadFlags(nsLoadFlags aFlags)
 62568: {
 62568:   nsCOMPtr<nsILoadGroup> loadGroup;
 94314:   DebugOnly<nsresult> rv = mChannel->GetLoadGroup(getter_AddRefs(loadGroup));
 62568:   NS_ASSERTION(NS_SUCCEEDED(rv), "GetLoadGroup() failed!");
 62568: 
 62568:   nsresult status;
 62568:   mChannel->GetStatus(&status);
 62568: 
 62568:   // Note: if (NS_FAILED(status)), the channel won't be in the load group.
 62568:   if (loadGroup &&
 62568:       NS_SUCCEEDED(status)) {
106838:     rv = loadGroup->RemoveRequest(mChannel, nullptr, status);
 62568:     NS_ASSERTION(NS_SUCCEEDED(rv), "RemoveRequest() failed!");
 62568:   }
 62568: 
 62568:   rv = mChannel->SetLoadFlags(aFlags);
 27217:   NS_ASSERTION(NS_SUCCEEDED(rv), "SetLoadFlags() failed!");
 27217: 
 62568:   if (loadGroup &&
 62568:       NS_SUCCEEDED(status)) {
106838:     rv = loadGroup->AddRequest(mChannel, nullptr);
 27217:     NS_ASSERTION(NS_SUCCEEDED(rv), "AddRequest() failed!");
 27217:   }
 27217: }
