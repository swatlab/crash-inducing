    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla FastLoad code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brendan Eich <brendan@mozilla.org> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include <string.h>
    1: #include "prtypes.h"
    1: #include "nscore.h"
    1: #include "nsDebug.h"
    1: #include "nsEnumeratorUtils.h"
    1: #include "nsMemory.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: 
    1: #include "nsIComponentManager.h"
    1: #include "nsIFile.h"
    1: #include "nsILocalFile.h"
    1: #include "nsISeekableStream.h"
    1: #include "nsISerializable.h"
    1: #include "nsIStreamBufferAccess.h"
    1: #include "nsIClassInfo.h"
    1: 
    1: #include "nsBinaryStream.h"
    1: #include "nsFastLoadFile.h"
    1: #include "nsInt64.h"
33672: #ifdef XP_UNIX
33672: #include <sys/mman.h>
33672: #endif
    1: 
58560: #ifdef XP_WIN
58560: #include <windows.h>
58560: #include "private/pprio.h"  // To get PR_ImportFile
58560: 
58560: #define MOZ_WIN_MEM_TRY_BEGIN __try {
58560: #define MOZ_WIN_MEM_TRY_CATCH(cmd) }                                \
58560:   __except(GetExceptionCode()==EXCEPTION_IN_PAGE_ERROR ?            \
58560:            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)   \
58560:   {                                                                 \
58560:     NS_WARNING("EXCEPTION_IN_PAGE_ERROR in " __FUNCTION__);         \
58560:     cmd;                                                            \
58560:   }
58560: #else
58560: #define MOZ_WIN_MEM_TRY_BEGIN {
58560: #define MOZ_WIN_MEM_TRY_CATCH(cmd) }
58560: #endif
58560: 
    1: #ifdef DEBUG_brendan
    1: # define METERING
    1: # define DEBUG_MUX
    1: #endif
    1: 
    1: #ifdef METERING
    1: # define METER(x)       x
    1: #else
    1: # define METER(x)       /* nothing */
    1: #endif
    1: 
    1: #ifdef DEBUG_MUX
    1: # include <stdio.h>
    1: # include <stdarg.h>
    1: 
    1: static void trace_mux(char mode, const char *format, ...)
    1: {
    1:     va_list ap;
    1:     static FILE *tfp;
    1:     if (!tfp) {
    1:         char tfn[16];
    1:         sprintf(tfn, "/tmp/mux.%ctrace", mode);
    1:         tfp = fopen(tfn, "w");
    1:         if (!tfp)
    1:             return;
    1:         setvbuf(tfp, NULL, _IOLBF, 0);
    1:     }
    1:     va_start(ap, format);
    1:     vfprintf(tfp, format, ap);
    1:     va_end(ap);
    1: }
    1: 
    1: # define TRACE_MUX(args) trace_mux args
    1: #else
    1: # define TRACE_MUX(args) /* nothing */
    1: #endif
    1: 
    1: /*
    1:  * Fletcher's 16-bit checksum, using 32-bit two's-complement arithmetic.
    1:  */
    1: #define FOLD_ONES_COMPLEMENT_CARRY(X)   ((X) = ((X) & 0xffff) + ((X) >> 16))
    1: #define ONES_COMPLEMENT_ACCUMULATE(X,Y) (X) += (Y); if ((X) & 0x80000000)     \
    1:                                         FOLD_ONES_COMPLEMENT_CARRY(X)
    1: #define FLETCHER_ACCUMULATE(A,B,U)      ONES_COMPLEMENT_ACCUMULATE(A, U);     \
    1:                                         ONES_COMPLEMENT_ACCUMULATE(B, A)
    1: 
    1: PRUint32
    1: NS_AccumulateFastLoadChecksum(PRUint32 *aChecksum,
    1:                               const PRUint8* aBuffer,
    1:                               PRUint32 aLength,
    1:                               PRBool aLastBuffer)
    1: {
    1:     PRUint32 C = *aChecksum;
    1:     PRUint32 A = C & 0xffff;
    1:     PRUint32 B = C >> 16;
    1: 
    1:     PRUint16 U = 0;
    1:     if (aLength >= 4) {
    1:         PRBool odd = PRWord(aBuffer) & 1;
    1:         switch (PRWord(aBuffer) & 3) {
    1:           case 3:
    1:             U = (aBuffer[0] << 8) | aBuffer[1];
    1:             FLETCHER_ACCUMULATE(A, B, U);
    1:             U = aBuffer[2];
    1:             aBuffer += 3;
    1:             aLength -= 3;
    1:             break;
    1: 
    1:           case 2:
    1:             U = (aBuffer[0] << 8) | aBuffer[1];
    1:             FLETCHER_ACCUMULATE(A, B, U);
    1:             U = 0;
    1:             aBuffer += 2;
    1:             aLength -= 2;
    1:             break;
    1: 
    1:           case 1:
    1:             U = *aBuffer++;
    1:             aLength--;
    1:             break;
    1:         }
    1: 
    1:         PRUint32 W;
    1:         if (odd) {
    1:             while (aLength > 3) {
 3233:                 W = *reinterpret_cast<const PRUint32*>(aBuffer);
    1:                 U <<= 8;
    1: #ifdef IS_BIG_ENDIAN
    1:                 U |= W >> 24;
    1:                 FLETCHER_ACCUMULATE(A, B, U);
    1:                 U = PRUint16(W >> 8);
    1:                 FLETCHER_ACCUMULATE(A, B, U);
    1:                 U = W & 0xff;
    1: #else
    1:                 U |= W & 0xff;
    1:                 FLETCHER_ACCUMULATE(A, B, U);
    1:                 U = PRUint16(W >> 8);
    1:                 U = NS_SWAP16(U);
    1:                 FLETCHER_ACCUMULATE(A, B, U);
    1:                 U = W >> 24;
    1: #endif
    1:                 aBuffer += 4;
    1:                 aLength -= 4;
    1:             }
    1:             aBuffer--;      // we're odd, we didn't checksum the last byte
    1:             aLength++;
    1:         } else {
    1:             while (aLength > 3) {
 3233:                 W = *reinterpret_cast<const PRUint32*>(aBuffer);
    1: #ifdef IS_BIG_ENDIAN
    1:                 U = W >> 16;
    1:                 FLETCHER_ACCUMULATE(A, B, U);
    1:                 U = PRUint16(W);
    1:                 FLETCHER_ACCUMULATE(A, B, U);
    1: #else
    1:                 U = NS_SWAP16(W);
    1:                 FLETCHER_ACCUMULATE(A, B, U);
    1:                 U = W >> 16;
    1:                 U = NS_SWAP16(W);
    1:                 FLETCHER_ACCUMULATE(A, B, U);
    1: #endif
    1:                 aBuffer += 4;
    1:                 aLength -= 4;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (aLastBuffer) {
    1:         NS_ASSERTION(aLength <= 4, "aLength botch");
    1:         switch (aLength) {
    1:           case 4:
    1:             U = (aBuffer[0] << 8) | aBuffer[1];
    1:             FLETCHER_ACCUMULATE(A, B, U);
    1:             U = (aBuffer[2] << 8) | aBuffer[3];
    1:             FLETCHER_ACCUMULATE(A, B, U);
    1:             break;
    1: 
    1:           case 3:
    1:             U = (aBuffer[0] << 8) | aBuffer[1];
    1:             FLETCHER_ACCUMULATE(A, B, U);
    1:             U = aBuffer[2];
    1:             FLETCHER_ACCUMULATE(A, B, U);
    1:             break;
    1: 
    1:           case 2:
    1:             U = (aBuffer[0] << 8) | aBuffer[1];
    1:             FLETCHER_ACCUMULATE(A, B, U);
    1:             break;
    1: 
    1:           case 1:
    1:             U = aBuffer[0];
    1:             FLETCHER_ACCUMULATE(A, B, U);
    1:             break;
    1:         }
    1: 
    1:         aLength = 0;
    1:     }
    1: 
    1:     while (A >> 16)
    1:         FOLD_ONES_COMPLEMENT_CARRY(A);
    1:     while (B >> 16)
    1:         FOLD_ONES_COMPLEMENT_CARRY(B);
    1: 
    1:     *aChecksum = (B << 16) | A;
    1:     return aLength;
    1: }
    1: 
    1: PRUint32
    1: NS_AddFastLoadChecksums(PRUint32 sum1, PRUint32 sum2, PRUint32 sum2ByteCount)
    1: {
    1:     PRUint32 A1 = sum1 & 0xffff;
    1:     PRUint32 B1 = sum1 >> 16;
    1: 
    1:     PRUint32 A2 = sum2 & 0xffff;
    1:     PRUint32 B2 = sum2 >> 16;
    1: 
    1:     PRUint32 A = A1 + A2;
    1:     while (A >> 16)
    1:         FOLD_ONES_COMPLEMENT_CARRY(A);
    1: 
    1:     PRUint32 B = B2;
    1:     for (PRUint32 n = (sum2ByteCount + 1) / 2; n != 0; n--)
    1:         ONES_COMPLEMENT_ACCUMULATE(B, B1);
    1:     while (B >> 16)
    1:         FOLD_ONES_COMPLEMENT_CARRY(B);
    1: 
    1:     return (B << 16) | A;
    1: }
    1: 
    1: #undef FOLD_ONES_COMPLEMENT_CARRY
    1: #undef ONES_COMPLEMENT_ACCUMULATE
    1: #undef FLETCHER_ACCUMULATE
    1: 
    1: static const char magic[] = MFL_FILE_MAGIC;
    1: 
    1: // -------------------------- nsFastLoadFileReader --------------------------
    1: 
    1: nsID nsFastLoadFileReader::nsFastLoadFooter::gDummyID;
    1: nsFastLoadFileReader::nsObjectMapEntry
    1:     nsFastLoadFileReader::nsFastLoadFooter::gDummySharpObjectEntry;
    1: 
    1: NS_IMPL_ISUPPORTS_INHERITED5(nsFastLoadFileReader,
    1:                              nsBinaryInputStream,
    1:                              nsIObjectInputStream,
    1:                              nsIFastLoadFileControl,
    1:                              nsIFastLoadReadControl,
    1:                              nsISeekableStream,
    1:                              nsIFastLoadFileReader)
    1: 
    1: nsresult
    1: nsFastLoadFileReader::ReadHeader(nsFastLoadHeader *aHeader)
    1: {
    1:     nsresult rv;
    1:     PRUint32 bytesRead;
    1: 
 3233:     rv = Read(reinterpret_cast<char*>(aHeader), sizeof *aHeader, &bytesRead);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (bytesRead != sizeof *aHeader ||
    1:         memcmp(aHeader->mMagic, magic, MFL_FILE_MAGIC_SIZE)) {
    1:         return NS_ERROR_UNEXPECTED;
    1:     }
    1: 
    1:     aHeader->mChecksum     = NS_SWAP32(aHeader->mChecksum);
    1:     aHeader->mVersion      = NS_SWAP32(aHeader->mVersion);
    1:     aHeader->mFooterOffset = NS_SWAP32(aHeader->mFooterOffset);
    1:     aHeader->mFileSize     = NS_SWAP32(aHeader->mFileSize);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: // nsIFastLoadFileControl methods:
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::GetChecksum(PRUint32 *aChecksum)
    1: {
    1:     *aChecksum = mHeader.mChecksum;
    1:     return NS_OK;
    1: }
    1: 
    1: struct nsStringMapEntry : public PLDHashEntryHdr {
    1:     const char*     mString;            // key, must come first
    1:     nsISupports*    mURI;               // for SelectMuxedDocument return value
    1: };
    1: 
    1: struct nsDocumentMapEntry : public nsStringMapEntry {
    1:     PRUint32    mInitialSegmentOffset;  // offset of URI's first segment in file
    1: };
    1: 
    1: struct nsDocumentMapReadEntry : public nsDocumentMapEntry {
    1:     PRUint32    mNextSegmentOffset;     // offset of URI's next segment to read
    1:     PRUint32    mBytesLeft : 31,        // bytes remaining in current segment
    1:                 mNeedToSeek : 1;        // flag to defer Seek from Select to
    1:                                         // Read, in case there is no Read before
    1:                                         // another entry is Selected (to improve
    1:                                         // input stream buffer utilization)
    1:     PRInt64     mSaveOffset;            // in case demux schedule differs from
    1:                                         // mux schedule
    1: };
    1: 
20261: static void
    1: strmap_ClearEntry(PLDHashTable *aTable, PLDHashEntryHdr *aHdr)
    1: {
 3233:     nsStringMapEntry* entry = static_cast<nsStringMapEntry*>(aHdr);
    1: 
    1:     if (entry->mString)
    1:         nsMemory::Free((void*) entry->mString);
    1:     NS_IF_RELEASE(entry->mURI);
    1:     PL_DHashClearEntryStub(aTable, aHdr);
    1: }
    1: 
    1: static const PLDHashTableOps strmap_DHashTableOps = {
    1:     PL_DHashAllocTable,
    1:     PL_DHashFreeTable,
    1:     PL_DHashStringKey,
    1:     PL_DHashMatchStringKey,
    1:     PL_DHashMoveEntryStub,
    1:     strmap_ClearEntry,
    1:     PL_DHashFinalizeStub,
    1:     NULL
    1: };
    1: 
    1: // An nsObjectMapEntry holds a strong reference to an XPCOM object, unless the
    1: // mObject member, when cast to NSFastLoadOID, has its MFL_OBJECT_DEF_TAG bit
    1: // set.  NB: we rely on the fact that an nsISupports* is never an odd pointer.
    1: struct nsObjectMapEntry : public PLDHashEntryHdr {
    1:     nsISupports*            mObject;        // key, must come first
    1: };
    1: 
    1: // Fast mapping from URI object pointer back to spec-indexed document info.
    1: struct nsURIMapReadEntry : public nsObjectMapEntry {
    1:     nsDocumentMapReadEntry* mDocMapEntry;
    1: };
    1: 
20261: static void
    1: objmap_ClearEntry(PLDHashTable *aTable, PLDHashEntryHdr *aHdr)
    1: {
 3233:     nsObjectMapEntry* entry = static_cast<nsObjectMapEntry*>(aHdr);
    1: 
    1:     // Ignore tagged object ids stored as object pointer keys (the updater
    1:     // code does this).
    1:     if ((NS_PTR_TO_INT32(entry->mObject) & MFL_OBJECT_DEF_TAG) == 0)
    1:         NS_IF_RELEASE(entry->mObject);
    1:     PL_DHashClearEntryStub(aTable, aHdr);
    1: }
    1: 
    1: static const PLDHashTableOps objmap_DHashTableOps = {
    1:     PL_DHashAllocTable,
    1:     PL_DHashFreeTable,
    1:     PL_DHashVoidPtrKeyStub,
    1:     PL_DHashMatchEntryStub,
    1:     PL_DHashMoveEntryStub,
    1:     objmap_ClearEntry,
    1:     PL_DHashFinalizeStub,
    1:     NULL
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::HasMuxedDocument(const char* aURISpec, PRBool *aResult)
    1: {
    1:     nsDocumentMapReadEntry* docMapEntry =
 3233:         static_cast<nsDocumentMapReadEntry*>
 3233:                    (PL_DHashTableOperate(&mFooter.mDocumentMap, aURISpec,
    1:                                          PL_DHASH_LOOKUP));
    1: 
    1:     *aResult = PL_DHASH_ENTRY_IS_BUSY(docMapEntry);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::StartMuxedDocument(nsISupports* aURI, const char* aURISpec)
    1: {
    1:     nsDocumentMapReadEntry* docMapEntry =
 3233:         static_cast<nsDocumentMapReadEntry*>
 3233:                    (PL_DHashTableOperate(&mFooter.mDocumentMap, aURISpec,
    1:                                          PL_DHASH_LOOKUP));
    1: 
    1:     // If the spec isn't in the map, return NS_ERROR_NOT_AVAILABLE so the
    1:     // FastLoad service can try for a file update.
    1:     if (PL_DHASH_ENTRY_IS_FREE(docMapEntry))
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     nsCOMPtr<nsISupports> key(do_QueryInterface(aURI));
    1:     nsURIMapReadEntry* uriMapEntry =
 3233:         static_cast<nsURIMapReadEntry*>
 3233:                    (PL_DHashTableOperate(&mFooter.mURIMap, key,
    1:                                          PL_DHASH_ADD));
    1:     if (!uriMapEntry)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     NS_ASSERTION(uriMapEntry->mDocMapEntry == nsnull,
    1:                  "URI mapped to two different specs?");
    1:     if (uriMapEntry->mDocMapEntry)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     docMapEntry->mURI = aURI;
    1:     NS_ADDREF(docMapEntry->mURI);
    1:     uriMapEntry->mObject = key;
    1:     NS_ADDREF(uriMapEntry->mObject);
    1:     uriMapEntry->mDocMapEntry = docMapEntry;
    1:     TRACE_MUX(('r', "start %p (%p) %s\n", aURI, key.get(), aURISpec));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::SelectMuxedDocument(nsISupports* aURI,
    1:                                           nsISupports** aResult)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Find the given URI's entry and select it for more reading.
    1:     nsCOMPtr<nsISupports> key(do_QueryInterface(aURI));
    1:     nsURIMapReadEntry* uriMapEntry =
 3233:         static_cast<nsURIMapReadEntry*>
 3233:                    (PL_DHashTableOperate(&mFooter.mURIMap, key,
    1:                                          PL_DHASH_LOOKUP));
    1: 
    1:     // If the URI isn't in the map, return NS_ERROR_NOT_AVAILABLE so the
    1:     // FastLoad service can try selecting the file updater.
    1:     if (PL_DHASH_ENTRY_IS_FREE(uriMapEntry))
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     // If we're interrupting another document's segment, save its offset so
    1:     // we can seek back when it's reselected.  If prevDocMapEntry->mNeedToSeek
    1:     // is set, that means the stream is not positioned for prevDocMapEntry, to
    1:     // avoid buffer thrashing.  See below in this function for more.
    1:     nsDocumentMapReadEntry* prevDocMapEntry = mCurrentDocumentMapEntry;
    1:     if (prevDocMapEntry &&
    1:         prevDocMapEntry->mBytesLeft &&
    1:         !prevDocMapEntry->mNeedToSeek) {
    1:         rv = Tell(&prevDocMapEntry->mSaveOffset);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     // It turns out we get a fair amount of redundant select calls, thanks to
    1:     // non-blocking hunks of data from the parser that are devoid of scripts.
    1:     // As more data gets FastLoaded, the number of these useless selects will
    1:     // decline.
    1:     nsDocumentMapReadEntry* docMapEntry = uriMapEntry->mDocMapEntry;
    1:     if (docMapEntry == prevDocMapEntry) {
    1:         TRACE_MUX(('r', "select prev %s same as current!\n",
    1:                    docMapEntry->mString));
    1:     }
    1: 
    1:     // Invariant: docMapEntry->mBytesLeft implies docMapEntry->mSaveOffset has
    1:     // been set non-zero by the Tell call above.
    1:     else if (docMapEntry->mBytesLeft) {
    1:         NS_ASSERTION(docMapEntry->mSaveOffset != 0,
    1:                      "reselecting from multiplex at unsaved offset?");
    1: 
    1:         // Defer Seek till Read, in case of "ping-pong" Selects without any
    1:         // intervening Reads, to avoid dumping the underlying mInputStream's
    1:         // input buffer for cases where alternate "pongs" fall in the same
    1:         // buffer.
    1:         docMapEntry->mNeedToSeek = PR_TRUE;
    1:     }
    1: 
    1:     *aResult = prevDocMapEntry ? prevDocMapEntry->mURI : nsnull;
    1:     NS_IF_ADDREF(*aResult);
    1: 
    1:     mCurrentDocumentMapEntry = docMapEntry;
    1: #ifdef DEBUG_MUX
    1:     PRInt64 currentSegmentOffset;
    1:     Tell(&currentSegmentOffset);
    1:     trace_mux('r', "select %p (%p) offset %ld\n",
    1:               aURI, key.get(), (long) currentSegmentOffset);
    1: #endif
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::EndMuxedDocument(nsISupports* aURI)
    1: {
    1:     nsCOMPtr<nsISupports> key(do_QueryInterface(aURI));
    1:     nsURIMapReadEntry* uriMapEntry =
 3233:         static_cast<nsURIMapReadEntry*>
 3233:                    (PL_DHashTableOperate(&mFooter.mURIMap, key,
    1:                                          PL_DHASH_LOOKUP));
    1: 
    1:     // If the URI isn't in the map, return NS_ERROR_NOT_AVAILABLE so the
    1:     // FastLoad service can try to end a select on its file updater.
    1:     if (PL_DHASH_ENTRY_IS_FREE(uriMapEntry))
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     // Drop our ref to the URI object that was passed to StartMuxedDocument,
    1:     // we no longer need it, and we do not want to extend its lifetime.
    1:     if (uriMapEntry->mDocMapEntry)
    1:         NS_RELEASE(uriMapEntry->mDocMapEntry->mURI);
    1: 
    1:     // Shrink the table if half the entries are removed sentinels.
    1:     PRUint32 size = PL_DHASH_TABLE_SIZE(&mFooter.mURIMap);
    1:     if (mFooter.mURIMap.removedCount >= (size >> 2))
    1:         PL_DHashTableOperate(&mFooter.mURIMap, key, PL_DHASH_REMOVE);
    1:     else
    1:         PL_DHashTableRawRemove(&mFooter.mURIMap, uriMapEntry);
    1: 
    1:     TRACE_MUX(('r', "end %p (%p)\n", aURI, key.get()));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::Read(char* aBuffer, PRUint32 aCount, PRUint32 *aBytesRead)
    1: {
    1:     nsDocumentMapReadEntry* entry = mCurrentDocumentMapEntry;
    1:     if (entry) {
    1:         // Don't call our Seek wrapper, as it clears mCurrentDocumentMapEntry.
    1:         if (entry->mNeedToSeek) {
33672:             SeekTo(entry->mSaveOffset);
    1:             entry->mNeedToSeek = PR_FALSE;
    1:         }
    1: 
    1:         // Loop to handle empty segments, which may be generated by the
    1:         // writer, given Start A; Start B; Select A; Select B; write B data;
    1:         // multiplexing schedules, which do tend to occur given non-blocking
    1:         // i/o with LIFO scheduling.  XXXbe investigate LIFO issues
    1:         while (entry->mBytesLeft == 0) {
    1:             // Check for unexpected end of multiplexed stream.
    1:             NS_ASSERTION(entry->mNextSegmentOffset != 0,
    1:                          "document demuxed from FastLoad file more than once?");
    1:             if (entry->mNextSegmentOffset == 0)
    1:                 return NS_ERROR_UNEXPECTED;
    1: 
33672:             SeekTo(entry->mNextSegmentOffset);
    1:             // Clear mCurrentDocumentMapEntry temporarily to avoid recursion.
    1:             mCurrentDocumentMapEntry = nsnull;
    1: 
33672:             nsresult rv = Read32(&entry->mNextSegmentOffset);
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 PRUint32 bytesLeft = 0;
    1:                 rv = Read32(&bytesLeft);
    1:                 entry->mBytesLeft = bytesLeft;
    1:             }
    1: 
    1:             mCurrentDocumentMapEntry = entry;
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1: 
    1:             NS_ASSERTION(entry->mBytesLeft >= 8, "demux segment length botch!");
    1:             entry->mBytesLeft -= 8;
    1:         }
    1:     }
36799:     if (!mFileData)
36799:         return NS_BASE_STREAM_CLOSED;
36799: 
33672:     PRUint32 count = PR_MIN(mFileLen - mFilePos, aCount);
58560: MOZ_WIN_MEM_TRY_BEGIN
33672:     memcpy(aBuffer, mFileData+mFilePos, count);
58560: MOZ_WIN_MEM_TRY_CATCH(return NS_ERROR_FAILURE)
33672:     *aBytesRead = count;
33672:     mFilePos += count;
33672:     if (entry) {
    1:         NS_ASSERTION(entry->mBytesLeft >= *aBytesRead, "demux Read underflow!");
    1:         entry->mBytesLeft -= *aBytesRead;
    1: 
    1: #ifdef NS_DEBUG
    1:         // Invariant: !entry->mBytesLeft implies entry->mSaveOffset == 0.
    1:         if (entry->mBytesLeft == 0)
    1:             entry->mSaveOffset = 0;
    1: #endif
    1:     }
33672:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
    1:                                    PRUint32 aCount, PRUint32 *aResult)
    1: {
    1:     nsDocumentMapReadEntry* entry = mCurrentDocumentMapEntry;
    1: 
    1:     NS_ASSERTION(!entry || (!entry->mNeedToSeek && entry->mBytesLeft != 0),
    1:                  "ReadSegments called from above nsFastLoadFileReader layer?!");
    1: 
36799:     if (!mFileData)
36799:         return NS_BASE_STREAM_CLOSED;
36799: 
33672:     PRUint32 count = PR_MIN(mFileLen - mFilePos, aCount);
33672: 
58560: MOZ_WIN_MEM_TRY_BEGIN
33672:     // Errors returned from the writer get ignored.
33672:     aWriter(this, aClosure, (char*)(mFileData + mFilePos), 0,
33672:             count, aResult);
58560: MOZ_WIN_MEM_TRY_CATCH(return NS_ERROR_FAILURE)
33672:     mFilePos += count;
33672:     if (entry) {
    1:         NS_ASSERTION(entry->mBytesLeft >= *aResult,
    1:                      "demux ReadSegments underflow!");
    1:         entry->mBytesLeft -= *aResult;
    1: 
    1: #ifdef NS_DEBUG
    1:         // Invariant: !entry->mBytesLeft implies entry->mSaveOffset == 0.
    1:         if (entry->mBytesLeft == 0)
    1:             entry->mSaveOffset = 0;
    1: #endif
    1:     }
33672:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::ComputeChecksum(PRUint32 *aResult)
    1: {
    1:     PRUint32 checksum = 0;
33672:     // Skip first 2 fields.
33672:     PRUint32 pos = offsetof(nsFastLoadHeader, mVersion);
58560: #ifdef XP_WIN
58560:     if (pos != PR_Seek(mFD, pos, PR_SEEK_SET))
58560:         return NS_ERROR_FAILURE;
58560:     PRUint32 len, rem = 0;
58560:     char buf[64 * 1024];
58560:     while ((len = PR_Read(mFD, buf + rem, sizeof(buf) - rem)) && len > 0) {
58560:         len += rem;
58560:         rem = NS_AccumulateFastLoadChecksum(&checksum,
58560:                                             reinterpret_cast<PRUint8*>(buf),
58560:                                             len,
58560:                                             PR_FALSE);
58560:         if (rem)
58560:             memcpy(buf, buf + len - rem, rem);
58560:     }
58560:     if (len < 0)
58560:         return NS_ERROR_FAILURE;
58560: 
58560:     if (rem) {
58560:         NS_AccumulateFastLoadChecksum(&checksum,
58560:                                       reinterpret_cast<PRUint8*>(buf),
58560:                                       rem,
58560:                                       PR_TRUE);
58560:     }
58560: 
58560: #else
    1:     NS_AccumulateFastLoadChecksum(&checksum,
33672:                                   mFileData + pos,
33672:                                   mFileLen - pos,
    1:                                   PR_TRUE);
58560: #endif
    1:     *aResult = checksum;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::GetDependencies(nsISimpleEnumerator* *aDependencies)
    1: {
    1:     return NS_NewArrayEnumerator(aDependencies, mFooter.mDependencies);
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileReader::ReadFooter(nsFastLoadFooter *aFooter)
    1: {
    1:     nsresult rv;
    1: 
    1:     rv = ReadFooterPrefix(aFooter);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     aFooter->mIDMap = new nsID[aFooter->mNumIDs];
    1:     if (!aFooter->mIDMap)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     PRUint32 i, n;
    1:     for (i = 0, n = aFooter->mNumIDs; i < n; i++) {
    1:         rv = ReadSlowID(&aFooter->mIDMap[i]);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     aFooter->mObjectMap = new nsObjectMapEntry[aFooter->mNumSharpObjects];
    1:     if (!aFooter->mObjectMap)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     for (i = 0, n = aFooter->mNumSharpObjects; i < n; i++) {
    1:         nsObjectMapEntry* entry = &aFooter->mObjectMap[i];
    1: 
    1:         rv = ReadSharpObjectInfo(entry);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         entry->mReadObject = nsnull;
    1:         entry->mSkipOffset = 0;
    1:         entry->mSaveStrongRefCnt = entry->mStrongRefCnt;
    1:         entry->mSaveWeakRefCnt = entry->mWeakRefCnt;
    1:     }
    1: 
    1:     if (!PL_DHashTableInit(&aFooter->mDocumentMap, &strmap_DHashTableOps,
    1:                            (void *)this, sizeof(nsDocumentMapReadEntry),
    1:                            aFooter->mNumMuxedDocuments)) {
    1:         aFooter->mDocumentMap.ops = nsnull;
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     if (!PL_DHashTableInit(&aFooter->mURIMap, &objmap_DHashTableOps,
    1:                            (void *)this, sizeof(nsURIMapReadEntry),
    1:                            aFooter->mNumMuxedDocuments)) {
    1:         aFooter->mURIMap.ops = nsnull;
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     for (i = 0, n = aFooter->mNumMuxedDocuments; i < n; i++) {
    1:         nsFastLoadMuxedDocumentInfo info;
    1: 
    1:         rv = ReadMuxedDocumentInfo(&info);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         nsDocumentMapReadEntry* entry =
 3233:             static_cast<nsDocumentMapReadEntry*>
 3233:                        (PL_DHashTableOperate(&aFooter->mDocumentMap,
    1:                                              info.mURISpec,
    1:                                              PL_DHASH_ADD));
    1:         if (!entry) {
    1:             nsMemory::Free((void*) info.mURISpec);
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1: 
    1:         NS_ASSERTION(!entry->mString, "duplicate URISpec in MuxedDocumentMap");
    1:         entry->mString = info.mURISpec;
    1:         entry->mURI = nsnull;
    1:         entry->mInitialSegmentOffset = info.mInitialSegmentOffset;
    1:         entry->mNextSegmentOffset = info.mInitialSegmentOffset;
    1:         entry->mBytesLeft = 0;
    1:         entry->mNeedToSeek = PR_FALSE;
    1:         entry->mSaveOffset = 0;
    1:     }
    1: 
    1:     nsCOMPtr<nsISupportsArray> readDeps;
    1:     rv = NS_NewISupportsArray(getter_AddRefs(readDeps));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsCAutoString filename;
    1:     for (i = 0, n = aFooter->mNumDependencies; i < n; i++) {
    1:         rv = ReadCString(filename);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         PRInt64 fastLoadMtime;
 3233:         rv = Read64(reinterpret_cast<PRUint64*>(&fastLoadMtime));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         nsCOMPtr<nsILocalFile> file;
    1:         rv = NS_NewNativeLocalFile(filename, PR_TRUE, getter_AddRefs(file));
    1:         if (NS_FAILED(rv))
    1:             return rv;
33900: #ifdef DEBUG
    1:         PRInt64 currentMtime;
    1:         rv = file->GetLastModifiedTime(&currentMtime);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         if (LL_NE(fastLoadMtime, currentMtime)) {
    1:             nsCAutoString path;
    1:             file->GetNativePath(path);
    1:             printf("%s mtime changed, invalidating FastLoad file\n",
    1:                    path.get());
    1:             return NS_ERROR_FAILURE;
    1:         }
33900: #endif
    1: 
    1:         rv = readDeps->AppendElement(file);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     aFooter->mDependencies = readDeps;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileReader::ReadFooterPrefix(nsFastLoadFooterPrefix *aFooterPrefix)
    1: {
    1:     nsresult rv;
    1: 
    1:     rv = Read32(&aFooterPrefix->mNumIDs);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Read32(&aFooterPrefix->mNumSharpObjects);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Read32(&aFooterPrefix->mNumMuxedDocuments);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Read32(&aFooterPrefix->mNumDependencies);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileReader::ReadSlowID(nsID *aID)
    1: {
    1:     nsresult rv;
    1: 
    1:     rv = Read32(&aID->m0);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Read16(&aID->m1);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Read16(&aID->m2);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRUint32 bytesRead;
 3233:     rv = Read(reinterpret_cast<char*>(aID->m3), sizeof aID->m3, &bytesRead);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (bytesRead != sizeof aID->m3)
    1:         return NS_ERROR_FAILURE;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileReader::ReadFastID(NSFastLoadID *aID)
    1: {
    1:     nsresult rv = Read32(aID);
    1:     if (NS_SUCCEEDED(rv))
    1:         *aID ^= MFL_ID_XOR_KEY;
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileReader::ReadSharpObjectInfo(nsFastLoadSharpObjectInfo *aInfo)
    1: {
    1:     nsresult rv;
    1: 
    1:     rv = Read32(&aInfo->mCIDOffset);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     NS_ASSERTION(aInfo->mCIDOffset != 0,
    1:                  "fastload reader: mCIDOffset cannot be zero!");
    1: 
    1:     rv = Read16(&aInfo->mStrongRefCnt);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Read16(&aInfo->mWeakRefCnt);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileReader::ReadMuxedDocumentInfo(nsFastLoadMuxedDocumentInfo *aInfo)
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCAutoString spec;
    1:     rv = ReadCString(spec);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Read32(&aInfo->mInitialSegmentOffset);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     aInfo->mURISpec = ToNewCString(spec);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileReader::Open()
    1: {
    1:     nsresult rv;
58560:     PRFileDesc *fd;    // OS file-descriptor
58560:     {    
58560: #ifdef XP_WIN
58560:     nsAutoString name;
58560:     rv = mFile->GetPath(name);
58560:     NS_ENSURE_SUCCESS(rv, rv);
58560:     // By not using OpenNSPRFileDesc can pass FILE_FLAG_SEQUENTIAL_SCAN so Windows reads in the file faster
58560:     HANDLE winFD = ::CreateFileW(name.get(), GENERIC_READ, FILE_SHARE_READ,
58560:                                  NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
58560:     if (winFD == INVALID_HANDLE_VALUE)
58560:         return NS_ERROR_FAILURE;
58560:     fd = PR_ImportFile((PROsfd) winFD);
58560: #else
33672:     nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(mFile, &rv);
33672:     if (NS_FAILED(rv))
33672:         return rv;
36799:     rv = localFile->OpenNSPRFileDesc(PR_RDONLY, 0, &fd);
    1:     if (NS_FAILED(rv))
    1:         return rv;
58560: #endif
58560:     }
36799:     PRInt64 size = PR_Available64(fd);
36799:     if (size >= PR_INT32_MAX) {
36799:         PR_Close(fd);
33672:         return NS_ERROR_FILE_TOO_BIG;
36799:     }
    1: 
33672:     mFileLen = (PRUint32) size;
36799:     if (mFileLen < sizeof(nsFastLoadHeader)) {
36799:         PR_Close(fd);
33672:         return NS_ERROR_FAILURE;
36799:     }
36799: 
36799:     mFileMap = PR_CreateFileMap(fd, mFileLen, PR_PROT_READONLY);
36799:     if (!mFileMap) {
36799:         PR_Close(fd);
36799:         return NS_ERROR_FAILURE;
36799:     }
33672: 
33672:     mFileData = (PRUint8*) PR_MemMap(mFileMap, 0, mFileLen);
58560: #ifdef XP_WIN
58560:     mFD = fd;
58560: #else
58560:     // At this point the non-mmap file descriptor is no longer needed on non-windows
36799:     PR_Close(fd);
58560: #endif
36799: 
36799:     if (!mFileData)
33672:         return NS_ERROR_FAILURE;
33672: 
34724: #if defined(XP_UNIX)
34724:     madvise((char *)mFileData, mFileLen, MADV_WILLNEED);
33672: #endif
33672: 
58560: MOZ_WIN_MEM_TRY_BEGIN
33672:     rv = ReadHeader(&mHeader);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
34222:     PRUint32 checksum;
34222:     rv = ComputeChecksum(&checksum);
34222:     if (NS_FAILED(rv))
34222:         return rv;
34222: 
34222:     if (checksum != mHeader.mChecksum)
34222:         return NS_ERROR_FAILURE;
34222: 
33672:     if (mHeader.mVersion != MFL_FILE_VERSION ||
33672:         mHeader.mFooterOffset == 0 ||
33672:         memcmp(mHeader.mMagic, magic, MFL_FILE_MAGIC_SIZE))
    1:         return NS_ERROR_UNEXPECTED;
    1: 
33672:     SeekTo(mHeader.mFooterOffset);
    1: 
    1:     rv = ReadFooter(&mFooter);
58560: 
58560: MOZ_WIN_MEM_TRY_CATCH(return NS_ERROR_FAILURE)
58560: 
    1:    if (NS_FAILED(rv))
    1:         return rv;
    1: 
33672:     SeekTo(sizeof(nsFastLoadHeader));
33672:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::Close()
    1: {
    1:     // Give up our strong "keepalive" references, in case not all objects that
    1:     // were deserialized were fully re-connected.
    1:     //
    1:     // This happens for sure when an nsFastLoadFileUpdater is created and wraps
    1:     // an nsFastLoadFileReader whose data was already deserialized by an earlier
    1:     // FastLoad episode.  The reader is useful in the second such episode during
    1:     // a session not so much for reading objects as for its footer information,
    1:     // which primes the updater's tables so that after the update completes, the
    1:     // FastLoad file has a superset footer.
36799:     if (mFileData) {
33672:         PR_MemUnmap(mFileData, mFileLen);
33672:         mFileData = nsnull;
36799:     }
36799: 
36799:     if (mFileMap) {
33672:         PR_CloseFileMap(mFileMap);
33672:         mFileMap = nsnull;
33672:     }
33972:     
58560: #ifdef XP_WIN
58560:     mFD = nsnull;
58560: #endif
58560: 
36799:     mFileLen = 0;
36799:     mFilePos = 0;
36799: 
33972:     if (!mFooter.mObjectMap)
33972:         return NS_OK;
33972: 
    1:     for (PRUint32 i = 0, n = mFooter.mNumSharpObjects; i < n; i++) {
    1:         nsObjectMapEntry* entry = &mFooter.mObjectMap[i];
    1:         entry->mReadObject = nsnull;
    1:     }
33884:     mFooter.mNumSharpObjects = 0;
    1: 
33672:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileReader::DeserializeObject(nsISupports* *aObject)
    1: {
    1:     nsresult rv;
    1:     NSFastLoadID fastCID;
    1: 
    1:     rv = ReadFastID(&fastCID);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     const nsID& slowCID = mFooter.GetID(fastCID);
    1:     nsCOMPtr<nsISupports> object(do_CreateInstance(slowCID, &rv));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsCOMPtr<nsISerializable> serializable(do_QueryInterface(object));
    1:     if (!serializable)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     rv = serializable->Read(this);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *aObject = object;
    1:     NS_ADDREF(*aObject);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileReader::ReadObject(PRBool aIsStrongRef, nsISupports* *aObject)
    1: {
    1:     nsresult rv;
    1:     NSFastLoadOID oid;
    1: 
    1:     rv = Read32(&oid);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1:     oid ^= MFL_OID_XOR_KEY;
    1: 
    1:     nsCOMPtr<nsISupports> object;
    1: 
    1:     if (oid == MFL_DULL_OBJECT_OID) {
    1:         // A very dull object, defined at point of single (strong) reference.
    1:         NS_ASSERTION(aIsStrongRef, "dull object read via weak ref!");
    1: 
    1:         rv = DeserializeObject(getter_AddRefs(object));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     } else {
    1:         NS_ASSERTION((oid & MFL_WEAK_REF_TAG) ==
    1:                      (aIsStrongRef ? 0 : MFL_WEAK_REF_TAG),
    1:                      "strong vs. weak ref deserialization mismatch!");
    1: 
    1:         nsObjectMapEntry* entry = &mFooter.GetSharpObjectEntry(oid);
    1: 
    1:         // Check whether we've already deserialized the object for this OID.
    1:         object = entry->mReadObject;
    1:         if (!object) {
    1:             nsDocumentMapReadEntry* saveDocMapEntry = nsnull;
    1: 
33672:             PRUint32 saveOffset32 = mFilePos;
    1:             if (entry->mCIDOffset != saveOffset32) {
    1:                 // We skipped deserialization of this object from its position
    1:                 // earlier in the input stream, presumably due to the reference
    1:                 // there being an nsFastLoadPtr, or (more likely) because the
    1:                 // object was muxed in another document, and deserialization
    1:                 // order does not match serialization order.  So we must seek
    1:                 // back and read it now.
    1:                 NS_ASSERTION(entry->mCIDOffset < saveOffset32,
    1:                              "out of order object?!");
    1: 
    1:                 // Ape our Seek wrapper by clearing mCurrentDocumentMapEntry.
    1:                 // This allows for a skipped object to be referenced from two
    1:                 // or more multiplexed documents in the FastLoad file.
    1:                 saveDocMapEntry = mCurrentDocumentMapEntry;
    1:                 mCurrentDocumentMapEntry = nsnull;
33672:                 SeekTo(entry->mCIDOffset);
    1:             }
    1: 
    1:             rv = DeserializeObject(getter_AddRefs(object));
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1: 
    1:             if (entry->mCIDOffset != saveOffset32) {
    1:                 // Save the "skip offset" in case we need to skip this object
    1:                 // definition when reading forward, later on.
33672:                 entry->mSkipOffset = mFilePos;
    1:                 // Restore stream offset and mCurrentDocumentMapEntry in case
    1:                 // we're still reading forward through a part of the multiplex
    1:                 // to get object definitions eagerly.
33672:                 SeekTo(saveOffset32);
    1:                 mCurrentDocumentMapEntry = saveDocMapEntry;
    1:             }
    1: 
    1:             // Save object until all refs have been deserialized.
    1:             entry->mReadObject = object;
    1:         } else {
    1:             // What if we are at a definition that's already been read?  This
    1:             // case arises when a sharp object's def is serialized before its
    1:             // refs, while a non-defining ref is deserialized before the def.
    1:             // We must skip over the object definition.
    1:             if (oid & MFL_OBJECT_DEF_TAG) {
    1:                 NS_ASSERTION(entry->mSkipOffset != 0, "impossible! see above");
    1: 
    1:                 // Since we are seeking within a muxed segment, we must adjust
    1:                 // mBytesLeft, so that Seek called from Read will be triggered
    1:                 // when mBytesLeft goes to zero.
33672:                 PRUint32 currentOffset = mFilePos;
    1:                 NS_ASSERTION(entry->mSkipOffset > (PRUint32)currentOffset,
    1:                              "skipping backwards from object?!");
    1:                 NS_ASSERTION(mCurrentDocumentMapEntry->mBytesLeft >=
    1:                              entry->mSkipOffset - (PRUint32)currentOffset,
    1:                              "skipped object buffer underflow!");
    1: 
    1:                 mCurrentDocumentMapEntry->mBytesLeft -=
    1:                     entry->mSkipOffset - (PRUint32)currentOffset;
    1: 
33672:                 SeekTo(entry->mSkipOffset);
    1:             }
    1:         }
    1: 
    1:         if (aIsStrongRef) {
    1:             NS_ASSERTION(entry->mStrongRefCnt != 0,
    1:                          "mStrongRefCnt underflow!");
    1:             --entry->mStrongRefCnt;
    1:         } else {
    1:             NS_ASSERTION(MFL_GET_WEAK_REFCNT(entry) != 0,
    1:                          "mWeakRefCnt underflow!");
    1:             MFL_DROP_WEAK_REFCNT(entry);
    1:         }
    1: 
    1:         if (entry->mStrongRefCnt == 0 && MFL_GET_WEAK_REFCNT(entry) == 0)
    1:             entry->mReadObject = nsnull;
    1:     }
    1: 
    1:     if (oid & MFL_QUERY_INTERFACE_TAG) {
    1:         NSFastLoadID iid;
    1:         rv = ReadFastID(&iid);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         rv = object->QueryInterface(mFooter.GetID(iid),
 3233:                                     reinterpret_cast<void**>(aObject));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     } else {
    1:         *aObject = object;
    1:         NS_ADDREF(*aObject);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::ReadID(nsID *aResult)
    1: {
    1:     nsresult rv;
    1:     NSFastLoadID fastID;
    1: 
    1:     rv = ReadFastID(&fastID);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *aResult = mFooter.GetID(fastID);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::Seek(PRInt32 aWhence, PRInt64 aOffset)
    1: {
33672:     NS_ASSERTION(aWhence == nsISeekableStream::NS_SEEK_SET, "Only NS_SEEK_SET seeks are supported");
    1:     mCurrentDocumentMapEntry = nsnull;
33672:     SeekTo(aOffset);
33672:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::Tell(PRInt64 *aResult)
    1: {
33672:     *aResult = mFilePos;
33672:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileReader::SetEOF()
    1: {
33672:     NS_ERROR("Refusing to truncate a memory-mapped file");
33672:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_COM nsresult
33672: NS_NewFastLoadFileReader(nsIObjectInputStream* *aResult, nsIFile *aFile)
    1: {
33672:     nsFastLoadFileReader* reader = new nsFastLoadFileReader(aFile);
    1:     if (!reader)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // Stabilize reader's refcnt.
    1:     nsCOMPtr<nsIObjectInputStream> stream(reader);
    1: 
    1:     nsresult rv = reader->Open();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *aResult = stream;
    1:     NS_ADDREF(*aResult);
    1:     return NS_OK;
    1: }
    1: 
    1: // -------------------------- nsFastLoadFileWriter --------------------------
    1: 
    1: NS_IMPL_ISUPPORTS_INHERITED4(nsFastLoadFileWriter,
    1:                              nsBinaryOutputStream,
    1:                              nsIObjectOutputStream,
    1:                              nsIFastLoadFileControl,
    1:                              nsIFastLoadWriteControl,
    1:                              nsISeekableStream)
    1: 
    1: struct nsIDMapEntry : public PLDHashEntryHdr {
    1:     NSFastLoadID    mFastID;            // 1 + nsFastLoadFooter::mIDMap index
    1:     nsID            mSlowID;            // key, used by PLDHashTableOps below
    1: };
    1: 
20261: static PLDHashNumber
    1: idmap_HashKey(PLDHashTable *aTable, const void *aKey)
    1: {
 3233:     const nsID *idp = reinterpret_cast<const nsID*>(aKey);
    1: 
    1:     return idp->m0;
    1: }
    1: 
20261: static PRBool
    1: idmap_MatchEntry(PLDHashTable *aTable,
    1:                 const PLDHashEntryHdr *aHdr,
    1:                 const void *aKey)
    1: {
 3233:     const nsIDMapEntry* entry = static_cast<const nsIDMapEntry*>(aHdr);
 3233:     const nsID *idp = reinterpret_cast<const nsID*>(aKey);
    1: 
    1:     return memcmp(&entry->mSlowID, idp, sizeof(nsID)) == 0;
    1: }
    1: 
    1: static const PLDHashTableOps idmap_DHashTableOps = {
    1:     PL_DHashAllocTable,
    1:     PL_DHashFreeTable,
    1:     idmap_HashKey,
    1:     idmap_MatchEntry,
    1:     PL_DHashMoveEntryStub,
    1:     PL_DHashClearEntryStub,
    1:     PL_DHashFinalizeStub,
    1:     NULL
    1: };
    1: 
    1: nsresult
    1: nsFastLoadFileWriter::MapID(const nsID& aSlowID, NSFastLoadID *aResult)
    1: {
    1:     nsIDMapEntry* entry =
 3233:         static_cast<nsIDMapEntry*>
 3233:                    (PL_DHashTableOperate(&mIDMap, &aSlowID, PL_DHASH_ADD));
    1:     if (!entry)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     if (entry->mFastID == 0) {
    1:         entry->mFastID = mIDMap.entryCount;
    1:         entry->mSlowID = aSlowID;
    1:     }
    1: 
    1:     *aResult = entry->mFastID;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileWriter::WriteHeader(nsFastLoadHeader *aHeader)
    1: {
    1:     nsresult rv;
    1:     PRUint32 bytesWritten;
    1: 
    1:     rv = Write(aHeader->mMagic, MFL_FILE_MAGIC_SIZE, &bytesWritten);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (bytesWritten != MFL_FILE_MAGIC_SIZE)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     rv = Write32(aHeader->mChecksum);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write32(aHeader->mVersion);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write32(aHeader->mFooterOffset);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write32(aHeader->mFileSize);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: // nsIFastLoadFileControl methods:
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::GetChecksum(PRUint32 *aChecksum)
    1: {
    1:     if (mHeader.mChecksum == 0)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     *aChecksum = mHeader.mChecksum;
    1:     return NS_OK;
    1: }
    1: 
    1: struct nsDocumentMapWriteEntry : public nsDocumentMapEntry {
    1:     PRUint32    mCurrentSegmentOffset;      // last written segment's offset
    1: };
    1: 
    1: // Fast mapping from URI object pointer back to spec-indexed document info.
    1: // We also may need the slow mapping from mURISpec to nsDocumentMapWriteEntry,
    1: // because the writer's mDocumentMap double hash table may grow "behind the
    1: // back of" each mURIMap entry's mDocMapEntry member.
    1: struct nsURIMapWriteEntry : public nsObjectMapEntry {
    1:     nsDocumentMapWriteEntry* mDocMapEntry;
    1:     PRUint32                 mGeneration;
    1:     const char*              mURISpec;
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::HasMuxedDocument(const char* aURISpec, PRBool *aResult)
    1: {
    1:     nsDocumentMapWriteEntry* docMapEntry =
 3233:         static_cast<nsDocumentMapWriteEntry*>
 3233:                    (PL_DHashTableOperate(&mDocumentMap, aURISpec,
    1:                                          PL_DHASH_LOOKUP));
    1: 
    1:     *aResult = PL_DHASH_ENTRY_IS_BUSY(docMapEntry);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::StartMuxedDocument(nsISupports* aURI,
    1:                                          const char* aURISpec)
    1: {
    1:     // Save mDocumentMap table generation and mCurrentDocumentMapEntry key in
    1:     // case the hash table grows during the PL_DHASH_ADD operation.
    1:     PRUint32 saveGeneration = mDocumentMap.generation;
    1:     const char* saveURISpec = mCurrentDocumentMapEntry
    1:                               ? mCurrentDocumentMapEntry->mString
    1:                               : nsnull;
    1: 
    1:     nsDocumentMapWriteEntry* docMapEntry =
 3233:         static_cast<nsDocumentMapWriteEntry*>
 3233:                    (PL_DHashTableOperate(&mDocumentMap, aURISpec,
    1:                                          PL_DHASH_ADD));
    1:     if (!docMapEntry)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // If the generation number changed, refresh mCurrentDocumentMapEntry.
    1:     if (mCurrentDocumentMapEntry && mDocumentMap.generation != saveGeneration) {
    1:         mCurrentDocumentMapEntry =
 3233:             static_cast<nsDocumentMapWriteEntry*>
 3233:                        (PL_DHashTableOperate(&mDocumentMap, saveURISpec,
    1:                                              PL_DHASH_LOOKUP));
    1:         NS_ASSERTION(PL_DHASH_ENTRY_IS_BUSY(mCurrentDocumentMapEntry),
    1:                      "mCurrentDocumentMapEntry lost during table growth?!");
    1: 
    1:         // Refresh saveGeneration for use below when initializing uriMapEntry.
    1:         saveGeneration = mDocumentMap.generation;
    1:     }
    1: 
12946:     NS_WARN_IF_FALSE(docMapEntry->mString == nsnull,
    1:                      "redundant multiplexed document?");
    1:     if (docMapEntry->mString)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     void* spec = nsMemory::Clone(aURISpec, strlen(aURISpec) + 1);
    1:     if (!spec)
    1:         return NS_ERROR_OUT_OF_MEMORY;
 3233:     docMapEntry->mString = reinterpret_cast<const char*>(spec);
    1:     docMapEntry->mURI = aURI;
    1:     NS_ADDREF(docMapEntry->mURI);
    1: 
    1:     nsCOMPtr<nsISupports> key(do_QueryInterface(aURI));
    1:     nsURIMapWriteEntry* uriMapEntry =
 3233:         static_cast<nsURIMapWriteEntry*>
 3233:                    (PL_DHashTableOperate(&mURIMap, key, PL_DHASH_ADD));
    1:     if (!uriMapEntry)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     NS_ASSERTION(uriMapEntry->mDocMapEntry == nsnull,
    1:                  "URI mapped to two different specs?");
    1:     if (uriMapEntry->mDocMapEntry)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     uriMapEntry->mObject = key;
    1:     NS_ADDREF(uriMapEntry->mObject);
    1:     uriMapEntry->mDocMapEntry = docMapEntry;
    1:     uriMapEntry->mGeneration = saveGeneration;
 3233:     uriMapEntry->mURISpec = reinterpret_cast<const char*>(spec);
    1:     TRACE_MUX(('w', "start %p (%p) %s\n", aURI, key.get(), aURISpec));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::SelectMuxedDocument(nsISupports* aURI,
    1:                                           nsISupports** aResult)
    1: {
    1:     // Capture the current file offset (XXXbe maintain our own via Write?)
    1:     nsresult rv;
    1:     PRInt64 currentSegmentOffset;
    1:     rv = mSeekableOutput->Tell(&currentSegmentOffset);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRUint32 currentSegmentOffset32 = currentSegmentOffset;
    1:     // Look for an existing entry keyed by aURI, added by StartMuxedDocument.
    1:     nsCOMPtr<nsISupports> key(do_QueryInterface(aURI));
    1:     nsURIMapWriteEntry* uriMapEntry =
 3233:         static_cast<nsURIMapWriteEntry*>
 3233:                    (PL_DHashTableOperate(&mURIMap, key, PL_DHASH_LOOKUP));
    1:     NS_ASSERTION(PL_DHASH_ENTRY_IS_BUSY(uriMapEntry),
    1:                  "SelectMuxedDocument without prior StartMuxedDocument?");
    1:     if (PL_DHASH_ENTRY_IS_FREE(uriMapEntry))
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     // Beware that uriMapEntry->mDocMapEntry may be stale, if an mDocumentMap
    1:     // addition caused that table to grow.  We save the mDocumentMap generation
    1:     // in each uriMapEntry and compare it to the current generation, rehashing
    1:     // uriMapEntry->mURISpec if necessary.
    1: 
    1:     nsDocumentMapWriteEntry* docMapEntry = uriMapEntry->mDocMapEntry;
    1:     if (uriMapEntry->mGeneration != mDocumentMap.generation) {
    1:         docMapEntry =
 3233:             static_cast<nsDocumentMapWriteEntry*>
 3233:                        (PL_DHashTableOperate(&mDocumentMap,
    1:                                              uriMapEntry->mURISpec,
    1:                                              PL_DHASH_LOOKUP));
    1:         NS_ASSERTION(PL_DHASH_ENTRY_IS_BUSY(docMapEntry), "lost mDocMapEntry!?");
    1:         uriMapEntry->mDocMapEntry = docMapEntry;
    1:         uriMapEntry->mGeneration = mDocumentMap.generation;
    1:     }
    1: 
    1:     // If there is a muxed document segment open, close it now by setting its
    1:     // length, stored in the second PRUint32 of the segment.
    1:     nsDocumentMapWriteEntry* prevDocMapEntry = mCurrentDocumentMapEntry;
    1:     if (prevDocMapEntry) {
    1:         if (prevDocMapEntry == docMapEntry) {
    1:             TRACE_MUX(('w', "select prev %s same as current!\n",
    1:                        prevDocMapEntry->mString));
    1:             *aResult = docMapEntry->mURI;
    1:             NS_ADDREF(*aResult);
    1:             return NS_OK;
    1:         }
    1: 
    1:         PRUint32 prevSegmentOffset = prevDocMapEntry->mCurrentSegmentOffset;
    1:         TRACE_MUX(('w', "select prev %s offset %lu\n",
    1:                    prevDocMapEntry->mString, prevSegmentOffset));
    1: 
    1:         rv = mSeekableOutput->Seek(nsISeekableStream::NS_SEEK_SET,
    1:                                    prevSegmentOffset + 4);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         // The length counts all bytes in the segment, including the header
    1:         // that contains [nextSegmentOffset, length].
    1:         rv = Write32(currentSegmentOffset32 - prevSegmentOffset);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         // Seek back to the current offset only if we are not going to seek
    1:         // back to *this* entry's last "current" segment offset and write its
    1:         // next segment offset at the first PRUint32 of the segment.
    1:         if (!docMapEntry->mInitialSegmentOffset) {
    1:             rv = mSeekableOutput->Seek(nsISeekableStream::NS_SEEK_SET,
    1:                                        currentSegmentOffset);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:         }
    1:     }
    1: 
    1:     // If this entry was newly added, set its key and initial segment offset.
    1:     // Otherwise, seek back to write the next segment offset of the previous
    1:     // segment for this document in the multiplex.
    1:     if (!docMapEntry->mInitialSegmentOffset) {
    1:         docMapEntry->mInitialSegmentOffset = currentSegmentOffset32;
    1:     } else {
    1:         rv = mSeekableOutput->Seek(nsISeekableStream::NS_SEEK_SET,
    1:                                    docMapEntry->mCurrentSegmentOffset);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         rv = Write32(currentSegmentOffset32);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         rv = mSeekableOutput->Seek(nsISeekableStream::NS_SEEK_SET,
    1:                                    currentSegmentOffset);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     // Update this document's current segment offset so we can later fix its
    1:     // next segment offset (unless it is last, in which case we leave the zero
    1:     // placeholder as a terminator).
    1:     docMapEntry->mCurrentSegmentOffset = currentSegmentOffset32;
    1: 
    1:     rv = Write32(0);    // nextSegmentOffset placeholder
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write32(0);    // length placeholder
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *aResult = prevDocMapEntry ? prevDocMapEntry->mURI : nsnull;
    1:     NS_IF_ADDREF(*aResult);
    1: 
    1:     mCurrentDocumentMapEntry = docMapEntry;
    1:     TRACE_MUX(('w', "select %p (%p) offset %lu\n",
    1:                aURI, key.get(), currentSegmentOffset));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::EndMuxedDocument(nsISupports* aURI)
    1: {
    1:     nsCOMPtr<nsISupports> key(do_QueryInterface(aURI));
    1:     nsURIMapWriteEntry* uriMapEntry =
 3233:         static_cast<nsURIMapWriteEntry*>
 3233:                    (PL_DHashTableOperate(&mURIMap, key, PL_DHASH_LOOKUP));
    1: 
    1:     // If the URI isn't in the map, nsFastLoadFileWriter::StartMuxedDocument
    1:     // must have been called with a redundant URI, *and* its caller must have
    1:     // ignored the NS_ERROR_UNEXPECTED it returned in that case.
    1:     if (PL_DHASH_ENTRY_IS_FREE(uriMapEntry)) {
    1:         TRACE_MUX(('w', "bad end %p (%p)\n", aURI, key.get()));
    1:         return NS_ERROR_UNEXPECTED;
    1:     }
    1: 
    1:     // Drop our ref to the URI object that was passed to StartMuxedDocument,
    1:     // we no longer need it, and we do not want to extend its lifetime.
    1:     if (uriMapEntry->mDocMapEntry)
    1:         NS_RELEASE(uriMapEntry->mDocMapEntry->mURI);
    1: 
    1:     // Shrink the table if half the entries are removed sentinels.
    1:     PRUint32 size = PL_DHASH_TABLE_SIZE(&mURIMap);
    1:     if (mURIMap.removedCount >= (size >> 2))
    1:         PL_DHashTableOperate(&mURIMap, key, PL_DHASH_REMOVE);
    1:     else
    1:         PL_DHashTableRawRemove(&mURIMap, uriMapEntry);
    1: 
    1:     TRACE_MUX(('w', "end %p (%p)\n", aURI, key.get()));
    1:     return NS_OK;
    1: }
    1: 
    1: struct nsDependencyMapEntry : public nsStringMapEntry {
    1:     PRInt64 mLastModified;
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::AddDependency(nsIFile* aFile)
    1: {
    1:     nsCAutoString path;
    1:     nsresult rv = aFile->GetNativePath(path);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsDependencyMapEntry* entry =
 3233:         static_cast<nsDependencyMapEntry*>
 3233:                    (PL_DHashTableOperate(&mDependencyMap, path.get(),
    1:                                          PL_DHASH_ADD));
    1:     if (!entry)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     if (!entry->mString) {
    1:         const char *tmp = ToNewCString(path);
    1:         if (!tmp)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         entry->mString = tmp;
    1: 
    1:         // If we can't get the last modified time from aFile, assume it does
    1:         // not exist, or is otherwise inaccessible to us (due to permissions),
    1:         // remove the dependency, and suppress the failure.
    1:         //
    1:         // Otherwise, we would end up aborting the fastload process due to a
    1:         // missing .js or .xul or other file on every startup.
    1: 
    1:         rv = aFile->GetLastModifiedTime(&entry->mLastModified);
    1:         if (NS_FAILED(rv)) {
    1:             PL_DHashTableOperate(&mDependencyMap, path.get(), PL_DHASH_REMOVE);
    1:             rv = NS_OK;
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileWriter::WriteFooterPrefix(const nsFastLoadFooterPrefix& aFooterPrefix)
    1: {
    1:     nsresult rv;
    1: 
    1:     rv = Write32(aFooterPrefix.mNumIDs);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write32(aFooterPrefix.mNumSharpObjects);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write32(aFooterPrefix.mNumMuxedDocuments);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write32(aFooterPrefix.mNumDependencies);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileWriter::WriteSlowID(const nsID& aID)
    1: {
    1:     nsresult rv;
    1: 
    1:     rv = Write32(aID.m0);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write16(aID.m1);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write16(aID.m2);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRUint32 bytesWritten;
 3233:     rv = Write(reinterpret_cast<const char*>(aID.m3), sizeof aID.m3,
    1:                &bytesWritten);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (bytesWritten != sizeof aID.m3)
    1:         return NS_ERROR_FAILURE;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileWriter::WriteFastID(NSFastLoadID aID)
    1: {
    1:     return Write32(aID ^ MFL_ID_XOR_KEY);
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileWriter::WriteSharpObjectInfo(const nsFastLoadSharpObjectInfo& aInfo)
    1: {
    1:     nsresult rv;
    1: 
    1:     NS_ASSERTION(aInfo.mCIDOffset != 0,
    1:                  "fastload writer: mCIDOffset cannot be zero!");
    1: 
    1:     rv = Write32(aInfo.mCIDOffset);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write16(aInfo.mStrongRefCnt);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write16(aInfo.mWeakRefCnt);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileWriter::WriteMuxedDocumentInfo(const nsFastLoadMuxedDocumentInfo& aInfo)
    1: {
    1:     nsresult rv;
    1: 
    1:     rv = WriteStringZ(aInfo.mURISpec);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write32(aInfo.mInitialSegmentOffset);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return NS_OK;
    1: }
    1: 
20261: PLDHashOperator
    1: nsFastLoadFileWriter::IDMapEnumerate(PLDHashTable *aTable,
    1:                                      PLDHashEntryHdr *aHdr,
    1:                                      PRUint32 aNumber,
    1:                                      void *aData)
    1: {
 3233:     nsIDMapEntry* entry = static_cast<nsIDMapEntry*>(aHdr);
    1:     PRUint32 index = entry->mFastID - 1;
 3233:     nsID* vector = reinterpret_cast<nsID*>(aData);
    1: 
    1:     NS_ASSERTION(index < aTable->entryCount, "bad nsIDMap index!");
    1:     vector[index] = entry->mSlowID;
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
    1: struct nsSharpObjectMapEntry : public nsObjectMapEntry {
    1:     NSFastLoadOID               mOID;
    1:     nsFastLoadSharpObjectInfo   mInfo;
    1: };
    1: 
20261: PLDHashOperator
    1: nsFastLoadFileWriter::ObjectMapEnumerate(PLDHashTable *aTable,
    1:                                          PLDHashEntryHdr *aHdr,
    1:                                          PRUint32 aNumber,
    1:                                          void *aData)
    1: {
 3233:     nsSharpObjectMapEntry* entry = static_cast<nsSharpObjectMapEntry*>(aHdr);
    1:     PRUint32 index = MFL_OID_TO_SHARP_INDEX(entry->mOID);
    1:     nsFastLoadSharpObjectInfo* vector =
 3233:         reinterpret_cast<nsFastLoadSharpObjectInfo*>(aData);
    1: 
    1:     NS_ASSERTION(index < aTable->entryCount, "bad nsObjectMap index!");
    1:     vector[index] = entry->mInfo;
    1: 
    1:     NS_ASSERTION(entry->mInfo.mStrongRefCnt, "no strong ref in serialization!");
    1: 
    1:     // Ignore tagged object ids stored as object pointer keys (the updater
    1:     // code does this).
    1:     if ((NS_PTR_TO_INT32(entry->mObject) & MFL_OBJECT_DEF_TAG) == 0)
    1:         NS_RELEASE(entry->mObject);
    1: 
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
20261: PLDHashOperator
    1: nsFastLoadFileWriter::DocumentMapEnumerate(PLDHashTable *aTable,
    1:                                            PLDHashEntryHdr *aHdr,
    1:                                            PRUint32 aNumber,
    1:                                            void *aData)
    1: {
    1:     nsFastLoadFileWriter* writer =
 3233:         reinterpret_cast<nsFastLoadFileWriter*>(aTable->data);
    1:     nsDocumentMapWriteEntry* entry =
 3233:         static_cast<nsDocumentMapWriteEntry*>(aHdr);
 3233:     nsresult* rvp = reinterpret_cast<nsresult*>(aData);
    1: 
    1:     nsFastLoadMuxedDocumentInfo info;
    1:     info.mURISpec = entry->mString;
    1:     info.mInitialSegmentOffset = entry->mInitialSegmentOffset;
    1:     *rvp = writer->WriteMuxedDocumentInfo(info);
    1: 
    1:     return NS_FAILED(*rvp) ? PL_DHASH_STOP : PL_DHASH_NEXT;
    1: }
    1: 
20261: PLDHashOperator
    1: nsFastLoadFileWriter::DependencyMapEnumerate(PLDHashTable *aTable,
    1:                                              PLDHashEntryHdr *aHdr,
    1:                                              PRUint32 aNumber,
    1:                                              void *aData)
    1: {
    1:     nsFastLoadFileWriter* writer =
 3233:         reinterpret_cast<nsFastLoadFileWriter*>(aTable->data);
 3233:     nsDependencyMapEntry* entry = static_cast<nsDependencyMapEntry*>(aHdr);
 3233:     nsresult* rvp = reinterpret_cast<nsresult*>(aData);
    1: 
    1:     *rvp = writer->WriteStringZ(entry->mString);
    1:     if (NS_SUCCEEDED(*rvp))
    1:         *rvp = writer->Write64(entry->mLastModified);
    1: 
    1:     return NS_FAILED(*rvp) ? PL_DHASH_STOP :PL_DHASH_NEXT;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileWriter::WriteFooter()
    1: {
    1:     nsresult rv;
    1:     PRUint32 i, count;
    1: 
    1:     nsFastLoadFooterPrefix footerPrefix;
    1:     footerPrefix.mNumIDs = mIDMap.entryCount;
    1:     footerPrefix.mNumSharpObjects = mObjectMap.entryCount;
    1:     footerPrefix.mNumMuxedDocuments = mDocumentMap.entryCount;
    1:     footerPrefix.mNumDependencies = mDependencyMap.entryCount;
    1: 
    1:     rv = WriteFooterPrefix(footerPrefix);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Enumerate mIDMap into a vector indexed by mFastID and write it.
    1:     nsID* idvec = new nsID[footerPrefix.mNumIDs];
    1:     if (!idvec)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     count = PL_DHashTableEnumerate(&mIDMap, IDMapEnumerate, idvec);
    1:     NS_ASSERTION(count == footerPrefix.mNumIDs, "bad mIDMap enumeration!");
    1:     for (i = 0; i < count; i++) {
    1:         rv = WriteSlowID(idvec[i]);
    1:         if (NS_FAILED(rv)) break;
    1:     }
    1: 
    1:     delete[] idvec;
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Enumerate mObjectMap into a vector indexed by mOID and write it.
    1:     nsFastLoadSharpObjectInfo* objvec =
    1:         new nsFastLoadSharpObjectInfo[footerPrefix.mNumSharpObjects];
    1:     if (!objvec)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: #ifdef NS_DEBUG
    1:     memset(objvec, 0, footerPrefix.mNumSharpObjects *
    1:                       sizeof(nsFastLoadSharpObjectInfo));
    1: #endif
    1: 
    1:     count = PL_DHashTableEnumerate(&mObjectMap, ObjectMapEnumerate, objvec);
    1:     NS_ASSERTION(count == footerPrefix.mNumSharpObjects,
    1:                  "bad mObjectMap enumeration!");
    1:     for (i = 0; i < count; i++) {
    1:         rv = WriteSharpObjectInfo(objvec[i]);
    1:         if (NS_FAILED(rv)) break;
    1:     }
    1: 
    1:     delete[] objvec;
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Enumerate mDocumentMap, writing nsFastLoadMuxedDocumentInfo records
    1:     count = PL_DHashTableEnumerate(&mDocumentMap, DocumentMapEnumerate, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     NS_ASSERTION(count == footerPrefix.mNumMuxedDocuments,
    1:                  "bad mDocumentMap enumeration!");
    1: 
    1:     // Write out make-like file dependencies.
    1:     count = PL_DHashTableEnumerate(&mDependencyMap, DependencyMapEnumerate, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileWriter::Init()
    1: {
    1:     if (!PL_DHashTableInit(&mIDMap, &idmap_DHashTableOps, (void *)this,
    1:                            sizeof(nsIDMapEntry), PL_DHASH_MIN_SIZE)) {
    1:         mIDMap.ops = nsnull;
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     if (!PL_DHashTableInit(&mObjectMap, &objmap_DHashTableOps, (void *)this,
    1:                            sizeof(nsSharpObjectMapEntry), PL_DHASH_MIN_SIZE)) {
    1:         mObjectMap.ops = nsnull;
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     if (!PL_DHashTableInit(&mDocumentMap, &strmap_DHashTableOps, (void *)this,
    1:                            sizeof(nsDocumentMapWriteEntry),
    1:                            PL_DHASH_MIN_SIZE)) {
    1:         mDocumentMap.ops = nsnull;
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     if (!PL_DHashTableInit(&mURIMap, &objmap_DHashTableOps, (void *)this,
    1:                            sizeof(nsURIMapWriteEntry), PL_DHASH_MIN_SIZE)) {
    1:         mURIMap.ops = nsnull;
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     if (!PL_DHashTableInit(&mDependencyMap, &strmap_DHashTableOps, (void *)this,
    1:                            sizeof(nsDependencyMapEntry), PL_DHASH_MIN_SIZE)) {
    1:         mDependencyMap.ops = nsnull;
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileWriter::Open()
    1: {
    1:     nsresult rv;
    1: 
54201:     if (!mSeekableOutput)
54201:         return NS_ERROR_FAILURE;
54201: 
    1:     rv = mSeekableOutput->Seek(nsISeekableStream::NS_SEEK_SET,
    1:                                sizeof(nsFastLoadHeader));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return Init();
    1: }
    1: 
33672: #define MFL_CHECKSUM_BUFSIZE    (6 * 8192)
33672: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::Close()
    1: {
    1:     nsresult rv;
    1: 
    1:     memcpy(mHeader.mMagic, magic, MFL_FILE_MAGIC_SIZE);
    1:     mHeader.mChecksum = 0;
    1:     mHeader.mVersion = MFL_FILE_VERSION;
    1: 
    1:     PRInt64 footerOffset;
    1:     rv = mSeekableOutput->Tell(&footerOffset);
    1: 
    1:     LL_L2UI(mHeader.mFooterOffset, footerOffset);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // If there is a muxed document segment open, close it now by setting its
    1:     // length, stored in the second PRUint32 of the segment.
    1:     if (mCurrentDocumentMapEntry) {
    1:         PRUint32 currentSegmentOffset =
    1:             mCurrentDocumentMapEntry->mCurrentSegmentOffset;
    1:         rv = mSeekableOutput->Seek(nsISeekableStream::NS_SEEK_SET,
    1:                                    currentSegmentOffset + 4);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         rv = Write32(mHeader.mFooterOffset - currentSegmentOffset);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         // Seek back to the current offset to write the footer.
    1:         rv = mSeekableOutput->Seek(nsISeekableStream::NS_SEEK_SET,
    1:                                    mHeader.mFooterOffset);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         mCurrentDocumentMapEntry = nsnull;
    1:     }
    1: 
    1:     rv = WriteFooter();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1:     PRInt64 fileSize;
    1:     rv = mSeekableOutput->Tell(&fileSize);
    1:     LL_L2UI(mHeader.mFileSize, fileSize);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = mSeekableOutput->Seek(nsISeekableStream::NS_SEEK_SET, 0);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = WriteHeader(&mHeader);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Now compute the checksum, using mFileIO to get an input stream on the
    1:     // underlying FastLoad file.
    1:     if (mFileIO) {
    1:         // Get the unbuffered output stream, which flushes the buffered header
    1:         // so we can read and checksum it along with the rest of the file, and
    1:         // which allows us to write the checksum directly.
    1:         nsCOMPtr<nsIOutputStream> output;
    1:         rv = mBufferAccess->GetUnbufferedStream(getter_AddRefs(output));
    1:         if (NS_FAILED(rv) || !output)
    1:             return NS_ERROR_UNEXPECTED;
    1: 
    1:         nsCOMPtr<nsIInputStream> input;
    1:         rv = mFileIO->GetInputStream(getter_AddRefs(input));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
33672:         // Seek the input stream to right after checksum/magic.
    1:         nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(input);
33672:         rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET,
33672:                             offsetof(nsFastLoadHeader, mVersion));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         char buf[MFL_CHECKSUM_BUFSIZE];
    1:         PRUint32 len, rem = 0;
    1:         PRUint32 checksum = 0;
    1: 
    1:         // Ok, we're finally ready to checksum the FastLoad file we just wrote!
    1:         while (NS_SUCCEEDED(rv =
    1:                             input->Read(buf + rem, sizeof buf - rem, &len)) &&
    1:                len) {
    1:             len += rem;
    1:             rem = NS_AccumulateFastLoadChecksum(&checksum,
 3233:                                                 reinterpret_cast<PRUint8*>
 3233:                                                                 (buf),
    1:                                                 len,
    1:                                                 PR_FALSE);
    1:             if (rem)
    1:                 memcpy(buf, buf + len - rem, rem);
    1:         }
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         if (rem) {
    1:             NS_AccumulateFastLoadChecksum(&checksum,
 3233:                                           reinterpret_cast<PRUint8*>(buf),
    1:                                           rem,
    1:                                           PR_TRUE);
    1:         }
    1: 
    1:         // Store the checksum in the FastLoad file header and remember it via
    1:         // mHeader.mChecksum, for GetChecksum.
    1:         seekable = do_QueryInterface(output);
    1:         rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET,
    1:                             offsetof(nsFastLoadHeader, mChecksum));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         mHeader.mChecksum = checksum;
    1:         checksum = NS_SWAP32(checksum);
    1:         PRUint32 bytesWritten;
 3233:         rv = output->Write(reinterpret_cast<char*>(&checksum),
    1:                            sizeof checksum,
    1:                            &bytesWritten);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:         if (bytesWritten != sizeof checksum)
    1:             return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     return mOutputStream->Close();
    1: }
    1: 
    1: // Pseudo-tag used as flag between WriteSingleRefObject and WriteObjectCommon.
    1: #define MFL_SINGLE_REF_PSEUDO_TAG       PR_BIT(MFL_OBJECT_TAG_BITS)
    1: 
    1: nsresult
    1: nsFastLoadFileWriter::WriteObjectCommon(nsISupports* aObject,
    1:                                         PRBool aIsStrongRef,
    1:                                         PRUint32 aTags)
    1: {
    1:     nsrefcnt rc;
    1:     nsresult rv;
    1: 
    1:     NS_ASSERTION((NS_PTR_TO_INT32(aObject) & MFL_OBJECT_DEF_TAG) == 0,
    1:                  "odd nsISupports*, oh no!");
    1: 
    1:     // Here be manual refcounting dragons!
    1:     rc = aObject->AddRef();
    1:     NS_ASSERTION(rc != 0, "bad refcnt when writing aObject!");
    1: 
    1:     NSFastLoadOID oid;
    1:     nsCOMPtr<nsIClassInfo> classInfo;
    1: 
    1:     if (rc == 2 && (aTags & MFL_SINGLE_REF_PSEUDO_TAG)) {
    1:         // Dull object: only one strong ref and no weak refs in serialization.
    1:         // Conservative: we don't trust the caller if there are more than two
    1:         // refs (one from the AddRef above, one from the data structure that's
    1:         // being serialized).
    1:         oid = MFL_DULL_OBJECT_OID;
    1:         aObject->Release();
    1:     } else {
    1:         // Object is presumed to be multiply connected through some combo of
    1:         // strong and weak refs.  Hold onto it via mObjectMap.
    1:         nsSharpObjectMapEntry* entry =
 3233:             static_cast<nsSharpObjectMapEntry*>
 3233:                        (PL_DHashTableOperate(&mObjectMap, aObject,
    1:                                              PL_DHASH_ADD));
    1:         if (!entry) {
    1:             aObject->Release();
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1: 
    1:         if (!entry->mObject) {
    1:             // First time we've seen this object address: add it to mObjectMap
    1:             // and serialize the object at the current stream offset.
    1:             PRInt64 thisOffset;
    1:             rv = Tell(&thisOffset);
    1:             if (NS_FAILED(rv)) {
    1:                 aObject->Release();
    1:                 return rv;
    1:             }
    1: 
    1:             // NB: aObject was already held, and mObject is a raw nsISupports*.
    1:             entry->mObject = aObject;
    1: 
    1:             oid = (mObjectMap.entryCount << MFL_OBJECT_TAG_BITS);
    1:             entry->mOID = oid;
    1: 
    1:             // NB: the (32-bit, fast) CID and object data follow the OID.
    1:             entry->mInfo.mCIDOffset = thisOffset + sizeof(oid);
    1:             entry->mInfo.mStrongRefCnt = aIsStrongRef ? 1 : 0;
    1:             entry->mInfo.mWeakRefCnt   = aIsStrongRef ? 0 : 1;
    1: 
    1:             // Record in oid the fact that we're defining this object in the
    1:             // stream, and get the object's class info here, so we can take
    1:             // note of singletons in order to avoid reserializing them when
    1:             // updating after reading.
    1:             oid |= MFL_OBJECT_DEF_TAG;
    1:             classInfo = do_QueryInterface(aObject);
    1:             if (!classInfo) {
    1:                 NS_NOTREACHED("aObject must implement nsIClassInfo");
    1:                 return NS_ERROR_FAILURE;
    1:             }
    1: 
    1:             PRUint32 flags;
    1:             if (NS_SUCCEEDED(classInfo->GetFlags(&flags)) &&
    1:                 (flags & nsIClassInfo::SINGLETON)) {
    1:                 MFL_SET_SINGLETON_FLAG(&entry->mInfo);
    1:             }
    1:         } else {
    1:             // Already serialized, recover oid and update the desired refcnt.
    1:             oid = entry->mOID;
    1:             if (aIsStrongRef) {
    1:                 ++entry->mInfo.mStrongRefCnt;
    1:                 NS_ASSERTION(entry->mInfo.mStrongRefCnt != 0,
    1:                              "mStrongRefCnt overflow");
    1:             } else {
    1:                 MFL_BUMP_WEAK_REFCNT(&entry->mInfo);
    1:                 NS_ASSERTION(MFL_GET_WEAK_REFCNT(&entry->mInfo) != 0,
    1:                              "mWeakRefCnt overflow");
    1:             }
    1: 
    1:             aObject->Release();
    1:         }
    1:     }
    1: 
    1:     if (!aIsStrongRef)
    1:         oid |= MFL_WEAK_REF_TAG;
    1:     oid |= (aTags & MFL_QUERY_INTERFACE_TAG);
    1: 
    1:     rv = Write32(oid ^ MFL_OID_XOR_KEY);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (oid & MFL_OBJECT_DEF_TAG) {
    1:         nsCOMPtr<nsISerializable> serializable(do_QueryInterface(aObject));
    1:         if (!serializable) {
    1:             NS_NOTREACHED("aObject must implement nsISerializable");
    1:             return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         nsCID slowCID;
    1:         rv = classInfo->GetClassIDNoAlloc(&slowCID);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         NSFastLoadID fastCID;
    1:         rv = MapID(slowCID, &fastCID);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         rv = WriteFastID(fastCID);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         rv = serializable->Write(this);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::WriteObject(nsISupports* aObject, PRBool aIsStrongRef)
    1: {
    1: #ifdef NS_DEBUG
    1:     nsCOMPtr<nsISupports> rootObject(do_QueryInterface(aObject));
    1: 
    1:     NS_ASSERTION(rootObject.get() == aObject,
    1:                  "bad call to WriteObject -- call WriteCompoundObject!");
    1: #endif
    1: 
    1:     return WriteObjectCommon(aObject, aIsStrongRef, 0);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::WriteSingleRefObject(nsISupports* aObject)
    1: {
    1: #ifdef NS_DEBUG
    1:     nsCOMPtr<nsISupports> rootObject(do_QueryInterface(aObject));
    1: 
    1:     NS_ASSERTION(rootObject.get() == aObject,
    1:                  "bad call to WriteSingleRefObject -- call WriteCompoundObject!");
    1: #endif
    1: 
    1:     return WriteObjectCommon(aObject, PR_TRUE, MFL_SINGLE_REF_PSEUDO_TAG);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::WriteCompoundObject(nsISupports* aObject,
    1:                                           const nsIID& aIID,
    1:                                           PRBool aIsStrongRef)
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsISupports> rootObject(do_QueryInterface(aObject));
    1: 
    1:     // We could assert that |rootObject != aObject|, but that would prevent
    1:     // callers who don't know whether they're dealing with the primary
    1:     // nsISupports pointer (e.g., they don't know which implementation of
    1:     // nsIURI they have) from using this function.
    1: 
    1: #ifdef NS_DEBUG
    1:     nsCOMPtr<nsISupports> roundtrip;
    1:     rootObject->QueryInterface(aIID, getter_AddRefs(roundtrip));
    1:     NS_ASSERTION(roundtrip.get() == aObject,
    1:                  "bad aggregation or multiple inheritance detected by call to "
    1:                  "WriteCompoundObject!");
    1: #endif
    1: 
    1:     rv = WriteObjectCommon(rootObject, aIsStrongRef, MFL_QUERY_INTERFACE_TAG);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     NSFastLoadID iid;
    1:     rv = MapID(aIID, &iid);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return WriteFastID(iid);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::WriteID(const nsID& aID)
    1: {
    1:     nsresult rv;
    1:     NSFastLoadID fastID;
    1: 
    1:     rv = MapID(aID, &fastID);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return WriteFastID(fastID);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::Seek(PRInt32 aWhence, PRInt64 aOffset)
    1: {
    1:     mCurrentDocumentMapEntry = nsnull;
    1:     return mSeekableOutput->Seek(aWhence, aOffset);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::Tell(PRInt64 *aResult)
    1: {
    1:     return mSeekableOutput->Tell(aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::SetEOF()
    1: {
    1:     return mSeekableOutput->SetEOF();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileWriter::SetOutputStream(nsIOutputStream *aStream)
    1: {
    1:     nsresult rv = nsBinaryOutputStream::SetOutputStream(aStream);
    1:     mSeekableOutput = do_QueryInterface(mOutputStream);
    1:     return rv;
    1: }
    1: 
    1: NS_COM nsresult
    1: NS_NewFastLoadFileWriter(nsIObjectOutputStream* *aResult,
    1:                          nsIOutputStream* aDestStream,
    1:                          nsIFastLoadFileIO* aFileIO)
    1: {
    1:     nsFastLoadFileWriter* writer =
    1:         new nsFastLoadFileWriter(aDestStream, aFileIO);
    1:     if (!writer)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // Stabilize writer's refcnt.
    1:     nsCOMPtr<nsIObjectOutputStream> stream(writer);
    1: 
    1:     nsresult rv = writer->Open();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *aResult = stream;
    1:     NS_ADDREF(*aResult);
    1:     return NS_OK;
    1: }
    1: 
    1: // -------------------------- nsFastLoadFileUpdater --------------------------
    1: 
33672: NS_IMPL_ISUPPORTS_INHERITED0(nsFastLoadFileUpdater,
33672:                              nsFastLoadFileWriter)
    1: 
20261: PLDHashOperator
    1: nsFastLoadFileUpdater::CopyReadDocumentMapEntryToUpdater(PLDHashTable *aTable,
    1:                                                          PLDHashEntryHdr *aHdr,
    1:                                                          PRUint32 aNumber,
    1:                                                          void *aData)
    1: {
    1:     nsDocumentMapReadEntry* readEntry =
 3233:         static_cast<nsDocumentMapReadEntry*>(aHdr);
    1:     nsFastLoadFileUpdater* updater =
 3233:         reinterpret_cast<nsFastLoadFileUpdater*>(aData);
    1: 
    1:     void* spec = nsMemory::Clone(readEntry->mString,
    1:                                  strlen(readEntry->mString) + 1);
    1:     if (!spec)
    1:         return PL_DHASH_STOP;
    1: 
    1:     nsDocumentMapWriteEntry* writeEntry =
 3233:         static_cast<nsDocumentMapWriteEntry*>
 3233:                    (PL_DHashTableOperate(&updater->mDocumentMap, spec,
    1:                                          PL_DHASH_ADD));
    1:     if (!writeEntry) {
    1:         nsMemory::Free(spec);
    1:         return PL_DHASH_STOP;
    1:     }
    1: 
 3233:     writeEntry->mString = reinterpret_cast<const char*>(spec);
    1:     writeEntry->mURI = nsnull;
    1:     writeEntry->mInitialSegmentOffset = readEntry->mInitialSegmentOffset;
    1:     writeEntry->mCurrentSegmentOffset = 0;
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
    1: nsresult
    1: nsFastLoadFileUpdater::Open(nsFastLoadFileReader* aReader)
    1: {
    1:     nsresult rv;
    1:     rv = nsFastLoadFileWriter::Init();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRUint32 i, n;
    1: 
    1:     // Map from dense, zero-based, uint32 NSFastLoadID in reader to 16-byte
    1:     // nsID in updater.
    1:     nsID* readIDMap = aReader->mFooter.mIDMap;
    1:     for (i = 0, n = aReader->mFooter.mNumIDs; i < n; i++) {
    1:         NSFastLoadID fastID;
    1:         rv = MapID(readIDMap[i], &fastID);
    1:         NS_ASSERTION(fastID == i + 1, "huh?");
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     // Map from reader dense, zero-based MFL_OID_TO_SHARP_INDEX(oid) to sharp
    1:     // object offset and refcnt information in updater.
    1:     nsFastLoadFileReader::nsObjectMapEntry* readObjectMap =
    1:         aReader->mFooter.mObjectMap;
    1: 
    1:     // Prepare to save aReader state in case we need to seek back and read a
    1:     // singleton object that might otherwise get written by this updater.
    1:     nsDocumentMapReadEntry* saveDocMapEntry = nsnull;
    1:     PRInt64 saveOffset = 0;
    1: 
    1:     for (i = 0, n = aReader->mFooter.mNumSharpObjects; i < n; i++) {
    1:         nsFastLoadFileReader::nsObjectMapEntry* readEntry = &readObjectMap[i];
    1: 
    1:         NS_ASSERTION(readEntry->mCIDOffset != 0,
    1:                      "fastload updater: mCIDOffset cannot be zero!");
    1: 
    1:         // If the reader didn't read this object but it's a singleton, we must
    1:         // "deserialize" it now, to discover its one and only root nsISupports
    1:         // address.  The object already exists in memory if it was created at
    1:         // startup without resort to the FastLoad file.  The canonical example
    1:         // is the system principal object held by all XUL JS scripts.
    1: 
    1:         nsISupports* obj = readEntry->mReadObject;
    1:         if (!obj && MFL_GET_SINGLETON_FLAG(readEntry)) {
    1:             if (!saveDocMapEntry) {
33672:                 rv = aReader->Tell(&saveOffset);
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1: 
    1:                 saveDocMapEntry = aReader->mCurrentDocumentMapEntry;
    1:                 aReader->mCurrentDocumentMapEntry = nsnull;
    1:             }
    1: 
33672:             rv = aReader->Seek(nsISeekableStream::NS_SEEK_SET,
    1:                                      readEntry->mCIDOffset);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1: 
    1:             rv = aReader
    1:                  ->DeserializeObject(getter_AddRefs(readEntry->mReadObject));
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:             obj = readEntry->mReadObject;
    1: 
    1:             // Don't forget to set mSkipOffset in case someone calls the reader
    1:             // to "deserialize" (yet again) the object we just read.
    1:             //
    1:             // Say the singleton is the system principal, and the FastLoad file
    1:             // contains data for navigator.xul including scripts and functions.
    1:             // If we update the FastLoad file to contain data for messenger.xul
    1:             // in a separate session started via mozilla -mail, *and during the
    1:             // same FastLoad episode in this session* race to open a navigator
    1:             // window, we will attempt to read all objects serialized in the
    1:             // navigator.xul portion of the FastLoad file.
    1:             //
    1:             // mSkipOffset must be set in such a case so the reader can skip
    1:             // the system principal's serialized data, because the updater for
    1:             // messenger.xul being opened here has already read it.
    1: 
33672:             rv = aReader->Tell(&readEntry->mSkipOffset);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:         }
    1: 
    1:         NSFastLoadOID oid = MFL_SHARP_INDEX_TO_OID(i);
    1:         void* key = obj
 3233:                     ? reinterpret_cast<void*>(obj)
 3233:                     : reinterpret_cast<void*>((oid | MFL_OBJECT_DEF_TAG));
    1: 
    1:         nsSharpObjectMapEntry* writeEntry =
 3233:             static_cast<nsSharpObjectMapEntry*>
 3233:                        (PL_DHashTableOperate(&mObjectMap, key,
    1:                                              PL_DHASH_ADD));
    1:         if (!writeEntry)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         // Hold the object if there is one, so that objmap_ClearEntry can
    1:         // release the reference.
    1:         NS_IF_ADDREF(obj);
 3233:         writeEntry->mObject = reinterpret_cast<nsISupports*>(key);
    1:         writeEntry->mOID = oid;
    1:         writeEntry->mInfo.mCIDOffset = readEntry->mCIDOffset;
    1:         writeEntry->mInfo.mStrongRefCnt = readEntry->mSaveStrongRefCnt;
    1:         writeEntry->mInfo.mWeakRefCnt = readEntry->mSaveWeakRefCnt;
    1:     }
    1: 
    1:     // If we had to read any singletons, restore aReader's saved state.
    1:     if (saveDocMapEntry) {
33672:         rv = aReader->Seek(nsISeekableStream::NS_SEEK_SET, saveOffset);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         aReader->mCurrentDocumentMapEntry = saveDocMapEntry;
    1:     }
    1: 
    1:     // Copy URI spec string and initial segment offset in FastLoad file from
    1:     // nsDocumentMapReadEntry in reader to nsDocumentMapWriteEntry in updater.
    1:     // If we didn't enumerate all entries, we ran out of memory.
    1:     n = PL_DHashTableEnumerate(&aReader->mFooter.mDocumentMap,
    1:                                CopyReadDocumentMapEntryToUpdater,
    1:                                this);
    1:     if (n != aReader->mFooter.mDocumentMap.entryCount)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // Copy source filename dependencies from reader to updater.
    1:     nsISupportsArray* readDeps = aReader->mFooter.mDependencies;
    1:     rv = readDeps->Count(&n);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     for (i = 0; i < n; i++) {
    1:         nsCOMPtr<nsIFile> file;
    1:         rv = readDeps->GetElementAt(i, getter_AddRefs(file));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         rv = AddDependency(file);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     // Seek to the reader's footer offset so we overwrite the footer.  First,
    1:     // update the header to have a zero mFooterOffset, which will invalidate
    1:     // the FastLoad file on next startup read attempt, should we crash before
    1:     // completing this update.
    1:     rv = mSeekableOutput->Seek(nsISeekableStream::NS_SEEK_SET,
    1:                                offsetof(nsFastLoadHeader, mFooterOffset));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = Write32(0);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = mSeekableOutput->Seek(nsISeekableStream::NS_SEEK_SET,
    1:                                aReader->mHeader.mFooterOffset);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFastLoadFileUpdater::Close()
    1: {
    1:     // Call base-class Close implementation, which uses mFileIO.
    1:     nsresult rv = nsFastLoadFileWriter::Close();
    1: 
    1:     // Break degenerate cycle from this->mFileIO to this.
    1:     mFileIO = nsnull;
    1:     return rv;
    1: }
    1: 
    1: NS_COM nsresult
    1: NS_NewFastLoadFileUpdater(nsIObjectOutputStream* *aResult,
33672:                           nsIFastLoadFileIO *aFileIO,
    1:                           nsIObjectInputStream* aReaderAsStream)
    1: {
    1:     // Make sure that aReaderAsStream is an nsFastLoadFileReader.
    1:     nsCOMPtr<nsIFastLoadFileReader> reader(do_QueryInterface(aReaderAsStream));
    1:     if (!reader)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
33672:     nsCOMPtr<nsIOutputStream> output;
33672:     nsresult rv = aFileIO->GetOutputStream(getter_AddRefs(output));
33672:     if (NS_FAILED(rv))
33672:         return rv;
33672: 
33672:     nsFastLoadFileUpdater* updater = new nsFastLoadFileUpdater(output, aFileIO);
    1:     if (!updater)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // Stabilize updater's refcnt.
    1:     nsCOMPtr<nsIObjectOutputStream> stream(updater);
    1: 
33672:     rv = updater->Open(static_cast<nsFastLoadFileReader*>(aReaderAsStream));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *aResult = stream;
    1:     NS_ADDREF(*aResult);
    1:     return NS_OK;
    1: }
