55916: /* ***** BEGIN LICENSE BLOCK *****
55916:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
55916:  *
55916:  * The contents of this file are subject to the Mozilla Public License Version
55916:  * 1.1 (the "License"); you may not use this file except in compliance with
55916:  * the License. You may obtain a copy of the License at
55916:  * http://www.mozilla.org/MPL/
55916:  *
55916:  * Software distributed under the License is distributed on an "AS IS" basis,
55916:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
55916:  * for the specific language governing rights and limitations under the
55916:  * License.
55916:  *
55916:  * The Original Code is Mozilla Android code.
55916:  *
55916:  * The Initial Developer of the Original Code is Mozilla Foundation.
55916:  * Portions created by the Initial Developer are Copyright (C) 2010
55916:  * the Initial Developer. All Rights Reserved.
55916:  *
55916:  * Contributor(s):
55916:  *   Michael Wu <mwu@mozilla.com>
55916:  *
55916:  * Alternatively, the contents of this file may be used under the terms of
55916:  * either the GNU General Public License Version 2 or later (the "GPL"), or
55916:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
55916:  * in which case the provisions of the GPL or the LGPL are applicable instead
55916:  * of those above. If you wish to allow use of your version of this file only
55916:  * under the terms of either the GPL or the LGPL, and not to allow others to
55916:  * use your version of this file under the terms of the MPL, indicate your
55916:  * decision by deleting the provisions above and replace them with the notice
55916:  * and other provisions required by the GPL or the LGPL. If you do not delete
55916:  * the provisions above, a recipient may use your version of this file under
55916:  * the terms of any one of the MPL, the GPL or the LGPL.
55916:  *
55916:  * ***** END LICENSE BLOCK ***** */
55916: 
56694: /*
56694:  * This custom library loading code is only meant to be called
56694:  * during initialization. As a result, it takes no special 
56694:  * precautions to be threadsafe. Any of the library loading functions
56694:  * like mozload should not be available to other code.
56694:  */
56694: 
55916: #include <jni.h>
55916: #include <android/log.h>
55916: #include <sys/time.h>
55916: #include <sys/types.h>
55916: #include <sys/stat.h>
55916: #include <sys/mman.h>
56694: #include <sys/limits.h>
55916: #include <errno.h>
55916: #include <string.h>
55916: #include <stdio.h>
56694: #include <stdlib.h>
55916: #include <fcntl.h>
55916: #include <endian.h>
55916: #include <unistd.h>
55916: #include <zlib.h>
56694: #include <linux/ashmem.h>
55916: #include "dlfcn.h"
56285: #include "APKOpen.h"
60403: #include <sys/time.h>
60403: #include <sys/resource.h>
55916: 
55916: /* compression methods */
55916: #define STORE    0
55916: #define DEFLATE  8
55916: #define LZMA    14
55916: 
55916: struct local_file_header {
55916:   uint32_t signature;
55916:   uint16_t min_version;
55916:   uint16_t general_flag;
55916:   uint16_t compression;
55916:   uint16_t lastmod_time;
55916:   uint16_t lastmod_date;
55916:   uint32_t crc32;
55916:   uint32_t compressed_size;
55916:   uint32_t uncompressed_size;
55916:   uint16_t filename_size;
55916:   uint16_t extra_field_size;
55916:   char     data[0];
55916: } __attribute__((__packed__));
55916: 
55916: struct cdir_entry {
55916:   uint32_t signature;
55916:   uint16_t creator_version;
55916:   uint16_t min_version;
55916:   uint16_t general_flag;
55916:   uint16_t compression;
55916:   uint16_t lastmod_time;
55916:   uint16_t lastmod_date;
55916:   uint32_t crc32;
55916:   uint32_t compressed_size;
55916:   uint32_t uncompressed_size;
55916:   uint16_t filename_size;
55916:   uint16_t extra_field_size;
55916:   uint16_t file_comment_size;
55916:   uint16_t disk_num;
55916:   uint16_t internal_attr;
55916:   uint32_t external_attr;
55916:   uint32_t offset;
55916:   char     data[0];
55916: } __attribute__((__packed__));
55916: 
55916: #define CDIR_END_SIG 0x06054b50
55916: 
55916: struct cdir_end {
55916:   uint32_t signature;
55916:   uint16_t disk_num;
55916:   uint16_t cdir_disk;
55916:   uint16_t disk_entries;
55916:   uint16_t cdir_entries;
55916:   uint32_t cdir_size;
55916:   uint32_t cdir_offset;
55916:   uint16_t comment_size;
55916:   char     comment[0];
55916: } __attribute__((__packed__));
55916: 
55916: static size_t zip_size;
55916: static int zip_fd;
70898: static struct mapping_info * lib_mapping = NULL;
56694: 
56694: NS_EXPORT const struct mapping_info *
56694: getLibraryMapping()
56694: {
56694:   return lib_mapping;
56694: }
56694: 
56694: static int
60403: createAshmem(size_t bytes, const char *name)
56694: {
56694:   int fd = open("/" ASHMEM_NAME_DEF, O_RDWR, 0600);
56694:   if (fd < 0)
56694:     return -1;
56694: 
60403:   char buf[ASHMEM_NAME_LEN];
60403: 
60403:   strlcpy(buf, name, sizeof(buf));
60403:   /*ret = */ioctl(fd, ASHMEM_SET_NAME, buf);
60403: 
56694:   if (!ioctl(fd, ASHMEM_SET_SIZE, bytes))
56694:     return fd;
56694: 
56694:   close(fd);
56694:   return -1;
56694: }
55916: 
55916: static void * map_file (const char *file)
55916: {
55916:   int fd = open(file, O_RDONLY);
55916:   if (fd == -1) {
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoMapFile", "map_file open %s", strerror(errno));
55916:     return NULL;
55916:   }
55916: 
55916:   zip_fd = fd;
55916:   struct stat s;
55916:   if (fstat(fd, &s) == -1) {
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoMapFile", "map_file fstat %s", strerror(errno));
55916:     return NULL;
55916:   }
55916: 
55916:   zip_size = s.st_size;
55916:   void *addr = mmap(NULL, zip_size, PROT_READ, MAP_SHARED, fd, 0);
55916:   if (addr == MAP_FAILED) {
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoMapFile", "map_file mmap %s", strerror(errno));
55916:     return NULL;
55916:   }
55916: 
55916:   return addr;
55916: }
55916: 
55916: static uint32_t cdir_entry_size (struct cdir_entry *entry)
55916: {
55916:   return sizeof(*entry) +
55916:          letoh16(entry->filename_size) +
55916:          letoh16(entry->extra_field_size) +
55916:          letoh16(entry->file_comment_size);
55916: }
55916: 
55916: static struct cdir_entry *
55916: find_cdir_entry (struct cdir_entry *entry, int count, const char *name)
55916: {
55916:   size_t name_size = strlen(name);
55916:   while (count--) {
55916:     if (letoh16(entry->filename_size) == name_size &&
55916:         !memcmp(entry->data, name, name_size))
55916:       return entry;
77557:     entry = (struct cdir_entry *)((char *)entry + cdir_entry_size(entry));
55916:   }
55916:   return NULL;
55916: }
55916: 
55916: #define SHELL_WRAPPER0(name) \
55916: typedef void (*name ## _t)(JNIEnv *, jclass); \
55916: static name ## _t f_ ## name; \
55916: extern "C" NS_EXPORT void JNICALL \
55916: Java_org_mozilla_gecko_GeckoAppShell_ ## name(JNIEnv *jenv, jclass jc) \
55916: { \
55916:   f_ ## name(jenv, jc); \
55916: }
55916: 
55916: #define SHELL_WRAPPER1(name,type1) \
55916: typedef void (*name ## _t)(JNIEnv *, jclass, type1 one); \
55916: static name ## _t f_ ## name; \
55916: extern "C" NS_EXPORT void JNICALL \
55916: Java_org_mozilla_gecko_GeckoAppShell_ ## name(JNIEnv *jenv, jclass jc, type1 one) \
55916: { \
55916:   f_ ## name(jenv, jc, one); \
55916: }
55916: 
55916: #define SHELL_WRAPPER2(name,type1,type2) \
55916: typedef void (*name ## _t)(JNIEnv *, jclass, type1 one, type2 two); \
55916: static name ## _t f_ ## name; \
55916: extern "C" NS_EXPORT void JNICALL \
55916: Java_org_mozilla_gecko_GeckoAppShell_ ## name(JNIEnv *jenv, jclass jc, type1 one, type2 two) \
55916: { \
55916:   f_ ## name(jenv, jc, one, two); \
55916: }
55916: 
55916: #define SHELL_WRAPPER3(name,type1,type2,type3) \
55916: typedef void (*name ## _t)(JNIEnv *, jclass, type1 one, type2 two, type3 three); \
55916: static name ## _t f_ ## name; \
55916: extern "C" NS_EXPORT void JNICALL \
55916: Java_org_mozilla_gecko_GeckoAppShell_ ## name(JNIEnv *jenv, jclass jc, type1 one, type2 two, type3 three) \
55916: { \
55916:   f_ ## name(jenv, jc, one, two, three); \
55916: }
55916: 
55916: SHELL_WRAPPER0(nativeInit)
55916: SHELL_WRAPPER1(nativeRun, jstring)
55916: SHELL_WRAPPER1(notifyGeckoOfEvent, jobject)
76837: SHELL_WRAPPER0(processNextNativeEvent)
55916: SHELL_WRAPPER1(setSurfaceView, jobject)
55916: SHELL_WRAPPER0(onResume)
55916: SHELL_WRAPPER0(onLowMemory)
55916: SHELL_WRAPPER3(callObserver, jstring, jstring, jstring)
55916: SHELL_WRAPPER1(removeObserver, jstring)
79687: SHELL_WRAPPER1(onChangeNetworkLinkStatus, jstring)
71129: SHELL_WRAPPER1(reportJavaCrash, jstring)
78424: SHELL_WRAPPER0(executeNextRunnable)
78958: SHELL_WRAPPER1(cameraCallbackBridge, jbyteArray)
55916: 
55916: static void * xul_handle = NULL;
55916: static time_t apk_mtime = 0;
55916: #ifdef DEBUG
55916: extern "C" int extractLibs = 1;
55916: #else
55916: extern "C" int extractLibs = 0;
55916: #endif
55916: 
55916: static void
55916: extractFile(const char * path, const struct cdir_entry *entry, void * data)
55916: {
55916:   uint32_t size = letoh32(entry->uncompressed_size);
55916: 
55916:   struct stat status;
55916:   if (!stat(path, &status) &&
55916:       status.st_size == size &&
55916:       apk_mtime < status.st_mtime)
55916:     return;
55916: 
55916:   int fd = open(path, O_CREAT | O_NOATIME | O_TRUNC | O_RDWR, S_IRWXU);
55916:   if (fd == -1) {
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Couldn't open %s to decompress library", path);
55916:     return;
55916:   }
55916: 
77947:   if (ftruncate(fd, size) == -1) {
77947:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Couldn't ftruncate %s to decompress library", path);
77947:     close(fd);
77947:     return;
77947:   }
77947: 
77947:   void * buf = mmap(NULL, size, PROT_READ | PROT_WRITE,
77947:                     MAP_SHARED, fd, 0);
55916:   if (buf == (void *)-1) {
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Couldn't mmap decompression buffer");
77642:     close(fd);
55916:     return;
55916:   }
55916: 
55916:   z_stream strm = {
55916:     next_in: (Bytef *)data,
55916:     avail_in: letoh32(entry->compressed_size),
55916:     total_in: 0,
55916: 
55916:     next_out: (Bytef *)buf,
77947:     avail_out: size,
55916:     total_out: 0
55916:   };
55916: 
55916:   int ret;
55916:   ret = inflateInit2(&strm, -MAX_WBITS);
55916:   if (ret != Z_OK)
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "inflateInit failed: %s", strm.msg);
55916: 
77947:   if (inflate(&strm, Z_FINISH) != Z_STREAM_END)
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "inflate failed: %s", strm.msg);
55916: 
55916:   if (strm.total_out != size)
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "extracted %d, expected %d!", strm.total_out, size);
55916: 
55916:   ret = inflateEnd(&strm);
55916:   if (ret != Z_OK)
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "inflateEnd failed: %s", strm.msg);
55916: 
55916:   close(fd);
79558: #ifdef ANDROID_ARM_LINKER
79558:   /* We just extracted data that is going to be executed in the future.
79558:    * We thus need to ensure Instruction and Data cache coherency. */
79558:   cacheflush((unsigned) buf, (unsigned) buf + size, 0);
79558: #endif
77947:   munmap(buf, size);
55916: }
55916: 
55916: static void
55916: extractLib(const struct cdir_entry *entry, void * data, void * dest)
55916: {
55916:   z_stream strm = {
55916:     next_in: (Bytef *)data,
55916:     avail_in: letoh32(entry->compressed_size),
55916:     total_in: 0,
55916: 
55916:     next_out: (Bytef *)dest,
55916:     avail_out: letoh32(entry->uncompressed_size),
55916:     total_out: 0
55916:   };
55916: 
55916:   int ret;
55916:   ret = inflateInit2(&strm, -MAX_WBITS);
55916:   if (ret != Z_OK)
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "inflateInit failed: %s", strm.msg);
55916: 
55916:   ret = inflate(&strm, Z_SYNC_FLUSH);
55916:   if (ret != Z_STREAM_END)
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "inflate failed: %s", strm.msg);
55916: 
55916:   ret = inflateEnd(&strm);
55916:   if (ret != Z_OK)
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "inflateEnd failed: %s", strm.msg);
55916: 
55916:   if (strm.total_out != letoh32(entry->uncompressed_size))
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "File not fully uncompressed! %d / %d", strm.total_out, letoh32(entry->uncompressed_size));
55916: }
55916: 
56694: static int cache_count = 0;
56694: static struct lib_cache_info *cache_mapping = NULL;
56694: 
56694: NS_EXPORT const struct lib_cache_info *
56694: getLibraryCache()
56694: {
56694:   return cache_mapping;
56694: }
56694: 
56694: static void
56694: ensureLibCache()
56694: {
56694:   if (!cache_mapping)
56694:     cache_mapping = (struct lib_cache_info *)calloc(MAX_LIB_CACHE_ENTRIES,
56694:                                                     sizeof(*cache_mapping));
56694: }
56694: 
56694: static void
56694: fillLibCache(const char *buf)
56694: {
56694:   ensureLibCache();
56694: 
56694:   char * str = strdup(buf);
56694:   if (!str)
56694:     return;
56694: 
56694:   char * saveptr;
56694:   char * nextstr = str;
56694:   do {
56694:     struct lib_cache_info *info = &cache_mapping[cache_count];
56694: 
56694:     char * name = strtok_r(nextstr, ":", &saveptr);
56694:     if (!name)
56694:       break;
56694:     nextstr = NULL;
56694: 
56694:     char * fd_str = strtok_r(NULL, ";", &saveptr);
56694:     if (!fd_str)
56694:       break;
56694: 
56694:     long int fd = strtol(fd_str, NULL, 10);
56694:     if (fd == LONG_MIN || fd == LONG_MAX)
56694:       break;
56694:     strncpy(info->name, name, MAX_LIB_CACHE_NAME_LEN - 1);
56694:     info->fd = fd;
56694:   } while (cache_count++ < MAX_LIB_CACHE_ENTRIES);
56694:   free(str);
56694: }
56694: 
56694: static int
56694: lookupLibCacheFd(const char *libName)
56694: {
56694:   if (!cache_mapping)
56694:     return -1;
56694: 
56694:   int count = cache_count;
56694:   while (count--) {
56694:     struct lib_cache_info *info = &cache_mapping[count];
56694:     if (!strcmp(libName, info->name))
56694:       return info->fd;
56694:   }
56694:   return -1;
56694: }
56694: 
56694: static void
60884: addLibCacheFd(const char *libName, int fd, uint32_t lib_size = 0, void* buffer = NULL)
56694: {
56694:   ensureLibCache();
56694: 
56694:   struct lib_cache_info *info = &cache_mapping[cache_count++];
56694:   strncpy(info->name, libName, MAX_LIB_CACHE_NAME_LEN - 1);
56694:   info->fd = fd;
60884:   info->lib_size = lib_size;
60884:   info->buffer = buffer;
56694: }
56694: 
55916: static void * mozload(const char * path, void *zip,
55916:                       struct cdir_entry *cdir_start, uint16_t cdir_entries)
55916: {
55916: #ifdef DEBUG
55916:   struct timeval t0, t1;
55916:   gettimeofday(&t0, 0);
55916: #endif
55916: 
55916:   struct cdir_entry *entry = find_cdir_entry(cdir_start, cdir_entries, path);
77557:   struct local_file_header *file = (struct local_file_header *)((char *)zip + letoh32(entry->offset));
77557:   void * data = ((char *)&file->data) + letoh16(file->filename_size) + letoh16(file->extra_field_size);
55916:   void * handle;
55916: 
55916:   if (extractLibs) {
63327:     char fullpath[PATH_MAX];
78580:     snprintf(fullpath, PATH_MAX, "%s/%s", getenv("CACHE_PATH"), path);
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "resolved %s to %s", path, fullpath);
55916:     extractFile(fullpath, entry, data);
55916:     handle = __wrap_dlopen(fullpath, RTLD_LAZY);
55916:     if (!handle)
55916:       __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Couldn't load %s because %s", fullpath, __wrap_dlerror());
55916: #ifdef DEBUG
55916:     gettimeofday(&t1, 0);
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "%s: spent %d", path,
55916:                         (((long long)t1.tv_sec * 1000000LL) +
55916:                           (long long)t1.tv_usec) -
55916:                         (((long long)t0.tv_sec * 1000000LL) +
55916:                           (long long)t0.tv_usec));
55916: #endif
55916:     return handle;
55916:   }
73637: 
55916:   size_t offset = letoh32(entry->offset) + sizeof(*file) + letoh16(file->filename_size) + letoh16(file->extra_field_size);
63327:   bool skipLibCache = false;
55916:   int fd = zip_fd;
55916:   void * buf = NULL;
56694:   uint32_t lib_size = letoh32(entry->uncompressed_size);
60884:   int cache_fd = 0;
55916:   if (letoh16(file->compression) == DEFLATE) {
78580:     cache_fd = lookupLibCacheFd(path);
56694:     fd = cache_fd;
56694:     if (fd < 0)
60403:       fd = createAshmem(lib_size, path);
56694: #ifdef DEBUG
56694:     else
78580:       __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Loading %s from cache", path);
56694: #endif
56694:     if (fd < 0) {
79952:       __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Couldn't open " ASHMEM_NAME_DEF ", Error %d, %s, bailing out", errno, strerror(errno));
56694:       return NULL;
56694:     }
56694:     buf = mmap(NULL, lib_size,
56694:                PROT_READ | PROT_WRITE,
56694:                MAP_SHARED, fd, 0);
55916:     if (buf == (void *)-1) {
55916:       __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Couldn't mmap decompression buffer");
56694:       close(fd);
55916:       return NULL;
55916:     }
55916: 
55916:     offset = 0;
55916: 
56694:     if (cache_fd < 0) {
55916:       extractLib(entry, data, buf);
78727: #ifdef ANDROID_ARM_LINKER
78727:       /* We just extracted data that is going to be executed in the future.
78727:        * We thus need to ensure Instruction and Data cache coherency. */
78727:       cacheflush((unsigned) buf, (unsigned) buf + entry->uncompressed_size, 0);
78727: #endif
78580:       addLibCacheFd(path, fd, lib_size, buf);
56694:     }
63327: 
60884:     // preload libxul, to avoid slowly demand-paging it
78580:     if (!strcmp(path, "libxul.so"))
60884:       madvise(buf, entry->uncompressed_size, MADV_WILLNEED);
55916:     data = buf;
55916:   }
55916: 
55916: #ifdef DEBUG
56694:   __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Loading %s with len %d (0x%08x) and offset %d (0x%08x)", path, lib_size, lib_size, offset, offset);
55916: #endif
55916: 
55916:   handle = moz_mapped_dlopen(path, RTLD_LAZY, fd, data,
56694:                              lib_size, offset);
55916:   if (!handle)
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Couldn't load %s because %s", path, __wrap_dlerror());
60884: 
79952:   if (buf)
56694:     munmap(buf, lib_size);
55916: 
55916: #ifdef DEBUG
55916:   gettimeofday(&t1, 0);
55916:   __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "%s: spent %d", path, (((long long)t1.tv_sec * 1000000LL) + (long long)t1.tv_usec) -
55916:                (((long long)t0.tv_sec * 1000000LL) + (long long)t0.tv_usec));
55916: #endif
55916: 
55916:   return handle;
55916: }
55916: 
56285: static void *
56285: extractBuf(const char * path, void *zip,
56285:            struct cdir_entry *cdir_start, uint16_t cdir_entries)
56285: {
56285:   struct cdir_entry *entry = find_cdir_entry(cdir_start, cdir_entries, path);
77557:   struct local_file_header *file = (struct local_file_header *)((char *)zip + letoh32(entry->offset));
77557:   void * data = ((char *)&file->data) + letoh16(file->filename_size) + letoh16(file->extra_field_size);
56285: 
56285:   void * buf = malloc(letoh32(entry->uncompressed_size));
56285:   if (buf == (void *)-1) {
56285:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Couldn't alloc decompression buffer for %s", path);
56285:     return NULL;
56285:   }
56285:   if (letoh16(file->compression) == DEFLATE)
56285:     extractLib(entry, data, buf);
56285:   else
56285:     memcpy(buf, data, letoh32(entry->uncompressed_size));
56285: 
56285:   return buf;
56285: }
56285: 
56285: static int mapping_count = 0;
56285: static char *file_ids = NULL;
56285: 
56285: #define MAX_MAPPING_INFO 32
56285: 
56285: extern "C" void
56285: report_mapping(char *name, void *base, uint32_t len, uint32_t offset)
56285: {
56285:   if (!file_ids || mapping_count >= MAX_MAPPING_INFO)
56285:     return;
56285: 
56285:   struct mapping_info *info = &lib_mapping[mapping_count++];
56285:   info->name = strdup(name);
56285:   info->base = (uintptr_t)base;
56285:   info->len = len;
56285:   info->offset = offset;
56285: 
56285:   char * entry = strstr(file_ids, name);
56285:   if (entry)
56285:     info->file_id = strndup(entry + strlen(name) + 1, 32);
56285: }
56285: 
55916: extern "C" void simple_linker_init(void);
55916: 
83485: extern "C" struct timeval timings[2];
83485: #define TIMING_RELOC 0
83485: #define TIMING_CONSTRUCTORS 1
83485: 
55916: static void
55916: loadLibs(const char *apkName)
55916: {
62123:   chdir(getenv("GRE_HOME"));
56285: 
55916:   simple_linker_init();
55916: 
55916:   struct stat status;
55916:   if (!stat(apkName, &status))
55916:     apk_mtime = status.st_mtime;
55916: 
55916:   struct timeval t0, t1;
55916:   gettimeofday(&t0, 0);
60403:   struct rusage usage1;
60403:   getrusage(RUSAGE_SELF, &usage1);
55916: 
55916:   void *zip = map_file(apkName);
77557:   struct cdir_end *dirend = (struct cdir_end *)((char *)zip + zip_size - sizeof(*dirend));
55916:   while ((void *)dirend > zip &&
55916:          letoh32(dirend->signature) != CDIR_END_SIG)
77557:     dirend = (struct cdir_end *)((char *)dirend - 1);
55916:   if (letoh32(dirend->signature) != CDIR_END_SIG) {
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Couldn't find end of central directory record");
55916:     return;
55916:   }
55916: 
55916:   uint32_t cdir_offset = letoh32(dirend->cdir_offset);
55916:   uint16_t cdir_entries = letoh16(dirend->cdir_entries);
55916: 
77557:   struct cdir_entry *cdir_start = (struct cdir_entry *)((char *)zip + cdir_offset);
55916: 
70898:   lib_mapping = (struct mapping_info *)calloc(MAX_MAPPING_INFO, sizeof(*lib_mapping));
70897: #ifdef MOZ_CRASHREPORTER
56285:   file_ids = (char *)extractBuf("lib.id", zip, cdir_start, cdir_entries);
56285: #endif
56285: 
78580: #define MOZLOAD(name) mozload("lib" name ".so", zip, cdir_start, cdir_entries)
55916:   MOZLOAD("mozalloc");
55916:   MOZLOAD("nspr4");
55916:   MOZLOAD("plc4");
55916:   MOZLOAD("plds4");
55916:   MOZLOAD("mozsqlite3");
55916:   MOZLOAD("nssutil3");
55916:   MOZLOAD("nss3");
55916:   MOZLOAD("ssl3");
55916:   MOZLOAD("smime3");
55916:   xul_handle = MOZLOAD("xul");
55916:   MOZLOAD("xpcom");
55916:   MOZLOAD("nssckbi");
55916:   MOZLOAD("freebl3");
55916:   MOZLOAD("softokn3");
55916: #undef MOZLOAD
55916: 
55916:   close(zip_fd);
55916: 
56285: #ifdef MOZ_CRASHREPORTER
56285:   free(file_ids);
56285:   file_ids = NULL;
56285: #endif
56285: 
55916:   if (!xul_handle)
55916:     __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Couldn't get a handle to libxul!");
55916: 
55916: #define GETFUNC(name) f_ ## name = (name ## _t) __wrap_dlsym(xul_handle, "Java_org_mozilla_gecko_GeckoAppShell_" #name)
55916:   GETFUNC(nativeInit);
55916:   GETFUNC(nativeRun);
55916:   GETFUNC(notifyGeckoOfEvent);
76837:   GETFUNC(processNextNativeEvent);
55916:   GETFUNC(setSurfaceView);
55916:   GETFUNC(onResume);
55916:   GETFUNC(onLowMemory);
55916:   GETFUNC(callObserver);
55916:   GETFUNC(removeObserver);
60931:   GETFUNC(onChangeNetworkLinkStatus);
71129:   GETFUNC(reportJavaCrash);
78424:   GETFUNC(executeNextRunnable);
78958:   GETFUNC(cameraCallbackBridge);
55916: #undef GETFUNC
55916:   gettimeofday(&t1, 0);
60403:   struct rusage usage2;
60403:   getrusage(RUSAGE_SELF, &usage2);
72133:   __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Loaded libs in %dms total, %dms user, %dms system, %d faults",
60403:                       (t1.tv_sec - t0.tv_sec)*1000 + (t1.tv_usec - t0.tv_usec)/1000, 
72133:                       (usage2.ru_utime.tv_sec - usage1.ru_utime.tv_sec)*1000 + (usage2.ru_utime.tv_usec - usage1.ru_utime.tv_usec)/1000,
72133:                       (usage2.ru_stime.tv_sec - usage1.ru_stime.tv_sec)*1000 + (usage2.ru_stime.tv_usec - usage1.ru_stime.tv_usec)/1000,
60403:                       usage2.ru_majflt-usage1.ru_majflt);
83485:   __android_log_print(ANDROID_LOG_ERROR, "GeckoLibLoad", "Spent %dms on relocations, %dms on constructors",
83485:                       timings[TIMING_RELOC].tv_sec * 1000 + timings[TIMING_RELOC].tv_usec / 1000,
83485:                       timings[TIMING_CONSTRUCTORS].tv_sec * 1000 + timings[TIMING_CONSTRUCTORS].tv_usec / 1000);
55916: }
55916: 
55916: extern "C" NS_EXPORT void JNICALL
60061: Java_org_mozilla_gecko_GeckoAppShell_loadLibs(JNIEnv *jenv, jclass jGeckoAppShellClass, jstring jApkName, jboolean jShouldExtract)
55916: {
60061:   if (jShouldExtract)
60061:     extractLibs = 1;
60096: 
55916:   const char* str;
55916:   // XXX: java doesn't give us true UTF8, we should figure out something 
55916:   // better to do here
55916:   str = jenv->GetStringUTFChars(jApkName, NULL);
55916:   if (str == NULL)
55916:     return;
55916: 
55916:   loadLibs(str);
55916:   jenv->ReleaseStringUTFChars(jApkName, str);
55916: }
55916: 
55916: typedef int GeckoProcessType;
55916: typedef int nsresult;
55916: 
55916: extern "C" NS_EXPORT int
55916: ChildProcessInit(int argc, char* argv[])
55916: {
55916:   int i;
55916:   for (i = 0; i < (argc - 1); i++) {
70010:     if (strcmp(argv[i], "-greomni"))
55916:       continue;
55916: 
55916:     i = i + 1;
55916:     break;
55916:   }
55916: 
56694:   fillLibCache(argv[argc - 1]);
55916:   loadLibs(argv[i]);
55916: 
56694:   // don't pass the last arg - it's only recognized by the lib cache
56694:   argc--;
56694: 
55916:   typedef GeckoProcessType (*XRE_StringToChildProcessType_t)(char*);
55916:   typedef nsresult (*XRE_InitChildProcess_t)(int, char**, GeckoProcessType);
55916:   XRE_StringToChildProcessType_t fXRE_StringToChildProcessType =
55916:     (XRE_StringToChildProcessType_t)__wrap_dlsym(xul_handle, "XRE_StringToChildProcessType");
55916:   XRE_InitChildProcess_t fXRE_InitChildProcess =
55916:     (XRE_InitChildProcess_t)__wrap_dlsym(xul_handle, "XRE_InitChildProcess");
55916: 
55916:   GeckoProcessType proctype = fXRE_StringToChildProcessType(argv[--argc]);
55916: 
55916:   nsresult rv = fXRE_InitChildProcess(argc, argv, proctype);
55916:   if (rv != 0)
55916:     return 1;
55916: 
55916:   return 0;
55916: }
55916: 
