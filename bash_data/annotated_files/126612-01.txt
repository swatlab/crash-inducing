     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
     1:  * vim: set ts=2 sw=2 et tw=78:
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
     1:  */
     1: 
     1: /*
     1:  * structures that represent things to be painted (ordered in z-order),
     1:  * used during painting and hit testing
     1:  */
     1: 
125720: // include PBrowserChild explicitly because TabChild won't include it
125720: // because we're in layout :(
125720: #include "mozilla/dom/PBrowserChild.h"
125720: #include "mozilla/dom/TabChild.h"
125720: 
107003: #include "mozilla/layers/PLayers.h"
107003: 
     1: #include "nsDisplayList.h"
     1: 
     1: #include "nsCSSRendering.h"
 68487: #include "nsRenderingContext.h"
     1: #include "nsISelectionController.h"
     1: #include "nsIPresShell.h"
     1: #include "nsRegion.h"
     1: #include "nsFrameManager.h"
     1: #include "gfxContext.h"
 15992: #include "nsStyleStructInlines.h"
 19214: #include "nsStyleTransformMatrix.h"
 19214: #include "gfxMatrix.h"
 19125: #include "nsSVGIntegrationUtils.h"
 30519: #include "nsLayoutUtils.h"
 47777: #include "nsIScrollableFrame.h"
 48165: #include "nsThemeConstants.h"
115308: #include "LayerTreeInvalidation.h"
     1: 
 27153: #include "imgIContainer.h"
 27153: #include "nsIInterfaceRequestorUtils.h"
 38803: #include "BasicLayers.h"
 58577: #include "nsBoxFrame.h"
 67670: #include "nsViewportFrame.h"
 82353: #include "nsSVGEffects.h"
105956: #include "nsSVGElement.h"
 82353: #include "nsSVGClipPathFrame.h"
 96794: #include "sampler.h"
107003: #include "nsAnimationManager.h"
107005: #include "nsTransitionManager.h"
107003: #include "nsIViewManager.h"
108747: #include "ImageLayers.h"
108747: #include "ImageContainer.h"
125848: #include "nsCanvasFrame.h"
 38803: 
 95340: #include "mozilla/StandardInteger.h"
 95340: 
 42593: using namespace mozilla;
109462: using namespace mozilla::css;
 38803: using namespace mozilla::layers;
125720: using namespace mozilla::dom;
 60443: typedef FrameMetrics::ViewID ViewID;
 27153: 
107003: static void AddTransformFunctions(nsCSSValueList* aList,
107003:                                   nsStyleContext* aContext,
107003:                                   nsPresContext* aPresContext,
107003:                                   nsRect& aBounds,
107003:                                   float aAppUnitsPerPixel,
107003:                                   InfallibleTArray<TransformFunction>& aFunctions)
107003: {
107003:   if (aList->mValue.GetUnit() == eCSSUnit_None) {
107003:     return;
107003:   }
107003: 
107003:   for (const nsCSSValueList* curr = aList; curr; curr = curr->mNext) {
107003:     const nsCSSValue& currElem = curr->mValue;
107003:     NS_ASSERTION(currElem.GetUnit() == eCSSUnit_Function,
107003:                  "Stream should consist solely of functions!");
107003:     nsCSSValue::Array* array = currElem.GetArrayValue();
107003:     bool canStoreInRuleTree = true;
107003:     switch (nsStyleTransformMatrix::TransformFunctionOf(array)) {
107003:       case eCSSKeyword_rotatex:
107003:       {
107003:         double theta = array->Item(1).GetAngleValueInRadians();
107003:         aFunctions.AppendElement(RotationX(theta));
107003:         break;
107003:       }
107003:       case eCSSKeyword_rotatey:
107003:       {
107003:         double theta = array->Item(1).GetAngleValueInRadians();
107003:         aFunctions.AppendElement(RotationY(theta));
107003:         break;
107003:       }
107003:       case eCSSKeyword_rotatez:
107003:       {
107003:         double theta = array->Item(1).GetAngleValueInRadians();
107003:         aFunctions.AppendElement(RotationZ(theta));
107003:         break;
107003:       }
107003:       case eCSSKeyword_rotate:
107003:       {
107003:         double theta = array->Item(1).GetAngleValueInRadians();
107003:         aFunctions.AppendElement(Rotation(theta));
107003:         break;
107003:       }
107003:       case eCSSKeyword_rotate3d:
107003:       {
107003:         double x = array->Item(1).GetFloatValue();
107003:         double y = array->Item(2).GetFloatValue();
107003:         double z = array->Item(3).GetFloatValue();
107003:         double theta = array->Item(4).GetAngleValueInRadians();
107003:         aFunctions.AppendElement(Rotation3D(x, y, z, theta));
107003:         break;
107003:       }
107003:       case eCSSKeyword_scalex:
107003:       {
107003:         double x = array->Item(1).GetFloatValue();
107003:         aFunctions.AppendElement(Scale(x, 1, 1));
107003:         break;
107003:       }
107003:       case eCSSKeyword_scaley:
107003:       {
107003:         double y = array->Item(1).GetFloatValue();
107003:         aFunctions.AppendElement(Scale(1, y, 1));
107003:         break;
107003:       }
107003:       case eCSSKeyword_scalez:
107003:       {
107003:         double z = array->Item(1).GetFloatValue();
107003:         aFunctions.AppendElement(Scale(1, 1, z));
107003:         break;
107003:       }
107003:       case eCSSKeyword_scale:
107003:       {
107003:         double x = array->Item(1).GetFloatValue();
107003:         // scale(x) is shorthand for scale(x, x);
107003:         double y = array->Count() == 2 ? x : array->Item(2).GetFloatValue();
107003:         aFunctions.AppendElement(Scale(x, y, 1));
107003:         break;
107003:       }
107003:       case eCSSKeyword_scale3d:
107003:       {
107003:         double x = array->Item(1).GetFloatValue();
107003:         double y = array->Item(2).GetFloatValue();
107003:         double z = array->Item(3).GetFloatValue();
107003:         aFunctions.AppendElement(Scale(x, y, z));
107003:         break;
107003:       }
107003:       case eCSSKeyword_translatex:
107003:       {
107003:         double x = nsStyleTransformMatrix::ProcessTranslatePart(
107003:           array->Item(1), aContext, aPresContext, canStoreInRuleTree,
107003:           aBounds.Width(), aAppUnitsPerPixel);
107003:         aFunctions.AppendElement(Translation(x, 0, 0));
107003:         break;
107003:       }
107003:       case eCSSKeyword_translatey:
107003:       {
107003:         double y = nsStyleTransformMatrix::ProcessTranslatePart(
107003:           array->Item(1), aContext, aPresContext, canStoreInRuleTree,
107003:           aBounds.Height(), aAppUnitsPerPixel);
107003:         aFunctions.AppendElement(Translation(0, y, 0));
107003:         break;
107003:       }
107003:       case eCSSKeyword_translatez:
107003:       {
107003:         double z = nsStyleTransformMatrix::ProcessTranslatePart(
107003:           array->Item(1), aContext, aPresContext, canStoreInRuleTree,
107003:           0, aAppUnitsPerPixel);
107003:         aFunctions.AppendElement(Translation(0, 0, z));
107003:         break;
107003:       }
107003:       case eCSSKeyword_translate:
107003:       {
107003:         double x = nsStyleTransformMatrix::ProcessTranslatePart(
107003:           array->Item(1), aContext, aPresContext, canStoreInRuleTree,
107003:           aBounds.Width(), aAppUnitsPerPixel);
107003:         // translate(x) is shorthand for translate(x, 0)
107003:         double y = 0;
107003:         if (array->Count() == 3) {
107003:            y = nsStyleTransformMatrix::ProcessTranslatePart(
107003:             array->Item(2), aContext, aPresContext, canStoreInRuleTree,
107003:             aBounds.Height(), aAppUnitsPerPixel);
107003:         }
107003:         aFunctions.AppendElement(Translation(x, y, 0));
107003:         break;
107003:       }
107003:       case eCSSKeyword_translate3d:
107003:       {
107003:         double x = nsStyleTransformMatrix::ProcessTranslatePart(
107003:           array->Item(1), aContext, aPresContext, canStoreInRuleTree,
107003:           aBounds.Width(), aAppUnitsPerPixel);
107003:         double y = nsStyleTransformMatrix::ProcessTranslatePart(
107003:           array->Item(2), aContext, aPresContext, canStoreInRuleTree,
107003:           aBounds.Height(), aAppUnitsPerPixel);
107003:         double z = nsStyleTransformMatrix::ProcessTranslatePart(
107003:           array->Item(3), aContext, aPresContext, canStoreInRuleTree,
107003:           0, aAppUnitsPerPixel);
107003: 
107003:         aFunctions.AppendElement(Translation(x, y, z));
107003:         break;
107003:       }
107003:       case eCSSKeyword_skewx:
107003:       {
107003:         double x = array->Item(1).GetFloatValue();
107003:         aFunctions.AppendElement(SkewX(x));
107003:         break;
107003:       }
107003:       case eCSSKeyword_skewy:
107003:       {
107003:         double y = array->Item(1).GetFloatValue();
107003:         aFunctions.AppendElement(SkewY(y));
107003:         break;
107003:       }
107003:       case eCSSKeyword_matrix:
107003:       {
107003:         gfx3DMatrix matrix;
107003:         matrix._11 = array->Item(1).GetFloatValue();
107003:         matrix._12 = array->Item(2).GetFloatValue();
107003:         matrix._13 = 0;
107003:         matrix._14 = array->Item(3).GetFloatValue();
107003:         matrix._21 = array->Item(4).GetFloatValue();
107003:         matrix._22 = array->Item(5).GetFloatValue();
107003:         matrix._23 = 0;
107003:         matrix._24 = array->Item(6).GetFloatValue();
107003:         matrix._31 = 0;
107003:         matrix._32 = 0;
107003:         matrix._33 = 1;
107003:         matrix._34 = 0;
107003:         matrix._41 = 0;
107003:         matrix._42 = 0;
107003:         matrix._43 = 0;
107003:         matrix._44 = 1;
107003:         aFunctions.AppendElement(TransformMatrix(matrix));
107003:         break;
107003:       }
107003:       case eCSSKeyword_matrix3d:
107003:       {
107003:         gfx3DMatrix matrix;
107003:         matrix._11 = array->Item(1).GetFloatValue();
107003:         matrix._12 = array->Item(2).GetFloatValue();
107003:         matrix._13 = array->Item(3).GetFloatValue();
107003:         matrix._14 = array->Item(4).GetFloatValue();
107003:         matrix._21 = array->Item(5).GetFloatValue();
107003:         matrix._22 = array->Item(6).GetFloatValue();
107003:         matrix._23 = array->Item(7).GetFloatValue();
107003:         matrix._24 = array->Item(8).GetFloatValue();
107003:         matrix._31 = array->Item(9).GetFloatValue();
107003:         matrix._32 = array->Item(10).GetFloatValue();
107003:         matrix._33 = array->Item(11).GetFloatValue();
107003:         matrix._34 = array->Item(12).GetFloatValue();
107003:         matrix._41 = array->Item(13).GetFloatValue();
107003:         matrix._42 = array->Item(14).GetFloatValue();
107003:         matrix._43 = array->Item(15).GetFloatValue();
107003:         matrix._44 = array->Item(16).GetFloatValue();
107003:         aFunctions.AppendElement(TransformMatrix(matrix));
107003:         break;
107003:       }
125555:       case eCSSKeyword_interpolatematrix:
125555:       {
125555:         gfx3DMatrix matrix;
125555:         nsStyleTransformMatrix::ProcessInterpolateMatrix(matrix, array,
125555:                                                          aContext,
125555:                                                          aPresContext,
125555:                                                          canStoreInRuleTree,
125555:                                                          aBounds,
125555:                                                          aAppUnitsPerPixel);
125555:         aFunctions.AppendElement(TransformMatrix(matrix));
125555:         break;
125555:       }
107003:       case eCSSKeyword_perspective:
107003:       {
107003:         aFunctions.AppendElement(Perspective(array->Item(1).GetFloatValue()));
107003:         break;
107003:       }
107003:       default:
107003:         NS_ERROR("Function not handled yet!");
107003:     }
107003:   }
107003: }
107003: 
107003: static TimingFunction
107003: ToTimingFunction(css::ComputedTimingFunction& aCTF)
107003: {
107003:   if (aCTF.GetType() == nsTimingFunction::Function) {
107003:     const nsSMILKeySpline* spline = aCTF.GetFunction();
107003:     return TimingFunction(CubicBezierFunction(spline->X1(), spline->Y1(),
107003:                                               spline->X2(), spline->Y2()));
107003:   }
107003: 
108991:   uint32_t type = aCTF.GetType() == nsTimingFunction::StepStart ? 1 : 2;
107003:   return TimingFunction(StepFunction(aCTF.GetSteps(), type));
107003: }
107003: 
107003: static void
107005: AddAnimationsForProperty(nsIFrame* aFrame, nsCSSProperty aProperty,
107005:                          ElementAnimation* ea, Layer* aLayer,
107005:                          AnimationData& aData)
107003: {
107005:   NS_ASSERTION(aLayer->AsContainerLayer(), "Should only animate ContainerLayer");
107005:   nsStyleContext* styleContext = aFrame->GetStyleContext();
107005:   nsPresContext* presContext = aFrame->PresContext();
107005:   nsRect bounds = nsDisplayTransform::GetFrameBoundsForTransform(aFrame);
107007:   float scale = presContext->AppUnitsPerDevPixel();
107005: 
108801:   TimeStamp startTime = ea->mStartTime;
108801:   TimeDuration duration = ea->mIterationDuration;
107005:   float iterations = ea->mIterationCount != NS_IEEEPositiveInfinity()
107005:                      ? ea->mIterationCount : -1;
108801:   int direction = ea->mDirection;
108801: 
108885:   Animation* animation = aLayer->AddAnimation(startTime, duration,
108801:                                               iterations, direction,
108801:                                               aProperty, aData);
108801: 
108991:   for (uint32_t propIdx = 0; propIdx < ea->mProperties.Length(); propIdx++) {
107005:     AnimationProperty* property = &ea->mProperties[propIdx];
107005: 
107005:     if (aProperty != property->mProperty) {
107005:       continue;
107005:     }
107005: 
108991:     for (uint32_t segIdx = 0; segIdx < property->mSegments.Length(); segIdx++) {
107005:       AnimationPropertySegment* segment = &property->mSegments[segIdx];
107005: 
108885:       AnimationSegment* animSegment = animation->segments().AppendElement();
107005:       if (aProperty == eCSSProperty_transform) {
108800:         animSegment->startState() = InfallibleTArray<TransformFunction>();
108800:         animSegment->endState() = InfallibleTArray<TransformFunction>();
108800: 
107005:         nsCSSValueList* list = segment->mFromValue.GetCSSValueListValue();
108800:         AddTransformFunctions(list, styleContext, presContext, bounds, scale,
108800:                               animSegment->startState().get_ArrayOfTransformFunction());
107005: 
107005:         list = segment->mToValue.GetCSSValueListValue();
108800:         AddTransformFunctions(list, styleContext, presContext, bounds, scale,
108800:                               animSegment->endState().get_ArrayOfTransformFunction());
107005:       } else if (aProperty == eCSSProperty_opacity) {
108800:         animSegment->startState() = segment->mFromValue.GetFloatValue();
108800:         animSegment->endState() = segment->mToValue.GetFloatValue();
108800:       }
108800: 
108800:       animSegment->startPortion() = segment->mFromKey;
108800:       animSegment->endPortion() = segment->mToKey;
108800:       animSegment->sampleFn() = ToTimingFunction(segment->mTimingFunction);
107005:     }
107005:   }
107005: }
107005: 
107005: static void
107567: AddAnimationsAndTransitionsToLayer(Layer* aLayer, nsDisplayListBuilder* aBuilder,
107567:                                    nsDisplayItem* aItem, nsCSSProperty aProperty)
107005: {
107005:   aLayer->ClearAnimations();
107005: 
107005:   nsIFrame* frame = aItem->GetUnderlyingFrame();
107567: 
114746:   nsIContent* content = frame->GetContent();
114746:   if (!content) {
114746:     return;
114746:   }
107005:   ElementTransitions* et =
114746:     nsTransitionManager::GetTransitionsForCompositor(content, aProperty);
107005: 
107005:   ElementAnimations* ea =
114746:     nsAnimationManager::GetAnimationsForCompositor(content, aProperty);
107005: 
107005:   if (!ea && !et) {
107003:     return;
107005:   }
107005: 
107567:   // If the frame is not prerendered, bail out.  Layout will still perform the
107567:   // animation.
109138:   if (!aItem->CanUseAsyncAnimations(aBuilder)) {
107567:     return;
107567:   }
107567: 
107005:   mozilla::TimeStamp currentTime =
107005:     frame->PresContext()->RefreshDriver()->MostRecentRefresh();
107005:   AnimationData data;
107005:   if (aProperty == eCSSProperty_transform) {
107003:     nsRect bounds = nsDisplayTransform::GetFrameBoundsForTransform(frame);
107003:     float scale = nsDeviceContext::AppUnitsPerCSSPixel();
107003:     gfxPoint3D offsetToTransformOrigin =
107003:       nsDisplayTransform::GetDeltaToMozTransformOrigin(frame, scale, &bounds);
107003:     gfxPoint3D offsetToPerspectiveOrigin =
107003:       nsDisplayTransform::GetDeltaToMozPerspectiveOrigin(frame, scale);
107003:     nscoord perspective = 0.0;
107003:     nsStyleContext* parentStyleContext = frame->GetStyleContext()->GetParent();
107003:     if (parentStyleContext) {
107003:       const nsStyleDisplay* disp = parentStyleContext->GetStyleDisplay();
107003:       if (disp && disp->mChildPerspective.GetUnit() == eStyleUnit_Coord) {
107003:         perspective = disp->mChildPerspective.GetCoordValue();
107003:       }
107003:     }
107005:     nsPoint origin = aItem->ToReferenceFrame();
107005: 
107005:     data = TransformData(origin, offsetToTransformOrigin,
107005:                          offsetToPerspectiveOrigin, bounds, perspective);
107005:   } else if (aProperty == eCSSProperty_opacity) {
107005:     data = null_t();
107005:   }
107005: 
107005:   if (et) {
108991:     for (uint32_t tranIdx = 0; tranIdx < et->mPropertyTransitions.Length(); tranIdx++) {
107005:       ElementPropertyTransition* pt = &et->mPropertyTransitions[tranIdx];
108984:       if (pt->mProperty != aProperty || !pt->IsRunningAt(currentTime)) {
107005:         continue;
107005:       }
107005: 
107005:       ElementAnimation anim;
107005:       anim.mIterationCount = 1;
107005:       anim.mDirection = NS_STYLE_ANIMATION_DIRECTION_NORMAL;
107005:       anim.mFillMode = NS_STYLE_ANIMATION_FILL_MODE_NONE;
107005:       anim.mStartTime = pt->mStartTime;
107005:       anim.mIterationDuration = pt->mDuration;
107005: 
107005:       AnimationProperty& prop = *anim.mProperties.AppendElement();
107005:       prop.mProperty = pt->mProperty;
107005: 
107005:       AnimationPropertySegment& segment = *prop.mSegments.AppendElement();
107005:       segment.mFromKey = 0;
107005:       segment.mToKey = 1;
107005:       segment.mFromValue = pt->mStartValue;
107005:       segment.mToValue = pt->mEndValue;
107005:       segment.mTimingFunction = pt->mTimingFunction;
107005: 
107005:       AddAnimationsForProperty(frame, aProperty, &anim,
107005:                                aLayer, data);
107005:     }
125555:     aLayer->SetAnimationGeneration(et->mAnimationGeneration);
107005:   }
107005: 
107005:   if (ea) {
108991:     for (uint32_t animIdx = 0; animIdx < ea->mAnimations.Length(); animIdx++) {
107003:       ElementAnimation* anim = &ea->mAnimations[animIdx];
108885:       if (!(anim->HasAnimationOfProperty(aProperty) &&
108984:             anim->IsRunningAt(currentTime))) {
107003:         continue;
107003:       }
107005:       AddAnimationsForProperty(frame, aProperty, anim,
107005:                                aLayer, data);
107005:     }
125555:     aLayer->SetAnimationGeneration(ea->mAnimationGeneration);
107005:   }
107005: }
107003: 
     1: nsDisplayListBuilder::nsDisplayListBuilder(nsIFrame* aReferenceFrame,
 79445:     Mode aMode, bool aBuildCaret)
     1:     : mReferenceFrame(aReferenceFrame),
106838:       mIgnoreScrollFrame(nullptr),
106838:       mCurrentTableItem(nullptr),
106838:       mFinalTransparentRegion(nullptr),
 95645:       mCachedOffsetFrame(aReferenceFrame),
114042:       mCachedReferenceFrame(aReferenceFrame),
 95645:       mCachedOffset(0, 0),
106838:       mGlassDisplayItem(nullptr),
 58600:       mMode(aMode),
     1:       mBuildCaret(aBuildCaret),
 80486:       mIgnoreSuppression(false),
 80486:       mHadToIgnoreSuppression(false),
 80486:       mIsAtRootOfPseudoStackingContext(false),
 80486:       mIncludeAllOutOfFlows(false),
 80486:       mSelectedFramesOnly(false),
 80486:       mAccurateVisibleRegions(false),
118837:       mAllowMergingAndFlattening(true),
118837:       mWillComputePluginGeometry(false),
 80486:       mInTransform(false),
 80486:       mSyncDecodeImages(false),
 80486:       mIsPaintingToWindow(false),
 80486:       mHasDisplayPort(false),
106096:       mHasFixedItems(false),
106380:       mIsInFixedPosition(false),
119281:       mIsCompositingCheap(false),
119281:       mContainsPluginItem(false)
 67670: {
 43900:   MOZ_COUNT_CTOR(nsDisplayListBuilder);
 47957:   PL_InitArenaPool(&mPool, "displayListArena", 1024,
 47957:                    NS_MAX(NS_ALIGNMENT_OF(void*),NS_ALIGNMENT_OF(double))-1);
     1: 
   238:   nsPresContext* pc = aReferenceFrame->PresContext();
     1:   nsIPresShell *shell = pc->PresShell();
     1:   if (pc->IsRenderingOnlySelection()) {
     1:     nsCOMPtr<nsISelectionController> selcon(do_QueryInterface(shell));
     1:     if (selcon) {
     1:       selcon->GetSelection(nsISelectionController::SELECTION_NORMAL,
     1:                            getter_AddRefs(mBoundingSelection));
     1:     }
     1:   }
     1: 
 67670:   if(mReferenceFrame->GetType() == nsGkAtoms::viewportFrame) {
 67670:     ViewportFrame* viewportFrame = static_cast<ViewportFrame*>(mReferenceFrame);
 77154:     if (!viewportFrame->GetChildList(nsIFrame::kFixedList).IsEmpty()) {
 80486:       mHasFixedItems = true;
 67670:     }
 67670:   }
 67670: 
122315:   nsCSSRendering::BeginFrameTreesLocked();
 47768:   PR_STATIC_ASSERT(nsDisplayItem::TYPE_MAX < (1 << nsDisplayItem::TYPE_BITS));
     1: }
     1: 
     1: static void MarkFrameForDisplay(nsIFrame* aFrame, nsIFrame* aStopAtFrame) {
     1:   for (nsIFrame* f = aFrame; f;
101616:        f = nsLayoutUtils::GetParentOrPlaceholderFor(f)) {
     1:     if (f->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO)
     1:       return;
     1:     f->AddStateBits(NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO);
     1:     if (f == aStopAtFrame) {
     1:       // we've reached a frame that we know will be painted, so we can stop.
     1:       break;
     1:     }
     1:   }
     1: }
     1: 
 79445: static bool IsFixedFrame(nsIFrame* aFrame)
 67670: {
 67670:   return aFrame && aFrame->GetParent() && !aFrame->GetParent()->GetParent();
 67670: }
 67670: 
113851: bool
113851: nsDisplayListBuilder::IsFixedItem(nsDisplayItem *aItem,
114041:                                   const nsIFrame** aActiveScrolledRoot,
114041:                                   const nsIFrame* aOverrideActiveScrolledRoot)
 67670: {
114041:   const nsIFrame* activeScrolledRoot = aOverrideActiveScrolledRoot;
113851:   if (!activeScrolledRoot) {
113851:     if (aItem->GetType() == nsDisplayItem::TYPE_SCROLL_LAYER) {
113851:       nsDisplayScrollLayer* scrollLayerItem =
113851:         static_cast<nsDisplayScrollLayer*>(aItem);
113851:       activeScrolledRoot =
113851:         nsLayoutUtils::GetActiveScrolledRootFor(scrollLayerItem->GetScrolledFrame(),
114042:                                                 FindReferenceFrameFor(scrollLayerItem->GetScrolledFrame()));
113851:     } else {
113851:       activeScrolledRoot = nsLayoutUtils::GetActiveScrolledRootFor(aItem, this);
113851:     }
113851:   }
113851: 
113851:   if (aActiveScrolledRoot) {
113851:     *aActiveScrolledRoot = activeScrolledRoot;
113851:   }
113851: 
 67670:   return activeScrolledRoot &&
113851:     !nsLayoutUtils::IsScrolledByRootContentDocumentDisplayportScrolling(activeScrolledRoot, this);
 67670: }
 67670: 
 79445: static bool ForceVisiblityForFixedItem(nsDisplayListBuilder* aBuilder,
 86220:                                        nsDisplayItem* aItem)
 67670: {
 69752:   return aBuilder->GetDisplayPort() && aBuilder->GetHasFixedItems() &&
113851:          aBuilder->IsFixedItem(aItem);
 67670: }
 67670: 
 69909: void nsDisplayListBuilder::SetDisplayPort(const nsRect& aDisplayPort)
 69909: {
 69909:     static bool fixedPositionLayersEnabled = getenv("MOZ_ENABLE_FIXED_POSITION_LAYERS") != 0;
 69909:     if (fixedPositionLayersEnabled) {
 80486:       mHasDisplayPort = true;
 69909:       mDisplayPort = aDisplayPort;
 69909:     }
 69909: }
 69909: 
 67670: void nsDisplayListBuilder::MarkOutOfFlowFrameForDisplay(nsIFrame* aDirtyFrame,
 67670:                                                         nsIFrame* aFrame,
 67670:                                                         const nsRect& aDirtyRect)
 67670: {
     1:   nsRect dirty = aDirtyRect - aFrame->GetOffsetTo(aDirtyFrame);
 55040:   nsRect overflowRect = aFrame->GetVisualOverflowRect();
 67670: 
 67670:   if (mHasDisplayPort && IsFixedFrame(aFrame)) {
 67670:     dirty = overflowRect;
 67670:   }
 67670: 
     1:   if (!dirty.IntersectRect(dirty, overflowRect))
     1:     return;
 39965:   aFrame->Properties().Set(nsDisplayListBuilder::OutOfFlowDirtyRectProperty(),
 39965:                            new nsRect(dirty));
     1: 
     1:   MarkFrameForDisplay(aFrame, aDirtyFrame);
     1: }
     1: 
     1: static void UnmarkFrameForDisplay(nsIFrame* aFrame) {
 39965:   nsPresContext* presContext = aFrame->PresContext();
 39965:   presContext->PropertyTable()->
 39965:     Delete(aFrame, nsDisplayListBuilder::OutOfFlowDirtyRectProperty());
     1: 
     1:   for (nsIFrame* f = aFrame; f;
101616:        f = nsLayoutUtils::GetParentOrPlaceholderFor(f)) {
     1:     if (!(f->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO))
     1:       return;
     1:     f->RemoveStateBits(NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO);
     1:   }
     1: }
     1: 
 60443: static void RecordFrameMetrics(nsIFrame* aForFrame,
 69189:                                nsIFrame* aScrollFrame,
 60443:                                ContainerLayer* aRoot,
 72251:                                const nsRect& aVisibleRect,
 72251:                                const nsRect& aViewport,
 63414:                                nsRect* aDisplayPort,
123809:                                nsRect* aCriticalDisplayPort,
 72251:                                ViewID aScrollId,
109009:                                const nsDisplayItem::ContainerParameters& aContainerParameters,
109009:                                bool aMayHaveTouchListeners) {
 60443:   nsPresContext* presContext = aForFrame->PresContext();
108991:   int32_t auPerDevPixel = presContext->AppUnitsPerDevPixel();
115456:   float auPerCSSPixel = nsPresContext::AppUnitsPerCSSPixel();
 60443: 
 72251:   nsIntRect visible = aVisibleRect.ScaleToNearestPixels(
 72251:     aContainerParameters.mXScale, aContainerParameters.mYScale, auPerDevPixel);
 60443:   aRoot->SetVisibleRegion(nsIntRegion(visible));
 60443: 
 60443:   FrameMetrics metrics;
 60443: 
115456:   metrics.mViewport = mozilla::gfx::Rect(
115456:     NSAppUnitsToDoublePixels(aViewport.x, auPerDevPixel),
115456:     NSAppUnitsToDoublePixels(aViewport.y, auPerDevPixel),
115456:     NSAppUnitsToDoublePixels(aViewport.width, auPerDevPixel),
115456:     NSAppUnitsToDoublePixels(aViewport.height, auPerDevPixel));
 72251: 
 63414:   if (aDisplayPort) {
115456:     metrics.mDisplayPort = mozilla::gfx::Rect(
115456:       NSAppUnitsToDoublePixels(aDisplayPort->x, auPerDevPixel),
115456:       NSAppUnitsToDoublePixels(aDisplayPort->y, auPerDevPixel),
115456:       NSAppUnitsToDoublePixels(aDisplayPort->width, auPerDevPixel),
115456:       NSAppUnitsToDoublePixels(aDisplayPort->height, auPerDevPixel));
123809: 
123809:       if (aCriticalDisplayPort) {
123809:         metrics.mCriticalDisplayPort = mozilla::gfx::Rect(
123809:           NSAppUnitsToDoublePixels(aCriticalDisplayPort->x, auPerDevPixel),
123809:           NSAppUnitsToDoublePixels(aCriticalDisplayPort->y, auPerDevPixel),
123809:           NSAppUnitsToDoublePixels(aCriticalDisplayPort->width, auPerDevPixel),
123809:           NSAppUnitsToDoublePixels(aCriticalDisplayPort->height, auPerDevPixel));
123809:       }
 60443:   }
 60443: 
106838:   nsIScrollableFrame* scrollableFrame = nullptr;
 69189:   if (aScrollFrame)
 69189:     scrollableFrame = aScrollFrame->GetScrollTargetFrame();
 63413: 
 63413:   if (scrollableFrame) {
 99281:     nsRect contentBounds = scrollableFrame->GetScrollRange();
 99281:     contentBounds.width += scrollableFrame->GetScrollPortRect().width;
 99281:     contentBounds.height += scrollableFrame->GetScrollPortRect().height;
115456:     metrics.mScrollableRect =
107003:       mozilla::gfx::Rect(nsPresContext::AppUnitsToFloatCSSPixels(contentBounds.x),
 99281:                          nsPresContext::AppUnitsToFloatCSSPixels(contentBounds.y),
 99281:                          nsPresContext::AppUnitsToFloatCSSPixels(contentBounds.width),
 99281:                          nsPresContext::AppUnitsToFloatCSSPixels(contentBounds.height));
 99281:     metrics.mContentRect = contentBounds.ScaleToNearestPixels(
 72251:       aContainerParameters.mXScale, aContainerParameters.mYScale, auPerDevPixel);
109012:     nsPoint scrollPosition = scrollableFrame->GetScrollPosition();
115456:     metrics.mScrollOffset = mozilla::gfx::Point(
115456:       NSAppUnitsToDoublePixels(scrollPosition.x, auPerCSSPixel),
115456:       NSAppUnitsToDoublePixels(scrollPosition.y, auPerCSSPixel));
 60868:   }
 60868:   else {
 99281:     nsRect contentBounds = aForFrame->GetRect();
115456:     metrics.mScrollableRect =
107003:       mozilla::gfx::Rect(nsPresContext::AppUnitsToFloatCSSPixels(contentBounds.x),
 99281:                          nsPresContext::AppUnitsToFloatCSSPixels(contentBounds.y),
 99281:                          nsPresContext::AppUnitsToFloatCSSPixels(contentBounds.width),
 99281:                          nsPresContext::AppUnitsToFloatCSSPixels(contentBounds.height));
 99281:     metrics.mContentRect = contentBounds.ScaleToNearestPixels(
 72251:       aContainerParameters.mXScale, aContainerParameters.mYScale, auPerDevPixel);
 60443:   }
 60443: 
 60868:   metrics.mScrollId = aScrollId;
 96930: 
 96930:   nsIPresShell* presShell = presContext->GetPresShell();
125720:   if (TabChild *tc = GetTabChildFrom(presShell)) {
125720:     metrics.mZoom = tc->GetZoom();
125720:   }
 96930:   metrics.mResolution = gfxSize(presShell->GetXResolution(), presShell->GetYResolution());
 96930: 
115456:   metrics.mDevPixelsPerCSSPixel = auPerCSSPixel / auPerDevPixel;
115456: 
109009:   metrics.mMayHaveTouchListeners = aMayHaveTouchListeners;
109009: 
118597:   if (nsIWidget* widget = aForFrame->GetNearestWidget()) {
118597:     widget->GetBounds(metrics.mCompositionBounds);
118597:   }
118597: 
 60443:   aRoot->SetFrameMetrics(metrics);
 60443: }
 60443: 
     1: nsDisplayListBuilder::~nsDisplayListBuilder() {
  9798:   NS_ASSERTION(mFramesMarkedForDisplay.Length() == 0,
  9798:                "All frames should have been unmarked");
  9798:   NS_ASSERTION(mPresShellStates.Length() == 0,
  9798:                "All presshells should have been exited");
 13961:   NS_ASSERTION(!mCurrentTableItem, "No table item should be active");
     1: 
122315:   nsCSSRendering::EndFrameTreesLocked();
122315: 
     1:   PL_FinishArenaPool(&mPool);
 43900:   MOZ_COUNT_DTOR(nsDisplayListBuilder);
     1: }
     1: 
108991: uint32_t
 32425: nsDisplayListBuilder::GetBackgroundPaintFlags() {
108991:   uint32_t flags = 0;
 32425:   if (mSyncDecodeImages) {
 32425:     flags |= nsCSSRendering::PAINTBG_SYNC_DECODE_IMAGES;
 32425:   }
 56434:   if (mIsPaintingToWindow) {
 56434:     flags |= nsCSSRendering::PAINTBG_TO_WINDOW;
 56434:   }
 32425:   return flags;
 32425: }
 32425: 
108991: static uint64_t RegionArea(const nsRegion& aRegion)
 59824: {
108991:   uint64_t area = 0;
 59824:   nsRegionRectIterator iter(aRegion);
 59824:   const nsRect* r;
106838:   while ((r = iter.Next()) != nullptr) {
108991:     area += uint64_t(r->width)*r->height;
 59824:   }
 59824:   return area;
 59824: }
 59824: 
 31544: void
 31544: nsDisplayListBuilder::SubtractFromVisibleRegion(nsRegion* aVisibleRegion,
 69802:                                                 const nsRegion& aRegion)
 31544: {
 59779:   if (aRegion.IsEmpty())
 59779:     return;
 59779: 
 32908:   nsRegion tmp;
 32908:   tmp.Sub(*aVisibleRegion, aRegion);
 32908:   // Don't let *aVisibleRegion get too complex, but don't let it fluff out
 32908:   // to its bounds either, which can be very bad (see bug 516740).
 59824:   // Do let aVisibleRegion get more complex if by doing so we reduce its
 59824:   // area by at least half.
 69802:   if (GetAccurateVisibleRegions() || tmp.GetNumRects() <= 15 ||
 59824:       RegionArea(tmp) <= RegionArea(*aVisibleRegion)/2) {
 32908:     *aVisibleRegion = tmp;
 31544:   }
 31544: }
 31544: 
 15969: nsCaret *
     1: nsDisplayListBuilder::GetCaret() {
 39960:   nsRefPtr<nsCaret> caret = CurrentPresShellState()->mPresShell->GetCaret();
     1:   return caret;
     1: }
     1: 
     1: void
     1: nsDisplayListBuilder::EnterPresShell(nsIFrame* aReferenceFrame,
     1:                                      const nsRect& aDirtyRect) {
  9798:   PresShellState* state = mPresShellStates.AppendElement();
  9798:   if (!state)
  9798:     return;
  9798:   state->mPresShell = aReferenceFrame->PresContext()->PresShell();
106838:   state->mCaretFrame = nullptr;
  9798:   state->mFirstFrameMarkedForDisplay = mFramesMarkedForDisplay.Length();
  9798: 
 27834:   state->mPresShell->UpdateCanvasBackground();
 27834: 
 42240:   if (mIsPaintingToWindow) {
 61717:     mReferenceFrame->AddPaintedPresShell(state->mPresShell);
 61717: 
 42240:     state->mPresShell->IncrementPaintCount();
 42240:   }
 42240: 
 79445:   bool buildCaret = mBuildCaret;
 51851:   if (mIgnoreSuppression || !state->mPresShell->IsPaintingSuppressed()) {
 51851:     if (state->mPresShell->IsPaintingSuppressed()) {
 80486:       mHadToIgnoreSuppression = true;
 51851:     }
 80486:     state->mIsBackgroundOnly = false;
 51851:   } else {
 80486:     state->mIsBackgroundOnly = true;
 80486:     buildCaret = false;
 51851:   }
 51851: 
 51851:   if (!buildCaret)
     1:     return;
     1: 
 39960:   nsRefPtr<nsCaret> caret = state->mPresShell->GetCaret();
  9798:   state->mCaretFrame = caret->GetCaretFrame();
     1: 
  9798:   if (state->mCaretFrame) {
     1:     // Check if the dirty rect intersects with the caret's dirty rect.
     1:     nsRect caretRect =
  9798:       caret->GetCaretRect() + state->mCaretFrame->GetOffsetTo(aReferenceFrame);
     1:     if (caretRect.Intersects(aDirtyRect)) {
     1:       // Okay, our rects intersect, let's mark the frame and all of its ancestors.
  9798:       mFramesMarkedForDisplay.AppendElement(state->mCaretFrame);
106838:       MarkFrameForDisplay(state->mCaretFrame, nullptr);
     1:     }
     1:   }
     1: }
     1: 
     1: void
     1: nsDisplayListBuilder::LeavePresShell(nsIFrame* aReferenceFrame,
 27834:                                      const nsRect& aDirtyRect) {
  9798:   if (CurrentPresShellState()->mPresShell != aReferenceFrame->PresContext()->PresShell()) {
  9798:     // Must have not allocated a state for this presshell, presumably due
  9798:     // to OOM.
     1:     return;
  9798:   }
     1: 
  9798:   // Unmark and pop off the frames marked for display in this pres shell.
108991:   uint32_t firstFrameForShell = CurrentPresShellState()->mFirstFrameMarkedForDisplay;
108991:   for (uint32_t i = firstFrameForShell;
  9798:        i < mFramesMarkedForDisplay.Length(); ++i) {
  9798:     UnmarkFrameForDisplay(mFramesMarkedForDisplay[i]);
  9798:   }
  9798:   mFramesMarkedForDisplay.SetLength(firstFrameForShell);
  9798:   mPresShellStates.SetLength(mPresShellStates.Length() - 1);
     1: }
     1: 
     1: void
 30782: nsDisplayListBuilder::MarkFramesForDisplayList(nsIFrame* aDirtyFrame,
 30782:                                                const nsFrameList& aFrames,
     1:                                                const nsRect& aDirtyRect) {
 30782:   for (nsFrameList::Enumerator e(aFrames); !e.AtEnd(); e.Next()) {
 30782:     mFramesMarkedForDisplay.AppendElement(e.get());
 30782:     MarkOutOfFlowFrameForDisplay(aDirtyFrame, e.get(), aDirtyRect);
     1:   }
     1: }
     1: 
 98299: void
 98299: nsDisplayListBuilder::MarkPreserve3DFramesForDisplayList(nsIFrame* aDirtyFrame, const nsRect& aDirtyRect)
 98299: {
 98299:   nsAutoTArray<nsIFrame::ChildList,4> childListArray;
 98299:   aDirtyFrame->GetChildLists(&childListArray);
 98299:   nsIFrame::ChildListArrayIterator lists(childListArray);
 98299:   for (; !lists.IsDone(); lists.Next()) {
 98299:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 98299:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 98299:       nsIFrame *child = childFrames.get();
 98299:       if (child->Preserves3D()) {
 98299:         mFramesMarkedForDisplay.AppendElement(child);
 98299:         nsRect dirty = aDirtyRect - child->GetOffsetTo(aDirtyFrame);
 98299: 
 98299:         child->Properties().Set(nsDisplayListBuilder::Preserve3DDirtyRectProperty(),
 98299:                            new nsRect(dirty));
 98299: 
 98299:         MarkFrameForDisplay(child, aDirtyFrame);
 98299:       }
 98299:     }
 98299:   }
 98299: }
 98299: 
     1: void*
     1: nsDisplayListBuilder::Allocate(size_t aSize) {
     1:   void *tmp;
     1:   PL_ARENA_ALLOCATE(tmp, &mPool, aSize);
121238:   if (!tmp) {
121238:     NS_RUNTIMEABORT("out of memory");
121238:   }
     1:   return tmp;
     1: }
     1: 
     1: void nsDisplayListSet::MoveTo(const nsDisplayListSet& aDestination) const
     1: {
     1:   aDestination.BorderBackground()->AppendToTop(BorderBackground());
     1:   aDestination.BlockBorderBackgrounds()->AppendToTop(BlockBorderBackgrounds());
     1:   aDestination.Floats()->AppendToTop(Floats());
     1:   aDestination.Content()->AppendToTop(Content());
     1:   aDestination.PositionedDescendants()->AppendToTop(PositionedDescendants());
     1:   aDestination.Outlines()->AppendToTop(Outlines());
     1: }
     1: 
     1: void
  7819: nsDisplayList::FlattenTo(nsTArray<nsDisplayItem*>* aElements) {
     1:   nsDisplayItem* item;
106838:   while ((item = RemoveBottom()) != nullptr) {
 47732:     if (item->GetType() == nsDisplayItem::TYPE_WRAP_LIST) {
120809:       item->GetSameCoordinateSystemChildren()->FlattenTo(aElements);
     1:       item->~nsDisplayItem();
     1:     } else {
     1:       aElements->AppendElement(item);
     1:     }
     1:   }
     1: }
     1: 
 19125: nsRect
 19125: nsDisplayList::GetBounds(nsDisplayListBuilder* aBuilder) const {
 19125:   nsRect bounds;
106838:   for (nsDisplayItem* i = GetBottom(); i != nullptr; i = i->GetAbove()) {
 95051:     bool snap;
 95051:     bounds.UnionRect(bounds, i->GetBounds(aBuilder, &snap));
 19125:   }
 19125:   return bounds;
 19125: }
 19125: 
 79445: bool
 51633: nsDisplayList::ComputeVisibilityForRoot(nsDisplayListBuilder* aBuilder,
 50393:                                         nsRegion* aVisibleRegion) {
 96794:   SAMPLE_LABEL("nsDisplayList", "ComputeVisibilityForRoot");
 51633:   nsRegion r;
 51633:   r.And(*aVisibleRegion, GetBounds(aBuilder));
120128:   return ComputeVisibilityForSublist(aBuilder, nullptr, aVisibleRegion, r.GetBounds(), r.GetBounds());
 51633: }
 51633: 
 59779: static nsRegion
 97420: TreatAsOpaque(nsDisplayItem* aItem, nsDisplayListBuilder* aBuilder)
 57094: {
 95051:   bool snap;
 97420:   nsRegion opaque = aItem->GetOpaqueRegion(aBuilder, &snap);
 57094:   if (aBuilder->IsForPluginGeometry()) {
120810:     // Treat all leaf chrome items as opaque, unless their frames are opacity:0.
 70349:     // Since opacity:0 frames generate an nsDisplayOpacity, that item will
 70349:     // not be treated as opaque here, so opacity:0 chrome content will be
 70349:     // effectively ignored, as it should be.
120810:     // We treat leaf chrome items as opaque to ensure that they cover
120810:     // content plugins, for security reasons.
120810:     // Non-leaf chrome items don't render contents of their own so shouldn't
120810:     // be treated as opaque (and their bounds is just the union of their
120810:     // children, which might be a large area their contents don't really cover).
 57094:     nsIFrame* f = aItem->GetUnderlyingFrame();
120810:     if (f && f->PresContext()->IsChrome() && !aItem->GetChildren() &&
120810:         f->GetStyleDisplay()->mOpacity != 0.0) {
 95051:       opaque = aItem->GetBounds(aBuilder, &snap);
 57094:     }
 59779:   }
 59779:   return opaque;
 57094: }
 57094: 
 86220: static nsRect
 86220: GetDisplayPortBounds(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
 69752: {
 86220:   // GetDisplayPortBounds() rectangle is used in order to restrict fixed aItem's
 86220:   // visible bounds. nsDisplayTransform bounds already take item's
 86220:   // transform into account, so there is no need to apply it here one more time.
 86220:   // Start TransformRectToBoundsInAncestor() calculations from aItem's frame
 86220:   // parent in this case.
 69752:   nsIFrame* frame = aItem->GetUnderlyingFrame();
 86220:   if (aItem->GetType() == nsDisplayItem::TYPE_TRANSFORM) {
 86220:     frame = nsLayoutUtils::GetCrossDocParentFrame(frame);
 86220:   }
 86220: 
 74753:   const nsRect* displayport = aBuilder->GetDisplayPort();
 86353:   nsRect result = nsLayoutUtils::TransformAncestorRectToFrame(
 74753:                     frame,
 69752:                     nsRect(0, 0, displayport->width, displayport->height),
114042:                     aBuilder->FindReferenceFrameFor(frame));
 86220:   result.MoveBy(aBuilder->ToReferenceFrame(frame));
 86220:   return result;
 69752: }
 69752: 
 79445: bool
 51633: nsDisplayList::ComputeVisibilityForSublist(nsDisplayListBuilder* aBuilder,
120128:                                            nsDisplayItem* aForItem,
 51633:                                            nsRegion* aVisibleRegion,
 61411:                                            const nsRect& aListVisibleBounds,
 69802:                                            const nsRect& aAllowVisibleRegionExpansion) {
 95051:   bool snap;
 51633: #ifdef DEBUG
 51633:   nsRegion r;
 51633:   r.And(*aVisibleRegion, GetBounds(aBuilder));
 68638:   NS_ASSERTION(r.GetBounds().IsEqualInterior(aListVisibleBounds),
 51633:                "bad aListVisibleBounds");
 51633: #endif
 51633:   mVisibleRect = aListVisibleBounds;
 79445:   bool anyVisible = false;
 42246: 
  7819:   nsAutoTArray<nsDisplayItem*, 512> elements;
     1:   FlattenTo(&elements);
     1: 
 79445:   bool forceTransparentSurface = false;
 56101: 
108991:   for (int32_t i = elements.Length() - 1; i >= 0; --i) {
  7819:     nsDisplayItem* item = elements[i];
106838:     nsDisplayItem* belowItem = i < 1 ? nullptr : elements[i - 1];
     1: 
120128:     NS_ASSERTION(!aForItem ||
120128:                  item->GetType() != nsDisplayItem::TYPE_TRANSFORM ||
120128:                  item->GetUnderlyingFrame() != aForItem->GetUnderlyingFrame() ||
120128:                  aForItem->ReferenceFrame() != aForItem->GetUnderlyingFrame(),
120128:                  "If we have an nsDisplayTransform child (for the same frame),"
120128:                  "then we shouldn't be our own reference frame!");
120128: 
120809:     nsDisplayList* list = item->GetSameCoordinateSystemChildren();
118837:     if (aBuilder->AllowMergingAndFlattening()) {
     1:       if (belowItem && item->TryMerge(aBuilder, belowItem)) {
     1:         belowItem->~nsDisplayItem();
  7819:         elements.ReplaceElementsAt(i - 1, 1, item);
     1:         continue;
     1:       }
     1: 
 69189:       if (list && item->ShouldFlattenAway(aBuilder)) {
 69189:         // The elements on the list >= i no longer serve any use.
 69189:         elements.SetLength(i);
 69189:         list->FlattenTo(&elements);
 69189:         i = elements.Length();
 69189:         item->~nsDisplayItem();
 69189:         continue;
 69189:       }
118837:     }
 69189: 
 95051:     nsRect bounds = item->GetBounds(aBuilder, &snap);
 33368: 
 33368:     nsRegion itemVisible;
 86220:     if (ForceVisiblityForFixedItem(aBuilder, item)) {
 86220:       itemVisible.And(GetDisplayPortBounds(aBuilder, item), bounds);
 69752:     } else {
 33368:       itemVisible.And(*aVisibleRegion, bounds);
 69752:     }
 33368:     item->mVisibleRect = itemVisible.GetBounds();
 33368: 
 69802:     if (item->ComputeVisibility(aBuilder, aVisibleRegion, aAllowVisibleRegionExpansion)) {
 80486:       anyVisible = true;
 97420:       nsRegion opaque = TreatAsOpaque(item, aBuilder);
 34210:       // Subtract opaque item from the visible region
 69802:       aBuilder->SubtractFromVisibleRegion(aVisibleRegion, opaque);
 97420:       if (aBuilder->NeedToForceTransparentSurfaceForItem(item) ||
 97420:           (list && list->NeedsTransparentSurface())) {
 97420:         forceTransparentSurface = true;
 97420:       }
     1:     }
 47763:     AppendToBottom(item);
     1:   }
 31544: 
 51633:   mIsOpaque = !aVisibleRegion->Intersects(mVisibleRect);
 56101:   mForceTransparentSurface = forceTransparentSurface;
 33368: #ifdef DEBUG
 80486:   mDidComputeVisibility = true;
 33368: #endif
 47763:   return anyVisible;
     1: }
     1: 
 42246: void nsDisplayList::PaintRoot(nsDisplayListBuilder* aBuilder,
 68481:                               nsRenderingContext* aCtx,
108991:                               uint32_t aFlags) const {
 96794:   SAMPLE_LABEL("nsDisplayList", "PaintRoot");
114042:   PaintForFrame(aBuilder, aCtx, aBuilder->RootReferenceFrame(), aFlags);
 42246: }
 42246: 
 38803: /**
 38803:  * We paint by executing a layer manager transaction, constructing a
 38803:  * single layer representing the display list, and then making it the
 38803:  * root of the layer manager, drawing into the ThebesLayers.
 38803:  */
 42246: void nsDisplayList::PaintForFrame(nsDisplayListBuilder* aBuilder,
 68481:                                   nsRenderingContext* aCtx,
 42246:                                   nsIFrame* aForFrame,
108991:                                   uint32_t aFlags) const {
 33368:   NS_ASSERTION(mDidComputeVisibility,
 33368:                "Must call ComputeVisibility before calling Paint");
 33368: 
 38805:   nsRefPtr<LayerManager> layerManager;
115313:   bool widgetTransaction = false;
 60857:   bool allowRetaining = false;
 60857:   bool doBeginTransaction = true;
115308:   nsIView *view = nullptr;
 38805:   if (aFlags & PAINT_USE_WIDGET_LAYERS) {
114042:     nsIFrame* rootReferenceFrame = aBuilder->RootReferenceFrame();
115308:     view = rootReferenceFrame->GetView();
114042:     NS_ASSERTION(rootReferenceFrame == nsLayoutUtils::GetDisplayRootFrame(rootReferenceFrame),
 38805:                  "Reference frame must be a display root for us to use the layer manager");
114042:     nsIWidget* window = rootReferenceFrame->GetNearestWidget();
 38805:     if (window) {
 55858:       layerManager = window->GetLayerManager(&allowRetaining);
 60857:       if (layerManager) {
 60857:         doBeginTransaction = !(aFlags & PAINT_EXISTING_TRANSACTION);
115313:         widgetTransaction = true;
 47738:       }
 38805:     }
 38805:   }
 38805:   if (!layerManager) {
 38805:     if (!aCtx) {
 38805:       NS_WARNING("Nowhere to paint into");
 38805:       return;
 38805:     }
 47767:     layerManager = new BasicLayerManager();
 38805:   }
 38805: 
119787:   // Store the existing layer builder to reinstate it on return.
119787:   FrameLayerBuilder *oldBuilder = layerManager->GetLayerBuilder();
119787: 
105568:   FrameLayerBuilder *layerBuilder = new FrameLayerBuilder();
108884:   layerBuilder->Init(aBuilder, layerManager);
105568: 
 47739:   if (aFlags & PAINT_FLUSH_LAYERS) {
 47739:     FrameLayerBuilder::InvalidateAllLayers(layerManager);
 47739:   }
 47739: 
 60857:   if (doBeginTransaction) {
 38805:     if (aCtx) {
 38803:       layerManager->BeginTransactionWithTarget(aCtx->ThebesContext());
 38805:     } else {
 38805:       layerManager->BeginTransaction();
 38805:     }
 60857:   }
118640:   if (widgetTransaction) {
105568:     layerBuilder->DidBeginRetainedLayerTransaction(layerManager);
 60857:   }
 38803: 
 72231:   nsPresContext* presContext = aForFrame->PresContext();
 72231:   nsIPresShell* presShell = presContext->GetPresShell();
 72231: 
115308:   NotifySubDocInvalidationFunc computeInvalidFunc =
115308:     presContext->MayHavePaintEventListenerInSubDocument() ? nsPresContext::NotifySubDocInvalidation : 0;
115308:   bool computeInvalidRect = (computeInvalidFunc ||
123614:                              !layerManager->IsCompositingCheap()) &&
115308:                             widgetTransaction;
115308: 
115308:   nsAutoPtr<LayerProperties> props(computeInvalidRect ? 
115308:                                      LayerProperties::CloneFrom(layerManager->GetRoot()) : 
115308:                                      nullptr);
115308: 
 72231:   nsDisplayItem::ContainerParameters containerParameters
 72231:     (presShell->GetXResolution(), presShell->GetYResolution());
105568:   nsRefPtr<ContainerLayer> root = layerBuilder->
106838:     BuildContainerLayerFor(aBuilder, layerManager, aForFrame, nullptr, *this,
106838:                            containerParameters, nullptr);
105568: 
115308:   if (widgetTransaction) {
115304:     aForFrame->ClearInvalidationStateBits();
115308:   }
115304: 
105568:   if (!root) {
119787:     layerManager->SetUserData(&gLayerManagerLayerBuilder, oldBuilder);
 38803:     return;
105568:   }
 72231:   // Root is being scaled up by the X/Y resolution. Scale it back down.
107388:   root->SetPostScale(1.0f/containerParameters.mXScale,
106915:                      1.0f/containerParameters.mYScale);
 54080: 
 60443:   ViewID id = presContext->IsRootContentDocument() ? FrameMetrics::ROOT_SCROLL_ID
 60443:                                                    : FrameMetrics::NULL_SCROLL_ID;
 42246: 
 63413:   nsIFrame* rootScrollFrame = presShell->GetRootScrollFrame();
123809:   nsRect displayport, criticalDisplayport;
 63414:   bool usingDisplayport = false;
123809:   bool usingCriticalDisplayport = false;
 63413:   if (rootScrollFrame) {
 63413:     nsIContent* content = rootScrollFrame->GetContent();
 63413:     if (content) {
 63414:       usingDisplayport = nsLayoutUtils::GetDisplayPort(content, &displayport);
123809:       usingCriticalDisplayport =
123809:         nsLayoutUtils::GetCriticalDisplayPort(content, &criticalDisplayport);
 63413:     }
 63413:   }
109009: 
109009:   bool mayHaveTouchListeners = false;
109009:   if (presShell) {
109009:     nsIDocument* document = presShell->GetDocument();
109009:     if (document) {
109009:       nsCOMPtr<nsPIDOMWindow> innerWin(document->GetInnerWindow());
109009:       if (innerWin) {
109009:         mayHaveTouchListeners = innerWin->HasTouchEventListeners();
109009:       }
109009:     }
109009:   }
109009: 
115456:   nsRect viewport(aBuilder->ToReferenceFrame(aForFrame), aForFrame->GetSize());
115456: 
 63414:   RecordFrameMetrics(aForFrame, rootScrollFrame,
115456:                      root, mVisibleRect, viewport,
123809:                      (usingDisplayport ? &displayport : nullptr),
123809:                      (usingCriticalDisplayport ? &criticalDisplayport : nullptr),
123809:                      id, containerParameters, mayHaveTouchListeners);
 80777:   if (usingDisplayport &&
 80777:       !(root->GetContentFlags() & Layer::CONTENT_OPAQUE)) {
 80777:     // See bug 693938, attachment 567017
 80777:     NS_WARNING("We don't support transparent content with displayports, force it to be opqaue");
 80777:     root->SetContentFlags(Layer::CONTENT_OPAQUE);
 80777:   }
 54080: 
 38803:   layerManager->SetRoot(root);
115307:   layerBuilder->WillEndTransaction();
106096:   bool temp = aBuilder->SetIsCompositingCheap(layerManager->IsCompositingCheap());
 42593:   layerManager->EndTransaction(FrameLayerBuilder::DrawThebesLayer,
108188:                                aBuilder, (aFlags & PAINT_NO_COMPOSITE) ? LayerManager::END_NO_COMPOSITE : LayerManager::END_DEFAULT);
106096:   aBuilder->SetIsCompositingCheap(temp);
115307:   layerBuilder->DidEndTransaction();
 38803: 
121651:   nsIntRegion invalid;
115308:   if (props) {
115308:     invalid = props->ComputeDifferences(root, computeInvalidFunc);
115315:   } else if (widgetTransaction) {
115315:     LayerProperties::ClearInvalidations(root);
115308:   }
115308: 
115308:   if (view) {
115308:     if (props) {
115308:       if (!invalid.IsEmpty()) {
121651:         nsIntRect bounds = invalid.GetBounds();
121651:         nsRect rect(presContext->DevPixelsToAppUnits(bounds.x),
121651:                     presContext->DevPixelsToAppUnits(bounds.y),
121651:                     presContext->DevPixelsToAppUnits(bounds.width),
121651:                     presContext->DevPixelsToAppUnits(bounds.height));
115308:         view->GetViewManager()->InvalidateViewNoSuppression(view, rect);
121651:         presContext->NotifyInvalidation(bounds, 0);
115308:       }
115308:     } else {
115308:       view->GetViewManager()->InvalidateView(view);
115308:     }
115308:   }
115308: 
 47739:   if (aFlags & PAINT_FLUSH_LAYERS) {
 47739:     FrameLayerBuilder::InvalidateAllLayers(layerManager);
 47739:   }
 47739: 
119787:   layerManager->SetUserData(&gLayerManagerLayerBuilder, oldBuilder);
     1: }
 38803: 
108991: uint32_t nsDisplayList::Count() const {
108991:   uint32_t count = 0;
     1:   for (nsDisplayItem* i = GetBottom(); i; i = i->GetAbove()) {
     1:     ++count;
     1:   }
     1:   return count;
     1: }
     1: 
     1: nsDisplayItem* nsDisplayList::RemoveBottom() {
     1:   nsDisplayItem* item = mSentinel.mAbove;
     1:   if (!item)
106838:     return nullptr;
     1:   mSentinel.mAbove = item->mAbove;
     1:   if (item == mTop) {
     1:     // must have been the only item
     1:     mTop = &mSentinel;
     1:   }
106838:   item->mAbove = nullptr;
     1:   return item;
     1: }
     1: 
     1: void nsDisplayList::DeleteAll() {
     1:   nsDisplayItem* item;
106838:   while ((item = RemoveBottom()) != nullptr) {
     1:     item->~nsDisplayItem();
     1:   }
     1: }
     1: 
 79445: static bool
 58577: GetMouseThrough(const nsIFrame* aFrame)
 58577: {
 58577:   if (!aFrame->IsBoxFrame())
 80486:     return false;
 58577: 
 58577:   const nsIFrame* frame = aFrame;
 58577:   while (frame) {
 58577:     if (frame->GetStateBits() & NS_FRAME_MOUSE_THROUGH_ALWAYS) {
 80486:       return true;
 58577:     } else if (frame->GetStateBits() & NS_FRAME_MOUSE_THROUGH_NEVER) {
 80486:       return false;
 58577:     }
 58577:     frame = frame->GetParentBox();
 58577:   }
 80486:   return false;
 58577: }
 58577: 
 79926: // A list of frames, and their z depth. Used for sorting
 79926: // the results of hit testing.
 79926: struct FramesWithDepth
 79926: {
 79926:   FramesWithDepth(float aDepth) :
 79926:     mDepth(aDepth)
 79926:   {}
 79926: 
 79926:   bool operator<(const FramesWithDepth& aOther) const {
 79926:     if (mDepth != aOther.mDepth) {
 79926:       // We want to sort so that the shallowest item (highest depth value) is first
 79926:       return mDepth > aOther.mDepth;
 79926:     }
 79926:     return this < &aOther;
 79926:   }
 79926:   bool operator==(const FramesWithDepth& aOther) const {
 79926:     return this == &aOther;
 79926:   }
 79926: 
 79926:   float mDepth;
 79926:   nsTArray<nsIFrame*> mFrames;
 79926: };
 79926: 
 79926: // Sort the frames by depth and then moves all the contained frames to the destination
 79926: void FlushFramesArray(nsTArray<FramesWithDepth>& aSource, nsTArray<nsIFrame*>* aDest)
 79926: {
 79926:   if (aSource.IsEmpty()) {
 79926:     return;
 79926:   }
 79926:   aSource.Sort();
108991:   uint32_t length = aSource.Length();
108991:   for (uint32_t i = 0; i < length; i++) {
 79926:     aDest->MoveElementsFrom(aSource[i].mFrames);
 79926:   }
 79926:   aSource.Clear();
 79926: }
 79926: 
 40570: void nsDisplayList::HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
 40570:                             nsDisplayItem::HitTestState* aState,
 40570:                             nsTArray<nsIFrame*> *aOutFrames) const {
108991:   int32_t itemBufferStart = aState->mItemBuffer.Length();
     1:   nsDisplayItem* item;
     1:   for (item = GetBottom(); item; item = item->GetAbove()) {
  9799:     aState->mItemBuffer.AppendElement(item);
     1:   }
 79926:   nsAutoTArray<FramesWithDepth, 16> temp;
108991:   for (int32_t i = aState->mItemBuffer.Length() - 1; i >= itemBufferStart; --i) {
  9799:     // Pop element off the end of the buffer. We want to shorten the buffer
  9799:     // so that recursive calls to HitTest have more buffer space.
  9799:     item = aState->mItemBuffer[i];
  9799:     aState->mItemBuffer.SetLength(i);
  9799: 
 95051:     bool snap;
 95051:     if (aRect.Intersects(item->GetBounds(aBuilder, &snap))) {
 78688:       nsAutoTArray<nsIFrame*, 16> outFrames;
 40570:       item->HitTest(aBuilder, aRect, aState, &outFrames);
 40570: 
 79926:       // For 3d transforms with preserve-3d we add hit frames into the temp list
 79926:       // so we can sort them later, otherwise we add them directly to the output list.
 79926:       nsTArray<nsIFrame*> *writeFrames = aOutFrames;
 79926:       if (item->GetType() == nsDisplayItem::TYPE_TRANSFORM &&
 79926:           item->GetUnderlyingFrame()->Preserves3D()) {
 80242:         if (outFrames.Length()) {
 79926:           nsDisplayTransform *transform = static_cast<nsDisplayTransform*>(item);
 79926:           nsPoint point = aRect.TopLeft();
 79926:           // A 1x1 rect means a point, otherwise use the center of the rect
 79926:           if (aRect.width != 1 || aRect.height != 1) {
 79926:             point = aRect.Center();
 79926:           }
 79926:           temp.AppendElement(FramesWithDepth(transform->GetHitDepthAtPoint(point)));
 79926:           writeFrames = &temp[temp.Length() - 1].mFrames;
 80242:         }
 79926:       } else {
 79926:         // We may have just finished a run of consecutive preserve-3d transforms,
 79926:         // so flush these into the destination array before processing our frame list.
 79926:         FlushFramesArray(temp, aOutFrames);
 79926:       }
 79926: 
108991:       for (uint32_t j = 0; j < outFrames.Length(); j++) {
 40570:         nsIFrame *f = outFrames.ElementAt(j);
 32021:         // Handle the XUL 'mousethrough' feature and 'pointer-events'.
 58577:         if (!GetMouseThrough(f) &&
120808:             f->GetStyleVisibility()->GetEffectivePointerEvents(f) != NS_STYLE_POINTER_EVENTS_NONE) {
 79926:           writeFrames->AppendElement(f);
     1:         }
     1:       }
     1:     }
  9799:   }
 79926:   // Clear any remaining preserve-3d transforms.
 79926:   FlushFramesArray(temp, aOutFrames);
108991:   NS_ASSERTION(aState->mItemBuffer.Length() == uint32_t(itemBufferStart),
  9799:                "How did we forget to pop some elements?");
     1: }
     1: 
108991: static void Sort(nsDisplayList* aList, int32_t aCount, nsDisplayList::SortLEQ aCmp,
     1:                  void* aClosure) {
     1:   if (aCount < 2)
     1:     return;
     1: 
     1:   nsDisplayList list1;
     1:   nsDisplayList list2;
     1:   int i;
108991:   int32_t half = aCount/2;
 79445:   bool sorted = true;
106838:   nsDisplayItem* prev = nullptr;
     1:   for (i = 0; i < aCount; ++i) {
     1:     nsDisplayItem* item = aList->RemoveBottom();
     1:     (i < half ? &list1 : &list2)->AppendToTop(item);
     1:     if (sorted && prev && !aCmp(prev, item, aClosure)) {
 80486:       sorted = false;
     1:     }
     1:     prev = item;
     1:   }
     1:   if (sorted) {
     1:     aList->AppendToTop(&list1);
     1:     aList->AppendToTop(&list2);
     1:     return;
     1:   }
     1: 
     1:   Sort(&list1, half, aCmp, aClosure);
     1:   Sort(&list2, aCount - half, aCmp, aClosure);
     1: 
     1:   for (i = 0; i < aCount; ++i) {
     1:     if (list1.GetBottom() &&
     1:         (!list2.GetBottom() ||
     1:          aCmp(list1.GetBottom(), list2.GetBottom(), aClosure))) {
     1:       aList->AppendToTop(list1.RemoveBottom());
     1:     } else {
     1:       aList->AppendToTop(list2.RemoveBottom());
     1:     }
     1:   }
     1: }
     1: 
 79445: static bool IsContentLEQ(nsDisplayItem* aItem1, nsDisplayItem* aItem2,
     1:                            void* aClosure) {
     1:   // These GetUnderlyingFrame calls return non-null because we're only used
     1:   // in sorting
     1:   return nsLayoutUtils::CompareTreePosition(
     1:       aItem1->GetUnderlyingFrame()->GetContent(),
     1:       aItem2->GetUnderlyingFrame()->GetContent(),
  3233:       static_cast<nsIContent*>(aClosure)) <= 0;
     1: }
     1: 
 79445: static bool IsZOrderLEQ(nsDisplayItem* aItem1, nsDisplayItem* aItem2,
     1:                           void* aClosure) {
     1:   // These GetUnderlyingFrame calls return non-null because we're only used
 40129:   // in sorting.  Note that we can't just take the difference of the two
 40129:   // z-indices here, because that might overflow a 32-bit int.
108991:   int32_t index1 = nsLayoutUtils::GetZIndex(aItem1->GetUnderlyingFrame());
108991:   int32_t index2 = nsLayoutUtils::GetZIndex(aItem2->GetUnderlyingFrame());
106140:   return index1 <= index2;
     1: }
     1: 
     1: void nsDisplayList::ExplodeAnonymousChildLists(nsDisplayListBuilder* aBuilder) {
     1:   // See if there's anything to do
 79445:   bool anyAnonymousItems = false;
     1:   nsDisplayItem* i;
106838:   for (i = GetBottom(); i != nullptr; i = i->GetAbove()) {
     1:     if (!i->GetUnderlyingFrame()) {
 80486:       anyAnonymousItems = true;
     1:       break;
     1:     }
     1:   }
     1:   if (!anyAnonymousItems)
     1:     return;
     1: 
     1:   nsDisplayList tmp;
106838:   while ((i = RemoveBottom()) != nullptr) {
     1:     if (i->GetUnderlyingFrame()) {
     1:       tmp.AppendToTop(i);
     1:     } else {
120809:       nsDisplayList* list = i->GetSameCoordinateSystemChildren();
     1:       NS_ASSERTION(list, "leaf items can't be anonymous");
     1:       list->ExplodeAnonymousChildLists(aBuilder);
     1:       nsDisplayItem* j;
106838:       while ((j = list->RemoveBottom()) != nullptr) {
  3233:         tmp.AppendToTop(static_cast<nsDisplayWrapList*>(i)->
     1:             WrapWithClone(aBuilder, j));
     1:       }
     1:       i->~nsDisplayItem();
     1:     }
     1:   }
     1: 
     1:   AppendToTop(&tmp);
     1: }
     1: 
     1: void nsDisplayList::SortByZOrder(nsDisplayListBuilder* aBuilder,
     1:                                  nsIContent* aCommonAncestor) {
     1:   Sort(aBuilder, IsZOrderLEQ, aCommonAncestor);
     1: }
     1: 
     1: void nsDisplayList::SortByContentOrder(nsDisplayListBuilder* aBuilder,
     1:                                        nsIContent* aCommonAncestor) {
     1:   Sort(aBuilder, IsContentLEQ, aCommonAncestor);
     1: }
     1: 
     1: void nsDisplayList::Sort(nsDisplayListBuilder* aBuilder,
     1:                          SortLEQ aCmp, void* aClosure) {
     1:   ExplodeAnonymousChildLists(aBuilder);
     1:   ::Sort(this, Count(), aCmp, aClosure);
     1: }
     1: 
123904: /* static */ bool
123904: nsDisplayItem::ForceActiveLayers()
123904: {
123904:   static bool sForce = false;
123904:   static bool sForceCached = false;
123904: 
123904:   if (!sForceCached) {
123904:     Preferences::AddBoolVarCache(&sForce, "layers.force-active", false);
123904:     sForceCached = true;
123904:   }
123904: 
123904:   return sForce;
123904: }
123904: 
123904: bool
123904: nsDisplayItem::RecomputeVisibility(nsDisplayListBuilder* aBuilder,
 47736:                                    nsRegion* aVisibleRegion) {
 95051:   bool snap;
 95051:   nsRect bounds = GetBounds(aBuilder, &snap);
 47736: 
 47736:   nsRegion itemVisible;
 86220:   if (ForceVisiblityForFixedItem(aBuilder, this)) {
 86220:     itemVisible.And(GetDisplayPortBounds(aBuilder, this), bounds);
 69752:   } else {
 47736:     itemVisible.And(*aVisibleRegion, bounds);
 69752:   }
 47736:   mVisibleRect = itemVisible.GetBounds();
 47736: 
 62700:   // When we recompute visibility within layers we don't need to
 62700:   // expand the visible region for content behind plugins (the plugin
 62700:   // is not in the layer).
 69802:   if (!ComputeVisibility(aBuilder, aVisibleRegion, nsRect()))
 80486:     return false;
 47736: 
 97420:   nsRegion opaque = TreatAsOpaque(this, aBuilder);
 59825:   aBuilder->SubtractFromVisibleRegion(aVisibleRegion, opaque);
 80486:   return true;
 47736: }
 47736: 
 69786: nsRect
 95051: nsDisplaySolidColor::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap)
 69786: {
 95051:   *aSnap = true;
 95051:   return mBounds;
 69786: }
 69786: 
 69786: void
 69786: nsDisplaySolidColor::Paint(nsDisplayListBuilder* aBuilder,
 69786:                            nsRenderingContext* aCtx)
 69786: {
 27834:   aCtx->SetColor(mColor);
 33368:   aCtx->FillRect(mVisibleRect);
 27834: }
 27834: 
 48165: static void
 60289: RegisterThemeGeometry(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
 48165: {
 48165:   nsIFrame* displayRoot = nsLayoutUtils::GetDisplayRootFrame(aFrame);
 48165: 
 48165:   for (nsIFrame* f = aFrame; f; f = f->GetParent()) {
 48165:     // Bail out if we're in a transformed subtree
 48165:     if (f->IsTransformed())
 48165:       return;
 48165:     // Bail out if we're not in the displayRoot's document
 48165:     if (!f->GetParent() && f != displayRoot)
 48165:       return;
 48165:   }
 48165: 
 48165:   nsRect borderBox(aFrame->GetOffsetTo(displayRoot), aFrame->GetSize());
 60289:   aBuilder->RegisterThemeGeometry(aFrame->GetStyleDisplay()->mAppearance,
 60289:       borderBox.ToNearestPixels(aFrame->PresContext()->AppUnitsPerDevPixel()));
 48165: }
 48165: 
122084: nsDisplayBackgroundImage::nsDisplayBackgroundImage(nsDisplayListBuilder* aBuilder,
113850:                                                    nsIFrame* aFrame,
113851:                                                    uint32_t aLayer,
122079:                                                    bool aIsThemed,
122082:                                                    const nsStyleBackground* aBackgroundStyle)
122304:   : nsDisplayImageContainer(aBuilder, aFrame)
122079:   , mBackgroundStyle(aBackgroundStyle)
122079:   , mLayer(aLayer)
122079:   , mIsThemed(aIsThemed)
121988:   , mIsBottommostLayer(true)
 48165: {
122084:   MOZ_COUNT_CTOR(nsDisplayBackgroundImage);
122079: 
122079:   if (mIsThemed) {
121988:     const nsStyleDisplay* disp = mFrame->GetStyleDisplay();
122079:     mFrame->IsThemed(disp, &mThemeTransparency);
 60289:     // Perform necessary RegisterThemeGeometry
 67670:     if (disp->mAppearance == NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR ||
 67670:         disp->mAppearance == NS_THEME_TOOLBAR) {
 60289:       RegisterThemeGeometry(aBuilder, aFrame);
 97420:     } else if (disp->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS ||
 97420:                disp->mAppearance == NS_THEME_WIN_GLASS) {
 97420:       aBuilder->SetGlassDisplayItem(this);
 48165:     }
122079:   } else if (mBackgroundStyle) {
 67670:     // Set HasFixedItems if we construct a background-attachment:fixed item
122079:     if (mLayer != mBackgroundStyle->mImageCount - 1) {
113850:       mIsBottommostLayer = false;
113850:     }
113850: 
113850:     // Check if this background layer is attachment-fixed
125849:     if (mBackgroundStyle->mLayers[mLayer].mAttachment == NS_STYLE_BG_ATTACHMENT_FIXED) {
 67670:       aBuilder->SetHasFixedItems();
121988:     }
121988:   }
124185: 
124185:   mBounds = GetBoundsInternal();
121988: }
121988: 
122084: nsDisplayBackgroundImage::~nsDisplayBackgroundImage()
108747: {
108747: #ifdef NS_BUILD_REFCNT_LOGGING
122084:   MOZ_COUNT_DTOR(nsDisplayBackgroundImage);
108747: #endif
108747: }
108747: 
113850: /*static*/ nsresult
122084: nsDisplayBackgroundImage::AppendBackgroundItemsToTop(nsDisplayListBuilder* aBuilder,
113850:                                                      nsIFrame* aFrame,
113850:                                                      nsDisplayList* aList,
122084:                                                      nsDisplayBackgroundImage** aBackground)
113850: {
121099:   nsStyleContext* bgSC = nullptr;
113850:   const nsStyleBackground* bg = nullptr;
113850:   nsPresContext* presContext = aFrame->PresContext();
122079:   bool isThemed = aFrame->IsThemed();
122079:   if (!isThemed &&
113850:       nsCSSRendering::FindBackground(presContext, aFrame, &bgSC)) {
113850:     bg = bgSC->GetStyleBackground();
113850:   }
113850: 
121099:   bool drawBackgroundColor = false;
121099:   nscolor color;
121099:   if (!nsCSSRendering::IsCanvasFrame(aFrame) && bg) {
121099:     bool drawBackgroundImage;
121099:     color =
121099:       nsCSSRendering::DetermineBackgroundColor(presContext, bgSC, aFrame,
121099:                                                drawBackgroundImage, drawBackgroundColor);
121099:   }
121099: 
124327:   // Even if we don't actually have a background color to paint, we still need
124327:   // to create the item because it's used for hit testing.
121099:   aList->AppendNewToTop(
122079:       new (aBuilder) nsDisplayBackgroundColor(aBuilder, aFrame, bg,
121099:                                               drawBackgroundColor ? color : NS_RGBA(0, 0, 0, 0)));
121099: 
125849:   if (isThemed) {
125849:     nsDisplayBackgroundImage* bgItem =
125849:       new (aBuilder) nsDisplayBackgroundImage(aBuilder, aFrame, 0, isThemed, nullptr);
125849:     nsresult rv = aList->AppendNewToTop(bgItem);
125849:     if (rv != NS_OK) {
125849:       return rv;
125849:     }
126612:     if (aBackground) {
125849:       *aBackground = bgItem;
126612:     }
125849:     return NS_OK;
125849:   }
125849: 
125849:   if (!bg) {
125849:     return NS_OK;
125849:   }
125849:  
113850:   // Passing bg == nullptr in this macro will result in one iteration with
113850:   // i = 0.
113850:   bool backgroundSet = !aBackground;
113850:   NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, bg) {
125849:     if (bg->mLayers[i].mImage.IsEmpty()) {
125849:       continue;
125849:     }
122084:     nsDisplayBackgroundImage* bgItem =
122084:       new (aBuilder) nsDisplayBackgroundImage(aBuilder, aFrame, i, isThemed, bg);
113850:     nsresult rv = aList->AppendNewToTop(bgItem);
113850:     if (rv != NS_OK) {
113850:       return rv;
113850:     }
113850:     if (!backgroundSet) {
113850:       *aBackground = bgItem;
113850:       backgroundSet = true;
113850:     }
113850:   }
113850: 
113850:   return NS_OK;
113850: }
113850: 
 55316: // Helper for RoundedRectIntersectsRect.
 79445: static bool
 55316: CheckCorner(nscoord aXOffset, nscoord aYOffset,
 55316:             nscoord aXRadius, nscoord aYRadius)
 55316: {
 55316:   NS_ABORT_IF_FALSE(aXOffset > 0 && aYOffset > 0,
 55316:                     "must not pass nonpositives to CheckCorner");
 55316:   NS_ABORT_IF_FALSE(aXRadius >= 0 && aYRadius >= 0,
 55316:                     "must not pass negatives to CheckCorner");
 55316: 
 55316:   // Avoid floating point math unless we're either (1) within the
 55316:   // quarter-ellipse area at the rounded corner or (2) outside the
 55316:   // rounding.
 55316:   if (aXOffset >= aXRadius || aYOffset >= aYRadius)
 80486:     return true;
 55316: 
 55316:   // Convert coordinates to a unit circle with (0,0) as the center of
 55316:   // curvature, and see if we're inside the circle or outside.
 55316:   float scaledX = float(aXRadius - aXOffset) / float(aXRadius);
 55316:   float scaledY = float(aYRadius - aYOffset) / float(aYRadius);
 55316:   return scaledX * scaledX + scaledY * scaledY < 1.0f;
 55316: }
 55316: 
 55316: 
 55316: /**
 55316:  * Return whether any part of aTestRect is inside of the rounded
 55316:  * rectangle formed by aBounds and aRadii (which are indexed by the
 55316:  * NS_CORNER_* constants in nsStyleConsts.h).
 55316:  *
 55316:  * See also RoundedRectContainsRect.
 55316:  */
 79445: static bool
 55316: RoundedRectIntersectsRect(const nsRect& aRoundedRect, nscoord aRadii[8],
 55316:                           const nsRect& aTestRect)
 55316: {
 55316:   NS_ABORT_IF_FALSE(aTestRect.Intersects(aRoundedRect),
 55316:                     "we should already have tested basic rect intersection");
 55316: 
 55316:   // distances from this edge of aRoundedRect to opposite edge of aTestRect,
 55316:   // which we know are positive due to the Intersects check above.
 55316:   nsMargin insets;
 55316:   insets.top = aTestRect.YMost() - aRoundedRect.y;
 55316:   insets.right = aRoundedRect.XMost() - aTestRect.x;
 55316:   insets.bottom = aRoundedRect.YMost() - aTestRect.y;
 55316:   insets.left = aTestRect.XMost() - aRoundedRect.x;
 55316: 
 55316:   // Check whether the bottom-right corner of aTestRect is inside the
 55316:   // top left corner of aBounds when rounded by aRadii, etc.  If any
 55316:   // corner is not, then fail; otherwise succeed.
 55316:   return CheckCorner(insets.left, insets.top,
 55316:                      aRadii[NS_CORNER_TOP_LEFT_X],
 55316:                      aRadii[NS_CORNER_TOP_LEFT_Y]) &&
 55316:          CheckCorner(insets.right, insets.top,
 55316:                      aRadii[NS_CORNER_TOP_RIGHT_X],
 55316:                      aRadii[NS_CORNER_TOP_RIGHT_Y]) &&
 55316:          CheckCorner(insets.right, insets.bottom,
 55316:                      aRadii[NS_CORNER_BOTTOM_RIGHT_X],
 55316:                      aRadii[NS_CORNER_BOTTOM_RIGHT_Y]) &&
 55316:          CheckCorner(insets.left, insets.bottom,
 55316:                      aRadii[NS_CORNER_BOTTOM_LEFT_X],
 55316:                      aRadii[NS_CORNER_BOTTOM_LEFT_Y]);
 55316: }
 55316: 
 55316: // Check that the rounded border of aFrame, added to aToReferenceFrame,
 55316: // intersects aRect.  Assumes that the unrounded border has already
 55316: // been checked for intersection.
 79445: static bool
 55316: RoundedBorderIntersectsRect(nsIFrame* aFrame,
 55316:                             const nsPoint& aFrameToReferenceFrame,
 55316:                             const nsRect& aTestRect)
 55316: {
 60029:   if (!nsRect(aFrameToReferenceFrame, aFrame->GetSize()).Intersects(aTestRect))
 80486:     return false;
 60029: 
 55316:   nscoord radii[8];
 55316:   return !aFrame->GetBorderRadii(radii) ||
 55316:          RoundedRectIntersectsRect(nsRect(aFrameToReferenceFrame,
 55316:                                           aFrame->GetSize()),
 55316:                                    radii, aTestRect);
 55316: }
 55316: 
 27703: // Returns TRUE if aContainedRect is guaranteed to be contained in
 27703: // the rounded rect defined by aRoundedRect and aRadii. Complex cases are
 27703: // handled conservatively by returning FALSE in some situations where
 27703: // a more thorough analysis could return TRUE.
 55316: //
 55316: // See also RoundedRectIntersectsRect.
 79445: static bool RoundedRectContainsRect(const nsRect& aRoundedRect,
 27703:                                     const nscoord aRadii[8],
 27703:                                     const nsRect& aContainedRect) {
 59779:   nsRegion rgn = nsLayoutUtils::RoundedRectIntersectRect(aRoundedRect, aRadii, aContainedRect);
 59779:   return rgn.Contains(aContainedRect);
 27703: }
 27703: 
 97537: bool
122084: nsDisplayBackgroundImage::IsSingleFixedPositionImage(nsDisplayListBuilder* aBuilder,
122086:                                                      const nsRect& aClipRect,
122086:                                                      gfxRect* aDestRect)
106096: {
122079:   if (mIsThemed || !mBackgroundStyle)
106096:     return false;
106096: 
126100:   if (mBackgroundStyle->mLayers.Length() != 1)
126100:     return false;
126100: 
106096:   nsPresContext* presContext = mFrame->PresContext();
108991:   uint32_t flags = aBuilder->GetBackgroundPaintFlags();
122085:   nsRect borderArea = nsRect(ToReferenceFrame(), mFrame->GetSize());
122085:   const nsStyleBackground::Layer &layer = mBackgroundStyle->mLayers[mLayer];
106096: 
106096:   if (layer.mAttachment != NS_STYLE_BG_ATTACHMENT_FIXED)
106096:     return false;
106096: 
106096:   nsBackgroundLayerState state =
106096:     nsCSSRendering::PrepareBackgroundLayer(presContext,
106096:                                            mFrame,
106096:                                            flags,
106096:                                            borderArea,
106096:                                            aClipRect,
122085:                                            *mBackgroundStyle,
106096:                                            layer);
106096: 
106096:   nsImageRenderer* imageRenderer = &state.mImageRenderer;
106096:   // We only care about images here, not gradients.
106096:   if (!imageRenderer->IsRasterImage())
106096:     return false;
106096: 
108991:   int32_t appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
122086:   *aDestRect = nsLayoutUtils::RectToGfxRect(state.mFillArea, appUnitsPerDevPixel);
106096: 
106096:   return true;
106096: }
106096: 
106096: bool
124315: nsDisplayBackgroundImage::TryOptimizeToImageLayer(LayerManager* aManager,
124315:                                                   nsDisplayListBuilder* aBuilder)
 97537: {
122079:   if (mIsThemed || !mBackgroundStyle)
 97537:     return false;
 97537: 
 97537:   nsPresContext* presContext = mFrame->PresContext();
108991:   uint32_t flags = aBuilder->GetBackgroundPaintFlags();
122085:   nsRect borderArea = nsRect(ToReferenceFrame(), mFrame->GetSize());
122085:   const nsStyleBackground::Layer &layer = mBackgroundStyle->mLayers[mLayer];
 97537: 
 97537:   nsBackgroundLayerState state =
 97537:     nsCSSRendering::PrepareBackgroundLayer(presContext,
 97537:                                            mFrame,
 97537:                                            flags,
 97537:                                            borderArea,
 97537:                                            borderArea,
122085:                                            *mBackgroundStyle,
 97537:                                            layer);
 97537: 
 99013:   nsImageRenderer* imageRenderer = &state.mImageRenderer;
 97537:   // We only care about images here, not gradients.
122304:   if (!imageRenderer->IsRasterImage())
 99013:     return false;
 99013: 
124315:   nsRefPtr<ImageContainer> imageContainer = imageRenderer->GetContainer(aManager);
 99013:   // Image is not ready to be made into a layer yet
 99013:   if (!imageContainer)
 97537:     return false;
 97537: 
 97537:   // We currently can't handle tiled or partial backgrounds.
 97537:   if (!state.mDestArea.IsEqualEdges(state.mFillArea)) {
 97537:     return false;
 97537:   }
 97537: 
 97537:   // Sub-pixel alignment is hard, lets punt on that.
 97537:   if (state.mAnchor != nsPoint(0.0f, 0.0f)) {
 97537:     return false;
 97537:   }
 97537: 
108991:   int32_t appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
 97537:   mDestRect = nsLayoutUtils::RectToGfxRect(state.mDestArea, appUnitsPerDevPixel);
 99013:   mImageContainer = imageContainer;
 97537: 
 97537:   // Ok, we can turn this into a layer if needed.
 97537:   return true;
 97537: }
 97537: 
122304: already_AddRefed<ImageContainer>
124315: nsDisplayBackgroundImage::GetContainer(LayerManager* aManager,
124315:                                        nsDisplayListBuilder *aBuilder)
122304: {
124315:   if (!TryOptimizeToImageLayer(aManager, aBuilder)) {
122304:     return nullptr;
122304:   }
122304: 
122304:   nsRefPtr<ImageContainer> container = mImageContainer;
122304: 
122304:   return container.forget();
122304: }
122304: 
 97537: LayerState
122084: nsDisplayBackgroundImage::GetLayerState(nsDisplayListBuilder* aBuilder,
 97537:                                         LayerManager* aManager,
 97537:                                         const FrameLayerBuilder::ContainerParameters& aParameters)
 97537: {
 97537:   if (!aManager->IsCompositingCheap() ||
 97537:       !nsLayoutUtils::GPUImageScalingEnabled() ||
124315:       !TryOptimizeToImageLayer(aManager, aBuilder)) {
 97537:     return LAYER_NONE;
 97537:   }
 97537: 
 97537:   gfxSize imageSize = mImageContainer->GetCurrentSize();
 97537:   NS_ASSERTION(imageSize.width != 0 && imageSize.height != 0, "Invalid image size!");
 97537: 
 97537:   gfxRect destRect = mDestRect;
 97537: 
 97537:   destRect.width *= aParameters.mXScale;
 97537:   destRect.height *= aParameters.mYScale;
 97537: 
 97537:   // Calculate the scaling factor for the frame.
 97537:   gfxSize scale = gfxSize(destRect.width / imageSize.width, destRect.height / imageSize.height);
 97537: 
 97537:   // If we are not scaling at all, no point in separating this into a layer.
 97537:   if (scale.width == 1.0f && scale.height == 1.0f) {
124315:     return LAYER_NONE;
 97537:   }
 97537: 
 97537:   // If the target size is pretty small, no point in using a layer.
 97537:   if (destRect.width * destRect.height < 64 * 64) {
124315:     return LAYER_NONE;
 97537:   }
 97537: 
 97537:   return LAYER_ACTIVE;
 97537: }
 97537: 
 97537: already_AddRefed<Layer>
122084: nsDisplayBackgroundImage::BuildLayer(nsDisplayListBuilder* aBuilder,
 97537:                                      LayerManager* aManager,
 97537:                                      const ContainerParameters& aParameters)
 97537: {
 97537:   nsRefPtr<ImageLayer> layer = aManager->CreateImageLayer();
 97537:   layer->SetContainer(mImageContainer);
122304:   ConfigureLayer(layer, aParameters.mOffset);
 97537:   return layer.forget();
 97537: }
 97537: 
 97537: void
122304: nsDisplayBackgroundImage::ConfigureLayer(ImageLayer* aLayer, const nsIntPoint& aOffset)
 97537: {
 97537:   aLayer->SetFilter(nsLayoutUtils::GetGraphicsFilterForFrame(mFrame));
 97537: 
 97537:   gfxIntSize imageSize = mImageContainer->GetCurrentSize();
 97537:   NS_ASSERTION(imageSize.width != 0 && imageSize.height != 0, "Invalid image size!");
 97537: 
 97537:   gfxMatrix transform;
122304:   transform.Translate(mDestRect.TopLeft() + aOffset);
 97537:   transform.Scale(mDestRect.width/imageSize.width,
 97537:                   mDestRect.height/imageSize.height);
106915:   aLayer->SetBaseTransform(gfx3DMatrix::From2D(transform));
 97537:   aLayer->SetVisibleRegion(nsIntRect(0, 0, imageSize.width, imageSize.height));
 97537: }
 97537: 
 55316: void
122084: nsDisplayBackgroundImage::HitTest(nsDisplayListBuilder* aBuilder,
 55316:                                   const nsRect& aRect,
 55316:                                   HitTestState* aState,
 55316:                                   nsTArray<nsIFrame*> *aOutFrames)
 55316: {
 75047:   if (mIsThemed) {
 75047:     // For theme backgrounds, assume that any point in our border rect is a hit.
 75047:     if (!nsRect(ToReferenceFrame(), mFrame->GetSize()).Intersects(aRect))
 75047:       return;
 75047:   } else {
 75047:     if (!RoundedBorderIntersectsRect(mFrame, ToReferenceFrame(), aRect)) {
 55316:       // aRect doesn't intersect our border-radius curve.
 55316:       return;
 55316:     }
 75047:   }
 55316: 
 55316:   aOutFrames->AppendElement(mFrame);
 55316: }
 55316: 
 79445: bool
122084: nsDisplayBackgroundImage::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                             nsRegion* aVisibleRegion,
 69802:                                             const nsRect& aAllowVisibleRegionExpansion)
 47754: {
 61411:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
 69802:                                         aAllowVisibleRegionExpansion)) {
 80486:     return false;
 61411:   }
 47763: 
 47754:   // Return false if the background was propagated away from this
 47754:   // frame. We don't want this display item to show up and confuse
 47754:   // anything.
122079:   return mIsThemed || mBackgroundStyle;
 47754: }
 47754: 
121099: /* static */ nsRegion
122084: nsDisplayBackgroundImage::GetInsideClipRegion(nsDisplayItem* aItem,
121099:                                               nsPresContext* aPresContext,
108991:                                               uint8_t aClip, const nsRect& aRect,
 95051:                                               bool* aSnap)
 59780: {
 59780:   nsRegion result;
 59780:   if (aRect.IsEmpty())
 59780:     return result;
 59780: 
121099:   nsIFrame *frame = aItem->GetUnderlyingFrame();
121099: 
 59780:   nscoord radii[8];
 59780:   nsRect clipRect;
 79445:   bool haveRadii;
 59780:   switch (aClip) {
 59780:   case NS_STYLE_BG_CLIP_BORDER:
121099:     haveRadii = frame->GetBorderRadii(radii);
121099:     clipRect = nsRect(aItem->ToReferenceFrame(), frame->GetSize());
 59780:     break;
 59780:   case NS_STYLE_BG_CLIP_PADDING:
121099:     haveRadii = frame->GetPaddingBoxBorderRadii(radii);
121099:     clipRect = frame->GetPaddingRect() - frame->GetPosition() + aItem->ToReferenceFrame();
 59780:     break;
 59780:   case NS_STYLE_BG_CLIP_CONTENT:
121099:     haveRadii = frame->GetContentBoxBorderRadii(radii);
121099:     clipRect = frame->GetContentRect() - frame->GetPosition() + aItem->ToReferenceFrame();
 59780:     break;
 59780:   default:
 59780:     NS_NOTREACHED("Unknown clip type");
 59780:     return result;
 59780:   }
 59780: 
 59780:   if (haveRadii) {
 95051:     *aSnap = false;
 95051:     result = nsLayoutUtils::RoundedRectIntersectRect(clipRect, radii, aRect);
 59780:   } else {
 98137:     result = clipRect.Intersect(aRect);
 59780:   }
 59780:   return result;
 59780: }
 59780: 
 59780: nsRegion
122084: nsDisplayBackgroundImage::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
 97420:                                           bool* aSnap) {
 59779:   nsRegion result;
 95051:   *aSnap = false;
     1:   // theme background overrides any other background
 56101:   if (mIsThemed) {
 59779:     if (mThemeTransparency == nsITheme::eOpaque) {
115303:       result = nsRect(ToReferenceFrame(), mFrame->GetSize());
 59779:     }
 59779:     return result;
 56101:   }
     1: 
122079:   if (!mBackgroundStyle)
 59779:     return result;
122079: 
 27153: 
 95051:   *aSnap = true;
 95051: 
 59780:   // For policies other than EACH_BOX, don't try to optimize here, since
 59780:   // this could easily lead to O(N^2) behavior inside InlineBackgroundData,
 59780:   // which expects frames to be sent to it in content order, not reverse
 59780:   // content order which we'll produce here.
 59780:   // Of course, if there's only one frame in the flow, it doesn't matter.
122079:   if (mBackgroundStyle->mBackgroundInlinePolicy == NS_STYLE_BG_INLINE_POLICY_EACH_BOX ||
 59780:       (!mFrame->GetPrevContinuation() && !mFrame->GetNextContinuation())) {
122079:     const nsStyleBackground::Layer& layer = mBackgroundStyle->mLayers[mLayer];
 59780:     if (layer.mImage.IsOpaque()) {
121099:       nsRect borderBox = nsRect(ToReferenceFrame(), mFrame->GetSize());
122079:       nsPresContext* presContext = mFrame->PresContext();
 59780:       nsRect r = nsCSSRendering::GetBackgroundLayerRect(presContext, mFrame,
122079:           borderBox, *mBackgroundStyle, layer);
122079:       result = GetInsideClipRegion(this, presContext, layer.mClip, r, aSnap);
 59779:     }
 59780:   }
 59780: 
 59779:   return result;
     1: }
     1: 
 79445: bool
122084: nsDisplayBackgroundImage::IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor) {
     1:   // theme background overrides any other background
 60675:   if (mIsThemed) {
 60675:     const nsStyleDisplay* disp = mFrame->GetStyleDisplay();
 60675:     if (disp->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS ||
 60675:         disp->mAppearance == NS_THEME_WIN_GLASS) {
 60675:       *aColor = NS_RGBA(0,0,0,0);
 80486:       return true;
 60675:     }
 80486:     return false;
 60675:   }
     1: 
122079:   if (!mBackgroundStyle) {
 42436:     *aColor = NS_RGBA(0,0,0,0);
 80486:     return true;
 42436:   }
 80486:   return false;
     1: }
     1: 
 79445: bool
122084: nsDisplayBackgroundImage::IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
 50392:                                                          nsIFrame* aFrame)
     1: {
 47777:   // theme background overrides any other background and is never fixed
 47777:   if (mIsThemed)
 80486:     return false;
 47777: 
122079:   if (!mBackgroundStyle)
 80486:     return false;
122079:   if (!mBackgroundStyle->HasFixedBackground())
 80486:     return false;
     1: 
 50392:   // If aFrame is mFrame or an ancestor in this document, and aFrame is
 50392:   // not the viewport frame, then moving aFrame will move mFrame
 50392:   // relative to the viewport, so our fixed-pos background will change.
 50392:   return aFrame->GetParent() &&
 50392:     (aFrame == mFrame ||
 50392:      nsLayoutUtils::IsProperAncestorFrame(aFrame, mFrame));
     1: }
     1: 
122080: nsRect
122084: nsDisplayBackgroundImage::GetPositioningArea()
122080: {
122080:   if (!mBackgroundStyle) {
122080:     return nsRect();
122080:   }
122080:   nsIFrame* attachedToFrame;
122080:   return nsCSSRendering::ComputeBackgroundPositioningArea(
122080:       mFrame->PresContext(), mFrame,
122080:       nsRect(ToReferenceFrame(), mFrame->GetSize()),
122080:       *mBackgroundStyle, mBackgroundStyle->mLayers[mLayer],
122080:       &attachedToFrame) + ToReferenceFrame();
122080: }
122080: 
 79445: bool
122084: nsDisplayBackgroundImage::RenderingMightDependOnPositioningAreaSizeChange()
115303: {
115303:   // theme background overrides any other background and we don't know what to do here
115303:   if (mIsThemed)
115303:     return true;
115303: 
122079:   if (!mBackgroundStyle)
115303:     return false;
122079: 
122080:   nscoord radii[8];
122080:   if (mFrame->GetBorderRadii(radii)) {
122080:     // A change in the size of the positioning area might change the position
122080:     // of the rounded corners.
122080:     return true;
122080:   }
122080: 
122079:   const nsStyleBackground::Layer &layer = mBackgroundStyle->mLayers[mLayer];
122080:   if (layer.RenderingMightDependOnPositioningAreaSizeChange()) {
121969:     return true;
121969:   }
115303:   return false;
115303: }
115303: 
121099: static void CheckForBorderItem(nsDisplayItem *aItem, uint32_t& aFlags)
121099: {
121099:   nsDisplayItem* nextItem = aItem->GetAbove();
121099:   while (nextItem && nextItem->GetType() == nsDisplayItem::TYPE_BACKGROUND) {
121099:     nextItem = nextItem->GetAbove();
121099:   }
121099:   if (nextItem && 
121099:       nextItem->GetUnderlyingFrame() == aItem->GetUnderlyingFrame() &&
121099:       nextItem->GetType() == nsDisplayItem::TYPE_BORDER) {
121099:     aFlags |= nsCSSRendering::PAINTBG_WILL_PAINT_BORDER;
121099:   }
121099: }
121099: 
     1: void
122084: nsDisplayBackgroundImage::Paint(nsDisplayListBuilder* aBuilder,
 68481:                                 nsRenderingContext* aCtx) {
125848:   PaintInternal(aBuilder, aCtx, mVisibleRect, nullptr);
125848: }
125848: 
125848: void
125848: nsDisplayBackgroundImage::PaintInternal(nsDisplayListBuilder* aBuilder,
125848:                                         nsRenderingContext* aCtx, const nsRect& aBounds,
125848:                                         nsRect* aClipRect) {
 51261:   nsPoint offset = ToReferenceFrame();
108991:   uint32_t flags = aBuilder->GetBackgroundPaintFlags();
121099:   CheckForBorderItem(this, flags);
125848: 
   238:   nsCSSRendering::PaintBackground(mFrame->PresContext(), *aCtx, mFrame,
125848:                                   aBounds,
 33368:                                   nsRect(offset, mFrame->GetSize()),
125848:                                   flags, aClipRect, mLayer);
125848: 
     1: }
     1: 
122084: void nsDisplayBackgroundImage::ComputeInvalidationRegion(nsDisplayListBuilder* aBuilder,
115303:                                                          const nsDisplayItemGeometry* aGeometry,
115303:                                                          nsRegion* aInvalidRegion)
115303: {
122080:   if (!mBackgroundStyle) {
122080:     return;
122080:   }
122080: 
121988:   const nsDisplayBackgroundGeometry* geometry = static_cast<const nsDisplayBackgroundGeometry*>(aGeometry);
122080: 
122080:   bool snap;
122080:   nsRect bounds = GetBounds(aBuilder, &snap);
122080:   nsRect positioningArea = GetPositioningArea();
122080:   if (positioningArea.TopLeft() != geometry->mPositioningArea.TopLeft() ||
122080:       (positioningArea.Size() != geometry->mPositioningArea.Size() &&
122080:        RenderingMightDependOnPositioningAreaSizeChange())) {
122080:     // Positioning area changed in a way that could cause everything to change,
122080:     // so invalidate everything (both old and new painting areas).
122080:     aInvalidRegion->Or(bounds, geometry->mBounds);
121969:     return;
121969:   }
122080:   if (!bounds.IsEqualInterior(geometry->mBounds)) {
122080:     // Positioning area is unchanged, so invalidate just the change in the
122080:     // painting area.
122080:     aInvalidRegion->Xor(bounds, geometry->mBounds);
115303:   }
115303: }
115303: 
     1: nsRect
122084: nsDisplayBackgroundImage::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
121099:   *aSnap = true;
124185:   return mBounds;
124185: }
124185: 
124185: nsRect
124185: nsDisplayBackgroundImage::GetBoundsInternal() {
121099:   nsPresContext* presContext = mFrame->PresContext();
121099: 
121099:   if (mIsThemed) {
119984:     nsRect r(nsPoint(0,0), mFrame->GetSize());
 51266:     presContext->GetTheme()->
 51266:         GetWidgetOverflow(presContext->DeviceContext(), mFrame,
 51266:                           mFrame->GetStyleDisplay()->mAppearance, &r);
115303: #ifdef XP_MACOSX
115303:     // Bug 748219
115303:     r.Inflate(mFrame->PresContext()->AppUnitsPerDevPixel());
115303: #endif
121099: 
 95051:     return r + ToReferenceFrame();
  9369:   }
  9369: 
122079:   if (!mBackgroundStyle) {
121099:     return nsRect();
121099:   }
121099: 
121099:   nsRect borderBox = nsRect(ToReferenceFrame(), mFrame->GetSize());
125848:   if (mFrame->GetType() == nsGkAtoms::canvasFrame) {
125848:     nsCanvasFrame* frame = static_cast<nsCanvasFrame*>(mFrame);
125848:     borderBox = frame->CanvasArea() + ToReferenceFrame();
125848:   }
122079:   const nsStyleBackground::Layer& layer = mBackgroundStyle->mLayers[mLayer];
121099:   return nsCSSRendering::GetBackgroundLayerRect(presContext, mFrame,
122079:                                                 borderBox, *mBackgroundStyle, layer);
121099: }
121099: 
113850: uint32_t
122084: nsDisplayBackgroundImage::GetPerFrameKey()
113850: {
113850:   return (mLayer << nsDisplayItem::TYPE_BITS) |
113850:     nsDisplayItem::GetPerFrameKey();
113850: }
113850: 
121099: void
121099: nsDisplayBackgroundColor::Paint(nsDisplayListBuilder* aBuilder,
121099:                                 nsRenderingContext* aCtx) 
121099: {
121099:   if (mColor == NS_RGBA(0, 0, 0, 0)) {
121099:     return;
121099:   }
121099: 
121099:   nsPoint offset = ToReferenceFrame();
121099:   uint32_t flags = aBuilder->GetBackgroundPaintFlags();
121099:   CheckForBorderItem(this, flags);
121099:   nsCSSRendering::PaintBackgroundColor(mFrame->PresContext(), *aCtx, mFrame,
121099:                                        mVisibleRect,
121099:                                        nsRect(offset, mFrame->GetSize()),
121099:                                        flags);
121099: }
121099: 
121099: nsRegion
121099: nsDisplayBackgroundColor::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
121099:                                           bool* aSnap) 
121099: {
121099:   if (NS_GET_A(mColor) != 255) {
121099:     return nsRegion();
121099:   }
121099: 
122079:   if (!mBackgroundStyle)
122079:     return nsRegion();
122079: 
122079:   *aSnap = true;
122079: 
122079:   const nsStyleBackground::Layer& bottomLayer = mBackgroundStyle->BottomLayer();
122079:   nsRect borderBox = nsRect(ToReferenceFrame(), mFrame->GetSize());
121988:   nsPresContext* presContext = mFrame->PresContext();
122084:   return nsDisplayBackgroundImage::GetInsideClipRegion(this, presContext, bottomLayer.mClip, borderBox, aSnap);
121099: }
121099: 
121099: bool
121099: nsDisplayBackgroundColor::IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor) 
121099: {
121099:   *aColor = mColor;
122079: 
122079:   if (!mBackgroundStyle)
121099:     return true;
121099: 
121099:   return (!nsLayoutUtils::HasNonZeroCorner(mFrame->GetStyleBorder()->mBorderRadius) &&
122079:           mBackgroundStyle->BottomLayer().mClip == NS_STYLE_BG_CLIP_BORDER);
121099: }
121099: 
121099: void
121099: nsDisplayBackgroundColor::HitTest(nsDisplayListBuilder* aBuilder,
121099:                                   const nsRect& aRect,
121099:                                   HitTestState* aState,
121099:                                   nsTArray<nsIFrame*> *aOutFrames)
121099: {
121099:   if (!RoundedBorderIntersectsRect(mFrame, ToReferenceFrame(), aRect)) {
121099:     // aRect doesn't intersect our border-radius curve.
121099:     return;
121099:   }
121099: 
121099:   aOutFrames->AppendElement(mFrame);
121099: }
121099: 
  9369: nsRect
 95051: nsDisplayOutline::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
 95051:   *aSnap = false;
 57625:   return mFrame->GetVisualOverflowRectRelativeToSelf() + ToReferenceFrame();
     1: }
     1: 
     1: void
     1: nsDisplayOutline::Paint(nsDisplayListBuilder* aBuilder,
 68481:                         nsRenderingContext* aCtx) {
     1:   // TODO join outlines together
 51261:   nsPoint offset = ToReferenceFrame();
   238:   nsCSSRendering::PaintOutline(mFrame->PresContext(), *aCtx, mFrame,
 33368:                                mVisibleRect,
 33368:                                nsRect(offset, mFrame->GetSize()),
 16424:                                mFrame->GetStyleContext());
     1: }
     1: 
 79445: bool
 33368: nsDisplayOutline::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                     nsRegion* aVisibleRegion,
 69802:                                     const nsRect& aAllowVisibleRegionExpansion) {
 61411:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
 69802:                                         aAllowVisibleRegionExpansion)) {
 80486:     return false;
 61411:   }
     1: 
     1:   const nsStyleOutline* outline = mFrame->GetStyleOutline();
 51261:   nsRect borderBox(ToReferenceFrame(), mFrame->GetSize());
 34210:   if (borderBox.Contains(aVisibleRegion->GetBounds()) &&
 20039:       !nsLayoutUtils::HasNonZeroCorner(outline->mOutlineRadius)) {
 19205:     if (outline->mOutlineOffset >= 0) {
     1:       // the visible region is entirely inside the border-rect, and the outline
     1:       // isn't rendered inside the border-rect, so the outline is not visible
 80486:       return false;
     1:     }
     1:   }
     1: 
 80486:   return true;
     1: }
     1: 
     1: void
 55316: nsDisplayEventReceiver::HitTest(nsDisplayListBuilder* aBuilder,
 55316:                                 const nsRect& aRect,
 55316:                                 HitTestState* aState,
 55316:                                 nsTArray<nsIFrame*> *aOutFrames)
 55316: {
 55316:   if (!RoundedBorderIntersectsRect(mFrame, ToReferenceFrame(), aRect)) {
 55316:     // aRect doesn't intersect our border-radius curve.
 55316:     return;
 55316:   }
 55316: 
 55316:   aOutFrames->AppendElement(mFrame);
 55316: }
 55316: 
 55316: void
     1: nsDisplayCaret::Paint(nsDisplayListBuilder* aBuilder,
 68481:                       nsRenderingContext* aCtx) {
     1:   // Note: Because we exist, we know that the caret is visible, so we don't
     1:   // need to check for the caret's visibility.
 51261:   mCaret->PaintCaret(aBuilder, aCtx, mFrame, ToReferenceFrame());
     1: }
     1: 
 79445: bool
 33368: nsDisplayBorder::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                    nsRegion* aVisibleRegion,
 69802:                                    const nsRect& aAllowVisibleRegionExpansion) {
 61411:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
 69802:                                         aAllowVisibleRegionExpansion)) {
 80486:     return false;
 61411:   }
     1: 
  6376:   nsRect paddingRect = mFrame->GetPaddingRect() - mFrame->GetPosition() +
 51261:     ToReferenceFrame();
 15992:   const nsStyleBorder *styleBorder;
  6376:   if (paddingRect.Contains(aVisibleRegion->GetBounds()) &&
 15992:       !(styleBorder = mFrame->GetStyleBorder())->IsBorderImageLoaded() &&
 20039:       !nsLayoutUtils::HasNonZeroCorner(styleBorder->mBorderRadius)) {
     1:     // the visible region is entirely inside the content rect, and no part
     1:     // of the border is rendered inside the content rect, so we are not
     1:     // visible
 15992:     // Skip this if there's a border-image (which draws a background
 15992:     // too) or if there is a border-radius (which makes the border draw
 15992:     // further in).
 80486:     return false;
     1:   }
     1: 
 80486:   return true;
     1: }
     1:   
115303: nsDisplayItemGeometry* 
115303: nsDisplayBorder::AllocateGeometry(nsDisplayListBuilder* aBuilder)
115303: {
115303:   return new nsDisplayBorderGeometry(this, aBuilder);
115303: }
115303: 
115303: void
115303: nsDisplayBorder::ComputeInvalidationRegion(nsDisplayListBuilder* aBuilder,
115303:                                            const nsDisplayItemGeometry* aGeometry,
115303:                                            nsRegion* aInvalidRegion)
115303: {
115303:   const nsDisplayBorderGeometry* geometry = static_cast<const nsDisplayBorderGeometry*>(aGeometry);
115303:   bool snap;
115303:   if (!geometry->mBounds.IsEqualInterior(GetBounds(aBuilder, &snap)) ||
115303:       !geometry->mContentRect.IsEqualInterior(GetContentRect())) {
115303:     // We can probably get away with only invalidating the difference
115303:     // between the border and padding rects, but the XUL ui at least
115303:     // is apparently painting a background with this?
115303:     aInvalidRegion->Or(GetBounds(aBuilder, &snap), geometry->mBounds);
115303:   }
115303: }
115303:   
     1: void
     1: nsDisplayBorder::Paint(nsDisplayListBuilder* aBuilder,
 68481:                        nsRenderingContext* aCtx) {
 51261:   nsPoint offset = ToReferenceFrame();
   238:   nsCSSRendering::PaintBorder(mFrame->PresContext(), *aCtx, mFrame,
 33368:                               mVisibleRect,
 33368:                               nsRect(offset, mFrame->GetSize()),
 16424:                               mFrame->GetStyleContext(),
 16424:                               mFrame->GetSkipSides());
     1: }
     1: 
 60027: nsRect
 95051: nsDisplayBorder::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap)
 60027: {
 86084:   nsRect borderBounds(ToReferenceFrame(), mFrame->GetSize());
 86084:   borderBounds.Inflate(mFrame->GetStyleBorder()->GetImageOutset());
 95051:   *aSnap = true;
 95051:   return borderBounds;
 60027: }
 60027: 
 35288: // Given a region, compute a conservative approximation to it as a list
 35288: // of rectangles that aren't vertically adjacent (i.e., vertically
 35288: // adjacent or overlapping rectangles are combined).
 35288: // Right now this is only approximate, some vertically overlapping rectangles
 35288: // aren't guaranteed to be combined.
 35288: static void
 35288: ComputeDisjointRectangles(const nsRegion& aRegion,
 35288:                           nsTArray<nsRect>* aRects) {
 35288:   nscoord accumulationMargin = nsPresContext::CSSPixelsToAppUnits(25);
 35288:   nsRect accumulated;
 35288:   nsRegionRectIterator iter(aRegion);
 80486:   while (true) {
 35288:     const nsRect* r = iter.Next();
 35288:     if (r && !accumulated.IsEmpty() &&
 35288:         accumulated.YMost() >= r->y - accumulationMargin) {
 35288:       accumulated.UnionRect(accumulated, *r);
 35288:       continue;
 35288:     }
 35288: 
 35288:     if (!accumulated.IsEmpty()) {
 35288:       aRects->AppendElement(accumulated);
 68639:       accumulated.SetEmpty();
 35288:     }
 35288: 
 35288:     if (!r)
 35288:       break;
 35288: 
 35288:     accumulated = *r;
 35288:   }
 35288: }
 35288: 
 15700: void
 24818: nsDisplayBoxShadowOuter::Paint(nsDisplayListBuilder* aBuilder,
 68481:                                nsRenderingContext* aCtx) {
 51261:   nsPoint offset = ToReferenceFrame();
 35288:   nsRect borderRect = nsRect(offset, mFrame->GetSize());
 35288:   nsPresContext* presContext = mFrame->PresContext();
 35288:   nsAutoTArray<nsRect,10> rects;
 35288:   ComputeDisjointRectangles(mVisibleRegion, &rects);
 35288: 
 98057:   SAMPLE_LABEL("nsDisplayBoxShadowOuter", "Paint");
108991:   for (uint32_t i = 0; i < rects.Length(); ++i) {
 35288:     aCtx->PushState();
 68485:     aCtx->IntersectClip(rects[i]);
 35288:     nsCSSRendering::PaintBoxShadowOuter(presContext, *aCtx, mFrame,
 35288:                                         borderRect, rects[i]);
 35288:     aCtx->PopState();
 35288:   }
 15700: }
 15700: 
 15700: nsRect
 95051: nsDisplayBoxShadowOuter::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
 95051:   *aSnap = false;
125546:   return mBounds;
125546: }
125546: 
125546: nsRect
125546: nsDisplayBoxShadowOuter::GetBoundsInternal() {
125546:   return nsLayoutUtils::GetBoxShadowRectForFrame(mFrame, mFrame->GetSize()) +
125546:          ToReferenceFrame();
 15700: }
 15700: 
 79445: bool
 33368: nsDisplayBoxShadowOuter::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                            nsRegion* aVisibleRegion,
 69802:                                            const nsRect& aAllowVisibleRegionExpansion) {
 61411:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
 69802:                                         aAllowVisibleRegionExpansion)) {
 80486:     return false;
 61411:   }
 24439: 
 35288:   // Store the actual visible region
 35288:   mVisibleRegion.And(*aVisibleRegion, mVisibleRect);
 35288: 
 51261:   nsPoint origin = ToReferenceFrame();
 34210:   nsRect visibleBounds = aVisibleRegion->GetBounds();
 27703:   nsRect frameRect(origin, mFrame->GetSize());
 27703:   if (!frameRect.Contains(visibleBounds))
 80486:     return true;
 27703: 
 24439:   // the visible region is entirely inside the border-rect, and box shadows
 24439:   // never render within the border-rect (unless there's a border radius).
 27703:   nscoord twipsRadii[8];
 79445:   bool hasBorderRadii = mFrame->GetBorderRadii(twipsRadii);
 27703:   if (!hasBorderRadii)
 80486:     return false;
 24439: 
 27703:   return !RoundedRectContainsRect(frameRect, twipsRadii, visibleBounds);
 24439: }
 24439: 
 24818: void
 24818: nsDisplayBoxShadowInner::Paint(nsDisplayListBuilder* aBuilder,
 68481:                                nsRenderingContext* aCtx) {
 51261:   nsPoint offset = ToReferenceFrame();
 35288:   nsRect borderRect = nsRect(offset, mFrame->GetSize());
 35288:   nsPresContext* presContext = mFrame->PresContext();
 35288:   nsAutoTArray<nsRect,10> rects;
 35288:   ComputeDisjointRectangles(mVisibleRegion, &rects);
 35288: 
 98057:   SAMPLE_LABEL("nsDisplayBoxShadowInner", "Paint");
108991:   for (uint32_t i = 0; i < rects.Length(); ++i) {
 35288:     aCtx->PushState();
 68485:     aCtx->IntersectClip(rects[i]);
 35288:     nsCSSRendering::PaintBoxShadowInner(presContext, *aCtx, mFrame,
 35288:                                         borderRect, rects[i]);
 35288:     aCtx->PopState();
 35288:   }
 35288: }
 35288: 
 79445: bool
 35288: nsDisplayBoxShadowInner::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                            nsRegion* aVisibleRegion,
 69802:                                            const nsRect& aAllowVisibleRegionExpansion) {
 61411:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
 69802:                                         aAllowVisibleRegionExpansion)) {
 80486:     return false;
 61411:   }
 35288: 
 35288:   // Store the actual visible region
 35288:   mVisibleRegion.And(*aVisibleRegion, mVisibleRect);
 80486:   return true;
 24818: }
 24818: 
120128: nsIFrame *GetTransformRootFrame(nsIFrame* aFrame)
120128: {
120128:   nsIFrame *parent = nsLayoutUtils::GetCrossDocParentFrame(aFrame);
120128:   while (parent && parent->Preserves3DChildren()) {
120128:     parent = nsLayoutUtils::GetCrossDocParentFrame(parent);
120128:   }
120128:   return parent;
120128: }
120128: 
 51260: nsDisplayWrapList::nsDisplayWrapList(nsDisplayListBuilder* aBuilder,
 51260:                                      nsIFrame* aFrame, nsDisplayList* aList)
 51260:   : nsDisplayItem(aBuilder, aFrame) {
     1:   mList.AppendToTop(aList);
 95693:   UpdateBounds(aBuilder);
120128: 
120128:   if (!aFrame || !aFrame->IsTransformed()) {
120128:     return;
120128:   }
120128: 
120128:   // If the frame is a preserve-3d parent, then we will create transforms
120128:   // inside this list afterwards (see WrapPreserve3DList in nsFrame.cpp).
120128:   // In this case we will always be outside of the transform, so share
120128:   // our parents reference frame.
120128:   if (aFrame->Preserves3DChildren()) {
120128:     mReferenceFrame = 
120128:       aBuilder->FindReferenceFrameFor(GetTransformRootFrame(aFrame));
120128:     mToReferenceFrame = aFrame->GetOffsetToCrossDoc(mReferenceFrame);
120128:     return;
120128:   }
120128: 
120128:   // If we're a transformed frame, then we need to find out if we're inside
120128:   // the nsDisplayTransform or outside of it. Frames inside the transform
120128:   // need mReferenceFrame == mFrame, outside needs the next ancestor
120128:   // reference frame.
120128:   // If we're inside the transform, then the nsDisplayItem constructor
120128:   // will have done the right thing.
120128:   // If we're outside the transform, then we should have only one child
120128:   // (since nsDisplayTransform wraps all actual content), and that child
120128:   // will have the correct reference frame set (since nsDisplayTransform
120128:   // handles this explictly).
120128:   //
120128:   // Preserve-3d can cause us to have multiple nsDisplayTransform
120128:   // children.
120128:   nsDisplayItem *i = mList.GetBottom();
120128:   if (i && (!i->GetAbove() || i->GetType() == TYPE_TRANSFORM) && 
120128:       i->GetUnderlyingFrame() == mFrame) {
120128:     mReferenceFrame = i->ReferenceFrame();
120128:     mToReferenceFrame = i->ToReferenceFrame();
120128:   }
     1: }
     1: 
 51260: nsDisplayWrapList::nsDisplayWrapList(nsDisplayListBuilder* aBuilder,
 51260:                                      nsIFrame* aFrame, nsDisplayItem* aItem)
 51260:   : nsDisplayItem(aBuilder, aFrame) {
     1:   mList.AppendToTop(aItem);
 95693:   UpdateBounds(aBuilder);
120128:   
120128:   if (!aFrame || !aFrame->IsTransformed()) {
120128:     return;
120128:   }
120128: 
120128:   if (aFrame->Preserves3DChildren()) {
120128:     mReferenceFrame = 
120128:       aBuilder->FindReferenceFrameFor(GetTransformRootFrame(aFrame));
120128:     mToReferenceFrame = aFrame->GetOffsetToCrossDoc(mReferenceFrame);
120128:     return;
120128:   }
120128: 
120128:   // See the previous nsDisplayWrapList constructor
120128:   if (aItem->GetUnderlyingFrame() == aFrame) {
120128:     mReferenceFrame = aItem->ReferenceFrame();
120128:     mToReferenceFrame = aItem->ToReferenceFrame();
120128:   }
     1: }
     1: 
 69189: nsDisplayWrapList::nsDisplayWrapList(nsDisplayListBuilder* aBuilder,
 95645:                                      nsIFrame* aFrame, nsDisplayItem* aItem,
114042:                                      const nsIFrame* aReferenceFrame,
 95645:                                      const nsPoint& aToReferenceFrame)
114042:   : nsDisplayItem(aBuilder, aFrame, aReferenceFrame, aToReferenceFrame) {
 95645:   mList.AppendToTop(aItem);
 95645:   mBounds = mList.GetBounds(aBuilder);
 69189: }
 69189: 
     1: nsDisplayWrapList::~nsDisplayWrapList() {
     1:   mList.DeleteAll();
     1: }
     1: 
 40570: void
 40570: nsDisplayWrapList::HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
 40570:                            HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames) {
 40570:   mList.HitTest(aBuilder, aRect, aState, aOutFrames);
     1: }
     1: 
     1: nsRect
 95051: nsDisplayWrapList::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
 95051:   *aSnap = false;
 95348:   return mBounds;
     1: }
     1: 
 79445: bool
 33368: nsDisplayWrapList::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                      nsRegion* aVisibleRegion,
 69802:                                      const nsRect& aAllowVisibleRegionExpansion) {
120128:   return mList.ComputeVisibilityForSublist(aBuilder, this, aVisibleRegion,
 61411:                                            mVisibleRect,
 69802:                                            aAllowVisibleRegionExpansion);
     1: }
     1: 
 59779: nsRegion
 59779: nsDisplayWrapList::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
 97420:                                    bool* aSnap) {
 95051:   *aSnap = false;
 59779:   nsRegion result;
 59779:   if (mList.IsOpaque()) {
 95348:     // Everything within GetBounds that's visible is opaque.
 95051:     result = GetBounds(aBuilder, aSnap);
 59779:   }
 59779:   return result;
     1: }
     1: 
 79445: bool nsDisplayWrapList::IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor) {
 80486:   // We could try to do something but let's conservatively just return false.
 80486:   return false;
     1: }
     1: 
 79445: bool nsDisplayWrapList::IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
 50392:                                                          nsIFrame* aFrame) {
 14202:   NS_WARNING("nsDisplayWrapList::IsVaryingRelativeToMovingFrame called unexpectedly");
 80486:   // We could try to do something but let's conservatively just return true.
 80486:   return true;
     1: }
     1: 
     1: void nsDisplayWrapList::Paint(nsDisplayListBuilder* aBuilder,
 68481:                               nsRenderingContext* aCtx) {
 38803:   NS_ERROR("nsDisplayWrapList should have been flattened away for painting");
     1: }
     1: 
121847: LayerState
121847: nsDisplayWrapList::RequiredLayerStateForChildren(nsDisplayListBuilder* aBuilder,
 47751:                                                  LayerManager* aManager,
 97534:                                                  const ContainerParameters& aParameters,
 47751:                                                  const nsDisplayList& aList,
 47751:                                                  nsIFrame* aActiveScrolledRoot) {
121847:   LayerState result = LAYER_INACTIVE;
 47751:   for (nsDisplayItem* i = aList.GetBottom(); i; i = i->GetAbove()) {
 47751:     nsIFrame* f = i->GetUnderlyingFrame();
 47751:     if (f) {
 47751:       nsIFrame* activeScrolledRoot =
106838:         nsLayoutUtils::GetActiveScrolledRootFor(f, nullptr);
121847:       if (activeScrolledRoot != aActiveScrolledRoot && result == LAYER_INACTIVE)
121847:         result = LAYER_ACTIVE;
 47751:     }
 47751: 
 97534:     LayerState state = i->GetLayerState(aBuilder, aManager, aParameters);
121847:     if ((state == LAYER_ACTIVE || state == LAYER_ACTIVE_FORCE) && (state > result))
121847:       result = state;
 47751:     if (state == LAYER_NONE) {
120809:       nsDisplayList* list = i->GetSameCoordinateSystemChildren();
121847:       if (list) {
121847:         LayerState childState = RequiredLayerStateForChildren(aBuilder, aManager, aParameters, *list, aActiveScrolledRoot);
121847:         if (childState > result) {
121847:           result = childState;
121847:         }
121847:       }
121847:     }
121847:   }
121847:   return result;
 47751: }
 47751: 
 59781: nsRect nsDisplayWrapList::GetComponentAlphaBounds(nsDisplayListBuilder* aBuilder)
 55291: {
 59781:   nsRect bounds;
 55291:   for (nsDisplayItem* i = mList.GetBottom(); i; i = i->GetAbove()) {
 59781:     bounds.UnionRect(bounds, i->GetComponentAlphaBounds(aBuilder));
 55291:   }
 59781:   return bounds;
 55291: }
 55291: 
     1: static nsresult
     1: WrapDisplayList(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
     1:                 nsDisplayList* aList, nsDisplayWrapper* aWrapper) {
 50393:   if (!aList->GetTop())
     1:     return NS_OK;
     1:   nsDisplayItem* item = aWrapper->WrapList(aBuilder, aFrame, aList);
     1:   if (!item)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   // aList was emptied
     1:   aList->AppendToTop(item);
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: WrapEachDisplayItem(nsDisplayListBuilder* aBuilder,
     1:                     nsDisplayList* aList, nsDisplayWrapper* aWrapper) {
     1:   nsDisplayList newList;
     1:   nsDisplayItem* item;
     1:   while ((item = aList->RemoveBottom())) {
     1:     item = aWrapper->WrapItem(aBuilder, item);
     1:     if (!item)
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     newList.AppendToTop(item);
     1:   }
     1:   // aList was emptied
     1:   aList->AppendToTop(&newList);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult nsDisplayWrapper::WrapLists(nsDisplayListBuilder* aBuilder,
     1:     nsIFrame* aFrame, const nsDisplayListSet& aIn, const nsDisplayListSet& aOut)
     1: {
     1:   nsresult rv = WrapListsInPlace(aBuilder, aFrame, aIn);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (&aOut == &aIn)
     1:     return NS_OK;
     1:   aOut.BorderBackground()->AppendToTop(aIn.BorderBackground());
     1:   aOut.BlockBorderBackgrounds()->AppendToTop(aIn.BlockBorderBackgrounds());
     1:   aOut.Floats()->AppendToTop(aIn.Floats());
     1:   aOut.Content()->AppendToTop(aIn.Content());
     1:   aOut.PositionedDescendants()->AppendToTop(aIn.PositionedDescendants());
     1:   aOut.Outlines()->AppendToTop(aIn.Outlines());
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult nsDisplayWrapper::WrapListsInPlace(nsDisplayListBuilder* aBuilder,
     1:     nsIFrame* aFrame, const nsDisplayListSet& aLists)
     1: {
     1:   nsresult rv;
     1:   if (WrapBorderBackground()) {
     1:     // Our border-backgrounds are in-flow
     1:     rv = WrapDisplayList(aBuilder, aFrame, aLists.BorderBackground(), this);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1:   // Our block border-backgrounds are in-flow
     1:   rv = WrapDisplayList(aBuilder, aFrame, aLists.BlockBorderBackgrounds(), this);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   // The floats are not in flow
     1:   rv = WrapEachDisplayItem(aBuilder, aLists.Floats(), this);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   // Our child content is in flow
     1:   rv = WrapDisplayList(aBuilder, aFrame, aLists.Content(), this);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   // The positioned descendants may not be in-flow
     1:   rv = WrapEachDisplayItem(aBuilder, aLists.PositionedDescendants(), this);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   // The outlines may not be in-flow
     1:   return WrapEachDisplayItem(aBuilder, aLists.Outlines(), this);
     1: }
     1: 
 51260: nsDisplayOpacity::nsDisplayOpacity(nsDisplayListBuilder* aBuilder,
 51260:                                    nsIFrame* aFrame, nsDisplayList* aList)
 51260:     : nsDisplayWrapList(aBuilder, aFrame, aList) {
     1:   MOZ_COUNT_CTOR(nsDisplayOpacity);
     1: }
     1: 
     1: #ifdef NS_BUILD_REFCNT_LOGGING
     1: nsDisplayOpacity::~nsDisplayOpacity() {
     1:   MOZ_COUNT_DTOR(nsDisplayOpacity);
     1: }
     1: #endif
     1: 
 59779: nsRegion nsDisplayOpacity::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
 97420:                                            bool* aSnap) {
 95051:   *aSnap = false;
     1:   // We are never opaque, if our opacity was < 1 then we wouldn't have
     1:   // been created.
 59779:   return nsRegion();
     1: }
     1: 
 38803: // nsDisplayOpacity uses layers for rendering
 38803: already_AddRefed<Layer>
 38803: nsDisplayOpacity::BuildLayer(nsDisplayListBuilder* aBuilder,
 72230:                              LayerManager* aManager,
 72230:                              const ContainerParameters& aContainerParameters) {
123917:   if (mFrame->GetStyleDisplay()->mOpacity == 0 && mFrame->GetContent() &&
123917:       !nsLayoutUtils::HasAnimationsForCompositor(mFrame->GetContent(), eCSSProperty_opacity)) {
121952:     return nullptr;
121952:   }
108884:   nsRefPtr<Layer> container = aManager->GetLayerBuilder()->
 72230:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, mList,
106838:                            aContainerParameters, nullptr);
107003:   if (!container)
106838:     return nullptr;
     1: 
107003:   container->SetOpacity(mFrame->GetStyleDisplay()->mOpacity);
107567:   AddAnimationsAndTransitionsToLayer(container, aBuilder,
107567:                                      this, eCSSProperty_opacity);
107003:   return container.forget();
 38803: }
     1: 
 80904: /**
 80904:  * This doesn't take into account layer scaling --- the layer may be
 80904:  * rendered at a higher (or lower) resolution, affecting the retained layer
 80904:  * size --- but this should be good enough.
 80904:  */
 80904: static bool
 80904: IsItemTooSmallForActiveLayer(nsDisplayItem* aItem)
 80904: {
 80904:   nsIntRect visibleDevPixels = aItem->GetVisibleRect().ToOutsidePixels(
 80904:           aItem->GetUnderlyingFrame()->PresContext()->AppUnitsPerDevPixel());
 80904:   static const int MIN_ACTIVE_LAYER_SIZE_DEV_PIXELS = 16;
 80904:   return visibleDevPixels.Size() <
 80904:     nsIntSize(MIN_ACTIVE_LAYER_SIZE_DEV_PIXELS, MIN_ACTIVE_LAYER_SIZE_DEV_PIXELS);
 80904: }
 80904: 
 47751: nsDisplayItem::LayerState
 47751: nsDisplayOpacity::GetLayerState(nsDisplayListBuilder* aBuilder,
 97534:                                 LayerManager* aManager,
 97534:                                 const ContainerParameters& aParameters) {
 80904:   if (mFrame->AreLayersMarkedActive(nsChangeHint_UpdateOpacityLayer) &&
 80904:       !IsItemTooSmallForActiveLayer(this))
 47753:     return LAYER_ACTIVE;
107003:   if (mFrame->GetContent()) {
107005:     if (nsLayoutUtils::HasAnimationsForCompositor(mFrame->GetContent(),
107003:                                                   eCSSProperty_opacity)) {
107003:       return LAYER_ACTIVE;
107003:     }
107003:   }
 47751:   nsIFrame* activeScrolledRoot =
106838:     nsLayoutUtils::GetActiveScrolledRootFor(mFrame, nullptr);
121847:   return RequiredLayerStateForChildren(aBuilder, aManager, aParameters, mList, activeScrolledRoot);
 47751: }
 47751: 
 79445: bool
 69802: nsDisplayOpacity::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                     nsRegion* aVisibleRegion,
 69802:                                     const nsRect& aAllowVisibleRegionExpansion) {
     1:   // Our children are translucent so we should not allow them to subtract
     1:   // area from aVisibleRegion. We do need to find out what is visible under
     1:   // our children in the temporary compositing buffer, because if our children
     1:   // paint our entire bounds opaquely then we don't need an alpha channel in
     1:   // the temporary compositing buffer.
 95051:   bool snap;
 95051:   nsRect bounds = GetBounds(aBuilder, &snap);
 38803:   nsRegion visibleUnderChildren;
 38803:   visibleUnderChildren.And(*aVisibleRegion, bounds);
 98137:   nsRect allowExpansion = bounds.Intersect(aAllowVisibleRegionExpansion);
 38803:   return
 61411:     nsDisplayWrapList::ComputeVisibility(aBuilder, &visibleUnderChildren,
 69802:                                          allowExpansion);
     1: }
     1: 
 79445: bool nsDisplayOpacity::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem) {
     1:   if (aItem->GetType() != TYPE_OPACITY)
 80486:     return false;
     1:   // items for the same content element should be merged into a single
     1:   // compositing group
     1:   // aItem->GetUnderlyingFrame() returns non-null because it's nsDisplayOpacity
     1:   if (aItem->GetUnderlyingFrame()->GetContent() != mFrame->GetContent())
 80486:     return false;
 95566:   MergeFromTrackingMergedFrames(static_cast<nsDisplayOpacity*>(aItem));
 80486:   return true;
     1: }
     1: 
 51260: nsDisplayOwnLayer::nsDisplayOwnLayer(nsDisplayListBuilder* aBuilder,
115308:                                      nsIFrame* aFrame, nsDisplayList* aList,
115308:                                      uint32_t aFlags)
115308:     : nsDisplayWrapList(aBuilder, aFrame, aList)
115308:     , mFlags(aFlags) {
 47744:   MOZ_COUNT_CTOR(nsDisplayOwnLayer);
 47744: }
 47744: 
 47744: #ifdef NS_BUILD_REFCNT_LOGGING
 47744: nsDisplayOwnLayer::~nsDisplayOwnLayer() {
 47744:   MOZ_COUNT_DTOR(nsDisplayOwnLayer);
 47744: }
 47744: #endif
 47744: 
 47744: // nsDisplayOpacity uses layers for rendering
 47744: already_AddRefed<Layer>
 47744: nsDisplayOwnLayer::BuildLayer(nsDisplayListBuilder* aBuilder,
 72230:                               LayerManager* aManager,
 72230:                               const ContainerParameters& aContainerParameters) {
108884:   nsRefPtr<Layer> layer = aManager->GetLayerBuilder()->
 72230:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, mList,
106838:                            aContainerParameters, nullptr);
115308: 
115308:   if (mFlags & GENERATE_SUBDOC_INVALIDATIONS) {
115308:     ContainerLayerPresContext* pres = new ContainerLayerPresContext;
115308:     pres->mPresContext = mFrame->PresContext();
115308:     layer->SetUserData(&gNotifySubDocInvalidationData, pres);
115308:   }
 47744:   return layer.forget();
 47744: }
 47744: 
103084: nsDisplayFixedPosition::nsDisplayFixedPosition(nsDisplayListBuilder* aBuilder,
103084:                                                nsIFrame* aFrame,
106380:                                                nsIFrame* aFixedPosFrame,
103084:                                                nsDisplayList* aList)
106380:     : nsDisplayOwnLayer(aBuilder, aFrame, aList)
106380:     , mFixedPosFrame(aFixedPosFrame) {
103084:   MOZ_COUNT_CTOR(nsDisplayFixedPosition);
103084: }
103084: 
103084: #ifdef NS_BUILD_REFCNT_LOGGING
103084: nsDisplayFixedPosition::~nsDisplayFixedPosition() {
103084:   MOZ_COUNT_DTOR(nsDisplayFixedPosition);
103084: }
103084: #endif
103084: 
103084: already_AddRefed<Layer>
103084: nsDisplayFixedPosition::BuildLayer(nsDisplayListBuilder* aBuilder,
103084:                                    LayerManager* aManager,
103084:                                    const ContainerParameters& aContainerParameters) {
103084:   nsRefPtr<Layer> layer =
103084:     nsDisplayOwnLayer::BuildLayer(aBuilder, aManager, aContainerParameters);
103084: 
103084:   // Work out the anchor point for this fixed position layer. We assume that
103084:   // any positioning set (left/top/right/bottom) indicates that the
103084:   // corresponding side of its container should be the anchor point,
103084:   // defaulting to top-left.
106380:   nsIFrame* viewportFrame = mFixedPosFrame->GetParent();
103084:   nsPresContext *presContext = viewportFrame->PresContext();
103084: 
103084:   // Fixed position frames are reflowed into the scroll-port size if one has
103084:   // been set.
103084:   nsSize containingBlockSize = viewportFrame->GetSize();
103084:   if (presContext->PresShell()->IsScrollPositionClampingScrollPortSizeSet()) {
103084:     containingBlockSize = presContext->PresShell()->
103084:       GetScrollPositionClampingScrollPortSize();
103084:   }
103084: 
103084:   // Find out the rect of the viewport frame relative to the reference frame.
103084:   // This, in conjunction with the container scale, will correspond to the
103084:   // coordinate-space of the built layer.
103084:   float factor = presContext->AppUnitsPerDevPixel();
114042:   nsPoint origin = viewportFrame->GetOffsetToCrossDoc(ReferenceFrame());
103084:   gfxRect anchorRect(NSAppUnitsToFloatPixels(origin.x, factor) *
103084:                        aContainerParameters.mXScale,
103084:                      NSAppUnitsToFloatPixels(origin.y, factor) *
103084:                        aContainerParameters.mYScale,
103084:                      NSAppUnitsToFloatPixels(containingBlockSize.width, factor) *
103084:                        aContainerParameters.mXScale,
103084:                      NSAppUnitsToFloatPixels(containingBlockSize.height, factor) *
103084:                        aContainerParameters.mYScale);
103084: 
103084:   gfxPoint anchor(anchorRect.x, anchorRect.y);
103084: 
106380:   const nsStylePosition* position = mFixedPosFrame->GetStylePosition();
103084:   if (position->mOffset.GetRightUnit() != eStyleUnit_Auto)
103084:     anchor.x = anchorRect.XMost();
103084:   if (position->mOffset.GetBottomUnit() != eStyleUnit_Auto)
103084:     anchor.y = anchorRect.YMost();
103084: 
103084:   layer->SetFixedPositionAnchor(anchor);
103084: 
103084:   return layer.forget();
103084: }
103084: 
108081: bool nsDisplayFixedPosition::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem) {
108081:   if (aItem->GetType() != TYPE_FIXED_POSITION)
108081:     return false;
108081:   // Items with the same fixed position frame can be merged.
108081:   nsDisplayFixedPosition* other = static_cast<nsDisplayFixedPosition*>(aItem);
108081:   if (other->mFixedPosFrame != mFixedPosFrame)
108081:     return false;
108081:   MergeFromTrackingMergedFrames(other);
108081:   return true;
108081: }
108081: 
 60447: nsDisplayScrollLayer::nsDisplayScrollLayer(nsDisplayListBuilder* aBuilder,
 60447:                                            nsDisplayList* aList,
 60447:                                            nsIFrame* aForFrame,
 69189:                                            nsIFrame* aScrolledFrame,
 69189:                                            nsIFrame* aScrollFrame)
 69189:   : nsDisplayWrapList(aBuilder, aForFrame, aList)
 69189:   , mScrollFrame(aScrollFrame)
 69189:   , mScrolledFrame(aScrolledFrame)
 60447: {
 60447: #ifdef NS_BUILD_REFCNT_LOGGING
 60466:   MOZ_COUNT_CTOR(nsDisplayScrollLayer);
 60447: #endif
 60447: 
 69189:   NS_ASSERTION(mScrolledFrame && mScrolledFrame->GetContent(),
 60447:                "Need a child frame with content");
 60447: }
 60447: 
 69189: nsDisplayScrollLayer::nsDisplayScrollLayer(nsDisplayListBuilder* aBuilder,
 69189:                                            nsDisplayItem* aItem,
 69189:                                            nsIFrame* aForFrame,
 69189:                                            nsIFrame* aScrolledFrame,
 69189:                                            nsIFrame* aScrollFrame)
 69189:   : nsDisplayWrapList(aBuilder, aForFrame, aItem)
 69189:   , mScrollFrame(aScrollFrame)
 69189:   , mScrolledFrame(aScrolledFrame)
 69189: {
 69189: #ifdef NS_BUILD_REFCNT_LOGGING
 69189:   MOZ_COUNT_CTOR(nsDisplayScrollLayer);
 69189: #endif
 69189: 
 69189:   NS_ASSERTION(mScrolledFrame && mScrolledFrame->GetContent(),
 69189:                "Need a child frame with content");
 69189: }
 69189: 
 69189: nsDisplayScrollLayer::nsDisplayScrollLayer(nsDisplayListBuilder* aBuilder,
 69189:                                            nsIFrame* aForFrame,
 69189:                                            nsIFrame* aScrolledFrame,
 69189:                                            nsIFrame* aScrollFrame)
 69189:   : nsDisplayWrapList(aBuilder, aForFrame)
 69189:   , mScrollFrame(aScrollFrame)
 69189:   , mScrolledFrame(aScrolledFrame)
 69189: {
 69189: #ifdef NS_BUILD_REFCNT_LOGGING
 69189:   MOZ_COUNT_CTOR(nsDisplayScrollLayer);
 69189: #endif
 69189: 
 69189:   NS_ASSERTION(mScrolledFrame && mScrolledFrame->GetContent(),
 69189:                "Need a child frame with content");
 69189: }
 69189: 
 69189: #ifdef NS_BUILD_REFCNT_LOGGING
 69189: nsDisplayScrollLayer::~nsDisplayScrollLayer()
 69189: {
 69189:   MOZ_COUNT_DTOR(nsDisplayScrollLayer);
 69189: }
 69189: #endif
 69189: 
 60447: already_AddRefed<Layer>
 60447: nsDisplayScrollLayer::BuildLayer(nsDisplayListBuilder* aBuilder,
 72230:                                  LayerManager* aManager,
 72230:                                  const ContainerParameters& aContainerParameters) {
108884:   nsRefPtr<ContainerLayer> layer = aManager->GetLayerBuilder()->
 72230:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, mList,
106838:                            aContainerParameters, nullptr);
 60447: 
 60447:   // Get the already set unique ID for scrolling this content remotely.
 60447:   // Or, if not set, generate a new ID.
 69189:   nsIContent* content = mScrolledFrame->GetContent();
 60450:   ViewID scrollId = nsLayoutUtils::FindIDFor(content);
 60447: 
102151:   nsRect viewport = mScrollFrame->GetRect() -
102151:                     mScrollFrame->GetPosition() +
114042:                     mScrollFrame->GetOffsetToCrossDoc(ReferenceFrame());
 60447: 
 63414:   bool usingDisplayport = false;
123809:   bool usingCriticalDisplayport = false;
123809:   nsRect displayport, criticalDisplayport;
102151:   if (content) {
 63414:     usingDisplayport = nsLayoutUtils::GetDisplayPort(content, &displayport);
123809:     usingCriticalDisplayport =
123809:       nsLayoutUtils::GetCriticalDisplayPort(content, &criticalDisplayport);
102151:   }
 69189:   RecordFrameMetrics(mScrolledFrame, mScrollFrame, layer, mVisibleRect, viewport,
123809:                      (usingDisplayport ? &displayport : nullptr),
123809:                      (usingCriticalDisplayport ? &criticalDisplayport : nullptr),
123809:                      scrollId, aContainerParameters, false);
 60447: 
 60447:   return layer.forget();
 60447: }
 60447: 
 79445: bool
 60447: nsDisplayScrollLayer::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                         nsRegion* aVisibleRegion,
 69802:                                         const nsRect& aAllowVisibleRegionExpansion)
 60447: {
 63414:   nsRect displayport;
 69189:   if (nsLayoutUtils::GetDisplayPort(mScrolledFrame->GetContent(), &displayport)) {
 60447:     // The visible region for the children may be much bigger than the hole we
 60447:     // are viewing the children from, so that the compositor process has enough
 60447:     // content to asynchronously pan while content is being refreshed.
 60447: 
114042:     nsRegion childVisibleRegion = displayport + mScrollFrame->GetOffsetToCrossDoc(ReferenceFrame());
 60447: 
 98137:     nsRect boundedRect =
 98137:       childVisibleRegion.GetBounds().Intersect(mList.GetBounds(aBuilder));
 98137:     nsRect allowExpansion = boundedRect.Intersect(aAllowVisibleRegionExpansion);
 79445:     bool visible = mList.ComputeVisibilityForSublist(
120128:       aBuilder, this, &childVisibleRegion, boundedRect, allowExpansion);
 60447:     mVisibleRect = boundedRect;
 60447: 
 60447:     return visible;
 60447: 
 60447:   } else {
 69189:     return nsDisplayWrapList::ComputeVisibility(aBuilder, aVisibleRegion,
 69802:                                                 aAllowVisibleRegionExpansion);
 60447:   }
 60447: }
 60447: 
 69189: LayerState
 69189: nsDisplayScrollLayer::GetLayerState(nsDisplayListBuilder* aBuilder,
 97534:                                     LayerManager* aManager,
 97534:                                     const ContainerParameters& aParameters)
 60447: {
 69189:   // Force this as a layer so we can scroll asynchronously.
 69189:   // This causes incorrect rendering for rounded clips!
 69189:   return LAYER_ACTIVE_FORCE;
 60447: }
 69189: 
 79445: bool
 69189: nsDisplayScrollLayer::TryMerge(nsDisplayListBuilder* aBuilder,
 69189:                                nsDisplayItem* aItem)
 69189: {
 69189:   if (aItem->GetType() != TYPE_SCROLL_LAYER) {
 80486:     return false;
 69189:   }
 69189: 
 69189:   nsDisplayScrollLayer* other = static_cast<nsDisplayScrollLayer*>(aItem);
 69189:   if (other->mScrolledFrame != this->mScrolledFrame) {
 80486:     return false;
 69189:   }
 69189: 
119946:   NS_ASSERTION(other->mReferenceFrame == mReferenceFrame,
119946:                "Must have the same reference frame!");
119946: 
 69189:   FrameProperties props = mScrolledFrame->Properties();
 69189:   props.Set(nsIFrame::ScrollLayerCount(),
 69189:     reinterpret_cast<void*>(GetScrollLayerCount() - 1));
 69189: 
116234:   // Swap frames with the other item before doing MergeFrom.
116234:   // XXX - This ensures that the frame associated with a scroll layer after
116234:   // merging is the first, rather than the last. This tends to change less,
116234:   // ensuring we're more likely to retain the associated gfx layer.
116234:   // See Bug 729534 and Bug 731641.
116234:   nsIFrame* tmp = mFrame;
116234:   mFrame = other->mFrame;
116234:   other->mFrame = tmp;
 95566:   MergeFromTrackingMergedFrames(other);
 80486:   return true;
 69189: }
 69189: 
 79445: bool
 69189: nsDisplayScrollLayer::ShouldFlattenAway(nsDisplayListBuilder* aBuilder)
 69189: {
 69189:   return GetScrollLayerCount() > 1;
 69189: }
 69189: 
 95340: intptr_t
 69189: nsDisplayScrollLayer::GetScrollLayerCount()
 69189: {
 69189:   FrameProperties props = mScrolledFrame->Properties();
 69189: #ifdef DEBUG
 79445:   bool hasCount = false;
 95340:   intptr_t result = reinterpret_cast<intptr_t>(
 69189:     props.Get(nsIFrame::ScrollLayerCount(), &hasCount));
 69189:   // If this aborts, then the property was either not added before scroll
 69189:   // layers were created or the property was deleted to early. If the latter,
 69189:   // make sure that nsDisplayScrollInfoLayer is on the bottom of the list so
 69189:   // that it is processed last.
 69189:   NS_ABORT_IF_FALSE(hasCount, "nsDisplayScrollLayer should always be defined");
 69189:   return result;
 69189: #else
 95340:   return reinterpret_cast<intptr_t>(props.Get(nsIFrame::ScrollLayerCount()));
 60447: #endif
 69189: }
 69189: 
 95340: intptr_t
 69189: nsDisplayScrollLayer::RemoveScrollLayerCount()
 69189: {
 95340:   intptr_t result = GetScrollLayerCount();
 69189:   FrameProperties props = mScrolledFrame->Properties();
 69189:   props.Remove(nsIFrame::ScrollLayerCount());
 69189:   return result;
 69189: }
 69189: 
 60447: 
 67860: nsDisplayScrollInfoLayer::nsDisplayScrollInfoLayer(
 67860:   nsDisplayListBuilder* aBuilder,
 69189:   nsIFrame* aScrolledFrame,
 69189:   nsIFrame* aScrollFrame)
 69189:   : nsDisplayScrollLayer(aBuilder, aScrolledFrame, aScrolledFrame, aScrollFrame)
 67860: {
 67860: #ifdef NS_BUILD_REFCNT_LOGGING
 67860:   MOZ_COUNT_CTOR(nsDisplayScrollInfoLayer);
 67860: #endif
 67860: }
 67860: 
 67860: #ifdef NS_BUILD_REFCNT_LOGGING
 67860: nsDisplayScrollInfoLayer::~nsDisplayScrollInfoLayer()
 67860: {
 67860:   MOZ_COUNT_DTOR(nsDisplayScrollInfoLayer);
 67860: }
 67860: #endif
 67860: 
 69189: LayerState
 69189: nsDisplayScrollInfoLayer::GetLayerState(nsDisplayListBuilder* aBuilder,
 97534:                                         LayerManager* aManager,
 97534:                                         const ContainerParameters& aParameters)
 69189: {
 69189:   return LAYER_ACTIVE_EMPTY;
 69189: }
 69189: 
 79445: bool
 69189: nsDisplayScrollInfoLayer::TryMerge(nsDisplayListBuilder* aBuilder,
 69189:                                    nsDisplayItem* aItem)
 69189: {
 80486:   return false;
 69189: }
 69189: 
 79445: bool
 69189: nsDisplayScrollInfoLayer::ShouldFlattenAway(nsDisplayListBuilder* aBuilder)
 69189: {
 69189:   // Layer metadata for a particular scroll frame needs to be unique. Only
 69189:   // one nsDisplayScrollLayer (with rendered content) or one
 69189:   // nsDisplayScrollInfoLayer (with only the metadata) should survive the
 69189:   // visibility computation.
 69189:   return RemoveScrollLayerCount() == 1;
 69189: }
 69189: 
 51260: nsDisplayClip::nsDisplayClip(nsDisplayListBuilder* aBuilder,
 52289:                              nsIFrame* aFrame, nsDisplayItem* aItem,
 52289:                              const nsRect& aRect)
 95645:    : nsDisplayWrapList(aBuilder, aFrame, aItem,
114042:        aFrame == aItem->GetUnderlyingFrame() ? aItem->ReferenceFrame() : aBuilder->FindReferenceFrameFor(aFrame),
 95645:        aFrame == aItem->GetUnderlyingFrame() ? aItem->ToReferenceFrame() : aBuilder->ToReferenceFrame(aFrame)),
 95645:      mClip(aRect) {
     1:   MOZ_COUNT_CTOR(nsDisplayClip);
     1: }
     1: 
 51260: nsDisplayClip::nsDisplayClip(nsDisplayListBuilder* aBuilder,
 52289:                              nsIFrame* aFrame, nsDisplayList* aList,
 52289:                              const nsRect& aRect)
 95051:    : nsDisplayWrapList(aBuilder, aFrame, aList), mClip(aRect) {
     1:   MOZ_COUNT_CTOR(nsDisplayClip);
 95051: }
 95051: 
 95051: nsRect nsDisplayClip::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
 95051:   nsRect r = nsDisplayWrapList::GetBounds(aBuilder, aSnap);
 95347:   *aSnap = false;
 98137:   return mClip.Intersect(r);
     1: }
     1: 
     1: #ifdef NS_BUILD_REFCNT_LOGGING
     1: nsDisplayClip::~nsDisplayClip() {
     1:   MOZ_COUNT_DTOR(nsDisplayClip);
     1: }
     1: #endif
     1: 
     1: void nsDisplayClip::Paint(nsDisplayListBuilder* aBuilder,
 68481:                           nsRenderingContext* aCtx) {
 38803:   NS_ERROR("nsDisplayClip should have been flattened away for painting");
     1: }
     1: 
 79445: bool nsDisplayClip::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                         nsRegion* aVisibleRegion,
 69802:                                         const nsRect& aAllowVisibleRegionExpansion) {
 34210:   nsRegion clipped;
 34210:   clipped.And(*aVisibleRegion, mClip);
 34210: 
 34210:   nsRegion finalClipped(clipped);
 98137:   nsRect allowExpansion = mClip.Intersect(aAllowVisibleRegionExpansion);
 79445:   bool anyVisible =
 61411:     nsDisplayWrapList::ComputeVisibility(aBuilder, &finalClipped,
 69802:                                          allowExpansion);
 34210: 
 34210:   nsRegion removed;
 34210:   removed.Sub(clipped, finalClipped);
 69802:   aBuilder->SubtractFromVisibleRegion(aVisibleRegion, removed);
 34210: 
     1:   return anyVisible;
     1: }
     1: 
 79445: bool nsDisplayClip::TryMerge(nsDisplayListBuilder* aBuilder,
     1:                              nsDisplayItem* aItem) {
     1:   if (aItem->GetType() != TYPE_CLIP)
 80486:     return false;
  3233:   nsDisplayClip* other = static_cast<nsDisplayClip*>(aItem);
 68638:   if (!other->mClip.IsEqualInterior(mClip))
 80486:     return false;
 95566:   // No need to track merged frames for clipping
 95348:   MergeFrom(other);
 80486:   return true;
     1: }
     1: 
     1: nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
     1:                                                 nsDisplayItem* aItem) {
 14466:   return new (aBuilder)
 52289:     nsDisplayClip(aBuilder, aItem->GetUnderlyingFrame(), aItem, mClip);
     1: }
 19125: 
 52292: nsDisplayClipRoundedRect::nsDisplayClipRoundedRect(
 52292:                              nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
 52292:                              nsDisplayItem* aItem,
 52292:                              const nsRect& aRect, nscoord aRadii[8])
 52292:     : nsDisplayClip(aBuilder, aFrame, aItem, aRect)
 52292: {
 52292:   MOZ_COUNT_CTOR(nsDisplayClipRoundedRect);
 52292:   memcpy(mRadii, aRadii, sizeof(mRadii));
 52292: }
 52292: 
 52292: nsDisplayClipRoundedRect::nsDisplayClipRoundedRect(
 52292:                              nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
 52292:                              nsDisplayList* aList,
 52292:                              const nsRect& aRect, nscoord aRadii[8])
 52292:     : nsDisplayClip(aBuilder, aFrame, aList, aRect)
 52292: {
 52292:   MOZ_COUNT_CTOR(nsDisplayClipRoundedRect);
 52292:   memcpy(mRadii, aRadii, sizeof(mRadii));
 52292: }
 52292: 
 52292: #ifdef NS_BUILD_REFCNT_LOGGING
 52292: nsDisplayClipRoundedRect::~nsDisplayClipRoundedRect()
 52292: {
 52292:   MOZ_COUNT_DTOR(nsDisplayClipRoundedRect);
 52292: }
 52292: #endif
 52292: 
 59779: nsRegion
 59779: nsDisplayClipRoundedRect::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
 97420:                                           bool* aSnap)
 52292: {
 95051:   *aSnap = false;
 59779:   return nsRegion();
 52292: }
 52292: 
 52292: void
 52292: nsDisplayClipRoundedRect::HitTest(nsDisplayListBuilder* aBuilder,
 52292:                                   const nsRect& aRect, HitTestState* aState,
 52292:                                   nsTArray<nsIFrame*> *aOutFrames)
 52292: {
 55316:   if (!RoundedRectIntersectsRect(mClip, mRadii, aRect)) {
 55316:     // aRect doesn't intersect our border-radius curve.
 55316: 
 55316:     // FIXME: This isn't quite sufficient for aRect having nontrivial
 55316:     // size (which is the unusual case here), since it's possible that
 55316:     // the part of aRect that intersects the the rounded rect isn't the
 55316:     // part that intersects the items in mList.
 55316:     return;
 55316:   }
 55316: 
 52292:   mList.HitTest(aBuilder, aRect, aState, aOutFrames);
 52292: }
 52292: 
 52292: nsDisplayWrapList*
 52292: nsDisplayClipRoundedRect::WrapWithClone(nsDisplayListBuilder* aBuilder,
 52292:                                         nsDisplayItem* aItem) {
 52292:   return new (aBuilder)
 52292:     nsDisplayClipRoundedRect(aBuilder, aItem->GetUnderlyingFrame(), aItem,
 52292:                              mClip, mRadii);
 52292: }
 52292: 
 79445: bool nsDisplayClipRoundedRect::ComputeVisibility(
 52292:                                     nsDisplayListBuilder* aBuilder,
 61411:                                     nsRegion* aVisibleRegion,
 69802:                                     const nsRect& aAllowVisibleRegionExpansion)
 52292: {
 52292:   nsRegion clipped;
 52292:   clipped.And(*aVisibleRegion, mClip);
 52292: 
 69802:   return nsDisplayWrapList::ComputeVisibility(aBuilder, &clipped, nsRect());
 52292:   // FIXME: Remove a *conservative* opaque region from aVisibleRegion
 52292:   // (like in nsDisplayClip::ComputeVisibility).
 52292: }
 52292: 
 79445: bool nsDisplayClipRoundedRect::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
 52292: {
 52292:   if (aItem->GetType() != TYPE_CLIP_ROUNDED_RECT)
 80486:     return false;
 52292:   nsDisplayClipRoundedRect* other =
 52292:     static_cast<nsDisplayClipRoundedRect*>(aItem);
 68638:   if (!mClip.IsEqualInterior(other->mClip) ||
 59653:       memcmp(mRadii, other->mRadii, sizeof(mRadii)) != 0)
 80486:     return false;
 95566:   // No need to track merged frames for clipping
 95348:   MergeFrom(other);
 80486:   return true;
 52292: }
 52292: 
 51260: nsDisplayZoom::nsDisplayZoom(nsDisplayListBuilder* aBuilder,
 51260:                              nsIFrame* aFrame, nsDisplayList* aList,
115308:                              int32_t aAPD, int32_t aParentAPD,
115308:                              uint32_t aFlags)
115308:     : nsDisplayOwnLayer(aBuilder, aFrame, aList, aFlags)
115308:     , mAPD(aAPD), mParentAPD(aParentAPD) {
 47900:   MOZ_COUNT_CTOR(nsDisplayZoom);
 47900: }
 19214: 
 47900: #ifdef NS_BUILD_REFCNT_LOGGING
 47900: nsDisplayZoom::~nsDisplayZoom() {
 47900:   MOZ_COUNT_DTOR(nsDisplayZoom);
 47900: }
 47900: #endif
 47900: 
 95051: nsRect nsDisplayZoom::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap)
 47900: {
 95051:   nsRect bounds = nsDisplayWrapList::GetBounds(aBuilder, aSnap);
 95051:   *aSnap = false;
 47900:   return bounds.ConvertAppUnitsRoundOut(mAPD, mParentAPD);
 47900: }
 47900: 
 47900: void nsDisplayZoom::HitTest(nsDisplayListBuilder *aBuilder,
 47900:                             const nsRect& aRect,
 47900:                             HitTestState *aState,
 47900:                             nsTArray<nsIFrame*> *aOutFrames)
 47900: {
 47900:   nsRect rect;
 47900:   // A 1x1 rect indicates we are just hit testing a point, so pass down a 1x1
 47900:   // rect as well instead of possibly rounding the width or height to zero.
 47900:   if (aRect.width == 1 && aRect.height == 1) {
 47900:     rect.MoveTo(aRect.TopLeft().ConvertAppUnits(mParentAPD, mAPD));
 47900:     rect.width = rect.height = 1;
 47900:   } else {
 47900:     rect = aRect.ConvertAppUnitsRoundOut(mParentAPD, mAPD);
 47900:   }
 47900:   mList.HitTest(aBuilder, rect, aState, aOutFrames);
 47900: }
 47900: 
 47900: void nsDisplayZoom::Paint(nsDisplayListBuilder* aBuilder,
 68481:                           nsRenderingContext* aCtx)
 47900: {
 47900:   mList.PaintForFrame(aBuilder, aCtx, mFrame, nsDisplayList::PAINT_DEFAULT);
 47900: }
 47900: 
 79445: bool nsDisplayZoom::ComputeVisibility(nsDisplayListBuilder *aBuilder,
 61411:                                       nsRegion *aVisibleRegion,
 69802:                                       const nsRect& aAllowVisibleRegionExpansion)
 47900: {
 47900:   // Convert the passed in visible region to our appunits.
 47900:   nsRegion visibleRegion =
 47900:     aVisibleRegion->ConvertAppUnitsRoundOut(mParentAPD, mAPD);
 47900:   nsRegion originalVisibleRegion = visibleRegion;
 47900: 
 51633:   nsRect transformedVisibleRect =
 51633:     mVisibleRect.ConvertAppUnitsRoundOut(mParentAPD, mAPD);
 62700:   nsRect allowExpansion =
 62700:     aAllowVisibleRegionExpansion.ConvertAppUnitsRoundIn(mParentAPD, mAPD);
 79445:   bool retval =
120128:     mList.ComputeVisibilityForSublist(aBuilder, this, &visibleRegion,
 61411:                                       transformedVisibleRect,
 69802:                                       allowExpansion);
 47900: 
 47900:   nsRegion removed;
 47900:   // removed = originalVisibleRegion - visibleRegion
 47900:   removed.Sub(originalVisibleRegion, visibleRegion);
 47900:   // Convert removed region to parent appunits.
 47900:   removed = removed.ConvertAppUnitsRoundIn(mAPD, mParentAPD);
 47900:   // aVisibleRegion = aVisibleRegion - removed (modulo any simplifications
 47900:   // SubtractFromVisibleRegion does)
 69802:   aBuilder->SubtractFromVisibleRegion(aVisibleRegion, removed);
 47900: 
 47900:   return retval;
 47900: }
 19214: 
 19214: ///////////////////////////////////////////////////
 19214: // nsDisplayTransform Implementation
 19214: //
 19214: 
 19214: // Write #define UNIFIED_CONTINUATIONS here to have the transform property try
 19214: // to transform content with continuations as one unified block instead of
 19214: // several smaller ones.  This is currently disabled because it doesn't work
 30710: // correctly, since when the frames are initially being reflowed, their
 19214: // continuations all compute their bounding rects independently of each other
 19214: // and consequently get the wrong value.  Write #define DEBUG_HIT here to have
 19214: // the nsDisplayTransform class dump out a bunch of information about hit
 19214: // detection.
 19214: #undef  UNIFIED_CONTINUATIONS
 19214: #undef  DEBUG_HIT
 19214: 
 19214: /* Returns the bounds of a frame as defined for transforms.  If
 19214:  * UNIFIED_CONTINUATIONS is not defined, this is simply the frame's bounding
 19214:  * rectangle, translated to the origin. Otherwise, returns the smallest
 19214:  * rectangle containing a frame and all of its continuations.  For example, if
 19214:  * there is a <span> element with several continuations split over several
 19214:  * lines, this function will return the rectangle containing all of those
 19214:  * continuations.  This rectangle is relative to the origin of the frame's local
 19214:  * coordinate space.
 19214:  */
 19214: #ifndef UNIFIED_CONTINUATIONS
 19214: 
 19214: nsRect
 19214: nsDisplayTransform::GetFrameBoundsForTransform(const nsIFrame* aFrame)
 19214: {
 19214:   NS_PRECONDITION(aFrame, "Can't get the bounds of a nonexistent frame!");
 98711: 
 98711:   if (aFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT) {
 98711:     // TODO: SVG needs to define what percentage translations resolve against.
 98711:     return nsRect();
 98711:   }
 98711: 
 19214:   return nsRect(nsPoint(0, 0), aFrame->GetSize());
 19214: }
 19214: 
 19214: #else
 19214: 
 19214: nsRect
 19214: nsDisplayTransform::GetFrameBoundsForTransform(const nsIFrame* aFrame)
 19214: {
 19214:   NS_PRECONDITION(aFrame, "Can't get the bounds of a nonexistent frame!");
 19214: 
 19214:   nsRect result;
 19214: 
 98711:   if (aFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT) {
 98711:     // TODO: SVG needs to define what percentage translations resolve against.
 98711:     return result;
 98711:   }
 98711: 
 19214:   /* Iterate through the continuation list, unioning together all the
 19214:    * bounding rects.
 19214:    */
 19214:   for (const nsIFrame *currFrame = aFrame->GetFirstContinuation();
106838:        currFrame != nullptr;
 19214:        currFrame = currFrame->GetNextContinuation())
 19214:     {
 19214:       /* Get the frame rect in local coordinates, then translate back to the
 19214:        * original coordinates.
 19214:        */
 19214:       result.UnionRect(result, nsRect(currFrame->GetOffsetTo(aFrame),
 19214:                                       currFrame->GetSize()));
 19214:     }
 19214: 
 19214:   return result;
 19214: }
 19214: 
 19214: #endif
 19214: 
114042: nsDisplayTransform::nsDisplayTransform(nsDisplayListBuilder* aBuilder, nsIFrame *aFrame,
114746:                                        nsDisplayList *aList, ComputeTransformFunction aTransformGetter, 
114746:                                        uint32_t aIndex) 
114746:   : nsDisplayItem(aBuilder, aFrame)
114746:   , mStoredList(aBuilder, aFrame, aList)
114746:   , mTransformGetter(aTransformGetter)
114746:   , mIndex(aIndex)
114746: {
114746:   MOZ_COUNT_CTOR(nsDisplayTransform);
114746:   NS_ABORT_IF_FALSE(aFrame, "Must have a frame!");
114746:   NS_ABORT_IF_FALSE(!aFrame->IsTransformed(), "Can't specify a transform getter for a transformed frame!");
114746: }
114746: 
114746: nsDisplayTransform::nsDisplayTransform(nsDisplayListBuilder* aBuilder, nsIFrame *aFrame,
114042:                                        nsDisplayList *aList, uint32_t aIndex) 
114746:   : nsDisplayItem(aBuilder, aFrame)
114746:   , mStoredList(aBuilder, aFrame, aList)
114746:   , mTransformGetter(nullptr)
114746:   , mIndex(aIndex)
114042: {
114042:   MOZ_COUNT_CTOR(nsDisplayTransform);
114042:   NS_ABORT_IF_FALSE(aFrame, "Must have a frame!");
114042:   mReferenceFrame = 
114042:     aBuilder->FindReferenceFrameFor(GetTransformRootFrame(aFrame));
114042:   mToReferenceFrame = aFrame->GetOffsetToCrossDoc(mReferenceFrame);
114042: }
114042: 
114042: nsDisplayTransform::nsDisplayTransform(nsDisplayListBuilder* aBuilder, nsIFrame *aFrame,
114042:                                        nsDisplayItem *aItem, uint32_t aIndex) 
114746:   : nsDisplayItem(aBuilder, aFrame)
114746:   , mStoredList(aBuilder, aFrame, aItem)
114746:   , mTransformGetter(nullptr)
114746:   , mIndex(aIndex)
114042: {
114042:   MOZ_COUNT_CTOR(nsDisplayTransform);
114042:   NS_ABORT_IF_FALSE(aFrame, "Must have a frame!");
114042:   mReferenceFrame = 
114042:     aBuilder->FindReferenceFrameFor(GetTransformRootFrame(aFrame));
114042:   mToReferenceFrame = aFrame->GetOffsetToCrossDoc(mReferenceFrame);
114042: }
114042: 
 43138: /* Returns the delta specified by the -moz-transform-origin property.
 19214:  * This is a positive delta, meaning that it indicates the direction to move
107003:  * to get from (0, 0) of the frame to the transform origin.  This function is
107003:  * called off the main thread.
 19214:  */
107003: /* static */ gfxPoint3D
107003: nsDisplayTransform::GetDeltaToMozTransformOrigin(const nsIFrame* aFrame,
 90354:                                                  float aAppUnitsPerPixel,
 19214:                                                  const nsRect* aBoundsOverride)
 19214: {
 19214:   NS_PRECONDITION(aFrame, "Can't get delta for a null frame!");
 98711:   NS_PRECONDITION(aFrame->IsTransformed(),
 98711:                   "Shouldn't get a delta for an untransformed frame!");
 19214: 
 19214:   /* For both of the coordinates, if the value of -moz-transform is a
 19214:    * percentage, it's relative to the size of the frame.  Otherwise, if it's
 19214:    * a distance, it's already computed for us!
 19214:    */
 19214:   const nsStyleDisplay* display = aFrame->GetStyleDisplay();
 19214:   nsRect boundingRect = (aBoundsOverride ? *aBoundsOverride :
 19214:                          nsDisplayTransform::GetFrameBoundsForTransform(aFrame));
 19214: 
 19214:   /* Allows us to access named variables by index. */
107003:   float coords[3];
 19214:   const nscoord* dimensions[2] =
 19214:     {&boundingRect.width, &boundingRect.height};
 19214: 
108991:   for (uint8_t index = 0; index < 2; ++index) {
 19214:     /* If the -moz-transform-origin specifies a percentage, take the percentage
 19214:      * of the size of the box.
 19214:      */
 53920:     const nsStyleCoord &coord = display->mTransformOrigin[index];
 53920:     if (coord.GetUnit() == eStyleUnit_Calc) {
 53920:       const nsStyleCoord::Calc *calc = coord.GetCalcValue();
107003:       coords[index] =
 90354:         NSAppUnitsToFloatPixels(*dimensions[index], aAppUnitsPerPixel) *
 53920:           calc->mPercent +
 90354:         NSAppUnitsToFloatPixels(calc->mLength, aAppUnitsPerPixel);
 53920:     } else if (coord.GetUnit() == eStyleUnit_Percent) {
107003:       coords[index] =
 90354:         NSAppUnitsToFloatPixels(*dimensions[index], aAppUnitsPerPixel) *
 53920:         coord.GetPercentValue();
 53920:     } else {
 53920:       NS_ABORT_IF_FALSE(coord.GetUnit() == eStyleUnit_Coord, "unexpected unit");
107003:       coords[index] =
 90354:         NSAppUnitsToFloatPixels(coord.GetCoordValue(), aAppUnitsPerPixel);
 90354:     }
 98711:     if ((aFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT) &&
 98711:         coord.GetUnit() != eStyleUnit_Percent) {
 98711:       // <length> values represent offsets from the origin of the SVG element's
 98711:       // user space, not the top left of its bounds, so we must adjust for that:
 98711:       nscoord offset =
 98711:         (index == 0) ? aFrame->GetPosition().x : aFrame->GetPosition().y;
107003:       coords[index] -= NSAppUnitsToFloatPixels(offset, aAppUnitsPerPixel);
107003:     }
107003:   }
107003: 
107003:   coords[2] = NSAppUnitsToFloatPixels(display->mTransformOrigin[2].GetCoordValue(),
 90354:                                       aAppUnitsPerPixel);
 19214:   /* Adjust based on the origin of the rectangle. */
107003:   coords[0] += NSAppUnitsToFloatPixels(boundingRect.x, aAppUnitsPerPixel);
107003:   coords[1] += NSAppUnitsToFloatPixels(boundingRect.y, aAppUnitsPerPixel);
107003: 
107003:   return gfxPoint3D(coords[0], coords[1], coords[2]);
 19214: }
 19214: 
 74759: /* Returns the delta specified by the -moz-perspective-origin property.
 74759:  * This is a positive delta, meaning that it indicates the direction to move
107003:  * to get from (0, 0) of the frame to the perspective origin. This function is
107003:  * called off the main thread.
 74759:  */
107003: /* static */ gfxPoint3D
107003: nsDisplayTransform::GetDeltaToMozPerspectiveOrigin(const nsIFrame* aFrame,
 92049:                                                    float aAppUnitsPerPixel)
 74759: {
 74759:   NS_PRECONDITION(aFrame, "Can't get delta for a null frame!");
 98711:   NS_PRECONDITION(aFrame->IsTransformed(),
 98711:                   "Shouldn't get a delta for an untransformed frame!");
 74759: 
 74759:   /* For both of the coordinates, if the value of -moz-perspective-origin is a
 74759:    * percentage, it's relative to the size of the frame.  Otherwise, if it's
 74759:    * a distance, it's already computed for us!
 74759:    */
 74759: 
 74759:   //TODO: Should this be using our bounds or the parent's bounds?
 74759:   // How do we handle aBoundsOverride in the latter case?
 90156:   nsIFrame* parent = aFrame->GetParentStyleContextFrame();
125048:   if (!parent) {
125048:     return gfxPoint3D();
125048:   }
 97086:   const nsStyleDisplay* display = parent->GetStyleDisplay();
 92049:   nsRect boundingRect = nsDisplayTransform::GetFrameBoundsForTransform(parent);
 74759: 
 74759:   /* Allows us to access named variables by index. */
 74759:   gfxPoint3D result;
 74759:   result.z = 0.0f;
 74759:   gfxFloat* coords[2] = {&result.x, &result.y};
 74759:   const nscoord* dimensions[2] =
 74759:     {&boundingRect.width, &boundingRect.height};
 74759: 
108991:   for (uint8_t index = 0; index < 2; ++index) {
 74759:     /* If the -moz-transform-origin specifies a percentage, take the percentage
 74759:      * of the size of the box.
 74759:      */
 74759:     const nsStyleCoord &coord = display->mPerspectiveOrigin[index];
 74759:     if (coord.GetUnit() == eStyleUnit_Calc) {
 74759:       const nsStyleCoord::Calc *calc = coord.GetCalcValue();
 90354:       *coords[index] =
 90354:         NSAppUnitsToFloatPixels(*dimensions[index], aAppUnitsPerPixel) *
 74759:           calc->mPercent +
 90354:         NSAppUnitsToFloatPixels(calc->mLength, aAppUnitsPerPixel);
 74759:     } else if (coord.GetUnit() == eStyleUnit_Percent) {
 90354:       *coords[index] =
 90354:         NSAppUnitsToFloatPixels(*dimensions[index], aAppUnitsPerPixel) *
 74759:         coord.GetPercentValue();
 74759:     } else {
 74759:       NS_ABORT_IF_FALSE(coord.GetUnit() == eStyleUnit_Coord, "unexpected unit");
 90354:       *coords[index] =
 90354:         NSAppUnitsToFloatPixels(coord.GetCoordValue(), aAppUnitsPerPixel);
 74759:     }
 74759:   }
 74759: 
 90156:   nsPoint parentOffset = aFrame->GetOffsetTo(parent);
 90354:   gfxPoint3D gfxOffset(
 90354:                NSAppUnitsToFloatPixels(parentOffset.x, aAppUnitsPerPixel),
 90354:                NSAppUnitsToFloatPixels(parentOffset.y, aAppUnitsPerPixel),
 90354:                0.0f);
 90156: 
 90156:   return result - gfxOffset;
 74759: }
 74759: 
125048: nsDisplayTransform::FrameTransformProperties::FrameTransformProperties(const nsIFrame* aFrame,
125048:                                                                        float aAppUnitsPerPixel,
125048:                                                                        const nsRect* aBoundsOverride)
125048:   : mFrame(aFrame)
125048:   , mTransformList(aFrame->GetStyleDisplay()->mSpecifiedTransform)
125048:   , mToMozOrigin(GetDeltaToMozTransformOrigin(aFrame, aAppUnitsPerPixel, aBoundsOverride))
125048:   , mToPerspectiveOrigin(GetDeltaToMozPerspectiveOrigin(aFrame, aAppUnitsPerPixel))
125048:   , mChildPerspective(0)
125048: {
125048:   const nsStyleDisplay* parentDisp = nullptr;
125048:   nsStyleContext* parentStyleContext = aFrame->GetStyleContext()->GetParent();
125048:   if (parentStyleContext) {
125048:     parentDisp = parentStyleContext->GetStyleDisplay();
125048:   }
125048:   if (parentDisp && parentDisp->mChildPerspective.GetUnit() == eStyleUnit_Coord) {
125048:     mChildPerspective = parentDisp->mChildPerspective.GetCoordValue();
125048:   }
125048: }
125048: 
 19214: /* Wraps up the -moz-transform matrix in a change-of-basis matrix pair that
 19214:  * translates from local coordinate space to transform coordinate space, then
 19214:  * hands it back.
 19214:  */
 74283: gfx3DMatrix
125048: nsDisplayTransform::GetResultingTransformMatrix(const FrameTransformProperties& aProperties,
125048:                                                 const nsPoint& aOrigin,
125048:                                                 float aAppUnitsPerPixel,
125048:                                                 const nsRect* aBoundsOverride,
125048:                                                 nsIFrame** aOutAncestor)
125048: {
125048:   return GetResultingTransformMatrixInternal(aProperties, aOrigin, aAppUnitsPerPixel,
125048:                                              aBoundsOverride, aOutAncestor);
125048: }
125048:  
125048: gfx3DMatrix
 19214: nsDisplayTransform::GetResultingTransformMatrix(const nsIFrame* aFrame,
 19214:                                                 const nsPoint& aOrigin,
 90354:                                                 float aAppUnitsPerPixel,
 77286:                                                 const nsRect* aBoundsOverride,
 77286:                                                 nsIFrame** aOutAncestor)
 19214: {
125048:   FrameTransformProperties props(aFrame,
125048:                                  aAppUnitsPerPixel,
125048:                                  aBoundsOverride);
125048: 
125048:   return GetResultingTransformMatrixInternal(props, aOrigin, aAppUnitsPerPixel, 
125048:                                              aBoundsOverride, aOutAncestor);
114042: }
114042: 
114042: gfx3DMatrix
125048: nsDisplayTransform::GetResultingTransformMatrixInternal(const FrameTransformProperties& aProperties,
114042:                                                         const nsPoint& aOrigin,
114042:                                                         float aAppUnitsPerPixel,
114042:                                                         const nsRect* aBoundsOverride,
114956:                                                         nsIFrame** aOutAncestor)
114042: {
125048:   const nsIFrame *frame = aProperties.mFrame;
 77286: 
 77286:   if (aOutAncestor) {
125048:     *aOutAncestor = nsLayoutUtils::GetCrossDocParentFrame(frame);
 77286:   }
 77286: 
 19214:   /* Account for the -moz-transform-origin property by translating the
 19214:    * coordinate space to the new origin.
 19214:    */
 90354:   gfxPoint3D newOrigin =
 90354:     gfxPoint3D(NSAppUnitsToFloatPixels(aOrigin.x, aAppUnitsPerPixel),
 90354:                NSAppUnitsToFloatPixels(aOrigin.y, aAppUnitsPerPixel),
 74757:                0.0f);
 19214: 
 19214:   /* Get the underlying transform matrix.  This requires us to get the
 19214:    * bounds of the frame.
 19214:    */
 19214:   nsRect bounds = (aBoundsOverride ? *aBoundsOverride :
125048:                    nsDisplayTransform::GetFrameBoundsForTransform(frame));
 19214: 
 19214:   /* Get the matrix, then change its basis to factor in the origin. */
 79445:   bool dummy;
 77286:   gfx3DMatrix result;
 98711:   // Call IsSVGTransformed() regardless of the value of
 98711:   // disp->mSpecifiedTransform, since we still need any transformFromSVGParent.
 98711:   gfxMatrix svgTransform, transformFromSVGParent;
 98711:   bool hasSVGTransforms =
125048:     frame && frame->IsSVGTransformed(&svgTransform, &transformFromSVGParent);
 77286:   /* Transformed frames always have a transform, or are preserving 3d (and might still have perspective!) */
125048:   if (aProperties.mTransformList) {
125048:     result = nsStyleTransformMatrix::ReadTransforms(aProperties.mTransformList,
125048:                                                     frame ? frame->GetStyleContext() : nullptr,
125048:                                                     frame ? frame->PresContext() : nullptr,
 90354:                                                     dummy, bounds, aAppUnitsPerPixel);
 98711:   } else if (hasSVGTransforms) {
105657:     // Correct the translation components for zoom:
125048:     float pixelsPerCSSPx = frame->PresContext()->AppUnitsPerCSSPixel() /
105657:                              aAppUnitsPerPixel;
105657:     svgTransform.x0 *= pixelsPerCSSPx;
105657:     svgTransform.y0 *= pixelsPerCSSPx;
 98711:     result = gfx3DMatrix::From2D(svgTransform);
 77286:   }
 74754: 
 98711:   if (hasSVGTransforms && !transformFromSVGParent.IsIdentity()) {
105657:     // Correct the translation components for zoom:
125048:     float pixelsPerCSSPx = frame->PresContext()->AppUnitsPerCSSPixel() /
105657:                              aAppUnitsPerPixel;
105657:     transformFromSVGParent.x0 *= pixelsPerCSSPx;
105657:     transformFromSVGParent.y0 *= pixelsPerCSSPx;
 98711:     result = result * gfx3DMatrix::From2D(transformFromSVGParent);
 98711:   }
 98711: 
125048:   if (nsLayoutUtils::Are3DTransformsEnabled() && aProperties.mChildPerspective > 0.0) {
 74754:     gfx3DMatrix perspective;
 74754:     perspective._34 =
125048:       -1.0 / NSAppUnitsToFloatPixels(aProperties.mChildPerspective, aAppUnitsPerPixel);
 81099:     /* At the point when perspective is applied, we have been translated to the transform origin.
 81099:      * The translation to the perspective origin is the difference between these values.
 81099:      */
125048:     result = result * nsLayoutUtils::ChangeMatrixBasis(aProperties.mToPerspectiveOrigin - aProperties.mToMozOrigin, perspective);
 74754:   }
 77286: 
114042:   gfxPoint3D rounded(hasSVGTransforms ? newOrigin.x : NS_round(newOrigin.x), 
114042:                      hasSVGTransforms ? newOrigin.y : NS_round(newOrigin.y), 
114042:                      0);
114042:   
125048:   if (frame && frame->Preserves3D() && nsLayoutUtils::Are3DTransformsEnabled()) {
 77286:       // Include the transform set on our parent
125048:       NS_ASSERTION(frame->GetParent() &&
125048:                    frame->GetParent()->IsTransformed() &&
125048:                    frame->GetParent()->Preserves3DChildren(),
 77286:                    "Preserve3D mismatch!");
125048:       FrameTransformProperties props(frame->GetParent(),
125048:                                      aAppUnitsPerPixel,
125048:                                      nullptr);
107003:       gfx3DMatrix parent =
125048:         GetResultingTransformMatrixInternal(props,
125048:                                             aOrigin - frame->GetPosition(),
125048:                                             aAppUnitsPerPixel, nullptr, aOutAncestor);
125048:       return nsLayoutUtils::ChangeMatrixBasis(rounded + aProperties.mToMozOrigin, result) * parent;
 77286:   }
 77286: 
 74754:   return nsLayoutUtils::ChangeMatrixBasis
125048:     (rounded + aProperties.mToMozOrigin, result);
 74281: }
 74281: 
 84920: bool
109462: nsDisplayOpacity::CanUseAsyncAnimations(nsDisplayListBuilder* aBuilder)
109462: {
109462:   if (GetUnderlyingFrame()->AreLayersMarkedActive(nsChangeHint_UpdateOpacityLayer)) {
109462:     return true;
109462:   }
109462: 
109462:   if (nsLayoutUtils::IsAnimationLoggingEnabled()) {
109462:     nsCString message;
109462:     message.AppendLiteral("Performance warning: Async animation disabled because frame was not marked active for opacity animation");
109468:     CommonElementAnimationData::LogAsyncAnimationFailure(message,
109468:                                                          GetUnderlyingFrame()->GetContent());
109462:   }
109462:   return false;
109462: }
109462: 
109462: bool
109462: nsDisplayTransform::CanUseAsyncAnimations(nsDisplayListBuilder* aBuilder)
109462: {
109462:   return ShouldPrerenderTransformedContent(aBuilder,
109462:                                            GetUnderlyingFrame(),
109462:                                            nsLayoutUtils::IsAnimationLoggingEnabled());
109462: }
109462: 
109462: /* static */ bool
 84920: nsDisplayTransform::ShouldPrerenderTransformedContent(nsDisplayListBuilder* aBuilder,
109462:                                                       nsIFrame* aFrame,
109462:                                                       bool aLogAnimations)
 84920: {
109462:   if (!aFrame->AreLayersMarkedActive(nsChangeHint_UpdateTransformLayer)) {
109462:     if (aLogAnimations) {
109462:       nsCString message;
109462:       message.AppendLiteral("Performance warning: Async animation disabled because frame was not marked active for transform animation");
109468:       CommonElementAnimationData::LogAsyncAnimationFailure(message,
109468:                                                            aFrame->GetContent());
109462:     }
109462:     return false;
109462:   }
109462: 
114042:   nsSize refSize = aBuilder->RootReferenceFrame()->GetSize();
 90088:   // Only prerender if the transformed frame's size is <= the
 90088:   // reference frame size (~viewport), allowing a 1/8th fuzz factor
 90088:   // for shadows, borders, etc.
 90088:   refSize += nsSize(refSize.width / 8, refSize.height / 8);
109462:   nsSize frameSize = aFrame->GetVisualOverflowRectRelativeToSelf().Size();
109462:   if (frameSize <= refSize) {
 91353:     // Bug 717521 - pre-render max 4096 x 4096 device pixels.
 91353:     nscoord max = aFrame->PresContext()->DevPixelsToAppUnits(4096);
 91353:     nsRect visual = aFrame->GetVisualOverflowRect();
 91353:     if (visual.width <= max && visual.height <= max) {
 91353:       return true;
 91353:     }
 91353:   }
109462: 
109462:   if (aLogAnimations) {
109462:     nsCString message;
109462:     message.AppendLiteral("Performance warning: Async animation disabled because frame size (");
109462:     message.AppendInt(nsPresContext::AppUnitsToIntCSSPixels(frameSize.width));
109462:     message.AppendLiteral(", ");
109462:     message.AppendInt(nsPresContext::AppUnitsToIntCSSPixels(frameSize.height));
109462:     message.AppendLiteral(") is bigger than the viewport (");
109462:     message.AppendInt(nsPresContext::AppUnitsToIntCSSPixels(refSize.width));
109462:     message.AppendLiteral(", ");
109462:     message.AppendInt(nsPresContext::AppUnitsToIntCSSPixels(refSize.height));
109462:     message.AppendLiteral(")");
109463:     CommonElementAnimationData::LogAsyncAnimationFailure(message,
109463:                                                          aFrame->GetContent());
 90088:   }
 90088:   return false;
 84920: }
 84920: 
 80243: /* If the matrix is singular, or a hidden backface is shown, the frame won't be visible or hit. */
 80243: static bool IsFrameVisible(nsIFrame* aFrame, const gfx3DMatrix& aMatrix)
 80243: {
 80243:   if (aMatrix.IsSingular()) {
 80243:     return false;
 80243:   }
 80243:   if (aFrame->GetStyleDisplay()->mBackfaceVisibility == NS_STYLE_BACKFACE_VISIBILITY_HIDDEN &&
 80243:       aMatrix.IsBackfaceVisible()) {
 80243:     return false;
 80243:   }
 80243:   return true;
 80243: }
 80243: 
 74283: const gfx3DMatrix&
 90354: nsDisplayTransform::GetTransform(float aAppUnitsPerPixel)
 74281: {
 90354:   if (mTransform.IsIdentity() || mCachedAppUnitsPerPixel != aAppUnitsPerPixel) {
114746:     gfxPoint3D newOrigin =
114746:       gfxPoint3D(NSAppUnitsToFloatPixels(mToReferenceFrame.x, aAppUnitsPerPixel),
114746:                  NSAppUnitsToFloatPixels(mToReferenceFrame.y, aAppUnitsPerPixel),
114746:                   0.0f);
114956:     if (mTransformGetter) {
114746:       mTransform = mTransformGetter(mFrame, aAppUnitsPerPixel);
114746:       mTransform = nsLayoutUtils::ChangeMatrixBasis(newOrigin, mTransform);
114746:     } else {
 74281:       mTransform =
 74281:         GetResultingTransformMatrix(mFrame, ToReferenceFrame(),
107003:                                     aAppUnitsPerPixel);
114956: 
114956:       /**
114956:        * Shift the coorindates to be relative to our reference frame instead of relative to this frame.
114956:        *  When we have preserve-3d, our reference frame is already guaranteed to be an ancestor of the
114956:        * preserve-3d chain, so we only need to do this once.
114956:        */
114956:       bool hasSVGTransforms = mFrame->IsSVGTransformed();
114956:       gfxPoint3D rounded(hasSVGTransforms ? newOrigin.x : NS_round(newOrigin.x), 
114956:                          hasSVGTransforms ? newOrigin.y : NS_round(newOrigin.y), 
114956:                          0);
114956:       mTransform.Translate(rounded);
 90354:       mCachedAppUnitsPerPixel = aAppUnitsPerPixel;
 74281:     }
114746:   }
 74281:   return mTransform;
 19214: }
 19214: 
 48693: already_AddRefed<Layer> nsDisplayTransform::BuildLayer(nsDisplayListBuilder *aBuilder,
 72230:                                                        LayerManager *aManager,
 72230:                                                        const ContainerParameters& aContainerParameters)
 19214: {
 74283:   const gfx3DMatrix& newTransformMatrix =
 74281:     GetTransform(mFrame->PresContext()->AppUnitsPerDevPixel());
 74755: 
 80243:   if (!IsFrameVisible(mFrame, newTransformMatrix)) {
106838:     return nullptr;
 74755:   }
 19517: 
108884:   nsRefPtr<ContainerLayer> container = aManager->GetLayerBuilder()->
120809:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, *mStoredList.GetChildren(),
 74283:                            aContainerParameters, &newTransformMatrix);
 79925: 
 79925:   // Add the preserve-3d flag for this layer, BuildContainerLayerFor clears all flags,
 79925:   // so we never need to explicitely unset this flag.
 82357:   if (mFrame->Preserves3D() || mFrame->Preserves3DChildren()) {
 79925:     container->SetContentFlags(container->GetContentFlags() | Layer::CONTENT_PRESERVE_3D);
125632:   } else {
125632:     container->SetContentFlags(container->GetContentFlags() & ~Layer::CONTENT_PRESERVE_3D);
 79925:   }
107003: 
107567:   AddAnimationsAndTransitionsToLayer(container, aBuilder,
107567:                                      this, eCSSProperty_transform);
116072:   if (ShouldPrerenderTransformedContent(aBuilder, mFrame, false)) {
116072:     container->SetUserData(nsIFrame::LayerIsPrerenderedDataKey(),
116072:                            /*the value is irrelevant*/nullptr);
125632:     container->SetContentFlags(container->GetContentFlags() | Layer::CONTENT_MAY_CHANGE_TRANSFORM);
116072:   } else {
116072:     container->RemoveUserData(nsIFrame::LayerIsPrerenderedDataKey());
125632:     container->SetContentFlags(container->GetContentFlags() & ~Layer::CONTENT_MAY_CHANGE_TRANSFORM);
116072:   }
 79925:   return container.forget();
 48693: }
 19214: 
 48693: nsDisplayItem::LayerState
 48693: nsDisplayTransform::GetLayerState(nsDisplayListBuilder* aBuilder,
 97534:                                   LayerManager* aManager,
 97534:                                   const ContainerParameters& aParameters) {
121847:   // If the transform is 3d, or the layer takes part in preserve-3d sorting
121847:   // then we *always* want this to be an active layer.
121847:   if (!GetTransform(mFrame->PresContext()->AppUnitsPerDevPixel()).Is2D() || 
121847:       mFrame->Preserves3D()) {
121847:     return LAYER_ACTIVE_FORCE;
121847:   }
 80904:   // Here we check if the *post-transform* bounds of this item are big enough
 80904:   // to justify an active layer.
 80904:   if (mFrame->AreLayersMarkedActive(nsChangeHint_UpdateTransformLayer) &&
 80904:       !IsItemTooSmallForActiveLayer(this))
 48693:     return LAYER_ACTIVE;
107003:   if (mFrame->GetContent()) {
107005:     if (nsLayoutUtils::HasAnimationsForCompositor(mFrame->GetContent(),
107003:                                                   eCSSProperty_transform)) {
107003:       return LAYER_ACTIVE;
107003:     }
107003:   }
 48693:   nsIFrame* activeScrolledRoot =
106838:     nsLayoutUtils::GetActiveScrolledRootFor(mFrame, nullptr);
121847:   return mStoredList.RequiredLayerStateForChildren(aBuilder,
 48693:                                                    aManager,
 97534:                                                    aParameters,
120809:                                                    *mStoredList.GetChildren(),
121847:                                                    activeScrolledRoot);
 19214: }
 19214: 
 79445: bool nsDisplayTransform::ComputeVisibility(nsDisplayListBuilder *aBuilder,
 61411:                                              nsRegion *aVisibleRegion,
 69802:                                              const nsRect& aAllowVisibleRegionExpansion)
 19214: {
 33368:   /* As we do this, we need to be sure to
 33368:    * untransform the visible rect, since we want everything that's painting to
 74283:    * think that it's painting in its original rectangular coordinate space.
 74283:    * If we can't untransform, take the entire overflow rect */
 74283:   nsRect untransformedVisibleRect;
 90079:   float factor = nsPresContext::AppUnitsPerCSSPixel();
 84920:   if (ShouldPrerenderTransformedContent(aBuilder, mFrame) ||
 90079:       !UntransformRectMatrix(mVisibleRect,
 90079:                              GetTransform(factor),
 90079:                              factor,
 74283:                              &untransformedVisibleRect))
 74283:   {
114042:     untransformedVisibleRect = mFrame->GetVisualOverflowRectRelativeToSelf();
 74283:   }
 74283:   nsRegion untransformedVisible = untransformedVisibleRect;
 78018:   // Call RecomputeVisiblity instead of ComputeVisibility since
 51633:   // nsDisplayItem::ComputeVisibility should only be called from
 51633:   // nsDisplayList::ComputeVisibility (which sets mVisibleRect on the item)
 51633:   mStoredList.RecomputeVisibility(aBuilder, &untransformedVisible);
 80486:   return true;
 19214: }
 19214: 
 19214: #ifdef DEBUG_HIT
 19214: #include <time.h>
 19214: #endif
 19214: 
 19214: /* HitTest does some fun stuff with matrix transforms to obtain the answer. */
 40570: void nsDisplayTransform::HitTest(nsDisplayListBuilder *aBuilder,
 40570:                                  const nsRect& aRect,
 40570:                                  HitTestState *aState,
 40570:                                  nsTArray<nsIFrame*> *aOutFrames)
 19214: {
 19214:   /* Here's how this works:
 19214:    * 1. Get the matrix.  If it's singular, abort (clearly we didn't hit
 19214:    *    anything).
 19214:    * 2. Invert the matrix.
 40570:    * 3. Use it to transform the rect into the correct space.
 40570:    * 4. Pass that rect down through to the list's version of HitTest.
 19214:    */
 19214:   float factor = nsPresContext::AppUnitsPerCSSPixel();
 74283:   gfx3DMatrix matrix = GetTransform(factor);
 74281: 
 80243:   if (!IsFrameVisible(mFrame, matrix)) {
 40570:     return;
 74755:   }
 19214: 
 19214:   /* We want to go from transformed-space to regular space.
 19214:    * Thus we have to invert the matrix, which normally does
 19214:    * the reverse operation (e.g. regular->transformed)
 19214:    */
 19214: 
 19214:   /* Now, apply the transform and pass it down the channel. */
 40570:   nsRect resultingRect;
 40570:   if (aRect.width == 1 && aRect.height == 1) {
 78032:     // Magic width/height indicating we're hit testing a point, not a rect
 74753:     gfxPoint point = matrix.Inverse().ProjectPoint(
 74753:                        gfxPoint(NSAppUnitsToFloatPixels(aRect.x, factor),
 40570:                                 NSAppUnitsToFloatPixels(aRect.y, factor)));
 40570: 
 40570:     resultingRect = nsRect(NSFloatPixelsToAppUnits(float(point.x), factor),
 40570:                            NSFloatPixelsToAppUnits(float(point.y), factor),
 40570:                            1, 1);
 40570: 
 40570:   } else {
 40570:     gfxRect originalRect(NSAppUnitsToFloatPixels(aRect.x, factor),
 40570:                          NSAppUnitsToFloatPixels(aRect.y, factor),
 40570:                          NSAppUnitsToFloatPixels(aRect.width, factor),
 40570:                          NSAppUnitsToFloatPixels(aRect.height, factor));
 40570: 
 74753:     gfxRect rect = matrix.Inverse().ProjectRectBounds(originalRect);;
 40570: 
 40570:     resultingRect = nsRect(NSFloatPixelsToAppUnits(float(rect.X()), factor),
 40570:                            NSFloatPixelsToAppUnits(float(rect.Y()), factor),
 40570:                            NSFloatPixelsToAppUnits(float(rect.Width()), factor),
 40570:                            NSFloatPixelsToAppUnits(float(rect.Height()), factor));
 40570:   }
 40570: 
 19214: 
 19214: #ifdef DEBUG_HIT
 19214:   printf("Frame: %p\n", dynamic_cast<void *>(mFrame));
 40570:   printf("  Untransformed point: (%f, %f)\n", resultingRect.X(), resultingRect.Y());
108991:   uint32_t originalFrameCount = aOutFrames.Length();
 19214: #endif
 19214: 
 40570:   mStoredList.HitTest(aBuilder, resultingRect, aState, aOutFrames);
 19214: 
 19214: #ifdef DEBUG_HIT
 40570:   if (originalFrameCount != aOutFrames.Length())
 40570:     printf("  Hit! Time: %f, first frame: %p\n", static_cast<double>(clock()),
 40570:            dynamic_cast<void *>(aOutFrames.ElementAt(0)));
 19214:   printf("=== end of hit test ===\n");
 19214: #endif
 19214: 
 19214: }
 19214: 
 79926: float
 79926: nsDisplayTransform::GetHitDepthAtPoint(const nsPoint& aPoint)
 79926: {
 79926:   float factor = nsPresContext::AppUnitsPerCSSPixel();
 79926:   gfx3DMatrix matrix = GetTransform(factor);
 79926: 
 80243:   NS_ASSERTION(IsFrameVisible(mFrame, matrix), "We can't have hit a frame that isn't visible!");
 79926: 
 79926:   gfxPoint point =
 79926:     matrix.Inverse().ProjectPoint(gfxPoint(NSAppUnitsToFloatPixels(aPoint.x, factor),
 79926:                                            NSAppUnitsToFloatPixels(aPoint.y, factor)));
 79926: 
 79926:   gfxPoint3D transformed = matrix.Transform3D(gfxPoint3D(point.x, point.y, 0));
 79926:   return transformed.z;
 79926: }
 79926: 
 19214: /* The bounding rectangle for the object is the overflow rectangle translated
 19214:  * by the reference point.
 19214:  */
 95051: nsRect nsDisplayTransform::GetBounds(nsDisplayListBuilder *aBuilder, bool* aSnap)
 19214: {
 90080:   nsRect untransformedBounds =
 90080:     ShouldPrerenderTransformedContent(aBuilder, mFrame) ?
114042:     mFrame->GetVisualOverflowRectRelativeToSelf() :
 95051:     mStoredList.GetBounds(aBuilder, aSnap);
 95051:   *aSnap = false;
 90078:   float factor = nsPresContext::AppUnitsPerCSSPixel();
 90080:   return nsLayoutUtils::MatrixTransformRect(untransformedBounds,
 90078:                                             GetTransform(factor),
 90078:                                             factor);
 19214: }
 19214: 
 19214: /* The transform is opaque iff the transform consists solely of scales and
 58321:  * translations and if the underlying content is opaque.  Thus if the transform
 19214:  * is of the form
 19214:  *
 19214:  * |a c e|
 19214:  * |b d f|
 19214:  * |0 0 1|
 19214:  *
 19214:  * We need b and c to be zero.
 58321:  *
 58321:  * We also need to check whether the underlying opaque content completely fills
 58321:  * our visible rect. We use UntransformRect which expands to the axis-aligned
 58321:  * bounding rect, but that's OK since if
 58321:  * mStoredList.GetVisibleRect().Contains(untransformedVisible), then it
 58321:  * certainly contains the actual (non-axis-aligned) untransformed rect.
 19214:  */
 59779: nsRegion nsDisplayTransform::GetOpaqueRegion(nsDisplayListBuilder *aBuilder,
 97420:                                              bool* aSnap)
 19214: {
 95051:   *aSnap = false;
 74283:   nsRect untransformedVisible;
 90079:   float factor = nsPresContext::AppUnitsPerCSSPixel();
116069:   // If we're going to prerender all our content, pretend like we
116069:   // don't have opqaue content so that everything under us is rendered
116069:   // as well.  That will increase graphics memory usage if our frame
116069:   // covers the entire window, but it allows our transform to be
116069:   // updated extremely cheaply, without invalidating any other
116069:   // content.
116069:   if (ShouldPrerenderTransformedContent(aBuilder, mFrame) ||
116069:       !UntransformRectMatrix(mVisibleRect, GetTransform(factor), factor, &untransformedVisible)) {
 74283:       return nsRegion();
 74283:   }
 74281: 
 74283:   const gfx3DMatrix& matrix = GetTransform(nsPresContext::AppUnitsPerCSSPixel());
 74281: 
 59779:   nsRegion result;
 74283:   gfxMatrix matrix2d;
 95051:   bool tmpSnap;
 74283:   if (matrix.Is2D(&matrix2d) &&
 74283:       matrix2d.PreservesAxisAlignedRectangles() &&
 97420:       mStoredList.GetOpaqueRegion(aBuilder, &tmpSnap).Contains(untransformedVisible)) {
 59779:     result = mVisibleRect;
 59779:   }
 59779:   return result;
 19214: }
 19214: 
 19214: /* The transform is uniform if it fills the entire bounding rect and the
 59779:  * wrapped list is uniform.  See GetOpaqueRegion for discussion of why this
 19214:  * works.
 19214:  */
 79445: bool nsDisplayTransform::IsUniform(nsDisplayListBuilder *aBuilder, nscolor* aColor)
 19214: {
 74283:   nsRect untransformedVisible;
 90079:   float factor = nsPresContext::AppUnitsPerCSSPixel();
 90079:   if (!UntransformRectMatrix(mVisibleRect, GetTransform(factor), factor, &untransformedVisible)) {
 80486:     return false;
 74283:   }
 74283:   const gfx3DMatrix& matrix = GetTransform(nsPresContext::AppUnitsPerCSSPixel());
 74281: 
 74283:   gfxMatrix matrix2d;
 74283:   return matrix.Is2D(&matrix2d) &&
 74283:          matrix2d.PreservesAxisAlignedRectangles() &&
 58321:          mStoredList.GetVisibleRect().Contains(untransformedVisible) &&
 42436:          mStoredList.IsUniform(aBuilder, aColor);
 19214: }
 19214: 
 19214: /* If UNIFIED_CONTINUATIONS is defined, we can merge two display lists that
 19214:  * share the same underlying content.  Otherwise, doing so results in graphical
 19214:  * glitches.
 19214:  */
 19214: #ifndef UNIFIED_CONTINUATIONS
 19214: 
 79445: bool
 19214: nsDisplayTransform::TryMerge(nsDisplayListBuilder *aBuilder,
 19214:                              nsDisplayItem *aItem)
 19214: {
 80486:   return false;
 19214: }
 19214: 
 19214: #else
 19214: 
 79445: bool
 19214: nsDisplayTransform::TryMerge(nsDisplayListBuilder *aBuilder,
 19214:                              nsDisplayItem *aItem)
 19214: {
 19214:   NS_PRECONDITION(aItem, "Why did you try merging with a null item?");
 19214:   NS_PRECONDITION(aBuilder, "Why did you try merging with a null builder?");
 19214: 
 19214:   /* Make sure that we're dealing with two transforms. */
 19214:   if (aItem->GetType() != TYPE_TRANSFORM)
 80486:     return false;
 19214: 
 19214:   /* Check to see that both frames are part of the same content. */
 19214:   if (aItem->GetUnderlyingFrame()->GetContent() != mFrame->GetContent())
 80486:     return false;
 19214: 
 19214:   /* Now, move everything over to this frame and signal that
 19214:    * we merged things!
 19214:    */
 95348:   mStoredList.MergeFrom(&static_cast<nsDisplayTransform*>(aItem)->mStoredList);
 80486:   return true;
 19214: }
 19214: 
 19214: #endif
 19214: 
 19214: /* TransformRect takes in as parameters a rectangle (in app space) and returns
 19214:  * the smallest rectangle (in app space) containing the transformed image of
 19214:  * that rectangle.  That is, it takes the four corners of the rectangle,
 19214:  * transforms them according to the matrix associated with the specified frame,
 19214:  * then returns the smallest rectangle containing the four transformed points.
 19214:  *
 19214:  * @param aUntransformedBounds The rectangle (in app units) to transform.
 19214:  * @param aFrame The frame whose transformation should be applied.
 19214:  * @param aOrigin The delta from the frame origin to the coordinate space origin
 19214:  * @param aBoundsOverride (optional) Force the frame bounds to be the
 19214:  *        specified bounds.
 19214:  * @return The smallest rectangle containing the image of the transformed
 19214:  *         rectangle.
 19214:  */
 19214: nsRect nsDisplayTransform::TransformRect(const nsRect &aUntransformedBounds,
 19214:                                          const nsIFrame* aFrame,
 19214:                                          const nsPoint &aOrigin,
 19214:                                          const nsRect* aBoundsOverride)
 19214: {
 19214:   NS_PRECONDITION(aFrame, "Can't take the transform based on a null frame!");
 19214: 
 19214:   float factor = nsPresContext::AppUnitsPerCSSPixel();
 19214:   return nsLayoutUtils::MatrixTransformRect
 19214:     (aUntransformedBounds,
 19214:      GetResultingTransformMatrix(aFrame, aOrigin, factor, aBoundsOverride),
 19214:      factor);
 19214: }
 19214: 
 63072: nsRect nsDisplayTransform::TransformRectOut(const nsRect &aUntransformedBounds,
 63072:                                             const nsIFrame* aFrame,
 63072:                                             const nsPoint &aOrigin,
 63072:                                             const nsRect* aBoundsOverride)
 63072: {
 63072:   NS_PRECONDITION(aFrame, "Can't take the transform based on a null frame!");
 63072: 
 63072:   float factor = nsPresContext::AppUnitsPerCSSPixel();
 63072:   return nsLayoutUtils::MatrixTransformRectOut
 63072:     (aUntransformedBounds,
 63072:      GetResultingTransformMatrix(aFrame, aOrigin, factor, aBoundsOverride),
 63072:      factor);
 63072: }
 63072: 
 90079: bool nsDisplayTransform::UntransformRectMatrix(const nsRect &aUntransformedBounds,
 90079:                                                const gfx3DMatrix& aMatrix,
 90354:                                                float aAppUnitsPerPixel,
 90079:                                                nsRect *aOutRect)
 90079: {
 90079:   if (aMatrix.IsSingular())
 90079:     return false;
 90079: 
 90354:   gfxRect result(NSAppUnitsToFloatPixels(aUntransformedBounds.x, aAppUnitsPerPixel),
 90354:                  NSAppUnitsToFloatPixels(aUntransformedBounds.y, aAppUnitsPerPixel),
 90354:                  NSAppUnitsToFloatPixels(aUntransformedBounds.width, aAppUnitsPerPixel),
 90354:                  NSAppUnitsToFloatPixels(aUntransformedBounds.height, aAppUnitsPerPixel));
 90079: 
 90079:   /* We want to untransform the matrix, so invert the transformation first! */
 90079:   result = aMatrix.Inverse().ProjectRectBounds(result);
 90079: 
 90354:   *aOutRect = nsLayoutUtils::RoundGfxRectToAppRect(result, aAppUnitsPerPixel);
 90079: 
 90079:   return true;
 90079: }
 90079: 
 79445: bool nsDisplayTransform::UntransformRect(const nsRect &aUntransformedBounds,
 19214:                                            const nsIFrame* aFrame,
 74283:                                            const nsPoint &aOrigin,
 74283:                                            nsRect* aOutRect)
 19214: {
 19214:   NS_PRECONDITION(aFrame, "Can't take the transform based on a null frame!");
 19214: 
 19214:   /* Grab the matrix.  If the transform is degenerate, just hand back the
 19214:    * empty rect.
 19214:    */
 19214:   float factor = nsPresContext::AppUnitsPerCSSPixel();
107003:   gfx3DMatrix matrix = GetResultingTransformMatrix(aFrame, aOrigin, factor);
 90079: 
 90079:   return UntransformRectMatrix(aUntransformedBounds, matrix, factor, aOutRect);
 19214: }
 19214: 
 51260: nsDisplaySVGEffects::nsDisplaySVGEffects(nsDisplayListBuilder* aBuilder,
 51260:                                          nsIFrame* aFrame, nsDisplayList* aList)
 95644:     : nsDisplayWrapList(aBuilder, aFrame, aList),
 95348:       mEffectsBounds(aFrame->GetVisualOverflowRectRelativeToSelf())
 19125: {
 19125:   MOZ_COUNT_CTOR(nsDisplaySVGEffects);
 19125: }
 19125: 
 19125: #ifdef NS_BUILD_REFCNT_LOGGING
 19125: nsDisplaySVGEffects::~nsDisplaySVGEffects()
 19125: {
 19125:   MOZ_COUNT_DTOR(nsDisplaySVGEffects);
 19125: }
 19125: #endif
 19125: 
 59779: nsRegion nsDisplaySVGEffects::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
 97420:                                               bool* aSnap)
 19125: {
 95051:   *aSnap = false;
 59779:   return nsRegion();
 19125: }
 19125: 
 40570: void
 40570: nsDisplaySVGEffects::HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
 40570:                              HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
 19125: {
 40570:   nsPoint rectCenter(aRect.x + aRect.width / 2, aRect.y + aRect.height / 2);
 95644:   if (nsSVGIntegrationUtils::HitTestFrameForEffects(mFrame,
 95644:       rectCenter - ToReferenceFrame())) {
 40570:     mList.HitTest(aBuilder, aRect, aState, aOutFrames);
 40570:   }
 19125: }
 19125: 
105566: void
105566: nsDisplaySVGEffects::PaintAsLayer(nsDisplayListBuilder* aBuilder,
105566:                                   nsRenderingContext* aCtx,
105566:                                   LayerManager* aManager)
 19125: {
105566:   nsSVGIntegrationUtils::PaintFramesWithEffects(aCtx, mFrame,
105566:                                                 mVisibleRect,
105566:                                                 aBuilder, aManager);
105566: }
105566: 
105566: LayerState
105566: nsDisplaySVGEffects::GetLayerState(nsDisplayListBuilder* aBuilder,
105566:                                    LayerManager* aManager,
105566:                                    const ContainerParameters& aParameters)
105566: {
105566:   return LAYER_SVG_EFFECTS;
105566: }
105566: 
105566: already_AddRefed<Layer>
105566: nsDisplaySVGEffects::BuildLayer(nsDisplayListBuilder* aBuilder,
105566:                                 LayerManager* aManager,
105566:                                 const ContainerParameters& aContainerParameters)
105566: {
105956:   const nsIContent* content = mFrame->GetContent();
105956:   bool hasSVGLayout = (mFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT);
105956:   if (hasSVGLayout) {
105956:     nsISVGChildFrame *svgChildFrame = do_QueryFrame(mFrame);
105956:     if (!svgChildFrame || !mFrame->GetContent()->IsSVG()) {
105956:       NS_ASSERTION(false, "why?");
106838:       return nullptr;
105956:     }
105956:     if (!static_cast<const nsSVGElement*>(content)->HasValidDimensions()) {
106838:       return nullptr; // The SVG spec says not to draw filters for this
105956:     }
105956:   }
105956: 
105566:   float opacity = mFrame->GetStyleDisplay()->mOpacity;
105566:   if (opacity == 0.0f)
106838:     return nullptr;
105566: 
105566:   nsIFrame* firstFrame =
105566:     nsLayoutUtils::GetFirstContinuationOrSpecialSibling(mFrame);
105566:   nsSVGEffects::EffectProperties effectProperties =
105566:     nsSVGEffects::GetEffectProperties(firstFrame);
105566: 
105566:   bool isOK = true;
105666:   effectProperties.GetClipPathFrame(&isOK);
105666:   effectProperties.GetMaskFrame(&isOK);
105666:   effectProperties.GetFilterFrame(&isOK);
105566: 
105566:   if (!isOK) {
106838:     return nullptr;
105566:   }
105566: 
108884:   nsRefPtr<ContainerLayer> container = aManager->GetLayerBuilder()->
105566:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, mList,
106838:                            aContainerParameters, nullptr);
105566: 
105566:   return container.forget();
 19125: }
 19125: 
 79445: bool nsDisplaySVGEffects::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                               nsRegion* aVisibleRegion,
 69802:                                               const nsRect& aAllowVisibleRegionExpansion) {
 95644:   nsPoint offset = ToReferenceFrame();
 34210:   nsRect dirtyRect =
 95644:     nsSVGIntegrationUtils::GetRequiredSourceForInvalidArea(mFrame,
 34210:                                                            mVisibleRect - offset) +
 34210:     offset;
 19125: 
 34210:   // Our children may be made translucent or arbitrarily deformed so we should
 34210:   // not allow them to subtract area from aVisibleRegion.
 34210:   nsRegion childrenVisible(dirtyRect);
 98137:   nsRect r = dirtyRect.Intersect(mList.GetBounds(aBuilder));
120128:   mList.ComputeVisibilityForSublist(aBuilder, this, &childrenVisible, r, nsRect());
 80486:   return true;
 19125: }
 19125: 
 79445: bool nsDisplaySVGEffects::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
 19125: {
 19125:   if (aItem->GetType() != TYPE_SVG_EFFECTS)
 80486:     return false;
 19125:   // items for the same content element should be merged into a single
 19125:   // compositing group
 19125:   // aItem->GetUnderlyingFrame() returns non-null because it's nsDisplaySVGEffects
 19125:   if (aItem->GetUnderlyingFrame()->GetContent() != mFrame->GetContent())
 80486:     return false;
 19125:   nsDisplaySVGEffects* other = static_cast<nsDisplaySVGEffects*>(aItem);
 95566:   MergeFromTrackingMergedFrames(other);
 95348:   mEffectsBounds.UnionRect(mEffectsBounds,
 95644:     other->mEffectsBounds + other->mFrame->GetOffsetTo(mFrame));
 80486:   return true;
 19125: }
 82353: 
 82353: #ifdef MOZ_DUMP_PAINTING
 82353: void
 82353: nsDisplaySVGEffects::PrintEffects(FILE* aOutput)
 82353: {
 82353:   nsIFrame* firstFrame =
 95644:     nsLayoutUtils::GetFirstContinuationOrSpecialSibling(mFrame);
 82353:   nsSVGEffects::EffectProperties effectProperties =
 82353:     nsSVGEffects::GetEffectProperties(firstFrame);
 82353:   bool isOK = true;
 82353:   nsSVGClipPathFrame *clipPathFrame = effectProperties.GetClipPathFrame(&isOK);
 82353:   bool first = true;
 82353:   fprintf(aOutput, " effects=(");
 95644:   if (mFrame->GetStyleDisplay()->mOpacity != 1.0f) {
 82353:     first = false;
 95644:     fprintf(aOutput, "opacity(%f)", mFrame->GetStyleDisplay()->mOpacity);
 82353:   }
 82353:   if (clipPathFrame) {
 82353:     if (!first) {
 82353:       fprintf(aOutput, ", ");
 82353:     }
 82353:     fprintf(aOutput, "clip(%s)", clipPathFrame->IsTrivial() ? "trivial" : "non-trivial");
 82353:     first = false;
 82353:   }
 82353:   if (effectProperties.GetFilterFrame(&isOK)) {
 82353:     if (!first) {
 82353:       fprintf(aOutput, ", ");
 82353:     }
 82353:     fprintf(aOutput, "filter");
 82353:     first = false;
 82353:   }
 82353:   if (effectProperties.GetMaskFrame(&isOK)) {
 82353:     if (!first) {
 82353:       fprintf(aOutput, ", ");
 82353:     }
 82353:     fprintf(aOutput, "mask");
 82353:   }
 82353:   fprintf(aOutput, ")");
 82353: }
 82353: #endif
 82353: 
