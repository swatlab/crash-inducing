126599: /* This Source Code Form is subject to the terms of the Mozilla Public
126599:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
126599:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
126599: 
126599: const { interfaces: Ci, classes: Cc, results: Cr, utils: Cu } = Components;
126599: 
126599: Cu.import("resource://gre/modules/Services.jsm");
126599: 
126599: var cps;
126599: var asyncRunner;
126599: var next;
126599: 
126599: (function init() {
126599:   // There has to be a profile directory before the CPS service is gotten.
126599:   do_get_profile();
126599: })();
126599: 
126599: function runAsyncTests(tests) {
126599:   do_test_pending();
126599: 
126599:   cps = Cc["@mozilla.org/content-pref/service;1"].
126599:         getService(Ci.nsIContentPrefService2);
126599: 
126599:   // Without this the private-browsing service tries to open a dialog when you
126599:   // change its enabled state.
126599:   Services.prefs.setBoolPref("browser.privatebrowsing.keep_current_session",
126599:                              true);
126599: 
126599:   let s = {};
126599:   Cu.import("resource://test/AsyncRunner.jsm", s);
126599:   asyncRunner = new s.AsyncRunner({
126599:     done: do_test_finished,
126599:     error: function (err) {
126599:       // xpcshell test functions like do_check_eq throw NS_ERROR_ABORT on
126599:       // failure.  Ignore those and catch only uncaught exceptions.
126599:       if (err !== Cr.NS_ERROR_ABORT) {
126599:         if (err.stack) {
126599:           err = err + "\n\nTraceback (most recent call first):\n" + err.stack +
126599:                       "\nUseless do_throw stack:";
126599:         }
126599:         do_throw(err);
126599:       }
126599:     },
126599:     consoleError: function (scriptErr) {
126599:       // As much as possible make sure the error is related to the test.  On the
126599:       // other hand if this fails to catch a test-related error, we'll hang.
126599:       let filename = scriptErr.sourceName || scriptErr.toString() || "";
126599:       if (/contentpref/i.test(filename))
126599:         do_throw(scriptErr);
126599:     }
126599:   });
126599: 
126599:   next = asyncRunner.next.bind(asyncRunner);
126599: 
126599:   do_register_cleanup(function () {
126599:     asyncRunner.destroy();
126599:     asyncRunner = null;
126599:   });
126599: 
126599:   tests.forEach(function (test) {
126599:     function gen() {
126599:       do_print("Running " + test.name);
126599:       yield test();
126599:       yield reset();
126599:     }
126599:     asyncRunner.appendIterator(gen());
126599:   });
126599: 
126599:   // reset() ends up calling asyncRunner.next(), starting the tests.
126599:   reset();
126599: }
126599: 
126599: function makeCallback(callbacks) {
126599:   callbacks = callbacks || {};
126599:   ["handleResult", "handleError"].forEach(function (meth) {
126599:     if (!callbacks[meth])
126599:       callbacks[meth] = function () {
126599:         do_throw(meth + " shouldn't be called.");
126599:       };
126599:   });
126599:   if (!callbacks.handleCompletion)
126599:     callbacks.handleCompletion = function (reason) {
126599:       do_check_eq(reason, Ci.nsIContentPrefCallback2.COMPLETE_OK);
126599:       next();
126599:     };
126599:   return callbacks;
126599: }
126599: 
126599: function do_check_throws(fn) {
126599:   let threw = false;
126599:   try {
126599:     fn();
126599:   }
126599:   catch (err) {
126599:     threw = true;
126599:   }
126599:   do_check_true(threw);
126599: }
126599: 
126599: function sendMessage(msg, callback) {
126599:   let obj = callback || {};
126599:   let ref = Cu.getWeakReference(obj);
126599:   cps.QueryInterface(Ci.nsIObserver).observe(ref, "test:" + msg, null);
126599:   return "value" in obj ? obj.value : undefined;
126599: }
126599: 
126599: function reset() {
126599:   sendMessage("reset", next);
126599: }
126599: 
126599: function set(group, name, val, context) {
126599:   cps.set(group, name, val, context, makeCallback());
126599: }
126599: 
126599: function setGlobal(name, val, context) {
126599:   cps.setGlobal(name, val, context, makeCallback());
126599: }
126599: 
126599: function prefOK(actual, expected, strict) {
126599:   do_check_true(actual instanceof Ci.nsIContentPref);
126599:   do_check_eq(actual.domain, expected.domain);
126599:   do_check_eq(actual.name, expected.name);
126599:   if (strict)
126599:     do_check_true(actual.value === expected.value);
126599:   else
126599:     do_check_eq(actual.value, expected.value);
126599: }
126599: 
126599: function getOK(args, expectedVal, expectedGroup, strict) {
126599:   if (args.length == 2)
126599:     args.push(undefined);
126599:   let expectedPrefs = expectedVal === undefined ? [] :
126599:                       [{ domain: expectedGroup || args[0],
126599:                          name: args[1],
126599:                          value: expectedVal }];
126599:   yield getOKEx("getByDomainAndName", args, expectedPrefs, strict);
126599: }
126599: 
126599: function getSubdomainsOK(args, expectedGroupValPairs) {
126599:   if (args.length == 2)
126599:     args.push(undefined);
126599:   let expectedPrefs = expectedGroupValPairs.map(function ([group, val]) {
126599:     return { domain: group, name: args[1], value: val };
126599:   });
126599:   yield getOKEx("getBySubdomainAndName", args, expectedPrefs);
126599: }
126599: 
126599: function getGlobalOK(args, expectedVal) {
126599:   if (args.length == 1)
126599:     args.push(undefined);
126599:   let expectedPrefs = expectedVal === undefined ? [] :
126599:                       [{ domain: null, name: args[0], value: expectedVal }];
126599:   yield getOKEx("getGlobal", args, expectedPrefs);
126599: }
126599: 
126599: function getOKEx(methodName, args, expectedPrefs, strict, context) {
126599:   let actualPrefs = [];
126599:   args.push(makeCallback({
126599:     handleResult: function (pref) actualPrefs.push(pref)
126599:   }));
126599:   yield cps[methodName].apply(cps, args);
126599:   arraysOfArraysOK([actualPrefs], [expectedPrefs], function (actual, expected) {
126599:     prefOK(actual, expected, strict);
126599:   });
126599: }
126599: 
126599: function getCachedOK(args, expectedIsCached, expectedVal, expectedGroup,
126599:                      strict) {
126599:   if (args.length == 2)
126599:     args.push(undefined);
126599:   let expectedPref = !expectedIsCached ? null : {
126599:     domain: expectedGroup || args[0],
126599:     name: args[1],
126599:     value: expectedVal
126599:   };
126599:   getCachedOKEx("getCachedByDomainAndName", args, expectedPref, strict);
126599: }
126599: 
126599: function getCachedSubdomainsOK(args, expectedGroupValPairs) {
126599:   if (args.length == 2)
126599:     args.push(undefined);
126599:   let len = {};
126599:   args.push(len);
126599:   let actualPrefs = cps.getCachedBySubdomainAndName.apply(cps, args);
126599:   do_check_eq(actualPrefs.length, len.value);
126599:   let expectedPrefs = expectedGroupValPairs.map(function ([group, val]) {
126599:     return { domain: group, name: args[1], value: val };
126599:   });
126599:   arraysOfArraysOK([actualPrefs], [expectedPrefs], prefOK);
126599: }
126599: 
126599: function getCachedGlobalOK(args, expectedIsCached, expectedVal) {
126599:   if (args.length == 1)
126599:     args.push(undefined);
126599:   let expectedPref = !expectedIsCached ? null : {
126599:     domain: null,
126599:     name: args[0],
126599:     value: expectedVal
126599:   };
126599:   getCachedOKEx("getCachedGlobal", args, expectedPref);
126599: }
126599: 
126599: function getCachedOKEx(methodName, args, expectedPref, strict) {
126599:   let actualPref = cps[methodName].apply(cps, args);
126599:   if (expectedPref)
126599:     prefOK(actualPref, expectedPref, strict);
126599:   else
126599:     do_check_true(actualPref === null);
126599: }
126599: 
126599: function arraysOfArraysOK(actual, expected, cmp) {
126599:   cmp = cmp || function (a, b) do_check_eq(a, b);
126599:   do_check_eq(actual.length, expected.length);
126599:   actual.forEach(function (actualChildArr, i) {
126599:     let expectedChildArr = expected[i];
126599:     do_check_eq(actualChildArr.length, expectedChildArr.length);
126599:     actualChildArr.forEach(function (actualElt, j) {
126599:       let expectedElt = expectedChildArr[j];
126599:       cmp(actualElt, expectedElt);
126599:     });
126599:   });
126599: }
126599: 
126599: function dbOK(expectedRows) {
126599:   let db = sendMessage("db");
126599:   let stmt = db.createAsyncStatement(
126599:     "SELECT groups.name AS grp, settings.name AS name, prefs.value AS value " +
126599:     "FROM prefs " +
126599:     "LEFT JOIN groups ON groups.id = prefs.groupID " +
126599:     "LEFT JOIN settings ON settings.id = prefs.settingID " +
126599:     "UNION " +
126599: 
126599:     // These second two SELECTs get the rows of the groups and settings tables
126599:     // that aren't referenced by the prefs table.  Neither should return any
126599:     // rows if the component is working properly.
126599:     "SELECT groups.name AS grp, NULL AS name, NULL AS value " +
126599:     "FROM groups " +
126599:     "WHERE id NOT IN (" +
126599:       "SELECT DISTINCT groupID " +
126599:       "FROM prefs " +
126599:       "WHERE groupID NOTNULL" +
126599:     ") " +
126599:     "UNION " +
126599:     "SELECT NULL AS grp, settings.name AS name, NULL AS value " +
126599:     "FROM settings " +
126599:     "WHERE id NOT IN (" +
126599:       "SELECT DISTINCT settingID " +
126599:       "FROM prefs " +
126599:       "WHERE settingID NOTNULL" +
126599:     ") " +
126599: 
126599:     "ORDER BY value ASC, grp ASC, name ASC"
126599:   );
126599: 
126599:   let actualRows = [];
126599:   let cols = ["grp", "name", "value"];
126599: 
126599:   db.executeAsync([stmt], 1, {
126599:     handleCompletion: function (reason) {
126599:       arraysOfArraysOK(actualRows, expectedRows);
126599:       next();
126599:     },
126599:     handleResult: function (results) {
126599:       let row = null;
126599:       while (row = results.getNextRow()) {
126599:         actualRows.push(cols.map(function (c) row.getResultByName(c)));
126599:       }
126599:     },
126599:     handleError: function (err) {
126599:       do_throw(err);
126599:     }
126599:   });
126599:   stmt.finalize();
126599: }
126599: 
137506: function on(event, names) {
126599:   let args = {
126599:     reset: function () {
126599:       for (let prop in this) {
126599:         if (Array.isArray(this[prop]))
126599:           this[prop].splice(0, this[prop].length);
126599:       }
126599:     },
137506:     destroy: function () {
137506:       names.forEach(function (n) cps.removeObserverForName(n, observers[n]));
137506:     },
126599:   };
126599: 
126599:   let observers = {};
126599: 
126599:   names.forEach(function (name) {
126599:     let obs = {};
126599:     ["onContentPrefSet", "onContentPrefRemoved"].forEach(function (meth) {
126599:       obs[meth] = function () do_throw(meth + " should not be called");
126599:     });
126599:     obs["onContentPref" + event] = function () {
126599:       args[name].push(Array.slice(arguments));
126599:     };
126599:     observers[name] = obs;
126599:     args[name] = [];
126599:     args[name].observer = obs;
126599:     cps.addObserverForName(name, obs);
126599:   });
126599: 
137506:   return args;
126599: }
126599: 
126599: function observerArgsOK(actualArgs, expectedArgs) {
126599:   do_check_neq(actualArgs, undefined);
126599:   arraysOfArraysOK(actualArgs, expectedArgs);
126599: }
