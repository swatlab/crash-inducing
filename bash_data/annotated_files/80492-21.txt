    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=80: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
77154:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* container for a document and its presentation */
    1: 
    1: #include "nscore.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsCRT.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsISupports.h"
    1: #include "nsIContent.h"
    1: #include "nsIContentViewerContainer.h"
80401: #include "nsIContentViewer.h"
41653: #include "mozilla/FunctionTimer.h"
    1: #include "nsIDocumentViewerPrint.h"
29522: #include "nsIPrivateDOMEvent.h"
29522: #include "nsIDOMBeforeUnloadEvent.h"
    1: #include "nsIDocument.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsStyleSet.h"
    1: #include "nsIStyleSheet.h"
42163: #include "nsCSSStyleSheet.h"
    1: #include "nsIFrame.h"
54315: #include "nsSubDocumentFrame.h"
    1: 
    1: #include "nsILinkHandler.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsISelectionListener.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMHTMLCollection.h"
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsContentCID.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsContentUtils.h"
    1: #include "nsLayoutStylesheetCache.h"
70976: #include "mozilla/Preferences.h"
    1: 
    1: #include "nsViewsCID.h"
    1: #include "nsIDeviceContextSpec.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIView.h"
    1: 
    1: #include "nsIPageSequenceFrame.h"
    1: #include "nsIURL.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIContentViewerEdit.h"
    1: #include "nsIContentViewerFile.h"
47937: #include "mozilla/css/Loader.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeNode.h"
    1: #include "nsIDocShellTreeOwner.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsIParser.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsHTMLReflowState.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMHTMLAreaElement.h"
    1: #include "nsIDOMHTMLLinkElement.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsCopySupport.h"
    1: #include "nsIDOMHTMLFrameSetElement.h"
    1: #ifdef MOZ_XUL
    1: #include "nsIXULDocument.h"
 3799: #include "nsXULPopupManager.h"
    1: #endif
    1: 
    1: #include "nsIClipboardHelper.h"
    1: 
    1: #include "nsPIDOMWindow.h"
72298: #include "nsDOMNavigationTiming.h"
38336: #include "nsPIWindowRoot.h"
    1: #include "nsJSEnvironment.h"
29018: #include "nsFocusManager.h"
    1: 
37067: #include "nsIScrollableFrame.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsGfxCIID.h"
    1: #include "nsStyleSheetService.h"
25034: #include "nsURILoader.h"
68487: #include "nsRenderingContext.h"
    1: 
    1: #include "nsIPrompt.h"
    1: #include "imgIContainer.h" // image animation mode constants
    1: 
    1: //--------------------------
    1: // Printing Include
    1: //---------------------------
    1: #ifdef NS_PRINTING
    1: 
    1: #include "nsIWebBrowserPrint.h"
    1: 
    1: #include "nsPrintEngine.h"
    1: 
    1: // Print Options
    1: #include "nsIPrintSettings.h"
    1: #include "nsIPrintSettingsService.h"
    1: #include "nsIPrintOptions.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsISimpleEnumerator.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: 
    1: // PrintOptions is now implemented by PrintSettingsService
    1: static const char sPrintOptionsContractID[]         = "@mozilla.org/gfx/printsettings-service;1";
    1: 
    1: // Printing Events
    1: #include "nsPrintPreviewListener.h"
    1: 
    1: #include "nsIDOMHTMLFrameElement.h"
    1: #include "nsIDOMHTMLIFrameElement.h"
    1: #include "nsIDOMHTMLObjectElement.h"
    1: #include "nsIPluginDocument.h"
    1: 
    1: // Print Progress
    1: #include "nsIPrintProgress.h"
    1: #include "nsIPrintProgressParams.h"
    1: 
    1: // Print error dialog
    1: #include "nsIWindowWatcher.h"
    1: 
    1: // Printing 
    1: #include "nsPrintEngine.h"
    1: #include "nsPagePrintTimer.h"
    1: 
    1: #endif // NS_PRINTING
    1: 
    1: // FrameSet
    1: #include "nsIDocument.h"
    1: 
    1: //focus
 1418: #include "nsIDOMEventTarget.h"
72631: #include "nsIDOMEventListener.h"
    1: #include "nsISelectionController.h"
    1: 
    1: #include "nsBidiUtils.h"
    1: #include "nsISHEntry.h"
    1: #include "nsISHistory.h"
    1: #include "nsISHistoryInternal.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsWeakPtr.h"
    1: #include "nsEventDispatcher.h"
    1: 
    1: //paint forcing
    1: #include "prenv.h"
    1: #include <stdio.h>
    1: 
    1: //switch to page layout
    1: #include "nsGfxCIID.h"
    1: 
74131: #include "mozilla/dom/Element.h"
74131: 
70976: using namespace mozilla;
70976: 
    1: #ifdef NS_DEBUG
    1: 
    1: #undef NOISY_VIEWER
    1: #else
    1: #undef NOISY_VIEWER
    1: #endif
    1: 
    1: //-----------------------------------------------------
    1: // PR LOGGING
    1: #ifdef MOZ_LOGGING
    1: #define FORCE_PR_LOG /* Allow logging in the release build */
    1: #endif
    1: 
    1: #include "prlog.h"
    1: 
    1: #ifdef PR_LOGGING
    1: 
    1: static PRLogModuleInfo * kPrintingLogMod = PR_NewLogModule("printing");
    1: #define PR_PL(_p1)  PR_LOG(kPrintingLogMod, PR_LOG_DEBUG, _p1);
    1: 
    1: #define PRT_YESNO(_p) ((_p)?"YES":"NO")
    1: #else
    1: #define PRT_YESNO(_p)
    1: #define PR_PL(_p1)
    1: #endif
    1: //-----------------------------------------------------
    1: 
    1: class DocumentViewerImpl;
    1: 
    1: // a small delegate class used to avoid circular references
    1: 
    1: class nsDocViewerSelectionListener : public nsISelectionListener
    1: {
    1: public:
    1: 
    1:   // nsISupports interface...
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsISelectionListerner interface
    1:   NS_DECL_NSISELECTIONLISTENER
    1: 
    1:                        nsDocViewerSelectionListener()
    1:                        : mDocViewer(NULL)
80486:                        , mGotSelectionState(false)
80486:                        , mSelectionWasCollapsed(false)
    1:                        {
    1:                        }
    1: 
    1:   virtual              ~nsDocViewerSelectionListener() {}
    1: 
    1:   nsresult             Init(DocumentViewerImpl *aDocViewer);
    1: 
    1: protected:
    1: 
    1:   DocumentViewerImpl*  mDocViewer;
79445:   bool                 mGotSelectionState;
79445:   bool                 mSelectionWasCollapsed;
    1: 
    1: };
    1: 
    1: 
    1: /** editor Implementation of the FocusListener interface
    1:  */
72631: class nsDocViewerFocusListener : public nsIDOMEventListener
    1: {
    1: public:
    1:   /** default constructor
    1:    */
    1:   nsDocViewerFocusListener();
    1:   /** default destructor
    1:    */
    1:   virtual ~nsDocViewerFocusListener();
    1: 
    1:   NS_DECL_ISUPPORTS
72631:   NS_DECL_NSIDOMEVENTLISTENER
72631: 
    1:   nsresult             Init(DocumentViewerImpl *aDocViewer);
    1: 
    1: private:
    1:     DocumentViewerImpl*  mDocViewer;
    1: };
    1: 
    1: 
    1: //-------------------------------------------------------------
80401: class DocumentViewerImpl : public nsIContentViewer,
    1:                            public nsIContentViewerEdit,
    1:                            public nsIContentViewerFile,
71056:                            public nsIMarkupDocumentViewer,
    1:                            public nsIDocumentViewerPrint
    1: 
    1: #ifdef NS_PRINTING
    1:                            , public nsIWebBrowserPrint
    1: #endif
    1: 
    1: {
    1:   friend class nsDocViewerSelectionListener;
    1:   friend class nsPagePrintTimer;
    1:   friend class nsPrintEngine;
    1: 
    1: public:
    1:   DocumentViewerImpl();
    1: 
    1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
    1: 
    1:   // nsISupports interface...
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIContentViewer interface...
    1:   NS_DECL_NSICONTENTVIEWER
    1: 
    1:   // nsIContentViewerEdit
    1:   NS_DECL_NSICONTENTVIEWEREDIT
    1: 
    1:   // nsIContentViewerFile
    1:   NS_DECL_NSICONTENTVIEWERFILE
    1: 
    1:   // nsIMarkupDocumentViewer
    1:   NS_DECL_NSIMARKUPDOCUMENTVIEWER
    1: 
    1: #ifdef NS_PRINTING
    1:   // nsIWebBrowserPrint
    1:   NS_DECL_NSIWEBBROWSERPRINT
    1: #endif
    1: 
    1:   typedef void (*CallChildFunc)(nsIMarkupDocumentViewer* aViewer,
    1:                                 void* aClosure);
    1:   void CallChildren(CallChildFunc aFunc, void* aClosure);
    1: 
    1:   // nsIDocumentViewerPrint Printing Methods
    1:   NS_DECL_NSIDOCUMENTVIEWERPRINT
    1: 
69880: 
69880:   static void DispatchBeforePrint(nsIDocument* aTop)
69880:   {
69880:     DispatchEventToWindowTree(aTop, NS_LITERAL_STRING("beforeprint"));
69880:   }
69880:   static void DispatchAfterPrint(nsIDocument* aTop)
69880:   {
69880:     DispatchEventToWindowTree(aTop, NS_LITERAL_STRING("afterprint"));
69880:   }
69880:   static void DispatchEventToWindowTree(nsIDocument* aTop,
69880:                                         const nsAString& aEvent);
69880: 
    1: protected:
    1:   virtual ~DocumentViewerImpl();
    1: 
    1: private:
 8519:   /**
 8519:    * Creates a view manager, root view, and widget for the root view, setting
 8519:    * mViewManager and mWindow.
 8519:    * @param aSize the initial size in appunits
30513:    * @param aContainerView the container view to hook our root view up
30513:    * to as a child, or null if this will be the root view manager
 8519:    */
30513:   nsresult MakeWindow(const nsSize& aSize, nsIView* aContainerView);
30513: 
30513:   /**
17009:    * Create our device context
17009:    */
30537:   nsresult CreateDeviceContext(nsIView* aContainerView);
17009: 
17009:   /**
30537:    * If aDoCreation is true, this creates the device context, creates a
30537:    * prescontext if necessary, and calls MakeWindow.
61100:    *
61100:    * If aForceSetNewDocument is false, then SetNewDocument won't be
61100:    * called if the window's current document is already mDocument.
17009:    */
    1:   nsresult InitInternal(nsIWidget* aParentWidget,
    1:                         nsISupports *aState,
23738:                         const nsIntRect& aBounds,
79445:                         bool aDoCreation,
79445:                         bool aNeedMakeCX = true,
79445:                         bool aForceSetNewDocument = true);
10100:   /**
10100:    * @param aDoInitialReflow set to true if you want to kick off the initial
10100:    * reflow
10100:    */
79445:   nsresult InitPresentationStuff(bool aDoInitialReflow);
    1: 
    1:   nsresult GetPopupNode(nsIDOMNode** aNode);
    1:   nsresult GetPopupLinkNode(nsIDOMNode** aNode);
    1:   nsresult GetPopupImageNode(nsIImageLoadingContent** aNode);
    1: 
    1:   void PrepareToStartLoad(void);
    1: 
    1:   nsresult SyncParentSubDocMap();
    1: 
    1:   nsresult GetDocumentSelection(nsISelection **aSelection);
    1: 
23902:   void DestroyPresShell();
61100:   void DestroyPresContext();
23902: 
    1: #ifdef NS_PRINTING
    1:   // Called when the DocViewer is notified that the state
    1:   // of Printing or PP has changed
    1:   void SetIsPrintingInDocShellTree(nsIDocShellTreeNode* aParentNode, 
79445:                                    bool                 aIsPrintingOrPP, 
79445:                                    bool                 aStartAtTop);
    1: #endif // NS_PRINTING
    1: 
62248:   // Whether we should attach to the top level widget. This is true if we
62248:   // are sharing/recycling a single base widget and not creating multiple
62248:   // child widgets.
79445:   bool ShouldAttachToTopLevel();
62248: 
    1: protected:
 7740:   // These return the current shell/prescontext etc.
 7740:   nsIPresShell* GetPresShell();
 7740:   nsPresContext* GetPresContext();
 7740:   nsIViewManager* GetViewManager();
 7740: 
46194:   void DetachFromTopLevelWidget();
46194: 
    1:   // IMPORTANT: The ownership implicit in the following member
    1:   // variables has been explicitly checked and set using nsCOMPtr
    1:   // for owning pointers and raw COM interface pointers for weak
    1:   // (ie, non owning) references. If you add any members to this
    1:   // class, please make the ownership explicit (pinkerton, scc).
    1: 
    1:   nsWeakPtr mContainer; // it owns me!
63709:   nsWeakPtr mTopContainerWhilePrinting;
68668:   nsRefPtr<nsDeviceContext> mDeviceContext;  // We create and own this baby
    1: 
    1:   // the following six items are explicitly in this order
    1:   // so they will be destroyed in the reverse order (pinkerton, scc)
    1:   nsCOMPtr<nsIDocument>    mDocument;
30537:   nsCOMPtr<nsIWidget>      mWindow;      // may be null
    1:   nsCOMPtr<nsIViewManager> mViewManager;
39823:   nsRefPtr<nsPresContext>  mPresContext;
    1:   nsCOMPtr<nsIPresShell>   mPresShell;
    1: 
    1:   nsCOMPtr<nsISelectionListener> mSelectionListener;
72631:   nsRefPtr<nsDocViewerFocusListener> mFocusListener;
    1: 
    1:   nsCOMPtr<nsIContentViewer> mPreviousViewer;
    1:   nsCOMPtr<nsISHEntry> mSHEntry;
    1: 
19869:   nsIWidget* mParentWidget; // purposely won't be ref counted.  May be null
79445:   bool mAttachedToParent; // view is attached to the parent widget
    1: 
30537:   nsIntRect mBounds;
30537: 
 7780:   // mTextZoom/mPageZoom record the textzoom/pagezoom of the first (galley)
 7780:   // presshell only.
    1:   float mTextZoom;      // Text zoom, defaults to 1.0
 5357:   float mPageZoom;
63383:   int mMinFontSize;
    1: 
    1:   PRInt16 mNumURLStarts;
    1:   PRInt16 mDestroyRefCount;    // a second "refcount" for the document viewer's "destroy"
    1: 
    1:   unsigned      mStopped : 1;
    1:   unsigned      mLoaded : 1;
    1:   unsigned      mDeferredWindowClose : 1;
    1:   // document management data
    1:   //   these items are specific to markup documents (html and xml)
    1:   //   may consider splitting these out into a subclass
    1:   unsigned      mIsSticky : 1;
    1:   unsigned      mInPermitUnload : 1;
    1: 
    1: #ifdef NS_PRINTING
    1:   unsigned      mClosingWhilePrinting : 1;
    1: 
    1: #if NS_PRINT_PREVIEW
25840:   unsigned                         mPrintPreviewZoomed : 1;
25840: 
    1:   // These data members support delayed printing when the document is loading
    1:   unsigned                         mPrintIsPending : 1;
    1:   unsigned                         mPrintDocIsFullyLoaded : 1;
    1:   nsCOMPtr<nsIPrintSettings>       mCachedPrintSettings;
    1:   nsCOMPtr<nsIWebProgressListener> mCachedPrintWebProgressListner;
    1: 
    1:   nsCOMPtr<nsPrintEngine>          mPrintEngine;
25840:   float                            mOriginalPrintPreviewScale;
25840:   float                            mPrintPreviewZoom;
    1: #endif // NS_PRINT_PREVIEW
    1: 
    1: #ifdef NS_DEBUG
    1:   FILE* mDebugFile;
    1: #endif // NS_DEBUG
    1: #endif // NS_PRINTING
    1: 
    1:   /* character set member data */
    1:   PRInt32 mHintCharsetSource;
    1:   nsCString mHintCharset;
    1:   nsCString mDefaultCharacterSet;
    1:   nsCString mForceCharacterSet;
    1:   nsCString mPrevDocCharacterSet;
    1:   
79445:   bool mIsPageMode;
79445:   bool mCallerIsClosingWindow;
79445:   bool mInitializedForPrintPreview;
79445:   bool mHidden;
    1: };
    1: 
69880: class nsPrintEventDispatcher
69880: {
69880: public:
69880:   nsPrintEventDispatcher(nsIDocument* aTop) : mTop(aTop)
69880:   {
69880:     DocumentViewerImpl::DispatchBeforePrint(mTop);
69880:   }
69880:   ~nsPrintEventDispatcher()
69880:   {
69880:     DocumentViewerImpl::DispatchAfterPrint(mTop);
69880:   }
69880: 
69880:   nsCOMPtr<nsIDocument> mTop;
69880: };
69880: 
69880: 
    1: //------------------------------------------------------------------
    1: // DocumentViewerImpl
    1: //------------------------------------------------------------------
    1: // Class IDs
    1: static NS_DEFINE_CID(kViewManagerCID,       NS_VIEW_MANAGER_CID);
    1: 
    1: //------------------------------------------------------------------
    1: nsresult
80401: NS_NewContentViewer(nsIContentViewer** aResult)
    1: {
    1:   *aResult = new DocumentViewerImpl();
    1: 
    1:   NS_ADDREF(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void DocumentViewerImpl::PrepareToStartLoad()
    1: {
80486:   mStopped          = false;
80486:   mLoaded           = false;
80486:   mAttachedToParent = false;
80486:   mDeferredWindowClose = false;
80486:   mCallerIsClosingWindow = false;
    1: 
    1: #ifdef NS_PRINTING
80486:   mPrintIsPending        = false;
80486:   mPrintDocIsFullyLoaded = false;
80486:   mClosingWhilePrinting  = false;
    1: 
    1:   // Make sure we have destroyed it and cleared the data member
    1:   if (mPrintEngine) {
    1:     mPrintEngine->Destroy();
    1:     mPrintEngine = nsnull;
    1: #ifdef NS_PRINT_PREVIEW
80486:     SetIsPrintPreview(false);
    1: #endif
35581:   }
    1: 
    1: #ifdef NS_DEBUG
    1:   mDebugFile = nsnull;
    1: #endif
    1: 
    1: #endif // NS_PRINTING
    1: }
    1: 
    1: // Note: operator new zeros our memory, so no need to init things to null.
    1: DocumentViewerImpl::DocumentViewerImpl()
63383:   : mTextZoom(1.0), mPageZoom(1.0), mMinFontSize(0),
80486:     mIsSticky(true),
25840: #ifdef NS_PRINT_PREVIEW
25840:     mPrintPreviewZoom(1.0),
25840: #endif
35581:     mHintCharsetSource(kCharsetUninitialized),
80486:     mInitializedForPrintPreview(false),
80486:     mHidden(false)
    1: {
    1:   PrepareToStartLoad();
    1: }
    1: 
    1: NS_IMPL_ADDREF(DocumentViewerImpl)
    1: NS_IMPL_RELEASE(DocumentViewerImpl)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(DocumentViewerImpl)
    1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewer)
    1:     NS_INTERFACE_MAP_ENTRY(nsIMarkupDocumentViewer)
    1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewerFile)
    1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewerEdit)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocumentViewerPrint)
    1:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContentViewer)
    1: #ifdef NS_PRINTING
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebBrowserPrint)
    1: #endif
    1: NS_INTERFACE_MAP_END
    1: 
    1: DocumentViewerImpl::~DocumentViewerImpl()
    1: {
    1:   if (mDocument) {
    1:     Close(nsnull);
    1:     mDocument->Destroy();
    1:   }
    1: 
    1:   NS_ASSERTION(!mPresShell && !mPresContext,
    1:                "User did not call nsIContentViewer::Destroy");
    1:   if (mPresShell || mPresContext) {
    1:     // Make sure we don't hand out a reference to the content viewer to
    1:     // the SHEntry!
    1:     mSHEntry = nsnull;
    1: 
    1:     Destroy();
    1:   }
    1: 
    1:   // XXX(?) Revoke pending invalidate events
    1: }
    1: 
    1: /*
    1:  * This method is called by the Document Loader once a document has
    1:  * been created for a particular data stream...  The content viewer
    1:  * must cache this document for later use when Init(...) is called.
    1:  *
    1:  * This method is also called when an out of band document.write() happens.
    1:  * In that case, the document passed in is the same as the previous document.
    1:  */
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::LoadStart(nsISupports *aDoc)
    1: {
    1: #ifdef NOISY_VIEWER
    1:   printf("DocumentViewerImpl::LoadStart\n");
    1: #endif
    1: 
    1:   nsresult rv = NS_OK;
    1:   if (!mDocument) {
    1:     mDocument = do_QueryInterface(aDoc, &rv);
    1:   }
    1:   else if (mDocument == aDoc) {
    1:     // Reset the document viewer's state back to what it was
    1:     // when the document load started.
    1:     PrepareToStartLoad();
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: DocumentViewerImpl::SyncParentSubDocMap()
    1: {
    1:   nsCOMPtr<nsIDocShellTreeItem> item(do_QueryReferent(mContainer));
    1:   nsCOMPtr<nsPIDOMWindow> pwin(do_GetInterface(item));
    1:   nsCOMPtr<nsIContent> content;
    1: 
    1:   if (mDocument && pwin) {
    1:     content = do_QueryInterface(pwin->GetFrameElementInternal());
    1:   }
    1: 
    1:   if (content) {
    1:     nsCOMPtr<nsIDocShellTreeItem> parent;
    1:     item->GetParent(getter_AddRefs(parent));
    1: 
    1:     nsCOMPtr<nsIDOMWindow> parent_win(do_GetInterface(parent));
    1: 
    1:     if (parent_win) {
    1:       nsCOMPtr<nsIDOMDocument> dom_doc;
    1:       parent_win->GetDocument(getter_AddRefs(dom_doc));
    1: 
    1:       nsCOMPtr<nsIDocument> parent_doc(do_QueryInterface(dom_doc));
    1: 
    1:       if (parent_doc) {
25722:         if (mDocument && parent_doc->GetSubDocumentFor(content) != mDocument) {
25722:           mDocument->SuppressEventHandling(parent_doc->EventHandlingSuppressed());
25722:         }
    1:         return parent_doc->SetSubDocumentFor(content, mDocument);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::SetContainer(nsISupports* aContainer)
    1: {
    1:   mContainer = do_GetWeakReference(aContainer);
    1:   if (mPresContext) {
    1:     mPresContext->SetContainer(aContainer);
    1:   }
    1: 
    1:   // We're loading a new document into the window where this document
    1:   // viewer lives, sync the parent document's frame element -> sub
    1:   // document map
    1: 
    1:   return SyncParentSubDocMap();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::GetContainer(nsISupports** aResult)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aResult);
    1: 
    1:    *aResult = nsnull;
    1:    nsCOMPtr<nsISupports> container = do_QueryReferent(mContainer);
    1:    container.swap(*aResult);
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::Init(nsIWidget* aParentWidget,
23738:                          const nsIntRect& aBounds)
    1: {
80486:   return InitInternal(aParentWidget, nsnull, aBounds, true);
    1: }
    1: 
    1: nsresult
79445: DocumentViewerImpl::InitPresentationStuff(bool aDoInitialReflow)
    1: {
35581:   if (GetIsPrintPreview())
35581:     return NS_OK;
35581: 
23902:   NS_ASSERTION(!mPresShell,
23902:                "Someone should have destroyed the presshell!");
23902: 
    1:   // Create the style set...
    1:   nsStyleSet *styleSet;
    1:   nsresult rv = CreateStyleSet(mDocument, &styleSet);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Now make the shell for the document
    1:   rv = mDocument->CreateShell(mPresContext, mViewManager, styleSet,
    1:                               getter_AddRefs(mPresShell));
    1:   if (NS_FAILED(rv)) {
    1:     delete styleSet;
    1:     return rv;
    1:   }
    1: 
    1:   // We're done creating the style set
    1:   styleSet->EndUpdate();
    1: 
    1:   if (aDoInitialReflow) {
    1:     // Since InitialReflow() will create frames for *all* items
    1:     // that are currently in the document tree, we need to flush
    1:     // any pending notifications to prevent the content sink from
    1:     // duplicating layout frames for content it has added to the tree
    1:     // but hasn't notified the document about. (Bug 154018)
    1:     //
    1:     // Note that we are flushing before we add mPresShell as an observer
    1:     // to avoid bogus notifications.
    1: 
    1:     mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
    1:   }
    1: 
    1:   mPresShell->BeginObservingDocument();
    1: 
    1:   // Initialize our view manager
30537:   nscoord width = mPresContext->DeviceContext()->UnscaledAppUnitsPerDevPixel() * mBounds.width;
30537:   nscoord height = mPresContext->DeviceContext()->UnscaledAppUnitsPerDevPixel() * mBounds.height;
    1: 
    1:   mViewManager->SetWindowDimensions(width, height);
    1:   mPresContext->SetTextZoom(mTextZoom);
 5357:   mPresContext->SetFullZoom(mPageZoom);
63383:   mPresContext->SetMinFontSize(mMinFontSize);
    1: 
    1:   if (aDoInitialReflow) {
    1:     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
    1:     if (htmlDoc) {
    1:       nsCOMPtr<nsIDOMHTMLFrameSetElement> frameset =
41634:         do_QueryInterface(mDocument->GetRootElement());
    1:       htmlDoc->SetIsFrameset(frameset != nsnull);
    1:     }
    1: 
 1416:     nsCOMPtr<nsIPresShell> shellGrip = mPresShell;
    1:     // Initial reflow
    1:     mPresShell->InitialReflow(width, height);
    1:   } else {
    1:     // Store the visible area so it's available for other callers of
    1:     // InitialReflow, like nsContentSink::StartLayout.
    1:     mPresContext->SetVisibleArea(nsRect(0, 0, width, height));
    1:   }
    1: 
    1:   // now register ourselves as a selection listener, so that we get
    1:   // called when the selection changes in the window
23902:   if (!mSelectionListener) {
    1:     nsDocViewerSelectionListener *selectionListener =
    1:       new nsDocViewerSelectionListener();
    1: 
    1:     selectionListener->Init(this);
    1: 
    1:     // mSelectionListener is a owning reference
    1:     mSelectionListener = selectionListener;
23902:   }
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   rv = GetDocumentSelection(getter_AddRefs(selection));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsISelectionPrivate> selPrivate(do_QueryInterface(selection));
    1:   rv = selPrivate->AddSelectionListener(mSelectionListener);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // Save old listener so we can unregister it
72631:   nsRefPtr<nsDocViewerFocusListener> oldFocusListener = mFocusListener;
    1: 
    1:   // focus listener
    1:   //
    1:   // now register ourselves as a focus listener, so that we get called
    1:   // when the focus changes in the window
47223:   nsDocViewerFocusListener *focusListener = new nsDocViewerFocusListener();
    1: 
    1:   focusListener->Init(this);
    1: 
    1:   // mFocusListener is a strong reference
    1:   mFocusListener = focusListener;
    1: 
 1418:   if (mDocument) {
72631:     mDocument->AddEventListener(NS_LITERAL_STRING("focus"),
72631:                                 mFocusListener,
80486:                                 false, false);
72631:     mDocument->AddEventListener(NS_LITERAL_STRING("blur"),
72631:                                 mFocusListener,
80486:                                 false, false);
72631: 
10100:     if (oldFocusListener) {
72631:       mDocument->RemoveEventListener(NS_LITERAL_STRING("focus"),
80486:                                      oldFocusListener, false);
72631:       mDocument->RemoveEventListener(NS_LITERAL_STRING("blur"),
80486:                                      oldFocusListener, false);
    1:     }
    1:   }
    1: 
42357:   if (aDoInitialReflow && mDocument) {
42357:     mDocument->ScrollToRef();
42357:   }
42357: 
    1:   return NS_OK;
    1: }
    1: 
30514: static nsPresContext*
30514: CreatePresContext(nsIDocument* aDocument,
30514:                   nsPresContext::nsPresContextType aType,
30514:                   nsIView* aContainerView)
30514: {
30514:   if (aContainerView)
30514:     return new nsPresContext(aDocument, aType);
30514:   return new nsRootPresContext(aDocument, aType);
30514: }
30514: 
    1: //-----------------------------------------------
    1: // This method can be used to initial the "presentation"
    1: // The aDoCreation indicates whether it should create
    1: // all the new objects or just initialize the existing ones
    1: nsresult
    1: DocumentViewerImpl::InitInternal(nsIWidget* aParentWidget,
    1:                                  nsISupports *aState,
23738:                                  const nsIntRect& aBounds,
79445:                                  bool aDoCreation,
79445:                                  bool aNeedMakeCX /*= true*/,
79445:                                  bool aForceSetNewDocument /* = true*/)
    1: {
61100:   if (mIsPageMode) {
80486:     // XXXbz should the InitInternal in SetPageMode just pass false
61100:     // here itself?
80486:     aForceSetNewDocument = false;
61100:   }
61100: 
35158:   // We don't want any scripts to run here. That can cause flushing,
35158:   // which can cause reentry into initialization of this document viewer,
35158:   // which would be disastrous.
35158:   nsAutoScriptBlocker blockScripts;
35158: 
    1:   mParentWidget = aParentWidget; // not ref counted
30537:   mBounds = aBounds;
    1: 
    1:   nsresult rv = NS_OK;
    1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NULL_POINTER);
    1: 
30513:   nsIView* containerView = FindContainerView();
30513: 
79445:   bool makeCX = false;
    1:   if (aDoCreation) {
30537:     nsresult rv = CreateDeviceContext(containerView);
30537:     NS_ENSURE_SUCCESS(rv, rv);
30537: 
20078:     // XXXbz this is a nasty hack to do with the fact that we create
20078:     // presentations both in Init() and in Show()...  Ideally we would only do
20078:     // it in one place (Show()) and require that callers call init(), open(),
20078:     // show() in that order or something.
30537:     if (!mPresContext &&
52207:         (aParentWidget || containerView || mDocument->IsBeingUsedAsImage() ||
49570:          (mDocument->GetDisplayDocument() &&
49570:           mDocument->GetDisplayDocument()->GetShell()))) {
    1:       // Create presentation context
    1:       if (mIsPageMode) {
    1:         //Presentation context already created in SetPageMode which is calling this method
30514:       } else {
30514:         mPresContext = CreatePresContext(mDocument,
30514:             nsPresContext::eContext_Galley, containerView);
30514:       }
    1:       NS_ENSURE_TRUE(mPresContext, NS_ERROR_OUT_OF_MEMORY);
    1: 
17009:       nsresult rv = mPresContext->Init(mDeviceContext); 
    1:       if (NS_FAILED(rv)) {
    1:         mPresContext = nsnull;
    1:         return rv;
    1:       }
    1: 
    1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
    1:       makeCX = !GetIsPrintPreview() && aNeedMakeCX; // needs to be true except when we are already in PP or we are enabling/disabling paginated mode.
    1: #else
80486:       makeCX = true;
    1: #endif
    1:     }
    1: 
    1:     if (mPresContext) {
    1:       // Create the ViewManager and Root View...
    1: 
    1:       // We must do this before we tell the script global object about
    1:       // this new document since doing that will cause us to re-enter
    1:       // into nsSubDocumentFrame code through reflows caused by
    1:       // FlushPendingNotifications() calls down the road...
    1: 
 8519:       rv = MakeWindow(nsSize(mPresContext->DevPixelsToAppUnits(aBounds.width),
30513:                              mPresContext->DevPixelsToAppUnits(aBounds.height)),
30513:                       containerView);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:       Hide();
    1: 
    1: #ifdef NS_PRINT_PREVIEW
    1:       if (mIsPageMode) {
    1:         // I'm leaving this in a broken state for the moment; we should
    1:         // be measuring/scaling with the print device context, not the
    1:         // screen device context, but this is good enough to allow
    1:         // printing reftests to work.
 3540:         double pageWidth = 0, pageHeight = 0;
 3540:         mPresContext->GetPrintSettings()->GetEffectivePageSize(&pageWidth,
    1:                                                                &pageHeight);
    1:         mPresContext->SetPageSize(
50791:           nsSize(mPresContext->CSSTwipsToAppUnits(NSToIntFloor(pageWidth)),
50791:                  mPresContext->CSSTwipsToAppUnits(NSToIntFloor(pageHeight))));
80486:         mPresContext->SetIsRootPaginatedDocument(true);
    1:         mPresContext->SetPageScale(1.0f);
    1:       }
    1: #endif
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIInterfaceRequestor> requestor(do_QueryReferent(mContainer));
    1:   if (requestor) {
    1:     if (mPresContext) {
    1:       nsCOMPtr<nsILinkHandler> linkHandler;
    1:       requestor->GetInterface(NS_GET_IID(nsILinkHandler),
    1:                               getter_AddRefs(linkHandler));
    1: 
    1:       mPresContext->SetContainer(requestor);
    1:       mPresContext->SetLinkHandler(linkHandler);
    1:     }
    1: 
    1:     // Set script-context-owner in the document
    1: 
    1:     nsCOMPtr<nsPIDOMWindow> window;
    1:     requestor->GetInterface(NS_GET_IID(nsPIDOMWindow),
    1:                             getter_AddRefs(window));
    1: 
    1:     if (window) {
39705:       nsCOMPtr<nsIDocument> curDoc =
39705:         do_QueryInterface(window->GetExtantDocument());
61100:       if (aForceSetNewDocument || curDoc != mDocument) {
80486:         window->SetNewDocument(mDocument, aState, false);
    1:         nsJSContext::LoadStart();
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (aDoCreation && mPresContext) {
    1:     // The ViewManager and Root View was created above (in
    1:     // MakeWindow())...
    1: 
38273:     rv = InitPresentationStuff(!makeCX);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
72298: void DocumentViewerImpl::SetNavigationTiming(nsDOMNavigationTiming* timing)
72298: {
72298:   NS_ASSERTION(mDocument, "Must have a document to set navigation timing.");
72298:   if (mDocument) {
72298:     mDocument->SetNavigationTiming(timing);
72298:   }
72298: }
72298: 
    1: //
    1: // LoadComplete(aStatus)
    1: //
    1: //   aStatus - The status returned from loading the document.
    1: //
    1: // This method is called by the container when the document has been
    1: // completely loaded.
    1: //
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::LoadComplete(nsresult aStatus)
    1: {
41653:   NS_TIME_FUNCTION;
    1:   /* We need to protect ourself against auto-destruction in case the
    1:      window is closed while processing the OnLoad event.  See bug
    1:      http://bugzilla.mozilla.org/show_bug.cgi?id=78445 for more
    1:      explanation.
    1:   */
80401:   nsRefPtr<DocumentViewerImpl> kungFuDeathGrip(this);
    1: 
  971:   // Flush out layout so it's up-to-date by the time onload is called.
  971:   // Note that this could destroy the window, so do this before
  971:   // checking for our mDocument and its window.
  921:   if (mPresShell && !mStopped) {
  921:     // Hold strong ref because this could conceivably run script
  921:     nsCOMPtr<nsIPresShell> shell = mPresShell;
  921:     shell->FlushPendingNotifications(Flush_Layout);
  921:   }
  921: 
63195:   nsresult rv = NS_OK;
  971:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
  971: 
  971:   // First, get the window from the document...
  971:   nsPIDOMWindow *window = mDocument->GetWindow();
  971: 
80486:   mLoaded = true;
  971: 
    1:   // Now, fire either an OnLoad or OnError event to the document...
79445:   bool restoring = false;
21811:   // XXXbz imagelib kills off the document load for a full-page image with
25034:   // NS_ERROR_PARSED_DATA_CACHED if it's in the cache.  So we want to treat
21811:   // that one as a success code; otherwise whether we fire onload for the image
21811:   // will depend on whether it's cached!
21811:   if(window &&
25034:      (NS_SUCCEEDED(aStatus) || aStatus == NS_ERROR_PARSED_DATA_CACHED)) {
23639:     if (mDocument)
23639:       mDocument->SetReadyStateInternal(nsIDocument::READYSTATE_COMPLETE);
    1:     nsEventStatus status = nsEventStatus_eIgnore;
80486:     nsEvent event(true, NS_LOAD);
    1:     event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
    1:      // XXX Dispatching to |window|, but using |document| as the target.
    1:     event.target = mDocument;
    1: 
    1:     // If the document presentation is being restored, we don't want to fire
    1:     // onload to the document content since that would likely confuse scripts
    1:     // on the page.
    1: 
    1:     nsIDocShell *docShell = window->GetDocShell();
    1:     NS_ENSURE_TRUE(docShell, NS_ERROR_UNEXPECTED);
    1: 
    1:     docShell->GetRestoringDocument(&restoring);
    1:     if (!restoring) {
72298:       nsRefPtr<nsDOMNavigationTiming> timing(mDocument->GetNavigationTiming());
72298:       if (timing) {
72298:         timing->NotifyLoadEventStart();
72298:       }
    1:       nsEventDispatcher::Dispatch(window, mPresContext, &event, nsnull,
    1:                                   &status);
72298:       if (timing) {
72298:         timing->NotifyLoadEventEnd();
72298:       }
    1:     }
    1:   } else {
    1:     // XXX: Should fire error event to the document...
    1:   }
    1: 
    1:   // Notify the document that it has been shown (regardless of whether
    1:   // it was just loaded). Note: mDocument may be null now if the above
    1:   // firing of onload caused the document to unload.
34446:   if (mDocument) {
34446:     // Re-get window, since it might have changed during above firing of onload
34446:     window = mDocument->GetWindow();
34446:     if (window) {
34446:       nsIDocShell *docShell = window->GetDocShell();
79445:       bool isInUnload;
36696:       if (docShell && NS_SUCCEEDED(docShell->GetIsInUnload(&isInUnload)) &&
36696:           !isInUnload) {
25572:         mDocument->OnPageShow(restoring, nsnull);
34446:       }
34446:     }
34446:   }
    1: 
    1:   // Now that the document has loaded, we can tell the presshell
    1:   // to unsuppress painting.
    1:   if (mPresShell && !mStopped) {
14187:     nsCOMPtr<nsIPresShell> shellDeathGrip(mPresShell);
    1:     mPresShell->UnsuppressPainting();
14187:     // mPresShell could have been removed now, see bug 378682/421432
14187:     if (mPresShell) {
12356:       mPresShell->ScrollToAnchor();
    1:     }
14187:   }
    1: 
 7080:   nsJSContext::LoadEnd();
    1: 
    1: #ifdef NS_PRINTING
    1:   // Check to see if someone tried to print during the load
    1:   if (mPrintIsPending) {
80486:     mPrintIsPending        = false;
80486:     mPrintDocIsFullyLoaded = true;
    1:     Print(mCachedPrintSettings, mCachedPrintWebProgressListner);
    1:     mCachedPrintSettings           = nsnull;
    1:     mCachedPrintWebProgressListner = nsnull;
    1:   }
    1: #endif
    1: 
63195:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::PermitUnload(bool aCallerClosesWindow, bool *aPermitUnload)
    1: {
80486:   *aPermitUnload = true;
    1: 
34032:   if (!mDocument || mInPermitUnload || mCallerIsClosingWindow) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // First, get the script global object from the document...
    1:   nsPIDOMWindow *window = mDocument->GetWindow();
    1: 
    1:   if (!window) {
    1:     // This is odd, but not fatal
    1:     NS_WARNING("window not set for document!");
    1:     return NS_OK;
    1:   }
    1: 
13098:   NS_ASSERTION(nsContentUtils::IsSafeToRunScript(), "This is unsafe");
13098: 
    1:   // Now, fire an BeforeUnload event to the document and see if it's ok
    1:   // to unload...
70359:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(mDocument);
29522:   nsCOMPtr<nsIDOMEvent> event;
70359:   domDoc->CreateEvent(NS_LITERAL_STRING("beforeunloadevent"),
29522:                       getter_AddRefs(event));
29522:   nsCOMPtr<nsIDOMBeforeUnloadEvent> beforeUnload = do_QueryInterface(event);
29522:   nsCOMPtr<nsIPrivateDOMEvent> pEvent = do_QueryInterface(beforeUnload);
29522:   NS_ENSURE_STATE(pEvent);
29522:   nsresult rv = event->InitEvent(NS_LITERAL_STRING("beforeunload"),
80486:                                  false, true);
29522:   NS_ENSURE_SUCCESS(rv, rv);
29522: 
    1:   // XXX Dispatching to |window|, but using |document| as the target.
29522:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(mDocument);
29522:   pEvent->SetTarget(target);
80486:   pEvent->SetTrusted(true);
    1: 
    1:   // In evil cases we might be destroyed while handling the
    1:   // onbeforeunload event, don't let that happen. (see also bug#331040)
    1:   nsRefPtr<DocumentViewerImpl> kungFuDeathGrip(this);
    1: 
    1:   {
    1:     // Never permit popups from the beforeunload handler, no matter
    1:     // how we get here.
80486:     nsAutoPopupStatePusher popupStatePusher(openAbused, true);
80486: 
80486:     mInPermitUnload = true;
29522:     nsEventDispatcher::DispatchDOMEvent(window, nsnull, event, mPresContext,
29522:                                         nsnull);
80486:     mInPermitUnload = false;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeNode> docShellNode(do_QueryReferent(mContainer));
29522:   nsAutoString text;
29522:   beforeUnload->GetReturnValue(text);
29522:   if (pEvent->GetInternalNSEvent()->flags & NS_EVENT_FLAG_NO_DEFAULT ||
29522:       !text.IsEmpty()) {
    1:     // Ask the user if it's ok to unload the current page
    1: 
    1:     nsCOMPtr<nsIPrompt> prompt = do_GetInterface(docShellNode);
    1: 
    1:     if (prompt) {
54135:       nsXPIDLString title, message, stayLabel, leaveLabel;
    1:       rv  = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
54135:                                                "OnBeforeUnloadTitle",
54135:                                                title);
    1:       rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
54135:                                                "OnBeforeUnloadMessage",
54135:                                                message);
54135:       rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
54135:                                                "OnBeforeUnloadLeaveButton",
54135:                                                leaveLabel);
54135:       rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
54135:                                                "OnBeforeUnloadStayButton",
54135:                                                stayLabel);
54135: 
54135:       if (NS_FAILED(rv) || !title || !message || !stayLabel || !leaveLabel) {
    1:         NS_ERROR("Failed to get strings from dom.properties!");
    1:         return NS_OK;
    1:       }
    1: 
71081:       // Although the exact value is ignored, we must not pass invalid
79445:       // bool values through XPConnect.
79445:       bool dummy = false;
54135:       PRInt32 buttonPressed = 0;
54135:       PRUint32 buttonFlags = (nsIPrompt::BUTTON_POS_0_DEFAULT |
54135:                              (nsIPrompt::BUTTON_TITLE_IS_STRING * nsIPrompt::BUTTON_POS_0) |
54135:                              (nsIPrompt::BUTTON_TITLE_IS_STRING * nsIPrompt::BUTTON_POS_1));
54135: 
54135:       rv = prompt->ConfirmEx(title, message, buttonFlags,
54135:                              leaveLabel, stayLabel, nsnull, nsnull,
54135:                              &dummy, &buttonPressed);
54135:       NS_ENSURE_SUCCESS(rv, rv);
54135: 
54135:       // Button 0 == leave, button 1 == stay
54135:       *aPermitUnload = (buttonPressed == 0);
    1:     }
    1:   }
    1: 
    1:   if (docShellNode) {
    1:     PRInt32 childCount;
    1:     docShellNode->GetChildCount(&childCount);
    1: 
    1:     for (PRInt32 i = 0; i < childCount && *aPermitUnload; ++i) {
    1:       nsCOMPtr<nsIDocShellTreeItem> item;
    1:       docShellNode->GetChildAt(i, getter_AddRefs(item));
    1: 
    1:       nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(item));
    1: 
    1:       if (docShell) {
    1:         nsCOMPtr<nsIContentViewer> cv;
    1:         docShell->GetContentViewer(getter_AddRefs(cv));
    1: 
    1:         if (cv) {
34032:           cv->PermitUnload(aCallerClosesWindow, aPermitUnload);
34032:         }
34032:       }
34032:     }
34032:   }
34032: 
34032:   if (aCallerClosesWindow && *aPermitUnload)
80486:     mCallerIsClosingWindow = true;
34032: 
34032:   return NS_OK;
34032: }
34032: 
34032: NS_IMETHODIMP
34032: DocumentViewerImpl::ResetCloseWindow()
34032: {
80486:   mCallerIsClosingWindow = false;
34032: 
34032:   nsCOMPtr<nsIDocShellTreeNode> docShellNode(do_QueryReferent(mContainer));
34032:   if (docShellNode) {
34032:     PRInt32 childCount;
34032:     docShellNode->GetChildCount(&childCount);
34032: 
34032:     for (PRInt32 i = 0; i < childCount; ++i) {
34032:       nsCOMPtr<nsIDocShellTreeItem> item;
34032:       docShellNode->GetChildAt(i, getter_AddRefs(item));
34032: 
34032:       nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(item));
34032: 
34032:       if (docShell) {
34032:         nsCOMPtr<nsIContentViewer> cv;
34032:         docShell->GetContentViewer(getter_AddRefs(cv));
34032: 
34032:         if (cv) {
34032:           cv->ResetCloseWindow();
34032:         }
34032:       }
34032:     }
34032:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::PageHide(bool aIsUnload)
    1: {
80486:   mHidden = true;
    1: 
    1:   if (!mDocument) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
25572:   mDocument->OnPageHide(!aIsUnload, nsnull);
29018: 
29018:   // inform the window so that the focus state is reset.
29018:   NS_ENSURE_STATE(mDocument);
29018:   nsPIDOMWindow *window = mDocument->GetWindow();
29018:   if (window)
29018:     window->PageHidden();
29018: 
    1:   if (aIsUnload) {
62725:     // Poke the GC. The window might be collectable garbage now.
62725:     nsJSContext::PokeGC();
62725: 
    1:     // if Destroy() was called during OnPageHide(), mDocument is nsnull.
    1:     NS_ENSURE_STATE(mDocument);
    1: 
    1:     // First, get the window from the document...
    1:     nsPIDOMWindow *window = mDocument->GetWindow();
    1: 
    1:     if (!window) {
    1:       // Fail if no window is available...
39690:       NS_WARNING("window not set for document!");
    1:       return NS_ERROR_NULL_POINTER;
    1:     }
    1: 
    1:     // Now, fire an Unload event to the document...
    1:     nsEventStatus status = nsEventStatus_eIgnore;
80486:     nsEvent event(true, NS_PAGE_UNLOAD);
    1:     event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
    1:     // XXX Dispatching to |window|, but using |document| as the target.
    1:     event.target = mDocument;
    1: 
    1:     // Never permit popups from the unload handler, no matter how we get
    1:     // here.
80486:     nsAutoPopupStatePusher popupStatePusher(openAbused, true);
    1: 
    1:     nsEventDispatcher::Dispatch(window, mPresContext, &event, nsnull, &status);
    1:   }
    1: 
 3799: #ifdef MOZ_XUL
    1:   // look for open menupopups and close them after the unload event, in case
    1:   // the unload event listeners open any new popups
11414:   nsContentUtils::HidePopupsInDocument(mDocument);
 3799: #endif
  825: 
  825:   return NS_OK;
    1: }
    1: 
    1: static void
    1: AttachContainerRecurse(nsIDocShell* aShell)
    1: {
    1:   nsCOMPtr<nsIContentViewer> viewer;
    1:   aShell->GetContentViewer(getter_AddRefs(viewer));
80401:   if (viewer) {
80401:     nsIDocument* doc = viewer->GetDocument();
    1:     if (doc) {
    1:       doc->SetContainer(aShell);
    1:     }
39823:     nsRefPtr<nsPresContext> pc;
80401:     viewer->GetPresContext(getter_AddRefs(pc));
    1:     if (pc) {
    1:       pc->SetContainer(aShell);
    1:       pc->SetLinkHandler(nsCOMPtr<nsILinkHandler>(do_QueryInterface(aShell)));
    1:     }
    1:     nsCOMPtr<nsIPresShell> presShell;
80401:     viewer->GetPresShell(getter_AddRefs(presShell));
    1:     if (presShell) {
    1:       presShell->SetForwardingContainer(nsnull);
    1:     }
    1:   }
    1: 
    1:   // Now recurse through the children
    1:   nsCOMPtr<nsIDocShellTreeNode> node = do_QueryInterface(aShell);
    1:   NS_ASSERTION(node, "docshells must implement nsIDocShellTreeNode");
    1: 
    1:   PRInt32 childCount;
    1:   node->GetChildCount(&childCount);
    1:   for (PRInt32 i = 0; i < childCount; ++i) {
    1:     nsCOMPtr<nsIDocShellTreeItem> childItem;
    1:     node->GetChildAt(i, getter_AddRefs(childItem));
    1:     AttachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(childItem)));
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::Open(nsISupports *aState, nsISHEntry *aSHEntry)
    1: {
    1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
    1: 
20078:   if (mDocument)
20078:     mDocument->SetContainer(nsCOMPtr<nsISupports>(do_QueryReferent(mContainer)));
20078: 
80486:   nsresult rv = InitInternal(mParentWidget, aState, mBounds, false);
19919:   NS_ENSURE_SUCCESS(rv, rv);
19919: 
80486:   mHidden = false;
68689: 
    1:   if (mPresShell)
    1:     mPresShell->SetForwardingContainer(nsnull);
    1: 
    1:   // Rehook the child presentations.  The child shells are still in
    1:   // session history, so get them from there.
    1: 
19869:   if (aSHEntry) {
    1:     nsCOMPtr<nsIDocShellTreeItem> item;
    1:     PRInt32 itemIndex = 0;
    1:     while (NS_SUCCEEDED(aSHEntry->ChildShellAt(itemIndex++,
    1:                                                getter_AddRefs(item))) && item) {
    1:       AttachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(item)));
    1:     }
19869:   }
    1:   
    1:   SyncParentSubDocMap();
    1: 
 1418:   if (mFocusListener && mDocument) {
72631:     mDocument->AddEventListener(NS_LITERAL_STRING("focus"), mFocusListener,
80486:                                 false, false);
72631:     mDocument->AddEventListener(NS_LITERAL_STRING("blur"), mFocusListener,
80486:                                 false, false);
    1:   }
    1: 
    1:   // XXX re-enable image animations once that works correctly
    1: 
    1:   PrepareToStartLoad();
62248: 
62248:   // When loading a page from the bfcache with puppet widgets, we do the
62248:   // widget attachment here (it is otherwise done in MakeWindow, which is
62248:   // called for non-bfcache pages in the history, but not bfcache pages).
62248:   // Attachment is necessary, since we get detached when another page
62248:   // is browsed to. That is, if we are one page A, then when we go to
62248:   // page B, we detach. So page A's view has no widget. If we then go
62248:   // back to it, and it is in the bfcache, we will use that view, which
62248:   // doesn't have a widget. The attach call here will properly attach us.
62248:   if (nsIWidget::UsePuppetWidgets() && mPresContext &&
62248:       ShouldAttachToTopLevel()) {
62248:     // If the old view is already attached to our parent, detach
62248:     DetachFromTopLevelWidget();
62248: 
62248:     nsIViewManager *vm = GetViewManager();
62248:     NS_ABORT_IF_FALSE(vm, "no view manager");
64435:     nsIView* v = vm->GetRootView();
62248:     NS_ABORT_IF_FALSE(v, "no root view");
62248:     NS_ABORT_IF_FALSE(mParentWidget, "no mParentWidget to set");
62248:     v->AttachToTopLevelWidget(mParentWidget);
62248: 
80486:     mAttachedToParent = true;
62248:   }
62248: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::Close(nsISHEntry *aSHEntry)
    1: {
    1:   // All callers are supposed to call close to break circular
    1:   // references.  If we do this stuff in the destructor, the
    1:   // destructor might never be called (especially if we're being
    1:   // used from JS.
    1: 
    1:   mSHEntry = aSHEntry;
    1: 
    1:   // Close is also needed to disable scripts during paint suppression,
    1:   // since we transfer the existing global object to the new document
    1:   // that is loaded.  In the future, the global object may become a proxy
    1:   // for an object that can be switched in and out so that we don't need
    1:   // to disable scripts during paint suppression.
    1: 
    1:   if (!mDocument)
    1:     return NS_OK;
    1: 
    1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
    1:   // Turn scripting back on
    1:   // after PrintPreview had turned it off
    1:   if (GetIsPrintPreview() && mPrintEngine) {
80486:     mPrintEngine->TurnScriptingOn(true);
    1:   }
    1: #endif
    1: 
    1: #ifdef NS_PRINTING
    1:   // A Close was called while we were printing
    1:   // so don't clear the ScriptGlobalObject
    1:   // or clear the mDocument below
    1:   if (mPrintEngine && !mClosingWhilePrinting) {
80486:     mClosingWhilePrinting = true;
    1:   } else
    1: #endif
    1:     {
28078:       // out of band cleanup of docshell
    1:       mDocument->SetScriptGlobalObject(nsnull);
    1: 
22959:       if (!mSHEntry && mDocument)
14469:         mDocument->RemovedFromDocShell();
    1:     }
    1: 
 1418:   if (mFocusListener && mDocument) {
72631:     mDocument->RemoveEventListener(NS_LITERAL_STRING("focus"), mFocusListener,
80486:                                    false);
72631:     mDocument->RemoveEventListener(NS_LITERAL_STRING("blur"), mFocusListener,
80486:                                    false);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: DetachContainerRecurse(nsIDocShell *aShell)
    1: {
    1:   // Unhook this docshell's presentation
    1:   nsCOMPtr<nsIContentViewer> viewer;
    1:   aShell->GetContentViewer(getter_AddRefs(viewer));
80401:   if (viewer) {
80401:     nsIDocument* doc = viewer->GetDocument();
    1:     if (doc) {
    1:       doc->SetContainer(nsnull);
    1:     }
39823:     nsRefPtr<nsPresContext> pc;
80401:     viewer->GetPresContext(getter_AddRefs(pc));
    1:     if (pc) {
    1:       pc->SetContainer(nsnull);
    1:       pc->SetLinkHandler(nsnull);
    1:     }
    1:     nsCOMPtr<nsIPresShell> presShell;
80401:     viewer->GetPresShell(getter_AddRefs(presShell));
    1:     if (presShell) {
    1:       presShell->SetForwardingContainer(nsWeakPtr(do_GetWeakReference(aShell)));
    1:     }
    1:   }
    1: 
    1:   // Now recurse through the children
    1:   nsCOMPtr<nsIDocShellTreeNode> node = do_QueryInterface(aShell);
    1:   NS_ASSERTION(node, "docshells must implement nsIDocShellTreeNode");
    1: 
    1:   PRInt32 childCount;
    1:   node->GetChildCount(&childCount);
    1:   for (PRInt32 i = 0; i < childCount; ++i) {
    1:     nsCOMPtr<nsIDocShellTreeItem> childItem;
    1:     node->GetChildAt(i, getter_AddRefs(childItem));
    1:     DetachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(childItem)));
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::Destroy()
    1: {
    1:   NS_ASSERTION(mDocument, "No document in Destroy()!");
    1: 
    1: #ifdef NS_PRINTING
23839:   // Here is where we check to see if the document was still being prepared 
    1:   // for printing when it was asked to be destroy from someone externally
23839:   // This usually happens if the document is unloaded while the user is in the
23839:   // Print Dialog
    1:   //
    1:   // So we flip the bool to remember that the document is going away
    1:   // and we can clean up and abort later after returning from the Print Dialog
    1:   if (mPrintEngine) {
    1:     if (mPrintEngine->CheckBeforeDestroy()) {
    1:       return NS_OK;
    1:     }
    1:   }
    1: #endif
    1: 
    1:   // Don't let the document get unloaded while we are printing.
    1:   // this could happen if we hit the back button during printing.
    1:   // We also keep the viewer from being cached in session history, since
    1:   // we require all documents there to be sanitized.
    1:   if (mDestroyRefCount != 0) {
    1:     --mDestroyRefCount;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If we were told to put ourselves into session history instead of destroy
    1:   // the presentation, do that now.
    1:   if (mSHEntry) {
    1:     if (mPresShell)
    1:       mPresShell->Freeze();
    1: 
    1:     // Make sure the presentation isn't torn down by Hide().
    1:     mSHEntry->SetSticky(mIsSticky);
80486:     mIsSticky = true;
    1: 
79445:     bool savePresentation = true;
    1: 
    1:     // Remove our root view from the view hierarchy.
    1:     if (mPresShell) {
    1:       nsIViewManager *vm = mPresShell->GetViewManager();
    1:       if (vm) {
64435:         nsIView *rootView = vm->GetRootView();
    1: 
    1:         if (rootView) {
62099:           // The invalidate that removing this view causes is dropped because
62099:           // the Freeze call above sets painting to be suppressed for our
62099:           // document. So we do it ourselves and make it happen.
62099:           vm->UpdateViewNoSuppression(rootView,
62099:             rootView->GetBounds() - rootView->GetPosition(),
62099:             NS_VMREFRESH_NO_SYNC);
62099: 
    1:           nsIView *rootViewParent = rootView->GetParent();
    1:           if (rootViewParent) {
    1:             nsIViewManager *parentVM = rootViewParent->GetViewManager();
    1:             if (parentVM) {
    1:               parentVM->RemoveChild(rootView);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
    1:     Hide();
    1: 
    1:     // This is after Hide() so that the user doesn't see the inputs clear.
    1:     if (mDocument) {
    1:       nsresult rv = mDocument->Sanitize();
    1:       if (NS_FAILED(rv)) {
    1:         // If we failed to sanitize, don't save presentation.
58185:         // XXX Shouldn't we run all the stuff after the |if (mSHEntry)| then?
80486:         savePresentation = false;
    1:       }
    1:     }
    1: 
    1: 
    1:     // Reverse ownership. Do this *after* calling sanitize so that sanitize
    1:     // doesn't cause mutations that make the SHEntry drop the presentation
62556: 
62556:     // Grab a reference to mSHEntry before calling into things like
62556:     // SyncPresentationState that might mess with our members.
    1:     nsCOMPtr<nsISHEntry> shEntry = mSHEntry; // we'll need this below
    1:     mSHEntry = nsnull;
    1: 
62556:     if (savePresentation) {
62556:       shEntry->SetContentViewer(this);
62556:     }
62556: 
62556:     // Always sync the presentation state.  That way even if someone screws up
62556:     // and shEntry has no window state at this point we'll be ok; we just won't
62556:     // cache ourselves.
62556:     shEntry->SyncPresentationState();
62556: 
    1:     // Break the link from the document/presentation to the docshell, so that
    1:     // link traversals cannot affect the currently-loaded document.
    1:     // When the presentation is restored, Open() and InitInternal() will reset
    1:     // these pointers to their original values.
    1: 
58185:     if (mDocument) {
    1:       mDocument->SetContainer(nsnull);
58185:     }
    1:     if (mPresContext) {
    1:       mPresContext->SetLinkHandler(nsnull);
    1:       mPresContext->SetContainer(nsnull);
    1:     }
    1:     if (mPresShell)
    1:       mPresShell->SetForwardingContainer(mContainer);
    1: 
    1:     // Do the same for our children.  Note that we need to get the child
    1:     // docshells from the SHEntry now; the docshell will have cleared them.
    1:     nsCOMPtr<nsIDocShellTreeItem> item;
    1:     PRInt32 itemIndex = 0;
    1:     while (NS_SUCCEEDED(shEntry->ChildShellAt(itemIndex++,
    1:                                               getter_AddRefs(item))) && item) {
    1:       DetachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(item)));
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
58185:   // The document was not put in the bfcache
58185: 
    1:   if (mDocument) {
    1:     mDocument->Destroy();
    1:     mDocument = nsnull;
    1:   }
    1: 
    1:   // All callers are supposed to call destroy to break circular
    1:   // references.  If we do this stuff in the destructor, the
    1:   // destructor might never be called (especially if we're being
    1:   // used from JS.
    1: 
14111: #ifdef NS_PRINTING
14111:   if (mPrintEngine) {
14111: #ifdef NS_PRINT_PREVIEW
79445:     bool doingPrintPreview;
14111:     mPrintEngine->GetDoingPrintPreview(&doingPrintPreview);
14111:     if (doingPrintPreview) {
14111:       mPrintEngine->FinishPrintPreview();
14111:     }
14111: #endif
14111: 
14111:     mPrintEngine->Destroy();
14111:     mPrintEngine = nsnull;
14111:   }
14111: #endif
14111: 
    1:   // Avoid leaking the old viewer.
    1:   if (mPreviousViewer) {
    1:     mPreviousViewer->Destroy();
    1:     mPreviousViewer = nsnull;
    1:   }
    1: 
    1:   mDeviceContext = nsnull;
    1: 
    1:   if (mPresShell) {
23902:     DestroyPresShell();
    1:   }
    1: 
    1:   if (mPresContext) {
61100:     DestroyPresContext();
    1:   }
    1: 
56620:   mWindow = nsnull;
56620:   mViewManager = nsnull;
    1:   mContainer = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::Stop(void)
    1: {
    1:   NS_ASSERTION(mDocument, "Stop called too early or too late");
    1:   if (mDocument) {
    1:     mDocument->StopDocumentLoad();
    1:   }
    1: 
38273:   if (!mHidden && (mLoaded || mStopped) && mPresContext && !mSHEntry)
    1:     mPresContext->SetImageAnimationMode(imgIContainer::kDontAnimMode);
    1: 
80486:   mStopped = true;
    1: 
    1:   if (!mLoaded && mPresShell) {
    1:     // Well, we might as well paint what we have so far.
  867:     nsCOMPtr<nsIPresShell> shellDeathGrip(mPresShell); // bug 378682
    1:     mPresShell->UnsuppressPainting();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::GetDOMDocument(nsIDOMDocument **aResult)
    1: {
    1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
    1:   return CallQueryInterface(mDocument, aResult);
    1: }
    1: 
37433: NS_IMETHODIMP_(nsIDocument *)
37433: DocumentViewerImpl::GetDocument()
37433: {
37433:   return mDocument;
37433: }
37433: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::SetDOMDocument(nsIDOMDocument *aDocument)
    1: {
    1:   // Assumptions:
    1:   //
    1:   // 1) this document viewer has been initialized with a call to Init().
    1:   // 2) the stylesheets associated with the document have been added
    1:   // to the document.
    1: 
    1:   // XXX Right now, this method assumes that the layout of the current
    1:   // document hasn't started yet.  More cleanup will probably be
    1:   // necessary to make this method work for the case when layout *has*
    1:   // occurred for the current document.
    1:   // That work can happen when and if it is needed.
    1: 
    1:   if (!aDocument)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
53996:   nsCOMPtr<nsIDocument> newDoc = do_QueryInterface(aDocument);
53996:   NS_ENSURE_TRUE(newDoc, NS_ERROR_UNEXPECTED);
53996: 
80486:   return SetDocumentInternal(newDoc, false);
53996: }
53996: 
53996: NS_IMETHODIMP
53996: DocumentViewerImpl::SetDocumentInternal(nsIDocument* aDocument,
79445:                                         bool aForceReuseInnerWindow)
53996: {
    1: 
    1:   // Set new container
    1:   nsCOMPtr<nsISupports> container = do_QueryReferent(mContainer);
53996:   aDocument->SetContainer(container);
53996: 
53996:   if (mDocument != aDocument) {
71899:     if (mDocument->IsStaticDocument()) {
71899:       mDocument->SetScriptGlobalObject(nsnull);
71899:       mDocument->Destroy();
71899:     }
    1:     // Replace the old document with the new one. Do this only when
    1:     // the new document really is a new document.
53996:     mDocument = aDocument;
    1: 
    1:     // Set the script global object on the new document
    1:     nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(container);
    1:     if (window) {
53996:       window->SetNewDocument(aDocument, nsnull, aForceReuseInnerWindow);
    1:     }
    1: 
61100:     // Clear the list of old child docshells. Child docshells for the new
    1:     // document will be constructed as frames are created.
53996:     if (!aDocument->IsStaticDocument()) {
    1:       nsCOMPtr<nsIDocShellTreeNode> node = do_QueryInterface(container);
    1:       if (node) {
    1:         PRInt32 count;
    1:         node->GetChildCount(&count);
    1:         for (PRInt32 i = 0; i < count; ++i) {
    1:           nsCOMPtr<nsIDocShellTreeItem> child;
    1:           node->GetChildAt(0, getter_AddRefs(child));
    1:           node->RemoveChild(child);
    1:         }
    1:       }
    1:     }
35581:   }
    1: 
53996:   nsresult rv = SyncParentSubDocMap();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Replace the current pres shell with a new shell for the new document
    1: 
    1:   if (mPresShell) {
61100:     DestroyPresShell();
 8519:   }
 8519: 
    1:   if (mPresContext) {
61100:     DestroyPresContext();
61100: 
62618:     mWindow = nsnull;
80486:     InitInternal(mParentWidget, nsnull, mBounds, true, true, false);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
 7740: nsIPresShell*
 7740: DocumentViewerImpl::GetPresShell()
 7740: {
 7740:   return mPresShell;
 7740: }
 7740: 
 7740: nsPresContext*
 7740: DocumentViewerImpl::GetPresContext()
 7740: {
 7740:   return mPresContext;
 7740: }
 7740: 
 7740: nsIViewManager*
 7740: DocumentViewerImpl::GetViewManager()
 7740: {
 7740:   return mViewManager;
 7740: }
 7740: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::GetPresShell(nsIPresShell** aResult)
    1: {
 7740:   nsIPresShell* shell = GetPresShell();
 7740:   NS_IF_ADDREF(*aResult = shell);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::GetPresContext(nsPresContext** aResult)
    1: {
 7740:   nsPresContext* pc = GetPresContext();
 7740:   NS_IF_ADDREF(*aResult = pc);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23738: DocumentViewerImpl::GetBounds(nsIntRect& aResult)
    1: {
    1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
30537:   aResult = mBounds;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::GetPreviousViewer(nsIContentViewer** aViewer)
    1: {
    1:   *aViewer = mPreviousViewer;
    1:   NS_IF_ADDREF(*aViewer);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::SetPreviousViewer(nsIContentViewer* aViewer)
    1: {
    1:   // NOTE:  |Show| sets |mPreviousViewer| to null without calling this
    1:   // function.
    1: 
    1:   if (aViewer) {
    1:     NS_ASSERTION(!mPreviousViewer,
    1:                  "can't set previous viewer when there already is one");
    1: 
    1:     // In a multiple chaining situation (which occurs when running a thrashing
    1:     // test like i-bench or jrgm's tests with no delay), we can build up a
    1:     // whole chain of viewers.  In order to avoid this, we always set our previous
    1:     // viewer to the MOST previous viewer in the chain, and then dump the intermediate
    1:     // link from the chain.  This ensures that at most only 2 documents are alive
    1:     // and undestroyed at any given time (the one that is showing and the one that
    1:     // is loading with painting suppressed).
 6685:     // It's very important that if this ever gets changed the code
 6685:     // before the RestorePresentation call in nsDocShell::InternalLoad
 6685:     // be changed accordingly.
    1:     nsCOMPtr<nsIContentViewer> prevViewer;
    1:     aViewer->GetPreviousViewer(getter_AddRefs(prevViewer));
    1:     if (prevViewer) {
    1:       aViewer->SetPreviousViewer(nsnull);
    1:       aViewer->Destroy();
    1:       return SetPreviousViewer(prevViewer);
    1:     }
    1:   }
    1: 
    1:   mPreviousViewer = aViewer;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23738: DocumentViewerImpl::SetBounds(const nsIntRect& aBounds)
    1: {
    1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
    1: 
30537:   mBounds = aBounds;
    1:   if (mWindow) {
46194:     // When attached to a top level window, change the client area, not the
46194:     // window frame.
    1:     // Don't have the widget repaint. Layout will generate repaint requests
46194:     // during reflow.
46194:     if (mAttachedToParent)
46194:       mWindow->ResizeClient(aBounds.x, aBounds.y,
46194:                             aBounds.width, aBounds.height,
80486:                             false);
46194:     else
46194:       mWindow->Resize(aBounds.x, aBounds.y,
46194:                       aBounds.width, aBounds.height,
80486:                       false);
30537:   } else if (mPresContext && mViewManager) {
30537:     PRInt32 p2a = mPresContext->AppUnitsPerDevPixel();
30537:     mViewManager->SetWindowDimensions(NSIntPixelsToAppUnits(mBounds.width, p2a),
30537:                                       NSIntPixelsToAppUnits(mBounds.height, p2a));
    1:   }
    1: 
    1:   // If there's a previous viewer, it's the one that's actually showing,
    1:   // so be sure to resize it as well so it paints over the right area.
    1:   // This may slow down the performance of the new page load, but resize
    1:   // during load is also probably a relatively unusual condition
    1:   // relating to things being hidden while something is loaded.  It so
    1:   // happens that Firefox does this a good bit with its infobar, and it
    1:   // looks ugly if we don't do this.
    1:   if (mPreviousViewer)
    1:     mPreviousViewer->SetBounds(aBounds);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::Move(PRInt32 aX, PRInt32 aY)
    1: {
    1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
30537:   mBounds.MoveTo(aX, aY);
    1:   if (mWindow) {
    1:     mWindow->Move(aX, aY);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::Show(void)
    1: {
    1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
    1: 
    1:   // We don't need the previous viewer anymore since we're not
    1:   // displaying it.
    1:   if (mPreviousViewer) {
    1:     // This little dance *may* only be to keep
    1:     // PresShell::EndObservingDocument happy, but I'm not sure.
    1:     nsCOMPtr<nsIContentViewer> prevViewer(mPreviousViewer);
    1:     mPreviousViewer = nsnull;
    1:     prevViewer->Destroy();
    1: 
    1:     // Make sure we don't have too many cached ContentViewers
    1:     nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryReferent(mContainer);
    1:     if (treeItem) {
    1:       // We need to find the root DocShell since only that object has an
    1:       // SHistory and we need the SHistory to evict content viewers
    1:       nsCOMPtr<nsIDocShellTreeItem> root;
    1:       treeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
    1:       nsCOMPtr<nsIWebNavigation> webNav = do_QueryInterface(root);
    1:       nsCOMPtr<nsISHistory> history;
    1:       webNav->GetSessionHistory(getter_AddRefs(history));
    1:       nsCOMPtr<nsISHistoryInternal> historyInt = do_QueryInterface(history);
    1:       if (historyInt) {
19870:         PRInt32 prevIndex,loadedIndex;
19870:         nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(treeItem);
19870:         docShell->GetPreviousTransIndex(&prevIndex);
19870:         docShell->GetLoadedTransIndex(&loadedIndex);
    1: #ifdef DEBUG_PAGE_CACHE
19870:         printf("About to evict content viewers: prev=%d, loaded=%d\n",
19870:                prevIndex, loadedIndex);
    1: #endif
80492:         historyInt->EvictContentViewers(prevIndex, loadedIndex);
    1:       }
    1:     }
    1:   }
    1: 
47783:   if (mWindow) {
55866:     // When attached to a top level xul window, we do not need to call
55866:     // Show on the widget. Underlying window management code handles
55866:     // this when the window is initialized.
55866:     if (!mAttachedToParent) {
80486:       mWindow->Show(true);
    1:     }
48796:   }
    1: 
30537:   if (mDocument && !mPresShell) {
30537:     NS_ASSERTION(!mWindow, "Window already created but no presshell?");
30537: 
    1:     nsCOMPtr<nsIBaseWindow> base_win(do_QueryReferent(mContainer));
19869:     if (base_win) {
    1:       base_win->GetParentWidget(&mParentWidget);
30537:       if (mParentWidget) {
 4482:         mParentWidget->Release(); // GetParentWidget AddRefs, but mParentWidget is weak
19869:       }
30537:     }
30537: 
30537:     nsIView* containerView = FindContainerView();
30537: 
30537:     nsresult rv = CreateDeviceContext(containerView);
17009:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Create presentation context
    1:     NS_ASSERTION(!mPresContext, "Shouldn't have a prescontext if we have no shell!");
30514:     mPresContext = CreatePresContext(mDocument,
30514:         nsPresContext::eContext_Galley, containerView);
    1:     NS_ENSURE_TRUE(mPresContext, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     rv = mPresContext->Init(mDeviceContext);
    1:     if (NS_FAILED(rv)) {
    1:       mPresContext = nsnull;
    1:       return rv;
    1:     }
    1: 
30537:     rv = MakeWindow(nsSize(mPresContext->DevPixelsToAppUnits(mBounds.width),
30537:                            mPresContext->DevPixelsToAppUnits(mBounds.height)),
30513:                            containerView);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     if (mPresContext && base_win) {
    1:       nsCOMPtr<nsILinkHandler> linkHandler(do_GetInterface(base_win));
    1: 
    1:       if (linkHandler) {
    1:         mPresContext->SetLinkHandler(linkHandler);
    1:       }
    1: 
    1:       mPresContext->SetContainer(base_win);
    1:     }
    1: 
    1:     if (mPresContext) {
    1:       Hide();
    1: 
38273:       rv = InitPresentationStuff(mDocument->MayStartLayout());
    1:     }
    1: 
    1:     // If we get here the document load has already started and the
    1:     // window is shown because some JS on the page caused it to be
    1:     // shown...
    1: 
35581:     if (mPresShell) {
  867:       nsCOMPtr<nsIPresShell> shellDeathGrip(mPresShell); // bug 378682
    1:       mPresShell->UnsuppressPainting();
    1:     }
35581:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::Hide(void)
    1: {
56344:   if (!mAttachedToParent && mWindow) {
80486:     mWindow->Show(false);
    1:   }
    1: 
    1:   if (!mPresShell)
    1:     return NS_OK;
    1: 
    1:   NS_ASSERTION(mPresContext, "Can't have a presshell and no prescontext!");
    1: 
    1:   // Avoid leaking the old viewer.
    1:   if (mPreviousViewer) {
    1:     mPreviousViewer->Destroy();
    1:     mPreviousViewer = nsnull;
    1:   }
    1: 
    1:   if (mIsSticky) {
    1:     // This window is sticky, that means that it might be shown again
    1:     // and we don't want the presshell n' all that to be thrown away
    1:     // just because the window is hidden.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
    1:   if (docShell) {
    1:     nsCOMPtr<nsILayoutHistoryState> layoutState;
80486:     mPresShell->CaptureHistoryState(getter_AddRefs(layoutState), true);
    1:   }
    1: 
23902:   DestroyPresShell();
23902: 
61100:   DestroyPresContext();
61100: 
    1:   mViewManager   = nsnull;
    1:   mWindow        = nsnull;
    1:   mDeviceContext = nsnull;
    1:   mParentWidget  = nsnull;
    1: 
    1:   nsCOMPtr<nsIBaseWindow> base_win(do_QueryReferent(mContainer));
    1: 
56344:   if (base_win && !mAttachedToParent) {
    1:     base_win->SetParentWidget(nsnull);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::GetSticky(bool *aSticky)
    1: {
    1:   *aSticky = mIsSticky;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::SetSticky(bool aSticky)
    1: {
    1:   mIsSticky = aSticky;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::RequestWindowClose(bool* aCanClose)
    1: {
    1: #ifdef NS_PRINTING
    1:   if (mPrintIsPending || (mPrintEngine && mPrintEngine->GetIsPrinting())) {
80486:     *aCanClose = false;
80486:     mDeferredWindowClose = true;
    1:   } else
    1: #endif
80486:     *aCanClose = true;
    1: 
    1:   return NS_OK;
    1: }
    1: 
79445: static bool
    1: AppendAgentSheet(nsIStyleSheet *aSheet, void *aData)
    1: {
 3233:   nsStyleSet *styleSet = static_cast<nsStyleSet*>(aData);
    1:   styleSet->AppendStyleSheet(nsStyleSet::eAgentSheet, aSheet);
80486:   return true;
    1: }
    1: 
79445: static bool
    1: PrependUserSheet(nsIStyleSheet *aSheet, void *aData)
    1: {
 3233:   nsStyleSet *styleSet = static_cast<nsStyleSet*>(aData);
    1:   styleSet->PrependStyleSheet(nsStyleSet::eUserSheet, aSheet);
80486:   return true;
    1: }
    1: 
    1: nsresult
    1: DocumentViewerImpl::CreateStyleSet(nsIDocument* aDocument,
    1:                                    nsStyleSet** aStyleSet)
    1: {
    1:   // Make sure this does the same thing as PresShell::AddSheet wrt ordering.
    1: 
    1:   // this should eventually get expanded to allow for creating
    1:   // different sets for different media
    1:   nsStyleSet *styleSet = new nsStyleSet();
    1: 
    1:   styleSet->BeginUpdate();
    1:   
    1:   // The document will fill in the document sheets when we create the presshell
    1:   
    1:   // Handle the user sheets.
20078: #ifdef DEBUG
20078:   nsCOMPtr<nsISupports> debugDocContainer = aDocument->GetContainer();
20078:   nsCOMPtr<nsIDocShellTreeItem> debugDocShell(do_QueryReferent(mContainer));
20078:   NS_ASSERTION(SameCOMIdentity(debugDocContainer, debugDocShell),
20078:                "Unexpected containers");
20078: #endif
42163:   nsCSSStyleSheet* sheet = nsnull;
20078:   if (nsContentUtils::IsInChromeDocshell(aDocument)) {
    1:     sheet = nsLayoutStylesheetCache::UserChromeSheet();
    1:   }
    1:   else {
    1:     sheet = nsLayoutStylesheetCache::UserContentSheet();
    1:   }
    1: 
    1:   if (sheet)
    1:     styleSet->AppendStyleSheet(nsStyleSet::eUserSheet, sheet);
    1: 
    1:   // Append chrome sheets (scrollbars + forms).
79445:   bool shouldOverride = false;
20078:   // We don't want a docshell here for external resource docs, so just
20078:   // look at mContainer.
20078:   nsCOMPtr<nsIDocShell> ds(do_QueryReferent(mContainer));
    1:   nsCOMPtr<nsIDOMEventTarget> chromeHandler;
    1:   nsCOMPtr<nsIURI> uri;
42163:   nsRefPtr<nsCSSStyleSheet> csssheet;
    1: 
19869:   if (ds) {
    1:     ds->GetChromeEventHandler(getter_AddRefs(chromeHandler));
19869:   }
    1:   if (chromeHandler) {
    1:     nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(chromeHandler));
    1:     nsCOMPtr<nsIContent> content(do_QueryInterface(elt));
    1:     if (elt && content) {
    1:       nsCOMPtr<nsIURI> baseURI = content->GetBaseURI();
    1: 
    1:       nsAutoString sheets;
    1:       elt->GetAttribute(NS_LITERAL_STRING("usechromesheets"), sheets);
    1:       if (!sheets.IsEmpty() && baseURI) {
38851:         nsRefPtr<mozilla::css::Loader> cssLoader = new mozilla::css::Loader();
    1: 
    1:         char *str = ToNewCString(sheets);
    1:         char *newStr = str;
    1:         char *token;
    1:         while ( (token = nsCRT::strtok(newStr, ", ", &newStr)) ) {
    1:           NS_NewURI(getter_AddRefs(uri), nsDependentCString(token), nsnull,
    1:                     baseURI);
    1:           if (!uri) continue;
    1: 
    1:           cssLoader->LoadSheetSync(uri, getter_AddRefs(csssheet));
41523:           if (!csssheet) continue;
    1: 
    1:           styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, csssheet);
80486:           shouldOverride = true;
    1:         }
    1:         nsMemory::Free(str);
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (!shouldOverride) {
    1:     sheet = nsLayoutStylesheetCache::ScrollbarsSheet();
    1:     if (sheet) {
    1:       styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, sheet);
    1:     }
    1:   }
    1: 
    1:   sheet = nsLayoutStylesheetCache::FormsSheet();
    1:   if (sheet) {
    1:     styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, sheet);
    1:   }
    1: 
21209:   // Make sure to clone the quirk sheet so that it can be usefully
21209:   // enabled/disabled as needed.
42163:   nsRefPtr<nsCSSStyleSheet> quirkClone;
42163:   nsCSSStyleSheet* quirkSheet;
21209:   if (!nsLayoutStylesheetCache::UASheet() ||
42162:       !(quirkSheet = nsLayoutStylesheetCache::QuirkSheet()) ||
42162:       !(quirkClone = quirkSheet->Clone(nsnull, nsnull, nsnull, nsnull)) ||
21209:       !sheet) {
21209:     delete styleSet;
21209:     return NS_ERROR_OUT_OF_MEMORY;
21209:   }
21209:   // quirk.css needs to come after the regular UA sheet (or more precisely,
21209:   // after the html.css and so forth that the UA sheet imports).
21209:   styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, quirkClone);
21209:   styleSet->SetQuirkStyleSheet(quirkClone);
21209:   styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet,
21209:                               nsLayoutStylesheetCache::UASheet());
    1: 
    1:   nsCOMPtr<nsIStyleSheetService> dummy =
    1:     do_GetService(NS_STYLESHEETSERVICE_CONTRACTID);
    1: 
    1:   nsStyleSheetService *sheetService = nsStyleSheetService::gInstance;
    1:   if (sheetService) {
    1:     sheetService->AgentStyleSheets()->EnumerateForwards(AppendAgentSheet,
    1:                                                         styleSet);
    1:     sheetService->UserStyleSheets()->EnumerateBackwards(PrependUserSheet,
    1:                                                         styleSet);
    1:   }
    1: 
    1:   // Caller will handle calling EndUpdate, per contract.
    1:   *aStyleSet = styleSet;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::ClearHistoryEntry()
    1: {
    1:   mSHEntry = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: 
    1: nsresult
30513: DocumentViewerImpl::MakeWindow(const nsSize& aSize, nsIView* aContainerView)
    1: {
35581:   if (GetIsPrintPreview())
35581:     return NS_OK;
35581: 
79445:   bool shouldAttach = ShouldAttachToTopLevel();
62248: 
62248:   if (shouldAttach) {
46194:     // If the old view is already attached to our parent, detach
46194:     DetachFromTopLevelWidget();
62248:   }
46194: 
    1:   nsresult rv;
    1:   mViewManager = do_CreateInstance(kViewManagerCID, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
68668:   nsDeviceContext *dx = mPresContext->DeviceContext();
    1: 
    1:   rv = mViewManager->Init(dx);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
30513:   // The root view is always at 0,0.
30513:   nsRect tbounds(nsPoint(0, 0), aSize);
30513:   // Create a view
30513:   nsIView* view = mViewManager->CreateView(tbounds, aContainerView);
30513:   if (!view)
30513:     return NS_ERROR_OUT_OF_MEMORY;
30513: 
51048:   // Create a widget if we were given a parent widget or don't have a
52208:   // container view that we can hook up to without a widget.
52209:   // Don't create widgets for ResourceDocs (external resources & svg images),
52209:   // because when they're displayed, they're painted into *another* document's
52209:   // widget.
52209:   if (!mDocument->IsResourceDoc() &&
52208:       (mParentWidget || !aContainerView)) {
30513:     // pass in a native widget to be the parent widget ONLY if the view hierarchy will stand alone.
30513:     // otherwise the view will find its own parent widget and "do the right thing" to
30513:     // establish a parent/child widget relationship
30513:     nsWidgetInitData initData;
30513:     nsWidgetInitData* initDataPtr;
30513:     if (!mParentWidget) {
30513:       initDataPtr = &initData;
30513:       initData.mWindowType = eWindowType_invisible;
30513:     } else {
30513:       initDataPtr = nsnull;
30513:     }
46194: 
62248:     if (shouldAttach) {
46194:       // Reuse the top level parent widget.
46194:       rv = view->AttachToTopLevelWidget(mParentWidget);
80486:       mAttachedToParent = true;
46194:     }
51048:     else if (!aContainerView && mParentWidget) {
51050:       rv = view->CreateWidgetForParent(mParentWidget, initDataPtr,
80486:                                        true, false);
51048:     }
46194:     else {
80486:       rv = view->CreateWidget(initDataPtr, true, false);
46194:     }
30513:     if (NS_FAILED(rv))
30513:       return rv;
30537:   }
30513: 
30513:   // Setup hierarchical relationship in view manager
30513:   mViewManager->SetRootView(view);
30513: 
30513:   mWindow = view->GetWidget();
30513: 
30513:   // This SetFocus is necessary so the Arrow Key and Page Key events
30513:   // go to the scrolled view as soon as the Window is created instead of going to
30513:   // the browser window (this enables keyboard scrolling of the document)
30513:   // mWindow->SetFocus();
30513: 
30513:   return rv;
30513: }
30513: 
46194: void
46194: DocumentViewerImpl::DetachFromTopLevelWidget()
46194: {
46194:   if (mViewManager) {
64435:     nsIView* oldView = mViewManager->GetRootView();
46194:     if (oldView && oldView->IsAttachedToTopLevel()) {
46194:       oldView->DetachFromTopLevelWidget();
46194:     }
46194:   }
80486:   mAttachedToParent = false;
46194: }
46194: 
30513: nsIView*
30513: DocumentViewerImpl::FindContainerView()
30513: {
30537:   nsIView* containerView = nsnull;
30537: 
51635:   if (mContainer) {
30537:     nsCOMPtr<nsIDocShellTreeItem> docShellItem = do_QueryReferent(mContainer);
30537:     nsCOMPtr<nsPIDOMWindow> pwin(do_GetInterface(docShellItem));
30537:     if (pwin) {
51634:       nsCOMPtr<nsIContent> containerElement = do_QueryInterface(pwin->GetFrameElementInternal());
78878:       if (!containerElement) {
78878:         return nsnull;
78878:       }
30537:       nsCOMPtr<nsIPresShell> parentPresShell;
30537:       if (docShellItem) {
30537:         nsCOMPtr<nsIDocShellTreeItem> parentDocShellItem;
30537:         docShellItem->GetParent(getter_AddRefs(parentDocShellItem));
30537:         if (parentDocShellItem) {
30537:           nsCOMPtr<nsIDocShell> parentDocShell = do_QueryInterface(parentDocShellItem);
30537:           parentDocShell->GetPresShell(getter_AddRefs(parentPresShell));
30537:         }
30537:       }
78878:       if (!parentPresShell) {
51185:         nsCOMPtr<nsIDocument> parentDoc = containerElement->GetCurrentDoc();
51185:         if (parentDoc) {
51185:           parentPresShell = parentDoc->GetShell();
51185:         }
51185:       }
78878:       if (!parentPresShell) {
31952:         NS_WARNING("Subdocument container has no presshell");
31952:       } else {
38958:         nsIFrame* f = parentPresShell->GetRealPrimaryFrameFor(containerElement);
30537:         if (f) {
30537:           nsIFrame* subdocFrame = f->GetContentInsertionFrame();
30537:           // subdocFrame might not be a subdocument frame; the frame
30537:           // constructor can treat a <frame> as an inline in some XBL
30537:           // cases. Treat that as display:none, the document is not
30537:           // displayed.
30537:           if (subdocFrame->GetType() == nsGkAtoms::subDocumentFrame) {
54315:             NS_ASSERTION(subdocFrame->GetView(), "Subdoc frames must have views");
54315:             nsIView* innerView =
54315:               static_cast<nsSubDocumentFrame*>(subdocFrame)->EnsureInnerView();
30537:             containerView = innerView;
31952:           } else {
31952:             NS_WARNING("Subdocument container has non-subdocument frame");
31952:           }
31952:         } else {
31952:           NS_WARNING("Subdocument container has no frame");
30537:         }
30537:       }
30537:     }
30537:   }
30537: 
38958:   return containerView;
    1: }
    1: 
17009: nsresult
30537: DocumentViewerImpl::CreateDeviceContext(nsIView* aContainerView)
17009: {
39705:   NS_PRECONDITION(!mPresShell && !mWindow,
19869:                   "This will screw up our existing presentation");
20078:   NS_PRECONDITION(mDocument, "Gotta have a document here");
20078:   
20078:   nsIDocument* doc = mDocument->GetDisplayDocument();
20078:   if (doc) {
30537:     NS_ASSERTION(!aContainerView, "External resource document embedded somewhere?");
20078:     // We want to use our display document's device context if possible
46225:     nsIPresShell* shell = doc->GetShell();
20078:     if (shell) {
20078:       nsPresContext* ctx = shell->GetPresContext();
20078:       if (ctx) {
20078:         mDeviceContext = ctx->DeviceContext();
20078:         return NS_OK;
20078:       }
20078:     }
20078:   }
20078:   
19869:   // Create a device context even if we already have one, since our widget
19869:   // might have changed.
30537:   nsIWidget* widget = nsnull;
30537:   if (aContainerView) {
30537:     widget = aContainerView->GetNearestWidget(nsnull);
31621:   }
31621:   if (!widget) {
31621:     widget = mParentWidget;
31621:   }
30537:   if (widget) {
30537:     widget = widget->GetTopLevelWidget();
30537:   }
31621: 
68667:   mDeviceContext = new nsDeviceContext();
30537:   mDeviceContext->Init(widget);
17009:   return NS_OK;
17009: }
17009: 
    1: // Return the selection for the document. Note that text fields have their
39646: // own selection, which cannot be accessed with this method.
    1: nsresult DocumentViewerImpl::GetDocumentSelection(nsISelection **aSelection)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aSelection);
    1:   if (!mPresShell) {
    1:     return NS_ERROR_NOT_INITIALIZED;
    1:   }
    1: 
    1:   nsCOMPtr<nsISelectionController> selcon;
    1:   selcon = do_QueryInterface(mPresShell);
    1:   if (selcon)
    1:     return selcon->GetSelection(nsISelectionController::SELECTION_NORMAL,
    1:                                 aSelection);
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* ========================================================================================
    1:  * nsIContentViewerEdit
    1:  * ======================================================================================== */
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::ClearSelection()
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsISelection> selection;
    1: 
39646:   // use nsCopySupport::GetSelectionForCopy() ?
    1:   rv = GetDocumentSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   return selection->CollapseToStart();
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::SelectAll()
    1: {
    1:   // XXX this is a temporary implementation copied from nsWebShell
    1:   // for now. I think nsDocument and friends should have some helper
    1:   // functions to make this easier.
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult rv;
    1: 
39646:   // use nsCopySupport::GetSelectionForCopy() ?
    1:   rv = GetDocumentSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmldoc = do_QueryInterface(mDocument);
    1:   nsCOMPtr<nsIDOMNode> bodyNode;
    1: 
    1:   if (htmldoc)
    1:   {
    1:     nsCOMPtr<nsIDOMHTMLElement>bodyElement;
    1:     rv = htmldoc->GetBody(getter_AddRefs(bodyElement));
    1:     if (NS_FAILED(rv) || !bodyElement) return rv;
    1: 
    1:     bodyNode = do_QueryInterface(bodyElement);
    1:   }
    1:   else if (mDocument)
    1:   {
41634:     bodyNode = do_QueryInterface(mDocument->GetRootElement());
    1:   }
    1:   if (!bodyNode) return NS_ERROR_FAILURE;
    1: 
    1:   rv = selection->RemoveAllRanges();
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = selection->SelectAllChildren(bodyNode);
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::CopySelection()
    1: {
39646:   nsCopySupport::FireClipboardEvent(NS_COPY, mPresShell, nsnull);
39646:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::CopyLinkLocation()
    1: {
    1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   GetPopupLinkNode(getter_AddRefs(node));
    1:   // make noise if we're not in a link
    1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
    1:   nsAutoString locationText;
    1:   nsresult rv = mPresShell->GetLinkLocation(node, locationText);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIClipboardHelper> clipboard(do_GetService("@mozilla.org/widget/clipboardhelper;1", &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // copy the href onto the clipboard
    1:   return clipboard->CopyString(locationText);
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::CopyImage(PRInt32 aCopyFlags)
    1: {
    1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
    1:   nsCOMPtr<nsIImageLoadingContent> node;
    1:   GetPopupImageNode(getter_AddRefs(node));
    1:   // make noise if we're not in an image
    1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
    1:   return nsCopySupport::ImageCopy(node, aCopyFlags);
    1: }
    1: 
 5538: 
79445: NS_IMETHODIMP DocumentViewerImpl::GetCopyable(bool *aCopyable)
    1: {
 4010:   NS_ENSURE_ARG_POINTER(aCopyable);
39646:   *aCopyable = nsCopySupport::CanCopy(mDocument);
12176:   return NS_OK;
    1: }
    1: 
    1: /* AString getContents (in string mimeType, in boolean selectionOnly); */
79445: NS_IMETHODIMP DocumentViewerImpl::GetContents(const char *mimeType, bool selectionOnly, nsAString& aOutValue)
    1: {
39646:   aOutValue.Truncate();
39646: 
    1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
39646:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_INITIALIZED);
39646: 
39646:   // Now we have the selection.  Make sure it's nonzero:
39646:   nsCOMPtr<nsISelection> sel;
39646:   if (selectionOnly) {
39646:     nsCopySupport::GetSelectionForCopy(mDocument, getter_AddRefs(sel));
39646:     NS_ENSURE_TRUE(sel, NS_ERROR_FAILURE);
39646:   
79445:     bool isCollapsed;
39646:     sel->GetIsCollapsed(&isCollapsed);
39646:     if (isCollapsed)
39646:       return NS_OK;
39646:   }
39646: 
39646:   // call the copy code
39646:   return nsCopySupport::GetContents(nsDependentCString(mimeType), 0, sel,
39646:                                     mDocument, aOutValue);
    1: }
    1: 
    1: /* readonly attribute boolean canGetContents; */
79445: NS_IMETHODIMP DocumentViewerImpl::GetCanGetContents(bool *aCanGetContents)
    1: {
39646:   NS_ENSURE_ARG_POINTER(aCanGetContents);
80486:   *aCanGetContents = false;
39646:   NS_ENSURE_STATE(mDocument);
39646:   *aCanGetContents = nsCopySupport::CanCopy(mDocument);
39646:   return NS_OK;
    1: }
    1: 
    1: 
    1: /* ========================================================================================
    1:  * nsIContentViewerFile
    1:  * ======================================================================================== */
    1: /** ---------------------------------------------------
    1:  *  See documentation above in the nsIContentViewerfile class definition
    1:  *	@update 01/24/00 dwc
    1:  */
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::Print(bool              aSilent,
    1:                           FILE *            aDebugFile,
    1:                           nsIPrintSettings* aPrintSettings)
    1: {
    1: #ifdef NS_PRINTING
    1:   nsCOMPtr<nsIPrintSettings> printSettings;
    1: 
    1: #ifdef NS_DEBUG
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   mDebugFile = aDebugFile;
    1:   // if they don't pass in a PrintSettings, then make one
    1:   // it will have all the default values
    1:   printSettings = aPrintSettings;
    1:   nsCOMPtr<nsIPrintOptions> printOptions = do_GetService(sPrintOptionsContractID, &rv);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // if they don't pass in a PrintSettings, then make one
    1:     if (printSettings == nsnull) {
    1:       printOptions->CreatePrintSettings(getter_AddRefs(printSettings));
    1:     }
    1:     NS_ASSERTION(printSettings, "You can't PrintPreview without a PrintSettings!");
    1:   }
    1:   if (printSettings) printSettings->SetPrintSilent(aSilent);
80486:   if (printSettings) printSettings->SetShowPrintProgress(false);
    1: #endif
    1: 
    1: 
    1:   return Print(printSettings, nsnull);
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
73870: /* [noscript] void printWithParent (in nsIDOMWindow aParentWin, in nsIPrintSettings aThePrintSettings, in nsIWebProgressListener aWPListener); */
    1: NS_IMETHODIMP 
73870: DocumentViewerImpl::PrintWithParent(nsIDOMWindow*, nsIPrintSettings *aThePrintSettings, nsIWebProgressListener *aWPListener)
    1: {
    1: #ifdef NS_PRINTING
    1:   return Print(aThePrintSettings, aWPListener);
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
    1: // nsIContentViewerFile interface
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::GetPrintable(bool *aPrintable)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPrintable);
    1: 
    1:   *aPrintable = !GetIsPrinting();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsIMarkupDocumentViewer
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::ScrollToNode(nsIDOMNode* aNode)
    1: {
    1:    NS_ENSURE_ARG(aNode);
    1:    NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
    1:    nsCOMPtr<nsIPresShell> presShell;
    1:    NS_ENSURE_SUCCESS(GetPresShell(getter_AddRefs(presShell)), NS_ERROR_FAILURE);
    1: 
    1:    // Get the nsIContent interface, because that's what we need to
    1:    // get the primary frame
    1: 
    1:    nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
    1:    NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
    1: 
    1:    // Tell the PresShell to scroll to the primary frame of the content.
    1:    NS_ENSURE_SUCCESS(presShell->ScrollContentIntoView(content,
    1:                                                       NS_PRESSHELL_SCROLL_TOP,
56647:                                                       NS_PRESSHELL_SCROLL_ANYWHERE,
56647:                                                       nsIPresShell::SCROLL_OVERFLOW_HIDDEN),
    1:                      NS_ERROR_FAILURE);
    1:    return NS_OK;
    1: }
    1: 
    1: void
    1: DocumentViewerImpl::CallChildren(CallChildFunc aFunc, void* aClosure)
    1: {
    1:   nsCOMPtr<nsIDocShellTreeNode> docShellNode(do_QueryReferent(mContainer));
    1:   if (docShellNode)
    1:   {
    1:     PRInt32 i;
    1:     PRInt32 n;
    1:     docShellNode->GetChildCount(&n);
    1:     for (i=0; i < n; i++)
    1:     {
    1:       nsCOMPtr<nsIDocShellTreeItem> child;
    1:       docShellNode->GetChildAt(i, getter_AddRefs(child));
    1:       nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
    1:       NS_ASSERTION(childAsShell, "null child in docshell");
    1:       if (childAsShell)
    1:       {
    1:         nsCOMPtr<nsIContentViewer> childCV;
    1:         childAsShell->GetContentViewer(getter_AddRefs(childCV));
    1:         if (childCV)
    1:         {
    1:           nsCOMPtr<nsIMarkupDocumentViewer> markupCV = do_QueryInterface(childCV);
    1:           if (markupCV) {
    1:             (*aFunc)(markupCV, aClosure);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
 4359: struct ZoomInfo
    1: {
 4359:   float mZoom;
    1: };
    1: 
    1: static void
    1: SetChildTextZoom(nsIMarkupDocumentViewer* aChild, void* aClosure)
    1: {
 4359:   struct ZoomInfo* ZoomInfo = (struct ZoomInfo*) aClosure;
 4359:   aChild->SetTextZoom(ZoomInfo->mZoom);
 4359: }
 4359: 
 4359: static void
63383: SetChildMinFontSize(nsIMarkupDocumentViewer* aChild, void* aClosure)
63383: {
71056:   nsCOMPtr<nsIMarkupDocumentViewer> branch =
63383:     do_QueryInterface(aChild);
68822:   branch->SetMinFontSize(NS_PTR_TO_INT32(aClosure));
63383: }
63383: 
63383: static void
 4359: SetChildFullZoom(nsIMarkupDocumentViewer* aChild, void* aClosure)
 4359: {
 4359:   struct ZoomInfo* ZoomInfo = (struct ZoomInfo*) aClosure;
 4359:   aChild->SetFullZoom(ZoomInfo->mZoom);
    1: }
    1: 
79445: static bool
20078: SetExtResourceTextZoom(nsIDocument* aDocument, void* aClosure)
20078: {
20078:   // Would it be better to enumerate external resource viewers instead?
46225:   nsIPresShell* shell = aDocument->GetShell();
20078:   if (shell) {
20078:     nsPresContext* ctxt = shell->GetPresContext();
20078:     if (ctxt) {
20078:       struct ZoomInfo* ZoomInfo = static_cast<struct ZoomInfo*>(aClosure);
20078:       ctxt->SetTextZoom(ZoomInfo->mZoom);
20078:     }
20078:   }
20078: 
80486:   return true;
20078: }
20078: 
79445: static bool
63383: SetExtResourceMinFontSize(nsIDocument* aDocument, void* aClosure)
63383: {
63383:   nsIPresShell* shell = aDocument->GetShell();
63383:   if (shell) {
63383:     nsPresContext* ctxt = shell->GetPresContext();
63383:     if (ctxt) {
68822:       ctxt->SetMinFontSize(NS_PTR_TO_INT32(aClosure));
63383:     }
63383:   }
63383: 
80486:   return true;
63383: }
63383: 
79445: static bool
20078: SetExtResourceFullZoom(nsIDocument* aDocument, void* aClosure)
20078: {
20078:   // Would it be better to enumerate external resource viewers instead?
46225:   nsIPresShell* shell = aDocument->GetShell();
20078:   if (shell) {
20078:     nsPresContext* ctxt = shell->GetPresContext();
20078:     if (ctxt) {
20078:       struct ZoomInfo* ZoomInfo = static_cast<struct ZoomInfo*>(aClosure);
20078:       ctxt->SetFullZoom(ZoomInfo->mZoom);
20078:     }
20078:   }
20078: 
80486:   return true;
20078: }
20078: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::SetTextZoom(float aTextZoom)
    1: {
25840:   if (GetIsPrintPreview()) {
25840:     return NS_OK;
25840:   }
25840: 
    1:   mTextZoom = aTextZoom;
10730: 
10730:   nsIViewManager::UpdateViewBatch batch(GetViewManager());
    1:       
    1:   // Set the text zoom on all children of mContainer (even if our zoom didn't
    1:   // change, our children's zoom may be different, though it would be unusual).
    1:   // Do this first, in case kids are auto-sizing and post reflow commands on
    1:   // our presshell (which should be subsumed into our own style change reflow).
 4359:   struct ZoomInfo ZoomInfo = { aTextZoom };
 4359:   CallChildren(SetChildTextZoom, &ZoomInfo);
    1: 
    1:   // Now change our own zoom
 7740:   nsPresContext* pc = GetPresContext();
 7740:   if (pc && aTextZoom != mPresContext->TextZoom()) {
 7740:       pc->SetTextZoom(aTextZoom);
 7740:   }
 7740: 
20078:   // And do the external resources
20078:   mDocument->EnumerateExternalResources(SetExtResourceTextZoom, &ZoomInfo);
20078: 
10730:   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::GetTextZoom(float* aTextZoom)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aTextZoom);
 7740:   nsPresContext* pc = GetPresContext();
 7740:   *aTextZoom = pc ? pc->TextZoom() : 1.0f;
    1:   return NS_OK;
    1: }
    1: 
 4003: NS_IMETHODIMP
63383: DocumentViewerImpl::SetMinFontSize(PRInt32 aMinFontSize)
63383: {
63383:   if (GetIsPrintPreview()) {
63383:     return NS_OK;
63383:   }
63383: 
63383:   mMinFontSize = aMinFontSize;
63383: 
63383:   nsIViewManager::UpdateViewBatch batch(GetViewManager());
63383:       
63383:   // Set the min font on all children of mContainer (even if our min font didn't
63383:   // change, our children's min font may be different, though it would be unusual).
63383:   // Do this first, in case kids are auto-sizing and post reflow commands on
63383:   // our presshell (which should be subsumed into our own style change reflow).
68822:   CallChildren(SetChildMinFontSize, NS_INT32_TO_PTR(aMinFontSize));
63383: 
63383:   // Now change our own min font
63383:   nsPresContext* pc = GetPresContext();
63383:   if (pc && aMinFontSize != mPresContext->MinFontSize()) {
63383:     pc->SetMinFontSize(aMinFontSize);
63383:   }
63383: 
63383:   // And do the external resources
68822:   mDocument->EnumerateExternalResources(SetExtResourceMinFontSize,
68822:                                         NS_INT32_TO_PTR(aMinFontSize));
63383: 
63383:   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
63383:   
63383:   return NS_OK;
63383: }
63383: 
63383: NS_IMETHODIMP
63383: DocumentViewerImpl::GetMinFontSize(PRInt32* aMinFontSize)
63383: {
63383:   NS_ENSURE_ARG_POINTER(aMinFontSize);
63383:   nsPresContext* pc = GetPresContext();
63383:   *aMinFontSize = pc ? pc->MinFontSize() : 0;
63383:   return NS_OK;
63383: }
63383: 
63383: NS_IMETHODIMP
 4003: DocumentViewerImpl::SetFullZoom(float aFullZoom)
 4003: {
25840: #ifdef NS_PRINT_PREVIEW
25840:   if (GetIsPrintPreview()) {
25840:     nsPresContext* pc = GetPresContext();
25840:     NS_ENSURE_TRUE(pc, NS_OK);
25840:     nsCOMPtr<nsIPresShell> shell = pc->GetPresShell();
25840:     NS_ENSURE_TRUE(shell, NS_OK);
25840: 
26050:     nsIViewManager::UpdateViewBatch batch(shell->GetViewManager());
25840:     if (!mPrintPreviewZoomed) {
25840:       mOriginalPrintPreviewScale = pc->GetPrintPreviewScale();
80486:       mPrintPreviewZoomed = true;
25840:     }
25840: 
25840:     mPrintPreviewZoom = aFullZoom;
25840:     pc->SetPrintPreviewScale(aFullZoom * mOriginalPrintPreviewScale);
39668:     nsIPageSequenceFrame* pf = shell->GetPageSequenceFrame();
25840:     if (pf) {
25840:       nsIFrame* f = do_QueryFrame(pf);
25840:       shell->FrameNeedsReflow(f, nsIPresShell::eResize, NS_FRAME_IS_DIRTY);
25840:     }
25840: 
25840:     nsIFrame* rootFrame = shell->GetRootFrame();
25840:     if (rootFrame) {
25840:       nsRect rect(nsPoint(0, 0), rootFrame->GetSize());
25840:       rootFrame->Invalidate(rect);
25840:     }
25840:     batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
25840:     return NS_OK;
25840:   }
25840: #endif
25840: 
 5357:   mPageZoom = aFullZoom;
 7740: 
10730:   nsIViewManager::UpdateViewBatch batch(GetViewManager());
 7740: 
 4359:   struct ZoomInfo ZoomInfo = { aFullZoom };
 4359:   CallChildren(SetChildFullZoom, &ZoomInfo);
 7740: 
 7740:   nsPresContext* pc = GetPresContext();
 7740:   if (pc) {
 7740:     pc->SetFullZoom(aFullZoom);
 7740:   }
 7740: 
20078:   // And do the external resources
20078:   mDocument->EnumerateExternalResources(SetExtResourceFullZoom, &ZoomInfo);
20078: 
10730:   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
 4003: 
 4003:   return NS_OK;
 4003: }
 4003: 
 4003: NS_IMETHODIMP
 4003: DocumentViewerImpl::GetFullZoom(float* aFullZoom)
 4003: {
 4003:   NS_ENSURE_ARG_POINTER(aFullZoom);
25840: #ifdef NS_PRINT_PREVIEW
25840:   if (GetIsPrintPreview()) {
25840:     *aFullZoom = mPrintPreviewZoom;
25840:     return NS_OK;
25840:   }
25840: #endif
15169:   // Check the prescontext first because it might have a temporary
15169:   // setting for print-preview
 7740:   nsPresContext* pc = GetPresContext();
15169:   *aFullZoom = pc ? pc->GetFullZoom() : mPageZoom;
 4003:   return NS_OK;
 4003: }
 4003: 
    1: static void
    1: SetChildAuthorStyleDisabled(nsIMarkupDocumentViewer* aChild, void* aClosure)
    1: {
79445:   bool styleDisabled  = *static_cast<bool*>(aClosure);
    1:   aChild->SetAuthorStyleDisabled(styleDisabled);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::SetAuthorStyleDisabled(bool aStyleDisabled)
    1: {
    1:   if (mPresShell) {
    1:     mPresShell->SetAuthorStyleDisabled(aStyleDisabled);
    1:   }
    1:   CallChildren(SetChildAuthorStyleDisabled, &aStyleDisabled);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::GetAuthorStyleDisabled(bool* aStyleDisabled)
    1: {
    1:   if (mPresShell) {
    1:     *aStyleDisabled = mPresShell->GetAuthorStyleDisabled();
    1:   } else {
80486:     *aStyleDisabled = false;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::GetDefaultCharacterSet(nsACString& aDefaultCharacterSet)
    1: {
    1:   if (mDefaultCharacterSet.IsEmpty())
    1:   {
70976:     const nsAdoptingCString& defCharset =
70976:       Preferences::GetLocalizedCString("intl.charset.default");
70976: 
70976:     if (!defCharset.IsEmpty()) {
70976:       mDefaultCharacterSet = defCharset;
70976:     } else {
    1:       mDefaultCharacterSet.AssignLiteral("ISO-8859-1");
    1:     }
70976:   }
    1:   aDefaultCharacterSet = mDefaultCharacterSet;
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: SetChildDefaultCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
    1: {
 3233:   const nsACString* charset = static_cast<nsACString*>(aClosure);
    1:   aChild->SetDefaultCharacterSet(*charset);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::SetDefaultCharacterSet(const nsACString& aDefaultCharacterSet)
    1: {
    1:   mDefaultCharacterSet = aDefaultCharacterSet;  // this does a copy of aDefaultCharacterSet
    1:   // now set the default char set on all children of mContainer
    1:   CallChildren(SetChildDefaultCharacterSet, (void*) &aDefaultCharacterSet);
    1:   return NS_OK;
    1: }
    1: 
    1: // XXX: SEMANTIC CHANGE!
    1: //      returns a copy of the string.  Caller is responsible for freeing result
    1: //      using Recycle(aForceCharacterSet)
    1: NS_IMETHODIMP DocumentViewerImpl::GetForceCharacterSet(nsACString& aForceCharacterSet)
    1: {
    1:   aForceCharacterSet = mForceCharacterSet;
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: SetChildForceCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
    1: {
 3233:   const nsACString* charset = static_cast<nsACString*>(aClosure);
    1:   aChild->SetForceCharacterSet(*charset);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::SetForceCharacterSet(const nsACString& aForceCharacterSet)
    1: {
    1:   mForceCharacterSet = aForceCharacterSet;
    1:   // now set the force char set on all children of mContainer
    1:   CallChildren(SetChildForceCharacterSet, (void*) &aForceCharacterSet);
    1:   return NS_OK;
    1: }
    1: 
    1: // XXX: SEMANTIC CHANGE!
    1: //      returns a copy of the string.  Caller is responsible for freeing result
    1: //      using Recycle(aHintCharacterSet)
    1: NS_IMETHODIMP DocumentViewerImpl::GetHintCharacterSet(nsACString& aHintCharacterSet)
    1: {
    1: 
    1:   if(kCharsetUninitialized == mHintCharsetSource) {
    1:     aHintCharacterSet.Truncate();
    1:   } else {
    1:     aHintCharacterSet = mHintCharset;
    1:     // this can't possibly be right.  we can't set a value just because somebody got a related value!
    1:     //mHintCharsetSource = kCharsetUninitialized;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::GetHintCharacterSetSource(PRInt32 *aHintCharacterSetSource)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aHintCharacterSetSource);
    1: 
    1:   *aHintCharacterSetSource = mHintCharsetSource;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::GetPrevDocCharacterSet(nsACString& aPrevDocCharacterSet)
    1: {
    1:   aPrevDocCharacterSet = mPrevDocCharacterSet;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: SetChildPrevDocCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
    1: {
 3233:   const nsACString* charset = static_cast<nsACString*>(aClosure);
    1:   aChild->SetPrevDocCharacterSet(*charset);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::SetPrevDocCharacterSet(const nsACString& aPrevDocCharacterSet)
    1: {
    1:   mPrevDocCharacterSet = aPrevDocCharacterSet;  
    1:   CallChildren(SetChildPrevDocCharacterSet, (void*) &aPrevDocCharacterSet);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: static void
    1: SetChildHintCharacterSetSource(nsIMarkupDocumentViewer* aChild, void* aClosure)
    1: {
    1:   aChild->SetHintCharacterSetSource(NS_PTR_TO_INT32(aClosure));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::SetHintCharacterSetSource(PRInt32 aHintCharacterSetSource)
    1: {
    1:   mHintCharsetSource = aHintCharacterSetSource;
    1:   // now set the hint char set source on all children of mContainer
    1:   CallChildren(SetChildHintCharacterSetSource,
68822:                       NS_INT32_TO_PTR(aHintCharacterSetSource));
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: SetChildHintCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
    1: {
 3233:   const nsACString* charset = static_cast<nsACString*>(aClosure);
    1:   aChild->SetHintCharacterSet(*charset);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::SetHintCharacterSet(const nsACString& aHintCharacterSet)
    1: {
    1:   mHintCharset = aHintCharacterSet;
    1:   // now set the hint char set on all children of mContainer
    1:   CallChildren(SetChildHintCharacterSet, (void*) &aHintCharacterSet);
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: SetChildBidiOptions(nsIMarkupDocumentViewer* aChild, void* aClosure)
    1: {
    1:   aChild->SetBidiOptions(NS_PTR_TO_INT32(aClosure));
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::SetBidiTextDirection(PRUint8 aTextDirection)
    1: {
    1:   PRUint32 bidiOptions;
    1: 
    1:   GetBidiOptions(&bidiOptions);
    1:   SET_BIDI_OPTION_DIRECTION(bidiOptions, aTextDirection);
    1:   SetBidiOptions(bidiOptions);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::GetBidiTextDirection(PRUint8* aTextDirection)
    1: {
    1:   PRUint32 bidiOptions;
    1: 
    1:   if (aTextDirection) {
    1:     GetBidiOptions(&bidiOptions);
    1:     *aTextDirection = GET_BIDI_OPTION_DIRECTION(bidiOptions);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::SetBidiTextType(PRUint8 aTextType)
    1: {
    1:   PRUint32 bidiOptions;
    1: 
    1:   GetBidiOptions(&bidiOptions);
    1:   SET_BIDI_OPTION_TEXTTYPE(bidiOptions, aTextType);
    1:   SetBidiOptions(bidiOptions);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::GetBidiTextType(PRUint8* aTextType)
    1: {
    1:   PRUint32 bidiOptions;
    1: 
    1:   if (aTextType) {
    1:     GetBidiOptions(&bidiOptions);
    1:     *aTextType = GET_BIDI_OPTION_TEXTTYPE(bidiOptions);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::SetBidiNumeral(PRUint8 aNumeral)
    1: {
    1:   PRUint32 bidiOptions;
    1: 
    1:   GetBidiOptions(&bidiOptions);
    1:   SET_BIDI_OPTION_NUMERAL(bidiOptions, aNumeral);
    1:   SetBidiOptions(bidiOptions);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::GetBidiNumeral(PRUint8* aNumeral)
    1: {
    1:   PRUint32 bidiOptions;
    1: 
    1:   if (aNumeral) {
    1:     GetBidiOptions(&bidiOptions);
    1:     *aNumeral = GET_BIDI_OPTION_NUMERAL(bidiOptions);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::SetBidiSupport(PRUint8 aSupport)
    1: {
    1:   PRUint32 bidiOptions;
    1: 
    1:   GetBidiOptions(&bidiOptions);
    1:   SET_BIDI_OPTION_SUPPORT(bidiOptions, aSupport);
    1:   SetBidiOptions(bidiOptions);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::GetBidiSupport(PRUint8* aSupport)
    1: {
    1:   PRUint32 bidiOptions;
    1: 
    1:   if (aSupport) {
    1:     GetBidiOptions(&bidiOptions);
    1:     *aSupport = GET_BIDI_OPTION_SUPPORT(bidiOptions);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::SetBidiOptions(PRUint32 aBidiOptions)
    1: {
    1:   if (mPresContext) {
80486:     mPresContext->SetBidi(aBidiOptions, true); // could cause reflow
    1:   }
    1:   // now set bidi on all children of mContainer
68822:   CallChildren(SetChildBidiOptions, NS_INT32_TO_PTR(aBidiOptions));
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::GetBidiOptions(PRUint32* aBidiOptions)
    1: {
    1:   if (aBidiOptions) {
    1:     if (mPresContext) {
    1:       *aBidiOptions = mPresContext->GetBidi();
    1:     }
    1:     else
    1:       *aBidiOptions = IBMBIDI_DEFAULT_BIDI_OPTIONS;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP DocumentViewerImpl::SizeToContent()
    1: {
    1:    NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
    1: 
19869:    // Skip doing this on docshell-less documents for now
    1:    nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryReferent(mContainer));
19869:    NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_NOT_AVAILABLE);
    1:    
    1:    nsCOMPtr<nsIDocShellTreeItem> docShellParent;
    1:    docShellAsItem->GetSameTypeParent(getter_AddRefs(docShellParent));
    1: 
    1:    // It's only valid to access this from a top frame.  Doesn't work from
    1:    // sub-frames.
    1:    NS_ENSURE_TRUE(!docShellParent, NS_ERROR_FAILURE);
    1: 
    1:    nsCOMPtr<nsIPresShell> presShell;
    1:    GetPresShell(getter_AddRefs(presShell));
    1:    NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
    1: 
    1:    // Flush out all content and style updates. We can't use a resize reflow
    1:    // because it won't change some sizes that a style change reflow will.
    1:    mDocument->FlushPendingNotifications(Flush_Layout);
    1: 
    1:   nsIFrame *root = presShell->GetRootFrame();
    1:   NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
    1: 
    1:   nscoord prefWidth;
    1:   {
68481:     nsRefPtr<nsRenderingContext> rcx =
51038:       presShell->GetReferenceRenderingContext();
    1:     NS_ENSURE_TRUE(rcx, NS_ERROR_FAILURE);
    1:     prefWidth = root->GetPrefWidth(rcx);
    1:   }
    1: 
    1:   nsresult rv = presShell->ResizeReflow(prefWidth, NS_UNCONSTRAINEDSIZE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
39823:    nsRefPtr<nsPresContext> presContext;
    1:    GetPresContext(getter_AddRefs(presContext));
    1:    NS_ENSURE_TRUE(presContext, NS_ERROR_FAILURE);
    1: 
    1:    PRInt32 width, height;
    1: 
    1:    // so how big is it?
    1:    nsRect shellArea = presContext->GetVisibleArea();
    1:    // Protect against bogus returns here
12971:    NS_ENSURE_TRUE(shellArea.width != NS_UNCONSTRAINEDSIZE &&
12971:                   shellArea.height != NS_UNCONSTRAINEDSIZE,
12971:                   NS_ERROR_FAILURE);
    1:    width = presContext->AppUnitsToDevPixels(shellArea.width);
    1:    height = presContext->AppUnitsToDevPixels(shellArea.height);
    1: 
    1:    nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:    docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
    1:    NS_ENSURE_TRUE(treeOwner, NS_ERROR_FAILURE);
    1: 
78045:    /* presContext's size was calculated in app units and has already been
78045:       rounded to the equivalent pixels (so the width/height calculation
78045:       we just performed was probably exact, though it was based on
78045:       values already rounded during ResizeReflow). In a surprising
78045:       number of instances, this rounding makes a window which for want
78045:       of one extra pixel's width ends up wrapping the longest line of
78045:       text during actual window layout. This makes the window too short,
78045:       generally clipping the OK/Cancel buttons. Here we add one pixel
78045:       to the calculated width, to circumvent this problem. */
78045:    NS_ENSURE_SUCCESS(treeOwner->SizeShellTo(docShellAsItem, width+1, height),
    1:       NS_ERROR_FAILURE);
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMPL_ISUPPORTS1(nsDocViewerSelectionListener, nsISelectionListener)
    1: 
    1: nsresult nsDocViewerSelectionListener::Init(DocumentViewerImpl *aDocViewer)
    1: {
    1:   mDocViewer = aDocViewer;
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * GetPopupNode, GetPopupLinkNode and GetPopupImageNode are helpers
    1:  * for the cmd_copyLink / cmd_copyImageLocation / cmd_copyImageContents family
    1:  * of commands. The focus controller stores the popup node, these retrieve
    1:  * them and munge appropriately. Note that we have to store the popup node
    1:  * rather than retrieving it from EventStateManager::GetFocusedContent because
    1:  * not all content (images included) can receive focus.
    1:  */
    1: 
    1: nsresult
    1: DocumentViewerImpl::GetPopupNode(nsIDOMNode** aNode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aNode);
    1: 
49309:   *aNode = nsnull;
49309: 
    1:   // get the document
37433:   nsIDocument* document = GetDocument();
    1:   NS_ENSURE_TRUE(document, NS_ERROR_FAILURE);
    1: 
    1:   // get the private dom window
38336:   nsCOMPtr<nsPIDOMWindow> window(document->GetWindow());
38336:   NS_ENSURE_TRUE(window, NS_ERROR_NOT_AVAILABLE);
38336:   if (window) {
38336:     nsCOMPtr<nsPIWindowRoot> root = window->GetTopWindowRoot();
38336:     NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
    1: 
    1:     // get the popup node
49309:     nsCOMPtr<nsIDOMNode> node = root->GetPopupNode();
49309: #ifdef MOZ_XUL
49309:     if (!node) {
49309:       nsPIDOMWindow* rootWindow = root->GetWindow();
49309:       if (rootWindow) {
49309:         nsCOMPtr<nsIDocument> rootDoc = do_QueryInterface(rootWindow->GetExtantDocument());
49309:         if (rootDoc) {
49309:           nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
49309:           if (pm) {
49309:             node = pm->GetLastTriggerPopupNode(rootDoc);
49309:           }
49309:         }
49309:       }
49309:     }
49309: #endif
49309:     node.swap(*aNode);
38336:   }
    1: 
37433:   return NS_OK;
    1: }
    1: 
    1: // GetPopupLinkNode: return popup link node or fail
    1: nsresult
    1: DocumentViewerImpl::GetPopupLinkNode(nsIDOMNode** aNode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aNode);
    1: 
    1:   // you get null unless i say so
    1:   *aNode = nsnull;
    1: 
    1:   // find popup node
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsresult rv = GetPopupNode(getter_AddRefs(node));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // find out if we have a link in our ancestry
    1:   while (node) {
    1: 
72415:     nsCOMPtr<nsIContent> content(do_QueryInterface(node));
72415:     if (content) {
72415:       nsCOMPtr<nsIURI> hrefURI = content->GetHrefURI();
72415:       if (hrefURI) {
    1:         *aNode = node;
    1:         NS_IF_ADDREF(*aNode); // addref
    1:         return NS_OK;
    1:       }
72415:     }
72415: 
72415:     // get our parent and keep trying...
    1:     nsCOMPtr<nsIDOMNode> parentNode;
    1:     node->GetParentNode(getter_AddRefs(parentNode));
    1:     node = parentNode;
    1:   }
    1: 
    1:   // if we have no node, fail
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: // GetPopupLinkNode: return popup image node or fail
    1: nsresult
    1: DocumentViewerImpl::GetPopupImageNode(nsIImageLoadingContent** aNode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aNode);
    1: 
    1:   // you get null unless i say so
    1:   *aNode = nsnull;
    1: 
    1:   // find popup node
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsresult rv = GetPopupNode(getter_AddRefs(node));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (node)
    1:     CallQueryInterface(node, aNode);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * XXX dr
    1:  * ------
    1:  * These two functions -- GetInLink and GetInImage -- are kind of annoying
    1:  * in that they only get called from the controller (in
    1:  * nsDOMWindowController::IsCommandEnabled). The actual construction of the
    1:  * context menus in communicator (nsContextMenu.js) has its own, redundant
    1:  * tests. No big deal, but good to keep in mind if we ever clean context
    1:  * menus.
    1:  */
    1: 
79445: NS_IMETHODIMP DocumentViewerImpl::GetInLink(bool* aInLink)
    1: {
    1: #ifdef DEBUG_dr
    1:   printf("dr :: DocumentViewerImpl::GetInLink\n");
    1: #endif
    1: 
    1:   NS_ENSURE_ARG_POINTER(aInLink);
    1: 
    1:   // we're not in a link unless i say so
80486:   *aInLink = false;
    1: 
    1:   // get the popup link
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsresult rv = GetPopupLinkNode(getter_AddRefs(node));
    1:   if (NS_FAILED(rv)) return rv;
    1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
    1:   // if we made it here, we're in a link
80486:   *aInLink = true;
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP DocumentViewerImpl::GetInImage(bool* aInImage)
    1: {
    1: #ifdef DEBUG_dr
    1:   printf("dr :: DocumentViewerImpl::GetInImage\n");
    1: #endif
    1: 
    1:   NS_ENSURE_ARG_POINTER(aInImage);
    1: 
    1:   // we're not in an image unless i say so
80486:   *aInImage = false;
    1: 
    1:   // get the popup image
    1:   nsCOMPtr<nsIImageLoadingContent> node;
    1:   nsresult rv = GetPopupImageNode(getter_AddRefs(node));
    1:   if (NS_FAILED(rv)) return rv;
    1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
    1:   // if we made it here, we're in an image
80486:   *aInImage = true;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocViewerSelectionListener::NotifySelectionChanged(nsIDOMDocument *, nsISelection *, PRInt16)
    1: {
    1:   NS_ASSERTION(mDocViewer, "Should have doc viewer!");
    1: 
    1:   // get the selection state
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult rv = mDocViewer->GetDocumentSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(rv)) return rv;
    1: 
79445:   bool selectionCollapsed;
    1:   selection->GetIsCollapsed(&selectionCollapsed);
    1:   // we only call UpdateCommands when the selection changes from collapsed
    1:   // to non-collapsed or vice versa. We might need another update string
    1:   // for simple selection changes, but that would be expenseive.
    1:   if (!mGotSelectionState || mSelectionWasCollapsed != selectionCollapsed)
    1:   {
37433:     nsIDocument* theDoc = mDocViewer->GetDocument();
    1:     if (!theDoc) return NS_ERROR_FAILURE;
    1: 
    1:     nsPIDOMWindow *domWindow = theDoc->GetWindow();
    1:     if (!domWindow) return NS_ERROR_FAILURE;
    1: 
    1:     domWindow->UpdateCommands(NS_LITERAL_STRING("select"));
80486:     mGotSelectionState = true;
    1:     mSelectionWasCollapsed = selectionCollapsed;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //nsDocViewerFocusListener
72631: NS_IMPL_ISUPPORTS1(nsDocViewerFocusListener,
    1:                    nsIDOMEventListener)
    1: 
    1: nsDocViewerFocusListener::nsDocViewerFocusListener()
    1: :mDocViewer(nsnull)
    1: {
    1: }
    1: 
    1: nsDocViewerFocusListener::~nsDocViewerFocusListener(){}
    1: 
    1: nsresult
    1: nsDocViewerFocusListener::HandleEvent(nsIDOMEvent* aEvent)
    1: {
72631:   NS_ENSURE_STATE(mDocViewer);
72631: 
    1:   nsCOMPtr<nsIPresShell> shell;
78878:   mDocViewer->GetPresShell(getter_AddRefs(shell));
72631:   NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
72631: 
72631:   nsCOMPtr<nsISelectionController> selCon = do_QueryInterface(shell);
    1:   PRInt16 selectionStatus;
    1:   selCon->GetDisplaySelection(&selectionStatus);
    1: 
72631:   nsAutoString eventType;
72631:   aEvent->GetType(eventType);
72631:   if (eventType.EqualsLiteral("focus")) {
    1:     // If selection was disabled, re-enable it.
    1:     if(selectionStatus == nsISelectionController::SELECTION_DISABLED ||
72631:        selectionStatus == nsISelectionController::SELECTION_HIDDEN) {
    1:       selCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
    1:       selCon->RepaintSelection(nsISelectionController::SELECTION_NORMAL);
    1:     }
72631:   } else {
72631:     NS_ABORT_IF_FALSE(eventType.EqualsLiteral("blur"),
72631:                       "Unexpected event type");
    1:     // If selection was on, disable it.
    1:     if(selectionStatus == nsISelectionController::SELECTION_ON ||
72631:        selectionStatus == nsISelectionController::SELECTION_ATTENTION) {
    1:       selCon->SetDisplaySelection(nsISelectionController::SELECTION_DISABLED);
    1:       selCon->RepaintSelection(nsISelectionController::SELECTION_NORMAL);
    1:     }
72631:   }
72631: 
72631:   return NS_OK;
72631: }
    1: 
    1: nsresult
    1: nsDocViewerFocusListener::Init(DocumentViewerImpl *aDocViewer)
    1: {
    1:   mDocViewer = aDocViewer;
    1:   return NS_OK;
    1: }
    1: 
    1: /** ---------------------------------------------------
    1:  *  From nsIWebBrowserPrint
    1:  */
    1: 
    1: #ifdef NS_PRINTING
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::Print(nsIPrintSettings*       aPrintSettings,
    1:                           nsIWebProgressListener* aWebProgressListener)
    1: {
    1: 
    1: #ifdef MOZ_XUL
    1:   // Temporary code for Bug 136185 / Bug 240490
    1:   nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
    1:   if (xulDoc) {
    1:     nsPrintEngine::ShowPrintErrorDialog(NS_ERROR_GFX_PRINTER_NO_XUL);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: #endif
    1: 
10495:   if (!mContainer) {
10495:     PR_PL(("Container was destroyed yet we are still trying to use it!"));
10495:     return NS_ERROR_FAILURE;
10495:   }
10495: 
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
69583:   NS_ENSURE_STATE(docShell);
    1: 
    1:   // Check to see if this document is still busy
    1:   // If it is busy and we aren't already "queued" up to print then
    1:   // Indicate there is a print pending and cache the args for later
    1:   PRUint32 busyFlags = nsIDocShell::BUSY_FLAGS_NONE;
    1:   if ((NS_FAILED(docShell->GetBusyFlags(&busyFlags)) ||
    1:        (busyFlags != nsIDocShell::BUSY_FLAGS_NONE && busyFlags & nsIDocShell::BUSY_FLAGS_PAGE_LOADING)) && 
    1:       !mPrintDocIsFullyLoaded) {
    1:     if (!mPrintIsPending) {
    1:       mCachedPrintSettings           = aPrintSettings;
    1:       mCachedPrintWebProgressListner = aWebProgressListener;
80486:       mPrintIsPending                = true;
    1:     }
    1:     PR_PL(("Printing Stopped - document is still busy!"));
    1:     return NS_ERROR_GFX_PRINTER_DOC_IS_BUSY;
    1:   }
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   docShell->GetPresShell(getter_AddRefs(presShell));
32341:   if (!presShell || !mDocument || !mDeviceContext) {
    1:     PR_PL(("Can't Print without pres shell, document etc"));
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsresult rv;
    1: 
    1:   // if we are printing another URL, then exit
    1:   // the reason we check here is because this method can be called while
    1:   // another is still in here (the printing dialog is a good example).
    1:   // the only time we can print more than one job at a time is the regression tests
    1:   if (GetIsPrinting()) {
    1:     // Let the user know we are not ready to print.
    1:     rv = NS_ERROR_NOT_AVAILABLE;
    1:     nsPrintEngine::ShowPrintErrorDialog(rv);
    1:     return rv;
    1:   }
    1: 
69880:   nsPrintEventDispatcher beforeAndAfterPrint(mDocument);
73433:   NS_ENSURE_STATE(!GetIsPrinting());
    1:   // If we are hosting a full-page plugin, tell it to print
    1:   // first. It shows its own native print UI.
    1:   nsCOMPtr<nsIPluginDocument> pDoc(do_QueryInterface(mDocument));
    1:   if (pDoc)
    1:     return pDoc->Print();
    1: 
    1:   if (!mPrintEngine) {
72850:     NS_ENSURE_STATE(mDeviceContext);
    1:     mPrintEngine = new nsPrintEngine();
    1: 
69583:     rv = mPrintEngine->Initialize(this, mContainer, mDocument, 
50791:                                   float(mDeviceContext->AppUnitsPerCSSInch()) /
31784:                                   float(mDeviceContext->AppUnitsPerDevPixel()) /
31784:                                   mPageZoom,
    1: #ifdef NS_DEBUG
    1:                                   mDebugFile
    1: #else
    1:                                   nsnull
    1: #endif
    1:                                   );
    1:     if (NS_FAILED(rv)) {
    1:       mPrintEngine->Destroy();
    1:       mPrintEngine = nsnull;
    1:       return rv;
    1:     }
    1:   }
    1: 
    1:   rv = mPrintEngine->Print(aPrintSettings, aWebProgressListener);
    1:   if (NS_FAILED(rv)) {
    1:     OnDonePrinting();
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::PrintPreview(nsIPrintSettings* aPrintSettings, 
    1:                                  nsIDOMWindow *aChildDOMWin, 
    1:                                  nsIWebProgressListener* aWebProgressListener)
    1: {
    1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
35581:   NS_WARN_IF_FALSE(IsInitializedForPrintPreview(),
35581:                    "Using docshell.printPreview is the preferred way for print previewing!");
35581: 
35581:   NS_ENSURE_ARG_POINTER(aChildDOMWin);
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (GetIsPrinting()) {
    1:     nsPrintEngine::CloseProgressDialog(aWebProgressListener);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1: #ifdef MOZ_XUL
    1:   // Temporary code for Bug 136185 / Bug 240490
    1:   nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
    1:   if (xulDoc) {
    1:     nsPrintEngine::CloseProgressDialog(aWebProgressListener);
80486:     nsPrintEngine::ShowPrintErrorDialog(NS_ERROR_GFX_PRINTER_NO_XUL, false);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: #endif
    1: 
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
51637:   if (!docShell || !mDeviceContext) {
51637:     PR_PL(("Can't Print Preview without device context and docshell"));
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
35581:   nsCOMPtr<nsIDOMDocument> domDoc;
35581:   aChildDOMWin->GetDocument(getter_AddRefs(domDoc));
35581:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
35581:   NS_ENSURE_STATE(doc);
35581: 
69880:   nsPrintEventDispatcher beforeAndAfterPrint(doc);
73433:   NS_ENSURE_STATE(!GetIsPrinting());
69880:   if (!mPrintEngine) {
    1:     mPrintEngine = new nsPrintEngine();
    1: 
69583:     rv = mPrintEngine->Initialize(this, mContainer, doc,
50791:                                   float(mDeviceContext->AppUnitsPerCSSInch()) /
31784:                                   float(mDeviceContext->AppUnitsPerDevPixel()) /
31784:                                   mPageZoom,
    1: #ifdef NS_DEBUG
    1:                                   mDebugFile
    1: #else
    1:                                   nsnull
    1: #endif
    1:                                   );
    1:     if (NS_FAILED(rv)) {
    1:       mPrintEngine->Destroy();
    1:       mPrintEngine = nsnull;
    1:       return rv;
    1:     }
    1:   }
    1: 
    1:   rv = mPrintEngine->PrintPreview(aPrintSettings, aChildDOMWin, aWebProgressListener);
80486:   mPrintPreviewZoomed = false;
    1:   if (NS_FAILED(rv)) {
    1:     OnDonePrinting();
    1:   }
    1:   return rv;
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::PrintPreviewNavigate(PRInt16 aType, PRInt32 aPageNum)
    1: {
    1:   if (!GetIsPrintPreview() ||
    1:       mPrintEngine->GetIsCreatingPrintPreview())
    1:     return NS_ERROR_FAILURE;
    1: 
37067:   nsIScrollableFrame* sf =
37067:     mPrintEngine->GetPrintPreviewPresShell()->GetRootScrollFrameAsScrollable();
37067:   if (!sf)
    1:     return NS_OK;
    1: 
    1:   // Check to see if we can short circut scrolling to the top
    1:   if (aType == nsIWebBrowserPrint::PRINTPREVIEW_HOME ||
    1:       (aType == nsIWebBrowserPrint::PRINTPREVIEW_GOTO_PAGENUM && aPageNum == 1)) {
37067:     sf->ScrollTo(nsPoint(0, 0), nsIScrollableFrame::INSTANT);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Finds the SimplePageSequencer frame
    1:   // in PP mPrtPreview->mPrintObject->mSeqFrame is null
    1:   nsIFrame* seqFrame  = nsnull;
    1:   PRInt32   pageCount = 0;
    1:   if (NS_FAILED(mPrintEngine->GetSeqFrameAndCountPages(seqFrame, pageCount))) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Figure where we are currently scrolled to
37067:   nsPoint pt = sf->GetScrollPosition();
    1: 
    1:   PRInt32    pageNum = 1;
    1:   nsIFrame * fndPageFrame  = nsnull;
    1:   nsIFrame * currentPage   = nsnull;
    1: 
    1:   // If it is "End" then just do a "goto" to the last page
    1:   if (aType == nsIWebBrowserPrint::PRINTPREVIEW_END) {
    1:     aType    = nsIWebBrowserPrint::PRINTPREVIEW_GOTO_PAGENUM;
    1:     aPageNum = pageCount;
    1:   }
    1: 
    1:   // Now, locate the current page we are on and
    1:   // and the page of the page number
    1:   nscoord gap = 0;
77154:   nsIFrame* pageFrame = seqFrame->GetFirstPrincipalChild();
    1:   while (pageFrame != nsnull) {
    1:     nsRect pageRect = pageFrame->GetRect();
    1:     if (pageNum == 1) {
    1:       gap = pageRect.y;
    1:     }
37067:     if (pageRect.Contains(pageRect.x, pt.y)) {
    1:       currentPage = pageFrame;
    1:     }
    1:     if (pageNum == aPageNum) {
    1:       fndPageFrame = pageFrame;
    1:       break;
    1:     }
    1:     pageNum++;
    1:     pageFrame = pageFrame->GetNextSibling();
    1:   }
    1: 
    1:   if (aType == nsIWebBrowserPrint::PRINTPREVIEW_PREV_PAGE) {
    1:     if (currentPage) {
    1:       fndPageFrame = currentPage->GetPrevInFlow();
    1:       if (!fndPageFrame) {
    1:         return NS_OK;
    1:       }
    1:     } else {
    1:       return NS_OK;
    1:     }
    1:   } else if (aType == nsIWebBrowserPrint::PRINTPREVIEW_NEXT_PAGE) {
    1:     if (currentPage) {
    1:       fndPageFrame = currentPage->GetNextInFlow();
    1:       if (!fndPageFrame) {
    1:         return NS_OK;
    1:       }
    1:     } else {
    1:       return NS_OK;
    1:     }
    1:   } else { // If we get here we are doing "GoTo"
    1:     if (aPageNum < 0 || aPageNum > pageCount) {
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
37067:   if (fndPageFrame) {
10937:     nscoord newYPosn =
71581:       nscoord(mPrintEngine->GetPrintPreviewScale() * fndPageFrame->GetPosition().y);
37067:     sf->ScrollTo(nsPoint(pt.x, newYPosn), nsIScrollableFrame::INSTANT);
    1:   }
    1:   return NS_OK;
    1: 
    1: }
    1: 
    1: /* readonly attribute nsIPrintSettings globalPrintSettings; */
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::GetGlobalPrintSettings(nsIPrintSettings * *aGlobalPrintSettings)
    1: {
    1:   return nsPrintEngine::GetGlobalPrintSettings(aGlobalPrintSettings);
    1: }
    1: 
    1: /* readonly attribute boolean doingPrint; */
80486: // XXX This always returns false for subdocuments
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::GetDoingPrint(bool *aDoingPrint)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDoingPrint);
    1:   
80486:   *aDoingPrint = false;
    1:   if (mPrintEngine) {
    1:     // XXX shouldn't this be GetDoingPrint() ?
    1:     return mPrintEngine->GetDoingPrintPreview(aDoingPrint);
    1:   } 
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute boolean doingPrintPreview; */
80486: // XXX This always returns false for subdocuments
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::GetDoingPrintPreview(bool *aDoingPrintPreview)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDoingPrintPreview);
    1: 
80486:   *aDoingPrintPreview = false;
    1:   if (mPrintEngine) {
    1:     return mPrintEngine->GetDoingPrintPreview(aDoingPrintPreview);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute nsIPrintSettings currentPrintSettings; */
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::GetCurrentPrintSettings(nsIPrintSettings * *aCurrentPrintSettings)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aCurrentPrintSettings);
    1: 
    1:   *aCurrentPrintSettings = nsnull;
    1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
    1: 
    1:   return mPrintEngine->GetCurrentPrintSettings(aCurrentPrintSettings);
    1: }
    1: 
    1: 
    1: /* readonly attribute nsIDOMWindow currentChildDOMWindow; */
    1: NS_IMETHODIMP 
    1: DocumentViewerImpl::GetCurrentChildDOMWindow(nsIDOMWindow * *aCurrentChildDOMWindow)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aCurrentChildDOMWindow);
    1:   *aCurrentChildDOMWindow = nsnull;
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* void cancel (); */
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::Cancel()
    1: {
    1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
    1:   return mPrintEngine->Cancelled();
    1: }
    1: 
    1: /* void exitPrintPreview (); */
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::ExitPrintPreview()
    1: {
33890:   if (GetIsPrinting())
33890:     return NS_ERROR_FAILURE;
    1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
    1: 
    1:   if (GetIsPrintPreview()) {
    1:     ReturnToGalleyPresentation();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: // Enumerate all the documents for their titles
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::EnumerateDocumentNames(PRUint32* aCount,
    1:                                            PRUnichar*** aResult)
    1: {
    1: #ifdef NS_PRINTING
    1:   NS_ENSURE_ARG(aCount);
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
    1: 
    1:   return mPrintEngine->EnumerateDocumentNames(aCount, aResult);
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
    1: /* readonly attribute boolean isFramesetFrameSelected; */
    1: NS_IMETHODIMP 
79445: DocumentViewerImpl::GetIsFramesetFrameSelected(bool *aIsFramesetFrameSelected)
    1: {
    1: #ifdef NS_PRINTING
80486:   *aIsFramesetFrameSelected = false;
    1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
    1: 
    1:   return mPrintEngine->GetIsFramesetFrameSelected(aIsFramesetFrameSelected);
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
    1: /* readonly attribute long printPreviewNumPages; */
    1: NS_IMETHODIMP
    1: DocumentViewerImpl::GetPrintPreviewNumPages(PRInt32 *aPrintPreviewNumPages)
    1: {
    1: #ifdef NS_PRINTING
    1:   NS_ENSURE_ARG_POINTER(aPrintPreviewNumPages);
    1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
    1: 
    1:   return mPrintEngine->GetPrintPreviewNumPages(aPrintPreviewNumPages);
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
    1: /* readonly attribute boolean isFramesetDocument; */
    1: NS_IMETHODIMP
79445: DocumentViewerImpl::GetIsFramesetDocument(bool *aIsFramesetDocument)
    1: {
    1: #ifdef NS_PRINTING
80486:   *aIsFramesetDocument = false;
    1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
    1: 
    1:   return mPrintEngine->GetIsFramesetDocument(aIsFramesetDocument);
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
    1: /* readonly attribute boolean isIFrameSelected; */
    1: NS_IMETHODIMP 
79445: DocumentViewerImpl::GetIsIFrameSelected(bool *aIsIFrameSelected)
    1: {
    1: #ifdef NS_PRINTING
80486:   *aIsIFrameSelected = false;
    1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
    1: 
    1:   return mPrintEngine->GetIsIFrameSelected(aIsIFrameSelected);
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
    1: /* readonly attribute boolean isRangeSelection; */
    1: NS_IMETHODIMP 
79445: DocumentViewerImpl::GetIsRangeSelection(bool *aIsRangeSelection)
    1: {
    1: #ifdef NS_PRINTING
80486:   *aIsRangeSelection = false;
    1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
    1: 
    1:   return mPrintEngine->GetIsRangeSelection(aIsRangeSelection);
    1: #else
    1:   return NS_ERROR_FAILURE;
    1: #endif
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: // Printing/Print Preview Helpers
    1: //----------------------------------------------------------------------------------
    1: 
    1: //----------------------------------------------------------------------------------
    1: // Walks the document tree and tells each DocShell whether Printing/PP is happening
    1: void 
    1: DocumentViewerImpl::SetIsPrintingInDocShellTree(nsIDocShellTreeNode* aParentNode, 
79445:                                                 bool                 aIsPrintingOrPP, 
79445:                                                 bool                 aStartAtTop)
    1: {
    1:   nsCOMPtr<nsIDocShellTreeItem> parentItem(do_QueryInterface(aParentNode));
    1: 
    1:   // find top of "same parent" tree
    1:   if (aStartAtTop) {
63709:     if (aIsPrintingOrPP) {
    1:       while (parentItem) {
    1:         nsCOMPtr<nsIDocShellTreeItem> parent;
    1:         parentItem->GetSameTypeParent(getter_AddRefs(parent));
    1:         if (!parent) {
    1:           break;
    1:         }
    1:         parentItem = do_QueryInterface(parent);
    1:       }
63709:       mTopContainerWhilePrinting = do_GetWeakReference(parentItem);
63709:     } else {
63709:       parentItem = do_QueryReferent(mTopContainerWhilePrinting);
63709:     }
63709:   }
    1: 
    1:   // Check to see if the DocShell's ContentViewer is printing/PP
    1:   nsCOMPtr<nsIContentViewerContainer> viewerContainer(do_QueryInterface(parentItem));
    1:   if (viewerContainer) {
    1:     viewerContainer->SetIsPrinting(aIsPrintingOrPP);
    1:   }
    1: 
63709:   if (!aParentNode) {
63709:     return;
63709:   }
63709: 
    1:   // Traverse children to see if any of them are printing.
    1:   PRInt32 n;
    1:   aParentNode->GetChildCount(&n);
    1:   for (PRInt32 i=0; i < n; i++) {
    1:     nsCOMPtr<nsIDocShellTreeItem> child;
    1:     aParentNode->GetChildAt(i, getter_AddRefs(child));
    1:     nsCOMPtr<nsIDocShellTreeNode> childAsNode(do_QueryInterface(child));
    1:     NS_ASSERTION(childAsNode, "child isn't nsIDocShellTreeNode");
    1:     if (childAsNode) {
80486:       SetIsPrintingInDocShellTree(childAsNode, aIsPrintingOrPP, false);
    1:     }
    1:   }
    1: 
    1: }
    1: #endif // NS_PRINTING
    1: 
79445: bool
62248: DocumentViewerImpl::ShouldAttachToTopLevel()
62248: {
62248:   if (!mParentWidget)
80486:     return false;
62248: 
62248:   nsCOMPtr<nsIDocShellTreeItem> containerItem = do_QueryReferent(mContainer);
62248:   if (!containerItem)
80486:     return false;
62248: 
62248:   // We always attach when using puppet widgets
62248:   if (nsIWidget::UsePuppetWidgets())
80486:     return true;
62248: 
62248: #ifdef XP_WIN
62248:   // On windows, in the parent process we also attach, but just to
62248:   // chrome items
62248:   PRInt32 docType;
62248:   nsWindowType winType;
62248:   containerItem->GetItemType(&docType);
62248:   mParentWidget->GetWindowType(winType);
62248:   if ((winType == eWindowType_toplevel ||
62248:        winType == eWindowType_dialog ||
62248:        winType == eWindowType_invisible) &&
62248:       docType == nsIDocShellTreeItem::typeChrome)
80486:     return true;
62248: #endif
62248: 
80486:   return false;
62248: }
62248: 
79445: bool CollectDocuments(nsIDocument* aDocument, void* aData)
69880: {
69880:   if (aDocument) {
69880:     static_cast<nsCOMArray<nsIDocument>*>(aData)->AppendObject(aDocument);
69880:     aDocument->EnumerateSubDocuments(CollectDocuments, aData);
69880:   }
80486:   return true;
69880: }
69880: 
69880: void
69880: DocumentViewerImpl::DispatchEventToWindowTree(nsIDocument* aDoc,
69880:                                               const nsAString& aEvent)
69880: {
69880:   nsCOMArray<nsIDocument> targets;
69880:   CollectDocuments(aDoc, &targets);
69880:   for (PRInt32 i = 0; i < targets.Count(); ++i) {
69880:     nsIDocument* d = targets[i];
69880:     nsContentUtils::DispatchTrustedEvent(d, d->GetWindow(),
80486:                                          aEvent, false, false, nsnull);
69880:   }
69880: }
69880: 
    1: //------------------------------------------------------------
80486: // XXX this always returns false for subdocuments
79445: bool
    1: DocumentViewerImpl::GetIsPrinting()
    1: {
    1: #ifdef NS_PRINTING
    1:   if (mPrintEngine) {
    1:     return mPrintEngine->GetIsPrinting();
    1:   }
    1: #endif
80486:   return false; 
    1: }
    1: 
    1: //------------------------------------------------------------
    1: // Notification from the PrintEngine of the current Printing status
    1: void
79445: DocumentViewerImpl::SetIsPrinting(bool aIsPrinting)
    1: {
    1: #ifdef NS_PRINTING
    1:   // Set all the docShells in the docshell tree to be printing.
    1:   // that way if anyone of them tries to "navigate" it can't
    1:   nsCOMPtr<nsIDocShellTreeNode> docShellTreeNode(do_QueryReferent(mContainer));
63709:   if (docShellTreeNode || !aIsPrinting) {
80486:     SetIsPrintingInDocShellTree(docShellTreeNode, aIsPrinting, true);
39324:   } else {
63709:     NS_WARNING("Did you close a window before printing?");
    1:   }
    1: #endif
    1: }
    1: 
    1: //------------------------------------------------------------
    1: // The PrintEngine holds the current value
    1: // this called from inside the DocViewer.
80486: // XXX it always returns false for subdocuments
79445: bool
    1: DocumentViewerImpl::GetIsPrintPreview()
    1: {
    1: #ifdef NS_PRINTING
    1:   if (mPrintEngine) {
    1:     return mPrintEngine->GetIsPrintPreview();
    1:   }
    1: #endif
80486:   return false; 
    1: }
    1: 
    1: //------------------------------------------------------------
    1: // Notification from the PrintEngine of the current PP status
    1: void
79445: DocumentViewerImpl::SetIsPrintPreview(bool aIsPrintPreview)
    1: {
    1: #ifdef NS_PRINTING
    1:   // Set all the docShells in the docshell tree to be printing.
    1:   // that way if anyone of them tries to "navigate" it can't
    1:   nsCOMPtr<nsIDocShellTreeNode> docShellTreeNode(do_QueryReferent(mContainer));
63709:   if (docShellTreeNode || !aIsPrintPreview) {
80486:     SetIsPrintingInDocShellTree(docShellTreeNode, aIsPrintPreview, true);
    1:   }
    1: #endif
35581:   if (!aIsPrintPreview) {
38057:     if (mPresShell) {
38057:       DestroyPresShell();
38057:     }
35581:     mWindow = nsnull;
35581:     mViewManager = nsnull;
35581:     mPresContext = nsnull;
35581:     mPresShell = nsnull;
35581:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: // nsIDocumentViewerPrint IFace
    1: //----------------------------------------------------------------------------------
    1: 
    1: //------------------------------------------------------------
    1: void
    1: DocumentViewerImpl::IncrementDestroyRefCount()
    1: {
    1:   ++mDestroyRefCount;
    1: }
    1: 
    1: //------------------------------------------------------------
    1: 
    1: static void ResetFocusState(nsIDocShell* aDocShell);
    1: 
    1: void
    1: DocumentViewerImpl::ReturnToGalleyPresentation()
    1: {
    1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
    1:   if (!GetIsPrintPreview()) {
    1:     NS_ERROR("Wow, we should never get here!");
    1:     return;
    1:   }
    1: 
80486:   SetIsPrintPreview(false);
80486: 
80486:   mPrintEngine->TurnScriptingOn(true);
    1:   mPrintEngine->Destroy();
    1:   mPrintEngine = nsnull;
    1: 
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
    1:   ResetFocusState(docShell);
    1: 
 7740:   SetTextZoom(mTextZoom);
 7740:   SetFullZoom(mPageZoom);
63383:   SetMinFontSize(mMinFontSize);
    1:   Show();
    1: 
    1: #endif // NS_PRINTING && NS_PRINT_PREVIEW
    1: }
    1: 
    1: //------------------------------------------------------------
    1: // Reset ESM focus for all descendent doc shells.
    1: static void
    1: ResetFocusState(nsIDocShell* aDocShell)
    1: {
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (!fm)
29018:     return;
29018: 
    1:   nsCOMPtr<nsISimpleEnumerator> docShellEnumerator;
    1:   aDocShell->GetDocShellEnumerator(nsIDocShellTreeItem::typeContent,
    1:                                    nsIDocShell::ENUMERATE_FORWARDS,
    1:                                    getter_AddRefs(docShellEnumerator));
    1:   
    1:   nsCOMPtr<nsISupports> currentContainer;
79445:   bool hasMoreDocShells;
    1:   while (NS_SUCCEEDED(docShellEnumerator->HasMoreElements(&hasMoreDocShells))
    1:          && hasMoreDocShells) {
    1:     docShellEnumerator->GetNext(getter_AddRefs(currentContainer));
29018:     nsCOMPtr<nsIDOMWindow> win = do_GetInterface(currentContainer);
29018:     if (win)
29018:       fm->ClearFocus(win);
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------
    1: // This called ONLY when printing has completed and the DV
    1: // is being notified that it should get rid of the PrintEngine.
    1: //
    1: // BUT, if we are in Print Preview then we want to ignore the 
    1: // notification (we do not get rid of the PrintEngine)
    1: // 
    1: // One small caveat: 
    1: //   This IS called from two places in this module for cleaning
    1: //   up when an error occurred during the start up printing 
    1: //   and print preview
    1: //
    1: void
    1: DocumentViewerImpl::OnDonePrinting() 
    1: {
    1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
    1:   if (mPrintEngine) {
    1:     if (GetIsPrintPreview()) {
    1:       mPrintEngine->DestroyPrintingData();
    1:     } else {
    1:       mPrintEngine->Destroy();
    1:       mPrintEngine = nsnull;
    1:     }
    1: 
    1:     // We are done printing, now cleanup 
    1:     if (mDeferredWindowClose) {
80486:       mDeferredWindowClose = false;
    1:       nsCOMPtr<nsISupports> container = do_QueryReferent(mContainer);
73870:       nsCOMPtr<nsIDOMWindow> win = do_GetInterface(container);
    1:       if (win)
    1:         win->Close();
    1:     } else if (mClosingWhilePrinting) {
    1:       if (mDocument) {
    1:         mDocument->SetScriptGlobalObject(nsnull);
    1:         mDocument->Destroy();
    1:         mDocument = nsnull;
    1:       }
80486:       mClosingWhilePrinting = false;
    1:     }
    1:   }
    1: #endif // NS_PRINTING && NS_PRINT_PREVIEW
    1: }
    1: 
79445: NS_IMETHODIMP DocumentViewerImpl::SetPageMode(bool aPageMode, nsIPrintSettings* aPrintSettings)
    1: {
    1:   // XXX Page mode is only partially working; it's currently used for
    1:   // reftests that require a paginated context
    1:   mIsPageMode = aPageMode;
    1: 
    1:   if (mPresShell) {
23902:     DestroyPresShell();
    1:   }
    1: 
    1:   if (mPresContext) {
61100:     DestroyPresContext();
61100:   }
61100: 
    1:   mViewManager  = nsnull;
    1:   mWindow       = nsnull;
    1: 
    1:   NS_ENSURE_STATE(mDocument);
    1:   if (aPageMode)
    1:   {    
30514:     mPresContext = CreatePresContext(mDocument,
30514:         nsPresContext::eContext_PageLayout, FindContainerView());
    1:     NS_ENSURE_TRUE(mPresContext, NS_ERROR_OUT_OF_MEMORY);
80486:     mPresContext->SetPaginatedScrolling(true);
    1:     mPresContext->SetPrintSettings(aPrintSettings);
    1:     nsresult rv = mPresContext->Init(mDeviceContext);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
80486:   InitInternal(mParentWidget, nsnull, mBounds, true, false);
    1: 
    1:   Show();
    1:   return NS_OK;
    1: }
 6685: 
 6685: NS_IMETHODIMP
 6685: DocumentViewerImpl::GetHistoryEntry(nsISHEntry **aHistoryEntry)
 6685: {
 6685:   NS_IF_ADDREF(*aHistoryEntry = mSHEntry);
 6685:   return NS_OK;
 6685: }
23902: 
62631: NS_IMETHODIMP
79445: DocumentViewerImpl::GetIsTabModalPromptAllowed(bool *aAllowed)
62631: {
62631:   *aAllowed = !(mInPermitUnload || mHidden);
62631:   return NS_OK;
62631: }
62631: 
23902: void
23902: DocumentViewerImpl::DestroyPresShell()
23902: {
23902:   // Break circular reference (or something)
23902:   mPresShell->EndObservingDocument();
23902: 
23902:   nsCOMPtr<nsISelection> selection;
23902:   GetDocumentSelection(getter_AddRefs(selection));
23902:   nsCOMPtr<nsISelectionPrivate> selPrivate = do_QueryInterface(selection);
23902:   if (selPrivate && mSelectionListener)
23902:     selPrivate->RemoveSelectionListener(mSelectionListener);
23902: 
28371:   nsAutoScriptBlocker scriptBlocker;
23902:   mPresShell->Destroy();
23902:   mPresShell = nsnull;
23902: }
35581: 
61100: void
61100: DocumentViewerImpl::DestroyPresContext()
61100: {
61100:   mPresContext->SetContainer(nsnull);
61100:   mPresContext->SetLinkHandler(nsnull);
61100:   mPresContext = nsnull;
61100: }
61100: 
79445: bool
35581: DocumentViewerImpl::IsInitializedForPrintPreview()
35581: {
35581:   return mInitializedForPrintPreview;
35581: }
35581: 
35581: void
35581: DocumentViewerImpl::InitializeForPrintPreview()
35581: {
80486:   mInitializedForPrintPreview = true;
35581: }
35581: 
35581: void
51637: DocumentViewerImpl::SetPrintPreviewPresentation(nsIViewManager* aViewManager,
35581:                                                 nsPresContext* aPresContext,
35581:                                                 nsIPresShell* aPresShell)
35581: {
35581:   if (mPresShell) {
35581:     DestroyPresShell();
35581:   }
35581: 
51637:   mWindow = nsnull;
35581:   mViewManager = aViewManager;
35581:   mPresContext = aPresContext;
35581:   mPresShell = aPresShell;
35581: }
