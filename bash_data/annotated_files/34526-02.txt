    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   David Hyatt <hyatt@netscape.com> (Original Author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsXBLContentSink.h"
    1: #include "nsIDocument.h"
    1: #include "nsBindingManager.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIParser.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsHTMLTokens.h"
    1: #include "nsIURI.h"
    1: #include "nsTextFragment.h"
    1: #ifdef MOZ_XUL
    1: #include "nsXULElement.h"
    1: #endif
    1: #include "nsXBLProtoImplProperty.h"
    1: #include "nsXBLProtoImplMethod.h"
    1: #include "nsXBLProtoImplField.h"
    1: #include "nsXBLPrototypeBinding.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIConsoleService.h"
    1: #include "nsIScriptError.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIPrincipal.h"
    1: 
    1: nsresult
    1: NS_NewXBLContentSink(nsIXMLContentSink** aResult,
    1:                      nsIDocument* aDoc,
    1:                      nsIURI* aURI,
    1:                      nsISupports* aContainer)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1: 
    1:   nsXBLContentSink* it;
    1:   NS_NEWXPCOM(it, nsXBLContentSink);
    1:   NS_ENSURE_TRUE(it, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsCOMPtr<nsIXMLContentSink> kungFuDeathGrip = it;
    1:   nsresult rv = it->Init(aDoc, aURI, aContainer);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return CallQueryInterface(it, aResult);
    1: }
    1: 
    1: nsXBLContentSink::nsXBLContentSink()
    1:   : mState(eXBL_InDocument),
    1:     mSecondaryState(eXBL_None),
    1:     mDocInfo(nsnull),
 6392:     mIsChromeOrResource(PR_FALSE),
 6330:     mFoundFirstBinding(PR_FALSE),    
    1:     mBinding(nsnull),
    1:     mHandler(nsnull),
    1:     mImplementation(nsnull),
    1:     mImplMember(nsnull),
 6392:     mImplField(nsnull),
    1:     mProperty(nsnull),
    1:     mMethod(nsnull),
    1:     mField(nsnull)
    1: {
    1:   mPrettyPrintXML = PR_FALSE;
    1: }
    1: 
    1: nsXBLContentSink::~nsXBLContentSink()
    1: {
    1: }
    1: 
    1: nsresult
    1: nsXBLContentSink::Init(nsIDocument* aDoc,
    1:                        nsIURI* aURI,
    1:                        nsISupports* aContainer)
    1: {
    1:   nsresult rv;
    1:   rv = nsXMLContentSink::Init(aDoc, aURI, aContainer, nsnull);
    1:   return rv;
    1: }
    1: 
    1: void
  681: nsXBLContentSink::MaybeStartLayout(PRBool aIgnorePendingSheets)
    1: {
    1:   return;
    1: }
    1: 
    1: nsresult
20517: nsXBLContentSink::FlushText(PRBool aReleaseTextNode)
    1: {
20517:   if (mTextLength != 0) {
    1:     const nsASingleFragmentString& text = Substring(mText, mText+mTextLength);
    1:     if (mState == eXBL_InHandlers) {
    1:       NS_ASSERTION(mBinding, "Must have binding here");
    1:       // Get the text and add it to the event handler.
    1:       if (mSecondaryState == eXBL_InHandler)
    1:         mHandler->AppendHandlerText(text);
    1:       mTextLength = 0;
    1:       return NS_OK;
    1:     }
    1:     else if (mState == eXBL_InImplementation) {
    1:       NS_ASSERTION(mBinding, "Must have binding here");
    1:       if (mSecondaryState == eXBL_InConstructor ||
    1:           mSecondaryState == eXBL_InDestructor) {
    1:         // Construct a method for the constructor/destructor.
    1:         nsXBLProtoImplMethod* method;
    1:         if (mSecondaryState == eXBL_InConstructor)
    1:           method = mBinding->GetConstructor();
    1:         else
    1:           method = mBinding->GetDestructor();
    1: 
    1:         // Get the text and add it to the constructor/destructor.
    1:         method->AppendBodyText(text);
    1:       }
    1:       else if (mSecondaryState == eXBL_InGetter ||
    1:                mSecondaryState == eXBL_InSetter) {
    1:         // Get the text and add it to the getter/setter
    1:         if (mSecondaryState == eXBL_InGetter)
    1:           mProperty->AppendGetterText(text);
    1:         else
    1:           mProperty->AppendSetterText(text);
    1:       }
    1:       else if (mSecondaryState == eXBL_InBody) {
    1:         // Get the text and add it to the method
    1:         if (mMethod)
    1:           mMethod->AppendBodyText(text);
    1:       }
    1:       else if (mSecondaryState == eXBL_InField) {
    1:         // Get the text and add it to the method
20670:         if (mField)
    1:           mField->AppendFieldText(text);
    1:       }
    1:       mTextLength = 0;
    1:       return NS_OK;
    1:     }
    1: 
    1:     nsIContent* content = GetCurrentContent();
    1:     if (content &&
    1:         (content->NodeInfo()->NamespaceEquals(kNameSpaceID_XBL) ||
    1:          (content->NodeInfo()->NamespaceEquals(kNameSpaceID_XUL) &&
    1:           content->Tag() != nsGkAtoms::label &&
    1:           content->Tag() != nsGkAtoms::description))) {
    1: 
    1:       PRBool isWS = PR_TRUE;
    1:       if (mTextLength > 0) {
    1:         const PRUnichar* cp = mText;
    1:         const PRUnichar* end = mText + mTextLength;
    1:         while (cp < end) {
    1:           PRUnichar ch = *cp++;
    1:           if (!XP_IS_SPACE(ch)) {
    1:             isWS = PR_FALSE;
    1:             break;
    1:           }
    1:         }
    1:       }
    1: 
    1:       if (isWS && mTextLength > 0) {
    1:         mTextLength = 0;
20517:         // Make sure to drop the textnode, if any
20517:         return nsXMLContentSink::FlushText(aReleaseTextNode);
20517:       }
    1:     }
    1:   }
    1: 
20517:   return nsXMLContentSink::FlushText(aReleaseTextNode);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXBLContentSink::ReportError(const PRUnichar* aErrorText, 
    1:                               const PRUnichar* aSourceText,
    1:                               nsIScriptError *aError,
    1:                               PRBool *_retval)
    1: {
    1:   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
    1: 
    1:   // XXX FIXME This function overrides and calls on
    1:   // nsXMLContentSink::ReportError, and probably should die.  See bug 347826.
    1: 
    1:   // XXX We should make sure the binding has no effect, but that it also
    1:   // gets destroyed properly without leaking.  Perhaps we should even
    1:   // ensure that the content that was bound is displayed with no
    1:   // binding.
    1: 
    1: #ifdef DEBUG
    1:   // Report the error to stderr.
    1:   fprintf(stderr,
    1:           "\n%s\n%s\n\n",
    1:           NS_LossyConvertUTF16toASCII(aErrorText).get(),
    1:           NS_LossyConvertUTF16toASCII(aSourceText).get());
    1: #endif
    1: 
    1:   // Most of what this does won't be too useful, but whatever...
    1:   // nsXMLContentSink::ReportError will handle the console logging.
    1:   return nsXMLContentSink::ReportError(aErrorText, 
    1:                                        aSourceText, 
    1:                                        aError,
    1:                                        _retval);
    1: }
    1: 
    1: nsresult
    1: nsXBLContentSink::ReportUnexpectedElement(nsIAtom* aElementName,
    1:                                           PRUint32 aLineNumber)
    1: {
    1:   // XXX we should really somehow stop the parse and drop the binding
    1:   // instead of just letting the XML sink build the content model like
    1:   // we do...
    1:   mState = eXBL_Error;
    1:   nsAutoString elementName;
    1:   aElementName->ToString(elementName);
    1: 
    1:   const PRUnichar* params[] = { elementName.get() };
    1: 
    1:   return nsContentUtils::ReportToConsole(nsContentUtils::eXBL_PROPERTIES,
    1:                                          "UnexpectedElement",
    1:                                          params, NS_ARRAY_LENGTH(params),
    1:                                          mDocumentURI,
    1:                                          EmptyString() /* source line */,
    1:                                          aLineNumber, 0 /* column number */,
    1:                                          nsIScriptError::errorFlag,
    1:                                          "XBL Content Sink");
    1: }
    1: 
    1: void
    1: nsXBLContentSink::AddMember(nsXBLProtoImplMember* aMember)
    1: {
    1:   // Add this member to our chain.
    1:   if (mImplMember)
    1:     mImplMember->SetNext(aMember); // Already have a chain. Just append to the end.
    1:   else
    1:     mImplementation->SetMemberList(aMember); // We're the first member in the chain.
    1: 
    1:   mImplMember = aMember; // Adjust our pointer to point to the new last member in the chain.
    1: }
    1: 
 6392: void
 6392: nsXBLContentSink::AddField(nsXBLProtoImplField* aField)
 6392: {
 6392:   // Add this field to our chain.
 6392:   if (mImplField)
 6392:     mImplField->SetNext(aField); // Already have a chain. Just append to the end.
 6392:   else
 6392:     mImplementation->SetFieldList(aField); // We're the first member in the chain.
 6392: 
 6392:   mImplField = aField; // Adjust our pointer to point to the new last field in the chain.
 6392: }
 6392: 
    1: NS_IMETHODIMP 
    1: nsXBLContentSink::HandleStartElement(const PRUnichar *aName, 
    1:                                      const PRUnichar **aAtts, 
    1:                                      PRUint32 aAttsCount, 
    1:                                      PRInt32 aIndex, 
    1:                                      PRUint32 aLineNumber)
    1: {
    1:   nsresult rv = nsXMLContentSink::HandleStartElement(aName,aAtts,aAttsCount,aIndex,aLineNumber);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   if (mState == eXBL_InBinding && !mBinding) {
    1:     rv = ConstructBinding();
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     
    1:     // mBinding may still be null, if the binding had no id.  If so,
    1:     // we'll deal with that later in the sink.
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsXBLContentSink::HandleEndElement(const PRUnichar *aName)
    1: {
    1:   FlushText();
    1: 
    1:   if (mState != eXBL_InDocument) {
    1:     PRInt32 nameSpaceID;
    1:     nsCOMPtr<nsIAtom> prefix, localName;
    1:     nsContentUtils::SplitExpatName(aName, getter_AddRefs(prefix),
    1:                                    getter_AddRefs(localName), &nameSpaceID);
    1: 
    1:     if (nameSpaceID == kNameSpaceID_XBL) {
    1:       if (mState == eXBL_Error) {
    1:         // Check whether we've opened this tag before; we may not have if
    1:         // it was a real XBL tag before the error occured.
    1:         if (!GetCurrentContent()->NodeInfo()->Equals(localName,
    1:                                                      nameSpaceID)) {
    1:           // OK, this tag was never opened as far as the XML sink is
    1:           // concerned.  Just drop the HandleEndElement
    1:           return NS_OK;
    1:         }
    1:       }
    1:       else if (mState == eXBL_InHandlers) {
    1:         if (localName == nsGkAtoms::handlers) {
    1:           mState = eXBL_InBinding;
    1:           mHandler = nsnull;
    1:         }
    1:         else if (localName == nsGkAtoms::handler)
    1:           mSecondaryState = eXBL_None;
    1:         return NS_OK;
    1:       }
    1:       else if (mState == eXBL_InResources) {
    1:         if (localName == nsGkAtoms::resources)
    1:           mState = eXBL_InBinding;
    1:         return NS_OK;
    1:       }
    1:       else if (mState == eXBL_InImplementation) {
    1:         if (localName == nsGkAtoms::implementation)
    1:           mState = eXBL_InBinding;
    1:         else if (localName == nsGkAtoms::property) {
    1:           mSecondaryState = eXBL_None;
    1:           mProperty = nsnull;
    1:         }
    1:         else if (localName == nsGkAtoms::method) {
    1:           mSecondaryState = eXBL_None;
    1:           mMethod = nsnull;
    1:         }
    1:         else if (localName == nsGkAtoms::field) {
    1:           mSecondaryState = eXBL_None;
    1:           mField = nsnull;
    1:         }
    1:         else if (localName == nsGkAtoms::constructor ||
    1:                  localName == nsGkAtoms::destructor)
    1:           mSecondaryState = eXBL_None;
    1:         else if (localName == nsGkAtoms::getter ||
    1:                  localName == nsGkAtoms::setter)
    1:           mSecondaryState = eXBL_InProperty;
    1:         else if (localName == nsGkAtoms::parameter ||
    1:                  localName == nsGkAtoms::body)
    1:           mSecondaryState = eXBL_InMethod;
    1:         return NS_OK;
    1:       }
    1:       else if (mState == eXBL_InBindings &&
    1:                localName == nsGkAtoms::bindings) {
    1:         mState = eXBL_InDocument;
    1:       }
    1:       
    1:       nsresult rv = nsXMLContentSink::HandleEndElement(aName);
    1:       if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:       if (mState == eXBL_InBinding && localName == nsGkAtoms::binding) {
    1:         mState = eXBL_InBindings;
    1:         if (mBinding) {  // See comment in HandleStartElement()
    1:           mBinding->Initialize();
    1:           mBinding = nsnull; // Clear our current binding ref.
    1:         }
    1:       }
    1: 
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return nsXMLContentSink::HandleEndElement(aName);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsXBLContentSink::HandleCDataSection(const PRUnichar *aData, 
    1:                                      PRUint32 aLength)
    1: {
    1:   if (mState == eXBL_InHandlers || mState == eXBL_InImplementation)
    1:     return AddText(aData, aLength);
    1:   return nsXMLContentSink::HandleCDataSection(aData, aLength);
    1: }
    1: 
    1: #define ENSURE_XBL_STATE(_cond)                                                       \
    1:   PR_BEGIN_MACRO                                                                      \
    1:     if (!(_cond)) { ReportUnexpectedElement(aTagName, aLineNumber); return PR_TRUE; } \
    1:   PR_END_MACRO
    1: 
    1: PRBool 
    1: nsXBLContentSink::OnOpenContainer(const PRUnichar **aAtts, 
    1:                                   PRUint32 aAttsCount, 
    1:                                   PRInt32 aNameSpaceID, 
    1:                                   nsIAtom* aTagName,
    1:                                   PRUint32 aLineNumber)
    1: {
    1:   if (mState == eXBL_Error) {
    1:     return PR_TRUE;
    1:   }
    1:   
    1:   if (aNameSpaceID != kNameSpaceID_XBL) {
    1:     // Construct non-XBL nodes
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   PRBool ret = PR_TRUE;
    1:   if (aTagName == nsGkAtoms::bindings) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InDocument);
    1:       
    1:     NS_NewXBLDocumentInfo(mDocument, &mDocInfo);
    1:     if (!mDocInfo) {
    1:       mState = eXBL_Error;
    1:       return PR_TRUE;
    1:     }
    1: 
    1:     mDocument->BindingManager()->PutXBLDocumentInfo(mDocInfo);
    1: 
    1:     nsIURI *uri = mDocument->GetDocumentURI();
    1:       
    1:     PRBool isChrome = PR_FALSE;
    1:     PRBool isRes = PR_FALSE;
    1: 
    1:     uri->SchemeIs("chrome", &isChrome);
    1:     uri->SchemeIs("resource", &isRes);
    1:     mIsChromeOrResource = isChrome || isRes;
    1:       
    1:     nsIXBLDocumentInfo* info = mDocInfo;
    1:     NS_RELEASE(info); // We keep a weak ref. We've created a cycle between doc/binding manager/doc info.
    1:     mState = eXBL_InBindings;
    1:   }
    1:   else if (aTagName == nsGkAtoms::binding) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InBindings);
    1:     mState = eXBL_InBinding;
    1:   }
    1:   else if (aTagName == nsGkAtoms::handlers) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InBinding && mBinding);
    1:     mState = eXBL_InHandlers;
    1:     ret = PR_FALSE;
    1:   }
    1:   else if (aTagName == nsGkAtoms::handler) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InHandlers);
    1:     mSecondaryState = eXBL_InHandler;
    1:     ConstructHandler(aAtts, aLineNumber);
    1:     ret = PR_FALSE;
    1:   }
    1:   else if (aTagName == nsGkAtoms::resources) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InBinding && mBinding);
    1:     mState = eXBL_InResources;
    1:     // Note that this mState will cause us to return false, so no need
    1:     // to set ret to false.
    1:   }
    1:   else if (aTagName == nsGkAtoms::stylesheet || aTagName == nsGkAtoms::image) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InResources);
    1:     NS_ASSERTION(mBinding, "Must have binding here");
    1:     ConstructResource(aAtts, aTagName);
    1:   }
    1:   else if (aTagName == nsGkAtoms::implementation) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InBinding && mBinding);
    1:     mState = eXBL_InImplementation;
    1:     ConstructImplementation(aAtts);
    1:     // Note that this mState will cause us to return false, so no need
    1:     // to set ret to false.
    1:   }
    1:   else if (aTagName == nsGkAtoms::constructor) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InImplementation &&
    1:                      mSecondaryState == eXBL_None);
    1:     NS_ASSERTION(mBinding, "Must have binding here");
    1:       
    1:     mSecondaryState = eXBL_InConstructor;
    1:     nsXBLProtoImplAnonymousMethod* newMethod =
    1:       new nsXBLProtoImplAnonymousMethod();
    1:     if (newMethod) {
    1:       newMethod->SetLineNumber(aLineNumber);
    1:       mBinding->SetConstructor(newMethod);
    1:       AddMember(newMethod);
    1:     }
    1:   }
    1:   else if (aTagName == nsGkAtoms::destructor) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InImplementation &&
    1:                      mSecondaryState == eXBL_None);
    1:     NS_ASSERTION(mBinding, "Must have binding here");
    1:     mSecondaryState = eXBL_InDestructor;
    1:     nsXBLProtoImplAnonymousMethod* newMethod =
    1:       new nsXBLProtoImplAnonymousMethod();
    1:     if (newMethod) {
    1:       newMethod->SetLineNumber(aLineNumber);
    1:       mBinding->SetDestructor(newMethod);
    1:       AddMember(newMethod);
    1:     }
    1:   }
    1:   else if (aTagName == nsGkAtoms::field) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InImplementation &&
    1:                      mSecondaryState == eXBL_None);
    1:     NS_ASSERTION(mBinding, "Must have binding here");
    1:     mSecondaryState = eXBL_InField;
    1:     ConstructField(aAtts, aLineNumber);
    1:   }
    1:   else if (aTagName == nsGkAtoms::property) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InImplementation &&
    1:                      mSecondaryState == eXBL_None);
    1:     NS_ASSERTION(mBinding, "Must have binding here");
    1:     mSecondaryState = eXBL_InProperty;
    1:     ConstructProperty(aAtts);
    1:   }
    1:   else if (aTagName == nsGkAtoms::getter) {
    1:     ENSURE_XBL_STATE(mSecondaryState == eXBL_InProperty && mProperty);
    1:     NS_ASSERTION(mState == eXBL_InImplementation, "Unexpected state");
    1:     mProperty->SetGetterLineNumber(aLineNumber);
    1:     mSecondaryState = eXBL_InGetter;
    1:   }
    1:   else if (aTagName == nsGkAtoms::setter) {
    1:     ENSURE_XBL_STATE(mSecondaryState == eXBL_InProperty && mProperty);
    1:     NS_ASSERTION(mState == eXBL_InImplementation, "Unexpected state");
    1:     mProperty->SetSetterLineNumber(aLineNumber);
    1:     mSecondaryState = eXBL_InSetter;
    1:   }
    1:   else if (aTagName == nsGkAtoms::method) {
    1:     ENSURE_XBL_STATE(mState == eXBL_InImplementation &&
    1:                      mSecondaryState == eXBL_None);
    1:     NS_ASSERTION(mBinding, "Must have binding here");
    1:     mSecondaryState = eXBL_InMethod;
    1:     ConstructMethod(aAtts);
    1:   }
    1:   else if (aTagName == nsGkAtoms::parameter) {
    1:     ENSURE_XBL_STATE(mSecondaryState == eXBL_InMethod && mMethod);
    1:     NS_ASSERTION(mState == eXBL_InImplementation, "Unexpected state");
    1:     ConstructParameter(aAtts);
    1:   }
    1:   else if (aTagName == nsGkAtoms::body) {
    1:     ENSURE_XBL_STATE(mSecondaryState == eXBL_InMethod && mMethod);
    1:     NS_ASSERTION(mState == eXBL_InImplementation, "Unexpected state");
    1:     // stash away the line number
    1:     mMethod->SetLineNumber(aLineNumber);
    1:     mSecondaryState = eXBL_InBody;
    1:   }
    1: 
    1:   return ret && mState != eXBL_InResources && mState != eXBL_InImplementation;
    1: }
    1: 
    1: #undef ENSURE_XBL_STATE
    1: 
    1: nsresult
    1: nsXBLContentSink::ConstructBinding()
    1: {
    1:   nsCOMPtr<nsIContent> binding = GetCurrentContent();
    1:   nsAutoString id;
    1:   binding->GetAttr(kNameSpaceID_None, nsGkAtoms::id, id);
    1:   NS_ConvertUTF16toUTF8 cid(id);
    1: 
    1:   nsresult rv = NS_OK;
    1:   
    1:   if (!cid.IsEmpty()) {
    1:     mBinding = new nsXBLPrototypeBinding();
    1:     if (!mBinding)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:       
34526:     rv = mBinding->Init(cid, mDocInfo, binding, !mFoundFirstBinding);
 8377:     if (NS_SUCCEEDED(rv) &&
 8377:         NS_SUCCEEDED(mDocInfo->SetPrototypeBinding(cid, mBinding))) {
    1:       if (!mFoundFirstBinding) {
    1:         mFoundFirstBinding = PR_TRUE;
    1:         mDocInfo->SetFirstPrototypeBinding(mBinding);
    1:       }
    1:       binding->UnsetAttr(kNameSpaceID_None, nsGkAtoms::id, PR_FALSE);
    1:     } else {
    1:       delete mBinding;
    1:       mBinding = nsnull;
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: static PRBool
    1: FindValue(const PRUnichar **aAtts, nsIAtom *aAtom, const PRUnichar **aResult)
    1: {
    1:   nsCOMPtr<nsIAtom> prefix, localName;
    1:   for (; *aAtts; aAtts += 2) {
    1:     PRInt32 nameSpaceID;
    1:     nsContentUtils::SplitExpatName(aAtts[0], getter_AddRefs(prefix),
    1:                                    getter_AddRefs(localName), &nameSpaceID);
    1: 
    1:     // Is this attribute one of the ones we care about?
    1:     if (nameSpaceID == kNameSpaceID_None && localName == aAtom) {
    1:       *aResult = aAtts[1];
    1: 
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
    1: nsXBLContentSink::ConstructHandler(const PRUnichar **aAtts, PRUint32 aLineNumber)
    1: {
    1:   const PRUnichar* event          = nsnull;
    1:   const PRUnichar* modifiers      = nsnull;
    1:   const PRUnichar* button         = nsnull;
    1:   const PRUnichar* clickcount     = nsnull;
    1:   const PRUnichar* keycode        = nsnull;
    1:   const PRUnichar* charcode       = nsnull;
    1:   const PRUnichar* phase          = nsnull;
    1:   const PRUnichar* command        = nsnull;
    1:   const PRUnichar* action         = nsnull;
    1:   const PRUnichar* group          = nsnull;
    1:   const PRUnichar* preventdefault = nsnull;
    1:   const PRUnichar* allowuntrusted = nsnull;
    1: 
    1:   nsCOMPtr<nsIAtom> prefix, localName;
    1:   for (; *aAtts; aAtts += 2) {
    1:     PRInt32 nameSpaceID;
    1:     nsContentUtils::SplitExpatName(aAtts[0], getter_AddRefs(prefix),
    1:                                    getter_AddRefs(localName), &nameSpaceID);
    1: 
    1:     if (nameSpaceID != kNameSpaceID_None) {
    1:       continue;
    1:     }
    1: 
    1:     // Is this attribute one of the ones we care about?
    1:     if (localName == nsGkAtoms::event)
    1:       event = aAtts[1];
    1:     else if (localName == nsGkAtoms::modifiers)
    1:       modifiers = aAtts[1];
    1:     else if (localName == nsGkAtoms::button)
    1:       button = aAtts[1];
    1:     else if (localName == nsGkAtoms::clickcount)
    1:       clickcount = aAtts[1];
    1:     else if (localName == nsGkAtoms::keycode)
    1:       keycode = aAtts[1];
    1:     else if (localName == nsGkAtoms::key || localName == nsGkAtoms::charcode)
    1:       charcode = aAtts[1];
    1:     else if (localName == nsGkAtoms::phase)
    1:       phase = aAtts[1];
    1:     else if (localName == nsGkAtoms::command)
    1:       command = aAtts[1];
    1:     else if (localName == nsGkAtoms::action)
    1:       action = aAtts[1];
    1:     else if (localName == nsGkAtoms::group)
    1:       group = aAtts[1];
    1:     else if (localName == nsGkAtoms::preventdefault)
    1:       preventdefault = aAtts[1];
    1:     else if (localName == nsGkAtoms::allowuntrusted)
    1:       allowuntrusted = aAtts[1];
    1:   }
    1: 
    1:   if (command && !mIsChromeOrResource) {
    1:     // Make sure the XBL doc is chrome or resource if we have a command
    1:     // shorthand syntax.
    1:     mState = eXBL_Error;
    1:     nsContentUtils::ReportToConsole(nsContentUtils::eXBL_PROPERTIES,
    1:                                     "CommandNotInChrome", nsnull, 0,
    1:                                     mDocumentURI,
    1:                                     EmptyString() /* source line */,
    1:                                     aLineNumber, 0 /* column number */,
    1:                                     nsIScriptError::errorFlag,
    1:                                     "XBL Content Sink");
    1:     return; // Don't even make this handler.
    1:   }
    1: 
    1:   // All of our pointers are now filled in. Construct our handler with all of
    1:   // these parameters.
    1:   nsXBLPrototypeHandler* newHandler;
    1:   newHandler = new nsXBLPrototypeHandler(event, phase, action, command,
    1:                                          keycode, charcode, modifiers, button,
    1:                                          clickcount, group, preventdefault,
 8752:                                          allowuntrusted, mBinding, aLineNumber);
    1: 
    1:   if (newHandler) {
    1:     // Add this handler to our chain of handlers.
    1:     if (mHandler) {
    1:       // Already have a chain. Just append to the end.
    1:       mHandler->SetNextHandler(newHandler);
    1:     }
    1:     else {
    1:       // We're the first handler in the chain.
    1:       mBinding->SetPrototypeHandlers(newHandler);
    1:     }
    1:     // Adjust our mHandler pointer to point to the new last handler in the
    1:     // chain.
    1:     mHandler = newHandler;
    1:   } else {
    1:     mState = eXBL_Error;
    1:   }
    1: }
    1: 
    1: void
    1: nsXBLContentSink::ConstructResource(const PRUnichar **aAtts,
    1:                                     nsIAtom* aResourceType)
    1: {
    1:   if (!mBinding)
    1:     return;
    1: 
    1:   const PRUnichar* src = nsnull;
    1:   if (FindValue(aAtts, nsGkAtoms::src, &src)) {
    1:     mBinding->AddResource(aResourceType, nsDependentString(src));
    1:   }
    1: }
    1: 
    1: void
    1: nsXBLContentSink::ConstructImplementation(const PRUnichar **aAtts)
    1: {
    1:   mImplementation = nsnull;
    1:   mImplMember = nsnull;
 6392:   mImplField = nsnull;
    1:   
    1:   if (!mBinding)
    1:     return;
    1: 
    1:   const PRUnichar* name = nsnull;
    1: 
    1:   nsCOMPtr<nsIAtom> prefix, localName;
    1:   for (; *aAtts; aAtts += 2) {
    1:     PRInt32 nameSpaceID;
    1:     nsContentUtils::SplitExpatName(aAtts[0], getter_AddRefs(prefix),
    1:                                    getter_AddRefs(localName), &nameSpaceID);
    1: 
    1:     if (nameSpaceID != kNameSpaceID_None) {
    1:       continue;
    1:     }
    1: 
    1:     // Is this attribute one of the ones we care about?
    1:     if (localName == nsGkAtoms::name) {
    1:       name = aAtts[1];
    1:     }
    1:     else if (localName == nsGkAtoms::implements) {
    1:       // Only allow implementation of interfaces via XBL if the principal of
    1:       // our XBL document has UniversalXPConnect privileges.  No principal
    1:       // means no privs!
    1:       
    1:       // XXX this api is so badly tied to JS it's not even funny.  We don't
    1:       // have a concept of enabling capabilities on a per-principal basis,
    1:       // but only on a per-principal-and-JS-stackframe basis!  So for now
    1:       // this is basically equivalent to testing that we have the system
    1:       // principal, since there is no JS stackframe in sight here...
    1:       PRBool hasUniversalXPConnect;
    1:       nsresult rv = mDocument->NodePrincipal()->
    1:         IsCapabilityEnabled("UniversalXPConnect", nsnull,
    1:                             &hasUniversalXPConnect);
    1:       if (NS_SUCCEEDED(rv) && hasUniversalXPConnect) {
    1:         mBinding->ConstructInterfaceTable(nsDependentString(aAtts[1]));
    1:       }
    1:     }
    1:   }
    1: 
    1:   NS_NewXBLProtoImpl(mBinding, name, &mImplementation);
    1: }
    1: 
    1: void
    1: nsXBLContentSink::ConstructField(const PRUnichar **aAtts, PRUint32 aLineNumber)
    1: {
    1:   const PRUnichar* name     = nsnull;
    1:   const PRUnichar* readonly = nsnull;
    1: 
    1:   nsCOMPtr<nsIAtom> prefix, localName;
    1:   for (; *aAtts; aAtts += 2) {
    1:     PRInt32 nameSpaceID;
    1:     nsContentUtils::SplitExpatName(aAtts[0], getter_AddRefs(prefix),
    1:                                    getter_AddRefs(localName), &nameSpaceID);
    1: 
    1:     if (nameSpaceID != kNameSpaceID_None) {
    1:       continue;
    1:     }
    1: 
    1:     // Is this attribute one of the ones we care about?
    1:     if (localName == nsGkAtoms::name) {
    1:       name = aAtts[1];
    1:     }
    1:     else if (localName == nsGkAtoms::readonly) {
    1:       readonly = aAtts[1];
    1:     }
    1:   }
    1: 
    1:   if (name) {
    1:     // All of our pointers are now filled in. Construct our field with all of
    1:     // these parameters.
    1:     mField = new nsXBLProtoImplField(name, readonly);
    1:     if (mField) {
    1:       mField->SetLineNumber(aLineNumber);
 6392:       AddField(mField);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsXBLContentSink::ConstructProperty(const PRUnichar **aAtts)
    1: {
    1:   const PRUnichar* name     = nsnull;
    1:   const PRUnichar* readonly = nsnull;
    1:   const PRUnichar* onget    = nsnull;
    1:   const PRUnichar* onset    = nsnull;
    1: 
    1:   nsCOMPtr<nsIAtom> prefix, localName;
    1:   for (; *aAtts; aAtts += 2) {
    1:     PRInt32 nameSpaceID;
    1:     nsContentUtils::SplitExpatName(aAtts[0], getter_AddRefs(prefix),
    1:                                    getter_AddRefs(localName), &nameSpaceID);
    1: 
    1:     if (nameSpaceID != kNameSpaceID_None) {
    1:       continue;
    1:     }
    1: 
    1:     // Is this attribute one of the ones we care about?
    1:     if (localName == nsGkAtoms::name) {
    1:       name = aAtts[1];
    1:     }
    1:     else if (localName == nsGkAtoms::readonly) {
    1:       readonly = aAtts[1];
    1:     }
    1:     else if (localName == nsGkAtoms::onget) {
    1:       onget = aAtts[1];
    1:     }
    1:     else if (localName == nsGkAtoms::onset) {
    1:       onset = aAtts[1];
    1:     }
    1:   }
    1: 
    1:   if (name) {
    1:     // All of our pointers are now filled in. Construct our property with all of
    1:     // these parameters.
    1:     mProperty = new nsXBLProtoImplProperty(name, onget, onset, readonly);
    1:     if (mProperty) {
    1:       AddMember(mProperty);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsXBLContentSink::ConstructMethod(const PRUnichar **aAtts)
    1: {
    1:   mMethod = nsnull;
    1: 
    1:   const PRUnichar* name = nsnull;
    1:   if (FindValue(aAtts, nsGkAtoms::name, &name)) {
    1:     mMethod = new nsXBLProtoImplMethod(name);
    1:   }
    1: 
    1:   if (mMethod) {
    1:     AddMember(mMethod);
    1:   }
    1: }
    1: 
    1: void
    1: nsXBLContentSink::ConstructParameter(const PRUnichar **aAtts)
    1: {
    1:   if (!mMethod)
    1:     return;
    1: 
    1:   const PRUnichar* name = nsnull;
    1:   if (FindValue(aAtts, nsGkAtoms::name, &name)) {
    1:     mMethod->AddParameter(nsDependentString(name));
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsXBLContentSink::CreateElement(const PRUnichar** aAtts, PRUint32 aAttsCount,
    1:                                 nsINodeInfo* aNodeInfo, PRUint32 aLineNumber,
19719:                                 nsIContent** aResult, PRBool* aAppendContent,
19719:                                 PRBool aFromParser)
    1: {
    1: #ifdef MOZ_XUL
    1:   if (!aNodeInfo->NamespaceEquals(kNameSpaceID_XUL)) {
    1: #endif
    1:     return nsXMLContentSink::CreateElement(aAtts, aAttsCount, aNodeInfo,
    1:                                            aLineNumber, aResult,
19719:                                            aAppendContent, aFromParser);
    1: #ifdef MOZ_XUL
    1:   }
    1: 
    1:   *aAppendContent = PR_TRUE;
20136:   nsRefPtr<nsXULPrototypeElement> prototype = new nsXULPrototypeElement();
    1:   if (!prototype)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   prototype->mNodeInfo = aNodeInfo;
    1:   // XXX - we need to do exactly what the XUL content-sink does (eg,
    1:   // look for 'type', 'version' etc attributes)
    1:   prototype->mScriptTypeID = nsIProgrammingLanguage::JAVASCRIPT;
    1: 
    1:   AddAttributesToXULPrototype(aAtts, aAttsCount, prototype);
    1: 
20136:   return nsXULElement::Create(prototype, mDocument, PR_FALSE, aResult);
    1: #endif
    1: }
    1: 
    1: nsresult 
    1: nsXBLContentSink::AddAttributes(const PRUnichar** aAtts,
    1:                                 nsIContent* aContent)
    1: {
33329:   if (aContent->IsXUL())
    1:     return NS_OK; // Nothing to do, since the proto already has the attrs.
    1: 
    1:   return nsXMLContentSink::AddAttributes(aAtts, aContent);
    1: }
    1: 
    1: #ifdef MOZ_XUL
    1: nsresult
    1: nsXBLContentSink::AddAttributesToXULPrototype(const PRUnichar **aAtts, 
    1:                                               PRUint32 aAttsCount, 
    1:                                               nsXULPrototypeElement* aElement)
    1: {
    1:   // Add tag attributes to the element
    1:   nsresult rv;
    1: 
    1:   // Create storage for the attributes
    1:   nsXULPrototypeAttribute* attrs = nsnull;
    1:   if (aAttsCount > 0) {
    1:     attrs = new nsXULPrototypeAttribute[aAttsCount];
    1:     if (!attrs)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   aElement->mAttributes    = attrs;
    1:   aElement->mNumAttributes = aAttsCount;
    1: 
    1:   // Copy the attributes into the prototype
    1:   nsCOMPtr<nsIAtom> prefix, localName;
    1: 
    1:   PRUint32 i;  
    1:   for (i = 0; i < aAttsCount; ++i) {
    1:     PRInt32 nameSpaceID;
    1:     nsContentUtils::SplitExpatName(aAtts[i * 2], getter_AddRefs(prefix),
    1:                                    getter_AddRefs(localName), &nameSpaceID);
    1: 
    1:     if (nameSpaceID == kNameSpaceID_None) {
    1:       attrs[i].mName.SetTo(localName);
    1:     }
    1:     else {
    1:       nsCOMPtr<nsINodeInfo> ni;
19197:       ni = mNodeInfoManager->GetNodeInfo(localName, prefix, nameSpaceID);
    1:       attrs[i].mName.SetTo(ni);
    1:     }
    1:     
    1:     rv = aElement->SetAttrAt(i, nsDependentString(aAtts[i * 2 + 1]),
    1:                              mDocumentURI); 
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: #endif
