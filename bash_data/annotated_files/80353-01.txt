    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Shell Service.
    1:  *
    1:  * The Initial Developer of the Original Code is mozilla.org.
    1:  * Portions created by the Initial Developer are Copyright (C) 2004
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Ben Goodger    <ben@mozilla.org>       (Clients, Mail, New Default Browser)
    1:  *  Joe Hewitt     <hewitt@netscape.com>   (Set Background)
 3818:  *  Blake Ross     <blake@cs.stanford.edu> (Desktop Color, DDE support)
    1:  *  Jungshik Shin  <jshin@mailaps.org>     (I18N)
 6438:  *  Robert Strong  <robert.bugzilla@gmail.com>
    1:  *  Asaf Romano    <mano@mozilla.com>
 3818:  *  Ryan Jones     <sciguyryan@gmail.com>
31003:  *  Paul O'Shannessy <paul@oshannessy.com>
42346:  *  Jim Mathies    <jmathies@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "imgIContainer.h"
    1: #include "imgIRequest.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefLocalizedString.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsNetUtil.h"
    1: #include "nsShellService.h"
    1: #include "nsWindowsShellService.h"
    1: #include "nsIProcess.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsBrowserCompsCID.h"
    1: #include "nsDirectoryServiceUtils.h"
    1: #include "nsAppDirectoryServiceDefs.h"
 6438: #include "nsDirectoryServiceDefs.h"
    1: #include "nsIWindowsRegKey.h"
 3818: #include "nsUnicharUtils.h"
42346: #include "nsIWinTaskbar.h"
42346: #include "nsISupportsPrimitives.h"
    1: 
    1: #include "windows.h"
    1: #include "shellapi.h"
14683: 
14683: #ifdef _WIN32_WINNT
14683: #undef _WIN32_WINNT
14683: #endif
14683: #define _WIN32_WINNT 0x0600
14683: #define INITGUID
14683: #include <shlobj.h>
    1: 
    1: #include <mbstring.h>
    1: 
    1: #ifndef MAX_BUF
    1: #define MAX_BUF 4096
    1: #endif
    1: 
    1: #define REG_SUCCEEDED(val) \
    1:   (val == ERROR_SUCCESS)
    1: 
    1: #define REG_FAILED(val) \
    1:   (val != ERROR_SUCCESS)
    1: 
42346: #define NS_TASKBAR_CONTRACTID "@mozilla.org/windows-taskbar;1"
42346: 
    1: NS_IMPL_ISUPPORTS2(nsWindowsShellService, nsIWindowsShellService, nsIShellService)
    1: 
    1: static nsresult
 6438: OpenKeyForReading(HKEY aKeyRoot, const nsAString& aKeyName, HKEY* aKey)
    1: {
 3818:   const nsString &flatName = PromiseFlatString(aKeyName);
    1: 
 6438:   DWORD res = ::RegOpenKeyExW(aKeyRoot, flatName.get(), 0, KEY_READ, aKey);
 3818:   switch (res) {
    1:   case ERROR_SUCCESS:
    1:     break;
    1:   case ERROR_ACCESS_DENIED:
    1:     return NS_ERROR_FILE_ACCESS_DENIED;
    1:   case ERROR_FILE_NOT_FOUND:
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////////
    1: // Default Browser Registry Settings
    1: //
 6438: // The setting of these values are made by an external binary since writing
 6438: // these values may require elevation.
 6438: //
    1: // - File Extension Mappings
    1: //   -----------------------
    1: //   The following file extensions:
    1: //    .htm .html .shtml .xht .xhtml 
    1: //   are mapped like so:
    1: //
    1: //   HKCU\SOFTWARE\Classes\.<ext>\      (default)         REG_SZ     FirefoxHTML
    1: //
    1: //   as aliases to the class:
    1: //
    1: //   HKCU\SOFTWARE\Classes\FirefoxHTML\
    1: //     DefaultIcon                      (default)         REG_SZ     <apppath>,1
 3321: //     shell\open\command               (default)         REG_SZ     <apppath> -requestPending -osint -url "%1"
    1: //     shell\open\ddeexec               (default)         REG_SZ     "%1",,0,0,,,,
    1: //     shell\open\ddeexec               NoActivateHandler REG_SZ
    1: //                       \Application   (default)         REG_SZ     Firefox
    1: //                       \Topic         (default)         REG_SZ     WWW_OpenURL
    1: //
    1: // - Windows Vista Protocol Handler
    1: //
    1: //   HKCU\SOFTWARE\Classes\FirefoxURL\  (default)         REG_SZ     <appname> URL
    1: //                                      EditFlags         REG_DWORD  2
    1: //                                      FriendlyTypeName  REG_SZ     <appname> URL
  769: //     DefaultIcon                      (default)         REG_SZ     <apppath>,1
 3321: //     shell\open\command               (default)         REG_SZ     <apppath> -requestPending -osint -url "%1"
    1: //     shell\open\ddeexec               (default)         REG_SZ     "%1",,0,0,,,,
    1: //     shell\open\ddeexec               NoActivateHandler REG_SZ
    1: //                       \Application   (default)         REG_SZ     Firefox
    1: //                       \Topic         (default)         REG_SZ     WWW_OpenURL
    1: //
    1: // - Protocol Mappings
    1: //   -----------------
    1: //   The following protocols:
 3569: //    HTTP, HTTPS, FTP
    1: //   are mapped like so:
    1: //
    1: //   HKCU\SOFTWARE\Classes\<protocol>\
  769: //     DefaultIcon                      (default)         REG_SZ     <apppath>,1
 3321: //     shell\open\command               (default)         REG_SZ     <apppath> -requestPending -osint -url "%1"
    1: //     shell\open\ddeexec               (default)         REG_SZ     "%1",,0,0,,,,
    1: //     shell\open\ddeexec               NoActivateHandler REG_SZ
    1: //                       \Application   (default)         REG_SZ     Firefox
    1: //                       \Topic         (default)         REG_SZ     WWW_OpenURL
    1: //
    1: // - Windows Start Menu (Win2K SP2, XP SP1, and newer)
    1: //   -------------------------------------------------
    1: //   The following keys are set to make Firefox appear in the Start Menu as the
    1: //   browser:
    1: //   
    1: //   HKCU\SOFTWARE\Clients\StartMenuInternet\FIREFOX.EXE\
    1: //                                      (default)         REG_SZ     <appname>
    1: //     DefaultIcon                      (default)         REG_SZ     <apppath>,0
    1: //     InstallInfo                      HideIconsCommand  REG_SZ     <uninstpath> /HideShortcuts
    1: //     InstallInfo                      IconsVisible      REG_DWORD  1
    1: //     InstallInfo                      ReinstallCommand  REG_SZ     <uninstpath> /SetAsDefaultAppGlobal
    1: //     InstallInfo                      ShowIconsCommand  REG_SZ     <uninstpath> /ShowShortcuts
    1: //     shell\open\command               (default)         REG_SZ     <apppath>
    1: //     shell\properties                 (default)         REG_SZ     <appname> &Options
    1: //     shell\properties\command         (default)         REG_SZ     <apppath> -preferences
    1: //     shell\safemode                   (default)         REG_SZ     <appname> &Safe Mode
    1: //     shell\safemode\command           (default)         REG_SZ     <apppath> -safe-mode
    1: //
    1: 
    1: typedef struct {
    1:   char* keyName;
    1:   char* valueName;
    1:   char* valueData;
    1: } SETTING;
    1: 
    1: #define APP_REG_NAME L"Firefox"
30081: #define CLS_HTML "FirefoxHTML"
30081: #define CLS_URL "FirefoxURL"
32067: #define CPL_DESKTOP L"Control Panel\\Desktop"
30081: #define VAL_OPEN "\"%APPPATH%\" -requestPending -osint -url \"%1\""
30081: #define VAL_FILE_ICON "%APPPATH%,1"
    1: #define DI "\\DefaultIcon"
    1: #define SOP "\\shell\\open\\command"
    1: 
    1: #define MAKE_KEY_NAME1(PREFIX, MID) \
    1:   PREFIX MID
    1: 
 6438: // The DefaultIcon registry key value should never be used when checking if
30081: // Firefox is the default browser for file handlers since other applications
30081: // (e.g. MS Office) may modify the DefaultIcon registry key value to add Icon
30081: // Handlers. see http://msdn2.microsoft.com/en-us/library/aa969357.aspx for
30081: // more info.
    1: static SETTING gSettings[] = {
30081:   // File Handler Class
25014:   { MAKE_KEY_NAME1(CLS_HTML, SOP), "", VAL_OPEN },
    1: 
    1:   // Protocol Handler Class - for Vista and above
25014:   { MAKE_KEY_NAME1(CLS_URL, SOP), "", VAL_OPEN },
    1: 
    1:   // Protocol Handlers
25014:   { MAKE_KEY_NAME1("HTTP", DI),    "", VAL_FILE_ICON },
25014:   { MAKE_KEY_NAME1("HTTP", SOP),   "", VAL_OPEN },
25014:   { MAKE_KEY_NAME1("HTTPS", DI),   "", VAL_FILE_ICON },
25014:   { MAKE_KEY_NAME1("HTTPS", SOP),  "", VAL_OPEN }
    1: };
    1: 
42346: nsresult
42346: GetHelperPath(nsAutoString& aPath)
42346: {
42346:   nsresult rv;
42346:   nsCOMPtr<nsIProperties> directoryService = 
42346:     do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID, &rv);
42346:   NS_ENSURE_SUCCESS(rv, rv);
42346: 
42346:   nsCOMPtr<nsILocalFile> appHelper;
42346:   rv = directoryService->Get(NS_XPCOM_CURRENT_PROCESS_DIR,
42346:                              NS_GET_IID(nsILocalFile),
42346:                              getter_AddRefs(appHelper));
42346:   NS_ENSURE_SUCCESS(rv, rv);
42346: 
42346:   rv = appHelper->AppendNative(NS_LITERAL_CSTRING("uninstall"));
42346:   NS_ENSURE_SUCCESS(rv, rv);
42346: 
42346:   rv = appHelper->AppendNative(NS_LITERAL_CSTRING("helper.exe"));
42346:   NS_ENSURE_SUCCESS(rv, rv);
42346: 
42346:   return appHelper->GetPath(aPath);
42346: }
42346: 
42346: nsresult
42346: LaunchHelper(nsAutoString& aPath)
42346: {
42346:   STARTUPINFOW si = {sizeof(si), 0};
42346:   PROCESS_INFORMATION pi = {0};
42346: 
42346:   BOOL ok = CreateProcessW(NULL, (LPWSTR)aPath.get(), NULL, NULL,
42346:                            FALSE, 0, NULL, NULL, &si, &pi);
42346: 
42346:   if (!ok)
42346:     return NS_ERROR_FAILURE;
42346: 
42346:   CloseHandle(pi.hProcess);
42346:   CloseHandle(pi.hThread);
42346:   return NS_OK;
42346: }
42346: 
42346: NS_IMETHODIMP
42346: nsWindowsShellService::ShortcutMaintenance()
42346: {
42346:   nsresult rv;
42346: 
42346:   // Launch helper.exe so it can update the application user model ids on
42346:   // shortcuts in the user's taskbar and start menu. This keeps older pinned
42346:   // shortcuts grouped correctly after major updates. Note, we also do this
42346:   // through the upgrade installer script, however, this is the only place we
42346:   // have a chance to trap links created by users who do control the install/
42346:   // update process of the browser.
42346: 
42346:   nsCOMPtr<nsIWinTaskbar> taskbarInfo =
42346:     do_GetService(NS_TASKBAR_CONTRACTID);
42346:   if (!taskbarInfo) // If we haven't built with win7 sdk features, this fails.
42346:     return NS_OK;
42346: 
42346:   // Avoid if this isn't Win7+
79445:   bool isSupported = false;
42346:   taskbarInfo->GetAvailable(&isSupported);
42346:   if (!isSupported)
42346:     return NS_OK;
42346: 
42346:   nsAutoString appId;
42346:   if (NS_FAILED(taskbarInfo->GetDefaultGroupId(appId)))
42346:     return NS_ERROR_UNEXPECTED;
42346: 
42346:   NS_NAMED_LITERAL_CSTRING(prefName, "browser.taskbar.lastgroupid");
42346:   nsCOMPtr<nsIPrefService> prefs =
42346:     do_GetService(NS_PREFSERVICE_CONTRACTID);
42346:   if (!prefs)
42346:     return NS_ERROR_UNEXPECTED;
42346: 
42346:   nsCOMPtr<nsIPrefBranch> prefBranch;
42346:   prefs->GetBranch(nsnull, getter_AddRefs(prefBranch));
42346:   if (!prefBranch)
42346:     return NS_ERROR_UNEXPECTED;
42346: 
42346:   nsCOMPtr<nsISupportsString> prefString;
42346:   rv = prefBranch->GetComplexValue(prefName.get(),
42346:                                    NS_GET_IID(nsISupportsString),
42346:                                    getter_AddRefs(prefString));
42346:   if (NS_SUCCEEDED(rv)) {
42346:     nsAutoString version;
42346:     prefString->GetData(version);
42346:     if (!version.IsEmpty() && version.Equals(appId)) {
42346:       // We're all good, get out of here.
42346:       return NS_OK;
42346:     }
42346:   }
42346:   // Update the version in prefs
42346:   prefString =
42346:     do_CreateInstance(NS_SUPPORTS_STRING_CONTRACTID, &rv);
42346:   if (NS_FAILED(rv))
42346:     return rv;
42346: 
42346:   prefString->SetData(appId);
42346:   rv = prefBranch->SetComplexValue(prefName.get(),
42346:                                    NS_GET_IID(nsISupportsString),
42346:                                    prefString);
42346:   if (NS_FAILED(rv)) {
42346:     NS_WARNING("Couldn't set last user model id!");
42346:     return NS_ERROR_UNEXPECTED;
42346:   }
42346: 
42346:   nsAutoString appHelperPath;
42346:   if (NS_FAILED(GetHelperPath(appHelperPath)))
42346:     return NS_ERROR_UNEXPECTED;
42346: 
42346:   appHelperPath.AppendLiteral(" /UpdateShortcutAppUserModelIds");
42346: 
42346:   return LaunchHelper(appHelperPath);
42346: }
42346: 
79445: bool
79445: nsWindowsShellService::IsDefaultBrowserVista(bool* aIsDefaultBrowser)
    1: {
27958: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN
    1:   IApplicationAssociationRegistration* pAAR;
    1:   
14683:   HRESULT hr = CoCreateInstance(CLSID_ApplicationAssociationRegistration,
    1:                                 NULL,
    1:                                 CLSCTX_INPROC,
14683:                                 IID_IApplicationAssociationRegistration,
    1:                                 (void**)&pAAR);
    1: 
 3818:   if (SUCCEEDED(hr)) {
77536:     BOOL res;
    1:     hr = pAAR->QueryAppIsDefaultAll(AL_EFFECTIVE,
    1:                                     APP_REG_NAME,
77536:                                     &res);
77536:     *aIsDefaultBrowser = res;
    1: 
    1:     pAAR->Release();
    1:     return PR_TRUE;
    1:   }
14683: #endif  
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsWindowsShellService::IsDefaultBrowser(bool aStartupCheck,
79445:                                         bool* aIsDefaultBrowser)
    1: {
 6438:   // If this is the first browser window, maintain internal state that we've
 6438:   // checked this session (so that subsequent window opens don't show the 
 6438:   // default browser dialog).
 6438:   if (aStartupCheck)
 6438:     mCheckedThisSession = PR_TRUE;
    1: 
    1:   SETTING* settings;
    1:   SETTING* end = gSettings + sizeof(gSettings)/sizeof(SETTING);
    1: 
    1:   *aIsDefaultBrowser = PR_TRUE;
    1: 
 3818:   PRUnichar exePath[MAX_BUF];
 3818:   if (!::GetModuleFileNameW(0, exePath, MAX_BUF))
    1:     return NS_ERROR_FAILURE;
    1: 
25014:   // Convert the path to a long path since GetModuleFileNameW returns the path
25014:   // that was used to launch Firefox which is not necessarily a long path.
25014:   if (!::GetLongPathNameW(exePath, exePath, MAX_BUF))
    1:     return NS_ERROR_FAILURE;
    1: 
25014:   nsAutoString appLongPath(exePath);
    1: 
25014:   nsresult rv;
 3818:   PRUnichar currValue[MAX_BUF];
    1:   for (settings = gSettings; settings < end; ++settings) {
 3818:     NS_ConvertUTF8toUTF16 dataLongPath(settings->valueData);
 3818:     NS_ConvertUTF8toUTF16 key(settings->keyName);
 3818:     NS_ConvertUTF8toUTF16 value(settings->valueName);
    1:     PRInt32 offset = dataLongPath.Find("%APPPATH%");
    1:     dataLongPath.Replace(offset, 9, appLongPath);
    1: 
    1:     ::ZeroMemory(currValue, sizeof(currValue));
    1:     HKEY theKey;
 6438:     rv = OpenKeyForReading(HKEY_CLASSES_ROOT, key, &theKey);
16387:     if (NS_FAILED(rv)) {
16387:       *aIsDefaultBrowser = PR_FALSE;
16388:       return NS_OK;
16387:     }
16387: 
    1:     DWORD len = sizeof currValue;
 3818:     DWORD res = ::RegQueryValueExW(theKey, PromiseFlatString(value).get(),
 3818:                                    NULL, NULL, (LPBYTE)currValue, &len);
    1:     // Close the key we opened.
    1:     ::RegCloseKey(theKey);
 3818:     if (REG_FAILED(res) ||
25014:         !dataLongPath.Equals(currValue, CaseInsensitiveCompare)) {
16387:       // Key wasn't set, or was set to something other than our registry entry
    1:       *aIsDefaultBrowser = PR_FALSE;
 6438:       return NS_OK;
    1:     }
    1:   }
    1: 
 6438:   // Only check if Firefox is the default browser on Vista if the previous
 6438:   // checks show that Firefox is the default browser.
16387:   if (*aIsDefaultBrowser)
16387:     IsDefaultBrowserVista(aIsDefaultBrowser);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsWindowsShellService::SetDefaultBrowser(bool aClaimAllTypes, bool aForAllUsers)
    1: {
16387:   nsAutoString appHelperPath;
42346:   if (NS_FAILED(GetHelperPath(appHelperPath)))
42346:     return NS_ERROR_FAILURE;
 6438: 
 6438:   if (aForAllUsers) {
 6438:     appHelperPath.AppendLiteral(" /SetAsDefaultAppGlobal");
 6438:   } else {
 6438:     appHelperPath.AppendLiteral(" /SetAsDefaultAppUser");
 6438:   }
 6438: 
42346:   return LaunchHelper(appHelperPath);
30081: }
30081: 
    1: NS_IMETHODIMP
79445: nsWindowsShellService::GetShouldCheckDefaultBrowser(bool* aResult)
    1: {
80353:   NS_ENSURE_ARG_POINTER(aResult);
80353: 
    1:   // If we've already checked, the browser has been started and this is a 
    1:   // new window open, and we don't want to check again.
    1:   if (mCheckedThisSession) {
    1:     *aResult = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIPrefBranch> prefs;
80353:   nsresult rv;
80353:   nsCOMPtr<nsIPrefService> pserve(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
80353:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
80353:   rv = pserve->GetBranch("", getter_AddRefs(prefs));
80353:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
80353:   return prefs->GetBoolPref(PREF_CHECKDEFAULTBROWSER, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsWindowsShellService::SetShouldCheckDefaultBrowser(bool aShouldCheck)
    1: {
    1:   nsCOMPtr<nsIPrefBranch> prefs;
80353:   nsresult rv;
    1: 
80353:   nsCOMPtr<nsIPrefService> pserve(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
80353:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
80353:   rv = pserve->GetBranch("", getter_AddRefs(prefs));
80353:   NS_ENSURE_SUCCESS(rv, rv);
80353: 
80353:   return prefs->SetBoolPref(PREF_CHECKDEFAULTBROWSER, aShouldCheck);
    1: }
    1: 
    1: static nsresult
30479: WriteBitmap(nsIFile* aFile, imgIContainer* aImage)
    1: {
30479:   nsRefPtr<gfxImageSurface> image;
32424:   nsresult rv = aImage->CopyFrame(imgIContainer::FRAME_FIRST,
32424:                                   imgIContainer::FLAG_SYNC_DECODE,
32424:                                   getter_AddRefs(image));
30479:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
30479:   PRInt32 width = image->Width();
30479:   PRInt32 height = image->Height();
    1: 
30479:   PRUint8* bits = image->Data();
30479:   PRUint32 length = image->GetDataSize();
30479:   PRUint32 bpr = PRUint32(image->Stride());
    1:   PRInt32 bitCount = bpr/width;
    1: 
    1:   // initialize these bitmap structs which we will later
    1:   // serialize directly to the head of the bitmap file
    1:   BITMAPINFOHEADER bmi;
    1:   bmi.biSize = sizeof(BITMAPINFOHEADER);
    1:   bmi.biWidth = width;
    1:   bmi.biHeight = height;
    1:   bmi.biPlanes = 1;
    1:   bmi.biBitCount = (WORD)bitCount*8;
    1:   bmi.biCompression = BI_RGB;
    1:   bmi.biSizeImage = length;
    1:   bmi.biXPelsPerMeter = 0;
    1:   bmi.biYPelsPerMeter = 0;
    1:   bmi.biClrUsed = 0;
    1:   bmi.biClrImportant = 0;
    1: 
    1:   BITMAPFILEHEADER bf;
    1:   bf.bfType = 0x4D42; // 'BM'
    1:   bf.bfReserved1 = 0;
    1:   bf.bfReserved2 = 0;
    1:   bf.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
    1:   bf.bfSize = bf.bfOffBits + bmi.biSizeImage;
    1: 
    1:   // get a file output stream
    1:   nsCOMPtr<nsIOutputStream> stream;
30479:   rv = NS_NewLocalFileOutputStream(getter_AddRefs(stream), aFile);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // write the bitmap headers and rgb pixel data to the file
    1:   rv = NS_ERROR_FAILURE;
    1:   if (stream) {
    1:     PRUint32 written;
    1:     stream->Write((const char*)&bf, sizeof(BITMAPFILEHEADER), &written);
    1:     if (written == sizeof(BITMAPFILEHEADER)) {
    1:       stream->Write((const char*)&bmi, sizeof(BITMAPINFOHEADER), &written);
    1:       if (written == sizeof(BITMAPINFOHEADER)) {
    1:         // write out the image data backwards because the desktop won't
    1:         // show bitmaps with negative heights for top-to-bottom
    1:         PRUint32 i = length;
    1:         do {
    1:           i -= bpr;
    1:           stream->Write(((const char*)bits) + i, bpr, &written);
    1:           if (written == bpr) {
    1:             rv = NS_OK;
    1:           } else {
    1:             rv = NS_ERROR_FAILURE;
    1:             break;
    1:           }
    1:         } while (i != 0);
    1:       }
    1:     }
    1: 
    1:     stream->Close();
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::SetDesktopBackground(nsIDOMElement* aElement, 
    1:                                             PRInt32 aPosition)
    1: {
    1:   nsresult rv;
    1: 
30479:   nsCOMPtr<imgIContainer> container;
    1:   nsCOMPtr<nsIDOMHTMLImageElement> imgElement(do_QueryInterface(aElement));
    1:   if (!imgElement) {
    1:     // XXX write background loading stuff!
35665:     return NS_ERROR_NOT_AVAILABLE;
    1:   } 
    1:   else {
 3818:     nsCOMPtr<nsIImageLoadingContent> imageContent =
 3818:       do_QueryInterface(aElement, &rv);
 3818:     if (!imageContent)
 3818:       return rv;
    1: 
    1:     // get the image container
    1:     nsCOMPtr<imgIRequest> request;
    1:     rv = imageContent->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                                   getter_AddRefs(request));
 3818:     if (!request)
 3818:       return rv;
    1:     rv = request->GetImage(getter_AddRefs(container));
    1:     if (!container)
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // get the file name from localized strings
    1:   nsCOMPtr<nsIStringBundleService>
    1:     bundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIStringBundle> shellBundle;
    1:   rv = bundleService->CreateBundle(SHELLSERVICE_PROPERTIES,
    1:                                    getter_AddRefs(shellBundle));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:  
    1:   // e.g. "Desktop Background.bmp"
    1:   nsString fileLeafName;
    1:   rv = shellBundle->GetStringFromName
    1:                       (NS_LITERAL_STRING("desktopBackgroundLeafNameWin").get(),
    1:                        getter_Copies(fileLeafName));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // get the profile root directory
    1:   nsCOMPtr<nsIFile> file;
    1:   rv = NS_GetSpecialDirectory(NS_APP_APPLICATION_REGISTRY_DIR,
    1:                               getter_AddRefs(file));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // eventually, the path is "%APPDATA%\Mozilla\Firefox\Desktop Background.bmp"
    1:   rv = file->Append(fileLeafName);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 3818:   nsAutoString path;
 3818:   rv = file->GetPath(path);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // write the bitmap to a file in the profile directory
30479:   rv = WriteBitmap(file, container);
    1: 
    1:   // if the file was written successfully, set it as the system wallpaper
    1:   if (NS_SUCCEEDED(rv)) {
79445:      bool result = false;
    1:      DWORD  dwDisp = 0;
    1:      HKEY   key;
31003:      // Try to create/open a subkey under HKCU.
31003:      DWORD res = ::RegCreateKeyExW(HKEY_CURRENT_USER, CPL_DESKTOP,
 3818:                                    0, NULL, REG_OPTION_NON_VOLATILE,
 3818:                                    KEY_WRITE, NULL, &key, &dwDisp);
 3818:     if (REG_SUCCEEDED(res)) {
 3818:       PRUnichar tile[2], style[2];
 3818:       switch (aPosition) {
 3818:         case BACKGROUND_TILE:
    1:           tile[0] = '1';
    1:           style[0] = '1';
 3818:           break;
 3818:         case BACKGROUND_CENTER:
    1:           tile[0] = '0';
    1:           style[0] = '0';
 3818:           break;
 3818:         case BACKGROUND_STRETCH:
    1:           tile[0] = '0';
    1:           style[0] = '2';
 3818:           break;
    1:       }
    1:       tile[1] = '\0';
    1:       style[1] = '\0';
 3818: 
 3818:       // The size is always 3 unicode characters.
 3818:       PRInt32 size = 3 * sizeof(PRUnichar);
 3818:       ::RegSetValueExW(key, L"TileWallpaper",
 3818:                        0, REG_SZ, (const BYTE *)tile, size);
 3818:       ::RegSetValueExW(key, L"WallpaperStyle",
 3818:                        0, REG_SZ, (const BYTE *)style, size);
 3818:       ::SystemParametersInfoW(SPI_SETDESKWALLPAPER, 0, (PVOID)path.get(),
24930:                               SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
31003: 
    1:       // Close the key we opened.
    1:       ::RegCloseKey(key);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::OpenApplication(PRInt32 aApplication)
    1: {
 3818:   nsAutoString application;
    1:   switch (aApplication) {
    1:   case nsIShellService::APPLICATION_MAIL:
 3818:     application.AssignLiteral("Mail");
    1:     break;
    1:   case nsIShellService::APPLICATION_NEWS:
 3818:     application.AssignLiteral("News");
    1:     break;
    1:   }
    1: 
    1:   // The Default Client section of the Windows Registry looks like this:
    1:   // 
    1:   // Clients\aClient\
    1:   //  e.g. aClient = "Mail"...
    1:   //        \Mail\(default) = Client Subkey Name
    1:   //             \Client Subkey Name
    1:   //             \Client Subkey Name\shell\open\command\ 
    1:   //             \Client Subkey Name\shell\open\command\(default) = path to exe
    1:   //
    1: 
    1:   // Find the default application for this class.
    1:   HKEY theKey;
 6438:   nsresult rv = OpenKeyForReading(HKEY_CLASSES_ROOT, application, &theKey);
 3818:   if (NS_FAILED(rv))
 3818:     return rv;
    1: 
 3818:   PRUnichar buf[MAX_BUF];
    1:   DWORD type, len = sizeof buf;
 3818:   DWORD res = ::RegQueryValueExW(theKey, EmptyString().get(), 0,
 3818:                                  &type, (LPBYTE)&buf, &len);
 3818: 
 3818:   if (REG_FAILED(res) || !*buf)
    1:     return NS_OK;
    1: 
    1:   // Close the key we opened.
    1:   ::RegCloseKey(theKey);
    1: 
    1:   // Find the "open" command
 6438:   application.AppendLiteral("\\");
 6438:   application.Append(buf);
 6438:   application.AppendLiteral("\\shell\\open\\command");
    1: 
 6438:   rv = OpenKeyForReading(HKEY_CLASSES_ROOT, application, &theKey);
 3818:   if (NS_FAILED(rv))
 3818:     return rv;
    1: 
    1:   ::ZeroMemory(buf, sizeof(buf));
    1:   len = sizeof buf;
 3818:   res = ::RegQueryValueExW(theKey, EmptyString().get(), 0,
 3818:                            &type, (LPBYTE)&buf, &len);
 3818:   if (REG_FAILED(res) || !*buf)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Close the key we opened.
    1:   ::RegCloseKey(theKey);
    1: 
    1:   // Look for any embedded environment variables and substitute their 
 3818:   // values, as |::CreateProcessW| is unable to do this.
 3818:   nsAutoString path(buf);
    1:   PRInt32 end = path.Length();
    1:   PRInt32 cursor = 0, temp = 0;
    1:   ::ZeroMemory(buf, sizeof(buf));
    1:   do {
    1:     cursor = path.FindChar('%', cursor);
    1:     if (cursor < 0) 
    1:       break;
    1: 
    1:     temp = path.FindChar('%', cursor + 1);
    1:     ++cursor;
    1: 
    1:     ::ZeroMemory(&buf, sizeof(buf));
 3818: 
 3818:     ::GetEnvironmentVariableW(nsAutoString(Substring(path, cursor, temp - cursor)).get(),
    1:                               buf, sizeof(buf));
    1:     
    1:     // "+ 2" is to subtract the extra characters used to delimit the environment
    1:     // variable ('%').
 3818:     path.Replace((cursor - 1), temp - cursor + 2, nsDependentString(buf));
    1: 
    1:     ++cursor;
    1:   }
    1:   while (cursor < end);
    1: 
 3818:   STARTUPINFOW si;
    1:   PROCESS_INFORMATION pi;
    1: 
 3818:   ::ZeroMemory(&si, sizeof(STARTUPINFOW));
    1:   ::ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
    1: 
 3818:   BOOL success = ::CreateProcessW(NULL, (LPWSTR)path.get(), NULL,
 3818:                                   NULL, FALSE, 0, NULL,  NULL,
 3818:                                   &si, &pi);
    1:   if (!success)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::GetDesktopBackgroundColor(PRUint32* aColor)
    1: {
    1:   PRUint32 color = ::GetSysColor(COLOR_DESKTOP);
    1:   *aColor = (GetRValue(color) << 16) | (GetGValue(color) << 8) | GetBValue(color);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::SetDesktopBackgroundColor(PRUint32 aColor)
    1: {
    1:   int aParameters[2] = { COLOR_BACKGROUND, COLOR_DESKTOP };
    1:   BYTE r = (aColor >> 16);
    1:   BYTE g = (aColor << 16) >> 24;
    1:   BYTE b = (aColor << 24) >> 24;
    1:   COLORREF colors[2] = { RGB(r,g,b), RGB(r,g,b) };
    1: 
    1:   ::SetSysColors(sizeof(aParameters) / sizeof(int), aParameters, colors);
    1: 
79445:   bool result = false;
    1:   DWORD  dwDisp = 0;
    1:   HKEY   key;
31003:   // Try to create/open a subkey under HKCU.
 3818:   DWORD rv = ::RegCreateKeyExW(HKEY_CURRENT_USER,
 3818:                                L"Control Panel\\Colors", 0, NULL,
 3818:                                REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
 3818:                                &key, &dwDisp);
 3818: 
 3818:   if (REG_SUCCEEDED(rv)) {
 3818:     char rgb[12];
    1:     sprintf((char*)rgb, "%u %u %u\0", r, g, b);
 3818:     NS_ConvertUTF8toUTF16 backColor(rgb);
 3818: 
 3818:     ::RegSetValueExW(key, L"Background",
 3818:                      0, REG_SZ, (const BYTE *)backColor.get(),
 3818:                      (backColor.Length() + 1) * sizeof(PRUnichar));
    1:   }
    1:   
    1:   // Close the key we opened.
    1:   ::RegCloseKey(key);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::GetUnreadMailCount(PRUint32* aCount)
    1: {
    1:   *aCount = 0;
    1: 
    1:   HKEY accountKey;
    1:   if (GetMailAccountKey(&accountKey)) {
    1:     DWORD type, unreadCount;
    1:     DWORD len = sizeof unreadCount;
 3818:     DWORD res = ::RegQueryValueExW(accountKey, L"MessageCount", 0,
 3818:                                    &type, (LPBYTE)&unreadCount, &len);
 3818:     if (REG_SUCCEEDED(res))
    1:       *aCount = unreadCount;
    1: 
    1:     // Close the key we opened.
    1:     ::RegCloseKey(accountKey);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
79445: bool
    1: nsWindowsShellService::GetMailAccountKey(HKEY* aResult)
    1: {
 3818:   NS_NAMED_LITERAL_STRING(unread,
 3818:     "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UnreadMail\\");
 3818: 
    1:   HKEY mailKey;
 3818:   DWORD res = ::RegOpenKeyExW(HKEY_CURRENT_USER, unread.get(), 0,
 3818:                               KEY_ENUMERATE_SUB_KEYS, &mailKey);
    1: 
    1:   PRInt32 i = 0;
    1:   do {
 3818:     PRUnichar subkeyName[MAX_BUF];
    1:     DWORD len = sizeof subkeyName;
 3818:     res = ::RegEnumKeyExW(mailKey, i++, subkeyName, &len, NULL, NULL,
 3818:                           NULL, NULL);
 3818:     if (REG_SUCCEEDED(res)) {
    1:       HKEY accountKey;
 3818:       res = ::RegOpenKeyExW(mailKey, PromiseFlatString(subkeyName).get(),
 3818:                             0, KEY_READ, &accountKey);
 3818:       if (REG_SUCCEEDED(res)) {
    1:         *aResult = accountKey;
    1:     
    1:         // Close the key we opened.
    1:         ::RegCloseKey(mailKey);
    1: 	 
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:     else
    1:       break;
    1:   }
    1:   while (1);
    1: 
    1:   // Close the key we opened.
    1:   ::RegCloseKey(mailKey);
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
 3818: nsWindowsShellService::OpenApplicationWithURI(nsILocalFile* aApplication,
 3818:                                               const nsACString& aURI)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIProcess> process = 
    1:     do_CreateInstance("@mozilla.org/process/util;1", &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   
    1:   rv = process->Init(aApplication);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   
    1:   const nsCString spec(aURI);
    1:   const char* specStr = spec.get();
25944:   return process->Run(PR_FALSE, &specStr, 1);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::GetDefaultFeedReader(nsILocalFile** _retval)
    1: {
    1:   *_retval = nsnull;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIWindowsRegKey> regKey =
    1:     do_CreateInstance("@mozilla.org/windows-registry-key;1", &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
    1:                     NS_LITERAL_STRING("feed\\shell\\open\\command"),
    1:                     nsIWindowsRegKey::ACCESS_READ);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString path;
    1:   rv = regKey->ReadStringValue(EmptyString(), path);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (path.IsEmpty())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (path.First() == '"') {
    1:     // Everything inside the quotes
    1:     path = Substring(path, 1, path.FindChar('"', 1) - 1);
    1:   }
    1:   else {
    1:     // Everything up to the first space
    1:     path = Substring(path, 0, path.FindChar(' '));
    1:   }
    1: 
    1:   nsCOMPtr<nsILocalFile> defaultReader =
    1:     do_CreateInstance("@mozilla.org/file/local;1", &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = defaultReader->InitWithPath(path);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
79445:   bool exists;
    1:   rv = defaultReader->Exists(&exists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (!exists)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   NS_ADDREF(*_retval = defaultReader);
    1:   return NS_OK;
    1: }
