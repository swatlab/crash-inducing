   1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Blake Ross <blaker@netscape.com>
   1:  *   Ben Goodger <ben@netscape.com>
1691:  *   Shawn Wilsher <me@shawnwilsher.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
   1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1:  
   1: #ifndef downloadmanager___h___
   1: #define downloadmanager___h___
   1: 
   1: #include "nsIDownloadManager.h"
   1: #include "nsIDownloadProgressListener.h"
   1: #include "nsIDownload.h"
   1: #include "nsIDOMDocument.h"
   1: #include "nsIDOMEventListener.h"
   1: #include "nsIWebProgressListener.h"
   1: #include "nsIWebProgressListener2.h"
   1: #include "nsIURI.h"
   1: #include "nsIWebBrowserPersist.h"
   1: #include "nsILocalFile.h"
   1: #include "nsIRequest.h"
   1: #include "nsIObserver.h"
1691: #include "nsString.h"
   1: #include "nsIStringBundle.h"
   1: #include "nsISupportsPrimitives.h"
   1: #include "nsIMIMEInfo.h"
1691: #include "mozIStorageConnection.h"
3038: #include "mozIStorageStatement.h"
1691: #include "nsISupportsArray.h"
1691: #include "nsCOMArray.h"
1691: #include "nsArrayEnumerator.h"
1691: #include "nsAutoPtr.h"
1691: #include "nsIObserverService.h"
   1: 
   1: typedef PRInt16 DownloadState;
   1: typedef PRInt16 DownloadType;
   1: 
   1: class nsDownload;
   1: 
5176: #ifdef XP_WIN
5176: class nsDownloadScanner;
5176: #endif
5176: 
   1: class nsDownloadManager : public nsIDownloadManager,
   1:                           public nsIObserver
   1: {
   1: public:
   1:   NS_DECL_ISUPPORTS
   1:   NS_DECL_NSIDOWNLOADMANAGER
   1:   NS_DECL_NSIOBSERVER
   1: 
   1:   nsresult Init();
   1: 
3409:   static nsDownloadManager *GetSingleton();
3409: 
   1:   virtual ~nsDownloadManager();
5176: #ifdef XP_WIN
5176:   nsDownloadManager() : mScanner(nsnull) { };
5176: private:
5176:   nsDownloadScanner *mScanner;
5176: #endif
   1: 
1691: protected:
1691:   nsresult InitDB(PRBool *aDoImport);
1691:   nsresult CreateTable();
1691:   nsresult ImportDownloadHistory();
2116:   nsresult GetDownloadFromDB(PRUint32 aID, nsDownload **retVal);
2699: 
2699:   inline nsresult AddToCurrentDownloads(nsDownload *aDl)
2699:   {
2699:     if (!mCurrentDownloads.AppendObject(aDl))
2699:       return NS_ERROR_OUT_OF_MEMORY;
2699: 
2699:     return NS_OK;
2699:   }
2699: 
5176:   void SendEvent(nsDownload *aDownload, const char *aTopic);
5176: 
   1: 
1691:   /**
1691:    * Adds a download with the specified information to the DB.
1691:    *
1691:    * @return The id of the download, or 0 if there was an error.
1691:    */
1691:   PRInt64 AddDownloadToDB(const nsAString &aName,
1691:                           const nsACString &aSource,
1691:                           const nsACString &aTarget,
1691:                           PRInt64 aStartTime,
1691:                           PRInt64 aEndTime,
1691:                           PRInt32 aState);
   1: 
1877:   void NotifyListenersOnDownloadStateChange(PRInt16 aOldState,
1877:                                             nsIDownload *aDownload);
1877:   void NotifyListenersOnProgressChange(nsIWebProgress *aProgress,
1877:                                        nsIRequest *aRequest,
1877:                                        PRInt64 aCurSelfProgress,
1877:                                        PRInt64 aMaxSelfProgress,
1877:                                        PRInt64 aCurTotalProgress,
1877:                                        PRInt64 aMaxTotalProgress,
1877:                                        nsIDownload *aDownload);
1877:   void NotifyListenersOnStateChange(nsIWebProgress *aProgress,
1877:                                     nsIRequest *aRequest,
1877:                                     PRUint32 aStateFlags,
1877:                                     nsresult aStatus,
1877:                                     nsIDownload *aDownload);
1877: 
1691:   nsDownload *FindDownload(PRUint32 aID);
1691:   nsresult PauseResumeDownload(PRUint32 aID, PRBool aPause);
1691:   nsresult CancelAllDownloads();
   1: 
2485:   /**
5176:    * Removes download from "current downloads". 
2487:    *
2487:    * This method removes the cycle created when starting the download, so 
2487:    * make sure to use kungFuDeathGrip if you want to access member variables
2485:    */
5176:   void CompleteDownload(nsDownload *aDownload);
1691: 
1691:   void     ConfirmCancelDownloads(PRInt32 aCount,
1691:                                   nsISupportsPRBool* aCancelDownloads,
   1:                                   const PRUnichar* aTitle, 
   1:                                   const PRUnichar* aCancelMessageMultiple, 
   1:                                   const PRUnichar* aCancelMessageSingle,
   1:                                   const PRUnichar* aDontCancelButton);
   1: 
   1:   PRInt32  GetRetentionBehavior();
   1: 
   1:   static PRBool IsInFinalStage(DownloadState aState)
   1:   {
   1:     return aState == nsIDownloadManager::DOWNLOAD_NOTSTARTED ||
2699:            aState == nsIDownloadManager::DOWNLOAD_DOWNLOADING;
 731:   }
   1: 
   1:   static PRBool IsInProgress(DownloadState aState) 
   1:   {
   1:     return aState == nsIDownloadManager::DOWNLOAD_NOTSTARTED || 
4676:            aState == nsIDownloadManager::DOWNLOAD_QUEUED ||
   1:            aState == nsIDownloadManager::DOWNLOAD_DOWNLOADING || 
2699:            aState == nsIDownloadManager::DOWNLOAD_PAUSED;
 731:   }
   1: 
   1:   static PRBool CompletedSuccessfully(DownloadState aState)
   1:   {
2699:     return aState == nsIDownloadManager::DOWNLOAD_FINISHED;
 731:   }
   1: 
   1: private:
1877:   nsCOMArray<nsIDownloadProgressListener> mListeners;
   1:   nsCOMPtr<nsIStringBundle> mBundle;
1691:   nsCOMPtr<mozIStorageConnection> mDBConn;
1691:   nsCOMArray<nsDownload> mCurrentDownloads;
1691:   nsCOMPtr<nsIObserverService> mObserverService;
3038:   nsCOMPtr<mozIStorageStatement> mUpdateDownloadStatement;
   1: 
3409:   static nsDownloadManager *gDownloadManagerService;
3409: 
   1:   friend class nsDownload;
   1: };
   1: 
   1: class nsDownload : public nsIDownload
   1: {
   1: public:
   1:   NS_DECL_NSIWEBPROGRESSLISTENER
   1:   NS_DECL_NSIWEBPROGRESSLISTENER2
   1:   NS_DECL_NSITRANSFER
   1:   NS_DECL_NSIDOWNLOAD
   1:   NS_DECL_ISUPPORTS
   1: 
   1:   nsDownload();
   1:   virtual ~nsDownload();
   1: 
   1: public:
1691:   /**
1691:    * This method MUST be called when changing states on a download.  It will
1808:    * notify the download listener when a change happens.  This also updates the
1808:    * database, by calling UpdateDB().
1691:    */
1808:   nsresult SetState(DownloadState aState);
1691: 
   1:   DownloadType GetDownloadType();
   1:   void SetDownloadType(DownloadType aType);
   1: 
1691:   nsresult UpdateDB();
1691: 
   1: protected:
1691:   void SetStartTime(PRInt64 aStartTime);
   1: 
1691:   nsresult PauseResume(PRBool aPause);
   1: 
   1:   nsDownloadManager* mDownloadManager;
   1:   nsCOMPtr<nsIURI> mTarget;
   1: 
   1: private:
   1:   nsString mDisplayName;
   1: 
   1:   nsCOMPtr<nsIURI> mSource;
4765:   nsCOMPtr<nsIURI> mReferrer;
   1:   nsCOMPtr<nsICancelable> mCancelable;
   1:   nsCOMPtr<nsIRequest> mRequest;
   1:   nsCOMPtr<nsILocalFile> mTempFile;
   1:   nsCOMPtr<nsIMIMEInfo> mMIMEInfo;
   1:   
   1:   DownloadState mDownloadState;
   1:   DownloadType  mDownloadType;
   1: 
1691:   PRUint32 mID;
   1:   PRInt32 mPercentComplete;
   1:   PRUint64 mCurrBytes;
   1:   PRUint64 mMaxBytes;
   1:   PRTime mStartTime;
   1:   PRTime mLastUpdate;
1691:   PRBool mPaused;
   1:   double mSpeed;
   1: 
   1:   friend class nsDownloadManager;
   1: };
   1: 
   1: #endif
