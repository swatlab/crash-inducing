 8141: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Witte (dwitte@stanford.edu)
    1:  *   Michiel van Leeuwen (mvl@exedo.nl)
20636:  *   Michael Ventnor <m.ventnor@gmail.com>
20636:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCookieService.h"
    1: #include "nsIServiceManager.h"
    1: 
    1: #include "nsIIOService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefBranch2.h"
    1: #include "nsIPrefService.h"
    1: #include "nsICookiePermission.h"
    1: #include "nsIURI.h"
    1: #include "nsIURL.h"
    1: #include "nsIChannel.h"
    1: #include "nsIFile.h"
    1: #include "nsIObserverService.h"
    1: #include "nsILineInputStream.h"
 8702: #include "nsIEffectiveTLDService.h"
    1: 
    1: #include "nsCOMArray.h"
    1: #include "nsArrayEnumerator.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsCRT.h"
    1: #include "prtime.h"
    1: #include "prprf.h"
    1: #include "nsNetUtil.h"
    1: #include "nsNetCID.h"
    1: #include "nsAppDirectoryServiceDefs.h"
 2508: #include "mozIStorageService.h"
 2508: #include "mozIStorageStatement.h"
 2508: #include "mozIStorageConnection.h"
 2508: #include "mozStorageHelper.h"
20636: #include "nsIPrivateBrowsingService.h"
20636: #include "nsNetCID.h"
    1: 
    1: /******************************************************************************
    1:  * nsCookieService impl:
    1:  * useful types & constants
    1:  ******************************************************************************/
    1: 
    1: // XXX_hack. See bug 178993.
    1: // This is a hack to hide HttpOnly cookies from older browsers
    1: //
    1: static const char kHttpOnlyPrefix[] = "#HttpOnly_";
    1: 
 2508: static const char kCookieFileName[] = "cookies.sqlite";
 8141: #define COOKIES_SCHEMA_VERSION 2
 8141: 
 8141: static const PRInt64 kCookieStaleThreshold = 60 * PR_USEC_PER_SEC; // 1 minute in microseconds
    1: 
 2508: static const char kOldCookieFileName[] = "cookies.txt";
    1: 
    1: #undef  LIMIT
    1: #define LIMIT(x, low, high, default) ((x) >= (low) && (x) <= (high) ? (x) : (default))
    1: 
    1: // default limits for the cookie list. these can be tuned by the
    1: // network.cookie.maxNumber and network.cookie.maxPerHost prefs respectively.
24568: static const PRUint32 kMaxNumberOfCookies = 3000;
    1: static const PRUint32 kMaxCookiesPerHost  = 50;
    1: static const PRUint32 kMaxBytesPerCookie  = 4096;
  956: static const PRUint32 kMaxBytesPerPath    = 1024;
    1: 
 2626: // these constants represent a decision about a cookie based on user prefs.
 2626: static const PRUint32 STATUS_ACCEPTED            = 0;
 2626: static const PRUint32 STATUS_REJECTED            = 1;
 2626: // STATUS_REJECTED_WITH_ERROR indicates the cookie should be rejected because
 2626: // of an error (rather than something the user can control). this is used for
 2626: // notification purposes, since we only want to notify of rejections where
    1: // the user can do something about it (e.g. whitelist the site).
 2626: static const PRUint32 STATUS_REJECTED_WITH_ERROR = 2;
    1: 
    1: // behavior pref constants 
    1: static const PRUint32 BEHAVIOR_ACCEPT        = 0;
    1: static const PRUint32 BEHAVIOR_REJECTFOREIGN = 1;
    1: static const PRUint32 BEHAVIOR_REJECT        = 2;
    1: 
    1: // pref string constants
    1: static const char kPrefCookiesPermissions[] = "network.cookie.cookieBehavior";
    1: static const char kPrefMaxNumberOfCookies[] = "network.cookie.maxNumber";
    1: static const char kPrefMaxCookiesPerHost[]  = "network.cookie.maxPerHost";
    1: 
    1: // struct for temporarily storing cookie attributes during header parsing
    1: struct nsCookieAttributes
    1: {
    1:   nsCAutoString name;
    1:   nsCAutoString value;
    1:   nsCAutoString host;
    1:   nsCAutoString path;
    1:   nsCAutoString expires;
    1:   nsCAutoString maxage;
 2508:   PRInt64 expiryTime;
    1:   PRBool isSession;
    1:   PRBool isSecure;
    1:   PRBool isHttpOnly;
    1: };
    1: 
    1: // stores linked list iteration state, and provides a rudimentary
    1: // list traversal method
    1: struct nsListIter
    1: {
    1:   nsListIter() {}
    1: 
30354:   explicit
    1:   nsListIter(nsCookieEntry *aEntry)
    1:    : entry(aEntry)
    1:    , prev(nsnull)
    1:    , current(aEntry ? aEntry->Head() : nsnull) {}
    1: 
    1:   nsListIter(nsCookieEntry *aEntry,
    1:              nsCookie      *aPrev,
    1:              nsCookie      *aCurrent)
    1:    : entry(aEntry)
    1:    , prev(aPrev)
    1:    , current(aCurrent) {}
    1: 
    1:   nsListIter& operator++() { prev = current; current = current->Next(); return *this; }
    1: 
    1:   nsCookieEntry *entry;
    1:   nsCookie      *prev;
    1:   nsCookie      *current;
    1: };
    1: 
    1: // stores temporary data for enumerating over the hash entries,
    1: // since enumeration is done using callback functions
    1: struct nsEnumerationData
    1: {
 2508:   nsEnumerationData(PRInt64 aCurrentTime,
 8141:                     PRInt64 aOldestTime)
    1:    : currentTime(aCurrentTime)
 8141:    , oldestTime(aOldestTime)
    1:    , iter(nsnull, nsnull, nsnull) {}
    1: 
 8141:   // the current time, in seconds
 2508:   PRInt64 currentTime;
    1: 
 8141:   // oldest lastAccessed time in the cookie list. use aOldestTime = LL_MAXINT
    1:   // to enable this search, LL_MININT to disable it.
 8141:   PRInt64 oldestTime;
    1: 
    1:   // an iterator object that points to the desired cookie
    1:   nsListIter iter;
    1: };
    1: 
    1: /******************************************************************************
    1:  * Cookie logging handlers
    1:  * used for logging in nsCookieService
    1:  ******************************************************************************/
    1: 
    1: // logging handlers
    1: #ifdef MOZ_LOGGING
    1: // in order to do logging, the following environment variables need to be set:
    1: //
    1: //    set NSPR_LOG_MODULES=cookie:3 -- shows rejected cookies
    1: //    set NSPR_LOG_MODULES=cookie:4 -- shows accepted and rejected cookies
    1: //    set NSPR_LOG_FILE=cookie.log
    1: //
    1: // this next define has to appear before the include of prlog.h
    1: #define FORCE_PR_LOG // Allow logging in the release build
    1: #include "prlog.h"
    1: #endif
    1: 
    1: // define logging macros for convenience
    1: #define SET_COOKIE PR_TRUE
    1: #define GET_COOKIE PR_FALSE
    1: 
    1: #ifdef PR_LOGGING
    1: static PRLogModuleInfo *sCookieLog = PR_NewLogModule("cookie");
    1: 
    1: #define COOKIE_LOGFAILURE(a, b, c, d)    LogFailure(a, b, c, d)
 7285: #define COOKIE_LOGSUCCESS(a, b, c, d, e) LogSuccess(a, b, c, d, e)
30480: #define COOKIE_LOGEVICTED(a)             LogEvicted(a)
 7285: #define COOKIE_LOGSTRING(lvl, fmt)   \
 7342:   PR_BEGIN_MACRO                     \
 7285:     PR_LOG(sCookieLog, lvl, fmt);    \
 7342:     PR_LOG(sCookieLog, lvl, ("\n")); \
 7342:   PR_END_MACRO
    1: 
    1: static void
    1: LogFailure(PRBool aSetCookie, nsIURI *aHostURI, const char *aCookieString, const char *aReason)
    1: {
    1:   // if logging isn't enabled, return now to save cycles
 2508:   if (!PR_LOG_TEST(sCookieLog, PR_LOG_WARNING))
    1:     return;
    1: 
    1:   nsCAutoString spec;
    1:   if (aHostURI)
    1:     aHostURI->GetAsciiSpec(spec);
    1: 
    1:   PR_LOG(sCookieLog, PR_LOG_WARNING,
 2508:     ("===== %s =====\n", aSetCookie ? "COOKIE NOT ACCEPTED" : "COOKIE NOT SENT"));
    1:   PR_LOG(sCookieLog, PR_LOG_WARNING,("request URL: %s\n", spec.get()));
 2508:   if (aSetCookie)
    1:     PR_LOG(sCookieLog, PR_LOG_WARNING,("cookie string: %s\n", aCookieString));
    1: 
    1:   PRExplodedTime explodedTime;
    1:   PR_ExplodeTime(PR_Now(), PR_GMTParameters, &explodedTime);
    1:   char timeString[40];
    1:   PR_FormatTimeUSEnglish(timeString, 40, "%c GMT", &explodedTime);
    1: 
    1:   PR_LOG(sCookieLog, PR_LOG_WARNING,("current time: %s", timeString));
    1:   PR_LOG(sCookieLog, PR_LOG_WARNING,("rejected because %s\n", aReason));
    1:   PR_LOG(sCookieLog, PR_LOG_WARNING,("\n"));
    1: }
    1: 
    1: static void
 7285: LogCookie(nsCookie *aCookie)
    1: {
    1:   PRExplodedTime explodedTime;
    1:   PR_ExplodeTime(PR_Now(), PR_GMTParameters, &explodedTime);
    1:   char timeString[40];
    1:   PR_FormatTimeUSEnglish(timeString, 40, "%c GMT", &explodedTime);
    1: 
    1:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("current time: %s", timeString));
    1: 
 7285:   if (aCookie) {
    1:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("----------------\n"));
    1:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("name: %s\n", aCookie->Name().get()));
    1:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("value: %s\n", aCookie->Value().get()));
    1:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("%s: %s\n", aCookie->IsDomain() ? "domain" : "host", aCookie->Host().get()));
    1:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("path: %s\n", aCookie->Path().get()));
    1: 
 2508:     PR_ExplodeTime(aCookie->Expiry() * PR_USEC_PER_SEC, PR_GMTParameters, &explodedTime);
    1:     PR_FormatTimeUSEnglish(timeString, 40, "%c GMT", &explodedTime);
 2508:     PR_LOG(sCookieLog, PR_LOG_DEBUG,
 2508:       ("expires: %s%s", timeString, aCookie->IsSession() ? " (at end of session)" : ""));
    1: 
 2508:     PR_ExplodeTime(aCookie->CreationID(), PR_GMTParameters, &explodedTime);
 2508:     PR_FormatTimeUSEnglish(timeString, 40, "%c GMT", &explodedTime);
    1:     PR_LOG(sCookieLog, PR_LOG_DEBUG,
 2508:       ("created: %s (id %lld)", timeString, aCookie->CreationID()));
 2508: 
    1:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("is secure: %s\n", aCookie->IsSecure() ? "true" : "false"));
 2508:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("is httpOnly: %s\n", aCookie->IsHttpOnly() ? "true" : "false"));
    1:   }
 7285: }
 7285: 
 7285: static void
 7285: LogSuccess(PRBool aSetCookie, nsIURI *aHostURI, const char *aCookieString, nsCookie *aCookie, PRBool aReplacing)
 7285: {
 7285:   // if logging isn't enabled, return now to save cycles
 7285:   if (!PR_LOG_TEST(sCookieLog, PR_LOG_DEBUG)) {
 7285:     return;
 7285:   }
 7285: 
 7285:   nsCAutoString spec;
 7285:   if (aHostURI)
 7285:     aHostURI->GetAsciiSpec(spec);
 7285: 
 7285:   PR_LOG(sCookieLog, PR_LOG_DEBUG,
 7285:     ("===== %s =====\n", aSetCookie ? "COOKIE ACCEPTED" : "COOKIE SENT"));
 7285:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("request URL: %s\n", spec.get()));
 7285:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("cookie string: %s\n", aCookieString));
 7285:   if (aSetCookie)
 7285:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("replaces existing cookie: %s\n", aReplacing ? "true" : "false"));
 7285: 
 7285:   LogCookie(aCookie);
 7285: 
 7285:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("\n"));
 7285: }
 7285: 
 7285: static void
 7285: LogEvicted(nsCookie *aCookie)
 7285: {
30480:   // if logging isn't enabled, return now to save cycles
30480:   if (!PR_LOG_TEST(sCookieLog, PR_LOG_DEBUG)) {
30480:     return;
30480:   }
30480: 
 7285:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("===== COOKIE EVICTED =====\n"));
 7285: 
 7285:   LogCookie(aCookie);
 7285: 
    1:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("\n"));
    1: }
    1: 
    1: // inline wrappers to make passing in nsAFlatCStrings easier
    1: static inline void
    1: LogFailure(PRBool aSetCookie, nsIURI *aHostURI, const nsAFlatCString &aCookieString, const char *aReason)
    1: {
    1:   LogFailure(aSetCookie, aHostURI, aCookieString.get(), aReason);
    1: }
    1: 
    1: static inline void
 7285: LogSuccess(PRBool aSetCookie, nsIURI *aHostURI, const nsAFlatCString &aCookieString, nsCookie *aCookie, PRBool aReplacing)
    1: {
 7285:   LogSuccess(aSetCookie, aHostURI, aCookieString.get(), aCookie, aReplacing);
    1: }
    1: 
    1: #else
 7342: #define COOKIE_LOGFAILURE(a, b, c, d)    PR_BEGIN_MACRO /* nothing */ PR_END_MACRO
 7342: #define COOKIE_LOGSUCCESS(a, b, c, d, e) PR_BEGIN_MACRO /* nothing */ PR_END_MACRO
 7342: #define COOKIE_LOGEVICTED(a)             PR_BEGIN_MACRO /* nothing */ PR_END_MACRO
 7342: #define COOKIE_LOGSTRING(a, b)           PR_BEGIN_MACRO /* nothing */ PR_END_MACRO
    1: #endif
    1: 
    1: /******************************************************************************
    1:  * nsCookieService impl:
    1:  * singleton instance ctor/dtor methods
    1:  ******************************************************************************/
    1: 
    1: nsCookieService *nsCookieService::gCookieService = nsnull;
    1: 
    1: nsCookieService*
    1: nsCookieService::GetSingleton()
    1: {
    1:   if (gCookieService) {
    1:     NS_ADDREF(gCookieService);
    1:     return gCookieService;
    1:   }
    1: 
    1:   // Create a new singleton nsCookieService.
    1:   // We AddRef only once since XPCOM has rules about the ordering of module
    1:   // teardowns - by the time our module destructor is called, it's too late to
    1:   // Release our members (e.g. nsIObserverService and nsIPrefBranch), since GC
    1:   // cycles have already been completed and would result in serious leaks.
    1:   // See bug 209571.
    1:   gCookieService = new nsCookieService();
    1:   if (gCookieService) {
    1:     NS_ADDREF(gCookieService);
    1:     if (NS_FAILED(gCookieService->Init())) {
    1:       NS_RELEASE(gCookieService);
    1:     }
    1:   }
    1: 
    1:   return gCookieService;
    1: }
    1: 
    1: /******************************************************************************
    1:  * nsCookieService impl:
    1:  * public methods
    1:  ******************************************************************************/
    1: 
 2796: NS_IMPL_ISUPPORTS5(nsCookieService,
    1:                    nsICookieService,
    1:                    nsICookieManager,
    1:                    nsICookieManager2,
    1:                    nsIObserver,
    1:                    nsISupportsWeakReference)
    1: 
    1: nsCookieService::nsCookieService()
33960:  : mDBState(&mDefaultDBState)
    1:  , mCookiesPermissions(BEHAVIOR_ACCEPT)
    1:  , mMaxNumberOfCookies(kMaxNumberOfCookies)
    1:  , mMaxCookiesPerHost(kMaxCookiesPerHost)
    1: {
    1: }
    1: 
    1: nsresult
    1: nsCookieService::Init()
    1: {
33960:   if (!mDBState->hostTable.Init()) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
 8702:   nsresult rv;
 8702:   mTLDService = do_GetService(NS_EFFECTIVETLDSERVICE_CONTRACTID, &rv);
 8702:   NS_ENSURE_SUCCESS(rv, rv);
 8702: 
    1:   // init our pref and observer
    1:   nsCOMPtr<nsIPrefBranch2> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:   if (prefBranch) {
    1:     prefBranch->AddObserver(kPrefCookiesPermissions, this, PR_TRUE);
    1:     prefBranch->AddObserver(kPrefMaxNumberOfCookies, this, PR_TRUE);
    1:     prefBranch->AddObserver(kPrefMaxCookiesPerHost,  this, PR_TRUE);
    1:     PrefChanged(prefBranch);
    1:   }
    1: 
24569:   // failure here is non-fatal (we can run fine without
 2508:   // persistent storage - e.g. if there's no profile)
 8702:   rv = InitDB();
 7285:   if (NS_FAILED(rv))
 7285:     COOKIE_LOGSTRING(PR_LOG_WARNING, ("Init(): InitDB() gave error %x", rv));
    1: 
    1:   mObserverService = do_GetService("@mozilla.org/observer-service;1");
    1:   if (mObserverService) {
    1:     mObserverService->AddObserver(this, "profile-before-change", PR_TRUE);
    1:     mObserverService->AddObserver(this, "profile-do-change", PR_TRUE);
20636:     mObserverService->AddObserver(this, NS_PRIVATE_BROWSING_SWITCH_TOPIC, PR_TRUE);
20636: 
20636:     nsCOMPtr<nsIPrivateBrowsingService> pbs =
20636:       do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
20636:     if (pbs) {
20636:       PRBool inPrivateBrowsing = PR_FALSE;
20636:       pbs->GetPrivateBrowsingEnabled(&inPrivateBrowsing);
20636:       if (inPrivateBrowsing) {
33960:         Observe(nsnull, NS_PRIVATE_BROWSING_SWITCH_TOPIC,
33960:                 NS_LITERAL_STRING(NS_PRIVATE_BROWSING_ENTER).get());
20636:       }
20636:     }
    1:   }
    1: 
    1:   mPermissionService = do_GetService(NS_COOKIEPERMISSION_CONTRACTID);
13137:   if (!mPermissionService) {
12921:     NS_WARNING("nsICookiePermission implementation not available - some features won't work!");
13137:     COOKIE_LOGSTRING(PR_LOG_WARNING, ("Init(): nsICookiePermission implementation not available"));
13137:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 2508: nsresult
33960: nsCookieService::InitDB()
 2508: {
33960:   NS_ASSERTION(mDBState == &mDefaultDBState, "not in default DB state");
33960: 
33960:   // attempt to open and read the database
33960:   nsresult rv = TryInitDB(PR_FALSE);
33960:   if (rv == NS_ERROR_FILE_CORRUPTED) {
33960:     // database is corrupt - delete and try again
33960:     COOKIE_LOGSTRING(PR_LOG_WARNING, ("InitDB(): db corrupt, trying again", rv));
33960: 
33960:     rv = TryInitDB(PR_TRUE);
33960:   }
33960: 
33960:   if (NS_FAILED(rv)) {
33960:     // reset our DB connection and statements
22579:     CloseDB();
33960:   }
33960:   return rv;
33960: }
33960: 
33960: nsresult
33960: nsCookieService::TryInitDB(PRBool aDeleteExistingDB)
33960: {
33960:   // null out any existing connection, and clear the cookie table
33960:   CloseDB();
33960:   RemoveAllFromMemory();
22579: 
 2508:   nsCOMPtr<nsIFile> cookieFile;
 9766:   nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, getter_AddRefs(cookieFile));
 9766:   if (NS_FAILED(rv)) return rv;
 2508: 
 2508:   cookieFile->AppendNative(NS_LITERAL_CSTRING(kCookieFileName));
 2508: 
24569:   // remove an existing db, if we've been told to (i.e. it's corrupt)
24569:   if (aDeleteExistingDB) {
24569:     rv = cookieFile->Remove(PR_FALSE);
24569:     NS_ENSURE_SUCCESS(rv, rv);
24569:   }
24569: 
 2508:   nsCOMPtr<mozIStorageService> storage = do_GetService("@mozilla.org/storage/service;1");
 2508:   if (!storage)
 2508:     return NS_ERROR_UNEXPECTED;
 2508: 
33960:   // open a connection to the cookie database, and only cache our connection
33960:   // and statements upon success.
33960:   rv = storage->OpenUnsharedDatabase(cookieFile, getter_AddRefs(mDBState->dbConn));
12382:   NS_ENSURE_SUCCESS(rv, rv);
12382: 
 2508:   PRBool tableExists = PR_FALSE;
33960:   mDBState->dbConn->TableExists(NS_LITERAL_CSTRING("moz_cookies"), &tableExists);
 2508:   if (!tableExists) {
 2508:       rv = CreateTable();
 2508:       NS_ENSURE_SUCCESS(rv, rv);
 2508: 
 2508:   } else {
 2508:     // table already exists; check the schema version before reading
 2508:     PRInt32 dbSchemaVersion;
33960:     rv = mDBState->dbConn->GetSchemaVersion(&dbSchemaVersion);
 2508:     NS_ENSURE_SUCCESS(rv, rv);
 2508: 
 8141:     switch (dbSchemaVersion) {
 8141:     // upgrading.
 8141:     // every time you increment the database schema, you need to implement
 8141:     // the upgrading code from the previous version to the new one.
 8141:     case 1:
 8141:       {
 8141:         // add the lastAccessed column to the table
33960:         rv = mDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
 8141:           "ALTER TABLE moz_cookies ADD lastAccessed INTEGER"));
 8141:         NS_ENSURE_SUCCESS(rv, rv);
 8141: 
 8141:         // update the schema version
33960:         rv = mDBState->dbConn->SetSchemaVersion(COOKIES_SCHEMA_VERSION);
 8141:         NS_ENSURE_SUCCESS(rv, rv);
 8141:       }
 8141:       // fall through to the next upgrade
 8141: 
 8141:     case COOKIES_SCHEMA_VERSION:
 8141:       break;
 8141: 
 8141:     case 0:
 8141:       {
 2508:         NS_WARNING("couldn't get schema version!");
 2508:           
 2508:         // the table may be usable; someone might've just clobbered the schema
 2508:         // version. we can treat this case like a downgrade using the codepath
 2508:         // below, by verifying the columns we care about are all there. for now,
 2508:         // re-set the schema version in the db, in case the checks succeed (if
 2508:         // they don't, we're dropping the table anyway).
33960:         rv = mDBState->dbConn->SetSchemaVersion(COOKIES_SCHEMA_VERSION);
 2508:         NS_ENSURE_SUCCESS(rv, rv);
 8141:       }
 8141:       // fall through to downgrade check
 8119: 
 2508:     // downgrading.
 2508:     // if columns have been added to the table, we can still use the ones we
 2508:     // understand safely. if columns have been deleted or altered, just
 2508:     // blow away the table and start from scratch! if you change the way
 2508:     // a column is interpreted, make sure you also change its name so this
 2508:     // check will catch it.
 8141:     default:
 8141:       {
 2508:         // check if all the expected columns exist
 2508:         nsCOMPtr<mozIStorageStatement> stmt;
33960:         rv = mDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
 2508:           "SELECT id, name, value, host, path, expiry, isSecure, isHttpOnly "
 2508:           "FROM moz_cookies"), getter_AddRefs(stmt));
 8141:         if (NS_SUCCEEDED(rv))
 8141:           break;
 2508: 
 2508:         // our columns aren't there - drop the table!
33960:         rv = mDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("DROP TABLE moz_cookies"));
 2508:         NS_ENSURE_SUCCESS(rv, rv);
 2508: 
 2508:         rv = CreateTable();
 2508:         NS_ENSURE_SUCCESS(rv, rv);
 2508:       }
 8141:       break;
 2508:     }
 2508:   }
 2508: 
 2508:   // make operations on the table asynchronous, for performance
33960:   mDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("PRAGMA synchronous = OFF"));
 2508: 
16979:   // open in exclusive mode for performance
33960:   mDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("PRAGMA locking_mode = EXCLUSIVE"));
16979: 
 2508:   // cache frequently used statements (for insertion, deletion, and updating)
33960:   rv = mDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
 2508:     "INSERT INTO moz_cookies "
 8141:     "(id, name, value, host, path, expiry, lastAccessed, isSecure, isHttpOnly) "
33960:     "VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"),
33960:     getter_AddRefs(mDBState->stmtInsert));
 2508:   NS_ENSURE_SUCCESS(rv, rv);
 2508: 
33960:   rv = mDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
33960:     "DELETE FROM moz_cookies WHERE id = ?1"),
33960:     getter_AddRefs(mDBState->stmtDelete));
 2508:   NS_ENSURE_SUCCESS(rv, rv);
 2508: 
33960:   rv = mDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
33960:     "UPDATE moz_cookies SET lastAccessed = ?1 WHERE id = ?2"),
33960:     getter_AddRefs(mDBState->stmtUpdate));
 8141:   NS_ENSURE_SUCCESS(rv, rv);
 8141: 
24569:   // if we deleted a corrupt db, don't attempt to import - return now
24569:   if (aDeleteExistingDB)
24569:     return NS_OK;
24569: 
 2508:   // check whether to import or just read in the db
 7848:   if (tableExists)
 7848:     return Read();
 2508: 
24569:   nsCOMPtr<nsIFile> oldCookieFile;
24569:   rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, getter_AddRefs(oldCookieFile));
 9766:   if (NS_FAILED(rv)) return rv;
 7848: 
24569:   oldCookieFile->AppendNative(NS_LITERAL_CSTRING(kOldCookieFileName));
24569:   rv = ImportCookies(oldCookieFile);
24569:   if (NS_FAILED(rv)) {
24569:     if (rv == NS_ERROR_FILE_NOT_FOUND)
24569:       return NS_OK;
24569: 
24569:     return rv;
24569:   }
 7848: 
 7848:   // we're done importing - delete the old cookie file
24569:   oldCookieFile->Remove(PR_FALSE);
 7848:   return NS_OK;
 2508: }
 2508: 
 2508: // sets the schema version and creates the moz_cookies table.
 2508: nsresult
 2508: nsCookieService::CreateTable()
 2508: {
 2508:   // set the schema version, before creating the table
33960:   nsresult rv = mDBState->dbConn->SetSchemaVersion(COOKIES_SCHEMA_VERSION);
 2508:   if (NS_FAILED(rv)) return rv;
 2508: 
 2508:   // create the table
33960:   return mDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
 2508:     "CREATE TABLE moz_cookies ("
 2508:     "id INTEGER PRIMARY KEY, name TEXT, value TEXT, host TEXT, path TEXT,"
 8141:     "expiry INTEGER, lastAccessed INTEGER, isSecure INTEGER, isHttpOnly INTEGER)"));
 2508: }
 2508: 
22579: void
22579: nsCookieService::CloseDB()
22579: {
33960:   NS_ASSERTION(!mPrivateDBState.dbConn, "private DB connection should always be null");
33960: 
33960:   // finalize our statements and close the db connection for the default state.
22579:   // since we own these objects, nulling the pointers is sufficient here.
33960:   mDefaultDBState.stmtInsert = nsnull;
33960:   mDefaultDBState.stmtDelete = nsnull;
33960:   mDefaultDBState.stmtUpdate = nsnull;
33960:   mDefaultDBState.dbConn = nsnull;
22579: }
22579: 
    1: nsCookieService::~nsCookieService()
    1: {
22579:   CloseDB();
22579: 
    1:   gCookieService = nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCookieService::Observe(nsISupports     *aSubject,
    1:                          const char      *aTopic,
    1:                          const PRUnichar *aData)
    1: {
    1:   // check the topic
 2508:   if (!strcmp(aTopic, "profile-before-change")) {
    1:     // The profile is about to change,
    1:     // or is going away because the application is shutting down.
 2508:     RemoveAllFromMemory();
 2508: 
33960:     if (mDBState->dbConn) {
19225:       if (!nsCRT::strcmp(aData, NS_LITERAL_STRING("shutdown-cleanse").get())) {
 2508:         // clear the cookie file
33960:         nsresult rv = mDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("DELETE FROM moz_cookies"));
 2508:         if (NS_FAILED(rv))
 2508:           NS_WARNING("db delete failed");
    1:       }
    1: 
16572:       // Close the DB connection before changing
22579:       CloseDB();
19225:     }
16572: 
 2508:   } else if (!strcmp(aTopic, "profile-do-change")) {
33960:     // the profile has already changed; init the db from the new location.
33960:     // if we are in the private browsing state, however, we do not want to read
33960:     // data into it - we should instead put it into the default state, so it's
33960:     // ready for us if and when we switch back to it.
33960:     if (mDBState == &mPrivateDBState) {
33960:       mDBState = &mDefaultDBState;
 2508:       InitDB();
33960:       mDBState = &mPrivateDBState;
33960:     } else {
33960:       InitDB();
33960:     }
    1: 
 2508:   } else if (!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
    1:     nsCOMPtr<nsIPrefBranch> prefBranch = do_QueryInterface(aSubject);
    1:     if (prefBranch)
    1:       PrefChanged(prefBranch);
20636:   } else if (!strcmp(aTopic, NS_PRIVATE_BROWSING_SWITCH_TOPIC)) {
20636:     if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_ENTER).Equals(aData)) {
33960:       if (!mPrivateDBState.hostTable.IsInitialized() &&
33960:           !mPrivateDBState.hostTable.Init())
33960:         return NS_ERROR_OUT_OF_MEMORY;
33960: 
33960:       NS_ASSERTION(mDBState == &mPrivateDBState, "already in private state");
33960:       NS_ASSERTION(mPrivateDBState.cookieCount == 0, "private count not 0");
33960:       NS_ASSERTION(mPrivateDBState.hostTable.Count() == 0, "private table not empty");
33960:       NS_ASSERTION(!mPrivateDBState.dbConn, "private DB connection not null");
33960: 
33960:       // swap the private and default states
33960:       mDBState = &mPrivateDBState;
33960: 
20690:       NotifyChanged(nsnull, NS_LITERAL_STRING("reload").get());
33960: 
20636:     } else if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_LEAVE).Equals(aData)) {
33960:       // restore the default state, and clear the private one
33960:       mDBState = &mDefaultDBState;
33960: 
33960:       NS_ASSERTION(!mPrivateDBState.dbConn, "private DB connection not null");
33960: 
33960:       mPrivateDBState.cookieCount = 0;
33960:       if (mPrivateDBState.hostTable.IsInitialized())
33960:         mPrivateDBState.hostTable.Clear();
33960: 
20636:       NotifyChanged(nsnull, NS_LITERAL_STRING("reload").get());
20636:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCookieService::GetCookieString(nsIURI     *aHostURI,
    1:                                  nsIChannel *aChannel,
    1:                                  char       **aCookie)
    1: {
12921:   GetCookieInternal(aHostURI, aChannel, PR_FALSE, aCookie);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCookieService::GetCookieStringFromHttp(nsIURI     *aHostURI,
    1:                                          nsIURI     *aFirstURI,
    1:                                          nsIChannel *aChannel,
    1:                                          char       **aCookie)
    1: {
12921:   GetCookieInternal(aHostURI, aChannel, PR_TRUE, aCookie);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCookieService::SetCookieString(nsIURI     *aHostURI,
    1:                                  nsIPrompt  *aPrompt,
    1:                                  const char *aCookieHeader,
    1:                                  nsIChannel *aChannel)
    1: {
12921:   return SetCookieStringInternal(aHostURI, aPrompt, aCookieHeader, nsnull, aChannel, PR_FALSE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCookieService::SetCookieStringFromHttp(nsIURI     *aHostURI,
    1:                                          nsIURI     *aFirstURI,
    1:                                          nsIPrompt  *aPrompt,
    1:                                          const char *aCookieHeader,
    1:                                          const char *aServerTime,
    1:                                          nsIChannel *aChannel) 
    1: {
12921:   return SetCookieStringInternal(aHostURI, aPrompt, aCookieHeader, aServerTime, aChannel, PR_TRUE);
 2793: }
 2793: 
 2793: nsresult
 2793: nsCookieService::SetCookieStringInternal(nsIURI     *aHostURI,
 2793:                                          nsIPrompt  *aPrompt,
 2793:                                          const char *aCookieHeader,
 2793:                                          const char *aServerTime,
 2793:                                          nsIChannel *aChannel,
 2793:                                          PRBool      aFromHttp) 
 2793: {
    1:   if (!aHostURI) {
    1:     COOKIE_LOGFAILURE(SET_COOKIE, nsnull, aCookieHeader, "host URI is null");
    1:     return NS_OK;
    1:   }
    1: 
    1:   // check default prefs
12921:   PRUint32 cookieStatus = CheckPrefs(aHostURI, aChannel, aCookieHeader);
    1:   // fire a notification if cookie was rejected (but not if there was an error)
    1:   switch (cookieStatus) {
 2626:   case STATUS_REJECTED:
    1:     NotifyRejected(aHostURI);
    1:   case STATUS_REJECTED_WITH_ERROR:
    1:     return NS_OK;
    1:   }
    1: 
    1:   // parse server local time. this is not just done here for efficiency
    1:   // reasons - if there's an error parsing it, and we need to default it
    1:   // to the current time, we must do it here since the current time in
    1:   // SetCookieInternal() will change for each cookie processed (e.g. if the
    1:   // user is prompted).
    1:   PRTime tempServerTime;
 2508:   PRInt64 serverTime;
    1:   if (aServerTime && PR_ParseTimeString(aServerTime, PR_TRUE, &tempServerTime) == PR_SUCCESS) {
 2508:     serverTime = tempServerTime / PR_USEC_PER_SEC;
    1:   } else {
 2508:     serverTime = PR_Now() / PR_USEC_PER_SEC;
    1:   }
    1: 
 2508:   // start a transaction on the storage db, to optimize insertions.
 2508:   // transaction will automically commit on completion
33960:   mozStorageTransaction transaction(mDBState->dbConn, PR_TRUE);
 2508:  
    1:   // switch to a nice string type now, and process each cookie in the header
    1:   nsDependentCString cookieHeader(aCookieHeader);
 2793:   while (SetCookieInternal(aHostURI, aChannel, cookieHeader, serverTime, aFromHttp));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // notify observers that a cookie was rejected due to the users' prefs.
    1: void
    1: nsCookieService::NotifyRejected(nsIURI *aHostURI)
    1: {
    1:   if (mObserverService)
    1:     mObserverService->NotifyObservers(aHostURI, "cookie-rejected", nsnull);
    1: }
    1: 
30480: // notify observers that the cookie list changed. there are four possible
    1: // values for aData:
30480: // "deleted" means a cookie was deleted. aCookie is the deleted cookie.
30480: // "added"   means a cookie was added. aCookie is the added cookie.
30480: // "changed" means a cookie was altered. aCookie is the new cookie.
30480: // "cleared" means the entire cookie list was cleared. aCookie is null.
    1: void
30480: nsCookieService::NotifyChanged(nsICookie2      *aCookie,
    1:                                const PRUnichar *aData)
    1: {
    1:   if (mObserverService)
30480:     mObserverService->NotifyObservers(aCookie, "cookie-changed", aData);
    1: }
    1: 
    1: /******************************************************************************
    1:  * nsCookieService:
    1:  * pref observer impl
    1:  ******************************************************************************/
    1: 
    1: void
    1: nsCookieService::PrefChanged(nsIPrefBranch *aPrefBranch)
    1: {
    1:   PRInt32 val;
    1:   if (NS_SUCCEEDED(aPrefBranch->GetIntPref(kPrefCookiesPermissions, &val)))
12287:     mCookiesPermissions = (PRUint8) LIMIT(val, 0, 2, 0);
    1: 
    1:   if (NS_SUCCEEDED(aPrefBranch->GetIntPref(kPrefMaxNumberOfCookies, &val)))
12287:     mMaxNumberOfCookies = (PRUint16) LIMIT(val, 0, 0xFFFF, 0xFFFF);
    1: 
    1:   if (NS_SUCCEEDED(aPrefBranch->GetIntPref(kPrefMaxCookiesPerHost, &val)))
12287:     mMaxCookiesPerHost = (PRUint16) LIMIT(val, 0, 0xFFFF, 0xFFFF);
    1: }
    1: 
    1: /******************************************************************************
    1:  * nsICookieManager impl:
    1:  * nsICookieManager
    1:  ******************************************************************************/
    1: 
    1: NS_IMETHODIMP
    1: nsCookieService::RemoveAll()
    1: {
    1:   RemoveAllFromMemory();
 2508: 
 2508:   // clear the cookie file
33960:   if (mDBState->dbConn) {
33960:     NS_ASSERTION(mDBState == &mDefaultDBState, "not in default DB state");
33960: 
33960:     nsresult rv = mDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("DELETE FROM moz_cookies"));
17099:     if (NS_FAILED(rv)) {
17099:       // Database must be corrupted, so remove it completely.
17099:       nsCOMPtr<nsIFile> dbFile;
33960:       mDBState->dbConn->GetDatabaseFile(getter_AddRefs(dbFile));
22579:       CloseDB();
17099:       dbFile->Remove(PR_FALSE);
22579: 
17099:       InitDB();
17099:     }
 2508:   }
 2508: 
17099:   NotifyChanged(nsnull, NS_LITERAL_STRING("cleared").get());
    1:   return NS_OK;
    1: }
    1: 
12774: // helper struct for passing arguments into hash enumeration callback.
12774: struct nsGetEnumeratorData
12774: {
12774:   nsGetEnumeratorData(nsCOMArray<nsICookie> *aArray, PRInt64 aTime)
12774:    : array(aArray)
12774:    , currentTime(aTime) {}
12774: 
12774:   nsCOMArray<nsICookie> *array;
12774:   PRInt64 currentTime;
12774: };
12774: 
20261: static PLDHashOperator
    1: COMArrayCallback(nsCookieEntry *aEntry,
    1:                  void          *aArg)
    1: {
12774:   nsGetEnumeratorData *data = static_cast<nsGetEnumeratorData *>(aArg);
12774: 
    1:   for (nsCookie *cookie = aEntry->Head(); cookie; cookie = cookie->Next()) {
12774:     // only append non-expired cookies
12774:     if (cookie->Expiry() > data->currentTime)
12774:       data->array->AppendObject(cookie);
    1:   }
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCookieService::GetEnumerator(nsISimpleEnumerator **aEnumerator)
    1: {
33960:   nsCOMArray<nsICookie> cookieList(mDBState->cookieCount);
12774:   nsGetEnumeratorData data(&cookieList, PR_Now() / PR_USEC_PER_SEC);
    1: 
33960:   mDBState->hostTable.EnumerateEntries(COMArrayCallback, &data);
    1: 
    1:   return NS_NewArrayEnumerator(aEnumerator, cookieList);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCookieService::Add(const nsACString &aDomain,
    1:                      const nsACString &aPath,
    1:                      const nsACString &aName,
    1:                      const nsACString &aValue,
    1:                      PRBool            aIsSecure,
 2510:                      PRBool            aIsHttpOnly,
    1:                      PRBool            aIsSession,
    1:                      PRInt64           aExpiry)
    1: {
 2508:   PRInt64 currentTimeInUsec = PR_Now();
    1: 
    1:   nsRefPtr<nsCookie> cookie =
    1:     nsCookie::Create(aName, aValue, aDomain, aPath,
 2508:                      aExpiry,
 2508:                      currentTimeInUsec,
 8141:                      currentTimeInUsec,
    1:                      aIsSession,
    1:                      aIsSecure,
 2626:                      aIsHttpOnly);
    1:   if (!cookie) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
30480:   AddInternal(cookie, currentTimeInUsec / PR_USEC_PER_SEC, nsnull, nsnull, PR_TRUE);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCookieService::Remove(const nsACString &aHost,
    1:                         const nsACString &aName,
    1:                         const nsACString &aPath,
    1:                         PRBool           aBlocked)
    1: {
    1:   nsListIter matchIter;
    1:   if (FindCookie(PromiseFlatCString(aHost),
    1:                  PromiseFlatCString(aName),
    1:                  PromiseFlatCString(aPath),
14075:                  matchIter,
14075:                  PR_Now() / PR_USEC_PER_SEC)) {
    1:     nsRefPtr<nsCookie> cookie = matchIter.current;
    1:     RemoveCookieFromList(matchIter);
    1:     NotifyChanged(cookie, NS_LITERAL_STRING("deleted").get());
14075:   }
    1: 
    1:   // check if we need to add the host to the permissions blacklist.
    1:   if (aBlocked && mPermissionService) {
14075:     nsCAutoString host(NS_LITERAL_CSTRING("http://"));
14075:     
14075:     // strip off the domain dot, if necessary
14075:     if (!aHost.IsEmpty() && aHost.First() == '.')
14075:       host.Append(Substring(aHost, 1, aHost.Length() - 1));
14075:     else
14075:       host.Append(aHost);
14075: 
    1:     nsCOMPtr<nsIURI> uri;
    1:     NS_NewURI(getter_AddRefs(uri), host);
    1: 
    1:     if (uri)
    1:       mPermissionService->SetAccess(uri, nsICookiePermission::ACCESS_DENY);
    1:   }
14075: 
    1:   return NS_OK;
    1: }
    1: 
    1: /******************************************************************************
    1:  * nsCookieService impl:
    1:  * private file I/O functions
    1:  ******************************************************************************/
    1: 
    1: nsresult
    1: nsCookieService::Read()
    1: {
    1:   nsresult rv;
 2508: 
 2508:   // delete expired cookies, before we read in the db
 2508:   {
 2508:     // scope the deletion, so the write lock is released when finished
 2508:     nsCOMPtr<mozIStorageStatement> stmtDeleteExpired;
33960:     rv = mDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
33960:       "DELETE FROM moz_cookies WHERE expiry <= ?1"),
 2508:       getter_AddRefs(stmtDeleteExpired));
 2508:     NS_ENSURE_SUCCESS(rv, rv);
 2508: 
 2508:     rv = stmtDeleteExpired->BindInt64Parameter(0, PR_Now() / PR_USEC_PER_SEC);
 2508:     NS_ENSURE_SUCCESS(rv, rv);
 2508: 
 2508:     PRBool hasResult;
 2508:     rv = stmtDeleteExpired->ExecuteStep(&hasResult);
 2508:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
 2508:   // let the reading begin!
 2508:   nsCOMPtr<mozIStorageStatement> stmt;
33960:   rv = mDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
 8141:     "SELECT id, name, value, host, path, expiry, lastAccessed, isSecure, isHttpOnly "
 2508:     "FROM moz_cookies"), getter_AddRefs(stmt));
 2508:   NS_ENSURE_SUCCESS(rv, rv);
 2508: 
 2508:   nsCAutoString name, value, host, path;
 2508:   PRBool hasResult;
24569:   while (NS_SUCCEEDED(rv = stmt->ExecuteStep(&hasResult)) && hasResult) {
 2508:     PRInt64 creationID = stmt->AsInt64(0);
 2508:     
 2508:     stmt->GetUTF8String(1, name);
 2508:     stmt->GetUTF8String(2, value);
 2508:     stmt->GetUTF8String(3, host);
 2508:     stmt->GetUTF8String(4, path);
 2508: 
 2508:     PRInt64 expiry = stmt->AsInt64(5);
 8141:     PRInt64 lastAccessed = stmt->AsInt64(6);
12048:     PRBool isSecure = 0 != stmt->AsInt32(7);
12048:     PRBool isHttpOnly = 0 != stmt->AsInt32(8);
 2508: 
 2508:     // create a new nsCookie and assign the data.
 2508:     nsCookie* newCookie =
 2508:       nsCookie::Create(name, value, host, path,
 2508:                        expiry,
 8141:                        lastAccessed,
 2508:                        creationID,
 2508:                        PR_FALSE,
 2508:                        isSecure,
 2626:                        isHttpOnly);
 2508:     if (!newCookie)
 2508:       return NS_ERROR_OUT_OF_MEMORY;
 2508: 
 2508:     if (!AddCookieToList(newCookie, PR_FALSE))
 2508:       // It is purpose that created us; purpose that connects us;
 2508:       // purpose that pulls us; that guides us; that drives us.
 2508:       // It is purpose that defines us; purpose that binds us.
 2508:       // When a cookie no longer has purpose, it has a choice:
 2508:       // it can return to the source to be deleted, or it can go
 2508:       // into exile, and stay hidden inside the Matrix.
 2508:       // Let's choose deletion.
 2508:       delete newCookie;
 2508:   }
 2508: 
33960:   COOKIE_LOGSTRING(PR_LOG_DEBUG, ("Read(): %ld cookies read", mDBState->cookieCount));
 7285: 
24569:   return rv;
 2508: }
 2508: 
 7848: NS_IMETHODIMP
 7848: nsCookieService::ImportCookies(nsIFile *aCookieFile)
 2508: {
 2508:   nsresult rv;
 2508:   nsCOMPtr<nsIInputStream> fileInputStream;
 7848:   rv = NS_NewLocalFileInputStream(getter_AddRefs(fileInputStream), aCookieFile);
 2508:   if (NS_FAILED(rv)) return rv;
 2508: 
    1:   nsCOMPtr<nsILineInputStream> lineInputStream = do_QueryInterface(fileInputStream, &rv);
 2508:   if (NS_FAILED(rv)) return rv;
 2508: 
 2508:   // start a transaction on the storage db, to optimize insertions.
 2508:   // transaction will automically commit on completion
33960:   mozStorageTransaction transaction(mDBState->dbConn, PR_TRUE);
    1: 
    1:   static const char kTrue[] = "TRUE";
    1: 
    1:   nsCAutoString buffer;
    1:   PRBool isMore = PR_TRUE;
    1:   PRInt32 hostIndex, isDomainIndex, pathIndex, secureIndex, expiresIndex, nameIndex, cookieIndex;
    1:   nsASingleFragmentCString::char_iterator iter;
    1:   PRInt32 numInts;
    1:   PRInt64 expires;
    1:   PRBool isDomain, isHttpOnly = PR_FALSE;
33960:   PRUint32 originalCookieCount = mDBState->cookieCount;
    1: 
 8141:   PRInt64 currentTimeInUsec = PR_Now();
 8141:   PRInt64 currentTime = currentTimeInUsec / PR_USEC_PER_SEC;
 8141:   // we use lastAccessedCounter to keep cookies in recently-used order,
 8141:   // so we start by initializing to currentTime (somewhat arbitrary)
 8141:   PRInt64 lastAccessedCounter = currentTimeInUsec;
 2508: 
    1:   /* file format is:
    1:    *
    1:    * host \t isDomain \t path \t secure \t expires \t name \t cookie
    1:    *
    1:    * if this format isn't respected we move onto the next line in the file.
    1:    * isDomain is "TRUE" or "FALSE" (default to "FALSE")
    1:    * isSecure is "TRUE" or "FALSE" (default to "TRUE")
    1:    * expires is a PRInt64 integer
 8141:    * note 1: cookie can contain tabs.
 8141:    * note 2: cookies will be stored in order of lastAccessed time:
 8141:    *         most-recently used come first; least-recently-used come last.
    1:    */
    1: 
    1:   /*
    1:    * ...but due to bug 178933, we hide HttpOnly cookies from older code
    1:    * in a comment, so they don't expose HttpOnly cookies to JS.
    1:    *
    1:    * The format for HttpOnly cookies is
    1:    *
    1:    * #HttpOnly_host \t isDomain \t path \t secure \t expires \t name \t cookie
    1:    *
    1:    */
    1: 
    1:   while (isMore && NS_SUCCEEDED(lineInputStream->ReadLine(buffer, &isMore))) {
    1:     if (StringBeginsWith(buffer, NS_LITERAL_CSTRING(kHttpOnlyPrefix))) {
    1:       isHttpOnly = PR_TRUE;
    1:       hostIndex = sizeof(kHttpOnlyPrefix) - 1;
    1:     } else if (buffer.IsEmpty() || buffer.First() == '#') {
    1:       continue;
    1:     } else {
    1:       isHttpOnly = PR_FALSE;
    1:       hostIndex = 0;
    1:     }
    1: 
    1:     // this is a cheap, cheesy way of parsing a tab-delimited line into
    1:     // string indexes, which can be lopped off into substrings. just for
    1:     // purposes of obfuscation, it also checks that each token was found.
    1:     // todo: use iterators?
    1:     if ((isDomainIndex = buffer.FindChar('\t', hostIndex)     + 1) == 0 ||
    1:         (pathIndex     = buffer.FindChar('\t', isDomainIndex) + 1) == 0 ||
    1:         (secureIndex   = buffer.FindChar('\t', pathIndex)     + 1) == 0 ||
    1:         (expiresIndex  = buffer.FindChar('\t', secureIndex)   + 1) == 0 ||
    1:         (nameIndex     = buffer.FindChar('\t', expiresIndex)  + 1) == 0 ||
    1:         (cookieIndex   = buffer.FindChar('\t', nameIndex)     + 1) == 0) {
    1:       continue;
    1:     }
    1: 
    1:     // check the expirytime first - if it's expired, ignore
    1:     // nullstomp the trailing tab, to avoid copying the string
    1:     buffer.BeginWriting(iter);
    1:     *(iter += nameIndex - 1) = char(0);
    1:     numInts = PR_sscanf(buffer.get() + expiresIndex, "%lld", &expires);
 2508:     if (numInts != 1 || expires < currentTime) {
    1:       continue;
    1:     }
    1: 
 2508:     isDomain = Substring(buffer, isDomainIndex, pathIndex - isDomainIndex - 1).EqualsLiteral(kTrue);
    1:     const nsASingleFragmentCString &host = Substring(buffer, hostIndex, isDomainIndex - hostIndex - 1);
    1:     // check for bad legacy cookies (domain not starting with a dot, or containing a port),
    1:     // and discard
11171:     if ((isDomain && !host.IsEmpty() && host.First() != '.') ||
    1:         host.FindChar(':') != kNotFound) {
    1:       continue;
    1:     }
    1: 
    1:     // create a new nsCookie and assign the data.
 8141:     // we don't know the cookie creation time, so just use the current time;
 8141:     // this is okay, since nsCookie::Create() will make sure the creation id
 8141:     // ends up monotonically increasing.
 7848:     nsRefPtr<nsCookie> newCookie =
    1:       nsCookie::Create(Substring(buffer, nameIndex, cookieIndex - nameIndex - 1),
    1:                        Substring(buffer, cookieIndex, buffer.Length() - cookieIndex),
    1:                        host,
    1:                        Substring(buffer, pathIndex, secureIndex - pathIndex - 1),
 2508:                        expires,
 8141:                        lastAccessedCounter,
 8141:                        currentTimeInUsec,
    1:                        PR_FALSE,
  153:                        Substring(buffer, secureIndex, expiresIndex - secureIndex - 1).EqualsLiteral(kTrue),
 2626:                        isHttpOnly);
    1:     if (!newCookie) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     
 8141:     // trick: preserve the most-recently-used cookie ordering,
 8141:     // by successively decrementing the lastAccessed time
 8141:     lastAccessedCounter--;
    1: 
 7848:     if (originalCookieCount == 0)
 7848:       AddCookieToList(newCookie);
 7848:     else
30480:       AddInternal(newCookie, currentTime, nsnull, nsnull, PR_TRUE);
    1:   }
    1: 
33960:   COOKIE_LOGSTRING(PR_LOG_DEBUG, ("ImportCookies(): %ld cookies imported", mDBState->cookieCount));
 7285: 
    1:   return NS_OK;
    1: }
    1: 
    1: /******************************************************************************
    1:  * nsCookieService impl:
    1:  * private GetCookie/SetCookie helpers
    1:  ******************************************************************************/
    1: 
 2796: // helper function for GetCookieList
 2796: static inline PRBool ispathdelimiter(char c) { return c == '/' || c == '?' || c == '#' || c == ';'; }
 2796: 
25383: // Comparator class for sorting cookies before sending to a server.
25383: class CompareCookiesForSendingComparator
25383: {
25383:   public:
25383:   PRBool Equals(const nsCookie* aCookie1, const nsCookie* aCookie2) const {
25383:     return PR_FALSE; // CreationID is unique, so two id's can never be equal.
25383:   }
25383:   PRBool LessThan(const nsCookie* aCookie1, const nsCookie* aCookie2) const {
25383:     // compare by cookie path length in accordance with RFC2109
25383:     int rv = aCookie2->Path().Length() - aCookie1->Path().Length();
25383:     if (rv == 0) {
25383:       // when path lengths match, older cookies should be listed first.  this is
25383:       // required for backwards compatibility since some websites erroneously
25383:       // depend on receiving cookies in the order in which they were sent to the
25383:       // browser!  see bug 236772.
25383:       // note: CreationID is unique, so two id's can never be equal.
25383:       // we may have overflow problems returning the result directly, so we need branches
25383:       rv = (aCookie1->CreationID() > aCookie2->CreationID() ? 1 : -1);
25383:     }
25383:     return rv < 0;
25383:   }
25383: };
25383: 
 2796: void
 2796: nsCookieService::GetCookieInternal(nsIURI      *aHostURI,
 2796:                                    nsIChannel  *aChannel,
 2796:                                    PRBool       aHttpBound,
 2796:                                    char       **aCookie)
 2796: {
 2796:   *aCookie = nsnull;
 2796: 
 2796:   if (!aHostURI) {
 2796:     COOKIE_LOGFAILURE(GET_COOKIE, nsnull, nsnull, "host URI is null");
 2796:     return;
 2796:   }
 2796: 
 2796:   // check default prefs
12921:   PRUint32 cookieStatus = CheckPrefs(aHostURI, aChannel, nsnull);
 2796:   // for GetCookie(), we don't fire rejection notifications.
 2796:   switch (cookieStatus) {
 2796:   case STATUS_REJECTED:
 2796:   case STATUS_REJECTED_WITH_ERROR:
 2796:     return;
 2796:   }
 2796: 
 2796:   // get host and path from the nsIURI
 2796:   // note: there was a "check if host has embedded whitespace" here.
 2796:   // it was removed since this check was added into the nsIURI impl (bug 146094).
 2796:   nsCAutoString hostFromURI, pathFromURI;
 2796:   if (NS_FAILED(aHostURI->GetAsciiHost(hostFromURI)) ||
 2796:       NS_FAILED(aHostURI->GetPath(pathFromURI))) {
 2796:     COOKIE_LOGFAILURE(GET_COOKIE, aHostURI, nsnull, "couldn't get host/path from URI");
 2796:     return;
 2796:   }
 2796:   // trim trailing dots
 2796:   hostFromURI.Trim(".");
 2796:   // insert a leading dot, so we begin the hash lookup with the
 2796:   // equivalent domain cookie host
 2796:   hostFromURI.Insert(NS_LITERAL_CSTRING("."), 0);
 2796: 
 2796:   // check if aHostURI is using an https secure protocol.
 2796:   // if it isn't, then we can't send a secure cookie over the connection.
 2796:   // if SchemeIs fails, assume an insecure connection, to be on the safe side
 2796:   PRBool isSecure;
 2796:   if (NS_FAILED(aHostURI->SchemeIs("https", &isSecure))) {
 2796:     isSecure = PR_FALSE;
 2796:   }
 2796: 
 2796:   nsCookie *cookie;
25383:   nsAutoTArray<nsCookie*, 8> foundCookieList;
 8141:   PRInt64 currentTimeInUsec = PR_Now();
 8141:   PRInt64 currentTime = currentTimeInUsec / PR_USEC_PER_SEC;
 2796:   const char *currentDot = hostFromURI.get();
 2796:   const char *nextDot = currentDot + 1;
 8141:   PRBool stale = PR_FALSE;
 2796: 
 2796:   // begin hash lookup, walking up the subdomain levels.
 2796:   // we use nextDot to force a lookup of the original host (without leading dot).
 2796:   do {
33960:     nsCookieEntry *entry = mDBState->hostTable.GetEntry(currentDot);
 2796:     cookie = entry ? entry->Head() : nsnull;
 2796:     for (; cookie; cookie = cookie->Next()) {
 2796:       // if the cookie is secure and the host scheme isn't, we can't send it
 2796:       if (cookie->IsSecure() && !isSecure) {
 2796:         continue;
 2796:       }
 2796: 
 2796:       // if the cookie is httpOnly and it's not going directly to the HTTP
 2796:       // connection, don't send it
 2796:       if (cookie->IsHttpOnly() && !aHttpBound) {
 2796:         continue;
 2796:       }
 2796: 
 2796:       // calculate cookie path length, excluding trailing '/'
 2796:       PRUint32 cookiePathLen = cookie->Path().Length();
 2796:       if (cookiePathLen > 0 && cookie->Path().Last() == '/') {
 2796:         --cookiePathLen;
 2796:       }
 2796: 
 2796:       // if the nsIURI path is shorter than the cookie path, don't send it back
 2796:       if (!StringBeginsWith(pathFromURI, Substring(cookie->Path(), 0, cookiePathLen))) {
 2796:         continue;
 2796:       }
 2796: 
 2796:       if (pathFromURI.Length() > cookiePathLen &&
 2796:           !ispathdelimiter(pathFromURI.CharAt(cookiePathLen))) {
 2796:         /*
 2796:          * |ispathdelimiter| tests four cases: '/', '?', '#', and ';'.
 2796:          * '/' is the "standard" case; the '?' test allows a site at host/abc?def
 2796:          * to receive a cookie that has a path attribute of abc.  this seems
 2796:          * strange but at least one major site (citibank, bug 156725) depends
 2796:          * on it.  The test for # and ; are put in to proactively avoid problems
 2796:          * with other sites - these are the only other chars allowed in the path.
 2796:          */
 2796:         continue;
 2796:       }
 2796: 
 2796:       // check if the cookie has expired
 2796:       if (cookie->Expiry() <= currentTime) {
 2796:         continue;
 2796:       }
 2796: 
 8141:       // all checks passed - add to list and check if lastAccessed stamp needs updating
 2796:       foundCookieList.AppendElement(cookie);
 8141:       if (currentTimeInUsec - cookie->LastAccessed() > kCookieStaleThreshold)
 8141:         stale = PR_TRUE;
 2796:     }
 2796: 
 2796:     currentDot = nextDot;
 2796:     if (currentDot)
 2796:       nextDot = strchr(currentDot + 1, '.');
 2796: 
 2796:   } while (currentDot);
 2796: 
25383:   PRInt32 count = foundCookieList.Length();
 8141:   if (count == 0)
 8141:     return;
 8141: 
 8141:   // update lastAccessed timestamps. we only do this if the timestamp is stale
 8141:   // by a certain amount, to avoid thrashing the db during pageload.
 8141:   if (stale) {
 8141:     // start a transaction on the storage db, to optimize updates.
 8141:     // transaction will automically commit on completion.
33960:     mozStorageTransaction transaction(mDBState->dbConn, PR_TRUE);
 8141: 
 8141:     for (PRInt32 i = 0; i < count; ++i) {
25383:       cookie = foundCookieList.ElementAt(i);
 8141: 
 8141:       if (currentTimeInUsec - cookie->LastAccessed() > kCookieStaleThreshold)
 8141:         UpdateCookieInList(cookie, currentTimeInUsec);
 8141:     }
 8141:   }
 8141: 
 2796:   // return cookies in order of path length; longest to shortest.
 2796:   // this is required per RFC2109.  if cookies match in length,
 2796:   // then sort by creation time (see bug 236772).
25383:   foundCookieList.Sort(CompareCookiesForSendingComparator());
 2796: 
 2796:   nsCAutoString cookieData;
 2796:   for (PRInt32 i = 0; i < count; ++i) {
25383:     cookie = foundCookieList.ElementAt(i);
 2796: 
 2796:     // check if we have anything to write
 2796:     if (!cookie->Name().IsEmpty() || !cookie->Value().IsEmpty()) {
 2796:       // if we've already added a cookie to the return list, append a "; " so
 2796:       // that subsequent cookies are delimited in the final list.
 2796:       if (!cookieData.IsEmpty()) {
 2796:         cookieData.AppendLiteral("; ");
 2796:       }
 2796: 
 2796:       if (!cookie->Name().IsEmpty()) {
 2796:         // we have a name and value - write both
 2796:         cookieData += cookie->Name() + NS_LITERAL_CSTRING("=") + cookie->Value();
 2796:       } else {
 2796:         // just write value
 2796:         cookieData += cookie->Value();
 2796:       }
 2796:     }
 2796:   }
 2796: 
 2796:   // it's wasteful to alloc a new string; but we have no other choice, until we
 2796:   // fix the callers to use nsACStrings.
 2796:   if (!cookieData.IsEmpty()) {
 7285:     COOKIE_LOGSUCCESS(GET_COOKIE, aHostURI, cookieData, nsnull, nsnull);
 2796:     *aCookie = ToNewCString(cookieData);
 2796:   }
 2796: }
 2796: 
    1: // processes a single cookie, and returns PR_TRUE if there are more cookies
    1: // to be processed
    1: PRBool
    1: nsCookieService::SetCookieInternal(nsIURI             *aHostURI,
    1:                                    nsIChannel         *aChannel,
    1:                                    nsDependentCString &aCookieHeader,
 2793:                                    PRInt64             aServerTime,
 2793:                                    PRBool              aFromHttp)
    1: {
    1:   // create a stack-based nsCookieAttributes, to store all the
    1:   // attributes parsed from the cookie
    1:   nsCookieAttributes cookieAttributes;
    1: 
    1:   // init expiryTime such that session cookies won't prematurely expire
    1:   cookieAttributes.expiryTime = LL_MAXINT;
    1: 
    1:   // aCookieHeader is an in/out param to point to the next cookie, if
 2796:   // there is one. Save the present value for logging purposes
    1:   nsDependentCString savedCookieHeader(aCookieHeader);
    1: 
    1:   // newCookie says whether there are multiple cookies in the header;
    1:   // so we can handle them separately.
 2508:   PRBool newCookie = ParseAttributes(aCookieHeader, cookieAttributes);
 2508: 
 2508:   PRInt64 currentTimeInUsec = PR_Now();
    1: 
 2626:   // calculate expiry time of cookie.
    1:   cookieAttributes.isSession = GetExpiry(cookieAttributes, aServerTime,
 2626:                                          currentTimeInUsec / PR_USEC_PER_SEC);
    1: 
 2796:   // reject cookie if it's over the size limit, per RFC2109
 2796:   if ((cookieAttributes.name.Length() + cookieAttributes.value.Length()) > kMaxBytesPerCookie) {
 2796:     COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, savedCookieHeader, "cookie too big (> 4kb)");
    1:     return newCookie;
    1:   }
    1: 
 2796:   if (cookieAttributes.name.FindChar('\t') != kNotFound) {
 2796:     COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, savedCookieHeader, "invalid name character");
 2796:     return newCookie;
  956:   }
  956: 
    1:   // domain & path checks
 2796:   if (!CheckDomain(cookieAttributes, aHostURI)) {
 2796:     COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, savedCookieHeader, "failed the domain tests");
 2796:     return newCookie;
    1:   }
 2796:   if (!CheckPath(cookieAttributes, aHostURI)) {
 2796:     COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, savedCookieHeader, "failed the path tests");
 2796:     return newCookie;
    1:   }
    1: 
    1:   // create a new nsCookie and copy attributes
    1:   nsRefPtr<nsCookie> cookie =
 2796:     nsCookie::Create(cookieAttributes.name,
 2796:                      cookieAttributes.value,
 2796:                      cookieAttributes.host,
 2796:                      cookieAttributes.path,
 2796:                      cookieAttributes.expiryTime,
 8141:                      currentTimeInUsec,
 8141:                      currentTimeInUsec,
 2796:                      cookieAttributes.isSession,
 2796:                      cookieAttributes.isSecure,
 2796:                      cookieAttributes.isHttpOnly);
 2796:   if (!cookie)
 2796:     return newCookie;
    1: 
    1:   // check permissions from site permission list, or ask the user,
    1:   // to determine if we can set the cookie
    1:   if (mPermissionService) {
    1:     PRBool permission;
    1:     // we need to think about prompters/parent windows here - TestPermission
    1:     // needs one to prompt, so right now it has to fend for itself to get one
    1:     mPermissionService->CanSetCookie(aHostURI,
    1:                                      aChannel,
 3233:                                      static_cast<nsICookie2*>(static_cast<nsCookie*>(cookie)),
 2796:                                      &cookieAttributes.isSession,
 2796:                                      &cookieAttributes.expiryTime,
    1:                                      &permission);
    1:     if (!permission) {
 2796:       COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, savedCookieHeader, "cookie rejected by permission manager");
    1:       NotifyRejected(aHostURI);
 2796:       return newCookie;
    1:     }
    1: 
    1:     // update isSession and expiry attributes, in case they changed
 2796:     cookie->SetIsSession(cookieAttributes.isSession);
 2796:     cookie->SetExpiry(cookieAttributes.expiryTime);
    1:   }
    1: 
    1:   // add the cookie to the list. AddInternal() takes care of logging.
 2508:   // we get the current time again here, since it may have changed during prompting
30480:   AddInternal(cookie, PR_Now() / PR_USEC_PER_SEC, aHostURI, savedCookieHeader.get(), aFromHttp);
 2796:   return newCookie;
    1: }
    1: 
    1: // this is a backend function for adding a cookie to the list, via SetCookie.
    1: // also used in the cookie manager, for profile migration from IE.
    1: // it either replaces an existing cookie; or adds the cookie to the hashtable,
    1: // and deletes a cookie (if maximum number of cookies has been
    1: // reached). also performs list maintenance by removing expired cookies.
    1: void
    1: nsCookieService::AddInternal(nsCookie   *aCookie,
30480:                              PRInt64     aCurrentTime,
    1:                              nsIURI     *aHostURI,
 2793:                              const char *aCookieHeader,
 2793:                              PRBool      aFromHttp)
    1: {
 3314:   // if the new cookie is httponly, make sure we're not coming from script
 3314:   if (!aFromHttp && aCookie->IsHttpOnly()) {
 3314:     COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, aCookieHeader, "cookie is httponly; coming from script");
 3314:     return;
 3314:   }
 3314: 
 2508:   // start a transaction on the storage db, to optimize deletions/insertions.
 2508:   // transaction will automically commit on completion. if we already have a
 2508:   // transaction (e.g. from SetCookie*()), this will have no effect. 
33960:   mozStorageTransaction transaction(mDBState->dbConn, PR_TRUE);
 2508: 
    1:   nsListIter matchIter;
14075:   PRBool foundCookie = FindCookie(aCookie->Host(), aCookie->Name(), aCookie->Path(),
30480:                                   matchIter, aCurrentTime);
    1: 
    1:   nsRefPtr<nsCookie> oldCookie;
    1:   if (foundCookie) {
    1:     oldCookie = matchIter.current;
 2793: 
 2793:     // if the old cookie is httponly, make sure we're not coming from script
 2793:     if (!aFromHttp && oldCookie->IsHttpOnly()) {
 2793:       COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, aCookieHeader, "previously stored cookie is httponly; coming from script");
 2793:       return;
 2793:     }
 2793: 
    1:     RemoveCookieFromList(matchIter);
    1: 
    1:     // check if the cookie has expired
30480:     if (aCookie->Expiry() <= aCurrentTime) {
    1:       COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, aCookieHeader, "previously stored cookie was deleted");
    1:       NotifyChanged(oldCookie, NS_LITERAL_STRING("deleted").get());
    1:       return;
    1:     }
    1: 
 8120:     // preserve creation time of cookie
 8120:     if (oldCookie)
 8120:       aCookie->SetCreationID(oldCookie->CreationID());
 8120: 
    1:   } else {
    1:     // check if cookie has already expired
30480:     if (aCookie->Expiry() <= aCurrentTime) {
    1:       COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, aCookieHeader, "cookie has already expired");
    1:       return;
    1:     }
    1: 
    1:     // check if we have to delete an old cookie.
30480:     nsEnumerationData data(aCurrentTime, LL_MAXINT);
 1128:     if (CountCookiesFromHostInternal(aCookie->RawHost(), data) >= mMaxCookiesPerHost) {
    1:       // remove the oldest cookie from host
    1:       oldCookie = data.iter.current;
    1:       RemoveCookieFromList(data.iter);
    1: 
33960:     } else if (mDBState->cookieCount >= mMaxNumberOfCookies) {
30480:       // try to make room, by removing expired cookies
30480:       RemoveExpiredCookies(aCurrentTime);
30480: 
30480:       // check if we still have to get rid of something
33960:       if (mDBState->cookieCount >= mMaxNumberOfCookies) {
30480:         // find the position of the oldest cookie, and remove it
30480:         data.oldestTime = LL_MAXINT;
30480:         FindOldestCookie(data);
30480:         oldCookie = data.iter.current;
30480:         RemoveCookieFromList(data.iter);
30480:       }
30480:     }
30480: 
30480:     // if we deleted an old cookie, notify consumers
30480:     if (oldCookie) {
30480:       COOKIE_LOGEVICTED(oldCookie);
30477:       NotifyChanged(oldCookie, NS_LITERAL_STRING("deleted").get());
    1:     }
 7285:   }
    1: 
    1:   // add the cookie to head of list
    1:   AddCookieToList(aCookie);
    1:   NotifyChanged(aCookie, foundCookie ? NS_LITERAL_STRING("changed").get()
    1:                                      : NS_LITERAL_STRING("added").get());
    1: 
 7285:   COOKIE_LOGSUCCESS(SET_COOKIE, aHostURI, aCookieHeader, aCookie, foundCookie != nsnull);
    1: }
    1: 
    1: /******************************************************************************
    1:  * nsCookieService impl:
    1:  * private cookie header parsing functions
    1:  ******************************************************************************/
    1: 
    1: // The following comment block elucidates the function of ParseAttributes.
    1: /******************************************************************************
    1:  ** Augmented BNF, modified from RFC2109 Section 4.2.2 and RFC2616 Section 2.1
    1:  ** please note: this BNF deviates from both specifications, and reflects this
  909:  ** implementation. <bnf> indicates a reference to the defined grammar "bnf".
    1: 
    1:  ** Differences from RFC2109/2616 and explanations:
    1:     1. implied *LWS
    1:          The grammar described by this specification is word-based. Except
    1:          where noted otherwise, linear white space (<LWS>) can be included
    1:          between any two adjacent words (token or quoted-string), and
    1:          between adjacent words and separators, without changing the
    1:          interpretation of a field.
    1:        <LWS> according to spec is SP|HT|CR|LF, but here, we allow only SP | HT.
    1: 
    1:     2. We use CR | LF as cookie separators, not ',' per spec, since ',' is in
    1:        common use inside values.
    1: 
    1:     3. tokens and values have looser restrictions on allowed characters than
    1:        spec. This is also due to certain characters being in common use inside
    1:        values. We allow only '=' to separate token/value pairs, and ';' to
    1:        terminate tokens or values. <LWS> is allowed within tokens and values
    1:        (see bug 206022).
    1: 
    1:     4. where appropriate, full <OCTET>s are allowed, where the spec dictates to
    1:        reject control chars or non-ASCII chars. This is erring on the loose
    1:        side, since there's probably no good reason to enforce this strictness.
    1: 
    1:     5. cookie <NAME> is optional, where spec requires it. This is a fairly
    1:        trivial case, but allows the flexibility of setting only a cookie <VALUE>
    1:        with a blank <NAME> and is required by some sites (see bug 169091).
    1:        
    1:     6. Attribute "HttpOnly", not covered in the RFCs, is supported
    1:        (see bug 178993).
    1: 
    1:  ** Begin BNF:
    1:     token         = 1*<any allowed-chars except separators>
    1:     value         = token-value | quoted-string
    1:     token-value   = 1*<any allowed-chars except value-sep>
    1:     quoted-string = ( <"> *( qdtext | quoted-pair ) <"> )
    1:     qdtext        = <any allowed-chars except <">>             ; CR | LF removed by necko
    1:     quoted-pair   = "\" <any OCTET except NUL or cookie-sep>   ; CR | LF removed by necko
    1:     separators    = ";" | "="
    1:     value-sep     = ";"
    1:     cookie-sep    = CR | LF
    1:     allowed-chars = <any OCTET except NUL or cookie-sep>
    1:     OCTET         = <any 8-bit sequence of data>
    1:     LWS           = SP | HT
    1:     NUL           = <US-ASCII NUL, null control character (0)>
    1:     CR            = <US-ASCII CR, carriage return (13)>
    1:     LF            = <US-ASCII LF, linefeed (10)>
    1:     SP            = <US-ASCII SP, space (32)>
    1:     HT            = <US-ASCII HT, horizontal-tab (9)>
    1: 
    1:     set-cookie    = "Set-Cookie:" cookies
    1:     cookies       = cookie *( cookie-sep cookie )
    1:     cookie        = [NAME "="] VALUE *(";" cookie-av)    ; cookie NAME/VALUE must come first
    1:     NAME          = token                                ; cookie name
    1:     VALUE         = value                                ; cookie value
    1:     cookie-av     = token ["=" value]
    1: 
    1:     valid values for cookie-av (checked post-parsing) are:
    1:     cookie-av     = "Path"    "=" value
    1:                   | "Domain"  "=" value
    1:                   | "Expires" "=" value
    1:                   | "Max-Age" "=" value
    1:                   | "Comment" "=" value
    1:                   | "Version" "=" value
    1:                   | "Secure"
    1:                   | "HttpOnly"
    1: 
    1: ******************************************************************************/
    1: 
    1: // helper functions for GetTokenValue
    1: static inline PRBool iswhitespace     (char c) { return c == ' '  || c == '\t'; }
    1: static inline PRBool isterminator     (char c) { return c == '\n' || c == '\r'; }
    1: static inline PRBool isquoteterminator(char c) { return isterminator(c) || c == '"'; }
    1: static inline PRBool isvalueseparator (char c) { return isterminator(c) || c == ';'; }
    1: static inline PRBool istokenseparator (char c) { return isvalueseparator(c) || c == '='; }
    1: 
    1: // Parse a single token/value pair.
    1: // Returns PR_TRUE if a cookie terminator is found, so caller can parse new cookie.
    1: PRBool
    1: nsCookieService::GetTokenValue(nsASingleFragmentCString::const_char_iterator &aIter,
    1:                                nsASingleFragmentCString::const_char_iterator &aEndIter,
    1:                                nsDependentCSubstring                         &aTokenString,
    1:                                nsDependentCSubstring                         &aTokenValue,
    1:                                PRBool                                        &aEqualsFound)
    1: {
    1:   nsASingleFragmentCString::const_char_iterator start, lastSpace;
    1:   // initialize value string to clear garbage
    1:   aTokenValue.Rebind(aIter, aIter);
    1: 
    1:   // find <token>, including any <LWS> between the end-of-token and the
    1:   // token separator. we'll remove trailing <LWS> next
    1:   while (aIter != aEndIter && iswhitespace(*aIter))
    1:     ++aIter;
    1:   start = aIter;
    1:   while (aIter != aEndIter && !istokenseparator(*aIter))
    1:     ++aIter;
    1: 
    1:   // remove trailing <LWS>; first check we're not at the beginning
    1:   lastSpace = aIter;
    1:   if (lastSpace != start) {
    1:     while (--lastSpace != start && iswhitespace(*lastSpace));
    1:     ++lastSpace;
    1:   }
    1:   aTokenString.Rebind(start, lastSpace);
    1: 
    1:   aEqualsFound = (*aIter == '=');
    1:   if (aEqualsFound) {
    1:     // find <value>
    1:     while (++aIter != aEndIter && iswhitespace(*aIter));
    1: 
    1:     start = aIter;
    1: 
    1:     if (*aIter == '"') {
    1:       // process <quoted-string>
    1:       // (note: cookie terminators, CR | LF, can't happen:
    1:       // they're removed by necko before the header gets here)
    1:       // assume value mangled if no terminating '"', return
    1:       while (++aIter != aEndIter && !isquoteterminator(*aIter)) {
    1:         // if <qdtext> (backwhacked char), skip over it. this allows '\"' in <quoted-string>.
    1:         // we increment once over the backwhack, nullcheck, then continue to the 'while',
    1:         // which increments over the backwhacked char. one exception - we don't allow
    1:         // CR | LF here either (see above about necko)
    1:         if (*aIter == '\\' && (++aIter == aEndIter || isterminator(*aIter)))
    1:           break;
    1:       }
    1: 
    1:       if (aIter != aEndIter && !isterminator(*aIter)) {
    1:         // include terminating quote in attribute string
    1:         aTokenValue.Rebind(start, ++aIter);
    1:         // skip to next ';'
    1:         while (aIter != aEndIter && !isvalueseparator(*aIter))
    1:           ++aIter;
    1:       }
    1:     } else {
    1:       // process <token-value>
    1:       // just look for ';' to terminate ('=' allowed)
    1:       while (aIter != aEndIter && !isvalueseparator(*aIter))
    1:         ++aIter;
    1: 
    1:       // remove trailing <LWS>; first check we're not at the beginning
    1:       if (aIter != start) {
    1:         lastSpace = aIter;
    1:         while (--lastSpace != start && iswhitespace(*lastSpace));
    1:         aTokenValue.Rebind(start, ++lastSpace);
    1:       }
    1:     }
    1:   }
    1: 
    1:   // aIter is on ';', or terminator, or EOS
    1:   if (aIter != aEndIter) {
    1:     // if on terminator, increment past & return PR_TRUE to process new cookie
    1:     if (isterminator(*aIter)) {
    1:       ++aIter;
    1:       return PR_TRUE;
    1:     }
    1:     // fall-through: aIter is on ';', increment and return PR_FALSE
    1:     ++aIter;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: // Parses attributes from cookie header. expires/max-age attributes aren't folded into the
    1: // cookie struct here, because we don't know which one to use until we've parsed the header.
    1: PRBool
    1: nsCookieService::ParseAttributes(nsDependentCString &aCookieHeader,
    1:                                  nsCookieAttributes &aCookieAttributes)
    1: {
    1:   static const char kPath[]    = "path";
    1:   static const char kDomain[]  = "domain";
    1:   static const char kExpires[] = "expires";
    1:   static const char kMaxage[]  = "max-age";
    1:   static const char kSecure[]  = "secure";
    1:   static const char kHttpOnly[]  = "httponly";
    1: 
    1:   nsASingleFragmentCString::const_char_iterator tempBegin, tempEnd;
    1:   nsASingleFragmentCString::const_char_iterator cookieStart, cookieEnd;
    1:   aCookieHeader.BeginReading(cookieStart);
    1:   aCookieHeader.EndReading(cookieEnd);
    1: 
    1:   aCookieAttributes.isSecure = PR_FALSE;
    1:   aCookieAttributes.isHttpOnly = PR_FALSE;
    1:   
    1:   nsDependentCSubstring tokenString(cookieStart, cookieStart);
    1:   nsDependentCSubstring tokenValue (cookieStart, cookieStart);
    1:   PRBool newCookie, equalsFound;
    1: 
    1:   // extract cookie <NAME> & <VALUE> (first attribute), and copy the strings.
    1:   // if we find multiple cookies, return for processing
    1:   // note: if there's no '=', we assume token is <VALUE>. this is required by
    1:   //       some sites (see bug 169091).
    1:   // XXX fix the parser to parse according to <VALUE> grammar for this case
    1:   newCookie = GetTokenValue(cookieStart, cookieEnd, tokenString, tokenValue, equalsFound);
    1:   if (equalsFound) {
    1:     aCookieAttributes.name = tokenString;
    1:     aCookieAttributes.value = tokenValue;
    1:   } else {
    1:     aCookieAttributes.value = tokenString;
    1:   }
    1: 
    1:   // extract remaining attributes
    1:   while (cookieStart != cookieEnd && !newCookie) {
    1:     newCookie = GetTokenValue(cookieStart, cookieEnd, tokenString, tokenValue, equalsFound);
    1: 
    1:     if (!tokenValue.IsEmpty()) {
    1:       tokenValue.BeginReading(tempBegin);
    1:       tokenValue.EndReading(tempEnd);
    1:       if (*tempBegin == '"' && *--tempEnd == '"') {
    1:         // our parameter is a quoted-string; remove quotes for later parsing
    1:         tokenValue.Rebind(++tempBegin, tempEnd);
    1:       }
    1:     }
    1: 
    1:     // decide which attribute we have, and copy the string
    1:     if (tokenString.LowerCaseEqualsLiteral(kPath))
    1:       aCookieAttributes.path = tokenValue;
    1: 
    1:     else if (tokenString.LowerCaseEqualsLiteral(kDomain))
    1:       aCookieAttributes.host = tokenValue;
    1: 
    1:     else if (tokenString.LowerCaseEqualsLiteral(kExpires))
    1:       aCookieAttributes.expires = tokenValue;
    1: 
    1:     else if (tokenString.LowerCaseEqualsLiteral(kMaxage))
    1:       aCookieAttributes.maxage = tokenValue;
    1: 
    1:     // ignore any tokenValue for isSecure; just set the boolean
    1:     else if (tokenString.LowerCaseEqualsLiteral(kSecure))
    1:       aCookieAttributes.isSecure = PR_TRUE;
    1:       
    1:     // ignore any tokenValue for isHttpOnly (see bug 178993);
    1:     // just set the boolean
    1:     else if (tokenString.LowerCaseEqualsLiteral(kHttpOnly))
    1:       aCookieAttributes.isHttpOnly = PR_TRUE;
    1:   }
    1: 
    1:   // rebind aCookieHeader, in case we need to process another cookie
    1:   aCookieHeader.Rebind(cookieStart, cookieEnd);
    1:   return newCookie;
    1: }
    1: 
    1: /******************************************************************************
    1:  * nsCookieService impl:
    1:  * private domain & permission compliance enforcement functions
    1:  ******************************************************************************/
    1: 
    1: PRBool
    1: nsCookieService::IsForeign(nsIURI *aHostURI,
    1:                            nsIURI *aFirstURI)
    1: {
    1:   // Get hosts
    1:   nsCAutoString currentHost, firstHost;
    1:   if (NS_FAILED(aHostURI->GetAsciiHost(currentHost)) ||
    1:       NS_FAILED(aFirstURI->GetAsciiHost(firstHost))) {
12921:     // assume foreign
    1:     return PR_TRUE;
    1:   }
    1:   // trim trailing dots
    1:   currentHost.Trim(".");
    1:   firstHost.Trim(".");
    1: 
 8702:   // fast path: check if the two hosts are identical.
 8702:   // this also covers two special cases:
 8702:   // 1) if we're dealing with IP addresses, require an exact match. this
 8702:   // eliminates any chance of IP address funkiness (e.g. the alias 127.1
 8702:   // domain-matching 99.54.127.1). bug 105917 originally noted the requirement
 8702:   // to deal with IP addresses. note that GetBaseDomain() below will return an
 8702:   // error if the URI is an IP address.
 8702:   // 2) we also need this for the (rare) case where the site is actually an eTLD,
 8702:   // e.g. http://co.tv; GetBaseDomain() will throw an error and we might
 8702:   // erroneously think currentHost is foreign. so we consider this case non-
 8702:   // foreign only if the hosts exactly match.
 8702:   if (firstHost.Equals(currentHost))
 8702:     return PR_FALSE;
    1: 
 8702:   // get the base domain for the originating URI.
 8702:   // e.g. for "images.bbc.co.uk", this would be "bbc.co.uk".
 8702:   nsCAutoString baseDomain;
12921:   nsresult rv = mTLDService->GetBaseDomain(aFirstURI, 0, baseDomain);
 8702:   if (NS_FAILED(rv)) {
 8702:     // URI is an IP, eTLD, or something else went wrong - assume foreign
 8702:     return PR_TRUE;
    1:   }  
 8702:   baseDomain.Trim(".");
    1: 
 8702:   // ensure the host domain is derived from the base domain.
 8702:   // we prepend dots before the comparison to ensure e.g.
 8702:   // "mybbc.co.uk" isn't matched as a superset of "bbc.co.uk".
 8702:   currentHost.Insert(NS_LITERAL_CSTRING("."), 0);
 8702:   baseDomain.Insert(NS_LITERAL_CSTRING("."), 0);
 8702:   return !StringEndsWith(currentHost, baseDomain);
    1: }
    1: 
 2626: PRUint32
    1: nsCookieService::CheckPrefs(nsIURI     *aHostURI,
    1:                             nsIChannel *aChannel,
 2626:                             const char *aCookieHeader)
    1: {
12921:   nsresult rv;
    1: 
    1:   // don't let ftp sites get/set cookies (could be a security issue)
12921:   PRBool ftp;
12921:   if (NS_SUCCEEDED(aHostURI->SchemeIs("ftp", &ftp)) && ftp) {
    1:     COOKIE_LOGFAILURE(aCookieHeader ? SET_COOKIE : GET_COOKIE, aHostURI, aCookieHeader, "ftp sites cannot read cookies");
    1:     return STATUS_REJECTED_WITH_ERROR;
    1:   }
    1: 
    1:   // check the permission list first; if we find an entry, it overrides
    1:   // default prefs. see bug 184059.
    1:   if (mPermissionService) {
    1:     nsCookieAccess access;
12921:     rv = mPermissionService->CanAccess(aHostURI, aChannel, &access);
    1: 
    1:     // if we found an entry, use it
    1:     if (NS_SUCCEEDED(rv)) {
    1:       switch (access) {
    1:       case nsICookiePermission::ACCESS_DENY:
    1:         COOKIE_LOGFAILURE(aCookieHeader ? SET_COOKIE : GET_COOKIE, aHostURI, aCookieHeader, "cookies are blocked for this site");
 2626:         return STATUS_REJECTED;
    1: 
    1:       case nsICookiePermission::ACCESS_ALLOW:
 2626:         return STATUS_ACCEPTED;
    1:       }
    1:     }
    1:   }
    1: 
12921:   // check default prefs
    1:   if (mCookiesPermissions == BEHAVIOR_REJECT) {
    1:     COOKIE_LOGFAILURE(aCookieHeader ? SET_COOKIE : GET_COOKIE, aHostURI, aCookieHeader, "cookies are disabled");
 2626:     return STATUS_REJECTED;
    1: 
    1:   } else if (mCookiesPermissions == BEHAVIOR_REJECTFOREIGN) {
12921:     // check if cookie is foreign
13137:     if (!mPermissionService) {
13137:       NS_WARNING("Foreign cookie blocking enabled, but nsICookiePermission unavailable! Rejecting cookie");
13137:       COOKIE_LOGSTRING(PR_LOG_WARNING, ("CheckPrefs(): foreign blocking enabled, but nsICookiePermission unavailable! Rejecting cookie"));
12921:       return STATUS_REJECTED;
13137:     }
    1: 
12921:     nsCOMPtr<nsIURI> firstURI;
12921:     rv = mPermissionService->GetOriginatingURI(aChannel, getter_AddRefs(firstURI));
12921: 
12921:     if (NS_FAILED(rv) || IsForeign(aHostURI, firstURI)) {
    1:       COOKIE_LOGFAILURE(aCookieHeader ? SET_COOKIE : GET_COOKIE, aHostURI, aCookieHeader, "originating server test failed");
 2626:       return STATUS_REJECTED;
    1:     }
    1:   }
    1: 
    1:   // if nothing has complained, accept cookie
 2626:   return STATUS_ACCEPTED;
    1: }
    1: 
    1: // processes domain attribute, and returns PR_TRUE if host has permission to set for this domain.
    1: PRBool
    1: nsCookieService::CheckDomain(nsCookieAttributes &aCookieAttributes,
    1:                              nsIURI             *aHostURI)
    1: {
 8702:   nsresult rv;
 8702: 
    1:   // get host from aHostURI
    1:   nsCAutoString hostFromURI;
    1:   if (NS_FAILED(aHostURI->GetAsciiHost(hostFromURI))) {
    1:     return PR_FALSE;
    1:   }
    1:   // trim trailing dots
    1:   hostFromURI.Trim(".");
    1: 
    1:   // if a domain is given, check the host has permission
    1:   if (!aCookieAttributes.host.IsEmpty()) {
    1:     aCookieAttributes.host.Trim(".");
    1:     // switch to lowercase now, to avoid case-insensitive compares everywhere
    1:     ToLowerCase(aCookieAttributes.host);
    1: 
 8702:     // get the base domain for the host URI.
 8702:     // e.g. for "images.bbc.co.uk", this would be "bbc.co.uk", which
 8702:     // represents the lowest level domain a cookie can be set for.
 8702:     nsCAutoString baseDomain;
 8702:     rv = mTLDService->GetBaseDomain(aHostURI, 0, baseDomain);
 8702:     baseDomain.Trim(".");
 8702:     if (NS_FAILED(rv)) {
 8702:       // check whether the host is an IP address, and leave the cookie as
 8702:       // a non-domain one. this will require an exact host match for the cookie,
 8702:       // so we eliminate any chance of IP address funkiness (e.g. the alias 127.1
 8702:       // domain-matching 99.54.127.1). bug 105917 originally noted the
 8702:       // requirement to deal with IP addresses.
 8702:       if (rv == NS_ERROR_HOST_IS_IP_ADDRESS)
 8702:         return hostFromURI.Equals(aCookieAttributes.host);
    1: 
    1:       return PR_FALSE;
    1:     }
    1: 
 8702:     // ensure the proposed domain is derived from the base domain; and also
 8702:     // that the host domain is derived from the proposed domain (per RFC2109).
 8702:     // we prepend a dot before the comparison to ensure e.g.
 8702:     // "mybbc.co.uk" isn't matched as a superset of "bbc.co.uk".
 8702:     hostFromURI.Insert(NS_LITERAL_CSTRING("."), 0);
    1:     aCookieAttributes.host.Insert(NS_LITERAL_CSTRING("."), 0);
 8702:     baseDomain.Insert(NS_LITERAL_CSTRING("."), 0);
 8702:     return StringEndsWith(aCookieAttributes.host, baseDomain) &&
 8702:            StringEndsWith(hostFromURI, aCookieAttributes.host);
    1: 
    1:     /*
    1:      * note: RFC2109 section 4.3.2 requires that we check the following:
    1:      * that the portion of host not in domain does not contain a dot.
    1:      * this prevents hosts of the form x.y.co.nz from setting cookies in the
    1:      * entire .co.nz domain. however, it's only a only a partial solution and
    1:      * it breaks sites (IE doesn't enforce it), so we don't perform this check.
    1:      */
 8702:   }
    1: 
    1:   // block any URIs without a host that aren't file:/// URIs
    1:   if (hostFromURI.IsEmpty()) {
    1:     PRBool isFileURI = PR_FALSE;
    1:     aHostURI->SchemeIs("file", &isFileURI);
    1:     if (!isFileURI)
    1:       return PR_FALSE;
    1:   }
 8702: 
 8702:   // no domain specified, use hostFromURI
    1:   aCookieAttributes.host = hostFromURI;
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsCookieService::CheckPath(nsCookieAttributes &aCookieAttributes,
    1:                            nsIURI             *aHostURI)
    1: {
    1:   // if a path is given, check the host has permission
    1:   if (aCookieAttributes.path.IsEmpty()) {
    1:     // strip down everything after the last slash to get the path,
    1:     // ignoring slashes in the query string part.
    1:     // if we can QI to nsIURL, that'll take care of the query string portion.
    1:     // otherwise, it's not an nsIURL and can't have a query string, so just find the last slash.
    1:     nsCOMPtr<nsIURL> hostURL = do_QueryInterface(aHostURI);
    1:     if (hostURL) {
    1:       hostURL->GetDirectory(aCookieAttributes.path);
    1:     } else {
    1:       aHostURI->GetPath(aCookieAttributes.path);
    1:       PRInt32 slash = aCookieAttributes.path.RFindChar('/');
    1:       if (slash != kNotFound) {
    1:         aCookieAttributes.path.Truncate(slash + 1);
    1:       }
    1:     }
    1: 
 1238: #if 0
  956:   } else {
    1:     /**
    1:      * The following test is part of the RFC2109 spec.  Loosely speaking, it says that a site
    1:      * cannot set a cookie for a path that it is not on.  See bug 155083.  However this patch
    1:      * broke several sites -- nordea (bug 155768) and citibank (bug 156725).  So this test has
    1:      * been disabled, unless we can evangelize these sites.
    1:      */
    1:     // get path from aHostURI
    1:     nsCAutoString pathFromURI;
    1:     if (NS_FAILED(aHostURI->GetPath(pathFromURI)) ||
    1:         !StringBeginsWith(pathFromURI, aCookieAttributes.path)) {
    1:       return PR_FALSE;
    1:     }
    1: #endif
    1:   }
    1: 
 1238:   if (aCookieAttributes.path.Length() > kMaxBytesPerPath ||
 1238:       aCookieAttributes.path.FindChar('\t') != kNotFound )
 1238:     return PR_FALSE;
 1238: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsCookieService::GetExpiry(nsCookieAttributes &aCookieAttributes,
 2508:                            PRInt64             aServerTime,
 2626:                            PRInt64             aCurrentTime)
    1: {
    1:   /* Determine when the cookie should expire. This is done by taking the difference between 
    1:    * the server time and the time the server wants the cookie to expire, and adding that 
    1:    * difference to the client time. This localizes the client time regardless of whether or
    1:    * not the TZ environment variable was set on the client.
    1:    *
    1:    * Note: We need to consider accounting for network lag here, per RFC.
    1:    */
 2508:   PRInt64 delta;
    1: 
    1:   // check for max-age attribute first; this overrides expires attribute
    1:   if (!aCookieAttributes.maxage.IsEmpty()) {
    1:     // obtain numeric value of maxageAttribute
    1:     PRInt64 maxage;
    1:     PRInt32 numInts = PR_sscanf(aCookieAttributes.maxage.get(), "%lld", &maxage);
    1: 
    1:     // default to session cookie if the conversion failed
    1:     if (numInts != 1) {
    1:       return PR_TRUE;
    1:     }
    1: 
 2508:     delta = maxage;
    1: 
    1:   // check for expires attribute
    1:   } else if (!aCookieAttributes.expires.IsEmpty()) {
    1:     PRTime tempExpires;
 2508:     PRInt64 expires;
    1: 
    1:     // parse expiry time
    1:     if (PR_ParseTimeString(aCookieAttributes.expires.get(), PR_TRUE, &tempExpires) == PR_SUCCESS) {
 2508:       expires = tempExpires / PR_USEC_PER_SEC;
    1:     } else {
    1:       return PR_TRUE;
    1:     }
    1: 
    1:     delta = expires - aServerTime;
    1: 
    1:   // default to session cookie if no attributes found
    1:   } else {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // if this addition overflows, expiryTime will be less than currentTime
    1:   // and the cookie will be expired - that's okay.
    1:   aCookieAttributes.expiryTime = aCurrentTime + delta;
    1: 
 2626:   return PR_FALSE;
    1: }
    1: 
    1: /******************************************************************************
    1:  * nsCookieService impl:
    1:  * private cookielist management functions
    1:  ******************************************************************************/
    1: 
    1: void
    1: nsCookieService::RemoveAllFromMemory()
    1: {
    1:   // clearing the hashtable will call each nsCookieEntry's dtor,
    1:   // which releases all their respective children.
33960:   mDBState->hostTable.Clear();
33960:   mDBState->cookieCount = 0;
    1: }
    1: 
20261: PLDHashOperator
30480: removeExpiredCallback(nsCookieEntry *aEntry,
    1:                       void          *aArg)
    1: {
30480:   const PRInt64 &currentTime = *static_cast<PRInt64*>(aArg);
    1:   for (nsListIter iter(aEntry, nsnull, aEntry->Head()); iter.current; ) {
30480:     if (iter.current->Expiry() <= currentTime)
    1:       // remove from list. this takes care of updating the iterator for us
    1:       nsCookieService::gCookieService->RemoveCookieFromList(iter);
30480:     else
    1:       ++iter;
    1:   }
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
30480: // removes any expired cookies from memory
    1: void
30480: nsCookieService::RemoveExpiredCookies(PRInt64 aCurrentTime)
    1: {
 7309: #ifdef PR_LOGGING
33960:   PRUint32 initialCookieCount = mDBState->cookieCount;
 7309: #endif
33960:   mDBState->hostTable.EnumerateEntries(removeExpiredCallback, &aCurrentTime);
33960:   COOKIE_LOGSTRING(PR_LOG_DEBUG,
33960:     ("RemoveExpiredCookies(): %ld purged; %ld remain",
33960:      initialCookieCount - mDBState->cookieCount, mDBState->cookieCount));
    1: }
    1: 
 1128: // find whether a given cookie has been previously set. this is provided by the
 1128: // nsICookieManager2 interface.
    1: NS_IMETHODIMP
 1128: nsCookieService::CookieExists(nsICookie2 *aCookie,
    1:                               PRBool     *aFoundCookie)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aCookie);
    1: 
 1128:   // just a placeholder
14075:   nsListIter iter;
19327:   nsCAutoString host, name, path;
19327:   nsresult rv = aCookie->GetHost(host);
19327:   NS_ENSURE_SUCCESS(rv, rv);
19327:   rv = aCookie->GetName(name);
19327:   NS_ENSURE_SUCCESS(rv, rv);
19327:   rv = aCookie->GetPath(path);
19327:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
19327:   *aFoundCookie = FindCookie(host, name, path, iter,
19327:                              PR_Now() / PR_USEC_PER_SEC);
    1:   return NS_OK;
    1: }
    1: 
 1128: // count the number of cookies from a given host, and simultaneously find the
 1128: // oldest cookie from the host.
    1: PRUint32
 1128: nsCookieService::CountCookiesFromHostInternal(const nsACString  &aHost,
    1:                                               nsEnumerationData &aData)
    1: {
    1:   PRUint32 countFromHost = 0;
    1: 
 1128:   nsCAutoString hostWithDot(NS_LITERAL_CSTRING(".") + aHost);
    1: 
    1:   const char *currentDot = hostWithDot.get();
    1:   const char *nextDot = currentDot + 1;
    1:   do {
33960:     nsCookieEntry *entry = mDBState->hostTable.GetEntry(currentDot);
    1:     for (nsListIter iter(entry); iter.current; ++iter) {
    1:       // only count non-expired cookies
    1:       if (iter.current->Expiry() > aData.currentTime) {
    1:         ++countFromHost;
    1: 
    1:         // check if we've found the oldest cookie so far
 8141:         if (aData.oldestTime > iter.current->LastAccessed()) {
 8141:           aData.oldestTime = iter.current->LastAccessed();
    1:           aData.iter = iter;
    1:         }
    1:       }
    1:     }
    1: 
    1:     currentDot = nextDot;
    1:     if (currentDot)
    1:       nextDot = strchr(currentDot + 1, '.');
    1: 
    1:   } while (currentDot);
    1: 
    1:   return countFromHost;
    1: }
    1: 
 1128: // count the number of cookies stored by a particular host. this is provided by the
 1128: // nsICookieManager2 interface.
 1128: NS_IMETHODIMP
 1128: nsCookieService::CountCookiesFromHost(const nsACString &aHost,
 1128:                                       PRUint32         *aCountFromHost)
 1128: {
 1128:   // we don't care about finding the oldest cookie here, so disable the search
 2508:   nsEnumerationData data(PR_Now() / PR_USEC_PER_SEC, LL_MININT);
 1128:   
 1128:   *aCountFromHost = CountCookiesFromHostInternal(aHost, data);
 1128:   return NS_OK;
 1128: }
 1128: 
30354: // get an enumerator of cookies stored by a particular host. this is provided by the
30354: // nsICookieManager2 interface.
30354: NS_IMETHODIMP
30354: nsCookieService::GetCookiesFromHost(const nsACString     &aHost,
30354:                                     nsISimpleEnumerator **aEnumerator)
30354: {
30354:   nsCOMArray<nsICookie> cookieList(mMaxCookiesPerHost);
30354:   nsCAutoString hostWithDot(NS_LITERAL_CSTRING(".") + aHost);
30354:   PRInt64 currentTime = PR_Now() / PR_USEC_PER_SEC;
30354: 
30354:   const char *currentDot = hostWithDot.get();
30354:   const char *nextDot = currentDot + 1;
30354:   do {
33960:     nsCookieEntry *entry = mDBState->hostTable.GetEntry(currentDot);
30354:     for (nsListIter iter(entry); iter.current; ++iter) {
30354:       // only append non-expired cookies
30354:       if (iter.current->Expiry() > currentTime)
30354:         cookieList.AppendObject(iter.current);
30354:     }
30354: 
30354:     currentDot = nextDot;
30354:     if (currentDot)
30354:       nextDot = strchr(currentDot + 1, '.');
30354: 
30354:   } while (currentDot);
30354: 
30354:   return NS_NewArrayEnumerator(aEnumerator, cookieList);
30354: }
30354: 
14075: // find an exact cookie specified by host, name, and path that hasn't expired.
    1: PRBool
    1: nsCookieService::FindCookie(const nsAFlatCString &aHost,
    1:                             const nsAFlatCString &aName,
    1:                             const nsAFlatCString &aPath,
14075:                             nsListIter           &aIter,
14075:                             PRInt64               aCurrentTime)
    1: {
33960:   nsCookieEntry *entry = mDBState->hostTable.GetEntry(aHost.get());
    1:   for (aIter = nsListIter(entry); aIter.current; ++aIter) {
14075:     if (aIter.current->Expiry() > aCurrentTime &&
14075:         aPath.Equals(aIter.current->Path()) &&
    1:         aName.Equals(aIter.current->Name())) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: // removes a cookie from the hashtable, and update the iterator state.
    1: void
    1: nsCookieService::RemoveCookieFromList(nsListIter &aIter)
    1: {
 2508:   // if it's a non-session cookie, remove it from the db
33960:   if (!aIter.current->IsSession() && mDBState->dbConn) {
 2508:     // use our cached sqlite "delete" statement
33960:     mozStorageStatementScoper scoper(mDBState->stmtDelete);
 2508: 
33960:     nsresult rv = mDBState->stmtDelete->BindInt64Parameter(0, aIter.current->CreationID());
 2508:     if (NS_SUCCEEDED(rv)) {
 2508:       PRBool hasResult;
33960:       rv = mDBState->stmtDelete->ExecuteStep(&hasResult);
 7285:     }
 7285: 
 7285:     if (NS_FAILED(rv)) {
 7285:       NS_WARNING("db remove failed!");
 7285:       COOKIE_LOGSTRING(PR_LOG_WARNING, ("RemoveCookieFromList(): removing from db gave error %x", rv));
 2508:     }
 2508:   }
 2508: 
    1:   if (!aIter.prev && !aIter.current->Next()) {
    1:     // we're removing the last element in the list - so just remove the entry
    1:     // from the hash. note that the entryclass' dtor will take care of
    1:     // releasing this last element for us!
33960:     mDBState->hostTable.RawRemoveEntry(aIter.entry);
    1:     aIter.current = nsnull;
    1: 
    1:   } else {
    1:     // just remove the element from the list, and increment the iterator
    1:     nsCookie *next = aIter.current->Next();
    1:     NS_RELEASE(aIter.current);
    1:     if (aIter.prev) {
    1:       // element to remove is not the head
    1:       aIter.current = aIter.prev->Next() = next;
    1:     } else {
    1:       // element to remove is the head
    1:       aIter.current = aIter.entry->Head() = next;
    1:     }
    1:   }
    1: 
33960:   --mDBState->cookieCount;
 2508: }
 2508: 
 2508: nsresult
 2508: bindCookieParameters(mozIStorageStatement* aStmt, const nsCookie* aCookie)
 2508: {
 2508:   nsresult rv;
 2508:   
 2508:   rv = aStmt->BindInt64Parameter(0, aCookie->CreationID());
 2508:   if (NS_FAILED(rv)) return rv;
 2508: 
 2508:   rv = aStmt->BindUTF8StringParameter(1, aCookie->Name());
 2508:   if (NS_FAILED(rv)) return rv;
 2508:   
 2508:   rv = aStmt->BindUTF8StringParameter(2, aCookie->Value());
 2508:   if (NS_FAILED(rv)) return rv;
 2508:   
 2508:   rv = aStmt->BindUTF8StringParameter(3, aCookie->Host());
 2508:   if (NS_FAILED(rv)) return rv;
 2508:   
 2508:   rv = aStmt->BindUTF8StringParameter(4, aCookie->Path());
 2508:   if (NS_FAILED(rv)) return rv;
 2508:   
 2508:   rv = aStmt->BindInt64Parameter(5, aCookie->Expiry());
 2508:   if (NS_FAILED(rv)) return rv;
 2508:   
 8141:   rv = aStmt->BindInt64Parameter(6, aCookie->LastAccessed());
 2508:   if (NS_FAILED(rv)) return rv;
 2508:   
 8141:   rv = aStmt->BindInt32Parameter(7, aCookie->IsSecure());
 8141:   if (NS_FAILED(rv)) return rv;
 8141:   
 8141:   rv = aStmt->BindInt32Parameter(8, aCookie->IsHttpOnly());
 2508:   return rv;
    1: }
    1: 
    1: PRBool
 2508: nsCookieService::AddCookieToList(nsCookie *aCookie, PRBool aWriteToDB)
    1: {
33960:   nsCookieEntry *entry = mDBState->hostTable.PutEntry(aCookie->Host().get());
    1: 
    1:   if (!entry) {
    1:     NS_ERROR("can't insert element into a null entry!");
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   NS_ADDREF(aCookie);
    1: 
    1:   aCookie->Next() = entry->Head();
    1:   entry->Head() = aCookie;
33960:   ++mDBState->cookieCount;
 2508: 
 2508:   // if it's a non-session cookie and hasn't just been read from the db, write it out.
33960:   if (aWriteToDB && !aCookie->IsSession() && mDBState->dbConn) {
 2508:     // use our cached sqlite "insert" statement
33960:     mozStorageStatementScoper scoper(mDBState->stmtInsert);
 2508: 
33960:     nsresult rv = bindCookieParameters(mDBState->stmtInsert, aCookie);
 7285:     if (NS_SUCCEEDED(rv)) {
 2508:       PRBool hasResult;
33960:       rv = mDBState->stmtInsert->ExecuteStep(&hasResult);
 7285:     }
 7285: 
 7285:     if (NS_FAILED(rv)) {
 7285:       NS_WARNING("db insert failed!");
 7285:       COOKIE_LOGSTRING(PR_LOG_WARNING, ("AddCookieToList(): adding to db gave error %x", rv));
 7285:     }
 2508:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
 8141: void
 8141: nsCookieService::UpdateCookieInList(nsCookie *aCookie, PRInt64 aLastAccessed)
 8141: {
 8141:   // update the lastAccessed timestamp
 8141:   aCookie->SetLastAccessed(aLastAccessed);
 8141: 
 8141:   // if it's a non-session cookie, update it in the db too
33960:   if (!aCookie->IsSession() && mDBState->dbConn) {
 8141:     // use our cached sqlite "update" statement
33960:     mozStorageStatementScoper scoper(mDBState->stmtUpdate);
 8141: 
33960:     nsresult rv = mDBState->stmtUpdate->BindInt64Parameter(0, aLastAccessed);
 8141:     if (NS_SUCCEEDED(rv)) {
33960:       rv = mDBState->stmtUpdate->BindInt64Parameter(1, aCookie->CreationID());
 8141:       if (NS_SUCCEEDED(rv)) {
 8141:         PRBool hasResult;
33960:         rv = mDBState->stmtUpdate->ExecuteStep(&hasResult);
 8141:       }
 8141:     }
 8141: 
 8141:     if (NS_FAILED(rv)) {
 8141:       NS_WARNING("db update failed!");
 8141:       COOKIE_LOGSTRING(PR_LOG_WARNING, ("UpdateCookieInList(): updating db gave error %x", rv));
 8141:     }
 8141:   }
 8141: }
 8141: 
30480: static PLDHashOperator
30480: findOldestCallback(nsCookieEntry *aEntry,
30480:                    void          *aArg)
30480: {
30480:   nsEnumerationData *data = static_cast<nsEnumerationData*>(aArg);
30480:   for (nsListIter iter(aEntry, nsnull, aEntry->Head()); iter.current; ++iter) {
30480:     // check if we've found the oldest cookie so far
30480:     if (data->oldestTime > iter.current->LastAccessed()) {
30480:       data->oldestTime = iter.current->LastAccessed();
30480:       data->iter = iter;
30480:     }
30480:   }
30480:   return PL_DHASH_NEXT;
30480: }
30480: 
30480: void
30480: nsCookieService::FindOldestCookie(nsEnumerationData &aData)
30480: {
33960:   mDBState->hostTable.EnumerateEntries(findOldestCallback, &aData);
30480: }
