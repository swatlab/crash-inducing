75402: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
75402:  * vim: set ts=8 sw=4 et tw=99 ft=cpp:
75402:  *
75402:  * ***** BEGIN LICENSE BLOCK *****
75397:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
75397:  *
75397:  * The contents of this file are subject to the Mozilla Public License Version
75397:  * 1.1 (the "License"); you may not use this file except in compliance with
75397:  * the License. You may obtain a copy of the License at
75397:  * http://www.mozilla.org/MPL/
75397:  *
75397:  * Software distributed under the License is distributed on an "AS IS" basis,
75397:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
75397:  * for the specific language governing rights and limitations under the
75397:  * License.
75397:  *
75513:  * The Original Code is SpiderMonkey Debugger object.
75397:  *
75397:  * The Initial Developer of the Original Code is
75397:  * Mozilla Foundation.
75397:  * Portions created by the Initial Developer are Copyright (C) 1998-1999
75397:  * the Initial Developer. All Rights Reserved.
75397:  *
75402:  * Contributors:
75397:  *   Jim Blandy <jimb@mozilla.com>
75397:  *   Jason Orendorff <jorendorff@mozilla.com>
75397:  *
75397:  * Alternatively, the contents of this file may be used under the terms of
75397:  * either of the GNU General Public License Version 2 or later (the "GPL"),
75397:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
75397:  * in which case the provisions of the GPL or the LGPL are applicable instead
75397:  * of those above. If you wish to allow use of your version of this file only
75397:  * under the terms of either the GPL or the LGPL, and not to allow others to
75397:  * use your version of this file under the terms of the MPL, indicate your
75397:  * decision by deleting the provisions above and replace them with the notice
75397:  * and other provisions required by the GPL or the LGPL. If you do not delete
75397:  * the provisions above, a recipient may use your version of this file under
75397:  * the terms of any one of the MPL, the GPL or the LGPL.
75397:  *
75397:  * ***** END LICENSE BLOCK ***** */
75397: 
76244: #include "vm/Debugger.h"
75397: #include "jsapi.h"
75397: #include "jscntxt.h"
75472: #include "jsemit.h"
75409: #include "jsgcmark.h"
75397: #include "jsobj.h"
75518: #include "jstl.h"
75398: #include "jswrapper.h"
75419: #include "jsinterpinlines.h"
75398: #include "jsobjinlines.h"
75504: #include "jsopcodeinlines.h"
75506: #include "methodjit/Retcon.h"
75418: #include "vm/Stack-inl.h"
75397: 
75397: using namespace js;
75397: 
75466: 
76236: /*** Forward declarations ************************************************************************/
75413: 
75513: extern Class DebuggerFrame_class;
75413: 
75413: enum {
75417:     JSSLOT_DEBUGFRAME_OWNER,
75418:     JSSLOT_DEBUGFRAME_ARGUMENTS,
77171:     JSSLOT_DEBUGFRAME_ONSTEP_HANDLER,
75417:     JSSLOT_DEBUGFRAME_COUNT
75413: };
75413: 
75513: extern Class DebuggerArguments_class;
75464: 
75464: enum {
75464:     JSSLOT_DEBUGARGUMENTS_FRAME,
75464:     JSSLOT_DEBUGARGUMENTS_COUNT
75464: };
75464: 
75513: extern Class DebuggerObject_class;
75418: 
75418: enum {
75418:     JSSLOT_DEBUGOBJECT_OWNER,
75418:     JSSLOT_DEBUGOBJECT_COUNT
75418: };
75418: 
75513: extern Class DebuggerScript_class;
75492: 
75492: enum {
75492:     JSSLOT_DEBUGSCRIPT_OWNER,
76236:     JSSLOT_DEBUGSCRIPT_HOLDER,  /* PrivateValue, cross-compartment pointer */
75492:     JSSLOT_DEBUGSCRIPT_COUNT
75492: };
75492: 
75466: 
76236: /*** Utils ***************************************************************************************/
75413: 
75398: bool
75398: ReportMoreArgsNeeded(JSContext *cx, const char *name, uintN required)
75397: {
75446:     JS_ASSERT(required > 0);
75446:     JS_ASSERT(required <= 10);
75399:     char s[2];
75446:     s[0] = '0' + (required - 1);
75399:     s[1] = '\0';
75398:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
75398:                          name, s, required == 1 ? "" : "s");
75397:     return false;
75397: }
75397: 
75398: #define REQUIRE_ARGC(name, n)                                                 \
75398:     JS_BEGIN_MACRO                                                            \
75472:         if (argc < (n))                                                       \
75398:             return ReportMoreArgsNeeded(cx, name, n);                         \
75398:     JS_END_MACRO
75398: 
75398: bool
75402: ReportObjectRequired(JSContext *cx)
75397: {
75398:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
75398:     return false;
75397: }
75397: 
75466: 
76236: /*** Breakpoints *********************************************************************************/
75506: 
75506: BreakpointSite::BreakpointSite(JSScript *script, jsbytecode *pc)
75506:   : script(script), pc(pc), realOpcode(JSOp(*pc)), scriptObject(NULL), enabledCount(0),
75506:     trapHandler(NULL), trapClosure(UndefinedValue())
75506: {
75506:     JS_ASSERT(realOpcode != JSOP_TRAP);
75506:     JS_INIT_CLIST(&breakpoints);
75506: }
75506: 
76236: /*
76236:  * Precondition: script is live, meaning either it is a non-held script that is
76236:  * on the stack or a held script that hasn't been GC'd.
76236:  */
75506: static JSObject *
75506: ScriptScope(JSContext *cx, JSScript *script, JSObject *holder)
75506: {
75506:     if (holder)
75506:         return holder;
75506: 
76236:     /*
76236:      * The referent is a non-held script. There is no direct reference from
76236:      * script to the scope, so find it on the stack.
76236:      */
75506:     for (AllFramesIter i(cx->stack.space()); ; ++i) {
75506:         JS_ASSERT(!i.done());
75506:         if (i.fp()->maybeScript() == script)
75506:             return &i.fp()->scopeChain();
75506:     }
75517:     JS_NOT_REACHED("ScriptScope: live non-held script not on stack");
75506: }
75506: 
75506: bool
75506: BreakpointSite::recompile(JSContext *cx, bool forTrap)
75506: {
75506: #ifdef JS_METHODJIT
75506:     if (script->hasJITCode()) {
75506:         Maybe<AutoCompartment> ac;
75506:         if (!forTrap) {
75506:             ac.construct(cx, ScriptScope(cx, script, scriptObject));
75506:             if (!ac.ref().enter())
75506:                 return false;
75506:         }
75506:         js::mjit::Recompiler recompiler(cx, script);
75506:         if (!recompiler.recompile())
75506:             return false;
75506:     }
75506: #endif
75506:     return true;
75506: }
75506: 
75506: bool
75506: BreakpointSite::inc(JSContext *cx)
75506: {
75506:     if (enabledCount == 0 && !trapHandler) {
75506:         JS_ASSERT(*pc == realOpcode);
75506:         *pc = JSOP_TRAP;
75506:         if (!recompile(cx, false)) {
75506:             *pc = realOpcode;
75506:             return false;
75506:         }
75506:     }
75506:     enabledCount++;
75506:     return true;
75506: }
75506: 
75506: void
75506: BreakpointSite::dec(JSContext *cx)
75506: {
75506:     JS_ASSERT(enabledCount > 0);
75506:     JS_ASSERT(*pc == JSOP_TRAP);
75506:     enabledCount--;
75506:     if (enabledCount == 0 && !trapHandler) {
75506:         *pc = realOpcode;
76236:         recompile(cx, false);  /* ignore failure */
75506:     }
75506: }
75506: 
75506: bool
75506: BreakpointSite::setTrap(JSContext *cx, JSTrapHandler handler, const Value &closure)
75506: {
75506:     if (enabledCount == 0) {
75506:         *pc = JSOP_TRAP;
75506:         if (!recompile(cx, true)) {
75506:             *pc = realOpcode;
75506:             return false;
75506:         }
75506:     }
75506:     trapHandler = handler;
75506:     trapClosure = closure;
75506:     return true;
75506: }
75506: 
75506: void
75506: BreakpointSite::clearTrap(JSContext *cx, BreakpointSiteMap::Enum *e,
75506:                           JSTrapHandler *handlerp, Value *closurep)
75506: {
75506:     if (handlerp)
75506:         *handlerp = trapHandler;
75506:     if (closurep)
75506:         *closurep = trapClosure;
75506: 
75506:     trapHandler = NULL;
75506:     trapClosure.setUndefined();
75506:     if (enabledCount == 0) {
75506:         *pc = realOpcode;
76236:         recompile(cx, true);  /* ignore failure */
75506:         destroyIfEmpty(cx->runtime, e);
75506:     }
75506: }
75506: 
75506: void
75506: BreakpointSite::destroyIfEmpty(JSRuntime *rt, BreakpointSiteMap::Enum *e)
75506: {
75506:     if (JS_CLIST_IS_EMPTY(&breakpoints) && !trapHandler) {
75506:         if (e)
75506:             e->removeFront();
75506:         else
76766:             script->compartment->breakpointSites.remove(pc);
75506:         rt->delete_(this);
75506:     }
75506: }
75506: 
75506: Breakpoint *
75506: BreakpointSite::firstBreakpoint() const
75506: {
75506:     if (JS_CLIST_IS_EMPTY(&breakpoints))
75506:         return NULL;
75506:     return Breakpoint::fromSiteLinks(JS_NEXT_LINK(&breakpoints));
75506: }
75506: 
75506: bool
75506: BreakpointSite::hasBreakpoint(Breakpoint *bp)
75506: {
75506:     for (Breakpoint *p = firstBreakpoint(); p; p = p->nextInSite())
75506:         if (p == bp)
75506:             return true;
75506:     return false;
75506: }
75506: 
75513: Breakpoint::Breakpoint(Debugger *debugger, BreakpointSite *site, JSObject *handler)
75506:     : debugger(debugger), site(site), handler(handler)
75506: {
75506:     JS_APPEND_LINK(&debuggerLinks, &debugger->breakpoints);
75506:     JS_APPEND_LINK(&siteLinks, &site->breakpoints);
75506: }
75506: 
75506: Breakpoint *
75506: Breakpoint::fromDebuggerLinks(JSCList *links)
75506: {
75506:     return (Breakpoint *) ((unsigned char *) links - offsetof(Breakpoint, debuggerLinks));
75506: }
75506: 
75506: Breakpoint *
75506: Breakpoint::fromSiteLinks(JSCList *links)
75506: {
75506:     return (Breakpoint *) ((unsigned char *) links - offsetof(Breakpoint, siteLinks));
75506: }
75506: 
75506: void
75506: Breakpoint::destroy(JSContext *cx, BreakpointSiteMap::Enum *e)
75506: {
75506:     if (debugger->enabled)
75506:         site->dec(cx);
75506:     JS_REMOVE_LINK(&debuggerLinks);
75506:     JS_REMOVE_LINK(&siteLinks);
75506:     JSRuntime *rt = cx->runtime;
75506:     site->destroyIfEmpty(rt, e);
75506:     rt->delete_(this);
75506: }
75506: 
75506: Breakpoint *
75506: Breakpoint::nextInDebugger()
75506: {
75506:     JSCList *link = JS_NEXT_LINK(&debuggerLinks);
75506:     return (link == &debugger->breakpoints) ? NULL : fromDebuggerLinks(link);
75506: }
75506: 
75506: Breakpoint *
75506: Breakpoint::nextInSite()
75506: {
75506:     JSCList *link = JS_NEXT_LINK(&siteLinks);
75506:     return (link == &site->breakpoints) ? NULL : fromSiteLinks(link);
75506: }
75506: 
75506: 
76236: /*** Debugger hook dispatch **********************************************************************/
75402: 
76226: Debugger::Debugger(JSContext *cx, JSObject *dbg)
76226:   : object(dbg), uncaughtExceptionHook(NULL), enabled(true),
76212:     frames(cx), objects(cx), heldScripts(cx), nonHeldScripts(cx)
75402: {
76226:     assertSameCompartment(cx, dbg);
76226: 
76212:     JSRuntime *rt = cx->runtime;
75452:     AutoLockGC lock(rt);
75452:     JS_APPEND_LINK(&link, &rt->debuggerList);
75506:     JS_INIT_CLIST(&breakpoints);
75451: }
75451: 
75513: Debugger::~Debugger()
75451: {
75489:     JS_ASSERT(debuggees.empty());
75452: 
76236:     /* This always happens in the GC thread, so no locking is required. */
75489:     JS_ASSERT(object->compartment()->rt->gcRunning);
75451:     JS_REMOVE_LINK(&link);
75402: }
75402: 
75413: bool
75513: Debugger::init(JSContext *cx)
75413: {
75492:     bool ok = (frames.init() &&
75492:                objects.init() &&
75492:                debuggees.init() &&
75492:                heldScripts.init() &&
75517:                nonHeldScripts.init());
75452:     if (!ok)
75452:         js_ReportOutOfMemory(cx);
75452:     return ok;
75413: }
75413: 
75425: JS_STATIC_ASSERT(uintN(JSSLOT_DEBUGFRAME_OWNER) == uintN(JSSLOT_DEBUGOBJECT_OWNER));
75492: JS_STATIC_ASSERT(uintN(JSSLOT_DEBUGFRAME_OWNER) == uintN(JSSLOT_DEBUGSCRIPT_OWNER));
75425: 
75513: Debugger *
75513: Debugger::fromChildJSObject(JSObject *obj)
75425: {
75513:     JS_ASSERT(obj->clasp == &DebuggerFrame_class ||
75513:               obj->clasp == &DebuggerObject_class ||
75513:               obj->clasp == &DebuggerScript_class);
75425:     JSObject *dbgobj = &obj->getReservedSlot(JSSLOT_DEBUGOBJECT_OWNER).toObject();
75425:     return fromJSObject(dbgobj);
75425: }
75425: 
75413: bool
75513: Debugger::getScriptFrame(JSContext *cx, StackFrame *fp, Value *vp)
75413: {
75425:     JS_ASSERT(fp->isScriptFrame());
75413:     FrameMap::AddPtr p = frames.lookupForAdd(fp);
75413:     if (!p) {
76236:         /* Create and populate the Debugger.Frame object. */
75413:         JSObject *proto = &object->getReservedSlot(JSSLOT_DEBUG_FRAME_PROTO).toObject();
75513:         JSObject *frameobj =
75513:             NewNonFunction<WithProto::Given>(cx, &DebuggerFrame_class, proto, NULL);
75413:         if (!frameobj || !frameobj->ensureClassReservedSlots(cx))
75413:             return false;
75413:         frameobj->setPrivate(fp);
75417:         frameobj->setReservedSlot(JSSLOT_DEBUGFRAME_OWNER, ObjectValue(*object));
75418: 
75413:         if (!frames.add(p, fp, frameobj)) {
75413:             js_ReportOutOfMemory(cx);
75413:             return false;
75413:         }
75413:     }
75413:     vp->setObject(*p->value);
75413:     return true;
75413: }
75413: 
76234: JSObject *
76234: Debugger::getHook(Hook hook) const
76234: {
76234:     JS_ASSERT(hook >= 0 && hook < HookCount);
76234:     const Value &v = object->getReservedSlot(JSSLOT_DEBUG_HOOK_START + hook);
76234:     return v.isUndefined() ? NULL : &v.toObject();
76234: }
76234: 
76234: bool
77173: Debugger::hasAnyLiveHooks(JSContext *cx) const
76234: {
77171:     if (!enabled)
77171:         return false;
77171: 
77171:     if (getHook(OnDebuggerStatement) ||
76234:         getHook(OnExceptionUnwind) ||
76234:         getHook(OnNewScript) ||
77171:         getHook(OnEnterFrame))
77173:     {
77171:         return true;
77173:     }
77173: 
77173:     /* If any breakpoints are in live scripts, return true. */
77173:     for (Breakpoint *bp = firstBreakpoint(); bp; bp = bp->nextInDebugger()) {
77173:         /*
77173:          * If holder is non-null, examine it to see if the script will be
77173:          * collected. If holder is null, then bp->site->script is an eval
77173:          * script on the stack, so it is definitely live.
77173:          */
77173:         JSObject *holder = bp->site->getScriptObject();
77173:         if (!holder || !IsAboutToBeFinalized(cx, holder))
77171:             return true;
77173:     }
77171: 
77171:     for (FrameMap::Range r = frames.all(); !r.empty(); r.popFront()) {
77171:         if (!r.front().value->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER).isUndefined())
77171:             return true;
77171:     }
77171: 
77171:     return false;
76234: }
76234: 
75413: void
75523: Debugger::slowPathOnEnterFrame(JSContext *cx)
75523: {
76236:     /* Build the list of recipients. */
75523:     AutoValueVector triggered(cx);
75523:     GlobalObject *global = cx->fp()->scopeChain().getGlobal();
75523:     if (GlobalObject::DebuggerVector *debuggers = global->getDebuggers()) {
75523:         for (Debugger **p = debuggers->begin(); p != debuggers->end(); p++) {
75523:             Debugger *dbg = *p;
75523:             JS_ASSERT(dbg->observesFrame(cx->fp()));
75523:             if (dbg->observesEnterFrame() && !triggered.append(ObjectValue(*dbg->toJSObject())))
75523:                 return;
75523:         }
75523:     }
75523: 
76236:     /* Deliver the event, checking again as in dispatchHook. */
75523:     for (Value *p = triggered.begin(); p != triggered.end(); p++) {
75523:         Debugger *dbg = Debugger::fromJSObject(&p->toObject());
75523:         if (dbg->debuggees.has(global) && dbg->observesEnterFrame())
76226:             dbg->fireEnterFrame(cx);
75523:     }
75523: }
75523: 
75523: void
75523: Debugger::slowPathOnLeaveFrame(JSContext *cx)
75413: {
75415:     StackFrame *fp = cx->fp();
75452:     GlobalObject *global = fp->scopeChain().getGlobal();
75452: 
76236:     /*
76236:      * FIXME This notifies only current debuggers, so it relies on a hack in
76236:      * Debugger::removeDebuggeeGlobal to make sure only current debuggers have
76236:      * Frame objects with .live === true.
76236:      */
75513:     if (GlobalObject::DebuggerVector *debuggers = global->getDebuggers()) {
75513:         for (Debugger **p = debuggers->begin(); p != debuggers->end(); p++) {
75513:             Debugger *dbg = *p;
75413:             if (FrameMap::Ptr p = dbg->frames.lookup(fp)) {
77171:                 StackFrame *frame = p->key;
75413:                 JSObject *frameobj = p->value;
75413:                 frameobj->setPrivate(NULL);
77171: 
77171:                 /* If this frame had an onStep handler, adjust the script's count. */
77171:                 if (!frameobj->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER).isUndefined() &&
77171:                     frame->isScriptFrame()) {
77171:                     frame->script()->changeStepModeCount(cx, -1);
77171:                 }
77171: 
75413:                 dbg->frames.remove(p);
75413:             }
75413:         }
75413:     }
75506: 
76236:     /*
76236:      * If this is an eval frame, then from the debugger's perspective the
76236:      * script is about to be destroyed. Remove any breakpoints in it.
76236:      */
75506:     if (fp->isEvalFrame()) {
75506:         JSScript *script = fp->script();
76766:         script->compartment->clearBreakpointsIn(cx, NULL, script, NULL);
75506:     }
75452: }
75413: 
75418: bool
75513: Debugger::wrapDebuggeeValue(JSContext *cx, Value *vp)
75418: {
75418:     assertSameCompartment(cx, object);
75418: 
75495:     if (vp->isObject()) {
75495:         JSObject *obj = &vp->toObject();
75418: 
75495:         ObjectWeakMap::AddPtr p = objects.lookupForAdd(obj);
75418:         if (p) {
75418:             vp->setObject(*p->value);
75418:         } else {
76236:             /* Create a new Debugger.Object for obj. */
75428:             JSObject *proto = &object->getReservedSlot(JSSLOT_DEBUG_OBJECT_PROTO).toObject();
75513:             JSObject *dobj =
75513:                 NewNonFunction<WithProto::Given>(cx, &DebuggerObject_class, proto, NULL);
75418:             if (!dobj || !dobj->ensureClassReservedSlots(cx))
75418:                 return false;
75495:             dobj->setPrivate(obj);
75418:             dobj->setReservedSlot(JSSLOT_DEBUGOBJECT_OWNER, ObjectValue(*object));
75495:             if (!objects.relookupOrAdd(p, obj, dobj)) {
75418:                 js_ReportOutOfMemory(cx);
75418:                 return false;
75418:             }
75418:             vp->setObject(*dobj);
75418:         }
75495:     } else if (!cx->compartment->wrap(cx, vp)) {
75495:         vp->setUndefined();
75495:         return false;
75418:     }
75495: 
75418:     return true;
75418: }
75418: 
75418: bool
75513: Debugger::unwrapDebuggeeValue(JSContext *cx, Value *vp)
75418: {
75427:     assertSameCompartment(cx, object, *vp);
75418:     if (vp->isObject()) {
75418:         JSObject *dobj = &vp->toObject();
75513:         if (dobj->clasp != &DebuggerObject_class) {
75418:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_EXPECTED_TYPE,
75513:                                  "Debugger", "Debugger.Object", dobj->clasp->name);
75418:             return false;
75418:         }
75456: 
75456:         Value owner = dobj->getReservedSlot(JSSLOT_DEBUGOBJECT_OWNER);
75456:         if (owner.toObjectOrNull() != object) {
75456:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
75456:                                  owner.isNull()
75456:                                  ? JSMSG_DEBUG_OBJECT_PROTO
75456:                                  : JSMSG_DEBUG_OBJECT_WRONG_OWNER);
75456:             return false;
75456:         }
75456: 
75495:         vp->setObject(*(JSObject *) dobj->getPrivate());
75418:     }
75418:     return true;
75418: }
75418: 
75402: JSTrapStatus
75513: Debugger::handleUncaughtException(AutoCompartment &ac, Value *vp, bool callHook)
75402: {
75404:     JSContext *cx = ac.context;
75404:     if (cx->isExceptionPending()) {
75404:         if (callHook && uncaughtExceptionHook) {
75404:             Value fval = ObjectValue(*uncaughtExceptionHook);
75404:             Value exc = cx->getPendingException();
75404:             Value rv;
75404:             cx->clearPendingException();
76829:             if (Invoke(cx, ObjectValue(*object), fval, 1, &exc, &rv))
75518:                 return vp ? parseResumptionValue(ac, true, rv, vp, false) : JSTRAP_CONTINUE;
75404:         }
75404: 
75404:         if (cx->isExceptionPending()) {
75402:             JS_ReportPendingException(cx);
75404:             cx->clearPendingException();
75404:         }
75404:     }
75450:     ac.leave();
75402:     return JSTRAP_ERROR;
75402: }
75402: 
75427: bool
75513: Debugger::newCompletionValue(AutoCompartment &ac, bool ok, Value val, Value *vp)
75427: {
75427:     JS_ASSERT_IF(ok, !ac.context->isExceptionPending());
75427: 
75427:     JSContext *cx = ac.context;
75427:     jsid key;
75427:     if (ok) {
75427:         ac.leave();
75427:         key = ATOM_TO_JSID(cx->runtime->atomState.returnAtom);
75427:     } else if (cx->isExceptionPending()) {
75427:         key = ATOM_TO_JSID(cx->runtime->atomState.throwAtom);
75427:         val = cx->getPendingException();
75427:         cx->clearPendingException();
75427:         ac.leave();
75427:     } else {
75427:         ac.leave();
75427:         vp->setNull();
75427:         return true;
75427:     }
75427: 
75427:     JSObject *obj = NewBuiltinClassInstance(cx, &js_ObjectClass);
75427:     if (!obj ||
75427:         !wrapDebuggeeValue(cx, &val) ||
75443:         !DefineNativeProperty(cx, obj, key, val, PropertyStub, StrictPropertyStub,
75443:                               JSPROP_ENUMERATE, 0, 0))
75427:     {
75427:         return false;
75427:     }
75427:     vp->setObject(*obj);
75427:     return true;
75427: }
75427: 
75402: JSTrapStatus
75513: Debugger::parseResumptionValue(AutoCompartment &ac, bool ok, const Value &rv, Value *vp,
75404:                                bool callHook)
75402: {
75402:     vp->setUndefined();
75402:     if (!ok)
75404:         return handleUncaughtException(ac, vp, callHook);
75450:     if (rv.isUndefined()) {
75450:         ac.leave();
75402:         return JSTRAP_CONTINUE;
75450:     }
75450:     if (rv.isNull()) {
75450:         ac.leave();
75402:         return JSTRAP_ERROR;
75450:     }
75402: 
76236:     /* Check that rv is {return: val} or {throw: val}. */
75402:     JSContext *cx = ac.context;
75402:     JSObject *obj;
75402:     const Shape *shape;
75402:     jsid returnId = ATOM_TO_JSID(cx->runtime->atomState.returnAtom);
75402:     jsid throwId = ATOM_TO_JSID(cx->runtime->atomState.throwAtom);
75461:     bool okResumption = rv.isObject();
75461:     if (okResumption) {
75461:         obj = &rv.toObject();
75461:         okResumption = obj->isObject();
75461:     }
75461:     if (okResumption) {
75461:         shape = obj->lastProperty();
75461:         okResumption = shape->previous() &&
75461:              !shape->previous()->previous() &&
75461:              (shape->propid == returnId || shape->propid == throwId) &&
75461:              shape->isDataDescriptor();
75461:     }
75461:     if (!okResumption) {
75402:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_BAD_RESUMPTION);
75404:         return handleUncaughtException(ac, vp, callHook);
75402:     }
75402: 
75427:     if (!js_NativeGet(cx, obj, obj, shape, 0, vp) || !unwrapDebuggeeValue(cx, vp))
75404:         return handleUncaughtException(ac, vp, callHook);
75402: 
75402:     ac.leave();
75427:     if (!cx->compartment->wrap(cx, vp)) {
75427:         vp->setUndefined();
75402:         return JSTRAP_ERROR;
75402:     }
75443:     return shape->propid == returnId ? JSTRAP_RETURN : JSTRAP_THROW;
75402: }
75402: 
75402: bool
75402: CallMethodIfPresent(JSContext *cx, JSObject *obj, const char *name, int argc, Value *argv,
75402:                     Value *rval)
75402: {
75402:     rval->setUndefined();
75448:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
75402:     Value fval;
75402:     return atom &&
75402:            js_GetMethod(cx, obj, ATOM_TO_JSID(atom), JSGET_NO_METHOD_BARRIER, &fval) &&
75402:            (!js_IsCallable(fval) ||
76829:             Invoke(cx, ObjectValue(*obj), fval, argc, argv, rval));
75402: }
75402: 
76226: JSTrapStatus
76226: Debugger::fireDebuggerStatement(JSContext *cx, Value *vp)
75439: {
76234:     JSObject *hook = getHook(OnDebuggerStatement);
76226:     JS_ASSERT(hook);
76226:     JS_ASSERT(hook->isCallable());
76226: 
76236:     /* Grab cx->fp() before pushing a dummy frame. */
75415:     StackFrame *fp = cx->fp();
76226:     AutoCompartment ac(cx, object);
75402:     if (!ac.enter())
75402:         return JSTRAP_ERROR;
75402: 
75413:     Value argv[1];
75413:     if (!getScriptFrame(cx, fp, argv))
75450:         return handleUncaughtException(ac, vp, false);
75413: 
75402:     Value rv;
76829:     bool ok = Invoke(cx, ObjectValue(*object), ObjectValue(*hook), 1, argv, &rv);
75402:     return parseResumptionValue(ac, ok, rv, vp);
75402: }
75402: 
76226: JSTrapStatus
76226: Debugger::fireExceptionUnwind(JSContext *cx, Value *vp)
75439: {
76234:     JSObject *hook = getHook(OnExceptionUnwind);
76226:     JS_ASSERT(hook);
76226:     JS_ASSERT(hook->isCallable());
76226: 
75439:     StackFrame *fp = cx->fp();
75439:     Value exc = cx->getPendingException();
75439:     cx->clearPendingException();
76226: 
76226:     AutoCompartment ac(cx, object);
75439:     if (!ac.enter())
75439:         return JSTRAP_ERROR;
75439: 
75439:     Value argv[2];
75439:     argv[1] = exc;
75439:     if (!getScriptFrame(cx, fp, &argv[0]) || !wrapDebuggeeValue(cx, &argv[1]))
75450:         return handleUncaughtException(ac, vp, false);
75439: 
75439:     Value rv;
76829:     bool ok = Invoke(cx, ObjectValue(*object), ObjectValue(*hook), 2, argv, &rv);
75439:     JSTrapStatus st = parseResumptionValue(ac, ok, rv, vp);
75439:     if (st == JSTRAP_CONTINUE)
75450:         cx->setPendingException(exc);
75439:     return st;
75439: }
75439: 
75518: void
76226: Debugger::fireEnterFrame(JSContext *cx)
75523: {
76234:     JSObject *hook = getHook(OnEnterFrame);
76226:     JS_ASSERT(hook);
76226:     JS_ASSERT(hook->isCallable());
76226: 
75523:     StackFrame *fp = cx->fp();
76226:     AutoCompartment ac(cx, object);
75523:     if (!ac.enter())
75523:         return;
75523: 
75523:     Value argv[1];
75523:     if (!getScriptFrame(cx, fp, &argv[0])) {
75523:         handleUncaughtException(ac, NULL, false);
75523:         return;
75523:     }
75523:     Value rv;
76829:     if (!Invoke(cx, ObjectValue(*object), ObjectValue(*hook), 1, argv, &rv))
75523:         handleUncaughtException(ac, NULL, true);
75523: }
75523: 
75523: void
76226: Debugger::fireNewScript(JSContext *cx, JSScript *script, JSObject *obj, NewScriptKind kind)
75518: {
76234:     JSObject *hook = getHook(OnNewScript);
76226:     JS_ASSERT(hook);
76226:     JS_ASSERT(hook->isCallable());
76226: 
76226:     AutoCompartment ac(cx, object);
75518:     if (!ac.enter())
75518:         return;
75518: 
75518:     JSObject *dsobj =
75518:         kind == NewHeldScript ? wrapHeldScript(cx, script, obj) : wrapNonHeldScript(cx, script);
75518:     if (!dsobj) {
75518:         handleUncaughtException(ac, NULL, false);
75518:         return;
75518:     }
75518: 
75518:     Value argv[1];
75518:     argv[0].setObject(*dsobj);
75518:     Value rv;
76829:     if (!Invoke(cx, ObjectValue(*object), ObjectValue(*hook), 1, argv, &rv))
75518:         handleUncaughtException(ac, NULL, true);
75518: }
75518: 
75439: JSTrapStatus
76226: Debugger::dispatchHook(JSContext *cx, js::Value *vp, Hook which)
75402: {
76226:     JS_ASSERT(which == OnDebuggerStatement || which == OnExceptionUnwind);
76226: 
76236:     /*
76236:      * Determine which debuggers will receive this event, and in what order.
76236:      * Make a copy of the list, since the original is mutable and we will be
76236:      * calling into arbitrary JS.
76236:      *
76236:      * Note: In the general case, 'triggered' contains references to objects in
76236:      * different compartments--every compartment *except* this one.
76236:      */
75402:     AutoValueVector triggered(cx);
75452:     GlobalObject *global = cx->fp()->scopeChain().getGlobal();
75513:     if (GlobalObject::DebuggerVector *debuggers = global->getDebuggers()) {
75513:         for (Debugger **p = debuggers->begin(); p != debuggers->end(); p++) {
75513:             Debugger *dbg = *p;
76234:             if (dbg->enabled && dbg->getHook(which)) {
75402:                 if (!triggered.append(ObjectValue(*dbg->toJSObject())))
75402:                     return JSTRAP_ERROR;
75402:             }
75402:         }
75452:     }
75402: 
76236:     /*
76236:      * Deliver the event to each debugger, checking again to make sure it
76236:      * should still be delivered.
76236:      */
75402:     for (Value *p = triggered.begin(); p != triggered.end(); p++) {
75513:         Debugger *dbg = Debugger::fromJSObject(&p->toObject());
76234:         if (dbg->debuggees.has(global) && dbg->enabled && dbg->getHook(which)) {
76226:             JSTrapStatus st = (which == OnDebuggerStatement)
76226:                               ? dbg->fireDebuggerStatement(cx, vp)
76226:                               : dbg->fireExceptionUnwind(cx, vp);
75402:             if (st != JSTRAP_CONTINUE)
75402:                 return st;
75402:         }
75402:     }
75402:     return JSTRAP_CONTINUE;
75402: }
75402: 
75518: static bool
75518: AddNewScriptRecipients(GlobalObject::DebuggerVector *src, AutoValueVector *dest)
75518: {
75518:     bool wasEmpty = dest->length() == 0;
75518:     for (Debugger **p = src->begin(); p != src->end(); p++) {
75518:         Debugger *dbg = *p;
75518:         Value v = ObjectValue(*dbg->toJSObject());
75518:         if (dbg->observesNewScript() &&
75518:             (wasEmpty || Find(dest->begin(), dest->end(), v) == dest->end()) &&
75518:             !dest->append(v))
75518:         {
75518:             return false;
75518:         }
75518:     }
75518:     return true;
75518: }
75518: 
75518: void
75518: Debugger::slowPathOnNewScript(JSContext *cx, JSScript *script, JSObject *obj, NewScriptKind kind)
75518: {
76236:     /*
76236:      * Build the list of recipients. For compile-and-go scripts, this is the
76236:      * same as the generic Debugger::dispatchHook code, but non-compile-and-go
76236:      * scripts are not tied to particular globals. We deliver them to every
76236:      * debugger observing any global in the script's compartment.
76236:      */
75518:     AutoValueVector triggered(cx);
75518:     GlobalObject *global;
75518:     if (script->compileAndGo) {
75518:         global = obj->getGlobal();
75518:         if (GlobalObject::DebuggerVector *debuggers = global->getDebuggers()) {
75518:             if (!AddNewScriptRecipients(debuggers, &triggered))
75518:                 return;
75518:         }
75518:     } else {
75518:         global = NULL;
76766:         GlobalObjectSet &debuggees = script->compartment->getDebuggees();
75518:         for (GlobalObjectSet::Range r = debuggees.all(); !r.empty(); r.popFront()) {
75518:             if (!AddNewScriptRecipients(r.front()->getDebuggers(), &triggered))
75518:                 return;
75518:         }
75518:     }
75518: 
76236:     /*
76236:      * Deliver the event to each debugger, checking again as in
76236:      * Debugger::dispatchHook.
76236:      */
75518:     for (Value *p = triggered.begin(); p != triggered.end(); p++) {
75518:         Debugger *dbg = Debugger::fromJSObject(&p->toObject());
76234:         if ((!global || dbg->debuggees.has(global)) && dbg->enabled && dbg->getHook(OnNewScript))
76226:             dbg->fireNewScript(cx, script, obj, kind);
75518:     }
75518: }
75518: 
75506: JSTrapStatus
75513: Debugger::onTrap(JSContext *cx, Value *vp)
75506: {
75506:     StackFrame *fp = cx->fp();
75506:     GlobalObject *scriptGlobal = fp->scopeChain().getGlobal();
75506:     jsbytecode *pc = cx->regs().pc;
75506:     BreakpointSite *site = cx->compartment->getBreakpointSite(pc);
75506:     JSOp op = site->realOpcode;
75506: 
76236:     /* Build list of breakpoint handlers. */
75506:     Vector<Breakpoint *> triggered(cx);
75506:     for (Breakpoint *bp = site->firstBreakpoint(); bp; bp = bp->nextInSite()) {
75506:         if (!triggered.append(bp))
75506:             return JSTRAP_ERROR;
75506:     }
75506: 
75506:     Value frame = UndefinedValue();
75506:     for (Breakpoint **p = triggered.begin(); p != triggered.end(); p++) {
75506:         Breakpoint *bp = *p;
75506: 
76236:         /* Handlers can clear breakpoints. Check that bp still exists. */
75506:         if (!site || !site->hasBreakpoint(bp))
75506:             continue;
75506: 
75513:         Debugger *dbg = bp->debugger;
75506:         if (dbg->enabled && dbg->debuggees.lookup(scriptGlobal)) {
75506:             AutoCompartment ac(cx, dbg->object);
75506:             if (!ac.enter())
75506:                 return JSTRAP_ERROR;
75506: 
75506:             Value argv[1];
75506:             if (!dbg->getScriptFrame(cx, fp, &argv[0]))
75506:                 return dbg->handleUncaughtException(ac, vp, false);
75506:             Value rv;
75506:             bool ok = CallMethodIfPresent(cx, bp->handler, "hit", 1, argv, &rv);
75506:             JSTrapStatus st = dbg->parseResumptionValue(ac, ok, rv, vp, true);
75506:             if (st != JSTRAP_CONTINUE)
75506:                 return st;
75506: 
76236:             /* Calling JS code invalidates site. Reload it. */
75506:             site = cx->compartment->getBreakpointSite(pc);
75506:         }
75506:     }
75506: 
75506:     if (site && site->trapHandler) {
75506:         JSTrapStatus st = site->trapHandler(cx, fp->script(), pc, Jsvalify(vp),
75506:                                             Jsvalify(site->trapClosure));
75506:         if (st != JSTRAP_CONTINUE)
75506:             return st;
75506:     }
75506: 
76236:     /* By convention, return the true op to the interpreter in vp. */
75506:     vp->setInt32(op);
75506:     return JSTRAP_CONTINUE;
75506: }
75506: 
77171: JSTrapStatus
77171: Debugger::onSingleStep(JSContext *cx, Value *vp)
77171: {
77171:     StackFrame *fp = cx->fp();
77171: 
77171:     /*
77171:      * We may be stepping over a JSOP_EXCEPTION, that pushes the context's
77171:      * pending exception for a 'catch' clause to handle. Don't let the
77171:      * onStep handlers mess with that (other than by returning a resumption
77171:      * value).
77171:      */
77171:     Value exception = UndefinedValue();
77171:     bool exceptionPending = cx->isExceptionPending();
77171:     if (exceptionPending) {
77171:         exception = cx->getPendingException();
77171:         cx->clearPendingException();
77171:     }
77171: 
77171:     /* We should only receive single-step traps for scripted frames. */
77171:     JS_ASSERT(fp->isScriptFrame());
77171: 
77171:     /*
77171:      * Build list of Debugger.Frame instances referring to this frame with
77171:      * onStep handlers.
77171:      */
77171:     AutoObjectVector frames(cx);
77171:     GlobalObject *global = fp->scopeChain().getGlobal();
77171:     if (GlobalObject::DebuggerVector *debuggers = global->getDebuggers()) {
77171:         for (Debugger **d = debuggers->begin(); d != debuggers->end(); d++) {
77171:             Debugger *dbg = *d;
77171:             if (FrameMap::Ptr p = dbg->frames.lookup(fp)) {
77171:                 JSObject *frame = p->value;
77171:                 if (!frame->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER).isUndefined() &&
77171:                     !frames.append(frame))
77171:                     return JSTRAP_ERROR;
77171:             }
77171:         }
77171:     }
77171: 
77171: #ifdef DEBUG
77171:     /*
77171:      * Validate the single-step count on this frame's script, to ensure that
77171:      * we're not receiving traps we didn't ask for. Even when frames is
77171:      * non-empty (and thus we know this trap was requested), do the check
77171:      * anyway, to make sure the count has the correct non-zero value.
77171:      *
77171:      * The converse --- ensuring that we do receive traps when we should --- can
77171:      * be done with unit tests.
77171:      */
77171:     {
77171:         uint32 stepperCount = 0;
77171:         JSScript *trappingScript = fp->script();
77171:         if (GlobalObject::DebuggerVector *debuggers = global->getDebuggers()) {
77171:             for (Debugger **p = debuggers->begin(); p != debuggers->end(); p++) {
77171:                 Debugger *dbg = *p;
77171:                 for (FrameMap::Range r = dbg->frames.all(); !r.empty(); r.popFront()) {
77171:                     StackFrame *frame = r.front().key;
77171:                     JSObject *frameobj = r.front().value;
77171:                     if (frame->isScriptFrame() &&
77171:                         frame->script() == trappingScript &&
77171:                         !frameobj->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER).isUndefined())
77171:                     {
77171:                         stepperCount++;
77171:                     }
77171:                 }
77171:             }
77171:         }
77171:         if (trappingScript->compileAndGo)
77171:             JS_ASSERT(stepperCount == trappingScript->stepModeCount());
77171:         else
77171:             JS_ASSERT(stepperCount <= trappingScript->stepModeCount());
77171:     }
77171: #endif
77171: 
77171:     /* Call all the onStep handlers we found. */
77171:     for (JSObject **p = frames.begin(); p != frames.end(); p++) {
77171:         JSObject *frame = *p;
77171:         Debugger *dbg = Debugger::fromChildJSObject(frame);
77171:         AutoCompartment ac(cx, dbg->object);
77171:         if (!ac.enter())
77171:             return JSTRAP_ERROR;
77171:         const Value &handler = frame->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER);
77171:         Value rval;
77171:         bool ok = Invoke(cx, ObjectValue(*frame), handler, 0, NULL, &rval);
77171:         JSTrapStatus st = dbg->parseResumptionValue(ac, ok, rval, vp);
77171:         if (st != JSTRAP_CONTINUE)
77171:             return st;
77171:     }
77171: 
77171:     vp->setUndefined();
77171:     if (exceptionPending)
77171:         cx->setPendingException(exception);
77171:     return JSTRAP_CONTINUE;
77171: }
77171: 
75466: 
76236: /*** Debugger JSObjects **************************************************************************/
75402: 
75495: void
76248: Debugger::markKeysInCompartment(JSTracer *tracer, const ObjectWeakMap &map)
75510: {
75510:     JSCompartment *comp = tracer->context->runtime->gcCurrentCompartment;
75510:     JS_ASSERT(comp);
75510: 
76261:     /*
76261:      * WeakMap::Range is deliberately private, to discourage C++ code from
76261:      * enumerating WeakMap keys. However in this case we need access, so we
76261:      * make a base-class reference. Range is public in HashMap.
76261:      */
75510:     typedef HashMap<JSObject *, JSObject *, DefaultHasher<JSObject *>, RuntimeAllocPolicy> Map;
76248:     const Map &storage = map;
75510:     for (Map::Range r = storage.all(); !r.empty(); r.popFront()) {
75510:         JSObject *key = r.front().key;
75510:         if (key->compartment() == comp && IsAboutToBeFinalized(tracer->context, key))
75510:             js::gc::MarkObject(tracer, *key, "cross-compartment WeakMap key");
75510:     }
75510: }
75510: 
76236: /*
76236:  * Ordinarily, WeakMap keys and values are marked because at some point it was
76236:  * discovered that the WeakMap was live; that is, some object containing the
76236:  * WeakMap was marked during mark phase.
76236:  *
76236:  * However, during single-compartment GC, we have to do something about
76236:  * cross-compartment WeakMaps in other compartments. Since those compartments
76236:  * aren't being GC'd, the WeakMaps definitely will not be found during mark
76236:  * phase. If their keys and values might need to be marked, we have to do it
76236:  * manually.
76236:  *
76236:  * Each Debugger object keeps two cross-compartment WeakMaps: objects and
76236:  * heldScripts.  Both have the nice property that all their values are in the
76236:  * same compartment as the Debugger object, so we only need to mark the
76236:  * keys. We must simply mark all keys that are in the compartment being GC'd.
76236:  *
76236:  * We must scan all Debugger objects regardless of whether they *currently*
76236:  * have any debuggees in the compartment being GC'd, because the WeakMap
76236:  * entries persist even when debuggees are removed.
76236:  *
76236:  * This happens during the initial mark phase, not iterative marking, because
76236:  * all the edges being reported here are strong references.
76236:  */
75510: void
75513: Debugger::markCrossCompartmentDebuggerObjectReferents(JSTracer *tracer)
75495: {
75510:     JSRuntime *rt = tracer->context->runtime;
75510:     JSCompartment *comp = rt->gcCurrentCompartment;
75495: 
76236:     /*
76236:      * Mark all objects in comp that are referents of Debugger.Objects in other
76236:      * compartments.
76236:      */
75510:     for (JSCList *p = &rt->debuggerList; (p = JS_NEXT_LINK(p)) != &rt->debuggerList;) {
75513:         Debugger *dbg = Debugger::fromLinks(p);
75496:         if (dbg->object->compartment() != comp) {
75510:             markKeysInCompartment(tracer, dbg->objects);
75510:             markKeysInCompartment(tracer, dbg->heldScripts);
75495:         }
75495:     }
75495: }
75495: 
76236: /*
76236:  * This method has two tasks:
76236:  *   1. Mark Debugger objects that are unreachable except for debugger hooks that
76236:  *      may yet be called.
76236:  *   2. Mark breakpoint handlers.
76236:  *
76256:  * This happens during the iterative part of the GC mark phase. This method
76256:  * returns true if it has to mark anything; GC calls it repeatedly until it
76256:  * returns false.
76236:  */
75402: bool
76255: Debugger::markAllIteratively(GCMarker *trc, JSGCInvocationKind gckind)
75402: {
75452:     bool markedAny = false;
75452: 
76236:     /*
77173:      * Find all Debugger objects in danger of GC. This code is a little
76236:      * convoluted since the easiest way to find them is via their debuggees.
76236:      */
77173:     JSContext *cx = trc->context;
77173:     JSRuntime *rt = cx->runtime;
75510:     JSCompartment *comp = rt->gcCurrentCompartment;
75402:     for (JSCompartment **c = rt->compartments.begin(); c != rt->compartments.end(); c++) {
75402:         JSCompartment *dc = *c;
75402: 
77173:         /* If dc is being collected, mark jsdbgapi.h trap closures in it. */
75506:         if (!comp || dc == comp)
77173:             markedAny = markedAny | dc->markTrapClosuresIteratively(trc);
75506: 
76236:         /*
76236:          * If this is a single-compartment GC, no compartment can debug itself, so skip
77173:          * |comp|. If it's a global GC, then search every compartment.
76236:          */
76256:         if (comp && dc == comp)
76256:             continue;
76256: 
75452:         const GlobalObjectSet &debuggees = dc->getDebuggees();
75452:         for (GlobalObjectSet::Range r = debuggees.all(); !r.empty(); r.popFront()) {
75452:             GlobalObject *global = r.front();
75452: 
76236:             /*
76236:              * Every debuggee has at least one debugger, so in this case
76236:              * getDebuggers can't return NULL.
76236:              */
75513:             const GlobalObject::DebuggerVector *debuggers = global->getDebuggers();
75487:             JS_ASSERT(debuggers);
75513:             for (Debugger **p = debuggers->begin(); p != debuggers->end(); p++) {
75513:                 Debugger *dbg = *p;
75402: 
76236:                 /*
76236:                  * dbg is a Debugger with at least one debuggee. Check three things:
76236:                  *   - dbg is actually in a compartment being GC'd
76236:                  *   - it isn't already marked
76236:                  *   - it actually has hooks that might be called
76236:                  */
77173:                 JSObject *dbgobj = dbg->toJSObject();
77173:                 if (comp && comp != dbgobj->compartment())
77173:                     continue;
77173: 
77173:                 bool dbgMarked = !IsAboutToBeFinalized(cx, dbgobj);
77173:                 if (!dbgMarked && dbg->hasAnyLiveHooks(cx)) {
76236:                     /*
76236:                      * obj could be reachable only via its live, enabled
76236:                      * debugger hooks, which may yet be called.
76236:                      */
77173:                     MarkObject(trc, *dbgobj, "enabled Debugger");
75402:                     markedAny = true;
77173:                     dbgMarked = true;
77173:                 }
77173: 
77173:                 if (dbgMarked) {
77173:                     /* Search for breakpoints to mark. */
77173:                     for (Breakpoint *bp = dbg->firstBreakpoint(); bp; bp = bp->nextInDebugger()) {
77173:                         JSObject *scriptObject = bp->site->getScriptObject();
77173:                         if (!scriptObject || !IsAboutToBeFinalized(cx, scriptObject)) {
77173:                             /*
77173:                              * The debugger and the script are both live.
77173:                              * Therefore the breakpoint handler is live.
77173:                              */
77173:                             JSObject *handler = bp->getHandler();
77173:                             if (IsAboutToBeFinalized(cx, handler)) {
77173:                                 MarkObject(trc, *bp->getHandler(), "breakpoint handler");
77173:                                 markedAny = true;
77173:                             }
77173:                         }
77173:                     }
75402:                 }
75402:             }
75418:         }
75402:     }
75402:     return markedAny;
75402: }
75402: 
75402: void
75513: Debugger::traceObject(JSTracer *trc, JSObject *obj)
75402: {
75513:     if (Debugger *dbg = Debugger::fromJSObject(obj))
75486:         dbg->trace(trc);
75486: }
75486: 
75486: void
75513: Debugger::trace(JSTracer *trc)
75486: {
75486:     if (uncaughtExceptionHook)
75486:         MarkObject(trc, *uncaughtExceptionHook, "hooks");
75413: 
76236:     /*
77171:      * Mark Debugger.Frame objects. These are all reachable from JS, because the
77171:      * corresponding StackFrames are still on the stack.
77171:      *
77171:      * (Once we support generator frames properly, we will need
77171:      * weakly-referenced Debugger.Frame objects as well, for suspended generator
77171:      * frames.)
76236:      */
75487:     for (FrameMap::Range r = frames.all(); !r.empty(); r.popFront()) {
75487:         JSObject *frameobj = r.front().value;
75449:         JS_ASSERT(frameobj->getPrivate());
75513:         MarkObject(trc, *frameobj, "live Debugger.Frame");
75413:     }
75486: 
76236:     /* Trace the referent -> Debugger.Object weak map. */
75486:     objects.trace(trc);
75492: 
76236:     /*
76236:      * Trace the weak map from JSFunctions and "Script" JSObjects to
76236:      * Debugger.Script objects.
76236:      */
75492:     heldScripts.trace(trc);
75492: 
76236:     /* Trace the map for non-held scripts, which are explicitly freed. */
75517:     for (ScriptMap::Range r = nonHeldScripts.all(); !r.empty(); r.popFront()) {
75492:         JSObject *scriptobj = r.front().value;
75492: 
76236:         /*
76236:          * nonHeldScripts should only refer to Debugger.Script objects for
76236:          * scripts that haven't been freed yet.
76236:          */
75492:         JS_ASSERT(scriptobj->getPrivate());
75513:         MarkObject(trc, *scriptobj, "live eval Debugger.Script");
75492:     }
75413: }
75413: 
75413: void
75513: Debugger::sweepAll(JSContext *cx)
75413: {
75489:     JSRuntime *rt = cx->runtime;
76256:     JS_ASSERT(!rt->gcCurrentCompartment);
76256: 
75451:     for (JSCList *p = &rt->debuggerList; (p = JS_NEXT_LINK(p)) != &rt->debuggerList;) {
75513:         Debugger *dbg = Debugger::fromLinks(p);
75452: 
76256:         if (IsAboutToBeFinalized(cx, dbg->object)) {
76236:             /*
76256:              * dbg is being GC'd. Detach it from its debuggees. In the case of
76256:              * runtime-wide GC, the debuggee might be GC'd too. Since detaching
76256:              * requires access to both objects, this must be done before
76256:              * finalize time. However, in a per-compartment GC, it is
76256:              * impossible for both objects to be GC'd (since they are in
76256:              * different compartments), so in that case we just wait for
76236:              * Debugger::finalize.
76236:              */
75470:             for (GlobalObjectSet::Enum e(dbg->debuggees); !e.empty(); e.popFront())
75489:                 dbg->removeDebuggeeGlobal(cx, e.front(), NULL, &e);
75470:         }
75470: 
75402:     }
75452: 
75505:     for (JSCompartment **c = rt->compartments.begin(); c != rt->compartments.end(); c++) {
76236:         /* For each debuggee being GC'd, detach it from all its debuggers. */
75505:         GlobalObjectSet &debuggees = (*c)->getDebuggees();
75505:         for (GlobalObjectSet::Enum e(debuggees); !e.empty(); e.popFront()) {
75505:             GlobalObject *global = e.front();
76256:             if (IsAboutToBeFinalized(cx, global))
75505:                 detachAllDebuggersFromGlobal(cx, global, &e);
75505:         }
75505:     }
75452: }
75452: 
75452: void
75513: Debugger::detachAllDebuggersFromGlobal(JSContext *cx, GlobalObject *global,
75513:                                        GlobalObjectSet::Enum *compartmentEnum)
75453: {
75513:     const GlobalObject::DebuggerVector *debuggers = global->getDebuggers();
75453:     JS_ASSERT(!debuggers->empty());
75453:     while (!debuggers->empty())
75489:         debuggers->back()->removeDebuggeeGlobal(cx, global, compartmentEnum, NULL);
75453: }
75453: 
75453: void
75513: Debugger::finalize(JSContext *cx, JSObject *obj)
75402: {
76256:     Debugger *dbg = fromJSObject(obj);
75489:     if (!dbg)
75489:         return;
75489:     if (!dbg->debuggees.empty()) {
76236:         /*
76236:          * This happens only during per-compartment GC. See comment in
76236:          * Debugger::sweepAll.
76236:          */
75489:         JS_ASSERT(cx->runtime->gcCurrentCompartment == dbg->object->compartment());
75489:         for (GlobalObjectSet::Enum e(dbg->debuggees); !e.empty(); e.popFront())
75489:             dbg->removeDebuggeeGlobal(cx, e.front(), NULL, &e);
75489:     }
75446:     cx->delete_(dbg);
75402: }
75412: 
75513: Class Debugger::jsclass = {
75513:     "Debugger", JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUG_COUNT),
75397:     PropertyStub, PropertyStub, PropertyStub, StrictPropertyStub,
75513:     EnumerateStub, ResolveStub, ConvertStub, Debugger::finalize,
75402:     NULL,                 /* reserved0   */
75402:     NULL,                 /* checkAccess */
75402:     NULL,                 /* call        */
75402:     NULL,                 /* construct   */
75402:     NULL,                 /* xdrObject   */
75402:     NULL,                 /* hasInstance */
75513:     Debugger::traceObject
75397: };
75397: 
76263: Debugger *
76264: Debugger::fromThisValue(JSContext *cx, const CallArgs &args, const char *fnname)
76263: {
76264:     if (!args.thisv().isObject()) {
76263:         ReportObjectRequired(cx);
76263:         return NULL;
76263:     }
76264:     JSObject *thisobj = &args.thisv().toObject();
76263:     if (thisobj->getClass() != &Debugger::jsclass) {
76263:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
76263:                              "Debugger", fnname, thisobj->getClass()->name);
76263:         return NULL;
76263:     }
76263: 
76263:     /*
76263:      * Forbid Debugger.prototype, which is of the Debugger JSClass but isn't
76263:      * really a Debugger object. The prototype object is distinguished by
76263:      * having a NULL private value.
76263:      */
76263:     Debugger *dbg = fromJSObject(thisobj);
76263:     if (!dbg) {
76263:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
76263:                              "Debugger", fnname, "prototype object");
76263:     }
76263:     return dbg;
76263: }
76263: 
76264: #define THIS_DEBUGGER(cx, argc, vp, fnname, args, dbg)                       \
76264:     CallArgs args = CallArgsFromVp(argc, vp);                                \
76264:     Debugger *dbg = Debugger::fromThisValue(cx, args, fnname);               \
76263:     if (!dbg)                                                                \
76263:         return false
76263: 
75402: JSBool
76231: Debugger::getEnabled(JSContext *cx, uintN argc, Value *vp)
76231: {
76264:     THIS_DEBUGGER(cx, argc, vp, "get enabled", args, dbg);
76264:     args.rval().setBoolean(dbg->enabled);
76231:     return true;
76231: }
76231: 
76231: JSBool
76231: Debugger::setEnabled(JSContext *cx, uintN argc, Value *vp)
76231: {
76231:     REQUIRE_ARGC("Debugger.set enabled", 1);
76264:     THIS_DEBUGGER(cx, argc, vp, "set enabled", args, dbg);
76264:     bool enabled = js_ValueToBoolean(args[0]);
76231: 
76231:     if (enabled != dbg->enabled) {
76231:         for (Breakpoint *bp = dbg->firstBreakpoint(); bp; bp = bp->nextInDebugger()) {
76231:             if (enabled) {
76231:                 if (!bp->site->inc(cx)) {
76236:                     /*
76236:                      * Roll back the changes on error to keep the
76236:                      * BreakpointSite::enabledCount counters correct.
76236:                      */
76231:                     for (Breakpoint *bp2 = dbg->firstBreakpoint();
76231:                          bp2 != bp;
76231:                          bp2 = bp2->nextInDebugger())
76231:                     {
76231:                         bp->site->dec(cx);
76231:                     }
76231:                     return false;
76231:                 }
76231:             } else {
76231:                 bp->site->dec(cx);
76231:             }
76231:         }
76231:     }
76231: 
76231:     dbg->enabled = enabled;
76264:     args.rval().setUndefined();
76231:     return true;
76231: }
76231: 
76231: JSBool
76234: Debugger::getHookImpl(JSContext *cx, uintN argc, Value *vp, Hook which)
75402: {
76234:     JS_ASSERT(which >= 0 && which < HookCount);
76264:     THIS_DEBUGGER(cx, argc, vp, "getHook", args, dbg);
76264:     args.rval() = dbg->object->getReservedSlot(JSSLOT_DEBUG_HOOK_START + which);
75402:     return true;
75402: }
75402: 
75402: JSBool
76234: Debugger::setHookImpl(JSContext *cx, uintN argc, Value *vp, Hook which)
75402: {
76234:     JS_ASSERT(which >= 0 && which < HookCount);
76226:     REQUIRE_ARGC("Debugger.setHook", 1);
76264:     THIS_DEBUGGER(cx, argc, vp, "setHook", args, dbg);
76264:     const Value &v = args[0];
76234:     if (v.isObject()) {
76234:         if (!v.toObject().isCallable()) {
76226:             js_ReportIsNotFunction(cx, vp, JSV2F_SEARCH_STACK);
75402:             return false;
76226:         }
76234:     } else if (!v.isUndefined()) {
76234:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_CALLABLE_OR_UNDEFINED);
76234:         return false;
76234:     }
76234:     dbg->object->setReservedSlot(JSSLOT_DEBUG_HOOK_START + which, v);
76264:     args.rval().setUndefined();
75402:     return true;
75402: }
75402: 
75402: JSBool
76230: Debugger::getOnDebuggerStatement(JSContext *cx, uintN argc, Value *vp)
76230: {
76234:     return getHookImpl(cx, argc, vp, OnDebuggerStatement);
76230: }
76230: 
76230: JSBool
76230: Debugger::setOnDebuggerStatement(JSContext *cx, uintN argc, Value *vp)
76230: {
76234:     return setHookImpl(cx, argc, vp, OnDebuggerStatement);
76230: }
76230: 
76230: JSBool
76230: Debugger::getOnExceptionUnwind(JSContext *cx, uintN argc, Value *vp)
76230: {
76234:     return getHookImpl(cx, argc, vp, OnExceptionUnwind);
76230: }
76230: 
76230: JSBool
76230: Debugger::setOnExceptionUnwind(JSContext *cx, uintN argc, Value *vp)
76230: {
76234:     return setHookImpl(cx, argc, vp, OnExceptionUnwind);
76230: }
76230: 
76230: JSBool
76230: Debugger::getOnNewScript(JSContext *cx, uintN argc, Value *vp)
76230: {
76234:     return getHookImpl(cx, argc, vp, OnNewScript);
76230: }
76230: 
76230: JSBool
76230: Debugger::setOnNewScript(JSContext *cx, uintN argc, Value *vp)
76230: {
76234:     return setHookImpl(cx, argc, vp, OnNewScript);
76230: }
76230: 
76230: JSBool
76230: Debugger::getOnEnterFrame(JSContext *cx, uintN argc, Value *vp)
76230: {
76234:     return getHookImpl(cx, argc, vp, OnEnterFrame);
76230: }
76230: 
76230: JSBool
76230: Debugger::setOnEnterFrame(JSContext *cx, uintN argc, Value *vp)
76230: {
76234:     return setHookImpl(cx, argc, vp, OnEnterFrame);
76230: }
76230: 
76230: JSBool
75513: Debugger::getUncaughtExceptionHook(JSContext *cx, uintN argc, Value *vp)
75404: {
76264:     THIS_DEBUGGER(cx, argc, vp, "get uncaughtExceptionHook", args, dbg);
76264:     args.rval().setObjectOrNull(dbg->uncaughtExceptionHook);
75404:     return true;
75404: }
75404: 
75404: JSBool
75513: Debugger::setUncaughtExceptionHook(JSContext *cx, uintN argc, Value *vp)
75404: {
75513:     REQUIRE_ARGC("Debugger.set uncaughtExceptionHook", 1);
76264:     THIS_DEBUGGER(cx, argc, vp, "set uncaughtExceptionHook", args, dbg);
76264:     if (!args[0].isNull() && (!args[0].isObject() || !args[0].toObject().isCallable())) {
75405:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_ASSIGN_FUNCTION_OR_NULL,
75405:                              "uncaughtExceptionHook");
75405:         return false;
75405:     }
75405: 
76264:     dbg->uncaughtExceptionHook = args[0].toObjectOrNull();
76264:     args.rval().setUndefined();
75404:     return true;
75404: }
75404: 
75456: JSObject *
76264: Debugger::unwrapDebuggeeArgument(JSContext *cx, const Value &v)
75456: {
76236:     /*
76236:      * The argument to {add,remove,has}Debuggee may be
76236:      *   - a Debugger.Object belonging to this Debugger: return its referent
76236:      *   - a cross-compartment wrapper: return the wrapped object
76236:      *   - any other non-Debugger.Object object: return it
76236:      * If it is a primitive, or a Debugger.Object that belongs to some other
76236:      * Debugger, throw a TypeError.
76236:      */
75456:     JSObject *obj = NonNullObject(cx, v);
75456:     if (obj) {
75513:         if (obj->clasp == &DebuggerObject_class) {
76264:             Value rv = v;
76264:             if (!unwrapDebuggeeValue(cx, &rv))
75456:                 return NULL;
76264:             return &rv.toObject();
75456:         }
75495:         if (obj->isCrossCompartmentWrapper())
75495:             return &obj->getProxyPrivate().toObject();
75456:     }
75456:     return obj;
75456: }
75456: 
75456: JSBool
75513: Debugger::addDebuggee(JSContext *cx, uintN argc, Value *vp)
75456: {
75513:     REQUIRE_ARGC("Debugger.addDebuggee", 1);
76264:     THIS_DEBUGGER(cx, argc, vp, "addDebuggee", args, dbg);
76264:     JSObject *referent = dbg->unwrapDebuggeeArgument(cx, args[0]);
75456:     if (!referent)
75456:         return false;
75456:     GlobalObject *global = referent->getGlobal();
76253:     if (!dbg->addDebuggeeGlobal(cx, global))
75456:         return false;
75456: 
75456:     Value v = ObjectValue(*referent);
75456:     if (!dbg->wrapDebuggeeValue(cx, &v))
75456:         return false;
76264:     args.rval() = v;
75456:     return true;
75456: }
75456: 
75456: JSBool
75513: Debugger::removeDebuggee(JSContext *cx, uintN argc, Value *vp)
75456: {
75513:     REQUIRE_ARGC("Debugger.removeDebuggee", 1);
76264:     THIS_DEBUGGER(cx, argc, vp, "removeDebuggee", args, dbg);
76264:     JSObject *referent = dbg->unwrapDebuggeeArgument(cx, args[0]);
75456:     if (!referent)
75456:         return false;
75456:     GlobalObject *global = referent->getGlobal();
75497:     if (dbg->debuggees.has(global))
75489:         dbg->removeDebuggeeGlobal(cx, global, NULL, NULL);
76264:     args.rval().setUndefined();
75456:     return true;
75456: }
75456: 
75456: JSBool
75513: Debugger::hasDebuggee(JSContext *cx, uintN argc, Value *vp)
75456: {
75513:     REQUIRE_ARGC("Debugger.hasDebuggee", 1);
76264:     THIS_DEBUGGER(cx, argc, vp, "hasDebuggee", args, dbg);
76264:     JSObject *referent = dbg->unwrapDebuggeeArgument(cx, args[0]);
75456:     if (!referent)
75456:         return false;
76264:     args.rval().setBoolean(!!dbg->debuggees.lookup(referent->getGlobal()));
75456:     return true;
75456: }
75456: 
75456: JSBool
75513: Debugger::getDebuggees(JSContext *cx, uintN argc, Value *vp)
75456: {
76264:     THIS_DEBUGGER(cx, argc, vp, "getDebuggees", args, dbg);
75456:     JSObject *arrobj = NewDenseAllocatedArray(cx, dbg->debuggees.count(), NULL);
75456:     if (!arrobj)
75456:         return false;
75456:     uintN i = 0;
75456:     for (GlobalObjectSet::Enum e(dbg->debuggees); !e.empty(); e.popFront()) {
75456:         Value v = ObjectValue(*e.front());
75456:         if (!dbg->wrapDebuggeeValue(cx, &v))
75456:             return false;
75456:         arrobj->setDenseArrayElement(i++, v);
75456:     }
76264:     args.rval().setObject(*arrobj);
75456:     return true;
75456: }
75456: 
75404: JSBool
75515: Debugger::getNewestFrame(JSContext *cx, uintN argc, Value *vp)
75441: {
76264:     THIS_DEBUGGER(cx, argc, vp, "getNewestFrame", args, dbg);
75484: 
76236:     /*
76236:      * cx->fp() would return the topmost frame in the current context.
76236:      * Since there may be multiple contexts, use AllFramesIter instead.
76236:      */
75485:     for (AllFramesIter i(cx->stack.space()); !i.done(); ++i) {
75484:         if (dbg->observesFrame(i.fp()))
75484:             return dbg->getScriptFrame(cx, i.fp(), vp);
75484:     }
76264:     args.rval().setNull();
75441:     return true;
75441: }
75441: 
75441: JSBool
75513: Debugger::clearAllBreakpoints(JSContext *cx, uintN argc, Value *vp)
75506: {
76264:     THIS_DEBUGGER(cx, argc, vp, "clearAllBreakpoints", args, dbg);
75506:     for (GlobalObjectSet::Range r = dbg->debuggees.all(); !r.empty(); r.popFront())
75506:         r.front()->compartment()->clearBreakpointsIn(cx, dbg, NULL, NULL);
75506:     return true;
75506: }
75506: 
75506: JSBool
75513: Debugger::construct(JSContext *cx, uintN argc, Value *vp)
75398: {
76264:     CallArgs args = CallArgsFromVp(argc, vp);
76264: 
76236:     /* Check that the arguments, if any, are cross-compartment wrappers. */
76264:     for (uintN i = 0; i < argc; i++) {
76264:         const Value &arg = args[i];
75398:         if (!arg.isObject())
75402:             return ReportObjectRequired(cx);
75398:         JSObject *argobj = &arg.toObject();
75451:         if (!argobj->isCrossCompartmentWrapper()) {
75513:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CCW_REQUIRED, "Debugger");
75398:             return false;
75398:         }
75456:     }
75412: 
76236:     /* Get Debugger.prototype. */
75398:     Value v;
75398:     jsid prototypeId = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
76264:     if (!args.callee().getProperty(cx, prototypeId, &v))
75398:         return false;
75398:     JSObject *proto = &v.toObject();
75513:     JS_ASSERT(proto->getClass() == &Debugger::jsclass);
75398: 
76236:     /*
76236:      * Make the new Debugger object. Each one has a reference to
76236:      * Debugger.{Frame,Object,Script}.prototype in reserved slots. The rest of
76236:      * the reserved slots are for hooks; they default to undefined.
76236:      */
75513:     JSObject *obj = NewNonFunction<WithProto::Given>(cx, &Debugger::jsclass, proto, NULL);
75413:     if (!obj || !obj->ensureClassReservedSlots(cx))
75398:         return false;
76234:     for (uintN slot = JSSLOT_DEBUG_PROTO_START; slot < JSSLOT_DEBUG_PROTO_STOP; slot++)
75418:         obj->setReservedSlot(slot, proto->getReservedSlot(slot));
75418: 
76226:     Debugger *dbg = cx->new_<Debugger>(cx, obj);
75402:     if (!dbg)
75402:         return false;
75451:     obj->setPrivate(dbg);
75456:     if (!dbg->init(cx)) {
75452:         cx->delete_(dbg);
75402:         return false;
75402:     }
75456: 
76236:     /* Add the initial debuggees, if any. */
76264:     for (uintN i = 0; i < argc; i++) {
76264:         GlobalObject *debuggee = args[i].toObject().getProxyPrivate().toObject().getGlobal();
75456:         if (!dbg->addDebuggeeGlobal(cx, debuggee))
75456:             return false;
75456:     }
75456: 
76264:     args.rval().setObject(*obj);
75398:     return true;
75398: }
75398: 
75453: bool
76248: Debugger::addDebuggeeGlobal(JSContext *cx, GlobalObject *global)
75453: {
76253:     if (debuggees.has(global))
76253:         return true;
76253: 
76248:     JSCompartment *debuggeeCompartment = global->compartment();
75457: 
76236:     /*
76248:      * Check for cycles. If global's compartment is reachable from this
76248:      * Debugger object's compartment by following debuggee-to-debugger links,
76248:      * then adding global would create a cycle. (Typically nobody is debugging
76248:      * the debugger, in which case we zip through this code without looping.)
76236:      */
75456:     Vector<JSCompartment *> visited(cx);
75456:     if (!visited.append(object->compartment()))
75456:         return false;
75456:     for (size_t i = 0; i < visited.length(); i++) {
75456:         JSCompartment *c = visited[i];
75489:         if (c == debuggeeCompartment) {
75456:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_LOOP);
75456:             return false;
75456:         }
75456: 
76236:         /*
76236:          * Find all compartments containing debuggers debugging global objects
76236:          * in c. Add those compartments to visited.
76236:          */
75456:         for (GlobalObjectSet::Range r = c->getDebuggees().all(); !r.empty(); r.popFront()) {
75513:             GlobalObject::DebuggerVector *v = r.front()->getDebuggers();
75513:             for (Debugger **p = v->begin(); p != v->end(); p++) {
75456:                 JSCompartment *next = (*p)->object->compartment();
76227:                 if (Find(visited, next) == visited.end() && !visited.append(next))
75456:                     return false;
75456:             }
75456:         }
75456:     }
75456: 
76236:     /* Refuse to enable debug mode for a compartment that has running scripts. */
75497:     if (!debuggeeCompartment->debugMode() && debuggeeCompartment->hasScriptsOnStack(cx)) {
75497:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_IDLE);
75494:         return false;
75494:     }
75494: 
76236:     /*
76236:      * Each debugger-debuggee relation must be stored in up to three places.
76236:      * JSCompartment::addDebuggee enables debug mode if needed.
76236:      */
76248:     AutoCompartment ac(cx, global);
75493:     if (!ac.enter())
75493:         return false;
76248:     GlobalObject::DebuggerVector *v = global->getOrCreateDebuggers(cx);
75489:     if (!v || !v->append(this)) {
75489:         js_ReportOutOfMemory(cx);
76248:     } else {
76248:         if (!debuggees.put(global)) {
75489:             js_ReportOutOfMemory(cx);
76248:         } else {
76248:             if (global->getDebuggers()->length() > 1)
75453:                 return true;
76248:             if (debuggeeCompartment->addDebuggee(cx, global))
76248:                 return true;
75453: 
76236:             /* Maintain consistency on error. */
76248:             debuggees.remove(global);
76248:         }
75453:         JS_ASSERT(v->back() == this);
75453:         v->popBack();
76248:     }
75453:     return false;
75453: }
75453: 
75453: void
75513: Debugger::removeDebuggeeGlobal(JSContext *cx, GlobalObject *global,
75489:                                GlobalObjectSet::Enum *compartmentEnum,
75453:                                GlobalObjectSet::Enum *debugEnum)
75453: {
76236:     /*
76236:      * Each debuggee is in two HashSets: one for its compartment and one for
76236:      * its debugger (this). The caller might be enumerating either set; if so,
76236:      * use HashSet::Enum::removeFront rather than HashSet::remove below, to
76236:      * avoid invalidating the live enumerator.
76236:      */
75453:     JS_ASSERT(global->compartment()->getDebuggees().has(global));
75453:     JS_ASSERT_IF(compartmentEnum, compartmentEnum->front() == global);
75453:     JS_ASSERT(debuggees.has(global));
75453:     JS_ASSERT_IF(debugEnum, debugEnum->front() == global);
75453: 
76236:     /*
76236:      * FIXME Debugger::slowPathOnLeaveFrame needs to kill all Debugger.Frame
76236:      * objects referring to a particular js::StackFrame. This is hard if
76236:      * Debugger objects that are no longer debugging the relevant global might
76236:      * have live Frame objects. So we take the easy way out and kill them
76236:      * here. This is a bug, since it's observable and contrary to the spec. One
76236:      * possible fix would be to put such objects into a compartment-wide bag
76236:      * which slowPathOnLeaveFrame would have to examine.
76236:      */
75453:     for (FrameMap::Enum e(frames); !e.empty(); e.popFront()) {
75453:         js::StackFrame *fp = e.front().key;
75453:         if (fp->scopeChain().getGlobal() == global) {
75453:             e.front().value->setPrivate(NULL);
75453:             e.removeFront();
75453:         }
75453:     }
75453: 
75513:     GlobalObject::DebuggerVector *v = global->getDebuggers();
75513:     Debugger **p;
75453:     for (p = v->begin(); p != v->end(); p++) {
75453:         if (*p == this)
75453:             break;
75453:     }
75453:     JS_ASSERT(p != v->end());
75453: 
76236:     /*
76236:      * The relation must be removed from up to three places: *v and debuggees
76236:      * for sure, and possibly the compartment's debuggee set.
76236:      */
75453:     v->erase(p);
75497:     if (v->empty())
75497:         global->compartment()->removeDebuggee(cx, global, compartmentEnum);
75453:     if (debugEnum)
75453:         debugEnum->removeFront();
75453:     else
75453:         debuggees.remove(global);
75453: }
75453: 
75513: JSPropertySpec Debugger::properties[] = {
75513:     JS_PSGS("enabled", Debugger::getEnabled, Debugger::setEnabled, 0),
76230:     JS_PSGS("onDebuggerStatement", Debugger::getOnDebuggerStatement,
76230:             Debugger::setOnDebuggerStatement, 0),
76236:     JS_PSGS("onExceptionUnwind", Debugger::getOnExceptionUnwind,
76236:             Debugger::setOnExceptionUnwind, 0),
76230:     JS_PSGS("onNewScript", Debugger::getOnNewScript, Debugger::setOnNewScript, 0),
76230:     JS_PSGS("onEnterFrame", Debugger::getOnEnterFrame, Debugger::setOnEnterFrame, 0),
75513:     JS_PSGS("uncaughtExceptionHook", Debugger::getUncaughtExceptionHook,
75513:             Debugger::setUncaughtExceptionHook, 0),
75402:     JS_PS_END
75402: };
75402: 
75513: JSFunctionSpec Debugger::methods[] = {
75513:     JS_FN("addDebuggee", Debugger::addDebuggee, 1, 0),
75513:     JS_FN("removeDebuggee", Debugger::removeDebuggee, 1, 0),
75513:     JS_FN("hasDebuggee", Debugger::hasDebuggee, 1, 0),
75513:     JS_FN("getDebuggees", Debugger::getDebuggees, 0, 0),
75515:     JS_FN("getNewestFrame", Debugger::getNewestFrame, 0, 0),
75513:     JS_FN("clearAllBreakpoints", Debugger::clearAllBreakpoints, 1, 0),
75441:     JS_FS_END
75441: };
75441: 
75466: 
76236: /*** Debugger.Script *****************************************************************************/
76236: 
76236: /*
76236:  * JSScripts' lifetimes fall into to two categories:
76236:  *
76236:  * - "Held scripts": JSScripts belonging to JSFunctions and JSScripts created
76236:  *   using JSAPI have lifetimes determined by the garbage collector. A JSScript
76236:  *   itself has no mark bit of its own. Instead, its holding object manages the
76236:  *   JSScript as part of its own structure: the holder has a mark bit; when the
76236:  *   holder is marked it calls js_TraceScript on its JSScript; and when the
76236:  *   holder is freed it explicitly frees its JSScript.
76236:  *
76236:  *   Debugger.Script instances for held scripts are strong references to the
76236:  *   holder (and thus to the script). Debugger::heldScripts weakly maps
76236:  *   debuggee holding objects to the Debugger.Script objects for their
76236:  *   JSScripts. We needn't act on a destroyScript event for a held script: if
76236:  *   we get such an event we know its Debugger.Script is dead anyway, and its
76236:  *   entry in Debugger::heldScripts will be cleaned up by the standard weak
76236:  *   table code.
76236:  *
76236:  * - "Non-held scripts": JSScripts generated temporarily for a call to eval or
76236:  *   JS_Evaluate*, live until the call completes, at which point the script is
76236:  *   destroyed.
76236:  *
76236:  *   A Debugger.Script instance for a non-held script has no influence on the
76236:  *   JSScript's lifetime. Debugger::nonHeldScripts maps live JSScripts to to
76236:  *   their Debugger.Script objects.  When a destroyScript event tells us that
76236:  *   a non-held script is dead, we remove its table entry, and clear its
76236:  *   Debugger.Script object's script pointer, thus marking it dead.
76236:  *
76236:  * A Debugger.Script's private pointer points directly to the JSScript, or is
76236:  * NULL if the Debugger.Script is dead. The JSSLOT_DEBUGSCRIPT_HOLDER slot
76236:  * refers to the holding object, or is null for non-held JSScripts. The private
76236:  * pointer is not traced; the holding object reference, if present, is traced
76236:  * via DebuggerScript_trace.
76236:  *
76236:  * (We consider a script saved in and retrieved from the eval cache to have
76236:  * been destroyed, and then --- mirabile dictu --- re-created at the same
76236:  * address. The newScriptHook and destroyScriptHook hooks cooperate with this
76236:  * view.)
76236:  */
75506: static inline JSScript *
75506: GetScriptReferent(JSObject *obj)
75506: {
75513:     JS_ASSERT(obj->getClass() == &DebuggerScript_class);
75492:     return (JSScript *) obj->getPrivate();
75492: }
75492: 
75506: static inline void
75506: ClearScriptReferent(JSObject *obj)
75506: {
75513:     JS_ASSERT(obj->getClass() == &DebuggerScript_class);
75492:     obj->setPrivate(NULL);
75492: }
75492: 
75506: static inline JSObject *
75506: GetScriptHolder(JSObject *obj)
75506: {
75513:     JS_ASSERT(obj->getClass() == &DebuggerScript_class);
75506:     Value v = obj->getReservedSlot(JSSLOT_DEBUGSCRIPT_HOLDER);
75506:     return (JSObject *) v.toPrivate();
75506: }
75506: 
75496: static void
75513: DebuggerScript_trace(JSTracer *trc, JSObject *obj)
75496: {
75496:     if (!trc->context->runtime->gcCurrentCompartment) {
75496:         Value v = obj->getReservedSlot(JSSLOT_DEBUGSCRIPT_HOLDER);
75496:         if (!v.isUndefined()) {
75496:             if (JSObject *obj = (JSObject *) v.toPrivate())
75513:                 MarkObject(trc, *obj, "Debugger.Script referent holder");
75492:         }
75496:     }
75496: }
75496: 
75513: Class DebuggerScript_class = {
75496:     "Script", JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUGSCRIPT_COUNT),
75496:     PropertyStub, PropertyStub, PropertyStub, StrictPropertyStub,
75496:     EnumerateStub, ResolveStub, ConvertStub, NULL,
75496:     NULL,                 /* reserved0   */
75496:     NULL,                 /* checkAccess */
75496:     NULL,                 /* call        */
75496:     NULL,                 /* construct   */
75496:     NULL,                 /* xdrObject   */
75496:     NULL,                 /* hasInstance */
75513:     DebuggerScript_trace
75496: };
75492: 
75492: JSObject *
75513: Debugger::newDebuggerScript(JSContext *cx, JSScript *script, JSObject *holder)
75492: {
75518:     assertSameCompartment(cx, object);
75518: 
75492:     JSObject *proto = &object->getReservedSlot(JSSLOT_DEBUG_SCRIPT_PROTO).toObject();
75492:     JS_ASSERT(proto);
75513:     JSObject *scriptobj = NewNonFunction<WithProto::Given>(cx, &DebuggerScript_class, proto, NULL);
75492:     if (!scriptobj || !scriptobj->ensureClassReservedSlots(cx))
75492:         return false;
75492:     scriptobj->setPrivate(script);
75492:     scriptobj->setReservedSlot(JSSLOT_DEBUGSCRIPT_OWNER, ObjectValue(*object));
75496:     scriptobj->setReservedSlot(JSSLOT_DEBUGSCRIPT_HOLDER, PrivateValue(holder));
75492: 
75492:     return scriptobj;
75492: }
75492: 
75492: JSObject *
75513: Debugger::wrapHeldScript(JSContext *cx, JSScript *script, JSObject *obj)
75492: {
75492:     assertSameCompartment(cx, object);
76766:     JS_ASSERT(cx->compartment != script->compartment);
76766:     JS_ASSERT(script->compartment == obj->compartment());
75492: 
75492:     ScriptWeakMap::AddPtr p = heldScripts.lookupForAdd(obj);
75492:     if (!p) {
75513:         JSObject *scriptobj = newDebuggerScript(cx, script, obj);
76236: 
76236:         /* The allocation may have caused a GC, which can remove table entries. */
75492:         if (!scriptobj || !heldScripts.relookupOrAdd(p, obj, scriptobj))
75492:             return NULL;
75492:     }
75492: 
75492:     JS_ASSERT(GetScriptReferent(p->value) == script);
75492:     return p->value;
75492: }
75492: 
75492: JSObject *
75513: Debugger::wrapFunctionScript(JSContext *cx, JSFunction *fun)
75492: {
75492:     return wrapHeldScript(cx, fun->script(), fun);
75492: }
75492: 
75492: JSObject *
75513: Debugger::wrapJSAPIScript(JSContext *cx, JSObject *obj)
75492: {
75492:     JS_ASSERT(obj->isScript());
75492:     return wrapHeldScript(cx, obj->getScript(), obj);
75492: }
75492: 
75492: JSObject *
75517: Debugger::wrapNonHeldScript(JSContext *cx, JSScript *script)
75492: {
75518:     assertSameCompartment(cx, object);
76766:     JS_ASSERT(cx->compartment != script->compartment);
75518: 
75517:     ScriptMap::AddPtr p = nonHeldScripts.lookupForAdd(script);
75492:     if (!p) {
75513:         JSObject *scriptobj = newDebuggerScript(cx, script, NULL);
75518: 
76236:         /* The allocation may have caused a GC, which can remove table entries. */
75517:         if (!scriptobj || !nonHeldScripts.relookupOrAdd(p, script, scriptobj))
75492:             return NULL;
75492:     }
75492: 
75492:     JS_ASSERT(GetScriptReferent(p->value) == script);
75492:     return p->value;
75492: }
75492: 
75492: void
75513: Debugger::slowPathOnDestroyScript(JSScript *script)
75492: {
76236:     /* Find all debuggers that might have Debugger.Script referring to this script. */
76766:     js::GlobalObjectSet *debuggees = &script->compartment->getDebuggees();
75492:     for (GlobalObjectSet::Range r = debuggees->all(); !r.empty(); r.popFront()) {
75513:         GlobalObject::DebuggerVector *debuggers = r.front()->getDebuggers();
75513:         for (Debugger **p = debuggers->begin(); p != debuggers->end(); p++)
75517:             (*p)->destroyNonHeldScript(script);
75492:     }
75492: }
75492: 
75492: void
75517: Debugger::destroyNonHeldScript(JSScript *script)
75492: {
75517:     ScriptMap::Ptr p = nonHeldScripts.lookup(script);
75492:     if (p) {
75492:         JS_ASSERT(GetScriptReferent(p->value) == script);
75492:         ClearScriptReferent(p->value);
75517:         nonHeldScripts.remove(p);
75492:     }
75492: }
75492: 
75492: static JSObject *
75513: DebuggerScript_check(JSContext *cx, const Value &v, const char *clsname, const char *fnname,
75513:                      bool checkLive)
75492: {
75506:     if (!v.isObject()) {
75492:         ReportObjectRequired(cx);
75492:         return NULL;
75492:     }
75506:     JSObject *thisobj = &v.toObject();
75513:     if (thisobj->clasp != &DebuggerScript_class) {
75492:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
75506:                              clsname, fnname, thisobj->getClass()->name);
75492:         return NULL;
75492:     }
75492: 
76236:     /*
76236:      * Check for Debugger.Script.prototype, which is of class DebuggerScript_class
76236:      * but whose holding object is undefined.
76236:      */
75492:     if (thisobj->getReservedSlot(JSSLOT_DEBUGSCRIPT_HOLDER).isUndefined()) {
75492:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
75506:                              clsname, fnname, "prototype object");
75492:         return NULL;
75492:     }
75492: 
75492:     if (checkLive && !GetScriptReferent(thisobj)) {
75492:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_LIVE,
75506:                              clsname, fnname, "script");
75492:         return NULL;
75492:     }
75492: 
75492:     return thisobj;
75492: }
75492: 
75506: static JSObject *
76265: DebuggerScript_checkThis(JSContext *cx, const CallArgs &args, const char *fnname, bool checkLive)
75506: {
76265:     return DebuggerScript_check(cx, args.thisv(), "Debugger.Script", fnname, checkLive);
76265: }
76265: 
76265: #define THIS_DEBUGSCRIPT_SCRIPT_NEEDLIVE(cx, argc, vp, fnname, args, obj, script, checkLive) \
76265:     CallArgs args = CallArgsFromVp(argc, vp);                                       \
76265:     JSObject *obj = DebuggerScript_checkThis(cx, args, fnname, checkLive);          \
75492:     if (!obj)                                                                       \
75492:         return false;                                                               \
75492:     JSScript *script = GetScriptReferent(obj)
75492: 
76265: #define THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, fnname, args, obj, script)            \
76265:     THIS_DEBUGSCRIPT_SCRIPT_NEEDLIVE(cx, argc, vp, fnname, args, obj, script, false)
76265: #define THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, fnname, args, obj, script)       \
76265:     THIS_DEBUGSCRIPT_SCRIPT_NEEDLIVE(cx, argc, vp, fnname, args, obj, script, true)
75492: 
75522: static JSBool
75522: DebuggerScript_getUrl(JSContext *cx, uintN argc, Value *vp)
75522: {
76265:     THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, "get url", args, obj, script);
75522: 
75522:     JSString *str = js_NewStringCopyZ(cx, script->filename);
75522:     if (!str)
75522:         return false;
76265:     args.rval().setString(str);
75522:     return true;
75522: }
75522: 
75522: static JSBool
75522: DebuggerScript_getStartLine(JSContext *cx, uintN argc, Value *vp)
75522: {
76265:     THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, "get startLine", args, obj, script);
76265:     args.rval().setNumber(script->lineno);
75522:     return true;
75522: }
75522: 
75522: static JSBool
75522: DebuggerScript_getLineCount(JSContext *cx, uintN argc, Value *vp)
75522: {
76265:     THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, "get lineCount", args, obj, script);
75522: 
76248:     uintN maxLine = js_GetScriptLineExtent(script);
76265:     args.rval().setNumber(jsdouble(maxLine));
75522:     return true;
75522: }
75492: 
75492: static JSBool
75513: DebuggerScript_getLive(JSContext *cx, uintN argc, Value *vp)
75492: {
76265:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "get live", args, obj, script);
76265:     args.rval().setBoolean(!!script);
75492:     return true;
75492: }
75492: 
75512: static JSBool
75513: DebuggerScript_getChildScripts(JSContext *cx, uintN argc, Value *vp)
75512: {
76265:     THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, "get live", args, obj, script);
75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);
75512: 
75512:     JSObject *result = NewDenseEmptyArray(cx);
75512:     if (!result)
75512:         return false;
75512:     if (JSScript::isValidOffset(script->objectsOffset)) {
76236:         /*
76236:          * script->savedCallerFun indicates that this is a direct eval script
76236:          * and the calling function is stored as script->objects()->vector[0].
76236:          * It is not really a child script of this script, so skip it.
76236:          */
75512:         JSObjectArray *objects = script->objects();
75519:         for (uint32 i = script->savedCallerFun ? 1 : 0; i < objects->length; i++) {
75512:             JSObject *obj = objects->vector[i];
75512:             if (obj->isFunction()) {
75512:                 JSObject *s = dbg->wrapFunctionScript(cx, (JSFunction *) obj);
75512:                 if (!s || !js_NewbornArrayPush(cx, result, ObjectValue(*s)))
75512:                     return false;
75512:             }
75512:         }
75512:     }
76265:     args.rval().setObject(*result);
75512:     return true;
75512: }
75512: 
75501: static bool
75501: ScriptOffset(JSContext *cx, JSScript *script, const Value &v, size_t *offsetp)
75501: {
75501:     double d;
75501:     size_t off;
75501: 
75501:     bool ok = v.isNumber();
75501:     if (ok) {
75501:         d = v.toNumber();
75501:         off = size_t(d);
75501:     }
75501:     if (!ok || off != d || !IsValidBytecodeOffset(cx, script, off)) {
75501:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_BAD_OFFSET);
75501:         return false;
75501:     }
75501:     *offsetp = off;
75501:     return true;
75501: }
75501: 
75501: static JSBool
75513: DebuggerScript_getOffsetLine(JSContext *cx, uintN argc, Value *vp)
75501: {
75513:     REQUIRE_ARGC("Debugger.Script.getOffsetLine", 1);
76265:     THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, "getOffsetLine", args, obj, script);
75501:     size_t offset;
76265:     if (!ScriptOffset(cx, script, args[0], &offset))
75501:         return false;
75501:     uintN lineno = JS_PCToLineNumber(cx, script, script->code + offset);
76265:     args.rval().setNumber(lineno);
75501:     return true;
75501: }
75501: 
75504: class BytecodeRangeWithLineNumbers : private BytecodeRange
75504: {
75504:   public:
75504:     using BytecodeRange::empty;
75504:     using BytecodeRange::frontPC;
75504:     using BytecodeRange::frontOpcode;
75504:     using BytecodeRange::frontOffset;
75504: 
75504:     BytecodeRangeWithLineNumbers(JSContext *cx, JSScript *script)
76236:       : BytecodeRange(cx, script), lineno(script->lineno), sn(script->notes()), snpc(script->code)
76236:     {
75504:         if (!SN_IS_TERMINATOR(sn))
75504:             snpc += SN_DELTA(sn);
75504:         updateLine();
75504:     }
75504: 
75504:     void popFront() {
75504:         BytecodeRange::popFront();
75504:         if (!empty())
75504:             updateLine();
75504:     }
75504: 
75504:     size_t frontLineNumber() const { return lineno; }
75504: 
75504:   private:
75504:     void updateLine() {
76236:         /*
76236:          * Determine the current line number by reading all source notes up to
76236:          * and including the current offset.
76236:          */
75504:         while (!SN_IS_TERMINATOR(sn) && snpc <= frontPC()) {
75504:             JSSrcNoteType type = (JSSrcNoteType) SN_TYPE(sn);
75504:             if (type == SRC_SETLINE)
75504:                 lineno = size_t(js_GetSrcNoteOffset(sn, 0));
75504:             else if (type == SRC_NEWLINE)
75504:                 lineno++;
75504: 
75504:             sn = SN_NEXT(sn);
75504:             snpc += SN_DELTA(sn);
75504:         }
75504:     }
75504: 
75504:     size_t lineno;
75504:     jssrcnote *sn;
75504:     jsbytecode *snpc;
75504: };
75504: 
75504: static const size_t NoEdges = -1;
75504: static const size_t MultipleEdges = -2;
75504: 
75504: /*
75504:  * FlowGraphSummary::populate(cx, script) computes a summary of script's
75513:  * control flow graph used by DebuggerScript_{getAllOffsets,getLineOffsets}.
75504:  *
75504:  * jumpData[offset] is:
75504:  *   - NoEdges if offset isn't the offset of an instruction, or if the
75504:  *     instruction is apparently unreachable;
75504:  *   - MultipleEdges if you can arrive at that instruction from
75504:  *     instructions on multiple different lines OR it's the first
75504:  *     instruction of the script;
75504:  *   - otherwise, the (unique) line number of all instructions that can
75504:  *     precede the instruction at offset.
75504:  *
75504:  * The generated graph does not contain edges for JSOP_RETSUB, which appears at
75504:  * the end of finally blocks. The algorithm that uses this information works
75504:  * anyway, because in non-exception cases, JSOP_RETSUB always returns to a
75504:  * !FlowsIntoNext instruction (JSOP_GOTO/GOTOX or JSOP_RETRVAL) which generates
75504:  * an edge if needed.
75504:  */
75504: class FlowGraphSummary : public Vector<size_t> {
75504:   public:
75504:     typedef Vector<size_t> Base;
75504:     FlowGraphSummary(JSContext *cx) : Base(cx) {}
75504: 
75504:     void addEdge(size_t sourceLine, size_t targetOffset) {
75504:         FlowGraphSummary &self = *this;
75504:         if (self[targetOffset] == NoEdges)
75504:             self[targetOffset] = sourceLine;
75504:         else if (self[targetOffset] != sourceLine)
75504:             self[targetOffset] = MultipleEdges;
75504:     }
75504: 
75504:     void addEdgeFromAnywhere(size_t targetOffset) {
75504:         (*this)[targetOffset] = MultipleEdges;
75504:     }
75504: 
75504:     bool populate(JSContext *cx, JSScript *script) {
75504:         if (!growBy(script->length))
75504:             return false;
75504:         FlowGraphSummary &self = *this;
75504:         self[0] = MultipleEdges;
75504:         for (size_t i = 1; i < script->length; i++)
75504:             self[i] = NoEdges;
75504: 
75504:         size_t prevLine = script->lineno;
75504:         JSOp prevOp = JSOP_NOP;
75504:         for (BytecodeRangeWithLineNumbers r(cx, script); !r.empty(); r.popFront()) {
75504:             size_t lineno = r.frontLineNumber();
75504:             JSOp op = r.frontOpcode();
75504: 
75504:             if (FlowsIntoNext(prevOp))
75504:                 addEdge(prevLine, r.frontOffset());
75504: 
75504:             if (js_CodeSpec[op].type() == JOF_JUMP) {
75504:                 addEdge(lineno, r.frontOffset() + GET_JUMP_OFFSET(r.frontPC()));
75504:             } else if (js_CodeSpec[op].type() == JOF_JUMPX) {
75504:                 addEdge(lineno, r.frontOffset() + GET_JUMPX_OFFSET(r.frontPC()));
75504:             } else if (op == JSOP_TABLESWITCH || op == JSOP_TABLESWITCHX ||
75504:                        op == JSOP_LOOKUPSWITCH || op == JSOP_LOOKUPSWITCHX) {
75504:                 bool table = op == JSOP_TABLESWITCH || op == JSOP_TABLESWITCHX;
75504:                 bool big = op == JSOP_TABLESWITCHX || op == JSOP_LOOKUPSWITCHX;
75504: 
75504:                 jsbytecode *pc = r.frontPC();
75504:                 size_t offset = r.frontOffset();
75504:                 ptrdiff_t step = big ? JUMPX_OFFSET_LEN : JUMP_OFFSET_LEN;
75504:                 size_t defaultOffset = offset + (big ? GET_JUMPX_OFFSET(pc) : GET_JUMP_OFFSET(pc));
75504:                 pc += step;
75504:                 addEdge(lineno, defaultOffset);
75504: 
75504:                 jsint ncases;
75504:                 if (table) {
75504:                     jsint low = GET_JUMP_OFFSET(pc);
75504:                     pc += JUMP_OFFSET_LEN;
75504:                     ncases = GET_JUMP_OFFSET(pc) - low + 1;
75504:                     pc += JUMP_OFFSET_LEN;
75504:                 } else {
75504:                     ncases = (jsint) GET_UINT16(pc);
75504:                     pc += UINT16_LEN;
75504:                     JS_ASSERT(ncases > 0);
75504:                 }
75504: 
75504:                 for (jsint i = 0; i < ncases; i++) {
75504:                     if (!table)
75504:                         pc += INDEX_LEN;
75504:                     size_t target = offset + (big ? GET_JUMPX_OFFSET(pc) : GET_JUMP_OFFSET(pc));
75504:                     addEdge(lineno, target);
75504:                     pc += step;
75504:                 }
75504:             }
75504: 
75504:             prevOp = op;
75504:             prevLine = lineno;
75504:         }
75504: 
75504:         return true;
75504:     }
75504: };
75504: 
75504: static JSBool
75513: DebuggerScript_getAllOffsets(JSContext *cx, uintN argc, Value *vp)
75504: {
76265:     THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, "getAllOffsets", args, obj, script);
75504: 
76236:     /*
76236:      * First pass: determine which offsets in this script are jump targets and
76236:      * which line numbers jump to them.
76236:      */
75504:     FlowGraphSummary flowData(cx);
75504:     if (!flowData.populate(cx, script))
75504:         return false;
75504: 
76236:     /* Second pass: build the result array. */
75504:     JSObject *result = NewDenseEmptyArray(cx);
75504:     if (!result)
75504:         return false;
75504:     for (BytecodeRangeWithLineNumbers r(cx, script); !r.empty(); r.popFront()) {
75504:         size_t offset = r.frontOffset();
75504:         size_t lineno = r.frontLineNumber();
75504: 
76236:         /* Make a note, if the current instruction is an entry point for the current line. */
75504:         if (flowData[offset] != NoEdges && flowData[offset] != lineno) {
76236:             /* Get the offsets array for this line. */
75504:             JSObject *offsets;
75504:             Value offsetsv;
75504:             if (!result->arrayGetOwnDataElement(cx, lineno, &offsetsv))
75504:                 return false;
75504: 
75504:             jsid id;
75504:             if (offsetsv.isObject()) {
75504:                 offsets = &offsetsv.toObject();
75504:             } else {
75504:                 JS_ASSERT(offsetsv.isMagic(JS_ARRAY_HOLE));
75504: 
76236:                 /*
76236:                  * Create an empty offsets array for this line.
76236:                  * Store it in the result array.
76236:                  */
75504:                 offsets = NewDenseEmptyArray(cx);
75504:                 if (!offsets ||
75504:                     !ValueToId(cx, NumberValue(lineno), &id) ||
75504:                     !result->defineProperty(cx, id, ObjectValue(*offsets)))
75504:                 {
75504:                     return false;
75504:                 }
75504:             }
75504: 
76236:             /* Append the current offset to the offsets array. */
75510:             if (!js_NewbornArrayPush(cx, offsets, NumberValue(offset)))
75504:                 return false;
75504:         }
75504:     }
75504: 
76265:     args.rval().setObject(*result);
75504:     return true;
75504: }
75504: 
75504: static JSBool
75513: DebuggerScript_getLineOffsets(JSContext *cx, uintN argc, Value *vp)
75504: {
76265:     THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, "getAllOffsets", args, obj, script);
75513:     REQUIRE_ARGC("Debugger.Script.getLineOffsets", 1);
75504: 
76236:     /* Parse lineno argument. */
75504:     size_t lineno;
75504:     bool ok = false;
76265:     if (args[0].isNumber()) {
76265:         jsdouble d = args[0].toNumber();
75504:         lineno = size_t(d);
75504:         ok = (lineno == d);
75504:     }
75504:     if (!ok) {
75504:         JS_ReportErrorNumber(cx,  js_GetErrorMessage, NULL, JSMSG_DEBUG_BAD_LINE);
75504:         return false;
75504:     }
75504: 
76236:     /*
76236:      * First pass: determine which offsets in this script are jump targets and
76236:      * which line numbers jump to them.
76236:      */
75504:     FlowGraphSummary flowData(cx);
75504:     if (!flowData.populate(cx, script))
75504:         return false;
75504: 
76236:     /* Second pass: build the result array. */
75504:     JSObject *result = NewDenseEmptyArray(cx);
75504:     if (!result)
75504:         return false;
75504:     for (BytecodeRangeWithLineNumbers r(cx, script); !r.empty(); r.popFront()) {
75504:         size_t offset = r.frontOffset();
75504: 
76236:         /* If the op at offset is an entry point, append offset to result. */
75504:         if (r.frontLineNumber() == lineno &&
75504:             flowData[offset] != NoEdges &&
75504:             flowData[offset] != lineno)
75504:         {
75510:             if (!js_NewbornArrayPush(cx, result, NumberValue(offset)))
75504:                 return false;
75504:         }
75504:     }
75504: 
76265:     args.rval().setObject(*result);
75504:     return true;
75504: }
75504: 
76229: static JSBool
75513: DebuggerScript_setBreakpoint(JSContext *cx, uintN argc, Value *vp)
75506: {
75513:     REQUIRE_ARGC("Debugger.Script.setBreakpoint", 2);
76265:     THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, "setBreakpoint", args, obj, script);
75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);
75506: 
75506:     JSObject *holder = GetScriptHolder(obj);
75506:     if (!dbg->observesScope(ScriptScope(cx, script, holder))) {
75506:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_DEBUGGING);
75506:         return false;
75506:     }
75506: 
75506:     size_t offset;
76265:     if (!ScriptOffset(cx, script, args[0], &offset))
75506:         return false;
75506: 
76265:     JSObject *handler = NonNullObject(cx, args[1]);
75506:     if (!handler)
75506:         return false;
75506: 
76766:     JSCompartment *comp = script->compartment;
75506:     jsbytecode *pc = script->code + offset;
75506:     BreakpointSite *site = comp->getOrCreateBreakpointSite(cx, script, pc, holder);
76270:     if (!site)
76270:         return false;
76248:     if (site->inc(cx)) {
76248:         if (cx->runtime->new_<Breakpoint>(dbg, site, handler)) {
76265:             args.rval().setUndefined();
75506:             return true;
76248:         }
75506:         site->dec(cx);
76248:     }
75506:     site->destroyIfEmpty(cx->runtime, NULL);
75506:     return false;
75506: }
75506: 
76229: static JSBool
75513: DebuggerScript_getBreakpoints(JSContext *cx, uintN argc, Value *vp)
75506: {
76265:     THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, "getBreakpoints", args, obj, script);
75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);
75506: 
75506:     jsbytecode *pc;
75506:     if (argc > 0) {
75506:         size_t offset;
76265:         if (!ScriptOffset(cx, script, args[0], &offset))
75506:             return false;
75506:         pc = script->code + offset;
75506:     } else {
75506:         pc = NULL;
75506:     }
75506: 
75506:     JSObject *arr = NewDenseEmptyArray(cx);
75506:     if (!arr)
75506:         return false;
76766:     JSCompartment *comp = script->compartment;
75506:     for (BreakpointSiteMap::Range r = comp->breakpointSites.all(); !r.empty(); r.popFront()) {
75506:         BreakpointSite *site = r.front().value;
75506:         if (site->script == script && (!pc || site->pc == pc)) {
75506:             for (Breakpoint *bp = site->firstBreakpoint(); bp; bp = bp->nextInSite()) {
75506:                 if (bp->debugger == dbg &&
75510:                     !js_NewbornArrayPush(cx, arr, ObjectValue(*bp->getHandler())))
75506:                 {
75506:                     return false;
75506:                 }
75506:             }
75506:         }
75506:     }
76265:     args.rval().setObject(*arr);
75506:     return true;
75506: }
75506: 
76229: static JSBool
75513: DebuggerScript_clearBreakpoint(JSContext *cx, uintN argc, Value *vp)
75506: {
75513:     REQUIRE_ARGC("Debugger.Script.clearBreakpoint", 1);
76265:     THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, "clearBreakpoint", args, obj, script);
75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);
75506: 
76265:     JSObject *handler = NonNullObject(cx, args[0]);
75506:     if (!handler)
75506:         return false;
75506: 
76766:     script->compartment->clearBreakpointsIn(cx, dbg, script, handler);
76265:     args.rval().setUndefined();
75506:     return true;
75506: }
75506: 
76229: static JSBool
75513: DebuggerScript_clearAllBreakpoints(JSContext *cx, uintN argc, Value *vp)
75506: {
76265:     THIS_DEBUGSCRIPT_LIVE_SCRIPT(cx, argc, vp, "clearBreakpoint", args, obj, script);
75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);
76766:     script->compartment->clearBreakpointsIn(cx, dbg, script, NULL);
76265:     args.rval().setUndefined();
75506:     return true;
75506: }
75506: 
75492: static JSBool
75513: DebuggerScript_construct(JSContext *cx, uintN argc, Value *vp)
75492: {
75513:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_CONSTRUCTOR, "Debugger.Script");
75492:     return false;
75492: }
75492: 
75513: static JSPropertySpec DebuggerScript_properties[] = {
75522:     JS_PSG("url", DebuggerScript_getUrl, 0),
75522:     JS_PSG("startLine", DebuggerScript_getStartLine, 0),
75522:     JS_PSG("lineCount", DebuggerScript_getLineCount, 0),
75513:     JS_PSG("live", DebuggerScript_getLive, 0),
75492:     JS_PS_END
75492: };
75492: 
75513: static JSFunctionSpec DebuggerScript_methods[] = {
75513:     JS_FN("getChildScripts", DebuggerScript_getChildScripts, 0, 0),
75513:     JS_FN("getAllOffsets", DebuggerScript_getAllOffsets, 0, 0),
75513:     JS_FN("getLineOffsets", DebuggerScript_getLineOffsets, 1, 0),
75513:     JS_FN("getOffsetLine", DebuggerScript_getOffsetLine, 0, 0),
75513:     JS_FN("setBreakpoint", DebuggerScript_setBreakpoint, 2, 0),
75513:     JS_FN("getBreakpoints", DebuggerScript_getBreakpoints, 1, 0),
75513:     JS_FN("clearBreakpoint", DebuggerScript_clearBreakpoint, 1, 0),
75513:     JS_FN("clearAllBreakpoints", DebuggerScript_clearAllBreakpoints, 0, 0),
75492:     JS_FS_END
75492: };
75492: 
75492: 
76236: /*** Debugger.Frame ******************************************************************************/
75413: 
75513: Class DebuggerFrame_class = {
75417:     "Frame", JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUGFRAME_COUNT),
75413:     PropertyStub, PropertyStub, PropertyStub, StrictPropertyStub,
75464:     EnumerateStub, ResolveStub, ConvertStub
75413: };
75413: 
75419: static JSObject *
76266: CheckThisFrame(JSContext *cx, const CallArgs &args, const char *fnname, bool checkLive)
75414: {
76266:     if (!args.thisv().isObject()) {
75414:         ReportObjectRequired(cx);
75414:         return NULL;
75414:     }
76266:     JSObject *thisobj = &args.thisv().toObject();
75513:     if (thisobj->getClass() != &DebuggerFrame_class) {
75414:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
75513:                              "Debugger.Frame", fnname, thisobj->getClass()->name);
75414:         return NULL;
75414:     }
75414: 
76236:     /*
76236:      * Forbid Debugger.Frame.prototype, which is of class DebuggerFrame_class
76236:      * but isn't really a working Debugger.Frame object. The prototype object
76236:      * is distinguished by having a NULL private value. Also, forbid popped
76236:      * frames.
76236:      */
75414:     if (!thisobj->getPrivate()) {
75417:         if (thisobj->getReservedSlot(JSSLOT_DEBUGFRAME_OWNER).isUndefined()) {
75414:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
75513:                                  "Debugger.Frame", fnname, "prototype object");
75414:             return NULL;
75414:         }
75414:         if (checkLive) {
75492:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_LIVE,
75513:                                  "Debugger.Frame", fnname, "stack frame");
75414:             return NULL;
75414:         }
75414:     }
75414:     return thisobj;
75414: }
75414: 
75484: #if DEBUG
75484: static bool
75484: StackContains(JSContext *cx, StackFrame *fp)
75484: {
75485:     for (AllFramesIter i(cx->stack.space()); !i.done(); ++i) {
75484:         if (fp == i.fp())
75484:             return true;
75484:     }
75484:     return false;
75484: }
75484: #endif
75484: 
76266: #define THIS_FRAME(cx, argc, vp, fnname, args, thisobj, fp)                  \
76266:     CallArgs args = CallArgsFromVp(argc, vp);                                \
76266:     JSObject *thisobj = CheckThisFrame(cx, args, fnname, true);              \
75413:     if (!thisobj)                                                            \
75413:         return false;                                                        \
75472:     StackFrame *fp = (StackFrame *) thisobj->getPrivate();                   \
75484:     JS_ASSERT(StackContains(cx, fp))
75413: 
75419: static JSBool
75513: DebuggerFrame_getType(JSContext *cx, uintN argc, Value *vp)
75413: {
76266:     THIS_FRAME(cx, argc, vp, "get type", args, thisobj, fp);
75413: 
76236:     /*
76236:      * Indirect eval frames are both isGlobalFrame() and isEvalFrame(), so the
76236:      * order of checks here is significant.
76236:      */
76266:     args.rval().setString(fp->isEvalFrame()
75413:                           ? cx->runtime->atomState.evalAtom
75413:                           : fp->isGlobalFrame()
75413:                           ? cx->runtime->atomState.globalAtom
75413:                           : cx->runtime->atomState.callAtom);
75413:     return true;
75413: }
75413: 
75420: static JSBool
75513: DebuggerFrame_getCallee(JSContext *cx, uintN argc, Value *vp)
75420: {
76266:     THIS_FRAME(cx, argc, vp, "get callee", args, thisobj, fp);
76266:     Value calleev = (fp->isFunctionFrame() && !fp->isEvalFrame()) ? fp->calleev() : NullValue();
76266:     if (!Debugger::fromChildJSObject(thisobj)->wrapDebuggeeValue(cx, &calleev))
76266:         return false;
76266:     args.rval() = calleev;
76266:     return true;
75420: }
75420: 
75420: static JSBool
75513: DebuggerFrame_getGenerator(JSContext *cx, uintN argc, Value *vp)
75413: {
76266:     THIS_FRAME(cx, argc, vp, "get generator", args, thisobj, fp);
76266:     args.rval().setBoolean(fp->isGeneratorFrame());
75413:     return true;
75413: }
75413: 
75419: static JSBool
75513: DebuggerFrame_getConstructing(JSContext *cx, uintN argc, Value *vp)
75445: {
76266:     THIS_FRAME(cx, argc, vp, "get constructing", args, thisobj, fp);
76266:     args.rval().setBoolean(fp->isFunctionFrame() && fp->isConstructing());
75445:     return true;
75445: }
75445: 
75445: static JSBool
75513: DebuggerFrame_getThis(JSContext *cx, uintN argc, Value *vp)
75418: {
76266:     THIS_FRAME(cx, argc, vp, "get this", args, thisobj, fp);
76266:     Value thisv;
75419:     {
75419:         AutoCompartment ac(cx, &fp->scopeChain());
75419:         if (!ac.enter())
75419:             return false;
75419:         if (!ComputeThis(cx, fp))
75419:             return false;
76266:         thisv = fp->thisValue();
76266:     }
76266:     if (!Debugger::fromChildJSObject(thisobj)->wrapDebuggeeValue(cx, &thisv))
76266:         return false;
76266:     args.rval() = thisv;
76266:     return true;
75425: }
75425: 
75425: static JSBool
75513: DebuggerFrame_getOlder(JSContext *cx, uintN argc, Value *vp)
75425: {
76266:     THIS_FRAME(cx, argc, vp, "get this", args, thisobj, thisfp);
75513:     Debugger *dbg = Debugger::fromChildJSObject(thisobj);
75425:     for (StackFrame *fp = thisfp->prev(); fp; fp = fp->prev()) {
75444:         if (!fp->isDummyFrame() && dbg->observesFrame(fp))
75444:             return dbg->getScriptFrame(cx, fp, vp);
75425:     }
76266:     args.rval().setNull();
75425:     return true;
75418: }
75418: 
75513: Class DebuggerArguments_class = {
75464:     "Arguments", JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUGARGUMENTS_COUNT),
75464:     PropertyStub, PropertyStub, PropertyStub, StrictPropertyStub,
75464:     EnumerateStub, ResolveStub, ConvertStub
75464: };
75464: 
76236: /* The getter used for each element of frame.arguments. See DebuggerFrame_getArguments. */
76229: static JSBool
75513: DebuggerArguments_getArg(JSContext *cx, uintN argc, Value *vp)
75464: {
76266:     CallArgs args = CallArgsFromVp(argc, vp);
76266:     int32 i = args.callee().getReservedSlot(0).toInt32();
75464: 
76236:     /* Check that the this value is an Arguments object. */
76266:     if (!args.thisv().isObject()) {
75464:         ReportObjectRequired(cx);
75464:         return false;
75464:     }
76266:     JSObject *argsobj = &args.thisv().toObject();
75513:     if (argsobj->getClass() != &DebuggerArguments_class) {
75464:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
75464:                              "Arguments", "getArgument", argsobj->getClass()->name);
75464:         return false;
75464:     }
75464: 
76236:     /*
76236:      * Put the Debugger.Frame into the this-value slot, then use THIS_FRAME
76236:      * to check that it is still live and get the fp.
76236:      */
76266:     args.thisv() = argsobj->getReservedSlot(JSSLOT_DEBUGARGUMENTS_FRAME);
76266:     THIS_FRAME(cx, argc, vp, "get argument", ca2, thisobj, fp);
75464: 
76236:     /*
76236:      * Since getters can be extracted and applied to other objects,
76236:      * there is no guarantee this object has an ith argument.
76236:      */
75464:     JS_ASSERT(i >= 0);
76266:     Value arg;
75464:     if (uintN(i) < fp->numActualArgs())
76266:         arg = fp->canonicalActualArg(i);
75464:     else
76266:         arg.setUndefined();
76266: 
76266:     if (!Debugger::fromChildJSObject(thisobj)->wrapDebuggeeValue(cx, &arg))
76266:         return false;
76266:     args.rval() = arg;
76266:     return true;
75464: }
75464: 
76229: static JSBool
75513: DebuggerFrame_getArguments(JSContext *cx, uintN argc, Value *vp)
75418: {
76266:     THIS_FRAME(cx, argc, vp, "get arguments", args, thisobj, fp);
75464:     Value argumentsv = thisobj->getReservedSlot(JSSLOT_DEBUGFRAME_ARGUMENTS);
75464:     if (!argumentsv.isUndefined()) {
75464:         JS_ASSERT(argumentsv.isObjectOrNull());
76266:         args.rval() = argumentsv;
75464:         return true;
75464:     }
75464: 
75464:     JSObject *argsobj;
75464:     if (fp->hasArgs()) {
76236:         /* Create an arguments object. */
76266:         GlobalObject *global = args.callee().getGlobal();
75464:         JSObject *proto;
75464:         if (!js_GetClassPrototype(cx, global, JSProto_Array, &proto))
75464:             return false;
75513:         argsobj = NewNonFunction<WithProto::Given>(cx, &DebuggerArguments_class, proto, global);
75464:         if (!argsobj ||
75464:             !js_SetReservedSlot(cx, argsobj, JSSLOT_DEBUGARGUMENTS_FRAME, ObjectValue(*thisobj)))
75464:         {
75464:             return false;
75464:         }
75464: 
75464:         JS_ASSERT(fp->numActualArgs() <= 0x7fffffff);
75464:         int32 fargc = int32(fp->numActualArgs());
75464:         if (!DefineNativeProperty(cx, argsobj, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom),
75464:                                   Int32Value(fargc), NULL, NULL,
75464:                                   JSPROP_PERMANENT | JSPROP_READONLY, 0, 0))
75464:         {
75464:             return false;
75464:         }
75464: 
75464:         for (int32 i = 0; i < fargc; i++) {
75513:             JSObject *getobj =
75513:                 js_NewFunction(cx, NULL, DebuggerArguments_getArg, 0, 0, global, NULL);
75464:             if (!getobj ||
75464:                 !js_SetReservedSlot(cx, getobj, 0, Int32Value(i)) ||
75464:                 !DefineNativeProperty(cx, argsobj, INT_TO_JSID(i), UndefinedValue(),
75464:                                       JS_DATA_TO_FUNC_PTR(PropertyOp, getobj), NULL,
75464:                                       JSPROP_ENUMERATE | JSPROP_SHARED | JSPROP_GETTER, 0, 0))
75464:             {
75464:                 return false;
75464:             }
75464:         }
75464:     } else {
75464:         argsobj = NULL;
75464:     }
76266:     args.rval() = ObjectOrNullValue(argsobj);
76266:     thisobj->setReservedSlot(JSSLOT_DEBUGFRAME_ARGUMENTS, args.rval());
75418:     return true;
75418: }
75418: 
75419: static JSBool
75513: DebuggerFrame_getScript(JSContext *cx, uintN argc, Value *vp)
75492: {
76266:     THIS_FRAME(cx, argc, vp, "get script", args, thisobj, fp);
75513:     Debugger *debug = Debugger::fromChildJSObject(thisobj);
75492: 
75492:     JSObject *scriptObject = NULL;
75492:     if (fp->isFunctionFrame() && !fp->isEvalFrame()) {
75492:         JSFunction *callee = fp->callee().getFunctionPrivate();
75492:         if (callee->isInterpreted()) {
75492:             scriptObject = debug->wrapFunctionScript(cx, callee);
75492:             if (!scriptObject)
75492:                 return false;
75492:         }
75492:     } else if (fp->isScriptFrame()) {
76236:         /*
76236:          * eval, JS_Evaluate*, and JS_ExecuteScript all create non-function
76236:          * script frames. However, scripts for JS_ExecuteScript are held by
76236:          * script objects, and must go in heldScripts, whereas scripts for eval
76236:          * and JS_Evaluate* latter are explicitly destroyed when the call
76236:          * returns, and must go in nonHeldScripts. Distinguish the two cases by
76236:          * checking whether the script has a Script object allocated to it.
76236:          */
75492:         JSScript *script = fp->script();
75517:         scriptObject = (script->u.object)
75517:                        ? debug->wrapJSAPIScript(cx, script->u.object)
75517:                        : debug->wrapNonHeldScript(cx, script);
75492:         if (!scriptObject)
75492:             return false;
75492:     }
76266:     args.rval().setObjectOrNull(scriptObject);
75492:     return true;
75492: }
75492: 
75492: static JSBool
75513: DebuggerFrame_getOffset(JSContext *cx, uintN argc, Value *vp)
75500: {
76266:     THIS_FRAME(cx, argc, vp, "get offset", args, thisobj, fp);
75500:     if (fp->isScriptFrame()) {
75500:         JSScript *script = fp->script();
75500:         jsbytecode *pc = fp->pcQuadratic(cx);
75500:         JS_ASSERT(script->code <= pc);
75500:         JS_ASSERT(pc < script->code + script->length);
75500:         size_t offset = pc - script->code;
76266:         args.rval().setNumber(double(offset));
75500:     } else {
76266:         args.rval().setUndefined();
75500:     }
75500:     return true;
75500: }
75500: 
75500: static JSBool
75513: DebuggerFrame_getLive(JSContext *cx, uintN argc, Value *vp)
75414: {
76266:     CallArgs args = CallArgsFromVp(argc, vp);
76266:     JSObject *thisobj = CheckThisFrame(cx, args, "get live", false);
75414:     if (!thisobj)
75414:         return false;
75415:     StackFrame *fp = (StackFrame *) thisobj->getPrivate();
76266:     args.rval().setBoolean(!!fp);
75414:     return true;
75414: }
75414: 
77171: static bool
77171: IsValidHook(const Value &v)
77171: {
77171:     return v.isUndefined() || (v.isObject() && v.toObject().isCallable());
77171: }
77171: 
77171: static JSBool
77171: DebuggerFrame_getOnStep(JSContext *cx, uintN argc, Value *vp)
77171: {
77171:     THIS_FRAME(cx, argc, vp, "get onStep", args, thisobj, fp);
77171:     (void) fp;  // Silence GCC warning
77171:     Value handler = thisobj->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER);
77171:     JS_ASSERT(IsValidHook(handler));
77171:     args.rval() = handler;
77171:     return true;
77171: }
77171: 
77171: static JSBool
77171: DebuggerFrame_setOnStep(JSContext *cx, uintN argc, Value *vp)
77171: {
77171:     REQUIRE_ARGC("Debugger.Frame.set onStep", 1);
77171:     THIS_FRAME(cx, argc, vp, "set onStep", args, thisobj, fp);
77171:     if (!fp->isScriptFrame()) {
77171:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_SCRIPT_FRAME);
77171:         return false;
77171:     }
77171:     if (!IsValidHook(args[0])) {
77171:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_CALLABLE_OR_UNDEFINED);
77171:         return false;
77171:     }
77171: 
77171:     Value prior = thisobj->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER);
77171:     int delta = !args[0].isUndefined() - !prior.isUndefined();
77171:     if (delta != 0) {
77171:         /* Try to adjust this frame's script single-step mode count. */
77171:         AutoCompartment ac(cx, &fp->scopeChain());
77171:         if (!ac.enter())
77171:             return false;
77171:         if (!fp->script()->changeStepModeCount(cx, delta))
77171:             return false;
77171:     }
77171: 
77171:     /* Now that the step mode switch has succeeded, we can install the handler. */
77171:     thisobj->setReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER, args[0]);
77171:     args.rval().setUndefined();
77171:     return true;
77171: }
77171: 
75472: namespace js {
75472: 
75472: JSBool
75472: EvaluateInScope(JSContext *cx, JSObject *scobj, StackFrame *fp, const jschar *chars,
75472:                 uintN length, const char *filename, uintN lineno, Value *rval)
75472: {
75472:     assertSameCompartment(cx, scobj, fp);
75472: 
76826:     /* Execute assumes an already-computed 'this" value. */
76826:     if (!ComputeThis(cx, fp))
76826:         return false;
76826: 
75472:     /*
75472:      * NB: This function breaks the assumption that the compiler can see all
75472:      * calls and properly compute a static level. In order to get around this,
75472:      * we use a static level that will cause us not to attempt to optimize
75472:      * variable references made by this frame.
75472:      */
75472:     JSScript *script = Compiler::compileScript(cx, scobj, fp, fp->scopeChain().principals(cx),
75472:                                                TCF_COMPILE_N_GO, chars, length,
75472:                                                filename, lineno, cx->findVersion(),
75472:                                                NULL, UpvarCookie::UPVAR_LEVEL_LIMIT);
75472: 
75472:     if (!script)
75472:         return false;
75472: 
76829:     bool ok = ExecuteKernel(cx, script, *scobj, fp->thisValue(), EXECUTE_DEBUG, fp, rval);
76766:     js_DestroyScript(cx, script, 6);
75472:     return ok;
75472: }
75472: 
75472: }
75472: 
75472: enum EvalBindingsMode { WithoutBindings, WithBindings };
75472: 
75419: static JSBool
75513: DebuggerFrameEval(JSContext *cx, uintN argc, Value *vp, EvalBindingsMode mode)
75433: {
76266:     if (mode == WithBindings)
76266:         REQUIRE_ARGC("Debugger.Frame.evalWithBindings", 2);
76266:     else
76266:         REQUIRE_ARGC("Debugger.Frame.eval", 1);
76266:     THIS_FRAME(cx, argc, vp, mode == WithBindings ? "evalWithBindings" : "eval",
76266:                args, thisobj, fp);
76266:     Debugger *dbg = Debugger::fromChildJSObject(thisobj);
75433: 
76236:     /* Check the first argument, the eval code string. */
76266:     if (!args[0].isString()) {
75433:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_EXPECTED_TYPE,
76266:                              "Debugger.Frame.eval", "string", InformalValueTypeName(args[0]));
75433:         return false;
75433:     }
76266:     JSLinearString *linearStr = args[0].toString()->ensureLinear(cx);
75433:     if (!linearStr)
75433:         return false;
75472: 
76236:     /*
76236:      * Gather keys and values of bindings, if any. This must be done in the
76236:      * debugger compartment, since that is where any exceptions must be
76236:      * thrown.
76236:      */
75472:     AutoIdVector keys(cx);
75472:     AutoValueVector values(cx);
75472:     if (mode == WithBindings) {
76266:         JSObject *bindingsobj = NonNullObject(cx, args[1]);
75472:         if (!bindingsobj ||
75472:             !GetPropertyNames(cx, bindingsobj, JSITER_OWNONLY, &keys) ||
75472:             !values.growBy(keys.length()))
75472:         {
75472:             return false;
75472:         }
75472:         for (size_t i = 0; i < keys.length(); i++) {
76266:             Value *valp = &values[i];
76266:             if (!bindingsobj->getProperty(cx, bindingsobj, keys[i], valp) ||
76266:                 !dbg->unwrapDebuggeeValue(cx, valp))
75472:             {
75472:                 return false;
75472:             }
75472:         }
75472:     }
75433: 
75433:     AutoCompartment ac(cx, &fp->scopeChain());
75433:     if (!ac.enter())
75433:         return false;
75472: 
76236:     /* Get a scope object. */
75472:     if (fp->isNonEvalFunctionFrame() && !fp->hasCallObj() && !CreateFunCallObject(cx, fp))
75472:         return false;
75472:     JSObject *scobj = GetScopeChain(cx, fp);
75472:     if (!scobj)
75472:         return false;
75472: 
76236:     /* If evalWithBindings, create the inner scope object. */
75472:     if (mode == WithBindings) {
76236:         /* TODO - Should probably create a With object here. */
75472:         scobj = NewNonFunction<WithProto::Given>(cx, &js_ObjectClass, NULL, scobj);
75472:         if (!scobj)
75472:             return false;
75472:         for (size_t i = 0; i < keys.length(); i++) {
75472:             if (!cx->compartment->wrap(cx, &values[i]) ||
75472:                 !DefineNativeProperty(cx, scobj, keys[i], values[i], NULL, NULL, 0, 0, 0))
75472:             {
75472:                 return false;
75472:             }
75472:         }
75472:     }
75472: 
76236:     /* Run the code and produce the completion value. */
75433:     Value rval;
75472:     JS::Anchor<JSString *> anchor(linearStr);
75472:     bool ok = EvaluateInScope(cx, scobj, fp, linearStr->chars(), linearStr->length(),
75472:                               "debugger eval code", 1, &rval);
75433:     return dbg->newCompletionValue(ac, ok, rval, vp);
75433: }
75433: 
75433: static JSBool
75513: DebuggerFrame_eval(JSContext *cx, uintN argc, Value *vp)
75472: {
75513:     return DebuggerFrameEval(cx, argc, vp, WithoutBindings);
75472: }
75472: 
75472: static JSBool
75513: DebuggerFrame_evalWithBindings(JSContext *cx, uintN argc, Value *vp)
75472: {
75513:     return DebuggerFrameEval(cx, argc, vp, WithBindings);
75472: }
75472: 
75472: static JSBool
75513: DebuggerFrame_construct(JSContext *cx, uintN argc, Value *vp)
75413: {
75513:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_CONSTRUCTOR, "Debugger.Frame");
75413:     return false;
75413: }
75413: 
75513: static JSPropertySpec DebuggerFrame_properties[] = {
75513:     JS_PSG("arguments", DebuggerFrame_getArguments, 0),
75513:     JS_PSG("callee", DebuggerFrame_getCallee, 0),
75513:     JS_PSG("constructing", DebuggerFrame_getConstructing, 0),
75513:     JS_PSG("generator", DebuggerFrame_getGenerator, 0),
75513:     JS_PSG("live", DebuggerFrame_getLive, 0),
75513:     JS_PSG("offset", DebuggerFrame_getOffset, 0),
75513:     JS_PSG("older", DebuggerFrame_getOlder, 0),
75513:     JS_PSG("script", DebuggerFrame_getScript, 0),
75513:     JS_PSG("this", DebuggerFrame_getThis, 0),
75513:     JS_PSG("type", DebuggerFrame_getType, 0),
77171:     JS_PSGS("onStep", DebuggerFrame_getOnStep, DebuggerFrame_setOnStep, 0),
75413:     JS_PS_END
75413: };
75413: 
75513: static JSFunctionSpec DebuggerFrame_methods[] = {
75513:     JS_FN("eval", DebuggerFrame_eval, 1, 0),
75513:     JS_FN("evalWithBindings", DebuggerFrame_evalWithBindings, 1, 0),
75433:     JS_FS_END
75433: };
75433: 
75466: 
76236: /*** Debugger.Object *****************************************************************************/
75418: 
75495: static void
75513: DebuggerObject_trace(JSTracer *trc, JSObject *obj)
75495: {
75496:     if (!trc->context->runtime->gcCurrentCompartment) {
75498:         if (JSObject *referent = (JSObject *) obj->getPrivate())
75513:             MarkObject(trc, *referent, "Debugger.Object referent");
75495:     }
75496: }
75495: 
75513: Class DebuggerObject_class = {
75421:     "Object", JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUGOBJECT_COUNT),
75418:     PropertyStub, PropertyStub, PropertyStub, StrictPropertyStub,
75495:     EnumerateStub, ResolveStub, ConvertStub, NULL,
75495:     NULL,                 /* reserved0   */
75495:     NULL,                 /* checkAccess */
75495:     NULL,                 /* call        */
75495:     NULL,                 /* construct   */
75495:     NULL,                 /* xdrObject   */
75495:     NULL,                 /* hasInstance */
75513:     DebuggerObject_trace
75418: };
75418: 
75419: static JSObject *
76267: DebuggerObject_checkThis(JSContext *cx, const CallArgs &args, const char *fnname)
75419: {
76267:     if (!args.thisv().isObject()) {
75419:         ReportObjectRequired(cx);
75419:         return NULL;
75419:     }
76267:     JSObject *thisobj = &args.thisv().toObject();
75513:     if (thisobj->clasp != &DebuggerObject_class) {
75419:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
75513:                              "Debugger.Object", fnname, thisobj->getClass()->name);
75419:         return NULL;
75419:     }
75419: 
76236:     /*
76236:      * Forbid Debugger.Object.prototype, which is of class DebuggerObject_class
76236:      * but isn't a real working Debugger.Object. The prototype object is
76236:      * distinguished by having no referent.
76236:      */
75495:     if (!thisobj->getPrivate()) {
75419:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
75513:                              "Debugger.Object", fnname, "prototype object");
75419:         return NULL;
75419:     }
75419:     return thisobj;
75419: }
75419: 
76267: #define THIS_DEBUGOBJECT_REFERENT(cx, argc, vp, fnname, args, obj)            \
76267:     CallArgs args = CallArgsFromVp(argc, vp);                                 \
76267:     JSObject *obj = DebuggerObject_checkThis(cx, args, fnname);               \
75451:     if (!obj)                                                                 \
75419:         return false;                                                         \
75495:     obj = (JSObject *) obj->getPrivate();                                     \
75495:     JS_ASSERT(obj)
75419: 
76267: #define THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, fnname, args, dbg, obj) \
76267:     CallArgs args = CallArgsFromVp(argc, vp);                                 \
76267:     JSObject *obj = DebuggerObject_checkThis(cx, args, fnname);               \
75488:     if (!obj)                                                                 \
75488:         return false;                                                         \
75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);                         \
75495:     obj = (JSObject *) obj->getPrivate();                                     \
75495:     JS_ASSERT(obj)
75488: 
75419: static JSBool
75513: DebuggerObject_construct(JSContext *cx, uintN argc, Value *vp)
75418: {
75513:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_CONSTRUCTOR, "Debugger.Object");
75418:     return false;
75418: }
75418: 
75419: static JSBool
75513: DebuggerObject_getProto(JSContext *cx, uintN argc, Value *vp)
75432: {
76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "get proto", args, dbg, refobj);
76267:     Value protov = ObjectOrNullValue(refobj->getProto());
76267:     if (!dbg->wrapDebuggeeValue(cx, &protov))
76267:         return false;
76267:     args.rval() = protov;
76267:     return true;
75432: }
75432: 
75432: static JSBool
75513: DebuggerObject_getClass(JSContext *cx, uintN argc, Value *vp)
75419: {
76267:     THIS_DEBUGOBJECT_REFERENT(cx, argc, vp, "get class", args, refobj);
75419:     const char *s = refobj->clasp->name;
75448:     JSAtom *str = js_Atomize(cx, s, strlen(s));
75419:     if (!str)
75419:         return false;
76267:     args.rval().setString(str);
75419:     return true;
75419: }
75419: 
75420: static JSBool
75513: DebuggerObject_getCallable(JSContext *cx, uintN argc, Value *vp)
75438: {
76267:     THIS_DEBUGOBJECT_REFERENT(cx, argc, vp, "get callable", args, refobj);
76267:     args.rval().setBoolean(refobj->isCallable());
75438:     return true;
75438: }
75438: 
75438: static JSBool
75513: DebuggerObject_getName(JSContext *cx, uintN argc, Value *vp)
75420: {
76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "get name", args, dbg, obj);
75460:     if (!obj->isFunction()) {
76267:         args.rval().setUndefined();
75460:         return true;
75460:     }
75460: 
75460:     JSString *name = obj->getFunctionPrivate()->atom;
75460:     if (!name) {
76267:         args.rval().setUndefined();
75460:         return true;
75460:     }
75460: 
76267:     Value namev = StringValue(name);
76267:     if (!dbg->wrapDebuggeeValue(cx, &namev))
76267:         return false;
76267:     args.rval() = namev;
76267:     return true;
75421: }
75460: 
75460: static JSBool
75513: DebuggerObject_getParameterNames(JSContext *cx, uintN argc, Value *vp)
75460: {
76267:     THIS_DEBUGOBJECT_REFERENT(cx, argc, vp, "get parameterNames", args, obj);
75460:     if (!obj->isFunction()) {
76267:         args.rval().setUndefined();
75460:         return true;
75428:     }
75460: 
75460:     const JSFunction *fun = obj->getFunctionPrivate();
75460:     JSObject *result = NewDenseAllocatedArray(cx, fun->nargs, NULL);
75460:     if (!result)
75460:         return false;
75460: 
75460:     if (fun->isInterpreted()) {
75460:         JS_ASSERT(fun->nargs == fun->script()->bindings.countArgs());
75460: 
75460:         if (fun->nargs > 0) {
75510:             Vector<JSAtom *> names(cx);
75510:             if (!fun->script()->bindings.getLocalNameArray(cx, &names))
75460:                 return false;
75460: 
75460:             for (size_t i = 0; i < fun->nargs; i++) {
75510:                 JSAtom *name = names[i];
76246:                 result->setDenseArrayElement(i, name ? StringValue(name) : UndefinedValue());
75460:             }
75460:         }
75460:     } else {
75460:         for (size_t i = 0; i < fun->nargs; i++)
76246:             result->setDenseArrayElement(i, UndefinedValue());
75460:     }
75460: 
76267:     args.rval().setObject(*result);
75421:     return true;
75421: }
75421: 
75492: static JSBool
75513: DebuggerObject_getScript(JSContext *cx, uintN argc, Value *vp)
75492: {
76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "get script", args, dbg, obj);
76267: 
76267:     args.rval().setUndefined();
75492: 
75492:     if (!obj->isFunction())
75492:         return true;
75492: 
75492:     JSFunction *fun = obj->getFunctionPrivate();
75492:     if (!fun->isInterpreted())
75492:         return true;
75492: 
75492:     JSObject *scriptObject = dbg->wrapFunctionScript(cx, fun);
75492:     if (!scriptObject)
75492:         return false;
75492: 
76267:     args.rval().setObject(*scriptObject);
75492:     return true;
75492: }
75492: 
76214: static JSBool
76214: DebuggerObject_getOwnPropertyDescriptor(JSContext *cx, uintN argc, Value *vp)
76214: {
76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "getOwnPropertyDescriptor", args, dbg, obj);
76214: 
76214:     jsid id;
76267:     if (!ValueToId(cx, argc >= 1 ? args[0] : UndefinedValue(), &id))
76214:         return false;
76214: 
76236:     /* Bug: This can cause the debuggee to run! */
76214:     AutoPropertyDescriptorRooter desc(cx);
76214:     {
76214:         AutoCompartment ac(cx, obj);
76214:         if (!ac.enter() || !cx->compartment->wrapId(cx, &id))
76214:             return false;
76214: 
76810:         ErrorCopier ec(ac, dbg->toJSObject());
76214:         if (!GetOwnPropertyDescriptor(cx, obj, id, &desc))
76214:             return false;
76214:     }
76214: 
76214:     if (desc.obj) {
76236:         /* Rewrap the debuggee values in desc for the debugger. */
76214:         if (!dbg->wrapDebuggeeValue(cx, &desc.value))
76214:             return false;
76214:         if (desc.attrs & JSPROP_GETTER) {
76214:             Value get = ObjectOrNullValue(CastAsObject(desc.getter));
76214:             if (!dbg->wrapDebuggeeValue(cx, &get))
76214:                 return false;
76214:             desc.getter = CastAsPropertyOp(get.toObjectOrNull());
76214:         }
76214:         if (desc.attrs & JSPROP_SETTER) {
76214:             Value set = ObjectOrNullValue(CastAsObject(desc.setter));
76214:             if (!dbg->wrapDebuggeeValue(cx, &set))
76214:                 return false;
76214:             desc.setter = CastAsStrictPropertyOp(set.toObjectOrNull());
76214:         }
76214:     }
76214: 
76267:     return NewPropertyDescriptorObject(cx, &desc, &args.rval());
76214: }
76214: 
76215: static JSBool
76215: DebuggerObject_getOwnPropertyNames(JSContext *cx, uintN argc, Value *vp)
76215: {
76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "getOwnPropertyNames", args, dbg, obj);
76215: 
76215:     AutoIdVector keys(cx);
76215:     {
76215:         AutoCompartment ac(cx, obj);
76215:         if (!ac.enter())
76215:             return false;
76215: 
76810:         ErrorCopier ec(ac, dbg->toJSObject());
76215:         if (!GetPropertyNames(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &keys))
76215:             return false;
76215:     }
76215: 
76215:     AutoValueVector vals(cx);
76215:     if (!vals.resize(keys.length()))
76215:         return false;
76215: 
76215:     for (size_t i = 0, len = keys.length(); i < len; i++) {
76215:          jsid id = keys[i];
76215:          if (JSID_IS_INT(id)) {
76215:              JSString *str = js_ValueToString(cx, Int32Value(JSID_TO_INT(id)));
76215:              if (!str)
76215:                  return false;
76215:              vals[i].setString(str);
76215:          } else if (JSID_IS_ATOM(id)) {
76215:              vals[i].setString(JSID_TO_STRING(id));
76215:              if (!cx->compartment->wrap(cx, &vals[i]))
76215:                  return false;
76215:          } else {
76215:              vals[i].setObject(*JSID_TO_OBJECT(id));
76215:              if (!dbg->wrapDebuggeeValue(cx, &vals[i]))
76215:                  return false;
76215:          }
76215:     }
76215: 
76215:     JSObject *aobj = NewDenseCopiedArray(cx, vals.length(), vals.begin());
76215:     if (!aobj)
76215:         return false;
76267:     args.rval().setObject(*aobj);
76215:     return true;
76215: }
76215: 
76223: static bool
76223: CheckArgCompartment(JSContext *cx, JSObject *obj, const Value &v,
76223:                     const char *methodname, const char *propname)
76223: {
76223:     if (v.isObject() && v.toObject().compartment() != obj->compartment()) {
76223:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_COMPARTMENT_MISMATCH,
76223:                              methodname, propname);
76223:         return false;
76223:     }
76223:     return true;
76223: }
76223: 
76236: /*
76236:  * Convert Debugger.Objects in desc to debuggee values.
76236:  * Reject non-callable getters and setters.
76236:  */
76224: static bool
76224: UnwrapPropDesc(JSContext *cx, Debugger *dbg, JSObject *obj, PropDesc *desc)
76224: {
76224:     return (!desc->hasValue || (dbg->unwrapDebuggeeValue(cx, &desc->value) &&
76224:                                 CheckArgCompartment(cx, obj, desc->value, "defineProperty",
76224:                                                     "value"))) &&
76224:            (!desc->hasGet || (dbg->unwrapDebuggeeValue(cx, &desc->get) &&
76224:                               CheckArgCompartment(cx, obj, desc->get, "defineProperty", "get") &&
76224:                               desc->checkGetter(cx))) &&
76224:            (!desc->hasSet || (dbg->unwrapDebuggeeValue(cx, &desc->set) &&
76224:                               CheckArgCompartment(cx, obj, desc->set, "defineProperty", "set") &&
76224:                               desc->checkSetter(cx)));
76224: }
76224: 
76236: /*
76236:  * Rewrap *idp and the fields of *desc for the current compartment.  Also:
76269:  * defining a property on a proxy requires the pd field to contain a descriptor
76236:  * object, so reconstitute desc->pd if needed.
76236:  */
76224: static bool
76224: WrapIdAndPropDesc(JSContext *cx, JSObject *obj, jsid *idp, PropDesc *desc)
76224: {
76224:     JSCompartment *comp = cx->compartment;
76224:     return comp->wrapId(cx, idp) &&
76224:            comp->wrap(cx, &desc->value) &&
76224:            comp->wrap(cx, &desc->get) &&
76224:            comp->wrap(cx, &desc->set) &&
76224:            (!obj->isProxy() || desc->makeObject(cx));
76224: }
76224: 
76223: static JSBool
76223: DebuggerObject_defineProperty(JSContext *cx, uintN argc, Value *vp)
76223: {
76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "defineProperty", args, dbg, obj);
76251:     REQUIRE_ARGC("Debugger.Object.defineProperty", 2);
76223: 
76223:     jsid id;
76267:     if (!ValueToId(cx, args[0], &id))
76223:         return JS_FALSE;
76223: 
76267:     const Value &descval = args[1];
76223:     AutoPropDescArrayRooter descs(cx);
76223:     PropDesc *desc = descs.append();
76223:     if (!desc || !desc->initialize(cx, descval, false))
76223:         return false;
76223: 
76223:     desc->pd.setUndefined();
76224:     if (!UnwrapPropDesc(cx, dbg, obj, desc))
76223:         return false;
76223: 
76223:     {
76223:         AutoCompartment ac(cx, obj);
76224:         if (!ac.enter() || !WrapIdAndPropDesc(cx, obj, &id, desc))
76223:             return false;
76224: 
76224:         ErrorCopier ec(ac, dbg->toJSObject());
76224:         bool dummy;
76224:         if (!DefineProperty(cx, obj, id, *desc, true, &dummy))
76223:             return false;
76223:     }
76223: 
76267:     args.rval().setUndefined();
76223:     return true;
76223: }
76214: 
76224: static JSBool
76224: DebuggerObject_defineProperties(JSContext *cx, uintN argc, Value *vp)
76224: {
76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "defineProperties", args, dbg, obj);
76224:     REQUIRE_ARGC("Debugger.Object.defineProperties", 1);
76267:     JSObject *props = ToObject(cx, &args[0]);
76224:     if (!props)
76224:         return false;
76224: 
76224:     AutoIdVector ids(cx);
76224:     AutoPropDescArrayRooter descs(cx);
76224:     if (!ReadPropertyDescriptors(cx, props, false, &ids, &descs))
76224:         return false;
76224:     size_t n = ids.length();
76224: 
76224:     for (size_t i = 0; i < n; i++) {
76224:         if (!UnwrapPropDesc(cx, dbg, obj, &descs[i]))
76224:             return false;
76224:     }
76224: 
76224:     {
76224:         AutoCompartment ac(cx, obj);
76224:         if (!ac.enter())
76224:             return false;
76224:         for (size_t i = 0; i < n; i++) {
76224:             if (!WrapIdAndPropDesc(cx, obj, &ids[i], &descs[i]))
76224:                 return false;
76224:         }
76224: 
76224:         ErrorCopier ec(ac, dbg->toJSObject());
76224:         for (size_t i = 0; i < n; i++) {
76224:             bool dummy;
76224:             if (!DefineProperty(cx, obj, ids[i], descs[i], true, &dummy))
76224:                 return false;
76224:         }
76224:     }
76224: 
76267:     args.rval().setUndefined();
76224:     return true;
76224: }
76224: 
76236: /*
76236:  * This does a non-strict delete, as a matter of API design. The case where the
76236:  * property is non-configurable isn't necessarily exceptional here.
76236:  */
76225: static JSBool
76225: DebuggerObject_deleteProperty(JSContext *cx, uintN argc, Value *vp)
76225: {
76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "deleteProperty", args, dbg, obj);
76267:     Value arg = argc > 0 ? args[0] : UndefinedValue();
76225:     jsid id;
76225:     if (!ValueToId(cx, arg, &id))
76225:         return false;
76225: 
76225:     AutoCompartment ac(cx, obj);
76225:     if (!ac.enter() || !cx->compartment->wrapId(cx, &id))
76225:         return false;
76225: 
76225:     ErrorCopier ec(ac, dbg->toJSObject());
76267:     return obj->deleteProperty(cx, id, &args.rval(), false);
76225: }
76224: 
76228: enum SealHelperOp { Seal, Freeze, PreventExtensions };
76228: 
76228: static JSBool
76228: DebuggerObject_sealHelper(JSContext *cx, uintN argc, Value *vp, SealHelperOp op, const char *name)
76228: {
76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, name, args, dbg, obj);
76228: 
76228:     AutoCompartment ac(cx, obj);
76228:     if (!ac.enter())
76228:         return false;
76228: 
76228:     ErrorCopier ec(ac, dbg->toJSObject());
76228:     bool ok;
76228:     if (op == Seal) {
76228:         ok = obj->seal(cx);
76228:     } else if (op == Freeze) {
76228:         ok = obj->freeze(cx);
76228:     } else {
76228:         JS_ASSERT(op == PreventExtensions);
76269:         if (!obj->isExtensible()) {
76269:             args.rval().setUndefined();
76228:             return true;
76269:         }
76228:         AutoIdVector props(cx);
76228:         ok = obj->preventExtensions(cx, &props);
76228:     }
76228:     if (!ok)
76228:         return false;
76267:     args.rval().setUndefined();
76267:     return true;
76228: }
76228: 
76228: static JSBool
76228: DebuggerObject_seal(JSContext *cx, uintN argc, Value *vp)
76228: {
76228:     return DebuggerObject_sealHelper(cx, argc, vp, Seal, "seal");
76228: }
76228: 
76228: static JSBool
76228: DebuggerObject_freeze(JSContext *cx, uintN argc, Value *vp)
76228: {
76228:     return DebuggerObject_sealHelper(cx, argc, vp, Freeze, "freeze");
76228: }
76228: 
76228: static JSBool
76228: DebuggerObject_preventExtensions(JSContext *cx, uintN argc, Value *vp)
76228: {
76228:     return DebuggerObject_sealHelper(cx, argc, vp, PreventExtensions, "preventExtensions");
76228: }
76228: 
76228: static JSBool
76228: DebuggerObject_isSealedHelper(JSContext *cx, uintN argc, Value *vp, SealHelperOp op,
76228:                               const char *name)
76228: {
76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, name, args, dbg, obj);
76228: 
76228:     AutoCompartment ac(cx, obj);
76228:     if (!ac.enter())
76228:         return false;
76228: 
76228:     ErrorCopier ec(ac, dbg->toJSObject());
76228:     bool r;
76228:     if (op == Seal) {
76228:         if (!obj->isSealed(cx, &r))
76228:             return false;
76228:     } else if (op == Freeze) {
76228:         if (!obj->isFrozen(cx, &r))
76228:             return false;
76228:     } else {
76228:         r = obj->isExtensible();
76228:     }
76267:     args.rval().setBoolean(r);
76228:     return true;
76228: }
76228: 
76228: static JSBool
76228: DebuggerObject_isSealed(JSContext *cx, uintN argc, Value *vp)
76228: {
76228:     return DebuggerObject_isSealedHelper(cx, argc, vp, Seal, "isSealed");
76228: }
76228: 
76228: static JSBool
76228: DebuggerObject_isFrozen(JSContext *cx, uintN argc, Value *vp)
76228: {
76228:     return DebuggerObject_isSealedHelper(cx, argc, vp, Freeze, "isFrozen");
76228: }
76228: 
76228: static JSBool
76228: DebuggerObject_isExtensible(JSContext *cx, uintN argc, Value *vp)
76228: {
76228:     return DebuggerObject_isSealedHelper(cx, argc, vp, PreventExtensions, "isExtensible");
76228: }
76228: 
75467: enum ApplyOrCallMode { ApplyMode, CallMode };
75467: 
75427: static JSBool
75467: ApplyOrCall(JSContext *cx, uintN argc, Value *vp, ApplyOrCallMode mode)
75427: {
76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "apply", args, dbg, obj);
75427: 
76236:     /*
76236:      * Any JS exceptions thrown must be in the debugger compartment, so do
76236:      * sanity checks and fallible conversions before entering the debuggee.
76236:      */
75467:     Value calleev = ObjectValue(*obj);
75427:     if (!obj->isCallable()) {
75428:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
75513:                              "Debugger.Object", "apply", obj->getClass()->name);
75427:         return false;
75427:     }
75427: 
76236:     /*
76236:      * Unwrap Debugger.Objects. This happens in the debugger's compartment since
76236:      * that is where any exceptions must be reported.
76236:      */
76267:     Value thisv = argc > 0 ? args[0] : UndefinedValue();
75467:     if (!dbg->unwrapDebuggeeValue(cx, &thisv))
75467:         return false;
75467:     uintN callArgc = 0;
75467:     Value *callArgv = NULL;
75427:     AutoValueVector argv(cx);
75467:     if (mode == ApplyMode) {
76267:         if (argc >= 2 && !args[1].isNullOrUndefined()) {
76267:             if (!args[1].isObject()) {
75513:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_APPLY_ARGS,
75513:                                      js_apply_str);
75427:                 return false;
75427:             }
76267:             JSObject *argsobj = &args[1].toObject();
75467:             if (!js_GetLengthProperty(cx, argsobj, &callArgc))
75427:                 return false;
76216:             callArgc = uintN(JS_MIN(callArgc, StackSpace::ARGS_LENGTH_MAX));
75467:             if (!argv.growBy(callArgc) || !GetElements(cx, argsobj, callArgc, argv.begin()))
75427:                 return false;
75467:             callArgv = argv.begin();
75467:         }
75467:     } else {
76216:         callArgc = argc > 0 ? uintN(JS_MIN(argc - 1, StackSpace::ARGS_LENGTH_MAX)) : 0;
76267:         callArgv = args.argv() + 1;
75467:     }
75467:     for (uintN i = 0; i < callArgc; i++) {
75467:         if (!dbg->unwrapDebuggeeValue(cx, &callArgv[i]))
75427:             return false;
75427:     }
75427: 
76236:     /*
76236:      * Enter the debuggee compartment and rewrap all input value for that compartment.
76236:      * (Rewrapping always takes place in the destination compartment.)
76236:      */
75427:     AutoCompartment ac(cx, obj);
75427:     if (!ac.enter() || !cx->compartment->wrap(cx, &calleev) || !cx->compartment->wrap(cx, &thisv))
75427:         return false;
75467:     for (uintN i = 0; i < callArgc; i++) {
75467:         if (!cx->compartment->wrap(cx, &callArgv[i]))
75427:             return false;
75427:     }
75427: 
76236:     /*
76236:      * Call the function. Use newCompletionValue to return to the debugger
76267:      * compartment and populate args.rval().
76236:      */
75427:     Value rval;
76829:     bool ok = Invoke(cx, thisv, calleev, callArgc, callArgv, &rval);
76267:     return dbg->newCompletionValue(ac, ok, rval, &args.rval());
75427: }
75427: 
75467: static JSBool
75513: DebuggerObject_apply(JSContext *cx, uintN argc, Value *vp)
75467: {
75467:     return ApplyOrCall(cx, argc, vp, ApplyMode);
75467: }
75467: 
75467: static JSBool
75513: DebuggerObject_call(JSContext *cx, uintN argc, Value *vp)
75467: {
75467:     return ApplyOrCall(cx, argc, vp, CallMode);
75467: }
75467: 
75513: static JSPropertySpec DebuggerObject_properties[] = {
75513:     JS_PSG("proto", DebuggerObject_getProto, 0),
75513:     JS_PSG("class", DebuggerObject_getClass, 0),
75513:     JS_PSG("callable", DebuggerObject_getCallable, 0),
75513:     JS_PSG("name", DebuggerObject_getName, 0),
75513:     JS_PSG("parameterNames", DebuggerObject_getParameterNames, 0),
75513:     JS_PSG("script", DebuggerObject_getScript, 0),
75421:     JS_PS_END
75421: };
75421: 
75513: static JSFunctionSpec DebuggerObject_methods[] = {
76214:     JS_FN("getOwnPropertyDescriptor", DebuggerObject_getOwnPropertyDescriptor, 1, 0),
76215:     JS_FN("getOwnPropertyNames", DebuggerObject_getOwnPropertyNames, 0, 0),
76223:     JS_FN("defineProperty", DebuggerObject_defineProperty, 2, 0),
76224:     JS_FN("defineProperties", DebuggerObject_defineProperties, 1, 0),
76225:     JS_FN("deleteProperty", DebuggerObject_deleteProperty, 1, 0),
76228:     JS_FN("seal", DebuggerObject_seal, 0, 0),
76228:     JS_FN("freeze", DebuggerObject_freeze, 0, 0),
76228:     JS_FN("preventExtensions", DebuggerObject_preventExtensions, 0, 0),
76228:     JS_FN("isSealed", DebuggerObject_isSealed, 0, 0),
76228:     JS_FN("isFrozen", DebuggerObject_isFrozen, 0, 0),
76228:     JS_FN("isExtensible", DebuggerObject_isExtensible, 0, 0),
75513:     JS_FN("apply", DebuggerObject_apply, 0, 0),
75513:     JS_FN("call", DebuggerObject_call, 0, 0),
75427:     JS_FS_END
75427: };
75427: 
75466: 
76236: /*** Glue ****************************************************************************************/
75402: 
75397: extern JS_PUBLIC_API(JSBool)
75513: JS_DefineDebuggerObject(JSContext *cx, JSObject *obj)
75397: {
75397:     JSObject *objProto;
75397:     if (!js_GetClassPrototype(cx, obj, JSProto_Object, &objProto))
75413:         return false;
75397: 
75413:     JSObject *debugCtor;
75513:     JSObject *debugProto = js_InitClass(cx, obj, objProto, &Debugger::jsclass, Debugger::construct,
75513:                                         1, Debugger::properties, Debugger::methods, NULL, NULL,
75513:                                         &debugCtor);
75413:     if (!debugProto || !debugProto->ensureClassReservedSlots(cx))
75413:         return false;
75413: 
75513:     JSObject *frameProto = js_InitClass(cx, debugCtor, objProto, &DebuggerFrame_class,
75513:                                         DebuggerFrame_construct, 0,
75513:                                         DebuggerFrame_properties, DebuggerFrame_methods,
75514:                                         NULL, NULL);
75413:     if (!frameProto)
75413:         return false;
75418: 
75513:     JSObject *scriptProto = js_InitClass(cx, debugCtor, objProto, &DebuggerScript_class,
75513:                                          DebuggerScript_construct, 0,
75513:                                          DebuggerScript_properties, DebuggerScript_methods,
75514:                                          NULL, NULL);
75514:     if (!scriptProto)
75492:         return false;
75492: 
75513:     JSObject *objectProto = js_InitClass(cx, debugCtor, objProto, &DebuggerObject_class,
75513:                                          DebuggerObject_construct, 0,
75513:                                          DebuggerObject_properties, DebuggerObject_methods,
75513:                                          NULL, NULL);
75418:     if (!objectProto)
75418:         return false;
75418: 
76234:     debugProto->setReservedSlot(Debugger::JSSLOT_DEBUG_FRAME_PROTO, ObjectValue(*frameProto));
76234:     debugProto->setReservedSlot(Debugger::JSSLOT_DEBUG_OBJECT_PROTO, ObjectValue(*objectProto));
76234:     debugProto->setReservedSlot(Debugger::JSSLOT_DEBUG_SCRIPT_PROTO, ObjectValue(*scriptProto));
75413:     return true;
75397: }
