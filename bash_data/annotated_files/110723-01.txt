 47804: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43310: 
 43310: #include "nsAccDocManager.h"
 43310: 
 96920: #include "ApplicationAccessible.h"
100057: #include "DocAccessible-inl.h"
 43310: #include "nsAccessibilityService.h"
 43310: #include "nsAccUtils.h"
 95490: #include "nsARIAMap.h"
 97643: #include "RootAccessibleWrap.h"
 67790: #include "States.h"
 43310: 
 99203: #ifdef DEBUG
 99203: #include "Logging.h"
 99203: #endif
 99203: 
 43310: #include "nsCURILoader.h"
 43310: #include "nsDocShellLoadTypes.h"
 43310: #include "nsIChannel.h"
 43310: #include "nsIContentViewer.h"
 43310: #include "nsIDOMDocument.h"
 72328: #include "nsEventListenerManager.h"
 43310: #include "nsIDOMEventTarget.h"
 43310: #include "nsIDOMWindow.h"
 43310: #include "nsIInterfaceRequestorUtils.h"
 43310: #include "nsIWebNavigation.h"
 43310: #include "nsServiceManagerUtils.h"
 43310: 
 74618: using namespace mozilla::a11y;
 74618: 
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: // nsAccDocManager
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: 
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: // nsAccDocManager public
 43310: 
 99568: DocAccessible*
 43310: nsAccDocManager::GetDocAccessible(nsIDocument *aDocument)
 43310: {
 43310:   if (!aDocument)
106838:     return nullptr;
 43310: 
 49017:   // Ensure CacheChildren is called before we query cache.
107956:   nsAccessNode::GetApplicationAccessible()->EnsureChildren();
 49017: 
 99568:   DocAccessible* docAcc = mDocAccessibleCache.GetWeak(aDocument);
 43310:   if (docAcc)
 43310:     return docAcc;
 43310: 
 43310:   return CreateDocOrRootAccessible(aDocument);
 43310: }
 43310: 
 99648: Accessible*
 56292: nsAccDocManager::FindAccessibleInCache(nsINode* aNode) const
 43310: {
 43310:   nsSearchAccessibleInCacheArg arg;
 56292:   arg.mNode = aNode;
 43310: 
 43310:   mDocAccessibleCache.EnumerateRead(SearchAccessibleInDocCache,
 43310:                                     static_cast<void*>(&arg));
 43310: 
 43310:   return arg.mAccessible;
 43310: }
 43310: 
 79853: #ifdef DEBUG
 79853: bool
 79853: nsAccDocManager::IsProcessingRefreshDriverNotification() const
 79853: {
 79853:   bool isDocRefreshing = false;
 79853:   mDocAccessibleCache.EnumerateRead(SearchIfDocIsRefreshing,
 79853:                                     static_cast<void*>(&isDocRefreshing));
 79853: 
 79853:   return isDocRefreshing;
 79853: }
 79853: #endif
 79853: 
 43765: 
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: // nsAccDocManager protected
 43310: 
 79445: bool
 43310: nsAccDocManager::Init()
 43310: {
 43310:   mDocAccessibleCache.Init(4);
 43310: 
 43310:   nsCOMPtr<nsIWebProgress> progress =
 43310:     do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
 43310: 
 43310:   if (!progress)
 80486:     return false;
 43310: 
 43310:   progress->AddProgressListener(static_cast<nsIWebProgressListener*>(this),
 43310:                                 nsIWebProgress::NOTIFY_STATE_DOCUMENT);
 43310: 
 80486:   return true;
 43310: }
 43310: 
 43310: void
 43310: nsAccDocManager::Shutdown()
 43310: {
 43310:   nsCOMPtr<nsIWebProgress> progress =
 43310:     do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
 43310: 
 43310:   if (progress)
 43310:     progress->RemoveProgressListener(static_cast<nsIWebProgressListener*>(this));
 43310: 
 43310:   ClearDocCache();
 43310: }
 43310: 
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: // nsISupports
 43310: 
 43310: NS_IMPL_THREADSAFE_ISUPPORTS3(nsAccDocManager,
 43310:                               nsIWebProgressListener,
 43310:                               nsIDOMEventListener,
 43310:                               nsISupportsWeakReference)
 43310: 
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: // nsIWebProgressListener
 43310: 
 43310: NS_IMETHODIMP
 43310: nsAccDocManager::OnStateChange(nsIWebProgress *aWebProgress,
108991:                                nsIRequest *aRequest, uint32_t aStateFlags,
 43310:                                nsresult aStatus)
 43310: {
 43310:   NS_ASSERTION(aStateFlags & STATE_IS_DOCUMENT, "Other notifications excluded");
 43310: 
 43310:   if (nsAccessibilityService::IsShutdown() || !aWebProgress ||
 43310:       (aStateFlags & (STATE_START | STATE_STOP)) == 0)
 43310:     return NS_OK;
 43310: 
 43310:   nsCOMPtr<nsIDOMWindow> DOMWindow;
 43310:   aWebProgress->GetDOMWindow(getter_AddRefs(DOMWindow));
 43310:   NS_ENSURE_STATE(DOMWindow);
 43310: 
 43310:   nsCOMPtr<nsIDOMDocument> DOMDocument;
 43310:   DOMWindow->GetDocument(getter_AddRefs(DOMDocument));
 43310:   NS_ENSURE_STATE(DOMDocument);
 43310: 
 43310:   nsCOMPtr<nsIDocument> document(do_QueryInterface(DOMDocument));
 43310: 
 43310:   // Document was loaded.
 43310:   if (aStateFlags & STATE_STOP) {
 99203: #ifdef DEBUG
 99203:     if (logging::IsEnabled(logging::eDocLoad))
 99203:       logging::DocLoad("document loaded", aWebProgress, aRequest, aStateFlags);
 99203: #endif
 43310: 
 43310:     // Figure out an event type to notify the document has been loaded.
108991:     uint32_t eventType = nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_STOPPED;
 43310: 
 43310:     // Some XUL documents get start state and then stop state with failure
 43310:     // status when everything is ok. Fire document load complete event in this
 43310:     // case.
 43310:     if (NS_SUCCEEDED(aStatus) || !nsCoreUtils::IsContentDocument(document))
 43310:       eventType = nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE;
 43310: 
 43310:     // If end consumer has been retargeted for loaded content then do not fire
 43310:     // any event because it means no new document has been loaded, for example,
 43310:     // it happens when user clicks on file link.
 43310:     if (aRequest) {
108991:       uint32_t loadFlags = 0;
 43310:       aRequest->GetLoadFlags(&loadFlags);
 43310:       if (loadFlags & nsIChannel::LOAD_RETARGETED_DOCUMENT_URI)
 43310:         eventType = 0;
 43310:     }
 43310: 
 43310:     HandleDOMDocumentLoad(document, eventType);
 43310:     return NS_OK;
 43310:   }
 43310: 
 43310:   // Document loading was started.
 99203: #ifdef DEBUG
 99203:   if (logging::IsEnabled(logging::eDocLoad))
 99203:     logging::DocLoad("start document loading", aWebProgress, aRequest, aStateFlags);
 99203: #endif
 43310: 
 99568:   DocAccessible* docAcc = mDocAccessibleCache.GetWeak(document);
 43310:   if (!docAcc)
 43310:     return NS_OK;
 43310: 
 43310:   nsCOMPtr<nsIWebNavigation> webNav(do_GetInterface(DOMWindow));
 43310:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(webNav));
 43310:   NS_ENSURE_STATE(docShell);
 43310: 
 75013:   bool isReloading = false;
108991:   uint32_t loadType;
 43310:   docShell->GetLoadType(&loadType);
 43310:   if (loadType == LOAD_RELOAD_NORMAL ||
 43310:       loadType == LOAD_RELOAD_BYPASS_CACHE ||
 43310:       loadType == LOAD_RELOAD_BYPASS_PROXY ||
 43310:       loadType == LOAD_RELOAD_BYPASS_PROXY_AND_CACHE) {
 75013:     isReloading = true;
 43310:   }
 43310: 
 75013:   docAcc->NotifyOfLoading(isReloading);
 43310:   return NS_OK;
 43310: }
 43310: 
 43310: NS_IMETHODIMP
 43310: nsAccDocManager::OnProgressChange(nsIWebProgress *aWebProgress,
 43310:                                   nsIRequest *aRequest,
108991:                                   int32_t aCurSelfProgress,
108991:                                   int32_t aMaxSelfProgress,
108991:                                   int32_t aCurTotalProgress,
108991:                                   int32_t aMaxTotalProgress)
 43310: {
 43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
 43310:   return NS_OK;
 43310: }
 43310: 
 43310: NS_IMETHODIMP
 43310: nsAccDocManager::OnLocationChange(nsIWebProgress *aWebProgress,
 82127:                                   nsIRequest *aRequest, nsIURI *aLocation,
108991:                                   uint32_t aFlags)
 43310: {
 43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
 43310:   return NS_OK;
 43310: }
 43310: 
 43310: NS_IMETHODIMP
 43310: nsAccDocManager::OnStatusChange(nsIWebProgress *aWebProgress,
 43310:                                 nsIRequest *aRequest, nsresult aStatus,
 43310:                                 const PRUnichar *aMessage)
 43310: {
 43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
 43310:   return NS_OK;
 43310: }
 43310: 
 43310: NS_IMETHODIMP
 43310: nsAccDocManager::OnSecurityChange(nsIWebProgress *aWebProgress,
 43310:                                   nsIRequest *aRequest,
108991:                                   uint32_t aState)
 43310: {
 43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
 43310:   return NS_OK;
 43310: }
 43310: 
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: // nsIDOMEventListener
 43310: 
 43310: NS_IMETHODIMP
 43310: nsAccDocManager::HandleEvent(nsIDOMEvent *aEvent)
 43310: {
 43310:   nsAutoString type;
 43310:   aEvent->GetType(type);
 43310: 
 43310:   nsCOMPtr<nsIDOMEventTarget> target;
 43310:   aEvent->GetTarget(getter_AddRefs(target));
 43310: 
 43310:   nsCOMPtr<nsIDocument> document(do_QueryInterface(target));
 43310:   NS_ASSERTION(document, "pagehide or DOMContentLoaded for non document!");
 43310:   if (!document)
 43310:     return NS_OK;
 43310: 
 43310:   if (type.EqualsLiteral("pagehide")) {
 43310:     // 'pagehide' event is registered on every DOM document we create an
 43310:     // accessible for, process the event for the target. This document
 43310:     // accessible and all its sub document accessible are shutdown as result of
 43310:     // processing.
 43310: 
 99203: #ifdef DEBUG
 99203:     if (logging::IsEnabled(logging::eDocDestroy))
 99203:       logging::DocDestroy("received 'pagehide' event", document);
 99203: #endif
 43310: 
 43310:     // Ignore 'pagehide' on temporary documents since we ignore them entirely in
 43310:     // accessibility.
 43310:     if (document->IsInitialDocument())
 43310:       return NS_OK;
 43310: 
 43310:     // Shutdown this one and sub document accessibles.
 56639: 
 56639:     // We're allowed to not remove listeners when accessible document is
 56639:     // shutdown since we don't keep strong reference on chrome event target and
 56639:     // listeners are removed automatically when chrome event target goes away.
 99568:     DocAccessible* docAccessible = mDocAccessibleCache.GetWeak(document);
 56639:     if (docAccessible)
 56639:       docAccessible->Shutdown();
 56639: 
 43310:     return NS_OK;
 43310:   }
 43310: 
 43310:   // XXX: handle error pages loading separately since they get neither
 43310:   // webprogress notifications nor 'pageshow' event.
 43310:   if (type.EqualsLiteral("DOMContentLoaded") &&
 43310:       nsCoreUtils::IsErrorPage(document)) {
 99203: #ifdef DEBUG
 99203:     if (logging::IsEnabled(logging::eDocLoad))
 99203:       logging::DocLoad("handled 'DOMContentLoaded' event", document);
 99203: #endif
 99203: 
 43310:     HandleDOMDocumentLoad(document,
 57986:                           nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE);
 43310:   }
 43310: 
 43310:   return NS_OK;
 43310: }
 43310: 
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: // nsAccDocManager private
 43310: 
 43310: void
 43310: nsAccDocManager::HandleDOMDocumentLoad(nsIDocument *aDocument,
108991:                                        uint32_t aLoadEventType)
 43310: {
 43310:   // Document accessible can be created before we were notified the DOM document
 43310:   // was loaded completely. However if it's not created yet then create it.
 99568:   DocAccessible* docAcc = mDocAccessibleCache.GetWeak(aDocument);
 43310:   if (!docAcc) {
 43310:     docAcc = CreateDocOrRootAccessible(aDocument);
 43310:     if (!docAcc)
 43310:       return;
 43310:   }
 43310: 
 75013:   docAcc->NotifyOfLoad(aLoadEventType);
 43310: }
 43310: 
 43310: void
 43310: nsAccDocManager::AddListeners(nsIDocument *aDocument,
 79445:                               bool aAddDOMContentLoadedListener)
 43310: {
 43310:   nsPIDOMWindow *window = aDocument->GetWindow();
 72326:   nsIDOMEventTarget *target = window->GetChromeEventHandler();
 80486:   nsEventListenerManager* elm = target->GetListenerManager(true);
 43310:   elm->AddEventListenerByType(this, NS_LITERAL_STRING("pagehide"),
 72331:                               NS_EVENT_FLAG_CAPTURE);
 43310: 
 99203: #ifdef DEBUG
 99203:   if (logging::IsEnabled(logging::eDocCreate))
 99203:     logging::Text("added 'pagehide' listener");
 99203: #endif
 43310: 
 43310:   if (aAddDOMContentLoadedListener) {
 43310:     elm->AddEventListenerByType(this, NS_LITERAL_STRING("DOMContentLoaded"),
 72331:                                 NS_EVENT_FLAG_CAPTURE);
 99203: #ifdef DEBUG
 99203:     if (logging::IsEnabled(logging::eDocCreate))
 99203:       logging::Text("added 'DOMContentLoaded' listener");
 99203: #endif
 43310:   }
 43310: }
 43310: 
 99568: DocAccessible*
 43310: nsAccDocManager::CreateDocOrRootAccessible(nsIDocument* aDocument)
 43310: {
 55834:   // Ignore temporary, hiding, resource documents and documents without
 55834:   // docshell.
 43763:   if (aDocument->IsInitialDocument() || !aDocument->IsVisible() ||
 55834:       aDocument->IsResourceDoc() || !aDocument->IsActive())
106838:     return nullptr;
 43310: 
 91105:   // Ignore documents without presshell and not having root frame.
 46225:   nsIPresShell* presShell = aDocument->GetShell();
110723:   if (!presShell || !presShell->GetRootFrame() || presShell->IsDestroying())
106838:     return nullptr;
 43310: 
 43310:   // Do not create document accessible until role content is loaded, otherwise
 43310:   // we get accessible document with wrong role.
 43504:   nsIContent *rootElm = nsCoreUtils::GetRoleContent(aDocument);
 43504:   if (!rootElm)
106838:     return nullptr;
 43310: 
 79445:   bool isRootDoc = nsCoreUtils::IsRootDocument(aDocument);
 43310: 
106838:   DocAccessible* parentDocAcc = nullptr;
 61317:   if (!isRootDoc) {
 43310:     // XXXaaronl: ideally we would traverse the presshell chain. Since there's
 43310:     // no easy way to do that, we cheat and use the document hierarchy.
 61317:     parentDocAcc = GetDocAccessible(aDocument->GetParentDocument());
 61317:     NS_ASSERTION(parentDocAcc,
 61317:                  "Can't create an accessible for the document!");
 61317:     if (!parentDocAcc)
106838:       return nullptr;
 47105:   }
 47105: 
 43310:   // We only create root accessibles for the true root, otherwise create a
 43310:   // doc accessible.
 99568:   nsRefPtr<DocAccessible> docAcc = isRootDoc ?
 97643:     new RootAccessibleWrap(aDocument, rootElm, presShell) :
 99568:     new DocAccessibleWrap(aDocument, rootElm, presShell);
 43310: 
 57413:   // Cache the document accessible into document cache.
 98908:   mDocAccessibleCache.Put(aDocument, docAcc);
 43310: 
 61317:   // Initialize the document accessible.
107208:   docAcc->Init();
 95490:   docAcc->SetRoleMapEntry(aria::GetRoleMap(aDocument));
 61317: 
 61317:   // Bind the document to the tree.
 61317:   if (isRootDoc) {
107956:     Accessible* appAcc = nsAccessNode::GetApplicationAccessible();
 61317:     if (!appAcc->AppendChild(docAcc)) {
 61317:       docAcc->Shutdown();
106838:       return nullptr;
 43310:     }
 43310: 
 61317:     // Fire reorder event to notify new accessible document has been attached to
 74015:     // the tree. The reorder event is delivered after the document tree is
 74015:     // constructed because event processing and tree construction are done by
 74015:     // the same document.
 61317:     nsRefPtr<AccEvent> reorderEvent =
 61317:       new AccEvent(nsIAccessibleEvent::EVENT_REORDER, appAcc, eAutoDetect,
 61317:                    AccEvent::eCoalesceFromSameSubtree);
 61317:     docAcc->FireDelayedAccessibleEvent(reorderEvent);
 61317: 
 61317:   } else {
 61317:     parentDocAcc->BindChildDocument(docAcc);
 43310:   }
 43310: 
 99203: #ifdef DEBUG
 99203:   if (logging::IsEnabled(logging::eDocCreate)) {
 99203:     logging::DocCreate("document creation finished", aDocument);
 99203:     logging::Stack();
 99203:   }
 99203: #endif
 43310: 
 43310:   AddListeners(aDocument, isRootDoc);
 43310:   return docAcc;
 43310: }
 43310: 
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: // nsAccDocManager static
 43310: 
 43310: PLDHashOperator
 58488: nsAccDocManager::GetFirstEntryInDocCache(const nsIDocument* aKey,
 99568:                                          DocAccessible* aDocAccessible,
 43310:                                          void* aUserArg)
 43310: {
 43310:   NS_ASSERTION(aDocAccessible,
 58488:                "No doc accessible for the object in doc accessible cache!");
 99568:   *reinterpret_cast<DocAccessible**>(aUserArg) = aDocAccessible;
 43310: 
 58488:   return PL_DHASH_STOP;
 58488: }
 43310: 
 58488: void
 58488: nsAccDocManager::ClearDocCache()
 58488: {
106838:   DocAccessible* docAcc = nullptr;
 58488:   while (mDocAccessibleCache.EnumerateRead(GetFirstEntryInDocCache, static_cast<void*>(&docAcc))) {
 58488:     if (docAcc)
 58488:       docAcc->Shutdown();
 58488:   }
 43310: }
 43310: 
 43310: PLDHashOperator
 56292: nsAccDocManager::SearchAccessibleInDocCache(const nsIDocument* aKey,
 99568:                                             DocAccessible* aDocAccessible,
 43310:                                             void* aUserArg)
 43310: {
 43310:   NS_ASSERTION(aDocAccessible,
 43310:                "No doc accessible for the object in doc accessible cache!");
 43310: 
 43310:   if (aDocAccessible) {
 43310:     nsSearchAccessibleInCacheArg* arg =
 43310:       static_cast<nsSearchAccessibleInCacheArg*>(aUserArg);
 61461:     arg->mAccessible = aDocAccessible->GetAccessible(arg->mNode);
 43538:     if (arg->mAccessible)
 43310:       return PL_DHASH_STOP;
 43310:   }
 43310: 
 43310:   return PL_DHASH_NEXT;
 43310: }
 79853: 
 79853: #ifdef DEBUG
 79853: PLDHashOperator
 79853: nsAccDocManager::SearchIfDocIsRefreshing(const nsIDocument* aKey,
 99568:                                          DocAccessible* aDocAccessible,
 79853:                                          void* aUserArg)
 79853: {
 79853:   NS_ASSERTION(aDocAccessible,
 79853:                "No doc accessible for the object in doc accessible cache!");
 79853: 
 79853:   if (aDocAccessible && aDocAccessible->mNotificationController &&
 79853:       aDocAccessible->mNotificationController->IsUpdating()) {
 79853:     *(static_cast<bool*>(aUserArg)) = true;
 79853:     return PL_DHASH_STOP;
 79853:   }
 79853: 
 79853:   return PL_DHASH_NEXT;
 79853: }
 79853: #endif
