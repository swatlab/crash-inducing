    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code. This file was split
    1:  * from xpfe/appshell/src/nsAppShellService.cpp
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   Benjamin Smedberg <bsmedberg@covad.net>
60458:  *   Daniel Brooks <db48x@db48x.net>
60458:  *   Taras Glek <tglek@mozilla.com>
68651:  *   Landry Breuil <landry@openbsd.org>
89494:  *   David Rajchenbach-Teller <dteller@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAppStartup.h"
    1: 
    1: #include "nsIAppShellService.h"
37611: #include "nsPIDOMWindow.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsILocalFile.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIProfileChangeStatus.h"
    1: #include "nsIPromptService.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsIWindowMediator.h"
    1: #include "nsIWindowWatcher.h"
89683: #include "nsIXULRuntime.h"
    1: #include "nsIXULWindow.h"
    1: #include "nsNativeCharsetUtils.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsStringGlue.h"
89683: #include "mozilla/Preferences.h"
    1: 
    1: #include "prprf.h"
    1: #include "nsCRT.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsAppShellCID.h"
89683: #include "nsXPCOMCIDInternal.h"
41540: #include "mozilla/Services.h"
60458: #include "mozilla/FunctionTimer.h"
60458: #include "nsIXPConnect.h"
60458: #include "jsapi.h"
61254: #include "prenv.h"
58881: 
60458: #if defined(XP_WIN)
60458: #include <windows.h>
60458: // windows.h can go to hell 
60458: #undef GetStartupInfo
60458: #elif defined(XP_UNIX)
60458: #include <unistd.h>
60458: #include <sys/syscall.h>
60458: #endif
60458: 
60458: #ifdef XP_MACOSX
60458: #include <sys/sysctl.h>
60458: #endif
42480: 
68651: #ifdef __OpenBSD__
68651: #include <sys/param.h>
68651: #include <sys/sysctl.h>
68651: #endif
68651: 
73876: #include "mozilla/Telemetry.h"
82448: #include "mozilla/StartupTimeline.h"
73876: 
    1: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
73876: 
89683: #define kPrefLastSuccess "toolkit.startup.last_success"
89683: #define kPrefMaxResumedCrashes "toolkit.startup.max_resumed_crashes"
89683: #define kPrefRecentCrashes "toolkit.startup.recent_crashes"
89683: 
89494: #if defined(XP_WIN)
89494: #include "mozilla/perfprobe.h"
89494: /**
89494:  * Events sent to the system for profiling purposes
89494:  */
89494: //Keep them syncronized with the .mof file
89494: 
89494: //Process-wide GUID, used by the OS to differentiate sources
89494: // {509962E0-406B-46F4-99BA-5A009F8D2225}
89494: //Keep it synchronized with the .mof file
89494: #define NS_APPLICATION_TRACING_CID \
89494:   { 0x509962E0, 0x406B, 0x46F4, \
89494:   { 0x99, 0xBA, 0x5A, 0x00, 0x9F, 0x8D, 0x22, 0x25} }
89494: 
89494: //Event-specific GUIDs, used by the OS to differentiate events
89494: // {A3DA04E0-57D7-482A-A1C1-61DA5F95BACB}
89494: #define NS_PLACES_INIT_COMPLETE_EVENT_CID \
89494:   { 0xA3DA04E0, 0x57D7, 0x482A, \
89494:   { 0xA1, 0xC1, 0x61, 0xDA, 0x5F, 0x95, 0xBA, 0xCB} }
89494: // {917B96B1-ECAD-4DAB-A760-8D49027748AE}
89494: #define NS_SESSION_STORE_WINDOW_RESTORED_EVENT_CID \
89494:   { 0x917B96B1, 0xECAD, 0x4DAB, \
89494:   { 0xA7, 0x60, 0x8D, 0x49, 0x02, 0x77, 0x48, 0xAE} }
89494: 
89494: static NS_DEFINE_CID(kApplicationTracingCID,
89494:   NS_APPLICATION_TRACING_CID);
89494: static NS_DEFINE_CID(kPlacesInitCompleteCID,
89494:   NS_PLACES_INIT_COMPLETE_EVENT_CID);
89494: static NS_DEFINE_CID(kSessionStoreWindowRestoredCID,
89494:   NS_SESSION_STORE_WINDOW_RESTORED_EVENT_CID);
89494: #endif //defined(XP_WIN)
89494: 
73876: using namespace mozilla;
    1: 
61862: PRUint32 gRestartMode = 0;
61862: 
    1: class nsAppExitEvent : public nsRunnable {
    1: private:
    1:   nsRefPtr<nsAppStartup> mService;
    1: 
    1: public:
    1:   nsAppExitEvent(nsAppStartup *service) : mService(service) {}
    1: 
    1:   NS_IMETHOD Run() {
    1:     // Tell the appshell to exit
    1:     mService->mAppShell->Exit();
    1: 
    1:     // We're done "shutting down".
80486:     mService->mShuttingDown = false;
80486:     mService->mRunning = false;
    1:     return NS_OK;
    1:   }
    1: };
    1: 
    1: //
    1: // nsAppStartup
    1: //
    1: 
    1: nsAppStartup::nsAppStartup() :
    1:   mConsiderQuitStopper(0),
80486:   mRunning(false),
80486:   mShuttingDown(false),
80486:   mAttemptingQuit(false),
80486:   mRestart(false),
89683:   mInterrupted(false),
89683:   mIsSafeModeNecessary(false),
89683:   mStartupCrashTrackingEnded(false)
    1: { }
    1: 
    1: 
    1: nsresult
    1: nsAppStartup::Init()
    1: {
42480:   NS_TIME_FUNCTION;
    1:   nsresult rv;
    1: 
    1:   // Create widget application shell
    1:   mAppShell = do_GetService(kAppShellCID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
42480:   NS_TIME_FUNCTION_MARK("Got AppShell service");
42480: 
41540:   nsCOMPtr<nsIObserverService> os =
41540:     mozilla::services::GetObserverService();
41540:   if (!os)
41540:     return NS_ERROR_FAILURE;
    1: 
42480:   NS_TIME_FUNCTION_MARK("Got Observer service");
42480: 
80486:   os->AddObserver(this, "quit-application-forced", true);
80486:   os->AddObserver(this, "sessionstore-windows-restored", true);
80486:   os->AddObserver(this, "profile-change-teardown", true);
80486:   os->AddObserver(this, "xul-window-registered", true);
80486:   os->AddObserver(this, "xul-window-destroyed", true);
    1: 
89494: #if defined(XP_WIN)
89494:   os->AddObserver(this, "places-init-complete", true);
89494:   // This last event is only interesting to us for xperf-based measures
89494: 
89494:   // Initialize interaction with profiler
89494:   mProbesManager =
89494:     new ProbeManager(
89494:                      kApplicationTracingCID,
89494:                      NS_LITERAL_CSTRING("Application startup probe"));
89494:   // Note: The operation is meant mostly for in-house profiling.
89494:   // Therefore, we do not warn if probes manager cannot be initialized
89494: 
89494:   if (mProbesManager) {
89494:     mPlacesInitCompleteProbe =
89494:       mProbesManager->
89494:       GetProbe(kPlacesInitCompleteCID,
89494:                NS_LITERAL_CSTRING("places-init-complete"));
89494:     NS_WARN_IF_FALSE(mPlacesInitCompleteProbe,
89494:                      "Cannot initialize probe 'places-init-complete'");
89494: 
89494:     mSessionWindowRestoredProbe =
89494:       mProbesManager->
89494:       GetProbe(kSessionStoreWindowRestoredCID,
89494:                NS_LITERAL_CSTRING("sessionstore-windows-restored"));
89494:     NS_WARN_IF_FALSE(mSessionWindowRestoredProbe,
89494:                      "Cannot initialize probe 'sessionstore-windows-restored'");
89494: 
89494:     rv = mProbesManager->StartSession();
89494:     NS_WARN_IF_FALSE(NS_SUCCEEDED(rv),
89494:                      "Cannot initialize system probe manager");
89494:   }
89494: #endif //defined(XP_WIN)
89494: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //
    1: // nsAppStartup->nsISupports
    1: //
    1: 
63892: NS_IMPL_THREADSAFE_ISUPPORTS5(nsAppStartup,
    1:                               nsIAppStartup,
    1:                               nsIWindowCreator,
    1:                               nsIWindowCreator2,
    1:                               nsIObserver,
    1:                               nsISupportsWeakReference)
    1: 
    1: 
    1: //
    1: // nsAppStartup->nsIAppStartup
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsAppStartup::CreateHiddenWindow()
    1: {
    1:   nsCOMPtr<nsIAppShellService> appShellService
    1:     (do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
    1:   NS_ENSURE_TRUE(appShellService, NS_ERROR_FAILURE);
    1: 
80433:   return appShellService->CreateHiddenWindow();
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
 8897: nsAppStartup::DestroyHiddenWindow()
 8897: {
 8897:   nsCOMPtr<nsIAppShellService> appShellService
 8897:     (do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
 8897:   NS_ENSURE_TRUE(appShellService, NS_ERROR_FAILURE);
 8897: 
 8897:   return appShellService->DestroyHiddenWindow();
 8897: }
 8897: 
 8897: NS_IMETHODIMP
    1: nsAppStartup::Run(void)
    1: {
    1:   NS_ASSERTION(!mRunning, "Reentrant appstartup->Run()");
    1: 
    1:   // If we have no windows open and no explicit calls to
    1:   // enterLastWindowClosingSurvivalArea, or somebody has explicitly called
    1:   // quit, don't bother running the event loop which would probably leave us
    1:   // with a zombie process.
    1: 
    1:   if (!mShuttingDown && mConsiderQuitStopper != 0) {
    1: #ifdef XP_MACOSX
    1:     EnterLastWindowClosingSurvivalArea();
    1: #endif
    1: 
80486:     mRunning = true;
    1: 
    1:     nsresult rv = mAppShell->Run();
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:   }
    1: 
    1:   return mRestart ? NS_SUCCESS_RESTART_APP : NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsAppStartup::Quit(PRUint32 aMode)
    1: {
    1:   PRUint32 ferocity = (aMode & 0xF);
    1: 
    1:   // Quit the application. We will asynchronously call the appshell's
    1:   // Exit() method via nsAppExitEvent to allow one last pass
    1:   // through any events in the queue. This guarantees a tidy cleanup.
    1:   nsresult rv = NS_OK;
79445:   bool postedExitEvent = false;
    1: 
    1:   if (mShuttingDown)
    1:     return NS_OK;
    1: 
 5221:   // If we're considering quitting, we will only do so if:
 5221:   if (ferocity == eConsiderQuit) {
 5221:     if (mConsiderQuitStopper == 0) {
 5221:       // there are no windows...
    1:       ferocity = eAttemptQuit;
    1:     }
 5221: #ifdef XP_MACOSX
 5221:     else if (mConsiderQuitStopper == 1) {
 5221:       // ... or there is only a hiddenWindow left, and it's useless:
 5221:       nsCOMPtr<nsIAppShellService> appShell
 5221:         (do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
 5221: 
 5221:       // Failure shouldn't be fatal, but will abort quit attempt:
 5221:       if (!appShell)
 5221:         return NS_OK;
 5221: 
79445:       bool usefulHiddenWindow;
 5221:       appShell->GetApplicationProvidedHiddenWindow(&usefulHiddenWindow);
 5221:       nsCOMPtr<nsIXULWindow> hiddenWindow;
 5221:       appShell->GetHiddenWindow(getter_AddRefs(hiddenWindow));
 5221:       // If the one window is useful, we won't quit:
 5221:       if (!hiddenWindow || usefulHiddenWindow)
 5221:         return NS_OK;
 5221: 
 5221:       ferocity = eAttemptQuit;
 5221:     }
 5221: #endif
 5221:   }
    1: 
37611:   nsCOMPtr<nsIObserverService> obsService;
37611:   if (ferocity == eAttemptQuit || ferocity == eForceQuit) {
37611: 
37611:     nsCOMPtr<nsISimpleEnumerator> windowEnumerator;
37611:     nsCOMPtr<nsIWindowMediator> mediator (do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
37611:     if (mediator) {
37611:       mediator->GetEnumerator(nsnull, getter_AddRefs(windowEnumerator));
37611:       if (windowEnumerator) {
79445:         bool more;
37611:         while (windowEnumerator->HasMoreElements(&more), more) {
37611:           nsCOMPtr<nsISupports> window;
37611:           windowEnumerator->GetNext(getter_AddRefs(window));
37611:           nsCOMPtr<nsPIDOMWindow> domWindow(do_QueryInterface(window));
37611:           if (domWindow) {
37611:             if (!domWindow->CanClose())
37611:               return NS_OK;
37611:           }
37611:         }
37611:       }
37611:     }
37611: 
80486:     mShuttingDown = true;
61862:     if (!mRestart) {
 5655:       mRestart = (aMode & eRestart) != 0;
61862:       gRestartMode = (aMode & 0xF0);
61862:     }
 5457: 
61254:     if (mRestart) {
61254:       // Firefox-restarts reuse the process. Process start-time isn't a useful indicator of startup time
62249:       PR_SetEnv(PR_smprintf("MOZ_APP_RESTART=%lld", (PRInt64) PR_Now() / PR_USEC_PER_MSEC));
61254:     }
61254: 
41540:     obsService = mozilla::services::GetObserverService();
31759: 
31759:     if (!mAttemptingQuit) {
80486:       mAttemptingQuit = true;
31759: #ifdef XP_MACOSX
31759:       // now even the Mac wants to quit when the last window is closed
31759:       ExitLastWindowClosingSurvivalArea();
31759: #endif
 8682:       if (obsService)
 8682:         obsService->NotifyObservers(nsnull, "quit-application-granted", nsnull);
31759:     }
    1: 
    1:     /* Enumerate through each open window and close it. It's important to do
    1:        this before we forcequit because this can control whether we really quit
    1:        at all. e.g. if one of these windows has an unload handler that
    1:        opens a new window. Ugh. I know. */
 3519:     CloseAllWindows();
 3519: 
    1:     if (mediator) {
 3519:       if (ferocity == eAttemptQuit) {
    1:         ferocity = eForceQuit; // assume success
    1: 
    1:         /* Were we able to immediately close all windows? if not, eAttemptQuit
    1:            failed. This could happen for a variety of reasons; in fact it's
    1:            very likely. Perhaps we're being called from JS and the window->Close
    1:            method hasn't had a chance to wrap itself up yet. So give up.
    1:            We'll return (with eConsiderQuit) as the remaining windows are
    1:            closed. */
    1:         mediator->GetEnumerator(nsnull, getter_AddRefs(windowEnumerator));
    1:         if (windowEnumerator) {
79445:           bool more;
    1:           while (windowEnumerator->HasMoreElements(&more), more) {
    1:             /* we can't quit immediately. we'll try again as the last window
    1:                finally closes. */
    1:             ferocity = eAttemptQuit;
    1:             nsCOMPtr<nsISupports> window;
    1:             windowEnumerator->GetNext(getter_AddRefs(window));
73870:             nsCOMPtr<nsIDOMWindow> domWindow = do_QueryInterface(window);
    1:             if (domWindow) {
79445:               bool closed = false;
    1:               domWindow->GetClosed(&closed);
    1:               if (!closed) {
    1:                 rv = NS_ERROR_FAILURE;
    1:                 break;
    1:               }
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (ferocity == eForceQuit) {
    1:     // do it!
    1: 
    1:     // No chance of the shutdown being cancelled from here on; tell people
    1:     // we're shutting down for sure while all services are still available.
    1:     if (obsService) {
    1:       NS_NAMED_LITERAL_STRING(shutdownStr, "shutdown");
    1:       NS_NAMED_LITERAL_STRING(restartStr, "restart");
    1:       obsService->NotifyObservers(nsnull, "quit-application",
    1:         mRestart ? restartStr.get() : shutdownStr.get());
    1:     }
    1: 
    1:     if (!mRunning) {
80486:       postedExitEvent = true;
    1:     }
    1:     else {
    1:       // no matter what, make sure we send the exit event.  If
    1:       // worst comes to worst, we'll do a leaky shutdown but we WILL
    1:       // shut down. Well, assuming that all *this* stuff works ;-).
    1:       nsCOMPtr<nsIRunnable> event = new nsAppExitEvent(this);
    1:       rv = NS_DispatchToCurrentThread(event);
    1:       if (NS_SUCCEEDED(rv)) {
80486:         postedExitEvent = true;
    1:       }
    1:       else {
    1:         NS_WARNING("failed to dispatch nsAppExitEvent");
    1:       }
    1:     }
    1:   }
    1: 
    1:   // turn off the reentrancy check flag, but not if we have
    1:   // more asynchronous work to do still.
    1:   if (!postedExitEvent)
80486:     mShuttingDown = false;
    1:   return rv;
    1: }
    1: 
    1: 
 3519: void
 3519: nsAppStartup::CloseAllWindows()
 3519: {
 3519:   nsCOMPtr<nsIWindowMediator> mediator
 3519:     (do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
 3519: 
 3519:   nsCOMPtr<nsISimpleEnumerator> windowEnumerator;
 3519: 
 3519:   mediator->GetEnumerator(nsnull, getter_AddRefs(windowEnumerator));
 3519: 
 3519:   if (!windowEnumerator)
 3519:     return;
 3519: 
79445:   bool more;
 3519:   while (NS_SUCCEEDED(windowEnumerator->HasMoreElements(&more)) && more) {
 3519:     nsCOMPtr<nsISupports> isupports;
 3519:     if (NS_FAILED(windowEnumerator->GetNext(getter_AddRefs(isupports))))
 3519:       break;
 3519: 
37611:     nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(isupports);
37611:     NS_ASSERTION(window, "not an nsPIDOMWindow");
31759:     if (window)
37611:       window->ForceClose();
 3519:   }
 3519: }
 3519: 
    1: NS_IMETHODIMP
    1: nsAppStartup::EnterLastWindowClosingSurvivalArea(void)
    1: {
    1:   ++mConsiderQuitStopper;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsAppStartup::ExitLastWindowClosingSurvivalArea(void)
    1: {
    1:   NS_ASSERTION(mConsiderQuitStopper > 0, "consider quit stopper out of bounds");
    1:   --mConsiderQuitStopper;
    1: 
31759:   if (mRunning)
 5221:     Quit(eConsiderQuit);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //
27580: // nsAppStartup->nsIAppStartup2
27580: //
27580: 
27580: NS_IMETHODIMP
79445: nsAppStartup::GetShuttingDown(bool *aResult)
27580: {
27580:   *aResult = mShuttingDown;
27580:   return NS_OK;
27580: }
27580: 
78260: NS_IMETHODIMP
79445: nsAppStartup::SetInterrupted(bool aInterrupted)
78260: {
78260:   mInterrupted = aInterrupted;
78260:   return NS_OK;
78260: }
78260: 
78260: NS_IMETHODIMP
79445: nsAppStartup::GetInterrupted(bool *aInterrupted)
78260: {
78260:   *aInterrupted = mInterrupted;
78260:   return NS_OK;
78260: }
78260: 
27580: //
    1: // nsAppStartup->nsIWindowCreator
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsAppStartup::CreateChromeWindow(nsIWebBrowserChrome *aParent,
    1:                                  PRUint32 aChromeFlags,
    1:                                  nsIWebBrowserChrome **_retval)
    1: {
79445:   bool cancel;
    1:   return CreateChromeWindow2(aParent, aChromeFlags, 0, 0, &cancel, _retval);
    1: }
    1: 
    1: 
    1: //
    1: // nsAppStartup->nsIWindowCreator2
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsAppStartup::CreateChromeWindow2(nsIWebBrowserChrome *aParent,
    1:                                   PRUint32 aChromeFlags,
    1:                                   PRUint32 aContextFlags,
    1:                                   nsIURI *aURI,
79445:                                   bool *aCancel,
    1:                                   nsIWebBrowserChrome **_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aCancel);
    1:   NS_ENSURE_ARG_POINTER(_retval);
80486:   *aCancel = false;
    1:   *_retval = 0;
    1: 
31759:   // Non-modal windows cannot be opened if we are attempting to quit
31759:   if (mAttemptingQuit && (aChromeFlags & nsIWebBrowserChrome::CHROME_MODAL) == 0)
31759:     return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
31759: 
    1:   nsCOMPtr<nsIXULWindow> newWindow;
    1: 
    1:   if (aParent) {
    1:     nsCOMPtr<nsIXULWindow> xulParent(do_GetInterface(aParent));
    1:     NS_ASSERTION(xulParent, "window created using non-XUL parent. that's unexpected, but may work.");
    1: 
    1:     if (xulParent)
80433:       xulParent->CreateNewWindow(aChromeFlags, getter_AddRefs(newWindow));
    1:     // And if it fails, don't try again without a parent. It could fail
    1:     // intentionally (bug 115969).
    1:   } else { // try using basic methods:
    1:     /* You really shouldn't be making dependent windows without a parent.
    1:       But unparented modal (and therefore dependent) windows happen
    1:       in our codebase, so we allow it after some bellyaching: */
    1:     if (aChromeFlags & nsIWebBrowserChrome::CHROME_DEPENDENT)
    1:       NS_WARNING("dependent window created without a parent");
    1: 
    1:     nsCOMPtr<nsIAppShellService> appShell(do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
    1:     if (!appShell)
    1:       return NS_ERROR_FAILURE;
    1:     
    1:     appShell->CreateTopLevelWindow(0, 0, aChromeFlags,
    1:                                    nsIAppShellService::SIZE_TO_CONTENT,
    1:                                    nsIAppShellService::SIZE_TO_CONTENT,
80433:                                    getter_AddRefs(newWindow));
    1:   }
    1: 
    1:   // if anybody gave us anything to work with, use it
    1:   if (newWindow) {
    1:     newWindow->SetContextFlags(aContextFlags);
    1:     nsCOMPtr<nsIInterfaceRequestor> thing(do_QueryInterface(newWindow));
    1:     if (thing)
    1:       CallGetInterface(thing.get(), _retval);
    1:   }
    1: 
    1:   return *_retval ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: 
    1: //
    1: // nsAppStartup->nsIObserver
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsAppStartup::Observe(nsISupports *aSubject,
    1:                       const char *aTopic, const PRUnichar *aData)
    1: {
    1:   NS_ASSERTION(mAppShell, "appshell service notified before appshell built");
18536:   if (!strcmp(aTopic, "quit-application-forced")) {
80486:     mShuttingDown = true;
18536:   }
18536:   else if (!strcmp(aTopic, "profile-change-teardown")) {
18536:     if (!mShuttingDown) {
    1:       EnterLastWindowClosingSurvivalArea();
 3519:       CloseAllWindows();
    1:       ExitLastWindowClosingSurvivalArea();
18536:     }
    1:   } else if (!strcmp(aTopic, "xul-window-registered")) {
    1:     EnterLastWindowClosingSurvivalArea();
    1:   } else if (!strcmp(aTopic, "xul-window-destroyed")) {
    1:     ExitLastWindowClosingSurvivalArea();
60458:   } else if (!strcmp(aTopic, "sessionstore-windows-restored")) {
82448:     StartupTimeline::Record(StartupTimeline::SESSION_RESTORED);
89494: #if defined(XP_WIN)
89494:     if (mSessionWindowRestoredProbe) {
89494:       mSessionWindowRestoredProbe->Trigger();
89494:     }
89494:   } else if (!strcmp(aTopic, "places-init-complete")) {
89494:     if (mPlacesInitCompleteProbe) {
89494:       mPlacesInitCompleteProbe->Trigger();
89494:     }
89494: #endif //defined(XP_WIN)
    1:   } else {
    1:     NS_ERROR("Unexpected observer topic.");
    1:   }
    1: 
    1:   return NS_OK;
    1: }
60458: 
60458: #if defined(LINUX) || defined(ANDROID)
60458: static PRUint64 
60458: JiffiesSinceBoot(const char *file)
60458: {
60458:   char stat[512];
60458:   FILE *f = fopen(file, "r");
60458:   if (!f)
60458:     return 0;
60458:   int n = fread(&stat, 1, sizeof(stat) - 1, f);
60458:   fclose(f);
60458:   if (n <= 0)
60458:     return 0;
60458:   stat[n] = 0;
60458:   
60458:   long long unsigned starttime = 0; // instead of PRUint64 to keep GCC quiet
60458:   
60458:   char *s = strrchr(stat, ')');
60458:   if (!s)
60458:     return 0;
73876:   int ret = sscanf(s + 2,
60458:                    "%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u "
60458:                    "%*u %*u %*u %*u %*u %*d %*d %*d %*d %llu",
60458:                    &starttime);
73876:   if (ret != 1 || !starttime)
60458:     return 0;
60458:   return starttime;
60458: }
60458: 
60458: static void
60458: ThreadedCalculateProcessCreationTimestamp(void *aClosure)
60458: {
60458:   PRTime now = PR_Now();
60458:   long hz = sysconf(_SC_CLK_TCK);
60458:   if (!hz)
60458:     return;
60458: 
60458:   char thread_stat[40];
60458:   sprintf(thread_stat, "/proc/self/task/%d/stat", (pid_t) syscall(__NR_gettid));
60458:   
73876:   PRUint64 thread_jiffies = JiffiesSinceBoot(thread_stat);
73876:   PRUint64 self_jiffies = JiffiesSinceBoot("/proc/self/stat");
73876:   
73876:   if (!thread_jiffies || !self_jiffies)
73876:     return;
73876: 
73876:   PRTime interval = (thread_jiffies - self_jiffies) * PR_USEC_PER_SEC / hz;
82448:   StartupTimeline::Record(StartupTimeline::PROCESS_CREATION, now - interval);
60458: }
60458: 
60458: static PRTime
60458: CalculateProcessCreationTimestamp()
60458: {
60458:  PRThread *thread = PR_CreateThread(PR_USER_THREAD,
60458:                                     ThreadedCalculateProcessCreationTimestamp,
60458:                                     NULL,
60458:                                     PR_PRIORITY_NORMAL,
60458:                                     PR_LOCAL_THREAD,
60458:                                     PR_JOINABLE_THREAD,
60458:                                     0);
60458: 
60458:   PR_JoinThread(thread);
82448:   return StartupTimeline::Get(StartupTimeline::PROCESS_CREATION);
60458: }
60458: #elif defined(XP_WIN)
60458: static PRTime
60458: CalculateProcessCreationTimestamp()
60458: {
60458:   FILETIME start, foo, bar, baz;
60458:   bool success = GetProcessTimes(GetCurrentProcess(), &start, &foo, &bar, &baz);
60458:   if (!success)
60458:     return 0;
60458:   // copied from NSPR _PR_FileTimeToPRTime
60458:   PRUint64 timestamp = 0;
60458:   CopyMemory(&timestamp, &start, sizeof(PRTime));
60458: #ifdef __GNUC__
60458:   timestamp = (timestamp - 116444736000000000LL) / 10LL;
60458: #else
60458:   timestamp = (timestamp - 116444736000000000i64) / 10i64;
60458: #endif
60458:   return timestamp;
60458: }
60458: #elif defined(XP_MACOSX)
60458: static PRTime
60458: CalculateProcessCreationTimestamp()
60458: {
60458:   int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid() };
60458:   size_t buffer_size;
60458:   if (sysctl(mib, 4, NULL, &buffer_size, NULL, 0))
60458:     return 0;
60458: 
60458:   struct kinfo_proc *proc = (kinfo_proc*) malloc(buffer_size);  
60458:   if (sysctl(mib, 4, proc, &buffer_size, NULL, 0)) {
60458:     free(proc);
60458:     return 0;
60458:   }
60460:   PRTime starttime = static_cast<PRTime>(proc->kp_proc.p_un.__p_starttime.tv_sec) * PR_USEC_PER_SEC;
60458:   starttime += proc->kp_proc.p_un.__p_starttime.tv_usec;
60458:   free(proc);
60458:   return starttime;
60458: }
68651: #elif defined(__OpenBSD__)
68651: static PRTime
68651: CalculateProcessCreationTimestamp()
68651: {
68651:   int mib[6] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid(), sizeof(struct kinfo_proc), 1 };
68651:   size_t buffer_size;
68651:   if (sysctl(mib, 6, NULL, &buffer_size, NULL, 0))
68651:     return 0;
68651: 
68651:   struct kinfo_proc *proc = (struct kinfo_proc*) malloc(buffer_size);
68651:   if (sysctl(mib, 6, proc, &buffer_size, NULL, 0)) {
68651:     free(proc);
68651:     return 0;
68651:   }
68651:   PRTime starttime = static_cast<PRTime>(proc->p_ustart_sec) * PR_USEC_PER_SEC;
68651:   starttime += proc->p_ustart_usec;
68651:   free(proc);
68651:   return starttime;
68651: }
60458: #else
60458: static PRTime
60458: CalculateProcessCreationTimestamp()
60458: {
60458:   return 0;
60458: }
60458: #endif
60458:  
60458: NS_IMETHODIMP
82815: nsAppStartup::GetStartupInfo(JSContext* aCx, JS::Value* aRetval)
60458: {
82815:   JSObject *obj = JS_NewObject(aCx, NULL, NULL, NULL);
82815:   *aRetval = OBJECT_TO_JSVAL(obj);
60458: 
82448:   PRTime ProcessCreationTimestamp = StartupTimeline::Get(StartupTimeline::PROCESS_CREATION);
82448: 
82448:   if (!ProcessCreationTimestamp) {
61254:     char *moz_app_restart = PR_GetEnv("MOZ_APP_RESTART");
61254:     if (moz_app_restart) {
82448:       ProcessCreationTimestamp = nsCRT::atoll(moz_app_restart) * PR_USEC_PER_MSEC;
82448:     } else {
82448:       ProcessCreationTimestamp = CalculateProcessCreationTimestamp();
61254:     }
73876:     // Bug 670008: Avoid obviously invalid process creation times
82448:     if (PR_Now() <= ProcessCreationTimestamp) {
82448:       ProcessCreationTimestamp = -1;
82448:       Telemetry::Accumulate(Telemetry::STARTUP_MEASUREMENT_ERRORS, StartupTimeline::PROCESS_CREATION);
82448:     }
82448:     StartupTimeline::Record(StartupTimeline::PROCESS_CREATION, ProcessCreationTimestamp);
73876:   }
60458: 
82448:   for (int i = StartupTimeline::PROCESS_CREATION; i < StartupTimeline::MAX_EVENT_ID; ++i) {
82448:     StartupTimeline::Event ev = static_cast<StartupTimeline::Event>(i);
82448:     if (StartupTimeline::Get(ev) > 0) {
80138:       // always define main to aid with bug 689256
82448:       if ((ev != StartupTimeline::MAIN) &&
82448:           (StartupTimeline::Get(ev) < StartupTimeline::Get(StartupTimeline::PROCESS_CREATION))) {
82448:         Telemetry::Accumulate(Telemetry::STARTUP_MEASUREMENT_ERRORS, i);
82448:         StartupTimeline::Record(ev, -1);
82448:       } else {
82815:         JSObject *date = JS_NewDateObjectMsec(aCx, StartupTimeline::Get(ev) / PR_USEC_PER_MSEC);
82815:         JS_DefineProperty(aCx, obj, StartupTimeline::Describe(ev), OBJECT_TO_JSVAL(date), NULL, NULL, JSPROP_ENUMERATE);
82448:       }
82448:     }
82448:   }
73876: 
60458:   return NS_OK;
60458: }
89683: 
89683: NS_IMETHODIMP
89683: nsAppStartup::GetAutomaticSafeModeNecessary(bool *_retval)
89683: {
90120:   NS_ENSURE_ARG_POINTER(_retval);
90120: 
89683:   *_retval = mIsSafeModeNecessary;
89683:   return NS_OK;
89683: }
89683: 
89683: NS_IMETHODIMP
89683: nsAppStartup::TrackStartupCrashBegin(bool *aIsSafeModeNecessary)
89683: {
89683:   const PRInt32 MAX_TIME_SINCE_STARTUP = 6 * 60 * 60 * 1000;
89683:   const PRInt32 MAX_STARTUP_BUFFER = 10;
89683:   nsresult rv;
89683: 
89683:   mStartupCrashTrackingEnded = false;
89683: 
89683:   bool hasLastSuccess = Preferences::HasUserValue(kPrefLastSuccess);
89683:   if (!hasLastSuccess) {
89683:     // Clear so we don't get stuck with SafeModeNecessary returning true if we
89683:     // have had too many recent crashes and the last success pref is missing.
89683:     Preferences::ClearUser(kPrefRecentCrashes);
89683:     return NS_ERROR_NOT_AVAILABLE;
89683:   }
89683: 
89683:   bool inSafeMode = false;
89683:   nsCOMPtr<nsIXULRuntime> xr = do_GetService(XULRUNTIME_SERVICE_CONTRACTID);
89683:   NS_ENSURE_TRUE(xr, NS_ERROR_FAILURE);
89683: 
89683:   xr->GetInSafeMode(&inSafeMode);
89683: 
89683:   PRInt64 replacedLockTime;
89683:   rv = xr->GetReplacedLockTime(&replacedLockTime);
89683: 
89683:   if (NS_FAILED(rv) || !replacedLockTime) {
89683:     if (!inSafeMode)
89683:       Preferences::ClearUser(kPrefRecentCrashes);
89683:     GetAutomaticSafeModeNecessary(aIsSafeModeNecessary);
89683:     return NS_OK;
89683:   }
89683: 
89683:   // check whether safe mode is necessary
89683:   PRInt32 maxResumedCrashes = -1;
89683:   rv = Preferences::GetInt(kPrefMaxResumedCrashes, &maxResumedCrashes);
89683:   NS_ENSURE_SUCCESS(rv, NS_OK);
89683: 
89683:   PRInt32 recentCrashes = 0;
89683:   Preferences::GetInt(kPrefRecentCrashes, &recentCrashes);
89683:   mIsSafeModeNecessary = (recentCrashes > maxResumedCrashes && maxResumedCrashes != -1);
89683: 
89683:   // time of last successful startup
89683:   PRInt32 lastSuccessfulStartup;
89683:   rv = Preferences::GetInt(kPrefLastSuccess, &lastSuccessfulStartup);
89683:   NS_ENSURE_SUCCESS(rv, rv);
89683: 
89683:   PRInt32 lockSeconds = (PRInt32)(replacedLockTime / PR_MSEC_PER_SEC);
89683: 
89683:   // started close enough to good startup so call it good
89683:   if (lockSeconds <= lastSuccessfulStartup + MAX_STARTUP_BUFFER
89683:       && lockSeconds >= lastSuccessfulStartup - MAX_STARTUP_BUFFER) {
89683:     GetAutomaticSafeModeNecessary(aIsSafeModeNecessary);
89683:     return NS_OK;
89683:   }
89683: 
89683:   // sanity check that the pref set at last success is not greater than the current time
89683:   if (PR_Now() / PR_USEC_PER_SEC <= lastSuccessfulStartup)
89683:     return NS_ERROR_FAILURE;
89683: 
89683:   if (inSafeMode) {
89683:     GetAutomaticSafeModeNecessary(aIsSafeModeNecessary);
89683:     return NS_OK;
89683:   }
89683: 
89683:   PRTime now = (PR_Now() / PR_USEC_PER_MSEC);
89683:   // if the last startup attempt which crashed was in the last 6 hours
89683:   if (replacedLockTime >= now - MAX_TIME_SINCE_STARTUP) {
89683:     NS_WARNING("Last startup was detected as a crash.");
89683:     recentCrashes++;
89683:     rv = Preferences::SetInt(kPrefRecentCrashes, recentCrashes);
89683:   } else {
89683:     // Otherwise ignore that crash and all previous since it may not be applicable anymore
89683:     // and we don't want someone to get stuck in safe mode if their prefs are read-only.
89683:     rv = Preferences::ClearUser(kPrefRecentCrashes);
89683:   }
89683:   NS_ENSURE_SUCCESS(rv, rv);
89683: 
89683:   // recalculate since recent crashes count may have changed above
89683:   mIsSafeModeNecessary = (recentCrashes > maxResumedCrashes && maxResumedCrashes != -1);
89683: 
89683:   nsCOMPtr<nsIPrefService> prefs = Preferences::GetService();
89683:   rv = prefs->SavePrefFile(nsnull); // flush prefs to disk since we are tracking crashes
89683:   NS_ENSURE_SUCCESS(rv, rv);
89683: 
89683:   GetAutomaticSafeModeNecessary(aIsSafeModeNecessary);
89683:   return rv;
89683: }
89683: 
89683: NS_IMETHODIMP
89683: nsAppStartup::TrackStartupCrashEnd()
89683: {
89683:   bool inSafeMode = false;
89683:   nsCOMPtr<nsIXULRuntime> xr = do_GetService(XULRUNTIME_SERVICE_CONTRACTID);
89683:   if (xr)
89683:     xr->GetInSafeMode(&inSafeMode);
89683: 
89683:   // return if we already ended or we're restarting into safe mode
89683:   if (mStartupCrashTrackingEnded || (mIsSafeModeNecessary && !inSafeMode))
89683:     return NS_OK;
89683:   mStartupCrashTrackingEnded = true;
89683: 
89683:   // Use the timestamp of XRE_main as an approximation for the lock file timestamp.
89683:   // See MAX_STARTUP_BUFFER for the buffer time period.
89683:   nsresult rv;
89683:   PRTime mainTime = StartupTimeline::Get(StartupTimeline::MAIN);
89683:   if (mainTime <= 0) {
89683:     NS_WARNING("Could not get StartupTimeline::MAIN time.");
89683:   } else {
89683:     PRInt32 lockFileTime = (PRInt32)(mainTime / PR_USEC_PER_SEC);
89683:     rv = Preferences::SetInt(kPrefLastSuccess, lockFileTime);
89683:     if (NS_FAILED(rv)) NS_WARNING("Could not set startup crash detection pref.");
89683:   }
89683: 
89683:   if (inSafeMode && mIsSafeModeNecessary) {
89683:     // On a successful startup in automatic safe mode, allow the user one more crash
89683:     // in regular mode before returning to safe mode.
89683:     PRInt32 maxResumedCrashes = 0;
89683:     PRInt32 prefType;
89683:     rv = Preferences::GetDefaultRootBranch()->GetPrefType(kPrefMaxResumedCrashes, &prefType);
89683:     NS_ENSURE_SUCCESS(rv, rv);
89683:     if (prefType == nsIPrefBranch::PREF_INT) {
89683:       rv = Preferences::GetInt(kPrefMaxResumedCrashes, &maxResumedCrashes);
89683:       NS_ENSURE_SUCCESS(rv, rv);
89683:     }
89683:     rv = Preferences::SetInt(kPrefRecentCrashes, maxResumedCrashes);
89683:     NS_ENSURE_SUCCESS(rv, rv);
89683:   } else if (!inSafeMode) {
89683:     // clear the count of recent crashes after a succesful startup when not in safe mode
89683:     rv = Preferences::ClearUser(kPrefRecentCrashes);
89683:     if (NS_FAILED(rv)) NS_WARNING("Could not clear startup crash count.");
89683:   }
89683:   nsCOMPtr<nsIPrefService> prefs = Preferences::GetService();
89683:   rv = prefs->SavePrefFile(nsnull); // flush prefs to disk since we are tracking crashes
89683: 
89683:   return rv;
89683: }
89683: 
89683: NS_IMETHODIMP
89683: nsAppStartup::RestartInSafeMode(PRUint32 aQuitMode)
89683: {
89683:   PR_SetEnv("MOZ_SAFE_MODE_RESTART=1");
89683:   this->Quit(aQuitMode | nsIAppStartup::eRestart);
89683: 
89683:   return NS_OK;
89683: }
