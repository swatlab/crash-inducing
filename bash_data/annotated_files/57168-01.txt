    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
57168:  *   Geoff Lankow <geoff@darktrojan.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
47648: 
    1: #include "nsIDOMHTMLInputElement.h"
    1: #include "nsITextControlElement.h"
    1: #include "nsIDOMNSEditableElement.h"
    1: #include "nsIRadioVisitor.h"
    1: #include "nsIPhonetic.h"
    1: 
    1: #include "nsIControllers.h"
29018: #include "nsFocusManager.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsContentCID.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIDOMHTMLFormElement.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsPresContext.h"
    1: #include "nsMappedAttributes.h"
    1: #include "nsIFormControl.h"
    1: #include "nsIForm.h"
42818: #include "nsFormSubmission.h"
51137: #include "nsFormSubmissionConstants.h"
    1: #include "nsIDocument.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIFormControlFrame.h"
20884: #include "nsITextControlFrame.h"
    1: #include "nsIFrame.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsDOMError.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIEditor.h"
    1: #include "nsGUIEvent.h"
50909: #include "nsIIOService.h"
    1: 
    1: #include "nsPresState.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIDOMNSEvent.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMHTMLCollection.h"
    1: #include "nsLinebreakConverter.h" //to strip out carriage returns
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsLayoutUtils.h"
29018: #include "nsWidgetsCID.h"
29018: #include "nsILookAndFeel.h"
    1: 
    1: #include "nsIDOMMutationEvent.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsMutationEvent.h"
    1: #include "nsIEventListenerManager.h"
    1: 
    1: #include "nsRuleData.h"
    1: 
    1: // input type=radio
    1: #include "nsIRadioGroupContainer.h"
    1: 
    1: // input type=file
    1: #include "nsIFile.h"
    1: #include "nsILocalFile.h"
    1: #include "nsNetUtil.h"
 3940: #include "nsDOMFile.h"
51580: #include "nsIFilePicker.h"
51580: #include "nsDirectoryServiceDefs.h"
51580: #include "nsIPrivateBrowsingService.h"
51580: #include "nsIContentURIGrouper.h"
51580: #include "nsIContentPrefService.h"
51580: #include "nsIObserverService.h"
51580: #include "nsIPopupWindowManager.h"
51581: #include "nsGlobalWindow.h"
    1: 
    1: // input type=image
    1: #include "nsImageLoadingContent.h"
    1: #include "nsIDOMWindowInternal.h"
    1: 
14228: #include "mozAutoDocUpdate.h"
34395: #include "nsHTMLFormElement.h"
43829: #include "nsContentCreatorFunctions.h"
50907: #include "nsCharSeparatedTokenizer.h"
50911: #include "nsContentUtils.h"
14228: 
40694: #include "nsTextEditRules.h"
40694: 
50911: // JS headers are needed for the pattern attribute.
53858: #include "jsapi.h"
50911: #include "jscntxt.h"
50911: 
47648: #include "nsHTMLInputElement.h"
43129: 
56805: using namespace mozilla::dom;
56805: 
    1: // XXX align=left, hspace, vspace, border? other nav4 attrs
    1: 
    1: static NS_DEFINE_CID(kXULControllersCID,  NS_XULCONTROLLERS_CID);
29018: static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
29018: 
    1: // First bits are needed for the control type.
    1: #define NS_OUTER_ACTIVATE_EVENT   (1 << 9)
    1: #define NS_ORIGINAL_CHECKED_VALUE (1 << 10)
    1: #define NS_NO_CONTENT_DISPATCH    (1 << 11)
24022: #define NS_ORIGINAL_INDETERMINATE_VALUE (1 << 12)
    1: #define NS_CONTROL_TYPE(bits)  ((bits) & ~( \
24022:   NS_OUTER_ACTIVATE_EVENT | NS_ORIGINAL_CHECKED_VALUE | NS_NO_CONTENT_DISPATCH | \
24022:   NS_ORIGINAL_INDETERMINATE_VALUE))
    1: 
29018: // whether textfields should be selected once focused:
29018: //  -1: no, 1: yes, 0: uninitialized
29018: static PRInt32 gSelectTextFieldOnFocus;
51580: UploadLastDir* nsHTMLInputElement::gUploadLastDir;
29018: 
41437: static const nsAttrValue::EnumTable kInputTypeTable[] = {
41437:   { "button", NS_FORM_INPUT_BUTTON },
41437:   { "checkbox", NS_FORM_INPUT_CHECKBOX },
50907:   { "email", NS_FORM_INPUT_EMAIL },
41437:   { "file", NS_FORM_INPUT_FILE },
41437:   { "hidden", NS_FORM_INPUT_HIDDEN },
41437:   { "reset", NS_FORM_INPUT_RESET },
41437:   { "image", NS_FORM_INPUT_IMAGE },
41437:   { "password", NS_FORM_INPUT_PASSWORD },
41437:   { "radio", NS_FORM_INPUT_RADIO },
42372:   { "search", NS_FORM_INPUT_SEARCH },
41437:   { "submit", NS_FORM_INPUT_SUBMIT },
42192:   { "tel", NS_FORM_INPUT_TEL },
41437:   { "text", NS_FORM_INPUT_TEXT },
50909:   { "url", NS_FORM_INPUT_URL },
41437:   { 0 }
41437: };
41437: 
41437: // Default type is 'text'.
50907: static const nsAttrValue::EnumTable* kInputDefaultType = &kInputTypeTable[12];
41437: 
53804: static const PRUint8 NS_INPUT_AUTOCOMPLETE_OFF     = 0;
53804: static const PRUint8 NS_INPUT_AUTOCOMPLETE_ON      = 1;
53804: static const PRUint8 NS_INPUT_AUTOCOMPLETE_DEFAULT = 2;
53804: 
53804: static const nsAttrValue::EnumTable kInputAutocompleteTable[] = {
53804:   { "", NS_INPUT_AUTOCOMPLETE_DEFAULT },
53804:   { "on", NS_INPUT_AUTOCOMPLETE_ON },
53804:   { "off", NS_INPUT_AUTOCOMPLETE_OFF },
53804:   { 0 }
53804: };
53804: 
53804: // Default autocomplete value is "".
53804: static const nsAttrValue::EnumTable* kInputDefaultAutocomplete = &kInputAutocompleteTable[0];
53804: 
22740: #define NS_INPUT_ELEMENT_STATE_IID                 \
22740: { /* dc3b3d14-23e2-4479-b513-7b369343e3a0 */       \
22740:   0xdc3b3d14,                                      \
22740:   0x23e2,                                          \
22740:   0x4479,                                          \
22740:   {0xb5, 0x13, 0x7b, 0x36, 0x93, 0x43, 0xe3, 0xa0} \
22740: }
22740: 
22740: class nsHTMLInputElementState : public nsISupports
22740: {
22740:   public:
22740:     NS_DECLARE_STATIC_IID_ACCESSOR(NS_INPUT_ELEMENT_STATE_IID)
22740:     NS_DECL_ISUPPORTS
22740: 
22740:     PRBool IsCheckedSet() {
22740:       return mCheckedSet;
22740:     }
22740: 
22740:     PRBool GetChecked() {
22740:       return mChecked;
22740:     }
22740: 
22740:     void SetChecked(PRBool aChecked) {
22740:       mChecked = aChecked;
22740:       mCheckedSet = PR_TRUE;
22740:     }
22740: 
22740:     const nsString& GetValue() {
22740:       return mValue;
22740:     }
22740: 
22740:     void SetValue(const nsAString &aValue) {
22740:       mValue = aValue;
22740:     }
22740: 
52042:     const nsCOMArray<nsIDOMFile>& GetFiles() {
52042:       return mFiles;
52042:     }
52042: 
52042:     void SetFiles(const nsCOMArray<nsIDOMFile> &aFiles) {
52042:       mFiles.Clear();
52042:       mFiles.AppendObjects(aFiles);
22740:     }
22740: 
22740:     nsHTMLInputElementState()
22740:       : mValue()
22740:       , mChecked(PR_FALSE)
22740:       , mCheckedSet(PR_FALSE)
22740:     {};
22740:  
22740:   protected:
22740:     nsString mValue;
52042:     nsCOMArray<nsIDOMFile> mFiles;
22740:     PRPackedBool mChecked;
22740:     PRPackedBool mCheckedSet;
22740: };
22740: 
22740: NS_IMPL_ISUPPORTS1(nsHTMLInputElementState, nsHTMLInputElementState)
22740: NS_DEFINE_STATIC_IID_ACCESSOR(nsHTMLInputElementState, NS_INPUT_ELEMENT_STATE_IID)
22740: 
51580: class AsyncClickHandler : public nsRunnable {
51580: public:
51580:   AsyncClickHandler(nsHTMLInputElement* aInput)
51580:    : mInput(aInput) {
51580:     
51580:     nsIDocument* doc = aInput->GetOwnerDoc();
51580:     if (doc) {
51580:       nsPIDOMWindow* win = doc->GetWindow();
51580:       if (win)
51580:         mPopupControlState = win->GetPopupControlState();
51580:     }
51580:   };
51580: 
51580:   NS_IMETHOD Run();
51580: 
51580: protected:
51580:   nsRefPtr<nsHTMLInputElement> mInput;
51580:   PopupControlState mPopupControlState;
51580: };
51580: 
51580: NS_IMETHODIMP
51580: AsyncClickHandler::Run()
51580: {
51580:   nsresult rv;
51580: 
51580:   // Get parent nsIDOMWindowInternal object.
51580:   nsCOMPtr<nsIDocument> doc = mInput->GetOwnerDoc();
51580:   if (!doc)
51580:     return NS_ERROR_FAILURE;
51580: 
51580:   nsPIDOMWindow* win = doc->GetWindow();
51580:   if (!win) {
51580:     return NS_ERROR_FAILURE;
51580:   }
51580: 
51580:   // Check if page is allowed to open the popup
51580:   if (mPopupControlState != openAllowed) {
51580:     nsCOMPtr<nsIPopupWindowManager> pm =
51580:       do_GetService(NS_POPUPWINDOWMANAGER_CONTRACTID);
51580:  
51580:     if (!pm) {
51580:       return NS_OK;
51580:     }
51580: 
51580:     PRUint32 permission;
51580:     pm->TestPermission(doc->GetDocumentURI(), &permission);
51581:     if (permission == nsIPopupWindowManager::DENY_POPUP) {
51581:       nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(doc);
51581:       nsGlobalWindow::FirePopupBlockedEvent(domDoc, win, nsnull, EmptyString(), EmptyString());
51580:       return NS_OK;
51580:     }
51581:   }
51580: 
51580:   // Get Loc title
51580:   nsXPIDLString title;
51580:   nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
51580:                                      "FileUpload", title);
51580: 
51580:   nsCOMPtr<nsIFilePicker> filePicker = do_CreateInstance("@mozilla.org/filepicker;1");
51580:   if (!filePicker)
51580:     return NS_ERROR_FAILURE;
51580: 
55186:   PRBool multi = mInput->HasAttr(kNameSpaceID_None, nsGkAtoms::multiple);
51580: 
51580:   rv = filePicker->Init(win, title, multi ?
51580:                         (PRInt16)nsIFilePicker::modeOpenMultiple :
51580:                         (PRInt16)nsIFilePicker::modeOpen);
51580:   NS_ENSURE_SUCCESS(rv, rv);
51580: 
55184:   if (mInput->HasAttr(kNameSpaceID_None, nsGkAtoms::accept)) {
55185:     PRInt32 filters = mInput->GetFilterFromAccept();
55184: 
55184:     if (filters) {
55184:       // We add |filterAll| to be sure the user always has a sane fallback.
55184:       filePicker->AppendFilters(filters | nsIFilePicker::filterAll);
55184: 
55184:       // If the accept attribute asked for a filter, we need to make it default.
55184:       // |filterAll| will always use index=0 so we need to set index=1 as the
55184:       // current filter.
51580:       filePicker->SetFilterIndex(1);
55184:     } else {
55184:       filePicker->AppendFilters(nsIFilePicker::filterAll);
55184:     }
55184:   } else {
55184:     filePicker->AppendFilters(nsIFilePicker::filterAll);
51580:   }
51580: 
51580:   // Set default directry and filename
51580:   nsAutoString defaultName;
51580: 
52042:   const nsCOMArray<nsIDOMFile>& oldFiles = mInput->GetFiles();
51580: 
51580:   if (oldFiles.Count()) {
52042:     nsString path;
52042: 
52042:     oldFiles[0]->GetMozFullPathInternal(path);
52042: 
52042:     nsCOMPtr<nsILocalFile> localFile;
52042:     rv = NS_NewLocalFile(path, PR_FALSE, getter_AddRefs(localFile));
52042: 
52042:     if (NS_SUCCEEDED(rv)) {
51580:       nsCOMPtr<nsIFile> parentFile;
52042:       rv = localFile->GetParent(getter_AddRefs(parentFile));
52042:       if (NS_SUCCEEDED(rv)) {
51580:         nsCOMPtr<nsILocalFile> parentLocalFile = do_QueryInterface(parentFile, &rv);
51580:         if (parentLocalFile) {
51580:           filePicker->SetDisplayDirectory(parentLocalFile);
51580:         }
51580:       }
52042:     }
51580: 
51580:     // Unfortunately nsIFilePicker doesn't allow multiple files to be
51580:     // default-selected, so only select something by default if exactly
51580:     // one file was selected before.
51580:     if (oldFiles.Count() == 1) {
51580:       nsAutoString leafName;
52042:       oldFiles[0]->GetName(leafName);
51580:       if (!leafName.IsEmpty()) {
51580:         filePicker->SetDefaultString(leafName);
51580:       }
51580:     }
51580:   } else {
51580:     // Attempt to retrieve the last used directory from the content pref service
51580:     nsCOMPtr<nsILocalFile> localFile;
51580:     nsHTMLInputElement::gUploadLastDir->FetchLastUsedDirectory(doc->GetDocumentURI(),
51580:                                                                getter_AddRefs(localFile));
51580:     if (!localFile) {
51580:       // Default to "desktop" directory for each platform
51580:       nsCOMPtr<nsIFile> homeDir;
51580:       NS_GetSpecialDirectory(NS_OS_DESKTOP_DIR, getter_AddRefs(homeDir));
51580:       localFile = do_QueryInterface(homeDir);
51580:     }
51580:     filePicker->SetDisplayDirectory(localFile);
51580:   }
51580: 
51580:   // Open dialog
51580:   PRInt16 mode;
51580:   rv = filePicker->Show(&mode);
51580:   NS_ENSURE_SUCCESS(rv, rv);
53805:   if (mode == nsIFilePicker::returnCancel) {
51580:     return NS_OK;
53805:   }
51580: 
51580:   // Collect new selected filenames
52042:   nsCOMArray<nsIDOMFile> newFiles;
51580:   if (multi) {
51580:     nsCOMPtr<nsISimpleEnumerator> iter;
51580:     rv = filePicker->GetFiles(getter_AddRefs(iter));
51580:     NS_ENSURE_SUCCESS(rv, rv);
51580: 
51580:     nsCOMPtr<nsISupports> tmp;
51580:     PRBool prefSaved = PR_FALSE;
53805:     PRBool loop = PR_TRUE;
53805:     while (NS_SUCCEEDED(iter->HasMoreElements(&loop)) && loop) {
53805:       iter->GetNext(getter_AddRefs(tmp));
51580:       nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(tmp);
51580:       if (localFile) {
51580:         nsString unicodePath;
51580:         rv = localFile->GetPath(unicodePath);
51580:         if (!unicodePath.IsEmpty()) {
52042:           nsCOMPtr<nsIDOMFile> domFile =
54295:             do_QueryObject(new nsDOMFile(localFile));
52042:           newFiles.AppendObject(domFile);
51580:         }
51580:         if (!prefSaved) {
51580:           // Store the last used directory using the content pref service
51580:           rv = nsHTMLInputElement::gUploadLastDir->StoreLastUsedDirectory(doc->GetDocumentURI(), 
51580:                                                                           localFile);
51580:           NS_ENSURE_SUCCESS(rv, rv);
51580:           prefSaved = PR_TRUE;
51580:         }
51580:       }
51580:     }
51580:   }
51580:   else {
51580:     nsCOMPtr<nsILocalFile> localFile;
51580:     rv = filePicker->GetFile(getter_AddRefs(localFile));
51580:     if (localFile) {
51580:       nsString unicodePath;
51580:       rv = localFile->GetPath(unicodePath);
51580:       if (!unicodePath.IsEmpty()) {
52042:         nsCOMPtr<nsIDOMFile> domFile=
54295:           do_QueryObject(new nsDOMFile(localFile));
52042:         newFiles.AppendObject(domFile);
51580:       }
51580:       // Store the last used directory using the content pref service
51580:       rv = nsHTMLInputElement::gUploadLastDir->StoreLastUsedDirectory(doc->GetDocumentURI(),
51580:                                                                       localFile);
51580:       NS_ENSURE_SUCCESS(rv, rv);
51580:     }
51580:   }
51580: 
51580:   // Set new selected files
52042:   if (newFiles.Count()) {
53805:     // The text control frame (if there is one) isn't going to send a change
53805:     // event because it will think this is done by a script.
53805:     // So, we can safely send one by ourself.
52042:     mInput->SetFiles(newFiles);
53805:     nsContentUtils::DispatchTrustedEvent(mInput->GetOwnerDoc(),
53805:                                          static_cast<nsIDOMHTMLInputElement*>(mInput.get()),
53805:                                          NS_LITERAL_STRING("change"), PR_FALSE,
53805:                                          PR_FALSE);
51580:   }
51580: 
51580:   return NS_OK;
51580: }
51580: 
51580: #define CPS_PREF_NAME NS_LITERAL_STRING("browser.upload.lastDir")
51580: 
51580: NS_IMPL_ISUPPORTS2(UploadLastDir, nsIObserver, nsISupportsWeakReference)
51580: 
51580: void
51580: nsHTMLInputElement::InitUploadLastDir() {
51580:   gUploadLastDir = new UploadLastDir();
51580:   NS_ADDREF(gUploadLastDir);
51580: 
51580:   nsCOMPtr<nsIObserverService> observerService =
51580:     mozilla::services::GetObserverService();
51580:   if (observerService && gUploadLastDir) {
51580:     observerService->AddObserver(gUploadLastDir, NS_PRIVATE_BROWSING_SWITCH_TOPIC, PR_TRUE);
51580:     observerService->AddObserver(gUploadLastDir, "browser:purge-session-history", PR_TRUE);
51580:   }
51580: }
51580: 
51580: void 
51580: nsHTMLInputElement::DestroyUploadLastDir() {
51580:   NS_IF_RELEASE(gUploadLastDir);
51580: }
51580: 
51580: UploadLastDir::UploadLastDir():
51580:   mInPrivateBrowsing(PR_FALSE)
51580: {
51580:   nsCOMPtr<nsIPrivateBrowsingService> pbService =
51580:     do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
51580:   if (pbService) {
51580:     pbService->GetPrivateBrowsingEnabled(&mInPrivateBrowsing);
51580:   }
51580: 
51580:   mUploadLastDirStore.Init();
51580: }
51580: 
51580: nsresult
51580: UploadLastDir::FetchLastUsedDirectory(nsIURI* aURI, nsILocalFile** aFile)
51580: {
51580:   NS_PRECONDITION(aURI, "aURI is null");
51580:   NS_PRECONDITION(aFile, "aFile is null");
51580:   // Retrieve the data from memory if it's present during private browsing mode,
51580:   // otherwise fall through to check the CPS
51580:   if (mInPrivateBrowsing) {
51580:     nsCOMPtr<nsIContentURIGrouper> hostnameGrouperService =
51580:       do_GetService(NS_HOSTNAME_GROUPER_SERVICE_CONTRACTID);
51580:     if (!hostnameGrouperService)
51580:       return NS_ERROR_NOT_AVAILABLE;
51580:     nsString group;
51580:     hostnameGrouperService->Group(aURI, group);
51580: 
51580:     if (mUploadLastDirStore.Get(group, aFile)) {
51580:       return NS_OK;
51580:     }
51580:   }
51580: 
51580:   // Attempt to get the CPS, if it's not present we'll just return
51580:   nsCOMPtr<nsIContentPrefService> contentPrefService =
51580:     do_GetService(NS_CONTENT_PREF_SERVICE_CONTRACTID);
51580:   if (!contentPrefService)
51580:     return NS_ERROR_NOT_AVAILABLE;
51580:   nsCOMPtr<nsIWritableVariant> uri = do_CreateInstance(NS_VARIANT_CONTRACTID);
51580:   if (!uri)
51580:     return NS_ERROR_OUT_OF_MEMORY;
51580:   uri->SetAsISupports(aURI);
51580: 
51580:   // Get the last used directory, if it is stored
51580:   PRBool hasPref;
51580:   if (NS_SUCCEEDED(contentPrefService->HasPref(uri, CPS_PREF_NAME, &hasPref)) && hasPref) {
51580:     nsCOMPtr<nsIVariant> pref;
51580:     contentPrefService->GetPref(uri, CPS_PREF_NAME, nsnull, getter_AddRefs(pref));
51580:     nsString prefStr;
51580:     pref->GetAsAString(prefStr);
51580: 
51580:     nsCOMPtr<nsILocalFile> localFile = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
51580:     if (!localFile)
51580:       return NS_ERROR_OUT_OF_MEMORY;
51580:     localFile->InitWithPath(prefStr);
51580: 
51580:     *aFile = localFile;
51580:     NS_ADDREF(*aFile);
51580:   }
51580:   return NS_OK;
51580: }
51580: 
51580: nsresult
51580: UploadLastDir::StoreLastUsedDirectory(nsIURI* aURI, nsILocalFile* aFile)
51580: {
51580:   NS_PRECONDITION(aURI, "aURI is null");
51580:   NS_PRECONDITION(aFile, "aFile is null");
51580:   nsCOMPtr<nsIFile> parentFile;
51580:   aFile->GetParent(getter_AddRefs(parentFile));
57168:   if (!parentFile) {
57168:     return NS_OK;
57168:   }
51580:   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(parentFile);
51580: 
51580:   // Store the data in memory instead of the CPS during private browsing mode
51580:   if (mInPrivateBrowsing) {
51580:     nsCOMPtr<nsIContentURIGrouper> hostnameGrouperService =
51580:       do_GetService(NS_HOSTNAME_GROUPER_SERVICE_CONTRACTID);
51580:     if (!hostnameGrouperService)
51580:       return NS_ERROR_NOT_AVAILABLE;
51580:     nsString group;
51580:     hostnameGrouperService->Group(aURI, group);
51580: 
51580:     return mUploadLastDirStore.Put(group, localFile);
51580:   }
51580: 
51580:   // Attempt to get the CPS, if it's not present we'll just return
51580:   nsCOMPtr<nsIContentPrefService> contentPrefService =
51580:     do_GetService(NS_CONTENT_PREF_SERVICE_CONTRACTID);
51580:   if (!contentPrefService)
51580:     return NS_ERROR_NOT_AVAILABLE;
51580:   nsCOMPtr<nsIWritableVariant> uri = do_CreateInstance(NS_VARIANT_CONTRACTID);
51580:   if (!uri)
51580:     return NS_ERROR_OUT_OF_MEMORY;
51580:   uri->SetAsISupports(aURI);
51580:  
51580:   // Find the parent of aFile, and store it
51580:   nsString unicodePath;
51580:   parentFile->GetPath(unicodePath);
51580:   if (unicodePath.IsEmpty()) // nothing to do
51580:     return NS_OK;
51580:   nsCOMPtr<nsIWritableVariant> prefValue = do_CreateInstance(NS_VARIANT_CONTRACTID);
51580:   if (!prefValue)
51580:     return NS_ERROR_OUT_OF_MEMORY;
51580:   prefValue->SetAsAString(unicodePath);
51580:   return contentPrefService->SetPref(uri, CPS_PREF_NAME, prefValue);
51580: }
51580: 
51580: NS_IMETHODIMP
51580: UploadLastDir::Observe(nsISupports *aSubject, char const *aTopic, PRUnichar const *aData)
51580: {
51580:   if (strcmp(aTopic, NS_PRIVATE_BROWSING_SWITCH_TOPIC) == 0) {
51580:     if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_ENTER).Equals(aData)) {
51580:       mInPrivateBrowsing = PR_TRUE;
51580:     } else if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_LEAVE).Equals(aData)) {
51580:       mInPrivateBrowsing = PR_FALSE;
51580:       if (mUploadLastDirStore.IsInitialized()) {
51580:         mUploadLastDirStore.Clear();
51580:       }
51580:     }
51580:   } else if (strcmp(aTopic, "browser:purge-session-history") == 0) {
51580:     if (mUploadLastDirStore.IsInitialized()) {
51580:       mUploadLastDirStore.Clear();
51580:     }
51580:     nsCOMPtr<nsIContentPrefService> contentPrefService =
51580:       do_GetService(NS_CONTENT_PREF_SERVICE_CONTRACTID);
51580:     if (contentPrefService)
51580:       contentPrefService->RemovePrefsByName(CPS_PREF_NAME);
51580:   }
51580:   return NS_OK;
51580: }
51580: 
    1: #ifdef ACCESSIBILITY
    1: //Helper method
    1: static nsresult FireEventForAccessibility(nsIDOMHTMLInputElement* aTarget,
    1:                                           nsPresContext* aPresContext,
    1:                                           const nsAString& aEventType);
    1: #endif
    1: 
    1: //
    1: // construction, destruction
    1: //
    1: 
    1: NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER(Input)
    1: 
48124: nsHTMLInputElement::nsHTMLInputElement(already_AddRefed<nsINodeInfo> aNodeInfo,
56805:                                        FromParser aFromParser)
    1:   : nsGenericHTMLFormElement(aNodeInfo),
41437:     mType(kInputDefaultType->value),
43129:     mBitField(0)
    1: {
    1:   SET_BOOLBIT(mBitField, BF_PARSER_CREATING, aFromParser);
43829:   SET_BOOLBIT(mBitField, BF_INHIBIT_RESTORATION,
56805:       aFromParser & mozilla::dom::FROM_PARSER_FRAGMENT);
43129:   mInputData.mState = new nsTextEditorState(this);
43129:   NS_ADDREF(mInputData.mState);
51580:   
51580:   if (!gUploadLastDir)
51580:     nsHTMLInputElement::InitUploadLastDir();
    1: }
    1: 
    1: nsHTMLInputElement::~nsHTMLInputElement()
    1: {
    1:   DestroyImageLoadingContent();
43129:   FreeData();
43129: }
43129: 
43129: void
43129: nsHTMLInputElement::FreeData()
43129: {
43129:   if (!IsSingleLineTextControl(PR_FALSE)) {
43129:     nsMemory::Free(mInputData.mValue);
43129:     mInputData.mValue = nsnull;
43129:   } else {
43682:     UnbindFromFrame(nsnull);
43129:     NS_IF_RELEASE(mInputData.mState);
43129:   }
43129: }
43129: 
43129: nsTextEditorState*
43129: nsHTMLInputElement::GetEditorState() const
43129: {
43129:   if (!IsSingleLineTextControl(PR_FALSE)) {
43129:     return nsnull;
43129:   }
43129: 
43129:   NS_ASSERTION(mInputData.mState,
43129:     "Single line text controls need to have a state associated with them");
43129: 
43129:   return mInputData.mState;
    1: }
    1: 
    1: 
    1: // nsISupports
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLInputElement)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLInputElement,
    1:                                                   nsGenericHTMLFormElement)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mControllers)
43129:   if (tmp->IsSingleLineTextControl(PR_FALSE)) {
43129:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mInputData.mState, nsTextEditorState)
43129:   }
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsHTMLInputElement, nsGenericElement) 
    1: NS_IMPL_RELEASE_INHERITED(nsHTMLInputElement, nsGenericElement) 
    1: 
    1: 
48124: DOMCI_NODE_DATA(HTMLInputElement, nsHTMLInputElement)
40490: 
    1: // QueryInterface implementation for nsHTMLInputElement
21218: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLInputElement)
52042:   NS_HTML_CONTENT_INTERFACE_TABLE8(nsHTMLInputElement,
 4838:                                    nsIDOMHTMLInputElement,
 4838:                                    nsITextControlElement,
 4838:                                    nsIPhonetic,
 4838:                                    imgIDecoderObserver,
 4838:                                    nsIImageLoadingContent,
13964:                                    imgIContainerObserver,
51181:                                    nsIDOMNSEditableElement,
51182:                                    nsIConstraintValidation)
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLInputElement,
21218:                                                nsGenericHTMLFormElement)
 4838: NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLInputElement)
    1: 
51182: // nsIConstraintValidation
51182: NS_IMPL_NSICONSTRAINTVALIDATION_EXCEPT_SETCUSTOMVALIDITY(nsHTMLInputElement)
    1: 
    1: // nsIDOMNode
    1: 
    1: nsresult
    1: nsHTMLInputElement::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
    1: {
    1:   *aResult = nsnull;
    1: 
48124:   nsCOMPtr<nsINodeInfo> ni = aNodeInfo;
56805:   nsHTMLInputElement *it = new nsHTMLInputElement(ni.forget(), NOT_FROM_PARSER);
    1: 
    1:   nsCOMPtr<nsINode> kungFuDeathGrip = it;
    1:   nsresult rv = CopyInnerTo(it);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   switch (mType) {
50907:     case NS_FORM_INPUT_EMAIL:
42372:     case NS_FORM_INPUT_SEARCH:
    1:     case NS_FORM_INPUT_TEXT:
    1:     case NS_FORM_INPUT_PASSWORD:
42192:     case NS_FORM_INPUT_TEL:
50909:     case NS_FORM_INPUT_URL:
    1:       if (GET_BOOLBIT(mBitField, BF_VALUE_CHANGED)) {
    1:         // We don't have our default value anymore.  Set our value on
    1:         // the clone.
    1:         // XXX GetValue should be const
    1:         nsAutoString value;
 3233:         const_cast<nsHTMLInputElement*>(this)->GetValue(value);
    1:         // SetValueInternal handles setting the VALUE_CHANGED bit for us
48080:         it->SetValueInternal(value, PR_FALSE, PR_TRUE);
    1:       }
    1:       break;
    1:     case NS_FORM_INPUT_FILE:
52042:       if (it->GetOwnerDoc()->IsStaticDocument()) {
52042:         // We're going to be used in print preview.  Since the doc is static
52042:         // we can just grab the pretty string and use it as wallpaper
52042:         GetDisplayFileName(it->mStaticDocFileList);
52042:       } else {
52042:         it->mFiles.Clear();
52042:         it->mFiles.AppendObjects(mFiles);
52042:       }
    1:       break;
    1:     case NS_FORM_INPUT_RADIO:
    1:     case NS_FORM_INPUT_CHECKBOX:
    1:       if (GET_BOOLBIT(mBitField, BF_CHECKED_CHANGED)) {
    1:         // We no longer have our original checked state.  Set our
    1:         // checked state on the clone.
48085:         it->DoSetChecked(GetChecked(), PR_FALSE, PR_TRUE);
    1:       }
    1:       break;
35581:     case NS_FORM_INPUT_IMAGE:
35581:       if (it->GetOwnerDoc()->IsStaticDocument()) {
35581:         CreateStaticImageClone(it);
35581:       }
35581:       break;
    1:     default:
    1:       break;
    1:   }
    1: 
    1:   kungFuDeathGrip.swap(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLInputElement::BeforeSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                                   const nsAString* aValue,
    1:                                   PRBool aNotify)
    1: {
    1:   if (aNameSpaceID == kNameSpaceID_None) {
    1:     //
    1:     // When name or type changes, radio should be removed from radio group.
    1:     // (type changes are handled in the form itself currently)
    1:     // If the parser is not done creating the radio, we also should not do it.
    1:     //
    1:     if ((aName == nsGkAtoms::name ||
    1:          (aName == nsGkAtoms::type && !mForm)) &&
    1:         mType == NS_FORM_INPUT_RADIO &&
    1:         (mForm || !(GET_BOOLBIT(mBitField, BF_PARSER_CREATING)))) {
51178:       WillRemoveFromRadioGroup(aNotify);
    1:     } else if (aNotify && aName == nsGkAtoms::src &&
22743:                mType == NS_FORM_INPUT_IMAGE) {
22743:       if (aValue) {
    1:         LoadImage(*aValue, PR_TRUE, aNotify);
22743:       } else {
22743:         // Null value means the attr got unset; drop the image
22743:         CancelImageRequests(aNotify);
22743:       }
    1:     } else if (aNotify && aName == nsGkAtoms::disabled) {
    1:       SET_BOOLBIT(mBitField, BF_DISABLED_CHANGED, PR_TRUE);
    1:     }
    1:   }
    1: 
    1:   return nsGenericHTMLFormElement::BeforeSetAttr(aNameSpaceID, aName,
    1:                                                  aValue, aNotify);
    1: }
    1: 
    1: nsresult
    1: nsHTMLInputElement::AfterSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                                  const nsAString* aValue,
    1:                                  PRBool aNotify)
    1: {
51178:   // States changes that have to be passed to ContentStatesChanged().
56168:   nsEventStates states;
51178: 
    1:   if (aNameSpaceID == kNameSpaceID_None) {
    1:     //
    1:     // When name or type changes, radio should be added to radio group.
    1:     // (type changes are handled in the form itself currently)
    1:     // If the parser is not done creating the radio, we also should not do it.
    1:     //
    1:     if ((aName == nsGkAtoms::name ||
    1:          (aName == nsGkAtoms::type && !mForm)) &&
    1:         mType == NS_FORM_INPUT_RADIO &&
    1:         (mForm || !(GET_BOOLBIT(mBitField, BF_PARSER_CREATING)))) {
    1:       AddedToRadioGroup();
    1:     }
    1: 
48063:     // If @value is changed and BF_VALUE_CHANGED is false, @value is the value
52196:     // of the element so, if the value of the element is different than @value,
52196:     // we have to re-set it. This is only the case when GetValueMode() returns
52196:     // VALUE_MODE_VALUE.
    1:     if (aName == nsGkAtoms::value &&
52196:         !GET_BOOLBIT(mBitField, BF_VALUE_CHANGED) &&
52196:         GetValueMode() == VALUE_MODE_VALUE) {
48079:       SetDefaultValueAsValue();
    1:     }
48063: 
    1:     //
    1:     // Checked must be set no matter what type of control it is, since
    1:     // GetChecked() must reflect the new value
 3410:     if (aName == nsGkAtoms::checked &&
 3410:         !GET_BOOLBIT(mBitField, BF_CHECKED_CHANGED)) {
    1:       // Delay setting checked if the parser is creating this element (wait
    1:       // until everything is set)
    1:       if (GET_BOOLBIT(mBitField, BF_PARSER_CREATING)) {
    1:         SET_BOOLBIT(mBitField, BF_SHOULD_INIT_CHECKED, PR_TRUE);
    1:       } else {
    1:         PRBool defaultChecked;
    1:         GetDefaultChecked(&defaultChecked);
48085:         DoSetChecked(defaultChecked, PR_TRUE, PR_TRUE);
    1:         SetCheckedChanged(PR_FALSE);
    1:       }
    1:     }
    1: 
    1:     if (aName == nsGkAtoms::type) {
    1:       if (!aValue) {
    1:         // We're now a text input.  Note that we have to handle this manually,
    1:         // since removing an attribute (which is what happened, since aValue is
    1:         // null) doesn't call ParseAttribute.
43437:         HandleTypeChange(kInputDefaultType->value);
    1:       }
    1: 
52361:       UpdateBarredFromConstraintValidation();
52361: 
43129:       // If we are changing type from File/Text/Tel/Passwd to other input types
43129:       // we need save the mValue into value attribute
43129:       if (mInputData.mValue &&
50907:           mType != NS_FORM_INPUT_EMAIL &&
    1:           mType != NS_FORM_INPUT_TEXT &&
42372:           mType != NS_FORM_INPUT_SEARCH &&
    1:           mType != NS_FORM_INPUT_PASSWORD &&
42192:           mType != NS_FORM_INPUT_TEL &&
50909:           mType != NS_FORM_INPUT_URL &&
    1:           mType != NS_FORM_INPUT_FILE) {
    1:         SetAttr(kNameSpaceID_None, nsGkAtoms::value,
43129:                 NS_ConvertUTF8toUTF16(mInputData.mValue), PR_FALSE);
43129:         FreeData();
    1:       }
    1: 
    1:       if (mType != NS_FORM_INPUT_IMAGE) {
    1:         // We're no longer an image input.  Cancel our image requests, if we have
    1:         // any.  Note that doing this when we already weren't an image is ok --
    1:         // just does nothing.
    1:         CancelImageRequests(aNotify);
    1:       } else if (aNotify) {
    1:         // We just got switched to be an image input; we should see
    1:         // whether we have an image to load;
    1:         nsAutoString src;
    1:         if (GetAttr(kNameSpaceID_None, nsGkAtoms::src, src)) {
    1:           LoadImage(src, PR_FALSE, aNotify);
    1:         }
    1:       }
    1: 
    1:       // Changing type affects the applicability of some states.  Just notify
    1:       // on them all now, just in case.  Note that we can't rely on the
51178:       // notifications LoadImage or CancelImageRequests might have sent, because
51178:       // those didn't include all the possibly-changed states in the mask. We
51178:       // have to do this here because we just updated mType, so the code in
51178:       // nsGenericElement::SetAttrAndNotify didn't see the new states.
51178:       states |= NS_EVENT_STATE_CHECKED |
    1:                 NS_EVENT_STATE_DEFAULT |
    1:                 NS_EVENT_STATE_BROKEN |
    1:                 NS_EVENT_STATE_USERDISABLED |
    1:                 NS_EVENT_STATE_SUPPRESSED |
14215:                 NS_EVENT_STATE_LOADING |
14215:                 NS_EVENT_STATE_MOZ_READONLY |
50912:                 NS_EVENT_STATE_MOZ_READWRITE |
50912:                 NS_EVENT_STATE_REQUIRED |
51178:                 NS_EVENT_STATE_OPTIONAL |
51178:                 NS_EVENT_STATE_VALID |
51178:                 NS_EVENT_STATE_INVALID |
51388:                 NS_EVENT_STATE_INDETERMINATE |
52361:                 NS_EVENT_STATE_MOZ_PLACEHOLDER |
52361:                 NS_EVENT_STATE_MOZ_SUBMITINVALID;
51178:     }
51178: 
51178:     if (aName == nsGkAtoms::required || aName == nsGkAtoms::disabled ||
51178:         aName == nsGkAtoms::readonly) {
51178:       UpdateValueMissingValidityState();
52361: 
52361:       // This *has* to be called *after* validity has changed.
52361:       if (aName == nsGkAtoms::readonly || aName == nsGkAtoms::disabled) {
52361:         UpdateBarredFromConstraintValidation();
52361:       }
52361: 
51178:       states |= NS_EVENT_STATE_REQUIRED | NS_EVENT_STATE_OPTIONAL |
51178:                 NS_EVENT_STATE_VALID | NS_EVENT_STATE_INVALID;
55101:     } else if (MaxLengthApplies() && aName == nsGkAtoms::maxlength) {
51178:       UpdateTooLongValidityState();
51178:       states |= NS_EVENT_STATE_VALID | NS_EVENT_STATE_INVALID;
51178:     } else if (aName == nsGkAtoms::pattern) {
51178:       UpdatePatternMismatchValidityState();
51178:       states |= NS_EVENT_STATE_VALID | NS_EVENT_STATE_INVALID;
51178:     }
51178: 
51178:     if (aNotify) {
51178:       nsIDocument* doc = GetCurrentDoc();
51178: 
51178:       if (aName == nsGkAtoms::type) {
 2896:         UpdateEditableState();
51178:       } else if (IsSingleLineTextControl(PR_FALSE) && aName == nsGkAtoms::readonly) {
51178:         UpdateEditableState();
51178:         states |= NS_EVENT_STATE_MOZ_READONLY | NS_EVENT_STATE_MOZ_READWRITE;
51178:       }
51178: 
56168:       if (doc && !states.IsEmpty()) {
52197:         MOZ_AUTO_DOC_UPDATE(doc, UPDATE_CONTENT_STATE, PR_TRUE);
51178:         doc->ContentStatesChanged(this, nsnull, states);
 2896:       }
 2896:     }
    1:   }
    1: 
    1:   return nsGenericHTMLFormElement::AfterSetAttr(aNameSpaceID, aName,
    1:                                                 aValue, aNotify);
    1: }
    1: 
    1: // nsIDOMHTMLInputElement
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::GetForm(nsIDOMHTMLFormElement** aForm)
    1: {
    1:   return nsGenericHTMLFormElement::GetForm(aForm);
    1: }
    1: 
48063: NS_IMPL_STRING_ATTR(nsHTMLInputElement, DefaultValue, value)
    1: NS_IMPL_BOOL_ATTR(nsHTMLInputElement, DefaultChecked, checked)
    1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, Accept, accept)
    1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, AccessKey, accesskey)
    1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, Align, align)
    1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, Alt, alt)
53804: NS_IMPL_ENUM_ATTR_DEFAULT_VALUE(nsHTMLInputElement, Autocomplete, autocomplete,
53804:                                 kInputDefaultAutocomplete->tag)
42460: NS_IMPL_BOOL_ATTR(nsHTMLInputElement, Autofocus, autofocus)
    1: //NS_IMPL_BOOL_ATTR(nsHTMLInputElement, Checked, checked)
    1: NS_IMPL_BOOL_ATTR(nsHTMLInputElement, Disabled, disabled)
56696: NS_IMPL_ACTION_ATTR(nsHTMLInputElement, FormAction, formaction)
51137: NS_IMPL_ENUM_ATTR_DEFAULT_VALUE(nsHTMLInputElement, FormEnctype, formenctype,
51137:                                 kFormDefaultEnctype->tag)
51137: NS_IMPL_ENUM_ATTR_DEFAULT_VALUE(nsHTMLInputElement, FormMethod, formmethod,
51137:                                 kFormDefaultMethod->tag)
53836: NS_IMPL_BOOL_ATTR(nsHTMLInputElement, FormNoValidate, formnovalidate)
50991: NS_IMPL_STRING_ATTR(nsHTMLInputElement, FormTarget, formtarget)
34164: NS_IMPL_BOOL_ATTR(nsHTMLInputElement, Multiple, multiple)
39007: NS_IMPL_NON_NEGATIVE_INT_ATTR(nsHTMLInputElement, MaxLength, maxlength)
    1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, Name, name)
    1: NS_IMPL_BOOL_ATTR(nsHTMLInputElement, ReadOnly, readonly)
50906: NS_IMPL_BOOL_ATTR(nsHTMLInputElement, Required, required)
    1: NS_IMPL_URI_ATTR(nsHTMLInputElement, Src, src)
56074: NS_IMPL_INT_ATTR(nsHTMLInputElement, TabIndex, tabindex)
    1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, UseMap, usemap)
    1: //NS_IMPL_STRING_ATTR(nsHTMLInputElement, Value, value)
56994: NS_IMPL_UINT_ATTR_NON_ZERO_DEFAULT_VALUE(nsHTMLInputElement, Size, size, DEFAULT_COLS)
50911: NS_IMPL_STRING_ATTR(nsHTMLInputElement, Pattern, pattern)
38754: NS_IMPL_STRING_ATTR(nsHTMLInputElement, Placeholder, placeholder)
41437: NS_IMPL_ENUM_ATTR_DEFAULT_VALUE(nsHTMLInputElement, Type, type,
41437:                                 kInputDefaultType->tag)
    1: 
    1: NS_IMETHODIMP
24022: nsHTMLInputElement::GetIndeterminate(PRBool* aValue)
24022: {
24022:   *aValue = GET_BOOLBIT(mBitField, BF_INDETERMINATE);
24022:   return NS_OK;
24022: }
24022: 
24916: nsresult
24916: nsHTMLInputElement::SetIndeterminateInternal(PRBool aValue,
24916:                                              PRBool aShouldInvalidate)
24022: {
24022:   SET_BOOLBIT(mBitField, BF_INDETERMINATE, aValue);
24022: 
24916:   if (aShouldInvalidate) {
24022:     // Repaint the frame
24022:     nsIFrame* frame = GetPrimaryFrame();
24022:     if (frame)
51756:       frame->InvalidateFrameSubtree();
24916:   }
24916: 
24916:   // Notify the document so it can update :indeterminate pseudoclass rules
24916:   nsIDocument* document = GetCurrentDoc();
24916:   if (document) {
24916:     mozAutoDocUpdate upd(document, UPDATE_CONTENT_STATE, PR_TRUE);
24916:     document->ContentStatesChanged(this, nsnull, NS_EVENT_STATE_INDETERMINATE);
24916:   }
24022: 
24022:   return NS_OK;
24022: }
24022: 
24022: NS_IMETHODIMP
24916: nsHTMLInputElement::SetIndeterminate(PRBool aValue)
24916: {
24916:   return SetIndeterminateInternal(aValue, PR_TRUE);
24916: }
24916: 
24916: NS_IMETHODIMP 
    1: nsHTMLInputElement::GetValue(nsAString& aValue)
    1: {
43129:   nsTextEditorState* state = GetEditorState();
43129:   if (state) {
43129:     state->GetValue(aValue, PR_TRUE);
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (mType == NS_FORM_INPUT_FILE) {
 8008:     if (nsContentUtils::IsCallerTrustedForCapability("UniversalFileRead")) {
52042:       if (mFiles.Count()) {
52042:         return mFiles[0]->GetMozFullPath(aValue);
    1:       }
    1:       else {
    1:         aValue.Truncate();
    1:       }
 8008:     } else {
 8008:       // Just return the leaf name
52042:       if (mFiles.Count() == 0 || NS_FAILED(mFiles[0]->GetName(aValue))) {
 8008:         aValue.Truncate();
 8008:       }
 8008:     }
    1:     
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Treat value == defaultValue for other input elements
    1:   if (!GetAttr(kNameSpaceID_None, nsGkAtoms::value, aValue) &&
    1:       (mType == NS_FORM_INPUT_RADIO || mType == NS_FORM_INPUT_CHECKBOX)) {
    1:     // The default value of a radio or checkbox input is "on".
    1:     aValue.AssignLiteral("on");
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLInputElement::SetValue(const nsAString& aValue)
    1: {
    1:   // check security.  Note that setting the value to the empty string is always
    1:   // OK and gives pages a way to clear a file input if necessary.
    1:   if (mType == NS_FORM_INPUT_FILE) {
    1:     if (!aValue.IsEmpty()) {
 8008:       if (!nsContentUtils::IsCallerTrustedForCapability("UniversalFileRead")) {
    1:         // setting the value of a "FILE" input widget requires the
    1:         // UniversalFileRead privilege
    1:         return NS_ERROR_DOM_SECURITY_ERR;
    1:       }
52042:       const PRUnichar *name = PromiseFlatString(aValue).get();
52042:       return MozSetFileNameArray(&name, 1);
    1:     }
    1:     else {
52042:       ClearFiles();
34230:     }
34230:   }
34230:   else {
48080:     SetValueInternal(aValue, PR_FALSE, PR_TRUE);
 6544:   }
 6544: 
 6544:   return NS_OK;
 6544: }
 6544: 
 6544: NS_IMETHODIMP
52363: nsHTMLInputElement::GetList(nsIDOMHTMLElement** aValue)
52363: {
52363:   nsAutoString dataListId;
52363:   GetAttr(kNameSpaceID_None, nsGkAtoms::list, dataListId);
52363:   if (!dataListId.IsEmpty()) {
52363:     nsIDocument* doc = GetCurrentDoc();
52363: 
52363:     if (doc) {
52363:       Element* elem = doc->GetElementById(dataListId);
52363: 
55360:       if (elem && elem->IsHTML(nsGkAtoms::datalist)) {
52363:         CallQueryInterface(elem, aValue);
52363:         return NS_OK;
52363:       }
52363:     }
52363:   }
52363: 
52363:   *aValue = nsnull;
52363:   return NS_OK;
52363: }
52363: 
52363: NS_IMETHODIMP 
34164: nsHTMLInputElement::MozGetFileNameArray(PRUint32 *aLength, PRUnichar ***aFileNames)
34164: {
34164:   if (!nsContentUtils::IsCallerTrustedForCapability("UniversalFileRead")) {
34164:     // Since this function returns full paths it's important that normal pages
34164:     // can't call it.
34164:     return NS_ERROR_DOM_SECURITY_ERR;
34164:   }
34164: 
52042:   *aLength = mFiles.Count();
34164:   PRUnichar **ret =
52042:     static_cast<PRUnichar **>(NS_Alloc(mFiles.Count() * sizeof(PRUnichar*)));
52042:   
54296:   for (PRInt32 i = 0; i <  mFiles.Count(); i++) {
52042:     nsString str;
54294:     mFiles[i]->GetMozFullPathInternal(str);
52042:     ret[i] = NS_strdup(str.get());
34164:   }
34164: 
34164:   *aFileNames = ret;
34164: 
34164:   return NS_OK;
34164: }
34164: 
34164: NS_IMETHODIMP 
34164: nsHTMLInputElement::MozSetFileNameArray(const PRUnichar **aFileNames, PRUint32 aLength)
34164: {
34164:   if (!nsContentUtils::IsCallerTrustedForCapability("UniversalFileRead")) {
34164:     // setting the value of a "FILE" input widget requires the
34164:     // UniversalFileRead privilege
34164:     return NS_ERROR_DOM_SECURITY_ERR;
34164:   }
34164: 
52042:   nsCOMArray<nsIDOMFile> files;
34164:   for (PRUint32 i = 0; i < aLength; ++i) {
52042:     nsCOMPtr<nsIFile> file;
52042:     if (StringBeginsWith(nsDependentString(aFileNames[i]),
52042:                          NS_LITERAL_STRING("file:"),
52042:                          nsASCIICaseInsensitiveStringComparator())) {
52042:       // Converts the URL string into the corresponding nsIFile if possible
52042:       // A local file will be created if the URL string begins with file://
52042:       NS_GetFileFromURLSpec(NS_ConvertUTF16toUTF8(aFileNames[i]),
52042:                             getter_AddRefs(file));
52042:     }
52042: 
52042:     if (!file) {
52042:       // this is no "file://", try as local file
52042:       nsCOMPtr<nsILocalFile> localFile;
52042:       NS_NewLocalFile(nsDependentString(aFileNames[i]),
52042:                       PR_FALSE, getter_AddRefs(localFile));
52042:       file = do_QueryInterface(localFile);
52042:     }
52042: 
52042:     if (file) {
54295:       nsCOMPtr<nsIDOMFile> domFile = new nsDOMFile(file);
52042:       files.AppendObject(domFile);
52042:     } else {
52042:       continue; // Not much we can do if the file doesn't exist
52042:     }
52042: 
52042:   }
52042: 
52042:   SetFiles(files);
34164: 
34164:   return NS_OK;
34164: }
34164: 
34164: NS_IMETHODIMP
42192: nsHTMLInputElement::MozIsTextField(PRBool aExcludePassword, PRBool* aResult)
42192: {
42192:   *aResult = IsSingleLineTextControl(aExcludePassword);
42192: 
42192:   return NS_OK;
42192: }
42192: 
42192: NS_IMETHODIMP 
 6544: nsHTMLInputElement::SetUserInput(const nsAString& aValue)
 6544: {
 6544:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
 6544:     return NS_ERROR_DOM_SECURITY_ERR;
 6544:   }
 6544: 
 6544:   if (mType == NS_FORM_INPUT_FILE)
 6544:   {
52042:     const PRUnichar* name = PromiseFlatString(aValue).get();
52042:     return MozSetFileNameArray(&name, 1);
 6544:   } else {
48080:     SetValueInternal(aValue, PR_TRUE, PR_TRUE);
 6544:   }
    1:   return NS_OK;
    1: }
    1: 
43129: NS_IMETHODIMP_(nsIEditor*)
43129: nsHTMLInputElement::GetTextEditor()
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     return state->GetEditor();
43134:   }
43129:   return nsnull;
43129: }
43129: 
43129: NS_IMETHODIMP_(nsISelectionController*)
43129: nsHTMLInputElement::GetSelectionController()
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     return state->GetSelectionController();
43134:   }
43129:   return nsnull;
43129: }
43129: 
43129: nsFrameSelection*
43129: nsHTMLInputElement::GetConstFrameSelection()
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     return state->GetConstFrameSelection();
43134:   }
43129:   return nsnull;
43129: }
43129: 
    1: NS_IMETHODIMP
43129: nsHTMLInputElement::BindToFrame(nsTextControlFrame* aFrame)
    1: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     return state->BindToFrame(aFrame);
43134:   }
43129:   return NS_ERROR_FAILURE;
43129: }
43129: 
43129: NS_IMETHODIMP_(void)
43129: nsHTMLInputElement::UnbindFromFrame(nsTextControlFrame* aFrame)
43129: {
43129:   nsTextEditorState *state = GetEditorState();
48078:   if (state && aFrame) {
43129:     state->UnbindFromFrame(aFrame);
43129:   }
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsHTMLInputElement::CreateEditor()
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     return state->PrepareEditor();
43134:   }
43129:   return NS_ERROR_FAILURE;
43129: }
43129: 
43129: NS_IMETHODIMP_(nsIContent*)
43129: nsHTMLInputElement::GetRootEditorNode()
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     return state->GetRootNode();
43134:   }
43129:   return nsnull;
43129: }
43129: 
43129: NS_IMETHODIMP_(nsIContent*)
56086: nsHTMLInputElement::CreatePlaceholderNode()
56086: {
56086:   nsTextEditorState *state = GetEditorState();
56086:   if (state) {
56086:     NS_ENSURE_SUCCESS(state->CreatePlaceholderNode(), nsnull);
56086:     return state->GetPlaceholderNode();
56086:   }
56086:   return nsnull;
56086: }
56086: 
56086: NS_IMETHODIMP_(nsIContent*)
43129: nsHTMLInputElement::GetPlaceholderNode()
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     return state->GetPlaceholderNode();
43134:   }
43129:   return nsnull;
43129: }
43129: 
43129: NS_IMETHODIMP_(void)
43129: nsHTMLInputElement::UpdatePlaceholderText(PRBool aNotify)
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     state->UpdatePlaceholderText(aNotify);
43129:   }
43129: }
43129: 
43129: NS_IMETHODIMP_(void)
43129: nsHTMLInputElement::SetPlaceholderClass(PRBool aVisible, PRBool aNotify)
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     state->SetPlaceholderClass(aVisible, aNotify);
43129:   }
    1: }
    1: 
    1: void
52042: nsHTMLInputElement::GetDisplayFileName(nsAString& aValue) const
    1: {
52042:   if (GetOwnerDoc()->IsStaticDocument()) {
52042:     aValue = mStaticDocFileList;
52042:     return;
52042:   }
52042: 
34164:   aValue.Truncate();
52042:   for (PRUint32 i = 0; i < (PRUint32)mFiles.Count(); ++i) {
52042:     nsString str;
54294:     mFiles[i]->GetMozFullPathInternal(str);
34164:     if (i == 0) {
52042:       aValue.Append(str);
    1:     }
    1:     else {
52042:       aValue.Append(NS_LITERAL_STRING(", ") + str);
34164:     }
    1:   }
    1: }
    1: 
    1: void
52042: nsHTMLInputElement::SetFiles(const nsCOMArray<nsIDOMFile>& aFiles)
    1: {
52042:   mFiles.Clear();
52042:   mFiles.AppendObjects(aFiles);
52042: 
 3469:   // No need to flush here, if there's no frame at this point we
 3469:   // don't need to force creation of one just to tell it about this
 3469:   // new value.  We just want the display to update as needed.
 3469:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_FALSE);
 3469:   if (formControlFrame) {
34164:     nsAutoString readableValue;
34164:     GetDisplayFileName(readableValue);
34164:     formControlFrame->SetFormProperty(nsGkAtoms::value, readableValue);
 3469:   }
 3469: 
 3940:   UpdateFileList();
 3940: 
    1:   SetValueChanged(PR_TRUE);
51178:   UpdateAllValidityStates(PR_TRUE);
    1: }
    1: 
52042: const nsCOMArray<nsIDOMFile>&
52042: nsHTMLInputElement::GetFiles()
 3940: {
52042:   return mFiles;
 3940: }
 3940: 
 3940: nsresult
 3940: nsHTMLInputElement::UpdateFileList()
 3940: {
 3940:   if (mFileList) {
 3940:     mFileList->Clear();
 3940: 
52042:     const nsCOMArray<nsIDOMFile>& files = GetFiles();
34164:     for (PRUint32 i = 0; i < (PRUint32)files.Count(); ++i) {
52042:       if (!mFileList->Append(files[i])) {
 3940:         return NS_ERROR_FAILURE;
 3940:       }
 3940:     }
 3940:   }
 3940: 
 3940:   return NS_OK;
 3940: }
 3940: 
 3940: nsresult
    1: nsHTMLInputElement::SetValueInternal(const nsAString& aValue,
48080:                                      PRBool aUserInput,
48080:                                      PRBool aSetValueChanged)
    1: {
    1:   NS_PRECONDITION(mType != NS_FORM_INPUT_FILE,
    1:                   "Don't call SetValueInternal for file inputs");
    1: 
    1:   if (mType == NS_FORM_INPUT_FILE) {
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
48063:   if (IsSingleLineTextControl(PR_FALSE)) {
48063:     // At the moment, only single line text control have to sanitize their value
48063:     // Because we have to create a new string for that, we should prevent doing
48063:     // it if it's useless.
48063:     nsAutoString value(aValue);
54366:     if (!GET_BOOLBIT(mBitField, BF_PARSER_CREATING)) {
48063:       SanitizeValue(value);
54366:     }
48063: 
48080:     if (aSetValueChanged) {
48063:       SetValueChanged(PR_TRUE);
48080:     }
48063:     mInputData.mState->SetValue(value, aUserInput);
48063: 
51388:     if (PlaceholderApplies() &&
51388:         HasAttr(kNameSpaceID_None, nsGkAtoms::placeholder)) {
51388:       nsIDocument* doc = GetCurrentDoc();
51388:       if (doc) {
51388:         mozAutoDocUpdate upd(doc, UPDATE_CONTENT_STATE, PR_TRUE);
51388:         doc->ContentStatesChanged(this, nsnull, NS_EVENT_STATE_MOZ_PLACEHOLDER);
51388:       }
51388:     }
51388: 
48063:     return NS_OK;
48063:   }
48063: 
    1:   // If the value of a hidden input was changed, we mark it changed so that we
    1:   // will know we need to save / restore the value.  Yes, we are overloading
    1:   // the meaning of ValueChanged just a teensy bit to save a measly byte of
    1:   // storage space in nsHTMLInputElement.  Yes, you are free to make a new flag,
    1:   // NEED_TO_SAVE_VALUE, at such time as mBitField becomes a 16-bit value.
    1:   if (mType == NS_FORM_INPUT_HIDDEN) {
    1:     SetValueChanged(PR_TRUE);
    1:   }
    1: 
    1:   // Treat value == defaultValue for other input elements.
    1:   return nsGenericHTMLFormElement::SetAttr(kNameSpaceID_None,
    1:                                            nsGkAtoms::value, aValue,
    1:                                            PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::SetValueChanged(PRBool aValueChanged)
    1: {
    1:   SET_BOOLBIT(mBitField, BF_VALUE_CHANGED, aValueChanged);
    1:   if (!aValueChanged) {
43129:     if (!IsSingleLineTextControl(PR_FALSE)) {
43129:       FreeData();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLInputElement::GetChecked(PRBool* aChecked)
    1: {
38672:   *aChecked = GetChecked();
    1:   return NS_OK;
    1: }
    1: 
47648: void
    1: nsHTMLInputElement::SetCheckedChanged(PRBool aCheckedChanged)
    1: {
47648:   DoSetCheckedChanged(aCheckedChanged, PR_TRUE);
47648: }
47648: 
47648: void
    1: nsHTMLInputElement::DoSetCheckedChanged(PRBool aCheckedChanged,
    1:                                         PRBool aNotify)
    1: {
    1:   if (mType == NS_FORM_INPUT_RADIO) {
    1:     if (GET_BOOLBIT(mBitField, BF_CHECKED_CHANGED) != aCheckedChanged) {
    1:       nsCOMPtr<nsIRadioVisitor> visitor;
    1:       NS_GetRadioSetCheckedChangedVisitor(aCheckedChanged,
    1:                                           getter_AddRefs(visitor));
    1:       VisitGroup(visitor, aNotify);
    1:     }
    1:   } else {
    1:     SetCheckedChangedInternal(aCheckedChanged);
    1:   }
47648: }
47648: 
47648: void
    1: nsHTMLInputElement::SetCheckedChangedInternal(PRBool aCheckedChanged)
    1: {
    1:   SET_BOOLBIT(mBitField, BF_CHECKED_CHANGED, aCheckedChanged);
47648: }
47648: 
47648: 
47648: PRBool
47648: nsHTMLInputElement::GetCheckedChanged()
    1: {
47648:   return GET_BOOLBIT(mBitField, BF_CHECKED_CHANGED);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::SetChecked(PRBool aChecked)
    1: {
48085:   return DoSetChecked(aChecked, PR_TRUE, PR_TRUE);
    1: }
    1: 
    1: nsresult
48085: nsHTMLInputElement::DoSetChecked(PRBool aChecked, PRBool aNotify,
48085:                                  PRBool aSetValueChanged)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   // If the user or JS attempts to set checked, whether it actually changes the
    1:   // value or not, we say the value was changed so that defaultValue don't
    1:   // affect it no more.
48085:   if (aSetValueChanged) {
    1:     DoSetCheckedChanged(PR_TRUE, aNotify);
48085:   }
    1: 
    1:   //
    1:   // Don't do anything if we're not changing whether it's checked (it would
    1:   // screw up state actually, especially when you are setting radio button to
    1:   // false)
    1:   //
38672:   if (GetChecked() == aChecked) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   //
    1:   // Set checked
    1:   //
    1:   if (mType == NS_FORM_INPUT_RADIO) {
    1:     //
    1:     // For radio button, we need to do some extra fun stuff
    1:     //
    1:     if (aChecked) {
    1:       rv = RadioSetChecked(aNotify);
    1:     } else {
    1:       nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
    1:       if (container) {
    1:         nsAutoString name;
    1:         if (GetNameIfExists(name)) {
    1:           container->SetCurrentRadioButton(name, nsnull);
    1:         }
    1:       }
51178:       // SetCheckedInternal is going to ask all radios to update their
51178:       // validity state. We have to be sure the radio group container knows
51178:       // the currently selected radio.
51178:       SetCheckedInternal(PR_FALSE, aNotify);
    1:     }
    1:   } else {
51178:     SetCheckedInternal(aChecked, aNotify);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
47648: nsresult
    1: nsHTMLInputElement::RadioSetChecked(PRBool aNotify)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   //
    1:   // Find the selected radio button so we can deselect it
    1:   //
50906:   nsCOMPtr<nsIDOMHTMLInputElement> currentlySelected = GetSelectedRadioButton();
    1: 
    1:   //
    1:   // Deselect the currently selected radio button
    1:   //
    1:   if (currentlySelected) {
    1:     // Pass PR_TRUE for the aNotify parameter since the currently selected
    1:     // button is already in the document.
51178:     static_cast<nsHTMLInputElement*>
 3233:                (static_cast<nsIDOMHTMLInputElement*>(currentlySelected))->SetCheckedInternal(PR_FALSE, PR_TRUE);
    1:   }
    1: 
    1:   //
    1:   // Let the group know that we are now the One True Radio Button
    1:   //
50906:   nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
50906:   nsAutoString name;
50906:   if (container && GetNameIfExists(name)) {
    1:     rv = container->SetCurrentRadioButton(name, this);
    1:   }
    1: 
51178:   // SetCheckedInternal is going to ask all radios to update their
51178:   // validity state. We have to be sure the radio group container knows
51178:   // the currently selected radio.
51178:   if (NS_SUCCEEDED(rv)) {
51178:     SetCheckedInternal(PR_TRUE, aNotify);
51178:   }
51178: 
    1:   return rv;
    1: }
    1: 
    1: /* virtual */ already_AddRefed<nsIRadioGroupContainer>
    1: nsHTMLInputElement::GetRadioGroupContainer()
    1: {
    1:   nsIRadioGroupContainer* retval = nsnull;
    1:   if (mForm) {
    1:     CallQueryInterface(mForm, &retval);
    1:   } else {
    1:     nsIDocument* currentDoc = GetCurrentDoc();
    1:     if (currentDoc) {
    1:       CallQueryInterface(currentDoc, &retval);
    1:     }
    1:   }
    1:   return retval;
    1: }
    1: 
50906: already_AddRefed<nsIDOMHTMLInputElement>
50906: nsHTMLInputElement::GetSelectedRadioButton()
50906: {
50906:   nsIDOMHTMLInputElement* selected;
50906:   nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
50906: 
50906:   if (!container) {
50906:     return nsnull;
50906:   }
50906: 
50906:   nsAutoString name;
50906:   if (!GetNameIfExists(name)) {
50906:     return nsnull;
50906:   }
50906: 
50906:   container->GetCurrentRadioButton(name, &selected);
50906:   return selected;
50906: }
50906: 
    1: nsresult
    1: nsHTMLInputElement::MaybeSubmitForm(nsPresContext* aPresContext)
    1: {
    1:   if (!mForm) {
    1:     // Nothing to do here.
    1:     return NS_OK;
    1:   }
    1:   
   95:   nsCOMPtr<nsIPresShell> shell = aPresContext->GetPresShell();
    1:   if (!shell) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Get the default submit element
    1:   nsIFormControl* submitControl = mForm->GetDefaultSubmitElement();
    1:   if (submitControl) {
    1:     nsCOMPtr<nsIContent> submitContent(do_QueryInterface(submitControl));
    1:     NS_ASSERTION(submitContent, "Form control not implementing nsIContent?!");
    1:     // Fire the button's onclick handler and let the button handle
    1:     // submitting the form.
    1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_CLICK, nsnull, nsMouseEvent::eReal);
    1:     nsEventStatus status = nsEventStatus_eIgnore;
    1:     shell->HandleDOMEventWithTarget(submitContent, &event, &status);
52448:   } else if (mForm->HasSingleTextControl() &&
52448:              (mForm->HasAttr(kNameSpaceID_None, nsGkAtoms::novalidate) ||
52448:               mForm->CheckValidFormSubmission())) {
52445:     // TODO: removing this code and have the submit event sent by the form,
52445:     // bug 592124.
    1:     // If there's only one text control, just submit the form
34395:     // Hold strong ref across the event
34395:     nsRefPtr<nsHTMLFormElement> form(mForm);
    1:     nsFormEvent event(PR_TRUE, NS_FORM_SUBMIT);
    1:     nsEventStatus status  = nsEventStatus_eIgnore;
34395:     shell->HandleDOMEventWithTarget(mForm, &event, &status);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
51178: void
    1: nsHTMLInputElement::SetCheckedInternal(PRBool aChecked, PRBool aNotify)
    1: {
    1:   //
    1:   // Set the value
    1:   //
    1:   SET_BOOLBIT(mBitField, BF_CHECKED, aChecked);
    1: 
    1:   //
    1:   // Notify the frame
    1:   //
38019:   if (mType == NS_FORM_INPUT_CHECKBOX || mType == NS_FORM_INPUT_RADIO) {
    1:     nsIFrame* frame = GetPrimaryFrame();
    1:     if (frame) {
51756:       frame->InvalidateFrameSubtree();
    1:     }
    1:   }
    1: 
    1:   // Notify the document that the CSS :checked pseudoclass for this element
    1:   // has changed state.
    1:   if (aNotify) {
    1:     nsIDocument* document = GetCurrentDoc();
    1:     if (document) {
    1:       mozAutoDocUpdate upd(document, UPDATE_CONTENT_STATE, aNotify);
    1:       document->ContentStatesChanged(this, nsnull, NS_EVENT_STATE_CHECKED);
    1:     }
    1:   }
    1: 
51178:   if (mType == NS_FORM_INPUT_CHECKBOX) {
51178:     UpdateAllValidityStates(aNotify);
51178:   }
51178: 
51178:   if (mType == NS_FORM_INPUT_RADIO) {
51178:     // OnValueChanged is going to be called for all radios in the radio group.
51178:     nsCOMPtr<nsIRadioVisitor> visitor =
51178:       NS_GetRadioUpdateValueMissingVisitor(aNotify);
51178:     VisitGroup(visitor, aNotify);
51178:   }
    1: }
    1: 
    1: 
    1: void
    1: nsHTMLInputElement::FireOnChange()
    1: {
    1:   //
    1:   // Since the value is changing, send out an onchange event (bug 23571)
    1:   //
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   nsEvent event(PR_TRUE, NS_FORM_CHANGE);
39823:   nsRefPtr<nsPresContext> presContext = GetPresContext();
 3233:   nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this), presContext,
    1:                               &event, nsnull, &status);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::Blur()
    1: {
29018:   return nsGenericHTMLElement::Blur();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::Focus()
    1: {
29018:   if (mType == NS_FORM_INPUT_FILE) {
29018:     // for file inputs, focus the button instead
29018:     nsIFrame* frame = GetPrimaryFrame();
29018:     if (frame) {
29018:       nsIFrame* childFrame = frame->GetFirstChild(nsnull);
29018:       while (childFrame) {
29018:         // see if the child is a button control
29018:         nsCOMPtr<nsIFormControl> formCtrl =
29018:           do_QueryInterface(childFrame->GetContent());
29018:         if (formCtrl && formCtrl->GetType() == NS_FORM_INPUT_BUTTON) {
29018:           nsCOMPtr<nsIDOMElement> element(do_QueryInterface(formCtrl));
29018:           nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:           if (fm && element)
29018:             fm->SetFocus(element, 0);
30604:           break;
29018:         }
29018: 
29018:         childFrame = childFrame->GetNextSibling();
29018:       }
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
29018:   return nsGenericHTMLElement::Focus();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::Select()
    1: {
42192:   if (!IsSingleLineTextControl(PR_FALSE)) {
    1:     return NS_OK;
20109:   }
20109: 
    1:   // XXX Bug?  We have to give the input focus before contents can be
    1:   // selected
    1: 
20109:   FocusTristate state = FocusState();
20109:   if (state == eUnfocusable) {
20109:     return NS_OK;
20109:   }
20109: 
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018: 
39823:   nsRefPtr<nsPresContext> presContext = GetPresContext();
20109:   if (state == eInactiveWindow) {
29018:     if (fm)
29018:       fm->SetFocus(this, nsIFocusManager::FLAG_NOSCROLL);
    1:     SelectAll(presContext);
    1:     return NS_OK;
    1:   }
    1: 
29018:   if (DispatchSelectEvent(presContext) && fm) {
29018:     fm->SetFocus(this, nsIFocusManager::FLAG_NOSCROLL);
29018: 
29018:     // ensure that the element is actually focused
29018:     nsCOMPtr<nsIDOMElement> focusedElement;
29018:     fm->GetFocusedElement(getter_AddRefs(focusedElement));
29018:     if (SameCOMIdentity(static_cast<nsIDOMNode *>(this), focusedElement)) {
29018:       // Now Select all the text!
29018:       SelectAll(presContext);
29018:     }
29018:   }
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: PRBool
29018: nsHTMLInputElement::DispatchSelectEvent(nsPresContext* aPresContext)
29018: {
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1: 
    1:   // If already handling select event, don't dispatch a second.
    1:   if (!GET_BOOLBIT(mBitField, BF_HANDLING_SELECT_EVENT)) {
    1:     nsEvent event(nsContentUtils::IsCallerChrome(), NS_FORM_SELECTED);
    1: 
    1:     SET_BOOLBIT(mBitField, BF_HANDLING_SELECT_EVENT, PR_TRUE);
 3233:     nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this),
29018:                                 aPresContext, &event, nsnull, &status);
    1:     SET_BOOLBIT(mBitField, BF_HANDLING_SELECT_EVENT, PR_FALSE);
    1:   }
    1: 
    1:   // If the DOM event was not canceled (e.g. by a JS event handler
    1:   // returning false)
29018:   return (status == nsEventStatus_eIgnore);
    1: }
    1:     
    1: void
    1: nsHTMLInputElement::SelectAll(nsPresContext* aPresContext)
    1: {
    1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
    1: 
    1:   if (formControlFrame) {
    1:     formControlFrame->SetFormProperty(nsGkAtoms::select, EmptyString());
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::Click()
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (GET_BOOLBIT(mBitField, BF_HANDLING_CLICK)) // Fixes crash as in bug 41599
    1:       return rv;                      // --heikki@netscape.com
    1: 
    1:   // first see if we are disabled or not. If disabled then do nothing.
    1:   nsAutoString disabled;
54342:   if (IsDisabled()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // see what type of input we are.  Only click button, checkbox, radio,
    1:   // reset, submit, & image
    1:   if (mType == NS_FORM_INPUT_BUTTON   ||
    1:       mType == NS_FORM_INPUT_CHECKBOX ||
    1:       mType == NS_FORM_INPUT_RADIO    ||
    1:       mType == NS_FORM_INPUT_RESET    ||
    1:       mType == NS_FORM_INPUT_SUBMIT   ||
51580:       mType == NS_FORM_INPUT_IMAGE    ||
51580:       mType == NS_FORM_INPUT_FILE) {
    1: 
    1:     // Strong in case the event kills it
    1:     nsCOMPtr<nsIDocument> doc = GetCurrentDoc();
    1:     if (!doc) {
    1:       return rv;
    1:     }
    1: 
46225:     nsCOMPtr<nsIPresShell> shell = doc->GetShell();
39823:     nsRefPtr<nsPresContext> context = nsnull;
    1:     if (shell) {
39620:       context = shell->GetPresContext();
39620:     }
39620: 
39620:     if (!context) {
39620:       doc->FlushPendingNotifications(Flush_Frames);
46225:       shell = doc->GetShell();
39620:       if (shell) {
39620:         context = shell->GetPresContext();
39620:       }
39620:     }
    1: 
    1:     if (context) {
    1:       // Click() is never called from native code, but it may be
    1:       // called from chrome JS. Mark this event trusted if Click()
    1:       // is called from chrome code.
    1:       nsMouseEvent event(nsContentUtils::IsCallerChrome(),
    1:                          NS_MOUSE_CLICK, nsnull, nsMouseEvent::eReal);
40485:       event.inputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_UNKNOWN;
    1:       nsEventStatus status = nsEventStatus_eIgnore;
    1: 
    1:       SET_BOOLBIT(mBitField, BF_HANDLING_CLICK, PR_TRUE);
51580:       if (mType == NS_FORM_INPUT_FILE){
51580:         FireAsyncClickHandler();
51580:       }
 3233:       nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this), context,
    1:                                   &event, nsnull, &status);
    1: 
    1:       SET_BOOLBIT(mBitField, BF_HANDLING_CLICK, PR_FALSE);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
51580: NS_IMETHODIMP
51580: nsHTMLInputElement::FireAsyncClickHandler()
51580: {
51580:   nsCOMPtr<nsIRunnable> event = new AsyncClickHandler(this);
51580:   return NS_DispatchToMainThread(event);
51580: }
51580: 
40691: PRBool
40691: nsHTMLInputElement::NeedToInitializeEditorForEvent(nsEventChainPreVisitor& aVisitor) const
40691: {
42339:   // We only need to initialize the editor for single line input controls because they
40691:   // are lazily initialized.  We don't need to initialize the control for
40691:   // certain types of events, because we know that those events are safe to be
40691:   // handled without the editor being initialized.  These events include:
40691:   // mousein/move/out, and DOM mutation events.
42339:   if (IsSingleLineTextControl(PR_FALSE) &&
40691:       aVisitor.mEvent->eventStructType != NS_MUTATION_EVENT) {
40691: 
40691:     switch (aVisitor.mEvent->message) {
40691:     case NS_MOUSE_MOVE:
40691:     case NS_MOUSE_ENTER:
40691:     case NS_MOUSE_EXIT:
40691:     case NS_MOUSE_ENTER_SYNTH:
40691:     case NS_MOUSE_EXIT_SYNTH:
40691:       return PR_FALSE;
40691:       break;
40691:     }
40691:     return PR_TRUE;
40691:   }
40691:   return PR_FALSE;
40691: }
40691: 
    1: nsresult
    1: nsHTMLInputElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
    1: {
    1:   // Do not process any DOM events if the element is disabled
    1:   aVisitor.mCanHandle = PR_FALSE;
54342:   if (IsDisabled()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // For some reason or another we also need to check if the style shows us
    1:   // as disabled.
    1:   {
    1:     nsIFrame* frame = GetPrimaryFrame();
    1:     if (frame) {
    1:       const nsStyleUserInterface* uiStyle = frame->GetStyleUserInterface();
    1: 
    1:       if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE ||
    1:           uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED) {
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
40691:   // Initialize the editor if needed.
40691:   if (NeedToInitializeEditorForEvent(aVisitor)) {
40691:     nsITextControlFrame* textControlFrame = do_QueryFrame(GetPrimaryFrame());
40691:     if (textControlFrame)
40691:       textControlFrame->EnsureEditorInitialized();
40691:   }
40691: 
 3722:   //FIXME Allow submission etc. also when there is no prescontext, Bug 329509.
 3722:   if (!aVisitor.mPresContext) {
 3722:     return nsGenericHTMLElement::PreHandleEvent(aVisitor);
 3722:   }
    1:   //
    1:   // Web pages expect the value of a radio button or checkbox to be set
    1:   // *before* onclick and DOMActivate fire, and they expect that if they set
    1:   // the value explicitly during onclick or DOMActivate it will not be toggled
    1:   // or any such nonsense.
    1:   // In order to support that (bug 57137 and 58460 are examples) we toggle
    1:   // the checked attribute *first*, and then fire onclick.  If the user
    1:   // returns false, we reset the control to the old checked value.  Otherwise,
    1:   // we dispatch DOMActivate.  If DOMActivate is cancelled, we also reset
    1:   // the control to the old checked value.  We need to keep track of whether
    1:   // we've already toggled the state from onclick since the user could
    1:   // explicitly dispatch DOMActivate on the element.
    1:   //
    1:   // This is a compatibility hack.
    1:   //
    1: 
    1:   // Track whether we're in the outermost Dispatch invocation that will
    1:   // cause activation of the input.  That is, if we're a click event, or a
    1:   // DOMActivate that was dispatched directly, this will be set, but if we're
    1:   // a DOMActivate dispatched from click handling, it will not be set.
    1:   PRBool outerActivateEvent =
    1:     (NS_IS_MOUSE_LEFT_CLICK(aVisitor.mEvent) ||
    1:      (aVisitor.mEvent->message == NS_UI_ACTIVATE &&
    1:       !GET_BOOLBIT(mBitField, BF_IN_INTERNAL_ACTIVATE)));
    1: 
    1:   if (outerActivateEvent) {
    1:     aVisitor.mItemFlags |= NS_OUTER_ACTIVATE_EVENT;
    1:   }
    1: 
    1:   PRBool originalCheckedValue = PR_FALSE;
    1: 
    1:   if (outerActivateEvent) {
    1:     SET_BOOLBIT(mBitField, BF_CHECKED_IS_TOGGLED, PR_FALSE);
    1: 
    1:     switch(mType) {
    1:       case NS_FORM_INPUT_CHECKBOX:
    1:         {
24022:           if (GET_BOOLBIT(mBitField, BF_INDETERMINATE)) {
24022:             // indeterminate is always set to FALSE when the checkbox is toggled
24916:             SetIndeterminateInternal(PR_FALSE, PR_FALSE);
24022:             aVisitor.mItemFlags |= NS_ORIGINAL_INDETERMINATE_VALUE;
24022:           }
24022: 
    1:           GetChecked(&originalCheckedValue);
48085:           DoSetChecked(!originalCheckedValue, PR_TRUE, PR_TRUE);
    1:           SET_BOOLBIT(mBitField, BF_CHECKED_IS_TOGGLED, PR_TRUE);
    1:         }
    1:         break;
    1: 
    1:       case NS_FORM_INPUT_RADIO:
    1:         {
50906:           nsCOMPtr<nsIDOMHTMLInputElement> selectedRadioButton = GetSelectedRadioButton();
    1:           aVisitor.mItemData = selectedRadioButton;
    1: 
38672:           originalCheckedValue = GetChecked();
    1:           if (!originalCheckedValue) {
48085:             DoSetChecked(PR_TRUE, PR_TRUE, PR_TRUE);
    1:             SET_BOOLBIT(mBitField, BF_CHECKED_IS_TOGGLED, PR_TRUE);
    1:           }
    1:         }
    1:         break;
    1: 
    1:       case NS_FORM_INPUT_SUBMIT:
    1:       case NS_FORM_INPUT_IMAGE:
    1:         if(mForm) {
    1:           // tell the form that we are about to enter a click handler.
    1:           // that means that if there are scripted submissions, the
    1:           // latest one will be deferred until after the exit point of the handler. 
50992:           mForm->OnSubmitClickBegin(this);
    1:         }
    1:         break;
    1: 
    1:       default:
    1:         break;
    1:     } //switch
    1:   }
    1: 
    1:   if (originalCheckedValue) {
    1:     aVisitor.mItemFlags |= NS_ORIGINAL_CHECKED_VALUE;
    1:   }
    1: 
    1:   // If NS_EVENT_FLAG_NO_CONTENT_DISPATCH is set we will not allow content to handle
    1:   // this event.  But to allow middle mouse button paste to work we must allow 
    1:   // middle clicks to go to text fields anyway.
    1:   if (aVisitor.mEvent->flags & NS_EVENT_FLAG_NO_CONTENT_DISPATCH) {
    1:     aVisitor.mItemFlags |= NS_NO_CONTENT_DISPATCH;
    1:   }
42192:   if (IsSingleLineTextControl(PR_FALSE) &&
    1:       aVisitor.mEvent->message == NS_MOUSE_CLICK &&
    1:       aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT &&
 3233:       static_cast<nsMouseEvent*>(aVisitor.mEvent)->button ==
    1:         nsMouseEvent::eMiddleButton) {
    1:     aVisitor.mEvent->flags &= ~NS_EVENT_FLAG_NO_CONTENT_DISPATCH;
    1:   }
    1: 
    1:   // We must cache type because mType may change during JS event (bug 2369)
42990:   aVisitor.mItemFlags |= mType;
    1: 
    1:   // Fire onchange (if necessary), before we do the blur, bug 357684.
    1:   if (aVisitor.mEvent->message == NS_BLUR_CONTENT) {
    1:     nsIFrame* primaryFrame = GetPrimaryFrame();
    1:     if (primaryFrame) {
23554:       nsITextControlFrame* textFrame = do_QueryFrame(primaryFrame);
    1:       if (textFrame) {
    1:         textFrame->CheckFireOnChange();
    1:       }
    1:     }
    1:   }
    1: 
29018:   return nsGenericHTMLFormElement::PreHandleEvent(aVisitor);
29018: }
29018: 
29018: static PRBool
29018: SelectTextFieldOnFocus()
29018: {
29018:   if (!gSelectTextFieldOnFocus) {
29018:     nsCOMPtr<nsILookAndFeel> lookNFeel(do_GetService(kLookAndFeelCID));
29018:     if (lookNFeel) {
29018:       PRInt32 selectTextfieldsOnKeyFocus = -1;
29018:       lookNFeel->GetMetric(nsILookAndFeel::eMetric_SelectTextfieldsOnKeyFocus,
29018:                            selectTextfieldsOnKeyFocus);
29018:       gSelectTextFieldOnFocus = selectTextfieldsOnKeyFocus != 0 ? 1 : -1;
29018:     }
29018:     else {
29018:       gSelectTextFieldOnFocus = -1;
29018:     }
29018:   }
29018: 
29018:   return gSelectTextFieldOnFocus == 1;
    1: }
    1: 
    1: nsresult
    1: nsHTMLInputElement::PostHandleEvent(nsEventChainPostVisitor& aVisitor)
    1: {
    1:   if (!aVisitor.mPresContext) {
    1:     return NS_OK;
    1:   }
35693: 
51388:   if (PlaceholderApplies() &&
51388:       HasAttr(kNameSpaceID_None, nsGkAtoms::placeholder) &&
51388:       // TODO: checking if the value is empty could be a good idea but we do not
51388:       // have a simple way to do that, see bug 585100
51388:       (aVisitor.mEvent->message == NS_FOCUS_CONTENT ||
51388:        aVisitor.mEvent->message == NS_BLUR_CONTENT)) {
51388:     nsIDocument* doc = GetCurrentDoc();
51388:     if (doc) {
51388:       MOZ_AUTO_DOC_UPDATE(doc, UPDATE_CONTENT_STATE, PR_TRUE);
51388:       doc->ContentStatesChanged(this, nsnull, NS_EVENT_STATE_MOZ_PLACEHOLDER);
51388:     }
51388:   }
51388: 
35693:   // ignore the activate event fired by the "Browse..." button
35693:   // (file input controls fire their own) (bug 500885)
35693:   if (mType == NS_FORM_INPUT_FILE) {
35693:     nsCOMPtr<nsIContent> maybeButton =
35693:       do_QueryInterface(aVisitor.mEvent->originalTarget);
35693:     if (maybeButton &&
35693:       maybeButton->IsRootOfNativeAnonymousSubtree() &&
35693:       maybeButton->AttrValueIs(kNameSpaceID_None,
35693:                                nsGkAtoms::type,
35693:                                nsGkAtoms::button,
35693:                                eCaseMatters)) {
35693:         return NS_OK;
35693:     }
35693:   }
35693: 
    1:   nsresult rv = NS_OK;
11494:   PRBool outerActivateEvent = !!(aVisitor.mItemFlags & NS_OUTER_ACTIVATE_EVENT);
    1:   PRBool originalCheckedValue =
11494:     !!(aVisitor.mItemFlags & NS_ORIGINAL_CHECKED_VALUE);
11494:   PRBool noContentDispatch = !!(aVisitor.mItemFlags & NS_NO_CONTENT_DISPATCH);
42990:   PRUint8 oldType = NS_CONTROL_TYPE(aVisitor.mItemFlags);
    1:   // Ideally we would make the default action for click and space just dispatch
    1:   // DOMActivate, and the default action for DOMActivate flip the checkbox/
    1:   // radio state and fire onchange.  However, for backwards compatibility, we
    1:   // need to flip the state before firing click, and we need to fire click
    1:   // when space is pressed.  So, we just nest the firing of DOMActivate inside
    1:   // the click event handling, and allow cancellation of DOMActivate to cancel
    1:   // the click.
    1:   if (aVisitor.mEventStatus != nsEventStatus_eConsumeNoDefault &&
42192:       !IsSingleLineTextControl(PR_TRUE) &&
    1:       NS_IS_MOUSE_LEFT_CLICK(aVisitor.mEvent)) {
    1:     nsUIEvent actEvent(NS_IS_TRUSTED_EVENT(aVisitor.mEvent), NS_UI_ACTIVATE, 1);
    1: 
   95:     nsCOMPtr<nsIPresShell> shell = aVisitor.mPresContext->GetPresShell();
    1:     if (shell) {
    1:       nsEventStatus status = nsEventStatus_eIgnore;
    1:       SET_BOOLBIT(mBitField, BF_IN_INTERNAL_ACTIVATE, PR_TRUE);
    1:       rv = shell->HandleDOMEventWithTarget(this, &actEvent, &status);
    1:       SET_BOOLBIT(mBitField, BF_IN_INTERNAL_ACTIVATE, PR_FALSE);
    1: 
    1:       // If activate is cancelled, we must do the same as when click is
    1:       // cancelled (revert the checkbox to its original value).
    1:       if (status == nsEventStatus_eConsumeNoDefault)
    1:         aVisitor.mEventStatus = status;
    1:     }
    1:   }
    1: 
    1:   if (outerActivateEvent) {
    1:     switch(oldType) {
    1:       case NS_FORM_INPUT_SUBMIT:
    1:       case NS_FORM_INPUT_IMAGE:
    1:         if(mForm) {
    1:           // tell the form that we are about to exit a click handler
    1:           // so the form knows not to defer subsequent submissions
    1:           // the pending ones that were created during the handler
    1:           // will be flushed or forgoten.
    1:           mForm->OnSubmitClickEnd();
    1:         }
    1:         break;
    1:     } //switch
    1:   }
    1: 
    1:   // Reset the flag for other content besides this text field
    1:   aVisitor.mEvent->flags |=
    1:     noContentDispatch ? NS_EVENT_FLAG_NO_CONTENT_DISPATCH : NS_EVENT_FLAG_NONE;
    1: 
    1:   // now check to see if the event was "cancelled"
    1:   if (GET_BOOLBIT(mBitField, BF_CHECKED_IS_TOGGLED) && outerActivateEvent) {
    1:     if (aVisitor.mEventStatus == nsEventStatus_eConsumeNoDefault) {
    1:       // if it was cancelled and a radio button, then set the old
    1:       // selected btn to TRUE. if it is a checkbox then set it to its
    1:       // original value
    1:       nsCOMPtr<nsIDOMHTMLInputElement> selectedRadioButton =
    1:         do_QueryInterface(aVisitor.mItemData);
    1:       if (selectedRadioButton) {
    1:         selectedRadioButton->SetChecked(PR_TRUE);
    1:         // If this one is no longer a radio button we must reset it back to
    1:         // false to cancel the action.  See how the web of hack grows?
    1:         if (mType != NS_FORM_INPUT_RADIO) {
48085:           DoSetChecked(PR_FALSE, PR_TRUE, PR_TRUE);
    1:         }
    1:       } else if (oldType == NS_FORM_INPUT_CHECKBOX) {
24022:         PRBool originalIndeterminateValue =
24022:           !!(aVisitor.mItemFlags & NS_ORIGINAL_INDETERMINATE_VALUE);
24916:         SetIndeterminateInternal(originalIndeterminateValue, PR_FALSE);
48085:         DoSetChecked(originalCheckedValue, PR_TRUE, PR_TRUE);
    1:       }
    1:     } else {
    1:       FireOnChange();
    1: #ifdef ACCESSIBILITY
    1:       // Fire an event to notify accessibility
    1:       if (mType == NS_FORM_INPUT_CHECKBOX) {
    1:         FireEventForAccessibility(this, aVisitor.mPresContext,
    1:                                   NS_LITERAL_STRING("CheckboxStateChange"));
    1:       } else {
    1:         FireEventForAccessibility(this, aVisitor.mPresContext,
    1:                                   NS_LITERAL_STRING("RadioStateChange"));
    1:         // Fire event for the previous selected radio.
    1:         nsCOMPtr<nsIDOMHTMLInputElement> previous =
    1:           do_QueryInterface(aVisitor.mItemData);
    1:         if(previous) {
    1:           FireEventForAccessibility(previous, aVisitor.mPresContext,
    1:                                     NS_LITERAL_STRING("RadioStateChange"));
    1:         }
    1:       }
    1: #endif
    1:     }
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     if (nsEventStatus_eIgnore == aVisitor.mEventStatus) {
    1:       switch (aVisitor.mEvent->message) {
    1: 
    1:         case NS_FOCUS_CONTENT:
    1:         {
33344:           // see if we should select the contents of the textbox. This happens
33344:           // for text and password fields when the field was focused by the
33344:           // keyboard or a navigation, the platform allows it, and it wasn't
33344:           // just because we raised a window.
29018:           nsIFocusManager* fm = nsFocusManager::GetFocusManager();
42192:           if (fm && IsSingleLineTextControl(PR_FALSE) &&
33344:               !(static_cast<nsFocusEvent *>(aVisitor.mEvent))->fromRaise &&
29018:               SelectTextFieldOnFocus()) {
29018:             nsIDocument* document = GetCurrentDoc();
29018:             if (document) {
29018:               PRUint32 lastFocusMethod;
29018:               fm->GetLastFocusMethod(document->GetWindow(), &lastFocusMethod);
31988:               if (lastFocusMethod &
31988:                   (nsIFocusManager::FLAG_BYKEY | nsIFocusManager::FLAG_BYMOVEFOCUS)) {
39823:                 nsRefPtr<nsPresContext> presContext = GetPresContext();
29018:                 if (DispatchSelectEvent(presContext)) {
29018:                   SelectAll(presContext);
29018:                 }
29018:               }
29018:             }
29018:           }
29018:           break;
29018:         }
    1: 
    1:         case NS_KEY_PRESS:
    1:         case NS_KEY_UP:
    1:         {
    1:           // For backwards compat, trigger checks/radios/buttons with
    1:           // space or enter (bug 25300)
    1:           nsKeyEvent * keyEvent = (nsKeyEvent *)aVisitor.mEvent;
    1: 
    1:           if ((aVisitor.mEvent->message == NS_KEY_PRESS &&
    1:                keyEvent->keyCode == NS_VK_RETURN) ||
    1:               (aVisitor.mEvent->message == NS_KEY_UP &&
    1:                keyEvent->keyCode == NS_VK_SPACE)) {
    1:             switch(mType) {
    1:               case NS_FORM_INPUT_CHECKBOX:
    1:               case NS_FORM_INPUT_RADIO:
    1:               {
    1:                 // Checkbox and Radio try to submit on Enter press
    1:                 if (keyEvent->keyCode != NS_VK_SPACE) {
    1:                   MaybeSubmitForm(aVisitor.mPresContext);
    1: 
    1:                   break;  // If we are submitting, do not send click event
    1:                 }
    1:                 // else fall through and treat Space like click...
    1:               }
    1:               case NS_FORM_INPUT_BUTTON:
    1:               case NS_FORM_INPUT_RESET:
    1:               case NS_FORM_INPUT_SUBMIT:
    1:               case NS_FORM_INPUT_IMAGE: // Bug 34418
    1:               {
    1:                 nsMouseEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
    1:                                    NS_MOUSE_CLICK, nsnull, nsMouseEvent::eReal);
40485:                 event.inputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_KEYBOARD;
    1:                 nsEventStatus status = nsEventStatus_eIgnore;
    1: 
 3233:                 nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this),
    1:                                             aVisitor.mPresContext, &event,
    1:                                             nsnull, &status);
    1:               } // case
    1:             } // switch
    1:           }
    1:           if (aVisitor.mEvent->message == NS_KEY_PRESS &&
    1:               mType == NS_FORM_INPUT_RADIO && !keyEvent->isAlt &&
    1:               !keyEvent->isControl && !keyEvent->isMeta) {
    1:             PRBool isMovingBack = PR_FALSE;
    1:             switch (keyEvent->keyCode) {
    1:               case NS_VK_UP: 
    1:               case NS_VK_LEFT:
    1:                 isMovingBack = PR_TRUE;
    1:               case NS_VK_DOWN:
    1:               case NS_VK_RIGHT:
    1:               // Arrow key pressed, focus+select prev/next radio button
    1:               nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
    1:               if (container) {
    1:                 nsAutoString name;
    1:                 if (GetNameIfExists(name)) {
    1:                   nsCOMPtr<nsIDOMHTMLInputElement> selectedRadioButton;
    1:                   container->GetNextRadioButton(name, isMovingBack, this,
    1:                                                 getter_AddRefs(selectedRadioButton));
    1:                   nsCOMPtr<nsIContent> radioContent =
    1:                     do_QueryInterface(selectedRadioButton);
    1:                   if (radioContent) {
    1:                     rv = selectedRadioButton->Focus();
    1:                     if (NS_SUCCEEDED(rv)) {
    1:                       nsEventStatus status = nsEventStatus_eIgnore;
    1:                       nsMouseEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
    1:                                          NS_MOUSE_CLICK, nsnull,
    1:                                          nsMouseEvent::eReal);
40485:                       event.inputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_KEYBOARD;
    1:                       rv = nsEventDispatcher::Dispatch(radioContent,
    1:                                                        aVisitor.mPresContext,
    1:                                                        &event, nsnull, &status);
    1:                       if (NS_SUCCEEDED(rv)) {
    1:                         aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
    1:                       }
    1:                     }
    1:                   }
    1:                 }
    1:               }
    1:             }
    1:           }
    1: 
    1:           /*
    1:            * If this is input type=text, and the user hit enter, fire onChange
    1:            * and submit the form (if we are in one)
    1:            *
    1:            * Bug 99920, bug 109463 and bug 147850:
    1:            * (a) if there is a submit control in the form, click the first
    1:            *     submit control in the form.
    1:            * (b) if there is just one text control in the form, submit by
    1:            *     sending a submit event directly to the form
    1:            * (c) if there is more than one text input and no submit buttons, do
    1:            *     not submit, period.
    1:            */
    1: 
    1:           if (aVisitor.mEvent->message == NS_KEY_PRESS &&
    1:               (keyEvent->keyCode == NS_VK_RETURN ||
    1:                keyEvent->keyCode == NS_VK_ENTER) &&
    1:               (mType == NS_FORM_INPUT_TEXT ||
50907:                mType == NS_FORM_INPUT_EMAIL ||
42372:                mType == NS_FORM_INPUT_SEARCH ||
    1:                mType == NS_FORM_INPUT_PASSWORD ||
42192:                mType == NS_FORM_INPUT_TEL ||
50909:                mType == NS_FORM_INPUT_URL ||
    1:                mType == NS_FORM_INPUT_FILE)) {
    1: 
    1:             PRBool isButton = PR_FALSE;
    1:             // If this is an enter on the button of a file input, don't submit
    1:             // -- that's supposed to put up the filepicker
    1:             if (mType == NS_FORM_INPUT_FILE) {
    1:               nsCOMPtr<nsIContent> maybeButton =
    1:                 do_QueryInterface(aVisitor.mEvent->originalTarget);
    1:               if (maybeButton) {
    1:                 isButton = maybeButton->AttrValueIs(kNameSpaceID_None,
    1:                                                     nsGkAtoms::type,
    1:                                                     nsGkAtoms::button,
    1:                                                     eCaseMatters);
    1:               }
    1:             }
    1: 
    1:             if (!isButton) {
    1:               nsIFrame* primaryFrame = GetPrimaryFrame();
    1:               if (primaryFrame) {
23554:                 nsITextControlFrame* textFrame = do_QueryFrame(primaryFrame);
    1:               
    1:                 // Fire onChange (if necessary)
    1:                 if (textFrame) {
    1:                   textFrame->CheckFireOnChange();
    1:                 }
    1:               }
    1: 
    1:               rv = MaybeSubmitForm(aVisitor.mPresContext);
    1:               NS_ENSURE_SUCCESS(rv, rv);
    1:             }
    1:           }
    1: 
    1:         } break; // NS_KEY_PRESS || NS_KEY_UP
    1: 
    1:         case NS_MOUSE_BUTTON_DOWN:
    1:         case NS_MOUSE_BUTTON_UP:
    1:         case NS_MOUSE_DOUBLECLICK:
    1:         {
    1:           // cancel all of these events for buttons
    1:           //XXXsmaug Why?
    1:           if (aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT &&
 3233:               (static_cast<nsMouseEvent*>(aVisitor.mEvent)->button ==
    1:                  nsMouseEvent::eMiddleButton ||
 3233:                static_cast<nsMouseEvent*>(aVisitor.mEvent)->button ==
    1:                  nsMouseEvent::eRightButton)) {
    1:             if (mType == NS_FORM_INPUT_BUTTON ||
    1:                 mType == NS_FORM_INPUT_RESET ||
    1:                 mType == NS_FORM_INPUT_SUBMIT) {
    1:               if (aVisitor.mDOMEvent) {
    1:                 aVisitor.mDOMEvent->StopPropagation();
    1:               } else {
    1:                 rv = NS_ERROR_FAILURE;
    1:               }
    1:             }
    1: 
    1:           }
    1:           break;
    1:         }
    1:         default:
    1:           break;
    1:       }
    1: 
    1:       if (outerActivateEvent) {
    1:         if (mForm && (oldType == NS_FORM_INPUT_SUBMIT ||
    1:                       oldType == NS_FORM_INPUT_IMAGE)) {
    1:           if (mType != NS_FORM_INPUT_SUBMIT && mType != NS_FORM_INPUT_IMAGE) {
    1:             // If the type has changed to a non-submit type, then we want to
    1:             // flush the stored submission if there is one (as if the submit()
    1:             // was allowed to succeed)
    1:             mForm->FlushPendingSubmission();
    1:           }
    1:         }
    1:         switch(mType) {
    1:         case NS_FORM_INPUT_RESET:
    1:         case NS_FORM_INPUT_SUBMIT:
    1:         case NS_FORM_INPUT_IMAGE:
    1:           if (mForm) {
    1:             nsFormEvent event(PR_TRUE, (mType == NS_FORM_INPUT_RESET) ?
    1:                               NS_FORM_RESET : NS_FORM_SUBMIT);
    1:             event.originator      = this;
    1:             nsEventStatus status  = nsEventStatus_eIgnore;
    1: 
   95:             nsCOMPtr<nsIPresShell> presShell =
   95:               aVisitor.mPresContext->GetPresShell();
    1: 
    1:             // If |nsIPresShell::Destroy| has been called due to
    1:             // handling the event the pres context will return a null
    1:             // pres shell.  See bug 125624.
52445:             // TODO: removing this code and have the submit event sent by the
52445:             // form, see bug 592124.
52445:             if (presShell && (event.message != NS_FORM_SUBMIT ||
52448:                               mForm->HasAttr(kNameSpaceID_None, nsGkAtoms::novalidate) ||
53836:                               // We know the element is a submit control, if this check is moved,
53836:                               // make sure formnovalidate is used only if it's a submit control.
53836:                               HasAttr(kNameSpaceID_None, nsGkAtoms::formnovalidate) ||
52445:                               mForm->CheckValidFormSubmission())) {
34395:               // Hold a strong ref while dispatching
34395:               nsRefPtr<nsHTMLFormElement> form(mForm);
34395:               presShell->HandleDOMEventWithTarget(mForm, &event, &status);
    1:             }
    1:           }
    1:           break;
    1: 
    1:         default:
    1:           break;
    1:         } //switch 
    1:       } //click or outer activate event
    1:     } else if (outerActivateEvent &&
    1:                (oldType == NS_FORM_INPUT_SUBMIT ||
    1:                 oldType == NS_FORM_INPUT_IMAGE) &&
    1:                mForm) {
    1:       // tell the form to flush a possible pending submission.
    1:       // the reason is that the script returned false (the event was
    1:       // not ignored) so if there is a stored submission, it needs to
    1:       // be submitted immediately.
    1:       mForm->FlushPendingSubmission();
    1:     }
    1:   } // if
    1: 
    1:   return rv;
    1: }
    1: 
28627: void
28627: nsHTMLInputElement::MaybeLoadImage()
28627: {
28627:   // Our base URI may have changed; claim that our URI changed, and the
28627:   // nsImageLoadingContent will decide whether a new image load is warranted.
28627:   nsAutoString uri;
28627:   if (mType == NS_FORM_INPUT_IMAGE &&
28627:       GetAttr(kNameSpaceID_None, nsGkAtoms::src, uri) &&
28627:       (NS_FAILED(LoadImage(uri, PR_FALSE, PR_TRUE)) ||
28627:        !LoadingEnabled())) {
28627:     CancelImageRequests(PR_TRUE);
28627:   }
28627: }
    1: 
    1: nsresult
    1: nsHTMLInputElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                                nsIContent* aBindingParent,
    1:                                PRBool aCompileEventHandlers)
    1: {
    1:   nsresult rv = nsGenericHTMLFormElement::BindToTree(aDocument, aParent,
    1:                                                      aBindingParent,
    1:                                                      aCompileEventHandlers);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (mType == NS_FORM_INPUT_IMAGE) {
    1:     // Our base URI may have changed; claim that our URI changed, and the
    1:     // nsImageLoadingContent will decide whether a new image load is warranted.
28627:     if (HasAttr(kNameSpaceID_None, nsGkAtoms::src)) {
28627:       ClearBrokenState();
28627:       nsContentUtils::AddScriptRunner(
41361:         NS_NewRunnableMethod(this, &nsHTMLInputElement::MaybeLoadImage));
    1:     }
    1:   }
    1: 
    1:   // Add radio to document if we don't have a form already (if we do it's
    1:   // already been added into that group)
    1:   if (aDocument && !mForm && mType == NS_FORM_INPUT_RADIO) {
    1:     AddedToRadioGroup();
    1:   }
    1: 
51178:   // An element can't suffer from value missing if it is not in a document.
51178:   // We have to check if we suffer from that as we are now in a document.
51178:   UpdateValueMissingValidityState();
51178: 
54342:   // If there is a disabled fieldset in the parent chain, the element is now
54342:   // barred from constraint validation and can't suffer from value missing
54342:   // (call done before).
54342:   UpdateBarredFromConstraintValidation();
54342: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsHTMLInputElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
    1: {
    1:   // If we have a form and are unbound from it,
    1:   // nsGenericHTMLFormElement::UnbindFromTree() will unset the form and
    1:   // that takes care of form's WillRemove so we just have to take care
    1:   // of the case where we're removing from the document and we don't
    1:   // have a form
    1:   if (!mForm && mType == NS_FORM_INPUT_RADIO) {
51178:     WillRemoveFromRadioGroup(PR_FALSE);
    1:   }
    1: 
    1:   nsGenericHTMLFormElement::UnbindFromTree(aDeep, aNullParent);
51178: 
51178:   // GetCurrentDoc is returning nsnull so we can update the value
51178:   // missing validity state to reflect we are no longer into a doc.
51178:   UpdateValueMissingValidityState();
54342:   // We might be no longer disabled because of parent chain changed.
54342:   UpdateBarredFromConstraintValidation();
    1: }
    1: 
43437: void
43437: nsHTMLInputElement::HandleTypeChange(PRUint8 aNewType)
43437: {
53749:   ValueModeType aOldValueMode = GetValueMode();
53749:   nsAutoString aOldValue;
54366: 
54366:   if (aOldValueMode == VALUE_MODE_VALUE && !GET_BOOLBIT(mBitField, BF_PARSER_CREATING)) {
53749:     GetValue(aOldValue);
54366:   }
53749: 
43437:   // Only single line text inputs have a text editor state.
43437:   PRBool isNewTypeSingleLine =
43437:     IsSingleLineTextControlInternal(PR_FALSE, aNewType);
43437:   PRBool isCurrentTypeSingleLine =
43437:     IsSingleLineTextControl(PR_FALSE);
43437:   if (isNewTypeSingleLine && !isCurrentTypeSingleLine) {
43437:     FreeData();
43437:     mInputData.mState = new nsTextEditorState(this);
43437:     NS_ADDREF(mInputData.mState);
43437:   } else if (isCurrentTypeSingleLine && !isNewTypeSingleLine) {
43437:     FreeData();
43437:   }
43437: 
43437:   mType = aNewType;
48063: 
54366:   if (!GET_BOOLBIT(mBitField, BF_PARSER_CREATING)) {
53749:     /**
53749:      * The following code is trying to reproduce the algorithm described here:
53749:      * http://www.whatwg.org/specs/web-apps/current-work/complete.html#input-type-change
53749:      */
53749:     switch (GetValueMode()) {
53749:       case VALUE_MODE_DEFAULT:
53749:       case VALUE_MODE_DEFAULT_ON:
53749:         // If the previous value mode was value, we need to set the value content
53749:         // attribute to the previous value.
53749:         // There is no value sanitizing algorithm for elements in this mode.
53749:         if (aOldValueMode == VALUE_MODE_VALUE && !aOldValue.IsEmpty()) {
53749:           SetAttr(kNameSpaceID_None, nsGkAtoms::value, aOldValue, PR_TRUE);
53749:         }
53749:         break;
53749:       case VALUE_MODE_VALUE:
53749:         // If the previous value mode wasn't value, we have to set the value to
53749:         // the value content attribute.
53749:         // SetValueInternal is going to sanitize the value.
53749:         {
48063:           nsAutoString value;
53749:           if (aOldValueMode != VALUE_MODE_VALUE) {
53749:             GetAttr(kNameSpaceID_None, nsGkAtoms::value, value);
53749:           } else {
53749:             // We get the current value so we can sanitize it.
48063:             GetValue(value);
53749:           }
48080:           SetValueInternal(value, PR_FALSE, PR_FALSE);
48063:         }
53749:         break;
53749:       case VALUE_MODE_FILENAME:
53749:       default:
53749:         // We don't care about the value.
53749:         // There is no value sanitizing algorithm for elements in this mode.
53749:         break;
53749:     }
54366:   }
51178: 
51178:   // Do not notify, it will be done after if needed.
51178:   UpdateAllValidityStates(PR_FALSE);
48063: }
48063: 
48063: void
48063: nsHTMLInputElement::SanitizeValue(nsAString& aValue)
48063: {
54366:   NS_ASSERTION(!GET_BOOLBIT(mBitField, BF_PARSER_CREATING),
54366:                "The element parsing should be finished!");
54366: 
48063:   switch (mType) {
48063:     case NS_FORM_INPUT_TEXT:
48063:     case NS_FORM_INPUT_SEARCH:
48063:     case NS_FORM_INPUT_TEL:
48063:     case NS_FORM_INPUT_PASSWORD:
50908:     case NS_FORM_INPUT_EMAIL:
48063:       {
48063:         PRUnichar crlf[] = { PRUnichar('\r'), PRUnichar('\n'), 0 };
48063:         aValue.StripChars(crlf);
48063:       }
48063:       break;
50910:     case NS_FORM_INPUT_URL:
50910:       {
50910:         PRUnichar crlf[] = { PRUnichar('\r'), PRUnichar('\n'), 0 };
50910:         aValue.StripChars(crlf);
50910: 
50910:         aValue = nsContentUtils::TrimWhitespace<nsContentUtils::IsHTMLWhitespace>(aValue);
50910:       }
50910:       break;
48063:   }
43437: }
43437: 
    1: PRBool
    1: nsHTMLInputElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                                    nsIAtom* aAttribute,
    1:                                    const nsAString& aValue,
    1:                                    nsAttrValue& aResult)
    1: {
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     if (aAttribute == nsGkAtoms::type) {
    1:       // XXX ARG!! This is major evilness. ParseAttribute
    1:       // shouldn't set members. Override SetAttr instead
 3940:       PRInt32 newType;
41437:       PRBool success = aResult.ParseEnumValue(aValue, kInputTypeTable, PR_FALSE);
41437:       if (success) {
 3940:         newType = aResult.GetEnumValue();
 3940:       } else {
41437:         newType = kInputDefaultType->value;
    1:       }
    1: 
18379:       if (newType != mType) {
18379:         // Make sure to do the check for newType being NS_FORM_INPUT_FILE and
18379:         // the corresponding SetValueInternal() call _before_ we set mType.
18379:         // That way the logic in SetValueInternal() will work right (that logic
18379:         // makes assumptions about our frame based on mType, but we won't have
18379:         // had time to recreate frames yet -- that happens later in the
18379:         // SetAttr() process).
34230:         if (newType == NS_FORM_INPUT_FILE || mType == NS_FORM_INPUT_FILE) {
34230:           // This call isn't strictly needed any more since we'll never
34230:           // confuse values and filenames. However it's there for backwards
    1:           // compat.
52042:           ClearFiles();
    1:         }
    1: 
43437:         HandleTypeChange(newType);
18379:       }
    1: 
 3940:       return success;
    1:     }
    1:     if (aAttribute == nsGkAtoms::width) {
11790:       return aResult.ParseSpecialIntValue(aValue, PR_TRUE);
    1:     }
    1:     if (aAttribute == nsGkAtoms::height) {
11790:       return aResult.ParseSpecialIntValue(aValue, PR_TRUE);
    1:     }
    1:     if (aAttribute == nsGkAtoms::maxlength) {
39006:       return aResult.ParseNonNegativeIntValue(aValue);
    1:     }
    1:     if (aAttribute == nsGkAtoms::size) {
56994:       return aResult.ParsePositiveIntValue(aValue);
    1:     }
    1:     if (aAttribute == nsGkAtoms::border) {
    1:       return aResult.ParseIntWithBounds(aValue, 0);
    1:     }
    1:     if (aAttribute == nsGkAtoms::align) {
    1:       return ParseAlignValue(aValue, aResult);
    1:     }
51137:     if (aAttribute == nsGkAtoms::formmethod) {
51137:       return aResult.ParseEnumValue(aValue, kFormMethodTable, PR_FALSE);
51137:     }
51137:     if (aAttribute == nsGkAtoms::formenctype) {
51137:       return aResult.ParseEnumValue(aValue, kFormEnctypeTable, PR_FALSE);
51137:     }
53804:     if (aAttribute == nsGkAtoms::autocomplete) {
53804:       return aResult.ParseEnumValue(aValue, kInputAutocompleteTable, PR_FALSE);
53804:     }
    1:     if (ParseImageAttribute(aAttribute, aValue, aResult)) {
    1:       // We have to call |ParseImageAttribute| unconditionally since we
    1:       // don't know if we're going to have a type="image" attribute yet,
    1:       // (or could have it set dynamically in the future).  See bug
    1:       // 214077.
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
    1:                                               aResult);
    1: }
    1: 
    1: static void
    1: MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
    1:                       nsRuleData* aData)
    1: {
    1:   const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::type);
    1:   if (value && value->Type() == nsAttrValue::eEnum &&
    1:       value->GetEnumValue() == NS_FORM_INPUT_IMAGE) {
    1:     nsGenericHTMLFormElement::MapImageBorderAttributeInto(aAttributes, aData);
    1:     nsGenericHTMLFormElement::MapImageMarginAttributeInto(aAttributes, aData);
    1:     nsGenericHTMLFormElement::MapImageSizeAttributesInto(aAttributes, aData);
    1:     // Images treat align as "float"
    1:     nsGenericHTMLFormElement::MapImageAlignAttributeInto(aAttributes, aData);
    1:   } 
    1: 
    1:   nsGenericHTMLFormElement::MapCommonAttributesInto(aAttributes, aData);
    1: }
    1: 
    1: nsChangeHint
    1: nsHTMLInputElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                            PRInt32 aModType) const
    1: {
    1:   nsChangeHint retval =
    1:     nsGenericHTMLFormElement::GetAttributeChangeHint(aAttribute, aModType);
    1:   if (aAttribute == nsGkAtoms::type) {
    1:     NS_UpdateHint(retval, NS_STYLE_HINT_FRAMECHANGE);
 9489:   } else if (mType == NS_FORM_INPUT_IMAGE &&
 9489:              (aAttribute == nsGkAtoms::alt ||
 9489:               aAttribute == nsGkAtoms::value)) {
 9489:     // We might need to rebuild our alt text.  Just go ahead and
 9489:     // reconstruct our frame.  This should be quite rare..
 9489:     NS_UpdateHint(retval, NS_STYLE_HINT_FRAMECHANGE);
    1:   } else if (aAttribute == nsGkAtoms::value) {
    1:     NS_UpdateHint(retval, NS_STYLE_HINT_REFLOW);
    1:   } else if (aAttribute == nsGkAtoms::size &&
42192:              IsSingleLineTextControl(PR_FALSE)) {
    1:     NS_UpdateHint(retval, NS_STYLE_HINT_REFLOW);
56086:   } else if (PlaceholderApplies() && aAttribute == nsGkAtoms::placeholder) {
56086:     NS_UpdateHint(retval, NS_STYLE_HINT_FRAMECHANGE);
    1:   }
    1:   return retval;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsHTMLInputElement::IsAttributeMapped(const nsIAtom* aAttribute) const
    1: {
    1:   static const MappedAttributeEntry attributes[] = {
    1:     { &nsGkAtoms::align },
    1:     { &nsGkAtoms::type },
    1:     { nsnull },
    1:   };
    1: 
    1:   static const MappedAttributeEntry* const map[] = {
    1:     attributes,
    1:     sCommonAttributeMap,
    1:     sImageMarginSizeAttributeMap,
    1:     sImageBorderAttributeMap,
    1:   };
    1: 
    1:   return FindAttributeDependence(aAttribute, map, NS_ARRAY_LENGTH(map));
    1: }
    1: 
    1: nsMapRuleToAttributesFunc
    1: nsHTMLInputElement::GetAttributeMappingFunction() const
    1: {
    1:   return &MapAttributesIntoRule;
    1: }
    1: 
    1: 
    1: // Controllers Methods
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::GetControllers(nsIControllers** aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1: 
    1:   //XXX: what about type "file"?
42192:   if (IsSingleLineTextControl(PR_FALSE))
    1:   {
    1:     if (!mControllers)
    1:     {
    1:       nsresult rv;
    1:       mControllers = do_CreateInstance(kXULControllersCID, &rv);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       nsCOMPtr<nsIController>
    1:         controller(do_CreateInstance("@mozilla.org/editor/editorcontroller;1",
    1:                                      &rv));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       mControllers->AppendController(controller);
    1:     }
    1:   }
    1: 
    1:   *aResult = mControllers;
    1:   NS_IF_ADDREF(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::GetTextLength(PRInt32* aTextLength)
    1: {
    1:   nsAutoString val;
    1: 
    1:   nsresult rv = GetValue(val);
    1: 
    1:   *aTextLength = val.Length();
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::SetSelectionRange(PRInt32 aSelectionStart,
    1:                                       PRInt32 aSelectionEnd)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
    1: 
    1:   if (formControlFrame) {
23554:     nsITextControlFrame* textControlFrame = do_QueryFrame(formControlFrame);
    1:     if (textControlFrame)
    1:       rv = textControlFrame->SetSelectionRange(aSelectionStart, aSelectionEnd);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::GetSelectionStart(PRInt32* aSelectionStart)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aSelectionStart);
    1:   
    1:   PRInt32 selEnd;
    1:   return GetSelectionRange(aSelectionStart, &selEnd);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::SetSelectionStart(PRInt32 aSelectionStart)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
    1: 
    1:   if (formControlFrame) {
23554:     nsITextControlFrame* textControlFrame = do_QueryFrame(formControlFrame);
    1:     if (textControlFrame)
    1:       rv = textControlFrame->SetSelectionStart(aSelectionStart);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::GetSelectionEnd(PRInt32* aSelectionEnd)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aSelectionEnd);
    1:   
    1:   PRInt32 selStart;
    1:   return GetSelectionRange(&selStart, aSelectionEnd);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::SetSelectionEnd(PRInt32 aSelectionEnd)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
    1: 
    1:   if (formControlFrame) {
23554:     nsITextControlFrame* textControlFrame = do_QueryFrame(formControlFrame);
    1:     if (textControlFrame)
    1:       rv = textControlFrame->SetSelectionEnd(aSelectionEnd);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
 3940: NS_IMETHODIMP
 8965: nsHTMLInputElement::GetFiles(nsIDOMFileList** aFileList)
 3940: {
 3940:   *aFileList = nsnull;
 3940: 
 3940:   if (mType != NS_FORM_INPUT_FILE) {
 3940:     return NS_OK;
 3940:   }
 3940: 
 3940:   if (!mFileList) {
 3940:     mFileList = new nsDOMFileList();
 3940:     if (!mFileList) return NS_ERROR_OUT_OF_MEMORY;
 3940: 
 3940:     UpdateFileList();
 3940:   }
 3940: 
 3940:   NS_ADDREF(*aFileList = mFileList);
 3940: 
 3940:   return NS_OK;
 3940: }
 3940: 
    1: nsresult
    1: nsHTMLInputElement::GetSelectionRange(PRInt32* aSelectionStart,
    1:                                       PRInt32* aSelectionEnd)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
    1: 
    1:   if (formControlFrame) {
23554:     nsITextControlFrame* textControlFrame = do_QueryFrame(formControlFrame);
    1:     if (textControlFrame)
    1:       rv = textControlFrame->GetSelectionRange(aSelectionStart, aSelectionEnd);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::GetPhonetic(nsAString& aPhonetic)
    1: {
    1:   aPhonetic.Truncate(0);
    1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
    1: 
    1:   if (formControlFrame) {
23554:     nsITextControlFrame* textControlFrame = do_QueryFrame(formControlFrame);
20884:     if (textControlFrame)
20884:       textControlFrame->GetPhonetic(aPhonetic);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef ACCESSIBILITY
    1: /*static*/ nsresult
    1: FireEventForAccessibility(nsIDOMHTMLInputElement* aTarget,
    1:                           nsPresContext* aPresContext,
    1:                           const nsAString& aEventType)
    1: {
    1:   nsCOMPtr<nsIDOMEvent> event;
    1:   if (NS_SUCCEEDED(nsEventDispatcher::CreateEvent(aPresContext, nsnull,
    1:                                                   NS_LITERAL_STRING("Events"),
    1:                                                   getter_AddRefs(event)))) {
    1:     event->InitEvent(aEventType, PR_TRUE, PR_TRUE);
    1: 
    1:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
    1:     if (privateEvent) {
    1:       privateEvent->SetTrusted(PR_TRUE);
    1:     }
    1: 
    1:     nsEventDispatcher::DispatchDOMEvent(aTarget, nsnull, event, aPresContext, nsnull);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
48079: nsresult
48079: nsHTMLInputElement::SetDefaultValueAsValue()
    1: {
52196:   NS_ASSERTION(GetValueMode() == VALUE_MODE_VALUE,
52196:                "GetValueMode() should return VALUE_MODE_VALUE!");
52196: 
52196:   // The element has a content attribute value different from it's value when
52196:   // it's in the value mode value.
52196:   nsAutoString resetVal;
52196:   GetDefaultValue(resetVal);
52196: 
52196:   // SetValueInternal is going to sanitize the value.
52196:   return SetValueInternal(resetVal, PR_FALSE, PR_FALSE);
52196: }
52196: 
52196: NS_IMETHODIMP
52196: nsHTMLInputElement::Reset()
    1: {
52196:   // We should be able to reset all dirty flags regardless of the type.
52196:   SetCheckedChanged(PR_FALSE);
52196:   SetValueChanged(PR_FALSE);
52196: 
52196:   switch (GetValueMode()) {
52196:     case VALUE_MODE_VALUE:
52196:       return SetDefaultValueAsValue();
52196:     case VALUE_MODE_DEFAULT_ON:
    1:       PRBool resetVal;
    1:       GetDefaultChecked(&resetVal);
48085:       return DoSetChecked(resetVal, PR_TRUE, PR_FALSE);
52196:     case VALUE_MODE_FILENAME:
52042:       ClearFiles();
52196:       return NS_OK;
52196:     case VALUE_MODE_DEFAULT:
    1:     default:
48079:       return NS_OK;
48079:   }
    1: }
    1: 
    1: NS_IMETHODIMP
50990: nsHTMLInputElement::SubmitNamesValues(nsFormSubmission* aFormSubmission)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   // Disabled elements don't submit
38672:   // For type=reset, and type=button, we just never submit, period.
38672:   // For type=image and type=button, we only submit if we were the button
38672:   // pressed
38672:   // For type=radio and type=checkbox, we only submit if checked=true
54342:   if (IsDisabled() || mType == NS_FORM_INPUT_RESET ||
38672:       mType == NS_FORM_INPUT_BUTTON ||
38672:       ((mType == NS_FORM_INPUT_SUBMIT || mType == NS_FORM_INPUT_IMAGE) &&
50990:        aFormSubmission->GetOriginatingElement() != this) ||
38672:       ((mType == NS_FORM_INPUT_RADIO || mType == NS_FORM_INPUT_CHECKBOX) &&
38672:        !GetChecked())) {
38672:     return NS_OK;
38672:   }
38672: 
    1:   // Get the name
    1:   nsAutoString name;
    1:   PRBool nameThere = GetNameIfExists(name);
    1: 
    1:   // Submit .x, .y for input type=image
    1:   if (mType == NS_FORM_INPUT_IMAGE) {
    1:     // Get a property set by the frame to find out where it was clicked.
    1:     nsIntPoint* lastClickedPoint =
 3233:       static_cast<nsIntPoint*>(GetProperty(nsGkAtoms::imageClickedPoint));
21208:     PRInt32 x, y;
    1:     if (lastClickedPoint) {
    1:       // Convert the values to strings for submission
21208:       x = lastClickedPoint->x;
21208:       y = lastClickedPoint->y;
21208:     } else {
21208:       x = y = 0;
21208:     }
21208: 
21208:     nsAutoString xVal, yVal;
21208:     xVal.AppendInt(x);
21208:     yVal.AppendInt(y);
    1: 
    1:     if (!name.IsEmpty()) {
38672:       aFormSubmission->AddNameValuePair(name + NS_LITERAL_STRING(".x"), xVal);
38672:       aFormSubmission->AddNameValuePair(name + NS_LITERAL_STRING(".y"), yVal);
    1:     } else {
    1:       // If the Image Element has no name, simply return x and y
    1:       // to Nav and IE compatibility.
38672:       aFormSubmission->AddNameValuePair(NS_LITERAL_STRING("x"), xVal);
38672:       aFormSubmission->AddNameValuePair(NS_LITERAL_STRING("y"), yVal);
    1:     }
38671: 
38671:     return NS_OK;
    1:   }
    1: 
    1:   //
    1:   // Submit name=value
    1:   //
    1: 
    1:   // If name not there, don't submit
    1:   if (!nameThere) {
38672:     return NS_OK;
    1:   }
    1: 
    1:   // Get the value
    1:   nsAutoString value;
    1:   rv = GetValue(value);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   if (mType == NS_FORM_INPUT_SUBMIT && value.IsEmpty() &&
    1:       !HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
    1:     // Get our default value, which is the same as our default label
    1:     nsXPIDLString defaultValue;
    1:     nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
    1:                                        "Submit", defaultValue);
    1:     value = defaultValue;
    1:   }
    1:       
    1:   //
24112:   // Submit file if its input type=file and this encoding method accepts files
    1:   //
    1:   if (mType == NS_FORM_INPUT_FILE) {
34164:     // Submit files
34164: 
52042:     const nsCOMArray<nsIDOMFile>& files = GetFiles();
34164: 
34164:     for (PRUint32 i = 0; i < (PRUint32)files.Count(); ++i) {
38672:       aFormSubmission->AddNameFilePair(name, files[i]);
34164:     }
34164: 
35147:     if (files.Count() == 0) {
35147:       // If no file was selected, pretend we had an empty file with an
35147:       // empty filename.
38672:       aFormSubmission->AddNameFilePair(name, nsnull);
35147: 
35147:     }
35147: 
34164:     return NS_OK;
    1:   }
    1: 
38672:   if (mType == NS_FORM_INPUT_HIDDEN && name.EqualsLiteral("_charset_")) {
38672:     nsCString charset;
38672:     aFormSubmission->GetCharset(charset);
38672:     rv = aFormSubmission->AddNameValuePair(name,
38672:                                            NS_ConvertASCIItoUTF16(charset));
38672:   }
42192:   else if (IsSingleLineTextControl(PR_TRUE) &&
39451:            name.EqualsLiteral("isindex") &&
39451:            aFormSubmission->SupportsIsindexSubmission()) {
39451:     rv = aFormSubmission->AddIsindex(value);
39451:   }
39451:   else {
38672:     rv = aFormSubmission->AddNameValuePair(name, value);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLInputElement::SaveState()
    1: {
    1:   nsresult rv = NS_OK;
    1: 
22740:   nsRefPtr<nsHTMLInputElementState> inputState = nsnull;
22740: 
    1:   switch (mType) {
    1:     case NS_FORM_INPUT_CHECKBOX:
    1:     case NS_FORM_INPUT_RADIO:
    1:       {
38672:         PRBool checked = GetChecked();
    1:         PRBool defaultChecked = PR_FALSE;
    1:         GetDefaultChecked(&defaultChecked);
    1:         // Only save if checked != defaultChecked (bug 62713)
    1:         // (always save if it's a radio button so that the checked
    1:         // state of all radio buttons is restored)
    1:         if (mType == NS_FORM_INPUT_RADIO || checked != defaultChecked) {
22740:           inputState = new nsHTMLInputElementState();
22740:           if (!inputState) {
22740:             return NS_ERROR_OUT_OF_MEMORY;
22740:           }
22740: 
22740:           inputState->SetChecked(checked);
    1:         }
    1:         break;
    1:       }
    1: 
    1:     // Never save passwords in session history
    1:     case NS_FORM_INPUT_PASSWORD:
    1:       break;
50907:     case NS_FORM_INPUT_EMAIL:
42372:     case NS_FORM_INPUT_SEARCH:
    1:     case NS_FORM_INPUT_TEXT:
42192:     case NS_FORM_INPUT_TEL:
50909:     case NS_FORM_INPUT_URL:
    1:     case NS_FORM_INPUT_HIDDEN:
    1:       {
    1:         if (GET_BOOLBIT(mBitField, BF_VALUE_CHANGED)) {
22740:           inputState = new nsHTMLInputElementState();
22740:           if (!inputState) {
22740:             return NS_ERROR_OUT_OF_MEMORY;
22740:           }
22740: 
    1:           nsAutoString value;
    1:           GetValue(value);
    1:           rv = nsLinebreakConverter::ConvertStringLineBreaks(
    1:                  value,
    1:                  nsLinebreakConverter::eLinebreakPlatform,
    1:                  nsLinebreakConverter::eLinebreakContent);
    1:           NS_ASSERTION(NS_SUCCEEDED(rv), "Converting linebreaks failed!");
22740:           inputState->SetValue(value);
    1:        }
    1:       break;
    1:     }
    1:     case NS_FORM_INPUT_FILE:
    1:       {
52042:         if (mFiles.Count()) {
22740:           inputState = new nsHTMLInputElementState();
22740:           if (!inputState) {
22740:             return NS_ERROR_OUT_OF_MEMORY;
22740:           }
22740: 
52042:           inputState->SetFiles(mFiles);
22740:         }
22740:         break;
22740:       }
22740:   }
22740:   
22740:   nsPresState* state = nsnull;
22740:   if (inputState) {
    1:     rv = GetPrimaryPresState(this, &state);
    1:     if (state) {
22740:       state->SetStateProperty(inputState);
    1:     }
    1:   }
    1: 
    1:   if (GET_BOOLBIT(mBitField, BF_DISABLED_CHANGED)) {
    1:     rv |= GetPrimaryPresState(this, &state);
    1:     if (state) {
54342:       // We do not want to save the real disabled state but the disabled
54342:       // attribute.
54342:       state->SetDisabled(HasAttr(kNameSpaceID_None, nsGkAtoms::disabled));
 6781:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsHTMLInputElement::DoneCreatingElement()
    1: {
    1:   SET_BOOLBIT(mBitField, BF_PARSER_CREATING, PR_FALSE);
    1: 
    1:   //
    1:   // Restore state as needed.  Note that disabled state applies to all control
    1:   // types.
    1:   //
43829:   PRBool restoredCheckedState =
43829:       GET_BOOLBIT(mBitField, BF_INHIBIT_RESTORATION) ?
43829:       PR_FALSE :
43829:       RestoreFormControlState(this, this);
    1: 
    1:   //
    1:   // If restore does not occur, we initialize .checked using the CHECKED
    1:   // property.
    1:   //
    1:   if (!restoredCheckedState &&
    1:       GET_BOOLBIT(mBitField, BF_SHOULD_INIT_CHECKED)) {
    1:     PRBool resetVal;
    1:     GetDefaultChecked(&resetVal);
48085:     DoSetChecked(resetVal, PR_FALSE, PR_TRUE);
    1:     DoSetCheckedChanged(PR_FALSE, PR_FALSE);
    1:   }
    1: 
54366:   // Sanitize the value.
54366:   if (GetValueMode() == VALUE_MODE_VALUE) {
54366:     nsAutoString aValue;
54366:     GetValue(aValue);
54366:     SetValueInternal(aValue, PR_FALSE, PR_FALSE);
54366:   }
54366: 
    1:   SET_BOOLBIT(mBitField, BF_SHOULD_INIT_CHECKED, PR_FALSE);
    1: }
    1: 
56168: nsEventStates
    1: nsHTMLInputElement::IntrinsicState() const
    1: {
    1:   // If you add states here, and they're type-dependent, you need to add them
    1:   // to the type case in AfterSetAttr.
    1:   
56168:   nsEventStates state = nsGenericHTMLFormElement::IntrinsicState();
    1:   if (mType == NS_FORM_INPUT_CHECKBOX || mType == NS_FORM_INPUT_RADIO) {
    1:     // Check current checked state (:checked)
    1:     if (GET_BOOLBIT(mBitField, BF_CHECKED)) {
    1:       state |= NS_EVENT_STATE_CHECKED;
    1:     }
    1: 
24916:     // Check current indeterminate state (:indeterminate)
24916:     if (mType == NS_FORM_INPUT_CHECKBOX && GET_BOOLBIT(mBitField, BF_INDETERMINATE)) {
24916:       state |= NS_EVENT_STATE_INDETERMINATE;
24916:     }
24916: 
    1:     // Check whether we are the default checked element (:default)
    1:     // The call is to an interface function, which makes it non-const, so we
    1:     // use a nasty hack :(
    1:     PRBool defaultState = PR_FALSE;
 3233:     const_cast<nsHTMLInputElement*>(this)->GetDefaultChecked(&defaultState);
    1:     if (defaultState) {
    1:       state |= NS_EVENT_STATE_DEFAULT;
    1:     }
    1:   } else if (mType == NS_FORM_INPUT_IMAGE) {
    1:     state |= nsImageLoadingContent::ImageState();
    1:   }
    1: 
50912:   if (DoesRequiredApply() && HasAttr(kNameSpaceID_None, nsGkAtoms::required)) {
50912:     state |= NS_EVENT_STATE_REQUIRED;
50912:   } else {
50912:     state |= NS_EVENT_STATE_OPTIONAL;
50912:   }
50912: 
51181:   if (IsCandidateForConstraintValidation()) {
51178:     state |= IsValid() ? NS_EVENT_STATE_VALID : NS_EVENT_STATE_INVALID;
51178:   }
51178: 
51388:   if (PlaceholderApplies() && HasAttr(kNameSpaceID_None, nsGkAtoms::placeholder) &&
51388:       !nsContentUtils::IsFocusedContent((nsIContent*)(this))) {
51388:     // TODO: we really need a GetValue(...) const method, see bug 585097
51388:     nsTextEditorState* edState = GetEditorState();
51388:     nsAutoString value;
51388: 
51388:     if (edState) {
51388:       edState->GetValue(value, PR_TRUE);
51388:     } else {
51388:       GetAttr(kNameSpaceID_None, nsGkAtoms::value, value);
51388:     }
51388: 
51388:     if (value.IsEmpty()) {
51388:       state |= NS_EVENT_STATE_MOZ_PLACEHOLDER;
51388:     }
51388:   }
51388: 
52361:   if (mForm && !mForm->GetValidity() && IsSubmitControl()) {
52361:     state |= NS_EVENT_STATE_MOZ_SUBMITINVALID;
52361:   }
52361: 
    1:   return state;
    1: }
    1: 
    1: PRBool
    1: nsHTMLInputElement::RestoreState(nsPresState* aState)
    1: {
    1:   PRBool restoredCheckedState = PR_FALSE;
    1: 
22740:   nsCOMPtr<nsHTMLInputElementState> inputState
22740:     (do_QueryInterface(aState->GetStateProperty()));
22740: 
22740:   if (inputState) {
    1:     switch (mType) {
    1:       case NS_FORM_INPUT_CHECKBOX:
    1:       case NS_FORM_INPUT_RADIO:
    1:         {
22740:           if (inputState->IsCheckedSet()) {
    1:             restoredCheckedState = PR_TRUE;
48085:             DoSetChecked(inputState->GetChecked(), PR_TRUE, PR_TRUE);
    1:           }
    1:           break;
    1:         }
    1: 
50907:       case NS_FORM_INPUT_EMAIL:
42372:       case NS_FORM_INPUT_SEARCH:
    1:       case NS_FORM_INPUT_TEXT:
42192:       case NS_FORM_INPUT_TEL:
50909:       case NS_FORM_INPUT_URL:
    1:       case NS_FORM_INPUT_HIDDEN:
    1:         {
48080:           SetValueInternal(inputState->GetValue(), PR_FALSE, PR_TRUE);
    1:           break;
    1:         }
    1:       case NS_FORM_INPUT_FILE:
    1:         {
52042:           const nsCOMArray<nsIDOMFile>& files = inputState->GetFiles();
52042:           SetFiles(files);
    1:           break;
    1:         }
    1:     }
22740:   }
22740: 
22740:   if (aState->IsDisabledSet()) {
22740:     SetDisabled(aState->GetDisabled());
    1:   }
    1: 
    1:   return restoredCheckedState;
    1: }
    1: 
    1: PRBool
    1: nsHTMLInputElement::AllowDrop()
    1: {
    1:   // Allow drop on anything other than file inputs.
    1: 
    1:   return mType != NS_FORM_INPUT_FILE;
    1: }
    1: 
    1: /*
    1:  * Radio group stuff
    1:  */
    1: 
47648: void
    1: nsHTMLInputElement::AddedToRadioGroup(PRBool aNotify)
    1: {
    1:   // Make sure not to notify if we're still being created by the parser
    1:   aNotify = aNotify && !GET_BOOLBIT(mBitField, BF_PARSER_CREATING);
    1: 
    1:   //
    1:   //  If the input element is not in a form and
    1:   //  not in a document, we just need to return.
    1:   //
    1:   if (!mForm && !(IsInDoc() && GetParent())) {
47648:     return;
    1:   }
    1: 
    1:   //
    1:   // If the input element is checked, and we add it to the group, it will
    1:   // deselect whatever is currently selected in that group
    1:   //
38672:   if (GetChecked()) {
    1:     //
    1:     // If it is checked, call "RadioSetChecked" to perform the selection/
    1:     // deselection ritual.  This has the side effect of repainting the
    1:     // radio button, but as adding a checked radio button into the group
    1:     // should not be that common an occurrence, I think we can live with
    1:     // that.
    1:     //
    1:     RadioSetChecked(aNotify);
    1:   }
    1: 
    1:   //
    1:   // For integrity purposes, we have to ensure that "checkedChanged" is
    1:   // the same for this new element as for all the others in the group
    1:   //
16190:   PRBool checkedChanged = GET_BOOLBIT(mBitField, BF_CHECKED_CHANGED);
    1:   nsCOMPtr<nsIRadioVisitor> visitor;
    1:   nsresult rv = NS_GetRadioGetCheckedChangedVisitor(&checkedChanged, this,
    1:                                            getter_AddRefs(visitor));
47648:   if (NS_FAILED(rv)) { return; }
    1:   
    1:   VisitGroup(visitor, aNotify);
    1:   SetCheckedChangedInternal(checkedChanged);
    1:   
    1:   //
    1:   // Add the radio to the radio group container.
    1:   //
    1:   nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
    1:   if (container) {
    1:     nsAutoString name;
    1:     if (GetNameIfExists(name)) {
 3233:       container->AddToRadioGroup(name, static_cast<nsIFormControl*>(this));
    1:     }
    1:   }
47648: }
47648: 
47648: void
51178: nsHTMLInputElement::WillRemoveFromRadioGroup(PRBool aNotify)
    1: {
    1:   //
    1:   // If the input element is not in a form and
    1:   // not in a document, we just need to return.
    1:   //
    1:   if (!mForm && !(IsInDoc() && GetParent())) {
47648:     return;
    1:   }
    1: 
    1:   //
    1:   // If this button was checked, we need to notify the group that there is no
    1:   // longer a selected radio button
    1:   //
    1:   nsAutoString name;
    1:   PRBool gotName = PR_FALSE;
38672:   if (GetChecked()) {
    1:     if (!gotName) {
    1:       if (!GetNameIfExists(name)) {
    1:         // If the name doesn't exist, nothing is going to happen anyway
47648:         return;
    1:       }
    1:       gotName = PR_TRUE;
    1:     }
    1: 
    1:     nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
    1:     if (container) {
    1:       container->SetCurrentRadioButton(name, nsnull);
    1:     }
51178: 
51178:     // Removing a checked radio from the group can change the validity state.
51178:     // Let's ask other radio to update their value missing validity state.
51178:     nsCOMPtr<nsIRadioVisitor> visitor =
51178:       NS_GetRadioUpdateValueMissingVisitor(aNotify);
51178:     VisitGroup(visitor, PR_FALSE);
    1:   }
    1:   
    1:   //
    1:   // Remove this radio from its group in the container
    1:   //
    1:   nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
    1:   if (container) {
    1:     if (!gotName) {
    1:       if (!GetNameIfExists(name)) {
    1:         // If the name doesn't exist, nothing is going to happen anyway
47648:         return;
    1:       }
    1:       gotName = PR_TRUE;
    1:     }
    1:     container->RemoveFromRadioGroup(name,
 3233:                                     static_cast<nsIFormControl*>(this));
    1:   }
    1: }
    1: 
    1: PRBool
43884: nsHTMLInputElement::IsHTMLFocusable(PRBool aWithMouse, PRBool *aIsFocusable, PRInt32 *aTabIndex)
    1: {
43884:   if (nsGenericHTMLElement::IsHTMLFocusable(aWithMouse, aIsFocusable, aTabIndex)) {
14348:     return PR_TRUE;
14348:   }
14348: 
54342:   if (IsDisabled()) {
29018:     *aIsFocusable = PR_FALSE;
29018:     return PR_TRUE;
29018:   }
29018: 
42192:   if (IsSingleLineTextControl(PR_FALSE)) {
14348:     *aIsFocusable = PR_TRUE;
    1:     return PR_FALSE;
    1:   }
    1: 
43884: #ifdef XP_MACOSX
49216:   const PRBool defaultFocusable = !aWithMouse || nsFocusManager::sMouseFocusesFormControl;
43884: #else
43884:   const PRBool defaultFocusable = PR_TRUE;
43884: #endif
43884: 
29018:   if (mType == NS_FORM_INPUT_FILE) {
29018:     if (aTabIndex) {
29018:       *aTabIndex = -1;
29018:     }
43884:     *aIsFocusable = defaultFocusable;
29018:     return PR_TRUE;
29018:   }
29018: 
29018:   if (mType == NS_FORM_INPUT_HIDDEN) {
    1:     if (aTabIndex) {
    1:       *aTabIndex = -1;
    1:     }
14348:     *aIsFocusable = PR_FALSE;
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   if (!aTabIndex) {
    1:     // The other controls are all focusable
43884:     *aIsFocusable = defaultFocusable;
14348:     return PR_FALSE;
    1:   }
    1: 
    1:   if (mType != NS_FORM_INPUT_RADIO) {
43884:     *aIsFocusable = defaultFocusable;
14348:     return PR_FALSE;
    1:   }
    1: 
38672:   if (GetChecked()) {
    1:     // Selected radio buttons are tabbable
43884:     *aIsFocusable = defaultFocusable;
14348:     return PR_FALSE;
    1:   }
    1: 
    1:   // Current radio button is not selected.
    1:   // But make it tabbable if nothing in group is selected.
    1:   nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
    1:   nsAutoString name;
    1:   if (!container || !GetNameIfExists(name)) {
43884:     *aIsFocusable = defaultFocusable;
14348:     return PR_FALSE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMHTMLInputElement> currentRadio;
    1:   container->GetCurrentRadioButton(name, getter_AddRefs(currentRadio));
    1:   if (currentRadio) {
    1:     *aTabIndex = -1;
    1:   }
43884:   *aIsFocusable = defaultFocusable;
14348:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsHTMLInputElement::VisitGroup(nsIRadioVisitor* aVisitor, PRBool aFlushContent)
    1: {
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
    1:   if (container) {
    1:     nsAutoString name;
    1:     if (GetNameIfExists(name)) {
    1:       rv = container->WalkRadioGroup(name, aVisitor, aFlushContent);
    1:     } else {
    1:       PRBool stop;
    1:       aVisitor->Visit(this, &stop);
    1:     }
    1:   } else {
    1:     PRBool stop;
    1:     aVisitor->Visit(this, &stop);
    1:   }
    1:   return rv;
    1: }
    1: 
50906: nsHTMLInputElement::ValueModeType
50906: nsHTMLInputElement::GetValueMode() const
50906: {
50906:   switch (mType)
50906:   {
50906:     case NS_FORM_INPUT_HIDDEN:
50906:     case NS_FORM_INPUT_SUBMIT:
50906:     case NS_FORM_INPUT_BUTTON:
50906:     case NS_FORM_INPUT_RESET:
50906:     case NS_FORM_INPUT_IMAGE:
50906:       return VALUE_MODE_DEFAULT;
50906:     case NS_FORM_INPUT_CHECKBOX:
50906:     case NS_FORM_INPUT_RADIO:
50906:       return VALUE_MODE_DEFAULT_ON;
50906:     case NS_FORM_INPUT_FILE:
50906:       return VALUE_MODE_FILENAME;
50906: #ifdef DEBUG
50906:     case NS_FORM_INPUT_TEXT:
50906:     case NS_FORM_INPUT_PASSWORD:
50906:     case NS_FORM_INPUT_SEARCH:
50906:     case NS_FORM_INPUT_TEL:
50907:     case NS_FORM_INPUT_EMAIL:
50909:     case NS_FORM_INPUT_URL:
50906:       return VALUE_MODE_VALUE;
50906:     default:
50906:       NS_NOTYETIMPLEMENTED("Unexpected input type in GetValueMode()");
50906:       return VALUE_MODE_VALUE;
50906: #else // DEBUG
50906:     default:
50906:       return VALUE_MODE_VALUE;
50906: #endif // DEBUG
50906:   }
50906: }
50906: 
50906: PRBool
50906: nsHTMLInputElement::IsMutable() const
50906: {
54342:   return !IsDisabled() && GetCurrentDoc() &&
50906:          !(DoesReadOnlyApply() &&
50906:            HasAttr(kNameSpaceID_None, nsGkAtoms::readonly));
50906: }
50906: 
50906: PRBool
50906: nsHTMLInputElement::DoesReadOnlyApply() const
50906: {
50906:   switch (mType)
50906:   {
50906:     case NS_FORM_INPUT_HIDDEN:
50906:     case NS_FORM_INPUT_BUTTON:
50906:     case NS_FORM_INPUT_IMAGE:
50906:     case NS_FORM_INPUT_RESET:
50906:     case NS_FORM_INPUT_SUBMIT:
50906:     case NS_FORM_INPUT_RADIO:
50906:     case NS_FORM_INPUT_FILE:
50906:     case NS_FORM_INPUT_CHECKBOX:
50906:     // TODO:
50906:     // case NS_FORM_INPUT_COLOR:
50906:     // case NS_FORM_INPUT_RANGE:
50906:       return PR_FALSE;
50906: #ifdef DEBUG
50906:     case NS_FORM_INPUT_TEXT:
50906:     case NS_FORM_INPUT_PASSWORD:
50906:     case NS_FORM_INPUT_SEARCH:
50906:     case NS_FORM_INPUT_TEL:
50907:     case NS_FORM_INPUT_EMAIL:
50909:     case NS_FORM_INPUT_URL:
50906:       return PR_TRUE;
50906:     default:
50906:       NS_NOTYETIMPLEMENTED("Unexpected input type in DoesReadOnlyApply()");
50906:       return PR_TRUE;
50906: #else // DEBUG
50906:     default:
50906:       return PR_TRUE;
50906: #endif // DEBUG
50906:   }
50906: }
50906: 
50906: PRBool
50906: nsHTMLInputElement::DoesRequiredApply() const
50906: {
50906:   switch (mType)
50906:   {
50906:     case NS_FORM_INPUT_HIDDEN:
50906:     case NS_FORM_INPUT_BUTTON:
50906:     case NS_FORM_INPUT_IMAGE:
50906:     case NS_FORM_INPUT_RESET:
50906:     case NS_FORM_INPUT_SUBMIT:
50906:     // TODO:
50906:     // case NS_FORM_INPUT_COLOR:
50906:     // case NS_FORM_INPUT_RANGE:
50906:       return PR_FALSE;
50906: #ifdef DEBUG
50906:     case NS_FORM_INPUT_RADIO:
50906:     case NS_FORM_INPUT_CHECKBOX:
50906:     case NS_FORM_INPUT_FILE:
50906:     case NS_FORM_INPUT_TEXT:
50906:     case NS_FORM_INPUT_PASSWORD:
50906:     case NS_FORM_INPUT_SEARCH:
50906:     case NS_FORM_INPUT_TEL:
50907:     case NS_FORM_INPUT_EMAIL:
50909:     case NS_FORM_INPUT_URL:
50906:       return PR_TRUE;
50906:     default:
50906:       NS_NOTYETIMPLEMENTED("Unexpected input type in DoesRequiredApply()");
50906:       return PR_TRUE;
50906: #else // DEBUG
50906:     default:
50906:       return PR_TRUE;
50906: #endif // DEBUG
50906:   }
50906: }
50906: 
50911: PRBool
50911: nsHTMLInputElement::DoesPatternApply() const
50911: {
50911:   return IsSingleLineTextControl(PR_FALSE);
50911: }
50911: 
51182: // nsIConstraintValidation
50904: 
51178: NS_IMETHODIMP
51178: nsHTMLInputElement::SetCustomValidity(const nsAString& aError)
51178: {
51182:   nsIConstraintValidation::SetCustomValidity(aError);
51178: 
51178:   nsIDocument* doc = GetCurrentDoc();
51178:   if (doc) {
52197:     MOZ_AUTO_DOC_UPDATE(doc, UPDATE_CONTENT_STATE, PR_TRUE);
51178:     doc->ContentStatesChanged(this, nsnull, NS_EVENT_STATE_INVALID |
51178:                                             NS_EVENT_STATE_VALID);
51178:   }
51178: 
51181:   return NS_OK;
51178: }
51178: 
50904: PRBool
50904: nsHTMLInputElement::IsTooLong()
50904: {
55101:   if (!MaxLengthApplies() ||
55101:       !HasAttr(kNameSpaceID_None, nsGkAtoms::maxlength) ||
55100:       !GET_BOOLBIT(mBitField, BF_VALUE_CHANGED)) {
50905:     return PR_FALSE;
50905:   }
50905: 
50904:   PRInt32 maxLength = -1;
55100:   GetMaxLength(&maxLength);
55100: 
55100:   // Maxlength of -1 means parsing error.
55100:   if (maxLength == -1) {
55100:     return PR_FALSE;
55100:   }
55100: 
50904:   PRInt32 textLength = -1;
50904:   GetTextLength(&textLength);
50904: 
55100:   return textLength > maxLength;
50904: }
50904: 
50904: PRBool
50906: nsHTMLInputElement::IsValueMissing()
50906: {
50906:   if (!HasAttr(kNameSpaceID_None, nsGkAtoms::required) ||
50906:       !DoesRequiredApply()) {
50906:     return PR_FALSE;
50906:   }
50906: 
50906:   if (GetValueMode() == VALUE_MODE_VALUE) {
50906:     if (!IsMutable()) {
50906:       return PR_FALSE;
50906:     }
50906: 
50906:     nsAutoString value;
51178:     NS_ENSURE_SUCCESS(GetValue(value), PR_FALSE);
50906: 
50906:     return value.IsEmpty();
50906:   }
50906: 
51178:   switch (mType)
51178:   {
51178:     case NS_FORM_INPUT_CHECKBOX:
50906:       return !GetChecked();
51178:     case NS_FORM_INPUT_RADIO:
51178:       {
50906:         nsCOMPtr<nsIDOMHTMLInputElement> selected = GetSelectedRadioButton();
50906:         return !selected;
50906:       }
51178:     case NS_FORM_INPUT_FILE:
51178:       {
52042:         const nsCOMArray<nsIDOMFile>& files = GetFiles();
50906:         return !files.Count();
50906:       }
51178:     default:
50906:       return PR_FALSE;
50906:   }
51178: }
50906: 
50906: PRBool
50907: nsHTMLInputElement::HasTypeMismatch()
50907: {
51178:   if (mType != NS_FORM_INPUT_EMAIL && mType != NS_FORM_INPUT_URL) {
51178:     return PR_FALSE;
51178:   }
51178: 
50907:   nsAutoString value;
50907:   NS_ENSURE_SUCCESS(GetValue(value), PR_FALSE);
50907: 
50907:   if (value.IsEmpty()) {
50907:     return PR_FALSE;
50907:   }
50907: 
51178:   if (mType == NS_FORM_INPUT_EMAIL) {
51178:     return HasAttr(kNameSpaceID_None, nsGkAtoms::multiple)
51178:              ? !IsValidEmailAddressList(value) : !IsValidEmailAddress(value);
50909:   } else if (mType == NS_FORM_INPUT_URL) {
50909:     /**
50909:      * TODO:
50909:      * The URL is not checked as the HTML5 specifications want it to be because
50909:      * there is no code to check for a valid URI/IRI according to 3986 and 3987
50909:      * RFC's at the moment, see bug 561586.
50909:      *
50909:      * RFC 3987 (IRI) implementation: bug 42899
50909:      *
50909:      * HTML5 specifications:
50909:      * http://dev.w3.org/html5/spec/infrastructure.html#valid-url
50909:      */
50909:     nsCOMPtr<nsIIOService> ioService = do_GetIOService();
50909:     nsCOMPtr<nsIURI> uri;
50909: 
50909:     return !NS_SUCCEEDED(ioService->NewURI(NS_ConvertUTF16toUTF8(value), nsnull,
50909:                                            nsnull, getter_AddRefs(uri)));
50907:   }
50907: 
50907:   return PR_FALSE;
50907: }
50907: 
50907: PRBool
50911: nsHTMLInputElement::HasPatternMismatch()
50911: {
50911:   nsAutoString pattern;
51178:   if (!DoesPatternApply() ||
51178:       !GetAttr(kNameSpaceID_None, nsGkAtoms::pattern, pattern)) {
50911:     return PR_FALSE;
50911:   }
50911: 
50911:   nsAutoString value;
50911:   NS_ENSURE_SUCCESS(GetValue(value), PR_FALSE);
50911: 
50911:   if (value.IsEmpty()) {
50911:     return PR_FALSE;
50911:   }
50911: 
50911:   nsIDocument* doc = GetOwnerDoc();
50911:   if (!doc) {
50911:     return PR_FALSE;
50911:   }
50911: 
50911:   return !IsPatternMatching(value, pattern, doc);
50911: }
50911: 
51178: void
51178: nsHTMLInputElement::UpdateTooLongValidityState()
51178: {
51178:   SetValidityState(VALIDITY_STATE_TOO_LONG, IsTooLong());
51178: }
51178: 
51178: void
51178: nsHTMLInputElement::UpdateValueMissingValidityState()
51178: {
51178:   SetValidityState(VALIDITY_STATE_VALUE_MISSING, IsValueMissing());
51178: }
51178: 
51178: void
51178: nsHTMLInputElement::UpdateTypeMismatchValidityState()
51178: {
51178:     SetValidityState(VALIDITY_STATE_TYPE_MISMATCH, HasTypeMismatch());
51178: }
51178: 
51178: void
51178: nsHTMLInputElement::UpdatePatternMismatchValidityState()
51178: {
51178:   SetValidityState(VALIDITY_STATE_PATTERN_MISMATCH, HasPatternMismatch());
51178: }
51178: 
51178: void
51178: nsHTMLInputElement::UpdateAllValidityStates(PRBool aNotify)
51178: {
56345:   PRBool validBefore = IsValid();
51178:   UpdateTooLongValidityState();
51178:   UpdateValueMissingValidityState();
51178:   UpdateTypeMismatchValidityState();
51178:   UpdatePatternMismatchValidityState();
51178: 
56345:   if (validBefore != IsValid() && aNotify) {
51178:     nsIDocument* doc = GetCurrentDoc();
51178:     if (doc) {
52197:       MOZ_AUTO_DOC_UPDATE(doc, UPDATE_CONTENT_STATE, PR_TRUE);
51178:       doc->ContentStatesChanged(this, nsnull,
51178:                                 NS_EVENT_STATE_VALID | NS_EVENT_STATE_INVALID);
51178:     }
51178:   }
51178: }
51178: 
52361: void
52361: nsHTMLInputElement::UpdateBarredFromConstraintValidation()
50904: {
52361:   SetBarredFromConstraintValidation(mType == NS_FORM_INPUT_HIDDEN ||
50904:                                     mType == NS_FORM_INPUT_BUTTON ||
50904:                                     mType == NS_FORM_INPUT_RESET ||
52361:                                     HasAttr(kNameSpaceID_None, nsGkAtoms::readonly) ||
54342:                                     IsDisabled());
50904: }
50904: 
50904: nsresult
50904: nsHTMLInputElement::GetValidationMessage(nsAString& aValidationMessage,
51178:                                          ValidityStateType aType)
50904: {
50904:   nsresult rv = NS_OK;
50904: 
50904:   switch (aType)
50904:   {
51178:     case VALIDITY_STATE_TOO_LONG:
50904:     {
50904:       nsXPIDLString message;
50904:       PRInt32 maxLength = -1;
50904:       PRInt32 textLength = -1;
50904:       nsAutoString strMaxLength;
50904:       nsAutoString strTextLength;
50904: 
50904:       GetMaxLength(&maxLength);
50904:       GetTextLength(&textLength);
50904: 
50904:       strMaxLength.AppendInt(maxLength);
50904:       strTextLength.AppendInt(textLength);
50904: 
54517:       const PRUnichar* params[] = { strMaxLength.get(), strTextLength.get() };
50904:       rv = nsContentUtils::FormatLocalizedString(nsContentUtils::eDOM_PROPERTIES,
54517:                                                  "FormValidationTextTooLong",
50904:                                                  params, 2, message);
50904:       aValidationMessage = message;
50904:       break;
50904:     }
51178:     case VALIDITY_STATE_VALUE_MISSING:
50906:     {
50906:       nsXPIDLString message;
50906:       nsCAutoString key;
50906:       switch (mType)
50906:       {
50906:         case NS_FORM_INPUT_FILE:
54517:           key.Assign("FormValidationFileMissing");
50906:           break;
50906:         case NS_FORM_INPUT_CHECKBOX:
54517:           key.Assign("FormValidationCheckboxMissing");
50906:           break;
50906:         case NS_FORM_INPUT_RADIO:
54517:           key.Assign("FormValidationRadioMissing");
50906:           break;
50906:         default:
54517:           key.Assign("FormValidationValueMissing");
50906:       }
50906:       rv = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
50906:                                               key.get(), message);
50906:       aValidationMessage = message;
50906:       break;
50906:     }
51178:     case VALIDITY_STATE_TYPE_MISMATCH:
50907:     {
50907:       nsXPIDLString message;
50909:       nsCAutoString key;
50909:       if (mType == NS_FORM_INPUT_EMAIL) {
54517:         key.AssignLiteral("FormValidationInvalidEmail");
50909:       } else if (mType == NS_FORM_INPUT_URL) {
54517:         key.AssignLiteral("FormValidationInvalidURL");
50909:       } else {
50909:         return NS_ERROR_UNEXPECTED;
50909:       }
50907:       rv = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
50909:                                               key.get(), message);
50907:       aValidationMessage = message;
50907:       break;
50907:     }
51178:     case VALIDITY_STATE_PATTERN_MISMATCH:
50911:     {
50911:       nsXPIDLString message;
50911:       nsAutoString title;
50911:       GetAttr(kNameSpaceID_None, nsGkAtoms::title, title);
50911:       if (title.IsEmpty()) {
50911:         rv = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
54517:                                                 "FormValidationPatternMismatch",
50911:                                                 message);
50911:       } else {
56464:         if (title.Length() > nsIConstraintValidation::sContentSpecifiedMaxLengthMessage) {
56464:           title.Truncate(nsIConstraintValidation::sContentSpecifiedMaxLengthMessage);
56464:         }
50911:         const PRUnichar* params[] = { title.get() };
50911:         rv = nsContentUtils::FormatLocalizedString(nsContentUtils::eDOM_PROPERTIES,
54517:                                                    "FormValidationPatternMismatchWithTitle",
50911:                                                    params, 1, message);
50911:       }
50911:       aValidationMessage = message;
50911:       break;
50911:     }
50904:     default:
51182:       rv = nsIConstraintValidation::GetValidationMessage(aValidationMessage, aType);
50904:   }
50904: 
50904:   return rv;
50904: }
    1: 
50907: //static
50907: PRBool
50907: nsHTMLInputElement::IsValidEmailAddressList(const nsAString& aValue)
50907: {
50907:   nsCharSeparatedTokenizerTemplate<nsContentUtils::IsHTMLWhitespace>
50907:     tokenizer(aValue, ',');
50907: 
50907:   while (tokenizer.hasMoreTokens()) {
50907:     if (!IsValidEmailAddress(tokenizer.nextToken())) {
50907:       return PR_FALSE;
50907:     }
50907:   }
50907: 
50907:   return !tokenizer.lastTokenEndedWithSeparator();
50907: }
50907: 
50907: //static
50907: PRBool
50907: nsHTMLInputElement::IsValidEmailAddress(const nsAString& aValue)
50907: {
50907:   PRUint32 i = 0;
50907:   PRUint32 length = aValue.Length();
50907: 
50907:   // If the email address is empty, begins with a '@' or ends with a '.',
50907:   // we know it's invalid.
50907:   if (length == 0 || aValue[0] == '@' || aValue[length-1] == '.') {
50907:     return PR_FALSE;
50907:   }
50907: 
50907:   // Parsing the username.
50907:   for (; i < length && aValue[i] != '@'; ++i) {
50907:     PRUnichar c = aValue[i];
50907: 
50907:     // The username characters have to be in this list to be valid.
50907:     if (!(nsCRT::IsAsciiAlpha(c) || nsCRT::IsAsciiDigit(c) ||
50907:           c == '.' || c == '!' || c == '#' || c == '$' || c == '%' ||
50907:           c == '&' || c == '\''|| c == '*' || c == '+' || c == '-' ||
50907:           c == '/' || c == '=' || c == '?' || c == '^' || c == '_' ||
50907:           c == '`' || c == '{' || c == '|' || c == '}' || c == '~' )) {
50907:       return PR_FALSE;
50907:     }
50907:   }
50907: 
50907:   // There is no domain name (or it's one-character long),
50907:   // that's not a valid email address.
50907:   if (++i >= length) {
50907:     return PR_FALSE;
50907:   }
50907: 
50907:   // The domain name can't begin with a dot.
50907:   if (aValue[i] == '.') {
50907:     return PR_FALSE;
50907:   }
50907: 
50907:   // The domain name must have at least one dot which can't follow another dot,
50907:   // can't be the first nor the last domain name character.
50907:   PRBool dotFound = PR_FALSE;
50907: 
50907:   // Parsing the domain name.
50907:   for (; i < length; ++i) {
50907:     PRUnichar c = aValue[i];
50907: 
50907:     if (c == '.') {
50907:       dotFound = PR_TRUE;
50907:       // A dot can't follow a dot.
50907:       if (aValue[i-1] == '.') {
50907:         return PR_FALSE;
50907:       }
50907:     } else if (!(nsCRT::IsAsciiAlpha(c) || nsCRT::IsAsciiDigit(c) ||
50907:                  c == '-')) {
50907:       // The domain characters have to be in this list to be valid.
50907:       return PR_FALSE;
50907:     }
50907:   }
50907: 
50907:   return dotFound;
50907: }
50907: 
50911: //static
50911: PRBool
50911: nsHTMLInputElement::IsPatternMatching(nsAString& aValue, nsAString& aPattern,
50911:                                       nsIDocument* aDocument)
50911: {
50911:   NS_ASSERTION(aDocument, "aDocument should be a valid pointer (not null)");
50911:   NS_ENSURE_TRUE(aDocument->GetScriptGlobalObject(), PR_TRUE);
50911: 
50911:   JSContext* ctx = (JSContext*) aDocument->GetScriptGlobalObject()->
50911:                                   GetContext()->GetNativeContext();
50911:   NS_ENSURE_TRUE(ctx, PR_TRUE);
50911: 
50911:   JSAutoRequest ar(ctx);
50911: 
50911:   // The pattern has to match the entire value.
50911:   aPattern.Insert(NS_LITERAL_STRING("^(?:"), 0);
50911:   aPattern.Append(NS_LITERAL_STRING(")$"));
50911: 
53858:   JSObject* re = JS_NewUCRegExpObjectNoStatics(ctx, reinterpret_cast<jschar*>
50911:                                                  (aPattern.BeginWriting()),
50911:                                                 aPattern.Length(), 0);
50911:   NS_ENSURE_TRUE(re, PR_TRUE);
50911: 
50911:   jsval rval = JSVAL_NULL;
50911:   size_t idx = 0;
50911:   JSBool res;
50911: 
53858:   res = JS_ExecuteRegExpNoStatics(ctx, re, reinterpret_cast<jschar*>
50911:                                     (aValue.BeginWriting()),
50911:                                   aValue.Length(), &idx, JS_TRUE, &rval);
50911: 
50911:   return res == JS_FALSE || rval != JSVAL_NULL;
50911: }
50911: 
    1: //
    1: // Visitor classes
    1: //
    1: //
    1: // CLASS nsRadioVisitor
    1: //
    1: // (this is the superclass of the others)
    1: //
    1: class nsRadioVisitor : public nsIRadioVisitor {
    1: public:
    1:   nsRadioVisitor() { }
  731:   virtual ~nsRadioVisitor() { }
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_IMETHOD Visit(nsIFormControl* aRadio, PRBool* aStop) = 0;
    1: };
    1: 
 4838: NS_IMPL_ISUPPORTS1(nsRadioVisitor, nsIRadioVisitor)
    1: 
    1: 
    1: //
    1: // CLASS nsRadioSetCheckedChangedVisitor
    1: //
    1: class nsRadioSetCheckedChangedVisitor : public nsRadioVisitor {
    1: public:
    1:   nsRadioSetCheckedChangedVisitor(PRBool aCheckedChanged) :
    1:     nsRadioVisitor(), mCheckedChanged(aCheckedChanged)
    1:     { }
    1: 
    1:   virtual ~nsRadioSetCheckedChangedVisitor() { }
    1: 
    1:   NS_IMETHOD Visit(nsIFormControl* aRadio, PRBool* aStop)
    1:   {
47648:     nsRefPtr<nsHTMLInputElement> radio =
47648:       static_cast<nsHTMLInputElement*>(aRadio);
47648:     NS_ASSERTION(radio, "Visit() passed a null button!");
    1:     radio->SetCheckedChangedInternal(mCheckedChanged);
    1:     return NS_OK;
    1:   }
    1: 
    1: protected:
    1:   PRPackedBool mCheckedChanged;
    1: };
    1: 
    1: //
    1: // CLASS nsRadioGetCheckedChangedVisitor
    1: //
    1: class nsRadioGetCheckedChangedVisitor : public nsRadioVisitor {
    1: public:
    1:   nsRadioGetCheckedChangedVisitor(PRBool* aCheckedChanged,
    1:                                   nsIFormControl* aExcludeElement) :
    1:     nsRadioVisitor(),
    1:     mCheckedChanged(aCheckedChanged),
    1:     mExcludeElement(aExcludeElement)
    1:     { }
    1: 
    1:   virtual ~nsRadioGetCheckedChangedVisitor() { }
    1: 
    1:   NS_IMETHOD Visit(nsIFormControl* aRadio, PRBool* aStop)
    1:   {
    1:     if (aRadio == mExcludeElement) {
    1:       return NS_OK;
    1:     }
47648:     nsRefPtr<nsHTMLInputElement> radio =
47648:       static_cast<nsHTMLInputElement*>(aRadio);
47648:     NS_ASSERTION(radio, "Visit() passed a null button!");
47648:     *mCheckedChanged = radio->GetCheckedChanged();
    1:     *aStop = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1: 
    1: protected:
    1:   PRBool* mCheckedChanged;
    1:   nsIFormControl* mExcludeElement;
    1: };
    1: 
51178: class nsRadioUpdateValueMissingVisitor : public nsRadioVisitor {
51178: public:
51178:   nsRadioUpdateValueMissingVisitor(PRBool aNotify)
51178:     : nsRadioVisitor()
51178:     , mNotify(aNotify)
51178:     { }
51178: 
51178:   virtual ~nsRadioUpdateValueMissingVisitor() { };
51178: 
51178:   NS_IMETHOD Visit(nsIFormControl* aRadio, PRBool* aStop)
51178:   {
51178:     /**
51178:      * The simplest way to update the value missing validity state is to do a
51178:      * global update of the validity state by simulationg a value change.
51178:      * OnValueChanged() is declared into nsITextControlElement. That may sound
51178:      * to be a weird way to update the validity states for radio controls but
51178:      * they are also implementing nsITextControlElement interface.
51178:      *
51178:      * When OnValueChanged() is called on a radio control, it will check if any
51178:      * radio in the group is checked. If none, the required radio will be
51178:      * suffering from being missing.
51178:      */
51178:     nsCOMPtr<nsITextControlElement> textCtl(do_QueryInterface(aRadio));
51178:     NS_ASSERTION(textCtl, "Visit() passed a null or non-radio pointer");
51178:     textCtl->OnValueChanged(mNotify);
51178:     return NS_OK;
51178:   }
51178: 
51178: protected:
51178:   PRBool mNotify;
51178: };
51178: 
    1: nsresult
    1: NS_GetRadioSetCheckedChangedVisitor(PRBool aCheckedChanged,
    1:                                     nsIRadioVisitor** aVisitor)
    1: {
    1:   //
    1:   // These are static so that we don't have to keep creating new visitors for
    1:   // such an ordinary process all the time.  There are only two possibilities
    1:   // for this visitor: set to true, and set to false.
    1:   //
    1:   static nsIRadioVisitor* sVisitorTrue = nsnull;
    1:   static nsIRadioVisitor* sVisitorFalse = nsnull;
    1: 
    1:   //
    1:   // Get the visitor that sets them to true
    1:   //
    1:   if (aCheckedChanged) {
    1:     if (!sVisitorTrue) {
    1:       sVisitorTrue = new nsRadioSetCheckedChangedVisitor(PR_TRUE);
    1:       if (!sVisitorTrue) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:       NS_ADDREF(sVisitorTrue);
    1:       nsresult rv =
    1:         nsContentUtils::ReleasePtrOnShutdown((nsISupports**)&sVisitorTrue);
    1:       if (NS_FAILED(rv)) {
    1:         NS_RELEASE(sVisitorTrue);
    1:         return rv;
    1:       }
    1:     }
    1:     *aVisitor = sVisitorTrue;
    1:   }
    1:   //
    1:   // Get the visitor that sets them to false
    1:   //
    1:   else {
    1:     if (!sVisitorFalse) {
    1:       sVisitorFalse = new nsRadioSetCheckedChangedVisitor(PR_FALSE);
    1:       if (!sVisitorFalse) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:       NS_ADDREF(sVisitorFalse);
    1:       nsresult rv =
    1:         nsContentUtils::ReleasePtrOnShutdown((nsISupports**)&sVisitorFalse);
    1:       if (NS_FAILED(rv)) {
    1:         NS_RELEASE(sVisitorFalse);
    1:         return rv;
    1:       }
    1:     }
    1:     *aVisitor = sVisitorFalse;
    1:   }
    1: 
    1:   NS_ADDREF(*aVisitor);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: NS_GetRadioGetCheckedChangedVisitor(PRBool* aCheckedChanged,
    1:                                     nsIFormControl* aExcludeElement,
    1:                                     nsIRadioVisitor** aVisitor)
    1: {
    1:   *aVisitor = new nsRadioGetCheckedChangedVisitor(aCheckedChanged,
    1:                                                   aExcludeElement);
    1:   if (!*aVisitor) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   NS_ADDREF(*aVisitor);
    1: 
    1:   return NS_OK;
    1: }
 3940: 
51178: /*
51178:  * This method is a factory: it lets callers to create an instance of
51178:  * nsRadioUpdateValueMissing without the class declaration and definition.
51178:  *
51178:  * TODO:
51178:  * Do we really need factories for radio visitors? Or at least, we should move
51178:  * that somewhere else because it feels like it's here only because the radio
51178:  * visitor classes are defined after most of nsHTMLInputElement code.
51178:  * See bug 586298
51178:  */
51178: nsIRadioVisitor*
51178: NS_GetRadioUpdateValueMissingVisitor(PRBool aNotify)
51178: {
51178:   return new nsRadioUpdateValueMissingVisitor(aNotify);
51178: }
51178: 
43129: NS_IMETHODIMP_(PRBool)
43129: nsHTMLInputElement::IsSingleLineTextControl() const
43129: {
43129:   return IsSingleLineTextControl(PR_FALSE);
43129: }
43129: 
43129: NS_IMETHODIMP_(PRBool)
43129: nsHTMLInputElement::IsTextArea() const
43129: {
43129:   return PR_FALSE;
43129: }
43129: 
43129: NS_IMETHODIMP_(PRBool)
43129: nsHTMLInputElement::IsPlainTextControl() const
43129: {
43129:   // need to check our HTML attribute and/or CSS.
43129:   return PR_TRUE;
43129: }
43129: 
43129: NS_IMETHODIMP_(PRBool)
43129: nsHTMLInputElement::IsPasswordTextControl() const
43129: {
43129:   return mType == NS_FORM_INPUT_PASSWORD;
43129: }
43129: 
43129: NS_IMETHODIMP_(PRInt32)
43129: nsHTMLInputElement::GetCols()
43129: {
43129:   // Else we know (assume) it is an input with size attr
43129:   const nsAttrValue* attr = GetParsedAttr(nsGkAtoms::size);
43129:   if (attr && attr->Type() == nsAttrValue::eInteger) {
43129:     PRInt32 cols = attr->GetIntegerValue();
43129:     if (cols > 0) {
43129:       return cols;
43129:     }
43129:   }
43129: 
43129:   return DEFAULT_COLS;
43129: }
43129: 
43129: NS_IMETHODIMP_(PRInt32)
43129: nsHTMLInputElement::GetWrapCols()
43129: {
43129:   return -1; // only textarea's can have wrap cols
43129: }
43129: 
43129: NS_IMETHODIMP_(PRInt32)
43129: nsHTMLInputElement::GetRows()
43129: {
43129:   return DEFAULT_ROWS;
43129: }
43129: 
43129: NS_IMETHODIMP_(void)
43129: nsHTMLInputElement::GetDefaultValueFromContent(nsAString& aValue)
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     GetDefaultValue(aValue);
48063:     // This is called by the frame to show the value.
48063:     // We have to sanitize it when needed.
54366:     if (!GET_BOOLBIT(mBitField, BF_PARSER_CREATING)) {
48063:       SanitizeValue(aValue);
43129:     }
43129:   }
54366: }
43129: 
43129: NS_IMETHODIMP_(PRBool)
43129: nsHTMLInputElement::ValueChanged() const
43129: {
43129:   return GET_BOOLBIT(mBitField, BF_VALUE_CHANGED);
43129: }
43129: 
43129: NS_IMETHODIMP_(void)
43129: nsHTMLInputElement::GetTextEditorValue(nsAString& aValue,
43129:                                        PRBool aIgnoreWrap) const
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     state->GetValue(aValue, aIgnoreWrap);
43129:   }
43129: }
43129: 
43129: NS_IMETHODIMP_(void)
43129: nsHTMLInputElement::SetTextEditorValue(const nsAString& aValue,
43129:                                        PRBool aUserInput)
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     state->SetValue(aValue, aUserInput);
43129:   }
43129: }
43129: 
43129: NS_IMETHODIMP_(void)
43129: nsHTMLInputElement::InitializeKeyboardEventListeners()
43129: {
43129:   nsTextEditorState *state = GetEditorState();
43129:   if (state) {
43129:     state->InitializeKeyboardEventListeners();
43129:   }
43129: }
51178: 
51178: NS_IMETHODIMP_(void)
51178: nsHTMLInputElement::OnValueChanged(PRBool aNotify)
51178: {
51178:   UpdateAllValidityStates(aNotify);
51388: 
51388:   // :-moz-placeholder pseudo-class may change when the value changes.
51388:   // However, we don't want to waste cycles if the state doesn't apply.
51388:   if (aNotify && PlaceholderApplies()
51388:       && HasAttr(kNameSpaceID_None, nsGkAtoms::placeholder)
51388:       && !nsContentUtils::IsFocusedContent((nsIContent*)(this))) {
51388:     nsIDocument* doc = GetCurrentDoc();
51388:     if (doc) {
51388:       MOZ_AUTO_DOC_UPDATE(doc, UPDATE_CONTENT_STATE, PR_TRUE);
51388:       doc->ContentStatesChanged(this, nsnull, NS_EVENT_STATE_MOZ_PLACEHOLDER);
51388:     }
51388:   }
51388: }
51388: 
54342: void
56168: nsHTMLInputElement::FieldSetDisabledChanged(nsEventStates aStates, PRBool aNotify)
54342: {
54342:   UpdateValueMissingValidityState();
54342:   UpdateBarredFromConstraintValidation();
54342: 
54342:   aStates |= NS_EVENT_STATE_VALID | NS_EVENT_STATE_INVALID;
55188:   nsGenericHTMLFormElement::FieldSetDisabledChanged(aStates, aNotify);
54346: }
54346: 
55184: PRInt32
55185: nsHTMLInputElement::GetFilterFromAccept()
55184: {
55184:   NS_ASSERTION(HasAttr(kNameSpaceID_None, nsGkAtoms::accept),
55184:                "You should not call GetFileFiltersFromAccept if the element"
55184:                " has no accept attribute!");
55184: 
55185:   PRInt32 filter = 0;
55184:   nsAutoString accept;
55184:   GetAttr(kNameSpaceID_None, nsGkAtoms::accept, accept);
55184: 
55184:   nsCharSeparatedTokenizerTemplate<nsContentUtils::IsHTMLWhitespace>
55184:     tokenizer(accept, ',');
55184: 
55184:   while (tokenizer.hasMoreTokens()) {
55184:     const nsDependentSubstring token = tokenizer.nextToken();
55184: 
55185:     PRInt32 tokenFilter = 0;
55184:     if (token.EqualsLiteral("image/*")) {
55185:       tokenFilter = nsIFilePicker::filterImages;
55184:     } else if (token.EqualsLiteral("audio/*")) {
55185:       tokenFilter = nsIFilePicker::filterAudio;
55184:     } else if (token.EqualsLiteral("video/*")) {
55185:       tokenFilter = nsIFilePicker::filterVideo;
55185:     }
55185: 
55185:     if (tokenFilter) {
55185:       // We do not want to set more than one filter so if we found two different
55185:       // kwown tokens, we will return 0 (no filter).
55185:       if (filter && filter != tokenFilter) {
55185:         return 0;
55185:       }
55185:       filter = tokenFilter;
55185:     }
55185:   }
55185: 
55185:   return filter;
55185: }
55185: 
