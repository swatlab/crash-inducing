 39028: /* vim: set sw=2 sts=2 et cin: */
 39028: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 39028:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 39028:  *
 39028:  * This Original Code has been modified by IBM Corporation.
 39028:  * Modifications made by IBM are
 39028:  * Copyright (c) International Business Machines Corporation, 2000
 39028:  *
 39028:  */
 39028: //=============================================================================
 39028: 
 39028: #include "nsWindow.h"
 39028: #include "os2FrameWindow.h"
 39028: #include "nsIRollupListener.h"
 39028: #include "nsIScreenManager.h"
 39028: #include "nsOS2Uni.h"
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: // External Variables (in nsWindow.cpp)
 39028: 
108991: extern uint32_t            gOS2Flags;
 39028: 
 39028: #ifdef DEBUG_FOCUS
 39028:   extern int currentWindowIdentifier;
 39028: #endif
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: // Debug
 39028: 
 39028: #ifdef DEBUG_FOCUS
 39028:   #define DEBUGFOCUS(what) fprintf(stderr, "[%8x]  %8lx  (%02d)  "#what"\n", \
 39028:                                    (int)this, mFrameWnd, mWindowIdentifier)
 39028: #else
 39028:   #define DEBUGFOCUS(what)
 39028: #endif
 39028: 
 39028: //=============================================================================
 39028: //  os2FrameWindow Setup
 39028: //=============================================================================
 39028: 
 39028: os2FrameWindow::os2FrameWindow(nsWindow* aOwner)
 39028: {
 39028:   mOwner            = aOwner;
 39028:   mFrameWnd         = 0;
 39028:   mTitleBar         = 0;
 39028:   mSysMenu          = 0;
 39028:   mMinMax           = 0;
 39028:   mSavedStyle       = 0;
 39028:   mFrameIcon        = 0;
 80486:   mChromeHidden     = false;
 80486:   mNeedActivation   = false;
 39028:   mPrevFrameProc    = 0;
 39028:   mFrameBounds      = nsIntRect(0, 0, 0, 0);
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: 
 39028: os2FrameWindow::~os2FrameWindow()
 39028: {
 39028:   if (mFrameIcon) {
 39028:     WinFreeFileIcon(mFrameIcon);
 39028:     mFrameIcon = 0;
 39028:   }
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: // Create frame & client windows for an os2FrameWindow object;  return the
 39028: // handle of the client window.  This is the only method that manipulates
 39028: // the client window - all other operations on it are handled by nsWindow.
 39028: 
 39028: HWND os2FrameWindow::CreateFrameWindow(nsWindow* aParent,
 39028:                                        HWND aParentWnd,
 39028:                                        const nsIntRect& aRect,
 39028:                                        nsWindowType aWindowType,
 39028:                                        nsBorderStyle aBorderStyle)
 39028: {
 39028:   // Create a frame window with a MozillaWindowClass window as its client.
 39028:   HWND hClient;
108991:   uint32_t fcfFlags = GetFCFlags(aWindowType, aBorderStyle);
 39028:   mFrameWnd = WinCreateStdWindow(HWND_DESKTOP,
 39028:                                  0,
 39028:                                  (ULONG*)&fcfFlags,
 39028:                                  kWindowClassName,
 39028:                                  "Title",
 39028:                                  WS_CLIPCHILDREN,
 39028:                                  NULLHANDLE,
 39028:                                  0,
 39028:                                  &hClient);
 39028:   if (!mFrameWnd) {
 39028:     return 0;
 39028:   }
 39028: 
 39028:   // Hide from the Window List until shown.
 80486:   SetWindowListVisibility(false);
 39028: 
 39028:   // This prevents a modal dialog from being covered by its disabled parent.
 39028:   if (aParentWnd != HWND_DESKTOP) {
 39028:     WinSetOwner(mFrameWnd, aParentWnd);
 39028:   }
 39028: 
 39028:   // Get the frame control HWNDs for use by fullscreen mode.
 39028:   mTitleBar = WinWindowFromID(mFrameWnd, FID_TITLEBAR);
 39028:   mSysMenu  = WinWindowFromID(mFrameWnd, FID_SYSMENU);
 39028:   mMinMax   = WinWindowFromID(mFrameWnd, FID_MINMAX);
 39028: 
 39028:   // Calc the size of a frame needed to contain a client area of the
 39028:   // specified width & height.  Without this, eWindowType_dialog windows
 39028:   // will be truncated (toplevel windows will still display correctly).
 39028:   RECTL rcl = {0, 0, aRect.width, aRect.height};
 39028:   WinCalcFrameRect(mFrameWnd, &rcl, FALSE);
 39028:   mFrameBounds = nsIntRect(aRect.x, aRect.y,
 39028:                            rcl.xRight-rcl.xLeft, rcl.yTop-rcl.yBottom);
 39028: 
 39028:   // Move & resize the frame.
108991:   int32_t pmY = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN)
 39028:                 - mFrameBounds.y - mFrameBounds.height;
 39028:   WinSetWindowPos(mFrameWnd, 0, mFrameBounds.x, pmY,
 39028:                   mFrameBounds.width, mFrameBounds.height,
 39028:                   SWP_SIZE | SWP_MOVE);
 39028: 
 39028:   // Store the client's bounds.  For windows with resizable borders,
 39028:   // the width includes the width of the frame controls (minmax, etc.).
 39028:   SWP swp;
 39028:   WinQueryWindowPos(hClient, &swp);
 39028:   mOwner->SetBounds(nsIntRect(swp.x, mFrameBounds.height - swp.y - swp.cy,
 39028:                               swp.cx, swp.cy));
 39028: 
 39028:   // Subclass the frame.
 39028:   mPrevFrameProc = WinSubclassWindow(mFrameWnd, fnwpFrame);
 39028:   WinSetWindowPtr(mFrameWnd, QWL_USER, this);
 39028: 
 39028:   DEBUGFOCUS(Create os2FrameWindow);
 39028:   return hClient;
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: 
108991: uint32_t os2FrameWindow::GetFCFlags(nsWindowType aWindowType,
 39028:                                     nsBorderStyle aBorderStyle)
 39028: {
108991:   uint32_t style = FCF_TITLEBAR | FCF_SYSMENU | FCF_TASKLIST |
 39028:                    FCF_CLOSEBUTTON | FCF_NOBYTEALIGN | FCF_AUTOICON;
 39028: 
 39028:   if (aWindowType == eWindowType_dialog) {
 39028:     if (aBorderStyle == eBorderStyle_default) {
 39028:       style |= FCF_DLGBORDER;
 39028:     } else {
 39028:       style |= FCF_SIZEBORDER | FCF_MINMAX;
 39028:     }
 39028:   }
 39028:   else {
 39028:     style |= FCF_SIZEBORDER | FCF_MINMAX;
 39028:   }
 39028: 
 39028:   if (gOS2Flags & kIsDBCS) {
 39028:     style |= FCF_DBE_APPSTAT;
 39028:   }
 39028:   if (aWindowType == eWindowType_invisible) {
 39028:     style &= ~FCF_TASKLIST;
 39028:   }
 39028: 
 39028:   if (aBorderStyle != eBorderStyle_default &&
 39028:       aBorderStyle != eBorderStyle_all) {
 39028:     if (aBorderStyle == eBorderStyle_none ||
 39028:         !(aBorderStyle & eBorderStyle_resizeh)) {
 39028:       style &= ~FCF_SIZEBORDER;
 39028:       style |= FCF_DLGBORDER;
 39028:     }
 39028:     if (aBorderStyle == eBorderStyle_none ||
 39028:         !(aBorderStyle & eBorderStyle_border)) {
 39028:       style &= ~(FCF_DLGBORDER | FCF_SIZEBORDER);
 39028:     }
 39028:     if (aBorderStyle == eBorderStyle_none ||
 39028:         !(aBorderStyle & eBorderStyle_title)) {
 39028:       style &= ~(FCF_TITLEBAR | FCF_TASKLIST);
 39028:     }
 39028:     if (aBorderStyle == eBorderStyle_none ||
 39028:         !(aBorderStyle & eBorderStyle_close)) {
 39028:       style &= ~FCF_CLOSEBUTTON;
 39028:     }
 39028:     if (aBorderStyle == eBorderStyle_none ||
 39028:       !(aBorderStyle & (eBorderStyle_menu | eBorderStyle_close))) {
 39028:       style &= ~FCF_SYSMENU;
 39028:     }
 39028: 
 39028:     // Looks like getting rid of the system menu also does away
 39028:     // with the close box. So, we only get rid of the system menu
 39028:     // if you want neither it nor the close box.
 39028: 
 39028:     if (aBorderStyle == eBorderStyle_none ||
 39028:         !(aBorderStyle & eBorderStyle_minimize)) {
 39028:       style &= ~FCF_MINBUTTON;
 39028:     }
 39028:     if (aBorderStyle == eBorderStyle_none ||
 39028:         !(aBorderStyle & eBorderStyle_maximize)) {
 39028:       style &= ~FCF_MAXBUTTON;
 39028:     }
 39028:   }
 39028: 
 39028:   return style;
 39028: }
 39028: 
 39028: //=============================================================================
 39028: //  Window Operations
 39028: //=============================================================================
 39028: 
 39028: // For frame windows, 'Show' is equivalent to 'Show & Activate'.
 39028: 
 79445: nsresult os2FrameWindow::Show(bool aState)
 39028: {
108991:   uint32_t ulFlags;
 39028:   if (!aState) {
 39028:     ulFlags = SWP_HIDE | SWP_DEACTIVATE;
 39028:   } else {
 39028:     ulFlags = SWP_SHOW | SWP_ACTIVATE;
 39028: 
108991:     uint32_t ulStyle = WinQueryWindowULong(mFrameWnd, QWL_STYLE);
108991:     int32_t sizeMode;
 39028:     mOwner->GetSizeMode(&sizeMode);
 39028:     if (!(ulStyle & WS_VISIBLE)) {
 39028:       if (sizeMode == nsSizeMode_Maximized) {
 39028:         ulFlags |= SWP_MAXIMIZE;
 39028:       } else if (sizeMode == nsSizeMode_Minimized) {
 39028:         ulFlags |= SWP_MINIMIZE;
 39028:       } else {
 39028:         ulFlags |= SWP_RESTORE;
 39028:       }
 39028:     } else if (ulStyle & WS_MINIMIZED) {
 39028:       if (sizeMode == nsSizeMode_Maximized) {
 39028:         ulFlags |= SWP_MAXIMIZE;
 39028:       } else {
 39028:         ulFlags |= SWP_RESTORE;
 39028:       }
 39028:     }
 39028:   }
 39028: 
 39028:   WinSetWindowPos(mFrameWnd, 0, 0, 0, 0, 0, ulFlags);
 39028:   SetWindowListVisibility(aState);
 39028: 
 39028:   return NS_OK;
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: 
 79445: void os2FrameWindow::SetWindowListVisibility(bool aState)
 39028: {
 39028:   HSWITCH hswitch = WinQuerySwitchHandle(mFrameWnd, 0);
 39028:   if (hswitch) {
 39028:     SWCNTRL swctl;
 39028:     WinQuerySwitchEntry(hswitch, &swctl);
 39028:     swctl.uchVisibility = aState ? SWL_VISIBLE : SWL_INVISIBLE;
 39028:     swctl.fbJump        = aState ? SWL_JUMPABLE : SWL_NOTJUMPABLE;
 39028:     WinChangeSwitchEntry(hswitch, &swctl);
 39028:   }
 39028: }
 39028: 
 39028: //=============================================================================
 39028: //  Window Positioning
 39028: //=============================================================================
 39028: 
 39028: nsresult os2FrameWindow::GetBounds(nsIntRect& aRect)
 39028: {
 39028:   aRect = mFrameBounds;
 39028:   return NS_OK;
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: 
108991: nsresult os2FrameWindow::Move(int32_t aX, int32_t aY)
 39028: {
 39028:   aY = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN) - mFrameBounds.height - aY;
 39028:   WinSetWindowPos(mFrameWnd, 0, aX, aY, 0, 0, SWP_MOVE);
 39028:   return NS_OK;
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: 
108991: nsresult os2FrameWindow::Resize(int32_t aWidth, int32_t aHeight,
 79445:                                 bool aRepaint)
 39028: {
 62135:   // When resizing, the coordinates of the window's bottom-left corner have to
 62135:   // be adjusted to ensure the position of the top-left corner doesn't change.
 62135:   Resize(mFrameBounds.x, mFrameBounds.y, aWidth, aHeight, aRepaint);
 62135: 
 39028:   return NS_OK;
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: 
108991: nsresult os2FrameWindow::Resize(int32_t aX, int32_t aY,
108991:                                 int32_t aWidth, int32_t aHeight,
 79445:                                 bool aRepaint)
 39028: {
 39028:   aY = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN) - aY - aHeight;
 39028:   WinSetWindowPos(mFrameWnd, 0, aX, aY, aWidth, aHeight, SWP_MOVE | SWP_SIZE);
 39028:   return NS_OK;
 39028: }
 39028: 
 39028: //=============================================================================
 39028: //  Top-level (frame window) Operations
 39028: //=============================================================================
 39028: 
 39028: // When WM_ACTIVATE is received with the "gaining activation" flag set,
 39028: // the frame's wndproc sets mNeedActivation.  Later, when an nsWindow
 39028: // gets a WM_FOCUSCHANGED msg with the "gaining focus" flag set, it
 39028: // invokes this method on os2FrameWindow to fire an NS_ACTIVATE event.
 39028: 
 39028: void os2FrameWindow::ActivateTopLevelWidget()
 39028: {
 39028:   // Don't fire event if we're minimized or else the window will
 39028:   // be restored as soon as the user clicks on it.  When the user
 39028:   // explicitly restores it, SetSizeMode() will call this method.
 39028:   if (mNeedActivation) {
108991:     int32_t sizeMode;
 39028:     mOwner->GetSizeMode(&sizeMode);
 39028:     if (sizeMode != nsSizeMode_Minimized) {
 80486:       mNeedActivation = false;
 39028:       DEBUGFOCUS(NS_ACTIVATE);
 39028:       mOwner->DispatchActivationEvent(NS_ACTIVATE);
 39028:     }
 39028:   }
 39028:   return;
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: // Maximize, minimize or restore the window.  When the frame has its
 62135: // controls, this method is usually advisory because min/max/restore has
 62135: // already occurred.  It only performs these actions when the frame is in
 62135: // fullscreen mode or saved window positions are being restored at startup.
 39028: 
108991: nsresult os2FrameWindow::SetSizeMode(int32_t aMode)
 39028: {
108991:   int32_t previousMode;
 39028:   mOwner->GetSizeMode(&previousMode);
 39028: 
 39028:   // save the new state
 39028:   nsresult rv = mOwner->nsBaseWidget::SetSizeMode(aMode);
 62135:   if (!NS_SUCCEEDED(rv)) {
 62135:     return rv;
 62135:   }
 39028: 
 39028:   // Minimized windows would get restored involuntarily if we fired an
 39028:   // NS_ACTIVATE when the user clicks on them.  Instead, we defer the
 39028:   // activation event until the window has explicitly been restored.
 39028:   if (previousMode == nsSizeMode_Minimized && previousMode != aMode) {
 39028:     DEBUGFOCUS(deferred NS_ACTIVATE);
 39028:     ActivateTopLevelWidget();
 39028:   }
 39028: 
 39028:   ULONG ulStyle = WinQueryWindowULong(mFrameWnd, QWL_STYLE);
 39028: 
 62135:   switch (aMode) {
 62135:     case nsSizeMode_Normal:
 62135:       if (ulStyle & (WS_MAXIMIZED | WS_MINIMIZED)) {
 62135:         WinSetWindowPos(mFrameWnd, 0, 0, 0, 0, 0, SWP_RESTORE);
 62135:       }
 62135:       break;
 62135: 
 62135:     case nsSizeMode_Minimized:
 39028:       if (!(ulStyle & WS_MINIMIZED)) {
 39028:         WinSetWindowPos(mFrameWnd, HWND_BOTTOM, 0, 0, 0, 0,
 39028:                         SWP_MINIMIZE | SWP_ZORDER | SWP_DEACTIVATE);
 39028:       }
 62135:       break;
 62135: 
 62135:     case nsSizeMode_Maximized:
 62135:       // Don't permit the window to be maximized when in
 62135:       // fullscreen mode because it won't be restored correctly.
 62135:       if (!(ulStyle & WS_MAXIMIZED) && !mChromeHidden) {
 62135:         WinSetWindowPos(mFrameWnd, HWND_TOP, 0, 0, 0, 0,
 62135:                         SWP_MAXIMIZE | SWP_ZORDER);
 62135:       }
 62135:       break;
 62135: 
 62135:     // 'nsSizeMode_Fullscreen' is defined but isn't used (as of v1.9.3)
 62135:     case nsSizeMode_Fullscreen:
 62135:     default:
 62135:       break;
 39028:   }
 39028: 
 39028:   return NS_OK;
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: // Hide or show the frame & its controls (titlebar, minmax, etc.).
 39028: 
 79445: nsresult os2FrameWindow::HideWindowChrome(bool aShouldHide)
 39028: {
 39028:   // Putting a maximized window into fullscreen mode causes multiple
 39028:   // problems if it's later minimized & then restored.  To avoid them,
 39028:   // restore maximized windows before putting them in fullscreen mode.
 39028:   if (WinQueryWindowULong(mFrameWnd, QWL_STYLE) & WS_MAXIMIZED) {
 39028:     WinSetWindowPos(mFrameWnd, 0, 0, 0, 0, 0, SWP_RESTORE | SWP_NOREDRAW);
 39028:   }
 39028: 
 39028:   HWND hParent;
 39028:   if (aShouldHide) {
 39028:     hParent = HWND_OBJECT;
 80486:     mChromeHidden = true;
 39028:   } else {
 39028:     hParent = mFrameWnd;
 80486:     mChromeHidden = false;
 39028:   }
 39028: 
 39028:   // Hide or show the frame controls.
 39028:   WinSetParent(mTitleBar, hParent, FALSE);
 39028:   WinSetParent(mSysMenu, hParent, FALSE);
 39028:   WinSetParent(mMinMax, hParent, FALSE);
 39028: 
 39028:   // Modify the frame style, then advise it of the changes.
 39028:   if (aShouldHide) {
 39028:     mSavedStyle = WinQueryWindowULong(mFrameWnd, QWL_STYLE);
 39028:     WinSetWindowULong(mFrameWnd, QWL_STYLE, mSavedStyle & ~FS_SIZEBORDER);
 39028:     WinSendMsg(mFrameWnd, WM_UPDATEFRAME, 0, 0);
 39028:   } else {
 39028:     WinSetWindowULong(mFrameWnd, QWL_STYLE, mSavedStyle);
 39028:     WinSendMsg(mFrameWnd, WM_UPDATEFRAME,
 39028:                MPFROMLONG(FCF_TITLEBAR | FCF_SYSMENU | FCF_MINMAX), 0);
 39028:   }
 39028: 
 39028:   return NS_OK;
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: // On OS/2, if you pass a titlebar > 512 characters, it doesn't display at all.
 39028: // We are going to limit our titlebars to 256 just to be on the safe side.
 39028: 
 39028: #define MAX_TITLEBAR_LENGTH 256
 39028: 
 39028: nsresult os2FrameWindow::SetTitle(const nsAString& aTitle)
 39028: {
 39028:   PRUnichar* uchtemp = ToNewUnicode(aTitle);
108991:   for (uint32_t i = 0; i < aTitle.Length(); i++) {
 39028:     switch (uchtemp[i]) {
 39028:       case 0x2018:
 39028:       case 0x2019:
 39028:         uchtemp[i] = 0x0027;
 39028:         break;
 39028:       case 0x201C:
 39028:       case 0x201D:
 39028:         uchtemp[i] = 0x0022;
 39028:         break;
 39028:       case 0x2014:
 39028:         uchtemp[i] = 0x002D;
 39028:         break;
 39028:     }
 39028:   }
 39028: 
 39028:   nsAutoCharBuffer title;
108991:   int32_t titleLength;
 39028:   WideCharToMultiByte(0, uchtemp, aTitle.Length(), title, titleLength);
 39028:   if (titleLength > MAX_TITLEBAR_LENGTH) {
 39028:     title[MAX_TITLEBAR_LENGTH] = '\0';
 39028:   }
 39028:   WinSetWindowText(mFrameWnd, title.Elements());
 39028: 
 39028:   // If the chrome is hidden, set the text of the titlebar directly
 39028:   if (mChromeHidden) {
 39028:     WinSetWindowText(mTitleBar, title.Elements());
 39028:   }
 39028: 
 39028:   nsMemory::Free(uchtemp);
 39028:   return NS_OK;
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: // This implementation guarantees that sysmenus & minimized windows
 39028: // will always have some icon other than the sysmenu default.
 39028: 
 39028: nsresult os2FrameWindow::SetIcon(const nsAString& aIconSpec)
 39028: {
 39028:   static HPOINTER hDefaultIcon = 0;
 39028:   HPOINTER        hWorkingIcon = 0;
 39028: 
 39028:   // Assume the given string is a local identifier for an icon file.
101111:   nsCOMPtr<nsIFile> iconFile;
 39028:   mOwner->ResolveIconName(aIconSpec, NS_LITERAL_STRING(".ico"),
 39028:                           getter_AddRefs(iconFile));
 39028: 
 39028:   // if the file was found, try to use it
 39028:   if (iconFile) {
110974:     nsAutoCString path;
 39028:     iconFile->GetNativePath(path);
 39028: 
 39028:     if (mFrameIcon) {
 39028:       WinFreeFileIcon(mFrameIcon);
 39028:     }
 39028:     mFrameIcon = WinLoadFileIcon(path.get(), FALSE);
 39028:     hWorkingIcon = mFrameIcon;
 39028:   }
 39028: 
 39028:   // if that doesn't work, use the app's icon (let's hope it can be
 39028:   // loaded because nobody should have to look at SPTR_APPICON)
 39028:   if (!hWorkingIcon) {
 39028:     if (!hDefaultIcon) {
 39028:       hDefaultIcon = WinLoadPointer(HWND_DESKTOP, 0, 1);
 39028:       if (!hDefaultIcon) {
 39028:         hDefaultIcon = WinQuerySysPointer(HWND_DESKTOP, SPTR_APPICON, FALSE);
 39028:       }
 39028:     }
 39028:     hWorkingIcon = hDefaultIcon;
 39028:   }
 39028: 
 39028:   WinSendMsg(mFrameWnd, WM_SETICON, (MPARAM)hWorkingIcon, (MPARAM)0);
 39028:   return NS_OK;
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: // Constrain a potential move to fit onscreen.
 39028: 
 79445: nsresult os2FrameWindow::ConstrainPosition(bool aAllowSlop,
108991:                                       int32_t* aX, int32_t* aY)
 39028: {
 39028:   // do we have enough info to do anything
 79445:   bool doConstrain = false;
 39028: 
 39028:   // get our playing field. use the current screen, or failing
 39028:   // that for any reason, use device caps for the default screen.
 39028:   RECTL screenRect;
 39028: 
 39028:   nsCOMPtr<nsIScreenManager> screenmgr =
 39028:     do_GetService("@mozilla.org/gfx/screenmanager;1");
 39028:   if (screenmgr) {
 39028:     nsCOMPtr<nsIScreen> screen;
108991:     int32_t left, top, width, height;
 39028: 
 39028:     // zero size rects confuse the screen manager
 39028:     width = mFrameBounds.width > 0 ? mFrameBounds.width : 1;
 39028:     height = mFrameBounds.height > 0 ? mFrameBounds.height : 1;
 39028:     screenmgr->ScreenForRect(*aX, *aY, width, height,
 39028:                              getter_AddRefs(screen));
 39028:     if (screen) {
 39028:       screen->GetAvailRect(&left, &top, &width, &height);
 39028:       screenRect.xLeft = left;
 39028:       screenRect.xRight = left+width;
 39028:       screenRect.yTop = top;
 39028:       screenRect.yBottom = top+height;
 80486:       doConstrain = true;
 39028:     }
 39028:   }
 39028: 
 39028: #define kWindowPositionSlop 100
 39028: 
 39028:   if (doConstrain) {
 39028:     if (aAllowSlop) {
 39028:       if (*aX < screenRect.xLeft - mFrameBounds.width + kWindowPositionSlop) {
 39028:         *aX = screenRect.xLeft - mFrameBounds.width + kWindowPositionSlop;
 39028:       } else
 39028:       if (*aX >= screenRect.xRight - kWindowPositionSlop) {
 39028:         *aX = screenRect.xRight - kWindowPositionSlop;
 39028:       }
 39028: 
 39028:       if (*aY < screenRect.yTop) {
 39028:         *aY = screenRect.yTop;
 39028:       } else
 39028:       if (*aY >= screenRect.yBottom - kWindowPositionSlop) {
 39028:         *aY = screenRect.yBottom - kWindowPositionSlop;
 39028:       }
 39028:     } else {
 39028:       if (*aX < screenRect.xLeft) {
 39028:         *aX = screenRect.xLeft;
 39028:       } else
 39028:       if (*aX >= screenRect.xRight - mFrameBounds.width) {
 39028:         *aX = screenRect.xRight - mFrameBounds.width;
 39028:       }
 39028: 
 39028:       if (*aY < screenRect.yTop) {
 39028:         *aY = screenRect.yTop;
 39028:       } else
 39028:       if (*aY >= screenRect.yBottom - mFrameBounds.height) {
 39028:         *aY = screenRect.yBottom - mFrameBounds.height;
 39028:       }
 39028:     }
 39028:   }
 39028: 
 39028:   return NS_OK;
 39028: }
 39028: 
 39028: //=============================================================================
 39028: //  os2FrameWindow's Window Procedure
 39028: //=============================================================================
 39028: 
 39028: // Subclass for frame window
 39028: 
 39028: MRESULT EXPENTRY fnwpFrame(HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2)
 39028: {
 39028:   // check to see if we have a rollup listener registered
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
123327:   if (rollupListener) {
120177:   nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
 39028:     if (msg == WM_TRACKFRAME || msg == WM_MINMAXFRAME ||
 39028:         msg == WM_BUTTON1DOWN || msg == WM_BUTTON2DOWN ||
 39028:         msg == WM_BUTTON3DOWN) {
 39028:       // Rollup if the event is outside the popup
120177:       if (!nsWindow::EventIsInsideWindow((nsWindow*)rollupWidget)) {
120177:         rollupListener->Rollup(UINT32_MAX);
 39028:       }
 39028:     }
 39028:   }
 39028: 
 39028:   os2FrameWindow* pFrame = (os2FrameWindow*)WinQueryWindowPtr(hwnd, QWL_USER);
 39028:   return pFrame->ProcessFrameMessage(msg, mp1, mp2);
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: // Process messages from the frame
 39028: 
 39028: MRESULT os2FrameWindow::ProcessFrameMessage(ULONG msg, MPARAM mp1, MPARAM mp2)
 39028: {
 39028:   MRESULT mresult = 0;
 79445:   bool    isDone = false;
 39028: 
 39028:   switch (msg) {
 39028:     case WM_WINDOWPOSCHANGED: {
 39028:       PSWP pSwp = (PSWP)mp1;
 39028: 
 62135:       // Don't save the new position or size of a minimized
 62135:       // window, or else it won't be restored correctly.
 39028:       if (pSwp->fl & SWP_MOVE && !(pSwp->fl & SWP_MINIMIZE)) {
 39028:         POINTL ptl = { pSwp->x, pSwp->y + pSwp->cy };
 39028:         ptl.y = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN) - ptl.y;
 39028:         mFrameBounds.x = ptl.x;
 39028:         mFrameBounds.y = ptl.y;
 39028:         mOwner->DispatchMoveEvent(ptl.x, ptl.y);
 39028:       }
 39028: 
 39028:       // Save the frame's bounds, then call the default wndproc
 39028:       // so the client can handle its WM_WINDOWPOSCHANGED msg now.
 39028:       if (pSwp->fl & SWP_SIZE && !(pSwp->fl & SWP_MINIMIZE)) {
 39028:         mFrameBounds.width = pSwp->cx;
 39028:         mFrameBounds.height = pSwp->cy;
 39028:         mresult = (*mPrevFrameProc)(mFrameWnd, msg, mp1, mp2);
 80486:         isDone = true;
 39028:       }
 39028: 
 39028:       if (pSwp->fl & (SWP_MAXIMIZE | SWP_MINIMIZE | SWP_RESTORE)) {
 80486:         nsSizeModeEvent event(true, NS_SIZEMODE, mOwner);
 39028:         if (pSwp->fl & SWP_MAXIMIZE) {
 39028:           event.mSizeMode = nsSizeMode_Maximized;
 39028:         } else if (pSwp->fl & SWP_MINIMIZE) {
 39028:           event.mSizeMode = nsSizeMode_Minimized;
 39028:         } else {
 39028:           event.mSizeMode = nsSizeMode_Normal;
 39028:         }
 39028:         mOwner->InitEvent(event);
 39028:         mOwner->DispatchWindowEvent(&event);
 39028:       }
 39028:       break;
 39028:     }
 39028: 
 39028:      // A frame window in kiosk/fullscreen mode must have its frame
 39028:      // controls reattached before it's minimized & detached after it's
 39028:      // restored.  If this doesn't happen at the correct times, clicking
 39028:      // on the icon won't restore it, the sysmenu will have the wrong
 39028:      // items, and/or the minmax button will have the wrong buttons.
 39028: 
 39028:     case WM_ADJUSTWINDOWPOS:
 39028:       if (mChromeHidden && ((PSWP)mp1)->fl & SWP_MINIMIZE) {
 39028:         WinSetParent(mTitleBar, mFrameWnd, TRUE);
 39028:         WinSetParent(mSysMenu, mFrameWnd, TRUE);
 39028:         WinSetParent(mMinMax, mFrameWnd, TRUE);
 39028:       }
 39028:       break;
 39028: 
 39028:     case WM_ADJUSTFRAMEPOS:
 39028:       if (mChromeHidden && ((PSWP)mp1)->fl & SWP_RESTORE) {
 39028:         WinSetParent(mTitleBar, HWND_OBJECT, TRUE);
 39028:         WinSetParent(mSysMenu, HWND_OBJECT, TRUE);
 39028:         WinSetParent(mMinMax, HWND_OBJECT, TRUE);
 39028:       }
 39028:       break;
 39028: 
 39028:     case WM_DESTROY:
 39028:       DEBUGFOCUS(frame WM_DESTROY);
 39028:       WinSubclassWindow(mFrameWnd, mPrevFrameProc);
 39028:       WinSetWindowPtr(mFrameWnd, QWL_USER, 0);
 39028:       break;
 39028: 
 39028:     case WM_INITMENU:
 39028:       // If we are in fullscreen/kiosk mode, disable maximize menu item.
 39028:       if (mChromeHidden &&
 39028:           SHORT1FROMMP(mp1) == SC_SYSMENU &&
 39028:           WinQueryWindowULong(mFrameWnd, QWL_STYLE) & WS_MINIMIZED) {
 39028:         MENUITEM menuitem;
 39028:         WinSendMsg(WinWindowFromID(mFrameWnd, FID_SYSMENU), MM_QUERYITEM,
 39028:                    MPFROM2SHORT(SC_SYSMENU, FALSE), MPARAM(&menuitem));
 39028:         mresult = (*mPrevFrameProc)(mFrameWnd, msg, mp1, mp2);
 39028:         WinEnableMenuItem(menuitem.hwndSubMenu, SC_MAXIMIZE, FALSE);
 80486:         isDone = true;
 39028:       }
 39028:       break;
 39028: 
 39028:     case WM_SYSCOMMAND:
 39028:       // If we are in fullscreen/kiosk mode, don't honor maximize requests.
 39028:       if (mChromeHidden &&
 39028:           SHORT1FROMMP(mp1) == SC_MAXIMIZE &&
 39028:           WinQueryWindowULong(mFrameWnd, QWL_STYLE) & WS_MINIMIZED) {
 80486:         isDone = true;
 39028:       }
 39028:       break;
 39028: 
 39028:     // When the frame is activated, set a flag to be acted on after
 39028:     // PM has finished changing focus.  When deactivated, dispatch
 39028:     // the event immediately because it doesn't affect the focus.
 39028:     case WM_ACTIVATE:
 39028:       DEBUGFOCUS(WM_ACTIVATE);
 39028:       if (mp1) {
 80486:         mNeedActivation = true;
 39028:       } else {
 80486:         mNeedActivation = false;
 39028:         DEBUGFOCUS(NS_DEACTIVATE);
 39028:         mOwner->DispatchActivationEvent(NS_DEACTIVATE);
 39028:         // Prevent the frame from automatically focusing any window
 39028:         // when it's reactivated.  Let moz set the focus to avoid
 39028:         // having non-widget children of plugins focused in error.
 39028:         WinSetWindowULong(mFrameWnd, QWL_HWNDFOCUSSAVE, 0);
 39028:       }
 39028:       break;
 39028:   }
 39028: 
 39028:   if (!isDone) {
 39028:     mresult = (*mPrevFrameProc)(mFrameWnd, msg, mp1, mp2);
 39028:   }
 39028: 
 39028:   return mresult;
 39028: }
 39028: 
 39028: //=============================================================================
 39028: 
