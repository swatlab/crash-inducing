29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
20929:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS string type implementation.
    1:  *
    1:  * In order to avoid unnecessary js_LockGCThing/js_UnlockGCThing calls, these
    1:  * native methods store strings (possibly newborn) converted from their 'this'
    1:  * parameter and arguments on the stack: 'this' conversions at argv[-1], arg
    1:  * conversions at their index (argv[0], argv[1]).  This is a legitimate method
    1:  * of rooting things that might lose their newborn root due to subsequent GC
    1:  * allocations in the same native method.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsutil.h"
55477: #include "jshash.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
40405: #include "jsfun.h"      /* for JS_ARGS_LENGTH_MAX */
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsregexp.h"
12581: #include "jsscope.h"
24499: #include "jsstaticcheck.h"
    1: #include "jsstr.h"
10992: #include "jsbit.h"
30023: #include "jsvector.h"
40405: #include "jsversion.h"
40901: 
42714: #include "jscntxtinlines.h"
55565: #include "jsinterpinlines.h"
40901: #include "jsobjinlines.h"
55711: #include "jsregexpinlines.h"
32607: #include "jsstrinlines.h"
56740: #include "jsautooplen.h"        // generated headers last
    1: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
33144: JS_STATIC_ASSERT(size_t(JSString::MAX_LENGTH) <= size_t(JSVAL_INT_MAX));
48470: JS_STATIC_ASSERT(JSString::MAX_LENGTH <= JSVAL_INT_MAX);
33144: 
54707: JS_STATIC_ASSERT(JS_EXTERNAL_STRING_LIMIT == 8);
54707: JSStringFinalizeOp str_finalizers[JS_EXTERNAL_STRING_LIMIT] = {
54707:     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
54707: };
54707: 
    1: const jschar *
    1: js_GetStringChars(JSContext *cx, JSString *str)
    1: {
 4718:     if (!js_MakeStringImmutable(cx, str))
    1:         return NULL;
29366:     return str->flatChars();
    1: }
    1: 
48491: void
48491: JSString::flatten()
48491: {
48491:     JSString *topNode;
48491:     jschar *chars;
48491:     size_t capacity;
48491:     JS_ASSERT(isRope());
48491: 
48491:     /*
48491:      * This can be called from any string in the rope, so first traverse to the
48491:      * top node.
48491:      */
48491:     topNode = this;
48491:     while (topNode->isInteriorNode())
48491:         topNode = topNode->interiorNodeParent();
48491: 
48491: #ifdef DEBUG
48491:     size_t length = topNode->length();
48491: #endif
48491: 
48491:     capacity = topNode->topNodeCapacity();
48491:     chars = (jschar *) topNode->topNodeBuffer();
48491: 
48491:     /*
48491:      * To make the traversal simpler, convert the top node to be marked as an
48491:      * interior node with a NULL parent, so that we end up at NULL when we are
48491:      * done processing it.
48491:      */
56469:     topNode->convertToInteriorNode(NULL);
48491:     JSString *str = topNode, *next;
48491:     size_t pos = 0;
48491: 
48491:     /*
48491:      * Traverse the tree, making each interior string dependent on the resulting
48491:      * string.
48491:      */
56469:     while (str) {
48491:         switch (str->ropeTraversalCount()) {
48491:           case 0:
48491:             next = str->ropeLeft();
48491: 
48491:             /*
48491:              * We know the "offset" field for the new dependent string now, but
48491:              * not later, so store it early. We have to be careful with this:
48491:              * mLeft is replaced by mOffset.
48491:              */
48562:             str->startTraversalConversion(chars, pos);
48491:             str->ropeIncrementTraversalCount();
48491:             if (next->isInteriorNode()) {
48491:                 str = next;
48491:             } else {
48491:                 js_strncpy(chars + pos, next->chars(), next->length());
48491:                 pos += next->length();
48491:             }
48491:             break;
48491:           case 1:
48491:             next = str->ropeRight();
48491:             str->ropeIncrementTraversalCount();
48491:             if (next->isInteriorNode()) {
48491:                 str = next;
48491:             } else {
48491:                 js_strncpy(chars + pos, next->chars(), next->length());
48491:                 pos += next->length();
48491:             }
48491:             break;
48491:           case 2:
48491:             next = str->interiorNodeParent();
48491:             /* Make the string a dependent string dependent with the right fields. */
48562:             str->finishTraversalConversion(topNode, chars, pos);
48491:             str = next;
48491:             break;
48491:           default:
48491:             JS_NOT_REACHED("bad traversal count");
48491:         }
48491:     }
48491: 
48491:     JS_ASSERT(pos == length);
48491:     /* Set null terminator. */
48491:     chars[pos] = 0;
48491:     topNode->initFlatMutable(chars, pos, capacity);
48491: }
48491: 
49109: #ifdef JS_TRACER
49109: 
49110: int32 JS_FASTCALL
49109: js_Flatten(JSString* str)
49109: {
49109:     str->flatten();
49109:     return 0;
49109: }
49109: JS_DEFINE_CALLINFO_1(extern, INT32, js_Flatten, STRING, 0, nanojit::ACCSET_STORE_ANY)
49109: 
49109: #endif /* !JS_TRACER */
49109: 
48491: static JS_ALWAYS_INLINE size_t
48491: RopeAllocSize(const size_t length, size_t *capacity)
48491: {
48491:     static const size_t ROPE_DOUBLING_MAX = 1024 * 1024;
48491: 
48491:     size_t size;
48491:     size_t minCap = (length + 1) * sizeof(jschar);
48491: 
48491:     /*
48491:      * Grow by 12.5% if the buffer is very large. Otherwise, round up to the
48491:      * next power of 2. This is similar to what we do with arrays; see
48491:      * JSObject::ensureDenseArrayElements.
48491:      */
48491:     if (length > ROPE_DOUBLING_MAX)
48491:         size = minCap + (minCap / 8);
48491:     else
48491:         size = 1 << (JS_CeilingLog2(minCap));
48491:     *capacity = (size / sizeof(jschar)) - 1;
48491:     JS_ASSERT(size >= sizeof(JSRopeBufferInfo));
48491:     return size;
48491: }
48491: 
48491: static JS_ALWAYS_INLINE JSRopeBufferInfo *
48491: ObtainRopeBuffer(JSContext *cx, bool usingLeft, bool usingRight,
48491:                  JSRopeBufferInfo *sourceBuffer, size_t length,
48491:                  JSString *left, JSString *right)
48491: {
48491:     JSRopeBufferInfo *buf;
48491:     size_t capacity;
48491: 
48491:     /*
48491:      * We need to survive a GC upon failure and in case creating a new
48491:      * string header triggers a GC, but we've broken the invariant that
48491:      * rope top nodes always point to freeable JSRopeBufferInfo
48491:      * objects, so make them point to NULL.
48491:      */
48491:     if (usingLeft)
48491:         left->nullifyTopNodeBuffer();
48491:     if (usingRight)
48491:         right->nullifyTopNodeBuffer();
48491: 
48491:     /*
48491:      * Try to reuse sourceBuffer. If it's not suitable, free it and create a
48491:      * suitable buffer.
48491:      */
48491:     if (length <= sourceBuffer->capacity) {
48491:         buf = sourceBuffer;
48491:     } else {
48491:         size_t allocSize = RopeAllocSize(length, &capacity);
48491:         cx->free(sourceBuffer);
48491:         buf = (JSRopeBufferInfo *) cx->malloc(allocSize);
48491:         if (!buf)
48491:             return NULL;
48491:         buf->capacity = capacity;
48491:     }
48491:     return buf;
48491: }
48491: 
48491: static JS_ALWAYS_INLINE JSString *
48491: FinishConcat(JSContext *cx, bool usingLeft, bool usingRight,
48491:              JSString *left, JSString *right, size_t length,
48491:              JSRopeBufferInfo *buf)
48491: {
48491:     JSString *res = js_NewGCString(cx);
48491:     if (!res) {
48491:         cx->free(buf);
48491:         return NULL;
48491:     }
48491:     res->initTopNode(left, right, length, buf);
48491:     if (usingLeft)
48491:         left->convertToInteriorNode(res);
48491:     if (usingRight)
48491:         right->convertToInteriorNode(res);
48491:     return res;
48491: }
48491: 
18040: JSString * JS_FASTCALL
    1: js_ConcatStrings(JSContext *cx, JSString *left, JSString *right)
    1: {
48491:     size_t length, leftLen, rightLen;
48491:     bool leftRopeTop, rightRopeTop;
48491: 
48491:     leftLen = left->length();
48491:     if (leftLen == 0)
48491:         return right;
48491:     rightLen = right->length();
48491:     if (rightLen == 0)
    1:         return left;
    1: 
48491:     length = leftLen + rightLen;
48491: 
48563:     if (JSShortString::fitsIntoShortString(length)) {
48563:         JSShortString *shortStr = js_NewGCShortString(cx);
48563:         if (!shortStr)
48563:             return NULL;
48563: 
48563:         jschar *buf = shortStr->init(length);
48563:         js_short_strncpy(buf, left->chars(), leftLen);
48563:         js_short_strncpy(buf + leftLen, right->chars(), rightLen);
48563:         buf[length] = 0;
48563:         return shortStr->header();
48563:     }
48563: 
48491:     /*
48491:      * We need to enforce a tree structure in ropes: every node needs to have a
48491:      * unique parent. So, we can't have the left or right child be in the middle
48491:      * of a rope tree. One potential solution is to traverse the subtree for the
48491:      * argument string and create a new flat string, but that would add
48491:      * complexity and is a rare case, so we simply flatten the entire rope that
48491:      * contains it. The case where left and right are part of the same rope is
48491:      * handled implicitly.
48491:      */
48491:     if (left->isInteriorNode())
48491:         left->flatten();
48491:     if (right->isInteriorNode())
48491:         right->flatten();
48491: 
48491:     if (left->isMutable() && !right->isRope() &&
48491:         left->flatCapacity() >= length) {
48491:         JS_ASSERT(left->isFlat());
48491: 
48491:         /*
48491:          * If left has enough unused space at the end of its buffer that we can
48491:          * fit the entire new string there, just write there.
48491:          */
48491:         jschar *chars = left->chars();
48491:         js_strncpy(chars + leftLen, right->chars(), rightLen);
48491:         chars[length] = 0;
48491:         JSString *res = js_NewString(cx, chars, length);
48491:         if (!res)
    1:             return NULL;
48491:         res->initFlatMutable(chars, length, left->flatCapacity());
48562:         left->initDependent(res, res->flatChars(), leftLen);
48491:         return res;
48491:     }
48491: 
48491:     if (length > JSString::MAX_LENGTH) {
48491:         if (JS_ON_TRACE(cx)) {
48491:             if (!CanLeaveTrace(cx))
48491:                 return NULL;
48491:             LeaveTrace(cx);
48491:         }
48491:         js_ReportAllocationOverflow(cx);
48491:         return NULL;
48491:     }
48491: 
48491:     leftRopeTop = left->isTopNode();
48491:     rightRopeTop = right->isTopNode();
48491: 
48491:     /*
48491:      * To make traversal more manageable, we enforce that, unless the children
48491:      * are leaves, the two children of a rope node must be distinct.
48491:      */
48491:     if (left == right && leftRopeTop) {
48491:         left->flatten();
48491:         leftRopeTop = false;
48491:         rightRopeTop = false;
48491:         JS_ASSERT(leftLen = left->length());
48491:         JS_ASSERT(rightLen = right->length());
48491:         JS_ASSERT(!left->isTopNode());
48491:         JS_ASSERT(!right->isTopNode());
48491:     }
48491: 
48491:     /*
48491:      * There are 4 cases, based on whether on whether the left or right is a
55485:      * rope or non-rope string.
48491:      */
55485:     JSRopeBufferInfo *buf = NULL;
55485: 
48491:     if (leftRopeTop) {
55485:         /* Left child is a rope. */
55485:         JSRopeBufferInfo *leftBuf = left->topNodeBuffer();
55485: 
55485:         /* If both children are ropes, steal the larger buffer. */
48491:         if (JS_UNLIKELY(rightRopeTop)) {
48491:             JSRopeBufferInfo *rightBuf = right->topNodeBuffer();
48491: 
55485:             /* Put the larger buffer into 'leftBuf'. */
48491:             if (leftBuf->capacity >= rightBuf->capacity) {
48491:                 cx->free(rightBuf);
    1:             } else {
48491:                 cx->free(leftBuf);
48491:                 leftBuf = rightBuf;
48491:             }
55485:         }
55485: 
55485:         buf = ObtainRopeBuffer(cx, true, rightRopeTop, leftBuf, length, left, right);
55485:         if (!buf)
55485:             return NULL;
55485:     } else if (JS_UNLIKELY(rightRopeTop)) {
55485:         /* Right child is a rope: steal its buffer if big enough. */
55485:         JSRopeBufferInfo *rightBuf = right->topNodeBuffer();
55485: 
55485:         buf = ObtainRopeBuffer(cx, false, true, rightBuf, length, left, right);
55485:         if (!buf)
55485:             return NULL;
48491:     } else {
55485:         /* Neither child is a rope: need to make a new buffer. */
48491:         size_t capacity;
48491:         size_t allocSize = RopeAllocSize(length, &capacity);
55485:         buf = (JSRopeBufferInfo *) cx->malloc(allocSize);
48491:         if (!buf)
    1:             return NULL;
48491:         buf->capacity = capacity;
55485:     }
55485: 
55485:     return FinishConcat(cx, leftRopeTop, rightRopeTop, left, right, length, buf);
    1: }
    1: 
    1: const jschar *
48491: JSString::undepend(JSContext *cx)
    1: {
    1:     size_t n, size;
    1:     jschar *s;
    1: 
48491:     ensureNotRope();
48491: 
48491:     if (isDependent()) {
48491:         n = dependentLength();
    1:         size = (n + 1) * sizeof(jschar);
30851:         s = (jschar *) cx->malloc(size);
    1:         if (!s)
    1:             return NULL;
    1: 
48491:         js_strncpy(s, dependentChars(), n);
    1:         s[n] = 0;
48491:         initFlat(s, n);
    1: 
    1: #ifdef DEBUG
    1:         {
    1:             JSRuntime *rt = cx->runtime;
    1:             JS_RUNTIME_UNMETER(rt, liveDependentStrings);
    1:             JS_RUNTIME_UNMETER(rt, totalDependentStrings);
    1:             JS_LOCK_RUNTIME_VOID(rt,
    1:                 (rt->strdepLengthSum -= (double)n,
    1:                  rt->strdepLengthSquaredSum -= (double)n * (double)n));
    1:         }
    1: #endif
    1:     }
    1: 
48491:     return flatChars();
 4718: }
 4718: 
 4718: JSBool
 4718: js_MakeStringImmutable(JSContext *cx, JSString *str)
 4718: {
48491:     /*
48491:      * Flattening a rope may result in a dependent string, so we need to flatten
48491:      * before undepending the string.
48491:      */
48491:     str->ensureNotRope();
48491:     if (!str->ensureNotDependent(cx)) {
 4718:         JS_RUNTIME_METER(cx->runtime, badUndependStrings);
 4718:         return JS_FALSE;
 4718:     }
29366:     str->flatClearMutable();
 4718:     return JS_TRUE;
    1: }
    1: 
16519: static JSString *
48470: ArgToRootedString(JSContext *cx, uintN argc, Value *vp, uintN arg)
16519: {
16519:     if (arg >= argc)
16519:         return ATOM_TO_STRING(cx->runtime->atomState.typeAtoms[JSTYPE_VOID]);
16519:     vp += 2 + arg;
16519: 
48470:     if (vp->isObject() && !DefaultValue(cx, &vp->toObject(), JSTYPE_STRING, vp))
16519:         return NULL;
30023: 
30023:     JSString *str;
48470:     if (vp->isString()) {
48470:         str = vp->toString();
48470:     } else if (vp->isBoolean()) {
30023:         str = ATOM_TO_STRING(cx->runtime->atomState.booleanAtoms[
48470:                                   (int)vp->toBoolean()]);
48470:     } else if (vp->isNull()) {
30023:         str = ATOM_TO_STRING(cx->runtime->atomState.nullAtom);
48470:     } else if (vp->isUndefined()) {
30023:         str = ATOM_TO_STRING(cx->runtime->atomState.typeAtoms[JSTYPE_VOID]);
30023:     }
30023:     else {
48470:         str = js_NumberToString(cx, vp->toNumber());
16519:         if (str)
48470:             vp->setString(str);
30023:     }
16519:     return str;
16519: }
16519: 
    1: /*
    1:  * Forward declarations for URI encode/decode and helper routines
    1:  */
    1: static JSBool
48470: str_decodeURI(JSContext *cx, uintN argc, Value *vp);
    1: 
    1: static JSBool
48470: str_decodeURI_Component(JSContext *cx, uintN argc, Value *vp);
    1: 
    1: static JSBool
48470: str_encodeURI(JSContext *cx, uintN argc, Value *vp);
    1: 
    1: static JSBool
48470: str_encodeURI_Component(JSContext *cx, uintN argc, Value *vp);
    1: 
33589: static const uint32 OVERLONG_UTF8 = UINT32_MAX;
33589: 
    1: static uint32
    1: Utf8ToOneUcs4Char(const uint8 *utf8Buffer, int utf8Length);
    1: 
    1: /*
    1:  * Contributions from the String class to the set of methods defined for the
    1:  * global object.  escape and unescape used to be defined in the Mocha library,
    1:  * but as ECMA decided to spec them, they've been moved to the core engine
    1:  * and made ECMA-compliant.  (Incomplete escapes are interpreted as literal
    1:  * characters by unescape.)
    1:  */
    1: 
    1: /*
    1:  * Stuff to emulate the old libmocha escape, which took a second argument
    1:  * giving the type of escape to perform.  Retained for compatibility, and
    1:  * copied here to avoid reliance on net.h, mkparse.c/NET_EscapeBytes.
    1:  */
    1: 
    1: #define URL_XALPHAS     ((uint8) 1)
    1: #define URL_XPALPHAS    ((uint8) 2)
    1: #define URL_PATH        ((uint8) 4)
    1: 
    1: static const uint8 urlCharType[256] =
    1: /*      Bit 0           xalpha          -- the alphas
    1:  *      Bit 1           xpalpha         -- as xalpha but
    1:  *                             converts spaces to plus and plus to %20
    1:  *      Bit 2 ...       path            -- as xalphas but doesn't escape '/'
    1:  */
    1:     /*   0 1 2 3 4 5 6 7 8 9 A B C D E F */
    1:     {    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,       /* 0x */
    1:          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,       /* 1x */
    1:          0,0,0,0,0,0,0,0,0,0,7,4,0,7,7,4,       /* 2x   !"#$%&'()*+,-./  */
    1:          7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,       /* 3x  0123456789:;<=>?  */
    1:          7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,       /* 4x  @ABCDEFGHIJKLMNO  */
    1:          7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,7,       /* 5X  PQRSTUVWXYZ[\]^_  */
    1:          0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,       /* 6x  `abcdefghijklmno  */
    1:          7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,       /* 7X  pqrstuvwxyz{\}~  DEL */
    1:          0, };
    1: 
    1: /* This matches the ECMA escape set when mask is 7 (default.) */
    1: 
    1: #define IS_OK(C, mask) (urlCharType[((uint8) (C))] & (mask))
    1: 
 4127: /* See ECMA-262 Edition 3 B.2.1 */
    1: JSBool
48470: js_str_escape(JSContext *cx, JSObject *obj, uintN argc, Value *argv, Value *rval)
    1: {
    1:     JSString *str;
    1:     size_t i, ni, length, newlength;
    1:     const jschar *chars;
    1:     jschar *newchars;
    1:     jschar ch;
    1:     jsint mask;
    1:     jsdouble d;
    1:     const char digits[] = {'0', '1', '2', '3', '4', '5', '6', '7',
    1:                            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
    1: 
    1:     mask = URL_XALPHAS | URL_XPALPHAS | URL_PATH;
    1:     if (argc > 1) {
40828:         if (!ValueToNumber(cx, argv[1], &d))
    1:             return JS_FALSE;
    1:         if (!JSDOUBLE_IS_FINITE(d) ||
    1:             (mask = (jsint)d) != d ||
    1:             mask & ~(URL_XALPHAS | URL_XPALPHAS | URL_PATH))
    1:         {
    1:             char numBuf[12];
    1:             JS_snprintf(numBuf, sizeof numBuf, "%lx", (unsigned long) mask);
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_STRING_MASK, numBuf);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
16519:     str = ArgToRootedString(cx, argc, argv - 2, 0);
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
29366:     str->getCharsAndLength(chars, length);
 4718:     newlength = length;
    1: 
    1:     /* Take a first pass and see how big the result string will need to be. */
    1:     for (i = 0; i < length; i++) {
    1:         if ((ch = chars[i]) < 128 && IS_OK(ch, mask))
    1:             continue;
    1:         if (ch < 256) {
    1:             if (mask == URL_XPALPHAS && ch == ' ')
    1:                 continue;   /* The character will be encoded as '+' */
    1:             newlength += 2; /* The character will be encoded as %XX */
    1:         } else {
    1:             newlength += 5; /* The character will be encoded as %uXXXX */
    1:         }
    1: 
    1:         /*
    1:          * This overflow test works because newlength is incremented by at
    1:          * most 5 on each iteration.
    1:          */
    1:         if (newlength < length) {
12983:             js_ReportAllocationOverflow(cx);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     if (newlength >= ~(size_t)0 / sizeof(jschar)) {
12983:         js_ReportAllocationOverflow(cx);
    1:         return JS_FALSE;
    1:     }
    1: 
30851:     newchars = (jschar *) cx->malloc((newlength + 1) * sizeof(jschar));
    1:     if (!newchars)
    1:         return JS_FALSE;
    1:     for (i = 0, ni = 0; i < length; i++) {
    1:         if ((ch = chars[i]) < 128 && IS_OK(ch, mask)) {
    1:             newchars[ni++] = ch;
    1:         } else if (ch < 256) {
    1:             if (mask == URL_XPALPHAS && ch == ' ') {
    1:                 newchars[ni++] = '+'; /* convert spaces to pluses */
    1:             } else {
    1:                 newchars[ni++] = '%';
    1:                 newchars[ni++] = digits[ch >> 4];
    1:                 newchars[ni++] = digits[ch & 0xF];
    1:             }
    1:         } else {
    1:             newchars[ni++] = '%';
    1:             newchars[ni++] = 'u';
    1:             newchars[ni++] = digits[ch >> 12];
    1:             newchars[ni++] = digits[(ch & 0xF00) >> 8];
    1:             newchars[ni++] = digits[(ch & 0xF0) >> 4];
    1:             newchars[ni++] = digits[ch & 0xF];
    1:         }
    1:     }
    1:     JS_ASSERT(ni == newlength);
    1:     newchars[newlength] = 0;
    1: 
 4718:     str = js_NewString(cx, newchars, newlength);
    1:     if (!str) {
30851:         cx->free(newchars);
    1:         return JS_FALSE;
    1:     }
48470:     rval->setString(str);
    1:     return JS_TRUE;
    1: }
    1: #undef IS_OK
    1: 
    1: static JSBool
48470: str_escape(JSContext *cx, uintN argc, Value *vp)
 4127: {
48470:     JSObject *obj = ComputeThisFromVp(cx, vp);
11809:     return obj && js_str_escape(cx, obj, argc, vp + 2, vp);
 4127: }
 4127: 
 4127: /* See ECMA-262 Edition 3 B.2.2 */
 4127: static JSBool
48470: str_unescape(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1:     size_t i, ni, length;
    1:     const jschar *chars;
    1:     jschar *newchars;
    1:     jschar ch;
    1: 
16519:     str = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
29366:     str->getCharsAndLength(chars, length);
    1: 
    1:     /* Don't bother allocating less space for the new string. */
30851:     newchars = (jschar *) cx->malloc((length + 1) * sizeof(jschar));
    1:     if (!newchars)
    1:         return JS_FALSE;
    1:     ni = i = 0;
    1:     while (i < length) {
    1:         ch = chars[i++];
    1:         if (ch == '%') {
    1:             if (i + 1 < length &&
    1:                 JS7_ISHEX(chars[i]) && JS7_ISHEX(chars[i + 1]))
    1:             {
    1:                 ch = JS7_UNHEX(chars[i]) * 16 + JS7_UNHEX(chars[i + 1]);
    1:                 i += 2;
    1:             } else if (i + 4 < length && chars[i] == 'u' &&
    1:                        JS7_ISHEX(chars[i + 1]) && JS7_ISHEX(chars[i + 2]) &&
    1:                        JS7_ISHEX(chars[i + 3]) && JS7_ISHEX(chars[i + 4]))
    1:             {
    1:                 ch = (((((JS7_UNHEX(chars[i + 1]) << 4)
    1:                         + JS7_UNHEX(chars[i + 2])) << 4)
    1:                       + JS7_UNHEX(chars[i + 3])) << 4)
    1:                     + JS7_UNHEX(chars[i + 4]);
    1:                 i += 5;
    1:             }
    1:         }
    1:         newchars[ni++] = ch;
    1:     }
    1:     newchars[ni] = 0;
    1: 
 4718:     str = js_NewString(cx, newchars, ni);
    1:     if (!str) {
30851:         cx->free(newchars);
    1:         return JS_FALSE;
    1:     }
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_UNEVAL
    1: static JSBool
48470: str_uneval(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1: 
48470:     str = js_ValueToSource(cx, argc != 0 ? vp[2] : UndefinedValue());
    1:     if (!str)
    1:         return JS_FALSE;
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: #endif
    1: 
    1: const char js_escape_str[] = "escape";
    1: const char js_unescape_str[] = "unescape";
    1: #if JS_HAS_UNEVAL
    1: const char js_uneval_str[] = "uneval";
    1: #endif
    1: const char js_decodeURI_str[] = "decodeURI";
    1: const char js_encodeURI_str[] = "encodeURI";
    1: const char js_decodeURIComponent_str[] = "decodeURIComponent";
    1: const char js_encodeURIComponent_str[] = "encodeURIComponent";
    1: 
    1: static JSFunctionSpec string_functions[] = {
16519:     JS_FN(js_escape_str,             str_escape,                1,0),
16519:     JS_FN(js_unescape_str,           str_unescape,              1,0),
    1: #if JS_HAS_UNEVAL
16519:     JS_FN(js_uneval_str,             str_uneval,                1,0),
    1: #endif
16519:     JS_FN(js_decodeURI_str,          str_decodeURI,             1,0),
16519:     JS_FN(js_encodeURI_str,          str_encodeURI,             1,0),
16519:     JS_FN(js_decodeURIComponent_str, str_decodeURI_Component,   1,0),
16519:     JS_FN(js_encodeURIComponent_str, str_encodeURI_Component,   1,0),
 4127: 
 4127:     JS_FS_END
    1: };
    1: 
    1: jschar      js_empty_ucstr[]  = {0};
    1: JSSubString js_EmptySubString = {0, js_empty_ucstr};
    1: 
    1: static JSBool
48470: str_getProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
    1:     JSString *str;
26273: 
48470:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
40826:         if (obj->getClass() == &js_StringClass) {
    1:             /* Follow ECMA-262 by fetching intrinsic length of our string. */
48470:             str = obj->getPrimitiveThis().toString();
    1:         } else {
    1:             /* Preserve compatibility: convert obj to a string primitive. */
48470:             str = js_ValueToString(cx, ObjectValue(*obj));
    1:             if (!str)
    1:                 return JS_FALSE;
    1:         }
    1: 
48470:         vp->setInt32(str->length());
    1:     }
26273: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: #define STRING_ELEMENT_ATTRS (JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_PERMANENT)
    1: 
    1: static JSBool
    1: str_enumerate(JSContext *cx, JSObject *obj)
    1: {
    1:     JSString *str, *str1;
    1:     size_t i, length;
    1: 
48470:     str = obj->getPrimitiveThis().toString();
    1: 
29366:     length = str->length();
    1:     for (i = 0; i < length; i++) {
 4076:         str1 = js_NewDependentString(cx, str, i, 1);
    1:         if (!str1)
    1:             return JS_FALSE;
48470:         if (!obj->defineProperty(cx, INT_TO_JSID(i), StringValue(str1),
48470:                                  PropertyStub, PropertyStub,
32573:                                  STRING_ELEMENT_ATTRS)) {
    1:             return JS_FALSE;
    1:         }
    1:     }
47569: 
47569:     return obj->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom),
48470:                                UndefinedValue(), NULL, NULL,
47569:                                JSPROP_PERMANENT | JSPROP_READONLY | JSPROP_SHARED);
    1: }
    1: 
    1: static JSBool
48470: str_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:             JSObject **objp)
    1: {
54169:     if (!JSID_IS_INT(id))
    1:         return JS_TRUE;
    1: 
48470:     JSString *str = obj->getPrimitiveThis().toString();
48470: 
48470:     jsint slot = JSID_TO_INT(id);
29366:     if ((size_t)slot < str->length()) {
48470:         JSString *str1 = JSString::getUnitString(cx, str, size_t(slot));
    1:         if (!str1)
    1:             return JS_FALSE;
48470:         if (!obj->defineProperty(cx, id, StringValue(str1), NULL, NULL,
32573:                                  STRING_ELEMENT_ATTRS)) {
    1:             return JS_FALSE;
    1:         }
    1:         *objp = obj;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
48470: Class js_StringClass = {
    1:     js_String_str,
31452:     JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_NEW_RESOLVE |
53557:     JSCLASS_HAS_CACHED_PROTO(JSProto_String),
48622:     PropertyStub,   /* addProperty */
48622:     PropertyStub,   /* delProperty */
48622:     str_getProperty,
48622:     PropertyStub,   /* setProperty */
48622:     str_enumerate,
48622:     (JSResolveOp)str_resolve,
48622:     ConvertStub
    1: };
    1: 
11809: #define NORMALIZE_THIS(cx,vp,str)                                             \
11809:     JS_BEGIN_MACRO                                                            \
48470:         if (vp[1].isString()) {                                               \
48470:             str = vp[1].toString();                                           \
11809:         } else {                                                              \
11809:             str = NormalizeThis(cx, vp);                                      \
11809:             if (!str)                                                         \
11809:                 return JS_FALSE;                                              \
11809:         }                                                                     \
11809:     JS_END_MACRO
11809: 
11809: static JSString *
48470: NormalizeThis(JSContext *cx, Value *vp)
11809: {
55712:     if (vp[1].isNullOrUndefined() && !ComputeThisFromVp(cx, vp))
11809:         return NULL;
35471: 
35471:     /*
55711:      * String.prototype.{toString,toSource,valueOf} throw a TypeError if the
55711:      * this-argument is not a string or a String object. So those methods use
55711:      * js::GetPrimitiveThis which provides that behavior.
55711:      *
55711:      * By standard, the rest of the String methods must ToString the
55711:      * this-argument rather than throw a TypeError. So those methods use
55711:      * NORMALIZE_THIS (and thus NormalizeThis) instead.
35471:      */
48470:     if (vp[1].isObject()) {
48470:         JSObject *obj = &vp[1].toObject();
35471:         if (obj->getClass() == &js_StringClass) {
40901:             vp[1] = obj->getPrimitiveThis();
48470:             return vp[1].toString();
48470:         }
48470:     }
48470: 
48470:     JSString *str = js_ValueToString(cx, vp[1]);
11809:     if (!str)
11809:         return NULL;
48470:     vp[1].setString(str);
11809:     return str;
11809: }
11809: 
    1: #if JS_HAS_TOSOURCE
    1: 
    1: /*
    1:  * String.prototype.quote is generic (as are most string methods), unlike
    1:  * toSource, toString, and valueOf.
    1:  */
    1: static JSBool
48470: str_quote(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1: 
11809:     NORMALIZE_THIS(cx, vp, str);
    1:     str = js_QuoteString(cx, str, '"');
    1:     if (!str)
    1:         return JS_FALSE;
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: str_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
55711:     if (!GetPrimitiveThis(cx, vp, &str))
55711:         return false;
55711: 
55711:     str = js_QuoteString(cx, str, '"');
55711:     if (!str)
55711:         return false;
55711: 
    1:     char buf[16];
55711:     size_t j = JS_snprintf(buf, sizeof buf, "(new String(");
55711: 
29366:     const jschar *s;
55711:     size_t k;
29366:     str->getCharsAndLength(s, k);
55711: 
55711:     size_t n = j + k + 2;
55711:     jschar *t = (jschar *) cx->malloc((n + 1) * sizeof(jschar));
    1:     if (!t)
55711:         return false;
55711: 
55711:     size_t i;
    1:     for (i = 0; i < j; i++)
    1:         t[i] = buf[i];
    1:     for (j = 0; j < k; i++, j++)
    1:         t[i] = s[j];
    1:     t[i++] = ')';
    1:     t[i++] = ')';
    1:     t[i] = 0;
55711: 
 4718:     str = js_NewString(cx, t, n);
    1:     if (!str) {
30851:         cx->free(t);
55711:         return false;
    1:     }
48470:     vp->setString(str);
55711:     return true;
    1: }
    1: 
    1: #endif /* JS_HAS_TOSOURCE */
    1: 
30443: JSBool
48470: js_str_toString(JSContext *cx, uintN argc, Value *vp)
    1: {
55711:     JSString *str;
55711:     if (!GetPrimitiveThis(cx, vp, &str))
48470:         return false;
55711:     vp->setString(str);
48470:     return true;
    1: }
    1: 
    1: /*
    1:  * Java-like string native methods.
    1:  */
20929: 
20929: static JSString *
20929: SubstringTail(JSContext *cx, JSString *str, jsdouble length, jsdouble begin, jsdouble end)
    1: {
    1:     if (begin < 0)
    1:         begin = 0;
    1:     else if (begin > length)
    1:         begin = length;
    1: 
    1:     if (end < 0)
    1:         end = 0;
    1:     else if (end > length)
    1:         end = length;
    1:     if (end < begin) {
    1:         /* ECMA emulates old JDK1.0 java.lang.String.substring. */
    1:         jsdouble tmp = begin;
    1:         begin = end;
    1:         end = tmp;
    1:     }
20929: 
20929:     return js_NewDependentString(cx, str, (size_t)begin, (size_t)(end - begin));
20929: }
20929: 
20929: static JSBool
48470: str_substring(JSContext *cx, uintN argc, Value *vp)
20929: {
20929:     JSString *str;
20929:     jsdouble d;
20929:     jsdouble length, begin, end;
20929: 
20929:     NORMALIZE_THIS(cx, vp, str);
20929:     if (argc != 0) {
40828:         if (!ValueToNumber(cx, vp[2], &d))
20929:             return JS_FALSE;
29366:         length = str->length();
20929:         begin = js_DoubleToInteger(d);
56555:         if (argc == 1 || vp[3].isUndefined()) {
20929:             end = length;
20929:         } else {
40828:             if (!ValueToNumber(cx, vp[3], &d))
20929:                 return JS_FALSE;
20929:             end = js_DoubleToInteger(d);
20929:         }
20929: 
20929:         str = SubstringTail(cx, str, length, begin, end);
    1:         if (!str)
    1:             return JS_FALSE;
    1:     }
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
18703: JSString* JS_FASTCALL
18703: js_toLowerCase(JSContext *cx, JSString *str)
    1: {
    1:     size_t i, n;
29366:     const jschar *s;
29366:     jschar *news;
29366: 
29366:     str->getCharsAndLength(s, n);
30851:     news = (jschar *) cx->malloc((n + 1) * sizeof(jschar));
    1:     if (!news)
18703:         return NULL;
    1:     for (i = 0; i < n; i++)
    1:         news[i] = JS_TOLOWER(s[i]);
    1:     news[n] = 0;
 4718:     str = js_NewString(cx, news, n);
    1:     if (!str) {
30851:         cx->free(news);
18703:         return NULL;
18703:     }
18703:     return str;
18703: }
18703: 
20408: static JSBool
48470: str_toLowerCase(JSContext *cx, uintN argc, Value *vp)
18703: {
18703:     JSString *str;
18703: 
18703:     NORMALIZE_THIS(cx, vp, str);
18703:     str = js_toLowerCase(cx, str);
18703:     if (!str)
    1:         return JS_FALSE;
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: str_toLocaleLowerCase(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1: 
    1:     /*
    1:      * Forcefully ignore the first (or any) argument and return toLowerCase(),
    1:      * ECMA has reserved that argument, presumably for defining the locale.
    1:      */
    1:     if (cx->localeCallbacks && cx->localeCallbacks->localeToLowerCase) {
11809:         NORMALIZE_THIS(cx, vp, str);
48470:         return cx->localeCallbacks->localeToLowerCase(cx, str, Jsvalify(vp));
 4127:     }
20408:     return str_toLowerCase(cx, 0, vp);
18703: }
18703: 
18703: JSString* JS_FASTCALL
18703: js_toUpperCase(JSContext *cx, JSString *str)
    1: {
    1:     size_t i, n;
29366:     const jschar *s;
29366:     jschar *news;
29366: 
29366:     str->getCharsAndLength(s, n);
30851:     news = (jschar *) cx->malloc((n + 1) * sizeof(jschar));
    1:     if (!news)
18703:         return NULL;
    1:     for (i = 0; i < n; i++)
    1:         news[i] = JS_TOUPPER(s[i]);
    1:     news[n] = 0;
 4718:     str = js_NewString(cx, news, n);
    1:     if (!str) {
30851:         cx->free(news);
18703:         return NULL;
18703:     }
18703:     return str;
18703: }
18703: 
20408: static JSBool
48470: str_toUpperCase(JSContext *cx, uintN argc, Value *vp)
18703: {
18703:     JSString *str;
18703: 
18703:     NORMALIZE_THIS(cx, vp, str);
18703:     str = js_toUpperCase(cx, str);
18703:     if (!str)
    1:         return JS_FALSE;
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: str_toLocaleUpperCase(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1: 
    1:     /*
    1:      * Forcefully ignore the first (or any) argument and return toUpperCase(),
11835:      * ECMA has reserved that argument, presumably for defining the locale.
    1:      */
    1:     if (cx->localeCallbacks && cx->localeCallbacks->localeToUpperCase) {
11809:         NORMALIZE_THIS(cx, vp, str);
48470:         return cx->localeCallbacks->localeToUpperCase(cx, str, Jsvalify(vp));
 4127:     }
20408:     return str_toUpperCase(cx, 0, vp);
    1: }
    1: 
    1: static JSBool
48470: str_localeCompare(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str, *thatStr;
    1: 
11809:     NORMALIZE_THIS(cx, vp, str);
    1:     if (argc == 0) {
48470:         vp->setInt32(0);
    1:     } else {
 4127:         thatStr = js_ValueToString(cx, vp[2]);
    1:         if (!thatStr)
    1:             return JS_FALSE;
    1:         if (cx->localeCallbacks && cx->localeCallbacks->localeCompare) {
48470:             vp[2].setString(thatStr);
48470:             return cx->localeCallbacks->localeCompare(cx, str, thatStr, Jsvalify(vp));
48470:         }
48470:         vp->setInt32(js_CompareStrings(str, thatStr));
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
49109: JSBool
49109: js_str_charAt(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
 4127:     jsint i;
    1:     jsdouble d;
 4127: 
48470:     if (vp[1].isString() && argc != 0 && vp[2].isInt32()) {
48470:         str = vp[1].toString();
48470:         i = vp[2].toInt32();
29366:         if ((size_t)i >= str->length())
 4127:             goto out_of_range;
 4127:     } else {
35471:         NORMALIZE_THIS(cx, vp, str);
    1: 
    1:         if (argc == 0) {
    1:             d = 0.0;
    1:         } else {
40828:             if (!ValueToNumber(cx, vp[2], &d))
    1:                 return JS_FALSE;
    1:             d = js_DoubleToInteger(d);
    1:         }
    1: 
29366:         if (d < 0 || str->length() <= d)
 4127:             goto out_of_range;
 4127:         i = (jsint) d;
 4127:     }
 4127: 
32607:     str = JSString::getUnitString(cx, str, size_t(i));
    1:     if (!str)
    1:         return JS_FALSE;
48470:     vp->setString(str);
    1:     return JS_TRUE;
 4127: 
 4127: out_of_range:
48470:     vp->setString(cx->runtime->emptyString);
 4127:     return JS_TRUE;
    1: }
    1: 
49109: JSBool
49109: js_str_charCodeAt(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
 4127:     jsint i;
    1:     jsdouble d;
 4127: 
48470:     if (vp[1].isString() && argc != 0 && vp[2].isInt32()) {
48470:         str = vp[1].toString();
48470:         i = vp[2].toInt32();
29366:         if ((size_t)i >= str->length())
 4127:             goto out_of_range;
 4127:     } else {
35471:         NORMALIZE_THIS(cx, vp, str);
    1: 
    1:         if (argc == 0) {
    1:             d = 0.0;
    1:         } else {
40828:             if (!ValueToNumber(cx, vp[2], &d))
    1:                 return JS_FALSE;
    1:             d = js_DoubleToInteger(d);
    1:         }
    1: 
29366:         if (d < 0 || str->length() <= d)
 4127:             goto out_of_range;
 4127:         i = (jsint) d;
 4127:     }
 4127: 
48470:     vp->setInt32(str->chars()[i]);
 3164:     return JS_TRUE;
 4127: 
 4127: out_of_range:
48470:     vp->setDouble(js_NaN);
    1:     return JS_TRUE;
    1: }
    1: 
    1: jsint
33165: js_BoyerMooreHorspool(const jschar *text, jsuint textlen,
33165:                       const jschar *pat, jsuint patlen)
    1: {
33165:     uint8 skip[sBMHCharSetSize];
33165: 
33165:     JS_ASSERT(0 < patlen && patlen <= sBMHPatLenMax);
33165:     for (jsuint i = 0; i < sBMHCharSetSize; i++)
33165:         skip[i] = (uint8)patlen;
33165:     jsuint m = patlen - 1;
33165:     for (jsuint i = 0; i < m; i++) {
33165:         jschar c = pat[i];
33165:         if (c >= sBMHCharSetSize)
33165:             return sBMHBadPattern;
33165:         skip[c] = (uint8)(m - i);
33165:     }
33151:     jschar c;
33165:     for (jsuint k = m;
    1:          k < textlen;
33165:          k += ((c = text[k]) >= sBMHCharSetSize) ? patlen : skip[c]) {
33165:         for (jsuint i = k, j = m; ; i--, j--) {
    1:             if (text[i] != pat[j])
    1:                 break;
33165:             if (j == 0)
33165:                 return static_cast<jsint>(i);  /* safe: max string size */
33165:         }
33165:     }
33165:     return -1;
33165: }
33165: 
40288: struct MemCmp {
40288:     typedef jsuint Extent;
40288:     static JS_ALWAYS_INLINE Extent computeExtent(const jschar *, jsuint patlen) {
40288:         return (patlen - 1) * sizeof(jschar);
40288:     }
40288:     static JS_ALWAYS_INLINE bool match(const jschar *p, const jschar *t, Extent extent) {
40288:         return memcmp(p, t, extent) == 0;
40288:     }
40288: };
40288: 
40288: struct ManualCmp {
40288:     typedef const jschar *Extent;
40288:     static JS_ALWAYS_INLINE Extent computeExtent(const jschar *pat, jsuint patlen) {
40288:         return pat + patlen;
40288:     }
40288:     static JS_ALWAYS_INLINE bool match(const jschar *p, const jschar *t, Extent extent) {
40288:         for (; p != extent; ++p, ++t) {
40288:             if (*p != *t)
40288:                 return false;
40288:         }
40288:         return true;
40288:     }
40288: };
40288: 
40288: template <class InnerMatch>
40288: static jsint
41865: UnrolledMatch(const jschar *text, jsuint textlen, const jschar *pat, jsuint patlen)
40288: {
40288:     JS_ASSERT(patlen > 0 && textlen > 0);
40288:     const jschar *textend = text + textlen - (patlen - 1);
40288:     const jschar p0 = *pat;
40288:     const jschar *const patNext = pat + 1;
40288:     const typename InnerMatch::Extent extent = InnerMatch::computeExtent(pat, patlen);
40288:     uint8 fixup;
40288: 
40288:     const jschar *t = text;
40288:     switch ((textend - t) & 7) {
40288:       case 0: if (*t++ == p0) { fixup = 8; goto match; }
40288:       case 7: if (*t++ == p0) { fixup = 7; goto match; }
40288:       case 6: if (*t++ == p0) { fixup = 6; goto match; }
40288:       case 5: if (*t++ == p0) { fixup = 5; goto match; }
40288:       case 4: if (*t++ == p0) { fixup = 4; goto match; }
40288:       case 3: if (*t++ == p0) { fixup = 3; goto match; }
40288:       case 2: if (*t++ == p0) { fixup = 2; goto match; }
40288:       case 1: if (*t++ == p0) { fixup = 1; goto match; }
41865:     }
41865:     while (t != textend) {
41865:       if (t[0] == p0) { t += 1; fixup = 8; goto match; }
41865:       if (t[1] == p0) { t += 2; fixup = 7; goto match; }
41865:       if (t[2] == p0) { t += 3; fixup = 6; goto match; }
41865:       if (t[3] == p0) { t += 4; fixup = 5; goto match; }
41865:       if (t[4] == p0) { t += 5; fixup = 4; goto match; }
41865:       if (t[5] == p0) { t += 6; fixup = 3; goto match; }
41865:       if (t[6] == p0) { t += 7; fixup = 2; goto match; }
41865:       if (t[7] == p0) { t += 8; fixup = 1; goto match; }
41865:         t += 8;
40288:         continue;
40288:         do {
40288:             if (*t++ == p0) {
40288:               match:
40288:                 if (!InnerMatch::match(patNext, t, extent))
40288:                     goto failed_match;
40288:                 return t - text - 1;
40288:             }
40288:           failed_match:;
40288:         } while (--fixup > 0);
40288:     }
40288:     return -1;
40288: }
40288: 
33165: static JS_ALWAYS_INLINE jsint
33165: StringMatch(const jschar *text, jsuint textlen,
33165:             const jschar *pat, jsuint patlen)
33165: {
33165:     if (patlen == 0)
33165:         return 0;
33165:     if (textlen < patlen)
33165:         return -1;
33165: 
40415: #if defined(__i386__) || defined(_M_IX86) || defined(__i386)
35107:     /*
35107:      * Given enough registers, the unrolled loop below is faster than the
35107:      * following loop. 32-bit x86 does not have enough registers.
35107:      */
35107:     if (patlen == 1) {
35107:         const jschar p0 = *pat;
35107:         for (const jschar *c = text, *end = text + textlen; c != end; ++c) {
35107:             if (*c == p0)
35107:                 return c - text;
35107:         }
35107:         return -1;
35107:     }
35107: #endif
35107: 
35107:     /*
35306:      * If the text or pattern string is short, BMH will be more expensive than
35306:      * the basic linear scan due to initialization cost and a more complex loop
35306:      * body. While the correct threshold is input-dependent, we can make a few
35306:      * conservative observations:
35306:      *  - When |textlen| is "big enough", the initialization time will be
35306:      *    proportionally small, so the worst-case slowdown is minimized.
35306:      *  - When |patlen| is "too small", even the best case for BMH will be
35306:      *    slower than a simple scan for large |textlen| due to the more complex
35306:      *    loop body of BMH.
35306:      * From this, the values for "big enough" and "too small" are determined
35306:      * empirically. See bug 526348.
35107:      */
35306:     if (textlen >= 512 && patlen >= 11 && patlen <= sBMHPatLenMax) {
33165:         jsint index = js_BoyerMooreHorspool(text, textlen, pat, patlen);
33165:         if (index != sBMHBadPattern)
33165:             return index;
33165:     }
33165: 
35107:     /*
40288:      * For big patterns with large potential overlap we want the SIMD-optimized
40288:      * speed of memcmp. For small patterns, a simple loop is faster.
40288:      *
40288:      * FIXME: Linux memcmp performance is sad and the manual loop is faster.
35107:      */
40288:     return
40288: #if !defined(__linux__)
41865:            patlen > 128 ? UnrolledMatch<MemCmp>(text, textlen, pat, patlen)
40288:                         :
35107: #endif
41865:                           UnrolledMatch<ManualCmp>(text, textlen, pat, patlen);
    1: }
    1: 
48536: static const size_t sRopeMatchThresholdRatioLog2 = 5;
48536: 
48536: static jsint
48536: RopeMatch(JSString *textstr, const jschar *pat, jsuint patlen)
48536: {
48536:     JS_ASSERT(textstr->isTopNode());
48536: 
48536:     if (patlen == 0)
48536:         return 0;
48536:     if (textstr->length() < patlen)
48536:         return -1;
48536: 
48536:     /*
48536:      * List of leaf nodes in the rope. If we run out of memory when trying to
48536:      * append to this list, we can still fall back to StringMatch, so use the
48536:      * system allocator so we don't report OOM in that case.
48536:      */
48536:     Vector<JSString *, 16, SystemAllocPolicy> strs;
48536: 
48536:     /*
48536:      * We don't want to do rope matching if there is a poor node-to-char ratio,
48536:      * since this means spending a lot of time in the match loop below. We also
48536:      * need to build the list of leaf nodes. Do both here: iterate over the
48536:      * nodes so long as there are not too many.
48536:      */
48536:     size_t textstrlen = textstr->length();
48536:     size_t threshold = textstrlen >> sRopeMatchThresholdRatioLog2;
48536:     JSRopeLeafIterator iter(textstr);
48536:     for (JSString *str = iter.init(); str; str = iter.next()) {
48536:         if (threshold-- == 0 || !strs.append(str))
48536:             return StringMatch(textstr->chars(), textstrlen, pat, patlen);
48536:     }
48536: 
48536:     /* Absolute offset from the beginning of the logical string textstr. */
48536:     jsint pos = 0;
48536: 
48536:     // TODO: consider branching to a simple loop if patlen == 1
48536: 
48536:     for (JSString **outerp = strs.begin(); outerp != strs.end(); ++outerp) {
48536:         /* First try to match without spanning two nodes. */
48536:         const jschar *chars;
48536:         size_t len;
48536:         (*outerp)->getCharsAndLength(chars, len);
48536:         jsint matchResult = StringMatch(chars, len, pat, patlen);
48536:         if (matchResult != -1)
48536:             return pos + matchResult;
48536: 
48536:         /* Test the overlap. */
48536:         JSString **innerp = outerp;
48536: 
48536:         /*
48536:          * Start searching at the first place where StringMatch wouldn't have
48536:          * found the match.
48536:          */
48536:         const jschar *const text = chars + (patlen > len ? 0 : len - patlen + 1);
48536:         const jschar *const textend = chars + len;
48536:         const jschar p0 = *pat;
48536:         const jschar *const p1 = pat + 1;
48536:         const jschar *const patend = pat + patlen;
48536:         for (const jschar *t = text; t != textend; ) {
48536:             if (*t++ != p0)
48536:                 continue;
48536:             const jschar *ttend = textend;
48536:             for (const jschar *pp = p1, *tt = t; pp != patend; ++pp, ++tt) {
48536:                 while (tt == ttend) {
48536:                     if (++innerp == strs.end())
48536:                         return -1;
48536:                     (*innerp)->getCharsAndEnd(tt, ttend);
48536:                 }
48536:                 if (*pp != *tt)
48536:                     goto break_continue;
48536:             }
48536: 
48536:             /* Matched! */
48536:             return pos + (t - chars) - 1;  /* -1 because of *t++ above */
48536: 
48536:           break_continue:;
48536:         }
48536: 
48536:         pos += len;
48536:     }
48536: 
48536:     return -1;
48536: }
48536: 
    1: static JSBool
48470: str_indexOf(JSContext *cx, uintN argc, Value *vp)
    1: {
33165: 
33165:     JSString *str;
33165:     NORMALIZE_THIS(cx, vp, str);
33165: 
33165:     JSString *patstr = ArgToRootedString(cx, argc, vp, 0);
33165:     if (!patstr)
33165:         return JS_FALSE;
33165: 
33165:     const jschar *text = str->chars();
33165:     jsuint textlen = str->length();
33165:     const jschar *pat = patstr->chars();
33165:     jsuint patlen = patstr->length();
33165: 
33165:     jsuint start;
33165:     if (argc > 1) {
48470:         if (vp[3].isInt32()) {
48470:             jsint i = vp[3].toInt32();
33165:             if (i <= 0) {
33165:                 start = 0;
33165:             } else if (jsuint(i) > textlen) {
33165:                 start = 0;
33165:                 textlen = 0;
33151:             } else {
33165:                 start = i;
33165:                 text += start;
33165:                 textlen -= start;
33165:             }
33165:         } else {
40828:             jsdouble d;
40828:             if (!ValueToNumber(cx, vp[3], &d))
    1:                 return JS_FALSE;
    1:             d = js_DoubleToInteger(d);
33165:             if (d <= 0) {
33165:                 start = 0;
33165:             } else if (d > textlen) {
33165:                 start = 0;
33165:                 textlen = 0;
    1:             } else {
33165:                 start = (jsint)d;
33165:                 text += start;
33165:                 textlen -= start;
33165:             }
15342:         }
15342:     } else {
33165:         start = 0;
33165:     }
33165: 
33165:     jsint match = StringMatch(text, textlen, pat, patlen);
48470:     vp->setInt32((match == -1) ? -1 : start + match);
33165:     return true;
    1: }
    1: 
    1: static JSBool
48470: str_lastIndexOf(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str, *str2;
    1:     const jschar *text, *pat;
    1:     jsint i, j, textlen, patlen;
    1:     jsdouble d;
    1: 
11809:     NORMALIZE_THIS(cx, vp, str);
29366:     text = str->chars();
29366:     textlen = (jsint) str->length();
    1: 
48470:     if (argc != 0 && vp[2].isString()) {
48470:         str2 = vp[2].toString();
26470:     } else {
16519:         str2 = ArgToRootedString(cx, argc, vp, 0);
16754:         if (!str2)
    1:             return JS_FALSE;
26470:     }
29366:     pat = str2->chars();
29366:     patlen = (jsint) str2->length();
    1: 
26470:     i = textlen - patlen; // Start searching here
26470:     if (i < 0) {
48470:         vp->setInt32(-1);
26470:         return JS_TRUE;
26470:     }
26470: 
    1:     if (argc > 1) {
48470:         if (vp[3].isInt32()) {
48470:             j = vp[3].toInt32();
26470:             if (j <= 0)
26470:                 i = 0;
26470:             else if (j < i)
26470:                 i = j;
26470:         } else {
40828:             if (!ValueToNumber(cx, vp[3], &d))
    1:                 return JS_FALSE;
26470:             if (!JSDOUBLE_IS_NaN(d)) {
    1:                 d = js_DoubleToInteger(d);
26470:                 if (d <= 0)
    1:                     i = 0;
26470:                 else if (d < i)
    1:                     i = (jsint)d;
    1:             }
26470:         }
    1:     }
    1: 
    1:     if (patlen == 0) {
48470:         vp->setInt32(i);
    1:         return JS_TRUE;
    1:     }
    1: 
35107:     const jschar *t = text + i;
35107:     const jschar *textend = text - 1;
35107:     const jschar p0 = *pat;
35107:     const jschar *patNext = pat + 1;
35107:     const jschar *patEnd = pat + patlen;
35107: 
35107:     for (; t != textend; --t) {
35107:         if (*t == p0) {
35107:             const jschar *t1 = t + 1;
35107:             for (const jschar *p1 = patNext; p1 != patEnd; ++p1, ++t1) {
35107:                 if (*t1 != *p1)
35107:                     goto break_continue;
35107:             }
48470:             vp->setInt32(t - text);
35107:             return JS_TRUE;
35107:         }
35107:       break_continue:;
35107:     }
35107: 
48470:     vp->setInt32(-1);
    1:     return JS_TRUE;
    1: }
    1: 
18938: static JSBool
48470: js_TrimString(JSContext *cx, Value *vp, JSBool trimLeft, JSBool trimRight)
18938: {
18938:     JSString *str;
18938:     const jschar *chars;
18938:     size_t length, begin, end;
18938: 
18938:     NORMALIZE_THIS(cx, vp, str);
29366:     str->getCharsAndLength(chars, length);
18938:     begin = 0;
18938:     end = length;
18938: 
18938:     if (trimLeft) {
18938:         while (begin < length && JS_ISSPACE(chars[begin]))
18938:             ++begin;
18938:     }
18938: 
18938:     if (trimRight) {
18938:         while (end > begin && JS_ISSPACE(chars[end-1]))
18938:             --end;
18938:     }
18938: 
18938:     str = js_NewDependentString(cx, str, begin, end - begin);
18938:     if (!str)
18938:         return JS_FALSE;
18938: 
48470:     vp->setString(str);
18938:     return JS_TRUE;
18938: }
18938: 
18938: static JSBool
48470: str_trim(JSContext *cx, uintN argc, Value *vp)
18938: {
18938:     return js_TrimString(cx, vp, JS_TRUE, JS_TRUE);
18938: }
18938: 
18938: static JSBool
48470: str_trimLeft(JSContext *cx, uintN argc, Value *vp)
18938: {
18938:     return js_TrimString(cx, vp, JS_TRUE, JS_FALSE);
18938: }
18938: 
18938: static JSBool
48470: str_trimRight(JSContext *cx, uintN argc, Value *vp)
18938: {
18938:     return js_TrimString(cx, vp, JS_FALSE, JS_TRUE);
18938: }
18938: 
    1: /*
    1:  * Perl-inspired string functions.
    1:  */
32645: 
51460: /* Result of a successfully performed flat match. */
51460: class FlatMatch
51460: {
51460:     JSString        *patstr;
51460:     const jschar    *pat;
51460:     size_t          patlen;
51460:     int32           match_;
51460: 
51460:     friend class RegExpGuard;
51460: 
51460:   public:
54398:     FlatMatch() : patstr(NULL) {} /* Old GCC wants this initialization. */
51460:     JSString *pattern() const { return patstr; }
51460:     size_t patternLength() const { return patlen; }
51460: 
33165:     /*
51460:      * @note    The match is -1 when the match is performed successfully,
51460:      *          but no match is found.
51460:      */
51460:     int32 match() const { return match_; }
51460: };
51460: 
51460: /* A regexp and optional associated object. */
51460: class RegExpPair
51460: {
51460:     JSObject    *reobj_;
51460:     RegExp      *re_;
51460: 
51460:     explicit RegExpPair(RegExp *re): re_(re) {}
51460:     friend class RegExpGuard;
51460: 
51460:   public:
51460:     /* @note    May be null. */
51460:     JSObject *reobj() const { return reobj_; }
51460:     RegExp &re() const { JS_ASSERT(re_); return *re_; }
51460: };
51460: 
51460: /*
51460:  * RegExpGuard factors logic out of String regexp operations.
33165:  *
51460:  * @param optarg    Indicates in which argument position RegExp
51460:  *                  flags will be found, if present. This is a Mozilla
51460:  *                  extension and not part of any ECMA spec.
33165:  */
32645: class RegExpGuard
32645: {
32645:     RegExpGuard(const RegExpGuard &);
32645:     void operator=(const RegExpGuard &);
32645: 
51460:     JSContext   *cx;
51460:     RegExpPair  rep;
51460:     FlatMatch   fm;
51460: 
51460:     /*
51460:      * Upper bound on the number of characters we are willing to potentially
51460:      * waste on searching for RegExp meta-characters.
51460:      */
51460:     static const size_t MAX_FLAT_PAT_LEN = 256;
32645: 
54576:     static JSString *flattenPattern(JSContext *cx, JSString *patstr) {
54576:         JSCharBuffer cb(cx);
54576:         if (!cb.reserve(patstr->length()))
54576:             return NULL;
54576: 
54576:         static const jschar ESCAPE_CHAR = '\\';
54576:         const jschar *chars = patstr->chars();
54576:         size_t len = patstr->length();
54576:         for (const jschar *it = chars; it != chars + len; ++it) {
54576:             if (RegExp::isMetaChar(*it)) {
54576:                 if (!cb.append(ESCAPE_CHAR) || !cb.append(*it))
54576:                     return NULL;
54576:             } else {
54576:                 if (!cb.append(*it))
54576:                     return NULL;
54576:             }
54576:         }
54576:         return js_NewStringFromCharBuffer(cx, cb);
54576:     }
54576: 
32645:   public:
51460:     explicit RegExpGuard(JSContext *cx) : cx(cx), rep(NULL) {}
33165: 
33165:     ~RegExpGuard() {
51460:         if (rep.re_)
51460:             rep.re_->decref(cx);
51460:     }
34376: 
33165:     /* init must succeed in order to call tryFlatMatch or normalizeRegExp. */
33165:     bool
48470:     init(uintN argc, Value *vp)
33165:     {
51460:         if (argc != 0 && VALUE_IS_REGEXP(cx, vp[2])) {
51460:             rep.reobj_ = &vp[2].toObject();
51460:             rep.re_ = RegExp::extractFrom(rep.reobj_);
51460:             rep.re_->incref(cx);
33165:         } else {
51460:             fm.patstr = ArgToRootedString(cx, argc, vp, 0);
51460:             if (!fm.patstr)
33165:                 return false;
33165:         }
33165:         return true;
33165:     }
    1: 
    1:     /*
51460:      * Attempt to match |patstr| to |textstr|. A flags argument, metachars in the
51460:      * pattern string, or a lengthy pattern string can thwart this process.
51460:      *
51460:      * @param checkMetaChars    Look for regexp metachars in the pattern string.
51460:      * @return                  Whether flat matching could be used.
33165:      */
51460:     const FlatMatch *
51460:     tryFlatMatch(JSString *textstr, uintN optarg, uintN argc, bool checkMetaChars = true)
29885:     {
51460:         if (rep.re_)
51460:             return NULL;
51460: 
51460:         fm.patstr->getCharsAndLength(fm.pat, fm.patlen);
51460: 
51460:         if (optarg < argc)
51460:             return NULL;
51460: 
51460:         if (checkMetaChars &&
51460:             (fm.patlen > MAX_FLAT_PAT_LEN || RegExp::hasMetaChars(fm.pat, fm.patlen))) {
51460:             return NULL;
51460:         }
51460: 
48536:         /*
48536:          * textstr could be a rope, so we want to avoid flattening it for as
48536:          * long as possible.
48536:          */
48536:         if (textstr->isTopNode()) {
51460:             fm.match_ = RopeMatch(textstr, fm.pat, fm.patlen);
48536:         } else {
48536:             const jschar *text;
48536:             size_t textlen;
33165:             textstr->getCharsAndLength(text, textlen);
51460:             fm.match_ = StringMatch(text, textlen, fm.pat, fm.patlen);
51460:         }
51460:         return &fm;
51460:     }
33165: 
33165:     /* If the pattern is not already a regular expression, make it so. */
51460:     const RegExpPair *
48470:     normalizeRegExp(bool flat, uintN optarg, uintN argc, Value *vp)
33165:     {
33165:         /* If we don't have a RegExp, build RegExp from pattern string. */
51460:         if (rep.re_)
51460:             return &rep;
51460: 
32645:         JSString *opt;
32645:         if (optarg < argc) {
51460:             opt = js_ValueToString(cx, vp[2 + optarg]);
    1:             if (!opt)
51460:                 return NULL;
    1:         } else {
    1:             opt = NULL;
    1:         }
51460: 
54576:         JSString *patstr;
54576:         if (flat) {
54576:             patstr = flattenPattern(cx, fm.patstr);
54576:             if (!patstr)
54576:                 return false;
54576:         } else {
54576:             patstr = fm.patstr;
54576:         }
54576:         JS_ASSERT(patstr);
54576: 
54576:         rep.re_ = RegExp::createFlagged(cx, patstr, opt);
51460:         if (!rep.re_)
51460:             return NULL;
51460:         rep.reobj_ = NULL;
51460:         return &rep;
51460:     }
51460: 
51460: #if DEBUG
51460:     bool hasRegExpPair() const { return rep.re_; }
51460: #endif
32645: };
32645: 
32645: /* js_ExecuteRegExp indicates success in two ways, based on the 'test' flag. */
32645: static JS_ALWAYS_INLINE bool
48470: Matched(bool test, const Value &v)
32645: {
48470:     return test ? v.isTrue() : !v.isNull();
32645: }
32645: 
53858: typedef bool (*DoMatchCallback)(JSContext *cx, RegExpStatics *res, size_t count, void *data);
32645: 
32645: /*
32645:  * BitOR-ing these flags allows the DoMatch caller to control when how the
32645:  * RegExp engine is called and when callbacks are fired.
32645:  */
32645: enum MatchControlFlags {
32645:    TEST_GLOBAL_BIT         = 0x1, /* use RegExp.test for global regexps */
32645:    TEST_SINGLE_BIT         = 0x2, /* use RegExp.test for non-global regexps */
32645:    CALLBACK_ON_SINGLE_BIT  = 0x4, /* fire callback on non-global match */
32645: 
32645:    MATCH_ARGS    = TEST_GLOBAL_BIT,
32645:    MATCHALL_ARGS = CALLBACK_ON_SINGLE_BIT,
32645:    REPLACE_ARGS  = TEST_GLOBAL_BIT | TEST_SINGLE_BIT | CALLBACK_ON_SINGLE_BIT
32645: };
32645: 
32645: /* Factor out looping and matching logic. */
32645: static bool
53858: DoMatch(JSContext *cx, RegExpStatics *res, Value *vp, JSString *str, const RegExpPair &rep,
32645:         DoMatchCallback callback, void *data, MatchControlFlags flags)
32645: {
51460:     RegExp &re = rep.re();
50491:     if (re.global()) {
32645:         /* global matching ('g') */
32645:         bool testGlobal = flags & TEST_GLOBAL_BIT;
51460:         if (rep.reobj())
51460:             rep.reobj()->zeroRegExpLastIndex();
32645:         for (size_t count = 0, i = 0, length = str->length(); i <= length; ++count) {
53858:             if (!re.execute(cx, res, str, &i, testGlobal, vp))
32645:                 return false;
32645:             if (!Matched(testGlobal, *vp))
    1:                 break;
53858:             if (!callback(cx, res, count, data))
32645:                 return false;
53858:             if (!res->matched())
32645:                 ++i;
    1:         }
    1:     } else {
32645:         /* single match */
33166:         bool testSingle = !!(flags & TEST_SINGLE_BIT),
33166:              callbackOnSingle = !!(flags & CALLBACK_ON_SINGLE_BIT);
32645:         size_t i = 0;
53858:         if (!re.execute(cx, res, str, &i, testSingle, vp))
32645:             return false;
53858:         if (callbackOnSingle && Matched(testSingle, *vp) && !callback(cx, res, 0, data))
32645:             return false;
32645:     }
32645:     return true;
32645: }
32645: 
50491: static bool
51460: BuildFlatMatchArray(JSContext *cx, JSString *textstr, const FlatMatch &fm, Value *vp)
50491: {
51460:     if (fm.match() < 0) {
50491:         vp->setNull();
50491:         return true;
50491:     }
50491: 
50491:     /* For this non-global match, produce a RegExp.exec-style array. */
50491:     JSObject *obj = js_NewSlowArrayObject(cx);
50491:     if (!obj)
50491:         return false;
50491:     vp->setObject(*obj);
50491: 
51460:     return obj->defineProperty(cx, INT_TO_JSID(0), StringValue(fm.pattern())) &&
50491:            obj->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.indexAtom),
51460:                                Int32Value(fm.match())) &&
50491:            obj->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.inputAtom),
50491:                                StringValue(textstr));
50491: }
50491: 
48470: typedef JSObject **MatchArgType;
48470: 
    1: /*
32645:  * DoMatch will only callback on global matches, hence this function builds
32645:  * only the "array of matches" returned by match on global regexps.
    1:  */
32645: static bool
53858: MatchCallback(JSContext *cx, RegExpStatics *res, size_t count, void *p)
    1: {
48470:     JS_ASSERT(count <= JSID_INT_MAX);  /* by max string length */
48470: 
48470:     JSObject *&arrayobj = *static_cast<MatchArgType>(p);
    1:     if (!arrayobj) {
22652:         arrayobj = js_NewArrayObject(cx, 0, NULL);
    1:         if (!arrayobj)
32645:             return false;
    1:     }
31883: 
50491:     Value v;
53858:     if (!res->createLastMatch(cx, &v))
32645:         return false;
31883: 
20408:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
54169:     return !!arrayobj->setProperty(cx, INT_TO_JSID(count), &v, false);
    1: }
    1: 
22658: static JSBool
48470: str_match(JSContext *cx, uintN argc, Value *vp)
18190: {
32645:     JSString *str;
32645:     NORMALIZE_THIS(cx, vp, str);
32645: 
33165:     RegExpGuard g(cx);
33165:     if (!g.init(argc, vp))
33165:         return false;
51460:     if (const FlatMatch *fm = g.tryFlatMatch(str, 1, argc))
51460:         return BuildFlatMatchArray(cx, str, *fm, vp);
51460: 
51460:     const RegExpPair *rep = g.normalizeRegExp(false, 1, argc, vp);
51460:     if (!rep)
32645:         return false;
32645: 
48470:     AutoObjectRooter array(cx);
48470:     MatchArgType arg = array.addr();
53858:     RegExpStatics *res = cx->regExpStatics();
53858:     if (!DoMatch(cx, res, vp, str, *rep, MatchCallback, arg, MATCH_ARGS))
32645:         return false;
32645: 
50491:     /* When not global, DoMatch will leave |RegExp.exec()| in *vp. */
51460:     if (rep->re().global())
48470:         vp->setObjectOrNull(array.object());
32645:     return true;
18190: }
18190: 
    1: static JSBool
48470: str_search(JSContext *cx, uintN argc, Value *vp)
    1: {
32645:     JSString *str;
32645:     NORMALIZE_THIS(cx, vp, str);
32645: 
33165:     RegExpGuard g(cx);
33165:     if (!g.init(argc, vp))
33165:         return false;
51460:     if (const FlatMatch *fm = g.tryFlatMatch(str, 1, argc)) {
51460:         vp->setInt32(fm->match());
33165:         return true;
33165:     }
51460:     const RegExpPair *rep = g.normalizeRegExp(false, 1, argc, vp);
51460:     if (!rep)
32645:         return false;
32645: 
53858:     RegExpStatics *res = cx->regExpStatics();
32645:     size_t i = 0;
53858:     if (!rep->re().execute(cx, res, str, &i, true, vp))
32645:         return false;
32645: 
48470:     if (vp->isTrue())
57584:         vp->setInt32(res->matchStart());
33165:     else
48470:         vp->setInt32(-1);
32645:     return true;
    1: }
    1: 
34376: struct ReplaceData
34376: {
34376:     ReplaceData(JSContext *cx)
42714:      : g(cx), cb(cx)
34376:     {}
34376: 
32645:     JSString           *str;           /* 'this' parameter object as a string */
32645:     RegExpGuard        g;              /* regexp parameter object and private data */
    1:     JSObject           *lambda;        /* replacement function object or null */
56740:     JSObject           *elembase;      /* object for function(a){return b[a]} replace */
    1:     JSString           *repstr;        /* replacement string */
    1:     jschar             *dollar;        /* null or pointer to first $ in repstr */
    1:     jschar             *dollarEnd;     /* limit pointer for js_strchr_limit */
    1:     jsint              index;          /* index in result of next replacement */
32645:     jsint              leftIndex;      /* left context index in str->chars */
32645:     JSSubString        dollarStr;      /* for "$$" InterpretDollar result */
32645:     bool               calledBack;     /* record whether callback has been called */
55565:     InvokeSessionGuard session;        /* arguments for repeated lambda Invoke call */
55565:     InvokeArgsGuard    singleShot;     /* arguments for single lambda Invoke call */
32645:     JSCharBuffer       cb;             /* buffer built during DoMatch */
31883: };
    1: 
50491: static bool
53858: InterpretDollar(JSContext *cx, RegExpStatics *res, jschar *dp, jschar *ep, ReplaceData &rdata,
57585:                 JSSubString *out, size_t *skip, volatile JSContext::DollarPath *path)
    1: {
    1:     JS_ASSERT(*dp == '$');
    1: 
    1:     /* If there is only a dollar, bail now */
    1:     if (dp + 1 >= ep)
50491:         return false;
    1: 
    1:     /* Interpret all Perl match-induced dollar variables. */
50491:     jschar dc = dp[1];
    1:     if (JS7_ISDEC(dc)) {
    1:         /* ECMA-262 Edition 3: 1-9 or 01-99 */
50491:         uintN num = JS7_UNDEC(dc);
53858:         if (num > res->getParenCount())
50491:             return false;
50491: 
50491:         jschar *cp = dp + 2;
    1:         if (cp < ep && (dc = *cp, JS7_ISDEC(dc))) {
50491:             uintN tmp = 10 * num + JS7_UNDEC(dc);
53858:             if (tmp <= res->getParenCount()) {
    1:                 cp++;
    1:                 num = tmp;
    1:             }
    1:         }
    1:         if (num == 0)
50491:             return false;
    1: 
    1:         /* Adjust num from 1 $n-origin to 0 array-index-origin. */
    1:         num--;
    1:         *skip = cp - dp;
53858:         if (num < res->getParenCount())
53858:             res->getParen(num, out);
50491:         else
50491:             *out = js_EmptySubString;
50491:         return true;
    1:     }
    1: 
    1:     *skip = 2;
    1:     switch (dc) {
    1:       case '$':
32645:         rdata.dollarStr.chars = dp;
32645:         rdata.dollarStr.length = 1;
50491:         *out = rdata.dollarStr;
57585:         *path = JSContext::DOLLAR_LITERAL;
50491:         return true;
    1:       case '&':
53858:         res->getLastMatch(out);
57585:         *path = JSContext::DOLLAR_AMP;
50491:         return true;
    1:       case '+':
53858:         res->getLastParen(out);
57585:         *path = JSContext::DOLLAR_PLUS;
50491:         return true;
    1:       case '`':
53858:         res->getLeftContext(out);
57585:         *path = JSContext::DOLLAR_TICK;
50491:         return true;
    1:       case '\'':
53858:         res->getRightContext(out);
57585:         *path = JSContext::DOLLAR_QUOT;
50491:         return true;
50491:     }
50491:     return false;
    1: }
    1: 
31883: static bool
53858: FindReplaceLength(JSContext *cx, RegExpStatics *res, ReplaceData &rdata, size_t *sizep)
    1: {
56740:     JSObject *base = rdata.elembase;
56740:     if (base) {
56740:         /*
56740:          * The base object is used when replace was passed a lambda which looks like
56740:          * 'function(a) { return b[a]; }' for the base object b.  b will not change
56740:          * in the course of the replace unless we end up making a scripted call due
56740:          * to accessing a scripted getter or a value with a scripted toString.
56740:          */
56740:         JS_ASSERT(rdata.lambda);
56740:         JS_ASSERT(!base->getOps()->lookupProperty);
56740:         JS_ASSERT(!base->getOps()->getProperty);
56740: 
56740:         Value match;
56740:         if (!res->createLastMatch(cx, &match))
56740:             return false;
56740:         JSString *str = match.toString();
56740: 
56740:         JSAtom *atom;
56740:         if (str->isAtomized()) {
56740:             atom = STRING_TO_ATOM(str);
56740:         } else {
56740:             atom = js_AtomizeString(cx, str, 0);
56740:             if (!atom)
56740:                 return false;
56740:         }
56740:         jsid id = ATOM_TO_JSID(atom);
56740: 
56740:         JSObject *holder;
56740:         JSProperty *prop = NULL;
56740:         if (js_LookupPropertyWithFlags(cx, base, id, JSRESOLVE_QUALIFIED, &holder, &prop) < 0)
56740:             return false;
56740: 
56740:         /* Only handle the case where the property exists and is on this object. */
56740:         if (prop && holder == base) {
56740:             Shape *shape = (Shape *) prop;
56740:             if (shape->slot != SHAPE_INVALID_SLOT && shape->hasDefaultGetter()) {
56740:                 Value value = base->getSlot(shape->slot);
56740:                 if (value.isString()) {
56740:                     rdata.repstr = value.toString();
56740:                     *sizep = rdata.repstr->length();
56740:                     return true;
56740:                 }
56740:             }
56740:         }
56740: 
56740:         /*
56740:          * Couldn't handle this property, fall through and despecialize to the
56740:          * general lambda case.
56740:          */
56740:         rdata.elembase = NULL;
56740:     }
56740: 
50491:     JSObject *lambda = rdata.lambda;
    1:     if (lambda) {
    1:         /*
    1:          * In the lambda case, not only do we find the replacement string's
    1:          * length, we compute repstr and return it via rdata for use within
32645:          * DoReplace.  The lambda is called with arguments ($&, $1, $2, ...,
    1:          * index, input), i.e., all the properties of a regexp match array.
    1:          * For $&, etc., we must create string jsvals from cx->regExpStatics.
    1:          * We grab up stack space to keep the newborn strings GC-rooted.
    1:          */
53858:         uintN p = res->getParenCount();
31883:         uintN argc = 1 + p + 2;
34376: 
55567:         InvokeSessionGuard &session = rdata.session;
55567:         if (!session.started()) {
55565:             Value lambdav = ObjectValue(*lambda);
55712:             if (!session.start(cx, lambdav, UndefinedValue(), argc))
31883:                 return false;
55565:         }
31883: 
55567:         PreserveRegExpStatics staticsGuard(res);
55567:         if (!staticsGuard.init(cx))
55567:             return false;
55567: 
55567:         /* Push $&, $1, $2, ... */
55565:         uintN argi = 0;
55565:         if (!res->createLastMatch(cx, &session[argi++]))
41836:             return false;
41836: 
53858:         for (size_t i = 0; i < res->getParenCount(); ++i) {
55565:             if (!res->createParen(cx, i, &session[argi++]))
41836:                 return false;
41836:         }
    1: 
    1:         /* Push match index and input string. */
57584:         session[argi++].setInt32(res->matchStart());
55565:         session[argi].setString(rdata.str);
55565: 
55565:         if (!session.invoke(cx))
41836:             return false;
31883: 
55566:         /* root repstr: rdata is on the stack, so scanned by conservative gc. */
55566:         rdata.repstr = ValueToString_TestForStringInline(cx, session.rval());
55566:         if (!rdata.repstr)
41836:             return false;
31883: 
55566:         *sizep = rdata.repstr->length();
41836:         return true;
    1:     }
    1: 
50491:     JSString *repstr = rdata.repstr;
50491:     size_t replen = repstr->length();
57585:     JSContext::DollarPath path;
50491:     for (jschar *dp = rdata.dollar, *ep = rdata.dollarEnd; dp; dp = js_strchr_limit(dp, '$', ep)) {
50491:         JSSubString sub;
50491:         size_t skip;
57585:         if (InterpretDollar(cx, res, dp, ep, rdata, &sub, &skip, &path)) {
50491:             replen += sub.length - skip;
    1:             dp += skip;
50491:         } else {
    1:             dp++;
    1:         }
50491:     }
    1:     *sizep = replen;
32645:     return true;
    1: }
    1: 
    1: static void
53858: DoReplace(JSContext *cx, RegExpStatics *res, ReplaceData &rdata, jschar *chars)
    1: {
50491:     JSString *repstr = rdata.repstr;
50491:     jschar *cp;
50491:     jschar *bp = cp = repstr->chars();
57585:     volatile JSContext::DollarPath path;
57585:     cx->dollarPath = &path;
57585:     jschar sourceBuf[128];
57585:     cx->blackBox = sourceBuf;
57585: 
50491:     for (jschar *dp = rdata.dollar, *ep = rdata.dollarEnd; dp; dp = js_strchr_limit(dp, '$', ep)) {
50491:         size_t len = dp - cp;
    1:         js_strncpy(chars, cp, len);
    1:         chars += len;
    1:         cp = dp;
50491: 
50491:         JSSubString sub;
50491:         size_t skip;
57585:         if (InterpretDollar(cx, res, dp, ep, rdata, &sub, &skip, &path)) {
57585:             if (((size_t(sub.chars) & 0xfffffU) + sub.length) > 0x100000U) {
57585:                 /* Going to cross a 0xffffe address, so take a gander at the replace value. */
57585:                 size_t peekLen = JS_MIN(rdata.dollarEnd - rdata.dollar, 128);
57585:                 js_strncpy(sourceBuf, rdata.dollar, peekLen);
57585:             }
57585: 
50491:             len = sub.length;
50491:             js_strncpy(chars, sub.chars, len);
    1:             chars += len;
    1:             cp += skip;
    1:             dp += skip;
    1:         } else {
    1:             dp++;
    1:         }
    1:     }
29366:     js_strncpy(chars, cp, repstr->length() - (cp - bp));
    1: }
    1: 
32645: static bool
53858: ReplaceCallback(JSContext *cx, RegExpStatics *res, size_t count, void *p)
    1: {
32645:     ReplaceData &rdata = *static_cast<ReplaceData *>(p);
32645: 
32645:     rdata.calledBack = true;
32645:     JSString *str = rdata.str;
32645:     size_t leftoff = rdata.leftIndex;
32645:     const jschar *left = str->chars() + leftoff;
57584:     size_t leftlen = res->matchStart() - leftoff;
57584:     rdata.leftIndex = res->matchLimit();
32645: 
32645:     size_t replen = 0;  /* silence 'unused' warning */
53858:     if (!FindReplaceLength(cx, res, rdata, &replen))
32645:         return false;
32645: 
32645:     size_t growth = leftlen + replen;
48470:     if (!rdata.cb.growByUninitialized(growth))
32645:         return false;
32645: 
32645:     jschar *chars = rdata.cb.begin() + rdata.index;
32645:     rdata.index += growth;
    1:     js_strncpy(chars, left, leftlen);
    1:     chars += leftlen;
53858:     DoReplace(cx, res, rdata, chars);
32645:     return true;
    1: }
    1: 
33165: static bool
33165: BuildFlatReplacement(JSContext *cx, JSString *textstr, JSString *repstr,
51460:                      const FlatMatch &fm, Value *vp)
33165: {
48536:     JSRopeBuilder builder(cx);
51460:     size_t match = fm.match(); /* Avoid signed/unsigned warnings. */
51460:     size_t matchEnd = match + fm.patternLength();
48536: 
48536:     if (textstr->isTopNode()) {
48536:         /*
48536:          * If we are replacing over a rope, avoid flattening it by iterating
48536:          * through it, building a new rope.
48536:          */
48536:         JSRopeLeafIterator iter(textstr);
48536:         size_t pos = 0;
48536:         for (JSString *str = iter.init(); str; str = iter.next()) {
48536:             size_t len = str->length();
48536:             size_t strEnd = pos + len;
48536:             if (pos < matchEnd && strEnd > match) {
48536:                 /*
48536:                  * We need to special-case any part of the rope that overlaps
48536:                  * with the replacement string.
48536:                  */
48536:                 if (match >= pos) {
48536:                     /*
48536:                      * If this part of the rope overlaps with the left side of
48536:                      * the pattern, then it must be the only one to overlap with
48536:                      * the first character in the pattern, so we include the
48536:                      * replacement string here.
48536:                      */
48536:                     JSString *leftSide = js_NewDependentString(cx, str, 0, match - pos);
48536:                     if (!leftSide ||
51460:                         !builder.append(leftSide) ||
51460:                         !builder.append(repstr)) {
33165:                         return false;
33165:                     }
48536:                 }
48536: 
48536:                 /*
48536:                  * If str runs off the end of the matched string, append the
48536:                  * last part of str.
48536:                  */
48536:                 if (strEnd > matchEnd) {
48536:                     JSString *rightSide = js_NewDependentString(cx, str, matchEnd - pos,
48536:                                                                 strEnd - matchEnd);
51460:                     if (!rightSide || !builder.append(rightSide))
33165:                         return false;
48536:                 }
48536:             } else {
51460:                 if (!builder.append(str))
48536:                     return false;
48536:             }
48536:             pos += str->length();
48536:         }
48536:     } else {
48536:         JSString *leftSide = js_NewDependentString(cx, textstr, 0, match);
48536:         if (!leftSide)
48536:             return false;
51460:         JSString *rightSide = js_NewDependentString(cx, textstr, match + fm.patternLength(),
51460:                                                     textstr->length() - match - fm.patternLength());
48536:         if (!rightSide ||
51460:             !builder.append(leftSide) ||
51460:             !builder.append(repstr) ||
51460:             !builder.append(rightSide)) {
48536:             return false;
48536:         }
48536:     }
48536: 
48536:     vp->setString(builder.getStr());
33165:     return true;
33165: }
33165: 
51460: /*
51460:  * Perform a linear-scan dollar substitution on the replacement text,
51460:  * constructing a result string that looks like:
51460:  *
51460:  *      newstring = string[:matchStart] + dollarSub(replaceValue) + string[matchLimit:]
51460:  */
51460: static inline bool
51460: BuildDollarReplacement(JSContext *cx, JSString *textstr, JSString *repstr,
51460:                        const jschar *firstDollar, const FlatMatch &fm, Value *vp)
51460: {
51460:     JS_ASSERT(repstr->chars() <= firstDollar && firstDollar < repstr->chars() + repstr->length());
51460:     size_t matchStart = fm.match();
51460:     size_t matchLimit = matchStart + fm.patternLength();
51460:     JSCharBuffer newReplaceChars(cx);
51460: 
51460:     /*
51460:      * Most probably:
51460:      *
51460:      *      len(newstr) >= len(orig) - len(match) + len(replacement)
51460:      *
51460:      * Note that dollar vars _could_ make the resulting text smaller than this.
51460:      */
51460:     if (!newReplaceChars.reserve(textstr->length() - fm.patternLength() + repstr->length()))
51460:         return false;
51460: 
51460:     /* Move the pre-dollar chunk in bulk. */
51460:     JS_ALWAYS_TRUE(newReplaceChars.append(repstr->chars(), firstDollar));
51460: 
51460:     /* Move the rest char-by-char, interpreting dollars as we encounter them. */
51460: #define ENSURE(__cond) if (!(__cond)) return false;
51460:     const jschar *repstrLimit = repstr->chars() + repstr->length();
51460:     for (const jschar *it = firstDollar; it < repstrLimit; ++it) {
51460:         if (*it != '$' || it == repstrLimit - 1) {
51460:             ENSURE(newReplaceChars.append(*it));
51460:             continue;
51460:         }
51460: 
51460:         switch (*(it + 1)) {
51460:           case '$': /* Eat one of the dollars. */
51460:             ENSURE(newReplaceChars.append(*it));
51460:             break;
51460:           case '&':
51460:             ENSURE(newReplaceChars.append(textstr->chars() + matchStart,
51460:                                           textstr->chars() + matchLimit));
51460:             break;
51460:           case '`':
51460:             ENSURE(newReplaceChars.append(textstr->chars(), textstr->chars() + matchStart));
51460:             break;
51460:           case '\'':
51460:             ENSURE(newReplaceChars.append(textstr->chars() + matchLimit,
51460:                                           textstr->chars() + textstr->length()));
51460:             break;
51460:           default: /* The dollar we saw was not special (no matter what its mother told it). */
51460:             ENSURE(newReplaceChars.append(*it));
51460:             continue;
51460:         }
51460:         ++it; /* We always eat an extra char in the above switch. */
51460:     }
51460: 
51460:     JSString *leftSide = js_NewDependentString(cx, textstr, 0, matchStart);
51460:     ENSURE(leftSide);
51460: 
51460:     JSString *newReplace = js_NewStringFromCharBuffer(cx, newReplaceChars);
51460:     ENSURE(newReplace);
51460: 
51460:     JS_ASSERT(textstr->length() >= matchLimit);
51460:     JSString *rightSide = js_NewDependentString(cx, textstr, matchLimit,
51460:                                                 textstr->length() - matchLimit);
51460:     ENSURE(rightSide);
51460: 
51460:     JSRopeBuilder builder(cx);
51460:     ENSURE(builder.append(leftSide) &&
51460:            builder.append(newReplace) &&
51460:            builder.append(rightSide));
51460: #undef ENSURE
51460: 
51460:     vp->setString(builder.getStr());
51460:     return true;
51460: }
51460: 
51460: static inline bool
51460: str_replace_regexp(JSContext *cx, uintN argc, Value *vp, ReplaceData &rdata)
51460: {
51460:     const RegExpPair *rep = rdata.g.normalizeRegExp(true, 2, argc, vp);
51460:     if (!rep)
51460:         return false;
51460: 
51460:     rdata.index = 0;
51460:     rdata.leftIndex = 0;
51460:     rdata.calledBack = false;
51460: 
53858:     RegExpStatics *res = cx->regExpStatics();
53858:     if (!DoMatch(cx, res, vp, rdata.str, *rep, ReplaceCallback, &rdata, REPLACE_ARGS))
51460:         return false;
51460: 
51460:     if (!rdata.calledBack) {
51460:         /* Didn't match, so the string is unmodified. */
51460:         vp->setString(rdata.str);
51460:         return true;
51460:     }
51460: 
51460:     JSSubString sub;
53858:     res->getRightContext(&sub);
51460:     if (!rdata.cb.append(sub.chars, sub.length))
51460:         return false;
51460: 
51460:     JSString *retstr = js_NewStringFromCharBuffer(cx, rdata.cb);
51460:     if (!retstr)
51460:         return false;
51460: 
51460:     vp->setString(retstr);
51460:     return true;
51460: }
51460: 
51460: static inline bool
51460: str_replace_flat_lambda(JSContext *cx, uintN argc, Value *vp, ReplaceData &rdata,
51460:                         const FlatMatch &fm)
51460: {
51460:     JS_ASSERT(fm.match() >= 0);
51460:     LeaveTrace(cx);
51460: 
51460:     JSString *matchStr = js_NewDependentString(cx, rdata.str, fm.match(), fm.patternLength());
51460:     if (!matchStr)
51460:         return false;
51460: 
51460:     /* lambda(matchStr, matchStart, textstr) */
51460:     static const uint32 lambdaArgc = 3;
55565:     if (!cx->stack().pushInvokeArgs(cx, lambdaArgc, &rdata.singleShot))
51460:         return false;
51460: 
55565:     CallArgs &args = rdata.singleShot;
51460:     args.callee().setObject(*rdata.lambda);
55712:     args.thisv().setUndefined();
51460: 
51460:     Value *sp = args.argv();
51460:     sp[0].setString(matchStr);
51460:     sp[1].setInt32(fm.match());
51460:     sp[2].setString(rdata.str);
51460: 
55565:     if (!Invoke(cx, rdata.singleShot, 0))
51460:         return false;
51460: 
51460:     JSString *repstr = js_ValueToString(cx, args.rval());
51460:     if (!repstr)
51460:         return false;
51460: 
51460:     JSString *leftSide = js_NewDependentString(cx, rdata.str, 0, fm.match());
51460:     if (!leftSide)
51460:         return false;
51460: 
51460:     size_t matchLimit = fm.match() + fm.patternLength();
51460:     JSString *rightSide = js_NewDependentString(cx, rdata.str, matchLimit,
51460:                                                 rdata.str->length() - matchLimit);
51460:     if (!rightSide)
51460:         return false;
51460: 
51460:     JSRopeBuilder builder(cx);
51460:     if (!(builder.append(leftSide) &&
51460:           builder.append(repstr) &&
51460:           builder.append(rightSide))) {
51460:         return false;
51460:     }
51460: 
51460:     vp->setString(builder.getStr());
51460:     return true;
51460: }
51460: 
48676: JSBool
48676: js::str_replace(JSContext *cx, uintN argc, Value *vp)
    1: {
32645:     ReplaceData rdata(cx);
32645:     NORMALIZE_THIS(cx, vp, rdata.str);
54576:     static const uint32 optarg = 2;
32645: 
33165:     /* Extract replacement string/function. */
54576:     if (argc >= optarg && js_IsCallable(vp[3])) {
48470:         rdata.lambda = &vp[3].toObject();
56740:         rdata.elembase = NULL;
32645:         rdata.repstr = NULL;
32645:         rdata.dollar = rdata.dollarEnd = NULL;
56740: 
56740:         if (rdata.lambda->isFunction()) {
56740:             JSFunction *fun = rdata.lambda->getFunctionPrivate();
56740:             if (fun->isInterpreted()) {
56740:                 /*
56740:                  * Pattern match the script to check if it is is indexing into a
56740:                  * particular object, e.g. 'function(a) { return b[a]; }'.  Avoid
56740:                  * calling the script in such cases, which are used by javascript
56740:                  * packers (particularly the popular Dean Edwards packer) to efficiently
56740:                  * encode large scripts.  We only handle the code patterns generated
56740:                  * by such packers here.
56740:                  */
56740:                 JSScript *script = fun->u.i.script;
56740:                 jsbytecode *pc = script->code;
56740: 
56740:                 Value table = UndefinedValue();
56740:                 if (JSOp(*pc) == JSOP_GETFCSLOT) {
56740:                     table = rdata.lambda->getFlatClosureUpvar(GET_UINT16(pc));
56740:                     pc += JSOP_GETFCSLOT_LENGTH;
56740:                 }
56740: 
56740:                 if (table.isObject() &&
56740:                     JSOp(*pc) == JSOP_GETARG && GET_SLOTNO(pc) == 0 &&
56740:                     JSOp(*(pc + JSOP_GETARG_LENGTH)) == JSOP_GETELEM &&
56740:                     JSOp(*(pc + JSOP_GETARG_LENGTH + JSOP_GETELEM_LENGTH)) == JSOP_RETURN) {
56740:                     Class *clasp = table.toObject().getClass();
56740:                     if (clasp->isNative() &&
56740:                         !clasp->ops.lookupProperty &&
56740:                         !clasp->ops.getProperty) {
56740:                         rdata.elembase = &table.toObject();
56740:                     }
56740:                 }
56740:             }
56740:         }
    1:     } else {
32645:         rdata.lambda = NULL;
56740:         rdata.elembase = NULL;
32645:         rdata.repstr = ArgToRootedString(cx, argc, vp, 1);
32645:         if (!rdata.repstr)
32645:             return false;
32645: 
30624:         /* We're about to store pointers into the middle of our string. */
32645:         if (!js_MakeStringImmutable(cx, rdata.repstr))
32645:             return false;
32645:         rdata.dollarEnd = rdata.repstr->chars() + rdata.repstr->length();
32645:         rdata.dollar = js_strchr_limit(rdata.repstr->chars(), '$',
    1:                                        rdata.dollarEnd);
32645:     }
32645: 
33165:     if (!rdata.g.init(argc, vp))
33165:         return false;
51460: 
51460:     /*
51460:      * Unlike its |String.prototype| brethren, |replace| doesn't convert
51460:      * its input to a regular expression. (Even if it contains metachars.)
51460:      *
51460:      * However, if the user invokes our (non-standard) |flags| argument
51460:      * extension then we revert to creating a regular expression. Note that
51460:      * this is observable behavior through the side-effect mutation of the
51460:      * |RegExp| statics.
51460:      */
51460: 
54576:     const FlatMatch *fm = rdata.g.tryFlatMatch(rdata.str, optarg, argc, false);
51460:     if (!fm) {
54576:         JS_ASSERT_IF(!rdata.g.hasRegExpPair(), argc > optarg);
51460:         return str_replace_regexp(cx, argc, vp, rdata);
51460:     }
51460: 
51460:     if (fm->match() < 0) {
48470:         vp->setString(rdata.str);
32645:         return true;
32645:     }
32645: 
51460:     if (rdata.lambda)
51460:         return str_replace_flat_lambda(cx, argc, vp, rdata, *fm);
51460: 
51460:     /* 
51460:      * Note: we could optimize the text.length == pattern.length case if we wanted,
51460:      * even in the presence of dollar metachars.
51460:      */
51460:     if (rdata.dollar)
51460:         return BuildDollarReplacement(cx, rdata.str, rdata.repstr, rdata.dollar, *fm, vp);
51460: 
51460:     return BuildFlatReplacement(cx, rdata.str, rdata.repstr, *fm, vp);
    1: }
    1: 
    1: /*
20408:  * Subroutine used by str_split to find the next split point in str, starting
18311:  * at offset *ip and looking either for the separator substring given by sep, or
18311:  * for the next re match.  In the re case, return the matched separator in *sep,
18311:  * and the possibly updated offset in *ip.
    1:  *
    1:  * Return -2 on error, -1 on end of string, >= 0 for a valid index of the next
    1:  * separator occurrence if found, or str->length if no separator is found.
    1:  */
    1: static jsint
53858: find_split(JSContext *cx, RegExpStatics *res, JSString *str, js::RegExp *re, jsint *ip,
53858:            JSSubString *sep)
    1: {
40228:     jsint i;
    1:     size_t length;
    1:     jschar *chars;
    1: 
    1:     /*
    1:      * Stop if past end of string.  If at end of string, we will compare the
    1:      * null char stored there (by js_NewString*) to sep->chars[j] in the while
    1:      * loop at the end of this function, so that
    1:      *
    1:      *  "ab,".split(',') => ["ab", ""]
    1:      *
    1:      * and the resulting array converts back to the string "ab," for symmetry.
    1:      * However, we ape Perl and do this only if there is a sufficiently large
20408:      * limit argument (see str_split).
    1:      */
    1:     i = *ip;
29366:     length = str->length();
    1:     if ((size_t)i > length)
    1:         return -1;
    1: 
29366:     chars = str->chars();
    1: 
    1:     /*
    1:      * Match a regular expression against the separator at or above index i.
    1:      * Call js_ExecuteRegExp with true for the test argument.  On successful
    1:      * match, get the separator from cx->regExpStatics.lastMatch.
    1:      */
    1:     if (re) {
    1:         size_t index;
48470:         Value rval;
    1: 
    1:       again:
    1:         /* JS1.2 deviated from Perl by never matching at end of string. */
    1:         index = (size_t)i;
53858:         if (!re->execute(cx, res, str, &index, true, &rval))
    1:             return -2;
48470:         if (!rval.isTrue()) {
    1:             /* Mismatch: ensure our caller advances i past end of string. */
    1:             sep->length = 1;
    1:             return length;
    1:         }
    1:         i = (jsint)index;
50491:         JS_ASSERT(sep);
53858:         res->getLastMatch(sep);
    1:         if (sep->length == 0) {
    1:             /*
    1:              * Empty string match: never split on an empty match at the start
    1:              * of a find_split cycle.  Same rule as for an empty global match
32645:              * in DoMatch.
    1:              */
    1:             if (i == *ip) {
    1:                 /*
    1:                  * "Bump-along" to avoid sticking at an empty match, but don't
    1:                  * bump past end of string -- our caller must do that by adding
    1:                  * sep->length to our return value.
    1:                  */
    1:                 if ((size_t)i == length)
    1:                     return -1;
    1:                 i++;
    1:                 goto again;
    1:             }
    1:             if ((size_t)i == length) {
    1:                 /*
    1:                  * If there was a trivial zero-length match at the end of the
    1:                  * split, then we shouldn't output the matched string at the end
    1:                  * of the split array. See ECMA-262 Ed. 3, 15.5.4.14, Step 15.
    1:                  */
    1:                 sep->chars = NULL;
    1:             }
    1:         }
    1:         JS_ASSERT((size_t)i >= sep->length);
    1:         return i - sep->length;
    1:     }
    1: 
    1:     /*
    1:      * Special case: if sep is the empty string, split str into one character
    1:      * substrings.  Let our caller worry about whether to split once at end of
    1:      * string into an empty substring.
    1:      */
    1:     if (sep->length == 0)
    1:         return ((size_t)i == length) ? -1 : i + 1;
    1: 
    1:     /*
    1:      * Now that we know sep is non-empty, search starting at i in str for an
    1:      * occurrence of all of sep's chars.  If we find them, return the index of
    1:      * the first separator char.  Otherwise, return length.
    1:      */
40228:     jsint match = StringMatch(chars + i, length - i, sep->chars, sep->length);
40228:     return match == -1 ? length : match + i;
    1: }
    1: 
20408: static JSBool
48470: str_split(JSContext *cx, uintN argc, Value *vp)
    1: {
40418:     JSString *str;
40418:     NORMALIZE_THIS(cx, vp, str);
40418: 
40418:     if (argc == 0) {
48470:         Value v = StringValue(str);
40418:         JSObject *aobj = js_NewArrayObject(cx, 1, &v);
40418:         if (!aobj)
40418:             return false;
48470:         vp->setObject(*aobj);
40418:         return true;
40418:     }
40418: 
50491:     RegExp *re;
    1:     JSSubString *sep, tmp;
18115:     if (VALUE_IS_REGEXP(cx, vp[2])) {
50491:         re = static_cast<RegExp *>(vp[2].toObject().getPrivate());
    1:         sep = &tmp;
    1: 
    1:         /* Set a magic value so we can detect a successful re match. */
    1:         sep->chars = NULL;
    1:         sep->length = 0;
    1:     } else {
 4127:         JSString *str2 = js_ValueToString(cx, vp[2]);
    1:         if (!str2)
40418:             return false;
48470:         vp[2].setString(str2);
    1: 
    1:         /*
    1:          * Point sep at a local copy of str2's header because find_split
    1:          * will modify sep->length.
    1:          */
29366:         str2->getCharsAndLength(tmp.chars, tmp.length);
    1:         sep = &tmp;
    1:         re = NULL;
    1:     }
    1: 
    1:     /* Use the second argument as the split limit, if given. */
40418:     uint32 limit = 0; /* Avoid warning. */
48470:     bool limited = (argc > 1) && !vp[3].isUndefined();
    1:     if (limited) {
40828:         jsdouble d;
40828:         if (!ValueToNumber(cx, vp[3], &d))
40418:             return false;
    1: 
    1:         /* Clamp limit between 0 and 1 + string length. */
 9613:         limit = js_DoubleToECMAUint32(d);
29366:         if (limit > str->length())
29366:             limit = 1 + str->length();
    1:     }
    1: 
40418:     AutoValueVector splits(cx);
40418: 
53858:     RegExpStatics *res = cx->regExpStatics();
40418:     jsint i, j;
40418:     uint32 len = i = 0;
53858:     while ((j = find_split(cx, res, str, re, &i, sep)) >= 0) {
    1:         if (limited && len >= limit)
    1:             break;
40418: 
40418:         JSString *sub = js_NewDependentString(cx, str, i, size_t(j - i));
48470:         if (!sub || !splits.append(StringValue(sub)))
40418:             return false;
    1:         len++;
    1: 
    1:         /*
40418:          * Imitate perl's feature of including parenthesized substrings that
40418:          * matched part of the delimiter in the new array, after the split
40418:          * substring that was delimited.
    1:          */
    1:         if (re && sep->chars) {
53858:             for (uintN num = 0; num < res->getParenCount(); num++) {
    1:                 if (limited && len >= limit)
    1:                     break;
50491:                 JSSubString parsub;
53858:                 res->getParen(num, &parsub);
50491:                 sub = js_NewStringCopyN(cx, parsub.chars, parsub.length);
48470:                 if (!sub || !splits.append(StringValue(sub)))
40418:                     return false;
    1:                 len++;
    1:             }
    1:             sep->chars = NULL;
    1:         }
    1:         i = j + sep->length;
    1:     }
40418: 
40418:     if (j == -2)
40418:         return false;
40418: 
42641:     JSObject *aobj = js_NewArrayObject(cx, splits.length(), splits.begin());
40418:     if (!aobj)
40418:         return false;
48470:     vp->setObject(*aobj);
40418:     return true;
    1: }
    1: 
    1: #if JS_HAS_PERL_SUBSTR
    1: static JSBool
48470: str_substr(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1:     jsdouble d;
    1:     jsdouble length, begin, end;
    1: 
11809:     NORMALIZE_THIS(cx, vp, str);
    1:     if (argc != 0) {
40828:         if (!ValueToNumber(cx, vp[2], &d))
    1:             return JS_FALSE;
29366:         length = str->length();
    1:         begin = js_DoubleToInteger(d);
    1:         if (begin < 0) {
    1:             begin += length;
    1:             if (begin < 0)
    1:                 begin = 0;
    1:         } else if (begin > length) {
    1:             begin = length;
    1:         }
    1: 
56555:         if (argc == 1 || vp[3].isUndefined()) {
    1:             end = length;
    1:         } else {
40828:             if (!ValueToNumber(cx, vp[3], &d))
    1:                 return JS_FALSE;
    1:             end = js_DoubleToInteger(d);
    1:             if (end < 0)
    1:                 end = 0;
    1:             end += begin;
    1:             if (end > length)
    1:                 end = length;
    1:         }
    1: 
 4127:         str = js_NewDependentString(cx, str,
 4127:                                     (size_t)begin,
 4076:                                     (size_t)(end - begin));
    1:         if (!str)
    1:             return JS_FALSE;
    1:     }
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: #endif /* JS_HAS_PERL_SUBSTR */
    1: 
    1: /*
    1:  * Python-esque sequence operations.
    1:  */
20408: static JSBool
48470: str_concat(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str, *str2;
48470:     Value *argv;
    1:     uintN i;
    1: 
11809:     NORMALIZE_THIS(cx, vp, str);
 4127: 
23707:     /* Set vp (aka rval) early to handle the argc == 0 case. */
48470:     vp->setString(str);
23707: 
 4127:     for (i = 0, argv = vp + 2; i < argc; i++) {
    1:         str2 = js_ValueToString(cx, argv[i]);
    1:         if (!str2)
    1:             return JS_FALSE;
48470:         argv[i].setString(str2);
    1: 
    1:         str = js_ConcatStrings(cx, str, str2);
    1:         if (!str)
    1:             return JS_FALSE;
48470:         vp->setString(str);
23707:     }
23707: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: str_slice(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     if (argc == 1 && vp[1].isString() && vp[2].isInt32()) {
 4127:         size_t begin, end, length;
 4127: 
48470:         JSString *str = vp[1].toString();
48470:         begin = vp[2].toInt32();
29366:         end = str->length();
 4127:         if (begin <= end) {
 4127:             length = end - begin;
 4127:             if (length == 0) {
 4127:                 str = cx->runtime->emptyString;
 4127:             } else {
12267:                 str = (length == 1)
32607:                       ? JSString::getUnitString(cx, str, begin)
 4127:                       : js_NewDependentString(cx, str, begin, length);
    1:                 if (!str)
    1:                     return JS_FALSE;
 4127:             }
48470:             vp->setString(str);
 4127:             return JS_TRUE;
 4127:         }
 4127:     }
 4127: 
48470:     JSString *str;
11809:     NORMALIZE_THIS(cx, vp, str);
    1: 
    1:     if (argc != 0) {
 4127:         double begin, end, length;
 4127: 
40828:         if (!ValueToNumber(cx, vp[2], &begin))
    1:             return JS_FALSE;
 4127:         begin = js_DoubleToInteger(begin);
29366:         length = str->length();
    1:         if (begin < 0) {
    1:             begin += length;
    1:             if (begin < 0)
    1:                 begin = 0;
    1:         } else if (begin > length) {
    1:             begin = length;
    1:         }
    1: 
56555:         if (argc == 1 || vp[3].isUndefined()) {
    1:             end = length;
    1:         } else {
40828:             if (!ValueToNumber(cx, vp[3], &end))
    1:                 return JS_FALSE;
 4127:             end = js_DoubleToInteger(end);
    1:             if (end < 0) {
    1:                 end += length;
    1:                 if (end < 0)
    1:                     end = 0;
    1:             } else if (end > length) {
    1:                 end = length;
    1:             }
    1:             if (end < begin)
    1:                 end = begin;
    1:         }
    1: 
 4127:         str = js_NewDependentString(cx, str,
 4127:                                     (size_t)begin,
 4076:                                     (size_t)(end - begin));
    1:         if (!str)
    1:             return JS_FALSE;
    1:     }
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_STR_HTML_HELPERS
    1: /*
    1:  * HTML composition aids.
    1:  */
    1: static JSBool
 4127: tagify(JSContext *cx, const char *begin, JSString *param, const char *end,
48470:        Value *vp)
    1: {
    1:     JSString *str;
    1:     jschar *tagbuf;
    1:     size_t beglen, endlen, parlen, taglen;
    1:     size_t i, j;
    1: 
11809:     NORMALIZE_THIS(cx, vp, str);
    1: 
    1:     if (!end)
    1:         end = begin;
    1: 
    1:     beglen = strlen(begin);
    1:     taglen = 1 + beglen + 1;                            /* '<begin' + '>' */
    1:     parlen = 0; /* Avoid warning. */
    1:     if (param) {
29366:         parlen = param->length();
    1:         taglen += 2 + parlen + 1;                       /* '="param"' */
    1:     }
    1:     endlen = strlen(end);
29366:     taglen += str->length() + 2 + endlen + 1;    /* 'str</end>' */
    1: 
    1:     if (taglen >= ~(size_t)0 / sizeof(jschar)) {
12983:         js_ReportAllocationOverflow(cx);
    1:         return JS_FALSE;
    1:     }
    1: 
30851:     tagbuf = (jschar *) cx->malloc((taglen + 1) * sizeof(jschar));
    1:     if (!tagbuf)
    1:         return JS_FALSE;
    1: 
    1:     j = 0;
    1:     tagbuf[j++] = '<';
    1:     for (i = 0; i < beglen; i++)
    1:         tagbuf[j++] = (jschar)begin[i];
    1:     if (param) {
    1:         tagbuf[j++] = '=';
    1:         tagbuf[j++] = '"';
29366:         js_strncpy(&tagbuf[j], param->chars(), parlen);
    1:         j += parlen;
    1:         tagbuf[j++] = '"';
    1:     }
    1:     tagbuf[j++] = '>';
29366:     js_strncpy(&tagbuf[j], str->chars(), str->length());
29366:     j += str->length();
    1:     tagbuf[j++] = '<';
    1:     tagbuf[j++] = '/';
    1:     for (i = 0; i < endlen; i++)
    1:         tagbuf[j++] = (jschar)end[i];
    1:     tagbuf[j++] = '>';
    1:     JS_ASSERT(j == taglen);
    1:     tagbuf[j] = 0;
    1: 
 4718:     str = js_NewString(cx, tagbuf, taglen);
    1:     if (!str) {
30851:         js_free((char *)tagbuf);
    1:         return JS_FALSE;
    1:     }
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: tagify_value(JSContext *cx, uintN argc, Value *vp,
16519:              const char *begin, const char *end)
    1: {
    1:     JSString *param;
    1: 
16519:     param = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!param)
    1:         return JS_FALSE;
 4127:     return tagify(cx, begin, param, end, vp);
    1: }
    1: 
    1: static JSBool
48470: str_bold(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "b", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_italics(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "i", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_fixed(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "tt", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_fontsize(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return tagify_value(cx, argc, vp, "font size", "font");
    1: }
    1: 
    1: static JSBool
48470: str_fontcolor(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return tagify_value(cx, argc, vp, "font color", "font");
    1: }
    1: 
    1: static JSBool
48470: str_link(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return tagify_value(cx, argc, vp, "a href", "a");
    1: }
    1: 
    1: static JSBool
48470: str_anchor(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return tagify_value(cx, argc, vp, "a name", "a");
    1: }
    1: 
    1: static JSBool
48470: str_strike(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "strike", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_small(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "small", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_big(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "big", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_blink(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "blink", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_sup(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "sup", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_sub(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "sub", NULL, NULL, vp);
    1: }
    1: #endif /* JS_HAS_STR_HTML_HELPERS */
    1: 
20408: #ifdef JS_TRACER
20408: JSString* FASTCALL
20408: js_String_getelem(JSContext* cx, JSString* str, int32 i)
20408: {
29366:     if ((size_t)i >= str->length())
20408:         return NULL;
32607:     return JSString::getUnitString(cx, str, size_t(i));
20408: }
20930: #endif
20408: 
27059: JS_DEFINE_TRCINFO_1(str_concat,
48613:     (3, (extern, STRING_RETRY, js_ConcatStrings, CONTEXT, THIS_STRING, STRING,
48613:          1, nanojit::ACCSET_NONE)))
20408: 
55711: static const uint16 GENERIC_PRIMITIVE = JSFUN_GENERIC_NATIVE | JSFUN_PRIMITIVE_THIS;
 4127: 
    1: static JSFunctionSpec string_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN("quote",             str_quote,             0,GENERIC_PRIMITIVE),
55711:     JS_FN(js_toSource_str,     str_toSource,          0,JSFUN_PRIMITIVE_THIS),
    1: #endif
    1: 
    1:     /* Java-like methods. */
55711:     JS_FN(js_toString_str,     js_str_toString,       0,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN(js_valueOf_str,      js_str_toString,       0,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN(js_toJSON_str,       js_str_toString,       0,JSFUN_PRIMITIVE_THIS),
26553:     JS_FN("substring",         str_substring,         2,GENERIC_PRIMITIVE),
26553:     JS_FN("toLowerCase",       str_toLowerCase,       0,GENERIC_PRIMITIVE),
26553:     JS_FN("toUpperCase",       str_toUpperCase,       0,GENERIC_PRIMITIVE),
49109:     JS_FN("charAt",            js_str_charAt,         1,GENERIC_PRIMITIVE),
49109:     JS_FN("charCodeAt",        js_str_charCodeAt,     1,GENERIC_PRIMITIVE),
16519:     JS_FN("indexOf",           str_indexOf,           1,GENERIC_PRIMITIVE),
16519:     JS_FN("lastIndexOf",       str_lastIndexOf,       1,GENERIC_PRIMITIVE),
18938:     JS_FN("trim",              str_trim,              0,GENERIC_PRIMITIVE),
18938:     JS_FN("trimLeft",          str_trimLeft,          0,GENERIC_PRIMITIVE),
18938:     JS_FN("trimRight",         str_trimRight,         0,GENERIC_PRIMITIVE),
16519:     JS_FN("toLocaleLowerCase", str_toLocaleLowerCase, 0,GENERIC_PRIMITIVE),
16519:     JS_FN("toLocaleUpperCase", str_toLocaleUpperCase, 0,GENERIC_PRIMITIVE),
16519:     JS_FN("localeCompare",     str_localeCompare,     1,GENERIC_PRIMITIVE),
    1: 
    1:     /* Perl-ish methods (search is actually Python-esque). */
26553:     JS_FN("match",             str_match,             1,GENERIC_PRIMITIVE),
16519:     JS_FN("search",            str_search,            1,GENERIC_PRIMITIVE),
26553:     JS_FN("replace",           str_replace,           2,GENERIC_PRIMITIVE),
26553:     JS_FN("split",             str_split,             2,GENERIC_PRIMITIVE),
    1: #if JS_HAS_PERL_SUBSTR
16519:     JS_FN("substr",            str_substr,            2,GENERIC_PRIMITIVE),
    1: #endif
    1: 
    1:     /* Python-esque sequence methods. */
32669:     JS_TN("concat",            str_concat,            1,GENERIC_PRIMITIVE, &str_concat_trcinfo),
16519:     JS_FN("slice",             str_slice,             2,GENERIC_PRIMITIVE),
    1: 
    1:     /* HTML string methods. */
    1: #if JS_HAS_STR_HTML_HELPERS
55711:     JS_FN("bold",              str_bold,              0,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("italics",           str_italics,           0,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("fixed",             str_fixed,             0,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("fontsize",          str_fontsize,          1,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("fontcolor",         str_fontcolor,         1,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("link",              str_link,              1,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("anchor",            str_anchor,            1,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("strike",            str_strike,            0,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("small",             str_small,             0,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("big",               str_big,               0,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("blink",             str_blink,             0,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("sup",               str_sup,               0,JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("sub",               str_sub,               0,JSFUN_PRIMITIVE_THIS),
    1: #endif
    1: 
 4127:     JS_FS_END
    1: };
    1: 
32676: /*
48610:  * Set up some tools to make it easier to generate large tables. After constant
48610:  * folding, for each n, Rn(0) is the comma-separated list R(0), R(1), ..., R(2^n-1).
48610:  * Similary, Rn(k) (for any k and n) generates the list R(k), R(k+1), ..., R(k+2^n-1).
48610:  * To use this, define R appropriately, then use Rn(0) (for some value of n), then
48610:  * undefine R.
32676:  */
48610: #define R2(n)  R(n),   R((n) + (1 << 0)),    R((n) + (2 << 0)),    R((n) + (3 << 0))
48610: #define R4(n)  R2(n),  R2((n) + (1 << 2)),   R2((n) + (2 << 2)),   R2((n) + (3 << 2))
48610: #define R6(n)  R4(n),  R4((n) + (1 << 4)),   R4((n) + (2 << 4)),   R4((n) + (3 << 4))
48610: #define R8(n)  R6(n),  R6((n) + (1 << 6)),   R6((n) + (2 << 6)),   R6((n) + (3 << 6))
48610: #define R10(n) R8(n),  R8((n) + (1 << 8)),   R8((n) + (2 << 8)),   R8((n) + (3 << 8))
48610: #define R12(n) R10(n), R10((n) + (1 << 10)), R10((n) + (2 << 10)), R10((n) + (3 << 10))
48610: 
48610: #define R3(n) R2(n), R2((n) + (1 << 2))
48610: #define R7(n) R6(n), R6((n) + (1 << 6))
48610: 
48610: /*
48610:  * Declare unit strings. Pack the string data itself into the mInlineChars
48610:  * place in the header.
48610:  */
48610: #define R(c) {                                                                \
48491:     JSString::FLAT | JSString::ATOMIZED | (1 << JSString::FLAGS_LENGTH_SHIFT),\
48610:     { (jschar *)(((char *)(unitStringTable + (c))) +                          \
48610:       offsetof(JSString, mInlineStorage)) },                                  \
48610:     { {(c), 0x00} } }
32676: 
32733: #ifdef __SUNPRO_CC
32733: #pragma pack(8)
32733: #else
32697: #pragma pack(push, 8)
32733: #endif
32697: 
54716: const JSString JSString::unitStringTable[]
32698: #ifdef __GNUC__
32698: __attribute__ ((aligned (8)))
32698: #endif
48610: = { R8(0) };
32697: 
32733: #ifdef __SUNPRO_CC
32733: #pragma pack(0)
32733: #else
32697: #pragma pack(pop)
32733: #endif
32698: 
48610: #undef R
32676: 
32676: /*
48610:  * Declare length-2 strings. We only store strings where both characters are
48610:  * alphanumeric. The lower 10 short chars are the numerals, the next 26 are
48610:  * the lowercase letters, and the next 26 are the uppercase letters.
32676:  */
48610: #define TO_SMALL_CHAR(c) ((c) >= '0' && (c) <= '9' ? (c) - '0' :              \
48610:                           (c) >= 'a' && (c) <= 'z' ? (c) - 'a' + 10 :         \
48610:                           (c) >= 'A' && (c) <= 'Z' ? (c) - 'A' + 36 :         \
48610:                           JSString::INVALID_SMALL_CHAR)
48610: 
48610: #define R TO_SMALL_CHAR
48610: 
54716: const JSString::SmallChar JSString::toSmallChar[] = { R7(0) };
48610: 
48610: #undef R
48610: 
48610: /*
48610:  * This is used when we generate our table of short strings, so the compiler is
48610:  * happier if we use |c| as few times as possible.
48610:  */
48610: #define FROM_SMALL_CHAR(c) ((c) + ((c) < 10 ? '0' :      \
48610:                                    (c) < 36 ? 'a' - 10 : \
48610:                                    'A' - 36))
48610: #define R FROM_SMALL_CHAR
48610: 
54716: const jschar JSString::fromSmallChar[] = { R6(0) };
48610: 
48610: #undef R
48610: 
48610: /*
48610:  * For code-generation ease, length-2 strings are encoded as 12-bit int values,
48610:  * where the upper 6 bits is the first character and the lower 6 bits is the
48610:  * second character.
48610:  */
48610: #define R(c) {                                                                \
48491:     JSString::FLAT | JSString::ATOMIZED | (2 << JSString::FLAGS_LENGTH_SHIFT),\
48610:     { (jschar *)(((char *)(length2StringTable + (c))) +                       \
48610:       offsetof(JSString, mInlineStorage)) },                                  \
48610:     { {FROM_SMALL_CHAR((c) >> 6), FROM_SMALL_CHAR((c) & 0x3F), 0x00} } }
32676: 
32733: #ifdef __SUNPRO_CC
32733: #pragma pack(8)
32733: #else
32697: #pragma pack(push, 8)
32733: #endif
32697: 
54716: const JSString JSString::length2StringTable[]
32698: #ifdef __GNUC__
32698: __attribute__ ((aligned (8)))
32698: #endif
48610: = { R12(0) };
32676: 
32733: #ifdef __SUNPRO_CC
32733: #pragma pack(0)
32733: #else
32697: #pragma pack(pop)
32733: #endif
32697: 
48610: #undef R
48610: 
48610: #define R(c) FROM_SMALL_CHAR((c) >> 6), FROM_SMALL_CHAR((c) & 0x3f), 0x00
48610: 
48610: const char JSString::deflatedLength2StringTable[] = { R12(0) };
48610: 
48610: #undef R
48610: 
48610: /*
48610:  * Declare int strings. Only int strings from 100 to 255 actually have to be
48610:  * generated, since the rest are either unit strings or length-2 strings. To
48610:  * avoid the runtime cost of figuring out where to look for the string for a
48610:  * particular integer, we precompute a table of JSString*s which refer to the
48610:  * correct location of the int string.
48610:  */
48610: #define R(c) {                                                                \
48610:     JSString::FLAT | JSString::ATOMIZED | (3 << JSString::FLAGS_LENGTH_SHIFT),\
48610:     { (jschar *)(((char *)(hundredStringTable + ((c) - 100))) +               \
48610:       offsetof(JSString, mInlineStorage)) },                                  \
48610:     { {((c) / 100) + '0', ((c) / 10 % 10) + '0', ((c) % 10) + '0', 0x00} } }
48610: 
48610: 
48610: JS_STATIC_ASSERT(100 + (1 << 7) + (1 << 4) + (1 << 3) + (1 << 2) == 256);
48610: 
48610: #ifdef __SUNPRO_CC
48610: #pragma pack(8)
48610: #else
48610: #pragma pack(push, 8)
48610: #endif
48610: 
54716: const JSString JSString::hundredStringTable[]
48610: #ifdef __GNUC__
48610: __attribute__ ((aligned (8)))
48610: #endif
48610: = { R7(100), /* 100 through 227 */
48610:     R4(100 + (1 << 7)), /* 228 through 243 */
48610:     R3(100 + (1 << 7) + (1 << 4)), /* 244 through 251 */
48610:     R2(100 + (1 << 7) + (1 << 4) + (1 << 3)) /* 252 through 255 */
32702: };
32702: 
48610: #undef R
48610: 
48610: #define R(c) ((c) < 10 ? JSString::unitStringTable + ((c) + '0') :            \
48610:               (c) < 100 ? JSString::length2StringTable +                      \
48610:               ((size_t)TO_SMALL_CHAR(((c) / 10) + '0') << 6) +                \
48610:               TO_SMALL_CHAR(((c) % 10) + '0') :                               \
48610:               JSString::hundredStringTable + ((c) - 100))
48610: 
54716: const JSString *const JSString::intStringTable[] = { R8(0) };
48610: 
48610: #undef R
48610: 
48610: #ifdef __SUNPRO_CC
48610: #pragma pack(0)
48610: #else
48610: #pragma pack(pop)
48610: #endif
48610: 
48610: #define R(c) ((c) / 100) + '0', ((c) / 10 % 10) + '0', ((c) % 10) + '0', 0x00
48610: 
48610: const char JSString::deflatedIntStringTable[] = {
48610:     R7(100), /* 100 through 227 */
48610:     R4(100 + (1 << 7)), /* 228 through 243 */
48610:     R3(100 + (1 << 7) + (1 << 4)), /* 244 through 251 */
48610:     R2(100 + (1 << 7) + (1 << 4) + (1 << 3)) /* 252 through 255 */
32702: };
32702: 
48610: #undef R
48610: #undef R2
48610: #undef R4
48610: #undef R6
48610: #undef R8
48610: #undef R10
48610: #undef R12
48610: 
48610: #undef R3
48610: #undef R7
32702: 
37696: /* Static table for common UTF8 encoding */
37696: #define U8(c)   char(((c) >> 6) | 0xc0), char(((c) & 0x3f) | 0x80), 0
37696: #define U(c)    U8(c), U8(c+1), U8(c+2), U8(c+3), U8(c+4), U8(c+5), U8(c+6), U8(c+7)
37696: 
37696: const char JSString::deflatedUnitStringTable[] = {
37696:     U(0x80), U(0x88), U(0x90), U(0x98), U(0xa0), U(0xa8), U(0xb0), U(0xb8),
37696:     U(0xc0), U(0xc8), U(0xd0), U(0xd8), U(0xe0), U(0xe8), U(0xf0), U(0xf8)
37696: };
37696: 
37696: #undef U
37696: #undef U8
37696: 
26008: JSBool
50489: js_String(JSContext *cx, uintN argc, Value *vp)
    1: {
53557:     Value *argv = vp + 2;
53557: 
    1:     JSString *str;
    1:     if (argc > 0) {
53557:         str = js_ValueToString(cx, argv[0]);
    1:         if (!str)
53557:             return false;
    1:     } else {
    1:         str = cx->runtime->emptyString;
    1:     }
50489: 
53557:     if (IsConstructing(vp)) {
50489:         JSObject *obj = NewBuiltinClassInstance(cx, &js_StringClass);
50489:         if (!obj)
53557:             return false;
48470:         obj->setPrimitiveThis(StringValue(str));
50489:         vp->setObject(*obj);
50489:     } else {
50489:         vp->setString(str);
50489:     }
53557:     return true;
    1: }
    1: 
20408: static JSBool
48470: str_fromCharCode(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     Value *argv;
    1:     uintN i;
18175:     jschar *chars;
    1:     JSString *str;
    1: 
 4127:     argv = vp + 2;
31823:     JS_ASSERT(argc <= JS_ARGS_LENGTH_MAX);
40828:     if (argc == 1) {
40828:         uint16_t code;
40828:         if (!ValueToUint16(cx, argv[0], &code))
40828:             return JS_FALSE;
40828:         if (code < UNIT_STRING_LIMIT) {
32674:             str = JSString::unitString(code);
17914:             if (!str)
17914:                 return JS_FALSE;
48470:             vp->setString(str);
17914:             return JS_TRUE;
17914:         }
48470:         argv[0].setInt32(code);
40828:     }
30851:     chars = (jschar *) cx->malloc((argc + 1) * sizeof(jschar));
    1:     if (!chars)
    1:         return JS_FALSE;
    1:     for (i = 0; i < argc; i++) {
40828:         uint16_t code;
40828:         if (!ValueToUint16(cx, argv[i], &code)) {
30851:             cx->free(chars);
    1:             return JS_FALSE;
    1:         }
    1:         chars[i] = (jschar)code;
    1:     }
    1:     chars[i] = 0;
 4718:     str = js_NewString(cx, chars, argc);
    1:     if (!str) {
30851:         cx->free(chars);
    1:         return JS_FALSE;
    1:     }
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
27059: #ifdef JS_TRACER
27059: static JSString* FASTCALL
27059: String_fromCharCode(JSContext* cx, int32 i)
27059: {
27059:     JS_ASSERT(JS_ON_TRACE(cx));
27059:     jschar c = (jschar)i;
27059:     if (c < UNIT_STRING_LIMIT)
32674:         return JSString::unitString(c);
27059:     return js_NewStringCopyN(cx, &c, 1);
27059: }
27059: #endif
27059: 
27059: JS_DEFINE_TRCINFO_1(str_fromCharCode,
48613:     (2, (static, STRING_RETRY, String_fromCharCode, CONTEXT, INT32, 1, nanojit::ACCSET_NONE)))
27059: 
    1: static JSFunctionSpec string_static_methods[] = {
32669:     JS_TN("fromCharCode", str_fromCharCode, 1, 0, &str_fromCharCode_trcinfo),
 4127:     JS_FS_END
    1: };
    1: 
    1: JSObject *
    1: js_InitStringClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto;
    1: 
    1:     /* Define the escape, unescape functions in the global object. */
    1:     if (!JS_DefineFunctions(cx, obj, string_functions))
    1:         return NULL;
    1: 
53557:     proto = js_InitClass(cx, obj, NULL, &js_StringClass, js_String, 1,
26273:                          NULL, string_methods,
    1:                          NULL, string_static_methods);
    1:     if (!proto)
    1:         return NULL;
48470:     proto->setPrimitiveThis(StringValue(cx->runtime->emptyString));
26535:     if (!js_DefineNativeProperty(cx, proto, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom),
48470:                                  UndefinedValue(), NULL, NULL,
26535:                                  JSPROP_READONLY | JSPROP_PERMANENT | JSPROP_SHARED, 0, 0,
26535:                                  NULL)) {
26535:         return JS_FALSE;
26535:     }
26535: 
    1:     return proto;
    1: }
    1: 
    1: JSString *
 4718: js_NewString(JSContext *cx, jschar *chars, size_t length)
    1: {
    1:     JSString *str;
    1: 
29366:     if (length > JSString::MAX_LENGTH) {
27474:         if (JS_ON_TRACE(cx)) {
27474:             /*
27474:              * If we can't leave the trace, signal OOM condition, otherwise
31065:              * exit from trace before throwing.
27474:              */
37741:             if (!CanLeaveTrace(cx))
27474:                 return NULL;
27474: 
37741:             LeaveTrace(cx);
27474:         }
12983:         js_ReportAllocationOverflow(cx);
    1:         return NULL;
    1:     }
    1: 
33581:     str = js_NewGCString(cx);
    1:     if (!str)
    1:         return NULL;
29366:     str->initFlat(chars, length);
    1: #ifdef DEBUG
    1:   {
    1:     JSRuntime *rt = cx->runtime;
    1:     JS_RUNTIME_METER(rt, liveStrings);
    1:     JS_RUNTIME_METER(rt, totalStrings);
    1:     JS_LOCK_RUNTIME_VOID(rt,
    1:         (rt->lengthSum += (double)length,
    1:          rt->lengthSquaredSum += (double)length * (double)length));
    1:   }
    1: #endif
    1:     return str;
    1: }
    1: 
56713: static JS_ALWAYS_INLINE JSString *
56713: NewShortString(JSContext *cx, const jschar *chars, size_t length)
56713: {
56713:     JS_ASSERT(JSShortString::fitsIntoShortString(length));
56713:     JSShortString *str = js_NewGCShortString(cx);
56713:     if (!str)
56713:         return NULL;
56713:     jschar *storage = str->init(length);
56713:     js_short_strncpy(storage, chars, length);
56713:     storage[length] = 0;
56713:     return str->header();
56713: }
56713: 
56713: static JSString *
56713: NewShortString(JSContext *cx, const char *chars, size_t length)
56713: {
56713:     JS_ASSERT(JSShortString::fitsIntoShortString(length));
56713:     JSShortString *str = js_NewGCShortString(cx);
56713:     if (!str)
56713:         return NULL;
56713:     jschar *storage = str->init(length);
56713: 
56713:     if (js_CStringsAreUTF8) {
56713: #ifdef DEBUG
56713:         size_t oldLength = length;
56713: #endif
56713:         if (!js_InflateStringToBuffer(cx, chars, length, storage, &length))
56713:             return NULL;
56713:         JS_ASSERT(length <= oldLength);
56713:         storage[length] = 0;
56713:         str->resetLength(length);
56713:     } else {
56713:         size_t n = length;
56713:         jschar *p = storage;
56713:         while (n--)
56713:             *p++ = jschar(*chars++);
56713:         *p = 0;
56713:     }
56713:     return str->header();
56713: }
56713: 
31505: static const size_t sMinWasteSize = 16;
31505: 
    1: JSString *
31890: js_NewStringFromCharBuffer(JSContext *cx, JSCharBuffer &cb)
31477: {
31477:     if (cb.empty())
31477:         return ATOM_TO_STRING(cx->runtime->atomState.emptyAtom);
31477: 
31925:     size_t length = cb.length();
56713: 
56713:     JS_STATIC_ASSERT(JSShortString::MAX_SHORT_STRING_LENGTH < JSCharBuffer::InlineLength);
56713:     if (JSShortString::fitsIntoShortString(length))
56713:         return NewShortString(cx, cb.begin(), length);
56713: 
31477:     if (!cb.append('\0'))
31477:         return NULL;
31477: 
31505:     size_t capacity = cb.capacity();
31505: 
31477:     jschar *buf = cb.extractRawBuffer();
31477:     if (!buf)
31477:         return NULL;
31477: 
31505:     /* For medium/big buffers, avoid wasting more than 1/4 of the memory. */
31505:     JS_ASSERT(capacity >= length);
31505:     if (capacity > sMinWasteSize && capacity - length > (length >> 2)) {
31505:         size_t bytes = sizeof(jschar) * (length + 1);
31505:         jschar *tmp = (jschar *)cx->realloc(buf, bytes);
31505:         if (!tmp) {
31505:             cx->free(buf);
31505:             return NULL;
31505:         }
31505:         buf = tmp;
31505:     }
31505: 
31477:     JSString *str = js_NewString(cx, buf, length);
31477:     if (!str)
31477:         cx->free(buf);
31477:     return str;
31477: }
31477: 
31477: JSString *
    1: js_NewDependentString(JSContext *cx, JSString *base, size_t start,
 4076:                       size_t length)
    1: {
 4718:     JSString *ds;
    1: 
    1:     if (length == 0)
    1:         return cx->runtime->emptyString;
    1: 
29366:     if (start == 0 && length == base->length())
    1:         return base;
    1: 
48562:     jschar *chars = base->chars() + start;
48562: 
56740:     JSString *staticStr = JSString::lookupStaticString(chars, length);
56740:     if (staticStr)
56740:         return staticStr;
54160: 
48562:     /* Try to avoid long chains of dependent strings. */
48562:     while (base->isDependent())
48562:         base = base->dependentBase();
48562: 
48562:     JS_ASSERT(base->isFlat());
48491: 
33581:     ds = js_NewGCString(cx);
    1:     if (!ds)
    1:         return NULL;
48562:     ds->initDependent(base, chars, length);
    1: #ifdef DEBUG
    1:   {
    1:     JSRuntime *rt = cx->runtime;
    1:     JS_RUNTIME_METER(rt, liveDependentStrings);
    1:     JS_RUNTIME_METER(rt, totalDependentStrings);
    1:     JS_RUNTIME_METER(rt, liveStrings);
    1:     JS_RUNTIME_METER(rt, totalStrings);
    1:     JS_LOCK_RUNTIME_VOID(rt,
    1:         (rt->strdepLengthSum += (double)length,
    1:          rt->strdepLengthSquaredSum += (double)length * (double)length));
    1:     JS_LOCK_RUNTIME_VOID(rt,
    1:         (rt->lengthSum += (double)length,
    1:          rt->lengthSquaredSum += (double)length * (double)length));
    1:   }
    1: #endif
 4718:     return ds;
    1: }
    1: 
    1: #ifdef DEBUG
    1: #include <math.h>
    1: 
10217: void printJSStringStats(JSRuntime *rt)
10217: {
10217:     double mean, sigma;
10217: 
10217:     mean = JS_MeanAndStdDev(rt->totalStrings, rt->lengthSum,
10217:                             rt->lengthSquaredSum, &sigma);
10217: 
    1:     fprintf(stderr, "%lu total strings, mean length %g (sigma %g)\n",
10217:             (unsigned long)rt->totalStrings, mean, sigma);
10217: 
10217:     mean = JS_MeanAndStdDev(rt->totalDependentStrings, rt->strdepLengthSum,
10217:                             rt->strdepLengthSquaredSum, &sigma);
10217: 
    1:     fprintf(stderr, "%lu total dependent strings, mean length %g (sigma %g)\n",
10217:             (unsigned long)rt->totalDependentStrings, mean, sigma);
    1: }
    1: #endif
    1: 
    1: JSString *
 4076: js_NewStringCopyN(JSContext *cx, const jschar *s, size_t n)
    1: {
48563:     if (JSShortString::fitsIntoShortString(n))
48563:         return NewShortString(cx, s, n);
48563: 
    1:     jschar *news;
    1:     JSString *str;
    1: 
30851:     news = (jschar *) cx->malloc((n + 1) * sizeof(jschar));
    1:     if (!news)
    1:         return NULL;
    1:     js_strncpy(news, s, n);
    1:     news[n] = 0;
 4718:     str = js_NewString(cx, news, n);
    1:     if (!str)
30851:         cx->free(news);
    1:     return str;
    1: }
    1: 
    1: JSString *
48563: js_NewStringCopyN(JSContext *cx, const char *s, size_t n)
48563: {
48563:     if (JSShortString::fitsIntoShortString(n))
48563:         return NewShortString(cx, s, n);
48563:     return JS_NewStringCopyN(cx, s, n);
48563: }
48563: 
48563: JSString *
 4076: js_NewStringCopyZ(JSContext *cx, const jschar *s)
    1: {
    1:     size_t n, m;
    1:     jschar *news;
    1:     JSString *str;
    1: 
    1:     n = js_strlen(s);
48563: 
48563:     if (JSShortString::fitsIntoShortString(n))
48563:         return NewShortString(cx, s, n);
48563: 
    1:     m = (n + 1) * sizeof(jschar);
30851:     news = (jschar *) cx->malloc(m);
    1:     if (!news)
    1:         return NULL;
    1:     memcpy(news, s, m);
 4718:     str = js_NewString(cx, news, n);
    1:     if (!str)
30851:         cx->free(news);
    1:     return str;
    1: }
    1: 
48563: JSString *
48563: js_NewStringCopyZ(JSContext *cx, const char *s)
48563: {
48563:     return js_NewStringCopyN(cx, s, strlen(s));
48563: }
48563: 
    1: JS_FRIEND_API(const char *)
48470: js_ValueToPrintable(JSContext *cx, const Value &v, JSValueToStringFun v2sfun)
    1: {
    1:     JSString *str;
    1: 
    1:     str = v2sfun(cx, v);
    1:     if (!str)
    1:         return NULL;
    1:     str = js_QuoteString(cx, str, 0);
    1:     if (!str)
    1:         return NULL;
    1:     return js_GetStringBytes(cx, str);
    1: }
    1: 
48470: JSString *
48470: js_ValueToString(JSContext *cx, const Value &arg)
    1: {
48470:     Value v = arg;
48470:     if (v.isObject() && !DefaultValue(cx, &v.toObject(), JSTYPE_STRING, &v))
48470:         return NULL;
48470: 
    1:     JSString *str;
48470:     if (v.isString()) {
48470:         str = v.toString();
48470:     } else if (v.isInt32()) {
48470:         str = js_NumberToString(cx, v.toInt32());
48470:     } else if (v.isDouble()) {
48470:         str = js_NumberToString(cx, v.toDouble());
48470:     } else if (v.isBoolean()) {
48470:         str = js_BooleanToString(cx, v.toBoolean());
48470:     } else if (v.isNull()) {
30023:         str = ATOM_TO_STRING(cx->runtime->atomState.nullAtom);
    1:     } else {
    1:         str = ATOM_TO_STRING(cx->runtime->atomState.typeAtoms[JSTYPE_VOID]);
    1:     }
    1:     return str;
    1: }
    1: 
30023: static inline JSBool
38627: AppendAtom(JSAtom *atom, JSCharBuffer &cb)
30023: {
30023:     JSString *str = ATOM_TO_STRING(atom);
30023:     const jschar *chars;
30023:     size_t length;
30023:     str->getCharsAndLength(chars, length);
31890:     return cb.append(chars, length);
30023: }
30023: 
30023: /* This function implements E-262-3 section 9.8, toString. */
48470: JSBool
48470: js_ValueToCharBuffer(JSContext *cx, const Value &arg, JSCharBuffer &cb)
30023: {
48470:     Value v = arg;
48470:     if (v.isObject() && !DefaultValue(cx, &v.toObject(), JSTYPE_STRING, &v))
30023:         return JS_FALSE;
51451: 
51451:     if (v.isString()) {
51451:         const jschar *chars;
51451:         size_t length;
51451:         v.toString()->getCharsAndLength(chars, length);
51451:         return cb.append(chars, length);
51451:     }
48470:     if (v.isNumber())
31890:         return js_NumberValueToCharBuffer(cx, v, cb);
48470:     if (v.isBoolean())
48470:         return js_BooleanToCharBuffer(cx, v.toBoolean(), cb);
48470:     if (v.isNull())
38627:         return AppendAtom(cx->runtime->atomState.nullAtom, cb);
48470:     JS_ASSERT(v.isUndefined());
38627:     return AppendAtom(cx->runtime->atomState.typeAtoms[JSTYPE_VOID], cb);
30023: }
30023: 
    1: JS_FRIEND_API(JSString *)
48470: js_ValueToSource(JSContext *cx, const Value &v)
    1: {
48470:     if (v.isUndefined())
 2312:         return ATOM_TO_STRING(cx->runtime->atomState.void0Atom);
48470:     if (v.isString())
48470:         return js_QuoteString(cx, v.toString(), '"');
48470:     if (v.isPrimitive()) {
    1:         /* Special case to preserve negative zero, _contra_ toString. */
48470:         if (v.isDouble() && JSDOUBLE_IS_NEGZERO(v.toDouble())) {
    1:             /* NB: _ucNstr rather than _ucstr to indicate non-terminated. */
    1:             static const jschar js_negzero_ucNstr[] = {'-', '0'};
    1: 
 4076:             return js_NewStringCopyN(cx, js_negzero_ucNstr, 2);
    1:         }
    1:         return js_ValueToString(cx, v);
    1:     }
    1: 
33178:     JSAtom *atom = cx->runtime->atomState.toSourceAtom;
48470:     AutoValueRooter tvr(cx);
48470:     if (!js_TryMethod(cx, &v.toObject(), atom, 0, NULL, tvr.addr()))
33178:         return NULL;
33178:     return js_ValueToString(cx, tvr.value());
    1: }
    1: 
 4529: /*
 4529:  * str is not necessarily a GC thing here.
 4529:  */
 4529: uint32
    1: js_HashString(JSString *str)
    1: {
    1:     const jschar *s;
    1:     size_t n;
 4718:     uint32 h;
 4718: 
29366:     str->getCharsAndLength(s, n);
 4718:     for (h = 0; n; s++, n--)
10992:         h = JS_ROTATE_LEFT32(h, 4) ^ *s;
    1:     return h;
    1: }
    1: 
 4529: /*
 4529:  * str is not necessarily a GC thing here.
 4529:  */
18728: JSBool JS_FASTCALL
 4529: js_EqualStrings(JSString *str1, JSString *str2)
 4529: {
 4529:     size_t n;
 4529:     const jschar *s1, *s2;
 4529: 
 4529:     JS_ASSERT(str1);
 4529:     JS_ASSERT(str2);
 4529: 
 4529:     /* Fast case: pointer equality could be a quick win. */
 4529:     if (str1 == str2)
18728:         return JS_TRUE;
 4529: 
29366:     n = str1->length();
29366:     if (n != str2->length())
18728:         return JS_FALSE;
 4529: 
 4529:     if (n == 0)
18728:         return JS_TRUE;
 4529: 
29366:     s1 = str1->chars(), s2 = str2->chars();
 4529:     do {
 4529:         if (*s1 != *s2)
18728:             return JS_FALSE;
 4529:         ++s1, ++s2;
 4529:     } while (--n != 0);
 4529: 
18728:     return JS_TRUE;
16519: }
48613: JS_DEFINE_CALLINFO_2(extern, BOOL, js_EqualStrings, STRING, STRING, 1, nanojit::ACCSET_NONE)
16519: 
20408: int32 JS_FASTCALL
    1: js_CompareStrings(JSString *str1, JSString *str2)
    1: {
    1:     size_t l1, l2, n, i;
    1:     const jschar *s1, *s2;
    1:     intN cmp;
    1: 
    1:     JS_ASSERT(str1);
    1:     JS_ASSERT(str2);
    1: 
    1:     /* Fast case: pointer equality could be a quick win. */
    1:     if (str1 == str2)
    1:         return 0;
    1: 
29366:     str1->getCharsAndLength(s1, l1);
29366:     str2->getCharsAndLength(s2, l2);
    1:     n = JS_MIN(l1, l2);
    1:     for (i = 0; i < n; i++) {
    1:         cmp = s1[i] - s2[i];
    1:         if (cmp != 0)
    1:             return cmp;
    1:     }
    1:     return (intN)(l1 - l2);
    1: }
48613: JS_DEFINE_CALLINFO_2(extern, INT32, js_CompareStrings, STRING, STRING, 1, nanojit::ACCSET_NONE)
    1: 
    1: size_t
    1: js_strlen(const jschar *s)
    1: {
    1:     const jschar *t;
    1: 
    1:     for (t = s; *t != 0; t++)
    1:         continue;
    1:     return (size_t)(t - s);
    1: }
    1: 
    1: jschar *
    1: js_strchr(const jschar *s, jschar c)
    1: {
    1:     while (*s != 0) {
    1:         if (*s == c)
    1:             return (jschar *)s;
    1:         s++;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: jschar *
    1: js_strchr_limit(const jschar *s, jschar c, const jschar *limit)
    1: {
    1:     while (s < limit) {
    1:         if (*s == c)
    1:             return (jschar *)s;
    1:         s++;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: jschar *
 8893: js_InflateString(JSContext *cx, const char *bytes, size_t *lengthp)
    1: {
 8893:     size_t nbytes, nchars, i;
 8893:     jschar *chars;
 8893: #ifdef DEBUG
 8893:     JSBool ok;
 8893: #endif
 8893: 
 8893:     nbytes = *lengthp;
 8893:     if (js_CStringsAreUTF8) {
 8893:         if (!js_InflateStringToBuffer(cx, bytes, nbytes, NULL, &nchars))
 8893:             goto bad;
30851:         chars = (jschar *) cx->malloc((nchars + 1) * sizeof (jschar));
 8893:         if (!chars)
 8893:             goto bad;
 8893: #ifdef DEBUG
 8893:         ok =
 8893: #endif
 8893:             js_InflateStringToBuffer(cx, bytes, nbytes, chars, &nchars);
 8893:         JS_ASSERT(ok);
 8893:     } else {
 8893:         nchars = nbytes;
30851:         chars = (jschar *) cx->malloc((nchars + 1) * sizeof(jschar));
 8893:         if (!chars)
 8893:             goto bad;
 8893:         for (i = 0; i < nchars; i++)
 8893:             chars[i] = (unsigned char) bytes[i];
 8893:     }
 8893:     *lengthp = nchars;
 8893:     chars[nchars] = 0;
 8893:     return chars;
 8893: 
 8893:   bad:
 8893:     /*
 8893:      * For compatibility with callers of JS_DecodeBytes we must zero lengthp
 8893:      * on errors.
 8893:      */
 8893:     *lengthp = 0;
    1:     return NULL;
    1: }
    1: 
    1: /*
    1:  * May be called with null cx by js_GetStringBytes, see below.
    1:  */
    1: char *
 8893: js_DeflateString(JSContext *cx, const jschar *chars, size_t nchars)
    1: {
 8893:     size_t nbytes, i;
    1:     char *bytes;
 8893: #ifdef DEBUG
 8893:     JSBool ok;
 8893: #endif
 8893: 
 8893:     if (js_CStringsAreUTF8) {
 8893:         nbytes = js_GetDeflatedStringLength(cx, chars, nchars);
 8893:         if (nbytes == (size_t) -1)
    1:             return NULL;
30851:         bytes = (char *) (cx ? cx->malloc(nbytes + 1) : js_malloc(nbytes + 1));
    1:         if (!bytes)
    1:             return NULL;
 8893: #ifdef DEBUG
 8893:         ok =
 8893: #endif
 8893:             js_DeflateStringToBuffer(cx, chars, nchars, bytes, &nbytes);
 8893:         JS_ASSERT(ok);
 8893:     } else {
 8893:         nbytes = nchars;
30851:         bytes = (char *) (cx ? cx->malloc(nbytes + 1) : js_malloc(nbytes + 1));
 8893:         if (!bytes)
 8893:             return NULL;
 8893:         for (i = 0; i < nbytes; i++)
 8893:             bytes[i] = (char) chars[i];
 8893:     }
 8893:     bytes[nbytes] = 0;
    1:     return bytes;
    1: }
    1: 
40444: size_t
40444: js_GetDeflatedStringLength(JSContext *cx, const jschar *chars, size_t nchars)
40444: {
40444:     if (!js_CStringsAreUTF8)
40444:         return nchars;
40444: 
40444:     return js_GetDeflatedUTF8StringLength(cx, chars, nchars);
40444: }
40444: 
    1: /*
    1:  * May be called with null cx through js_GetStringBytes, see below.
    1:  */
    1: size_t
40444: js_GetDeflatedUTF8StringLength(JSContext *cx, const jschar *chars, size_t nchars)
    1: {
 8893:     size_t nbytes;
    1:     const jschar *end;
    1:     uintN c, c2;
    1:     char buffer[10];
    1: 
 8893:     nbytes = nchars;
 8893:     for (end = chars + nchars; chars != end; chars++) {
    1:         c = *chars;
    1:         if (c < 0x80)
    1:             continue;
    1:         if (0xD800 <= c && c <= 0xDFFF) {
    1:             /* Surrogate pair. */
    1:             chars++;
56209: 
56209:             /* nbytes sets 1 length since this is surrogate pair. */
56209:             nbytes--;
    1:             if (c >= 0xDC00 || chars == end)
    1:                 goto bad_surrogate;
    1:             c2 = *chars;
    1:             if (c2 < 0xDC00 || c2 > 0xDFFF)
    1:                 goto bad_surrogate;
    1:             c = ((c - 0xD800) << 10) + (c2 - 0xDC00) + 0x10000;
    1:         }
    1:         c >>= 11;
 8893:         nbytes++;
    1:         while (c) {
    1:             c >>= 5;
 8893:             nbytes++;
 8893:         }
 8893:     }
 8893:     return nbytes;
    1: 
    1:   bad_surrogate:
    1:     if (cx) {
    1:         JS_snprintf(buffer, 10, "0x%x", c);
    1:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage,
    1:                                      NULL, JSMSG_BAD_SURROGATE_CHAR, buffer);
    1:     }
    1:     return (size_t) -1;
    1: }
    1: 
    1: JSBool
    1: js_DeflateStringToBuffer(JSContext *cx, const jschar *src, size_t srclen,
    1:                          char *dst, size_t *dstlenp)
    1: {
40444:     size_t dstlen, i;
    1: 
 8893:     dstlen = *dstlenp;
 8893:     if (!js_CStringsAreUTF8) {
 8893:         if (srclen > dstlen) {
 8893:             for (i = 0; i < dstlen; i++)
 8893:                 dst[i] = (char) src[i];
 8893:             if (cx) {
 8893:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 8893:                                      JSMSG_BUFFER_TOO_SMALL);
 8893:             }
 8893:             return JS_FALSE;
 8893:         }
 8893:         for (i = 0; i < srclen; i++)
 8893:             dst[i] = (char) src[i];
 8893:         *dstlenp = srclen;
 8893:         return JS_TRUE;
 8893:     }
 8893: 
40444:     return js_DeflateStringToUTF8Buffer(cx, src, srclen, dst, dstlenp);
40444: }
40444: 
40444: JSBool
40444: js_DeflateStringToUTF8Buffer(JSContext *cx, const jschar *src, size_t srclen,
40444:                              char *dst, size_t *dstlenp)
40444: {
40444:     size_t dstlen, i, origDstlen, utf8Len;
40444:     jschar c, c2;
40444:     uint32 v;
40444:     uint8 utf8buf[6];
40444: 
40444:     dstlen = *dstlenp;
 8893:     origDstlen = dstlen;
    1:     while (srclen) {
    1:         c = *src++;
    1:         srclen--;
    1:         if ((c >= 0xDC00) && (c <= 0xDFFF))
    1:             goto badSurrogate;
    1:         if (c < 0xD800 || c > 0xDBFF) {
    1:             v = c;
    1:         } else {
    1:             if (srclen < 1)
    1:                 goto badSurrogate;
    1:             c2 = *src;
    1:             if ((c2 < 0xDC00) || (c2 > 0xDFFF))
    1:                 goto badSurrogate;
    1:             src++;
    1:             srclen--;
    1:             v = ((c - 0xD800) << 10) + (c2 - 0xDC00) + 0x10000;
    1:         }
    1:         if (v < 0x0080) {
    1:             /* no encoding necessary - performance hack */
 2539:             if (dstlen == 0)
    1:                 goto bufferTooSmall;
    1:             *dst++ = (char) v;
    1:             utf8Len = 1;
    1:         } else {
    1:             utf8Len = js_OneUcs4ToUtf8Char(utf8buf, v);
    1:             if (utf8Len > dstlen)
    1:                 goto bufferTooSmall;
    1:             for (i = 0; i < utf8Len; i++)
    1:                 *dst++ = (char) utf8buf[i];
    1:         }
    1:         dstlen -= utf8Len;
    1:     }
    1:     *dstlenp = (origDstlen - dstlen);
    1:     return JS_TRUE;
    1: 
    1: badSurrogate:
    1:     *dstlenp = (origDstlen - dstlen);
    1:     /* Delegate error reporting to the measurement function. */
    1:     if (cx)
    1:         js_GetDeflatedStringLength(cx, src - 1, srclen + 1);
    1:     return JS_FALSE;
    1: 
    1: bufferTooSmall:
    1:     *dstlenp = (origDstlen - dstlen);
    1:     if (cx) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BUFFER_TOO_SMALL);
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: JSBool
    1: js_InflateStringToBuffer(JSContext *cx, const char *src, size_t srclen,
    1:                          jschar *dst, size_t *dstlenp)
    1: {
40444:     size_t dstlen, i;
 8893: 
 8893:     if (!js_CStringsAreUTF8) {
 8893:         if (dst) {
 8893:             dstlen = *dstlenp;
 8893:             if (srclen > dstlen) {
 8893:                 for (i = 0; i < dstlen; i++)
 8893:                     dst[i] = (unsigned char) src[i];
 8893:                 if (cx) {
 8893:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 8893:                                          JSMSG_BUFFER_TOO_SMALL);
 8893:                 }
 8893:                 return JS_FALSE;
 8893:             }
 8893:             for (i = 0; i < srclen; i++)
 8893:                 dst[i] = (unsigned char) src[i];
 8893:         }
 8893:         *dstlenp = srclen;
 8893:         return JS_TRUE;
 8893:     }
 8893: 
40444:     return js_InflateUTF8StringToBuffer(cx, src, srclen, dst, dstlenp);
40444: }
40444: 
40444: JSBool
40444: js_InflateUTF8StringToBuffer(JSContext *cx, const char *src, size_t srclen,
40444:                              jschar *dst, size_t *dstlenp)
40444: {
40444:     size_t dstlen, origDstlen, offset, j, n;
40444:     uint32 v;
40444: 
 8893:     dstlen = dst ? *dstlenp : (size_t) -1;
 8893:     origDstlen = dstlen;
 8893:     offset = 0;
    1: 
    1:     while (srclen) {
    1:         v = (uint8) *src;
    1:         n = 1;
    1:         if (v & 0x80) {
    1:             while (v & (0x80 >> n))
    1:                 n++;
    1:             if (n > srclen)
    1:                 goto bufferTooSmall;
33589:             if (n == 1 || n > 4)
    1:                 goto badCharacter;
    1:             for (j = 1; j < n; j++) {
    1:                 if ((src[j] & 0xC0) != 0x80)
    1:                     goto badCharacter;
    1:             }
  363:             v = Utf8ToOneUcs4Char((uint8 *)src, n);
    1:             if (v >= 0x10000) {
    1:                 v -= 0x10000;
    1:                 if (v > 0xFFFFF || dstlen < 2) {
    1:                     *dstlenp = (origDstlen - dstlen);
    1:                     if (cx) {
    1:                         char buffer[10];
    1:                         JS_snprintf(buffer, 10, "0x%x", v + 0x10000);
    1:                         JS_ReportErrorFlagsAndNumber(cx,
    1:                                                      JSREPORT_ERROR,
    1:                                                      js_GetErrorMessage, NULL,
    1:                                                      JSMSG_UTF8_CHAR_TOO_LARGE,
    1:                                                      buffer);
    1:                     }
    1:                     return JS_FALSE;
    1:                 }
    1:                 if (dst) {
    1:                     *dst++ = (jschar)((v >> 10) + 0xD800);
    1:                     v = (jschar)((v & 0x3FF) + 0xDC00);
    1:                 }
    1:                 dstlen--;
    1:             }
    1:         }
    1:         if (!dstlen)
    1:             goto bufferTooSmall;
    1:         if (dst)
    1:             *dst++ = (jschar) v;
    1:         dstlen--;
    1:         offset += n;
    1:         src += n;
    1:         srclen -= n;
    1:     }
    1:     *dstlenp = (origDstlen - dstlen);
    1:     return JS_TRUE;
    1: 
    1: badCharacter:
    1:     *dstlenp = (origDstlen - dstlen);
    1:     if (cx) {
    1:         char buffer[10];
    1:         JS_snprintf(buffer, 10, "%d", offset);
    1:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR,
    1:                                      js_GetErrorMessage, NULL,
    1:                                      JSMSG_MALFORMED_UTF8_CHAR,
    1:                                      buffer);
    1:     }
    1:     return JS_FALSE;
    1: 
    1: bufferTooSmall:
    1:     *dstlenp = (origDstlen - dstlen);
    1:     if (cx) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BUFFER_TOO_SMALL);
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
40281: namespace js {
40281: 
40281: DeflatedStringCache::DeflatedStringCache()
    1: {
40281: #ifdef JS_THREADSAFE
40281:     lock = NULL;
    1: #endif
27477: }
    1: 
40281: bool
40281: DeflatedStringCache::init()
40281: {
40281: #ifdef JS_THREADSAFE
40281:     JS_ASSERT(!lock);
40281:     lock = JS_NEW_LOCK();
40281:     if (!lock)
40281:         return false;
40281: #endif
40281: 
40281:     /*
40281:      * Make room for 2K deflated strings that a typical browser session
40281:      * creates.
40281:      */
40281:     return map.init(2048);
40281: }
40281: 
40281: DeflatedStringCache::~DeflatedStringCache()
40281: {
40281: #ifdef JS_THREADSAFE
40281:     if (lock)
40281:         JS_DESTROY_LOCK(lock);
40281: #endif
40281: }
40281: 
40281: void
40281: DeflatedStringCache::sweep(JSContext *cx)
40281: {
40281:     /*
40281:      * We must take a lock even during the GC as JS_GetStringBytes() can be
40281:      * called outside the request.
40281:      */
40281:     JS_ACQUIRE_LOCK(lock);
40281: 
40281:     for (Map::Enum e(map); !e.empty(); e.popFront()) {
40281:         JSString *str = e.front().key;
54707:         if (IsAboutToBeFinalized(str)) {
40281:             char *bytes = e.front().value;
40281:             e.removeFront();
40281: 
40281:             /*
40281:              * We cannot use cx->free here as bytes may come from the
40281:              * embedding that calls JS_NewString(cx, bytes, length). Those
40281:              * bytes may not be allocated via js_malloc and may not have
40281:              * space for the background free list.
40281:              */
40281:             js_free(bytes);
40281:         }
40281:     }
40281: 
40281:     JS_RELEASE_LOCK(lock);
40281: }
40281: 
40281: void
40281: DeflatedStringCache::remove(JSString *str)
40281: {
40281:     JS_ACQUIRE_LOCK(lock);
40281: 
40281:     Map::Ptr p = map.lookup(str);
40281:     if (p) {
40281:         js_free(p->value);
40281:         map.remove(p);
40281:     }
40281: 
40281:     JS_RELEASE_LOCK(lock);
40281: }
40281: 
40281: bool
40281: DeflatedStringCache::setBytes(JSContext *cx, JSString *str, char *bytes)
40281: {
40281:     JS_ACQUIRE_LOCK(lock);
40281: 
40281:     Map::AddPtr p = map.lookupForAdd(str);
40281:     JS_ASSERT(!p);
40281:     bool ok = map.add(p, str, bytes);
40281: 
40281:     JS_RELEASE_LOCK(lock);
40281: 
40281:     if (!ok)
40281:         js_ReportOutOfMemory(cx);
    1:     return ok;
    1: }
    1: 
40281: char *
40281: DeflatedStringCache::getBytes(JSContext *cx, JSString *str)
40281: {
40281:     JS_ACQUIRE_LOCK(lock);
40281:     Map::AddPtr p = map.lookupForAdd(str);
42645:     char *bytes = p ? p->value : NULL;
40281:     JS_RELEASE_LOCK(lock);
42645: 
42645:     if (bytes)
42645:         return bytes;
42645: 
40281:     bytes = js_DeflateString(cx, str->chars(), str->length());
40281:     if (!bytes)
40281:         return NULL;
42645: 
42645:     /*
42645:      * In the single-threaded case we use the add method as js_DeflateString
42645:      * cannot mutate the map. In particular, it cannot run the GC that may
42645:      * delete entries from the map. But the JS_THREADSAFE version requires to
42645:      * deal with other threads adding the entries to the map.
42645:      */
42645:     char *bytesToFree = NULL;
42722:     JSBool ok;
40281: #ifdef JS_THREADSAFE
40281:     JS_ACQUIRE_LOCK(lock);
42722:     ok = map.relookupOrAdd(p, str, bytes);
42722:     if (ok && p->value != bytes) {
40281:         /* Some other thread has asked for str bytes .*/
42645:         JS_ASSERT(!strcmp(p->value, bytes));
42645:         bytesToFree = bytes;
42645:         bytes = p->value;
42645:     }
42645:     JS_RELEASE_LOCK(lock);
42645: #else  /* !JS_THREADSAFE */
42722:     ok = map.add(p, str, bytes);
42722: #endif
42722:     if (!ok) {
42645:         bytesToFree = bytes;
42645:         bytes = NULL;
42722:         if (cx)
42722:             js_ReportOutOfMemory(cx);
42722:     }
42645: 
42645:     if (bytesToFree) {
40281:         if (cx)
42645:             cx->free(bytesToFree);
40281:         else
42645:             js_free(bytesToFree);
42645:     }
40281:     return bytes;
40281: }
40281: 
40281: } /* namespace js */
40281: 
    1: const char *
    1: js_GetStringBytes(JSContext *cx, JSString *str)
    1: {
    1:     JSRuntime *rt;
    1:     char *bytes;
    1: 
32702:     if (JSString::isUnitString(str)) {
32674: #ifdef IS_LITTLE_ENDIAN
32674:         /* Unit string data is {c, 0, 0, 0} so we can just cast. */
37696:         bytes = (char *)str->chars();
32674: #else
32674:         /* Unit string data is {0, c, 0, 0} so we can point into the middle. */
37696:         bytes = (char *)str->chars() + 1;
32674: #endif
37696:         return ((*bytes & 0x80) && js_CStringsAreUTF8)
37696:                ? JSString::deflatedUnitStringTable + ((*bytes & 0x7f) * 3)
37696:                : bytes;
32674:     }
32674: 
32702:     /*
48610:      * We must burn some space on deflated int strings and length-2 strings
48610:      * to preserve static allocation (which is to say, JSRuntime independence).
32702:      */
48610:     if (JSString::isLength2String(str))
48610:         return JSString::deflatedLength2StringTable + ((str - JSString::length2StringTable) * 3);
48610: 
48610:     if (JSString::isHundredString(str)) {
48610:         /*
48610:          * We handled the 1 and 2-digit number cases already, so we know that
48610:          * str is between 100 and 255.
48610:          */
48610:         return JSString::deflatedIntStringTable + ((str - JSString::hundredStringTable) * 4);
32702:     }
32702: 
    1:     if (cx) {
    1:         rt = cx->runtime;
    1:     } else {
    1:         /* JS_GetStringBytes calls us with null cx. */
54707:         rt = GetGCThingRuntime(str);
    1:     }
    1: 
40281:     return rt->deflatedStringCache->getBytes(cx, str);
    1: }
    1: 
    1: /*
    1:  * From java.lang.Character.java:
    1:  *
    1:  * The character properties are currently encoded into 32 bits in the
    1:  * following manner:
    1:  *
    1:  * 10 bits      signed offset used for converting case
    1:  *  1 bit       if 1, adding the signed offset converts the character to
    1:  *              lowercase
    1:  *  1 bit       if 1, subtracting the signed offset converts the character to
    1:  *              uppercase
    1:  *  1 bit       if 1, character has a titlecase equivalent (possibly itself)
    1:  *  3 bits      0  may not be part of an identifier
    1:  *              1  ignorable control; may continue a Unicode identifier or JS
    1:  *                 identifier
    1:  *              2  may continue a JS identifier but not a Unicode identifier
    1:  *                 (unused)
    1:  *              3  may continue a Unicode identifier or JS identifier
    1:  *              4  is a JS whitespace character
    1:  *              5  may start or continue a JS identifier;
    1:  *                 may continue but not start a Unicode identifier (_)
    1:  *              6  may start or continue a JS identifier but not a Unicode
    1:  *                 identifier ($)
    1:  *              7  may start or continue a Unicode identifier or JS identifier
    1:  *              Thus:
    1:  *                 5, 6, 7 may start a JS identifier
    1:  *                 1, 2, 3, 5, 6, 7 may continue a JS identifier
    1:  *                 7 may start a Unicode identifier
    1:  *                 1, 3, 5, 7 may continue a Unicode identifier
    1:  *                 1 is ignorable within an identifier
    1:  *                 4 is JS whitespace
    1:  *  2 bits      0  this character has no numeric property
    1:  *              1  adding the digit offset to the character code and then
    1:  *                 masking with 0x1F will produce the desired numeric value
    1:  *              2  this character has a "strange" numeric value
    1:  *              3  a JS supradecimal digit: adding the digit offset to the
    1:  *                 character code, then masking with 0x1F, then adding 10
    1:  *                 will produce the desired numeric value
    1:  *  5 bits      digit offset
    1:  *  1 bit       XML 1.0 name start character
    1:  *  1 bit       XML 1.0 name character
    1:  *  2 bits      reserved for future use
    1:  *  5 bits      character type
    1:  */
    1: 
    1: /* The X table has 1024 entries for a total of 1024 bytes. */
    1: 
    1: const uint8 js_X[] = {
    1:   0,   1,   2,   3,   4,   5,   6,   7,  /*  0x0000 */
    1:   8,   9,  10,  11,  12,  13,  14,  15,  /*  0x0200 */
    1:  16,  17,  18,  19,  20,  21,  22,  23,  /*  0x0400 */
    1:  24,  25,  26,  27,  28,  28,  28,  28,  /*  0x0600 */
    1:  28,  28,  28,  28,  29,  30,  31,  32,  /*  0x0800 */
    1:  33,  34,  35,  36,  37,  38,  39,  40,  /*  0x0A00 */
    1:  41,  42,  43,  44,  45,  46,  28,  28,  /*  0x0C00 */
    1:  47,  48,  49,  50,  51,  52,  53,  28,  /*  0x0E00 */
    1:  28,  28,  54,  55,  56,  57,  58,  59,  /*  0x1000 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1200 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1400 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1600 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1800 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1A00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1C00 */
    1:  60,  60,  61,  62,  63,  64,  65,  66,  /*  0x1E00 */
    1:  67,  68,  69,  70,  71,  72,  73,  74,  /*  0x2000 */
    1:  75,  75,  75,  76,  77,  78,  28,  28,  /*  0x2200 */
    1:  79,  80,  81,  82,  83,  83,  84,  85,  /*  0x2400 */
    1:  86,  85,  28,  28,  87,  88,  89,  28,  /*  0x2600 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x2800 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x2A00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x2C00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x2E00 */
    1:  90,  91,  92,  93,  94,  56,  95,  28,  /*  0x3000 */
    1:  96,  97,  98,  99,  83, 100,  83, 101,  /*  0x3200 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3400 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3600 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3800 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3A00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3C00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3E00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4000 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4200 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4400 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4600 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4800 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4A00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4C00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x4E00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5A00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5C00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5E00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6A00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6C00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6E00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7A00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7C00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7E00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8A00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8C00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8E00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9A00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9C00 */
    1:  56,  56,  56,  56,  56,  56, 102,  28,  /*  0x9E00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xA000 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xA200 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xA400 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xA600 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xA800 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xAA00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xAC00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xAE00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xB000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xB200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xB400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xB600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xB800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xBA00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xBC00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xBE00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xC000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xC200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xC400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xC600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xC800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xCA00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xCC00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xCE00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xD000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xD200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xD400 */
    1:  56,  56,  56,  56,  56,  56, 103,  28,  /*  0xD600 */
    1: 104, 104, 104, 104, 104, 104, 104, 104,  /*  0xD800 */
    1: 104, 104, 104, 104, 104, 104, 104, 104,  /*  0xDA00 */
    1: 104, 104, 104, 104, 104, 104, 104, 104,  /*  0xDC00 */
    1: 104, 104, 104, 104, 104, 104, 104, 104,  /*  0xDE00 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xE000 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xE200 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xE400 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xE600 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xE800 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xEA00 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xEC00 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xEE00 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xF000 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xF200 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xF400 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xF600 */
    1: 105, 105, 105, 105,  56,  56,  56,  56,  /*  0xF800 */
    1: 106,  28,  28,  28, 107, 108, 109, 110,  /*  0xFA00 */
    1:  56,  56,  56,  56, 111, 112, 113, 114,  /*  0xFC00 */
    1: 115, 116,  56, 117, 118, 119, 120, 121   /*  0xFE00 */
    1: };
    1: 
    1: /* The Y table has 7808 entries for a total of 7808 bytes. */
    1: 
    1: const uint8 js_Y[] = {
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    0 */
    1:   0,   1,   1,   1,   1,   1,   0,   0,  /*    0 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    0 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    0 */
    1:   2,   3,   3,   3,   4,   3,   3,   3,  /*    0 */
    1:   5,   6,   3,   7,   3,   8,   3,   3,  /*    0 */
    1:   9,   9,   9,   9,   9,   9,   9,   9,  /*    0 */
    1:   9,   9,   3,   3,   7,   7,   7,   3,  /*    0 */
    1:   3,  10,  10,  10,  10,  10,  10,  10,  /*    1 */
    1:  10,  10,  10,  10,  10,  10,  10,  10,  /*    1 */
    1:  10,  10,  10,  10,  10,  10,  10,  10,  /*    1 */
    1:  10,  10,  10,   5,   3,   6,  11,  12,  /*    1 */
    1:  11,  13,  13,  13,  13,  13,  13,  13,  /*    1 */
    1:  13,  13,  13,  13,  13,  13,  13,  13,  /*    1 */
    1:  13,  13,  13,  13,  13,  13,  13,  13,  /*    1 */
    1:  13,  13,  13,   5,   7,   6,   7,   0,  /*    1 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    2 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    2 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    2 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    2 */
    1:   2,   3,   4,   4,   4,   4,  15,  15,  /*    2 */
    1:  11,  15,  16,   5,   7,   8,  15,  11,  /*    2 */
    1:  15,   7,  17,  17,  11,  16,  15,   3,  /*    2 */
    1:  11,  18,  16,   6,  19,  19,  19,   3,  /*    2 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*    3 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*    3 */
    1:  20,  20,  20,  20,  20,  20,  20,   7,  /*    3 */
    1:  20,  20,  20,  20,  20,  20,  20,  16,  /*    3 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*    3 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*    3 */
    1:  21,  21,  21,  21,  21,  21,  21,   7,  /*    3 */
    1:  21,  21,  21,  21,  21,  21,  21,  22,  /*    3 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  25,  26,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  16,  23,  24,  23,  24,  23,  24,  23,  /*    4 */
    1:  24,  23,  24,  23,  24,  23,  24,  23,  /*    5 */
    1:  24,  16,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  27,  23,  24,  23,  24,  23,  24,  28,  /*    5 */
    1:  16,  29,  23,  24,  23,  24,  30,  23,  /*    6 */
    1:  24,  31,  31,  23,  24,  16,  32,  32,  /*    6 */
    1:  33,  23,  24,  31,  34,  16,  35,  36,  /*    6 */
    1:  23,  24,  16,  16,  35,  37,  16,  38,  /*    6 */
    1:  23,  24,  23,  24,  23,  24,  38,  23,  /*    6 */
    1:  24,  39,  40,  16,  23,  24,  39,  23,  /*    6 */
    1:  24,  41,  41,  23,  24,  23,  24,  42,  /*    6 */
    1:  23,  24,  16,  40,  23,  24,  40,  40,  /*    6 */
    1:  40,  40,  40,  40,  43,  44,  45,  43,  /*    7 */
    1:  44,  45,  43,  44,  45,  23,  24,  23,  /*    7 */
    1:  24,  23,  24,  23,  24,  23,  24,  23,  /*    7 */
    1:  24,  23,  24,  23,  24,  16,  23,  24,  /*    7 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    7 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    7 */
    1:  16,  43,  44,  45,  23,  24,  46,  46,  /*    7 */
    1:  46,  46,  23,  24,  23,  24,  23,  24,  /*    7 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    8 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    8 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    9 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    9 */
    1:  16,  16,  16,  47,  48,  16,  49,  49,  /*    9 */
    1:  50,  50,  16,  51,  16,  16,  16,  16,  /*    9 */
    1:  49,  16,  16,  52,  16,  16,  16,  16,  /*    9 */
    1:  53,  54,  16,  16,  16,  16,  16,  54,  /*    9 */
    1:  16,  16,  55,  16,  16,  16,  16,  16,  /*    9 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*    9 */
    1:  16,  16,  16,  56,  16,  16,  16,  16,  /*   10 */
    1:  56,  16,  57,  57,  16,  16,  16,  16,  /*   10 */
    1:  16,  16,  58,  16,  16,  16,  16,  16,  /*   10 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   10 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   10 */
    1:  16,  46,  46,  46,  46,  46,  46,  46,  /*   10 */
    1:  59,  59,  59,  59,  59,  59,  59,  59,  /*   10 */
    1:  59,  11,  11,  59,  59,  59,  59,  59,  /*   10 */
    1:  59,  59,  11,  11,  11,  11,  11,  11,  /*   11 */
    1:  11,  11,  11,  11,  11,  11,  11,  11,  /*   11 */
    1:  59,  59,  11,  11,  11,  11,  11,  11,  /*   11 */
    1:  11,  11,  11,  11,  11,  11,  11,  46,  /*   11 */
    1:  59,  59,  59,  59,  59,  11,  11,  11,  /*   11 */
    1:  11,  11,  46,  46,  46,  46,  46,  46,  /*   11 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   11 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   11 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  46,  46,  /*   13 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   13 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   13 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   13 */
    1:  60,  60,  46,  46,  46,  46,  46,  46,  /*   13 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   13 */
    1:  46,  46,  46,  46,   3,   3,  46,  46,  /*   13 */
    1:  46,  46,  59,  46,  46,  46,   3,  46,  /*   13 */
    1:  46,  46,  46,  46,  11,  11,  61,   3,  /*   14 */
    1:  62,  62,  62,  46,  63,  46,  64,  64,  /*   14 */
    1:  16,  20,  20,  20,  20,  20,  20,  20,  /*   14 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*   14 */
    1:  20,  20,  46,  20,  20,  20,  20,  20,  /*   14 */
    1:  20,  20,  20,  20,  65,  66,  66,  66,  /*   14 */
    1:  16,  21,  21,  21,  21,  21,  21,  21,  /*   14 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*   14 */
    1:  21,  21,  16,  21,  21,  21,  21,  21,  /*   15 */
    1:  21,  21,  21,  21,  67,  68,  68,  46,  /*   15 */
    1:  69,  70,  38,  38,  38,  71,  72,  46,  /*   15 */
    1:  46,  46,  38,  46,  38,  46,  38,  46,  /*   15 */
    1:  38,  46,  23,  24,  23,  24,  23,  24,  /*   15 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   15 */
    1:  73,  74,  16,  40,  46,  46,  46,  46,  /*   15 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   15 */
    1:  46,  75,  75,  75,  75,  75,  75,  75,  /*   16 */
    1:  75,  75,  75,  75,  75,  46,  75,  75,  /*   16 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*   16 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*   16 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*   16 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*   16 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*   16 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*   16 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*   17 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*   17 */
    1:  46,  74,  74,  74,  74,  74,  74,  74,  /*   17 */
    1:  74,  74,  74,  74,  74,  46,  74,  74,  /*   17 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   17 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   17 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   17 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   17 */
    1:  23,  24,  15,  60,  60,  60,  60,  46,  /*   18 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  40,  23,  24,  23,  24,  46,  46,  23,  /*   19 */
    1:  24,  46,  46,  23,  24,  46,  46,  46,  /*   19 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   19 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   19 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   19 */
    1:  23,  24,  23,  24,  46,  46,  23,  24,  /*   19 */
    1:  23,  24,  23,  24,  23,  24,  46,  46,  /*   19 */
    1:  23,  24,  46,  46,  46,  46,  46,  46,  /*   19 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  76,  76,  76,  76,  76,  76,  76,  /*   20 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   20 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   21 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   21 */
    1:  76,  76,  76,  76,  76,  76,  76,  46,  /*   21 */
    1:  46,  59,   3,   3,   3,   3,   3,   3,  /*   21 */
    1:  46,  77,  77,  77,  77,  77,  77,  77,  /*   21 */
    1:  77,  77,  77,  77,  77,  77,  77,  77,  /*   21 */
    1:  77,  77,  77,  77,  77,  77,  77,  77,  /*   21 */
    1:  77,  77,  77,  77,  77,  77,  77,  77,  /*   21 */
    1:  77,  77,  77,  77,  77,  77,  77,  16,  /*   22 */
    1:  46,   3,  46,  46,  46,  46,  46,  46,  /*   22 */
    1:  46,  60,  60,  60,  60,  60,  60,  60,  /*   22 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   22 */
    1:  60,  60,  46,  60,  60,  60,  60,  60,  /*   22 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   22 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   22 */
    1:  60,  60,  46,  60,  60,  60,   3,  60,  /*   22 */
    1:   3,  60,  60,   3,  60,  46,  46,  46,  /*   23 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   23 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   23 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   23 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   23 */
    1:  40,  40,  40,  46,  46,  46,  46,  46,  /*   23 */
    1:  40,  40,  40,   3,   3,  46,  46,  46,  /*   23 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   23 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   24 */
    1:  46,  46,  46,  46,   3,  46,  46,  46,  /*   24 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   24 */
    1:  46,  46,  46,   3,  46,  46,  46,   3,  /*   24 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   24 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   24 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   24 */
    1:  40,  40,  40,  46,  46,  46,  46,  46,  /*   24 */
    1:  59,  40,  40,  40,  40,  40,  40,  40,  /*   25 */
    1:  40,  40,  40,  60,  60,  60,  60,  60,  /*   25 */
    1:  60,  60,  60,  46,  46,  46,  46,  46,  /*   25 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   25 */
    1:  78,  78,  78,  78,  78,  78,  78,  78,  /*   25 */
    1:  78,  78,   3,   3,   3,   3,  46,  46,  /*   25 */
    1:  60,  40,  40,  40,  40,  40,  40,  40,  /*   25 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   25 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  46,  46,  40,  40,  40,  40,  40,  46,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   27 */
    1:  40,  40,  40,  40,  40,  40,  40,  46,  /*   27 */
    1:  40,  40,  40,  40,   3,  40,  60,  60,  /*   27 */
    1:  60,  60,  60,  60,  60,  79,  79,  60,  /*   27 */
    1:  60,  60,  60,  60,  60,  59,  59,  60,  /*   27 */
    1:  60,  15,  60,  60,  60,  60,  46,  46,  /*   27 */
    1:   9,   9,   9,   9,   9,   9,   9,   9,  /*   27 */
    1:   9,   9,  46,  46,  46,  46,  46,  46,  /*   27 */
36430:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
36430:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  60,  60,  80,  46,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  46,  46,  60,  40,  80,  80,  /*   29 */
    1:  80,  60,  60,  60,  60,  60,  60,  60,  /*   30 */
    1:  60,  80,  80,  80,  80,  60,  46,  46,  /*   30 */
    1:  15,  60,  60,  60,  60,  46,  46,  46,  /*   30 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   30 */
    1:  40,  40,  60,  60,   3,   3,  81,  81,  /*   30 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   30 */
    1:   3,  46,  46,  46,  46,  46,  46,  46,  /*   30 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   30 */
    1:  46,  60,  80,  80,  46,  40,  40,  40,  /*   31 */
    1:  40,  40,  40,  40,  40,  46,  46,  40,  /*   31 */
    1:  40,  46,  46,  40,  40,  40,  40,  40,  /*   31 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   31 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   31 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   31 */
    1:  40,  46,  40,  46,  46,  46,  40,  40,  /*   31 */
    1:  40,  40,  46,  46,  60,  46,  80,  80,  /*   31 */
    1:  80,  60,  60,  60,  60,  46,  46,  80,  /*   32 */
    1:  80,  46,  46,  80,  80,  60,  46,  46,  /*   32 */
    1:  46,  46,  46,  46,  46,  46,  46,  80,  /*   32 */
    1:  46,  46,  46,  46,  40,  40,  46,  40,  /*   32 */
    1:  40,  40,  60,  60,  46,  46,  81,  81,  /*   32 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   32 */
    1:  40,  40,   4,   4,  82,  82,  82,  82,  /*   32 */
    1:  19,  83,  15,  46,  46,  46,  46,  46,  /*   32 */
    1:  46,  46,  60,  46,  46,  40,  40,  40,  /*   33 */
    1:  40,  40,  40,  46,  46,  46,  46,  40,  /*   33 */
    1:  40,  46,  46,  40,  40,  40,  40,  40,  /*   33 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   33 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   33 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   33 */
    1:  40,  46,  40,  40,  46,  40,  40,  46,  /*   33 */
    1:  40,  40,  46,  46,  60,  46,  80,  80,  /*   33 */
    1:  80,  60,  60,  46,  46,  46,  46,  60,  /*   34 */
    1:  60,  46,  46,  60,  60,  60,  46,  46,  /*   34 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   34 */
    1:  46,  40,  40,  40,  40,  46,  40,  46,  /*   34 */
    1:  46,  46,  46,  46,  46,  46,  81,  81,  /*   34 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   34 */
    1:  60,  60,  40,  40,  40,  46,  46,  46,  /*   34 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   34 */
    1:  46,  60,  60,  80,  46,  40,  40,  40,  /*   35 */
    1:  40,  40,  40,  40,  46,  40,  46,  40,  /*   35 */
    1:  40,  40,  46,  40,  40,  40,  40,  40,  /*   35 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   35 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   35 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   35 */
    1:  40,  46,  40,  40,  46,  40,  40,  40,  /*   35 */
    1:  40,  40,  46,  46,  60,  40,  80,  80,  /*   35 */
    1:  80,  60,  60,  60,  60,  60,  46,  60,  /*   36 */
    1:  60,  80,  46,  80,  80,  60,  46,  46,  /*   36 */
    1:  15,  46,  46,  46,  46,  46,  46,  46,  /*   36 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   36 */
    1:  40,  46,  46,  46,  46,  46,  81,  81,  /*   36 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   36 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   36 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   36 */
    1:  46,  60,  80,  80,  46,  40,  40,  40,  /*   37 */
    1:  40,  40,  40,  40,  40,  46,  46,  40,  /*   37 */
    1:  40,  46,  46,  40,  40,  40,  40,  40,  /*   37 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   37 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   37 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   37 */
    1:  40,  46,  40,  40,  46,  46,  40,  40,  /*   37 */
    1:  40,  40,  46,  46,  60,  40,  80,  60,  /*   37 */
    1:  80,  60,  60,  60,  46,  46,  46,  80,  /*   38 */
    1:  80,  46,  46,  80,  80,  60,  46,  46,  /*   38 */
    1:  46,  46,  46,  46,  46,  46,  60,  80,  /*   38 */
    1:  46,  46,  46,  46,  40,  40,  46,  40,  /*   38 */
    1:  40,  40,  46,  46,  46,  46,  81,  81,  /*   38 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   38 */
    1:  15,  46,  46,  46,  46,  46,  46,  46,  /*   38 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   38 */
    1:  46,  46,  60,  80,  46,  40,  40,  40,  /*   39 */
    1:  40,  40,  40,  46,  46,  46,  40,  40,  /*   39 */
    1:  40,  46,  40,  40,  40,  40,  46,  46,  /*   39 */
    1:  46,  40,  40,  46,  40,  46,  40,  40,  /*   39 */
    1:  46,  46,  46,  40,  40,  46,  46,  46,  /*   39 */
    1:  40,  40,  40,  46,  46,  46,  40,  40,  /*   39 */
    1:  40,  40,  40,  40,  40,  40,  46,  40,  /*   39 */
    1:  40,  40,  46,  46,  46,  46,  80,  80,  /*   39 */
    1:  60,  80,  80,  46,  46,  46,  80,  80,  /*   40 */
    1:  80,  46,  80,  80,  80,  60,  46,  46,  /*   40 */
    1:  46,  46,  46,  46,  46,  46,  46,  80,  /*   40 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   40 */
    1:  46,  46,  46,  46,  46,  46,  46,  81,  /*   40 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   40 */
    1:  84,  19,  19,  46,  46,  46,  46,  46,  /*   40 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   40 */
    1:  46,  80,  80,  80,  46,  40,  40,  40,  /*   41 */
    1:  40,  40,  40,  40,  40,  46,  40,  40,  /*   41 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   41 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   41 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   41 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   41 */
    1:  40,  40,  40,  40,  46,  40,  40,  40,  /*   41 */
    1:  40,  40,  46,  46,  46,  46,  60,  60,  /*   41 */
    1:  60,  80,  80,  80,  80,  46,  60,  60,  /*   42 */
    1:  60,  46,  60,  60,  60,  60,  46,  46,  /*   42 */
    1:  46,  46,  46,  46,  46,  60,  60,  46,  /*   42 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   42 */
    1:  40,  40,  46,  46,  46,  46,  81,  81,  /*   42 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   42 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   42 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   42 */
    1:  46,  46,  80,  80,  46,  40,  40,  40,  /*   43 */
    1:  40,  40,  40,  40,  40,  46,  40,  40,  /*   43 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   43 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   43 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   43 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   43 */
    1:  40,  40,  40,  40,  46,  40,  40,  40,  /*   43 */
    1:  40,  40,  46,  46,  46,  46,  80,  60,  /*   43 */
    1:  80,  80,  80,  80,  80,  46,  60,  80,  /*   44 */
    1:  80,  46,  80,  80,  60,  60,  46,  46,  /*   44 */
    1:  46,  46,  46,  46,  46,  80,  80,  46,  /*   44 */
    1:  46,  46,  46,  46,  46,  46,  40,  46,  /*   44 */
    1:  40,  40,  46,  46,  46,  46,  81,  81,  /*   44 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   44 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   44 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   44 */
    1:  46,  46,  80,  80,  46,  40,  40,  40,  /*   45 */
    1:  40,  40,  40,  40,  40,  46,  40,  40,  /*   45 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   45 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   45 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   45 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   45 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   45 */
    1:  40,  40,  46,  46,  46,  46,  80,  80,  /*   45 */
    1:  80,  60,  60,  60,  46,  46,  80,  80,  /*   46 */
    1:  80,  46,  80,  80,  80,  60,  46,  46,  /*   46 */
    1:  46,  46,  46,  46,  46,  46,  46,  80,  /*   46 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   46 */
    1:  40,  40,  46,  46,  46,  46,  81,  81,  /*   46 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   46 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   46 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   46 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  40,   3,  /*   47 */
    1:  40,  60,  40,  40,  60,  60,  60,  60,  /*   47 */
    1:  60,  60,  60,  46,  46,  46,  46,   4,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  59,  60,  /*   48 */
    1:  60,  60,  60,  60,  60,  60,  60,  15,  /*   48 */
    1:   9,   9,   9,   9,   9,   9,   9,   9,  /*   48 */
    1:   9,   9,   3,   3,  46,  46,  46,  46,  /*   48 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   48 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   48 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   48 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   48 */
    1:  46,  40,  40,  46,  40,  46,  46,  40,  /*   49 */
    1:  40,  46,  40,  46,  46,  40,  46,  46,  /*   49 */
    1:  46,  46,  46,  46,  40,  40,  40,  40,  /*   49 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   49 */
    1:  46,  40,  40,  40,  46,  40,  46,  40,  /*   49 */
    1:  46,  46,  40,  40,  46,  40,  40,   3,  /*   49 */
    1:  40,  60,  40,  40,  60,  60,  60,  60,  /*   49 */
    1:  60,  60,  46,  60,  60,  40,  46,  46,  /*   49 */
    1:  40,  40,  40,  40,  40,  46,  59,  46,  /*   50 */
    1:  60,  60,  60,  60,  60,  60,  46,  46,  /*   50 */
    1:   9,   9,   9,   9,   9,   9,   9,   9,  /*   50 */
    1:   9,   9,  46,  46,  40,  40,  46,  46,  /*   50 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   50 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   50 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   50 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   50 */
    1:  15,  15,  15,  15,   3,   3,   3,   3,  /*   51 */
    1:   3,   3,   3,   3,   3,   3,   3,   3,  /*   51 */
    1:   3,   3,   3,  15,  15,  15,  15,  15,  /*   51 */
    1:  60,  60,  15,  15,  15,  15,  15,  15,  /*   51 */
    1:  78,  78,  78,  78,  78,  78,  78,  78,  /*   51 */
    1:  78,  78,  85,  85,  85,  85,  85,  85,  /*   51 */
    1:  85,  85,  85,  85,  15,  60,  15,  60,  /*   51 */
    1:  15,  60,   5,   6,   5,   6,  80,  80,  /*   51 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   52 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   52 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   52 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   52 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   52 */
    1:  40,  40,  46,  46,  46,  46,  46,  46,  /*   52 */
    1:  46,  60,  60,  60,  60,  60,  60,  60,  /*   52 */
    1:  60,  60,  60,  60,  60,  60,  60,  80,  /*   52 */
    1:  60,  60,  60,  60,  60,   3,  60,  60,  /*   53 */
    1:  60,  60,  60,  60,  46,  46,  46,  46,  /*   53 */
    1:  60,  60,  60,  60,  60,  60,  46,  60,  /*   53 */
    1:  46,  60,  60,  60,  60,  60,  60,  60,  /*   53 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   53 */
    1:  60,  60,  60,  60,  60,  60,  46,  46,  /*   53 */
    1:  46,  60,  60,  60,  60,  60,  60,  60,  /*   53 */
    1:  46,  60,  46,  46,  46,  46,  46,  46,  /*   53 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   54 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   54 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   54 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   54 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   54 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   54 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   54 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   54 */
    1:  76,  76,  76,  76,  76,  76,  46,  46,  /*   55 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   55 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   55 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   55 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   55 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   55 */
    1:  16,  16,  16,  16,  16,  16,  16,  46,  /*   55 */
    1:  46,  46,  46,   3,  46,  46,  46,  46,  /*   55 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  46,  46,  46,  46,  46,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  46,  46,  46,  46,  46,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  46,  46,  46,  46,  46,  46,  /*   59 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  16,  16,  /*   61 */
    1:  16,  16,  16,  16,  46,  46,  46,  46,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  46,  46,  46,  46,  46,  46,  /*   62 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   63 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   63 */
    1:  86,  86,  86,  86,  86,  86,  46,  46,  /*   63 */
    1:  87,  87,  87,  87,  87,  87,  46,  46,  /*   63 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   63 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   63 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   63 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   63 */
    1:  86,  86,  86,  86,  86,  86,  46,  46,  /*   64 */
    1:  87,  87,  87,  87,  87,  87,  46,  46,  /*   64 */
    1:  16,  86,  16,  86,  16,  86,  16,  86,  /*   64 */
    1:  46,  87,  46,  87,  46,  87,  46,  87,  /*   64 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   64 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   64 */
    1:  88,  88,  89,  89,  89,  89,  90,  90,  /*   64 */
    1:  91,  91,  92,  92,  93,  93,  46,  46,  /*   64 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   65 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   65 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   65 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   65 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   65 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   65 */
    1:  86,  86,  16,  94,  16,  46,  16,  16,  /*   65 */
    1:  87,  87,  95,  95,  96,  11,  38,  11,  /*   65 */
    1:  11,  11,  16,  94,  16,  46,  16,  16,  /*   66 */
    1:  97,  97,  97,  97,  96,  11,  11,  11,  /*   66 */
    1:  86,  86,  16,  16,  46,  46,  16,  16,  /*   66 */
    1:  87,  87,  98,  98,  46,  11,  11,  11,  /*   66 */
    1:  86,  86,  16,  16,  16,  99,  16,  16,  /*   66 */
    1:  87,  87, 100, 100, 101,  11,  11,  11,  /*   66 */
    1:  46,  46,  16,  94,  16,  46,  16,  16,  /*   66 */
    1: 102, 102, 103, 103,  96,  11,  11,  46,  /*   66 */
    1:   2,   2,   2,   2,   2,   2,   2,   2,  /*   67 */
36430:   2,   2,   2,   2, 104, 104, 104, 104,  /*   67 */
    1:   8,   8,   8,   8,   8,   8,   3,   3,  /*   67 */
    1:   5,   6,   5,   5,   5,   6,   5,   5,  /*   67 */
    1:   3,   3,   3,   3,   3,   3,   3,   3,  /*   67 */
36430: 105, 106, 104, 104, 104, 104, 104,  46,  /*   67 */
    1:   3,   3,   3,   3,   3,   3,   3,   3,  /*   67 */
    1:   3,   5,   6,   3,   3,   3,   3,  12,  /*   67 */
    1:  12,   3,   3,   3,   7,   5,   6,  46,  /*   68 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   68 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   68 */
36430:  46,  46,  46,  46,  46,  46,  46,  46,  /*   68 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   68 */
    1:  46,  46, 104, 104, 104, 104, 104, 104,  /*   68 */
    1:  17,  46,  46,  46,  17,  17,  17,  17,  /*   68 */
    1:  17,  17,   7,   7,   7,   5,   6,  16,  /*   68 */
    1: 107, 107, 107, 107, 107, 107, 107, 107,  /*   69 */
    1: 107, 107,   7,   7,   7,   5,   6,  46,  /*   69 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   69 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   69 */
    1:   4,   4,   4,   4,   4,   4,   4,   4,  /*   69 */
    1:   4,   4,   4,   4,  46,  46,  46,  46,  /*   69 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   69 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   69 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   70 */
    1:  60,  60,  60,  60,  60,  79,  79,  79,  /*   70 */
    1:  79,  60,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  15,  15,  38,  15,  15,  15,  15,  38,  /*   71 */
    1:  15,  15,  16,  38,  38,  38,  16,  16,  /*   71 */
    1:  38,  38,  38,  16,  15,  38,  15,  15,  /*   71 */
    1:  38,  38,  38,  38,  38,  38,  15,  15,  /*   71 */
    1:  15,  15,  15,  15,  38,  15,  38,  15,  /*   71 */
    1:  38,  15,  38,  38,  38,  38,  16,  16,  /*   71 */
    1:  38,  38,  15,  38,  16,  40,  40,  40,  /*   71 */
    1:  40,  46,  46,  46,  46,  46,  46,  46,  /*   71 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   72 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   72 */
    1:  46,  46,  46,  19,  19,  19,  19,  19,  /*   72 */
    1:  19,  19,  19,  19,  19,  19,  19, 108,  /*   72 */
    1: 109, 109, 109, 109, 109, 109, 109, 109,  /*   72 */
    1: 109, 109, 109, 109, 110, 110, 110, 110,  /*   72 */
    1: 111, 111, 111, 111, 111, 111, 111, 111,  /*   72 */
    1: 111, 111, 111, 111, 112, 112, 112, 112,  /*   72 */
    1: 113, 113, 113,  46,  46,  46,  46,  46,  /*   73 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   73 */
    1:   7,   7,   7,   7,   7,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   74 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   74 */
    1:  15,  15,   7,  15,   7,  15,  15,  15,  /*   74 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   74 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   74 */
    1:  15,  15,  15,  46,  46,  46,  46,  46,  /*   74 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   74 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   74 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,  46,  46,  46,  46,  46,  46,  /*   76 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   76 */
    1:  15,  46,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:   7,   7,   7,   7,  15,  15,  15,  15,  /*   77 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:   7,   7,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:  15,   5,   6,  15,  15,  15,  15,  15,  /*   77 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  46,  46,  46,  46,  46,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   79 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   79 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   79 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   79 */
    1:  15,  15,  15,  15,  15,  46,  46,  46,  /*   79 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   79 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   79 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   79 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   80 */
    1:  15,  15,  15,  46,  46,  46,  46,  46,  /*   80 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   80 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   80 */
    1: 114, 114, 114, 114, 114, 114, 114, 114,  /*   80 */
    1: 114, 114, 114, 114, 114, 114, 114, 114,  /*   80 */
    1: 114, 114, 114, 114,  82,  82,  82,  82,  /*   80 */
    1:  82,  82,  82,  82,  82,  82,  82,  82,  /*   80 */
    1:  82,  82,  82,  82,  82,  82,  82,  82,  /*   81 */
    1: 115, 115, 115, 115, 115, 115, 115, 115,  /*   81 */
    1: 115, 115, 115, 115, 115, 115, 115, 115,  /*   81 */
    1: 115, 115, 115, 115,  15,  15,  15,  15,  /*   81 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   81 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   81 */
    1:  15,  15,  15,  15,  15,  15, 116, 116,  /*   81 */
    1: 116, 116, 116, 116, 116, 116, 116, 116,  /*   81 */
    1: 116, 116, 116, 116, 116, 116, 116, 116,  /*   82 */
    1: 116, 116, 116, 116, 116, 116, 116, 116,  /*   82 */
    1: 117, 117, 117, 117, 117, 117, 117, 117,  /*   82 */
    1: 117, 117, 117, 117, 117, 117, 117, 117,  /*   82 */
    1: 117, 117, 117, 117, 117, 117, 117, 117,  /*   82 */
    1: 117, 117, 118,  46,  46,  46,  46,  46,  /*   82 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   82 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   82 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  46,  46,  /*   84 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   85 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  46,  46,  46,  46,  /*   86 */
    1:  46,  46,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  46,  15,  15,  15,  15,  46,  15,  15,  /*   87 */
    1:  15,  15,  46,  46,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  46,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   88 */
    1:  15,  15,  15,  15,  46,  15,  46,  15,  /*   88 */
    1:  15,  15,  15,  46,  46,  46,  15,  46,  /*   88 */
    1:  15,  15,  15,  15,  15,  15,  15,  46,  /*   88 */
    1:  46,  15,  15,  15,  15,  15,  15,  15,  /*   88 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   88 */
    1:  46,  46,  46,  46,  46,  46, 119, 119,  /*   88 */
    1: 119, 119, 119, 119, 119, 119, 119, 119,  /*   88 */
    1: 114, 114, 114, 114, 114, 114, 114, 114,  /*   89 */
    1: 114, 114,  83,  83,  83,  83,  83,  83,  /*   89 */
    1:  83,  83,  83,  83,  15,  46,  46,  46,  /*   89 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   89 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   89 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   89 */
    1:  46,  15,  15,  15,  15,  15,  15,  15,  /*   89 */
    1:  15,  15,  15,  15,  15,  15,  15,  46,  /*   89 */
    1:   2,   3,   3,   3,  15,  59,   3, 120,  /*   90 */
    1:   5,   6,   5,   6,   5,   6,   5,   6,  /*   90 */
    1:   5,   6,  15,  15,   5,   6,   5,   6,  /*   90 */
    1:   5,   6,   5,   6,   8,   5,   6,   5,  /*   90 */
    1:  15, 121, 121, 121, 121, 121, 121, 121,  /*   90 */
    1: 121, 121,  60,  60,  60,  60,  60,  60,  /*   90 */
    1:   8,  59,  59,  59,  59,  59,  15,  15,  /*   90 */
    1:  46,  46,  46,  46,  46,  46,  46,  15,  /*   90 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  46,  46,  46,  /*   92 */
    1:  46,  60,  60,  59,  59,  59,  59,  46,  /*   92 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,   3,  59,  59,  59,  46,  /*   93 */
    1:  46,  46,  46,  46,  46,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  46,  46,  46,  /*   94 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   95 */
    1:  40,  40,  40,  40,  40,  40,  40,  46,  /*   95 */
    1:  15,  15,  85,  85,  85,  85,  15,  15,  /*   95 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   95 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   95 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   95 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   95 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   95 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  15,  46,  46,  46,  /*   96 */
    1:  85,  85,  85,  85,  85,  85,  85,  85,  /*   96 */
    1:  85,  85,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  46,  46,  46,  46,  /*   97 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   97 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   97 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   97 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   97 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   97 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   97 */
    1:  15,  15,  15,  15,  46,  46,  46,  15,  /*   97 */
    1: 114, 114, 114, 114, 114, 114, 114, 114,  /*   98 */
    1: 114, 114,  15,  15,  15,  15,  15,  15,  /*   98 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   98 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   98 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   98 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   98 */
    1:  15,  46,  46,  46,  46,  46,  46,  46,  /*   98 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   98 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  46,  46,  46,  46,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  46,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  46,  /*  100 */
    1:  46,  46,  46,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  46,  46,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  46,  /*  101 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  102 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  102 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  102 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  102 */
    1:  40,  40,  40,  40,  40,  40,  46,  46,  /*  102 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  102 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  102 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  102 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  103 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  103 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  103 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  103 */
    1:  40,  40,  40,  40,  46,  46,  46,  46,  /*  103 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  103 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  103 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  103 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  106 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  106 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  106 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  106 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  106 */
    1:  40,  40,  40,  40,  40,  40,  46,  46,  /*  106 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  106 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  106 */
    1:  16,  16,  16,  16,  16,  16,  16,  46,  /*  107 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  107 */
    1:  46,  46,  46,  16,  16,  16,  16,  16,  /*  107 */
    1:  46,  46,  46,  46,  46,  46,  60,  40,  /*  107 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  107 */
    1:  40,   7,  40,  40,  40,  40,  40,  40,  /*  107 */
    1:  40,  40,  40,  40,  40,  40,  40,  46,  /*  107 */
    1:  40,  40,  40,  40,  40,  46,  40,  46,  /*  107 */
    1:  40,  40,  46,  40,  40,  46,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  46,  46,  46,  46,  46,  46,  /*  109 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  109 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  110 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  110 */
    1:  46,  46,  46,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,   5,   6,  /*  111 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  112 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  46,  46,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  114 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  114 */
    1:  40,  40,  40,  40,  46,  46,  46,  46,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  115 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  115 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  115 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  115 */
    1:  60,  60,  60,  60,  46,  46,  46,  46,  /*  115 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  115 */
    1:   3,   8,   8,  12,  12,   5,   6,   5,  /*  115 */
    1:   6,   5,   6,   5,   6,   5,   6,   5,  /*  115 */
    1:   6,   5,   6,   5,   6,  46,  46,  46,  /*  116 */
    1:  46,   3,   3,   3,   3,  12,  12,  12,  /*  116 */
    1:   3,   3,   3,  46,   3,   3,   3,   3,  /*  116 */
    1:   8,   5,   6,   5,   6,   5,   6,   3,  /*  116 */
    1:   3,   3,   7,   8,   7,   7,   7,  46,  /*  116 */
    1:   3,   4,   3,   3,  46,  46,  46,  46,  /*  116 */
    1:  40,  40,  40,  46,  40,  46,  40,  40,  /*  116 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  116 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  46,  46, 104,  /*  117 */
    1:  46,   3,   3,   3,   4,   3,   3,   3,  /*  118 */
    1:   5,   6,   3,   7,   3,   8,   3,   3,  /*  118 */
    1:   9,   9,   9,   9,   9,   9,   9,   9,  /*  118 */
    1:   9,   9,   3,   3,   7,   7,   7,   3,  /*  118 */
    1:   3,  10,  10,  10,  10,  10,  10,  10,  /*  118 */
    1:  10,  10,  10,  10,  10,  10,  10,  10,  /*  118 */
    1:  10,  10,  10,  10,  10,  10,  10,  10,  /*  118 */
    1:  10,  10,  10,   5,   3,   6,  11,  12,  /*  118 */
    1:  11,  13,  13,  13,  13,  13,  13,  13,  /*  119 */
    1:  13,  13,  13,  13,  13,  13,  13,  13,  /*  119 */
    1:  13,  13,  13,  13,  13,  13,  13,  13,  /*  119 */
    1:  13,  13,  13,   5,   7,   6,   7,  46,  /*  119 */
    1:  46,   3,   5,   6,   3,   3,  40,  40,  /*  119 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  119 */
    1:  59,  40,  40,  40,  40,  40,  40,  40,  /*  119 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  119 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  59,  59,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  46,  /*  120 */
    1:  46,  46,  40,  40,  40,  40,  40,  40,  /*  121 */
    1:  46,  46,  40,  40,  40,  40,  40,  40,  /*  121 */
    1:  46,  46,  40,  40,  40,  40,  40,  40,  /*  121 */
    1:  46,  46,  40,  40,  40,  46,  46,  46,  /*  121 */
    1:   4,   4,   7,  11,  15,   4,   4,  46,  /*  121 */
    1:   7,   7,   7,   7,   7,  15,  15,  46,  /*  121 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  121 */
    1:  46,  46,  46,  46,  46,  15,  46,  46   /*  121 */
    1: };
    1: 
    1: /* The A table has 124 entries for a total of 496 bytes. */
    1: 
    1: const uint32 js_A[] = {
    1: 0x0001000F,  /*    0   Cc, ignorable */
    1: 0x0004000F,  /*    1   Cc, whitespace */
    1: 0x0004000C,  /*    2   Zs, whitespace */
    1: 0x00000018,  /*    3   Po */
    1: 0x0006001A,  /*    4   Sc, currency */
    1: 0x00000015,  /*    5   Ps */
    1: 0x00000016,  /*    6   Pe */
    1: 0x00000019,  /*    7   Sm */
    1: 0x00000014,  /*    8   Pd */
    1: 0x00036089,  /*    9   Nd, identifier part, decimal 16 */
    1: 0x0827FF81,  /*   10   Lu, hasLower (add 32), identifier start, supradecimal 31 */
    1: 0x0000001B,  /*   11   Sk */
    1: 0x00050017,  /*   12   Pc, underscore */
    1: 0x0817FF82,  /*   13   Ll, hasUpper (subtract 32), identifier start, supradecimal 31 */
    1: 0x0000000C,  /*   14   Zs */
    1: 0x0000001C,  /*   15   So */
    1: 0x00070182,  /*   16   Ll, identifier start */
    1: 0x0000600B,  /*   17   No, decimal 16 */
    1: 0x0000500B,  /*   18   No, decimal 8 */
    1: 0x0000800B,  /*   19   No, strange */
    1: 0x08270181,  /*   20   Lu, hasLower (add 32), identifier start */
    1: 0x08170182,  /*   21   Ll, hasUpper (subtract 32), identifier start */
    1: 0xE1D70182,  /*   22   Ll, hasUpper (subtract -121), identifier start */
    1: 0x00670181,  /*   23   Lu, hasLower (add 1), identifier start */
    1: 0x00570182,  /*   24   Ll, hasUpper (subtract 1), identifier start */
    1: 0xCE670181,  /*   25   Lu, hasLower (add -199), identifier start */
    1: 0x3A170182,  /*   26   Ll, hasUpper (subtract 232), identifier start */
    1: 0xE1E70181,  /*   27   Lu, hasLower (add -121), identifier start */
    1: 0x4B170182,  /*   28   Ll, hasUpper (subtract 300), identifier start */
    1: 0x34A70181,  /*   29   Lu, hasLower (add 210), identifier start */
    1: 0x33A70181,  /*   30   Lu, hasLower (add 206), identifier start */
    1: 0x33670181,  /*   31   Lu, hasLower (add 205), identifier start */
    1: 0x32A70181,  /*   32   Lu, hasLower (add 202), identifier start */
    1: 0x32E70181,  /*   33   Lu, hasLower (add 203), identifier start */
    1: 0x33E70181,  /*   34   Lu, hasLower (add 207), identifier start */
    1: 0x34E70181,  /*   35   Lu, hasLower (add 211), identifier start */
    1: 0x34670181,  /*   36   Lu, hasLower (add 209), identifier start */
    1: 0x35670181,  /*   37   Lu, hasLower (add 213), identifier start */
    1: 0x00070181,  /*   38   Lu, identifier start */
    1: 0x36A70181,  /*   39   Lu, hasLower (add 218), identifier start */
    1: 0x00070185,  /*   40   Lo, identifier start */
    1: 0x36670181,  /*   41   Lu, hasLower (add 217), identifier start */
    1: 0x36E70181,  /*   42   Lu, hasLower (add 219), identifier start */
    1: 0x00AF0181,  /*   43   Lu, hasLower (add 2), hasTitle, identifier start */
    1: 0x007F0183,  /*   44   Lt, hasUpper (subtract 1), hasLower (add 1), hasTitle, identifier start */
    1: 0x009F0182,  /*   45   Ll, hasUpper (subtract 2), hasTitle, identifier start */
    1: 0x00000000,  /*   46   unassigned */
    1: 0x34970182,  /*   47   Ll, hasUpper (subtract 210), identifier start */
    1: 0x33970182,  /*   48   Ll, hasUpper (subtract 206), identifier start */
    1: 0x33570182,  /*   49   Ll, hasUpper (subtract 205), identifier start */
    1: 0x32970182,  /*   50   Ll, hasUpper (subtract 202), identifier start */
    1: 0x32D70182,  /*   51   Ll, hasUpper (subtract 203), identifier start */
    1: 0x33D70182,  /*   52   Ll, hasUpper (subtract 207), identifier start */
    1: 0x34570182,  /*   53   Ll, hasUpper (subtract 209), identifier start */
    1: 0x34D70182,  /*   54   Ll, hasUpper (subtract 211), identifier start */
    1: 0x35570182,  /*   55   Ll, hasUpper (subtract 213), identifier start */
    1: 0x36970182,  /*   56   Ll, hasUpper (subtract 218), identifier start */
    1: 0x36570182,  /*   57   Ll, hasUpper (subtract 217), identifier start */
    1: 0x36D70182,  /*   58   Ll, hasUpper (subtract 219), identifier start */
    1: 0x00070084,  /*   59   Lm, identifier start */
    1: 0x00030086,  /*   60   Mn, identifier part */
    1: 0x09A70181,  /*   61   Lu, hasLower (add 38), identifier start */
    1: 0x09670181,  /*   62   Lu, hasLower (add 37), identifier start */
    1: 0x10270181,  /*   63   Lu, hasLower (add 64), identifier start */
    1: 0x0FE70181,  /*   64   Lu, hasLower (add 63), identifier start */
    1: 0x09970182,  /*   65   Ll, hasUpper (subtract 38), identifier start */
    1: 0x09570182,  /*   66   Ll, hasUpper (subtract 37), identifier start */
    1: 0x10170182,  /*   67   Ll, hasUpper (subtract 64), identifier start */
    1: 0x0FD70182,  /*   68   Ll, hasUpper (subtract 63), identifier start */
    1: 0x0F970182,  /*   69   Ll, hasUpper (subtract 62), identifier start */
    1: 0x0E570182,  /*   70   Ll, hasUpper (subtract 57), identifier start */
    1: 0x0BD70182,  /*   71   Ll, hasUpper (subtract 47), identifier start */
    1: 0x0D970182,  /*   72   Ll, hasUpper (subtract 54), identifier start */
    1: 0x15970182,  /*   73   Ll, hasUpper (subtract 86), identifier start */
    1: 0x14170182,  /*   74   Ll, hasUpper (subtract 80), identifier start */
    1: 0x14270181,  /*   75   Lu, hasLower (add 80), identifier start */
    1: 0x0C270181,  /*   76   Lu, hasLower (add 48), identifier start */
    1: 0x0C170182,  /*   77   Ll, hasUpper (subtract 48), identifier start */
    1: 0x00034089,  /*   78   Nd, identifier part, decimal 0 */
    1: 0x00000087,  /*   79   Me */
    1: 0x00030088,  /*   80   Mc, identifier part */
    1: 0x00037489,  /*   81   Nd, identifier part, decimal 26 */
    1: 0x00005A0B,  /*   82   No, decimal 13 */
    1: 0x00006E0B,  /*   83   No, decimal 23 */
    1: 0x0000740B,  /*   84   No, decimal 26 */
    1: 0x0000000B,  /*   85   No */
    1: 0xFE170182,  /*   86   Ll, hasUpper (subtract -8), identifier start */
    1: 0xFE270181,  /*   87   Lu, hasLower (add -8), identifier start */
    1: 0xED970182,  /*   88   Ll, hasUpper (subtract -74), identifier start */
    1: 0xEA970182,  /*   89   Ll, hasUpper (subtract -86), identifier start */
    1: 0xE7170182,  /*   90   Ll, hasUpper (subtract -100), identifier start */
    1: 0xE0170182,  /*   91   Ll, hasUpper (subtract -128), identifier start */
    1: 0xE4170182,  /*   92   Ll, hasUpper (subtract -112), identifier start */
    1: 0xE0970182,  /*   93   Ll, hasUpper (subtract -126), identifier start */
    1: 0xFDD70182,  /*   94   Ll, hasUpper (subtract -9), identifier start */
    1: 0xEDA70181,  /*   95   Lu, hasLower (add -74), identifier start */
    1: 0xFDE70181,  /*   96   Lu, hasLower (add -9), identifier start */
    1: 0xEAA70181,  /*   97   Lu, hasLower (add -86), identifier start */
    1: 0xE7270181,  /*   98   Lu, hasLower (add -100), identifier start */
    1: 0xFE570182,  /*   99   Ll, hasUpper (subtract -7), identifier start */
    1: 0xE4270181,  /*  100   Lu, hasLower (add -112), identifier start */
    1: 0xFE670181,  /*  101   Lu, hasLower (add -7), identifier start */
    1: 0xE0270181,  /*  102   Lu, hasLower (add -128), identifier start */
    1: 0xE0A70181,  /*  103   Lu, hasLower (add -126), identifier start */
    1: 0x00010010,  /*  104   Cf, ignorable */
    1: 0x0004000D,  /*  105   Zl, whitespace */
    1: 0x0004000E,  /*  106   Zp, whitespace */
    1: 0x0000400B,  /*  107   No, decimal 0 */
    1: 0x0000440B,  /*  108   No, decimal 2 */
    1: 0x0427438A,  /*  109   Nl, hasLower (add 16), identifier start, decimal 1 */
    1: 0x0427818A,  /*  110   Nl, hasLower (add 16), identifier start, strange */
    1: 0x0417638A,  /*  111   Nl, hasUpper (subtract 16), identifier start, decimal 17 */
    1: 0x0417818A,  /*  112   Nl, hasUpper (subtract 16), identifier start, strange */
    1: 0x0007818A,  /*  113   Nl, identifier start, strange */
    1: 0x0000420B,  /*  114   No, decimal 1 */
    1: 0x0000720B,  /*  115   No, decimal 25 */
    1: 0x06A0001C,  /*  116   So, hasLower (add 26) */
    1: 0x0690001C,  /*  117   So, hasUpper (subtract 26) */
    1: 0x00006C0B,  /*  118   No, decimal 22 */
    1: 0x0000560B,  /*  119   No, decimal 11 */
    1: 0x0007738A,  /*  120   Nl, identifier start, decimal 25 */
    1: 0x0007418A,  /*  121   Nl, identifier start, decimal 0 */
    1: 0x00000013,  /*  122   Cs */
    1: 0x00000012   /*  123   Co */
    1: };
    1: 
    1: const jschar js_uriReservedPlusPound_ucstr[] =
    1:     {';', '/', '?', ':', '@', '&', '=', '+', '$', ',', '#', 0};
    1: const jschar js_uriUnescaped_ucstr[] =
    1:     {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    1:      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
    1:      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    1:      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    1:      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    1:      '-', '_', '.', '!', '~', '*', '\'', '(', ')', 0};
    1: 
30451: /*
30451:  * This table allows efficient testing for the regular expression \w which is
30451:  * defined by ECMA-262 15.10.2.6 to be [0-9A-Z_a-z].
30451:  */
30451: const bool js_alnum[] = {
30451: /*       0      1      2      3      4      5      5      7      8      9      */
30451: /*  0 */ false, false, false, false, false, false, false, false, false, false,
30451: /*  1 */ false, false, false, false, false, false, false, false, false, false,
30451: /*  2 */ false, false, false, false, false, false, false, false, false, false,
30451: /*  3 */ false, false, false, false, false, false, false, false, false, false,
30451: /*  4 */ false, false, false, false, false, false, false, false, true,  true,
30451: /*  5 */ true,  true,  true,  true,  true,  true,  true,  true,  false, false,
30451: /*  6 */ false, false, false, false, false, true,  true,  true,  true,  true,
30451: /*  7 */ true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
30451: /*  8 */ true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
30451: /*  9 */ true,  false, false, false, false, true,  false, true,  true,  true,
30451: /* 10 */ true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
30451: /* 11 */ true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
30451: /* 12 */ true,  true,  true,  false, false, false, false, false
30451: };
30451: 
    1: #define URI_CHUNK 64U
    1: 
31890: static inline bool
48470: TransferBufferToString(JSContext *cx, JSCharBuffer &cb, Value *rval)
    1: {
31890:     JSString *str = js_NewStringFromCharBuffer(cx, cb);
 4718:     if (!str)
31890:         return false;
48470:     rval->setString(str);
31890:     return true;;
    1: }
    1: 
    1: /*
    1:  * ECMA 3, 15.1.3 URI Handling Function Properties
    1:  *
    1:  * The following are implementations of the algorithms
    1:  * given in the ECMA specification for the hidden functions
    1:  * 'Encode' and 'Decode'.
    1:  */
    1: static JSBool
    1: Encode(JSContext *cx, JSString *str, const jschar *unescapedSet,
48470:        const jschar *unescapedSet2, Value *rval)
    1: {
    1:     size_t length, j, k, L;
31890:     JSCharBuffer cb(cx);
29366:     const jschar *chars;
29366:     jschar c, c2;
    1:     uint32 v;
33589:     uint8 utf8buf[4];
    1:     jschar hexBuf[4];
    1:     static const char HexDigits[] = "0123456789ABCDEF"; /* NB: uppercase */
 4718: 
29366:     str->getCharsAndLength(chars, length);
    1:     if (length == 0) {
48470:         rval->setString(cx->runtime->emptyString);
    1:         return JS_TRUE;
    1:     }
    1: 
 4718:     /* From this point the control must goto bad on failures. */
    1:     hexBuf[0] = '%';
    1:     hexBuf[3] = 0;
    1:     for (k = 0; k < length; k++) {
    1:         c = chars[k];
    1:         if (js_strchr(unescapedSet, c) ||
    1:             (unescapedSet2 && js_strchr(unescapedSet2, c))) {
31890:             if (!cb.append(c))
31890:                 return JS_FALSE;
    1:         } else {
    1:             if ((c >= 0xDC00) && (c <= 0xDFFF)) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_URI, NULL);
31890:                 return JS_FALSE;
    1:             }
    1:             if (c < 0xD800 || c > 0xDBFF) {
    1:                 v = c;
    1:             } else {
    1:                 k++;
    1:                 if (k == length) {
    1:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_BAD_URI, NULL);
31890:                     return JS_FALSE;
    1:                 }
    1:                 c2 = chars[k];
    1:                 if ((c2 < 0xDC00) || (c2 > 0xDFFF)) {
    1:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_BAD_URI, NULL);
31890:                     return JS_FALSE;
    1:                 }
    1:                 v = ((c - 0xD800) << 10) + (c2 - 0xDC00) + 0x10000;
    1:             }
    1:             L = js_OneUcs4ToUtf8Char(utf8buf, v);
    1:             for (j = 0; j < L; j++) {
    1:                 hexBuf[1] = HexDigits[utf8buf[j] >> 4];
    1:                 hexBuf[2] = HexDigits[utf8buf[j] & 0xf];
31890:                 if (!cb.append(hexBuf, 3))
    1:                     return JS_FALSE;
    1:             }
31890:         }
31890:     }
31890: 
31890:     return TransferBufferToString(cx, cb, rval);
31890: }
    1: 
    1: static JSBool
48470: Decode(JSContext *cx, JSString *str, const jschar *reservedSet, Value *rval)
    1: {
    1:     size_t length, start, k;
31890:     JSCharBuffer cb(cx);
29366:     const jschar *chars;
29366:     jschar c, H;
    1:     uint32 v;
    1:     jsuint B;
33589:     uint8 octets[4];
    1:     intN j, n;
    1: 
29366:     str->getCharsAndLength(chars, length);
    1:     if (length == 0) {
48470:         rval->setString(cx->runtime->emptyString);
    1:         return JS_TRUE;
    1:     }
    1: 
 4718:     /* From this point the control must goto bad on failures. */
    1:     for (k = 0; k < length; k++) {
    1:         c = chars[k];
    1:         if (c == '%') {
    1:             start = k;
    1:             if ((k + 2) >= length)
 4718:                 goto report_bad_uri;
    1:             if (!JS7_ISHEX(chars[k+1]) || !JS7_ISHEX(chars[k+2]))
 4718:                 goto report_bad_uri;
    1:             B = JS7_UNHEX(chars[k+1]) * 16 + JS7_UNHEX(chars[k+2]);
    1:             k += 2;
    1:             if (!(B & 0x80)) {
    1:                 c = (jschar)B;
    1:             } else {
    1:                 n = 1;
    1:                 while (B & (0x80 >> n))
    1:                     n++;
33589:                 if (n == 1 || n > 4)
 4718:                     goto report_bad_uri;
    1:                 octets[0] = (uint8)B;
    1:                 if (k + 3 * (n - 1) >= length)
 4718:                     goto report_bad_uri;
    1:                 for (j = 1; j < n; j++) {
    1:                     k++;
    1:                     if (chars[k] != '%')
 4718:                         goto report_bad_uri;
    1:                     if (!JS7_ISHEX(chars[k+1]) || !JS7_ISHEX(chars[k+2]))
 4718:                         goto report_bad_uri;
    1:                     B = JS7_UNHEX(chars[k+1]) * 16 + JS7_UNHEX(chars[k+2]);
    1:                     if ((B & 0xC0) != 0x80)
 4718:                         goto report_bad_uri;
    1:                     k += 2;
    1:                     octets[j] = (char)B;
    1:                 }
    1:                 v = Utf8ToOneUcs4Char(octets, n);
    1:                 if (v >= 0x10000) {
    1:                     v -= 0x10000;
    1:                     if (v > 0xFFFFF)
 4718:                         goto report_bad_uri;
    1:                     c = (jschar)((v & 0x3FF) + 0xDC00);
    1:                     H = (jschar)((v >> 10) + 0xD800);
31890:                     if (!cb.append(H))
31890:                         return JS_FALSE;
    1:                 } else {
    1:                     c = (jschar)v;
    1:                 }
    1:             }
    1:             if (js_strchr(reservedSet, c)) {
31890:                 if (!cb.append(chars + start, k - start + 1))
31890:                     return JS_FALSE;
 4718:             } else {
31890:                 if (!cb.append(c))
31890:                     return JS_FALSE;
 4718:             }
 4718:         } else {
31890:             if (!cb.append(c))
    1:                 return JS_FALSE;
 4718:         }
 4718:     }
 4718: 
31890:     return TransferBufferToString(cx, cb, rval);
    1: 
 4718:   report_bad_uri:
 4718:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_URI);
 4718:     /* FALL THROUGH */
 4718: 
    1:     return JS_FALSE;
    1: }
    1: 
    1: static JSBool
48470: str_decodeURI(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1: 
16519:     str = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     return Decode(cx, str, js_uriReservedPlusPound_ucstr, vp);
    1: }
    1: 
    1: static JSBool
48470: str_decodeURI_Component(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1: 
16519:     str = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     return Decode(cx, str, js_empty_ucstr, vp);
    1: }
    1: 
    1: static JSBool
48470: str_encodeURI(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1: 
16519:     str = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!str)
    1:         return JS_FALSE;
    1:     return Encode(cx, str, js_uriReservedPlusPound_ucstr, js_uriUnescaped_ucstr,
 4127:                   vp);
    1: }
    1: 
    1: static JSBool
48470: str_encodeURI_Component(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1: 
16519:     str = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     return Encode(cx, str, js_uriUnescaped_ucstr, NULL, vp);
    1: }
    1: 
    1: /*
    1:  * Convert one UCS-4 char and write it into a UTF-8 buffer, which must be at
33589:  * least 4 bytes long.  Return the number of UTF-8 bytes of data written.
    1:  */
    1: int
    1: js_OneUcs4ToUtf8Char(uint8 *utf8Buffer, uint32 ucs4Char)
    1: {
    1:     int utf8Length = 1;
    1: 
33589:     JS_ASSERT(ucs4Char <= 0x10FFFF);
    1:     if (ucs4Char < 0x80) {
    1:         *utf8Buffer = (uint8)ucs4Char;
    1:     } else {
    1:         int i;
    1:         uint32 a = ucs4Char >> 11;
    1:         utf8Length = 2;
    1:         while (a) {
    1:             a >>= 5;
    1:             utf8Length++;
    1:         }
    1:         i = utf8Length;
    1:         while (--i) {
    1:             utf8Buffer[i] = (uint8)((ucs4Char & 0x3F) | 0x80);
    1:             ucs4Char >>= 6;
    1:         }
    1:         *utf8Buffer = (uint8)(0x100 - (1 << (8-utf8Length)) + ucs4Char);
    1:     }
    1:     return utf8Length;
    1: }
    1: 
    1: /*
    1:  * Convert a utf8 character sequence into a UCS-4 character and return that
    1:  * character.  It is assumed that the caller already checked that the sequence
    1:  * is valid.
    1:  */
    1: static uint32
    1: Utf8ToOneUcs4Char(const uint8 *utf8Buffer, int utf8Length)
    1: {
    1:     uint32 ucs4Char;
    1:     uint32 minucs4Char;
    1:     /* from Unicode 3.1, non-shortest form is illegal */
    1:     static const uint32 minucs4Table[] = {
33589:         0x00000080, 0x00000800, 0x00010000
    1:     };
    1: 
33589:     JS_ASSERT(utf8Length >= 1 && utf8Length <= 4);
    1:     if (utf8Length == 1) {
    1:         ucs4Char = *utf8Buffer;
    1:         JS_ASSERT(!(ucs4Char & 0x80));
    1:     } else {
    1:         JS_ASSERT((*utf8Buffer & (0x100 - (1 << (7-utf8Length)))) ==
    1:                   (0x100 - (1 << (8-utf8Length))));
    1:         ucs4Char = *utf8Buffer++ & ((1<<(7-utf8Length))-1);
    1:         minucs4Char = minucs4Table[utf8Length-2];
    1:         while (--utf8Length) {
    1:             JS_ASSERT((*utf8Buffer & 0xC0) == 0x80);
    1:             ucs4Char = ucs4Char<<6 | (*utf8Buffer++ & 0x3F);
    1:         }
33589:         if (JS_UNLIKELY(ucs4Char < minucs4Char)) {
33589:             ucs4Char = OVERLONG_UTF8;
33589:         } else if (ucs4Char == 0xFFFE || ucs4Char == 0xFFFF) {
    1:             ucs4Char = 0xFFFD;
    1:         }
    1:     }
    1:     return ucs4Char;
    1: }
    1: 
47439: #if defined DEBUG || defined JS_DUMP_CONSERVATIVE_GC_ROOTS
 4535: 
 4569: JS_FRIEND_API(size_t)
    1: js_PutEscapedStringImpl(char *buffer, size_t bufferSize, FILE *fp,
    1:                         JSString *str, uint32 quote)
    1: {
29366:     const jschar *chars, *charsEnd;
    1:     size_t n;
 6152:     const char *escape;
    1:     char c;
    1:     uintN u, hex, shift;
    1:     enum {
    1:         STOP, FIRST_QUOTE, LAST_QUOTE, CHARS, ESCAPE_START, ESCAPE_MORE
    1:     } state;
    1: 
    1:     JS_ASSERT(quote == 0 || quote == '\'' || quote == '"');
    1:     JS_ASSERT_IF(buffer, bufferSize != 0);
    1:     JS_ASSERT_IF(!buffer, bufferSize == 0);
    1:     JS_ASSERT_IF(fp, !buffer);
    1: 
29366:     str->getCharsAndEnd(chars, charsEnd);
    1:     n = 0;
    1:     --bufferSize;
    1:     state = FIRST_QUOTE;
    1:     shift = 0;
    1:     hex = 0;
    1:     u = 0;
    1:     c = 0;  /* to quell GCC warnings */
    1: 
    1:     for (;;) {
    1:         switch (state) {
    1:           case STOP:
    1:             goto stop;
    1:           case FIRST_QUOTE:
    1:             state = CHARS;
    1:             goto do_quote;
    1:           case LAST_QUOTE:
    1:             state = STOP;
    1:           do_quote:
    1:             if (quote == 0)
    1:                 continue;
    1:             c = (char)quote;
    1:             break;
    1:           case CHARS:
    1:             if (chars == charsEnd) {
    1:                 state = LAST_QUOTE;
    1:                 continue;
    1:             }
    1:             u = *chars++;
    1:             if (u < ' ') {
  814:                 if (u != 0) {
    1:                     escape = strchr(js_EscapeMap, (int)u);
    1:                     if (escape) {
    1:                         u = escape[1];
    1:                         goto do_escape;
    1:                     }
  814:                 }
    1:                 goto do_hex_escape;
    1:             }
    1:             if (u < 127) {
    1:                 if (u == quote || u == '\\')
    1:                     goto do_escape;
    1:                 c = (char)u;
    1:             } else if (u < 0x100) {
    1:                 goto do_hex_escape;
    1:             } else {
    1:                 shift = 16;
    1:                 hex = u;
    1:                 u = 'u';
    1:                 goto do_escape;
    1:             }
    1:             break;
    1:           do_hex_escape:
    1:             shift = 8;
    1:             hex = u;
    1:             u = 'x';
    1:           do_escape:
    1:             c = '\\';
    1:             state = ESCAPE_START;
    1:             break;
    1:           case ESCAPE_START:
    1:             JS_ASSERT(' ' <= u && u < 127);
    1:             c = (char)u;
    1:             state = ESCAPE_MORE;
    1:             break;
    1:           case ESCAPE_MORE:
    1:             if (shift == 0) {
    1:                 state = CHARS;
    1:                 continue;
    1:             }
    1:             shift -= 4;
    1:             u = 0xF & (hex >> shift);
    1:             c = (char)(u + (u < 10 ? '0' : 'A' - 10));
    1:             break;
    1:         }
    1:         if (buffer) {
    1:             if (n == bufferSize)
    1:                 break;
    1:             buffer[n] = c;
    1:         } else if (fp) {
    1:             fputc(c, fp);
    1:         }
    1:         n++;
    1:     }
    1:   stop:
    1:     if (buffer)
    1:         buffer[n] = '\0';
    1:     return n;
    1: }
    1: 
    1: #endif
