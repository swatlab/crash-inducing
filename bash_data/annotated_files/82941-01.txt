  966: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
  966: /* vim:expandtab:shiftwidth=2:tabstop=2:
  966:  */
  966: /* ***** BEGIN LICENSE BLOCK *****
  966:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  966:  *
  966:  * The contents of this file are subject to the Mozilla Public License Version
  966:  * 1.1 (the "License"); you may not use this file except in compliance with
  966:  * the License. You may obtain a copy of the License at
  966:  * http://www.mozilla.org/MPL/
  966:  *
  966:  * Software distributed under the License is distributed on an "AS IS" basis,
  966:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  966:  * for the specific language governing rights and limitations under the
  966:  * License.
  966:  *
  966:  * The Original Code is mozilla.org code.
  966:  *
  966:  * The Initial Developer of the Original Code is
  966:  * Mozilla Foundation.
  966:  * Portions created by the Initial Developer are Copyright (C) 2007
  966:  * the Initial Developer. All Rights Reserved.
  966:  *
  966:  * Contributor(s):
  966:  *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
  966:  *
  966:  * Alternatively, the contents of this file may be used under the terms of
  966:  * either the GNU General Public License Version 2 or later (the "GPL"), or
  966:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  966:  * in which case the provisions of the GPL or the LGPL are applicable instead
  966:  * of those above. If you wish to allow use of your version of this file only
  966:  * under the terms of either the GPL or the LGPL, and not to allow others to
  966:  * use your version of this file under the terms of the MPL, indicate your
  966:  * decision by deleting the provisions above and replace them with the notice
  966:  * and other provisions required by the GPL or the LGPL. If you do not delete
  966:  * the provisions above, a recipient may use your version of this file under
  966:  * the terms of any one of the MPL, the GPL or the LGPL.
  966:  *
  966:  * ***** END LICENSE BLOCK ***** */
  966: 
  966: #include "CAccessibleText.h"
  966: 
  966: #include "Accessible2.h"
  966: #include "AccessibleText_i.c"
  966: 
61202: #include "nsHyperTextAccessible.h"
  966: 
  966: // IUnknown
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::QueryInterface(REFIID iid, void** ppv)
  966: {
  966:   *ppv = NULL;
  966: 
  966:   if (IID_IAccessibleText == iid) {
46339:     nsCOMPtr<nsIAccessibleText> textAcc(do_QueryObject(this));
 2217:     if (!textAcc) {
 2217:       return E_NOINTERFACE;
 2217:     }
 3233:     *ppv = static_cast<IAccessibleText*>(this);
 3233:     (reinterpret_cast<IUnknown*>(*ppv))->AddRef();
  966:     return S_OK;
  966:   }
  966: 
  966:   return E_NOINTERFACE;
  966: }
  966: 
  966: // IAccessibleText
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::addSelection(long aStartOffset, long aEndOffset)
  966: {
11593: __try {
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966:   nsresult rv = textAcc->AddSelection(aStartOffset, aEndOffset);
13730:   return GetHRESULT(rv);
13730: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_attributes(long aOffset, long *aStartOffset,
  966:                                 long *aEndOffset, BSTR *aTextAttributes)
  966: {
11593: __try {
14603:   if (!aStartOffset || !aEndOffset || !aTextAttributes)
14603:     return E_INVALIDARG;
14603: 
13730:   *aStartOffset = 0;
13730:   *aEndOffset = 0;
13128:   *aTextAttributes = NULL;
13128: 
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966: 
  966:   PRInt32 startOffset = 0, endOffset = 0;
16001:   nsCOMPtr<nsIPersistentProperties> attributes;
80486:   nsresult rv = textAcc->GetTextAttributes(true, aOffset,
16001:                                            &startOffset, &endOffset,
16001:                                            getter_AddRefs(attributes));
16001:   if (NS_FAILED(rv))
16001:     return GetHRESULT(rv);
  966:   
16001:   HRESULT hr = nsAccessibleWrap::ConvertToIA2Attributes(attributes,
16001:                                                         aTextAttributes);
16001:   if (FAILED(hr))
16001:     return hr;
  966: 
  966:   *aStartOffset = startOffset;
  966:   *aEndOffset = endOffset;
16001: 
16001:   return S_OK;
13730: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
16001:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_caretOffset(long *aOffset)
  966: {
11593: __try {
13730:   *aOffset = -1;
13730: 
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966: 
  966:   PRInt32 offset = 0;
  966:   nsresult rv = textAcc->GetCaretOffset(&offset);
13730:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
13730: 
  966:   *aOffset = offset;
22834:   return offset != -1 ? S_OK : S_FALSE;
13730: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_characterExtents(long aOffset,
  966:                                       enum IA2CoordinateType aCoordType,
  966:                                       long *aX, long *aY,
  966:                                       long *aWidth, long *aHeight)
  966: {
11593: __try {
13730:   *aX = 0;
13730:   *aY = 0;
13730:   *aWidth = 0;
13730:   *aHeight = 0;
13730: 
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966: 
  966:   PRUint32 geckoCoordType = (aCoordType == IA2_COORDTYPE_SCREEN_RELATIVE) ?
  966:     nsIAccessibleCoordinateType::COORDTYPE_SCREEN_RELATIVE :
  966:     nsIAccessibleCoordinateType::COORDTYPE_PARENT_RELATIVE;
  966: 
  966:   PRInt32 x = 0, y =0, width = 0, height = 0;
  966:   nsresult rv = textAcc->GetCharacterExtents (aOffset, &x, &y, &width, &height,
  966:                                               geckoCoordType);
13730:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
13730: 
  966:   *aX = x;
  966:   *aY = y;
  966:   *aWidth = width;
  966:   *aHeight = height;
13730:   return S_OK;
  966: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_nSelections(long *aNSelections)
  966: {
11593: __try {
13730:   *aNSelections = 0;
13730: 
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
82941:   if (textAcc->IsDefunct())
82941:     return E_FAIL;
  966: 
  966:   PRInt32 selCount = 0;
  966:   nsresult rv = textAcc->GetSelectionCount(&selCount);
13730:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
13730: 
  966:   *aNSelections = selCount;
13730:   return S_OK;
  966: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_offsetAtPoint(long aX, long aY,
  966:                                    enum IA2CoordinateType aCoordType,
  966:                                    long *aOffset)
  966: {
11593: __try {
13730:   *aOffset = 0;
13730: 
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966: 
  966:   PRUint32 geckoCoordType = (aCoordType == IA2_COORDTYPE_SCREEN_RELATIVE) ?
  966:     nsIAccessibleCoordinateType::COORDTYPE_SCREEN_RELATIVE :
  966:     nsIAccessibleCoordinateType::COORDTYPE_PARENT_RELATIVE;
  966: 
  966:   PRInt32 offset = 0;
  966:   nsresult rv = textAcc->GetOffsetAtPoint(aX, aY, geckoCoordType, &offset);
13730:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
13730: 
  966:   *aOffset = offset;
13730:   return S_OK;
  966: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_selection(long aSelectionIndex, long *aStartOffset,
  966:                                long *aEndOffset)
  966: {
11593: __try {
13730:   *aStartOffset = 0;
13730:   *aEndOffset = 0;
13730: 
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966: 
  966:   PRInt32 startOffset = 0, endOffset = 0;
  966:   nsresult rv = textAcc->GetSelectionBounds(aSelectionIndex,
  966:                                             &startOffset, &endOffset);
13730:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
13730: 
  966:   *aStartOffset = startOffset;
  966:   *aEndOffset = endOffset;
13730:   return S_OK;
  966: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_text(long aStartOffset, long aEndOffset, BSTR *aText)
  966: {
11593: __try {
13128:   *aText = NULL;
13128: 
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966: 
  966:   nsAutoString text;
  966:   nsresult rv = textAcc->GetText(aStartOffset, aEndOffset, text);
  966:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
  966: 
13128:   if (text.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aText = ::SysAllocStringLen(text.get(), text.Length());
13730:   return *aText ? S_OK : E_OUTOFMEMORY;
13128: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13730:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_textBeforeOffset(long aOffset,
  966:                                       enum IA2TextBoundaryType aBoundaryType,
  966:                                       long *aStartOffset, long *aEndOffset,
  966:                                       BSTR *aText)
  966: {
11593: __try {
13730:   *aStartOffset = 0;
13730:   *aEndOffset = 0;
13128:   *aText = NULL;
13128: 
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
61202:   if (textAcc->IsDefunct())
61202:     return E_FAIL;
  966: 
  966:   nsresult rv = NS_OK;
  966:   nsAutoString text;
  966:   PRInt32 startOffset = 0, endOffset = 0;
  966: 
  966:   if (aBoundaryType == IA2_TEXT_BOUNDARY_ALL) {
  966:     startOffset = 0;
61202:     endOffset = textAcc->CharacterCount();
  966:     rv = textAcc->GetText(startOffset, endOffset, text);
  966:   } else {
  966:     nsAccessibleTextBoundary boundaryType = GetGeckoTextBoundary(aBoundaryType);
10945:     if (boundaryType == -1)
10945:       return S_FALSE;
  966:     rv = textAcc->GetTextBeforeOffset(aOffset, boundaryType,
  966:                                       &startOffset, &endOffset, text);
  966:   }
  966: 
  966:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
  966: 
  966:   *aStartOffset = startOffset;
  966:   *aEndOffset = endOffset;
  966: 
13128:   if (text.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aText = ::SysAllocStringLen(text.get(), text.Length());
13730:   return *aText ? S_OK : E_OUTOFMEMORY;
13128: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13730:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_textAfterOffset(long aOffset,
  966:                                      enum IA2TextBoundaryType aBoundaryType,
  966:                                      long *aStartOffset, long *aEndOffset,
  966:                                      BSTR *aText)
  966: {
11593: __try {
13730:   *aStartOffset = 0;
13730:   *aEndOffset = 0;
13128:   *aText = NULL;
13128: 
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
61202:   if (textAcc->IsDefunct())
61202:     return E_FAIL;
  966: 
  966:   nsresult rv = NS_OK;
  966:   nsAutoString text;
  966:   PRInt32 startOffset = 0, endOffset = 0;
  966: 
  966:   if (aBoundaryType == IA2_TEXT_BOUNDARY_ALL) {
  966:     startOffset = 0;
61202:     endOffset = textAcc->CharacterCount();
  966:     rv = textAcc->GetText(startOffset, endOffset, text);
  966:   } else {
  966:     nsAccessibleTextBoundary boundaryType = GetGeckoTextBoundary(aBoundaryType);
10945:     if (boundaryType == -1)
10945:       return S_FALSE;
  966:     rv = textAcc->GetTextAfterOffset(aOffset, boundaryType,
  966:                                      &startOffset, &endOffset, text);
  966:   }
  966: 
  966:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
  966: 
  966:   *aStartOffset = startOffset;
  966:   *aEndOffset = endOffset;
  966: 
13128:   if (text.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aText = ::SysAllocStringLen(text.get(), text.Length());
13730:   return *aText ? S_OK : E_OUTOFMEMORY;
13128: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13730:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_textAtOffset(long aOffset,
  966:                                   enum IA2TextBoundaryType aBoundaryType,
  966:                                   long *aStartOffset, long *aEndOffset,
  966:                                   BSTR *aText)
  966: {
11593: __try {
13730:   *aStartOffset = 0;
13730:   *aEndOffset = 0;
13730:   *aText = NULL;
13730: 
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
61202:   if (textAcc->IsDefunct())
61202:     return E_FAIL;
  966: 
  966:   nsresult rv = NS_OK;
  966:   nsAutoString text;
  966:   PRInt32 startOffset = 0, endOffset = 0;
  966: 
  966:   if (aBoundaryType == IA2_TEXT_BOUNDARY_ALL) {
  966:     startOffset = 0;
61202:     endOffset = textAcc->CharacterCount();
  966:     rv = textAcc->GetText(startOffset, endOffset, text);
  966:   } else {
  966:     nsAccessibleTextBoundary boundaryType = GetGeckoTextBoundary(aBoundaryType);
10945:     if (boundaryType == -1)
10945:       return S_FALSE;
  966:     rv = textAcc->GetTextAtOffset(aOffset, boundaryType,
  966:                                   &startOffset, &endOffset, text);
  966:   }
  966: 
  966:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
  966: 
  966:   *aStartOffset = startOffset;
  966:   *aEndOffset = endOffset;
  966: 
13128:   if (text.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aText = ::SysAllocStringLen(text.get(), text.Length());
13730:   return *aText ? S_OK : E_OUTOFMEMORY;
13128: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13730:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::removeSelection(long aSelectionIndex)
  966: {
11593: __try {
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966: 
  966:   nsresult rv = textAcc->RemoveSelection(aSelectionIndex);
13730:   return GetHRESULT(rv);
13730: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::setCaretOffset(long aOffset)
  966: {
11593: __try {
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966: 
  966:   nsresult rv = textAcc->SetCaretOffset(aOffset);
13730:   return GetHRESULT(rv);
13730: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::setSelection(long aSelectionIndex, long aStartOffset,
  966:                               long aEndOffset)
  966: {
11593: __try {
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966: 
  966:   nsresult rv = textAcc->SetSelectionBounds(aSelectionIndex,
  966:                                             aStartOffset, aEndOffset);
13730:   return GetHRESULT(rv);
13730: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_nCharacters(long *aNCharacters)
  966: {
11593: __try {
13730:   *aNCharacters = 0;
13730: 
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
61202:   if (textAcc->IsDefunct())
61202:     return E_FAIL;
  966: 
61202:   *aNCharacters  = textAcc->CharacterCount();
13730:   return S_OK;
  966: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::scrollSubstringTo(long aStartIndex, long aEndIndex,
  966:                                    enum IA2ScrollType aScrollType)
  966: {
11593: __try {
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966: 
 5245:   nsresult rv = textAcc->ScrollSubstringTo(aStartIndex, aEndIndex, aScrollType);
13730:   return GetHRESULT(rv);
13730: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::scrollSubstringToPoint(long aStartIndex, long aEndIndex,
 6286:                                         enum IA2CoordinateType aCoordType,
  966:                                         long aX, long aY)
  966: {
11593: __try {
61202:   nsRefPtr<nsHyperTextAccessible> textAcc(do_QueryObject(this));
  966: 
 6286:   PRUint32 geckoCoordType = (aCoordType == IA2_COORDTYPE_SCREEN_RELATIVE) ?
 6286:     nsIAccessibleCoordinateType::COORDTYPE_SCREEN_RELATIVE :
 6286:     nsIAccessibleCoordinateType::COORDTYPE_PARENT_RELATIVE;
  966: 
 6286:   nsresult rv = textAcc->ScrollSubstringToPoint(aStartIndex, aEndIndex,
 6286:                                                 geckoCoordType, aX, aY);
13730:   return GetHRESULT(rv);
13730: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_newText(IA2TextSegment *aNewText)
  966: {
11593: __try {
80486:   return GetModifiedText(true, aNewText);
13730: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: STDMETHODIMP
  966: CAccessibleText::get_oldText(IA2TextSegment *aOldText)
  966: {
11593: __try {
80486:   return GetModifiedText(false, aOldText);
13730: 
11593: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593:   return E_FAIL;
  966: }
  966: 
  966: // CAccessibleText
  966: 
  966: HRESULT
79445: CAccessibleText::GetModifiedText(bool aGetInsertedText,
  966:                                  IA2TextSegment *aText)
  966: {
  966:   PRUint32 startOffset = 0, endOffset = 0;
  966:   nsAutoString text;
  966: 
  966:   nsresult rv = GetModifiedText(aGetInsertedText, text,
  966:                                 &startOffset, &endOffset);
  966:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
  966: 
  966:   aText->start = startOffset;
  966:   aText->end = endOffset;
  966: 
13730:   if (text.IsEmpty())
13730:     return S_FALSE;
13730: 
13128:   aText->text = ::SysAllocStringLen(text.get(), text.Length());
13730:   return aText->text ? S_OK : E_OUTOFMEMORY;
  966: }
  966: 
  966: nsAccessibleTextBoundary
  966: CAccessibleText::GetGeckoTextBoundary(enum IA2TextBoundaryType aBoundaryType)
  966: {
  966:   switch (aBoundaryType) {
  966:     case IA2_TEXT_BOUNDARY_CHAR:
  966:       return nsIAccessibleText::BOUNDARY_CHAR;
  966:     case IA2_TEXT_BOUNDARY_WORD:
  966:       return nsIAccessibleText::BOUNDARY_WORD_START;
  966:     case IA2_TEXT_BOUNDARY_LINE:
  966:       return nsIAccessibleText::BOUNDARY_LINE_START;
10945:     //case IA2_TEXT_BOUNDARY_SENTENCE:
10945:     //case IA2_TEXT_BOUNDARY_PARAGRAPH:
10945:       // XXX: not implemented
  966:     default:
  966:       return -1;
  966:   }
  966: }
  966: 
