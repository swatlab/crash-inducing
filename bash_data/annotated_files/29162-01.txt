    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998-2000
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Norris Boyd
    1:  *   Mitch Stoltz
    1:  *   Steve Morse
    1:  *   Christopher A. Aillon
    1:  *   Giorgio Maone
13414:  *   Daniel Veditz
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsScriptSecurityManager.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIScriptObjectPrincipal.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIURL.h"
    1: #include "nsINestedURI.h"
    1: #include "nspr.h"
    1: #include "nsJSPrincipals.h"
    1: #include "nsSystemPrincipal.h"
    1: #include "nsPrincipal.h"
    1: #include "nsNullPrincipal.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsCRT.h"
    1: #include "nsCRTGlue.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsDOMError.h"
    1: #include "nsDOMCID.h"
    1: #include "jsdbgapi.h"
 8990: #include "jsarena.h"
 8990: #include "jsfun.h"
10939: #include "jsobj.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIXPCSecurityManager.h"
    1: #include "nsTextFormatter.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIProperties.h"
    1: #include "nsDirectoryServiceDefs.h"
    1: #include "nsIFile.h"
 5766: #include "nsIFileURL.h"
    1: #include "nsIZipReader.h"
    1: #include "nsIJAR.h"
    1: #include "nsIPluginInstance.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIPrompt.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsIConsoleService.h"
    1: #include "nsISecurityCheckedComponent.h"
    1: #include "nsIPrefBranch2.h"
    1: #include "nsIJSRuntimeService.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIContent.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsDOMJSUtils.h"
    1: #include "nsAboutProtocolUtils.h"
    1: #include "nsIClassInfo.h"
    1: #include "nsIURIFixup.h"
    1: #include "nsCDefaultURIFixup.h"
14262: #include "nsIChromeRegistry.h"
28610: #include "nsPrintfCString.h"
    1: 
    1: static NS_DEFINE_CID(kZipReaderCID, NS_ZIPREADER_CID);
    1: 
    1: nsIIOService    *nsScriptSecurityManager::sIOService = nsnull;
    1: nsIXPConnect    *nsScriptSecurityManager::sXPConnect = nsnull;
20462: nsIThreadJSContextStack *nsScriptSecurityManager::sJSContextStack = nsnull;
    1: nsIStringBundle *nsScriptSecurityManager::sStrBundle = nsnull;
    1: JSRuntime       *nsScriptSecurityManager::sRuntime   = 0;
13414: PRBool nsScriptSecurityManager::sStrictFileOriginPolicy = PR_TRUE;
    1: 
 8990: // Info we need about the JSClasses used by XPConnects wrapped
 8990: // natives, to avoid having to QI to nsIXPConnectWrappedNative all the
 8990: // time when doing security checks.
 8990: static const JSClass *sXPCWrappedNativeJSClass;
 8990: static JSGetObjectOps sXPCWrappedNativeGetObjOps1;
 8990: static JSGetObjectOps sXPCWrappedNativeGetObjOps2;
 8990: 
 8990: 
    1: ///////////////////////////
    1: // Convenience Functions //
    1: ///////////////////////////
    1: // Result of this function should not be freed.
    1: static inline const PRUnichar *
    1: JSValIDToString(JSContext *cx, const jsval idval)
    1: {
    1:     JSAutoRequest ar(cx);
    1:     JSString *str = JS_ValueToString(cx, idval);
    1:     if(!str)
    1:         return nsnull;
 3233:     return reinterpret_cast<PRUnichar*>(JS_GetStringChars(str));
    1: }
    1: 
28684: class nsAutoInPrincipalDomainOriginSetter {
28684: public:
28684:     nsAutoInPrincipalDomainOriginSetter() {
28684:         ++sInPrincipalDomainOrigin;
28684:     }
28684:     ~nsAutoInPrincipalDomainOriginSetter() {
28684:         --sInPrincipalDomainOrigin;
28684:     }
28684:     static PRUint32 sInPrincipalDomainOrigin;
28684: };
28684: PRUint32 nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin;
28684: 
16273: static
16273: nsresult
16273: GetPrincipalDomainOrigin(nsIPrincipal* aPrincipal,
16273:                          nsACString& aOrigin)
16273: {
28713:   if (nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin > 1) {
28713:       // Allow a single recursive call to GetPrincipalDomainOrigin, since that
28713:       // might be happening on a different principal from the first call.  But
28713:       // after that, cut off the recursion; it just indicates that something
28713:       // we're doing in this method causes us to reenter a security check here.
28713:       return NS_ERROR_NOT_AVAILABLE;
28713:   }
28713: 
28684:   nsAutoInPrincipalDomainOriginSetter autoSetter;
16273:   aOrigin.Truncate();
16273: 
16273:   nsCOMPtr<nsIURI> uri;
16273:   aPrincipal->GetDomain(getter_AddRefs(uri));
16273:   if (!uri) {
16273:     aPrincipal->GetURI(getter_AddRefs(uri));
16273:   }
16273:   NS_ENSURE_TRUE(uri, NS_ERROR_UNEXPECTED);
16273: 
16273:   uri = NS_GetInnermostURI(uri);
16273:   NS_ENSURE_TRUE(uri, NS_ERROR_UNEXPECTED);
16273: 
16273:   nsCAutoString hostPort;
16273: 
16273:   nsresult rv = uri->GetHostPort(hostPort);
16273:   if (NS_SUCCEEDED(rv)) {
16273:     nsCAutoString scheme;
16273:     rv = uri->GetScheme(scheme);
16273:     NS_ENSURE_SUCCESS(rv, rv);
16273:     aOrigin = scheme + NS_LITERAL_CSTRING("://") + hostPort;
16273:   }
16273:   else {
16273:     // Some URIs (e.g., nsSimpleURI) don't support host. Just
16273:     // get the full spec.
16273:     rv = uri->GetSpec(aOrigin);
16273:     NS_ENSURE_SUCCESS(rv, rv);
16273:   }
16273: 
16273:   return NS_OK;
16273: }
16273: 
10939: // Inline copy of JS_GetPrivate() for better inlining and optimization
10939: // possibilities. Also doesn't take a cx argument as it's not
10939: // needed. We access the private data only on objects whose private
10939: // data is not expected to change during the lifetime of the object,
10939: // so thus we won't worry about locking and holding on to slot values
10939: // etc while referencing private data.
10939: inline void *
10939: caps_GetJSPrivate(JSObject *obj)
10939: {
10939:     jsval v;
10939: 
10939:     JS_ASSERT(STOBJ_GET_CLASS(obj)->flags & JSCLASS_HAS_PRIVATE);
10939:     v = obj->fslots[JSSLOT_PRIVATE];
10939:     if (!JSVAL_IS_INT(v))
10939:         return NULL;
10939:     return JSVAL_TO_PRIVATE(v);
10939: }
10939: 
    1: static nsIScriptContext *
    1: GetScriptContext(JSContext *cx)
    1: {
    1:     return GetScriptContextFromJSContext(cx);
    1: }
    1: 
    1: inline void SetPendingException(JSContext *cx, const char *aMsg)
    1: {
    1:     JSAutoRequest ar(cx);
13379:     JS_ReportError(cx, "%s", aMsg);
    1: }
    1: 
    1: inline void SetPendingException(JSContext *cx, const PRUnichar *aMsg)
    1: {
    1:     JSAutoRequest ar(cx);
13379:     JS_ReportError(cx, "%hs", aMsg);
    1: }
    1: 
    1: // DomainPolicy members
    1: #ifdef DEBUG_CAPS_DomainPolicyLifeCycle
    1: PRUint32 DomainPolicy::sObjects=0;
    1: void DomainPolicy::_printPopulationInfo()
    1: {
    1:     printf("CAPS.DomainPolicy: Gen. %d, %d DomainPolicy objects.\n",
    1:         sGeneration, sObjects);
    1: }
    1: #endif
    1: PRUint32 DomainPolicy::sGeneration = 0;
    1: 
    1: // Helper class to get stuff from the ClassInfo and not waste extra time with
    1: // virtual method calls for things it has already gotten
    1: class ClassInfoData
    1: {
    1: public:
    1:     ClassInfoData(nsIClassInfo *aClassInfo, const char *aName)
    1:         : mClassInfo(aClassInfo),
 3233:           mName(const_cast<char *>(aName)),
    1:           mDidGetFlags(PR_FALSE),
    1:           mMustFreeName(PR_FALSE)
    1:     {
    1:     }
    1: 
    1:     ~ClassInfoData()
    1:     {
    1:         if (mMustFreeName)
    1:             nsMemory::Free(mName);
    1:     }
    1: 
    1:     PRUint32 GetFlags()
    1:     {
    1:         if (!mDidGetFlags) {
    1:             if (mClassInfo) {
    1:                 nsresult rv = mClassInfo->GetFlags(&mFlags);
    1:                 if (NS_FAILED(rv)) {
    1:                     mFlags = 0;
    1:                 }
    1:             } else {
    1:                 mFlags = 0;
    1:             }
    1: 
    1:             mDidGetFlags = PR_TRUE;
    1:         }
    1: 
    1:         return mFlags;
    1:     }
    1: 
    1:     PRBool IsDOMClass()
    1:     {
 7870:         return !!(GetFlags() & nsIClassInfo::DOM_OBJECT);
    1:     }
    1: 
    1:     const char* GetName()
    1:     {
    1:         if (!mName) {
    1:             if (mClassInfo) {
    1:                 mClassInfo->GetClassDescription(&mName);
    1:             }
    1: 
    1:             if (mName) {
    1:                 mMustFreeName = PR_TRUE;
    1:             } else {
 3233:                 mName = const_cast<char *>("UnnamedClass");
    1:             }
    1:         }
    1: 
    1:         return mName;
    1:     }
    1: 
    1: private:
    1:     nsIClassInfo *mClassInfo; // WEAK
    1:     PRUint32 mFlags;
    1:     char *mName;
    1:     PRPackedBool mDidGetFlags;
    1:     PRPackedBool mMustFreeName;
    1: };
    1: 
20175: class AutoCxPusher {
20175: public:
20175:     AutoCxPusher(nsIJSContextStack *aStack, JSContext *cx)
20175:         : mStack(aStack), mContext(cx)
20175:     {
20175:         if (NS_FAILED(mStack->Push(mContext))) {
20175:             mStack = nsnull;
20175:         }
20175:     }
20175: 
20175:     ~AutoCxPusher()
20175:     {
20175:         if (mStack) {
20175:             mStack->Pop(nsnull);
20175:         }
20175:     }
20175: 
20175: private:
20175:     nsCOMPtr<nsIJSContextStack> mStack;
20175:     JSContext *mContext;
20175: };
20175: 
    1: JSContext *
    1: nsScriptSecurityManager::GetCurrentJSContext()
    1: {
    1:     // Get JSContext from stack.
    1:     JSContext *cx;
20462:     if (NS_FAILED(sJSContextStack->Peek(&cx)))
    1:         return nsnull;
    1:     return cx;
    1: }
    1: 
    1: JSContext *
    1: nsScriptSecurityManager::GetSafeJSContext()
    1: {
    1:     // Get JSContext from stack.
    1:     JSContext *cx;
20462:     if (NS_FAILED(sJSContextStack->GetSafeJSContext(&cx)))
    1:         return nsnull;
    1:     return cx;
    1: }
    1: 
12321: /* static */
    1: PRBool
    1: nsScriptSecurityManager::SecurityCompareURIs(nsIURI* aSourceURI,
    1:                                              nsIURI* aTargetURI)
    1: {
18488:     return NS_SecurityCompareURIs(aSourceURI, aTargetURI, sStrictFileOriginPolicy);
    1: }
    1: 
20149: // SecurityHashURI is consistent with SecurityCompareURIs because NS_SecurityHashURI
20149: // is consistent with NS_SecurityCompareURIs.  See nsNetUtil.h.
20149: PRUint32
20149: nsScriptSecurityManager::SecurityHashURI(nsIURI* aURI)
20149: {
20149:     return NS_SecurityHashURI(aURI);
20149: }
20149: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::GetChannelPrincipal(nsIChannel* aChannel,
    1:                                              nsIPrincipal** aPrincipal)
    1: {
    1:     NS_PRECONDITION(aChannel, "Must have channel!");
    1:     nsCOMPtr<nsISupports> owner;
    1:     aChannel->GetOwner(getter_AddRefs(owner));
    1:     if (owner) {
    1:         CallQueryInterface(owner, aPrincipal);
    1:         if (*aPrincipal) {
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
    1:     // OK, get the principal from the URI.  Make sure this does the same thing
    1:     // as nsDocument::Reset and nsXULDocument::StartDocumentLoad.
    1:     nsCOMPtr<nsIURI> uri;
 7109:     nsresult rv = NS_GetFinalChannelURI(aChannel, getter_AddRefs(uri));
 7109:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     return GetCodebasePrincipal(uri, aPrincipal);
    1: }
    1: 
 2524: NS_IMETHODIMP
 2524: nsScriptSecurityManager::IsSystemPrincipal(nsIPrincipal* aPrincipal,
 2524:                                            PRBool* aIsSystem)
 2524: {
 2524:     *aIsSystem = (aPrincipal == mSystemPrincipal);
 2524:     return NS_OK;
 2524: }
 2524: 
 9825: NS_IMETHODIMP_(nsIPrincipal *)
 9825: nsScriptSecurityManager::GetCxSubjectPrincipal(JSContext *cx)
 9825: {
 9825:     NS_ASSERTION(cx == GetCurrentJSContext(),
 9825:                  "Uh, cx is not the current JS context!");
 9825: 
 9825:     nsresult rv = NS_ERROR_FAILURE;
 9825:     nsIPrincipal *principal = GetSubjectPrincipal(cx, &rv);
 9825:     if (NS_FAILED(rv))
 9825:         return nsnull;
 9825: 
 9825:     return principal;
 9825: }
 9825: 
20761: NS_IMETHODIMP_(nsIPrincipal *)
20761: nsScriptSecurityManager::GetCxSubjectPrincipalAndFrame(JSContext *cx, JSStackFrame **fp)
20761: {
20761:     NS_ASSERTION(cx == GetCurrentJSContext(),
20761:                  "Uh, cx is not the current JS context!");
20761: 
20761:     nsresult rv = NS_ERROR_FAILURE;
20761:     nsIPrincipal *principal = GetPrincipalAndFrame(cx, fp, &rv);
20761:     if (NS_FAILED(rv))
20761:         return nsnull;
20761: 
20761:     return principal;
20761: }
20761: 
    1: ////////////////////
    1: // Policy Storage //
    1: ////////////////////
    1: 
    1: // Table of security levels
20261: static PRBool
    1: DeleteCapability(nsHashKey *aKey, void *aData, void* closure)
    1: {
    1:     NS_Free(aData);
    1:     return PR_TRUE;
    1: }
    1: 
    1: //-- Per-Domain Policy - applies to one or more protocols or hosts
    1: struct DomainEntry
    1: {
    1:     DomainEntry(const char* aOrigin,
    1:                 DomainPolicy* aDomainPolicy) : mOrigin(aOrigin),
    1:                                                mDomainPolicy(aDomainPolicy),
    1:                                                mNext(nsnull)
    1:     {
    1:         mDomainPolicy->Hold();
    1:     }
    1: 
    1:     ~DomainEntry()
    1:     {
    1:         mDomainPolicy->Drop();
    1:     }
    1: 
    1:     PRBool Matches(const char *anOrigin)
    1:     {
    1:         int len = strlen(anOrigin);
    1:         int thisLen = mOrigin.Length();
    1:         if (len < thisLen)
    1:             return PR_FALSE;
    1:         if (mOrigin.RFindChar(':', thisLen-1, 1) != -1)
    1:         //-- Policy applies to all URLs of this scheme, compare scheme only
    1:             return mOrigin.EqualsIgnoreCase(anOrigin, thisLen);
    1: 
    1:         //-- Policy applies to a particular host; compare domains
    1:         if (!mOrigin.Equals(anOrigin + (len - thisLen)))
    1:             return PR_FALSE;
    1:         if (len == thisLen)
    1:             return PR_TRUE;
    1:         char charBefore = anOrigin[len-thisLen-1];
    1:         return (charBefore == '.' || charBefore == ':' || charBefore == '/');
    1:     }
    1: 
    1:     nsCString         mOrigin;
    1:     DomainPolicy*     mDomainPolicy;
    1:     DomainEntry*      mNext;
    1: #if defined(DEBUG) || defined(DEBUG_CAPS_HACKER)
    1:     nsCString         mPolicyName_DEBUG;
    1: #endif
    1: };
    1: 
20261: static PRBool
    1: DeleteDomainEntry(nsHashKey *aKey, void *aData, void* closure)
    1: {
    1:     DomainEntry *entry = (DomainEntry*) aData;
    1:     do
    1:     {
    1:         DomainEntry *next = entry->mNext;
    1:         delete entry;
    1:         entry = next;
    1:     } while (entry);
    1:     return PR_TRUE;
    1: }
    1: 
    1: /////////////////////////////
    1: // nsScriptSecurityManager //
    1: /////////////////////////////
    1: 
    1: ////////////////////////////////////
    1: // Methods implementing ISupports //
    1: ////////////////////////////////////
    1: NS_IMPL_ISUPPORTS5(nsScriptSecurityManager,
    1:                    nsIScriptSecurityManager,
    1:                    nsIXPCSecurityManager,
    1:                    nsIPrefSecurityCheck,
    1:                    nsIChannelEventSink,
    1:                    nsIObserver)
    1: 
    1: ///////////////////////////////////////////////////
    1: // Methods implementing nsIScriptSecurityManager //
    1: ///////////////////////////////////////////////////
    1: 
    1: ///////////////// Security Checks /////////////////
18907: JSBool
    1: nsScriptSecurityManager::CheckObjectAccess(JSContext *cx, JSObject *obj,
    1:                                            jsval id, JSAccessMode mode,
    1:                                            jsval *vp)
    1: {
    1:     // Get the security manager
    1:     nsScriptSecurityManager *ssm =
    1:         nsScriptSecurityManager::GetScriptSecurityManager();
    1: 
    1:     NS_ASSERTION(ssm, "Failed to get security manager service");
    1:     if (!ssm)
    1:         return JS_FALSE;
    1: 
    1:     // Get the object being accessed.  We protect these cases:
    1:     // 1. The Function.prototype.caller property's value, which might lead
    1:     //    an attacker up a call-stack to a function or another object from
    1:     //    a different trust domain.
    1:     // 2. A user-defined getter or setter function accessible on another
    1:     //    trust domain's window or document object.
    1:     // *vp can be a primitive, in that case, we use obj as the target
    1:     // object.
    1:     JSObject* target = JSVAL_IS_PRIMITIVE(*vp) ? obj : JSVAL_TO_OBJECT(*vp);
    1: 
    1:     // Do the same-origin check -- this sets a JS exception if the check fails.
    1:     // Pass the parent object's class name, as we have no class-info for it.
 5491:     nsresult rv =
10939:         ssm->CheckPropertyAccess(cx, target, STOBJ_GET_CLASS(obj)->name, id,
 5491:                                  (mode & JSACC_WRITE) ?
20175:                                  (PRInt32)nsIXPCSecurityManager::ACCESS_SET_PROPERTY :
20175:                                  (PRInt32)nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
    1: 
    1:     if (NS_FAILED(rv))
    1:         return JS_FALSE; // Security check failed (XXX was an error reported?)
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CheckPropertyAccess(JSContext* cx,
    1:                                              JSObject* aJSObject,
    1:                                              const char* aClassName,
    1:                                              jsval aProperty,
    1:                                              PRUint32 aAction)
    1: {
    1:     return CheckPropertyAccessImpl(aAction, nsnull, cx, aJSObject,
14480:                                    nsnull, nsnull, nsnull,
    1:                                    aClassName, aProperty, nsnull);
    1: }
    1: 
    1: NS_IMETHODIMP
14480: nsScriptSecurityManager::CheckConnect(JSContext* cx,
14480:                                       nsIURI* aTargetURI,
14480:                                       const char* aClassName,
14480:                                       const char* aPropertyName)
14480: {
14480:     // Get a context if necessary
14480:     if (!cx)
14480:     {
14480:         cx = GetCurrentJSContext();
14480:         if (!cx)
14480:             return NS_OK; // No JS context, so allow the load
14480:     }
14480: 
14480:     nsresult rv = CheckLoadURIFromScript(cx, aTargetURI);
14480:     if (NS_FAILED(rv)) return rv;
14480: 
14480:     JSAutoRequest ar(cx);
14480: 
14480:     JSString* propertyName = ::JS_InternString(cx, aPropertyName);
14480:     if (!propertyName)
14480:         return NS_ERROR_OUT_OF_MEMORY;
14480: 
14480:     return CheckPropertyAccessImpl(nsIXPCSecurityManager::ACCESS_CALL_METHOD, nsnull,
14480:                                    cx, nsnull, nsnull, aTargetURI,
14480:                                    nsnull, aClassName, STRING_TO_JSVAL(propertyName), nsnull);
14480: }
14480: 
14480: NS_IMETHODIMP
    1: nsScriptSecurityManager::CheckSameOrigin(JSContext* cx,
    1:                                          nsIURI* aTargetURI)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Get a context if necessary
    1:     if (!cx)
    1:     {
    1:         cx = GetCurrentJSContext();
    1:         if (!cx)
    1:             return NS_OK; // No JS context, so allow access
    1:     }
    1: 
    1:     // Get a principal from the context
    1:     nsIPrincipal* sourcePrincipal = GetSubjectPrincipal(cx, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (!sourcePrincipal)
    1:     {
    1:         NS_WARNING("CheckSameOrigin called on script w/o principals; should this happen?");
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (sourcePrincipal == mSystemPrincipal)
    1:     {
    1:         // This is a system (chrome) script, so allow access
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Get the original URI from the source principal.
    1:     // This has the effect of ignoring any change to document.domain
    1:     // which must be done to avoid DNS spoofing (bug 154930)
    1:     nsCOMPtr<nsIURI> sourceURI;
    1:     sourcePrincipal->GetDomain(getter_AddRefs(sourceURI));
    1:     if (!sourceURI) {
    1:       sourcePrincipal->GetURI(getter_AddRefs(sourceURI));
    1:       NS_ENSURE_TRUE(sourceURI, NS_ERROR_FAILURE);
    1:     }
    1: 
    1:     // Compare origins
    1:     if (!SecurityCompareURIs(sourceURI, aTargetURI))
    1:     {
    1:          ReportError(cx, NS_LITERAL_STRING("CheckSameOriginError"), sourceURI, aTargetURI);
13172:          return NS_ERROR_DOM_BAD_URI;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CheckSameOriginURI(nsIURI* aSourceURI,
 7219:                                             nsIURI* aTargetURI,
 7219:                                             PRBool reportError)
    1: {
    1:     if (!SecurityCompareURIs(aSourceURI, aTargetURI))
    1:     {
 7219:          if (reportError) {
    1:             ReportError(nsnull, NS_LITERAL_STRING("CheckSameOriginError"),
    1:                      aSourceURI, aTargetURI);
 7219:          }
    1:          return NS_ERROR_DOM_BAD_URI;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsScriptSecurityManager::CheckPropertyAccessImpl(PRUint32 aAction,
10286:                                                  nsAXPCNativeCallContext* aCallContext,
    1:                                                  JSContext* cx, JSObject* aJSObject,
14480:                                                  nsISupports* aObj, nsIURI* aTargetURI,
    1:                                                  nsIClassInfo* aClassInfo,
    1:                                                  const char* aClassName, jsval aProperty,
    1:                                                  void** aCachedClassPolicy)
    1: {
    1:     nsresult rv;
    1:     nsIPrincipal* subjectPrincipal = GetSubjectPrincipal(cx, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (!subjectPrincipal || subjectPrincipal == mSystemPrincipal)
    1:         // We have native code or the system principal: just allow access
    1:         return NS_OK;
    1: 
16268:     nsCOMPtr<nsIPrincipal> objectPrincipal;
16268: 
    1:     // Hold the class info data here so we don't have to go back to virtual
    1:     // methods all the time
    1:     ClassInfoData classInfoData(aClassInfo, aClassName);
    1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
    1:     nsCAutoString propertyName;
    1:     propertyName.AssignWithConversion((PRUnichar*)JSValIDToString(cx, aProperty));
    1:     printf("### CanAccess(%s.%s, %i) ", classInfoData.GetName(), 
    1:            propertyName.get(), aAction);
    1: #endif
    1: 
    1:     //-- Look up the security policy for this class and subject domain
    1:     SecurityLevel securityLevel;
    1:     rv = LookupPolicy(subjectPrincipal, classInfoData, aProperty, aAction, 
    1:                       (ClassPolicy**)aCachedClassPolicy, &securityLevel);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (securityLevel.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
    1:     {   
    1:         // No policy found for this property so use the default of last resort.
    1:         // If we were called from somewhere other than XPConnect
    1:         // (no XPC call context), assume this is a DOM class. Otherwise,
    1:         // ask the ClassInfo.
    1:         if (!aCallContext || classInfoData.IsDOMClass())
    1:             securityLevel.level = SCRIPT_SECURITY_SAME_ORIGIN_ACCESS;
    1:         else
    1:             securityLevel.level = SCRIPT_SECURITY_NO_ACCESS;
    1:     }
    1: 
    1:     if (SECURITY_ACCESS_LEVEL_FLAG(securityLevel))
    1:     // This flag means securityLevel is allAccess, noAccess, or sameOrigin
    1:     {
    1:         switch (securityLevel.level)
    1:         {
    1:         case SCRIPT_SECURITY_NO_ACCESS:
    1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
    1:             printf("noAccess ");
    1: #endif
    1:             rv = NS_ERROR_DOM_PROP_ACCESS_DENIED;
    1:             break;
    1: 
    1:         case SCRIPT_SECURITY_ALL_ACCESS:
    1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
    1:             printf("allAccess ");
    1: #endif
    1:             rv = NS_OK;
    1:             break;
    1: 
    1:         case SCRIPT_SECURITY_SAME_ORIGIN_ACCESS:
    1:             {
    1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
    1:                 printf("sameOrigin ");
    1: #endif
10341:                 nsCOMPtr<nsIPrincipal> principalHolder;
    1:                 if(aJSObject)
    1:                 {
10939:                     objectPrincipal = doGetObjectPrincipal(aJSObject);
    1:                     if (!objectPrincipal)
 9830:                         rv = NS_ERROR_DOM_SECURITY_ERR;
    1:                 }
14480:                 else if(aTargetURI)
14480:                 {
14480:                     if (NS_FAILED(GetCodebasePrincipal(
16268:                           aTargetURI, getter_AddRefs(objectPrincipal))))
14480:                         return NS_ERROR_FAILURE;
14480:                 }
    1:                 else
    1:                 {
14480:                     NS_ERROR("CheckPropertyAccessImpl called without a target object or URL");
    1:                     return NS_ERROR_FAILURE;
    1:                 }
 9830:                 if(NS_SUCCEEDED(rv))
    1:                     rv = CheckSameOriginDOMProp(subjectPrincipal, objectPrincipal,
14480:                                                 aAction, aTargetURI != nsnull);
    1:                 break;
    1:             }
    1:         default:
    1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
    1:                 printf("ERROR ");
    1: #endif
    1:             NS_ERROR("Bad Security Level Value");
    1:             return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1:     else // if SECURITY_ACCESS_LEVEL_FLAG is false, securityLevel is a capability
    1:     {
    1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
    1:         printf("Cap:%s ", securityLevel.capability);
    1: #endif
    1:         PRBool capabilityEnabled = PR_FALSE;
    1:         rv = IsCapabilityEnabled(securityLevel.capability, &capabilityEnabled);
    1:         if (NS_FAILED(rv) || !capabilityEnabled)
    1:             rv = NS_ERROR_DOM_SECURITY_ERR;
    1:         else
    1:             rv = NS_OK;
    1:     }
    1: 
    1:     if (NS_SUCCEEDED(rv))
    1:     {
    1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
    1:     printf(" GRANTED.\n");
    1: #endif
    1:         return rv;
    1:     }
    1: 
    1:     //--See if the object advertises a non-default level of access
    1:     //  using nsISecurityCheckedComponent
    1:     nsCOMPtr<nsISecurityCheckedComponent> checkedComponent =
    1:         do_QueryInterface(aObj);
    1: 
    1:     nsXPIDLCString objectSecurityLevel;
    1:     if (checkedComponent)
    1:     {
    1:         nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
    1:         nsCOMPtr<nsIInterfaceInfo> interfaceInfo;
 5491:         const nsIID* objIID;
    1:         rv = aCallContext->GetCalleeWrapper(getter_AddRefs(wrapper));
    1:         if (NS_SUCCEEDED(rv))
    1:             rv = wrapper->FindInterfaceWithMember(aProperty, getter_AddRefs(interfaceInfo));
    1:         if (NS_SUCCEEDED(rv))
    1:             rv = interfaceInfo->GetIIDShared(&objIID);
    1:         if (NS_SUCCEEDED(rv))
    1:         {
    1:             switch (aAction)
    1:             {
    1:             case nsIXPCSecurityManager::ACCESS_GET_PROPERTY:
    1:                 checkedComponent->CanGetProperty(objIID,
    1:                                                  JSValIDToString(cx, aProperty),
    1:                                                  getter_Copies(objectSecurityLevel));
    1:                 break;
    1:             case nsIXPCSecurityManager::ACCESS_SET_PROPERTY:
    1:                 checkedComponent->CanSetProperty(objIID,
    1:                                                  JSValIDToString(cx, aProperty),
    1:                                                  getter_Copies(objectSecurityLevel));
    1:                 break;
    1:             case nsIXPCSecurityManager::ACCESS_CALL_METHOD:
    1:                 checkedComponent->CanCallMethod(objIID,
    1:                                                 JSValIDToString(cx, aProperty),
    1:                                                 getter_Copies(objectSecurityLevel));
    1:             }
    1:         }
    1:     }
28348:     rv = CheckXPCPermissions(aObj, aJSObject, subjectPrincipal,
28292:                              objectSecurityLevel);
    1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
    1:     if(NS_SUCCEEDED(rv))
    1:         printf("CheckXPCPerms GRANTED.\n");
    1:     else
    1:         printf("CheckXPCPerms DENIED.\n");
    1: #endif
    1: 
    1:     if (NS_FAILED(rv)) //-- Security tests failed, access is denied, report error
    1:     {
    1:         nsAutoString stringName;
    1:         switch(aAction)
    1:         {
    1:         case nsIXPCSecurityManager::ACCESS_GET_PROPERTY:
16268:             stringName.AssignLiteral("GetPropertyDeniedOrigins");
    1:             break;
    1:         case nsIXPCSecurityManager::ACCESS_SET_PROPERTY:
16268:             stringName.AssignLiteral("SetPropertyDeniedOrigins");
    1:             break;
    1:         case nsIXPCSecurityManager::ACCESS_CALL_METHOD:
16268:             stringName.AssignLiteral("CallMethodDeniedOrigins");
    1:         }
    1: 
    1:         NS_ConvertUTF8toUTF16 className(classInfoData.GetName());
16268:         nsCAutoString subjectOrigin;
28684:         if (!nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin) {
16268:             GetPrincipalDomainOrigin(subjectPrincipal, subjectOrigin);
28684:         } else {
28684:             subjectOrigin.AssignLiteral("the security manager");
28684:         }
16268:         NS_ConvertUTF8toUTF16 subjectOriginUnicode(subjectOrigin);
16268: 
16268:         nsCAutoString objectOrigin;
28684:         if (!nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin &&
28684:             objectPrincipal) {
16268:             GetPrincipalDomainOrigin(objectPrincipal, objectOrigin);
16268:         }
16268:         NS_ConvertUTF8toUTF16 objectOriginUnicode(objectOrigin);
16268:             
16268:         nsXPIDLString errorMsg;
    1:         const PRUnichar *formatStrings[] =
    1:         {
16268:             subjectOriginUnicode.get(),
    1:             className.get(),
16268:             JSValIDToString(cx, aProperty),
16268:             objectOriginUnicode.get()
    1:         };
    1: 
16268:         PRUint32 length = NS_ARRAY_LENGTH(formatStrings);
16268: 
28684:         if (nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin ||
28684:             !objectPrincipal) {
16268:             stringName.AppendLiteral("OnlySubject");
16268:             --length;
16268:         }
16268:         
    1:         // We need to keep our existing failure rv and not override it
    1:         // with a likely success code from the following string bundle
    1:         // call in order to throw the correct security exception later.
    1:         nsresult rv2 = sStrBundle->FormatStringFromName(stringName.get(),
    1:                                                         formatStrings,
16268:                                                         length,
    1:                                                         getter_Copies(errorMsg));
16268:         if (NS_FAILED(rv2)) {
16268:             // Might just be missing the string...  Do our best
16268:             errorMsg = stringName;
16268:         }
    1: 
    1:         SetPendingException(cx, errorMsg.get());
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
13269: /* static */
    1: nsresult
13269: nsScriptSecurityManager::CheckSameOriginPrincipal(nsIPrincipal* aSubject,
14480:                                                   nsIPrincipal* aObject,
14480:                                                   PRBool aIsCheckConnect)
    1: {
    1:     /*
    1:     ** Get origin of subject and object and compare.
    1:     */
    1:     if (aSubject == aObject)
    1:         return NS_OK;
    1: 
14480:     // These booleans are only used when !aIsCheckConnect.  Default
14480:     // them to false, and change if that turns out wrong.
    1:     PRBool subjectSetDomain = PR_FALSE;
    1:     PRBool objectSetDomain = PR_FALSE;
    1:     
    1:     nsCOMPtr<nsIURI> subjectURI;
    1:     nsCOMPtr<nsIURI> objectURI;
    1: 
14480:     if (aIsCheckConnect)
14480:     {
14480:         // Don't use domain for CheckConnect calls, since that's called for
14480:         // data-only load checks like XMLHTTPRequest (bug 290100).
14480:         aSubject->GetURI(getter_AddRefs(subjectURI));
14480:         aObject->GetURI(getter_AddRefs(objectURI));
14480:     }
14480:     else
14480:     {
    1:         aSubject->GetDomain(getter_AddRefs(subjectURI));
    1:         if (!subjectURI) {
    1:             aSubject->GetURI(getter_AddRefs(subjectURI));
    1:         } else {
    1:             subjectSetDomain = PR_TRUE;
    1:         }
    1: 
    1:         aObject->GetDomain(getter_AddRefs(objectURI));
    1:         if (!objectURI) {
    1:             aObject->GetURI(getter_AddRefs(objectURI));
    1:         } else {
    1:             objectSetDomain = PR_TRUE;
    1:         }
14480:     }
    1: 
    1:     if (SecurityCompareURIs(subjectURI, objectURI))
    1:     {   // If either the subject or the object has changed its principal by
    1:         // explicitly setting document.domain then the other must also have
    1:         // done so in order to be considered the same origin. This prevents
    1:         // DNS spoofing based on document.domain (154930)
    1: 
14480:         // But this restriction does not apply to CheckConnect calls, since
14480:         // that's called for data-only load checks like XMLHTTPRequest where
14480:         // we ignore domain (bug 290100).
14480:         if (aIsCheckConnect)
14480:             return NS_OK;
14480: 
    1:         // If both or neither explicitly set their domain, allow the access
    1:         if (subjectSetDomain == objectSetDomain)
    1:             return NS_OK;
    1:     }
    1: 
    1:     /*
    1:     ** Access tests failed, so now report error.
    1:     */
    1:     return NS_ERROR_DOM_PROP_ACCESS_DENIED;
    1: }
    1: 
20149: // It's important that
20149: //
20149: //   CheckSameOriginPrincipal(A, B, PR_FALSE) == NS_OK
20149: //
20149: // imply
20149: //
20149: //   HashPrincipalByOrigin(A) == HashPrincipalByOrigin(B)
20149: //
20149: // if principals A and B could ever be used as keys in a hashtable.
20149: // Violation of this invariant leads to spurious failures of hashtable
20149: // lookups.  See bug 454850.
20149: 
20149: /*static*/ PRUint32
20149: nsScriptSecurityManager::HashPrincipalByOrigin(nsIPrincipal* aPrincipal)
20149: {
20149:     nsCOMPtr<nsIURI> uri;
20149:     aPrincipal->GetDomain(getter_AddRefs(uri));
20149:     if (!uri)
20149:         aPrincipal->GetURI(getter_AddRefs(uri));
20149:     return SecurityHashURI(uri);
20149: }
    1: 
    1: nsresult
    1: nsScriptSecurityManager::CheckSameOriginDOMProp(nsIPrincipal* aSubject,
    1:                                                 nsIPrincipal* aObject,
14480:                                                 PRUint32 aAction,
14480:                                                 PRBool aIsCheckConnect)
    1: {
13269:     nsresult rv;
14480:     if (aIsCheckConnect) {
14480:         // Don't do equality compares, just do a same-origin compare,
14480:         // since the object principal isn't a real principal, just a
14480:         // GetCodebasePrincipal() on whatever URI we started with.
14480:         rv = CheckSameOriginPrincipal(aSubject, aObject, aIsCheckConnect);
14480:     } else {
13269:         PRBool subsumes;
13269:         rv = aSubject->Subsumes(aObject, &subsumes);
13269:         if (NS_SUCCEEDED(rv) && !subsumes) {
13269:             rv = NS_ERROR_DOM_PROP_ACCESS_DENIED;
13269:         }
14480:     }
    1:     
    1:     if (NS_SUCCEEDED(rv))
    1:         return NS_OK;
    1: 
    1:     /*
    1:     * Content can't ever touch chrome (we check for UniversalXPConnect later)
    1:     */
    1:     if (aObject == mSystemPrincipal)
    1:         return NS_ERROR_DOM_PROP_ACCESS_DENIED;
    1: 
    1:     /*
    1:     * If we failed the origin tests it still might be the case that we
    1:     * are a signed script and have permissions to do this operation.
    1:     * Check for that here.
    1:     */
    1:     PRBool capabilityEnabled = PR_FALSE;
    1:     const char* cap = aAction == nsIXPCSecurityManager::ACCESS_SET_PROPERTY ?
    1:                       "UniversalBrowserWrite" : "UniversalBrowserRead";
    1:     rv = IsCapabilityEnabled(cap, &capabilityEnabled);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (capabilityEnabled)
    1:         return NS_OK;
    1: 
    1:     /*
    1:     ** Access tests failed, so now report error.
    1:     */
    1:     return NS_ERROR_DOM_PROP_ACCESS_DENIED;
    1: }
    1: 
    1: nsresult
    1: nsScriptSecurityManager::LookupPolicy(nsIPrincipal* aPrincipal,
    1:                                       ClassInfoData& aClassData,
    1:                                       jsval aProperty,
    1:                                       PRUint32 aAction,
    1:                                       ClassPolicy** aCachedClassPolicy,
    1:                                       SecurityLevel* result)
    1: {
    1:     nsresult rv;
    1:     result->level = SCRIPT_SECURITY_UNDEFINED_ACCESS;
    1: 
    1:     DomainPolicy* dpolicy = nsnull;
    1:     //-- Initialize policies if necessary
    1:     if (mPolicyPrefsChanged)
    1:     {
23434:         if (!mSecurityPref) {
23434:             rv = InitPrefs();
23434:             NS_ENSURE_SUCCESS(rv, rv);
23434:         }
    1:         rv = InitPolicies();
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1:     else
    1:     {
    1:         aPrincipal->GetSecurityPolicy((void**)&dpolicy);
    1:     }
    1: 
    1:     if (!dpolicy && mOriginToPolicyMap)
    1:     {
    1:         //-- Look up the relevant domain policy, if any
    1: #ifdef DEBUG_CAPS_LookupPolicy
    1:         printf("DomainLookup ");
    1: #endif
    1: 
13284:         nsCAutoString origin;
13284:         rv = GetPrincipalDomainOrigin(aPrincipal, origin);
13284:         NS_ENSURE_SUCCESS(rv, rv);
    1:  
    1:         char *start = origin.BeginWriting();
    1:         const char *nextToLastDot = nsnull;
    1:         const char *lastDot = nsnull;
    1:         const char *colon = nsnull;
    1:         char *p = start;
    1: 
    1:         //-- search domain (stop at the end of the string or at the 3rd slash)
    1:         for (PRUint32 slashes=0; *p; p++)
    1:         {
    1:             if (*p == '/' && ++slashes == 3) 
    1:             {
    1:                 *p = '\0'; // truncate at 3rd slash
    1:                 break;
    1:             }
    1:             if (*p == '.')
    1:             {
    1:                 nextToLastDot = lastDot;
    1:                 lastDot = p;
    1:             } 
    1:             else if (!colon && *p == ':')
    1:                 colon = p;
    1:         }
    1: 
    1:         nsCStringKey key(nextToLastDot ? nextToLastDot+1 : start);
    1:         DomainEntry *de = (DomainEntry*) mOriginToPolicyMap->Get(&key);
    1:         if (!de)
    1:         {
    1:             nsCAutoString scheme(start, colon-start+1);
    1:             nsCStringKey schemeKey(scheme);
    1:             de = (DomainEntry*) mOriginToPolicyMap->Get(&schemeKey);
    1:         }
    1: 
    1:         while (de)
    1:         {
    1:             if (de->Matches(start))
    1:             {
    1:                 dpolicy = de->mDomainPolicy;
    1:                 break;
    1:             }
    1:             de = de->mNext;
    1:         }
    1: 
    1:         if (!dpolicy)
    1:             dpolicy = mDefaultPolicy;
    1: 
    1:         aPrincipal->SetSecurityPolicy((void*)dpolicy);
    1:     }
    1: 
    1:     ClassPolicy* cpolicy = nsnull;
    1: 
    1:     if ((dpolicy == mDefaultPolicy) && aCachedClassPolicy)
    1:     {
    1:         // No per-domain policy for this principal (the more common case)
    1:         // so look for a cached class policy from the object wrapper
    1:         cpolicy = *aCachedClassPolicy;
    1:     }
    1: 
    1:     if (!cpolicy)
    1:     { //-- No cached policy for this class, need to look it up
    1: #ifdef DEBUG_CAPS_LookupPolicy
    1:         printf("ClassLookup ");
    1: #endif
    1: 
 3233:         cpolicy = static_cast<ClassPolicy*>
 3233:                              (PL_DHashTableOperate(dpolicy,
    1:                                                       aClassData.GetName(),
    1:                                                       PL_DHASH_LOOKUP));
    1: 
    1:         if (PL_DHASH_ENTRY_IS_FREE(cpolicy))
    1:             cpolicy = NO_POLICY_FOR_CLASS;
    1: 
    1:         if ((dpolicy == mDefaultPolicy) && aCachedClassPolicy)
    1:             *aCachedClassPolicy = cpolicy;
    1:     }
    1: 
    1:     // We look for a PropertyPolicy in the following places:
    1:     // 1)  The ClassPolicy for our class we got from our DomainPolicy
    1:     // 2)  The mWildcardPolicy of our DomainPolicy
    1:     // 3)  The ClassPolicy for our class we got from mDefaultPolicy
    1:     // 4)  The mWildcardPolicy of our mDefaultPolicy
    1:     PropertyPolicy* ppolicy = nsnull;
    1:     if (cpolicy != NO_POLICY_FOR_CLASS)
    1:     {
 3233:         ppolicy = static_cast<PropertyPolicy*>
 3233:                              (PL_DHashTableOperate(cpolicy->mPolicy,
    1:                                                       (void*)aProperty,
    1:                                                       PL_DHASH_LOOKUP));
    1:     }
    1: 
    1:     // If there is no class policy for this property, and we have a wildcard
    1:     // policy, try that.
    1:     if (dpolicy->mWildcardPolicy &&
    1:         (!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy)))
    1:     {
    1:         ppolicy =
 3233:             static_cast<PropertyPolicy*>
 3233:                        (PL_DHashTableOperate(dpolicy->mWildcardPolicy->mPolicy,
    1:                                                 (void*)aProperty,
    1:                                                 PL_DHASH_LOOKUP));
    1:     }
    1: 
    1:     // If dpolicy is not the defauly policy and there's no class or wildcard
    1:     // policy for this property, check the default policy for this class and
    1:     // the default wildcard policy
    1:     if (dpolicy != mDefaultPolicy &&
    1:         (!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy)))
    1:     {
 3233:         cpolicy = static_cast<ClassPolicy*>
 3233:                              (PL_DHashTableOperate(mDefaultPolicy,
    1:                                                       aClassData.GetName(),
    1:                                                       PL_DHASH_LOOKUP));
    1: 
    1:         if (PL_DHASH_ENTRY_IS_BUSY(cpolicy))
    1:         {
    1:             ppolicy =
 3233:                 static_cast<PropertyPolicy*>
 3233:                            (PL_DHashTableOperate(cpolicy->mPolicy,
    1:                                                     (void*)aProperty,
    1:                                                     PL_DHASH_LOOKUP));
    1:         }
    1: 
    1:         if ((!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy)) &&
    1:             mDefaultPolicy->mWildcardPolicy)
    1:         {
    1:             ppolicy =
 3233:               static_cast<PropertyPolicy*>
 3233:                          (PL_DHashTableOperate(mDefaultPolicy->mWildcardPolicy->mPolicy,
    1:                                                   (void*)aProperty,
    1:                                                   PL_DHASH_LOOKUP));
    1:         }
    1:     }
    1: 
    1:     if (!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy))
    1:         return NS_OK;
    1: 
    1:     // Get the correct security level from the property policy
    1:     if (aAction == nsIXPCSecurityManager::ACCESS_SET_PROPERTY)
    1:         *result = ppolicy->mSet;
    1:     else
    1:         *result = ppolicy->mGet;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CheckLoadURIFromScript(JSContext *cx, nsIURI *aURI)
    1: {
    1:     // Get principal of currently executing script.
    1:     nsresult rv;
    1:     nsIPrincipal* principal = GetSubjectPrincipal(cx, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Native code can load all URIs.
    1:     if (!principal)
    1:         return NS_OK;
    1: 
    1:     rv = CheckLoadURIWithPrincipal(principal, aURI,
    1:                                    nsIScriptSecurityManager::STANDARD);
    1:     if (NS_SUCCEEDED(rv)) {
    1:         // OK to load
    1:         return NS_OK;
    1:     }
    1: 
    1:     // See if we're attempting to load a file: URI. If so, let a
    1:     // UniversalFileRead capability trump the above check.
    1:     PRBool isFile = PR_FALSE;
    1:     PRBool isRes = PR_FALSE;
    1:     if (NS_FAILED(aURI->SchemeIs("file", &isFile)) ||
    1:         NS_FAILED(aURI->SchemeIs("resource", &isRes)))
    1:         return NS_ERROR_FAILURE;
    1:     if (isFile || isRes)
    1:     {
    1:         PRBool enabled;
    1:         if (NS_FAILED(IsCapabilityEnabled("UniversalFileRead", &enabled)))
    1:             return NS_ERROR_FAILURE;
    1:         if (enabled)
    1:             return NS_OK;
    1:     }
    1: 
    1:     // Report error.
    1:     nsCAutoString spec;
    1:     if (NS_FAILED(aURI->GetAsciiSpec(spec)))
    1:         return NS_ERROR_FAILURE;
28616:     nsCAutoString msg("Access to '");
28616:     msg.Append(spec);
28616:     msg.AppendLiteral("' from script denied");
28616:     SetPendingException(cx, msg.get());
13172:     return NS_ERROR_DOM_BAD_URI;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CheckLoadURI(nsIURI *aSourceURI, nsIURI *aTargetURI,
    1:                                       PRUint32 aFlags)
    1: {
    1:     // FIXME: bug 327244 -- this function should really die...  Really truly.
    1:     NS_PRECONDITION(aSourceURI, "CheckLoadURI called with null source URI");
    1:     NS_ENSURE_ARG_POINTER(aSourceURI);
    1: 
    1:     // Note: this is not _quite_ right if aSourceURI has
    1:     // NS_NULLPRINCIPAL_SCHEME, but we'll just extract the scheme in
    1:     // CheckLoadURIWithPrincipal anyway, so this is good enough.  This method
    1:     // really needs to go away....
    1:     nsCOMPtr<nsIPrincipal> sourcePrincipal;
    1:     nsresult rv = CreateCodebasePrincipal(aSourceURI,
    1:                                           getter_AddRefs(sourcePrincipal));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     return CheckLoadURIWithPrincipal(sourcePrincipal, aTargetURI, aFlags);
    1: }
    1: 
    1: /**
    1:  * Helper method to handle cases where a flag passed to
    1:  * CheckLoadURIWithPrincipal means denying loading if the given URI has certain
    1:  * nsIProtocolHandler flags set.
    1:  * @return if success, access is allowed. Otherwise, deny access
    1:  */
    1: static nsresult
    1: DenyAccessIfURIHasFlags(nsIURI* aURI, PRUint32 aURIFlags)
    1: {
    1:     NS_PRECONDITION(aURI, "Must have URI!");
    1:     
    1:     PRBool uriHasFlags;
    1:     nsresult rv =
    1:         NS_URIChainHasFlags(aURI, aURIFlags, &uriHasFlags);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (uriHasFlags) {
    1:         return NS_ERROR_DOM_BAD_URI;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CheckLoadURIWithPrincipal(nsIPrincipal* aPrincipal,
    1:                                                    nsIURI *aTargetURI,
    1:                                                    PRUint32 aFlags)
    1: {
    1:     NS_PRECONDITION(aPrincipal, "CheckLoadURIWithPrincipal must have a principal");
    1:     // If someone passes a flag that we don't understand, we should
    1:     // fail, because they may need a security check that we don't
    1:     // provide.
    1:     NS_ENSURE_FALSE(aFlags & ~(nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT |
    1:                                nsIScriptSecurityManager::ALLOW_CHROME |
    1:                                nsIScriptSecurityManager::DISALLOW_SCRIPT |
    1:                                nsIScriptSecurityManager::DISALLOW_INHERIT_PRINCIPAL),
    1:                     NS_ERROR_UNEXPECTED);
    1:     NS_ENSURE_ARG_POINTER(aPrincipal);
23241:     NS_ENSURE_ARG_POINTER(aTargetURI);
    1: 
    1:     if (aPrincipal == mSystemPrincipal) {
    1:         // Allow access
    1:         return NS_OK;
    1:     }
    1:     
    1:     nsCOMPtr<nsIURI> sourceURI;
    1:     aPrincipal->GetURI(getter_AddRefs(sourceURI));
 4337:     if (!sourceURI) {
 4337:         NS_ERROR("Non-system principals passed to CheckLoadURIWithPrincipal "
 4337:                  "must have a URI!");
 4337:         return NS_ERROR_UNEXPECTED;
 4337:     }
    1:     
    1:     // Automatic loads are not allowed from certain protocols.
    1:     if (aFlags & nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT) {
    1:         nsresult rv =
    1:             DenyAccessIfURIHasFlags(sourceURI,
    1:                                     nsIProtocolHandler::URI_FORBIDS_AUTOMATIC_DOCUMENT_REPLACEMENT);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     // If DISALLOW_INHERIT_PRINCIPAL is set, we prevent loading of URIs which
    1:     // would do such inheriting.  That would be URIs that do not have their own
    1:     // security context.
    1:     if (aFlags & nsIScriptSecurityManager::DISALLOW_INHERIT_PRINCIPAL) {
    1:         nsresult rv =
    1:             DenyAccessIfURIHasFlags(aTargetURI,
    1:                                     nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     // If either URI is a nested URI, get the base URI
    1:     nsCOMPtr<nsIURI> sourceBaseURI = NS_GetInnermostURI(sourceURI);
    1:     nsCOMPtr<nsIURI> targetBaseURI = NS_GetInnermostURI(aTargetURI);
    1: 
    1:     //-- get the target scheme
    1:     nsCAutoString targetScheme;
    1:     nsresult rv = targetBaseURI->GetScheme(targetScheme);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     //-- Some callers do not allow loading javascript:
    1:     if ((aFlags & nsIScriptSecurityManager::DISALLOW_SCRIPT) &&
    1:          targetScheme.EqualsLiteral("javascript"))
    1:     {
    1:        return NS_ERROR_DOM_BAD_URI;
    1:     }
    1: 
    1:     //-- get the source scheme
    1:     nsCAutoString sourceScheme;
    1:     rv = sourceBaseURI->GetScheme(sourceScheme);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
13653:     if (sourceScheme.LowerCaseEqualsLiteral(NS_NULLPRINCIPAL_SCHEME)) {
13653:         // A null principal can target its own URI.
13653:         if (sourceURI == aTargetURI) {
13653:             return NS_OK;
13653:         }
13653:     }
13653:     else if (targetScheme.Equals(sourceScheme,
13653:                                  nsCaseInsensitiveCStringComparator()))
    1:     {
    1:         // every scheme can access another URI from the same scheme,
    1:         // as long as they don't represent null principals.
    1:         return NS_OK;
    1:     }
    1: 
    1:     NS_NAMED_LITERAL_STRING(errorTag, "CheckLoadURIError");
    1:     
    1:     // If the schemes don't match, the policy is specified by the protocol
    1:     // flags on the target URI.  Note that the order of policy checks here is
    1:     // very important!  We start from most restrictive and work our way down.
    1:     // Note that since we're working with the innermost URI, we can just use
    1:     // the methods that work on chains of nested URIs and they will only look
    1:     // at the flags for our one URI.
    1: 
    1:     // Check for system target URI
    1:     rv = DenyAccessIfURIHasFlags(targetBaseURI,
    1:                                  nsIProtocolHandler::URI_DANGEROUS_TO_LOAD);
    1:     if (NS_FAILED(rv)) {
    1:         // Deny access, since the origin principal is not system
    1:         ReportError(nsnull, errorTag, sourceURI, aTargetURI);
    1:         return rv;
    1:     }
    1: 
    1:     // Check for chrome target URI
    1:     PRBool hasFlags;
    1:     rv = NS_URIChainHasFlags(targetBaseURI,
    1:                              nsIProtocolHandler::URI_IS_UI_RESOURCE,
    1:                              &hasFlags);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (hasFlags) {
    1:         if (aFlags & nsIScriptSecurityManager::ALLOW_CHROME) {
14262:             if (!targetScheme.EqualsLiteral("chrome")) {
14262:                 // for now don't change behavior for resource: or moz-icon:
    1:                 return NS_OK;
    1:             }
    1: 
14262:             // allow load only if chrome package is whitelisted
14262:             nsCOMPtr<nsIXULChromeRegistry> reg(do_GetService(
14262:                                                  NS_CHROMEREGISTRY_CONTRACTID));
14262:             if (reg) {
14262:                 PRBool accessAllowed = PR_FALSE;
14262:                 reg->AllowContentToAccess(targetBaseURI, &accessAllowed);
14262:                 if (accessAllowed) {
14262:                     return NS_OK;
14262:                 }
14262:             }
14262:         }
14262: 
    1:         // resource: and chrome: are equivalent, securitywise
    1:         // That's bogus!!  Fix this.  But watch out for
    1:         // the view-source stylesheet?
    1:         PRBool sourceIsChrome;
    1:         rv = NS_URIChainHasFlags(sourceBaseURI,
    1:                                  nsIProtocolHandler::URI_IS_UI_RESOURCE,
    1:                                  &sourceIsChrome);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:         if (sourceIsChrome) {
    1:             return NS_OK;
    1:         }
    1:         ReportError(nsnull, errorTag, sourceURI, aTargetURI);
    1:         return NS_ERROR_DOM_BAD_URI;
    1:     }
    1: 
    1:     // Check for target URI pointing to a file
    1:     rv = NS_URIChainHasFlags(targetBaseURI,
    1:                              nsIProtocolHandler::URI_IS_LOCAL_FILE,
    1:                              &hasFlags);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (hasFlags) {
    1:         // resource: and chrome: are equivalent, securitywise
    1:         // That's bogus!!  Fix this.  But watch out for
    1:         // the view-source stylesheet?
    1:         PRBool sourceIsChrome;
    1:         rv = NS_URIChainHasFlags(sourceURI,
    1:                                  nsIProtocolHandler::URI_IS_UI_RESOURCE,
    1:                                  &sourceIsChrome);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:         if (sourceIsChrome) {
    1:             return NS_OK;
    1:         }
    1: 
    1:         // Now check capability policies
    1:         static const char loadURIPrefGroup[] = "checkloaduri";
    1:         ClassInfoData nameData(nsnull, loadURIPrefGroup);
    1: 
    1:         SecurityLevel secLevel;
    1:         rv = LookupPolicy(aPrincipal, nameData, sEnabledID,
    1:                           nsIXPCSecurityManager::ACCESS_GET_PROPERTY, 
    1:                           nsnull, &secLevel);
    1:         if (NS_SUCCEEDED(rv) && secLevel.level == SCRIPT_SECURITY_ALL_ACCESS)
    1:         {
    1:             // OK for this site!
    1:             return NS_OK;
    1:         }
    1: 
    1:         ReportError(nsnull, errorTag, sourceURI, aTargetURI);
    1:         return NS_ERROR_DOM_BAD_URI;
    1:     }
    1: 
    1:     // OK, everyone is allowed to load this, since unflagged handlers are
    1:     // deprecated but treated as URI_LOADABLE_BY_ANYONE.  But check whether we
    1:     // need to warn.  At some point we'll want to make this warning into an
    1:     // error and treat unflagged handlers as URI_DANGEROUS_TO_LOAD.
    1:     rv = NS_URIChainHasFlags(targetBaseURI,
    1:                              nsIProtocolHandler::URI_LOADABLE_BY_ANYONE,
    1:                              &hasFlags);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (!hasFlags) {
    1:         nsXPIDLString message;
    1:         NS_ConvertASCIItoUTF16 ucsTargetScheme(targetScheme);
    1:         const PRUnichar* formatStrings[] = { ucsTargetScheme.get() };
    1:         rv = sStrBundle->
    1:             FormatStringFromName(NS_LITERAL_STRING("ProtocolFlagError").get(),
    1:                                  formatStrings,
    1:                                  NS_ARRAY_LENGTH(formatStrings),
    1:                                  getter_Copies(message));
    1:         if (NS_SUCCEEDED(rv)) {
    1:             nsCOMPtr<nsIConsoleService> console(
    1:               do_GetService("@mozilla.org/consoleservice;1"));
    1:             NS_ENSURE_TRUE(console, NS_ERROR_FAILURE);
    1: 
    1:             console->LogStringMessage(message.get());
    1: #ifdef DEBUG
    1:             fprintf(stderr, "%s\n", NS_ConvertUTF16toUTF8(message).get());
    1: #endif
    1:         }
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsScriptSecurityManager::ReportError(JSContext* cx, const nsAString& messageTag,
    1:                                      nsIURI* aSource, nsIURI* aTarget)
    1: {
    1:     nsresult rv;
    1:     NS_ENSURE_TRUE(aSource && aTarget, NS_ERROR_NULL_POINTER);
    1: 
    1:     // Get the source URL spec
    1:     nsCAutoString sourceSpec;
    1:     rv = aSource->GetAsciiSpec(sourceSpec);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Get the target URL spec
    1:     nsCAutoString targetSpec;
    1:     rv = aTarget->GetAsciiSpec(targetSpec);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Localize the error message
    1:     nsXPIDLString message;
    1:     NS_ConvertASCIItoUTF16 ucsSourceSpec(sourceSpec);
    1:     NS_ConvertASCIItoUTF16 ucsTargetSpec(targetSpec);
    1:     const PRUnichar *formatStrings[] = { ucsSourceSpec.get(), ucsTargetSpec.get() };
    1:     rv = sStrBundle->FormatStringFromName(PromiseFlatString(messageTag).get(),
    1:                                           formatStrings,
    1:                                           NS_ARRAY_LENGTH(formatStrings),
    1:                                           getter_Copies(message));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // If a JS context was passed in, set a JS exception.
    1:     // Otherwise, print the error message directly to the JS console
    1:     // and to standard output
    1:     if (cx)
    1:     {
    1:         SetPendingException(cx, message.get());
    1:     }
    1:     else // Print directly to the console
    1:     {
    1:         nsCOMPtr<nsIConsoleService> console(
    1:             do_GetService("@mozilla.org/consoleservice;1"));
    1:         NS_ENSURE_TRUE(console, NS_ERROR_FAILURE);
    1: 
    1:         console->LogStringMessage(message.get());
    1: #ifdef DEBUG
    1:         fprintf(stderr, "%s\n", NS_LossyConvertUTF16toASCII(message).get());
    1: #endif
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CheckLoadURIStr(const nsACString& aSourceURIStr,
    1:                                          const nsACString& aTargetURIStr,
    1:                                          PRUint32 aFlags)
    1: {
    1:     // FIXME: bug 327244 -- this function should really die...  Really truly.
    1:     nsCOMPtr<nsIURI> source;
    1:     nsresult rv = NS_NewURI(getter_AddRefs(source), aSourceURIStr,
    1:                             nsnull, nsnull, sIOService);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Note: this is not _quite_ right if aSourceURI has
    1:     // NS_NULLPRINCIPAL_SCHEME, but we'll just extract the scheme in
    1:     // CheckLoadURIWithPrincipal anyway, so this is good enough.  This method
    1:     // really needs to go away....
    1:     nsCOMPtr<nsIPrincipal> sourcePrincipal;
    1:     rv = CreateCodebasePrincipal(source,
    1:                                  getter_AddRefs(sourcePrincipal));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     return CheckLoadURIStrWithPrincipal(sourcePrincipal, aTargetURIStr,
    1:                                         aFlags);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CheckLoadURIStrWithPrincipal(nsIPrincipal* aPrincipal,
    1:                                                       const nsACString& aTargetURIStr,
    1:                                                       PRUint32 aFlags)
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIURI> target;
    1:     rv = NS_NewURI(getter_AddRefs(target), aTargetURIStr,
    1:                    nsnull, nsnull, sIOService);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = CheckLoadURIWithPrincipal(aPrincipal, target, aFlags);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Now start testing fixup -- since aTargetURIStr is a string, not
    1:     // an nsIURI, we may well end up fixing it up before loading.
    1:     // Note: This needs to stay in sync with the nsIURIFixup api.
    1:     nsCOMPtr<nsIURIFixup> fixup = do_GetService(NS_URIFIXUP_CONTRACTID);
    1:     if (!fixup) {
    1:         return rv;
    1:     }
    1: 
    1:     PRUint32 flags[] = {
    1:         nsIURIFixup::FIXUP_FLAG_NONE,
    1:         nsIURIFixup::FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP,
    1:         nsIURIFixup::FIXUP_FLAGS_MAKE_ALTERNATE_URI,
    1:         nsIURIFixup::FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP |
    1:         nsIURIFixup::FIXUP_FLAGS_MAKE_ALTERNATE_URI
    1:     };
    1: 
    1:     for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(flags); ++i) {
    1:         rv = fixup->CreateFixupURI(aTargetURIStr, flags[i],
    1:                                    getter_AddRefs(target));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         rv = CheckLoadURIWithPrincipal(aPrincipal, target, aFlags);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CheckFunctionAccess(JSContext *aCx, void *aFunObj,
    1:                                              void *aTargetObj)
    1: {
    1:     // This check is called for event handlers
    1:     nsresult rv;
    1:     nsIPrincipal* subject =
    1:         GetFunctionObjectPrincipal(aCx, (JSObject *)aFunObj, nsnull, &rv);
    1: 
    1:     // If subject is null, get a principal from the function object's scope.
    1:     if (NS_SUCCEEDED(rv) && !subject)
    1:     {
    1: #ifdef DEBUG
    1:         {
13702:             JSFunction *fun =
13702:                 (JSFunction *)caps_GetJSPrivate((JSObject *)aFunObj);
    1:             JSScript *script = JS_GetFunctionScript(aCx, fun);
    1: 
    1:             NS_ASSERTION(!script, "Null principal for non-native function!");
    1:         }
    1: #endif
    1: 
10939:         subject = doGetObjectPrincipal((JSObject*)aFunObj);
    1:     }
    1: 
    1:     if (!subject)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     if (subject == mSystemPrincipal)
    1:         // This is the system principal: just allow access
    1:         return NS_OK;
    1: 
    1:     // Check if the principal the function was compiled under is
    1:     // allowed to execute scripts.
    1: 
    1:     PRBool result;
    1:     rv = CanExecuteScripts(aCx, subject, &result);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     if (!result)
    1:       return NS_ERROR_DOM_SECURITY_ERR;
    1: 
    1:     /*
    1:     ** Get origin of subject and object and compare.
    1:     */
    1:     JSObject* obj = (JSObject*)aTargetObj;
10939:     nsIPrincipal* object = doGetObjectPrincipal(obj);
    1: 
    1:     if (!object)
    1:         return NS_ERROR_FAILURE;        
    1: 
13269:     PRBool subsumes;
13269:     rv = subject->Subsumes(object, &subsumes);
13269:     if (NS_SUCCEEDED(rv) && !subsumes) {
13269:         rv = NS_ERROR_DOM_PROP_ACCESS_DENIED;
13269:     }
13269:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CanExecuteScripts(JSContext* cx,
    1:                                            nsIPrincipal *aPrincipal,
    1:                                            PRBool *result)
    1: {
    1:     *result = PR_FALSE; 
    1: 
    1:     if (aPrincipal == mSystemPrincipal)
    1:     {
    1:         // Even if JavaScript is disabled, we must still execute system scripts
    1:         *result = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     //-- See if the current window allows JS execution
    1:     nsIScriptContext *scriptContext = GetScriptContext(cx);
    1:     if (!scriptContext) return NS_ERROR_FAILURE;
    1: 
    1:     if (!scriptContext->GetScriptsEnabled()) {
    1:         // No scripting on this context, folks
    1:         *result = PR_FALSE;
    1:         return NS_OK;
    1:     }
    1:     
    1:     nsIScriptGlobalObject *sgo = scriptContext->GetGlobalObject();
    1: 
    1:     if (!sgo) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // window can be null here if we're running with a non-DOM window
    1:     // as the script global (i.e. a XUL prototype document).
    1:     nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(sgo);
    1:     nsCOMPtr<nsIDocShell> docshell;
    1:     nsresult rv;
    1: 
    1:     if (window) {
    1:         docshell = window->GetDocShell();
    1:     }
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> globalObjTreeItem =
    1:         do_QueryInterface(docshell);
    1: 
    1:     if (globalObjTreeItem) 
    1:     {
    1:         nsCOMPtr<nsIDocShellTreeItem> treeItem(globalObjTreeItem);
    1:         nsCOMPtr<nsIDocShellTreeItem> parentItem;
    1: 
    1:         // Walk up the docshell tree to see if any containing docshell disallows scripts
    1:         do
    1:         {
    1:             rv = docshell->GetAllowJavascript(result);
    1:             if (NS_FAILED(rv)) return rv;
    1:             if (!*result)
    1:                 return NS_OK; // Do not run scripts
    1:             treeItem->GetParent(getter_AddRefs(parentItem));
    1:             treeItem.swap(parentItem);
    1:             docshell = do_QueryInterface(treeItem);
    1: #ifdef DEBUG
    1:             if (treeItem && !docshell) {
    1:               NS_ERROR("cannot get a docshell from a treeItem!");
    1:             }
    1: #endif // DEBUG
    1:         } while (treeItem && docshell);
    1:     }
    1: 
    1:     // OK, the docshell doesn't have script execution explicitly disabled.
    1:     // Check whether our URI is an "about:" URI that allows scripts.  If it is,
    1:     // we need to allow JS to run.  In this case, don't apply the JS enabled
    1:     // pref or policies.  On failures, just press on and don't do this special
    1:     // case.
    1:     nsCOMPtr<nsIURI> principalURI;
    1:     aPrincipal->GetURI(getter_AddRefs(principalURI));
 4337:     if (!principalURI) {
 4337:         // Broken principal of some sort.  Disallow.
 4337:         *result = PR_FALSE;
 4337:         return NS_ERROR_UNEXPECTED;
 4337:     }
 4337:         
    1:     PRBool isAbout;
    1:     rv = principalURI->SchemeIs("about", &isAbout);
    1:     if (NS_SUCCEEDED(rv) && isAbout) {
    1:         nsCOMPtr<nsIAboutModule> module;
    1:         rv = NS_GetAboutModule(principalURI, getter_AddRefs(module));
    1:         if (NS_SUCCEEDED(rv)) {
    1:             PRUint32 flags;
    1:             rv = module->GetURIFlags(principalURI, &flags);
    1:             if (NS_SUCCEEDED(rv) &&
    1:                 (flags & nsIAboutModule::ALLOW_SCRIPT)) {
    1:                 *result = PR_TRUE;
    1:                 return NS_OK;              
    1:             }
    1:         }
    1:     }
    1: 
    1:     *result = mIsJavaScriptEnabled;
    1:     if (!*result)
    1:         return NS_OK; // Do not run scripts
    1: 
    1:     //-- Check for a per-site policy
    1:     static const char jsPrefGroupName[] = "javascript";
    1:     ClassInfoData nameData(nsnull, jsPrefGroupName);
    1: 
    1:     SecurityLevel secLevel;
    1:     rv = LookupPolicy(aPrincipal, nameData, sEnabledID,
    1:                       nsIXPCSecurityManager::ACCESS_GET_PROPERTY, 
    1:                       nsnull, &secLevel);
    1:     if (NS_FAILED(rv) || secLevel.level == SCRIPT_SECURITY_NO_ACCESS)
    1:     {
    1:         *result = PR_FALSE;
    1:         return rv;
    1:     }
    1: 
    1:     //-- Nobody vetoed, so allow the JS to run.
    1:     *result = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: ///////////////// Principals ///////////////////////
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::GetSubjectPrincipal(nsIPrincipal **aSubjectPrincipal)
    1: {
    1:     nsresult rv;
    1:     *aSubjectPrincipal = doGetSubjectPrincipal(&rv);
    1:     if (NS_SUCCEEDED(rv))
    1:         NS_IF_ADDREF(*aSubjectPrincipal);
    1:     return rv;
    1: }
    1: 
    1: nsIPrincipal*
    1: nsScriptSecurityManager::doGetSubjectPrincipal(nsresult* rv)
    1: {
    1:     NS_PRECONDITION(rv, "Null out param");
    1:     JSContext *cx = GetCurrentJSContext();
    1:     if (!cx)
    1:     {
    1:         *rv = NS_OK;
    1:         return nsnull;
    1:     }
    1:     return GetSubjectPrincipal(cx, rv);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::GetSystemPrincipal(nsIPrincipal **result)
    1: {
    1:     NS_ADDREF(*result = mSystemPrincipal);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::SubjectPrincipalIsSystem(PRBool* aIsSystem)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aIsSystem);
    1:     *aIsSystem = PR_FALSE;
    1: 
    1:     if (!mSystemPrincipal)
    1:         return NS_OK;
    1: 
    1:     nsCOMPtr<nsIPrincipal> subject;
    1:     nsresult rv = GetSubjectPrincipal(getter_AddRefs(subject));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if(!subject)
    1:     {
    1:         // No subject principal means no JS is running;
    1:         // this is the equivalent of system principal code
    1:         *aIsSystem = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     return mSystemPrincipal->Equals(subject, aIsSystem);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::GetCertificatePrincipal(const nsACString& aCertFingerprint,
    1:                                                  const nsACString& aSubjectName,
    1:                                                  const nsACString& aPrettyName,
    1:                                                  nsISupports* aCertificate,
    1:                                                  nsIURI* aURI,
    1:                                                  nsIPrincipal **result)
    1: {
    1:     *result = nsnull;
    1:     
    1:     NS_ENSURE_ARG(!aCertFingerprint.IsEmpty() &&
    1:                   !aSubjectName.IsEmpty() &&
    1:                   aCertificate);
    1: 
    1:     return DoGetCertificatePrincipal(aCertFingerprint, aSubjectName,
    1:                                      aPrettyName, aCertificate, aURI, PR_TRUE,
    1:                                      result);
    1: }
    1: 
    1: nsresult
    1: nsScriptSecurityManager::DoGetCertificatePrincipal(const nsACString& aCertFingerprint,
    1:                                                    const nsACString& aSubjectName,
    1:                                                    const nsACString& aPrettyName,
    1:                                                    nsISupports* aCertificate,
    1:                                                    nsIURI* aURI,
    1:                                                    PRBool aModifyTable,
    1:                                                    nsIPrincipal **result)
    1: {
    1:     NS_ENSURE_ARG(!aCertFingerprint.IsEmpty());
    1:     
    1:     // Create a certificate principal out of the certificate ID
    1:     // and URI given to us.  We will use this principal to test
    1:     // equality when doing our hashtable lookups below.
    1:     nsRefPtr<nsPrincipal> certificate = new nsPrincipal();
    1:     if (!certificate)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     nsresult rv = certificate->Init(aCertFingerprint, aSubjectName,
    1:                                     aPrettyName, aCertificate, aURI);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Check to see if we already have this principal.
    1:     nsCOMPtr<nsIPrincipal> fromTable;
    1:     mPrincipals.Get(certificate, getter_AddRefs(fromTable));
    1:     if (fromTable) {
    1:         // Bingo.  We found the certificate in the table, which means
    1:         // that it has escalated privileges.
    1: 
    1:         if (aModifyTable) {
    1:             // Make sure this principal has names, so if we ever go to save it
    1:             // we'll save them.  If we get a name mismatch here we'll throw,
    1:             // but that's desirable.
 3233:             rv = static_cast<nsPrincipal*>
 3233:                             (static_cast<nsIPrincipal*>(fromTable))
    1:                 ->EnsureCertData(aSubjectName, aPrettyName, aCertificate);
    1:             if (NS_FAILED(rv)) {
    1:                 // We have a subject name mismatch for the same cert id.
    1:                 // Hand back the |certificate| object we created and don't give
    1:                 // it any rights from the table.
    1:                 NS_ADDREF(*result = certificate);
    1:                 return NS_OK;
    1:             }                
    1:         }
    1:         
    1:         if (!aURI) {
    1:             // We were asked to just get the base certificate, so output
    1:             // what we have in the table.
 3233:             certificate = static_cast<nsPrincipal*>
 3233:                                      (static_cast<nsIPrincipal*>
 3233:                                                  (fromTable));
    1:         } else {
    1:             // We found a certificate and now need to install a codebase
    1:             // on it.  We don't want to modify the principal in the hash
    1:             // table, so create a new principal and clone the pertinent
    1:             // things.
    1:             nsXPIDLCString prefName;
    1:             nsXPIDLCString id;
    1:             nsXPIDLCString subjectName;
    1:             nsXPIDLCString granted;
    1:             nsXPIDLCString denied;
    1:             PRBool isTrusted;
    1:             rv = fromTable->GetPreferences(getter_Copies(prefName),
    1:                                            getter_Copies(id),
    1:                                            getter_Copies(subjectName),
    1:                                            getter_Copies(granted),
    1:                                            getter_Copies(denied),
    1:                                            &isTrusted);
    1:             // XXXbz assert something about subjectName and aSubjectName here?
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 NS_ASSERTION(!isTrusted, "Shouldn't have isTrusted true here");
    1:                 
    1:                 certificate = new nsPrincipal();
    1:                 if (!certificate)
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:                 rv = certificate->InitFromPersistent(prefName, id,
    1:                                                      subjectName, aPrettyName,
    1:                                                      granted, denied,
    1:                                                      aCertificate,
    1:                                                      PR_TRUE, PR_FALSE);
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1:                 
    1:                 certificate->SetURI(aURI);
    1:             }
    1:         }
    1:     }
    1: 
    1:     NS_ADDREF(*result = certificate);
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsScriptSecurityManager::CreateCodebasePrincipal(nsIURI* aURI, nsIPrincipal **result)
    1: {
    1:     // I _think_ it's safe to not create null principals here based on aURI.
    1:     // At least all the callers would do the right thing in those cases, as far
    1:     // as I can tell.  --bz
    1:     nsRefPtr<nsPrincipal> codebase = new nsPrincipal();
    1:     if (!codebase)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     nsresult rv = codebase->Init(EmptyCString(), EmptyCString(),
    1:                                  EmptyCString(), nsnull, aURI);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     NS_ADDREF(*result = codebase);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::GetCodebasePrincipal(nsIURI *aURI,
    1:                                               nsIPrincipal **result)
    1: {
 4337:     NS_ENSURE_ARG(aURI);
 4337:     
    1:     PRBool inheritsPrincipal;
    1:     nsresult rv =
    1:         NS_URIChainHasFlags(aURI,
    1:                             nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT,
    1:                             &inheritsPrincipal);
    1:     if (NS_FAILED(rv) || inheritsPrincipal) {
    1:         return CallCreateInstance(NS_NULLPRINCIPAL_CONTRACTID, result);
    1:     }
    1:     
    1:     nsCOMPtr<nsIPrincipal> principal;
    1:     rv = CreateCodebasePrincipal(aURI, getter_AddRefs(principal));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     if (mPrincipals.Count() > 0)
    1:     {
    1:         //-- Check to see if we already have this principal.
    1:         nsCOMPtr<nsIPrincipal> fromTable;
    1:         mPrincipals.Get(principal, getter_AddRefs(fromTable));
    1:         if (fromTable) {
    1:             // We found an existing codebase principal.  But it might have a
    1:             // generic codebase for this origin on it.  Install our particular
    1:             // codebase.
    1:             // XXXbz this is kinda similar to the code in
    1:             // GetCertificatePrincipal, but just ever so slightly different.
    1:             // Oh, well.
    1:             nsXPIDLCString prefName;
    1:             nsXPIDLCString id;
    1:             nsXPIDLCString subjectName;
    1:             nsXPIDLCString granted;
    1:             nsXPIDLCString denied;
    1:             PRBool isTrusted;
    1:             rv = fromTable->GetPreferences(getter_Copies(prefName),
    1:                                            getter_Copies(id),
    1:                                            getter_Copies(subjectName),
    1:                                            getter_Copies(granted),
    1:                                            getter_Copies(denied),
    1:                                            &isTrusted);
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 nsRefPtr<nsPrincipal> codebase = new nsPrincipal();
    1:                 if (!codebase)
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:                 rv = codebase->InitFromPersistent(prefName, id,
    1:                                                   subjectName, EmptyCString(),
    1:                                                   granted, denied,
    1:                                                   nsnull, PR_FALSE,
    1:                                                   isTrusted);
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1:                 
    1:                 codebase->SetURI(aURI);
    1:                 principal = codebase;
    1:             }
    1: 
    1:         }
    1:     }
    1: 
    1:     NS_IF_ADDREF(*result = principal);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::GetPrincipalFromContext(JSContext *cx,
    1:                                                  nsIPrincipal **result)
    1: {
    1:     *result = nsnull;
    1: 
    1:     nsIScriptContext *scriptContext = GetScriptContext(cx);
    1: 
    1:     if (!scriptContext)
    1:     {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     nsCOMPtr<nsIScriptObjectPrincipal> globalData =
    1:         do_QueryInterface(scriptContext->GetGlobalObject());
    1:     if (globalData)
    1:         NS_IF_ADDREF(*result = globalData->GetPrincipal());
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: // static
    1: nsIPrincipal*
    1: nsScriptSecurityManager::GetScriptPrincipal(JSContext *cx,
    1:                                             JSScript *script,
    1:                                             nsresult* rv)
    1: {
    1:     NS_PRECONDITION(rv, "Null out param");
    1:     *rv = NS_OK;
    1:     if (!script)
    1:     {
    1:         return nsnull;
    1:     }
    1:     JSPrincipals *jsp = JS_GetScriptPrincipals(cx, script);
    1:     if (!jsp) {
    1:         *rv = NS_ERROR_FAILURE;
18821:         NS_ERROR("Script compiled without principals!");
    1:         return nsnull;
    1:     }
 3233:     nsJSPrincipals *nsJSPrin = static_cast<nsJSPrincipals *>(jsp);
    1:     nsIPrincipal* result = nsJSPrin->nsIPrincipalPtr;
    1:     if (!result)
    1:         *rv = NS_ERROR_FAILURE;
    1:     return result;
    1: }
    1: 
    1: // static
    1: nsIPrincipal*
    1: nsScriptSecurityManager::GetFunctionObjectPrincipal(JSContext *cx,
    1:                                                     JSObject *obj,
    1:                                                     JSStackFrame *fp,
    1:                                                     nsresult *rv)
    1: {
    1:     NS_PRECONDITION(rv, "Null out param");
29162:     if (!JS_ObjectIsFunction(cx, obj))
29162:     {
29162:         // Protect against pseudo-functions (like SJOWs).
29162:         nsIPrincipal *result = doGetObjectPrincipal(obj);
29162:         if (!result)
29162:             *rv = NS_ERROR_FAILURE;
29162:         return result;
29162:     }
29162: 
13702:     JSFunction *fun = (JSFunction *) caps_GetJSPrivate(obj);
    1:     JSScript *script = JS_GetFunctionScript(cx, fun);
    1: 
    1:     *rv = NS_OK;
    1: 
    1:     if (!script)
    1:     {
    1:         // A native function: skip it in order to find its scripted caller.
    1:         return nsnull;
    1:     }
    1: 
    1:     JSScript *frameScript = fp ? JS_GetFrameScript(cx, fp) : nsnull;
    1: 
    1:     if (frameScript && frameScript != script)
    1:     {
    1:         // There is a frame script, and it's different from the
    1:         // function script. In this case we're dealing with either
    1:         // an eval or a Script object, and in these cases the
    1:         // principal we want is in the frame's script, not in the
    1:         // function's script. The function's script is where the
    1:         // eval-calling code came from, not where the eval or new
    1:         // Script object came from, and we want the principal of
    1:         // the eval function object or new Script object.
    1: 
13691:         script = frameScript;
13691:     }
13691:     else if (JS_GetFunctionObject(fun) != obj)
13691:     {
13691:         // Here, obj is a cloned function object.  In this case, the
13691:         // clone's prototype may have been precompiled from brutally
13691:         // shared chrome, or else it is a lambda or nested function.
13691:         // The general case here is a function compiled against a
13691:         // different scope than the one it is parented by at runtime,
13691:         // hence the creation of a clone to carry the correct scope
13691:         // chain linkage.
13691:         //
    1:         // Since principals follow scope, we must get the object
13691:         // principal from the clone's scope chain. There are no
    1:         // reliable principals compiled into the function itself.
    1: 
10939:         nsIPrincipal *result = doGetObjectPrincipal(obj);
    1:         if (!result)
    1:             *rv = NS_ERROR_FAILURE;
    1:         return result;
    1:     }
    1: 
13691:     return GetScriptPrincipal(cx, script, rv);
13691: }
13691: 
    1: // static
    1: nsIPrincipal*
    1: nsScriptSecurityManager::GetFramePrincipal(JSContext *cx,
    1:                                            JSStackFrame *fp,
    1:                                            nsresult *rv)
    1: {
    1:     NS_PRECONDITION(rv, "Null out param");
    1:     JSObject *obj = JS_GetFrameFunctionObject(cx, fp);
    1:     if (!obj)
    1:     {
    1:         // Must be in a top-level script. Get principal from the script.
    1:         JSScript *script = JS_GetFrameScript(cx, fp);
    1:         return GetScriptPrincipal(cx, script, rv);
    1:     }
    1: 
    1:     nsIPrincipal* result = GetFunctionObjectPrincipal(cx, obj, fp, rv);
    1: 
    1: #ifdef DEBUG
    1:     if (NS_SUCCEEDED(*rv) && !result)
    1:     {
13702:         JSFunction *fun = (JSFunction *)caps_GetJSPrivate(obj);
    1:         JSScript *script = JS_GetFunctionScript(cx, fun);
    1: 
    1:         NS_ASSERTION(!script, "Null principal for non-native function!");
    1:     }
    1: #endif
    1: 
    1:     return result;
    1: }
    1: 
    1: // static
    1: nsIPrincipal*
    1: nsScriptSecurityManager::GetPrincipalAndFrame(JSContext *cx,
    1:                                               JSStackFrame **frameResult,
    1:                                               nsresult* rv)
    1: {
    1:     NS_PRECONDITION(rv, "Null out param");    
    1:     //-- If there's no principal on the stack, look at the global object
    1:     //   and return the innermost frame for annotations.
    1:     *rv = NS_OK;
    1:     if (cx)
    1:     {
    1:         // Get principals from innermost frame of JavaScript or Java.
    1:         JSStackFrame *fp = nsnull; // tell JS_FrameIterator to start at innermost
    1:         for (fp = JS_FrameIterator(cx, &fp); fp; fp = JS_FrameIterator(cx, &fp))
    1:         {
    1:             nsIPrincipal* result = GetFramePrincipal(cx, fp, rv);
    1:             if (result)
    1:             {
    1:                 NS_ASSERTION(NS_SUCCEEDED(*rv), "Weird return");
    1:                 *frameResult = fp;
    1:                 return result;
    1:             }
    1:         }
    1: 
    1:         nsIScriptContext *scriptContext = GetScriptContext(cx);
    1:         if (scriptContext)
    1:         {
    1:             nsCOMPtr<nsIScriptObjectPrincipal> globalData =
    1:                 do_QueryInterface(scriptContext->GetGlobalObject());
    1:             if (!globalData)
    1:             {
    1:                 *rv = NS_ERROR_FAILURE;
    1:                 return nsnull;
    1:             }
    1: 
    1:             // Note that we're not in a loop or anything, and nothing comes
    1:             // after this point in the function, so we can just return here.
    1:             nsIPrincipal* result = globalData->GetPrincipal();
    1:             if (result)
    1:             {
    1:                 JSStackFrame *inner = nsnull;
    1:                 *frameResult = JS_FrameIterator(cx, &inner);
    1:                 return result;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return nsnull;
    1: }
    1: 
    1: // static
    1: nsIPrincipal*
    1: nsScriptSecurityManager::GetSubjectPrincipal(JSContext *cx,
    1:                                              nsresult* rv)
    1: {
    1:     NS_PRECONDITION(rv, "Null out param");
    1:     JSStackFrame *fp;
    1:     return GetPrincipalAndFrame(cx, &fp, rv);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::GetObjectPrincipal(JSContext *aCx, JSObject *aObj,
    1:                                             nsIPrincipal **result)
    1: {
10939:     *result = doGetObjectPrincipal(aObj);
    1:     if (!*result)
    1:         return NS_ERROR_FAILURE;
    1:     NS_ADDREF(*result);
    1:     return NS_OK;
    1: }
    1: 
    1: // static
    1: nsIPrincipal*
10939: nsScriptSecurityManager::doGetObjectPrincipal(JSObject *aObj
 8990: #ifdef DEBUG
 8990:                                               , PRBool aAllowShortCircuit
 8990: #endif
 8990:                                               )
    1: {
10942:     NS_ASSERTION(aObj, "Bad call to doGetObjectPrincipal()!");
    1:     nsIPrincipal* result = nsnull;
    1: 
    1: #ifdef DEBUG
    1:     JSObject* origObj = aObj;
    1: #endif
    1:     
10939:     const JSClass *jsClass = STOBJ_GET_CLASS(aObj);
 8990: 
 8990:     // A common case seen in this code is that we enter this function
 8990:     // with aObj being a Function object, whose parent is a Call
 8990:     // object. Neither of those have object principals, so we can skip
 8990:     // those objects here before we enter the below loop. That way we
 8990:     // avoid wasting time checking properties of their classes etc in
 8990:     // the loop.
 8990: 
 8990:     if (jsClass == &js_FunctionClass) {
10939:         aObj = STOBJ_GET_PARENT(aObj);
 8990: 
 8990:         if (!aObj)
 8990:             return nsnull;
 8990: 
10939:         jsClass = STOBJ_GET_CLASS(aObj);
 8990: 
 8990:         if (jsClass == &js_CallClass) {
10939:             aObj = STOBJ_GET_PARENT(aObj);
 8990: 
 8990:             if (!aObj)
 8990:                 return nsnull;
 8990: 
10939:             jsClass = STOBJ_GET_CLASS(aObj);
 8990:         }
 8990:     }
 8990: 
 8990:     do {
 8990:         // Note: jsClass is set before this loop, and also at the
 8990:         // *end* of this loop.
 8990: 
 8990:         // NOTE: These class and getObjectOps hook checks better match
 8990:         // what IS_WRAPPER_CLASS() does in xpconnect!
 8990:         if (jsClass == sXPCWrappedNativeJSClass ||
 8990:             jsClass->getObjectOps == sXPCWrappedNativeGetObjOps1 ||
 8990:             jsClass->getObjectOps == sXPCWrappedNativeGetObjOps2) {
 8990:             nsIXPConnectWrappedNative *xpcWrapper =
10939:                 (nsIXPConnectWrappedNative *)caps_GetJSPrivate(aObj);
 8990: 
 8990:             if (xpcWrapper) {
 8990: #ifdef DEBUG
10834:                 if (aAllowShortCircuit) {
 8990: #endif
10834:                     result = xpcWrapper->GetObjectPrincipal();
10834: 
10834:                     if (result) {
 8990:                         break;
 8990:                     }
10834: #ifdef DEBUG
10834:                 }
10834: #endif
 8990: 
 8990:                 // If not, check if it points to an
 8990:                 // nsIScriptObjectPrincipal
 8990:                 nsCOMPtr<nsIScriptObjectPrincipal> objPrin =
10834:                     do_QueryWrappedNative(xpcWrapper);
 8990:                 if (objPrin) {
 8990:                     result = objPrin->GetPrincipal();
 8990: 
 8990:                     if (result) {
 8990:                         break;
 8990:                     }
 8990:                 }
 8990:             }
 8990:         } else if (!(~jsClass->flags & (JSCLASS_HAS_PRIVATE |
 8990:                                         JSCLASS_PRIVATE_IS_NSISUPPORTS))) {
10939:             nsISupports *priv = (nsISupports *)caps_GetJSPrivate(aObj);
    1: 
 8990: #ifdef DEBUG
 8990:             if (aAllowShortCircuit) {
    1:                 nsCOMPtr<nsIXPConnectWrappedNative> xpcWrapper =
    1:                     do_QueryInterface(priv);
    1: 
 9603:                 NS_ASSERTION(!xpcWrapper ||
 9603:                              !strcmp(jsClass->name, "XPCNativeWrapper"),
 8990:                              "Uh, an nsIXPConnectWrappedNative with the "
 8990:                              "wrong JSClass or getObjectOps hooks!");
 8990:             }
 8990: #endif
 8990: 
 8990:             nsCOMPtr<nsIScriptObjectPrincipal> objPrin =
 8990:                 do_QueryInterface(priv);
 8990: 
 8990:             if (objPrin) {
    1:                 result = objPrin->GetPrincipal();
 8990: 
 8990:                 if (result) {
    1:                     break;
    1:                 }
    1:             }
 8990:         }
    1: 
10939:         aObj = STOBJ_GET_PARENT(aObj);
 8990: 
 8990:         if (!aObj)
 8990:             break;
 8990: 
10939:         jsClass = STOBJ_GET_CLASS(aObj);
 8990:     } while (1);
    1: 
    1:     NS_ASSERTION(!aAllowShortCircuit ||
10939:                  result == doGetObjectPrincipal(origObj, PR_FALSE),
    1:                  "Principal mismatch.  Not good");
    1:     
    1:     return result;
    1: }
    1: 
    1: nsresult
    1: nsScriptSecurityManager::SavePrincipal(nsIPrincipal* aToSave)
    1: {
    1:     //-- Save to mPrincipals
    1:     mPrincipals.Put(aToSave, aToSave);
    1: 
    1:     //-- Save to prefs
    1:     nsXPIDLCString idPrefName;
    1:     nsXPIDLCString id;
    1:     nsXPIDLCString subjectName;
    1:     nsXPIDLCString grantedList;
    1:     nsXPIDLCString deniedList;
    1:     PRBool isTrusted;
    1:     nsresult rv = aToSave->GetPreferences(getter_Copies(idPrefName),
    1:                                           getter_Copies(id),
    1:                                           getter_Copies(subjectName),
    1:                                           getter_Copies(grantedList),
    1:                                           getter_Copies(deniedList),
    1:                                           &isTrusted);
    1:     if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
    1: 
    1:     nsCAutoString grantedPrefName;
    1:     nsCAutoString deniedPrefName;
    1:     nsCAutoString subjectNamePrefName;
    1:     rv = GetPrincipalPrefNames( idPrefName,
    1:                                 grantedPrefName,
    1:                                 deniedPrefName,
    1:                                 subjectNamePrefName );
    1:     if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
    1: 
    1:     mIsWritingPrefs = PR_TRUE;
    1:     if (grantedList)
    1:         mSecurityPref->SecuritySetCharPref(grantedPrefName.get(), grantedList);
    1:     else
    1:         mSecurityPref->SecurityClearUserPref(grantedPrefName.get());
    1: 
    1:     if (deniedList)
    1:         mSecurityPref->SecuritySetCharPref(deniedPrefName.get(), deniedList);
    1:     else
    1:         mSecurityPref->SecurityClearUserPref(deniedPrefName.get());
    1: 
    1:     if (grantedList || deniedList) {
    1:         mSecurityPref->SecuritySetCharPref(idPrefName, id);
    1:         mSecurityPref->SecuritySetCharPref(subjectNamePrefName.get(),
    1:                                            subjectName);
    1:     }
    1:     else {
    1:         mSecurityPref->SecurityClearUserPref(idPrefName);
    1:         mSecurityPref->SecurityClearUserPref(subjectNamePrefName.get());
    1:     }
    1: 
    1:     mIsWritingPrefs = PR_FALSE;
    1: 
    1:     nsCOMPtr<nsIPrefService> prefService(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     return prefService->SavePrefFile(nsnull);
    1: }
    1: 
    1: ///////////////// Capabilities API /////////////////////
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::IsCapabilityEnabled(const char *capability,
    1:                                              PRBool *result)
    1: {
    1:     nsresult rv;
    1:     JSStackFrame *fp = nsnull;
    1:     JSContext *cx = GetCurrentJSContext();
    1:     fp = cx ? JS_FrameIterator(cx, &fp) : nsnull;
    1:     if (!fp)
    1:     {
    1:         // No script code on stack. Allow execution.
    1:         *result = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1:     *result = PR_FALSE;
    1:     nsIPrincipal* previousPrincipal = nsnull;
    1:     do
    1:     {
    1:         nsIPrincipal* principal = GetFramePrincipal(cx, fp, &rv);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:         if (!principal)
    1:             continue;
    1:         // If caller has a different principal, stop looking up the stack.
    1:         if(previousPrincipal)
    1:         {
    1:             PRBool isEqual = PR_FALSE;
    1:             if(NS_FAILED(previousPrincipal->Equals(principal, &isEqual)) || !isEqual)
    1:                 break;
    1:         }
    1:         else
    1:             previousPrincipal = principal;
    1: 
    1:         // First check if the principal is even able to enable the
    1:         // given capability. If not, don't look any further.
    1:         PRInt16 canEnable;
    1:         rv = principal->CanEnableCapability(capability, &canEnable);
    1:         if (NS_FAILED(rv)) return rv;
    1:         if (canEnable != nsIPrincipal::ENABLE_GRANTED &&
    1:             canEnable != nsIPrincipal::ENABLE_WITH_USER_PERMISSION)
    1:             return NS_OK;
    1: 
    1:         // Now see if the capability is enabled.
    1:         void *annotation = JS_GetFrameAnnotation(cx, fp);
    1:         rv = principal->IsCapabilityEnabled(capability, annotation, result);
    1:         if (NS_FAILED(rv)) return rv;
    1:         if (*result)
    1:             return NS_OK;
    1:     } while ((fp = JS_FrameIterator(cx, &fp)) != nsnull);
    1: 
    1:     if (!previousPrincipal)
    1:     {
    1:         // No principals on the stack, all native code.  Allow
    1:         // execution if the subject principal is the system principal.
    1: 
    1:         return SubjectPrincipalIsSystem(result);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsScriptSecurityManager::FormatCapabilityString(nsAString& aCapability)
    1: {
    1:     nsAutoString newcaps;
    1:     nsAutoString rawcap;
    1:     NS_NAMED_LITERAL_STRING(capdesc, "capdesc.");
    1:     PRInt32 pos;
    1:     PRInt32 index = kNotFound;
    1:     nsresult rv;
    1: 
    1:     NS_ASSERTION(kNotFound == -1, "Basic constant changed, algorithm broken!");
    1: 
    1:     do {
    1:         pos = index+1;
    1:         index = aCapability.FindChar(' ', pos);
    1:         rawcap = Substring(aCapability, pos,
    1:                            (index == kNotFound) ? index : index - pos);
    1: 
    1:         nsXPIDLString capstr;
    1:         rv = sStrBundle->GetStringFromName(
    1:                             nsPromiseFlatString(capdesc+rawcap).get(),
    1:                             getter_Copies(capstr));
    1:         if (NS_SUCCEEDED(rv))
    1:             newcaps += capstr;
    1:         else
    1:         {
    1:             nsXPIDLString extensionCap;
    1:             const PRUnichar* formatArgs[] = { rawcap.get() };
    1:             rv = sStrBundle->FormatStringFromName(
    1:                                 NS_LITERAL_STRING("ExtensionCapability").get(),
    1:                                 formatArgs,
    1:                                 NS_ARRAY_LENGTH(formatArgs),
    1:                                 getter_Copies(extensionCap));
    1:             if (NS_SUCCEEDED(rv))
    1:                 newcaps += extensionCap;
    1:             else
    1:                 newcaps += rawcap;
    1:         }
    1: 
    1:         newcaps += NS_LITERAL_STRING("\n");
    1:     } while (index != kNotFound);
    1: 
    1:     aCapability = newcaps;
    1: }
    1: 
    1: PRBool
    1: nsScriptSecurityManager::CheckConfirmDialog(JSContext* cx, nsIPrincipal* aPrincipal,
    1:                                             const char* aCapability, PRBool *checkValue)
    1: {
    1:     nsresult rv;
    1:     *checkValue = PR_FALSE;
    1: 
    1:     //-- Get a prompter for the current window.
    1:     nsCOMPtr<nsIPrompt> prompter;
    1:     if (cx)
    1:     {
    1:         nsIScriptContext *scriptContext = GetScriptContext(cx);
    1:         if (scriptContext)
    1:         {
    1:             nsCOMPtr<nsIDOMWindowInternal> domWin =
    1:                 do_QueryInterface(scriptContext->GetGlobalObject());
    1:             if (domWin)
    1:                 domWin->GetPrompter(getter_AddRefs(prompter));
    1:         }
    1:     }
    1: 
    1:     if (!prompter)
    1:     {
    1:         //-- Couldn't get prompter from the current window, so get the prompt service.
    1:         nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
    1:         if (wwatch)
    1:           wwatch->GetNewPrompter(0, getter_AddRefs(prompter));
    1:         if (!prompter)
    1:             return PR_FALSE;
    1:     }
    1: 
    1:     //-- Localize the dialog text
    1:     nsXPIDLString check;
    1:     rv = sStrBundle->GetStringFromName(NS_LITERAL_STRING("CheckMessage").get(),
    1:                                        getter_Copies(check));
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1: 
    1:     nsXPIDLString title;
    1:     rv = sStrBundle->GetStringFromName(NS_LITERAL_STRING("Titleline").get(),
    1:                                        getter_Copies(title));
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1: 
    1:     nsXPIDLString yesStr;
    1:     rv = sStrBundle->GetStringFromName(NS_LITERAL_STRING("Yes").get(),
    1:                                        getter_Copies(yesStr));
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1: 
    1:     nsXPIDLString noStr;
    1:     rv = sStrBundle->GetStringFromName(NS_LITERAL_STRING("No").get(),
    1:                                        getter_Copies(noStr));
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1: 
13284:     nsCAutoString val;
    1:     PRBool hasCert;
    1:     aPrincipal->GetHasCertificate(&hasCert);
    1:     if (hasCert)
    1:         rv = aPrincipal->GetPrettyName(val);
    1:     else
13284:         rv = GetPrincipalDomainOrigin(aPrincipal, val);
    1: 
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1: 
    1:     NS_ConvertUTF8toUTF16 location(val);
    1:     NS_ConvertASCIItoUTF16 capability(aCapability);
    1:     FormatCapabilityString(capability);
    1:     const PRUnichar *formatStrings[] = { location.get(), capability.get() };
    1: 
    1:     nsXPIDLString message;
    1:     rv = sStrBundle->FormatStringFromName(NS_LITERAL_STRING("EnableCapabilityQuery").get(),
    1:                                           formatStrings,
    1:                                           NS_ARRAY_LENGTH(formatStrings),
    1:                                           getter_Copies(message));
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1: 
    1:     PRInt32 buttonPressed = 1; // If the user exits by clicking the close box, assume No (button 1)
    1:     rv = prompter->ConfirmEx(title.get(), message.get(),
    1:                              (nsIPrompt::BUTTON_DELAY_ENABLE) +
    1:                              (nsIPrompt::BUTTON_POS_1_DEFAULT) +
    1:                              (nsIPrompt::BUTTON_TITLE_IS_STRING * nsIPrompt::BUTTON_POS_0) +
    1:                              (nsIPrompt::BUTTON_TITLE_IS_STRING * nsIPrompt::BUTTON_POS_1),
    1:                              yesStr.get(), noStr.get(), nsnull, check.get(), checkValue, &buttonPressed);
    1: 
    1:     if (NS_FAILED(rv))
    1:         *checkValue = PR_FALSE;
    1:     return (buttonPressed == 0);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::RequestCapability(nsIPrincipal* aPrincipal,
    1:                                            const char *capability, PRInt16* canEnable)
    1: {
    1:     if (NS_FAILED(aPrincipal->CanEnableCapability(capability, canEnable)))
    1:         return NS_ERROR_FAILURE;
    1:     if (*canEnable == nsIPrincipal::ENABLE_WITH_USER_PERMISSION)
    1:     {
    1:         // Prompt user for permission to enable capability.
    1:         JSContext* cx = GetCurrentJSContext();
    1:         PRBool remember;
    1:         if (CheckConfirmDialog(cx, aPrincipal, capability, &remember))
    1:             *canEnable = nsIPrincipal::ENABLE_GRANTED;
    1:         else
    1:             *canEnable = nsIPrincipal::ENABLE_DENIED;
    1:         if (remember)
    1:         {
    1:             //-- Save principal to prefs and to mPrincipals
    1:             if (NS_FAILED(aPrincipal->SetCanEnableCapability(capability, *canEnable)))
    1:                 return NS_ERROR_FAILURE;
    1:             if (NS_FAILED(SavePrincipal(aPrincipal)))
    1:                 return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::EnableCapability(const char *capability)
    1: {
    1:     JSContext *cx = GetCurrentJSContext();
    1:     JSStackFrame *fp;
    1: 
    1:     //-- Error checks for capability string length (200)
    1:     if(PL_strlen(capability)>200)
    1:     {
    1:         static const char msg[] = "Capability name too long";
    1:         SetPendingException(cx, msg);
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     //-- Check capability string for valid characters
    1:     //
    1:     //   Logically we might have wanted this in nsPrincipal, but performance
    1:     //   worries dictate it can't go in IsCapabilityEnabled() and we may have
    1:     //   to show the capability on a dialog before we call the principal's
    1:     //   EnableCapability().
    1:     //
    1:     //   We don't need to validate the capability string on the other APIs
    1:     //   available to web content. Without the ability to enable junk then
    1:     //   isPrivilegeEnabled, disablePrivilege, and revertPrivilege all do
    1:     //   the right thing (effectively nothing) when passed unallowed chars.
    1:     for (const char *ch = capability; *ch; ++ch)
    1:     {
    1:         if (!NS_IS_ALPHA(*ch) && *ch != ' ' && !NS_IS_DIGIT(*ch)
    1:             && *ch != '_' && *ch != '-' && *ch != '.')
    1:         {
    1:             static const char msg[] = "Invalid character in capability name";
    1:             SetPendingException(cx, msg);
    1:             return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1: 
    1:     nsresult rv;
    1:     nsIPrincipal* principal = GetPrincipalAndFrame(cx, &fp, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1:     if (!principal)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     void *annotation = JS_GetFrameAnnotation(cx, fp);
    1:     PRBool enabled;
    1:     if (NS_FAILED(principal->IsCapabilityEnabled(capability, annotation,
    1:                                                  &enabled)))
    1:         return NS_ERROR_FAILURE;
    1:     if (enabled)
    1:         return NS_OK;
    1: 
    1:     PRInt16 canEnable;
    1:     if (NS_FAILED(RequestCapability(principal, capability, &canEnable)))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     if (canEnable != nsIPrincipal::ENABLE_GRANTED)
    1:     {
13284:         nsCAutoString val;
    1:         PRBool hasCert;
    1:         nsresult rv;
    1:         principal->GetHasCertificate(&hasCert);
    1:         if (hasCert)
    1:             rv = principal->GetPrettyName(val);
    1:         else
13284:             rv = GetPrincipalDomainOrigin(principal, val);
    1: 
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         NS_ConvertUTF8toUTF16 location(val);
    1:         NS_ConvertUTF8toUTF16 cap(capability);
    1:         const PRUnichar *formatStrings[] = { location.get(), cap.get() };
    1: 
    1:         nsXPIDLString message;
    1:         rv = sStrBundle->FormatStringFromName(NS_LITERAL_STRING("EnableCapabilityDenied").get(),
    1:                                               formatStrings,
    1:                                               NS_ARRAY_LENGTH(formatStrings),
    1:                                               getter_Copies(message));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         SetPendingException(cx, message.get());
    1: 
    1:         return NS_ERROR_FAILURE; // XXX better error code?
    1:     }
    1:     if (NS_FAILED(principal->EnableCapability(capability, &annotation)))
    1:         return NS_ERROR_FAILURE;
    1:     JS_SetFrameAnnotation(cx, fp, annotation);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::RevertCapability(const char *capability)
    1: {
    1:     JSContext *cx = GetCurrentJSContext();
    1:     JSStackFrame *fp;
    1:     nsresult rv;
    1:     nsIPrincipal* principal = GetPrincipalAndFrame(cx, &fp, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1:     if (!principal)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     void *annotation = JS_GetFrameAnnotation(cx, fp);
    1:     principal->RevertCapability(capability, &annotation);
    1:     JS_SetFrameAnnotation(cx, fp, annotation);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::DisableCapability(const char *capability)
    1: {
    1:     JSContext *cx = GetCurrentJSContext();
    1:     JSStackFrame *fp;
    1:     nsresult rv;
    1:     nsIPrincipal* principal = GetPrincipalAndFrame(cx, &fp, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1:     if (!principal)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     void *annotation = JS_GetFrameAnnotation(cx, fp);
    1:     principal->DisableCapability(capability, &annotation);
    1:     JS_SetFrameAnnotation(cx, fp, annotation);
    1:     return NS_OK;
    1: }
    1: 
    1: //////////////// Master Certificate Functions ///////////////////////////////////////
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::SetCanEnableCapability(const nsACString& certFingerprint,
    1:                                                 const char* capability,
    1:                                                 PRInt16 canEnable)
    1: {
    1:     NS_ENSURE_ARG(!certFingerprint.IsEmpty());
    1:     
    1:     nsresult rv;
    1:     nsIPrincipal* subjectPrincipal = doGetSubjectPrincipal(&rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     //-- Get the system certificate
    1:     if (!mSystemCertificate)
    1:     {
    1:         nsCOMPtr<nsIFile> systemCertFile;
    1:         nsCOMPtr<nsIProperties> directoryService =
    1:                  do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID, &rv);
    1:         if (!directoryService) return NS_ERROR_FAILURE;
    1:         rv = directoryService->Get(NS_XPCOM_CURRENT_PROCESS_DIR, NS_GET_IID(nsIFile),
    1:                               getter_AddRefs(systemCertFile));
    1:         if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
    1:         systemCertFile->AppendNative(NS_LITERAL_CSTRING("systemSignature.jar"));
    1:         if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
    1:         nsCOMPtr<nsIZipReader> systemCertZip = do_CreateInstance(kZipReaderCID, &rv);
    1:         if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
    1:         rv = systemCertZip->Open(systemCertFile);
    1:         if (NS_SUCCEEDED(rv))
    1:         {
    1:             nsCOMPtr<nsIJAR> systemCertJar(do_QueryInterface(systemCertZip, &rv));
    1:             if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
    1:             rv = systemCertJar->GetCertificatePrincipal(nsnull,
    1:                                                         getter_AddRefs(mSystemCertificate));
    1:             if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1: 
    1:     //-- Make sure the caller's principal is the system certificate
    1:     PRBool isEqual = PR_FALSE;
    1:     if (mSystemCertificate)
    1:     {
    1:         rv = mSystemCertificate->Equals(subjectPrincipal, &isEqual);
    1:         if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
    1:     }
    1:     if (!isEqual)
    1:     {
    1:         JSContext* cx = GetCurrentJSContext();
    1:         if (!cx) return NS_ERROR_FAILURE;
    1:         static const char msg1[] = "Only code signed by the system certificate may call SetCanEnableCapability or Invalidate";
    1:         static const char msg2[] = "Attempt to call SetCanEnableCapability or Invalidate when no system certificate has been established";
    1:         SetPendingException(cx, mSystemCertificate ? msg1 : msg2);
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     //-- Get the target principal
    1:     nsCOMPtr<nsIPrincipal> objectPrincipal;
    1:     rv = DoGetCertificatePrincipal(certFingerprint, EmptyCString(),
    1:                                    EmptyCString(), nsnull,
    1:                                    nsnull, PR_FALSE,
    1:                                    getter_AddRefs(objectPrincipal));
    1:     if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
    1:     rv = objectPrincipal->SetCanEnableCapability(capability, canEnable);
    1:     if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
    1:     return SavePrincipal(objectPrincipal);
    1: }
    1: 
    1: ////////////////////////////////////////////////
    1: // Methods implementing nsIXPCSecurityManager //
    1: ////////////////////////////////////////////////
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CanCreateWrapper(JSContext *cx,
    1:                                           const nsIID &aIID,
    1:                                           nsISupports *aObj,
    1:                                           nsIClassInfo *aClassInfo,
    1:                                           void **aPolicy)
    1: {
    1: #ifdef DEBUG_CAPS_CanCreateWrapper
    1:     char* iidStr = aIID.ToString();
    1:     printf("### CanCreateWrapper(%s) ", iidStr);
    1:     nsCRT::free(iidStr);
    1: #endif
    1: // XXX Special case for nsIXPCException ?
    1:     ClassInfoData objClassInfo = ClassInfoData(aClassInfo, nsnull);
    1:     if (objClassInfo.IsDOMClass())
    1:     {
    1: #ifdef DEBUG_CAPS_CanCreateWrapper
    1:         printf("DOM class - GRANTED.\n");
    1: #endif
    1:         return NS_OK;
    1:     }
    1: 
    1:     //--See if the object advertises a non-default level of access
    1:     //  using nsISecurityCheckedComponent
    1:     nsCOMPtr<nsISecurityCheckedComponent> checkedComponent =
    1:         do_QueryInterface(aObj);
    1: 
    1:     nsXPIDLCString objectSecurityLevel;
    1:     if (checkedComponent)
    1:         checkedComponent->CanCreateWrapper((nsIID *)&aIID, getter_Copies(objectSecurityLevel));
    1: 
28348:     nsresult rv = CheckXPCPermissions(aObj, nsnull, nsnull, objectSecurityLevel);
    1:     if (NS_FAILED(rv))
    1:     {
    1:         //-- Access denied, report an error
16268:         NS_ConvertUTF8toUTF16 strName("CreateWrapperDenied");
16268:         nsCAutoString origin;
16268:         nsresult rv2;
16268:         nsIPrincipal* subjectPrincipal = doGetSubjectPrincipal(&rv2);
16268:         if (NS_SUCCEEDED(rv2) && subjectPrincipal) {
16268:             GetPrincipalDomainOrigin(subjectPrincipal, origin);
16268:         }
16268:         NS_ConvertUTF8toUTF16 originUnicode(origin);
    1:         NS_ConvertUTF8toUTF16 className(objClassInfo.GetName());
16268:         const PRUnichar* formatStrings[] = {
16268:             className.get(),
16268:             originUnicode.get()
16268:         };
16268:         PRUint32 length = NS_ARRAY_LENGTH(formatStrings);
16268:         if (originUnicode.IsEmpty()) {
16268:             --length;
16268:         } else {
16268:             strName.AppendLiteral("ForOrigin");
16268:         }
    1:         nsXPIDLString errorMsg;
    1:         // We need to keep our existing failure rv and not override it
    1:         // with a likely success code from the following string bundle
    1:         // call in order to throw the correct security exception later.
16268:         rv2 = sStrBundle->FormatStringFromName(strName.get(),
    1:                                                formatStrings,
16268:                                                length,
    1:                                                getter_Copies(errorMsg));
    1:         NS_ENSURE_SUCCESS(rv2, rv2);
    1: 
    1:         SetPendingException(cx, errorMsg.get());
    1: 
    1: #ifdef DEBUG_CAPS_CanCreateWrapper
    1:         printf("DENIED.\n");
    1:     }
    1:     else
    1:     {
    1:         printf("GRANTED.\n");
    1: #endif
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1: nsresult
    1: nsScriptSecurityManager::CheckComponentPermissions(JSContext *cx,
    1:                                                    const nsCID &aCID)
    1: {
    1:     nsresult rv;
    1:     nsIPrincipal* subjectPrincipal = GetSubjectPrincipal(cx, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Reformat the CID string so it's suitable for prefs
    1:     nsXPIDLCString cidTemp;
    1:     cidTemp.Adopt(aCID.ToString());
    1:     nsCAutoString cid(NS_LITERAL_CSTRING("CID") +
    1:                       Substring(cidTemp, 1, cidTemp.Length() - 2));
    1:     ToUpperCase(cid);
    1: 
    1: #ifdef DEBUG_CAPS_CheckComponentPermissions
    1:     printf("### CheckComponentPermissions(ClassID.%s) ",cid.get());
    1: #endif
    1: 
    1:     // Look up the policy for this class.
    1:     // while this isn't a property we'll treat it as such, using ACCESS_CALL_METHOD
    1:     JSAutoRequest ar(cx);
    1:     jsval cidVal = STRING_TO_JSVAL(::JS_InternString(cx, cid.get()));
    1: 
    1:     ClassInfoData nameData(nsnull, "ClassID");
    1:     SecurityLevel securityLevel;
    1:     rv = LookupPolicy(subjectPrincipal, nameData, cidVal,
    1:                       nsIXPCSecurityManager::ACCESS_CALL_METHOD, 
    1:                       nsnull, &securityLevel);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // If there's no policy stored, use the "security.classID.allowByDefault" pref 
    1:     if (securityLevel.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
    1:         securityLevel.level = mXPCDefaultGrantAll ? SCRIPT_SECURITY_ALL_ACCESS :
    1:                                                     SCRIPT_SECURITY_NO_ACCESS;
    1: 
    1:     if (securityLevel.level == SCRIPT_SECURITY_ALL_ACCESS)
    1:     {
    1: #ifdef DEBUG_CAPS_CheckComponentPermissions
    1:         printf(" GRANTED.\n");
    1: #endif
    1:         return NS_OK;
    1:     }
    1: 
    1: #ifdef DEBUG_CAPS_CheckComponentPermissions
    1:     printf(" DENIED.\n");
    1: #endif
    1:     return NS_ERROR_DOM_PROP_ACCESS_DENIED;
    1: }
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CanCreateInstance(JSContext *cx,
    1:                                            const nsCID &aCID)
    1: {
    1: #ifdef DEBUG_CAPS_CanCreateInstance
    1:     char* cidStr = aCID.ToString();
    1:     printf("### CanCreateInstance(%s) ", cidStr);
    1:     nsCRT::free(cidStr);
    1: #endif
    1: 
28348:     nsresult rv = CheckXPCPermissions(nsnull, nsnull, nsnull, nsnull);
    1:     if (NS_FAILED(rv))
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     {
    1:         rv = CheckComponentPermissions(cx, aCID);
    1:     }
    1:     if (NS_FAILED(rv))
    1: #endif
    1:     {
    1:         //-- Access denied, report an error
    1:         nsCAutoString errorMsg("Permission denied to create instance of class. CID=");
10204:         char cidStr[NSID_LENGTH];
10204:         aCID.ToProvidedString(cidStr);
    1:         errorMsg.Append(cidStr);
    1:         SetPendingException(cx, errorMsg.get());
    1: 
    1: #ifdef DEBUG_CAPS_CanCreateInstance
    1:         printf("DENIED\n");
    1:     }
    1:     else
    1:     {
    1:         printf("GRANTED\n");
    1: #endif
    1:     }
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CanGetService(JSContext *cx,
    1:                                        const nsCID &aCID)
    1: {
    1: #ifdef DEBUG_CAPS_CanGetService
    1:     char* cidStr = aCID.ToString();
    1:     printf("### CanGetService(%s) ", cidStr);
    1:     nsCRT::free(cidStr);
    1: #endif
    1: 
28348:     nsresult rv = CheckXPCPermissions(nsnull, nsnull, nsnull, nsnull);
    1:     if (NS_FAILED(rv))
    1:     {
    1:         //-- Access denied, report an error
    1:         nsCAutoString errorMsg("Permission denied to get service. CID=");
10204:         char cidStr[NSID_LENGTH];
10204:         aCID.ToProvidedString(cidStr);
    1:         errorMsg.Append(cidStr);
    1:         SetPendingException(cx, errorMsg.get());
    1: 
    1: #ifdef DEBUG_CAPS_CanGetService
    1:         printf("DENIED\n");
    1:     }
    1:     else
    1:     {
    1:         printf("GRANTED\n");
    1: #endif
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CanAccess(PRUint32 aAction,
10286:                                    nsAXPCNativeCallContext* aCallContext,
    1:                                    JSContext* cx,
    1:                                    JSObject* aJSObject,
    1:                                    nsISupports* aObj,
    1:                                    nsIClassInfo* aClassInfo,
    1:                                    jsval aPropertyName,
    1:                                    void** aPolicy)
    1: {
    1:     return CheckPropertyAccessImpl(aAction, aCallContext, cx,
14480:                                    aJSObject, aObj, nsnull, aClassInfo,
    1:                                    nsnull, aPropertyName, aPolicy);
    1: }
    1: 
    1: nsresult
28348: nsScriptSecurityManager::CheckXPCPermissions(nsISupports* aObj, JSObject* aJSObject,
28292:                                              nsIPrincipal* aSubjectPrincipal,
    1:                                              const char* aObjectSecurityLevel)
    1: {
    1:     //-- Check for the all-powerful UniversalXPConnect privilege
    1:     PRBool ok = PR_FALSE;
    1:     if (NS_SUCCEEDED(IsCapabilityEnabled("UniversalXPConnect", &ok)) && ok)
    1:         return NS_OK;
    1: 
    1:     //-- If the object implements nsISecurityCheckedComponent, it has a non-default policy.
    1:     if (aObjectSecurityLevel)
    1:     {
    1:         if (PL_strcasecmp(aObjectSecurityLevel, "allAccess") == 0)
    1:             return NS_OK;
28348:         if (aSubjectPrincipal && aJSObject &&
28348:             PL_strcasecmp(aObjectSecurityLevel, "sameOrigin") == 0)
28292:         {
28292:             nsIPrincipal* objectPrincipal = doGetObjectPrincipal(aJSObject);
28292: 
28292:             // Only do anything if we have both a subject and object
28292:             // principal.
28292:             if (objectPrincipal)
28292:             {
28292:                 PRBool subsumes;
28348:                 nsresult rv = aSubjectPrincipal->Subsumes(objectPrincipal, &subsumes);
28292:                 NS_ENSURE_SUCCESS(rv, rv);
28292:                 if (subsumes)
28292:                     return NS_OK;
28292:             }
28292:         }
    1:         else if (PL_strcasecmp(aObjectSecurityLevel, "noAccess") != 0)
    1:         {
    1:             PRBool canAccess = PR_FALSE;
    1:             if (NS_SUCCEEDED(IsCapabilityEnabled(aObjectSecurityLevel, &canAccess)) &&
    1:                 canAccess)
    1:                 return NS_OK;
    1:         }
    1:     }
    1: 
    1:     //-- If user allows scripting of plugins by untrusted scripts,
    1:     //   and the target object is a plugin, allow the access.
    1:     if(aObj)
    1:     {
    1:         nsresult rv;
    1:         nsCOMPtr<nsIPluginInstance> plugin(do_QueryInterface(aObj, &rv));
    1:         if (NS_SUCCEEDED(rv))
    1:         {
    1:             static PRBool prefSet = PR_FALSE;
    1:             static PRBool allowPluginAccess = PR_FALSE;
    1:             if (!prefSet)
    1:             {
    1:                 rv = mSecurityPref->SecurityGetBoolPref("security.xpconnect.plugin.unrestricted",
    1:                                                        &allowPluginAccess);
    1:                 prefSet = PR_TRUE;
    1:             }
    1:             if (allowPluginAccess)
    1:                 return NS_OK;
    1:         }
    1:     }
    1: 
    1:     //-- Access tests failed
    1:     return NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED;
    1: }
    1: 
    1: //////////////////////////////////////////////
    1: // Method implementing nsIPrefSecurityCheck //
    1: //////////////////////////////////////////////
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::CanAccessSecurityPreferences(PRBool* _retval)
    1: {
    1:     return IsCapabilityEnabled("CapabilityPreferencesAccess", _retval);  
    1: }
    1: 
    1: /////////////////////////////////////////////
    1: // Method implementing nsIChannelEventSink //
    1: /////////////////////////////////////////////
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::OnChannelRedirect(nsIChannel* oldChannel, 
    1:                                            nsIChannel* newChannel,
    1:                                            PRUint32 redirFlags)
    1: {
    1:     nsCOMPtr<nsIPrincipal> oldPrincipal;
    1:     GetChannelPrincipal(oldChannel, getter_AddRefs(oldPrincipal));
    1: 
    1:     nsCOMPtr<nsIURI> newURI;
    1:     newChannel->GetURI(getter_AddRefs(newURI));
21937:     nsCOMPtr<nsIURI> newOriginalURI;
21937:     newChannel->GetOriginalURI(getter_AddRefs(newOriginalURI));
21937: 
21937:     NS_ENSURE_STATE(oldPrincipal && newURI && newOriginalURI);
    1: 
    1:     const PRUint32 flags =
    1:         nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT |
    1:         nsIScriptSecurityManager::DISALLOW_SCRIPT;
21937:     nsresult rv = CheckLoadURIWithPrincipal(oldPrincipal, newURI, flags);
21937:     if (NS_SUCCEEDED(rv) && newOriginalURI != newURI) {
21937:         rv = CheckLoadURIWithPrincipal(oldPrincipal, newOriginalURI, flags);
21937:     }
21937:     return rv;
    1: }
    1: 
    1: 
    1: /////////////////////////////////////
    1: // Method implementing nsIObserver //
    1: /////////////////////////////////////
    1: static const char sPrincipalPrefix[] = "capability.principal";
    1: static const char sPolicyPrefix[] = "capability.policy.";
    1: 
    1: NS_IMETHODIMP
    1: nsScriptSecurityManager::Observe(nsISupports* aObject, const char* aTopic,
    1:                                  const PRUnichar* aMessage)
    1: {
    1:     nsresult rv = NS_OK;
    1:     NS_ConvertUTF16toUTF8 messageStr(aMessage);
    1:     const char *message = messageStr.get();
    1: 
    1:     static const char jsPrefix[] = "javascript.";
 5766:     static const char securityPrefix[] = "security.";
 5766:     if ((PL_strncmp(message, jsPrefix, sizeof(jsPrefix)-1) == 0) ||
 5766:         (PL_strncmp(message, securityPrefix, sizeof(securityPrefix)-1) == 0) )
 5766:     {
 5766:         ScriptSecurityPrefChanged();
 5766:     }
 5766:     else if (PL_strncmp(message, sPolicyPrefix, sizeof(sPolicyPrefix)-1) == 0)
 5766:     {
 5766:         // This will force re-initialization of the pref table
 5766:         mPolicyPrefsChanged = PR_TRUE;
 5766:     }
    1:     else if ((PL_strncmp(message, sPrincipalPrefix, sizeof(sPrincipalPrefix)-1) == 0) &&
    1:              !mIsWritingPrefs)
    1:     {
    1:         static const char id[] = "id";
    1:         char* lastDot = PL_strrchr(message, '.');
    1:         //-- This check makes sure the string copy below doesn't overwrite its bounds
    1:         if(PL_strlen(lastDot) >= sizeof(id))
    1:         {
    1:             PL_strcpy(lastDot + 1, id);
    1:             const char** idPrefArray = (const char**)&message;
    1:             rv = InitPrincipals(1, idPrefArray, mSecurityPref);
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
    1: /////////////////////////////////////////////
    1: // Constructor, Destructor, Initialization //
    1: /////////////////////////////////////////////
    1: nsScriptSecurityManager::nsScriptSecurityManager(void)
    1:     : mOriginToPolicyMap(nsnull),
    1:       mDefaultPolicy(nsnull),
    1:       mCapabilities(nsnull),
    1:       mIsJavaScriptEnabled(PR_FALSE),
    1:       mIsWritingPrefs(PR_FALSE),
12321:       mPolicyPrefsChanged(PR_TRUE)
    1: #ifdef XPC_IDISPATCH_SUPPORT
12321:       , mXPCDefaultGrantAll(PR_FALSE)
    1: #endif
    1: {
25554:     NS_ASSERTION(sizeof(PRWord) == sizeof(void*),
25554:                  "PRWord and void* have different lengths on this platform. "
25554:                  "This may cause a security failure with the SecurityLevel union.");
    1:     mPrincipals.Init(31);
    1: }
    1: 
    1: 
    1: nsresult nsScriptSecurityManager::Init()
    1: {
20462:     nsresult rv = CallGetService(nsIXPConnect::GetCID(), &sXPConnect);
20462:     NS_ENSURE_SUCCESS(rv, rv);
20462: 
20462:     rv = CallGetService("@mozilla.org/js/xpc/ContextStack;1", &sJSContextStack);
20462:     NS_ENSURE_SUCCESS(rv, rv);
20462: 
    1:     JSContext* cx = GetSafeJSContext();
    1:     if (!cx) return NS_ERROR_FAILURE;   // this can happen of xpt loading fails
    1:     
    1:     ::JS_BeginRequest(cx);
    1:     if (sEnabledID == JSVAL_VOID)
    1:         sEnabledID = STRING_TO_JSVAL(::JS_InternString(cx, "enabled"));
    1:     ::JS_EndRequest(cx);
    1: 
23434:     InitPrefs();
    1: 
    1:     rv = CallGetService(NS_IOSERVICE_CONTRACTID, &sIOService);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIStringBundleService> bundleService = do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = bundleService->CreateBundle("chrome://global/locale/security/caps.properties", &sStrBundle);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Create our system principal singleton
    1:     nsRefPtr<nsSystemPrincipal> system = new nsSystemPrincipal();
    1:     NS_ENSURE_TRUE(system, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     rv = system->Init();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     mSystemPrincipal = system;
    1: 
    1:     //-- Register security check callback in the JS engine
    1:     //   Currently this is used to control access to function.caller
    1:     nsCOMPtr<nsIJSRuntimeService> runtimeService =
    1:         do_GetService("@mozilla.org/js/xpc/RuntimeService;1", &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = runtimeService->GetRuntime(&sRuntime);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
18871:     static JSSecurityCallbacks securityCallbacks = {
18871:       CheckObjectAccess,
18871:       NULL,
18871:       NULL
18871:     };
18871: 
    1: #ifdef DEBUG
18871:     JSSecurityCallbacks *oldcallbacks =
    1: #endif
18871:     JS_SetRuntimeSecurityCallbacks(sRuntime, &securityCallbacks);
18871:     NS_ASSERTION(!oldcallbacks, "Someone else set security callbacks!");
    1: 
 8990:     sXPConnect->GetXPCWrappedNativeJSClassInfo(&sXPCWrappedNativeJSClass,
 8990:                                                &sXPCWrappedNativeGetObjOps1,
 8990:                                                &sXPCWrappedNativeGetObjOps2);
    1:     return NS_OK;
    1: }
    1: 
    1: static nsScriptSecurityManager *gScriptSecMan = nsnull;
    1: 
    1: jsval nsScriptSecurityManager::sEnabledID   = JSVAL_VOID;
    1: 
    1: nsScriptSecurityManager::~nsScriptSecurityManager(void)
    1: {
    1:     delete mOriginToPolicyMap;
    1:     if(mDefaultPolicy)
    1:         mDefaultPolicy->Drop();
    1:     delete mCapabilities;
    1:     gScriptSecMan = nsnull;
    1: }
    1: 
    1: void
    1: nsScriptSecurityManager::Shutdown()
    1: {
    1:     if (sRuntime) {
18871:         JS_SetRuntimeSecurityCallbacks(sRuntime, NULL);
    1:         sRuntime = nsnull;
    1:     }
    1:     sEnabledID = JSVAL_VOID;
    1: 
    1:     NS_IF_RELEASE(sIOService);
    1:     NS_IF_RELEASE(sXPConnect);
20462:     NS_IF_RELEASE(sJSContextStack);
    1:     NS_IF_RELEASE(sStrBundle);
    1: }
    1: 
    1: nsScriptSecurityManager *
    1: nsScriptSecurityManager::GetScriptSecurityManager()
    1: {
    1:     if (!gScriptSecMan)
    1:     {
    1:         nsScriptSecurityManager* ssManager = new nsScriptSecurityManager();
    1:         if (!ssManager)
    1:             return nsnull;
    1:         nsresult rv;
    1:         rv = ssManager->Init();
    1:         NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to initialize nsScriptSecurityManager");
    1:         if (NS_FAILED(rv)) {
    1:             delete ssManager;
    1:             return nsnull;
    1:         }
    1:  
    1:         rv = nsJSPrincipals::Startup();
    1:         if (NS_FAILED(rv)) {
    1:             NS_WARNING("can't initialize JS engine security protocol glue!");
    1:             delete ssManager;
    1:             return nsnull;
    1:         }
    1:  
    1:         rv = sXPConnect->SetDefaultSecurityManager(ssManager,
    1:                                                    nsIXPCSecurityManager::HOOK_ALL);
    1:         if (NS_FAILED(rv)) {
    1:             NS_WARNING("Failed to install xpconnect security manager!");
    1:             delete ssManager;
    1:             return nsnull;
    1:         }
    1: 
    1:         gScriptSecMan = ssManager;
    1:     }
    1:     return gScriptSecMan;
    1: }
    1: 
    1: // Currently this nsGenericFactory constructor is used only from FastLoad
    1: // (XPCOM object deserialization) code, when "creating" the system principal
    1: // singleton.
    1: nsSystemPrincipal *
    1: nsScriptSecurityManager::SystemPrincipalSingletonConstructor()
    1: {
    1:     nsIPrincipal *sysprin = nsnull;
    1:     if (gScriptSecMan)
    1:         NS_ADDREF(sysprin = gScriptSecMan->mSystemPrincipal);
 3233:     return static_cast<nsSystemPrincipal*>(sysprin);
    1: }
    1: 
    1: nsresult
    1: nsScriptSecurityManager::InitPolicies()
    1: {
    1:     // Clear any policies cached on XPConnect wrappers
    1:     NS_ENSURE_STATE(sXPConnect);
    1:     nsresult rv = sXPConnect->ClearAllWrappedNativeSecurityPolicies();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     //-- Clear mOriginToPolicyMap: delete mapped DomainEntry items,
    1:     //-- whose dtor decrements refcount of stored DomainPolicy object
    1:     delete mOriginToPolicyMap;
    1:     
    1:     //-- Marks all the survivor DomainPolicy objects (those cached
    1:     //-- by nsPrincipal objects) as invalid: they will be released
    1:     //-- on first nsPrincipal::GetSecurityPolicy() attempt.
    1:     DomainPolicy::InvalidateAll();
    1:     
    1:     //-- Release old default policy
    1:     if(mDefaultPolicy) {
    1:         mDefaultPolicy->Drop();
    1:         mDefaultPolicy = nsnull;
    1:     }
    1:     
    1:     //-- Initialize a new mOriginToPolicyMap
    1:     mOriginToPolicyMap =
    1:       new nsObjectHashtable(nsnull, nsnull, DeleteDomainEntry, nsnull);
    1:     if (!mOriginToPolicyMap)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     //-- Create, refcount and initialize a new default policy 
    1:     mDefaultPolicy = new DomainPolicy();
    1:     if (!mDefaultPolicy)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     mDefaultPolicy->Hold();
    1:     if (!mDefaultPolicy->Init())
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     //-- Initialize the table of security levels
    1:     if (!mCapabilities)
    1:     {
    1:         mCapabilities = 
    1:           new nsObjectHashtable(nsnull, nsnull, DeleteCapability, nsnull);
    1:         if (!mCapabilities)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     // Get a JS context - we need it to create internalized strings later.
    1:     JSContext* cx = GetSafeJSContext();
    1:     NS_ASSERTION(cx, "failed to get JS context");
20462:     AutoCxPusher autoPusher(sJSContextStack, cx);
    1:     rv = InitDomainPolicy(cx, "default", mDefaultPolicy);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsXPIDLCString policyNames;
    1:     rv = mSecurityPref->SecurityGetCharPref("capability.policy.policynames",
    1:                                             getter_Copies(policyNames));
    1: 
    1:     nsXPIDLCString defaultPolicyNames;
    1:     rv = mSecurityPref->SecurityGetCharPref("capability.policy.default_policynames",
    1:                                             getter_Copies(defaultPolicyNames));
    1:     policyNames += NS_LITERAL_CSTRING(" ") + defaultPolicyNames;
    1: 
    1:     //-- Initialize domain policies
    1:     char* policyCurrent = policyNames.BeginWriting();
    1:     PRBool morePolicies = PR_TRUE;
    1:     while (morePolicies)
    1:     {
    1:         while(*policyCurrent == ' ' || *policyCurrent == ',')
    1:             policyCurrent++;
    1:         if (*policyCurrent == '\0')
    1:             break;
    1:         char* nameBegin = policyCurrent;
    1: 
    1:         while(*policyCurrent != '\0' && *policyCurrent != ' ' && *policyCurrent != ',')
    1:             policyCurrent++;
    1: 
    1:         morePolicies = (*policyCurrent != '\0');
    1:         *policyCurrent = '\0';
    1:         policyCurrent++;
    1: 
    1:         nsCAutoString sitesPrefName(
    1:             NS_LITERAL_CSTRING(sPolicyPrefix) +
    1:             nsDependentCString(nameBegin) +
    1:             NS_LITERAL_CSTRING(".sites"));
    1:         nsXPIDLCString domainList;
    1:         rv = mSecurityPref->SecurityGetCharPref(sitesPrefName.get(),
    1:                                                 getter_Copies(domainList));
    1:         if (NS_FAILED(rv))
    1:             continue;
    1: 
    1:         DomainPolicy* domainPolicy = new DomainPolicy();
    1:         if (!domainPolicy)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         if (!domainPolicy->Init())
    1:         {
    1:             delete domainPolicy;
    1:             return NS_ERROR_UNEXPECTED;
    1:         }
    1:         domainPolicy->Hold();
    1:         //-- Parse list of sites and create an entry in mOriginToPolicyMap for each
    1:         char* domainStart = domainList.BeginWriting();
    1:         char* domainCurrent = domainStart;
    1:         char* lastDot = nsnull;
    1:         char* nextToLastDot = nsnull;
    1:         PRBool moreDomains = PR_TRUE;
    1:         while (moreDomains)
    1:         {
    1:             if (*domainCurrent == ' ' || *domainCurrent == '\0')
    1:             {
    1:                 moreDomains = (*domainCurrent != '\0');
    1:                 *domainCurrent = '\0';
    1:                 nsCStringKey key(nextToLastDot ? nextToLastDot+1 : domainStart);
    1:                 DomainEntry *newEntry = new DomainEntry(domainStart, domainPolicy);
    1:                 if (!newEntry)
    1:                 {
    1:                     domainPolicy->Drop();
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1:                 }
    1: #ifdef DEBUG
    1:                 newEntry->mPolicyName_DEBUG = nameBegin;
    1: #endif
    1:                 DomainEntry *existingEntry = (DomainEntry *)
    1:                     mOriginToPolicyMap->Get(&key);
    1:                 if (!existingEntry)
    1:                     mOriginToPolicyMap->Put(&key, newEntry);
    1:                 else
    1:                 {
    1:                     if (existingEntry->Matches(domainStart))
    1:                     {
    1:                         newEntry->mNext = existingEntry;
    1:                         mOriginToPolicyMap->Put(&key, newEntry);
    1:                     }
    1:                     else
    1:                     {
    1:                         while (existingEntry->mNext)
    1:                         {
    1:                             if (existingEntry->mNext->Matches(domainStart))
    1:                             {
    1:                                 newEntry->mNext = existingEntry->mNext;
    1:                                 existingEntry->mNext = newEntry;
    1:                                 break;
    1:                             }
    1:                             existingEntry = existingEntry->mNext;
    1:                         }
    1:                         if (!existingEntry->mNext)
    1:                             existingEntry->mNext = newEntry;
    1:                     }
    1:                 }
    1:                 domainStart = domainCurrent + 1;
    1:                 lastDot = nextToLastDot = nsnull;
    1:             }
    1:             else if (*domainCurrent == '.')
    1:             {
    1:                 nextToLastDot = lastDot;
    1:                 lastDot = domainCurrent;
    1:             }
    1:             domainCurrent++;
    1:         }
    1: 
    1:         rv = InitDomainPolicy(cx, nameBegin, domainPolicy);
    1:         domainPolicy->Drop();
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     // Reset the "dirty" flag
    1:     mPolicyPrefsChanged = PR_FALSE;
    1: 
    1: #ifdef DEBUG_CAPS_HACKER
    1:     PrintPolicyDB();
    1: #endif
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsScriptSecurityManager::InitDomainPolicy(JSContext* cx,
    1:                                           const char* aPolicyName,
    1:                                           DomainPolicy* aDomainPolicy)
    1: {
    1:     nsresult rv;
    1:     nsCAutoString policyPrefix(NS_LITERAL_CSTRING(sPolicyPrefix) +
    1:                                nsDependentCString(aPolicyName) +
    1:                                NS_LITERAL_CSTRING("."));
    1:     PRUint32 prefixLength = policyPrefix.Length() - 1; // subtract the '.'
    1: 
    1:     PRUint32 prefCount;
    1:     char** prefNames;
    1:     rv = mPrefBranch->GetChildList(policyPrefix.get(),
    1:                                    &prefCount, &prefNames);
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (prefCount == 0)
    1:         return NS_OK;
    1: 
    1:     //-- Populate the policy
    1:     PRUint32 currentPref = 0;
    1:     for (; currentPref < prefCount; currentPref++)
    1:     {
    1:         // Get the class name
    1:         const char* start = prefNames[currentPref] + prefixLength + 1;
    1:         char* end = PL_strchr(start, '.');
    1:         if (!end) // malformed pref, bail on this one
    1:             continue;
    1:         static const char sitesStr[] = "sites";
    1: 
    1:         // We dealt with "sites" in InitPolicies(), so no need to do
    1:         // that again...
    1:         if (PL_strncmp(start, sitesStr, sizeof(sitesStr)-1) == 0)
    1:             continue;
    1: 
    1:         // Get the pref value
    1:         nsXPIDLCString prefValue;
    1:         rv = mSecurityPref->SecurityGetCharPref(prefNames[currentPref],
    1:                                                 getter_Copies(prefValue));
    1:         if (NS_FAILED(rv) || !prefValue)
    1:             continue;
    1: 
    1:         SecurityLevel secLevel;
    1:         if (PL_strcasecmp(prefValue, "noAccess") == 0)
    1:             secLevel.level = SCRIPT_SECURITY_NO_ACCESS;
    1:         else if (PL_strcasecmp(prefValue, "allAccess") == 0)
    1:             secLevel.level = SCRIPT_SECURITY_ALL_ACCESS;
    1:         else if (PL_strcasecmp(prefValue, "sameOrigin") == 0)
    1:             secLevel.level = SCRIPT_SECURITY_SAME_ORIGIN_ACCESS;
    1:         else 
    1:         {  //-- pref value is the name of a capability
    1:             nsCStringKey secLevelKey(prefValue);
    1:             secLevel.capability =
 3233:                 reinterpret_cast<char*>(mCapabilities->Get(&secLevelKey));
    1:             if (!secLevel.capability)
    1:             {
    1:                 secLevel.capability = NS_strdup(prefValue);
    1:                 if (!secLevel.capability)
    1:                     break;
    1:                 mCapabilities->Put(&secLevelKey, 
    1:                                    secLevel.capability);
    1:             }
    1:         }
    1: 
    1:         *end = '\0';
    1:         // Find or store this class in the classes table
    1:         ClassPolicy* cpolicy = 
 3233:           static_cast<ClassPolicy*>
 3233:                      (PL_DHashTableOperate(aDomainPolicy, start,
    1:                                               PL_DHASH_ADD));
    1:         if (!cpolicy)
    1:             break;
    1: 
    1:         // If this is the wildcard class (class '*'), save it in mWildcardPolicy
    1:         // (we leave it stored in the hashtable too to take care of the cleanup)
    1:         if ((*start == '*') && (end == start + 1)) {
    1:             aDomainPolicy->mWildcardPolicy = cpolicy;
    1: 
    1:             // Make sure that cpolicy knows about aDomainPolicy so it can reset
    1:             // the mWildcardPolicy pointer as needed if it gets moved in the
    1:             // hashtable.
    1:             cpolicy->mDomainWeAreWildcardFor = aDomainPolicy;
    1:         }
    1: 
    1:         // Get the property name
    1:         start = end + 1;
    1:         end = PL_strchr(start, '.');
    1:         if (end)
    1:             *end = '\0';
    1: 
    1:         JSAutoRequest ar(cx);
    1: 
    1:         JSString* propertyKey = ::JS_InternString(cx, start);
    1:         if (!propertyKey)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         // Store this property in the class policy
    1:         const void* ppkey =
 3233:           reinterpret_cast<const void*>(STRING_TO_JSVAL(propertyKey));
    1:         PropertyPolicy* ppolicy = 
 3233:           static_cast<PropertyPolicy*>
 3233:                      (PL_DHashTableOperate(cpolicy->mPolicy, ppkey,
    1:                                               PL_DHASH_ADD));
    1:         if (!ppolicy)
    1:             break;
    1: 
    1:         if (end) // The pref specifies an access mode
    1:         {
    1:             start = end + 1;
    1:             if (PL_strcasecmp(start, "set") == 0)
    1:                 ppolicy->mSet = secLevel;
    1:             else
    1:                 ppolicy->mGet = secLevel;
    1:         }
    1:         else
    1:         {
    1:             if (ppolicy->mGet.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
    1:                 ppolicy->mGet = secLevel;
    1:             if (ppolicy->mSet.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
    1:                 ppolicy->mSet = secLevel;
    1:         }
    1:     }
    1: 
    1:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, prefNames);
    1:     if (currentPref < prefCount) // Loop exited early because of out-of-memory error
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: // XXXbz We should really just get a prefbranch to handle this...
    1: nsresult
    1: nsScriptSecurityManager::GetPrincipalPrefNames(const char* prefBase,
    1:                                                nsCString& grantedPref,
    1:                                                nsCString& deniedPref,
    1:                                                nsCString& subjectNamePref)
    1: {
    1:     char* lastDot = PL_strrchr(prefBase, '.');
    1:     if (!lastDot) return NS_ERROR_FAILURE;
    1:     PRInt32 prefLen = lastDot - prefBase + 1;
    1: 
    1:     grantedPref.Assign(prefBase, prefLen);
    1:     deniedPref.Assign(prefBase, prefLen);
    1:     subjectNamePref.Assign(prefBase, prefLen);
    1: 
    1: #define GRANTED "granted"
    1: #define DENIED "denied"
    1: #define SUBJECTNAME "subjectName"
    1: 
    1:     grantedPref.AppendLiteral(GRANTED);
    1:     if (grantedPref.Length() != prefLen + sizeof(GRANTED) - 1) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     deniedPref.AppendLiteral(DENIED);
    1:     if (deniedPref.Length() != prefLen + sizeof(DENIED) - 1) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     subjectNamePref.AppendLiteral(SUBJECTNAME);
    1:     if (subjectNamePref.Length() != prefLen + sizeof(SUBJECTNAME) - 1) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1: #undef SUBJECTNAME
    1: #undef DENIED
    1: #undef GRANTED
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsScriptSecurityManager::InitPrincipals(PRUint32 aPrefCount, const char** aPrefNames,
    1:                                         nsISecurityPref* aSecurityPref)
    1: {
    1:     /* This is the principal preference syntax:
    1:      * capability.principal.[codebase|codebaseTrusted|certificate].<name>.[id|granted|denied]
    1:      * For example:
    1:      * user_pref("capability.principal.certificate.p1.id","12:34:AB:CD");
    1:      * user_pref("capability.principal.certificate.p1.granted","Capability1 Capability2");
    1:      * user_pref("capability.principal.certificate.p1.denied","Capability3");
    1:      */
    1: 
    1:     /* codebaseTrusted means a codebase principal that can enable capabilities even if
    1:      * codebase principals are disabled. Don't use trustedCodebase except with unspoofable
    1:      * URLs such as HTTPS URLs.
    1:      */
    1: 
    1:     static const char idSuffix[] = ".id";
    1:     for (PRUint32 c = 0; c < aPrefCount; c++)
    1:     {
    1:         PRInt32 prefNameLen = PL_strlen(aPrefNames[c]) - 
    1:             (NS_ARRAY_LENGTH(idSuffix) - 1);
    1:         if (PL_strcasecmp(aPrefNames[c] + prefNameLen, idSuffix) != 0)
    1:             continue;
    1: 
    1:         nsXPIDLCString id;
    1:         if (NS_FAILED(mSecurityPref->SecurityGetCharPref(aPrefNames[c], getter_Copies(id))))
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         nsCAutoString grantedPrefName;
    1:         nsCAutoString deniedPrefName;
    1:         nsCAutoString subjectNamePrefName;
    1:         nsresult rv = GetPrincipalPrefNames(aPrefNames[c],
    1:                                             grantedPrefName,
    1:                                             deniedPrefName,
    1:                                             subjectNamePrefName);
    1:         if (rv == NS_ERROR_OUT_OF_MEMORY)
    1:             return rv;
    1:         if (NS_FAILED(rv))
    1:             continue;
    1: 
    1:         nsXPIDLCString grantedList;
    1:         mSecurityPref->SecurityGetCharPref(grantedPrefName.get(),
    1:                                            getter_Copies(grantedList));
    1:         nsXPIDLCString deniedList;
    1:         mSecurityPref->SecurityGetCharPref(deniedPrefName.get(),
    1:                                            getter_Copies(deniedList));
    1:         nsXPIDLCString subjectName;
    1:         mSecurityPref->SecurityGetCharPref(subjectNamePrefName.get(),
    1:                                            getter_Copies(subjectName));
    1: 
    1:         //-- Delete prefs if their value is the empty string
    1:         if (id.IsEmpty() || (grantedList.IsEmpty() && deniedList.IsEmpty()))
    1:         {
    1:             mSecurityPref->SecurityClearUserPref(aPrefNames[c]);
    1:             mSecurityPref->SecurityClearUserPref(grantedPrefName.get());
    1:             mSecurityPref->SecurityClearUserPref(deniedPrefName.get());
    1:             mSecurityPref->SecurityClearUserPref(subjectNamePrefName.get());
    1:             continue;
    1:         }
    1: 
    1:         //-- Create a principal based on the prefs
    1:         static const char certificateName[] = "capability.principal.certificate";
    1:         static const char codebaseName[] = "capability.principal.codebase";
    1:         static const char codebaseTrustedName[] = "capability.principal.codebaseTrusted";
    1: 
    1:         PRBool isCert = PR_FALSE;
    1:         PRBool isTrusted = PR_FALSE;
    1:         
    1:         if (PL_strncmp(aPrefNames[c], certificateName,
    1:                        sizeof(certificateName) - 1) == 0)
    1:         {
    1:             isCert = PR_TRUE;
    1:         }
    1:         else if (PL_strncmp(aPrefNames[c], codebaseName,
    1:                             sizeof(codebaseName) - 1) == 0)
    1:         {
    1:             isTrusted = (PL_strncmp(aPrefNames[c], codebaseTrustedName,
    1:                                     sizeof(codebaseTrustedName) - 1) == 0);
    1:         }
    1:         else
    1:         {
    1:           NS_ERROR("Not a codebase or a certificate?!");
    1:         }
    1: 
    1:         nsRefPtr<nsPrincipal> newPrincipal = new nsPrincipal();
    1:         if (!newPrincipal)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         rv = newPrincipal->InitFromPersistent(aPrefNames[c], id, subjectName,
    1:                                               EmptyCString(),
    1:                                               grantedList, deniedList, nsnull, 
    1:                                               isCert, isTrusted);
    1:         if (NS_SUCCEEDED(rv))
    1:             mPrincipals.Put(newPrincipal, newPrincipal);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: const char nsScriptSecurityManager::sJSEnabledPrefName[] =
    1:     "javascript.enabled";
 5766: const char nsScriptSecurityManager::sFileOriginPolicyPrefName[] =
13414:     "security.fileuri.strict_origin_policy";
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1: const char nsScriptSecurityManager::sXPCDefaultGrantAllName[] =
    1:     "security.classID.allowByDefault";
    1: #endif
    1: 
    1: inline void
 5766: nsScriptSecurityManager::ScriptSecurityPrefChanged()
    1: {
23434:     // JavaScript defaults to enabled in failure cases.
23434:     mIsJavaScriptEnabled = PR_TRUE;
23434: 
23434:     sStrictFileOriginPolicy = PR_TRUE;
23434: 
23434: #ifdef XPC_IDISPATCH_SUPPORT
23434:     // Granting XPC Priveleges defaults to disabled in failure cases.
23434:     mXPCDefaultGrantAll = PR_FALSE;
23434: #endif
23434: 
23434:     nsresult rv;
23434:     if (!mSecurityPref) {
23434:         rv = InitPrefs();
23434:         if (NS_FAILED(rv))
23434:             return;
23434:     }
23434: 
    1:     PRBool temp;
23434:     rv = mSecurityPref->SecurityGetBoolPref(sJSEnabledPrefName, &temp);
23434:     if (NS_SUCCEEDED(rv))
23434:         mIsJavaScriptEnabled = temp;
23434: 
13414:     rv = mSecurityPref->SecurityGetBoolPref(sFileOriginPolicyPrefName, &temp);
23434:     if (NS_SUCCEEDED(rv))
13414:         sStrictFileOriginPolicy = NS_SUCCEEDED(rv) && temp;
    1: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     rv = mSecurityPref->SecurityGetBoolPref(sXPCDefaultGrantAllName, &temp);
23434:     if (NS_SUCCEEDED(rv))
23434:         mXPCDefaultGrantAll = temp;
    1: #endif
    1: }
    1: 
    1: nsresult
    1: nsScriptSecurityManager::InitPrefs()
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIPrefService> prefService(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     rv = prefService->GetBranch(nsnull, getter_AddRefs(mPrefBranch));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     nsCOMPtr<nsIPrefBranch2> prefBranchInternal(do_QueryInterface(mPrefBranch, &rv));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     mSecurityPref = do_QueryInterface(mPrefBranch, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Set the initial value of the "javascript.enabled" prefs
 5766:     ScriptSecurityPrefChanged();
    1:     // set observer callbacks in case the value of the prefs change
    1:     prefBranchInternal->AddObserver(sJSEnabledPrefName, this, PR_FALSE);
 5766:     prefBranchInternal->AddObserver(sFileOriginPolicyPrefName, this, PR_FALSE);
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     prefBranchInternal->AddObserver(sXPCDefaultGrantAllName, this, PR_FALSE);
    1: #endif
    1:     PRUint32 prefCount;
    1:     char** prefNames;
    1: 
    1:     // Set a callback for policy pref changes
    1:     prefBranchInternal->AddObserver(sPolicyPrefix, this, PR_FALSE);
    1: 
    1:     //-- Initialize the principals database from prefs
    1:     rv = mPrefBranch->GetChildList(sPrincipalPrefix, &prefCount, &prefNames);
    1:     if (NS_SUCCEEDED(rv) && prefCount > 0)
    1:     {
    1:         rv = InitPrincipals(prefCount, (const char**)prefNames, mSecurityPref);
    1:         NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, prefNames);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     //-- Set a callback for principal changes
    1:     prefBranchInternal->AddObserver(sPrincipalPrefix, this, PR_FALSE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////////
    1: // The following code prints the contents of the policy DB to the console.
    1: #ifdef DEBUG_CAPS_HACKER
    1: 
    1: //typedef PLDHashOperator
20261: //(* PLDHashEnumerator)(PLDHashTable *table, PLDHashEntryHdr *hdr,
    1: //                      PRUint32 number, void *arg);
20261: static PLDHashOperator
    1: PrintPropertyPolicy(PLDHashTable *table, PLDHashEntryHdr *entry,
    1:                     PRUint32 number, void *arg)
    1: {
    1:     PropertyPolicy* pp = (PropertyPolicy*)entry;
    1:     nsCAutoString prop("        ");
    1:     JSContext* cx = (JSContext*)arg;
    1:     prop.AppendInt((PRUint32)pp->key);
    1:     prop += ' ';
    1:     prop.AppendWithConversion((PRUnichar*)JSValIDToString(cx, pp->key));
    1:     prop += ": Get=";
    1:     if (SECURITY_ACCESS_LEVEL_FLAG(pp->mGet))
    1:         prop.AppendInt(pp->mGet.level);
    1:     else
    1:         prop += pp->mGet.capability;
    1: 
    1:     prop += " Set=";
    1:     if (SECURITY_ACCESS_LEVEL_FLAG(pp->mSet))
    1:         prop.AppendInt(pp->mSet.level);
    1:     else
    1:         prop += pp->mSet.capability;
    1:         
    1:     printf("%s.\n", prop.get());
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
20261: static PLDHashOperator
    1: PrintClassPolicy(PLDHashTable *table, PLDHashEntryHdr *entry,
    1:                  PRUint32 number, void *arg)
    1: {
    1:     ClassPolicy* cp = (ClassPolicy*)entry;
    1:     printf("    %s\n", cp->key);
    1: 
    1:     PL_DHashTableEnumerate(cp->mPolicy, PrintPropertyPolicy, arg);
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
    1: // typedef PRBool
20261: // (* nsHashtableEnumFunc)(nsHashKey *aKey, void *aData, void* aClosure);
20261: static PRBool
    1: PrintDomainPolicy(nsHashKey *aKey, void *aData, void* aClosure)
    1: {
    1:     DomainEntry* de = (DomainEntry*)aData;
    1:     printf("----------------------------\n");
    1:     printf("Domain: %s Policy Name: %s.\n", de->mOrigin.get(),
    1:            de->mPolicyName_DEBUG.get());
    1:     PL_DHashTableEnumerate(de->mDomainPolicy, PrintClassPolicy, aClosure);
    1:     return PR_TRUE;
    1: }
    1: 
20261: static PRBool
    1: PrintCapability(nsHashKey *aKey, void *aData, void* aClosure)
    1: {
    1:     char* cap = (char*)aData;
    1:     printf("    %s.\n", cap);
    1:     return PR_TRUE;
    1: }
    1: 
    1: void
    1: nsScriptSecurityManager::PrintPolicyDB()
    1: {
    1:     printf("############## Security Policies ###############\n");
    1:     if(mOriginToPolicyMap)
    1:     {
    1:         JSContext* cx = GetCurrentJSContext();
    1:         if (!cx)
    1:             cx = GetSafeJSContext();
    1:         printf("----------------------------\n");
    1:         printf("Domain: Default.\n");
    1:         PL_DHashTableEnumerate(mDefaultPolicy, PrintClassPolicy, (void*)cx);
    1:         mOriginToPolicyMap->Enumerate(PrintDomainPolicy, (void*)cx);
    1:     }
    1:     printf("############ End Security Policies #############\n\n");
    1:     printf("############## Capabilities ###############\n");
    1:     mCapabilities->Enumerate(PrintCapability);
    1:     printf("############## End Capabilities ###############\n");
    1: }
    1: #endif
