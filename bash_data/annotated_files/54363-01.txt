    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Veditz <dveditz@netscape.com>
    1:  *   Samir Gehani <sgehani@netscape.com>
    1:  *   Mitch Stoltz <mstoltz@netsape.com>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Jeff Walden <jwalden+code@mit.edu>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include <string.h>
    1: #include "nsJARInputStream.h"
    1: #include "nsJAR.h"
    1: #include "nsILocalFile.h"
    1: #include "nsIConsoleService.h"
    1: #include "nsICryptoHash.h"
    1: #include "prprf.h"
52345: #include "mozilla/Omnijar.h"
    1: 
    1: #ifdef XP_UNIX
    1:   #include <sys/stat.h>
    1: #elif defined (XP_WIN) || defined(XP_OS2)
    1:   #include <io.h>
    1: #endif
    1: 
    1: //----------------------------------------------
    1: // nsJARManifestItem declaration
    1: //----------------------------------------------
    1: /*
    1:  * nsJARManifestItem contains meta-information pertaining 
    1:  * to an individual JAR entry, taken from the 
    1:  * META-INF/MANIFEST.MF and META-INF/ *.SF files.
    1:  * This is security-critical information, defined here so it is not
    1:  * accessible from anywhere else.
    1:  */
    1: typedef enum
    1: {
    1:   JAR_INVALID       = 1,
    1:   JAR_INTERNAL      = 2,
    1:   JAR_EXTERNAL      = 3
    1: } JARManifestItemType;
    1: 
    1: class nsJARManifestItem
    1: {
    1: public:
    1:   JARManifestItemType mType;
    1: 
    1:   // True if the second step of verification (VerifyEntry) 
    1:   // has taken place:
    1:   PRBool              entryVerified;
    1:   
    1:   // Not signed, valid, or failure code
    1:   PRInt16             status;
    1:   
    1:   // Internal storage of digests
27026:   nsCString           calculatedSectionDigest;
27026:   nsCString           storedEntryDigest;
    1: 
    1:   nsJARManifestItem();
    1:   virtual ~nsJARManifestItem();
    1: };
    1: 
    1: //-------------------------------------------------
    1: // nsJARManifestItem constructors and destructor
    1: //-------------------------------------------------
    1: nsJARManifestItem::nsJARManifestItem(): mType(JAR_INTERNAL),
    1:                                         entryVerified(PR_FALSE),
27026:                                         status(JAR_NOT_SIGNED)
    1: {
    1: }
    1: 
    1: nsJARManifestItem::~nsJARManifestItem()
    1: {
    1: }
    1: 
    1: //----------------------------------------------
    1: // nsJAR constructor/destructor
    1: //----------------------------------------------
20261: static PRBool
    1: DeleteManifestEntry(nsHashKey* aKey, void* aData, void* closure)
    1: {
    1: //-- deletes an entry in  mManifestData.
    1:   delete (nsJARManifestItem*)aData;
    1:   return PR_TRUE;
    1: }
    1: 
    1: // The following initialization makes a guess of 10 entries per jarfile.
52345: nsJAR::nsJAR(): mZip(new nsZipArchive()),
52345:                 mManifestData(nsnull, nsnull, DeleteManifestEntry, nsnull, 10),
    1:                 mParsedManifest(PR_FALSE),
    1:                 mGlobalStatus(JAR_MANIFEST_NOT_PARSED),
    1:                 mReleaseTime(PR_INTERVAL_NO_TIMEOUT), 
    1:                 mCache(nsnull), 
    1:                 mLock(nsnull),
    1:                 mTotalItemsInManifest(0)
    1: {
    1: }
    1: 
    1: nsJAR::~nsJAR()
    1: {
    1:   Close();
    1: }
    1: 
39049: NS_IMPL_THREADSAFE_QUERY_INTERFACE1(nsJAR, nsIZipReader)
    1: NS_IMPL_THREADSAFE_ADDREF(nsJAR)
    1: 
    1: // Custom Release method works with nsZipReaderCache...
    1: nsrefcnt nsJAR::Release(void) 
    1: {
    1:   nsrefcnt count; 
    1:   NS_PRECONDITION(0 != mRefCnt, "dup release"); 
    1:   count = PR_AtomicDecrement((PRInt32 *)&mRefCnt); 
    1:   NS_LOG_RELEASE(this, count, "nsJAR"); 
    1:   if (0 == count) {
    1:     mRefCnt = 1; /* stabilize */ 
    1:     /* enable this to find non-threadsafe destructors: */ 
    1:     /* NS_ASSERT_OWNINGTHREAD(nsJAR); */ 
47223:     delete this;
    1:     return 0; 
    1:   }
    1:   else if (1 == count && mCache) {
    1:     nsresult rv = mCache->ReleaseZip(this);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "failed to release zip file");
    1:   }
    1:   return count; 
    1: } 
    1: 
    1: //----------------------------------------------
    1: // nsIZipReader implementation
    1: //----------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsJAR::Open(nsIFile* zipFile)
    1: {
24060:   NS_ENSURE_ARG_POINTER(zipFile);
    1:   if (mLock) return NS_ERROR_FAILURE; // Already open!
    1: 
    1:   mZipFile = zipFile;
20028: 
    1:   mLock = PR_NewLock();
    1:   NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
    1:   
52345: #ifdef MOZ_OMNIJAR
52345:   // The omnijar is special, it is opened early on and closed late
52345:   // this avoids reopening it
52345:   PRBool equals;
52345:   nsresult rv = zipFile->Equals(mozilla::OmnijarPath(), &equals);
52345:   if (NS_SUCCEEDED(rv) && equals) {
52345:     mZip = mozilla::OmnijarReader();
52345:     return NS_OK;
52345:   }
52345: #endif
52345:   return mZip->OpenArchive(zipFile);
    1: }
    1: 
    1: NS_IMETHODIMP
52251: nsJAR::OpenInner(nsIZipReader *aZipReader, const char *aZipEntry)
52251: {
52251:   NS_ENSURE_ARG_POINTER(aZipReader);
52251:   NS_ENSURE_ARG_POINTER(aZipEntry);
52251:   if (mLock) return NS_ERROR_FAILURE; // Already open!
52251: 
54363:   PRBool exist;
54363:   nsresult rv = aZipReader->HasEntry(nsDependentCString(aZipEntry), &exist);
54363:   NS_ENSURE_SUCCESS(rv, rv);
54363:   NS_ENSURE_TRUE(exist, NS_ERROR_FILE_NOT_FOUND);
54363: 
54363:   rv = aZipReader->GetFile(getter_AddRefs(mZipFile));
52251:   NS_ENSURE_SUCCESS(rv, rv);
52251: 
52251:   mLock = PR_NewLock();
52251:   NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
52251: 
52251:   mOuterZipEntry.Assign(aZipEntry);
52251: 
52251:   nsRefPtr<nsZipHandle> handle;
52345:   rv = nsZipHandle::Init(static_cast<nsJAR*>(aZipReader)->mZip.get(), aZipEntry,
52251:                          getter_AddRefs(handle));
52251:   if (NS_FAILED(rv))
52251:     return rv;
52251: 
52345:   return mZip->OpenArchive(handle);
52251: }
52251: 
52251: NS_IMETHODIMP
    1: nsJAR::GetFile(nsIFile* *result)
    1: {
    1:   *result = mZipFile;
    1:   NS_IF_ADDREF(*result);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJAR::Close()
    1: {
    1:   if (mLock) {
    1:     PR_DestroyLock(mLock);
    1:     mLock = nsnull;
    1:   }
    1: 
    1:   mParsedManifest = PR_FALSE;
21614:   mManifestData.Reset();
    1:   mGlobalStatus = JAR_MANIFEST_NOT_PARSED;
    1:   mTotalItemsInManifest = 0;
52251:   mOuterZipEntry.Truncate(0);
    1: 
52345: #ifdef MOZ_OMNIJAR
52345:   if (mZip == mozilla::OmnijarReader()) {
52345:     mZip.forget();
52345:     mZip = new nsZipArchive();
52345:     return NS_OK;
52345:   }
52345: #endif
52345:   return mZip->CloseArchive();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJAR::Test(const char *aEntryName)
    1: {
52345:   return mZip->Test(aEntryName);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJAR::Extract(const char *zipEntry, nsIFile* outFile)
    1: {
    1:   // nsZipArchive and zlib are not thread safe
    1:   // we need to use a lock to prevent bug #51267
    1:   nsAutoLock lock(mLock);
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(outFile, &rv);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
52345:   nsZipItem *item = mZip->GetItem(zipEntry);
    1:   NS_ENSURE_TRUE(item, NS_ERROR_FILE_TARGET_DOES_NOT_EXIST);
    1: 
    1:   // Remove existing file or directory so we set permissions correctly.
    1:   // If it's a directory that already exists and contains files, throw
    1:   // an exception and return.
    1: 
    1:   //XXX Bug 332139:
    1:   //XXX If we guarantee that rv in the case of a non-empty directory
    1:   //XXX is always FILE_DIR_NOT_EMPTY, we can remove
    1:   //XXX |rv == NS_ERROR_FAILURE| - bug 322183 needs to be completely
    1:   //XXX fixed before that can happen
    1:   rv = localFile->Remove(PR_FALSE);
    1:   if (rv == NS_ERROR_FILE_DIR_NOT_EMPTY ||
    1:       rv == NS_ERROR_FAILURE)
    1:     return rv;
    1: 
33990:   if (item->IsDirectory())
    1:   {
33990:     rv = localFile->Create(nsIFile::DIRECTORY_TYPE, item->Mode());
    1:     //XXX Do this in nsZipArchive?  It would be nice to keep extraction
    1:     //XXX code completely there, but that would require a way to get a
    1:     //XXX PRDir from localFile.
    1:   }
    1:   else
    1:   {
    1:     PRFileDesc* fd;
33990:     rv = localFile->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE, item->Mode(), &fd);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // ExtractFile also closes the fd handle and resolves the symlink if needed
    1:     nsCAutoString path;
    1:     rv = outFile->GetNativePath(path);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
52345:     rv = mZip->ExtractFile(item, path.get(), fd);
    1:   }
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   // nsIFile needs milliseconds, while prtime is in microseconds.
    1:   // non-fatal if this fails, ignore errors
37369:   outFile->SetLastModifiedTime(item->LastModTime() / PR_USEC_PER_MSEC);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsJAR::GetEntry(const char *aEntryName, nsIZipEntry* *result)
    1: {
52345:   nsZipItem* zipItem = mZip->GetItem(aEntryName);
    1:   NS_ENSURE_TRUE(zipItem, NS_ERROR_FILE_TARGET_DOES_NOT_EXIST);
    1: 
    1:   nsJARItem* jarItem = new nsJARItem(zipItem);
    1:   NS_ENSURE_TRUE(jarItem, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   NS_ADDREF(*result = jarItem);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJAR::HasEntry(const nsACString &aEntryName, PRBool *result)
    1: {
52345:   *result = mZip->GetItem(PromiseFlatCString(aEntryName).get()) != nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJAR::FindEntries(const char *aPattern, nsIUTF8StringEnumerator **result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1: 
    1:   nsZipFind *find;
52345:   nsresult rv = mZip->FindInit(aPattern, &find);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsIUTF8StringEnumerator *zipEnum = new nsJAREnumerator(find);
    1:   if (!zipEnum) {
    1:     delete find;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   NS_ADDREF(*result = zipEnum);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJAR::GetInputStream(const char* aFilename, nsIInputStream** result)
    1: {
    1:   return GetInputStreamWithSpec(EmptyCString(), aFilename, result);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJAR::GetInputStreamWithSpec(const nsACString& aJarDirSpec, 
    1:                           const char* aEntryName, nsIInputStream** result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEntryName);
    1:   NS_ENSURE_ARG_POINTER(result);
    1: 
    1:   // Watch out for the jar:foo.zip!/ (aDir is empty) top-level special case!
    1:   nsZipItem *item = nsnull;
    1:   if (*aEntryName) {
    1:     // First check if item exists in jar
52345:     item = mZip->GetItem(aEntryName);
    1:     if (!item) return NS_ERROR_FILE_TARGET_DOES_NOT_EXIST;
    1:   }
    1:   nsJARInputStream* jis = new nsJARInputStream();
    1:   // addref now so we can call InitFile/InitDirectory()
    1:   NS_ENSURE_TRUE(jis, NS_ERROR_OUT_OF_MEMORY);
    1:   NS_ADDREF(*result = jis);
    1: 
    1:   nsresult rv = NS_OK;
33990:   if (!item || item->IsDirectory()) {
31399:     rv = jis->InitDirectory(this, aJarDirSpec, aEntryName);
    1:   } else {
33443:     rv = jis->InitFile(this, item);
    1:   }
    1:   if (NS_FAILED(rv)) {
    1:     NS_RELEASE(*result);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJAR::GetCertificatePrincipal(const char* aFilename, nsIPrincipal** aPrincipal)
    1: {
    1:   //-- Parameter check
    1:   if (!aPrincipal)
    1:     return NS_ERROR_NULL_POINTER;
    1:   *aPrincipal = nsnull;
    1: 
    1:   //-- Parse the manifest
21764:   nsresult rv = ParseManifest();
    1:   if (NS_FAILED(rv)) return rv;
    1:   if (mGlobalStatus == JAR_NO_MANIFEST)
    1:     return NS_OK;
    1: 
    1:   PRInt16 requestedStatus;
    1:   if (aFilename)
    1:   {
    1:     //-- Find the item
    1:     nsCStringKey key(aFilename);
 3233:     nsJARManifestItem* manItem = static_cast<nsJARManifestItem*>(mManifestData.Get(&key));
    1:     if (!manItem)
    1:       return NS_OK;
    1:     //-- Verify the item against the manifest
    1:     if (!manItem->entryVerified)
    1:     {
    1:       nsXPIDLCString entryData;
    1:       PRUint32 entryDataLen;
    1:       rv = LoadEntry(aFilename, getter_Copies(entryData), &entryDataLen);
    1:       if (NS_FAILED(rv)) return rv;
    1:       rv = VerifyEntry(manItem, entryData, entryDataLen);
    1:       if (NS_FAILED(rv)) return rv;
    1:     }
    1:     requestedStatus = manItem->status;
    1:   }
    1:   else // User wants identity of signer w/o verifying any entries
    1:     requestedStatus = mGlobalStatus;
    1: 
    1:   if (requestedStatus != JAR_VALID_MANIFEST)
    1:     ReportError(aFilename, requestedStatus);
    1:   else // Valid signature
    1:   {
    1:     *aPrincipal = mPrincipal;
    1:     NS_IF_ADDREF(*aPrincipal);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsJAR::GetManifestEntriesCount(PRUint32* count)
    1: {
    1:   *count = mTotalItemsInManifest;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJAR::GetJarPath(nsACString& aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(mZipFile);
    1: 
    1:   return mZipFile->GetNativePath(aResult);
    1: }
    1: 
    1: //----------------------------------------------
    1: // nsJAR private implementation
    1: //----------------------------------------------
    1: nsresult 
    1: nsJAR::LoadEntry(const char* aFilename, char** aBuf, PRUint32* aBufLen)
    1: {
    1:   //-- Get a stream for reading the file
    1:   nsresult rv;
    1:   nsCOMPtr<nsIInputStream> manifestStream;
    1:   rv = GetInputStream(aFilename, getter_AddRefs(manifestStream));
    1:   if (NS_FAILED(rv)) return NS_ERROR_FILE_TARGET_DOES_NOT_EXIST;
    1:   
    1:   //-- Read the manifest file into memory
    1:   char* buf;
    1:   PRUint32 len;
    1:   rv = manifestStream->Available(&len);
    1:   if (NS_FAILED(rv)) return rv;
    1:   if (len == PRUint32(-1))
    1:     return NS_ERROR_FILE_CORRUPTED; // bug 164695
42429:   buf = (char*)malloc(len+1);
    1:   if (!buf) return NS_ERROR_OUT_OF_MEMORY;
    1:   PRUint32 bytesRead;
    1:   rv = manifestStream->Read(buf, len, &bytesRead);
    1:   if (bytesRead != len) 
    1:     rv = NS_ERROR_FILE_CORRUPTED;
    1:   if (NS_FAILED(rv)) {
42429:     free(buf);
    1:     return rv;
    1:   }
    1:   buf[len] = '\0'; //Null-terminate the buffer
    1:   *aBuf = buf;
    1:   if (aBufLen)
    1:     *aBufLen = len;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: PRInt32
    1: nsJAR::ReadLine(const char** src)
    1: {
    1:   //--Moves pointer to beginning of next line and returns line length
    1:   //  not including CR/LF.
    1:   PRInt32 length;
    1:   char* eol = PL_strpbrk(*src, "\r\n");
    1: 
    1:   if (eol == nsnull) // Probably reached end of file before newline
    1:   {
    1:     length = PL_strlen(*src);
    1:     if (length == 0) // immediate end-of-file
    1:       *src = nsnull;
    1:     else             // some data left on this line
    1:       *src += length;
    1:   }
    1:   else
    1:   {
    1:     length = eol - *src;
    1:     if (eol[0] == '\r' && eol[1] == '\n')      // CR LF, so skip 2
    1:       *src = eol+2;
    1:     else                                       // Either CR or LF, so skip 1
    1:       *src = eol+1;
    1:   }
    1:   return length;
    1: }
    1: 
    1: //-- The following #defines are used by ParseManifest()
    1: //   and ParseOneFile(). The header strings are defined in the JAR specification.
    1: #define JAR_MF 1
    1: #define JAR_SF 2
    1: #define JAR_MF_SEARCH_STRING "(M|/M)ETA-INF/(M|m)(ANIFEST|anifest).(MF|mf)$"
    1: #define JAR_SF_SEARCH_STRING "(M|/M)ETA-INF/*.(SF|sf)$"
    1: #define JAR_MF_HEADER (const char*)"Manifest-Version: 1.0"
    1: #define JAR_SF_HEADER (const char*)"Signature-Version: 1.0"
    1: 
    1: nsresult
21764: nsJAR::ParseManifest()
    1: {
    1:   //-- Verification Step 1
    1:   if (mParsedManifest)
    1:     return NS_OK;
    1:   //-- (1)Manifest (MF) file
    1:   nsCOMPtr<nsIUTF8StringEnumerator> files;
    1:   nsresult rv = FindEntries(JAR_MF_SEARCH_STRING, getter_AddRefs(files));
    1:   if (!files) rv = NS_ERROR_FAILURE;
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   //-- Load the file into memory
    1:   PRBool more;
    1:   rv = files->HasMore(&more);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (!more)
    1:   {
    1:     mGlobalStatus = JAR_NO_MANIFEST;
    1:     mParsedManifest = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCAutoString manifestFilename;
    1:   rv = files->GetNext(manifestFilename);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Check if there is more than one manifest, if so then error!
    1:   rv = files->HasMore(&more);
    1:   if (NS_FAILED(rv)) return rv;
    1:   if (more)
    1:   {
    1:     mParsedManifest = PR_TRUE;
    1:     return NS_ERROR_FILE_CORRUPTED; // More than one MF file
    1:   }
    1: 
    1:   nsXPIDLCString manifestBuffer;
    1:   PRUint32 manifestLen;
    1:   rv = LoadEntry(manifestFilename.get(), getter_Copies(manifestBuffer), &manifestLen);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   //-- Parse it
    1:   rv = ParseOneFile(manifestBuffer, JAR_MF);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   //-- (2)Signature (SF) file
    1:   // If there are multiple signatures, we select one.
    1:   rv = FindEntries(JAR_SF_SEARCH_STRING, getter_AddRefs(files));
    1:   if (!files) rv = NS_ERROR_FAILURE;
    1:   if (NS_FAILED(rv)) return rv;
    1:   //-- Get an SF file
    1:   rv = files->HasMore(&more);
    1:   if (NS_FAILED(rv)) return rv;
    1:   if (!more)
    1:   {
    1:     mGlobalStatus = JAR_NO_MANIFEST;
    1:     mParsedManifest = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1:   rv = files->GetNext(manifestFilename);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = LoadEntry(manifestFilename.get(), getter_Copies(manifestBuffer), &manifestLen);
    1:   if (NS_FAILED(rv)) return rv;
    1:   
    1:   //-- Get its corresponding signature file
    1:   nsCAutoString sigFilename(manifestFilename);
    1:   PRInt32 extension = sigFilename.RFindChar('.') + 1;
    1:   NS_ASSERTION(extension != 0, "Manifest Parser: Missing file extension.");
    1:   (void)sigFilename.Cut(extension, 2);
    1:   nsXPIDLCString sigBuffer;
    1:   PRUint32 sigLen;
    1:   {
    1:     nsCAutoString tempFilename(sigFilename); tempFilename.Append("rsa", 3);
    1:     rv = LoadEntry(tempFilename.get(), getter_Copies(sigBuffer), &sigLen);
    1:   }
    1:   if (NS_FAILED(rv))
    1:   {
    1:     nsCAutoString tempFilename(sigFilename); tempFilename.Append("RSA", 3);
    1:     rv = LoadEntry(tempFilename.get(), getter_Copies(sigBuffer), &sigLen);
    1:   }
    1:   if (NS_FAILED(rv))
    1:   {
    1:     mGlobalStatus = JAR_NO_MANIFEST;
    1:     mParsedManifest = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1: 
21764:   //-- Get the signature verifier service
21764:   nsCOMPtr<nsISignatureVerifier> verifier = 
21764:            do_GetService(SIGNATURE_VERIFIER_CONTRACTID, &rv);
21764:   if (NS_FAILED(rv)) // No signature verifier available
21764:   {
21764:     mGlobalStatus = JAR_NO_MANIFEST;
21764:     mParsedManifest = PR_TRUE;
21764:     return NS_OK;
21764:   }
21764: 
    1:   //-- Verify that the signature file is a valid signature of the SF file
    1:   PRInt32 verifyError;
    1:   rv = verifier->VerifySignature(sigBuffer, sigLen, manifestBuffer, manifestLen, 
    1:                                  &verifyError, getter_AddRefs(mPrincipal));
    1:   if (NS_FAILED(rv)) return rv;
    1:   if (mPrincipal && verifyError == 0)
    1:     mGlobalStatus = JAR_VALID_MANIFEST;
    1:   else if (verifyError == nsISignatureVerifier::VERIFY_ERROR_UNKNOWN_CA)
    1:     mGlobalStatus = JAR_INVALID_UNKNOWN_CA;
    1:   else
    1:     mGlobalStatus = JAR_INVALID_SIG;
    1: 
    1:   //-- Parse the SF file. If the verification above failed, principal
    1:   // is null, and ParseOneFile will mark the relevant entries as invalid.
    1:   // if ParseOneFile fails, then it has no effect, and we can safely 
    1:   // continue to the next SF file, or return. 
    1:   ParseOneFile(manifestBuffer, JAR_SF);
    1:   mParsedManifest = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJAR::ParseOneFile(const char* filebuf, PRInt16 aFileType)
    1: {
    1:   //-- Check file header
    1:   const char* nextLineStart = filebuf;
    1:   nsCAutoString curLine;
    1:   PRInt32 linelen;
    1:   linelen = ReadLine(&nextLineStart);
    1:   curLine.Assign(filebuf, linelen);
    1: 
    1:   if ( ((aFileType == JAR_MF) && !curLine.Equals(JAR_MF_HEADER) ) ||
    1:        ((aFileType == JAR_SF) && !curLine.Equals(JAR_SF_HEADER) ) )
    1:      return NS_ERROR_FILE_CORRUPTED;
    1: 
    1:   //-- Skip header section
    1:   do {
    1:     linelen = ReadLine(&nextLineStart);
    1:   } while (linelen > 0);
    1: 
    1:   //-- Set up parsing variables
    1:   const char* curPos;
    1:   const char* sectionStart = nextLineStart;
    1: 
    1:   nsJARManifestItem* curItemMF = nsnull;
    1:   PRBool foundName = PR_FALSE;
    1:   if (aFileType == JAR_MF)
    1:     if (!(curItemMF = new nsJARManifestItem()))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsCAutoString curItemName;
    1:   nsCAutoString storedSectionDigest;
    1: 
    1:   for(;;)
    1:   {
    1:     curPos = nextLineStart;
    1:     linelen = ReadLine(&nextLineStart);
    1:     curLine.Assign(curPos, linelen);
    1:     if (linelen == 0) 
    1:     // end of section (blank line or end-of-file)
    1:     {
    1:       if (aFileType == JAR_MF)
    1:       {
    1:         mTotalItemsInManifest++;
    1:         if (curItemMF->mType != JAR_INVALID)
    1:         { 
    1:           //-- Did this section have a name: line?
    1:           if(!foundName)
    1:             curItemMF->mType = JAR_INVALID;
    1:           else 
    1:           {
    1:             //-- If it's an internal item, it must correspond 
    1:             //   to a valid jar entry
    1:             if (curItemMF->mType == JAR_INTERNAL)
    1:             {
    1:               PRBool exists;
33668:               nsresult rv = HasEntry(curItemName, &exists);
33668:               if (NS_FAILED(rv) || !exists)
    1:                 curItemMF->mType = JAR_INVALID;
    1:             }
    1:             //-- Check for duplicates
    1:             nsCStringKey key(curItemName);
    1:             if (mManifestData.Exists(&key))
    1:               curItemMF->mType = JAR_INVALID;
    1:           }
    1:         }
    1: 
    1:         if (curItemMF->mType == JAR_INVALID)
    1:           delete curItemMF;
    1:         else //-- calculate section digest
    1:         {
    1:           PRUint32 sectionLength = curPos - sectionStart;
    1:           CalculateDigest(sectionStart, sectionLength,
27026:                           curItemMF->calculatedSectionDigest);
    1:           //-- Save item in the hashtable
    1:           nsCStringKey itemKey(curItemName);
    1:           mManifestData.Put(&itemKey, (void*)curItemMF);
    1:         }
    1:         if (nextLineStart == nsnull) // end-of-file
    1:           break;
    1: 
    1:         sectionStart = nextLineStart;
    1:         if (!(curItemMF = new nsJARManifestItem()))
    1:           return NS_ERROR_OUT_OF_MEMORY;
    1:       } // (aFileType == JAR_MF)
    1:       else
    1:         //-- file type is SF, compare digest with calculated 
    1:         //   section digests from MF file.
    1:       {
    1:         if (foundName)
    1:         {
    1:           nsJARManifestItem* curItemSF;
    1:           nsCStringKey key(curItemName);
    1:           curItemSF = (nsJARManifestItem*)mManifestData.Get(&key);
    1:           if(curItemSF)
    1:           {
    1:             NS_ASSERTION(curItemSF->status == JAR_NOT_SIGNED,
    1:                          "SECURITY ERROR: nsJARManifestItem not correctly initialized");
    1:             curItemSF->status = mGlobalStatus;
    1:             if (curItemSF->status == JAR_VALID_MANIFEST)
    1:             { // Compare digests
    1:               if (storedSectionDigest.IsEmpty())
    1:                 curItemSF->status = JAR_NOT_SIGNED;
    1:               else
    1:               {
27026:                 if (!storedSectionDigest.Equals(curItemSF->calculatedSectionDigest))
    1:                   curItemSF->status = JAR_INVALID_MANIFEST;
27026:                 curItemSF->calculatedSectionDigest.Truncate();
27026:                 storedSectionDigest.Truncate();
    1:               }
    1:             } // (aPrincipal != nsnull)
    1:           } // if(curItemSF)
    1:         } // if(foundName)
    1: 
    1:         if(nextLineStart == nsnull) // end-of-file
    1:           break;
    1:       } // aFileType == JAR_SF
    1:       foundName = PR_FALSE;
    1:       continue;
    1:     } // if(linelen == 0)
    1: 
    1:     //-- Look for continuations (beginning with a space) on subsequent lines
    1:     //   and append them to the current line.
    1:     while(*nextLineStart == ' ')
    1:     {
    1:       curPos = nextLineStart;
    1:       PRInt32 continuationLen = ReadLine(&nextLineStart) - 1;
    1:       nsCAutoString continuation(curPos+1, continuationLen);
    1:       curLine += continuation;
    1:       linelen += continuationLen;
    1:     }
    1: 
    1:     //-- Find colon in current line, this separates name from value
    1:     PRInt32 colonPos = curLine.FindChar(':');
    1:     if (colonPos == -1)    // No colon on line, ignore line
    1:       continue;
    1:     //-- Break down the line
    1:     nsCAutoString lineName;
    1:     curLine.Left(lineName, colonPos);
    1:     nsCAutoString lineData;
    1:     curLine.Mid(lineData, colonPos+2, linelen - (colonPos+2));
    1: 
    1:     //-- Lines to look for:
    1:     // (1) Digest:
27026:     if (lineName.LowerCaseEqualsLiteral("sha1-digest"))
    1:     //-- This is a digest line, save the data in the appropriate place 
    1:     {
    1:       if(aFileType == JAR_MF)
27026:         curItemMF->storedEntryDigest = lineData;
    1:       else
    1:         storedSectionDigest = lineData;
    1:       continue;
    1:     }
    1:     
    1:     // (2) Name: associates this manifest section with a file in the jar.
27026:     if (!foundName && lineName.LowerCaseEqualsLiteral("name"))
    1:     {
    1:       curItemName = lineData;
    1:       foundName = PR_TRUE;
    1:       continue;
    1:     }
    1: 
    1:     // (3) Magic: this may be an inline Javascript. 
    1:     //     We can't do any other kind of magic.
27026:     if (aFileType == JAR_MF && lineName.LowerCaseEqualsLiteral("magic"))
    1:     {
27026:       if (lineData.LowerCaseEqualsLiteral("javascript"))
    1:         curItemMF->mType = JAR_EXTERNAL;
    1:       else
    1:         curItemMF->mType = JAR_INVALID;
    1:       continue;
    1:     }
    1: 
    1:   } // for (;;)
    1:   return NS_OK;
    1: } //ParseOneFile()
    1: 
    1: nsresult
    1: nsJAR::VerifyEntry(nsJARManifestItem* aManItem, const char* aEntryData,
    1:                    PRUint32 aLen)
    1: {
    1:   if (aManItem->status == JAR_VALID_MANIFEST)
    1:   {
27026:     if (aManItem->storedEntryDigest.IsEmpty())
    1:       // No entry digests in manifest file. Entry is unsigned.
    1:       aManItem->status = JAR_NOT_SIGNED;
    1:     else
    1:     { //-- Calculate and compare digests
27026:       nsCString calculatedEntryDigest;
27026:       nsresult rv = CalculateDigest(aEntryData, aLen, calculatedEntryDigest);
    1:       if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
27026:       if (!aManItem->storedEntryDigest.Equals(calculatedEntryDigest))
    1:         aManItem->status = JAR_INVALID_ENTRY;
27026:       aManItem->storedEntryDigest.Truncate();
    1:     }
    1:   }
    1:   aManItem->entryVerified = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: void nsJAR::ReportError(const char* aFilename, PRInt16 errorCode)
    1: {
    1:   //-- Generate error message
    1:   nsAutoString message; 
    1:   message.AssignLiteral("Signature Verification Error: the signature on ");
    1:   if (aFilename)
    1:     message.AppendWithConversion(aFilename);
    1:   else
    1:     message.AppendLiteral("this .jar archive");
    1:   message.AppendLiteral(" is invalid because ");
    1:   switch(errorCode)
    1:   {
    1:   case JAR_NOT_SIGNED:
    1:     message.AppendLiteral("the archive did not contain a valid PKCS7 signature.");
    1:     break;
    1:   case JAR_INVALID_SIG:
    1:     message.AppendLiteral("the digital signature (*.RSA) file is not a valid signature of the signature instruction file (*.SF).");
    1:     break;
    1:   case JAR_INVALID_UNKNOWN_CA:
    1:     message.AppendLiteral("the certificate used to sign this file has an unrecognized issuer.");
    1:     break;
    1:   case JAR_INVALID_MANIFEST:
    1:     message.AppendLiteral("the signature instruction file (*.SF) does not contain a valid hash of the MANIFEST.MF file.");
    1:     break;
    1:   case JAR_INVALID_ENTRY:
    1:     message.AppendLiteral("the MANIFEST.MF file does not contain a valid hash of the file being verified.");
    1:     break;
    1:   case JAR_NO_MANIFEST:
    1:     message.AppendLiteral("the archive did not contain a manifest.");
    1:     break;
    1:   default:
    1:     message.AppendLiteral("of an unknown problem.");
    1:   }
    1:   
    1:   // Report error in JS console
    1:   nsCOMPtr<nsIConsoleService> console(do_GetService("@mozilla.org/consoleservice;1"));
    1:   if (console)
    1:   {
    1:     console->LogStringMessage(message.get());
    1:   }
    1: #ifdef DEBUG
    1:   char* messageCstr = ToNewCString(message);
    1:   if (!messageCstr) return;
    1:   fprintf(stderr, "%s\n", messageCstr);
    1:   nsMemory::Free(messageCstr);
    1: #endif
    1: }
    1: 
    1: 
    1: nsresult nsJAR::CalculateDigest(const char* aInBuf, PRUint32 aLen,
27026:                                 nsCString& digest)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsICryptoHash> hasher = do_CreateInstance("@mozilla.org/security/hash;1", &rv);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = hasher->Init(nsICryptoHash::SHA1);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = hasher->Update((const PRUint8*) aInBuf, aLen);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
27026:   return hasher->Finish(PR_TRUE, digest);
    1: }
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsJAREnumerator, nsIUTF8StringEnumerator)
    1:   
    1: //----------------------------------------------
    1: // nsJAREnumerator::HasMore
    1: //----------------------------------------------
    1: NS_IMETHODIMP
    1: nsJAREnumerator::HasMore(PRBool* aResult)
    1: {
    1:     // try to get the next element
33990:     if (!mName) {
    1:         NS_ASSERTION(mFind, "nsJAREnumerator: Missing zipFind.");
33990:         nsresult rv = mFind->FindNext( &mName, &mNameLen );
    1:         if (rv == NS_ERROR_FILE_TARGET_DOES_NOT_EXIST) {
    1:             *aResult = PR_FALSE;                    // No more matches available
    1:             return NS_OK;
    1:         }
    1:         NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);    // no error translation
    1:     }
    1: 
    1:     *aResult = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------
    1: // nsJAREnumerator::GetNext
    1: //----------------------------------------------
    1: NS_IMETHODIMP
    1: nsJAREnumerator::GetNext(nsACString& aResult)
    1: {
    1:     // check if the current item is "stale"
33990:     if (!mName) {
    1:         PRBool   bMore;
    1:         nsresult rv = HasMore(&bMore);
    1:         if (NS_FAILED(rv) || !bMore)
    1:             return NS_ERROR_FAILURE; // no error translation
    1:     }
33990:     aResult.Assign(mName, mNameLen);
33990:     mName = 0; // we just gave this one away
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsJARItem, nsIZipEntry)
    1: 
    1: nsJARItem::nsJARItem(nsZipItem* aZipItem)
33990:     : mSize(aZipItem->Size()),
33990:       mRealsize(aZipItem->RealSize()),
33990:       mCrc32(aZipItem->CRC32()),
37369:       mLastModTime(aZipItem->LastModTime()),
33990:       mCompression(aZipItem->Compression()),
33990:       mIsDirectory(aZipItem->IsDirectory()),
    1:       mIsSynthetic(aZipItem->isSynthetic)
    1: {
    1: }
    1: 
    1: //------------------------------------------
    1: // nsJARItem::GetCompression
    1: //------------------------------------------
    1: NS_IMETHODIMP
    1: nsJARItem::GetCompression(PRUint16 *aCompression)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCompression);
    1: 
    1:     *aCompression = mCompression;
    1:     return NS_OK;
    1: }
    1: 
    1: //------------------------------------------
    1: // nsJARItem::GetSize
    1: //------------------------------------------
    1: NS_IMETHODIMP
    1: nsJARItem::GetSize(PRUint32 *aSize)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aSize);
    1: 
    1:     *aSize = mSize;
    1:     return NS_OK;
    1: }
    1: 
    1: //------------------------------------------
    1: // nsJARItem::GetRealSize
    1: //------------------------------------------
    1: NS_IMETHODIMP
    1: nsJARItem::GetRealSize(PRUint32 *aRealsize)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aRealsize);
    1: 
    1:     *aRealsize = mRealsize;
    1:     return NS_OK;
    1: }
    1: 
    1: //------------------------------------------
    1: // nsJARItem::GetCrc32
    1: //------------------------------------------
    1: NS_IMETHODIMP
    1: nsJARItem::GetCRC32(PRUint32 *aCrc32)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCrc32);
    1: 
    1:     *aCrc32 = mCrc32;
    1:     return NS_OK;
    1: }
    1: 
    1: //------------------------------------------
    1: // nsJARItem::GetIsDirectory
    1: //------------------------------------------
    1: NS_IMETHODIMP
    1: nsJARItem::GetIsDirectory(PRBool *aIsDirectory)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aIsDirectory);
    1: 
    1:     *aIsDirectory = mIsDirectory;
    1:     return NS_OK;
    1: }
    1: 
    1: //------------------------------------------
    1: // nsJARItem::GetIsSynthetic
    1: //------------------------------------------
    1: NS_IMETHODIMP
    1: nsJARItem::GetIsSynthetic(PRBool *aIsSynthetic)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aIsSynthetic);
    1: 
    1:     *aIsSynthetic = mIsSynthetic;
    1:     return NS_OK;
    1: }
    1: 
    1: //------------------------------------------
    1: // nsJARItem::GetLastModifiedTime
    1: //------------------------------------------
    1: NS_IMETHODIMP
    1: nsJARItem::GetLastModifiedTime(PRTime* aLastModTime)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aLastModTime);
    1: 
37369:     *aLastModTime = mLastModTime;
    1:     return NS_OK;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: // nsIZipReaderCache
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS3(nsZipReaderCache, nsIZipReaderCache, nsIObserver, nsISupportsWeakReference)
    1: 
    1: nsZipReaderCache::nsZipReaderCache()
52251:   : mLock(nsnull)
52251:   , mZips(16)
    1: #ifdef ZIP_CACHE_HIT_RATE
    1:     ,
    1:     mZipCacheLookups(0),
    1:     mZipCacheHits(0),
    1:     mZipCacheFlushes(0),
    1:     mZipSyncMisses(0)
    1: #endif
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsZipReaderCache::Init(PRUint32 cacheSize)
    1: {
    1:   mCacheSize = cacheSize; 
    1:   
    1: // Register as a memory pressure observer 
    1:   nsCOMPtr<nsIObserverService> os = 
    1:            do_GetService("@mozilla.org/observer-service;1");
    1:   if (os)
    1:   {
    1:     os->AddObserver(this, "memory-pressure", PR_TRUE);
    1:     os->AddObserver(this, "chrome-flush-caches", PR_TRUE);
52253:     os->AddObserver(this, "flush-cache-entry", PR_TRUE);
    1:   }
    1: // ignore failure of the observer registration.
    1: 
    1:   mLock = PR_NewLock();
    1:   return mLock ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
20261: static PRBool
    1: DropZipReaderCache(nsHashKey *aKey, void *aData, void* closure)
    1: {
    1:   nsJAR* zip = (nsJAR*)aData;
    1:   zip->SetZipReaderCache(nsnull);
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsZipReaderCache::~nsZipReaderCache()
    1: {
    1:   if (mLock)
    1:     PR_DestroyLock(mLock);
    1:   mZips.Enumerate(DropZipReaderCache, nsnull);
    1: 
    1: #ifdef ZIP_CACHE_HIT_RATE
    1:   printf("nsZipReaderCache size=%d hits=%d lookups=%d rate=%f%% flushes=%d missed %d\n",
    1:          mCacheSize, mZipCacheHits, mZipCacheLookups, 
    1:          (float)mZipCacheHits / mZipCacheLookups, 
    1:          mZipCacheFlushes, mZipSyncMisses);
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsZipReaderCache::GetZip(nsIFile* zipFile, nsIZipReader* *result)
    1: {
18893:   NS_ENSURE_ARG_POINTER(zipFile);
    1:   nsresult rv;
39049:   nsCOMPtr<nsIZipReader> antiLockZipGrip;
    1:   nsAutoLock lock(mLock);
    1: 
    1: #ifdef ZIP_CACHE_HIT_RATE
    1:   mZipCacheLookups++;
    1: #endif
    1: 
52251:   nsCAutoString uri;
52251:   rv = zipFile->GetNativePath(uri);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
52251:   uri.Insert(NS_LITERAL_CSTRING("file:"), 0);
52251: 
52251:   nsCStringKey key(uri);
 3233:   nsJAR* zip = static_cast<nsJAR*>(static_cast<nsIZipReader*>(mZips.Get(&key))); // AddRefs
31399:   if (zip) {
    1: #ifdef ZIP_CACHE_HIT_RATE
    1:     mZipCacheHits++;
    1: #endif
    1:     zip->ClearReleaseTime();
    1:   }
    1:   else {
    1:     zip = new nsJAR();
    1:     if (zip == nsnull)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(zip);
    1:     zip->SetZipReaderCache(this);
    1: 
    1:     rv = zip->Open(zipFile);
    1:     if (NS_FAILED(rv)) {
    1:       NS_RELEASE(zip);
    1:       return rv;
    1:     }
    1: 
 3233:     PRBool collision = mZips.Put(&key, static_cast<nsIZipReader*>(zip)); // AddRefs to 2
    1:     NS_ASSERTION(!collision, "horked");
    1:   }
    1:   *result = zip;
    1:   return rv;
    1: }
    1: 
52251: NS_IMETHODIMP
52251: nsZipReaderCache::GetInnerZip(nsIFile* zipFile, const char *entry,
52251:                               nsIZipReader* *result)
52251: {
52251:   NS_ENSURE_ARG_POINTER(zipFile);
52251: 
52251:   nsCOMPtr<nsIZipReader> outerZipReader;
52251:   nsresult rv = GetZip(zipFile, getter_AddRefs(outerZipReader));
52251:   NS_ENSURE_SUCCESS(rv, rv);
52251: 
52251: #ifdef ZIP_CACHE_HIT_RATE
52251:   mZipCacheLookups++;
52251: #endif
52251: 
52251:   nsCAutoString uri;
52251:   rv = zipFile->GetNativePath(uri);
52251:   if (NS_FAILED(rv)) return rv;
52251: 
52251:   uri.Insert(NS_LITERAL_CSTRING("jar:"), 0);
52251:   uri.AppendLiteral("!/");
52251:   uri.Append(entry);
52251: 
52251:   nsCStringKey key(uri);
52251:   nsJAR* zip = static_cast<nsJAR*>(static_cast<nsIZipReader*>(mZips.Get(&key))); // AddRefs
52251:   if (zip) {
52251: #ifdef ZIP_CACHE_HIT_RATE
52251:     mZipCacheHits++;
52251: #endif
52251:     zip->ClearReleaseTime();
52251:   }
52251:   else {
52251:     zip = new nsJAR();
52251:     if (zip == nsnull)
52251:         return NS_ERROR_OUT_OF_MEMORY;
52251:     NS_ADDREF(zip);
52251:     zip->SetZipReaderCache(this);
52251: 
52251:     rv = zip->OpenInner(outerZipReader, entry);
52251:     if (NS_FAILED(rv)) {
52251:       NS_RELEASE(zip);
52251:       return rv;
52251:     }
52251: 
52251:     PRBool collision = mZips.Put(&key, static_cast<nsIZipReader*>(zip)); // AddRefs to 2
52251:     NS_ASSERTION(!collision, "horked");
52251:   }
52251:   *result = zip;
52251:   return rv;
52251: }
52251: 
20261: static PRBool
    1: FindOldestZip(nsHashKey *aKey, void *aData, void* closure)
    1: {
    1:   nsJAR** oldestPtr = (nsJAR**)closure;
    1:   nsJAR* oldest = *oldestPtr;
    1:   nsJAR* current = (nsJAR*)aData;
    1:   PRIntervalTime currentReleaseTime = current->GetReleaseTime();
    1:   if (currentReleaseTime != PR_INTERVAL_NO_TIMEOUT) {
    1:     if (oldest == nsnull ||
    1:         currentReleaseTime < oldest->GetReleaseTime()) {
    1:       *oldestPtr = current;
    1:     }    
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: struct ZipFindData {nsJAR* zip; PRBool found;}; 
    1: 
20261: static PRBool
    1: FindZip(nsHashKey *aKey, void *aData, void* closure)
    1: {
    1:   ZipFindData* find_data = (ZipFindData*)closure;
    1: 
    1:   if (find_data->zip == (nsJAR*)aData) {
    1:     find_data->found = PR_TRUE; 
    1:     return PR_FALSE;
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsZipReaderCache::ReleaseZip(nsJAR* zip)
    1: {
    1:   nsresult rv;
    1:   nsAutoLock lock(mLock);
    1: 
    1:   // It is possible that two thread compete for this zip. The dangerous 
    1:   // case is where one thread Releases the zip and discovers that the ref
    1:   // count has gone to one. Before it can call this ReleaseZip method
    1:   // another thread calls our GetZip method. The ref count goes to two. That
    1:   // second thread then Releases the zip and the ref count goes to one. It
    1:   // then tries to enter this ReleaseZip method and blocks while the first
    1:   // thread is still here. The first thread continues and remove the zip from 
    1:   // the cache and calls its Release method sending the ref count to 0 and
    1:   // deleting the zip. However, the second thread is still blocked at the
    1:   // start of ReleaseZip, but the 'zip' param now hold a reference to a
    1:   // deleted zip!
    1:   // 
    1:   // So, we are going to try safeguarding here by searching our hashtable while
    1:   // locked here for the zip. We return fast if it is not found. 
    1: 
    1:   ZipFindData find_data = {zip, PR_FALSE};
    1:   mZips.Enumerate(FindZip, &find_data);
    1:   if (!find_data.found) {
    1: #ifdef ZIP_CACHE_HIT_RATE
    1:     mZipSyncMisses++;
    1: #endif
    1:     return NS_OK;
    1:   }
    1: 
    1:   zip->SetReleaseTime();
    1: 
    1:   if (mZips.Count() <= mCacheSize)
    1:     return NS_OK;
    1: 
    1:   nsJAR* oldest = nsnull;
    1:   mZips.Enumerate(FindOldestZip, &oldest);
    1:   
    1:   // Because of the craziness above it is possible that there is no zip that
    1:   // needs removing. 
    1:   if (!oldest)
    1:     return NS_OK;
    1: 
    1: #ifdef ZIP_CACHE_HIT_RATE
    1:     mZipCacheFlushes++;
    1: #endif
    1: 
    1:   // Clear the cache pointer in case we gave out this oldest guy while
    1:   // his Release call was being made. Otherwise we could nest on ReleaseZip
    1:   // when the second owner calls Release and we are still here in this lock.
    1:   oldest->SetZipReaderCache(nsnull);
    1: 
    1:   // remove from hashtable
52251:   nsCAutoString uri;
52251:   rv = oldest->GetJarPath(uri);
52251:   if (NS_FAILED(rv))
52251:     return rv;
    1: 
52251:   if (zip->mOuterZipEntry.IsEmpty()) {
52251:     uri.Insert(NS_LITERAL_CSTRING("file:"), 0);
52251:   } else {
52251:     uri.Insert(NS_LITERAL_CSTRING("jar:"), 0);
52251:     uri.AppendLiteral("!/");
52251:     uri.Append(zip->mOuterZipEntry);
52251:   }
52251: 
52251:   nsCStringKey key(uri);
52251:   PRBool removed;
52251:   removed = mZips.Remove(&key);  // Releases
    1:   NS_ASSERTION(removed, "botched");
    1: 
    1:   return NS_OK;
    1: }
    1: 
20261: static PRBool
    1: FindFlushableZip(nsHashKey *aKey, void *aData, void* closure)
    1: {
    1:   nsHashKey** flushableKeyPtr = (nsHashKey**)closure;
    1:   nsJAR* current = (nsJAR*)aData;
    1:   
    1:   if (current->GetReleaseTime() != PR_INTERVAL_NO_TIMEOUT) {
    1:     *flushableKeyPtr = aKey;
    1:     current->SetZipReaderCache(nsnull);
    1:     return PR_FALSE;
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsZipReaderCache::Observe(nsISupports *aSubject,
    1:                           const char *aTopic, 
    1:                           const PRUnichar *aSomeData)
    1: {
    1:   if (strcmp(aTopic, "memory-pressure") == 0) {
    1:     nsAutoLock lock(mLock);
    1:     while (PR_TRUE) {
    1:       nsHashKey* flushable = nsnull;
    1:       mZips.Enumerate(FindFlushableZip, &flushable); 
    1:       if ( ! flushable )
    1:         break;
    1:       PRBool removed = mZips.Remove(flushable);  // Releases
    1:       NS_ASSERTION(removed, "botched");
    1: 
    1: #ifdef xDEBUG_jband
    1:       printf("flushed something from the jar cache\n");
    1: #endif
    1:     }
    1:   }
    1:   else if (strcmp(aTopic, "chrome-flush-caches") == 0) {
    1:     mZips.Enumerate(DropZipReaderCache, nsnull);
    1:     mZips.Reset();
    1:   }
52253:   else if (strcmp(aTopic, "flush-cache-entry") == 0) {
52253:     nsCOMPtr<nsIFile> file = do_QueryInterface(aSubject);
52253:     if (!file)
52253:       return NS_OK;
52253: 
52253:     nsCAutoString uri;
52253:     if (NS_FAILED(file->GetNativePath(uri)))
52253:       return NS_OK;
52253: 
52253:     uri.Insert(NS_LITERAL_CSTRING("file:"), 0);
52253:     nsCStringKey key(uri);
52253: 
52253:     nsAutoLock lock(mLock);    
52253:     nsJAR* zip = static_cast<nsJAR*>(static_cast<nsIZipReader*>(mZips.Get(&key)));
52253:     if (!zip)
52253:       return NS_OK;
52253: 
52253: #ifdef ZIP_CACHE_HIT_RATE
52253:     mZipCacheFlushes++;
52253: #endif
52253: 
52253:     zip->SetZipReaderCache(nsnull);
52253: 
52253:     mZips.Remove(&key);
52253:     NS_RELEASE(zip);
52253:   }
    1:   return NS_OK;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
