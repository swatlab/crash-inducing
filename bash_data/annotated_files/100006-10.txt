82129: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
90129:  */
90129: /* This Source Code Form is subject to the terms of the Mozilla Public
90129:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
90129:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
68933: 
97569: #ifndef gc_marking_h___
97569: #define gc_marking_h___
68933: 
68933: #include "jsgc.h"
68933: #include "jscntxt.h"
80202: #include "jslock.h"
68933: 
82129: #include "gc/Barrier.h"
80202: #include "js/TemplateLib.h"
68933: 
97569: extern "C" {
97569: struct JSContext;
97569: struct JSFunction;
97569: struct JSObject;
97569: struct JSScript;
97569: }
97569: 
97569: class JSAtom;
97569: class JSLinearString;
97569: 
68933: namespace js {
97569: 
97569: class ArgumentsObject;
97569: class BaseShape;
97569: class GlobalObject;
97569: class UnownedBaseShape;
97569: struct Shape;
97569: 
97569: template<class, typename> class HeapPtr;
97569: 
68933: namespace gc {
68933: 
90129: /*** Object Marking ***/
90129: 
90129: /*
90129:  * These functions expose marking functionality for all of the different GC
90129:  * thing kinds. For each GC thing, there are several variants. As an example,
90129:  * these are the variants generated for JSObject. They are listed from most to
90129:  * least desirable for use:
90129:  *
90129:  * MarkObject(JSTracer *trc, const HeapPtr<JSObject> &thing, const char *name);
90129:  *     This function should be used for marking JSObjects, in preference to all
90129:  *     others below. Use it when you have HeapPtr<JSObject>, which
90129:  *     automatically implements write barriers.
90129:  *
90129:  * MarkObjectRoot(JSTracer *trc, JSObject *thing, const char *name);
90129:  *     This function is only valid during the root marking phase of GC (i.e.,
90129:  *     when MarkRuntime is on the stack).
90129:  *
90129:  * MarkObjectUnbarriered(JSTracer *trc, JSObject *thing, const char *name);
90129:  *     Like MarkObject, this function can be called at any time. It is more
90129:  *     forgiving, since it doesn't demand a HeapPtr as an argument. Its use
90129:  *     should always be accompanied by a comment explaining how write barriers
90129:  *     are implemented for the given field.
90129:  *
90129:  * Additionally, the functions MarkObjectRange and MarkObjectRootRange are
90129:  * defined for marking arrays of object pointers.
90129:  */
90129: #define DeclMarker(base, type)                                                                    \
90409: void Mark##base(JSTracer *trc, HeapPtr<type> *thing, const char *name);                           \
90409: void Mark##base##Root(JSTracer *trc, type **thingp, const char *name);                            \
91557: void Mark##base##Unbarriered(JSTracer *trc, type **thingp, const char *name);                     \
90129: void Mark##base##Range(JSTracer *trc, size_t len, HeapPtr<type> *thing, const char *name);        \
99246: void Mark##base##RootRange(JSTracer *trc, size_t len, type **thing, const char *name);            \
99246: bool Is##base##Marked(type **thingp);                                                             \
99246: bool Is##base##Marked(HeapPtr<type> *thingp);
90129: 
90129: DeclMarker(BaseShape, BaseShape)
91557: DeclMarker(BaseShape, UnownedBaseShape)
90129: DeclMarker(Object, ArgumentsObject)
99246: DeclMarker(Object, DebugScopeObject)
90129: DeclMarker(Object, GlobalObject)
90129: DeclMarker(Object, JSObject)
90129: DeclMarker(Object, JSFunction)
90129: DeclMarker(Script, JSScript)
90129: DeclMarker(Shape, Shape)
90129: DeclMarker(String, JSAtom)
90129: DeclMarker(String, JSString)
90129: DeclMarker(String, JSFlatString)
90129: DeclMarker(String, JSLinearString)
90129: DeclMarker(TypeObject, types::TypeObject)
90129: #if JS_HAS_XML_SUPPORT
90129: DeclMarker(XML, JSXML)
90129: #endif
90129: 
97569: #undef DeclMarker
97569: 
90129: /*** Externally Typed Marking ***/
90129: 
90129: /*
90129:  * Note: this must only be called by the GC and only when we are tracing through
90129:  * MarkRoots. It is explicitly for ConservativeStackMarking and should go away
90129:  * after we transition to exact rooting.
90129:  */
68933: void
93352: MarkKind(JSTracer *trc, void **thingp, JSGCTraceKind kind);
73561: 
68933: void
93352: MarkGCThingRoot(JSTracer *trc, void **thingp, const char *name);
68933: 
90129: /*** ID Marking ***/
82129: 
82129: void
97032: MarkId(JSTracer *trc, EncapsulatedId *id, const char *name);
82129: 
82129: void
90419: MarkIdRoot(JSTracer *trc, jsid *id, const char *name);
82129: 
82129: void
99246: MarkIdUnbarriered(JSTracer *trc, jsid *id, const char *name);
99246: 
99246: void
97032: MarkIdRange(JSTracer *trc, size_t len, HeapId *vec, const char *name);
82129: 
82129: void
90129: MarkIdRootRange(JSTracer *trc, size_t len, jsid *vec, const char *name);
68933: 
90129: /*** Value Marking ***/
68933: 
68933: void
98291: MarkValue(JSTracer *trc, EncapsulatedValue *v, const char *name);
68933: 
90129: void
98291: MarkValueRange(JSTracer *trc, size_t len, EncapsulatedValue *vec, const char *name);
90129: 
90129: void
90302: MarkValueRoot(JSTracer *trc, Value *v, const char *name);
90129: 
90129: void
90302: MarkValueRootRange(JSTracer *trc, size_t len, Value *vec, const char *name);
90129: 
90129: inline void
90302: MarkValueRootRange(JSTracer *trc, Value *begin, Value *end, const char *name)
90129: {
90129:     MarkValueRootRange(trc, end - begin, begin, name);
90129: }
90129: 
99246: bool
99246: IsValueMarked(Value *v);
99246: 
91146: /*** Slot Marking ***/
90129: 
90129: void
91146: MarkSlot(JSTracer *trc, HeapSlot *s, const char *name);
91146: 
91146: void
91557: MarkArraySlots(JSTracer *trc, size_t len, HeapSlot *vec, const char *name);
91557: 
91557: void
91557: MarkObjectSlots(JSTracer *trc, JSObject *obj, uint32_t start, uint32_t nslots);
90129: 
94620: void
94620: MarkCrossCompartmentObjectUnbarriered(JSTracer *trc, JSObject **obj, const char *name);
94620: 
94620: void
94620: MarkCrossCompartmentScriptUnbarriered(JSTracer *trc, JSScript **script, const char *name);
94620: 
73561: /*
73561:  * Mark a value that may be in a different compartment from the compartment
73561:  * being GC'd. (Although it won't be marked if it's in the wrong compartment.)
73561:  */
73561: void
91146: MarkCrossCompartmentSlot(JSTracer *trc, HeapSlot *s, const char *name);
91146: 
91557: 
91146: /*** Special Cases ***/
91146: 
91557: /*
91557:  * The unioned HeapPtr stored in script->globalObj needs special treatment to
91557:  * typecheck correctly.
91557:  */
91557: void
91557: MarkObject(JSTracer *trc, HeapPtr<GlobalObject, JSScript *> *thingp, const char *name);
91557: 
91146: /* Direct value access used by the write barriers and the methodjit. */
91146: void
91146: MarkValueUnbarriered(JSTracer *trc, Value *v, const char *name);
73561: 
90129: /*
90129:  * MarkChildren<JSObject> is exposed solely for preWriteBarrier on
90129:  * JSObject::TradeGuts. It should not be considered external interface.
90129:  */
82129: void
68933: MarkChildren(JSTracer *trc, JSObject *obj);
68933: 
81128: /*
85055:  * Trace through the shape and any shapes it contains to mark
90129:  * non-shape children. This is exposed to the JS API as
90129:  * JS_TraceShapeCycleCollectorChildren.
84173:  */
85055: void
90419: MarkCycleCollectorChildren(JSTracer *trc, Shape *shape);
84173: 
90410: void
90410: PushArena(GCMarker *gcmarker, ArenaHeader *aheader);
90410: 
90129: /*** Generic ***/
90410: 
84173: /*
90129:  * The Mark() functions interface should only be used by code that must be
90129:  * templated.  Other uses should use the more specific, type-named functions.
81128:  */
90129: 
81128: inline void
90302: Mark(JSTracer *trc, HeapValue *v, const char *name)
81128: {
81128:     MarkValue(trc, v, name);
81128: }
81128: 
81128: inline void
90409: Mark(JSTracer *trc, HeapPtr<JSObject> *o, const char *name)
81128: {
82129:     MarkObject(trc, o, name);
81128: }
81128: 
82348: inline void
95296: Mark(JSTracer *trc, HeapPtr<JSScript> *o, const char *name)
95296: {
95296:     MarkScript(trc, o, name);
95296: }
95296: 
98644: #if JS_HAS_XML_SUPPORT
95296: inline void
90409: Mark(JSTracer *trc, HeapPtr<JSXML> *xml, const char *name)
82348: {
82348:     MarkXML(trc, xml, name);
82348: }
98644: #endif
82348: 
99246: bool
99246: IsCellMarked(Cell **thingp);
99246: 
81128: inline bool
99246: IsMarked(EncapsulatedValue *v)
81128: {
99246:     if (!v->isMarkable())
81128:         return true;
99246:     return IsValueMarked(v->unsafeGet());
81128: }
81128: 
81128: inline bool
99246: IsMarked(HeapPtrObject *objp)
81128: {
99246:     return IsObjectMarked(objp);
99246: }
99246: 
99246: inline bool
99246: IsMarked(HeapPtrScript *scriptp)
99246: {
99246:     return IsScriptMarked(scriptp);
81128: }
81128: 
95296: inline Cell *
95296: ToMarkable(const Value &v)
95296: {
95296:     if (v.isMarkable())
95296:         return (Cell *)v.toGCThing();
95296:     return NULL;
95296: }
95296: 
95296: inline Cell *
95296: ToMarkable(Cell *cell)
95296: {
95296:     return cell;
95296: }
95296: 
95296: inline JSGCTraceKind
95296: TraceKind(const Value &v)
95296: {
95296:     JS_ASSERT(v.isMarkable());
95296:     if (v.isObject())
95296:         return JSTRACE_OBJECT;
95296:     return JSTRACE_STRING;
95296: }
95296: 
95296: inline JSGCTraceKind
95296: TraceKind(JSObject *obj)
95296: {
95296:     return JSTRACE_OBJECT;
95296: }
95296: 
95296: inline JSGCTraceKind
95296: TraceKind(JSScript *script)
95296: {
95296:     return JSTRACE_SCRIPT;
95296: }
95296: 
82129: } /* namespace gc */
82129: 
82129: void
82129: TraceChildren(JSTracer *trc, void *thing, JSGCTraceKind kind);
82129: 
82129: void
82129: CallTracer(JSTracer *trc, void *thing, JSGCTraceKind kind);
82129: 
82129: } /* namespace js */
68933: 
97569: #endif /* gc_marking_h___ */
